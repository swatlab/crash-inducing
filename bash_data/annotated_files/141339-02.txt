     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsINameSpaceManager.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsIBoxObject.h"
     1: #include "nsTreeUtils.h"
     1: #include "nsTreeContentView.h"
     1: #include "nsChildIterator.h"
 80058: #include "nsDOMClassInfoID.h"
108290: #include "nsError.h"
 68780: #include "nsEventStates.h"
 94340: #include "nsINodeInfo.h"
     1: #include "nsIXULSortService.h"
 48458: #include "nsContentUtils.h"
 48457: #include "nsTreeBodyFrame.h"
 51350: #include "mozilla/dom/Element.h"
 80058: #include "nsServiceManagerUtils.h"
 51350: 
 51350: namespace dom = mozilla::dom;
 48457: 
 48457: #define NS_ENSURE_NATIVE_COLUMN(_col)                                \
 48457:   nsRefPtr<nsTreeColumn> col = nsTreeBodyFrame::GetColumnImpl(_col); \
 48457:   if (!col) {                                                        \
 48457:     return NS_ERROR_INVALID_ARG;                                     \
 48457:   }
     1: 
     1: // A content model view implementation for the tree.
     1: 
     1: #define ROW_FLAG_CONTAINER      0x01
     1: #define ROW_FLAG_OPEN           0x02
     1: #define ROW_FLAG_EMPTY          0x04
     1: #define ROW_FLAG_SEPARATOR      0x08
     1: 
     1: class Row
     1: {
     1:   public:
108991:     Row(nsIContent* aContent, int32_t aParentIndex)
     1:       : mContent(aContent), mParentIndex(aParentIndex),
     1:         mSubtreeSize(0), mFlags(0) {
     1:     }
     1: 
     1:     ~Row() {
     1:     }
     1: 
 79445:     void SetContainer(bool aContainer) {
     1:       aContainer ? mFlags |= ROW_FLAG_CONTAINER : mFlags &= ~ROW_FLAG_CONTAINER;
     1:     }
 79445:     bool IsContainer() { return mFlags & ROW_FLAG_CONTAINER; }
     1: 
 79445:     void SetOpen(bool aOpen) {
     1:       aOpen ? mFlags |= ROW_FLAG_OPEN : mFlags &= ~ROW_FLAG_OPEN;
     1:     }
 79445:     bool IsOpen() { return !!(mFlags & ROW_FLAG_OPEN); }
     1: 
 79445:     void SetEmpty(bool aEmpty) {
     1:       aEmpty ? mFlags |= ROW_FLAG_EMPTY : mFlags &= ~ROW_FLAG_EMPTY;
     1:     }
 79445:     bool IsEmpty() { return !!(mFlags & ROW_FLAG_EMPTY); }
     1: 
 79445:     void SetSeparator(bool aSeparator) {
     1:       aSeparator ? mFlags |= ROW_FLAG_SEPARATOR : mFlags &= ~ROW_FLAG_SEPARATOR;
     1:     }
 79445:     bool IsSeparator() { return !!(mFlags & ROW_FLAG_SEPARATOR); }
     1: 
     1:     // Weak reference to a content item.
     1:     nsIContent*         mContent;
     1: 
     1:     // The parent index of the item, set to -1 for the top level items.
108991:     int32_t             mParentIndex;
     1: 
     1:     // Subtree size for this item.
108991:     int32_t             mSubtreeSize;
     1: 
     1:   private:
     1:     // State flags
108991:     int8_t		mFlags;
     1: };
     1: 
     1: 
     1: // We don't reference count the reference to the document
     1: // If the document goes away first, we'll be informed and we
     1: // can drop our reference.
     1: // If we go away first, we'll get rid of ourselves from the
     1: // document's observer list.
     1: 
     1: nsTreeContentView::nsTreeContentView(void) :
106838:   mBoxObject(nullptr),
106838:   mSelection(nullptr),
106838:   mRoot(nullptr),
106838:   mDocument(nullptr)
     1: {
     1: }
     1: 
     1: nsTreeContentView::~nsTreeContentView(void)
     1: {
     1:   // Remove ourselves from mDocument's observers.
     1:   if (mDocument)
     1:     mDocument->RemoveObserver(this);
     1: }
     1: 
     1: nsresult
     1: NS_NewTreeContentView(nsITreeView** aResult)
     1: {
     1:   *aResult = new nsTreeContentView;
     1:   if (! *aResult)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   NS_ADDREF(*aResult);
     1:   return NS_OK;
     1: }
     1: 
 31735: NS_IMPL_CYCLE_COLLECTION_4(nsTreeContentView,
 31735:                            mBoxObject,
 31735:                            mSelection,
 31735:                            mRoot,
 31735:                            mBody)
     1: 
 31735: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsTreeContentView)
 31735: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsTreeContentView)
 31735: 
 40490: DOMCI_DATA(TreeContentView, nsTreeContentView)
 40490: 
 31735: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsTreeContentView)
     1:   NS_INTERFACE_MAP_ENTRY(nsITreeView)
     1:   NS_INTERFACE_MAP_ENTRY(nsITreeContentView)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDocumentObserver)
     1:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsITreeContentView)
 25059:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(TreeContentView)
     1: NS_INTERFACE_MAP_END
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::GetRowCount(int32_t* aRowCount)
     1: {
 24551:   *aRowCount = mRows.Length();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeContentView::GetSelection(nsITreeSelection** aSelection)
     1: {
     1:   NS_IF_ADDREF(*aSelection = mSelection);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
 48458: nsTreeContentView::CanTrustTreeSelection(nsISupports* aValue)
 48458: {
 48458:   // Untrusted content is only allowed to specify known-good views
120109:   if (nsContentUtils::IsCallerChrome())
 80486:     return true;
 48458:   nsCOMPtr<nsINativeTreeSelection> nativeTreeSel = do_QueryInterface(aValue);
 48458:   return nativeTreeSel && NS_SUCCEEDED(nativeTreeSel->EnsureNative());
 48458: }
 48458: 
     1: NS_IMETHODIMP
     1: nsTreeContentView::SetSelection(nsITreeSelection* aSelection)
     1: {
 48458:   NS_ENSURE_TRUE(!aSelection || CanTrustTreeSelection(aSelection),
 48458:                  NS_ERROR_DOM_SECURITY_ERR);
 48458: 
     1:   mSelection = aSelection;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
134832: nsTreeContentView::GetRowProperties(int32_t aIndex, nsAString& aProps)
     1: {
108991:   NS_PRECONDITION(aIndex >= 0 && aIndex < int32_t(mRows.Length()), "bad index");
108991:   if (aIndex < 0 || aIndex >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   Row* row = mRows[aIndex];
 25233:   nsIContent* realRow;
     1:   if (row->IsSeparator())
     1:     realRow = row->mContent;
     1:   else
 25233:     realRow = nsTreeUtils::GetImmediateChild(row->mContent, nsGkAtoms::treerow);
     1: 
     1:   if (realRow) {
134832:     realRow->GetAttr(kNameSpaceID_None, nsGkAtoms::properties, aProps);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
134832: nsTreeContentView::GetCellProperties(int32_t aRow, nsITreeColumn* aCol,
134832:                                      nsAString& aProps)
     1: {
 48457:   NS_ENSURE_NATIVE_COLUMN(aCol);
108991:   NS_PRECONDITION(aRow >= 0 && aRow < int32_t(mRows.Length()), "bad row");
108991:   if (aRow < 0 || aRow >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   Row* row = mRows[aRow];
 25233:   nsIContent* realRow =
 25233:     nsTreeUtils::GetImmediateChild(row->mContent, nsGkAtoms::treerow);
     1:   if (realRow) {
     1:     nsIContent* cell = GetCell(realRow, aCol);
     1:     if (cell) {
134832:       cell->GetAttr(kNameSpaceID_None, nsGkAtoms::properties, aProps);
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
134832: nsTreeContentView::GetColumnProperties(nsITreeColumn* aCol, nsAString& aProps)
     1: {
 48457:   NS_ENSURE_NATIVE_COLUMN(aCol);
     1:   nsCOMPtr<nsIDOMElement> element;
     1:   aCol->GetElement(getter_AddRefs(element));
     1: 
134832:   element->GetAttribute(NS_LITERAL_STRING("properties"), aProps);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::IsContainer(int32_t aIndex, bool* _retval)
     1: {
108991:   NS_PRECONDITION(aIndex >= 0 && aIndex < int32_t(mRows.Length()), "bad index");
108991:   if (aIndex < 0 || aIndex >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   *_retval = mRows[aIndex]->IsContainer();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::IsContainerOpen(int32_t aIndex, bool* _retval)
     1: {
108991:   NS_PRECONDITION(aIndex >= 0 && aIndex < int32_t(mRows.Length()), "bad index");
108991:   if (aIndex < 0 || aIndex >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   *_retval = mRows[aIndex]->IsOpen();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::IsContainerEmpty(int32_t aIndex, bool* _retval)
     1: {
108991:   NS_PRECONDITION(aIndex >= 0 && aIndex < int32_t(mRows.Length()), "bad index");
108991:   if (aIndex < 0 || aIndex >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   *_retval = mRows[aIndex]->IsEmpty();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::IsSeparator(int32_t aIndex, bool *_retval)
     1: {
108991:   NS_PRECONDITION(aIndex >= 0 && aIndex < int32_t(mRows.Length()), "bad index");
108991:   if (aIndex < 0 || aIndex >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   *_retval = mRows[aIndex]->IsSeparator();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsTreeContentView::IsSorted(bool *_retval)
     1: {
 80486:   *_retval = false;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::CanDrop(int32_t aIndex, int32_t aOrientation,
 79445:                            nsIDOMDataTransfer* aDataTransfer, bool *_retval)
     1: {
108991:   NS_PRECONDITION(aIndex >= 0 && aIndex < int32_t(mRows.Length()), "bad index");
108991:   if (aIndex < 0 || aIndex >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 80486:   *_retval = false;
     1:  
     1:   return NS_OK;
     1: }
     1:  
     1: NS_IMETHODIMP
108991: nsTreeContentView::Drop(int32_t aRow, int32_t aOrientation, nsIDOMDataTransfer* aDataTransfer)
     1: {
108991:   NS_PRECONDITION(aRow >= 0 && aRow < int32_t(mRows.Length()), "bad row");
108991:   if (aRow < 0 || aRow >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::GetParentIndex(int32_t aRowIndex, int32_t* _retval)
     1: {
108991:   NS_PRECONDITION(aRowIndex >= 0 && aRowIndex < int32_t(mRows.Length()),
 24551:                   "bad row index");
108991:   if (aRowIndex < 0 || aRowIndex >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   *_retval = mRows[aRowIndex]->mParentIndex;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::HasNextSibling(int32_t aRowIndex, int32_t aAfterIndex, bool* _retval)
     1: {
108991:   NS_PRECONDITION(aRowIndex >= 0 && aRowIndex < int32_t(mRows.Length()),
 24551:                   "bad row index");
108991:   if (aRowIndex < 0 || aRowIndex >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
     1:   // We have a next sibling if the row is not the last in the subtree.
108991:   int32_t parentIndex = mRows[aRowIndex]->mParentIndex;
     1:   if (parentIndex >= 0) {
     1:     // Compute the last index in this subtree.
108991:     int32_t lastIndex = parentIndex + (mRows[parentIndex])->mSubtreeSize;
 24551:     Row* row = mRows[lastIndex];
     1:     while (row->mParentIndex != parentIndex) {
     1:       lastIndex = row->mParentIndex;
 24551:       row = mRows[lastIndex];
     1:     }
     1: 
     1:     *_retval = aRowIndex < lastIndex;
     1:   }
     1:   else {
108991:     *_retval = uint32_t(aRowIndex) < mRows.Length() - 1;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::GetLevel(int32_t aIndex, int32_t* _retval)
     1: {
108991:   NS_PRECONDITION(aIndex >= 0 && aIndex < int32_t(mRows.Length()), "bad index");
108991:   if (aIndex < 0 || aIndex >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
108991:   int32_t level = 0;
 24551:   Row* row = mRows[aIndex];
     1:   while (row->mParentIndex >= 0) {
     1:     level++;
 24551:     row = mRows[row->mParentIndex];
     1:   }
     1:   *_retval = level;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1:  NS_IMETHODIMP
108991: nsTreeContentView::GetImageSrc(int32_t aRow, nsITreeColumn* aCol, nsAString& _retval)
     1: {
     1:   _retval.Truncate();
 48457:   NS_ENSURE_NATIVE_COLUMN(aCol);
108991:   NS_PRECONDITION(aRow >= 0 && aRow < int32_t(mRows.Length()), "bad row");
108991:   if (aRow < 0 || aRow >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   Row* row = mRows[aRow];
     1: 
 25233:   nsIContent* realRow =
 25233:     nsTreeUtils::GetImmediateChild(row->mContent, nsGkAtoms::treerow);
     1:   if (realRow) {
     1:     nsIContent* cell = GetCell(realRow, aCol);
     1:     if (cell)
     1:       cell->GetAttr(kNameSpaceID_None, nsGkAtoms::src, _retval);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::GetProgressMode(int32_t aRow, nsITreeColumn* aCol, int32_t* _retval)
     1: {
 48457:   NS_ENSURE_NATIVE_COLUMN(aCol);
108991:   NS_PRECONDITION(aRow >= 0 && aRow < int32_t(mRows.Length()), "bad row");
108991:   if (aRow < 0 || aRow >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
     1:   *_retval = nsITreeView::PROGRESS_NONE;
     1: 
 24551:   Row* row = mRows[aRow];
     1: 
 25233:   nsIContent* realRow =
 25233:     nsTreeUtils::GetImmediateChild(row->mContent, nsGkAtoms::treerow);
     1:   if (realRow) {
     1:     nsIContent* cell = GetCell(realRow, aCol);
     1:     if (cell) {
     1:       static nsIContent::AttrValuesArray strings[] =
106838:         {&nsGkAtoms::normal, &nsGkAtoms::undetermined, nullptr};
     1:       switch (cell->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::mode,
     1:                                     strings, eCaseMatters)) {
     1:         case 0: *_retval = nsITreeView::PROGRESS_NORMAL; break;
     1:         case 1: *_retval = nsITreeView::PROGRESS_UNDETERMINED; break;
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::GetCellValue(int32_t aRow, nsITreeColumn* aCol, nsAString& _retval)
     1: {
     1:   _retval.Truncate();
 48457:   NS_ENSURE_NATIVE_COLUMN(aCol);
108991:   NS_PRECONDITION(aRow >= 0 && aRow < int32_t(mRows.Length()), "bad row");
108991:   if (aRow < 0 || aRow >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   Row* row = mRows[aRow];
     1: 
 25233:   nsIContent* realRow =
 25233:     nsTreeUtils::GetImmediateChild(row->mContent, nsGkAtoms::treerow);
     1:   if (realRow) {
     1:     nsIContent* cell = GetCell(realRow, aCol);
     1:     if (cell)
     1:       cell->GetAttr(kNameSpaceID_None, nsGkAtoms::value, _retval);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::GetCellText(int32_t aRow, nsITreeColumn* aCol, nsAString& _retval)
     1: {
     1:   _retval.Truncate();
 48457:   NS_ENSURE_NATIVE_COLUMN(aCol);
108991:   NS_PRECONDITION(aRow >= 0 && aRow < int32_t(mRows.Length()), "bad row");
     1:   NS_PRECONDITION(aCol, "bad column");
     1: 
108991:   if (aRow < 0 || aRow >= int32_t(mRows.Length()) || !aCol)
     1:     return NS_ERROR_INVALID_ARG;
     1: 
 24551:   Row* row = mRows[aRow];
     1: 
     1:   // Check for a "label" attribute - this is valid on an <treeitem>
 64496:   // with a single implied column.
     1:   if (row->mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, _retval)
     1:       && !_retval.IsEmpty())
     1:     return NS_OK;
     1: 
     1:   nsIAtom *rowTag = row->mContent->Tag();
 64496:   if (rowTag == nsGkAtoms::treeitem && row->mContent->IsXUL()) {
 25233:     nsIContent* realRow =
 25233:       nsTreeUtils::GetImmediateChild(row->mContent, nsGkAtoms::treerow);
     1:     if (realRow) {
     1:       nsIContent* cell = GetCell(realRow, aCol);
     1:       if (cell)
     1:         cell->GetAttr(kNameSpaceID_None, nsGkAtoms::label, _retval);
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeContentView::SetTree(nsITreeBoxObject* aTree)
     1: {
  1570:   ClearRows();
  1570: 
     1:   mBoxObject = aTree;
     1: 
141339:   MOZ_ASSERT(!mRoot, "mRoot should have been cleared out by ClearRows");
141339: 
141339:   if (aTree) {
     1:     // Get our root element
     1:     nsCOMPtr<nsIBoxObject> boxObject = do_QueryInterface(mBoxObject);
141339:     if (!boxObject) {
141339:       mBoxObject = nullptr;
141339:       return NS_ERROR_INVALID_ARG;
141339:     }
     1:     nsCOMPtr<nsIDOMElement> element;
     1:     boxObject->GetElement(getter_AddRefs(element));
     1: 
     1:     mRoot = do_QueryInterface(element);
 31735:     NS_ENSURE_STATE(mRoot);
     1: 
     1:     // Add ourselves to document's observers.
     1:     nsIDocument* document = mRoot->GetDocument();
     1:     if (document) {
     1:       document->AddObserver(this);
     1:       mDocument = document;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMElement> bodyElement;
     1:     mBoxObject->GetTreeBody(getter_AddRefs(bodyElement));
     1:     if (bodyElement) {
  1570:       mBody = do_QueryInterface(bodyElement);
108991:       int32_t index = 0;
  1570:       Serialize(mBody, -1, &index, mRows);
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::ToggleOpenState(int32_t aIndex)
     1: {
108991:   NS_PRECONDITION(aIndex >= 0 && aIndex < int32_t(mRows.Length()), "bad index");
108991:   if (aIndex < 0 || aIndex >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
     1:   // We don't serialize content right here, since content might be generated
     1:   // lazily.
 24551:   Row* row = mRows[aIndex];
     1: 
     1:   if (row->IsOpen())
 80486:     row->mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::open, NS_LITERAL_STRING("false"), true);
     1:   else
 80486:     row->mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::open, NS_LITERAL_STRING("true"), true);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeContentView::CycleHeader(nsITreeColumn* aCol)
     1: {
 48457:   NS_ENSURE_NATIVE_COLUMN(aCol);
     1: 
     1:   if (!mRoot)
     1:     return NS_OK;
     1: 
     1:   nsCOMPtr<nsIDOMElement> element;
     1:   aCol->GetElement(getter_AddRefs(element));
     1:   if (element) {
     1:     nsCOMPtr<nsIContent> column = do_QueryInterface(element);
     1:     nsAutoString sort;
     1:     column->GetAttr(kNameSpaceID_None, nsGkAtoms::sort, sort);
     1:     if (!sort.IsEmpty()) {
     1:       nsCOMPtr<nsIXULSortService> xs = do_GetService("@mozilla.org/xul/xul-sort-service;1");
     1:       if (xs) {
     1:         nsAutoString sortdirection;
     1:         static nsIContent::AttrValuesArray strings[] =
106838:           {&nsGkAtoms::ascending, &nsGkAtoms::descending, nullptr};
     1:         switch (column->FindAttrValueIn(kNameSpaceID_None,
     1:                                         nsGkAtoms::sortDirection,
     1:                                         strings, eCaseMatters)) {
     1:           case 0: sortdirection.AssignLiteral("descending"); break;
     1:           case 1: sortdirection.AssignLiteral("natural"); break;
     1:           default: sortdirection.AssignLiteral("ascending"); break;
     1:         }
     1: 
 43693:         nsAutoString hints;
 43693:         column->GetAttr(kNameSpaceID_None, nsGkAtoms::sorthints, hints);
 43693:         sortdirection.AppendLiteral(" ");
 43693:         sortdirection += hints;
 43693: 
     1:         nsCOMPtr<nsIDOMNode> rootnode = do_QueryInterface(mRoot);
     1:         xs->Sort(rootnode, sort, sortdirection);
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeContentView::SelectionChanged()
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::CycleCell(int32_t aRow, nsITreeColumn* aCol)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::IsEditable(int32_t aRow, nsITreeColumn* aCol, bool* _retval)
     1: {
 80486:   *_retval = false;
 48457:   NS_ENSURE_NATIVE_COLUMN(aCol);
108991:   NS_PRECONDITION(aRow >= 0 && aRow < int32_t(mRows.Length()), "bad row");
108991:   if (aRow < 0 || aRow >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 80486:   *_retval = true;
     1: 
 24551:   Row* row = mRows[aRow];
     1: 
 25233:   nsIContent* realRow =
 25233:     nsTreeUtils::GetImmediateChild(row->mContent, nsGkAtoms::treerow);
     1:   if (realRow) {
     1:     nsIContent* cell = GetCell(realRow, aCol);
     1:     if (cell && cell->AttrValueIs(kNameSpaceID_None, nsGkAtoms::editable,
     1:                                   nsGkAtoms::_false, eCaseMatters)) {
 80486:       *_retval = false;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::IsSelectable(int32_t aRow, nsITreeColumn* aCol, bool* _retval)
     1: {
 48457:   NS_ENSURE_NATIVE_COLUMN(aCol);
108991:   NS_PRECONDITION(aRow >= 0 && aRow < int32_t(mRows.Length()), "bad row");
108991:   if (aRow < 0 || aRow >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 80486:   *_retval = true;
     1: 
 24551:   Row* row = mRows[aRow];
     1: 
 25233:   nsIContent* realRow =
 25233:     nsTreeUtils::GetImmediateChild(row->mContent, nsGkAtoms::treerow);
     1:   if (realRow) {
     1:     nsIContent* cell = GetCell(realRow, aCol);
     1:     if (cell && cell->AttrValueIs(kNameSpaceID_None, nsGkAtoms::selectable,
     1:                                   nsGkAtoms::_false, eCaseMatters)) {
 80486:       *_retval = false;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::SetCellValue(int32_t aRow, nsITreeColumn* aCol, const nsAString& aValue)
     1: {
 48457:   NS_ENSURE_NATIVE_COLUMN(aCol);
108991:   NS_PRECONDITION(aRow >= 0 && aRow < int32_t(mRows.Length()), "bad row");
108991:   if (aRow < 0 || aRow >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   Row* row = mRows[aRow];
     1: 
 25233:   nsIContent* realRow =
 25233:     nsTreeUtils::GetImmediateChild(row->mContent, nsGkAtoms::treerow);
     1:   if (realRow) {
     1:     nsIContent* cell = GetCell(realRow, aCol);
     1:     if (cell)
 80486:       cell->SetAttr(kNameSpaceID_None, nsGkAtoms::value, aValue, true);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::SetCellText(int32_t aRow, nsITreeColumn* aCol, const nsAString& aValue)
     1: {
 48457:   NS_ENSURE_NATIVE_COLUMN(aCol);
108991:   NS_PRECONDITION(aRow >= 0 && aRow < int32_t(mRows.Length()), "bad row");
108991:   if (aRow < 0 || aRow >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   Row* row = mRows[aRow];
     1: 
 25233:   nsIContent* realRow =
 25233:     nsTreeUtils::GetImmediateChild(row->mContent, nsGkAtoms::treerow);
     1:   if (realRow) {
     1:     nsIContent* cell = GetCell(realRow, aCol);
     1:     if (cell)
 80486:       cell->SetAttr(kNameSpaceID_None, nsGkAtoms::label, aValue, true);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeContentView::PerformAction(const PRUnichar* aAction)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::PerformActionOnRow(const PRUnichar* aAction, int32_t aRow)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::PerformActionOnCell(const PRUnichar* aAction, int32_t aRow, nsITreeColumn* aCol)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::GetItemAtIndex(int32_t aIndex, nsIDOMElement** _retval)
     1: {
108991:   NS_PRECONDITION(aIndex >= 0 && aIndex < int32_t(mRows.Length()), "bad index");
108991:   if (aIndex < 0 || aIndex >= int32_t(mRows.Length()))
     1:     return NS_ERROR_INVALID_ARG;   
     1: 
 24551:   Row* row = mRows[aIndex];
     1:   row->mContent->QueryInterface(NS_GET_IID(nsIDOMElement), (void**)_retval);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeContentView::GetIndexOfItem(nsIDOMElement* aItem, int32_t* _retval)
     1: {
     1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aItem);
     1:   *_retval = FindContent(content);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsTreeContentView::AttributeChanged(nsIDocument*  aDocument,
 51350:                                     dom::Element* aElement,
108991:                                     int32_t       aNameSpaceID,
     1:                                     nsIAtom*      aAttribute,
108991:                                     int32_t       aModType)
     1: {
 48013:   // Lots of codepaths under here that do all sorts of stuff, so be safe.
 48013:   nsCOMPtr<nsIMutationObserver> kungFuDeathGrip(this);
 48013: 
     1:   // Make sure this notification concerns us.
     1:   // First check the tag to see if it's one that we care about.
 51350:   nsIAtom* tag = aElement->Tag();
     1: 
 51350:   if (mBoxObject && (aElement == mRoot || aElement == mBody)) {
  9004:     mBoxObject->ClearStyleAndImageCaches();
  9004:     mBoxObject->Invalidate();
  9004:   }
  9004: 
 64496:   // We don't consider non-XUL nodes.
106838:   nsIContent* parent = nullptr;
 64496:   if (!aElement->IsXUL() ||
 64496:       ((parent = aElement->GetParent()) && !parent->IsXUL())) {
 64496:     return;
 64496:   }
     1:   if (tag != nsGkAtoms::treecol &&
     1:       tag != nsGkAtoms::treeitem &&
     1:       tag != nsGkAtoms::treeseparator &&
     1:       tag != nsGkAtoms::treerow &&
 64496:       tag != nsGkAtoms::treecell) {
     1:     return;
     1:   }
     1: 
  1570:   // If we have a legal tag, go up to the tree/select and make sure
  1570:   // that it's ours.
     1: 
 51350:   for (nsIContent* element = aElement; element != mBody; element = element->GetParent()) {
  1570:     if (!element)
  1570:       return; // this is not for us
  1570:     nsIAtom *parentTag = element->Tag();
 64496:     if (element->IsXUL() && parentTag == nsGkAtoms::tree)
  1570:       return; // this is not for us
     1:   }
     1: 
     1:   // Handle changes of the hidden attribute.
     1:   if (aAttribute == nsGkAtoms::hidden &&
     1:      (tag == nsGkAtoms::treeitem || tag == nsGkAtoms::treeseparator)) {
 79445:     bool hidden = aElement->AttrValueIs(kNameSpaceID_None,
     1:                                           nsGkAtoms::hidden,
     1:                                           nsGkAtoms::_true, eCaseMatters);
     1:  
108991:     int32_t index = FindContent(aElement);
     1:     if (hidden && index >= 0) {
     1:       // Hide this row along with its children.
108991:       int32_t count = RemoveRow(index);
     1:       if (mBoxObject)
     1:         mBoxObject->RowCountChanged(index, -count);
     1:     }
     1:     else if (!hidden && index < 0) {
     1:       // Show this row along with its children.
 51350:       nsCOMPtr<nsIContent> parent = aElement->GetParent();
     1:       if (parent) {
 51350:         InsertRowFor(parent, aElement);
     1:       }
     1:     }
     1: 
     1:     return;
     1:   }
     1: 
     1:   if (tag == nsGkAtoms::treecol) {
     1:     if (aAttribute == nsGkAtoms::properties) {
     1:       if (mBoxObject) {
     1:         nsCOMPtr<nsITreeColumns> cols;
     1:         mBoxObject->GetColumns(getter_AddRefs(cols));
     1:         if (cols) {
 51350:           nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aElement);
     1:           nsCOMPtr<nsITreeColumn> col;
     1:           cols->GetColumnFor(element, getter_AddRefs(col));
     1:           mBoxObject->InvalidateColumn(col);
     1:         }
     1:       }
     1:     }
     1:   }
     1:   else if (tag == nsGkAtoms::treeitem) {
108991:     int32_t index = FindContent(aElement);
     1:     if (index >= 0) {
 24551:       Row* row = mRows[index];
     1:       if (aAttribute == nsGkAtoms::container) {
 79445:         bool isContainer =
 51350:           aElement->AttrValueIs(kNameSpaceID_None, nsGkAtoms::container,
     1:                                 nsGkAtoms::_true, eCaseMatters);
     1:         row->SetContainer(isContainer);
     1:         if (mBoxObject)
     1:           mBoxObject->InvalidateRow(index);
     1:       }
     1:       else if (aAttribute == nsGkAtoms::open) {
 79445:         bool isOpen =
 51350:           aElement->AttrValueIs(kNameSpaceID_None, nsGkAtoms::open,
     1:                                 nsGkAtoms::_true, eCaseMatters);
 79445:         bool wasOpen = row->IsOpen();
     1:         if (! isOpen && wasOpen)
     1:           CloseContainer(index);
     1:         else if (isOpen && ! wasOpen)
     1:           OpenContainer(index);
     1:       }
     1:       else if (aAttribute == nsGkAtoms::empty) {
 79445:         bool isEmpty =
 51350:           aElement->AttrValueIs(kNameSpaceID_None, nsGkAtoms::empty,
     1:                                 nsGkAtoms::_true, eCaseMatters);
     1:         row->SetEmpty(isEmpty);
     1:         if (mBoxObject)
     1:           mBoxObject->InvalidateRow(index);
     1:       }
     1:     }
     1:   }
     1:   else if (tag == nsGkAtoms::treeseparator) {
108991:     int32_t index = FindContent(aElement);
     1:     if (index >= 0) {
     1:       if (aAttribute == nsGkAtoms::properties && mBoxObject) {
     1:         mBoxObject->InvalidateRow(index);
     1:       }
     1:     }
     1:   }
     1:   else if (tag == nsGkAtoms::treerow) {
     1:     if (aAttribute == nsGkAtoms::properties) {
 51350:       nsCOMPtr<nsIContent> parent = aElement->GetParent();
     1:       if (parent) {
108991:         int32_t index = FindContent(parent);
     1:         if (index >= 0 && mBoxObject) {
     1:           mBoxObject->InvalidateRow(index);
     1:         }
     1:       }
     1:     }
     1:   }
     1:   else if (tag == nsGkAtoms::treecell) {
     1:     if (aAttribute == nsGkAtoms::ref ||
     1:         aAttribute == nsGkAtoms::properties ||
     1:         aAttribute == nsGkAtoms::mode ||
     1:         aAttribute == nsGkAtoms::src ||
     1:         aAttribute == nsGkAtoms::value ||
     1:         aAttribute == nsGkAtoms::label) {
 51350:       nsIContent* parent = aElement->GetParent();
     1:       if (parent) {
     1:         nsCOMPtr<nsIContent> grandParent = parent->GetParent();
 37873:         if (grandParent && grandParent->IsXUL()) {
108991:           int32_t index = FindContent(grandParent);
     1:           if (index >= 0 && mBoxObject) {
     1:             // XXX Should we make an effort to invalidate only cell ?
     1:             mBoxObject->InvalidateRow(index);
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1: }
     1: 
     1: void
     1: nsTreeContentView::ContentAppended(nsIDocument *aDocument,
     1:                                    nsIContent* aContainer,
 42107:                                    nsIContent* aFirstNewContent,
108991:                                    int32_t     /* unused */)
     1: {
 42107:   for (nsIContent* cur = aFirstNewContent; cur; cur = cur->GetNextSibling()) {
 42107:     // Our contentinserted doesn't use the index
 42107:     ContentInserted(aDocument, aContainer, cur, 0);
     1:   }
     1: }
     1: 
     1: void
     1: nsTreeContentView::ContentInserted(nsIDocument *aDocument,
     1:                                    nsIContent* aContainer,
     1:                                    nsIContent* aChild,
108991:                                    int32_t /* unused */)
     1: {
     1:   NS_ASSERTION(aChild, "null ptr");
     1: 
     1:   // Make sure this notification concerns us.
     1:   // First check the tag to see if it's one that we care about.
     1:   nsIAtom *childTag = aChild->Tag();
     1: 
 64496:   // Don't allow non-XUL nodes.
 64496:   if (!aChild->IsXUL() || !aContainer->IsXUL())
     1:     return;
     1:   if (childTag != nsGkAtoms::treeitem &&
     1:       childTag != nsGkAtoms::treeseparator &&
     1:       childTag != nsGkAtoms::treechildren &&
     1:       childTag != nsGkAtoms::treerow &&
 64496:       childTag != nsGkAtoms::treecell) {
     1:     return;
     1:   }
     1: 
     1:   // If we have a legal tag, go up to the tree/select and make sure
     1:   // that it's ours.
     1: 
  1570:   for (nsIContent* element = aContainer; element != mBody; element = element->GetParent()) {
     1:     if (!element)
     1:       return; // this is not for us
     1:     nsIAtom *parentTag = element->Tag();
 64496:     if (element->IsXUL() && parentTag == nsGkAtoms::tree)
     1:       return; // this is not for us
     1:   }
     1: 
 48014:   // Lots of codepaths under here that do all sorts of stuff, so be safe.
 48014:   nsCOMPtr<nsIMutationObserver> kungFuDeathGrip(this);
 48014: 
     1:   if (childTag == nsGkAtoms::treechildren) {
108991:     int32_t index = FindContent(aContainer);
     1:     if (index >= 0) {
 24551:       Row* row = mRows[index];
 80486:       row->SetEmpty(false);
     1:       if (mBoxObject)
     1:         mBoxObject->InvalidateRow(index);
     1:       if (row->IsContainer() && row->IsOpen()) {
108991:         int32_t count = EnsureSubtree(index);
     1:         if (mBoxObject)
     1:           mBoxObject->RowCountChanged(index + 1, count);
     1:       }
     1:     }
     1:   }
     1:   else if (childTag == nsGkAtoms::treeitem ||
     1:            childTag == nsGkAtoms::treeseparator) {
     1:     InsertRowFor(aContainer, aChild);
     1:   }
     1:   else if (childTag == nsGkAtoms::treerow) {
108991:     int32_t index = FindContent(aContainer);
     1:     if (index >= 0 && mBoxObject)
     1:       mBoxObject->InvalidateRow(index);
     1:   }
     1:   else if (childTag == nsGkAtoms::treecell) {
     1:     nsCOMPtr<nsIContent> parent = aContainer->GetParent();
     1:     if (parent) {
108991:       int32_t index = FindContent(parent);
     1:       if (index >= 0 && mBoxObject)
     1:         mBoxObject->InvalidateRow(index);
     1:     }
     1:   }
 57870: }
     1: 
     1: void
     1: nsTreeContentView::ContentRemoved(nsIDocument *aDocument,
     1:                                   nsIContent* aContainer,
     1:                                   nsIContent* aChild,
108991:                                   int32_t aIndexInContainer,
 48038:                                   nsIContent* aPreviousSibling)
     1: {
     1:   NS_ASSERTION(aChild, "null ptr");
     1: 
     1:   // Make sure this notification concerns us.
     1:   // First check the tag to see if it's one that we care about.
     1:   nsIAtom *tag = aChild->Tag();
     1: 
 64496:   // We don't consider non-XUL nodes.
 64496:   if (!aChild->IsXUL() || !aContainer->IsXUL())
     1:     return;
     1:   if (tag != nsGkAtoms::treeitem &&
     1:       tag != nsGkAtoms::treeseparator &&
     1:       tag != nsGkAtoms::treechildren &&
     1:       tag != nsGkAtoms::treerow &&
 64496:       tag != nsGkAtoms::treecell) {
     1:     return;
     1:   }
     1: 
     1:   // If we have a legal tag, go up to the tree/select and make sure
     1:   // that it's ours.
     1: 
  1570:   for (nsIContent* element = aContainer; element != mBody; element = element->GetParent()) {
     1:     if (!element)
     1:       return; // this is not for us
     1:     nsIAtom *parentTag = element->Tag();
 64496:     if (element->IsXUL() && parentTag == nsGkAtoms::tree)
     1:       return; // this is not for us
     1:   }
     1: 
 48016:   // Lots of codepaths under here that do all sorts of stuff, so be safe.
 48016:   nsCOMPtr<nsIMutationObserver> kungFuDeathGrip(this);
 48016: 
     1:   if (tag == nsGkAtoms::treechildren) {
108991:     int32_t index = FindContent(aContainer);
     1:     if (index >= 0) {
 24551:       Row* row = mRows[index];
 80486:       row->SetEmpty(true);
108991:       int32_t count = RemoveSubtree(index);
     1:       // Invalidate also the row to update twisty.
     1:       if (mBoxObject) {
     1:         mBoxObject->InvalidateRow(index);
     1:         mBoxObject->RowCountChanged(index + 1, -count);
     1:       }
     1:     }
     1:   }
     1:   else if (tag == nsGkAtoms::treeitem ||
 64496:            tag == nsGkAtoms::treeseparator
     1:           ) {
108991:     int32_t index = FindContent(aChild);
     1:     if (index >= 0) {
108991:       int32_t count = RemoveRow(index);
     1:       if (mBoxObject)
     1:         mBoxObject->RowCountChanged(index, -count);
     1:     }
     1:   }
     1:   else if (tag == nsGkAtoms::treerow) {
108991:     int32_t index = FindContent(aContainer);
     1:     if (index >= 0 && mBoxObject)
     1:       mBoxObject->InvalidateRow(index);
     1:   }
     1:   else if (tag == nsGkAtoms::treecell) {
     1:     nsCOMPtr<nsIContent> parent = aContainer->GetParent();
     1:     if (parent) {
108991:       int32_t index = FindContent(parent);
     1:       if (index >= 0 && mBoxObject)
     1:         mBoxObject->InvalidateRow(index);
     1:     }
     1:   }
     1: }
     1: 
     1: void
     1: nsTreeContentView::NodeWillBeDestroyed(const nsINode* aNode)
     1: {
 48009:   // XXXbz do we need this strong ref?  Do we drop refs to self in ClearRows?
 48009:   nsCOMPtr<nsIMutationObserver> kungFuDeathGrip(this);
     1:   ClearRows();
     1: }
     1: 
     1: 
     1: // Recursively serialize content, starting with aContent.
     1: void
108991: nsTreeContentView::Serialize(nsIContent* aContent, int32_t aParentIndex,
140814:                              int32_t* aIndex, nsTArray<nsAutoPtr<Row> >& aRows)
     1: {
 64496:   // Don't allow non-XUL nodes.
 64496:   if (!aContent->IsXUL())
 64496:     return;
 37873: 
     1:   ChildIterator iter, last;
     1:   for (ChildIterator::Init(aContent, &iter, &last); iter != last; ++iter) {
 25233:     nsIContent* content = *iter;
     1:     nsIAtom *tag = content->Tag();
108991:     int32_t count = aRows.Length();
     1: 
 64496:     if (content->IsXUL()) {
     1:       if (tag == nsGkAtoms::treeitem)
     1:         SerializeItem(content, aParentIndex, aIndex, aRows);
     1:       else if (tag == nsGkAtoms::treeseparator)
     1:         SerializeSeparator(content, aParentIndex, aIndex, aRows);
     1:     }
 24551:     *aIndex += aRows.Length() - count;
     1:   }
     1: }
     1: 
     1: void
108991: nsTreeContentView::SerializeItem(nsIContent* aContent, int32_t aParentIndex,
140814:                                  int32_t* aIndex, nsTArray<nsAutoPtr<Row> >& aRows)
     1: {
     1:   if (aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::hidden,
     1:                             nsGkAtoms::_true, eCaseMatters))
     1:     return;
     1: 
135626:   Row* row = new Row(aContent, aParentIndex);
     1:   aRows.AppendElement(row);
     1: 
     1:   if (aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::container,
     1:                             nsGkAtoms::_true, eCaseMatters)) {
 80486:     row->SetContainer(true);
     1:     if (aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::open,
     1:                               nsGkAtoms::_true, eCaseMatters)) {
 80486:       row->SetOpen(true);
 25233:       nsIContent* child =
 25233:         nsTreeUtils::GetImmediateChild(aContent, nsGkAtoms::treechildren);
 67574:       if (child && child->IsXUL()) {
     1:         // Now, recursively serialize our child.
108991:         int32_t count = aRows.Length();
108991:         int32_t index = 0;
     1:         Serialize(child, aParentIndex + *aIndex + 1, &index, aRows);
 24551:         row->mSubtreeSize += aRows.Length() - count;
     1:       }
     1:       else
 80486:         row->SetEmpty(true);
     1:     } else if (aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::empty,
     1:                                      nsGkAtoms::_true, eCaseMatters)) {
 80486:       row->SetEmpty(true);
     1:     }
     1:   } 
     1: }
     1: 
     1: void
 24551: nsTreeContentView::SerializeSeparator(nsIContent* aContent,
108991:                                       int32_t aParentIndex, int32_t* aIndex,
140814:                                       nsTArray<nsAutoPtr<Row> >& aRows)
     1: {
     1:   if (aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::hidden,
     1:                             nsGkAtoms::_true, eCaseMatters))
     1:     return;
     1: 
135626:   Row* row = new Row(aContent, aParentIndex);
 80486:   row->SetSeparator(true);
     1:   aRows.AppendElement(row);
     1: }
     1: 
     1: void
     1: nsTreeContentView::GetIndexInSubtree(nsIContent* aContainer,
108991:                                      nsIContent* aContent, int32_t* aIndex)
     1: {
108991:   uint32_t childCount = aContainer->GetChildCount();
 64496:   
 64496:   if (!aContainer->IsXUL())
 64496:     return;
 64496: 
108991:   for (uint32_t i = 0; i < childCount; i++) {
     1:     nsIContent *content = aContainer->GetChildAt(i);
     1: 
     1:     if (content == aContent)
     1:       break;
     1: 
     1:     nsIAtom *tag = content->Tag();
     1: 
 64496:     if (content->IsXUL()) {
     1:       if (tag == nsGkAtoms::treeitem) {
     1:         if (! content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::hidden,
     1:                                    nsGkAtoms::_true, eCaseMatters)) {
     1:           (*aIndex)++;
     1:           if (content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::container,
     1:                                    nsGkAtoms::_true, eCaseMatters) &&
     1:               content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::open,
     1:                                    nsGkAtoms::_true, eCaseMatters)) {
 25233:             nsIContent* child =
 25233:               nsTreeUtils::GetImmediateChild(content, nsGkAtoms::treechildren);
 67574:             if (child && child->IsXUL())
     1:               GetIndexInSubtree(child, aContent, aIndex);
     1:           }
     1:         }
     1:       }
     1:       else if (tag == nsGkAtoms::treeseparator) {
     1:         if (! content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::hidden,
     1:                                    nsGkAtoms::_true, eCaseMatters))
     1:           (*aIndex)++;
     1:       }
     1:     }
     1:   }
     1: }
     1: 
108991: int32_t
108991: nsTreeContentView::EnsureSubtree(int32_t aIndex)
     1: {
 24551:   Row* row = mRows[aIndex];
     1: 
 25233:   nsIContent* child;
 64496:   child = nsTreeUtils::GetImmediateChild(row->mContent, nsGkAtoms::treechildren);
 67574:   if (!child || !child->IsXUL()) {
     1:     return 0;
     1:   }
     1: 
140814:   nsAutoTArray<nsAutoPtr<Row>, 8> rows;
108991:   int32_t index = 0;
     1:   Serialize(child, aIndex, &index, rows);
140814:   // We can't use InsertElementsAt since the destination can't steal
140814:   // ownership from its const source argument.
140814:   for (nsTArray<Row>::index_type i = 0; i < rows.Length(); i++) {
140814:     nsAutoPtr<Row>* newRow = mRows.InsertElementAt(aIndex + i + 1);
140814:     *newRow = rows[i];
140814:   }
108991:   int32_t count = rows.Length();
     1: 
     1:   row->mSubtreeSize += count;
     1:   UpdateSubtreeSizes(row->mParentIndex, count);
     1: 
     1:   // Update parent indexes, but skip newly added rows.
     1:   // They already have correct values.
     1:   UpdateParentIndexes(aIndex, count + 1, count);
     1: 
     1:   return count;
     1: }
     1: 
108991: int32_t
108991: nsTreeContentView::RemoveSubtree(int32_t aIndex)
     1: {
 24551:   Row* row = mRows[aIndex];
108991:   int32_t count = row->mSubtreeSize;
     1: 
     1:   mRows.RemoveElementsAt(aIndex + 1, count);
     1: 
     1:   row->mSubtreeSize -= count;
     1:   UpdateSubtreeSizes(row->mParentIndex, -count);
     1: 
     1:   UpdateParentIndexes(aIndex, 0, -count);
     1: 
     1:   return count;
     1: }
     1: 
     1: void
     1: nsTreeContentView::InsertRowFor(nsIContent* aParent, nsIContent* aChild)
     1: {
108991:   int32_t grandParentIndex = -1;
 79445:   bool insertRow = false;
     1: 
     1:   nsCOMPtr<nsIContent> grandParent = aParent->GetParent();
     1:   nsIAtom* grandParentTag = grandParent->Tag();
     1: 
 64496:   if (grandParent->IsXUL() && grandParentTag == nsGkAtoms::tree) {
     1:     // Allow insertion to the outermost container.
 80486:     insertRow = true;
     1:   }
     1:   else {
     1:     // Test insertion to an inner container.
     1: 
     1:     // First try to find this parent in our array of rows, if we find one
     1:     // we can be sure that all other parents are open too.
     1:     grandParentIndex = FindContent(grandParent);
     1:     if (grandParentIndex >= 0) {
     1:       // Got it, now test if it is open.
 24551:       if (mRows[grandParentIndex]->IsOpen())
 80486:         insertRow = true;
     1:     }
     1:   }
     1: 
     1:   if (insertRow) {
108991:     int32_t index = 0;
     1:     GetIndexInSubtree(aParent, aChild, &index);
     1: 
108991:     int32_t count = InsertRow(grandParentIndex, index, aChild);
     1:     if (mBoxObject)
     1:       mBoxObject->RowCountChanged(grandParentIndex + index + 1, count);
     1:   }
     1: }
     1: 
108991: int32_t
108991: nsTreeContentView::InsertRow(int32_t aParentIndex, int32_t aIndex, nsIContent* aContent)
     1: {
140814:   nsAutoTArray<nsAutoPtr<Row>, 8> rows;
     1:   nsIAtom *tag = aContent->Tag();
 33329:   if (aContent->IsXUL()) {
     1:     if (tag == nsGkAtoms::treeitem)
     1:       SerializeItem(aContent, aParentIndex, &aIndex, rows);
     1:     else if (tag == nsGkAtoms::treeseparator)
     1:       SerializeSeparator(aContent, aParentIndex, &aIndex, rows);
     1:   }
     1: 
140814:   // We can't use InsertElementsAt since the destination can't steal
140814:   // ownership from its const source argument.
140814:   for (nsTArray<Row>::index_type i = 0; i < rows.Length(); i++) {
140814:     nsAutoPtr<Row>* newRow = mRows.InsertElementAt(aParentIndex + aIndex + i + 1);
140814:     *newRow = rows[i];
140814:   }
108991:   int32_t count = rows.Length();
     1: 
     1:   UpdateSubtreeSizes(aParentIndex, count);
     1: 
     1:   // Update parent indexes, but skip added rows.
     1:   // They already have correct values.
     1:   UpdateParentIndexes(aParentIndex + aIndex, count + 1, count);
     1: 
     1:   return count;
     1: }
     1: 
108991: int32_t
108991: nsTreeContentView::RemoveRow(int32_t aIndex)
     1: {
 24551:   Row* row = mRows[aIndex];
108991:   int32_t count = row->mSubtreeSize + 1;
108991:   int32_t parentIndex = row->mParentIndex;
     1: 
     1:   mRows.RemoveElementsAt(aIndex, count);
     1: 
     1:   UpdateSubtreeSizes(parentIndex, -count);
     1: 
     1:   UpdateParentIndexes(aIndex, 0, -count);
     1: 
     1:   return count;
     1: }
     1: 
     1: void
     1: nsTreeContentView::ClearRows()
     1: {
     1:   mRows.Clear();
106838:   mRoot = nullptr;
106838:   mBody = nullptr;
     1:   // Remove ourselves from mDocument's observers.
     1:   if (mDocument) {
     1:     mDocument->RemoveObserver(this);
106838:     mDocument = nullptr;
     1:   }
     1: }
     1: 
     1: void
108991: nsTreeContentView::OpenContainer(int32_t aIndex)
     1: {
 24551:   Row* row = mRows[aIndex];
 80486:   row->SetOpen(true);
     1: 
108991:   int32_t count = EnsureSubtree(aIndex);
     1:   if (mBoxObject) {
     1:     mBoxObject->InvalidateRow(aIndex);
     1:     mBoxObject->RowCountChanged(aIndex + 1, count);
     1:   }
     1: }
     1: 
     1: void
108991: nsTreeContentView::CloseContainer(int32_t aIndex)
     1: {
 24551:   Row* row = mRows[aIndex];
 80486:   row->SetOpen(false);
     1: 
108991:   int32_t count = RemoveSubtree(aIndex);
     1:   if (mBoxObject) {
     1:     mBoxObject->InvalidateRow(aIndex);
     1:     mBoxObject->RowCountChanged(aIndex + 1, -count);
     1:   }
     1: }
     1: 
108991: int32_t
     1: nsTreeContentView::FindContent(nsIContent* aContent)
     1: {
108991:   for (uint32_t i = 0; i < mRows.Length(); i++) {
 24551:     if (mRows[i]->mContent == aContent) {
     1:       return i;
     1:     }
     1:   }
     1: 
     1:   return -1;
     1: }
     1: 
     1: void
108991: nsTreeContentView::UpdateSubtreeSizes(int32_t aParentIndex, int32_t count)
     1: {
     1:   while (aParentIndex >= 0) {
 24551:     Row* row = mRows[aParentIndex];
     1:     row->mSubtreeSize += count;
     1:     aParentIndex = row->mParentIndex;
     1:   }
     1: }
     1: 
     1: void
108991: nsTreeContentView::UpdateParentIndexes(int32_t aIndex, int32_t aSkip, int32_t aCount)
     1: {
108991:   int32_t count = mRows.Length();
108991:   for (int32_t i = aIndex + aSkip; i < count; i++) {
 24551:     Row* row = mRows[i];
     1:     if (row->mParentIndex > aIndex) {
     1:       row->mParentIndex += aCount;
     1:     }
     1:   }
     1: }
     1: 
     1: nsIContent*
     1: nsTreeContentView::GetCell(nsIContent* aContainer, nsITreeColumn* aCol)
     1: {
     1:   nsCOMPtr<nsIAtom> colAtom;
108991:   int32_t colIndex;
     1:   aCol->GetAtom(getter_AddRefs(colAtom));
     1:   aCol->GetIndex(&colIndex);
     1: 
     1:   // Traverse through cells, try to find the cell by "ref" attribute or by cell
     1:   // index in a row. "ref" attribute has higher priority.
106838:   nsIContent* result = nullptr;
108991:   int32_t j = 0;
     1:   ChildIterator iter, last;
     1:   for (ChildIterator::Init(aContainer, &iter, &last); iter != last; ++iter) {
 25233:     nsIContent* cell = *iter;
     1: 
     1:     if (cell->Tag() == nsGkAtoms::treecell) {
     1:       if (colAtom && cell->AttrValueIs(kNameSpaceID_None, nsGkAtoms::ref,
     1:                                        colAtom, eCaseMatters)) {
     1:         result = cell;
     1:         break;
     1:       }
     1:       else if (j == colIndex) {
     1:         result = cell;
     1:       }
     1:       j++;
     1:     }
     1:   }
     1: 
     1:   return result;
     1: }
