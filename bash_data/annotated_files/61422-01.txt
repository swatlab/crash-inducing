38727: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
38727:  * ***** BEGIN LICENSE BLOCK *****
38727:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
38727:  *
38727:  * The contents of this file are subject to the Mozilla Public License Version
38727:  * 1.1 (the "License"); you may not use this file except in compliance with
38727:  * the License. You may obtain a copy of the License at
38727:  * http://www.mozilla.org/MPL/
38727:  *
38727:  * Software distributed under the License is distributed on an "AS IS" basis,
38727:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
38727:  * for the specific language governing rights and limitations under the
38727:  * License.
38727:  *
38727:  * The Original Code is Mozilla Foundation code.
38727:  *
38727:  * The Initial Developer of the Original Code is Mozilla Foundation.
38727:  * Portions created by the Initial Developer are Copyright (C) 2010
38727:  * the Initial Developer. All Rights Reserved.
38727:  *
38727:  * Contributor(s):
38727:  *   Bas Schouten <bschouten@mozilla.com>
38727:  *
38727:  * Alternatively, the contents of this file may be used under the terms of
38727:  * either the GNU General Public License Version 2 or later (the "GPL"), or
38727:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
38727:  * in which case the provisions of the GPL or the LGPL are applicable instead
38727:  * of those above. If you wish to allow use of your version of this file only
38727:  * under the terms of either the GPL or the LGPL, and not to allow others to
38727:  * use your version of this file under the terms of the MPL, indicate your
38727:  * decision by deleting the provisions above and replace them with the notice
38727:  * and other provisions required by the GPL or the LGPL. If you do not delete
38727:  * the provisions above, a recipient may use your version of this file under
38727:  * the terms of any one of the MPL, the GPL or the LGPL.
38727:  *
38727:  * ***** END LICENSE BLOCK ***** */
61083: #ifdef MOZ_LOGGING
61083: #define FORCE_PR_LOG /* Allow logging in the release build */
61083: #endif /* MOZ_LOGGING */
38727: 
38727: #include "gfxDWriteFontList.h"
38727: #include "gfxDWriteFonts.h"
38727: #include "nsUnicharUtils.h"
38727: #include "nsILocaleService.h"
61083: #include "nsIPrefService.h"
61083: #include "nsIPrefBranch2.h"
61083: #include "nsServiceManagerUtils.h"
38727: 
38727: #include "gfxGDIFontList.h"
38727: 
38867: #include "nsIWindowsRegKey.h"
38867: 
61260: using namespace mozilla;
61260: 
61083: #ifdef PR_LOGGING
61084: 
61084: #define LOG_FONTLIST(args) PR_LOG(gfxPlatform::GetLog(eGfxLog_fontlist), \
61084:                                PR_LOG_DEBUG, args)
61084: #define LOG_FONTLIST_ENABLED() PR_LOG_TEST( \
61084:                                    gfxPlatform::GetLog(eGfxLog_fontlist), \
61084:                                    PR_LOG_DEBUG)
61084: 
61084: #define LOG_FONTINIT(args) PR_LOG(gfxPlatform::GetLog(eGfxLog_fontinit), \
61084:                                PR_LOG_DEBUG, args)
61084: #define LOG_FONTINIT_ENABLED() PR_LOG_TEST( \
61084:                                    gfxPlatform::GetLog(eGfxLog_fontinit), \
61084:                                    PR_LOG_DEBUG)
61084: 
61084: #endif // PR_LOGGING
61083: 
38727: // font info loader constants
61083: 
61083: // avoid doing this during startup even on slow machines but try to start
61083: // it soon enough so that system fallback doesn't happen first
61083: static const PRUint32 kDelayBeforeLoadingFonts = 120 * 1000; // 2 minutes after init
61083: static const PRUint32 kIntervalBetweenLoadingFonts = 2000;   // every 2 seconds until complete
38727: 
38727: static __inline void
38727: BuildKeyNameFromFontName(nsAString &aName)
38727: {
38727:     if (aName.Length() >= LF_FACESIZE)
38727:         aName.Truncate(LF_FACESIZE - 1);
38727:     ToLowerCase(aName);
38727: }
38727: 
38727: ////////////////////////////////////////////////////////////////////////////////
38727: // gfxDWriteFontFamily
38727: 
38727: gfxDWriteFontFamily::~gfxDWriteFontFamily()
38727: {
38727: }
38727: 
38727: void
38727: gfxDWriteFontFamily::FindStyleVariations()
38727: {
38727:     HRESULT hr;
38727:     if (mHasStyles) {
38727:         return;
38727:     }
38727:     mHasStyles = PR_TRUE;
38727: 
38727:     for (UINT32 i = 0; i < mDWFamily->GetFontCount(); i++) {
38727:         nsRefPtr<IDWriteFont> font;
38727:         hr = mDWFamily->GetFont(i, getter_AddRefs(font));
38727:         if (FAILED(hr)) {
38727:             // This should never happen.
38727:             NS_WARNING("Failed to get existing font from family.");
38727:             continue;
38727:         }
38727: 
38727:         if (font->GetSimulations() & DWRITE_FONT_SIMULATIONS_OBLIQUE) {
38727:             // We don't want these.
38727:             continue;
38727:         }
38727: 
38727:         nsRefPtr<IDWriteLocalizedStrings> names;
38727:         hr = font->GetFaceNames(getter_AddRefs(names));
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727:         
38727:         BOOL exists;
38727:         nsAutoTArray<WCHAR,32> faceName;
38727:         UINT32 englishIdx = 0;
38727:         hr = names->FindLocaleName(L"en-us", &englishIdx, &exists);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727: 
38727:         if (!exists) {
38727:             // No english found, use whatever is first in the list.
38727:             englishIdx = 0;
38727:         }
38727:         UINT32 length;
38727:         hr = names->GetStringLength(englishIdx, &length);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727:         if (!faceName.SetLength(length + 1)) {
38727:             // Eeep - running out of memory. Unlikely to end well.
38727:             continue;
38727:         }
38727: 
38727:         hr = names->GetString(englishIdx, faceName.Elements(), length + 1);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727: 
38727:         nsString fullID(mName);
61084:         fullID.Append(NS_LITERAL_STRING(" "));
38727:         fullID.Append(faceName.Elements());
38727: 
38727:         /**
38727:          * Faces do not have a localized name so we just put the en-us name in
38727:          * here.
38727:          */
38727:         gfxDWriteFontEntry *fe = 
38727:             new gfxDWriteFontEntry(fullID, font);
61357:         AddFontEntry(fe);
38727: 
61084: #ifdef PR_LOGGING
61084:         if (LOG_FONTLIST_ENABLED()) {
61084:             LOG_FONTLIST(("(fontlist) added (%s) to family (%s)"
61084:                  " with style: %s weight: %d stretch: %d",
61084:                  NS_ConvertUTF16toUTF8(fe->Name()).get(),
61084:                  NS_ConvertUTF16toUTF8(Name()).get(),
61084:                  (fe->IsItalic()) ? "italic" : "normal",
61084:                  fe->Weight(), fe->Stretch()));
61084:         }
61084: #endif
61357:     }
61084: 
38727:     if (!mAvailableFonts.Length()) {
38727:         NS_WARNING("Family with no font faces in it.");
38727:     }
38727: 
46178:     if (mIsBadUnderlineFamily) {
46178:         SetBadUnderlineFonts();
46178:     }
38727: }
38727: 
38727: void
38727: gfxDWriteFontFamily::LocalizedName(nsAString &aLocalizedName)
38727: {
38727:     aLocalizedName.AssignLiteral("Unknown Font");
38727:     HRESULT hr;
38727:     nsresult rv;
38727:     nsCOMPtr<nsILocaleService> ls = do_GetService(NS_LOCALESERVICE_CONTRACTID,
38727:                                                   &rv);
38727:     nsCOMPtr<nsILocale> locale;
38727:     rv = ls->GetApplicationLocale(getter_AddRefs(locale));
38727:     nsString localeName;
38727:     if (NS_SUCCEEDED(rv)) {
38727:         rv = locale->GetCategory(NS_LITERAL_STRING(NSILOCALE_MESSAGE), 
38727:                                  localeName);
38727:     }
38727:     if (NS_FAILED(rv)) {
38727:         localeName.AssignLiteral("en-us");
38727:     }
38727: 
38727:     nsRefPtr<IDWriteLocalizedStrings> names;
38727: 
38727:     hr = mDWFamily->GetFamilyNames(getter_AddRefs(names));
38727:     if (FAILED(hr)) {
38727:         return;
38727:     }
38727:     UINT32 idx = 0;
38727:     BOOL exists;
38727:     hr = names->FindLocaleName(localeName.BeginReading(),
38727:                                &idx,
38727:                                &exists);
38727:     if (FAILED(hr)) {
38727:         return;
38727:     }
38727:     if (!exists) {
38727:         // Use english is localized is not found.
38727:         hr = names->FindLocaleName(L"en-us", &idx, &exists);
38727:         if (FAILED(hr)) {
38727:             return;
38727:         }
38727:         if (!exists) {
38727:             // Use 0 index if english is not found.
38727:             idx = 0;
38727:         }
38727:     }
38727:     nsAutoTArray<WCHAR, 32> famName;
38727:     UINT32 length;
38727:     
38727:     hr = names->GetStringLength(idx, &length);
38727:     if (FAILED(hr)) {
38727:         return;
38727:     }
38727:     
38727:     if (!famName.SetLength(length + 1)) {
38727:         // Eeep - running out of memory. Unlikely to end well.
38727:         return;
38727:     }
38727: 
38727:     hr = names->GetString(idx, famName.Elements(), length + 1);
38727:     if (FAILED(hr)) {
38727:         return;
38727:     }
38727: 
38727:     aLocalizedName = nsDependentString(famName.Elements());
38727: }
38727: 
38727: ////////////////////////////////////////////////////////////////////////////////
38727: // gfxDWriteFontEntry
38727: 
38727: gfxDWriteFontEntry::~gfxDWriteFontEntry()
38727: {
38727: }
38727: 
38727: PRBool
38727: gfxDWriteFontEntry::IsSymbolFont()
38727: {
38727:     if (mFont) {
38727:         return mFont->IsSymbolFont();
38727:     } else {
38727:         return PR_FALSE;
38727:     }
38727: }
38727: 
38727: nsresult
38727: gfxDWriteFontEntry::GetFontTable(PRUint32 aTableTag,
60098:                                  FallibleTArray<PRUint8> &aBuffer)
38727: {
61083:     gfxDWriteFontList *pFontList = gfxDWriteFontList::PlatformFontList();
61083: 
61083:     if (mFont && pFontList->UseGDIFontTableAccess()) {
61083:         LOGFONTW logfont = { 0 };
61083:         if (!InitLogFont(mFont, &logfont))
61083:             return NS_ERROR_FAILURE;
61083: 
61083:         AutoDC dc;
61083:         AutoSelectFont font(dc.GetDC(), &logfont);
61083:         if (font.IsValid()) {
61083:             PRInt32 tableSize =
61083:                 ::GetFontData(dc.GetDC(), NS_SWAP32(aTableTag), 0, NULL, NULL);
61083:             if (tableSize != GDI_ERROR) {
61083:                 if (aBuffer.SetLength(tableSize)) {
61083:                     ::GetFontData(dc.GetDC(), NS_SWAP32(aTableTag), 0,
61083:                                   aBuffer.Elements(), aBuffer.Length());
61083:                     return NS_OK;
61083:                 }
61083:                 return NS_ERROR_OUT_OF_MEMORY;
61083:             }
61083:         }
61083:         return NS_ERROR_FAILURE;
61083:     }
61083: 
38727:     HRESULT hr;
38727:     nsresult rv;
61083:     nsRefPtr<IDWriteFontFace> fontFace;
61083: 
38727:     rv = CreateFontFace(getter_AddRefs(fontFace));
38727: 
38727:     if (NS_FAILED(rv)) {
38727:         return rv;
38727:     }
38727: 
38727:     PRUint8 *tableData;
38727:     PRUint32 len;
38727:     void *tableContext = NULL;
38727:     BOOL exists;
38727:     hr = fontFace->TryGetFontTable(NS_SWAP32(aTableTag),
38727:                                    (const void**)&tableData,
38727:                                    &len,
38727:                                    &tableContext,
38727:                                    &exists);
38727: 
38727:     if (FAILED(hr) || !exists) {
38727:         return NS_ERROR_FAILURE;
38727:     }
38727:     if (!aBuffer.SetLength(len)) {
38727:         return NS_ERROR_OUT_OF_MEMORY;
38727:     }
38727:     memcpy(aBuffer.Elements(), tableData, len);
38727:     if (tableContext) {
38727:         fontFace->ReleaseFontTable(&tableContext);
38727:     }
38727:     return NS_OK;
38727: }
38727: 
38727: nsresult
38727: gfxDWriteFontEntry::ReadCMAP()
38727: {
38727:     HRESULT hr;
38727:     nsresult rv;
61083: 
61083:     // attempt this once, if errors occur leave a blank cmap
61083:     if (mCmapInitialized)
61083:         return NS_OK;
61083:     mCmapInitialized = PR_TRUE;
61083: 
61083:     // if loading via GDI, just use GetFontTable
61083:     if (mFont && gfxDWriteFontList::PlatformFontList()->UseGDIFontTableAccess()) {
61083:         const PRUint32 kCmapTag = TRUETYPE_TAG('c','m','a','p');
61083:         AutoFallibleTArray<PRUint8,16384> buffer;
61083: 
61083:         if (GetFontTable(kCmapTag, buffer) != NS_OK)
61083:             return NS_ERROR_FAILURE;
61083:         PRUint8 *cmap = buffer.Elements();
61083: 
61083:         PRPackedBool  unicodeFont = PR_FALSE, symbolFont = PR_FALSE;
61083:         rv = gfxFontUtils::ReadCMAP(cmap, buffer.Length(),
61083:                                     mCharacterMap, mUVSOffset,
61083:                                     unicodeFont, symbolFont);
61083:         mHasCmapTable = NS_SUCCEEDED(rv);
61083:         return rv;
61083:     }
61083: 
61083:     // loading using dwrite, don't use GetFontTable to avoid copy
61083:     nsRefPtr<IDWriteFontFace> fontFace;
38727:     rv = CreateFontFace(getter_AddRefs(fontFace));
38727: 
38727:     if (NS_FAILED(rv)) {
38727:         return rv;
38727:     }
38727: 
38727:     PRUint8 *tableData;
38727:     PRUint32 len;
38727:     void *tableContext = NULL;
38727:     BOOL exists;
38727:     hr = fontFace->TryGetFontTable(DWRITE_MAKE_OPENTYPE_TAG('c', 'm', 'a', 'p'),
38727:                                    (const void**)&tableData,
38727:                                    &len,
38727:                                    &tableContext,
38727:                                    &exists);
38727:     if (FAILED(hr)) {
38727:         return NS_ERROR_FAILURE;
38727:     }
38727: 
38727:     PRPackedBool isSymbol = fontFace->IsSymbolFont();
38727:     PRPackedBool isUnicode = PR_TRUE;
38727:     if (exists) {
38727:         rv = gfxFontUtils::ReadCMAP(tableData,
38727:                                     len,
38727:                                     mCharacterMap,
42989:                                     mUVSOffset,
38727:                                     isUnicode,
38727:                                     isSymbol);
38727:     }
38727:     fontFace->ReleaseFontTable(tableContext);
38727: 
61084: #ifdef PR_LOGGING
61084:     LOG_FONTLIST(("(fontlist-cmap) name: %s, size: %d\n",
61084:                   NS_ConvertUTF16toUTF8(mName).get(), mCharacterMap.GetSize()));
61084: #endif
61084: 
43527:     mHasCmapTable = NS_SUCCEEDED(rv);
38727:     return rv;
38727: }
38727: 
38727: gfxFont *
38727: gfxDWriteFontEntry::CreateFontInstance(const gfxFontStyle* aFontStyle,
39306:                                        PRBool aNeedsBold)
38727: {
39306:     return new gfxDWriteFont(this, aFontStyle, aNeedsBold);
38727: }
38727: 
38727: nsresult
38727: gfxDWriteFontEntry::CreateFontFace(IDWriteFontFace **aFontFace,
38727:                                    DWRITE_FONT_SIMULATIONS aSimulations)
38727: {
38727:     HRESULT hr;
38727:     if (mFont) {
38727:         hr = mFont->CreateFontFace(aFontFace);
38727:     } else if (mFontFile) {
38727:         IDWriteFontFile *fontFile = mFontFile.get();
38727:         hr = gfxWindowsPlatform::GetPlatform()->GetDWriteFactory()->
38727:             CreateFontFace(mFaceType,
38727:                            1,
38727:                            &fontFile,
38727:                            0,
38727:                            aSimulations,
38727:                            aFontFace);
38727:     }
38727:     if (FAILED(hr)) {
38727:         return NS_ERROR_FAILURE;
38727:     }
38727:     return NS_OK;
38727: }
38727: 
61083: PRBool
61083: gfxDWriteFontEntry::InitLogFont(IDWriteFont *aFont, LOGFONTW *aLogFont)
61083: {
61083:     HRESULT hr;
61083: 
61083:     BOOL isInSystemCollection;
61083:     IDWriteGdiInterop *gdi = 
61083:         gfxDWriteFontList::PlatformFontList()->GetGDIInterop();
61083:     hr = gdi->ConvertFontToLOGFONT(aFont, aLogFont, &isInSystemCollection);
61083:     return (FAILED(hr) ? PR_FALSE : PR_TRUE);
61083: }
61083: 
61260: PRBool
61260: gfxDWriteFontEntry::IsCJKFont()
61260: {
61260:     if (mIsCJK != UNINITIALIZED_VALUE) {
61260:         return mIsCJK;
61260:     }
61260: 
61260:     mIsCJK = PR_FALSE;
61260: 
61260:     const PRUint32 kOS2Tag = TRUETYPE_TAG('O','S','/','2');
61260:     AutoFallibleTArray<PRUint8,128> buffer;
61260:     if (GetFontTable(kOS2Tag, buffer) != NS_OK) {
61260:         return mIsCJK;
61260:     }
61260: 
61260:     // ulCodePageRange bit definitions for the CJK codepages,
61260:     // from http://www.microsoft.com/typography/otspec/os2.htm#cpr
61260:     const PRUint32 CJK_CODEPAGE_BITS =
61260:         (1 << 17) | // codepage 932 - JIS/Japan
61260:         (1 << 18) | // codepage 936 - Chinese (simplified)
61260:         (1 << 19) | // codepage 949 - Korean Wansung
61260:         (1 << 20) | // codepage 950 - Chinese (traditional)
61260:         (1 << 21);  // codepage 1361 - Korean Johab
61260: 
61260:     if (buffer.Length() >= offsetof(OS2Table, sxHeight)) {
61260:         const OS2Table* os2 =
61260:             reinterpret_cast<const OS2Table*>(buffer.Elements());
61260:         if ((PRUint32(os2->codePageRange1) & CJK_CODEPAGE_BITS) != 0) {
61260:             mIsCJK = PR_TRUE;
61260:         }
61260:     }
61260: 
61260:     return mIsCJK;
61260: }
61260: 
38727: ////////////////////////////////////////////////////////////////////////////////
38727: // gfxDWriteFontList
38727: 
38727: gfxDWriteFontList::gfxDWriteFontList()
61085:     : mInitialized(PR_FALSE)
38727: {
38867:     mFontSubstitutes.Init();
38727: }
38727: 
61083: // bug 602792 - CJK systems default to large CJK fonts which cause excessive
61083: //   I/O strain during cold startup due to dwrite caching bugs.  Default to
61083: //   Arial to avoid this.
61083: 
38727: gfxFontEntry *
38727: gfxDWriteFontList::GetDefaultFont(const gfxFontStyle *aStyle,
38727:                                   PRBool &aNeedsBold)
38727: {
61083:     nsAutoString resolvedName;
61083: 
61083:     // try Arial first
61083:     if (ResolveFontName(NS_LITERAL_STRING("Arial"), resolvedName)) {
61083:         return FindFontForFamily(resolvedName, aStyle, aNeedsBold);
61083:     }
61083: 
61083:     // otherwise, use local default
38727:     NONCLIENTMETRICSW ncm;
38727:     ncm.cbSize = sizeof(ncm);
38727:     BOOL status = ::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, 
38727:                                           sizeof(ncm), &ncm, 0);
38727:     if (status) {
38727:         if (ResolveFontName(nsDependentString(ncm.lfMessageFont.lfFaceName),
38727:                             resolvedName)) {
38727:             return FindFontForFamily(resolvedName, aStyle, aNeedsBold);
38727:         }
38727:     }
38727: 
38727:     return nsnull;
38727: }
38727: 
38727: gfxFontEntry *
38727: gfxDWriteFontList::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
38727:                                    const nsAString& aFullname)
38727: {
38727:     PRBool found;
38727:     gfxFontEntry *lookup;
38727: 
38727:     // initialize name lookup tables if needed
38727:     if (!mFaceNamesInitialized) {
38727:         InitFaceNameLists();
38727:     }
38727: 
38727:     // lookup in name lookup tables, return null if not found
38727:     if (!(lookup = mPostscriptNames.GetWeak(aFullname, &found)) &&
38727:         !(lookup = mFullnames.GetWeak(aFullname, &found))) 
38727:     {
38727:         return nsnull;
38727:     }
38727:     gfxFontEntry *fe = 
38727:         new gfxDWriteFontEntry(lookup->Name(),
38727:                                static_cast<gfxDWriteFontEntry*>(lookup)->mFont,
38727:                                aProxyEntry->Weight(),
38727:                                aProxyEntry->Stretch(),
38727:                                aProxyEntry->IsItalic());
38727: 
38727:     return fe;
38727: }
38727: 
38727: gfxFontEntry *
38727: gfxDWriteFontList::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
38727:                                     const PRUint8 *aFontData,
38727:                                     PRUint32 aLength)
38727: {
38727:     nsresult rv;
38727:     nsAutoString uniqueName;
38727:     rv = gfxFontUtils::MakeUniqueUserFontName(uniqueName);
38727:     if (NS_FAILED(rv)) {
38727:         NS_Free((void*)aFontData);
38727:         return nsnull;
38727:     }
38727: 
60098:     FallibleTArray<PRUint8> newFontData;
38727: 
38727:     rv = gfxFontUtils::RenameFont(uniqueName, aFontData, aLength, &newFontData);
38727:     NS_Free((void*)aFontData);
38727: 
38727:     if (NS_FAILED(rv)) {
38727:         return nsnull;
38727:     }
38727:     
38727:     DWORD numFonts = 0;
38727: 
38727:     nsRefPtr<IDWriteFontFile> fontFile;
38727:     HRESULT hr;
38727: 
38727:     /**
38868:      * We pass in a pointer to a structure containing a pointer to the array
38868:      * containing the font data and a unique identifier. DWrite will
38727:      * internally copy what is at that pointer, and pass that to
38727:      * CreateStreamFromKey. The array will be empty when the function 
38727:      * succesfully returns since it swaps out the data.
38727:      */
38868:     ffReferenceKey key;
38868:     key.mArray = &newFontData;
38868:     nsCOMPtr<nsIUUIDGenerator> uuidgen =
38868:       do_GetService("@mozilla.org/uuid-generator;1");
38868:     if (!uuidgen) {
38868:         return nsnull;
38868:     }
38868: 
38868:     rv = uuidgen->GenerateUUIDInPlace(&key.mGUID);
38868: 
38868:     if (NS_FAILED(rv)) {
38868:         return nsnull;
38868:     }
38868: 
38727:     hr = gfxWindowsPlatform::GetPlatform()->GetDWriteFactory()->
38868:         CreateCustomFontFileReference(&key,
38868:                                       sizeof(key),
38727:                                       gfxDWriteFontFileLoader::Instance(),
38727:                                       getter_AddRefs(fontFile));
38727: 
38727:     if (FAILED(hr)) {
38727:         NS_WARNING("Failed to create custom font file reference.");
38727:         return nsnull;
38727:     }
38727: 
38727:     BOOL isSupported;
38727:     DWRITE_FONT_FILE_TYPE fileType;
38727:     UINT32 numFaces;
38727: 
38727:     PRUint16 w = (aProxyEntry->mWeight == 0 ? 400 : aProxyEntry->mWeight);
38727:     gfxDWriteFontEntry *entry = 
38727:         new gfxDWriteFontEntry(uniqueName, 
38727:                                fontFile,
38727:                                aProxyEntry->Weight(),
38727:                                aProxyEntry->Stretch(),
38727:                                aProxyEntry->IsItalic());
38727: 
38727:     fontFile->Analyze(&isSupported, &fileType, &entry->mFaceType, &numFaces);
38727:     if (!isSupported || numFaces > 1) {
38727:         // We don't know how to deal with 0 faces either.
38727:         delete entry;
38727:         return nsnull;
38727:     }
38727: 
38727:     return entry;
38727: }
38727: 
61085: #ifdef DEBUG_DWRITE_STARTUP
61085: 
61085: #define LOGREGISTRY(msg) LogRegistryEvent(msg)
61085: 
61085: // for use when monitoring process
61085: static void LogRegistryEvent(const wchar_t *msg)
61085: {
61085:     HKEY dummyKey;
61085:     HRESULT hr;
61085:     wchar_t buf[512];
61085: 
61085:     wsprintfW(buf, L" log %s", msg);
61085:     hr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, buf, 0, KEY_READ, &dummyKey);
61085:     if (SUCCEEDED(hr)) {
61085:         RegCloseKey(dummyKey);
61085:     }
61085: }
61085: #else
61085: 
61085: #define LOGREGISTRY(msg)
61085: 
61085: #endif
61085: 
57104: nsresult
38727: gfxDWriteFontList::InitFontList()
38727: {
61085:     LOGREGISTRY(L"InitFontList start");
61083: 
61422:     mInitialized = PR_FALSE;
61422: 
61083: #ifdef PR_LOGGING
61083:     LARGE_INTEGER frequency;        // ticks per second
61085:     LARGE_INTEGER t1, t2, t3;           // ticks
61083:     double elapsedTime, upTime;
61083:     char nowTime[256], nowDate[256];
61083: 
61084:     if (LOG_FONTINIT_ENABLED()) {    
61083:         GetTimeFormat(LOCALE_INVARIANT, TIME_FORCE24HOURFORMAT, 
61083:                       NULL, NULL, nowTime, 256);
61083:         GetDateFormat(LOCALE_INVARIANT, NULL, NULL, NULL, nowDate, 256);
61083:         upTime = (double) GetTickCount();
61083:         QueryPerformanceFrequency(&frequency);
61083:         QueryPerformanceCounter(&t1);
61083:     }
61083: #endif
61083: 
38727:     HRESULT hr;
38727:     gfxFontCache *fc = gfxFontCache::GetCache();
38727:     if (fc) {
38727:         fc->AgeAllGenerations();
38727:     }
38727: 
61083:     nsCOMPtr<nsIPrefBranch2> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);
61083:     nsresult rv;
61083: 
61083:     rv = pref->GetBoolPref(
61083:              "gfx.font_rendering.directwrite.use_gdi_table_loading", 
61083:              &mGDIFontTableAccess);
61083:     if (NS_FAILED(rv)) {
61083:         mGDIFontTableAccess = PR_FALSE;
61083:     }
61083: 
38727:     gfxPlatformFontList::InitFontList();
38727: 
38867:     mFontSubstitutes.Clear();
38867:     mNonExistingFonts.Clear();
38867: 
61083: #ifdef PR_LOGGING
61084:     if (LOG_FONTINIT_ENABLED()) {
61083:         QueryPerformanceCounter(&t2);
61083:     }
61083: #endif
61083: 
61085:     hr = gfxWindowsPlatform::GetPlatform()->GetDWriteFactory()->
61085:         GetGdiInterop(getter_AddRefs(mGDIInterop));
61085:     if (FAILED(hr)) {
61085:         return NS_ERROR_FAILURE;
61085:     }
61085: 
61085:     LOGREGISTRY(L"InitFontList end");
61085: 
61085: #ifdef PR_LOGGING
61085:     if (LOG_FONTINIT_ENABLED()) {
61085:         QueryPerformanceCounter(&t3);
61085: 
61085:         // determine dwrite version
61085:         nsAutoString dwriteVers;
61085:         gfxWindowsPlatform::GetPlatform()->GetDLLVersion(L"dwrite.dll",
61085:                                                          dwriteVers);
61085:         LOG_FONTINIT(("InitFontList\n"));
61085:         LOG_FONTINIT(("Start: %s %s\n", nowDate, nowTime));
61085:         LOG_FONTINIT(("Uptime: %9.3f s\n", upTime/1000));
61085:         LOG_FONTINIT(("dwrite version: %s\n", 
61085:                       NS_ConvertUTF16toUTF8(dwriteVers).get()));
61085:         elapsedTime = (t3.QuadPart - t1.QuadPart) * 1000.0 / frequency.QuadPart;
61085:         LOG_FONTINIT(("Total time in InitFontList:    %9.3f ms\n", elapsedTime));
61085:         elapsedTime = (t2.QuadPart - t1.QuadPart) * 1000.0 / frequency.QuadPart;
61085:         LOG_FONTINIT((" --- gfxPlatformFontList init: %9.3f ms\n", elapsedTime));
61085:         elapsedTime = (t3.QuadPart - t2.QuadPart) * 1000.0 / frequency.QuadPart;
61085:         LOG_FONTINIT((" --- GdiInterop object:        %9.3f ms\n", elapsedTime));
61085:     }
61085: #endif
61085: 
61085:     return NS_OK;
61085: }
61085: 
61085: nsresult
61085: gfxDWriteFontList::DelayedInitFontList()
61085: {
61085:     LOGREGISTRY(L"DelayedInitFontList start");
61085: 
61085: #ifdef PR_LOGGING
61085:     LARGE_INTEGER frequency;        // ticks per second
61085:     LARGE_INTEGER t1, t2, t3;           // ticks
61085:     double elapsedTime, upTime;
61085:     char nowTime[256], nowDate[256];
61085: 
61085:     if (LOG_FONTINIT_ENABLED()) {    
61085:         GetTimeFormat(LOCALE_INVARIANT, TIME_FORCE24HOURFORMAT, 
61085:                       NULL, NULL, nowTime, 256);
61085:         GetDateFormat(LOCALE_INVARIANT, NULL, NULL, NULL, nowDate, 256);
61085:         upTime = (double) GetTickCount();
61085:         QueryPerformanceFrequency(&frequency);
61085:         QueryPerformanceCounter(&t1);
61085:     }
61085: #endif
61085: 
61085:     HRESULT hr;
61085: 
61085:     LOGREGISTRY(L"calling GetSystemFontCollection");
38727:     nsRefPtr<IDWriteFontCollection> systemFonts;
38727:     hr = gfxWindowsPlatform::GetPlatform()->GetDWriteFactory()->
38727:         GetSystemFontCollection(getter_AddRefs(systemFonts));
38727:     NS_ASSERTION(SUCCEEDED(hr), "GetSystemFontCollection failed!");
61085:     LOGREGISTRY(L"GetSystemFontCollection done");
38727: 
57104:     if (FAILED(hr)) {
57104:         return NS_ERROR_FAILURE;
57104:     }
57104: 
61083: #ifdef PR_LOGGING
61084:     if (LOG_FONTINIT_ENABLED()) {
61085:         QueryPerformanceCounter(&t2);
61083:     }
61083: #endif
61083: 
38727:     for (UINT32 i = 0; i < systemFonts->GetFontFamilyCount(); i++) {
38727:         nsRefPtr<IDWriteFontFamily> family;
38727:         systemFonts->GetFontFamily(i, getter_AddRefs(family));
38727: 
38727:         nsRefPtr<IDWriteLocalizedStrings> names;
38727:         hr = family->GetFamilyNames(getter_AddRefs(names));
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727: 
38727:         UINT32 englishIdx = 0;
38727: 
38727:         BOOL exists;
38727:         hr = names->FindLocaleName(L"en-us", &englishIdx, &exists);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727:         if (!exists) {
38727:             // Use 0 index if english is not found.
38727:             englishIdx = 0;
38727:         }
38727: 
60116:         nsAutoTArray<WCHAR, 32> enName;
38727:         UINT32 length;
38727:         
38727:         hr = names->GetStringLength(englishIdx, &length);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727:         
60116:         if (!enName.SetLength(length + 1)) {
38727:             // Eeep - running out of memory. Unlikely to end well.
38727:             continue;
38727:         }
38727: 
60116:         hr = names->GetString(englishIdx, enName.Elements(), length + 1);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727: 
60116:         nsAutoString name(enName.Elements());
38727:         BuildKeyNameFromFontName(name);
38727: 
60116:         nsRefPtr<gfxFontFamily> fam;
60116: 
60116:         if (mFontFamilies.GetWeak(name)) {
60116:             continue;
60116:         }
60116:         
60116:         nsDependentString familyName(enName.Elements());
60116: 
60116:         fam = new gfxDWriteFontFamily(familyName, family);
60116:         if (!fam) {
60116:             continue;
60116:         }
60116: 
46178:         if (mBadUnderlineFamilyNames.Contains(name)) {
46178:             fam->SetBadUnderlineFamily();
46178:         }
38867:         mFontFamilies.Put(name, fam);
60116: 
60116:         // now add other family name localizations, if present
60116:         PRUint32 nameCount = names->GetCount();
60116:         PRUint32 nameIndex;
60116: 
60116:         for (nameIndex = 0; nameIndex < nameCount; nameIndex++) {
60116:             UINT32 nameLen;
60116:             nsAutoTArray<WCHAR, 32> localizedName;
60116: 
60116:             // only add other names
60116:             if (nameIndex == englishIdx) {
60116:                 continue;
38727:             }
38727:             
60116:             hr = names->GetStringLength(nameIndex, &nameLen);
60116:             if (FAILED(hr)) {
60116:                 continue;
60116:             }
60116: 
60116:             if (!localizedName.SetLength(nameLen + 1)) {
60116:                 continue;
60116:             }
60116: 
60116:             hr = names->GetString(nameIndex, localizedName.Elements(), 
60116:                                   nameLen + 1);
60116:             if (FAILED(hr)) {
60116:                 continue;
60116:             }
60116: 
60116:             nsDependentString locName(localizedName.Elements());
60116: 
60116:             if (!familyName.Equals(locName)) {
60116:                 AddOtherFamilyName(fam, locName);
60116:             }
60116: 
60116:         }
60116: 
60116:         // at this point, all family names have been read in
60116:         fam->SetOtherFamilyNamesInitialized();
60116:     }
60116: 
60116:     mOtherFamilyNamesInitialized = PR_TRUE;
38867:     GetFontSubstitutes();
38867: 
61357:     // bug 551313 - DirectWrite creates a Gill Sans family out of 
61357:     // poorly named members of the Gill Sans MT family containing
61357:     // only Ultra Bold weights.  This causes big problems for pages
61357:     // using Gill Sans which is usually only available on OSX
61357: 
61357:     nsAutoString nameGillSans(L"Gill Sans");
61357:     nsAutoString nameGillSansMT(L"Gill Sans MT");
61357:     BuildKeyNameFromFontName(nameGillSans);
61357:     BuildKeyNameFromFontName(nameGillSansMT);
61357: 
61357:     gfxFontFamily *gillSansFamily = mFontFamilies.GetWeak(nameGillSans);
61357:     gfxFontFamily *gillSansMTFamily = mFontFamilies.GetWeak(nameGillSansMT);
61357: 
61357:     if (gillSansFamily && gillSansMTFamily) {
61357:         gillSansFamily->FindStyleVariations();
61357:         nsTArray<nsRefPtr<gfxFontEntry> >& faces = gillSansFamily->GetFontList();
61357:         PRUint32 i;
61357: 
61357:         PRBool allUltraBold = PR_TRUE;
61357:         for (i = 0; i < faces.Length(); i++) {
61357:             // does the face have 'Ultra Bold' in the name?
61357:             if (faces[i]->Name().Find(NS_LITERAL_STRING("Ultra Bold")) == -1) {
61357:                 allUltraBold = PR_FALSE;
61357:                 break;
61357:             }
61357:         }
61357: 
61357:         // if all the Gill Sans faces are Ultra Bold ==> move faces
61357:         // for Gill Sans into Gill Sans MT family
61357:         if (allUltraBold) {
61357: 
61357:             // add faces to Gill Sans MT
61357:             for (i = 0; i < faces.Length(); i++) {
61357:                 gillSansMTFamily->AddFontEntry(faces[i]);
61357: 
61357: #ifdef PR_LOGGING
61357:                 if (LOG_FONTLIST_ENABLED()) {
61357:                     gfxFontEntry *fe = faces[i];
61357:                     LOG_FONTLIST(("(fontlist) moved (%s) to family (%s)"
61357:                          " with style: %s weight: %d stretch: %d",
61357:                          NS_ConvertUTF16toUTF8(fe->Name()).get(),
61357:                          NS_ConvertUTF16toUTF8(gillSansMTFamily->Name()).get(),
61357:                          (fe->IsItalic()) ? "italic" : "normal",
61357:                          fe->Weight(), fe->Stretch()));
61357:                 }
61357: #endif
61357:             }
61357: 
61357:             // remove Gills Sans
61357:             mFontFamilies.Remove(nameGillSans);
61357:         }
61357:     }
61357: 
38727:     StartLoader(kDelayBeforeLoadingFonts, kIntervalBetweenLoadingFonts);
57104: 
61085:     LOGREGISTRY(L"DelayedInitFontList end");
61085: 
61083: #ifdef PR_LOGGING
61084:     if (LOG_FONTINIT_ENABLED()) {
61085:         QueryPerformanceCounter(&t3);
61083: 
61083:         // determine dwrite version
61083:         nsAutoString dwriteVers;
61083:         gfxWindowsPlatform::GetPlatform()->GetDLLVersion(L"dwrite.dll",
61083:                                                          dwriteVers);
61085:         LOG_FONTINIT(("DelayedInitFontList\n"));
61084:         LOG_FONTINIT(("Start: %s %s\n", nowDate, nowTime));
61084:         LOG_FONTINIT(("Uptime: %9.3f s\n", upTime/1000));
61084:         LOG_FONTINIT(("dwrite version: %s\n", 
61084:                       NS_ConvertUTF16toUTF8(dwriteVers).get()));
61085:         elapsedTime = (t3.QuadPart - t1.QuadPart) * 1000.0 / frequency.QuadPart;
61084:         LOG_FONTINIT((
61085:           "Total time in DelayedInitFontList:    %9.3f ms (families: %d, %s)\n",
61083:           elapsedTime, systemFonts->GetFontFamilyCount(),
61083:           (mGDIFontTableAccess ? "gdi table access" : "dwrite table access")));
61083:         elapsedTime = (t2.QuadPart - t1.QuadPart) * 1000.0 / frequency.QuadPart;
61085:         LOG_FONTINIT((" --- GetSystemFontCollection:  %9.3f ms\n", elapsedTime));
61083:         elapsedTime = (t3.QuadPart - t2.QuadPart) * 1000.0 / frequency.QuadPart;
61084:         LOG_FONTINIT((" --- iterate over families:    %9.3f ms\n", elapsedTime));
61083:     }
61083: #endif
61083: 
57104:     return NS_OK;
38727: }
38788: 
38867: static void
38867: RemoveCharsetFromFontSubstitute(nsAString &aName)
38867: {
38867:     PRInt32 comma = aName.FindChar(PRUnichar(','));
38867:     if (comma >= 0)
38867:         aName.Truncate(comma);
38867: }
38867: 
61083: #define MAX_VALUE_NAME 512
61083: #define MAX_VALUE_DATA 512
61083: 
38867: nsresult
38867: gfxDWriteFontList::GetFontSubstitutes()
38867: {
61083:     HKEY hKey;
61083:     DWORD i, rv, lenAlias, lenActual, valueType;
61083:     WCHAR aliasName[MAX_VALUE_NAME];
61083:     WCHAR actualName[MAX_VALUE_DATA];
61083: 
61083:     if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
61083:           L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes",
61083:           0, KEY_READ, &hKey) != ERROR_SUCCESS)
61083:     {
38867:         return NS_ERROR_FAILURE;
38867:     }
38867: 
61083:     for (i = 0, rv = ERROR_SUCCESS; rv != ERROR_NO_MORE_ITEMS; i++) {
61083:         aliasName[0] = 0;
61083:         lenAlias = sizeof(aliasName);
61083:         actualName[0] = 0;
61083:         lenActual = sizeof(actualName);
61083:         rv = RegEnumValueW(hKey, i, aliasName, &lenAlias, NULL, &valueType, 
61083:                 (LPBYTE)actualName, &lenActual);
38867: 
61083:         if (rv != ERROR_SUCCESS || valueType != REG_SZ || lenAlias == 0) {
38867:             continue;
38867:         }
38867: 
61083:         if (aliasName[0] == WCHAR('@')) {
61083:             continue;
61083:         }
61083: 
61083:         nsAutoString substituteName((PRUnichar*) aliasName);
61083:         nsAutoString actualFontName((PRUnichar*) actualName);
38867:         RemoveCharsetFromFontSubstitute(substituteName);
38867:         BuildKeyNameFromFontName(substituteName);
38867:         RemoveCharsetFromFontSubstitute(actualFontName);
38867:         BuildKeyNameFromFontName(actualFontName);
38867:         gfxFontFamily *ff;
38867:         if (!actualFontName.IsEmpty() && 
38867:             (ff = mFontFamilies.GetWeak(actualFontName))) {
38867:             mFontSubstitutes.Put(substituteName, ff);
38867:         } else {
38867:             mNonExistingFonts.AppendElement(substituteName);
38867:         }
38867:     }
38867:     return NS_OK;
38867: }
38867: 
38788: PRBool
38788: gfxDWriteFontList::GetStandardFamilyName(const nsAString& aFontName,
38788:                                          nsAString& aFamilyName)
38788: {
38788:     gfxFontFamily *family = FindFamily(aFontName);
38788:     if (family) {
38788:         family->LocalizedName(aFamilyName);
38788:         return PR_TRUE;
38788:     }
38788: 
38788:     return PR_FALSE;
38788: }
38867: 
61085: gfxFontFamily* gfxDWriteFontList::FindFamily(const nsAString& aFamily)
61085: {
61085:     if (!mInitialized) {
61085:         mInitialized = PR_TRUE;
61085:         DelayedInitFontList();
61085:     }
61085: 
61085:     return gfxPlatformFontList::FindFamily(aFamily);
61085: }
61085: 
38867: PRBool 
38867: gfxDWriteFontList::ResolveFontName(const nsAString& aFontName,
38867:                                    nsAString& aResolvedFontName)
38867: {
61085:     if (!mInitialized) {
61085:         mInitialized = PR_TRUE;
61085:         DelayedInitFontList();
61085:     }
61085: 
38867:     nsAutoString keyName(aFontName);
38867:     BuildKeyNameFromFontName(keyName);
38867: 
38867:     nsRefPtr<gfxFontFamily> ff;
38867:     if (mFontSubstitutes.Get(keyName, &ff)) {
38867:         aResolvedFontName = ff->Name();
38867:         return PR_TRUE;
38867:     }
38867: 
38867:     if (mNonExistingFonts.Contains(keyName)) {
38867:         return PR_FALSE;
38867:     }
38867: 
38867:     return gfxPlatformFontList::ResolveFontName(aFontName, aResolvedFontName);
38867: }
