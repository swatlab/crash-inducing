26702: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
26702: /* ***** BEGIN LICENSE BLOCK *****
26702:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
26702:  *
26702:  * The contents of this file are subject to the Mozilla Public License Version
26702:  * 1.1 (the "License"); you may not use this file except in compliance with
26702:  * the License. You may obtain a copy of the License at
26702:  * http://www.mozilla.org/MPL/
26702:  *
26702:  * Software distributed under the License is distributed on an "AS IS" basis,
26702:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
26702:  * for the specific language governing rights and limitations under the
26702:  * License.
26702:  *
26702:  * The Original Code is Mozilla MathML Project.
26702:  *
26702:  * The Initial Developer of the Original Code is
26702:  * The University Of Queensland.
26702:  * Portions created by the Initial Developer are Copyright (C) 1999
26702:  * the Initial Developer. All Rights Reserved.
26702:  *
26702:  * Contributor(s):
26702:  *   Roger B. Sidje <rbs@maths.uq.edu.au>
26702:  *
26702:  * Alternatively, the contents of this file may be used under the terms of
26702:  * either of the GNU General Public License Version 2 or later (the "GPL"),
26702:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
26702:  * in which case the provisions of the GPL or the LGPL are applicable instead
26702:  * of those above. If you wish to allow use of your version of this file only
26702:  * under the terms of either the GPL or the LGPL, and not to allow others to
26702:  * use your version of this file under the terms of the MPL, indicate your
26702:  * decision by deleting the provisions above and replace them with the notice
26702:  * and other provisions required by the GPL or the LGPL. If you do not delete
26702:  * the provisions above, a recipient may use your version of this file under
26702:  * the terms of any one of the MPL, the GPL or the LGPL.
26702:  *
26702:  * ***** END LICENSE BLOCK ***** */
26702: 
26702: #include "nsINameSpaceManager.h"
26702: #include "nsMathMLFrame.h"
26702: #include "nsMathMLChar.h"
35554: #include "nsCSSPseudoElements.h"
26702: 
26702: // used to map attributes into CSS rules
26702: #include "nsStyleSet.h"
26702: #include "nsAutoPtr.h"
26702: #include "nsDisplayList.h"
68487: #include "nsRenderingContext.h"
26702: 
26702: eMathMLFrameType
26702: nsMathMLFrame::GetMathMLFrameType()
26702: {
26702:   // see if it is an embellished operator (mapped to 'Op' in TeX)
26702:   if (mEmbellishData.coreFrame)
26702:     return GetMathMLFrameTypeFor(mEmbellishData.coreFrame);
26702: 
26702:   // if it has a prescribed base, fetch the type from there
26702:   if (mPresentationData.baseFrame)
26702:     return GetMathMLFrameTypeFor(mPresentationData.baseFrame);
26702: 
26702:   // everything else is treated as ordinary (mapped to 'Ord' in TeX)
26702:   return eMathMLFrameType_Ordinary;  
26702: }
26702: 
26702: // snippet of code used by <mstyle> and <mtable>, which are the only
26702: // two tags where the displaystyle attribute is allowed by the spec.
26702: /* static */ void
26702: nsMathMLFrame::FindAttrDisplaystyle(nsIContent*         aContent,
26702:                                     nsPresentationData& aPresentationData)
26702: {
26702:   NS_ASSERTION(aContent->Tag() == nsGkAtoms::mstyle_ ||
26702:                aContent->Tag() == nsGkAtoms::mtable_, "bad caller");
26702:   static nsIContent::AttrValuesArray strings[] =
26702:     {&nsGkAtoms::_false, &nsGkAtoms::_true, nsnull};
26702:   // see if the explicit displaystyle attribute is there
26702:   switch (aContent->FindAttrValueIn(kNameSpaceID_None,
26702:     nsGkAtoms::displaystyle_, strings, eCaseMatters)) {
26702:   case 0:
26702:     aPresentationData.flags &= ~NS_MATHML_DISPLAYSTYLE;
26702:     aPresentationData.flags |= NS_MATHML_EXPLICIT_DISPLAYSTYLE;
26702:     break;
26702:   case 1:
26702:     aPresentationData.flags |= NS_MATHML_DISPLAYSTYLE;
26702:     aPresentationData.flags |= NS_MATHML_EXPLICIT_DISPLAYSTYLE;
26702:     break;
26702:   }
26702:   // no reset if the attr isn't found. so be sure to call it on inherited flags
26702: }
26702: 
26702: NS_IMETHODIMP
26702: nsMathMLFrame::InheritAutomaticData(nsIFrame* aParent) 
26702: {
26702:   mEmbellishData.flags = 0;
26702:   mEmbellishData.coreFrame = nsnull;
26702:   mEmbellishData.direction = NS_STRETCH_DIRECTION_UNSUPPORTED;
26702:   mEmbellishData.leftSpace = 0;
26702:   mEmbellishData.rightSpace = 0;
26702: 
26702:   mPresentationData.flags = 0;
26702:   mPresentationData.baseFrame = nsnull;
26702:   mPresentationData.mstyle = nsnull;
26702: 
26702:   // by default, just inherit the display of our parent
26702:   nsPresentationData parentData;
26702:   GetPresentationDataFrom(aParent, parentData);
26702:   mPresentationData.mstyle = parentData.mstyle;
26702:   if (NS_MATHML_IS_DISPLAYSTYLE(parentData.flags)) {
26702:     mPresentationData.flags |= NS_MATHML_DISPLAYSTYLE;
26702:   }
26702: 
26702: #if defined(NS_DEBUG) && defined(SHOW_BOUNDING_BOX)
26702:   mPresentationData.flags |= NS_MATHML_SHOW_BOUNDING_METRICS;
26702: #endif
26702: 
26702:   return NS_OK;
26702: }
26702: 
26702: NS_IMETHODIMP
26702: nsMathMLFrame::UpdatePresentationData(PRUint32        aFlagsValues,
26702:                                       PRUint32        aWhichFlags)
26702: {
26702:   // update flags that are relevant to this call
26702:   if (NS_MATHML_IS_DISPLAYSTYLE(aWhichFlags)) {
26702:     // updating the displaystyle flag is allowed
26702:     if (NS_MATHML_IS_DISPLAYSTYLE(aFlagsValues)) {
26702:       mPresentationData.flags |= NS_MATHML_DISPLAYSTYLE;
26702:     }
26702:     else {
26702:       mPresentationData.flags &= ~NS_MATHML_DISPLAYSTYLE;
26702:     }
26702:   }
26702:   if (NS_MATHML_IS_COMPRESSED(aWhichFlags)) {
26702:     // updating the compression flag is allowed
26702:     if (NS_MATHML_IS_COMPRESSED(aFlagsValues)) {
26702:       // 'compressed' means 'prime' style in App. G, TeXbook
26702:       mPresentationData.flags |= NS_MATHML_COMPRESSED;
26702:     }
26702:     // no else. the flag is sticky. it retains its value once it is set
26702:   }
26702:   return NS_OK;
26702: }
26702: 
26702: // Helper to give a style context suitable for doing the stretching of
26702: // a MathMLChar. Frame classes that use this should ensure that the 
26702: // extra leaf style contexts given to the MathMLChars are accessible to
26702: // the Style System via the Get/Set AdditionalStyleContext() APIs.
26702: /* static */ void
26702: nsMathMLFrame::ResolveMathMLCharStyle(nsPresContext*  aPresContext,
26702:                                       nsIContent*      aContent,
26702:                                       nsStyleContext*  aParentStyleContext,
26702:                                       nsMathMLChar*    aMathMLChar,
26702:                                       PRBool           aIsMutableChar)
26702: {
35554:   nsCSSPseudoElements::Type pseudoType = (aIsMutableChar) ?
35554:     nsCSSPseudoElements::ePseudo_mozMathStretchy :
35554:     nsCSSPseudoElements::ePseudo_mozMathAnonymous; // savings
26702:   nsRefPtr<nsStyleContext> newStyleContext;
26702:   newStyleContext = aPresContext->StyleSet()->
41642:     ResolvePseudoElementStyle(aContent->AsElement(), pseudoType,
41642:                               aParentStyleContext);
26702: 
26702:   if (newStyleContext)
26702:     aMathMLChar->SetStyleContext(newStyleContext);
26702: }
26702: 
26702: /* static */ void
26702: nsMathMLFrame::GetEmbellishDataFrom(nsIFrame*        aFrame,
26702:                                     nsEmbellishData& aEmbellishData)
26702: {
26702:   // initialize OUT params
26702:   aEmbellishData.flags = 0;
26702:   aEmbellishData.coreFrame = nsnull;
26702:   aEmbellishData.direction = NS_STRETCH_DIRECTION_UNSUPPORTED;
26702:   aEmbellishData.leftSpace = 0;
26702:   aEmbellishData.rightSpace = 0;
26702: 
26702:   if (aFrame && aFrame->IsFrameOfType(nsIFrame::eMathML)) {
26702:     nsIMathMLFrame* mathMLFrame = do_QueryFrame(aFrame);
26702:     if (mathMLFrame) {
26702:       mathMLFrame->GetEmbellishData(aEmbellishData);
26702:     }
26702:   }
26702: }
26702: 
26702: // helper to get the presentation data of a frame, by possibly walking up
26702: // the frame hierarchy if we happen to be surrounded by non-MathML frames.
26702: /* static */ void
26702: nsMathMLFrame::GetPresentationDataFrom(nsIFrame*           aFrame,
26702:                                        nsPresentationData& aPresentationData,
26702:                                        PRBool              aClimbTree)
26702: {
26702:   // initialize OUT params
26702:   aPresentationData.flags = 0;
26702:   aPresentationData.baseFrame = nsnull;
26702:   aPresentationData.mstyle = nsnull;
26702: 
26702:   nsIFrame* frame = aFrame;
26702:   while (frame) {
26702:     if (frame->IsFrameOfType(nsIFrame::eMathML)) {
26702:       nsIMathMLFrame* mathMLFrame = do_QueryFrame(frame);
26702:       if (mathMLFrame) {
26702:         mathMLFrame->GetPresentationData(aPresentationData);
26702:         break;
26702:       }
26702:     }
26702:     // stop if the caller doesn't want to lookup beyond the frame
26702:     if (!aClimbTree) {
26702:       break;
26702:     }
26702:     // stop if we reach the root <math> tag
26702:     nsIContent* content = frame->GetContent();
26702:     NS_ASSERTION(content || !frame->GetParent(), // no assert for the root
26702:                  "dangling frame without a content node"); 
26702:     if (!content)
26702:       break;
26702: 
26702:     if (content->Tag() == nsGkAtoms::math) {
26702:       const nsStyleDisplay* display = frame->GetStyleDisplay();
26702:       if (display->mDisplay == NS_STYLE_DISPLAY_BLOCK) {
26702:         aPresentationData.flags |= NS_MATHML_DISPLAYSTYLE;
26702:       }
26702:       break;
26702:     }
26702:     frame = frame->GetParent();
26702:   }
26702:   NS_WARN_IF_FALSE(frame && frame->GetContent(),
26702:                    "bad MathML markup - could not find the top <math> element");
26702: }
26702: 
26702: // helper to get an attribute from the content or the surrounding <mstyle> hierarchy
26702: /* static */ PRBool
26702: nsMathMLFrame::GetAttribute(nsIContent* aContent,
26702:                             nsIFrame*   aMathMLmstyleFrame,
26702:                             nsIAtom*    aAttributeAtom,
26702:                             nsString&   aValue)
26702: {
26702:   // see if we can get the attribute from the content
26702:   if (aContent && aContent->GetAttr(kNameSpaceID_None, aAttributeAtom,
26702:                                     aValue)) {
26702:     return PR_TRUE;
26702:   }
26702: 
26702:   // see if we can get the attribute from the mstyle frame
26702:   if (!aMathMLmstyleFrame) {
26702:     return PR_FALSE;
26702:   }
26702: 
26702:   nsIFrame* mstyleParent = aMathMLmstyleFrame->GetParent();
26702: 
26702:   nsPresentationData mstyleParentData;
26702:   mstyleParentData.mstyle = nsnull;
26702: 
26702:   if (mstyleParent) {
26702:     nsIMathMLFrame* mathMLFrame = do_QueryFrame(mstyleParent);
26702:     if (mathMLFrame) {
26702:       mathMLFrame->GetPresentationData(mstyleParentData);
26702:     }
26702:   }
26702: 
26702:   // recurse all the way up into the <mstyle> hierarchy
26702:   return GetAttribute(aMathMLmstyleFrame->GetContent(),
26702:                       mstyleParentData.mstyle, aAttributeAtom, aValue);
26702: }
26702: 
26702: /* static */ void
68481: nsMathMLFrame::GetRuleThickness(nsRenderingContext& aRenderingContext,
68493:                                 nsFontMetrics*      aFontMetrics,
26702:                                 nscoord&             aRuleThickness)
26702: {
26702:   // get the bounding metrics of the overbar char, the rendering context
26702:   // is assumed to have been set with the font of the current style context
68486:   NS_ASSERTION(aRenderingContext.FontMetrics()->Font().
68486:                Equals(aFontMetrics->Font()),
26702:                "unexpected state");
68486: 
68495:   nscoord xHeight = aFontMetrics->XHeight();
26702:   PRUnichar overBar = 0x00AF;
68484:   nsBoundingMetrics bm = aRenderingContext.GetBoundingMetrics(&overBar, 1);
26702:   aRuleThickness = bm.ascent + bm.descent;
68484:   if (aRuleThickness <= 0 || aRuleThickness >= xHeight) {
26702:     // fall-back to the other version
26702:     GetRuleThickness(aFontMetrics, aRuleThickness);
26702:   }
26702: }
26702: 
26702: /* static */ void
68481: nsMathMLFrame::GetAxisHeight(nsRenderingContext& aRenderingContext,
68493:                              nsFontMetrics*      aFontMetrics,
26702:                              nscoord&             aAxisHeight)
26702: {
26702:   // get the bounding metrics of the minus sign, the rendering context
26702:   // is assumed to have been set with the font of the current style context
68486:   NS_ASSERTION(aRenderingContext.FontMetrics()->Font().
68486:                Equals(aFontMetrics->Font()),
26702:                "unexpected state");
68486: 
68495:   nscoord xHeight = aFontMetrics->XHeight();
26702:   PRUnichar minus = 0x2212; // not '-', but official Unicode minus sign
68484:   nsBoundingMetrics bm = aRenderingContext.GetBoundingMetrics(&minus, 1);
26702:   aAxisHeight = bm.ascent - (bm.ascent + bm.descent)/2;
68484:   if (aAxisHeight <= 0 || aAxisHeight >= xHeight) {
26702:     // fall-back to the other version
26702:     GetAxisHeight(aFontMetrics, aAxisHeight);
26702:   }
26702: }
26702: 
26702: /* static */ nscoord
26702: nsMathMLFrame::CalcLength(nsPresContext*   aPresContext,
26702:                           nsStyleContext*   aStyleContext,
26702:                           const nsCSSValue& aCSSValue)
26702: {
26702:   NS_ASSERTION(aCSSValue.IsLengthUnit(), "not a length unit");
26702: 
26702:   if (aCSSValue.IsFixedLengthUnit()) {
50786:     return aCSSValue.GetFixedLength(aPresContext);
50786:   }
50786:   if (aCSSValue.IsPixelLengthUnit()) {
50786:     return aCSSValue.GetPixelLength();
26702:   }
26702: 
26702:   nsCSSUnit unit = aCSSValue.GetUnit();
26702: 
50786:   if (eCSSUnit_EM == unit) {
26702:     const nsStyleFont* font = aStyleContext->GetStyleFont();
26702:     return NSToCoordRound(aCSSValue.GetFloatValue() * (float)font->mFont.size);
26702:   }
26702:   else if (eCSSUnit_XHeight == unit) {
26702:     const nsStyleFont* font = aStyleContext->GetStyleFont();
68493:     nsRefPtr<nsFontMetrics> fm = aPresContext->GetMetricsFor(font->mFont);
68495:     nscoord xHeight = fm->XHeight();
26702:     return NSToCoordRound(aCSSValue.GetFloatValue() * (float)xHeight);
26702:   }
26702: 
50786:   // MathML doesn't specify other CSS units such as rem or ch
50786:   NS_ERROR("Unsupported unit");
26702:   return 0;
26702: }
26702: 
26702: /* static */ PRBool
26702: nsMathMLFrame::ParseNamedSpaceValue(nsIFrame*   aMathMLmstyleFrame,
26702:                                     nsString&   aString,
26702:                                     nsCSSValue& aCSSValue)
26702: {
26702:   aCSSValue.Reset();
26702:   aString.CompressWhitespace(); //  aString is not a const in this code...
26702:   if (!aString.Length()) return PR_FALSE;
26702: 
26702:   // See if it is one of the 'namedspace' (ranging 1/18em...7/18em)
26702:   PRInt32 i = 0;
26702:   nsIAtom* namedspaceAtom = nsnull;
26702:   if (aString.EqualsLiteral("veryverythinmathspace")) {
26702:     i = 1;
26702:     namedspaceAtom = nsGkAtoms::veryverythinmathspace_;
26702:   }
26702:   else if (aString.EqualsLiteral("verythinmathspace")) {
26702:     i = 2;
26702:     namedspaceAtom = nsGkAtoms::verythinmathspace_;
26702:   }
26702:   else if (aString.EqualsLiteral("thinmathspace")) {
26702:     i = 3;
26702:     namedspaceAtom = nsGkAtoms::thinmathspace_;
26702:   }
26702:   else if (aString.EqualsLiteral("mediummathspace")) {
26702:     i = 4;
26702:     namedspaceAtom = nsGkAtoms::mediummathspace_;
26702:   }
26702:   else if (aString.EqualsLiteral("thickmathspace")) {
26702:     i = 5;
26702:     namedspaceAtom = nsGkAtoms::thickmathspace_;
26702:   }
26702:   else if (aString.EqualsLiteral("verythickmathspace")) {
26702:     i = 6;
26702:     namedspaceAtom = nsGkAtoms::verythickmathspace_;
26702:   }
26702:   else if (aString.EqualsLiteral("veryverythickmathspace")) {
26702:     i = 7;
26702:     namedspaceAtom = nsGkAtoms::veryverythickmathspace_;
26702:   }
26702: 
26702:   if (0 != i) {
26702:     if (aMathMLmstyleFrame) {
26702:       // see if there is a <mstyle> that has overriden the default value
26702:       // GetAttribute() will recurse all the way up into the <mstyle> hierarchy
26702:       nsAutoString value;
26702:       GetAttribute(nsnull, aMathMLmstyleFrame, namedspaceAtom, value);
26702:       if (!value.IsEmpty()) {
26702:         if (ParseNumericValue(value, aCSSValue) &&
26702:             aCSSValue.IsLengthUnit()) {
26702:           return PR_TRUE;
26702:         }
26702:       }
26702:     }
26702: 
26702:     // fall back to the default value
26702:     aCSSValue.SetFloatValue(float(i)/float(18), eCSSUnit_EM);
26702:     return PR_TRUE;
26702:   }
26702: 
26702:   return PR_FALSE;
26702: }
26702: 
26702: // ================
26702: // Utils to map attributes into CSS rules (work-around to bug 69409 which
26702: // is not scheduled to be fixed anytime soon)
26702: //
26702: 
26702: static const PRInt32 kMathMLversion1 = 1;
26702: static const PRInt32 kMathMLversion2 = 2;
26702: 
26702: struct
26702: nsCSSMapping {
26702:   PRInt32        compatibility;
26702:   const nsIAtom* attrAtom;
26702:   const char*    cssProperty;
26702: };
26702: 
26702: #if defined(NS_DEBUG) && defined(SHOW_BOUNDING_BOX)
26702: class nsDisplayMathMLBoundingMetrics : public nsDisplayItem {
26702: public:
51260:   nsDisplayMathMLBoundingMetrics(nsDisplayListBuilder* aBuilder,
51260:                                  nsIFrame* aFrame, const nsRect& aRect)
51260:     : nsDisplayItem(aBuilder, aFrame), mRect(aRect) {
26702:     MOZ_COUNT_CTOR(nsDisplayMathMLBoundingMetrics);
26702:   }
26702: #ifdef NS_BUILD_REFCNT_LOGGING
26702:   virtual ~nsDisplayMathMLBoundingMetrics() {
26702:     MOZ_COUNT_DTOR(nsDisplayMathMLBoundingMetrics);
26702:   }
26702: #endif
26702: 
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
68481:                      nsRenderingContext* aCtx);
47732:   NS_DISPLAY_DECL_NAME("MathMLBoundingMetrics", TYPE_MATHML_BOUNDING_METRICS)
26702: private:
26702:   nsRect    mRect;
26702: };
26702: 
26702: void nsDisplayMathMLBoundingMetrics::Paint(nsDisplayListBuilder* aBuilder,
68481:                                            nsRenderingContext* aCtx)
26702: {
26702:   aCtx->SetColor(NS_RGB(0,0,255));
51261:   aCtx->DrawRect(mRect + ToReferenceFrame());
26702: }
26702: 
26702: nsresult
26702: nsMathMLFrame::DisplayBoundingMetrics(nsDisplayListBuilder* aBuilder,
26702:                                       nsIFrame* aFrame, const nsPoint& aPt,
26702:                                       const nsBoundingMetrics& aMetrics,
26702:                                       const nsDisplayListSet& aLists) {
26702:   if (!NS_MATHML_PAINT_BOUNDING_METRICS(mPresentationData.flags))
26702:     return NS_OK;
26702:     
26702:   nscoord x = aPt.x + aMetrics.leftBearing;
26702:   nscoord y = aPt.y - aMetrics.ascent;
26702:   nscoord w = aMetrics.rightBearing - aMetrics.leftBearing;
26702:   nscoord h = aMetrics.ascent + aMetrics.descent;
26702: 
26702:   return aLists.Content()->AppendNewToTop(new (aBuilder)
51260:       nsDisplayMathMLBoundingMetrics(aBuilder, this, nsRect(x,y,w,h)));
26702: }
26702: #endif
26702: 
26702: class nsDisplayMathMLBar : public nsDisplayItem {
26702: public:
51260:   nsDisplayMathMLBar(nsDisplayListBuilder* aBuilder,
51260:                      nsIFrame* aFrame, const nsRect& aRect)
51260:     : nsDisplayItem(aBuilder, aFrame), mRect(aRect) {
26702:     MOZ_COUNT_CTOR(nsDisplayMathMLBar);
26702:   }
26702: #ifdef NS_BUILD_REFCNT_LOGGING
26702:   virtual ~nsDisplayMathMLBar() {
26702:     MOZ_COUNT_DTOR(nsDisplayMathMLBar);
26702:   }
26702: #endif
26702: 
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
68481:                      nsRenderingContext* aCtx);
47732:   NS_DISPLAY_DECL_NAME("MathMLBar", TYPE_MATHML_BAR)
26702: private:
26702:   nsRect    mRect;
26702: };
26702: 
26702: void nsDisplayMathMLBar::Paint(nsDisplayListBuilder* aBuilder,
68481:                                nsRenderingContext* aCtx)
26702: {
26702:   // paint the bar with the current text color
26702:   aCtx->SetColor(mFrame->GetStyleColor()->mColor);
51261:   aCtx->FillRect(mRect + ToReferenceFrame());
26702: }
26702: 
26702: nsresult
26702: nsMathMLFrame::DisplayBar(nsDisplayListBuilder* aBuilder,
26702:                           nsIFrame* aFrame, const nsRect& aRect,
26702:                           const nsDisplayListSet& aLists) {
26702:   if (!aFrame->GetStyleVisibility()->IsVisible() || aRect.IsEmpty())
26702:     return NS_OK;
26702: 
26702:   return aLists.Content()->AppendNewToTop(new (aBuilder)
51260:       nsDisplayMathMLBar(aBuilder, aFrame, aRect));
26702: }
