17078: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
17078: /* ***** BEGIN LICENSE BLOCK *****
17078:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
17078:  *
17078:  * The contents of this file are subject to the Mozilla Public License Version
17078:  * 1.1 (the "License"); you may not use this file except in compliance with
17078:  * the License. You may obtain a copy of the License at
17078:  * http://www.mozilla.org/MPL/
17078:  *
17078:  * Software distributed under the License is distributed on an "AS IS" basis,
17078:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
17078:  * for the specific language governing rights and limitations under the
17078:  * License.
17078:  *
17078:  * The Original Code is mozilla.org code.
17078:  *
17078:  * The Initial Developer of the Original Code is the Mozilla Corporation.
17078:  * Portions created by the Initial Developer are Copyright (C) 2008
17078:  * the Initial Developer. All Rights Reserved.
17078:  *
17078:  * Contributor(s):
17078:  *   Neil Deakin <enndeakin@gmail.com>
17078:  *
17078:  * Alternatively, the contents of this file may be used under the terms of
17078:  * either of the GNU General Public License Version 2 or later (the "GPL"),
17078:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
17078:  * in which case the provisions of the GPL or the LGPL are applicable instead
17078:  * of those above. If you wish to allow use of your version of this file only
17078:  * under the terms of either the GPL or the LGPL, and not to allow others to
17078:  * use your version of this file under the terms of the MPL, indicate your
17078:  * decision by deleting the provisions above and replace them with the notice
17078:  * and other provisions required by the GPL or the LGPL. If you do not delete
17078:  * the provisions above, a recipient may use your version of this file under
17078:  * the terms of any one of the MPL, the GPL or the LGPL.
17078:  *
17078:  * ***** END LICENSE BLOCK ***** */
17078: 
17078: #include "nsDOMDataTransfer.h"
17078: 
17078: #include "prlog.h"
17078: #include "nsString.h"
17078: #include "nsIServiceManager.h"
17078: #include "nsIVariant.h"
17078: #include "nsISupportsPrimitives.h"
17078: #include "nsDOMClassInfo.h"
17078: #include "nsDOMLists.h"
17078: #include "nsGUIEvent.h"
17078: #include "nsDOMError.h"
17078: #include "nsIDragService.h"
17078: #include "nsIScriptableRegion.h"
17078: #include "nsContentUtils.h"
39843: #include "nsIContent.h"
17078: 
17078: NS_IMPL_CYCLE_COLLECTION_2(nsDOMDataTransfer, mDragTarget, mDragImage)
17078: 
17078: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDOMDataTransfer)
17078: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsDOMDataTransfer)
17078: 
17078: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMDataTransfer)
17078:   NS_INTERFACE_MAP_ENTRY(nsIDOMDataTransfer)
17078:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSDataTransfer)
17078:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMDataTransfer)
25059:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DataTransfer)
17078: NS_INTERFACE_MAP_END
17078: 
17078: // the size of the array
17078: const char nsDOMDataTransfer::sEffects[8][9] = {
17078:   "none", "copy", "move", "copyMove", "link", "copyLink", "linkMove", "all"
17078: };
17078: 
17078: nsDOMDataTransfer::nsDOMDataTransfer()
17078:   : mEventType(NS_DRAGDROP_START),
17078:     mDropEffect(nsIDragService::DRAGDROP_ACTION_NONE),
17078:     mEffectAllowed(nsIDragService::DRAGDROP_ACTION_UNINITIALIZED),
29051:     mCursorState(PR_FALSE),
17078:     mReadOnly(PR_FALSE),
17078:     mIsExternal(PR_FALSE),
25064:     mUserCancelled(PR_FALSE),
17078:     mDragImageX(0),
29051:     mDragImageY(0)
17078: {
17078: }
17078: 
17078: nsDOMDataTransfer::nsDOMDataTransfer(PRUint32 aEventType, PRUint32 aAction)
17078:   : mEventType(aEventType),
17078:     mDropEffect(nsIDragService::DRAGDROP_ACTION_NONE),
36752:     mCursorState(PR_FALSE),
17078:     mReadOnly(PR_TRUE),
17078:     mIsExternal(PR_TRUE),
25064:     mUserCancelled(PR_FALSE),
17078:     mDragImageX(0),
17078:     mDragImageY(0)
17078: {
17078:   mEffectAllowed = aAction &
17078:                    (nsIDragService::DRAGDROP_ACTION_COPY |
17078:                     nsIDragService::DRAGDROP_ACTION_LINK |
17078:                     nsIDragService::DRAGDROP_ACTION_MOVE);
17078: 
17078:   CacheExternalFormats();
17078: }
17078: 
17078: nsDOMDataTransfer::nsDOMDataTransfer(PRUint32 aEventType,
17078:                                      const PRUint32 aEffectAllowed,
36752:                                      PRBool aCursorState,
17078:                                      PRBool aIsExternal,
25064:                                      PRBool aUserCancelled,
17078:                                      nsTArray<nsTArray<TransferItem> >& aItems,
17078:                                      nsIDOMElement* aDragImage,
17078:                                      PRUint32 aDragImageX,
17078:                                      PRUint32 aDragImageY)
17078:   : mEventType(aEventType),
17078:     mDropEffect(nsIDragService::DRAGDROP_ACTION_NONE),
17078:     mEffectAllowed(aEffectAllowed),
36752:     mCursorState(aCursorState),
17078:     mReadOnly(PR_TRUE),
17078:     mIsExternal(aIsExternal),
25064:     mUserCancelled(aUserCancelled),
17078:     mItems(aItems),
17078:     mDragImage(aDragImage),
17078:     mDragImageX(aDragImageX),
17078:     mDragImageY(aDragImageY)
17078: {
17078:   // The items are copied from aItems into mItems. There is no need to copy
17078:   // the actual data in the items as the data transfer will be read only. The
17078:   // draggesture and dragstart events are the only times when items are
17078:   // modifiable, but those events should have been using the first constructor
17078:   // above.
17078:   NS_ASSERTION(aEventType != NS_DRAGDROP_GESTURE &&
17078:                aEventType != NS_DRAGDROP_START,
17078:                "invalid event type for nsDOMDataTransfer constructor");
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::GetDropEffect(nsAString& aDropEffect)
17078: {
17078:   aDropEffect.AssignASCII(sEffects[mDropEffect]);
17078:   return NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::SetDropEffect(const nsAString& aDropEffect)
17078: {
17078:   // the drop effect can only be 'none', 'copy', 'move' or 'link'.
17078:   for (PRUint32 e = 0; e <= nsIDragService::DRAGDROP_ACTION_LINK; e++) {
17078:     if (aDropEffect.EqualsASCII(sEffects[e])) {
17078:       // don't allow copyMove
17078:       if (e != (nsIDragService::DRAGDROP_ACTION_COPY |
17078:                 nsIDragService::DRAGDROP_ACTION_MOVE))
17078:         mDropEffect = e;
17078:       break;
17078:     }
17078:   }
17078: 
17078:   return NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::GetEffectAllowed(nsAString& aEffectAllowed)
17078: {
17078:   if (mEffectAllowed == nsIDragService::DRAGDROP_ACTION_UNINITIALIZED)
17078:     aEffectAllowed.AssignLiteral("uninitialized");
17078:   else
17078:     aEffectAllowed.AssignASCII(sEffects[mEffectAllowed]);
17078:   return NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::SetEffectAllowed(const nsAString& aEffectAllowed)
17078: {
17078:   if (aEffectAllowed.EqualsLiteral("uninitialized")) {
17078:     mEffectAllowed = nsIDragService::DRAGDROP_ACTION_UNINITIALIZED;
17078:     return NS_OK;
17078:   }
17078: 
17078:   PR_STATIC_ASSERT(nsIDragService::DRAGDROP_ACTION_NONE == 0);
17078:   PR_STATIC_ASSERT(nsIDragService::DRAGDROP_ACTION_COPY == 1);
17078:   PR_STATIC_ASSERT(nsIDragService::DRAGDROP_ACTION_MOVE == 2);
17078:   PR_STATIC_ASSERT(nsIDragService::DRAGDROP_ACTION_LINK == 4);
17078: 
17078:   for (PRUint32 e = 0; e < NS_ARRAY_LENGTH(sEffects); e++) {
17078:     if (aEffectAllowed.EqualsASCII(sEffects[e])) {
17078:       mEffectAllowed = e;
17078:       break;
17078:     }
17078:   }
17078: 
17078:   return NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::GetDropEffectInt(PRUint32* aDropEffect)
17078: {
17078:   *aDropEffect = mDropEffect;
17078:   return  NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::SetDropEffectInt(PRUint32 aDropEffect)
17078: {
17078:   mDropEffect = aDropEffect;
17078:   return  NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::GetEffectAllowedInt(PRUint32* aEffectAllowed)
17078: {
17078:   *aEffectAllowed = mEffectAllowed;
17078:   return  NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::SetEffectAllowedInt(PRUint32 aEffectAllowed)
17078: {
17078:   mEffectAllowed = aEffectAllowed;
17078:   return  NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
25064: nsDOMDataTransfer::GetMozUserCancelled(PRBool* aUserCancelled)
25064: {
25064:   *aUserCancelled = mUserCancelled;
25064:   return NS_OK;
25064: }
25064: 
25064: NS_IMETHODIMP
30954: nsDOMDataTransfer::GetFiles(nsIDOMFileList** aFileList)
30954: {
30954:   *aFileList = nsnull;
30954: 
30954:   if (mEventType != NS_DRAGDROP_DROP && mEventType != NS_DRAGDROP_DRAGDROP)
30954:     return NS_OK;
30954: 
30954:   if (!mFiles) {
30954:     mFiles = new nsDOMFileList();
30954:     NS_ENSURE_TRUE(mFiles, NS_ERROR_OUT_OF_MEMORY);
30954: 
30954:     PRUint32 count = mItems.Length();
30954: 
30954:     for (PRUint32 i = 0; i < count; i++) {
30954:       nsCOMPtr<nsIVariant> variant;
30954:       nsresult rv = MozGetDataAt(NS_ConvertUTF8toUTF16(kFileMime), i, getter_AddRefs(variant));
30954:       NS_ENSURE_SUCCESS(rv, rv);
30954: 
30954:       if (!variant)
30954:         continue;
30954: 
30954:       nsCOMPtr<nsISupports> supports;
30954:       rv = variant->GetAsISupports(getter_AddRefs(supports));
30954: 
30954:       if (NS_FAILED(rv))
30954:         continue;
30954: 
30954:       nsCOMPtr<nsIFile> file = do_QueryInterface(supports);
30954: 
30954:       if (!file)
30954:         continue;
30954: 
38871:       nsCOMPtr<nsIDocument> targetDoc;
38871:       nsCOMPtr<nsINode> targetNode = do_QueryInterface(mDragTarget);
38871:       if (targetNode) {
38871:         targetDoc = targetNode->GetOwnerDoc();
38871:       }
38871: 
38871:       nsRefPtr<nsDOMFile> domFile = new nsDOMFile(file, targetDoc);
30954:       NS_ENSURE_TRUE(domFile, NS_ERROR_OUT_OF_MEMORY);
30954: 
30954:       if (!mFiles->Append(domFile))
30954:         return NS_ERROR_FAILURE;
30954:     }
30954:   }
30954: 
30954:   *aFileList = mFiles;
30954:   NS_ADDREF(*aFileList);
30954:   return NS_OK;
30954: }
30954: 
30954: NS_IMETHODIMP
17078: nsDOMDataTransfer::GetTypes(nsIDOMDOMStringList** aTypes)
17078: {
32468:   *aTypes = nsnull;
32468: 
32468:   nsRefPtr<nsDOMStringList> types = new nsDOMStringList();
32468:   NS_ENSURE_TRUE(types, NS_ERROR_OUT_OF_MEMORY);
32468: 
32468:   if (mItems.Length()) {
32468:     nsTArray<TransferItem>& item = mItems[0];
32468:     for (PRUint32 i = 0; i < item.Length(); i++)
32468:       types->Add(item[i].mFormat);
32468: 
32468:     PRBool filePresent, filePromisePresent;
32468:     types->Contains(NS_LITERAL_STRING(kFileMime), &filePresent);
32468:     types->Contains(NS_LITERAL_STRING("application/x-moz-file-promise"), &filePromisePresent);
32468:     if (filePresent || filePromisePresent)
32468:       types->Add(NS_LITERAL_STRING("Files"));
32468:   }
32468: 
32468:   *aTypes = types;
32468:   NS_ADDREF(*aTypes);
32468: 
32468:   return NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::GetData(const nsAString& aFormat, nsAString& aData)
17078: {
17078:   // return an empty string if data for the format was not found
17078:   aData.Truncate();
17078: 
17078:   nsCOMPtr<nsIVariant> data;
17078:   nsresult rv = MozGetDataAt(aFormat, 0, getter_AddRefs(data));
17078:   if (rv == NS_ERROR_DOM_INDEX_SIZE_ERR)
17078:     return NS_OK;
17078: 
17078:   NS_ENSURE_SUCCESS(rv, rv);
17078: 
17078:   if (data) {
17078:     nsAutoString stringdata;
17078:     data->GetAsAString(stringdata);
17078: 
17078:     // for the URL type, parse out the first URI from the list. The URIs are
17078:     // separated by newlines
17078:     if (aFormat.EqualsLiteral("URL")) {
17078:       PRInt32 lastidx = 0, idx;
17078:       PRInt32 length = stringdata.Length();
17078:       while (lastidx < length) {
17078:         idx = stringdata.FindChar('\n', lastidx);
17078:         // lines beginning with # are comments
17078:         if (stringdata[lastidx] == '#') {
17078:           if (idx == -1)
17078:             break;
17078:         }
17078:         else {
17078:           if (idx == -1)
17078:             aData.Assign(Substring(stringdata, lastidx));
17078:           else
17078:             aData.Assign(Substring(stringdata, lastidx, idx - lastidx));
17078:           aData = nsContentUtils::TrimWhitespace(aData, PR_TRUE);
17078:           return NS_OK;
17078:         }
17078:         lastidx = idx + 1;
17078:       }
17078:     }
17078:     else {
17078:       aData = stringdata;
17078:     }
17078:   }
17078: 
17078:   return NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::SetData(const nsAString& aFormat, const nsAString& aData)
17078: {
17078:   nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
17078:   NS_ENSURE_TRUE(variant, NS_ERROR_OUT_OF_MEMORY);
17078: 
17078:   variant->SetAsAString(aData);
17078: 
17078:   return MozSetDataAt(aFormat, variant, 0);
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::ClearData(const nsAString& aFormat)
17078: {
17078:   nsresult rv = MozClearDataAt(aFormat, 0);
17078:   return (rv == NS_ERROR_DOM_INDEX_SIZE_ERR) ? NS_OK : rv;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::GetMozItemCount(PRUint32* aCount)
17078: {
17078:   *aCount = mItems.Length();
17078:   return NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
25809: nsDOMDataTransfer::GetMozCursor(nsAString& aCursorState)
25809: {
25958:   if (mCursorState) {
25958:     aCursorState.AssignLiteral("default");
25958:   } else {
25958:     aCursorState.AssignLiteral("auto");
25958:   }
25809:   return NS_OK;
25809: }
25809: 
25809: NS_IMETHODIMP
25809: nsDOMDataTransfer::SetMozCursor(const nsAString& aCursorState)
25809: {
25809:   // Lock the cursor to an arrow during the drag.
25958:   mCursorState = aCursorState.EqualsLiteral("default");
25809: 
25809:   return NS_OK;
25809: }
25809: 
25809: NS_IMETHODIMP
38841: nsDOMDataTransfer::GetMozSourceNode(nsIDOMNode** aSourceNode)
38841: {
38841:   *aSourceNode = nsnull;
38841: 
38841:   nsCOMPtr<nsIDragSession> dragSession = nsContentUtils::GetDragSession();
38841:   if (!dragSession)
38841:     return NS_OK;
38841: 
38841:   nsCOMPtr<nsIDOMNode> sourceNode;
38841:   dragSession->GetSourceNode(getter_AddRefs(sourceNode));
38841:   if (sourceNode && !nsContentUtils::CanCallerAccess(sourceNode))
38841:     return NS_OK;
38841: 
38841:   sourceNode.swap(*aSourceNode);
38841:   return NS_OK;
38841: }
38841: 
38841: NS_IMETHODIMP
17078: nsDOMDataTransfer::MozTypesAt(PRUint32 aIndex, nsIDOMDOMStringList** aTypes)
17078: {
17078:   *aTypes = nsnull;
17078: 
17078:   nsRefPtr<nsDOMStringList> types = new nsDOMStringList();
17078:   NS_ENSURE_TRUE(types, NS_ERROR_OUT_OF_MEMORY);
17078: 
17078:   if (aIndex < mItems.Length()) {
17078:     // note that you can retrieve the types regardless of their principal
17078:     nsTArray<TransferItem>& item = mItems[aIndex];
17078:     for (PRUint32 i = 0; i < item.Length(); i++)
17078:       types->Add(item[i].mFormat);
17078:   }
17078: 
17078:   *aTypes = types;
17078:   NS_ADDREF(*aTypes);
17078: 
17078:   return NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::MozGetDataAt(const nsAString& aFormat,
17078:                                 PRUint32 aIndex,
17078:                                 nsIVariant** aData)
17078: {
17078:   *aData = nsnull;
17078: 
17078:   if (aFormat.IsEmpty())
17078:     return NS_OK;
17078: 
17078:   if (aIndex >= mItems.Length())
17078:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
17078: 
17078:   nsAutoString format;
17078:   GetRealFormat(aFormat, format);
17078: 
17078:   nsTArray<TransferItem>& item = mItems[aIndex];
17078: 
17078:   // allow access to any data in the drop and dragdrop events, or if the
17078:   // UniversalBrowserRead privilege is set, otherwise only allow access to
17078:   // data from the same principal.
17078:   nsIPrincipal* principal = nsnull;
17078:   if (mEventType != NS_DRAGDROP_DROP && mEventType != NS_DRAGDROP_DRAGDROP &&
17078:       !nsContentUtils::IsCallerTrustedForCapability("UniversalBrowserRead"))
17078:     principal = GetCurrentPrincipal();
17078: 
17078:   PRUint32 count = item.Length();
17078:   for (PRUint32 i = 0; i < count; i++) {
17078:     TransferItem& formatitem = item[i];
17078:     if (formatitem.mFormat.Equals(format)) {
17078:       PRBool subsumes;
17078:       if (formatitem.mPrincipal && principal &&
17078:           (NS_FAILED(principal->Subsumes(formatitem.mPrincipal, &subsumes)) || !subsumes))
17078:         return NS_ERROR_DOM_SECURITY_ERR;
17078: 
17078:       if (!formatitem.mData)
17078:         FillInExternalDragData(formatitem, aIndex);
17078:       *aData = formatitem.mData;
17078:       NS_IF_ADDREF(*aData);
17078:       return NS_OK;
17078:     }
17078:   }
17078: 
17078:   return NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::MozSetDataAt(const nsAString& aFormat,
17078:                                 nsIVariant* aData,
17078:                                 PRUint32 aIndex)
17078: {
17078:   NS_ENSURE_TRUE(aData, NS_ERROR_NULL_POINTER);
17078: 
17078:   if (aFormat.IsEmpty())
17078:     return NS_OK;
17078: 
17078:   if (mReadOnly)
17078:     return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
17078: 
17078:   // Specifying an index less than the current length will replace an existing
17078:   // item. Specifying an index equal to the current length will add a new item.
17078:   if (aIndex > mItems.Length())
17078:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
17078: 
17078:   // don't allow non-chrome to add file data
17078:   // XXX perhaps this should also limit any non-string type as well
17078:   if ((aFormat.EqualsLiteral("application/x-moz-file-promise") ||
17078:        aFormat.EqualsLiteral("application/x-moz-file")) &&
30954:        !nsContentUtils::IsCallerTrustedForCapability("UniversalXPConnect")) {
17078:     return NS_ERROR_DOM_SECURITY_ERR;
17078:   }
17078: 
17078:   return SetDataWithPrincipal(aFormat, aData, aIndex, GetCurrentPrincipal());
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::MozClearDataAt(const nsAString& aFormat, PRUint32 aIndex)
17078: {
17078:   if (mReadOnly)
17078:     return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
17078: 
17078:   if (aIndex >= mItems.Length())
17078:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
17078: 
17078:   nsAutoString format;
17078:   GetRealFormat(aFormat, format);
17078: 
17078:   nsIPrincipal* principal = GetCurrentPrincipal();
17078: 
17078:   // if the format is empty, clear all formats
17078:   PRBool clearall = format.IsEmpty();
17078: 
17078:   nsTArray<TransferItem>& item = mItems[aIndex];
17078:   // count backwards so that the count and index don't have to be adjusted
17078:   // after removing an element
17078:   for (PRInt32 i = item.Length() - 1; i >= 0; i--) {
17078:     TransferItem& formatitem = item[i];
17078:     if (clearall || formatitem.mFormat.Equals(format)) {
17078:       // don't allow removing data that has a stronger principal
17078:       PRBool subsumes;
17078:       if (formatitem.mPrincipal && principal &&
17078:           (NS_FAILED(principal->Subsumes(formatitem.mPrincipal, &subsumes)) || !subsumes))
17078:         return NS_ERROR_DOM_SECURITY_ERR;
17078: 
17078:       item.RemoveElementAt(i);
17078: 
17078:       // if a format was specified, break out. Otherwise, loop around until
17078:       // all formats have been removed
17078:       if (!clearall)
17078:         break;
17078:     }
17078:   }
17078: 
17078:   // if the last format for an item is removed, remove the entire item
17078:   if (!item.Length())
17078:      mItems.RemoveElementAt(aIndex);
17078: 
17078:   return NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::SetDragImage(nsIDOMElement* aImage, PRInt32 aX, PRInt32 aY)
17078: {
17078:   if (mReadOnly)
17078:     return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
17078: 
39843:   if (aImage) {
39843:     nsCOMPtr<nsIContent> content = do_QueryInterface(aImage);
39843:     NS_ENSURE_TRUE(content, NS_ERROR_INVALID_ARG);
39843:   }
17078:   mDragImage = aImage;
17078:   mDragImageX = aX;
17078:   mDragImageY = aY;
17078:   return NS_OK;
17078: }
17078: 
17078: NS_IMETHODIMP
17078: nsDOMDataTransfer::AddElement(nsIDOMElement* aElement)
17078: {
17078:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
17078: 
17078:   if (mReadOnly)
17078:     return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
17078: 
17078:   mDragTarget = do_QueryInterface(aElement);
17078: 
17078:   return NS_OK;
17078: }
17078: 
17078: nsresult
25064: nsDOMDataTransfer::Clone(PRUint32 aEventType, PRBool aUserCancelled,
17078:                          nsIDOMDataTransfer** aNewDataTransfer)
17078: {
17078:   nsDOMDataTransfer* newDataTransfer =
36752:     new nsDOMDataTransfer(aEventType, mEffectAllowed, mCursorState,
36752:                           mIsExternal, aUserCancelled, mItems,
36752:                           mDragImage, mDragImageX, mDragImageY);
17078:   NS_ENSURE_TRUE(newDataTransfer, NS_ERROR_OUT_OF_MEMORY);
17078: 
17078:   *aNewDataTransfer = newDataTransfer;
17078:   NS_ADDREF(*aNewDataTransfer);
17078:   return NS_OK;
17078: }
17078: 
17078: void
17078: nsDOMDataTransfer::GetTransferables(nsISupportsArray** aArray)
17078: {
17078:   *aArray = nsnull;
17078: 
17078:   nsCOMPtr<nsISupportsArray> transArray =
17078:     do_CreateInstance("@mozilla.org/supports-array;1");
17078:   if (!transArray)
17078:     return;
17078: 
17078:   PRBool added = PR_FALSE;
17078:   PRUint32 count = mItems.Length();
17078:   for (PRUint32 i = 0; i < count; i++) {
17078: 
17078:     nsTArray<TransferItem>& item = mItems[i];
17078:     PRUint32 count = item.Length();
17078:     if (!count)
17078:       continue;
17078: 
17078:     nsCOMPtr<nsITransferable> transferable =
17078:       do_CreateInstance("@mozilla.org/widget/transferable;1");
17078:     if (!transferable)
17078:       return;
17078: 
17078:     for (PRUint32 f = 0; f < count; f++) {
17078:       TransferItem& formatitem = item[f];
17078:       if (!formatitem.mData) // skip empty items
17078:         continue;
17078: 
17078:       PRUint32 length;
17078:       nsCOMPtr<nsISupports> convertedData;
17078:       if (!ConvertFromVariant(formatitem.mData, getter_AddRefs(convertedData), &length))
17078:         continue;
17078: 
17078:       // the underlying drag code uses text/unicode, so use that instead of text/plain
17078:       const char* format;
17078:       NS_ConvertUTF16toUTF8 utf8format(formatitem.mFormat);
17078:       if (utf8format.EqualsLiteral("text/plain"))
17078:         format = kUnicodeMime;
17078:       else
17078:         format = utf8format.get();
17078: 
17078:       // if a converter is set for a format, set the converter for the
17078:       // transferable and don't add the item
17078:       nsCOMPtr<nsIFormatConverter> converter = do_QueryInterface(convertedData);
17078:       if (converter) {
17078:         transferable->AddDataFlavor(format);
17078:         transferable->SetConverter(converter);
17078:         continue;
17078:       }
17078: 
17078:       nsresult rv = transferable->SetTransferData(format, convertedData, length);
17078:       if (NS_FAILED(rv))
17078:         return;
17078: 
17078:       added = PR_TRUE;
17078:     }
17078: 
17078:     // only append the transferable if data was successfully added to it
17078:     if (added)
17078:       transArray->AppendElement(transferable);
17078:   }
17078: 
17078:   NS_ADDREF(*aArray = transArray);
17078: }
17078: 
17078: PRBool
17078: nsDOMDataTransfer::ConvertFromVariant(nsIVariant* aVariant,
17078:                                       nsISupports** aSupports,
17078:                                       PRUint32* aLength)
17078: {
17078:   *aSupports = nsnull;
17078:   *aLength = 0;
17078: 
17078:   PRUint16 type;
17078:   aVariant->GetDataType(&type);
17078:   if (type == nsIDataType::VTYPE_INTERFACE ||
17078:       type == nsIDataType::VTYPE_INTERFACE_IS) {
18582:     nsCOMPtr<nsISupports> data;
18582:     if (NS_FAILED(aVariant->GetAsISupports(getter_AddRefs(data))))
17078:        return PR_FALSE;
17078:  
18582:     nsCOMPtr<nsIFlavorDataProvider> fdp = do_QueryInterface(data);
18582:     if (fdp) {
17078:       // for flavour data providers, use kFlavorHasDataProvider (which has the
17078:       // value 0) as the length.
18582:       NS_ADDREF(*aSupports = fdp);
18582:       *aLength = nsITransferable::kFlavorHasDataProvider;
18582:     }
18582:     else {
18582:       // wrap the item in an nsISupportsInterfacePointer
18582:       nsCOMPtr<nsISupportsInterfacePointer> ptrSupports =
18582:         do_CreateInstance(NS_SUPPORTS_INTERFACE_POINTER_CONTRACTID);
18582:       if (!ptrSupports)
18582:         return PR_FALSE;
18582: 
18582:       ptrSupports->SetData(data);
18582:       NS_ADDREF(*aSupports = ptrSupports);
18582: 
18582:       *aLength = sizeof(nsISupportsInterfacePointer *);
18582:     }
18582: 
18582:     return PR_TRUE;
17078:   }
17078: 
17078:   PRUnichar* chrs;
37376:   PRUint32 len = 0;
37376:   nsresult rv = aVariant->GetAsWStringWithSize(&len, &chrs);
17078:   if (NS_FAILED(rv))
17078:     return PR_FALSE;
17078: 
37376:   nsAutoString str;
37376:   str.Adopt(chrs, len);
37376: 
17078:   nsCOMPtr<nsISupportsString>
17078:     strSupports(do_CreateInstance(NS_SUPPORTS_STRING_CONTRACTID));
17078:   if (!strSupports)
17078:     return PR_FALSE;
17078: 
17078:   strSupports->SetData(str);
17078: 
17078:   *aSupports = strSupports;
17078:   NS_ADDREF(*aSupports);
17078: 
17078:   // each character is two bytes
17078:   *aLength = str.Length() << 1;
17078: 
17078:   return PR_TRUE;
17078: }
17078: 
17078: void
17078: nsDOMDataTransfer::ClearAll()
17078: {
17078:   mItems.Clear();
17078: }
17078: 
17078: nsresult
17078: nsDOMDataTransfer::SetDataWithPrincipal(const nsAString& aFormat,
17078:                                         nsIVariant* aData,
17078:                                         PRUint32 aIndex,
17078:                                         nsIPrincipal* aPrincipal)
17078: {
17078:   nsAutoString format;
17078:   GetRealFormat(aFormat, format);
17078: 
17078:   // check if the item for the format already exists. In that case,
17078:   // just replace it.
17078:   TransferItem* formatitem;
17078:   if (aIndex < mItems.Length()) {
17078:     nsTArray<TransferItem>& item = mItems[aIndex];
17078:     PRUint32 count = item.Length();
17078:     for (PRUint32 i = 0; i < count; i++) {
17078:       TransferItem& itemformat = item[i];
17078:       if (itemformat.mFormat.Equals(format)) {
17078:         // don't allow replacing data that has a stronger principal
17078:         PRBool subsumes;
17078:         if (itemformat.mPrincipal && aPrincipal &&
17078:             (NS_FAILED(aPrincipal->Subsumes(itemformat.mPrincipal, &subsumes)) || !subsumes))
17078:           return NS_ERROR_DOM_SECURITY_ERR;
17078: 
17078:         itemformat.mPrincipal = aPrincipal;
17078:         itemformat.mData = aData;
17078:         return NS_OK;
17078:       }
17078:     }
17078: 
17078:     // add a new format
17078:     formatitem = item.AppendElement();
17078:   }
17078:   else {
17078:     NS_ASSERTION(aIndex == mItems.Length(), "Index out of range");
17078: 
17078:     // add a new index
17078:     nsTArray<TransferItem>* item = mItems.AppendElement();
17078:     NS_ENSURE_TRUE(item, NS_ERROR_OUT_OF_MEMORY);
17078: 
17078:     formatitem = item->AppendElement();
17078:   }
17078: 
17078:   NS_ENSURE_TRUE(formatitem, NS_ERROR_OUT_OF_MEMORY);
17078: 
17078:   formatitem->mFormat = format;
17078:   formatitem->mPrincipal = aPrincipal;
17078:   formatitem->mData = aData;
17078: 
17078:   return NS_OK;
17078: }
17078: 
17078: nsIPrincipal*
17078: nsDOMDataTransfer::GetCurrentPrincipal()
17078: {
17078:   nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
17078: 
17078:   nsCOMPtr<nsIPrincipal> currentPrincipal;
17078:   ssm->GetSubjectPrincipal(getter_AddRefs(currentPrincipal));
17078:   if (!currentPrincipal)
17078:     ssm->GetSystemPrincipal(getter_AddRefs(currentPrincipal));
17078: 
17078:   return currentPrincipal.get();
17078: }
17078: 
17078: void
17078: nsDOMDataTransfer::GetRealFormat(const nsAString& aInFormat, nsAString& aOutFormat)
17078: {
17078:   // treat text/unicode as equivalent to text/plain
17078:   if (aInFormat.EqualsLiteral("Text") || aInFormat.EqualsLiteral("text/unicode"))
17078:     aOutFormat.AssignLiteral("text/plain");
17078:   else if (aInFormat.EqualsLiteral("URL"))
17078:     aOutFormat.AssignLiteral("text/uri-list");
17078:   else
17078:     aOutFormat.Assign(aInFormat);
17078: }
17078: 
17078: void
17078: nsDOMDataTransfer::CacheExternalFormats()
17078: {
17078:   // Called during the constructor to cache the formats available from an
17078:   // external drag. The data associated with each format will be set to null.
17078:   // This data will instead only be retrieved in FillInExternalDragData when
17078:   // asked for, as it may be time consuming for the source application to
17078:   // generate it.
17078: 
38841:   nsCOMPtr<nsIDragSession> dragSession = nsContentUtils::GetDragSession();
17078:   if (!dragSession)
17078:     return;
17078: 
17078:   // make sure that the system principal is used for external drags
17078:   nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
17078:   nsCOMPtr<nsIPrincipal> sysPrincipal;
17078:   ssm->GetSystemPrincipal(getter_AddRefs(sysPrincipal));
17078: 
17078:   // there isn't a way to get a list of the formats that might be available on
17078:   // all platforms, so just check for the types that can actually be imported
17078:   // XXXndeakin there are some other formats but those are platform specific.
17078:   const char* formats[] = { kFileMime, kHTMLMime, kURLMime, kURLDataMime, kUnicodeMime };
17078: 
17078:   PRUint32 count;
17078:   dragSession->GetNumDropItems(&count);
17078:   for (PRUint32 c = 0; c < count; c++) {
17078:     for (PRUint32 f = 0; f < NS_ARRAY_LENGTH(formats); f++) {
17078:       // IsDataFlavorSupported doesn't take an index as an argument and just
17078:       // checks if any of the items support a particular flavor, even though
17078:       // the GetData method does take an index. Here, we just assume that
17078:       // every item being dragged has the same set of flavors.
17078:       PRBool supported;
17078:       dragSession->IsDataFlavorSupported(formats[f], &supported);
17078:       // if the format is supported, add an item to the array with null as
17078:       // the data. When retrieved, GetRealData will read the data.
17078:       if (supported) {
22672:         if (strcmp(formats[f], kUnicodeMime) == 0) {
17078:           SetDataWithPrincipal(NS_LITERAL_STRING("text/plain"), nsnull, c, sysPrincipal);
17078:         }
17078:         else {
22672:           if (strcmp(formats[f], kURLDataMime) == 0)
17078:             SetDataWithPrincipal(NS_LITERAL_STRING("text/uri-list"), nsnull, c, sysPrincipal);
17078:           SetDataWithPrincipal(NS_ConvertUTF8toUTF16(formats[f]), nsnull, c, sysPrincipal);
17078:         }
17078:       }
17078:     }
17078:   }
17078: }
17078: 
17078: void
17078: nsDOMDataTransfer::FillInExternalDragData(TransferItem& aItem, PRUint32 aIndex)
17078: {
17078:   NS_PRECONDITION(mIsExternal, "Not an external drag");
17078: 
17078:   if (!aItem.mData) {
17078:     nsCOMPtr<nsITransferable> trans =
17078:       do_CreateInstance("@mozilla.org/widget/transferable;1");
17078:     if (!trans)
17078:       return;
17078: 
17078:     NS_ConvertUTF16toUTF8 utf8format(aItem.mFormat);
17078:     const char* format = utf8format.get();
17078:     if (strcmp(format, "text/plain") == 0)
17078:       format = kUnicodeMime;
17078:     else if (strcmp(format, "text/uri-list") == 0)
17078:       format = kURLDataMime;
17078: 
38841:     nsCOMPtr<nsIDragSession> dragSession = nsContentUtils::GetDragSession();
17078:     if (!dragSession)
17078:       return;
17078: 
17078:     trans->AddDataFlavor(format);
17078:     dragSession->GetData(trans, aIndex);
17078: 
17078:     PRUint32 length = 0;
17078:     nsCOMPtr<nsISupports> data;
17078:     trans->GetTransferData(format, getter_AddRefs(data), &length);
17078:     if (!data)
17078:       return;
17078: 
17078:     nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
17078:     if (!variant)
17078:       return;
17078: 
17078:     nsCOMPtr<nsISupportsString> supportsstr = do_QueryInterface(data);
17078:     if (supportsstr) {
17078:       nsAutoString str;
17078:       supportsstr->GetData(str);
17078:       variant->SetAsAString(str);
17078:     }
17078:     else {
17078:       variant->SetAsISupports(data);
17078:     }
17078:     aItem.mData = variant;
17078:   }
17078: }
