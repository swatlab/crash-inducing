22840: /* ***** BEGIN LICENSE BLOCK *****
22840:  * 
22840:  * Copyright (c) 2008, Mozilla Corporation
22840:  * All rights reserved.
22840:  * 
22840:  * Redistribution and use in source and binary forms, with or without
22840:  * modification, are permitted provided that the following conditions are met:
22840:  * 
22840:  * * Redistributions of source code must retain the above copyright notice, this
22840:  *   list of conditions and the following disclaimer.
22840:  * * Redistributions in binary form must reproduce the above copyright notice,
22840:  *   this list of conditions and the following disclaimer in the documentation
22840:  *   and/or other materials provided with the distribution.
22840:  * * Neither the name of the Mozilla Corporation nor the names of its
22840:  *   contributors may be used to endorse or promote products derived from this
22840:  *   software without specific prior written permission.
22840:  * 
22840:  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
22840:  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
22840:  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
22840:  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
22840:  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
22840:  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
22840:  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
22840:  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
22840:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
22840:  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
22840:  * 
22840:  * Contributor(s):
22840:  *   Josh Aas <josh@mozilla.com>
24506:  *   Jim Mathies <jmathies@mozilla.com>
22840:  * 
22840:  * ***** END LICENSE BLOCK ***** */
22840: 
22840: #include "nptest_platform.h"
22840: 
24506: #include <windows.h>
31130: #include <windowsx.h>
36729: #include <stdio.h>
24506: 
33639:  using namespace std;
33639: 
27272: void SetSubclass(HWND hWnd, InstanceData* instanceData);
27272: void ClearSubclass(HWND hWnd);
27272: LRESULT CALLBACK PluginWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
27272: 
33358: struct _PlatformData {
33358:   HWND childWindow;
33358: };
33358: 
26802: bool
26802: pluginSupportsWindowMode()
26802: {
27272:   return true;
26802: }
26802: 
26802: bool
26802: pluginSupportsWindowlessMode()
26802: {
26802:   return true;
26802: }
26802: 
22840: NPError
22840: pluginInstanceInit(InstanceData* instanceData)
22840: {
33358:   instanceData->platformData = static_cast<PlatformData*>
33358:     (NPN_MemAlloc(sizeof(PlatformData)));
33358:   if (!instanceData->platformData)
33358:     return NPERR_OUT_OF_MEMORY_ERROR;
33358: 
33358:   instanceData->platformData->childWindow = NULL;
22840:   return NPERR_NO_ERROR;
22840: }
22840: 
26802: void
26802: pluginInstanceShutdown(InstanceData* instanceData)
22840: {
33358:   NPN_MemFree(instanceData->platformData);
33358:   instanceData->platformData = 0;
24506: }
24506: 
26802: void
26942: pluginDoSetWindow(InstanceData* instanceData, NPWindow* newWindow)
26942: {
26942:   instanceData->window = *newWindow;
26942: }
26942: 
33358: #define CHILD_WIDGET_SIZE 10
33358: 
26942: void
26802: pluginWidgetInit(InstanceData* instanceData, void* oldWindow)
26802: {
27272:   HWND hWnd = (HWND)instanceData->window.window;
27272:   if (oldWindow) {
39855:     // chrashtests/539897-1.html excercises this code
27272:     HWND hWndOld = (HWND)oldWindow;
27272:     ClearSubclass(hWndOld);
33358:     if (instanceData->platformData->childWindow) {
33358:       ::DestroyWindow(instanceData->platformData->childWindow);
24506:     }
33358:   }
33358: 
27272:   SetSubclass(hWnd, instanceData);
33358: 
33358:   instanceData->platformData->childWindow =
33358:     ::CreateWindowW(L"SCROLLBAR", L"Dummy child window", 
33358:                     WS_CHILD, 0, 0, CHILD_WIDGET_SIZE, CHILD_WIDGET_SIZE, hWnd, NULL,
33358:                     NULL, NULL);
22840: }
22840: 
29991: static void
29991: drawToDC(InstanceData* instanceData, HDC dc,
29991:          int x, int y, int width, int height)
29991: {
29991:   HBITMAP offscreenBitmap = ::CreateCompatibleBitmap(dc, width, height);
29991:   if (!offscreenBitmap)
29991:     return;
29991:   HDC offscreenDC = ::CreateCompatibleDC(dc);
29991:   if (!offscreenDC) {
29991:     ::DeleteObject(offscreenBitmap);
29991:     return;
29991:   }
29991: 
29991:   HBITMAP oldOffscreenBitmap =
29991:     (HBITMAP)::SelectObject(offscreenDC, offscreenBitmap);
29991:   ::SetBkMode(offscreenDC, TRANSPARENT);
29991:   BYTE alpha = 255;
29991:   RECT fill = { 0, 0, width, height };
29991: 
29991:   switch (instanceData->scriptableObject->drawMode) {
29991:     case DM_DEFAULT:
29991:     {
29991:       HBRUSH brush = ::CreateSolidBrush(RGB(0, 0, 0));
29991:       if (brush) {
29991:         ::FillRect(offscreenDC, &fill, brush);
29991:         ::DeleteObject(brush);
29991:       }
29991:       if (width > 6 && height > 6) {
29991:         brush = ::CreateSolidBrush(RGB(192, 192, 192));
29991:         if (brush) {
29991:           RECT inset = { 3, 3, width - 3, height - 3 };
29991:           ::FillRect(offscreenDC, &inset, brush);
29991:           ::DeleteObject(brush);
29991:         }
29991:       }
29991: 
29991:       const char* uaString = NPN_UserAgent(instanceData->npp);
29991:       if (uaString && width > 10 && height > 10) {
29991:         HFONT font =
29991:           ::CreateFontA(20, 0, 0, 0, 400, FALSE, FALSE, FALSE,
29991:                         DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
29991:                         CLIP_DEFAULT_PRECIS, 5, // CLEARTYPE_QUALITY
29991:                         DEFAULT_PITCH, "Arial");
29991:         if (font) {
29991:           HFONT oldFont = (HFONT)::SelectObject(offscreenDC, font);
29991:           RECT inset = { 5, 5, width - 5, height - 5 };
29991:           ::DrawTextA(offscreenDC, uaString, -1, &inset,
29991:                       DT_LEFT | DT_TOP | DT_NOPREFIX | DT_WORDBREAK);
29991:           ::SelectObject(offscreenDC, oldFont);
29991:           ::DeleteObject(font);
29991:         }
29991:       }
29991:     }
29991:     break;
29991: 
29991:     case DM_SOLID_COLOR:
29991:     {
29991:       PRUint32 rgba = instanceData->scriptableObject->drawColor;
29991:       BYTE r = ((rgba & 0xFF0000) >> 16);
29991:       BYTE g = ((rgba & 0xFF00) >> 8);
29991:       BYTE b = (rgba & 0xFF);
29991:       alpha = ((rgba & 0xFF000000) >> 24);
29991: 
29991:       HBRUSH brush = ::CreateSolidBrush(RGB(r, g, b));
29991:       if (brush) {
29991:         ::FillRect(offscreenDC, &fill, brush);
29991:         ::DeleteObject(brush);
29991:       }
29991:     }
29991:     break;
29991:   }
29991: 
29991:   BLENDFUNCTION blendFunc;
29991:   blendFunc.BlendOp = AC_SRC_OVER;
29991:   blendFunc.BlendFlags = 0;
29991:   blendFunc.SourceConstantAlpha = alpha;
29991:   blendFunc.AlphaFormat = 0;
29991:   ::AlphaBlend(dc, x, y, width, height, offscreenDC, 0, 0, width, height,
29991:                blendFunc);
29991:   ::SelectObject(offscreenDC, oldOffscreenBitmap);
29991:   ::DeleteObject(offscreenDC);
29991:   ::DeleteObject(offscreenBitmap);
29991: }
29991: 
22840: void
22840: pluginDraw(InstanceData* instanceData)
22840: {
24506:   NPP npp = instanceData->npp;
24506:   if (!npp)
24506:     return;
24506: 
27272:   HDC hdc = NULL;
27272:   PAINTSTRUCT ps;
27272: 
27272:   if (instanceData->hasWidget)
27272:     hdc = ::BeginPaint((HWND)instanceData->window.window, &ps);
27272:   else
27272:     hdc = (HDC)instanceData->window.window;
24506: 
24506:   if (hdc == NULL)
24506:     return;
24506: 
27272:   // Push the browser's hdc on the resource stack. If this test plugin is windowless,
27272:   // we share the drawing surface with the rest of the browser.
24506:   int savedDCID = SaveDC(hdc);
24506: 
27272:   // When we have a widget, window.x/y are meaningless since our widget
27272:   // is always positioned correctly and we just draw into it at 0,0.
27272:   int x = instanceData->hasWidget ? 0 : instanceData->window.x;
27272:   int y = instanceData->hasWidget ? 0 : instanceData->window.y;
27280:   int width = instanceData->window.width;
27280:   int height = instanceData->window.height;
29991:   drawToDC(instanceData, hdc, x, y, width, height);
24506: 
24506:   // Pop our hdc changes off the resource stack
24506:   RestoreDC(hdc, savedDCID);
27272: 
27272:   if (instanceData->hasWidget)
27272:     ::EndPaint((HWND)instanceData->window.window, &ps);
53945: 
53945:   notifyDidPaint(instanceData);
24506: }
26802: 
27272: /* script interface */
27272: 
27272: int32_t
27272: pluginGetEdge(InstanceData* instanceData, RectEdge edge)
27272: {
27272:   if (!instanceData || !instanceData->hasWidget)
27272:     return NPTEST_INT32_ERROR;
27272: 
30144:   // Get the plugin client rect in screen coordinates
30144:   RECT rect = {0};
30144:   if (!::GetClientRect((HWND)instanceData->window.window, &rect))
30144:     return NPTEST_INT32_ERROR;
30144:   ::MapWindowPoints((HWND)instanceData->window.window, NULL, (LPPOINT)&rect, 2);
27272: 
30144:   // Get the toplevel window frame rect in screen coordinates
30144:   HWND rootWnd = ::GetAncestor((HWND)instanceData->window.window, GA_ROOT);
30144:   if (!rootWnd)
27272:     return NPTEST_INT32_ERROR;
30144:   RECT rootRect;
30144:   if (!::GetWindowRect(rootWnd, &rootRect))
30144:     return NPTEST_INT32_ERROR;
27272: 
27272:   switch (edge) {
27272:   case EDGE_LEFT:
30144:     return rect.left - rootRect.left;
27272:   case EDGE_TOP:
30144:     return rect.top - rootRect.top;
27272:   case EDGE_RIGHT:
30144:     return rect.right - rootRect.left;
27272:   case EDGE_BOTTOM:
30144:     return rect.bottom - rootRect.top;
27272:   }
27272: 
27272:   return NPTEST_INT32_ERROR;
27272: }
27272: 
30145: static BOOL
30145: getWindowRegion(HWND wnd, HRGN rgn)
30145: {
30145:   if (::GetWindowRgn(wnd, rgn) != ERROR)
30145:     return TRUE;
30145: 
30145:   RECT clientRect;
30145:   if (!::GetClientRect(wnd, &clientRect))
30145:     return FALSE;
30145:   return ::SetRectRgn(rgn, 0, 0, clientRect.right, clientRect.bottom);
30145: }
30145: 
30145: static RGNDATA*
30145: computeClipRegion(InstanceData* instanceData)
30145: {
30145:   HWND wnd = (HWND)instanceData->window.window;
30145:   HRGN rgn = ::CreateRectRgn(0, 0, 0, 0);
30145:   if (!rgn)
30145:     return NULL;
30145:   HRGN ancestorRgn = ::CreateRectRgn(0, 0, 0, 0);
30145:   if (!ancestorRgn) {
30145:     ::DeleteObject(rgn);
30145:     return NULL;
30145:   }
30145:   if (!getWindowRegion(wnd, rgn)) {
30145:     ::DeleteObject(ancestorRgn);
30145:     ::DeleteObject(rgn);
30145:     return NULL;
30145:   }
30145: 
30145:   HWND ancestor = wnd;
30145:   for (;;) {
30145:     ancestor = ::GetAncestor(ancestor, GA_PARENT);
30145:     if (!ancestor || ancestor == ::GetDesktopWindow()) {
30145:       ::DeleteObject(ancestorRgn);
30145: 
30145:       DWORD size = ::GetRegionData(rgn, 0, NULL);
30145:       if (!size) {
30145:         ::DeleteObject(rgn);
30145:         return NULL;
30145:       }
30145: 
30145:       HANDLE heap = ::GetProcessHeap();
30145:       RGNDATA* data = static_cast<RGNDATA*>(::HeapAlloc(heap, 0, size));
30145:       if (!data) {
30145:         ::DeleteObject(rgn);
30145:         return NULL;
30145:       }
30145:       DWORD result = ::GetRegionData(rgn, size, data);
30145:       ::DeleteObject(rgn);
30145:       if (!result) {
30145:         ::HeapFree(heap, 0, data);
30145:         return NULL;
30145:       }
30145: 
30145:       return data;
30145:     }
30145: 
30145:     if (!getWindowRegion(ancestor, ancestorRgn)) {
30145:       ::DeleteObject(ancestorRgn);
30145:       ::DeleteObject(rgn);
30145:       return 0;
30145:     }
30145: 
30145:     POINT pt = { 0, 0 };
30145:     ::MapWindowPoints(ancestor, wnd, &pt, 1);
30145:     if (::OffsetRgn(ancestorRgn, pt.x, pt.y) == ERROR ||
30145:         ::CombineRgn(rgn, rgn, ancestorRgn, RGN_AND) == ERROR) {
30145:       ::DeleteObject(ancestorRgn);
30145:       ::DeleteObject(rgn);
30145:       return 0;
30145:     }
30145:   }
30145: }
30145: 
27272: int32_t
27272: pluginGetClipRegionRectCount(InstanceData* instanceData)
27272: {
30145:   RGNDATA* data = computeClipRegion(instanceData);
30145:   if (!data)
30145:     return NPTEST_INT32_ERROR;
30145: 
30145:   int32_t result = data->rdh.nCount;
30145:   ::HeapFree(::GetProcessHeap(), 0, data);
30145:   return result;
30145: }
30145: 
30145: static int32_t
30145: addOffset(LONG coord, int32_t offset)
30145: {
30145:   if (offset == NPTEST_INT32_ERROR)
30145:     return NPTEST_INT32_ERROR;
30145:   return coord + offset;
27272: }
27272: 
27272: int32_t
27272: pluginGetClipRegionRectEdge(InstanceData* instanceData, 
27272:     int32_t rectIndex, RectEdge edge)
27272: {
30145:   RGNDATA* data = computeClipRegion(instanceData);
30145:   if (!data)
30145:     return NPTEST_INT32_ERROR;
30145: 
30145:   HANDLE heap = ::GetProcessHeap();
30145:   if (rectIndex >= int32_t(data->rdh.nCount)) {
30145:     ::HeapFree(heap, 0, data);
30145:     return NPTEST_INT32_ERROR;
30145:   }
30145: 
30145:   RECT rect = reinterpret_cast<RECT*>(data->Buffer)[rectIndex];
30145:   ::HeapFree(heap, 0, data);
30145: 
30145:   switch (edge) {
30145:   case EDGE_LEFT:
30145:     return addOffset(rect.left, pluginGetEdge(instanceData, EDGE_LEFT));
30145:   case EDGE_TOP:
30145:     return addOffset(rect.top, pluginGetEdge(instanceData, EDGE_TOP));
30145:   case EDGE_RIGHT:
30145:     return addOffset(rect.right, pluginGetEdge(instanceData, EDGE_LEFT));
30145:   case EDGE_BOTTOM:
30145:     return addOffset(rect.bottom, pluginGetEdge(instanceData, EDGE_TOP));
30145:   }
30145: 
30145:   return NPTEST_INT32_ERROR;
27272: }
27272: 
27272: /* windowless plugin events */
27272: 
31130: static bool
33863: handleEventInternal(InstanceData* instanceData, NPEvent* pe, LRESULT* result)
31130: {
31130:   switch ((UINT)pe->event) {
31130:     case WM_PAINT:
31130:       pluginDraw(instanceData);
31130:       return true;
31130: 
33863:     case WM_MOUSEACTIVATE:
33863:       if (instanceData->hasWidget) {
33863:         ::SetFocus((HWND)instanceData->window.window);
33863:         *result = MA_ACTIVATEANDEAT;
33863:         return true;
33863:       }
33863:       return false;
33863: 
33863:     case WM_MOUSEWHEEL:
33863:       return true;
33863: 
37315:     case WM_WINDOWPOSCHANGED: {
37315:       WINDOWPOS* pPos = (WINDOWPOS*)pe->lParam;
37315:       instanceData->winX = instanceData->winY = 0;
37315:       if (pPos) {
37315:         instanceData->winX = pPos->x;
37315:         instanceData->winY = pPos->y;
37315:         return true;
37315:       }
37315:       return false;
37315:     }
37315: 
31130:     case WM_MOUSEMOVE:
31130:     case WM_LBUTTONDOWN:
31130:     case WM_LBUTTONUP:
31130:     case WM_MBUTTONDOWN:
31130:     case WM_MBUTTONUP:
31130:     case WM_RBUTTONDOWN:
31130:     case WM_RBUTTONUP: {
37315:       int x = instanceData->hasWidget ? 0 : instanceData->winX;
37315:       int y = instanceData->hasWidget ? 0 : instanceData->winY;
31130:       instanceData->lastMouseX = GET_X_LPARAM(pe->lParam) - x;
31130:       instanceData->lastMouseY = GET_Y_LPARAM(pe->lParam) - y;
31130:       return true;
31130:     }
31130: 
31130:     default:
31130:       return false;
31130:   }
31130: }
31130: 
26802: int16_t
26802: pluginHandleEvent(InstanceData* instanceData, void* event)
26802: {
26802:   NPEvent* pe = (NPEvent*)event;
26802: 
26802:   if (pe == NULL || instanceData == NULL ||
26802:       instanceData->window.type != NPWindowTypeDrawable)
26802:     return 0;   
26802: 
33863:   LRESULT result = 0;
33863:   return handleEventInternal(instanceData, pe, &result);
26802: }
26942: 
27272: /* windowed plugin events */
27272: 
27272: LRESULT CALLBACK PluginWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
26942: {
27272: 	WNDPROC wndProc = (WNDPROC)GetProp(hWnd, "MozillaWndProc");
27272:   if (!wndProc)
27272:     return 0;
27272:   InstanceData* pInstance = (InstanceData*)GetProp(hWnd, "InstanceData");
27272:   if (!pInstance)
27272:     return 0;
27272: 
31130:   NPEvent event = { uMsg, wParam, lParam };
31130: 
33863:   LRESULT result = 0;
33863:   if (handleEventInternal(pInstance, &event, &result))
33863:     return result;
26942: 
27272:   if (uMsg == WM_CLOSE) {
27272:     ClearSubclass((HWND)pInstance->window.window);
26942:   }
26942: 
27272:   return CallWindowProc(wndProc, hWnd, uMsg, wParam, lParam);
27272: }
27272: 
27272: void
27272: ClearSubclass(HWND hWnd)
26942: {
27272:   if (GetProp(hWnd, "MozillaWndProc")) {
36802:     ::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)GetProp(hWnd, "MozillaWndProc"));
27272:     RemoveProp(hWnd, "MozillaWndProc");
27272:     RemoveProp(hWnd, "InstanceData");
26942:   }
27272: }
27272: 
27272: void
27272: SetSubclass(HWND hWnd, InstanceData* instanceData)
27272: {
27272:   // Subclass the plugin window so we can handle our own windows events.
27272:   SetProp(hWnd, "InstanceData", (HANDLE)instanceData);
36802:   WNDPROC origProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)PluginWndProc);
27272:   SetProp(hWnd, "MozillaWndProc", (HANDLE)origProc);
27272: }
33358: 
33358: static void checkEquals(int a, int b, const char* msg, string& error)
33358: {
33358:   if (a == b) {
33358:     return;
33358:   }
33358: 
33358:   error.append(msg);
33358:   char buf[100];
33358:   sprintf(buf, " (got %d, expected %d)\n", a, b);
33358:   error.append(buf);
33358: }
33358: 
33358: void pluginDoInternalConsistencyCheck(InstanceData* instanceData, string& error)
33358: {
33358:   if (instanceData->platformData->childWindow) {
33358:     RECT childRect;
33358:     ::GetWindowRect(instanceData->platformData->childWindow, &childRect);
33358:     RECT ourRect;
33358:     HWND hWnd = (HWND)instanceData->window.window;
33358:     ::GetWindowRect(hWnd, &ourRect);
33358:     checkEquals(childRect.left, ourRect.left, "Child widget left", error);
33358:     checkEquals(childRect.top, ourRect.top, "Child widget top", error);
33358:     checkEquals(childRect.right, childRect.left + CHILD_WIDGET_SIZE, "Child widget width", error);
33358:     checkEquals(childRect.bottom, childRect.top + CHILD_WIDGET_SIZE, "Child widget height", error);
33358:   }
33358: }
