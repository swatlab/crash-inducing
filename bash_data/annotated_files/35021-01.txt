    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@netscape.com>
    1:  *   Chris Saari <saari@netscape.com>
    1:  *   Asko Tontti <atontti@cc.hut.fi>
    1:  *   Arron Mogge <paper@animecity.nu>
    1:  *   Andrew Smith
 7009:  *   Federico Mena-Quintero <federico@novell.com>
32424:  *   Bobby Holley <bobbyholley@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsComponentManagerUtils.h"
    1: #include "imgIContainerObserver.h"
 7009: #include "ImageErrors.h"
 7009: #include "imgIDecoder.h"
 7009: #include "imgIDecoderObserver.h"
    1: #include "imgContainer.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsAutoPtr.h"
 7009: #include "nsStringStream.h"
 7009: #include "prmem.h"
 7009: #include "prlog.h"
 7009: #include "prenv.h"
32424: #include "nsTime.h"
32424: #include "ImageLogging.h"
    1: 
    1: #include "gfxContext.h"
    1: 
 7009: /* Accounting for compressed data */
 7009: #if defined(PR_LOGGING)
 7009: static PRLogModuleInfo *gCompressedImageAccountingLog = PR_NewLogModule ("CompressedImageAccounting");
 7009: #else
 7009: #define gCompressedImageAccountingLog
 7009: #endif
 7009: 
32424: /* We define our own error checking macros here for 2 reasons:
32424:  *
32424:  * 1) Most of the failures we encounter here will (hopefully) be
32424:  * the result of decoding failures (ie, bad data) and not code
32424:  * failures. As such, we don't want to clutter up debug consoles
32424:  * with spurious messages about NS_ENSURE_SUCCESS failures.
32424:  *
32424:  * 2) We want to set the internal error flag, shutdown properly,
32424:  * and end up in an error state.
32424:  *
32424:  * So this macro should be called when the desired failure behavior
32424:  * is to put the container into an error state and return failure.
32424:  * It goes without saying that macro won't compile outside of a
32424:  * non-static imgContainer method.
32424:  */
32424: #define LOG_CONTAINER_ERROR                      \
32424:   PR_BEGIN_MACRO                                 \
32424:   PR_LOG (gImgLog, PR_LOG_ERROR,                 \
32424:           ("ImgContainer: [this=%p] Error "      \
32424:            "detected at line %u for image of "   \
32424:            "type %s\n", this, __LINE__,          \
32424:            mSourceDataMimeType.get()));          \
32424:   PR_END_MACRO
32424: 
32424: #define CONTAINER_ENSURE_SUCCESS(status)      \
32424:   PR_BEGIN_MACRO                              \
32424:   nsresult _status = status; /* eval once */  \
32424:   if (_status) {                              \
32424:     LOG_CONTAINER_ERROR;                      \
32424:     DoError();                                \
32424:     return _status;                           \
32424:   }                                           \
32424:  PR_END_MACRO
32424: 
32424: #define CONTAINER_ENSURE_TRUE(arg, rv)  \
32424:   PR_BEGIN_MACRO                        \
32424:   if (!(arg)) {                         \
32424:     LOG_CONTAINER_ERROR;                \
32424:     DoError();                          \
32424:     return rv;                          \
32424:   }                                     \
32424:   PR_END_MACRO
32424: 
32424: 
32424: 
32424: static int num_containers;
32424: static int num_discardable_containers;
32424: static PRInt64 total_source_bytes;
32424: static PRInt64 discardable_source_bytes;
32424: 
32424: /* Are we globally disabling image discarding? */
32424: static PRBool
32424: DiscardingEnabled()
32424: {
32424:   static PRBool inited;
32424:   static PRBool enabled;
32424: 
32424:   if (!inited) {
32424:     inited = PR_TRUE;
32424: 
32424:     enabled = (PR_GetEnv("MOZ_DISABLE_IMAGE_DISCARD") == nsnull);
32424:   }
32424: 
32424:   return enabled;
32424: }
32424: 
32424: NS_IMPL_ISUPPORTS4(imgContainer, imgIContainer, nsITimerCallback, nsIProperties,
32424:                    nsISupportsWeakReference)
    1: 
    1: //******************************************************************************
    1: imgContainer::imgContainer() :
    1:   mSize(0,0),
32424:   mHasSize(PR_FALSE),
    1:   mAnim(nsnull),
    1:   mAnimationMode(kNormalAnimMode),
    1:   mLoopCount(-1),
 7009:   mObserver(nsnull),
32424:   mDecodeOnDraw(PR_FALSE),
32424:   mMultipart(PR_FALSE),
32424:   mInitialized(PR_FALSE),
 7009:   mDiscardable(PR_FALSE),
32424:   mLockCount(0),
32424:   mDiscardTimer(nsnull),
32424:   mHasSourceData(PR_FALSE),
32424:   mDecoded(PR_FALSE),
33531:   mHasBeenDecoded(PR_FALSE),
32424:   mDecoder(nsnull),
32424:   mWorker(nsnull),
32424:   mBytesDecoded(0),
32424:   mDecoderFlags(imgIDecoder::DECODER_FLAG_NONE),
32424:   mWorkerPending(PR_FALSE),
32424:   mInDecoder(PR_FALSE),
32424:   mError(PR_FALSE)
    1: {
32424:   // Statistics
32424:   num_containers++;
    1: }
    1: 
    1: //******************************************************************************
    1: imgContainer::~imgContainer()
    1: {
    1:   if (mAnim)
    1:     delete mAnim;
 7009: 
30479:   for (unsigned int i = 0; i < mFrames.Length(); ++i)
30479:     delete mFrames[i];
30479: 
32424:   // Discardable statistics
32424:   if (mDiscardable) {
32424:     num_discardable_containers--;
32424:     discardable_source_bytes -= mSourceData.Length();
 7009: 
 7009:     PR_LOG (gCompressedImageAccountingLog, PR_LOG_DEBUG,
 7009:             ("CompressedImageAccounting: destroying imgContainer %p.  "
32424:              "Total Containers: %d, Discardable containers: %d, "
32424:              "Total source bytes: %lld, Source bytes for discardable containers %lld",
 7009:              this,
32424:              num_containers,
32424:              num_discardable_containers,
32424:              total_source_bytes,
32424:              discardable_source_bytes));
 7009:   }
 7009: 
 7009:   if (mDiscardTimer) {
 7009:     mDiscardTimer->Cancel();
 7009:     mDiscardTimer = nsnull;
 7009:   }
32424: 
32424:   // If we have a decoder open, shut it down
32424:   if (mDecoder) {
32424:     nsresult rv = ShutdownDecoder(eShutdownIntent_Interrupted);
32424:     if (NS_FAILED(rv))
32424:       NS_WARNING("Failed to shut down decoder in destructor!");
    1:   }
    1: 
32424:   // Total statistics
32424:   num_containers--;
32424:   total_source_bytes -= mSourceData.Length();
32424: }
32424: 
    1: //******************************************************************************
32424: /* void init(in imgIDecoderObserver aObserver, in string aMimeType,
32424:              in PRUint32 aFlags); */
32424: NS_IMETHODIMP imgContainer::Init(imgIDecoderObserver *aObserver,
32424:                                  const char* aMimeType,
32424:                                  PRUint32 aFlags)
    1: {
32424:   // We don't support re-initialization
32424:   if (mInitialized)
32424:     return NS_ERROR_ILLEGAL_VALUE;
32424: 
32424:   // Not sure an error can happen before init, but be safe
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ENSURE_ARG_POINTER(aMimeType);
32424: 
32424:   // We must be non-discardable and non-decode-on-draw for
32424:   // multipart channels
32424:   NS_ABORT_IF_FALSE(!(aFlags & INIT_FLAG_MULTIPART) ||
32424:                     (!(aFlags & INIT_FLAG_DISCARDABLE) &&
32424:                      !(aFlags & INIT_FLAG_DECODE_ON_DRAW)),
32424:                     "Can't be discardable or decode-on-draw for multipart");
32424: 
32424:   // Store initialization data
32424:   mObserver = do_GetWeakReference(aObserver);
32424:   mSourceDataMimeType.Assign(aMimeType);
32424:   mDiscardable = aFlags & INIT_FLAG_DISCARDABLE;
32424:   mDecodeOnDraw = aFlags & INIT_FLAG_DECODE_ON_DRAW;;
32424:   mMultipart = aFlags & INIT_FLAG_MULTIPART;
32424: 
32424:   // Statistics
32424:   if (mDiscardable) {
32424:     num_discardable_containers++;
32424:     discardable_source_bytes += mSourceData.Length();
32424:   }
32424: 
32424:   // If we're being called from ExtractFrame (used by borderimage),
32424:   // we don't actually do any decoding. Bail early.
32424:   // XXX - This should be removed when we fix borderimage
32424:   if (mSourceDataMimeType.Length() == 0) {
32424:     mInitialized = PR_TRUE;
32424:     return NS_OK;
32424:   }
32424: 
32424:   // Determine our decoder flags. If we're doing decode-on-draw,
32424:   // we want to do a quick first pass to get the size but nothing
32424:   // else. We instantiate another decoder later to do the full
32424:   // decoding.
32424:   PRUint32 dFlags = imgIDecoder::DECODER_FLAG_NONE;
32424:   if (mDecodeOnDraw)
32424:     dFlags |= imgIDecoder::DECODER_FLAG_HEADERONLY;
32424: 
32424:   // Instantiate the decoder
32424:   nsresult rv = InitDecoder(dFlags);
32424:   CONTAINER_ENSURE_SUCCESS(rv);
32424: 
32424:   // Mark us as initialized
32424:   mInitialized = PR_TRUE;
32424: 
32424:   return NS_OK;
32424: }
32424: 
32424: //******************************************************************************
32424: /* [noscript] imgIContainer extractFrame(PRUint32 aWhichFrame,
32424:  *                                       [const] in nsIntRect aRegion,
32424:  *                                       in PRUint32 aFlags); */
32424: NS_IMETHODIMP imgContainer::ExtractFrame(PRUint32 aWhichFrame,
32424:                                          const nsIntRect &aRegion,
32424:                                          PRUint32 aFlags,
32424:                                          imgIContainer **_retval)
32424: {
32424:   NS_ENSURE_ARG_POINTER(_retval);
32424: 
32424:   nsresult rv;
32424: 
32424:   if (aWhichFrame > FRAME_MAX_VALUE)
32424:     return NS_ERROR_INVALID_ARG;
32424: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // Make a new container. This should switch to another class with bug 505959.
32424:   nsRefPtr<imgContainer> img(new imgContainer());
32424:   NS_ENSURE_TRUE(img, NS_ERROR_OUT_OF_MEMORY);
32424: 
32424:   // We don't actually have a mimetype in this case. The empty string tells the
32424:   // init routine not to try to instantiate a decoder. This should be fixed in
32424:   // bug 505959.
32424:   img->Init(nsnull, "", INIT_FLAG_NONE);
32424:   img->SetSize(aRegion.width, aRegion.height);
32424:   img->mDecoded = PR_TRUE; // Also, we need to mark the image as decoded
33531:   img->mHasBeenDecoded = PR_TRUE;
32424: 
32424:   // If a synchronous decode was requested, do it
32424:   if (aFlags & FLAG_SYNC_DECODE) {
32424:     rv = SyncDecode();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // Get the frame. If it's not there, it's probably the caller's fault for
32424:   // not waiting for the data to be loaded from the network or not passing
32424:   // FLAG_SYNC_DECODE
32424:   PRUint32 frameIndex = (aWhichFrame == FRAME_FIRST) ?
32424:                         0 : GetCurrentImgFrameIndex();
34809:   imgFrame *frame = GetDrawableImgFrame(frameIndex);
32424:   if (!frame) {
32424:     *_retval = nsnull;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
30479:   // The frame can be smaller than the image. We want to extract only the part
30479:   // of the frame that actually exists.
30479:   nsIntRect framerect = frame->GetRect();
30479:   framerect.IntersectRect(framerect, aRegion);
30479: 
31137:   if (framerect.IsEmpty())
31137:     return NS_ERROR_NOT_AVAILABLE;
31137: 
30479:   nsAutoPtr<imgFrame> subframe;
32424:   rv = frame->Extract(framerect, getter_Transfers(subframe));
30479:   if (NS_FAILED(rv))
30479:     return rv;
30479: 
30479:   img->mFrames.AppendElement(subframe.forget());
30479: 
30479:   *_retval = img.forget().get();
30479: 
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* readonly attribute PRInt32 width; */
    1: NS_IMETHODIMP imgContainer::GetWidth(PRInt32 *aWidth)
    1: {
13362:   NS_ENSURE_ARG_POINTER(aWidth);
    1: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
    1:   *aWidth = mSize.width;
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* readonly attribute PRInt32 height; */
    1: NS_IMETHODIMP imgContainer::GetHeight(PRInt32 *aHeight)
    1: {
13362:   NS_ENSURE_ARG_POINTER(aHeight);
    1: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
    1:   *aHeight = mSize.height;
    1:   return NS_OK;
    1: }
    1: 
30479: imgFrame *imgContainer::GetImgFrame(PRUint32 framenum)
 7009: {
32424:   nsresult rv = WantDecodedFrames();
32424:   CONTAINER_ENSURE_TRUE(NS_SUCCEEDED(rv), nsnull);
 7009: 
30479:   if (!mAnim) {
30479:     NS_ASSERTION(framenum == 0, "Don't ask for a frame > 0 if we're not animated!");
30479:     return mFrames.SafeElementAt(0, nsnull);
30479:   }
30479:   if (mAnim->lastCompositedFrameIndex == PRInt32(framenum))
13362:     return mAnim->compositingFrame;
30479:   return mFrames.SafeElementAt(framenum, nsnull);
30479: }
30479: 
34809: imgFrame *imgContainer::GetDrawableImgFrame(PRUint32 framenum)
34809: {
34809:   imgFrame *frame = GetImgFrame(framenum);
34809: 
34809:   // We will return a paletted frame if it's not marked as compositing failed
34809:   // so we can catch crashes for reasons we haven't investigated.
34809:   if (frame && frame->GetCompositingFailed())
34809:     return nsnull;
34809:   return frame;
34809: }
34809: 
32424: PRUint32 imgContainer::GetCurrentImgFrameIndex() const
30479: {
30479:   if (mAnim)
30479:     return mAnim->currentAnimationFrameIndex;
30479: 
30479:   return 0;
30479: }
30479: 
30479: imgFrame *imgContainer::GetCurrentImgFrame()
30479: {
30479:   return GetImgFrame(GetCurrentImgFrameIndex());
 7009: }
 7009: 
34809: imgFrame *imgContainer::GetCurrentDrawableImgFrame()
34809: {
34809:   return GetDrawableImgFrame(GetCurrentImgFrameIndex());
34809: }
34809: 
    1: //******************************************************************************
30479: /* readonly attribute boolean currentFrameIsOpaque; */
30479: NS_IMETHODIMP imgContainer::GetCurrentFrameIsOpaque(PRBool *aIsOpaque)
    1: {
30479:   NS_ENSURE_ARG_POINTER(aIsOpaque);
 7009: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // See if we can get an image frame
30479:   imgFrame *curframe = GetCurrentImgFrame();
32424: 
32424:   // If we don't get a frame, the safe answer is "not opaque"
32424:   if (!curframe)
32424:     *aIsOpaque = PR_FALSE;
32424: 
32424:   // Otherwise, we can make a more intelligent decision
32424:   else {
30479:     *aIsOpaque = !curframe->GetNeedsBackground();
30479: 
30479:     // We are also transparent if the current frame's size doesn't cover our
30479:     // entire area.
30479:     nsIntRect framerect = curframe->GetRect();
30479:     *aIsOpaque = *aIsOpaque && (framerect != nsIntRect(0, 0, mSize.width, mSize.height));
32424:   }
30479: 
30479:   return NS_OK;
30479: }
30479: 
30479: //******************************************************************************
30479: /* [noscript] void getCurrentFrameRect(nsIntRect rect); */
30479: NS_IMETHODIMP imgContainer::GetCurrentFrameRect(nsIntRect &aRect)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // Get the current frame
30479:   imgFrame *curframe = GetCurrentImgFrame();
32424: 
32424:   // If we have the frame, use that rectangle
32424:   if (curframe)
30479:     aRect = curframe->GetRect();
30479: 
32424:   // If the frame doesn't exist, we pass the empty rectangle. It's not clear
32424:   // whether this is appropriate in general, but at the moment the only
32424:   // consumer of this method is imgRequest (when it wants to figure out dirty
32424:   // rectangles to send out batched observer updates). This should probably be
32424:   // revisited when we fix bug 503973.
32424:   else {
32424:     aRect.MoveTo(0, 0);
32424:     aRect.SizeTo(0, 0);
32424:   }
32424: 
30479:   return NS_OK;
30479: }
30479: 
30479: //******************************************************************************
30479: /* readonly attribute unsigned long currentFrameIndex; */
30479: NS_IMETHODIMP imgContainer::GetCurrentFrameIndex(PRUint32 *aCurrentFrameIdx)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
30479:   NS_ENSURE_ARG_POINTER(aCurrentFrameIdx);
30479:   
30479:   *aCurrentFrameIdx = GetCurrentImgFrameIndex();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* readonly attribute unsigned long numFrames; */
    1: NS_IMETHODIMP imgContainer::GetNumFrames(PRUint32 *aNumFrames)
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
13362:   NS_ENSURE_ARG_POINTER(aNumFrames);
    1: 
32424:   *aNumFrames = mFrames.Length();
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
30479: /* readonly attribute boolean animated; */
30479: NS_IMETHODIMP imgContainer::GetAnimated(PRBool *aAnimated)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
30479:   NS_ENSURE_ARG_POINTER(aAnimated);
30479: 
33531:   // If we have mAnim, we can know for sure
33531:   if (mAnim) {
33531:     *aAnimated = PR_TRUE;
33531:     return NS_OK;
33531:   }
33531: 
33531:   // Otherwise, we need to have been decoded to know for sure, since if we were
33531:   // decoded at least once mAnim would have been created for animated images
33531:   if (!mHasBeenDecoded)
33531:     return NS_ERROR_NOT_AVAILABLE;
33531: 
33531:   // We know for sure
33531:   *aAnimated = PR_FALSE;
30479: 
30479:   return NS_OK;
30479: }
30479: 
30479: 
30479: //******************************************************************************
32424: /* [noscript] gfxImageSurface copyFrame(in PRUint32 aWhichFrame,
32424:  *                                      in PRUint32 aFlags); */
32424: NS_IMETHODIMP imgContainer::CopyFrame(PRUint32 aWhichFrame,
32424:                                       PRUint32 aFlags,
32424:                                       gfxImageSurface **_retval)
    1: {
32424:   if (aWhichFrame > FRAME_MAX_VALUE)
32424:     return NS_ERROR_INVALID_ARG;
32424: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   nsresult rv;
32424: 
32424:   // If requested, synchronously flush any data we have lying around to the decoder
32424:   if (aFlags & FLAG_SYNC_DECODE) {
32424:     rv = SyncDecode();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
13362:   NS_ENSURE_ARG_POINTER(_retval);
 7009: 
32424:   // Get the frame. If it's not there, it's probably the caller's fault for
32424:   // not waiting for the data to be loaded from the network or not passing
32424:   // FLAG_SYNC_DECODE
32424:   PRUint32 frameIndex = (aWhichFrame == FRAME_FIRST) ?
32424:                         0 : GetCurrentImgFrameIndex();
34809:   imgFrame *frame = GetDrawableImgFrame(frameIndex);
32424:   if (!frame) {
32424:     *_retval = nsnull;
32424:     return NS_ERROR_FAILURE;
32424:   }
30479: 
30479:   nsRefPtr<gfxPattern> pattern;
30479:   frame->GetPattern(getter_AddRefs(pattern));
30479:   nsIntRect intframerect = frame->GetRect();
30479:   gfxRect framerect(intframerect.x, intframerect.y, intframerect.width, intframerect.height);
30479: 
30479:   // Create a 32-bit image surface of our size, but draw using the frame's
30479:   // rect, implicitly padding the frame out to the image's size.
30479:   nsRefPtr<gfxImageSurface> imgsurface = new gfxImageSurface(gfxIntSize(mSize.width, mSize.height),
30479:                                                              gfxASurface::ImageFormatARGB32);
30479:   gfxContext ctx(imgsurface);
30479:   ctx.SetOperator(gfxContext::OPERATOR_SOURCE);
30479:   ctx.SetPattern(pattern);
30479:   ctx.Rectangle(framerect);
30479:   ctx.Fill();
30479: 
30479:   *_retval = imgsurface.forget().get();
 3538:   return NS_OK;
30479: }
 3538: 
30479: //******************************************************************************
32424: /* [noscript] gfxASurface getFrame(in PRUint32 aWhichFrame,
32424:  *                                 in PRUint32 aFlags); */
32424: NS_IMETHODIMP imgContainer::GetFrame(PRUint32 aWhichFrame,
32424:                                      PRUint32 aFlags,
32424:                                      gfxASurface **_retval)
30479: {
32424:   if (aWhichFrame > FRAME_MAX_VALUE)
32424:     return NS_ERROR_INVALID_ARG;
32424: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   nsresult rv = NS_OK;
32424: 
32424:   // If the caller requested a synchronous decode, do it
32424:   if (aFlags & FLAG_SYNC_DECODE) {
32424:     rv = SyncDecode();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // Get the frame. If it's not there, it's probably the caller's fault for
32424:   // not waiting for the data to be loaded from the network or not passing
32424:   // FLAG_SYNC_DECODE
32424:   PRUint32 frameIndex = (aWhichFrame == FRAME_FIRST) ?
32424:                           0 : GetCurrentImgFrameIndex();
34809:   imgFrame *frame = GetDrawableImgFrame(frameIndex);
32424:   if (!frame) {
32424:     *_retval = nsnull;
32424:     return NS_ERROR_FAILURE;
32424:   }
 7009: 
30479:   nsRefPtr<gfxASurface> framesurf;
 3538: 
30479:   // If this frame covers the entire image, we can just reuse its existing
30479:   // surface.
30479:   nsIntRect framerect = frame->GetRect();
30479:   if (framerect.x == 0 && framerect.y == 0 &&
30479:       framerect.width == mSize.width &&
30479:       framerect.height == mSize.height)
30479:     rv = frame->GetSurface(getter_AddRefs(framesurf));
    1: 
30479:   // The image doesn't have a surface because it's been optimized away. Create
30479:   // one.
30479:   if (!framesurf) {
30479:     nsRefPtr<gfxImageSurface> imgsurf;
32424:     rv = CopyFrame(aWhichFrame, aFlags, getter_AddRefs(imgsurf));
30479:     framesurf = imgsurf;
30479:   }
30479: 
30479:   *_retval = framesurf.forget().get();
30479: 
30479:   return rv;
30479: }
30479: 
30479: //******************************************************************************
32424: /* readonly attribute unsigned long dataSize; */
32424: NS_IMETHODIMP imgContainer::GetDataSize(PRUint32 *_retval)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
30479:   NS_ENSURE_ARG_POINTER(_retval);
30479: 
32424:   // Start with 0
32424:   *_retval = 0;
32424: 
32424:   // Account for any compressed source data
32424:   *_retval += mSourceData.Length();
32424:   NS_ABORT_IF_FALSE(StoringSourceData() || (*_retval == 0),
32424:                     "Non-zero source data size when we aren't storing it?");
32424: 
32424:   // Account for any uncompressed frames
32424:   for (PRUint32 i = 0; i < mFrames.Length(); ++i) {
32424:     imgFrame *frame = mFrames.SafeElementAt(i, nsnull);
32424:     NS_ABORT_IF_FALSE(frame, "Null frame in frame array!");
32424:     *_retval += frame->GetImageDataLength();
    1:   }
    1: 
30479:   return NS_OK;
30479: }
30479: 
30479: nsresult imgContainer::InternalAddFrameHelper(PRUint32 framenum, imgFrame *aFrame,
30479:                                               PRUint8 **imageData, PRUint32 *imageLength,
30479:                                               PRUint32 **paletteData, PRUint32 *paletteLength)
30479: {
32424:   NS_ABORT_IF_FALSE(framenum <= mFrames.Length(), "Invalid frame index!");
32424:   if (framenum > mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   nsAutoPtr<imgFrame> frame(aFrame);
30479: 
30479:   if (paletteData && paletteLength)
30479:     frame->GetPaletteData(paletteData, paletteLength);
30479: 
30479:   frame->GetImageData(imageData, imageLength);
30479: 
30479:   mFrames.InsertElementAt(framenum, frame.forget());
 7009: 
    1:   return NS_OK;
    1: }
    1:                                   
30479: nsresult imgContainer::InternalAddFrame(PRUint32 framenum,
30479:                                         PRInt32 aX, PRInt32 aY,
30479:                                         PRInt32 aWidth, PRInt32 aHeight,
30479:                                         gfxASurface::gfxImageFormat aFormat,
30479:                                         PRUint8 aPaletteDepth,
30479:                                         PRUint8 **imageData,
30479:                                         PRUint32 *imageLength,
30479:                                         PRUint32 **paletteData,
30479:                                         PRUint32 *paletteLength)
30479: {
32424:   NS_ABORT_IF_FALSE(framenum <= mFrames.Length(), "Invalid frame index!");
32424:   if (framenum > mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   nsAutoPtr<imgFrame> frame(new imgFrame());
30479:   NS_ENSURE_TRUE(frame, NS_ERROR_OUT_OF_MEMORY);
30479: 
30479:   nsresult rv = frame->Init(aX, aY, aWidth, aHeight, aFormat, aPaletteDepth);
30479:   NS_ENSURE_SUCCESS(rv, rv);
30479: 
30479:   if (mFrames.Length() == 0) {
30479:     return InternalAddFrameHelper(framenum, frame.forget(), imageData, imageLength, 
30479:                                   paletteData, paletteLength);
30479:   }
30479: 
30479:   if (mFrames.Length() == 1) {
 7089:     // Since we're about to add our second frame, initialize animation stuff
    1:     if (!ensureAnimExists())
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     
    1:     // If we dispose of the first frame by clearing it, then the
    1:     // First Frame's refresh area is all of itself.
    1:     // RESTORE_PREVIOUS is invalid (assumed to be DISPOSE_CLEAR)
30479:     PRInt32 frameDisposalMethod = mFrames[0]->GetFrameDisposalMethod();
    1:     if (frameDisposalMethod == imgIContainer::kDisposeClear ||
    1:         frameDisposalMethod == imgIContainer::kDisposeRestorePrevious)
30479:       mAnim->firstFrameRefreshArea = mFrames[0]->GetRect();
    1:   }
    1: 
    1:   // Calculate firstFrameRefreshArea
    1:   // Some gifs are huge but only have a small area that they animate
    1:   // We only need to refresh that small area when Frame 0 comes around again
30479:   nsIntRect frameRect = frame->GetRect();
    1:   mAnim->firstFrameRefreshArea.UnionRect(mAnim->firstFrameRefreshArea, 
30479:                                          frameRect);
    1:   
30479:   rv = InternalAddFrameHelper(framenum, frame.forget(), imageData, imageLength,
30479:                               paletteData, paletteLength);
 7009:   
 7089:   // If this is our second frame (We've just added our second frame above),
 7089:   // count should now be 2.  This must be called after we AppendObject 
 7089:   // because StartAnimation checks for > 1 frames
30479:   if (mFrames.Length() == 2)
    1:     StartAnimation();
    1:   
30479:   return rv;
30479: }
30479: 
30479: /* [noscript] void appendFrame (in PRInt32 aX, in PRInt32 aY, in PRInt32 aWidth, in PRInt32 aHeight, in gfxImageFormat aFormat, [array, size_is (imageLength)] out PRUint8 imageData, out unsigned long imageLength); */
30479: NS_IMETHODIMP imgContainer::AppendFrame(PRInt32 aX, PRInt32 aY, PRInt32 aWidth,
30479:                                         PRInt32 aHeight, 
30479:                                         gfxASurface::gfxImageFormat aFormat,
30479:                                         PRUint8 **imageData,
30479:                                         PRUint32 *imageLength)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
30479:   NS_ENSURE_ARG_POINTER(imageData);
30479:   NS_ENSURE_ARG_POINTER(imageLength);
30479: 
32424:   return InternalAddFrame(mFrames.Length(), aX, aY, aWidth, aHeight, aFormat, 
30479:                           /* aPaletteDepth = */ 0, imageData, imageLength,
30479:                           /* aPaletteData = */ nsnull, 
30479:                           /* aPaletteLength = */ nsnull);
30479: }
30479: 
30479: /* [noscript] void appendPalettedFrame (in PRInt32 aX, in PRInt32 aY, in PRInt32 aWidth, in PRInt32 aHeight, in gfxImageFormat aFormat, in PRUint8 aPaletteDepth, [array, size_is (imageLength)] out PRUint8 imageData, out unsigned long imageLength, [array, size_is (paletteLength)] out PRUint32 paletteData, out unsigned long paletteLength); */
30479: NS_IMETHODIMP imgContainer::AppendPalettedFrame(PRInt32 aX, PRInt32 aY,
30479:                                                 PRInt32 aWidth, PRInt32 aHeight,
30479:                                                 gfxASurface::gfxImageFormat aFormat,
30479:                                                 PRUint8 aPaletteDepth,
30479:                                                 PRUint8 **imageData,
30479:                                                 PRUint32 *imageLength,
30479:                                                 PRUint32 **paletteData,
30479:                                                 PRUint32 *paletteLength)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
30479:   NS_ENSURE_ARG_POINTER(imageData);
30479:   NS_ENSURE_ARG_POINTER(imageLength);
30479:   NS_ENSURE_ARG_POINTER(paletteData);
30479:   NS_ENSURE_ARG_POINTER(paletteLength);
30479: 
32424:   return InternalAddFrame(mFrames.Length(), aX, aY, aWidth, aHeight, aFormat, 
30479:                           aPaletteDepth, imageData, imageLength,
30479:                           paletteData, paletteLength);
30479: }
30479: 
32424: /*  [noscript] void setSize(in long aWidth, in long aHeight); */
32424: NS_IMETHODIMP imgContainer::SetSize(PRInt32 aWidth, PRInt32 aHeight)
32424: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // Ensure that we have positive values
32424:   // XXX - Why isn't the size unsigned? Should this be changed?
32424:   if ((aWidth < 0) || (aHeight < 0))
32424:     return NS_ERROR_INVALID_ARG;
32424: 
32424:   // if we already have a size, check the new size against the old one
32424:   if (mHasSize &&
32424:       ((aWidth != mSize.width) || (aHeight != mSize.height))) {
32424: 
32424:     // Alter the warning depending on whether the channel is multipart
32424:     if (!mMultipart)
32424:       NS_WARNING("Image changed size on redecode! This should not happen!");
32424:     else
32424:       NS_WARNING("Multipart channel sent an image of a different size");
32424: 
32424:     DoError();
32424:     return NS_ERROR_UNEXPECTED;
32424:   }
32424: 
32424:   // Set the size and flag that we have it
32424:   mSize.SizeTo(aWidth, aHeight);
32424:   mHasSize = PR_TRUE;
32424: 
32424:   return NS_OK;
32424: }
32424: 
32424: /*  [noscript] void ensureCleanFrame(in unsigned long aFramenum, in PRInt32 aX, 
32424:                                      in PRInt32 aY, in PRInt32 aWidth, 
32424:                                      in PRInt32 aHeight, in gfxImageFormat aFormat, 
32424:                                      [array, size_is(imageLength)]
32424:                                        out PRUint8 imageData,
32424:                                      out unsigned long imageLength); */
30479: NS_IMETHODIMP imgContainer::EnsureCleanFrame(PRUint32 aFrameNum, PRInt32 aX, PRInt32 aY,
30479:                                              PRInt32 aWidth, PRInt32 aHeight, 
30479:                                              gfxASurface::gfxImageFormat aFormat,
30479:                                              PRUint8 **imageData, PRUint32 *imageLength)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
30479:   NS_ENSURE_ARG_POINTER(imageData);
30479:   NS_ENSURE_ARG_POINTER(imageLength);
32424:   NS_ABORT_IF_FALSE(aFrameNum <= mFrames.Length(), "Invalid frame index!");
32424:   if (aFrameNum > mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   // Adding a frame that doesn't already exist.
32424:   if (aFrameNum == mFrames.Length())
30479:     return InternalAddFrame(aFrameNum, aX, aY, aWidth, aHeight, aFormat, 
30479:                             /* aPaletteDepth = */ 0, imageData, imageLength,
30479:                             /* aPaletteData = */ nsnull, 
30479:                             /* aPaletteLength = */ nsnull);
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
30479:   if (!frame)
30479:     return InternalAddFrame(aFrameNum, aX, aY, aWidth, aHeight, aFormat, 
30479:                             /* aPaletteDepth = */ 0, imageData, imageLength,
30479:                             /* aPaletteData = */ nsnull, 
30479:                             /* aPaletteLength = */ nsnull);
30479: 
30479:   // See if we can re-use the frame that already exists.
30479:   nsIntRect rect = frame->GetRect();
30479:   if (rect.x != aX || rect.y != aY || rect.width != aWidth || rect.height != aHeight ||
30479:       frame->GetFormat() != aFormat) {
30479:     delete frame;
30479:     return InternalAddFrame(aFrameNum, aX, aY, aWidth, aHeight, aFormat, 
30479:                             /* aPaletteDepth = */ 0, imageData, imageLength,
30479:                             /* aPaletteData = */ nsnull, 
30479:                             /* aPaletteLength = */ nsnull);
30479:   }
30479: 
30479:   // We can re-use the frame.
30479:   frame->GetImageData(imageData, imageLength);
30479: 
30479:   return NS_OK;
30479: }
30479: 
30479: 
30479: //******************************************************************************
30479: /* void frameUpdated (in unsigned long framenumber, in nsIntRect rect); */
30479: NS_IMETHODIMP imgContainer::FrameUpdated(PRUint32 aFrameNum, nsIntRect &aUpdatedRect)
30479: {
33647:   NS_ASSERTION(aFrameNum < mFrames.Length(), "Invalid frame index!");
32424:   if (aFrameNum >= mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
32424:   NS_ABORT_IF_FALSE(frame, "Calling FrameUpdated on frame that doesn't exist!");
30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
30479: 
30479:   frame->ImageUpdated(aUpdatedRect);
30479: 
30479:   return NS_OK;
30479: }
30479: 
30479: //******************************************************************************
30479: /* void setFrameDisposalMethod (in unsigned long framenumber, in PRInt32 aDisposalMethod); */
30479: NS_IMETHODIMP imgContainer::SetFrameDisposalMethod(PRUint32 aFrameNum, PRInt32 aDisposalMethod)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
32424:   if (aFrameNum >= mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
32424:   NS_ABORT_IF_FALSE(frame,
32424:                     "Calling SetFrameDisposalMethod on frame that doesn't exist!");
30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
30479: 
30479:   frame->SetFrameDisposalMethod(aDisposalMethod);
30479: 
30479:   return NS_OK;
30479: }
30479: 
30479: //******************************************************************************
30479: /* void setFrameTimeout (in unsigned long framenumber, in PRInt32 aTimeout); */
30479: NS_IMETHODIMP imgContainer::SetFrameTimeout(PRUint32 aFrameNum, PRInt32 aTimeout)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
32424:   if (aFrameNum >= mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
32424:   NS_ABORT_IF_FALSE(frame, "Calling SetFrameTimeout on frame that doesn't exist!");
30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
30479: 
30479:   frame->SetTimeout(aTimeout);
30479: 
30479:   return NS_OK;
30479: }
30479: 
30479: //******************************************************************************
30479: /* void setFrameBlendMethod (in unsigned long framenumber, in PRInt32 aBlendMethod); */
30479: NS_IMETHODIMP imgContainer::SetFrameBlendMethod(PRUint32 aFrameNum, PRInt32 aBlendMethod)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
32424:   if (aFrameNum >= mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
32424:   NS_ABORT_IF_FALSE(frame, "Calling SetFrameBlendMethod on frame that doesn't exist!");
30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
30479: 
30479:   frame->SetBlendMethod(aBlendMethod);
30479: 
30479:   return NS_OK;
30479: }
30479: 
30479: 
30479: //******************************************************************************
30479: /* void setFrameHasNoAlpha (in unsigned long framenumber); */
30479: NS_IMETHODIMP imgContainer::SetFrameHasNoAlpha(PRUint32 aFrameNum)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
32424:   if (aFrameNum >= mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
32424:   NS_ABORT_IF_FALSE(frame, "Calling SetFrameHasNoAlpha on frame that doesn't exist!");
30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
30479: 
30479:   frame->SetHasNoAlpha();
30479: 
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
26936: /* void endFrameDecode (in unsigned long framenumber); */
26936: NS_IMETHODIMP imgContainer::EndFrameDecode(PRUint32 aFrameNum)
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
    1:   // Assume there's another frame.
    1:   // currentDecodingFrameIndex is 0 based, aFrameNum is 1 based
    1:   if (mAnim)
    1:     mAnim->currentDecodingFrameIndex = aFrameNum;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* void decodingComplete (); */
    1: NS_IMETHODIMP imgContainer::DecodingComplete(void)
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // Flag that we're done decoding.
32424:   // XXX - these should probably be combined when we fix animated image
32424:   // discarding with bug 500402.
32424:   mDecoded = PR_TRUE;
33531:   mHasBeenDecoded = PR_TRUE;
    1:   if (mAnim)
    1:     mAnim->doneDecoding = PR_TRUE;
30479: 
32424:   nsresult rv;
32424: 
32424:   // We now have one of the qualifications for discarding. Re-evaluate.
32424:   if (CanDiscard()) {
32424:     NS_ABORT_IF_FALSE(!mDiscardTimer,
32424:                       "We shouldn't have been discardable before this");
32424:     rv = ResetDiscardTimer();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // If there's only 1 frame, optimize it. Optimizing animated images
32424:   // is not supported.
32424:   //
32424:   // We don't optimize the frame for multipart images because we reuse
32424:   // the frame.
32424:   if ((mFrames.Length() == 1) && !mMultipart) {
32424:     rv = mFrames[0]->Optimize();
32424:     NS_ENSURE_SUCCESS(rv, rv);
32424:   }
30479: 
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* attribute unsigned short animationMode; */
    1: NS_IMETHODIMP imgContainer::GetAnimationMode(PRUint16 *aAnimationMode)
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
13362:   NS_ENSURE_ARG_POINTER(aAnimationMode);
    1:   
    1:   *aAnimationMode = mAnimationMode;
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* attribute unsigned short animationMode; */
    1: NS_IMETHODIMP imgContainer::SetAnimationMode(PRUint16 aAnimationMode)
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
    1:   NS_ASSERTION(aAnimationMode == imgIContainer::kNormalAnimMode ||
    1:                aAnimationMode == imgIContainer::kDontAnimMode ||
    1:                aAnimationMode == imgIContainer::kLoopOnceAnimMode,
    1:                "Wrong Animation Mode is being set!");
    1:   
    1:   switch (mAnimationMode = aAnimationMode) {
    1:     case kDontAnimMode:
    1:       StopAnimation();
    1:       break;
    1:     case kNormalAnimMode:
    1:       if (mLoopCount != 0 || 
32424:           (mAnim && (mAnim->currentAnimationFrameIndex + 1 < mFrames.Length())))
    1:         StartAnimation();
    1:       break;
    1:     case kLoopOnceAnimMode:
32424:       if (mAnim && (mAnim->currentAnimationFrameIndex + 1 < mFrames.Length()))
    1:         StartAnimation();
    1:       break;
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* void startAnimation () */
    1: NS_IMETHODIMP imgContainer::StartAnimation()
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
    1:   if (mAnimationMode == kDontAnimMode || 
    1:       (mAnim && (mAnim->timer || mAnim->animating)))
    1:     return NS_OK;
    1:   
32424:   if (mFrames.Length() > 1) {
    1:     if (!ensureAnimExists())
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     
13362:     // Default timeout to 100: the timer notify code will do the right
13362:     // thing, so just get that started.
13362:     PRInt32 timeout = 100;
30479:     imgFrame *currentFrame = GetCurrentImgFrame();
    1:     if (currentFrame) {
30479:       timeout = currentFrame->GetTimeout();
    1:       if (timeout <= 0) // -1 means display this frame forever
    1:         return NS_OK;
13362:     }
    1:     
    1:     mAnim->timer = do_CreateInstance("@mozilla.org/timer;1");
13362:     NS_ENSURE_TRUE(mAnim->timer, NS_ERROR_OUT_OF_MEMORY);
    1:     
    1:     // The only way animating becomes true is if the timer is created
    1:     mAnim->animating = PR_TRUE;
 3233:     mAnim->timer->InitWithCallback(static_cast<nsITimerCallback*>(this),
    1:                                    timeout, nsITimer::TYPE_REPEATING_SLACK);
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* void stopAnimation (); */
    1: NS_IMETHODIMP imgContainer::StopAnimation()
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
    1:   if (mAnim) {
    1:     mAnim->animating = PR_FALSE;
    1: 
    1:     if (!mAnim->timer)
    1:       return NS_OK;
    1: 
    1:     mAnim->timer->Cancel();
    1:     mAnim->timer = nsnull;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* void resetAnimation (); */
    1: NS_IMETHODIMP imgContainer::ResetAnimation()
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
    1:   if (mAnimationMode == kDontAnimMode || 
 6617:       !mAnim || mAnim->currentAnimationFrameIndex == 0)
    1:     return NS_OK;
    1: 
    1:   PRBool oldAnimating = mAnim->animating;
    1: 
    1:   if (mAnim->animating) {
    1:     nsresult rv = StopAnimation();
13362:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   mAnim->lastCompositedFrameIndex = -1;
    1:   mAnim->currentAnimationFrameIndex = 0;
32424: 
32424:   // Note - We probably want to kick off a redecode somewhere around here when
32424:   // we fix bug 500402.
32424: 
32424:   // Update display if we were animating before
    1:   nsCOMPtr<imgIContainerObserver> observer(do_QueryReferent(mObserver));
32424:   if (oldAnimating && observer)
30479:     observer->FrameChanged(this, &(mAnim->firstFrameRefreshArea));
    1: 
    1:   if (oldAnimating)
    1:     return StartAnimation();
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* attribute long loopCount; */
    1: NS_IMETHODIMP imgContainer::GetLoopCount(PRInt32 *aLoopCount)
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
13362:   NS_ENSURE_ARG_POINTER(aLoopCount);
    1:   
    1:   *aLoopCount = mLoopCount;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* attribute long loopCount; */
    1: NS_IMETHODIMP imgContainer::SetLoopCount(PRInt32 aLoopCount)
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
    1:   // -1  infinite
    1:   //  0  no looping, one iteration
    1:   //  1  one loop, two iterations
    1:   //  ...
    1:   mLoopCount = aLoopCount;
    1: 
    1:   return NS_OK;
    1: }
    1: 
32424: //******************************************************************************
32424: /* void addSourceData(in nsIInputStream aInputStream, in unsigned long aCount); */
32424: NS_IMETHODIMP imgContainer::AddSourceData(const char *aBuffer, PRUint32 aCount)
 7009: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ENSURE_ARG_POINTER(aBuffer);
32424:   nsresult rv = NS_OK;
32424: 
32424:   // We should not call this if we're not initialized
32424:   NS_ABORT_IF_FALSE(mInitialized, "Calling AddSourceData() on uninitialized "
32424:                                   "imgContainer!");
32424: 
32424:   // We should not call this if we're already finished adding source data
32424:   NS_ABORT_IF_FALSE(!mHasSourceData, "Calling AddSourceData() after calling "
32424:                                      "sourceDataComplete()!");
32424: 
32424:   // This call should come straight from necko - no reentrancy allowed
32424:   NS_ABORT_IF_FALSE(!mInDecoder, "Re-entrant call to AddSourceData!");
32424: 
32424:   // If we're not storing source data, write it directly to the decoder
32424:   if (!StoringSourceData()) {
32424:     rv = WriteToDecoder(aBuffer, aCount);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
 7009:   }
 7009: 
32424:   // Otherwise, we're storing data in the source buffer
32424:   else {
32424: 
32424:     // Store the data
32424:     char *newElem = mSourceData.AppendElements(aBuffer, aCount);
32424:     if (!newElem)
32424:       return NS_ERROR_OUT_OF_MEMORY;
32424: 
32424:     // If there's a decoder open, that means we want to do more decoding.
32424:     // Wake up the worker if it's not up already
32424:     if (mDecoder && !mWorkerPending) {
32424:       NS_ABORT_IF_FALSE(mWorker, "We should have a worker here!");
32424:       rv = mWorker->Run();
32424:       CONTAINER_ENSURE_SUCCESS(rv);
 7009:     }
 7009:   }
 7009: 
32424:   // Statistics
32424:   total_source_bytes += aCount;
32424:   if (mDiscardable)
32424:     discardable_source_bytes += aCount;
 7009:   PR_LOG (gCompressedImageAccountingLog, PR_LOG_DEBUG,
 7009:           ("CompressedImageAccounting: Added compressed data to imgContainer %p (%s). "
32424:            "Total Containers: %d, Discardable containers: %d, "
32424:            "Total source bytes: %lld, Source bytes for discardable containers %lld",
 7009:            this,
32424:            mSourceDataMimeType.get(),
32424:            num_containers,
32424:            num_discardable_containers,
32424:            total_source_bytes,
32424:            discardable_source_bytes));
 7009: 
 7009:   return NS_OK;
 7009: }
 7009: 
 7009: /* Note!  buf must be declared as char buf[9]; */
 7009: // just used for logging and hashing the header
 7009: static void
 7009: get_header_str (char *buf, char *data, PRSize data_len)
 7009: {
 7009:   int i;
 7009:   int n;
 7009:   static char hex[] = "0123456789abcdef";
 7009: 
 7009:   n = data_len < 4 ? data_len : 4;
 7009: 
 7009:   for (i = 0; i < n; i++) {
 7009:     buf[i * 2]     = hex[(data[i] >> 4) & 0x0f];
 7009:     buf[i * 2 + 1] = hex[data[i] & 0x0f];
 7009:   }
 7009: 
 7009:   buf[i * 2] = 0;
 7009: }
 7009: 
 7009: //******************************************************************************
32424: /* void sourceDataComplete(); */
32424: NS_IMETHODIMP imgContainer::SourceDataComplete()
 7009: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // If we've been called before, ignore. Otherwise, flag that we have everything
32424:   if (mHasSourceData)
 7009:     return NS_OK;
32424:   mHasSourceData = PR_TRUE;
32424: 
32424:   // This call should come straight from necko - no reentrancy allowed
32424:   NS_ABORT_IF_FALSE(!mInDecoder, "Re-entrant call to AddSourceData!");
32424: 
32424:   // If we're not storing any source data, then all the data was written
32424:   // directly to the decoder in the AddSourceData() calls. This means we're
32424:   // done, so we can shut down the decoder.
32424:   if (!StoringSourceData()) {
32424:     nsresult rv = ShutdownDecoder(eShutdownIntent_Done);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // If there's a decoder open, we need to wake up the worker if it's not
32424:   // already. This is so the worker can account for the fact that the source
32424:   // data is complete. For some decoders, DecodingComplete() is only called
32424:   // when the decoder is Close()-ed, and thus the SourceDataComplete() call
32424:   // is the only way we can transition to a 'decoded' state. Furthermore,
32424:   // it's always possible for any image type to have the data stream stop
32424:   // abruptly at any point, in which case we need to trigger an error.
32424:   if (mDecoder && !mWorkerPending) {
32424:     NS_ABORT_IF_FALSE(mWorker, "We should have a worker here!");
32424:     nsresult rv = mWorker->Run();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // Free up any extra space in the backing buffer
32424:   mSourceData.Compact();
32424: 
32424:   // Log header information
 7009:   if (PR_LOG_TEST(gCompressedImageAccountingLog, PR_LOG_DEBUG)) {
 7009:     char buf[9];
32424:     get_header_str(buf, mSourceData.Elements(), mSourceData.Length());
 7009:     PR_LOG (gCompressedImageAccountingLog, PR_LOG_DEBUG,
32424:             ("CompressedImageAccounting: imgContainer::SourceDataComplete() - data "
32424:              "is done for container %p (%s) - header %p is 0x%s (length %d)",
 7009:              this,
32424:              mSourceDataMimeType.get(),
32424:              mSourceData.Elements(),
 7009:              buf,
32424:              mSourceData.Length()));
 7009:   }
 7009: 
32424:   // We now have one of the qualifications for discarding. Re-evaluate.
32424:   if (CanDiscard()) {
32424:     nsresult rv = ResetDiscardTimer();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424:   return NS_OK;
32424: }
32424: 
32424: //******************************************************************************
32424: /* void newSourceData(); */
32424: NS_IMETHODIMP imgContainer::NewSourceData()
32424: {
32424:   nsresult rv;
32424: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // The source data should be complete before calling this
32424:   NS_ABORT_IF_FALSE(mHasSourceData,
32424:                     "Calling NewSourceData before SourceDataComplete!");
32424:   if (!mHasSourceData)
32424:     return NS_ERROR_ILLEGAL_VALUE;
32424: 
32424:   // Only supported for multipart channels. It wouldn't be too hard to change this,
32424:   // but it would involve making sure that things worked for decode-on-draw and
32424:   // discarding. Presently there's no need for this, so we don't.
32424:   NS_ABORT_IF_FALSE(mMultipart, "NewSourceData not supported for multipart");
32424:   if (!mMultipart)
32424:     return NS_ERROR_ILLEGAL_VALUE;
32424: 
32424:   // We're multipart, so we shouldn't be storing source data
32424:   NS_ABORT_IF_FALSE(!StoringSourceData(),
32424:                     "Shouldn't be storing source data for multipart");
32424: 
32424:   // We're not storing the source data and we got SourceDataComplete. We should
32424:   // have shut down the previous decoder
32424:   NS_ABORT_IF_FALSE(!mDecoder, "Shouldn't have a decoder in NewSourceData");
32424: 
32424:   // The decoder was shut down and we didn't flag an error, so we should be decoded
32424:   NS_ABORT_IF_FALSE(mDecoded, "Should be decoded in NewSourceData");
32424: 
32424:   // Reset some flags
32424:   mDecoded = PR_FALSE;
32424:   mHasSourceData = PR_FALSE;
32424: 
32424:   // We're decode-on-load here. Open up a new decoder just like what happens when
32424:   // we call Init() for decode-on-load images.
32424:   rv = InitDecoder(imgIDecoder::DECODER_FLAG_NONE);
32424:   CONTAINER_ENSURE_SUCCESS(rv);
32424: 
32424:   return NS_OK;
 7009: }
 7009: 
    1: //******************************************************************************
    1: /* void notify(in nsITimer timer); */
    1: NS_IMETHODIMP imgContainer::Notify(nsITimer *timer)
    1: {
    1:   // This should never happen since the timer is only set up in StartAnimation()
    1:   // after mAnim is checked to exist.
10438:   NS_ENSURE_TRUE(mAnim, NS_ERROR_UNEXPECTED);
    1:   NS_ASSERTION(mAnim->timer == timer,
    1:                "imgContainer::Notify() called with incorrect timer");
    1: 
12826:   if (!mAnim->animating || !mAnim->timer)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<imgIContainerObserver> observer(do_QueryReferent(mObserver));
    1:   if (!observer) {
    1:     // the imgRequest that owns us is dead, we should die now too.
    1:     StopAnimation();
    1:     return NS_OK;
    1:   }
    1: 
32424:   if (mFrames.Length() == 0)
    1:     return NS_OK;
    1:   
30479:   imgFrame *nextFrame = nsnull;
    1:   PRInt32 previousFrameIndex = mAnim->currentAnimationFrameIndex;
32424:   PRUint32 nextFrameIndex = mAnim->currentAnimationFrameIndex + 1;
    1:   PRInt32 timeout = 0;
    1: 
    1:   // If we're done decoding the next frame, go ahead and display it now and
    1:   // reinit the timer with the next frame's delay time.
    1:   // currentDecodingFrameIndex is not set until the second frame has
    1:   // finished decoding (see EndFrameDecode)
    1:   if (mAnim->doneDecoding || 
 1988:       (nextFrameIndex < mAnim->currentDecodingFrameIndex)) {
32424:     if (mFrames.Length() == nextFrameIndex) {
    1:       // End of Animation
    1: 
    1:       // If animation mode is "loop once", it's time to stop animating
    1:       if (mAnimationMode == kLoopOnceAnimMode || mLoopCount == 0) {
    1:         StopAnimation();
    1:         return NS_OK;
    1:       } else {
    1:         // We may have used compositingFrame to build a frame, and then copied
    1:         // it back into mFrames[..].  If so, delete composite to save memory
    1:         if (mAnim->compositingFrame && mAnim->lastCompositedFrameIndex == -1)
    1:           mAnim->compositingFrame = nsnull;
    1:       }
    1: 
    1:       nextFrameIndex = 0;
    1:       if (mLoopCount > 0)
    1:         mLoopCount--;
    1:     }
    1: 
    1:     if (!(nextFrame = mFrames[nextFrameIndex])) {
    1:       // something wrong with the next frame, skip it
    1:       mAnim->currentAnimationFrameIndex = nextFrameIndex;
    1:       mAnim->timer->SetDelay(100);
    1:       return NS_OK;
    1:     }
30479:     timeout = nextFrame->GetTimeout();
    1: 
 1988:   } else if (nextFrameIndex == mAnim->currentDecodingFrameIndex) {
    1:     // Uh oh, the frame we want to show is currently being decoded (partial)
    1:     // Wait a bit and try again
    1:     mAnim->timer->SetDelay(100);
    1:     return NS_OK;
    1:   } else { //  (nextFrameIndex > currentDecodingFrameIndex)
    1:     // We shouldn't get here. However, if we are requesting a frame
    1:     // that hasn't been decoded yet, go back to the last frame decoded
    1:     NS_WARNING("imgContainer::Notify()  Frame is passed decoded frame");
    1:     nextFrameIndex = mAnim->currentDecodingFrameIndex;
    1:     if (!(nextFrame = mFrames[nextFrameIndex])) {
    1:       // something wrong with the next frame, skip it
    1:       mAnim->currentAnimationFrameIndex = nextFrameIndex;
    1:       mAnim->timer->SetDelay(100);
    1:       return NS_OK;
    1:     }
30479:     timeout = nextFrame->GetTimeout();
    1:   }
    1: 
    1:   if (timeout > 0)
    1:     mAnim->timer->SetDelay(timeout);
    1:   else
    1:     StopAnimation();
    1: 
    1:   nsIntRect dirtyRect;
30479:   imgFrame *frameToUse = nsnull;
    1: 
    1:   if (nextFrameIndex == 0) {
    1:     frameToUse = nextFrame;
    1:     dirtyRect = mAnim->firstFrameRefreshArea;
    1:   } else {
30479:     imgFrame *prevFrame = mFrames[previousFrameIndex];
    1:     if (!prevFrame)
    1:       return NS_OK;
    1: 
    1:     // Change frame and announce it
    1:     if (NS_FAILED(DoComposite(&frameToUse, &dirtyRect, prevFrame,
    1:                               nextFrame, nextFrameIndex))) {
    1:       // something went wrong, move on to next
    1:       NS_WARNING("imgContainer::Notify(): Composing Frame Failed\n");
34809:       nextFrame->SetCompositingFailed(PR_TRUE);
    1:       mAnim->currentAnimationFrameIndex = nextFrameIndex;
    1:       return NS_OK;
34809:     } else {
34809:       nextFrame->SetCompositingFailed(PR_FALSE);
    1:     }
    1:   }
    1:   // Set currentAnimationFrameIndex at the last possible moment
    1:   mAnim->currentAnimationFrameIndex = nextFrameIndex;
    1:   // Refreshes the screen
30479:   observer->FrameChanged(this, &dirtyRect);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: // DoComposite gets called when the timer for animation get fired and we have to
    1: // update the composited frame of the animation.
30479: nsresult imgContainer::DoComposite(imgFrame** aFrameToUse,
    1:                                    nsIntRect* aDirtyRect,
30479:                                    imgFrame* aPrevFrame,
30479:                                    imgFrame* aNextFrame,
    1:                                    PRInt32 aNextFrameIndex)
    1: {
13362:   NS_ENSURE_ARG_POINTER(aDirtyRect);
13362:   NS_ENSURE_ARG_POINTER(aPrevFrame);
13362:   NS_ENSURE_ARG_POINTER(aNextFrame);
13362:   NS_ENSURE_ARG_POINTER(aFrameToUse);
    1: 
30479:   PRInt32 prevFrameDisposalMethod = aPrevFrame->GetFrameDisposalMethod();
    1:   if (prevFrameDisposalMethod == imgIContainer::kDisposeRestorePrevious &&
    1:       !mAnim->compositingPrevFrame)
    1:     prevFrameDisposalMethod = imgIContainer::kDisposeClear;
30479: 
30479:   nsIntRect prevFrameRect = aPrevFrame->GetRect();
    1:   PRBool isFullPrevFrame = (prevFrameRect.x == 0 && prevFrameRect.y == 0 &&
    1:                             prevFrameRect.width == mSize.width &&
    1:                             prevFrameRect.height == mSize.height);
    1: 
 7671:   // Optimization: DisposeClearAll if the previous frame is the same size as
    1:   //               container and it's clearing itself
 7671:   if (isFullPrevFrame && 
 7671:       (prevFrameDisposalMethod == imgIContainer::kDisposeClear))
 7671:     prevFrameDisposalMethod = imgIContainer::kDisposeClearAll;
    1: 
30479:   PRInt32 nextFrameDisposalMethod = aNextFrame->GetFrameDisposalMethod();
30479:   nsIntRect nextFrameRect = aNextFrame->GetRect();
    1:   PRBool isFullNextFrame = (nextFrameRect.x == 0 && nextFrameRect.y == 0 &&
    1:                             nextFrameRect.width == mSize.width &&
    1:                             nextFrameRect.height == mSize.height);
    1: 
30479:   if (!aNextFrame->GetIsPaletted()) {
 7671:     // Optimization: Skip compositing if the previous frame wants to clear the
 7671:     //               whole image
 7671:     if (prevFrameDisposalMethod == imgIContainer::kDisposeClearAll) {
 7671:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
 7671:       *aFrameToUse = aNextFrame;
 7671:       return NS_OK;
 7671:     }
    1:   
    1:     // Optimization: Skip compositing if this frame is the same size as the
    1:     //               container and it's fully drawing over prev frame (no alpha)
    1:     if (isFullNextFrame &&
    1:         (nextFrameDisposalMethod != imgIContainer::kDisposeRestorePrevious) &&
30479:         !aNextFrame->GetHasAlpha()) {
    1:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
    1:       *aFrameToUse = aNextFrame;
    1:       return NS_OK;
    1:     }
 7671:   }
    1: 
    1:   // Calculate area that needs updating
    1:   switch (prevFrameDisposalMethod) {
    1:     default:
    1:     case imgIContainer::kDisposeNotSpecified:
    1:     case imgIContainer::kDisposeKeep:
    1:       *aDirtyRect = nextFrameRect;
    1:       break;
    1: 
 7671:     case imgIContainer::kDisposeClearAll:
 7671:       // Whole image container is cleared
 7671:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
 7671:       break;
 7671: 
    1:     case imgIContainer::kDisposeClear:
    1:       // Calc area that needs to be redrawn (the combination of previous and
    1:       // this frame)
    1:       // XXX - This could be done with multiple framechanged calls
    1:       //       Having prevFrame way at the top of the image, and nextFrame
    1:       //       way at the bottom, and both frames being small, we'd be
    1:       //       telling framechanged to refresh the whole image when only two
    1:       //       small areas are needed.
    1:       aDirtyRect->UnionRect(nextFrameRect, prevFrameRect);
    1:       break;
    1: 
    1:     case imgIContainer::kDisposeRestorePrevious:
    1:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
    1:       break;
    1:   }
    1: 
    1:   // Optimization:
    1:   //   Skip compositing if the last composited frame is this frame
    1:   //   (Only one composited frame was made for this animation.  Example:
    1:   //    Only Frame 3 of a 10 frame image required us to build a composite frame
    1:   //    On the second loop, we do not need to rebuild the frame
    1:   //    since it's still sitting in compositingFrame)
    1:   if (mAnim->lastCompositedFrameIndex == aNextFrameIndex) {
    1:     *aFrameToUse = mAnim->compositingFrame;
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRBool needToBlankComposite = PR_FALSE;
    1: 
    1:   // Create the Compositing Frame
    1:   if (!mAnim->compositingFrame) {
30479:     mAnim->compositingFrame = new imgFrame();
30479:     if (!mAnim->compositingFrame) {
    1:       NS_WARNING("Failed to init compositingFrame!\n");
30479:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
30479:     nsresult rv = mAnim->compositingFrame->Init(0, 0, mSize.width, mSize.height,
30479:                                                 gfxASurface::ImageFormatARGB32);
35021:     if (NS_FAILED(rv)) {
35021:       mAnim->compositingFrame = nsnull;
35021:       return rv;
35021:     }
    1:     needToBlankComposite = PR_TRUE;
 9540:   } else if (aNextFrameIndex == 1) {
 9540:     // When we are looping the compositing frame needs to be cleared.
 9540:     needToBlankComposite = PR_TRUE;
    1:   }
    1: 
 7671:   // More optimizations possible when next frame is not transparent
 7671:   PRBool doDisposal = PR_TRUE;
30479:   if (!aNextFrame->GetHasAlpha()) {
 7671:     if (isFullNextFrame) {
 7671:       // Optimization: No need to dispose prev.frame when 
 7671:       // next frame is full frame and not transparent.
 7671:       doDisposal = PR_FALSE;
 7671:       // No need to blank the composite frame
 7671:       needToBlankComposite = PR_FALSE;
    1:     } else {
 7671:       if ((prevFrameRect.x >= nextFrameRect.x) &&
 7671:           (prevFrameRect.y >= nextFrameRect.y) &&
 7671:           (prevFrameRect.x + prevFrameRect.width <= nextFrameRect.x + nextFrameRect.width) &&
 7671:           (prevFrameRect.y + prevFrameRect.height <= nextFrameRect.y + nextFrameRect.height)) {
 7671:         // Optimization: No need to dispose prev.frame when 
 7671:         // next frame fully overlaps previous frame.
 7671:         doDisposal = PR_FALSE;  
 7671:       }
    1:     }      
    1:   }
    1: 
 7671:   if (doDisposal) {
 7671:     // Dispose of previous: clear, restore, or keep (copy)
    1:     switch (prevFrameDisposalMethod) {
    1:       case imgIContainer::kDisposeClear:
    1:         if (needToBlankComposite) {
    1:           // If we just created the composite, it could have anything in it's
 7671:           // buffer. Clear whole frame
 2200:           ClearFrame(mAnim->compositingFrame);
    1:         } else {
 7671:           // Only blank out previous frame area (both color & Mask/Alpha)
 2200:           ClearFrame(mAnim->compositingFrame, prevFrameRect);
    1:         }
    1:         break;
    1:   
 7671:       case imgIContainer::kDisposeClearAll:
 7671:         ClearFrame(mAnim->compositingFrame);
 7671:         break;
 7671:   
    1:       case imgIContainer::kDisposeRestorePrevious:
    1:         // It would be better to copy only the area changed back to
    1:         // compositingFrame.
    1:         if (mAnim->compositingPrevFrame) {
    1:           CopyFrameImage(mAnim->compositingPrevFrame, mAnim->compositingFrame);
    1:   
    1:           // destroy only if we don't need it for this frame's disposal
    1:           if (nextFrameDisposalMethod != imgIContainer::kDisposeRestorePrevious)
    1:             mAnim->compositingPrevFrame = nsnull;
    1:         } else {
 2200:           ClearFrame(mAnim->compositingFrame);
    1:         }
    1:         break;
 7671:       
 7671:       default:
 7671:         // Copy previous frame into compositingFrame before we put the new frame on top
 7671:         // Assumes that the previous frame represents a full frame (it could be
 7671:         // smaller in size than the container, as long as the frame before it erased
 7671:         // itself)
 7671:         // Note: Frame 1 never gets into DoComposite(), so (aNextFrameIndex - 1) will
 7671:         // always be a valid frame number.
 7671:         if (mAnim->lastCompositedFrameIndex != aNextFrameIndex - 1) {
32163:           if (isFullPrevFrame && !aPrevFrame->GetIsPaletted()) {
 7671:             // Just copy the bits
 7671:             CopyFrameImage(aPrevFrame, mAnim->compositingFrame);
 7671:           } else {
 7671:             if (needToBlankComposite) {
 7671:               // Only blank composite when prev is transparent or not full.
30479:               if (aPrevFrame->GetHasAlpha() || !isFullPrevFrame) {
 7671:                 ClearFrame(mAnim->compositingFrame);
 7671:               }
 7671:             }
 7671:             DrawFrameTo(aPrevFrame, mAnim->compositingFrame, prevFrameRect);
 7671:           }
 7671:         }
32163:     }
 7671:   } else if (needToBlankComposite) {
 7671:     // If we just created the composite, it could have anything in it's
 7671:     // buffers. Clear them
 7671:     ClearFrame(mAnim->compositingFrame);
    1:   }
    1: 
    1:   // Check if the frame we are composing wants the previous image restored afer
 7108:   // it is done. Don't store it (again) if last frame wanted its image restored
    1:   // too
    1:   if ((nextFrameDisposalMethod == imgIContainer::kDisposeRestorePrevious) &&
    1:       (prevFrameDisposalMethod != imgIContainer::kDisposeRestorePrevious)) {
    1:     // We are storing the whole image.
    1:     // It would be better if we just stored the area that nextFrame is going to
    1:     // overwrite.
    1:     if (!mAnim->compositingPrevFrame) {
30479:       mAnim->compositingPrevFrame = new imgFrame();
30479:       if (!mAnim->compositingPrevFrame) {
30479:         NS_WARNING("Failed to init compositingFrame!\n");
30479:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
30479:       nsresult rv = mAnim->compositingPrevFrame->Init(0, 0, mSize.width, mSize.height,
30479:                                                       gfxASurface::ImageFormatARGB32);
35021:       if (NS_FAILED(rv)) {
35021:         mAnim->compositingPrevFrame = nsnull;
35021:         return rv;
35021:       }
30479:     }
30479: 
    1:     CopyFrameImage(mAnim->compositingFrame, mAnim->compositingPrevFrame);
    1:   }
    1: 
    1:   // blit next frame into it's correct spot
 5275:   DrawFrameTo(aNextFrame, mAnim->compositingFrame, nextFrameRect);
30479: 
    1:   // Set timeout of CompositeFrame to timeout of frame we just composed
    1:   // Bug 177948
30479:   PRInt32 timeout = aNextFrame->GetTimeout();
    1:   mAnim->compositingFrame->SetTimeout(timeout);
    1: 
 7671:   // Tell the image that it is fully 'downloaded'.
30479:   nsresult rv = mAnim->compositingFrame->ImageUpdated(mAnim->compositingFrame->GetRect());
19117:   if (NS_FAILED(rv)) {
19117:     return rv;
19117:   }
 7671: 
 7671:   // We don't want to keep composite images for 8bit frames...
 7671:   if (isFullNextFrame && mAnimationMode == kNormalAnimMode && mLoopCount != 0 &&
30479:       !aNextFrame->GetIsPaletted()) {
    1:     // We have a composited full frame
    1:     // Store the composited frame into the mFrames[..] so we don't have to
    1:     // continuously re-build it
    1:     // Then set the previous frame's disposal to CLEAR_ALL so we just draw the
    1:     // frame next time around
    1:     if (CopyFrameImage(mAnim->compositingFrame, aNextFrame)) {
    1:       aPrevFrame->SetFrameDisposalMethod(imgIContainer::kDisposeClearAll);
    1:       mAnim->lastCompositedFrameIndex = -1;
    1:       *aFrameToUse = aNextFrame;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   mAnim->lastCompositedFrameIndex = aNextFrameIndex;
    1:   *aFrameToUse = mAnim->compositingFrame;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
 2200: // Fill aFrame with black. Does also clears the mask.
30479: void imgContainer::ClearFrame(imgFrame *aFrame)
    1: {
    1:   if (!aFrame)
    1:     return;
    1: 
35020:   nsresult rv = aFrame->LockImageData();
35020:   if (NS_FAILED(rv))
35020:     return;
30479: 
    1:   nsRefPtr<gfxASurface> surf;
30479:   aFrame->GetSurface(getter_AddRefs(surf));
    1: 
 2200:   // Erase the surface to transparent
 2200:   gfxContext ctx(surf);
 2200:   ctx.SetOperator(gfxContext::OPERATOR_CLEAR);
 2200:   ctx.Paint();
30479: 
30479:   aFrame->UnlockImageData();
    1: }
    1: 
 2200: //******************************************************************************
30479: void imgContainer::ClearFrame(imgFrame *aFrame, nsIntRect &aRect)
 2200: {
30479:   if (!aFrame || aRect.width <= 0 || aRect.height <= 0)
 2200:     return;
 2200: 
35020:   nsresult rv = aFrame->LockImageData();
35020:   if (NS_FAILED(rv))
35020:     return;
30479: 
 2200:   nsRefPtr<gfxASurface> surf;
30479:   aFrame->GetSurface(getter_AddRefs(surf));
 2200: 
 2200:   // Erase the destination rectangle to transparent
 2200:   gfxContext ctx(surf);
 2200:   ctx.SetOperator(gfxContext::OPERATOR_CLEAR);
 2200:   ctx.Rectangle(gfxRect(aRect.x, aRect.y, aRect.width, aRect.height));
 2200:   ctx.Fill();
30479: 
30479:   aFrame->UnlockImageData();
 2200: }
 2200: 
    1: 
    1: //******************************************************************************
    1: // Whether we succeed or fail will not cause a crash, and there's not much
    1: // we can do about a failure, so there we don't return a nsresult
30479: PRBool imgContainer::CopyFrameImage(imgFrame *aSrcFrame,
30479:                                     imgFrame *aDstFrame)
    1: {
    1:   PRUint8* aDataSrc;
    1:   PRUint8* aDataDest;
    1:   PRUint32 aDataLengthSrc;
    1:   PRUint32 aDataLengthDest;
    1: 
    1:   if (!aSrcFrame || !aDstFrame)
    1:     return PR_FALSE;
    1: 
    1:   if (NS_FAILED(aDstFrame->LockImageData()))
    1:     return PR_FALSE;
    1: 
    1:   // Copy Image Over
    1:   aSrcFrame->GetImageData(&aDataSrc, &aDataLengthSrc);
    1:   aDstFrame->GetImageData(&aDataDest, &aDataLengthDest);
    1:   if (!aDataDest || !aDataSrc || aDataLengthDest != aDataLengthSrc) {
    1:     aDstFrame->UnlockImageData();
    1:     return PR_FALSE;
    1:   }
    1:   memcpy(aDataDest, aDataSrc, aDataLengthSrc);
    1:   aDstFrame->UnlockImageData();
    1: 
    1:   return PR_TRUE;
    1: }
 2663: 
 5275: //******************************************************************************
10521: /* 
10521:  * aSrc is the current frame being drawn,
10521:  * aDst is the composition frame where the current frame is drawn into.
10521:  * aSrcRect is the size of the current frame, and the position of that frame
10521:  *          in the composition frame.
10521:  */
30479: nsresult imgContainer::DrawFrameTo(imgFrame *aSrc,
30479:                                    imgFrame *aDst, 
10521:                                    nsIntRect& aSrcRect)
 5275: {
10521:   NS_ENSURE_ARG_POINTER(aSrc);
10521:   NS_ENSURE_ARG_POINTER(aDst);
 5275: 
30479:   nsIntRect dstRect = aDst->GetRect();
 7671: 
10521:   // According to both AGIF and APNG specs, offsets are unsigned
10521:   if (aSrcRect.x < 0 || aSrcRect.y < 0) {
10521:     NS_WARNING("imgContainer::DrawFrameTo: negative offsets not allowed");
10521:     return NS_ERROR_FAILURE;
10521:   }
10521:   // Outside the destination frame, skip it
10521:   if ((aSrcRect.x > dstRect.width) || (aSrcRect.y > dstRect.height)) {
10521:     return NS_OK;
10521:   }
30479: 
30479:   if (aSrc->GetIsPaletted()) {
 8118:     // Larger than the destination frame, clip it
10521:     PRInt32 width = PR_MIN(aSrcRect.width, dstRect.width - aSrcRect.x);
10521:     PRInt32 height = PR_MIN(aSrcRect.height, dstRect.height - aSrcRect.y);
 8118: 
10521:     // The clipped image must now fully fit within destination image frame
10521:     NS_ASSERTION((aSrcRect.x >= 0) && (aSrcRect.y >= 0) &&
10521:                  (aSrcRect.x + width <= dstRect.width) &&
10521:                  (aSrcRect.y + height <= dstRect.height),
10521:                 "imgContainer::DrawFrameTo: Invalid aSrcRect");
10521: 
10521:     // clipped image size may be smaller than source, but not larger
10521:     NS_ASSERTION((width <= aSrcRect.width) && (height <= aSrcRect.height),
 8118:                  "imgContainer::DrawFrameTo: source must be smaller than dest");
 7671: 
 7671:     if (NS_FAILED(aDst->LockImageData()))
 7671:       return NS_ERROR_FAILURE;
30479: 
 7671:     // Get pointers to image data
 7671:     PRUint32 size;
 7671:     PRUint8 *srcPixels;
30479:     PRUint32 *colormap;
30479:     PRUint32 *dstPixels;
 7671: 
 7671:     aSrc->GetImageData(&srcPixels, &size);
30479:     aSrc->GetPaletteData(&colormap, &size);
 7671:     aDst->GetImageData((PRUint8 **)&dstPixels, &size);
 7671:     if (!srcPixels || !dstPixels || !colormap) {
 7671:       aDst->UnlockImageData();
 7671:       return NS_ERROR_FAILURE;
 7671:     }
 7671: 
 7671:     // Skip to the right offset
10521:     dstPixels += aSrcRect.x + (aSrcRect.y * dstRect.width);
30479:     if (!aSrc->GetHasAlpha()) {
 9592:       for (PRInt32 r = height; r > 0; --r) {
 9592:         for (PRInt32 c = 0; c < width; c++) {
 9592:           dstPixels[c] = colormap[srcPixels[c]];
 7671:         }
 9592:         // Go to the next row in the source resp. destination image
10521:         srcPixels += aSrcRect.width;
 9592:         dstPixels += dstRect.width;
 7671:       }
 7671:     } else {
 9592:       for (PRInt32 r = height; r > 0; --r) {
 9592:         for (PRInt32 c = 0; c < width; c++) {
 9592:           const PRUint32 color = colormap[srcPixels[c]];
 7671:           if (color)
 9592:             dstPixels[c] = color;
 7671:         }
 9592:         // Go to the next row in the source resp. destination image
10521:         srcPixels += aSrcRect.width;
 9592:         dstPixels += dstRect.width;
 7671:       }
 7671:     }
30479: 
 7671:     aDst->UnlockImageData();
 7671:     return NS_OK;
 7671:   }
 7671: 
12652:   nsRefPtr<gfxPattern> srcPatt;
30479:   aSrc->GetPattern(getter_AddRefs(srcPatt));
 5275: 
30479:   aDst->LockImageData();
 5275:   nsRefPtr<gfxASurface> dstSurf;
30479:   aDst->GetSurface(getter_AddRefs(dstSurf));
 5275: 
 5275:   gfxContext dst(dstSurf);
10521:   dst.Translate(gfxPoint(aSrcRect.x, aSrcRect.y));
10521:   dst.Rectangle(gfxRect(0, 0, aSrcRect.width, aSrcRect.height), PR_TRUE);
 7108:   
 7108:   // first clear the surface if the blend flag says so
30479:   PRInt32 blendMethod = aSrc->GetBlendMethod();
10521:   if (blendMethod == imgIContainer::kBlendSource) {
 7108:     gfxContext::GraphicsOperator defaultOperator = dst.CurrentOperator();
 7108:     dst.SetOperator(gfxContext::OPERATOR_CLEAR);
 7108:     dst.Fill();
10521:     dst.SetOperator(defaultOperator);
 7108:   }
12652:   dst.SetPattern(srcPatt);
 5275:   dst.Paint();
 5275: 
30479:   aDst->UnlockImageData();
30479: 
 5275:   return NS_OK;
 5275: }
 5275: 
 5275: 
 2663: /********* Methods to implement lazy allocation of nsIProperties object *************/
 2663: NS_IMETHODIMP imgContainer::Get(const char *prop, const nsIID & iid, void * *result)
 2663: {
 2663:   if (!mProperties)
 2663:     return NS_ERROR_FAILURE;
 2663:   return mProperties->Get(prop, iid, result);
 2663: }
 2663: 
 2663: NS_IMETHODIMP imgContainer::Set(const char *prop, nsISupports *value)
 2663: {
 2663:   if (!mProperties)
 2663:     mProperties = do_CreateInstance("@mozilla.org/properties;1");
 2663:   if (!mProperties)
 2663:     return NS_ERROR_OUT_OF_MEMORY;
 2663:   return mProperties->Set(prop, value);
 2663: }
 2663: 
 2663: NS_IMETHODIMP imgContainer::Has(const char *prop, PRBool *_retval)
 2663: {
 2663:   NS_ENSURE_ARG_POINTER(_retval);
 2663:   if (!mProperties) {
 2663:     *_retval = PR_FALSE;
 2663:     return NS_OK;
 2663:   }
 2663:   return mProperties->Has(prop, _retval);
 2663: }
 2663: 
 2663: NS_IMETHODIMP imgContainer::Undefine(const char *prop)
 2663: {
 2663:   if (!mProperties)
 2663:     return NS_ERROR_FAILURE;
 2663:   return mProperties->Undefine(prop);
 2663: }
 2663: 
 2663: NS_IMETHODIMP imgContainer::GetKeys(PRUint32 *count, char ***keys)
 2663: {
 2663:   if (!mProperties) {
 2663:     *count = 0;
 2663:     *keys = nsnull;
 2663:     return NS_OK;
 2663:   }
 2663:   return mProperties->GetKeys(count, keys);
 2663: }
 7009: 
 7009: static int
 7009: get_discard_timer_ms (void)
 7009: {
 7009:   /* FIXME: don't hardcode this */
10438:   return 15000; /* 15 seconds */
 7009: }
 7009: 
 7009: void
 7009: imgContainer::sDiscardTimerCallback(nsITimer *aTimer, void *aClosure)
 7009: {
32424:   // Retrieve self pointer and null out the expired timer
 7009:   imgContainer *self = (imgContainer *) aClosure;
32424:   NS_ABORT_IF_FALSE(aTimer == self->mDiscardTimer, 
32424:                     "imgContainer::DiscardTimerCallback() got a callback "
32424:                     "for an unknown timer");
 7009:   self->mDiscardTimer = nsnull;
 7009: 
32424:   // We should be ok for discard
32424:   NS_ABORT_IF_FALSE(self->CanDiscard(), "Hit discard callback but can't discard!");
32424: 
32424:   // We should never discard when we have an active decoder
32424:   NS_ABORT_IF_FALSE(!self->mDecoder, "Discard callback fired with open decoder!");
32424: 
32424:   // As soon as an image becomes animated, it becomes non-discardable and any
32424:   // timers are cancelled.
32424:   NS_ABORT_IF_FALSE(!self->mAnim, "Discard callback fired for animated image!");
32424: 
32424:   // For post-operation logging
30479:   int old_frame_count = self->mFrames.Length();
 7009: 
32424:   // Delete all the decoded frames, then clear the array.
30479:   for (int i = 0; i < old_frame_count; ++i)
30479:     delete self->mFrames[i];
 7009:   self->mFrames.Clear();
 7009: 
32424:   // Flag that we no longer have decoded frames for this image
32424:   self->mDecoded = PR_FALSE;
32424: 
32424:   // Notify that we discarded
32424:   nsCOMPtr<imgIDecoderObserver> observer(do_QueryReferent(self->mObserver));
32424:   if (observer)
32424:     observer->OnDiscard(nsnull);
32424: 
32424:   // Log
 7009:   PR_LOG(gCompressedImageAccountingLog, PR_LOG_DEBUG,
32424:          ("CompressedImageAccounting: discarded uncompressed image "
32424:           "data from imgContainer %p (%s) - %d frames (cached count: %d); "
32424:           "Total Containers: %d, Discardable containers: %d, "
32424:           "Total source bytes: %lld, Source bytes for discardable containers %lld",
 7009:           self,
32424:           self->mSourceDataMimeType.get(),
 7009:           old_frame_count,
32424:           self->mFrames.Length(),
32424:           num_containers,
32424:           num_discardable_containers,
32424:           total_source_bytes,
32424:           discardable_source_bytes));
 7009: }
 7009: 
 7009: nsresult
32424: imgContainer::ResetDiscardTimer()
 7009: {
32424:   // We should not call this function if we can't discard
32424:   NS_ABORT_IF_FALSE(CanDiscard(), "Calling ResetDiscardTimer but can't discard!");
32424: 
32424:   // As soon as an image becomes animated it is set non-discardable
32424:   NS_ABORT_IF_FALSE(!mAnim, "Trying to reset discard timer on animated image!");
32424: 
32424:   // If we have a timer already ticking, cancel it
12826:   if (mDiscardTimer) {
12826:     nsresult rv = mDiscardTimer->Cancel();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
12826:     mDiscardTimer = nsnull;
12826:   }
12826: 
32424:   // Create a new timer
 7009:   mDiscardTimer = do_CreateInstance("@mozilla.org/timer;1");
32424:   CONTAINER_ENSURE_TRUE(mDiscardTimer, NS_ERROR_OUT_OF_MEMORY);
32424: 
32424:   // Activate the timer
 7009:   return mDiscardTimer->InitWithFuncCallback(sDiscardTimerCallback,
 7009:                                              (void *) this,
 7009:                                              get_discard_timer_ms (),
 7009:                                              nsITimer::TYPE_ONE_SHOT);
 7009: }
 7009: 
32424: // Helper method to determine if we can discard an image
32424: PRBool
32424: imgContainer::CanDiscard() {
32424:   return (DiscardingEnabled() && // Globally enabled...
32424:           mDiscardable &&        // ...Enabled at creation time...
32424:           (mLockCount == 0) &&   // ...not temporarily disabled...
32424:           mHasSourceData &&      // ...have the source data...
32424:           mDecoded);             // ...and have something to discard.
32424: }
32424: 
32424: // Helper method to determine if we're storing the source data in a buffer
32424: // or just writing it directly to the decoder
32424: PRBool
32424: imgContainer::StoringSourceData() {
32424:   return (mDecodeOnDraw || mDiscardable);
32424: }
32424: 
32424: 
32424: // Sets up a decoder for this image. It is an error to call this function
32424: // when decoding is already in process (ie - when mDecoder is non-null).
 7009: nsresult
32424: imgContainer::InitDecoder (PRUint32 dFlags)
 7009: {
32424:   // Ensure that the decoder is not already initialized
32424:   NS_ABORT_IF_FALSE(!mDecoder, "Calling InitDecoder() while already decoding!");
32424:   
32424:   // We shouldn't be firing up a decoder if we already have the frames decoded
32424:   NS_ABORT_IF_FALSE(!mDecoded, "Calling InitDecoder() but already decoded!");
32424: 
32424:   // Since we're not decoded, we should not have a discard timer active
32424:   NS_ABORT_IF_FALSE(!mDiscardTimer, "Discard Timer active in InitDecoder()!");
32424: 
32424:   // Find and instantiate the decoder
32424:   nsCAutoString decoderCID(NS_LITERAL_CSTRING("@mozilla.org/image/decoder;3?type=") +
32424:                                               mSourceDataMimeType);
32424:   mDecoder = do_CreateInstance(decoderCID.get());
32424:   CONTAINER_ENSURE_TRUE(mDecoder, NS_IMAGELIB_ERROR_NO_DECODER);
32424: 
32424:   // Store the flags for this decoder
32424:   mDecoderFlags = dFlags;
32424: 
32424:   // Initialize the decoder
32424:   nsCOMPtr<imgIDecoderObserver> observer(do_QueryReferent(mObserver));
32424:   nsresult result = mDecoder->Init(this, observer, dFlags);
32424:   CONTAINER_ENSURE_SUCCESS(result);
32424: 
32424:   // Create a decode worker
32424:   mWorker = new imgDecodeWorker(this);
32424:   CONTAINER_ENSURE_TRUE(mWorker, NS_ERROR_OUT_OF_MEMORY);
 7009: 
 7009:   return NS_OK;
 7009: }
 7009: 
32424: // Flushes, closes, and nulls-out a decoder. Cleans up any related decoding
32424: // state. It is an error to call this function when there is no initialized
32424: // decoder.
32424: // 
32424: // aIntent specifies the intent of the shutdown. If aIntent is
32424: // eShutdownIntent_Done, an error is flagged if we didn't get what we should
32424: // have out of the decode. If aIntent is eShutdownIntent_Interrupted, we don't
32424: // check this. If aIntent is eShutdownIntent_Error, we shut down in error mode.
32424: nsresult
32424: imgContainer::ShutdownDecoder(eShutdownIntent aIntent)
32424: {
32424:   // Ensure that our intent is valid
32424:   NS_ABORT_IF_FALSE((aIntent >= 0) || (aIntent < eShutdownIntent_AllCount),
32424:                     "Invalid shutdown intent");
32424: 
32424:   // Ensure that the decoder is initialized
32424:   NS_ABORT_IF_FALSE(mDecoder, "Calling ShutdownDecoder() with no active decoder!");
32424: 
32424:   nsresult rv;
32424: 
32424:   // If we're "done" _and_ it's a full decode, flush
32424:   if ((aIntent == eShutdownIntent_Done) &&
32424:       !(mDecoderFlags && imgIDecoder::DECODER_FLAG_HEADERONLY)) {
32424:     mInDecoder = PR_TRUE;
32424:     rv = mDecoder->Flush();
32424:     mInDecoder = PR_FALSE;
32424: 
32424:     // The error case here is a bit tricky. We flag an error, which takes us
32424:     // back into this function, and then we return.
32424:     if (NS_FAILED(rv)) {
32424:       DoError();
32424:       return rv;
32424:     }
32424:   }
32424: 
32424:   // Close the decoder with the appropriate flags
32424:   mInDecoder = PR_TRUE;
32424:   PRUint32 closeFlags = (aIntent == eShutdownIntent_Error)
32424:                           ? (PRUint32) imgIDecoder::CLOSE_FLAG_DONTNOTIFY
32424:                           : 0;
32424:   rv = mDecoder->Close(closeFlags);
32424:   mInDecoder = PR_FALSE;
32424: 
32424:   // null out the decoder, _then_ check for errors on the close (otherwise the
32424:   // error routine might re-invoke ShutdownDecoder)
32424:   mDecoder = nsnull;
32424:   if (NS_FAILED(rv)) {
32424:     DoError();
32424:     return rv;
32424:   }
32424: 
32424:   // Kill off the worker
32424:   mWorker = nsnull;
32424: 
32424:   // We just shut down the decoder. If we didn't get what we want, but expected
32424:   // to, flag an error
32424:   PRBool failed = PR_FALSE;
32424:   if ((mDecoderFlags & imgIDecoder::DECODER_FLAG_HEADERONLY) && !mHasSize)
32424:     failed = PR_TRUE;
32424:   if (!(mDecoderFlags & imgIDecoder::DECODER_FLAG_HEADERONLY) && !mDecoded)
32424:     failed = PR_TRUE;
32424:   if ((aIntent == eShutdownIntent_Done) && failed) {
32424:     DoError();
32424:     return NS_ERROR_FAILURE;
32424:   }
32424: 
32424:   // Clear the flags
32424:   mDecoderFlags = imgIDecoder::DECODER_FLAG_NONE;
32424: 
32424:   // Reset number of decoded bytes
32424:   mBytesDecoded = 0;
32424: 
32424:   return NS_OK;
32424: }
32424: 
33898: // Writes the data to the decoder, updating the total number of bytes written.
32424: nsresult
32424: imgContainer::WriteToDecoder(const char *aBuffer, PRUint32 aCount)
32424: {
32424:   // We should have a decoder
32424:   NS_ABORT_IF_FALSE(mDecoder, "Trying to write to null decoder!");
32424: 
32424:   // Write
32424:   mInDecoder = PR_TRUE;
33898:   nsresult rv = mDecoder->Write(aBuffer, aCount);
32424:   mInDecoder = PR_FALSE;
32424:   CONTAINER_ENSURE_SUCCESS(rv);
32424: 
32424:   // Keep track of the total number of bytes written over the lifetime of the
32424:   // decoder
32424:   mBytesDecoded += aCount;
32424: 
32424:   return NS_OK;
32424: }
32424: 
32424: // This function is called in situations where it's clear that we want the
32424: // frames in decoded form (Draw, GetFrame, CopyFrame, ExtractFrame, etc).
32424: // If we're completely decoded, this method resets the discard timer (if
32424: // we're discardable), since wanting the frames now is a good indicator of
32424: // wanting them again soon. If we're not decoded, this method kicks off
32424: // asynchronous decoding to generate the frames.
32424: nsresult
32424: imgContainer::WantDecodedFrames()
32424: {
32424:   nsresult rv;
32424: 
32424:   // If we can discard, we should have a timer already. reset it.
32424:   if (CanDiscard()) {
32424:     NS_ABORT_IF_FALSE(mDiscardTimer, "Decoded and discardable but timer not set!");
32424:     rv = ResetDiscardTimer();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // Request a decode (no-op if we're decoded)
32424:   return RequestDecode();
32424: }
32424: 
30479: //******************************************************************************
32424: /* void requestDecode() */
32424: NS_IMETHODIMP
32424: imgContainer::RequestDecode()
32424: {
32424:   nsresult rv;
32424: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // If we're not storing source data, we have nothing to do
32424:   if (!StoringSourceData())
32424:     return NS_OK;
32424: 
32424:   // If we're fully decoded, we have nothing to do
32424:   if (mDecoded)
32424:     return NS_OK;
32424: 
32884:   // If we've already got a full decoder running, we have nothing to do
32884:   if (mDecoder && !(mDecoderFlags & imgIDecoder::DECODER_FLAG_HEADERONLY))
32884:     return NS_OK;
32884: 
32884:   // If our callstack goes through a header-only decoder, we have a problem.
32884:   // We need to shutdown the header-only decoder and replace it with  a full
32884:   // decoder, but can't do that from within the decoder itself. Thus, we post
32884:   // an asynchronous event to the event loop to do it later. Since
32884:   // RequestDecode() is an asynchronous function this works fine (though it's
32884:   // a little slower).
32424:   if (mInDecoder) {
32424:     nsRefPtr<imgDecodeRequestor> requestor = new imgDecodeRequestor(this);
32424:     if (!requestor)
32424:       return NS_ERROR_OUT_OF_MEMORY;
32424:     return NS_DispatchToCurrentThread(requestor);
32424:   }
32424: 
32424: 
32424:   // If we have a header-only decoder open, interrupt it and shut it down
32424:   if (mDecoder && (mDecoderFlags & imgIDecoder::DECODER_FLAG_HEADERONLY)) {
32424:     rv = ShutdownDecoder(eShutdownIntent_Interrupted);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // If we don't have a decoder, create one 
32424:   if (!mDecoder) {
32424:     NS_ABORT_IF_FALSE(mFrames.IsEmpty(), "Trying to decode to non-empty frame-array");
32424:     rv = InitDecoder(imgIDecoder::DECODER_FLAG_NONE);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // If we already have a pending worker, we're done
32424:   if (mWorkerPending)
32424:     return NS_OK;
32424: 
32424:   // If we've read all the data we have, we're done
32424:   if (mBytesDecoded == mSourceData.Length())
32424:     return NS_OK;
32424: 
32424:   // If we get this far, dispatch the worker. We do this instead of starting
32424:   // any immediate decoding so that actions like tabbing-over to a tab with
32424:   // large undecoded images don't incur an annoying lag.
32424:   return mWorker->Dispatch();
32424: }
32424: 
32424: // Synchronously decodes as much data as possible
32424: nsresult
32424: imgContainer::SyncDecode()
32424: {
32424:   nsresult rv;
32424: 
32424:   // If we're decoded already, no worries
32424:   if (mDecoded)
32424:     return NS_OK;
32424: 
32424:   // If we're not storing source data, there isn't much to do here
32424:   if (!StoringSourceData())
32424:     return NS_OK;
32424: 
32424:   // We really have no good way of forcing a synchronous decode if we're being
32424:   // called in a re-entrant manner (ie, from an event listener fired by a
32424:   // decoder), because the decoding machinery is already tied up. The best we
32424:   // can do is assert that it doesn't happen for debug builds (if it does, we
32424:   // need to rethink the layout code that does it), and fail for release builds.
32424:   NS_ABORT_IF_FALSE(!mInDecoder, "Yikes, forcing sync in reentrant call!");
32424:   if (mInDecoder)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // If we have a header-only decoder open, shut it down
32424:   if (mDecoder && (mDecoderFlags & imgIDecoder::DECODER_FLAG_HEADERONLY)) {
32424:     rv = ShutdownDecoder(eShutdownIntent_Interrupted);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // If we don't have a decoder, create one 
32424:   if (!mDecoder) {
32424:     NS_ABORT_IF_FALSE(mFrames.IsEmpty(), "Trying to decode to non-empty frame-array");
32424:     rv = InitDecoder(imgIDecoder::DECODER_FLAG_NONE);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // Write everything we have
32424:   rv = WriteToDecoder(mSourceData.Elements() + mBytesDecoded,
32424:                       mSourceData.Length() - mBytesDecoded);
32424:   CONTAINER_ENSURE_SUCCESS(rv);
32424: 
32424:   // If we finished the decode, shutdown the decoder
32424:   if (IsDecodeFinished()) {
32424:     rv = ShutdownDecoder(eShutdownIntent_Done);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // All good!
32424:   return NS_OK;
32424: }
32424: 
32424: //******************************************************************************
32424: /* [noscript] void draw(in gfxContext aContext, in gfxGraphicsFilter aFilter,
32424:  * in gfxMatrix aUserSpaceToImageSpace, in gfxRect aFill, in nsIntRect aSubimage,
32424:  * in PRUint32 aFlags); */ 
30479: NS_IMETHODIMP imgContainer::Draw(gfxContext *aContext, gfxPattern::GraphicsFilter aFilter, 
30479:                                  gfxMatrix &aUserSpaceToImageSpace, gfxRect &aFill,
32424:                                  nsIntRect &aSubimage, PRUint32 aFlags)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
30479:   NS_ENSURE_ARG_POINTER(aContext);
30479: 
32424:   // If a synchronous draw is requested, flush anything that might be sitting around
32424:   if (aFlags & FLAG_SYNC_DECODE) {
32424:     nsresult rv = SyncDecode();
32424:     NS_ENSURE_SUCCESS(rv, rv);
32424:   }
32424: 
34809:   imgFrame *frame = GetCurrentDrawableImgFrame();
32424:   if (!frame) {
32424:     NS_ABORT_IF_FALSE(!mDecoded, "Decoded but frame not available?");
32424:     return NS_OK; // Getting the frame (above) touches the image and kicks off decoding
32424:   }
30479: 
30479:   nsIntRect framerect = frame->GetRect();
30479:   nsIntMargin padding(framerect.x, framerect.y, 
30479:                       mSize.width - framerect.XMost(),
30479:                       mSize.height - framerect.YMost());
30479: 
30479:   frame->Draw(aContext, aFilter, aUserSpaceToImageSpace, aFill, padding, aSubimage);
30479: 
30479:   return NS_OK;
30479: }
30479: 
32424: //******************************************************************************
32424: /* void lockImage() */
32424: NS_IMETHODIMP
32424: imgContainer::LockImage()
 7009: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // Cancel the discard timer if it's there
32424:   if (mDiscardTimer) {
32424:     mDiscardTimer->Cancel();
32424:     mDiscardTimer = nsnull; // It's wasteful to null out the discard timers each
32424:                             // time, but we'll wait to fix that until bug 502694.
 7009:   }
 7009: 
32424:   // Increment the lock count
32424:   mLockCount++;
32424: 
 7009:   return NS_OK;
 7009: }
 7009: 
32424: //******************************************************************************
32424: /* void unlockImage() */
 7009: NS_IMETHODIMP
32424: imgContainer::UnlockImage()
 7009: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // It's an error to call this function if the lock count is 0
32424:   NS_ABORT_IF_FALSE(mLockCount > 0,
32424:                     "Calling UnlockImage with mLockCount == 0!");
32424:   if (mLockCount == 0)
32424:     return NS_ERROR_ABORT;
32424: 
32424:   // We're locked, so we shouldn't have a discard timer set
32424:   NS_ABORT_IF_FALSE(!mDiscardTimer, "Locked, but discard timer set!");
32424: 
32424:   // Decrement our lock count
32424:   mLockCount--;
32424: 
32424:   // We now _might_ have one of the qualifications for discarding. Re-evaluate.
32424:   if (CanDiscard()) {
32424:     nsresult rv = ResetDiscardTimer();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
 7009:   return NS_OK;
 7009: }
 7009: 
32424: // Flushes up to aMaxBytes to the decoder.
32424: nsresult
32424: imgContainer::DecodeSomeData (PRUint32 aMaxBytes)
 7009: {
32424:   // We should have a decoder if we get here
32424:   NS_ABORT_IF_FALSE(mDecoder, "trying to decode without decoder!");
32424: 
32424:   // If we have nothing to decode, return
32424:   if (mBytesDecoded == mSourceData.Length())
32424:     return NS_OK;
32424: 
32424: 
32424:   // write the proper amount of data
32424:   PRUint32 bytesToDecode = PR_MIN(aMaxBytes,
32424:                                   mSourceData.Length() - mBytesDecoded);
32424:   nsresult rv = WriteToDecoder(mSourceData.Elements() + mBytesDecoded,
32424:                                bytesToDecode);
32424: 
32424:   return rv;
32424: }
32424: 
32424: // There are various indicators that tell us we're finished with the decode
32424: // task at hand and can shut down the decoder.
32424: PRBool imgContainer::IsDecodeFinished()
32424: {
32424:   // Assume it's not finished
32424:   PRBool decodeFinished = PR_FALSE;
32424: 
32424:   // There shouldn't be any reason to call this if we're not storing
32424:   // source data
32424:   NS_ABORT_IF_FALSE(StoringSourceData(),
32424:                     "just shut down on SourceDataComplete!");
32424: 
32424:   // The decode is complete if we got what we wanted...
32424:   if (mDecoderFlags & imgIDecoder::DECODER_FLAG_HEADERONLY) {
32424:     if (mHasSize)
32424:       decodeFinished = PR_TRUE;
32424:   }
32424:   else {
32424:     if (mDecoded)
32424:       decodeFinished = PR_TRUE;
32424:   }
32424: 
32424:   // ...or if we have all the source data and wrote all the source data.
32424:   //
32424:   // (NB - This can be distinct from the above case even for non-erroneous
32424:   // images because the decoder might not call DecodingComplete() until we
32424:   // call Close() in ShutdownDecoder())
32424:   if (mHasSourceData && (mBytesDecoded == mSourceData.Length()))
32424:     decodeFinished = PR_TRUE;
32424: 
32424:   return decodeFinished;
32424: }
32424: 
32424: // Indempotent error flagging routine. If a decoder is open,
32424: // sends OnStopContainer and OnStopDecode and shuts down the decoder
32424: void imgContainer::DoError()
32424: {
32424:   // If we've flagged an error before, we have nothing to do
32424:   if (mError)
32424:     return;
32424: 
32424:   // If we're mid-decode
32424:   if (mDecoder) {
32424: 
32424:     // grab the observer and give an OnStopContainer and an OnStopDecode
32424:     nsCOMPtr<imgIDecoderObserver> observer = do_QueryReferent(mObserver);
32424:     if (observer) {
32424:       observer->OnStopContainer(nsnull, this);
32424:       observer->OnStopDecode(nsnull, NS_ERROR_FAILURE, nsnull);
32424:     }
32424: 
32424:     // Shutdown the decoder in error mode. We don't care if this flags other
32424:     // errors.
32424:     (void) ShutdownDecoder(eShutdownIntent_Error);
32424:   }
32424: 
32424:   // Put the container in an error state
32424:   mError = PR_TRUE;
32424: 
32424:   // Log our error
32424:   LOG_CONTAINER_ERROR;
32424: }
32424: 
32424: // Tweakable progressive decoding parameters
32424: #define DECODE_BYTES_AT_A_TIME 4096
32424: #define MAX_USEC_BEFORE_YIELD (1000 * 5)
32424: 
32424: // Decodes some data, then re-posts itself to the end of the event queue if
32424: // there's more processing to be done
32424: NS_IMETHODIMP imgDecodeWorker::Run()
32424: {
32424:   nsresult rv;
32424: 
32424:   // If we shutdown the decoder in this function, we could lose ourselves
32424:   nsCOMPtr<nsIRunnable> kungFuDeathGrip(this);
32424: 
32424:   // The container holds a strong reference to us. Cycles are bad.
32424:   nsCOMPtr<imgIContainer> iContainer(do_QueryReferent(mContainer));
32424:   if (!iContainer)
32424:     return NS_OK;
32424:   imgContainer* container = static_cast<imgContainer*>(iContainer.get());
32424: 
32424:   NS_ABORT_IF_FALSE(container->mInitialized,
32424:                     "Worker active for uninitialized container!");
32424: 
32424:   // If we were pending, we're not anymore
32424:   container->mWorkerPending = PR_FALSE;
32424: 
32424:   // If an error is flagged, it probably happened while we were waiting
32424:   // in the event queue. Bail early, but no need to bother the run queue
32424:   // by returning an error.
32424:   if (container->mError)
32424:     return NS_OK;
32424: 
32424:   // If we don't have a decoder, we must have finished already (for example,
32424:   // a synchronous decode request came while the worker was pending).
32424:   if (!container->mDecoder)
32424:     return NS_OK;
32424: 
32424:   // Header-only decodes are cheap and we more or less want them to be
32424:   // synchronous. Write all the data in that case, otherwise write a
32424:   // chunk
32424:   PRUint32 maxBytes =
32424:     (container->mDecoderFlags & imgIDecoder::DECODER_FLAG_HEADERONLY)
32424:     ? container->mSourceData.Length() : DECODE_BYTES_AT_A_TIME;
32424: 
32424:   // Loop control
32424:   PRBool haveMoreData = PR_TRUE;
32424:   nsTime deadline(PR_Now() + MAX_USEC_BEFORE_YIELD);
32424: 
32424:   // We keep decoding chunks until one of three possible events occur:
32424:   // 1) We don't have any data left to decode
32424:   // 2) The decode completes
32424:   // 3) We hit the deadline and need to yield to keep the UI snappy
32424:   while (haveMoreData && !container->IsDecodeFinished() &&
32424:          (nsTime(PR_Now()) < deadline)) {
32424: 
32424:     // Decode a chunk of data
32424:     rv = container->DecodeSomeData(maxBytes);
32424:     if (NS_FAILED(rv)) {
32424:       container->DoError();
32424:       return rv;
32424:     }
32424: 
32424:     // Figure out if we still have more data
32424:     haveMoreData =
32424:       container->mSourceData.Length() > container->mBytesDecoded;
32424:   }
32424: 
32424:   // If the decode finished, shutdown the decoder
32424:   if (container->IsDecodeFinished()) {
32424:     rv = container->ShutdownDecoder(imgContainer::eShutdownIntent_Done);
32424:     if (NS_FAILED(rv)) {
32424:       container->DoError();
32424:       return rv;
32424:     }
32424:   }
32424: 
32424:   // If Conditions 1 & 2 are still true, then the only reason we bailed was
32424:   // because we hit the deadline. Repost ourselves to the end of the event
32424:   // queue.
32424:   if (!container->IsDecodeFinished() && haveMoreData)
32424:     return this->Dispatch();
32424: 
32424:   // Otherwise, return success
 7009:   return NS_OK;
 7009: }
 7009: 
32424: // Queues the worker up at the end of the event queue
32424: NS_METHOD imgDecodeWorker::Dispatch()
 7009: {
32424:   // The container holds a strong reference to us. Cycles are bad.
32424:   nsCOMPtr<imgIContainer> iContainer(do_QueryReferent(mContainer));
32424:   if (!iContainer)
32424:     return NS_OK;
32424:   imgContainer* container = static_cast<imgContainer*>(iContainer.get());
32424: 
32424:   // We should not be called if there's already a pending worker
32424:   NS_ABORT_IF_FALSE(!container->mWorkerPending,
32424:                     "Trying to queue up worker with one already pending!");
32424: 
32424:   // Flag that we're pending
32424:   container->mWorkerPending = PR_TRUE;
32424: 
32424:   // Dispatch
32424:   return NS_DispatchToCurrentThread(this);
32424: }
32424: 
32424: // nsIInputStream callback to copy the incoming image data directly to the 
32424: // container without processing. The imgContainer is passed as the closure.
32424: // Always reads everything it gets, even if the data is erroneous.
32424: NS_METHOD
32424: imgContainer::WriteToContainer(nsIInputStream* in, void* closure,
32424:                                const char* fromRawSegment, PRUint32 toOffset,
32424:                                PRUint32 count, PRUint32 *writeCount)
32424: {
32424:   // Retrieve the imgContainer
32424:   imgIContainer *container = static_cast<imgIContainer*>(closure);
32424: 
32424:   // Copy the source data. We squelch the return value here, because returning
32424:   // an error means that ReadSegments stops reading data, violating our
32424:   // invariant that we read everything we get.
32424:   (void) container->AddSourceData(fromRawSegment, count);
32424: 
32424:   // We wrote everything we got
32424:   *writeCount = count;
32424: 
 7009:   return NS_OK;
 7009: }
