38727: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
38727:  * ***** BEGIN LICENSE BLOCK *****
38727:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
38727:  *
38727:  * The contents of this file are subject to the Mozilla Public License Version
38727:  * 1.1 (the "License"); you may not use this file except in compliance with
38727:  * the License. You may obtain a copy of the License at
38727:  * http://www.mozilla.org/MPL/
38727:  *
38727:  * Software distributed under the License is distributed on an "AS IS" basis,
38727:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
38727:  * for the specific language governing rights and limitations under the
38727:  * License.
38727:  *
38727:  * The Original Code is Mozilla Foundation code.
38727:  *
38727:  * The Initial Developer of the Original Code is Mozilla Foundation.
38727:  * Portions created by the Initial Developer are Copyright (C) 2010
38727:  * the Initial Developer. All Rights Reserved.
38727:  *
38727:  * Contributor(s):
38727:  *   Bas Schouten <bschouten@mozilla.com>
38727:  *
38727:  * Alternatively, the contents of this file may be used under the terms of
38727:  * either the GNU General Public License Version 2 or later (the "GPL"), or
38727:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
38727:  * in which case the provisions of the GPL or the LGPL are applicable instead
38727:  * of those above. If you wish to allow use of your version of this file only
38727:  * under the terms of either the GPL or the LGPL, and not to allow others to
38727:  * use your version of this file under the terms of the MPL, indicate your
38727:  * decision by deleting the provisions above and replace them with the notice
38727:  * and other provisions required by the GPL or the LGPL. If you do not delete
38727:  * the provisions above, a recipient may use your version of this file under
38727:  * the terms of any one of the MPL, the GPL or the LGPL.
38727:  *
38727:  * ***** END LICENSE BLOCK ***** */
38727: 
38727: #include "gfxDWriteFontList.h"
38727: #include "gfxDWriteFonts.h"
38727: #include "nsUnicharUtils.h"
38727: #include "nsILocaleService.h"
38727: 
38727: #include "gfxGDIFontList.h"
38727: 
38867: #include "nsIWindowsRegKey.h"
38867: 
38727: // font info loader constants
38727: static const PRUint32 kDelayBeforeLoadingFonts = 8 * 1000; // 8secs
38727: static const PRUint32 kIntervalBetweenLoadingFonts = 150; // 150ms
38727: 
38727: static __inline void
38727: BuildKeyNameFromFontName(nsAString &aName)
38727: {
38727:     if (aName.Length() >= LF_FACESIZE)
38727:         aName.Truncate(LF_FACESIZE - 1);
38727:     ToLowerCase(aName);
38727: }
38727: 
38727: ////////////////////////////////////////////////////////////////////////////////
38727: // gfxDWriteFontFamily
38727: 
38727: gfxDWriteFontFamily::~gfxDWriteFontFamily()
38727: {
38727: }
38727: 
38727: void
38727: gfxDWriteFontFamily::FindStyleVariations()
38727: {
38727:     HRESULT hr;
38727:     if (mHasStyles) {
38727:         return;
38727:     }
38727:     mHasStyles = PR_TRUE;
38727: 
38727:     for (UINT32 i = 0; i < mDWFamily->GetFontCount(); i++) {
38727:         nsRefPtr<IDWriteFont> font;
38727:         hr = mDWFamily->GetFont(i, getter_AddRefs(font));
38727:         if (FAILED(hr)) {
38727:             // This should never happen.
38727:             NS_WARNING("Failed to get existing font from family.");
38727:             continue;
38727:         }
38727: 
38727:         if (font->GetSimulations() & DWRITE_FONT_SIMULATIONS_OBLIQUE) {
38727:             // We don't want these.
38727:             continue;
38727:         }
38727: 
38727:         nsRefPtr<IDWriteLocalizedStrings> names;
38727:         hr = font->GetFaceNames(getter_AddRefs(names));
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727:         
38727:         BOOL exists;
38727:         nsAutoTArray<WCHAR,32> faceName;
38727:         UINT32 englishIdx = 0;
38727:         hr = names->FindLocaleName(L"en-us", &englishIdx, &exists);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727: 
38727:         if (!exists) {
38727:             // No english found, use whatever is first in the list.
38727:             englishIdx = 0;
38727:         }
38727:         UINT32 length;
38727:         hr = names->GetStringLength(englishIdx, &length);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727:         if (!faceName.SetLength(length + 1)) {
38727:             // Eeep - running out of memory. Unlikely to end well.
38727:             continue;
38727:         }
38727: 
38727:         hr = names->GetString(englishIdx, faceName.Elements(), length + 1);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727: 
38727:         nsString fullID(mName);
38727:         fullID.Append(faceName.Elements());
38727: 
38727:         /**
38727:          * Faces do not have a localized name so we just put the en-us name in
38727:          * here.
38727:          */
38727:         gfxDWriteFontEntry *fe = 
38727:             new gfxDWriteFontEntry(fullID, font);
38727:         fe->SetFamily(this);
38727: 
38727:         mAvailableFonts.AppendElement(fe);
38727:     }
38727:     if (!mAvailableFonts.Length()) {
38727:         NS_WARNING("Family with no font faces in it.");
38727:     }
38727: 
46178:     if (mIsBadUnderlineFamily) {
46178:         SetBadUnderlineFonts();
46178:     }
38727: }
38727: 
38727: void
38727: gfxDWriteFontFamily::LocalizedName(nsAString &aLocalizedName)
38727: {
38727:     aLocalizedName.AssignLiteral("Unknown Font");
38727:     HRESULT hr;
38727:     nsresult rv;
38727:     nsCOMPtr<nsILocaleService> ls = do_GetService(NS_LOCALESERVICE_CONTRACTID,
38727:                                                   &rv);
38727:     nsCOMPtr<nsILocale> locale;
38727:     rv = ls->GetApplicationLocale(getter_AddRefs(locale));
38727:     nsString localeName;
38727:     if (NS_SUCCEEDED(rv)) {
38727:         rv = locale->GetCategory(NS_LITERAL_STRING(NSILOCALE_MESSAGE), 
38727:                                  localeName);
38727:     }
38727:     if (NS_FAILED(rv)) {
38727:         localeName.AssignLiteral("en-us");
38727:     }
38727: 
38727:     nsRefPtr<IDWriteLocalizedStrings> names;
38727: 
38727:     hr = mDWFamily->GetFamilyNames(getter_AddRefs(names));
38727:     if (FAILED(hr)) {
38727:         return;
38727:     }
38727:     UINT32 idx = 0;
38727:     BOOL exists;
38727:     hr = names->FindLocaleName(localeName.BeginReading(),
38727:                                &idx,
38727:                                &exists);
38727:     if (FAILED(hr)) {
38727:         return;
38727:     }
38727:     if (!exists) {
38727:         // Use english is localized is not found.
38727:         hr = names->FindLocaleName(L"en-us", &idx, &exists);
38727:         if (FAILED(hr)) {
38727:             return;
38727:         }
38727:         if (!exists) {
38727:             // Use 0 index if english is not found.
38727:             idx = 0;
38727:         }
38727:     }
38727:     nsAutoTArray<WCHAR, 32> famName;
38727:     UINT32 length;
38727:     
38727:     hr = names->GetStringLength(idx, &length);
38727:     if (FAILED(hr)) {
38727:         return;
38727:     }
38727:     
38727:     if (!famName.SetLength(length + 1)) {
38727:         // Eeep - running out of memory. Unlikely to end well.
38727:         return;
38727:     }
38727: 
38727:     hr = names->GetString(idx, famName.Elements(), length + 1);
38727:     if (FAILED(hr)) {
38727:         return;
38727:     }
38727: 
38727:     aLocalizedName = nsDependentString(famName.Elements());
38727: }
38727: 
38727: ////////////////////////////////////////////////////////////////////////////////
38727: // gfxDWriteFontEntry
38727: 
38727: gfxDWriteFontEntry::~gfxDWriteFontEntry()
38727: {
38727: }
38727: 
38727: PRBool
38727: gfxDWriteFontEntry::IsSymbolFont()
38727: {
38727:     if (mFont) {
38727:         return mFont->IsSymbolFont();
38727:     } else {
38727:         return PR_FALSE;
38727:     }
38727: }
38727: 
38727: nsresult
38727: gfxDWriteFontEntry::GetFontTable(PRUint32 aTableTag,
38727:                                  nsTArray<PRUint8> &aBuffer)
38727: {
38727:     nsRefPtr<IDWriteFontFace> fontFace;
38727:     HRESULT hr;
38727:     nsresult rv;
38727:     rv = CreateFontFace(getter_AddRefs(fontFace));
38727: 
38727:     if (NS_FAILED(rv)) {
38727:         return rv;
38727:     }
38727: 
38727:     PRUint8 *tableData;
38727:     PRUint32 len;
38727:     void *tableContext = NULL;
38727:     BOOL exists;
38727:     hr = fontFace->TryGetFontTable(NS_SWAP32(aTableTag),
38727:                                    (const void**)&tableData,
38727:                                    &len,
38727:                                    &tableContext,
38727:                                    &exists);
38727: 
38727:     if (FAILED(hr) || !exists) {
38727:         return NS_ERROR_FAILURE;
38727:     }
38727:     if (!aBuffer.SetLength(len)) {
38727:         return NS_ERROR_OUT_OF_MEMORY;
38727:     }
38727:     memcpy(aBuffer.Elements(), tableData, len);
38727:     if (tableContext) {
38727:         fontFace->ReleaseFontTable(&tableContext);
38727:     }
38727:     return NS_OK;
38727: }
38727: 
38727: nsresult
38727: gfxDWriteFontEntry::ReadCMAP()
38727: {
38727:     nsRefPtr<IDWriteFontFace> fontFace;
38727:     HRESULT hr;
38727:     nsresult rv;
38727:     rv = CreateFontFace(getter_AddRefs(fontFace));
38727: 
38727:     if (NS_FAILED(rv)) {
38727:         return rv;
38727:     }
38727: 
38727:     PRUint8 *tableData;
38727:     PRUint32 len;
38727:     void *tableContext = NULL;
38727:     BOOL exists;
38727:     hr = fontFace->TryGetFontTable(DWRITE_MAKE_OPENTYPE_TAG('c', 'm', 'a', 'p'),
38727:                                    (const void**)&tableData,
38727:                                    &len,
38727:                                    &tableContext,
38727:                                    &exists);
38727:     if (FAILED(hr)) {
38727:         return NS_ERROR_FAILURE;
38727:     }
38727: 
38727:     PRPackedBool isSymbol = fontFace->IsSymbolFont();
38727:     PRPackedBool isUnicode = PR_TRUE;
38727:     if (exists) {
38727:         rv = gfxFontUtils::ReadCMAP(tableData,
38727:                                     len,
38727:                                     mCharacterMap,
42989:                                     mUVSOffset,
38727:                                     isUnicode,
38727:                                     isSymbol);
38727:     }
38727:     fontFace->ReleaseFontTable(tableContext);
38727: 
38727:     mCmapInitialized = PR_TRUE;
43527:     mHasCmapTable = NS_SUCCEEDED(rv);
38727:     return rv;
38727: }
38727: 
38727: gfxFont *
38727: gfxDWriteFontEntry::CreateFontInstance(const gfxFontStyle* aFontStyle,
39306:                                        PRBool aNeedsBold)
38727: {
39306:     return new gfxDWriteFont(this, aFontStyle, aNeedsBold);
38727: }
38727: 
38727: nsresult
38727: gfxDWriteFontEntry::CreateFontFace(IDWriteFontFace **aFontFace,
38727:                                    DWRITE_FONT_SIMULATIONS aSimulations)
38727: {
38727:     HRESULT hr;
38727:     if (mFont) {
38727:         hr = mFont->CreateFontFace(aFontFace);
38727:     } else if (mFontFile) {
38727:         IDWriteFontFile *fontFile = mFontFile.get();
38727:         hr = gfxWindowsPlatform::GetPlatform()->GetDWriteFactory()->
38727:             CreateFontFace(mFaceType,
38727:                            1,
38727:                            &fontFile,
38727:                            0,
38727:                            aSimulations,
38727:                            aFontFace);
38727:     }
38727:     if (FAILED(hr)) {
38727:         return NS_ERROR_FAILURE;
38727:     }
38727:     return NS_OK;
38727: }
38727: 
38727: ////////////////////////////////////////////////////////////////////////////////
38727: // gfxDWriteFontList
38727: 
38727: gfxDWriteFontList::gfxDWriteFontList()
38727: {
38867:     mFontSubstitutes.Init();
38727: }
38727: 
38727: gfxFontEntry *
38727: gfxDWriteFontList::GetDefaultFont(const gfxFontStyle *aStyle,
38727:                                   PRBool &aNeedsBold)
38727: {
38727:     NONCLIENTMETRICSW ncm;
38727:     ncm.cbSize = sizeof(ncm);
38727:     BOOL status = ::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, 
38727:                                           sizeof(ncm), &ncm, 0);
38727:     if (status) {
38727:         nsAutoString resolvedName;
38727:         if (ResolveFontName(nsDependentString(ncm.lfMessageFont.lfFaceName),
38727:                             resolvedName)) {
38727:             return FindFontForFamily(resolvedName, aStyle, aNeedsBold);
38727:         }
38727:     }
38727: 
38727:     return nsnull;
38727: }
38727: 
38727: gfxFontEntry *
38727: gfxDWriteFontList::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
38727:                                    const nsAString& aFullname)
38727: {
38727:     PRBool found;
38727:     gfxFontEntry *lookup;
38727: 
38727:     // initialize name lookup tables if needed
38727:     if (!mFaceNamesInitialized) {
38727:         InitFaceNameLists();
38727:     }
38727: 
38727:     // lookup in name lookup tables, return null if not found
38727:     if (!(lookup = mPostscriptNames.GetWeak(aFullname, &found)) &&
38727:         !(lookup = mFullnames.GetWeak(aFullname, &found))) 
38727:     {
38727:         return nsnull;
38727:     }
38727:     gfxFontEntry *fe = 
38727:         new gfxDWriteFontEntry(lookup->Name(),
38727:                                static_cast<gfxDWriteFontEntry*>(lookup)->mFont,
38727:                                aProxyEntry->Weight(),
38727:                                aProxyEntry->Stretch(),
38727:                                aProxyEntry->IsItalic());
38727: 
38727:     return fe;
38727: }
38727: 
38727: gfxFontEntry *
38727: gfxDWriteFontList::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
38727:                                     const PRUint8 *aFontData,
38727:                                     PRUint32 aLength)
38727: {
38727:     nsresult rv;
38727:     nsAutoString uniqueName;
38727:     rv = gfxFontUtils::MakeUniqueUserFontName(uniqueName);
38727:     if (NS_FAILED(rv)) {
38727:         NS_Free((void*)aFontData);
38727:         return nsnull;
38727:     }
38727: 
38727:     nsTArray<PRUint8> newFontData;
38727: 
38727:     rv = gfxFontUtils::RenameFont(uniqueName, aFontData, aLength, &newFontData);
38727:     NS_Free((void*)aFontData);
38727: 
38727:     if (NS_FAILED(rv)) {
38727:         return nsnull;
38727:     }
38727:     
38727:     DWORD numFonts = 0;
38727: 
38727:     nsRefPtr<IDWriteFontFile> fontFile;
38727:     HRESULT hr;
38727: 
38727:     /**
38868:      * We pass in a pointer to a structure containing a pointer to the array
38868:      * containing the font data and a unique identifier. DWrite will
38727:      * internally copy what is at that pointer, and pass that to
38727:      * CreateStreamFromKey. The array will be empty when the function 
38727:      * succesfully returns since it swaps out the data.
38727:      */
38868:     ffReferenceKey key;
38868:     key.mArray = &newFontData;
38868:     nsCOMPtr<nsIUUIDGenerator> uuidgen =
38868:       do_GetService("@mozilla.org/uuid-generator;1");
38868:     if (!uuidgen) {
38868:         return nsnull;
38868:     }
38868: 
38868:     rv = uuidgen->GenerateUUIDInPlace(&key.mGUID);
38868: 
38868:     if (NS_FAILED(rv)) {
38868:         return nsnull;
38868:     }
38868: 
38727:     hr = gfxWindowsPlatform::GetPlatform()->GetDWriteFactory()->
38868:         CreateCustomFontFileReference(&key,
38868:                                       sizeof(key),
38727:                                       gfxDWriteFontFileLoader::Instance(),
38727:                                       getter_AddRefs(fontFile));
38727: 
38727:     if (FAILED(hr)) {
38727:         NS_WARNING("Failed to create custom font file reference.");
38727:         return nsnull;
38727:     }
38727: 
38727:     BOOL isSupported;
38727:     DWRITE_FONT_FILE_TYPE fileType;
38727:     UINT32 numFaces;
38727: 
38727:     PRUint16 w = (aProxyEntry->mWeight == 0 ? 400 : aProxyEntry->mWeight);
38727:     gfxDWriteFontEntry *entry = 
38727:         new gfxDWriteFontEntry(uniqueName, 
38727:                                fontFile,
38727:                                aProxyEntry->Weight(),
38727:                                aProxyEntry->Stretch(),
38727:                                aProxyEntry->IsItalic());
38727: 
38727:     fontFile->Analyze(&isSupported, &fileType, &entry->mFaceType, &numFaces);
38727:     if (!isSupported || numFaces > 1) {
38727:         // We don't know how to deal with 0 faces either.
38727:         delete entry;
38727:         return nsnull;
38727:     }
38727: 
38727:     return entry;
38727: }
38727: 
57104: nsresult
38727: gfxDWriteFontList::InitFontList()
38727: {
38727:     HRESULT hr;
38727:     gfxFontCache *fc = gfxFontCache::GetCache();
38727:     if (fc) {
38727:         fc->AgeAllGenerations();
38727:     }
38727: 
38727:     gfxPlatformFontList::InitFontList();
38727: 
38867:     mFontSubstitutes.Clear();
38867:     mNonExistingFonts.Clear();
38867: 
38727:     nsRefPtr<IDWriteFontCollection> systemFonts;
38727:     hr = gfxWindowsPlatform::GetPlatform()->GetDWriteFactory()->
38727:         GetSystemFontCollection(getter_AddRefs(systemFonts));
38727:     NS_ASSERTION(SUCCEEDED(hr), "GetSystemFontCollection failed!");
38727: 
57104:     if (FAILED(hr)) {
57104:         return NS_ERROR_FAILURE;
57104:     }
57104: 
38727:     for (UINT32 i = 0; i < systemFonts->GetFontFamilyCount(); i++) {
38727:         nsRefPtr<IDWriteFontFamily> family;
38727:         systemFonts->GetFontFamily(i, getter_AddRefs(family));
38727: 
38727:         nsRefPtr<IDWriteLocalizedStrings> names;
38727:         hr = family->GetFamilyNames(getter_AddRefs(names));
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727: 
38727:         UINT32 englishIdx = 0;
38727: 
38727:         BOOL exists;
38727:         hr = names->FindLocaleName(L"en-us", &englishIdx, &exists);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727:         if (!exists) {
38727:             // Use 0 index if english is not found.
38727:             englishIdx = 0;
38727:         }
38727: 
38727:         nsAutoTArray<WCHAR, 32> famName;
38727:         UINT32 length;
38727:         
38727:         hr = names->GetStringLength(englishIdx, &length);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727:         
38727:         if (!famName.SetLength(length + 1)) {
38727:             // Eeep - running out of memory. Unlikely to end well.
38727:             continue;
38727:         }
38727: 
38727:         hr = names->GetString(englishIdx, famName.Elements(), length + 1);
38727:         if (FAILED(hr)) {
38727:             continue;
38727:         }
38727: 
38727:         nsAutoString name(famName.Elements());
38727:         BuildKeyNameFromFontName(name);
38727: 
38867:         if (!mFontFamilies.GetWeak(name)) {
38727:             nsRefPtr<gfxFontFamily> fam = 
46178:                 new gfxDWriteFontFamily(nsDependentString(famName.Elements()),
38727:                                         family);
46178:             if (mBadUnderlineFamilyNames.Contains(name)) {
46178:                 fam->SetBadUnderlineFamily();
46178:             }
38867:             mFontFamilies.Put(name, fam);
38727:         }
38727:     }
38727: 
38867:     GetFontSubstitutes();
38867: 
38727:     StartLoader(kDelayBeforeLoadingFonts, kIntervalBetweenLoadingFonts);
57104: 
57104:     return NS_OK;
38727: }
38788: 
38867: static void
38867: RemoveCharsetFromFontSubstitute(nsAString &aName)
38867: {
38867:     PRInt32 comma = aName.FindChar(PRUnichar(','));
38867:     if (comma >= 0)
38867:         aName.Truncate(comma);
38867: }
38867: 
38867: nsresult
38867: gfxDWriteFontList::GetFontSubstitutes()
38867: {
38867:     // Create the list of FontSubstitutes
38867:     nsCOMPtr<nsIWindowsRegKey> regKey = 
38867:         do_CreateInstance("@mozilla.org/windows-registry-key;1");
38867:     if (!regKey) {
38867:         return NS_ERROR_FAILURE;
38867:     }
38867:     NS_NAMED_LITERAL_STRING(
38867:         kFontSubstitutesKey,
38867:         "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes");
38867: 
38867:     nsresult rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_LOCAL_MACHINE,
38867:                                kFontSubstitutesKey,
38867:                                nsIWindowsRegKey::ACCESS_READ);
38867:     if (NS_FAILED(rv)) {
38867:         return rv;
38867:     }
38867: 
38867:     PRUint32 count;
38867:     rv = regKey->GetValueCount(&count);
38867:     if (NS_FAILED(rv) || count == 0)
38867:         return rv;
38867:     for (PRUint32 i = 0; i < count; i++) {
38867:         nsAutoString substituteName;
38867:         rv = regKey->GetValueName(i, substituteName);
38867:         if (NS_FAILED(rv) || substituteName.IsEmpty() ||
38867:             substituteName.CharAt(1) == PRUnichar('@')) {
38867:             continue;
38867:         }
38867:         PRUint32 valueType;
38867:         rv = regKey->GetValueType(substituteName, &valueType);
38867:         if (NS_FAILED(rv) || valueType != nsIWindowsRegKey::TYPE_STRING) {
38867:             continue;
38867:         }
38867:         nsAutoString actualFontName;
38867:         rv = regKey->ReadStringValue(substituteName, actualFontName);
38867:         if (NS_FAILED(rv)) {
38867:             continue;
38867:         }
38867: 
38867:         RemoveCharsetFromFontSubstitute(substituteName);
38867:         BuildKeyNameFromFontName(substituteName);
38867:         RemoveCharsetFromFontSubstitute(actualFontName);
38867:         BuildKeyNameFromFontName(actualFontName);
38867:         gfxFontFamily *ff;
38867:         if (!actualFontName.IsEmpty() && 
38867:             (ff = mFontFamilies.GetWeak(actualFontName))) {
38867:             mFontSubstitutes.Put(substituteName, ff);
38867:         } else {
38867:             mNonExistingFonts.AppendElement(substituteName);
38867:         }
38867:     }
38867:     return NS_OK;
38867: }
38867: 
38788: PRBool
38788: gfxDWriteFontList::GetStandardFamilyName(const nsAString& aFontName,
38788:                                          nsAString& aFamilyName)
38788: {
38788:     gfxFontFamily *family = FindFamily(aFontName);
38788:     if (family) {
38788:         family->LocalizedName(aFamilyName);
38788:         return PR_TRUE;
38788:     }
38788: 
38788:     return PR_FALSE;
38788: }
38867: 
38867: PRBool 
38867: gfxDWriteFontList::ResolveFontName(const nsAString& aFontName,
38867:                                    nsAString& aResolvedFontName)
38867: {
38867:     nsAutoString keyName(aFontName);
38867:     BuildKeyNameFromFontName(keyName);
38867: 
38867:     nsRefPtr<gfxFontFamily> ff;
38867:     if (mFontSubstitutes.Get(keyName, &ff)) {
38867:         aResolvedFontName = ff->Name();
38867:         return PR_TRUE;
38867:     }
38867: 
38867:     if (mNonExistingFonts.Contains(keyName)) {
38867:         return PR_FALSE;
38867:     }
38867: 
38867:     return gfxPlatformFontList::ResolveFontName(aFontName, aResolvedFontName);
38867: }
