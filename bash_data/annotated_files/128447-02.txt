     1: /* -*- Mode: objc; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 80467: #include "mozilla/Util.h"
 80467: 
 46321: #ifdef MOZ_LOGGING
 46321: #define FORCE_PR_LOG
 46321: #endif
 46321: #include "prlog.h"
 46321: 
     1: #include <unistd.h>
 75269: #include <math.h>
     1:  
     1: #include "nsChildView.h"
  3574: #include "nsCocoaWindow.h"
     1: 
 11978: #include "nsObjCExceptions.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsToolkit.h"
     1: #include "nsCRT.h"
     1: 
 68493: #include "nsFontMetrics.h"
     1: #include "nsIRollupListener.h"
127607: #include "nsViewManager.h"
     1: #include "nsIInterfaceRequestor.h"
101111: #include "nsIFile.h"
  3545: #include "nsILocalFileMac.h"
     1: #include "nsGfxCIID.h"
 29316: #include "nsIDOMSimpleGestureEvent.h"
 70007: #include "nsNPAPIPluginInstance.h"
 60289: #include "nsThemeConstants.h"
108457: #include "nsIWidgetListener.h"
119178: #include "nsIPresShell.h"
     1: 
     1: #include "nsDragService.h"
 26757: #include "nsClipboard.h"
     1: #include "nsCursorManager.h"
     1: #include "nsWindowMap.h"
 98723: #include "nsCocoaFeatures.h"
     1: #include "nsCocoaUtils.h"
 21081: #include "nsMenuUtilsX.h"
 10884: #include "nsMenuBarX.h"
 43436: #ifdef __LP64__
 43436: #include "ComplexTextInputPanel.h"
 43436: #endif
     1: 
     1: #include "gfxContext.h"
     1: #include "gfxQuartzSurface.h"
 34711: #include "nsRegion.h"
 41434: #include "Layers.h"
 41434: #include "LayerManagerOGL.h"
124008: #include "GLTextureImage.h"
 87729: #include "mozilla/layers/CompositorCocoaWidgetHelper.h"
101309: #ifdef ACCESSIBILITY
101309: #include "nsAccessibilityService.h"
124964: #include "mozilla/a11y/Platform.h"
101309: #endif
     1: 
 70976: #include "mozilla/Preferences.h"
 70976: 
 15067: #include <dlfcn.h>
 15067: 
 27993: #include <ApplicationServices/ApplicationServices.h>
 27993: 
 87692: #include "sampler.h"
 87692: 
108072: #include "nsIDOMWheelEvent.h"
108072: 
 80467: using namespace mozilla;
 41434: using namespace mozilla::layers;
 62870: using namespace mozilla::gl;
 69464: using namespace mozilla::widget;
 70976: using namespace mozilla;
 69464: 
     1: #undef DEBUG_UPDATE
     1: #undef INVALIDATE_DEBUGGING  // flash areas as they are invalidated
     1: 
 25019: // Don't put more than this many rects in the dirty region, just fluff
 25019: // out to the bounding-box if there are more
 25019: #define MAX_RECTS_IN_REGION 100
 25019: 
  3545: #ifdef PR_LOGGING
106838: PRLogModuleInfo* sCocoaLog = nullptr;
  3545: #endif
  3545: 
     1: extern "C" {
     1:   CG_EXTERN void CGContextResetCTM(CGContextRef);
     1:   CG_EXTERN void CGContextSetCTM(CGContextRef, CGAffineTransform);
     1:   CG_EXTERN void CGContextResetClip(CGContextRef);
     1: }
     1: 
 50708: // defined in nsMenuBarX.mm
 50708: extern NSMenu* sApplicationMenu; // Application menu shared by all menubars
 50708: 
 79445: bool gChildViewMethodsSwizzled = false;
 33316: 
 33316: extern nsISupportsArray *gDraggedTransferables;
 33316: 
 32976: ChildView* ChildViewMouseTracker::sLastMouseEventView = nil;
 75392: NSEvent* ChildViewMouseTracker::sLastMouseMoveEvent = nil;
 75223: NSWindow* ChildViewMouseTracker::sWindowUnderMouse = nil;
 76751: NSPoint ChildViewMouseTracker::sLastScrollEventScreenLocation = NSZeroPoint;
   539: 
     1: #ifdef INVALIDATE_DEBUGGING
     1: static void blinkRect(Rect* r);
     1: static void blinkRgn(RgnHandle rgn);
     1: #endif
     1: 
 79445: bool gUserCancelledDrag = false;
     1: 
108991: uint32_t nsChildView::sLastInputEventCount = 0;
 27993: 
     1: @interface ChildView(Private)
     1: 
     1: // sets up our view, attaching it to its owning gecko view
  6754: - (id)initWithFrame:(NSRect)inFrame geckoChild:(nsChildView*)inChild;
 61878: - (void)forceRefreshOpenGL;
     1: 
  2315: // set up a gecko mouse event based on a cocoa mouse event
  2315: - (void) convertCocoaMouseEvent:(NSEvent*)aMouseEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent;
  2315: 
     1: - (NSMenu*)contextMenu;
     1: 
     1: - (void)setIsPluginView:(BOOL)aIsPlugin;
 32120: - (void)setPluginEventModel:(NPEventModel)eventModel;
 54248: - (void)setPluginDrawingModel:(NPDrawingModel)drawingModel;
 54248: - (NPDrawingModel)pluginDrawingModel;
     1: 
     1: - (BOOL)isRectObscuredBySubview:(NSRect)inRect;
     1: 
     1: - (void)processPendingRedraws;
     1: 
118896: - (void)drawRect:(NSRect)aRect inContext:(CGContextRef)aContext alternate:(BOOL)aIsAlternate;
 55858: 
 61287: // Called using performSelector:withObject:afterDelay:0 to release
 61287: // aWidgetArray (and its contents) the next time through the run loop.
 61287: - (void)releaseWidgets:(NSArray*)aWidgetArray;
 61287: 
     1: #if USE_CLICK_HOLD_CONTEXTMENU
     1:  // called on a timer two seconds after a mouse down to see if we should display
     1:  // a context menu (click-hold)
     1: - (void)clickHoldCallback:(id)inEvent;
     1: #endif
     1: 
     1: #ifdef ACCESSIBILITY
     1: - (id<mozAccessible>)accessible;
     1: #endif
     1: 
 47792: - (BOOL)inactiveWindowAcceptsMouseEvent:(NSEvent*)aEvent;
 47792: 
     1: @end
     1: 
     1: #pragma mark -
     1: 
     1: /* Convenience routines to go from a gecko rect to cocoa NSRects and back
     1:  *
     1:  * Gecko rects (nsRect) contain an origin (x,y) in a coordinate
     1:  * system with (0,0) in the top-left of the screen. Cocoa rects
     1:  * (NSRect) contain an origin (x,y) in a coordinate system with
     1:  * (0,0) in the bottom-left of the screen. Both nsRect and NSRect
     1:  * contain width/height info, with no difference in their use.
     1:  * If a Cocoa rect is from a flipped view, there is no need to
     1:  * convert coordinate systems.
     1:  */
     1: 
     1: static inline void
 23738: NSRectToGeckoRect(const NSRect & inCocoaRect, nsIntRect & outGeckoRect)
 23738: {
 23738:   outGeckoRect.x = NSToIntRound(inCocoaRect.origin.x);
 23738:   outGeckoRect.y = NSToIntRound(inCocoaRect.origin.y);
 23738:   outGeckoRect.width = NSToIntRound(inCocoaRect.origin.x + inCocoaRect.size.width) - outGeckoRect.x;
 23738:   outGeckoRect.height = NSToIntRound(inCocoaRect.origin.y + inCocoaRect.size.height) - outGeckoRect.y;
 23738: }
     1: 
     1: static inline void 
 23738: ConvertGeckoRectToMacRect(const nsIntRect& aRect, Rect& outMacRect)
     1: {
     1:   outMacRect.left = aRect.x;
     1:   outMacRect.top = aRect.y;
     1:   outMacRect.right = aRect.x + aRect.width;
     1:   outMacRect.bottom = aRect.y + aRect.height;
     1: }
     1: 
     1: // Flips a screen coordinate from a point in the cocoa coordinate system (bottom-left rect) to a point
     1: // that is a "flipped" cocoa coordinate system (starts in the top-left).
     1: static inline void
     1: FlipCocoaScreenCoordinate(NSPoint &inPoint)
     1: {
  8779:   inPoint.y = nsCocoaUtils::FlippedScreenY(inPoint.y);
     1: }
     1: 
 73539: void EnsureLogInitialized()
 73539: {
 73539: #ifdef PR_LOGGING
 73539:   if (!sCocoaLog) {
 73539:     sCocoaLog = PR_NewLogModule("nsCocoaWidgets");
 73539:   }
 73539: #endif // PR_LOGGING
 73539: }
 73539: 
 32916: #pragma mark -
 32916: 
 32916: nsChildView::nsChildView() : nsBaseWidget()
106838: , mView(nullptr)
106838: , mParentView(nullptr)
106838: , mParentWidget(nullptr)
115495: , mBackingScaleFactor(0.0)
 79564: , mVisible(false)
 79564: , mDrawing(false)
 79564: , mPluginDrawing(false)
 79564: , mIsDispatchPaint(false)
106838: , mPluginInstanceOwner(nullptr)
 32916: {
 73539:   EnsureLogInitialized();
  3545: 
 39839:   memset(&mPluginCGContext, 0, sizeof(mPluginCGContext));
 39839: 
  5676:   SetBackgroundColor(NS_RGB(255, 255, 255));
  5676:   SetForegroundColor(NS_RGB(0, 0, 0));
     1: }
     1: 
     1: nsChildView::~nsChildView()
     1: {
 30427:   // Notify the children that we're gone.  childView->ResetParent() can change
 30427:   // our list of children while it's being iterated, so the way we iterate the
 30427:   // list must allow for this.
 30427:   for (nsIWidget* kid = mLastChild; kid;) {
  3233:     nsChildView* childView = static_cast<nsChildView*>(kid);
 30427:     kid = kid->GetPrevSibling();
 27679:     childView->ResetParent();
     1:   }
     1: 
 15567:   NS_WARN_IF_FALSE(mOnDestroyCalled, "nsChildView object destroyed without calling Destroy()");
 15567: 
106838:   mResizerImage = nullptr;
 62871: 
 15567:   // An nsChildView object that was in use can be destroyed without Destroy()
 15567:   // ever being called on it.  So we also need to do a quick, safe cleanup
 15567:   // here (it's too late to just call Destroy(), which can cause crashes).
 15567:   // It's particularly important to make sure widgetDestroyed is called on our
 15567:   // mView -- this method NULLs mView's mGeckoChild, and NULL checks on
 15567:   // mGeckoChild are used throughout the ChildView class to tell if it's safe
 15567:   // to use a ChildView object.
 15567:   [mView widgetDestroyed]; // Safe if mView is nil.
 15567:   mParentWidget = nil;
 15567:   TearDownView(); // Safe if called twice.
     1: }
     1: 
 15919: NS_IMPL_ISUPPORTS_INHERITED1(nsChildView, nsBaseWidget, nsIPluginWidget)
     1: 
 33013: nsresult nsChildView::Create(nsIWidget *aParent,
 33013:                              nsNativeWidget aNativeParent,
 23738:                              const nsIntRect &aRect,
 68668:                              nsDeviceContext *aContext,
 33013:                              nsWidgetInitData *aInitData)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
 40740:   // Because the hidden window is created outside of an event loop,
 40740:   // we need to provide an autorelease pool to avoid leaking cocoa objects
 40740:   // (see bug 559075).
 40740:   nsAutoreleasePool localPool;
 40740: 
 24707:   // See NSView (MethodSwizzling) below.
 38435:   if (!gChildViewMethodsSwizzled) {
 24707:     nsToolkit::SwizzleMethods([NSView class], @selector(mouseDownCanMoveWindow),
 24707:                               @selector(nsChildView_NSView_mouseDownCanMoveWindow));
 76790: #ifdef __LP64__
 98723:     if (nsCocoaFeatures::OnLionOrLater()) {
 76790:       nsToolkit::SwizzleMethods([NSEvent class], @selector(addLocalMonitorForEventsMatchingMask:handler:),
 76790:                                 @selector(nsChildView_NSEvent_addLocalMonitorForEventsMatchingMask:handler:),
 79564:                                 true);
 76790:       nsToolkit::SwizzleMethods([NSEvent class], @selector(removeMonitor:),
 79564:                                 @selector(nsChildView_NSEvent_removeMonitor:), true);
 76790:     }
118918: #else
 74099:     TextInputHandler::SwizzleMethods();
 61078: #endif
 79564:     gChildViewMethodsSwizzled = true;
 24707:   }
 11675: 
     1:   mBounds = aRect;
     1: 
 80842:   // Ensure that the toolkit is created.
 80842:   nsToolkit::GetToolkit();
 80842: 
108460:   BaseCreate(aParent, aRect, aContext, aInitData);
     1: 
     1:   // inherit things from the parent view and create our parallel 
     1:   // NSView in the Cocoa display system
     1:   mParentView = nil;
     1:   if (aParent) {
 33013:     // This is the case when we're the popup content view of a popup window.
     1:     SetBackgroundColor(aParent->GetBackgroundColor());
     1:     SetForegroundColor(aParent->GetForegroundColor());
     1: 
     1:     // inherit the top-level window. NS_NATIVE_WIDGET is always a NSView
     1:     // regardless of if we're asking a window or a view (for compatibility
     1:     // with windows).
102475:     mParentView = (NSView<mozView>*)aParent->GetNativeData(NS_NATIVE_WIDGET); 
     1:     mParentWidget = aParent;   
 33013:   } else {
 33013:     // This is the normal case. When we're the root widget of the view hiararchy,
 33013:     // aNativeParent will be the contentView of our window, since that's what
 33013:     // nsCocoaWindow returns when asked for an NS_NATIVE_VIEW.
102475:     mParentView = reinterpret_cast<NSView<mozView>*>(aNativeParent);
 33013:   }
     1:   
     1:   // create our parallel NSView and hook it up to our parent. Recall
     1:   // that NS_NATIVE_WIDGET is the NSView.
115495:   CGFloat scaleFactor = nsCocoaUtils::GetBackingScaleFactor(mParentView);
115495:   NSRect r = nsCocoaUtils::DevPixelsToCocoaPoints(mBounds, scaleFactor);
102475:   mView = [(NSView<mozView>*)CreateCocoaView(r) retain];
115495:   if (!mView) {
115495:     return NS_ERROR_FAILURE;
115495:   }
     1: 
 37446:   [(ChildView*)mView setIsPluginView:(mWindowType == eWindowType_plugin)];
 37446: 
     1:   // If this view was created in a Gecko view hierarchy, the initial state
     1:   // is hidden.  If the view is attached only to a native NSView but has
     1:   // no Gecko parent (as in embedding), the initial state is visible.
     1:   if (mParentWidget)
     1:     [mView setHidden:YES];
     1:   else
 79564:     mVisible = true;
     1: 
     1:   // Hook it up in the NSView hierarchy.
     1:   if (mParentView) {
     1:     [mParentView addSubview:mView];
     1:   }
     1: 
     1:   // if this is a ChildView, make sure that our per-window data
     1:   // is set up
     1:   if ([mView isKindOfClass:[ChildView class]])
 29297:     [[WindowDataMap sharedWindowDataMap] ensureDataForWindow:[mView window]];
     1: 
 69465:   NS_ASSERTION(!mTextInputHandler, "mTextInputHandler has already existed");
 69465:   mTextInputHandler = new TextInputHandler(this, mView);
 33316: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
     1: // Creates the appropriate child view. Override to create something other than
     1: // our |ChildView| object. Autoreleases, so caller must retain.
     1: NSView*
     1: nsChildView::CreateCocoaView(NSRect inFrame)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
  6754:   return [[[ChildView alloc] initWithFrame:inFrame geckoChild:this] autorelease];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
     1: }
     1: 
     1: void nsChildView::TearDownView()
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
     1:   if (!mView)
     1:     return;
     1: 
     1:   NSWindow* win = [mView window];
     1:   NSResponder* responder = [win firstResponder];
     1: 
     1:   // We're being unhooked from the view hierarchy, don't leave our view
     1:   // or a child view as the window first responder.
     1:   if (responder && [responder isKindOfClass:[NSView class]] &&
     1:       [(NSView*)responder isDescendantOf:mView]) {
     1:     [win makeFirstResponder:[mView superview]];
     1:   }
     1: 
  2000:   // If mView is win's contentView, win (mView's NSWindow) "owns" mView --
  2000:   // win has retained mView, and will detach it from the view hierarchy and
  2000:   // release it when necessary (when win is itself destroyed (in a call to
  2000:   // [win dealloc])).  So all we need to do here is call [mView release] (to
  2000:   // match the call to [mView retain] in nsChildView::StandardCreate()).
  2000:   // Also calling [mView removeFromSuperviewWithoutNeedingDisplay] causes
  2000:   // mView to be released again and dealloced, while remaining win's
  2000:   // contentView.  So if we do that here, win will (for a short while) have
  2000:   // an invalid contentView (for the consequences see bmo bugs 381087 and
  2000:   // 374260).
  2000:   if ([mView isEqual:[win contentView]]) {
     1:     [mView release];
  2000:   } else {
  2000:     // Stop NSView hierarchy being changed during [ChildView drawRect:]
  2000:     [mView performSelectorOnMainThread:@selector(delayedTearDown) withObject:nil waitUntilDone:false];
  2000:   }
     1:   mView = nil;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
 31534: nsCocoaWindow*
 31534: nsChildView::GetXULWindowWidget()
 31534: {
 32510:   id windowDelegate = [[mView window] delegate];
 31534:   if (windowDelegate && [windowDelegate isKindOfClass:[WindowDelegate class]]) {
 31534:     return [(WindowDelegate *)windowDelegate geckoWidget];
 31534:   }
106838:   return nullptr;
 31534: }
 31534: 
     1: NS_IMETHODIMP nsChildView::Destroy()
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
     1:   if (mOnDestroyCalled)
     1:     return NS_OK;
 79564:   mOnDestroyCalled = true;
     1: 
     1:   [mView widgetDestroyed];
     1: 
     1:   nsBaseWidget::Destroy();
     1: 
108456:   NotifyWindowDestroyed();
     1:   mParentWidget = nil;
     1: 
     1:   TearDownView();
     1: 
 25875:   nsBaseWidget::OnDestroy();
 25875: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
     1: #pragma mark -
     1: 
     1: #if 0
     1: static void PrintViewHierarchy(NSView *view)
     1: {
     1:   while (view) {
     1:     NSLog(@"  view is %x, frame %@", view, NSStringFromRect([view frame]));
     1:     view = [view superview];
     1:   }
     1: }
     1: #endif
     1: 
     1: // Return native data according to aDataType
108991: void* nsChildView::GetNativeData(uint32_t aDataType)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSNULL;
 11978: 
106838:   void* retVal = nullptr;
     1: 
     1:   switch (aDataType) 
     1:   {
  6013:     case NS_NATIVE_WIDGET:
     1:     case NS_NATIVE_DISPLAY:
     1:       retVal = (void*)mView;
     1:       break;
     1: 
     1:     case NS_NATIVE_WINDOW:
 32510:       retVal = [mView window];
     1:       break;
     1: 
  6013:     case NS_NATIVE_GRAPHIC:
 31561:       NS_ERROR("Requesting NS_NATIVE_GRAPHIC on a Mac OS X child view!");
106838:       retVal = nullptr;
     1:       break;
     1: 
     1:     case NS_NATIVE_OFFSETX:
     1:       retVal = 0;
     1:       break;
     1: 
     1:     case NS_NATIVE_OFFSETY:
     1:       retVal = 0;
     1:       break;
     1: 
     1:     case NS_NATIVE_PLUGIN_PORT:
 30549:     case NS_NATIVE_PLUGIN_PORT_CG:
 30549:     {
 37446:       // The NP_CGContext pointer should always be NULL in the Cocoa event model.
 37446:       if ([(ChildView*)mView pluginEventModel] == NPEventModelCocoa)
106838:         return nullptr;
     1: 
 30549:       UpdatePluginPort();
 32799:       retVal = (void*)&mPluginCGContext;
     1:       break;
     1:     }
     1:   }
     1: 
     1:   return retVal;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL;
     1: }
     1: 
     1: #pragma mark -
     1: 
 16601: nsTransparencyMode nsChildView::GetTransparencyMode()
 16601: {
 34853:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 34853: 
 34853:   nsCocoaWindow* windowWidget = GetXULWindowWidget();
 34853:   return windowWidget ? windowWidget->GetTransparencyMode() : eTransparencyOpaque;
 34853: 
 34853:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(eTransparencyOpaque);
  9499: }
  9499: 
  9499: // This is called by nsContainerFrame on the root widget for all window types
 16601: // except popup windows (when nsCocoaWindow::SetTransparencyMode is used instead).
 16601: void nsChildView::SetTransparencyMode(nsTransparencyMode aMode)
 16601: {
 16601:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 16601: 
 34853:   nsCocoaWindow* windowWidget = GetXULWindowWidget();
 34853:   if (windowWidget) {
 34853:     windowWidget->SetTransparencyMode(aMode);
 16601:   }
 16601: 
 16601:   NS_OBJC_END_TRY_ABORT_BLOCK;
  9499: }
  9499: 
105772: bool nsChildView::IsVisible() const
105772: {
105772:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
     1:   if (!mVisible) {
105772:     return mVisible;
105772:   }
105772: 
     1:   // mVisible does not accurately reflect the state of a hidden tabbed view
     1:   // so verify that the view has a window as well
105772:   // then check native widget hierarchy visibility
105772:   return ([mView window] != nil) && !NSIsEmptyRect([mView visibleRect]);
105772: 
105772:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(false);
     1: }
     1: 
 14641: void nsChildView::HidePlugin()
 14641: {
 33357:   NS_ASSERTION(mWindowType == eWindowType_plugin,
 33357:                "HidePlugin called on non-plugin view");
 14641: }
 14641: 
 30549: void nsChildView::UpdatePluginPort()
 30549: {
 33357:   NS_ASSERTION(mWindowType == eWindowType_plugin,
 33357:                "UpdatePluginPort called on non-plugin view");
 30549: 
 30549:   // [NSGraphicsContext currentContext] is supposed to "return the
 30549:   // current graphics context of the current thread."  But sometimes
 30549:   // (when called while mView isn't focused for drawing) it returns a
 30549:   // graphics context for the wrong window.  [window graphicsContext]
 30549:   // (which "provides the graphics context associated with the window
 30549:   // for the current thread") seems always to return the "right"
 30549:   // graphics context.  See bug 500130.
 32799:   mPluginCGContext.context = NULL;
 32799:   mPluginCGContext.window = NULL;
 32120: }
 30549: 
 14641: static void HideChildPluginViews(NSView* aView)
 14641: {
 14641:   NSArray* subviews = [aView subviews];
 14641: 
 14641:   for (unsigned int i = 0; i < [subviews count]; ++i) {
 14641:     NSView* view = [subviews objectAtIndex: i];
 14641: 
 14641:     if (![view isKindOfClass:[ChildView class]])
 14641:       continue;
 14641: 
 14641:     ChildView* childview = static_cast<ChildView*>(view);
 14641:     if ([childview isPluginView]) {
 14641:       nsChildView* widget = static_cast<nsChildView*>([childview widget]);
 14641:       if (widget) {
 14641:         widget->HidePlugin();
 14641:       }
 14641:     } else {
 14641:       HideChildPluginViews(view);
 14641:     }
 14641:   }
 14641: }
 14641: 
     1: // Hide or show this component
 79445: NS_IMETHODIMP nsChildView::Show(bool aState)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
     1:   if (aState != mVisible) {
 40740:     // Provide an autorelease pool because this gets called during startup
 40740:     // on the "hidden window", resulting in cocoa object leakage if there's
 40740:     // no pool in place.
 40740:     nsAutoreleasePool localPool;
 40740: 
     1:     [mView setHidden:!aState];
     1:     mVisible = aState;
 52100:     if (!mVisible && IsPluginView())
 52100:       HidePlugin();
     1:   }
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
 27679: // Change the parent of this widget
 21041: NS_IMETHODIMP
 21041: nsChildView::SetParent(nsIWidget* aNewParent)
 21041: {
 21041:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 21041: 
 54312:   if (mOnDestroyCalled)
 54312:     return NS_OK;
 54312: 
 54312:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
 54312:   
 82580:   if (mParentWidget) {
 54312:     mParentWidget->RemoveChild(this);
 82580:   }
 82580: 
 82580:   if (aNewParent) {
 82580:     ReparentNativeWidget(aNewParent);
 82580:   } else {
 82580:     [mView removeFromSuperview];
 82580:     mParentView = nil;
 82580:   }
 82580: 
 54312:   mParentWidget = aNewParent;
 54312: 
 82580:   if (mParentWidget) {
 54312:     mParentWidget->AddChild(this);
 82580:   }
 82580: 
 54312:   return NS_OK;
 54312: 
 54312:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 54312: }
 54312: 
 54312: NS_IMETHODIMP
 54312: nsChildView::ReparentNativeWidget(nsIWidget* aNewParent)
 54312: {
 54312:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 54312: 
 54312:   NS_PRECONDITION(aNewParent, "");
 54312: 
 54312:   if (mOnDestroyCalled)
 54312:     return NS_OK;
 54312: 
 21041:   NSView<mozView>* newParentView =
102475:    (NSView<mozView>*)aNewParent->GetNativeData(NS_NATIVE_WIDGET); 
 21041:   NS_ENSURE_TRUE(newParentView, NS_ERROR_FAILURE);
 21041: 
 21041:   // we hold a ref to mView, so this is safe
 21041:   [mView removeFromSuperview];
 21041:   mParentView = newParentView;
 21041:   [mParentView addSubview:mView];
 21041:   return NS_OK;
 21041: 
 21041:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 21041: }
     1: 
 27679: void nsChildView::ResetParent()
 27679: {
 27679:   if (!mOnDestroyCalled) {
 27679:     if (mParentWidget)
 27679:       mParentWidget->RemoveChild(this);
 27679:     if (mView)
 27679:       [mView removeFromSuperview];
 27679:   }
106838:   mParentWidget = nullptr;
 27679: }
 27679: 
 20723: nsIWidget*
 41321: nsChildView::GetParent()
     1: {
     1:   return mParentWidget;
     1: }
     1: 
 50783: float
 50783: nsChildView::GetDPI()
 50783: {
 50783:   NSWindow* window = [mView window];
 50873:   if (window && [window isKindOfClass:[BaseWindow class]]) {
 50873:     return [(BaseWindow*)window getDPI];
 50873:   }
 50873: 
 50873:   return 96.0;
 50783: }
 50783: 
 79445: NS_IMETHODIMP nsChildView::Enable(bool aState)
     1: {
     1:   return NS_OK;
     1: }
     1: 
106103: bool nsChildView::IsEnabled() const
106103: {
106103:   return true;
     1: }
     1: 
 79445: NS_IMETHODIMP nsChildView::SetFocus(bool aRaise)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
     1:   NSWindow* window = [mView window];
 29018:   if (window)
 29018:     [window makeFirstResponder:mView];
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
     1: // Override to set the cursor on the mac
     1: NS_IMETHODIMP nsChildView::SetCursor(nsCursor aCursor)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
 39094:   if ([mView isDragInProgress])
 39094:     return NS_OK; // Don't change the cursor during dragging.
 39094: 
     1:   nsBaseWidget::SetCursor(aCursor);
 39278:   return [[nsCursorManager sharedInstance] setCursor:aCursor];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
     1: // implement to fix "hidden virtual function" warning
     1: NS_IMETHODIMP nsChildView::SetCursor(imgIContainer* aCursor,
108991:                                       uint32_t aHotspotX, uint32_t aHotspotY)
     1: {
 39278:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 39278: 
 39278:   nsBaseWidget::SetCursor(aCursor, aHotspotX, aHotspotY);
 39278:   return [[nsCursorManager sharedInstance] setCursorWithImage:aCursor hotSpotX:aHotspotX hotSpotY:aHotspotY];
 39278: 
 39278:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
     1: #pragma mark -
     1: 
     1: // Get this component dimension
 23738: NS_IMETHODIMP nsChildView::GetBounds(nsIntRect &aRect)
     1: {
 54180:   if (!mView) {
     1:     aRect = mBounds;
 54180:   } else {
115495:     aRect = CocoaPointsToDevPixels([mView frame]);
 54180:   }
     1:   return NS_OK;
     1: }
     1: 
128334: NS_IMETHODIMP nsChildView::GetClientBounds(nsIntRect &aRect)
128334: {
128334:   GetBounds(aRect);
128334:   if (!mParentWidget) {
128334:     // For top level widgets we want the position on screen, not the position
128334:     // of this view inside the window.
128334:     MOZ_ASSERT(mWindowType != eWindowType_plugin, "plugin widgets should have parents");
128334:     aRect.MoveTo(WidgetToScreenOffset());
128334:   }
128334:   return NS_OK;
128334: }
128334: 
115495: double
120488: nsChildView::GetDefaultScaleInternal()
115495: {
115495:   return BackingScaleFactor();
115495: }
115495: 
115495: CGFloat
115495: nsChildView::BackingScaleFactor()
115495: {
115495:   if (mBackingScaleFactor > 0.0) {
115495:     return mBackingScaleFactor;
115495:   }
115495:   if (!mView) {
115495:     return 1.0;
115495:   }
115495:   mBackingScaleFactor = nsCocoaUtils::GetBackingScaleFactor(mView);
115495:   return mBackingScaleFactor;
115495: }
115495: 
119103: void
119103: nsChildView::BackingScaleFactorChanged()
119103: {
119103:   CGFloat newScale = nsCocoaUtils::GetBackingScaleFactor(mView);
119103: 
119103:   // ignore notification if it hasn't really changed (or maybe we have
119103:   // disabled HiDPI mode via prefs)
119103:   if (mBackingScaleFactor == newScale) {
119103:     return;
119103:   }
119103: 
119103:   mBackingScaleFactor = newScale;
119103: 
119106:   if (mWidgetListener && !mWidgetListener->GetXULWindow()) {
119103:     nsIPresShell* presShell = mWidgetListener->GetPresShell();
119103:     if (presShell) {
119103:       presShell->BackingScaleFactorChanged();
119103:     }
119103:   }
119103: 
119106:   if (IsPluginView()) {
119106:     nsEventStatus status = nsEventStatus_eIgnore;
119106:     nsGUIEvent guiEvent(true, NS_PLUGIN_RESOLUTION_CHANGED, this);
119106:     guiEvent.time = PR_IntervalNow();
119106:     DispatchEvent(&guiEvent, status);
119106:   }
119106: }
119106: 
 79445: NS_IMETHODIMP nsChildView::ConstrainPosition(bool aAllowSlop,
108991:                                              int32_t *aX, int32_t *aY)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: // Move this component, aX and aY are in the parent widget coordinate system
125634: NS_IMETHODIMP nsChildView::Move(double aX, double aY)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
125634:   int32_t x = NSToIntRound(aX);
125634:   int32_t y = NSToIntRound(aY);
125634: 
125634:   if (!mView || (mBounds.x == x && mBounds.y == y))
  7635:     return NS_OK;
  7635: 
125634:   mBounds.x = x;
125634:   mBounds.y = y;
     1: 
115495:   [mView setFrame:DevPixelsToCocoaPoints(mBounds)];
     1: 
  7635:   if (mVisible)
     1:     [mView setNeedsDisplay:YES];
     1: 
120177:   NotifyRollupGeometryChange();
     1:   ReportMoveEvent();
  7635: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
125634: NS_IMETHODIMP nsChildView::Resize(double aWidth, double aHeight, bool aRepaint)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
125634:   int32_t width = NSToIntRound(aWidth);
125634:   int32_t height = NSToIntRound(aHeight);
125634: 
125634:   if (!mView || (mBounds.width == width && mBounds.height == height))
  7635:     return NS_OK;
  7635: 
125634:   mBounds.width  = width;
125634:   mBounds.height = height;
     1: 
115495:   [mView setFrame:DevPixelsToCocoaPoints(mBounds)];
     1: 
     1:   if (mVisible && aRepaint)
     1:     [mView setNeedsDisplay:YES];
     1: 
120177:   NotifyRollupGeometryChange();
     1:   ReportSizeEvent();
     1: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
125634: NS_IMETHODIMP nsChildView::Resize(double aX, double aY,
125634:                                   double aWidth, double aHeight, bool aRepaint)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
125634:   int32_t x = NSToIntRound(aX);
125634:   int32_t y = NSToIntRound(aY);
125634:   int32_t width = NSToIntRound(aWidth);
125634:   int32_t height = NSToIntRound(aHeight);
125634: 
125634:   BOOL isMoving = (mBounds.x != x || mBounds.y != y);
125634:   BOOL isResizing = (mBounds.width != width || mBounds.height != height);
  7635:   if (!mView || (!isMoving && !isResizing))
  7635:     return NS_OK;
  7635: 
  7635:   if (isMoving) {
125634:     mBounds.x = x;
125634:     mBounds.y = y;
  7635:   }
  7635:   if (isResizing) {
125634:     mBounds.width  = width;
125634:     mBounds.height = height;
  7635:   }
  7635: 
115495:   [mView setFrame:DevPixelsToCocoaPoints(mBounds)];
  7635: 
  7635:   if (mVisible && aRepaint)
  7635:     [mView setNeedsDisplay:YES];
  7635: 
120177:   NotifyRollupGeometryChange();
 10305:   if (isMoving) {
  7635:     ReportMoveEvent();
 10305:     if (mOnDestroyCalled)
 10305:       return NS_OK;
 10305:   }
  7635:   if (isResizing)
  7635:     ReportSizeEvent();
  7635: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
108991: static const int32_t resizeIndicatorWidth = 15;
108991: static const int32_t resizeIndicatorHeight = 15;
 79445: bool nsChildView::ShowsResizeIndicator(nsIntRect* aResizerRect)
 16520: {
 16520:   NSView *topLevelView = mView, *superView = nil;
 17108:   while ((superView = [topLevelView superview]))
 16520:     topLevelView = superView;
 16520: 
 32298:   if (![[topLevelView window] showsResizeIndicator] ||
 32298:       !([[topLevelView window] styleMask] & NSResizableWindowMask))
 79564:     return false;
 16520: 
 16520:   if (aResizerRect) {
 16520:     NSSize bounds = [topLevelView bounds].size;
 16520:     NSPoint corner = NSMakePoint(bounds.width, [topLevelView isFlipped] ? bounds.height : 0);
 16520:     corner = [topLevelView convertPoint:corner toView:mView];
 16520:     aResizerRect->SetRect(NSToIntRound(corner.x) - resizeIndicatorWidth,
 16520:                           NSToIntRound(corner.y) - resizeIndicatorHeight,
 16520:                           resizeIndicatorWidth, resizeIndicatorHeight);
 16520:   }
 79564:   return true;
 16520: }
 16520: 
 24684: // In QuickDraw mode the coordinate system used here should be that of the
 24684: // browser window's content region (defined as everything but the 22-pixel
 24684: // high titlebar).  But in CoreGraphics mode the coordinate system should be
 24684: // that of the browser window as a whole (including its titlebar).  Both
 24684: // coordinate systems have a top-left origin.  See bmo bug 474491.
 24684: //
 24684: // There's a bug in this method's code -- it currently uses the QuickDraw
 24684: // coordinate system for both the QuickDraw and CoreGraphics drawing modes.
 24684: // This bug is fixed by the patch for bug 474491.  But the Flash plugin (both
 24684: // version 10.0.12.36 from Adobe and version 9.0 r151 from Apple) has Mozilla-
 24684: // specific code to work around this bug, which breaks when we fix it (see bmo
 24684: // bug 477077).  So we'll need to coordinate releasing a fix for this bug with
 24684: // Adobe and other major plugin vendors that support the CoreGraphics mode.
127546: //
127546: // outClipRect and outOrigin are in display pixels, not device pixels.
 79445: NS_IMETHODIMP nsChildView::GetPluginClipRect(nsIntRect& outClipRect, nsIntPoint& outOrigin, bool& outWidgetVisible)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
 33357:   NS_ASSERTION(mWindowType == eWindowType_plugin,
 33357:                "GetPluginClipRect must only be called on a plugin widget");
 33357:   if (mWindowType != eWindowType_plugin) return NS_ERROR_FAILURE;
     1:   
 32510:   NSWindow* window = [mView window];
     1:   if (!window) return NS_ERROR_FAILURE;
     1:   
     1:   NSPoint viewOrigin = [mView convertPoint:NSZeroPoint toView:nil];
 24681:   NSRect frame = [[window contentView] frame];
     1:   viewOrigin.y = frame.size.height - viewOrigin.y;
     1:   
     1:   // set up the clipping region for plugins.
     1:   NSRect visibleBounds = [mView visibleRect];
     1:   NSPoint clipOrigin   = [mView convertPoint:visibleBounds.origin toView:nil];
     1:   
 24681:   // Convert from cocoa to QuickDraw coordinates
     1:   clipOrigin.y = frame.size.height - clipOrigin.y;
     1:   
 23738:   outClipRect.x = NSToIntRound(clipOrigin.x);
 23738:   outClipRect.y = NSToIntRound(clipOrigin.y);
     1: 
 30515:   // need to convert view's origin to window coordinates.
 30515:   // then, encode as "SetOrigin" ready values.
 30515:   outOrigin.x = -NSToIntRound(viewOrigin.x);
 30515:   outOrigin.y = -NSToIntRound(viewOrigin.y);
     1: 
105772:   if (IsVisible() && [mView window] != nil) {
 23738:     outClipRect.width  = NSToIntRound(visibleBounds.origin.x + visibleBounds.size.width) - NSToIntRound(visibleBounds.origin.x);
 23738:     outClipRect.height = NSToIntRound(visibleBounds.origin.y + visibleBounds.size.height) - NSToIntRound(visibleBounds.origin.y);
 30515: 
 30515:     if (mClipRects) {
 30515:       nsIntRect clipBounds;
108991:       for (uint32_t i = 0; i < mClipRectCount; ++i) {
127546:         NSRect cocoaPoints = DevPixelsToCocoaPoints(mClipRects[i]);
127546:         clipBounds.UnionRect(clipBounds, nsIntRect(NSToIntRound(cocoaPoints.origin.x),
127546:                                                    NSToIntRound(cocoaPoints.origin.y),
127546:                                                    NSToIntRound(cocoaPoints.size.width),
127546:                                                    NSToIntRound(cocoaPoints.size.height)));
 30515:       }
 30515:       outClipRect.IntersectRect(outClipRect, clipBounds - outOrigin);
 30515:     }
 30515: 
 30515:     // XXXroc should this be !outClipRect.IsEmpty()?
 79564:     outWidgetVisible = true;
     1:   }
     1:   else {
     1:     outClipRect.width = 0;
     1:     outClipRect.height = 0;
 79564:     outWidgetVisible = false;
     1:   }
     1: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
     1: NS_IMETHODIMP nsChildView::StartDrawPlugin()
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
 33357:   NS_ASSERTION(mWindowType == eWindowType_plugin,
 33357:                "StartDrawPlugin must only be called on a plugin widget");
 33357:   if (mWindowType != eWindowType_plugin) return NS_ERROR_FAILURE;
   130: 
110791:   // This code is necessary for CoreGraphics in 32-bit builds.
 32120:   // See comments below about why. In 64-bit CoreGraphics mode we will not keep
 32120:   // this region up to date, plugins should not depend on it.
 32120: #ifndef __LP64__
 32510:   NSWindow* window = [mView window];
     1:   if (!window)
     1:     return NS_ERROR_FAILURE;
     1: 
110791:   // In QuickDraw drawing mode we used to prevent reentrant handling of any
110791:   // plugin event. But in CoreGraphics drawing mode only do this if the current
 32019:   // plugin event isn't an update/paint event.  This allows popupcontextmenu()
 32019:   // to work properly from a plugin that supports the Cocoa event model,
 32019:   // without regressing bug 409615.  See bug 435041.  (StartDrawPlugin() and
 32019:   // EndDrawPlugin() wrap every call to nsIPluginInstance::HandleEvent() --
 32019:   // not just calls that "draw" or paint.)
110791:   if (mIsDispatchPaint && mPluginDrawing) {
 32019:     return NS_ERROR_FAILURE;
 32019:   }
 32019: 
     1:   // It appears that the WindowRef from which we get the plugin port undergoes the
     1:   // traditional BeginUpdate/EndUpdate cycle, which, if you recall, sets the visible
     1:   // region to the intersection of the visible region and the update region. Since
     1:   // we don't know here if we're being drawn inside a BeginUpdate/EndUpdate pair
     1:   // (which seem to occur in [NSWindow display]), and we don't want to have the burden
     1:   // of correctly doing Carbon invalidates of the plugin rect, we manually set the
 14027:   // visible region to be the entire port every time. It is necessary to set up our
 14027:   // window's port even for CoreGraphics plugins, because they may still use Carbon
 14027:   // internally (see bug #420527 for details).
 71609:   //
 71609:   // Don't use this code if any of the QuickDraw APIs it currently requires are
 71609:   // missing (as they probably will be on OS X 10.8 and up).
 71609:   if (::NewRgn && ::GetQDGlobalsThePort && ::GetGWorld && ::SetGWorld &&
 71609:       ::IsPortOffscreen && ::GetMainDevice && ::SetOrigin && ::RectRgn &&
 71609:       ::SetPortVisibleRegion && ::SetPortClipRegion && ::DisposeRgn) {
     1:     RgnHandle pluginRegion = ::NewRgn();
     1:     if (pluginRegion) {
110791:       CGrafPtr port = ::GetWindowPort(WindowRef([window windowRef]));
 79445:       bool portChanged = (port != CGrafPtr(::GetQDGlobalsThePort()));
     1:       CGrafPtr oldPort;
     1:       GDHandle oldDevice;
     1: 
     1:       if (portChanged) {
     1:         ::GetGWorld(&oldPort, &oldDevice);
106838:         ::SetGWorld(port, ::IsPortOffscreen(port) ? nullptr : ::GetMainDevice());
     1:       }
     1: 
     1:       ::SetOrigin(0, 0);
     1: 
 23738:       nsIntRect clipRect; // this is in native window coordinates
 23738:       nsIntPoint origin;
 79445:       bool visible;
     1:       GetPluginClipRect(clipRect, origin, visible);
     1: 
     1:       // XXX if we're not visible, set an empty clip region?
     1:       Rect pluginRect;
     1:       ConvertGeckoRectToMacRect(clipRect, pluginRect);
     1: 
     1:       ::RectRgn(pluginRegion, &pluginRect);
 14027:       ::SetPortVisibleRegion(port, pluginRegion);
 14027:       ::SetPortClipRegion(port, pluginRegion);
     1: 
     1:       // now set up the origin for the plugin
     1:       ::SetOrigin(origin.x, origin.y);
     1: 
     1:       ::DisposeRgn(pluginRegion);
     1: 
 71609:       if (portChanged) {
     1:         ::SetGWorld(oldPort, oldDevice);
     1:       }
 71609:     }
 71609:   }
 32120: #endif
     1: 
 79564:   mPluginDrawing = true;
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
     1: NS_IMETHODIMP nsChildView::EndDrawPlugin()
     1: {
 33357:   NS_ASSERTION(mWindowType == eWindowType_plugin,
 33357:                "EndDrawPlugin must only be called on a plugin widget");
 33357:   if (mWindowType != eWindowType_plugin) return NS_ERROR_FAILURE;
   130: 
 79564:   mPluginDrawing = false;
     1:   return NS_OK;
     1: }
     1: 
 14641: NS_IMETHODIMP nsChildView::SetPluginInstanceOwner(nsIPluginInstanceOwner* aInstanceOwner)
 14641: {
 14641:   mPluginInstanceOwner = aInstanceOwner;
 14641: 
 14641:   return NS_OK;
 14641: }
 14641: 
 32019: NS_IMETHODIMP nsChildView::SetPluginEventModel(int inEventModel)
 32019: {
 32120:   [(ChildView*)mView setPluginEventModel:(NPEventModel)inEventModel];
 32019:   return NS_OK;
 32019: }
 32019: 
 32019: NS_IMETHODIMP nsChildView::GetPluginEventModel(int* outEventModel)
 32019: {
 32120:   *outEventModel = [(ChildView*)mView pluginEventModel];
 32019:   return NS_OK;
 32019: }
 32019: 
 54248: NS_IMETHODIMP nsChildView::SetPluginDrawingModel(int inDrawingModel)
 54248: {
 54248:   [(ChildView*)mView setPluginDrawingModel:(NPDrawingModel)inDrawingModel];
 54248:   return NS_OK;
 54248: }
 54248: 
 43436: NS_IMETHODIMP nsChildView::StartComplexTextInputForCurrentEvent()
 43436: {
 74099:   return mTextInputHandler->StartComplexTextInputForCurrentEvent();
 43436: }
 43436: 
108991: nsresult nsChildView::SynthesizeNativeKeyEvent(int32_t aNativeKeyboardLayout,
108991:                                                int32_t aNativeKeyCode,
108991:                                                uint32_t aModifierFlags,
 14962:                                                const nsAString& aCharacters,
 14962:                                                const nsAString& aUnmodifiedCharacters)
 14962: {
 74097:   return mTextInputHandler->SynthesizeNativeKeyEvent(aNativeKeyboardLayout,
 74097:                                                      aNativeKeyCode,
 74097:                                                      aModifierFlags,
 74097:                                                      aCharacters,
 74097:                                                      aUnmodifiedCharacters);
 14962: }
     1: 
 32976: nsresult nsChildView::SynthesizeNativeMouseEvent(nsIntPoint aPoint,
108991:                                                  uint32_t aNativeMessage,
108991:                                                  uint32_t aModifierFlags)
 32976: {
 32976:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 32976: 
128447:   NSPoint pt =
128447:     nsCocoaUtils::DevPixelsToCocoaPoints(aPoint, BackingScaleFactor());
128447: 
 32976:   // Move the mouse cursor to the requested position and reconnect it to the mouse.
128447:   CGWarpMouseCursorPosition(NSPointToCGPoint(pt));
 32976:   CGAssociateMouseAndMouseCursorPosition(true);
 32976: 
 32976:   // aPoint is given with the origin on the top left, but convertScreenToBase
 32976:   // expects a point in a coordinate system that has its origin on the bottom left.
128447:   NSPoint screenPoint = NSMakePoint(pt.x, nsCocoaUtils::FlippedScreenY(pt.y));
 32976:   NSPoint windowPoint = [[mView window] convertScreenToBase:screenPoint];
 32976: 
 34069:   NSEvent* event = [NSEvent mouseEventWithType:aNativeMessage
 32976:                                       location:windowPoint
 32976:                                  modifierFlags:aModifierFlags
 32976:                                      timestamp:[NSDate timeIntervalSinceReferenceDate]
 32976:                                   windowNumber:[[mView window] windowNumber]
 32976:                                        context:nil
 32976:                                    eventNumber:0
 32976:                                     clickCount:1
 32976:                                       pressure:0.0];
 32976: 
 32976:   if (!event)
 32976:     return NS_ERROR_FAILURE;
 32976: 
 75223:   if ([[mView window] isKindOfClass:[BaseWindow class]]) {
 75223:     // Tracking area events don't end up in their tracking areas when sent
 75223:     // through [NSApp sendEvent:], so pass them directly to the right methods.
 75223:     BaseWindow* window = (BaseWindow*)[mView window];
 75223:     if (aNativeMessage == NSMouseEntered) {
 75223:       [window mouseEntered:event];
 75223:       return NS_OK;
 75223:     }
 75223:     if (aNativeMessage == NSMouseExited) {
 75223:       [window mouseExited:event];
 75223:       return NS_OK;
 75223:     }
 75223:     if (aNativeMessage == NSMouseMoved) {
 75223:       [window mouseMoved:event];
 75223:       return NS_OK;
 75223:     }
 75223:   }
 75223: 
 32976:   [NSApp sendEvent:event];
 32976:   return NS_OK;
 32976: 
 32976:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 32976: }
 32976: 
 21081: // First argument has to be an NSMenu representing the application's top-level
 21081: // menu bar. The returned item is *not* retained.
 21081: static NSMenuItem* NativeMenuItemWithLocation(NSMenu* menubar, NSString* locationString)
 21081: {
 21081:   NSArray* indexes = [locationString componentsSeparatedByString:@"|"];
 15578:   unsigned int indexCount = [indexes count];
 15578:   if (indexCount == 0)
 21081:     return nil;
 15578: 
 15578:   NSMenu* currentSubmenu = [NSApp mainMenu];
 21081:   for (unsigned int i = 0; i < indexCount; i++) {
 15578:     int targetIndex;
 15578:     // We remove the application menu from consideration for the top-level menu
 15578:     if (i == 0)
 15578:       targetIndex = [[indexes objectAtIndex:i] intValue] + 1;
 15578:     else
 15578:       targetIndex = [[indexes objectAtIndex:i] intValue];
 15578:     int itemCount = [currentSubmenu numberOfItems];
 15578:     if (targetIndex < itemCount) {
 15578:       NSMenuItem* menuItem = [currentSubmenu itemAtIndex:targetIndex];
 21081:       // if this is the last index just return the menu item
 21081:       if (i == (indexCount - 1))
 21081:         return menuItem;
 21081:       // if this is not the last index find the submenu and keep going
 15578:       if ([menuItem hasSubmenu])
 21081:         currentSubmenu = [menuItem submenu];
 15578:       else
 21081:         return nil;
 21081:     }
 21081:   }
 21081: 
 21081:   return nil;
 21081: }
 21081: 
 21081: // Used for testing native menu system structure and event handling.
 21081: NS_IMETHODIMP nsChildView::ActivateNativeMenuItemAt(const nsAString& indexString)
 21081: {
 21081:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 21081: 
 21081:   NSString* locationString = [NSString stringWithCharacters:indexString.BeginReading() length:indexString.Length()];
 21081:   NSMenuItem* item = NativeMenuItemWithLocation([NSApp mainMenu], locationString);
 16264:   // We can't perform an action on an item with a submenu, that will raise
 16264:   // an obj-c exception.
 21081:   if (item && ![item hasSubmenu]) {
 21081:     NSMenu* parent = [item menu];
 21081:     if (parent) {
 15578:       // NSLog(@"Performing action for native menu item titled: %@\n",
 15578:       //       [[currentSubmenu itemAtIndex:targetIndex] title]);
 21081:       [parent performActionForItemAtIndex:[parent indexOfItem:item]];
 21081:       return NS_OK;
 21081:     }
 21081:   }
 15578:   return NS_ERROR_FAILURE;
 16264: 
 16264:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 16264: }
 16264: 
 21081: // Used for testing native menu system structure and event handling.
 21081: NS_IMETHODIMP nsChildView::ForceUpdateNativeMenuAt(const nsAString& indexString)
 21081: {
 21081:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 21081: 
 31534:   nsCocoaWindow *widget = GetXULWindowWidget();
 16264:   if (widget) {
 16264:     nsMenuBarX* mb = widget->GetMenuBar();
 16264:     if (mb) {
 21081:       if (indexString.IsEmpty())
 16264:         mb->ForceNativeMenuReload();
 21081:       else
 21081:         mb->ForceUpdateNativeMenuAt(indexString);
 21081:     }
 21081:   }
 16264:   return NS_OK;
 21081: 
 21081:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 16264: }
 16264: 
     1: #pragma mark -
     1: 
     1: #ifdef INVALIDATE_DEBUGGING
     1: 
     1: static Boolean KeyDown(const UInt8 theKey)
     1: {
     1:   KeyMap map;
     1:   GetKeys(map);
     1:   return ((*((UInt8 *)map + (theKey >> 3)) >> (theKey & 7)) & 1) != 0;
     1: }
     1: 
     1: static Boolean caps_lock()
     1: {
     1:   return KeyDown(0x39);
     1: }
     1: 
     1: static void blinkRect(Rect* r)
     1: {
     1:   StRegionFromPool oldClip;
     1:   if (oldClip != NULL)
     1:     ::GetClip(oldClip);
     1: 
     1:   ::ClipRect(r);
     1:   ::InvertRect(r);
     1:   UInt32 end = ::TickCount() + 5;
     1:   while (::TickCount() < end) ;
     1:   ::InvertRect(r);
     1: 
     1:   if (oldClip != NULL)
     1:     ::SetClip(oldClip);
     1: }
     1: 
     1: static void blinkRgn(RgnHandle rgn)
     1: {
     1:   StRegionFromPool oldClip;
     1:   if (oldClip != NULL)
     1:     ::GetClip(oldClip);
     1: 
     1:   ::SetClip(rgn);
     1:   ::InvertRgn(rgn);
     1:   UInt32 end = ::TickCount() + 5;
     1:   while (::TickCount() < end) ;
     1:   ::InvertRgn(rgn);
     1: 
     1:   if (oldClip != NULL)
     1:     ::SetClip(oldClip);
     1: }
     1: 
     1: #endif
     1: 
     1: // Invalidate this component's visible area
 87336: NS_IMETHODIMP nsChildView::Invalidate(const nsIntRect &aRect)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
     1:   if (!mView || !mVisible)
     1:     return NS_OK;
     1: 
 87336:   if ([NSView focusView]) {
     1:     // if a view is focussed (i.e. being drawn), then postpone the invalidate so that we
     1:     // don't lose it.
115495:     [mView setNeedsPendingDisplayInRect:DevPixelsToCocoaPoints(aRect)];
     1:   }
     1:   else {
115495:     [mView setNeedsDisplayInRect:DevPixelsToCocoaPoints(aRect)];
     1:   }
     1: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
 79445: bool
122281: nsChildView::ComputeShouldAccelerate(bool aDefault)
 54780: {
 62139:   // Don't use OpenGL for transparent windows or for popup windows.
 62139:   if (!mView || ![[mView window] isOpaque] ||
 62139:       [[mView window] isKindOfClass:[PopupWindow class]])
 79564:     return false;
 54780: 
122281:   return nsBaseWidget::ComputeShouldAccelerate(aDefault);
 54780: }
 54780: 
101913: bool
101913: nsChildView::UseOffMainThreadCompositing()
101913: {
101913:   // OMTC doesn't work with Basic Layers on OS X right now. Once it works, we'll
101913:   // still want to disable it for certain kinds of windows (e.g. popups).
122281:   return nsBaseWidget::UseOffMainThreadCompositing() &&
122281:          ComputeShouldAccelerate(mUseLayersAcceleration);
101913: }
101913: 
108991: inline uint16_t COLOR8TOCOLOR16(uint8_t color8)
     1: {
     1:   // return (color8 == 0xFF ? 0xFFFF : (color8 << 8));
     1:   return (color8 << 8) | color8;  /* (color8 * 257) == (color8 * 0x0101) */
     1: }
     1: 
     1: #pragma mark -
     1: 
 55293: nsresult nsChildView::ConfigureChildren(const nsTArray<Configuration>& aConfigurations)
 55293: {
108991:   for (uint32_t i = 0; i < aConfigurations.Length(); ++i) {
 55293:     const Configuration& config = aConfigurations[i];
 55293:     nsChildView* child = static_cast<nsChildView*>(config.mChild);
 30515: #ifdef DEBUG
 30515:     nsWindowType kidType;
 55293:     child->GetWindowType(kidType);
 30515: #endif
 52100:     NS_ASSERTION(kidType == eWindowType_plugin,
 52100:                  "Configured widget is not a plugin type");
 55293:     NS_ASSERTION(child->GetParent() == this,
 30515:                  "Configured widget is not a child of the right widget");
 52100: 
 52100:     // nsIWidget::Show() doesn't get called on plugin widgets unless we call
 52100:     // it from here.  See bug 592563.
 55293:     child->Show(!config.mClipRegion.IsEmpty());
 52100: 
 52100:     child->Resize(
 55293:         config.mBounds.x, config.mBounds.y,
 55293:         config.mBounds.width, config.mBounds.height,
110791:         false);
 52100: 
 52100:     // Store the clip region here in case GetPluginClipRect needs it.
 55293:     child->StoreWindowClipRegion(config.mClipRegion);
 30515:   }
 30515:   return NS_OK;
 30515: }
 30515: 
  6118: // Invokes callback and ProcessEvent methods on Event Listener object
     1: NS_IMETHODIMP nsChildView::DispatchEvent(nsGUIEvent* event, nsEventStatus& aStatus)
     1: {
 12976: #ifdef DEBUG
110974:   debug_DumpEvent(stdout, event->widget, event, nsAutoCString("something"), 0);
 12976: #endif
 12976: 
 69465:   NS_ASSERTION(!(mTextInputHandler && mTextInputHandler->IsIMEComposing() &&
 69465:                  NS_IS_KEY_EVENT(event)),
 22410:     "Any key events should not be fired during IME composing");
 22410: 
     1:   aStatus = nsEventStatus_eIgnore;
     1: 
108460:   nsIWidgetListener* listener = mWidgetListener;
108460: 
108460:   // If the listener is NULL, check if the parent is a popup. If it is, then
108460:   // this child is the popup content view attached to a popup. Get the
108460:   // listener from the parent popup instead.
 29942:   nsCOMPtr<nsIWidget> kungFuDeathGrip = do_QueryInterface(mParentWidget ? mParentWidget : this);
108460:   if (!listener && mParentWidget) {
     1:     nsWindowType type;
     1:     mParentWidget->GetWindowType(type);
     1:     if (type == eWindowType_popup) {
108460:       // Check just in case event->widget isn't this widget
  4173:       if (event->widget)
108457:         listener = event->widget->GetWidgetListener();
108460:       if (!listener) {
     1:         event->widget = mParentWidget;
108460:         listener = mParentWidget->GetWidgetListener();
108460:       }
108460:     }
108460:   }
108460: 
108460:   if (listener)
108460:     aStatus = listener->HandleEvent(event, mUseAttachedEvents);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: bool nsChildView::DispatchWindowEvent(nsGUIEvent &event)
     1: {
     1:   nsEventStatus status;
     1:   DispatchEvent(&event, status);
     1:   return ConvertStatus(status);
     1: }
     1: 
118896: bool nsChildView::PaintWindow(nsIntRegion aRegion, bool aIsAlternate)
108457: {
108457:   nsIWidget* widget = this;
108457:   nsIWidgetListener* listener = mWidgetListener;
108457: 
108457:   // If there is no listener, use the parent popup's listener if that exists.
108457:   if (!listener && mParentWidget) {
108457:     nsWindowType type;
108457:     mParentWidget->GetWindowType(type);
108457:     if (type == eWindowType_popup) {
108457:       widget = mParentWidget;
108457:       listener = mParentWidget->GetWidgetListener();
108457:     }
108457:   }
108457: 
108457:   if (!listener)
108457:     return false;
108457: 
108457:   bool returnValue = false;
108457:   bool oldDispatchPaint = mIsDispatchPaint;
108457:   mIsDispatchPaint = true;
118896:   uint32_t flags = nsIWidgetListener::SENT_WILL_PAINT;
118896:   if (aIsAlternate) {
118896:     flags |= nsIWidgetListener::PAINT_IS_ALTERNATE; 
118896:   }
118896:   returnValue = listener->PaintWindow(widget, aRegion, flags);
108457:   mIsDispatchPaint = oldDispatchPaint;
108457:   return returnValue;
108457: }
108457: 
     1: #pragma mark -
     1: 
108457: void nsChildView::ReportMoveEvent()
108457: {
108457:   if (mWidgetListener)
108457:     mWidgetListener->WindowMoved(this, mBounds.x, mBounds.y);
108457: }
108457: 
108457: void nsChildView::ReportSizeEvent()
108457: {
108457:   if (mWidgetListener)
108457:     mWidgetListener->WindowResized(this, mBounds.width, mBounds.height);
     1: }
     1: 
     1: #pragma mark -
     1: 
 25183: //    Return the offset between this child view and the screen.
115495: //    @return       -- widget origin in device-pixel coords
 25183: nsIntPoint nsChildView::WidgetToScreenOffset()
 25183: {
 25183:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 25183: 
115495:   NSPoint origin = NSMakePoint(0, 0);
115495: 
115495:   // 1. First translate view origin point into window coords.
115495:   // The returned point is in bottom-left coordinates.
115495:   origin = [mView convertPoint:origin toView:nil];
     1: 
     1:   // 2. We turn the window-coord rect's origin into screen (still bottom-left) coords.
115495:   origin = [[mView window] convertBaseToScreen:origin];
     1: 
     1:   // 3. Since we're dealing in bottom-left coords, we need to make it top-left coords
     1:   //    before we pass it back to Gecko.
115495:   FlipCocoaScreenCoordinate(origin);
115495: 
115495:   // convert to device pixels
115495:   return CocoaPointsToDevPixels(origin);
 25183: 
 25183:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(nsIntPoint(0,0));
     1: }
     1: 
     1: NS_IMETHODIMP nsChildView::CaptureRollupEvents(nsIRollupListener * aListener,
120177:                                                bool aDoCapture)
     1: {
     1:   // this never gets called, only top-level windows can be rollup widgets
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsChildView::SetTitle(const nsAString& title)
     1: {
  3653:   // child views don't have titles
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsChildView::GetAttention(int32_t aCycleCount)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
     1:   [NSApp requestUserAttention:NSInformationalRequest];
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
 27993: /* static */
 79445: bool nsChildView::DoHasPendingInputEvent()
 27993: {
 27993:   return sLastInputEventCount != GetCurrentInputEventCount(); 
 27993: }
 27993: 
 27993: /* static */
108991: uint32_t nsChildView::GetCurrentInputEventCount()
 27993: {
 27993:   // Can't use kCGAnyInputEventType because that updates too rarely for us (and
 27993:   // always in increments of 30+!) and because apparently it's sort of broken
 27993:   // on Tiger.  So just go ahead and query the counters we care about.
 27993:   static const CGEventType eventTypes[] = {
 27993:     kCGEventLeftMouseDown,
 27993:     kCGEventLeftMouseUp,
 27993:     kCGEventRightMouseDown,
 27993:     kCGEventRightMouseUp,
 27993:     kCGEventMouseMoved,
 27993:     kCGEventLeftMouseDragged,
 27993:     kCGEventRightMouseDragged,
 27993:     kCGEventKeyDown,
 27993:     kCGEventKeyUp,
 27993:     kCGEventScrollWheel,
 27993:     kCGEventTabletPointer,
 27993:     kCGEventOtherMouseDown,
 27993:     kCGEventOtherMouseUp,
 27993:     kCGEventOtherMouseDragged
 27993:   };
 27993: 
108991:   uint32_t eventCount = 0;
108991:   for (uint32_t i = 0; i < ArrayLength(eventTypes); ++i) {
 27993:     eventCount +=
 27993:       CGEventSourceCounterForEventType(kCGEventSourceStateCombinedSessionState,
 27993:                                        eventTypes[i]);
 27993:   }
 27993:   return eventCount;
 27993: }
 27993: 
 27993: /* static */
 27993: void nsChildView::UpdateCurrentInputEventCount()
 27993: {
 27993:   sLastInputEventCount = GetCurrentInputEventCount();
 27993: }
 27993: 
 79445: bool nsChildView::HasPendingInputEvent()
 27993: {
 27993:   return DoHasPendingInputEvent();
 27993: }
     1: 
     1: #pragma mark -
     1: 
 23538: // Force Input Method Editor to commit the uncommitted input
 15919: // Note that this and other IME methods don't necessarily
     1: // get called on the same ChildView that input is going through.
     1: NS_IMETHODIMP nsChildView::ResetInputState()
     1: {
 69465:   NS_ENSURE_TRUE(mTextInputHandler, NS_ERROR_NOT_AVAILABLE);
 69465:   mTextInputHandler->CommitIMEComposition();
     1:   return NS_OK;
     1: }
     1: 
 82841: NS_IMETHODIMP_(void)
 82841: nsChildView::SetInputContext(const InputContext& aContext,
 82841:                              const InputContextAction& aAction)
 82841: {
 82841:   NS_ENSURE_TRUE(mTextInputHandler, );
 82840:   mInputContext = aContext;
 82842:   switch (aContext.mIMEState.mEnabled) {
 82842:     case IMEState::ENABLED:
 82842:     case IMEState::PLUGIN:
 79564:       mTextInputHandler->SetASCIICapableOnly(false);
 79564:       mTextInputHandler->EnableIME(true);
 82842:       if (mInputContext.mIMEState.mOpen != IMEState::DONT_CHANGE_OPEN_STATE) {
 82842:         mTextInputHandler->SetIMEOpenState(
 82842:           mInputContext.mIMEState.mOpen == IMEState::OPEN);
 82842:       }
   539:       break;
 82842:     case IMEState::DISABLED:
 79564:       mTextInputHandler->SetASCIICapableOnly(false);
 79564:       mTextInputHandler->EnableIME(false);
   539:       break;
 82842:     case IMEState::PASSWORD:
 79564:       mTextInputHandler->SetASCIICapableOnly(true);
 79564:       mTextInputHandler->EnableIME(false);
   539:       break;
   539:     default:
   539:       NS_ERROR("not implemented!");
   539:   }
 82841: }
 82841: 
 82841: NS_IMETHODIMP_(InputContext)
 82841: nsChildView::GetInputContext()
 82841: {
 82842:   switch (mInputContext.mIMEState.mEnabled) {
 82842:     case IMEState::ENABLED:
 82842:     case IMEState::PLUGIN:
 82842:       if (mTextInputHandler) {
 82842:         mInputContext.mIMEState.mOpen =
 82842:           mTextInputHandler->IsIMEOpened() ? IMEState::OPEN : IMEState::CLOSED;
 82842:         break;
 82842:       }
 82842:       // If mTextInputHandler is null, set CLOSED instead...
 82842:     default:
 82842:       mInputContext.mIMEState.mOpen = IMEState::CLOSED;
 82842:       break;
 82842:   }
120232:   mInputContext.mNativeIMEContext = [mView inputContext];
120232:   // If input context isn't available on this widget, we should set |this|
120232:   // instead of nullptr since nullptr means that the platform has only one
120232:   // context per process.
120232:   if (!mInputContext.mNativeIMEContext) {
120232:     mInputContext.mNativeIMEContext = this;
120232:   }
 82841:   return mInputContext;
     1: }
     1: 
     1: // Destruct and don't commit the IME composition string.
     1: NS_IMETHODIMP nsChildView::CancelIMEComposition()
     1: {
 69465:   NS_ENSURE_TRUE(mTextInputHandler, NS_ERROR_NOT_AVAILABLE);
 69465:   mTextInputHandler->CancelIMEComposition();
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsChildView::GetToggledKeyState(uint32_t aKeyCode,
 79445:                                               bool* aLEDState)
  2475: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
  2475:   NS_ENSURE_ARG_POINTER(aLEDState);
108991:   uint32_t key;
  2475:   switch (aKeyCode) {
  2475:     case NS_VK_CAPS_LOCK:
  2475:       key = alphaLock;
  2475:       break;
  2475:     case NS_VK_NUM_LOCK:
  2475:       key = kEventKeyModifierNumLockMask;
  2475:       break;
  2475:     // Mac doesn't support SCROLL_LOCK state.
  2475:     default:
  2475:       return NS_ERROR_NOT_IMPLEMENTED;
  2475:   }
108991:   uint32_t modifierFlags = ::GetCurrentKeyModifiers();
  2475:   *aLEDState = (modifierFlags & key) != 0;
  2475:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
  2475: }
  2475: 
 79445: NS_IMETHODIMP nsChildView::OnIMEFocusChange(bool aFocus)
 33316: {
 69465:   NS_ENSURE_TRUE(mTextInputHandler, NS_ERROR_NOT_AVAILABLE);
 69465:   mTextInputHandler->OnFocusChangeInGecko(aFocus);
121727:   return NS_OK;
 33316: }
 33316: 
 33316: NSView<mozView>* nsChildView::GetEditorView()
 33316: {
 33316:   NSView<mozView>* editorView = mView;
 33316:   // We need to get editor's view. E.g., when the focus is in the bookmark
 33316:   // dialog, the view is <panel> element of the dialog.  At this time, the key
 33316:   // events are processed the parent window's view that has native focus.
 79564:   nsQueryContentEvent textContent(true, NS_QUERY_TEXT_CONTENT, this);
 33316:   textContent.InitForQueryTextContent(0, 0);
 33316:   DispatchWindowEvent(textContent);
 33316:   if (textContent.mSucceeded && textContent.mReply.mFocusedWidget) {
 33316:     NSView<mozView>* view = static_cast<NSView<mozView>*>(
 33316:       textContent.mReply.mFocusedWidget->GetNativeData(NS_NATIVE_WIDGET));
 33316:     if (view)
 33316:       editorView = view;
 33316:   }
 33316:   return editorView;
 33316: }
 33316: 
     1: #pragma mark -
     1: 
 87729: void
 87729: nsChildView::CreateCompositor()
 87729: {
 87729:   nsBaseWidget::CreateCompositor();
 87729:   if (mCompositorChild) {
 87729:     LayerManagerOGL *manager =
 87729:       static_cast<LayerManagerOGL*>(compositor::GetLayerManager(mCompositorParent));
 87729: 
124006:     NSOpenGLContext *glContext = (NSOpenGLContext *)manager->GetNSOpenGLContext();
 87729: 
 87729:     [(ChildView *)mView setGLContext:glContext];
 87729:     [(ChildView *)mView setUsingOMTCompositor:true];
 87729:   }
 87729: }
 87729: 
     1: gfxASurface*
     1: nsChildView::GetThebesSurface()
     1: {
     1:   if (!mTempThebesSurface) {
     1:     mTempThebesSurface = new gfxQuartzSurface(gfxSize(1, 1), gfxASurface::ImageFormatARGB32);
     1:   }
     1: 
  1556:   return mTempThebesSurface;
     1: }
     1: 
 62871: static void
 62871: DrawResizer(CGContextRef aCtx)
 62871: {
 62871:   CGContextSetShouldAntialias(aCtx, false);
 62870:   CGPoint points[6];
 62870:   points[0] = CGPointMake(13.0f, 4.0f);
 62870:   points[1] = CGPointMake(3.0f, 14.0f);
 62870:   points[2] = CGPointMake(13.0f, 8.0f);
 62870:   points[3] = CGPointMake(7.0f, 14.0f);
 62870:   points[4] = CGPointMake(13.0f, 12.0f);
 62870:   points[5] = CGPointMake(11.0f, 14.0f);
 62871:   CGContextSetRGBStrokeColor(aCtx, 0.00f, 0.00f, 0.00f, 0.15f);
 62871:   CGContextStrokeLineSegments(aCtx, points, 6);
 62870: 
 62870:   points[0] = CGPointMake(13.0f, 5.0f);
 62870:   points[1] = CGPointMake(4.0f, 14.0f);
 62870:   points[2] = CGPointMake(13.0f, 9.0f);
 62870:   points[3] = CGPointMake(8.0f, 14.0f);
 62870:   points[4] = CGPointMake(13.0f, 13.0f);
 62870:   points[5] = CGPointMake(12.0f, 14.0f);
 62871:   CGContextSetRGBStrokeColor(aCtx, 0.13f, 0.13f, 0.13f, 0.54f);
 62871:   CGContextStrokeLineSegments(aCtx, points, 6);
 62870: 
 62870:   points[0] = CGPointMake(13.0f, 6.0f);
 62870:   points[1] = CGPointMake(5.0f, 14.0f);
 62870:   points[2] = CGPointMake(13.0f, 10.0f);
 62870:   points[3] = CGPointMake(9.0f, 14.0f);
 62870:   points[5] = CGPointMake(13.0f, 13.9f);
 62870:   points[4] = CGPointMake(13.0f, 14.0f);
 62871:   CGContextSetRGBStrokeColor(aCtx, 0.84f, 0.84f, 0.84f, 0.55f);
 62871:   CGContextStrokeLineSegments(aCtx, points, 6);
 62871: }
 62871: 
 62871: void
 87886: nsChildView::DrawWindowOverlay(LayerManager* aManager, nsIntRect aRect)
 62871: {
106838:   if (!ShowsResizeIndicator(nullptr)) {
 62871:     return;
 62871:   }
 62871: 
 62871:   nsRefPtr<LayerManagerOGL> manager(static_cast<LayerManagerOGL*>(aManager));
 62871:   if (!manager) {
 62871:     return;
 62871:   }
 62871: 
 62871:   if (!mResizerImage) {
124008:     mResizerImage = TextureImage::Create(manager->gl(),
124008:                                          nsIntSize(15, 15),
 62871:                                          gfxASurface::CONTENT_COLOR_ALPHA,
 62871:                                          LOCAL_GL_CLAMP_TO_EDGE,
 98144:                                          TextureImage::UseNearestFilter);
 62871: 
 62871:     // Creation of texture images can fail.
 62871:     if (!mResizerImage)
 62871:       return;
 62871: 
 62871:     nsIntRegion update(nsIntRect(0, 0, 15, 15));
 62871:     gfxASurface *asurf = mResizerImage->BeginUpdate(update);
 62871:     if (!asurf) {
106838:       mResizerImage = nullptr;
 62871:       return;
 62871:     }
 62871: 
 62871:     NS_ABORT_IF_FALSE(asurf->GetType() == gfxASurface::SurfaceTypeQuartz,
 62871:                   "BeginUpdate must return a Quartz surface!");
 62871: 
 62871:     nsRefPtr<gfxQuartzSurface> image = static_cast<gfxQuartzSurface*>(asurf);
 62871:     DrawResizer(image->GetCGContext());
 62871: 
 62871:     mResizerImage->EndUpdate();
 62871:   }
 62871: 
 62871:   NS_ABORT_IF_FALSE(mResizerImage, "Must have a texture allocated by now!");
 62871: 
 62871:   float bottomX = aRect.x + aRect.width;
 62871:   float bottomY = aRect.y + aRect.height;
 62871: 
 73465:   TextureImage::ScopedBindTexture texBind(mResizerImage, LOCAL_GL_TEXTURE0);
 62870: 
 97428:   ShaderProgramOGL *program =
 97428:     manager->GetProgram(mResizerImage->GetShaderProgramType());
 62870:   program->Activate();
 62870:   program->SetLayerQuadRect(nsIntRect(bottomX - 15,
 62870:                                       bottomY - 15,
 62870:                                       15,
 62870:                                       15));
 62870:   program->SetLayerTransform(gfx3DMatrix());
 62870:   program->SetLayerOpacity(1.0);
 62870:   program->SetRenderOffset(nsIntPoint(0,0));
 62870:   program->SetTextureUnit(0);
 62870: 
 62870:   manager->BindAndDrawQuad(program);
 60224: }
 60224: 
 60289: void
 60289: nsChildView::UpdateThemeGeometries(const nsTArray<ThemeGeometry>& aThemeGeometries)
 60289: {
 60289:   NSWindow* win = [mView window];
 60289:   if (!win || ![win isKindOfClass:[ToolbarWindow class]])
 60289:     return;
 60289: 
 60289:   float unifiedToolbarHeight = 0;
 60289:   nsIntRect topPixelStrip(0, 0, [win frame].size.width, 1);
 60289: 
108991:   for (uint32_t i = 0; i < aThemeGeometries.Length(); ++i) {
 60289:     const ThemeGeometry& g = aThemeGeometries[i];
 60289:     if ((g.mWidgetType == NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR ||
 60289:          g.mWidgetType == NS_THEME_TOOLBAR) &&
 60289:         g.mRect.Contains(topPixelStrip)) {
 60289:       unifiedToolbarHeight = g.mRect.YMost();
 60289:     }
 60289:   }
115495:   [(ToolbarWindow*)win
115495:     setUnifiedToolbarHeight:DevPixelsToCocoaPoints(unifiedToolbarHeight)];
 60289: }
 60289: 
  6348: NS_IMETHODIMP
  6348: nsChildView::BeginSecureKeyboardInput()
  6348: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
  6348:   nsresult rv = nsBaseWidget::BeginSecureKeyboardInput();
 62281:   if (NS_SUCCEEDED(rv)) {
  6348:     ::EnableSecureEventInput();
 62281:   }
  6348:   return rv;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
  6348: }
  6348: 
  6348: NS_IMETHODIMP
  6348: nsChildView::EndSecureKeyboardInput()
  6348: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
  6348:   nsresult rv = nsBaseWidget::EndSecureKeyboardInput();
 62281:   if (NS_SUCCEEDED(rv)) {
  6348:     ::DisableSecureEventInput();
 62281:   }
  6348:   return rv;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
  6348: }
  6348: 
     1: #ifdef ACCESSIBILITY
122283: already_AddRefed<a11y::Accessible>
 42313: nsChildView::GetDocumentAccessible()
 42313: {
101309:   if (!mozilla::a11y::ShouldA11yBeEnabled())
106838:     return nullptr;
106838: 
122283:   a11y::Accessible* docAccessible = nullptr;
 42313:   if (mAccessible) {
 42313:     CallQueryReferent(mAccessible.get(), &docAccessible);
 42313:     return docAccessible;
 42313:   }
 42313: 
     1:   // need to fetch the accessible anew, because it has gone away.
     1:   // cache the accessible in our weak ptr
122283:   a11y::Accessible* acc = GetAccessible();
108454:   mAccessible = do_GetWeakReference(static_cast<nsIAccessible *>(acc));
108454: 
108454:   NS_IF_ADDREF(acc);
108454:   return acc;
     1: }
     1: #endif
     1: 
     1: #pragma mark -
     1: 
     1: @implementation ChildView
     1: 
     1: // globalDragPboard is non-null during native drag sessions that did not originate
     1: // in our native NSView (it is set in |draggingEntered:|). It is unset when the
     1: // drag session ends for this view, either with the mouse exiting or when a drop
     1: // occurs in this view.
     1: NSPasteboard* globalDragPboard = nil;
     1: 
 34629: // gLastDragView and gLastDragMouseDownEvent are used to communicate information
 34629: // to the drag service during drag invocation (starting a drag in from the view).
 34629: // gLastDragView is only non-null while mouseDragged is on the call stack.
  6245: NSView* gLastDragView = nil;
 34629: NSEvent* gLastDragMouseDownEvent = nil;
     1: 
 22821: + (void)initialize
 22821: {
 22821:   static BOOL initialized = NO;
 22821: 
 22821:   if (!initialized) {
 22821:     // Inform the OS about the types of services (from the "Services" menu)
 22821:     // that we can handle.
 26757: 
 26757:     NSArray *sendTypes = [[NSArray alloc] initWithObjects:NSStringPboardType,NSHTMLPboardType,nil];
 36983:     NSArray *returnTypes = [[NSArray alloc] initWithObjects:NSStringPboardType,NSHTMLPboardType,nil];
 26757:     
 22821:     [NSApp registerServicesMenuSendTypes:sendTypes returnTypes:returnTypes];
 22821: 
 26757:     [sendTypes release];
 26757:     [returnTypes release];
 26757: 
 22821:     initialized = YES;
 22821:   }
 22821: }
 22821: 
  6754: // initWithFrame:geckoChild:
  6754: - (id)initWithFrame:(NSRect)inFrame geckoChild:(nsChildView*)inChild
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
     1:   if ((self = [super initWithFrame:inFrame])) {
     1:     mGeckoChild = inChild;
     1:     mIsPluginView = NO;
 32120: #ifndef NP_NO_CARBON
118918:     // We don't support the Carbon event model but it's still the default
118918:     // model for i386 per NPAPI.
 32120:     mPluginEventModel = NPEventModelCarbon;
 32120: #else
 32120:     mPluginEventModel = NPEventModelCocoa;
 32120: #endif
 54248: #ifndef NP_NO_QUICKDRAW
110791:     // We don't support the Quickdraw drawing model any more but it's still
110791:     // the default model for i386 per NPAPI.
 54248:     mPluginDrawingModel = NPDrawingModelQuickDraw;
 54248: #else
 54248:     mPluginDrawingModel = NPDrawingModelCoreGraphics;
 54248: #endif
 43368:     mPendingDisplay = NO;
 47792:     mBlockedLastMouseDown = NO;
     1: 
 13976:     mLastMouseDownEvent = nil;
 47792:     mClickThroughMouseDownEvent = nil;
106838:     mDragService = nullptr;
 15585: 
 20793:     mGestureState = eGestureState_None;
 20793:     mCumulativeMagnification = 0.0;
 20793:     mCumulativeRotation = 0.0;
 32542: 
 61878:     // We can't call forceRefreshOpenGL here because, in order to work around
 61878:     // the bug, it seems we need to have a draw already happening. Therefore,
 61878:     // we call it in drawRect:inContext:, when we know that a draw is in
 61878:     // progress.
 61878:     mDidForceRefreshOpenGL = NO;
 61878: 
 32542:     [self setFocusRingType:NSFocusRingTypeNone];
 75269: 
 75269: #ifdef __LP64__
 75269:     mSwipeAnimationCancelled = nil;
 75269: #endif
     1:   }
     1:   
     1:   // register for things we'll take from other applications
120690:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView initWithFrame: registering drag types\n"));
120690:   [self registerForDraggedTypes:[NSArray arrayWithObjects:NSFilenamesPboardType,
120690:                                                           NSStringPboardType,
120690:                                                           NSHTMLPboardType,
120690:                                                           NSURLPboardType,
120690:                                                           NSFilesPromisePboardType,
120690:                                                           kWildcardPboardType,
120690:                                                           kCorePboardType_url,
120690:                                                           kCorePboardType_urld,
120690:                                                           kCorePboardType_urln,
120690:                                                           nil]];
 19344:   [[NSNotificationCenter defaultCenter] addObserver:self
 41061:                                            selector:@selector(windowBecameMain:)
 41061:                                                name:NSWindowDidBecomeMainNotification
 41061:                                              object:nil];
 41061:   [[NSNotificationCenter defaultCenter] addObserver:self
 41061:                                            selector:@selector(windowResignedMain:)
 41061:                                                name:NSWindowDidResignMainNotification
 41061:                                              object:nil];
 41061:   [[NSNotificationCenter defaultCenter] addObserver:self
 20457:                                            selector:@selector(systemMetricsChanged)
 19344:                                                name:NSControlTintDidChangeNotification
 19344:                                              object:nil];
 19492:   [[NSNotificationCenter defaultCenter] addObserver:self
 20457:                                            selector:@selector(systemMetricsChanged)
 19492:                                                name:NSSystemColorsDidChangeNotification
 19492:                                              object:nil];
 20457:   [[NSDistributedNotificationCenter defaultCenter] addObserver:self
 20457:                                                       selector:@selector(systemMetricsChanged)
 20457:                                                           name:@"AppleAquaScrollBarVariantChanged"
 20457:                                                         object:nil
 20457:                                             suspensionBehavior:NSNotificationSuspensionBehaviorDeliverImmediately]; 
 41434:   [[NSNotificationCenter defaultCenter] addObserver:self
 41434:                                            selector:@selector(_surfaceNeedsUpdate:)
 41434:                                                name:NSViewGlobalFrameDidChangeNotification
 41434:                                              object:self];
     1: 
     1:   return self;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
     1: }
     1: 
 69465: - (void)installTextInputHandler:(TextInputHandler*)aHandler
 69465: {
 69465:   mTextInputHandler = aHandler;
 69465: }
 69465: 
 69465: - (void)uninstallTextInputHandler
 69465: {
106838:   mTextInputHandler = nullptr;
 69465: }
 69465: 
 61878: // Work around bug 603134.
 61878: // OS X has a bug that causes new OpenGL windows to only paint once or twice,
 61878: // then stop painting altogether. By clearing the drawable from the GL context,
 61878: // and then resetting the view to ourselves, we convince OS X to start updating
 61878: // again.
 61878: // This can cause a flash in new windows - bug 631339 - but it's very hard to
 61878: // fix that while maintaining this workaround.
 61878: - (void)forceRefreshOpenGL
 61878: {
 61878:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 61878: 
 61878:   [mGLContext clearDrawable];
 61878:   [mGLContext setView:self];
 61878: 
 61878:   NS_OBJC_END_TRY_ABORT_BLOCK;
 61878: }
 61878: 
 87729: - (void)setGLContext:(NSOpenGLContext *)aGLContext
 87729: {
 87729:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 87729: 
 87729:   mGLContext = aGLContext;
 87729:   [mGLContext retain];
 87729: 
 87729:   NS_OBJC_END_TRY_ABORT_BLOCK;
 87729: }
 87729: 
     1: - (void)dealloc
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 43776:   [mGLContext release];
     1:   [mPendingDirtyRects release];
 13976:   [mLastMouseDownEvent release];
 47792:   [mClickThroughMouseDownEvent release];
 34051:   ChildViewMouseTracker::OnDestroyView(self);
     1: 
 19344:   [[NSNotificationCenter defaultCenter] removeObserver:self];
 20457:   [[NSDistributedNotificationCenter defaultCenter] removeObserver:self];
 19344: 
  6013:   [super dealloc];
  6013: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
 41061: - (void)updatePluginTopLevelWindowStatus:(BOOL)hasMain
 41061: {
 41321:   if (!mGeckoChild)
 41321:     return;
 41321: 
 79564:   nsPluginEvent pluginEvent(true, NS_PLUGIN_FOCUS_EVENT, mGeckoChild);
 41061:   NPCocoaEvent cocoaEvent;
 74102:   nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
 41061:   cocoaEvent.type = NPCocoaEventWindowFocusChanged;
 41061:   cocoaEvent.data.focus.hasFocus = hasMain;
 74102:   nsCocoaUtils::InitPluginEvent(pluginEvent, cocoaEvent);
 41061:   mGeckoChild->DispatchWindowEvent(pluginEvent);
 41061: }
 41061: 
 41061: - (void)windowBecameMain:(NSNotification*)inNotification
 41061: {
 41061:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 41061: 
 41061:   if (mIsPluginView && mPluginEventModel == NPEventModelCocoa) {
 41061:     if ((NSWindow*)[inNotification object] == [self window]) {
 41061:       [self updatePluginTopLevelWindowStatus:YES];
 41061:     }
 41061:   }
 41061: 
 41061:   NS_OBJC_END_TRY_ABORT_BLOCK;
 41061: }
 41061: 
 41061: - (void)windowResignedMain:(NSNotification*)inNotification
 41061: {
 41061:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 41061: 
 41061:   if (mIsPluginView && mPluginEventModel == NPEventModelCocoa) {
 41061:     if ((NSWindow*)[inNotification object] == [self window]) {
 41061:       [self updatePluginTopLevelWindowStatus:NO];
 41061:     }
 41061:   }
 41061: 
 41061:   NS_OBJC_END_TRY_ABORT_BLOCK;
 41061: }
 41061: 
     1: - (void)widgetDestroyed
     1: {
 69465:   if (mTextInputHandler) {
 69465:     mTextInputHandler->OnDestroyWidget(mGeckoChild);
106838:     mTextInputHandler = nullptr;
106838:   }
106838:   mGeckoChild = nullptr;
 20736: 
  6789:   // Just in case we're destroyed abruptly and missed the draggingExited
  6789:   // or performDragOperation message.
  6789:   NS_IF_RELEASE(mDragService);
     1: }
     1: 
     1: // mozView method, return our gecko child view widget. Note this does not AddRef.
     1: - (nsIWidget*) widget
     1: {
  3233:   return static_cast<nsIWidget*>(mGeckoChild);
     1: }
     1: 
 20457: - (void)systemMetricsChanged
 19344: {
108452:   if (mGeckoChild)
108452:     mGeckoChild->NotifyThemeChanged();
 19344: }
 19344: 
     1: - (void)setNeedsPendingDisplay
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
     1:   mPendingFullDisplay = YES;
 43368:   if (!mPendingDisplay) {
     1:     [self performSelector:@selector(processPendingRedraws) withObject:nil afterDelay:0];
 43368:     mPendingDisplay = YES;
 43368:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: - (void)setNeedsPendingDisplayInRect:(NSRect)invalidRect
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
     1:   if (!mPendingDirtyRects)
     1:     mPendingDirtyRects = [[NSMutableArray alloc] initWithCapacity:1];
     1:   [mPendingDirtyRects addObject:[NSValue valueWithRect:invalidRect]];
 43368:   if (!mPendingDisplay) {
     1:     [self performSelector:@selector(processPendingRedraws) withObject:nil afterDelay:0];
 43368:     mPendingDisplay = YES;
 43368:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: // Clears the queue of any pending invalides
     1: - (void)processPendingRedraws
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
     1:   if (mPendingFullDisplay) {
     1:     [self setNeedsDisplay:YES];
     1:   }
 43368:   else if (mPendingDirtyRects) {
     1:     unsigned int count = [mPendingDirtyRects count];
     1:     for (unsigned int i = 0; i < count; ++i) {
     1:       [self setNeedsDisplayInRect:[[mPendingDirtyRects objectAtIndex:i] rectValue]];
     1:     }
     1:   }
     1:   mPendingFullDisplay = NO;
 43368:   mPendingDisplay = NO;
     1:   [mPendingDirtyRects release];
     1:   mPendingDirtyRects = nil;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
 34054: - (void)setNeedsDisplayInRect:(NSRect)aRect
 34054: {
 34054:   [super setNeedsDisplayInRect:aRect];
 34054: 
 34054:   if ([[self window] isKindOfClass:[ToolbarWindow class]]) {
 34054:     ToolbarWindow* window = (ToolbarWindow*)[self window];
 34054:     if ([window drawsContentsIntoWindowFrame]) {
 34054:       // Tell it to mark the rect in the titlebar as dirty.
 34054:       NSView* borderView = [[window contentView] superview];
 34054:       [window setTitlebarNeedsDisplayInRect:[self convertRect:aRect toView:borderView]];
 34054:     }
 34054:   }
 34054: }
 34054: 
     1: - (NSString*)description
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
     1:   return [NSString stringWithFormat:@"ChildView %p, gecko child %p, frame %@", self, mGeckoChild, NSStringFromRect([self frame])];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
     1: }
     1: 
     1: // Make the origin of this view the topLeft corner (gecko origin) rather
     1: // than the bottomLeft corner (standard cocoa origin).
     1: - (BOOL)isFlipped
     1: {
     1:   return YES;
     1: }
     1: 
     1: - (BOOL)isOpaque
     1: {
 54250:   return [[self window] isOpaque] && !mIsPluginView;
     1: }
     1: 
     1: -(void)setIsPluginView:(BOOL)aIsPlugin
     1: {
     1:   mIsPluginView = aIsPlugin;
     1: }
     1: 
   130: -(BOOL)isPluginView
     1: {
     1:   return mIsPluginView;
     1: }
     1: 
 57526: // Are we processing an NSLeftMouseDown event that will fail to click through?
 57526: // If so, we shouldn't focus or unfocus a plugin.
 57526: - (BOOL)isInFailingLeftClickThrough
 57526: {
 57526:   if (!mGeckoChild)
 57526:     return NO;
 57526: 
 57526:   if (!mClickThroughMouseDownEvent ||
 57526:       [mClickThroughMouseDownEvent type] != NSLeftMouseDown)
 57526:     return NO;
 57526: 
 57526:   BOOL retval =
 57526:     !ChildViewMouseTracker::WindowAcceptsEvent([self window],
 57526:                                                mClickThroughMouseDownEvent,
 79564:                                                self, true);
 57526: 
 57526:   // If we return YES here, this will result in us not being focused,
 57526:   // which will stop us receiving mClickThroughMouseDownEvent in
 57526:   // [ChildView mouseDown:].  So we need to release and null-out
 57526:   // mClickThroughMouseDownEvent here.
 57526:   if (retval) {
 57526:     [mClickThroughMouseDownEvent release];
 57526:     mClickThroughMouseDownEvent = nil;
 57526:   }
 57526: 
 57526:   return retval;
 57526: }
 57526: 
 32120: - (void)setPluginEventModel:(NPEventModel)eventModel
 32120: {
 32120:   mPluginEventModel = eventModel;
 32120: }
 32120: 
 54248: - (void)setPluginDrawingModel:(NPDrawingModel)drawingModel
 54248: {
 54248:   mPluginDrawingModel = drawingModel;
 54248: }
 54248: 
 61078: - (NPEventModel)pluginEventModel
 32120: {
 32120:   return mPluginEventModel;
 32019: }
 32019: 
 61078: - (NPDrawingModel)pluginDrawingModel
 54248: {
 54248:   return mPluginDrawingModel;
 54248: }
 54248: 
108991: - (void)sendFocusEvent:(uint32_t)eventType
  4208: {
  4208:   if (!mGeckoChild)
  4208:     return;
  4208: 
  4208:   nsEventStatus status = nsEventStatus_eIgnore;
 79564:   nsGUIEvent focusGuiEvent(true, eventType, mGeckoChild);
  4208:   focusGuiEvent.time = PR_IntervalNow();
  4208:   mGeckoChild->DispatchEvent(&focusGuiEvent, status);
  4208: }
  4208: 
     1: // We accept key and mouse events, so don't keep passing them up the chain. Allow
 41321: // this to be a 'focused' widget for event dispatch.
     1: - (BOOL)acceptsFirstResponder
     1: {
     1:   return YES;
     1: }
     1: 
 47792: // Accept mouse down events on background windows
 47792: - (BOOL)acceptsFirstMouse:(NSEvent*)aEvent
 47792: {
 47792:   if (![[self window] isKindOfClass:[PopupWindow class]]) {
 47792:     // We rely on this function to tell us that the mousedown was on a
 47792:     // background window. Inside mouseDown we can't tell whether we were
 47792:     // inactive because at that point we've already been made active.
 47792:     // Unfortunately, acceptsFirstMouse is called for PopupWindows even when
 47792:     // their parent window is active, so ignore this on them for now.
 47792:     mClickThroughMouseDownEvent = [aEvent retain];
 47792:   }
 47792:   return YES;
 47792: }
 47792: 
 21644: - (void)viewWillMoveToWindow:(NSWindow *)newWindow
 21644: {
 21644:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 21644: 
 21644:   if (!newWindow)
 21644:     HideChildPluginViews(self);
 21644: 
 21644:   [super viewWillMoveToWindow:newWindow];
 21644: 
 21644:   NS_OBJC_END_TRY_ABORT_BLOCK;
 21644: }
 21644: 
 32510: - (void)viewDidMoveToWindow
 32510: {
 37446:   if (mPluginEventModel == NPEventModelCocoa &&
 37446:       [self window] && [self isPluginView] && mGeckoChild) {
 32510:     mGeckoChild->UpdatePluginPort();
 32510:   }
 32510: 
 32510:   [super viewDidMoveToWindow];
 32510: }
 32510: 
     1: - (void)scrollRect:(NSRect)aRect by:(NSSize)offset
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
     1:   // Update any pending dirty rects to reflect the new scroll position
     1:   if (mPendingDirtyRects) {
     1:     unsigned int count = [mPendingDirtyRects count];
     1:     for (unsigned int i = 0; i < count; ++i) {
     1:       NSRect oldRect = [[mPendingDirtyRects objectAtIndex:i] rectValue];
     1:       NSRect newRect = NSOffsetRect(oldRect, offset.width, offset.height);
     1:       [mPendingDirtyRects replaceObjectAtIndex:i
     1:                                     withObject:[NSValue valueWithRect:newRect]];
     1:     }
     1:   }
     1:   [super scrollRect:aRect by:offset];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: - (BOOL)mouseDownCanMoveWindow
     1: {
120690:   return NO;
     1: }
     1: 
     1: - (void)lockFocus
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
     1:   [super lockFocus];
 11978: 
 43776:   if (mGLContext) {
 43776:     if ([mGLContext view] != self) {
 43776:       [mGLContext setView:self];
 43776:     }
 43776: 
 43776:     [mGLContext makeCurrentContext];
 41434:   }
 41434: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
 41434: -(void)update
 41434: {
 43776:   if (mGLContext) {
 43776:     [mGLContext update];
 41434:   }
 41434: }
 41434: 
 41434: - (void) _surfaceNeedsUpdate:(NSNotification*)notification
 41434: {
 41434:    [self update];
 41434: }
 41434: 
115495: - (BOOL)wantsBestResolutionOpenGLSurface
115495: {
115495:   return nsCocoaUtils::HiDPIEnabled() ? YES : NO;
115495: }
115495: 
119103: - (void)viewDidChangeBackingProperties
119103: {
119103:   [super viewDidChangeBackingProperties];
119103:   if (mGeckoChild) {
119103:     // actually, it could be the color space that's changed,
119103:     // but we can't tell the difference here except by retrieving
119103:     // the backing scale factor and comparing to the old value
119103:     mGeckoChild->BackingScaleFactorChanged();
119103:   }
119103: }
119103: 
     1: // The display system has told us that a portion of our view is dirty. Tell
     1: // gecko to paint it
     1: - (void)drawRect:(NSRect)aRect
     1: {
 34054:   CGContextRef cgContext = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
118896:   [self drawRect:aRect inContext:cgContext alternate:false];
 34054: 
 35620:   // If we're a transparent window and our contents have changed, we need
 34054:   // to make sure the shadow is updated to the new contents.
 35620:   if ([[self window] isKindOfClass:[BaseWindow class]]) {
 35620:     [(BaseWindow*)[self window] deferredInvalidateShadow];
 35620:   }
 34054: }
 34054: 
 55858: - (void)drawRect:(NSRect)aRect inTitlebarContext:(CGContextRef)aContext
 55858: {
 57913:   if (!mGeckoChild)
 57913:     return;
 57913: 
 55858:   // Title bar drawing only works if we really draw into aContext, which only
 55858:   // the basic layer manager will do.
 55858:   nsBaseWidget::AutoUseBasicLayerManager setupLayerManager(mGeckoChild);
118896:   [self drawRect:aRect inContext:aContext alternate:true];
118896: }
118896: 
118896: - (void)drawRect:(NSRect)aRect inContext:(CGContextRef)aContext alternate:(BOOL)aIsAlternate
 34054: {
 87692:   SAMPLE_LABEL("widget", "ChildView::drawRect");
105772:   if (!mGeckoChild || !mGeckoChild->IsVisible())
     1:     return;
     1: 
110791:   // Don't ever draw plugin views explicitly; they'll be drawn as part of their parent widget.
 54250:   if (mIsPluginView)
 54250:     return;
 54250: 
 34054: #ifdef DEBUG_UPDATE
 23738:   nsIntRect geckoBounds;
     1:   mGeckoChild->GetBounds(geckoBounds);
     1: 
     1:   fprintf (stderr, "---- Update[%p][%p] [%f %f %f %f] cgc: %p\n  gecko bounds: [%d %d %d %d]\n",
     1:            self, mGeckoChild,
 34054:            aRect.origin.x, aRect.origin.y, aRect.size.width, aRect.size.height, aContext,
     1:            geckoBounds.x, geckoBounds.y, geckoBounds.width, geckoBounds.height);
     1: 
 34054:   CGAffineTransform xform = CGContextGetCTM(aContext);
     1:   fprintf (stderr, "  xform in: [%f %f %f %f %f %f]\n", xform.a, xform.b, xform.c, xform.d, xform.tx, xform.ty);
     1: #endif
108457:   nsIntRegion region;
     1: 
115495:   nsIntRect boundingRect = mGeckoChild->CocoaPointsToDevPixels(aRect);
     1:   const NSRect *rects;
 32120:   NSInteger count, i;
 34054:   [[NSView focusView] getRectsBeingDrawn:&rects count:&count];
 25019:   if (count < MAX_RECTS_IN_REGION) {
     1:     for (i = 0; i < count; ++i) {
 34054:       // Add the rect to the region.
115495:       NSRect r = [self convertRect:rects[i] fromView:[NSView focusView]];
115495:       region.Or(region, mGeckoChild->CocoaPointsToDevPixels(r));
108457:     }
108457:     region.And(region, boundingRect);
 25019:   } else {
108457:     region = boundingRect;
 34054:   }
     1: 
106838:   LayerManager *layerManager = mGeckoChild->GetLayerManager(nullptr);
105710:   if (layerManager->GetBackendType() == mozilla::layers::LAYERS_OPENGL) {
 87729:     NSOpenGLContext *glContext;
 87729: 
 87729:     LayerManagerOGL *manager = static_cast<LayerManagerOGL*>(layerManager);
108457:     manager->SetClippingRegion(region);
124006:     glContext = (NSOpenGLContext *)manager->GetNSOpenGLContext();
 87729: 
 43776:     if (!mGLContext) {
 87729:       [self setGLContext:glContext];
 87729:     }
 87729: 
108187:     [glContext setView:self];
108187:     [glContext update];
108187: 
118896:     mGeckoChild->PaintWindow(region, aIsAlternate);
 61878: 
 61878:     // Force OpenGL to refresh the very first time we draw. This works around a
 61878:     // Mac OS X bug that stops windows updating on OS X when we use OpenGL.
 61878:     if (!mDidForceRefreshOpenGL) {
 61878:       [self performSelector:@selector(forceRefreshOpenGL) withObject:nil afterDelay:0];
 61878:       mDidForceRefreshOpenGL = YES;
 61878:     }
 61878: 
 41434:     return;
 41434:   }
 41434: 
 41434:   // Create Cairo objects.
 41434: 
115495:   // The CGContext that drawRect supplies us with comes with a transform that
115495:   // scales one user space unit to one Cocoa point, which can consist of
115495:   // multiple dev pixels. But Gecko expects its supplied context to be scaled
115495:   // to device pixels, so we need to reverse the scaling.
121063:   double scale = mGeckoChild->BackingScaleFactor();
121063:   CGContextScaleCTM(aContext, 1.0 / scale, 1.0 / scale);
121063: 
121063:   NSSize viewSize = [self bounds].size;
121063:   nsIntSize backingSize(viewSize.width * scale, viewSize.height * scale);
121063: 
121063:   nsRefPtr<gfxQuartzSurface> targetSurface =
121063:     new gfxQuartzSurface(aContext, backingSize);
121063:   targetSurface->SetAllowUseAsSource(false);
121063: 
121063:   nsRefPtr<gfxContext> targetContext = new gfxContext(targetSurface);
121063: 
115495:   gfxContextMatrixAutoSaveRestore save(targetContext);
115495: 
 34054:   // Set up the clip region.
108457:   nsIntRegionRectIterator iter(region);
 38805:   targetContext->NewPath();
 38805:   for (;;) {
 38805:     const nsIntRect* r = iter.Next();
 38805:     if (!r)
 38805:       break;
 38805:     targetContext->Rectangle(gfxRect(r->x, r->y, r->width, r->height));
 38805:   }
 34054:   targetContext->Clip();
 34054: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 79445:   bool painted;
 38805:   {
 47746:     nsBaseWidget::AutoLayerManagerSetup
106914:       setupLayerManager(mGeckoChild, targetContext, BUFFER_NONE);
118896:     painted = mGeckoChild->PaintWindow(region, aIsAlternate);
 38805:   }
 38805: 
 87729:   // Force OpenGL to refresh the very first time we draw. This works around a
 87729:   // Mac OS X bug that stops windows updating on OS X when we use OpenGL.
 87729:   if (painted && !mDidForceRefreshOpenGL &&
 87729:       layerManager->AsShadowManager() && mUsingOMTCompositor) {
 87729:     if (!mDidForceRefreshOpenGL) {
 87729:       [self performSelector:@selector(forceRefreshOpenGL) withObject:nil afterDelay:0];
 87729:       mDidForceRefreshOpenGL = YES;
 87729:     }
 87729:   }
 87729: 
 34628:   if (!painted && [self isOpaque]) {
 34628:     // Gecko refused to draw, but we've claimed to be opaque, so we have to
 34628:     // draw something--fill with white.
 34628:     CGContextSetRGBFillColor(aContext, 1, 1, 1, 1);
115495:     CGContextFillRect(aContext, NSRectToCGRect(aRect));
 34628:   }
 37194: 
     1:   // note that the cairo surface *MUST* be destroyed at this point,
     1:   // or bad things will happen (since we can't keep the cgContext around
     1:   // beyond this drawRect message handler)
     1: 
     1: #ifdef DEBUG_UPDATE
     1:   fprintf (stderr, "---- update done ----\n");
     1: 
     1: #if 0
 34054:   CGContextSetRGBStrokeColor (aContext,
     1:                             ((((unsigned long)self) & 0xff)) / 255.0,
     1:                             ((((unsigned long)self) & 0xff00) >> 8) / 255.0,
     1:                             ((((unsigned long)self) & 0xff0000) >> 16) / 255.0,
     1:                             0.5);
     1: #endif
 34054:   CGContextSetRGBStrokeColor(aContext, 1, 0, 0, 0.8);
 34054:   CGContextSetLineWidth(aContext, 4.0);
115495:   CGContextStrokeRect(aContext, NSRectToCGRect(aRect));
     1: #endif
     1: }
     1: 
 61287: - (void)releaseWidgets:(NSArray*)aWidgetArray
 61287: {
 61287:   if (!aWidgetArray) {
 61287:     return;
 61287:   }
 61287:   NSInteger count = [aWidgetArray count];
 61287:   for (NSInteger i = 0; i < count; ++i) {
 61287:     NSNumber* pointer = (NSNumber*) [aWidgetArray objectAtIndex:i];
 61287:     nsIWidget* widget = (nsIWidget*) [pointer unsignedIntegerValue];
 61287:     NS_RELEASE(widget);
 61287:   }
 61287: }
 61287: 
 34856: - (void)viewWillDraw
 34856: {
 35619:   if (mGeckoChild) {
 61287:     // The OS normally *will* draw our NSWindow, no matter what we do here.
 61287:     // But Gecko can delete our parent widget(s) (along with mGeckoChild)
108457:     // while processing a paint request, which closes our NSWindow and
 61287:     // makes the OS throw an NSInternalInconsistencyException assertion when
 61287:     // it tries to draw it.  Sometimes the OS also aborts the browser process.
 61287:     // So we need to retain our parent(s) here and not release it/them until
 61287:     // the next time through the main thread's run loop.  When we do this we
 61287:     // also need to retain and release mGeckoChild, which holds a strong
 61287:     // reference to us (otherwise we might have been deleted by the time
 61287:     // releaseWidgets: is called on us).  See bug 550392.
 61287:     nsIWidget* parent = mGeckoChild->GetParent();
 61287:     if (parent) {
 61287:       NSMutableArray* widgetArray = [NSMutableArray arrayWithCapacity:3];
 61287:       while (parent) {
 61287:         NS_ADDREF(parent);
 61287:         [widgetArray addObject:[NSNumber numberWithUnsignedInteger:(NSUInteger)parent]];
 61287:         parent = parent->GetParent();
 61287:       }
 61287:       NS_ADDREF(mGeckoChild);
 61287:       [widgetArray addObject:[NSNumber numberWithUnsignedInteger:(NSUInteger)mGeckoChild]];
 61287:       [self performSelector:@selector(releaseWidgets:)
 61287:                  withObject:widgetArray
 61287:                  afterDelay:0];
 61287:     }
108457: 
108457:     nsIWidgetListener* listener = mGeckoChild->GetWidgetListener();
108457:     if (listener) {
108457:       listener->WillPaintWindow(mGeckoChild, false);
108457:     }
 34856:   }
 35619:   [super viewWillDraw];
 35619: }
 34856: 
  3595: // Allows us to turn off setting up the clip region
     1: // before each drawRect. We already clip within gecko.
     1: - (BOOL)wantsDefaultClipping
     1: {
     1:   return NO;
     1: }
     1: 
     1: #if USE_CLICK_HOLD_CONTEXTMENU
     1: //
     1: // -clickHoldCallback:
     1: //
     1: // called from a timer two seconds after a mouse down to see if we should display
     1: // a context menu (click-hold). |anEvent| is the original mouseDown event. If we're
     1: // still in that mouseDown by this time, put up the context menu, otherwise just
     1: // fuhgeddaboutit. |anEvent| has been retained by the OS until after this callback
     1: // fires so we're ok there.
     1: //
     1: // This code currently messes in a bunch of edge cases (bugs 234751, 232964, 232314)
     1: // so removing it until we get it straightened out.
     1: //
     1: - (void)clickHoldCallback:(id)theEvent;
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
     1:   if( theEvent == [NSApp currentEvent] ) {
     1:     // we're still in the middle of the same mousedown event here, activate
     1:     // click-hold context menu by triggering the right mouseDown action.
     1:     NSEvent* clickHoldEvent = [NSEvent mouseEventWithType:NSRightMouseDown
     1:                                                   location:[theEvent locationInWindow]
 38441:                                              modifierFlags:[theEvent modifierFlags]
     1:                                                  timestamp:[theEvent timestamp]
     1:                                               windowNumber:[theEvent windowNumber]
     1:                                                    context:[theEvent context]
     1:                                                eventNumber:[theEvent eventNumber]
     1:                                                 clickCount:[theEvent clickCount]
     1:                                                   pressure:[theEvent pressure]];
     1:     [self rightMouseDown:clickHoldEvent];
     1:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: #endif
     1: 
  3574: // If we've just created a non-native context menu, we need to mark it as
  3574: // such and let the OS (and other programs) know when it opens and closes
  3574: // (this is how the OS knows to close other programs' context menus when
  3574: // ours open).  We send the initial notification here, but others are sent
  3574: // in nsCocoaWindow::Show().
  3574: - (void)maybeInitContextMenuTracking
  3574: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 72208: #ifdef MOZ_USE_NATIVE_POPUP_WINDOWS
 12536:   return;
 72208: #endif /* MOZ_USE_NATIVE_POPUP_WINDOWS */
 12536: 
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
127124:   NS_ENSURE_TRUE_VOID(rollupListener);
120177:   nsCOMPtr<nsIWidget> widget = rollupListener->GetRollupWidget();
127124:   NS_ENSURE_TRUE_VOID(widget);
120177: 
120177:   NSWindow *popupWindow = (NSWindow*)widget->GetNativeData(NS_NATIVE_WINDOW);
  7637:   if (!popupWindow || ![popupWindow isKindOfClass:[PopupWindow class]])
  3574:     return;
  7637: 
  3574:   [[NSDistributedNotificationCenter defaultCenter]
  3574:     postNotificationName:@"com.apple.HIToolbox.beginMenuTrackingNotification"
  3574:                   object:@"org.mozilla.gecko.PopupWindow"];
  7637:   [(PopupWindow*)popupWindow setIsContextMenu:YES];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  3574: }
  3574: 
 28346: // Returns true if the event should no longer be processed, false otherwise.
 28346: // This does not return whether or not anything was rolled up.
  8345: - (BOOL)maybeRollup:(NSEvent*)theEvent
  8345: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
 28346:   BOOL consumeEvent = NO;
 28346: 
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
127124:   NS_ENSURE_TRUE(rollupListener, false);
120177:   nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
120177:   if (rollupWidget) {
120177:     NSWindow* currentPopup = static_cast<NSWindow*>(rollupWidget->GetNativeData(NS_NATIVE_WINDOW));
  8779:     if (!nsCocoaUtils::IsEventOverWindow(theEvent, currentPopup)) {
 28346:       // event is not over the rollup window, default is to roll up
 79445:       bool shouldRollup = true;
 28346: 
 28346:       // check to see if scroll events should roll up the popup
  8345:       if ([theEvent type] == NSScrollWheel) {
120177:         shouldRollup = rollupListener->ShouldRollupOnMouseWheelEvent();
 28346:         // always consume scroll events that aren't over the popup
 28346:         consumeEvent = YES;
 28346:       }
 28346: 
  8345:       // if we're dealing with menus, we probably have submenus and
  8345:       // we don't want to rollup if the click is in a parent menu of
  8345:       // the current submenu
115367:       uint32_t popupsToRollup = UINT32_MAX;
 10352:       nsAutoTArray<nsIWidget*, 5> widgetChain;
120177:       uint32_t sameTypeCount = rollupListener->GetSubmenuWidgetChain(&widgetChain);
108991:       for (uint32_t i = 0; i < widgetChain.Length(); i++) {
 10352:         nsIWidget* widget = widgetChain[i];
  8345:         NSWindow* currWindow = (NSWindow*)widget->GetNativeData(NS_NATIVE_WINDOW);
  8779:         if (nsCocoaUtils::IsEventOverWindow(theEvent, currWindow)) {
 42263:           // don't roll up if the mouse event occurred within a menu of the
 42263:           // same type. If the mouse event occurred in a menu higher than
 29148:           // that, roll up, but pass the number of popups to Rollup so
 29148:           // that only those of the same type close up.
 29148:           if (i < sameTypeCount) {
 79564:             shouldRollup = false;
 29148:           }
 29148:           else {
 29148:             popupsToRollup = sameTypeCount;
 29148:           }
  8345:           break;
  8345:         }
 28346:       }
 28346: 
 28346:       if (shouldRollup) {
120177:         consumeEvent = (BOOL)rollupListener->Rollup(popupsToRollup, nullptr);
 28346:       }
 28346:     }
 28346:   }
 28346: 
 28346:   return consumeEvent;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
  8345: }
  8345: 
 20793: /*
 20793:  * XXX - The swipeWithEvent, beginGestureWithEvent, magnifyWithEvent,
 20793:  * rotateWithEvent, and endGestureWithEvent methods are part of a
 20793:  * PRIVATE interface exported by nsResponder and reverse-engineering
 20793:  * was necessary to obtain the methods' prototypes. Thus, Apple may
 20793:  * change the interface in the future without notice.
 20793:  *
 20793:  * The prototypes were obtained from the following link:
 20793:  * http://cocoadex.com/2008/02/nsevent-modifications-swipe-ro.html
 20793:  */
 20793: 
 20793: - (void)swipeWithEvent:(NSEvent *)anEvent
 20793: {
 20793:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 20793: 
 20793:   if (!anEvent || !mGeckoChild)
 20793:     return;
 20793: 
 20793:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 20793: 
 20793:   float deltaX = [anEvent deltaX];  // left=1.0, right=-1.0
 20793:   float deltaY = [anEvent deltaY];  // up=1.0, down=-1.0
 20793: 
 20793:   // Setup the "swipe" event.
 79564:   nsSimpleGestureEvent geckoEvent(true, NS_SIMPLE_GESTURE_SWIPE, mGeckoChild, 0, 0.0);
 23284:   [self convertCocoaMouseEvent:anEvent toGeckoEvent:&geckoEvent];
 20793: 
 20793:   // Record the left/right direction.
 20793:   if (deltaX > 0.0)
 20793:     geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_LEFT;
 20793:   else if (deltaX < 0.0)
 20793:     geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_RIGHT;
 20793: 
 20793:   // Record the up/down direction.
 20793:   if (deltaY > 0.0)
 20793:     geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_UP;
 20793:   else if (deltaY < 0.0)
 20793:     geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_DOWN;
 20793: 
 20793:   // Send the event.
 20793:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 20793: 
 20793:   NS_OBJC_END_TRY_ABORT_BLOCK;
 20793: }
 20793: 
 20793: - (void)beginGestureWithEvent:(NSEvent *)anEvent
 20793: {
 20793:   NS_ASSERTION(mGestureState == eGestureState_None, "mGestureState should be eGestureState_None");
 20793: 
 20793:   if (!anEvent)
 20793:     return;
 20793: 
 20793:   mGestureState = eGestureState_StartGesture;
 20793:   mCumulativeMagnification = 0;
 20793:   mCumulativeRotation = 0.0;
 20793: }
 20793: 
 20793: - (void)magnifyWithEvent:(NSEvent *)anEvent
 20793: {
 20793:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 20793: 
 20793:   if (!anEvent || !mGeckoChild)
 20793:     return;
 20793: 
 20793:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 20793: 
 20793:   float deltaZ = [anEvent deltaZ];
 20793: 
108991:   uint32_t msg;
 20793:   switch (mGestureState) {
 20793:   case eGestureState_StartGesture:
 20793:     msg = NS_SIMPLE_GESTURE_MAGNIFY_START;
 20793:     mGestureState = eGestureState_MagnifyGesture;
 20793:     break;
 20793: 
 20793:   case eGestureState_MagnifyGesture:
 20793:     msg = NS_SIMPLE_GESTURE_MAGNIFY_UPDATE;
 20793:     break;
 20793: 
 20793:   case eGestureState_None:
 20793:   case eGestureState_RotateGesture:
 20793:   default:
 20793:     return;
 20793:   }
 20793: 
 20793:   // Setup the event.
 79564:   nsSimpleGestureEvent geckoEvent(true, msg, mGeckoChild, 0, deltaZ);
 23284:   [self convertCocoaMouseEvent:anEvent toGeckoEvent:&geckoEvent];
 20793: 
 20793:   // Send the event.
 20793:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 20793: 
 20793:   // Keep track of the cumulative magnification for the final "magnify" event.
 20793:   mCumulativeMagnification += deltaZ;
 20793:   
 20793:   NS_OBJC_END_TRY_ABORT_BLOCK;
 20793: }
 20793: 
 20793: - (void)rotateWithEvent:(NSEvent *)anEvent
 20793: {
 20793:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 20793: 
 20793:   if (!anEvent || !mGeckoChild)
 20793:     return;
 20793: 
 20793:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 20793: 
 20793:   float rotation = [anEvent rotation];
 20793: 
108991:   uint32_t msg;
 20793:   switch (mGestureState) {
 20793:   case eGestureState_StartGesture:
 20793:     msg = NS_SIMPLE_GESTURE_ROTATE_START;
 20793:     mGestureState = eGestureState_RotateGesture;
 20793:     break;
 20793: 
 20793:   case eGestureState_RotateGesture:
 20793:     msg = NS_SIMPLE_GESTURE_ROTATE_UPDATE;
 20793:     break;
 20793: 
 20793:   case eGestureState_None:
 20793:   case eGestureState_MagnifyGesture:
 20793:   default:
 20793:     return;
 20793:   }
 20793: 
 20793:   // Setup the event.
 79564:   nsSimpleGestureEvent geckoEvent(true, msg, mGeckoChild, 0, 0.0);
 23284:   [self convertCocoaMouseEvent:anEvent toGeckoEvent:&geckoEvent];
 20793:   geckoEvent.delta = -rotation;
 20793:   if (rotation > 0.0) {
 26874:     geckoEvent.direction = nsIDOMSimpleGestureEvent::ROTATION_COUNTERCLOCKWISE;
 20793:   } else {
 26874:     geckoEvent.direction = nsIDOMSimpleGestureEvent::ROTATION_CLOCKWISE;
 20793:   }
 20793: 
 20793:   // Send the event.
 20793:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 20793: 
 20793:   // Keep track of the cumulative rotation for the final "rotate" event.
 20793:   mCumulativeRotation += rotation;
 20793: 
 20793:   NS_OBJC_END_TRY_ABORT_BLOCK;
 20793: }
 20793: 
 20793: - (void)endGestureWithEvent:(NSEvent *)anEvent
 20793: {
 20793:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 20793: 
 20793:   if (!anEvent || !mGeckoChild) {
 20793:     // Clear the gestures state if we cannot send an event.
 20793:     mGestureState = eGestureState_None;
 20793:     mCumulativeMagnification = 0.0;
 20793:     mCumulativeRotation = 0.0;
 20793:     return;
 20793:   }
 20793: 
 20793:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 20793: 
 20793:   switch (mGestureState) {
 20793:   case eGestureState_MagnifyGesture:
 20793:     {
 20793:       // Setup the "magnify" event.
 79564:       nsSimpleGestureEvent geckoEvent(true, NS_SIMPLE_GESTURE_MAGNIFY,
 20793:                                       mGeckoChild, 0, mCumulativeMagnification);
 23284:       [self convertCocoaMouseEvent:anEvent toGeckoEvent:&geckoEvent];
 20793: 
 20793:       // Send the event.
 20793:       mGeckoChild->DispatchWindowEvent(geckoEvent);
 20793:     }
 20793:     break;
 20793: 
 20793:   case eGestureState_RotateGesture:
 20793:     {
 20793:       // Setup the "rotate" event.
 79564:       nsSimpleGestureEvent geckoEvent(true, NS_SIMPLE_GESTURE_ROTATE, mGeckoChild, 0, 0.0);
 23284:       [self convertCocoaMouseEvent:anEvent toGeckoEvent:&geckoEvent];
 20793:       geckoEvent.delta = -mCumulativeRotation;
 20793:       if (mCumulativeRotation > 0.0) {
 26874:         geckoEvent.direction = nsIDOMSimpleGestureEvent::ROTATION_COUNTERCLOCKWISE;
 20793:       } else {
 26874:         geckoEvent.direction = nsIDOMSimpleGestureEvent::ROTATION_CLOCKWISE;
 20793:       }
 20793: 
 20793:       // Send the event.
 20793:       mGeckoChild->DispatchWindowEvent(geckoEvent);
 20793:     }
 20793:     break;
 20793: 
 20793:   case eGestureState_None:
 20793:   case eGestureState_StartGesture:
 20793:   default:
 20793:     break;
 20793:   }
 20793: 
 20793:   // Clear the gestures state.
 20793:   mGestureState = eGestureState_None;
 20793:   mCumulativeMagnification = 0.0;
 20793:   mCumulativeRotation = 0.0;
 20793: 
 20793:   NS_OBJC_END_TRY_ABORT_BLOCK;
 20793: }
 20793: 
 75269: // Support fluid swipe tracking on OS X 10.7 and higher.  We must be careful
 75269: // to only invoke this support on a horizontal two-finger gesture that really
 75269: // is a swipe (and not a scroll) -- in other words, the app is responsible
 75269: // for deciding which is which.  But once the decision is made, the OS tracks
 75269: // the swipe until it has finished, and decides whether or not it succeeded.
 75269: // A swipe has the same functionality as the Back and Forward buttons.  For
 75269: // now swipe animation is unsupported (e.g. no bounces).  This method is
 75269: // partly based on Apple sample code available at
 75269: // http://developer.apple.com/library/mac/#releasenotes/Cocoa/AppKit.html
 75269: // (under Fluid Swipe Tracking API).
 75269: #ifdef __LP64__
 75269: - (void)maybeTrackScrollEventAsSwipe:(NSEvent *)anEvent
108072:                       scrollOverflow:(double)overflow
 75269: {
 98723:   if (!nsCocoaFeatures::OnLionOrLater()) {
 75269:     return;
 75269:   }
 75269:   // This method checks whether the AppleEnableSwipeNavigateWithScrolls global
 75269:   // preference is set.  If it isn't, fluid swipe tracking is disabled, and a
 75269:   // horizontal two-finger gesture is always a scroll (even in Safari).  This
 75269:   // preference can't (currently) be set from the Preferences UI -- only using
 75269:   // 'defaults write'.
 75269:   if (![NSEvent isSwipeTrackingFromScrollEventsEnabled]) {
 75269:     return;
 75269:   }
 75269:   if ([anEvent type] != NSScrollWheel) {
 75269:     return;
 75269:   }
 75269: 
 75269:   // If a swipe is currently being tracked kill it -- it's been interrupted by
 75269:   // another gesture or legacy scroll wheel event.
 75269:   if (mSwipeAnimationCancelled && (*mSwipeAnimationCancelled == NO)) {
 75269:     *mSwipeAnimationCancelled = YES;
 75269:     mSwipeAnimationCancelled = nil;
 75269:   }
 75269: 
 75269:   // Only initiate tracking if the user has tried to scroll past the edge of
 75269:   // the current page (as indicated by 'overflow' being non-zero).  Gecko only
 75269:   // sets nsMouseScrollEvent.scrollOverflow when it's processing
 75269:   // NS_MOUSE_PIXEL_SCROLL events (not NS_MOUSE_SCROLL events).
 75269:   // nsMouseScrollEvent.scrollOverflow only indicates left or right overflow
 75269:   // for horizontal NS_MOUSE_PIXEL_SCROLL events.
 75269:   if (!overflow) {
 75269:     return;
 75269:   }
 75269:   // Only initiate tracking for gestures that have just begun -- otherwise a
 75269:   // scroll to one side of the page can have a swipe tacked on to it.
 75269:   if ([anEvent phase] != NSEventPhaseBegan) {
 75269:     return;
 75269:   }
 75269:   CGFloat deltaX, deltaY;
 75269:   if ([anEvent hasPreciseScrollingDeltas]) {
 75269:     deltaX = [anEvent scrollingDeltaX];
 75269:     deltaY = [anEvent scrollingDeltaY];
 75269:   } else {
 75269:     deltaX = [anEvent deltaX];
 75269:     deltaY = [anEvent deltaY];
 75269:   }
 75269:   // Only initiate tracking for events whose horizontal element is at least
 75269:   // eight times larger than its vertical element.  This minimizes performance
 75269:   // problems with vertical scrolls (by minimizing the possibility that they'll
 75269:   // be misinterpreted as horizontal swipes), while still tolerating a small
 75269:   // vertical element to a true horizontal swipe.  The number '8' was arrived
 75269:   // at by trial and error.
 75269:   if ((deltaX == 0) || (fabs(deltaX) <= fabs(deltaY) * 8)) {
 75269:     return;
 75269:   }
 75269: 
 75269:   __block BOOL animationCancelled = NO;
121224:   __block BOOL geckoSwipeEventSent = NO;
 75269:   // At this point, anEvent is the first scroll wheel event in a two-finger
 75269:   // horizontal gesture that we've decided to treat as a swipe.  When we call
 75269:   // [NSEvent trackSwipeEventWithOptions:...], the OS interprets all
 75269:   // subsequent scroll wheel events that are part of this gesture as a swipe,
 75269:   // and stops sending them to us.  The OS calls the trackingHandler "block"
 75269:   // multiple times, asynchronously (sometimes after [NSEvent
 75269:   // maybeTrackScrollEventAsSwipe:...] has returned).  The OS determines when
 75269:   // the gesture has finished, and whether or not it was "successful" -- this
 75269:   // information is passed to trackingHandler.  We must be careful to only
 75269:   // call [NSEvent maybeTrackScrollEventAsSwipe:...] on a "real" swipe --
 75269:   // otherwise two-finger scrolling performance will suffer significantly.
 78040:   // Note that we use anEvent inside the block. This extends the lifetime of
 78040:   // the anEvent object because it's retained by the block, see bug 682445.
 78040:   // The block will release it when the block goes away at the end of the
 78040:   // animation, or when the animation is canceled.
 75269:   [anEvent trackSwipeEventWithOptions:0
 75269:              dampenAmountThresholdMin:-1
 75269:                                   max:1
 75269:                          usingHandler:^(CGFloat gestureAmount, NSEventPhase phase, BOOL isComplete, BOOL *stop) {
 82637:       // Since this tracking handler can be called asynchronously, mGeckoChild
 82637:       // might have become NULL here (our child widget might have been
 82637:       // destroyed).
 82637:       if (animationCancelled || !mGeckoChild) {
 75269:         *stop = YES;
 75269:         return;
 75269:       }
 76752:       // gestureAmount is documented to be '-1', '0' or '1' when isComplete
 76752:       // is TRUE, but the docs don't say anything about its value at other
 76752:       // times.  However, tests show that, when phase == NSEventPhaseEnded,
 76752:       // gestureAmount is negative when it will be '-1' at isComplete, and
 76752:       // positive when it will be '1'.  And phase is never equal to
 76752:       // NSEventPhaseEnded when gestureAmount will be '0' at isComplete.
 76752:       // Not waiting until isComplete is TRUE substantially reduces the
 76752:       // time it takes to change pages after a swipe, and helps resolve
 76752:       // bug 678891.
121224:       if (phase == NSEventPhaseEnded && !geckoSwipeEventSent) {
 75269:         if (gestureAmount) {
 79564:           nsSimpleGestureEvent geckoEvent(true, NS_SIMPLE_GESTURE_SWIPE, mGeckoChild, 0, 0.0);
 78040:           [self convertCocoaMouseEvent:anEvent toGeckoEvent:&geckoEvent];
 75269:           if (gestureAmount > 0) {
 78040:             geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_LEFT;
 75269:           } else {
 78040:             geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_RIGHT;
 78040:           }
121224:           // If DispatchWindowEvent() does something to trigger a modal dialog
121224:           // (which spins the event loop), the OS gets confused and makes
121224:           // several re-entrant calls to this handler, all of which have
121224:           // 'phase' set to NSEventPhaseEnded.  Unless we do something about
121224:           // it, this results in an equal number of re-entrant calls to
121224:           // DispatchWindowEvent(), and to our modal-event handling code.
121224:           // Probably because of bug 478703, this really messes things up,
121224:           // and requires a force quit to get out of.  We avoid this by
121224:           // avoiding re-entrant calls to DispatchWindowEvent().  See bug
121224:           // 770626.
121224:           geckoSwipeEventSent = YES;
 78040:           mGeckoChild->DispatchWindowEvent(geckoEvent);
 75269:         }
 75269:         mSwipeAnimationCancelled = nil;
 76752:       } else if (phase == NSEventPhaseCancelled) {
 76752:         mSwipeAnimationCancelled = nil;
 75269:       }
 75269:     }];
 75269: 
 75269:   // We keep a pointer to the __block variable (animationCanceled) so we
 75269:   // can cancel our block handler at any time.  Note: We must assign
 75269:   // &animationCanceled after our block creation and copy -- its address
 75269:   // isn't resolved until then!
 75269:   mSwipeAnimationCancelled = &animationCancelled;
 75269: }
 75269: #endif // #ifdef __LP64__
 75269: 
 87729: - (void)setUsingOMTCompositor:(BOOL)aUseOMTC
 87729: {
 87729:   mUsingOMTCompositor = aUseOMTC;
 87729: }
 87729: 
 87729: 
 35622: // Returning NO from this method only disallows ordering on mousedown - in order
 35622: // to prevent it for mouseup too, we need to call [NSApp preventWindowOrdering]
 35622: // when handling the mousedown event.
 35622: - (BOOL)shouldDelayWindowOrderingForEvent:(NSEvent*)aEvent
 35622: {
 35622:   // Always using system-provided window ordering for normal windows.
 35622:   if (![[self window] isKindOfClass:[PopupWindow class]])
 35622:     return NO;
 35622: 
 47792:   // Don't reorder when we don't have a parent window, like when we're a
 47792:   // context menu or a tooltip.
 47792:   return ![[self window] parentWindow];
 35622: }
 35622: 
     1: - (void)mouseDown:(NSEvent*)theEvent
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 35622:   if ([self shouldDelayWindowOrderingForEvent:theEvent]) {
 35622:     [NSApp preventWindowOrdering];
 35622:   }
 35622: 
 13976:   // If we've already seen this event due to direct dispatch from menuForEvent:
 13976:   // just bail; if not, remember it.
 13976:   if (mLastMouseDownEvent == theEvent) {
 13976:     [mLastMouseDownEvent release];
 13976:     mLastMouseDownEvent = nil;
 13976:     return;
 13976:   }
 13976:   else {
 13976:     [mLastMouseDownEvent release];
 13976:     mLastMouseDownEvent = [theEvent retain];
 13976:   }
 13976: 
 34629:   [gLastDragMouseDownEvent release];
 34629:   gLastDragMouseDownEvent = [theEvent retain];
 34629: 
 47792:   // We need isClickThrough because at this point the window we're in might
 47792:   // already have become main, so the check for isMainWindow in
 47792:   // WindowAcceptsEvent isn't enough. It also has to check isClickThrough.
 47792:   BOOL isClickThrough = (theEvent == mClickThroughMouseDownEvent);
 47792:   [mClickThroughMouseDownEvent release];
 47792:   mClickThroughMouseDownEvent = nil;
 47792: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 10305: 
 32976:   if ([self maybeRollup:theEvent] ||
 47792:       !ChildViewMouseTracker::WindowAcceptsEvent([self window], theEvent, self, isClickThrough)) {
 47792:     // Remember blocking because that means we want to block mouseup as well.
 47792:     mBlockedLastMouseDown = YES;
     1:     return;
 47792:   }
     1: 
     1: #if USE_CLICK_HOLD_CONTEXTMENU
     1:   // fire off timer to check for click-hold after two seconds. retains |theEvent|
     1:   [self performSelector:@selector(clickHoldCallback:) withObject:theEvent afterDelay:2.0];
     1: #endif
     1: 
   656:   // in order to send gecko events we'll need a gecko widget
   656:   if (!mGeckoChild)
   656:     return;
   656: 
 38441:   NSUInteger modifierFlags = [theEvent modifierFlags];
 32019: 
 96897:   nsMouseEvent geckoEvent(true, NS_MOUSE_BUTTON_DOWN, mGeckoChild, nsMouseEvent::eReal);
  2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 47792: 
 47792:   NSInteger clickCount = [theEvent clickCount];
 47792:   if (mBlockedLastMouseDown && clickCount > 1) {
 47792:     // Don't send a double click if the first click of the double click was
 47792:     // blocked.
 47792:     clickCount--;
 47792:   }
 47792:   geckoEvent.clickCount = clickCount;
 47792: 
 32019:   if (modifierFlags & NSControlKeyMask)
     1:     geckoEvent.button = nsMouseEvent::eRightButton;
     1:   else
     1:     geckoEvent.button = nsMouseEvent::eLeftButton;
     1: 
 32019:   // Create event for use by plugins.
 32019:   // This is going to our child view so we don't need to look up the destination
 32019:   // event type.
 32120:   NPCocoaEvent cocoaEvent;
 32120:   if (mPluginEventModel == NPEventModelCocoa) {
 74102:     nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
 32019:     NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
 32019:     cocoaEvent.type = NPCocoaEventMouseDown;
 32019:     cocoaEvent.data.mouse.modifierFlags = modifierFlags;
 32019:     cocoaEvent.data.mouse.pluginX = point.x;
 32019:     cocoaEvent.data.mouse.pluginY = point.y;
 32019:     cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
 47792:     cocoaEvent.data.mouse.clickCount = clickCount;
 32019:     cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
 32019:     cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
 32019:     cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
 34743:     geckoEvent.pluginEvent = &cocoaEvent;
 32019:   }
     1: 
 18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 47792:   mBlockedLastMouseDown = NO;
     1: 
     1:   // XXX maybe call markedTextSelectionChanged:client: here?
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: - (void)mouseUp:(NSEvent *)theEvent
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 47792:   if (!mGeckoChild || mBlockedLastMouseDown)
  2315:     return;
  2315: 
 37413:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 37413: 
 64614:   NPCocoaEvent cocoaEvent;
 64614: 	
 96897:   nsMouseEvent geckoEvent(true, NS_MOUSE_BUTTON_UP, mGeckoChild, nsMouseEvent::eReal);
  2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 38441:   if ([theEvent modifierFlags] & NSControlKeyMask)
 19247:     geckoEvent.button = nsMouseEvent::eRightButton;
 19247:   else
 19247:     geckoEvent.button = nsMouseEvent::eLeftButton;
  2315: 
 32019:   // Create event for use by plugins.
 32019:   // This is going to our child view so we don't need to look up the destination
 32019:   // event type.
 37413:   if (mIsPluginView) {
 32120:     if (mPluginEventModel == NPEventModelCocoa) {
 74102:       nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
 32019:       NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
 32019:       cocoaEvent.type = NPCocoaEventMouseUp;
 32019:       cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
 32019:       cocoaEvent.data.mouse.pluginX = point.x;
 32019:       cocoaEvent.data.mouse.pluginY = point.y;
 32019:       cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
 32019:       cocoaEvent.data.mouse.clickCount = [theEvent clickCount];
 32019:       cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
 32019:       cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
 32019:       cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
 34743:       geckoEvent.pluginEvent = &cocoaEvent;
 32019:     }
 37413:   }
     1: 
 38852:   // This might destroy our widget (and null out mGeckoChild).
 18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 11978: 
 37413:   // If our mouse-up event's location is over some other object (as might
 37413:   // happen if it came at the end of a dragging operation), also send our
 37413:   // Gecko frame a mouse-exit event.
 38852:   if (mGeckoChild && mIsPluginView) {
118918:     if (mPluginEventModel == NPEventModelCocoa) {
 37413:       if (ChildViewMouseTracker::ViewForEvent(theEvent) != self) {
 96897:         nsMouseEvent geckoExitEvent(true, NS_MOUSE_EXIT, mGeckoChild, nsMouseEvent::eReal);
 37413:         [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoExitEvent];
 37413: 
 37413:         NPCocoaEvent cocoaEvent;
 74102:         nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
 37413:         NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
 37413:         cocoaEvent.type = NPCocoaEventMouseExited;
 37413:         cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
 37413:         cocoaEvent.data.mouse.pluginX = point.x;
 37413:         cocoaEvent.data.mouse.pluginY = point.y;
 37413:         cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
 37413:         cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
 37413:         cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
 37413:         cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
 37413:         geckoExitEvent.pluginEvent = &cocoaEvent;
 37413: 
 37413:         mGeckoChild->DispatchWindowEvent(geckoExitEvent);
 37413:       }
 37413:     }
 37413:   }
 37413: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
 32976: - (void)sendMouseEnterOrExitEvent:(NSEvent*)aEvent
 32976:                             enter:(BOOL)aEnter
 32976:                              type:(nsMouseEvent::exitType)aType
 32976: {
 32976:   if (!mGeckoChild)
 32976:     return;
 32976: 
 32976:   NSPoint windowEventLocation = nsCocoaUtils::EventLocationForWindow(aEvent, [self window]);
 32976:   NSPoint localEventLocation = [self convertPoint:windowEventLocation fromView:nil];
 32976: 
108991:   uint32_t msg = aEnter ? NS_MOUSE_ENTER : NS_MOUSE_EXIT;
 79564:   nsMouseEvent event(true, msg, mGeckoChild, nsMouseEvent::eReal);
115495:   event.refPoint = mGeckoChild->CocoaPointsToDevPixels(localEventLocation);
  2315: 
 32019:   // Create event for use by plugins.
 32976:   // This is going to our child view so we don't need to look up the destination
 32976:   // event type.
 34700:   NPCocoaEvent cocoaEvent;
 34700:   if (mIsPluginView) {
 32976:     if (mPluginEventModel == NPEventModelCocoa) {
 74102:       nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
 32019:       cocoaEvent.type = ((msg == NS_MOUSE_ENTER) ? NPCocoaEventMouseEntered : NPCocoaEventMouseExited);
 32976:       cocoaEvent.data.mouse.modifierFlags = [aEvent modifierFlags];
 32019:       cocoaEvent.data.mouse.pluginX = 5;
 32019:       cocoaEvent.data.mouse.pluginY = 5;
 32976:       cocoaEvent.data.mouse.buttonNumber = [aEvent buttonNumber];
 32976:       cocoaEvent.data.mouse.deltaX = [aEvent deltaX];
 32976:       cocoaEvent.data.mouse.deltaY = [aEvent deltaY];
 32976:       cocoaEvent.data.mouse.deltaZ = [aEvent deltaZ];
 34743:       event.pluginEvent = &cocoaEvent;
 32019:     }
 34700:   }
  5762: 
 32976:   event.exit = aType;
 32976: 
 32976:   nsEventStatus status; // ignored
 32976:   mGeckoChild->DispatchEvent(&event, status);
 32976: }
 32976: 
 32976: - (void)handleMouseMoved:(NSEvent*)theEvent
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
  2462:   if (!mGeckoChild)
  2462:     return;
  2462: 
 96897:   nsMouseEvent geckoEvent(true, NS_MOUSE_MOVE, mGeckoChild, nsMouseEvent::eReal);
  2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
  2315: 
 32019:   // Create event for use by plugins.
 32019:   // This is going to our child view so we don't need to look up the destination
 32019:   // event type.
 34700:   NPCocoaEvent cocoaEvent;
 34700:   if (mIsPluginView) {
 32120:     if (mPluginEventModel == NPEventModelCocoa) {
 74102:       nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
 32019:       NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
 32019:       cocoaEvent.type = NPCocoaEventMouseMoved;
 32019:       cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
 32019:       cocoaEvent.data.mouse.pluginX = point.x;
 32019:       cocoaEvent.data.mouse.pluginY = point.y;
 32019:       cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
 32019:       cocoaEvent.data.mouse.clickCount = [theEvent clickCount];
 32019:       cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
 32019:       cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
 32019:       cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
 34743:       geckoEvent.pluginEvent = &cocoaEvent;
 32019:     }
 34700:   }
 18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: - (void)mouseDragged:(NSEvent*)theEvent
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
  2462:   if (!mGeckoChild)
  2462:     return;
  2462: 
  6245:   gLastDragView = self;
     1: 
 64614:   NPCocoaEvent cocoaEvent;
 64614: 
 96897:   nsMouseEvent geckoEvent(true, NS_MOUSE_MOVE, mGeckoChild, nsMouseEvent::eReal);
  2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
  2315: 
 32019:   // create event for use by plugins
 37413:   if (mIsPluginView) {
 32120:     if (mPluginEventModel == NPEventModelCocoa) {
 74102:       nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
 32019:       NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
 32019:       cocoaEvent.type = NPCocoaEventMouseDragged;
 32019:       cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
 32019:       cocoaEvent.data.mouse.pluginX = point.x;
 32019:       cocoaEvent.data.mouse.pluginY = point.y;
 32019:       cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
 32019:       cocoaEvent.data.mouse.clickCount = [theEvent clickCount];
 32019:       cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
 32019:       cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
 32019:       cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
 34743:       geckoEvent.pluginEvent = &cocoaEvent;
 32019:     }
 37413:   }
     1: 
 18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
     1: 
 10305:   // Note, sending the above event might have destroyed our widget since we didn't retain.
 10305:   // Fine so long as we don't access any local variables from here on.
  6245:   gLastDragView = nil;
 34629: 
     1:   // XXX maybe call markedTextSelectionChanged:client: here?
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: - (void)rightMouseDown:(NSEvent *)theEvent
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 10305: 
  8345:   [self maybeRollup:theEvent];
  2462:   if (!mGeckoChild)
  2462:     return;
  2462: 
     1:   // The right mouse went down, fire off a right mouse down event to gecko
 96897:   nsMouseEvent geckoEvent(true, NS_MOUSE_BUTTON_DOWN, mGeckoChild, nsMouseEvent::eReal);
  2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
     1:   geckoEvent.button = nsMouseEvent::eRightButton;
  2315:   geckoEvent.clickCount = [theEvent clickCount];
  2315: 
 32019:   // create event for use by plugins
 32120:   NPCocoaEvent cocoaEvent;
 32120:   if (mPluginEventModel == NPEventModelCocoa) {
 74102:     nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
 32019:     NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
 32019:     cocoaEvent.type = NPCocoaEventMouseDown;
 32019:     cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
 32019:     cocoaEvent.data.mouse.pluginX = point.x;
 32019:     cocoaEvent.data.mouse.pluginY = point.y;
 32019:     cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
 32019:     cocoaEvent.data.mouse.clickCount = [theEvent clickCount];
 32019:     cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
 32019:     cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
 32019:     cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
 34743:     geckoEvent.pluginEvent = &cocoaEvent;
 32019:   }
     1: 
 71158:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 10305:   if (!mGeckoChild)
 10305:     return;
 10305: 
 71158:   // Let the superclass do the context menu stuff.
 71158:   [super rightMouseDown:theEvent];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: - (void)rightMouseUp:(NSEvent *)theEvent
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
  2462:   if (!mGeckoChild)
  2462:     return;
  2462: 
 64614:   NPCocoaEvent cocoaEvent;
 64614: 
 96897:   nsMouseEvent geckoEvent(true, NS_MOUSE_BUTTON_UP, mGeckoChild, nsMouseEvent::eReal);
  2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
     1:   geckoEvent.button = nsMouseEvent::eRightButton;
  2315:   geckoEvent.clickCount = [theEvent clickCount];
  2315: 
 32019:   // create event for use by plugins
 37413:   if (mIsPluginView) {
 32120:     if (mPluginEventModel == NPEventModelCocoa) {
 74102:       nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
 32019:       NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
 32019:       cocoaEvent.type = NPCocoaEventMouseUp;
 32019:       cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
 32019:       cocoaEvent.data.mouse.pluginX = point.x;
 32019:       cocoaEvent.data.mouse.pluginY = point.y;
 32019:       cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
 32019:       cocoaEvent.data.mouse.clickCount = [theEvent clickCount];
 32019:       cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
 32019:       cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
 32019:       cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
 34743:       geckoEvent.pluginEvent = &cocoaEvent;
 32019:     }
 37413:   }
     1: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
  3574: - (void)rightMouseDragged:(NSEvent*)theEvent
  3574: {
  3574:   if (!mGeckoChild)
  3574:     return;
  3574: 
 96897:   nsMouseEvent geckoEvent(true, NS_MOUSE_MOVE, mGeckoChild, nsMouseEvent::eReal);
  3574:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
  3574:   geckoEvent.button = nsMouseEvent::eRightButton;
  3574: 
  3574:   // send event into Gecko by going directly to the
  3574:   // the widget.
 18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
  3574: }
  3574: 
     1: - (void)otherMouseDown:(NSEvent *)theEvent
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 10305: 
 32976:   if ([self maybeRollup:theEvent] ||
 47792:       !ChildViewMouseTracker::WindowAcceptsEvent([self window], theEvent, self))
  7637:     return;
  3574: 
  2462:   if (!mGeckoChild)
  2462:     return;
  2462: 
 96897:   nsMouseEvent geckoEvent(true, NS_MOUSE_BUTTON_DOWN, mGeckoChild, nsMouseEvent::eReal);
  2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
  2315:   geckoEvent.button = nsMouseEvent::eMiddleButton;
     1:   geckoEvent.clickCount = [theEvent clickCount];
  2315: 
 18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: - (void)otherMouseUp:(NSEvent *)theEvent
     1: {
  2462:   if (!mGeckoChild)
  2462:     return;
  2462: 
 96897:   nsMouseEvent geckoEvent(true, NS_MOUSE_BUTTON_UP, mGeckoChild, nsMouseEvent::eReal);
  2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
     1:   geckoEvent.button = nsMouseEvent::eMiddleButton;
     1: 
 18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
     1: }
     1: 
  3574: - (void)otherMouseDragged:(NSEvent*)theEvent
  3574: {
  3574:   if (!mGeckoChild)
  3574:     return;
  3574: 
 96897:   nsMouseEvent geckoEvent(true, NS_MOUSE_MOVE, mGeckoChild, nsMouseEvent::eReal);
  3574:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
  3574:   geckoEvent.button = nsMouseEvent::eMiddleButton;
  3574: 
  3574:   // send event into Gecko by going directly to the
  3574:   // the widget.
 18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
  3574: }
  3574: 
108991: static int32_t RoundUp(double aDouble)
108991: {
108991:   return aDouble < 0 ? static_cast<int32_t>(floor(aDouble)) :
108991:                        static_cast<int32_t>(ceil(aDouble));
108072: }
108072: 
108072: - (void)scrollWheel:(NSEvent*)theEvent
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
108072:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
108072: 
108072:   ChildViewMouseTracker::MouseScrolled(theEvent);
108072: 
108072:   if ([self maybeRollup:theEvent]) {
  2462:     return;
108072:   }
108072: 
108072:   if (!mGeckoChild) {
108072:     return;
108072:   }
108072: 
108072:   WheelEvent wheelEvent(true, NS_WHEEL_WHEEL, mGeckoChild);
108072:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&wheelEvent];
108072:   wheelEvent.deltaMode =
108072:     Preferences::GetBool("mousewheel.enable_pixel_scrolling", true) ?
108072:       nsIDOMWheelEvent::DOM_DELTA_PIXEL : nsIDOMWheelEvent::DOM_DELTA_LINE;
 19319: 
 19319:   // Calling deviceDeltaX or deviceDeltaY on theEvent will trigger a Cocoa
 19319:   // assertion and an Objective-C NSInternalInconsistencyException if the
 19319:   // underlying "Carbon" event doesn't contain pixel scrolling information.
 19319:   // For these events, carbonEventKind is kEventMouseWheelMoved instead of
 19319:   // kEventMouseScroll.
108072:   if (wheelEvent.deltaMode == nsIDOMWheelEvent::DOM_DELTA_PIXEL) {
 33236:     EventRef theCarbonEvent = [theEvent _eventRef];
 33236:     UInt32 carbonEventKind = theCarbonEvent ? ::GetEventKind(theCarbonEvent) : 0;
108072:     if (carbonEventKind != kEventMouseScroll) {
108072:       wheelEvent.deltaMode = nsIDOMWheelEvent::DOM_DELTA_LINE;
108072:     }
108072:   }
108072: 
108072:   wheelEvent.lineOrPageDeltaX = RoundUp(-[theEvent deltaX]);
108072:   wheelEvent.lineOrPageDeltaY = RoundUp(-[theEvent deltaY]);
108072: 
108072:   if (wheelEvent.deltaMode == nsIDOMWheelEvent::DOM_DELTA_PIXEL) {
 19319:     // Some scrolling devices supports pixel scrolling, e.g. a Macbook
102626:     // touchpad or a Mighty Mouse. On those devices, [theEvent deviceDeltaX/Y]
102626:     // contains the amount of pixels to scroll. Since Lion this has changed 
102626:     // to [theEvent scrollingDeltaX/Y].
115495:     double scale = mGeckoChild->BackingScaleFactor();
108072:     if ([theEvent respondsToSelector:@selector(scrollingDeltaX)]) {
115495:       wheelEvent.deltaX = -[theEvent scrollingDeltaX] * scale;
115495:       wheelEvent.deltaY = -[theEvent scrollingDeltaY] * scale;
102626:     } else {
115495:       wheelEvent.deltaX = -[theEvent deviceDeltaX] * scale;
115495:       wheelEvent.deltaY = -[theEvent deviceDeltaY] * scale;
108072:     }
102626:   } else {
108072:     wheelEvent.deltaX = -[theEvent deltaX];
108072:     wheelEvent.deltaY = -[theEvent deltaY];
108072:   }
108072: 
108072:   // TODO: We should not set deltaZ for now because we're not sure if we should
108072:   //       revert the sign.
108072:   // wheelEvent.deltaZ = [theEvent deltaZ];
108072: 
108072:   if (!wheelEvent.deltaX && !wheelEvent.deltaY && !wheelEvent.deltaZ) {
 19319:     // No sense in firing off a Gecko event.
     1:     return;
108072:   }
108072: 
108072:   wheelEvent.isMomentum = nsCocoaUtils::IsMomentumScrollEvent(theEvent);
     1: 
 34678:   NPCocoaEvent cocoaEvent;
 34678:   if (mPluginEventModel == NPEventModelCocoa) {
 74102:     nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
 34678:     NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
 34678:     cocoaEvent.type = NPCocoaEventScrollWheel;
 34678:     cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
 34678:     cocoaEvent.data.mouse.pluginX = point.x;
 34678:     cocoaEvent.data.mouse.pluginY = point.y;
 34678:     cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
 34678:     cocoaEvent.data.mouse.clickCount = 0;
 34678:     cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
 34678:     cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
108072:     cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
108072:     wheelEvent.pluginEvent = &cocoaEvent;
108072:   }
108072: 
108072:   mGeckoChild->DispatchWindowEvent(wheelEvent);
108072:   if (!mGeckoChild) {
 10305:     return;
108072:   }
     1: 
 75269: #ifdef __LP64__
108072:   // overflowDeltaX tells us when the user has tried to scroll past the edge
108072:   // of a page to the left or the right (in those cases it's non-zero).
108072:   if (wheelEvent.deltaMode == nsIDOMWheelEvent::DOM_DELTA_PIXEL &&
108072:       wheelEvent.deltaX != 0.0) {
 75269:     [self maybeTrackScrollEventAsSwipe:theEvent
108072:                         scrollOverflow:wheelEvent.overflowDeltaX];
 75269:   }
 75269: #endif // #ifdef __LP64__
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: -(NSMenu*)menuForEvent:(NSEvent*)theEvent
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
  2462:   if (!mGeckoChild || [self isPluginView])
     1:     return nil;
     1: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 10305: 
  8345:   [self maybeRollup:theEvent];
 10305:   if (!mGeckoChild)
 10305:     return nil;
  4842: 
 13976:   // Cocoa doesn't always dispatch a mouseDown: for a control-click event,
 13976:   // depends on what we return from menuForEvent:. Gecko always expects one
 13976:   // and expects the mouse down event before the context menu event, so
 13976:   // get that event sent first if this is a left mouse click.
 13976:   if ([theEvent type] == NSLeftMouseDown) {
 13976:     [self mouseDown:theEvent];
 13976:     if (!mGeckoChild)
 13609:       return nil;
 13976:   }
     1: 
 96897:   nsMouseEvent geckoEvent(true, NS_CONTEXTMENU, mGeckoChild, nsMouseEvent::eReal);
  2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
     1:   geckoEvent.button = nsMouseEvent::eRightButton;
 18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 10305:   if (!mGeckoChild)
 10305:     return nil;
  3574: 
 12394:   [self maybeInitContextMenuTracking];
 12394: 
     1:   // Go up our view chain to fetch the correct menu to return.
     1:   return [self contextMenu];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
     1: }
     1: 
     1: - (NSMenu*)contextMenu
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
     1:   NSView* superView = [self superview];
     1:   if ([superView respondsToSelector:@selector(contextMenu)])
     1:     return [(NSView<mozView>*)superView contextMenu];
     1: 
     1:   return nil;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
     1: }
     1: 
  2315: - (void) convertCocoaMouseEvent:(NSEvent*)aMouseEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent
  2315: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 47792:   NS_ASSERTION(outGeckoEvent, "convertCocoaMouseEvent:toGeckoEvent: requires non-null aoutGeckoEvent");
 47792:   if (!outGeckoEvent)
  2315:     return;
  2315: 
 96897:   nsCocoaUtils::InitInputEvent(*outGeckoEvent, aMouseEvent);
  2315: 
  2315:   // convert point to view coordinate system
 32510:   NSPoint locationInWindow = nsCocoaUtils::EventLocationForWindow(aMouseEvent, [self window]);
 31655:   NSPoint localPoint = [self convertPoint:locationInWindow fromView:nil];
115495: 
115495:   outGeckoEvent->refPoint = mGeckoChild->CocoaPointsToDevPixels(localPoint);
 11978: 
 96891:   nsMouseEvent_base* mouseEvent =
 96891:     static_cast<nsMouseEvent_base*>(outGeckoEvent);
 96891:   mouseEvent->buttons = 0;
121453:   NSUInteger mouseButtons = [NSEvent pressedMouseButtons];
 96891: 
 96891:   if (mouseButtons & 0x01) {
 96891:     mouseEvent->buttons |= nsMouseEvent::eLeftButtonFlag;
 96891:   }
 96891:   if (mouseButtons & 0x02) {
 96891:     mouseEvent->buttons |= nsMouseEvent::eRightButtonFlag;
 96891:   }
 96891:   if (mouseButtons & 0x04) {
 96891:     mouseEvent->buttons |= nsMouseEvent::eMiddleButtonFlag;
 96891:   }
 96891:   if (mouseButtons & 0x08) {
 96891:     mouseEvent->buttons |= nsMouseEvent::e4thButtonFlag;
 96891:   }
 96891:   if (mouseButtons & 0x10) {
 96891:     mouseEvent->buttons |= nsMouseEvent::e5thButtonFlag;
 96891:   }
 96891: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  2315: }
  2315: 
  2315: 
  2315: #pragma mark -
  2315: // NSTextInput implementation
  2315: 
  2315: - (void)insertText:(id)insertString
  2315: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 74098:   NS_ENSURE_TRUE(mGeckoChild, );
 33316: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
  4726: 
 74098:   NSAttributedString* attrStr;
 74098:   if ([insertString isKindOfClass:[NSAttributedString class]]) {
 74098:     attrStr = static_cast<NSAttributedString*>(insertString);
 74098:   } else {
 74098:     attrStr =
 74098:       [[[NSAttributedString alloc] initWithString:insertString] autorelease];
 74098:   }
 74098: 
 74098:   mTextInputHandler->InsertText(attrStr);
 74098: 
 74098:   NS_OBJC_END_TRY_ABORT_BLOCK;
 74098: }
 74098: 
 74098: - (void)insertNewline:(id)sender
 74098: {
 74098:   [self insertText:@"\n"];
 74098: }
 74098: 
 74098: - (void) doCommandBySelector:(SEL)aSelector
 74098: {
 74098:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 74098: 
 74103:   if (!mGeckoChild || !mTextInputHandler) {
 74103:     return;
 74103:   }
 74103: 
 74103:   const char* sel = reinterpret_cast<const char*>(aSelector);
 74103:   if (!mTextInputHandler->DoCommandBySelector(sel)) {
  2315:     [super doCommandBySelector:aSelector];
 74098:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  2315: }
  2315: 
  2315: - (void) setMarkedText:(id)aString selectedRange:(NSRange)selRange
  2315: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 69465:   NS_ENSURE_TRUE(mTextInputHandler, );
 33316: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
  4726: 
 69462:   NSAttributedString* attrStr;
 69462:   if ([aString isKindOfClass:[NSAttributedString class]]) {
 69462:     attrStr = static_cast<NSAttributedString*>(aString);
 69462:   } else {
 69462:     attrStr = [[[NSAttributedString alloc] initWithString:aString] autorelease];
 69462:   }
 69462: 
 69465:   mTextInputHandler->SetMarkedText(attrStr, selRange);
  4726: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  2315: }
  2315: 
  2315: - (void) unmarkText
  2315: {
 69465:   NS_ENSURE_TRUE(mTextInputHandler, );
 69465:   mTextInputHandler->CommitIMEComposition();
  2315: }
  2315: 
  2315: - (BOOL) hasMarkedText
  2315: {
 69465:   NS_ENSURE_TRUE(mTextInputHandler, NO);
 69465:   return mTextInputHandler->HasMarkedText();
  2315: }
  2315: 
 32120: - (NSInteger) conversationIdentifier
  2315: {
 69465:   NS_ENSURE_TRUE(mTextInputHandler, reinterpret_cast<NSInteger>(self));
 69465:   return mTextInputHandler->ConversationIdentifier();
  2315: }
  2315: 
  2315: - (NSAttributedString *) attributedSubstringFromRange:(NSRange)theRange
  2315: {
 69465:   NS_ENSURE_TRUE(mTextInputHandler, nil);
 69465:   return mTextInputHandler->GetAttributedSubstringFromRange(theRange);
  2315: }
  2315: 
  2315: - (NSRange) markedRange
  2315: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
 69465:   NS_ENSURE_TRUE(mTextInputHandler, NSMakeRange(NSNotFound, 0));
 69465:   return mTextInputHandler->MarkedRange();
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSMakeRange(0, 0));
  2315: }
  2315: 
  2315: - (NSRange) selectedRange
  2315: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
 69465:   NS_ENSURE_TRUE(mTextInputHandler, NSMakeRange(NSNotFound, 0));
 69465:   return mTextInputHandler->SelectedRange();
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSMakeRange(0, 0));
  2315: }
  2315: 
  2315: - (NSRect) firstRectForCharacterRange:(NSRange)theRange
  2315: {
 11914:   NSRect rect;
 69465:   NS_ENSURE_TRUE(mTextInputHandler, rect);
 69465:   return mTextInputHandler->FirstRectForCharacterRange(theRange);
  2315: }
  2315: 
 32120: - (NSUInteger)characterIndexForPoint:(NSPoint)thePoint
  2315: {
 69465:   NS_ENSURE_TRUE(mTextInputHandler, 0);
 69465:   return mTextInputHandler->CharacterIndexForPoint(thePoint);
  2315: }
  2315: 
  2315: - (NSArray*) validAttributesForMarkedText
  2315: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
 69465:   NS_ENSURE_TRUE(mTextInputHandler, [NSArray array]);
 69465:   return mTextInputHandler->GetValidAttributesForMarkedText();
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
  2315: }
  2315: 
  2315: #pragma mark -
  2315: 
118918: #ifdef __LP64__
 43436: - (NSTextInputContext *)inputContext
 43436: {
 43436:   if (mIsPluginView && mPluginEventModel == NPEventModelCocoa)
 43436:     return [[ComplexTextInputPanel sharedComplexTextInputPanel] inputContext];
 43436:   else
 43436:     return [super inputContext];
 43436: }
 43436: #endif
 43436: 
 50708: // This is a private API that Cocoa uses.
 50708: // Cocoa will call this after the menu system returns "NO" for "performKeyEquivalent:".
 50708: // We want all they key events we can get so just return YES. In particular, this fixes
 50708: // ctrl-tab - we don't get a "keyDown:" call for that without this.
 50708: - (BOOL)_wantsKeyDownForEvent:(NSEvent*)event
 50708: {
 50708:   return YES;
 50708: }
 50708: 
 12429: - (void)keyDown:(NSEvent*)theEvent
 12429: {
 15585:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 15585: 
 74103:   if (mGeckoChild && mTextInputHandler && mIsPluginView) {
 74099:     mTextInputHandler->HandleKeyDownEventForPlugin(theEvent);
 61078:     return;
 61078:   }
 61078: 
 74103:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 79445:   bool handled = false;
 74103:   if (mGeckoChild && mTextInputHandler) {
 74103:     handled = mTextInputHandler->HandleKeyDownEvent(theEvent);
 74103:   }
 50708: 
 50708:   // We always allow keyboard events to propagate to keyDown: but if they are not
 50708:   // handled we give special Application menu items a chance to act.
 50708:   if (!handled && sApplicationMenu) {
 50708:     [sApplicationMenu performKeyEquivalent:theEvent];
 50708:   }
 15585: 
 15585:   NS_OBJC_END_TRY_ABORT_BLOCK;
 12429: }
 12429: 
  2315: - (void)keyUp:(NSEvent*)theEvent
  2315: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 74100:   NS_ENSURE_TRUE(mGeckoChild, );
 61078: 
 15585:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 15585: 
 15585:   if (mIsPluginView) {
 74099:     mTextInputHandler->HandleKeyUpEventForPlugin(theEvent);
 15585:     return;
 15585:   }
 15585: 
 74100:   mTextInputHandler->HandleKeyUpEvent(theEvent);
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  2315: }
  2315: 
  2315: - (void)flagsChanged:(NSEvent*)theEvent
  2315: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 74100:   NS_ENSURE_TRUE(mGeckoChild, );
  2462: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 74100:   mTextInputHandler->HandleFlagsChanged(theEvent);
 20387: 
 20387:   NS_OBJC_END_TRY_ABORT_BLOCK;
 20387: }
 20387: 
 20387: - (BOOL) isFirstResponder
 20387: {
 20387:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 20387: 
 20387:   NSResponder* resp = [[self window] firstResponder];
 20387:   return (resp == (NSResponder*)self);
 20387: 
 20387:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 20387: }
 20387: 
 39094: - (BOOL)isDragInProgress
 39094: {
 39094:   if (!mDragService)
 39094:     return NO;
 39094: 
 39094:   nsCOMPtr<nsIDragSession> dragSession;
 39094:   mDragService->GetCurrentSession(getter_AddRefs(dragSession));
106838:   return dragSession != nullptr;
 39094: }
 39094: 
 47792: - (BOOL)inactiveWindowAcceptsMouseEvent:(NSEvent*)aEvent
 47792: {
 49214:   // If we're being destroyed assume the default -- return YES.
 49214:   if (!mGeckoChild)
 49214:     return YES;
 49214: 
 96897:   nsMouseEvent geckoEvent(true, NS_MOUSE_ACTIVATE, mGeckoChild, nsMouseEvent::eReal);
 47792:   [self convertCocoaMouseEvent:aEvent toGeckoEvent:&geckoEvent];
 47792:   return !mGeckoChild->DispatchWindowEvent(geckoEvent);
 47792: }
 47792: 
 63215: // Don't focus a plugin if the user has clicked on a DOM element above it.
 63215: // In this case the user has actually clicked on the plugin's ChildView
 63215: // (underneath the non-plugin DOM element).  But we shouldn't allow the
 63215: // ChildView to be focused.  See bug 627649.
 63215: - (BOOL)currentEventShouldFocusPlugin
 63215: {
 63215:   if (!mGeckoChild)
 63215:     return NO;
 63215: 
 63215:   NSEvent* currentEvent = [NSApp currentEvent];
 63215:   if ([currentEvent type] != NSLeftMouseDown)
 63215:     return YES;
 63215: 
 64515:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 64515: 
119321:   // hitTest needs coordinates in device pixels
 63215:   NSPoint eventLoc = nsCocoaUtils::ScreenLocationForEvent(currentEvent);
 63215:   eventLoc.y = nsCocoaUtils::FlippedScreenY(eventLoc.y);
119321:   nsIntPoint widgetLoc = mGeckoChild->CocoaPointsToDevPixels(eventLoc) -
119321:     mGeckoChild->WidgetToScreenOffset();
 63215: 
 79564:   nsQueryContentEvent hitTest(true, NS_QUERY_DOM_WIDGET_HITTEST, mGeckoChild);
 63215:   hitTest.InitForQueryDOMWidgetHittest(widgetLoc);
 64515:   // This might destroy our widget (and null out mGeckoChild).
 63215:   mGeckoChild->DispatchWindowEvent(hitTest);
 64515:   if (!mGeckoChild)
 64515:     return NO;
 63215:   if (hitTest.mSucceeded && !hitTest.mReply.mWidgetIsHit)
 63215:     return NO;
 63215: 
 63215:   return YES;
 63215: }
 63215: 
 57526: // Don't focus a plugin if we're in a left click-through that will fail (see
 57526: // [ChildView isInFailingLeftClickThrough] above).
 63215: - (BOOL)shouldFocusPlugin:(BOOL)getFocus
 41321: {
 41321:   if (!mGeckoChild)
 57526:     return NO;
 57526: 
 57526:   nsCocoaWindow* windowWidget = mGeckoChild->GetXULWindowWidget();
 57526:   if (windowWidget && !windowWidget->ShouldFocusPlugin())
 57526:     return NO;
 57526: 
 63215:   if (getFocus && ![self currentEventShouldFocusPlugin])
 63215:     return NO;
 63215: 
 57526:   return YES;
 57526: }
 57526: 
 57526: // Returns NO if the plugin shouldn't be focused/unfocused.
 63215: - (BOOL)updatePluginFocusStatus:(BOOL)getFocus
 57526: {
 57526:   if (!mGeckoChild)
 57526:     return NO;
 57526: 
 63215:   if (![self shouldFocusPlugin:getFocus])
 57526:     return NO;
 41321: 
 63215:   if (mPluginEventModel == NPEventModelCocoa) {
 79564:     nsPluginEvent pluginEvent(true, NS_PLUGIN_FOCUS_EVENT, mGeckoChild);
 41321:     NPCocoaEvent cocoaEvent;
 74102:     nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
 41321:     cocoaEvent.type = NPCocoaEventFocusChanged;
 63215:     cocoaEvent.data.focus.hasFocus = getFocus;
 74102:     nsCocoaUtils::InitPluginEvent(pluginEvent, cocoaEvent);
 41321:     mGeckoChild->DispatchWindowEvent(pluginEvent);
 57526: 
 63215:     if (getFocus)
 57526:       [self sendFocusEvent:NS_PLUGIN_FOCUS];
 63215:   }
 57526: 
 57526:   return YES;
 41321: }
 41321: 
 41321: // We must always call through to our superclass, even when mGeckoChild is
 41321: // nil -- otherwise the keyboard focus can end up in the wrong NSView.
 41321: - (BOOL)becomeFirstResponder
 41321: {
 41321:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 41321: 
 63215:   if (mIsPluginView) {
 63215:     if (![self updatePluginFocusStatus:YES])
 57526:       return NO;
 41321:   }
 41321: 
 41321:   return [super becomeFirstResponder];
 41321: 
 41321:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(YES);
 41321: }
 41321: 
  2677: // We must always call through to our superclass, even when mGeckoChild is
  2677: // nil -- otherwise the keyboard focus can end up in the wrong NSView.
  2315: - (BOOL)resignFirstResponder
  2315: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
 63215:   if (mIsPluginView) {
 63215:     if (![self updatePluginFocusStatus:NO])
 57526:       return NO;
 41321:   }
 41321: 
  2315:   return [super resignFirstResponder];
 11978: 
 41321:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(YES);
  2315: }
  2315: 
  2315: - (void)viewsWindowDidBecomeKey
  2315: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
  2315:   if (!mGeckoChild)
  2462:     return;
  2315: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 10305: 
  2315:   // check to see if the window implements the mozWindow protocol. This
  2315:   // allows embedders to avoid re-entrant calls to -makeKeyAndOrderFront,
 29018:   // which can happen because these activate calls propagate out
  2315:   // to the embedder via nsIEmbeddingSiteWindow::SetFocus().
  2315:   BOOL isMozWindow = [[self window] respondsToSelector:@selector(setSuppressMakeKeyFront:)];
  2315:   if (isMozWindow)
  2315:     [[self window] setSuppressMakeKeyFront:YES];
  2315: 
108457:   nsIWidgetListener* listener = mGeckoChild->GetWidgetListener();
108457:   if (listener)
108457:     listener->WindowActivated();
  2315: 
  2315:   if (isMozWindow)
  2315:     [[self window] setSuppressMakeKeyFront:NO];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  2315: }
  2315: 
  2315: - (void)viewsWindowDidResignKey
  2315: {
  2315:   if (!mGeckoChild)
  2462:     return;
  2315: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 10305: 
108457:   nsIWidgetListener* listener = mGeckoChild->GetWidgetListener();
108457:   if (listener)
108457:     listener->WindowDeactivated();
  2315: }
  2315: 
  2677: // If the call to removeFromSuperview isn't delayed from nsChildView::
  2677: // TearDownView(), the NSView hierarchy might get changed during calls to
  2677: // [ChildView drawRect:], which leads to "beyond bounds" exceptions in
  2677: // NSCFArray.  For more info see bmo bug 373122.  Apple's docs claim that
  2315: // removeFromSuperviewWithoutNeedingDisplay "can be safely invoked during
  2315: // display" (whatever "display" means).  But it's _not_ true that it can be
  2677: // safely invoked during calls to [NSView drawRect:].  We use
  2677: // removeFromSuperview here because there's no longer any danger of being
  2677: // "invoked during display", and because doing do clears up bmo bug 384343.
  2315: - (void)delayedTearDown
  2315: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
  2677:   [self removeFromSuperview];
  2315:   [self release];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  2315: }
  2315: 
     1: #pragma mark -
     1: 
     1: // drag'n'drop stuff
     1: #define kDragServiceContractID "@mozilla.org/widget/dragservice;1"
     1: 
 39094: - (NSDragOperation)dragOperationForSession:(nsIDragSession*)aDragSession
 39094: {
108991:   uint32_t dragAction;
 39094:   aDragSession->GetDragAction(&dragAction);
 39094:   if (nsIDragService::DRAGDROP_ACTION_LINK & dragAction)
 39094:     return NSDragOperationLink;
 39094:   if (nsIDragService::DRAGDROP_ACTION_COPY & dragAction)
 39094:     return NSDragOperationCopy;
 39094:   if (nsIDragService::DRAGDROP_ACTION_MOVE & dragAction)
 39094:     return NSDragOperationGeneric;
 39094:   return NSDragOperationNone;
 39094: }
 39094: 
     1: // This is a utility function used by NSView drag event methods
     1: // to send events. It contains all of the logic needed for Gecko
 39094: // dragging to work. Returns the appropriate cocoa drag operation code.
108991: - (NSDragOperation)doDragAction:(uint32_t)aMessage sender:(id)aSender
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
  2958:   if (!mGeckoChild)
 39094:     return NSDragOperationNone;
     1: 
  3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView doDragAction: entered\n"));
  3545: 
  2958:   if (!mDragService) {
  2958:     CallGetService(kDragServiceContractID, &mDragService);
  2958:     NS_ASSERTION(mDragService, "Couldn't get a drag service - big problem!");
  2958:     if (!mDragService)
 39094:       return NSDragOperationNone;
  2958:   }
  2958: 
     1:   if (aMessage == NS_DRAGDROP_ENTER)
     1:     mDragService->StartDragSession();
     1: 
     1:   nsCOMPtr<nsIDragSession> dragSession;
     1:   mDragService->GetCurrentSession(getter_AddRefs(dragSession));
     1:   if (dragSession) {
   482:     if (aMessage == NS_DRAGDROP_OVER) {
   482:       // fire the drag event at the source. Just ignore whether it was
   482:       // cancelled or not as there isn't actually a means to stop the drag
   482:       mDragService->FireDragEventAtSource(NS_DRAGDROP_DRAG);
 79564:       dragSession->SetCanDrop(false);
   482:     }
     1:     else if (aMessage == NS_DRAGDROP_DROP) {
 16085:       // We make the assumption that the dragOver handlers have correctly set
     1:       // the |canDrop| property of the Drag Session.
 79445:       bool canDrop = false;
 18445:       if (!NS_SUCCEEDED(dragSession->GetCanDrop(&canDrop)) || !canDrop) {
 37791:         [self doDragAction:NS_DRAGDROP_EXIT sender:aSender];
 37791: 
 18445:         nsCOMPtr<nsIDOMNode> sourceNode;
 18445:         dragSession->GetSourceNode(getter_AddRefs(sourceNode));
 18445:         if (!sourceNode) {
 79564:           mDragService->EndDragSession(false);
 18445:         }
 39094:         return NSDragOperationNone;
     1:       }
 18445:     }
     1:     
 38441:     unsigned int modifierFlags = [[NSApp currentEvent] modifierFlags];
108991:     uint32_t action = nsIDragService::DRAGDROP_ACTION_MOVE;
     1:     // force copy = option, alias = cmd-option, default is move
     1:     if (modifierFlags & NSAlternateKeyMask) {
     1:       if (modifierFlags & NSCommandKeyMask)
     1:         action = nsIDragService::DRAGDROP_ACTION_LINK;
     1:       else
     1:         action = nsIDragService::DRAGDROP_ACTION_COPY;
     1:     }
     1:     dragSession->SetDragAction(action);
     1:   }
     1: 
  6754:   // set up gecko event
 96897:   nsDragEvent geckoEvent(true, aMessage, mGeckoChild);
 96897:   nsCocoaUtils::InitInputEvent(geckoEvent, [NSApp currentEvent]);
  6754: 
  6754:   // Use our own coordinates in the gecko event.
  6754:   // Convert event from gecko global coords to gecko view coords.
115495:   NSPoint draggingLoc = [aSender draggingLocation];
115495:   NSPoint localPoint = [self convertPoint:draggingLoc fromView:nil];
115495: 
115495:   geckoEvent.refPoint = mGeckoChild->CocoaPointsToDevPixels(localPoint);
  6754: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
  6754:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 10305:   if (!mGeckoChild)
 39094:     return NSDragOperationNone;
 39094: 
 39094:   if (dragSession) {
 39094:     switch (aMessage) {
 39094:       case NS_DRAGDROP_ENTER:
 39094:       case NS_DRAGDROP_OVER:
 39094:         return [self dragOperationForSession:dragSession];
 39094:       case NS_DRAGDROP_EXIT:
 39094:       case NS_DRAGDROP_DROP: {
     1:         nsCOMPtr<nsIDOMNode> sourceNode;
     1:         dragSession->GetSourceNode(getter_AddRefs(sourceNode));
     1:         if (!sourceNode) {
     1:           // We're leaving a window while doing a drag that was
     1:           // initiated in a different app. End the drag session,
     1:           // since we're done with it for now (until the user
     1:           // drags back into mozilla).
 79564:           mDragService->EndDragSession(false);
     1:         }
     1:       }
 39094:     }
 39094:   }
 39094: 
 39094:   return NSDragOperationGeneric;
 39094: 
 39094:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSDragOperationNone);
     1: }
     1: 
     1: - (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
  3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingEntered: entered\n"));
  3545:   
     1:   // there should never be a globalDragPboard when "draggingEntered:" is
     1:   // called, but just in case we'll take care of it here.
     1:   [globalDragPboard release];
     1: 
     1:   // Set the global drag pasteboard that will be used for this drag session.
     1:   // This will be set back to nil when the drag session ends (mouse exits
     1:   // the view or a drop happens within the view).
     1:   globalDragPboard = [[sender draggingPasteboard] retain];
     1: 
 39094:   return [self doDragAction:NS_DRAGDROP_ENTER sender:sender];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSDragOperationNone);
     1: }
     1: 
     1: - (NSDragOperation)draggingUpdated:(id <NSDraggingInfo>)sender
     1: {
  3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingUpdated: entered\n"));
  3545: 
 39094:   return [self doDragAction:NS_DRAGDROP_OVER sender:sender];
     1: }
     1: 
     1: - (void)draggingExited:(id <NSDraggingInfo>)sender
     1: {
  3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingExited: entered\n"));
  3545: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
     1:   [self doDragAction:NS_DRAGDROP_EXIT sender:sender];
  6789:   NS_IF_RELEASE(mDragService);
  2958: }
  2958: 
  2958: - (BOOL)performDragOperation:(id <NSDraggingInfo>)sender
  2958: {
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 39094:   BOOL handled = [self doDragAction:NS_DRAGDROP_DROP sender:sender] != NSDragOperationNone;
  6789:   NS_IF_RELEASE(mDragService);
  6789:   return handled;
  2958: }
  2958: 
  2958: // NSDraggingSource
 77050: - (void)draggedImage:(NSImage *)anImage movedTo:(NSPoint)aPoint
 77050: {
 77050:   // Get the drag service if it isn't already cached. The drag service
 77050:   // isn't cached when dragging over a different application.
 77050:   nsCOMPtr<nsIDragService> dragService = mDragService;
 77050:   if (!dragService) {
 77050:     dragService = do_GetService(kDragServiceContractID);
 77050:   }
 77050: 
 77050:   if (dragService) {
 77050:     NSPoint pnt = [NSEvent mouseLocation];
 77050:     FlipCocoaScreenCoordinate(pnt);
 77050:     dragService->DragMoved(NSToIntRound(pnt.x), NSToIntRound(pnt.y));
 77050:   }
 77050: }
 77050: 
 77050: // NSDraggingSource
  2958: - (void)draggedImage:(NSImage *)anImage endedAt:(NSPoint)aPoint operation:(NSDragOperation)operation
  2958: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
106838:   gDraggedTransferables = nullptr;
  3592: 
 25064:   NSEvent *currentEvent = [NSApp currentEvent];
 25064:   gUserCancelledDrag = ([currentEvent type] == NSKeyDown &&
103582:                         [currentEvent keyCode] == kVK_Escape);
 25064: 
  2958:   if (!mDragService) {
  2958:     CallGetService(kDragServiceContractID, &mDragService);
  2958:     NS_ASSERTION(mDragService, "Couldn't get a drag service - big problem!");
  2958:   }
  2958: 
  2958:   if (mDragService) {
 27257:     // set the dragend point from the current mouse location
 27257:     nsDragService* dragService = static_cast<nsDragService *>(mDragService);
 27257:     NSPoint pnt = [NSEvent mouseLocation];
 27257:     FlipCocoaScreenCoordinate(pnt);
 27401:     dragService->SetDragEndPoint(nsIntPoint(NSToIntRound(pnt.x), NSToIntRound(pnt.y)));
 27257: 
 28780:     // XXX: dropEffect should be updated per |operation|. 
 28780:     // As things stand though, |operation| isn't well handled within "our"
 28780:     // events, that is, when the drop happens within the window: it is set
 28780:     // either to NSDragOperationGeneric or to NSDragOperationNone.
 28780:     // For that reason, it's not yet possible to override dropEffect per the
 28780:     // given OS value, and it's also unclear what's the correct dropEffect 
 28780:     // value for NSDragOperationGeneric that is passed by other applications.
 28780:     // All that said, NSDragOperationNone is still reliable.
 28780:     if (operation == NSDragOperationNone) {
 28780:       nsCOMPtr<nsIDOMDataTransfer> dataTransfer;
 28780:       dragService->GetDataTransfer(getter_AddRefs(dataTransfer));
 89615:       if (dataTransfer)
 89615:         dataTransfer->SetDropEffectInt(nsIDragService::DRAGDROP_ACTION_NONE);
 28780:     }
 28780: 
 79564:     mDragService->EndDragSession(true);
  2958:     NS_RELEASE(mDragService);
  2958:   }
  2958: 
     1:   [globalDragPboard release];
     1:   globalDragPboard = nil;
 34629:   [gLastDragMouseDownEvent release];
 34629:   gLastDragMouseDownEvent = nil;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
  2958: // NSDraggingSource
  2958: // this is just implemented so we comply with the NSDraggingSource informal protocol
 32120: - (NSDragOperation)draggingSourceOperationMaskForLocal:(BOOL)isLocal
     1: {
  2958:   return UINT_MAX;
     1: }
     1: 
  3545: // This method is a callback typically invoked in response to a drag ending on the desktop
  3545: // or a Findow folder window; the argument passed is a path to the drop location, to be used
  3545: // in constructing a complete pathname for the file(s) we want to create as a result of
  3545: // the drag.
 32120: - (NSArray *)namesOfPromisedFilesDroppedAtDestination:(NSURL*)dropDestination
  3545: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
  3545:   nsresult rv;
  3545: 
  3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView namesOfPromisedFilesDroppedAtDestination: entering callback for promised files\n"));
  3545: 
101111:   nsCOMPtr<nsIFile> targFile;
 79564:   NS_NewLocalFile(EmptyString(), true, getter_AddRefs(targFile));
  3545:   nsCOMPtr<nsILocalFileMac> macLocalFile = do_QueryInterface(targFile);
  3545:   if (!macLocalFile) {
  3545:     NS_ERROR("No Mac local file");
  3545:     return nil;
  3545:   }
  3545: 
  3545:   if (!NS_SUCCEEDED(macLocalFile->InitWithCFURL((CFURLRef)dropDestination))) {
  3545:     NS_ERROR("failed InitWithCFURL");
  3545:     return nil;
  3545:   }
  3545: 
  3592:   if (!gDraggedTransferables)
  3592:     return nil;
  3545: 
108991:   uint32_t transferableCount;
  3592:   rv = gDraggedTransferables->Count(&transferableCount);
  3545:   if (NS_FAILED(rv))
  3545:     return nil;
  3545: 
108991:   for (uint32_t i = 0; i < transferableCount; i++) {
  3545:     nsCOMPtr<nsISupports> genericItem;
  3592:     gDraggedTransferables->GetElementAt(i, getter_AddRefs(genericItem));
  3545:     nsCOMPtr<nsITransferable> item(do_QueryInterface(genericItem));
  3545:     if (!item) {
  3545:       NS_ERROR("no transferable");
  3545:       return nil;
  3545:     }
106838:     item->Init(nullptr);
  3545: 
101111:     item->SetTransferData(kFilePromiseDirectoryMime, macLocalFile, sizeof(nsIFile*));
  3545:     
  3545:     // now request the kFilePromiseMime data, which will invoke the data provider
  3545:     // If successful, the returned data is a reference to the resulting file.
  3545:     nsCOMPtr<nsISupports> fileDataPrimitive;
108991:     uint32_t dataSize = 0;
  3545:     item->GetTransferData(kFilePromiseMime, getter_AddRefs(fileDataPrimitive), &dataSize);
  3545:   }
  3545:   
  3545:   NSPasteboard* generalPboard = [NSPasteboard pasteboardWithName:NSDragPboard];
  3545:   NSData* data = [generalPboard dataForType:@"application/x-moz-file-promise-dest-filename"];
  3545:   NSString* name = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
  3545:   NSArray* rslt = [NSArray arrayWithObject:name];
  3545: 
  3545:   [name release];
  3545: 
  3545:   return rslt;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
  3545: }
     1: 
 22821: #pragma mark -
 22821: 
 22821: // Support for the "Services" menu. We currently only support sending strings
 26757: // and HTML to system services.
 22821: 
 22821: - (id)validRequestorForSendType:(NSString *)sendType
 22821:                      returnType:(NSString *)returnType
 22821: {
 22821:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 22821: 
 22821:   // sendType contains the type of data that the service would like this
 22821:   // application to send to it.  sendType is nil if the service is not
 22821:   // requesting any data.
 22821:   //
 22821:   // returnType contains the type of data the the service would like to
 22821:   // return to this application (e.g., to overwrite the selection).
 22821:   // returnType is nil if the service will not return any data.
 22821:   //
 22821:   // The following condition thus triggers when the service expects a string
 36983:   // or HTML from us or no data at all AND when the service will either not
 36983:   // send back any data to us or will send a string or HTML back to us.
 36983: 
 36983: #define IsSupportedType(typeStr) ([typeStr isEqual:NSStringPboardType] || [typeStr isEqual:NSHTMLPboardType])
 36983: 
 36983:   id result = nil;
 36983: 
 36983:   if ((!sendType || IsSupportedType(sendType)) &&
 36983:       (!returnType || IsSupportedType(returnType))) {
 22821:     if (mGeckoChild) {
 36983:       // Assume that this object will be able to handle this request.
 36983:       result = self;
 36983: 
 36983:       // Keep the ChildView alive during this operation.
 22821:       nsAutoRetainCocoaObject kungFuDeathGrip(self);
 26757:       
 36983:       // Determine if there is a selection (if sending to the service).
 36983:       if (sendType) {
 79564:         nsQueryContentEvent event(true, NS_QUERY_CONTENT_STATE, mGeckoChild);
 39229:         // This might destroy our widget (and null out mGeckoChild).
 26757:         mGeckoChild->DispatchWindowEvent(event);
 39229:         if (!mGeckoChild || !event.mSucceeded || !event.mReply.mHasSelection)
 36983:           result = nil;
 36983:       }
 36983: 
 36983:       // Determine if we can paste (if receiving data from the service).
 39229:       if (mGeckoChild && returnType) {
 79564:         nsContentCommandEvent command(true, NS_CONTENT_COMMAND_PASTE_TRANSFERABLE, mGeckoChild, true);
 39229:         // This might possibly destroy our widget (and null out mGeckoChild).
 36983:         mGeckoChild->DispatchWindowEvent(command);
 39229:         if (!mGeckoChild || !command.mSucceeded || !command.mIsEnabled)
 36983:           result = nil;
 36983:       }
 36983:     }
 36983:   }
 36983: 
 36983: #undef IsSupportedType
 36983: 
 36983:   // Give the superclass a chance if this object will not handle this request.
 36983:   if (!result)
 36983:     result = [super validRequestorForSendType:sendType returnType:returnType];
 36983: 
 36983:   return result;
 22821: 
 22821:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 22821: }
 22821: 
 22821: - (BOOL)writeSelectionToPasteboard:(NSPasteboard *)pboard
 22821:                              types:(NSArray *)types
 22821: {
 22821:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 22821: 
 22821:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 22821: 
 26757:   // Make sure that the service will accept strings or HTML.
 26757:   if ([types containsObject:NSStringPboardType] == NO &&
 26757:       [types containsObject:NSHTMLPboardType] == NO)
 22821:     return NO;
 22821: 
 26757:   // Bail out if there is no Gecko object.
 22821:   if (!mGeckoChild)
 22821:     return NO;
 26757: 
 26757:   // Obtain the current selection.
 79564:   nsQueryContentEvent event(true,
 26757:                             NS_QUERY_SELECTION_AS_TRANSFERABLE,
 26757:                             mGeckoChild);
 26757:   mGeckoChild->DispatchWindowEvent(event);
 26757:   if (!event.mSucceeded || !event.mReply.mTransferable)
 22821:     return NO;
 22821: 
 26757:   // Transform the transferable to an NSDictionary.
 26757:   NSDictionary* pasteboardOutputDict = nsClipboard::PasteboardDictFromTransferable(event.mReply.mTransferable);
 26757:   if (!pasteboardOutputDict)
 26757:     return NO;
 26757: 
 26757:   // Declare the pasteboard types.
 26757:   unsigned int typeCount = [pasteboardOutputDict count];
 26757:   NSMutableArray * types = [NSMutableArray arrayWithCapacity:typeCount];
 26757:   [types addObjectsFromArray:[pasteboardOutputDict allKeys]];
 26757:   [pboard declareTypes:types owner:nil];
 26757: 
 26757:   // Write the data to the pasteboard.
 26757:   for (unsigned int i = 0; i < typeCount; i++) {
 26757:     NSString* currentKey = [types objectAtIndex:i];
 26757:     id currentValue = [pasteboardOutputDict valueForKey:currentKey];
 26757: 
 26757:     if (currentKey == NSStringPboardType ||
 26757:         currentKey == kCorePboardType_url ||
 26757:         currentKey == kCorePboardType_urld ||
 26757:         currentKey == kCorePboardType_urln) {
 26757:       [pboard setString:currentValue forType:currentKey];
 26757:     } else if (currentKey == NSHTMLPboardType) {
 26757:       [pboard setString:(nsClipboard::WrapHtmlForSystemPasteboard(currentValue)) forType:currentKey];
 26757:     } else if (currentKey == NSTIFFPboardType) {
 26757:       [pboard setData:currentValue forType:currentKey];
 26757:     } else if (currentKey == NSFilesPromisePboardType) {
 26757:       [pboard setPropertyList:currentValue forType:currentKey];        
 26757:     }
 26757:   }
 26757: 
 26757:   return YES;
 22821: 
 22821:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 22821: }
 22821: 
 36983: // Called if the service wants us to replace the current selection.
 22821: - (BOOL)readSelectionFromPasteboard:(NSPasteboard *)pboard
 22821: {
 36983:   nsresult rv;
 36983:   nsCOMPtr<nsITransferable> trans = do_CreateInstance("@mozilla.org/widget/transferable;1", &rv);
 36983:   if (NS_FAILED(rv))
 22821:     return NO;
106838:   trans->Init(nullptr);
 36983: 
 36983:   trans->AddDataFlavor(kUnicodeMime);
 36983:   trans->AddDataFlavor(kHTMLMime);
 36983: 
 36983:   rv = nsClipboard::TransferableFromPasteboard(trans, pboard);
 36983:   if (NS_FAILED(rv))
 36983:     return NO;
 36983: 
 79564:   NS_ENSURE_TRUE(mGeckoChild, false);
 79564: 
 79564:   nsContentCommandEvent command(true,
 36983:                                 NS_CONTENT_COMMAND_PASTE_TRANSFERABLE,
 36983:                                 mGeckoChild);
 36983:   command.mTransferable = trans;
 36983:   mGeckoChild->DispatchWindowEvent(command);
 36983:   
 36983:   return command.mSucceeded && command.mIsEnabled;
 22821: }
 22821: 
     1: #pragma mark -
     1: 
     1: #ifdef ACCESSIBILITY
     1: 
     1: /* Every ChildView has a corresponding mozDocAccessible object that is doing all
     1:    the heavy lifting. The topmost ChildView corresponds to a mozRootAccessible
     1:    object.
     1: 
     1:    All ChildView needs to do is to route all accessibility calls (from the NSAccessibility APIs)
     1:    down to its object, pretending that they are the same.
     1: */
     1: - (id<mozAccessible>)accessible
     1: {
  2462:   if (!mGeckoChild)
  2462:     return nil;
  2462: 
     1:   id<mozAccessible> nativeAccessible = nil;
     1: 
 14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 10305:   nsCOMPtr<nsIWidget> kungFuDeathGrip2(mGeckoChild);
122283:   nsRefPtr<a11y::Accessible> accessible = mGeckoChild->GetDocumentAccessible();
108807:   if (!accessible)
 10305:     return nil;
     1: 
     1:   accessible->GetNativeInterface((void**)&nativeAccessible);
     1: 
     1: #ifdef DEBUG_hakan
     1:   NSAssert(![nativeAccessible isExpired], @"native acc is expired!!!");
     1: #endif
     1: 
     1:   return nativeAccessible;
     1: }
     1: 
     1: /* Implementation of formal mozAccessible formal protocol (enabling mozViews
     1:    to talk to mozAccessible objects in the accessibility module). */
     1: 
     1: - (BOOL)hasRepresentedView
     1: {
     1:   return YES;
     1: }
     1: 
     1: - (id)representedView
     1: {
     1:   return self;
     1: }
     1: 
     1: - (BOOL)isRoot
     1: {
     1:   return [[self accessible] isRoot];
     1: }
     1: 
     1: #ifdef DEBUG
     1: - (void)printHierarchy
     1: {
     1:   [[self accessible] printHierarchy];
     1: }
     1: #endif
     1: 
     1: #pragma mark -
     1: 
     1: // general
     1: 
     1: - (BOOL)accessibilityIsIgnored
     1: {
108807:   if (!mozilla::a11y::ShouldA11yBeEnabled())
108807:     return [super accessibilityIsIgnored];
108807: 
     1:   return [[self accessible] accessibilityIsIgnored];
     1: }
     1: 
     1: - (id)accessibilityHitTest:(NSPoint)point
     1: {
108807:   if (!mozilla::a11y::ShouldA11yBeEnabled())
108807:     return [super accessibilityHitTest:point];
108807: 
     1:   return [[self accessible] accessibilityHitTest:point];
     1: }
     1: 
     1: - (id)accessibilityFocusedUIElement
     1: {
108807:   if (!mozilla::a11y::ShouldA11yBeEnabled())
108807:     return [super accessibilityFocusedUIElement];
108807: 
     1:   return [[self accessible] accessibilityFocusedUIElement];
     1: }
     1: 
     1: // actions
     1: 
     1: - (NSArray*)accessibilityActionNames
     1: {
108807:   if (!mozilla::a11y::ShouldA11yBeEnabled())
108807:     return [super accessibilityActionNames];
108807: 
     1:   return [[self accessible] accessibilityActionNames];
     1: }
     1: 
     1: - (NSString*)accessibilityActionDescription:(NSString*)action
     1: {
108807:   if (!mozilla::a11y::ShouldA11yBeEnabled())
108807:     return [super accessibilityActionDescription:action];
108807: 
     1:   return [[self accessible] accessibilityActionDescription:action];
     1: }
     1: 
     1: - (void)accessibilityPerformAction:(NSString*)action
     1: {
108807:   if (!mozilla::a11y::ShouldA11yBeEnabled())
108807:     return [super accessibilityPerformAction:action];
108807: 
     1:   return [[self accessible] accessibilityPerformAction:action];
     1: }
     1: 
     1: // attributes
     1: 
     1: - (NSArray*)accessibilityAttributeNames
     1: {
108807:   if (!mozilla::a11y::ShouldA11yBeEnabled())
108807:     return [super accessibilityAttributeNames];
108807: 
     1:   return [[self accessible] accessibilityAttributeNames];
     1: }
     1: 
     1: - (BOOL)accessibilityIsAttributeSettable:(NSString*)attribute
     1: {
108807:   if (!mozilla::a11y::ShouldA11yBeEnabled())
108807:     return [super accessibilityIsAttributeSettable:attribute];
108807: 
     1:   return [[self accessible] accessibilityIsAttributeSettable:attribute];
     1: }
     1: 
     1: - (id)accessibilityAttributeValue:(NSString*)attribute
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
108807:   if (!mozilla::a11y::ShouldA11yBeEnabled())
108807:     return [super accessibilityAttributeValue:attribute];
108807: 
     1:   id<mozAccessible> accessible = [self accessible];
     1: 
     1:   // if we're the root (topmost) accessible, we need to return our native AXParent as we
     1:   // traverse outside to the hierarchy of whoever embeds us. thus, fall back on NSView's
     1:   // default implementation for this attribute.
     1:   if ([attribute isEqualToString:NSAccessibilityParentAttribute] && [accessible isRoot]) {
     1:     id parentAccessible = [super accessibilityAttributeValue:attribute];
     1:     return parentAccessible;
     1:   }
     1: 
     1:   return [accessible accessibilityAttributeValue:attribute];
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
     1: }
     1: 
     1: #endif /* ACCESSIBILITY */
     1: 
     1: @end
   539: 
 32976: #pragma mark -
 32976: 
 32976: void
 32976: ChildViewMouseTracker::OnDestroyView(ChildView* aView)
 32976: {
 75223:   if (sLastMouseEventView == aView) {
 32976:     sLastMouseEventView = nil;
 75392:     [sLastMouseMoveEvent release];
 75392:     sLastMouseMoveEvent = nil;
 32976:   }
 75223: }
 75223: 
 75223: void
 75223: ChildViewMouseTracker::OnDestroyWindow(NSWindow* aWindow)
 75223: {
 75223:   if (sWindowUnderMouse == aWindow) {
 75223:     sWindowUnderMouse = nil;
 75223:   }
 75223: }
 75223: 
 75223: void
 75223: ChildViewMouseTracker::MouseEnteredWindow(NSEvent* aEvent)
 75223: {
 75223:   sWindowUnderMouse = [aEvent window];
 75223:   ReEvaluateMouseEnterState(aEvent);
 75223: }
 75223: 
 75223: void
 75223: ChildViewMouseTracker::MouseExitedWindow(NSEvent* aEvent)
 75223: {
 75223:   if (sWindowUnderMouse == [aEvent window]) {
 75223:     sWindowUnderMouse = nil;
 75223:     ReEvaluateMouseEnterState(aEvent);
 75223:   }
 75223: }
 32976: 
 32976: void
 35621: ChildViewMouseTracker::ReEvaluateMouseEnterState(NSEvent* aEvent)
 32976: {
 34051:   ChildView* oldView = sLastMouseEventView;
 35621:   sLastMouseEventView = ViewForEvent(aEvent);
 35621:   if (sLastMouseEventView != oldView) {
 32976:     // Send enter and / or exit events.
 35621:     nsMouseEvent::exitType type = [sLastMouseEventView window] == [oldView window] ?
 32976:                                     nsMouseEvent::eChild : nsMouseEvent::eTopLevel;
 34051:     [oldView sendMouseEnterOrExitEvent:aEvent enter:NO type:type];
 32976:     // After the cursor exits the window set it to a visible regular arrow cursor.
 32976:     if (type == nsMouseEvent::eTopLevel) {
 32976:       [[nsCursorManager sharedInstance] setCursor:eCursor_standard];
 32976:     }
 35621:     [sLastMouseEventView sendMouseEnterOrExitEvent:aEvent enter:YES type:type];
 35621:   }
 35621: }
 35621: 
 35621: void
 75392: ChildViewMouseTracker::ResendLastMouseMoveEvent()
 75392: {
 75392:   if (sLastMouseMoveEvent) {
 75392:     MouseMoved(sLastMouseMoveEvent);
 75392:   }
 75392: }
 75392: 
 75392: void
 35621: ChildViewMouseTracker::MouseMoved(NSEvent* aEvent)
 35621: {
 75223:   MouseEnteredWindow(aEvent);
 35621:   [sLastMouseEventView handleMouseMoved:aEvent];
 75392:   if (sLastMouseMoveEvent != aEvent) {
 75392:     [sLastMouseMoveEvent release];
 75392:     sLastMouseMoveEvent = [aEvent retain];
 75392:   }
 32976: }
 32976: 
 76751: void
 76751: ChildViewMouseTracker::MouseScrolled(NSEvent* aEvent)
 76751: {
 76751:   if (!nsCocoaUtils::IsMomentumScrollEvent(aEvent)) {
 76751:     // Store the position so we can pin future momentum scroll events.
 76751:     sLastScrollEventScreenLocation = nsCocoaUtils::ScreenLocationForEvent(aEvent);
 76751:   }
 76751: }
 76751: 
 32976: ChildView*
 32976: ChildViewMouseTracker::ViewForEvent(NSEvent* aEvent)
 32976: {
 75223:   NSWindow* window = sWindowUnderMouse;
 47792:   if (!window)
 32976:     return nil;
 32976: 
 32976:   NSPoint windowEventLocation = nsCocoaUtils::EventLocationForWindow(aEvent, window);
 32976:   NSView* view = [[[window contentView] superview] hitTest:windowEventLocation];
 47792:   if (![view isKindOfClass:[ChildView class]])
 47792:     return nil;
 47792: 
 47792:   ChildView* childView = (ChildView*)view;
 49214:   // If childView is being destroyed return nil.
 49214:   if (![childView widget])
 49214:     return nil;
 47792:   return WindowAcceptsEvent(window, aEvent, childView) ? childView : nil;
 32976: }
 32976: 
 32976: BOOL
 47792: ChildViewMouseTracker::WindowAcceptsEvent(NSWindow* aWindow, NSEvent* aEvent,
 47792:                                           ChildView* aView, BOOL aIsClickThrough)
 32976: {
 32976:   // Right mouse down events may get through to all windows, even to a top level
 32976:   // window with an open sheet.
 42317:   if (!aWindow || [aEvent type] == NSRightMouseDown)
 32976:     return YES;
 32976: 
 32976:   id delegate = [aWindow delegate];
 32976:   if (!delegate || ![delegate isKindOfClass:[WindowDelegate class]])
 32976:     return YES;
 32976: 
 32976:   nsIWidget *windowWidget = [(WindowDelegate *)delegate geckoWidget];
 32976:   if (!windowWidget)
 32976:     return YES;
 32976: 
 32976:   nsWindowType windowType;
 32976:   windowWidget->GetWindowType(windowType);
 32976: 
 42317:   NSWindow* topLevelWindow = nil;
 42317: 
 32976:   switch (windowType) {
 32976:     case eWindowType_popup:
 32976:       // If this is a context menu, it won't have a parent. So we'll always
 32976:       // accept mouse move events on context menus even when none of our windows
 32976:       // is active, which is the right thing to do.
 32976:       // For panels, the parent window is the XUL window that owns the panel.
 47792:       return WindowAcceptsEvent([aWindow parentWindow], aEvent, aView, aIsClickThrough);
 32976: 
 32976:     case eWindowType_toplevel:
 32976:     case eWindowType_dialog:
 42317:       if ([aWindow attachedSheet])
 42317:         return NO;
 42317: 
 42317:       topLevelWindow = aWindow;
 42317:       break;
 32976:     case eWindowType_sheet: {
 32976:       nsIWidget* parentWidget = windowWidget->GetSheetWindowParent();
 32976:       if (!parentWidget)
 32976:         return YES;
 32976: 
 42317:       topLevelWindow = (NSWindow*)parentWidget->GetNativeData(NS_NATIVE_WINDOW);
 42317:       break;
 32976:     }
 32976: 
 32976:     default:
 32976:       return YES;
 32976:   }
 42317: 
 42317:   if (!topLevelWindow ||
 47792:       ([topLevelWindow isMainWindow] && !aIsClickThrough) ||
 42317:       [aEvent type] == NSOtherMouseDown ||
 42317:       (([aEvent modifierFlags] & NSCommandKeyMask) != 0 &&
 42317:        [aEvent type] != NSMouseMoved))
 42317:     return YES;
 42317: 
 42317:   // If we're here then we're dealing with a left click or mouse move on an
 47792:   // inactive window or something similar. Ask Gecko what to do.
 47792:   return [aView inactiveWindowAcceptsMouseEvent:aEvent];
 32976: }
 32976: 
 32976: #pragma mark -
 32976: 
 24707: @interface NSView (MethodSwizzling)
 24707: - (BOOL)nsChildView_NSView_mouseDownCanMoveWindow;
 24707: @end
 24707: 
 24707: @implementation NSView (MethodSwizzling)
 24707: 
 24707: // All top-level browser windows belong to the ToolbarWindow class and have
 24707: // NSTexturedBackgroundWindowMask turned on in their "style" (see particularly
 24707: // [ToolbarWindow initWithContentRect:...] in nsCocoaWindow.mm).  This style
 24707: // normally means the window "may be moved by clicking and dragging anywhere
 24707: // in the window background", but we've suppressed this by giving the
 24707: // ChildView class a mouseDownCanMoveWindow method that always returns NO.
 24707: // Normally a ToolbarWindow's contentView (not a ChildView) returns YES when
 24707: // NSTexturedBackgroundWindowMask is turned on.  But normally this makes no
 24707: // difference.  However, under some (probably very unusual) circumstances
 24707: // (and only on Leopard) it *does* make a difference -- for example it
 24707: // triggers bmo bugs 431902 and 476393.  So here we make sure that a
 24707: // ToolbarWindow's contentView always returns NO from the
 24707: // mouseDownCanMoveWindow method.
 24707: - (BOOL)nsChildView_NSView_mouseDownCanMoveWindow
 24707: {
 24707:   NSWindow *ourWindow = [self window];
 24707:   NSView *contentView = [ourWindow contentView];
 24707:   if ([ourWindow isKindOfClass:[ToolbarWindow class]] && (self == contentView))
120690:     return NO;
 24707:   return [self nsChildView_NSView_mouseDownCanMoveWindow];
 24707: }
 24707: 
 24707: @end
 76790: 
 76790: #ifdef __LP64__
 76790: // When using blocks, at least on OS X 10.7, the OS sometimes calls
 76790: // +[NSEvent removeMonitor:] more than once on a single event monitor, which
 76790: // causes crashes.  See bug 678607.  We hook these methods to work around
 76790: // the problem.
 76790: @interface NSEvent (MethodSwizzling)
 76790: + (id)nsChildView_NSEvent_addLocalMonitorForEventsMatchingMask:(unsigned long long)mask handler:(id)block;
 76790: + (void)nsChildView_NSEvent_removeMonitor:(id)eventMonitor;
 76790: @end
 76790: 
 76790: // This is a local copy of the AppKit frameworks sEventObservers hashtable.
 76790: // It only stores "local monitors".  We use it to ensure that +[NSEvent
 76790: // removeMonitor:] is never called more than once on the same local monitor.
 76790: static NSHashTable *sLocalEventObservers = nil;
 76790: 
 76790: @implementation NSEvent (MethodSwizzling)
 76790: 
 76790: + (id)nsChildView_NSEvent_addLocalMonitorForEventsMatchingMask:(unsigned long long)mask handler:(id)block
 76790: {
 76790:   if (!sLocalEventObservers) {
 76790:     sLocalEventObservers = [[NSHashTable hashTableWithOptions:
 76790:       NSHashTableStrongMemory | NSHashTableObjectPointerPersonality] retain];
 76790:   }
 76790:   id retval =
 76790:     [self nsChildView_NSEvent_addLocalMonitorForEventsMatchingMask:mask handler:block];
 76790:   if (sLocalEventObservers && retval && ![sLocalEventObservers containsObject:retval]) {
 76790:     [sLocalEventObservers addObject:retval];
 76790:   }
 76790:   return retval;
 76790: }
 76790: 
 76790: + (void)nsChildView_NSEvent_removeMonitor:(id)eventMonitor
 76790: {
 76790:   if (sLocalEventObservers && [eventMonitor isKindOfClass: ::NSClassFromString(@"_NSLocalEventObserver")]) {
 76790:     if (![sLocalEventObservers containsObject:eventMonitor]) {
 76790:       return;
 76790:     }
 76790:     [sLocalEventObservers removeObject:eventMonitor];
 76790:   }
 76790:   [self nsChildView_NSEvent_removeMonitor:eventMonitor];
 76790: }
 76790: 
 76790: @end
 76790: #endif // #ifdef __LP64__
