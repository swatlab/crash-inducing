     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * Class for managing loading of a subframe (creation of the docshell,
     1:  * handling of loads in it, recursion-checking).
     1:  */
     1: 
     1: #ifndef nsFrameLoader_h_
     1: #define nsFrameLoader_h_
     1: 
     1: #include "nsIDocShell.h"
     1: #include "nsStringFwd.h"
     1: #include "nsIFrameLoader.h"
 54084: #include "nsPoint.h"
 46517: #include "nsSize.h"
 13433: #include "nsIURI.h"
 46517: #include "nsAutoPtr.h"
 46683: #include "nsFrameMessageManager.h"
 79617: #include "mozilla/dom/Element.h"
102310: #include "mozilla/Attributes.h"
106914: #include "FrameMetrics.h"
     1: 
     1: class nsIURI;
 51754: class nsSubDocumentFrame;
 46517: class nsIView;
 42412: class nsIInProcessContentFrameMessageManager;
 42907: class AutoResetInShow;
101817: class nsITabParent;
 46517: 
 46517: namespace mozilla {
 46517: namespace dom {
 47933: class PBrowserParent;
 46517: class TabParent;
 46517: }
 54017: 
 54017: namespace layout {
 54017: class RenderFrameParent;
 54017: }
 46517: }
 46517: 
 46517: #ifdef MOZ_WIDGET_GTK2
 46517: typedef struct _GtkWidget GtkWidget;
 46517: #endif
 46640: #ifdef MOZ_WIDGET_QT
 46640: class QX11EmbedContainer;
 46640: #endif
     1: 
 54084: /**
 54084:  * Defines a target configuration for this <browser>'s content
 60445:  * document's view.  If the content document's actual view
 60445:  * doesn't match this nsIContentView, then on paints its pixels
 54084:  * are transformed to compensate for the difference.
 54084:  *
 54084:  * Used to support asynchronous re-paints of content pixels; see
 60445:  * nsIContentView.
 54084:  */
102310: class nsContentView MOZ_FINAL : public nsIContentView
 60445: {
 60445: public:
 60445:   typedef mozilla::layers::FrameMetrics::ViewID ViewID;
 60445:   NS_DECL_ISUPPORTS
 60445:   NS_DECL_NSICONTENTVIEW
 60445:  
 60445:   struct ViewConfig {
 60445:     ViewConfig()
 60445:       : mScrollOffset(0, 0)
 54084:       , mXScale(1.0)
 54084:       , mYScale(1.0)
 54084:     {}
 54084: 
 54084:     // Default copy ctor and operator= are fine
 54084: 
 79445:     bool operator==(const ViewConfig& aOther) const
 54084:     {
 60445:       return (mScrollOffset == aOther.mScrollOffset &&
 54084:               mXScale == aOther.mXScale &&
 54084:               mYScale == aOther.mYScale);
 54084:     }
 54084: 
 54084:     // This is the scroll offset the <browser> user wishes or expects
 54084:     // its enclosed content document to have.  "Scroll offset" here
 54084:     // means the document pixel at pixel (0,0) within the CSS
 54084:     // viewport.  If the content document's actual scroll offset
 54084:     // doesn't match |mScrollOffset|, the difference is used to define
 54084:     // a translation transform when painting the content document.
 54084:     nsPoint mScrollOffset;
 54084:     // The scale at which the <browser> user wishes to paint its
 54084:     // enclosed content document.  If content-document layers have a
 54084:     // lower or higher resolution than the desired scale, then the
 54084:     // ratio is used to define a scale transform when painting the
 54084:     // content document.
 54084:     float mXScale;
 54084:     float mYScale;
 54084:   };
 54084: 
 73980:   nsContentView(nsFrameLoader* aFrameLoader, ViewID aScrollId,
 60445:                 ViewConfig aConfig = ViewConfig())
 60449:     : mViewportSize(0, 0)
 60449:     , mContentSize(0, 0)
 82403:     , mParentScaleX(1.0)
 82403:     , mParentScaleY(1.0)
 73980:     , mFrameLoader(aFrameLoader)
 60445:     , mScrollId(aScrollId)
 60445:     , mConfig(aConfig)
 60445:   {}
 60445: 
 60445:   bool IsRoot() const;
 60445: 
 60445:   ViewID GetId() const
 60445:   {
 60445:     return mScrollId;
 60445:   }
 60445: 
 60445:   ViewConfig GetViewConfig() const
 60445:   {
 60445:     return mConfig;
 60445:   }
 60445: 
 60449:   nsSize mViewportSize;
 60449:   nsSize mContentSize;
 82403:   float mParentScaleX;
 82403:   float mParentScaleY;
 60449: 
 73980:   nsFrameLoader* mFrameLoader;  // WEAK
 60445: 
 60445: private:
 60445:   nsresult Update(const ViewConfig& aConfig);
 60445: 
 60445:   ViewID mScrollId;
 60445:   ViewConfig mConfig;
 60445: };
 60445: 
 60445: 
102310: class nsFrameLoader MOZ_FINAL : public nsIFrameLoader,
 60445:                                 public nsIContentViewManager
 60445: {
 60445:   friend class AutoResetInShow;
 60445:   typedef mozilla::dom::PBrowserParent PBrowserParent;
 60445:   typedef mozilla::dom::TabParent TabParent;
 60445:   typedef mozilla::layout::RenderFrameParent RenderFrameParent;
 60445: 
 60445: protected:
 79617:   nsFrameLoader(mozilla::dom::Element* aOwner, bool aNetworkCreated);
 60445: 
 60445: public:
 12261:   ~nsFrameLoader() {
 80486:     mNeedsAsyncDestroy = true;
 46683:     if (mMessageManager) {
 46683:       mMessageManager->Disconnect();
 46683:     }
 12261:     nsFrameLoader::Destroy();
 12261:   }
 12261: 
 79445:   bool AsyncScrollEnabled() const
 60448:   {
 60448:     return !!(mRenderMode & RENDER_MODE_ASYNC_SCROLL);
 60448:   }
 60448: 
 79617:   static nsFrameLoader* Create(mozilla::dom::Element* aOwner,
 79617:                                bool aNetworkCreated);
 31661: 
     1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 60322:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsFrameLoader, nsIFrameLoader)
     1:   NS_DECL_NSIFRAMELOADER
 60445:   NS_DECL_NSICONTENTVIEWMANAGER
  3556:   NS_HIDDEN_(nsresult) CheckForRecursiveLoad(nsIURI* aURI);
 13433:   nsresult ReallyStartLoading();
 12256:   void Finalize();
 14660:   nsIDocShell* GetExistingDocShell() { return mDocShell; }
 72326:   nsIDOMEventTarget* GetTabChildGlobalAsEventTarget();
 35581:   nsresult CreateStaticClone(nsIFrameLoader* aDest);
 35581: 
 34245:   /**
 34245:    * Called from the layout frame associated with this frame loader;
 34245:    * this notifies us to hook up with the widget and view.
 34245:    */
 79445:   bool Show(PRInt32 marginWidth, PRInt32 marginHeight,
 34245:               PRInt32 scrollbarPrefX, PRInt32 scrollbarPrefY,
 51754:               nsSubDocumentFrame* frame);
 34245: 
 34245:   /**
 69814:    * Called when the margin properties of the containing frame are changed.
 69814:    */
 69814:   void MarginsChanged(PRUint32 aMarginWidth, PRUint32 aMarginHeight);
 69814: 
 69814:   /**
 34245:    * Called from the layout frame associated with this frame loader, when
 34245:    * the frame is being torn down; this notifies us that out widget and view
 34245:    * are going away and we should unhook from them.
 34245:    */
 34245:   void Hide();
 34245: 
 35581:   nsresult CloneForStatic(nsIFrameLoader* aOriginal);
 35581: 
 16549:   // The guts of an nsIFrameLoaderOwner::SwapFrameLoader implementation.  A
 16549:   // frame loader owner needs to call this, and pass in the two references to
 16549:   // nsRefPtrs for frame loaders that need to be swapped.
 16549:   nsresult SwapWithOtherLoader(nsFrameLoader* aOther,
 16549:                                nsRefPtr<nsFrameLoader>& aFirstToSwap,
 16549:                                nsRefPtr<nsFrameLoader>& aSecondToSwap);
 46517: 
 46797:   // When IPC is enabled, destroy any associated child process.
 46797:   void DestroyChild();
 46797: 
 48948:   /**
 48948:    * Return the primary frame for our owning content, or null if it
 48948:    * can't be found.
 48948:    */
 48948:   nsIFrame* GetPrimaryFrameOfOwningContent() const
 48948:   {
106838:     return mOwnerContent ? mOwnerContent->GetPrimaryFrame() : nullptr;
 48948:   }
 48948: 
 48948:   /** 
 48948:    * Return the document that owns this, or null if we don't have
 48948:    * an owner.
 48948:    */
 98275:   nsIDocument* GetOwnerDoc() const
106838:   { return mOwnerContent ? mOwnerContent->OwnerDoc() : nullptr; }
 48948: 
 47933:   PBrowserParent* GetRemoteBrowser();
 54017: 
 54017:   /**
 54017:    * The "current" render frame is the one on which the most recent
 54017:    * remote layer-tree transaction was executed.  If no content has
 54017:    * been drawn yet, or the remote browser doesn't have any drawn
 54017:    * content for whatever reason, return NULL.  The returned render
 54017:    * frame has an associated shadow layer tree.
 54017:    *
 54017:    * Note that the returned render frame might not be a frame
 54017:    * constructed for this->GetURL().  This can happen, e.g., if the
 54017:    * <browser> was just navigated to a new URL, but hasn't painted the
 54017:    * new page yet.  A render frame for the previous page may be
 54017:    * returned.  (In-process <browser> behaves similarly, and this
 54017:    * behavior seems desirable.)
 54017:    */
 54017:   RenderFrameParent* GetCurrentRemoteFrame() const
 54017:   {
 54017:     return mCurrentRemoteFrame;
 54017:   }
 54017: 
 54017:   /**
 54017:    * |aFrame| can be null.  If non-null, it must be the remote frame
 54017:    * on which the most recent layer transaction completed for this's
 54017:    * <browser>.
 54017:    */
 54017:   void SetCurrentRemoteFrame(RenderFrameParent* aFrame)
 54017:   {
 54017:     mCurrentRemoteFrame = aFrame;
 54017:   }
 46683:   nsFrameMessageManager* GetFrameMessageManager() { return mMessageManager; }
 46683: 
 79617:   mozilla::dom::Element* GetOwnerContent() { return mOwnerContent; }
 83439:   bool ShouldClipSubdocument() { return mClipSubdocument; }
 83439: 
 92922:   bool ShouldClampScrollPosition() { return mClampScrollPosition; }
 92922: 
101817:   /**
101817:    * Tell this FrameLoader to use a particular remote browser.
101817:    *
101817:    * This will assert if mRemoteBrowser or mCurrentRemoteFrame is non-null.  In
101817:    * practice, this means you can't have successfully run TryRemoteBrowser() on
101817:    * this object, which means you can't have called ShowRemoteFrame() or
101817:    * ReallyStartLoading().
101817:    */
101817:   void SetRemoteBrowser(nsITabParent* aTabParent);
101817: 
     1: private:
     1: 
 98014:   void SetOwnerContent(mozilla::dom::Element* aContent);
 98014: 
 46517:   bool ShouldUseRemoteProcess();
 46517: 
 46517:   /**
104514:    * Is this a frameloader for a bona fide <iframe mozbrowser> or
104514:    * <iframe mozapp>?  (I.e., does the frame return true for
104514:    * nsIMozBrowserFrame::GetReallyIsBrowser()?)
 96948:    */
 96948:   bool OwnerIsBrowserFrame();
 96948: 
 96948:   /**
104514:    * Is this a frameloader for a bona fide <iframe mozapp>?  (I.e., does the
104514:    * frame return true for nsIMozBrowserFrame::GetReallyIsApp()?)
104514:    */
104514:   bool OwnerIsAppFrame();
104514: 
104514:   /**
104514:    * Get our owning element's app manifest URL, or return the empty string if
104514:    * our owning element doesn't have an app manifest URL.
104514:    */
104514:   void GetOwnerAppManifestURL(nsAString& aOut);
104514: 
104514:   /**
 46517:    * If we are an IPC frame, set mRemoteFrame. Otherwise, create and
 46517:    * initialize mDocShell.
 46517:    */
 46517:   nsresult MaybeCreateDocShell();
 42412:   nsresult EnsureMessageManager();
 38663:   NS_HIDDEN_(void) GetURL(nsString& aURL);
 46517: 
 46517:   // Properly retrieves documentSize of any subdocument type.
 46517:   NS_HIDDEN_(nsIntSize) GetSubDocumentSize(const nsIFrame *aIFrame);
 73965:   nsresult GetWindowDimensions(nsRect& aRect);
 46517: 
 46517:   // Updates the subdocument position and size. This gets called only
 46517:   // when we have our own in-process DocShell.
 46517:   NS_HIDDEN_(nsresult) UpdateBaseWindowPositionAndSize(nsIFrame *aIFrame);
 13433:   nsresult CheckURILoad(nsIURI* aURI);
 38663:   void FireErrorEvent();
 38663:   nsresult ReallyStartLoadingInternal();
     1: 
 54008:   // Return true if remote browser created; nothing else to do
 54008:   bool TryRemoteBrowser();
 46517: 
 54008:   // Tell the remote browser that it's now "virtually visible"
 54008:   bool ShowRemoteFrame(const nsIntSize& size);
 46517: 
     1:   nsCOMPtr<nsIDocShell> mDocShell;
 13433:   nsCOMPtr<nsIURI> mURIToLoad;
 79617:   mozilla::dom::Element* mOwnerContent; // WEAK
 42412: public:
 42412:   // public because a callback needs these.
 42412:   nsRefPtr<nsFrameMessageManager> mMessageManager;
 42412:   nsCOMPtr<nsIInProcessContentFrameMessageManager> mChildMessageManager;
 42412: private:
 79445:   bool mDepthTooGreat : 1;
 79445:   bool mIsTopLevelContent : 1;
 79445:   bool mDestroyCalled : 1;
 79445:   bool mNeedsAsyncDestroy : 1;
 79445:   bool mInSwap : 1;
 79445:   bool mInShow : 1;
 79445:   bool mHideCalled : 1;
 50721:   // True when the object is created for an element which the parser has
 50721:   // created using NS_FROM_PARSER_NETWORK flag. If the element is modified,
 50721:   // it may lose the flag.
 79445:   bool mNetworkCreated : 1;
 46517: 
 79445:   bool mDelayRemoteDialogs : 1;
 79445:   bool mRemoteBrowserShown : 1;
 83439:   bool mRemoteFrame : 1;
 83439:   bool mClipSubdocument : 1;
 92922:   bool mClampScrollPosition : 1;
104021:   bool mRemoteBrowserInitialized : 1;
 83439: 
 46517:   // XXX leaking
 46796:   nsCOMPtr<nsIObserver> mChildHost;
 54017:   RenderFrameParent* mCurrentRemoteFrame;
 47933:   TabParent* mRemoteBrowser;
 46893: 
 60445:   // See nsIFrameLoader.idl.  Short story, if !(mRenderMode &
 60445:   // RENDER_MODE_ASYNC_SCROLL), all the fields below are ignored in
 60445:   // favor of what content tells.
 60445:   PRUint32 mRenderMode;
 73592: 
 73592:   // See nsIFrameLoader.idl. EVENT_MODE_NORMAL_DISPATCH automatically
 73592:   // forwards some input events to out-of-process content.
 73592:   PRUint32 mEventMode;
     1: };
     1: 
     1: #endif
