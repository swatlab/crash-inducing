125567: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 33649: /* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 33649: 
 33649: /*
 33649:  * Code to notify things that animate before a refresh, at an appropriate
 33649:  * refresh rate.  (Perhaps temporary, until replaced by compositor.)
 33649:  */
 33649: 
 33649: #ifndef nsRefreshDriver_h_
 33649: #define nsRefreshDriver_h_
 33649: 
 33649: #include "mozilla/TimeStamp.h"
 33649: #include "mozFlushType.h"
 33649: #include "nsCOMPtr.h"
 33649: #include "nsTObserverArray.h"
 50365: #include "nsTArray.h"
 50368: #include "nsAutoPtr.h"
 82097: #include "nsTHashtable.h"
 82097: #include "nsHashKeys.h"
102311: #include "mozilla/Attributes.h"
 33649: 
 36615: class nsPresContext;
 50365: class nsIPresShell;
 50368: class nsIDocument;
 82097: class imgIRequest;
 36615: 
 33649: /**
 33649:  * An abstract base class to be implemented by callers wanting to be
 33649:  * notified at refresh times.  When nothing needs to be painted, callers
 33649:  * may not be notified.
 33649:  */
125567: namespace mozilla {
125567:     class RefreshDriverTimer;
125567: }
125567: 
 33649: class nsARefreshObserver {
 33649: public:
 36617:   // AddRef and Release signatures that match nsISupports.  Implementors
 36617:   // must implement reference counting, and those that do implement
 36617:   // nsISupports will already have methods with the correct signature.
 36617:   //
 36617:   // The refresh driver does NOT hold references to refresh observers
 36617:   // except while it is notifying them.
 36617:   NS_IMETHOD_(nsrefcnt) AddRef(void) = 0;
 36617:   NS_IMETHOD_(nsrefcnt) Release(void) = 0;
 36617: 
 33649:   virtual void WillRefresh(mozilla::TimeStamp aTime) = 0;
 33649: };
 33649: 
125567: class nsRefreshDriver MOZ_FINAL : public nsISupports {
 33649: public:
 36615:   nsRefreshDriver(nsPresContext *aPresContext);
 33649:   ~nsRefreshDriver();
 33649: 
 63688:   static void InitializeStatics();
125567:   static void Shutdown();
 63688: 
 36615:   // nsISupports implementation
 36615:   NS_DECL_ISUPPORTS
 36615: 
 33649:   /**
 67983:    * Methods for testing, exposed via nsIDOMWindowUtils.  See
 67983:    * nsIDOMWindowUtils.advanceTimeAndRefresh for description.
 67983:    */
108991:   void AdvanceTimeAndRefresh(int64_t aMilliseconds);
 67983:   void RestoreNormalRefresh();
125567:   void DoTick();
125567:   bool IsTestControllingRefreshesEnabled() const
125567:   {
125567:     return mTestControllingRefreshes;
125567:   }
 67983: 
 67983:   /**
 33649:    * Return the time of the most recent refresh.  This is intended to be
 33649:    * used by callers who want to start an animation now and want to know
 33649:    * what time to consider the start of the animation.  (This helps
 33649:    * ensure that multiple animations started during the same event off
 33649:    * the main event loop have the same start time.)
 33649:    */
 33649:   mozilla::TimeStamp MostRecentRefresh() const;
 50368:   /**
 50368:    * Same thing, but in microseconds since the epoch.
 50368:    */
108991:   int64_t MostRecentRefreshEpochTime() const;
 33649: 
 33649:   /**
 33649:    * Add / remove refresh observers.  Returns whether the operation
 33649:    * succeeded.
 33649:    *
 33649:    * The flush type affects:
 33649:    *   + the order in which the observers are notified (lowest flush
 33649:    *     type to highest, in order registered)
 33649:    *   + (in the future) which observers are suppressed when the display
 33649:    *     doesn't require current position data or isn't currently
 33649:    *     painting, and, correspondingly, which get notified when there
 33649:    *     is a flush during such suppression
 33649:    * and it must be either Flush_Style, Flush_Layout, or Flush_Display.
 36617:    *
 36617:    * The refresh driver does NOT own a reference to these observers;
 36617:    * they must remove themselves before they are destroyed.
 33649:    */
 79445:   bool AddRefreshObserver(nsARefreshObserver *aObserver,
 33649:                             mozFlushType aFlushType);
 79445:   bool RemoveRefreshObserver(nsARefreshObserver *aObserver,
 33649:                                mozFlushType aFlushType);
 36615: 
 36615:   /**
 82097:    * Add/Remove imgIRequest versions of observers.
 82097:    *
 82097:    * These are used for hooking into the refresh driver for
 82097:    * controlling animated images.
 82097:    *
 82097:    * @note The refresh driver owns a reference to these listeners.
 82097:    *
 82097:    * @note Technically, imgIRequest objects are not nsARefreshObservers, but
 82097:    * for controlling animated image repaint events, we subscribe the
 82097:    * imgIRequests to the nsRefreshDriver for notification of paint events.
 82097:    *
 82097:    * @returns whether the operation succeeded, or void in the case of removal.
 82097:    */
 82097:   bool AddImageRequest(imgIRequest* aRequest);
 82097:   void RemoveImageRequest(imgIRequest* aRequest);
 82097:   void ClearAllImageRequests();
 82097: 
 82097:   /**
 50365:    * Add / remove presshells that we should flush style and layout on
 50365:    */
 79445:   bool AddStyleFlushObserver(nsIPresShell* aShell) {
 50365:     NS_ASSERTION(!mStyleFlushObservers.Contains(aShell),
 50365: 		 "Double-adding style flush observer");
106838:     bool appended = mStyleFlushObservers.AppendElement(aShell) != nullptr;
 68771:     EnsureTimerStarted(false);
 50365:     return appended;
 50365:   }
 50365:   void RemoveStyleFlushObserver(nsIPresShell* aShell) {
 50365:     mStyleFlushObservers.RemoveElement(aShell);
 50365:   }
 79445:   bool AddLayoutFlushObserver(nsIPresShell* aShell) {
 50365:     NS_ASSERTION(!IsLayoutFlushObserver(aShell),
 50365: 		 "Double-adding layout flush observer");
106838:     bool appended = mLayoutFlushObservers.AppendElement(aShell) != nullptr;
 68771:     EnsureTimerStarted(false);
 50365:     return appended;
 50365:   }
 50365:   void RemoveLayoutFlushObserver(nsIPresShell* aShell) {
 50365:     mLayoutFlushObservers.RemoveElement(aShell);
 50365:   }
 79445:   bool IsLayoutFlushObserver(nsIPresShell* aShell) {
 50365:     return mLayoutFlushObservers.Contains(aShell);
 50365:   }
115319:   bool AddPresShellToInvalidateIfHidden(nsIPresShell* aShell) {
115319:     NS_ASSERTION(!mPresShellsToInvalidateIfHidden.Contains(aShell),
115319: 		 "Double-adding style flush observer");
115319:     bool appended = mPresShellsToInvalidateIfHidden.AppendElement(aShell) != nullptr;
115319:     EnsureTimerStarted(false);
115319:     return appended;
115319:   }
115319:   void RemovePresShellToInvalidateIfHidden(nsIPresShell* aShell) {
115319:     mPresShellsToInvalidateIfHidden.RemoveElement(aShell);
115319:   }
 50365: 
 50365:   /**
 87344:    * Remember whether our presshell's view manager needs a flush
 87344:    */
114466:   void ScheduleViewManagerFlush();
 87344:   void RevokeViewManagerFlush() {
 87344:     mViewManagerFlushIsPending = false;
 87344:   }
115309:   bool ViewManagerFlushIsPending() {
115309:     return mViewManagerFlushIsPending;
115309:   }
 87344: 
 87344:   /**
 82857:    * Add a document for which we have nsIFrameRequestCallbacks
 52255:    */
 82857:   void ScheduleFrameRequestCallbacks(nsIDocument* aDocument);
 52255: 
 52255:   /**
 82857:    * Remove a document for which we have nsIFrameRequestCallbacks
 52255:    */
 82857:   void RevokeFrameRequestCallbacks(nsIDocument* aDocument);
 52255: 
 52255:   /**
 36615:    * Tell the refresh driver that it is done driving refreshes and
 36615:    * should stop its timer and forget about its pres context.  This may
 36615:    * be called from within a refresh.
 36615:    */
 36615:   void Disconnect() {
 36615:     StopTimer();
106838:     mPresContext = nullptr;
 36615:   }
 36615: 
 37880:   /**
 37880:    * Freeze the refresh driver.  It should stop delivering future
 37880:    * refreshes until thawed.
 37880:    */
 37880:   void Freeze();
 37880: 
 37880:   /**
 37880:    * Thaw the refresh driver.  If needed, it should start delivering
 37880:    * refreshes again.
 37880:    */
 37880:   void Thaw();
 37880: 
 50366:   /**
 51546:    * Throttle or unthrottle the refresh driver.  This is done if the
 51546:    * corresponding presshell is hidden or shown.
 51546:    */
 51546:   void SetThrottled(bool aThrottled);
 51546: 
 51546:   /**
 50366:    * Return the prescontext we were initialized with
 50366:    */
 50366:   nsPresContext* PresContext() const { return mPresContext; }
 50366: 
 38310: #ifdef DEBUG
 38310:   /**
 38310:    * Check whether the given observer is an observer for the given flush type
 38310:    */
 79445:   bool IsRefreshObserver(nsARefreshObserver *aObserver,
 38310: 			   mozFlushType aFlushType);
 38310: #endif
 38310: 
 87356:   /**
 87356:    * Default interval the refresh driver uses, in ms.
 87356:    */
108991:   static int32_t DefaultInterval();
 87356: 
 36602: private:
 33649:   typedef nsTObserverArray<nsARefreshObserver*> ObserverArray;
 82097:   typedef nsTHashtable<nsISupportsHashKey> RequestTable;
 33649: 
125567:   void Tick(int64_t aNowEpoch, mozilla::TimeStamp aNowTime);
125567: 
 68771:   void EnsureTimerStarted(bool aAdjustingTimer);
 33649:   void StopTimer();
 82097: 
108991:   uint32_t ObserverCount() const;
108991:   uint32_t ImageRequestCount() const;
 82097:   static PLDHashOperator ImageRequestEnumerator(nsISupportsHashKey* aEntry,
 82097:                                           void* aUserArg);
 33649:   ObserverArray& ArrayFor(mozFlushType aFlushType);
 37880:   // Trigger a refresh immediately, if haven't been disconnected or frozen.
 37880:   void DoRefresh();
 33649: 
125567:   double GetRefreshTimerInterval() const;
125567:   double GetRegularTimerInterval() const;
125567:   double GetThrottledTimerInterval() const;
 63574: 
 82857:   bool HaveFrameRequestCallbacks() const {
 82857:     return mFrameRequestCallbackDocs.Length() != 0;
 63688:   }
 63688: 
125567:   mozilla::RefreshDriverTimer* ChooseTimer() const;
125567:   mozilla::RefreshDriverTimer *mActiveTimer;
 33649: 
 36615:   nsPresContext *mPresContext; // weak; pres context passed in constructor
 36615:                                // and unset in Disconnect
 36615: 
 51546:   bool mFrozen;
 51546:   bool mThrottled;
 67983:   bool mTestControllingRefreshes;
 87344:   bool mViewManagerFlushIsPending;
125567:   bool mRequestedHighPrecision;
125567: 
125567:   int64_t mMostRecentRefreshEpochTime;
125567:   mozilla::TimeStamp mMostRecentRefresh;
 37880: 
 33649:   // separate arrays for each flush type we support
 33649:   ObserverArray mObservers[3];
 82097:   RequestTable mRequests;
 82097: 
 50365:   nsAutoTArray<nsIPresShell*, 16> mStyleFlushObservers;
 50365:   nsAutoTArray<nsIPresShell*, 16> mLayoutFlushObservers;
115319:   nsAutoTArray<nsIPresShell*, 16> mPresShellsToInvalidateIfHidden;
 50368:   // nsTArray on purpose, because we want to be able to swap.
 82857:   nsTArray<nsIDocument*> mFrameRequestCallbackDocs;
 63574: 
 82097:   // Helper struct for processing image requests
 82097:   struct ImageRequestParameters {
 82097:       mozilla::TimeStamp ts;
 82097:   };
125567: 
125567:   friend class mozilla::RefreshDriverTimer;
125567: 
125567:   // turn on or turn off high precision based on various factors
125567:   void ConfigureHighPrecision();
125567:   void SetHighPrecisionTimersEnabled(bool aEnable);
 33649: };
 33649: 
 33649: #endif /* !defined(nsRefreshDriver_h_) */
