 73549: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 73021: /* vim: set sw=2 ts=8 et tw=80 : */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 70220: 
 72966: #include "WebSocketLog.h"
 73020: #include "WebSocketChannel.h"
 70220: 
 70220: #include "nsISocketTransportService.h"
 70220: #include "nsIURI.h"
 70220: #include "nsIChannel.h"
 70220: #include "nsICryptoHash.h"
 70220: #include "nsIRunnable.h"
 70220: #include "nsIPrefBranch.h"
 70220: #include "nsIPrefService.h"
 70220: #include "nsICancelable.h"
 70220: #include "nsIDNSRecord.h"
 70220: #include "nsIDNSService.h"
 70220: #include "nsIStreamConverterService.h"
 70220: #include "nsIIOService2.h"
 70220: #include "nsIProtocolProxyService.h"
 70220: 
 70220: #include "nsAutoPtr.h"
 70220: #include "nsStandardURL.h"
 70220: #include "nsNetCID.h"
 70220: #include "nsServiceManagerUtils.h"
 70220: #include "nsXPIDLString.h"
 70220: #include "nsCRT.h"
 70220: #include "nsThreadUtils.h"
108290: #include "nsError.h"
 70220: #include "nsStringStream.h"
 70220: #include "nsAlgorithm.h"
 70220: #include "nsProxyRelease.h"
 84709: #include "nsNetUtil.h"
101868: #include "mozilla/Attributes.h"
103141: #include "TimeStamp.h"
 70220: 
 70220: #include "plbase64.h"
 70220: #include "prmem.h"
 70220: #include "prnetdb.h"
 70220: #include "prbit.h"
 70220: #include "zlib.h"
 70220: 
103141: // rather than slurp up all of nsIWebSocket.idl, which lives outside necko, just
103141: // dupe one constant we need from it
103141: #define CLOSE_GOING_AWAY 1001
103141: 
 70220: extern PRThread *gSocketThread;
 70220: 
103141: using namespace mozilla;
103141: 
 70220: namespace mozilla {
 70220: namespace net {
 70220: 
 73020: NS_IMPL_THREADSAFE_ISUPPORTS11(WebSocketChannel,
 73019:                                nsIWebSocketChannel,
 70220:                                nsIHttpUpgradeListener,
 70220:                                nsIRequestObserver,
 70220:                                nsIStreamListener,
 70220:                                nsIProtocolHandler,
 70220:                                nsIInputStreamCallback,
 70220:                                nsIOutputStreamCallback,
 70220:                                nsITimerCallback,
 70220:                                nsIDNSListener,
 70220:                                nsIInterfaceRequestor,
 70220:                                nsIChannelEventSink)
 70220: 
 85007: // We implement RFC 6455, which uses Sec-WebSocket-Version: 13 on the wire.
 85007: #define SEC_WEBSOCKET_VERSION "13"
 70220: 
 70220: /*
 70220:  * About SSL unsigned certificates
 70220:  *
 70220:  * wss will not work to a host using an unsigned certificate unless there
 70220:  * is already an exception (i.e. it cannot popup a dialog asking for
 70220:  * a security exception). This is similar to how an inlined img will
 70220:  * fail without a dialog if fails for the same reason. This should not
 70220:  * be a problem in practice as it is expected the websocket javascript
 70220:  * is served from the same host as the websocket server (or of course,
 70220:  * a valid cert could just be provided).
 70220:  *
 70220:  */
 70220: 
 70220: // some helper classes
 70220: 
 84709: //-----------------------------------------------------------------------------
103141: // FailDelayManager
103141: //
103141: // Stores entries (searchable by {host, port}) of connections that have recently
103141: // failed, so we can do delay of reconnects per RFC 6455 Section 7.2.3
103141: //-----------------------------------------------------------------------------
103141: 
103141: 
103141: // Initial reconnect delay is randomly chosen between 200-400 ms.
103141: // This is a gentler backoff than the 0-5 seconds the spec offhandedly suggests.
108991: const uint32_t kWSReconnectInitialBaseDelay     = 200;
108991: const uint32_t kWSReconnectInitialRandomDelay   = 200;
103141: 
103141: // Base lifetime (in ms) of a FailDelay: kept longer if more failures occur
108991: const uint32_t kWSReconnectBaseLifeTime         = 60 * 1000;
103141: // Maximum reconnect delay (in ms)
108991: const uint32_t kWSReconnectMaxDelay             = 60 * 1000;
103141: 
103141: // hold record of failed connections, and calculates needed delay for reconnects
103141: // to same host/port.
103141: class FailDelay
103141: {
103141: public:
108991:   FailDelay(nsCString address, int32_t port)
103141:     : mAddress(address), mPort(port)
103141:   {
103141:     mLastFailure = TimeStamp::Now();
103141:     mNextDelay = kWSReconnectInitialBaseDelay +
103141:                  (rand() % kWSReconnectInitialRandomDelay);
103141:   }
103141: 
103141:   // Called to update settings when connection fails again.
103141:   void FailedAgain()
103141:   {
103141:     mLastFailure = TimeStamp::Now();
103141:     // We use a truncated exponential backoff as suggested by RFC 6455,
103141:     // but multiply by 1.5 instead of 2 to be more gradual.
115357:     mNextDelay = NS_MIN<double>(kWSReconnectMaxDelay, mNextDelay * 1.5);
103141:     LOG(("WebSocket: FailedAgain: host=%s, port=%d: incremented delay to %lu",
103141:          mAddress.get(), mPort, mNextDelay));
103141:   }
103141: 
103141:   // returns 0 if there is no need to delay (i.e. delay interval is over)
108991:   uint32_t RemainingDelay(TimeStamp rightNow)
103141:   {
103141:     TimeDuration dur = rightNow - mLastFailure;
108991:     uint32_t sinceFail = (uint32_t) dur.ToMilliseconds();
103141:     if (sinceFail > mNextDelay)
103141:       return 0;
103141: 
103141:     return mNextDelay - sinceFail;
103141:   }
103141: 
103141:   bool IsExpired(TimeStamp rightNow)
103141:   {
103141:     return (mLastFailure +
103141:             TimeDuration::FromMilliseconds(kWSReconnectBaseLifeTime + mNextDelay))
103141:             <= rightNow;
103141:   }
103141: 
103141:   nsCString  mAddress;     // IP address (or hostname if using proxy)
108991:   int32_t    mPort;
103141: 
103141: private:
103141:   TimeStamp  mLastFailure; // Time of last failed attempt
103141:   // mLastFailure + mNextDelay is the soonest we'll allow a reconnect
108991:   uint32_t   mNextDelay;   // milliseconds
103141: };
103141: 
103141: class FailDelayManager
103141: {
103141: public:
103141:   FailDelayManager()
103141:   {
104428:     MOZ_COUNT_CTOR(FailDelayManager);
103141: 
103141:     mDelaysDisabled = false;
103141: 
103141:     nsCOMPtr<nsIPrefBranch> prefService =
103141:       do_GetService(NS_PREFSERVICE_CONTRACTID);
103141:     bool boolpref = true;
103141:     nsresult rv;
103141:     rv = prefService->GetBoolPref("network.websocket.delay-failed-reconnects",
103141:                                   &boolpref);
103141:     if (NS_SUCCEEDED(rv) && !boolpref) {
103141:       mDelaysDisabled = true;
103141:     }
103141:   }
103141: 
103141:   ~FailDelayManager()
103141:   {
104428:     MOZ_COUNT_DTOR(FailDelayManager);
108991:     for (uint32_t i = 0; i < mEntries.Length(); i++) {
103141:       delete mEntries[i];
103141:     }
103141:   }
103141: 
108991:   void Add(nsCString &address, int32_t port)
103141:   {
103141:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
103141: 
103141:     if (mDelaysDisabled)
103141:       return;
103141: 
103141:     FailDelay *record = new FailDelay(address, port);
103141:     mEntries.AppendElement(record);
103141:   }
103141: 
103141:   // Element returned may not be valid after next main thread event: don't keep
103141:   // pointer to it around
108991:   FailDelay* Lookup(nsCString &address, int32_t port,
108991:                     uint32_t *outIndex = nullptr)
103141:   {
103141:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
103141: 
103141:     if (mDelaysDisabled)
106838:       return nullptr;
106838: 
106838:     FailDelay *result = nullptr;
103141:     TimeStamp rightNow = TimeStamp::Now();
103141: 
103141:     // We also remove expired entries during search: iterate from end to make
103141:     // indexing simpler
108991:     for (int32_t i = mEntries.Length() - 1; i >= 0; --i) {
103141:       FailDelay *fail = mEntries[i];
103141:       if (fail->mAddress.Equals(address) && fail->mPort == port) {
103141:         if (outIndex)
103141:           *outIndex = i;
103141:         result = fail;
118362:         // break here: removing more entries would mess up *outIndex.
118465:         // Any remaining expired entries will be deleted next time Lookup
118362:         // finds nothing, which is the most common case anyway.
118362:         break;
103141:       } else if (fail->IsExpired(rightNow)) {
103141:         mEntries.RemoveElementAt(i);
103141:         delete fail;
103141:       }
103141:     }
103141:     return result;
103141:   }
103141: 
103141:   // returns true if channel connects immediately, or false if it's delayed
104078:   void DelayOrBegin(WebSocketChannel *ws)
103141:   {
103141:     if (!mDelaysDisabled) {
108991:       uint32_t failIndex = 0;
103141:       FailDelay *fail = Lookup(ws->mAddress, ws->mPort, &failIndex);
103141: 
103141:       if (fail) {
103141:         TimeStamp rightNow = TimeStamp::Now();
103141: 
108991:         uint32_t remainingDelay = fail->RemainingDelay(rightNow);
103141:         if (remainingDelay) {
103141:           // reconnecting within delay interval: delay by remaining time
103141:           nsresult rv;
103141:           ws->mReconnectDelayTimer =
103141:             do_CreateInstance("@mozilla.org/timer;1", &rv);
103141:           if (NS_SUCCEEDED(rv)) {
103141:             rv = ws->mReconnectDelayTimer->InitWithCallback(
103141:                           ws, remainingDelay, nsITimer::TYPE_ONE_SHOT);
103141:             if (NS_SUCCEEDED(rv)) {
103141:               LOG(("WebSocket: delaying websocket [this=%p] by %lu ms",
103141:                    ws, (unsigned long)remainingDelay));
103141:               ws->mConnecting = CONNECTING_DELAYED;
104078:               return;
103141:             }
103141:           }
103141:           // if timer fails (which is very unlikely), drop down to BeginOpen call
103141:         } else if (fail->IsExpired(rightNow)) {
103141:           mEntries.RemoveElementAt(failIndex);
103141:           delete fail;
103141:         }
103141:       }
103141:     }
103141: 
103141:     // Delays disabled, or no previous failure, or we're reconnecting after scheduled
103141:     // delay interval has passed: connect.
104078:     ws->BeginOpen();
103141:   }
103141: 
103141:   // Remove() also deletes all expired entries as it iterates: better for
103141:   // battery life than using a periodic timer.
108991:   void Remove(nsCString &address, int32_t port)
103141:   {
103141:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
103141: 
103141:     TimeStamp rightNow = TimeStamp::Now();
103141: 
103141:     // iterate from end, to make deletion indexing easier
108991:     for (int32_t i = mEntries.Length() - 1; i >= 0; --i) {
103141:       FailDelay *entry = mEntries[i];
103141:       if ((entry->mAddress.Equals(address) && entry->mPort == port) ||
103141:           entry->IsExpired(rightNow)) {
103141:         mEntries.RemoveElementAt(i);
103141:         delete entry;
103141:       }
103141:     }
103141:   }
103141: 
103141: private:
103141:   nsTArray<FailDelay *> mEntries;
103141:   bool                  mDelaysDisabled;
103141: };
103141: 
103141: //-----------------------------------------------------------------------------
103141: // nsWSAdmissionManager
103141: //
103141: // 1) Ensures that only one websocket at a time is CONNECTING to a given IP
103141: //    address (or hostname, if using proxy), per RFC 6455 Section 4.1.
103141: // 2) Delays reconnects to IP/host after connection failure, per Section 7.2.3
103141: //-----------------------------------------------------------------------------
103141: 
103141: class nsWSAdmissionManager
103141: {
103141: public:
103141:   nsWSAdmissionManager() : mSessionCount(0)
103141:   {
103141:     MOZ_COUNT_CTOR(nsWSAdmissionManager);
103141:   }
103141: 
103141:   class nsOpenConn
103141:   {
103141:   public:
103141:     nsOpenConn(nsCString &addr, WebSocketChannel *channel)
103141:       : mAddress(addr), mChannel(channel) { MOZ_COUNT_CTOR(nsOpenConn); }
103141:     ~nsOpenConn() { MOZ_COUNT_DTOR(nsOpenConn); }
103141: 
103141:     nsCString mAddress;
103141:     WebSocketChannel *mChannel;
103141:   };
103141: 
103141:   ~nsWSAdmissionManager()
103141:   {
103141:     MOZ_COUNT_DTOR(nsWSAdmissionManager);
108991:     for (uint32_t i = 0; i < mQueue.Length(); i++)
103141:       delete mQueue[i];
103141:   }
103141: 
103141:   // Determine if we will open connection immediately (returns true), or
103141:   // delay/queue the connection (returns false)
104078:   void ConditionallyConnect(WebSocketChannel *ws)
103141:   {
103141:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
103141:     NS_ABORT_IF_FALSE(ws->mConnecting == NOT_CONNECTING, "opening state");
103141: 
103141:     // If there is already another WS channel connecting to this IP address,
103141:     // defer BeginOpen and mark as waiting in queue.
103141:     bool found = (IndexOf(ws->mAddress) >= 0);
103141: 
103141:     // Always add ourselves to queue, even if we'll connect immediately
103141:     nsOpenConn *newdata = new nsOpenConn(ws->mAddress, ws);
103141:     mQueue.AppendElement(newdata);
103141: 
103141:     if (found) {
103141:       ws->mConnecting = CONNECTING_QUEUED;
104078:     } else {
104078:       mFailures.DelayOrBegin(ws);
103141:     }
103141:   }
103141: 
104078:   void OnConnected(WebSocketChannel *aChannel)
103141:   {
103141:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
103141:     NS_ABORT_IF_FALSE(aChannel->mConnecting == CONNECTING_IN_PROGRESS,
103141:                       "Channel completed connect, but not connecting?");
103141: 
103141:     aChannel->mConnecting = NOT_CONNECTING;
103141: 
103141:     // Remove from queue
103141:     RemoveFromQueue(aChannel);
103141: 
103141:     // Connection succeeded, so stop keeping track of any previous failures
103141:     mFailures.Remove(aChannel->mAddress, aChannel->mPort);
103141: 
103141:     // Check for queued connections to same host.
103141:     // Note: still need to check for failures, since next websocket with same
103141:     // host may have different port
104078:     ConnectNext(aChannel->mAddress);
103141:   }
103141: 
103141:   // Called every time a websocket channel ends its session (including going away
103141:   // w/o ever successfully creating a connection)
104078:   void OnStopSession(WebSocketChannel *aChannel, nsresult aReason)
103141:   {
103141:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
103141: 
103141:     if (NS_FAILED(aReason)) {
103141:       // Have we seen this failure before?
103141:       FailDelay *knownFailure = mFailures.Lookup(aChannel->mAddress,
103141:                                                  aChannel->mPort);
103141:       if (knownFailure) {
103141:         // repeated failure to connect: increase delay for next connection
103141:         knownFailure->FailedAgain();
103141:       } else {
103141:         // new connection failure: record it.
103141:         LOG(("WebSocket: connection to %s, %d failed: [this=%p]",
103141:               aChannel->mAddress.get(), (int)aChannel->mPort, aChannel));
103141:         mFailures.Add(aChannel->mAddress, aChannel->mPort);
103141:       }
103141:     }
103141: 
103141:     if (aChannel->mConnecting) {
103141:       // Only way a connecting channel may get here w/o failing is if it was
103141:       // closed with GOING_AWAY (1001) because of navigation, tab close, etc.
103141:       NS_ABORT_IF_FALSE(NS_FAILED(aReason) ||
103141:                         aChannel->mScriptCloseCode == CLOSE_GOING_AWAY,
103141:                         "websocket closed while connecting w/o failing?");
103141: 
103141:       RemoveFromQueue(aChannel);
103141: 
103141:       bool wasNotQueued = (aChannel->mConnecting != CONNECTING_QUEUED);
103141:       aChannel->mConnecting = NOT_CONNECTING;
104078:       if (wasNotQueued) {
104078:         ConnectNext(aChannel->mAddress);
103141:       }
103141:     }
104078:   }
104078: 
104078:   void ConnectNext(nsCString &hostName)
103141:   {
108991:     int32_t index = IndexOf(hostName);
103141:     if (index >= 0) {
103141:       WebSocketChannel *chan = mQueue[index]->mChannel;
103141: 
103141:       NS_ABORT_IF_FALSE(chan->mConnecting == CONNECTING_QUEUED,
103141:                         "transaction not queued but in queue");
103141:       LOG(("WebSocket: ConnectNext: found channel [this=%p] in queue", chan));
103141: 
104078:       mFailures.DelayOrBegin(chan);
103141:     }
103141:   }
103141: 
103141:   void IncrementSessionCount()
103141:   {
103141:     PR_ATOMIC_INCREMENT(&mSessionCount);
103141:   }
103141: 
103141:   void DecrementSessionCount()
103141:   {
103141:     PR_ATOMIC_DECREMENT(&mSessionCount);
103141:   }
103141: 
108991:   int32_t SessionCount()
103141:   {
103141:     return mSessionCount;
103141:   }
103141: 
103141: private:
103141: 
103141:   void RemoveFromQueue(WebSocketChannel *aChannel)
103141:   {
108991:     int32_t index = IndexOf(aChannel);
103141:     NS_ABORT_IF_FALSE(index >= 0, "connection to remove not in queue");
103141:     if (index >= 0) {
103141:       nsOpenConn *olddata = mQueue[index];
103141:       mQueue.RemoveElementAt(index);
103141:       delete olddata;
103141:     }
103141:   }
103141: 
108991:   int32_t IndexOf(nsCString &aStr)
103141:   {
108991:     for (uint32_t i = 0; i < mQueue.Length(); i++)
103141:       if (aStr == (mQueue[i])->mAddress)
103141:         return i;
103141:     return -1;
103141:   }
103141: 
108991:   int32_t IndexOf(WebSocketChannel *aChannel)
103141:   {
108991:     for (uint32_t i = 0; i < mQueue.Length(); i++)
103141:       if (aChannel == (mQueue[i])->mChannel)
103141:         return i;
103141:     return -1;
103141:   }
103141: 
103141:   // SessionCount might be decremented from the main or the socket
103141:   // thread, so manage it with atomic counters
108991:   int32_t               mSessionCount;
103141: 
103141:   // Queue for websockets that have not completed connecting yet.
103141:   // The first nsOpenConn with a given address will be either be
103141:   // CONNECTING_IN_PROGRESS or CONNECTING_DELAYED.  Later ones with the same
103141:   // hostname must be CONNECTING_QUEUED.
103141:   //
103141:   // We could hash hostnames instead of using a single big vector here, but the
103141:   // dataset is expected to be small.
103141:   nsTArray<nsOpenConn *> mQueue;
103141: 
103141:   FailDelayManager       mFailures;
103141: };
103141: 
106838: static nsWSAdmissionManager *sWebSocketAdmissions = nullptr;
103141: 
103141: //-----------------------------------------------------------------------------
 84709: // CallOnMessageAvailable
 84709: //-----------------------------------------------------------------------------
 84709: 
101868: class CallOnMessageAvailable MOZ_FINAL : public nsIRunnable
 70220: {
 70220: public:
 70220:   NS_DECL_ISUPPORTS
 70220: 
 80658:   CallOnMessageAvailable(WebSocketChannel *aChannel,
 70220:                          nsCString        &aData,
108991:                          int32_t           aLen)
 80658:     : mChannel(aChannel),
 70220:       mData(aData),
 70220:       mLen(aLen) {}
 70220: 
 84709:   NS_IMETHOD Run()
 70220:   {
 70220:     if (mLen < 0)
 80658:       mChannel->mListener->OnMessageAvailable(mChannel->mContext, mData);
 70220:     else
 80658:       mChannel->mListener->OnBinaryMessageAvailable(mChannel->mContext, mData);
 70220:     return NS_OK;
 70220:   }
 70220: 
 70220: private:
 70220:   ~CallOnMessageAvailable() {}
 70220: 
 80658:   nsRefPtr<WebSocketChannel>        mChannel;
 70220:   nsCString                         mData;
108991:   int32_t                           mLen;
 70220: };
 70220: NS_IMPL_THREADSAFE_ISUPPORTS1(CallOnMessageAvailable, nsIRunnable)
 70220: 
 84709: //-----------------------------------------------------------------------------
 84709: // CallOnStop
 84709: //-----------------------------------------------------------------------------
 84709: 
101868: class CallOnStop MOZ_FINAL : public nsIRunnable
 70220: {
 70220: public:
 70220:   NS_DECL_ISUPPORTS
 70220: 
 80658:   CallOnStop(WebSocketChannel *aChannel,
103141:              nsresult          aReason)
 80658:     : mChannel(aChannel),
103141:       mReason(aReason) {}
 70220: 
 84709:   NS_IMETHOD Run()
 70220:   {
 86783:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
103141: 
103141:     sWebSocketAdmissions->OnStopSession(mChannel, mReason);
103141: 
103329:     if (mChannel->mListener) {
103141:       mChannel->mListener->OnStop(mChannel->mContext, mReason);
106838:       mChannel->mListener = nullptr;
106838:       mChannel->mContext = nullptr;
103329:     }
 70220:     return NS_OK;
 70220:   }
 70220: 
 70220: private:
 70220:   ~CallOnStop() {}
 70220: 
 80658:   nsRefPtr<WebSocketChannel>        mChannel;
103141:   nsresult                          mReason;
 70220: };
 70220: NS_IMPL_THREADSAFE_ISUPPORTS1(CallOnStop, nsIRunnable)
 70220: 
 84709: //-----------------------------------------------------------------------------
 84709: // CallOnServerClose
 84709: //-----------------------------------------------------------------------------
 84709: 
101868: class CallOnServerClose MOZ_FINAL : public nsIRunnable
 70220: {
 70220: public:
 70220:   NS_DECL_ISUPPORTS
 70220: 
 80658:   CallOnServerClose(WebSocketChannel *aChannel,
108991:                     uint16_t          aCode,
 74812:                     nsCString        &aReason)
 80658:     : mChannel(aChannel),
 74812:       mCode(aCode),
 74812:       mReason(aReason) {}
 70220: 
 84709:   NS_IMETHOD Run()
 70220:   {
 80658:     mChannel->mListener->OnServerClose(mChannel->mContext, mCode, mReason);
 70220:     return NS_OK;
 70220:   }
 70220: 
 70220: private:
 70220:   ~CallOnServerClose() {}
 70220: 
 80658:   nsRefPtr<WebSocketChannel>        mChannel;
108991:   uint16_t                          mCode;
 74812:   nsCString                         mReason;
 70220: };
 70220: NS_IMPL_THREADSAFE_ISUPPORTS1(CallOnServerClose, nsIRunnable)
 70220: 
 84709: //-----------------------------------------------------------------------------
 84709: // CallAcknowledge
 84709: //-----------------------------------------------------------------------------
 84709: 
101868: class CallAcknowledge MOZ_FINAL : public nsIRunnable
 70220: {
 70220: public:
 70220:   NS_DECL_ISUPPORTS
 70220: 
 80658:   CallAcknowledge(WebSocketChannel *aChannel,
108991:                   uint32_t          aSize)
 80658:     : mChannel(aChannel),
 70220:       mSize(aSize) {}
 70220: 
 84709:   NS_IMETHOD Run()
 70220:   {
 73021:     LOG(("WebSocketChannel::CallAcknowledge: Size %u\n", mSize));
 80658:     mChannel->mListener->OnAcknowledge(mChannel->mContext, mSize);
 70220:     return NS_OK;
 70220:   }
 70220: 
 70220: private:
 70220:   ~CallAcknowledge() {}
 70220: 
 80658:   nsRefPtr<WebSocketChannel>        mChannel;
108991:   uint32_t                          mSize;
 70220: };
 70220: NS_IMPL_THREADSAFE_ISUPPORTS1(CallAcknowledge, nsIRunnable)
 70220: 
 84709: //-----------------------------------------------------------------------------
 96974: // CallOnTransportAvailable
 96974: //-----------------------------------------------------------------------------
 96974: 
101868: class CallOnTransportAvailable MOZ_FINAL : public nsIRunnable
 96974: {
 96974: public:
 96974:   NS_DECL_ISUPPORTS
 96974: 
 96974:   CallOnTransportAvailable(WebSocketChannel *aChannel,
 96974:                            nsISocketTransport *aTransport,
 96974:                            nsIAsyncInputStream *aSocketIn,
 96974:                            nsIAsyncOutputStream *aSocketOut)
 96974:     : mChannel(aChannel),
 96974:       mTransport(aTransport),
 96974:       mSocketIn(aSocketIn),
 96974:       mSocketOut(aSocketOut) {}
 96974: 
 96974:   NS_IMETHOD Run()
 96974:   {
 96974:     LOG(("WebSocketChannel::CallOnTransportAvailable %p\n", this));
 96974:     return mChannel->OnTransportAvailable(mTransport, mSocketIn, mSocketOut);
 96974:   }
 96974: 
 96974: private:
 96974:   ~CallOnTransportAvailable() {}
 96974: 
 96974:   nsRefPtr<WebSocketChannel>     mChannel;
 96974:   nsCOMPtr<nsISocketTransport>   mTransport;
 96974:   nsCOMPtr<nsIAsyncInputStream>  mSocketIn;
 96974:   nsCOMPtr<nsIAsyncOutputStream> mSocketOut;
 96974: };
 96974: NS_IMPL_THREADSAFE_ISUPPORTS1(CallOnTransportAvailable, nsIRunnable)
 96974: 
 96974: //-----------------------------------------------------------------------------
 84709: // OutboundMessage
 84709: //-----------------------------------------------------------------------------
 84709: 
 84709: enum WsMsgType {
 84709:   kMsgTypeString = 0,
 84709:   kMsgTypeBinaryString,
 84709:   kMsgTypeStream,
 84709:   kMsgTypePing,
 84709:   kMsgTypePong,
 84709:   kMsgTypeFin
 84709: };
 84709: 
 84709: static const char* msgNames[] = {
 84709:   "text",
 84709:   "binaryString",
 84709:   "binaryStream",
 84709:   "ping",
 84709:   "pong",
 84709:   "close"
 84709: };
 84709: 
 84709: class OutboundMessage
 84709: {
 84709: public:
 84709:   OutboundMessage(WsMsgType type, nsCString *str)
 84709:     : mMsgType(type)
 84709:   {
 84709:     MOZ_COUNT_CTOR(OutboundMessage);
 84709:     mMsg.pString = str;
 84709:     mLength = str ? str->Length() : 0;
 84709:   }
 84709: 
108991:   OutboundMessage(nsIInputStream *stream, uint32_t length)
 84709:     : mMsgType(kMsgTypeStream), mLength(length)
 84709:   {
 84709:     MOZ_COUNT_CTOR(OutboundMessage);
 84709:     mMsg.pStream = stream;
 84709:     mMsg.pStream->AddRef();
 84709:   }
 84709: 
 84709:  ~OutboundMessage() {
 84709:     MOZ_COUNT_DTOR(OutboundMessage);
 84709:     switch (mMsgType) {
 84709:       case kMsgTypeString:
 84709:       case kMsgTypeBinaryString:
 84709:       case kMsgTypePing:
 84709:       case kMsgTypePong:
 84709:         delete mMsg.pString;
 84709:         break;
 84709:       case kMsgTypeStream:
 84709:         // for now this only gets hit if msg deleted w/o being sent
 84709:         if (mMsg.pStream) {
 84709:           mMsg.pStream->Close();
 84709:           mMsg.pStream->Release();
 84709:         }
 84709:         break;
 84709:       case kMsgTypeFin:
 84709:         break;    // do-nothing: avoid compiler warning
 84709:     }
 84709:   }
 84709: 
 84709:   WsMsgType GetMsgType() const { return mMsgType; }
108991:   int32_t Length() const { return mLength; }
108991: 
108991:   uint8_t* BeginWriting() {
 84709:     NS_ABORT_IF_FALSE(mMsgType != kMsgTypeStream,
 84709:                       "Stream should have been converted to string by now");
108991:     return (uint8_t *)(mMsg.pString ? mMsg.pString->BeginWriting() : nullptr);
 84709:   }
 84709: 
108991:   uint8_t* BeginReading() {
 84709:     NS_ABORT_IF_FALSE(mMsgType != kMsgTypeStream,
 84709:                       "Stream should have been converted to string by now");
108991:     return (uint8_t *)(mMsg.pString ? mMsg.pString->BeginReading() : nullptr);
 84709:   }
 84709: 
 84709:   nsresult ConvertStreamToString()
 84709:   {
 84709:     NS_ABORT_IF_FALSE(mMsgType == kMsgTypeStream, "Not a stream!");
 84709: 
 84709: #ifdef DEBUG
 84709:     // Make sure we got correct length from Blob
108991:     uint64_t bytes;
 84709:     mMsg.pStream->Available(&bytes);
 84709:     NS_ASSERTION(bytes == mLength, "Stream length != blob length!");
 84709: #endif
 84709: 
 84709:     nsAutoPtr<nsCString> temp(new nsCString());
 84709:     nsresult rv = NS_ReadInputStreamToString(mMsg.pStream, *temp, mLength);
 84709: 
 84709:     NS_ENSURE_SUCCESS(rv, rv);
 84709: 
 84709:     mMsg.pStream->Close();
 84709:     mMsg.pStream->Release();
 84709:     mMsg.pString = temp.forget();
 84709:     mMsgType = kMsgTypeBinaryString;
 84709: 
 84709:     return NS_OK;
 84709:   }
 84709: 
 84709: private:
 84709:   union {
 84709:     nsCString      *pString;
 84709:     nsIInputStream *pStream;
 84709:   }                           mMsg;
 84709:   WsMsgType                   mMsgType;
108991:   uint32_t                    mLength;
 84709: };
 84709: 
 84709: //-----------------------------------------------------------------------------
 84709: // OutboundEnqueuer
 84709: //-----------------------------------------------------------------------------
 84709: 
101868: class OutboundEnqueuer MOZ_FINAL : public nsIRunnable
 70220: {
 70220: public:
 70220:   NS_DECL_ISUPPORTS
 70220: 
 84709:   OutboundEnqueuer(WebSocketChannel *aChannel, OutboundMessage *aMsg)
 84709:     : mChannel(aChannel), mMessage(aMsg) {}
 84709: 
 84709:   NS_IMETHOD Run()
 70220:   {
 84709:     mChannel->EnqueueOutgoingMessage(mChannel->mOutgoingMessages, mMessage);
 70220:     return NS_OK;
 70220:   }
 70220: 
 70220: private:
 84709:   ~OutboundEnqueuer() {}
 70220: 
 73020:   nsRefPtr<WebSocketChannel>  mChannel;
 84709:   OutboundMessage            *mMessage;
 70220: };
 84709: NS_IMPL_THREADSAFE_ISUPPORTS1(OutboundEnqueuer, nsIRunnable)
 84709: 
 84709: //-----------------------------------------------------------------------------
 84709: // nsWSCompression
 84709: //
 70220: // similar to nsDeflateConverter except for the mandatory FLUSH calls
 70220: // required by websocket and the absence of the deflate termination
 70220: // block which is appropriate because it would create data bytes after
 70220: // sending the websockets CLOSE message.
 84709: //-----------------------------------------------------------------------------
 70220: 
 70220: class nsWSCompression
 70220: {
 70220: public:
 70220:   nsWSCompression(nsIStreamListener *aListener,
 70220:                   nsISupports *aContext)
 80486:     : mActive(false),
 70220:       mContext(aContext),
 70220:       mListener(aListener)
 70220:   {
 71457:     MOZ_COUNT_CTOR(nsWSCompression);
 71457: 
 70220:     mZlib.zalloc = allocator;
 70220:     mZlib.zfree = destructor;
 70220:     mZlib.opaque = Z_NULL;
 70220: 
 70220:     // Initialize the compressor - these are all the normal zlib
 70220:     // defaults except window size is set to -15 instead of +15.
 70220:     // This is the zlib way of specifying raw RFC 1951 output instead
 70220:     // of the zlib rfc 1950 format which has a 2 byte header and
 70220:     // adler checksum as a trailer
 70220: 
 70220:     nsresult rv;
 70220:     mStream = do_CreateInstance(NS_STRINGINPUTSTREAM_CONTRACTID, &rv);
 70220:     if (NS_SUCCEEDED(rv) && aContext && aListener &&
 73021:       deflateInit2(&mZlib, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -15, 8,
 73021:                    Z_DEFAULT_STRATEGY) == Z_OK) {
 80486:       mActive = true;
 70220:     }
 70220:   }
 70220: 
 70220:   ~nsWSCompression()
 70220:   {
 71457:     MOZ_COUNT_DTOR(nsWSCompression);
 71457: 
 70220:     if (mActive)
 70220:       deflateEnd(&mZlib);
 70220:   }
 70220: 
 79445:   bool Active()
 70220:   {
 70220:     return mActive;
 70220:   }
 70220: 
108991:   nsresult Deflate(uint8_t *buf1, uint32_t buf1Len,
108991:                    uint8_t *buf2, uint32_t buf2Len)
 70220:   {
 70220:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread,
 70220:                           "not socket thread");
 70220:     NS_ABORT_IF_FALSE(mActive, "not active");
 70220: 
 70220:     mZlib.avail_out = kBufferLen;
 70220:     mZlib.next_out = mBuffer;
 70220:     mZlib.avail_in = buf1Len;
 70220:     mZlib.next_in = buf1;
 70220: 
 70220:     nsresult rv;
 70220: 
 70220:     while (mZlib.avail_in > 0) {
 70220:       deflate(&mZlib, (buf2Len > 0) ? Z_NO_FLUSH : Z_SYNC_FLUSH);
 70220:       rv = PushData();
 70220:       if (NS_FAILED(rv))
 70220:         return rv;
 70220:       mZlib.avail_out = kBufferLen;
 70220:       mZlib.next_out = mBuffer;
 70220:     }
 70220: 
 70220:     mZlib.avail_in = buf2Len;
 70220:     mZlib.next_in = buf2;
 70220: 
 70220:     while (mZlib.avail_in > 0) {
 70220:       deflate(&mZlib, Z_SYNC_FLUSH);
 70220:       rv = PushData();
 70220:       if (NS_FAILED(rv))
 70220:         return rv;
 70220:       mZlib.avail_out = kBufferLen;
 70220:       mZlib.next_out = mBuffer;
 70220:     }
 70220: 
 70220:     return NS_OK;
 70220:   }
 70220: 
 70220: private:
 70220: 
 70220:   // use zlib data types
 70220:   static void *allocator(void *opaque, uInt items, uInt size)
 70220:   {
 70220:     return moz_xmalloc(items * size);
 70220:   }
 70220: 
 70220:   static void destructor(void *opaque, void *addr)
 70220:   {
 70220:     moz_free(addr);
 70220:   }
 70220: 
 70220:   nsresult PushData()
 70220:   {
108991:     uint32_t bytesToWrite = kBufferLen - mZlib.avail_out;
 70220:     if (bytesToWrite > 0) {
 70220:       mStream->ShareData(reinterpret_cast<char *>(mBuffer), bytesToWrite);
 73021:       nsresult rv =
106838:         mListener->OnDataAvailable(nullptr, mContext, mStream, 0, bytesToWrite);
 70220:       if (NS_FAILED(rv))
 70220:         return rv;
 70220:     }
 70220:     return NS_OK;
 70220:   }
 70220: 
 79445:   bool                            mActive;
 70220:   z_stream                        mZlib;
 70220:   nsCOMPtr<nsIStringInputStream>  mStream;
 70220: 
 70220:   nsISupports                    *mContext;     /* weak ref */
 70220:   nsIStreamListener              *mListener;    /* weak ref */
 70220: 
108991:   const static int32_t            kBufferLen = 4096;
108991:   uint8_t                         mBuffer[kBufferLen];
 70220: };
 70220: 
 84709: //-----------------------------------------------------------------------------
 73020: // WebSocketChannel
 84709: //-----------------------------------------------------------------------------
 73020: 
 73020: WebSocketChannel::WebSocketChannel() :
103141:   mPort(0),
 70220:   mCloseTimeout(20000),
 70220:   mOpenTimeout(20000),
103141:   mConnecting(NOT_CONNECTING),
 70220:   mPingTimeout(0),
 70220:   mPingResponseTimeout(10000),
 72502:   mMaxConcurrentConnections(200),
 70220:   mRecvdHttpOnStartRequest(0),
 70220:   mRecvdHttpUpgradeTransport(0),
 70220:   mRequestedClose(0),
 70220:   mClientClosed(0),
 70220:   mServerClosed(0),
 70220:   mStopped(0),
 70220:   mCalledOnStop(0),
 70220:   mPingOutstanding(0),
 70220:   mAllowCompression(1),
 70220:   mAutoFollowRedirects(0),
 70220:   mReleaseOnTransmit(0),
 72181:   mTCPClosed(0),
104079:   mWasOpened(0),
104079:   mOpenedHttpChannel(0),
 96974:   mDataStarted(0),
 99957:   mIncrementedSessionCount(0),
 99957:   mDecrementedSessionCount(0),
115367:   mMaxMessageSize(INT32_MAX),
 70220:   mStopOnClose(NS_OK),
 74812:   mServerCloseCode(CLOSE_ABNORMAL),
 74812:   mScriptCloseCode(0),
 75095:   mFragmentOpcode(kContinuation),
 70220:   mFragmentAccumulator(0),
 70220:   mBuffered(0),
 85010:   mBufferSize(kIncomingBufferInitialSize),
106838:   mCurrentOut(nullptr),
 70220:   mCurrentOutSent(0),
106838:   mCompressor(nullptr),
 70220:   mDynamicOutputSize(0),
106838:   mDynamicOutput(nullptr)
 70220: {
 70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 70220: 
 73020:   LOG(("WebSocketChannel::WebSocketChannel() %p\n", this));
 70220: 
 70220:   if (!sWebSocketAdmissions)
 70220:     sWebSocketAdmissions = new nsWSAdmissionManager();
 70220: 
108991:   mFramePtr = mBuffer = static_cast<uint8_t *>(moz_xmalloc(mBufferSize));
 70220: }
 70220: 
 73020: WebSocketChannel::~WebSocketChannel()
 70220: {
 73020:   LOG(("WebSocketChannel::~WebSocketChannel() %p\n", this));
 70220: 
104079:   if (mWasOpened) {
104079:     MOZ_ASSERT(mCalledOnStop, "WebSocket was opened but OnStop was not called");
104079:     MOZ_ASSERT(mStopped, "WebSocket was opened but never stopped");
104079:   }
104079:   MOZ_ASSERT(!mDNSRequest, "DNS Request still alive at destruction");
104079:   MOZ_ASSERT(!mConnecting, "Should not be connecting in destructor");
 70220: 
 70220:   moz_free(mBuffer);
 70220:   moz_free(mDynamicOutput);
 70220:   delete mCompressor;
 70220:   delete mCurrentOut;
 70220: 
 70220:   while ((mCurrentOut = (OutboundMessage *) mOutgoingPingMessages.PopFront()))
 70220:     delete mCurrentOut;
 70220:   while ((mCurrentOut = (OutboundMessage *) mOutgoingPongMessages.PopFront()))
 70220:     delete mCurrentOut;
 70220:   while ((mCurrentOut = (OutboundMessage *) mOutgoingMessages.PopFront()))
 70220:     delete mCurrentOut;
 70220: 
 70220:   nsCOMPtr<nsIThread> mainThread;
 70220:   nsIURI *forgettable;
 70220:   NS_GetMainThread(getter_AddRefs(mainThread));
 70220: 
 70220:   if (mURI) {
 70220:     mURI.forget(&forgettable);
 80486:     NS_ProxyRelease(mainThread, forgettable, false);
 70220:   }
 70220: 
 70220:   if (mOriginalURI) {
 70220:     mOriginalURI.forget(&forgettable);
 80486:     NS_ProxyRelease(mainThread, forgettable, false);
 70220:   }
 70220: 
 70220:   if (mListener) {
 70220:     nsIWebSocketListener *forgettableListener;
 70220:     mListener.forget(&forgettableListener);
 80486:     NS_ProxyRelease(mainThread, forgettableListener, false);
 70220:   }
 70220: 
 70220:   if (mContext) {
 70220:     nsISupports *forgettableContext;
 70220:     mContext.forget(&forgettableContext);
 80486:     NS_ProxyRelease(mainThread, forgettableContext, false);
 70220:   }
 73548: 
 73548:   if (mLoadGroup) {
 73548:     nsILoadGroup *forgettableGroup;
 73548:     mLoadGroup.forget(&forgettableGroup);
 80486:     NS_ProxyRelease(mainThread, forgettableGroup, false);
 73548:   }
 70220: }
 70220: 
 70220: void
 73020: WebSocketChannel::Shutdown()
 70220: {
 70220:   delete sWebSocketAdmissions;
106838:   sWebSocketAdmissions = nullptr;
 70220: }
 70220: 
104078: void
 73020: WebSocketChannel::BeginOpen()
 70220: {
 73020:   LOG(("WebSocketChannel::BeginOpen() %p\n", this));
 70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 70220: 
 70220:   nsresult rv;
 70220: 
104078:   // Important that we set CONNECTING_IN_PROGRESS before any call to
104078:   // AbortSession here: ensures that any remaining queued connection(s) are
104078:   // scheduled in OnStopSession
104078:   mConnecting = CONNECTING_IN_PROGRESS;
104078: 
 70220:   if (mRedirectCallback) {
 73021:     LOG(("WebSocketChannel::BeginOpen: Resuming Redirect\n"));
 70220:     rv = mRedirectCallback->OnRedirectVerifyCallback(NS_OK);
106838:     mRedirectCallback = nullptr;
104078:     return;
 70220:   }
 70220: 
 70220:   nsCOMPtr<nsIChannel> localChannel = do_QueryInterface(mChannel, &rv);
 70220:   if (NS_FAILED(rv)) {
 73021:     LOG(("WebSocketChannel::BeginOpen: cannot async open\n"));
 95225:     AbortSession(NS_ERROR_UNEXPECTED);
104078:     return;
 70220:   }
 70220: 
 70220:   rv = localChannel->AsyncOpen(this, mHttpChannel);
 70220:   if (NS_FAILED(rv)) {
 73021:     LOG(("WebSocketChannel::BeginOpen: cannot async open\n"));
 70220:     AbortSession(NS_ERROR_CONNECTION_REFUSED);
104078:     return;
 70220:   }
104079:   mOpenedHttpChannel = 1;
 70220: 
 70220:   mOpenTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
103141:   if (NS_FAILED(rv)) {
103141:     LOG(("WebSocketChannel::BeginOpen: cannot create open timer\n"));
103141:     AbortSession(NS_ERROR_UNEXPECTED);
104078:     return;
103141:   }
103141: 
103141:   rv = mOpenTimer->InitWithCallback(this, mOpenTimeout,
103141:                                     nsITimer::TYPE_ONE_SHOT);
103141:   if (NS_FAILED(rv)) {
103141:     LOG(("WebSocketChannel::BeginOpen: cannot initialize open timer\n"));
103141:     AbortSession(NS_ERROR_UNEXPECTED);
104078:     return;
103141:   }
 70220: }
 70220: 
 79445: bool
 73020: WebSocketChannel::IsPersistentFramePtr()
 70220: {
 70220:   return (mFramePtr >= mBuffer && mFramePtr < mBuffer + mBufferSize);
 70220: }
 70220: 
 73021: // Extends the internal buffer by count and returns the total
 70220: // amount of data available for read
 74275: //
 74275: // Accumulated fragment size is passed in instead of using the member
 74275: // variable beacuse when transitioning from the stack to the persistent
 74275: // read buffer we want to explicitly include them in the buffer instead
 74275: // of as already existing data.
 85010: bool
108991: WebSocketChannel::UpdateReadBuffer(uint8_t *buffer, uint32_t count,
108991:                                    uint32_t accumulatedFragments,
108991:                                    uint32_t *available)
 70220: {
 73020:   LOG(("WebSocketChannel::UpdateReadBuffer() %p [%p %u]\n",
 70220:          this, buffer, count));
 70220: 
 70220:   if (!mBuffered)
 70220:     mFramePtr = mBuffer;
 70220: 
 73021:   NS_ABORT_IF_FALSE(IsPersistentFramePtr(), "update read buffer bad mFramePtr");
 74275:   NS_ABORT_IF_FALSE(mFramePtr - accumulatedFragments >= mBuffer,
 74275:                     "reserved FramePtr bad");
 70220: 
 70220:   if (mBuffered + count <= mBufferSize) {
 70220:     // append to existing buffer
 73021:     LOG(("WebSocketChannel: update read buffer absorbed %u\n", count));
 74275:   } else if (mBuffered + count - 
 74275:              (mFramePtr - accumulatedFragments - mBuffer) <= mBufferSize) {
 70220:     // make room in existing buffer by shifting unused data to start
 74275:     mBuffered -= (mFramePtr - mBuffer - accumulatedFragments);
 73021:     LOG(("WebSocketChannel: update read buffer shifted %u\n", mBuffered));
 74275:     ::memmove(mBuffer, mFramePtr - accumulatedFragments, mBuffered);
 74275:     mFramePtr = mBuffer + accumulatedFragments;
 73021:   } else {
 70220:     // existing buffer is not sufficient, extend it
 85010:     mBufferSize += count + 8192 + mBufferSize/3;
 73021:     LOG(("WebSocketChannel: update read buffer extended to %u\n", mBufferSize));
108991:     uint8_t *old = mBuffer;
108991:     mBuffer = (uint8_t *)moz_realloc(mBuffer, mBufferSize);
 85010:     if (!mBuffer) {
 85010:       mBuffer = old;
 85010:       return false;
 85010:     }
 70220:     mFramePtr = mBuffer + (mFramePtr - old);
 70220:   }
 70220: 
 70220:   ::memcpy(mBuffer + mBuffered, buffer, count);
 70220:   mBuffered += count;
 70220: 
 85010:   if (available)
 85010:     *available = mBuffered - (mFramePtr - mBuffer);
 85010: 
 85010:   return true;
 70220: }
 70220: 
 70220: nsresult
108991: WebSocketChannel::ProcessInput(uint8_t *buffer, uint32_t count)
 70220: {
 73021:   LOG(("WebSocketChannel::ProcessInput %p [%d %d]\n", this, count, mBuffered));
 73021:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
 70220: 
 70220:   // reset the ping timer
 70220:   if (mPingTimer) {
 70220:     // The purpose of ping/pong is to actively probe the peer so that an
 70220:     // unreachable peer is not mistaken for a period of idleness. This
 73021:     // implementation accepts any application level read activity as a sign of
 73021:     // life, it does not necessarily have to be a pong.
 70220:     mPingOutstanding = 0;
 70220:     mPingTimer->SetDelay(mPingTimeout);
 70220:   }
 70220: 
108991:   uint32_t avail;
 70220: 
 70220:   if (!mBuffered) {
 73021:     // Most of the time we can process right off the stack buffer without
 73021:     // having to accumulate anything
 70220:     mFramePtr = buffer;
 70220:     avail = count;
 73021:   } else {
 85010:     if (!UpdateReadBuffer(buffer, count, mFragmentAccumulator, &avail)) {
 85010:       return NS_ERROR_FILE_TOO_BIG;
 85010:     }
 70220:   }
 70220: 
108991:   uint8_t *payload;
108991:   uint32_t totalAvail = avail;
 70220: 
 70220:   while (avail >= 2) {
108991:     int64_t payloadLength = mFramePtr[1] & 0x7F;
108991:     uint8_t finBit        = mFramePtr[0] & kFinalFragBit;
108991:     uint8_t rsvBits       = mFramePtr[0] & 0x70;
108991:     uint8_t maskBit       = mFramePtr[1] & kMaskBit;
108991:     uint8_t opcode        = mFramePtr[0] & 0x0F;
108991: 
108991:     uint32_t framingLength = 2;
 70220:     if (maskBit)
 70220:       framingLength += 4;
 70220: 
 70220:     if (payloadLength < 126) {
 70220:       if (avail < framingLength)
 70220:         break;
 73021:     } else if (payloadLength == 126) {
 70220:       // 16 bit length field
 70220:       framingLength += 2;
 70220:       if (avail < framingLength)
 70220:         break;
 70220: 
 70220:       payloadLength = mFramePtr[2] << 8 | mFramePtr[3];
 73021:     } else {
 70220:       // 64 bit length
 70220:       framingLength += 8;
 70220:       if (avail < framingLength)
 70220:         break;
 72178: 
 72178:       if (mFramePtr[2] & 0x80) {
 72178:         // Section 4.2 says that the most significant bit MUST be
 72178:         // 0. (i.e. this is really a 63 bit value)
 73020:         LOG(("WebSocketChannel:: high bit of 64 bit length set"));
 72178:         return NS_ERROR_ILLEGAL_VALUE;
 72178:       }
 72178: 
 70220:       // copy this in case it is unaligned
108991:       uint64_t tempLen;
 70220:       memcpy(&tempLen, mFramePtr + 2, 8);
 70220:       payloadLength = PR_ntohll(tempLen);
 70220:     }
 70220: 
 70220:     payload = mFramePtr + framingLength;
 70220:     avail -= framingLength;
 70220: 
 73021:     LOG(("WebSocketChannel::ProcessInput: payload %lld avail %lu\n",
 70220:          payloadLength, avail));
 70220: 
 70220:     if (payloadLength + mFragmentAccumulator > mMaxMessageSize) {
 70220:       return NS_ERROR_FILE_TOO_BIG;
 70220:     }
 70220: 
 70220:     if (avail < payloadLength)
 70220:       break;
 70220: 
 73021:     LOG(("WebSocketChannel::ProcessInput: Frame accumulated - opcode %d\n",
 70220:          opcode));
 70220: 
 70220:     if (maskBit) {
 70220:       // This is unexpected - the server does not generally send masked
 70220:       // frames to the client, but it is allowed
 73020:       LOG(("WebSocketChannel:: Client RECEIVING masked frame."));
 70220: 
108991:       uint32_t mask;
 70220:       memcpy(&mask, payload - 4, 4);
 70220:       mask = PR_ntohl(mask);
 70220:       ApplyMask(mask, payload, payloadLength);
 70220:     }
 70220: 
 73021:     // Control codes are required to have the fin bit set
 70220:     if (!finBit && (opcode & kControlFrameMask)) {
 73021:       LOG(("WebSocketChannel:: fragmented control frame code %d\n", opcode));
 70220:       return NS_ERROR_ILLEGAL_VALUE;
 70220:     }
 70220: 
 70220:     if (rsvBits) {
 73020:       LOG(("WebSocketChannel:: unexpected reserved bits %x\n", rsvBits));
 70220:       return NS_ERROR_ILLEGAL_VALUE;
 70220:     }
 70220: 
 70220:     if (!finBit || opcode == kContinuation) {
 70220:       // This is part of a fragment response
 70220: 
 73021:       // Only the first frame has a non zero op code: Make sure we don't see a
 73021:       // first frame while some old fragments are open
 70220:       if ((mFragmentAccumulator != 0) && (opcode != kContinuation)) {
 75095:         LOG(("WebSocketChannel:: nested fragments\n"));
 70220:         return NS_ERROR_ILLEGAL_VALUE;
 70220:       }
 70220: 
 73021:       LOG(("WebSocketChannel:: Accumulating Fragment %lld\n", payloadLength));
 70220: 
 70220:       if (opcode == kContinuation) {
 75095: 
 75095:         // Make sure this continuation fragment isn't the first fragment
 75095:         if (mFragmentOpcode == kContinuation) {
 75095:           LOG(("WebSocketHeandler:: continuation code in first fragment\n"));
 75095:           return NS_ERROR_ILLEGAL_VALUE;
 75095:         }
 75095: 
 73021:         // For frag > 1 move the data body back on top of the headers
 70220:         // so we have contiguous stream of data
 70220:         NS_ABORT_IF_FALSE(mFramePtr + framingLength == payload,
 70220:                           "payload offset from frameptr wrong");
 70220:         ::memmove(mFramePtr, payload, avail);
 70220:         payload = mFramePtr;
 70220:         if (mBuffered)
 70220:           mBuffered -= framingLength;
 73021:       } else {
 70220:         mFragmentOpcode = opcode;
 70220:       }
 70220: 
 70220:       if (finBit) {
 73020:         LOG(("WebSocketChannel:: Finalizing Fragment\n"));
 70220:         payload -= mFragmentAccumulator;
 70220:         payloadLength += mFragmentAccumulator;
 70220:         avail += mFragmentAccumulator;
 70220:         mFragmentAccumulator = 0;
 70220:         opcode = mFragmentOpcode;
 75095:         // reset to detect if next message illegally starts with continuation
 75095:         mFragmentOpcode = kContinuation;
 70220:       } else {
 70220:         opcode = kContinuation;
 70220:         mFragmentAccumulator += payloadLength;
 70220:       }
 73021:     } else if (mFragmentAccumulator != 0 && !(opcode & kControlFrameMask)) {
 73021:       // This frame is not part of a fragment sequence but we
 70220:       // have an open fragment.. it must be a control code or else
 70220:       // we have a problem
 73021:       LOG(("WebSocketChannel:: illegal fragment sequence\n"));
 70220:       return NS_ERROR_ILLEGAL_VALUE;
 70220:     }
 70220: 
 70220:     if (mServerClosed) {
 73020:       LOG(("WebSocketChannel:: ignoring read frame code %d after close\n",
 70220:                  opcode));
 70220:       // nop
 73021:     } else if (mStopped) {
 73021:       LOG(("WebSocketChannel:: ignoring read frame code %d after completion\n",
 70220:            opcode));
 73021:     } else if (opcode == kText) {
 73020:       LOG(("WebSocketChannel:: text frame received\n"));
 70220:       if (mListener) {
101813:         nsCString utf8Data;
101813:         if (!utf8Data.Assign((const char *)payload, payloadLength,
101813:                              mozilla::fallible_t()))
101813:           return NS_ERROR_OUT_OF_MEMORY;
 72179: 
 85008:         // Section 8.1 says to fail connection if invalid utf-8 in text message
 80486:         if (!IsUTF8(utf8Data, false)) {
 73020:           LOG(("WebSocketChannel:: text frame invalid utf-8\n"));
 95225:           return NS_ERROR_CANNOT_CONVERT_DATA;
 72179:         }
 72179: 
 80658:         NS_DispatchToMainThread(new CallOnMessageAvailable(this, utf8Data, -1));
 70220:       }
 73021:     } else if (opcode & kControlFrameMask) {
 70220:       // control frames
 70220:       if (payloadLength > 125) {
 73020:         LOG(("WebSocketChannel:: bad control frame code %d length %d\n",
 70220:              opcode, payloadLength));
 70220:         return NS_ERROR_ILLEGAL_VALUE;
 70220:       }
 70220: 
 70220:       if (opcode == kClose) {
 73020:         LOG(("WebSocketChannel:: close received\n"));
 70220:         mServerClosed = 1;
 70220: 
 74812:         mServerCloseCode = CLOSE_NO_STATUS;
 70220:         if (payloadLength >= 2) {
 74812:           memcpy(&mServerCloseCode, payload, 2);
 74812:           mServerCloseCode = PR_ntohs(mServerCloseCode);
 74812:           LOG(("WebSocketChannel:: close recvd code %u\n", mServerCloseCode));
108991:           uint16_t msglen = payloadLength - 2;
 70220:           if (msglen > 0) {
 74812:             mServerCloseReason.SetLength(msglen);
 74812:             memcpy(mServerCloseReason.BeginWriting(),
 74812:                    (const char *)payload + 2, msglen);
 72179: 
 72179:             // section 8.1 says to replace received non utf-8 sequences
 72179:             // (which are non-conformant to send) with u+fffd,
 72179:             // but secteam feels that silently rewriting messages is
 72179:             // inappropriate - so we will fail the connection instead.
 80486:             if (!IsUTF8(mServerCloseReason, false)) {
 73020:               LOG(("WebSocketChannel:: close frame invalid utf-8\n"));
 95225:               return NS_ERROR_CANNOT_CONVERT_DATA;
 72179:             }
 72179: 
 74812:             LOG(("WebSocketChannel:: close msg %s\n",
 74812:                  mServerCloseReason.get()));
 70220:           }
 70220:         }
 70220: 
 70220:         if (mCloseTimer) {
 70220:           mCloseTimer->Cancel();
106838:           mCloseTimer = nullptr;
 70220:         }
 80658:         if (mListener) {
 80658:           NS_DispatchToMainThread(new CallOnServerClose(this, mServerCloseCode,
 80658:                                                         mServerCloseReason));
 80658:         }
 70220: 
 70220:         if (mClientClosed)
 70220:           ReleaseSession();
 73021:       } else if (opcode == kPing) {
 73020:         LOG(("WebSocketChannel:: ping received\n"));
 70220:         GeneratePong(payload, payloadLength);
 74912:       } else if (opcode == kPong) {
 73021:         // opcode kPong: the mere act of receiving the packet is all we need
 73021:         // to do for the pong to trigger the activity timers
 73020:         LOG(("WebSocketChannel:: pong received\n"));
 74912:       } else {
 74912:         /* unknown control frame opcode */
 74912:         LOG(("WebSocketChannel:: unknown control op code %d\n", opcode));
 74912:         return NS_ERROR_ILLEGAL_VALUE;
 70220:       }
 70220: 
 70220:       if (mFragmentAccumulator) {
 73021:         // Remove the control frame from the stream so we have a contiguous
 73021:         // data buffer of reassembled fragments
 73020:         LOG(("WebSocketChannel:: Removing Control From Read buffer\n"));
 70220:         NS_ABORT_IF_FALSE(mFramePtr + framingLength == payload,
 70220:                           "payload offset from frameptr wrong");
 73021:         ::memmove(mFramePtr, payload + payloadLength, avail - payloadLength);
 70220:         payload = mFramePtr;
 70220:         avail -= payloadLength;
 70220:         if (mBuffered)
 70220:           mBuffered -= framingLength + payloadLength;
 74911:         payloadLength = 0;
 70220:       }
 73021:     } else if (opcode == kBinary) {
 73020:       LOG(("WebSocketChannel:: binary frame received\n"));
 70220:       if (mListener) {
 72179:         nsCString binaryData((const char *)payload, payloadLength);
 80658:         NS_DispatchToMainThread(new CallOnMessageAvailable(this, binaryData,
 73021:                                                            payloadLength));
 70220:       }
 73021:     } else if (opcode != kContinuation) {
 70220:       /* unknown opcode */
 73020:       LOG(("WebSocketChannel:: unknown op code %d\n", opcode));
 70220:       return NS_ERROR_ILLEGAL_VALUE;
 70220:     }
 70220: 
 70220:     mFramePtr = payload + payloadLength;
 70220:     avail -= payloadLength;
 70220:     totalAvail = avail;
 70220:   }
 70220: 
 70220:   // Adjust the stateful buffer. If we were operating off the stack and
 70220:   // now have a partial message then transition to the buffer, or if
 70220:   // we were working off the buffer but no longer have any active state
 70220:   // then transition to the stack
 70220:   if (!IsPersistentFramePtr()) {
 70220:     mBuffered = 0;
 70220: 
 70220:     if (mFragmentAccumulator) {
 73020:       LOG(("WebSocketChannel:: Setup Buffer due to fragment"));
 70220: 
 85010:       if (!UpdateReadBuffer(mFramePtr - mFragmentAccumulator,
106838:                             totalAvail + mFragmentAccumulator, 0, nullptr)) {
 95225:         return NS_ERROR_FILE_TOO_BIG;
 85010:       }
 70220: 
 70220:       // UpdateReadBuffer will reset the frameptr to the beginning
 70220:       // of new saved state, so we need to skip past processed framgents
 70220:       mFramePtr += mFragmentAccumulator;
 73021:     } else if (totalAvail) {
 73020:       LOG(("WebSocketChannel:: Setup Buffer due to partial frame"));
106838:       if (!UpdateReadBuffer(mFramePtr, totalAvail, 0, nullptr)) {
 95225:         return NS_ERROR_FILE_TOO_BIG;
 85010:       }
 70220:     }
 73021:   } else if (!mFragmentAccumulator && !totalAvail) {
 73021:     // If we were working off a saved buffer state and there is no partial
 73021:     // frame or fragment in process, then revert to stack behavior
 73020:     LOG(("WebSocketChannel:: Internal buffering not needed anymore"));
 70220:     mBuffered = 0;
 85010: 
 85010:     // release memory if we've been processing a large message
 85010:     if (mBufferSize > kIncomingBufferStableSize) {
 85010:       mBufferSize = kIncomingBufferStableSize;
 85010:       moz_free(mBuffer);
108991:       mBuffer = (uint8_t *)moz_xmalloc(mBufferSize);
 85010:     }
 70220:   }
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: void
108991: WebSocketChannel::ApplyMask(uint32_t mask, uint8_t *data, uint64_t len)
 70220: {
 84709:   if (!data || len == 0)
 84709:     return;
 84709: 
 70220:   // Optimally we want to apply the mask 32 bits at a time,
 70220:   // but the buffer might not be alligned. So we first deal with
 70220:   // 0 to 3 bytes of preamble individually
 70220: 
113996:   while (len && (reinterpret_cast<uintptr_t>(data) & 3)) {
 70220:     *data ^= mask >> 24;
 70220:     mask = PR_ROTATE_LEFT32(mask, 8);
 70220:     data++;
 70220:     len--;
 70220:   }
 70220: 
 70220:   // perform mask on full words of data
 70220: 
108991:   uint32_t *iData = (uint32_t *) data;
108991:   uint32_t *end = iData + (len / 4);
 70220:   mask = PR_htonl(mask);
 70220:   for (; iData < end; iData++)
 70220:     *iData ^= mask;
 70220:   mask = PR_ntohl(mask);
108991:   data = (uint8_t *)iData;
 70220:   len  = len % 4;
 70220: 
 70220:   // There maybe up to 3 trailing bytes that need to be dealt with
 70220:   // individually 
 70220: 
 70220:   while (len) {
 70220:     *data ^= mask >> 24;
 70220:     mask = PR_ROTATE_LEFT32(mask, 8);
 70220:     data++;
 70220:     len--;
 70220:   }
 70220: }
 70220: 
 70220: void
 73020: WebSocketChannel::GeneratePing()
 70220: {
 70220:   nsCString *buf = new nsCString();
 70220:   buf->Assign("PING");
 84709:   EnqueueOutgoingMessage(mOutgoingPingMessages,
 84709:                          new OutboundMessage(kMsgTypePing, buf));
 70220: }
 70220: 
 70220: void
108991: WebSocketChannel::GeneratePong(uint8_t *payload, uint32_t len)
 70220: {
 70220:   nsCString *buf = new nsCString();
 70220:   buf->SetLength(len);
 70220:   if (buf->Length() < len) {
 73020:     LOG(("WebSocketChannel::GeneratePong Allocation Failure\n"));
 70220:     delete buf;
 70220:     return;
 70220:   }
 70220: 
 70220:   memcpy(buf->BeginWriting(), payload, len);
 84709:   EnqueueOutgoingMessage(mOutgoingPongMessages,
 84709:                          new OutboundMessage(kMsgTypePong, buf));
 84709: }
 84709: 
 84709: void
 84709: WebSocketChannel::EnqueueOutgoingMessage(nsDeque &aQueue,
 84709:                                          OutboundMessage *aMsg)
 84709: {
 84709:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
 84709: 
 84709:   LOG(("WebSocketChannel::EnqueueOutgoingMessage %p "
 84709:        "queueing msg %p [type=%s len=%d]\n",
 84709:        this, aMsg, msgNames[aMsg->GetMsgType()], aMsg->Length()));
 84709: 
 84709:   aQueue.Push(aMsg);
 70220:   OnOutputStreamReady(mSocketOut);
 70220: }
 70220: 
 70220: 
108991: uint16_t
 73020: WebSocketChannel::ResultToCloseCode(nsresult resultCode)
 72180: {
 72180:   if (NS_SUCCEEDED(resultCode))
 74812:     return CLOSE_NORMAL;
 95225: 
 95225:   switch (resultCode) {
 95225:     case NS_ERROR_FILE_TOO_BIG:
 95225:     case NS_ERROR_OUT_OF_MEMORY:
 74812:       return CLOSE_TOO_LARGE;
 95225:     case NS_ERROR_CANNOT_CONVERT_DATA:
 95225:       return CLOSE_INVALID_PAYLOAD;
 95225:     case NS_ERROR_UNEXPECTED:
 95225:       return CLOSE_INTERNAL_ERROR;
 95225:     default:
 95225:       return CLOSE_PROTOCOL_ERROR;
 73021:   }
 72180: }
 72180: 
 70220: void
 73020: WebSocketChannel::PrimeNewOutgoingMessage()
 70220: {
 73020:   LOG(("WebSocketChannel::PrimeNewOutgoingMessage() %p\n", this));
 73021:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
 70220:   NS_ABORT_IF_FALSE(!mCurrentOut, "Current message in progress");
 70220: 
 84709:   nsresult rv = NS_OK;
 70220: 
 70220:   mCurrentOut = (OutboundMessage *)mOutgoingPongMessages.PopFront();
 70220:   if (mCurrentOut) {
 84709:     NS_ABORT_IF_FALSE(mCurrentOut->GetMsgType() == kMsgTypePong,
 84709:                      "Not pong message!");
 70220:   } else {
 70220:     mCurrentOut = (OutboundMessage *)mOutgoingPingMessages.PopFront();
 70220:     if (mCurrentOut)
 84709:       NS_ABORT_IF_FALSE(mCurrentOut->GetMsgType() == kMsgTypePing,
 84709:                         "Not ping message!");
 70220:     else
 70220:       mCurrentOut = (OutboundMessage *)mOutgoingMessages.PopFront();
 70220:   }
 70220: 
 70220:   if (!mCurrentOut)
 70220:     return;
 84709: 
 84709:   WsMsgType msgType = mCurrentOut->GetMsgType();
 84709: 
 84709:   LOG(("WebSocketChannel::PrimeNewOutgoingMessage "
 84709:        "%p found queued msg %p [type=%s len=%d]\n",
 84709:        this, mCurrentOut, msgNames[msgType], mCurrentOut->Length()));
 84709: 
 70220:   mCurrentOutSent = 0;
 70220:   mHdrOut = mOutHeader;
 70220: 
108991:   uint8_t *payload = nullptr;
 84709: 
 84709:   if (msgType == kMsgTypeFin) {
 70220:     // This is a demand to create a close message
 70220:     if (mClientClosed) {
 89215:       DeleteCurrentOutGoingMessage();
 70220:       PrimeNewOutgoingMessage();
 70220:       return;
 70220:     }
 70220: 
 70220:     mClientClosed = 1;
 70220:     mOutHeader[0] = kFinalFragBit | kClose;
 98749:     mOutHeader[1] = kMaskBit;
 70220: 
 70220:     // payload is offset 6 including 4 for the mask
 70220:     payload = mOutHeader + 6;
 70220: 
 70220:     // The close reason code sits in the first 2 bytes of payload
 74812:     // If the channel user provided a code and reason during Close()
 74812:     // and there isn't an internal error, use that.
 98749:     if (NS_SUCCEEDED(mStopOnClose)) {
 98749:       if (mScriptCloseCode) {
108991:         *((uint16_t *)payload) = PR_htons(mScriptCloseCode);
 98749:         mOutHeader[1] += 2;
 98749:         mHdrOutToSend = 8;
 74812:         if (!mScriptCloseReason.IsEmpty()) {
 74812:           NS_ABORT_IF_FALSE(mScriptCloseReason.Length() <= 123,
 74812:                             "Close Reason Too Long");
 74812:           mOutHeader[1] += mScriptCloseReason.Length();
 74812:           mHdrOutToSend += mScriptCloseReason.Length();
 74812:           memcpy (payload + 2,
 74812:                   mScriptCloseReason.BeginReading(),
 74812:                   mScriptCloseReason.Length());
 74812:         }
 74993:       } else {
 98749:         // No close code/reason, so payload length = 0.  We must still send mask
 98749:         // even though it's not used.  Keep payload offset so we write mask
 98749:         // below.
 98749:         mHdrOutToSend = 6;
 98749:       }
 98749:     } else {
108991:       *((uint16_t *)payload) = PR_htons(ResultToCloseCode(mStopOnClose));
 98749:       mOutHeader[1] += 2;
 98749:       mHdrOutToSend = 8;
 74812:     }
 74812: 
 70220:     if (mServerClosed) {
 70220:       /* bidi close complete */
 70220:       mReleaseOnTransmit = 1;
 73021:     } else if (NS_FAILED(mStopOnClose)) {
 70220:       /* result of abort session - give up */
 70220:       StopSession(mStopOnClose);
 73021:     } else {
 70220:       /* wait for reciprocal close from server */
 70220:       mCloseTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
 70220:       if (NS_SUCCEEDED(rv)) {
 70220:         mCloseTimer->InitWithCallback(this, mCloseTimeout,
 70220:                                       nsITimer::TYPE_ONE_SHOT);
 73021:       } else {
 70220:         StopSession(rv);
 70220:       }
 70220:     }
 73021:   } else {
 84709:     switch (msgType) {
 84709:     case kMsgTypePong:
 73021:       mOutHeader[0] = kFinalFragBit | kPong;
 84709:       break;
 84709:     case kMsgTypePing:
 73021:       mOutHeader[0] = kFinalFragBit | kPing;
 84709:       break;
 84709:     case kMsgTypeString:
 73021:       mOutHeader[0] = kFinalFragBit | kText;
 84709:       break;
 84709:     case kMsgTypeStream:
 84709:       // HACK ALERT:  read in entire stream into string.
 84709:       // Will block socket transport thread if file is blocking.
 84709:       // TODO: bug 704447:  don't block socket thread!
 84709:       rv = mCurrentOut->ConvertStreamToString();
 84709:       if (NS_FAILED(rv)) {
 95225:         AbortSession(NS_ERROR_FILE_TOO_BIG);
 84709:         return;
 84709:       }
 84709:       // Now we're a binary string
 84709:       msgType = kMsgTypeBinaryString;
 84709: 
 84709:       // no break: fall down into binary string case
 84709: 
 84709:     case kMsgTypeBinaryString:
 70220:       mOutHeader[0] = kFinalFragBit | kBinary;
 84709:       break;
 84709:     case kMsgTypeFin:
 84709:       NS_ABORT_IF_FALSE(false, "unreachable");  // avoid compiler warning
 84709:       break;
 70220:     }
 70220: 
 70220:     if (mCurrentOut->Length() < 126) {
 70220:       mOutHeader[1] = mCurrentOut->Length() | kMaskBit;
 70220:       mHdrOutToSend = 6;
 79358:     } else if (mCurrentOut->Length() <= 0xffff) {
 70220:       mOutHeader[1] = 126 | kMaskBit;
108991:       ((uint16_t *)mOutHeader)[1] =
 70220:         PR_htons(mCurrentOut->Length());
 70220:       mHdrOutToSend = 8;
 73021:     } else {
 70220:       mOutHeader[1] = 127 | kMaskBit;
108991:       uint64_t tempLen = mCurrentOut->Length();
 70220:       tempLen = PR_htonll(tempLen);
 70220:       memcpy(mOutHeader + 2, &tempLen, 8);
 70220:       mHdrOutToSend = 14;
 70220:     }
 70220:     payload = mOutHeader + mHdrOutToSend;
 70220:   }
 70220: 
 70220:   NS_ABORT_IF_FALSE(payload, "payload offset not found");
 70220: 
 84709:   // Perform the sending mask. Never use a zero mask
108991:   uint32_t mask;
 71216:   do {
108991:     uint8_t *buffer;
 71216:     nsresult rv = mRandomGenerator->GenerateRandomBytes(4, &buffer);
 71216:     if (NS_FAILED(rv)) {
 73021:       LOG(("WebSocketChannel::PrimeNewOutgoingMessage(): "
 71216:            "GenerateRandomBytes failure %x\n", rv));
 71216:       StopSession(rv);
 71216:       return;
 71216:     }
108991:     mask = * reinterpret_cast<uint32_t *>(buffer);
 71216:     NS_Free(buffer);
 71216:   } while (!mask);
108991:   *(((uint32_t *)payload) - 1) = PR_htonl(mask);
 70220: 
 73021:   LOG(("WebSocketChannel::PrimeNewOutgoingMessage() using mask %08x\n", mask));
 70220: 
 70220:   // We don't mask the framing, but occasionally we stick a little payload
 73021:   // data in the buffer used for the framing. Close frames are the current
 73021:   // example. This data needs to be masked, but it is never more than a
 73021:   // handful of bytes and might rotate the mask, so we can just do it locally.
 73021:   // For real data frames we ship the bulk of the payload off to ApplyMask()
 70220: 
 70220:   while (payload < (mOutHeader + mHdrOutToSend)) {
 70220:     *payload ^= mask >> 24;
 70220:     mask = PR_ROTATE_LEFT32(mask, 8);
 70220:     payload++;
 70220:   }
 70220: 
 70220:   // Mask the real message payloads
 70220: 
 73021:   ApplyMask(mask, mCurrentOut->BeginWriting(), mCurrentOut->Length());
 70220: 
108991:   int32_t len = mCurrentOut->Length();
 98749: 
 70220:   // for small frames, copy it all together for a contiguous write
 98749:   if (len && len <= kCopyBreak) {
 98749:     memcpy(mOutHeader + mHdrOutToSend, mCurrentOut->BeginWriting(), len);
 98749:     mHdrOutToSend += len;
 98749:     mCurrentOutSent = len;
 70220:   }
 70220: 
 98749:   if (len && mCompressor) {
 70220:     // assume a 1/3 reduction in size for sizing the buffer
 70220:     // the buffer is used multiple times if necessary
108991:     uint32_t currentHeaderSize = mHdrOutToSend;
 70220:     mHdrOutToSend = 0;
 70220: 
 98749:     EnsureHdrOut(32 + (currentHeaderSize + len - mCurrentOutSent) / 2 * 3);
 73021:     mCompressor->Deflate(mOutHeader, currentHeaderSize,
 70220:                          mCurrentOut->BeginReading() + mCurrentOutSent,
 98749:                          len - mCurrentOutSent);
 70220: 
 73021:     // All of the compressed data now resides in {mHdrOut, mHdrOutToSend}
 70220:     // so do not send the body again
 98749:     mCurrentOutSent = len;
 70220:   }
 70220: 
 73021:   // Transmitting begins - mHdrOutToSend bytes from mOutHeader and
 73021:   // mCurrentOut->Length() bytes from mCurrentOut. The latter may be
 73021:   // coaleseced into the former for small messages or as the result of the
 73021:   // compression process,
 70220: }
 70220: 
 70220: void
 89215: WebSocketChannel::DeleteCurrentOutGoingMessage()
 89215: {
 89215:   delete mCurrentOut;
106838:   mCurrentOut = nullptr;
 89215:   mCurrentOutSent = 0;
 89215: }
 89215: 
 89215: void
108991: WebSocketChannel::EnsureHdrOut(uint32_t size)
 70220: {
 73020:   LOG(("WebSocketChannel::EnsureHdrOut() %p [%d]\n", this, size));
 70220: 
 70220:   if (mDynamicOutputSize < size) {
 70220:     mDynamicOutputSize = size;
 70220:     mDynamicOutput =
108991:       (uint8_t *) moz_xrealloc(mDynamicOutput, mDynamicOutputSize);
 70220:   }
 70220: 
 70220:   mHdrOut = mDynamicOutput;
 70220: }
 70220: 
 70220: void
 73020: WebSocketChannel::CleanupConnection()
 72181: {
 73020:   LOG(("WebSocketChannel::CleanupConnection() %p", this));
 72181: 
 72181:   if (mLingeringCloseTimer) {
 72181:     mLingeringCloseTimer->Cancel();
106838:     mLingeringCloseTimer = nullptr;
 72181:   }
 72181: 
 72181:   if (mSocketIn) {
106838:     mSocketIn->AsyncWait(nullptr, 0, 0, nullptr);
106838:     mSocketIn = nullptr;
 72181:   }
 72181: 
 72181:   if (mSocketOut) {
106838:     mSocketOut->AsyncWait(nullptr, 0, 0, nullptr);
106838:     mSocketOut = nullptr;
 72181:   }
 72181: 
 72181:   if (mTransport) {
106838:     mTransport->SetSecurityCallbacks(nullptr);
106838:     mTransport->SetEventSink(nullptr, nullptr);
 72181:     mTransport->Close(NS_BASE_STREAM_CLOSED);
106838:     mTransport = nullptr;
 72181:   }
 99957: 
 99957:   DecrementSessionCount();
 72181: }
 72181: 
 72181: void
 73020: WebSocketChannel::StopSession(nsresult reason)
 70220: {
 73020:   LOG(("WebSocketChannel::StopSession() %p [%x]\n", this, reason));
 70220: 
 70220:   // normally this should be called on socket thread, but it is ok to call it
 70220:   // from OnStartRequest before the socket thread machine has gotten underway
 70220: 
 95225:   mStopped = 1;
 70220: 
104079:   if (!mOpenedHttpChannel) {
 74992:     // The HTTP channel information will never be used in this case
106838:     mChannel = nullptr;
106838:     mHttpChannel = nullptr;
106838:     mLoadGroup = nullptr;
106838:     mCallbacks = nullptr;
 74992:   }
 74992: 
 70220:   if (mCloseTimer) {
 70220:     mCloseTimer->Cancel();
106838:     mCloseTimer = nullptr;
 70220:   }
 70220: 
 70220:   if (mOpenTimer) {
 70220:     mOpenTimer->Cancel();
106838:     mOpenTimer = nullptr;
 70220:   }
 70220: 
103141:   if (mReconnectDelayTimer) {
103141:     mReconnectDelayTimer->Cancel();
106838:     mReconnectDelayTimer = nullptr;
103141:   }
103141: 
 70220:   if (mPingTimer) {
 70220:     mPingTimer->Cancel();
106838:     mPingTimer = nullptr;
 70220:   }
 70220: 
 72181:   if (mSocketIn && !mTCPClosed) {
 73021:     // Drain, within reason, this socket. if we leave any data
 70220:     // unconsumed (including the tcp fin) a RST will be generated
 70220:     // The right thing to do here is shutdown(SHUT_WR) and then wait
 70220:     // a little while to see if any data comes in.. but there is no
 70220:     // reason to delay things for that when the websocket handshake
 70220:     // is supposed to guarantee a quiet connection except for that fin.
 70220: 
 70220:     char     buffer[512];
108991:     uint32_t count = 0;
108991:     uint32_t total = 0;
 70220:     nsresult rv;
 70220:     do {
 70220:       total += count;
 70220:       rv = mSocketIn->Read(buffer, 512, &count);
 72181:       if (rv != NS_BASE_STREAM_WOULD_BLOCK &&
 72181:         (NS_FAILED(rv) || count == 0))
 80486:         mTCPClosed = true;
 70220:     } while (NS_SUCCEEDED(rv) && count > 0 && total < 32000);
 70220:   }
 70220: 
 72181:   if (!mTCPClosed && mTransport && sWebSocketAdmissions &&
 86784:       sWebSocketAdmissions->SessionCount() < kLingeringCloseThreshold) {
 72181: 
 73021:     // 7.1.1 says that the client SHOULD wait for the server to close the TCP
 73021:     // connection. This is so we can reuse port numbers before 2 MSL expires,
 73021:     // which is not really as much of a concern for us as the amount of state
 73021:     // that might be accrued by keeping this channel object around waiting for
 73021:     // the server. We handle the SHOULD by waiting a short time in the common
 73021:     // case, but not waiting in the case of high concurrency.
 72181:     //
 72181:     // Normally this will be taken care of in AbortSession() after mTCPClosed
 72181:     // is set when the server close arrives without waiting for the timeout to
 72181:     // expire.
 72181: 
 73021:     LOG(("WebSocketChannel::StopSession: Wait for Server TCP close"));
 72181: 
 72181:     nsresult rv;
 72181:     mLingeringCloseTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
 72181:     if (NS_SUCCEEDED(rv))
 72181:       mLingeringCloseTimer->InitWithCallback(this, kLingeringCloseTimeout,
 72181:                                              nsITimer::TYPE_ONE_SHOT);
 72181:     else
 72181:       CleanupConnection();
 73021:   } else {
 72181:     CleanupConnection();
 70220:   }
 70220: 
 70220:   if (mDNSRequest) {
 70220:     mDNSRequest->Cancel(NS_ERROR_UNEXPECTED);
106838:     mDNSRequest = nullptr;
 70220:   }
 70220: 
106838:   mInflateReader = nullptr;
106838:   mInflateStream = nullptr;
 70220: 
 70220:   delete mCompressor;
106838:   mCompressor = nullptr;
 70220: 
 70220:   if (!mCalledOnStop) {
 70220:     mCalledOnStop = 1;
 80658:     NS_DispatchToMainThread(new CallOnStop(this, reason));
 71740:   }
 70220: 
 70220:   return;
 70220: }
 70220: 
 70220: void
 73020: WebSocketChannel::AbortSession(nsresult reason)
 70220: {
 73020:   LOG(("WebSocketChannel::AbortSession() %p [reason %x] stopped = %d\n",
 70220:        this, reason, mStopped));
 70220: 
 70220:   // normally this should be called on socket thread, but it is ok to call it
 72502:   // from the main thread before StartWebsocketData() has completed
 70220: 
 72181:   // When we are failing we need to close the TCP connection immediately
 72181:   // as per 7.1.1
 80486:   mTCPClosed = true;
 72181: 
 72181:   if (mLingeringCloseTimer) {
 72181:     NS_ABORT_IF_FALSE(mStopped, "Lingering without Stop");
 73021:     LOG(("WebSocketChannel:: Cleanup connection based on TCP Close"));
 72181:     CleanupConnection();
 72181:     return;
 72181:   }
 72181: 
 70220:   if (mStopped)
 70220:     return;
 70220:   mStopped = 1;
 70220: 
 70220:   if (mTransport && reason != NS_BASE_STREAM_CLOSED &&
 70220:       !mRequestedClose && !mClientClosed && !mServerClosed) {
 70220:     mRequestedClose = 1;
 86783:     mStopOnClose = reason;
 84709:     mSocketThread->Dispatch(
106838:       new OutboundEnqueuer(this, new OutboundMessage(kMsgTypeFin, nullptr)),
 73021:                            nsIEventTarget::DISPATCH_NORMAL);
 73021:   } else {
 70220:     StopSession(reason);
 70220:   }
 70220: }
 70220: 
 70220: // ReleaseSession is called on orderly shutdown
 70220: void
 73020: WebSocketChannel::ReleaseSession()
 70220: {
 73020:   LOG(("WebSocketChannel::ReleaseSession() %p stopped = %d\n",
 70220:        this, mStopped));
 73021:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
 70220: 
 70220:   if (mStopped)
 70220:     return;
 70220:   StopSession(NS_OK);
 70220: }
 70220: 
 99957: void
 99957: WebSocketChannel::IncrementSessionCount()
 99957: {
 99957:   if (!mIncrementedSessionCount) {
 99957:     sWebSocketAdmissions->IncrementSessionCount();
 99957:     mIncrementedSessionCount = 1;
 99957:   }
 99957: }
 99957: 
 99957: void
 99957: WebSocketChannel::DecrementSessionCount()
 99957: {
 99957:   // Make sure we decrement session count only once, and only if we incremented it.
 99957:   // This code is thread-safe: sWebSocketAdmissions->DecrementSessionCount is
 99957:   // atomic, and mIncrementedSessionCount/mDecrementedSessionCount are set at
 99957:   // times when they'll never be a race condition for checking/setting them.
 99957:   if (mIncrementedSessionCount && !mDecrementedSessionCount) {
 99957:     sWebSocketAdmissions->DecrementSessionCount();
 99957:     mDecrementedSessionCount = 1;
 99957:   }
 99957: }
 99957: 
 70220: nsresult
 73020: WebSocketChannel::HandleExtensions()
 70220: {
 73020:   LOG(("WebSocketChannel::HandleExtensions() %p\n", this));
 70220: 
 70220:   nsresult rv;
110974:   nsAutoCString extensions;
 70220: 
 70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 70220: 
 70220:   rv = mHttpChannel->GetResponseHeader(
 70220:     NS_LITERAL_CSTRING("Sec-WebSocket-Extensions"), extensions);
 70220:   if (NS_SUCCEEDED(rv)) {
 70220:     if (!extensions.IsEmpty()) {
 70220:       if (!extensions.Equals(NS_LITERAL_CSTRING("deflate-stream"))) {
 73021:         LOG(("WebSocketChannel::OnStartRequest: "
 73021:              "HTTP Sec-WebSocket-Exensions negotiated unknown value %s\n",
 70220:              extensions.get()));
 70220:         AbortSession(NS_ERROR_ILLEGAL_VALUE);
 70220:         return NS_ERROR_ILLEGAL_VALUE;
 70220:       }
 70220: 
 70220:       if (!mAllowCompression) {
 73021:         LOG(("WebSocketChannel::HandleExtensions: "
 70220:              "Recvd Compression Extension that wasn't offered\n"));
 70220:         AbortSession(NS_ERROR_ILLEGAL_VALUE);
 70220:         return NS_ERROR_ILLEGAL_VALUE;
 70220:       }
 70220: 
 70220:       nsCOMPtr<nsIStreamConverterService> serv =
 70220:         do_GetService(NS_STREAMCONVERTERSERVICE_CONTRACTID, &rv);
 70220:       if (NS_FAILED(rv)) {
 73020:         LOG(("WebSocketChannel:: Cannot find compression service\n"));
 70220:         AbortSession(NS_ERROR_UNEXPECTED);
 70220:         return NS_ERROR_UNEXPECTED;
 70220:       }
 70220: 
106838:       rv = serv->AsyncConvertData("deflate", "uncompressed", this, nullptr,
 70220:                                   getter_AddRefs(mInflateReader));
 70220: 
 70220:       if (NS_FAILED(rv)) {
 73020:         LOG(("WebSocketChannel:: Cannot find inflate listener\n"));
 70220:         AbortSession(NS_ERROR_UNEXPECTED);
 70220:         return NS_ERROR_UNEXPECTED;
 70220:       }
 70220: 
 73021:       mInflateStream = do_CreateInstance(NS_STRINGINPUTSTREAM_CONTRACTID, &rv);
 70220: 
 70220:       if (NS_FAILED(rv)) {
 73020:         LOG(("WebSocketChannel:: Cannot find inflate stream\n"));
 70220:         AbortSession(NS_ERROR_UNEXPECTED);
 70220:         return NS_ERROR_UNEXPECTED;
 70220:       }
 70220: 
 70220:       mCompressor = new nsWSCompression(this, mSocketOut);
 70220:       if (!mCompressor->Active()) {
 73020:         LOG(("WebSocketChannel:: Cannot init deflate object\n"));
 70220:         delete mCompressor;
106838:         mCompressor = nullptr;
 70220:         AbortSession(NS_ERROR_UNEXPECTED);
 70220:         return NS_ERROR_UNEXPECTED;
 70220:       }
 74838:       mNegotiatedExtensions = extensions;
 70220:     }
 70220:   }
 70220: 
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: nsresult
 73020: WebSocketChannel::SetupRequest()
 70220: {
 73020:   LOG(("WebSocketChannel::SetupRequest() %p\n", this));
 70220: 
 70220:   nsresult rv;
 70220: 
 70220:   if (mLoadGroup) {
 70220:     rv = mHttpChannel->SetLoadGroup(mLoadGroup);
 70220:     NS_ENSURE_SUCCESS(rv, rv);
 70220:   }
 70220: 
 70220:   rv = mHttpChannel->SetLoadFlags(nsIRequest::LOAD_BACKGROUND |
 70220:                                   nsIRequest::INHIBIT_CACHING |
 70220:                                   nsIRequest::LOAD_BYPASS_CACHE);
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 70220: 
 70220:   // draft-ietf-hybi-thewebsocketprotocol-07 illustrates Upgrade: websocket
 73021:   // in lower case, so go with that. It is technically case insensitive.
 70220:   rv = mChannel->HTTPUpgrade(NS_LITERAL_CSTRING("websocket"), this);
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 70220: 
 70220:   mHttpChannel->SetRequestHeader(
 70220:     NS_LITERAL_CSTRING("Sec-WebSocket-Version"),
 80486:     NS_LITERAL_CSTRING(SEC_WEBSOCKET_VERSION), false);
 70220: 
 70220:   if (!mOrigin.IsEmpty())
 85007:     mHttpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Origin"), mOrigin,
 85007:                                    false);
 70220: 
 70220:   if (!mProtocol.IsEmpty())
 73021:     mHttpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Sec-WebSocket-Protocol"),
 80486:                                    mProtocol, true);
 70220: 
 70220:   if (mAllowCompression)
 73021:     mHttpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Sec-WebSocket-Extensions"),
 73021:                                    NS_LITERAL_CSTRING("deflate-stream"),
 80486:                                    false);
 70220: 
108991:   uint8_t      *secKey;
110974:   nsAutoCString secKeyString;
 71216: 
 71216:   rv = mRandomGenerator->GenerateRandomBytes(16, &secKey);
 71216:   NS_ENSURE_SUCCESS(rv, rv);
106838:   char* b64 = PL_Base64Encode((const char *)secKey, 16, nullptr);
 71216:   NS_Free(secKey);
 73021:   if (!b64)
 73021:     return NS_ERROR_OUT_OF_MEMORY;
 70220:   secKeyString.Assign(b64);
 70220:   PR_Free(b64);
 73021:   mHttpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Sec-WebSocket-Key"),
 80486:                                  secKeyString, false);
 74745:   LOG(("WebSocketChannel::SetupRequest: client key %s\n", secKeyString.get()));
 70220: 
 70220:   // prepare the value we expect to see in
 70220:   // the sec-websocket-accept response header
 70220:   secKeyString.AppendLiteral("258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
 70220:   nsCOMPtr<nsICryptoHash> hasher =
 70220:     do_CreateInstance(NS_CRYPTO_HASH_CONTRACTID, &rv);
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 70220:   rv = hasher->Init(nsICryptoHash::SHA1);
 70220:   NS_ENSURE_SUCCESS(rv, rv);
108991:   rv = hasher->Update((const uint8_t *) secKeyString.BeginWriting(),
 70220:                       secKeyString.Length());
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 80486:   rv = hasher->Finish(true, mHashedSecret);
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 74745:   LOG(("WebSocketChannel::SetupRequest: expected server key %s\n",
 70220:        mHashedSecret.get()));
 70220: 
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: nsresult
 73020: WebSocketChannel::ApplyForAdmission()
 70220: {
 73020:   LOG(("WebSocketChannel::ApplyForAdmission() %p\n", this));
 70220: 
 70220:   // Websockets has a policy of 1 session at a time being allowed in the
 70220:   // CONNECTING state per server IP address (not hostname)
 70220: 
 70220:   nsresult rv;
 70220:   nsCOMPtr<nsIDNSService> dns = do_GetService(NS_DNSSERVICE_CONTRACTID, &rv);
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 70220: 
 70220:   nsCString hostName;
 70220:   rv = mURI->GetHost(hostName);
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 70220:   mAddress = hostName;
103141:   rv = mURI->GetPort(&mPort);
103141:   NS_ENSURE_SUCCESS(rv, rv);
103141:   if (mPort == -1)
103141:     mPort = (mEncrypted ? kDefaultWSSPort : kDefaultWSPort);
 70220: 
 70220:   // expect the callback in ::OnLookupComplete
 74745:   LOG(("WebSocketChannel::ApplyForAdmission: checking for concurrent open\n"));
 70220:   nsCOMPtr<nsIThread> mainThread;
 70220:   NS_GetMainThread(getter_AddRefs(mainThread));
 73021:   dns->AsyncResolve(hostName, 0, this, mainThread, getter_AddRefs(mDNSRequest));
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 70220: 
 70220:   return NS_OK;
 70220: }
 70220: 
 72502: // Called after both OnStartRequest and OnTransportAvailable have
 72502: // executed. This essentially ends the handshake and starts the websockets
 72502: // protocol state machine.
 72502: nsresult
 73020: WebSocketChannel::StartWebsocketData()
 72502: {
 73020:   LOG(("WebSocketChannel::StartWebsocketData() %p", this));
 96974:   NS_ABORT_IF_FALSE(!mDataStarted, "StartWebsocketData twice");
 96974:   mDataStarted = 1;
 96974: 
103141:   // We're now done CONNECTING, which means we can now open another,
103141:   // perhaps parallel, connection to the same host if one
103141:   // is pending
103141:   sWebSocketAdmissions->OnConnected(this);
103141: 
 96974:   LOG(("WebSocketChannel::StartWebsocketData Notifying Listener %p\n",
 96974:        mListener.get()));
 96974: 
 96974:   if (mListener)
 96974:     mListener->OnStart(mContext);
 72502: 
 72502:   return mSocketIn->AsyncWait(this, 0, 0, mSocketThread);
 72502: }
 72502: 
 70220: // nsIDNSListener
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::OnLookupComplete(nsICancelable *aRequest,
 70220:                                      nsIDNSRecord *aRecord,
 70220:                                      nsresult aStatus)
 70220: {
 73020:   LOG(("WebSocketChannel::OnLookupComplete() %p [%p %p %x]\n",
 70220:        this, aRequest, aRecord, aStatus));
 70220: 
 70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 74992:   NS_ABORT_IF_FALSE(aRequest == mDNSRequest || mStopped,
 74992:                     "wrong dns request");
 74992: 
 86784:   if (mStopped) {
 86784:     LOG(("WebSocketChannel::OnLookupComplete: Request Already Stopped\n"));
 74992:     return NS_OK;
 86784:   }
 70220: 
106838:   mDNSRequest = nullptr;
 70220: 
 70220:   // These failures are not fatal - we just use the hostname as the key
 70220:   if (NS_FAILED(aStatus)) {
 73021:     LOG(("WebSocketChannel::OnLookupComplete: No DNS Response\n"));
 73021:   } else {
 70220:     nsresult rv = aRecord->GetNextAddrAsString(mAddress);
 70220:     if (NS_FAILED(rv))
 73021:       LOG(("WebSocketChannel::OnLookupComplete: Failed GetNextAddr\n"));
 70220:   }
 70220: 
104078:   LOG(("WebSocket OnLookupComplete: Proceeding to ConditionallyConnect\n"));
104078:   sWebSocketAdmissions->ConditionallyConnect(this);
 70220: 
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: // nsIInterfaceRequestor
 70220: 
 70220: NS_IMETHODIMP
106217: WebSocketChannel::GetInterface(const nsIID & iid, void **result)
 70220: {
 73020:   LOG(("WebSocketChannel::GetInterface() %p\n", this));
 70220: 
 70220:   if (iid.Equals(NS_GET_IID(nsIChannelEventSink)))
 70220:     return QueryInterface(iid, result);
 70220: 
 70220:   if (mCallbacks)
 70220:     return mCallbacks->GetInterface(iid, result);
 70220: 
 70220:   return NS_ERROR_FAILURE;
 70220: }
 70220: 
 70220: // nsIChannelEventSink
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::AsyncOnChannelRedirect(
 70220:                     nsIChannel *oldChannel,
 70220:                     nsIChannel *newChannel,
108991:                     uint32_t flags,
 70220:                     nsIAsyncVerifyRedirectCallback *callback)
 70220: {
 73020:   LOG(("WebSocketChannel::AsyncOnChannelRedirect() %p\n", this));
 70220:   nsresult rv;
 70220: 
 70220:   nsCOMPtr<nsIURI> newuri;
 70220:   rv = newChannel->GetURI(getter_AddRefs(newuri));
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 70220: 
 84711:   // newuri is expected to be http or https
 84711:   bool newuriIsHttps = false;
 84711:   rv = newuri->SchemeIs("https", &newuriIsHttps);
 84711:   NS_ENSURE_SUCCESS(rv, rv);
 84711: 
 70220:   if (!mAutoFollowRedirects) {
 84711:     // Even if redirects configured off, still allow them for HTTP Strict
 84711:     // Transport Security (from ws://FOO to https://FOO (mapped to wss://FOO)
 84711: 
 84711:     nsCOMPtr<nsIURI> clonedNewURI;
 84711:     rv = newuri->Clone(getter_AddRefs(clonedNewURI));
 84711:     NS_ENSURE_SUCCESS(rv, rv);
 84711: 
 84711:     rv = clonedNewURI->SetScheme(NS_LITERAL_CSTRING("ws"));
 84711:     NS_ENSURE_SUCCESS(rv, rv);
 84711: 
 84711:     nsCOMPtr<nsIURI> currentURI;
 84711:     rv = GetURI(getter_AddRefs(currentURI));
 84711:     NS_ENSURE_SUCCESS(rv, rv);
 84711: 
 84711:     // currentURI is expected to be ws or wss
 84711:     bool currentIsHttps = false;
 84711:     rv = currentURI->SchemeIs("wss", &currentIsHttps);
 84711:     NS_ENSURE_SUCCESS(rv, rv);
 84711: 
 84711:     bool uriEqual = false;
 84711:     rv = clonedNewURI->Equals(currentURI, &uriEqual);
 84711:     NS_ENSURE_SUCCESS(rv, rv);
 84711: 
 84711:     // It's only a HSTS redirect if we started with non-secure, are going to
 84711:     // secure, and the new URI is otherwise the same as the old one.
 84711:     if (!(!currentIsHttps && newuriIsHttps && uriEqual)) {
110974:       nsAutoCString newSpec;
 84711:       rv = newuri->GetSpec(newSpec);
 84711:       NS_ENSURE_SUCCESS(rv, rv);
 84711: 
 73021:       LOG(("WebSocketChannel: Redirect to %s denied by configuration\n",
 84711:            newSpec.get()));
 84711:       return NS_ERROR_FAILURE;
 70220:     }
 84711:   }
 84711: 
 84711:   if (mEncrypted && !newuriIsHttps) {
110974:     nsAutoCString spec;
 70220:     if (NS_SUCCEEDED(newuri->GetSpec(spec)))
 73021:       LOG(("WebSocketChannel: Redirect to %s violates encryption rule\n",
 70220:            spec.get()));
 84711:     return NS_ERROR_FAILURE;
 70220:   }
 70220: 
 73021:   nsCOMPtr<nsIHttpChannel> newHttpChannel = do_QueryInterface(newChannel, &rv);
 70220:   if (NS_FAILED(rv)) {
 73021:     LOG(("WebSocketChannel: Redirect could not QI to HTTP\n"));
 84711:     return rv;
 70220:   }
 70220: 
 70220:   nsCOMPtr<nsIHttpChannelInternal> newUpgradeChannel =
 70220:     do_QueryInterface(newChannel, &rv);
 70220: 
 70220:   if (NS_FAILED(rv)) {
 73021:     LOG(("WebSocketChannel: Redirect could not QI to HTTP Upgrade\n"));
 84711:     return rv;
 70220:   }
 70220: 
 71217:   // The redirect is likely OK
 70220: 
 70220:   newChannel->SetNotificationCallbacks(this);
 84711: 
 84711:   mEncrypted = newuriIsHttps;
 84711:   newuri->Clone(getter_AddRefs(mURI));
 84711:   if (mEncrypted)
 84711:     rv = mURI->SetScheme(NS_LITERAL_CSTRING("wss"));
 84711:   else
 84711:     rv = mURI->SetScheme(NS_LITERAL_CSTRING("ws"));
 84711: 
 70220:   mHttpChannel = newHttpChannel;
 70220:   mChannel = newUpgradeChannel;
 71217:   rv = SetupRequest();
 71217:   if (NS_FAILED(rv)) {
 73021:     LOG(("WebSocketChannel: Redirect could not SetupRequest()\n"));
 84711:     return rv;
 71217:   }
 70220: 
103141:   // Redirected-to URI may need to be delayed by 1-connecting-per-host and
103141:   // delay-after-fail algorithms.  So hold off calling OnRedirectVerifyCallback
103141:   // until BeginOpen, when we know it's OK to proceed with new channel.
103141:   mRedirectCallback = callback;
103141: 
103141:   // Mark old channel as successfully connected so we'll clear any FailDelay
103141:   // associated with the old URI.  Note: no need to also call OnStopSession:
103141:   // it's a no-op for successful, already-connected channels.
103141:   sWebSocketAdmissions->OnConnected(this);
103141: 
103141:   // ApplyForAdmission as if we were starting from fresh...
103196:   mAddress.Truncate();
104079:   mOpenedHttpChannel = 0;
 70220:   rv = ApplyForAdmission();
 70220:   if (NS_FAILED(rv)) {
 73021:     LOG(("WebSocketChannel: Redirect failed due to DNS failure\n"));
106838:     mRedirectCallback = nullptr;
 84711:     return rv;
 70220:   }
 70220: 
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: // nsITimerCallback
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::Notify(nsITimer *timer)
 70220: {
 73020:   LOG(("WebSocketChannel::Notify() %p [%p]\n", this, timer));
 70220: 
 70220:   if (timer == mCloseTimer) {
 70220:     NS_ABORT_IF_FALSE(mClientClosed, "Close Timeout without local close");
 70220:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread,
 70220:                       "not socket thread");
 70220: 
106838:     mCloseTimer = nullptr;
 70220:     if (mStopped || mServerClosed)                /* no longer relevant */
 70220:       return NS_OK;
 70220: 
 73020:     LOG(("WebSocketChannel:: Expecting Server Close - Timed Out\n"));
 70220:     AbortSession(NS_ERROR_NET_TIMEOUT);
 73021:   } else if (timer == mOpenTimer) {
 70220:     NS_ABORT_IF_FALSE(!mRecvdHttpOnStartRequest,
 70220:                       "Open Timer after open complete");
 70220:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 70220: 
106838:     mOpenTimer = nullptr;
 73020:     LOG(("WebSocketChannel:: Connection Timed Out\n"));
 70220:     if (mStopped || mServerClosed)                /* no longer relevant */
 70220:       return NS_OK;
 70220: 
 70220:     AbortSession(NS_ERROR_NET_TIMEOUT);
103141:   } else if (timer == mReconnectDelayTimer) {
103141:     NS_ABORT_IF_FALSE(mConnecting == CONNECTING_DELAYED,
103141:                       "woke up from delay w/o being delayed?");
103141: 
106838:     mReconnectDelayTimer = nullptr;
103141:     LOG(("WebSocketChannel: connecting [this=%p] after reconnect delay", this));
104078:     BeginOpen();
 73021:   } else if (timer == mPingTimer) {
 70220:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread,
 70220:                       "not socket thread");
 70220: 
 70220:     if (mClientClosed || mServerClosed || mRequestedClose) {
 70220:       // no point in worrying about ping now
106838:       mPingTimer = nullptr;
 70220:       return NS_OK;
 70220:     }
 70220: 
 70220:     if (!mPingOutstanding) {
 73021:       LOG(("nsWebSocketChannel:: Generating Ping\n"));
 70220:       mPingOutstanding = 1;
 70220:       GeneratePing();
 70220:       mPingTimer->InitWithCallback(this, mPingResponseTimeout,
 70220:                                    nsITimer::TYPE_ONE_SHOT);
 73021:     } else {
 73021:       LOG(("nsWebSocketChannel:: Timed out Ping\n"));
106838:       mPingTimer = nullptr;
 70220:       AbortSession(NS_ERROR_NET_TIMEOUT);
 70220:     }
 73021:   } else if (timer == mLingeringCloseTimer) {
 73020:     LOG(("WebSocketChannel:: Lingering Close Timer"));
 72181:     CleanupConnection();
 73021:   } else {
 70220:     NS_ABORT_IF_FALSE(0, "Unknown Timer");
 70220:   }
 70220: 
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::GetSecurityInfo(nsISupports **aSecurityInfo)
 70220: {
 73020:   LOG(("WebSocketChannel::GetSecurityInfo() %p\n", this));
 70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 70220: 
 70220:   if (mTransport) {
 70220:     if (NS_FAILED(mTransport->GetSecurityInfo(aSecurityInfo)))
106838:       *aSecurityInfo = nullptr;
 70220:   }
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::AsyncOpen(nsIURI *aURI,
 70220:                             const nsACString &aOrigin,
 70220:                             nsIWebSocketListener *aListener,
 70220:                             nsISupports *aContext)
 70220: {
 73020:   LOG(("WebSocketChannel::AsyncOpen() %p\n", this));
 70220: 
 70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 70220: 
 70220:   if (!aURI || !aListener) {
 73020:     LOG(("WebSocketChannel::AsyncOpen() Uri or Listener null"));
 70220:     return NS_ERROR_UNEXPECTED;
 70220:   }
 70220: 
104079:   if (mListener || mWasOpened)
 70220:     return NS_ERROR_ALREADY_OPENED;
 70220: 
 70220:   nsresult rv;
 70220: 
 70220:   mSocketThread = do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID, &rv);
 70220:   if (NS_FAILED(rv)) {
 70220:     NS_WARNING("unable to continue without socket transport service");
 70220:     return rv;
 70220:   }
 70220: 
 73021:   mRandomGenerator =
 73021:     do_GetService("@mozilla.org/security/random-generator;1", &rv);
 71216:   if (NS_FAILED(rv)) {
 71216:     NS_WARNING("unable to continue without random number generator");
 71216:     return rv;
 71216:   }
 71216: 
 70220:   nsCOMPtr<nsIPrefBranch> prefService;
 70220:   prefService = do_GetService(NS_PREFSERVICE_CONTRACTID);
 70220: 
 70220:   if (prefService) {
108991:     int32_t intpref;
 79445:     bool boolpref;
 73021:     rv = prefService->GetIntPref("network.websocket.max-message-size", 
 73021:                                  &intpref);
 70220:     if (NS_SUCCEEDED(rv)) {
115367:       mMaxMessageSize = clamped(intpref, 1024, INT32_MAX);
 70220:     }
 73021:     rv = prefService->GetIntPref("network.websocket.timeout.close", &intpref);
 70220:     if (NS_SUCCEEDED(rv)) {
 81029:       mCloseTimeout = clamped(intpref, 1, 1800) * 1000;
 70220:     }
 73021:     rv = prefService->GetIntPref("network.websocket.timeout.open", &intpref);
 70220:     if (NS_SUCCEEDED(rv)) {
 81029:       mOpenTimeout = clamped(intpref, 1, 1800) * 1000;
 70220:     }
 73021:     rv = prefService->GetIntPref("network.websocket.timeout.ping.request",
 73021:                                  &intpref);
 70220:     if (NS_SUCCEEDED(rv)) {
 81029:       mPingTimeout = clamped(intpref, 0, 86400) * 1000;
 70220:     }
 73021:     rv = prefService->GetIntPref("network.websocket.timeout.ping.response",
 73021:                                  &intpref);
 70220:     if (NS_SUCCEEDED(rv)) {
 81029:       mPingResponseTimeout = clamped(intpref, 1, 3600) * 1000;
 70220:     }
 73021:     rv = prefService->GetBoolPref("network.websocket.extensions.stream-deflate",
 73021:                                   &boolpref);
 70220:     if (NS_SUCCEEDED(rv)) {
 70220:       mAllowCompression = boolpref ? 1 : 0;
 70220:     }
 73021:     rv = prefService->GetBoolPref("network.websocket.auto-follow-http-redirects",
 73021:                                   &boolpref);
 70220:     if (NS_SUCCEEDED(rv)) {
 70220:       mAutoFollowRedirects = boolpref ? 1 : 0;
 70220:     }
 72502:     rv = prefService->GetIntPref
 72502:       ("network.websocket.max-connections", &intpref);
 72502:     if (NS_SUCCEEDED(rv)) {
 81029:       mMaxConcurrentConnections = clamped(intpref, 1, 0xffff);
 72502:     }
 72502:   }
 72502: 
 86784:   if (sWebSocketAdmissions)
 86784:     LOG(("WebSocketChannel::AsyncOpen %p sessionCount=%d max=%d\n", this,
 86784:          sWebSocketAdmissions->SessionCount(), mMaxConcurrentConnections));
 86784: 
 72502:   if (sWebSocketAdmissions &&
 86784:       sWebSocketAdmissions->SessionCount() >= mMaxConcurrentConnections)
 73021:   {
 86784:     LOG(("WebSocketChannel: max concurrency %d exceeded (%d)",
 86784:          mMaxConcurrentConnections,
 86784:          sWebSocketAdmissions->SessionCount()));
 72502: 
 72502:     // WebSocket connections are expected to be long lived, so return
 72502:     // an error here instead of queueing
 72502:     return NS_ERROR_SOCKET_CREATE_FAILED;
 70220:   }
 70220: 
 70220:   if (mPingTimeout) {
 70220:     mPingTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
 70220:     if (NS_FAILED(rv)) {
 70220:       NS_WARNING("unable to create ping timer. Carrying on.");
 73021:     } else {
 73021:       LOG(("WebSocketChannel will generate ping after %d ms of receive silence\n",
 73021:            mPingTimeout));
 70220:       mPingTimer->SetTarget(mSocketThread);
 73021:       mPingTimer->InitWithCallback(this, mPingTimeout, nsITimer::TYPE_ONE_SHOT);
 70220:     }
 70220:   }
 70220: 
 70220:   mOriginalURI = aURI;
 70220:   mURI = mOriginalURI;
 70220:   mOrigin = aOrigin;
 70220: 
 70220:   nsCOMPtr<nsIURI> localURI;
 70220:   nsCOMPtr<nsIChannel> localChannel;
 70220: 
 70220:   mURI->Clone(getter_AddRefs(localURI));
 70220:   if (mEncrypted)
 70220:     rv = localURI->SetScheme(NS_LITERAL_CSTRING("https"));
 70220:   else
 70220:     rv = localURI->SetScheme(NS_LITERAL_CSTRING("http"));
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 70220: 
 70220:   nsCOMPtr<nsIIOService> ioService;
 70220:   ioService = do_GetService(NS_IOSERVICE_CONTRACTID, &rv);
 70220:   if (NS_FAILED(rv)) {
 70220:     NS_WARNING("unable to continue without io service");
 70220:     return rv;
 70220:   }
 70220: 
 70220:   nsCOMPtr<nsIIOService2> io2 = do_QueryInterface(ioService, &rv);
 70220:   if (NS_FAILED(rv)) {
 73021:     NS_WARNING("WebSocketChannel: unable to continue without ioservice2");
 70220:     return rv;
 70220:   }
 70220: 
 70220:   rv = io2->NewChannelFromURIWithProxyFlags(
 70220:               localURI,
 70220:               mURI,
 70220:               nsIProtocolProxyService::RESOLVE_PREFER_HTTPS_PROXY |
 70220:               nsIProtocolProxyService::RESOLVE_ALWAYS_TUNNEL,
 70220:               getter_AddRefs(localChannel));
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 70220: 
 73021:   // Pass most GetInterface() requests through to our instantiator, but handle
 70220:   // nsIChannelEventSink in this object in order to deal with redirects
 70220:   localChannel->SetNotificationCallbacks(this);
 70220: 
 70220:   mChannel = do_QueryInterface(localChannel, &rv);
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 70220: 
 70220:   mHttpChannel = do_QueryInterface(localChannel, &rv);
 70220:   NS_ENSURE_SUCCESS(rv, rv);
 70220: 
 70220:   rv = SetupRequest();
 70220:   if (NS_FAILED(rv))
 70220:     return rv;
 70220: 
 99957:   rv = ApplyForAdmission();
 99957:   if (NS_FAILED(rv))
 99957:     return rv;
 99957: 
104079:   // Only set these if the open was successful:
104079:   //
104079:   mWasOpened = 1;
104079:   mListener = aListener;
104079:   mContext = aContext;
 99957:   IncrementSessionCount();
 99957: 
 99957:   return rv;
 70220: }
 70220: 
 70220: NS_IMETHODIMP
108991: WebSocketChannel::Close(uint16_t code, const nsACString & reason)
 70220: {
 73020:   LOG(("WebSocketChannel::Close() %p\n", this));
 70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 74745: 
 90616:   if (mRequestedClose) {
 90616:     return NS_OK;
 90616:   }
 90616: 
 74812:   // The API requires the UTF-8 string to be 123 or less bytes
 74812:   if (reason.Length() > 123)
 74812:     return NS_ERROR_ILLEGAL_VALUE;
 74812: 
 70220:   mRequestedClose = 1;
 74812:   mScriptCloseReason = reason;
 74812:   mScriptCloseCode = code;
 70220: 
103141:   if (!mTransport) {
103141:     nsresult rv;
103141:     if (code == CLOSE_GOING_AWAY) {
103141:       // Not an error: for example, tab has closed or navigated away
103141:       LOG(("WebSocketChannel::Close() GOING_AWAY without transport."));
103141:       rv = NS_OK;
103141:     } else {
103141:       LOG(("WebSocketChannel::Close() without transport - error."));
103141:       rv = NS_ERROR_NOT_CONNECTED;
103141:     }
103141:     StopSession(rv);
103141:     return rv;
103141:   }
103141: 
 84709:   return mSocketThread->Dispatch(
106838:       new OutboundEnqueuer(this, new OutboundMessage(kMsgTypeFin, nullptr)),
 73021:                            nsIEventTarget::DISPATCH_NORMAL);
 70220: }
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::SendMsg(const nsACString &aMsg)
 70220: {
 73020:   LOG(("WebSocketChannel::SendMsg() %p\n", this));
 84709: 
 84709:   return SendMsgCommon(&aMsg, false, aMsg.Length());
 70220: }
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::SendBinaryMsg(const nsACString &aMsg)
 70220: {
 73020:   LOG(("WebSocketChannel::SendBinaryMsg() %p len=%d\n", this, aMsg.Length()));
 84709:   return SendMsgCommon(&aMsg, true, aMsg.Length());
 84709: }
 84709: 
 84709: NS_IMETHODIMP
108991: WebSocketChannel::SendBinaryStream(nsIInputStream *aStream, uint32_t aLength)
 84709: {
 84709:   LOG(("WebSocketChannel::SendBinaryStream() %p\n", this));
 84709: 
106838:   return SendMsgCommon(nullptr, true, aLength, aStream);
 84709: }
 84709: 
 84709: nsresult
 84709: WebSocketChannel::SendMsgCommon(const nsACString *aMsg, bool aIsBinary,
108991:                                 uint32_t aLength, nsIInputStream *aStream)
 84709: {
 70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 70220: 
 70220:   if (mRequestedClose) {
 84709:     LOG(("WebSocketChannel:: Error: send when closed\n"));
 70220:     return NS_ERROR_UNEXPECTED;
 70220:   }
 70220: 
 70220:   if (mStopped) {
 84709:     LOG(("WebSocketChannel:: Error: send when stopped\n"));
 70220:     return NS_ERROR_NOT_CONNECTED;
 70220:   }
 70220: 
 86641:   NS_ABORT_IF_FALSE(mMaxMessageSize >= 0, "max message size negative");
108991:   if (aLength > static_cast<uint32_t>(mMaxMessageSize)) {
 85011:     LOG(("WebSocketChannel:: Error: message too big\n"));
 85011:     return NS_ERROR_FILE_TOO_BIG;
 85011:   }
 85011: 
 84709:   return mSocketThread->Dispatch(
 84709:     aStream ? new OutboundEnqueuer(this, new OutboundMessage(aStream, aLength))
 84709:             : new OutboundEnqueuer(this,
 84709:                      new OutboundMessage(aIsBinary ? kMsgTypeBinaryString
 84709:                                                    : kMsgTypeString,
 84709:                                          new nsCString(*aMsg))),
 73021:     nsIEventTarget::DISPATCH_NORMAL);
 70220: }
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::OnTransportAvailable(nsISocketTransport *aTransport,
 70220:                                        nsIAsyncInputStream *aSocketIn,
 70220:                                        nsIAsyncOutputStream *aSocketOut)
 70220: {
 96974:   if (!NS_IsMainThread()) {
 96974:     return NS_DispatchToMainThread(new CallOnTransportAvailable(this,
 96974:                                                                 aTransport,
 96974:                                                                 aSocketIn,
 96974:                                                                 aSocketOut));
 96974:   }
 96974: 
 73021:   LOG(("WebSocketChannel::OnTransportAvailable %p [%p %p %p] rcvdonstart=%d\n",
 70220:        this, aTransport, aSocketIn, aSocketOut, mRecvdHttpOnStartRequest));
 70220: 
 70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 70220:   NS_ABORT_IF_FALSE(!mRecvdHttpUpgradeTransport, "OTA duplicated");
 72181:   NS_ABORT_IF_FALSE(aSocketIn, "OTA with invalid socketIn");
 70220: 
 70220:   mTransport = aTransport;
 70220:   mSocketIn = aSocketIn;
 70220:   mSocketOut = aSocketOut;
 70220: 
 70220:   nsresult rv;
106838:   rv = mTransport->SetEventSink(nullptr, nullptr);
 70220:   if (NS_FAILED(rv)) return rv;
 80658:   rv = mTransport->SetSecurityCallbacks(this);
 70220:   if (NS_FAILED(rv)) return rv;
 70220: 
 70220:   mRecvdHttpUpgradeTransport = 1;
 70220:   if (mRecvdHttpOnStartRequest)
 72502:     return StartWebsocketData();
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: // nsIRequestObserver (from nsIStreamListener)
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::OnStartRequest(nsIRequest *aRequest,
 70220:                                  nsISupports *aContext)
 70220: {
 73021:   LOG(("WebSocketChannel::OnStartRequest(): %p [%p %p] recvdhttpupgrade=%d\n",
 70220:        this, aRequest, aContext, mRecvdHttpUpgradeTransport));
 70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 70220:   NS_ABORT_IF_FALSE(!mRecvdHttpOnStartRequest, "OTA duplicated");
 70220: 
 70220:   if (mOpenTimer) {
 70220:     mOpenTimer->Cancel();
106838:     mOpenTimer = nullptr;
 70220:   }
 70220: 
 70220:   if (mStopped) {
 73021:     LOG(("WebSocketChannel::OnStartRequest: Channel Already Done\n"));
 70220:     AbortSession(NS_ERROR_CONNECTION_REFUSED);
 70220:     return NS_ERROR_CONNECTION_REFUSED;
 70220:   }
 70220: 
 70220:   nsresult rv;
108991:   uint32_t status;
 70220:   char *val, *token;
 70220: 
 70220:   rv = mHttpChannel->GetResponseStatus(&status);
 70220:   if (NS_FAILED(rv)) {
 73021:     LOG(("WebSocketChannel::OnStartRequest: No HTTP Response\n"));
 70220:     AbortSession(NS_ERROR_CONNECTION_REFUSED);
 70220:     return NS_ERROR_CONNECTION_REFUSED;
 70220:   }
 70220: 
 73021:   LOG(("WebSocketChannel::OnStartRequest: HTTP status %d\n", status));
 70220:   if (status != 101) {
 70220:     AbortSession(NS_ERROR_CONNECTION_REFUSED);
 70220:     return NS_ERROR_CONNECTION_REFUSED;
 70220:   }
 70220: 
110974:   nsAutoCString respUpgrade;
 70220:   rv = mHttpChannel->GetResponseHeader(
 70220:     NS_LITERAL_CSTRING("Upgrade"), respUpgrade);
 70220: 
 70220:   if (NS_SUCCEEDED(rv)) {
 70220:     rv = NS_ERROR_ILLEGAL_VALUE;
 70220:     if (!respUpgrade.IsEmpty()) {
 70220:       val = respUpgrade.BeginWriting();
 70220:       while ((token = nsCRT::strtok(val, ", \t", &val))) {
 70220:         if (PL_strcasecmp(token, "Websocket") == 0) {
 70220:           rv = NS_OK;
 70220:           break;
 70220:         }
 70220:       }
 70220:     }
 70220:   }
 70220: 
 70220:   if (NS_FAILED(rv)) {
 73021:     LOG(("WebSocketChannel::OnStartRequest: "
 70220:          "HTTP response header Upgrade: websocket not found\n"));
 95225:     AbortSession(NS_ERROR_ILLEGAL_VALUE);
 70220:     return rv;
 70220:   }
 70220: 
110974:   nsAutoCString respConnection;
 70220:   rv = mHttpChannel->GetResponseHeader(
 70220:     NS_LITERAL_CSTRING("Connection"), respConnection);
 70220: 
 70220:   if (NS_SUCCEEDED(rv)) {
 70220:     rv = NS_ERROR_ILLEGAL_VALUE;
 70220:     if (!respConnection.IsEmpty()) {
 70220:       val = respConnection.BeginWriting();
 70220:       while ((token = nsCRT::strtok(val, ", \t", &val))) {
 70220:         if (PL_strcasecmp(token, "Upgrade") == 0) {
 70220:           rv = NS_OK;
 70220:           break;
 70220:         }
 70220:       }
 70220:     }
 70220:   }
 70220: 
 70220:   if (NS_FAILED(rv)) {
 73021:     LOG(("WebSocketChannel::OnStartRequest: "
 73021:          "HTTP response header 'Connection: Upgrade' not found\n"));
 95225:     AbortSession(NS_ERROR_ILLEGAL_VALUE);
 70220:     return rv;
 70220:   }
 70220: 
110974:   nsAutoCString respAccept;
 70220:   rv = mHttpChannel->GetResponseHeader(
 73021:                        NS_LITERAL_CSTRING("Sec-WebSocket-Accept"),
 73021:                        respAccept);
 70220: 
 70220:   if (NS_FAILED(rv) ||
 70220:     respAccept.IsEmpty() || !respAccept.Equals(mHashedSecret)) {
 73021:     LOG(("WebSocketChannel::OnStartRequest: "
 70220:          "HTTP response header Sec-WebSocket-Accept check failed\n"));
 95225:     LOG(("WebSocketChannel::OnStartRequest: Expected %s received %s\n",
 70220:          mHashedSecret.get(), respAccept.get()));
 70220:     AbortSession(NS_ERROR_ILLEGAL_VALUE);
 70220:     return NS_ERROR_ILLEGAL_VALUE;
 70220:   }
 70220: 
 70220:   // If we sent a sub protocol header, verify the response matches
 70220:   // If it does not, set mProtocol to "" so the protocol attribute
 70220:   // of the WebSocket JS object reflects that
 70220:   if (!mProtocol.IsEmpty()) {
110974:     nsAutoCString respProtocol;
 70220:     rv = mHttpChannel->GetResponseHeader(
 73021:                          NS_LITERAL_CSTRING("Sec-WebSocket-Protocol"), 
 73021:                          respProtocol);
 70220:     if (NS_SUCCEEDED(rv)) {
 70220:       rv = NS_ERROR_ILLEGAL_VALUE;
 70220:       val = mProtocol.BeginWriting();
 70220:       while ((token = nsCRT::strtok(val, ", \t", &val))) {
 70220:         if (PL_strcasecmp(token, respProtocol.get()) == 0) {
 70220:           rv = NS_OK;
 70220:           break;
 70220:         }
 70220:       }
 70220: 
 70220:       if (NS_SUCCEEDED(rv)) {
 73021:         LOG(("WebsocketChannel::OnStartRequest: subprotocol %s confirmed",
 73021:              respProtocol.get()));
 70220:         mProtocol = respProtocol;
 73021:       } else {
 73021:         LOG(("WebsocketChannel::OnStartRequest: "
 70220:              "subprotocol [%s] not found - %s returned",
 70220:              mProtocol.get(), respProtocol.get()));
 70220:         mProtocol.Truncate();
 70220:       }
 73021:     } else {
 73020:       LOG(("WebsocketChannel::OnStartRequest "
 70220:                  "subprotocol [%s] not found - none returned",
 70220:                  mProtocol.get()));
 70220:       mProtocol.Truncate();
 70220:     }
 70220:   }
 70220: 
 70220:   rv = HandleExtensions();
 70220:   if (NS_FAILED(rv))
 70220:     return rv;
 70220: 
 70220:   mRecvdHttpOnStartRequest = 1;
 70220:   if (mRecvdHttpUpgradeTransport)
 72502:     return StartWebsocketData();
 70220: 
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::OnStopRequest(nsIRequest *aRequest,
 70220:                                   nsISupports *aContext,
 70220:                                   nsresult aStatusCode)
 70220: {
 73020:   LOG(("WebSocketChannel::OnStopRequest() %p [%p %p %x]\n",
 70220:        this, aRequest, aContext, aStatusCode));
 70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "not main thread");
 70220: 
 73021:   // This is the end of the HTTP upgrade transaction, the
 70220:   // upgraded streams live on
 70220: 
106838:   mChannel = nullptr;
106838:   mHttpChannel = nullptr;
106838:   mLoadGroup = nullptr;
106838:   mCallbacks = nullptr;
 70220: 
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: // nsIInputStreamCallback
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::OnInputStreamReady(nsIAsyncInputStream *aStream)
 70220: {
 73020:   LOG(("WebSocketChannel::OnInputStreamReady() %p\n", this));
 73021:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
 70220: 
 77269:   if (!mSocketIn) // did we we clean up the socket after scheduling InputReady?
 77269:     return NS_OK;
 77269:   
 70220:   nsRefPtr<nsIStreamListener>    deleteProtector1(mInflateReader);
 70220:   nsRefPtr<nsIStringInputStream> deleteProtector2(mInflateStream);
 70220: 
 70220:   // this is after the  http upgrade - so we are speaking websockets
 70220:   char  buffer[2048];
108991:   uint32_t count;
 70220:   nsresult rv;
 70220: 
 70220:   do {
 70220:     rv = mSocketIn->Read((char *)buffer, 2048, &count);
 73021:     LOG(("WebSocketChannel::OnInputStreamReady: read %u rv %x\n", count, rv));
 70220: 
 70220:     if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
 70220:       mSocketIn->AsyncWait(this, 0, 0, mSocketThread);
 70220:       return NS_OK;
 70220:     }
 70220: 
 70220:     if (NS_FAILED(rv)) {
 80486:       mTCPClosed = true;
 70220:       AbortSession(rv);
 70220:       return rv;
 70220:     }
 70220: 
 70220:     if (count == 0) {
 80486:       mTCPClosed = true;
 70220:       AbortSession(NS_BASE_STREAM_CLOSED);
 70220:       return NS_OK;
 70220:     }
 70220: 
 72181:     if (mStopped) {
 72181:       NS_ABORT_IF_FALSE(mLingeringCloseTimer,
 72181:                         "OnInputReady after stop without linger");
 72181:       continue;
 72181:     }
 72181: 
 70220:     if (mInflateReader) {
 70220:       mInflateStream->ShareData(buffer, count);
106838:       rv = mInflateReader->OnDataAvailable(nullptr, mSocketIn, mInflateStream, 
 73021:                                            0, count);
 73021:     } else {
108991:       rv = ProcessInput((uint8_t *)buffer, count);
 70220:     }
 70220: 
 70220:     if (NS_FAILED(rv)) {
 70220:       AbortSession(rv);
 70220:       return rv;
 70220:     }
 70220:   } while (NS_SUCCEEDED(rv) && mSocketIn);
 70220: 
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: 
 70220: // nsIOutputStreamCallback
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::OnOutputStreamReady(nsIAsyncOutputStream *aStream)
 70220: {
 73020:   LOG(("WebSocketChannel::OnOutputStreamReady() %p\n", this));
 73021:   NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "not socket thread");
 70220:   nsresult rv;
 70220: 
 70220:   if (!mCurrentOut)
 70220:     PrimeNewOutgoingMessage();
 70220: 
 70220:   while (mCurrentOut && mSocketOut) {
 70220:     const char *sndBuf;
108991:     uint32_t toSend;
108991:     uint32_t amtSent;
 70220: 
 70220:     if (mHdrOut) {
 70220:       sndBuf = (const char *)mHdrOut;
 70220:       toSend = mHdrOutToSend;
 73021:       LOG(("WebSocketChannel::OnOutputStreamReady: "
 73021:            "Try to send %u of hdr/copybreak\n", toSend));
 73021:     } else {
 70220:       sndBuf = (char *) mCurrentOut->BeginReading() + mCurrentOutSent;
 70220:       toSend = mCurrentOut->Length() - mCurrentOutSent;
 70220:       if (toSend > 0) {
 73021:         LOG(("WebSocketChannel::OnOutputStreamReady: "
 73021:              "Try to send %u of data\n", toSend));
 70220:       }
 70220:     }
 70220: 
 70220:     if (toSend == 0) {
 70220:       amtSent = 0;
 73021:     } else {
 70220:       rv = mSocketOut->Write(sndBuf, toSend, &amtSent);
 73021:       LOG(("WebSocketChannel::OnOutputStreamReady: write %u rv %x\n",
 70220:            amtSent, rv));
 70220: 
 70220:       if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
106838:         mSocketOut->AsyncWait(this, 0, 0, nullptr);
 70220:         return NS_OK;
 70220:       }
 70220: 
 70220:       if (NS_FAILED(rv)) {
 70220:         AbortSession(rv);
 70220:         return NS_OK;
 70220:       }
 70220:     }
 70220: 
 70220:     if (mHdrOut) {
 70220:       if (amtSent == toSend) {
106838:         mHdrOut = nullptr;
 70220:         mHdrOutToSend = 0;
 73021:       } else {
 70220:         mHdrOut += amtSent;
 70220:         mHdrOutToSend -= amtSent;
 70220:       }
 73021:     } else {
 70220:       if (amtSent == toSend) {
 70220:         if (!mStopped) {
 80658:           NS_DispatchToMainThread(new CallAcknowledge(this,
 73021:                                                       mCurrentOut->Length()));
 70220:         }
 89215:         DeleteCurrentOutGoingMessage();
 70220:         PrimeNewOutgoingMessage();
 73021:       } else {
 70220:         mCurrentOutSent += amtSent;
 70220:       }
 70220:     }
 70220:   }
 70220: 
 70220:   if (mReleaseOnTransmit)
 70220:     ReleaseSession();
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: // nsIStreamListener
 70220: 
 70220: NS_IMETHODIMP
 73020: WebSocketChannel::OnDataAvailable(nsIRequest *aRequest,
 70220:                                     nsISupports *aContext,
 70220:                                     nsIInputStream *aInputStream,
111234:                                     uint64_t aOffset,
108991:                                     uint32_t aCount)
 70220: {
111234:   LOG(("WebSocketChannel::OnDataAvailable() %p [%p %p %p %llu %u]\n",
 70220:          this, aRequest, aContext, aInputStream, aOffset, aCount));
 70220: 
 70220:   if (aContext == mSocketIn) {
 70220:     // This is the deflate decoder
 70220: 
 73021:     LOG(("WebSocketChannel::OnDataAvailable: Deflate Data %u\n",
 70220:              aCount));
 70220: 
108991:     uint8_t  buffer[2048];
108991:     uint32_t maxRead;
108991:     uint32_t count;
 95225:     nsresult rv = NS_OK;  // aCount always > 0, so this just avoids warning
 70220: 
 70220:     while (aCount > 0) {
 70220:       if (mStopped)
 70220:         return NS_BASE_STREAM_CLOSED;
 70220: 
 70220:       maxRead = NS_MIN(2048U, aCount);
 70220:       rv = aInputStream->Read((char *)buffer, maxRead, &count);
 73021:       LOG(("WebSocketChannel::OnDataAvailable: InflateRead read %u rv %x\n",
 70220:            count, rv));
 70220:       if (NS_FAILED(rv) || count == 0) {
 95225:         AbortSession(NS_ERROR_UNEXPECTED);
 95225:         break;
 95225:       }
 95225: 
 95225:       aCount -= count;
 95225:       rv = ProcessInput(buffer, count);
 95225:       if (NS_FAILED(rv)) {
 70220:         AbortSession(rv);
 70220:         break;
 70220:       }
 70220:     }
 95225:     return rv;
 70220:   }
 70220: 
 70220:   if (aContext == mSocketOut) {
 70220:     // This is the deflate encoder
 70220: 
108991:     uint32_t maxRead;
108991:     uint32_t count;
 70220:     nsresult rv;
 70220: 
 70220:     while (aCount > 0) {
 70220:       if (mStopped)
 70220:         return NS_BASE_STREAM_CLOSED;
 70220: 
 70220:       maxRead = NS_MIN(2048U, aCount);
 70220:       EnsureHdrOut(mHdrOutToSend + aCount);
 73021:       rv = aInputStream->Read((char *)mHdrOut + mHdrOutToSend, maxRead, &count);
 73021:       LOG(("WebSocketChannel::OnDataAvailable: DeflateWrite read %u rv %x\n", 
 73021:            count, rv));
 70220:       if (NS_FAILED(rv) || count == 0) {
 70220:         AbortSession(rv);
 70220:         break;
 70220:       }
 70220: 
 70220:       mHdrOutToSend += count;
 70220:       aCount -= count;
 70220:     }
 70220:     return NS_OK;
 70220:   }
 70220: 
 70220: 
 70220:   // Otherwise, this is the HTTP OnDataAvailable Method, which means
 70220:   // this is http data in response to the upgrade request and
 70220:   // there should be no http response body if the upgrade succeeded
 70220: 
 70220:   // This generally should be caught by a non 101 response code in
 70220:   // OnStartRequest().. so we can ignore the data here
 70220: 
 73021:   LOG(("WebSocketChannel::OnDataAvailable: HTTP data unexpected len>=%u\n",
 70220:          aCount));
 70220: 
 70220:   return NS_OK;
 70220: }
 70220: 
 70220: } // namespace mozilla::net
 70220: } // namespace mozilla
