    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set sw=2 ts=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Peter Annema <disttsc@bart.nl>
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *   Henri Sivonen <hsivonen@iki.fi>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80467: #include "mozilla/Util.h"
80467: 
    1: #include "nsContentSink.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIHTMLContentSink.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIParser.h"
    1: #include "nsScriptLoader.h"
    1: #include "nsIURI.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsHTMLTokens.h"
    1: #include "nsIAppShell.h"
    1: #include "nsCRT.h"
    1: #include "prtime.h"
    1: #include "prlog.h"
    1: #include "nsNodeUtils.h"
    1: #include "nsIContent.h"
41930: #include "mozilla/dom/Element.h"
70842: #include "mozilla/Preferences.h"
    1: 
    1: #include "nsGenericHTMLElement.h"
    1: 
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentType.h"
    1: #include "nsIScriptElement.h"
    1: 
    1: #include "nsIComponentManager.h"
    1: #include "nsIServiceManager.h"
    1: 
    1: #include "nsGkAtoms.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIChannel.h"
    1: #include "nsIHttpChannel.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocument.h"
    1: #include "nsStubDocumentObserver.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDOMHTMLMapElement.h"
    1: #include "nsICookieService.h"
23904: #include "nsTArray.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsTextFragment.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptGlobalObjectOwner.h"
    1: 
    1: #include "nsIParserService.h"
    1: 
    1: #include "nsIStyleSheetLinkingElement.h"
    1: #include "nsITimer.h"
    1: #include "nsDOMError.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsStyleLinkElement.h"
    1: 
    1: #include "nsReadableUtils.h"
    1: #include "nsWeakReference.h" // nsHTMLElementFactory supports weak references
    1: #include "nsIPrompt.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsIDocShellTreeItem.h"
    1: 
    1: #include "nsEscape.h"
    1: #include "nsIElementObserver.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsContentCreatorFunctions.h"
14228: #include "mozAutoDocUpdate.h"
    1: 
70842: using namespace mozilla;
41634: using namespace mozilla::dom;
41634: 
    1: #ifdef NS_DEBUG
    1: static PRLogModuleInfo* gSinkLogModuleInfo;
    1: 
    1: #define SINK_TRACE_NODE(_bit, _msg, _tag, _sp, _obj) \
    1:   _obj->SinkTraceNode(_bit, _msg, _tag, _sp, this)
    1: 
    1: #else
    1: #define SINK_TRACE_NODE(_bit, _msg, _tag, _sp, _obj)
    1: #endif
    1: 
    1: //----------------------------------------------------------------------
    1: 
48124: typedef nsGenericHTMLElement*
56805:   (*contentCreatorCallback)(already_AddRefed<nsINodeInfo>,
56805:                             FromParser aFromParser);
    1: 
    1: nsGenericHTMLElement*
48124: NS_NewHTMLNOTUSEDElement(already_AddRefed<nsINodeInfo> aNodeInfo,
56805:                          FromParser aFromParser)
    1: {
    1:   NS_NOTREACHED("The element ctor should never be called");
    1:   return nsnull;
    1: }
    1: 
    1: #define HTML_TAG(_tag, _classname) NS_NewHTML##_classname##Element,
47236: #define HTML_HTMLELEMENT_TAG(_tag) NS_NewHTMLElement,
    1: #define HTML_OTHER(_tag) NS_NewHTMLNOTUSEDElement,
    1: static const contentCreatorCallback sContentCreatorCallbacks[] = {
    1:   NS_NewHTMLUnknownElement,
    1: #include "nsHTMLTagList.h"
    1: #undef HTML_TAG
47236: #undef HTML_HTMLELEMENT_TAG
    1: #undef HTML_OTHER
    1:   NS_NewHTMLUnknownElement
    1: };
    1: 
    1: class SinkContext;
    1: class HTMLContentSink;
    1: 
    1: class HTMLContentSink : public nsContentSink,
    1: #ifdef DEBUG
    1:                         public nsIDebugDumpContent,
    1: #endif
    1:                         public nsIHTMLContentSink
    1: {
    1: public:
    1:   friend class SinkContext;
    1: 
    1:   HTMLContentSink();
    1:   virtual ~HTMLContentSink();
    1: 
    1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
    1: 
    1:   nsresult Init(nsIDocument* aDoc, nsIURI* aURI, nsISupports* aContainer,
    1:                 nsIChannel* aChannel);
    1: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS_INHERITED
40040:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(HTMLContentSink, nsContentSink)
    1: 
    1:   // nsIContentSink
21121:   NS_IMETHOD WillParse(void);
29496:   NS_IMETHOD WillBuildModel(nsDTDMode aDTDMode);
79445:   NS_IMETHOD DidBuildModel(bool aTerminated);
    1:   NS_IMETHOD WillInterrupt(void);
    1:   NS_IMETHOD WillResume(void);
87806:   NS_IMETHOD SetParser(nsParserBase* aParser);
    1:   virtual void FlushPendingNotifications(mozFlushType aType);
    1:   NS_IMETHOD SetDocumentCharset(nsACString& aCharset);
    1:   virtual nsISupports *GetTarget();
79445:   virtual bool IsScriptExecuting();
    1: 
    1:   // nsIHTMLContentSink
92473:   virtual bool IsAboutBlank() { return true; }
    1:   NS_IMETHOD OpenContainer(const nsIParserNode& aNode);
    1:   NS_IMETHOD CloseContainer(const nsHTMLTag aTag);
    1:   NS_IMETHOD CloseMalformedContainer(const nsHTMLTag aTag);
    1:   NS_IMETHOD AddLeaf(const nsIParserNode& aNode);
    1:   NS_IMETHOD DidProcessTokens(void);
    1:   NS_IMETHOD WillProcessAToken(void);
    1:   NS_IMETHOD DidProcessAToken(void);
    1:   NS_IMETHOD BeginContext(PRInt32 aID);
    1:   NS_IMETHOD EndContext(PRInt32 aID);
    1:   NS_IMETHOD OpenHead();
79445:   NS_IMETHOD IsEnabled(PRInt32 aTag, bool* aReturn);
    1: 
    1: #ifdef DEBUG
    1:   // nsIDebugDumpContent
    1:   NS_IMETHOD DumpContentModel();
    1: #endif
    1: 
    1: protected:
    1:   // If aCheckIfPresent is true, will only set an attribute in cases
    1:   // when it's not already set.
    1:   nsresult AddAttributes(const nsIParserNode& aNode, nsIContent* aContent,
79445:                          bool aNotify = false,
79445:                          bool aCheckIfPresent = false);
    1:   already_AddRefed<nsGenericHTMLElement>
    1:   CreateContentObject(const nsIParserNode& aNode, nsHTMLTag aNodeType);
    1: 
    1: #ifdef NS_DEBUG
    1:   void SinkTraceNode(PRUint32 aBit,
    1:                      const char* aMsg,
    1:                      const nsHTMLTag aTag,
    1:                      PRInt32 aStackPos,
    1:                      void* aThis);
    1: #endif
    1: 
40040:   nsCOMPtr<nsIHTMLDocument> mHTMLDocument;
    1: 
    1:   // The maximum length of a text run
    1:   PRInt32 mMaxTextRun;
    1: 
40040:   nsRefPtr<nsGenericHTMLElement> mRoot;
40040:   nsRefPtr<nsGenericHTMLElement> mBody;
40040:   nsRefPtr<nsGenericHTMLElement> mHead;
    1: 
26413:   nsAutoTArray<SinkContext*, 8> mContextStack;
    1:   SinkContext* mCurrentContext;
    1:   SinkContext* mHeadContext;
    1: 
    1:   // Boolean indicating whether we've seen a <head> tag that might have had
    1:   // attributes once already.
79445:   bool mHaveSeenHead;
    1: 
    1:   // Boolean indicating whether we've notified insertion of our root content
    1:   // yet.  We want to make sure to only do this once.
79445:   bool mNotifiedRootInsertion;
    1: 
    1:   PRUint8 mScriptEnabled : 1;
    1:   PRUint8 mFramesEnabled : 1;
88021:   PRUint8 unused : 6;  // bits available if someone needs one
    1: 
    1:   nsINodeInfo* mNodeInfoCache[NS_HTML_TAG_MAX + 1];
    1: 
    1:   nsresult FlushTags();
    1: 
    1:   // Routines for tags that require special handling
    1:   nsresult CloseHTML();
    1:   nsresult OpenBody(const nsIParserNode& aNode);
    1:   nsresult CloseBody();
    1: 
    1:   nsresult OpenHeadContext();
    1:   void CloseHeadContext();
    1: 
    1:   // nsContentSink overrides
    1:   void UpdateChildCounts();
    1: 
    1:   void NotifyInsert(nsIContent* aContent,
    1:                     nsIContent* aChildContent,
    1:                     PRInt32 aIndexInContainer);
 6642:   void NotifyRootInsertion();
 6642:   
79445:   bool IsMonolithicContainer(nsHTMLTag aTag);
    1: 
    1: #ifdef NS_DEBUG
    1:   void ForceReflow();
    1: #endif
    1: };
    1: 
    1: class SinkContext
    1: {
    1: public:
    1:   SinkContext(HTMLContentSink* aSink);
    1:   ~SinkContext();
    1: 
    1:   nsresult Begin(nsHTMLTag aNodeType, nsGenericHTMLElement* aRoot,
    1:                  PRUint32 aNumFlushed, PRInt32 aInsertionPoint);
    1:   nsresult OpenContainer(const nsIParserNode& aNode);
88015:   nsresult CloseContainer(const nsHTMLTag aTag);
    1:   nsresult AddLeaf(const nsIParserNode& aNode);
22966:   nsresult AddLeaf(nsIContent* aContent);
    1:   nsresult End();
    1: 
    1:   nsresult GrowStack();
    1:   nsresult AddText(const nsAString& aText);
79445:   nsresult FlushText(bool* aDidFlush = nsnull,
79445:                      bool aReleaseLast = false);
79445:   nsresult FlushTextAndRelease(bool* aDidFlush = nsnull)
    1:   {
80486:     return FlushText(aDidFlush, true);
    1:   }
    1: 
    1:   nsresult FlushTags();
    1: 
79445:   bool     IsCurrentContainer(nsHTMLTag mType);
    1: 
    1:   void DidAddContent(nsIContent* aContent);
    1:   void UpdateChildCounts();
    1: 
    1: private:
    1:   // Function to check whether we've notified for the current content.
    1:   // What this actually does is check whether we've notified for all
    1:   // of the parent's kids.
79445:   bool HaveNotifiedForCurrentContent() const;
    1:   
    1: public:
    1:   HTMLContentSink* mSink;
    1:   PRInt32 mNotifyLevel;
    1:   nsCOMPtr<nsIContent> mLastTextNode;
    1:   PRInt32 mLastTextNodeSize;
    1: 
    1:   struct Node {
    1:     nsHTMLTag mType;
    1:     nsGenericHTMLElement* mContent;
    1:     PRUint32 mNumFlushed;
    1:     PRInt32 mInsertionPoint;
20342: 
20342:     nsIContent *Add(nsIContent *child);
    1:   };
    1: 
    1:   Node* mStack;
    1:   PRInt32 mStackSize;
    1:   PRInt32 mStackPos;
    1: 
    1:   PRUnichar* mText;
    1:   PRInt32 mTextLength;
    1:   PRInt32 mTextSize;
17064: 
17064: private:
79445:   bool mLastTextCharWasCR;
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: #ifdef NS_DEBUG
    1: void
    1: HTMLContentSink::SinkTraceNode(PRUint32 aBit,
    1:                                const char* aMsg,
    1:                                const nsHTMLTag aTag,
    1:                                PRInt32 aStackPos,
    1:                                void* aThis)
    1: {
    1:   if (SINK_LOG_TEST(gSinkLogModuleInfo, aBit)) {
    1:     nsIParserService *parserService = nsContentUtils::GetParserService();
    1:     if (!parserService)
    1:       return;
    1: 
    1:     NS_ConvertUTF16toUTF8 tag(parserService->HTMLIdToStringTag(aTag));
    1:     PR_LogPrint("%s: this=%p node='%s' stackPos=%d", 
    1:                 aMsg, aThis, tag.get(), aStackPos);
    1:   }
    1: }
    1: #endif
    1: 
    1: nsresult
    1: HTMLContentSink::AddAttributes(const nsIParserNode& aNode,
79445:                                nsIContent* aContent, bool aNotify,
79445:                                bool aCheckIfPresent)
    1: {
    1:   // Add tag attributes to the content attributes
    1: 
    1:   PRInt32 ac = aNode.GetAttributeCount();
    1: 
    1:   if (ac == 0) {
    1:     // No attributes, nothing to do. Do an early return to avoid
    1:     // constructing the nsAutoString object for nothing.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsHTMLTag nodeType = nsHTMLTag(aNode.GetNodeType());
    1: 
    1:   // The attributes are on the parser node in the order they came in in the
    1:   // source.  What we want to happen if a single attribute is set multiple
    1:   // times on an element is that the first time should "win".  That is, <input
    1:   // value="foo" value="bar"> should show "foo".  So we loop over the
    1:   // attributes backwards; this ensures that the first attribute in the set
    1:   // wins.  This does mean that we do some extra work in the case when the same
    1:   // attribute is set multiple times, but we save a HasAttr call in the much
    1:   // more common case of reasonable HTML.  Note that if aCheckIfPresent is set
    1:   // then we actually want to loop _forwards_ to preserve the "first attribute
    1:   // wins" behavior.  That does mean that when aCheckIfPresent is set the order
    1:   // of attributes will get "reversed" from the point of view of the
    1:   // serializer.  But aCheckIfPresent is only true for malformed documents with
    1:   // multiple <html>, <head>, or <body> tags, so we're doing fixup anyway at
    1:   // that point.
    1: 
    1:   PRInt32 i, limit, step;
    1:   if (aCheckIfPresent) {
    1:     i = 0;
    1:     limit = ac;
    1:     step = 1;
    1:   } else {
    1:     i = ac - 1;
    1:     limit = -1;
    1:     step = -1;
    1:   }
    1:   
39101:   nsAutoString key;
    1:   for (; i != limit; i += step) {
    1:     // Get lower-cased key
92465:     nsresult rv = nsContentUtils::ASCIIToLower(aNode.GetKeyAt(i), key);
92465:     if (NS_FAILED(rv)) {
92465:       return rv;
92465:     }
39101: 
39101:     nsCOMPtr<nsIAtom> keyAtom = do_GetAtom(key);
    1: 
    1:     if (aCheckIfPresent && aContent->HasAttr(kNameSpaceID_None, keyAtom)) {
    1:       continue;
    1:     }
    1: 
    1:     // Get value and remove mandatory quotes
    1:     static const char* kWhitespace = "\n\r\t\b";
    1: 
    1:     // Bug 114997: Don't trim whitespace on <input value="...">:
    1:     // Using ?: outside the function call would be more efficient, but
    1:     // we don't trust ?: with references.
    1:     const nsAString& v =
    1:       nsContentUtils::TrimCharsInSet(
    1:         (nodeType == eHTMLTag_input &&
    1:           keyAtom == nsGkAtoms::value) ?
    1:         "" : kWhitespace, aNode.GetValueAt(i));
    1: 
    1:     if (nodeType == eHTMLTag_a && keyAtom == nsGkAtoms::name) {
    1:       NS_ConvertUTF16toUTF8 cname(v);
    1:       NS_ConvertUTF8toUTF16 uv(nsUnescape(cname.BeginWriting()));
    1: 
    1:       // Add attribute to content
    1:       aContent->SetAttr(kNameSpaceID_None, keyAtom, uv, aNotify);
    1:     } else {
    1:       // Add attribute to content
    1:       aContent->SetAttr(kNameSpaceID_None, keyAtom, v, aNotify);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * Factory subroutine to create all of the html content objects.
    1:  */
    1: already_AddRefed<nsGenericHTMLElement>
    1: HTMLContentSink::CreateContentObject(const nsIParserNode& aNode,
    1:                                      nsHTMLTag aNodeType)
    1: {
    1:   // Find/create atom for the tag name
    1: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
    1: 
    1:   if (aNodeType == eHTMLTag_userdefined) {
43337:     nsAutoString lower;
43337:     nsContentUtils::ASCIIToLower(aNode.GetText(), lower);
43337:     nsCOMPtr<nsIAtom> name = do_GetAtom(lower);
71770:     nodeInfo = mNodeInfoManager->GetNodeInfo(name, nsnull, kNameSpaceID_XHTML,
71770:                                              nsIDOMNode::ELEMENT_NODE);
    1:   }
    1:   else if (mNodeInfoCache[aNodeType]) {
    1:     nodeInfo = mNodeInfoCache[aNodeType];
    1:   }
    1:   else {
    1:     nsIParserService *parserService = nsContentUtils::GetParserService();
    1:     if (!parserService)
    1:       return nsnull;
    1: 
    1:     nsIAtom *name = parserService->HTMLIdToAtomTag(aNodeType);
    1:     NS_ASSERTION(name, "What? Reverse mapping of id to string broken!!!");
    1: 
71770:     nodeInfo = mNodeInfoManager->GetNodeInfo(name, nsnull, kNameSpaceID_XHTML,
71770:                                              nsIDOMNode::ELEMENT_NODE);
    1:     NS_IF_ADDREF(mNodeInfoCache[aNodeType] = nodeInfo);
    1:   }
    1: 
    1:   NS_ENSURE_TRUE(nodeInfo, nsnull);
    1: 
    1:   // Make the content object
56805:   return CreateHTMLElement(aNodeType, nodeInfo.forget(), FROM_PARSER_NETWORK);
    1: }
    1: 
    1: nsresult
48124: NS_NewHTMLElement(nsIContent** aResult, already_AddRefed<nsINodeInfo> aNodeInfo,
56805:                   FromParser aFromParser)
    1: {
    1:   *aResult = nsnull;
    1: 
48124:   nsCOMPtr<nsINodeInfo> nodeInfo = aNodeInfo;
48124: 
    1:   nsIParserService* parserService = nsContentUtils::GetParserService();
    1:   if (!parserService)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
48124:   nsIAtom *name = nodeInfo->NameAtom();
48124: 
48124:   NS_ASSERTION(nodeInfo->NamespaceEquals(kNameSpaceID_XHTML), 
29004:                "Trying to HTML elements that don't have the XHTML namespace");
    1:   
    1:   *aResult = CreateHTMLElement(parserService->
    1:                                  HTMLCaseSensitiveAtomTagToId(name),
48124:                                nodeInfo.forget(), aFromParser).get();
    1:   return *aResult ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: already_AddRefed<nsGenericHTMLElement>
48124: CreateHTMLElement(PRUint32 aNodeType, already_AddRefed<nsINodeInfo> aNodeInfo,
56805:                   FromParser aFromParser)
    1: {
    1:   NS_ASSERTION(aNodeType <= NS_HTML_TAG_MAX ||
    1:                aNodeType == eHTMLTag_userdefined,
    1:                "aNodeType is out of bounds");
    1: 
    1:   contentCreatorCallback cb = sContentCreatorCallbacks[aNodeType];
    1: 
    1:   NS_ASSERTION(cb != NS_NewHTMLNOTUSEDElement,
    1:                "Don't know how to construct tag element!");
    1: 
    1:   nsGenericHTMLElement* result = cb(aNodeInfo, aFromParser);
    1:   NS_IF_ADDREF(result);
    1: 
    1:   return result;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: SinkContext::SinkContext(HTMLContentSink* aSink)
    1:   : mSink(aSink),
    1:     mNotifyLevel(0),
    1:     mLastTextNodeSize(0),
    1:     mStack(nsnull),
    1:     mStackSize(0),
    1:     mStackPos(0),
    1:     mText(nsnull),
    1:     mTextLength(0),
17064:     mTextSize(0),
80486:     mLastTextCharWasCR(false)
    1: {
    1:   MOZ_COUNT_CTOR(SinkContext);
    1: }
    1: 
    1: SinkContext::~SinkContext()
    1: {
    1:   MOZ_COUNT_DTOR(SinkContext);
    1: 
    1:   if (mStack) {
    1:     for (PRInt32 i = 0; i < mStackPos; i++) {
    1:       NS_RELEASE(mStack[i].mContent);
    1:     }
    1:     delete [] mStack;
    1:   }
    1: 
    1:   delete [] mText;
    1: }
    1: 
    1: nsresult
    1: SinkContext::Begin(nsHTMLTag aNodeType,
    1:                    nsGenericHTMLElement* aRoot,
    1:                    PRUint32 aNumFlushed,
    1:                    PRInt32 aInsertionPoint)
    1: {
    1:   if (mStackSize < 1) {
    1:     nsresult rv = GrowStack();
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1:   }
    1: 
    1:   mStack[0].mType = aNodeType;
    1:   mStack[0].mContent = aRoot;
    1:   mStack[0].mNumFlushed = aNumFlushed;
    1:   mStack[0].mInsertionPoint = aInsertionPoint;
    1:   NS_ADDREF(aRoot);
    1:   mStackPos = 1;
    1:   mTextLength = 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
79445: bool
    1: SinkContext::IsCurrentContainer(nsHTMLTag aTag)
    1: {
    1:   if (aTag == mStack[mStackPos - 1].mType) {
80486:     return true;
    1:   }
    1: 
80486:   return false;
    1: }
    1: 
    1: void
    1: SinkContext::DidAddContent(nsIContent* aContent)
    1: {
88016:   if ((mStackPos == 2) && (mSink->mBody == mStack[1].mContent)) {
    1:     // We just finished adding something to the body
    1:     mNotifyLevel = 0;
    1:   }
    1: 
    1:   // If we just added content to a node for which
    1:   // an insertion happen, we need to do an immediate
    1:   // notification for that insertion.
    1:   if (0 < mStackPos &&
    1:       mStack[mStackPos - 1].mInsertionPoint != -1 &&
    1:       mStack[mStackPos - 1].mNumFlushed <
    1:       mStack[mStackPos - 1].mContent->GetChildCount()) {
    1:     nsIContent* parent = mStack[mStackPos - 1].mContent;
    1: 
    1: #ifdef NS_DEBUG
    1:     // Tracing code
    1:     nsIParserService *parserService = nsContentUtils::GetParserService();
    1:     if (parserService) {
    1:       nsHTMLTag tag = nsHTMLTag(mStack[mStackPos - 1].mType);
    1:       NS_ConvertUTF16toUTF8 str(parserService->HTMLIdToStringTag(tag));
    1: 
    1:       SINK_TRACE(gSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:                  ("SinkContext::DidAddContent: Insertion notification for "
    1:                   "parent=%s at position=%d and stackPos=%d",
    1:                   str.get(), mStack[mStackPos - 1].mInsertionPoint - 1,
    1:                   mStackPos - 1));
    1:     }
    1: #endif
    1: 
20342:     PRInt32 childIndex = mStack[mStackPos - 1].mInsertionPoint - 1;
20342:     NS_ASSERTION(parent->GetChildAt(childIndex) == aContent,
20342:                  "Flushing the wrong child.");
20342:     mSink->NotifyInsert(parent, aContent, childIndex);
    1:     mStack[mStackPos - 1].mNumFlushed = parent->GetChildCount();
    1:   } else if (mSink->IsTimeToNotify()) {
    1:     SINK_TRACE(gSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:                ("SinkContext::DidAddContent: Notification as a result of the "
    1:                 "interval expiring; backoff count: %d", mSink->mBackoffCount));
    1:     FlushTags();
    1:   }
    1: }
    1: 
    1: nsresult
    1: SinkContext::OpenContainer(const nsIParserNode& aNode)
    1: {
    1:   FlushTextAndRelease();
    1: 
    1:   SINK_TRACE_NODE(SINK_TRACE_CALLS,
    1:                   "SinkContext::OpenContainer", 
    1:                   nsHTMLTag(aNode.GetNodeType()), 
    1:                   mStackPos, 
    1:                   mSink);
    1: 
    1:   if (mStackPos <= 0) {
    1:     NS_ERROR("container w/o parent");
    1: 
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsresult rv;
    1:   if (mStackPos + 1 > mStackSize) {
    1:     rv = GrowStack();
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1:   }
    1: 
    1:   // Create new container content object
    1:   nsHTMLTag nodeType = nsHTMLTag(aNode.GetNodeType());
    1:   nsGenericHTMLElement* content =
    1:     mSink->CreateContentObject(aNode, nodeType).get();
    1:   if (!content) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   mStack[mStackPos].mType = nodeType;
    1:   mStack[mStackPos].mContent = content;
    1:   mStack[mStackPos].mNumFlushed = 0;
    1:   mStack[mStackPos].mInsertionPoint = -1;
    1:   ++mStackPos;
    1: 
    1:   rv = mSink->AddAttributes(aNode, content);
    1: 
20342:   mStack[mStackPos - 2].Add(content);
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (mSink->IsMonolithicContainer(nodeType)) {
    1:     mSink->mInMonolithicContainer++;
    1:   }
    1: 
    1:   // Special handling for certain tags
    1:   switch (nodeType) {
    1:     case eHTMLTag_form:
88021:       MOZ_NOT_REACHED("Must not use HTMLContentSink for forms.");
    1:       break;
    1: 
    1:     case eHTMLTag_frameset:
88016:       MOZ_NOT_REACHED("Must not use HTMLContentSink for frames.");
    1:       break;
    1: 
    1:     case eHTMLTag_noembed:
    1:     case eHTMLTag_noframes:
88019:       MOZ_NOT_REACHED("Must not use HTMLContentSink for noembed/noframes.");
    1:       break;
    1: 
    1:     case eHTMLTag_script:
88016:     case eHTMLTag_style:
88016:       MOZ_NOT_REACHED("Must not use HTMLContentSink for styles and scripts.");
    1:       break;
    1: 
    1:     case eHTMLTag_button:
87833: #ifdef MOZ_MEDIA
84678:     case eHTMLTag_audio:
84678:     case eHTMLTag_video:
87833: #endif
    1:       content->DoneCreatingElement();
    1:       break;
    1: 
    1:     default:
    1:       break;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
79445: bool
    1: SinkContext::HaveNotifiedForCurrentContent() const
    1: {
    1:   if (0 < mStackPos) {
    1:     nsIContent* parent = mStack[mStackPos - 1].mContent;
    1:     return mStack[mStackPos-1].mNumFlushed == parent->GetChildCount();
    1:   }
    1: 
80486:   return true;
    1: }
    1: 
20342: nsIContent *
20342: SinkContext::Node::Add(nsIContent *child)
20342: {
22966:   NS_ASSERTION(mContent, "No parent to insert/append into!");
20342:   if (mInsertionPoint != -1) {
20342:     NS_ASSERTION(mNumFlushed == mContent->GetChildCount(),
20342:                  "Inserting multiple children without flushing.");
80486:     mContent->InsertChildAt(child, mInsertionPoint++, false);
20342:   } else {
80486:     mContent->AppendChildTo(child, false);
20342:   }
20342:   return child;
20342: }
20342: 
    1: nsresult
88015: SinkContext::CloseContainer(const nsHTMLTag aTag)
    1: {
    1:   nsresult result = NS_OK;
    1: 
    1:   // Flush any collected text content. Release the last text
    1:   // node to indicate that no more should be added to it.
    1:   FlushTextAndRelease();
    1: 
    1:   SINK_TRACE_NODE(SINK_TRACE_CALLS,
    1:                   "SinkContext::CloseContainer", 
    1:                   aTag, mStackPos - 1, mSink);
    1: 
    1:   NS_ASSERTION(mStackPos > 0,
    1:                "stack out of bounds. wrong context probably!");
    1: 
    1:   if (mStackPos <= 0) {
    1:     return NS_OK; // Fix crash - Ref. bug 45975 or 45007
    1:   }
    1: 
    1:   --mStackPos;
    1:   nsHTMLTag nodeType = mStack[mStackPos].mType;
    1: 
88021:   NS_ASSERTION(nodeType == aTag,
    1:                "Tag mismatch.  Closing tag on wrong context or something?");
    1: 
    1:   nsGenericHTMLElement* content = mStack[mStackPos].mContent;
    1: 
11169:   content->Compact();
    1: 
    1:   // If we're in a state where we do append notifications as
    1:   // we go up the tree, and we're at the level where the next
    1:   // notification needs to be done, do the notification.
    1:   if (mNotifyLevel >= mStackPos) {
    1:     // Check to see if new content has been added after our last
    1:     // notification
    1: 
    1:     if (mStack[mStackPos].mNumFlushed < content->GetChildCount()) {
    1: #ifdef NS_DEBUG
    1:       {
    1:         // Tracing code
    1:         SINK_TRACE(gSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:                    ("SinkContext::CloseContainer: reflow on notifyImmediate "
    1:                     "tag=%s newIndex=%d stackPos=%d",
39100:                     nsAtomCString(mStack[mStackPos].mContent->Tag()).get(),
    1:                     mStack[mStackPos].mNumFlushed, mStackPos));
    1:       }
    1: #endif
    1:       mSink->NotifyAppend(content, mStack[mStackPos].mNumFlushed);
    1:       mStack[mStackPos].mNumFlushed = content->GetChildCount();
    1:     }
    1: 
    1:     // Indicate that notification has now happened at this level
    1:     mNotifyLevel = mStackPos - 1;
    1:   }
    1: 
    1:   if (mSink->IsMonolithicContainer(nodeType)) {
    1:     --mSink->mInMonolithicContainer;
    1:   }
    1: 
    1:   DidAddContent(content);
    1: 
    1:   // Special handling for certain tags
    1:   switch (nodeType) {
    1:   case eHTMLTag_noembed:
    1:   case eHTMLTag_noframes:
88019:     MOZ_NOT_REACHED("Must not use HTMLContentSink for noembed/noframes.");
    1:     break;
88019: 
    1:   case eHTMLTag_form:
88021:     MOZ_NOT_REACHED("Must not use HTMLContentSink for forms.");
    1:     break;
    1: 
15751: #ifdef MOZ_MEDIA
15751:   case eHTMLTag_video:
15751:   case eHTMLTag_audio:
15751: #endif
    1:   case eHTMLTag_select:
    1:   case eHTMLTag_textarea:
    1:   case eHTMLTag_object:
    1:   case eHTMLTag_applet:
16977:   case eHTMLTag_title:
    1:     content->DoneAddingChildren(HaveNotifiedForCurrentContent());
    1:     break;
    1: 
    1:   case eHTMLTag_script:
88015:     MOZ_NOT_REACHED("Must not use HTMLContentSink to run scripts.");
88015:     result = NS_ERROR_NOT_IMPLEMENTED;
    1:     break;
    1: 
    1:   case eHTMLTag_style:
88016:     MOZ_NOT_REACHED("Must not use HTMLContentSink for styles.");
88016:     result = NS_ERROR_NOT_IMPLEMENTED;
    1:     break;
    1: 
    1:   default:
    1:     break;
    1:   }
    1: 
    1:   NS_IF_RELEASE(content);
    1: 
    1: #ifdef DEBUG
    1:   if (SINK_LOG_TEST(gSinkLogModuleInfo, SINK_ALWAYS_REFLOW)) {
    1:     mSink->ForceReflow();
    1:   }
    1: #endif
    1: 
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: SinkContext::AddLeaf(const nsIParserNode& aNode)
    1: {
    1:   SINK_TRACE_NODE(SINK_TRACE_CALLS,
    1:                   "SinkContext::AddLeaf", 
    1:                   nsHTMLTag(aNode.GetNodeType()), 
    1:                   mStackPos, mSink);
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   switch (aNode.GetTokenType()) {
    1:   case eToken_start:
    1:     {
    1:       FlushTextAndRelease();
    1: 
    1:       // Create new leaf content object
    1:       nsHTMLTag nodeType = nsHTMLTag(aNode.GetNodeType());
    1:       nsRefPtr<nsGenericHTMLElement> content =
    1:         mSink->CreateContentObject(aNode, nodeType);
    1:       NS_ENSURE_TRUE(content, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       rv = mSink->AddAttributes(aNode, content);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       // Add new leaf to its parent
    1:       AddLeaf(content);
    1: 
    1:       // Additional processing needed once the element is in the tree
    1:       switch (nodeType) {
    1:       case eHTMLTag_meta:
88020:         MOZ_NOT_REACHED("Must not use HTMLContentSink for metas.");
88020:         rv = NS_ERROR_NOT_IMPLEMENTED;
    1:         break;
    1: 
    1:       case eHTMLTag_input:
    1:         content->DoneCreatingElement();
75019:         break;
75019: 
75019:       case eHTMLTag_menuitem:
75019:         content->DoneCreatingElement();
    1:         break;
    1: 
    1:       default:
    1:         break;
    1:       }
    1:     }
    1:     break;
    1: 
    1:   case eToken_text:
    1:   case eToken_whitespace:
    1:   case eToken_newline:
    1:     rv = AddText(aNode.GetText());
    1: 
    1:     break;
    1:   case eToken_entity:
    1:     {
    1:       nsAutoString tmp;
    1:       PRInt32 unicode = aNode.TranslateToUnicodeStr(tmp);
    1:       if (unicode < 0) {
    1:         rv = AddText(aNode.GetText());
    1:       } else {
    1:         // Map carriage returns to newlines
    1:         if (!tmp.IsEmpty()) {
    1:           if (tmp.CharAt(0) == '\r') {
    1:             tmp.Assign((PRUnichar)'\n');
    1:           }
    1:           rv = AddText(tmp);
    1:         }
    1:       }
    1:     }
    1: 
    1:     break;
    1:   default:
    1:     break;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
22966: SinkContext::AddLeaf(nsIContent* aContent)
    1: {
    1:   NS_ASSERTION(mStackPos > 0, "leaf w/o container");
    1:   if (mStackPos <= 0) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   
20342:   DidAddContent(mStack[mStackPos - 1].Add(aContent));
    1: 
    1: #ifdef DEBUG
    1:   if (SINK_LOG_TEST(gSinkLogModuleInfo, SINK_ALWAYS_REFLOW)) {
    1:     mSink->ForceReflow();
    1:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: SinkContext::End()
    1: {
    1:   for (PRInt32 i = 0; i < mStackPos; i++) {
    1:     NS_RELEASE(mStack[i].mContent);
    1:   }
    1: 
    1:   mStackPos = 0;
    1:   mTextLength = 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: SinkContext::GrowStack()
    1: {
    1:   PRInt32 newSize = mStackSize * 2;
    1:   if (newSize == 0) {
    1:     newSize = 32;
    1:   }
    1: 
    1:   Node* stack = new Node[newSize];
    1:   if (!stack) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   if (mStackPos != 0) {
    1:     memcpy(stack, mStack, sizeof(Node) * mStackPos);
    1:     delete [] mStack;
    1:   }
    1: 
    1:   mStack = stack;
    1:   mStackSize = newSize;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * Add textual content to the current running text buffer. If the text buffer
    1:  * overflows, flush out the text by creating a text content object and adding
    1:  * it to the content tree.
    1:  */
    1: 
    1: // XXX If we get a giant string grow the buffer instead of chopping it
    1: // up???
    1: nsresult
    1: SinkContext::AddText(const nsAString& aText)
    1: {
    1:   PRInt32 addLen = aText.Length();
    1:   if (addLen == 0) {
    1:     return NS_OK;
    1:   }
    1:   
    1:   // Create buffer when we first need it
    1:   if (mTextSize == 0) {
    1:     mText = new PRUnichar[4096];
    1:     if (!mText) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     mTextSize = 4096;
    1:   }
    1: 
    1:   // Copy data from string into our buffer; flush buffer when it fills up
    1:   PRInt32 offset = 0;
    1: 
    1:   while (addLen != 0) {
    1:     PRInt32 amount = mTextSize - mTextLength;
    1: 
    1:     if (amount > addLen) {
    1:       amount = addLen;
    1:     }
    1: 
    1:     if (amount == 0) {
    1:       // Don't release last text node so we can add to it again
    1:       nsresult rv = FlushText();
    1:       if (NS_FAILED(rv)) {
    1:         return rv;
    1:       }
17065: 
17065:       // Go back to the top of the loop so we re-calculate amount and
17065:       // don't fall through to CopyNewlineNormalizedUnicodeTo with a
17065:       // zero-length amount (which invalidates mLastTextCharWasCR).
17065:       continue;
    1:     }
    1: 
    1:     mTextLength +=
    1:       nsContentUtils::CopyNewlineNormalizedUnicodeTo(aText, offset,
    1:                                                      &mText[mTextLength],
17064:                                                      amount,
17064:                                                      mLastTextCharWasCR);
    1:     offset += amount;
    1:     addLen -= amount;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * NOTE!! Forked into nsXMLContentSink. Please keep in sync.
    1:  *
    1:  * Flush all elements that have been seen so far such that
    1:  * they are visible in the tree. Specifically, make sure
    1:  * that they are all added to their respective parents.
    1:  * Also, do notification at the top for all content that
    1:  * has been newly added so that the frame tree is complete.
    1:  */
    1: nsresult
    1: SinkContext::FlushTags()
    1: {
80486:   mSink->mDeferredFlushTags = false;
79445:   bool oldBeganUpdate = mSink->mBeganUpdate;
 1574:   PRUint32 oldUpdates = mSink->mUpdatesInNotification;
    1: 
    1:   ++(mSink->mInNotification);
 1574:   mSink->mUpdatesInNotification = 0;
  398:   {
  398:     // Scope so we call EndUpdate before we decrease mInNotification
    1:     mozAutoDocUpdate updateBatch(mSink->mDocument, UPDATE_CONTENT_MODEL,
80486:                                  true);
80486:     mSink->mBeganUpdate = true;
    1: 
    1:     // Don't release last text node in case we need to add to it again
    1:     FlushText();
    1: 
    1:     // Start from the base of the stack (growing downward) and do
    1:     // a notification from the node that is closest to the root of
    1:     // tree for any content that has been added.
    1: 
    1:     // Note that we can start at stackPos == 0 here, because it's the caller's
    1:     // responsibility to handle flushing interactions between contexts (see
    1:     // HTMLContentSink::BeginContext).
    1:     PRInt32 stackPos = 0;
79445:     bool flushed = false;
    1:     PRUint32 childCount;
    1:     nsGenericHTMLElement* content;
    1: 
    1:     while (stackPos < mStackPos) {
    1:       content = mStack[stackPos].mContent;
    1:       childCount = content->GetChildCount();
    1: 
    1:       if (!flushed && (mStack[stackPos].mNumFlushed < childCount)) {
    1: #ifdef NS_DEBUG
    1:         {
    1:           // Tracing code
    1:           SINK_TRACE(gSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:                      ("SinkContext::FlushTags: tag=%s from newindex=%d at "
39100:                       "stackPos=%d",
39100:                       nsAtomCString(mStack[stackPos].mContent->Tag()).get(),
    1:                       mStack[stackPos].mNumFlushed, stackPos));
    1:         }
    1: #endif
31441:         if (mStack[stackPos].mInsertionPoint != -1) {
31441:           // We might have popped the child off our stack already
31441:           // but not notified on it yet, which is why we have to get it
31441:           // directly from its parent node.
31441: 
20342:           PRInt32 childIndex = mStack[stackPos].mInsertionPoint - 1;
31441:           nsIContent* child = content->GetChildAt(childIndex);
31441:           // Child not on stack anymore; can't assert it's correct
31441:           NS_ASSERTION(!(mStackPos > (stackPos + 1)) ||
31441:                        (child == mStack[stackPos + 1].mContent),
20342:                        "Flushing the wrong child.");
20342:           mSink->NotifyInsert(content, child, childIndex);
    1:         } else {
    1:           mSink->NotifyAppend(content, mStack[stackPos].mNumFlushed);
    1:         }
    1: 
80486:         flushed = true;
    1:       }
    1: 
    1:       mStack[stackPos].mNumFlushed = childCount;
    1:       stackPos++;
    1:     }
    1:     mNotifyLevel = mStackPos - 1;
  398:   }
    1:   --(mSink->mInNotification);
    1: 
 1574:   if (mSink->mUpdatesInNotification > 1) {
 1574:     UpdateChildCounts();
 1574:   }
 1574: 
 1574:   mSink->mUpdatesInNotification = oldUpdates;
    1:   mSink->mBeganUpdate = oldBeganUpdate;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * NOTE!! Forked into nsXMLContentSink. Please keep in sync.
    1:  */
    1: void
    1: SinkContext::UpdateChildCounts()
    1: {
    1:   // Start from the top of the stack (growing upwards) and see if any
    1:   // new content has been appended. If so, we recognize that reflows
    1:   // have been generated for it and we should make sure that no
    1:   // further reflows occur.  Note that we have to include stackPos == 0
    1:   // to properly notify on kids of <html>.
    1:   PRInt32 stackPos = mStackPos - 1;
    1:   while (stackPos >= 0) {
    1:     Node & node = mStack[stackPos];
    1:     node.mNumFlushed = node.mContent->GetChildCount();
    1: 
    1:     stackPos--;
    1:   }
    1: 
    1:   mNotifyLevel = mStackPos - 1;
    1: }
    1: 
    1: /**
    1:  * Flush any buffered text out by creating a text content object and
    1:  * adding it to the content.
    1:  */
    1: nsresult
79445: SinkContext::FlushText(bool* aDidFlush, bool aReleaseLast)
    1: {
    1:   nsresult rv = NS_OK;
79445:   bool didFlush = false;
    1: 
    1:   if (mTextLength != 0) {
    1:     if (mLastTextNode) {
    1:       if ((mLastTextNodeSize + mTextLength) > mSink->mMaxTextRun) {
    1:         mLastTextNodeSize = 0;
    1:         mLastTextNode = nsnull;
    1:         FlushText(aDidFlush, aReleaseLast);
    1:       } else {
79445:         bool notify = HaveNotifiedForCurrentContent();
    1:         // We could probably always increase mInNotification here since
    1:         // if AppendText doesn't notify it shouldn't trigger evil code.
    1:         // But just in case it does, we don't want to mask any notifications.
    1:         if (notify) {
    1:           ++mSink->mInNotification;
    1:         }
    1:         rv = mLastTextNode->AppendText(mText, mTextLength, notify);
    1:         if (notify) {
    1:           --mSink->mInNotification;
    1:         }
    1: 
    1:         mLastTextNodeSize += mTextLength;
    1:         mTextLength = 0;
80486:         didFlush = true;
    1:       }
    1:     } else {
    1:       nsCOMPtr<nsIContent> textContent;
    1:       rv = NS_NewTextNode(getter_AddRefs(textContent),
    1:                           mSink->mNodeInfoManager);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       mLastTextNode = textContent;
    1: 
    1:       // Set the text in the text node
80486:       mLastTextNode->SetText(mText, mTextLength, false);
    1: 
    1:       // Eat up the rest of the text up in state.
    1:       mLastTextNodeSize += mTextLength;
    1:       mTextLength = 0;
    1: 
22966:       rv = AddLeaf(mLastTextNode);
22966:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
80486:       didFlush = true;
    1:     }
    1:   }
    1: 
    1:   if (aDidFlush) {
    1:     *aDidFlush = didFlush;
    1:   }
    1: 
    1:   if (aReleaseLast) {
    1:     mLastTextNodeSize = 0;
    1:     mLastTextNode = nsnull;
80486:     mLastTextCharWasCR = false;
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   if (didFlush &&
    1:       SINK_LOG_TEST(gSinkLogModuleInfo, SINK_ALWAYS_REFLOW)) {
    1:     mSink->ForceReflow();
    1:   }
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: NS_NewHTMLContentSink(nsIHTMLContentSink** aResult,
    1:                       nsIDocument* aDoc,
    1:                       nsIURI* aURI,
    1:                       nsISupports* aContainer,
    1:                       nsIChannel* aChannel)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1: 
    1:   nsRefPtr<HTMLContentSink> it = new HTMLContentSink();
    1: 
    1:   if (!it) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   nsresult rv = it->Init(aDoc, aURI, aContainer, aChannel);
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *aResult = it;
    1:   NS_ADDREF(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: HTMLContentSink::HTMLContentSink()
    1: {
    1:   // Note: operator new zeros our memory
    1: 
    1: 
    1: #ifdef NS_DEBUG
    1:   if (!gSinkLogModuleInfo) {
    1:     gSinkLogModuleInfo = PR_NewLogModule("htmlcontentsink");
    1:   }
    1: #endif
    1: }
    1: 
    1: HTMLContentSink::~HTMLContentSink()
    1: {
    1:   if (mNotificationTimer) {
    1:     mNotificationTimer->Cancel();
    1:   }
    1: 
26413:   PRInt32 numContexts = mContextStack.Length();
    1: 
    1:   if (mCurrentContext == mHeadContext && numContexts > 0) {
    1:     // Pop off the second html context if it's not done earlier
    1:     mContextStack.RemoveElementAt(--numContexts);
    1:   }
    1: 
    1:   PRInt32 i;
    1:   for (i = 0; i < numContexts; i++) {
26413:     SinkContext* sc = mContextStack.ElementAt(i);
    1:     if (sc) {
    1:       sc->End();
    1:       if (sc == mCurrentContext) {
    1:         mCurrentContext = nsnull;
    1:       }
    1: 
    1:       delete sc;
    1:     }
    1:   }
    1: 
    1:   if (mCurrentContext == mHeadContext) {
    1:     mCurrentContext = nsnull;
    1:   }
    1: 
    1:   delete mCurrentContext;
    1: 
    1:   delete mHeadContext;
    1: 
80467:   for (i = 0; PRUint32(i) < ArrayLength(mNodeInfoCache); ++i) {
    1:     NS_IF_RELEASE(mNodeInfoCache[i]);
    1:   }
    1: }
    1: 
40040: NS_IMPL_CYCLE_COLLECTION_CLASS(HTMLContentSink)
40040: 
40040: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(HTMLContentSink, nsContentSink)
40040:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mHTMLDocument)
40040:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mRoot)
40040:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mBody)
40040:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mHead)
80467:   for (PRUint32 i = 0; i < ArrayLength(tmp->mNodeInfoCache); ++i) {
40040:     NS_IF_RELEASE(tmp->mNodeInfoCache[i]);
40040:   }
40040: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
40040: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(HTMLContentSink,
40040:                                                   nsContentSink)
40040:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mHTMLDocument)
40040:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRoot)
40040:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mBody)
40040:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mHead)
80467:   for (PRUint32 i = 0; i < ArrayLength(tmp->mNodeInfoCache); ++i) {
40040:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mNodeInfoCache[i]");
40040:     cb.NoteXPCOMChild(tmp->mNodeInfoCache[i]);
40040:   }
40040: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
40040: 
40040: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(HTMLContentSink)
40040:   NS_INTERFACE_TABLE_BEGIN
40040:     NS_INTERFACE_TABLE_ENTRY(HTMLContentSink, nsIContentSink)
40040:     NS_INTERFACE_TABLE_ENTRY(HTMLContentSink, nsIHTMLContentSink)
    1: #if DEBUG
40040:     NS_INTERFACE_TABLE_ENTRY(HTMLContentSink, nsIDebugDumpContent)
    1: #endif
40040:   NS_INTERFACE_TABLE_END
40040: NS_INTERFACE_TABLE_TAIL_INHERITING(nsContentSink)
40040: 
40040: NS_IMPL_ADDREF_INHERITED(HTMLContentSink, nsContentSink)
40040: NS_IMPL_RELEASE_INHERITED(HTMLContentSink, nsContentSink)
    1: 
79445: static bool
    1: IsScriptEnabled(nsIDocument *aDoc, nsIDocShell *aContainer)
    1: {
80486:   NS_ENSURE_TRUE(aDoc && aContainer, true);
    1: 
    1:   nsCOMPtr<nsIScriptGlobalObject> globalObject = aDoc->GetScriptGlobalObject();
    1: 
24112:   // Getting context is tricky if the document hasn't had its
    1:   // GlobalObject set yet
    1:   if (!globalObject) {
    1:     nsCOMPtr<nsIScriptGlobalObjectOwner> owner = do_GetInterface(aContainer);
80486:     NS_ENSURE_TRUE(owner, true);
    1: 
    1:     globalObject = owner->GetScriptGlobalObject();
80486:     NS_ENSURE_TRUE(globalObject, true);
    1:   }
    1: 
    1:   nsIScriptContext *scriptContext = globalObject->GetContext();
80486:   NS_ENSURE_TRUE(scriptContext, true);
    1: 
78415:   JSContext* cx = scriptContext->GetNativeContext();
80486:   NS_ENSURE_TRUE(cx, true);
    1: 
79445:   bool enabled = true;
    1:   nsContentUtils::GetSecurityManager()->
    1:     CanExecuteScripts(cx, aDoc->NodePrincipal(), &enabled);
    1:   return enabled;
    1: }
    1: 
    1: nsresult
    1: HTMLContentSink::Init(nsIDocument* aDoc,
    1:                       nsIURI* aURI,
    1:                       nsISupports* aContainer,
    1:                       nsIChannel* aChannel)
    1: {
    1:   NS_ENSURE_TRUE(aContainer, NS_ERROR_NULL_POINTER);
    1:   
    1:   nsresult rv = nsContentSink::Init(aDoc, aURI, aContainer, aChannel);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   aDoc->AddObserver(this);
80486:   mIsDocumentObserver = true;
40040:   mHTMLDocument = do_QueryInterface(aDoc);
    1: 
    1:   NS_ASSERTION(mDocShell, "oops no docshell!");
    1: 
    1:   // Find out if subframes are enabled
    1:   if (mDocShell) {
79445:     bool subFramesEnabled = true;
    1:     mDocShell->GetAllowSubframes(&subFramesEnabled);
    1:     if (subFramesEnabled) {
80486:       mFramesEnabled = true;
    1:     }
    1:   }
    1: 
    1:   // Find out if scripts are enabled, if not, show <noscript> content
    1:   if (IsScriptEnabled(aDoc, mDocShell)) {
80486:     mScriptEnabled = true;
    1:   }
    1: 
    1: 
    1:   // Changed from 8192 to greatly improve page loading performance on
    1:   // large pages.  See bugzilla bug 77540.
70842:   mMaxTextRun = Preferences::GetInt("content.maxtextrun", 8191);
    1: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
19197:   nodeInfo = mNodeInfoManager->GetNodeInfo(nsGkAtoms::html, nsnull,
71770:                                            kNameSpaceID_XHTML,
71770:                                            nsIDOMNode::ELEMENT_NODE);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // Make root part
48124:   mRoot = NS_NewHTMLHtmlElement(nodeInfo.forget());
    1:   if (!mRoot) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   NS_ASSERTION(mDocument->GetChildCount() == 0,
    1:                "Document should have no kids here!");
80486:   rv = mDocument->AppendChildTo(mRoot, false);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Make head part
19197:   nodeInfo = mNodeInfoManager->GetNodeInfo(nsGkAtoms::head,
71770:                                            nsnull, kNameSpaceID_XHTML,
71770:                                            nsIDOMNode::ELEMENT_NODE);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
48124:   mHead = NS_NewHTMLHeadElement(nodeInfo.forget());
    1:   if (NS_FAILED(rv)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
80486:   mRoot->AppendChildTo(mHead, false);
    1: 
    1:   mCurrentContext = new SinkContext(this);
    1:   NS_ENSURE_TRUE(mCurrentContext, NS_ERROR_OUT_OF_MEMORY);
    1:   mCurrentContext->Begin(eHTMLTag_html, mRoot, 0, -1);
    1:   mContextStack.AppendElement(mCurrentContext);
    1: 
    1: #ifdef NS_DEBUG
    1:   nsCAutoString spec;
    1:   (void)aURI->GetSpec(spec);
    1:   SINK_TRACE(gSinkLogModuleInfo, SINK_TRACE_CALLS,
    1:              ("HTMLContentSink::Init: this=%p url='%s'",
    1:               this, spec.get()));
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
21121: HTMLContentSink::WillParse(void)
21121: {
21121:   return WillParseImpl();
21121: }
21121: 
21121: NS_IMETHODIMP
29496: HTMLContentSink::WillBuildModel(nsDTDMode aDTDMode)
    1: {
    1:   WillBuildModelImpl();
29496: 
    1:   if (mHTMLDocument) {
    1:     nsCompatibility mode = eCompatibility_NavQuirks;
29496:     switch (aDTDMode) {
    1:       case eDTDMode_full_standards:
    1:         mode = eCompatibility_FullStandards;
    1:         break;
    1:       case eDTDMode_almost_standards:
    1:         mode = eCompatibility_AlmostStandards;
    1:         break;
    1:       default:
    1:         break;
    1:     }
    1:     mHTMLDocument->SetCompatibilityMode(mode);
    1:   }
    1: 
    1:   // Notify document that the load is beginning
    1:   mDocument->BeginLoad();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: HTMLContentSink::DidBuildModel(bool aTerminated)
    1: {
33527:   DidBuildModelImpl(aTerminated);
    1: 
    1:   // Reflow the last batch of content
88016:   if (mBody) {
    1:     SINK_TRACE(gSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:                ("HTMLContentSink::DidBuildModel: layout final content"));
    1:     mCurrentContext->FlushTags();
    1:   } else if (!mLayoutStarted) {
    1:     // We never saw the body, and layout never got started. Force
    1:     // layout *now*, to get an initial reflow.
    1:     SINK_TRACE(gSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:                ("HTMLContentSink::DidBuildModel: forcing reflow on empty "
    1:                 "document"));
    1: 
    1:     // NOTE: only force the layout if we are NOT destroying the
    1:     // docshell. If we are destroying it, then starting layout will
    1:     // likely cause us to crash, or at best waste a lot of time as we
    1:     // are just going to tear it down anyway.
79445:     bool bDestroying = true;
    1:     if (mDocShell) {
    1:       mDocShell->IsBeingDestroyed(&bDestroying);
    1:     }
    1: 
    1:     if (!bDestroying) {
80486:       StartLayout(false);
    1:     }
    1:   }
    1: 
    1:   ScrollToRef();
    1: 
    1:   // Make sure we no longer respond to document mutations.  We've flushed all
    1:   // our notifications out, so there's no need to do anything else here.
    1: 
    1:   // XXXbz I wonder whether we could End() our contexts here too, or something,
28461:   // just to make sure we no longer notify...  Or is the mIsDocumentObserver
28461:   // thing sufficient?
    1:   mDocument->RemoveObserver(this);
80486:   mIsDocumentObserver = false;
    1:   
    1:   mDocument->EndLoad();
    1: 
    1:   DropParserAndPerfHint();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
87806: HTMLContentSink::SetParser(nsParserBase* aParser)
    1: {
  854:   NS_PRECONDITION(aParser, "Should have a parser here!");
    1:   mParser = aParser;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::BeginContext(PRInt32 aPosition)
    1: {
    1:   NS_PRECONDITION(aPosition > -1, "out of bounds");
    1: 
    1:   if (!mCurrentContext) {
42587:     NS_ERROR("Nonexistent context");
    1: 
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Flush everything in the current context so that we don't have
    1:   // to worry about insertions resulting in inconsistent frame creation.
    1:   mCurrentContext->FlushTags();
    1: 
    1:   // Sanity check.
    1:   if (mCurrentContext->mStackPos <= aPosition) {
    1:     NS_ERROR("Out of bounds position");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   PRInt32 insertionPoint = -1;
    1:   nsHTMLTag nodeType      = mCurrentContext->mStack[aPosition].mType;
    1:   nsGenericHTMLElement* content = mCurrentContext->mStack[aPosition].mContent;
    1: 
    1:   // If the content under which the new context is created
    1:   // has a child on the stack, the insertion point is
    1:   // before the last child.
    1:   if (aPosition < (mCurrentContext->mStackPos - 1)) {
    1:     insertionPoint = content->GetChildCount() - 1;
    1:   }
    1: 
63640:   SinkContext* sc = new SinkContext(this);
    1:   sc->Begin(nodeType,
    1:             content,
    1:             mCurrentContext->mStack[aPosition].mNumFlushed,
    1:             insertionPoint);
    1:   NS_ADDREF(sc->mSink);
    1: 
    1:   mContextStack.AppendElement(mCurrentContext);
    1:   mCurrentContext = sc;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::EndContext(PRInt32 aPosition)
    1: {
42587:   NS_PRECONDITION(mCurrentContext && aPosition > -1, "nonexistent context");
    1: 
26413:   PRUint32 n = mContextStack.Length() - 1;
26413:   SinkContext* sc = mContextStack.ElementAt(n);
    1: 
20342:   const SinkContext::Node &bottom = mCurrentContext->mStack[0];
20342:   
20342:   NS_ASSERTION(sc->mStack[aPosition].mType == bottom.mType,
    1:                "ending a wrong context");
    1: 
    1:   mCurrentContext->FlushTextAndRelease();
    1:   
20342:   NS_ASSERTION(bottom.mContent->GetChildCount() == bottom.mNumFlushed,
20342:                "Node at base of context stack not fully flushed.");
20342: 
20342:   // Flushing tags before the assertion on the previous line would
20342:   // undoubtedly prevent the assertion from failing, but it shouldn't
20342:   // be failing anyway, FlushTags or no.  Flushing here is nevertheless
20342:   // a worthwhile precaution, since we lose some information (e.g.,
20342:   // mInsertionPoints) when we end the current context.
20342:   mCurrentContext->FlushTags();
20342: 
20342:   sc->mStack[aPosition].mNumFlushed = bottom.mNumFlushed;
    1: 
    1:   for (PRInt32 i = 0; i<mCurrentContext->mStackPos; i++) {
    1:     NS_IF_RELEASE(mCurrentContext->mStack[i].mContent);
    1:   }
    1: 
    1:   delete [] mCurrentContext->mStack;
    1: 
    1:   mCurrentContext->mStack      = nsnull;
    1:   mCurrentContext->mStackPos   = 0;
    1:   mCurrentContext->mStackSize  = 0;
    1: 
    1:   delete [] mCurrentContext->mText;
    1: 
    1:   mCurrentContext->mText       = nsnull;
    1:   mCurrentContext->mTextLength = 0;
    1:   mCurrentContext->mTextSize   = 0;
    1: 
    1:   NS_IF_RELEASE(mCurrentContext->mSink);
    1: 
    1:   delete mCurrentContext;
    1: 
    1:   mCurrentContext = sc;
    1:   mContextStack.RemoveElementAt(n);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: HTMLContentSink::CloseHTML()
    1: {
    1:   SINK_TRACE_NODE(SINK_TRACE_CALLS,
    1:                  "HTMLContentSink::CloseHTML", 
    1:                  eHTMLTag_html, 0, this);
    1: 
    1:   if (mHeadContext) {
    1:     if (mCurrentContext == mHeadContext) {
26413:       PRUint32 numContexts = mContextStack.Length();
    1: 
    1:       // Pop off the second html context if it's not done earlier
26413:       mCurrentContext = mContextStack.ElementAt(--numContexts);
    1:       mContextStack.RemoveElementAt(numContexts);
    1:     }
    1: 
    1:     NS_ASSERTION(mHeadContext->mTextLength == 0, "Losing text");
    1: 
    1:     mHeadContext->End();
    1: 
    1:     delete mHeadContext;
    1:     mHeadContext = nsnull;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: HTMLContentSink::OpenHead()
    1: {
    1:   nsresult rv = OpenHeadContext();
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: HTMLContentSink::OpenBody(const nsIParserNode& aNode)
    1: {
    1:   SINK_TRACE_NODE(SINK_TRACE_CALLS,
    1:                   "HTMLContentSink::OpenBody", 
    1:                   eHTMLTag_body,
    1:                   mCurrentContext->mStackPos, 
    1:                   this);
    1: 
    1:   CloseHeadContext();  // do this just in case if the HEAD was left open!
    1: 
    1:   // Add attributes, if any, to the current BODY node
    1:   if (mBody) {
80486:     AddAttributes(aNode, mBody, true, true);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv = mCurrentContext->OpenContainer(aNode);
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   mBody = mCurrentContext->mStack[mCurrentContext->mStackPos - 1].mContent;
    1: 
    1:   if (mCurrentContext->mStackPos > 1) {
    1:     PRInt32 parentIndex    = mCurrentContext->mStackPos - 2;
    1:     nsGenericHTMLElement *parent = mCurrentContext->mStack[parentIndex].mContent;
    1:     PRInt32 numFlushed     = mCurrentContext->mStack[parentIndex].mNumFlushed;
    1:     PRInt32 childCount = parent->GetChildCount();
    1:     NS_ASSERTION(numFlushed < childCount, "Already notified on the body?");
    1:     
    1:     PRInt32 insertionPoint =
    1:       mCurrentContext->mStack[parentIndex].mInsertionPoint;
    1: 
    1:     // XXX: I have yet to see a case where numFlushed is non-zero and
    1:     // insertionPoint is not -1, but this code will try to handle
    1:     // those cases too.
    1: 
20484:     PRUint32 oldUpdates = mUpdatesInNotification;
18382:     mUpdatesInNotification = 0;
    1:     if (insertionPoint != -1) {
    1:       NotifyInsert(parent, mBody, insertionPoint - 1);
    1:     } else {
    1:       NotifyAppend(parent, numFlushed);
    1:     }
    1:     mCurrentContext->mStack[parentIndex].mNumFlushed = childCount;
18382:     if (mUpdatesInNotification > 1) {
18382:       UpdateChildCounts();
18382:     }
18382:     mUpdatesInNotification = oldUpdates;
    1:   }
    1: 
80486:   StartLayout(false);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: HTMLContentSink::CloseBody()
    1: {
    1:   SINK_TRACE_NODE(SINK_TRACE_CALLS,
    1:                   "HTMLContentSink::CloseBody", 
    1:                   eHTMLTag_body,
    1:                   mCurrentContext->mStackPos - 1, 
    1:                   this);
    1: 
79445:   bool didFlush;
    1:   nsresult rv = mCurrentContext->FlushTextAndRelease(&didFlush);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // Flush out anything that's left
    1:   SINK_TRACE(gSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:              ("HTMLContentSink::CloseBody: layout final body content"));
    1: 
    1:   mCurrentContext->FlushTags();
88015:   mCurrentContext->CloseContainer(eHTMLTag_body);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: HTMLContentSink::IsEnabled(PRInt32 aTag, bool* aReturn)
    1: {
    1:   nsHTMLTag theHTMLTag = nsHTMLTag(aTag);
    1: 
    1:   if (theHTMLTag == eHTMLTag_script) {
    1:     *aReturn = mScriptEnabled;
    1:   } else if (theHTMLTag == eHTMLTag_frameset) {
    1:     *aReturn = mFramesEnabled;
    1:   } else {
80486:     *aReturn = false;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::OpenContainer(const nsIParserNode& aNode)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   switch (aNode.GetNodeType()) {
    1:     case eHTMLTag_frameset:
88016:       MOZ_NOT_REACHED("Must not use HTMLContentSink for frames.");
88016:       rv = NS_ERROR_NOT_IMPLEMENTED;
    1:       break;
    1:     case eHTMLTag_head:
    1:       rv = OpenHeadContext();
    1:       if (NS_SUCCEEDED(rv)) {
80486:         rv = AddAttributes(aNode, mHead, true, mHaveSeenHead);
80486:         mHaveSeenHead = true;
    1:       }
    1:       break;
    1:     case eHTMLTag_body:
    1:       rv = OpenBody(aNode);
    1:       break;
    1:     case eHTMLTag_html:
    1:       if (mRoot) {
    1:         // If we've already hit this code once, need to check for
    1:         // already-present attributes on the root.
80486:         AddAttributes(aNode, mRoot, true, mNotifiedRootInsertion);
    1:         if (!mNotifiedRootInsertion) {
 6642:           NotifyRootInsertion();
    1:         }
10340:         ProcessOfflineManifest(mRoot);
    1:       }
    1:       break;
    1:     case eHTMLTag_form:
88021:       MOZ_NOT_REACHED("Must not use HTMLContentSink for forms.");
88021:       rv = NS_ERROR_NOT_IMPLEMENTED;
    1:       break;
    1:     default:
    1:       rv = mCurrentContext->OpenContainer(aNode);
    1:       break;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::CloseContainer(const eHTMLTags aTag)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   switch (aTag) {
    1:     case eHTMLTag_frameset:
88016:       MOZ_NOT_REACHED("Must not use HTMLContentSink for frames.");
88016:       rv = NS_ERROR_NOT_IMPLEMENTED;
    1:       break;
    1:     case eHTMLTag_head:
    1:       CloseHeadContext();
    1:       break;
    1:     case eHTMLTag_body:
    1:       rv = CloseBody();
    1:       break;
    1:     case eHTMLTag_html:
    1:       rv = CloseHTML();
    1:       break;
    1:     case eHTMLTag_form:
88021:       MOZ_NOT_REACHED("Must not use HTMLContentSink for forms.");
88021:       rv = NS_ERROR_NOT_IMPLEMENTED;
    1:       break;
    1:     default:
88015:       rv = mCurrentContext->CloseContainer(aTag);
    1:       break;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::CloseMalformedContainer(const eHTMLTags aTag)
    1: {
88015:   return mCurrentContext->CloseContainer(aTag);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::AddLeaf(const nsIParserNode& aNode)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsHTMLTag nodeType = nsHTMLTag(aNode.GetNodeType());
    1:   switch (nodeType) {
    1:   case eHTMLTag_link:
88016:     rv = NS_ERROR_NOT_IMPLEMENTED;
88016:     MOZ_NOT_REACHED("Must not use HTMLContentSink for links.");
    1: 
    1:     break;
    1:   default:
    1:     rv = mCurrentContext->AddLeaf(aNode);
    1: 
    1:     break;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::DidProcessTokens(void)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::WillProcessAToken(void)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::DidProcessAToken(void)
    1: {
    1:   return DidProcessATokenImpl();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::WillInterrupt()
    1: {
    1:   return WillInterruptImpl();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::WillResume()
    1: {
    1:   return WillResumeImpl();
    1: }
    1: 
    1: nsresult
    1: HTMLContentSink::OpenHeadContext()
    1: {
    1:   if (mCurrentContext && mCurrentContext->IsCurrentContainer(eHTMLTag_head))
    1:     return NS_OK;
    1: 
    1:   // Flush everything in the current context so that we don't have
    1:   // to worry about insertions resulting in inconsistent frame creation.
    1:   //
    1:   // Try to do this only if needed (costly), i.e., only if we are sure
    1:   // we are changing contexts from some other context to the head.
    1:   //
    1:   // PERF: This call causes approximately a 2% slowdown in page load time
    1:   // according to jrgm's page load tests, but seems to be a necessary evil
    1:   if (mCurrentContext && (mCurrentContext != mHeadContext)) {
    1:     mCurrentContext->FlushTags();
    1:   }
    1: 
    1:   if (!mHeadContext) {
    1:     mHeadContext = new SinkContext(this);
    1:     NS_ENSURE_TRUE(mHeadContext, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     nsresult rv = mHeadContext->Begin(eHTMLTag_head, mHead, 0, -1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   mContextStack.AppendElement(mCurrentContext);
    1:   mCurrentContext = mHeadContext;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: HTMLContentSink::CloseHeadContext()
    1: {
    1:   if (mCurrentContext) {
    1:     if (!mCurrentContext->IsCurrentContainer(eHTMLTag_head))
    1:       return;
    1: 
    1:     mCurrentContext->FlushTextAndRelease();
26474:     mCurrentContext->FlushTags();
    1:   }
    1: 
26413:   if (!mContextStack.IsEmpty())
26413:   {
26413:     PRUint32 n = mContextStack.Length() - 1;
26413:     mCurrentContext = mContextStack.ElementAt(n);
    1:     mContextStack.RemoveElementAt(n);
    1:   }
26413: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: HTMLContentSink::ForceReflow()
    1: {
    1:   mCurrentContext->FlushTags();
    1: }
    1: #endif
    1: 
    1: void
    1: HTMLContentSink::NotifyInsert(nsIContent* aContent,
    1:                               nsIContent* aChildContent,
    1:                               PRInt32 aIndexInContainer)
    1: {
    1:   if (aContent && aContent->GetCurrentDoc() != mDocument) {
    1:     // aContent is not actually in our document anymore.... Just bail out of
    1:     // here; notifying on our document for this insert would be wrong.
    1:     return;
    1:   }
    1: 
    1:   mInNotification++;
    1: 
    1:   {
    1:     // Scope so we call EndUpdate before we decrease mInNotification
    1:     MOZ_AUTO_DOC_UPDATE(mDocument, UPDATE_CONTENT_MODEL, !mBeganUpdate);
    1:     nsNodeUtils::ContentInserted(NODE_FROM(aContent, mDocument),
    1:                                  aChildContent, aIndexInContainer);
    1:     mLastNotificationTime = PR_Now();
    1:   }
    1: 
    1:   mInNotification--;
    1: }
    1: 
 6642: void
 6642: HTMLContentSink::NotifyRootInsertion()
 6642: {
 6642:   NS_PRECONDITION(!mNotifiedRootInsertion, "Double-notifying on root?");
 6642:   NS_ASSERTION(!mLayoutStarted,
 6642:                "How did we start layout without notifying on root?");
 6642:   // Now make sure to notify that we have now inserted our root.  If
 6642:   // there has been no initial reflow yet it'll be a no-op, but if
 6642:   // there has been one we need this to get its frames constructed.
 6642:   // Note that if mNotifiedRootInsertion is true we don't notify here,
 6642:   // since that just means there are multiple <html> tags in the
 6642:   // document; in those cases we just want to put all the attrs on one
 6642:   // tag.
80486:   mNotifiedRootInsertion = true;
 6642:   PRInt32 index = mDocument->IndexOf(mRoot);
 6642:   NS_ASSERTION(index != -1, "mRoot not child of document?");
 6642:   NotifyInsert(nsnull, mRoot, index);
 6642: 
 6642:   // Now update the notification information in all our
 6642:   // contexts, since we just inserted the root and notified on
 6642:   // our whole tree
 6642:   UpdateChildCounts();
 6642: }
 6642: 
79445: bool
    1: HTMLContentSink::IsMonolithicContainer(nsHTMLTag aTag)
    1: {
    1:   if (aTag == eHTMLTag_tr     ||
    1:       aTag == eHTMLTag_select ||
    1:       aTag == eHTMLTag_applet ||
    1:       aTag == eHTMLTag_object) {
80486:     return true;
    1:   }
    1: 
80486:   return false;
    1: }
    1: 
    1: void
    1: HTMLContentSink::UpdateChildCounts()
    1: {
26413:   PRUint32 numContexts = mContextStack.Length();
26413:   for (PRUint32 i = 0; i < numContexts; i++) {
26413:     SinkContext* sc = mContextStack.ElementAt(i);
    1: 
    1:     sc->UpdateChildCounts();
    1:   }
    1: 
    1:   mCurrentContext->UpdateChildCounts();
    1: }
    1: 
    1: void
    1: HTMLContentSink::FlushPendingNotifications(mozFlushType aType)
    1: {
    1:   // Only flush tags if we're not doing the notification ourselves
    1:   // (since we aren't reentrant)
 6642:   if (!mInNotification) {
28461:     // Only flush if we're still a document observer (so that our child counts
28461:     // should be correct).
28461:     if (mIsDocumentObserver) {
 4886:       if (aType >= Flush_ContentAndNotify) {
 6642:         FlushTags();
 6642:       }
 6642:       else if (mCurrentContext) {
    1:         mCurrentContext->FlushText();
    1:       }
28461:     }
27993:     if (aType >= Flush_InterruptibleLayout) {
    1:       // Make sure that layout has started so that the reflow flush
    1:       // will actually happen.
80486:       StartLayout(true);
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: HTMLContentSink::FlushTags()
    1: {
 6642:   if (!mNotifiedRootInsertion) {
 6642:     NotifyRootInsertion();
 6642:     return NS_OK;
 6642:   }
 6642:   
    1:   return mCurrentContext ? mCurrentContext->FlushTags() : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::SetDocumentCharset(nsACString& aCharset)
    1: {
    1:   if (mDocShell) {
    1:     // the following logic to get muCV is copied from
    1:     // nsHTMLDocument::StartDocumentLoad
    1:     // We need to call muCV->SetPrevDocCharacterSet here in case
    1:     // the charset is detected by parser DetectMetaTag
    1:     nsCOMPtr<nsIMarkupDocumentViewer> muCV;
    1:     nsCOMPtr<nsIContentViewer> cv;
    1:     mDocShell->GetContentViewer(getter_AddRefs(cv));
    1:     if (cv) {
    1:        muCV = do_QueryInterface(cv);
    1:     } else {
    1:       // in this block of code, if we get an error result, we return
    1:       // it but if we get a null pointer, that's perfectly legal for
    1:       // parent and parentContentViewer
    1: 
    1:       nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
    1:         do_QueryInterface(mDocShell);
    1:       NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
    1: 
    1:       nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
    1:       docShellAsItem->GetSameTypeParent(getter_AddRefs(parentAsItem));
    1: 
    1:       nsCOMPtr<nsIDocShell> parent(do_QueryInterface(parentAsItem));
    1:       if (parent) {
    1:         nsCOMPtr<nsIContentViewer> parentContentViewer;
    1:         nsresult rv =
    1:           parent->GetContentViewer(getter_AddRefs(parentContentViewer));
    1:         if (NS_SUCCEEDED(rv) && parentContentViewer) {
    1:           muCV = do_QueryInterface(parentContentViewer);
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (muCV) {
    1:       muCV->SetPrevDocCharacterSet(aCharset);
    1:     }
    1:   }
    1: 
    1:   if (mDocument) {
    1:     mDocument->SetDocumentCharacterSet(aCharset);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsISupports *
    1: HTMLContentSink::GetTarget()
    1: {
    1:   return mDocument;
    1: }
    1: 
79445: bool
27387: HTMLContentSink::IsScriptExecuting()
27387: {
27387:   return IsScriptExecutingImpl();
27387: }
27387: 
    1: #ifdef DEBUG
    1: /**
    1:  *  This will dump content model into the output file.
    1:  *
    1:  *  @update  harishd 05/25/00
    1:  *  @param
    1:  *  @return  NS_OK all went well, error on failure
    1:  */
    1: 
    1: NS_IMETHODIMP
    1: HTMLContentSink::DumpContentModel()
    1: {
    1:   FILE* out = ::fopen("rtest_html.txt", "a");
    1:   if (out) {
    1:     if (mDocument) {
41634:       Element* root = mDocument->GetRootElement();
    1:       if (root) {
    1:         if (mDocumentURI) {
    1:           nsCAutoString buf;
    1:           mDocumentURI->GetSpec(buf);
    1:           fputs(buf.get(), out);
    1:         }
    1: 
    1:         fputs(";", out);
80486:         root->DumpContent(out, 0, false);
    1:         fputs(";\n", out);
    1:       }
    1:     }
    1: 
    1:     fclose(out);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
