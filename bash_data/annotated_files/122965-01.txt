     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 80467: #include "mozilla/Util.h"
 80467: 
 87729: #include "mozilla/layers/CompositorChild.h"
 87729: #include "mozilla/layers/CompositorParent.h"
     1: #include "nsBaseWidget.h"
 68668: #include "nsDeviceContext.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsGfxCIID.h"
     1: #include "nsWidgetsCID.h"
     1: #include "nsServiceManagerUtils.h"
     1: #include "nsIScreenManager.h"
     1: #include "nsAppDirectoryServiceDefs.h"
     1: #include "nsISimpleEnumerator.h"
  8591: #include "nsIContent.h"
     1: #include "nsIServiceManager.h"
 70337: #include "mozilla/Preferences.h"
 38805: #include "BasicLayers.h"
 40028: #include "LayerManagerOGL.h"
 51658: #include "nsIXULRuntime.h"
108454: #include "nsIXULWindow.h"
108456: #include "nsIBaseWindow.h"
120177: #include "nsXULPopupManager.h"
108452: #include "nsEventStateManager.h"
108457: #include "nsIWidgetListener.h"
 60833: #include "nsIGfxInfo.h"
 61041: #include "npapi.h"
 87729: #include "base/thread.h"
 99109: #include "prenv.h"
102309: #include "mozilla/Attributes.h"
 33016: 
108454: #ifdef ACCESSIBILITY
108454: #include "nsAccessibilityService.h"
108454: #endif
108454: 
 33016: #ifdef DEBUG
     1: #include "nsIObserver.h"
     1: 
     1: static void debug_RegisterPrefCallbacks();
     1: 
 79445: static bool debug_InSecureKeyboardInputMode = false;
     1: #endif
     1: 
     1: #ifdef NOISY_WIDGET_LEAKS
108991: static int32_t gNumWidgets;
     1: #endif
     1: 
120177: nsIRollupListener* nsBaseWidget::gRollupListener = nullptr;
120177: 
 38805: using namespace mozilla::layers;
 70337: using namespace mozilla;
 87729: using base::Thread;
 87729: using mozilla::ipc::AsyncChannel;
 38805: 
106838: nsIContent* nsBaseWidget::mLastRollup = nullptr;
 98504: // Global user preference for disabling native theme. Used
 98504: // in NativeWindowTheme.
 98504: bool            gDisableNativeTheme               = false;
  8591: 
     1: // nsBaseWidget
     1: NS_IMPL_ISUPPORTS1(nsBaseWidget, nsIWidget)
     1: 
     1: 
  8591: nsAutoRollup::nsAutoRollup()
  8591: {
  8591:   // remember if mLastRollup was null, and only clear it upon destruction
  8591:   // if so. This prevents recursive usage of nsAutoRollup from clearing
  8591:   // mLastRollup when it shouldn't.
  8591:   wasClear = !nsBaseWidget::mLastRollup;
  8591: }
  8591: 
  8591: nsAutoRollup::~nsAutoRollup()
  8591: {
  8591:   if (nsBaseWidget::mLastRollup && wasClear) {
  8591:     NS_RELEASE(nsBaseWidget::mLastRollup);
  8591:   }
  8591: }
  8591: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // nsBaseWidget constructor
     1: //
     1: //-------------------------------------------------------------------------
     1: 
     1: nsBaseWidget::nsBaseWidget()
108457: : mWidgetListener(nullptr)
108461: , mAttachedWidgetListener(nullptr)
106838: , mContext(nullptr)
     1: , mCursor(eCursor_standard)
     1: , mWindowType(eWindowType_child)
     1: , mBorderStyle(eBorderStyle_none)
122281: , mUseLayersAcceleration(false)
 91135: , mForceLayersAcceleration(false)
 80486: , mTemporarilyUseBasicLayerManager(false)
108460: , mUseAttachedEvents(false)
115495: , mContextInitialized(false)
     1: , mBounds(0,0,0,0)
106838: , mOriginalBounds(nullptr)
 30515: , mClipRectCount(0)
     1: , mZIndex(0)
     1: , mSizeMode(nsSizeMode_Normal)
 48254: , mPopupLevel(ePopupLevelTop)
102628: , mPopupType(ePopupTypeAny)
     1: {
     1: #ifdef NOISY_WIDGET_LEAKS
     1:   gNumWidgets++;
     1:   printf("WIDGETS+ = %d\n", gNumWidgets);
     1: #endif
     1: 
     1: #ifdef DEBUG
     1:   debug_RegisterPrefCallbacks();
     1: #endif
     1: }
     1: 
     1: 
 99223: static void DeferredDestroyCompositor(CompositorParent* aCompositorParent,
104549:                               CompositorChild* aCompositorChild)
 94488: {
 94488:     aCompositorChild->Destroy();
 94488:     aCompositorParent->Release();
 94488:     aCompositorChild->Release();
 94488: }
 94488: 
 99223: void nsBaseWidget::DestroyCompositor() 
 99223: {
 99223:   if (mCompositorChild) {
 99223:     mCompositorChild->SendWillStop();
 99223: 
 99223:     // The call just made to SendWillStop can result in IPC from the
 99223:     // CompositorParent to the CompositorChild (e.g. caused by the destruction
 99223:     // of shared memory). We need to ensure this gets processed by the
 99223:     // CompositorChild before it gets destroyed. It suffices to ensure that
 99223:     // events already in the MessageLoop get processed before the
 99223:     // CompositorChild is destroyed, so we add a task to the MessageLoop to
 99223:     // handle compositor desctruction.
 99223:     MessageLoop::current()->PostTask(FROM_HERE,
 99223:                NewRunnableFunction(DeferredDestroyCompositor, mCompositorParent,
104549:                                    mCompositorChild));
 99223:     // The DestroyCompositor task we just added to the MessageLoop will handle
 99223:     // releasing mCompositorParent and mCompositorChild.
 99223:     mCompositorParent.forget();
 99223:     mCompositorChild.forget();
 99223:   }
 99223: }
 94488: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // nsBaseWidget destructor
     1: //
     1: //-------------------------------------------------------------------------
     1: nsBaseWidget::~nsBaseWidget()
     1: {
 47767:   if (mLayerManager &&
105710:       mLayerManager->GetBackendType() == LAYERS_BASIC) {
 47767:     static_cast<BasicLayerManager*>(mLayerManager.get())->ClearRetainerWidget();
 47767:   }
 47767: 
 58810:   if (mLayerManager) {
 58810:     mLayerManager->Destroy();
106838:     mLayerManager = nullptr;
 87729:   }
 87729: 
 99223:   DestroyCompositor();
 58810: 
     1: #ifdef NOISY_WIDGET_LEAKS
     1:   gNumWidgets--;
     1:   printf("WIDGETS- = %d\n", gNumWidgets);
     1: #endif
     1: 
     1:   NS_IF_RELEASE(mContext);
     1:   delete mOriginalBounds;
     1: }
     1: 
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Basic create.
     1: //
     1: //-------------------------------------------------------------------------
     1: void nsBaseWidget::BaseCreate(nsIWidget *aParent,
 23738:                               const nsIntRect &aRect,
 68668:                               nsDeviceContext *aContext,
     1:                               nsWidgetInitData *aInitData)
     1: {
 98504:   static bool gDisableNativeThemeCached = false;
 98504:   if (!gDisableNativeThemeCached) {
105601:     Preferences::AddBoolVarCache(&gDisableNativeTheme,
 98504:                                  "mozilla.widget.disable-native-theme",
 98504:                                  gDisableNativeTheme);
 98504:     gDisableNativeThemeCached = true;
 98504:   }
 98504: 
     1:   // keep a reference to the device context
     1:   if (aContext) {
     1:     mContext = aContext;
     1:     NS_ADDREF(mContext);
     1:   }
     1:   else {
 68667:     mContext = new nsDeviceContext();
 68667:     NS_ADDREF(mContext);
106838:     mContext->Init(nullptr);
     1:   }
     1: 
106838:   if (nullptr != aInitData) {
 33357:     mWindowType = aInitData->mWindowType;
 33357:     mBorderStyle = aInitData->mBorderStyle;
 48254:     mPopupLevel = aInitData->mPopupLevel;
102628:     mPopupType = aInitData->mPopupHint;
     1:   }
     1: 
     1:   if (aParent) {
     1:     aParent->AddChild(this);
     1:   }
     1: }
     1: 
 79445: NS_IMETHODIMP nsBaseWidget::CaptureMouse(bool aCapture)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Accessor functions to get/set the client data
     1: //
     1: //-------------------------------------------------------------------------
     1: 
108457: nsIWidgetListener* nsBaseWidget::GetWidgetListener()
     1: {
108457:   return mWidgetListener;
     1: }
     1: 
108457: void nsBaseWidget::SetWidgetListener(nsIWidgetListener* aWidgetListener)
     1: {
108457:   mWidgetListener = aWidgetListener;
     1: }
     1: 
 51049: already_AddRefed<nsIWidget>
 51049: nsBaseWidget::CreateChild(const nsIntRect  &aRect,
 68668:                           nsDeviceContext *aContext,
 51049:                           nsWidgetInitData *aInitData,
 79445:                           bool             aForceUseIWidgetParent)
 51049: {
 51049:   nsIWidget* parent = this;
106838:   nsNativeWidget nativeParent = nullptr;
 51049: 
 51049:   if (!aForceUseIWidgetParent) {
 51049:     // Use only either parent or nativeParent, not both, to match
 51049:     // existing code.  Eventually Create() should be divested of its
 51049:     // nativeWidget parameter.
106838:     nativeParent = parent ? parent->GetNativeData(NS_NATIVE_WIDGET) : nullptr;
106838:     parent = nativeParent ? nullptr : parent;
 51049:     NS_ABORT_IF_FALSE(!parent || !nativeParent, "messed up logic");
 51049:   }
 51049: 
 51049:   nsCOMPtr<nsIWidget> widget;
 51049:   if (aInitData && aInitData->mWindowType == eWindowType_popup) {
 51049:     widget = AllocateChildPopupWidget();
 51049:   } else {
 51049:     static NS_DEFINE_IID(kCChildCID, NS_CHILD_CID);
 51049:     widget = do_CreateInstance(kCChildCID);
 51049:   }
 51049: 
 51049:   if (widget &&
 51049:       NS_SUCCEEDED(widget->Create(parent, nativeParent, aRect,
 80842:                                   aContext, aInitData))) {
 51049:     return widget.forget();
 51049:   }
 51049: 
106838:   return nullptr;
 51049: }
 51049: 
 46192: // Attach a view to our widget which we'll send events to. 
 46192: NS_IMETHODIMP
108460: nsBaseWidget::AttachViewToTopLevel(bool aUseAttachedEvents,
 68668:                                    nsDeviceContext *aContext)
 46192: {
 52189:   NS_ASSERTION((mWindowType == eWindowType_toplevel ||
 52189:                 mWindowType == eWindowType_dialog ||
 62248:                 mWindowType == eWindowType_invisible ||
 62248:                 mWindowType == eWindowType_child),
 62248:                "Can't attach to window of that type");
 46192: 
108460:   mUseAttachedEvents = aUseAttachedEvents;
 46192: 
 46192:   if (aContext) {
 46192:     if (mContext) {
 46192:       NS_IF_RELEASE(mContext);
 46192:     }
 46192:     mContext = aContext;
 46192:     NS_ADDREF(mContext);
 46192:   }
 46192: 
 46192:   return NS_OK;
 46192: }
 46192: 
108461: nsIWidgetListener* nsBaseWidget::GetAttachedWidgetListener()
 46192:  {
108461:    return mAttachedWidgetListener;
 46192:  }
 46192:  
108461: void nsBaseWidget::SetAttachedWidgetListener(nsIWidgetListener* aListener)
 46192:  {
108461:    mAttachedWidgetListener = aListener;
 46192:  }
 46192: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Close this nsBaseWidget
     1: //
     1: //-------------------------------------------------------------------------
     1: NS_METHOD nsBaseWidget::Destroy()
     1: {
     1:   // Just in case our parent is the only ref to us
     1:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
     1:   // disconnect from the parent
     1:   nsIWidget *parent = GetParent();
     1:   if (parent) {
     1:     parent->RemoveChild(this);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Set this nsBaseWidget's parent
     1: //
     1: //-------------------------------------------------------------------------
     1: NS_IMETHODIMP nsBaseWidget::SetParent(nsIWidget* aNewParent)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Get this nsBaseWidget parent
     1: //
     1: //-------------------------------------------------------------------------
     1: nsIWidget* nsBaseWidget::GetParent(void)
     1: {
106838:   return nullptr;
     1: }
     1: 
     1: //-------------------------------------------------------------------------
     1: //
 19295: // Get this nsBaseWidget top level widget
 19295: //
 19295: //-------------------------------------------------------------------------
 31093: nsIWidget* nsBaseWidget::GetTopLevelWidget()
 19295: {
106838:   nsIWidget *topLevelWidget = nullptr, *widget = this;
 19295:   while (widget) {
 19295:     topLevelWidget = widget;
 19295:     widget = widget->GetParent();
 19295:   }
 19295:   return topLevelWidget;
 19295: }
 19295: 
 19295: //-------------------------------------------------------------------------
 19295: //
 14886: // Get this nsBaseWidget's top (non-sheet) parent (if it's a sheet)
 14886: //
 14886: //-------------------------------------------------------------------------
 14886: nsIWidget* nsBaseWidget::GetSheetWindowParent(void)
 14886: {
106838:   return nullptr;
 14886: }
 14886: 
 50782: float nsBaseWidget::GetDPI()
 50782: {
 50782:   return 96.0f;
 50782: }
 50782: 
120488: double nsIWidget::GetDefaultScale()
 50782: {
120488:   // The number of device pixels per CSS pixel. A value <= 0 means choose
120488:   // automatically based on the DPI. A positive value is used as-is. This effectively
120488:   // controls the size of a CSS "px".
120488:   float devPixelsPerCSSPixel = -1.0;
120488: 
120488:   nsAdoptingCString prefString = Preferences::GetCString("layout.css.devPixelsPerPx");
120488:   if (!prefString.IsEmpty()) {
120488:     devPixelsPerCSSPixel = static_cast<float>(atof(prefString));
120488:   }
120488: 
120488:   if (devPixelsPerCSSPixel <= 0) {
120488:     devPixelsPerCSSPixel = GetDefaultScaleInternal();
120488:   }
120488: 
120488:   return devPixelsPerCSSPixel;
 50782: }
 50782: 
 14886: //-------------------------------------------------------------------------
 14886: //
     1: // Add a child to the list of children
     1: //
     1: //-------------------------------------------------------------------------
     1: void nsBaseWidget::AddChild(nsIWidget* aChild)
     1: {
     1:   NS_PRECONDITION(!aChild->GetNextSibling() && !aChild->GetPrevSibling(),
     1:                   "aChild not properly removed from its old child list");
     1:   
     1:   if (!mFirstChild) {
     1:     mFirstChild = mLastChild = aChild;
     1:   } else {
     1:     // append to the list
     1:     NS_ASSERTION(mLastChild, "Bogus state");
     1:     NS_ASSERTION(!mLastChild->GetNextSibling(), "Bogus state");
     1:     mLastChild->SetNextSibling(aChild);
     1:     aChild->SetPrevSibling(mLastChild);
     1:     mLastChild = aChild;
     1:   }
     1: }
     1: 
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Remove a child from the list of children
     1: //
     1: //-------------------------------------------------------------------------
     1: void nsBaseWidget::RemoveChild(nsIWidget* aChild)
     1: {
     1:   NS_ASSERTION(aChild->GetParent() == this, "Not one of our kids!");
     1:   
     1:   if (mLastChild == aChild) {
     1:     mLastChild = mLastChild->GetPrevSibling();
     1:   }
     1:   if (mFirstChild == aChild) {
     1:     mFirstChild = mFirstChild->GetNextSibling();
     1:   }
     1: 
     1:   // Now remove from the list.  Make sure that we pass ownership of the tail
     1:   // of the list correctly before we have aChild let go of it.
     1:   nsIWidget* prev = aChild->GetPrevSibling();
     1:   nsIWidget* next = aChild->GetNextSibling();
     1:   if (prev) {
     1:     prev->SetNextSibling(next);
     1:   }
     1:   if (next) {
     1:     next->SetPrevSibling(prev);
     1:   }
     1:   
106838:   aChild->SetNextSibling(nullptr);
106838:   aChild->SetPrevSibling(nullptr);
     1: }
     1: 
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Sets widget's position within its parent's child list.
     1: //
     1: //-------------------------------------------------------------------------
108991: NS_IMETHODIMP nsBaseWidget::SetZIndex(int32_t aZIndex)
     1: {
     1:   // Hold a ref to ourselves just in case, since we're going to remove
     1:   // from our parent.
     1:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
     1:   
     1:   mZIndex = aZIndex;
     1: 
     1:   // reorder this child in its parent's list.
  3233:   nsBaseWidget* parent = static_cast<nsBaseWidget*>(GetParent());
     1:   if (parent) {
     1:     parent->RemoveChild(this);
     1:     // Scope sib outside the for loop so we can check it afterward
     1:     nsIWidget* sib = parent->GetFirstChild();
     1:     for ( ; sib; sib = sib->GetNextSibling()) {
108991:       int32_t childZIndex;
     1:       if (NS_SUCCEEDED(sib->GetZIndex(&childZIndex))) {
     1:         if (aZIndex < childZIndex) {
     1:           // Insert ourselves before sib
     1:           nsIWidget* prev = sib->GetPrevSibling();
     1:           mNextSibling = sib;
     1:           mPrevSibling = prev;
     1:           sib->SetPrevSibling(this);
     1:           if (prev) {
     1:             prev->SetNextSibling(this);
     1:           } else {
     1:             NS_ASSERTION(sib == parent->mFirstChild, "Broken child list");
     1:             // We've taken ownership of sib, so it's safe to have parent let
     1:             // go of it
     1:             parent->mFirstChild = this;
     1:           }
 80486:           PlaceBehind(eZPlacementBelow, sib, false);
     1:           break;
     1:         }
     1:       }
     1:     }
     1:     // were we added to the list?
     1:     if (!sib) {
     1:       parent->AddChild(this);
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Gets widget's position within its parent's child list.
     1: //
     1: //-------------------------------------------------------------------------
108991: NS_IMETHODIMP nsBaseWidget::GetZIndex(int32_t* aZIndex)
     1: {
     1:   *aZIndex = mZIndex;
     1:   return NS_OK;
     1: }
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Places widget behind the given widget (platforms must override)
     1: //
     1: //-------------------------------------------------------------------------
     1: NS_IMETHODIMP nsBaseWidget::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
 79445:                                         nsIWidget *aWidget, bool aActivate)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Maximize, minimize or restore the window. The BaseWidget implementation
     1: // merely stores the state.
     1: //
     1: //-------------------------------------------------------------------------
108991: NS_IMETHODIMP nsBaseWidget::SetSizeMode(int32_t aMode)
 51547: {
 30075:   if (aMode == nsSizeMode_Normal ||
 30075:       aMode == nsSizeMode_Minimized ||
 30075:       aMode == nsSizeMode_Maximized ||
 30075:       aMode == nsSizeMode_Fullscreen) {
     1: 
     1:     mSizeMode = (nsSizeMode) aMode;
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_ILLEGAL_VALUE;
     1: }
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Get the size mode (minimized, maximized, that sort of thing...)
     1: //
     1: //-------------------------------------------------------------------------
108991: NS_IMETHODIMP nsBaseWidget::GetSizeMode(int32_t* aMode)
 51547: {
     1:   *aMode = mSizeMode;
     1:   return NS_OK;
     1: }
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Get the foreground color
     1: //
     1: //-------------------------------------------------------------------------
     1: nscolor nsBaseWidget::GetForegroundColor(void)
     1: {
     1:   return mForeground;
     1: }
     1: 
     1:     
     1: //-------------------------------------------------------------------------
     1: //
     1: // Set the foreground color
     1: //
     1: //-------------------------------------------------------------------------
     1: NS_METHOD nsBaseWidget::SetForegroundColor(const nscolor &aColor)
     1: {
     1:   mForeground = aColor;
     1:   return NS_OK;
     1: }
     1: 
     1:     
     1: //-------------------------------------------------------------------------
     1: //
     1: // Get the background color
     1: //
     1: //-------------------------------------------------------------------------
     1: nscolor nsBaseWidget::GetBackgroundColor(void)
     1: {
     1:   return mBackground;
     1: }
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Set the background color
     1: //
     1: //-------------------------------------------------------------------------
     1: NS_METHOD nsBaseWidget::SetBackgroundColor(const nscolor &aColor)
     1: {
     1:   mBackground = aColor;
     1:   return NS_OK;
     1: }
     1:      
     1: //-------------------------------------------------------------------------
     1: //
     1: // Get this component cursor
     1: //
     1: //-------------------------------------------------------------------------
     1: nsCursor nsBaseWidget::GetCursor()
     1: {
     1:   return mCursor;
     1: }
     1: 
     1: NS_METHOD nsBaseWidget::SetCursor(nsCursor aCursor)
     1: {
     1:   mCursor = aCursor; 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsBaseWidget::SetCursor(imgIContainer* aCursor,
108991:                                       uint32_t aHotspotX, uint32_t aHotspotY)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1:     
     1: //-------------------------------------------------------------------------
     1: //
     1: // Get the window type for this widget
     1: //
     1: //-------------------------------------------------------------------------
     1: NS_IMETHODIMP nsBaseWidget::GetWindowType(nsWindowType& aWindowType)
     1: {
     1:   aWindowType = mWindowType;
     1:   return NS_OK;
     1: }
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Window transparency methods
     1: //
     1: //-------------------------------------------------------------------------
     1: 
 16601: void nsBaseWidget::SetTransparencyMode(nsTransparencyMode aMode) {
     1: }
     1: 
 16601: nsTransparencyMode nsBaseWidget::GetTransparencyMode() {
 16601:   return eTransparencyOpaque;
     1: }
     1: 
 79445: bool
 30515: nsBaseWidget::StoreWindowClipRegion(const nsTArray<nsIntRect>& aRects)
 30515: {
 30688:   if (mClipRects && mClipRectCount == aRects.Length() &&
 30688:       memcmp(mClipRects, aRects.Elements(), sizeof(nsIntRect)*mClipRectCount) == 0)
 80486:     return false;
 30688: 
 30515:   mClipRectCount = aRects.Length();
 30515:   mClipRects = new nsIntRect[mClipRectCount];
 30515:   if (mClipRects) {
 30515:     memcpy(mClipRects, aRects.Elements(), sizeof(nsIntRect)*mClipRectCount);
 30515:   }
 80486:   return true;
 30515: }
 30515: 
 30515: void
 30515: nsBaseWidget::GetWindowClipRegion(nsTArray<nsIntRect>* aRects)
 30515: {
 30515:   if (mClipRects) {
 30515:     aRects->AppendElements(mClipRects.get(), mClipRectCount);
 30515:   } else {
 30515:     aRects->AppendElement(nsIntRect(0, 0, mBounds.width, mBounds.height));
 30515:   }
 30515: }
 30515: 
     1: //-------------------------------------------------------------------------
     1: //
 20467: // Set window shadow style
 20467: //
 20467: //-------------------------------------------------------------------------
 20467: 
108991: NS_IMETHODIMP nsBaseWidget::SetWindowShadowStyle(int32_t aMode)
 20467: {
 20467:   return NS_ERROR_NOT_IMPLEMENTED;
 20467: }
 20467: 
 20467: //-------------------------------------------------------------------------
 20467: //
     1: // Hide window borders/decorations for this widget
     1: //
     1: //-------------------------------------------------------------------------
 79445: NS_IMETHODIMP nsBaseWidget::HideWindowChrome(bool aShouldHide)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Put the window into full-screen mode
     1: //
     1: //-------------------------------------------------------------------------
 79445: NS_IMETHODIMP nsBaseWidget::MakeFullScreen(bool aFullScreen)
     1: {
 30004:   HideWindowChrome(aFullScreen);
 29944: 
     1:   if (aFullScreen) {
     1:     if (!mOriginalBounds)
 23738:       mOriginalBounds = new nsIntRect();
     1:     GetScreenBounds(*mOriginalBounds);
     1: 
     1:     // Move to top-left corner of screen and size to the screen dimensions
     1:     nsCOMPtr<nsIScreenManager> screenManager;
     1:     screenManager = do_GetService("@mozilla.org/gfx/screenmanager;1"); 
     1:     NS_ASSERTION(screenManager, "Unable to grab screenManager.");
     1:     if (screenManager) {
     1:       nsCOMPtr<nsIScreen> screen;
119098:       // convert dev pix to display/CSS pix for ScreenForRect
119098:       double scale = GetDefaultScale();
119098:       screenManager->ScreenForRect(mOriginalBounds->x / scale,
119098:                                    mOriginalBounds->y / scale,
119098:                                    mOriginalBounds->width / scale,
119098:                                    mOriginalBounds->height / scale,
     1:                                    getter_AddRefs(screen));
     1:       if (screen) {
108991:         int32_t left, top, width, height;
     1:         if (NS_SUCCEEDED(screen->GetRect(&left, &top, &width, &height))) {
 80486:           Resize(left, top, width, height, true);
     1:         }
     1:       }
     1:     }
     1: 
     1:   } else if (mOriginalBounds) {
     1:     Resize(mOriginalBounds->x, mOriginalBounds->y, mOriginalBounds->width,
 80486:            mOriginalBounds->height, true);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 38805: nsBaseWidget::AutoLayerManagerSetup::AutoLayerManagerSetup(
 47746:     nsBaseWidget* aWidget, gfxContext* aTarget,
106914:     BufferMode aDoubleBuffering, ScreenRotation aRotation)
 38805:   : mWidget(aWidget)
 38805: {
 38805:   BasicLayerManager* manager =
 63893:     static_cast<BasicLayerManager*>(mWidget->GetLayerManager());
 38805:   if (manager) {
105710:     NS_ASSERTION(manager->GetBackendType() == LAYERS_BASIC,
 40028:       "AutoLayerManagerSetup instantiated for non-basic layer backend!");
108348:     manager->SetDefaultTarget(aTarget);
108348:     manager->SetDefaultTargetConfiguration(aDoubleBuffering, aRotation);
 38805:   }
 38805: }
 38805: 
 38805: nsBaseWidget::AutoLayerManagerSetup::~AutoLayerManagerSetup()
 38805: {
 38805:   BasicLayerManager* manager =
 63893:     static_cast<BasicLayerManager*>(mWidget->GetLayerManager());
 38805:   if (manager) {
105710:     NS_ASSERTION(manager->GetBackendType() == LAYERS_BASIC,
 40028:       "AutoLayerManagerSetup instantiated for non-basic layer backend!");
108348:     manager->SetDefaultTarget(nullptr);
108348:     manager->SetDefaultTargetConfiguration(mozilla::layers::BUFFER_NONE, ROTATION_0);
 38805:   }
 38805: }
 38805: 
 55858: nsBaseWidget::AutoUseBasicLayerManager::AutoUseBasicLayerManager(nsBaseWidget* aWidget)
 55858:   : mWidget(aWidget)
 55858: {
122965:   mPreviousTemporarilyUseBasicLayerManager =
122965:     mWidget->mTemporarilyUseBasicLayerManager;
 80486:   mWidget->mTemporarilyUseBasicLayerManager = true;
 55858: }
 55858: 
 55858: nsBaseWidget::AutoUseBasicLayerManager::~AutoUseBasicLayerManager()
 55858: {
122965:   mWidget->mTemporarilyUseBasicLayerManager =
122965:     mPreviousTemporarilyUseBasicLayerManager;
 55858: }
 55858: 
 79445: bool
122281: nsBaseWidget::ComputeShouldAccelerate(bool aDefault)
 38805: {
110791: #if defined(XP_WIN) || defined(ANDROID) || (MOZ_PLATFORM_MAEMO > 5) || \
110791:     defined(MOZ_GL_PROVIDER) || defined(XP_MACOSX)
 79445:   bool accelerateByDefault = true;
 60324: #else
 79445:   bool accelerateByDefault = false;
 60324: #endif
 51655: 
102628:   // We don't want to accelerate small popup windows like menu, but we still 
102628:   // want to accelerate xul panels that may contain arbitrarily complex content.
102628:   bool isSmallPopup = ((mWindowType == eWindowType_popup) && 
102628:                       (mPopupType != ePopupTypePanel));
 60324:   // we should use AddBoolPrefVarCache
102628:   bool disableAcceleration = isSmallPopup || 
 79445:     Preferences::GetBool("layers.acceleration.disabled", false);
 91135:   mForceLayersAcceleration =
 79445:     Preferences::GetBool("layers.acceleration.force-enabled", false);
 42226: 
 51978:   const char *acceleratedEnv = PR_GetEnv("MOZ_ACCELERATED");
 51978:   accelerateByDefault = accelerateByDefault ||
 51978:                         (acceleratedEnv && (*acceleratedEnv != '0'));
 51978: 
 51658:   nsCOMPtr<nsIXULRuntime> xr = do_GetService("@mozilla.org/xre/runtime;1");
 79445:   bool safeMode = false;
 51658:   if (xr)
 51658:     xr->GetInSafeMode(&safeMode);
 51658: 
 76848:   bool whitelisted = false;
 76848: 
 76848:   nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
 76848:   if (gfxInfo) {
 78440:     // bug 655578: on X11 at least, we must always call GetData (even if we don't need that information)
 78440:     // as that's what causes GfxInfo initialization which kills the zombie 'glxtest' process.
 78440:     // initially we relied on the fact that GetFeatureStatus calls GetData for us, but bug 681026 showed
 78440:     // that assumption to be unsafe.
 78440:     gfxInfo->GetData();
 78440: 
108991:     int32_t status;
 76848:     if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_OPENGL_LAYERS, &status))) {
 76848:       if (status == nsIGfxInfo::FEATURE_NO_INFO) {
 76848:         whitelisted = true;
 76848:       }
 76848:     }
 76848:   }
 76848: 
 51658:   if (disableAcceleration || safeMode)
 80486:     return false;
 53686: 
 91135:   if (mForceLayersAcceleration)
 80486:     return true;
 60833:   
 76848:   if (!whitelisted) {
 60833:     NS_WARNING("OpenGL-accelerated layers are not supported on this system.");
115717: #ifdef MOZ_ANDROID_OMTC
103693:     NS_RUNTIMEABORT("OpenGL-accelerated layers are a hard requirement on this platform. "
103693:                     "Cannot continue without support for them.");
103693: #endif
 80486:     return false;
 60833:   }
 60833: 
 60833:   if (accelerateByDefault)
 80486:     return true;
 53686: 
 60324:   /* use the window acceleration flag */
122281:   return aDefault;
 53686: }
 53686: 
 87729: void nsBaseWidget::CreateCompositor()
 87729: {
 98069:   bool renderToEGLSurface = false;
115717: #ifdef MOZ_ANDROID_OMTC
 98069:   renderToEGLSurface = true;
 98069: #endif
 98069:   nsIntRect rect;
 98069:   GetBounds(rect);
 98069:   mCompositorParent =
104549:     new CompositorParent(this, renderToEGLSurface, rect.width, rect.height);
 87729:   LayerManager* lm = CreateBasicLayerManager();
104549:   MessageLoop *childMessageLoop = CompositorParent::CompositorLoop();
 87729:   mCompositorChild = new CompositorChild(lm);
 87729:   AsyncChannel *parentChannel = mCompositorParent->GetIPCChannel();
 87729:   AsyncChannel::Side childSide = mozilla::ipc::AsyncChannel::Child;
 87729:   mCompositorChild->Open(parentChannel, childMessageLoop, childSide);
108991:   int32_t maxTextureSize;
101912:   PLayersChild* shadowManager;
105710:   mozilla::layers::LayersBackend backendHint =
122281:     mUseLayersAcceleration ? mozilla::layers::LAYERS_OPENGL : mozilla::layers::LAYERS_BASIC;
105710:   mozilla::layers::LayersBackend parentBackend;
105604:   shadowManager = mCompositorChild->SendPLayersConstructor(
105604:     backendHint, 0, &parentBackend, &maxTextureSize);
 87729: 
 87729:   if (shadowManager) {
 87729:     ShadowLayerForwarder* lf = lm->AsShadowForwarder();
 87729:     if (!lf) {
 87729:       delete lm;
106838:       mCompositorChild = nullptr;
 89233:       return;
 87729:     }
 87729:     lf->SetShadowManager(shadowManager);
105604:     lf->SetParentBackendType(parentBackend);
 99140:     lf->SetMaxTextureSize(maxTextureSize);
 87729: 
 87729:     mLayerManager = lm;
 87729:   } else {
 99949:     // We don't currently want to support not having a LayersChild
 99949:     NS_RUNTIMEABORT("failed to construct LayersChild");
 87729:     delete lm;
106838:     mCompositorChild = nullptr;
 87729:   }
 87729: }
 87729: 
 99109: bool nsBaseWidget::UseOffMainThreadCompositing()
 99109: {
103820:   bool isSmallPopup = ((mWindowType == eWindowType_popup) && 
103820:                       (mPopupType != ePopupTypePanel));
104549:   return CompositorParent::CompositorLoop() && !isSmallPopup;
 99109: }
 99109: 
 75149: LayerManager* nsBaseWidget::GetLayerManager(PLayersChild* aShadowManager,
 75149:                                             LayersBackend aBackendHint,
 75149:                                             LayerManagerPersistence aPersistence,
 58812:                                             bool* aAllowRetaining)
 58812: {
 53686:   if (!mLayerManager) {
 53686: 
122281:     mUseLayersAcceleration = ComputeShouldAccelerate(mUseLayersAcceleration);
 51655: 
 87729:     // Try to use an async compositor first, if possible
 99109:     if (UseOffMainThreadCompositing()) {
 87729:       // e10s uses the parameter to pass in the shadow manager from the TabChild
 87729:       // so we don't expect to see it there since this doesn't support e10s.
106838:       NS_ASSERTION(aShadowManager == nullptr, "Async Compositor not supported with e10s");
 87729:       CreateCompositor();
 87729:     }
 87729: 
122281:     if (mUseLayersAcceleration) {
 87729:       if (!mLayerManager) {
 75149:         nsRefPtr<LayerManagerOGL> layerManager = new LayerManagerOGL(this);
 40028:         /**
 40028:          * XXX - On several OSes initialization is expected to fail for now.
 87729:          * If we'd get a non-basic layer manager they'd crash. This is ok though
 40028:          * since on those platforms it will fail. Anyone implementing new
 40028:          * platforms on LayerManagerOGL should ensure their widget is able to
 40028:          * deal with it though!
 40028:          */
 91135: 
 91135:         if (layerManager->Initialize(mForceLayersAcceleration)) {
 40028:           mLayerManager = layerManager;
 40028:         }
 40028:       }
 87729:     }
 40028:     if (!mLayerManager) {
 55858:       mBasicLayerManager = mLayerManager = CreateBasicLayerManager();
 38805:     }
 40028:   }
 55858:   if (mTemporarilyUseBasicLayerManager && !mBasicLayerManager) {
 55858:     mBasicLayerManager = CreateBasicLayerManager();
 55858:   }
 55858:   LayerManager* usedLayerManager = mTemporarilyUseBasicLayerManager ?
 55858:                                      mBasicLayerManager : mLayerManager;
 55858:   if (aAllowRetaining) {
 55858:     *aAllowRetaining = (usedLayerManager == mLayerManager);
 55858:   }
 55858:   return usedLayerManager;
 38805: }
 38805: 
 54111: BasicLayerManager* nsBaseWidget::CreateBasicLayerManager()
 54111: {
 54111:       return new BasicShadowLayerManager(this);
 54111: }
 54111: 
116086: CompositorChild* nsBaseWidget::GetRemoteRenderer()
116086: {
116086:   return mCompositorChild;
116086: }
116086: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Return the used device context
     1: //
     1: //-------------------------------------------------------------------------
 68668: nsDeviceContext* nsBaseWidget::GetDeviceContext() 
     1: {
115495:   if (!mContextInitialized) {
115495:     mContext->Init(this);
115495:     mContextInitialized = true;
115495:   }
     1:   return mContext; 
     1: }
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Get the thebes surface
     1: //
     1: //-------------------------------------------------------------------------
     1: gfxASurface *nsBaseWidget::GetThebesSurface()
     1: {
     1:   // in theory we should get our parent's surface,
     1:   // clone it, and set a device offset before returning
106838:   return nullptr;
     1: }
  5551: 
     1: 
     1: //-------------------------------------------------------------------------
     1: //
     1: // Destroy the window
     1: //
     1: //-------------------------------------------------------------------------
     1: void nsBaseWidget::OnDestroy()
     1: {
 80842:   // release references to device context and app shell
     1:   NS_IF_RELEASE(mContext);
     1: }
     1: 
     1: NS_METHOD nsBaseWidget::SetWindowClass(const nsAString& xulWinType)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
108991: NS_METHOD nsBaseWidget::MoveClient(int32_t aX, int32_t aY)
 83107: {
 83107:   nsIntPoint clientOffset(GetClientOffset());
 83107:   aX -= clientOffset.x;
 83107:   aY -= clientOffset.y;
 83107:   return Move(aX, aY);
 83107: }
 83107: 
108991: NS_METHOD nsBaseWidget::ResizeClient(int32_t aWidth,
108991:                                      int32_t aHeight,
 83107:                                      bool aRepaint)
 83107: {
 83107:   NS_ASSERTION((aWidth >=0) , "Negative width passed to ResizeClient");
 83107:   NS_ASSERTION((aHeight >=0), "Negative height passed to ResizeClient");
 83107: 
 83107:   nsIntRect clientBounds;
 83107:   GetClientBounds(clientBounds);
 83107:   aWidth = mBounds.width + (aWidth - clientBounds.width);
 83107:   aHeight = mBounds.height + (aHeight - clientBounds.height);
 83107: 
 83107:   return Resize(aWidth, aHeight, aRepaint);
 83107: }
 83107: 
108991: NS_METHOD nsBaseWidget::ResizeClient(int32_t aX,
108991:                                      int32_t aY,
108991:                                      int32_t aWidth,
108991:                                      int32_t aHeight,
 83107:                                      bool aRepaint)
 83107: {
 83107:   NS_ASSERTION((aWidth >=0) , "Negative width passed to ResizeClient");
 83107:   NS_ASSERTION((aHeight >=0), "Negative height passed to ResizeClient");
 83107: 
 83107:   nsIntRect clientBounds;
 83107:   GetClientBounds(clientBounds);
 83107:   aWidth = mBounds.width + (aWidth - clientBounds.width);
 83107:   aHeight = mBounds.height + (aHeight - clientBounds.height);
 83107: 
 83107:   nsIntPoint clientOffset(GetClientOffset());
 83107:   aX -= clientOffset.x;
 83107:   aY -= clientOffset.y;
 83107: 
 83107:   return Resize(aX, aY, aWidth, aHeight, aRepaint);
 83107: }
 83107: 
 46198: //-------------------------------------------------------------------------
 46198: //
 46198: // Bounds
 46198: //
 46198: //-------------------------------------------------------------------------
 46198: 
     1: /**
     1: * If the implementation of nsWindow supports borders this method MUST be overridden
     1: *
     1: **/
 23738: NS_METHOD nsBaseWidget::GetClientBounds(nsIntRect &aRect)
     1: {
     1:   return GetBounds(aRect);
     1: }
     1: 
     1: /**
     1: * If the implementation of nsWindow supports borders this method MUST be overridden
     1: *
     1: **/
 23738: NS_METHOD nsBaseWidget::GetBounds(nsIntRect &aRect)
     1: {
     1:   aRect = mBounds;
     1:   return NS_OK;
     1: }
     1: 
     1: /**
     1: * If the implementation of nsWindow uses a local coordinate system within the window,
     1: * this method must be overridden
     1: *
     1: **/
 23738: NS_METHOD nsBaseWidget::GetScreenBounds(nsIntRect &aRect)
     1: {
     1:   return GetBounds(aRect);
     1: }
     1: 
 48256: nsIntPoint nsBaseWidget::GetClientOffset()
 46192: {
 48256:   return nsIntPoint(0, 0);
 46192: }
 46192: 
 46198: NS_IMETHODIMP
 46198: nsBaseWidget::GetNonClientMargins(nsIntMargin &margins)
 46198: {
 46198:   return NS_ERROR_NOT_IMPLEMENTED;
 46198: }
 46198:  
 46198: NS_IMETHODIMP
 46198: nsBaseWidget::SetNonClientMargins(nsIntMargin &margins)
 46198: {
 46198:   return NS_ERROR_NOT_IMPLEMENTED;
 46198: }
 46198: 
 79445: NS_METHOD nsBaseWidget::EnableDragDrop(bool aEnable)
     1: {
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_METHOD nsBaseWidget::SetModal(bool aModal)
     1: {
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsBaseWidget::GetAttention(int32_t aCycleCount) {
     1:     return NS_OK;
     1: }
     1: 
 79445: bool
 27993: nsBaseWidget::HasPendingInputEvent()
 27993: {
 80486:   return false;
 27993: }
 27993: 
     1: NS_IMETHODIMP
     1: nsBaseWidget::SetIcon(const nsAString&)
     1: {
     1:   return NS_OK;
     1: }
     1: 
  6348: NS_IMETHODIMP
  6348: nsBaseWidget::BeginSecureKeyboardInput()
  6348: {
  6348: #ifdef DEBUG
  6348:   NS_ASSERTION(!debug_InSecureKeyboardInputMode, "Attempting to nest call to BeginSecureKeyboardInput!");
 80486:   debug_InSecureKeyboardInputMode = true;
  6348: #endif
  6348:   return NS_OK;
  6348: }
  6348: 
  6348: NS_IMETHODIMP
  6348: nsBaseWidget::EndSecureKeyboardInput()
  6348: {
  6348: #ifdef DEBUG
  6348:   NS_ASSERTION(debug_InSecureKeyboardInputMode, "Calling EndSecureKeyboardInput when it hasn't been enabled!");
 80486:   debug_InSecureKeyboardInputMode = false;
  6348: #endif
  6348:   return NS_OK;
  6348: }
  6348: 
  7242: NS_IMETHODIMP
 79445: nsBaseWidget::SetWindowTitlebarColor(nscolor aColor, bool aActive)
  7242: {
  7242:   return NS_ERROR_NOT_IMPLEMENTED;
  7242: }
  7242: 
 79445: bool
 16520: nsBaseWidget::ShowsResizeIndicator(nsIntRect* aResizerRect)
 16520: {
 80486:   return false;
 16520: }
 16520: 
 33016: NS_IMETHODIMP
122281: nsBaseWidget::SetLayersAcceleration(bool aEnabled)
 40028: {
122281:   if (mUseLayersAcceleration == aEnabled) {
 40028:     return NS_OK;
 40028:   }
122281: 
122281:   bool usedAcceleration = mUseLayersAcceleration;
122281: 
122281:   mUseLayersAcceleration = ComputeShouldAccelerate(aEnabled);
122281:   // ComputeShouldAccelerate may have set mUseLayersAcceleration to a value
122281:   // different from aEnabled.
122281:   if (usedAcceleration == mUseLayersAcceleration) {
122281:     return NS_OK;
122281:   }
122281: 
 58810:   if (mLayerManager) {
 58810:     mLayerManager->Destroy();
 58810:   }
 40028:   mLayerManager = NULL;
 40028:   return NS_OK;
 40028: }
 40028: 
 48711: NS_METHOD nsBaseWidget::RegisterTouchWindow()
 48711: {
 48711:   return NS_ERROR_NOT_IMPLEMENTED;
 48711: }
 48711: 
 48711: NS_METHOD nsBaseWidget::UnregisterTouchWindow()
 48711: {
 48711:   return NS_ERROR_NOT_IMPLEMENTED;
 48711: }
 48711: 
 40028: NS_IMETHODIMP
108991: nsBaseWidget::OverrideSystemMouseScrollSpeed(int32_t aOriginalDelta,
 79445:                                              bool aIsHorizontal,
108991:                                              int32_t &aOverriddenDelta)
 33016: {
 33016:   aOverriddenDelta = aOriginalDelta;
 33016: 
 33016:   const char* kPrefNameOverrideEnabled =
 33016:     "mousewheel.system_scroll_override_on_root_content.enabled";
 79445:   bool isOverrideEnabled =
 79445:     Preferences::GetBool(kPrefNameOverrideEnabled, false);
 70337:   if (!isOverrideEnabled) {
 33016:     return NS_OK;
 33016:   }
 33016: 
110974:   nsAutoCString factorPrefName(
 33016:     "mousewheel.system_scroll_override_on_root_content.");
 33016:   if (aIsHorizontal) {
 33016:     factorPrefName.AppendLiteral("horizontal.");
 33016:   } else {
 33016:     factorPrefName.AppendLiteral("vertical.");
 33016:   }
 33016:   factorPrefName.AppendLiteral("factor");
108991:   int32_t iFactor = Preferences::GetInt(factorPrefName.get(), 0);
 33016:   // The pref value must be larger than 100, otherwise, we don't override the
 33016:   // delta value.
 70337:   if (iFactor <= 100) {
 33016:     return NS_OK;
 33016:   }
 33016:   double factor = (double)iFactor / 100;
108991:   aOverriddenDelta = int32_t(NS_round((double)aOriginalDelta * factor));
 33016: 
 33016:   return NS_OK;
 33016: }
 33016: 
  7242: 
     1: /**
     1:  * Modifies aFile to point at an icon file with the given name and suffix.  The
     1:  * suffix may correspond to a file extension with leading '.' if appropriate.
     1:  * Returns true if the icon file exists and can be read.
     1:  */
 79445: static bool
101111: ResolveIconNameHelper(nsIFile *aFile,
     1:                       const nsAString &aIconName,
     1:                       const nsAString &aIconSuffix)
     1: {
     1:   aFile->Append(NS_LITERAL_STRING("icons"));
     1:   aFile->Append(NS_LITERAL_STRING("default"));
     1:   aFile->Append(aIconName + aIconSuffix);
     1: 
 79445:   bool readable;
     1:   return NS_SUCCEEDED(aFile->IsReadable(&readable)) && readable;
     1: }
     1: 
     1: /**
     1:  * Resolve the given icon name into a local file object.  This method is
     1:  * intended to be called by subclasses of nsBaseWidget.  aIconSuffix is a
     1:  * platform specific icon file suffix (e.g., ".ico" under Win32).
     1:  *
     1:  * If no file is found matching the given parameters, then null is returned.
     1:  */
     1: void
     1: nsBaseWidget::ResolveIconName(const nsAString &aIconName,
     1:                               const nsAString &aIconSuffix,
101111:                               nsIFile **aResult)
     1: { 
106838:   *aResult = nullptr;
     1: 
     1:   nsCOMPtr<nsIProperties> dirSvc = do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID);
     1:   if (!dirSvc)
     1:     return;
     1: 
     1:   // first check auxilary chrome directories
     1: 
     1:   nsCOMPtr<nsISimpleEnumerator> dirs;
     1:   dirSvc->Get(NS_APP_CHROME_DIR_LIST, NS_GET_IID(nsISimpleEnumerator),
     1:               getter_AddRefs(dirs));
     1:   if (dirs) {
 79445:     bool hasMore;
     1:     while (NS_SUCCEEDED(dirs->HasMoreElements(&hasMore)) && hasMore) {
     1:       nsCOMPtr<nsISupports> element;
     1:       dirs->GetNext(getter_AddRefs(element));
     1:       if (!element)
     1:         continue;
101111:       nsCOMPtr<nsIFile> file = do_QueryInterface(element);
     1:       if (!file)
     1:         continue;
     1:       if (ResolveIconNameHelper(file, aIconName, aIconSuffix)) {
     1:         NS_ADDREF(*aResult = file);
     1:         return;
     1:       }
     1:     }
     1:   }
     1: 
     1:   // then check the main app chrome directory
     1: 
101111:   nsCOMPtr<nsIFile> file;
101111:   dirSvc->Get(NS_APP_CHROME_DIR, NS_GET_IID(nsIFile),
     1:               getter_AddRefs(file));
     1:   if (file && ResolveIconNameHelper(file, aIconName, aIconSuffix))
     1:     NS_ADDREF(*aResult = file);
     1: }
     1: 
  8892: NS_IMETHODIMP 
108991: nsBaseWidget::BeginResizeDrag(nsGUIEvent* aEvent, int32_t aHorizontal, int32_t aVertical)
  8892: {
  8892:   return NS_ERROR_NOT_IMPLEMENTED;
  8892: }
  8892: 
 47857: NS_IMETHODIMP
 47857: nsBaseWidget::BeginMoveDrag(nsMouseEvent* aEvent)
 47857: {
 47857:   return NS_ERROR_NOT_IMPLEMENTED;
 47857: }
 47857: 
108991: uint32_t
 88239: nsBaseWidget::GetGLFrameBufferFormat()
 88239: {
 88239:   if (mLayerManager &&
105710:       mLayerManager->GetBackendType() == LAYERS_OPENGL) {
 88239:     // Assume that the default framebuffer has RGBA format.  Specific
 88239:     // backends that know differently will override this method.
 88239:     return LOCAL_GL_RGBA;
 88239:   }
 88239:   return LOCAL_GL_NONE;
 88239: }
 88239: 
106923: void nsBaseWidget::SetSizeConstraints(const SizeConstraints& aConstraints)
106923: {
106923:   mSizeConstraints = aConstraints;
106923:   // We can't ensure that the size is honored at this point because we're
106923:   // probably in the middle of a reflow.
106923: }
106923: 
106923: const widget::SizeConstraints& nsBaseWidget::GetSizeConstraints() const
106923: {
106923:   return mSizeConstraints;
106923: }
106923: 
120177: // static
120177: nsIRollupListener*
120177: nsBaseWidget::GetActiveRollupListener()
120177: {
120177:   // If set, then this is likely an <html:select> dropdown.
120177:   if (gRollupListener)
120177:     return gRollupListener;
120177: 
120177:   return nsXULPopupManager::GetInstance();
120177: }
120177: 
108452: void
108456: nsBaseWidget::NotifyWindowDestroyed()
108456: {
108457:   if (!mWidgetListener)
108457:     return;
108457: 
108457:   nsCOMPtr<nsIXULWindow> window = mWidgetListener->GetXULWindow();
108457:   nsCOMPtr<nsIBaseWindow> xulWindow(do_QueryInterface(window));
108457:   if (xulWindow) {
108457:     xulWindow->Destroy();
108456:   }
108456: }
108456: 
108456: void
108452: nsBaseWidget::NotifySizeMoveDone()
108452: {
108458:   if (!mWidgetListener || mWidgetListener->GetXULWindow())
108458:     return;
108458: 
108458:   nsIPresShell* presShell = mWidgetListener->GetPresShell();
108452:   if (presShell) {
108452:     presShell->WindowSizeMoveDone();
108452:   }
108452: }
108452: 
108452: void
108452: nsBaseWidget::NotifySysColorChanged()
108452: {
108458:   if (!mWidgetListener || mWidgetListener->GetXULWindow())
108458:     return;
108458: 
108458:   nsIPresShell* presShell = mWidgetListener->GetPresShell();
108452:   if (presShell) {
108452:     presShell->SysColorChanged();
108452:   }
108452: }
108452: 
108452: void
108452: nsBaseWidget::NotifyThemeChanged()
108452: {
108458:   if (!mWidgetListener || mWidgetListener->GetXULWindow())
108458:     return;
108458: 
108458:   nsIPresShell* presShell = mWidgetListener->GetPresShell();
108452:   if (presShell) {
108452:     presShell->ThemeChanged();
108452:   }
108452: }
108452: 
108455: void
108455: nsBaseWidget::NotifyUIStateChanged(UIStateChangeType aShowAccelerators,
108455:                                    UIStateChangeType aShowFocusRings)
108455: {
108650:   if (!mWidgetListener)
108650:     return;
108650: 
108458:   nsIPresShell* presShell = mWidgetListener->GetPresShell();
108455:   nsIDocument* doc = presShell->GetDocument();
108455:   if (doc) {
108455:     nsPIDOMWindow* win = doc->GetWindow();
108455:     if (win) {
108455:       win->SetKeyboardIndicators(aShowAccelerators, aShowFocusRings);
108455:     }
108455:   }
108455: }
108455: 
108454: #ifdef ACCESSIBILITY
108454: 
122283: a11y::Accessible*
108454: nsBaseWidget::GetAccessible()
108454: {
108650:   NS_ENSURE_TRUE(mWidgetListener, nullptr);
108650: 
108458:   nsIPresShell* presShell = mWidgetListener->GetPresShell();
108454:   NS_ENSURE_TRUE(presShell, nullptr);
108454: 
108454:   // If container is null then the presshell is not active. This often happens
108454:   // when a preshell is being held onto for fastback.
108454:   nsPresContext* presContext = presShell->GetPresContext();
108454:   nsCOMPtr<nsISupports> container = presContext->GetContainer();
108454:   NS_ENSURE_TRUE(container, nullptr);
108454: 
108454:   // Accessible creation might be not safe so use IsSafeToRunScript to
108454:   // make sure it's not created at unsafe times.
108454:   nsCOMPtr<nsIAccessibilityService> accService = services::GetAccessibilityService();
108454:   if (accService) {
108454:     return accService->GetRootDocumentAccessible(presShell, nsContentUtils::IsSafeToRunScript());
108454:   }
108454: 
108454:   return nullptr;
108454: }
108454: 
108454: #endif
108454: 
     1: #ifdef DEBUG
     1: //////////////////////////////////////////////////////////////
     1: //
     1: // Convert a GUI event message code to a string.
     1: // Makes it a lot easier to debug events.
     1: //
     1: // See gtk/nsWidget.cpp and windows/nsWindow.cpp
     1: // for a DebugPrintEvent() function that uses
     1: // this.
     1: //
     1: //////////////////////////////////////////////////////////////
     1: /* static */ nsAutoString
     1: nsBaseWidget::debug_GuiEventToString(nsGUIEvent * aGuiEvent)
     1: {
106838:   NS_ASSERTION(nullptr != aGuiEvent,"cmon, null gui event.");
     1: 
     1:   nsAutoString eventName(NS_LITERAL_STRING("UNKNOWN"));
     1: 
     1: #define _ASSIGN_eventName(_value,_name)\
 83428: case _value: eventName.AssignLiteral(_name) ; break
     1: 
     1:   switch(aGuiEvent->message)
     1:   {
     1:     _ASSIGN_eventName(NS_BLUR_CONTENT,"NS_BLUR_CONTENT");
     1:     _ASSIGN_eventName(NS_DRAGDROP_GESTURE,"NS_DND_GESTURE");
     1:     _ASSIGN_eventName(NS_DRAGDROP_DROP,"NS_DND_DROP");
     1:     _ASSIGN_eventName(NS_DRAGDROP_ENTER,"NS_DND_ENTER");
     1:     _ASSIGN_eventName(NS_DRAGDROP_EXIT,"NS_DND_EXIT");
     1:     _ASSIGN_eventName(NS_DRAGDROP_OVER,"NS_DND_OVER");
     1:     _ASSIGN_eventName(NS_FOCUS_CONTENT,"NS_FOCUS_CONTENT");
     1:     _ASSIGN_eventName(NS_FORM_SELECTED,"NS_FORM_SELECTED");
     1:     _ASSIGN_eventName(NS_FORM_CHANGE,"NS_FORM_CHANGE");
     1:     _ASSIGN_eventName(NS_FORM_INPUT,"NS_FORM_INPUT");
     1:     _ASSIGN_eventName(NS_FORM_RESET,"NS_FORM_RESET");
     1:     _ASSIGN_eventName(NS_FORM_SUBMIT,"NS_FORM_SUBMIT");
     1:     _ASSIGN_eventName(NS_IMAGE_ABORT,"NS_IMAGE_ABORT");
     1:     _ASSIGN_eventName(NS_LOAD_ERROR,"NS_LOAD_ERROR");
     1:     _ASSIGN_eventName(NS_KEY_DOWN,"NS_KEY_DOWN");
     1:     _ASSIGN_eventName(NS_KEY_PRESS,"NS_KEY_PRESS");
     1:     _ASSIGN_eventName(NS_KEY_UP,"NS_KEY_UP");
     1:     _ASSIGN_eventName(NS_MOUSE_ENTER,"NS_MOUSE_ENTER");
     1:     _ASSIGN_eventName(NS_MOUSE_EXIT,"NS_MOUSE_EXIT");
     1:     _ASSIGN_eventName(NS_MOUSE_BUTTON_DOWN,"NS_MOUSE_BUTTON_DOWN");
     1:     _ASSIGN_eventName(NS_MOUSE_BUTTON_UP,"NS_MOUSE_BUTTON_UP");
     1:     _ASSIGN_eventName(NS_MOUSE_CLICK,"NS_MOUSE_CLICK");
     1:     _ASSIGN_eventName(NS_MOUSE_DOUBLECLICK,"NS_MOUSE_DBLCLICK");
     1:     _ASSIGN_eventName(NS_MOUSE_MOVE,"NS_MOUSE_MOVE");
     1:     _ASSIGN_eventName(NS_LOAD,"NS_LOAD");
 37802:     _ASSIGN_eventName(NS_POPSTATE,"NS_POPSTATE");
 54146:     _ASSIGN_eventName(NS_BEFORE_SCRIPT_EXECUTE,"NS_BEFORE_SCRIPT_EXECUTE");
 54146:     _ASSIGN_eventName(NS_AFTER_SCRIPT_EXECUTE,"NS_AFTER_SCRIPT_EXECUTE");
     1:     _ASSIGN_eventName(NS_PAGE_UNLOAD,"NS_PAGE_UNLOAD");
 29975:     _ASSIGN_eventName(NS_HASHCHANGE,"NS_HASHCHANGE");
 46273:     _ASSIGN_eventName(NS_READYSTATECHANGE,"NS_READYSTATECHANGE");
     1:     _ASSIGN_eventName(NS_XUL_BROADCAST, "NS_XUL_BROADCAST");
     1:     _ASSIGN_eventName(NS_XUL_COMMAND_UPDATE, "NS_XUL_COMMAND_UPDATE");
     1: 
     1: #undef _ASSIGN_eventName
     1: 
     1:   default: 
     1:     {
     1:       char buf[32];
     1:       
     1:       sprintf(buf,"UNKNOWN: %d",aGuiEvent->message);
     1:       
 83428:       CopyASCIItoUTF16(buf, eventName);
     1:     }
     1:     break;
     1:   }
     1:   
     1:   return nsAutoString(eventName);
     1: }
     1: //////////////////////////////////////////////////////////////
     1: //
     1: // Code to deal with paint and event debug prefs.
     1: //
     1: //////////////////////////////////////////////////////////////
     1: struct PrefPair
     1: {
     1:   const char * name;
 79445:   bool value;
     1: };
     1: 
     1: static PrefPair debug_PrefValues[] =
     1: {
 80486:   { "nglayout.debug.crossing_event_dumping", false },
 80486:   { "nglayout.debug.event_dumping", false },
 80486:   { "nglayout.debug.invalidate_dumping", false },
 80486:   { "nglayout.debug.motion_event_dumping", false },
 80486:   { "nglayout.debug.paint_dumping", false },
 80486:   { "nglayout.debug.paint_flashing", false }
     1: };
     1: 
     1: //////////////////////////////////////////////////////////////
 79445: bool
     1: nsBaseWidget::debug_GetCachedBoolPref(const char * aPrefName)
     1: {
106838:   NS_ASSERTION(nullptr != aPrefName,"cmon, pref name is null.");
     1: 
108991:   for (uint32_t i = 0; i < ArrayLength(debug_PrefValues); i++)
     1:   {
     1:     if (strcmp(debug_PrefValues[i].name, aPrefName) == 0)
     1:     {
     1:       return debug_PrefValues[i].value;
     1:     }
     1:   }
     1: 
 80486:   return false;
     1: }
     1: //////////////////////////////////////////////////////////////
 79445: static void debug_SetCachedBoolPref(const char * aPrefName,bool aValue)
     1: {
106838:   NS_ASSERTION(nullptr != aPrefName,"cmon, pref name is null.");
     1: 
108991:   for (uint32_t i = 0; i < ArrayLength(debug_PrefValues); i++)
     1:   {
     1:     if (strcmp(debug_PrefValues[i].name, aPrefName) == 0)
     1:     {
     1:       debug_PrefValues[i].value = aValue;
     1: 
     1:       return;
     1:     }
     1:   }
     1: 
 80486:   NS_ASSERTION(false, "cmon, this code is not reached dude.");
     1: }
     1: 
     1: //////////////////////////////////////////////////////////////
102309: class Debug_PrefObserver MOZ_FINAL : public nsIObserver {
     1:   public:
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIOBSERVER
     1: };
     1: 
     1: NS_IMPL_ISUPPORTS1(Debug_PrefObserver, nsIObserver)
     1: 
     1: NS_IMETHODIMP
     1: Debug_PrefObserver::Observe(nsISupports* subject, const char* topic,
     1:                             const PRUnichar* data)
     1: {
     1:   NS_ConvertUTF16toUTF8 prefName(data);
     1: 
 79445:   bool value = Preferences::GetBool(prefName.get(), false);
     1:   debug_SetCachedBoolPref(prefName.get(), value);
     1:   return NS_OK;
     1: }
     1: 
     1: //////////////////////////////////////////////////////////////
     1: /* static */ void
     1: debug_RegisterPrefCallbacks()
     1: {
 79445:   static bool once = true;
     1: 
 70337:   if (!once) {
 70337:     return;
 70337:   }
 70337: 
 80486:   once = false;
     1: 
     1:   nsCOMPtr<nsIObserver> obs(new Debug_PrefObserver());
108991:   for (uint32_t i = 0; i < ArrayLength(debug_PrefValues); i++) {
     1:     // Initialize the pref values
     1:     debug_PrefValues[i].value =
 79445:       Preferences::GetBool(debug_PrefValues[i].name, false);
     1: 
     1:     if (obs) {
     1:       // Register callbacks for when these change
 70337:       Preferences::AddStrongObserver(obs, debug_PrefValues[i].name);
     1:     }
     1:   }
     1: }
     1: //////////////////////////////////////////////////////////////
108991: static int32_t
     1: _GetPrintCount()
     1: {
108991:   static int32_t sCount = 0;
     1:   
     1:   return ++sCount;
     1: }
     1: //////////////////////////////////////////////////////////////
 79445: /* static */ bool
     1: nsBaseWidget::debug_WantPaintFlashing()
     1: {
     1:   return debug_GetCachedBoolPref("nglayout.debug.paint_flashing");
     1: }
     1: //////////////////////////////////////////////////////////////
     1: /* static */ void
     1: nsBaseWidget::debug_DumpEvent(FILE *                aFileOut,
     1:                               nsIWidget *           aWidget,
     1:                               nsGUIEvent *          aGuiEvent,
110974:                               const nsAutoCString & aWidgetName,
108991:                               int32_t               aWindowID)
     1: {
     1:   if (aGuiEvent->message == NS_MOUSE_MOVE)
     1:   {
     1:     if (!debug_GetCachedBoolPref("nglayout.debug.motion_event_dumping"))
     1:       return;
     1:   }
     1:   
     1:   if (aGuiEvent->message == NS_MOUSE_ENTER || 
     1:       aGuiEvent->message == NS_MOUSE_EXIT)
     1:   {
     1:     if (!debug_GetCachedBoolPref("nglayout.debug.crossing_event_dumping"))
     1:       return;
     1:   }
     1: 
     1:   if (!debug_GetCachedBoolPref("nglayout.debug.event_dumping"))
     1:     return;
     1: 
 83428:   NS_LossyConvertUTF16toASCII tempString(debug_GuiEventToString(aGuiEvent).get());
     1:   
     1:   fprintf(aFileOut,
     1:           "%4d %-26s widget=%-8p name=%-12s id=%-8p refpt=%d,%d\n",
     1:           _GetPrintCount(),
     1:           tempString.get(),
     1:           (void *) aWidget,
     1:           aWidgetName.get(),
     1:           (void *) (aWindowID ? aWindowID : 0x0),
     1:           aGuiEvent->refPoint.x,
     1:           aGuiEvent->refPoint.y);
     1: }
     1: //////////////////////////////////////////////////////////////
     1: /* static */ void
     1: nsBaseWidget::debug_DumpPaintEvent(FILE *                aFileOut,
     1:                                    nsIWidget *           aWidget,
108457:                                    const nsIntRegion &   aRegion,
110974:                                    const nsAutoCString & aWidgetName,
108991:                                    int32_t               aWindowID)
     1: {
106838:   NS_ASSERTION(nullptr != aFileOut,"cmon, null output FILE");
106838:   NS_ASSERTION(nullptr != aWidget,"cmon, the widget is null");
     1: 
     1:   if (!debug_GetCachedBoolPref("nglayout.debug.paint_dumping"))
     1:     return;
     1:   
108457:   nsIntRect rect = aRegion.GetBounds();
     1:   fprintf(aFileOut,
 51040:           "%4d PAINT      widget=%p name=%-12s id=%-8p bounds-rect=%3d,%-3d %3d,%-3d", 
     1:           _GetPrintCount(),
     1:           (void *) aWidget,
     1:           aWidgetName.get(),
 51040:           (void *) aWindowID,
 51040:           rect.x, rect.y, rect.width, rect.height
 51040:     );
     1:   
     1:   fprintf(aFileOut,"\n");
     1: }
     1: //////////////////////////////////////////////////////////////
     1: /* static */ void
     1: nsBaseWidget::debug_DumpInvalidate(FILE *                aFileOut,
     1:                                    nsIWidget *           aWidget,
 23738:                                    const nsIntRect *     aRect,
110974:                                    const nsAutoCString & aWidgetName,
108991:                                    int32_t               aWindowID)
     1: {
     1:   if (!debug_GetCachedBoolPref("nglayout.debug.invalidate_dumping"))
     1:     return;
     1: 
106838:   NS_ASSERTION(nullptr != aFileOut,"cmon, null output FILE");
106838:   NS_ASSERTION(nullptr != aWidget,"cmon, the widget is null");
     1: 
     1:   fprintf(aFileOut,
     1:           "%4d Invalidate widget=%p name=%-12s id=%-8p",
     1:           _GetPrintCount(),
     1:           (void *) aWidget,
     1:           aWidgetName.get(),
     1:           (void *) aWindowID);
     1: 
     1:   if (aRect) 
     1:   {
     1:     fprintf(aFileOut,
     1:             " rect=%3d,%-3d %3d,%-3d",
     1:             aRect->x, 
     1:             aRect->y,
     1:             aRect->width, 
     1:             aRect->height);
     1:   }
     1:   else
     1:   {
     1:     fprintf(aFileOut,
     1:             " rect=%-15s",
     1:             "none");
     1:   }
     1:   
     1:   fprintf(aFileOut,"\n");
     1: }
     1: //////////////////////////////////////////////////////////////
     1: 
     1: #endif // DEBUG
     1: 
