  701: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
  701: /* ***** BEGIN LICENSE BLOCK *****
  701:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  701:  *
  701:  * The contents of this file are subject to the Mozilla Public License Version
  701:  * 1.1 (the "License"); you may not use this file except in compliance with
  701:  * the License. You may obtain a copy of the License at
  701:  * http://www.mozilla.org/MPL/
  701:  *
  701:  * Software distributed under the License is distributed on an "AS IS" basis,
  701:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  701:  * for the specific language governing rights and limitations under the
  701:  * License.
  701:  *
  701:  * The Original Code is support for icons in native menu items on Mac OS X.
  701:  *
  701:  * The Initial Developer of the Original Code is Google Inc.
  701:  * Portions created by the Initial Developer are Copyright (C) 2006
  701:  * the Initial Developer. All Rights Reserved.
  701:  *
  701:  * Contributor(s):
  701:  *  Mark Mentovai <mark@moxienet.com> (Original Author)
  701:  *  Josh Aas <josh@mozilla.com>
35630:  *  Benjamin Frisch <bfrisch@gmail.com>
  701:  *
  701:  * Alternatively, the contents of this file may be used under the terms of
  701:  * either the GNU General Public License Version 2 or later (the "GPL"), or
  701:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  701:  * in which case the provisions of the GPL or the LGPL are applicable instead
  701:  * of those above. If you wish to allow use of your version of this file only
  701:  * under the terms of either the GPL or the LGPL, and not to allow others to
  701:  * use your version of this file under the terms of the MPL, indicate your
  701:  * decision by deleting the provisions above and replace them with the notice
  701:  * and other provisions required by the GPL or the LGPL. If you do not delete
  701:  * the provisions above, a recipient may use your version of this file under
  701:  * the terms of any one of the MPL, the GPL or the LGPL.
  701:  *
  701:  * ***** END LICENSE BLOCK ***** */
  701: 
  701: /*
  701:  * Retrieves and displays icons in native menu items on Mac OS X.
  701:  */
  701: 
  701: #include "nsMenuItemIconX.h"
  701: 
11978: #include "nsObjCExceptions.h"
  701: #include "prmem.h"
  701: #include "nsIContent.h"
  701: #include "nsIDocument.h"
  701: #include "nsINameSpaceManager.h"
  701: #include "nsWidgetAtoms.h"
  701: #include "nsIDOMDocumentView.h"
  701: #include "nsIDOMViewCSS.h"
  701: #include "nsIDOMElement.h"
  701: #include "nsIDOMCSSStyleDeclaration.h"
  701: #include "nsIDOMCSSValue.h"
  701: #include "nsIDOMCSSPrimitiveValue.h"
35630: #include "nsIDOMRect.h"
  701: #include "nsThreadUtils.h"
  701: #include "nsToolkit.h"
  701: #include "nsNetUtil.h"
  701: #include "imgILoader.h"
  701: #include "imgIRequest.h"
15578: #include "nsMenuItemX.h"
30479: #include "gfxImageSurface.h"
30479: #include "imgIContainer.h"
39390: #include "nsCocoaUtils.h"
  701: 
  701: static const PRUint32 kIconWidth = 16;
  701: static const PRUint32 kIconHeight = 16;
  701: static const PRUint32 kIconBitsPerComponent = 8;
  701: static const PRUint32 kIconComponents = 4;
  701: static const PRUint32 kIconBitsPerPixel = kIconBitsPerComponent *
  701:                                           kIconComponents;
  701: static const PRUint32 kIconBytesPerRow = kIconWidth * kIconBitsPerPixel / 8;
  701: static const PRUint32 kIconBytes = kIconBytesPerRow * kIconHeight;
  701: 
35630: typedef nsresult (nsIDOMRect::*GetRectSideMethod)(nsIDOMCSSPrimitiveValue**);
35630: 
  701: NS_IMPL_ISUPPORTS2(nsMenuItemIconX, imgIContainerObserver, imgIDecoderObserver)
  701: 
15578: nsMenuItemIconX::nsMenuItemIconX(nsMenuObjectX* aMenuItem,
 4175:                                  nsIContent*    aContent,
 4175:                                  NSMenuItem*    aNativeMenuItem)
  701: : mContent(aContent)
15578: , mMenuObject(aMenuItem)
  701: , mLoadedIcon(PR_FALSE)
  701: , mSetIcon(PR_FALSE)
 4175: , mNativeMenuItem(aNativeMenuItem)
  701: {
 4175:   //  printf("Creating icon for menu item %d, menu %d, native item is %d\n", aMenuItem, aMenu, aNativeMenuItem);
  701: }
  701: 
  701: nsMenuItemIconX::~nsMenuItemIconX()
  701: {
  701:   if (mIconRequest)
22953:     mIconRequest->CancelAndForgetObserver(NS_BINDING_ABORTED);
  701: }
  701: 
30014: // Called from mMenuObjectX's destructor, to prevent us from outliving it
30014: // (as might otherwise happen if calls to our imgIDecoderObserver methods
30014: // are still outstanding).  mMenuObjectX owns our nNativeMenuItem.
30014: void nsMenuItemIconX::Destroy()
30014: {
30014:   if (mIconRequest) {
30014:     mIconRequest->CancelAndForgetObserver(NS_BINDING_ABORTED);
30014:     mIconRequest = nsnull;
30014:   }
30014:   mMenuObject = nsnull;
30014:   mNativeMenuItem = nil;
30014: }
30014: 
  701: nsresult
  701: nsMenuItemIconX::SetupIcon()
  701: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 4175:   // Still don't have one, then something is wrong, get out of here.
 4175:   if (!mNativeMenuItem) {
 4175:     NS_ERROR("No native menu item\n");
 4175:     return NS_ERROR_FAILURE;
 4175:   }
 4175: 
  701:   nsCOMPtr<nsIURI> iconURI;
15578:   nsresult rv = GetIconURI(getter_AddRefs(iconURI));
  701:   if (NS_FAILED(rv)) {
  701:     // There is no icon for this menu item. An icon might have been set
  701:     // earlier.  Clear it.
 4175:     [mNativeMenuItem setImage:nil];
  701: 
  701:     return NS_OK;
  701:   }
  701: 
35630:   rv = LoadIcon(iconURI);
35630:   if (NS_FAILED(rv)) {
35630:     // There is no icon for this menu item, as an error occured while loading it.
35630:     // An icon might have been set earlier or the place holder icon may have
35630:     // been set.  Clear it.
35630:     [mNativeMenuItem setImage:nil];
35630:   }
35630:   return rv;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
  701: }
  701: 
35630: static PRInt32
35630: GetDOMRectSide(nsIDOMRect* aRect, GetRectSideMethod aMethod)
35630: {
35630:   nsCOMPtr<nsIDOMCSSPrimitiveValue> dimensionValue;
35630:   (aRect->*aMethod)(getter_AddRefs(dimensionValue));
35630:   if (!dimensionValue)
35630:     return -1;
35630: 
35630:   PRUint16 primitiveType;
35630:   nsresult rv = dimensionValue->GetPrimitiveType(&primitiveType);
35630:   if (NS_FAILED(rv) || primitiveType != nsIDOMCSSPrimitiveValue::CSS_PX)
35630:     return -1;
35630: 
35630:   float dimension = 0;
35630:   rv = dimensionValue->GetFloatValue(nsIDOMCSSPrimitiveValue::CSS_PX,
35630:                                      &dimension);
35630:   if (NS_FAILED(rv))
35630:     return -1;
35630: 
35630:   return NSToIntRound(dimension);
35630: }
35630: 
  701: nsresult
  701: nsMenuItemIconX::GetIconURI(nsIURI** aIconURI)
  701: {
30014:   if (!mMenuObject)
30014:     return NS_ERROR_FAILURE;
30014: 
  701:   // Mac native menu items support having both a checkmark and an icon
  701:   // simultaneously, but this is unheard of in the cross-platform toolkit,
  701:   // seemingly because the win32 theme is unable to cope with both at once.
  701:   // The downside is that it's possible to get a menu item marked with a
  701:   // native checkmark and a checkmark for an icon.  Head off that possibility
  701:   // by pretending that no icon exists if this is a checkable menu item.
15578:   if (mMenuObject->MenuObjectType() == eMenuItemObjectType) {
15578:     nsMenuItemX* menuItem = static_cast<nsMenuItemX*>(mMenuObject);
15578:     if (menuItem->GetMenuItemType() != eRegularMenuItemType)
  701:       return NS_ERROR_FAILURE;
  701:   }
  701: 
15578:   if (!mContent)
15578:     return NS_ERROR_FAILURE;
  701: 
  701:   // First, look at the content node's "image" attribute.
  701:   nsAutoString imageURIString;
  701:   PRBool hasImageAttr = mContent->GetAttr(kNameSpaceID_None,
  701:                                           nsWidgetAtoms::image,
  701:                                           imageURIString);
  701: 
  701:   nsresult rv;
35630:   nsCOMPtr<nsIDOMCSSValue> cssValue;
35630:   nsCOMPtr<nsIDOMCSSStyleDeclaration> cssStyleDecl;
35630:   nsCOMPtr<nsIDOMCSSPrimitiveValue> primitiveValue;
35630:   PRUint16 primitiveType;
  701:   if (!hasImageAttr) {
  701:     // If the content node has no "image" attribute, get the
  701:     // "list-style-image" property from CSS.
  701:     nsCOMPtr<nsIDOMDocumentView> domDocumentView =
  701:      do_QueryInterface(mContent->GetDocument());
  701:     if (!domDocumentView) return NS_ERROR_FAILURE;
  701: 
  701:     nsCOMPtr<nsIDOMAbstractView> domAbstractView;
  701:     rv = domDocumentView->GetDefaultView(getter_AddRefs(domAbstractView));
  701:     if (NS_FAILED(rv)) return rv;
  701: 
  701:     nsCOMPtr<nsIDOMViewCSS> domViewCSS = do_QueryInterface(domAbstractView);
  701:     if (!domViewCSS) return NS_ERROR_FAILURE;
  701: 
  701:     nsCOMPtr<nsIDOMElement> domElement = do_QueryInterface(mContent);
  701:     if (!domElement) return NS_ERROR_FAILURE;
  701: 
  701:     nsAutoString empty;
  701:     rv = domViewCSS->GetComputedStyle(domElement, empty,
  701:                                       getter_AddRefs(cssStyleDecl));
  701:     if (NS_FAILED(rv)) return rv;
  701: 
  701:     NS_NAMED_LITERAL_STRING(listStyleImage, "list-style-image");
  701:     rv = cssStyleDecl->GetPropertyCSSValue(listStyleImage,
  701:                                            getter_AddRefs(cssValue));
  701:     if (NS_FAILED(rv)) return rv;
  701: 
35630:     primitiveValue = do_QueryInterface(cssValue);
  701:     if (!primitiveValue) return NS_ERROR_FAILURE;
  701: 
  701:     rv = primitiveValue->GetPrimitiveType(&primitiveType);
  701:     if (NS_FAILED(rv)) return rv;
  701:     if (primitiveType != nsIDOMCSSPrimitiveValue::CSS_URI)
  701:       return NS_ERROR_FAILURE;
  701: 
  701:     rv = primitiveValue->GetStringValue(imageURIString);
  701:     if (NS_FAILED(rv)) return rv;
  701:   }
  701: 
35630:   // Empty the mImageRegionRect initially as the image region CSS could
35630:   // have been changed and now have an error or have been removed since the
35630:   // last GetIconURI call.
35630:   mImageRegionRect.Empty();
35630: 
  701:   // If this menu item shouldn't have an icon, the string will be empty,
  701:   // and NS_NewURI will fail.
  701:   nsCOMPtr<nsIURI> iconURI;
  701:   rv = NS_NewURI(getter_AddRefs(iconURI), imageURIString);
  701:   if (NS_FAILED(rv)) return rv;
  701: 
  701:   *aIconURI = iconURI;
  701:   NS_ADDREF(*aIconURI);
35630: 
35630:   if (!hasImageAttr) {
35630:     // Check if the icon has a specified image region so that it can be
35630:     // cropped appropriately before being displayed.
35630:     NS_NAMED_LITERAL_STRING(imageRegion, "-moz-image-region");
35630:     rv = cssStyleDecl->GetPropertyCSSValue(imageRegion,
35630:                                            getter_AddRefs(cssValue));
35630:     // Just return NS_OK if there if there is a failure due to no
35630:     // moz-image region specified so the whole icon will be drawn anyway.
35630:     if (NS_FAILED(rv)) return NS_OK;
35630: 
35630:     primitiveValue = do_QueryInterface(cssValue);
35630:     if (!primitiveValue) return NS_OK;
35630: 
35630:     rv = primitiveValue->GetPrimitiveType(&primitiveType);
35630:     if (NS_FAILED(rv)) return NS_OK;
35630:     if (primitiveType != nsIDOMCSSPrimitiveValue::CSS_RECT)
35630:       return NS_OK;
35630: 
35630:     nsCOMPtr<nsIDOMRect> imageRegionRect;
35630:     rv = primitiveValue->GetRectValue(getter_AddRefs(imageRegionRect));
35630:     if (NS_FAILED(rv)) return NS_OK;
35630: 
35630:     if (imageRegionRect) {
35630:       // Return NS_ERROR_FAILURE if the image region is invalid so the image
35630:       // is not drawn, and behavior is similar to XUL menus.
35630:       PRInt32 bottom = GetDOMRectSide(imageRegionRect, &nsIDOMRect::GetBottom);
35630:       PRInt32 right = GetDOMRectSide(imageRegionRect, &nsIDOMRect::GetRight);
35630:       PRInt32 top = GetDOMRectSide(imageRegionRect, &nsIDOMRect::GetTop);
35630:       PRInt32 left = GetDOMRectSide(imageRegionRect, &nsIDOMRect::GetLeft);
35630: 
35630:       if (top < 0 || left < 0 || bottom <= top || right <= left)
35630:         return NS_ERROR_FAILURE;
35630: 
35630:       mImageRegionRect.SetRect(left, top, right - left, bottom - top);
35630:     }
35630:   }
35630: 
  701:   return NS_OK;
  701: }
  701: 
  701: nsresult
  701: nsMenuItemIconX::LoadIcon(nsIURI* aIconURI)
  701: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
  701:   if (mIconRequest) {
  701:     // Another icon request is already in flight.  Kill it.
  701:     mIconRequest->Cancel(NS_BINDING_ABORTED);
  701:     mIconRequest = nsnull;
  701:   }
  701: 
  701:   mLoadedIcon = PR_FALSE;
  701: 
  701:   if (!mContent) return NS_ERROR_FAILURE;
  701: 
  701:   nsCOMPtr<nsIDocument> document = mContent->GetOwnerDoc();
  701:   if (!document) return NS_ERROR_FAILURE;
  701: 
  701:   nsCOMPtr<nsILoadGroup> loadGroup = document->GetDocumentLoadGroup();
  701:   if (!loadGroup) return NS_ERROR_FAILURE;
  701: 
  701:   nsresult rv = NS_ERROR_FAILURE;
  701:   nsCOMPtr<imgILoader> loader = do_GetService("@mozilla.org/image/loader;1",
  701:                                               &rv);
  701:   if (NS_FAILED(rv)) return rv;
  701: 
  701:   if (!mSetIcon) {
  701:     // Set a completely transparent 16x16 image as the icon on this menu item
  701:     // as a placeholder.  This keeps the menu item text displayed in the same
  701:     // position that it will be displayed when the real icon is loaded, and
  701:     // prevents it from jumping around or looking misaligned.
  701: 
  701:     static PRBool sInitializedPlaceholder;
 4175:     static NSImage* sPlaceholderIconImage;
  701:     if (!sInitializedPlaceholder) {
  701:       sInitializedPlaceholder = PR_TRUE;
  701: 
 4175:       // Note that we only create the one and reuse it forever, so this is not a leak.
 4175:       sPlaceholderIconImage = [[NSImage alloc] initWithSize:NSMakeSize(kIconWidth, kIconHeight)];
  701:     }
  701: 
  701:     if (!sPlaceholderIconImage) return NS_ERROR_FAILURE;
  701: 
 4175:     if (mNativeMenuItem)
 4175:       [mNativeMenuItem setImage:sPlaceholderIconImage];
  701:   }
  701: 
  701:   rv = loader->LoadImage(aIconURI, nsnull, nsnull, loadGroup, this,
  701:                          nsnull, nsIRequest::LOAD_NORMAL, nsnull,
  701:                          nsnull, getter_AddRefs(mIconRequest));
  701:   if (NS_FAILED(rv)) return rv;
  701: 
  701:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
  701: }
  701: 
 5500: //
  701: // imgIContainerObserver
 5500: //
  701: 
  701: NS_IMETHODIMP
  701: nsMenuItemIconX::FrameChanged(imgIContainer* aContainer,
  701:                               nsIntRect*     aDirtyRect)
  701: {
  701:   return NS_OK;
  701: }
  701: 
 5500: //
  701: // imgIDecoderObserver
 5500: //
  701: 
  701: NS_IMETHODIMP
  701: nsMenuItemIconX::OnStartRequest(imgIRequest* aRequest)
  701: {
  701:   return NS_OK;
  701: }
  701: 
  701: NS_IMETHODIMP
  701: nsMenuItemIconX::OnStartDecode(imgIRequest* aRequest)
  701: {
  701:   return NS_OK;
  701: }
  701: 
  701: NS_IMETHODIMP
  701: nsMenuItemIconX::OnStartContainer(imgIRequest*   aRequest,
  701:                                   imgIContainer* aContainer)
  701: {
32424:   // Request a decode
32424:   NS_ABORT_IF_FALSE(aContainer, "who sent the notification then?");
32424:   aContainer->RequestDecode();
32424: 
  701:   return NS_OK;
  701: }
  701: 
  701: NS_IMETHODIMP
30479: nsMenuItemIconX::OnStartFrame(imgIRequest* aRequest, PRUint32 aFrame)
  701: {
  701:   return NS_OK;
  701: }
  701: 
  701: NS_IMETHODIMP
  701: nsMenuItemIconX::OnDataAvailable(imgIRequest*     aRequest,
30479:                                  PRBool           aCurrentFrame,
  701:                                  const nsIntRect* aRect)
  701: {
  701:   return NS_OK;
  701: }
  701: 
  701: NS_IMETHODIMP
  701: nsMenuItemIconX::OnStopFrame(imgIRequest*    aRequest,
30479:                              PRUint32        aFrame)
  701: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
30479:   if (aRequest != mIconRequest)
30479:     return NS_ERROR_FAILURE;
  701: 
  701:   // Only support one frame.
  701:   if (mLoadedIcon)
  701:     return NS_OK;
  701: 
38855:   if (!mNativeMenuItem)
38855:     return NS_ERROR_FAILURE;
30014: 
30479:   nsCOMPtr<imgIContainer> imageContainer;
30479:   aRequest->GetImage(getter_AddRefs(imageContainer));
35630:   if (!imageContainer) {
35630:     [mNativeMenuItem setImage:nil];
30479:     return NS_ERROR_FAILURE;
35630:   }
  701: 
39390:   PRInt32 origWidth = 0, origHeight = 0;
39390:   imageContainer->GetWidth(&origWidth);
39390:   imageContainer->GetHeight(&origHeight);
  701:   
35630:   // If the image region is invalid, don't draw the image to almost match
35630:   // the behavior of other platforms.
35630:   if (!mImageRegionRect.IsEmpty() &&
35630:       (mImageRegionRect.XMost() > origWidth ||
35630:        mImageRegionRect.YMost() > origHeight)) {
35630:     [mNativeMenuItem setImage:nil];
35630:     return NS_ERROR_FAILURE;
35630:   }
35630: 
35630:   if (mImageRegionRect.IsEmpty()) {
35630:     mImageRegionRect.SetRect(0, 0, origWidth, origHeight);
35630:   }
35630:   
39829:   nsRefPtr<gfxImageSurface> frame;
39829:   nsresult rv = imageContainer->CopyFrame(  imgIContainer::FRAME_CURRENT,
39829:                                             imgIContainer::FLAG_SYNC_DECODE,
39829:                                             getter_AddRefs(frame));
39829:   if (NS_FAILED(rv) || !frame) {
39829:     [mNativeMenuItem setImage:nil];
39829:     return NS_ERROR_FAILURE;
39829:   }      
39390:   CGImageRef origImage = NULL;
39829:   rv = nsCocoaUtils::CreateCGImageFromSurface(frame, &origImage);
39390:   if (NS_FAILED(rv) || !origImage) {
39390:     [mNativeMenuItem setImage:nil];
39390:     return NS_ERROR_FAILURE;
39390:   }
38855: 
38855:   PRBool createSubImage = !(mImageRegionRect.x == 0 && mImageRegionRect.y == 0 &&
38855:                             mImageRegionRect.width == origWidth && mImageRegionRect.height == origHeight);
39390:   
39390:   CGImageRef finalImage = NULL;
38855:   if (createSubImage) {
39390:     // if mImageRegionRect is set using CSS, we need to slice a piece out of the overall 
39390:     // image to use as the icon
39390:     finalImage = ::CGImageCreateWithImageInRect(origImage, 
39390:                                                 ::CGRectMake(mImageRegionRect.x, 
39390:                                                 mImageRegionRect.y,
39390:                                                 mImageRegionRect.width,
39390:                                                 mImageRegionRect.height));
39390:     ::CGImageRelease(origImage);
39390:     if (!finalImage) {
35630:       [mNativeMenuItem setImage:nil];
  701:       return NS_ERROR_FAILURE;  
  701:     }
39390:   } else {
39390:     finalImage = origImage;
39390:   }
  701:   // The image may not be the right size for a menu icon (16x16).
  701:   // Create a new CGImage for the menu item.
  715:   PRUint8* bitmap = (PRUint8*)malloc(kIconBytes);
  701: 
39390:   CGColorSpaceRef colorSpace = ::CGColorSpaceCreateDeviceRGB();
  701: 
39390:   CGContextRef bitmapContext = ::CGBitmapContextCreate(bitmap, kIconWidth, kIconHeight,
  701:                                                        kIconBitsPerComponent,
  701:                                                        kIconBytesPerRow,
  701:                                                        colorSpace,
39390:                                                        kCGImageAlphaPremultipliedLast);
39390:   ::CGColorSpaceRelease(colorSpace);
  701:   if (!bitmapContext) {
39390:     ::CGImageRelease(finalImage);
  715:     free(bitmap);
  701:     ::CGColorSpaceRelease(colorSpace);
  701:     return NS_ERROR_FAILURE;
  701:   }
39390:   CGRect iconRect = ::CGRectMake(0, 0, kIconWidth, kIconHeight);
39829:   ::CGContextClearRect(bitmapContext, iconRect);
39390:   ::CGContextDrawImage(bitmapContext, iconRect, finalImage);
  701:   
39390:   CGImageRef iconImage = ::CGBitmapContextCreateImage(bitmapContext);
39390: 
39390:   ::CGImageRelease(finalImage);
  701:   ::CGContextRelease(bitmapContext);
39390:   free(bitmap);
  701:  
39390:   if (!iconImage) return NS_ERROR_FAILURE;
39390: 
39390:   NSImage *newImage = nil;
39390:   rv = nsCocoaUtils::CreateNSImageFromCGImage(iconImage, &newImage);
39390:   if (NS_FAILED(rv) || !newImage) {    
39390:     [mNativeMenuItem setImage:nil];
39390:     ::CGImageRelease(iconImage);
  701:     return NS_ERROR_FAILURE;
  701:   }
  701: 
 4175:   [mNativeMenuItem setImage:newImage];
 4175:   
 4175:   [newImage release];
  701:   ::CGImageRelease(iconImage);
  701: 
  701:   mLoadedIcon = PR_TRUE;
  701:   mSetIcon = PR_TRUE;
  701: 
  701:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
  701: }
  701: 
  701: NS_IMETHODIMP
  701: nsMenuItemIconX::OnStopContainer(imgIRequest*   aRequest,
  701:                                 imgIContainer* aContainer)
  701: {
  701:   return NS_OK;
  701: }
  701: 
  701: NS_IMETHODIMP
  701: nsMenuItemIconX::OnStopDecode(imgIRequest*     aRequest,
  701:                              nsresult         status,
  701:                              const PRUnichar* statusArg)
  701: {
  701:   return NS_OK;
  701: }
  701: 
  701: NS_IMETHODIMP
  701: nsMenuItemIconX::OnStopRequest(imgIRequest* aRequest,
  701:                               PRBool       aIsLastPart)
  701: {
23675:   NS_ASSERTION(mIconRequest, "NULL mIconRequest!  Multiple calls to OnStopRequest()?");
23675:   if (mIconRequest) {
  701:     mIconRequest->Cancel(NS_BINDING_ABORTED);
  701:     mIconRequest = nsnull;
23675:   }
  701:   return NS_OK;
  701: }
32424: 
32424: NS_IMETHODIMP
32424: nsMenuItemIconX::OnDiscard(imgIRequest* aRequest)
32424: {
32424:   return NS_OK;
32424: }
