     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
     1: /* vim:expandtab:shiftwidth=4:tabstop=4:
     1:  */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsDragService.h"
     1: #include "nsIObserverService.h"
     1: #include "nsWidgetsCID.h"
     1: #include "nsWindow.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsXPCOM.h"
     1: #include "nsISupportsPrimitives.h"
 22432: #include "nsIIOService.h"
 22432: #include "nsIFileURL.h"
 22432: #include "nsNetUtil.h"
     1: #include "prlog.h"
 25381: #include "nsTArray.h"
     1: #include "nsPrimitiveHelpers.h"
     1: #include "prtime.h"
     1: #include "prthread.h"
 23281: #include <gtk/gtk.h>
     1: #include <gdk/gdkx.h>
     1: #include "nsCRT.h"
 41540: #include "mozilla/Services.h"
     1: 
113945: #if (MOZ_WIDGET_GTK == 2)
 97333: #include "gtk2compat.h"
 97333: #endif
 97333: 
     1: #include "gfxASurface.h"
 15409: #include "gfxXlibSurface.h"
 15409: #include "gfxContext.h"
     1: #include "nsImageToPixbuf.h"
 10025: #include "nsPresContext.h"
 10025: #include "nsIDocument.h"
 13254: #include "nsISelection.h"
 97567: #include "nsIViewManager.h"
 77050: #include "nsIFrame.h"
     1: 
 15409: // This sets how opaque the drag image is
 15409: #define DRAG_IMAGE_ALPHA_LEVEL 0.5
 15409: 
 29409: // These values are copied from GtkDragResult (rather than using GtkDragResult
 29409: // directly) so that this code can be compiled against versions of GTK+ that
 29409: // do not have GtkDragResult.
 29409: // GtkDragResult is available from GTK+ version 2.12.
 29409: enum {
 29409:   MOZ_GTK_DRAG_RESULT_SUCCESS,
 29409:   MOZ_GTK_DRAG_RESULT_NO_TARGET
 29409: };
 29409: 
 61356: // Some gobject functions expect functions for gpointer arguments.
 61356: // gpointer is void* but C++ doesn't like casting functions to void*.
 61356: template<class T> static inline gpointer
 61356: FuncToGpointer(T aFunction)
 61356: {
 61356:     return reinterpret_cast<gpointer>
 61356:         (reinterpret_cast<uintptr_t>
 61356:          // This cast just provides a warning if T is not a function.
 61356:          (reinterpret_cast<void (*)()>(aFunction)));
 61356: }
 61356: 
     1: static PRLogModuleInfo *sDragLm = NULL;
 97568: 
 97568: // data used for synthetic periodic motion events sent to the source widget
 97568: // grabbing real events for the drag.
 61356: static guint sMotionEventTimerID;
 97568: static GdkEvent *sMotionEvent;
 97568: static GtkWidget *sGrabWidget;
     1: 
     1: static const char gMimeListType[] = "application/x-moz-internal-item-list";
     1: static const char gMozUrlType[] = "_NETSCAPE_URL";
     1: static const char gTextUriListType[] = "text/uri-list";
 32484: static const char gTextPlainUTF8Type[] = "text/plain;charset=utf-8";
     1: 
     1: static void
 72984: invisibleSourceDragBegin(GtkWidget        *aWidget,
 72984:                          GdkDragContext   *aContext,
 72984:                          gpointer          aData);
 72984: 
 72984: static void
     1: invisibleSourceDragEnd(GtkWidget        *aWidget,
     1:                        GdkDragContext   *aContext,
     1:                        gpointer          aData);
     1: 
 29409: static gboolean
 29409: invisibleSourceDragFailed(GtkWidget        *aWidget,
 29409:                           GdkDragContext   *aContext,
 29409:                           gint              aResult,
 29409:                           gpointer          aData);
 29409: 
     1: static void
     1: invisibleSourceDragDataGet(GtkWidget        *aWidget,
     1:                            GdkDragContext   *aContext,
     1:                            GtkSelectionData *aSelectionData,
     1:                            guint             aInfo,
     1:                            guint32           aTime,
     1:                            gpointer          aData);
     1: 
     1: nsDragService::nsDragService()
 98176:     : mScheduledTask(eDragTaskNone)
 98176:     , mTaskSource(0)
     1: {
     1:     // We have to destroy the hidden widget before the event loop stops
     1:     // running.
     1:     nsCOMPtr<nsIObserverService> obsServ =
 41540:         mozilla::services::GetObserverService();
 79636:     obsServ->AddObserver(this, "quit-application", false);
     1: 
     1:     // our hidden source widget
 97567:     mHiddenWidget = gtk_window_new(GTK_WINDOW_POPUP);
     1:     // make sure that the widget is realized so that
     1:     // we can use it as a drag source.
     1:     gtk_widget_realize(mHiddenWidget);
     1:     // hook up our internal signals so that we can get some feedback
     1:     // from our drag source
 72984:     g_signal_connect(mHiddenWidget, "drag_begin",
 72984:                      G_CALLBACK(invisibleSourceDragBegin), this);
 69924:     g_signal_connect(mHiddenWidget, "drag_data_get",
 24530:                      G_CALLBACK(invisibleSourceDragDataGet), this);
 69924:     g_signal_connect(mHiddenWidget, "drag_end",
 24530:                      G_CALLBACK(invisibleSourceDragEnd), this);
 29409:     // drag-failed is available from GTK+ version 2.12
 29409:     guint dragFailedID = g_signal_lookup("drag-failed",
 29409:                                          G_TYPE_FROM_INSTANCE(mHiddenWidget));
 29409:     if (dragFailedID) {
 29409:         g_signal_connect_closure_by_id(mHiddenWidget, dragFailedID, 0,
 29409:                                        g_cclosure_new(G_CALLBACK(invisibleSourceDragFailed),
 29409:                                                       this, NULL),
 29409:                                        FALSE);
 29409:     }
     1: 
     1:     // set up our logging module
     1:     if (!sDragLm)
     1:         sDragLm = PR_NewLogModule("nsDragService");
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::nsDragService"));
 79636:     mCanDrop = false;
 79636:     mTargetDragDataReceived = false;
     1:     mTargetDragData = 0;
     1:     mTargetDragDataLen = 0;
     1: }
     1: 
     1: nsDragService::~nsDragService()
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::~nsDragService"));
 97331:     if (mTaskSource)
 97331:         g_source_remove(mTaskSource);
 97331: 
     1: }
     1: 
 97334: NS_IMPL_ISUPPORTS_INHERITED1(nsDragService, nsBaseDragService, nsIObserver)
  4345: 
 97330: /* static */ nsDragService*
 97330: nsDragService::GetInstance()
 97330: {
 97330:     static const nsIID iid = NS_DRAGSERVICE_CID;
 97330:     nsCOMPtr<nsIDragService> dragService = do_GetService(iid);
 97330:     return static_cast<nsDragService*>(dragService.get());
 97330:     // We rely on XPCOM keeping a reference to the service.
 97330: }
 97330: 
     1: // nsIObserver
     1: 
     1: NS_IMETHODIMP
     1: nsDragService::Observe(nsISupports *aSubject, const char *aTopic,
     1:                        const PRUnichar *aData)
     1: {
     1:   if (!nsCRT::strcmp(aTopic, "quit-application")) {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:            ("nsDragService::Observe(\"quit-application\")"));
     1:     if (mHiddenWidget) {
     1:       gtk_widget_destroy(mHiddenWidget);
     1:       mHiddenWidget = 0;
     1:     }
     1:     TargetResetData();
     1:   } else {
     1:     NS_NOTREACHED("unexpected topic");
     1:     return NS_ERROR_UNEXPECTED;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 61356: // Support for periodic drag events
 61356: 
 61356: // http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#drag-and-drop-processing-model
 61356: // and the Xdnd protocol both recommend that drag events are sent periodically,
 61356: // but GTK does not normally provide this.
 61356: //
 61356: // Here GTK is periodically stimulated by copies of the most recent mouse
 61356: // motion events so as to send drag position messages to the destination when
 61356: // appropriate (after it has received a status event from the previous
 61356: // message).
 61356: //
 61356: // (If events were sent only on the destination side then the destination
 61356: // would have no message to which it could reply with a drag status.  Without
 61356: // sending a drag status to the source, the destination would not be able to
 61356: // change its feedback re whether it could accept the drop, and so the
 61356: // source's behavior on drop will not be consistent.)
 61356: 
 61356: static gboolean
 61356: DispatchMotionEventCopy(gpointer aData)
 61356: {
 97568:     // Clear the timer id before OnSourceGrabEventAfter is called during event
 97568:     // dispatch.
 61356:     sMotionEventTimerID = 0;
 61356: 
 97568:     GdkEvent *event = sMotionEvent;
 97568:     sMotionEvent = NULL;
 61356:     // If there is no longer a grab on the widget, then the drag is over and
 61356:     // there is no need to continue drag motion.
 97568:     if (gtk_widget_has_grab(sGrabWidget)) {
 97568:         gtk_propagate_event(sGrabWidget, event);
 61356:     }
 97568:     gdk_event_free(event);
 61356: 
 61356:     // Cancel this timer;
 61356:     // We've already started another if the motion event was dispatched.
 61356:     return FALSE;
 61356: }
 61356: 
 61356: static void
 61356: OnSourceGrabEventAfter(GtkWidget *widget, GdkEvent *event, gpointer user_data)
 61356: {
 97568:     // If there is no longer a grab on the widget, then the drag motion is
 97568:     // over (though the data may not be fetched yet).
 97568:     if (!gtk_widget_has_grab(sGrabWidget))
 61356:         return;
 61356: 
 97568:     if (event->type == GDK_MOTION_NOTIFY) {
 97568:         if (sMotionEvent) {
 97568:             gdk_event_free(sMotionEvent);
 61356:         }
 97568:         sMotionEvent = gdk_event_copy(event);
 95558: 
 95558:         // Update the cursor position.  The last of these recorded gets used for
 95558:         // the NS_DRAGDROP_END event.
 95558:         nsDragService *dragService = static_cast<nsDragService*>(user_data);
 97568:         dragService->SetDragEndPoint(nsIntPoint(event->motion.x_root,
 97568:                                                 event->motion.y_root));
 97568:     } else if (sMotionEvent && (event->type != GDK_KEY_PRESS ||
 97568:                                 event->type != GDK_KEY_RELEASE)) {
 97568:         // Update modifier state from keypress events.
 97568:         sMotionEvent->motion.state = event->key.state;
 97568:     } else {
 97568:         return;
 97568:     }
 95558: 
 97568:     if (sMotionEventTimerID) {
 97568:         g_source_remove(sMotionEventTimerID);
 97568:     }
 61356: 
 61356:     // G_PRIORITY_DEFAULT_IDLE is lower priority than GDK's redraw idle source
 61356:     // and lower than GTK's idle source that sends drag position messages after
 61356:     // motion-notify signals.
 61356:     //
 61356:     // http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#drag-and-drop-processing-model
 61356:     // recommends an interval of 350ms +/- 200ms.
 61356:     sMotionEventTimerID = 
 61356:         g_timeout_add_full(G_PRIORITY_DEFAULT_IDLE, 350,
 97568:                            DispatchMotionEventCopy, NULL, NULL);
 61356: }
 61356: 
 97567: static GtkWindow*
 97567: GetGtkWindow(nsIDOMDocument *aDocument)
 97567: {
 97567:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(aDocument);
 97567:     if (!doc)
 97567:         return NULL;
 97567: 
 97567:     nsCOMPtr<nsIPresShell> presShell = doc->GetShell();
 97567:     if (!presShell)
 97567:         return NULL;
 97567: 
 97567:     nsCOMPtr<nsIViewManager> vm = presShell->GetViewManager();
 97567:     if (!vm)
 97567:         return NULL;
 97567: 
 97567:     nsCOMPtr<nsIWidget> widget;
 97567:     vm->GetRootWidget(getter_AddRefs(widget));
 97567:     if (!widget)
 97567:         return NULL;
 97567: 
 97567:     GtkWidget *gtkWidget =
 97567:         static_cast<nsWindow*>(widget.get())->GetMozContainerWidget();
 97567:     if (!gtkWidget)
 97567:         return NULL;
 97567: 
 97567:     GtkWidget *toplevel = NULL;
 97567:     toplevel = gtk_widget_get_toplevel(gtkWidget);
 97567:     if (!GTK_IS_WINDOW(toplevel))
 97567:         return NULL;
 97567: 
 97567:     return GTK_WINDOW(toplevel);
 97567: }   
 97567: 
     1: // nsIDragService
     1: 
     1: NS_IMETHODIMP
     1: nsDragService::InvokeDragSession(nsIDOMNode *aDOMNode,
     1:                                  nsISupportsArray * aArrayTransferables,
     1:                                  nsIScriptableRegion * aRegion,
108991:                                  uint32_t aActionType)
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::InvokeDragSession"));
 97335: 
 97335:     // If the previous source drag has not yet completed, signal handlers need
 97568:     // to be removed from sGrabWidget and dragend needs to be dispatched to
 97335:     // the source node, but we can't call EndDragSession yet because we don't
 97335:     // know whether or not the drag succeeded.
 97335:     if (mSourceNode)
 97335:         return NS_ERROR_NOT_AVAILABLE;
 97335: 
 13306:     nsresult rv = nsBaseDragService::InvokeDragSession(aDOMNode,
 13306:                                                        aArrayTransferables,
     1:                                                        aRegion, aActionType);
 13306:     NS_ENSURE_SUCCESS(rv, rv);
 13306: 
     1:     // make sure that we have an array of transferables to use
     1:     if (!aArrayTransferables)
     1:         return NS_ERROR_INVALID_ARG;
     1:     // set our reference to the transferables.  this will also addref
     1:     // the transferables since we're going to hang onto this beyond the
     1:     // length of this call
     1:     mSourceDataItems = aArrayTransferables;
     1:     // get the list of items we offer for drags
 25274:     GtkTargetList *sourceList = GetSourceList();
     1: 
 25274:     if (!sourceList)
 25274:         return NS_OK;
     1: 
 72984:     // stored temporarily until the drag-begin signal has been received
 72984:     mSourceRegion = aRegion;
 72984: 
     1:     // save our action type
     1:     GdkDragAction action = GDK_ACTION_DEFAULT;
     1: 
     1:     if (aActionType & DRAGDROP_ACTION_COPY)
     1:         action = (GdkDragAction)(action | GDK_ACTION_COPY);
     1:     if (aActionType & DRAGDROP_ACTION_MOVE)
     1:         action = (GdkDragAction)(action | GDK_ACTION_MOVE);
     1:     if (aActionType & DRAGDROP_ACTION_LINK)
     1:         action = (GdkDragAction)(action | GDK_ACTION_LINK);
     1: 
 89550:     // Create a fake event for the drag so we can pass the time (so to speak).
 89550:     // If we don't do this, then, when the timestamp for the pending button
 89550:     // release event is used for the ungrab, the ungrab can fail due to the
 89550:     // timestamp being _earlier_ than CurrentTime.
     1:     GdkEvent event;
     1:     memset(&event, 0, sizeof(GdkEvent));
     1:     event.type = GDK_BUTTON_PRESS;
113945:     event.button.window = gtk_widget_get_window(mHiddenWidget);
 90019:     event.button.time = nsWindow::GetLastUserInputTime();
     1: 
 97567:     // Put the drag widget in the window group of the source node so that the
 97567:     // gtk_grab_add during gtk_drag_begin is effective.
 97567:     // gtk_window_get_group(NULL) returns the default window group.
 97567:     GtkWindowGroup *window_group =
 97567:         gtk_window_get_group(GetGtkWindow(mSourceDocument));
 97567:     gtk_window_group_add_window(window_group,
 97567:                                 GTK_WINDOW(mHiddenWidget));
 97567: 
113945: #if (MOZ_WIDGET_GTK == 3)
113945:     // Get device for event source
113945:     GdkDisplay *display = gdk_display_get_default();
113945:     GdkDeviceManager *device_manager = gdk_display_get_device_manager(display);
113945:     event.button.device = gdk_device_manager_get_client_pointer(device_manager);
113945: #endif
113945:   
     1:     // start our drag.
     1:     GdkDragContext *context = gtk_drag_begin(mHiddenWidget,
     1:                                              sourceList,
     1:                                              action,
     1:                                              1,
     1:                                              &event);
     1: 
106838:     mSourceRegion = nullptr;
     1: 
 72984:     if (context) {
 89546:         StartDragSession();
 89546: 
 61356:         // GTK uses another hidden window for receiving mouse events.
 97568:         sGrabWidget = gtk_window_group_get_current_grab(window_group);
 97568:         if (sGrabWidget) {
 97568:             g_object_ref(sGrabWidget);
 97568:             // Only motion and key events are required but connect to
 61356:             // "event-after" as this is never blocked by other handlers.
 97568:             g_signal_connect(sGrabWidget, "event-after",
 95558:                              G_CALLBACK(OnSourceGrabEventAfter), this);
 61356:         }
 95558:         // We don't have a drag end point yet.
 95558:         mEndDragPoint = nsIntPoint(-1, -1);
 25274:     }
 72984:     else {
 72984:         rv = NS_ERROR_FAILURE;
 72984:     }
  2467: 
     1:     gtk_target_list_unref(sourceList);
     1: 
 25274:     return rv;
     1: }
     1: 
 79445: bool
 15409: nsDragService::SetAlphaPixmap(gfxASurface *aSurface,
 15409:                                  GdkDragContext *aContext,
108991:                                  int32_t aXOffset,
108991:                                  int32_t aYOffset,
 23738:                                  const nsIntRect& dragRect)
 15409: {
113945: #if (MOZ_WIDGET_GTK == 2)
 15409:     GdkScreen* screen = gtk_widget_get_screen(mHiddenWidget);
 15409: 
 15409:     // Transparent drag icons need, like a lot of transparency-related things,
 15409:     // a compositing X window manager
 15409:     if (!gdk_screen_is_composited(screen))
 79636:       return false;
 15409: 
 15409:     GdkColormap* alphaColormap = gdk_screen_get_rgba_colormap(screen);
 15409:     if (!alphaColormap)
 79636:       return false;
 15409: 
 15409:     GdkPixmap* pixmap = gdk_pixmap_new(NULL, dragRect.width, dragRect.height,
 15409:                                        gdk_colormap_get_visual(alphaColormap)->depth);
 15409:     if (!pixmap)
 79636:       return false;
 15409: 
 15409:     gdk_drawable_set_colormap(GDK_DRAWABLE(pixmap), alphaColormap);
 15409: 
 15409:     // Make a gfxXlibSurface wrapped around the pixmap to render on
 15409:     nsRefPtr<gfxASurface> xPixmapSurface =
 15409:          nsWindow::GetSurfaceForGdkDrawable(GDK_DRAWABLE(pixmap),
 15409:                                             dragRect.Size());
 15409:     if (!xPixmapSurface)
 79636:       return false;
 15409: 
 15409:     nsRefPtr<gfxContext> xPixmapCtx = new gfxContext(xPixmapSurface);
 15409: 
 15409:     // Clear it...
 15409:     xPixmapCtx->SetOperator(gfxContext::OPERATOR_CLEAR);
 15409:     xPixmapCtx->Paint();
 15409: 
 15409:     // ...and paint the drag image with translucency
 15409:     xPixmapCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
 15409:     xPixmapCtx->SetSource(aSurface);
 15409:     xPixmapCtx->Paint(DRAG_IMAGE_ALPHA_LEVEL);
 15409: 
 15409:     // The drag transaction addrefs the pixmap, so we can just unref it from us here
 15409:     gtk_drag_set_icon_pixmap(aContext, alphaColormap, pixmap, NULL,
 15409:                              aXOffset, aYOffset);
 24530:     g_object_unref(pixmap);
 79636:     return true;
113945: #else
113945:     // TODO GTK3
113945:     return false;
113945: #endif
 15409: }
 15409: 
     1: NS_IMETHODIMP
     1: nsDragService::StartDragSession()
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::StartDragSession"));
     1:     return nsBaseDragService::StartDragSession();
     1: }
     1:  
     1: NS_IMETHODIMP
 79445: nsDragService::EndDragSession(bool aDoneDrag)
     1: {
 29217:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::EndDragSession %d",
 29217:                                    aDoneDrag));
 61356: 
 97568:     if (sGrabWidget) {
 97568:         g_signal_handlers_disconnect_by_func(sGrabWidget,
 95558:              FuncToGpointer(OnSourceGrabEventAfter), this);
 97568:         g_object_unref(sGrabWidget);
 97568:         sGrabWidget = NULL;
 61356: 
 61356:         if (sMotionEventTimerID) {
 61356:             g_source_remove(sMotionEventTimerID);
 61356:             sMotionEventTimerID = 0;
 61356:         }
 97568:         if (sMotionEvent) {
 97568:             gdk_event_free(sMotionEvent);
 97568:             sMotionEvent = NULL;
 97568:         }
 61356:     }
 61356: 
     1:     // unset our drag action
     1:     SetDragAction(DRAGDROP_ACTION_NONE);
   482:     return nsBaseDragService::EndDragSession(aDoneDrag);
     1: }
     1: 
     1: // nsIDragSession
     1: NS_IMETHODIMP
 79445: nsDragService::SetCanDrop(bool aCanDrop)
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::SetCanDrop %d",
     1:                                    aCanDrop));
     1:     mCanDrop = aCanDrop;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsDragService::GetCanDrop(bool *aCanDrop)
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::GetCanDrop"));
     1:     *aCanDrop = mCanDrop;
     1:     return NS_OK;
     1: }
     1: 
     1: // count the number of URIs in some text/uri-list format data.
108991: static uint32_t
     1: CountTextUriListItems(const char *data,
108991:                       uint32_t datalen)
     1: {
     1:     const char *p = data;
     1:     const char *endPtr = p + datalen;
108991:     uint32_t count = 0;
     1: 
     1:     while (p < endPtr) {
     1:         // skip whitespace (if any)
     1:         while (p < endPtr && *p != '\0' && isspace(*p))
     1:             p++;
     1:         // if we aren't at the end of the line ...
     1:         if (p != endPtr && *p != '\0' && *p != '\n' && *p != '\r')
     1:             count++;
     1:         // skip to the end of the line
     1:         while (p < endPtr && *p != '\0' && *p != '\n')
     1:             p++;
     1:         p++; // skip the actual newline as well.
     1:     }
     1:     return count;
     1: }
     1: 
     1: // extract an item from text/uri-list formatted data and convert it to
     1: // unicode.
     1: static void
     1: GetTextUriListItem(const char *data,
108991:                    uint32_t datalen,
108991:                    uint32_t aItemIndex,
     1:                    PRUnichar **convertedText,
108991:                    int32_t *convertedTextLen)
     1: {
     1:     const char *p = data;
     1:     const char *endPtr = p + datalen;
     1:     unsigned int count = 0;
     1: 
106838:     *convertedText = nullptr;
     1:     while (p < endPtr) {
     1:         // skip whitespace (if any)
     1:         while (p < endPtr && *p != '\0' && isspace(*p))
     1:             p++;
     1:         // if we aren't at the end of the line, we have a url
     1:         if (p != endPtr && *p != '\0' && *p != '\n' && *p != '\r')
     1:             count++;
     1:         // this is the item we are after ...
     1:         if (aItemIndex + 1 == count) {
     1:             const char *q = p;
     1:             while (q < endPtr && *q != '\0' && *q != '\n' && *q != '\r')
     1:               q++;
     1:             nsPrimitiveHelpers::ConvertPlatformPlainTextToUnicode(
     1:                                 p, q - p, convertedText, convertedTextLen);
     1:             break;
     1:         }
     1:         // skip to the end of the line
     1:         while (p < endPtr && *p != '\0' && *p != '\n')
     1:             p++;
     1:         p++; // skip the actual newline as well.
     1:     }
     1: 
     1:     // didn't find the desired item, so just pass the whole lot
     1:     if (!*convertedText) {
     1:         nsPrimitiveHelpers::ConvertPlatformPlainTextToUnicode(
     1:                             data, datalen, convertedText, convertedTextLen);
     1:     }
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsDragService::GetNumDropItems(uint32_t * aNumItems)
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::GetNumDropItems"));
 95563: 
 95563:     if (!mTargetWidget) {
 95563:         PR_LOG(sDragLm, PR_LOG_DEBUG,
 95563:                ("*** warning: GetNumDropItems \
 95563:                called without a valid target widget!\n"));
 95563:         *aNumItems = 0;
 95563:         return NS_OK;
 95563:     }
 95563: 
 79445:     bool isList = IsTargetContextList();
     1:     if (isList)
     1:         mSourceDataItems->Count(aNumItems);
     1:     else {
     1:         GdkAtom gdkFlavor = gdk_atom_intern(gTextUriListType, FALSE);
     1:         GetTargetDragData(gdkFlavor);
     1:         if (mTargetDragData) {
  3233:             const char *data = reinterpret_cast<char*>(mTargetDragData);
     1:             *aNumItems = CountTextUriListItems(data, mTargetDragDataLen);
     1:         } else
     1:             *aNumItems = 1;
     1:     }
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("%d items", *aNumItems));
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsDragService::GetData(nsITransferable * aTransferable,
108991:                        uint32_t aItemIndex)
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::GetData %d", aItemIndex));
     1: 
     1:     // make sure that we have a transferable
     1:     if (!aTransferable)
     1:         return NS_ERROR_INVALID_ARG;
     1: 
 95563:     if (!mTargetWidget) {
 95563:         PR_LOG(sDragLm, PR_LOG_DEBUG,
 95563:                ("*** warning: GetData \
 95563:                called without a valid target widget!\n"));
 95563:         return NS_ERROR_FAILURE;
 95563:     }
 95563: 
     1:     // get flavor list that includes all acceptable flavors (including
     1:     // ones obtained through conversion). Flavors are nsISupportsStrings
     1:     // so that they can be seen from JS.
     1:     nsCOMPtr<nsISupportsArray> flavorList;
 95563:     nsresult rv = aTransferable->FlavorsTransferableCanImport(
     1:                         getter_AddRefs(flavorList));
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
     1:     // count the number of flavors
108991:     uint32_t cnt;
     1:     flavorList->Count(&cnt);
     1:     unsigned int i;
     1: 
     1:     // check to see if this is an internal list
 79445:     bool isList = IsTargetContextList();
     1: 
     1:     if (isList) {
     1:         PR_LOG(sDragLm, PR_LOG_DEBUG, ("it's a list..."));
  3400:         // find a matching flavor
  3400:         for (i = 0; i < cnt; ++i) {
     1:             nsCOMPtr<nsISupports> genericWrapper;
  3400:             flavorList->GetElementAt(i, getter_AddRefs(genericWrapper));
     1:             nsCOMPtr<nsISupportsCString> currentFlavor;
     1:             currentFlavor = do_QueryInterface(genericWrapper);
  3400:             if (!currentFlavor)
  3400:                 continue;
  3400: 
     1:             nsXPIDLCString flavorStr;
     1:             currentFlavor->ToString(getter_Copies(flavorStr));
     1:             PR_LOG(sDragLm,
     1:                    PR_LOG_DEBUG,
     1:                    ("flavor is %s\n", (const char *)flavorStr));
     1:             // get the item with the right index
     1:             nsCOMPtr<nsISupports> genericItem;
     1:             mSourceDataItems->GetElementAt(aItemIndex,
     1:                                            getter_AddRefs(genericItem));
     1:             nsCOMPtr<nsITransferable> item(do_QueryInterface(genericItem));
  3400:             if (!item)
  3400:                 continue;
  3400: 
     1:             nsCOMPtr<nsISupports> data;
108991:             uint32_t tmpDataLen = 0;
     1:             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                    ("trying to get transfer data for %s\n",
     1:                    (const char *)flavorStr));
     1:             rv = item->GetTransferData(flavorStr,
     1:                                        getter_AddRefs(data),
     1:                                        &tmpDataLen);
     1:             if (NS_FAILED(rv)) {
     1:                 PR_LOG(sDragLm, PR_LOG_DEBUG, ("failed.\n"));
  3400:                 continue;
     1:             }
     1:             PR_LOG(sDragLm, PR_LOG_DEBUG, ("succeeded.\n"));
     1:             rv = aTransferable->SetTransferData(flavorStr,data,tmpDataLen);
     1:             if (NS_FAILED(rv)) {
     1:                 PR_LOG(sDragLm,
     1:                        PR_LOG_DEBUG,
     1:                        ("fail to set transfer data into transferable!\n"));
  3400:                 continue;
     1:             }
     1:             // ok, we got the data
     1:             return NS_OK;
     1:         }
     1:         // if we got this far, we failed
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     // Now walk down the list of flavors. When we find one that is
     1:     // actually present, copy out the data into the transferable in that
     1:     // format. SetTransferData() implicitly handles conversions.
     1:     for ( i = 0; i < cnt; ++i ) {
     1:         nsCOMPtr<nsISupports> genericWrapper;
     1:         flavorList->GetElementAt(i,getter_AddRefs(genericWrapper));
     1:         nsCOMPtr<nsISupportsCString> currentFlavor;
     1:         currentFlavor = do_QueryInterface(genericWrapper);
     1:         if (currentFlavor) {
     1:             // find our gtk flavor
     1:             nsXPIDLCString flavorStr;
     1:             currentFlavor->ToString(getter_Copies(flavorStr));
     1:             GdkAtom gdkFlavor = gdk_atom_intern(flavorStr, FALSE);
     1:             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                    ("looking for data in type %s, gdk flavor %ld\n",
  3233:                    static_cast<const char*>(flavorStr), gdkFlavor));
 79445:             bool dataFound = false;
     1:             if (gdkFlavor) {
     1:                 GetTargetDragData(gdkFlavor);
     1:             }
     1:             if (mTargetDragData) {
 79636:                 PR_LOG(sDragLm, PR_LOG_DEBUG, ("dataFound = true\n"));
 79636:                 dataFound = true;
     1:             }
     1:             else {
 79636:                 PR_LOG(sDragLm, PR_LOG_DEBUG, ("dataFound = false\n"));
 12780: 
 22432:                 // Dragging and dropping from the file manager would cause us 
101111:                 // to parse the source text as a nsIFile URL.
 12780:                 if ( strcmp(flavorStr, kFileMime) == 0 ) {
 12780:                     gdkFlavor = gdk_atom_intern(kTextMime, FALSE);
 12780:                     GetTargetDragData(gdkFlavor);
 12780:                     if (mTargetDragData) {
 12780:                         const char* text = static_cast<char*>(mTargetDragData);
106838:                         PRUnichar* convertedText = nullptr;
108991:                         int32_t convertedTextLen = 0;
 14400: 
 14400:                         GetTextUriListItem(text, mTargetDragDataLen, aItemIndex,
 14400:                                            &convertedText, &convertedTextLen);
 14400: 
 14400:                         if (convertedText) {
 22432:                             nsCOMPtr<nsIIOService> ioService = do_GetIOService(&rv);
 22432:                             nsCOMPtr<nsIURI> fileURI;
 22432:                             nsresult rv = ioService->NewURI(NS_ConvertUTF16toUTF8(convertedText),
106838:                                                             nullptr, nullptr, getter_AddRefs(fileURI));
 12780:                             if (NS_SUCCEEDED(rv)) {
 22432:                                 nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(fileURI, &rv);
 22432:                                 if (NS_SUCCEEDED(rv)) {
 22432:                                     nsCOMPtr<nsIFile> file;
 22432:                                     rv = fileURL->GetFile(getter_AddRefs(file));
 22432:                                     if (NS_SUCCEEDED(rv)) {
 22432:                                         // The common wrapping code at the end of 
 22432:                                         // this function assumes the data is text
 12780:                                         // and calls text-specific operations.
101111:                                         // Make a secret hideout here for nsIFile
 22432:                                         // objects and return early.
 12780:                                         aTransferable->SetTransferData(flavorStr, file,
 22432:                                                                        convertedTextLen);
 14400:                                         g_free(convertedText);
 12780:                                         return NS_OK;
 12780:                                     }
 22432:                                 }
 22432:                             }
 14400:                             g_free(convertedText);
 14400:                         }
 12780:                         continue;
 12780:                     }
 12780:                 }
 12780: 
     1:                 // if we are looking for text/unicode and we fail to find it
     1:                 // on the clipboard first, try again with text/plain. If that
     1:                 // is present, convert it to unicode.
     1:                 if ( strcmp(flavorStr, kUnicodeMime) == 0 ) {
     1:                     PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                            ("we were looking for text/unicode... \
 32484:                            trying with text/plain;charset=utf-8\n"));
 32484:                     gdkFlavor = gdk_atom_intern(gTextPlainUTF8Type, FALSE);
 32484:                     GetTargetDragData(gdkFlavor);
 32484:                     if (mTargetDragData) {
 32484:                         PR_LOG(sDragLm, PR_LOG_DEBUG, ("Got textplain data\n"));
 32484:                         const char* castedText =
 32484:                                     reinterpret_cast<char*>(mTargetDragData);
106838:                         PRUnichar* convertedText = nullptr;
 32484:                         NS_ConvertUTF8toUTF16 ucs2string(castedText,
 32484:                                                          mTargetDragDataLen);
 32484:                         convertedText = ToNewUnicode(ucs2string);
 32484:                         if ( convertedText ) {
 32484:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
 32484:                                    ("successfully converted plain text \
 32484:                                    to unicode.\n"));
 32484:                             // out with the old, in with the new
 32484:                             g_free(mTargetDragData);
 32484:                             mTargetDragData = convertedText;
 32484:                             mTargetDragDataLen = ucs2string.Length() * 2;
 79636:                             dataFound = true;
 32484:                         } // if plain text data on clipboard
 32484:                     } else {
 32484:                         PR_LOG(sDragLm, PR_LOG_DEBUG,
 32484:                                ("we were looking for text/unicode... \
     1:                                trying again with text/plain\n"));
     1:                         gdkFlavor = gdk_atom_intern(kTextMime, FALSE);
     1:                         GetTargetDragData(gdkFlavor);
     1:                         if (mTargetDragData) {
     1:                             PR_LOG(sDragLm, PR_LOG_DEBUG, ("Got textplain data\n"));
     1:                             const char* castedText =
  3233:                                         reinterpret_cast<char*>(mTargetDragData);
106838:                             PRUnichar* convertedText = nullptr;
108991:                             int32_t convertedTextLen = 0;
     1:                             nsPrimitiveHelpers::ConvertPlatformPlainTextToUnicode(
     1:                                                 castedText, mTargetDragDataLen,
     1:                                                 &convertedText, &convertedTextLen);
     1:                             if ( convertedText ) {
     1:                                 PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                        ("successfully converted plain text \
     1:                                        to unicode.\n"));
     1:                                 // out with the old, in with the new
     1:                                 g_free(mTargetDragData);
     1:                                 mTargetDragData = convertedText;
     1:                                 mTargetDragDataLen = convertedTextLen * 2;
 79636:                                 dataFound = true;
     1:                             } // if plain text data on clipboard
     1:                         } // if plain text flavor present
 32484:                     } // if plain text charset=utf-8 flavor present
     1:                 } // if looking for text/unicode
     1: 
     1:                 // if we are looking for text/x-moz-url and we failed to find
     1:                 // it on the clipboard, try again with text/uri-list, and then
     1:                 // _NETSCAPE_URL
     1:                 if (strcmp(flavorStr, kURLMime) == 0) {
     1:                     PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                            ("we were looking for text/x-moz-url...\
     1:                            trying again with text/uri-list\n"));
     1:                     gdkFlavor = gdk_atom_intern(gTextUriListType, FALSE);
     1:                     GetTargetDragData(gdkFlavor);
     1:                     if (mTargetDragData) {
     1:                         PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                ("Got text/uri-list data\n"));
     1:                         const char *data =
  3233:                                    reinterpret_cast<char*>(mTargetDragData);
106838:                         PRUnichar* convertedText = nullptr;
108991:                         int32_t convertedTextLen = 0;
     1: 
     1:                         GetTextUriListItem(data, mTargetDragDataLen, aItemIndex,
     1:                                            &convertedText, &convertedTextLen);
     1: 
     1:                         if ( convertedText ) {
     1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                    ("successfully converted \
     1:                                    _NETSCAPE_URL to unicode.\n"));
     1:                             // out with the old, in with the new
     1:                             g_free(mTargetDragData);
     1:                             mTargetDragData = convertedText;
     1:                             mTargetDragDataLen = convertedTextLen * 2;
 79636:                             dataFound = true;
     1:                         }
     1:                     }
     1:                     else {
     1:                         PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                ("failed to get text/uri-list data\n"));
     1:                     }
     1:                     if (!dataFound) {
     1:                         PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                ("we were looking for text/x-moz-url...\
     1:                                trying again with _NETSCAP_URL\n"));
     1:                         gdkFlavor = gdk_atom_intern(gMozUrlType, FALSE);
     1:                         GetTargetDragData(gdkFlavor);
     1:                         if (mTargetDragData) {
     1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                    ("Got _NETSCAPE_URL data\n"));
     1:                             const char* castedText =
  3233:                                   reinterpret_cast<char*>(mTargetDragData);
106838:                             PRUnichar* convertedText = nullptr;
108991:                             int32_t convertedTextLen = 0;
     1:                             nsPrimitiveHelpers::ConvertPlatformPlainTextToUnicode(castedText, mTargetDragDataLen, &convertedText, &convertedTextLen);
     1:                             if ( convertedText ) {
     1:                                 PR_LOG(sDragLm,
     1:                                        PR_LOG_DEBUG,
     1:                                        ("successfully converted _NETSCAPE_URL \
     1:                                        to unicode.\n"));
     1:                                 // out with the old, in with the new
     1:                                 g_free(mTargetDragData);
     1:                                 mTargetDragData = convertedText;
     1:                                 mTargetDragDataLen = convertedTextLen * 2;
 79636:                                 dataFound = true;
     1:                             }
     1:                         }
     1:                         else {
     1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                    ("failed to get _NETSCAPE_URL data\n"));
     1:                         }
     1:                     }
     1:                 }
     1: 
     1:             } // else we try one last ditch effort to find our data
     1: 
     1:             if (dataFound) {
     1:                 // the DOM only wants LF, so convert from MacOS line endings
     1:                 // to DOM line endings.
     1:                 nsLinebreakHelpers::ConvertPlatformToDOMLinebreaks(
     1:                              flavorStr,
     1:                              &mTargetDragData,
  3233:                              reinterpret_cast<int*>(&mTargetDragDataLen));
     1:         
     1:                 // put it into the transferable.
     1:                 nsCOMPtr<nsISupports> genericDataWrapper;
     1:                 nsPrimitiveHelpers::CreatePrimitiveForData(flavorStr,
     1:                                     mTargetDragData, mTargetDragDataLen,
     1:                                     getter_AddRefs(genericDataWrapper));
     1:                 aTransferable->SetTransferData(flavorStr,
     1:                                                genericDataWrapper,
     1:                                                mTargetDragDataLen);
     1:                 // we found one, get out of this loop!
     1:                 PR_LOG(sDragLm, PR_LOG_DEBUG, ("dataFound and converted!\n"));
     1:                 break;
     1:             }
     1:         } // if (currentFlavor)
     1:     } // foreach flavor
     1: 
     1:     return NS_OK;
     1:   
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDragService::IsDataFlavorSupported(const char *aDataFlavor,
 79445:                                      bool *_retval)
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::IsDataFlavorSupported %s",
     1:                                    aDataFlavor));
     1:     if (!_retval)
     1:         return NS_ERROR_INVALID_ARG;
     1: 
     1:     // set this to no by default
 79636:     *_retval = false;
     1: 
     1:     // check to make sure that we have a drag object set, here
 95563:     if (!mTargetWidget) {
     1:         PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                ("*** warning: IsDataFlavorSupported \
 95563:                called without a valid target widget!\n"));
     1:         return NS_OK;
     1:     }
     1: 
     1:     // check to see if the target context is a list.
 79445:     bool isList = IsTargetContextList();
     1:     // if it is, just look in the internal data since we are the source
     1:     // for it.
     1:     if (isList) {
     1:         PR_LOG(sDragLm, PR_LOG_DEBUG, ("It's a list.."));
108991:         uint32_t numDragItems = 0;
     1:         // if we don't have mDataItems we didn't start this drag so it's
     1:         // an external client trying to fool us.
     1:         if (!mSourceDataItems)
     1:             return NS_OK;
     1:         mSourceDataItems->Count(&numDragItems);
108991:         for (uint32_t itemIndex = 0; itemIndex < numDragItems; ++itemIndex) {
     1:             nsCOMPtr<nsISupports> genericItem;
     1:             mSourceDataItems->GetElementAt(itemIndex,
     1:                                            getter_AddRefs(genericItem));
     1:             nsCOMPtr<nsITransferable> currItem(do_QueryInterface(genericItem));
     1:             if (currItem) {
     1:                 nsCOMPtr <nsISupportsArray> flavorList;
     1:                 currItem->FlavorsTransferableCanExport(
     1:                           getter_AddRefs(flavorList));
     1:                 if (flavorList) {
108991:                     uint32_t numFlavors;
     1:                     flavorList->Count( &numFlavors );
108991:                     for ( uint32_t flavorIndex = 0;
     1:                           flavorIndex < numFlavors ;
     1:                           ++flavorIndex ) {
     1:                         nsCOMPtr<nsISupports> genericWrapper;
     1:                         flavorList->GetElementAt(flavorIndex,
     1:                                                 getter_AddRefs(genericWrapper));
     1:                         nsCOMPtr<nsISupportsCString> currentFlavor;
     1:                         currentFlavor = do_QueryInterface(genericWrapper);
     1:                         if (currentFlavor) {
     1:                             nsXPIDLCString flavorStr;
     1:                             currentFlavor->ToString(getter_Copies(flavorStr));
     1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                    ("checking %s against %s\n",
     1:                                    (const char *)flavorStr, aDataFlavor));
     1:                             if (strcmp(flavorStr, aDataFlavor) == 0) {
     1:                                 PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                        ("boioioioiooioioioing!\n"));
 79636:                                 *_retval = true;
     1:                             }
     1:                         }
     1:                     }
     1:                 }
     1:             }
     1:         }
     1:         return NS_OK;
     1:     }
     1: 
     1:     // check the target context vs. this flavor, one at a time
     1:     GList *tmp;
113945:     for (tmp = gdk_drag_context_list_targets(mTargetDragContext); 
113945:          tmp; tmp = tmp->next) {
  9859:         /* Bug 331198 */
  9859:         GdkAtom atom = GDK_POINTER_TO_ATOM(tmp->data);
     1:         gchar *name = NULL;
     1:         name = gdk_atom_name(atom);
     1:         PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                ("checking %s against %s\n", name, aDataFlavor));
 35221:         if (name && (strcmp(name, aDataFlavor) == 0)) {
     1:             PR_LOG(sDragLm, PR_LOG_DEBUG, ("good!\n"));
 79636:             *_retval = true;
     1:         }
     1:         // check for automatic text/uri-list -> text/x-moz-url mapping
 37970:         if (!*_retval && 
 35221:             name &&
 35221:             (strcmp(name, gTextUriListType) == 0) &&
 35221:             (strcmp(aDataFlavor, kURLMime) == 0)) {
     1:             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                    ("good! ( it's text/uri-list and \
     1:                    we're checking against text/x-moz-url )\n"));
 79636:             *_retval = true;
     1:         }
     1:         // check for automatic _NETSCAPE_URL -> text/x-moz-url mapping
 37970:         if (!*_retval && 
 35221:             name &&
 35221:             (strcmp(name, gMozUrlType) == 0) &&
 35221:             (strcmp(aDataFlavor, kURLMime) == 0)) {
     1:             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                    ("good! ( it's _NETSCAPE_URL and \
     1:                    we're checking against text/x-moz-url )\n"));
 79636:             *_retval = true;
     1:         }
     1:         // check for auto text/plain -> text/unicode mapping
 37970:         if (!*_retval && 
 35221:             name &&
 35221:             (strcmp(name, kTextMime) == 0) &&
 35221:             ((strcmp(aDataFlavor, kUnicodeMime) == 0) ||
 35221:              (strcmp(aDataFlavor, kFileMime) == 0))) {
     1:             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                    ("good! ( it's text plain and we're checking \
 12780:                    against text/unicode or application/x-moz-file)\n"));
 79636:             *_retval = true;
     1:         }
     1:         g_free(name);
     1:     }
     1:     return NS_OK;
     1: }
     1: 
 97334: void
 97334: nsDragService::ReplyToDragMotion()
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG,
 97334:            ("nsDragService::ReplyToDragMotion %d", mCanDrop));
     1: 
 97334:     GdkDragAction action = (GdkDragAction)0;
     1:     if (mCanDrop) {
     1:         // notify the dragger if we can drop
     1:         switch (mDragAction) {
     1:         case DRAGDROP_ACTION_COPY:
     1:           action = GDK_ACTION_COPY;
     1:           break;
     1:         case DRAGDROP_ACTION_LINK:
     1:           action = GDK_ACTION_LINK;
     1:           break;
     1:         default:
     1:           action = GDK_ACTION_MOVE;
     1:           break;
     1:         }
     1:     }
     1: 
 97334:     gdk_drag_status(mTargetDragContext, action, mTargetTime);
     1: }
     1: 
 97334: void
     1: nsDragService::TargetDataReceived(GtkWidget         *aWidget,
     1:                                   GdkDragContext    *aContext,
     1:                                   gint               aX,
     1:                                   gint               aY,
     1:                                   GtkSelectionData  *aSelectionData,
     1:                                   guint              aInfo,
     1:                                   guint32            aTime)
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::TargetDataReceived"));
     1:     TargetResetData();
 79636:     mTargetDragDataReceived = true;
114183:     gint len = gtk_selection_data_get_length(aSelectionData);
114183:     const guchar* data = gtk_selection_data_get_data(aSelectionData);
114183:     if (len > 0 && data) {
114183:         mTargetDragDataLen = len;
     1:         mTargetDragData = g_malloc(mTargetDragDataLen);
114183:         memcpy(mTargetDragData, data, mTargetDragDataLen);
     1:     }
     1:     else {
     1:         PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                ("Failed to get data.  selection data len was %d\n",
113945:                 mTargetDragDataLen));
     1:     }
     1: }
     1: 
 79445: bool
     1: nsDragService::IsTargetContextList(void)
     1: {
 79445:     bool retval = false;
     1: 
     1:     // gMimeListType drags only work for drags within a single process.
     1:     // The gtk_drag_get_source_widget() function will return NULL if the
     1:     // source of the drag is another app, so we use it to check if a
     1:     // gMimeListType drop will work or not.
     1:     if (gtk_drag_get_source_widget(mTargetDragContext) == NULL)
     1:         return retval;
     1: 
     1:     GList *tmp;
     1: 
     1:     // walk the list of context targets and see if one of them is a list
     1:     // of items.
113945:     for (tmp = gdk_drag_context_list_targets(mTargetDragContext); 
113945:          tmp; tmp = tmp->next) {
  9859:         /* Bug 331198 */
  9859:         GdkAtom atom = GDK_POINTER_TO_ATOM(tmp->data);
     1:         gchar *name = NULL;
     1:         name = gdk_atom_name(atom);
 35249:         if (name && strcmp(name, gMimeListType) == 0)
 79636:             retval = true;
     1:         g_free(name);
     1:         if (retval)
     1:             break;
     1:     }
     1:     return retval;
     1: }
     1: 
     1: // Maximum time to wait for a "drag_received" arrived, in microseconds
     1: #define NS_DND_TIMEOUT 500000
     1: 
     1: void
     1: nsDragService::GetTargetDragData(GdkAtom aFlavor)
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("getting data flavor %d\n", aFlavor));
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("mLastWidget is %p and mLastContext is %p\n",
 97331:                                    mTargetWidget.get(),
 97331:                                    mTargetDragContext.get()));
     1:     // reset our target data areas
     1:     TargetResetData();
     1:     gtk_drag_get_data(mTargetWidget, mTargetDragContext, aFlavor, mTargetTime);
     1:     
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("about to start inner iteration."));
     1:     PRTime entryTime = PR_Now();
     1:     while (!mTargetDragDataReceived && mDoingDrag) {
     1:         // check the number of iterations
     1:         PR_LOG(sDragLm, PR_LOG_DEBUG, ("doing iteration...\n"));
     1:         PR_Sleep(20*PR_TicksPerSecond()/1000);  /* sleep for 20 ms/iteration */
     1:         if (PR_Now()-entryTime > NS_DND_TIMEOUT) break;
     1:         gtk_main_iteration();
     1:     }
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("finished inner iteration\n"));
     1: }
     1: 
     1: void
     1: nsDragService::TargetResetData(void)
     1: {
 79636:     mTargetDragDataReceived = false;
     1:     // make sure to free old data if we have to
     1:     g_free(mTargetDragData);
     1:     mTargetDragData = 0;
     1:     mTargetDragDataLen = 0;
     1: }
     1: 
     1: GtkTargetList *
     1: nsDragService::GetSourceList(void)
     1: {
     1:     if (!mSourceDataItems)
     1:         return NULL;
 25381:     nsTArray<GtkTargetEntry*> targetArray;
     1:     GtkTargetEntry *targets;
     1:     GtkTargetList  *targetList = 0;
108991:     uint32_t targetCount = 0;
     1:     unsigned int numDragItems = 0;
     1: 
     1:     mSourceDataItems->Count(&numDragItems);
     1: 
     1:     // Check to see if we're dragging > 1 item.
     1:     if (numDragItems > 1) {
     1:         // as the Xdnd protocol only supports a single item (or is it just
     1:         // gtk's implementation?), we don't advertise all flavours listed
     1:         // in the nsITransferable.
     1: 
     1:         // the application/x-moz-internal-item-list format, which preserves
     1:         // all information for drags within the same mozilla instance.
     1:         GdkAtom listAtom = gdk_atom_intern(gMimeListType, FALSE);
     1:         GtkTargetEntry *listTarget =
     1:             (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
     1:         listTarget->target = g_strdup(gMimeListType);
     1:         listTarget->flags = 0;
  9859:         /* Bug 331198 */
  9859:         listTarget->info = NS_PTR_TO_UINT32(listAtom);
     1:         PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                ("automatically adding target %s with id %ld\n",
     1:                listTarget->target, listAtom));
     1:         targetArray.AppendElement(listTarget);
     1: 
     1:         // check what flavours are supported so we can decide what other
     1:         // targets to advertise.
     1:         nsCOMPtr<nsISupports> genericItem;
     1:         mSourceDataItems->GetElementAt(0, getter_AddRefs(genericItem));
     1:         nsCOMPtr<nsITransferable> currItem(do_QueryInterface(genericItem));
     1: 
     1:         if (currItem) {
     1:             nsCOMPtr <nsISupportsArray> flavorList;
     1:             currItem->FlavorsTransferableCanExport(getter_AddRefs(flavorList));
     1:             if (flavorList) {
108991:                 uint32_t numFlavors;
     1:                 flavorList->Count( &numFlavors );
108991:                 for (uint32_t flavorIndex = 0;
     1:                      flavorIndex < numFlavors ;
     1:                      ++flavorIndex ) {
     1:                     nsCOMPtr<nsISupports> genericWrapper;
     1:                     flavorList->GetElementAt(flavorIndex,
     1:                                            getter_AddRefs(genericWrapper));
     1:                     nsCOMPtr<nsISupportsCString> currentFlavor;
     1:                     currentFlavor = do_QueryInterface(genericWrapper);
     1:                     if (currentFlavor) {
     1:                         nsXPIDLCString flavorStr;
     1:                         currentFlavor->ToString(getter_Copies(flavorStr));
     1: 
     1:                         // check if text/x-moz-url is supported.
     1:                         // If so, advertise
     1:                         // text/uri-list.
     1:                         if (strcmp(flavorStr, kURLMime) == 0) {
     1:                             listAtom = gdk_atom_intern(gTextUriListType, FALSE);
     1:                             listTarget =
     1:                              (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
     1:                             listTarget->target = g_strdup(gTextUriListType);
     1:                             listTarget->flags = 0;
  9859:                             /* Bug 331198 */
  9859:                             listTarget->info = NS_PTR_TO_UINT32(listAtom);
     1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                    ("automatically adding target %s with \
     1:                                    id %ld\n", listTarget->target, listAtom));
     1:                             targetArray.AppendElement(listTarget);
     1:                         }
     1:                     }
     1:                 } // foreach flavor in item
     1:             } // if valid flavor list
     1:         } // if item is a transferable
     1:     } else if (numDragItems == 1) {
     1:         nsCOMPtr<nsISupports> genericItem;
     1:         mSourceDataItems->GetElementAt(0, getter_AddRefs(genericItem));
     1:         nsCOMPtr<nsITransferable> currItem(do_QueryInterface(genericItem));
     1:         if (currItem) {
     1:             nsCOMPtr <nsISupportsArray> flavorList;
     1:             currItem->FlavorsTransferableCanExport(getter_AddRefs(flavorList));
     1:             if (flavorList) {
108991:                 uint32_t numFlavors;
     1:                 flavorList->Count( &numFlavors );
108991:                 for (uint32_t flavorIndex = 0;
     1:                      flavorIndex < numFlavors ;
     1:                      ++flavorIndex ) {
     1:                     nsCOMPtr<nsISupports> genericWrapper;
     1:                     flavorList->GetElementAt(flavorIndex,
     1:                                              getter_AddRefs(genericWrapper));
     1:                     nsCOMPtr<nsISupportsCString> currentFlavor;
     1:                     currentFlavor = do_QueryInterface(genericWrapper);
     1:                     if (currentFlavor) {
     1:                         nsXPIDLCString flavorStr;
     1:                         currentFlavor->ToString(getter_Copies(flavorStr));
     1:                         // get the atom
     1:                         GdkAtom atom = gdk_atom_intern(flavorStr, FALSE);
     1:                         GtkTargetEntry *target =
     1:                           (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
     1:                         target->target = g_strdup(flavorStr);
     1:                         target->flags = 0;
  9859:                         /* Bug 331198 */
  9859:                         target->info = NS_PTR_TO_UINT32(atom);
     1:                         PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                ("adding target %s with id %ld\n",
     1:                                target->target, atom));
     1:                         targetArray.AppendElement(target);
     1:                         // Check to see if this is text/unicode.
     1:                         // If it is, add text/plain
     1:                         // since we automatically support text/plain
     1:                         // if we support text/unicode.
     1:                         if (strcmp(flavorStr, kUnicodeMime) == 0) {
     1:                             // get the atom for the unicode string
 32484:                             GdkAtom plainUTF8Atom =
 32484:                               gdk_atom_intern(gTextPlainUTF8Type, FALSE);
 32484:                             GtkTargetEntry *plainUTF8Target =
 32484:                              (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
 32484:                             plainUTF8Target->target = g_strdup(gTextPlainUTF8Type);
 32484:                             plainUTF8Target->flags = 0;
 32484:                             /* Bug 331198 */
 32484:                             plainUTF8Target->info = NS_PTR_TO_UINT32(plainUTF8Atom);
 32484:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
 32484:                                    ("automatically adding target %s with \
 32484:                                    id %ld\n", plainUTF8Target->target, plainUTF8Atom));
 32484:                             targetArray.AppendElement(plainUTF8Target);
 32484: 
 32484:                             // get the atom for the ASCII string
     1:                             GdkAtom plainAtom =
     1:                               gdk_atom_intern(kTextMime, FALSE);
     1:                             GtkTargetEntry *plainTarget =
     1:                              (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
     1:                             plainTarget->target = g_strdup(kTextMime);
     1:                             plainTarget->flags = 0;
  9859:                             /* Bug 331198 */
  9859:                             plainTarget->info = NS_PTR_TO_UINT32(plainAtom);
     1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                    ("automatically adding target %s with \
     1:                                    id %ld\n", plainTarget->target, plainAtom));
     1:                             targetArray.AppendElement(plainTarget);
     1:                         }
     1:                         // Check to see if this is the x-moz-url type.
     1:                         // If it is, add _NETSCAPE_URL
     1:                         // this is a type used by everybody.
     1:                         if (strcmp(flavorStr, kURLMime) == 0) {
     1:                             // get the atom name for it
     1:                             GdkAtom urlAtom =
     1:                              gdk_atom_intern(gMozUrlType, FALSE);
     1:                             GtkTargetEntry *urlTarget =
     1:                              (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
     1:                             urlTarget->target = g_strdup(gMozUrlType);
     1:                             urlTarget->flags = 0;
  9859:                             /* Bug 331198 */
  9859:                             urlTarget->info = NS_PTR_TO_UINT32(urlAtom);
     1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
     1:                                    ("automatically adding target %s with \
     1:                                    id %ld\n", urlTarget->target, urlAtom));
     1:                             targetArray.AppendElement(urlTarget);
     1:                         }
     1:                     }
     1:                 } // foreach flavor in item
     1:             } // if valid flavor list
     1:         } // if item is a transferable
     1:     } // if it is a single item drag
     1: 
     1:     // get all the elements that we created.
 25381:     targetCount = targetArray.Length();
     1:     if (targetCount) {
     1:         // allocate space to create the list of valid targets
     1:         targets =
     1:           (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry) * targetCount);
108991:         uint32_t targetIndex;
     1:         for ( targetIndex = 0; targetIndex < targetCount; ++targetIndex) {
 25381:             GtkTargetEntry *disEntry = targetArray.ElementAt(targetIndex);
     1:             // this is a string reference but it will be freed later.
     1:             targets[targetIndex].target = disEntry->target;
     1:             targets[targetIndex].flags = disEntry->flags;
     1:             targets[targetIndex].info = disEntry->info;
     1:         }
     1:         targetList = gtk_target_list_new(targets, targetCount);
     1:         // clean up the target list
108991:         for (uint32_t cleanIndex = 0; cleanIndex < targetCount; ++cleanIndex) {
 25381:             GtkTargetEntry *thisTarget = targetArray.ElementAt(cleanIndex);
     1:             g_free(thisTarget->target);
     1:             g_free(thisTarget);
     1:         }
     1:         g_free(targets);
     1:     }
     1:     return targetList;
     1: }
     1: 
     1: void
 29409: nsDragService::SourceEndDragSession(GdkDragContext *aContext,
 29409:                                     gint            aResult)
     1: {
     1:     // this just releases the list of data items that we provide
106838:     mSourceDataItems = nullptr;
 29217: 
 97336:     if (!mDoingDrag || mScheduledTask == eDragTaskSourceEnd)
 97336:         // EndDragSession() was already called on drop
 97336:         // or SourceEndDragSession on drag-failed
 97336:         return;
 29409: 
 95558:     if (mEndDragPoint.x < 0) {
 95558:         // We don't have a drag end point, so guess
 29409:         gint x, y;
 29409:         GdkDisplay* display = gdk_display_get_default();
 29409:         if (display) {
 29409:             gdk_display_get_pointer(display, NULL, &x, &y, NULL);
 29409:             SetDragEndPoint(nsIntPoint(x, y));
 29409:         }
 95558:     }
 29217: 
 29217:     // Either the drag was aborted or the drop occurred outside the app.
 29217:     // The dropEffect of mDataTransfer is not updated for motion outside the
 29217:     // app, but is needed for the dragend event, so set it now.
 29217: 
108991:     uint32_t dropEffect;
 29409: 
 29409:     if (aResult == MOZ_GTK_DRAG_RESULT_SUCCESS) {
 29409: 
 29409:         // With GTK+ versions 2.10.x and prior the drag may have been
 29409:         // cancelled (but no drag-failed signal would have been sent).
 29409:         // aContext->dest_window will be non-NULL only if the drop was sent.
 29217:         GdkDragAction action =
113945:             gdk_drag_context_get_dest_window(aContext) ? 
113945:                 gdk_drag_context_get_actions(aContext) : (GdkDragAction)0;
 29217: 
 29409:         // Only one bit of action should be set, but, just in case someone
 29409:         // does something funny, erring away from MOVE, and not recording
 29409:         // unusual action combinations as NONE.
 29217:         if (!action)
 29217:             dropEffect = DRAGDROP_ACTION_NONE;
 29217:         else if (action & GDK_ACTION_COPY)
 29217:             dropEffect = DRAGDROP_ACTION_COPY;
 29217:         else if (action & GDK_ACTION_LINK)
 29217:             dropEffect = DRAGDROP_ACTION_LINK;
 29217:         else if (action & GDK_ACTION_MOVE)
 29217:             dropEffect = DRAGDROP_ACTION_MOVE;
 29217:         else
 29217:             dropEffect = DRAGDROP_ACTION_COPY;
 29217: 
 29409:     } else {
 29409: 
 29409:         dropEffect = DRAGDROP_ACTION_NONE;
 29409: 
 29409:         if (aResult != MOZ_GTK_DRAG_RESULT_NO_TARGET) {
 79636:             mUserCancelled = true;
 29409:         }
 29409:     }
 29409: 
 89615:     if (mDataTransfer) {
 89615:         mDataTransfer->SetDropEffectInt(dropEffect);
 29217:     }
     1: 
 97336:     // Schedule the appropriate drag end dom events.
106838:     Schedule(eDragTaskSourceEnd, nullptr, NULL, nsIntPoint(), 0);
     1: }
     1: 
     1: static void
     1: CreateUriList(nsISupportsArray *items, gchar **text, gint *length)
     1: {
108991:     uint32_t i, count;
     1:     GString *uriList = g_string_new(NULL);
     1: 
     1:     items->Count(&count);
     1:     for (i = 0; i < count; i++) {
     1:         nsCOMPtr<nsISupports> genericItem;
     1:         items->GetElementAt(i, getter_AddRefs(genericItem));
     1:         nsCOMPtr<nsITransferable> item;
     1:         item = do_QueryInterface(genericItem);
     1: 
     1:         if (item) {
108991:             uint32_t tmpDataLen = 0;
     1:             void    *tmpData = NULL;
106878:             nsresult rv = NS_OK;
     1:             nsCOMPtr<nsISupports> data;
     1:             rv = item->GetTransferData(kURLMime,
     1:                                        getter_AddRefs(data),
     1:                                        &tmpDataLen);
     1: 
     1:             if (NS_SUCCEEDED(rv)) {
     1:                 nsPrimitiveHelpers::CreateDataFromPrimitive(kURLMime,
     1:                                                             data,
     1:                                                             &tmpData,
     1:                                                             tmpDataLen);
106838:                 char* plainTextData = nullptr;
  3233:                 PRUnichar* castedUnicode = reinterpret_cast<PRUnichar*>
  3233:                                                            (tmpData);
108991:                 int32_t plainTextLen = 0;
     1:                 nsPrimitiveHelpers::ConvertUnicodeToPlatformPlainText(
     1:                                     castedUnicode,
     1:                                     tmpDataLen / 2,
     1:                                     &plainTextData,
     1:                                     &plainTextLen);
     1:                 if (plainTextData) {
108991:                     int32_t j;
     1: 
     1:                     // text/x-moz-url is of form url + "\n" + title.
     1:                     // We just want the url.
     1:                     for (j = 0; j < plainTextLen; j++)
     1:                         if (plainTextData[j] == '\n' ||
     1:                             plainTextData[j] == '\r') {
     1:                             plainTextData[j] = '\0';
     1:                             break;
     1:                         }
     1:                     g_string_append(uriList, plainTextData);
     1:                     g_string_append(uriList, "\r\n");
     1:                     // this wasn't allocated with glib
     1:                     free(plainTextData);
     1:                 }
     1:                 if (tmpData) {
     1:                     // this wasn't allocated with glib
     1:                     free(tmpData);
     1:                 }
     1:             }
     1:         }
     1:     }
     1:     *text = uriList->str;
     1:     *length = uriList->len + 1;
     1:     g_string_free(uriList, FALSE); // don't free the data
     1: }
     1: 
     1: 
     1: void
     1: nsDragService::SourceDataGet(GtkWidget        *aWidget,
     1:                              GdkDragContext   *aContext,
     1:                              GtkSelectionData *aSelectionData,
     1:                              guint             aInfo,
     1:                              guint32           aTime)
     1: {
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::SourceDataGet"));
     1:     GdkAtom atom = (GdkAtom)aInfo;
     1:     nsXPIDLCString mimeFlavor;
     1:     gchar *typeName = 0;
     1:     typeName = gdk_atom_name(atom);
     1:     if (!typeName) {
     1:         PR_LOG(sDragLm, PR_LOG_DEBUG, ("failed to get atom name.\n"));
     1:         return;
     1:     }
     1: 
     1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("Type is %s\n", typeName));
     1:     // make a copy since |nsXPIDLCString| won't use |g_free|...
     1:     mimeFlavor.Adopt(nsCRT::strdup(typeName));
     1:     g_free(typeName);
     1:     // check to make sure that we have data items to return.
     1:     if (!mSourceDataItems) {
     1:         PR_LOG(sDragLm, PR_LOG_DEBUG, ("Failed to get our data items\n"));
     1:         return;
     1:     }
     1: 
     1:     nsCOMPtr<nsISupports> genericItem;
     1:     mSourceDataItems->GetElementAt(0, getter_AddRefs(genericItem));
     1:     nsCOMPtr<nsITransferable> item;
     1:     item = do_QueryInterface(genericItem);
     1:     if (item) {
     1:         // if someone was asking for text/plain, lookup unicode instead so
     1:         // we can convert it.
 79445:         bool needToDoConversionToPlainText = false;
     1:         const char* actualFlavor = mimeFlavor;
 32484:         if (strcmp(mimeFlavor, kTextMime) == 0 ||
 32484:             strcmp(mimeFlavor, gTextPlainUTF8Type) == 0) {
     1:             actualFlavor = kUnicodeMime;
 79636:             needToDoConversionToPlainText = true;
     1:         }
     1:         // if someone was asking for _NETSCAPE_URL we need to convert to
     1:         // plain text but we also need to look for x-moz-url
     1:         else if (strcmp(mimeFlavor, gMozUrlType) == 0) {
     1:             actualFlavor = kURLMime;
 79636:             needToDoConversionToPlainText = true;
     1:         }
   468:         // if someone was asking for text/uri-list we need to convert to
   468:         // plain text.
   468:         else if (strcmp(mimeFlavor, gTextUriListType) == 0) {
   468:             actualFlavor = gTextUriListType;
 79636:             needToDoConversionToPlainText = true;
   468:         }
     1:         else
     1:             actualFlavor = mimeFlavor;
     1: 
108991:         uint32_t tmpDataLen = 0;
     1:         void    *tmpData = NULL;
     1:         nsresult rv;
     1:         nsCOMPtr<nsISupports> data;
     1:         rv = item->GetTransferData(actualFlavor,
     1:                                    getter_AddRefs(data),
     1:                                    &tmpDataLen);
     1:         if (NS_SUCCEEDED(rv)) {
     1:             nsPrimitiveHelpers::CreateDataFromPrimitive (actualFlavor, data,
     1:                                                          &tmpData, tmpDataLen);
     1:             // if required, do the extra work to convert unicode to plain
     1:             // text and replace the output values with the plain text.
     1:             if (needToDoConversionToPlainText) {
106838:                 char* plainTextData = nullptr;
  3233:                 PRUnichar* castedUnicode = reinterpret_cast<PRUnichar*>
  3233:                                                            (tmpData);
108991:                 int32_t plainTextLen = 0;
 32484:                 if (strcmp(mimeFlavor, gTextPlainUTF8Type) == 0) {
 32484:                     plainTextData =
 32484:                         ToNewUTF8String(
 32484:                             nsDependentString(castedUnicode, tmpDataLen / 2),
108991:                             (uint32_t*)&plainTextLen);
 32484:                 } else {
     1:                     nsPrimitiveHelpers::ConvertUnicodeToPlatformPlainText(
     1:                                         castedUnicode,
     1:                                         tmpDataLen / 2,
     1:                                         &plainTextData,
     1:                                         &plainTextLen);
 32484:                 }
     1:                 if (tmpData) {
     1:                     // this was not allocated using glib
     1:                     free(tmpData);
     1:                     tmpData = plainTextData;
     1:                     tmpDataLen = plainTextLen;
     1:                 }
     1:             }
     1:             if (tmpData) {
     1:                 // this copies the data
     1:                 gtk_selection_data_set(aSelectionData,
113945:                                        gtk_selection_data_get_target(aSelectionData),
     1:                                        8,
     1:                                        (guchar *)tmpData, tmpDataLen);
     1:                 // this wasn't allocated with glib
     1:                 free(tmpData);
     1:             }
   468:         } else {
   468:             if (strcmp(mimeFlavor, gTextUriListType) == 0) {
   468:                 // fall back for text/uri-list
   468:                 gchar *uriList;
   468:                 gint length;
   468:                 CreateUriList(mSourceDataItems, &uriList, &length);
   468:                 gtk_selection_data_set(aSelectionData,
113945:                                        gtk_selection_data_get_target(aSelectionData),
   468:                                        8, (guchar *)uriList, length);
   468:                 g_free(uriList);
   468:                 return;
   468:             }
     1:         }
     1:     }
     1: }
     1: 
 72984: void nsDragService::SetDragIcon(GdkDragContext* aContext)
 72984: {
 77050:     if (!mHasImage && !mSelection)
 77050:         return;
 77050: 
 72984:     nsIntRect dragRect;
 72984:     nsPresContext* pc;
 72984:     nsRefPtr<gfxASurface> surface;
 72984:     DrawDrag(mSourceNode, mSourceRegion, mScreenX, mScreenY,
 72984:              &dragRect, getter_AddRefs(surface), &pc);
 77050:     if (!pc)
 77050:         return;
 72984: 
108991:     int32_t sx = mScreenX, sy = mScreenY;
 72984:     ConvertToUnscaledDevPixels(pc, &sx, &sy);
 72984: 
108991:     int32_t offsetX = sx - dragRect.x;
108991:     int32_t offsetY = sy - dragRect.y;
 77050: 
 77050:     // If a popup is set as the drag image, use its widget. Otherwise, use
 77050:     // the surface that DrawDrag created.
 77050:     if (mDragPopup) {
106838:         GtkWidget* gtkWidget = nullptr;
 77050:         nsIFrame* frame = mDragPopup->GetPrimaryFrame();
 77050:         if (frame) {
 77050:             // DrawDrag ensured that this is a popup frame.
 77050:             nsCOMPtr<nsIWidget> widget = frame->GetNearestWidget();
 77050:             if (widget) {
 77050:                 gtkWidget = (GtkWidget *)widget->GetNativeData(NS_NATIVE_SHELLWIDGET);
 77050:                 if (gtkWidget) {
 77050:                     OpenDragPopup();
 77050:                     gtk_drag_set_icon_widget(aContext, gtkWidget, offsetX, offsetY);
 77050:                 }
 77050:             }
 77050:         }
 77050:     }
 77050:     else if (surface) {
 72984:         if (!SetAlphaPixmap(surface, aContext, offsetX, offsetY, dragRect)) {
 72984:             GdkPixbuf* dragPixbuf =
 72984:               nsImageToPixbuf::SurfaceToPixbuf(surface, dragRect.width, dragRect.height);
 72984:             if (dragPixbuf) {
 72984:                 gtk_drag_set_icon_pixbuf(aContext, dragPixbuf, offsetX, offsetY);
 72984:                 g_object_unref(dragPixbuf);
 72984:             }
 72984:         }
 72984:     }
 72984: }
 72984: 
 72984: static void
 72984: invisibleSourceDragBegin(GtkWidget        *aWidget,
 72984:                          GdkDragContext   *aContext,
 72984:                          gpointer          aData)
 72984: {
 72984:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("invisibleSourceDragBegin"));
 72984:     nsDragService *dragService = (nsDragService *)aData;
 72984: 
 72984:     dragService->SetDragIcon(aContext);
 72984: }
 72984: 
 70016: static void
     1: invisibleSourceDragDataGet(GtkWidget        *aWidget,
     1:                            GdkDragContext   *aContext,
     1:                            GtkSelectionData *aSelectionData,
     1:                            guint             aInfo,
     1:                            guint32           aTime,
     1:                            gpointer          aData)
     1: {
 29217:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("invisibleSourceDragDataGet"));
     1:     nsDragService *dragService = (nsDragService *)aData;
     1:     dragService->SourceDataGet(aWidget, aContext,
     1:                                aSelectionData, aInfo, aTime);
     1: }
     1: 
 70016: static gboolean
 29409: invisibleSourceDragFailed(GtkWidget        *aWidget,
 29409:                           GdkDragContext   *aContext,
 29409:                           gint              aResult,
 29409:                           gpointer          aData)
 29409: {
 29409:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("invisibleSourceDragFailed %i", aResult));
 29409:     nsDragService *dragService = (nsDragService *)aData;
 29409:     // End the drag session now (rather than waiting for the drag-end signal)
 29409:     // so that operations performed on dropEffect == none can start immediately
 29409:     // rather than waiting for the drag-failed animation to finish.
 29409:     dragService->SourceEndDragSession(aContext, aResult);
 29409: 
 29409:     // We should return TRUE to disable the drag-failed animation iff the
 29409:     // source performed an operation when dropEffect was none, but the handler
 29409:     // of the dragend DOM event doesn't provide this information.
 29409:     return FALSE;
 29409: }
 29409: 
 70016: static void
     1: invisibleSourceDragEnd(GtkWidget        *aWidget,
     1:                        GdkDragContext   *aContext,
     1:                        gpointer          aData)
     1: {
 29217:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("invisibleSourceDragEnd"));
     1:     nsDragService *dragService = (nsDragService *)aData;
 27401: 
 29409:     // The drag has ended.  Release the hostages!
 29409:     dragService->SourceEndDragSession(aContext, MOZ_GTK_DRAG_RESULT_SUCCESS);
 27401: }
 27401: 
 97336: // The following methods handle responding to GTK drag signals and
 97331: // tracking state between these signals.
 97331: //
 97331: // In general, GTK does not expect us to run the event loop while handling its
 97336: // drag signals, however our drag event handlers may run the
 97331: // event loop, most often to fetch information about the drag data.
 97331: // 
 97331: // GTK, for example, uses the return value from drag-motion signals to
 97331: // determine whether drag-leave signals should be sent.  If an event loop is
 97331: // run during drag-motion the XdndLeave message can get processed but when GTK
 97331: // receives the message it does not yet know that it needs to send the
 97331: // drag-leave signal to our widget.
 97331: //
 97331: // After a drag-drop signal, we need to reply with gtk_drag_finish().
 97331: // However, gtk_drag_finish should happen after the drag-drop signal handler
 97331: // returns so that when the Motif drag protocol is used, the
 97331: // XmTRANSFER_SUCCESS during gtk_drag_finish is sent after the XmDROP_START
 97331: // reply sent on return from the drag-drop signal handler.
 97331: //
 97336: // Similarly drag-end for a successful drag and drag-failed are not good
 97336: // times to run a nested event loop as gtk_drag_drop_finished() and
 97336: // gtk_drag_source_info_destroy() don't gtk_drag_clear_source_info() or remove
 97336: // drop_timeout until after at least the first of these signals is sent.
 97336: // Processing other events (e.g. a slow GDK_DROP_FINISHED reply, or the drop
 97336: // timeout) could cause gtk_drag_drop_finished to be called again with the
 97336: // same GtkDragSourceInfo, which won't like being destroyed twice.
 97336: //
 97331: // Therefore we reply to the signals immediately and schedule a task to
 97331: // dispatch the Gecko events, which may run the event loop.
 97331: //
 97331: // Action in response to drag-leave signals is also delayed until the event
 97331: // loop runs again so that we find out whether a drag-drop signal follows.
 97331: //
 97331: // A single task is scheduled to manage responses to all three GTK signals.
 97331: // If further signals are received while the task is scheduled, the scheduled
 97331: // response is updated, sometimes effectively compressing successive signals.
 97331: //
 97331: // No Gecko drag events are dispatched (during nested event loops) while other
 97331: // Gecko drag events are in flight.  This helps event handlers that may not
 97331: // expect nested events, while accessing an event's dataTransfer for example.
 97331: 
 97331: gboolean
 97331: nsDragService::ScheduleMotionEvent(nsWindow *aWindow,
 97331:                                    GdkDragContext *aDragContext,
 97331:                                    nsIntPoint aWindowPoint, guint aTime)
 97331: {
 97331:     if (mScheduledTask == eDragTaskMotion) {
 97331:         // The drag source has sent another motion message before we've
 97331:         // replied to the previous.  That shouldn't happen with Xdnd.  The
 97331:         // spec for Motif drags is less clear, but we'll just update the
 97331:         // scheduled task with the new position reply only to the most
 97331:         // recent message.
 97331:         NS_WARNING("Drag Motion message received before previous reply was sent");
 97331:     }
 97331: 
 97331:     // Returning TRUE means we'll reply with a status message, unless we first
 97331:     // get a leave.
 97331:     return Schedule(eDragTaskMotion, aWindow, aDragContext,
 97331:                     aWindowPoint, aTime);
 97331: }
 97331: 
 97331: void
 97331: nsDragService::ScheduleLeaveEvent()
 97331: {
 97331:     // We don't know at this stage whether a drop signal will immediately
 97331:     // follow.  If the drop signal gets sent it will happen before we return
 97331:     // to the main loop and the scheduled leave task will be replaced.
106838:     if (!Schedule(eDragTaskLeave, nullptr, NULL, nsIntPoint(), 0)) {
 97331:         NS_WARNING("Drag leave after drop");
 97331:     }        
 97331: }
 97331: 
 97331: gboolean
 97331: nsDragService::ScheduleDropEvent(nsWindow *aWindow,
 97331:                                  GdkDragContext *aDragContext,
 97331:                                  nsIntPoint aWindowPoint, guint aTime)
 97331: {
 97331:     if (!Schedule(eDragTaskDrop, aWindow,
 97331:                   aDragContext, aWindowPoint, aTime)) {
 97331:         NS_WARNING("Additional drag drop ignored");
 97331:         return FALSE;        
 97331:     }
 97331: 
 97331:     SetDragEndPoint(aWindowPoint + aWindow->WidgetToScreenOffset());
 97331: 
 97331:     // We'll reply with gtk_drag_finish().
 97331:     return TRUE;
 97331: }
 97331: 
 97331: gboolean
 97331: nsDragService::Schedule(DragTask aTask, nsWindow *aWindow,
 97331:                         GdkDragContext *aDragContext,
 97331:                         nsIntPoint aWindowPoint, guint aTime)
 97331: {
 97331:     // If there is an existing leave or motion task scheduled, then that
 97331:     // will be replaced.  When the new task is run, it will dispatch
 97331:     // any necessary leave or motion events.
 97331: 
 97336:     // If aTask is eDragTaskSourceEnd, then it will replace even a scheduled
 97336:     // drop event (which could happen if the drop event has not been processed
 97336:     // within the allowed time).  Otherwise, if we haven't yet run a scheduled
 97336:     // drop or end task, just say that we are not ready to receive another
 97336:     // drop.
 97336:     if (mScheduledTask == eDragTaskSourceEnd ||
 97336:         (mScheduledTask == eDragTaskDrop && aTask != eDragTaskSourceEnd))
 97336:         return FALSE;
 97336: 
 97331:     mScheduledTask = aTask;
 97331:     mPendingWindow = aWindow;
 97331:     mPendingDragContext = aDragContext;
 97331:     mPendingWindowPoint = aWindowPoint;
 97331:     mPendingTime = aTime;
 97331: 
 97331:     if (!mTaskSource) {
 97331:         // High priority is used here because the native events involved have
 97331:         // already waited at default priority.  Perhaps a lower than default
 97331:         // priority could be used for motion tasks because there is a chance
 97331:         // that a leave or drop is waiting, but managing different priorities
 97331:         // may not be worth the effort.  Motion tasks shouldn't queue up as
 97331:         // they should be throttled based on replies.
 97331:         mTaskSource =
 97331:             g_idle_add_full(G_PRIORITY_HIGH, TaskDispatchCallback, this, NULL);
 97331:     }
 97331:     return TRUE;
 97331: }
 97331: 
 97331: gboolean
 97331: nsDragService::TaskDispatchCallback(gpointer data)
 97331: {
 97331:     nsRefPtr<nsDragService> dragService = static_cast<nsDragService*>(data);
 97331:     return dragService->RunScheduledTask();
 97331: }
 97331: 
 97331: gboolean
 97331: nsDragService::RunScheduledTask()
 97331: {
 97331:     if (mTargetWindow && mTargetWindow != mPendingWindow) {
 97332:         PR_LOG(sDragLm, PR_LOG_DEBUG,
 97332:                ("nsDragService: dispatch drag leave (%p)\n",
 97332:                 mTargetWindow.get()));
 97332:         mTargetWindow->
 97332:             DispatchDragEvent(NS_DRAGDROP_EXIT, mTargetWindowPoint, 0);
 97332: 
 97332:         if (!mSourceNode) {
 97332:             // The drag that was initiated in a different app. End the drag
 97332:             // session, since we're done with it for now (until the user drags
 97332:             // back into this app).
 97332:             EndDragSession(false);
 97332:         }
 97331:     }
 97331: 
 97331:     // It is possible that the pending state has been updated during dispatch
 97331:     // of the leave event.  That's fine.
 97331: 
 97331:     // Now we collect the pending state because, from this point on, we want
 97331:     // to use the same state for all events dispatched.  All state is updated
 97331:     // so that when other tasks are scheduled during dispatch here, this
 97331:     // task is considered to have already been run.
 97331:     bool positionHasChanged =
 97331:         mPendingWindow != mTargetWindow ||
 97331:         mPendingWindowPoint != mTargetWindowPoint;
 97331:     DragTask task = mScheduledTask;
 97331:     mScheduledTask = eDragTaskNone;
 97331:     mTargetWindow = mPendingWindow.forget();
 97331:     mTargetWindowPoint = mPendingWindowPoint;
 97331: 
 97336:     if (task == eDragTaskLeave || task == eDragTaskSourceEnd) {
 97336:         if (task == eDragTaskSourceEnd) {
 97336:             // Dispatch drag end events.
 97336:             EndDragSession(true);
 97336:         }
 97336: 
 97331:         // Nothing more to do
 97331:         // Returning false removes the task source from the event loop.
 97331:         mTaskSource = 0;
 97331:         return FALSE;
 97331:     }
 97331: 
 97331:     // This may be the start of a destination drag session.
 97331:     StartDragSession();
 97331: 
 97331:     // mTargetWidget may be NULL if the window has been destroyed.
 97331:     // (The leave event is not scheduled if a drop task is still scheduled.)
 97331:     // We still reply appropriately to indicate that the drop will or didn't
 97331:     // succeeed. 
 97331:     mTargetWidget = mTargetWindow->GetMozContainerWidget();
 97331:     mTargetDragContext.steal(mPendingDragContext);
 97331:     mTargetTime = mPendingTime;
 97331: 
 97331:     // http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#drag-and-drop-processing-model
 97331:     // (as at 27 December 2010) indicates that a "drop" event should only be
 97331:     // fired (at the current target element) if the current drag operation is
 97331:     // not none.  The current drag operation will only be set to a non-none
 97331:     // value during a "dragover" event.
 97331:     //
 97331:     // If the user has ended the drag before any dragover events have been
 97331:     // sent, then the spec recommends skipping the drop (because the current
 97331:     // drag operation is none).  However, here we assume that, by releasing
 97331:     // the mouse button, the user has indicated that they want to drop, so we
 97331:     // proceed with the drop where possible.
 97331:     //
 97331:     // In order to make the events appear to content in the same way as if the
 97331:     // spec is being followed we make sure to dispatch a "dragover" event with
 97331:     // appropriate coordinates and check canDrop before the "drop" event.
 97331:     //
 97331:     // When the Xdnd protocol is used for source/destination communication (as
 97331:     // should be the case with GTK source applications) a dragover event
 97331:     // should have already been sent during the drag-motion signal, which
 97331:     // would have already been received because XdndDrop messages do not
 97331:     // contain a position.  However, we can't assume the same when the Motif
 97331:     // protocol is used.
 97331:     if (task == eDragTaskMotion || positionHasChanged) {
 97333:         UpdateDragAction();
 97332:         DispatchMotionEvents();
 97331: 
 97331:         if (task == eDragTaskMotion) {
 97331:             // Reply to tell the source whether we can drop and what
 97331:             // action would be taken.
 97334:             ReplyToDragMotion();
 97331:         }
 97331:     }
 97331: 
 97331:     if (task == eDragTaskDrop) {
 97332:         gboolean success = DispatchDropEvent();
 97331: 
 97331:         // Perhaps we should set the del parameter to TRUE when the drag
 97331:         // action is move, but we don't know whether the data was successfully
 97331:         // transferred.
 97331:         gtk_drag_finish(mTargetDragContext, success,
 97331:                         /* del = */ FALSE, mTargetTime);
 97331: 
 97331:         // This drag is over, so clear out our reference to the previous
 97331:         // window.
106838:         mTargetWindow = nullptr;
 97331:         // Make sure to end the drag session. If this drag started in a
 97331:         // different app, we won't get a drag_end signal to end it from.
 97331:         EndDragSession(true);
 97331:     }
 97331: 
 97331:     // We're done with the drag context.
 97331:     mTargetWidget = NULL;
 97331:     mTargetDragContext = NULL;
 97331: 
 97331:     // If we got another drag signal while running the sheduled task, that
 97331:     // must have happened while running a nested event loop.  Leave the task
 97331:     // source on the event loop.
 97331:     if (mScheduledTask != eDragTaskNone)
 97331:         return TRUE;
 97331: 
 97331:     // We have no task scheduled.
 97331:     // Returning false removes the task source from the event loop.
 97331:     mTaskSource = 0;
 97331:     return FALSE;
 97331: }
 97332: 
 97333: // This will update the drag action based on the information in the
 97333: // drag context.  Gtk gets this from a combination of the key settings
 97333: // and what the source is offering.
 97333: 
 97333: void
 97333: nsDragService::UpdateDragAction()
 97333: {
 97333:     // This doesn't look right.  dragSession.dragAction is used by
 97333:     // nsContentUtils::SetDataTransferInEvent() to set the initial
 97333:     // dataTransfer.dropEffect, so GdkDragContext::suggested_action would be
 97333:     // more appropriate.  GdkDragContext::actions should be used to set
 97333:     // dataTransfer.effectAllowed, which doesn't currently happen with
 97333:     // external sources.
 97333: 
 97333:     // default is to do nothing
 97333:     int action = nsIDragService::DRAGDROP_ACTION_NONE;
 97333:     GdkDragAction gdkAction = gdk_drag_context_get_actions(mTargetDragContext);
 97333: 
 97333:     // set the default just in case nothing matches below
 97333:     if (gdkAction & GDK_ACTION_DEFAULT)
 97333:         action = nsIDragService::DRAGDROP_ACTION_MOVE;
 97333: 
 97333:     // first check to see if move is set
 97333:     if (gdkAction & GDK_ACTION_MOVE)
 97333:         action = nsIDragService::DRAGDROP_ACTION_MOVE;
 97333: 
 97333:     // then fall to the others
 97333:     else if (gdkAction & GDK_ACTION_LINK)
 97333:         action = nsIDragService::DRAGDROP_ACTION_LINK;
 97333: 
 97333:     // copy is ctrl
 97333:     else if (gdkAction & GDK_ACTION_COPY)
 97333:         action = nsIDragService::DRAGDROP_ACTION_COPY;
 97333: 
 97333:     // update the drag information
 97333:     SetDragAction(action);
 97333: }
 97333: 
 97332: void
 97332: nsDragService::DispatchMotionEvents()
 97332: {
 97332:     mCanDrop = false;
 97332: 
 97332:     FireDragEventAtSource(NS_DRAGDROP_DRAG);
 97332: 
 97332:     mTargetWindow->
 97332:         DispatchDragEvent(NS_DRAGDROP_OVER, mTargetWindowPoint, mTargetTime);
 97332: }
 97332: 
 97332: // Returns true if the drop was successful
 97332: gboolean
 97332: nsDragService::DispatchDropEvent()
 97332: {
 97332:     // We need to check IsDestroyed here because the nsRefPtr
 97332:     // only protects this from being deleted, it does NOT protect
 97332:     // against nsView::~nsView() calling Destroy() on it, bug 378273.
 97332:     if (mTargetWindow->IsDestroyed())
 97332:         return FALSE;
 97332: 
108991:     uint32_t msg = mCanDrop ? NS_DRAGDROP_DROP : NS_DRAGDROP_EXIT;
 97332: 
 97332:     mTargetWindow->DispatchDragEvent(msg, mTargetWindowPoint, mTargetTime);
 97332: 
 97332:     return mCanDrop;
 97332: }
