32917: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
32917: /* ***** BEGIN LICENSE BLOCK *****
32917:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
32917:  *
32917:  * The contents of this file are subject to the Mozilla Public License Version
32917:  * 1.1 (the "License"); you may not use this file except in compliance with
32917:  * the License. You may obtain a copy of the License at
32917:  * http://www.mozilla.org/MPL/
32917:  *
32917:  * Software distributed under the License is distributed on an "AS IS" basis,
32917:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
32917:  * for the specific language governing rights and limitations under the
32917:  * License.
32917:  *
32917:  * The Original Code is mozilla.org code.
32917:  *
32917:  * The Initial Developer of the Original Code is
32917:  * Netscape Communications Corporation.
32917:  * Portions created by the Initial Developer are Copyright (C) 1998
32917:  * the Initial Developer. All Rights Reserved.
32917:  *
32917:  * Contributor(s):
32917:  *   Henri Sivonen <hsivonen@iki.fi>
32917:  *
32917:  * Alternatively, the contents of this file may be used under the terms of
32917:  * either of the GNU General Public License Version 2 or later (the "GPL"),
32917:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
32917:  * in which case the provisions of the GPL or the LGPL are applicable instead
32917:  * of those above. If you wish to allow use of your version of this file only
32917:  * under the terms of either the GPL or the LGPL, and not to allow others to
32917:  * use your version of this file under the terms of the MPL, indicate your
32917:  * decision by deleting the provisions above and replace them with the notice
32917:  * and other provisions required by the GPL or the LGPL. If you do not delete
32917:  * the provisions above, a recipient may use your version of this file under
32917:  * the terms of any one of the MPL, the GPL or the LGPL.
32917:  *
32917:  * ***** END LICENSE BLOCK ***** */
32917: 
32917: #ifndef nsHtml5StreamParser_h__
32917: #define nsHtml5StreamParser_h__
32917: 
32917: #include "nsAutoPtr.h"
32917: #include "nsCOMPtr.h"
32917: #include "nsIStreamListener.h"
32917: #include "nsICharsetDetectionObserver.h"
32917: #include "nsHtml5MetaScanner.h"
32917: #include "nsIUnicodeDecoder.h"
32917: #include "nsHtml5TreeOpExecutor.h"
80404: #include "nsHtml5OwningUTF16Buffer.h"
32917: #include "nsIInputStream.h"
41448: #include "nsICharsetAlias.h"
34979: #include "mozilla/Mutex.h"
34979: #include "nsHtml5AtomTable.h"
34981: #include "nsHtml5Speculation.h"
35600: #include "nsITimer.h"
37402: #include "nsICharsetDetector.h"
32917: 
32917: class nsHtml5Parser;
32917: 
32917: #define NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE 1024
38744: #define NS_HTML5_STREAM_PARSER_SNIFFING_BUFFER_SIZE 1024
32917: 
81151: enum eParserMode {
81151:   /**
81151:    * Parse a document normally as HTML.
81151:    */
81151:   NORMAL,
81151: 
81151:   /**
81151:    * View document as HTML source.
81151:    */
81151:   VIEW_SOURCE_HTML,
81151: 
81151:   /**
81151:    * View document as XML source
81151:    */
81151:   VIEW_SOURCE_XML,
81151: 
81151:   /**
81151:    * View document as plain text
81151:    */
81151:   PLAIN_TEXT
81151: };
81151: 
32917: enum eBomState {
32917:   /**
32917:    * BOM sniffing hasn't started.
32917:    */
32917:   BOM_SNIFFING_NOT_STARTED = 0,
32917: 
32917:   /**
32917:    * BOM sniffing is ongoing, and the first byte of an UTF-16LE BOM has been
32917:    * seen.
32917:    */
32917:   SEEN_UTF_16_LE_FIRST_BYTE = 1,
32917: 
32917:   /**
32917:    * BOM sniffing is ongoing, and the first byte of an UTF-16BE BOM has been
32917:    * seen.
32917:    */
32917:   SEEN_UTF_16_BE_FIRST_BYTE = 2,
32917: 
32917:   /**
32917:    * BOM sniffing is ongoing, and the first byte of an UTF-8 BOM has been
32917:    * seen.
32917:    */
32917:   SEEN_UTF_8_FIRST_BYTE = 3,
32917: 
32917:   /**
32917:    * BOM sniffing is ongoing, and the first and second bytes of an UTF-8 BOM
32917:    * have been seen.
32917:    */
32917:   SEEN_UTF_8_SECOND_BYTE = 4,
32917: 
32917:   /**
32917:    * BOM sniffing was started but is now over for whatever reason.
32917:    */
32917:   BOM_SNIFFING_OVER = 5
32917: };
32917: 
34979: enum eHtml5StreamState {
34979:   STREAM_NOT_STARTED = 0,
34979:   STREAM_BEING_READ = 1,
34979:   STREAM_ENDED = 2
34979: };
34979: 
32917: class nsHtml5StreamParser : public nsIStreamListener,
41448:                             public nsICharsetDetectionObserver {
34980: 
34980:   friend class nsHtml5RequestStopper;
34980:   friend class nsHtml5DataAvailable;
34981:   friend class nsHtml5StreamParserContinuation;
41395:   friend class nsHtml5TimerKungFu;
34980: 
32917:   public:
32917:     NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
32917:     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
32917:     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsHtml5StreamParser, nsIStreamListener)
32917: 
35600:     static void InitializeStatics();
35600: 
34979:     nsHtml5StreamParser(nsHtml5TreeOpExecutor* aExecutor,
81151:                         nsHtml5Parser* aOwner,
81151:                         eParserMode aMode);
32917:                         
32917:     virtual ~nsHtml5StreamParser();
32917: 
32917:     // nsIRequestObserver methods:
32917:     NS_DECL_NSIREQUESTOBSERVER
32917:     // nsIStreamListener methods:
32917:     NS_DECL_NSISTREAMLISTENER
32917:     
32917:     // nsICharsetDetectionObserver
32917:     /**
32917:      * Chardet calls this to report the detection result
32917:      */
32917:     NS_IMETHOD Notify(const char* aCharset, nsDetectionConfident aConf);
32917: 
41448:     // EncodingDeclarationHandler
41449:     // http://hg.mozilla.org/projects/htmlparser/file/tip/src/nu/validator/htmlparser/common/EncodingDeclarationHandler.java
32917:     /**
32917:      * Tree builder uses this to report a late <meta charset>
32917:      */
79445:     bool internalEncodingDeclaration(nsString* aEncoding);
32917: 
32917:     // Not from an external interface
32917: 
32917:     /**
32917:      *  Call this method once you've created a parser, and want to instruct it
32917:      *  about what charset to load
32917:      *
32917:      *  @param   aCharset the charset of a document
32917:      *  @param   aCharsetSource the source of the charset
32917:      */
32917:     inline void SetDocumentCharset(const nsACString& aCharset, PRInt32 aSource) {
34979:       NS_PRECONDITION(mStreamState == STREAM_NOT_STARTED,
34979:                       "SetDocumentCharset called too late.");
34979:       NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
32917:       mCharset = aCharset;
32917:       mCharsetSource = aSource;
32917:     }
32917:     
32917:     inline void SetObserver(nsIRequestObserver* aObserver) {
34979:       NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
32917:       mObserver = aObserver;
32917:     }
32917: 
32917:     nsresult GetChannel(nsIChannel** aChannel);
32917: 
34979:     /**
34979:      * The owner parser must call this after script execution
34979:      * when no scripts are executing and the document.written 
34979:      * buffer has been exhausted.
34979:      */
34979:     void ContinueAfterScripts(nsHtml5Tokenizer* aTokenizer, 
34979:                               nsHtml5TreeBuilder* aTreeBuilder,
79445:                               bool aLastWasCR);
34979: 
34986:     /**
41395:      * Continues the stream parser if the charset switch failed.
34986:      */
34986:     void ContinueAfterFailedCharsetSwitch();
34986: 
34979:     void Terminate() {
34979:       mozilla::MutexAutoLock autoLock(mTerminatedMutex);
80486:       mTerminated = true;
32917:     }
32917:     
41395:     void DropTimer();
41395: 
81156:     /**
81156:      * Sets mCharset and mCharsetSource appropriately for the XML View Source
81326:      * case if aEncoding names a supported rough ASCII superset and sets
81326:      * the mCharset and mCharsetSource to the UTF-8 default otherwise.
81156:      */
81326:     void SetEncodingFromExpat(const PRUnichar* aEncoding);
81156: 
34980:   private:
34979: 
34980: #ifdef DEBUG
79445:     bool IsParserThread() {
79445:       bool ret;
34980:       mThread->IsOnCurrentThread(&ret);
34980:       return ret;
34980:     }
34980: #endif
34980: 
80404:     void MarkAsBroken();
80404: 
41395:     /**
41395:      * Marks the stream parser as interrupted. If you ever add calls to this
41395:      * method, be sure to review Uninterrupt usage very, very carefully to
41395:      * avoid having a previous in-flight runnable cancel your Interrupt()
41395:      * call on the other thread too soon.
41395:      */
34981:     void Interrupt() {
34981:       mozilla::MutexAutoLock autoLock(mTerminatedMutex);
80486:       mInterrupted = true;
34981:     }
34981: 
34981:     void Uninterrupt() {
41395:       NS_ASSERTION(IsParserThread(), "Wrong thread!");
34981:       mTokenizerMutex.AssertCurrentThreadOwns();
34981:       // Not acquiring mTerminatedMutex because mTokenizerMutex is already
34981:       // held at this point and is already stronger.
80486:       mInterrupted = false;      
34981:     }
34981: 
41395:     /**
41395:      * Flushes the tree ops from the tree builder and disarms the flush
41395:      * timer.
41395:      */
41395:     void FlushTreeOpsAndDisarmTimer();
41395: 
34981:     void ParseAvailableData();
34980:     
34980:     void DoStopRequest();
34980:     
34980:     void DoDataAvailable(PRUint8* aBuffer, PRUint32 aLength);
34979: 
79445:     bool IsTerminatedOrInterrupted() {
34981:       mozilla::MutexAutoLock autoLock(mTerminatedMutex);
34981:       return mTerminated || mInterrupted;
34981:     }
34981: 
79445:     bool IsTerminated() {
34979:       mozilla::MutexAutoLock autoLock(mTerminatedMutex);
34979:       return mTerminated;
32917:     }
32917: 
32917:     /**
32917:      * True when there is a Unicode decoder already
32917:      */
79445:     inline bool HasDecoder() {
32917:       return !!mUnicodeDecoder;
32917:     }
32917: 
32917:     /**
32917:      * Push bytes from network when there is no Unicode decoder yet
32917:      */
32917:     nsresult SniffStreamBytes(const PRUint8* aFromSegment,
32917:                               PRUint32 aCount,
32917:                               PRUint32* aWriteCount);
32917: 
32917:     /**
32917:      * Push bytes from network when there is a Unicode decoder already
32917:      */
32917:     nsresult WriteStreamBytes(const PRUint8* aFromSegment,
32917:                               PRUint32 aCount,
32917:                               PRUint32* aWriteCount);
32917: 
32917:     /**
62647:      * Check whether every other byte in the sniffing buffer is zero.
62647:      */
62647:     void SniffBOMlessUTF16BasicLatin(const PRUint8* aFromSegment,
62647:                                      PRUint32 aCountToSniffingLimit);
62647: 
62647:     /**
32917:      * <meta charset> scan failed. Try chardet if applicable. After this, the
32917:      * the parser will have some encoding even if a last resolt fallback.
32917:      *
32917:      * @param aFromSegment The current network buffer or null if the sniffing
32917:      *                     buffer is being flushed due to network stream ending.
32917:      * @param aCount       The number of bytes in aFromSegment (ignored if
32917:      *                     aFromSegment is null)
32917:      * @param aWriteCount  Return value for how many bytes got read from the
32917:      *                     buffer.
32917:      * @param aCountToSniffingLimit The number of unfilled slots in
32917:      *                              mSniffingBuffer
32917:      */
32917:     nsresult FinalizeSniffing(const PRUint8* aFromSegment,
32917:                               PRUint32 aCount,
32917:                               PRUint32* aWriteCount,
32917:                               PRUint32 aCountToSniffingLimit);
32917: 
32917:     /**
32917:      * Set up the Unicode decoder and write the sniffing buffer into it
32917:      * followed by the current network buffer.
32917:      *
32917:      * @param aFromSegment The current network buffer or null if the sniffing
32917:      *                     buffer is being flushed due to network stream ending.
32917:      * @param aCount       The number of bytes in aFromSegment (ignored if
32917:      *                     aFromSegment is null)
32917:      * @param aWriteCount  Return value for how many bytes got read from the
32917:      *                     buffer.
32917:      */
32917:     nsresult SetupDecodingAndWriteSniffingBufferAndCurrentSegment(const PRUint8* aFromSegment,
32917:                                                                   PRUint32 aCount,
32917:                                                                   PRUint32* aWriteCount);
32917: 
32917:     /**
32917:      * Write the sniffing buffer into the Unicode decoder followed by the
32917:      * current network buffer.
32917:      *
32917:      * @param aFromSegment The current network buffer or null if the sniffing
32917:      *                     buffer is being flushed due to network stream ending.
32917:      * @param aCount       The number of bytes in aFromSegment (ignored if
32917:      *                     aFromSegment is null)
32917:      * @param aWriteCount  Return value for how many bytes got read from the
32917:      *                     buffer.
32917:      */
32917:     nsresult WriteSniffingBufferAndCurrentSegment(const PRUint8* aFromSegment,
32917:                                                   PRUint32 aCount,
32917:                                                   PRUint32* aWriteCount);
32917: 
32917:     /**
32917:      * Initialize the Unicode decoder, mark the BOM as the source and
32917:      * drop the sniffer.
32917:      *
32917:      * @param aCharsetName The charset name to report to the outside (UTF-16
32917:      *                     or UTF-8)
32917:      * @param aDecoderCharsetName The actual name for the decoder's charset
32917:      *                            (UTF-16BE, UTF-16LE or UTF-8; the BOM has
32917:      *                            been swallowed)
32917:      */
32917:     nsresult SetupDecodingFromBom(const char* aCharsetName,
32917:                                   const char* aDecoderCharsetName);
32917: 
35600:     /**
81156:      * Become confident or resolve and encoding name to its preferred form.
81156:      * @param aEncoding the value of an internal encoding decl. Acts as an
81156:      *                  out param, too, when the method returns true.
81156:      * @return true if the parser needs to start using the new value of
81156:      *         aEncoding and false if the parser became confident or if
81156:      *         the encoding name did not specify a usable encoding
81156:      */
81156:     bool PreferredForInternalEncodingDecl(nsACString& aEncoding);
81156: 
81156:     /**
35600:      * Callback for mFlushTimer.
35600:      */
35600:     static void TimerCallback(nsITimer* aTimer, void* aClosure);
35600: 
35600:     /**
35600:      * Parser thread entry point for (maybe) flushing the ops and posting
35600:      * a flush runnable back on the main thread.
35600:      */
35600:     void TimerFlush();
35600: 
32917:     nsCOMPtr<nsIRequest>          mRequest;
32917:     nsCOMPtr<nsIRequestObserver>  mObserver;
32917: 
32917:     /**
32917:      * The Unicode decoder
32917:      */
32917:     nsCOMPtr<nsIUnicodeDecoder>   mUnicodeDecoder;
32917: 
32917:     /**
32917:      * The buffer for sniffing the character encoding
32917:      */
32917:     nsAutoArrayPtr<PRUint8>       mSniffingBuffer;
32917: 
32917:     /**
32917:      * The number of meaningful bytes in mSniffingBuffer
32917:      */
32917:     PRUint32                      mSniffingLength;
32917: 
32917:     /**
32917:      * BOM sniffing state
32917:      */
32917:     eBomState                     mBomState;
32917: 
32917:     /**
32917:      * <meta> prescan implementation
32917:      */
32917:     nsAutoPtr<nsHtml5MetaScanner> mMetaScanner;
32917: 
32917:     // encoding-related stuff
32917:     /**
32917:      * The source (confidence) of the character encoding in use
32917:      */
32917:     PRInt32                       mCharsetSource;
32917: 
32917:     /**
32917:      * The character encoding in use
32917:      */
32917:     nsCString                     mCharset;
32917: 
34979:     /**
34979:      * Whether reparse is forbidden
34979:      */
79445:     bool                          mReparseForbidden;
34979: 
32917:     // Portable parser objects
32917:     /**
32917:      * The first buffer in the pending UTF-16 buffer queue
32917:      */
80404:     nsRefPtr<nsHtml5OwningUTF16Buffer> mFirstBuffer;
32917: 
32917:     /**
32917:      * The last buffer in the pending UTF-16 buffer queue
32917:      */
80404:     nsHtml5OwningUTF16Buffer*     mLastBuffer; // weak ref; always points to
32917:                       // a buffer of the size NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE
32917: 
32917:     /**
32917:      * The tree operation executor
32917:      */
32917:     nsHtml5TreeOpExecutor*        mExecutor;
32917: 
32917:     /**
32917:      * The HTML5 tree builder
32917:      */
34979:     nsAutoPtr<nsHtml5TreeBuilder> mTreeBuilder;
32917: 
32917:     /**
32917:      * The HTML5 tokenizer
32917:      */
34979:     nsAutoPtr<nsHtml5Tokenizer>   mTokenizer;
32917: 
34979:     /**
34979:      * Makes sure the main thread can't mess the tokenizer state while it's
34981:      * tokenizing. This mutex also protects the current speculation.
34979:      */
34979:     mozilla::Mutex                mTokenizerMutex;
34979: 
34979:     /**
34979:      * The scoped atom table
34979:      */
34979:     nsHtml5AtomTable              mAtomTable;
34979: 
34979:     /**
34979:      * The owner parser.
34979:      */
34983:     nsRefPtr<nsHtml5Parser>       mOwner;
32917: 
32917:     /**
32917:      * Whether the last character tokenized was a carriage return (for CRLF)
32917:      */
79445:     bool                          mLastWasCR;
32917: 
32917:     /**
34979:      * For tracking stream life cycle
32917:      */
34979:     eHtml5StreamState             mStreamState;
32917:     
32917:     /**
34981:      * Whether we are speculating.
32917:      */
79445:     bool                          mSpeculating;
34981: 
34981:     /**
34981:      * Whether the tokenizer has reached EOF. (Reset when stream rewinded.)
34981:      */
79445:     bool                          mAtEOF;
34981: 
34981:     /**
34981:      * The speculations. The mutex protects the nsTArray itself.
34981:      * To access the queue of current speculation, mTokenizerMutex must be 
34981:      * obtained.
34981:      * The current speculation is the last element
34981:      */
34981:     nsTArray<nsAutoPtr<nsHtml5Speculation> >  mSpeculations;
34981:     mozilla::Mutex                            mSpeculationMutex;
32917: 
32917:     /**
34979:      * True to terminate early; protected by mTerminatedMutex
32917:      */
79445:     bool                          mTerminated;
79445:     bool                          mInterrupted;
34979:     mozilla::Mutex                mTerminatedMutex;
32917:     
34980:     /**
34980:      * The thread this stream parser runs on.
34980:      */
34980:     nsCOMPtr<nsIThread>           mThread;
34980:     
34980:     nsCOMPtr<nsIRunnable>         mExecutorFlusher;
34981:     
39737:     nsCOMPtr<nsIRunnable>         mLoadFlusher;
39737: 
34981:     /**
37402:      * The chardet instance if chardet is enabled.
37402:      */
37402:     nsCOMPtr<nsICharsetDetector>  mChardet;
37402: 
37402:     /**
62346:      * If false, don't push data to chardet.
62346:      */
79445:     bool                          mFeedChardet;
62346: 
62346:     /**
35600:      * Timer for flushing tree ops once in a while when not speculating.
35600:      */
35600:     nsCOMPtr<nsITimer>            mFlushTimer;
35600: 
35600:     /**
41395:      * Keeps track whether mFlushTimer has been armed. Unfortunately,
41395:      * nsITimer doesn't enable querying this from the timer itself.
35600:      */
79445:     bool                          mFlushTimerArmed;
35600: 
35600:     /**
41395:      * False initially and true after the timer has fired at least once.
35600:      */
79445:     bool                          mFlushTimerEverFired;
35600: 
35600:     /**
81151:      * Whether the parser is doing a normal parse, view source or plain text.
81151:      */
81151:     eParserMode                   mMode;
81151: 
81151:     /**
41395:      * The pref html5.flushtimer.initialdelay: Time in milliseconds between
41395:      * the time a network buffer is seen and the timer firing when the
41395:      * timer hasn't fired previously in this parse.
35600:      */
41395:     static PRInt32                sTimerInitialDelay;
41395: 
41395:     /**
41395:      * The pref html5.flushtimer.subsequentdelay: Time in milliseconds between
41395:      * the time a network buffer is seen and the timer firing when the
41395:      * timer has already fired previously in this parse.
41395:      */
41395:     static PRInt32                sTimerSubsequentDelay;
32917: };
32917: 
32917: #endif // nsHtml5StreamParser_h__
