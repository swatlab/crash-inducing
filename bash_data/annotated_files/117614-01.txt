 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JavaScript API.
     1:  */
 95341: 
 95341: #include "mozilla/FloatingPoint.h"
110844: #include "mozilla/ThreadLocal.h"
 95341: 
     1: #include <ctype.h>
     1: #include <stdarg.h>
     1: #include <stdlib.h>
     1: #include <string.h>
 58990: #include <sys/stat.h>
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
     1: #include "jsclist.h"
     1: #include "jsprf.h"
     1: #include "jsapi.h"
     1: #include "jsarray.h"
     1: #include "jsatom.h"
     1: #include "jsbool.h"
 54863: #include "jsclone.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsdate.h"
 88135: #include "jsdtoa.h"
     1: #include "jsexn.h"
     1: #include "jsfun.h"
     1: #include "jsgc.h"
     1: #include "jsinterp.h"
  6464: #include "jsiter.h"
     1: #include "jslock.h"
     1: #include "jsmath.h"
 88135: #include "jsnativestack.h"
     1: #include "jsnum.h"
 20092: #include "json.h"
     1: #include "jsobj.h"
     1: #include "jsopcode.h"
 73746: #include "jsprobes.h"
 42733: #include "jsproxy.h"
     1: #include "jsscope.h"
     1: #include "jsscript.h"
     1: #include "jsstr.h"
     1: #include "prmjtime.h"
 68911: #include "jsweakmap.h"
113582: #include "jsworkers.h"
 47498: #include "jswrapper.h"
 37042: #include "jstypedarray.h"
 94006: #include "jsxml.h"
     1: 
103638: #include "builtin/Eval.h"
 87812: #include "builtin/MapObject.h"
 79981: #include "builtin/RegExp.h"
108659: #include "builtin/ParallelArray.h"
103638: #include "ds/LifoAlloc.h"
 80507: #include "frontend/BytecodeCompiler.h"
 97569: #include "gc/Marking.h"
 89806: #include "gc/Memory.h"
 86104: #include "js/MemoryMetrics.h"
 97045: #include "vm/NumericConversions.h"
 93300: #include "vm/StringBuffer.h"
 94006: #include "vm/Xdr.h"
103638: #include "yarr/BumpPointerAllocator.h"
 79981: 
 34349: #include "jsatominlines.h"
 77343: #include "jsinferinlines.h"
114192: #include "jsinterpinlines.h"
 48470: #include "jsobjinlines.h"
 34349: #include "jsscopeinlines.h"
 59968: #include "jsscriptinlines.h"
 50493: 
 93701: #include "vm/ObjectImpl-inl.h"
 79981: #include "vm/RegExpObject-inl.h"
 82129: #include "vm/RegExpStatics-inl.h"
 69223: #include "vm/Stack-inl.h"
 72107: #include "vm/String-inl.h"
 69223: 
 50493: #if ENABLE_YARR_JIT
 50491: #include "assembler/jit/ExecutableAllocator.h"
 50491: #include "methodjit/Logging.h"
 50493: #endif
 34349: 
112298: #ifdef JS_METHODJIT
111677: #include "ion/Ion.h"
111677: #endif
111677: 
 37741: using namespace js;
 54707: using namespace js::gc;
 77343: using namespace js::types;
105835: using js::frontend::Parser;
 37741: 
105479: bool
105479: JS::detail::CallMethodIfWrapped(JSContext *cx, IsAcceptableThis test, NativeImpl impl,
105479:                                CallArgs args)
105479: {
105479:     const Value &thisv = args.thisv();
105479:     JS_ASSERT(!test(thisv));
105479: 
105479:     if (thisv.isObject()) {
105479:         JSObject &thisObj = args.thisv().toObject();
105479:         if (thisObj.isProxy())
105479:             return Proxy::nativeCall(cx, test, impl, args);
105479:     }
105479: 
105479:     ReportIncompatible(cx, args);
105479:     return false;
105479: }
105479: 
105479: 
 61450: /*
 99821:  * This class is a version-establishing barrier at the head of a VM entry or
 61450:  * re-entry. It ensures that:
 61450:  *
 61450:  * - |newVersion| is the starting (default) version used for the context.
 61450:  * - The starting version state is not an override.
 61450:  * - Overrides in the VM session are not propagated to the caller.
 61450:  */
 53848: class AutoVersionAPI
 53848: {
 53848:     JSContext   * const cx;
 61450:     JSVersion   oldDefaultVersion;
 61450:     bool        oldHasVersionOverride;
 61450:     JSVersion   oldVersionOverride;
 61450: #ifdef DEBUG
 91237:     unsigned       oldCompileOptions;
 61450: #endif
 61450:     JSVersion   newVersion;
 53848: 
 53848:   public:
 99821:     AutoVersionAPI(JSContext *cx, JSVersion newVersion)
 61450:       : cx(cx),
 61450:         oldDefaultVersion(cx->getDefaultVersion()),
 61450:         oldHasVersionOverride(cx->isVersionOverridden()),
 61450:         oldVersionOverride(oldHasVersionOverride ? cx->findVersion() : JSVERSION_UNKNOWN)
 61450: #ifdef DEBUG
 61450:         , oldCompileOptions(cx->getCompileOptions())
 61450: #endif
 61450:     {
 99821: #if JS_HAS_XML_SUPPORT
 99821:         // For backward compatibility, AutoVersionAPI clobbers the
 99821:         // JSOPTION_MOAR_XML bit in cx, but not the JSOPTION_ALLOW_XML bit.
 99821:         newVersion = JSVersion(newVersion | (oldDefaultVersion & VersionFlags::ALLOW_XML));
 99821: #endif
 61450:         this->newVersion = newVersion;
 61450:         cx->clearVersionOverride();
 61450:         cx->setDefaultVersion(newVersion);
 61425:     }
 61425: 
 61425:     ~AutoVersionAPI() {
 61450:         cx->setDefaultVersion(oldDefaultVersion);
 61450:         if (oldHasVersionOverride)
 61450:             cx->overrideVersion(oldVersionOverride);
 61450:         else
 61424:             cx->clearVersionOverride();
 61450:         JS_ASSERT(oldCompileOptions == cx->getCompileOptions());
 61450:     }
 61450: 
 61450:     /* The version that this scoped-entity establishes. */
 61450:     JSVersion version() const { return newVersion; }
 53848: };
 53848: 
     1: #ifdef HAVE_VA_LIST_AS_ARRAY
     1: #define JS_ADDRESSOF_VA_LIST(ap) ((va_list *)(ap))
     1: #else
     1: #define JS_ADDRESSOF_VA_LIST(ap) (&(ap))
     1: #endif
     1: 
 78613: #ifdef JS_USE_JSID_STRUCT_TYPES
 78613: jsid JS_DEFAULT_XML_NAMESPACE_ID = { size_t(JSID_TYPE_DEFAULT_XML_NAMESPACE) };
 78613: jsid JSID_VOID  = { size_t(JSID_TYPE_VOID) };
 78613: jsid JSID_EMPTY = { size_t(JSID_TYPE_OBJECT) };
 48470: #endif
 48470: 
 78613: const jsval JSVAL_NULL  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_NULL,      0));
 78613: const jsval JSVAL_ZERO  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_INT32,     0));
 78613: const jsval JSVAL_ONE   = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_INT32,     1));
 78613: const jsval JSVAL_FALSE = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   JS_FALSE));
 78613: const jsval JSVAL_TRUE  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   JS_TRUE));
 78613: const jsval JSVAL_VOID  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_UNDEFINED, 0));
 25901: 
 48540: /* Make sure that jschar is two bytes unsigned integer */
 48540: JS_STATIC_ASSERT((jschar)-1 > 0);
 48540: JS_STATIC_ASSERT(sizeof(jschar) == 2);
 48540: 
 84755: JS_PUBLIC_API(int64_t)
     1: JS_Now()
     1: {
     1:     return PRMJ_Now();
     1: }
     1: 
     1: JS_PUBLIC_API(jsval)
     1: JS_GetNaNValue(JSContext *cx)
     1: {
 78614:     return cx->runtime->NaNValue;
     1: }
     1: 
     1: JS_PUBLIC_API(jsval)
     1: JS_GetNegativeInfinityValue(JSContext *cx)
     1: {
 78614:     return cx->runtime->negativeInfinityValue;
     1: }
     1: 
     1: JS_PUBLIC_API(jsval)
     1: JS_GetPositiveInfinityValue(JSContext *cx)
     1: {
 78614:     return cx->runtime->positiveInfinityValue;
     1: }
     1: 
     1: JS_PUBLIC_API(jsval)
     1: JS_GetEmptyStringValue(JSContext *cx)
     1: {
     1:     return STRING_TO_JSVAL(cx->runtime->emptyString);
     1: }
     1: 
 58976: JS_PUBLIC_API(JSString *)
 58976: JS_GetEmptyString(JSRuntime *rt)
 58976: {
 87611:     JS_ASSERT(rt->hasContexts());
 58976:     return rt->emptyString;
 58976: }
 58976: 
 86458: static void
103783: AssertHeapIsIdle(JSRuntime *rt)
103783: {
103783:     JS_ASSERT(rt->heapState == JSRuntime::Idle);
 86458: }
 86458: 
 86458: static void
103783: AssertHeapIsIdle(JSContext *cx)
103783: {
103783:     AssertHeapIsIdle(cx->runtime);
 86458: }
 86458: 
 86458: static void
103785: AssertHeapIsIdleOrIterating(JSRuntime *rt)
103785: {
103785:     JS_ASSERT(rt->heapState != JSRuntime::Collecting);
103785: }
103785: 
103785: static void
103785: AssertHeapIsIdleOrIterating(JSContext *cx)
103785: {
103785:     AssertHeapIsIdleOrIterating(cx->runtime);
103785: }
103785: 
103785: static void
103783: AssertHeapIsIdleOrStringIsFlat(JSContext *cx, JSString *str)
 86458: {
 86458:     /*
 86458:      * We allow some functions to be called during a GC as long as the argument
 86458:      * is a flat string, since that will not cause allocation.
 86458:      */
103783:     JS_ASSERT_IF(cx->runtime->isHeapBusy(), str->isFlat());
 86458: }
 86458: 
     1: JS_PUBLIC_API(JSBool)
 91237: JS_ConvertArguments(JSContext *cx, unsigned argc, jsval *argv, const char *format, ...)
     1: {
     1:     va_list ap;
     1:     JSBool ok;
     1: 
103783:     AssertHeapIsIdle(cx);
 86458: 
     1:     va_start(ap, format);
     1:     ok = JS_ConvertArgumentsVA(cx, argc, argv, format, ap);
     1:     va_end(ap);
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 91237: JS_ConvertArgumentsVA(JSContext *cx, unsigned argc, jsval *argv, const char *format, va_list ap)
     1: {
     1:     jsval *sp;
     1:     JSBool required;
     1:     char c;
 90955:     double d;
     1:     JSString *str;
107154:     RootedObject obj(cx);
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 48470:     assertSameCompartment(cx, JSValueArray(argv - 2, argc + 2));
     1:     sp = argv;
     1:     required = JS_TRUE;
     1:     while ((c = *format++) != '\0') {
     1:         if (isspace(c))
     1:             continue;
     1:         if (c == '/') {
     1:             required = JS_FALSE;
     1:             continue;
     1:         }
     1:         if (sp == argv + argc) {
     1:             if (required) {
103274:                 if (JSFunction *fun = ReportIfNotFunction(cx, argv[-2])) {
     1:                     char numBuf[12];
     1:                     JS_snprintf(numBuf, sizeof numBuf, "%u", argc);
 57812:                     JSAutoByteString funNameBytes;
 57812:                     if (const char *name = GetFunctionNameBytes(cx, fun, &funNameBytes)) {
 57812:                         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
 57812:                                              name, numBuf, (argc == 1) ? "" : "s");
 57812:                     }
     1:                 }
     1:                 return JS_FALSE;
     1:             }
     1:             break;
     1:         }
     1:         switch (c) {
     1:           case 'b':
106378:             *va_arg(ap, JSBool *) = ToBoolean(*sp);
     1:             break;
     1:           case 'c':
 84755:             if (!JS_ValueToUint16(cx, *sp, va_arg(ap, uint16_t *)))
     1:                 return JS_FALSE;
     1:             break;
     1:           case 'i':
 84755:             if (!JS_ValueToECMAInt32(cx, *sp, va_arg(ap, int32_t *)))
     1:                 return JS_FALSE;
     1:             break;
     1:           case 'u':
 84755:             if (!JS_ValueToECMAUint32(cx, *sp, va_arg(ap, uint32_t *)))
     1:                 return JS_FALSE;
     1:             break;
     1:           case 'j':
 84755:             if (!JS_ValueToInt32(cx, *sp, va_arg(ap, int32_t *)))
     1:                 return JS_FALSE;
     1:             break;
     1:           case 'd':
 90955:             if (!JS_ValueToNumber(cx, *sp, va_arg(ap, double *)))
     1:                 return JS_FALSE;
     1:             break;
     1:           case 'I':
 12694:             if (!JS_ValueToNumber(cx, *sp, &d))
     1:                 return JS_FALSE;
 97045:             *va_arg(ap, double *) = ToInteger(d);
     1:             break;
     1:           case 'S':
     1:           case 'W':
 84160:             str = ToString(cx, *sp);
     1:             if (!str)
     1:                 return JS_FALSE;
     1:             *sp = STRING_TO_JSVAL(str);
 57814:             if (c == 'W') {
114424:                 JSStableString *stable = str->ensureStable(cx);
114424:                 if (!stable)
     1:                     return JS_FALSE;
114424:                 *va_arg(ap, const jschar **) = stable->chars();
     1:             } else {
     1:                 *va_arg(ap, JSString **) = str;
     1:             }
     1:             break;
     1:           case 'o':
 78614:             if (!js_ValueToObjectOrNull(cx, *sp, &obj))
     1:                 return JS_FALSE;
     1:             *sp = OBJECT_TO_JSVAL(obj);
     1:             *va_arg(ap, JSObject **) = obj;
     1:             break;
     1:           case 'f':
103274:             obj = ReportIfNotFunction(cx, *sp);
     1:             if (!obj)
     1:                 return JS_FALSE;
 10574:             *sp = OBJECT_TO_JSVAL(obj);
 83234:             *va_arg(ap, JSFunction **) = obj->toFunction();
     1:             break;
     1:           case 'v':
     1:             *va_arg(ap, jsval *) = *sp;
     1:             break;
     1:           case '*':
     1:             break;
     1:           default:
113884:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_CHAR, format);
     1:             return JS_FALSE;
     1:         }
     1:         sp++;
     1:     }
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
111462: JS_ConvertValue(JSContext *cx, jsval valueArg, JSType type, jsval *vp)
111462: {
111462:     RootedValue value(cx, valueArg);
 10449:     JSBool ok;
107154:     RootedObject obj(cx);
     1:     JSString *str;
 90955:     double d;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
     1:     switch (type) {
     1:       case JSTYPE_VOID:
     1:         *vp = JSVAL_VOID;
     1:         ok = JS_TRUE;
     1:         break;
     1:       case JSTYPE_OBJECT:
111462:         ok = js_ValueToObjectOrNull(cx, value, &obj);
     1:         if (ok)
     1:             *vp = OBJECT_TO_JSVAL(obj);
     1:         break;
     1:       case JSTYPE_FUNCTION:
111462:         *vp = value;
103274:         obj = ReportIfNotFunction(cx, *vp);
     1:         ok = (obj != NULL);
     1:         break;
     1:       case JSTYPE_STRING:
111462:         str = ToString(cx, value);
     1:         ok = (str != NULL);
     1:         if (ok)
     1:             *vp = STRING_TO_JSVAL(str);
     1:         break;
     1:       case JSTYPE_NUMBER:
111462:         ok = JS_ValueToNumber(cx, value, &d);
     1:         if (ok)
 48470:             *vp = DOUBLE_TO_JSVAL(d);
     1:         break;
     1:       case JSTYPE_BOOLEAN:
111462:         *vp = BooleanValue(ToBoolean(value));
 10449:         return JS_TRUE;
     1:       default: {
     1:         char numBuf[12];
     1:         JS_snprintf(numBuf, sizeof numBuf, "%d", (int)type);
 43229:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_TYPE, numBuf);
     1:         ok = JS_FALSE;
     1:         break;
     1:       }
     1:     }
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
111462: JS_ValueToObject(JSContext *cx, jsval valueArg, JSObject **objpArg)
111462: {
111462:     RootedValue value(cx, valueArg);
107154:     RootedObject objp(cx, *objpArg);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
111462:     if (!js_ValueToObjectOrNull(cx, value, &objp))
107154:         return false;
107154:     *objpArg = objp;
107154:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
111462: JS_ValueToFunction(JSContext *cx, jsval valueArg)
111462: {
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
111462:     return ReportIfNotFunction(cx, value);
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
111462: JS_ValueToConstructor(JSContext *cx, jsval valueArg)
111462: {
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
111462:     return ReportIfNotFunction(cx, value);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
111462: JS_ValueToString(JSContext *cx, jsval valueArg)
111462: {
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
111462:     return ToString(cx, value);
     1: }
     1: 
 21482: JS_PUBLIC_API(JSString *)
111462: JS_ValueToSource(JSContext *cx, jsval valueArg)
111462: {
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
111462:     return js_ValueToSource(cx, value);
111462: }
111462: 
111462: JS_PUBLIC_API(JSBool)
111462: JS_ValueToNumber(JSContext *cx, jsval valueArg, double *dp)
111462: {
111462:     RootedValue value(cx, valueArg);
107246:     return JS::ToNumber(cx, value, dp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 91450: JS_DoubleIsInt32(double d, int32_t *ip)
 91450: {
 95341:     return MOZ_DOUBLE_IS_INT32(d, ip);
 39905: }
 39905: 
 84755: JS_PUBLIC_API(int32_t)
 90955: JS_DoubleToInt32(double d)
 64550: {
 97045:     return ToInt32(d);
 64550: }
 64550: 
 84755: JS_PUBLIC_API(uint32_t)
 90955: JS_DoubleToUint32(double d)
 64550: {
 97045:     return ToUint32(d);
 64550: }
 64550: 
 39905: JS_PUBLIC_API(JSBool)
111462: JS_ValueToECMAInt32(JSContext *cx, jsval valueArg, int32_t *ip)
111462: {
111462:     RootedValue value(cx, valueArg);
107246:     return JS::ToInt32(cx, value, ip);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
111462: JS_ValueToECMAUint32(JSContext *cx, jsval valueArg, uint32_t *ip)
111462: {
111462:     RootedValue value(cx, valueArg);
107246:     return JS::ToUint32(cx, value, ip);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
111462: JS_ValueToInt64(JSContext *cx, jsval valueArg, int64_t *ip)
111462: {
111462:     RootedValue value(cx, valueArg);
107392:     return JS::ToInt64(cx, value, ip);
107392: }
107392: 
107392: JS_PUBLIC_API(JSBool)
111462: JS_ValueToUint64(JSContext *cx, jsval valueArg, uint64_t *ip)
111462: {
111462:     RootedValue value(cx, valueArg);
107392:     return JS::ToUint64(cx, value, ip);
107392: }
107392: 
107392: JS_PUBLIC_API(JSBool)
108174: JS_ValueToInt32(JSContext *cx, jsval vArg, int32_t *ip)
108174: {
108174:     AssertHeapIsIdle(cx);
108174:     CHECK_REQUEST(cx);
108174: 
108174:     RootedValue v(cx, vArg);
 47485:     assertSameCompartment(cx, v);
 33178: 
 98811:     if (v.isInt32()) {
 98811:         *ip = v.toInt32();
 98811:         return true;
 98811:     }
 98811: 
 98811:     double d;
 98811:     if (v.isDouble()) {
 98811:         d = v.toDouble();
 98811:     } else if (!ToNumberSlow(cx, v, &d)) {
 98811:         return false;
 98811:     }
 98811: 
 98811:     if (MOZ_DOUBLE_IS_NaN(d) || d <= -2147483649.0 || 2147483648.0 <= d) {
 98811:         js_ReportValueError(cx, JSMSG_CANT_CONVERT,
108174:                             JSDVG_SEARCH_STACK, v, NullPtr());
 98811:         return false;
 98811:     }
 98811: 
 98811:     *ip = (int32_t) floor(d + 0.5);  /* Round to nearest */
 98811:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
111462: JS_ValueToUint16(JSContext *cx, jsval valueArg, uint16_t *ip)
111462: {
111462:     RootedValue value(cx, valueArg);
111462:     return ToUint16(cx, value, ip);
111462: }
111462: 
111462: JS_PUBLIC_API(JSBool)
111462: JS_ValueToBoolean(JSContext *cx, jsval valueArg, JSBool *bp)
111462: {
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
111462:     *bp = ToBoolean(value);
 10449:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSType)
111462: JS_TypeOfValue(JSContext *cx, jsval valueArg)
111462: {
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
111462:     return TypeOfValue(cx, value);
     1: }
     1: 
     1: JS_PUBLIC_API(const char *)
     1: JS_GetTypeName(JSContext *cx, JSType type)
     1: {
 91237:     if ((unsigned)type >= (unsigned)JSTYPE_LIMIT)
     1:         return NULL;
114199:     return TypeStrings[type];
     1: }
     1: 
 28408: JS_PUBLIC_API(JSBool)
111462: JS_StrictlyEqual(JSContext *cx, jsval value1Arg, jsval value2Arg, JSBool *equal)
111462: {
111462:     RootedValue value1(cx, value1Arg);
111462:     RootedValue value2(cx, value2Arg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value1, value2);
 88099:     bool eq;
111462:     if (!StrictlyEqual(cx, value1, value2, &eq))
 88099:         return false;
 88099:     *equal = eq;
 88099:     return true;
 28408: }
 28408: 
 32760: JS_PUBLIC_API(JSBool)
111462: JS_LooselyEqual(JSContext *cx, jsval value1Arg, jsval value2Arg, JSBool *equal)
111462: {
111462:     RootedValue value1(cx, value1Arg);
111462:     RootedValue value2(cx, value2Arg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value1, value2);
 88099:     bool eq;
111462:     if (!LooselyEqual(cx, value1, value2, &eq))
 88099:         return false;
 88099:     *equal = eq;
 88099:     return true;
 64551: }
 64551: 
 64551: JS_PUBLIC_API(JSBool)
111462: JS_SameValue(JSContext *cx, jsval value1Arg, jsval value2Arg, JSBool *same)
111462: {
111462:     RootedValue value1(cx, value1Arg);
111462:     RootedValue value2(cx, value2Arg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value1, value2);
 88099:     bool s;
111462:     if (!SameValue(cx, value1, value2, &s))
 88099:         return false;
 88099:     *same = s;
 88099:     return true;
 32760: }
 32760: 
 64210: JS_PUBLIC_API(JSBool)
 64210: JS_IsBuiltinEvalFunction(JSFunction *fun)
 64210: {
 64228:     return IsAnyBuiltinEval(fun);
 64210: }
 64210: 
 64210: JS_PUBLIC_API(JSBool)
 64210: JS_IsBuiltinFunctionConstructor(JSFunction *fun)
 64210: {
 64210:     return IsBuiltinFunctionConstructor(fun);
 64210: }
 64210: 
     1: /************************************************************************/
     1: 
  8893: /*
  8893:  * Has a new runtime ever been created?  This flag is used to detect unsafe
  8893:  * changes to js_CStringsAreUTF8 after a runtime has been created, and to
 73748:  * control things that should happen only once across all runtimes.
  8893:  */
  8893: static JSBool js_NewRuntimeWasCalled = JS_FALSE;
  8893: 
110844: /*
110844:  * Thread Local Storage slot for storing the runtime for a thread.
110844:  */
110844: namespace JS {
110844: mozilla::ThreadLocal<JSRuntime *> TlsRuntime;
111593: 
111593: #ifdef DEBUG
111593: JS_FRIEND_API(void)
111593: EnterAssertNoGCScope()
111593: {
111593:     ++TlsRuntime.get()->gcAssertNoGCDepth;
111593: }
111593: 
111593: JS_FRIEND_API(void)
111593: LeaveAssertNoGCScope()
111593: {
111593:     --TlsRuntime.get()->gcAssertNoGCDepth;
111593:     JS_ASSERT(TlsRuntime.get()->gcAssertNoGCDepth >= 0);
111593: }
111593: 
111593: JS_FRIEND_API(bool)
111593: InNoGCScope()
111593: {
111593:     return TlsRuntime.get()->gcAssertNoGCDepth > 0;
111593: }
111593: 
111593: JS_FRIEND_API(bool)
111593: NeedRelaxedRootChecks()
111593: {
111593:     return TlsRuntime.get()->gcRelaxRootChecks;
111593: }
111593: #else
111593: JS_FRIEND_API(void) EnterAssertNoGCScope() {}
111593: JS_FRIEND_API(void) LeaveAssertNoGCScope() {}
111593: JS_FRIEND_API(bool) InNoGCScope() { return false; }
111593: JS_FRIEND_API(bool) NeedRelaxedRootChecks() { return false; }
111593: #endif
111593: 
111593: } /* namespace JS */
110844: 
 91900: static const JSSecurityCallbacks NullSecurityCallbacks = { };
 91900: 
 34299: JSRuntime::JSRuntime()
 89261:   : atomsCompartment(NULL),
 88135: #ifdef JS_THREADSAFE
 88135:     ownerThread_(NULL),
 88135: #endif
 88135:     tempLifoAlloc(TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE),
106660:     freeLifoAlloc(TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE),
 88135:     execAlloc_(NULL),
 88135:     bumpAlloc_(NULL),
 97464: #ifdef JS_METHODJIT
 97464:     jaegerRuntime_(NULL),
 97464: #endif
108585:     selfHostedGlobal_(NULL),
 89261:     nativeStackBase(0),
 89261:     nativeStackQuota(0),
 88135:     interpreterFrames(NULL),
 79507:     cxCallback(NULL),
 94740:     destroyCompartmentCallback(NULL),
106510:     compartmentNameCallback(NULL),
 79507:     activityCallback(NULL),
 79507:     activityCallbackArg(NULL),
 88135: #ifdef JS_THREADSAFE
 88135:     requestDepth(0),
 88135: # ifdef DEBUG
 88135:     checkRequestDepth(0),
 88135: # endif
 88135: #endif
 79507:     gcSystemAvailableChunkListHead(NULL),
 79507:     gcUserAvailableChunkListHead(NULL),
 79507:     gcKeepAtoms(0),
 79507:     gcBytes(0),
 79507:     gcMaxBytes(0),
 79507:     gcMaxMallocBytes(0),
 85064:     gcNumArenasFreeCommitted(0),
105981:     gcVerifyPreData(NULL),
105981:     gcVerifyPostData(NULL),
 79507:     gcChunkAllocationSinceLastGC(false),
 79507:     gcNextFullGCTime(0),
104267:     gcLastGCTime(0),
 79507:     gcJitReleaseTime(0),
 79507:     gcMode(JSGC_MODE_GLOBAL),
117018:     gcAllocationThreshold(30 * 1024 * 1024),
104267:     gcHighFrequencyGC(false),
104267:     gcHighFrequencyTimeThreshold(1000),
104267:     gcHighFrequencyLowLimitBytes(100 * 1024 * 1024),
104267:     gcHighFrequencyHighLimitBytes(500 * 1024 * 1024),
104267:     gcHighFrequencyHeapGrowthMax(3.0),
104267:     gcHighFrequencyHeapGrowthMin(1.5),
104267:     gcLowFrequencyHeapGrowth(1.5),
104267:     gcDynamicHeapGrowth(false),
104267:     gcDynamicMarkSlice(false),
 99131:     gcShouldCleanUpEverything(false),
 79507:     gcIsNeeded(0),
 79507:     gcWeakMapList(NULL),
 80212:     gcStats(thisFromCtor()),
 90410:     gcNumber(0),
 90410:     gcStartNumber(0),
 95297:     gcIsFull(false),
 88182:     gcTriggerReason(gcreason::NO_REASON),
 94620:     gcStrictCompartmentChecking(false),
102262:     gcDisableStrictProxyCheckingCount(0),
 90410:     gcIncrementalState(gc::NO_INCREMENTAL),
 90410:     gcLastMarkSlice(false),
106556:     gcSweepOnBackgroundThread(false),
108913:     gcSweepingCompartments(NULL),
106556:     gcSweepPhase(0),
106556:     gcSweepCompartmentIndex(0),
106556:     gcSweepKindIndex(0),
106556:     gcArenasAllocatedDuringSweep(NULL),
 90410:     gcInterFrameGC(0),
 90410:     gcSliceBudget(SliceBudget::Unlimited),
 90410:     gcIncrementalEnabled(true),
 97353:     gcExactScanningEnabled(true),
111593: #ifdef DEBUG
111593:     gcRelaxRootChecks(false),
111593:     gcAssertNoGCDepth(0),
111593: #endif
 79507:     gcPoke(false),
103783:     heapState(Idle),
 79507: #ifdef JS_GC_ZEAL
 79507:     gcZeal_(0),
 79507:     gcZealFrequency(0),
 79507:     gcNextScheduled(0),
 91660:     gcDeterministicOnly(false),
102693:     gcIncrementalLimit(0),
 79507: #endif
108566:     gcValidate(true),
 79507:     gcCallback(NULL),
 90410:     gcSliceCallback(NULL),
 91339:     gcFinalizeCallback(NULL),
109045:     analysisPurgeCallback(NULL),
109045:     analysisPurgeTriggerBytes(0),
 99043:     gcMallocBytes(0),
 80159:     gcBlackRootsTraceOp(NULL),
 80159:     gcBlackRootsData(NULL),
 80159:     gcGrayRootsTraceOp(NULL),
 80159:     gcGrayRootsData(NULL),
 91250:     autoGCRooters(NULL),
 94574:     scriptAndCountsVector(NULL),
 79507:     NaNValue(UndefinedValue()),
 79507:     negativeInfinityValue(UndefinedValue()),
 79507:     positiveInfinityValue(UndefinedValue()),
 79507:     emptyString(NULL),
105947:     sourceHook(NULL),
 79507:     debugMode(false),
104307:     spsProfiler(thisFromCtor()),
 84803:     profilingScripts(false),
 98147:     alwaysPreserveCode(false),
 79507:     hadOutOfMemory(false),
 98921:     debugScopes(NULL),
114914:     liveArrayBuffers(NULL),
 79507:     data(NULL),
 79507:     gcLock(NULL),
 80215:     gcHelperThread(thisFromCtor()),
105944: #ifdef JS_THREADSAFE
105944:     sourceCompressorThread(thisFromCtor()),
105944: #endif
108915:     defaultFreeOp_(thisFromCtor(), false),
 79507:     debuggerMutations(0),
 91900:     securityCallbacks(const_cast<JSSecurityCallbacks *>(&NullSecurityCallbacks)),
107786:     DOMcallbacks(NULL),
 91900:     destroyPrincipals(NULL),
 80748:     structuredCloneCallbacks(NULL),
 80213:     telemetryCallback(NULL),
 79507:     propertyRemovals(0),
 79507:     thousandsSeparator(0),
 79507:     decimalSeparator(0),
 79507:     numGrouping(0),
 97464:     mathCache_(NULL),
 88135:     dtoaState(NULL),
 79507:     trustedPrincipals_(NULL),
 88135:     wrapObjectCallback(TransparentObjectWrapper),
 98430:     sameCompartmentWrapObjectCallback(NULL),
 79507:     preWrapObjectCallback(NULL),
 84729:     preserveWrapperCallback(NULL),
 88135: #ifdef DEBUG
 88135:     noGCOrAllocationCheck(0),
 88135: #endif
 90598:     inOOMReport(0),
112741:     jitHardening(false),
112479:     ionTop(NULL),
112479:     ionJSContext(NULL),
112479:     ionStackLimit(0),
112756:     ionActivation(NULL),
115708:     ionPcScriptCache(NULL),
112756:     ionReturnOverride_(MagicValue(JS_ARG_POISON))
 34299: {
 34299:     /* Initialize infallibly first, so we can goto bad and JS_DestroyRuntime. */
 34299:     JS_INIT_CLIST(&contextList);
 75451:     JS_INIT_CLIST(&debuggerList);
 79507: 
 91178:     PodZero(&debugHooks);
 79507:     PodZero(&atomState);
 89261: 
 89261: #if JS_STACK_GROWTH_DIRECTION > 0
 89261:     nativeStackLimit = UINTPTR_MAX;
 89261: #endif
 34299: }
 34299: 
 34299: bool
 84755: JSRuntime::init(uint32_t maxbytes)
 34299: {
 81562: #ifdef JS_THREADSAFE
 88135:     ownerThread_ = PR_GetCurrentThread();
 81562: #endif
 81562: 
110844:     JS::TlsRuntime.set(this);
110844: 
 50491: #ifdef JS_METHODJIT_SPEW
 50491:     JMCheckLogging();
 50491: #endif
 50491: 
111488: #if defined(JSGC_ROOT_ANALYSIS) || defined(JSGC_USE_EXACT_ROOTING)
111488:     PodArrayZero(thingGCRooters);
111488: #endif
111488: 
 64559:     if (!js_InitGC(this, maxbytes))
 64559:         return false;
 64559: 
 90410:     if (!gcMarker.init())
 90410:         return false;
 90410: 
 90934:     const char *size = getenv("JSGC_MARK_STACK_LIMIT");
 90934:     if (size)
 90934:         SetMarkStackLimit(this, atoi(size));
 90934: 
 64559:     if (!(atomsCompartment = this->new_<JSCompartment>(this)) ||
 77343:         !atomsCompartment->init(NULL) ||
108585:         !compartments.append(atomsCompartment))
108585:     {
110933:         js_delete(atomsCompartment);
 43286:         return false;
 47498:     }
 43286: 
 73901:     atomsCompartment->isSystemCompartment = true;
 91825:     atomsCompartment->setGCLastBytes(8192, 8192, GC_NORMAL);
 64559: 
114199:     if (!InitAtoms(this))
 34299:         return false;
 40281: 
 72090:     if (!InitRuntimeNumberState(this))
 72090:         return false;
 72090: 
 88135:     dtoaState = js_NewDtoaState();
 88135:     if (!dtoaState)
 88135:         return false;
 88135: 
 88135:     if (!stackSpace.init())
 88135:         return false;
 88135: 
 97463:     if (!scriptFilenameTable.init())
 97463:         return false;
 97463: 
105944: #ifdef JS_THREADSAFE
113655: # ifdef JS_ION
113582:     workerThreadState = this->new_<WorkerThreadState>();
113582:     if (!workerThreadState || !workerThreadState->init(this))
113582:         return false;
113655: # endif
113582: 
105944:     if (!sourceCompressorThread.init())
105944:         return false;
105944: #endif
105944: 
104377:     if (!evalCache.init())
104377:         return false;
104377: 
 98921:     debugScopes = this->new_<DebugScopes>(this);
 98921:     if (!debugScopes || !debugScopes->init()) {
110933:         js_delete(debugScopes);
 98921:         return false;
 98921:     }
 98921: 
 89261:     nativeStackBase = GetNativeStackBase();
 72090:     return true;
 34299: }
 34299: 
 34299: JSRuntime::~JSRuntime()
 34299: {
110844: #ifdef JS_THREADSAFE
110844:     clearOwnerThread();
110844: #endif
 98921: 
110933:     js_delete(debugScopes);
 98921: 
 97463:     /*
 97463:      * Even though all objects in the compartment are dead, we may have keep
 97463:      * some filenames around because of gcKeepAtoms.
 97463:      */
 97463:     FreeScriptFilenames(this);
 97463: 
105944: #ifdef JS_THREADSAFE
113655: # ifdef JS_ION
113643:     js_delete(workerThreadState);
113655: # endif
105944:     sourceCompressorThread.finish();
105944: #endif
105944: 
 34299: #ifdef DEBUG
 34299:     /* Don't hurt everyone in leaky ol' Mozilla with a fatal JS_ASSERT! */
 34299:     if (!JS_CLIST_IS_EMPTY(&contextList)) {
 91237:         unsigned cxcount = 0;
 91250:         for (ContextIter acx(this); !acx.done(); acx.next()) {
 34299:             fprintf(stderr,
 34299: "JS API usage error: found live context at %p\n",
 91266:                     (void *) acx.get());
 34299:             cxcount++;
 34299:         }
 34299:         fprintf(stderr,
 34299: "JS API usage error: %u context%s left in runtime upon JS_DestroyRuntime.\n",
 34299:                 cxcount, (cxcount == 1) ? "" : "s");
 34299:     }
 34299: #endif
 34299: 
 72090:     FinishRuntimeNumberState(this);
114199:     FinishAtoms(this);
 34299: 
 88135:     if (dtoaState)
 88135:         js_DestroyDtoaState(dtoaState);
 88135: 
 34299:     js_FinishGC(this);
 34299: #ifdef JS_THREADSAFE
 34299:     if (gcLock)
 88135:         PR_DestroyLock(gcLock);
 34299: #endif
 97464: 
110933:     js_delete(bumpAlloc_);
110933:     js_delete(mathCache_);
 97464: #ifdef JS_METHODJIT
110933:     js_delete(jaegerRuntime_);
 97464: #endif
110933:     js_delete(execAlloc_);  /* Delete after jaegerRuntime_. */
115708: 
115708:     if (ionPcScriptCache)
115708:         js_delete(ionPcScriptCache);
 34299: }
 34299: 
 81562: #ifdef JS_THREADSAFE
 81562: void
 81562: JSRuntime::setOwnerThread()
 81562: {
 88135:     JS_ASSERT(ownerThread_ == (void *)0xc1ea12);  /* "clear" */
 88135:     JS_ASSERT(requestDepth == 0);
110844:     JS_ASSERT(js_NewRuntimeWasCalled);
110844:     JS_ASSERT(JS::TlsRuntime.get() == NULL);
 88135:     ownerThread_ = PR_GetCurrentThread();
110844:     JS::TlsRuntime.set(this);
 89261:     nativeStackBase = GetNativeStackBase();
 89261:     if (nativeStackQuota)
 89261:         JS_SetNativeStackQuota(this, nativeStackQuota);
 81562: }
 81562: 
 81562: void
 81562: JSRuntime::clearOwnerThread()
 81562: {
110844:     assertValidThread();
 88135:     JS_ASSERT(requestDepth == 0);
110844:     JS_ASSERT(js_NewRuntimeWasCalled);
 88135:     ownerThread_ = (void *)0xc1ea12;  /* "clear" */
110844:     JS::TlsRuntime.set(NULL);
 89261:     nativeStackBase = 0;
 89261: #if JS_STACK_GROWTH_DIRECTION > 0
 89261:     nativeStackLimit = UINTPTR_MAX;
 89261: #else
 89261:     nativeStackLimit = 0;
 89261: #endif
 81562: }
 81562: 
110844: JS_FRIEND_API(void)
110844: JSRuntime::abortIfWrongThread() const
110844: {
110844:     if (ownerThread_ != PR_GetCurrentThread())
110844:         MOZ_CRASH();
110844:     if (this != JS::TlsRuntime.get())
110844:         MOZ_CRASH();
110844: }
110844: 
110844: JS_FRIEND_API(void)
110844: JSRuntime::assertValidThread() const
110844: {
110844:     JS_ASSERT(ownerThread_ == PR_GetCurrentThread());
110844:     JS_ASSERT(this == JS::TlsRuntime.get());
 88135: }
 88135: #endif  /* JS_THREADSAFE */
 81562: 
     1: JS_PUBLIC_API(JSRuntime *)
 84755: JS_NewRuntime(uint32_t maxbytes)
     1: {
 73748:     if (!js_NewRuntimeWasCalled) {
     1: #ifdef DEBUG
     1:         /*
     1:          * This code asserts that the numbers associated with the error names
     1:          * in jsmsg.def are monotonically increasing.  It uses values for the
     1:          * error names enumerated in jscntxt.c.  It's not a compile-time check
     1:          * but it's better than nothing.
     1:          */
     1:         int errorNumber = 0;
     1: #define MSG_DEF(name, number, count, exception, format)                       \
     1:     JS_ASSERT(name == errorNumber++);
     1: #include "js.msg"
     1: #undef MSG_DEF
     1: 
     1: #define MSG_DEF(name, number, count, exception, format)                       \
     1:     JS_BEGIN_MACRO                                                            \
 91237:         unsigned numfmtspecs = 0;                                                \
     1:         const char *fmt;                                                      \
     1:         for (fmt = format; *fmt != '\0'; fmt++) {                             \
     1:             if (*fmt == '{' && isdigit(fmt[1]))                               \
     1:                 ++numfmtspecs;                                                \
     1:         }                                                                     \
     1:         JS_ASSERT(count == numfmtspecs);                                      \
     1:     JS_END_MACRO;
     1: #include "js.msg"
     1: #undef MSG_DEF
 73748: #endif /* DEBUG */
     1: 
 89806:         InitMemorySubsystem();
 89806: 
110844:         if (!JS::TlsRuntime.init())
110909:             return NULL;
110844: 
  8893:         js_NewRuntimeWasCalled = JS_TRUE;
     1:     }
     1: 
110933:     JSRuntime *rt = js_new<JSRuntime>();
 79507:     if (!rt)
     1:         return NULL;
     1: 
111781: #if defined(JS_METHODJIT) && defined(JS_ION)
111677:     if (!ion::InitializeIon())
111677:         return NULL;
111677: #endif
111677: 
 34299:     if (!rt->init(maxbytes)) {
     1:         JS_DestroyRuntime(rt);
     1:         return NULL;
     1:     }
     1: 
 74651:     Probes::createRuntime(rt);
 34299:     return rt;
 34299: }
 34299: 
     1: JS_PUBLIC_API(void)
     1: JS_DestroyRuntime(JSRuntime *rt)
     1: {
 74651:     Probes::destroyRuntime(rt);
110933:     js_delete(rt);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ShutDown(void)
     1: {
 74651:     Probes::shutdown();
  3531:     PRMJ_NowShutdown();
     1: }
     1: 
     1: JS_PUBLIC_API(void *)
     1: JS_GetRuntimePrivate(JSRuntime *rt)
     1: {
     1:     return rt->data;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_SetRuntimePrivate(JSRuntime *rt, void *data)
     1: {
     1:     rt->data = data;
     1: }
     1: 
 11277: #ifdef JS_THREADSAFE
 53548: static void
 53548: StartRequest(JSContext *cx)
 53548: {
 88135:     JSRuntime *rt = cx->runtime;
110844:     rt->assertValidThread();
 88135: 
 88135:     if (rt->requestDepth) {
 88135:         rt->requestDepth++;
 88128:     } else {
     1:         /* Indicate that a request is running. */
 88135:         rt->requestDepth = 1;
 50462: 
 88567:         if (rt->activityCallback)
 50462:             rt->activityCallback(rt->activityCallbackArg, true);
 48481:     }
 53548: }
 53548: 
 47439: static void
 47439: StopRequest(JSContext *cx)
 47439: {
 88135:     JSRuntime *rt = cx->runtime;
110844:     rt->assertValidThread();
 88135:     JS_ASSERT(rt->requestDepth != 0);
 88135:     if (rt->requestDepth != 1) {
 88135:         rt->requestDepth--;
 88128:     } else {
114314:         rt->conservativeGC.updateForRequestEnd();
 88135:         rt->requestDepth = 0;
  3624: 
 50463:         if (rt->activityCallback)
 50462:             rt->activityCallback(rt->activityCallbackArg, false);
 50462:     }
 48481: }
 53548: #endif /* JS_THREADSAFE */
 53548: 
 53548: JS_PUBLIC_API(void)
 53548: JS_BeginRequest(JSContext *cx)
 53548: {
 53548: #ifdef JS_THREADSAFE
 53548:     cx->outstandingRequests++;
 53548:     StartRequest(cx);
 47439: #endif
 53548: }
 47439: 
 47439: JS_PUBLIC_API(void)
 47439: JS_EndRequest(JSContext *cx)
 47439: {
 47439: #ifdef JS_THREADSAFE
 53548:     JS_ASSERT(cx->outstandingRequests != 0);
 53548:     cx->outstandingRequests--;
 47439:     StopRequest(cx);
 11277: #endif
     1: }
     1: 
 58977: JS_PUBLIC_API(JSBool)
 88135: JS_IsInRequest(JSRuntime *rt)
 58977: {
 58977: #ifdef JS_THREADSAFE
110844:     rt->assertValidThread();
 88135:     return rt->requestDepth != 0;
 88135: #else
 88135:     return false;
 88135: #endif
 88135: }
 88135: 
     1: JS_PUBLIC_API(JSContextCallback)
     1: JS_SetContextCallback(JSRuntime *rt, JSContextCallback cxCallback)
     1: {
     1:     JSContextCallback old;
     1: 
     1:     old = rt->cxCallback;
     1:     rt->cxCallback = cxCallback;
     1:     return old;
     1: }
     1: 
     1: JS_PUBLIC_API(JSContext *)
     1: JS_NewContext(JSRuntime *rt, size_t stackChunkSize)
     1: {
 94960:     return NewContext(rt, stackChunkSize);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_DestroyContext(JSContext *cx)
     1: {
 94960:     DestroyContext(cx, DCM_FORCE_GC);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_DestroyContextNoGC(JSContext *cx)
     1: {
 94960:     DestroyContext(cx, DCM_NO_GC);
     1: }
     1: 
     1: JS_PUBLIC_API(void *)
     1: JS_GetContextPrivate(JSContext *cx)
     1: {
     1:     return cx->data;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_SetContextPrivate(JSContext *cx, void *data)
     1: {
     1:     cx->data = data;
     1: }
     1: 
 86983: JS_PUBLIC_API(void *)
 86983: JS_GetSecondContextPrivate(JSContext *cx)
 86983: {
 86983:     return cx->data2;
 86983: }
 86983: 
 86983: JS_PUBLIC_API(void)
 86983: JS_SetSecondContextPrivate(JSContext *cx, void *data)
 86983: {
 86983:     cx->data2 = data;
 86983: }
 86983: 
     1: JS_PUBLIC_API(JSRuntime *)
     1: JS_GetRuntime(JSContext *cx)
     1: {
     1:     return cx->runtime;
     1: }
     1: 
     1: JS_PUBLIC_API(JSContext *)
     1: JS_ContextIterator(JSRuntime *rt, JSContext **iterp)
     1: {
 91250:     JSContext *cx = *iterp;
 91250:     JSCList *next = cx ? cx->link.next : rt->contextList.next;
 91250:     cx = (next == &rt->contextList) ? NULL : JSContext::fromLinkField(next);
 91250:     *iterp = cx;
 91250:     return cx;
 83122: }
 83122: 
     1: JS_PUBLIC_API(JSVersion)
     1: JS_GetVersion(JSContext *cx)
     1: {
 53848:     return VersionNumber(cx->findVersion());
 53848: }
 53848: 
     1: JS_PUBLIC_API(JSVersion)
 53848: JS_SetVersion(JSContext *cx, JSVersion newVersion)
 53848: {
 53848:     JS_ASSERT(VersionIsKnown(newVersion));
 53848:     JS_ASSERT(!VersionHasFlags(newVersion));
 53848:     JSVersion newVersionNumber = newVersion;
 53848: 
 61450: #ifdef DEBUG
 91237:     unsigned coptsBefore = cx->getCompileOptions();
 61450: #endif
 53848:     JSVersion oldVersion = cx->findVersion();
 53848:     JSVersion oldVersionNumber = VersionNumber(oldVersion);
 53848:     if (oldVersionNumber == newVersionNumber)
 53848:         return oldVersionNumber; /* No override actually occurs! */
 53628: 
 53628:     /* We no longer support 1.4 or below. */
 53848:     if (newVersionNumber != JSVERSION_DEFAULT && newVersionNumber <= JSVERSION_1_4)
 53848:         return oldVersionNumber;
 53848: 
 61450:     VersionCopyFlags(&newVersion, oldVersion);
 53848:     cx->maybeOverrideVersion(newVersion);
 61450:     JS_ASSERT(cx->getCompileOptions() == coptsBefore);
 53848:     return oldVersionNumber;
     1: }
     1: 
     1: static struct v2smap {
     1:     JSVersion   version;
     1:     const char  *string;
     1: } v2smap[] = {
     1:     {JSVERSION_1_0,     "1.0"},
     1:     {JSVERSION_1_1,     "1.1"},
     1:     {JSVERSION_1_2,     "1.2"},
     1:     {JSVERSION_1_3,     "1.3"},
     1:     {JSVERSION_1_4,     "1.4"},
     1:     {JSVERSION_ECMA_3,  "ECMAv3"},
     1:     {JSVERSION_1_5,     "1.5"},
     1:     {JSVERSION_1_6,     "1.6"},
     1:     {JSVERSION_1_7,     "1.7"},
  1981:     {JSVERSION_1_8,     "1.8"},
 34362:     {JSVERSION_ECMA_5,  "ECMAv5"},
     1:     {JSVERSION_DEFAULT, js_default_str},
     1:     {JSVERSION_UNKNOWN, NULL},          /* must be last, NULL is sentinel */
     1: };
     1: 
     1: JS_PUBLIC_API(const char *)
     1: JS_VersionToString(JSVersion version)
     1: {
     1:     int i;
     1: 
     1:     for (i = 0; v2smap[i].string; i++)
     1:         if (v2smap[i].version == version)
     1:             return v2smap[i].string;
     1:     return "unknown";
     1: }
     1: 
     1: JS_PUBLIC_API(JSVersion)
     1: JS_StringToVersion(const char *string)
     1: {
     1:     int i;
     1: 
     1:     for (i = 0; v2smap[i].string; i++)
     1:         if (strcmp(v2smap[i].string, string) == 0)
     1:             return v2smap[i].version;
     1:     return JSVERSION_UNKNOWN;
     1: }
     1: 
 84755: JS_PUBLIC_API(uint32_t)
     1: JS_GetOptions(JSContext *cx)
     1: {
 53848:     /*
 53848:      * Can't check option/version synchronization here.
 53848:      * We may have been synchronized with a script version that was formerly on
 53848:      * the stack, but has now been popped.
 53848:      */
 61450:     return cx->allOptions();
 61450: }
 61450: 
 91237: static unsigned
 91237: SetOptionsCommon(JSContext *cx, unsigned options)
 61450: {
 61450:     JS_ASSERT((options & JSALLOPTION_MASK) == options);
 91237:     unsigned oldopts = cx->allOptions();
 91237:     unsigned newropts = options & JSRUNOPTION_MASK;
 91237:     unsigned newcopts = options & JSCOMPILEOPTION_MASK;
 61450:     cx->setRunOptions(newropts);
 61450:     cx->setCompileOptions(newcopts);
 61450:     cx->updateJITEnabled();
 61450:     return oldopts;
     1: }
     1: 
 84755: JS_PUBLIC_API(uint32_t)
 84755: JS_SetOptions(JSContext *cx, uint32_t options)
     1: {
 61450:     return SetOptionsCommon(cx, options);
     1: }
     1: 
 84755: JS_PUBLIC_API(uint32_t)
 84755: JS_ToggleOptions(JSContext *cx, uint32_t options)
     1: {
 91237:     unsigned oldopts = cx->allOptions();
 91237:     unsigned newopts = oldopts ^ options;
 61450:     return SetOptionsCommon(cx, newopts);
     1: }
     1: 
 90106: JS_PUBLIC_API(void)
 90106: JS_SetJitHardening(JSRuntime *rt, JSBool enabled)
 90106: {
 90106:     rt->setJitHardening(!!enabled);
 90106: }
 90106: 
     1: JS_PUBLIC_API(const char *)
     1: JS_GetImplementationVersion(void)
     1: {
 68908:     return "JavaScript-C 1.8.5+ 2011-04-16";
     1: }
     1: 
 94740: JS_PUBLIC_API(void)
 94740: JS_SetDestroyCompartmentCallback(JSRuntime *rt, JSDestroyCompartmentCallback callback)
 94740: {
 94740:     rt->destroyCompartmentCallback = callback;
 48503: }
 48503: 
106510: JS_PUBLIC_API(void)
106510: JS_SetCompartmentNameCallback(JSRuntime *rt, JSCompartmentNameCallback callback)
106510: {
106510:     rt->compartmentNameCallback = callback;
106510: }
106510: 
 47516: JS_PUBLIC_API(JSWrapObjectCallback)
 55628: JS_SetWrapObjectCallbacks(JSRuntime *rt,
 55628:                           JSWrapObjectCallback callback,
 98430:                           JSSameCompartmentWrapObjectCallback sccallback,
 55628:                           JSPreWrapCallback precallback)
 55574: {
 47516:     JSWrapObjectCallback old = rt->wrapObjectCallback;
 47516:     rt->wrapObjectCallback = callback;
 98430:     rt->sameCompartmentWrapObjectCallback = sccallback;
 55628:     rt->preWrapObjectCallback = precallback;
 47516:     return old;
 47516: }
 47516: 
110499: JS_PUBLIC_API(JSCompartment *)
110499: JS_EnterCompartment(JSContext *cx, JSRawObject target)
110499: {
110499:     AssertHeapIsIdle(cx);
110499:     CHECK_REQUEST(cx);
110499: 
110499:     JSCompartment *oldCompartment = cx->compartment;
109256:     cx->enterCompartment(target->compartment());
110499:     return oldCompartment;
110499: }
110499: 
110499: JS_PUBLIC_API(JSCompartment *)
110499: JS_EnterCompartmentOfScript(JSContext *cx, JSScript *target)
 74466: {
103783:     AssertHeapIsIdle(cx);
 59883:     CHECK_REQUEST(cx);
109256:     GlobalObject &global = target->global();
110499:     return JS_EnterCompartment(cx, &global);
 74466: }
 74466: 
 47498: JS_PUBLIC_API(void)
110499: JS_LeaveCompartment(JSContext *cx, JSCompartment *oldCompartment)
110499: {
110499:     AssertHeapIsIdle(cx);
110499:     CHECK_REQUEST(cx);
110499:     cx->leaveCompartment(oldCompartment);
 47498: }
 47498: 
109257: JSAutoCompartment::JSAutoCompartment(JSContext *cx, JSRawObject target)
109257:   : cx_(cx),
109257:     oldCompartment_(cx->compartment)
109257: {
109257:     AssertHeapIsIdleOrIterating(cx_);
109257:     cx_->enterCompartment(target->compartment());
109257: }
109257: 
110499: JSAutoCompartment::JSAutoCompartment(JSContext *cx, JSScript *target)
110499:   : cx_(cx),
110499:     oldCompartment_(cx->compartment)
110499: {
110499:     AssertHeapIsIdleOrIterating(cx_);
110499:     cx_->enterCompartment(target->compartment());
110499: }
110499: 
110499: JSAutoCompartment::JSAutoCompartment(JSContext *cx, JSStackFrame *target)
110499:   : cx_(cx),
110499:     oldCompartment_(cx->compartment)
110499: {
110499:     AssertHeapIsIdleOrIterating(cx_);
110499:     cx_->enterCompartment(Valueify(target)->global().compartment());
110499: }
110499: 
109257: JSAutoCompartment::~JSAutoCompartment()
109257: {
109256:     cx_->leaveCompartment(oldCompartment_);
109256: }
 64190: 
 91250: JS_PUBLIC_API(void)
 91250: JS_SetCompartmentPrivate(JSCompartment *compartment, void *data)
 91250: {
 91250:     compartment->data = data;
 91250: }
 91250: 
 48503: JS_PUBLIC_API(void *)
 91250: JS_GetCompartmentPrivate(JSCompartment *compartment)
 91250: {
 91250:     return compartment->data;
 48503: }
 48503: 
 51450: JS_PUBLIC_API(JSBool)
 51450: JS_WrapObject(JSContext *cx, JSObject **objp)
 51450: {
103783:     AssertHeapIsIdle(cx);
 51450:     CHECK_REQUEST(cx);
 51450:     return cx->compartment->wrap(cx, objp);
 51450: }
 51450: 
 51450: JS_PUBLIC_API(JSBool)
 51450: JS_WrapValue(JSContext *cx, jsval *vp)
 51450: {
103783:     AssertHeapIsIdle(cx);
 51450:     CHECK_REQUEST(cx);
 78614:     return cx->compartment->wrap(cx, vp);
 51450: }
 51450: 
 98380: /*
 98380:  * Identity remapping. Not for casual consumers.
 98380:  *
 98380:  * Normally, an object's contents and its identity are inextricably linked.
 98380:  * Identity is determined by the address of the JSObject* in the heap, and
 98380:  * the contents are what is located at that address. Transplanting allows these
 98380:  * concepts to be separated through a combination of swapping (exchanging the
 98380:  * contents of two same-compartment objects) and remapping cross-compartment
 98380:  * identities by altering wrappers.
 98380:  *
 98380:  * The |origobj| argument should be the object whose identity needs to be
 98380:  * remapped, usually to another compartment. The contents of |origobj| are
 98380:  * destroyed.
 98380:  *
 98380:  * The |target| argument serves two purposes:
 98380:  *
 98380:  * First, |target| serves as a hint for the new identity of the object. The new
 98380:  * identity object will always be in the same compartment as |target|, but
 98380:  * if that compartment already had an object representing |origobj| (either a
 98380:  * cross-compartment wrapper for it, or |origobj| itself if the two arguments
 98380:  * are same-compartment), the existing object is used. Otherwise, |target|
 98380:  * itself is used. To avoid ambiguity, JS_TransplantObject always returns the
 98380:  * new identity.
 98380:  *
 98380:  * Second, the new identity object's contents will be those of |target|. A swap()
 98380:  * is used to make this happen if an object other than |target| is used.
116134:  *
116134:  * We don't have a good way to recover from failure in this function, so
116134:  * we intentionally crash instead.
 98380:  */
 98380: 
     1: JS_PUBLIC_API(JSObject *)
107154: JS_TransplantObject(JSContext *cx, JSObject *origobjArg, JSObject *targetArg)
107154: {
107154:     RootedObject origobj(cx, origobjArg);
107154:     RootedObject target(cx, targetArg);
103783:     AssertHeapIsIdle(cx);
 98380:     JS_ASSERT(origobj != target);
 99134:     JS_ASSERT(!IsCrossCompartmentWrapper(origobj));
 99134:     JS_ASSERT(!IsCrossCompartmentWrapper(target));
 98380: 
104658:     /*
104658:      * Transplantation typically allocates new wrappers in every compartment. If
104658:      * an incremental GC is active, this causes every compartment to be leaked
104658:      * for that GC. Hence, we finish any ongoing incremental GC before the
104658:      * transplant to avoid leaks.
104658:      */
114957:     if (IsIncrementalGCInProgress(cx->runtime)) {
105857:         PrepareForIncrementalGC(cx->runtime);
104658:         FinishIncrementalGC(cx->runtime, gcreason::TRANSPLANT);
105857:     }
104658: 
 79734:     JSCompartment *destination = target->compartment();
 62643:     WrapperMap &map = destination->crossCompartmentWrappers;
 62643:     Value origv = ObjectValue(*origobj);
 98381:     JSObject *newIdentity;
 62643: 
 79734:     if (origobj->compartment() == destination) {
 58534:         // If the original object is in the same compartment as the
 99134:         // destination, then we know that we won't find a wrapper in the
 62643:         // destination's cross compartment map and that the same
 98380:         // object will continue to work.
 98380:         if (!origobj->swap(cx, target))
116134:             MOZ_CRASH();
 98381:         newIdentity = origobj;
 62643:     } else if (WrapperMap::Ptr p = map.lookup(origv)) {
 62643:         // There might already be a wrapper for the original object in
 98380:         // the new compartment. If there is, we use its identity and swap
 98380:         // in the contents of |target|.
 98381:         newIdentity = &p->value.toObject();
 99134: 
 99134:         // When we remove origv from the wrapper map, its wrapper, newIdentity,
 99134:         // must immediately cease to be a cross-compartment wrapper. Neuter it.
 55574:         map.remove(p);
115024:         NukeCrossCompartmentWrapper(cx, newIdentity);
 99134: 
 98381:         if (!newIdentity->swap(cx, target))
116134:             MOZ_CRASH();
 55574:     } else {
 98380:         // Otherwise, we use |target| for the new identity object.
 98381:         newIdentity = target;
 98381:     }
 55574: 
 62643:     // Now, iterate through other scopes looking for references to the
 98380:     // old object, and update the relevant cross-compartment wrappers.
103588:     if (!RemapAllWrappersForObject(cx, origobj, newIdentity))
116134:         MOZ_CRASH();
 55751: 
 58534:     // Lastly, update the original object to point to the new one.
 79734:     if (origobj->compartment() != destination) {
109257:         RootedObject newIdentityWrapper(cx, newIdentity);
 58534:         AutoCompartment ac(cx, origobj);
109257:         if (!JS_WrapObject(cx, newIdentityWrapper.address()))
116134:             MOZ_CRASH();
 98381:         if (!origobj->swap(cx, newIdentityWrapper))
116134:             MOZ_CRASH();
 99134:         origobj->compartment()->crossCompartmentWrappers.put(ObjectValue(*newIdentity), origv);
 55574:     }
 55574: 
 98380:     // The new identity object might be one of several things. Return it to avoid
 98380:     // ambiguity.
 98381:     return newIdentity;
 55574: }
 55574: 
 62975: /*
107434:  * Some C++ objects (such as the location object and XBL) require both an XPConnect
107434:  * reflector and a security wrapper for that reflector. We expect that there are
107434:  * no live references to the reflector, so when we perform the transplant we turn
107434:  * the security wrapper into a cross-compartment wrapper. Just in case there
107434:  * happen to be live references to the reflector, we swap it out to limit the harm.
 62975:  */
 62975: JS_FRIEND_API(JSObject *)
 62975: js_TransplantObjectWithWrapper(JSContext *cx,
107154:                                JSObject *origobjArg,
107154:                                JSObject *origwrapperArg,
107154:                                JSObject *targetobjArg,
107154:                                JSObject *targetwrapperArg)
107154: {
107154:     RootedObject origobj(cx, origobjArg);
107154:     RootedObject origwrapper(cx, origwrapperArg);
107154:     RootedObject targetobj(cx, targetobjArg);
107154:     RootedObject targetwrapper(cx, targetwrapperArg);
107154: 
103783:     AssertHeapIsIdle(cx);
 99134:     JS_ASSERT(!IsCrossCompartmentWrapper(origobj));
 99134:     JS_ASSERT(!IsCrossCompartmentWrapper(origwrapper));
 99245:     JS_ASSERT(!IsCrossCompartmentWrapper(targetobj));
 99245:     JS_ASSERT(!IsCrossCompartmentWrapper(targetwrapper));
 86458: 
 98383:     JSObject *newWrapper;
 79734:     JSCompartment *destination = targetobj->compartment();
 62975:     WrapperMap &map = destination->crossCompartmentWrappers;
 62975: 
 62975:     // |origv| is the map entry we're looking up. The map entries are going to
 98383:     // be for |origobj|, not |origwrapper|.
 62975:     Value origv = ObjectValue(*origobj);
 62975: 
 62975:     // There might already be a wrapper for the original object in the new
 62975:     // compartment.
 62975:     if (WrapperMap::Ptr p = map.lookup(origv)) {
 98383:         // There is. Make the existing cross-compartment wrapper a same-
 98383:         // compartment wrapper.
 98383:         newWrapper = &p->value.toObject();
 99134: 
 99134:         // When we remove origv from the wrapper map, its wrapper, newWrapper,
 99134:         // must immediately cease to be a cross-compartment wrapper. Neuter it.
 62975:         map.remove(p);
115024:         NukeCrossCompartmentWrapper(cx, newWrapper);
 99134: 
 98383:         if (!newWrapper->swap(cx, targetwrapper))
116134:             MOZ_CRASH();
 62975:     } else {
 98383:         // Otherwise, use the passed-in wrapper as the same-compartment wrapper.
 98383:         newWrapper = targetwrapper;
 62975:     }
 62975: 
 62975:     // Now, iterate through other scopes looking for references to the old
 98383:     // object. Note that the entries in the maps are for |origobj| and not
 98383:     // |origwrapper|. They need to be updated to point at the new object.
103588:     if (!RemapAllWrappersForObject(cx, origobj, targetobj))
116134:         MOZ_CRASH();
 62975: 
 98383:     // Lastly, update things in the original compartment. Our invariants dictate
 98383:     // that the original compartment can only have one cross-compartment wrapper
 98383:     // to the new object. So we choose to update |origwrapper|, not |origobj|,
107434:     // since there are probably no live direct intra-compartment references to
107434:     // |origobj|.
 62975:     {
 62975:         AutoCompartment ac(cx, origobj);
107434: 
107434:         // We can't be sure that the reflector is completely dead. This is bad,
107434:         // because it is in a weird state. To minimize potential harm we create
107434:         // a new unreachable dummy object and swap it with the reflector.
107434:         // After the swap we have a possibly-live object that isn't dangerous,
107434:         // and a possibly-dangerous object that isn't live.
107434:         RootedObject reflectorGuts(cx, NewDeadProxyObject(cx, JS_GetGlobalForObject(cx, origobj)));
107434:         if (!reflectorGuts || !origobj->swap(cx, reflectorGuts))
116134:             MOZ_CRASH();
107434: 
107434:         // Turn origwrapper into a CCW to the new object.
107154:         RootedObject wrapperGuts(cx, targetobj);
107434:         if (!JS_WrapObject(cx, wrapperGuts.address()))
116134:             MOZ_CRASH();
 98384:         if (!origwrapper->swap(cx, wrapperGuts))
116134:             MOZ_CRASH();
 98382:         origwrapper->compartment()->crossCompartmentWrappers.put(ObjectValue(*targetobj),
 62975:                                                                  ObjectValue(*origwrapper));
 62975:     }
 62975: 
 98383:     return newWrapper;
 62975: }
 62975: 
 98380: /*
 98380:  * Recompute all cross-compartment wrappers for an object, resetting state.
 98380:  * Gecko uses this to clear Xray wrappers when doing a navigation that reuses
 98380:  * the inner window and global object.
 98380:  */
 98380: JS_PUBLIC_API(JSBool)
107154: JS_RefreshCrossCompartmentWrappers(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
103588:     return RemapAllWrappersForObject(cx, obj, obj);
 98380: }
 98380: 
 55574: JS_PUBLIC_API(JSObject *)
     1: JS_GetGlobalObject(JSContext *cx)
     1: {
109255:     return cx->maybeDefaultCompartmentObject();
     1: }
     1: 
     1: JS_PUBLIC_API(void)
107154: JS_SetGlobalObject(JSContext *cx, JSRawObject obj)
     1: {
103783:     AssertHeapIsIdle(cx);
 35586:     CHECK_REQUEST(cx);
 47517: 
109255:     cx->setDefaultCompartmentObject(obj);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_InitStandardClasses(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
     1: 
109255:     cx->setDefaultCompartmentObjectIfUnset(obj);
 47485:     assertSameCompartment(cx, obj);
 43290: 
102586:     Rooted<GlobalObject*> global(cx, &obj->global());
102586:     return GlobalObject::initStandardClasses(cx, global);
     1: }
     1: 
 77817: #define CLASP(name)                 (&name##Class)
 97573: #define TYPED_ARRAY_CLASP(type)     (&TypedArray::classes[TypedArray::type])
 97886: #define EAGER_ATOM(name)            NAME_OFFSET(name)
114199: #define EAGER_CLASS_ATOM(name)      NAME_OFFSET(name)
     1: #define EAGER_ATOM_AND_CLASP(name)  EAGER_CLASS_ATOM(name), CLASP(name)
     1: 
     1: typedef struct JSStdName {
 98960:     JSClassInitializerOp init;
     1:     size_t      atomOffset;     /* offset of atom pointer in JSAtomState */
 48470:     Class       *clasp;
     1: } JSStdName;
     1: 
114207: static Handle<PropertyName*>
 97828: StdNameToPropertyName(JSContext *cx, JSStdName *stdn)
     1: {
 97886:     return OFFSET_TO_NAME(cx->runtime, stdn->atomOffset);
     1: }
     1: 
     1: /*
     1:  * Table of class initializers and their atom offsets in rt->atomState.
     1:  * If you add a "standard" class, remember to update this table.
     1:  */
     1: static JSStdName standard_class_atoms[] = {
 78468:     {js_InitFunctionClass,              EAGER_ATOM_AND_CLASP(Function)},
 78468:     {js_InitObjectClass,                EAGER_ATOM_AND_CLASP(Object)},
     1:     {js_InitArrayClass,                 EAGER_ATOM_AND_CLASP(Array)},
     1:     {js_InitBooleanClass,               EAGER_ATOM_AND_CLASP(Boolean)},
     1:     {js_InitDateClass,                  EAGER_ATOM_AND_CLASP(Date)},
     1:     {js_InitMathClass,                  EAGER_ATOM_AND_CLASP(Math)},
     1:     {js_InitNumberClass,                EAGER_ATOM_AND_CLASP(Number)},
     1:     {js_InitStringClass,                EAGER_ATOM_AND_CLASP(String)},
     1:     {js_InitExceptionClasses,           EAGER_ATOM_AND_CLASP(Error)},
     1:     {js_InitRegExpClass,                EAGER_ATOM_AND_CLASP(RegExp)},
     1: #if JS_HAS_XML_SUPPORT
     1:     {js_InitXMLClass,                   EAGER_ATOM_AND_CLASP(XML)},
 48622:     {js_InitNamespaceClass,             EAGER_ATOM_AND_CLASP(Namespace)},
 48622:     {js_InitQNameClass,                 EAGER_ATOM_AND_CLASP(QName)},
     1: #endif
     1: #if JS_HAS_GENERATORS
     1:     {js_InitIteratorClasses,            EAGER_ATOM_AND_CLASP(StopIteration)},
     1: #endif
 20092:     {js_InitJSONClass,                  EAGER_ATOM_AND_CLASP(JSON)},
 96828:     {js_InitTypedArrayClasses,          EAGER_CLASS_ATOM(ArrayBuffer), &js::ArrayBufferObject::protoClass},
 72067:     {js_InitWeakMapClass,               EAGER_CLASS_ATOM(WeakMap), &js::WeakMapClass},
 87812:     {js_InitMapClass,                   EAGER_CLASS_ATOM(Map), &js::MapObject::class_},
 87812:     {js_InitSetClass,                   EAGER_CLASS_ATOM(Set), &js::SetObject::class_},
108659:     {js_InitParallelArrayClass,         EAGER_CLASS_ATOM(ParallelArray), &js::ParallelArrayObject::class_},
 97886:     {NULL,                              0, NULL}
     1: };
     1: 
     1: /*
     1:  * Table of top-level function and constant names and their init functions.
     1:  * If you add a "standard" global function or property, remember to update
     1:  * this table.
     1:  */
     1: static JSStdName standard_class_names[] = {
 43236:     {js_InitObjectClass,        EAGER_ATOM(eval), CLASP(Object)},
     1: 
     1:     /* Global properties and functions defined by the Number class. */
 57823:     {js_InitNumberClass,        EAGER_ATOM(NaN), CLASP(Number)},
 57823:     {js_InitNumberClass,        EAGER_ATOM(Infinity), CLASP(Number)},
 97886:     {js_InitNumberClass,        EAGER_ATOM(isNaN), CLASP(Number)},
 97886:     {js_InitNumberClass,        EAGER_ATOM(isFinite), CLASP(Number)},
 97886:     {js_InitNumberClass,        EAGER_ATOM(parseFloat), CLASP(Number)},
 97886:     {js_InitNumberClass,        EAGER_ATOM(parseInt), CLASP(Number)},
     1: 
     1:     /* String global functions. */
 97886:     {js_InitStringClass,        EAGER_ATOM(escape), CLASP(String)},
 97886:     {js_InitStringClass,        EAGER_ATOM(unescape), CLASP(String)},
 97886:     {js_InitStringClass,        EAGER_ATOM(decodeURI), CLASP(String)},
 97886:     {js_InitStringClass,        EAGER_ATOM(encodeURI), CLASP(String)},
 97886:     {js_InitStringClass,        EAGER_ATOM(decodeURIComponent), CLASP(String)},
 97886:     {js_InitStringClass,        EAGER_ATOM(encodeURIComponent), CLASP(String)},
     1: #if JS_HAS_UNEVAL
 97886:     {js_InitStringClass,        EAGER_ATOM(uneval), CLASP(String)},
     1: #endif
     1: 
     1:     /* Exception constructors. */
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(Error), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(InternalError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(EvalError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(RangeError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(ReferenceError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(SyntaxError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(TypeError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(URIError), CLASP(Error)},
     1: 
     1: #if JS_HAS_XML_SUPPORT
 97886:     {js_InitXMLClass,           EAGER_ATOM(XMLList), CLASP(XML)},
 97886:     {js_InitXMLClass,           EAGER_ATOM(isXMLName), CLASP(XML)},
     1: #endif
     1: 
105836:     {js_InitIteratorClasses,    EAGER_CLASS_ATOM(Iterator), &PropertyIteratorObject::class_},
     1: 
 37042:     /* Typed Arrays */
 77817:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(ArrayBuffer),  &ArrayBufferClass},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Int8Array),    TYPED_ARRAY_CLASP(TYPE_INT8)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint8Array),   TYPED_ARRAY_CLASP(TYPE_UINT8)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Int16Array),   TYPED_ARRAY_CLASP(TYPE_INT16)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint16Array),  TYPED_ARRAY_CLASP(TYPE_UINT16)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Int32Array),   TYPED_ARRAY_CLASP(TYPE_INT32)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint32Array),  TYPED_ARRAY_CLASP(TYPE_UINT32)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Float32Array), TYPED_ARRAY_CLASP(TYPE_FLOAT32)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Float64Array), TYPED_ARRAY_CLASP(TYPE_FLOAT64)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint8ClampedArray),
 48622:                                 TYPED_ARRAY_CLASP(TYPE_UINT8_CLAMPED)},
 97574:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(DataView),     &DataViewClass},
 43236: 
 87674:     {js_InitWeakMapClass,       EAGER_ATOM_AND_CLASP(WeakMap)},
 43236:     {js_InitProxyClass,         EAGER_ATOM_AND_CLASP(Proxy)},
 42733: 
 97886:     {NULL,                      0, NULL}
     1: };
     1: 
     1: static JSStdName object_prototype_names[] = {
     1:     /* Object.prototype properties (global delegates to Object.prototype). */
 43236:     {js_InitObjectClass,        EAGER_ATOM(proto), CLASP(Object)},
     1: #if JS_HAS_TOSOURCE
 43236:     {js_InitObjectClass,        EAGER_ATOM(toSource), CLASP(Object)},
     1: #endif
 43236:     {js_InitObjectClass,        EAGER_ATOM(toString), CLASP(Object)},
 43236:     {js_InitObjectClass,        EAGER_ATOM(toLocaleString), CLASP(Object)},
 43236:     {js_InitObjectClass,        EAGER_ATOM(valueOf), CLASP(Object)},
     1: #if JS_HAS_OBJ_WATCHPOINT
 97886:     {js_InitObjectClass,        EAGER_ATOM(watch), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(unwatch), CLASP(Object)},
     1: #endif
 97886:     {js_InitObjectClass,        EAGER_ATOM(hasOwnProperty), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(isPrototypeOf), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(propertyIsEnumerable), CLASP(Object)},
 40855: #if OLD_GETTER_SETTER_METHODS
 97886:     {js_InitObjectClass,        EAGER_ATOM(defineGetter), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(defineSetter), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(lookupGetter), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(lookupSetter), CLASP(Object)},
     1: #endif
     1: 
 97886:     {NULL,                      0, NULL}
     1: };
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_ResolveStandardClass(JSContext *cx, JSObject *objArg, jsid id, JSBool *resolved)
107154: {
107154:     RootedObject obj(cx, objArg);
     1:     JSString *idstr;
     1:     JSRuntime *rt;
     1:     JSAtom *atom;
     1:     JSStdName *stdnm;
 91237:     unsigned i;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 99822:     *resolved = false;
     1: 
  4556:     rt = cx->runtime;
 87611:     if (!rt->hasContexts() || !JSID_IS_ATOM(id))
 99822:         return true;
  4556: 
 48470:     idstr = JSID_TO_STRING(id);
     1: 
     1:     /* Check whether we're resolving 'undefined', and define it if so. */
114207:     atom = rt->atomState.undefined;
 64345:     if (idstr == atom) {
 99822:         *resolved = true;
107154:         RootedValue undefinedValue(cx, UndefinedValue());
108951:         return JSObject::defineProperty(cx, obj, atom->asPropertyName(), undefinedValue,
 78614:                                         JS_PropertyStub, JS_StrictPropertyStub,
 37031:                                         JSPROP_PERMANENT | JSPROP_READONLY);
     1:     }
     1: 
     1:     /* Try for class constructors/prototypes named by well-known atoms. */
     1:     stdnm = NULL;
     1:     for (i = 0; standard_class_atoms[i].init; i++) {
 43236:         JS_ASSERT(standard_class_atoms[i].clasp);
 97828:         atom = OFFSET_TO_NAME(rt, standard_class_atoms[i].atomOffset);
 64345:         if (idstr == atom) {
     1:             stdnm = &standard_class_atoms[i];
     1:             break;
     1:         }
     1:     }
     1: 
     1:     if (!stdnm) {
     1:         /* Try less frequently used top-level functions and constants. */
     1:         for (i = 0; standard_class_names[i].init; i++) {
 43236:             JS_ASSERT(standard_class_names[i].clasp);
 97828:             atom = StdNameToPropertyName(cx, &standard_class_names[i]);
     1:             if (!atom)
 99822:                 return false;
 64345:             if (idstr == atom) {
     1:                 stdnm = &standard_class_names[i];
     1:                 break;
     1:             }
     1:         }
     1: 
115021:         RootedObject proto(cx);
115021:         if (!JSObject::getProto(cx, obj, &proto))
115021:             return false;
115021:         if (!stdnm && !proto) {
     1:             /*
     1:              * Try even less frequently used names delegated from the global
     1:              * object to Object.prototype, but only if the Object class hasn't
     1:              * yet been initialized.
     1:              */
     1:             for (i = 0; object_prototype_names[i].init; i++) {
 43236:                 JS_ASSERT(object_prototype_names[i].clasp);
 97828:                 atom = StdNameToPropertyName(cx, &object_prototype_names[i]);
     1:                 if (!atom)
 99822:                     return false;
 64345:                 if (idstr == atom) {
 41243:                     stdnm = &object_prototype_names[i];
     1:                     break;
     1:                 }
     1:             }
     1:         }
     1:     }
     1: 
     1:     if (stdnm) {
     1:         /*
 43236:          * If this standard class is anonymous, then we don't want to resolve
 43236:          * by name.
     1:          */
 60566:         JS_ASSERT(obj->isGlobal());
 43236:         if (stdnm->clasp->flags & JSCLASS_IS_ANONYMOUS)
 99822:             return true;
 43236: 
 69232:         if (IsStandardClassResolved(obj, stdnm->clasp))
 99822:             return true;
 99822: 
 99822: #if JS_HAS_XML_SUPPORT
 99822:         if ((stdnm->init == js_InitXMLClass ||
 99822:              stdnm->init == js_InitNamespaceClass ||
 99822:              stdnm->init == js_InitQNameClass) &&
 99822:             !VersionHasAllowXML(cx->findVersion()))
 99822:         {
 99822:             return true;
 99822:         }
 99822: #endif
     1: 
     1:         if (!stdnm->init(cx, obj))
 99822:             return false;
 99822:         *resolved = true;
 99822:     }
 99822:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_EnumerateStandardClasses(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     AssertHeapIsIdle(cx);
107154:     CHECK_REQUEST(cx);
107154:     assertSameCompartment(cx, obj);
 97353: 
 69232:     /*
 69232:      * Check whether we need to bind 'undefined' and define it if so.
 69232:      * Since ES5 15.1.1.3 undefined can't be deleted.
 69232:      */
114207:     HandlePropertyName undefinedName = cx->names().undefined;
106862:     RootedValue undefinedValue(cx, UndefinedValue());
111073:     if (!obj->nativeContains(cx, undefinedName) &&
108951:         !JSObject::defineProperty(cx, obj, undefinedName, undefinedValue,
 78614:                                   JS_PropertyStub, JS_StrictPropertyStub,
 39915:                                   JSPROP_PERMANENT | JSPROP_READONLY)) {
 99822:         return false;
     1:     }
     1: 
 69232:     /* Initialize any classes that have not been initialized yet. */
 99822:     for (unsigned i = 0; standard_class_atoms[i].init; i++) {
 99822:         const JSStdName &stdnm = standard_class_atoms[i];
 99945:         if (!js::IsStandardClassResolved(obj, stdnm.clasp)
 99822: #if JS_HAS_XML_SUPPORT
 99945:             && ((stdnm.init != js_InitXMLClass &&
 99822:                  stdnm.init != js_InitNamespaceClass &&
 99822:                  stdnm.init != js_InitQNameClass) ||
 99822:                 VersionHasAllowXML(cx->findVersion()))
 99822: #endif
 99822:             )
 99822:         {
 99822:             if (!stdnm.init(cx, obj))
 99822:                 return false;
 99822:         }
 99822:     }
 99822: 
 99822:     return true;
     1: }
     1: 
 82129: static JSIdArray *
 91450: NewIdArray(JSContext *cx, int length)
 67898: {
 67898:     JSIdArray *ida;
 67898: 
 67898:     ida = (JSIdArray *)
 67898:         cx->calloc_(offsetof(JSIdArray, vector) + length * sizeof(jsval));
 67898:     if (ida)
 67898:         ida->length = length;
 67898:     return ida;
 67898: }
 67898: 
 67898: /*
 67898:  * Unlike realloc(3), this function frees ida on failure.
 67898:  */
 67898: static JSIdArray *
 91450: SetIdArrayLength(JSContext *cx, JSIdArray *ida, int length)
 67898: {
 67898:     JSIdArray *rida;
 67898: 
 67898:     rida = (JSIdArray *)
 67898:            JS_realloc(cx, ida,
 67898:                       offsetof(JSIdArray, vector) + length * sizeof(jsval));
 67898:     if (!rida) {
 67898:         JS_DestroyIdArray(cx, ida);
 67898:     } else {
 67898:         rida->length = length;
 67898:     }
 67898:     return rida;
 67898: }
 67898: 
 67898: static JSIdArray *
 97828: AddNameToArray(JSContext *cx, PropertyName *name, JSIdArray *ida, int *ip)
 91450: {
 91450:     int i = *ip;
 91450:     int length = ida->length;
 67898:     if (i >= length) {
107276:         ida = SetIdArrayLength(cx, ida, Max(length * 2, 8));
 67898:         if (!ida)
 67898:             return NULL;
 67898:         JS_ASSERT(i < ida->length);
 67898:     }
 97828:     ida->vector[i].init(NameToId(name));
 67898:     *ip = i + 1;
 67898:     return ida;
 67898: }
 67898: 
 67898: static JSIdArray *
111073: EnumerateIfResolved(JSContext *cx, Handle<JSObject*> obj, Handle<PropertyName*> name,
111073:                     JSIdArray *ida, int *ip, JSBool *foundp)
111073: {
111073:     *foundp = obj->nativeContains(cx, name);
 67898:     if (*foundp)
 97828:         ida = AddNameToArray(cx, name, ida, ip);
 67898:     return ida;
 67898: }
 67898: 
 67898: JS_PUBLIC_API(JSIdArray *)
107154: JS_EnumerateResolvedStandardClasses(JSContext *cx, JSObject *objArg, JSIdArray *ida)
107154: {
107154:     RootedObject obj(cx, objArg);
 67898:     JSRuntime *rt;
 91450:     int i, j, k;
 67898:     JSBool found;
 98960:     JSClassInitializerOp init;
 67898: 
103783:     AssertHeapIsIdle(cx);
 67898:     CHECK_REQUEST(cx);
 67898:     assertSameCompartment(cx, obj, ida);
 67898:     rt = cx->runtime;
 67898:     if (ida) {
 67898:         i = ida->length;
 67898:     } else {
 67898:         ida = NewIdArray(cx, 8);
 67898:         if (!ida)
 67898:             return NULL;
 67898:         i = 0;
 67898:     }
 67898: 
 67898:     /* Check whether 'undefined' has been resolved and enumerate it if so. */
114207:     ida = EnumerateIfResolved(cx, obj, cx->names().undefined, ida, &i, &found);
 67898:     if (!ida)
 67898:         return NULL;
 67898: 
 67898:     /* Enumerate only classes that *have* been resolved. */
114207:     Rooted<PropertyName*> name(cx);
 67898:     for (j = 0; standard_class_atoms[j].init; j++) {
 97828:         name = OFFSET_TO_NAME(rt, standard_class_atoms[j].atomOffset);
 97828:         ida = EnumerateIfResolved(cx, obj, name, ida, &i, &found);
 67898:         if (!ida)
 67898:             return NULL;
 67898: 
 67898:         if (found) {
 67898:             init = standard_class_atoms[j].init;
 67898: 
 67898:             for (k = 0; standard_class_names[k].init; k++) {
 67898:                 if (standard_class_names[k].init == init) {
 97828:                     name = StdNameToPropertyName(cx, &standard_class_names[k]);
 97828:                     ida = AddNameToArray(cx, name, ida, &i);
 67898:                     if (!ida)
 67898:                         return NULL;
 67898:                 }
 67898:             }
 67898: 
 67898:             if (init == js_InitObjectClass) {
 67898:                 for (k = 0; object_prototype_names[k].init; k++) {
 97828:                     name = StdNameToPropertyName(cx, &object_prototype_names[k]);
 97828:                     ida = AddNameToArray(cx, name, ida, &i);
 67898:                     if (!ida)
 67898:                         return NULL;
 67898:                 }
 67898:             }
 67898:         }
 67898:     }
 67898: 
 67898:     /* Trim to exact length. */
 67898:     return SetIdArrayLength(cx, ida, i);
 67898: }
 67898: 
     1: #undef CLASP
     1: #undef EAGER_ATOM
     1: #undef EAGER_CLASS_ATOM
     1: #undef EAGER_ATOM_CLASP
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_GetClassObject(JSContext *cx, JSRawObject obj, JSProtoKey key, JSObject **objpArg)
107154: {
107154:     RootedObject objp(cx, *objpArg);
107154:     AssertHeapIsIdle(cx);
107154:     CHECK_REQUEST(cx);
107154: 
 47485:     assertSameCompartment(cx, obj);
107154:     if (!js_GetClassObject(cx, obj, key, &objp))
107154:         return false;
107154:     *objpArg = objp;
107154:     return true;
     1: }
     1: 
106721: JS_PUBLIC_API(JSBool)
106721: JS_GetClassPrototype(JSContext *cx, JSProtoKey key, JSObject **objp_)
106721: {
106721:     AssertHeapIsIdle(cx);
106721:     CHECK_REQUEST(cx);
109255: 
106721:     RootedObject objp(cx);
109255:     bool result = js_GetClassPrototype(cx, key, &objp);
106721:     *objp_ = objp;
106721:     return result;
106721: }
106721: 
106721: JS_PUBLIC_API(JSProtoKey)
106721: JS_IdentifyClassPrototype(JSContext *cx, JSObject *obj)
106721: {
106721:     AssertHeapIsIdle(cx);
106721:     CHECK_REQUEST(cx);
106721:     assertSameCompartment(cx, obj);
106721:     JS_ASSERT(!IsCrossCompartmentWrapper(obj));
106721:     return js_IdentifyClassPrototype(obj);
106721: }
106721: 
     1: JS_PUBLIC_API(JSObject *)
107154: JS_GetObjectPrototype(JSContext *cx, JSRawObject forObj)
 89843: {
 89843:     CHECK_REQUEST(cx);
 89843:     assertSameCompartment(cx, forObj);
 89843:     return forObj->global().getOrCreateObjectPrototype(cx);
 89843: }
 89843: 
 89843: JS_PUBLIC_API(JSObject *)
107154: JS_GetFunctionPrototype(JSContext *cx, JSRawObject forObj)
 90619: {
 90619:     CHECK_REQUEST(cx);
 90619:     assertSameCompartment(cx, forObj);
 90619:     return forObj->global().getOrCreateFunctionPrototype(cx);
 90619: }
 90619: 
 90619: JS_PUBLIC_API(JSObject *)
107154: JS_GetGlobalForObject(JSContext *cx, JSRawObject obj)
  4427: {
103783:     AssertHeapIsIdle(cx);
 47485:     assertSameCompartment(cx, obj);
 86483:     return &obj->global();
  4427: }
  4427: 
 42766: JS_PUBLIC_API(JSObject *)
103785: JS_GetGlobalForCompartmentOrNull(JSContext *cx, JSCompartment *c)
103785: {
103785:     AssertHeapIsIdleOrIterating(cx);
103785:     assertSameCompartment(cx, c);
103785:     return c->maybeGlobal();
103785: }
103785: 
103785: JS_PUBLIC_API(JSObject *)
 42766: JS_GetGlobalForScopeChain(JSContext *cx)
 42766: {
108249:     AssertHeapIsIdleOrIterating(cx);
 56729:     CHECK_REQUEST(cx);
109255:     return cx->global();
 42766: }
 42766: 
 11809: JS_PUBLIC_API(jsval)
 11809: JS_ComputeThis(JSContext *cx, jsval *vp)
 11809: {
103783:     AssertHeapIsIdle(cx);
 48470:     assertSameCompartment(cx, JSValueArray(vp, 2));
 78614:     CallReceiver call = CallReceiverFromVp(vp);
 68904:     if (!BoxNonStrictThis(cx, call))
 68904:         return JSVAL_NULL;
 78614:     return call.thisv();
 11809: }
 11809: 
 91825: JS_PUBLIC_API(void)
 91825: JS_MallocInCompartment(JSCompartment *comp, size_t nbytes)
 91825: {
 91825:     comp->mallocInCompartment(nbytes);
 91825: }
 91825: 
 91825: JS_PUBLIC_API(void)
 91825: JS_FreeInCompartment(JSCompartment *comp, size_t nbytes)
 91825: {
 91825:     comp->freeInCompartment(nbytes);
 91825: }
 91825: 
     1: JS_PUBLIC_API(void *)
     1: JS_malloc(JSContext *cx, size_t nbytes)
     1: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 64560:     return cx->malloc_(nbytes);
     1: }
     1: 
     1: JS_PUBLIC_API(void *)
     1: JS_realloc(JSContext *cx, void *p, size_t nbytes)
     1: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 64560:     return cx->realloc_(p, nbytes);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_free(JSContext *cx, void *p)
     1: {
110933:     return js_free(p);
     1: }
     1: 
 34383: JS_PUBLIC_API(void)
 94738: JS_freeop(JSFreeOp *fop, void *p)
 94738: {
 94738:     return FreeOp::get(fop)->free_(p);
 94738: }
 94738: 
 94739: JS_PUBLIC_API(JSFreeOp *)
 94739: JS_GetDefaultFreeOp(JSRuntime *rt)
 94739: {
 94739:     return rt->defaultFreeOp();
 94739: }
 94739: 
 94738: JS_PUBLIC_API(void)
 34383: JS_updateMallocCounter(JSContext *cx, size_t nbytes)
 34383: {
 88570:     return cx->runtime->updateMallocCounter(cx, nbytes);
 34383: }
 34383: 
     1: JS_PUBLIC_API(char *)
     1: JS_strdup(JSContext *cx, const char *s)
     1: {
103783:     AssertHeapIsIdle(cx);
 87623:     size_t n = strlen(s) + 1;
 87623:     void *p = cx->malloc_(n);
     1:     if (!p)
     1:         return NULL;
 87623:     return (char *)js_memcpy(p, s, n);
     1: }
     1: 
     1: #undef JS_AddRoot
 47403: 
     1: JS_PUBLIC_API(JSBool)
 47403: JS_AddValueRoot(JSContext *cx, jsval *vp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 78614:     return js_AddRoot(cx, vp, NULL);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 47403: JS_AddStringRoot(JSContext *cx, JSString **rp)
 47403: {
103783:     AssertHeapIsIdle(cx);
 47403:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, NULL);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 47403: JS_AddObjectRoot(JSContext *cx, JSObject **rp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, NULL);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 48470: JS_AddGCThingRoot(JSContext *cx, void **rp)
 47403: {
103783:     AssertHeapIsIdle(cx);
 47403:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, NULL);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 48470: JS_AddNamedValueRoot(JSContext *cx, jsval *vp, const char *name)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 78614:     return js_AddRoot(cx, vp, name);
 47403: }
 47403: 
 47403: JS_PUBLIC_API(JSBool)
 47403: JS_AddNamedStringRoot(JSContext *cx, JSString **rp, const char *name)
 47403: {
103783:     AssertHeapIsIdle(cx);
 47403:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, name);
 47403: }
 47403: 
 47403: JS_PUBLIC_API(JSBool)
 47403: JS_AddNamedObjectRoot(JSContext *cx, JSObject **rp, const char *name)
 47403: {
103783:     AssertHeapIsIdle(cx);
 47403:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, name);
 47403: }
 47403: 
 47403: JS_PUBLIC_API(JSBool)
 78492: JS_AddNamedScriptRoot(JSContext *cx, JSScript **rp, const char *name)
 78492: {
103783:     AssertHeapIsIdle(cx);
 78492:     CHECK_REQUEST(cx);
 78492:     return js_AddGCThingRoot(cx, (void **)rp, name);
 78492: }
 78492: 
 78492: JS_PUBLIC_API(JSBool)
 48470: JS_AddNamedGCThingRoot(JSContext *cx, void **rp, const char *name)
 47403: {
103783:     AssertHeapIsIdle(cx);
 47403:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, name);
 47403: }
 47403: 
 86458: /* We allow unrooting from finalizers within the GC */
 86458: 
 94739: JS_PUBLIC_API(void)
 47403: JS_RemoveValueRoot(JSContext *cx, jsval *vp)
 47403: {
 47403:     CHECK_REQUEST(cx);
 94739:     js_RemoveRoot(cx->runtime, (void *)vp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 47403: JS_RemoveStringRoot(JSContext *cx, JSString **rp)
 47403: {
 47403:     CHECK_REQUEST(cx);
 94739:     js_RemoveRoot(cx->runtime, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 47403: JS_RemoveObjectRoot(JSContext *cx, JSObject **rp)
 47403: {
 47403:     CHECK_REQUEST(cx);
 94739:     js_RemoveRoot(cx->runtime, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 78492: JS_RemoveScriptRoot(JSContext *cx, JSScript **rp)
 78492: {
 78492:     CHECK_REQUEST(cx);
 94739:     js_RemoveRoot(cx->runtime, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 48470: JS_RemoveGCThingRoot(JSContext *cx, void **rp)
 47403: {
 47403:     CHECK_REQUEST(cx);
 94739:     js_RemoveRoot(cx->runtime, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 94739: JS_RemoveValueRootRT(JSRuntime *rt, jsval *vp)
 94739: {
 94739:     js_RemoveRoot(rt, (void *)vp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 94739: JS_RemoveStringRootRT(JSRuntime *rt, JSString **rp)
 94739: {
 94739:     js_RemoveRoot(rt, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 94739: JS_RemoveObjectRootRT(JSRuntime *rt, JSObject **rp)
 94739: {
 94739:     js_RemoveRoot(rt, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
110460: JS_RemoveScriptRootRT(JSRuntime *rt, JSScript **rp)
 94739: {
 94739:     js_RemoveRoot(rt, (void *)rp);
 47403: }
 47403: 
 64190: JS_NEVER_INLINE JS_PUBLIC_API(void)
 64190: JS_AnchorPtr(void *p)
 64190: {
 64190: }
 64190: 
     1: #ifdef DEBUG
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_DumpNamedRoots(JSRuntime *rt,
 48470:                   void (*dump)(const char *name, void *rp, JSGCRootType type, void *data),
     1:                   void *data)
     1: {
     1:     js_DumpNamedRoots(rt, dump, data);
     1: }
     1: 
     1: #endif /* DEBUG */
     1: 
 84755: JS_PUBLIC_API(uint32_t)
     1: JS_MapGCRoots(JSRuntime *rt, JSGCRootMapFun map, void *data)
     1: {
     1:     return js_MapGCRoots(rt, map, data);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_LockGCThing(JSContext *cx, void *thing)
     1: {
     1:     JSBool ok;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 12282:     ok = js_LockGCThingRT(cx->runtime, thing);
     1:     if (!ok)
 12282:         JS_ReportOutOfMemory(cx);
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_LockGCThingRT(JSRuntime *rt, void *thing)
     1: {
     1:     return js_LockGCThingRT(rt, thing);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_UnlockGCThing(JSContext *cx, void *thing)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 36410:     js_UnlockGCThingRT(cx->runtime, thing);
 36410:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_UnlockGCThingRT(JSRuntime *rt, void *thing)
     1: {
 36410:     js_UnlockGCThingRT(rt, thing);
 36410:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
 80159: JS_SetExtraGCRootsTracer(JSRuntime *rt, JSTraceDataOp traceOp, void *data)
 80159: {
103783:     AssertHeapIsIdle(rt);
 80159:     rt->gcBlackRootsTraceOp = traceOp;
 80159:     rt->gcBlackRootsData = data;
   958: }
   958: 
   958: JS_PUBLIC_API(void)
 91339: JS_TracerInit(JSTracer *trc, JSRuntime *rt, JSTraceCallback callback)
 91339: {
 91339:     InitTracer(trc, rt, callback);
 87290: }
 87290: 
 87290: JS_PUBLIC_API(void)
   786: JS_TraceRuntime(JSTracer *trc)
   786: {
103783:     AssertHeapIsIdle(trc->runtime);
 53548:     TraceRuntime(trc);
   786: }
   786: 
 38595: JS_PUBLIC_API(void)
 82129: JS_TraceChildren(JSTracer *trc, void *thing, JSGCTraceKind kind)
 82129: {
 82129:     js::TraceChildren(trc, thing, kind);
 82129: }
 82129: 
 82129: JS_PUBLIC_API(void)
 77715: JS_CallTracer(JSTracer *trc, void *thing, JSGCTraceKind kind)
 38595: {
 82129:     js::CallTracer(trc, thing, kind);
 38595: }
 38595: 
   786: JS_PUBLIC_API(void)
101990: JS_GetTraceThingInfo(char *buf, size_t bufsize, JSTracer *trc, void *thing,
 77715:                      JSGCTraceKind kind, JSBool details)
 77715: {
 77715:     const char *name = NULL; /* silence uninitialized warning */
   786:     size_t n;
   786: 
   786:     if (bufsize == 0)
   786:         return;
   786: 
   786:     switch (kind) {
   786:       case JSTRACE_OBJECT:
   786:       {
 90876:         name = static_cast<JSObject *>(thing)->getClass()->name;
   786:         break;
   786:       }
   786: 
   786:       case JSTRACE_STRING:
 29366:         name = ((JSString *)thing)->isDependent()
   786:                ? "substring"
   786:                : "string";
   786:         break;
   786: 
 77659:       case JSTRACE_SCRIPT:
 77659:         name = "script";
 77659:         break;
 77659: 
112047:       case JSTRACE_IONCODE:
112047:         name = "ioncode";
112047:         break;
112047: 
 64360:       case JSTRACE_SHAPE:
 64360:         name = "shape";
 64360:         break;
 64360: 
 83221:       case JSTRACE_BASE_SHAPE:
 83221:         name = "base_shape";
 83221:         break;
 83221: 
 77659:       case JSTRACE_TYPE_OBJECT:
 77659:         name = "type_object";
 77659:         break;
 77659: 
   786: #if JS_HAS_XML_SUPPORT
   786:       case JSTRACE_XML:
   786:         name = "xml";
   786:         break;
   786: #endif
   786:     }
   786: 
   786:     n = strlen(name);
   786:     if (n > bufsize - 1)
   786:         n = bufsize - 1;
 87623:     js_memcpy(buf, name, n + 1);
   786:     buf += n;
   786:     bufsize -= n;
 90876:     *buf = '\0';
   786: 
   786:     if (details && bufsize > 2) {
   786:         switch (kind) {
   786:           case JSTRACE_OBJECT:
   786:           {
   786:             JSObject *obj = (JSObject *)thing;
 48470:             Class *clasp = obj->getClass();
 77817:             if (clasp == &FunctionClass) {
 83234:                 JSFunction *fun = obj->toFunction();
 13824:                 if (!fun) {
 13824:                     JS_snprintf(buf, bufsize, " <newborn>");
 76812:                 } else if (fun != obj) {
 13824:                     JS_snprintf(buf, bufsize, " %p", fun);
 13824:                 } else {
109108:                     if (fun->displayAtom()) {
 90876:                         *buf++ = ' ';
 90876:                         bufsize--;
109108:                         PutEscapedString(buf, bufsize, fun->displayAtom(), 0);
 13824:                     }
 90876:                 }
 13824:             } else if (clasp->flags & JSCLASS_HAS_PRIVATE) {
 31452:                 JS_snprintf(buf, bufsize, " %p", obj->getPrivate());
 11846:             } else {
 11846:                 JS_snprintf(buf, bufsize, " <no private>");
 11846:             }
   786:             break;
   786:           }
   786: 
   786:           case JSTRACE_STRING:
 59890:           {
 90876:             *buf++ = ' ';
 90876:             bufsize--;
 59890:             JSString *str = (JSString *)thing;
 59890:             if (str->isLinear())
 64345:                 PutEscapedString(buf, bufsize, &str->asLinear(), 0);
 59890:             else
 59890:                 JS_snprintf(buf, bufsize, "<rope: length %d>", (int)str->length());
   786:             break;
 59890:           }
   786: 
 77659:           case JSTRACE_SCRIPT:
 77659:           {
 77659:             JSScript *script = static_cast<JSScript *>(thing);
 77659:             JS_snprintf(buf, bufsize, " %s:%u", script->filename, unsigned(script->lineno));
 77659:             break;
 77659:           }
 77659: 
112047:           case JSTRACE_IONCODE:
 64360:           case JSTRACE_SHAPE:
 83221:           case JSTRACE_BASE_SHAPE:
 77659:           case JSTRACE_TYPE_OBJECT:
 64360:             break;
 64360: 
   786: #if JS_HAS_XML_SUPPORT
  4529:           case JSTRACE_XML:
   786:           {
   786:             extern const char *js_xml_class_str[];
   786:             JSXML *xml = (JSXML *)thing;
   786: 
   786:             JS_snprintf(buf, bufsize, " %s", js_xml_class_str[xml->xml_class]);
   786:             break;
   786:           }
   786: #endif
   786:         }
   786:     }
   786:     buf[bufsize - 1] = '\0';
   786: }
   786: 
 80670: extern JS_PUBLIC_API(const char *)
 80670: JS_GetTraceEdgeName(JSTracer *trc, char *buffer, int bufferSize)
 80670: {
 80670:     if (trc->debugPrinter) {
 80670:         trc->debugPrinter(trc, buffer, bufferSize);
 80670:         return buffer;
 80670:     }
 80670:     if (trc->debugPrintIndex != (size_t) - 1) {
 80670:         JS_snprintf(buffer, bufferSize, "%s[%lu]",
 80670:                     (const char *)trc->debugPrintArg,
 80670:                     trc->debugPrintIndex);
 80670:         return buffer;
 80670:     }
 80670:     return (const char*)trc->debugPrintArg;
 80670: }
 80670: 
101990: #ifdef DEBUG
101990: 
   786: typedef struct JSHeapDumpNode JSHeapDumpNode;
   786: 
   786: struct JSHeapDumpNode {
   786:     void            *thing;
 77715:     JSGCTraceKind   kind;
   786:     JSHeapDumpNode  *next;          /* next sibling */
   786:     JSHeapDumpNode  *parent;        /* node with the thing that refer to thing
   786:                                        from this node */
   786:     char            edgeName[1];    /* name of the edge from parent->thing
   786:                                        into thing */
   786: };
   786: 
 94610: typedef HashSet<void *, PointerHasher<void *, 3>, SystemAllocPolicy> VisitedSet;
 94610: 
   786: typedef struct JSDumpingTracer {
   786:     JSTracer            base;
 94610:     VisitedSet          visited;
 91339:     bool                ok;
   786:     void                *startThing;
   786:     void                *thingToFind;
   786:     void                *thingToIgnore;
   786:     JSHeapDumpNode      *parentNode;
   786:     JSHeapDumpNode      **lastNodep;
   786:     char                buffer[200];
   786: } JSDumpingTracer;
   786: 
   786: static void
 90232: DumpNotify(JSTracer *trc, void **thingp, JSGCTraceKind kind)
 90232: {
 94610:     JS_ASSERT(trc->callback == DumpNotify);
 94610: 
 94610:     JSDumpingTracer *dtrc = (JSDumpingTracer *)trc;
 94416:     void *thing = *thingp;
   786: 
   786:     if (!dtrc->ok || thing == dtrc->thingToIgnore)
   786:         return;
   786: 
   786:     /*
   786:      * Check if we have already seen thing unless it is thingToFind to include
   786:      * it to the graph each time we reach it and print all live things that
   786:      * refer to thingToFind.
   786:      *
   786:      * This does not print all possible paths leading to thingToFind since
   786:      * when a thing A refers directly or indirectly to thingToFind and A is
   786:      * present several times in the graph, we will print only the first path
   786:      * leading to A and thingToFind, other ways to reach A will be ignored.
   786:      */
   786:     if (dtrc->thingToFind != thing) {
   786:         /*
   786:          * The startThing check allows to avoid putting startThing into the
   786:          * hash table before tracing startThing in JS_DumpHeap.
   786:          */
   786:         if (thing == dtrc->startThing)
   786:             return;
 94610:         VisitedSet::AddPtr p = dtrc->visited.lookupForAdd(thing);
 94610:         if (p)
 94610:             return;
 94610:         if (!dtrc->visited.add(p, thing)) {
 91339:             dtrc->ok = false;
   786:             return;
   786:         }
   786:     }
   786: 
 87623:     const char *edgeName = JS_GetTraceEdgeName(&dtrc->base, dtrc->buffer, sizeof(dtrc->buffer));
 87623:     size_t edgeNameSize = strlen(edgeName) + 1;
 71352:     size_t bytes = offsetof(JSHeapDumpNode, edgeName) + edgeNameSize;
110933:     JSHeapDumpNode *node = (JSHeapDumpNode *) js_malloc(bytes);
   786:     if (!node) {
 91339:         dtrc->ok = false;
   786:         return;
   786:     }
   786: 
   786:     node->thing = thing;
   786:     node->kind = kind;
   786:     node->next = NULL;
   786:     node->parent = dtrc->parentNode;
 87623:     js_memcpy(node->edgeName, edgeName, edgeNameSize);
   786: 
   786:     JS_ASSERT(!*dtrc->lastNodep);
   786:     *dtrc->lastNodep = node;
   786:     dtrc->lastNodep = &node->next;
   786: }
   786: 
   786: /* Dump node and the chain that leads to thing it contains. */
   786: static JSBool
   917: DumpNode(JSDumpingTracer *dtrc, FILE* fp, JSHeapDumpNode *node)
   786: {
   786:     JSHeapDumpNode *prev, *following;
   786:     size_t chainLimit;
   786:     enum { MAX_PARENTS_TO_PRINT = 10 };
   786: 
101990:     JS_GetTraceThingInfo(dtrc->buffer, sizeof dtrc->buffer,
   786:                          &dtrc->base, node->thing, node->kind, JS_TRUE);
   917:     if (fprintf(fp, "%p %-22s via ", node->thing, dtrc->buffer) < 0)
   786:         return JS_FALSE;
   786: 
   786:     /*
   786:      * We need to print the parent chain in the reverse order. To do it in
   786:      * O(N) time where N is the chain length we first reverse the chain while
   786:      * searching for the top and then print each node while restoring the
   786:      * chain order.
   786:      */
   786:     chainLimit = MAX_PARENTS_TO_PRINT;
   786:     prev = NULL;
   786:     for (;;) {
   786:         following = node->parent;
   786:         node->parent = prev;
   786:         prev = node;
   786:         node = following;
   786:         if (!node)
   786:             break;
   786:         if (chainLimit == 0) {
   917:             if (fputs("...", fp) < 0)
   786:                 return JS_FALSE;
   786:             break;
   786:         }
   786:         --chainLimit;
   786:     }
   786: 
   786:     node = prev;
   786:     prev = following;
 91339:     bool ok = true;
   786:     do {
   786:         /* Loop must continue even when !ok to restore the parent chain. */
   786:         if (ok) {
   786:             if (!prev) {
   786:                 /* Print edge from some runtime root or startThing. */
   917:                 if (fputs(node->edgeName, fp) < 0)
 91339:                     ok = false;
   786:             } else {
101990:                 JS_GetTraceThingInfo(dtrc->buffer, sizeof dtrc->buffer,
   786:                                      &dtrc->base, prev->thing, prev->kind,
   786:                                      JS_FALSE);
   917:                 if (fprintf(fp, "(%p %s).%s",
   786:                            prev->thing, dtrc->buffer, node->edgeName) < 0) {
 91339:                     ok = false;
   786:                 }
   786:             }
   786:         }
   786:         following = node->parent;
   786:         node->parent = prev;
   786:         prev = node;
   786:         node = following;
   786:     } while (node);
   786: 
   917:     return ok && putc('\n', fp) >= 0;
   786: }
   786: 
   786: JS_PUBLIC_API(JSBool)
 91339: JS_DumpHeap(JSRuntime *rt, FILE *fp, void* startThing, JSGCTraceKind startKind,
   917:             void *thingToFind, size_t maxDepth, void *thingToIgnore)
   786: {
 94610:     if (maxDepth == 0)
 94610:         return true;
 94610: 
 94416:     JSDumpingTracer dtrc;
 94610:     if (!dtrc.visited.init())
 94610:         return false;
 94416:     JS_TracerInit(&dtrc.base, rt, DumpNotify);
 94610:     dtrc.ok = true;
   786:     dtrc.startThing = startThing;
   786:     dtrc.thingToFind = thingToFind;
   786:     dtrc.thingToIgnore = thingToIgnore;
   786:     dtrc.parentNode = NULL;
 94610:     JSHeapDumpNode *node = NULL;
   786:     dtrc.lastNodep = &node;
   786:     if (!startThing) {
 77715:         JS_ASSERT(startKind == JSTRACE_OBJECT);
 53548:         TraceRuntime(&dtrc.base);
   786:     } else {
   786:         JS_TraceChildren(&dtrc.base, startThing, startKind);
   786:     }
   786: 
   786:     if (!node)
 94610:         return dtrc.ok;
 94610: 
 94610:     size_t depth = 1;
 94610:     JSHeapDumpNode *children, *next, *parent;
 94610:     bool thingToFindWasTraced = thingToFind && thingToFind == startThing;
   786:     for (;;) {
   786:         /*
   786:          * Loop must continue even when !dtrc.ok to free all nodes allocated
   786:          * so far.
   786:          */
   786:         if (dtrc.ok) {
   786:             if (thingToFind == NULL || thingToFind == node->thing)
   917:                 dtrc.ok = DumpNode(&dtrc, fp, node);
   786: 
   786:             /* Descend into children. */
   786:             if (dtrc.ok &&
   786:                 depth < maxDepth &&
   786:                 (thingToFind != node->thing || !thingToFindWasTraced)) {
   786:                 dtrc.parentNode = node;
   786:                 children = NULL;
   786:                 dtrc.lastNodep = &children;
   786:                 JS_TraceChildren(&dtrc.base, node->thing, node->kind);
   786:                 if (thingToFind == node->thing)
   786:                     thingToFindWasTraced = JS_TRUE;
   786:                 if (children != NULL) {
   786:                     ++depth;
   786:                     node = children;
   786:                     continue;
   786:                 }
   786:             }
   786:         }
   786: 
   786:         /* Move to next or parents next and free the node. */
   786:         for (;;) {
   786:             next = node->next;
   786:             parent = node->parent;
110933:             js_free(node);
   786:             node = next;
   786:             if (node)
   786:                 break;
   786:             if (!parent)
 94610:                 return dtrc.ok;
   786:             JS_ASSERT(depth > 1);
   786:             --depth;
   786:             node = parent;
   786:         }
   786:     }
   786: 
   786:     JS_ASSERT(depth == 1);
   786:     return dtrc.ok;
   786: }
   786: 
   786: #endif /* DEBUG */
   786: 
   583: extern JS_PUBLIC_API(JSBool)
   583: JS_IsGCMarkingTracer(JSTracer *trc)
   583: {
   583:     return IS_GC_MARKING_TRACER(trc);
   583: }
   583: 
 94871: JS_PUBLIC_API(void)
 94960: JS_GC(JSRuntime *rt)
 94960: {
103783:     AssertHeapIsIdle(rt);
 94960:     PrepareForFullGC(rt);
 94960:     GC(rt, GC_NORMAL, gcreason::API);
 94620: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_MaybeGC(JSContext *cx)
     1: {
 60258:     MaybeGC(cx);
     1: }
     1: 
 91339: JS_PUBLIC_API(void)
 91339: JS_SetGCCallback(JSRuntime *rt, JSGCCallback cb)
 91339: {
103783:     AssertHeapIsIdle(rt);
     1:     rt->gcCallback = cb;
 91339: }
 91339: 
 91339: JS_PUBLIC_API(void)
 91339: JS_SetFinalizeCallback(JSRuntime *rt, JSFinalizeCallback cb)
 91339: {
103783:     AssertHeapIsIdle(rt);
 91339:     rt->gcFinalizeCallback = cb;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 89658: JS_IsAboutToBeFinalized(void *thing)
 89658: {
 89658:     gc::Cell *t = static_cast<gc::Cell *>(thing);
 99246:     bool isMarked = IsCellMarked(&t);
 99246:     JS_ASSERT(t == thing);
 99246:     return !isMarked;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
 84755: JS_SetGCParameter(JSRuntime *rt, JSGCParamKey key, uint32_t value)
     1: {
     1:     switch (key) {
 86796:       case JSGC_MAX_BYTES: {
 86796:         JS_ASSERT(value >= rt->gcBytes);
     1:         rt->gcMaxBytes = value;
     1:         break;
 86796:       }
 32553:       case JSGC_MAX_MALLOC_BYTES:
 34288:         rt->setGCMaxMallocBytes(value);
 32553:         break;
 90410:       case JSGC_SLICE_TIME_BUDGET:
 90410:         rt->gcSliceBudget = SliceBudget::TimeBudget(value);
 90410:         break;
 90934:       case JSGC_MARK_STACK_LIMIT:
 90934:         js::SetMarkStackLimit(rt, value);
 90934:         break;
104267:       case JSGC_HIGH_FREQUENCY_TIME_LIMIT:
104267:         rt->gcHighFrequencyTimeThreshold = value;
104267:         break;
104267:       case JSGC_HIGH_FREQUENCY_LOW_LIMIT:
104267:         rt->gcHighFrequencyLowLimitBytes = value * 1024 * 1024;
104267:         break;
104267:       case JSGC_HIGH_FREQUENCY_HIGH_LIMIT:
104267:         rt->gcHighFrequencyHighLimitBytes = value * 1024 * 1024;
104267:         break;
104267:       case JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX:
104267:         rt->gcHighFrequencyHeapGrowthMax = value / 100.0;
104267:         break;
104267:       case JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN:
104267:         rt->gcHighFrequencyHeapGrowthMin = value / 100.0;
104267:         break;
104267:       case JSGC_LOW_FREQUENCY_HEAP_GROWTH:
104267:         rt->gcLowFrequencyHeapGrowth = value / 100.0;
104267:         break;
104267:       case JSGC_DYNAMIC_HEAP_GROWTH:
104267:         rt->gcDynamicHeapGrowth = value;
104267:         break;
104267:       case JSGC_DYNAMIC_MARK_SLICE:
104267:         rt->gcDynamicMarkSlice = value;
104267:         break;
109045:       case JSGC_ANALYSIS_PURGE_TRIGGER:
109045:         rt->analysisPurgeTriggerBytes = value * 1024 * 1024;
109045:         break;
117017:       case JSGC_ALLOCATION_THRESHOLD:
117017:         rt->gcAllocationThreshold = value * 1024 * 1024;
117017:         break;
 69836:       default:
 69836:         JS_ASSERT(key == JSGC_MODE);
 60531:         rt->gcMode = JSGCMode(value);
 60531:         JS_ASSERT(rt->gcMode == JSGC_MODE_GLOBAL ||
 90410:                   rt->gcMode == JSGC_MODE_COMPARTMENT ||
 90410:                   rt->gcMode == JSGC_MODE_INCREMENTAL);
 32553:         return;
 24313:     }
 24313: }
 24313: 
 84755: JS_PUBLIC_API(uint32_t)
 24313: JS_GetGCParameter(JSRuntime *rt, JSGCParamKey key)
 24313: {
 24313:     switch (key) {
 24313:       case JSGC_MAX_BYTES:
 86796:         return uint32_t(rt->gcMaxBytes);
 32553:       case JSGC_MAX_MALLOC_BYTES:
 32553:         return rt->gcMaxMallocBytes;
 24313:       case JSGC_BYTES:
 86796:         return uint32_t(rt->gcBytes);
 60531:       case JSGC_MODE:
 84755:         return uint32_t(rt->gcMode);
 62964:       case JSGC_UNUSED_CHUNKS:
 84755:         return uint32_t(rt->gcChunkPool.getEmptyCount());
 74782:       case JSGC_TOTAL_CHUNKS:
 84755:         return uint32_t(rt->gcChunkSet.count() + rt->gcChunkPool.getEmptyCount());
 90410:       case JSGC_SLICE_TIME_BUDGET:
 90410:         return uint32_t(rt->gcSliceBudget > 0 ? rt->gcSliceBudget / PRMJ_USEC_PER_MSEC : 0);
 90934:       case JSGC_MARK_STACK_LIMIT:
 90934:         return rt->gcMarker.sizeLimit();
104267:       case JSGC_HIGH_FREQUENCY_TIME_LIMIT:
104267:         return rt->gcHighFrequencyTimeThreshold;
104267:       case JSGC_HIGH_FREQUENCY_LOW_LIMIT:
104267:         return rt->gcHighFrequencyLowLimitBytes / 1024 / 1024;
104267:       case JSGC_HIGH_FREQUENCY_HIGH_LIMIT:
104267:         return rt->gcHighFrequencyHighLimitBytes / 1024 / 1024;
104267:       case JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX:
104267:         return uint32_t(rt->gcHighFrequencyHeapGrowthMax * 100);
104267:       case JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN:
104267:         return uint32_t(rt->gcHighFrequencyHeapGrowthMin * 100);
104267:       case JSGC_LOW_FREQUENCY_HEAP_GROWTH:
104267:         return uint32_t(rt->gcLowFrequencyHeapGrowth * 100);
104267:       case JSGC_DYNAMIC_HEAP_GROWTH:
104267:         return rt->gcDynamicHeapGrowth;
104267:       case JSGC_DYNAMIC_MARK_SLICE:
104267:         return rt->gcDynamicMarkSlice;
109045:       case JSGC_ANALYSIS_PURGE_TRIGGER:
109045:         return rt->analysisPurgeTriggerBytes / 1024 / 1024;
117017:       case JSGC_ALLOCATION_THRESHOLD:
117017:         return rt->gcAllocationThreshold / 1024 / 1024;
 24313:       default:
 24313:         JS_ASSERT(key == JSGC_NUMBER);
 90410:         return uint32_t(rt->gcNumber);
     1:     }
     1: }
     1: 
 27884: JS_PUBLIC_API(void)
 84755: JS_SetGCParameterForThread(JSContext *cx, JSGCParamKey key, uint32_t value)
 27884: {
 27884:     JS_ASSERT(key == JSGC_MAX_CODE_CACHE_BYTES);
 27884: }
 27884: 
 84755: JS_PUBLIC_API(uint32_t)
 27884: JS_GetGCParameterForThread(JSContext *cx, JSGCParamKey key)
 27884: {
 27884:     JS_ASSERT(key == JSGC_MAX_CODE_CACHE_BYTES);
 27885:     return 0;
 27884: }
 27884: 
     1: JS_PUBLIC_API(JSString *)
 89632: JS_NewExternalString(JSContext *cx, const jschar *chars, size_t length,
 89632:                      const JSStringFinalizer *fin)
 89632: {
103783:     AssertHeapIsIdle(cx);
 89632:     CHECK_REQUEST(cx);
 89632:     JSString *s = JSExternalString::new_(cx, chars, length, fin);
 73746:     Probes::createString(cx, s, length);
 73746:     return s;
 68942: }
 68942: 
 68942: extern JS_PUBLIC_API(JSBool)
 89632: JS_IsExternalString(JSString *str)
 89632: {
 68942:     return str->isExternal();
 68942: }
 68942: 
 89632: extern JS_PUBLIC_API(const JSStringFinalizer *)
 89632: JS_GetExternalStringFinalizer(JSString *str)
 89632: {
 89632:     return str->asExternal().externalFinalizer();
     1: }
     1: 
     1: JS_PUBLIC_API(void)
 89261: JS_SetNativeStackQuota(JSRuntime *rt, size_t stackSize)
 89261: {
 89261:     rt->nativeStackQuota = stackSize;
 89261:     if (!rt->nativeStackBase)
 89261:         return;
 89261: 
 42740: #if JS_STACK_GROWTH_DIRECTION > 0
 42740:     if (stackSize == 0) {
 89261:         rt->nativeStackLimit = UINTPTR_MAX;
 42740:     } else {
 89261:         JS_ASSERT(rt->nativeStackBase <= size_t(-1) - stackSize);
 89261:         rt->nativeStackLimit = rt->nativeStackBase + stackSize - 1;
 42740:     }
 42740: #else
 42740:     if (stackSize == 0) {
 89261:         rt->nativeStackLimit = 0;
 42740:     } else {
 89261:         JS_ASSERT(rt->nativeStackBase >= stackSize);
 89261:         rt->nativeStackLimit = rt->nativeStackBase - (stackSize - 1);
 42740:     }
 42740: #endif
 42740: }
 42740: 
     1: /************************************************************************/
     1: 
 91450: JS_PUBLIC_API(int)
 82129: JS_IdArrayLength(JSContext *cx, JSIdArray *ida)
 82129: {
 82129:     return ida->length;
 82129: }
 82129: 
 82129: JS_PUBLIC_API(jsid)
 91450: JS_IdArrayGet(JSContext *cx, JSIdArray *ida, int index)
 82129: {
 82129:     JS_ASSERT(index >= 0 && index < ida->length);
 82129:     return ida->vector[index];
 82129: }
 82129: 
 67898: JS_PUBLIC_API(void)
 67898: JS_DestroyIdArray(JSContext *cx, JSIdArray *ida)
 67898: {
 94740:     DestroyIdArray(cx->runtime->defaultFreeOp(), ida);
 67898: }
 67898: 
     1: JS_PUBLIC_API(JSBool)
111462: JS_ValueToId(JSContext *cx, jsval valueArg, jsid *idp)
111462: {
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
111462:     return ValueToId(cx, value, idp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_IdToValue(JSContext *cx, jsid id, jsval *vp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 48470:     *vp = IdToJsval(id);
 47485:     assertSameCompartment(cx, *vp);
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_DefaultValue(JSContext *cx, JSObject *objArg, JSType hint, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 80466:     CHECK_REQUEST(cx);
 80466:     JS_ASSERT(obj != NULL);
 80466:     JS_ASSERT(hint == JSTYPE_VOID || hint == JSTYPE_STRING || hint == JSTYPE_NUMBER);
106862: 
106862:     RootedValue value(cx);
108951:     if (!JSObject::defaultValue(cx, obj, hint, &value))
106862:         return false;
106862: 
106862:     *vp = value;
106862:     return true;
106862: }
106862: 
106862: JS_PUBLIC_API(JSBool)
106862: JS_PropertyStub(JSContext *cx, JSHandleObject obj, JSHandleId id, JSMutableHandleValue vp)
     1: {
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
106862: JS_StrictPropertyStub(JSContext *cx, JSHandleObject obj, JSHandleId id, JSBool strict, JSMutableHandleValue vp)
 62395: {
 62395:     return JS_TRUE;
 62395: }
 62395: 
 62395: JS_PUBLIC_API(JSBool)
 98960: JS_EnumerateStub(JSContext *cx, JSHandleObject obj)
     1: {
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 98960: JS_ResolveStub(JSContext *cx, JSHandleObject obj, JSHandleId id)
     1: {
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
106862: JS_ConvertStub(JSContext *cx, JSHandleObject obj, JSType type, JSMutableHandleValue vp)
     1: {
 40867:     JS_ASSERT(type != JSTYPE_OBJECT && type != JSTYPE_FUNCTION);
 72054:     JS_ASSERT(obj);
102586:     return DefaultValue(cx, obj, type, vp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
107154: JS_InitClass(JSContext *cx, JSObject *objArg, JSObject *parent_protoArg,
 91237:              JSClass *clasp, JSNative constructor, unsigned nargs,
     1:              JSPropertySpec *ps, JSFunctionSpec *fs,
     1:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
     1: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedObject parent_proto(cx, parent_protoArg);
103783:     AssertHeapIsIdle(cx);
 25897:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, parent_proto);
 99364:     return js_InitClass(cx, obj, parent_proto, Valueify(clasp), constructor,
 78614:                         nargs, ps, fs, static_ps, static_fs);
 25887: }
 25887: 
 89207: JS_PUBLIC_API(JSBool)
107154: JS_LinkConstructorAndPrototype(JSContext *cx, JSObject *ctorArg, JSObject *protoArg)
107154: {
107154:     RootedObject ctor(cx, ctorArg);
107154:     RootedObject proto(cx, protoArg);
 89207:     return LinkConstructorAndPrototype(cx, ctor, proto);
 89207: }
 89207: 
     1: JS_PUBLIC_API(JSClass *)
107154: JS_GetClass(RawObject obj)
     1: {
 78614:     return obj->getJSClass();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_InstanceOf(JSContext *cx, JSObject *objArg, JSClass *clasp, jsval *argv)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 67947: #ifdef DEBUG
 67947:     if (argv) {
 47485:         assertSameCompartment(cx, obj);
 67947:         assertSameCompartment(cx, JSValueArray(argv - 2, 2));
 67947:     }
 67947: #endif
 67947:     if (!obj || obj->getJSClass() != clasp) {
 67943:         if (argv)
 79387:             ReportIncompatibleMethod(cx, CallReceiverFromArgv(argv), Valueify(clasp));
 67943:         return false;
 67943:     }
 67943:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
111462: JS_HasInstance(JSContext *cx, JSObject *objArg, jsval valueArg, JSBool *bp)
107154: {
107154:     RootedObject obj(cx, objArg);
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     assertSameCompartment(cx, obj, value);
113652:     return HasInstance(cx, obj, value, bp);
     1: }
     1: 
     1: JS_PUBLIC_API(void *)
107154: JS_GetPrivate(RawObject obj)
     1: {
 86458:     /* This function can be called by a finalizer. */
 31452:     return obj->getPrivate();
     1: }
     1: 
 89826: JS_PUBLIC_API(void)
107154: JS_SetPrivate(RawObject obj, void *data)
     1: {
 86458:     /* This function can be called by a finalizer. */
 32684:     obj->setPrivate(data);
     1: }
     1: 
     1: JS_PUBLIC_API(void *)
107154: JS_GetInstancePrivate(JSContext *cx, JSObject *objArg, JSClass *clasp, jsval *argv)
107154: {
107154:     RootedObject obj(cx, objArg);
 67944:     if (!JS_InstanceOf(cx, obj, clasp, argv))
     1:         return NULL;
 32684:     return obj->getPrivate();
     1: }
     1: 
115023: JS_PUBLIC_API(JSBool)
115023: JS_GetPrototype(JSContext *cx, JSObject *objArg, JSObject **protop)
115023: {
115023:     RootedObject obj(cx, objArg);
115023:     RootedObject proto(cx);
115023:     bool rv = JSObject::getProto(cx, obj, &proto);
115023:     *protop = proto;
115023:     return rv;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_SetPrototype(JSContext *cx, JSObject *objArg, JSObject *protoArg)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedObject proto(cx, protoArg);
107154:     AssertHeapIsIdle(cx);
107154:     CHECK_REQUEST(cx);
107154:     assertSameCompartment(cx, obj, proto);
107154: 
102586:     return SetProto(cx, obj, proto, JS_FALSE);
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
107154: JS_GetParent(RawObject obj)
     1: {
 86483:     JS_ASSERT(!obj->isScope());
 83275:     return obj->getParent();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_SetParent(JSContext *cx, JSObject *objArg, JSObject *parentArg)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedObject parent(cx, parentArg);
107154:     AssertHeapIsIdle(cx);
107154:     CHECK_REQUEST(cx);
107154:     JS_ASSERT(!obj->isScope());
107154:     JS_ASSERT(parent || !obj->getParent());
107154:     assertSameCompartment(cx, obj, parent);
107154: 
102586:     return JSObject::setParent(cx, obj, parent);
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
107154: JS_GetConstructor(JSContext *cx, JSObject *protoArg)
107154: {
107154:     RootedObject proto(cx, protoArg);
106862:     RootedValue cval(cx);
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, proto);
 19712:     {
 19712:         JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 19712: 
114207:         if (!JSObject::getProperty(cx, proto, proto, cx->names().constructor, &cval))
     1:             return NULL;
     1:     }
 83234:     if (!IsFunctionObject(cval)) {
     1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_CONSTRUCTOR,
 40826:                              proto->getClass()->name);
     1:         return NULL;
     1:     }
 48470:     return &cval.toObject();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_GetObjectId(JSContext *cx, JSRawObject obj, jsid *idp)
     1: {
103783:     AssertHeapIsIdle(cx);
 47485:     assertSameCompartment(cx, obj);
     1:     *idp = OBJECT_TO_JSID(obj);
     1:     return JS_TRUE;
     1: }
     1: 
 64258: class AutoHoldCompartment {
 64258:   public:
 64258:     explicit AutoHoldCompartment(JSCompartment *compartment JS_GUARD_OBJECT_NOTIFIER_PARAM)
 64258:       : holdp(&compartment->hold)
 64258:     {
 64258:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 64258:         *holdp = true;
 64258:     }
 64258: 
 64258:     ~AutoHoldCompartment() {
 64258:         *holdp = false;
 64258:     }
 64258:   private:
 64258:     bool *holdp;
 64258:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 64258: };
 64258: 
 43286: JS_PUBLIC_API(JSObject *)
102756: JS_NewGlobalObject(JSContext *cx, JSClass *clasp, JSPrincipals *principals)
 47498: {
103783:     AssertHeapIsIdle(cx);
 47498:     CHECK_REQUEST(cx);
102755:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
102755: 
 47516:     JSCompartment *compartment = NewCompartment(cx, principals);
 47498:     if (!compartment)
 47498:         return NULL;
 47498: 
 64258:     AutoHoldCompartment hold(compartment);
 64258: 
 47498:     JSCompartment *saved = cx->compartment;
 77343:     cx->setCompartment(compartment);
102755:     GlobalObject *global = GlobalObject::create(cx, Valueify(clasp));
 77343:     cx->setCompartment(saved);
 47498: 
102755:     return global;
 47498: }
 47498: 
 47498: JS_PUBLIC_API(JSObject *)
107154: JS_NewObject(JSContext *cx, JSClass *jsclasp, JSObject *protoArg, JSObject *parentArg)
107154: {
107154:     RootedObject proto(cx, protoArg);
107154:     RootedObject parent(cx, parentArg);
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, proto, parent);
 50450: 
 48470:     Class *clasp = Valueify(jsclasp);
     1:     if (!clasp)
 77817:         clasp = &ObjectClass;    /* default class is Object */
 77817: 
 77817:     JS_ASSERT(clasp != &FunctionClass);
 43286:     JS_ASSERT(!(clasp->flags & JSCLASS_IS_GLOBAL));
 50450: 
 83275:     JSObject *obj = NewObjectWithClassProto(cx, clasp, proto, parent);
111593:     AutoAssertNoGC nogc;
 77343:     if (obj) {
 77343:         if (clasp->ext.equality)
 77353:             MarkTypeObjectFlags(cx, obj, OBJECT_FLAG_SPECIAL_EQUALITY);
 77343:     }
 50450: 
 43286:     JS_ASSERT_IF(obj, obj->getParent());
 43286:     return obj;
  3624: }
  3624: 
 11700: JS_PUBLIC_API(JSObject *)
107154: JS_NewObjectWithGivenProto(JSContext *cx, JSClass *jsclasp, JSObject *protoArg, JSObject *parentArg)
107154: {
107154:     RootedObject proto(cx, protoArg);
107154:     RootedObject parent(cx, parentArg);
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 11700:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, proto, parent);
 50450: 
 48470:     Class *clasp = Valueify(jsclasp);
 11700:     if (!clasp)
 77817:         clasp = &ObjectClass;    /* default class is Object */
 77817: 
 77817:     JS_ASSERT(clasp != &FunctionClass);
 43286:     JS_ASSERT(!(clasp->flags & JSCLASS_IS_GLOBAL));
 50450: 
 83275:     JSObject *obj = NewObjectWithGivenProto(cx, clasp, proto, parent);
111593:     AutoAssertNoGC nogc;
 83248:     if (obj)
 77353:         MarkTypeObjectUnknownProperties(cx, obj->type());
 57806:     return obj;
     1: }
     1: 
 53557: JS_PUBLIC_API(JSObject *)
 94094: JS_NewObjectForConstructor(JSContext *cx, JSClass *clasp, const jsval *vp)
 53557: {
103783:     AssertHeapIsIdle(cx);
 53557:     CHECK_REQUEST(cx);
 53557:     assertSameCompartment(cx, *vp);
 53557: 
104205:     RootedObject obj(cx, JSVAL_TO_OBJECT(*vp));
104205:     return js_CreateThis(cx, Valueify(clasp), obj);
 53557: }
 53557: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_IsExtensible(JSRawObject obj)
 54565: {
 54565:     return obj->isExtensible();
 54565: }
 54565: 
 54565: JS_PUBLIC_API(JSBool)
107154: JS_IsNative(JSRawObject obj)
 68935: {
 68935:     return obj->isNative();
 68935: }
 68935: 
 91339: JS_PUBLIC_API(JSRuntime *)
107154: JS_GetObjectRuntime(JSRawObject obj)
 91339: {
 91339:     return obj->compartment()->rt;
 91339: }
 91339: 
 68935: JS_PUBLIC_API(JSBool)
107154: JS_FreezeObject(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 47485:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 47485: 
108951:     return JSObject::freeze(cx, obj);
 54563: }
 54563: 
 54563: JS_PUBLIC_API(JSBool)
107154: JS_DeepFreezeObject(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 54563:     CHECK_REQUEST(cx);
 54563:     assertSameCompartment(cx, obj);
 54563: 
 54563:     /* Assume that non-extensible objects are already deep-frozen, to avoid divergence. */
115563:     if (!obj->isExtensible())
 52503:         return true;
     1: 
108951:     if (!JSObject::freeze(cx, obj))
 52503:         return false;
 22452: 
     1:     /* Walk slots in obj and if any value is a non-null object, seal it. */
 84755:     for (uint32_t i = 0, n = obj->slotSpan(); i < n; ++i) {
 48470:         const Value &v = obj->getSlot(i);
 48470:         if (v.isPrimitive())
     1:             continue;
107154:         RootedObject obj(cx, &v.toObject());
107154:         if (!JS_DeepFreezeObject(cx, obj))
 52503:             return false;
 52503:     }
 54563: 
 52503:     return true;
     1: }
     1: 
     1: static JSBool
103320: LookupPropertyById(JSContext *cx, HandleObject obj, HandleId id, unsigned flags,
103716:                    MutableHandleObject objp, MutableHandleShape propp)
 43228: {
103783:     AssertHeapIsIdle(cx);
 43231:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 43231: 
 43228:     JSAutoResolveFlags rf(cx, flags);
108951:     return JSObject::lookupGeneric(cx, obj, id, objp, propp);
 43228: }
 43228: 
 43228: #define AUTO_NAMELEN(s,n)   (((n) == (size_t)-1) ? js_strlen(s) : (n))
 43228: 
 43228: static JSBool
103320: LookupResult(JSContext *cx, HandleObject obj, HandleObject obj2, jsid id,
103716:              HandleShape shape, Value *vp)
103716: {
103716:     if (!shape) {
 43228:         /* XXX bad API: no way to tell "not defined" from "void value" */
 48470:         vp->setUndefined();
 43228:         return JS_TRUE;
 43228:     }
 43228: 
 43228:     if (obj2->isNative()) {
 43228:         /* Peek at the native property's slot value, without doing a Get. */
 83221:         if (shape->hasSlot()) {
 83221:             *vp = obj2->nativeGetSlot(shape->slot());
 57180:             return true;
 57180:         }
 57180:     } else {
 57180:         if (obj2->isDenseArray())
 48470:             return js_GetDenseArrayElementValue(cx, obj2, id, vp);
 57180:         if (obj2->isProxy()) {
 57180:             AutoPropertyDescriptorRooter desc(cx);
 79386:             if (!Proxy::getPropertyDescriptor(cx, obj2, id, false, &desc))
 57180:                 return false;
 57180:             if (!(desc.attrs & JSPROP_SHARED)) {
 57180:                 *vp = desc.value;
 57180:                 return true;
 57180:             }
 57180:         }
 57180:     }
 57180: 
 43228:     /* XXX bad API: no way to return "defined but value unknown" */
 48470:     vp->setBoolean(true);
 43290:     return true;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_LookupPropertyById(JSContext *cx, JSObject *objArg, jsid idArg, jsval *vp)
107154: {
107154:     RootedId id(cx, idArg);
107154:     RootedObject obj(cx, objArg);
103320:     RootedObject obj2(cx);
103716:     RootedShape prop(cx);
103320: 
103636:     return LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &prop) &&
 78614:            LookupResult(cx, obj, obj2, id, prop, vp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_LookupElement(JSContext *cx, JSObject *objArg, uint32_t index, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
 75052:     CHECK_REQUEST(cx);
 75052:     jsid id;
 75052:     if (!IndexToId(cx, index, &id))
 75052:         return false;
 75052:     return JS_LookupPropertyById(cx, obj, id, vp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_LookupProperty(JSContext *cx, JSObject *objArg, const char *name, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
 97828:     return atom && JS_LookupPropertyById(cx, obj, AtomToId(atom), vp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_LookupUCProperty(JSContext *cx, JSObject *objArg, const jschar *name, size_t namelen, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_LookupPropertyById(cx, obj, AtomToId(atom), vp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_LookupPropertyWithFlagsById(JSContext *cx, JSObject *objArg, jsid id_, unsigned flags,
107154:                                JSObject **objpArg, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedObject objp(cx, *objpArg);
 99421:     RootedId id(cx, id_);
103716:     RootedShape prop(cx);
 43228: 
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
103320:     if (!(obj->isNative()
103636:           ? LookupPropertyWithFlags(cx, obj, id, flags, &objp, &prop)
108951:           : JSObject::lookupGeneric(cx, obj, id, &objp, &prop)))
103320:         return false;
103320: 
103320:     if (!LookupResult(cx, obj, objp, id, prop, vp))
103320:         return false;
103320: 
107154:     *objpArg = objp;
103320:     return true;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_LookupPropertyWithFlags(JSContext *cx, JSObject *objArg, const char *name, unsigned flags, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
 43228:     JSObject *obj2;
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
 97828:     return atom && JS_LookupPropertyWithFlagsById(cx, obj, AtomToId(atom), flags, &obj2, vp);
 43231: }
 43231: 
 43231: JS_PUBLIC_API(JSBool)
107154: JS_HasPropertyById(JSContext *cx, JSObject *objArg, jsid idArg, JSBool *foundp)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedId id(cx, idArg);
103320:     RootedObject obj2(cx);
103716:     RootedShape prop(cx);
 56567:     JSBool ok = LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
103636:                                    &obj2, &prop);
 56567:     *foundp = (prop != NULL);
 56567:     return ok;
 43229: }
 43229: 
 43229: JS_PUBLIC_API(JSBool)
107154: JS_HasElement(JSContext *cx, JSObject *objArg, uint32_t index, JSBool *foundp)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 75051:     CHECK_REQUEST(cx);
 75051:     jsid id;
 75051:     if (!IndexToId(cx, index, &id))
 75051:         return false;
 75051:     return JS_HasPropertyById(cx, obj, id, foundp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_HasProperty(JSContext *cx, JSObject *objArg, const char *name, JSBool *foundp)
107154: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
 97828:     return atom && JS_HasPropertyById(cx, obj, AtomToId(atom), foundp);
 43231: }
 43231: 
 43231: JS_PUBLIC_API(JSBool)
107154: JS_HasUCProperty(JSContext *cx, JSObject *objArg, const jschar *name, size_t namelen, JSBool *foundp)
107154: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_HasPropertyById(cx, obj, AtomToId(atom), foundp);
 43231: }
 43231: 
 43231: JS_PUBLIC_API(JSBool)
107154: JS_AlreadyHasOwnPropertyById(JSContext *cx, JSObject *objArg, jsid id_, JSBool *foundp)
107154: {
107154:     RootedObject obj(cx, objArg);
 99421:     RootedId id(cx, id_);
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 43228: 
 43228:     if (!obj->isNative()) {
103636:         RootedObject obj2(cx);
103716:         RootedShape prop(cx);
 43228: 
 43229:         if (!LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
 43228:                                 &obj2, &prop)) {
 43228:             return JS_FALSE;
 43228:         }
 43228:         *foundp = (obj == obj2);
 43228:         return JS_TRUE;
 43228:     }
 43228: 
 78194:     *foundp = obj->nativeContains(cx, id);
 43228:     return JS_TRUE;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_AlreadyHasOwnElement(JSContext *cx, JSObject *objArg, uint32_t index, JSBool *foundp)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 75050:     CHECK_REQUEST(cx);
 75050:     jsid id;
 75050:     if (!IndexToId(cx, index, &id))
 75050:         return false;
 75050:     return JS_AlreadyHasOwnPropertyById(cx, obj, id, foundp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_AlreadyHasOwnProperty(JSContext *cx, JSObject *objArg, const char *name, JSBool *foundp)
107154: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
 97828:     return atom && JS_AlreadyHasOwnPropertyById(cx, obj, AtomToId(atom), foundp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_AlreadyHasOwnUCProperty(JSContext *cx, JSObject *objArg, const jschar *name, size_t namelen,
 43228:                            JSBool *foundp)
 43228: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_AlreadyHasOwnPropertyById(cx, obj, AtomToId(atom), foundp);
 43228: }
 43228: 
107783: /* Wrapper functions to create wrappers with no corresponding JSJitInfo from API
107783:  * function arguments.
107783:  */
107783: static JSPropertyOpWrapper
107783: GetterWrapper(JSPropertyOp getter)
107783: {
107783:     JSPropertyOpWrapper ret;
107783:     ret.op = getter;
107783:     ret.info = NULL;
107783:     return ret;
107783: }
107783: 
107783: static JSStrictPropertyOpWrapper
107783: SetterWrapper(JSStrictPropertyOp setter)
107783: {
107783:     JSStrictPropertyOpWrapper ret;
107783:     ret.op = setter;
107783:     ret.info = NULL;
107783:     return ret;
107783: }
107783: 
 43228: static JSBool
 97353: DefinePropertyById(JSContext *cx, HandleObject obj, HandleId id, HandleValue value,
107783:                    const JSPropertyOpWrapper &get, const JSStrictPropertyOpWrapper &set,
107783:                    unsigned attrs, unsigned flags, int tinyid)
107783: {
107783:     PropertyOp getter = get.op;
107783:     StrictPropertyOp setter = set.op;
 84680:     /*
 84680:      * JSPROP_READONLY has no meaning when accessors are involved. Ideally we'd
 84680:      * throw if this happens, but we've accepted it for long enough that it's
 84680:      * not worth trying to make callers change their ways. Just flip it off on
 84680:      * its way through the API layer so that we can enforce this internally.
 84680:      */
 84680:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER))
 84680:         attrs &= ~JSPROP_READONLY;
 84680: 
 94398:     /*
 94398:      * When we use DefineProperty, we need full scriptable Function objects rather
 94398:      * than JSNatives. However, we might be pulling this property descriptor off
 94398:      * of something with JSNative property descriptors. If we are, wrap them in
 94398:      * JS Function objects.
 94398:      */
 94398:     if (attrs & JSPROP_NATIVE_ACCESSORS) {
 94398:         JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
 94398:         attrs &= ~JSPROP_NATIVE_ACCESSORS;
 94398:         if (getter) {
107154:             RootedObject global(cx, (JSObject*) &obj->global());
107783:             JSFunction *getobj = JS_NewFunction(cx, (Native) getter, 0, 0, global, NULL);
 94398:             if (!getobj)
 94398:                 return false;
107783: 
107783:             if (get.info)
107783:                 getobj->setJitInfo(get.info);
107783: 
 94398:             getter = JS_DATA_TO_FUNC_PTR(PropertyOp, getobj);
 94398:             attrs |= JSPROP_GETTER;
 94398:         }
 94398:         if (setter) {
 99364:             // Root just the getter, since the setter is not yet a JSObject.
 99364:             AutoRooterGetterSetter getRoot(cx, JSPROP_GETTER, &getter, NULL);
107154:             RootedObject global(cx, (JSObject*) &obj->global());
107783:             JSFunction *setobj = JS_NewFunction(cx, (Native) setter, 1, 0, global, NULL);
 94398:             if (!setobj)
 94398:                 return false;
107783: 
107783:             if (set.info)
107783:                 setobj->setJitInfo(set.info);
107783: 
 94398:             setter = JS_DATA_TO_FUNC_PTR(StrictPropertyOp, setobj);
 94398:             attrs |= JSPROP_SETTER;
 94398:         }
 94398:     }
 94398: 
 94398: 
103783:     AssertHeapIsIdle(cx);
 43232:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id, value,
 47485:                             (attrs & JSPROP_GETTER)
 47485:                             ? JS_FUNC_TO_DATA_PTR(JSObject *, getter)
 47485:                             : NULL,
 47485:                             (attrs & JSPROP_SETTER)
 47485:                             ? JS_FUNC_TO_DATA_PTR(JSObject *, setter)
 47485:                             : NULL);
 43232: 
103344:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 40430:     if (flags != 0 && obj->isNative()) {
 69855:         return !!DefineNativeProperty(cx, obj, id, value, getter, setter,
 69855:                                       attrs, flags, tinyid);
 20964:     }
108951:     return JSObject::defineGeneric(cx, obj, id, value, getter, setter, attrs);
 20964: }
 20964: 
 43228: JS_PUBLIC_API(JSBool)
111462: JS_DefinePropertyById(JSContext *cx, JSObject *objArg, jsid idArg, jsval valueArg,
 91237:                       JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 43228: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedId id(cx, idArg);
111462:     RootedValue value(cx, valueArg);
107783:     return DefinePropertyById(cx, obj, id, value, GetterWrapper(getter),
107783:                               SetterWrapper(setter), attrs, 0, 0);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_DefineElement(JSContext *cx, JSObject *objArg, uint32_t index, jsval valueArg,
 91237:                  JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 43228: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedValue value(cx, valueArg);
 99364:     AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
103783:     AssertHeapIsIdle(cx);
 97353:     CHECK_REQUEST(cx);
 99421:     RootedId id(cx);
 97353:     if (!IndexToId(cx, index, id.address()))
 75049:         return false;
107783:     return DefinePropertyById(cx, obj, id, value, GetterWrapper(getter),
107783:                               SetterWrapper(setter), attrs, 0, 0);
 43228: }
 43228: 
 20964: static JSBool
107154: DefineProperty(JSContext *cx, JSHandleObject obj, const char *name, const Value &value_,
107783:                const JSPropertyOpWrapper &getter, const JSStrictPropertyOpWrapper &setter,
107783:                unsigned attrs, unsigned flags, int tinyid)
     1: {
 99421:     RootedValue value(cx, value_);
107783:     AutoRooterGetterSetter gsRoot(cx, attrs, const_cast<JSPropertyOp *>(&getter.op),
107783:                                   const_cast<JSStrictPropertyOp *>(&setter.op));
 99421:     RootedId id(cx);
 86437: 
     1:     if (attrs & JSPROP_INDEX) {
 40292:         id = INT_TO_JSID(intptr_t(name));
     1:         attrs &= ~JSPROP_INDEX;
     1:     } else {
107982:         JSAtom *atom = Atomize(cx, name, strlen(name));
     1:         if (!atom)
     1:             return JS_FALSE;
 97828:         id = AtomToId(atom);
     1:     }
 75402: 
 43229:     return DefinePropertyById(cx, obj, id, value, getter, setter, attrs, flags, tinyid);
     1: }
     1: 
 43228: JS_PUBLIC_API(JSBool)
111462: JS_DefineProperty(JSContext *cx, JSObject *objArg, const char *name, jsval valueArg,
 91237:                   PropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 78614: {
107154:     RootedObject obj(cx, objArg);
111462:     RootedValue value(cx, valueArg);
107783:     return DefineProperty(cx, obj, name, value, GetterWrapper(getter),
107783:                           SetterWrapper(setter), attrs, 0, 0);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_DefinePropertyWithTinyId(JSContext *cx, JSObject *objArg, const char *name, int8_t tinyid,
111462:                             jsval valueArg, PropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 78614: {
107154:     RootedObject obj(cx, objArg);
111462:     RootedValue value(cx, valueArg);
107783:     return DefineProperty(cx, obj, name, value, GetterWrapper(getter),
107783:                           SetterWrapper(setter), attrs, Shape::HAS_SHORTID, tinyid);
 43228: }
     1: 
     1: static JSBool
107154: DefineUCProperty(JSContext *cx, JSHandleObject obj, const jschar *name, size_t namelen,
 97353:                  const Value &value_, PropertyOp getter, StrictPropertyOp setter, unsigned attrs,
 91237:                  unsigned flags, int tinyid)
     1: {
 99421:     RootedValue value(cx, value_);
 99364:     AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
107982:     JSAtom *atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97353:     if (!atom)
 97353:         return false;
 99421:     RootedId id(cx, AtomToId(atom));
107783:     return DefinePropertyById(cx, obj, id, value, GetterWrapper(getter),
107783:                               SetterWrapper(setter), attrs, flags, tinyid);
     1: }
     1: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_DefineUCProperty(JSContext *cx, JSObject *objArg, const jschar *name, size_t namelen,
111462:                     jsval valueArg, JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 43228: {
107154:     RootedObject obj(cx, objArg);
111462:     RootedValue value(cx, valueArg);
 78614:     return DefineUCProperty(cx, obj, name, namelen, value, getter, setter, attrs, 0, 0);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_DefineUCPropertyWithTinyId(JSContext *cx, JSObject *objArg, const jschar *name, size_t namelen,
111462:                               int8_t tinyid, jsval valueArg,
 91237:                               JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 43228: {
107154:     RootedObject obj(cx, objArg);
111462:     RootedValue value(cx, valueArg);
 78614:     return DefineUCProperty(cx, obj, name, namelen, value, getter, setter, attrs,
 78614:                             Shape::HAS_SHORTID, tinyid);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_DefineOwnProperty(JSContext *cx, JSObject *objArg, jsid idArg, jsval descriptor, JSBool *bp)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedId id(cx, idArg);
107154:     AssertHeapIsIdle(cx);
107154:     CHECK_REQUEST(cx);
107154:     assertSameCompartment(cx, obj, id, descriptor);
107154: 
102586:     return js_DefineOwnProperty(cx, obj, id, descriptor, bp);
 43228: }
 43228: 
     1: JS_PUBLIC_API(JSObject *)
107154: JS_DefineObject(JSContext *cx, JSObject *objArg, const char *name, JSClass *jsclasp,
107154:                 JSObject *protoArg, unsigned attrs)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedObject proto(cx, protoArg);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, proto);
 50450: 
 48470:     Class *clasp = Valueify(jsclasp);
     1:     if (!clasp)
 77817:         clasp = &ObjectClass;    /* default class is Object */
 50450: 
107557:     RootedObject nobj(cx, NewObjectWithClassProto(cx, clasp, proto, obj));
     1:     if (!nobj)
     1:         return NULL;
 50450: 
107783:     if (!DefineProperty(cx, obj, name, ObjectValue(*nobj), GetterWrapper(NULL),
107783:                         SetterWrapper(NULL), attrs, 0, 0))
107783:     {
     1:         return NULL;
107783:     }
 50450: 
     1:     return nobj;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_DefineConstDoubles(JSContext *cx, JSObject *objArg, JSConstDoubleSpec *cds)
107154: {
107154:     RootedObject obj(cx, objArg);
     1:     JSBool ok;
 91237:     unsigned attrs;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
107783:     JSPropertyOpWrapper noget = GetterWrapper(NULL);
107783:     JSStrictPropertyOpWrapper noset = SetterWrapper(NULL);
     1:     for (ok = JS_TRUE; cds->name; cds++) {
 48470:         Value value = DoubleValue(cds->dval);
 19712:         attrs = cds->flags;
 19712:         if (!attrs)
 19712:             attrs = JSPROP_READONLY | JSPROP_PERMANENT;
107783:         ok = DefineProperty(cx, obj, cds->name, value, noget, noset, attrs, 0, 0);
     1:         if (!ok)
     1:             break;
     1:     }
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_DefineProperties(JSContext *cx, JSObject *objArg, JSPropertySpec *ps)
107154: {
107154:     RootedObject obj(cx, objArg);
     1:     JSBool ok;
 43232:     for (ok = true; ps->name; ps++) {
 78614:         ok = DefineProperty(cx, obj, ps->name, UndefinedValue(), ps->getter, ps->setter,
 52503:                             ps->flags, Shape::HAS_SHORTID, ps->tinyid);
     1:         if (!ok)
     1:             break;
     1:     }
     1:     return ok;
     1: }
     1: 
     1: static JSBool
103320: GetPropertyDescriptorById(JSContext *cx, HandleObject obj, HandleId id, unsigned flags,
 48470:                           JSBool own, PropertyDescriptor *desc)
     1: {
103320:     RootedObject obj2(cx);
103716:     RootedShape shape(cx);
103716: 
103716:     if (!LookupPropertyById(cx, obj, id, flags, &obj2, &shape))
     1:         return JS_FALSE;
 26022: 
103716:     if (!shape || (own && obj != obj2)) {
 26022:         desc->obj = NULL;
 26022:         desc->attrs = 0;
 26022:         desc->getter = NULL;
 26022:         desc->setter = NULL;
 48470:         desc->value.setUndefined();
     1:         return JS_TRUE;
     1:     }
     1: 
 26022:     desc->obj = obj2;
 40430:     if (obj2->isNative()) {
 52503:         desc->attrs = shape->attributes();
 52503:         desc->getter = shape->getter();
 52503:         desc->setter = shape->setter();
 83221:         if (shape->hasSlot())
 83221:             desc->value = obj2->nativeGetSlot(shape->slot());
 48470:         else
 48470:             desc->value.setUndefined();
 52503:     } else {
 52503:         if (obj2->isProxy()) {
 42733:             JSAutoResolveFlags rf(cx, flags);
 42733:             return own
 79386:                    ? Proxy::getOwnPropertyDescriptor(cx, obj2, id, false, desc)
 79386:                    : Proxy::getPropertyDescriptor(cx, obj2, id, false, desc);
 52503:         }
108951:         if (!JSObject::getGenericAttributes(cx, obj2, id, &desc->attrs))
 43290:             return false;
 26022:         desc->getter = NULL;
 26022:         desc->setter = NULL;
 48470:         desc->value.setUndefined();
 26022:     }
 43290:     return true;
     1: }
     1: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_GetPropertyDescriptorById(JSContext *cx, JSObject *objArg, jsid idArg, unsigned flags,
105533:                              JSPropertyDescriptor *desc_)
 43228: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedId id(cx, idArg);
105533:     AutoPropertyDescriptorRooter desc(cx);
105533:     if (!GetPropertyDescriptorById(cx, obj, id, flags, JS_FALSE, &desc))
105533:         return false;
105533:     *desc_ = desc;
105533:     return true;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_GetPropertyAttrsGetterAndSetterById(JSContext *cx, JSObject *objArg, jsid idArg,
 91237:                                        unsigned *attrsp, JSBool *foundp,
 62395:                                        JSPropertyOp *getterp, JSStrictPropertyOp *setterp)
 43228: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedId id(cx, idArg);
105533:     AutoPropertyDescriptorRooter desc(cx);
 43233:     if (!GetPropertyDescriptorById(cx, obj, id, JSRESOLVE_QUALIFIED, JS_FALSE, &desc))
 43233:         return false;
 26022: 
 26022:     *attrsp = desc.attrs;
 26022:     *foundp = (desc.obj != NULL);
 26022:     if (getterp)
 78614:         *getterp = desc.getter;
 26022:     if (setterp)
 78614:         *setterp = desc.setter;
 43233:     return true;
 24145: }
 24145: 
 24145: JS_PUBLIC_API(JSBool)
107154: JS_GetPropertyAttributes(JSContext *cx, JSObject *objArg, const char *name,
 91237:                          unsigned *attrsp, JSBool *foundp)
 43228: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
 97828:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, AtomToId(atom),
 43228:                                                           attrsp, foundp, NULL, NULL);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_GetUCPropertyAttributes(JSContext *cx, JSObject *objArg, const jschar *name, size_t namelen,
 91237:                            unsigned *attrsp, JSBool *foundp)
 43228: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, AtomToId(atom),
 43228:                                                           attrsp, foundp, NULL, NULL);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_GetPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *objArg, const char *name,
 91237:                                    unsigned *attrsp, JSBool *foundp,
 62395:                                    JSPropertyOp *getterp, JSStrictPropertyOp *setterp)
 43228: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
 97828:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, AtomToId(atom),
 43228:                                                           attrsp, foundp, getterp, setterp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_GetUCPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *objArg,
 43228:                                      const jschar *name, size_t namelen,
 91237:                                      unsigned *attrsp, JSBool *foundp,
 62395:                                      JSPropertyOp *getterp, JSStrictPropertyOp *setterp)
 43228: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, AtomToId(atom),
 43228:                                                           attrsp, foundp, getterp, setterp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_GetOwnPropertyDescriptor(JSContext *cx, JSObject *objArg, jsid idArg, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedId id(cx, idArg);
107154:     AssertHeapIsIdle(cx);
107154:     CHECK_REQUEST(cx);
107154: 
102586:     return GetOwnPropertyDescriptor(cx, obj, id, vp);
 43228: }
 43228: 
 43228: static JSBool
103320: SetPropertyAttributesById(JSContext *cx, HandleObject obj, HandleId id, unsigned attrs, JSBool *foundp)
103320: {
103320:     RootedObject obj2(cx);
103716:     RootedShape shape(cx);
103716: 
103716:     if (!LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &shape))
 43290:         return false;
103716:     if (!shape || obj != obj2) {
 43290:         *foundp = false;
 43290:         return true;
 43290:     }
 43290:     JSBool ok = obj->isNative()
108951:                 ? JSObject::changePropertyAttributes(cx, obj, shape, attrs)
108951:                 : JSObject::setGenericAttributes(cx, obj, id, &attrs);
 43290:     if (ok)
 43290:         *foundp = true;
 43228:     return ok;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_SetPropertyAttributes(JSContext *cx, JSObject *objArg, const char *name,
 91237:                          unsigned attrs, JSBool *foundp)
     1: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
107154:     RootedId id(cx, AtomToId(atom));
102586:     return atom && SetPropertyAttributesById(cx, obj, id, attrs, foundp);
     1: }
     1: 
  7927: JS_PUBLIC_API(JSBool)
107154: JS_SetUCPropertyAttributes(JSContext *cx, JSObject *objArg, const jschar *name, size_t namelen,
 91237:                            unsigned attrs, JSBool *foundp)
 43228: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
107154:     RootedId id(cx, AtomToId(atom));
102586:     return atom && SetPropertyAttributesById(cx, obj, id, attrs, foundp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_GetPropertyById(JSContext *cx, JSObject *objArg, jsid idArg, jsval *vp)
107154: {
107154:     return JS_ForwardGetPropertyTo(cx, objArg, idArg, objArg, vp);
107154: }
107154: 
107154: JS_PUBLIC_API(JSBool)
107154: JS_ForwardGetPropertyTo(JSContext *cx, JSObject *objArg, jsid idArg, JSObject *onBehalfOfArg, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedObject onBehalfOf(cx, onBehalfOfArg);
107154:     RootedId id(cx, idArg);
 98960: 
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 81415:     assertSameCompartment(cx, onBehalfOf);
 43228:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
106862: 
106862:     RootedValue value(cx);
108951:     if (!JSObject::getGeneric(cx, obj, onBehalfOf, id, &value))
106862:         return false;
106862: 
106862:     *vp = value;
106862:     return true;
106862: }
106862: 
106862: JS_PUBLIC_API(JSBool)
107154: JS_GetPropertyByIdDefault(JSContext *cx, JSObject *objArg, jsid idArg, jsval defArg, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedId id(cx, idArg);
107154:     RootedValue def(cx, defArg);
106862: 
106862:     RootedValue value(cx);
106862:     if (!baseops::GetPropertyDefault(cx, obj, id, def, &value))
106862:         return false;
106862: 
106862:     *vp = value;
106862:     return true;
 56211: }
 56211: 
 56211: JS_PUBLIC_API(JSBool)
107154: JS_GetElement(JSContext *cx, JSObject *objArg, uint32_t index, jsval *vp)
107154: {
107154:     return JS_ForwardGetElementTo(cx, objArg, index, objArg, vp);
107154: }
107154: 
107154: JS_PUBLIC_API(JSBool)
107154: JS_ForwardGetElementTo(JSContext *cx, JSObject *objArg, uint32_t index, JSObject *onBehalfOfArg, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedObject onBehalfOf(cx, onBehalfOfArg);
103783:     AssertHeapIsIdle(cx);
 81415:     CHECK_REQUEST(cx);
 81415:     assertSameCompartment(cx, obj);
 81415:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
106862: 
106862:     RootedValue value(cx);
108951:     if (!JSObject::getElement(cx, obj, onBehalfOf, index, &value))
106862:         return false;
106862: 
106862:     *vp = value;
106862:     return true;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_GetElementIfPresent(JSContext *cx, JSObject *objArg, uint32_t index, JSObject *onBehalfOfArg, jsval *vp, JSBool* present)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedObject onBehalfOf(cx, onBehalfOfArg);
103783:     AssertHeapIsIdle(cx);
 81419:     CHECK_REQUEST(cx);
 81419:     assertSameCompartment(cx, obj);
 81419:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
106862: 
106862:     RootedValue value(cx);
 81419:     bool isPresent;
108951:     if (!JSObject::getElementIfPresent(cx, obj, onBehalfOf, index, &value, &isPresent))
 81419:         return false;
106862: 
106862:     *vp = value;
 81419:     *present = isPresent;
 81419:     return true;
 81419: }
 81419: 
 81419: JS_PUBLIC_API(JSBool)
107154: JS_GetProperty(JSContext *cx, JSObject *objArg, const char *name, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
 97828:     return atom && JS_GetPropertyById(cx, obj, AtomToId(atom), vp);
  7927: }
  7927: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_GetPropertyDefault(JSContext *cx, JSObject *objArg, const char *name, jsval def, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
 97828:     return atom && JS_GetPropertyByIdDefault(cx, obj, AtomToId(atom), def, vp);
 56211: }
 56211: 
 56211: JS_PUBLIC_API(JSBool)
107154: JS_GetUCProperty(JSContext *cx, JSObject *objArg, const jschar *name, size_t namelen, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_GetPropertyById(cx, obj, AtomToId(atom), vp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_GetMethodById(JSContext *cx, JSObject *objArg, jsid idArg, JSObject **objp, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedId id(cx, idArg);
 98960: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
106862: 
106862:     RootedValue value(cx);
106862:     if (!GetMethod(cx, obj, id, 0, &value))
     1:         return JS_FALSE;
106862:     *vp = value;
106862: 
 26187:     if (objp)
     1:         *objp = obj;
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_GetMethod(JSContext *cx, JSObject *objArg, const char *name, JSObject **objp, jsval *vp)
     1: {
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
107154:     return atom && JS_GetMethodById(cx, objArg, AtomToId(atom), objp, vp);
107154: }
107154: 
107154: JS_PUBLIC_API(JSBool)
107154: JS_SetPropertyById(JSContext *cx, JSObject *objArg, jsid idArg, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedId id(cx, idArg);
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 43228:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
106862: 
106862:     RootedValue value(cx, *vp);
108951:     if (!JSObject::setGeneric(cx, obj, obj, id, &value, false))
106862:         return false;
106862: 
106862:     *vp = value;
106862:     return true;
103345: }
103345: 
103345: JS_PUBLIC_API(JSBool)
107154: JS_SetElement(JSContext *cx, JSObject *objArg, uint32_t index, jsval *vp)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 98960:     CHECK_REQUEST(cx);
 98960:     assertSameCompartment(cx, obj, *vp);
 81415:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
106862: 
106862:     RootedValue value(cx, *vp);
108951:     if (!JSObject::setElement(cx, obj, obj, index, &value, false))
106862:         return false;
106862: 
106862:     *vp = value;
106862:     return true;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_SetProperty(JSContext *cx, JSObject *objArg, const char *name, jsval *vp)
107154: {
107557:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
107557:     return atom && JS_SetPropertyById(cx, obj, AtomToId(atom), vp);
107154: }
107154: 
107154: JS_PUBLIC_API(JSBool)
107154: JS_SetUCProperty(JSContext *cx, JSObject *objArg, const jschar *name, size_t namelen, jsval *vp)
107154: {
107557:     RootedObject obj(cx, objArg);
107982:     JSAtom *atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
107557:     return atom && JS_SetPropertyById(cx, obj, AtomToId(atom), vp);
107154: }
107154: 
107154: JS_PUBLIC_API(JSBool)
107154: JS_DeletePropertyById2(JSContext *cx, JSObject *objArg, jsid id, jsval *rval)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 43228:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 86790: 
106862:     RootedValue value(cx);
106862: 
102586:     if (JSID_IS_SPECIAL(id)) {
102586:         Rooted<SpecialId> sid(cx, JSID_TO_SPECIALID(id));
108951:         if (!JSObject::deleteSpecial(cx, obj, sid, &value, false))
106862:             return false;
106862:     } else {
108951:         if (!JSObject::deleteByValue(cx, obj, IdToValue(id), &value, false))
106862:             return false;
106862:     }
106862: 
106862:     *rval = value;
106862:     return true;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_DeleteElement2(JSContext *cx, JSObject *objArg, uint32_t index, jsval *rval)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 75053:     CHECK_REQUEST(cx);
 86790:     assertSameCompartment(cx, obj);
 86790:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
106862: 
106862:     RootedValue value(cx);
108951:     if (!JSObject::deleteElement(cx, obj, index, &value, false))
106862:         return false;
106862: 
106862:     *rval = value;
106862:     return true;
 86790: }
 86790: 
 86790: JS_PUBLIC_API(JSBool)
107154: JS_DeleteProperty2(JSContext *cx, JSObject *objArg, const char *name, jsval *rval)
107154: {
107154:     RootedObject obj(cx, objArg);
 86790:     CHECK_REQUEST(cx);
 86790:     assertSameCompartment(cx, obj);
 86790:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 86790: 
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
 86790:     if (!atom)
 75053:         return false;
 86790: 
106862:     RootedValue value(cx);
108951:     if (!JSObject::deleteByValue(cx, obj, StringValue(atom), &value, false))
106862:         return false;
106862: 
106862:     *rval = value;
106862:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_DeleteUCProperty2(JSContext *cx, JSObject *objArg, const jschar *name, size_t namelen, jsval *rval)
107154: {
107154:     RootedObject obj(cx, objArg);
 86790:     CHECK_REQUEST(cx);
 86790:     assertSameCompartment(cx, obj);
 86790:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 86790: 
107982:     JSAtom *atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 86790:     if (!atom)
 86790:         return false;
 86790: 
106862:     RootedValue value(cx);
108951:     if (!JSObject::deleteByValue(cx, obj, StringValue(atom), &value, false))
106862:         return false;
106862: 
106862:     *rval = value;
106862:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_DeletePropertyById(JSContext *cx, JSObject *objArg, jsid idArg)
 43228: {
 43228:     jsval junk;
107154:     return JS_DeletePropertyById2(cx, objArg, idArg, &junk);
107154: }
107154: 
107154: JS_PUBLIC_API(JSBool)
107154: JS_DeleteElement(JSContext *cx, JSObject *objArg, uint32_t index)
     1: {
     1:     jsval junk;
107154:     return JS_DeleteElement2(cx, objArg, index, &junk);
107154: }
107154: 
107154: JS_PUBLIC_API(JSBool)
107154: JS_DeleteProperty(JSContext *cx, JSObject *objArg, const char *name)
 43228: {
 43228:     jsval junk;
107154:     return JS_DeleteProperty2(cx, objArg, name, &junk);
     1: }
     1: 
110475: static Shape *
110475: LastConfigurableShape(JSObject *obj)
110475: {
110475:     for (Shape::Range r(obj->lastProperty()->all()); !r.empty(); r.popFront()) {
110475:         Shape *shape = &r.front();
110475:         if (shape->configurable())
110475:             return shape;
110475:     }
110475:     return NULL;
110475: }
110475: 
     1: JS_PUBLIC_API(void)
110475: JS_ClearNonGlobalObject(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
     1: 
110475:     JS_ASSERT(!obj->isGlobal());
110475: 
110475:     if (!obj->isNative())
110475:         return;
110475: 
110475:     /* Remove all configurable properties from obj. */
110475:     while (Shape *shape = LastConfigurableShape(obj)) {
110475:         if (!obj->removeProperty(cx, shape->propid()))
110475:             return;
110475:     }
110475: 
110475:     /* Set all remaining writable plain data properties to undefined. */
110475:     for (Shape::Range r(obj->lastProperty()->all()); !r.empty(); r.popFront()) {
110475:         Shape *shape = &r.front();
110475:         if (shape->isDataDescriptor() &&
110475:             shape->writable() &&
110475:             shape->hasDefaultSetter() &&
110475:             shape->hasSlot()) {
110475:             obj->nativeSetSlot(shape->slot(), UndefinedValue());
110475:         }
110475:     }
110475: }
110475: 
110475: JS_PUBLIC_API(void)
110475: JS_SetAllNonReservedSlotsToUndefined(JSContext *cx, JSObject *objArg)
110475: {
110475:     RootedObject obj(cx, objArg);
110475:     AssertHeapIsIdle(cx);
110475:     CHECK_REQUEST(cx);
110475:     assertSameCompartment(cx, obj);
110475: 
110475:     if (!obj->isNative())
110475:         return;
110475: 
110475:     Class *clasp = obj->getClass();
110475:     unsigned numReserved = JSCLASS_RESERVED_SLOTS(clasp);
110475:     unsigned numSlots = obj->slotSpan();
110475:     for (unsigned i = numReserved; i < numSlots; i++)
110475:         obj->setSlot(i, UndefinedValue());
     1: }
     1: 
     1: JS_PUBLIC_API(JSIdArray *)
107154: JS_Enumerate(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 42641:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 43290: 
 48470:     AutoIdVector props(cx);
     1:     JSIdArray *ida;
 54562:     if (!GetPropertyNames(cx, obj, JSITER_OWNONLY, &props) || !VectorToIdArray(cx, props, &ida))
 68902:         return NULL;
 42641:     return ida;
     1: }
     1: 
     1: /*
     1:  * XXX reverse iterator for properties, unreverse and meld with jsinterp.c's
     1:  *     prop_iterator_class somehow...
 31501:  * + preserve the obj->enumerate API while optimizing the native object case
 52503:  * + native case here uses a Shape *, but that iterates in reverse!
     1:  * + so we make non-native match, by reverse-iterating after JS_Enumerating
     1:  */
 84755: const uint32_t JSSLOT_ITER_INDEX = 0;
     1: 
     1: static void
115877: prop_iter_finalize(FreeOp *fop, RawObject obj)
     1: {
 31452:     void *pdata = obj->getPrivate();
 31452:     if (!pdata)
     1:         return;
     1: 
 55746:     if (obj->getSlot(JSSLOT_ITER_INDEX).toInt32() >= 0) {
     1:         /* Non-native case: destroy the ida enumerated when obj was created. */
 31452:         JSIdArray *ida = (JSIdArray *) pdata;
 94740:         DestroyIdArray(fop, ida);
     1:     }
     1: }
     1: 
   583: static void
115876: prop_iter_trace(JSTracer *trc, RawObject obj)
     1: {
 31452:     void *pdata = obj->getPrivate();
 31452:     if (!pdata)
 31452:         return;
 31452: 
 55746:     if (obj->getSlot(JSSLOT_ITER_INDEX).toInt32() < 0) {
 82129:         /*
 82129:          * Native case: just mark the next property to visit. We don't need a
 82129:          * barrier here because the pointer is updated via setPrivate, which
 82129:          * always takes a barrier.
 82129:          */
 91557:         Shape *tmp = (Shape *)pdata;
 91557:         MarkShapeUnbarriered(trc, &tmp, "prop iter shape");
 91849:         obj->setPrivateUnbarriered(tmp);
     1:     } else {
     1:         /* Non-native case: mark each id in the JSIdArray private. */
 31452:         JSIdArray *ida = (JSIdArray *) pdata;
 90129:         MarkIdRange(trc, ida->length, ida->vector, "prop iter");
 48470:     }
 48470: }
 48470: 
 48470: static Class prop_iter_class = {
     1:     "PropertyIterator",
 92217:     JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS | JSCLASS_HAS_RESERVED_SLOTS(1),
 78614:     JS_PropertyStub,         /* addProperty */
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 78614:     JS_ConvertStub,
 48622:     prop_iter_finalize,
 48622:     NULL,           /* checkAccess */
 48622:     NULL,           /* call        */
 48622:     NULL,           /* construct   */
 48622:     NULL,           /* hasInstance */
 64218:     prop_iter_trace
     1: };
     1: 
     1: JS_PUBLIC_API(JSObject *)
107154: JS_NewPropertyIterator(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
109329: 
109329:     RootedObject iterobj(cx, NewObjectWithClassProto(cx, &prop_iter_class, NULL, obj));
     1:     if (!iterobj)
     1:         return NULL;
     1: 
109329:     int index;
 40430:     if (obj->isNative()) {
 52503:         /* Native case: start with the last property in obj. */
109329:         iterobj->setPrivateGCThing(obj->lastProperty());
     1:         index = -1;
     1:     } else {
109329:         /* Non-native case: enumerate a JSIdArray and keep it via private. */
109329:         JSIdArray *ida = JS_Enumerate(cx, obj);
     1:         if (!ida)
 31452:             return NULL;
109329:         iterobj->setPrivate((void *)ida);
     1:         index = ida->length;
     1:     }
     1: 
     1:     /* iterobj cannot escape to other threads here. */
 74457:     iterobj->setSlot(JSSLOT_ITER_INDEX, Int32Value(index));
     1:     return iterobj;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_NextProperty(JSContext *cx, JSObject *iterobjArg, jsid *idp)
107154: {
107154:     RootedObject iterobj(cx, iterobjArg);
111593:     AutoAssertNoGC nogc;
 91450:     int32_t i;
103639:     Shape *shape;
     1:     JSIdArray *ida;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, iterobj);
 55746:     i = iterobj->getSlot(JSSLOT_ITER_INDEX).toInt32();
     1:     if (i < 0) {
     1:         /* Native case: private data is a property tree node pointer. */
 58687:         JS_ASSERT(iterobj->getParent()->isNative());
 52503:         shape = (Shape *) iterobj->getPrivate();
     1: 
 74907:         while (shape->previous() && !shape->enumerable())
 52503:             shape = shape->previous();
 52503: 
 52503:         if (!shape->previous()) {
 83221:             JS_ASSERT(shape->isEmptyShape());
 48470:             *idp = JSID_VOID;
     1:         } else {
109329:             iterobj->setPrivateGCThing(const_cast<Shape *>(shape->previous().get()));
 83221:             *idp = shape->propid();
     1:         }
     1:     } else {
     1:         /* Non-native case: use the ida enumerated when iterobj was created. */
 32684:         ida = (JSIdArray *) iterobj->getPrivate();
     1:         JS_ASSERT(i <= ida->length);
 55479:         STATIC_ASSUME(i <= ida->length);
     1:         if (i == 0) {
 48470:             *idp = JSID_VOID;
     1:         } else {
     1:             *idp = ida->vector[--i];
 48470:             iterobj->setSlot(JSSLOT_ITER_INDEX, Int32Value(i));
     1:         }
     1:     }
114424:     return true;
     1: }
     1: 
105837: JS_PUBLIC_API(JSBool)
105837: JS_ArrayIterator(JSContext *cx, unsigned argc, jsval *vp)
105837: {
105837:     CallArgs args = CallArgsFromVp(argc, vp);
105840:     Rooted<Value> target(cx, args.thisv());
107154:     AssertHeapIsIdle(cx);
107154:     assertSameCompartment(cx, target);
107154:     CHECK_REQUEST(cx);
107154: 
105840:     JSObject *iterobj = ElementIteratorObject::create(cx, target);
105837:     if (!iterobj)
105837:         return false;
105837:     vp->setObject(*iterobj);
105837:     return true;
 89625: }
 89625: 
 89826: JS_PUBLIC_API(jsval)
107154: JS_GetReservedSlot(RawObject obj, uint32_t index)
 89826: {
 90279:     return obj->getReservedSlot(index);
 89826: }
 89826: 
 89826: JS_PUBLIC_API(void)
111462: JS_SetReservedSlot(RawObject obj, uint32_t index, RawValue value)
111462: {
111462:     obj->setReservedSlot(index, value);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSObject *)
 91450: JS_NewArrayObject(JSContext *cx, int length, jsval *vector)
 43228: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 91612: 
 91688:     assertSameCompartment(cx, JSValueArray(vector, vector ? (uint32_t)length : 0));
 91688:     return NewDenseCopiedArray(cx, (uint32_t)length, vector);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_IsArrayObject(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
 47485:     assertSameCompartment(cx, obj);
 79390:     return ObjectClassIs(*obj, ESClass_Array, cx);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_GetArrayLength(JSContext *cx, JSObject *objArg, uint32_t *lengthp)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
108951:     return GetLengthProperty(cx, obj, lengthp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
106505: JS_SetArrayLength(JSContext *cx, JSObject *objArg, uint32_t length)
106505: {
106505:     RootedObject obj(cx, objArg);
107154:     AssertHeapIsIdle(cx);
107154:     CHECK_REQUEST(cx);
107154:     assertSameCompartment(cx, obj);
108951:     return SetLengthProperty(cx, obj, length);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_CheckAccess(JSContext *cx, JSObject *objArg, jsid idArg, JSAccessMode mode,
 91237:                jsval *vp, unsigned *attrsp)
     1: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedId id(cx, idArg);
111462:     RootedValue value(cx, *vp);
 98960: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
111462:     JSBool status = CheckAccess(cx, obj, id, mode, &value, attrsp);
111462:     *vp = value;
111462:     return status;
     1: }
     1: 
 91900: JS_PUBLIC_API(void)
 91900: JS_HoldPrincipals(JSPrincipals *principals)
 91900: {
104326:     JS_ATOMIC_INCREMENT(&principals->refcount);
 91900: }
 91900: 
 91900: JS_PUBLIC_API(void)
 91900: JS_DropPrincipals(JSRuntime *rt, JSPrincipals *principals)
     1: {
104326:     int rc = JS_ATOMIC_DECREMENT(&principals->refcount);
104326:     if (rc == 0)
 91900:         rt->destroyPrincipals(principals);
 91900: }
 91900: 
 91900: JS_PUBLIC_API(void)
 91900: JS_SetSecurityCallbacks(JSRuntime *rt, const JSSecurityCallbacks *scb)
 91900: {
 91900:     JS_ASSERT(scb != &NullSecurityCallbacks);
 91900:     rt->securityCallbacks = scb ? scb : &NullSecurityCallbacks;
 91900: }
 91900: 
 91900: JS_PUBLIC_API(const JSSecurityCallbacks *)
 91900: JS_GetSecurityCallbacks(JSRuntime *rt)
 91900: {
 91900:     return (rt->securityCallbacks != &NullSecurityCallbacks) ? rt->securityCallbacks : NULL;
     1: }
     1: 
 73495: JS_PUBLIC_API(void)
 73495: JS_SetTrustedPrincipals(JSRuntime *rt, JSPrincipals *prin)
 73495: {
 73495:     rt->setTrustedPrincipals(prin);
 73495: }
 73495: 
 91900: extern JS_PUBLIC_API(void)
 91900: JS_InitDestroyPrincipalsCallback(JSRuntime *rt, JSDestroyPrincipalsOp destroyPrincipals)
 91900: {
 91900:     JS_ASSERT(destroyPrincipals);
 91900:     JS_ASSERT(!rt->destroyPrincipals);
 91900:     rt->destroyPrincipals = destroyPrincipals;
 91900: }
 91900: 
     1: JS_PUBLIC_API(JSFunction *)
 91237: JS_NewFunction(JSContext *cx, JSNative native, unsigned nargs, unsigned flags,
107154:                JSObject *parentArg, const char *name)
107154: {
107154:     RootedObject parent(cx, parentArg);
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, parent);
     1: 
116203:     RootedAtom atom(cx);
116203:     if (name) {
107982:         atom = Atomize(cx, name, strlen(name));
     1:         if (!atom)
     1:             return NULL;
     1:     }
 86437: 
116203:     return js_NewFunction(cx, NullPtr(), native, nargs, flags, parent, atom);
     1: }
     1: 
 57721: JS_PUBLIC_API(JSFunction *)
107154: JS_NewFunctionById(JSContext *cx, JSNative native, unsigned nargs, unsigned flags, JSObject *parentArg,
 57721:                    jsid id)
 57721: {
107154:     RootedObject parent(cx, parentArg);
 57721:     JS_ASSERT(JSID_IS_STRING(id));
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 57721:     CHECK_REQUEST(cx);
 57721:     assertSameCompartment(cx, parent);
 57721: 
116203:     RootedAtom atom(cx, JSID_TO_ATOM(id));
116203:     return js_NewFunction(cx, NullPtr(), native, nargs, flags, parent, atom);
 57721: }
 57721: 
     1: JS_PUBLIC_API(JSObject *)
107154: JS_CloneFunctionObject(JSContext *cx, JSObject *funobjArg, JSRawObject parentArg)
107154: {
107154:     RootedObject funobj(cx, funobjArg);
107154:     RootedObject parent(cx, parentArg);
107154:     AssertHeapIsIdle(cx);
107154:     CHECK_REQUEST(cx);
107154:     assertSameCompartment(cx, parent);  // XXX no funobj for now
 95355: 
 38604:     if (!parent)
109255:         parent = cx->global();
 38604: 
 77817:     if (!funobj->isFunction()) {
103274:         ReportIsNotFunction(cx, ObjectValue(*funobj));
 27012:         return NULL;
 27012:     }
 27012: 
104378:     /*
108585:      * If a function was compiled to be lexically nested inside some other
108585:      * script, we cannot clone it without breaking the compiler's assumptions.
104378:      */
 99421:     RootedFunction fun(cx, funobj->toFunction());
108585:     if (fun->isInterpreted() && (fun->script()->enclosingStaticScope() ||
108585:         (fun->script()->compileAndGo && !parent->isGlobal())))
108585:     {
108585:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_CLONE_FUNOBJ_SCOPE);
 77343:         return NULL;
 77343:     }
 77343: 
 98316:     if (fun->isBoundFunction()) {
108585:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_CLONE_OBJECT);
 98316:         return NULL;
 98316:     }
 93245: 
 83258:     return CloneFunctionObject(cx, fun, parent, fun->getAllocKind());
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
     1: JS_GetFunctionObject(JSFunction *fun)
     1: {
 76812:     return fun;
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_GetFunctionId(JSFunction *fun)
     1: {
109108:     return fun->atom();
     1: }
     1: 
109112: JS_PUBLIC_API(JSString *)
109112: JS_GetFunctionDisplayId(JSFunction *fun)
109112: {
109112:     return fun->displayAtom();
109112: }
109112: 
 91237: JS_PUBLIC_API(unsigned)
     1: JS_GetFunctionFlags(JSFunction *fun)
     1: {
     1:     return fun->flags;
     1: }
     1: 
 84755: JS_PUBLIC_API(uint16_t)
     1: JS_GetFunctionArity(JSFunction *fun)
     1: {
     1:     return fun->nargs;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_ObjectIsFunction(JSContext *cx, RawObject obj)
     1: {
 77817:     return obj->isFunction();
     1: }
     1: 
 60563: JS_PUBLIC_API(JSBool)
107154: JS_ObjectIsCallable(JSContext *cx, RawObject obj)
 60563: {
 60563:     return obj->isCallable();
 60563: }
 60563: 
 80059: JS_PUBLIC_API(JSBool)
107154: JS_IsNativeFunction(JSRawObject funobj, JSNative call)
 80059: {
 80059:     if (!funobj->isFunction())
 80059:         return false;
 83252:     JSFunction *fun = funobj->toFunction();
 80059:     return fun->isNative() && fun->native() == call;
 80059: }
 80059: 
 94831: JS_PUBLIC_API(JSObject*)
107154: JS_BindCallable(JSContext *cx, JSObject *targetArg, JSRawObject newThis)
107154: {
107154:     RootedObject target(cx, targetArg);
 99421:     RootedValue thisArg(cx, ObjectValue(*newThis));
 97353:     return js_fun_bind(cx, target, thisArg, NULL, 0);
 94831: }
 94831: 
 80157: JSBool
 91237: js_generic_native_method_dispatcher(JSContext *cx, unsigned argc, Value *vp)
 48470: {
108174:     CallArgs args = CallArgsFromVp(argc, vp);
108174: 
 83258:     JSFunctionSpec *fs = (JSFunctionSpec *)
 83301:         vp->toObject().toFunction()->getExtendedSlot(0).toPrivate();
 53557:     JS_ASSERT((fs->flags & JSFUN_GENERIC_NATIVE) != 0);
  4127: 
 41988:     if (argc < 1) {
108174:         js_ReportMissingArg(cx, args.calleev(), 0);
 41988:         return JS_FALSE;
 41988:     }
 41988: 
  4127:     /*
  4127:      * Copy all actual (argc) arguments down over our |this| parameter, vp[1],
  4127:      * which is almost always the class constructor object, e.g. Array.  Then
  4127:      * call the corresponding prototype native method with our first argument
  4127:      * passed as |this|.
  4127:      */
  4127:     memmove(vp + 1, vp + 2, argc * sizeof(jsval));
  4127: 
 25712:     /* Clear the last parameter in case too few arguments were passed. */
 48470:     vp[2 + --argc].setUndefined();
  4127: 
107788:     return fs->call.op(cx, argc, vp);
  4127: }
  4127: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_DefineFunctions(JSContext *cx, JSObject *objArg, JSFunctionSpec *fs)
107154: {
107154:     RootedObject obj(cx, objArg);
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 91237:     unsigned flags;
 99421:     RootedObject ctor(cx);
     1:     JSFunction *fun;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
     1:     for (; fs->name; fs++) {
     1:         flags = fs->flags;
     1: 
107982:         RootedAtom atom(cx, Atomize(cx, fs->name, strlen(fs->name)));
 77343:         if (!atom)
 77343:             return JS_FALSE;
 77343: 
102586:         Rooted<jsid> id(cx, AtomToId(atom));
102586: 
     1:         /*
     1:          * Define a generic arity N+1 static method for the arity N prototype
     1:          * method if flags contains JSFUN_GENERIC_NATIVE.
     1:          */
     1:         if (flags & JSFUN_GENERIC_NATIVE) {
     1:             if (!ctor) {
     1:                 ctor = JS_GetConstructor(cx, obj);
     1:                 if (!ctor)
     1:                     return JS_FALSE;
     1:             }
     1: 
     1:             flags &= ~JSFUN_GENERIC_NATIVE;
102586:             fun = js_DefineFunction(cx, ctor, id, js_generic_native_method_dispatcher,
108585:                                     fs->nargs + 1, flags, NULL, JSFunction::ExtendedFinalizeKind);
     1:             if (!fun)
     1:                 return JS_FALSE;
     1: 
     1:             /*
     1:              * As jsapi.h notes, fs must point to storage that lives as long
     1:              * as fun->object lives.
     1:              */
 83301:             fun->setExtendedSlot(0, PrivateValue(fs));
     1:         }
     1: 
108585:         fun = js_DefineFunction(cx, obj, id, fs->call.op, fs->nargs, flags, fs->selfHostedName);
     1:         if (!fun)
     1:             return JS_FALSE;
107788:         if (fs->call.info)
107788:             fun->setJitInfo(fs->call.info);
     1:     }
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
107154: JS_DefineFunction(JSContext *cx, JSObject *objArg, const char *name, JSNative call,
 91237:                   unsigned nargs, unsigned attrs)
     1: {
107154:     RootedObject obj(cx, objArg);
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
 57721:     if (!atom)
 57721:         return NULL;
102586:     Rooted<jsid> id(cx, AtomToId(atom));
102586:     return js_DefineFunction(cx, obj, id, call, nargs, attrs);
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
107154: JS_DefineUCFunction(JSContext *cx, JSObject *objArg,
     1:                     const jschar *name, size_t namelen, JSNative call,
 91237:                     unsigned nargs, unsigned attrs)
     1: {
107154:     RootedObject obj(cx, objArg);
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 40340:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
107982:     JSAtom *atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 57721:     if (!atom)
 57721:         return NULL;
102586:     Rooted<jsid> id(cx, AtomToId(atom));
102586:     return js_DefineFunction(cx, obj, id, call, nargs, attrs);
 57721: }
 57721: 
 57721: extern JS_PUBLIC_API(JSFunction *)
107154: JS_DefineFunctionById(JSContext *cx, JSObject *objArg, jsid id_, JSNative call,
 91237:                       unsigned nargs, unsigned attrs)
 57721: {
107154:     RootedObject obj(cx, objArg);
 99421:     RootedId id(cx, id_);
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 57721:     CHECK_REQUEST(cx);
 57721:     assertSameCompartment(cx, obj);
 98960:     return js_DefineFunction(cx, obj, id, call, nargs, attrs);
 43235: }
 43235: 
 77180: struct AutoLastFrameCheck {
 77180:     AutoLastFrameCheck(JSContext *cx JS_GUARD_OBJECT_NOTIFIER_PARAM)
 77180:       : cx(cx) {
 77180:         JS_ASSERT(cx);
 77180:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 77180:     }
 77180: 
 77180:     ~AutoLastFrameCheck() {
 77180:         if (cx->isExceptionPending() &&
 77180:             !JS_IsRunning(cx) &&
 77180:             !cx->hasRunOption(JSOPTION_DONT_REPORT_UNCAUGHT)) {
 43235:             js_ReportUncaughtException(cx);
 43235:         }
 77180:     }
 77180: 
 77180:   private:
 77180:     JSContext       *cx;
 77180:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 77180: };
 43235: 
106508: /* Use the fastest available getc. */
106508: #if defined(HAVE_GETC_UNLOCKED)
106508: # define fast_getc getc_unlocked
106508: #elif defined(HAVE__GETC_NOLOCK)
106508: # define fast_getc _getc_nolock
106508: #else
106508: # define fast_getc getc
106508: #endif
106508: 
106508: typedef Vector<char, 8, TempAllocPolicy> FileContents;
106508: 
106508: static bool
106508: ReadCompleteFile(JSContext *cx, FILE *fp, FileContents &buffer)
106508: {
106508:     /* Get the complete length of the file, if possible. */
106508:     struct stat st;
106508:     int ok = fstat(fileno(fp), &st);
106508:     if (ok != 0)
106508:         return false;
106508:     if (st.st_size > 0) {
106508:         if (!buffer.reserve(st.st_size))
106508:             return false;
106508:     }
106508: 
106508:     // Read in the whole file. Note that we can't assume the data's length
106508:     // is actually st.st_size, because 1) some files lie about their size
106508:     // (/dev/zero and /dev/random), and 2) reading files in text mode on
106508:     // Windows collapses "\r\n" pairs to single \n characters.
106508:     for (;;) {
106508:         int c = fast_getc(fp);
106508:         if (c == EOF)
106508:             break;
106508:         if (!buffer.append(c))
106508:             return false;
106508:     }
106508: 
106508:     return true;
106508: }
106508: 
107046: class AutoFile
107046: {
107046:     FILE *fp_;
107046:   public:
107046:     AutoFile()
107046:       : fp_(NULL)
107046:     {}
107046:     ~AutoFile()
107046:     {
107046:         if (fp_ && fp_ != stdin)
107046:             fclose(fp_);
107046:     }
107046:     FILE *fp() const { return fp_; }
107046:     bool open(JSContext *cx, const char *filename);
107046:     bool readAll(JSContext *cx, FileContents &buffer)
107046:     {
107046:         JS_ASSERT(fp_);
107046:         return ReadCompleteFile(cx, fp_, buffer);
107046:     }
107046: };
107046: 
107039: /*
107039:  * Open a source file for reading. Supports "-" and NULL to mean stdin. The
107039:  * return value must be fclosed unless it is stdin.
107039:  */
107046: bool
107046: AutoFile::open(JSContext *cx, const char *filename)
107046: {
107039:     if (!filename || strcmp(filename, "-") == 0) {
107046:         fp_ = stdin;
107039:     } else {
107046:         fp_ = fopen(filename, "r");
107046:         if (!fp_) {
107039:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_OPEN,
107039:                                  filename, "No such file or directory");
107046:             return false;
107046:         }
107046:     }
107046:     return true;
107039: }
107039: 
107039: 
106508: JS::CompileOptions::CompileOptions(JSContext *cx)
106508:     : principals(NULL),
106508:       originPrincipals(NULL),
106508:       version(cx->findVersion()),
106508:       versionSet(false),
106508:       utf8(false),
106508:       filename(NULL),
106508:       lineno(1),
106508:       compileAndGo(cx->hasRunOption(JSOPTION_COMPILE_N_GO)),
107038:       noScriptRval(cx->hasRunOption(JSOPTION_NO_SCRIPT_RVAL)),
108585:       selfHostingMode(false),
107687:       sourcePolicy(SAVE_SOURCE)
106508: {
106508: }
106508: 
106508: JSScript *
106508: JS::Compile(JSContext *cx, HandleObject obj, CompileOptions options,
106508:             const jschar *chars, size_t length)
106508: {
106508:     Maybe<AutoVersionAPI> mava;
106508:     if (options.versionSet) {
106508:         mava.construct(cx, options.version);
106508:         // AutoVersionAPI propagates some compilation flags through.
106508:         options.version = mava.ref().version();
106508:     }
106508: 
 61450:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 61450:     CHECK_REQUEST(cx);
114338:     assertSameCompartment(cx, obj);
114338:     JS_ASSERT_IF(options.principals, cx->compartment->principals == options.principals);
 77180:     AutoLastFrameCheck lfc(cx);
 61450: 
106508:     return frontend::CompileScript(cx, obj, NULL, options, chars, length);
106508: }
106508: 
106508: JSScript *
106508: JS::Compile(JSContext *cx, HandleObject obj, CompileOptions options,
106508:             const char *bytes, size_t length)
106508: {
106508:     jschar *chars;
106508:     if (options.utf8)
106508:         chars = InflateString(cx, bytes, &length, CESU8Encoding);
106508:     else
106508:         chars = InflateString(cx, bytes, &length);
106508:     if (!chars)
106508:         return NULL;
106508: 
106508:     JSScript *script = Compile(cx, obj, options, chars, length);
110933:     js_free(chars);
106508:     return script;
106508: }
106508: 
106508: JSScript *
106508: JS::Compile(JSContext *cx, HandleObject obj, CompileOptions options, FILE *fp)
106508: {
106508:     FileContents buffer(cx);
106508:     if (!ReadCompleteFile(cx, fp, buffer))
106508:         return NULL;
106508: 
106508:     JSScript *script = Compile(cx, obj, options, buffer.begin(), buffer.length());
106508:     return script;
106508: }
106508: 
106508: JSScript *
106508: JS::Compile(JSContext *cx, HandleObject obj, CompileOptions options, const char *filename)
106508: {
107046:     AutoFile file;
107046:     if (!file.open(cx, filename))
106508:         return NULL;
107039:     options = options.setFileAndLine(filename, 1);
107046:     JSScript *script = Compile(cx, obj, options, file.fp());
106508:     return script;
 78492: }
 78492: 
 78492: extern JS_PUBLIC_API(JSScript *)
107154: JS_CompileUCScriptForPrincipalsVersion(JSContext *cx, JSObject *objArg,
 53848:                                        JSPrincipals *principals,
 53848:                                        const jschar *chars, size_t length,
 91237:                                        const char *filename, unsigned lineno,
 53848:                                        JSVersion version)
 53848: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setFileAndLine(filename, lineno)
106508:            .setVersion(version);
106508: 
106508:     return Compile(cx, obj, options, chars, length);
 90856: }
 90856: 
 90856: extern JS_PUBLIC_API(JSScript *)
107154: JS_CompileUCScriptForPrincipalsVersionOrigin(JSContext *cx, JSObject *objArg,
 90856:                                              JSPrincipals *principals,
 90856:                                              JSPrincipals *originPrincipals,
 90856:                                              const jschar *chars, size_t length,
 91237:                                              const char *filename, unsigned lineno,
 90856:                                              JSVersion version)
 90856: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setOriginPrincipals(originPrincipals)
106508:            .setFileAndLine(filename, lineno)
106508:            .setVersion(version);
106508: 
106508:     return Compile(cx, obj, options, chars, length);
 53848: }
 53848: 
 78492: JS_PUBLIC_API(JSScript *)
107154: JS_CompileUCScriptForPrincipals(JSContext *cx, JSObject *objArg, JSPrincipals *principals,
 43228:                                 const jschar *chars, size_t length,
 91237:                                 const char *filename, unsigned lineno)
     1: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setFileAndLine(filename, lineno);
106508: 
106508:     return Compile(cx, obj, options, chars, length);
     1: }
     1: 
 78492: JS_PUBLIC_API(JSScript *)
107154: JS_CompileUCScript(JSContext *cx, JSObject *objArg, const jschar *chars, size_t length,
 91237:                    const char *filename, unsigned lineno)
 43228: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setFileAndLine(filename, lineno);
106508: 
106508:     return Compile(cx, obj, options, chars, length);
 43228: }
 43228: 
 78492: JS_PUBLIC_API(JSScript *)
107154: JS_CompileScriptForPrincipalsVersion(JSContext *cx, JSObject *objArg,
 57678:                                      JSPrincipals *principals,
 57678:                                      const char *bytes, size_t length,
 91237:                                      const char *filename, unsigned lineno,
 57678:                                      JSVersion version)
 57678: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setFileAndLine(filename, lineno)
106508:            .setVersion(version);
106508: 
106508:     return Compile(cx, obj, options, bytes, length);
 57678: }
 57678: 
 78492: JS_PUBLIC_API(JSScript *)
107154: JS_CompileScriptForPrincipals(JSContext *cx, JSObject *objArg,
     1:                               JSPrincipals *principals,
     1:                               const char *bytes, size_t length,
 91237:                               const char *filename, unsigned lineno)
     1: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setFileAndLine(filename, lineno);
106508: 
106508:     return Compile(cx, obj, options, bytes, length);
 78492: }
 78492: 
 78492: JS_PUBLIC_API(JSScript *)
107154: JS_CompileScript(JSContext *cx, JSObject *objArg, const char *bytes, size_t length,
 91237:                  const char *filename, unsigned lineno)
     1: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setFileAndLine(filename, lineno);
106508: 
106508:     return Compile(cx, obj, options, bytes, length);
106508: }
106508: 
106508: JS_PUBLIC_API(JSBool)
107154: JS_BufferIsCompilableUnit(JSContext *cx, JSBool bytes_are_utf8, JSObject *objArg, const char *bytes, size_t length)
107154: {
107154:     RootedObject obj(cx, objArg);
     1:     jschar *chars;
     1:     JSBool result;
     1:     JSExceptionState *exnState;
     1:     JSErrorReporter older;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 68907:     if (bytes_are_utf8)
 71337:         chars = InflateString(cx, bytes, &length, CESU8Encoding);
 68907:     else
 71337:         chars = InflateString(cx, bytes, &length);
     1:     if (!chars)
     1:         return JS_TRUE;
     1: 
     1:     /*
     1:      * Return true on any out-of-memory error, so our caller doesn't try to
     1:      * collect more buffered source.
     1:      */
     1:     result = JS_TRUE;
     1:     exnState = JS_SaveExceptionState(cx);
 27012:     {
106508:         CompileOptions options(cx);
106508:         options.setCompileAndGo(false);
106508:         Parser parser(cx, options, chars, length, /* foldConstants = */ true);
 99261:         if (parser.init()) {
     1:             older = JS_SetErrorReporter(cx, NULL);
 40860:             if (!parser.parse(obj) &&
 40860:                 parser.tokenStream.isUnexpectedEOF()) {
     1:                 /*
 27012:                  * We ran into an error. If it was because we ran out of
 27012:                  * source, we return false so our caller knows to try to
 27012:                  * collect more buffered source.
     1:                  */
     1:                 result = JS_FALSE;
     1:             }
  6561:             JS_SetErrorReporter(cx, older);
 27012:         }
  6561:     }
110933:     js_free(chars);
     1:     JS_RestoreExceptionState(cx, exnState);
     1:     return result;
     1: }
     1: 
 78492: JS_PUBLIC_API(JSScript *)
107154: JS_CompileUTF8File(JSContext *cx, JSObject *objArg, const char *filename)
107154: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setUTF8(true)
106508:            .setFileAndLine(filename, 1);
106508: 
106508:     return Compile(cx, obj, options, filename);
 78492: }
 78492: 
 78492: JS_PUBLIC_API(JSScript *)
107154: JS_CompileUTF8FileHandleForPrincipals(JSContext *cx, JSObject *objArg, const char *filename,
 64190:                                       FILE *file, JSPrincipals *principals)
     1: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setUTF8(true)
106508:            .setFileAndLine(filename, 1)
106508:            .setPrincipals(principals);
106508: 
106508:     return Compile(cx, obj, options, file);
 64190: }
 64190: 
 78492: JS_PUBLIC_API(JSScript *)
107154: JS_CompileUTF8FileHandleForPrincipalsVersion(JSContext *cx, JSObject *objArg, const char *filename,
 57678:                                              FILE *file, JSPrincipals *principals, JSVersion version)
 57678: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setUTF8(true)
106508:            .setFileAndLine(filename, 1)
106508:            .setPrincipals(principals)
106508:            .setVersion(version);
106508: 
106508:     return Compile(cx, obj, options, file);
 57678: }
 57678: 
 78492: JS_PUBLIC_API(JSScript *)
107154: JS_CompileUTF8FileHandle(JSContext *cx, JSObject *objArg, const char *filename, FILE *file)
107154: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setUTF8(true)
106508:            .setFileAndLine(filename, 1);
106508: 
106508:     return Compile(cx, obj, options, file);
 43228: }
 43228: 
 78492: JS_PUBLIC_API(JSObject *)
 80803: JS_GetGlobalFromScript(JSScript *script)
 80803: {
 80803:     JS_ASSERT(!script->isCachedEval);
104376:     return &script->global();
     1: }
     1: 
106508: JS_PUBLIC_API(JSFunction *)
106508: JS::CompileFunction(JSContext *cx, HandleObject obj, CompileOptions options,
106508:                     const char *name, unsigned nargs, const char **argnames,
106508:                     const jschar *chars, size_t length)
106508: {
106508:     Maybe<AutoVersionAPI> mava;
106508:     if (options.versionSet) {
106508:         mava.construct(cx, options.version);
106508:         // AutoVersionAPI propagates some compilation flags through.
106508:         options.version = mava.ref().version();
106508:     }
 86437: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
114338:     assertSameCompartment(cx, obj);
114338:     JS_ASSERT_IF(options.principals, cx->compartment->principals == options.principals);
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 99421:     RootedAtom funAtom(cx);
 95355:     if (name) {
107982:         funAtom = Atomize(cx, name, strlen(name));
 77180:         if (!funAtom)
 77180:             return NULL;
 77180:     }
 77180: 
108505:     AutoNameVector formals(cx);
 91237:     for (unsigned i = 0; i < nargs; i++) {
107982:         RootedAtom argAtom(cx, Atomize(cx, argnames[i], strlen(argnames[i])));
108505:         if (!argAtom || !formals.append(argAtom->asPropertyName()))
 77180:             return NULL;
 77180:     }
 77180: 
116203:     RootedFunction fun(cx, js_NewFunction(cx, NullPtr(), NULL, 0, JSFUN_INTERPRETED, obj, funAtom));
 77180:     if (!fun)
 77180:         return NULL;
 43228: 
108505:     if (!frontend::CompileFunctionBody(cx, fun, options, formals, chars, length))
 77180:         return NULL;
 43228: 
102586:     if (obj && funAtom) {
102586:         Rooted<jsid> id(cx, AtomToId(funAtom));
106862:         RootedValue value(cx, ObjectValue(*fun));
108951:         if (!JSObject::defineGeneric(cx, obj, id, value, NULL, NULL, JSPROP_ENUMERATE))
 77180:             return NULL;
 77180:     }
 77180: 
 43228:     return fun;
 43228: }
 76812: 
 61450: JS_PUBLIC_API(JSFunction *)
106508: JS::CompileFunction(JSContext *cx, HandleObject obj, CompileOptions options,
106508:                     const char *name, unsigned nargs, const char **argnames,
106508:                     const char *bytes, size_t length)
106508: {
106508:     jschar *chars;
106508:     if (options.utf8)
106508:         chars = InflateString(cx, bytes, &length, CESU8Encoding);
106508:     else
106508:         chars = InflateString(cx, bytes, &length);
106508:     if (!chars)
106508:         return NULL;
106508: 
106508:     JSFunction *fun = CompileFunction(cx, obj, options, name, nargs, argnames, chars, length);
110933:     js_free(chars);
106508:     return fun;
106508: }
106508: 
106508: JS_PUBLIC_API(JSFunction *)
106508: JS_CompileUCFunctionForPrincipalsVersion(JSContext *cx, JSObject *obj_,
 61450:                                          JSPrincipals *principals, const char *name,
 91237:                                          unsigned nargs, const char **argnames,
 61450:                                          const jschar *chars, size_t length,
 91237:                                          const char *filename, unsigned lineno,
 61450:                                          JSVersion version)
 61450: {
106508:     RootedObject obj(cx, obj_);
106508: 
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setFileAndLine(filename, lineno)
106508:            .setVersion(version);
106508: 
106508:     return CompileFunction(cx, obj, options, name, nargs, argnames, chars, length);
 61450: }
 61450: 
 61450: JS_PUBLIC_API(JSFunction *)
107154: JS_CompileUCFunctionForPrincipals(JSContext *cx, JSObject *objArg,
 61450:                                   JSPrincipals *principals, const char *name,
 91237:                                   unsigned nargs, const char **argnames,
 61450:                                   const jschar *chars, size_t length,
 91237:                                   const char *filename, unsigned lineno)
 61450: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setFileAndLine(filename, lineno);
106508: 
106508:     return CompileFunction(cx, obj, options, name, nargs, argnames, chars, length);
 61450: }
 43228: 
 43228: JS_PUBLIC_API(JSFunction *)
107154: JS_CompileUCFunction(JSContext *cx, JSObject *objArg, const char *name,
 91237:                      unsigned nargs, const char **argnames,
 43228:                      const jschar *chars, size_t length,
 91237:                      const char *filename, unsigned lineno)
 43228: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setFileAndLine(filename, lineno);
106508: 
106508:     return CompileFunction(cx, obj, options, name, nargs, argnames, chars, length);
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
107154: JS_CompileFunctionForPrincipals(JSContext *cx, JSObject *objArg,
     1:                                 JSPrincipals *principals, const char *name,
 91237:                                 unsigned nargs, const char **argnames,
     1:                                 const char *bytes, size_t length,
 91237:                                 const char *filename, unsigned lineno)
     1: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setFileAndLine(filename, lineno);
106508: 
106508:     return CompileFunction(cx, obj, options, name, nargs, argnames, bytes, length);
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
107154: JS_CompileFunction(JSContext *cx, JSObject *objArg, const char *name,
 91237:                    unsigned nargs, const char **argnames,
 43228:                    const char *bytes, size_t length,
 91237:                    const char *filename, unsigned lineno)
     1: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setFileAndLine(filename, lineno);
106508: 
106508:     return CompileFunction(cx, obj, options, name, nargs, argnames, bytes, length);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
117612: JS_DecompileScript(JSContext *cx, JSScript *scriptArg, const char *name, unsigned indent)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
105944: 
105944:     AssertHeapIsIdle(cx);
105944:     CHECK_REQUEST(cx);
117612:     RootedScript script(cx, scriptArg);
106335:     RootedFunction fun(cx, script->function());
106335:     if (fun)
106335:         return JS_DecompileFunction(cx, fun, indent);
117612:     bool haveSource = script->scriptSource()->hasSourceData();
117614:     if (!haveSource && !script->loadSource(cx, &haveSource))
117612:         return NULL;
117612:     return haveSource ? script->sourceData(cx) : js_NewStringCopyZ(cx, "[no source]");
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
106335: JS_DecompileFunction(JSContext *cx, JSFunction *funArg, unsigned indent)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
106335:     assertSameCompartment(cx, funArg);
106335:     RootedFunction fun(cx, funArg);
106335:     return FunctionToString(cx, fun, false, !(indent & JS_DONT_PRETTY_PRINT));
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
106335: JS_DecompileFunctionBody(JSContext *cx, JSFunction *funArg, unsigned indent)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
106335:     assertSameCompartment(cx, funArg);
106335:     RootedFunction fun(cx, funArg);
106335:     return FunctionToString(cx, fun, true, !(indent & JS_DONT_PRETTY_PRINT));
     1: }
     1: 
 97069: JS_NEVER_INLINE JS_PUBLIC_API(JSBool)
107154: JS_ExecuteScript(JSContext *cx, JSObject *objArg, JSScript *scriptArg, jsval *rval)
107154: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedScript script(cx, scriptArg);
103320: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 94867:     assertSameCompartment(cx, obj);
 97069:     if (cx->compartment != obj->compartment())
 97182:         *(volatile int *) 0 = 0xf0;
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 94867:     /*
 94867:      * Mozilla caches pre-compiled scripts (e.g., in the XUL prototype cache)
 94867:      * and runs them against multiple globals. With a compartment per global,
 94867:      * this requires cloning the pre-compiled script into each new global.
 94867:      * Since each script gets run once, there is no point in trying to cache
 94867:      * this clone. Ideally, this would be handled at some pinch point in
 94867:      * mozilla, but there doesn't seem to be one, so we handle it here.
 94867:      */
107154:     if (script->compartment() != obj->compartment()) {
107154:         script = CloneScript(cx, NullPtr(), NullPtr(), script);
 94867:         if (!script.get())
 94867:             return false;
 94867:     } else {
 94867:         script = scriptArg;
 94867:     }
 94867: 
107154:     return Execute(cx, script, *obj, rval);
107154: }
107154: 
107154: JS_PUBLIC_API(JSBool)
107154: JS_ExecuteScriptVersion(JSContext *cx, JSObject *objArg, JSScript *script, jsval *rval,
 57678:                         JSVersion version)
 57678: {
107154:     RootedObject obj(cx, objArg);
 57678:     AutoVersionAPI ava(cx, version);
 78492:     return JS_ExecuteScript(cx, obj, script, rval);
 57678: }
 57678: 
106508: extern JS_PUBLIC_API(bool)
106508: JS::Evaluate(JSContext *cx, HandleObject obj, CompileOptions options,
106508:              const jschar *chars, size_t length, jsval *rval)
106508: {
106508:     Maybe<AutoVersionAPI> mava;
106508:     if (options.versionSet) {
106508:         mava.construct(cx, options.version);
106508:         // AutoVersionAPI propagates some compilation flags through.
106508:         options.version = mava.ref().version();
106508:     }
106508: 
 84691:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
106508:     AssertHeapIsIdle(cx);
106508:     CHECK_REQUEST(cx);
114338:     assertSameCompartment(cx, obj);
114338:     JS_ASSERT_IF(options.principals, cx->compartment->principals == options.principals);
114338: 
 84691:     AutoLastFrameCheck lfc(cx);
106508: 
106508:     options.setCompileAndGo(true);
106508:     options.setNoScriptRval(!rval);
107154:     RootedScript script(cx, frontend::CompileScript(cx, obj, NULL, options, chars, length));
 84691:     if (!script)
 84691:         return false;
 84691: 
106508:     JS_ASSERT(script->getVersion() == options.version);
 84691: 
 84691:     return Execute(cx, script, *obj, rval);
 84691: }
 84691: 
106508: extern JS_PUBLIC_API(bool)
106508: JS::Evaluate(JSContext *cx, HandleObject obj, CompileOptions options,
106508:              const char *bytes, size_t length, jsval *rval)
106508: {
106508:     jschar *chars;
106508:     if (options.utf8)
106508:         chars = InflateString(cx, bytes, &length, CESU8Encoding);
106508:     else
106508:         chars = InflateString(cx, bytes, &length);
106508:     if (!chars)
108811:         return false;
106508: 
106508:     bool ok = Evaluate(cx, obj, options, chars, length, rval);
110933:     js_free(chars);
106508:     return ok;
106508: }
106508: 
107039: extern JS_PUBLIC_API(bool)
107039: JS::Evaluate(JSContext *cx, HandleObject obj, CompileOptions options,
107039:              const char *filename, jsval *rval)
107039: {
107046:     FileContents buffer(cx);
107046:     {
107046:         AutoFile file;
107046:         if (!file.open(cx, filename) || !file.readAll(cx, buffer))
108811:             return false;
107046:     }
107039: 
107039:     options = options.setFileAndLine(filename, 1);
107039:     return Evaluate(cx, obj, options, buffer.begin(), buffer.length(), rval);
107039: }
107039: 
106508: JS_PUBLIC_API(JSBool)
107154: JS_EvaluateUCScriptForPrincipals(JSContext *cx, JSObject *objArg,
 61450:                                  JSPrincipals *principals,
 91237:                                  const jschar *chars, unsigned length,
 91237:                                  const char *filename, unsigned lineno,
 84691:                                  jsval *rval)
 84691: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setFileAndLine(filename, lineno);
106508: 
106508:     return Evaluate(cx, obj, options, chars, length, rval);
106508: }
106508: 
106508: JS_PUBLIC_API(JSBool)
107154: JS_EvaluateUCScriptForPrincipalsVersion(JSContext *cx, JSObject *objArg,
 53848:                                         JSPrincipals *principals,
 91237:                                         const jschar *chars, unsigned length,
 91237:                                         const char *filename, unsigned lineno,
 53848:                                         jsval *rval, JSVersion version)
 53848: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setFileAndLine(filename, lineno)
106508:            .setVersion(version);
106508: 
106508:     return Evaluate(cx, obj, options, chars, length, rval);
 53848: }
 53848: 
 84691: extern JS_PUBLIC_API(JSBool)
107154: JS_EvaluateUCScriptForPrincipalsVersionOrigin(JSContext *cx, JSObject *objArg,
     1:                                               JSPrincipals *principals,
 84691:                                               JSPrincipals *originPrincipals,
 91237:                                               const jschar *chars, unsigned length,
 91237:                                               const char *filename, unsigned lineno,
 84691:                                               jsval *rval, JSVersion version)
 84691: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setOriginPrincipals(originPrincipals)
106508:            .setFileAndLine(filename, lineno)
106508:            .setVersion(version);
106508: 
106508:     return Evaluate(cx, obj, options, chars, length, rval);
106508: }
106508: 
106508: JS_PUBLIC_API(JSBool)
107154: JS_EvaluateUCScript(JSContext *cx, JSObject *objArg, const jschar *chars, unsigned length,
 91237:                     const char *filename, unsigned lineno, jsval *rval)
 43228: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setFileAndLine(filename, lineno);
106508: 
106508:     return Evaluate(cx, obj, options, chars, length, rval);
 43228: }
 43228: 
 91237: /* Ancient unsigned nbytes is part of API/ABI, so use size_t length local. */
 43228: JS_PUBLIC_API(JSBool)
107154: JS_EvaluateScriptForPrincipals(JSContext *cx, JSObject *objArg, JSPrincipals *principals,
 91237:                                const char *bytes, unsigned nbytes,
 91237:                                const char *filename, unsigned lineno, jsval *rval)
 43228: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setFileAndLine(filename, lineno);
106508: 
106508:     return Evaluate(cx, obj, options, bytes, nbytes, rval);
106508: }
106508: 
106508: JS_PUBLIC_API(JSBool)
107154: JS_EvaluateScriptForPrincipalsVersion(JSContext *cx, JSObject *objArg, JSPrincipals *principals,
 91237:                                       const char *bytes, unsigned nbytes,
106508:                                       const char *filename, unsigned lineno, jsval *rval,
106508:                                       JSVersion version)
106508: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(principals)
106508:            .setVersion(version)
106508:            .setFileAndLine(filename, lineno);
106508: 
106508:     return Evaluate(cx, obj, options, bytes, nbytes, rval);
106508: }
106508: 
106508: JS_PUBLIC_API(JSBool)
107154: JS_EvaluateScript(JSContext *cx, JSObject *objArg, const char *bytes, unsigned nbytes,
 91237:                   const char *filename, unsigned lineno, jsval *rval)
 43228: {
107154:     RootedObject obj(cx, objArg);
106508:     CompileOptions options(cx);
106508:     options.setFileAndLine(filename, lineno);
106508: 
106508:     return Evaluate(cx, obj, options, bytes, nbytes, rval);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
107154: JS_CallFunction(JSContext *cx, JSObject *objArg, JSFunction *fun, unsigned argc, jsval *argv,
 43229:                 jsval *rval)
     1: {
107154:     RootedObject obj(cx, objArg);
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 48470:     assertSameCompartment(cx, obj, fun, JSValueArray(argv, argc));
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 78614:     return Invoke(cx, ObjectOrNullValue(obj), ObjectValue(*fun), argc, argv, rval);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
107154: JS_CallFunctionName(JSContext *cx, JSObject *objArg, const char *name, unsigned argc, jsval *argv,
 43229:                     jsval *rval)
     1: {
107154:     RootedObject obj(cx, objArg);
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
107154:     assertSameCompartment(cx, obj, JSValueArray(argv, argc));
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
102586:     if (!atom)
102586:         return false;
102586: 
106862:     RootedValue v(cx);
107154:     RootedId id(cx, AtomToId(atom));
102586:     return GetMethod(cx, obj, id, 0, &v) &&
 78614:            Invoke(cx, ObjectOrNullValue(obj), v, argc, argv, rval);
 76829: }
 76829: 
 76829: JS_PUBLIC_API(JSBool)
107154: JS_CallFunctionValue(JSContext *cx, JSObject *objArg, jsval fval, unsigned argc, jsval *argv,
 76829:                      jsval *rval)
 76829: {
107154:     RootedObject obj(cx, objArg);
 76829:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 76829:     CHECK_REQUEST(cx);
 76829:     assertSameCompartment(cx, obj, fval, JSValueArray(argv, argc));
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 78614:     return Invoke(cx, ObjectOrNullValue(obj), fval, argc, argv, rval);
     1: }
     1: 
 55717: namespace JS {
 55717: 
 55717: JS_PUBLIC_API(bool)
 91237: Call(JSContext *cx, jsval thisv, jsval fval, unsigned argc, jsval *argv, jsval *rval)
 55717: {
103783:     AssertHeapIsIdle(cx);
 55717:     CHECK_REQUEST(cx);
 55717:     assertSameCompartment(cx, thisv, fval, JSValueArray(argv, argc));
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 78614:     return Invoke(cx, thisv, fval, argc, argv, rval);
 55717: }
 55717: 
 55717: } // namespace JS
 55717: 
 40293: JS_PUBLIC_API(JSObject *)
107154: JS_New(JSContext *cx, JSObject *ctorArg, unsigned argc, jsval *argv)
107154: {
107154:     RootedObject ctor(cx, ctorArg);
103783:     AssertHeapIsIdle(cx);
 40293:     CHECK_REQUEST(cx);
 48470:     assertSameCompartment(cx, ctor, JSValueArray(argv, argc));
 77180:     AutoLastFrameCheck lfc(cx);
 40293: 
 40293:     // This is not a simple variation of JS_CallFunctionValue because JSOP_NEW
 40293:     // is not a simple variation of JSOP_CALL. We have to determine what class
 40293:     // of object to create, create it, and clamp the return value to an object,
 76829:     // among other details. InvokeConstructor does the hard work.
 42714:     InvokeArgsGuard args;
 69223:     if (!cx->stack.pushInvokeArgs(cx, argc, &args))
 40293:         return NULL;
 42714: 
108174:     args.setCallee(ObjectValue(*ctor));
108174:     args.setThis(NullValue());
 87623:     PodCopy(args.array(), argv, argc);
 40293: 
 77180:     if (!InvokeConstructor(cx, args))
 77180:         return NULL;
 77180: 
 77180:     if (!args.rval().isObject()) {
 57687:         /*
 57687:          * Although constructors may return primitives (via proxies), this
 57687:          * API is asking for an object, so we report an error.
 57687:          */
 57812:         JSAutoByteString bytes;
 57812:         if (js_ValueToPrintable(cx, args.rval(), &bytes)) {
 57687:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_NEW_RESULT,
 57812:                                  bytes.ptr());
 57812:         }
 77180:         return NULL;
 77180:     }
 77180: 
 77180:     return &args.rval().toObject();
 40293: }
 40293: 
 25087: JS_PUBLIC_API(JSOperationCallback)
 25087: JS_SetOperationCallback(JSContext *cx, JSOperationCallback callback)
 25087: {
 25087:     JSOperationCallback old = cx->operationCallback;
 23726:     cx->operationCallback = callback;
 25087:     return old;
 23726: }
 23726: 
 23726: JS_PUBLIC_API(JSOperationCallback)
 23726: JS_GetOperationCallback(JSContext *cx)
 23726: {
 23726:     return cx->operationCallback;
 23726: }
 23726: 
 23726: JS_PUBLIC_API(void)
 91846: JS_TriggerOperationCallback(JSRuntime *rt)
 91846: {
 88135:     rt->triggerOperationCallback();
 25472: }
 25472: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_IsRunning(JSContext *cx)
     1: {
109256:     return cx->hasfp();
 47498: }
 37739: 
 71697: JS_PUBLIC_API(JSBool)
   520: JS_SaveFrameChain(JSContext *cx)
   520: {
103785:     AssertHeapIsIdleOrIterating(cx);
 37912:     CHECK_REQUEST(cx);
109256:     return cx->saveFrameChain();
   520: }
   520: 
   520: JS_PUBLIC_API(void)
 71697: JS_RestoreFrameChain(JSContext *cx)
   520: {
103785:     AssertHeapIsIdleOrIterating(cx);
 37912:     CHECK_REQUEST(cx);
109256:     cx->restoreFrameChain();
   520: }
   520: 
 83205: #ifdef MOZ_TRACE_JSCALLS
 83205: JS_PUBLIC_API(void)
 83205: JS_SetFunctionCallback(JSContext *cx, JSFunctionCallback fcb)
 83205: {
 83205:     cx->functionCallback = fcb;
 83205: }
 83205: 
 83205: JS_PUBLIC_API(JSFunctionCallback)
 83205: JS_GetFunctionCallback(JSContext *cx)
 83205: {
 83205:     return cx->functionCallback;
 83205: }
 83205: #endif
 83205: 
     1: /************************************************************************/
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewStringCopyN(JSContext *cx, const char *s, size_t n)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 59890:     return js_NewStringCopyN(cx, s, n);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewStringCopyZ(JSContext *cx, const char *s)
     1: {
     1:     size_t n;
     1:     jschar *js;
     1:     JSString *str;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 87952:     if (!s || !*s)
     1:         return cx->runtime->emptyString;
     1:     n = strlen(s);
 71337:     js = InflateString(cx, s, &n);
     1:     if (!js)
     1:         return NULL;
  4718:     str = js_NewString(cx, js, n);
     1:     if (!str)
110933:         js_free(js);
     1:     return str;
     1: }
     1: 
 48470: JS_PUBLIC_API(JSBool)
 70270: JS_StringHasBeenInterned(JSContext *cx, JSString *str)
 70270: {
103783:     AssertHeapIsIdle(cx);
 70270:     CHECK_REQUEST(cx);
 70270: 
 70270:     if (!str->isAtom())
 70270:         return false;
 70270: 
 70270:     return AtomIsInterned(cx, &str->asAtom());
 48470: }
 48470: 
 97828: JS_PUBLIC_API(jsid)
 97828: INTERNED_STRING_TO_JSID(JSContext *cx, JSString *str)
 97828: {
 97828:     JS_ASSERT(str);
 97828:     JS_ASSERT(((size_t)str & JSID_TYPE_MASK) == 0);
 97828:     JS_ASSERT_IF(cx, JS_StringHasBeenInterned(cx, str));
 97828:     return AtomToId(&str->asAtom());
 97828: }
 97828: 
     1: JS_PUBLIC_API(JSString *)
 59889: JS_InternJSString(JSContext *cx, JSString *str)
 59889: {
103783:     AssertHeapIsIdle(cx);
 59889:     CHECK_REQUEST(cx);
107982:     JSAtom *atom = AtomizeString(cx, str, InternAtom);
 70270:     JS_ASSERT_IF(atom, JS_StringHasBeenInterned(cx, atom));
 70270:     return atom;
 59889: }
 59889: 
 59889: JS_PUBLIC_API(JSString *)
     1: JS_InternString(JSContext *cx, const char *s)
     1: {
107025:     return JS_InternStringN(cx, s, strlen(s));
107025: }
107025: 
107025: JS_PUBLIC_API(JSString *)
107025: JS_InternStringN(JSContext *cx, const char *s, size_t length)
107025: {
107025:     AssertHeapIsIdle(cx);
107025:     CHECK_REQUEST(cx);
107982:     JSAtom *atom = Atomize(cx, s, length, InternAtom);
 70270:     JS_ASSERT_IF(atom, JS_StringHasBeenInterned(cx, atom));
 70270:     return atom;
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewUCString(JSContext *cx, jschar *chars, size_t length)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
  4718:     return js_NewString(cx, chars, length);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewUCStringCopyN(JSContext *cx, const jschar *s, size_t n)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
  4076:     return js_NewStringCopyN(cx, s, n);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewUCStringCopyZ(JSContext *cx, const jschar *s)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
     1:     if (!s)
     1:         return cx->runtime->emptyString;
  4076:     return js_NewStringCopyZ(cx, s);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_InternUCStringN(JSContext *cx, const jschar *s, size_t length)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
107982:     JSAtom *atom = AtomizeChars(cx, s, length, InternAtom);
 70270:     JS_ASSERT_IF(atom, JS_StringHasBeenInterned(cx, atom));
 70270:     return atom;
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_InternUCString(JSContext *cx, const jschar *s)
     1: {
     1:     return JS_InternUCStringN(cx, s, js_strlen(s));
     1: }
     1: 
     1: JS_PUBLIC_API(size_t)
     1: JS_GetStringLength(JSString *str)
     1: {
 29366:     return str->length();
     1: }
     1: 
 33583: JS_PUBLIC_API(const jschar *)
 59889: JS_GetStringCharsZ(JSContext *cx, JSString *str)
 59889: {
103783:     AssertHeapIsIdleOrStringIsFlat(cx, str);
 59889:     CHECK_REQUEST(cx);
 59889:     assertSameCompartment(cx, str);
114424:     JSStableString *stable = str->ensureStable(cx);
114424:     if (!stable)
114424:         return NULL;
114424:     return stable->chars();
 59234: }
 59234: 
 59234: JS_PUBLIC_API(const jschar *)
 59889: JS_GetStringCharsZAndLength(JSContext *cx, JSString *str, size_t *plength)
 59889: {
114424:     JS_ASSERT(plength);
103783:     AssertHeapIsIdleOrStringIsFlat(cx, str);
 59889:     CHECK_REQUEST(cx);
 59234:     assertSameCompartment(cx, str);
114424:     JSStableString *stable = str->ensureStable(cx);
114424:     if (!stable)
114424:         return NULL;
114424:     *plength = stable->length();
114424:     return stable->chars();
 59889: }
 59889: 
 59889: JS_PUBLIC_API(const jschar *)
 59889: JS_GetStringCharsAndLength(JSContext *cx, JSString *str, size_t *plength)
 59889: {
114424:     JS_ASSERT(plength);
103783:     AssertHeapIsIdleOrStringIsFlat(cx, str);
 59889:     CHECK_REQUEST(cx);
 59889:     assertSameCompartment(cx, str);
114424:     JSStableString *stable = str->ensureStable(cx);
114424:     if (!stable)
114424:         return NULL;
114424:     *plength = stable->length();
114424:     return stable->chars();
 59889: }
 59889: 
 59889: JS_PUBLIC_API(const jschar *)
 59889: JS_GetInternedStringChars(JSString *str)
 59889: {
114424:     JS_ASSERT(str->isAtom());
114424:     JSStableString *stable = str->ensureStable(NULL);
114424:     if (!stable)
114424:         return NULL;
114424:     return stable->chars();
 59889: }
 59889: 
 59889: JS_PUBLIC_API(const jschar *)
 59889: JS_GetInternedStringCharsAndLength(JSString *str, size_t *plength)
 59889: {
114424:     JS_ASSERT(str->isAtom());
114424:     JS_ASSERT(plength);
114424:     JSStableString *stable = str->ensureStable(NULL);
114424:     if (!stable)
114424:         return NULL;
114424:     *plength = stable->length();
114424:     return stable->chars();
 59889: }
 59889: 
 59889: extern JS_PUBLIC_API(JSFlatString *)
 59889: JS_FlattenString(JSContext *cx, JSString *str)
 59889: {
103783:     AssertHeapIsIdle(cx);
 59889:     CHECK_REQUEST(cx);
 59889:     assertSameCompartment(cx, str);
114424:     JSFlatString *flat = str->ensureFlat(cx);
114424:     if (!flat)
114424:         return NULL;
114424:     return flat;
 59889: }
 59889: 
 59889: extern JS_PUBLIC_API(const jschar *)
 59889: JS_GetFlatStringChars(JSFlatString *str)
 59889: {
114424:     JSStableString *stable = str->ensureStable(NULL);
114424:     if (!stable)
114424:         return NULL;
 57721:     return str->chars();
 57721: }
 57721: 
 57721: JS_PUBLIC_API(JSBool)
 84755: JS_CompareStrings(JSContext *cx, JSString *str1, JSString *str2, int32_t *result)
 59889: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 81562: 
 59890:     return CompareStrings(cx, str1, str2, result);
 59889: }
 59889: 
 59889: JS_PUBLIC_API(JSBool)
 59889: JS_StringEqualsAscii(JSContext *cx, JSString *str, const char *asciiBytes, JSBool *match)
 59234: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 81562: 
 59890:     JSLinearString *linearStr = str->ensureLinear(cx);
 59890:     if (!linearStr)
 59890:         return false;
 59890:     *match = StringEqualsAscii(linearStr, asciiBytes);
 59890:     return true;
 59234: }
 59234: 
 59889: JS_PUBLIC_API(JSBool)
 59889: JS_FlatStringEqualsAscii(JSFlatString *str, const char *asciiBytes)
 59889: {
 59890:     return StringEqualsAscii(str, asciiBytes);
 57721: }
 57721: 
 57721: JS_PUBLIC_API(size_t)
 59889: JS_PutEscapedFlatString(char *buffer, size_t size, JSFlatString *str, char quote)
 57721: {
 57721:     return PutEscapedString(buffer, size, str, quote);
 57721: }
 57721: 
 59889: JS_PUBLIC_API(size_t)
 59889: JS_PutEscapedString(JSContext *cx, char *buffer, size_t size, JSString *str, char quote)
 59234: {
103783:     AssertHeapIsIdle(cx);
 59890:     JSLinearString *linearStr = str->ensureLinear(cx);
 59890:     if (!linearStr)
 59890:         return size_t(-1);
 59890:     return PutEscapedString(buffer, size, linearStr, quote);
 59234: }
 59234: 
 57721: JS_PUBLIC_API(JSBool)
 57721: JS_FileEscapedString(FILE *fp, JSString *str, char quote)
 57721: {
 59890:     JSLinearString *linearStr = str->ensureLinear(NULL);
 59890:     return linearStr && FileEscapedString(fp, linearStr, quote);
 57721: }
 57721: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewGrowableString(JSContext *cx, jschar *chars, size_t length)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 48491:     return js_NewString(cx, chars, length);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
 43229: JS_NewDependentString(JSContext *cx, JSString *str, size_t start, size_t length)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
  4076:     return js_NewDependentString(cx, str, start, length);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_ConcatStrings(JSContext *cx, JSString *left, JSString *right)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
102586:     Rooted<JSString*> lstr(cx, left);
102586:     Rooted<JSString*> rstr(cx, right);
102586:     return js_ConcatStrings(cx, lstr, rstr);
     1: }
     1: 
     1: JS_PUBLIC_API(const jschar *)
     1: JS_UndependString(JSContext *cx, JSString *str)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 59889:     return str->getCharsZ(cx);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 43229: JS_EncodeCharacters(JSContext *cx, const jschar *src, size_t srclen, char *dst, size_t *dstlenp)
     1: {
103783:     AssertHeapIsIdle(cx);
 86458:     CHECK_REQUEST(cx);
 86458: 
     1:     size_t n;
     1:     if (!dst) {
 71337:         n = GetDeflatedStringLength(cx, src, srclen);
     1:         if (n == (size_t)-1) {
     1:             *dstlenp = 0;
     1:             return JS_FALSE;
     1:         }
     1:         *dstlenp = n;
     1:         return JS_TRUE;
     1:     }
     1: 
 71337:     return DeflateStringToBuffer(cx, src, srclen, dst, dstlenp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 43229: JS_DecodeBytes(JSContext *cx, const char *src, size_t srclen, jschar *dst, size_t *dstlenp)
     1: {
103783:     AssertHeapIsIdle(cx);
 86458:     CHECK_REQUEST(cx);
 71337:     return InflateStringToBuffer(cx, src, srclen, dst, dstlenp);
     1: }
     1: 
 68907: JS_PUBLIC_API(JSBool)
 68907: JS_DecodeUTF8(JSContext *cx, const char *src, size_t srclen, jschar *dst,
 68907:               size_t *dstlenp)
 68907: {
103783:     AssertHeapIsIdle(cx);
 86458:     CHECK_REQUEST(cx);
 71337:     return InflateUTF8StringToBuffer(cx, src, srclen, dst, dstlenp);
 68907: }
 68907: 
  8893: JS_PUBLIC_API(char *)
116201: JS_EncodeString(JSContext *cx, JSRawString strArg)
116201: {
116201:     RootedString str(cx, strArg);
116201: 
103783:     AssertHeapIsIdle(cx);
 86458:     CHECK_REQUEST(cx);
 86458: 
 59890:     const jschar *chars = str->getChars(cx);
 59890:     if (!chars)
 59890:         return NULL;
 71337:     return DeflateString(cx, chars, str->length());
  8893: }
  8893: 
 57814: JS_PUBLIC_API(size_t)
 57814: JS_GetStringEncodingLength(JSContext *cx, JSString *str)
 57814: {
 86458:     /* jsd calls us with a NULL cx. Ugh. */
 86458:     if (cx) {
103783:         AssertHeapIsIdle(cx);
 86458:         CHECK_REQUEST(cx);
 86458:     }
 86458: 
 59890:     const jschar *chars = str->getChars(cx);
 59890:     if (!chars)
 59890:         return size_t(-1);
 71337:     return GetDeflatedStringLength(cx, chars, str->length());
 57814: }
 57814: 
 57814: JS_PUBLIC_API(size_t)
 57814: JS_EncodeStringToBuffer(JSString *str, char *buffer, size_t length)
 57814: {
 57814:     /*
 71337:      * FIXME bug 612141 - fix DeflateStringToBuffer interface so the result
 57814:      * would allow to distinguish between insufficient buffer and encoding
 57814:      * error.
 57814:      */
 57814:     size_t writtenLength = length;
 59890:     const jschar *chars = str->getChars(NULL);
 59890:     if (!chars)
 59890:         return size_t(-1);
 71337:     if (DeflateStringToBuffer(NULL, chars, str->length(), buffer, &writtenLength)) {
 57814:         JS_ASSERT(writtenLength <= length);
 57814:         return writtenLength;
 57814:     }
 57814:     JS_ASSERT(writtenLength <= length);
 71337:     size_t necessaryLength = GetDeflatedStringLength(NULL, chars, str->length());
 57814:     if (necessaryLength == size_t(-1))
 57814:         return size_t(-1);
 57814:     if (writtenLength != length) {
 57814:         /* Make sure that the buffer contains only valid UTF-8 sequences. */
 57814:         JS_ASSERT(js_CStringsAreUTF8);
 57814:         PodZero(buffer + writtenLength, length - writtenLength);
 57814:     }
 57814:     return necessaryLength;
 57814: }
 57814: 
 20092: JS_PUBLIC_API(JSBool)
107154: JS_Stringify(JSContext *cx, jsval *vp, JSObject *replacerArg, jsval space,
 20092:              JSONWriteCallback callback, void *data)
 20092: {
107154:     RootedObject replacer(cx, replacerArg);
104205:     RootedValue value(cx, *vp);
104205: 
103783:     AssertHeapIsIdle(cx);
 20092:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, replacer, space);
 60571:     StringBuffer sb(cx);
104205:     if (!js_Stringify(cx, &value, replacer, space, sb))
 31819:         return false;
104205:     *vp = value;
 73060:     if (sb.empty()) {
114207:         HandlePropertyName null = cx->names().null;
114207:         return callback(null->chars(), null->length(), data);
 73060:     }
 60571:     return callback(sb.begin(), sb.length(), data);
 20092: }
 20092: 
 20092: JS_PUBLIC_API(JSBool)
 84755: JS_ParseJSON(JSContext *cx, const jschar *chars, uint32_t len, jsval *vp)
 67923: {
103783:     AssertHeapIsIdle(cx);
 67923:     CHECK_REQUEST(cx);
 67923: 
106862:     RootedValue reviver(cx, NullValue()), value(cx);
106862:     if (!ParseJSONWithReviver(cx, chars, len, reviver, &value))
106862:         return false;
106862: 
106862:     *vp = value;
106862:     return true;
106862: }
106862: 
106862: JS_PUBLIC_API(JSBool)
106862: JS_ParseJSONWithReviver(JSContext *cx, const jschar *chars, uint32_t len, jsval reviverArg, jsval *vp)
106862: {
106862:     AssertHeapIsIdle(cx);
106862:     CHECK_REQUEST(cx);
106862: 
106862:     RootedValue reviver(cx, reviverArg), value(cx);
106862:     if (!ParseJSONWithReviver(cx, chars, len, reviver, &value))
106862:         return false;
106862: 
106862:     *vp = value;
106862:     return true;
 67923: }
 67923: 
 67923: JS_PUBLIC_API(JSBool)
116001: JS_ReadStructuredClone(JSContext *cx, uint64_t *buf, size_t nbytes,
 84755:                        uint32_t version, jsval *vp,
 60105:                        const JSStructuredCloneCallbacks *optionalCallbacks,
 60105:                        void *closure)
 58294: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 81562: 
 58294:     if (version > JS_STRUCTURED_CLONE_VERSION) {
 58294:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_CLONE_VERSION);
 58294:         return false;
 58294:     }
 60105:     const JSStructuredCloneCallbacks *callbacks =
 60105:         optionalCallbacks ?
 60105:         optionalCallbacks :
 60105:         cx->runtime->structuredCloneCallbacks;
 78614:     return ReadStructuredClone(cx, buf, nbytes, vp, callbacks, closure);
 54863: }
 54863: 
 54863: JS_PUBLIC_API(JSBool)
111462: JS_WriteStructuredClone(JSContext *cx, jsval valueArg, uint64_t **bufp, size_t *nbytesp,
 60105:                         const JSStructuredCloneCallbacks *optionalCallbacks,
116001:                         void *closure, jsval transferable)
 60105: {
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
 81562: 
 60105:     const JSStructuredCloneCallbacks *callbacks =
 60105:         optionalCallbacks ?
 60105:         optionalCallbacks :
 60105:         cx->runtime->structuredCloneCallbacks;
116001:     return WriteStructuredClone(cx, valueArg, (uint64_t **) bufp, nbytesp,
116001:                                 callbacks, closure, transferable);
116001: }
116001: 
116001: JS_PUBLIC_API(JSBool)
116001: JS_ClearStructuredClone(const uint64_t *data, size_t nbytes)
116001: {
116001:     return ClearStructuredClone(data, nbytes);
116001: }
116001: 
116001: JS_PUBLIC_API(JSBool)
116001: JS_StructuredCloneHasTransferables(const uint64_t *data, size_t nbytes,
116001:                                    JSBool *hasTransferable)
116001: {
116001:     bool transferable;
116001:     if (!StructuredCloneHasTransferObjects(data, nbytes, &transferable))
116001:         return false;
116001: 
116001:     *hasTransferable = transferable;
116001:     return true;
111462: }
111462: 
111462: JS_PUBLIC_API(JSBool)
111462: JS_StructuredClone(JSContext *cx, jsval valueArg, jsval *vp,
 60105:                    const JSStructuredCloneCallbacks *optionalCallbacks,
 60105:                    void *closure)
 60105: {
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
 81562: 
 60105:     const JSStructuredCloneCallbacks *callbacks =
 60105:         optionalCallbacks ?
 60105:         optionalCallbacks :
 60105:         cx->runtime->structuredCloneCallbacks;
 59556:     JSAutoStructuredCloneBuffer buf;
111462:     return buf.write(cx, value, callbacks, closure) &&
 74542:            buf.read(cx, vp, callbacks, closure);
 74542: }
 74542: 
 74542: void
 74542: JSAutoStructuredCloneBuffer::clear()
 74542: {
 74542:     if (data_) {
116001:         ClearStructuredClone(data_, nbytes_);
 74542:         data_ = NULL;
 74542:         nbytes_ = 0;
 74542:         version_ = 0;
 74542:     }
 74542: }
 74542: 
 74542: void
 84755: JSAutoStructuredCloneBuffer::adopt(uint64_t *data, size_t nbytes, uint32_t version)
 74542: {
 74542:     clear();
 74542:     data_ = data;
 74542:     nbytes_ = nbytes;
 74542:     version_ = version;
 74542: }
 74542: 
 74542: bool
 84755: JSAutoStructuredCloneBuffer::copy(const uint64_t *srcData, size_t nbytes, uint32_t version)
 84755: {
116001:     // transferable objects cannot be copied
116001:     bool hasTransferable;
116001:     if (!StructuredCloneHasTransferObjects(data_, nbytes_, &hasTransferable) ||
116001:         hasTransferable)
116001:         return false;
116001: 
110933:     uint64_t *newData = static_cast<uint64_t *>(js_malloc(nbytes));
 74542:     if (!newData)
 74542:         return false;
 74542: 
 87623:     js_memcpy(newData, srcData, nbytes);
 74542: 
 74542:     clear();
 74542:     data_ = newData;
 74542:     nbytes_ = nbytes;
 74542:     version_ = version;
 74542:     return true;
 74542: }
 74542: void
 84755: JSAutoStructuredCloneBuffer::steal(uint64_t **datap, size_t *nbytesp, uint32_t *versionp)
 74542: {
 74542:     *datap = data_;
 74542:     *nbytesp = nbytes_;
 74542:     if (versionp)
 74542:         *versionp = version_;
 74542: 
 74542:     data_ = NULL;
 74542:     nbytes_ = 0;
 74542:     version_ = 0;
 74542: }
 74542: 
 74542: bool
 74542: JSAutoStructuredCloneBuffer::read(JSContext *cx, jsval *vp,
 74542:                                   const JSStructuredCloneCallbacks *optionalCallbacks,
116001:                                   void *closure)
 74542: {
 74542:     JS_ASSERT(cx);
 74542:     JS_ASSERT(data_);
 74542:     return !!JS_ReadStructuredClone(cx, data_, nbytes_, version_, vp,
 74542:                                     optionalCallbacks, closure);
 74542: }
 74542: 
 74542: bool
111462: JSAutoStructuredCloneBuffer::write(JSContext *cx, jsval valueArg,
 74542:                                    const JSStructuredCloneCallbacks *optionalCallbacks,
 74542:                                    void *closure)
 74542: {
116001:     jsval transferable = JSVAL_VOID;
116001:     return write(cx, valueArg, transferable, optionalCallbacks, closure);
116001: }
116001: 
116001: bool
116001: JSAutoStructuredCloneBuffer::write(JSContext *cx, jsval valueArg,
116001:                                    jsval transferable,
116001:                                    const JSStructuredCloneCallbacks *optionalCallbacks,
116001:                                    void *closure)
116001: {
111462:     RootedValue value(cx, valueArg);
 74542:     clear();
111462:     bool ok = !!JS_WriteStructuredClone(cx, value, &data_, &nbytes_,
116001:                                         optionalCallbacks, closure,
116001:                                         transferable);
 74542:     if (!ok) {
 74542:         data_ = NULL;
 74542:         nbytes_ = 0;
 74542:         version_ = JS_STRUCTURED_CLONE_VERSION;
 74542:     }
 74542:     return ok;
 74542: }
 74542: 
 74542: void
 74542: JSAutoStructuredCloneBuffer::swap(JSAutoStructuredCloneBuffer &other)
 74542: {
 84755:     uint64_t *data = other.data_;
 74542:     size_t nbytes = other.nbytes_;
 84755:     uint32_t version = other.version_;
 74542: 
 74542:     other.data_ = this->data_;
 74542:     other.nbytes_ = this->nbytes_;
 74542:     other.version_ = this->version_;
 74542: 
 74542:     this->data_ = data;
 74542:     this->nbytes_ = nbytes;
 74542:     this->version_ = version;
 54863: }
 54863: 
 54863: JS_PUBLIC_API(void)
 54863: JS_SetStructuredCloneCallbacks(JSRuntime *rt, const JSStructuredCloneCallbacks *callbacks)
 54863: {
 54863:     rt->structuredCloneCallbacks = callbacks;
 54863: }
 54863: 
 54863: JS_PUBLIC_API(JSBool)
 84755: JS_ReadUint32Pair(JSStructuredCloneReader *r, uint32_t *p1, uint32_t *p2)
 54863: {
 54863:     return r->input().readPair((uint32_t *) p1, (uint32_t *) p2);
 54863: }
 54863: 
 54863: JS_PUBLIC_API(JSBool)
 54863: JS_ReadBytes(JSStructuredCloneReader *r, void *p, size_t len)
 54863: {
 54863:     return r->input().readBytes(p, len);
 54863: }
 54863: 
 54863: JS_PUBLIC_API(JSBool)
 84755: JS_WriteUint32Pair(JSStructuredCloneWriter *w, uint32_t tag, uint32_t data)
 54863: {
 54863:     return w->output().writePair(tag, data);
 54863: }
 54863: 
 54863: JS_PUBLIC_API(JSBool)
 54863: JS_WriteBytes(JSStructuredCloneWriter *w, const void *p, size_t len)
 54863: {
 54863:     return w->output().writeBytes(p, len);
 54863: }
 54863: 
  8893: /*
  8893:  * The following determines whether C Strings are to be treated as UTF-8
  8893:  * or ISO-8859-1.  For correct operation, it must be set prior to the
  8893:  * first call to JS_NewRuntime.
  8893:  */
  8893: #ifndef JS_C_STRINGS_ARE_UTF8
  8893: JSBool js_CStringsAreUTF8 = JS_FALSE;
  8893: #endif
  8893: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_CStringsAreUTF8()
     1: {
  8893:     return js_CStringsAreUTF8;
  8893: }
  8893: 
  8893: JS_PUBLIC_API(void)
  8893: JS_SetCStringsAreUTF8()
  8893: {
  8893:     JS_ASSERT(!js_NewRuntimeWasCalled);
  8893: 
  8893: #ifndef JS_C_STRINGS_ARE_UTF8
  8893:     js_CStringsAreUTF8 = JS_TRUE;
     1: #endif
     1: }
     1: 
     1: /************************************************************************/
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ReportError(JSContext *cx, const char *format, ...)
     1: {
     1:     va_list ap;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     va_start(ap, format);
     1:     js_ReportErrorVA(cx, JSREPORT_ERROR, format, ap);
     1:     va_end(ap);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ReportErrorNumber(JSContext *cx, JSErrorCallback errorCallback,
 91237:                      void *userRef, const unsigned errorNumber, ...)
     1: {
     1:     va_list ap;
     1:     va_start(ap, errorNumber);
105518:     JS_ReportErrorNumberVA(cx, errorCallback, userRef, errorNumber, ap);
105518:     va_end(ap);
105518: }
105518: 
105518: JS_PUBLIC_API(void)
105518: JS_ReportErrorNumberVA(JSContext *cx, JSErrorCallback errorCallback,
105518:                        void *userRef, const unsigned errorNumber,
105518:                        va_list ap)
105518: {
105518:     AssertHeapIsIdle(cx);
     1:     js_ReportErrorNumberVA(cx, JSREPORT_ERROR, errorCallback, userRef,
     1:                            errorNumber, JS_TRUE, ap);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ReportErrorNumberUC(JSContext *cx, JSErrorCallback errorCallback,
 91237:                      void *userRef, const unsigned errorNumber, ...)
     1: {
     1:     va_list ap;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     va_start(ap, errorNumber);
     1:     js_ReportErrorNumberVA(cx, JSREPORT_ERROR, errorCallback, userRef,
     1:                            errorNumber, JS_FALSE, ap);
     1:     va_end(ap);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ReportWarning(JSContext *cx, const char *format, ...)
     1: {
     1:     va_list ap;
     1:     JSBool ok;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     va_start(ap, format);
     1:     ok = js_ReportErrorVA(cx, JSREPORT_WARNING, format, ap);
     1:     va_end(ap);
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 91237: JS_ReportErrorFlagsAndNumber(JSContext *cx, unsigned flags,
     1:                              JSErrorCallback errorCallback, void *userRef,
 91237:                              const unsigned errorNumber, ...)
     1: {
     1:     va_list ap;
     1:     JSBool ok;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     va_start(ap, errorNumber);
     1:     ok = js_ReportErrorNumberVA(cx, flags, errorCallback, userRef,
     1:                                 errorNumber, JS_TRUE, ap);
     1:     va_end(ap);
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 91237: JS_ReportErrorFlagsAndNumberUC(JSContext *cx, unsigned flags,
     1:                                JSErrorCallback errorCallback, void *userRef,
 91237:                                const unsigned errorNumber, ...)
     1: {
     1:     va_list ap;
     1:     JSBool ok;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     va_start(ap, errorNumber);
     1:     ok = js_ReportErrorNumberVA(cx, flags, errorCallback, userRef,
     1:                                 errorNumber, JS_FALSE, ap);
     1:     va_end(ap);
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ReportOutOfMemory(JSContext *cx)
     1: {
     1:     js_ReportOutOfMemory(cx);
     1: }
     1: 
 12983: JS_PUBLIC_API(void)
 12983: JS_ReportAllocationOverflow(JSContext *cx)
 12983: {
 12983:     js_ReportAllocationOverflow(cx);
 12983: }
 12983: 
     1: JS_PUBLIC_API(JSErrorReporter)
 87280: JS_GetErrorReporter(JSContext *cx)
 87280: {
 87280:     return cx->errorReporter;
 87280: }
 87280: 
 87280: JS_PUBLIC_API(JSErrorReporter)
     1: JS_SetErrorReporter(JSContext *cx, JSErrorReporter er)
     1: {
     1:     JSErrorReporter older;
     1: 
     1:     older = cx->errorReporter;
     1:     cx->errorReporter = er;
     1:     return older;
     1: }
     1: 
     1: /************************************************************************/
     1: 
     1: /*
 61050:  * Dates.
 61050:  */
 61050: JS_PUBLIC_API(JSObject *)
 61050: JS_NewDateObject(JSContext *cx, int year, int mon, int mday, int hour, int min, int sec)
 61050: {
103783:     AssertHeapIsIdle(cx);
 61050:     CHECK_REQUEST(cx);
 61050:     return js_NewDateObject(cx, year, mon, mday, hour, min, sec);
 61050: }
 61050: 
 61050: JS_PUBLIC_API(JSObject *)
 90955: JS_NewDateObjectMsec(JSContext *cx, double msec)
 61050: {
103783:     AssertHeapIsIdle(cx);
 61050:     CHECK_REQUEST(cx);
 61050:     return js_NewDateObjectMsec(cx, msec);
 61050: }
 61050: 
 61050: JS_PUBLIC_API(JSBool)
107154: JS_ObjectIsDate(JSContext *cx, JSRawObject obj)
 61050: {
103783:     AssertHeapIsIdle(cx);
 61050:     JS_ASSERT(obj);
 61050:     return obj->isDate();
 61050: }
 61050: 
104532: JS_PUBLIC_API(void)
104532: JS_ClearDateCaches(JSContext *cx)
104532: {
104532:     AssertHeapIsIdle(cx);
104532:     CHECK_REQUEST(cx);
104532:     js_ClearDateCaches();
104532: }
104532: 
 61050: /************************************************************************/
 61050: 
 61050: /*
     1:  * Regular Expressions.
     1:  */
     1: JS_PUBLIC_API(JSObject *)
107154: JS_NewRegExpObject(JSContext *cx, JSObject *objArg, char *bytes, size_t length, unsigned flags)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 71337:     jschar *chars = InflateString(cx, bytes, &length);
     1:     if (!chars)
     1:         return NULL;
 79981: 
 86483:     RegExpStatics *res = obj->asGlobal().getRegExpStatics();
 79981:     RegExpObject *reobj = RegExpObject::create(cx, res, chars, length, RegExpFlag(flags), NULL);
110933:     js_free(chars);
 53858:     return reobj;
 53858: }
 53858: 
 53858: JS_PUBLIC_API(JSObject *)
107154: JS_NewUCRegExpObject(JSContext *cx, JSObject *objArg, jschar *chars, size_t length, unsigned flags)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 53858:     CHECK_REQUEST(cx);
 86483:     RegExpStatics *res = obj->asGlobal().getRegExpStatics();
 79981:     return RegExpObject::create(cx, res, chars, length, RegExpFlag(flags), NULL);
 53858: }
 53858: 
 53858: JS_PUBLIC_API(void)
107154: JS_SetRegExpInput(JSContext *cx, JSObject *objArg, JSString *input, JSBool multiline)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 53858:     CHECK_REQUEST(cx);
 53858:     assertSameCompartment(cx, input);
 53858: 
 86483:     obj->asGlobal().getRegExpStatics()->reset(cx, input, !!multiline);
 53858: }
 53858: 
 53858: JS_PUBLIC_API(void)
107154: JS_ClearRegExpStatics(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 53858:     CHECK_REQUEST(cx);
 53858:     JS_ASSERT(obj);
 53858: 
 86483:     obj->asGlobal().getRegExpStatics()->clear();
 53858: }
 53858: 
 53858: JS_PUBLIC_API(JSBool)
107154: JS_ExecuteRegExp(JSContext *cx, JSObject *objArg, JSObject *reobjArg, jschar *chars, size_t length,
 53858:                  size_t *indexp, JSBool test, jsval *rval)
 53858: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedObject reobj(cx, reobjArg);
103783:     AssertHeapIsIdle(cx);
 53858:     CHECK_REQUEST(cx);
 53858: 
 86483:     RegExpStatics *res = obj->asGlobal().getRegExpStatics();
 89918:     return ExecuteRegExp(cx, res, reobj->asRegExp(), NULL, chars, length,
 80378:                          indexp, test ? RegExpTest : RegExpExec, rval);
 53858: }
 53858: 
 53858: JS_PUBLIC_API(JSObject *)
 91237: JS_NewRegExpObjectNoStatics(JSContext *cx, char *bytes, size_t length, unsigned flags)
 53858: {
103783:     AssertHeapIsIdle(cx);
 53858:     CHECK_REQUEST(cx);
 71337:     jschar *chars = InflateString(cx, bytes, &length);
 53858:     if (!chars)
 53858:         return NULL;
 79981:     RegExpObject *reobj = RegExpObject::createNoStatics(cx, chars, length, RegExpFlag(flags), NULL);
110933:     js_free(chars);
 79981:     return reobj;
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
 91237: JS_NewUCRegExpObjectNoStatics(JSContext *cx, jschar *chars, size_t length, unsigned flags)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 79981:     return RegExpObject::createNoStatics(cx, chars, length, RegExpFlag(flags), NULL);
 53858: }
 53858: 
 53858: JS_PUBLIC_API(JSBool)
107154: JS_ExecuteRegExpNoStatics(JSContext *cx, JSObject *objArg, jschar *chars, size_t length,
 53858:                           size_t *indexp, JSBool test, jsval *rval)
     1: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 50911: 
 89918:     return ExecuteRegExp(cx, NULL, obj->asRegExp(), NULL, chars, length, indexp,
 80378:                          test ? RegExpTest : RegExpExec, rval);
 53858: }
     1: 
 70279: JS_PUBLIC_API(JSBool)
107154: JS_ObjectIsRegExp(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 70279:     JS_ASSERT(obj);
 70279:     return obj->isRegExp();
 70279: }
 70279: 
 91237: JS_PUBLIC_API(unsigned)
107154: JS_GetRegExpFlags(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 70281:     CHECK_REQUEST(cx);
 70281: 
 86483:     return obj->asRegExp().getFlags();
 70281: }
 70281: 
 70281: JS_PUBLIC_API(JSString *)
107154: JS_GetRegExpSource(JSContext *cx, JSObject *objArg)
107154: {
107154:     RootedObject obj(cx, objArg);
103783:     AssertHeapIsIdle(cx);
 70281:     CHECK_REQUEST(cx);
 70281: 
 86483:     return obj->asRegExp().getSource();
 70281: }
 70281: 
     1: /************************************************************************/
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_SetLocaleCallbacks(JSContext *cx, JSLocaleCallbacks *callbacks)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     cx->localeCallbacks = callbacks;
     1: }
     1: 
     1: JS_PUBLIC_API(JSLocaleCallbacks *)
     1: JS_GetLocaleCallbacks(JSContext *cx)
     1: {
 86458:     /* This function can be called by a finalizer. */
     1:     return cx->localeCallbacks;
     1: }
     1: 
     1: /************************************************************************/
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_IsExceptionPending(JSContext *cx)
     1: {
 86458:     /* This function can be called by a finalizer. */
 60211:     return (JSBool) cx->isExceptionPending();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_GetPendingException(JSContext *cx, jsval *vp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 60211:     if (!cx->isExceptionPending())
     1:         return JS_FALSE;
 78614:     *vp = cx->getPendingException();
 60211:     assertSameCompartment(cx, *vp);
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
111462: JS_SetPendingException(JSContext *cx, jsval valueArg)
111462: {
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
111462:     cx->setPendingException(value);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ClearPendingException(JSContext *cx)
     1: {
103783:     AssertHeapIsIdle(cx);
 60211:     cx->clearPendingException();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ReportPendingException(JSContext *cx)
     1: {
103783:     AssertHeapIsIdle(cx);
 92711:     CHECK_REQUEST(cx);
 92711: 
 92711:     return js_ReportUncaughtException(cx);
     1: }
     1: 
     1: struct JSExceptionState {
     1:     JSBool throwing;
     1:     jsval  exception;
     1: };
     1: 
     1: JS_PUBLIC_API(JSExceptionState *)
     1: JS_SaveExceptionState(JSContext *cx)
     1: {
     1:     JSExceptionState *state;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
110934:     state = cx->pod_malloc<JSExceptionState>();
     1:     if (state) {
     1:         state->throwing = JS_GetPendingException(cx, &state->exception);
     1:         if (state->throwing && JSVAL_IS_GCTHING(state->exception))
 78614:             js_AddRoot(cx, &state->exception, "JSExceptionState.exception");
     1:     }
     1:     return state;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_RestoreExceptionState(JSContext *cx, JSExceptionState *state)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
     1:     if (state) {
     1:         if (state->throwing)
     1:             JS_SetPendingException(cx, state->exception);
     1:         else
     1:             JS_ClearPendingException(cx);
     1:         JS_DropExceptionState(cx, state);
     1:     }
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_DropExceptionState(JSContext *cx, JSExceptionState *state)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
     1:     if (state) {
 47485:         if (state->throwing && JSVAL_IS_GCTHING(state->exception)) {
 47485:             assertSameCompartment(cx, state->exception);
 47403:             JS_RemoveValueRoot(cx, &state->exception);
 47485:         }
110933:         js_free(state);
     1:     }
     1: }
     1: 
     1: JS_PUBLIC_API(JSErrorReport *)
111462: JS_ErrorFromException(JSContext *cx, jsval valueArg)
111462: {
111462:     RootedValue value(cx, valueArg);
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
116201:     return js_ErrorFromException(value);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ThrowReportedError(JSContext *cx, const char *message,
     1:                       JSErrorReport *reportp)
     1: {
103783:     AssertHeapIsIdle(cx);
 36234:     return JS_IsRunning(cx) &&
 36234:            js_ErrorToException(cx, message, reportp, NULL, NULL);
     1: }
     1: 
  6464: JS_PUBLIC_API(JSBool)
  6464: JS_ThrowStopIteration(JSContext *cx)
  6464: {
103783:     AssertHeapIsIdle(cx);
  6464:     return js_ThrowStopIteration(cx);
  6464: }
  6464: 
 86984: JS_PUBLIC_API(intptr_t)
 86984: JS_GetCurrentThread()
 86984: {
 11941: #ifdef JS_THREADSAFE
 88135:     return reinterpret_cast<intptr_t>(PR_GetCurrentThread());
 11941: #else
 11941:     return 0;
 11941: #endif
     1: }
     1: 
 81562: extern JS_PUBLIC_API(void)
 81562: JS_ClearRuntimeThread(JSRuntime *rt)
 81562: {
103783:     AssertHeapIsIdle(rt);
 81562: #ifdef JS_THREADSAFE
 81562:     rt->clearOwnerThread();
 81562: #endif
 81562: }
 81562: 
 81562: extern JS_PUBLIC_API(void)
 81562: JS_SetRuntimeThread(JSRuntime *rt)
 81562: {
103783:     AssertHeapIsIdle(rt);
 81562: #ifdef JS_THREADSAFE
 81562:     rt->setOwnerThread();
 81562: #endif
 81562: }
 81562: 
 81562: extern JS_NEVER_INLINE JS_PUBLIC_API(void)
 81562: JS_AbortIfWrongThread(JSRuntime *rt)
 81562: {
110844:     rt->abortIfWrongThread();
 81562: }
 81562: 
  1492: #ifdef JS_GC_ZEAL
  1492: JS_PUBLIC_API(void)
 94870: JS_SetGCZeal(JSContext *cx, uint8_t zeal, uint32_t frequency)
 71353: {
 90410:     const char *env = getenv("JS_GC_ZEAL");
 90410:     if (env) {
 98072:         if (0 == strcmp(env, "help")) {
 98072:             printf("Format: JS_GC_ZEAL=N[,F]\n"
 98072:                    "N indicates \"zealousness\":\n"
 98072:                    "  0: no additional GCs\n"
 98072:                    "  1: additional GCs at common danger points\n"
 98072:                    "  2: GC every F allocations (default: 100)\n"
 98072:                    "  3: GC when the window paints (browser only)\n"
105981:                    "  4: Verify pre write barriers between instructions\n"
105981:                    "  5: Verify pre write barriers between paints\n"
113957:                    "  6: Verify stack rooting (ignoring XML)\n"
102693:                    "  7: Verify stack rooting (all roots)\n"
102693:                    "  8: Incremental GC in two slices: 1) mark roots 2) finish collection\n"
102693:                    "  9: Incremental GC in two slices: 1) mark all 2) new marking and finish\n"
105981:                    " 10: Incremental GC in multiple slices\n"
105981:                    " 11: Verify post write barriers between instructions\n"
109045:                    " 12: Verify post write barriers between paints\n"
109045:                    " 13: Purge analysis state every F allocations (default: 100)\n");
 98072:         }
 98072:         const char *p = strchr(env, ',');
 90410:         zeal = atoi(env);
 98072:         frequency = p ? atoi(p + 1) : JS_DEFAULT_ZEAL_FREQ;
 98072:     }
 90410: 
108442:     JSRuntime *rt = cx->runtime;
108442: 
105981:     if (zeal == 0) {
108442:         if (rt->gcVerifyPreData)
108442:             VerifyBarriers(rt, PreBarrierVerifier);
108442:         if (rt->gcVerifyPostData)
108442:             VerifyBarriers(rt, PostBarrierVerifier);
105981:     }
102261: 
108442: #ifdef JS_METHODJIT
108442:     /* In case JSCompartment::compileBarriers() changed... */
108442:     for (CompartmentsIter c(rt); !c.done(); c.next())
108442:         mjit::ClearAllFrames(c);
108442: #endif
108694: 
108694:     bool schedule = zeal >= js::gc::ZealAllocValue;
108694:     rt->gcZeal_ = zeal;
108694:     rt->gcZealFrequency = frequency;
108694:     rt->gcNextScheduled = schedule ? frequency : 0;
 71353: }
 71353: 
 71353: JS_PUBLIC_API(void)
 94870: JS_ScheduleGC(JSContext *cx, uint32_t count)
 71353: {
 71353:     cx->runtime->gcNextScheduled = count;
  1492: }
  1492: #endif
  1492: 
     1: /************************************************************************/
     1: 
 67939: #if !defined(STATIC_EXPORTABLE_JS_API) && !defined(STATIC_JS_API) && defined(XP_WIN)
 11461: 
 52897: #include "jswin.h"
 11461: 
     1: /*
 11461:  * Initialization routine for the JS DLL.
     1:  */
     1: BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
     1: {
     1:     return TRUE;
     1: }
     1: 
 11461: #endif
 81418: 
 81418: JS_PUBLIC_API(JSBool)
 84755: JS_IndexToId(JSContext *cx, uint32_t index, jsid *id)
 81418: {
 81418:     return IndexToId(cx, index, id);
 81418: }
 81457: 
 82522: JS_PUBLIC_API(JSBool)
 82522: JS_IsIdentifier(JSContext *cx, JSString *str, JSBool *isIdentifier)
 82522: {
 82522:     assertSameCompartment(cx, str);
 82522: 
 82522:     JSLinearString* linearStr = str->ensureLinear(cx);
 82522:     if (!linearStr)
 82522:         return false;
 82522: 
105835:     *isIdentifier = js::frontend::IsIdentifier(linearStr);
 82522:     return true;
 82522: }
 82522: 
 92133: JS_PUBLIC_API(JSBool)
 92133: JS_DescribeScriptedCaller(JSContext *cx, JSScript **script, unsigned *lineno)
 92133: {
 92133:     if (script)
 92133:         *script = NULL;
 92133:     if (lineno)
 92133:         *lineno = 0;
 92133: 
 97161:     ScriptFrameIter i(cx);
 92133:     if (i.done())
 92133:         return JS_FALSE;
 92133: 
 92133:     if (script)
 92133:         *script = i.script();
 92133:     if (lineno)
 92133:         *lineno = js::PCToLineNumber(i.script(), i.pc());
 92133:     return JS_TRUE;
 92133: }
 92133: 
 81457: #ifdef JS_THREADSAFE
 81457: static PRStatus
 81457: CallOnce(void *func)
 81457: {
 81457:     JSInitCallback init = JS_DATA_TO_FUNC_PTR(JSInitCallback, func);
 81457:     return init() ? PR_SUCCESS : PR_FAILURE;
 81457: }
 81457: #endif
 81457: 
 81457: JS_PUBLIC_API(JSBool)
 81457: JS_CallOnce(JSCallOnceType *once, JSInitCallback func)
 81457: {
 81457: #ifdef JS_THREADSAFE
 81457:     return PR_CallOnceWithArg(once, CallOnce, JS_FUNC_TO_DATA_PTR(void *, func)) == PR_SUCCESS;
 81457: #else
 81457:     if (!*once) {
 81457:         *once = true;
 81457:         return func();
 81457:     } else {
 81457:         return JS_TRUE;
 81457:     }
 81457: #endif
 81457: }
 86988: 
 86988: namespace JS {
 86988: 
 86988: AutoGCRooter::AutoGCRooter(JSContext *cx, ptrdiff_t tag)
 91250:   : down(cx->runtime->autoGCRooters), tag(tag), stackTop(&cx->runtime->autoGCRooters)
 91250: {
 91250:     JS_ASSERT(this != *stackTop);
 91250:     *stackTop = this;
 86988: }
 86988: 
 94326: #ifdef DEBUG
 94326: JS_PUBLIC_API(void)
111462: AssertArgumentsAreSane(JSContext *cx, const JS::Value &value)
111462: {
111462:     AssertHeapIsIdle(cx);
111462:     CHECK_REQUEST(cx);
111462:     assertSameCompartment(cx, value);
 94326: }
 94326: #endif /* DEBUG */
 94326: 
 86988: } // namespace JS
 94006: 
 94006: JS_PUBLIC_API(void *)
116202: JS_EncodeScript(JSContext *cx, JSRawScript scriptArg, uint32_t *lengthp)
 94006: {
 94006:     XDREncoder encoder(cx);
116202:     RootedScript script(cx, scriptArg);
 94006:     if (!encoder.codeScript(&script))
 94006:         return NULL;
 94006:     return encoder.forgetData(lengthp);
 94006: }
 94006: 
 94006: JS_PUBLIC_API(void *)
107154: JS_EncodeInterpretedFunction(JSContext *cx, JSRawObject funobjArg, uint32_t *lengthp)
 94006: {
 94006:     XDREncoder encoder(cx);
107154:     RootedObject funobj(cx, funobjArg);
 94006:     if (!encoder.codeFunction(&funobj))
 94006:         return NULL;
 94006:     return encoder.forgetData(lengthp);
 94006: }
 94006: 
 94006: JS_PUBLIC_API(JSScript *)
 94006: JS_DecodeScript(JSContext *cx, const void *data, uint32_t length,
 94006:                 JSPrincipals *principals, JSPrincipals *originPrincipals)
 94006: {
 94006:     XDRDecoder decoder(cx, data, length, principals, originPrincipals);
116202:     RootedScript script(cx);
 94006:     if (!decoder.codeScript(&script))
 94006:         return NULL;
 94006:     return script;
 94006: }
 94006: 
 94006: JS_PUBLIC_API(JSObject *)
 94006: JS_DecodeInterpretedFunction(JSContext *cx, const void *data, uint32_t length,
 94006:                              JSPrincipals *principals, JSPrincipals *originPrincipals)
 94006: {
 94006:     XDRDecoder decoder(cx, data, length, principals, originPrincipals);
107154:     RootedObject funobj(cx);
 94006:     if (!decoder.codeFunction(&funobj))
 94006:         return NULL;
 94006:     return funobj;
 94006: }
 95519: 
 95519: JS_PUBLIC_API(JSObject *)
 95519: JS_GetScriptedGlobal(JSContext *cx)
 95519: {
 97161:     ScriptFrameIter i(cx);
 95519:     if (i.done())
109255:         return cx->global();
109255:     return &i.fp()->global();
109255: }
109255: 
