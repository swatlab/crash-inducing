    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 3573:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *   Mike Shaver <shaver@mozilla.org>
    1:  *   Mark Hammond <MarkH@ActiveState.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* All the XPConnect private declarations - only include locally. */
    1: 
    1: #ifndef xpcprivate_h___
    1: #define xpcprivate_h___
    1: 
    1: #include <string.h>
    1: #include <stdlib.h>
    1: #include <stdarg.h>
    1: #include <math.h>
    1: #include "nscore.h"
    1: #include "nsXPCOM.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsCycleCollectionParticipant.h"
    1: #include "nsCycleCollector.h"
    1: #include "nsISupports.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIClassInfoImpl.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIComponentRegistrar.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsIGenericFactory.h"
    1: #include "nsMemory.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIInterfaceInfo.h"
    1: #include "nsIInterfaceInfoManager.h"
    1: #include "nsIXPCScriptable.h"
    1: #include "nsIXPCSecurityManager.h"
    1: #include "nsIJSRuntimeService.h"
    1: #include "nsWeakReference.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIModule.h"
    1: #include "nsAutoLock.h"
    1: #include "nsXPTCUtils.h"
    1: #include "jsapi.h"
    1: #include "jsdhash.h"
    1: #include "jsprf.h"
    1: #include "prprf.h"
    1: #include "jsinterp.h"
    1: #include "jscntxt.h"
    1: #include "jsdbgapi.h"
    1: #include "jsgc.h"
    1: #include "xptinfo.h"
    1: #include "xpcforwards.h"
    1: #include "xpclog.h"
    1: #include "xpccomponents.h"
    1: #include "xpcexception.h"
    1: #include "xpcjsid.h"
    1: #include "prlong.h"
    1: #include "prmem.h"
    1: #include "prenv.h"
 9848: #include "prclist.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsXPIDLString.h"
21377: #include "nsAutoJSValHolder.h"
    1: 
    1: #include "nsThreadUtils.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsDeque.h"
    1: #include "nsVoidArray.h"
    1: 
    1: #include "nsIConsoleService.h"
    1: #include "nsIScriptError.h"
    1: #include "nsIExceptionService.h"
    1: 
    1: #include "nsVariant.h"
    1: #include "nsIPropertyBag.h"
    1: #include "nsIProperty.h"
    1: #include "nsSupportsArray.h"
 1104: #include "nsTArray.h"
 7286: #include "nsBaseHashtable.h"
 7286: #include "nsHashKeys.h"
    1: 
    1: #include "nsIXPCScriptNotify.h"  // used to notify: ScriptEvaluated
    1: 
    1: #ifndef XPCONNECT_STANDALONE
    1: #define XPC_USE_SECURITY_CHECKED_COMPONENT
    1: #include "nsIScriptObjectPrincipal.h"
    1: #include "nsIPrincipal.h"
    1: #endif
    1: 
    1: #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
    1: #include "nsISecurityCheckedComponent.h"
    1: #endif
    1: 
    1: #ifdef XPC_TOOLS_SUPPORT
    1: #include "nsIXPCToolsProfiler.h"
    1: #endif
    1: 
 3310: #include "nsIThreadInternal.h"
 3310: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1: // This goop was added because of EXCEPINFO in ThrowCOMError
    1: // This include is here, because it needs to occur before the undefines below
    1: #include <atlbase.h>
    1: #include "oaidl.h"
    1: // Nasty MS defines
    1: #undef GetClassInfo
    1: #undef GetClassName
    1: #endif
    1: 
    1: /***************************************************************************/
    1: // Compile time switches for instrumentation and stuff....
    1: 
    1: // Note that one would not normally turn *any* of these on in a non-DEBUG build.
    1: 
    1: #if defined(DEBUG_jband) || defined(DEBUG_jst) || defined(DEBUG_dbradley) || defined(DEBUG_shaver_no) || defined(DEBUG_timeless)
    1: #define DEBUG_xpc_hacker
    1: #endif
    1: 
    1: #if defined(DEBUG_brendan)
    1: #define DEBUG_XPCNativeWrapper 1
    1: #endif
    1: 
    1: #ifdef DEBUG
    1: #define XPC_DETECT_LEADING_UPPERCASE_ACCESS_ERRORS
    1: #define XPC_CHECK_WRAPPER_THREADSAFETY
    1: #endif
    1: 
    1: #if defined(DEBUG_xpc_hacker)
    1: #define XPC_DUMP_AT_SHUTDOWN
    1: #define XPC_TRACK_WRAPPER_STATS
    1: #define XPC_TRACK_SCOPE_STATS
    1: #define XPC_TRACK_PROTO_STATS
    1: #define XPC_TRACK_DEFERRED_RELEASES
    1: #define XPC_CHECK_WRAPPERS_AT_SHUTDOWN
    1: #define XPC_REPORT_SHADOWED_WRAPPED_NATIVE_MEMBERS
    1: #define XPC_CHECK_CLASSINFO_CLAIMS
    1: #if defined(DEBUG_jst)
    1: #define XPC_ASSERT_CLASSINFO_CLAIMS
    1: #endif
    1: //#define DEBUG_stats_jband 1
    1: //#define XPC_REPORT_NATIVE_INTERFACE_AND_SET_FLUSHING
    1: //#define XPC_REPORT_JSCLASS_FLUSHING
    1: //#define XPC_TRACK_AUTOMARKINGPTR_STATS
    1: #endif
    1: 
    1: #if defined(DEBUG_dbaron) || defined(DEBUG_bzbarsky) // only part of DEBUG_xpc_hacker!
    1: #define XPC_DUMP_AT_SHUTDOWN
    1: #endif
    1: 
    1: /***************************************************************************/
    1: // conditional forward declarations....
    1: 
    1: #ifdef XPC_REPORT_SHADOWED_WRAPPED_NATIVE_MEMBERS
    1: void DEBUG_ReportShadowedMembers(XPCNativeSet* set,
    1:                                  XPCWrappedNative* wrapper,
    1:                                  XPCWrappedNativeProto* proto);
    1: #else
    1: #define DEBUG_ReportShadowedMembers(set, wrapper, proto) ((void)0)
    1: #endif
    1: 
    1: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
    1: void DEBUG_ReportWrapperThreadSafetyError(XPCCallContext& ccx,
    1:                                           const char* msg,
    1:                                           const XPCWrappedNative* wrapper);
    1: void DEBUG_CheckWrapperThreadSafety(const XPCWrappedNative* wrapper);
    1: #else
    1: #define DEBUG_CheckWrapperThreadSafety(w) ((void)0)
    1: #endif
    1: 
    1: /***************************************************************************/
    1: 
    1: // Defeat possible Windows macro-mangling of the name
    1: #ifdef GetClassInfo
    1: #undef GetClassInfo
    1: #endif
    1: 
    1: /***************************************************************************/
    1: // default initial sizes for maps (hashtables)
    1: 
    1: #define XPC_CONTEXT_MAP_SIZE                16
    1: #define XPC_JS_MAP_SIZE                     64
    1: #define XPC_JS_CLASS_MAP_SIZE               64
    1: 
    1: #define XPC_NATIVE_MAP_SIZE                 64
    1: #define XPC_NATIVE_PROTO_MAP_SIZE           16
    1: #define XPC_DYING_NATIVE_PROTO_MAP_SIZE     16
    1: #define XPC_DETACHED_NATIVE_PROTO_MAP_SIZE  32
    1: #define XPC_NATIVE_INTERFACE_MAP_SIZE       64
    1: #define XPC_NATIVE_SET_MAP_SIZE             64
    1: #define XPC_NATIVE_JSCLASS_MAP_SIZE         32
    1: #define XPC_THIS_TRANSLATOR_MAP_SIZE         8
    1: #define XPC_NATIVE_WRAPPER_MAP_SIZE         16
 4042: #define XPC_WRAPPER_MAP_SIZE                 8
    1: 
    1: /***************************************************************************/
    1: // data declarations...
    1: extern const char* XPC_ARG_FORMATTER_FORMAT_STRINGS[]; // format strings
    1: extern const char XPC_CONTEXT_STACK_CONTRACTID[];
    1: extern const char XPC_RUNTIME_CONTRACTID[];
    1: extern const char XPC_EXCEPTION_CONTRACTID[];
    1: extern const char XPC_CONSOLE_CONTRACTID[];
    1: extern const char XPC_SCRIPT_ERROR_CONTRACTID[];
    1: extern const char XPC_ID_CONTRACTID[];
    1: extern const char XPC_XPCONNECT_CONTRACTID[];
    1: 
    1: /***************************************************************************/
    1: // useful macros...
    1: 
    1: #define XPC_STRING_GETTER_BODY(dest, src) \
    1:     NS_ENSURE_ARG_POINTER(dest); \
    1:     char* result; \
    1:     if(src) \
    1:         result = (char*) nsMemory::Clone(src, \
    1:                                 sizeof(char)*(strlen(src)+1)); \
    1:     else \
    1:         result = nsnull; \
    1:     *dest = result; \
    1:     return (result || !src) ? NS_OK : NS_ERROR_OUT_OF_MEMORY
    1: 
 8990: 
 8990: // NOTE!!!
 8990: //
 8990: // If this ever changes,
 8990: // nsScriptSecurityManager::doGetObjectPrincipal() *must* be updated
 8990: // also!
 8990: //
 8990: // NOTE!!!
 8869: #define IS_WRAPPER_CLASS(clazz)                                               \
 8869:           ((clazz) == &XPC_WN_NoHelper_JSClass.base ||                        \
 8869:            (clazz)->getObjectOps == XPC_WN_GetObjectOpsNoCall ||              \
 8869:            (clazz)->getObjectOps == XPC_WN_GetObjectOpsWithCall)
 8869: 
    1: /***************************************************************************/
    1: // Auto locking support class...
    1: 
    1: // We PROMISE to never screw this up.
    1: #ifdef _MSC_VER
    1: #pragma warning(disable : 4355) // OK to pass "this" in member initializer
    1: #endif
    1: 
    1: typedef PRMonitor XPCLock;
    1: 
    1: static inline void xpc_Wait(XPCLock* lock) 
    1:     {
    1:         NS_ASSERTION(lock, "xpc_Wait called with null lock!");
    1: #ifdef DEBUG
    1:         PRStatus result = 
    1: #endif
    1:         PR_Wait(lock, PR_INTERVAL_NO_TIMEOUT);
    1:         NS_ASSERTION(PR_SUCCESS == result, "bad result from PR_Wait!");
    1:     }
    1: 
    1: static inline void xpc_NotifyAll(XPCLock* lock) 
    1:     {
    1:         NS_ASSERTION(lock, "xpc_NotifyAll called with null lock!");
    1: #ifdef DEBUG
    1:         PRStatus result = 
    1: #endif    
    1:         PR_NotifyAll(lock);
    1:         NS_ASSERTION(PR_SUCCESS == result, "bad result from PR_NotifyAll!");
    1:     }
    1: 
    1: // This is a cloned subset of nsAutoMonitor. We want the use of a monitor -
    1: // mostly because we need reenterability - but we also want to support passing
    1: // a null monitor in without things blowing up. This is used for wrappers that
    1: // are guaranteed to be used only on one thread. We avoid lock overhead by
    1: // using a null monitor. By changing this class we can avoid having multiplte
    1: // code paths or (conditional) manual calls to PR_{Enter,Exit}Monitor.
    1: //
    1: // Note that xpconnect only makes *one* monitor and *mostly* holds it locked
    1: // only through very small critical sections.
    1: 
    1: class XPCAutoLock : public nsAutoLockBase {
    1: public:
    1: 
    1:     static XPCLock* NewLock(const char* name)
    1:                         {return nsAutoMonitor::NewMonitor(name);}
    1:     static void     DestroyLock(XPCLock* lock)
    1:                         {nsAutoMonitor::DestroyMonitor(lock);}
    1: 
    1:     XPCAutoLock(XPCLock* lock)
    1: #ifdef DEBUG_jband
    1:         : nsAutoLockBase(lock ? (void*) lock : (void*) this, eAutoMonitor),
    1: #else
    1:         : nsAutoLockBase(lock, eAutoMonitor),
    1: #endif
    1:           mLock(lock)
    1:     {
    1:         if(mLock)
    1:             PR_EnterMonitor(mLock);
    1:     }
    1: 
    1:     ~XPCAutoLock()
    1:     {
    1:         if(mLock)
    1:         {
    1: #ifdef DEBUG
    1:             PRStatus status =
    1: #endif
    1:                 PR_ExitMonitor(mLock);
    1:             NS_ASSERTION(status == PR_SUCCESS, "PR_ExitMonitor failed");
    1:         }
    1:     }
    1: 
    1: private:
    1:     XPCLock*  mLock;
    1: 
    1:     // Not meant to be implemented. This makes it a compiler error to
    1:     // construct or assign an XPCAutoLock object incorrectly.
    1:     XPCAutoLock(void) {}
    1:     XPCAutoLock(XPCAutoLock& /*aMon*/) {}
    1:     XPCAutoLock& operator =(XPCAutoLock& /*aMon*/) {
    1:         return *this;
    1:     }
    1: 
    1:     // Not meant to be implemented. This makes it a compiler error to
    1:     // attempt to create an XPCAutoLock object on the heap.
    1:     static void* operator new(size_t /*size*/) CPP_THROW_NEW {
    1:         return nsnull;
    1:     }
    1:     static void operator delete(void* /*memory*/) {}
    1: };
    1: 
    1: /************************************************/
    1: 
    1: class XPCAutoUnlock : public nsAutoUnlockBase {
    1: public:
    1:     XPCAutoUnlock(XPCLock* lock)
    1:         : nsAutoUnlockBase(lock),
    1:           mLock(lock)
    1:     {
    1:         if(mLock)
    1:         {
    1: #ifdef DEBUG
    1:             PRStatus status =
    1: #endif
    1:                 PR_ExitMonitor(mLock);
    1:             NS_ASSERTION(status == PR_SUCCESS, "PR_ExitMonitor failed");
    1:         }
    1:     }
    1: 
    1:     ~XPCAutoUnlock()
    1:     {
    1:         if(mLock)
    1:             PR_EnterMonitor(mLock);
    1:     }
    1: 
    1: private:
    1:     XPCLock*  mLock;
    1: 
    1:     // Not meant to be implemented. This makes it a compiler error to
    1:     // construct or assign an XPCAutoUnlock object incorrectly.
    1:     XPCAutoUnlock(void) {}
    1:     XPCAutoUnlock(XPCAutoUnlock& /*aMon*/) {}
    1:     XPCAutoUnlock& operator =(XPCAutoUnlock& /*aMon*/) {
    1:         return *this;
    1:     }
    1: 
    1:     // Not meant to be implemented. This makes it a compiler error to
    1:     // attempt to create an XPCAutoUnlock object on the heap.
    1:     static void* operator new(size_t /*size*/) CPP_THROW_NEW {
    1:         return nsnull;
    1:     }
    1:     static void operator delete(void* /*memory*/) {}
    1: };
    1: 
    1: // A helper class to deal with temporary JS contexts. It destroys the context
    1: // when it goes out of scope.
    1: class XPCAutoJSContext
    1: {
    1: public:
    1:     XPCAutoJSContext(JSContext *aContext, PRBool aGCOnDestroy)
    1:         : mContext(aContext), mGCOnDestroy(aGCOnDestroy)
    1:     {
    1:     }
    1: 
    1:     ~XPCAutoJSContext()
    1:     {
    1:         if(!mContext)
    1:             return;
    1: 
    1:         if(mGCOnDestroy)
    1:             JS_DestroyContext(mContext);
    1:         else
    1:             JS_DestroyContextNoGC(mContext);
    1:     }
    1: 
    1:     operator JSContext * () {return mContext;}
    1: 
    1: private:
    1:     JSContext *mContext;
    1:     PRBool mGCOnDestroy;
    1: };
    1: 
    1: /***************************************************************************
    1: ****************************************************************************
    1: *
    1: * Core runtime and context classes...
    1: *
    1: ****************************************************************************
    1: ***************************************************************************/
    1: 
    1: // We have a general rule internally that getters that return addref'd interface
    1: // pointer generally do so using an 'out' parm. When interface pointers are
    1: // returned as function call result values they are not addref'd. Exceptions
    1: // to this rule are noted explicitly.
    1: 
    1: const PRBool OBJ_IS_GLOBAL = PR_TRUE;
    1: const PRBool OBJ_IS_NOT_GLOBAL = PR_FALSE;
    1: 
20312: #define NS_JS_RUNTIME_SERVICE_CID \
20312: {0xb5e65b52, 0x1dd1, 0x11b2, \
20312:     { 0xae, 0x8f, 0xf0, 0x92, 0x8e, 0xd8, 0x84, 0x82 }}
20312: 
20462: #define NS_XPC_THREAD_JSCONTEXT_STACK_CID  \
20462: { 0xff8c4d10, 0x3194, 0x11d3, \
20462:     { 0x98, 0x85, 0x0, 0x60, 0x8, 0x96, 0x24, 0x22 } }
20462: 
    1: class nsXPConnect : public nsIXPConnect,
 3310:                     public nsIThreadObserver,
    1:                     public nsSupportsWeakReference,
 7286:                     public nsCycleCollectionJSRuntime,
20312:                     public nsCycleCollectionParticipant,
20462:                     public nsIJSRuntimeService,
20462:                     public nsIThreadJSContextStack
    1: {
    1: public:
    1:     // all the interface method declarations...
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIXPCONNECT
 3310:     NS_DECL_NSITHREADOBSERVER
20312:     NS_DECL_NSIJSRUNTIMESERVICE
20462:     NS_DECL_NSIJSCONTEXTSTACK
20462:     NS_DECL_NSITHREADJSCONTEXTSTACK
    1: 
    1:     // non-interface implementation
    1: public:
    1:     // These get non-addref'd pointers
    1:     static nsXPConnect*  GetXPConnect();
20312:     static XPCJSRuntime* GetRuntimeInstance();
20312:     XPCJSRuntime* GetRuntime() {return mRuntime;}
    1: 
    1:     // Gets addref'd pointer
    1:     static nsresult GetInterfaceInfoManager(nsIInterfaceInfoSuperManager** iim,
    1:                                             nsXPConnect* xpc = nsnull);
    1: 
    1:     static JSBool IsISupportsDescendant(nsIInterfaceInfo* info);
    1: 
    1:     nsIXPCSecurityManager* GetDefaultSecurityManager() const
    1:         {return mDefaultSecurityManager;}
    1: 
    1:     PRUint16 GetDefaultSecurityManagerFlags() const
    1:         {return mDefaultSecurityManagerFlags;}
    1: 
    1:     // This returns an AddRef'd pointer. It does not do this with an 'out' param
    1:     // only because this form is required by the generic module macro:
    1:     // NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR
    1:     static nsXPConnect* GetSingleton();
    1: 
    1:     // Called by module code in dll startup
    1:     static void InitStatics() { gSelf = nsnull; gOnceAliveNowDead = JS_FALSE; }
    1:     // Called by module code on dll shutdown.
    1:     static void ReleaseXPConnectSingleton();
    1: 
    1:     virtual ~nsXPConnect();
    1: 
    1:     JSBool IsShuttingDown() const {return mShuttingDown;}
    1: 
    1:     nsresult GetInfoForIID(const nsIID * aIID, nsIInterfaceInfo** info);
    1:     nsresult GetInfoForName(const char * name, nsIInterfaceInfo** info);
    1: 
 3669:     // nsCycleCollectionParticipant
10981:     NS_IMETHOD RootAndUnlinkJSObjects(void *p);
 1829:     NS_IMETHOD Unlink(void *p);
 1829:     NS_IMETHOD Unroot(void *p);
 1829:     NS_IMETHOD Traverse(void *p,
 1829:                         nsCycleCollectionTraversalCallback &cb);
 3669:     
 3669:     // nsCycleCollectionLanguageRuntime
 7286:     virtual nsresult BeginCycleCollection(nsCycleCollectionTraversalCallback &cb);
 3669:     virtual nsresult FinishCycleCollection();
 3669:     virtual nsCycleCollectionParticipant *ToParticipant(void *p);
10141:     virtual PRBool Collect();
 5183: #ifdef DEBUG_CC
 5183:     virtual void PrintAllReferencesTo(void *p);
 5183: #endif
 1829: 
 7286:     // We should not trace XPConnect JS roots when tracing the graph for the
 7286:     // cycle collector. Those should be traced from the XPCOM objects that hold
 7286:     // them when we know that they won't be collected by the cycle collector.
 7286:     PRBool ShouldTraceRoots()
 7286:     {
 7286:         return !mCycleCollecting;
 7286:     }
 7230: 
 7286:     XPCCallContext* GetCycleCollectionContext()
 7286:     {
 7286:         return mCycleCollectionContext;
 7286:     }
 7286: 
 7286:     PRInt32 GetRequestDepth(JSContext* cx);
 7286: 
 7286:     // This returns the singleton nsCycleCollectionParticipant for JSContexts.
 7286:     static nsCycleCollectionParticipant *JSContextParticipant();
 7286: 
    1: #ifndef XPCONNECT_STANDALONE
    1:     void RecordTraversal(void *p, nsISupports *s);
    1: #endif
14170:     static PRBool ReportAllJSExceptions()
14170:     {
14170:       return gReportAllJSExceptions > 0;
14170:     }
    1: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1: public:
    1:     static PRBool IsIDispatchEnabled();
    1: #endif
    1: protected:
    1:     nsXPConnect();
    1: 
    1: private:
    1:     static PRThread* FindMainThread();
    1: 
    1: private:
    1:     // Singleton instance
    1:     static nsXPConnect*      gSelf;
    1:     static JSBool            gOnceAliveNowDead;
    1: 
    1:     XPCJSRuntime*            mRuntime;
    1:     nsCOMPtr<nsIInterfaceInfoSuperManager> mInterfaceInfoManager;
    1:     nsIXPCSecurityManager*   mDefaultSecurityManager;
    1:     PRUint16                 mDefaultSecurityManagerFlags;
    1:     JSBool                   mShuttingDown;
 1084:     XPCCallContext*          mCycleCollectionContext;
 7286: #ifdef DEBUG_CC
 7286:     nsAutoPtr<XPCCallContext> mExplainCycleCollectionContext;
 7286:     PLDHashTable             mJSRoots;
 7286: #endif
 7286:     PRBool                   mCycleCollecting;
    1: 
    1: #ifdef XPC_TOOLS_SUPPORT
    1:     nsCOMPtr<nsIXPCToolsProfiler> mProfiler;
    1:     nsCOMPtr<nsILocalFile>        mProfilerOutputFile;
    1: #endif
    1: 
 7286: #ifndef XPCONNECT_STANDALONE
 7286:     typedef nsBaseHashtable<nsVoidPtrHashKey, nsISupports*, nsISupports*> ScopeSet;
 7286:     ScopeSet mScopes;
 7286: #endif
20312:     nsCOMPtr<nsIXPCScriptable> mBackstagePass;
20312: 
14170:     static PRUint32 gReportAllJSExceptions;
    1: };
    1: 
    1: /***************************************************************************/
    1: 
 2072: class XPCRootSetElem
 2072: {
 2072: public:
 2072:     XPCRootSetElem()
 2072:     {
 2072: #ifdef DEBUG
 2072:         mNext = nsnull;
 2072:         mSelfp = nsnull;
 2072: #endif
 2072:     }
 2072: 
 2072:     ~XPCRootSetElem()
 2072:     {
 2072:         NS_ASSERTION(!mNext, "Must be unlinked");
 2072:         NS_ASSERTION(!mSelfp, "Must be unlinked");
 2072:     }
 2072: 
 2072:     inline XPCRootSetElem* GetNextRoot() { return mNext; }
 2072:     void AddToRootSet(JSRuntime* rt, XPCRootSetElem** listHead);
 2072:     void RemoveFromRootSet(JSRuntime* rt);
 2072: 
 2072: private:
 2072:     XPCRootSetElem *mNext;
 2072:     XPCRootSetElem **mSelfp;
 2072: };
 2072: 
 2072: /***************************************************************************/
 2072: 
    1: // In the current xpconnect system there can only be one XPCJSRuntime.
    1: // So, xpconnect can only be used on one JSRuntime within the process.
    1: 
    1: // no virtuals. no refcounting.
    1: class XPCJSRuntime
    1: {
    1: public:
20312:     static XPCJSRuntime* newXPCJSRuntime(nsXPConnect* aXPConnect);
    1: 
    1:     JSRuntime*     GetJSRuntime() const {return mJSRuntime;}
    1:     nsXPConnect*   GetXPConnect() const {return mXPConnect;}
    1: 
    1:     JSObject2WrappedJSMap*     GetWrappedJSMap()        const
    1:         {return mWrappedJSMap;}
    1: 
    1:     IID2WrappedJSClassMap*     GetWrappedJSClassMap()   const
    1:         {return mWrappedJSClassMap;}
    1: 
    1:     IID2NativeInterfaceMap* GetIID2NativeInterfaceMap() const
    1:         {return mIID2NativeInterfaceMap;}
    1: 
    1:     ClassInfo2NativeSetMap* GetClassInfo2NativeSetMap() const
    1:         {return mClassInfo2NativeSetMap;}
    1: 
    1:     NativeSetMap* GetNativeSetMap() const
    1:         {return mNativeSetMap;}
    1: 
    1:     IID2ThisTranslatorMap* GetThisTranslatorMap() const
    1:         {return mThisTranslatorMap;}
    1: 
    1:     XPCNativeScriptableSharedMap* GetNativeScriptableSharedMap() const
    1:         {return mNativeScriptableSharedMap;}
    1: 
    1:     XPCWrappedNativeProtoMap* GetDyingWrappedNativeProtoMap() const
    1:         {return mDyingWrappedNativeProtoMap;}
    1: 
    1:     XPCWrappedNativeProtoMap* GetDetachedWrappedNativeProtoMap() const
    1:         {return mDetachedWrappedNativeProtoMap;}
    1: 
    1:     XPCNativeWrapperMap* GetExplicitNativeWrapperMap() const
    1:         {return mExplicitNativeWrapperMap;}
    1: 
    1:     XPCLock* GetMapLock() const {return mMapLock;}
    1: 
20312:     JSBool OnJSContextNew(JSContext* cx);
    1: 
    1:     JSBool DeferredRelease(nsISupports* obj);
    1: 
    1:     JSBool GetDoingFinalization() const {return mDoingFinalization;}
    1: 
    1:     // Mapping of often used strings to jsid atoms that live 'forever'.
    1:     //
    1:     // To add a new string: add to this list and to XPCJSRuntime::mStrings
    1:     // at the top of xpcjsruntime.cpp
    1:     enum {
    1:         IDX_CONSTRUCTOR             = 0 ,
    1:         IDX_TO_STRING               ,
    1:         IDX_TO_SOURCE               ,
    1:         IDX_LAST_RESULT             ,
    1:         IDX_RETURN_CODE             ,
    1:         IDX_VALUE                   ,
    1:         IDX_QUERY_INTERFACE         ,
    1:         IDX_COMPONENTS              ,
    1:         IDX_WRAPPED_JSOBJECT        ,
    1:         IDX_OBJECT                  ,
    1:         IDX_FUNCTION                ,
    1:         IDX_PROTOTYPE               ,
    1:         IDX_CREATE_INSTANCE         ,
    1:         IDX_ITEM                    ,
 6464:         IDX_PROTO                   ,
 6464:         IDX_ITERATOR                ,
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:         IDX_ACTIVEX_OBJECT          ,
    1:         IDX_COM_OBJECT              ,
    1:         IDX_ACTIVEX_SUPPORTS        ,
    1: #endif
    1:         IDX_TOTAL_COUNT // just a count of the above
    1:     };
    1: 
    1:     jsid GetStringID(uintN index) const
    1:     {
    1:         NS_ASSERTION(index < IDX_TOTAL_COUNT, "index out of range");
    1:         return mStrIDs[index];
    1:     }
    1:     jsval GetStringJSVal(uintN index) const
    1:     {
    1:         NS_ASSERTION(index < IDX_TOTAL_COUNT, "index out of range");
    1:         return mStrJSVals[index];
    1:     }
    1:     const char* GetStringName(uintN index) const
    1:     {
    1:         NS_ASSERTION(index < IDX_TOTAL_COUNT, "index out of range");
    1:         return mStrings[index];
    1:     }
    1: 
18907:     static void TraceJS(JSTracer* trc, void* data);
 7230:     void TraceXPConnectRoots(JSTracer *trc);
 7230:     void AddXPConnectRoots(JSContext* cx,
 7230:                            nsCycleCollectionTraversalCallback& cb);
 1025: 
18907:     static JSBool GCCallback(JSContext *cx, JSGCStatus status);
    1: 
 2072:     inline void AddVariantRoot(XPCTraceableVariant* variant);
 2072:     inline void AddWrappedJSRoot(nsXPCWrappedJS* wrappedJS);
 2072:     inline void AddObjectHolderRoot(XPCJSObjectHolder* holder);
 2072: 
 7230:     nsresult AddJSHolder(void* aHolder, nsScriptObjectTracer* aTracer);
 7230:     nsresult RemoveJSHolder(void* aHolder);
 7230: 
 7286:     void UnsetContextGlobals();
 7286:     void RestoreContextGlobals();
 7286:     JSObject* GetUnsetContextGlobal(JSContext* cx);
 7286: 
    1:     void DebugDump(PRInt16 depth);
    1: 
 2991:     void SystemIsBeingShutDown(JSContext* cx);
    1: 
    1:     PRThread* GetThreadRunningGC() const {return mThreadRunningGC;}
    1: 
    1:     ~XPCJSRuntime();
    1: 
    1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
    1:    void DEBUG_AddWrappedNative(nsIXPConnectWrappedNative* wrapper)
    1:         {XPCAutoLock lock(GetMapLock());
    1:          JSDHashEntryHdr *entry =
    1:             JS_DHashTableOperate(DEBUG_WrappedNativeHashtable,
    1:                                  wrapper, JS_DHASH_ADD);
    1:          if(entry) ((JSDHashEntryStub *)entry)->key = wrapper;}
    1: 
    1:    void DEBUG_RemoveWrappedNative(nsIXPConnectWrappedNative* wrapper)
    1:         {XPCAutoLock lock(GetMapLock());
    1:          JS_DHashTableOperate(DEBUG_WrappedNativeHashtable,
    1:                               wrapper, JS_DHASH_REMOVE);}
    1: private:
    1:    JSDHashTable* DEBUG_WrappedNativeHashtable;
    1: public:
    1: #endif
    1: 
    1: private:
    1:     XPCJSRuntime(); // no implementation
20312:     XPCJSRuntime(nsXPConnect* aXPConnect);
    1: 
    1: private:
    1:     static const char* mStrings[IDX_TOTAL_COUNT];
    1:     jsid mStrIDs[IDX_TOTAL_COUNT];
    1:     jsval mStrJSVals[IDX_TOTAL_COUNT];
    1: 
    1:     nsXPConnect* mXPConnect;
    1:     JSRuntime*  mJSRuntime;
    1:     JSObject2WrappedJSMap*   mWrappedJSMap;
    1:     IID2WrappedJSClassMap*   mWrappedJSClassMap;
    1:     IID2NativeInterfaceMap*  mIID2NativeInterfaceMap;
    1:     ClassInfo2NativeSetMap*  mClassInfo2NativeSetMap;
    1:     NativeSetMap*            mNativeSetMap;
    1:     IID2ThisTranslatorMap*   mThisTranslatorMap;
    1:     XPCNativeScriptableSharedMap* mNativeScriptableSharedMap;
    1:     XPCWrappedNativeProtoMap* mDyingWrappedNativeProtoMap;
    1:     XPCWrappedNativeProtoMap* mDetachedWrappedNativeProtoMap;
    1:     XPCNativeWrapperMap*     mExplicitNativeWrapperMap;
    1:     XPCLock* mMapLock;
    1:     PRThread* mThreadRunningGC;
    1:     nsVoidArray mWrappedJSToReleaseArray;
    1:     nsVoidArray mNativesToReleaseArray;
    1:     JSBool mDoingFinalization;
 2072:     XPCRootSetElem *mVariantRoots;
 2072:     XPCRootSetElem *mWrappedJSRoots;
 2072:     XPCRootSetElem *mObjectHolderRoots;
 7230:     JSDHashTable mJSHolders;
 7286:     JSDHashTable mClearedGlobalObjects;
    1: };
    1: 
    1: /***************************************************************************/
    1: /***************************************************************************/
    1: // XPCContext is mostly a dumb class to hold JSContext specific data and
    1: // maps that let us find wrappers created for the given JSContext.
    1: 
    1: // no virtuals
    1: class XPCContext
    1: {
20312:     friend class XPCJSRuntime;
    1: public:
20312:     static XPCContext* GetXPCContext(JSContext* aJSContext)
20312:         {
20312:             NS_ASSERTION(aJSContext->data2, "should already have XPCContext");
20312:             return static_cast<XPCContext *>(aJSContext->data2);
20312:         }
    1: 
    1:     XPCJSRuntime* GetRuntime() const {return mRuntime;}
    1:     JSContext* GetJSContext() const {return mJSContext;}
    1: 
    1:     enum LangType {LANG_UNKNOWN, LANG_JS, LANG_NATIVE};
    1:     
    1:     LangType GetCallingLangType() const
    1:         {
    1:             return mCallingLangType;
    1:         }
    1:     LangType SetCallingLangType(LangType lt)
    1:         {
    1:             LangType tmp = mCallingLangType; 
    1:             mCallingLangType = lt; 
    1:             return tmp;
    1:         }
    1:     JSBool CallerTypeIsJavaScript() const 
    1:         {
    1:             return LANG_JS == mCallingLangType;
    1:         }
    1:     JSBool CallerTypeIsNative() const 
    1:         {
    1:             return LANG_NATIVE == mCallingLangType;
    1:         }
    1:     JSBool CallerTypeIsKnown() const 
    1:         {
    1:             return LANG_UNKNOWN != mCallingLangType;
    1:         }
    1: 
    1:     nsresult GetException(nsIException** e)
    1:         {
    1:             NS_IF_ADDREF(mException);
    1:             *e = mException;
    1:             return NS_OK;
    1:         }
    1:     void SetException(nsIException* e)
    1:         {
    1:             NS_IF_ADDREF(e);
    1:             NS_IF_RELEASE(mException);
    1:             mException = e;
    1:         }
    1: 
    1:     nsresult GetLastResult() {return mLastResult;}
    1:     void SetLastResult(nsresult rc) {mLastResult = rc;}
    1: 
    1:     nsresult GetPendingResult() {return mPendingResult;}
    1:     void SetPendingResult(nsresult rc) {mPendingResult = rc;}
    1: 
    1:     nsIXPCSecurityManager* GetSecurityManager() const
    1:         {return mSecurityManager;}
    1:     void SetSecurityManager(nsIXPCSecurityManager* aSecurityManager)
    1:         {mSecurityManager = aSecurityManager;}
    1: 
    1:     PRUint16 GetSecurityManagerFlags() const
    1:         {return mSecurityManagerFlags;}
    1:     void SetSecurityManagerFlags(PRUint16 f)
    1:         {mSecurityManagerFlags = f;}
    1: 
    1:     nsIXPCSecurityManager* GetAppropriateSecurityManager(PRUint16 flags) const
    1:         {
    1:             NS_ASSERTION(CallerTypeIsKnown(),"missing caller type set somewhere");
    1:             if(!CallerTypeIsJavaScript())
    1:                 return nsnull;
    1:             if(mSecurityManager)
    1:             {
    1:                 if(flags & mSecurityManagerFlags)
    1:                     return mSecurityManager;
    1:             }
    1:             else
    1:             {
    1:                 nsIXPCSecurityManager* mgr;
    1:                 nsXPConnect* xpc = mRuntime->GetXPConnect();
    1:                 mgr = xpc->GetDefaultSecurityManager();
    1:                 if(mgr && (flags & xpc->GetDefaultSecurityManagerFlags()))
    1:                     return mgr;
    1:             }
    1:             return nsnull;
    1:         }
    1: 
    1:     void DebugDump(PRInt16 depth);
10291:     void AddScope(PRCList *scope) { PR_INSERT_AFTER(scope, &mScopes); }
10291:     void RemoveScope(PRCList *scope) { PR_REMOVE_LINK(scope); }
    1: 
    1:     ~XPCContext();
    1: 
    1: private:
    1:     XPCContext();    // no implementation
    1:     XPCContext(XPCJSRuntime* aRuntime, JSContext* aJSContext);
    1: 
20312:     static XPCContext* newXPCContext(XPCJSRuntime* aRuntime,
20312:                                      JSContext* aJSContext);
    1: private:
    1:     XPCJSRuntime* mRuntime;
    1:     JSContext*  mJSContext;
    1:     nsresult mLastResult;
    1:     nsresult mPendingResult;
    1:     nsIXPCSecurityManager* mSecurityManager;
    1:     nsIException* mException;
    1:     LangType mCallingLangType;
    1:     PRUint16 mSecurityManagerFlags;
10291: 
10291:     // A linked list of scopes to notify when we are destroyed.
10291:     PRCList mScopes;
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: #define NATIVE_CALLER  XPCContext::LANG_NATIVE
    1: #define JS_CALLER      XPCContext::LANG_JS
    1: 
 9332: // class to export a JSString as an const nsAString, no refcounting :(
 9332: class XPCReadableJSStringWrapper : public nsDependentString
 9332: {
 9332: public:
 9332:     typedef nsDependentString::char_traits char_traits;
 9332: 
 9332:     XPCReadableJSStringWrapper(PRUnichar *chars, size_t length) :
 9332:         nsDependentString(chars, length)
 9332:     { }
 9332: 
 9332:     XPCReadableJSStringWrapper() :
 9332:         nsDependentString(char_traits::sEmptyBuffer, char_traits::sEmptyBuffer)
 9332:     { SetIsVoid(PR_TRUE); }
 9332: };
 9332: 
    1: // No virtuals
    1: // XPCCallContext is ALWAYS declared as a local variable in some function;
    1: // i.e. instance lifetime is always controled by some C++ function returning.
    1: //
    1: // These things are created frequently in many places. We *intentionally* do
    1: // not inialialize all members in order to save on construction overhead.
    1: // Some constructor pass more valid params than others. We init what must be
    1: // init'd and leave other members undefined. In debug builds the accessors
    1: // use a CHECK_STATE macro to track whether or not the object is in a valid
    1: // state to answer the question a caller might be asking. As long as this
    1: // class is maintained correctly it can do its job without a bunch of added
    1: // overhead from useless initializations and non-DEBUG error checking.
    1: //
    1: // Note that most accessors are inlined.
    1: 
10286: class XPCCallContext : public nsAXPCNativeCallContext
    1: {
    1: public:
10286:     NS_IMETHOD GetCallee(nsISupports **aResult);
10286:     NS_IMETHOD GetCalleeMethodIndex(PRUint16 *aResult);
10286:     NS_IMETHOD GetCalleeWrapper(nsIXPConnectWrappedNative **aResult);
10286:     NS_IMETHOD GetJSContext(JSContext **aResult);
10286:     NS_IMETHOD GetArgc(PRUint32 *aResult);
10286:     NS_IMETHOD GetArgvPtr(jsval **aResult);
10286:     NS_IMETHOD GetRetValPtr(jsval **aResult);
10286:     NS_IMETHOD GetReturnValueWasSet(PRBool *aResult);
10286:     NS_IMETHOD SetReturnValueWasSet(PRBool aValue);
10286:     NS_IMETHOD GetCalleeInterface(nsIInterfaceInfo **aResult);
10286:     NS_IMETHOD GetCalleeClassInfo(nsIClassInfo **aResult);
20343:     NS_IMETHOD GetPreviousCallContext(nsAXPCNativeCallContext **aResult);
20343:     NS_IMETHOD GetLanguage(PRUint16 *aResult);
    1: 
    1:     enum {NO_ARGS = (uintN) -1};
    1: 
    1:     XPCCallContext(XPCContext::LangType callerLanguage,
    1:                    JSContext* cx    = nsnull,
    1:                    JSObject* obj    = nsnull,
    1:                    JSObject* funobj = nsnull,
    1:                    jsval id         = 0,
    1:                    uintN argc       = NO_ARGS,
    1:                    jsval *argv      = nsnull,
    1:                    jsval *rval      = nsnull);
    1: 
    1:     virtual ~XPCCallContext();
    1: 
    1:     inline JSBool                       IsValid() const ;
    1: 
    1:     inline nsXPConnect*                 GetXPConnect() const ;
    1:     inline XPCJSRuntime*                GetRuntime() const ;
    1:     inline XPCPerThreadData*            GetThreadData() const ;
    1:     inline XPCContext*                  GetXPCContext() const ;
    1:     inline JSContext*                   GetJSContext() const ;
    1:     inline JSContext*                   GetSafeJSContext() const ;
    1:     inline JSBool                       GetContextPopRequired() const ;
    1:     inline XPCContext::LangType         GetCallerLanguage() const ;
    1:     inline XPCContext::LangType         GetPrevCallerLanguage() const ;
    1:     inline XPCCallContext*              GetPrevCallContext() const ;
    1: 
    1:     inline JSObject*                    GetOperandJSObject() const ;
    1:     inline JSObject*                    GetCurrentJSObject() const ;
    1:     inline JSObject*                    GetFlattenedJSObject() const ;
    1: 
    1:     inline nsISupports*                 GetIdentityObject() const ;
    1:     inline XPCWrappedNative*            GetWrapper() const ;
    1: 
    1:     inline JSBool                       CanGetTearOff() const ;
    1:     inline XPCWrappedNativeTearOff*     GetTearOff() const ;
    1: 
    1:     inline XPCNativeScriptableInfo*     GetScriptableInfo() const ;
    1:     inline JSBool                       CanGetSet() const ;
    1:     inline XPCNativeSet*                GetSet() const ;
    1:     inline JSBool                       CanGetInterface() const ;
    1:     inline XPCNativeInterface*          GetInterface() const ;
    1:     inline XPCNativeMember*             GetMember() const ;
    1:     inline JSBool                       HasInterfaceAndMember() const ;
    1:     inline jsval                        GetName() const ;
    1:     inline JSBool                       GetStaticMemberIsLocal() const ;
    1:     inline uintN                        GetArgc() const ;
    1:     inline jsval*                       GetArgv() const ;
    1:     inline jsval*                       GetRetVal() const ;
    1:     inline JSBool                       GetReturnValueWasSet() const ;
    1: 
    1:     inline PRUint16                     GetMethodIndex() const ;
    1:     inline void                         SetMethodIndex(PRUint16 index) ;
    1: 
    1:     inline JSBool   GetDestroyJSContextInDestructor() const;
    1:     inline void     SetDestroyJSContextInDestructor(JSBool b);
    1: 
    1:     inline jsval GetResolveName() const;
    1:     inline jsval SetResolveName(jsval name);
    1: 
    1:     inline XPCWrappedNative* GetResolvingWrapper() const;
    1:     inline XPCWrappedNative* SetResolvingWrapper(XPCWrappedNative* w);
    1: 
    1:     inline void SetRetVal(jsval val);
    1: 
    1:     inline JSObject* GetCallee() const;
    1:     inline void SetCallee(JSObject* callee);
    1: 
    1:     void SetName(jsval name);
    1:     void SetArgsAndResultPtr(uintN argc, jsval *argv, jsval *rval);
    1:     void SetCallInfo(XPCNativeInterface* iface, XPCNativeMember* member,
    1:                      JSBool isSetter);
    1: 
    1:     nsresult  CanCallNow();
    1: 
    1:     void SystemIsBeingShutDown();
    1: 
    1:     operator JSContext*() const {return GetJSContext();}
    1: 
 9332:     XPCReadableJSStringWrapper *NewStringWrapper(PRUnichar *str, PRUint32 len);
 9332:     void DeleteString(nsAString *string);
 9332: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     /**
    1:      * Sets the IDispatch information for the context
    1:      * This has to be void* because of icky Microsoft macros that
    1:      * would be introduced if we included the DispatchInterface header
    1:      */
    1:     void SetIDispatchInfo(XPCNativeInterface* iface, void * member);
    1:     void* GetIDispatchMember() const { return mIDispatchMember; }
    1: #endif
    1: private:
    1: 
    1:     // no copy ctor or assignment allowed
    1:     XPCCallContext(const XPCCallContext& r); // not implemented
    1:     XPCCallContext& operator= (const XPCCallContext& r); // not implemented
    1: 
    1: private:
    1:     // posible values for mState
    1:     enum State {
    1:         INIT_FAILED,
    1:         SYSTEM_SHUTDOWN,
    1:         HAVE_CONTEXT,
    1:         HAVE_OBJECT,
    1:         HAVE_NAME,
    1:         HAVE_ARGS,
    1:         READY_TO_CALL,
    1:         CALL_DONE
    1:     };
    1: 
    1: #ifdef DEBUG
    1: inline void CHECK_STATE(int s) const {NS_ASSERTION(mState >= s, "bad state");}
    1: #else
    1: #define CHECK_STATE(s) ((void)0)
    1: #endif
    1: 
    1: private:
    1:     State                           mState;
    1: 
    1:     nsXPConnect*                    mXPC;
    1: 
    1:     XPCPerThreadData*               mThreadData;
    1:     XPCContext*                     mXPCContext;
    1:     JSContext*                      mJSContext;
    1:     JSBool                          mContextPopRequired;
    1:     JSBool                          mDestroyJSContextInDestructor;
    1: 
    1:     XPCContext::LangType            mCallerLanguage;
    1: 
    1:     // ctor does not necessarily init the following. BEWARE!
    1: 
    1:     XPCContext::LangType            mPrevCallerLanguage;
    1: 
    1:     XPCCallContext*                 mPrevCallContext;
    1: 
    1:     JSObject*                       mOperandJSObject;
    1:     JSObject*                       mCurrentJSObject;
    1:     JSObject*                       mFlattenedJSObject;
    1:     XPCWrappedNative*               mWrapper;
    1:     XPCWrappedNativeTearOff*        mTearOff;
    1: 
    1:     XPCNativeScriptableInfo*        mScriptableInfo;
    1: 
    1:     XPCNativeSet*                   mSet;
    1:     XPCNativeInterface*             mInterface;
    1:     XPCNativeMember*                mMember;
    1: 
    1:     jsval                           mName;
    1:     JSBool                          mStaticMemberIsLocal;
    1: 
    1:     uintN                           mArgc;
    1:     jsval*                          mArgv;
    1:     jsval*                          mRetVal;
    1: 
    1:     JSBool                          mReturnValueWasSet;
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     void*                           mIDispatchMember;
    1: #endif
    1:     PRUint16                        mMethodIndex;
    1: 
    1:     // If not null, this is the function object of the function we're going to
    1:     // call.  This member only makes sense when CallerTypeIsNative() on our
    1:     // XPCContext returns true.  We're not responsible for rooting this object;
    1:     // whoever sets it on us needs to deal with that.
    1:     JSObject*                       mCallee;
 9332: 
 9332: #define XPCCCX_STRING_CACHE_SIZE 2
 9332: 
 9332:     // String wrapper entry, holds a string, and a boolean that tells
 9332:     // whether the string is in use or not.
 9332:     struct StringWrapperEntry
 9332:     {
 9332:         StringWrapperEntry()
 9332:             : mInUse(PR_FALSE)
 9332:         {
 9332:         }
 9332: 
 9332:         XPCReadableJSStringWrapper mString;
 9332:         PRBool mInUse;
    1:     };
    1: 
 9332:     // Reserve space for XPCCCX_STRING_CACHE_SIZE string wrapper
 9332:     // entries for use on demand. It's important to not make this be
 9332:     // string class members since we don't want to pay the cost of
 9332:     // calling the constructors and destructors when the strings
 9332:     // aren't being used.
 9332:     char mStringWrapperData[sizeof(StringWrapperEntry) * XPCCCX_STRING_CACHE_SIZE];
 9332: };
    1: 
    1: /***************************************************************************
    1: ****************************************************************************
    1: *
    1: * Core classes for wrapped native objects for use from JavaScript...
    1: *
    1: ****************************************************************************
    1: ***************************************************************************/
    1: 
    1: // These are the various JSClasses and callbacks whose use that required
    1: // visibility from more than one .cpp file.
    1: 
    1: extern JSExtendedClass XPC_WN_NoHelper_JSClass;
 9030: extern JSClass XPC_WN_NoMods_WithCall_Proto_JSClass;
 9030: extern JSClass XPC_WN_NoMods_NoCall_Proto_JSClass;
 9030: extern JSClass XPC_WN_ModsAllowed_WithCall_Proto_JSClass;
 9030: extern JSClass XPC_WN_ModsAllowed_NoCall_Proto_JSClass;
    1: extern JSClass XPC_WN_Tearoff_JSClass;
10478: extern JSClass XPC_WN_NoHelper_Proto_JSClass;
    1: 
18907: extern JSObjectOps *
    1: XPC_WN_GetObjectOpsNoCall(JSContext *cx, JSClass *clazz);
    1: 
18907: extern JSObjectOps *
    1: XPC_WN_GetObjectOpsWithCall(JSContext *cx, JSClass *clazz);
    1: 
18907: extern JSObjectOps *
10478: XPC_WN_Proto_GetObjectOps(JSContext *cx, JSClass *clazz);
10478: 
18907: extern JSBool
    1: XPC_WN_CallMethod(JSContext *cx, JSObject *obj,
    1:                   uintN argc, jsval *argv, jsval *vp);
    1: 
18907: extern JSBool
    1: XPC_WN_GetterSetter(JSContext *cx, JSObject *obj,
    1:                     uintN argc, jsval *argv, jsval *vp);
    1: 
    1: extern JSBool
    1: xpc_InitWrappedNativeJSOps();
    1: 
 9030: // Maybe this macro should check for class->enumerate ==
 9030: // XPC_WN_Shared_Proto_Enumerate or something rather than checking for
 9030: // 4 classes?
    1: #define IS_PROTO_CLASS(clazz)                                                 \
 9030:           ((clazz) == &XPC_WN_NoMods_WithCall_Proto_JSClass ||                \
 9030:            (clazz) == &XPC_WN_NoMods_NoCall_Proto_JSClass ||                  \
 9030:            (clazz) == &XPC_WN_ModsAllowed_WithCall_Proto_JSClass ||           \
 9030:            (clazz) == &XPC_WN_ModsAllowed_NoCall_Proto_JSClass)
    1: 
    1: // Comes from xpcwrappednativeops.cpp
    1: extern void
 1025: xpc_TraceForValidWrapper(JSTracer *trc, XPCWrappedNative* wrapper);
    1: 
    1: /***************************************************************************/
    1: 
    1: /***************************************************************************/
    1: // XPCWrappedNativeScope is one-to-one with a JS global object.
    1: 
10291: class XPCWrappedNativeScope : public PRCList
    1: {
    1: public:
    1: 
    1:     static XPCWrappedNativeScope*
    1:     GetNewOrUsed(XPCCallContext& ccx, JSObject* aGlobal);
    1: 
    1:     XPCJSRuntime*
    1:     GetRuntime() const {return mRuntime;}
    1: 
    1:     Native2WrappedNativeMap*
    1:     GetWrappedNativeMap() const {return mWrappedNativeMap;}
    1: 
 4042:     WrappedNative2WrapperMap*
 4042:     GetWrapperMap() const {return mWrapperMap;}
 4042: 
    1:     ClassInfo2WrappedNativeProtoMap*
    1:     GetWrappedNativeProtoMap() const {return mWrappedNativeProtoMap;}
    1: 
    1:     nsXPCComponents*
    1:     GetComponents() const {return mComponents;}
    1: 
    1:     JSObject*
    1:     GetGlobalJSObject() const {return mGlobalJSObject;}
    1: 
    1:     JSObject*
    1:     GetPrototypeJSObject() const {return mPrototypeJSObject;}
    1: 
10478:     // Getter for the prototype that we use for wrappers that have no
10478:     // helper.
10478:     JSObject*
10478:     GetPrototypeNoHelper(XPCCallContext& ccx);
10478: 
    1: #ifndef XPCONNECT_STANDALONE
    1:     nsIPrincipal*
    1:     GetPrincipal() const
    1:     {return mScriptObjectPrincipal ?
    1:          mScriptObjectPrincipal->GetPrincipal() : nsnull;}
    1: #endif
    1:     
    1:     JSObject*
    1:     GetPrototypeJSFunction() const {return mPrototypeJSFunction;}
    1: 
    1:     void RemoveWrappedNativeProtos();
    1: 
    1:     static XPCWrappedNativeScope*
    1:     FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
    1:                         JSBool OKIfNotInitialized = JS_FALSE);
    1: 
    1:     static void
 2991:     SystemIsBeingShutDown(JSContext* cx);
    1: 
    1:     static void
 1025:     TraceJS(JSTracer* trc, XPCJSRuntime* rt);
 1025: 
 1025:     static void
 7286:     SuspectAllWrappers(XPCJSRuntime* rt, JSContext* cx,
 7286:                        nsCycleCollectionTraversalCallback &cb);
 2954: 
 2954:     static void
    1:     FinishedMarkPhaseOfGC(JSContext* cx, XPCJSRuntime* rt);
    1: 
    1:     static void
    1:     FinishedFinalizationPhaseOfGC(JSContext* cx);
    1: 
    1:     static void
    1:     MarkAllWrappedNativesAndProtos();
    1: 
    1:     static nsresult
    1:     ClearAllWrappedNativeSecurityPolicies(XPCCallContext& ccx);
    1: 
    1: #ifdef DEBUG
    1:     static void
    1:     ASSERT_NoInterfaceSetsAreMarked();
    1: #endif
    1: 
    1:     static void
    1:     SweepAllWrappedNativeTearOffs();
    1: 
    1:     static void
    1:     DebugDumpAllScopes(PRInt16 depth);
    1: 
    1:     void
    1:     DebugDump(PRInt16 depth);
    1: 
    1:     JSBool
    1:     IsValid() const {return mRuntime != nsnull;}
    1: 
 4099:     static JSBool
 4099:     IsDyingScope(XPCWrappedNativeScope *scope);
 4099: 
    1:     void SetComponents(nsXPCComponents* aComponents);
    1:     void SetGlobal(XPCCallContext& ccx, JSObject* aGlobal);
    1: 
    1:     static void InitStatics() { gScopes = nsnull; gDyingScopes = nsnull; }
    1: 
10291:     XPCContext *GetContext() { return mContext; }
10291:     void SetContext(XPCContext *xpcc) { mContext = nsnull; }
10291: 
    1: #ifndef XPCONNECT_STANDALONE
    1:     /**
    1:      * Fills the hash mapping global object to principal.
    1:      */
    1:     static void TraverseScopes(XPCCallContext& ccx);
    1: #endif
    1: 
    1: protected:
    1:     XPCWrappedNativeScope(XPCCallContext& ccx, JSObject* aGlobal);
    1:     virtual ~XPCWrappedNativeScope();
    1: 
    1:     static void KillDyingScopes();
    1: 
    1:     XPCWrappedNativeScope(); // not implemented
    1: 
    1: private:
    1:     static XPCWrappedNativeScope* gScopes;
    1:     static XPCWrappedNativeScope* gDyingScopes;
    1: 
    1:     XPCJSRuntime*                    mRuntime;
    1:     Native2WrappedNativeMap*         mWrappedNativeMap;
    1:     ClassInfo2WrappedNativeProtoMap* mWrappedNativeProtoMap;
 4042:     WrappedNative2WrapperMap*        mWrapperMap;
    1:     nsXPCComponents*                 mComponents;
    1:     XPCWrappedNativeScope*           mNext;
    1:     // The JS global object for this scope.  If non-null, this will be the
    1:     // default parent for the XPCWrappedNatives that have us as the scope,
    1:     // unless a PreCreate hook overrides it.  Note that this _may_ be null (see
    1:     // constructor).
    1:     JSObject*                        mGlobalJSObject;
10478: 
10478:     // Cached value of Object.prototype
    1:     JSObject*                        mPrototypeJSObject;
10478:     // Cached value of Function.prototype
    1:     JSObject*                        mPrototypeJSFunction;
10478:     // Prototype to use for wrappers with no helper.
10478:     JSObject*                        mPrototypeNoHelper;
10478: 
10291:     XPCContext*                      mContext;
    1: 
    1: #ifndef XPCONNECT_STANDALONE
    1:     // The script object principal instance corresponding to our current global
    1:     // JS object.
    1:     // XXXbz what happens if someone calls JS_SetPrivate on mGlobalJSObject.
    1:     // How do we deal?  Do we need to?  I suspect this isn't worth worrying
    1:     // about, since all of our scope objects are verified as not doing that.
    1:     nsCOMPtr<nsIScriptObjectPrincipal> mScriptObjectPrincipal;
    1: #endif
    1: };
    1: 
10471: JSObject* xpc_CloneJSFunction(XPCCallContext &ccx, JSObject *funobj,
10471:                               JSObject *parent);
10471: 
    1: /***************************************************************************/
    1: // XPCNativeMember represents a single idl declared method, attribute or
    1: // constant.
    1: 
    1: // Tight. No virtual methods. Can be bitwise copied (until any resolution done).
    1: 
    1: class XPCNativeMember
    1: {
    1: public:
    1:     static JSBool GetCallInfo(XPCCallContext& ccx,
    1:                               JSObject* funobj,
    1:                               XPCNativeInterface** pInterface,
    1:                               XPCNativeMember**    pMember);
    1: 
    1:     jsval   GetName() const {return mName;}
    1: 
    1:     PRUint16 GetIndex() const {return mIndex;}
    1: 
10471:     JSBool GetConstantValue(XPCCallContext& ccx, XPCNativeInterface* iface,
10471:                             jsval* pval)
10471:         {NS_ASSERTION(IsConstant(),
10471:                       "Only call this if you're sure this is a constant!");
10471:          if(!IsResolved() && !Resolve(ccx, iface)) return JS_FALSE;
    1:          *pval = mVal; return JS_TRUE;}
    1: 
10471:     JSBool NewFunctionObject(XPCCallContext& ccx, XPCNativeInterface* iface,
15179:                              JSObject *parent, jsval* pval);
10471: 
    1:     JSBool IsMethod() const
    1:         {return 0 != (mFlags & METHOD);}
    1: 
    1:     JSBool IsConstant() const
    1:         {return 0 != (mFlags & CONSTANT);}
    1: 
    1:     JSBool IsAttribute() const
    1:         {return 0 != (mFlags & GETTER);}
    1: 
    1:     JSBool IsWritableAttribute() const
    1:         {return 0 != (mFlags & SETTER_TOO);}
    1: 
    1:     JSBool IsReadOnlyAttribute() const
    1:         {return IsAttribute() && !IsWritableAttribute();}
    1: 
    1: 
    1:     void SetName(jsval a) {mName = a;}
    1: 
    1:     void SetMethod(PRUint16 index)
    1:         {mVal = JSVAL_NULL; mFlags = METHOD; mIndex = index;}
    1: 
    1:     void SetConstant(PRUint16 index)
    1:         {mVal = JSVAL_NULL; mFlags = CONSTANT; mIndex = index;}
    1: 
    1:     void SetReadOnlyAttribute(PRUint16 index)
    1:         {mVal = JSVAL_NULL; mFlags = GETTER; mIndex = index;}
    1: 
    1:     void SetWritableAttribute()
    1:         {NS_ASSERTION(mFlags == GETTER,"bad"); mFlags = GETTER | SETTER_TOO;}
    1: 
    1:     /* default ctor - leave random contents */
    1:     XPCNativeMember()  {MOZ_COUNT_CTOR(XPCNativeMember);}
    1:     ~XPCNativeMember() {MOZ_COUNT_DTOR(XPCNativeMember);}
    1: 
    1:     void DealWithDyingGCThings(JSContext* cx, XPCJSRuntime* rt)
    1:         {if(IsResolved() && JSVAL_IS_GCTHING(mVal) &&
    1:            JS_IsAboutToBeFinalized(cx, JSVAL_TO_GCTHING(mVal)))
    1:            {mVal = JSVAL_NULL; mFlags &= ~RESOLVED;}}
    1: 
    1: private:
    1:     JSBool IsResolved() const {return mFlags & RESOLVED;}
    1:     JSBool Resolve(XPCCallContext& ccx, XPCNativeInterface* iface);
    1: 
    1:     enum {
    1:         RESOLVED    = 0x01,
    1:         METHOD      = 0x02,
    1:         CONSTANT    = 0x04,
    1:         GETTER      = 0x08,
    1:         SETTER_TOO  = 0x10
    1:     };
    1: 
    1: private:
    1:     // our only data...
    1:     jsval    mName;
    1:     jsval    mVal;
    1:     PRUint16 mIndex;
    1:     PRUint16 mFlags;
    1: };
    1: 
    1: /***************************************************************************/
    1: // XPCNativeInterface represents a single idl declared interface. This is
    1: // primarily the set of XPCNativeMembers.
    1: 
    1: // Tight. No virtual methods.
    1: 
    1: class XPCNativeInterface
    1: {
    1: public:
    1:     static XPCNativeInterface* GetNewOrUsed(XPCCallContext& ccx,
    1:                                             const nsIID* iid);
    1:     static XPCNativeInterface* GetNewOrUsed(XPCCallContext& ccx,
    1:                                             nsIInterfaceInfo* info);
    1:     static XPCNativeInterface* GetNewOrUsed(XPCCallContext& ccx,
    1:                                             const char* name);
    1:     static XPCNativeInterface* GetISupports(XPCCallContext& ccx);
    1: 
    1:     inline nsIInterfaceInfo* GetInterfaceInfo() const {return mInfo.get();}
    1:     inline jsval             GetName()          const {return mName;}
    1: 
    1:     inline const nsIID* GetIID() const;
    1:     inline const char*  GetNameString() const;
    1:     inline XPCNativeMember* FindMember(jsval name) const;
    1: 
    1:     inline JSBool HasAncestor(const nsIID* iid) const;
    1: 
    1:     const char* GetMemberName(XPCCallContext& ccx,
    1:                               const XPCNativeMember* member) const;
    1: 
    1:     PRUint16 GetMemberCount() const
    1:         {NS_ASSERTION(!IsMarked(), "bad"); return mMemberCount;}
    1:     XPCNativeMember* GetMemberAt(PRUint16 i)
    1:         {NS_ASSERTION(i < mMemberCount, "bad index"); return &mMembers[i];}
    1: 
    1:     inline void DealWithDyingGCThings(JSContext* cx, XPCJSRuntime* rt);
    1: 
    1:     void DebugDump(PRInt16 depth);
    1: 
    1: #define XPC_NATIVE_IFACE_MARK_FLAG ((PRUint16)JS_BIT(15)) // only high bit of 16 is set
    1: 
    1:     void Mark()     {mMemberCount |= XPC_NATIVE_IFACE_MARK_FLAG;}
    1:     void Unmark()   {mMemberCount &= ~XPC_NATIVE_IFACE_MARK_FLAG;}
    1:     JSBool IsMarked() const
    1:                     {return 0 != (mMemberCount & XPC_NATIVE_IFACE_MARK_FLAG);}
    1: 
    1:     // NOP. This is just here to make the AutoMarkingPtr code compile.
 1025:     inline void TraceJS(JSTracer* trc) {}
 1025:     inline void AutoTrace(JSTracer* trc) {}
    1: 
    1:     static void DestroyInstance(JSContext* cx, XPCJSRuntime* rt,
    1:                                 XPCNativeInterface* inst);
    1: 
    1: protected:
    1:     static XPCNativeInterface* NewInstance(XPCCallContext& ccx,
    1:                                            nsIInterfaceInfo* aInfo);
    1: 
    1:     XPCNativeInterface();   // not implemented
    1:     XPCNativeInterface(nsIInterfaceInfo* aInfo, jsval aName)
    1:         : mInfo(aInfo), mName(aName), mMemberCount(0)
    1:                           {MOZ_COUNT_CTOR(XPCNativeInterface);}
    1:     ~XPCNativeInterface() {MOZ_COUNT_DTOR(XPCNativeInterface);}
    1: 
    1:     void* operator new(size_t, void* p) CPP_THROW_NEW {return p;}
    1: 
    1:     XPCNativeInterface(const XPCNativeInterface& r); // not implemented
    1:     XPCNativeInterface& operator= (const XPCNativeInterface& r); // not implemented
    1: 
    1: private:
    1:     nsCOMPtr<nsIInterfaceInfo> mInfo;
    1:     jsval                      mName;
    1:     PRUint16          mMemberCount;
    1:     XPCNativeMember   mMembers[1]; // always last - object sized for array
    1: };
    1: 
    1: /***************************************************************************/
    1: // XPCNativeSetKey is used to key a XPCNativeSet in a NativeSetMap.
    1: 
    1: class XPCNativeSetKey
    1: {
    1: public:
    1:     XPCNativeSetKey(XPCNativeSet*       BaseSet  = nsnull,
    1:                     XPCNativeInterface* Addition = nsnull,
    1:                     PRUint16            Position = 0)
    1:         : mIsAKey(IS_A_KEY), mPosition(Position), mBaseSet(BaseSet),
    1:           mAddition(Addition) {}
    1:     ~XPCNativeSetKey() {}
    1: 
    1:     XPCNativeSet*           GetBaseSet()  const {return mBaseSet;}
    1:     XPCNativeInterface*     GetAddition() const {return mAddition;}
    1:     PRUint16                GetPosition() const {return mPosition;}
    1: 
    1:     // This is a fun little hack...
    1:     // We build these keys only on the stack. We use them for lookup in
    1:     // NativeSetMap. Becasue we don't want to pay the cost of cloning a key and
    1:     // sticking it into the hashtable, when the XPCNativeSet actually
    1:     // gets added to the table the 'key' in the table is a pointer to the
    1:     // set itself and not this key. Our key compare function expects to get
    1:     // a key and a set. When we do external lookups in the map we pass in one
    1:     // of these keys and our compare function gets passed a key and a set.
    1:     // (see compare_NativeKeyToSet in xpcmaps.cpp). This is all well and good.
    1:     // Except, when the table decides to resize itself. Then it tries to use
    1:     // our compare function with the 'keys' that are in the hashtable (which are
    1:     // really XPCNativeSet objects and not XPCNativeSetKey objects!
    1:     //
    1:     // So, the hack is to have the compare function assume it is getting a
    1:     // XPCNativeSetKey pointer and call this IsAKey method. If that fails then
    1:     // it realises that it really has a XPCNativeSet pointer and deals with that
    1:     // fact. This is safe because we know that both of these classes have no
    1:     // virtual methods and their first data member is a PRUint16. We are
    1:     // confident that XPCNativeSet->mMemberCount will never be 0xffff.
    1: 
    1:     JSBool                  IsAKey() const {return mIsAKey == IS_A_KEY;}
    1: 
    1:     enum {IS_A_KEY = 0xffff};
    1: 
    1:     // Allow shallow copy
    1: 
    1: private:
    1:     PRUint16                mIsAKey;    // must be first data member
    1:     PRUint16                mPosition;
    1:     XPCNativeSet*           mBaseSet;
    1:     XPCNativeInterface*     mAddition;
    1: };
    1: 
    1: /***************************************************************************/
    1: // XPCNativeSet represents an ordered collection of XPCNativeInterface pointers.
    1: 
    1: class XPCNativeSet
    1: {
    1: public:
    1:     static XPCNativeSet* GetNewOrUsed(XPCCallContext& ccx, const nsIID* iid);
    1:     static XPCNativeSet* GetNewOrUsed(XPCCallContext& ccx,
    1:                                       nsIClassInfo* classInfo);
    1:     static XPCNativeSet* GetNewOrUsed(XPCCallContext& ccx,
    1:                                       XPCNativeSet* otherSet,
    1:                                       XPCNativeInterface* newInterface,
    1:                                       PRUint16 position);
    1: 
    1:     static void ClearCacheEntryForClassInfo(nsIClassInfo* classInfo);
    1: 
    1:     inline JSBool FindMember(jsval name, XPCNativeMember** pMember,
    1:                              PRUint16* pInterfaceIndex) const;
    1: 
    1:     inline JSBool FindMember(jsval name, XPCNativeMember** pMember,
    1:                              XPCNativeInterface** pInterface) const;
    1: 
    1:     inline JSBool FindMember(jsval name,
    1:                              XPCNativeMember** pMember,
    1:                              XPCNativeInterface** pInterface,
    1:                              XPCNativeSet* protoSet,
    1:                              JSBool* pIsLocal) const;
    1: 
    1:     inline JSBool HasInterface(XPCNativeInterface* aInterface) const;
    1:     inline JSBool HasInterfaceWithAncestor(XPCNativeInterface* aInterface) const;
    1: 
    1:     inline XPCNativeInterface* FindInterfaceWithIID(const nsIID& iid) const;
    1: 
    1:     inline XPCNativeInterface* FindNamedInterface(jsval name) const;
    1: 
    1:     PRUint16 GetMemberCount() const {return mMemberCount;}
    1:     PRUint16 GetInterfaceCount() const
    1:         {NS_ASSERTION(!IsMarked(), "bad"); return mInterfaceCount;}
    1:     XPCNativeInterface** GetInterfaceArray() {return mInterfaces;}
    1: 
    1:     XPCNativeInterface* GetInterfaceAt(PRUint16 i)
    1:         {NS_ASSERTION(i < mInterfaceCount, "bad index"); return mInterfaces[i];}
    1: 
    1:     inline JSBool MatchesSetUpToInterface(const XPCNativeSet* other,
    1:                                           XPCNativeInterface* iface) const;
    1: 
    1: #define XPC_NATIVE_SET_MARK_FLAG ((PRUint16)JS_BIT(15)) // only high bit of 16 is set
    1: 
    1:     inline void Mark();
    1: 
    1:     // NOP. This is just here to make the AutoMarkingPtr code compile.
 1025:     inline void TraceJS(JSTracer* trc) {}
 1025:     inline void AutoTrace(JSTracer* trc) {}
    1: 
    1: private:
    1:     void MarkSelfOnly() {mInterfaceCount |= XPC_NATIVE_SET_MARK_FLAG;}
    1: public:
    1:     void Unmark()       {mInterfaceCount &= ~XPC_NATIVE_SET_MARK_FLAG;}
    1:     JSBool IsMarked() const
    1:                   {return 0 != (mInterfaceCount & XPC_NATIVE_SET_MARK_FLAG);}
    1: 
    1: #ifdef DEBUG
    1:     inline void ASSERT_NotMarked();
    1: #endif
    1: 
    1:     void DebugDump(PRInt16 depth);
    1: 
    1:     static void DestroyInstance(XPCNativeSet* inst);
    1: 
    1: protected:
    1:     static XPCNativeSet* NewInstance(XPCCallContext& ccx,
    1:                                      XPCNativeInterface** array,
    1:                                      PRUint16 count);
    1:     static XPCNativeSet* NewInstanceMutate(XPCNativeSet*       otherSet,
    1:                                            XPCNativeInterface* newInterface,
    1:                                            PRUint16            position);
    1:     XPCNativeSet()  {MOZ_COUNT_CTOR(XPCNativeSet);}
    1:     ~XPCNativeSet() {MOZ_COUNT_DTOR(XPCNativeSet);}
    1:     void* operator new(size_t, void* p) CPP_THROW_NEW {return p;}
    1: 
    1: private:
    1:     PRUint16                mMemberCount;
    1:     PRUint16                mInterfaceCount;
    1:     XPCNativeInterface*     mInterfaces[1];  // always last - object sized for array
    1: };
    1: 
    1: /***************************************************************************/
    1: // XPCNativeScriptableFlags is a wrapper class that holds the flags returned
    1: // from calls to nsIXPCScriptable::GetScriptableFlags(). It has convenience
    1: // methods to check for particular bitflags. Since we also use this class as
    1: // a member of the gc'd class XPCNativeScriptableShared, this class holds the
    1: // bit and exposes the inlined methods to support marking.
    1: 
    1: #define XPC_WN_SJSFLAGS_MARK_FLAG JS_BIT(31) // only high bit of 32 is set
    1: 
    1: class XPCNativeScriptableFlags
    1: {
    1: private:
    1:     JSUint32 mFlags;
    1: 
    1: public:
    1: 
    1:     XPCNativeScriptableFlags(JSUint32 flags = 0) : mFlags(flags) {}
    1: 
    1:     JSUint32 GetFlags() const {return mFlags & ~XPC_WN_SJSFLAGS_MARK_FLAG;}
    1:     void     SetFlags(JSUint32 flags) {mFlags = flags;}
    1: 
    1:     operator JSUint32() const {return GetFlags();}
    1: 
    1:     XPCNativeScriptableFlags(const XPCNativeScriptableFlags& r)
    1:         {mFlags = r.GetFlags();}
    1: 
    1:     XPCNativeScriptableFlags& operator= (const XPCNativeScriptableFlags& r)
    1:         {mFlags = r.GetFlags(); return *this;}
    1: 
    1:     void Mark()       {mFlags |= XPC_WN_SJSFLAGS_MARK_FLAG;}
    1:     void Unmark()     {mFlags &= ~XPC_WN_SJSFLAGS_MARK_FLAG;}
    1:     JSBool IsMarked() const {return 0 != (mFlags & XPC_WN_SJSFLAGS_MARK_FLAG);}
    1: 
    1: #ifdef GET_IT
    1: #undef GET_IT
    1: #endif
    1: #define GET_IT(f_) const {return 0 != (mFlags & nsIXPCScriptable:: f_ );}
    1: 
    1:     JSBool WantPreCreate()                GET_IT(WANT_PRECREATE)
    1:     JSBool WantCreate()                   GET_IT(WANT_CREATE)
    1:     JSBool WantPostCreate()               GET_IT(WANT_POSTCREATE)
    1:     JSBool WantAddProperty()              GET_IT(WANT_ADDPROPERTY)
    1:     JSBool WantDelProperty()              GET_IT(WANT_DELPROPERTY)
    1:     JSBool WantGetProperty()              GET_IT(WANT_GETPROPERTY)
    1:     JSBool WantSetProperty()              GET_IT(WANT_SETPROPERTY)
    1:     JSBool WantEnumerate()                GET_IT(WANT_ENUMERATE)
    1:     JSBool WantNewEnumerate()             GET_IT(WANT_NEWENUMERATE)
    1:     JSBool WantNewResolve()               GET_IT(WANT_NEWRESOLVE)
    1:     JSBool WantConvert()                  GET_IT(WANT_CONVERT)
    1:     JSBool WantFinalize()                 GET_IT(WANT_FINALIZE)
    1:     JSBool WantCheckAccess()              GET_IT(WANT_CHECKACCESS)
    1:     JSBool WantCall()                     GET_IT(WANT_CALL)
    1:     JSBool WantConstruct()                GET_IT(WANT_CONSTRUCT)
    1:     JSBool WantHasInstance()              GET_IT(WANT_HASINSTANCE)
 1025:     JSBool WantTrace()                    GET_IT(WANT_TRACE)
    1:     JSBool WantEquality()                 GET_IT(WANT_EQUALITY)
    1:     JSBool WantOuterObject()              GET_IT(WANT_OUTER_OBJECT)
    1:     JSBool WantInnerObject()              GET_IT(WANT_INNER_OBJECT)
    1:     JSBool UseJSStubForAddProperty()      GET_IT(USE_JSSTUB_FOR_ADDPROPERTY)
    1:     JSBool UseJSStubForDelProperty()      GET_IT(USE_JSSTUB_FOR_DELPROPERTY)
    1:     JSBool UseJSStubForSetProperty()      GET_IT(USE_JSSTUB_FOR_SETPROPERTY)
    1:     JSBool DontEnumStaticProps()          GET_IT(DONT_ENUM_STATIC_PROPS)
    1:     JSBool DontEnumQueryInterface()       GET_IT(DONT_ENUM_QUERY_INTERFACE)
    1:     JSBool DontAskInstanceForScriptable() GET_IT(DONT_ASK_INSTANCE_FOR_SCRIPTABLE)
    1:     JSBool ClassInfoInterfacesOnly()      GET_IT(CLASSINFO_INTERFACES_ONLY)
    1:     JSBool AllowPropModsDuringResolve()   GET_IT(ALLOW_PROP_MODS_DURING_RESOLVE)
    1:     JSBool AllowPropModsToPrototype()     GET_IT(ALLOW_PROP_MODS_TO_PROTOTYPE)
    1:     JSBool DontSharePrototype()           GET_IT(DONT_SHARE_PROTOTYPE)
    1:     JSBool DontReflectInterfaceNames()    GET_IT(DONT_REFLECT_INTERFACE_NAMES)
    1: 
    1: #undef GET_IT
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: // XPCNativeScriptableShared is used to hold the JSClass and the
    1: // associated scriptable flags for XPCWrappedNatives. These are shared across
    1: // the runtime and are garbage collected by xpconnect. We *used* to just store
    1: // this inside the XPCNativeScriptableInfo (usually owned by instances of
    1: // XPCWrappedNativeProto. This had two problems... It was wasteful, and it
    1: // was a big problem when wrappers are reparented to different scopes (and
    1: // thus different protos (the DOM does this).
    1: 
    1: class XPCNativeScriptableShared
    1: {
    1: public:
    1:     const XPCNativeScriptableFlags& GetFlags() const {return mFlags;}
    1:     JSClass*                        GetJSClass() {return &mJSClass.base;}
    1: 
    1:     XPCNativeScriptableShared(JSUint32 aFlags = 0, char* aName = nsnull)
    1:         : mFlags(aFlags)
    1:         {memset(&mJSClass, 0, sizeof(mJSClass));
    1:          mJSClass.base.name = aName;  // take ownership
    1:          MOZ_COUNT_CTOR(XPCNativeScriptableShared);}
    1: 
    1:     ~XPCNativeScriptableShared()
    1:         {if(mJSClass.base.name)nsMemory::Free((void*)mJSClass.base.name);
    1:          MOZ_COUNT_DTOR(XPCNativeScriptableShared);}
    1: 
    1:     char* TransferNameOwnership()
    1:         {char* name=(char*)mJSClass.base.name; mJSClass.base.name = nsnull;
    1:         return name;}
    1: 
    1:     void PopulateJSClass(JSBool isGlobal);
    1: 
    1:     void Mark()       {mFlags.Mark();}
    1:     void Unmark()     {mFlags.Unmark();}
    1:     JSBool IsMarked() const {return mFlags.IsMarked();}
    1: 
    1: private:
    1:     XPCNativeScriptableFlags mFlags;
    1:     JSExtendedClass          mJSClass;
    1: };
    1: 
    1: /***************************************************************************/
    1: // XPCNativeScriptableInfo is used to hold the nsIXPCScriptable state for a
    1: // given class or instance.
    1: 
    1: class XPCNativeScriptableInfo
    1: {
    1: public:
    1:     static XPCNativeScriptableInfo*
    1:     Construct(XPCCallContext& ccx, JSBool isGlobal,
    1:               const XPCNativeScriptableCreateInfo* sci);
    1: 
    1:     nsIXPCScriptable*
    1:     GetCallback() const {return mCallback;}
    1: 
    1:     const XPCNativeScriptableFlags&
    1:     GetFlags() const      {return mShared->GetFlags();}
    1: 
    1:     JSClass*
    1:     GetJSClass()          {return mShared->GetJSClass();}
    1: 
    1:     XPCNativeScriptableShared*
    1:     GetScriptableShared() {return mShared;}
    1: 
    1:     void
    1:     SetCallback(nsIXPCScriptable* s) {mCallback = s;}
    1: 
    1:     void
    1:     SetScriptableShared(XPCNativeScriptableShared* shared) {mShared = shared;}
    1: 
    1:     void Mark() {if(mShared) mShared->Mark();}
    1: 
    1: protected:
    1:     XPCNativeScriptableInfo(nsIXPCScriptable* scriptable = nsnull,
    1:                             XPCNativeScriptableShared* shared = nsnull)
    1:         : mCallback(scriptable), mShared(shared)
    1:                                {MOZ_COUNT_CTOR(XPCNativeScriptableInfo);}
    1: public:
    1:     ~XPCNativeScriptableInfo() {MOZ_COUNT_DTOR(XPCNativeScriptableInfo);}
    1: private:
    1: 
    1:     // disable copy ctor and assignment
    1:     XPCNativeScriptableInfo(const XPCNativeScriptableInfo& r); // not implemented
    1:     XPCNativeScriptableInfo& operator= (const XPCNativeScriptableInfo& r); // not implemented
    1: 
    1: private:
    1:     nsCOMPtr<nsIXPCScriptable>  mCallback;
    1:     XPCNativeScriptableShared*  mShared;
    1: };
    1: 
    1: /***************************************************************************/
    1: // XPCNativeScriptableCreateInfo is used in creating new wrapper and protos.
    1: // it abstracts out the scriptable interface pointer and the flags. After
    1: // creation these are factored differently using XPCNativeScriptableInfo.
    1: 
    1: class XPCNativeScriptableCreateInfo
    1: {
    1: public:
    1: 
    1:     XPCNativeScriptableCreateInfo(const XPCNativeScriptableInfo& si)
    1:         : mCallback(si.GetCallback()), mFlags(si.GetFlags()) {}
    1: 
    1:     XPCNativeScriptableCreateInfo(nsIXPCScriptable* callback = nsnull,
    1:                                   XPCNativeScriptableFlags flags = 0)
    1:         : mCallback(callback), mFlags(flags) {}
    1: 
    1:     nsIXPCScriptable*
    1:     GetCallback() const {return mCallback;}
    1: 
    1:     const XPCNativeScriptableFlags&
    1:     GetFlags() const      {return mFlags;}
    1: 
    1:     void
    1:     SetCallback(nsIXPCScriptable* callback) {mCallback = callback;}
    1: 
    1:     void
    1:     SetFlags(const XPCNativeScriptableFlags& flags)  {mFlags = flags;}
    1: 
    1: private:
    1:     nsCOMPtr<nsIXPCScriptable>  mCallback;
    1:     XPCNativeScriptableFlags    mFlags;
    1: };
    1: 
    1: /***********************************************/
    1: // XPCWrappedNativeProto hold the additional (potentially shared) wrapper data
    1: // for XPCWrappedNative whose native objects expose nsIClassInfo.
    1: 
21218: #define UNKNOWN_OFFSETS ((QITableEntry*)1)
21218: 
    1: class XPCWrappedNativeProto
    1: {
    1: public:
    1:     static XPCWrappedNativeProto*
    1:     GetNewOrUsed(XPCCallContext& ccx,
    1:                  XPCWrappedNativeScope* Scope,
    1:                  nsIClassInfo* ClassInfo,
    1:                  const XPCNativeScriptableCreateInfo* ScriptableCreateInfo,
    1:                  JSBool ForceNoSharing,
21218:                  JSBool isGlobal,
21218:                  QITableEntry* offsets = UNKNOWN_OFFSETS);
    1: 
    1:     XPCWrappedNativeScope*
    1:     GetScope()   const {return mScope;}
    1: 
    1:     XPCJSRuntime*
    1:     GetRuntime() const {return mScope->GetRuntime();}
    1: 
    1:     JSObject*
    1:     GetJSProtoObject() const {return mJSProtoObject;}
    1: 
    1:     nsIClassInfo*
    1:     GetClassInfo()     const {return mClassInfo;}
    1: 
    1:     XPCNativeSet*
    1:     GetSet()           const {return mSet;}
    1: 
    1:     XPCNativeScriptableInfo*
    1:     GetScriptableInfo()   {return mScriptableInfo;}
    1: 
    1:     void**
    1:     GetSecurityInfoAddr() {return &mSecurityInfo;}
    1: 
    1:     JSUint32
    1:     GetClassInfoFlags() const {return mClassInfoFlags;}
    1: 
21218:     QITableEntry*
21218:     GetOffsets()
21218:     {
21218:         return InitedOffsets() ? mOffsets : nsnull;
21218:     }
21218:     QITableEntry*
21218:     GetOffsetsMasked()
21218:     {
21218:         return mOffsets;
21218:     }
21218:     void
21218:     CacheOffsets(nsISupports* identity)
21218:     {
21218:         static NS_DEFINE_IID(kThisPtrOffsetsSID, NS_THISPTROFFSETS_SID);
21218: 
21218: #ifdef DEBUG
21218:         if(InitedOffsets() && mOffsets)
21218:         {
21218:             QITableEntry* offsets;
21218:             identity->QueryInterface(kThisPtrOffsetsSID, (void**)&offsets);
21218:             NS_ASSERTION(offsets == mOffsets,
21218:                          "We can't deal with objects that have the same "
21218:                          "classinfo but different offset tables.");
21218:         }
21218: #endif
21218: 
21218:         if(!InitedOffsets())
21218:         {
21218:             if(mClassInfoFlags & nsIClassInfo::CONTENT_NODE)
21218:             {
21218:                 identity->QueryInterface(kThisPtrOffsetsSID, (void**)&mOffsets);
21218:             }
21218:             else
21218:             {
21218:                 mOffsets = nsnull;
21218:             }
21218:         }
21218:     }
21218: 
    1: #ifdef GET_IT
    1: #undef GET_IT
    1: #endif
18991: #define GET_IT(f_) const {return !!(mClassInfoFlags & nsIClassInfo:: f_ );}
    1: 
    1:     JSBool ClassIsSingleton()           GET_IT(SINGLETON)
    1:     JSBool ClassIsThreadSafe()          GET_IT(THREADSAFE)
    1:     JSBool ClassIsMainThreadOnly()      GET_IT(MAIN_THREAD_ONLY)
    1:     JSBool ClassIsDOMObject()           GET_IT(DOM_OBJECT)
    1:     JSBool ClassIsPluginObject()        GET_IT(PLUGIN_OBJECT)
    1: 
    1: #undef GET_IT
    1: 
    1: #define XPC_PROTO_DONT_SHARE JS_BIT(31) // only high bit of 32 is set
    1: 
    1:     JSBool
    1:     IsShared() const {return !(mClassInfoFlags & XPC_PROTO_DONT_SHARE);}
    1: 
    1:     XPCLock* GetLock() const
    1:         {return ClassIsThreadSafe() ? GetRuntime()->GetMapLock() : nsnull;}
    1: 
    1:     void SetScriptableInfo(XPCNativeScriptableInfo* si)
    1:         {NS_ASSERTION(!mScriptableInfo, "leak here!"); mScriptableInfo = si;}
    1: 
    1:     void JSProtoObjectFinalized(JSContext *cx, JSObject *obj);
    1: 
 2991:     void SystemIsBeingShutDown(JSContext* cx);
    1: 
    1:     void DebugDump(PRInt16 depth);
    1: 
 1025:     void TraceJS(JSTracer* trc)
 1025:     {
 1025:         if(mJSProtoObject)
 1025:         {
 1025:             JS_CALL_OBJECT_TRACER(trc, mJSProtoObject,
 1025:                                   "XPCWrappedNativeProto::mJSProtoObject");
 1025:         }
 1025:         if(mScriptableInfo && JS_IsGCMarkingTracer(trc))
 1025:             mScriptableInfo->Mark();
 1025:     }
 1025: 
    1:     // NOP. This is just here to make the AutoMarkingPtr code compile.
 1025:     inline void AutoTrace(JSTracer* trc) {}
    1: 
    1:     // Yes, we *do* need to mark the mScriptableInfo in both cases.
    1:     void Mark() const
    1:         {mSet->Mark(); 
    1:          if(mScriptableInfo) mScriptableInfo->Mark();}
    1: 
    1: #ifdef DEBUG
    1:     void ASSERT_SetNotMarked() const {mSet->ASSERT_NotMarked();}
    1: #endif
    1: 
    1:     ~XPCWrappedNativeProto();
    1: 
    1: protected:
    1:     // disable copy ctor and assignment
    1:     XPCWrappedNativeProto(const XPCWrappedNativeProto& r); // not implemented
    1:     XPCWrappedNativeProto& operator= (const XPCWrappedNativeProto& r); // not implemented
    1: 
    1:     // hide ctor
    1:     XPCWrappedNativeProto(XPCWrappedNativeScope* Scope,
    1:                           nsIClassInfo* ClassInfo,
    1:                           PRUint32 ClassInfoFlags,
21218:                           XPCNativeSet* Set,
21218:                           QITableEntry* offsets);
    1: 
    1:     JSBool Init(XPCCallContext& ccx, JSBool isGlobal,
    1:                 const XPCNativeScriptableCreateInfo* scriptableCreateInfo);
    1: 
    1: private:
    1: #if defined(DEBUG_xpc_hacker) || defined(DEBUG)
    1:     static PRInt32 gDEBUG_LiveProtoCount;
    1: #endif
    1: 
    1: private:
21218:     PRBool
21218:     InitedOffsets()
21218:     {
21218:         return mOffsets != UNKNOWN_OFFSETS;
21218:     }
21218: 
    1:     XPCWrappedNativeScope*   mScope;
    1:     JSObject*                mJSProtoObject;
    1:     nsCOMPtr<nsIClassInfo>   mClassInfo;
    1:     PRUint32                 mClassInfoFlags;
    1:     XPCNativeSet*            mSet;
    1:     void*                    mSecurityInfo;
    1:     XPCNativeScriptableInfo* mScriptableInfo;
21218:     QITableEntry*            mOffsets;
    1: };
    1: 
    1: 
    1: /***********************************************/
    1: // XPCWrappedNativeTearOff represents the info needed to make calls to one
    1: // interface on the underlying native object of a XPCWrappedNative.
    1: 
    1: class XPCWrappedNativeTearOff
    1: {
    1: public:
    1:     JSBool IsAvailable() const {return mInterface == nsnull;}
    1:     JSBool IsReserved()  const {return mInterface == (XPCNativeInterface*)1;}
    1:     JSBool IsValid()     const {return !IsAvailable() && !IsReserved();}
    1:     void   SetReserved()       {mInterface = (XPCNativeInterface*)1;}
    1: 
    1:     XPCNativeInterface* GetInterface() const {return mInterface;}
    1:     nsISupports*        GetNative()    const {return mNative;}
    1:     JSObject*           GetJSObject()  const;
    1:     void SetInterface(XPCNativeInterface*  Interface) {mInterface = Interface;}
    1:     void SetNative(nsISupports*  Native)              {mNative = Native;}
    1:     void SetJSObject(JSObject*  JSObj);
    1: 
    1:     void JSObjectFinalized() {SetJSObject(nsnull);}
    1: 
    1:     XPCWrappedNativeTearOff()
    1:         : mInterface(nsnull), mNative(nsnull), mJSObject(nsnull) {}
    1:     ~XPCWrappedNativeTearOff();
    1: 
    1:     // NOP. This is just here to make the AutoMarkingPtr code compile.
 1025:     inline void TraceJS(JSTracer* trc) {}
 1025:     inline void AutoTrace(JSTracer* trc) {}
    1: 
    1:     void Mark()       {mJSObject = (JSObject*)(((jsword)mJSObject) | 1);}
    1:     void Unmark()     {mJSObject = (JSObject*)(((jsword)mJSObject) & ~1);}
    1:     JSBool IsMarked() const {return (JSBool)(((jsword)mJSObject) & 1);}
    1: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     enum JSObject_flags
    1:     {
    1:         IDISPATCH_BIT = 2,
    1:         JSOBJECT_MASK = 3
    1:     };
    1:     void                SetIDispatch(JSContext* cx);
    1:     JSBool              IsIDispatch() const;
    1:     XPCDispInterface*   GetIDispatchInfo() const;
    1: #endif
    1: private:
    1:     XPCWrappedNativeTearOff(const XPCWrappedNativeTearOff& r); // not implemented
    1:     XPCWrappedNativeTearOff& operator= (const XPCWrappedNativeTearOff& r); // not implemented
    1: 
    1: private:
    1:     XPCNativeInterface* mInterface;
    1:     nsISupports*        mNative;
    1:     JSObject*           mJSObject;
    1: };
    1: 
    1: /***********************************************/
    1: // XPCWrappedNativeTearOffChunk is a collections of XPCWrappedNativeTearOff
    1: // objects. It lets us allocate a set of XPCWrappedNativeTearOff objects and
    1: // link the sets - rather than only having the option of linking single
    1: // XPCWrappedNativeTearOff objects.
    1: //
    1: // The value of XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK can be tuned at buildtime
    1: // to balance between the code of allocations of additional chunks and the waste
    1: // of space for ununsed XPCWrappedNativeTearOff objects.
    1: 
    1: #define XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK 1
    1: 
    1: class XPCWrappedNativeTearOffChunk
    1: {
    1: friend class XPCWrappedNative;
    1: private:
    1:     XPCWrappedNativeTearOffChunk() : mNextChunk(nsnull) {}
    1:     ~XPCWrappedNativeTearOffChunk() {delete mNextChunk;}
    1: 
    1: private:
    1:     XPCWrappedNativeTearOff mTearOffs[XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK];
    1:     XPCWrappedNativeTearOffChunk* mNextChunk;
    1: };
    1: 
    1: /***************************************************************************/
    1: // XPCWrappedNative the wrapper around one instance of a native xpcom object
    1: // to be used from JavaScript.
    1: 
    1: class XPCWrappedNative : public nsIXPConnectWrappedNative
    1: {
    1: public:
 7230:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIXPCONNECTJSOBJECTHOLDER
    1:     NS_DECL_NSIXPCONNECTWRAPPEDNATIVE
10141:     // No need to unlink the JS objects, if the XPCWrappedNative will be cycle
10141:     // collected then its mFlatJSObject will be cycle collected too and
10141:     // finalization of the mFlatJSObject will unlink the js objects (see
10141:     // XPC_WN_NoHelper_Finalize and FlatJSObjectFinalized).
10141:     // We also rely on NS_DECL_CYCLE_COLLECTION_CLASS_NO_UNLINK having empty
10141:     // Root/Unroot methods, to avoid root/unrooting the JS objects from
10141:     // addrefing/releasing the XPCWrappedNative during unlinking, which would
10141:     // make the JS objects uncollectable to the JS GC.
12418:     class NS_CYCLE_COLLECTION_INNERCLASS
12418:      : public nsXPCOMCycleCollectionParticipant
12418:     {
12418:       NS_DECL_CYCLE_COLLECTION_CLASS_BODY_NO_UNLINK(XPCWrappedNative,
12418:                                                     XPCWrappedNative)
12418:       NS_IMETHOD RootAndUnlinkJSObjects(void *p);
12418:       NS_IMETHOD Unlink(void *p) { return NS_OK; }
12418:       NS_IMETHOD Unroot(void *p) { return NS_OK; }
12418:     };
12418:     NS_CYCLE_COLLECTION_PARTICIPANT_INSTANCE
 7230:     NS_DECL_CYCLE_COLLECTION_UNMARK_PURPLE_STUB(XPCWrappedNative)
    1: 
    1: #ifndef XPCONNECT_STANDALONE
    1:     virtual nsIPrincipal* GetObjectPrincipal() const;
    1: #endif
    1: 
    1:     JSBool
    1:     IsValid() const {return nsnull != mFlatJSObject;}
    1: 
12418: #define XPC_SCOPE_WORD(s)   ((jsword)(s))
12418: #define XPC_SCOPE_MASK      ((jsword)0x3)
    1: #define XPC_SCOPE_TAG       ((jsword)0x1)
12418: #define XPC_WRAPPER_EXPIRED ((jsword)0x2)
    1: 
    1:     static inline JSBool
    1:     IsTaggedScope(XPCWrappedNativeScope* s)
    1:         {return XPC_SCOPE_WORD(s) & XPC_SCOPE_TAG;}
    1: 
    1:     static inline XPCWrappedNativeScope*
    1:     TagScope(XPCWrappedNativeScope* s)
    1:         {NS_ASSERTION(!IsTaggedScope(s), "bad pointer!");
    1:          return (XPCWrappedNativeScope*)(XPC_SCOPE_WORD(s) | XPC_SCOPE_TAG);}
    1: 
    1:     static inline XPCWrappedNativeScope*
    1:     UnTagScope(XPCWrappedNativeScope* s)
    1:         {return (XPCWrappedNativeScope*)(XPC_SCOPE_WORD(s) & ~XPC_SCOPE_TAG);}
    1: 
12418:     inline JSBool
12418:     IsWrapperExpired() const
12418:         {return XPC_SCOPE_WORD(mMaybeScope) & XPC_WRAPPER_EXPIRED;}
12418: 
    1:     JSBool
    1:     HasProto() const {return !IsTaggedScope(mMaybeScope);}
    1: 
    1:     XPCWrappedNativeProto*
12418:     GetProto() const
12418:         {return HasProto() ?
12418:          (XPCWrappedNativeProto*)
12418:          (XPC_SCOPE_WORD(mMaybeProto) & ~XPC_SCOPE_MASK) : nsnull;}
12418: 
12418:     void
12418:     SetProto(XPCWrappedNativeProto* p)
12418:         {NS_ASSERTION(!IsWrapperExpired(), "bad ptr!");
12418:          mMaybeProto = p;}
    1: 
    1:     XPCWrappedNativeScope*
12418:     GetScope() const
12418:         {return GetProto() ? GetProto()->GetScope() :
12418:          (XPCWrappedNativeScope*)
12418:          (XPC_SCOPE_WORD(mMaybeScope) & ~XPC_SCOPE_MASK);}
    1: 
    1:     nsISupports*
    1:     GetIdentityObject() const {return mIdentity;}
    1: 
    1:     JSObject*
    1:     GetFlatJSObject() const {return mFlatJSObject;}
    1: 
    1:     XPCLock*
    1:     GetLock() const {return IsValid() && HasProto() ?
12418:                                 GetProto()->GetLock() : nsnull;}
    1: 
    1:     XPCNativeSet*
    1:     GetSet() const {XPCAutoLock al(GetLock()); return mSet;}
    1: 
    1: private:
    1:     void
    1:     SetSet(XPCNativeSet* set) {XPCAutoLock al(GetLock()); mSet = set;}
12418: 
12418:     inline void
12418:     ExpireWrapper()
12418:         {mMaybeScope = (XPCWrappedNativeScope*)
12418:                        (XPC_SCOPE_WORD(mMaybeScope) | XPC_WRAPPER_EXPIRED);}
12418: 
    1: public:
    1: 
    1:     XPCNativeScriptableInfo*
    1:     GetScriptableInfo() const {return mScriptableInfo;}
    1: 
    1:     nsIXPCScriptable*      // call this wrong and you deserve to crash
    1:     GetScriptableCallback() const  {return mScriptableInfo->GetCallback();}
    1: 
    1:     void**
    1:     GetSecurityInfoAddr() {return HasProto() ?
12418:                                    GetProto()->GetSecurityInfoAddr() : nsnull;}
    1: 
    1:     nsIClassInfo*
    1:     GetClassInfo() const {return IsValid() && HasProto() ?
12418:                             GetProto()->GetClassInfo() : nsnull;}
    1: 
    1:     JSBool
    1:     HasSharedProto() const {return IsValid() && HasProto() &&
12418:                             GetProto()->IsShared();}
    1: 
    1:     JSBool
    1:     HasMutatedSet() const {return IsValid() &&
    1:                                   (!HasProto() ||
12418:                                    GetSet() != GetProto()->GetSet());}
    1: 
    1:     XPCJSRuntime*
    1:     GetRuntime() const {XPCWrappedNativeScope* scope = GetScope();
    1:                         return scope ? scope->GetRuntime() : nsnull;}
    1: 
    1:     static nsresult
    1:     GetNewOrUsed(XPCCallContext& ccx,
    1:                  nsISupports* Object,
    1:                  XPCWrappedNativeScope* Scope,
    1:                  XPCNativeInterface* Interface,
    1:                  JSBool isGlobal,
    1:                  XPCWrappedNative** wrapper);
    1: 
    1: public:
    1:     static nsresult
    1:     GetUsedOnly(XPCCallContext& ccx,
    1:                 nsISupports* Object,
    1:                 XPCWrappedNativeScope* Scope,
    1:                 XPCNativeInterface* Interface,
    1:                 XPCWrappedNative** wrapper);
    1: 
    1:     static XPCWrappedNative*
    1:     GetWrappedNativeOfJSObject(JSContext* cx, JSObject* obj,
    1:                                JSObject* funobj = nsnull,
    1:                                JSObject** pobj2 = nsnull,
    1:                                XPCWrappedNativeTearOff** pTearOff = nsnull);
    1: 
    1:     static nsresult
    1:     ReparentWrapperIfFound(XPCCallContext& ccx,
    1:                            XPCWrappedNativeScope* aOldScope,
    1:                            XPCWrappedNativeScope* aNewScope,
    1:                            JSObject* aNewParent,
    1:                            nsISupports* aCOMObj,
    1:                            XPCWrappedNative** aWrapper);
    1: 
 7230:     void FlatJSObjectFinalized(JSContext *cx);
    1: 
 2991:     void SystemIsBeingShutDown(JSContext* cx);
    1: 
    1: #ifdef XPC_DETECT_LEADING_UPPERCASE_ACCESS_ERRORS
    1:     // This will try to find a member that is of the form "camelCased"
    1:     // but was accessed from JS using "CamelCased". This is here to catch
    1:     // mistakes caused by the confusion magnet that JS methods are by
    1:     // convention 'foo' while C++ members are by convention 'Foo'.
    1:     static void
    1:     HandlePossibleNameCaseError(XPCCallContext& ccx,
    1:                                 XPCNativeSet* set,
    1:                                 XPCNativeInterface* iface,
    1:                                 jsval name);
    1:     static void
    1:     HandlePossibleNameCaseError(JSContext* cx,
    1:                                 XPCNativeSet* set,
    1:                                 XPCNativeInterface* iface,
    1:                                 jsval name);
    1: 
    1: #define  HANDLE_POSSIBLE_NAME_CASE_ERROR(context, set, iface, name) \
    1:     XPCWrappedNative::HandlePossibleNameCaseError(context, set, iface, name)
    1: #else
    1: #define  HANDLE_POSSIBLE_NAME_CASE_ERROR(context, set, iface, name) ((void)0)
    1: #endif
    1: 
    1:     enum CallMode {CALL_METHOD, CALL_GETTER, CALL_SETTER};
    1: 
    1:     static JSBool CallMethod(XPCCallContext& ccx,
    1:                              CallMode mode = CALL_METHOD);
    1: 
    1:     static JSBool GetAttribute(XPCCallContext& ccx)
    1:         {return CallMethod(ccx, CALL_GETTER);}
    1: 
    1:     static JSBool SetAttribute(XPCCallContext& ccx)
    1:         {return CallMethod(ccx, CALL_SETTER);}
    1: 
    1:     inline JSBool HasInterfaceNoQI(XPCNativeInterface* aInterface);
    1:     inline JSBool HasInterfaceNoQI(const nsIID& iid);
    1: 
    1:     XPCWrappedNativeTearOff* LocateTearOff(XPCCallContext& ccx,
    1:                                            XPCNativeInterface* aInterface);
    1:     XPCWrappedNativeTearOff* FindTearOff(XPCCallContext& ccx,
    1:                                          XPCNativeInterface* aInterface,
    1:                                          JSBool needJSObject = JS_FALSE,
    1:                                          nsresult* pError = nsnull);
    1:     void Mark() const
    1:     {
    1:         mSet->Mark();
    1:         if(mScriptableInfo) mScriptableInfo->Mark();
12418:         if(HasProto()) GetProto()->Mark();
    1:     }
    1: 
    1:     // Yes, we *do* need to mark the mScriptableInfo in both cases.
 1025:     inline void TraceJS(JSTracer* trc)
    1:     {
 1025:         if(mScriptableInfo && JS_IsGCMarkingTracer(trc))
 1025:             mScriptableInfo->Mark();
12418:         if(HasProto()) GetProto()->TraceJS(trc);
 4042:         if(mWrapper)
 4042:             JS_CALL_OBJECT_TRACER(trc, mWrapper, "XPCWrappedNative::mWrapper");
 4042:         TraceOtherWrapper(trc);
    1:     }
    1: 
 1025:     inline void AutoTrace(JSTracer* trc)
    1:     {
    1:         // If this got called, we're being kept alive by someone who really
    1:         // needs us alive and whole.  Do not let our mFlatJSObject go away.
 1025:         // This is the only time we should be tracing our mFlatJSObject,
 1025:         // normally somebody else is doing that. Be careful not to trace the
 1025:         // bogus JSVAL_ONE value we can have during init, though.
    1:         if(mFlatJSObject && mFlatJSObject != (JSObject*)JSVAL_ONE)
    1:         {
 1025:             JS_CALL_OBJECT_TRACER(trc, mFlatJSObject,
 1025:                                   "XPCWrappedNative::mFlatJSObject");
    1:         }
    1:     }
    1: 
    1: #ifdef DEBUG
    1:     void ASSERT_SetsNotMarked() const
    1:         {mSet->ASSERT_NotMarked();
12418:          if(HasProto()){GetProto()->ASSERT_SetNotMarked();}}
    1: 
    1:     int DEBUG_CountOfTearoffChunks() const
    1:         {int i = 0; const XPCWrappedNativeTearOffChunk* to;
    1:          for(to = &mFirstChunk; to; to = to->mNextChunk) {i++;} return i;}
    1: #endif
    1: 
    1:     inline void SweepTearOffs();
    1: 
    1:     // Returns a string that shuld be free'd using JS_smprintf_free (or null).
    1:     char* ToString(XPCCallContext& ccx,
    1:                    XPCWrappedNativeTearOff* to = nsnull) const;
    1: 
    1:     static nsresult GatherProtoScriptableCreateInfo(
    1:                         nsIClassInfo* classInfo,
    1:                         XPCNativeScriptableCreateInfo* sciProto);
    1: 
    1:     JSBool HasExternalReference() const {return mRefCnt > 1;}
    1: 
 4042:     JSObject* GetWrapper()              { return mWrapper; }
 4042:     void      SetWrapper(JSObject *obj) { mWrapper = obj; }
    1: 
 7286:     void NoteTearoffs(nsCycleCollectionTraversalCallback& cb);
 7286: 
21218:     QITableEntry* GetOffsets()
21218:     {
21218:         if(!HasProto() || !GetProto()->ClassIsDOMObject())
21218:             return nsnull;
21218: 
21218:         XPCWrappedNativeProto* proto = GetProto();
21218:         QITableEntry* offsets = proto->GetOffsets();
21218:         if(!offsets)
21218:         {
21218:             static NS_DEFINE_IID(kThisPtrOffsetsSID, NS_THISPTROFFSETS_SID);
21218:             mIdentity->QueryInterface(kThisPtrOffsetsSID, (void**)&offsets);
21218:         }
21218:         return offsets;
21218:     }
21218: 
    1:     // Make ctor and dtor protected (rather than private) to placate nsCOMPtr.
    1: protected:
    1:     XPCWrappedNative(); // not implemented
    1: 
    1:     // This ctor is used if this object will have a proto.
    1:     XPCWrappedNative(nsISupports* aIdentity,
    1:                      XPCWrappedNativeProto* aProto);
    1: 
    1:     // This ctor is used if this object will NOT have a proto.
    1:     XPCWrappedNative(nsISupports* aIdentity,
    1:                      XPCWrappedNativeScope* aScope,
    1:                      XPCNativeSet* aSet);
    1: 
    1:     virtual ~XPCWrappedNative();
    1: 
    1: private:
 4042:     void TraceOtherWrapper(JSTracer* trc);
    1:     JSBool Init(XPCCallContext& ccx, JSObject* parent, JSBool isGlobal,
    1:                 const XPCNativeScriptableCreateInfo* sci);
    1: 
    1:     JSBool ExtendSet(XPCCallContext& ccx, XPCNativeInterface* aInterface);
    1: 
    1:     nsresult InitTearOff(XPCCallContext& ccx,
    1:                          XPCWrappedNativeTearOff* aTearOff,
    1:                          XPCNativeInterface* aInterface,
    1:                          JSBool needJSObject);
    1: 
    1:     JSBool InitTearOffJSObject(XPCCallContext& ccx,
    1:                                 XPCWrappedNativeTearOff* to);
    1: 
    1: public:
    1:     static nsresult GatherScriptableCreateInfo(
    1:                         nsISupports* obj,
    1:                         nsIClassInfo* classInfo,
    1:                         XPCNativeScriptableCreateInfo* sciProto,
    1:                         XPCNativeScriptableCreateInfo* sciWrapper);
    1: 
    1: private:
    1:     union
    1:     {
    1:         XPCWrappedNativeScope*   mMaybeScope;
    1:         XPCWrappedNativeProto*   mMaybeProto;
    1:     };
    1:     XPCNativeSet*                mSet;
    1:     JSObject*                    mFlatJSObject;
    1:     XPCNativeScriptableInfo*     mScriptableInfo;
    1:     XPCWrappedNativeTearOffChunk mFirstChunk;
 4042:     JSObject*                    mWrapper;
    1: 
 7230: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
    1: public:
    1:     nsCOMPtr<nsIThread>          mThread; // Don't want to overload _mOwningThread
 7230: #endif
    1: };
    1: 
    1: /***************************************************************************
    1: ****************************************************************************
    1: *
    1: * Core classes for wrapped JSObject for use from native code...
    1: *
    1: ****************************************************************************
    1: ***************************************************************************/
    1: 
    1: // this interfaces exists so we can refcount nsXPCWrappedJSClass
    1: // {2453EBA0-A9B8-11d2-BA64-00805F8A5DD7}
    1: #define NS_IXPCONNECT_WRAPPED_JS_CLASS_IID  \
    1: { 0x2453eba0, 0xa9b8, 0x11d2,               \
    1:   { 0xba, 0x64, 0x0, 0x80, 0x5f, 0x8a, 0x5d, 0xd7 } }
    1: 
    1: class nsIXPCWrappedJSClass : public nsISupports
    1: {
    1: public:
    1:     NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCONNECT_WRAPPED_JS_CLASS_IID)
    1:     NS_IMETHOD DebugDump(PRInt16 depth) = 0;
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsIXPCWrappedJSClass,
    1:                               NS_IXPCONNECT_WRAPPED_JS_CLASS_IID)
    1: 
    1: /*************************/
    1: // nsXPCWrappedJSClass represents the sharable factored out common code and
    1: // data for nsXPCWrappedJS instances for the same interface type.
    1: 
    1: class nsXPCWrappedJSClass : public nsIXPCWrappedJSClass
    1: {
    1:     // all the interface method declarations...
    1:     NS_DECL_ISUPPORTS
    1:     NS_IMETHOD DebugDump(PRInt16 depth);
    1: public:
    1: 
    1:     static nsresult
    1:     GetNewOrUsed(XPCCallContext& ccx,
    1:                  REFNSIID aIID,
    1:                  nsXPCWrappedJSClass** clazz);
    1: 
    1:     REFNSIID GetIID() const {return mIID;}
    1:     XPCJSRuntime* GetRuntime() const {return mRuntime;}
    1:     nsIInterfaceInfo* GetInterfaceInfo() const {return mInfo;}
    1:     const char* GetInterfaceName();
    1: 
    1:     static JSBool IsWrappedJS(nsISupports* aPtr);
    1: 
    1:     NS_IMETHOD DelegatedQueryInterface(nsXPCWrappedJS* self, REFNSIID aIID,
    1:                                        void** aInstancePtr);
    1: 
    1:     JSObject* GetRootJSObject(XPCCallContext& ccx, JSObject* aJSObj);
    1: 
    1:     NS_IMETHOD CallMethod(nsXPCWrappedJS* wrapper, uint16 methodIndex,
    1:                           const XPTMethodDescriptor* info,
    1:                           nsXPTCMiniVariant* params);
    1: 
    1:     JSObject*  CallQueryInterfaceOnJSObject(XPCCallContext& ccx,
    1:                                             JSObject* jsobj, REFNSIID aIID);
    1: 
    1:     static nsresult BuildPropertyEnumerator(XPCCallContext& ccx,
    1:                                             JSObject* aJSObj,
    1:                                             nsISimpleEnumerator** aEnumerate);
    1: 
    1:     static nsresult GetNamedPropertyAsVariant(XPCCallContext& ccx, 
    1:                                               JSObject* aJSObj,
    1:                                               jsval aName, 
    1:                                               nsIVariant** aResult);
    1: 
    1:     virtual ~nsXPCWrappedJSClass();
    1: 
    1:     static nsresult CheckForException(XPCCallContext & ccx,
    1:                                       const char * aPropertyName,
14170:                                       const char * anInterfaceName,
14170:                                       PRBool aForceReport);
    1: private:
    1:     nsXPCWrappedJSClass();   // not implemented
    1:     nsXPCWrappedJSClass(XPCCallContext& ccx, REFNSIID aIID,
    1:                         nsIInterfaceInfo* aInfo);
    1: 
    1:     JSObject*  NewOutObject(JSContext* cx);
    1: 
    1:     JSBool IsReflectable(uint16 i) const
    1:         {return (JSBool)(mDescriptors[i/32] & (1 << (i%32)));}
    1:     void SetReflectable(uint16 i, JSBool b)
    1:         {if(b) mDescriptors[i/32] |= (1 << (i%32));
    1:          else mDescriptors[i/32] &= ~(1 << (i%32));}
    1: 
    1:     enum SizeMode {GET_SIZE, GET_LENGTH};
    1: 
    1:     JSBool GetArraySizeFromParam(JSContext* cx,
    1:                                  const XPTMethodDescriptor* method,
    1:                                  const nsXPTParamInfo& param,
    1:                                  uint16 methodIndex,
    1:                                  uint8 paramIndex,
    1:                                  SizeMode mode,
    1:                                  nsXPTCMiniVariant* params,
    1:                                  JSUint32* result);
    1: 
    1:     JSBool GetInterfaceTypeFromParam(JSContext* cx,
    1:                                      const XPTMethodDescriptor* method,
    1:                                      const nsXPTParamInfo& param,
    1:                                      uint16 methodIndex,
    1:                                      const nsXPTType& type,
    1:                                      nsXPTCMiniVariant* params,
    1:                                      nsID* result);
    1: 
    1:     void CleanupPointerArray(const nsXPTType& datum_type,
    1:                              JSUint32 array_count,
    1:                              void** arrayp);
    1: 
    1:     void CleanupPointerTypeObject(const nsXPTType& type,
    1:                                   void** pp);
    1: 
    1: private:
    1:     XPCJSRuntime* mRuntime;
    1:     nsIInterfaceInfo* mInfo;
    1:     char* mName;
    1:     nsIID mIID;
    1:     uint32* mDescriptors;
    1: };
    1: 
    1: /*************************/
    1: // nsXPCWrappedJS is a wrapper for a single JSObject for use from native code.
    1: // nsXPCWrappedJS objects are chained together to represent the various
    1: // interface on the single underlying (possibly aggregate) JSObject.
    1: 
    1: class nsXPCWrappedJS : protected nsAutoXPTCStub,
    1:                        public nsIXPConnectWrappedJS,
    1:                        public nsSupportsWeakReference,
 2072:                        public nsIPropertyBag,
 2072:                        public XPCRootSetElem
    1: {
    1: public:
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIXPCONNECTJSOBJECTHOLDER
    1:     NS_DECL_NSIXPCONNECTWRAPPEDJS
    1:     NS_DECL_NSISUPPORTSWEAKREFERENCE
    1:     NS_DECL_NSIPROPERTYBAG
10981: 
10981:     class NS_CYCLE_COLLECTION_INNERCLASS
10981:      : public nsXPCOMCycleCollectionParticipant
10981:     {
10981:       NS_IMETHOD RootAndUnlinkJSObjects(void *p);
10981:       NS_DECL_CYCLE_COLLECTION_CLASS_BODY(nsXPCWrappedJS, nsIXPConnectWrappedJS)
10981:     };
10981:     NS_CYCLE_COLLECTION_PARTICIPANT_INSTANCE
    1:     NS_DECL_CYCLE_COLLECTION_UNMARK_PURPLE_STUB(nsXPCWrappedJS)
    1: 
    1:     NS_IMETHOD CallMethod(PRUint16 methodIndex,
    1:                           const XPTMethodDescriptor *info,
    1:                           nsXPTCMiniVariant* params);
    1: 
    1:     /*
    1:     * This is rarely called directly. Instead one usually calls
    1:     * XPCConvert::JSObject2NativeInterface which will handles cases where the
    1:     * JS object is already a wrapped native or a DOM object.
    1:     */
    1: 
    1:     static nsresult
    1:     GetNewOrUsed(XPCCallContext& ccx,
    1:                  JSObject* aJSObj,
    1:                  REFNSIID aIID,
    1:                  nsISupports* aOuter,
    1:                  nsXPCWrappedJS** wrapper);
    1: 
    1:     nsISomeInterface* GetXPTCStub() { return mXPTCStub; }
    1:     JSObject* GetJSObject() const {return mJSObj;}
    1:     nsXPCWrappedJSClass*  GetClass() const {return mClass;}
    1:     REFNSIID GetIID() const {return GetClass()->GetIID();}
    1:     nsXPCWrappedJS* GetRootWrapper() const {return mRoot;}
    1:     nsXPCWrappedJS* GetNextWrapper() const {return mNext;}
    1: 
    1:     nsXPCWrappedJS* Find(REFNSIID aIID);
    1:     nsXPCWrappedJS* FindInherited(REFNSIID aIID);
    1: 
    1:     JSBool IsValid() const {return mJSObj != nsnull;}
    1:     void SystemIsBeingShutDown(JSRuntime* rt);
    1: 
    1:     // This is used by XPCJSRuntime::GCCallback to find wrappers that no
    1:     // longer root their JSObject and are only still alive because they
    1:     // were being used via nsSupportsWeakReference at the time when their
    1:     // last (outside) reference was released. Wrappers that fit into that
    1:     // category are only deleted when we see that their corresponding JSObject
    1:     // is to be finalized.
    1:     JSBool IsSubjectToFinalization() const {return IsValid() && mRefCnt == 1;}
    1: 
    1:     JSBool IsAggregatedToNative() const {return mRoot->mOuter != nsnull;}
    1:     nsISupports* GetAggregatedNativeObject() const {return mRoot->mOuter;}
    1: 
 2072:     void TraceJS(JSTracer* trc);
 2072: #ifdef DEBUG
 2072:     static void PrintTraceName(JSTracer* trc, char *buf, size_t bufsize);
 2072: #endif
 2072: 
    1:     virtual ~nsXPCWrappedJS();
    1: protected:
    1:     nsXPCWrappedJS();   // not implemented
    1:     nsXPCWrappedJS(XPCCallContext& ccx,
    1:                    JSObject* aJSObj,
    1:                    nsXPCWrappedJSClass* aClass,
    1:                    nsXPCWrappedJS* root,
    1:                    nsISupports* aOuter);
    1: 
 7286:    void Unlink();
 7286: 
    1: private:
    1:     JSObject* mJSObj;
    1:     nsXPCWrappedJSClass* mClass;
    1:     nsXPCWrappedJS* mRoot;
    1:     nsXPCWrappedJS* mNext;
    1:     nsISupports* mOuter;    // only set in root
    1: };
    1: 
    1: /***************************************************************************/
    1: 
 2072: class XPCJSObjectHolder : public nsIXPConnectJSObjectHolder,
 2072:                           public XPCRootSetElem
    1: {
    1: public:
    1:     // all the interface method declarations...
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIXPCONNECTJSOBJECTHOLDER
    1: 
    1:     // non-interface implementation
    1: 
    1: public:
 2072:     static XPCJSObjectHolder* newHolder(XPCCallContext& ccx, JSObject* obj);
    1: 
    1:     virtual ~XPCJSObjectHolder();
    1: 
 2072:     void TraceJS(JSTracer *trc);
 2072: #ifdef DEBUG
 2072:     static void PrintTraceName(JSTracer* trc, char *buf, size_t bufsize);
 2072: #endif
 2072: 
    1: private:
 2072:     XPCJSObjectHolder(XPCCallContext& ccx, JSObject* obj);
    1:     XPCJSObjectHolder(); // not implemented
    1: 
    1:     JSObject* mJSObj;
    1: };
    1: 
    1: /***************************************************************************
    1: ****************************************************************************
    1: *
    1: * All manner of utility classes follow...
    1: *
    1: ****************************************************************************
    1: ***************************************************************************/
    1: 
    1: class xpcProperty : public nsIProperty
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIPROPERTY
    1: 
    1:   xpcProperty(const PRUnichar* aName, PRUint32 aNameLen, nsIVariant* aValue);
    1:   virtual ~xpcProperty() {}
    1: 
    1: private:
    1:     nsString             mName;
    1:     nsCOMPtr<nsIVariant> mValue;
    1: };
    1: 
    1: class xpcPropertyBagEnumerator : public nsISimpleEnumerator
    1: {
    1: public:
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSISIMPLEENUMERATOR
    1: 
    1:     xpcPropertyBagEnumerator(PRUint32 count);
    1:     virtual ~xpcPropertyBagEnumerator() {}
    1: 
    1:     JSBool AppendElement(nsISupports* element);
    1: 
    1: private:
    1:     nsSupportsArray mArray;
    1:     PRUint32        mIndex;
    1:     PRUint32        mCount;
    1: };
    1: 
    1: /***************************************************************************/
    1: // data conversion
    1: 
    1: // class here just for static methods
    1: class XPCConvert
    1: {
    1: public:
    1:     static JSBool IsMethodReflectable(const XPTMethodDescriptor& info);
    1: 
    1:     /**
    1:      * Convert a native object into a jsval.
    1:      *
    1:      * @param ccx the context for the whole procedure
    1:      * @param d [out] the resulting jsval
    1:      * @param s the native object we're working with
    1:      * @param type the type of object that s is
    1:      * @param iid the interface of s that we want
    1:      * @param scope the default scope to put on the new JSObject's __parent__
    1:      *        chain
    1:      * @param pErr [out] relevant error code, if any.
    1:      */    
    1:     static JSBool NativeData2JS(XPCCallContext& ccx, jsval* d, const void* s,
    1:                                 const nsXPTType& type, const nsID* iid,
    1:                                 JSObject* scope, nsresult* pErr);
    1: 
    1:     static JSBool JSData2Native(XPCCallContext& ccx, void* d, jsval s,
    1:                                 const nsXPTType& type,
    1:                                 JSBool useAllocator, const nsID* iid,
    1:                                 nsresult* pErr);
    1: 
    1:     /**
    1:      * Convert a native nsISupports into a JSObject.
    1:      *
    1:      * @param ccx the context for the whole procedure
    1:      * @param dest [out] the resulting JSObject
    1:      * @param src the native object we're working with
    1:      * @param iid the interface of src that we want
    1:      * @param scope the default scope to put on the new JSObject's __parent__
    1:      *        chain
    1:      * @param allowNativeWrapper if true, this method may wrap the resulting
    1:      *        JSObject in an XPCNativeWrapper and return that, as needed.
    1:      * @param pErr [out] relevant error code, if any.
    1:      */
    1:     static JSBool NativeInterface2JSObject(XPCCallContext& ccx,
22065:                                            jsval* d,
    1:                                            nsIXPConnectJSObjectHolder** dest,
    1:                                            nsISupports* src,
    1:                                            const nsID* iid,
    1:                                            JSObject* scope,
    1:                                            PRBool allowNativeWrapper,
    1:                                            PRBool isGlobal,
    1:                                            nsresult* pErr);
22065:     static JSBool NativeInterface2JSObject(XPCCallContext& ccx,
22065:                                            JSObject** dest,
22065:                                            nsISupports* src,
22065:                                            const nsID* iid,
22065:                                            JSObject* scope,
22065:                                            PRBool allowNativeWrapper,
22065:                                            PRBool isGlobal,
22065:                                            nsresult* pErr)
22065:     {
22065:         jsval v;
22071:         JSBool ok = NativeInterface2JSObject(ccx, &v, nsnull, src, iid, scope,
22071:                                              allowNativeWrapper, isGlobal,
22071:                                              pErr);
22065:         *dest = JSVAL_TO_OBJECT(v);
22065:         return ok;
22065:     }
    1: 
    1:     static JSBool GetNativeInterfaceFromJSObject(XPCCallContext& ccx,
    1:                                                  void** dest, JSObject* src,
    1:                                                  const nsID* iid, 
    1:                                                  nsresult* pErr);
    1:     static JSBool JSObject2NativeInterface(XPCCallContext& ccx,
    1:                                            void** dest, JSObject* src,
    1:                                            const nsID* iid,
    1:                                            nsISupports* aOuter,
    1:                                            nsresult* pErr);
18543:     static JSBool GetISupportsFromJSObject(JSObject* obj, nsISupports** iface);
    1: 
    1:     /**
    1:      * Convert a native array into a jsval.
    1:      *
    1:      * @param ccx the context for the whole procedure
    1:      * @param d [out] the resulting jsval
    1:      * @param s the native array we're working with
    1:      * @param type the type of objects in the array
    1:      * @param iid the interface of each object in the array that we want
    1:      * @param count the number of items in the array
    1:      * @param scope the default scope to put on the new JSObjects' __parent__
    1:      *        chain
    1:      * @param pErr [out] relevant error code, if any.
    1:      */    
    1:     static JSBool NativeArray2JS(XPCCallContext& ccx,
    1:                                  jsval* d, const void** s,
    1:                                  const nsXPTType& type, const nsID* iid,
    1:                                  JSUint32 count, JSObject* scope,
    1:                                  nsresult* pErr);
    1: 
    1:     static JSBool JSArray2Native(XPCCallContext& ccx, void** d, jsval s,
    1:                                  JSUint32 count, JSUint32 capacity,
    1:                                  const nsXPTType& type,
    1:                                  JSBool useAllocator, const nsID* iid,
    1:                                  uintN* pErr);
    1: 
    1:     static JSBool NativeStringWithSize2JS(XPCCallContext& ccx,
    1:                                           jsval* d, const void* s,
    1:                                           const nsXPTType& type,
    1:                                           JSUint32 count,
    1:                                           nsresult* pErr);
    1: 
    1:     static JSBool JSStringWithSize2Native(XPCCallContext& ccx, void* d, jsval s,
    1:                                           JSUint32 count, JSUint32 capacity,
    1:                                           const nsXPTType& type,
    1:                                           JSBool useAllocator,
    1:                                           uintN* pErr);
    1: 
    1:     static nsresult JSValToXPCException(XPCCallContext& ccx,
    1:                                         jsval s,
    1:                                         const char* ifaceName,
    1:                                         const char* methodName,
    1:                                         nsIException** exception);
    1: 
    1:     static nsresult JSErrorToXPCException(XPCCallContext& ccx,
    1:                                           const char* message,
    1:                                           const char* ifaceName,
    1:                                           const char* methodName,
    1:                                           const JSErrorReport* report,
    1:                                           nsIException** exception);
    1: 
    1:     static nsresult ConstructException(nsresult rv, const char* message,
    1:                                        const char* ifaceName,
    1:                                        const char* methodName,
    1:                                        nsISupports* data,
19303:                                        nsIException** exception,
21377:                                        JSContext* cx,
21377:                                        jsval *jsExceptionPtr);
    1: 
    1:     static void RemoveXPCOMUCStringFinalizer();
    1: 
    1: private:
    1:     XPCConvert(); // not implemented
21873: 
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: // readable string conversions, static methods only
    1: class XPCStringConvert
    1: {
    1: public:
    1: 
    1:     static JSString *ReadableToJSString(JSContext *cx,
    1:                                         const nsAString &readable);
    1: 
 9332:     static XPCReadableJSStringWrapper *JSStringToReadable(XPCCallContext& ccx,
 9332:                                                           JSString *str);
    1: 
    1:     static void ShutdownDOMStringFinalizer();
    1: 
    1: private:
    1:     XPCStringConvert();         // not implemented
    1: };
    1: 
18907: extern JSBool
    1: XPC_JSArgumentFormatter(JSContext *cx, const char *format,
    1:                         JSBool fromJS, jsval **vpp, va_list *app);
    1: 
    1: 
    1: /***************************************************************************/
    1: // code for throwing exceptions into JS
    1: 
    1: class XPCThrower
    1: {
    1: public:
    1:     static void Throw(nsresult rv, JSContext* cx);
    1:     static void Throw(nsresult rv, XPCCallContext& ccx);
    1:     static void ThrowBadResult(nsresult rv, nsresult result, XPCCallContext& ccx);
    1:     static void ThrowBadParam(nsresult rv, uintN paramNum, XPCCallContext& ccx);
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     static void ThrowCOMError(JSContext* cx, unsigned long COMErrorCode, 
    1:                               nsresult rv = NS_ERROR_XPC_COM_ERROR,
    1:                               const EXCEPINFO * exception = nsnull);
    1: #endif
    1:     static JSBool SetVerbosity(JSBool state)
    1:         {JSBool old = sVerbose; sVerbose = state; return old;}
    1: 
18543:     static void BuildAndThrowException(JSContext* cx, nsresult rv, const char* sz);
18543:     static JSBool CheckForPendingException(nsresult result, JSContext *cx);
18543: 
    1: private:
    1:     static void Verbosify(XPCCallContext& ccx,
    1:                           char** psz, PRBool own);
    1: 
    1:     static JSBool ThrowExceptionObject(JSContext* cx, nsIException* e);
    1: 
    1: private:
    1:     static JSBool sVerbose;
    1: };
    1: 
    1: 
    1: /***************************************************************************/
    1: 
    1: class XPCJSStack
    1: {
    1: public:
    1:     static nsresult
    1:     CreateStack(JSContext* cx, nsIStackFrame** stack);
    1: 
    1:     static nsresult
    1:     CreateStackFrameLocation(PRUint32 aLanguage,
    1:                              const char* aFilename,
    1:                              const char* aFunctionName,
    1:                              PRInt32 aLineNumber,
    1:                              nsIStackFrame* aCaller,
    1:                              nsIStackFrame** stack);
    1: private:
    1:     XPCJSStack();   // not implemented
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: class nsXPCException :
    1:             public nsIXPCException
    1: {
    1: public:
    1:     NS_DEFINE_STATIC_CID_ACCESSOR(NS_XPCEXCEPTION_CID)
    1: 
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIEXCEPTION
    1:     NS_DECL_NSIXPCEXCEPTION
    1: 
    1:     static nsresult NewException(const char *aMessage,
    1:                                  nsresult aResult,
    1:                                  nsIStackFrame *aLocation,
    1:                                  nsISupports *aData,
    1:                                  nsIException** exception);
    1: 
    1:     static JSBool NameAndFormatForNSResult(nsresult rv,
    1:                                            const char** name,
    1:                                            const char** format);
    1: 
    1:     static void* IterateNSResults(nsresult* rv,
    1:                                   const char** name,
    1:                                   const char** format,
    1:                                   void** iterp);
    1: 
    1:     static PRUint32 GetNSResultCount();
    1: 
    1:     nsXPCException();
    1:     virtual ~nsXPCException();
    1: 
    1:     static void InitStatics() { sEverMadeOneFromFactory = JS_FALSE; }
    1: 
21377:     PRBool StealThrownJSVal(jsval* vp);
21377:     void StowThrownJSVal(JSContext* cx, jsval v);
19303: 
    1: protected:
    1:     void Reset();
    1: private:
    1:     char*           mMessage;
    1:     nsresult        mResult;
    1:     char*           mName;
    1:     nsIStackFrame*  mLocation;
    1:     nsISupports*    mData;
    1:     char*           mFilename;
    1:     int             mLineNumber;
    1:     nsIException*   mInner;
    1:     PRBool          mInitialized;
    1: 
21377:     nsAutoJSValHolder mThrownJSVal;
19303: 
    1:     static JSBool sEverMadeOneFromFactory;
    1: };
    1: 
    1: /***************************************************************************/
    1: /*
    1: * nsJSID implements nsIJSID. It is also used by nsJSIID and nsJSCID as a
    1: * member (as a hidden implementaion detail) to which they delegate many calls.
    1: */
    1: 
    1: extern JSBool xpc_InitJSxIDClassObjects();
    1: extern void xpc_DestroyJSxIDClassObjects();
    1: 
    1: 
    1: class nsJSID : public nsIJSID
    1: {
    1: public:
    1:     NS_DEFINE_STATIC_CID_ACCESSOR(NS_JS_ID_CID)
    1: 
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIJSID
    1: 
    1:     PRBool InitWithName(const nsID& id, const char *nameString);
    1:     PRBool SetName(const char* name);
    1:     void   SetNameToNoString()
    1:         {NS_ASSERTION(!mName, "name already set"); mName = gNoString;}
    1:     PRBool NameIsSet() const {return nsnull != mName;}
10204:     const nsID& ID() const {return mID;}
    1:     PRBool IsValid() const {return !mID.Equals(GetInvalidIID());}
    1: 
    1:     static nsJSID* NewID(const char* str);
10204:     static nsJSID* NewID(const nsID& id);
    1: 
    1:     nsJSID();
    1:     virtual ~nsJSID();
    1: protected:
    1: 
    1:     void Reset();
    1:     const nsID& GetInvalidIID() const;
    1: 
    1: protected:
    1:     static char gNoString[];
    1:     nsID    mID;
    1:     char*   mNumber;
    1:     char*   mName;
    1: };
    1: 
    1: // nsJSIID
    1: 
    1: class nsJSIID : public nsIJSIID, public nsIXPCScriptable
    1: #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
    1:           , public nsISecurityCheckedComponent
    1: #endif
    1: {
    1: public:
    1:     NS_DECL_ISUPPORTS
    1: 
    1:     // we manually delagate these to nsJSID
    1:     NS_DECL_NSIJSID
    1: 
    1:     // we implement the rest...
    1:     NS_DECL_NSIJSIID
    1:     NS_DECL_NSIXPCSCRIPTABLE
    1: #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
    1:     NS_DECL_NSISECURITYCHECKEDCOMPONENT
    1: #endif
    1: 
    1:     static nsJSIID* NewID(nsIInterfaceInfo* aInfo);
    1: 
    1:     nsJSIID(nsIInterfaceInfo* aInfo);
    1:     nsJSIID(); // not implemented
    1:     virtual ~nsJSIID();
    1: 
    1: private:
    1:     nsCOMPtr<nsIInterfaceInfo> mInfo;
    1: };
    1: 
    1: // nsJSCID
    1: 
    1: class nsJSCID : public nsIJSCID, public nsIXPCScriptable
    1: {
    1: public:
    1:     NS_DECL_ISUPPORTS
    1: 
    1:     // we manually delagate these to nsJSID
    1:     NS_DECL_NSIJSID
    1: 
    1:     // we implement the rest...
    1:     NS_DECL_NSIJSCID
    1:     NS_DECL_NSIXPCSCRIPTABLE
    1: 
    1:     static nsJSCID* NewID(const char* str);
    1: 
    1:     nsJSCID();
    1:     virtual ~nsJSCID();
    1: 
    1: private:
    1:     void ResolveName();
    1: 
    1: private:
    1:     nsJSID mDetails;
    1: };
    1: 
    1: 
    1: /***************************************************************************/
    1: // XPCJSContextStack is not actually an xpcom object, but xpcom calls are
    1: // delegated to it as an implementation detail.
10990: struct XPCJSContextInfo {
10990:     XPCJSContextInfo(JSContext* aCx) :
 1104:         cx(aCx),
10990:         frame(nsnull),
10990:         requestDepth(0)
 1104:     {}
 1104:     JSContext* cx;
10990: 
10990:     // Frame to be restored when this JSContext becomes the topmost
10990:     // one.
10990:     JSStackFrame* frame;
10990: 
10990:     // Greater than 0 if a request was suspended
10990:     jsrefcount requestDepth;
 1104: };
    1: 
    1: class XPCJSContextStack
    1: {
    1: public:
    1:     NS_DECL_NSIJSCONTEXTSTACK
    1:     NS_DECL_NSITHREADJSCONTEXTSTACK
    1: 
    1:     XPCJSContextStack();
    1:     virtual ~XPCJSContextStack();
    1: 
    1: #ifdef DEBUG
    1:     JSBool DEBUG_StackHasJSContext(JSContext*  aJSContext);
    1: #endif
    1: 
10990:     const nsTArray<XPCJSContextInfo>* GetStack()
 1104:     { return &mStack; }
    1: 
    1: private:
10990:     nsAutoTArray<XPCJSContextInfo, 16> mStack;
    1:     JSContext*  mSafeJSContext;
    1: 
    1:     // If non-null, we own it; same as mSafeJSContext if SetSafeJSContext
    1:     // not called.
    1:     JSContext*  mOwnSafeJSContext;
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: #define NS_XPC_JSCONTEXT_STACK_ITERATOR_CID \
    1: { 0x05bae29d, 0x8aef, 0x486d, \
    1:   { 0x84, 0xaa, 0x53, 0xf4, 0x8f, 0x14, 0x68, 0x11 } }
    1: 
    1: class nsXPCJSContextStackIterator : public nsIJSContextStackIterator
    1: {
    1: public:
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIJSCONTEXTSTACKITERATOR
    1: 
    1: private:
10990:     const nsTArray<XPCJSContextInfo> *mStack;
 1104:     PRUint32 mPosition;
    1: };
    1: 
    1: /**************************************************************/
    1: // All of our thread local storage.
    1: 
    1: #define BAD_TLS_INDEX ((PRUint32) -1)
    1: 
    1: class XPCPerThreadData
    1: {
    1: public:
    1:     // Get the instance of this object for the current thread
10490:     static inline XPCPerThreadData* GetData(JSContext *cx)
10490:     {
10490:         if(cx)
10490:         {
10490:             NS_ASSERTION(cx->thread, "Uh, JS context w/o a thread?");
10490: 
10490:             if(cx->thread == sMainJSThread)
10490:                 return sMainThreadData;
10490:         }
15864:         else if(sMainThreadData && sMainThreadData->mThread == PR_GetCurrentThread())
15864:         {
15864:             return sMainThreadData;
15864:         }
10490: 
10490:         return GetDataImpl(cx);
10490:     }
10490: 
    1:     static void CleanupAllThreads();
    1: 
    1:     ~XPCPerThreadData();
    1: 
    1:     nsresult GetException(nsIException** aException)
    1:     {
    1:         if(EnsureExceptionManager())
    1:             return mExceptionManager->GetCurrentException(aException);
    1: 
    1:         NS_IF_ADDREF(mException);
    1:         *aException = mException;
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsresult SetException(nsIException* aException)
    1:     {
    1:         if(EnsureExceptionManager())
    1:             return mExceptionManager->SetCurrentException(aException);
    1: 
    1:         NS_IF_ADDREF(aException);
    1:         NS_IF_RELEASE(mException);
    1:         mException = aException;
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsIExceptionManager* GetExceptionManager()
    1:     {
    1:         if(EnsureExceptionManager())
    1:             return mExceptionManager;
    1:         return nsnull;
    1:     }
    1: 
    1:     JSBool EnsureExceptionManager()
    1:     {
    1:         if(mExceptionManager)
    1:             return JS_TRUE;
    1: 
    1:         if(mExceptionManagerNotAvailable)
    1:             return JS_FALSE;
    1: 
    1:         nsCOMPtr<nsIExceptionService> xs =
    1:             do_GetService(NS_EXCEPTIONSERVICE_CONTRACTID);
    1:         if(xs)
    1:             xs->GetCurrentExceptionManager(&mExceptionManager);
    1:         if(mExceptionManager)
    1:             return JS_TRUE;
    1: 
    1:         mExceptionManagerNotAvailable = JS_TRUE;
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     XPCJSContextStack* GetJSContextStack() {return mJSContextStack;}
    1: 
    1:     XPCCallContext*  GetCallContext() const {return mCallContext;}
    1:     XPCCallContext*  SetCallContext(XPCCallContext* ccx)
    1:         {XPCCallContext* old = mCallContext; mCallContext = ccx; return old;}
    1: 
    1:     jsval GetResolveName() const {return mResolveName;}
    1:     jsval SetResolveName(jsval name)
    1:         {jsval old = mResolveName; mResolveName = name; return old;}
    1: 
    1:     XPCWrappedNative* GetResolvingWrapper() const {return mResolvingWrapper;}
    1:     XPCWrappedNative* SetResolvingWrapper(XPCWrappedNative* w)
    1:         {XPCWrappedNative* old = mResolvingWrapper;
    1:          mResolvingWrapper = w; return old;}
    1: 
    1:     void Cleanup();
    1:     void ReleaseNatives();
    1: 
    1:     PRBool IsValid() const {return mJSContextStack != nsnull;}
    1: 
    1:     static PRLock* GetLock() {return gLock;}
    1:     // Must be called with the threads locked.
    1:     static XPCPerThreadData* IterateThreads(XPCPerThreadData** iteratorp);
    1: 
    1:     AutoMarkingPtr**  GetAutoRootsAdr() {return &mAutoRoots;}
    1: 
 1025:     void TraceJS(JSTracer* trc);
    1:     void MarkAutoRootsAfterJSFinalize();
    1: 
    1:     jsuword GetStackLimit() const { return mStackLimit; }
    1: 
    1:     static void InitStatics()
    1:         { gLock = nsnull; gThreads = nsnull; gTLSIndex = BAD_TLS_INDEX; }
    1: 
    1: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
    1:     JSUint32  IncrementWrappedNativeThreadsafetyReportDepth()
    1:         {return ++mWrappedNativeThreadsafetyReportDepth;}
    1:     void      ClearWrappedNativeThreadsafetyReportDepth()
    1:         {mWrappedNativeThreadsafetyReportDepth = 0;}
    1: #endif
    1: 
10490:     static void ShutDown()
10490:         {sMainJSThread = nsnull; sMainThreadData = nsnull;}
10490: 
18543:     static PRBool IsMainThread(JSContext *cx)
18543:         { return cx->thread == sMainJSThread; }
18543: 
    1: private:
    1:     XPCPerThreadData();
10490:     static XPCPerThreadData* GetDataImpl(JSContext *cx);
    1: 
    1: private:
    1:     XPCJSContextStack*   mJSContextStack;
    1:     XPCPerThreadData*    mNextThread;
    1:     XPCCallContext*      mCallContext;
    1:     jsval                mResolveName;
    1:     XPCWrappedNative*    mResolvingWrapper;
    1: 
    1:     nsIExceptionManager* mExceptionManager;
    1:     nsIException*        mException;
    1:     JSBool               mExceptionManagerNotAvailable;
    1:     AutoMarkingPtr*      mAutoRoots;
    1: 
    1:     jsuword              mStackLimit;
    1: 
    1: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
    1:     JSUint32             mWrappedNativeThreadsafetyReportDepth;
    1: #endif
    1:     PRThread*            mThread;
    1: 
    1:     static PRLock*           gLock;
    1:     static XPCPerThreadData* gThreads;
    1:     static PRUintn           gTLSIndex;
10490: 
10490:     // Cached value of cx->thread on the main thread. 
10490:     static void *sMainJSThread;
10490: 
10490:     // Cached per thread data for the main thread. Only safe to access
10490:     // if cx->thread == sMainJSThread.
10490:     static XPCPerThreadData *sMainThreadData;
    1: };
    1: 
    1: /***************************************************************************/
    1: #ifndef XPCONNECT_STANDALONE
    1: #include "nsIScriptSecurityManager.h"
    1: 
    1: class BackstagePass : public nsIScriptObjectPrincipal,
    1:                       public nsIXPCScriptable,
    1:                       public nsIClassInfo
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIXPCSCRIPTABLE
    1:   NS_DECL_NSICLASSINFO
    1: 
    1:   virtual nsIPrincipal* GetPrincipal() {
    1:     return mPrincipal;
    1:   }
    1: 
    1:   BackstagePass(nsIPrincipal *prin) :
    1:     mPrincipal(prin)
    1:   {
    1:   }
    1: 
    1:   virtual ~BackstagePass() { }
    1: 
    1: private:
    1:   nsCOMPtr<nsIPrincipal> mPrincipal;
    1: };
    1: 
    1: #else
    1: 
    1: class BackstagePass : public nsIXPCScriptable, public nsIClassInfo
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIXPCSCRIPTABLE
    1:   NS_DECL_NSICLASSINFO
    1: 
    1:   BackstagePass()
    1:   {
    1:   }
    1: 
    1:   virtual ~BackstagePass() { }
    1: };
    1: 
    1: #endif
    1: 
    1: class nsJSRuntimeServiceImpl : public nsIJSRuntimeService,
    1:                                public nsSupportsWeakReference
    1: {
    1:  public:
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIJSRUNTIMESERVICE
    1: 
    1:     // This returns an AddRef'd pointer. It does not do this with an out param
    1:     // only because this form  is required by generic module macro:
    1:     // NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR
    1:     static nsJSRuntimeServiceImpl* GetSingleton();
    1: 
    1:     static void FreeSingleton();
    1: 
    1:     nsJSRuntimeServiceImpl();
    1:     virtual ~nsJSRuntimeServiceImpl();
    1: 
    1:     static void InitStatics() { gJSRuntimeService = nsnull; }
    1:  protected:
    1:     static nsJSRuntimeServiceImpl* gJSRuntimeService;
    1:     nsCOMPtr<nsIXPCScriptable> mBackstagePass;
    1: };
    1: 
    1: /***************************************************************************/
    1: // 'Components' object
    1: 
    1: class nsXPCComponents : public nsIXPCComponents,
    1:                         public nsIXPCScriptable,
    1:                         public nsIClassInfo
    1: #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
    1:                       , public nsISecurityCheckedComponent
    1: #endif
    1: {
    1: public:
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIXPCCOMPONENTS
    1:     NS_DECL_NSIXPCSCRIPTABLE
    1:     NS_DECL_NSICLASSINFO
    1: 
    1: #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
    1:     NS_DECL_NSISECURITYCHECKEDCOMPONENT
    1: #endif
    1: 
    1: public:
    1:     static JSBool
    1:     AttachNewComponentsObject(XPCCallContext& ccx,
    1:                               XPCWrappedNativeScope* aScope,
    1:                               JSObject* aGlobal);
    1: 
    1:     void SystemIsBeingShutDown() {ClearMembers();}
    1: 
    1:     virtual ~nsXPCComponents();
    1: 
    1: private:
    1:     nsXPCComponents();
    1:     void ClearMembers();
    1: 
    1: private:
    1:     nsXPCComponents_Interfaces*     mInterfaces;
    1:     nsXPCComponents_InterfacesByID* mInterfacesByID;
    1:     nsXPCComponents_Classes*        mClasses;
    1:     nsXPCComponents_ClassesByID*    mClassesByID;
    1:     nsXPCComponents_Results*        mResults;
    1:     nsXPCComponents_ID*             mID;
    1:     nsXPCComponents_Exception*      mException;
    1:     nsXPCComponents_Constructor*    mConstructor;
    1:     nsXPCComponents_Utils*          mUtils;
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: class nsXPCComponents_Interfaces :
    1:             public nsIScriptableInterfaces,
    1:             public nsIXPCScriptable,
    1:             public nsIClassInfo
    1: #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
    1:           , public nsISecurityCheckedComponent
    1: #endif
    1: {
    1: public:
    1:     // all the interface method declarations...
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSISCRIPTABLEINTERFACES
    1:     NS_DECL_NSIXPCSCRIPTABLE
    1:     NS_DECL_NSICLASSINFO
    1: #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
    1:     NS_DECL_NSISECURITYCHECKEDCOMPONENT
    1: #endif
    1: 
    1: public:
    1:     nsXPCComponents_Interfaces();
    1:     virtual ~nsXPCComponents_Interfaces();
    1: 
    1: private:
    1:     nsCOMPtr<nsIInterfaceInfoManager> mManager;
    1: };
    1: 
    1: 
    1: /***************************************************************************/
    1: 
    1: extern JSObject*
    1: xpc_NewIDObject(JSContext *cx, JSObject* jsobj, const nsID& aID);
    1: 
10204: extern const nsID*
    1: xpc_JSObjectToID(JSContext *cx, JSObject* obj);
    1: 
    1: extern JSBool
    1: xpc_JSObjectIsID(JSContext *cx, JSObject* obj);
    1: 
    1: /***************************************************************************/
    1: // in xpcdebug.cpp
    1: 
    1: extern JSBool
 5905: xpc_DumpJSStack(JSContext* cx, JSBool showArgs, JSBool showLocals,
    1:                 JSBool showThisProps);
    1: 
    1: extern JSBool
    1: xpc_DumpEvalInJSStackFrame(JSContext* cx, JSUint32 frameno, const char* text);
    1: 
    1: extern JSBool
    1: xpc_DumpJSObject(JSObject* obj);
    1: 
    1: extern JSBool
    1: xpc_InstallJSDebuggerKeywordHandler(JSRuntime* rt);
    1: 
    1: /***************************************************************************/
    1: 
    1: // Definition of nsScriptError, defined here because we lack a place to put
    1: // XPCOM objects associated with the JavaScript engine.
    1: class nsScriptError : public nsIScriptError {
    1: public:
    1:     nsScriptError();
    1: 
    1:     virtual ~nsScriptError();
    1: 
    1:   // TODO - do something reasonable on getting null from these babies.
    1: 
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSICONSOLEMESSAGE
    1:     NS_DECL_NSISCRIPTERROR
    1: 
    1: private:
    1:     nsString mMessage;
    1:     nsString mSourceName;
    1:     PRUint32 mLineNumber;
    1:     nsString mSourceLine;
    1:     PRUint32 mColumnNumber;
    1:     PRUint32 mFlags;
    1:     nsCString mCategory;
    1: };
    1: 
    1: /***************************************************************************/
    1: // XXX allowing for future notifications to XPCCallContext
    1: 
    1: class AutoJSRequest
    1: {
    1: public:
    1:     AutoJSRequest(XPCCallContext& aCCX)
    1:       : mCCX(aCCX), mCX(aCCX.GetJSContext()) {BeginRequest();}
    1:     ~AutoJSRequest() {EndRequest();}
    1: 
    1:     void EndRequest() {
    1:         if(mCX) {
    1:             JS_EndRequest(mCX);
    1:             mCX = nsnull;
    1:         }
    1:     }
    1: private:
    1:     void BeginRequest() {
    1:         if(JS_GetContextThread(mCX))
    1:             JS_BeginRequest(mCX);
    1:         else
    1:             mCX = nsnull;
    1:     }
    1: private:
    1:     XPCCallContext& mCCX;
    1:     JSContext* mCX;
    1: };
    1: 
    1: class AutoJSSuspendRequest
    1: {
    1: public:
    1:     AutoJSSuspendRequest(XPCCallContext& aCCX)
15178:       : mCX(aCCX.GetJSContext()) {SuspendRequest();}
    1:     ~AutoJSSuspendRequest() {ResumeRequest();}
    1: 
    1:     void ResumeRequest() {
    1:         if(mCX) {
    1:             JS_ResumeRequest(mCX, mDepth);
    1:             mCX = nsnull;
    1:         }
    1:     }
    1: private:
    1:     void SuspendRequest() {
    1:         if(JS_GetContextThread(mCX))
    1:             mDepth = JS_SuspendRequest(mCX);
    1:         else
    1:             mCX = nsnull;
    1:     }
    1: private:
    1:     JSContext* mCX;
    1:     jsrefcount mDepth;
    1: };
    1: 
15178: class AutoJSSuspendRequestWithNoCallContext
15178: {
15178: public:
15178:     AutoJSSuspendRequestWithNoCallContext(JSContext *aCX)
15178:       : mCX(aCX) {SuspendRequest();}
15178:     ~AutoJSSuspendRequestWithNoCallContext() {ResumeRequest();}
15178: 
15178:     void ResumeRequest() {
15178:         if(mCX) {
15178:             JS_ResumeRequest(mCX, mDepth);
15178:             mCX = nsnull;
15178:         }
15178:     }
15178: private:
15178:     void SuspendRequest() {
15178:         if(JS_GetContextThread(mCX))
15178:             mDepth = JS_SuspendRequest(mCX);
15178:         else
15178:             mCX = nsnull;
15178:     }
15178: private:
15178:     JSContext* mCX;
15178:     jsrefcount mDepth;
15178: };
15178: 
15178: class AutoJSSuspendNonMainThreadRequest
15178: {
15178: public:
15178:     AutoJSSuspendNonMainThreadRequest(JSContext *aCX)
15178:         : mCX(aCX) {SuspendRequest();}
15178:     ~AutoJSSuspendNonMainThreadRequest() {ResumeRequest();}
15178: 
15178:     void ResumeRequest() {
15178:         if (mCX) {
15178:             JS_ResumeRequest(mCX, mDepth);
15178:             mCX = nsnull;
15178:         }
15178:     }
15178: 
15178: private:
15178:     void SuspendRequest() {
18543:         if (mCX && !XPCPerThreadData::IsMainThread(mCX))
15178:             mDepth = JS_SuspendRequest(mCX);
15178:         else
15178:             mCX = nsnull;
15178:     }
15178: 
15178:     JSContext *mCX;
15178:     jsrefcount mDepth;
15178: };
15178:         
15178: 
    1: /*****************************************/
    1: 
    1: class AutoJSRequestWithNoCallContext
    1: {
    1: public:
    1:     AutoJSRequestWithNoCallContext(JSContext* aCX) : mCX(aCX) {BeginRequest();}
    1:     ~AutoJSRequestWithNoCallContext() {EndRequest();}
    1: 
    1:     void EndRequest() {
    1:         if(mCX) {
    1:             JS_EndRequest(mCX);
    1:             mCX = nsnull;
    1:         }
    1:     }
    1: private:
    1:     void BeginRequest() {
    1:         if(JS_GetContextThread(mCX))
    1:             JS_BeginRequest(mCX);
    1:         else
    1:             mCX = nsnull;
    1:     }
    1: private:
    1:     JSContext* mCX;
    1: };
    1: 
    1: /***************************************************************************/
    1: class AutoJSErrorAndExceptionEater
    1: {
    1: public:
    1:     AutoJSErrorAndExceptionEater(JSContext* aCX)
    1:         : mCX(aCX),
    1:           mOldErrorReporter(JS_SetErrorReporter(mCX, nsnull)),
    1:           mOldExceptionState(JS_SaveExceptionState(mCX)) {}
    1:     ~AutoJSErrorAndExceptionEater()
    1:     {
    1:         JS_SetErrorReporter(mCX, mOldErrorReporter);
    1:         JS_RestoreExceptionState(mCX, mOldExceptionState);
    1:     }
    1: private:
    1:     JSContext*        mCX;
    1:     JSErrorReporter   mOldErrorReporter;
    1:     JSExceptionState* mOldExceptionState;
    1: };
    1: 
    1: /******************************************************************************
    1:  * Handles pre/post script processing and the setting/resetting the error
    1:  * reporter
    1:  */
    1: class AutoScriptEvaluate
    1: {
    1: public:
    1:     /**
    1:      * Saves the JSContext as well as initializing our state
    1:      * @param cx The JSContext, this can be null, we don't do anything then
    1:      */
    1:     AutoScriptEvaluate(JSContext * cx)
20343:          : mJSContext(cx), mState(0), mErrorReporterSet(PR_FALSE),
20343:            mEvaluated(PR_FALSE), mContextHasThread(0) {}
    1: 
    1:     /**
    1:      * Does the pre script evaluation and sets the error reporter if given
    1:      * This function should only be called once, and will assert if called
    1:      * more than once
    1:      * @param errorReporter the error reporter callback function to set
    1:      */
    1: 
    1:     void StartEvaluating(JSErrorReporter errorReporter = nsnull);
    1:     /**
    1:      * Does the post script evaluation and resets the error reporter
    1:      */
    1:     ~AutoScriptEvaluate();
    1: private:
    1:     JSContext* mJSContext;
    1:     JSExceptionState* mState;
20343:     PRBool mErrorReporterSet;
    1:     PRBool mEvaluated;
    1:     jsword mContextHasThread;
    1: 
    1:     // No copying or assignment allowed
    1:     AutoScriptEvaluate(const AutoScriptEvaluate &);
    1:     AutoScriptEvaluate & operator =(const AutoScriptEvaluate &);
    1: };
    1: 
    1: /***************************************************************************/
    1: class AutoResolveName
    1: {
    1: public:
    1:     AutoResolveName(XPCCallContext& ccx, jsval name)
    1:         : mTLS(ccx.GetThreadData()),
    1:           mOld(mTLS->SetResolveName(name)),
    1:           mCheck(name) {}
    1:     ~AutoResolveName()
    1:         {
    1: #ifdef DEBUG
    1:             jsval old = 
    1: #endif
    1:             mTLS->SetResolveName(mOld);
    1:             NS_ASSERTION(old == mCheck, "Bad Nesting!");
    1:         }
    1: 
    1: private:
    1:     XPCPerThreadData* mTLS;
    1:     jsval mOld;
    1:     jsval mCheck;
    1: };
    1: 
    1: /***************************************************************************/
    1: class XPCMarkableJSVal
    1: {
    1: public:
    1:     XPCMarkableJSVal(jsval val) : mVal(val), mValPtr(&mVal) {}
    1:     XPCMarkableJSVal(jsval *pval) : mVal(0), mValPtr(pval) {}
    1:     ~XPCMarkableJSVal() {}
    1:     void Mark() {}
 1025:     void TraceJS(JSTracer* trc)
 1025:     {
 1025:         JS_CALL_VALUE_TRACER(trc, *mValPtr, "XPCMarkableJSVal");
 1025:     }
 1025:     void AutoTrace(JSTracer* trc) {}
    1: private:
    1:     XPCMarkableJSVal(); // not implemented    
    1:     jsval  mVal;
    1:     jsval* mValPtr;
    1: }; 
    1: 
    1: /***************************************************************************/
    1: // AutoMarkingPtr is the base class for the various AutoMarking pointer types 
    1: // below. This system allows us to temporarily protect instances of our garbage 
    1: // collected types after they are constructed but before they are safely 
    1: // attached to other rooted objects.
    1: // This base class has pure virtual support for marking. 
    1: 
    1: class AutoMarkingPtr
    1: {
    1: public:
    1:     AutoMarkingPtr(XPCCallContext& ccx)
    1:         : mNext(nsnull), mTLS(ccx.GetThreadData()) {Link();}
    1: 
    1:     virtual ~AutoMarkingPtr() {Unlink();}
    1:     
    1:     void Link() 
    1:         {if(!mTLS) return;
    1:          AutoMarkingPtr** list = mTLS->GetAutoRootsAdr(); 
    1:          mNext = *list; *list = this;}
    1: 
    1:     void Unlink() 
    1:         {if(!mTLS) return;
    1:          AutoMarkingPtr** cur = mTLS->GetAutoRootsAdr(); 
    1:          while(*cur != this) {
    1:             NS_ASSERTION(*cur, "This object not in list!");
    1:             cur = &(*cur)->mNext;
    1:          }
    1:          *cur = mNext;
    1:          mTLS = nsnull;
    1:         }
    1: 
    1:     AutoMarkingPtr* GetNext() {return mNext;}
    1:     
 1025:     virtual void TraceJS(JSTracer* trc) = 0;
    1:     virtual void MarkAfterJSFinalize() = 0;
    1: 
    1: protected:
    1:     AutoMarkingPtr* mNext;
    1:     XPCPerThreadData* mTLS;
    1: };
    1: 
    1: // More joy of macros...
    1: 
    1: #define DEFINE_AUTO_MARKING_PTR_TYPE(class_, type_)                          \
    1: class class_ : public AutoMarkingPtr                                         \
    1: {                                                                            \
    1: public:                                                                      \
    1:     class_ (XPCCallContext& ccx, type_ * ptr = nsnull)                       \
    1:         : AutoMarkingPtr(ccx), mPtr(ptr) {}                                  \
    1:     virtual ~ class_ () {}                                                   \
    1:                                                                              \
 1025:     virtual void TraceJS(JSTracer* trc)                                      \
    1:         {if(mPtr) {                                                          \
 1025:            mPtr->TraceJS(trc);                                               \
 1025:            mPtr->AutoTrace(trc);                                             \
    1:          }                                                                   \
 1025:          if(mNext) mNext->TraceJS(trc);}                                     \
    1:                                                                              \
    1:     virtual void MarkAfterJSFinalize()                                       \
    1:         {if(mPtr) mPtr->Mark();                                              \
    1:          if(mNext) mNext->MarkAfterJSFinalize();}                            \
    1:                                                                              \
    1:     type_ * get()        const  {return mPtr;}                               \
    1:     operator type_ *()   const  {return mPtr;}                               \
    1:     type_ * operator->() const  {return mPtr;}                               \
    1:                                                                              \
    1:     class_ & operator =(type_ * p)                                           \
    1:         {mPtr = p; return *this;}                                            \
    1:                                                                              \
    1: protected:                                                                   \
    1:     type_ * mPtr;                                                            \
    1: };
    1: 
    1: // Use the macro above to define our AutoMarking types...
    1: 
    1: DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingNativeInterfacePtr, XPCNativeInterface)
    1: DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingNativeSetPtr, XPCNativeSet)
    1: DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingWrappedNativePtr, XPCWrappedNative)
    1: DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingWrappedNativeTearOffPtr, XPCWrappedNativeTearOff)
    1: DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingWrappedNativeProtoPtr, XPCWrappedNativeProto)
    1: DEFINE_AUTO_MARKING_PTR_TYPE(AutoMarkingJSVal, XPCMarkableJSVal)
    1:                                     
    1: #define DEFINE_AUTO_MARKING_ARRAY_PTR_TYPE(class_, type_)                    \
    1: class class_ : public AutoMarkingPtr                                         \
    1: {                                                                            \
    1: public:                                                                      \
    1:     class_ (XPCCallContext& ccx)                                             \
    1:         : AutoMarkingPtr(ccx), mPtr(nsnull), mCount(0) {}                    \
    1:     class_ (XPCCallContext& ccx, type_** aPtr, PRUint32 aCount,              \
    1:             PRBool aClear = PR_FALSE)                                        \
    1:         : AutoMarkingPtr(ccx), mPtr(aPtr), mCount(aCount)                    \
    1:     {                                                                        \
    1:         if(!mPtr) mCount = 0;                                                \
    1:         else if(aClear) memset(mPtr, 0, mCount*sizeof(type_*));              \
    1:     }                                                                        \
    1:     virtual ~ class_ () {}                                                   \
    1:                                                                              \
 1025:     virtual void TraceJS(JSTracer* trc)                                      \
    1:     {                                                                        \
    1:         for(PRUint32 i = 0; i < mCount; ++i)                                 \
    1:         {                                                                    \
    1:             type_* cur = mPtr[i];                                            \
    1:             if(cur)                                                          \
    1:             {                                                                \
 1025:                 cur->TraceJS(trc);                                           \
 1025:                 cur->AutoTrace(trc);                                         \
    1:             }                                                                \
    1:         }                                                                    \
 1025:         if(mNext) mNext->TraceJS(trc);                                       \
    1:     }                                                                        \
    1:                                                                              \
    1:     virtual void MarkAfterJSFinalize()                                       \
    1:     {                                                                        \
    1:         for(PRUint32 i = 0; i < mCount; ++i)                                 \
    1:         {                                                                    \
    1:             type_* cur = mPtr[i];                                            \
    1:             if(cur)                                                          \
    1:                 cur->Mark();                                                 \
    1:         }                                                                    \
    1:         if(mNext) mNext->MarkAfterJSFinalize();                              \
    1:     }                                                                        \
    1:                                                                              \
    1:     type_ ** get()       const  {return mPtr;}                               \
    1:     operator type_ **()  const  {return mPtr;}                               \
    1:     type_ ** operator->() const  {return mPtr;}                              \
    1:                                                                              \
    1:     class_ & operator =(const class_ & inst)                                 \
    1:         {mPtr = inst.mPtr; mCount = inst.mCount; return *this;}              \
    1:                                                                              \
    1: protected:                                                                   \
    1:     type_ ** mPtr;                                                           \
    1:     PRUint32 mCount;                                                         \
    1: };
    1: 
    1: DEFINE_AUTO_MARKING_ARRAY_PTR_TYPE(AutoMarkingNativeInterfacePtrArrayPtr,
    1:                                    XPCNativeInterface)
    1:     
    1: // Note: It looked like I would need one of these AutoMarkingPtr types for
    1: // XPCNativeScriptableInfo in order to manage marking its 
    1: // XPCNativeScriptableShared member during construction. But AFAICT we build
    1: // these and bind them to rooted things so immediately that this just is not
    1: // needed.
    1: 
    1: #define AUTO_MARK_JSVAL_HELPER2(tok, line) tok##line
    1: #define AUTO_MARK_JSVAL_HELPER(tok, line) AUTO_MARK_JSVAL_HELPER2(tok, line)
    1: 
    1: #define AUTO_MARK_JSVAL(ccx, val)                                            \
    1:     XPCMarkableJSVal AUTO_MARK_JSVAL_HELPER(_val_,__LINE__)(val);            \
    1:     AutoMarkingJSVal AUTO_MARK_JSVAL_HELPER(_automarker_,__LINE__)           \
    1:     (ccx, &AUTO_MARK_JSVAL_HELPER(_val_,__LINE__))
    1: 
    1: #ifdef XPC_USE_SECURITY_CHECKED_COMPONENT
    1: /***************************************************************************/
    1: // Allocates a string that grants all access ("AllAccess")
    1: 
    1: extern char* xpc_CloneAllAccess();
    1: /***************************************************************************/
    1: // Returns access if wideName is in list
    1: 
    1: extern char * xpc_CheckAccessList(const PRUnichar* wideName, const char* list[]);
    1: #endif
    1: 
    1: /***************************************************************************/
    1: // in xpcvariant.cpp...
    1: 
    1: // {1809FD50-91E8-11d5-90F9-0010A4E73D9A}
    1: #define XPCVARIANT_IID \
    1:     {0x1809fd50, 0x91e8, 0x11d5, \
    1:       { 0x90, 0xf9, 0x0, 0x10, 0xa4, 0xe7, 0x3d, 0x9a } }
    1: 
    1: class XPCVariant : public nsIVariant
    1: {
    1: public:
    1:     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1:     NS_DECL_NSIVARIANT
    1:     NS_DECL_CYCLE_COLLECTION_CLASS(XPCVariant)
    1: 
    1:     // If this class ever implements nsIWritableVariant, take special care with
    1:     // the case when mJSVal is JSVAL_STRING, since we don't own the data in
    1:     // that case.
    1: 
    1:     // We #define and iid so that out module local code can use QI to detect 
    1:     // if a given nsIVariant is in fact an XPCVariant. 
    1:     NS_DECLARE_STATIC_IID_ACCESSOR(XPCVARIANT_IID)
    1: 
    1:     static XPCVariant* newVariant(XPCCallContext& ccx, jsval aJSVal);
    1: 
    1:     jsval GetJSVal() const {return mJSVal;}
    1: 
 2072:     XPCVariant(jsval aJSVal);
    1: 
    1:     /**
    1:      * Convert a variant into a jsval.
    1:      *
    1:      * @param ccx the context for the whole procedure
    1:      * @param variant the variant to convert
    1:      * @param scope the default scope to put on the new JSObject's __parent__
    1:      *        chain
    1:      * @param pErr [out] relevant error code, if any.
    1:      * @param pJSVal [out] the resulting jsval.
    1:      */    
    1:     static JSBool VariantDataToJS(XPCCallContext& ccx, 
    1:                                   nsIVariant* variant,
    1:                                   JSObject* scope, nsresult* pErr,
    1:                                   jsval* pJSVal);
    1: 
    1: protected:
 2072:     virtual ~XPCVariant() { }
    1: 
    1:     JSBool InitializeData(XPCCallContext& ccx);
    1: 
    1: protected:
    1:     nsDiscriminatedUnion mData;
    1:     jsval                mJSVal;
 2072: };
 2072: 
 2072: NS_DEFINE_STATIC_IID_ACCESSOR(XPCVariant, XPCVARIANT_IID)
 2072: 
 2072: class XPCTraceableVariant: public XPCVariant,
 2072:                            public XPCRootSetElem
 2072: {
 2072: public:
 2072:     XPCTraceableVariant(XPCJSRuntime *runtime, jsval aJSVal)
 2072:         : XPCVariant(aJSVal)
 2072:     {
 2072:         runtime->AddVariantRoot(this);
 2072:     }
 2072: 
 2072:     virtual ~XPCTraceableVariant();
 2072: 
 2072:     void TraceJS(JSTracer* trc);
 2072: #ifdef DEBUG
 2072:     static void PrintTraceName(JSTracer* trc, char *buf, size_t bufsize);
    1: #endif
    1: };
    1: 
    1: /***************************************************************************/
    1: #ifndef XPCONNECT_STANDALONE
    1: 
    1: #define PRINCIPALHOLDER_IID \
    1: {0xbf109f49, 0xf94a, 0x43d8, {0x93, 0xdb, 0xe4, 0x66, 0x49, 0xc5, 0xd9, 0x7d}}
    1: 
    1: class PrincipalHolder : public nsIScriptObjectPrincipal
    1: {
    1: public:
    1:     NS_DECLARE_STATIC_IID_ACCESSOR(PRINCIPALHOLDER_IID)
    1: 
    1:     PrincipalHolder(nsIPrincipal *holdee)
    1:         : mHoldee(holdee)
    1:     {
    1:     }
    1:     virtual ~PrincipalHolder() { }
    1: 
    1:     NS_DECL_ISUPPORTS
    1: 
    1:     nsIPrincipal *GetPrincipal();
    1: 
    1: private:
    1:     nsCOMPtr<nsIPrincipal> mHoldee;
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(PrincipalHolder, PRINCIPALHOLDER_IID)
    1: 
    1: #endif /* !XPCONNECT_STANDALONE */
    1: 
    1: /***************************************************************************/
    1: // Utilities
    1: 
10858: inline void *
10858: xpc_GetJSPrivate(JSObject *obj)
10858: {
10858:     jsval v;
10858: 
10858:     JS_ASSERT(STOBJ_GET_CLASS(obj)->flags & JSCLASS_HAS_PRIVATE);
10858:     v = obj->fslots[JSSLOT_PRIVATE];
10858:     if (!JSVAL_IS_INT(v))
10858:         return NULL;
10858:     return JSVAL_TO_PRIVATE(v);
10858: }
10858: 
    1: #ifndef XPCONNECT_STANDALONE
    1: 
    1: // Helper for creating a sandbox object to use for evaluating
    1: // untrusted code completely separated from all other code in the
    1: // system using xpc_EvalInSandbox(). Takes the JSContext on which to
    1: // do setup etc on, puts the sandbox object in *vp (which must be
    1: // rooted by the caller), and uses the principal that's either
    1: // directly passed in prinOrSop or indirectly as an
    1: // nsIScriptObjectPrincipal holding the principal. If no principal is
    1: // reachable through prinOrSop, a new null principal will be created
    1: // and used.
    1: nsresult
    1: xpc_CreateSandboxObject(JSContext * cx, jsval * vp, nsISupports *prinOrSop);
    1: 
    1: // Helper for evaluating scripts in a sandbox object created with
    1: // xpc_CreateSandboxObject(). The caller is responsible of ensuring
    1: // that *rval doesn't get collected during the call or usage after the
    1: // call. This helper will use filename and lineNo for error reporting,
    1: // and if no filename is provided it will use the codebase from the
 3573: // principal and line number 1 as a fallback. if returnStringOnly is
 3573: // true, then the result in *rval, or the exception in cx->exception
 3573: // will be coerced into strings. If an exception is thrown converting
 3573: // an exception to a string, evalInSandbox will return an NS_ERROR_*
 3573: // result, and cx->exception will be empty.
    1: nsresult
    1: xpc_EvalInSandbox(JSContext *cx, JSObject *sandbox, const nsAString& source,
 3573:                   const char *filename, PRInt32 lineNo,
 3573:                   PRBool returnStringOnly, jsval *rval);
    1: #endif /* !XPCONNECT_STANDALONE */
    1: 
    1: /***************************************************************************/
    1: // Inlined utilities.
    1: 
    1: inline JSBool
    1: xpc_ForcePropertyResolve(JSContext* cx, JSObject* obj, jsval idval);
    1: 
    1: inline jsval
    1: GetRTStringByIndex(JSContext *cx, uintN index);
    1: 
 7987: // Wrapper for JS_NewObject to mark the new object as system when parent is
 7987: // also a system object.
 7987: inline JSObject*
 7987: xpc_NewSystemInheritingJSObject(JSContext *cx, JSClass *clasp, JSObject *proto,
 7987:                                 JSObject *parent);
 7987: 
    1: nsISupports *
    1: XPC_GetIdentityObject(JSContext *cx, JSObject *obj);
    1: 
    1: PRBool
    1: IsXPCSafeJSObjectWrapperClass(JSClass *clazz);
    1: 
    1: JSObject *
10858: XPC_SJOW_GetUnsafeObject(JSObject *obj);
    1: 
    1: JSBool
    1: XPC_SJOW_Construct(JSContext *cx, JSObject *obj, uintN, jsval *argv,
    1:                    jsval *rval);
    1: 
    1: PRBool
    1: XPC_SJOW_AttachNewConstructorObject(XPCCallContext &ccx,
    1:                                     JSObject *aGlobalObject);
    1: 
 4042: JSBool
 4042: XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp);
 4042: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1: // IDispatch specific classes
    1: #include "XPCDispPrivate.h"
    1: #endif
    1: 
    1: /***************************************************************************/
    1: // Inlines use the above - include last.
    1: 
    1: #include "xpcinlines.h"
    1: 
    1: /***************************************************************************/
    1: // Maps have inlines that use the above - include last.
    1: 
    1: #include "xpcmaps.h"
    1: 
    1: /***************************************************************************/
    1: 
    1: #endif /* xpcprivate_h___ */
