24962: #
24962: # ***** BEGIN LICENSE BLOCK *****
24962: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
24962: #
24962: # The contents of this file are subject to the Mozilla Public License Version
24962: # 1.1 (the "License"); you may not use this file except in compliance with
24962: # the License. You may obtain a copy of the License at
24962: # http://www.mozilla.org/MPL/
24962: #
24962: # Software distributed under the License is distributed on an "AS IS" basis,
24962: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
24962: # for the specific language governing rights and limitations under the
24962: # License.
24962: #
24962: # The Original Code is mozilla.org code.
24962: #
24962: # The Initial Developer of the Original Code is
24962: # Mozilla Foundation.
24962: # Portions created by the Initial Developer are Copyright (C) 2009
24962: # the Initial Developer. All Rights Reserved.
24962: #
24962: # Contributor(s):
32268: #   Serge Gautherie <sgautherie.bz@free.fr>
24962: #   Ted Mielczarek <ted.mielczarek@gmail.com>
24962: #
24962: # Alternatively, the contents of this file may be used under the terms of
24962: # either the GNU General Public License Version 2 or later (the "GPL"), or
24962: # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
24962: # in which case the provisions of the GPL or the LGPL are applicable instead
24962: # of those above. If you wish to allow use of your version of this file only
24962: # under the terms of either the GPL or the LGPL, and not to allow others to
24962: # use your version of this file under the terms of the MPL, indicate your
24962: # decision by deleting the provisions above and replace them with the notice
24962: # and other provisions required by the GPL or the LGPL. If you do not delete
24962: # the provisions above, a recipient may use your version of this file under
24962: # the terms of any one of the MPL, the GPL or the LGPL.
24962: #
24962: # ***** END LICENSE BLOCK *****
24962: 
24962: """
24962: Runs the reftest test harness.
24962: """
24962: 
24962: import sys, shutil, os, os.path
24962: SCRIPT_DIRECTORY = os.path.abspath(os.path.realpath(os.path.dirname(sys.argv[0])))
24962: sys.path.append(SCRIPT_DIRECTORY)
39171: 
37238: from automation import Automation
34020: from automationutils import *
24962: from optparse import OptionParser
24962: from tempfile import mkdtemp
24962: 
37238: class RefTest(object):
37238: 
24962:   oldcwd = os.getcwd()
37238: 
37238:   def __init__(self, automation):
37238:     self.automation = automation
24962: 
37238:   def getFullPath(self, path):
37238:     "Get an absolute path relative to self.oldcwd."
37238:     return os.path.normpath(os.path.join(self.oldcwd, os.path.expanduser(path)))
24962: 
39171:   def getManifestPath(self, path):
39171:     "Get the path of the manifest, and for remote testing this function is subclassed to point to remote manifest"
39171:     return self.getFullPath(path)
39171: 
37238:   def createReftestProfile(self, options, profileDir):
32920:     "Sets up a profile for reftest."
24962: 
50985:     self.automation.setupPermissionsDatabase(profileDir,
51988:       {'allowXULXBL': [('localhost', True), ('<file>', True)]})
50985: 
32920:     # Set preferences.
24962:     prefsFile = open(os.path.join(profileDir, "user.js"), "w")
24962:     prefsFile.write("""user_pref("browser.dom.window.dump.enabled", true);
24962:     """)
34783:     prefsFile.write('user_pref("reftest.timeout", %d);\n' % (options.timeout * 1000))
34783:     prefsFile.write('user_pref("ui.caretBlinkTime", -1);\n')
34783: 
39987:     if options.totalChunks != None:
39987:       prefsFile.write('user_pref("reftest.totalChunks", %d);\n' % options.totalChunks)
39987:     if options.thisChunk != None:
39987:       prefsFile.write('user_pref("reftest.thisChunk", %d);\n' % options.thisChunk)
48233:     if options.logFile != None:
48233:       prefsFile.write('user_pref("reftest.logFile", "%s");\n' % options.logFile)
39987: 
34783:     for v in options.extraPrefs:
34783:       thispref = v.split("=")
34783:       if len(thispref) < 2:
34783:         print "Error: syntax error in --setpref=" + v
34783:         sys.exit(1)
34783:       part = 'user_pref("%s", %s);\n' % (thispref[0], thispref[1])
34783:       prefsFile.write(part)
34235:     # no slow script dialogs
34235:     prefsFile.write('user_pref("dom.max_script_run_time", 0);')
34235:     prefsFile.write('user_pref("dom.max_chrome_script_run_time", 0);')
32920:     prefsFile.close()
29396: 
24962:     # install the reftest extension bits into the profile
46150:     self.automation.installExtension(os.path.join(SCRIPT_DIRECTORY, "reftest"),
46150:                                                   profileDir,
46150:                                                   "reftest@mozilla.org")
46150: 
24962: 
39171:   def registerExtension(self, browserEnv, options, profileDir, extraArgs = ['-silent']):
39171:     # run once with -silent to let the extension manager do its thing
39171:     # and then exit the app
39171:     self.automation.log.info("REFTEST INFO | runreftest.py | Performing extension manager registration: start.\n")
39171:     # Don't care about this |status|: |runApp()| reporting it should be enough.
39171:     status = self.automation.runApp(None, browserEnv, options.app, profileDir,
39171:                                  extraArgs,
39171:                                  utilityPath = options.utilityPath,
39171:                                  xrePath=options.xrePath,
39171:                                  symbolsPath=options.symbolsPath)
39171:     # We don't care to call |processLeakLog()| for this step.
39171:     self.automation.log.info("\nREFTEST INFO | runreftest.py | Performing extension manager registration: end.")
39171: 
39171:     # Remove the leak detection file so it can't "leak" to the tests run.
39171:     # The file is not there if leak logging was not enabled in the application build.
39171:     if os.path.exists(self.leakLogFile):
39171:       os.remove(self.leakLogFile)
39171: 
39171:   def buildBrowserEnv(self, options, profileDir):
39171:     browserEnv = self.automation.environment(xrePath = options.xrePath)
39171:     browserEnv["XPCOM_DEBUG_BREAK"] = "stack"
39171: 
39171:     # Enable leaks detection to its own log file.
39171:     self.leakLogFile = os.path.join(profileDir, "runreftest_leaks.log")
39171:     browserEnv["XPCOM_MEM_BLOAT_LOG"] = self.leakLogFile
39171:     return browserEnv
39171: 
39171:   def cleanup(self, profileDir):
39171:     if profileDir:
39171:       shutil.rmtree(profileDir)
39171: 
37238:   def runTests(self, manifest, options):
37238:     debuggerInfo = getDebuggerInfo(self.oldcwd, options.debugger, options.debuggerArgs,
37238:         options.debuggerInteractive);
37238: 
37238:     profileDir = None
37238:     try:
37238:       profileDir = mkdtemp()
37238:       self.createReftestProfile(options, profileDir)
37238:       self.copyExtraFilesToProfile(options, profileDir)
38937: 
38937:       # browser environment
39171:       browserEnv = self.buildBrowserEnv(options, profileDir)
38937: 
39171:       self.registerExtension(browserEnv, options, profileDir)
37238: 
37238:       # then again to actually run reftest
37238:       self.automation.log.info("REFTEST INFO | runreftest.py | Running tests: start.\n")
39171:       reftestlist = self.getManifestPath(manifest)
37238:       status = self.automation.runApp(None, browserEnv, options.app, profileDir,
37238:                                  ["-reftest", reftestlist],
37238:                                  utilityPath = options.utilityPath,
37238:                                  xrePath=options.xrePath,
37238:                                  debuggerInfo=debuggerInfo,
37238:                                  symbolsPath=options.symbolsPath,
37238:                                  # give the JS harness 30 seconds to deal
37238:                                  # with its own timeouts
37238:                                  timeout=options.timeout + 30.0)
39171:       processLeakLog(self.leakLogFile, options.leakThreshold)
37238:       self.automation.log.info("\nREFTEST INFO | runreftest.py | Running tests: end.")
37238:     finally:
39171:       self.cleanup(profileDir)
37238:     return status
37238: 
37238:   def copyExtraFilesToProfile(self, options, profileDir):
37238:     "Copy extra files or dirs specified on the command line to the testing profile."
37238:     for f in options.extraProfileFiles:
37238:       abspath = self.getFullPath(f)
37238:       dest = os.path.join(profileDir, os.path.basename(abspath))
37238:       if os.path.isdir(abspath):
37238:         shutil.copytree(abspath, dest)
37238:       else:
37238:         shutil.copy(abspath, dest)
37238: 
38937: 
39171: class ReftestOptions(OptionParser):
39171: 
39171:   def __init__(self, automation):
46150:     self._automation = automation
39171:     OptionParser.__init__(self)
39171:     defaults = {}
28231: 
28231:     # we want to pass down everything from automation.__all__
39171:     addCommonOptions(self, 
46150:                      defaults=dict(zip(self._automation.__all__, 
46150:                             [getattr(self._automation, x) for x in self._automation.__all__])))
46150:     self._automation.addCommonOptions(self)
39171:     self.add_option("--appname",
24962:                     action = "store", type = "string", dest = "app",
24962:                     default = os.path.join(SCRIPT_DIRECTORY, automation.DEFAULT_APP),
24962:                     help = "absolute path to application, overriding default")
39171:     self.add_option("--extra-profile-file",
24962:                     action = "append", dest = "extraProfileFiles",
24962:                     default = [],
24962:                     help = "copy specified files/dirs to testing profile")
39171:     self.add_option("--timeout",              
29396:                     action = "store", dest = "timeout", type = "int", 
33957:                     default = 5 * 60, # 5 minutes per bug 479518
33957:                     help = "reftest will timeout in specified number of seconds. [default %default s].")
39171:     self.add_option("--leak-threshold",
26932:                     action = "store", type = "int", dest = "leakThreshold",
26932:                     default = 0,
26932:                     help = "fail if the number of bytes leaked through "
26932:                            "refcounted objects (or bytes in classes with "
26932:                            "MOZ_COUNT_CTOR and MOZ_COUNT_DTOR) is greater "
26932:                            "than the given number")
39171:     self.add_option("--utility-path",
33291:                     action = "store", type = "string", dest = "utilityPath",
46150:                     default = self._automation.DIST_BIN,
33291:                     help = "absolute path to directory containing utility "
33291:                            "programs (xpcshell, ssltunnel, certutil)")
46150:     defaults["utilityPath"] = self._automation.DIST_BIN
39171: 
39987:     self.add_option("--total-chunks",
39987:                     type = "int", dest = "totalChunks",
39987:                     help = "how many chunks to split the tests up into")
39987:     defaults["totalChunks"] = None
39987: 
39987:     self.add_option("--this-chunk",
39987:                     type = "int", dest = "thisChunk",
39987:                     help = "which chunk to run between 1 and --total-chunks")
39987:     defaults["thisChunk"] = None
39987: 
48233:     self.add_option("--log-file",
48233:                     action = "store", type = "string", dest = "logFile",
48233:                     default = None,
48233:                     help = "file to log output to in addition to stdout")
48233:     defaults["logFile"] = None
48233:  
48630:     self.add_option("--skip-slow-tests",
48630:                     dest = "skipSlowTests", action = "store_true",
48630:                     help = "skip tests marked as slow when running")
48630:     defaults["skipSlowTests"] = False
48630: 
39171:     self.set_defaults(**defaults)
39171: 
39171: def main():
39171:   automation = Automation()
39171:   parser = ReftestOptions(automation)
39171:   reftest = RefTest(automation)
26932: 
24962:   options, args = parser.parse_args()
24962:   if len(args) != 1:
24962:     print >>sys.stderr, "No reftest.list specified."
24962:     sys.exit(1)
24962: 
37238:   options.app = reftest.getFullPath(options.app)
24962:   if not os.path.exists(options.app):
24962:     print """Error: Path %(app)s doesn't exist.
24962: Are you executing $objdir/_tests/reftest/runreftest.py?""" \
24962:             % {"app": options.app}
24962:     sys.exit(1)
24962: 
26448:   if options.xrePath is None:
26448:     options.xrePath = os.path.dirname(options.app)
26448:   else:
26448:     # allow relative paths
37238:     options.xrePath = reftest.getFullPath(options.xrePath)
26448: 
41990:   if options.symbolsPath and not isURL(options.symbolsPath):
37238:     options.symbolsPath = reftest.getFullPath(options.symbolsPath)
37238:   options.utilityPath = reftest.getFullPath(options.utilityPath)
33395: 
39987:   if options.totalChunks is not None and options.thisChunk is None:
39987:     print "thisChunk must be specified when totalChunks is specified"
39987:     sys.exit(1)
39987: 
39987:   if options.totalChunks:
39987:     if not 1 <= options.thisChunk <= options.totalChunks:
39987:       print "thisChunk must be between 1 and totalChunks"
39987:       sys.exit(1)
39987:   
48233:   if options.logFile:
48233:     options.logFile = reftest.getFullPath(options.logFile)
48233: 
37238:   sys.exit(reftest.runTests(args[0], options))
24962:   
24962: if __name__ == "__main__":
24962:   main()
