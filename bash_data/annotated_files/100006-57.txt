 78065: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 78065:  * vim: set ts=8 sw=4 et tw=78:
 78065:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 78065: 
 86483: #ifndef ScopeObject_h___
 86483: #define ScopeObject_h___
 86483: 
 98180: #include "jscntxt.h"
 86483: #include "jsobj.h"
 98921: #include "jsweakmap.h"
 78065: 
 78065: namespace js {
 78065: 
 98921: /*****************************************************************************/
 98921: 
 86483: /*
 95101:  * A "scope coordinate" describes how to get from head of the scope chain to a
 95101:  * given lexically-enclosing variable. A scope coordinate has two dimensions:
 95101:  *  - hops: the number of scope objects on the scope chain to skip
 95101:  *  - binding: which binding on the scope object
100006:  *
100006:  * XXX: Until bug 659577 lands, this is all for show and all ScopeCoordinates
100006:  * have hops fixed at 0 and 'binding' is just the js::Bindings binding for args
100006:  * and vars and the stack depth for let bindings. Thus, aliased-var access
100006:  * touches the StackFrame like it always did and 'binding' must be first
100006:  * converted to either an arg or local slot (using Bindings::bindingToLocal or
100006:  * bindingToArg). With bug 659577, ScopeObject will have a 'var' function that
100006:  * takes a ScopeCoordinate.
 95101:  */
 95101: struct ScopeCoordinate
 95101: {
 95101:     uint16_t hops;
100006:     uint16_t binding;
 95101:     inline ScopeCoordinate(jsbytecode *pc);
 95101: };
 95101: 
100006: inline JSAtom *
100006: ScopeCoordinateAtom(JSScript *script, jsbytecode *pc);
 95101: 
 98921: /*****************************************************************************/
 98921: 
 95101: /*
 86483:  * Scope objects
 86483:  *
 86483:  * Scope objects are technically real JSObjects but only belong on the scope
 86483:  * chain (that is, fp->scopeChain() or fun->environment()). The hierarchy of
 86483:  * scope objects is:
 86483:  *
 86483:  *   JSObject                   Generic object
 86483:  *     \
 86483:  *   ScopeObject                Engine-internal scope
 86483:  *     \   \   \
 86483:  *      \   \  DeclEnvObject    Holds name of recursive/heavyweight named lambda
 86483:  *       \   \
 86483:  *        \  CallObject         Scope of entire function or strict eval
 86483:  *         \
 86483:  *   NestedScopeObject          Scope created for a statement
 86483:  *     \   \
 86483:  *      \  WithObject           with
 86483:  *       \
 86483:  *   BlockObject                Shared interface of cloned/static block objects
 86483:  *     \   \
 86483:  *      \  ClonedBlockObject    let, switch, catch, for
 86483:  *       \
 86483:  *       StaticBlockObject      See NB
 86483:  *
 86483:  * This hierarchy represents more than just the interface hierarchy: reserved
 86483:  * slots in base classes are fixed for all derived classes. Thus, for example,
 86483:  * ScopeObject::enclosingScope() can simply access a fixed slot without further
 86483:  * dynamic type information.
 86483:  *
 86483:  * NB: Static block objects are a special case: these objects are created at
 86483:  * compile time to hold the shape/binding information from which block objects
 86483:  * are cloned at runtime. These objects should never escape into the wild and
 86483:  * support a restricted set of ScopeObject operations.
 98921:  *
 98921:  * See also "Debug scope objects" below.
 86483:  */
 86483: 
 86483: class ScopeObject : public JSObject
 78065: {
100006:     /* Use maybeStackFrame() instead. */
100006:     void *getPrivate() const;
100006: 
 86483:   protected:
 86483:     static const uint32_t SCOPE_CHAIN_SLOT = 0;
 86483: 
 86483:   public:
 78065:     /*
 86483:      * Since every scope chain terminates with a global object and GlobalObject
 86483:      * does not derive ScopeObject (it has a completely different layout), the
 86483:      * enclosing scope of a ScopeObject is necessarily non-null.
 78065:      */
 86483:     inline JSObject &enclosingScope() const;
 95355:     inline bool setEnclosingScope(JSContext *cx, HandleObject obj);
 86483: 
 86483:     /*
100006:      * The stack frame for this scope object, if the frame is still active.
100006:      * Note: these members may not be called for a StaticBlockObject or
100006:      * WithObject.
 99992:      */
100006:     inline StackFrame *maybeStackFrame() const;
100006:     inline void setStackFrame(StackFrame *frame);
 99992: 
 86483:     /* For jit access. */
 86483:     static inline size_t offsetOfEnclosingScope();
 86483: };
 86483: 
 86483: class CallObject : public ScopeObject
 86483: {
 84755:     static const uint32_t CALLEE_SLOT = 1;
 78065: 
 91175:     static CallObject *
100006:     create(JSContext *cx, JSScript *script, HandleObject enclosing, HandleObject callee);
 91175: 
 78065:   public:
100006:     static const uint32_t RESERVED_SLOTS = 3;
 83316: 
 91175:     static CallObject *createForFunction(JSContext *cx, StackFrame *fp);
 91175:     static CallObject *createForStrictEval(JSContext *cx, StackFrame *fp);
 78065: 
 78065:     /* True if this is for a strict mode eval frame or for a function call. */
 78065:     inline bool isForEval() const;
 78065: 
 78065:     /*
 78065:      * The callee function if this CallObject was created for a function
 78065:      * invocation, or null if it was created for a strict mode eval frame.
 78065:      */
 78065:     inline JSObject *getCallee() const;
 78065:     inline JSFunction *getCalleeFunction() const;
 78065:     inline void setCallee(JSObject *callee);
 78065: 
 78065:     /* Returns the formal argument at the given index. */
100006:     inline const Value &arg(unsigned i) const;
100006:     inline void setArg(unsigned i, const Value &v);
100006:     inline void initArgUnchecked(unsigned i, const Value &v);
 78065: 
 78065:     /* Returns the variable at the given index. */
100006:     inline const Value &var(unsigned i) const;
100006:     inline void setVar(unsigned i, const Value &v);
100006:     inline void initVarUnchecked(unsigned i, const Value &v);
 78065: 
 78065:     /*
 78065:      * Get the actual arrays of arguments and variables. Only call if type
 78065:      * inference is enabled, where we ensure that call object variables are in
 78065:      * contiguous slots (see NewCallObject).
 78065:      */
 91175:     inline HeapSlotArray argArray();
 91175:     inline HeapSlotArray varArray();
 78065: 
100006:     inline void copyValues(unsigned nargs, Value *argv, unsigned nvars, Value *slots);
100006: 
100006:     static JSBool getArgOp(JSContext *cx, HandleObject obj, HandleId id, Value *vp);
100006:     static JSBool getVarOp(JSContext *cx, HandleObject obj, HandleId id, Value *vp);
 98960:     static JSBool setArgOp(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp);
 98960:     static JSBool setVarOp(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp);
 93245: 
100006:     /* Return whether this environment contains 'name' and, if so, its value. */
100006:     bool containsVarOrArg(PropertyName *name, Value *vp, JSContext *cx);
 78065: };
 78065: 
 86483: class DeclEnvObject : public ScopeObject
 86483: {
 86483:   public:
 86483:     static const uint32_t RESERVED_SLOTS = 1;
 86483:     static const gc::AllocKind FINALIZE_KIND = gc::FINALIZE_OBJECT2;
 78065: 
 86483:     static DeclEnvObject *create(JSContext *cx, StackFrame *fp);
 86483: 
 86483: };
 86483: 
 86483: class NestedScopeObject : public ScopeObject
 78065: {
 86483:   protected:
 86483:     static const unsigned DEPTH_SLOT = 1;
 78065: 
 86483:   public:
 86483:     /* Return the abstract stack depth right before entering this nested scope. */
 86483:     uint32_t stackDepth() const;
 86483: };
 86483: 
 86483: class WithObject : public NestedScopeObject
 86483: {
100006:     /* These ScopeObject operations are not valid on a with object. */
100006:     js::StackFrame *maybeStackFrame() const;
100006:     void setStackFrame(StackFrame *frame);
100006: 
 86483:     static const unsigned THIS_SLOT = 2;
 86483: 
 86483:     /* Use WithObject::object() instead. */
 86483:     JSObject *getProto() const;
 86483: 
 86483:   public:
 86483:     static const unsigned RESERVED_SLOTS = 3;
100006:     static const gc::AllocKind FINALIZE_KIND = gc::FINALIZE_OBJECT4;
 86483: 
 86483:     static WithObject *
 98921:     create(JSContext *cx, HandleObject proto, HandleObject enclosing, uint32_t depth);
 86483: 
 86483:     /* Return object for the 'this' class hook. */
 86483:     JSObject &withThis() const;
 86483: 
 86483:     /* Return the 'o' in 'with (o)'. */
 86483:     JSObject &object() const;
 86483: };
 86483: 
 86483: class BlockObject : public NestedScopeObject
 86483: {
 86483:   public:
100006:     static const unsigned RESERVED_SLOTS = 2;
100006:     static const gc::AllocKind FINALIZE_KIND = gc::FINALIZE_OBJECT4;
 86483: 
 86483:     /* Return the number of variables associated with this block. */
 86483:     inline uint32_t slotCount() const;
 86483: 
 86483:   protected:
 86483:     /* Blocks contain an object slot for each slot i: 0 <= i < slotCount. */
100006:     inline HeapSlot &slotValue(unsigned i);
 86483: };
 86483: 
 86483: class StaticBlockObject : public BlockObject
 86483: {
100006:     /* These ScopeObject operations are not valid on a static block object. */
100006:     StackFrame *maybeStackFrame() const;
100006:     void setStackFrame(StackFrame *frame);
100006: 
 86483:   public:
 86483:     static StaticBlockObject *create(JSContext *cx);
 86483: 
 86483:     inline StaticBlockObject *enclosingBlock() const;
 86483:     inline void setEnclosingBlock(StaticBlockObject *blockObj);
 86483: 
 86483:     void setStackDepth(uint32_t depth);
 95101:     bool containsVarAtDepth(uint32_t depth);
 86483: 
 86483:     /*
 86483:      * Frontend compilation temporarily uses the object's slots to link
 86483:      * a let var to its associated Definition parse node.
 86483:      */
 86483:     void setDefinitionParseNode(unsigned i, Definition *def);
 86483:     Definition *maybeDefinitionParseNode(unsigned i);
 95099: 
 95099:     /*
 95099:      * A let binding is aliased is accessed lexically by nested functions or
 95099:      * dynamically through dynamic name lookup (eval, with, function::, etc).
 95099:      */
 95099:     void setAliased(unsigned i, bool aliased);
 95099:     bool isAliased(unsigned i);
 86483: 
 98921:     /*
 98921:      * A static block object is cloned (when entering the block) iff some
 98921:      * variable of the block isAliased.
 98921:      */
100006:     bool needsClone() const;
 98921: 
 91237:     const Shape *addVar(JSContext *cx, jsid id, int index, bool *redeclared);
 86483: };
 86483: 
 86483: class ClonedBlockObject : public BlockObject
 86483: {
 86483:   public:
 98921:     static ClonedBlockObject *create(JSContext *cx, Handle<StaticBlockObject *> block,
 98921:                                      StackFrame *fp);
 86483: 
 86483:     /* The static block from which this block was cloned. */
 86483:     StaticBlockObject &staticBlock() const;
 86483: 
100006:     /*
100006:      * When this block's stack slots are about to be popped, 'put' must be
100006:      * called to copy the slot values into this block's object slots.
100006:      */
100006:     void put(StackFrame *fp);
100006: 
 86483:     /* Assuming 'put' has been called, return the value of the ith let var. */
100006:     const Value &closedSlot(unsigned i);
 99991: 
100006:     /* Return whether this environment contains 'name' and, if so, its value. */
100006:     bool containsVar(PropertyName *name, Value *vp, JSContext *cx);
 86483: };
 86483: 
 94006: template<XDRMode mode>
 94006: bool
 94006: XDRStaticBlockObject(XDRState<mode> *xdr, JSScript *script, StaticBlockObject **objp);
 90546: 
 97298: extern JSObject *
 97298: CloneStaticBlockObject(JSContext *cx, StaticBlockObject &srcBlock,
 97298:                        const AutoObjectVector &objects, JSScript *src);
 97298: 
 98921: /*****************************************************************************/
 98921: 
 98921: /*
 98921:  * A scope iterator describes the active scopes enclosing the current point of
 98921:  * execution for a single frame, proceeding from inner to outer. Here, "frame"
 98921:  * means a single activation of: a function, eval, or global code. By design,
 98921:  * ScopeIter exposes *all* scopes, even those that have been optimized away
 98921:  * (i.e., no ScopeObject was created when entering the scope and thus there is
 98921:  * no ScopeObject on fp->scopeChain representing the scope).
 98921:  *
 98921:  * Note: ScopeIter iterates over all scopes *within* a frame which means that
 98921:  * all scopes are ScopeObjects. In particular, the GlobalObject enclosing
 98921:  * global code (and any random objects passed as scopes to Execute) will not
 98921:  * be included.
 98921:  */
 98921: class ScopeIter
 98921: {
 98921:   public:
 98921:     enum Type { Call, Block, With, StrictEvalScope };
 98921: 
 98921:   private:
 98921:     StackFrame *fp_;
 98921:     JSObject *cur_;
 98921:     StaticBlockObject *block_;
 98921:     Type type_;
 98921:     bool hasScopeObject_;
 98921: 
 98921:     void settle();
 98921: 
 98921:   public:
 98921:     /* The default constructor leaves ScopeIter totally invalid */
 98921:     explicit ScopeIter();
 98921: 
 98921:     /* Constructing from StackFrame places ScopeIter on the innermost scope. */
 98921:     explicit ScopeIter(StackFrame *fp);
 98921: 
 98921:     /*
 98921:      * Without a StackFrame, the resulting ScopeIter is done() with
 98921:      * enclosingScope() as given.
 98921:      */
 98921:     explicit ScopeIter(JSObject &enclosingScope);
 98921: 
 98921:     /*
 98921:      * For the special case of generators, copy the given ScopeIter, with 'fp'
 98921:      * as the StackFrame instead of si.fp(). Not for general use.
 98921:      */
 98921:     ScopeIter(ScopeIter si, StackFrame *fp);
 98921: 
 98921:     /* Like ScopeIter(StackFrame *) except start at 'scope'. */
 98921:     ScopeIter(StackFrame *fp, ScopeObject &scope);
 98921: 
 98921:     bool done() const { return !fp_; }
 98921: 
 98921:     /* If done(): */
 98921: 
 98921:     JSObject &enclosingScope() const { JS_ASSERT(done()); return *cur_; }
 98921: 
 98921:     /* If !done(): */
 98921: 
 98921:     ScopeIter enclosing() const;
 98921: 
 98921:     StackFrame *fp() const { JS_ASSERT(!done()); return fp_; }
 98921:     Type type() const { JS_ASSERT(!done()); return type_; }
 98921:     bool hasScopeObject() const { JS_ASSERT(!done()); return hasScopeObject_; }
 98921:     ScopeObject &scope() const;
 98921: 
 98921:     StaticBlockObject &staticBlock() const { JS_ASSERT(type() == Block); return *block_; }
 98921: 
 98921:     /* For use as hash policy */
 98921:     typedef ScopeIter Lookup;
 98921:     static HashNumber hash(ScopeIter si);
 98921:     static bool match(ScopeIter si1, ScopeIter si2);
 98921: };
 98921: 
 98921: /*****************************************************************************/
 98921: 
 98921: /*
 98921:  * Debug scope objects
 98921:  *
 98921:  * The debugger effectively turns every opcode into a potential direct eval.
 98921:  * Naively, this would require creating a ScopeObject for every call/block
 98921:  * scope and using JSOP_GETALIASEDVAR for every access. To optimize this, the
 98921:  * engine assumes there is no debugger and optimizes scope access and creation
 98921:  * accordingly. When the debugger wants to perform an unexpected eval-in-frame
 98921:  * (or other, similar dynamic-scope-requiring operations), fp->scopeChain is
 98921:  * now incomplete: it may not contain all, or any, of the ScopeObjects to
 98921:  * represent the current scope.
 98921:  *
 98921:  * To resolve this, the debugger first calls GetDebugScopeFor(Function|Frame)
 98921:  * to synthesize a "debug scope chain". A debug scope chain is just a chain of
 98921:  * objects that fill in missing scopes and protect the engine from unexpected
 98921:  * access. (The latter means that some debugger operations, like adding a new
 98921:  * binding to a lexical scope, can fail when a true eval would succeed.) To do
 98921:  * both of these things, GetDebugScopeFor* creates a new proxy DebugScopeObject
 98921:  * to sit in front of every existing ScopeObject.
 98921:  *
 98921:  * GetDebugScopeFor* ensures the invariant that the same DebugScopeObject is
 98921:  * always produced for the same underlying scope (optimized or not!). This is
 98921:  * maintained by some bookkeeping information stored in DebugScopes.
 98921:  */
 98921: 
 98921: extern JSObject *
 98921: GetDebugScopeForFunction(JSContext *cx, JSFunction *fun);
 98921: 
 98921: extern JSObject *
 98921: GetDebugScopeForFrame(JSContext *cx, StackFrame *fp);
 98921: 
 98921: /* Provides debugger access to a scope. */
 98921: class DebugScopeObject : public JSObject
 98921: {
 98921:     static const unsigned ENCLOSING_EXTRA = 0;
 98921: 
 98921:   public:
 98921:     static DebugScopeObject *create(JSContext *cx, ScopeObject &scope, JSObject &enclosing);
 98921: 
 98921:     ScopeObject &scope() const;
 98921:     JSObject &enclosingScope() const;
 98921: 
 98921:     /* Currently, the 'declarative' scopes are Call and Block. */
 98921:     bool isForDeclarative() const;
 98921: };
 98921: 
 98921: /* Maintains runtime-wide debug scope bookkeeping information. */
 98921: class DebugScopes
 98921: {
 98921:     /* The map from (non-debug) scopes to debug scopes. */
 98921:     typedef WeakMap<HeapPtrObject, HeapPtrObject> ObjectWeakMap;
 98921:     ObjectWeakMap proxiedScopes;
 98921: 
 98921:     /*
 98921:      * The map from live frames which have optimized-away scopes to the
 98921:      * corresponding debug scopes.
 98921:      */
100006:     typedef HashMap<ScopeIter, DebugScopeObject *, ScopeIter, RuntimeAllocPolicy> MissingScopeMap;
 98921:     MissingScopeMap missingScopes;
 98921: 
 98921:   public:
 98921:     DebugScopes(JSRuntime *rt);
 98921:     ~DebugScopes();
 98921:     bool init();
 98921: 
 98921:     void mark(JSTracer *trc);
100006:     void sweep();
 98921: 
 98921:     DebugScopeObject *hasDebugScope(JSContext *cx, ScopeObject &scope) const;
 98921:     bool addDebugScope(JSContext *cx, ScopeObject &scope, DebugScopeObject &debugScope);
 98921: 
 98921:     DebugScopeObject *hasDebugScope(JSContext *cx, ScopeIter si) const;
 98921:     bool addDebugScope(JSContext *cx, ScopeIter si, DebugScopeObject &debugScope);
 98921: 
 98921:     /*
 98921:      * In debug-mode, these must be called whenever exiting a call/block or
 98921:      * when activating/yielding a generator.
 98921:      */
 98921:     void onPopCall(StackFrame *fp);
 98921:     void onPopBlock(JSContext *cx, StackFrame *fp);
 98921:     void onGeneratorFrameChange(StackFrame *from, StackFrame *to);
 98921:     void onCompartmentLeaveDebugMode(JSCompartment *c);
 98921: };
 98921: 
 86483: }  /* namespace js */
 86483: #endif /* ScopeObject_h___ */
