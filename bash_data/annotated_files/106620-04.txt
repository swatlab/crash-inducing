     1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef GFX_PLATFORM_H
     1: #define GFX_PLATFORM_H
     1: 
     1: #include "prtypes.h"
 61084: #include "prlog.h"
 23904: #include "nsTArray.h"
 82830: #include "nsStringGlue.h"
 19003: #include "nsIObserver.h"
 19003: 
     1: #include "gfxTypes.h"
     1: #include "gfxASurface.h"
 19127: #include "gfxColor.h"
     1: 
 27035: #include "qcms.h"
 77158: 
 77158: #include "gfx2DGlue.h"
 77158: #include "mozilla/RefPtr.h"
 82419: #include "GfxInfoCollector.h"
 77158: 
  4240: #ifdef XP_OS2
  4240: #undef OS2EMX_PLAIN_CHAR
  4240: #endif
  4240: 
     1: class gfxImageSurface;
 16418: class gfxFont;
   270: class gfxFontGroup;
   367: struct gfxFontStyle;
 19962: class gfxUserFontSet;
 19962: class gfxFontEntry;
 22397: class gfxProxyFontEntry;
 31590: class gfxPlatformFontList;
 37211: class gfxTextRun;
 19962: class nsIURI;
 38493: class nsIAtom;
     1: 
 72424: extern cairo_user_data_key_t kDrawTarget;
 72424: 
 11086: // pref lang id's for font prefs
 11086: // !!! needs to match the list of pref font.default.xx entries listed in all.js !!!
 39063: // !!! don't use as bit mask, this may grow larger !!!
 11086: 
 11086: enum eFontPrefLang {
 11086:     eFontPrefLang_Western     =  0,
 11086:     eFontPrefLang_CentEuro    =  1,
 11086:     eFontPrefLang_Japanese    =  2,
 11086:     eFontPrefLang_ChineseTW   =  3,
 11086:     eFontPrefLang_ChineseCN   =  4,
 11086:     eFontPrefLang_ChineseHK   =  5,
 11086:     eFontPrefLang_Korean      =  6,
 11086:     eFontPrefLang_Cyrillic    =  7,
 11086:     eFontPrefLang_Baltic      =  8,
 11086:     eFontPrefLang_Greek       =  9,
 11086:     eFontPrefLang_Turkish     = 10,
 11086:     eFontPrefLang_Thai        = 11,
 11086:     eFontPrefLang_Hebrew      = 12,
 11086:     eFontPrefLang_Arabic      = 13,
 11086:     eFontPrefLang_Devanagari  = 14,
 11086:     eFontPrefLang_Tamil       = 15,
 11086:     eFontPrefLang_Armenian    = 16,
 11086:     eFontPrefLang_Bengali     = 17,
 11086:     eFontPrefLang_Canadian    = 18,
 11086:     eFontPrefLang_Ethiopic    = 19,
 11086:     eFontPrefLang_Georgian    = 20,
 11086:     eFontPrefLang_Gujarati    = 21,
 11086:     eFontPrefLang_Gurmukhi    = 22,
 11086:     eFontPrefLang_Khmer       = 23,
 11086:     eFontPrefLang_Malayalam   = 24,
 13885:     eFontPrefLang_Oriya       = 25,
 13885:     eFontPrefLang_Telugu      = 26,
 13885:     eFontPrefLang_Kannada     = 27,
 13885:     eFontPrefLang_Sinhala     = 28,
 38930:     eFontPrefLang_Tibetan     = 29,
 11086: 
 38930:     eFontPrefLang_LangCount   = 30, // except Others and UserDefined.
 11086: 
 38930:     eFontPrefLang_Others      = 30, // x-unicode
 38930:     eFontPrefLang_UserDefined = 31,
 11086: 
 38930:     eFontPrefLang_CJKSet      = 32, // special code for CJK set
 38930:     eFontPrefLang_AllCount    = 33
 11086: };
 11086: 
 16571: enum eCMSMode {
 16571:     eCMSMode_Off          = 0,     // No color management
 16571:     eCMSMode_All          = 1,     // Color manage everything
 16571:     eCMSMode_TaggedOnly   = 2,     // Color manage tagged Images Only
 16571:     eCMSMode_AllCount     = 3
 16571: };
 16571: 
 61084: enum eGfxLog {
 61084:     // all font enumerations, localized names, fullname/psnames, cmap loads
 61084:     eGfxLog_fontlist         = 0,
 61084:     // timing info on font initialization
 61084:     eGfxLog_fontinit         = 1,
 61084:     // dump text runs, font matching, system fallback for content
 61084:     eGfxLog_textrun          = 2,
 61084:     // dump text runs, font matching, system fallback for chrome
 91869:     eGfxLog_textrunui        = 3,
 91869:     // dump cmap coverage data as they are loaded
 91869:     eGfxLog_cmapdata         = 4
 61084: };
 61084: 
 11086: // when searching through pref langs, max number of pref langs
 13885: const PRUint32 kMaxLenPrefLangList = 32;
 11086: 
 42854: #define UNINITIALIZED_VALUE  (-1)
 42854: 
 59199: typedef gfxASurface::gfxImageFormat gfxImageFormat;
 59199: 
 82419: inline const char*
 82419: GetBackendName(mozilla::gfx::BackendType aBackend)
 82419: {
 82419:   switch (aBackend) {
 82419:       case mozilla::gfx::BACKEND_DIRECT2D:
 82419:         return "direct2d";
 82419:       case mozilla::gfx::BACKEND_COREGRAPHICS:
 82419:         return "quartz";
 82419:       case mozilla::gfx::BACKEND_CAIRO:
 82419:         return "cairo";
 82419:       case mozilla::gfx::BACKEND_SKIA:
 82419:         return "skia";
 88510:       case mozilla::gfx::BACKEND_NONE:
 88510:         return "none";
 82419:   }
106619:   MOZ_NOT_REACHED("Incomplete switch");
 82419: }
 82419: 
     1: class THEBES_API gfxPlatform {
     1: public:
     1:     /**
     1:      * Return a pointer to the current active platform.
     1:      * This is a singleton; it contains mostly convenience
     1:      * functions to obtain platform-specific objects.
     1:      */
     1:     static gfxPlatform *GetPlatform();
     1: 
   218: 
   218:     /**
 68853:      * Shut down Thebes.
 68853:      * Init() arranges for this to be called at an appropriate time.
     1:      */
     1:     static void Shutdown();
     1: 
     1:     /**
     1:      * Create an offscreen surface of the given dimensions
  8368:      * and image format.
     1:      */
     1:     virtual already_AddRefed<gfxASurface> CreateOffscreenSurface(const gfxIntSize& size,
 54253:                                                                  gfxASurface::gfxContentType contentType) = 0;
     1: 
102921:     /**
102921:      * Create an offscreen surface of the given dimensions and image format which
102921:      * can be converted to a gfxImageSurface without copying. If we can provide
102921:      * a platform-hosted surface, then we will return that instead of an actual
102921:      * gfxImageSurface.
102921:      * Sub-classes should override this method if CreateOffscreenSurface returns a
102921:      * surface which implements GetAsImageSurface
102921:      */
102921:     virtual already_AddRefed<gfxASurface>
102921:       CreateOffscreenImageSurface(const gfxIntSize& aSize,
102921:                                   gfxASurface::gfxContentType aContentType);
     1: 
  8368:     virtual already_AddRefed<gfxASurface> OptimizeImage(gfxImageSurface *aSurface,
  8368:                                                         gfxASurface::gfxImageFormat format);
     1: 
 72424:     virtual mozilla::RefPtr<mozilla::gfx::DrawTarget>
106600:       CreateDrawTargetForSurface(gfxASurface *aSurface, const mozilla::gfx::IntSize& aSize);
 72424: 
 99077:     /*
106620:      * Creates a SourceSurface for a gfxASurface. This function does no caching,
106620:      * so the caller should cache the gfxASurface if it will be used frequently.
106620:      * The returned surface keeps a reference to aTarget, so it is OK to keep the
106620:      * surface, even if aTarget changes.
106620:      * aTarget should not keep a reference to the returned surface because that
106620:      * will cause a cycle.
 99077:      */
 72424:     virtual mozilla::RefPtr<mozilla::gfx::SourceSurface>
 72424:       GetSourceSurfaceForSurface(mozilla::gfx::DrawTarget *aTarget, gfxASurface *aSurface);
 72424: 
 72424:     virtual mozilla::RefPtr<mozilla::gfx::ScaledFont>
106598:       GetScaledFontForFont(mozilla::gfx::DrawTarget* aTarget, gfxFont *aFont);
 72424: 
 72424:     virtual already_AddRefed<gfxASurface>
 72424:       GetThebesSurfaceForDrawTarget(mozilla::gfx::DrawTarget *aTarget);
 72424: 
 81280:     virtual mozilla::RefPtr<mozilla::gfx::DrawTarget>
 81280:       CreateOffscreenDrawTarget(const mozilla::gfx::IntSize& aSize, mozilla::gfx::SurfaceFormat aFormat);
 81280: 
 94602:     virtual mozilla::RefPtr<mozilla::gfx::DrawTarget>
 94602:       CreateDrawTargetForData(unsigned char* aData, const mozilla::gfx::IntSize& aSize, 
 94602:                               int32_t aStride, mozilla::gfx::SurfaceFormat aFormat);
 94602: 
106616:     // aBackend will be set to the preferred backend for Azure canvas
106619:     bool SupportsAzureCanvas(mozilla::gfx::BackendType& aBackend);
 82417: 
106616:     // aObj will contain the preferred backend for Azure canvas
106619:     void GetAzureCanvasBackendInfo(mozilla::widget::InfoObject &aObj) {
106619:       aObj.DefineProperty("AzureBackend", GetBackendName(mPreferredCanvasBackend));
 82419:     }
 82419: 
     1:     /*
     1:      * Font bits
     1:      */
     1: 
 37211:     virtual void SetupClusterBoundaries(gfxTextRun *aTextRun, const PRUnichar *aString);
 37211: 
     1:     /**
     1:      * Fill aListOfFonts with the results of querying the list of font names
     1:      * that correspond to the given language group or generic font family
     1:      * (or both, or neither).
     1:      */
 38493:     virtual nsresult GetFontList(nsIAtom *aLangGroup,
     1:                                  const nsACString& aGenericFamily,
 23904:                                  nsTArray<nsString>& aListOfFonts);
     1: 
     1:     /**
     1:      * Rebuilds the any cached system font lists
     1:      */
     1:     virtual nsresult UpdateFontList();
     1: 
     1:     /**
 57104:      * Create the platform font-list object (gfxPlatformFontList concrete subclass).
 57104:      * This function is responsible to create the appropriate subclass of
 57104:      * gfxPlatformFontList *and* to call its InitFontList() method.
 31590:      */
 31590:     virtual gfxPlatformFontList *CreatePlatformFontList() {
 31590:         NS_NOTREACHED("oops, this platform doesn't have a gfxPlatformFontList implementation");
 31590:         return nsnull;
 31590:     }
 31590: 
 31590:     /**
     1:      * Font name resolver, this returns actual font name(s) by the callback
     1:      * function. If the font doesn't exist, the callback function is not called.
 80486:      * If the callback function returns false, the aAborted value is set to
 80486:      * true, otherwise, false.
     1:      */
 79445:     typedef bool (*FontResolverCallback) (const nsAString& aName,
     1:                                             void *aClosure);
     1:     virtual nsresult ResolveFontName(const nsAString& aFontName,
     1:                                      FontResolverCallback aCallback,
     1:                                      void *aClosure,
 79445:                                      bool& aAborted) = 0;
     1: 
   270:     /**
 13003:      * Resolving a font name to family name. The result MUST be in the result of GetFontList().
 13003:      * If the name doesn't in the system, aFamilyName will be empty string, but not failed.
 13003:      */
 13003:     virtual nsresult GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName) = 0;
 13003: 
 13003:     /**
   270:      * Create the appropriate platform font group
   270:      */
   270:     virtual gfxFontGroup *CreateFontGroup(const nsAString& aFamilies,
 19962:                                           const gfxFontStyle *aStyle,
 19962:                                           gfxUserFontSet *aUserFontSet) = 0;
 19962:                                           
 19962:                                           
 19962:     /**
 22397:      * Look up a local platform font using the full font face name.
 22397:      * (Needed to support @font-face src local().)
 22397:      * Ownership of the returned gfxFontEntry is passed to the caller,
 22397:      * who must either AddRef() or delete.
 19962:      */
 23273:     virtual gfxFontEntry* LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
 23273:                                           const nsAString& aFontName)
 23273:     { return nsnull; }
 19962: 
 19962:     /**
 22397:      * Activate a platform font.  (Needed to support @font-face src url().)
 32808:      * aFontData is a NS_Malloc'ed block that must be freed by this function
 32808:      * (or responsibility passed on) when it is no longer needed; the caller
 32808:      * will NOT free it.
 22397:      * Ownership of the returned gfxFontEntry is passed to the caller,
 22397:      * who must either AddRef() or delete.
 19962:      */
 22397:     virtual gfxFontEntry* MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
 22397:                                            const PRUint8 *aFontData,
 32808:                                            PRUint32 aLength);
 19962: 
 19962:     /**
 19962:      * Whether to allow downloadable fonts via @font-face rules
 19962:      */
 79445:     bool DownloadableFontsEnabled();
 55084: 
 55084:     /**
 55084:      * Whether to sanitize downloaded fonts using the OTS library
 55084:      */
 79445:     bool SanitizeDownloadedFonts();
 19962: 
 89739:     /**
 89739:      * True when hinting should be enabled.  This setting shouldn't
 89739:      * change per gecko process, while the process is live.  If so the
 89739:      * results are not defined.
 89739:      *
 89739:      * NB: this bit is only honored by the FT2 backend, currently.
 89739:      */
 89739:     virtual bool FontHintingEnabled() { return true; }
 89739: 
 91872:     /**
 91872:      * Whether to check all font cmaps during system font fallback
 91872:      */
 91872:     bool UseCmapsDuringSystemFallback();
 91872: 
 84392: #ifdef MOZ_GRAPHITE
 84392:     /**
 84392:      * Whether to use the SIL Graphite rendering engine
 84392:      * (for fonts that include Graphite tables)
 84392:      */
 84392:     bool UseGraphiteShaping();
 84392: #endif
 84392: 
 43527:     /**
 43527:      * Whether to use the harfbuzz shaper (depending on script complexity).
 43527:      *
 43527:      * This allows harfbuzz to be enabled selectively via the preferences.
 43527:      */
 79445:     bool UseHarfBuzzForScript(PRInt32 aScriptCode);
 43527: 
 19962:     // check whether format is supported on a platform or not (if unclear, returns true)
 79445:     virtual bool IsFontFormatSupported(nsIURI *aFontURI, PRUint32 aFormatFlags) { return false; }
   270: 
 79445:     void GetPrefFonts(nsIAtom *aLanguage, nsString& array, bool aAppendUnicode = true);
     1: 
 37211:     // in some situations, need to make decisions about ambiguous characters, may need to look at multiple pref langs
 37211:     void GetLangPrefs(eFontPrefLang aPrefLangs[], PRUint32 &aLen, eFontPrefLang aCharLang, eFontPrefLang aPageLang);
 37211:     
  3787:     /**
 11086:      * Iterate over pref fonts given a list of lang groups.  For a single lang
 80486:      * group, multiple pref fonts are possible.  If error occurs, returns false,
 80486:      * true otherwise.  Callback returns false to abort process.
 11086:      */
 79445:     typedef bool (*PrefFontCallback) (eFontPrefLang aLang, const nsAString& aName,
 11086:                                         void *aClosure);
 79445:     static bool ForEachPrefFont(eFontPrefLang aLangArray[], PRUint32 aLangArrayLen,
 11086:                                   PrefFontCallback aCallback,
 11086:                                   void *aClosure);
 11086: 
 38493:     // convert a lang group to enum constant (i.e. "zh-TW" ==> eFontPrefLang_ChineseTW)
 11086:     static eFontPrefLang GetFontPrefLangFor(const char* aLang);
 11086: 
 38493:     // convert a lang group atom to enum constant
 38493:     static eFontPrefLang GetFontPrefLangFor(nsIAtom *aLang);
 38493: 
 11086:     // convert a enum constant to lang group string (i.e. eFontPrefLang_ChineseTW ==> "zh-TW")
 11086:     static const char* GetPrefLangName(eFontPrefLang aLang);
 11086:    
 37211:     // map a Unicode range (based on char code) to a font language for Preferences
 37211:     static eFontPrefLang GetFontPrefLangFor(PRUint8 aUnicodeRange);
 37211: 
 11086:     // returns true if a pref lang is CJK
 79445:     static bool IsLangCJK(eFontPrefLang aLang);
 11086:     
 11086:     // helper method to add a pref lang to an array, if not already in array
 11086:     static void AppendPrefLang(eFontPrefLang aPrefLangs[], PRUint32& aLen, eFontPrefLang aAddLang);
 11086: 
 91870:     // returns a list of commonly used fonts for a given character
 91870:     // these are *possible* matches, no cmap-checking is done at this level
 91870:     virtual void GetCommonFallbackFonts(const PRUint32 /*aCh*/,
 91870:                                         PRInt32 /*aRunScript*/,
 91870:                                         nsTArray<const char*>& /*aFontList*/)
 91870:     {
 91870:         // platform-specific override, by default do nothing
 91870:     }
 91870: 
103934:     // Break large OMTC tiled thebes layer painting into small paints.
103934:     static bool UseProgressiveTilePainting();
103934: 
 86671:     // helper method to indicate if we want to use Azure content drawing
 86671:     static bool UseAzureContentDrawing();
 86671:     
 11086:     /**
  3787:      * Are we going to try color management?
  3787:      */
 16571:     static eCMSMode GetCMSMode();
  3787: 
  3787:     /**
 16152:      * Determines the rendering intent for color management.
 16152:      *
 16152:      * If the value in the pref gfx.color_management.rendering_intent is a
 32801:      * valid rendering intent as defined in gfx/qcms/qcms.h, that
 16152:      * value is returned. Otherwise, -1 is returned and the embedded intent
 16152:      * should be used.
 16152:      *
 16152:      * See bug 444014 for details.
 16152:      */
 16152:     static int GetRenderingIntent();
 16152: 
 16152:     /**
 19127:      * Convert a pixel using a cms transform in an endian-aware manner.
 19127:      *
 19127:      * Sets 'out' to 'in' if transform is NULL.
 19127:      */
 27035:     static void TransformPixel(const gfxRGBA& in, gfxRGBA& out, qcms_transform *transform);
 19127: 
 19127:     /**
  3787:      * Return the output device ICC profile.
  3787:      */
 27035:     static qcms_profile* GetCMSOutputProfile();
  3787: 
  3787:     /**
 15987:      * Return the sRGB ICC profile.
 15987:      */
 27035:     static qcms_profile* GetCMSsRGBProfile();
 15987: 
 15987:     /**
  3787:      * Return sRGB -> output device transform.
  3787:      */
 27035:     static qcms_transform* GetCMSRGBTransform();
  3787: 
  3787:     /**
  5465:      * Return output -> sRGB device transform.
  5465:      */
 27035:     static qcms_transform* GetCMSInverseRGBTransform();
  5465: 
  5465:     /**
  3787:      * Return sRGBA -> output device transform.
  3787:      */
 27035:     static qcms_transform* GetCMSRGBATransform();
  3787: 
 71640:     virtual void FontsPrefsChanged(const char *aPref);
 42854: 
 86691:     PRInt32 GetBidiNumeralOption();
 86691: 
 51037:     /**
 51037:      * Returns a 1x1 surface that can be used to create graphics contexts
 51037:      * for measuring text etc as if they will be rendered to the screen
 51037:      */
 51037:     gfxASurface* ScreenReferenceSurface() { return mScreenReferenceSurface; }
 51037: 
 99511:     virtual mozilla::gfx::SurfaceFormat Optimal2DFormatForContent(gfxASurface::gfxContentType aContent);
 99511: 
 99511:     virtual gfxImageFormat OptimalFormatForContent(gfxASurface::gfxContentType aContent);
 99511: 
 59199:     virtual gfxImageFormat GetOffscreenFormat()
 99511:     { return gfxASurface::ImageFormatRGB24; }
 59199: 
 61084:     /**
 61084:      * Returns a logger if one is available and logging is enabled
 61084:      */
 61084:     static PRLogModuleInfo* GetLog(eGfxLog aWhichLog);
 61084: 
 95058:     bool WorkAroundDriverBugs() const { return mWorkAroundDriverBugs; }
 95058: 
 98557:     virtual int GetScreenDepth() const;
 98557: 
     1: protected:
 42854:     gfxPlatform();
     1:     virtual ~gfxPlatform();
     1: 
 37211:     void AppendCJKPrefLangs(eFontPrefLang aPrefLangs[], PRUint32 &aLen, 
 37211:                             eFontPrefLang aCharLang, eFontPrefLang aPageLang);
 37211: 
106616:     /**
106616:      * Helper method, creates a draw target for a specific Azure backend.
106616:      * Used by CreateOffscreenDrawTarget.
106616:      */
106616:     mozilla::RefPtr<mozilla::gfx::DrawTarget>
106616:       CreateDrawTargetForBackend(mozilla::gfx::BackendType aBackend,
106616:                                  const mozilla::gfx::IntSize& aSize,
106616:                                  mozilla::gfx::SurfaceFormat aFormat);
106616: 
106616:     /**
106616:      * Initialise the preferred and fallback canvas backends
106616:      * aBackendBitmask specifies the backends which are acceptable to the caller.
106616:      * The backend used is determined by aBackendBitmask and the order specified
106616:      * by the gfx.canvas.azure.backends pref.
106616:      */
106616:     void InitCanvasBackend(PRUint32 aBackendBitmask);
106616:     /**
106616:      * returns the first backend named in the pref gfx.canvas.azure.backends
106616:      * which is a component of aBackendBitmask, a bitmask of backend types
106616:      */
106616:     static mozilla::gfx::BackendType GetCanvasBackendPref(PRUint32 aBackendBitmask);
106616:     static mozilla::gfx::BackendType BackendTypeForName(const nsCString& aName);
106616: 
 79446:     PRInt8  mAllowDownloadableFonts;
 79446:     PRInt8  mDownloadableFontsSanitize;
 84392: #ifdef MOZ_GRAPHITE
 84392:     PRInt8  mGraphiteShapingEnabled;
 84392: #endif
 42854: 
 86691:     PRInt8  mBidiNumeralOption;
 86691: 
 91872:     // whether to always search font cmaps globally 
 91872:     // when doing system font fallback
 91872:     PRInt8  mFallbackUsesCmaps;
 91872: 
 67838:     // which scripts should be shaped with harfbuzz
 67838:     PRInt32 mUseHarfBuzzScripts;
 43527: 
  3787: private:
 93721:     /**
 93721:      * Start up Thebes.
 93721:      */
 93721:     static void Init();
 93721: 
 27035:     virtual qcms_profile* GetPlatformCMSOutputProfile();
 19003: 
 51037:     nsRefPtr<gfxASurface> mScreenReferenceSurface;
 37211:     nsTArray<PRUint32> mCJKPrefLangs;
 71640:     nsCOMPtr<nsIObserver> mSRGBOverrideObserver;
 71640:     nsCOMPtr<nsIObserver> mFontPrefsObserver;
106619: 
106619:     // The preferred draw target backend to use for canvas
106619:     mozilla::gfx::BackendType mPreferredCanvasBackend;
106619:     // The fallback draw target backend to use for canvas, if the preferred backend fails
106619:     mozilla::gfx::BackendType mFallbackCanvasBackend;
106619: 
106619:     mozilla::widget::GfxInfoCollector<gfxPlatform> mAzureCanvasBackendCollector;
 95058:     bool mWorkAroundDriverBugs;
     1: };
     1: 
     1: #endif /* GFX_PLATFORM_H */
