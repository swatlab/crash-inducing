    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Masatoshi Kimura <VYV03354@nifty.ne.jp>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "gfxWindowsPlatform.h"
    1: 
    1: #include "gfxImageSurface.h"
    1: #include "gfxWindowsSurface.h"
    1: 
    1: #include "nsUnicharUtils.h"
    1: 
26915: #include "nsIPrefService.h"
26915: #include "nsIPrefBranch2.h"
    1: #include "nsServiceManagerUtils.h"
23904: #include "nsTArray.h"
    1: 
    1: #include "nsIWindowsRegKey.h"
19962: #include "nsILocalFile.h"
19962: #include "plbase64.h"
    1: 
24104: #ifdef MOZ_FT2_FONTS
24104: #include "ft2build.h"
24104: #include FT_FREETYPE_H
24104: #include "gfxFT2Fonts.h"
24104: #include "cairo-ft.h"
31344: #include "nsAppDirectoryServiceDefs.h"
36949: #include "gfxFT2FontList.h"
24104: #else
  270: #include "gfxWindowsFonts.h"
36949: #include "gfxGDIFontList.h"
24104: #endif
24104: 
30086: /*XXX to get CAIRO_HAS_DDRAW_SURFACE */
30086: #include "cairo.h"
30086: 
24104: #ifdef WINCE
24104: #include <shlwapi.h>
30086: 
30086: #ifdef CAIRO_HAS_DDRAW_SURFACE
30086: #include "gfxDDrawSurface.h"
30086: #endif
24104: #endif
24104: 
19962: #include "gfxUserFontSet.h"
  270: 
    1: #include <string>
    1: 
24104: #ifdef MOZ_FT2_FONTS
24104: static FT_Library gPlatformFTLibrary = NULL;
24104: #endif
 1959: 
13578: static __inline void
13578: BuildKeyNameFromFontName(nsAString &aName)
13578: {
13578:     if (aName.Length() >= LF_FACESIZE)
13578:         aName.Truncate(LF_FACESIZE - 1);
13578:     ToLowerCase(aName);
13578: }
13280: 
36949: gfxWindowsPlatform::gfxWindowsPlatform()
 5254: {
36949:     mPrefFonts.Init(50);
 5254: 
24104: #ifdef MOZ_FT2_FONTS
24104:     FT_Init_FreeType(&gPlatformFTLibrary);
24104: #endif
24104: 
30087: /* Pick the default render mode differently between
30087:  * desktop, Windows Mobile, and Windows CE.
30087:  */
30087: #if defined(WINCE_WINDOWS_MOBILE)
30087:     mRenderMode = RENDER_IMAGE_DDRAW16;
30087: #elif defined(WINCE)
30087:     mRenderMode = RENDER_DDRAW_GL;
30087: #else
30087:     mRenderMode = RENDER_GDI;
30087: #endif
30087: 
36949:     nsCOMPtr<nsIPrefBranch2> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);
36949: 
30087:     PRInt32 rmode;
30087:     if (NS_SUCCEEDED(pref->GetIntPref("mozilla.widget.render-mode", &rmode))) {
30087:         if (rmode >= 0 || rmode < RENDER_MODE_MAX) {
30087: #ifndef CAIRO_HAS_DDRAW_SURFACE
30087:             if (rmode == RENDER_DDRAW || rmode == RENDER_DDRAW_GL)
30087:                 rmode = RENDER_IMAGE_STRETCH24;
30087: #endif
30087:             mRenderMode = (RenderMode) rmode;
26915:         }
26915:     }
    1: }
    1: 
    1: gfxWindowsPlatform::~gfxWindowsPlatform()
    1: {
24104:     // not calling FT_Done_FreeType because cairo may still hold references to
24104:     // these FT_Faces.  See bug 458169.
    1: }
    1: 
36949: gfxPlatformFontList*
36949: gfxWindowsPlatform::CreatePlatformFontList()
36949: {
36949: #ifdef MOZ_FT2_FONTS
36949:     return new gfxFT2FontList();
36949: #else
36949:     return new gfxGDIFontList();
36949: #endif
36949: }
36949:  
    1: already_AddRefed<gfxASurface>
    1: gfxWindowsPlatform::CreateOffscreenSurface(const gfxIntSize& size,
    1:                                            gfxASurface::gfxImageFormat imageFormat)
    1: {
30087:     gfxASurface *surf = nsnull;
30087: 
30086: #ifdef CAIRO_HAS_DDRAW_SURFACE
30087:     if (mRenderMode == RENDER_DDRAW || mRenderMode == RENDER_DDRAW_GL)
30087:         surf = new gfxDDrawSurface(NULL, size, imageFormat);
23691: #endif
30087: 
30087: #ifdef CAIRO_HAS_WIN32_SURFACE
30087:     if (mRenderMode == RENDER_GDI)
30087:         surf = new gfxWindowsSurface(size, imageFormat);
30086: #endif
30087: 
30087:     if (surf == nsnull)
30087:         surf = new gfxImageSurface(size, imageFormat);
30087: 
    1:     NS_IF_ADDREF(surf);
30087: 
    1:     return surf;
    1: }
    1: 
    1: nsresult
    1: gfxWindowsPlatform::GetFontList(const nsACString& aLangGroup,
    1:                                 const nsACString& aGenericFamily,
23904:                                 nsTArray<nsString>& aListOfFonts)
    1: {
36949:     gfxPlatformFontList::PlatformFontList()->GetFontList(aLangGroup, aGenericFamily, aListOfFonts);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: static void
    1: RemoveCharsetFromFontSubstitute(nsAString &aName)
    1: {
    1:     PRInt32 comma = aName.FindChar(PRUnichar(','));
    1:     if (comma >= 0)
    1:         aName.Truncate(comma);
    1: }
    1: 
24104: 
    1: nsresult
    1: gfxWindowsPlatform::UpdateFontList()
    1: {
36949:     gfxPlatformFontList::PlatformFontList()->UpdateFontList();
12989: 
    1:     return NS_OK;
    1: }
    1: 
    1: struct ResolveData {
    1:     ResolveData(gfxPlatform::FontResolverCallback aCallback,
    1:                 gfxWindowsPlatform *aCaller, const nsAString *aFontName,
    1:                 void *aClosure) :
    1:         mFoundCount(0), mCallback(aCallback), mCaller(aCaller),
    1:         mFontName(aFontName), mClosure(aClosure) {}
    1:     PRUint32 mFoundCount;
    1:     gfxPlatform::FontResolverCallback mCallback;
    1:     gfxWindowsPlatform *mCaller;
    1:     const nsAString *mFontName;
    1:     void *mClosure;
    1: };
    1: 
    1: nsresult
    1: gfxWindowsPlatform::ResolveFontName(const nsAString& aFontName,
    1:                                     FontResolverCallback aCallback,
36949:                                     void *aClosure, PRBool& aAborted)
    1: {
36949:     nsAutoString resolvedName;
36949:     if (!gfxPlatformFontList::PlatformFontList()->
36949:              ResolveFontName(aFontName, resolvedName)) {
36949:         aAborted = PR_FALSE;
36949:         return NS_OK;
36949:     }
36949:     aAborted = !(*aCallback)(resolvedName, aClosure);
    1:     return NS_OK;
    1: }
    1: 
36949: nsresult
36949: gfxWindowsPlatform::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
36949: {
36949:     gfxPlatformFontList::PlatformFontList()->GetStandardFamilyName(aFontName, aFamilyName);
    1:     return NS_OK;
    1: }
    1: 
  270: gfxFontGroup *
  270: gfxWindowsPlatform::CreateFontGroup(const nsAString &aFamilies,
19962:                                     const gfxFontStyle *aStyle,
19962:                                     gfxUserFontSet *aUserFontSet)
  270: {
24104: #ifdef MOZ_FT2_FONTS
24104:     return new gfxFT2FontGroup(aFamilies, aStyle);
24104: #else
19962:     return new gfxWindowsFontGroup(aFamilies, aStyle, aUserFontSet);
24104: #endif
19962: }
19962: 
19962: gfxFontEntry* 
23273: gfxWindowsPlatform::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
23273:                                     const nsAString& aFontName)
19962: {
36949:     return gfxPlatformFontList::PlatformFontList()->LookupLocalFont(aProxyEntry, 
36949:                                                                     aFontName);
19962: }
19962: 
19962: gfxFontEntry* 
22397: gfxWindowsPlatform::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
21067:                                      const PRUint8 *aFontData, PRUint32 aLength)
19962: {
36949:     return gfxPlatformFontList::PlatformFontList()->MakePlatformFont(aProxyEntry,
36949:                                                                      aFontData,
36949:                                                                      aLength);
19962: }
19962: 
19962: PRBool
19962: gfxWindowsPlatform::IsFontFormatSupported(nsIURI *aFontURI, PRUint32 aFormatFlags)
19962: {
23576:     // check for strange format flags
23576:     NS_ASSERTION(!(aFormatFlags & gfxUserFontSet::FLAG_FORMAT_NOT_USED),
23576:                  "strange font format hint set");
23576: 
23576:     // accept supported formats
32809:     if (aFormatFlags & (gfxUserFontSet::FLAG_FORMAT_WOFF     |
32809:                         gfxUserFontSet::FLAG_FORMAT_OPENTYPE | 
23576:                         gfxUserFontSet::FLAG_FORMAT_TRUETYPE)) {
23576:         return PR_TRUE;
23576:     }
23576: 
23576:     // reject all other formats, known and unknown
23576:     if (aFormatFlags != 0) {
19962:         return PR_FALSE;
19962:     }
19962: 
23576:     // no format hint set, need to look at data
19962:     return PR_TRUE;
  270: }
 1959: 
36949: gfxFontFamily *
13280: gfxWindowsPlatform::FindFontFamily(const nsAString& aName)
 1959: {
36949:     return gfxPlatformFontList::PlatformFontList()->FindFamily(aName);
13280: }
13280: 
36949: gfxFontEntry *
13578: gfxWindowsPlatform::FindFontEntry(const nsAString& aName, const gfxFontStyle& aFontStyle)
13280: {
36949:     nsRefPtr<gfxFontFamily> ff = FindFontFamily(aName);
13280:     if (!ff)
13280:         return nsnull;
13280: 
36949:     PRBool aNeedsBold;
36949:     return ff->FindFontForStyle(aFontStyle, aNeedsBold);
 1959: }
 3787: 
27035: qcms_profile*
 3787: gfxWindowsPlatform::GetPlatformCMSOutputProfile()
 3787: {
24104: #ifndef MOZ_FT2_FONTS
37454:     WCHAR str[MAX_PATH];
37454:     DWORD size = MAX_PATH;
37454:     BOOL res;
 3787: 
 3787:     HDC dc = GetDC(nsnull);
36860:     if (!dc)
36860:         return nsnull;
36860: 
37454: #if _MSC_VER
36860:     __try {
37454:         res = GetICMProfileW(dc, &size, (LPWSTR)&str);
36860:     } __except(GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION) {
37454:         res = FALSE;
36860:     }
37454: #else
37454:     res = GetICMProfileW(dc, &size, (LPWSTR)&str);
37454: #endif
36860: 
 3787:     ReleaseDC(nsnull, dc);
37454:     if (!res)
37454:         return nsnull;
 3787: 
27035:     qcms_profile* profile =
27035:         qcms_profile_from_path(NS_ConvertUTF16toUTF8(str).get());
 3787: #ifdef DEBUG_tor
 3787:     if (profile)
 3787:         fprintf(stderr,
 3787:                 "ICM profile read from %s successfully\n",
 3787:                 NS_ConvertUTF16toUTF8(str).get());
 3787: #endif
 3787:     return profile;
22248: #else
22248:     return nsnull;
22248: #endif
 3787: }
 5254: 
 5254: PRBool
36949: gfxWindowsPlatform::GetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<gfxFontEntry> > *array)
 5254: {
13280:     return mPrefFonts.Get(aKey, array);
 5254: }
 5254: 
 5254: void
36949: gfxWindowsPlatform::SetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<gfxFontEntry> >& array)
 5254: {
13280:     mPrefFonts.Put(aKey, array);
 5254: }
13877: 
24104: #ifdef MOZ_FT2_FONTS
24104: FT_Library
24104: gfxWindowsPlatform::GetFTLibrary()
24104: {
24104:     return gPlatformFTLibrary;
24104: }
24104: #endif
32950: 
37211: #ifndef MOZ_FT2_FONTS
37211: void
37211: gfxWindowsPlatform::SetupClusterBoundaries(gfxTextRun *aTextRun,
37211:                                            const PRUnichar *aString)
37211: {
37211:     NS_ABORT_IF_FALSE(sizeof(WCHAR) == sizeof(PRUnichar),
37211:                       "WCHAR/PRUnichar not compatible");
37211: 
37211:     PRUint32 length = aTextRun->GetLength();
37211: 
37211:     nsAutoTArray<SCRIPT_ITEM,4> items;
37211:     PRUint32 maxItems = 4;
37211:     int numItems;
37211:     HRESULT result;
37211:     PRUint32 i, j;
37211: 
37211:     do {
37211:         items.SetLength(maxItems);
37211:         result = ::ScriptItemize(aString, length,
37211:                                  maxItems - 1,
37211:                                  NULL,
37211:                                  NULL,
37211:                                  items.Elements(),
37211:                                  &numItems);
37211:         maxItems <<= 1;
37211:         if (maxItems > INT_MAX)
37211:             break;
37211:     } while (result == E_OUTOFMEMORY);
37211: 
37211:     if (result != 0) {
37211:         return;
37211:     }
37211: 
37211:     nsTArray<SCRIPT_LOGATTR> attrs;
37211:     for (i = 0; i < PRUint32(numItems); ++i) {
37211:         PRUint32 offset = items[i].iCharPos;
37211:         length = items[i + 1].iCharPos - offset;
37211:         if (attrs.Length() < length) {
37211:             attrs.SetLength(length);
37211:         }
37211:         result = ::ScriptBreak(aString + offset, length,
37211:                                &items[i].a,
37211:                                attrs.Elements());
37211:         if (result != 0) {
37211:             break;
37211:         }
37211:         for (j = 1; j < length; ++j) {
37211:             if (!attrs[j].fCharStop) {
37211:                 gfxTextRun::CompressedGlyph g;
37211:                 // Remember that this character is not the start of a cluster
37211:                 // by setting its glyph data to "not a cluster start",
37211:                 // "is a ligature start", with no glyphs.
37211:                 aTextRun->SetGlyphs(offset + j,
37211:                                     g.SetComplex(PR_FALSE, PR_TRUE, 0),
37211:                                     nsnull);
37211:             }
37211:         }
37211:     }
37211: }
37211: #endif
37211: 
32950: void
32950: gfxWindowsPlatform::InitDisplayCaps()
32950: {
32950:     HDC dc = GetDC((HWND)nsnull);
32950: 
32950:     gfxPlatform::sDPI = GetDeviceCaps(dc, LOGPIXELSY);
32950: 
32950:     ReleaseDC((HWND)nsnull, dc);
32950: }
32950: 
