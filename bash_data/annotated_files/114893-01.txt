     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsIDocShell.h"
     1: #include "nsPresContext.h"
 80058: #include "nsDOMClassInfoID.h"
108290: #include "nsError.h"
107461: #include "nsIDOMEvent.h"
     1: #include "nsDOMWindowUtils.h"
 39629: #include "nsQueryContentEventResult.h"
     1: #include "nsGlobalWindow.h"
     1: #include "nsIDocument.h"
 29018: #include "nsFocusManager.h"
 54257: #include "nsEventStateManager.h"
 63413: #include "nsFrameManager.h"
 67983: #include "nsRefreshDriver.h"
 87650: #include "nsDOMTouchEvent.h"
 87650: #include "nsIDOMTouchEvent.h"
 94270: #include "nsObjectLoadingContent.h"
111609: #include "nsFrame.h"
     1: 
 37063: #include "nsIScrollableFrame.h"
 26714: 
     1: #include "nsContentUtils.h"
 39629: #include "nsLayoutUtils.h"
     1: 
     1: #include "nsIFrame.h"
     1: #include "nsIWidget.h"
     1: #include "nsGUIEvent.h"
 93784: #include "nsCharsetSource.h"
  7369: #include "nsJSEnvironment.h"
 84803: #include "nsJSUtils.h"
     1: 
 18474: #include "nsIViewManager.h"
 18474: 
 22197: #include "nsIDOMHTMLCanvasElement.h"
 22197: #include "gfxContext.h"
 22197: #include "gfxImageSurface.h"
 38650: #include "nsLayoutUtils.h"
 40174: #include "nsComputedDOMStyle.h"
 51620: #include "nsIPresShell.h"
 56404: #include "nsStyleAnimation.h"
 56404: #include "nsCSSProps.h"
 78955: #include "nsDOMFile.h"
 80560: #include "BasicLayers.h"
 94270: #include "nsTArrayHelpers.h"
 97801: #include "nsIDocShell.h"
 97801: #include "nsIContentViewer.h"
 97801: #include "nsIMarkupDocumentViewer.h"
 99280: #include "nsClientRect.h"
 22197: 
103111: #if defined(MOZ_X11) && defined(MOZ_WIDGET_GTK)
 15235: #include <gdk/gdk.h>
     1: #include <gdk/gdkx.h>
     1: #endif
     1: 
 51975: #include "Layers.h"
 71624: #include "nsIIOService.h"
 51975: 
 64094: #include "mozilla/dom/Element.h"
 84685: #include "mozilla/dom/indexedDB/FileInfo.h"
 84685: #include "mozilla/dom/indexedDB/IndexedDatabaseManager.h"
 84290: #include "sampler.h"
100151: #include "nsDOMBlobBuilder.h"
100151: #include "nsIDOMFileHandle.h"
111055: #include "nsPrintfCString.h"
 64094: 
 96894: using namespace mozilla;
 64094: using namespace mozilla::dom;
 51975: using namespace mozilla::layers;
 82840: using namespace mozilla::widget;
 51975: 
 79445: static bool IsUniversalXPConnectCapable()
 39629: {
 79445:   bool hasCap = false;
 39629:   nsresult rv = nsContentUtils::GetSecurityManager()->
 39629:                   IsCapabilityEnabled("UniversalXPConnect", &hasCap);
 80486:   NS_ENSURE_SUCCESS(rv, false);
 39629:   return hasCap;
 39629: }
 39629: 
 40490: DOMCI_DATA(WindowUtils, nsDOMWindowUtils)
 40490: 
 94546: NS_INTERFACE_MAP_BEGIN(nsDOMWindowUtils)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMWindowUtils)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMWindowUtils)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
     1:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WindowUtils)
     1: NS_INTERFACE_MAP_END
     1: 
 94546: NS_IMPL_ADDREF(nsDOMWindowUtils)
 94546: NS_IMPL_RELEASE(nsDOMWindowUtils)
     1: 
     1: nsDOMWindowUtils::nsDOMWindowUtils(nsGlobalWindow *aWindow)
     1: {
 94546:   nsCOMPtr<nsISupports> supports = do_QueryObject(aWindow);
 94546:   mWindow = do_GetWeakReference(supports);
 94546:   NS_ASSERTION(aWindow->IsOuterWindow(), "How did that happen?");
     1: }
     1: 
     1: nsDOMWindowUtils::~nsDOMWindowUtils()
     1: {
     1: }
     1: 
 54075: nsIPresShell*
 54075: nsDOMWindowUtils::GetPresShell()
 54075: {
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   if (!window)
106838:     return nullptr;
 54075: 
 94546:   nsIDocShell *docShell = window->GetDocShell();
 54075:   if (!docShell)
106838:     return nullptr;
 54075: 
 54075:   nsCOMPtr<nsIPresShell> presShell;
 54075:   docShell->GetPresShell(getter_AddRefs(presShell));
 54075:   return presShell;
 54075: }
 54075: 
 23350: nsPresContext*
 23350: nsDOMWindowUtils::GetPresContext()
 23350: {
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   if (!window)
106838:     return nullptr;
 94546:   nsIDocShell *docShell = window->GetDocShell();
 23350:   if (!docShell)
106838:     return nullptr;
 39823:   nsRefPtr<nsPresContext> presContext;
 23350:   docShell->GetPresContext(getter_AddRefs(presContext));
 23350:   return presContext;
 23350: }
 23350: 
     1: NS_IMETHODIMP
108991: nsDOMWindowUtils::GetImageAnimationMode(uint16_t *aMode)
     1: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
     1:   NS_ENSURE_ARG_POINTER(aMode);
     1:   *aMode = 0;
 23350:   nsPresContext* presContext = GetPresContext();
     1:   if (presContext) {
     1:     *aMode = presContext->ImageAnimationMode();
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsDOMWindowUtils::SetImageAnimationMode(uint16_t aMode)
     1: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 23350:   nsPresContext* presContext = GetPresContext();
     1:   if (presContext) {
     1:     presContext->SetImageAnimationMode(aMode);
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsDOMWindowUtils::GetDocCharsetIsForced(bool *aIsForced)
  4527: {
 80486:   *aIsForced = false;
  4527: 
 39630:   if (!IsUniversalXPConnectCapable()) {
  4527:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
  4527: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   if (window) {
114646:     nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
  4527:     *aIsForced = doc &&
  4527:       doc->GetDocumentCharacterSetSource() >= kCharsetFromParentForced;
  4527:   }
  4527:   return NS_OK;
  4527: }
  4527: 
  4527: NS_IMETHODIMP
     1: nsDOMWindowUtils::GetDocumentMetadata(const nsAString& aName,
     1:                                       nsAString& aValue)
     1: {
 39630:   if (!IsUniversalXPConnectCapable()) {
     1:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
     1: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   if (window) {
 94546:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
     1:     if (doc) {
     1:       nsCOMPtr<nsIAtom> name = do_GetAtom(aName);
     1:       doc->GetHeaderData(name, aValue);
     1:       return NS_OK;
     1:     }
     1:   }
     1:   
     1:   aValue.Truncate();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsDOMWindowUtils::Redraw(uint32_t aCount, uint32_t *aDurationOut)
     1: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 15235:   if (aCount == 0)
 15235:     aCount = 1;
 15235: 
 54075:   if (nsIPresShell* presShell = GetPresShell()) {
     1:     nsIFrame *rootFrame = presShell->GetRootFrame();
     1: 
     1:     if (rootFrame) {
103530:       nsRect r(nsPoint(0, 0), rootFrame->GetSize());
103530: 
 15235:       PRIntervalTime iStart = PR_IntervalNow();
 15235: 
108991:       for (uint32_t i = 0; i < aCount; i++)
103530:         rootFrame->InvalidateWithFlags(r, nsIFrame::INVALIDATE_IMMEDIATE);
     1: 
103111: #if defined(MOZ_X11) && defined(MOZ_WIDGET_GTK)
103111:       XSync(GDK_DISPLAY_XDISPLAY(gdk_display_get_default()), False);
     1: #endif
 15235: 
 15235:       *aDurationOut = PR_IntervalToMilliseconds(PR_IntervalNow() - iStart);
 15235: 
     1:       return NS_OK;
     1:     }
     1:   }
 51975:   return NS_ERROR_FAILURE;
     1: }
 51975: 
 51975: NS_IMETHODIMP
 54076: nsDOMWindowUtils::SetCSSViewport(float aWidthPx, float aHeightPx)
 54076: {
 54076:   if (!IsUniversalXPConnectCapable()) {
 54076:     return NS_ERROR_DOM_SECURITY_ERR;
 54076:   }
 54076: 
 54076:   if (!(aWidthPx >= 0.0 && aHeightPx >= 0.0)) {
 54076:     return NS_ERROR_ILLEGAL_VALUE;
 54076:   }
 54076: 
 54076:   nsIPresShell* presShell = GetPresShell();
 54076:   if (!presShell) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 54076:   nscoord width = nsPresContext::CSSPixelsToAppUnits(aWidthPx);
 54076:   nscoord height = nsPresContext::CSSPixelsToAppUnits(aHeightPx);
 54076: 
 54649:   presShell->ResizeReflowOverride(width, height);
 54076: 
 54076:   return NS_OK;
 54076: }
 54076: 
114646: NS_IMETHODIMP
114646: nsDOMWindowUtils::GetViewportInfo(uint32_t aDisplayWidth,
114646:                                   uint32_t aDisplayHeight,
114646:                                   double *aDefaultZoom, bool *aAllowZoom,
114646:                                   double *aMinZoom, double *aMaxZoom,
114646:                                   uint32_t *aWidth, uint32_t *aHeight,
114646:                                   bool *aAutoSize)
114646: {
114646:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
114646:   NS_ENSURE_STATE(window);
114646: 
114646:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
114646:   NS_ENSURE_STATE(doc);
114646: 
114646:   ViewportInfo info = nsContentUtils::GetViewportInfo(doc, aDisplayWidth, aDisplayHeight);
114646:   *aDefaultZoom = info.defaultZoom;
114646:   *aAllowZoom = info.allowZoom;
114646:   *aMinZoom = info.minZoom;
114646:   *aMaxZoom = info.maxZoom;
114646:   *aWidth = info.width;
114646:   *aHeight = info.height;
114646:   *aAutoSize = info.autoSize;
114646:   return NS_OK;
114646: }
114646: 
 63413: static void DestroyNsRect(void* aObject, nsIAtom* aPropertyName,
 63413:                           void* aPropertyValue, void* aData)
 63413: {
 63413:   nsRect* rect = static_cast<nsRect*>(aPropertyValue);
 63413:   delete rect;
 63413: }
 63413: 
 97801: static void
 97801: MaybeReflowForInflationScreenWidthChange(nsPresContext *aPresContext)
 97801: {
101113:   if (aPresContext) {
101113:     nsIPresShell* presShell = aPresContext->GetPresShell();
101113:     if (presShell && nsLayoutUtils::FontSizeInflationEnabled(aPresContext) &&
101113:         presShell->FontSizeInflationMinTwips() != 0) {
 97801:       bool changed;
 97801:       aPresContext->ScreenWidthInchesForFontInflation(&changed);
 97801:       if (changed) {
 97801:         nsCOMPtr<nsISupports> container = aPresContext->GetContainer();
 97801:         nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(container);
 97801:         if (docShell) {
 97801:           nsCOMPtr<nsIContentViewer> cv;
 97801:           docShell->GetContentViewer(getter_AddRefs(cv));
 97801:           nsCOMPtr<nsIMarkupDocumentViewer> mudv = do_QueryInterface(cv);
 97801:           if (mudv) {
 97801:             nsTArray<nsCOMPtr<nsIMarkupDocumentViewer> > array;
 97801:             mudv->AppendSubtree(array);
108991:             for (uint32_t i = 0, iEnd = array.Length(); i < iEnd; ++i) {
 97801:               nsCOMPtr<nsIPresShell> shell;
 97801:               nsCOMPtr<nsIContentViewer> cv = do_QueryInterface(array[i]);
 97801:               cv->GetPresShell(getter_AddRefs(shell));
 98117:               if (shell) {
 98117:                 nsIFrame *rootFrame = shell->GetRootFrame();
 97801:                 if (rootFrame) {
101736:                   shell->FrameNeedsReflow(rootFrame,
101736:                                           nsIPresShell::eStyleChange,
 97801:                                           NS_FRAME_IS_DIRTY);
 97801:                 }
 97801:               }
 97801:             }
 97801:           }
 97801:         }
 97801:       }
 97801:     }
 97915:   }
101113: }
 97801: 
 54076: NS_IMETHODIMP
 63413: nsDOMWindowUtils::SetDisplayPortForElement(float aXPx, float aYPx,
 63413:                                            float aWidthPx, float aHeightPx,
 63413:                                            nsIDOMElement* aElement)
 63413: {
 54080:   if (!IsUniversalXPConnectCapable()) {
 54080:     return NS_ERROR_DOM_SECURITY_ERR;
 54080:   }
 54080: 
 54080:   nsIPresShell* presShell = GetPresShell();
 54080:   if (!presShell) {
 54080:     return NS_ERROR_FAILURE;
 54080:   }
 54080: 
 54080:   nsRect displayport(nsPresContext::CSSPixelsToAppUnits(aXPx),
 54080:                      nsPresContext::CSSPixelsToAppUnits(aYPx),
 54080:                      nsPresContext::CSSPixelsToAppUnits(aWidthPx),
 54080:                      nsPresContext::CSSPixelsToAppUnits(aHeightPx));
 54080: 
 63413:   if (!aElement) {
 63413:     return NS_ERROR_INVALID_ARG;
 63413:   }
 63413: 
 63413:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
 63413: 
 63413:   if (!content) {
 63413:     return NS_ERROR_INVALID_ARG;
 63413:   }
 63413: 
 95507:   if (content->GetCurrentDoc() != presShell->GetDocument()) {
 95507:     return NS_ERROR_INVALID_ARG;
 95507:   }
 95507: 
 63413:   content->SetProperty(nsGkAtoms::DisplayPort, new nsRect(displayport),
 63413:                        DestroyNsRect);
 63413: 
 63413:   nsIFrame* rootScrollFrame = presShell->GetRootScrollFrame();
 63413:   if (rootScrollFrame) {
 63413:     if (content == rootScrollFrame->GetContent()) {
 63414:       // We are setting a root displayport for a document.
 63414:       // The pres shell needs a special flag set.
 80486:       presShell->SetIgnoreViewportScrolling(true);
 97801: 
 97801:       // When the "font.size.inflation.minTwips" preference is set, the
 97801:       // layout depends on the size of the screen.  Since when the size
 97801:       // of the screen changes, the root displayport also changes, we
 97801:       // hook in the needed updates here rather than adding a
 97801:       // separate notification just for this change.
 97801:       nsPresContext* presContext = GetPresContext();
 97801:       MaybeReflowForInflationScreenWidthChange(presContext);
 63413:     }
 63413:   }
 63413: 
 63414:   nsIFrame* rootFrame = presShell->FrameManager()->GetRootFrame();
 63413:   if (rootFrame) {
103530:     nsIContent* rootContent =
106838:       rootScrollFrame ? rootScrollFrame->GetContent() : nullptr;
103530:     nsRect rootDisplayport;
103530:     bool usingDisplayport = rootContent &&
103530:       nsLayoutUtils::GetDisplayPort(rootContent, &rootDisplayport);
103530:     rootFrame->InvalidateWithFlags(
103530:       usingDisplayport ? rootDisplayport : rootFrame->GetVisualOverflowRect(),
103530:       nsIFrame::INVALIDATE_NO_THEBES_LAYERS);
 80560: 
 97371:     // If we are hiding something that is a display root then send empty paint
 97371:     // transaction in order to release retained layers because it won't get
 97371:     // any more paint requests when it is hidden.
 97371:     if (displayport.IsEmpty() &&
 97371:         rootFrame == nsLayoutUtils::GetDisplayRootFrame(rootFrame)) {
 80560:       nsCOMPtr<nsIWidget> widget = GetWidget();
 80560:       if (widget) {
 80560:         bool isRetainingManager;
 80560:         LayerManager* manager = widget->GetLayerManager(&isRetainingManager);
 80560:         if (isRetainingManager) {
 80560:           manager->BeginTransaction();
106838:           nsLayoutUtils::PaintFrame(nullptr, rootFrame, nsRegion(), NS_RGB(255, 255, 255),
 80560:                                     nsLayoutUtils::PAINT_WIDGET_LAYERS |
 80560:                                     nsLayoutUtils::PAINT_EXISTING_TRANSACTION);
 80560:         }
 80560:       }
 80560:     }
 63413:   }
 54080: 
 54080:   return NS_OK;
 54080: }
 54080: 
 54080: NS_IMETHODIMP
 54081: nsDOMWindowUtils::SetResolution(float aXResolution, float aYResolution)
 54081: {
 54081:   if (!IsUniversalXPConnectCapable()) {
 54081:     return NS_ERROR_DOM_SECURITY_ERR;
 54081:   }
 54081: 
 54081:   nsIPresShell* presShell = GetPresShell();
 54081:   return presShell ? presShell->SetResolution(aXResolution, aYResolution)
 54081:                    : NS_ERROR_FAILURE;
 54081: }
 54081: 
     1: NS_IMETHODIMP
 93057: nsDOMWindowUtils::SetIsFirstPaint(bool aIsFirstPaint)
 93057: {
 93057:   if (!IsUniversalXPConnectCapable()) {
 93057:     return NS_ERROR_DOM_SECURITY_ERR;
 93057:   }
 93057: 
 93057:   nsIPresShell* presShell = GetPresShell();
 93057:   if (presShell) {
 93057:     presShell->SetIsFirstPaint(aIsFirstPaint);
 93057:     return NS_OK;
 93057:   }
 93057:   return NS_ERROR_FAILURE;
 93057: }
 93057: 
 93057: NS_IMETHODIMP
 93057: nsDOMWindowUtils::GetIsFirstPaint(bool *aIsFirstPaint)
 93057: {
 93057:   if (!IsUniversalXPConnectCapable()) {
 93057:     return NS_ERROR_DOM_SECURITY_ERR;
 93057:   }
 93057: 
 93057:   nsIPresShell* presShell = GetPresShell();
 93057:   if (presShell) {
 93057:     *aIsFirstPaint = presShell->GetIsFirstPaint();
 93057:     return NS_OK;
 93057:   }
 93057:   return NS_ERROR_FAILURE;
 93057: }
 93057: 
 96894: /* static */
 96894: mozilla::widget::Modifiers
108991: nsDOMWindowUtils::GetWidgetModifiers(int32_t aModifiers)
 96894: {
 96894:   widget::Modifiers result = 0;
 96894:   if (aModifiers & nsIDOMWindowUtils::MODIFIER_SHIFT) {
 96894:     result |= widget::MODIFIER_SHIFT;
 96894:   }
 96894:   if (aModifiers & nsIDOMWindowUtils::MODIFIER_CONTROL) {
 96894:     result |= widget::MODIFIER_CONTROL;
 96894:   }
 96894:   if (aModifiers & nsIDOMWindowUtils::MODIFIER_ALT) {
 96894:     result |= widget::MODIFIER_ALT;
 96894:   }
 96894:   if (aModifiers & nsIDOMWindowUtils::MODIFIER_META) {
 96894:     result |= widget::MODIFIER_META;
 96894:   }
 96894:   if (aModifiers & nsIDOMWindowUtils::MODIFIER_ALTGRAPH) {
 96894:     result |= widget::MODIFIER_ALTGRAPH;
 96894:   }
 96894:   if (aModifiers & nsIDOMWindowUtils::MODIFIER_CAPSLOCK) {
 96894:     result |= widget::MODIFIER_CAPSLOCK;
 96894:   }
 96894:   if (aModifiers & nsIDOMWindowUtils::MODIFIER_FN) {
 96894:     result |= widget::MODIFIER_FN;
 96894:   }
 96894:   if (aModifiers & nsIDOMWindowUtils::MODIFIER_NUMLOCK) {
 96894:     result |= widget::MODIFIER_NUMLOCK;
 96894:   }
103760:   if (aModifiers & nsIDOMWindowUtils::MODIFIER_SCROLLLOCK) {
103761:     result |= widget::MODIFIER_SCROLLLOCK;
 96894:   }
 96894:   if (aModifiers & nsIDOMWindowUtils::MODIFIER_SYMBOLLOCK) {
 96894:     result |= widget::MODIFIER_SYMBOLLOCK;
 96894:   }
103760:   if (aModifiers & nsIDOMWindowUtils::MODIFIER_OS) {
103761:     result |= widget::MODIFIER_OS;
 96894:   }
 96894:   return result;
 96894: }
 96894: 
 93057: NS_IMETHODIMP
     1: nsDOMWindowUtils::SendMouseEvent(const nsAString& aType,
 21967:                                  float aX,
 21967:                                  float aY,
108991:                                  int32_t aButton,
108991:                                  int32_t aClickCount,
108991:                                  int32_t aModifiers,
108301:                                  bool aIgnoreRootScrollFrame,
108301:                                  float aPressure,
108301:                                  unsigned short aInputSourceArg)
     1: {
 51620:   return SendMouseEventCommon(aType, aX, aY, aButton, aClickCount, aModifiers,
109430:                               aIgnoreRootScrollFrame, aPressure,
109430:                               aInputSourceArg, false);
 51620: }
 51620: 
 51620: NS_IMETHODIMP
 51620: nsDOMWindowUtils::SendMouseEventToWindow(const nsAString& aType,
 51620:                                          float aX,
 51620:                                          float aY,
108991:                                          int32_t aButton,
108991:                                          int32_t aClickCount,
108991:                                          int32_t aModifiers,
108301:                                          bool aIgnoreRootScrollFrame,
108301:                                          float aPressure,
108301:                                          unsigned short aInputSourceArg)
 51620: {
102603:   SAMPLE_LABEL("nsDOMWindowUtils", "SendMouseEventToWindow");
 51620:   return SendMouseEventCommon(aType, aX, aY, aButton, aClickCount, aModifiers,
109430:                               aIgnoreRootScrollFrame, aPressure,
109430:                               aInputSourceArg, true);
 51620: }
 51620: 
 98205: static nsIntPoint
 98205: ToWidgetPoint(float aX, float aY, const nsPoint& aOffset,
 98205:               nsPresContext* aPresContext)
 98205: {
 98205:   double appPerDev = aPresContext->AppUnitsPerDevPixel();
 98205:   nscoord appPerCSS = nsPresContext::AppUnitsPerCSSPixel();
 98205:   return nsIntPoint(NSToIntRound((aX*appPerCSS + aOffset.x)/appPerDev),
 98205:                     NSToIntRound((aY*appPerCSS + aOffset.y)/appPerDev));
 98205: }
 98205: 
 51620: NS_IMETHODIMP
 51620: nsDOMWindowUtils::SendMouseEventCommon(const nsAString& aType,
 51620:                                        float aX,
 51620:                                        float aY,
108991:                                        int32_t aButton,
108991:                                        int32_t aClickCount,
108991:                                        int32_t aModifiers,
 79445:                                        bool aIgnoreRootScrollFrame,
108301:                                        float aPressure,
108301:                                        unsigned short aInputSourceArg,
 79445:                                        bool aToWindow)
 51620: {
 39630:   if (!IsUniversalXPConnectCapable()) {
     1:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
     1: 
     1:   // get the widget to send the event to
 21967:   nsPoint offset;
 21967:   nsCOMPtr<nsIWidget> widget = GetWidget(&offset);
     1:   if (!widget)
     1:     return NS_ERROR_FAILURE;
     1: 
108991:   int32_t msg;
 79445:   bool contextMenuKey = false;
     1:   if (aType.EqualsLiteral("mousedown"))
     1:     msg = NS_MOUSE_BUTTON_DOWN;
     1:   else if (aType.EqualsLiteral("mouseup"))
     1:     msg = NS_MOUSE_BUTTON_UP;
     1:   else if (aType.EqualsLiteral("mousemove"))
     1:     msg = NS_MOUSE_MOVE;
     1:   else if (aType.EqualsLiteral("mouseover"))
     1:     msg = NS_MOUSE_ENTER;
     1:   else if (aType.EqualsLiteral("mouseout"))
     1:     msg = NS_MOUSE_EXIT;
  6039:   else if (aType.EqualsLiteral("contextmenu")) {
     1:     msg = NS_CONTEXTMENU;
  6039:     contextMenuKey = (aButton == 0);
  6039:   } else
     1:     return NS_ERROR_FAILURE;
     1: 
108301:   if (aInputSourceArg == nsIDOMMouseEvent::MOZ_SOURCE_UNKNOWN) {
108301:     aInputSourceArg = nsIDOMMouseEvent::MOZ_SOURCE_MOUSE;
108301:   }
108301: 
 80486:   nsMouseEvent event(true, msg, widget, nsMouseEvent::eReal,
  6039:                      contextMenuKey ?
  6039:                        nsMouseEvent::eContextMenuKey : nsMouseEvent::eNormal);
 96894:   event.modifiers = GetWidgetModifiers(aModifiers);
     1:   event.button = aButton;
     1:   event.widget = widget;
108301:   event.pressure = aPressure;
108301:   event.inputSource = aInputSourceArg;
     1:   event.clickCount = aClickCount;
     1:   event.time = PR_IntervalNow();
 33400:   event.flags |= NS_EVENT_FLAG_SYNTHETIC_TEST_EVENT;
 21967: 
 47902:   nsPresContext* presContext = GetPresContext();
 47902:   if (!presContext)
 47902:     return NS_ERROR_FAILURE;
 47902: 
 98205:   event.refPoint = ToWidgetPoint(aX, aY, offset, presContext);
 22095:   event.ignoreRootScrollFrame = aIgnoreRootScrollFrame;
     1: 
     1:   nsEventStatus status;
 51620:   if (aToWindow) {
 82568:     nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
 51620:     if (!presShell)
 51620:       return NS_ERROR_FAILURE;
 51620:     nsIViewManager* viewManager = presShell->GetViewManager();
 51620:     if (!viewManager)
 51620:       return NS_ERROR_FAILURE;
 64435:     nsIView* view = viewManager->GetRootView();
 64435:     if (!view)
 51620:       return NS_ERROR_FAILURE;
 51620: 
 51620:     status = nsEventStatus_eIgnore;
 82568:     return presShell->HandleEvent(view->GetFrame(), &event, false, &status);
 51620:   }
 64435:   return widget->DispatchEvent(&event, status);
     1: }
     1: 
     1: NS_IMETHODIMP
108067: nsDOMWindowUtils::SendWheelEvent(float aX,
 21967:                                  float aY,
108067:                                  double aDeltaX,
108067:                                  double aDeltaY,
108067:                                  double aDeltaZ,
108991:                                  uint32_t aDeltaMode,
108991:                                  int32_t aModifiers,
108991:                                  int32_t aLineOrPageDeltaX,
108991:                                  int32_t aLineOrPageDeltaY,
108991:                                  uint32_t aOptions)
 16604: {
 39630:   if (!IsUniversalXPConnectCapable()) {
 16604:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
 16604: 
 16604:   // get the widget to send the event to
 21967:   nsPoint offset;
 21967:   nsCOMPtr<nsIWidget> widget = GetWidget(&offset);
108067:   if (!widget) {
 16604:     return NS_ERROR_NULL_POINTER;
108067:   }
108067: 
108067:   widget::WheelEvent wheelEvent(true, NS_WHEEL_WHEEL, widget);
108067:   wheelEvent.modifiers = GetWidgetModifiers(aModifiers);
108067:   wheelEvent.deltaX = aDeltaX;
108067:   wheelEvent.deltaY = aDeltaY;
108067:   wheelEvent.deltaZ = aDeltaZ;
108067:   wheelEvent.deltaMode = aDeltaMode;
108067:   wheelEvent.isMomentum =
108067:     (aOptions & WHEEL_EVENT_CAUSED_BY_MOMENTUM) != 0;
108067:   wheelEvent.isPixelOnlyDevice =
108067:     (aOptions & WHEEL_EVENT_CAUSED_BY_PIXEL_ONLY_DEVICE) != 0;
108067:   NS_ENSURE_TRUE(
108067:     !wheelEvent.isPixelOnlyDevice ||
108067:       aDeltaMode == nsIDOMWheelEvent::DOM_DELTA_PIXEL,
108067:     NS_ERROR_INVALID_ARG);
108067:   wheelEvent.customizedByUserPrefs =
108067:     (aOptions & WHEEL_EVENT_CUSTOMIZED_BY_USER_PREFS) != 0;
108067:   wheelEvent.lineOrPageDeltaX = aLineOrPageDeltaX;
108067:   wheelEvent.lineOrPageDeltaY = aLineOrPageDeltaY;
108067:   wheelEvent.widget = widget;
108067: 
108067:   wheelEvent.time = PR_Now() / 1000;
 21967: 
 47902:   nsPresContext* presContext = GetPresContext();
108067:   NS_ENSURE_TRUE(presContext, NS_ERROR_FAILURE);
108067: 
108067:   wheelEvent.refPoint = ToWidgetPoint(aX, aY, offset, presContext);
 16604: 
 16604:   nsEventStatus status;
108067:   nsresult rv = widget->DispatchEvent(&wheelEvent, status);
108067:   NS_ENSURE_SUCCESS(rv, rv);
111055: 
111055:   bool failedX = false;
111055:   if ((aOptions & WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_ZERO) &&
111055:       wheelEvent.overflowDeltaX != 0) {
111055:     failedX = true;
111055:   }
111055:   if ((aOptions & WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_POSITIVE) &&
111055:       wheelEvent.overflowDeltaX <= 0) {
111055:     failedX = true;
111055:   }
111055:   if ((aOptions & WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_NEGATIVE) &&
111055:       wheelEvent.overflowDeltaX >= 0) {
111055:     failedX = true;
111055:   }
111055:   bool failedY = false;
111055:   if ((aOptions & WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_ZERO) &&
111055:       wheelEvent.overflowDeltaY != 0) {
111055:     failedY = true;
111055:   }
111055:   if ((aOptions & WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_POSITIVE) &&
111055:       wheelEvent.overflowDeltaY <= 0) {
111055:     failedY = true;
111055:   }
111055:   if ((aOptions & WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_NEGATIVE) &&
111055:       wheelEvent.overflowDeltaY >= 0) {
111055:     failedY = true;
111055:   }
111055: 
111055: #ifdef DEBUG
111055:   if (failedX) {
111055:     nsPrintfCString debugMsg("SendWheelEvent(): unexpected overflowDeltaX: %f",
111055:                              wheelEvent.overflowDeltaX);
111055:     NS_WARNING(debugMsg.get());
111055:   }
111055:   if (failedY) {
111055:     nsPrintfCString debugMsg("SendWheelEvent(): unexpected overflowDeltaY: %f",
111055:                              wheelEvent.overflowDeltaY);
111055:     NS_WARNING(debugMsg.get());
111055:   }
111055: #endif
111055: 
111055:   return (!failedX && !failedY) ? NS_OK : NS_ERROR_FAILURE;
 16604: }
 16604: 
 87650: NS_IMETHODIMP
 87650: nsDOMWindowUtils::SendTouchEvent(const nsAString& aType,
108991:                                  uint32_t *aIdentifiers,
108991:                                  int32_t *aXs,
108991:                                  int32_t *aYs,
108991:                                  uint32_t *aRxs,
108991:                                  uint32_t *aRys,
 87650:                                  float *aRotationAngles,
 87650:                                  float *aForces,
108991:                                  uint32_t aCount,
108991:                                  int32_t aModifiers,
 87650:                                  bool aIgnoreRootScrollFrame,
 87650:                                  bool *aPreventDefault)
 87650: {
 87650:   if (!IsUniversalXPConnectCapable()) {
 87650:     return NS_ERROR_DOM_SECURITY_ERR;
 87650:   }
 87650: 
 87650:   // get the widget to send the event to
 87650:   nsPoint offset;
 87650:   nsCOMPtr<nsIWidget> widget = GetWidget(&offset);
 87650:   if (!widget) {
 87650:     return NS_ERROR_NULL_POINTER;
 87650:   }
108991:   int32_t msg;
 87650:   if (aType.EqualsLiteral("touchstart")) {
 87650:     msg = NS_TOUCH_START;
 87650:   } else if (aType.EqualsLiteral("touchmove")) {
 87650:     msg = NS_TOUCH_MOVE;
 87650:   } else if (aType.EqualsLiteral("touchend")) {
 87650:     msg = NS_TOUCH_END;
 87650:   } else if (aType.EqualsLiteral("touchcancel")) {
 87650:     msg = NS_TOUCH_CANCEL;
 87650:   } else {
 87650:     return NS_ERROR_UNEXPECTED;
 87650:   }
 87650:   nsTouchEvent event(true, msg, widget);
 96894:   event.modifiers = GetWidgetModifiers(aModifiers);
 87650:   event.widget = widget;
 87650:   event.time = PR_Now();
 87650: 
 87650:   nsPresContext* presContext = GetPresContext();
 87650:   if (!presContext) {
 87650:     return NS_ERROR_FAILURE;
 87650:   }
 87650:   event.touches.SetCapacity(aCount);
108991:   for (uint32_t i = 0; i < aCount; ++i) {
 98205:     nsIntPoint pt = ToWidgetPoint(aXs[i], aYs[i], offset, presContext);
 87650:     nsCOMPtr<nsIDOMTouch> t(new nsDOMTouch(aIdentifiers[i],
 87650:                                            pt,
 87650:                                            nsIntPoint(aRxs[i], aRys[i]),
 87650:                                            aRotationAngles[i],
 87650:                                            aForces[i]));
 87650:     event.touches.AppendElement(t);
 87650:   }
 87650: 
 87650:   nsEventStatus status;
 87650:   nsresult rv = widget->DispatchEvent(&event, status);
 87650:   *aPreventDefault = (status == nsEventStatus_eConsumeNoDefault);
 87650:   return rv;
 87650: }
 87650: 
 16604: NS_IMETHODIMP
     1: nsDOMWindowUtils::SendKeyEvent(const nsAString& aType,
108991:                                int32_t aKeyCode,
108991:                                int32_t aCharCode,
108991:                                int32_t aModifiers,
108991:                                uint32_t aAdditionalFlags,
 79445:                                bool* aDefaultActionTaken)
     1: {
 39630:   if (!IsUniversalXPConnectCapable()) {
     1:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
     1: 
     1:   // get the widget to send the event to
  4010:   nsCOMPtr<nsIWidget> widget = GetWidget();
     1:   if (!widget)
     1:     return NS_ERROR_FAILURE;
     1: 
108991:   int32_t msg;
     1:   if (aType.EqualsLiteral("keydown"))
     1:     msg = NS_KEY_DOWN;
     1:   else if (aType.EqualsLiteral("keyup"))
     1:     msg = NS_KEY_UP;
     1:   else if (aType.EqualsLiteral("keypress"))
     1:     msg = NS_KEY_PRESS;
     1:   else
     1:     return NS_ERROR_FAILURE;
     1: 
 80486:   nsKeyEvent event(true, msg, widget);
 96894:   event.modifiers = GetWidgetModifiers(aModifiers);
     1: 
 97482:   if (msg == NS_KEY_PRESS) {
 97482:     event.keyCode = aCharCode ? 0 : aKeyCode;
 97482:     event.charCode = aCharCode;
 97482:   } else {
     1:     event.keyCode = aKeyCode;
 97482:     event.charCode = 0;
 97482:   }
 97482: 
108991:   uint32_t locationFlag = (aAdditionalFlags &
 97482:     (KEY_FLAG_LOCATION_STANDARD | KEY_FLAG_LOCATION_LEFT |
 97482:      KEY_FLAG_LOCATION_RIGHT | KEY_FLAG_LOCATION_NUMPAD |
 97482:      KEY_FLAG_LOCATION_MOBILE | KEY_FLAG_LOCATION_JOYSTICK));
 97482:   switch (locationFlag) {
 97482:     case KEY_FLAG_LOCATION_STANDARD:
 97482:       event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_STANDARD;
 97482:       break;
 97482:     case KEY_FLAG_LOCATION_LEFT:
 97482:       event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_LEFT;
 97482:       break;
 97482:     case KEY_FLAG_LOCATION_RIGHT:
 97482:       event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_RIGHT;
 97482:       break;
 97482:     case KEY_FLAG_LOCATION_NUMPAD:
 97482:       event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_NUMPAD;
 97482:       break;
 97482:     case KEY_FLAG_LOCATION_MOBILE:
 97482:       event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_MOBILE;
 97482:       break;
 97482:     case KEY_FLAG_LOCATION_JOYSTICK:
 97482:       event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_JOYSTICK;
 97482:       break;
 97482:     default:
 97482:       if (locationFlag != 0) {
 97482:         return NS_ERROR_INVALID_ARG;
 97482:       }
 97482:       // If location flag isn't set, choose the location from keycode.
 97482:       switch (aKeyCode) {
 97482:         case nsIDOMKeyEvent::DOM_VK_NUMPAD0:
 97482:         case nsIDOMKeyEvent::DOM_VK_NUMPAD1:
 97482:         case nsIDOMKeyEvent::DOM_VK_NUMPAD2:
 97482:         case nsIDOMKeyEvent::DOM_VK_NUMPAD3:
 97482:         case nsIDOMKeyEvent::DOM_VK_NUMPAD4:
 97482:         case nsIDOMKeyEvent::DOM_VK_NUMPAD5:
 97482:         case nsIDOMKeyEvent::DOM_VK_NUMPAD6:
 97482:         case nsIDOMKeyEvent::DOM_VK_NUMPAD7:
 97482:         case nsIDOMKeyEvent::DOM_VK_NUMPAD8:
 97482:         case nsIDOMKeyEvent::DOM_VK_NUMPAD9:
 97482:         case nsIDOMKeyEvent::DOM_VK_MULTIPLY:
 97482:         case nsIDOMKeyEvent::DOM_VK_ADD:
 97482:         case nsIDOMKeyEvent::DOM_VK_SEPARATOR:
 97482:         case nsIDOMKeyEvent::DOM_VK_SUBTRACT:
 97482:         case nsIDOMKeyEvent::DOM_VK_DECIMAL:
 97482:         case nsIDOMKeyEvent::DOM_VK_DIVIDE:
 97482:           event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_NUMPAD;
 97482:           break;
 97482:         case nsIDOMKeyEvent::DOM_VK_SHIFT:
 97482:         case nsIDOMKeyEvent::DOM_VK_CONTROL:
 97482:         case nsIDOMKeyEvent::DOM_VK_ALT:
 97482:         case nsIDOMKeyEvent::DOM_VK_META:
 97482:           event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_LEFT;
 97482:           break;
 97482:         default:
 97482:           event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_STANDARD;
 97482:           break;
 97482:       }
 97482:       break;
 97482:   }
 97482: 
     1:   event.refPoint.x = event.refPoint.y = 0;
     1:   event.time = PR_IntervalNow();
     1: 
 97482:   if (aAdditionalFlags & KEY_FLAG_PREVENT_DEFAULT) {
 18388:     event.flags |= NS_EVENT_FLAG_NO_DEFAULT;
 18388:   }
 18388: 
     1:   nsEventStatus status;
 18388:   nsresult rv = widget->DispatchEvent(&event, status);
 18388:   NS_ENSURE_SUCCESS(rv, rv);
 18388: 
 18388:   *aDefaultActionTaken = (status != nsEventStatus_eConsumeNoDefault);
 18388:   
 18388:   return NS_OK;
     1: }
     1: 
 14962: NS_IMETHODIMP
108991: nsDOMWindowUtils::SendNativeKeyEvent(int32_t aNativeKeyboardLayout,
108991:                                      int32_t aNativeKeyCode,
108991:                                      int32_t aModifiers,
 14962:                                      const nsAString& aCharacters,
 14962:                                      const nsAString& aUnmodifiedCharacters)
 14962: {
 39630:   if (!IsUniversalXPConnectCapable()) {
 14962:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
 14962: 
 14962:   // get the widget to send the event to
 14962:   nsCOMPtr<nsIWidget> widget = GetWidget();
 14962:   if (!widget)
 14962:     return NS_ERROR_FAILURE;
 14962: 
 14998:   return widget->SynthesizeNativeKeyEvent(aNativeKeyboardLayout, aNativeKeyCode,
 14962:                                           aModifiers, aCharacters, aUnmodifiedCharacters);
 14962: }
 14962: 
 15578: NS_IMETHODIMP
108991: nsDOMWindowUtils::SendNativeMouseEvent(int32_t aScreenX,
108991:                                        int32_t aScreenY,
108991:                                        int32_t aNativeMessage,
108991:                                        int32_t aModifierFlags,
 32976:                                        nsIDOMElement* aElement)
 32976: {
 39630:   if (!IsUniversalXPConnectCapable()) {
 32976:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
 32976: 
 32976:   // get the widget to send the event to
 32976:   nsCOMPtr<nsIWidget> widget = GetWidgetForElement(aElement);
 32976:   if (!widget)
 32976:     return NS_ERROR_FAILURE;
 32976: 
 32976:   return widget->SynthesizeNativeMouseEvent(nsIntPoint(aScreenX, aScreenY),
 32976:                                             aNativeMessage, aModifierFlags);
 32976: }
 32976: 
 32976: NS_IMETHODIMP
108991: nsDOMWindowUtils::SendNativeMouseScrollEvent(int32_t aScreenX,
108991:                                              int32_t aScreenY,
108991:                                              uint32_t aNativeMessage,
 93734:                                              double aDeltaX,
 93734:                                              double aDeltaY,
 93734:                                              double aDeltaZ,
108991:                                              uint32_t aModifierFlags,
108991:                                              uint32_t aAdditionalFlags,
 93734:                                              nsIDOMElement* aElement)
 93734: {
 93734:   if (!IsUniversalXPConnectCapable()) {
 93734:     return NS_ERROR_DOM_SECURITY_ERR;
 93734:   }
 93734: 
 93734:   // get the widget to send the event to
 93734:   nsCOMPtr<nsIWidget> widget = GetWidgetForElement(aElement);
 93734:   if (!widget) {
 93734:     return NS_ERROR_FAILURE;
 93734:   }
 93734: 
 93734:   return widget->SynthesizeNativeMouseScrollEvent(nsIntPoint(aScreenX,
 93734:                                                              aScreenY),
 93734:                                                   aNativeMessage,
 93734:                                                   aDeltaX, aDeltaY, aDeltaZ,
 93734:                                                   aModifierFlags,
 93734:                                                   aAdditionalFlags);
 93734: }
 93734: 
 93734: NS_IMETHODIMP
 15578: nsDOMWindowUtils::ActivateNativeMenuItemAt(const nsAString& indexString)
 15578: {
 39630:   if (!IsUniversalXPConnectCapable()) {
 15578:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
 15578: 
 15578:   // get the widget to send the event to
 15578:   nsCOMPtr<nsIWidget> widget = GetWidget();
 15578:   if (!widget)
 15578:     return NS_ERROR_FAILURE;
 15578: 
 15578:   return widget->ActivateNativeMenuItemAt(indexString);
 15578: }
 15578: 
 16264: NS_IMETHODIMP
 21081: nsDOMWindowUtils::ForceUpdateNativeMenuAt(const nsAString& indexString)
 16264: {
 39630:   if (!IsUniversalXPConnectCapable()) {
 16264:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
 16264: 
 16264:   // get the widget to send the event to
 16264:   nsCOMPtr<nsIWidget> widget = GetWidget();
 16264:   if (!widget)
 16264:     return NS_ERROR_FAILURE;
 16264: 
 21081:   return widget->ForceUpdateNativeMenuAt(indexString);
 16264: }
 16264: 
     1: nsIWidget*
 21967: nsDOMWindowUtils::GetWidget(nsPoint* aOffset)
     1: {
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   if (window) {
 94546:     nsIDocShell *docShell = window->GetDocShell();
     1:     if (docShell) {
     1:       nsCOMPtr<nsIPresShell> presShell;
     1:       docShell->GetPresShell(getter_AddRefs(presShell));
     1:       if (presShell) {
     1:         nsIFrame* frame = presShell->GetRootFrame();
     1:         if (frame)
 21967:           return frame->GetView()->GetNearestWidget(aOffset);
     1:       }
     1:     }
     1:   }
     1: 
106838:   return nullptr;
     1: }
  3416: 
 32976: nsIWidget*
 32976: nsDOMWindowUtils::GetWidgetForElement(nsIDOMElement* aElement)
 32976: {
 32976:   if (!aElement)
 32976:     return GetWidget();
 32976: 
 32976:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
 32976:   nsIDocument* doc = content->GetCurrentDoc();
106838:   nsIPresShell* presShell = doc ? doc->GetShell() : nullptr;
 32976: 
 32976:   if (presShell) {
 36657:     nsIFrame* frame = content->GetPrimaryFrame();
 32976:     if (!frame) {
 32976:       frame = presShell->GetRootFrame();
 32976:     }
 32976:     if (frame)
 47148:       return frame->GetNearestWidget();
 32976:   }
 32976: 
106838:   return nullptr;
 32976: }
 32976: 
  3416: NS_IMETHODIMP
  3416: nsDOMWindowUtils::Focus(nsIDOMElement* aElement)
  3416: {
 39630:   if (!IsUniversalXPConnectCapable()) {
  6799:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
  6799: 
 94546:   nsCOMPtr<nsIDOMWindow> window = do_QueryReferent(mWindow);
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (fm) {
 29018:     if (aElement)
 29018:       fm->SetFocus(aElement, 0);
 29018:     else
 94546:       fm->ClearFocus(window);
  3416:   }
  3416: 
  3416:   return NS_OK;
  3416: }
  3416: 
  7057: NS_IMETHODIMP
 88519: nsDOMWindowUtils::GarbageCollect(nsICycleCollectorListener *aListener,
108991:                                  int32_t aExtraForgetSkippableCalls)
  7057: {
 84290:   SAMPLE_LABEL("GC", "GarbageCollect");
 48507:   // Always permit this in debug builds.
  7057: #ifndef DEBUG
 39630:   if (!IsUniversalXPConnectCapable()) {
  7057:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
  7057: #endif
  7057: 
103363:   nsJSContext::GarbageCollectNow(js::gcreason::DOM_UTILS);
 88519:   nsJSContext::CycleCollectNow(aListener, aExtraForgetSkippableCalls);
  7057: 
  7057:   return NS_OK;
  7057: }
 18474: 
 74347: NS_IMETHODIMP
 88519: nsDOMWindowUtils::CycleCollect(nsICycleCollectorListener *aListener,
108991:                                int32_t aExtraForgetSkippableCalls)
 74347: {
 74347:   // Always permit this in debug builds.
 74347: #ifndef DEBUG
 74347:   if (!IsUniversalXPConnectCapable()) {
 74347:     return NS_ERROR_DOM_SECURITY_ERR;
 74347:   }
 74347: #endif
 74347: 
 88519:   nsJSContext::CycleCollectNow(aListener, aExtraForgetSkippableCalls);
 74347:   return NS_OK;
 74347: }
 18474: 
 18474: NS_IMETHODIMP
 20793: nsDOMWindowUtils::SendSimpleGestureEvent(const nsAString& aType,
 23284:                                          float aX,
 23284:                                          float aY,
108991:                                          uint32_t aDirection,
107847:                                          double aDelta,
108991:                                          int32_t aModifiers,
108991:                                          uint32_t aClickCount)
 20793: {
 39630:   if (!IsUniversalXPConnectCapable()) {
 20793:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
 20793: 
 20793:   // get the widget to send the event to
 23284:   nsPoint offset;
 23284:   nsCOMPtr<nsIWidget> widget = GetWidget(&offset);
 20793:   if (!widget)
 20793:     return NS_ERROR_FAILURE;
 20793: 
108991:   int32_t msg;
 20793:   if (aType.EqualsLiteral("MozSwipeGesture"))
 20793:     msg = NS_SIMPLE_GESTURE_SWIPE;
 20793:   else if (aType.EqualsLiteral("MozMagnifyGestureStart"))
 20793:     msg = NS_SIMPLE_GESTURE_MAGNIFY_START;
 20793:   else if (aType.EqualsLiteral("MozMagnifyGestureUpdate"))
 20793:     msg = NS_SIMPLE_GESTURE_MAGNIFY_UPDATE;
 20793:   else if (aType.EqualsLiteral("MozMagnifyGesture"))
 20793:     msg = NS_SIMPLE_GESTURE_MAGNIFY;
 20793:   else if (aType.EqualsLiteral("MozRotateGestureStart"))
 20793:     msg = NS_SIMPLE_GESTURE_ROTATE_START;
 20793:   else if (aType.EqualsLiteral("MozRotateGestureUpdate"))
 20793:     msg = NS_SIMPLE_GESTURE_ROTATE_UPDATE;
 20793:   else if (aType.EqualsLiteral("MozRotateGesture"))
 20793:     msg = NS_SIMPLE_GESTURE_ROTATE;
 26874:   else if (aType.EqualsLiteral("MozTapGesture"))
 26874:     msg = NS_SIMPLE_GESTURE_TAP;
 26874:   else if (aType.EqualsLiteral("MozPressTapGesture"))
 26874:     msg = NS_SIMPLE_GESTURE_PRESSTAP;
101997:   else if (aType.EqualsLiteral("MozEdgeUIGesture"))
101997:     msg = NS_SIMPLE_GESTURE_EDGEUI;
 20793:   else
 20793:     return NS_ERROR_FAILURE;
 20793:  
 80486:   nsSimpleGestureEvent event(true, msg, widget, aDirection, aDelta);
 96894:   event.modifiers = GetWidgetModifiers(aModifiers);
101997:   event.clickCount = aClickCount;
 20793:   event.time = PR_IntervalNow();
 20793: 
 47902:   nsPresContext* presContext = GetPresContext();
 47902:   if (!presContext)
 47902:     return NS_ERROR_FAILURE;
 47902: 
 98205:   event.refPoint = ToWidgetPoint(aX, aY, offset, presContext);
 23284: 
 20793:   nsEventStatus status;
 20793:   return widget->DispatchEvent(&event, status);
 20793: }
 21333: 
 21333: NS_IMETHODIMP
 40200: nsDOMWindowUtils::ElementFromPoint(float aX, float aY,
 79445:                                    bool aIgnoreRootScrollFrame,
 79445:                                    bool aFlushLayout,
 21333:                                    nsIDOMElement** aReturn)
 21333: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
 94546:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
 21333:   NS_ENSURE_STATE(doc);
 21333: 
 21333:   return doc->ElementFromPointHelper(aX, aY, aIgnoreRootScrollFrame, aFlushLayout,
 21333:                                      aReturn);
 21333: }
 22197: 
 40568: NS_IMETHODIMP
 40568: nsDOMWindowUtils::NodesFromRect(float aX, float aY,
 40568:                                 float aTopSize, float aRightSize,
 40568:                                 float aBottomSize, float aLeftSize,
 79445:                                 bool aIgnoreRootScrollFrame,
 79445:                                 bool aFlushLayout,
 40568:                                 nsIDOMNodeList** aReturn)
 40568: {
 88444:   if (!IsUniversalXPConnectCapable()) {
 88444:     return NS_ERROR_DOM_SECURITY_ERR;
 88444:   }
 88444: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
 94546:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
 40568:   NS_ENSURE_STATE(doc);
 40568: 
 40568:   return doc->NodesFromRectHelper(aX, aY, aTopSize, aRightSize, aBottomSize, aLeftSize, 
 40568:                                   aIgnoreRootScrollFrame, aFlushLayout, aReturn);
 40568: }
 40568: 
 22197: static already_AddRefed<gfxImageSurface>
 83345: CanvasToImageSurface(nsIDOMHTMLCanvasElement* aCanvas)
 22197: {
 83345:   nsCOMPtr<nsINode> node = do_QueryInterface(aCanvas);
 83345:   if (!node) {
106838:     return nullptr;
 83345:   }
 83345: 
 83345:   NS_ABORT_IF_FALSE(node->IsElement(),
 83345:                     "An nsINode that implements nsIDOMHTMLCanvasElement should "
 83345:                     "be an element.");
 38650:   nsLayoutUtils::SurfaceFromElementResult result =
 83345:     nsLayoutUtils::SurfaceFromElement(node->AsElement(),
 38650:                                       nsLayoutUtils::SFE_WANT_IMAGE_SURFACE);
 38650:   return static_cast<gfxImageSurface*>(result.mSurface.forget().get());
 22197: }
 22197: 
 22197: NS_IMETHODIMP
 22197: nsDOMWindowUtils::CompareCanvases(nsIDOMHTMLCanvasElement *aCanvas1,
 22197:                                   nsIDOMHTMLCanvasElement *aCanvas2,
108991:                                   uint32_t* aMaxDifference,
108991:                                   uint32_t* retVal)
 22197: {
 39630:   if (!IsUniversalXPConnectCapable()) {
 22197:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
 22197: 
106838:   if (aCanvas1 == nullptr ||
106838:       aCanvas2 == nullptr ||
106838:       retVal == nullptr)
 22197:     return NS_ERROR_FAILURE;
 22197: 
 22197:   nsRefPtr<gfxImageSurface> img1 = CanvasToImageSurface(aCanvas1);
 22197:   nsRefPtr<gfxImageSurface> img2 = CanvasToImageSurface(aCanvas2);
 22197: 
106838:   if (img1 == nullptr || img2 == nullptr ||
 22197:       img1->GetSize() != img2->GetSize() ||
 22197:       img1->Stride() != img2->Stride())
 22197:     return NS_ERROR_FAILURE;
 22197: 
 22197:   int v;
 22197:   gfxIntSize size = img1->GetSize();
108991:   uint32_t stride = img1->Stride();
 22197: 
 22197:   // we can optimize for the common all-pass case
108991:   if (stride == (uint32_t) size.width * 4) {
 22197:     v = memcmp(img1->Data(), img2->Data(), size.width * size.height * 4);
 22197:     if (v == 0) {
 22197:       if (aMaxDifference)
 22197:         *aMaxDifference = 0;
 22197:       *retVal = 0;
 22197:       return NS_OK;
 22197:     }
 22197:   }
 22197: 
108991:   uint32_t dc = 0;
108991:   uint32_t different = 0;
 22197: 
 22197:   for (int j = 0; j < size.height; j++) {
 22197:     unsigned char *p1 = img1->Data() + j*stride;
 22197:     unsigned char *p2 = img2->Data() + j*stride;
 22197:     v = memcmp(p1, p2, stride);
 22197: 
 22197:     if (v) {
 22197:       for (int i = 0; i < size.width; i++) {
108991:         if (*(uint32_t*) p1 != *(uint32_t*) p2) {
 22197: 
 22197:           different++;
 22197: 
108991:           dc = NS_MAX((uint32_t)abs(p1[0] - p2[0]), dc);
108991:           dc = NS_MAX((uint32_t)abs(p1[1] - p2[1]), dc);
108991:           dc = NS_MAX((uint32_t)abs(p1[2] - p2[2]), dc);
108991:           dc = NS_MAX((uint32_t)abs(p1[3] - p2[3]), dc);
 22197:         }
 22197: 
 22197:         p1 += 4;
 22197:         p2 += 4;
 22197:       }
 22197:     }
 22197:   }
 22197: 
 22197:   if (aMaxDifference)
 22197:     *aMaxDifference = dc;
 22197: 
 22197:   *retVal = different;
 22197:   return NS_OK;
 22197: }
 23350: 
 23350: NS_IMETHODIMP
 79445: nsDOMWindowUtils::GetIsMozAfterPaintPending(bool *aResult)
 23350: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
111600:   NS_ENSURE_ARG_POINTER(aResult);
 80486:   *aResult = false;
 23350:   nsPresContext* presContext = GetPresContext();
 23350:   if (!presContext)
 23350:     return NS_OK;
 23350:   *aResult = presContext->IsDOMPaintEventPending();
 23350:   return NS_OK;
 23350: }
 24947: 
 24947: NS_IMETHODIMP
 25579: nsDOMWindowUtils::ClearMozAfterPaintEvents()
 25579: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 25579:   nsPresContext* presContext = GetPresContext();
 25579:   if (!presContext)
 25579:     return NS_OK;
 25579:   presContext->ClearMozAfterPaintEvents();
 25579:   return NS_OK;
 25579: }
 25579: 
 25579: NS_IMETHODIMP
 79445: nsDOMWindowUtils::DisableNonTestMouseEvents(bool aDisable)
 24947: {
 39630:   if (!IsUniversalXPConnectCapable()) {
 24947:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
 24947: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 94546:   nsIDocShell *docShell = window->GetDocShell();
 24947:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
 24947:   nsCOMPtr<nsIPresShell> presShell;
 24947:   docShell->GetPresShell(getter_AddRefs(presShell));
 24947:   NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
 40052:   presShell->DisableNonTestMouseEvents(aDisable);
 40052:   return NS_OK;
 24947: }
 25722: 
 25722: NS_IMETHODIMP
 79445: nsDOMWindowUtils::SuppressEventHandling(bool aSuppress)
 25722: {
 39630:   if (!IsUniversalXPConnectCapable()) {
 25722:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
 25722: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
 94546:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
 25722:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
 25722: 
 25722:   if (aSuppress) {
 25722:     doc->SuppressEventHandling();
 25722:   } else {
 80486:     doc->UnsuppressEventHandlingAndFireEvents(true);
 25722:   }
 26714: 
 25722:   return NS_OK;
 25722: }
 25722: 
 26714: NS_IMETHODIMP
108991: nsDOMWindowUtils::GetScrollXY(bool aFlushLayout, int32_t* aScrollX, int32_t* aScrollY)
 26714: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
 94546:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
 26714:   NS_ENSURE_STATE(doc);
 26714: 
 26714:   if (aFlushLayout) {
 26714:     doc->FlushPendingNotifications(Flush_Layout);
 26714:   }
 26714: 
 37063:   nsPoint scrollPos(0,0);
 46225:   nsIPresShell *presShell = doc->GetShell();
 26714:   if (presShell) {
 37063:     nsIScrollableFrame* sf = presShell->GetRootScrollFrameAsScrollable();
 37063:     if (sf) {
 37063:       scrollPos = sf->GetScrollPosition();
 26714:     }
 26714:   }
 26714: 
 37063:   *aScrollX = nsPresContext::AppUnitsToIntCSSPixels(scrollPos.x);
 37063:   *aScrollY = nsPresContext::AppUnitsToIntCSSPixels(scrollPos.y);
 26714: 
 26714:   return NS_OK;
 26714: }
 27984: 
 27984: NS_IMETHODIMP
 99280: nsDOMWindowUtils::GetRootBounds(nsIDOMClientRect** aResult)
 99280: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 99280:   // Weak ref, since we addref it below
 99280:   nsClientRect* rect = new nsClientRect();
 99280:   NS_ADDREF(*aResult = rect);
 99280: 
 99280:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 99280:   NS_ENSURE_STATE(window);
 99280: 
 99280:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
 99280:   NS_ENSURE_STATE(doc);
 99280: 
 99280:   nsRect bounds(0, 0, 0, 0);
 99280:   nsIPresShell* presShell = doc->GetShell();
 99280:   if (presShell) {
 99280:     nsIScrollableFrame* sf = presShell->GetRootScrollFrameAsScrollable();
 99280:     if (sf) {
 99280:       bounds = sf->GetScrollRange();
 99280:       bounds.width += sf->GetScrollPortRect().width;
 99280:       bounds.height += sf->GetScrollPortRect().height;
 99280:     } else if (presShell->GetRootFrame()) {
 99280:       bounds = presShell->GetRootFrame()->GetRect();
 99280:     }
 99280:   }
 99280: 
 99280:   rect->SetRect(nsPresContext::AppUnitsToFloatCSSPixels(bounds.x),
 99280:                 nsPresContext::AppUnitsToFloatCSSPixels(bounds.y),
 99280:                 nsPresContext::AppUnitsToFloatCSSPixels(bounds.width),
 99280:                 nsPresContext::AppUnitsToFloatCSSPixels(bounds.height));
 99280:   return NS_OK;
 99280: }
 99280: 
 99280: NS_IMETHODIMP
 79445: nsDOMWindowUtils::GetIMEIsOpen(bool *aState)
 27984: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 27984:   NS_ENSURE_ARG_POINTER(aState);
 27984: 
 27984:   nsCOMPtr<nsIWidget> widget = GetWidget();
 27984:   if (!widget)
 27984:     return NS_ERROR_FAILURE;
 27984: 
 27984:   // Open state should not be available when IME is not enabled.
 82841:   InputContext context = widget->GetInputContext();
 82842:   if (context.mIMEState.mEnabled != IMEState::ENABLED) {
 27984:     return NS_ERROR_NOT_AVAILABLE;
 82840:   }
 27984: 
 82842:   if (context.mIMEState.mOpen == IMEState::OPEN_STATE_NOT_SUPPORTED) {
 82842:     return NS_ERROR_NOT_IMPLEMENTED;
 82842:   }
 82842:   *aState = (context.mIMEState.mOpen == IMEState::OPEN);
 82842:   return NS_OK;
 27984: }
 27984: 
 27984: NS_IMETHODIMP
108991: nsDOMWindowUtils::GetIMEStatus(uint32_t *aState)
 27984: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 27984:   NS_ENSURE_ARG_POINTER(aState);
 27984: 
 27984:   nsCOMPtr<nsIWidget> widget = GetWidget();
 27984:   if (!widget)
 27984:     return NS_ERROR_FAILURE;
 27984: 
 82841:   InputContext context = widget->GetInputContext();
108991:   *aState = static_cast<uint32_t>(context.mIMEState.mEnabled);
 58019:   return NS_OK;
 58019: }
 58019: 
 58019: NS_IMETHODIMP
 58019: nsDOMWindowUtils::GetFocusedInputType(char** aType)
 58019: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 58019:   NS_ENSURE_ARG_POINTER(aType);
 58019: 
 58019:   nsCOMPtr<nsIWidget> widget = GetWidget();
 58019:   if (!widget) {
 58019:     return NS_ERROR_FAILURE;
 58019:   }
 58019: 
 82841:   InputContext context = widget->GetInputContext();
 58019:   *aType = ToNewCString(context.mHTMLInputType);
 58019:   return NS_OK;
 27984: }
 27984: 
 31084: NS_IMETHODIMP
 60450: nsDOMWindowUtils::FindElementWithViewId(nsViewID aID,
 60450:                                         nsIDOMElement** aResult)
 60450: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 60450:   if (aID == FrameMetrics::ROOT_SCROLL_ID) {
 60450:     nsPresContext* presContext = GetPresContext();
 61804:     if (!presContext) {
 61804:       return NS_ERROR_NOT_AVAILABLE;
 61804:     }
 61804: 
 60450:     nsIDocument* document = presContext->Document();
 60451:     mozilla::dom::Element* rootElement = document->GetRootElement();
 60451:     if (!rootElement) {
 60451:       return NS_ERROR_NOT_AVAILABLE;
 60451:     }
 61804: 
 60451:     CallQueryInterface(rootElement, aResult);
 60450:     return NS_OK;
 60450:   }
 60450: 
 60450:   nsRefPtr<nsIContent> content = nsLayoutUtils::FindContentFor(aID);
 61804:   return content ? CallQueryInterface(content, aResult) : NS_OK;
 60450: }
 60450: 
 60450: NS_IMETHODIMP
 31084: nsDOMWindowUtils::GetScreenPixelsPerCSSPixel(float* aScreenPixels)
 31084: {
111472:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
111472:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
111472:   return window->GetDevicePixelRatio(aScreenPixels);
 31084: }
 33962: 
 33962: NS_IMETHODIMP
 34272: nsDOMWindowUtils::DispatchDOMEventViaPresShell(nsIDOMNode* aTarget,
 34272:                                                nsIDOMEvent* aEvent,
 79445:                                                bool aTrusted,
 79445:                                                bool* aRetVal)
 34272: {
 34272:   if (!nsContentUtils::IsCallerTrustedForRead()) {
 34272:     return NS_ERROR_DOM_SECURITY_ERR;
 34272:   }
 34272: 
 34272:   nsPresContext* presContext = GetPresContext();
 34272:   NS_ENSURE_STATE(presContext);
 34272:   nsCOMPtr<nsIPresShell> shell = presContext->GetPresShell();
 34272:   NS_ENSURE_STATE(shell);
101616:   NS_ENSURE_STATE(aEvent);
101616:   aEvent->SetTrusted(aTrusted);
101616:   nsEvent* internalEvent = aEvent->GetInternalNSEvent();
 34272:   NS_ENSURE_STATE(internalEvent);
 34272:   nsCOMPtr<nsIContent> content = do_QueryInterface(aTarget);
 34272:   NS_ENSURE_STATE(content);
 34272: 
 34272:   nsEventStatus status = nsEventStatus_eIgnore;
106838:   shell->HandleEventWithTarget(internalEvent, nullptr, content,
 34272:                                &status);
 34272:   *aRetVal = (status != nsEventStatus_eConsumeNoDefault);
 34272:   return NS_OK;
 34272: }
 36577: 
 39629: static void
106838: InitEvent(nsGUIEvent &aEvent, nsIntPoint *aPt = nullptr)
 39629: {
 39629:   if (aPt) {
 39629:     aEvent.refPoint = *aPt;
 39629:   }
 39629:   aEvent.time = PR_IntervalNow();
 39629: }
 39629: 
 39629: NS_IMETHODIMP
 78627: nsDOMWindowUtils::SendCompositionEvent(const nsAString& aType,
 78627:                                        const nsAString& aData,
 78627:                                        const nsAString& aLocale)
 39629: {
 39629:   if (!IsUniversalXPConnectCapable()) {
 39629:     return NS_ERROR_DOM_SECURITY_ERR;
 39629:   }
 39629: 
 39629:   // get the widget to send the event to
 39629:   nsCOMPtr<nsIWidget> widget = GetWidget();
 39629:   if (!widget) {
 39629:     return NS_ERROR_FAILURE;
 39629:   }
 39629: 
108991:   uint32_t msg;
 39629:   if (aType.EqualsLiteral("compositionstart")) {
 39629:     msg = NS_COMPOSITION_START;
 39629:   } else if (aType.EqualsLiteral("compositionend")) {
 39629:     msg = NS_COMPOSITION_END;
 78627:   } else if (aType.EqualsLiteral("compositionupdate")) {
 78627:     msg = NS_COMPOSITION_UPDATE;
 39629:   } else {
 39629:     return NS_ERROR_FAILURE;
 39629:   }
 39629: 
 80486:   nsCompositionEvent compositionEvent(true, msg, widget);
 39629:   InitEvent(compositionEvent);
 78627:   if (msg != NS_COMPOSITION_START) {
 78627:     compositionEvent.data = aData;
 78627:   }
 39629: 
 39629:   nsEventStatus status;
 39629:   nsresult rv = widget->DispatchEvent(&compositionEvent, status);
 39629:   NS_ENSURE_SUCCESS(rv, rv);
 39629: 
 39629:   return NS_OK;
 39629: }
 39629: 
 39629: static void
108991: AppendClause(int32_t aClauseLength, uint32_t aClauseAttr,
 39629:              nsTArray<nsTextRange>* aRanges)
 39629: {
 39629:   NS_PRECONDITION(aRanges, "aRange is null");
 39629:   if (aClauseLength == 0) {
 39629:     return;
 39629:   }
 39629:   nsTextRange range;
 39629:   range.mStartOffset = aRanges->Length() == 0 ? 0 :
 39629:     aRanges->ElementAt(aRanges->Length() - 1).mEndOffset + 1;
 39629:   range.mEndOffset = range.mStartOffset + aClauseLength;
 39629:   NS_ASSERTION(range.mStartOffset <= range.mEndOffset, "range is invalid");
 39629:   NS_PRECONDITION(aClauseAttr == NS_TEXTRANGE_RAWINPUT ||
 39629:                   aClauseAttr == NS_TEXTRANGE_SELECTEDRAWTEXT ||
 39629:                   aClauseAttr == NS_TEXTRANGE_CONVERTEDTEXT ||
 39629:                   aClauseAttr == NS_TEXTRANGE_SELECTEDCONVERTEDTEXT,
 39629:                   "aClauseAttr is invalid value");
 39629:   range.mRangeType = aClauseAttr;
 39629:   aRanges->AppendElement(range);
 39629: }
 39629: 
 39629: NS_IMETHODIMP
 39629: nsDOMWindowUtils::SendTextEvent(const nsAString& aCompositionString,
108991:                                 int32_t aFirstClauseLength,
108991:                                 uint32_t aFirstClauseAttr,
108991:                                 int32_t aSecondClauseLength,
108991:                                 uint32_t aSecondClauseAttr,
108991:                                 int32_t aThirdClauseLength,
108991:                                 uint32_t aThirdClauseAttr,
108991:                                 int32_t aCaretStart,
108991:                                 int32_t aCaretLength)
 39629: {
 39629:   if (!IsUniversalXPConnectCapable()) {
 39629:     return NS_ERROR_DOM_SECURITY_ERR;
 39629:   }
 39629: 
 39629:   // get the widget to send the event to
 39629:   nsCOMPtr<nsIWidget> widget = GetWidget();
 39629:   if (!widget) {
 39629:     return NS_ERROR_FAILURE;
 39629:   }
 39629: 
 80486:   nsTextEvent textEvent(true, NS_TEXT_TEXT, widget);
 39629:   InitEvent(textEvent);
 39629: 
 39629:   nsAutoTArray<nsTextRange, 4> textRanges;
 39629:   NS_ENSURE_TRUE(aFirstClauseLength >= 0,  NS_ERROR_INVALID_ARG);
 39629:   NS_ENSURE_TRUE(aSecondClauseLength >= 0, NS_ERROR_INVALID_ARG);
 39629:   NS_ENSURE_TRUE(aThirdClauseLength >= 0,  NS_ERROR_INVALID_ARG);
 39629:   AppendClause(aFirstClauseLength,  aFirstClauseAttr, &textRanges);
 39629:   AppendClause(aSecondClauseLength, aSecondClauseAttr, &textRanges);
 39629:   AppendClause(aThirdClauseLength,  aThirdClauseAttr, &textRanges);
108991:   int32_t len = aFirstClauseLength + aSecondClauseLength + aThirdClauseLength;
108991:   NS_ENSURE_TRUE(len == 0 || uint32_t(len) == aCompositionString.Length(),
 39629:                  NS_ERROR_FAILURE);
 39629: 
 39629:   if (aCaretStart >= 0) {
 39629:     nsTextRange range;
 39629:     range.mStartOffset = aCaretStart;
 39629:     range.mEndOffset = range.mStartOffset + aCaretLength;
 39629:     range.mRangeType = NS_TEXTRANGE_CARETPOSITION;
 39629:     textRanges.AppendElement(range);
 39629:   }
 39629: 
 39629:   textEvent.theText = aCompositionString;
 39629: 
 39629:   textEvent.rangeCount = textRanges.Length();
 39629:   textEvent.rangeArray = textRanges.Elements();
 39629: 
 39629:   nsEventStatus status;
 39629:   nsresult rv = widget->DispatchEvent(&textEvent, status);
 39629:   NS_ENSURE_SUCCESS(rv, rv);
 39629: 
 39629:   return NS_OK;
 39629: }
 39629: 
 39629: NS_IMETHODIMP
108991: nsDOMWindowUtils::SendQueryContentEvent(uint32_t aType,
108991:                                         uint32_t aOffset, uint32_t aLength,
108991:                                         int32_t aX, int32_t aY,
 39629:                                         nsIQueryContentEventResult **aResult)
 39629: {
106838:   *aResult = nullptr;
 39629: 
 39629:   if (!IsUniversalXPConnectCapable()) {
 39629:     return NS_ERROR_DOM_SECURITY_ERR;
 39629:   }
 39629: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 48255: 
 94546:   nsIDocShell *docShell = window->GetDocShell();
 48255:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
 48255: 
 48255:   nsCOMPtr<nsIPresShell> presShell;
 48255:   docShell->GetPresShell(getter_AddRefs(presShell));
 48255:   NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
 48255: 
 48255:   nsPresContext* presContext = presShell->GetPresContext();
 48255:   NS_ENSURE_TRUE(presContext, NS_ERROR_FAILURE);
 48255: 
 39629:   // get the widget to send the event to
 39629:   nsCOMPtr<nsIWidget> widget = GetWidget();
 39629:   if (!widget) {
 39629:     return NS_ERROR_FAILURE;
 39629:   }
 39629: 
 39629:   if (aType != NS_QUERY_SELECTED_TEXT &&
 39629:       aType != NS_QUERY_TEXT_CONTENT &&
 39629:       aType != NS_QUERY_CARET_RECT &&
 39629:       aType != NS_QUERY_TEXT_RECT &&
 39629:       aType != NS_QUERY_EDITOR_RECT &&
 39629:       aType != NS_QUERY_CHARACTER_AT_POINT) {
 39629:     return NS_ERROR_INVALID_ARG;
 39629:   }
 39629: 
 39629:   nsCOMPtr<nsIWidget> targetWidget = widget;
 39629:   nsIntPoint pt(aX, aY);
 39629: 
 39629:   if (aType == QUERY_CHARACTER_AT_POINT) {
 39629:     // Looking for the widget at the point.
 80486:     nsQueryContentEvent dummyEvent(true, NS_QUERY_CONTENT_STATE, widget);
 39629:     InitEvent(dummyEvent, &pt);
 39629:     nsIFrame* popupFrame =
 48255:       nsLayoutUtils::GetPopupFrameForEventCoordinates(presContext->GetRootPresContext(), &dummyEvent);
 39629: 
 39629:     nsIntRect widgetBounds;
 39629:     nsresult rv = widget->GetClientBounds(widgetBounds);
 40682:     NS_ENSURE_SUCCESS(rv, rv);
 83107:     widgetBounds.MoveTo(0, 0);
 39629: 
 39629:     // There is no popup frame at the point and the point isn't in our widget,
 39629:     // we cannot process this request.
 39629:     NS_ENSURE_TRUE(popupFrame || widgetBounds.Contains(pt),
 39629:                    NS_ERROR_FAILURE);
 39629: 
 39629:     // Fire the event on the widget at the point
 39629:     if (popupFrame) {
 47148:       targetWidget = popupFrame->GetNearestWidget();
 39629:     }
 39629:   }
 39629: 
 39629:   pt += widget->WidgetToScreenOffset() - targetWidget->WidgetToScreenOffset();
 39629: 
 80486:   nsQueryContentEvent queryEvent(true, aType, targetWidget);
 39629:   InitEvent(queryEvent, &pt);
 39629: 
 39629:   switch (aType) {
 39629:     case NS_QUERY_TEXT_CONTENT:
 39629:       queryEvent.InitForQueryTextContent(aOffset, aLength);
 39629:       break;
 39629:     case NS_QUERY_CARET_RECT:
 39629:       queryEvent.InitForQueryCaretRect(aOffset);
 39629:       break;
 39629:     case NS_QUERY_TEXT_RECT:
 39629:       queryEvent.InitForQueryTextRect(aOffset, aLength);
 39629:       break;
 39629:   }
 39629: 
 39629:   nsEventStatus status;
 39629:   nsresult rv = targetWidget->DispatchEvent(&queryEvent, status);
 39629:   NS_ENSURE_SUCCESS(rv, rv);
 39629: 
 39629:   nsQueryContentEventResult* result = new nsQueryContentEventResult();
 39629:   NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
 39629:   result->SetEventResult(widget, queryEvent);
 39629:   NS_ADDREF(*aResult = result);
 39629:   return NS_OK;
 39629: }
 39629: 
 39629: NS_IMETHODIMP
108991: nsDOMWindowUtils::SendSelectionSetEvent(uint32_t aOffset,
108991:                                         uint32_t aLength,
 79445:                                         bool aReverse,
 79445:                                         bool *aResult)
 39629: {
 80486:   *aResult = false;
 39629: 
 39629:   if (!IsUniversalXPConnectCapable()) {
 39629:     return NS_ERROR_DOM_SECURITY_ERR;
 39629:   }
 39629: 
 39629:   // get the widget to send the event to
 39629:   nsCOMPtr<nsIWidget> widget = GetWidget();
 39629:   if (!widget) {
 39629:     return NS_ERROR_FAILURE;
 39629:   }
 39629: 
 80486:   nsSelectionEvent selectionEvent(true, NS_SELECTION_SET, widget);
 39629:   InitEvent(selectionEvent);
 39629: 
 39629:   selectionEvent.mOffset = aOffset;
 39629:   selectionEvent.mLength = aLength;
 39629:   selectionEvent.mReversed = aReverse;
 39629: 
 39629:   nsEventStatus status;
 39629:   nsresult rv = widget->DispatchEvent(&selectionEvent, status);
 39629:   NS_ENSURE_SUCCESS(rv, rv);
 39629: 
 39629:   *aResult = selectionEvent.mSucceeded;
 39629:   return NS_OK;
 39629: }
 39629: 
 36577: NS_IMETHODIMP
 36983: nsDOMWindowUtils::SendContentCommandEvent(const nsAString& aType,
 36983:                                           nsITransferable * aTransferable)
 36983: {
 39630:   if (!IsUniversalXPConnectCapable()) {
 36983:     return NS_ERROR_DOM_SECURITY_ERR;
 39630:   }
 36983: 
 36983:   // get the widget to send the event to
 36983:   nsCOMPtr<nsIWidget> widget = GetWidget();
 36983:   if (!widget)
 36983:     return NS_ERROR_FAILURE;
 36983: 
108991:   int32_t msg;
 36983:   if (aType.EqualsLiteral("cut"))
 36983:     msg = NS_CONTENT_COMMAND_CUT;
 36983:   else if (aType.EqualsLiteral("copy"))
 36983:     msg = NS_CONTENT_COMMAND_COPY;
 36983:   else if (aType.EqualsLiteral("paste"))
 36983:     msg = NS_CONTENT_COMMAND_PASTE;
 36983:   else if (aType.EqualsLiteral("delete"))
 36983:     msg = NS_CONTENT_COMMAND_DELETE;
 36983:   else if (aType.EqualsLiteral("undo"))
 36983:     msg = NS_CONTENT_COMMAND_UNDO;
 36983:   else if (aType.EqualsLiteral("redo"))
 36983:     msg = NS_CONTENT_COMMAND_REDO;
 36983:   else if (aType.EqualsLiteral("pasteTransferable"))
 36983:     msg = NS_CONTENT_COMMAND_PASTE_TRANSFERABLE;
 36983:   else
 36983:     return NS_ERROR_FAILURE;
 36983:  
 80486:   nsContentCommandEvent event(true, msg, widget);
 36983:   if (msg == NS_CONTENT_COMMAND_PASTE_TRANSFERABLE) {
 36983:     event.mTransferable = aTransferable;
 36983:   }
 36983: 
 36983:   nsEventStatus status;
 36983:   return widget->DispatchEvent(&event, status);
 36983: }
 36983: 
 36983: NS_IMETHODIMP
 83346: nsDOMWindowUtils::GetClassName(const JS::Value& aObject, JSContext* aCx, char** aName)
 36577: {
 36577:   if (!nsContentUtils::IsCallerTrustedForRead()) {
 36577:     return NS_ERROR_DOM_SECURITY_ERR;
 36577:   }
 36577: 
 83346:   // Our argument must be a non-null object.
 83346:   if (JSVAL_IS_PRIMITIVE(aObject)) {
 83346:     return NS_ERROR_XPC_BAD_CONVERT_JS;
 83346:   }
 36577: 
 89430:   *aName = NS_strdup(JS_GetClass(JSVAL_TO_OBJECT(aObject))->name);
 83346:   NS_ABORT_IF_FALSE(*aName, "NS_strdup should be infallible.");
 83346:   return NS_OK;
 36577: }
 40174: 
 40174: NS_IMETHODIMP
 40174: nsDOMWindowUtils::GetVisitedDependentComputedStyle(
 40174:                     nsIDOMElement *aElement, const nsAString& aPseudoElement,
 40174:                     const nsAString& aPropertyName, nsAString& aResult)
 40174: {
 40174:   aResult.Truncate();
 40174: 
 40174:   if (!IsUniversalXPConnectCapable()) {
 40174:     return NS_ERROR_DOM_SECURITY_ERR;
 40174:   }
 40174: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
 40174:   nsCOMPtr<nsIDOMCSSStyleDeclaration> decl;
 40174:   nsresult rv =
 94546:     window->GetComputedStyle(aElement, aPseudoElement, getter_AddRefs(decl));
 40174:   NS_ENSURE_SUCCESS(rv, rv);
 40174: 
 80486:   static_cast<nsComputedDOMStyle*>(decl.get())->SetExposeVisitedStyle(true);
 40174:   rv = decl->GetPropertyValue(aPropertyName, aResult);
 80486:   static_cast<nsComputedDOMStyle*>(decl.get())->SetExposeVisitedStyle(false);
 40174: 
 40174:   return rv;
 40174: }
 41968: 
 41968: NS_IMETHODIMP
 47268: nsDOMWindowUtils::EnterModalState()
 47268: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
 94546:   window->EnterModalState();
 47268:   return NS_OK;
 47268: }
 47268: 
 47268: NS_IMETHODIMP
 47268: nsDOMWindowUtils::LeaveModalState()
 47268: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
106838:   window->LeaveModalState(nullptr);
 61768:   return NS_OK;
 61768: }
 61768: 
 61768: NS_IMETHODIMP
 61768: nsDOMWindowUtils::EnterModalStateWithWindow(nsIDOMWindow **aWindow)
 61768: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
 94546:   *aWindow = window->EnterModalState();
 61768:   NS_IF_ADDREF(*aWindow);
 61768:   return NS_OK;
 61768: }
 61768: 
 61768: NS_IMETHODIMP
 61768: nsDOMWindowUtils::LeaveModalStateWithWindow(nsIDOMWindow *aWindow)
 61768: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
 94546:   window->LeaveModalState(aWindow);
 47268:   return NS_OK;
 47268: }
 47268: 
 47268: NS_IMETHODIMP
 79445: nsDOMWindowUtils::IsInModalState(bool *retval)
 47268: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
 94546:   *retval = static_cast<nsGlobalWindow*>(window.get())->IsInModalState();
 47268:   return NS_OK;
 47268: }
 47268: 
 47268: NS_IMETHODIMP
 82301: nsDOMWindowUtils::GetParent(const JS::Value& aObject,
 82301:                             JSContext* aCx,
 82301:                             JS::Value* aParent)
 41968: {
 41968:   if (!IsUniversalXPConnectCapable()) {
 41968:     return NS_ERROR_DOM_SECURITY_ERR;
 41968:   }
 41968: 
 82301:   // First argument must be an object.
 82301:   if (JSVAL_IS_PRIMITIVE(aObject)) {
 82301:     return NS_ERROR_XPC_BAD_CONVERT_JS;
 82301:   }
 41968: 
102586:   JS::Rooted<JSObject*> parent(aCx, JS_GetParent(JSVAL_TO_OBJECT(aObject)));
 82301:   *aParent = OBJECT_TO_JSVAL(parent);
 41973: 
 48622:   // Outerize if necessary.
 42728:   if (parent) {
 82301:     if (JSObjectOp outerize = js::GetObjectClass(parent)->ext.outerObject) {
102586:       *aParent = OBJECT_TO_JSVAL(outerize(aCx, parent));
 82301:     }
 41973:   }
 41973: 
 41968:   return NS_OK;
 41968: }
 41968: 
 42108: NS_IMETHODIMP
108991: nsDOMWindowUtils::GetOuterWindowID(uint64_t *aWindowID)
 42108: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
 94546:   NS_ASSERTION(window->IsOuterWindow(), "How did that happen?");
 94546:   *aWindowID = window->WindowID();
 42108:   return NS_OK;
 42108: }
 42108: 
 42108: NS_IMETHODIMP
108991: nsDOMWindowUtils::GetCurrentInnerWindowID(uint64_t *aWindowID)
 42108: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_TRUE(window, NS_ERROR_NOT_AVAILABLE);
 94546: 
 94546:   NS_ASSERTION(window->IsOuterWindow(), "How did that happen?");
 94546:   nsGlobalWindow* inner =
 94546:     static_cast<nsGlobalWindow*>(window.get())->GetCurrentInnerWindowInternal();
 42108:   if (!inner) {
 42108:     return NS_ERROR_NOT_AVAILABLE;
 42108:   }
 56273:   *aWindowID = inner->WindowID();
 42108:   return NS_OK;
 42108: }
 48101: 
 48101: NS_IMETHODIMP
 48101: nsDOMWindowUtils::SuspendTimeouts()
 48101: {
 48101:   if (!IsUniversalXPConnectCapable()) {
 48101:     return NS_ERROR_DOM_SECURITY_ERR;
 48101:   }
 48101: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 94546: 
 94546:   window->SuspendTimeouts();
 48101: 
 48101:   return NS_OK;
 48101: }
 48101: 
 48101: NS_IMETHODIMP
 48101: nsDOMWindowUtils::ResumeTimeouts()
 48101: {
 48101:   if (!IsUniversalXPConnectCapable()) {
 48101:     return NS_ERROR_DOM_SECURITY_ERR;
 48101:   }
 48101: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 94546: 
 94546:   window->ResumeTimeouts();
 48101: 
 48101:   return NS_OK;
 48101: }
 51975: 
 51975: NS_IMETHODIMP
 51975: nsDOMWindowUtils::GetLayerManagerType(nsAString& aType)
 51975: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 51975:   nsCOMPtr<nsIWidget> widget = GetWidget();
 51975:   if (!widget)
 51975:     return NS_ERROR_FAILURE;
 51975: 
 51975:   LayerManager *mgr = widget->GetLayerManager();
 51975:   if (!mgr)
 51975:     return NS_ERROR_FAILURE;
 51975: 
 51975:   mgr->GetBackendName(aType);
 51975: 
 51975:   return NS_OK;
 51975: }
 54230: 
 86724: NS_IMETHODIMP
 86724: nsDOMWindowUtils::StartFrameTimeRecording()
 86724: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 86724:   nsCOMPtr<nsIWidget> widget = GetWidget();
 86724:   if (!widget)
 86724:     return NS_ERROR_FAILURE;
 86724: 
 86724:   LayerManager *mgr = widget->GetLayerManager();
 86724:   if (!mgr)
 86724:     return NS_ERROR_FAILURE;
 86724: 
 86724:   mgr->StartFrameTimeRecording();
 86724: 
 86724:   return NS_OK;
 86724: }
 86724: 
 86724: NS_IMETHODIMP
108991: nsDOMWindowUtils::StopFrameTimeRecording(uint32_t *frameCount, float **frames)
 86724: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 86724:   NS_ENSURE_ARG_POINTER(frameCount);
 86724:   NS_ENSURE_ARG_POINTER(frames);
 86724: 
 86724:   nsCOMPtr<nsIWidget> widget = GetWidget();
 86724:   if (!widget)
 86724:     return NS_ERROR_FAILURE;
 86724: 
 86724:   LayerManager *mgr = widget->GetLayerManager();
 86724:   if (!mgr)
 86724:     return NS_ERROR_FAILURE;
 86724: 
 86724:   nsTArray<float> frameTimes = mgr->StopFrameTimeRecording();
 86724: 
106838:   *frames = nullptr;
 86724:   *frameCount = frameTimes.Length();
 86724: 
 86724:   if (*frameCount != 0) {
 86724:     *frames = (float*)nsMemory::Alloc(*frameCount * sizeof(float*));
 86724:     if (!*frames)
 86724:       return NS_ERROR_OUT_OF_MEMORY;
 86724: 
 86724:     /* copy over the frame times into the array we just allocated */
108991:     for (uint32_t i = 0; i < *frameCount; i++) {
 86724:       (*frames)[i] = frameTimes[i];
 86724:     }
 86724:   }
 86724: 
 86724:   return NS_OK;
 86724: }
 86724: 
 79445: static bool
 64094: ComputeAnimationValue(nsCSSProperty aProperty,
 64094:                       Element* aElement,
 56404:                       const nsAString& aInput,
 56404:                       nsStyleAnimation::Value& aOutput)
 56404: {
 56404: 
 64094:   if (!nsStyleAnimation::ComputeValue(aProperty, aElement, aInput,
 80486:                                       false, aOutput)) {
 80486:     return false;
 56404:   }
 56404: 
 56404:   // This matches TransExtractComputedValue in nsTransitionManager.cpp.
 56404:   if (aProperty == eCSSProperty_visibility) {
 56404:     NS_ABORT_IF_FALSE(aOutput.GetUnit() == nsStyleAnimation::eUnit_Enumerated,
 56404:                       "unexpected unit");
 56404:     aOutput.SetIntValue(aOutput.GetIntValue(),
 56404:                         nsStyleAnimation::eUnit_Visibility);
 56404:   }
 56404: 
 80486:   return true;
 56404: }
 56404: 
 56404: NS_IMETHODIMP
108991: nsDOMWindowUtils::AdvanceTimeAndRefresh(int64_t aMilliseconds)
 67983: {
 67983:   if (!IsUniversalXPConnectCapable()) {
 67983:     return NS_ERROR_DOM_SECURITY_ERR;
 67983:   }
 67983: 
 67983:   GetPresContext()->RefreshDriver()->AdvanceTimeAndRefresh(aMilliseconds);
 67983: 
 67983:   return NS_OK;
 67983: }
 67983: 
 67983: NS_IMETHODIMP
 67983: nsDOMWindowUtils::RestoreNormalRefresh()
 67983: {
 67983:   if (!IsUniversalXPConnectCapable()) {
 67983:     return NS_ERROR_DOM_SECURITY_ERR;
 67983:   }
 67983: 
 67983:   GetPresContext()->RefreshDriver()->RestoreNormalRefresh();
 67983: 
 67983:   return NS_OK;
 67983: }
 67983: 
 67983: NS_IMETHODIMP
 56404: nsDOMWindowUtils::ComputeAnimationDistance(nsIDOMElement* aElement,
 56404:                                            const nsAString& aProperty,
 56404:                                            const nsAString& aValue1,
 56404:                                            const nsAString& aValue2,
 56404:                                            double* aResult)
 56404: {
 56404:   if (!IsUniversalXPConnectCapable()) {
 56404:     return NS_ERROR_DOM_SECURITY_ERR;
 56404:   }
 56404: 
 56404:   nsresult rv;
 56404:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement, &rv);
 56404:   NS_ENSURE_SUCCESS(rv, rv);
 56404: 
 56404:   // Convert direction-dependent properties as appropriate, e.g.,
 56404:   // border-left to border-left-value.
104540:   nsCSSProperty property = nsCSSProps::LookupProperty(aProperty,
104540:                                                       nsCSSProps::eAny);
 56404:   if (property != eCSSProperty_UNKNOWN && nsCSSProps::IsShorthand(property)) {
 56404:     nsCSSProperty subprop0 = *nsCSSProps::SubpropertyEntryFor(property);
 56404:     if (nsCSSProps::PropHasFlags(subprop0, CSS_PROPERTY_REPORT_OTHER_NAME) &&
 56404:         nsCSSProps::OtherNameFor(subprop0) == property) {
 56404:       property = subprop0;
 56404:     } else {
 56404:       property = eCSSProperty_UNKNOWN;
 56404:     }
 56404:   }
 56404: 
 56404:   NS_ABORT_IF_FALSE(property == eCSSProperty_UNKNOWN ||
 56404:                     !nsCSSProps::IsShorthand(property),
 56404:                     "should not have shorthand");
 56404: 
 56404:   nsStyleAnimation::Value v1, v2;
 56404:   if (property == eCSSProperty_UNKNOWN ||
 64094:       !ComputeAnimationValue(property, content->AsElement(), aValue1, v1) ||
 64094:       !ComputeAnimationValue(property, content->AsElement(), aValue2, v2)) {
 56404:     return NS_ERROR_ILLEGAL_VALUE;
 56404:   }
 56404: 
 56404:   if (!nsStyleAnimation::ComputeDistance(property, v1, v2, *aResult)) {
 56404:     return NS_ERROR_FAILURE;
 56404:   }
 56404: 
 56404:   return NS_OK;
 56404: }
 56404: 
 54230: nsresult
 54230: nsDOMWindowUtils::RenderDocument(const nsRect& aRect,
108991:                                  uint32_t aFlags,
 54230:                                  nscolor aBackgroundColor,
 54230:                                  gfxContext* aThebesContext)
 54230: {
111600:     if (!IsUniversalXPConnectCapable()) {
111600:       return NS_ERROR_DOM_SECURITY_ERR;
111600:     }
111600: 
 94546:     nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:     NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 94546: 
 54230:     // Get DOM Document
 54230:     nsresult rv;
 54230:     nsCOMPtr<nsIDOMDocument> ddoc;
 94546:     rv = window->GetDocument(getter_AddRefs(ddoc));
 54230:     NS_ENSURE_SUCCESS(rv, rv);
 54230: 
 54230:     // Get Document
 54230:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(ddoc, &rv);
 54230:     NS_ENSURE_SUCCESS(rv, rv);
 54230: 
 54230:     // Get Primary Shell
 54230:     nsCOMPtr<nsIPresShell> presShell = doc->GetShell();
 54230:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
 54230: 
 54230:     // Render Document
 54230:     return presShell->RenderDocument(aRect, aFlags, aBackgroundColor, aThebesContext);
 54230: }
 54257: 
 54257: NS_IMETHODIMP 
108991: nsDOMWindowUtils::GetCursorType(int16_t *aCursor)
 54257: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 54257:   NS_ENSURE_ARG_POINTER(aCursor);
 54257: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);  
 94546: 
 79445:   bool isSameDoc = false;
 94546:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
 54257: 
 54257:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
 54257: 
 54257:   do {
 54257:     if (nsEventStateManager::sMouseOverDocument == doc.get()) {
 80486:       isSameDoc = true;
 54257:       break;
 54257:     }
 54257:   } while ((doc = doc->GetParentDocument()));
 54257: 
 54257:   if (!isSameDoc) {
 54257:     *aCursor = eCursor_none;
 54257:     return NS_OK;
 54257:   }
 54257: 
 54257:   nsCOMPtr<nsIWidget> widget = GetWidget();
 54257:   if (!widget)
 54257:     return NS_ERROR_FAILURE;
 54257: 
 54257:   // fetch cursor value from window's widget
 54257:   *aCursor = widget->GetCursor();
 54257: 
 54257:   return NS_OK;
 54257: }
 56274: 
 56274: NS_IMETHODIMP
 56331: nsDOMWindowUtils::GetDisplayDPI(float *aDPI)
 56331: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 56331:   nsCOMPtr<nsIWidget> widget = GetWidget();
 56331:   if (!widget)
 56331:     return NS_ERROR_FAILURE;
 56331: 
 56331:   *aDPI = widget->GetDPI();
 56331: 
 56331:   return NS_OK;
 56331: }
 56331: 
 56331: 
 56331: NS_IMETHODIMP
108991: nsDOMWindowUtils::GetOuterWindowWithId(uint64_t aWindowID,
 56274:                                        nsIDOMWindow** aWindow)
 56274: {
 56286:   if (!IsUniversalXPConnectCapable()) {
 56286:     return NS_ERROR_DOM_SECURITY_ERR;
 56286:   }
 56286: 
 56274:   *aWindow = nsGlobalWindow::GetOuterWindowWithId(aWindowID);
 56274:   NS_IF_ADDREF(*aWindow);
 56274:   return NS_OK;
 56274: }
 61838: 
 78955: NS_IMETHODIMP
 78955: nsDOMWindowUtils::WrapDOMFile(nsIFile *aFile,
111600:                               nsIDOMFile **aDOMFile)
111600: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
114893:   if (!aFile) {
114893:     return NS_ERROR_FAILURE;
114893:   }
114893: 
 78955:   NS_ADDREF(*aDOMFile = new nsDOMFileFile(aFile));
 78955:   return NS_OK;
 78955: }
 78955: 
 61838: #ifdef DEBUG
 79445: static bool
 61838: CheckLeafLayers(Layer* aLayer, const nsIntPoint& aOffset, nsIntRegion* aCoveredRegion)
 61838: {
 61838:   gfxMatrix transform;
 61838:   if (!aLayer->GetTransform().Is2D(&transform) ||
 61838:       transform.HasNonIntegerTranslation())
 80486:     return false;
 61838:   transform.NudgeToIntegers();
 61838:   nsIntPoint offset = aOffset + nsIntPoint(transform.x0, transform.y0);
 61838: 
 61838:   Layer* child = aLayer->GetFirstChild();
 61838:   if (child) {
 61838:     while (child) {
 61838:       if (!CheckLeafLayers(child, offset, aCoveredRegion))
 80486:         return false;
 61838:       child = child->GetNextSibling();
 61838:     }
 61838:   } else {
 61838:     nsIntRegion rgn = aLayer->GetVisibleRegion();
 61838:     rgn.MoveBy(offset);
 61838:     nsIntRegion tmp;
 61838:     tmp.And(rgn, *aCoveredRegion);
 61838:     if (!tmp.IsEmpty())
 80486:       return false;
 61838:     aCoveredRegion->Or(*aCoveredRegion, rgn);
 61838:   }
 61838: 
 80486:   return true;
 61838: }
 61838: #endif
 61838: 
 61838: NS_IMETHODIMP
 79445: nsDOMWindowUtils::LeafLayersPartitionWindow(bool* aResult)
 61838: {
 61838:   if (!IsUniversalXPConnectCapable()) {
 61838:     return NS_ERROR_DOM_SECURITY_ERR;
 61838:   }
 61838: 
 80486:   *aResult = true;
 61838: #ifdef DEBUG
 61838:   nsIWidget* widget = GetWidget();
 61838:   if (!widget)
 61838:     return NS_ERROR_FAILURE;
 61838:   LayerManager* manager = widget->GetLayerManager();
 61838:   if (!manager)
 61838:     return NS_ERROR_FAILURE;
 61838:   nsPresContext* presContext = GetPresContext();
 61838:   if (!presContext)
 61838:     return NS_ERROR_FAILURE;
 61838:   Layer* root = manager->GetRoot();
 61838:   if (!root)
 61838:     return NS_ERROR_FAILURE;
 61838: 
 61838:   nsIntPoint offset(0, 0);
 61838:   nsIntRegion coveredRegion;
 61838:   if (!CheckLeafLayers(root, offset, &coveredRegion)) {
 80486:     *aResult = false;
 61838:   }
 61838:   if (!coveredRegion.IsEqual(root->GetVisibleRegion())) {
 80486:     *aResult = false;
 61838:   }
 61838: #endif
 61838:   return NS_OK;
 61838: }
 68880: 
 68880: NS_IMETHODIMP
 79445: nsDOMWindowUtils::GetMayHaveTouchEventListeners(bool* aResult)
 68880: {
 68880:   if (!IsUniversalXPConnectCapable()) {
 68880:     return NS_ERROR_DOM_SECURITY_ERR;
 68880:   }
 68880: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 94546: 
 94546:   nsPIDOMWindow* innerWindow = window->GetCurrentInnerWindow();
 80486:   *aResult = innerWindow ? innerWindow->HasTouchEventListeners() : false;
 68880:   return NS_OK;
 68880: }
 68880: 
 80875: NS_IMETHODIMP
 80875: nsDOMWindowUtils::CheckAndClearPaintedState(nsIDOMElement* aElement, bool* aResult)
 80875: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 80875:   if (!aElement) {
 80875:     return NS_ERROR_INVALID_ARG;
 80875:   }
 80875: 
 80875:   nsresult rv;
 80875:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement, &rv);
 80875:   NS_ENSURE_SUCCESS(rv, rv);
 80875: 
 80875:   nsIFrame* frame = content->GetPrimaryFrame();
 80875: 
 80875:   if (!frame) {
 80875:     *aResult = false;
 80875:     return NS_OK;
 80875:   }
 80875: 
 80875:   *aResult = frame->CheckAndClearPaintedState();
 80875:   return NS_OK;
 80875: }
 80875: 
108233: NS_IMETHODIMP
108233: nsDOMWindowUtils::PreventFurtherDialogs()
108233: {
108233:   // Permanently disable further dialogs for this window.
108233: 
108233:   if (!IsUniversalXPConnectCapable()) {
108233:     return NS_ERROR_DOM_SECURITY_ERR;
108233:   }
108233: 
108233:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
108233:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
108233: 
108233:   static_cast<nsGlobalWindow*>(window.get())->PreventFurtherDialogs(true);
108233:   return NS_OK;
108233: }
108233: 
100151: static nsresult
100151: GetFileOrBlob(const nsAString& aName, const jsval& aBlobParts,
100151:               const jsval& aParameters, JSContext* aCx,
108991:               uint8_t aOptionalArgCount, nsISupports** aResult)
 84685: {
 84685:   if (!IsUniversalXPConnectCapable()) {
 84685:     return NS_ERROR_DOM_SECURITY_ERR;
 84685:   }
 84685: 
100151:   nsresult rv;
100151: 
100151:   nsCOMPtr<nsISupports> file;
100151: 
100151:   if (aName.IsVoid()) {
100151:     rv = nsDOMMultipartFile::NewBlob(getter_AddRefs(file));
100151:   }
100151:   else {
100151:     rv = nsDOMMultipartFile::NewFile(aName, getter_AddRefs(file));
100151:   }
100151:   NS_ENSURE_SUCCESS(rv, rv);
100151: 
100151:   nsCOMPtr<nsIJSNativeInitializer> initializer = do_QueryInterface(file);
100151:   NS_ASSERTION(initializer, "what?");
100151: 
100151:   jsval args[2] = { aBlobParts, aParameters };
100151: 
106838:   rv = initializer->Initialize(nullptr, aCx, nullptr, aOptionalArgCount, args);
100151:   NS_ENSURE_SUCCESS(rv, rv);
100151: 
100151:   file.forget(aResult);
100151:   return NS_OK;
100151: }
100151: 
100151: NS_IMETHODIMP
100151: nsDOMWindowUtils::GetFile(const nsAString& aName, const jsval& aBlobParts,
100151:                           const jsval& aParameters, JSContext* aCx,
108991:                           uint8_t aOptionalArgCount, nsIDOMFile** aResult)
100151: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
100151:   nsCOMPtr<nsISupports> file;
100151:   nsresult rv = GetFileOrBlob(aName, aBlobParts, aParameters, aCx,
100151:                               aOptionalArgCount, getter_AddRefs(file));
100151:   NS_ENSURE_SUCCESS(rv, rv);
100151: 
100151:   nsCOMPtr<nsIDOMFile> result = do_QueryInterface(file);
100151:   result.forget(aResult);
100151: 
100151:   return NS_OK;
100151: }
100151: 
100151: NS_IMETHODIMP
100151: nsDOMWindowUtils::GetBlob(const jsval& aBlobParts, const jsval& aParameters,
108991:                           JSContext* aCx, uint8_t aOptionalArgCount,
100151:                           nsIDOMBlob** aResult)
100151: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
100151:   nsCOMPtr<nsISupports> blob;
109323:   nsresult rv = GetFileOrBlob(NullString(), aBlobParts, aParameters, aCx,
100151:                               aOptionalArgCount, getter_AddRefs(blob));
100151:   NS_ENSURE_SUCCESS(rv, rv);
100151: 
100151:   nsCOMPtr<nsIDOMBlob> result = do_QueryInterface(blob);
100151:   result.forget(aResult);
100151: 
100151:   return NS_OK;
100151: }
100151: 
100151: NS_IMETHODIMP
100151: nsDOMWindowUtils::GetFileId(const jsval& aFile, JSContext* aCx,
108991:                             int64_t* aResult)
100151: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
100151: 
100151:   if (!JSVAL_IS_PRIMITIVE(aFile)) {
100151:     JSObject* obj = JSVAL_TO_OBJECT(aFile);
100151: 
100151:     nsISupports* nativeObj =
100151:       nsContentUtils::XPConnect()->GetNativeOfWrapper(aCx, obj);
100151: 
100151:     nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(nativeObj);
100151:     if (blob) {
100151:       *aResult = blob->GetFileId();
100151:       return NS_OK;
100151:     }
100151: 
100151:     nsCOMPtr<nsIDOMFileHandle> fileHandle = do_QueryInterface(nativeObj);
100151:     if (fileHandle) {
100151:       *aResult = fileHandle->GetFileId();
100151:       return NS_OK;
100151:     }
100151:   }
100151: 
100151:   *aResult = -1;
 84685:   return NS_OK;
 84685: }
 84685: 
 84685: NS_IMETHODIMP
 84685: nsDOMWindowUtils::GetFileReferences(const nsAString& aDatabaseName,
108991:                                     int64_t aId, int32_t* aRefCnt,
108991:                                     int32_t* aDBRefCnt, int32_t* aSliceRefCnt,
 84685:                                     bool* aResult)
 84685: {
 84685:   if (!IsUniversalXPConnectCapable()) {
 84685:     return NS_ERROR_DOM_SECURITY_ERR;
 84685:   }
 84685: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 84685: 
 84685:   nsCString origin;
 84685:   nsresult rv = indexedDB::IndexedDatabaseManager::GetASCIIOriginFromWindow(
 94546:     window, origin);
 84685:   NS_ENSURE_SUCCESS(rv, rv);
 84685: 
 84685:   nsRefPtr<indexedDB::IndexedDatabaseManager> mgr =
 85093:     indexedDB::IndexedDatabaseManager::Get();
 84685: 
 85093:   if (mgr) {
 84685:     nsRefPtr<indexedDB::FileManager> fileManager =
 85093:       mgr->GetFileManager(origin, aDatabaseName);
 84685: 
 85093:     if (fileManager) {
 84685:       nsRefPtr<indexedDB::FileInfo> fileInfo = fileManager->GetFileInfo(aId);
 85093: 
 84685:       if (fileInfo) {
 84685:         fileInfo->GetReferences(aRefCnt, aDBRefCnt, aSliceRefCnt);
 85093: 
 85093:         if (*aRefCnt != -1) {
 85093:           // We added an extra temp ref, so account for that accordingly.
 85093:           (*aRefCnt)--;
 85093:         }
 85093: 
 84685:         *aResult = true;
 84685:         return NS_OK;
 84685:       }
 85093:     }
 85093:   }
 84685: 
 84685:   *aRefCnt = *aDBRefCnt = *aSliceRefCnt = -1;
 84685:   *aResult = false;
 84685:   return NS_OK;
 84685: }
 84803: 
 86098: NS_IMETHODIMP
 90410: nsDOMWindowUtils::IsIncrementalGCEnabled(JSContext* cx, bool* aResult)
 90410: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 90410:   *aResult = js::IsIncrementalGCEnabled(JS_GetRuntime(cx));
 90410:   return NS_OK;
 90410: }
 90410: 
 90410: NS_IMETHODIMP
 86098: nsDOMWindowUtils::StartPCCountProfiling(JSContext* cx)
 84803: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 84803:   js::StartPCCountProfiling(cx);
 84803:   return NS_OK;
 84803: }
 84803: 
 84803: NS_IMETHODIMP
 86098: nsDOMWindowUtils::StopPCCountProfiling(JSContext* cx)
 84803: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 84803:   js::StopPCCountProfiling(cx);
 84803:   return NS_OK;
 84803: }
 84803: 
 84803: NS_IMETHODIMP
 86098: nsDOMWindowUtils::PurgePCCounts(JSContext* cx)
 84803: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 84803:   js::PurgePCCounts(cx);
 84803:   return NS_OK;
 84803: }
 84803: 
 84803: NS_IMETHODIMP
108991: nsDOMWindowUtils::GetPCCountScriptCount(JSContext* cx, int32_t *result)
 84803: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 84803:   *result = js::GetPCCountScriptCount(cx);
 84803:   return NS_OK;
 84803: }
 84803: 
 84803: NS_IMETHODIMP
108991: nsDOMWindowUtils::GetPCCountScriptSummary(int32_t script, JSContext* cx, nsAString& result)
 84803: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 84803:   JSString *text = js::GetPCCountScriptSummary(cx, script);
 84803:   if (!text)
 84803:     return NS_ERROR_FAILURE;
 84803: 
 84803:   nsDependentJSString str;
 84803:   if (!str.init(cx, text))
 84803:     return NS_ERROR_FAILURE;
 84803: 
 84803:   result = str;
 84803:   return NS_OK;
 84803: }
 84803: 
 84803: NS_IMETHODIMP
108991: nsDOMWindowUtils::GetPCCountScriptContents(int32_t script, JSContext* cx, nsAString& result)
 84803: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 84803:   JSString *text = js::GetPCCountScriptContents(cx, script);
 84803:   if (!text)
 84803:     return NS_ERROR_FAILURE;
 84803: 
 84803:   nsDependentJSString str;
 84803:   if (!str.init(cx, text))
 84803:     return NS_ERROR_FAILURE;
 84803: 
 84803:   result = str;
 84803:   return NS_OK;
 84803: }
 86563: 
 86563: NS_IMETHODIMP
 86563: nsDOMWindowUtils::GetPaintingSuppressed(bool *aPaintingSuppressed)
 86563: {
111600:   if (!IsUniversalXPConnectCapable()) {
111600:     return NS_ERROR_DOM_SECURITY_ERR;
111600:   }
111600: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 94546:   nsIDocShell *docShell = window->GetDocShell();
 86563:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
 86563: 
 86563:   nsCOMPtr<nsIPresShell> presShell;
 86563:   docShell->GetPresShell(getter_AddRefs(presShell));
 86563:   NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
 86563: 
 86563:   *aPaintingSuppressed = presShell->IsPaintingSuppressed();
 86563:   return NS_OK;
 86563: }
 86563: 
 94270: NS_IMETHODIMP
 94270: nsDOMWindowUtils::GetPlugins(JSContext* cx, jsval* aPlugins)
 94270: {
 94270:   if (!IsUniversalXPConnectCapable()) {
 94270:     return NS_ERROR_DOM_SECURITY_ERR;
 94270:   }
 94270: 
 94546:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 94546:   NS_ENSURE_STATE(window);
 94546: 
 94546:   nsIDOMDocument* ddoc = window->GetExtantDocument();
 94270: 
 94270:   nsresult rv;
 94270:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(ddoc, &rv);
 94270:   NS_ENSURE_SUCCESS(rv, rv);
 94270: 
 94270:   nsTArray<nsIObjectLoadingContent*> plugins;
 94270:   doc->GetPlugins(plugins);
 94270: 
106838:   JSObject* jsPlugins = nullptr;
 94270:   rv = nsTArrayToJSArray(cx, plugins, &jsPlugins);
 94270:   NS_ENSURE_SUCCESS(rv, rv);
 94270: 
 94270:   *aPlugins = OBJECT_TO_JSVAL(jsPlugins);
 94270:   return NS_OK;
 94270: }
 96812: 
 96812: NS_IMETHODIMP
 96812: nsDOMWindowUtils::SetScrollPositionClampingScrollPortSize(float aWidth, float aHeight)
 96812: {
 96812:   if (!IsUniversalXPConnectCapable()) {
 96812:     return NS_ERROR_DOM_SECURITY_ERR;
 96812:   }
 96812: 
 96812:   if (!(aWidth >= 0.0 && aHeight >= 0.0)) {
 96812:     return NS_ERROR_ILLEGAL_VALUE;
 96812:   }
 96812: 
 96812:   nsIPresShell* presShell = GetPresShell();
 96812:   if (!presShell) {
 96812:     return NS_ERROR_FAILURE;
 96812:   }
 96812: 
 96812:   presShell->SetScrollPositionClampingScrollPortSize(
 96812:     nsPresContext::CSSPixelsToAppUnits(aWidth),
 96812:     nsPresContext::CSSPixelsToAppUnits(aHeight));
 96812: 
 96812:   return NS_OK;
 96812: }
 98227: 
106920: nsresult
106920: nsDOMWindowUtils::RemoteFrameFullscreenChanged(nsIDOMElement* aFrameElement,
106920:                                             const nsAString& aNewOrigin)
106920: {
111601:   if (!IsUniversalXPConnectCapable()) {
111601:     return NS_ERROR_DOM_SECURITY_ERR;
111601:   }
111601: 
106920:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
106920:   NS_ENSURE_STATE(window);
106920: 
106920:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
106920:   NS_ENSURE_STATE(doc);
106920: 
106920:   doc->RemoteFrameFullscreenChanged(aFrameElement, aNewOrigin);
106920:   return NS_OK;
106920: }
106920: 
106920: nsresult
106920: nsDOMWindowUtils::RemoteFrameFullscreenReverted()
106920: {
111601:   if (!IsUniversalXPConnectCapable()) {
111601:     return NS_ERROR_DOM_SECURITY_ERR;
111601:   }
111601: 
106920:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
106920:   NS_ENSURE_STATE(window);
106920: 
106920:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(window->GetExtantDocument()));
106920:   NS_ENSURE_STATE(doc);
106920: 
106920:   doc->RemoteFrameFullscreenReverted();
106920:   return NS_OK;
106920: }
106920: 
106920: nsresult
106920: nsDOMWindowUtils::ExitFullscreen()
106920: {
111601:   if (!IsUniversalXPConnectCapable()) {
111601:     return NS_ERROR_DOM_SECURITY_ERR;
111601:   }
111601: 
106920:   nsIDocument::ExitFullScreen(/* async = */ false);
106920:   return NS_OK;
106920: }
111609: 
111609: NS_IMETHODIMP
113988: nsDOMWindowUtils::SelectAtPoint(float aX, float aY, uint32_t aSelectBehavior,
111609:                                 bool *_retval)
111609: {
111609:   *_retval = false;
111609:   if (!IsUniversalXPConnectCapable()) {
111609:     return NS_ERROR_DOM_SECURITY_ERR;
111609:   }
111609: 
111609:   nsSelectionAmount amount;
111609:   switch (aSelectBehavior) {
111609:     case nsIDOMWindowUtils::SELECT_CHARACTER:
111609:       amount = eSelectCharacter;
111609:     break;
111609:     case nsIDOMWindowUtils::SELECT_CLUSTER:
111609:       amount = eSelectCluster;
111609:     break;
111609:     case nsIDOMWindowUtils::SELECT_WORD:
111609:       amount = eSelectWord;
111609:     break;
111609:     case nsIDOMWindowUtils::SELECT_LINE:
111609:       amount = eSelectLine;
111609:     break;
111609:     case nsIDOMWindowUtils::SELECT_BEGINLINE:
111609:       amount = eSelectBeginLine;
111609:     break;
111609:     case nsIDOMWindowUtils::SELECT_ENDLINE:
111609:       amount = eSelectEndLine;
111609:     break;
111609:     case nsIDOMWindowUtils::SELECT_PARAGRAPH:
111609:       amount = eSelectParagraph;
111609:     break;
111609:     case nsIDOMWindowUtils::SELECT_WORDNOSPACE:
111609:       amount = eSelectWordNoSpace;
111609:     break;
111609:   }
111609: 
111609:   nsIPresShell* presShell = GetPresShell();
111609:   if (!presShell) {
111609:     return NS_ERROR_UNEXPECTED;
111609:   }
111609: 
111609:   // The root frame for this content window
111609:   nsIFrame* rootFrame = presShell->FrameManager()->GetRootFrame();
111609:   if (!rootFrame) {
111609:     return NS_ERROR_UNEXPECTED;
111609:   }
111609: 
111609:   // Get the target frame at the client coordinates passed to us
111609:   nsCOMPtr<nsIWidget> widget = GetWidget();
111609:   nsIntPoint pt(aX, aY);
111609:   nsPoint ptInRoot =
111609:     nsLayoutUtils::GetEventCoordinatesRelativeTo(widget, pt, rootFrame);
111609:   nsIFrame* targetFrame = nsLayoutUtils::GetFrameForPoint(rootFrame, ptInRoot);
111609:   // This can happen if the page hasn't loaded yet or if the point
111609:   // is outside the frame.
111609:   if (!targetFrame) {
111609:     return NS_ERROR_INVALID_ARG;
111609:   }
111609: 
111609:   // Convert point to coordinates relative to the target frame, which is
111609:   // what targetFrame's SelectByTypeAtPoint expects.
111609:   nsPoint relPoint =
111609:     nsLayoutUtils::GetEventCoordinatesRelativeTo(widget, pt, targetFrame);
111609: 
111609:   nsresult rv =
111609:     static_cast<nsFrame*>(targetFrame)->
111609:       SelectByTypeAtPoint(GetPresContext(), relPoint, amount, amount,
111609:                           nsFrame::SELECT_ACCUMULATE);
111609:   *_retval = !NS_FAILED(rv);
111609:   return NS_OK;
111609: }
113662: 
113662: NS_IMETHODIMP
113988: nsDOMWindowUtils::LoadSheet(nsIURI *aSheetURI, uint32_t aSheetType)
113662: {
113662:   if (!IsUniversalXPConnectCapable()) {
113662:     return NS_ERROR_DOM_SECURITY_ERR;
113662:   }
113662: 
113662:   NS_ENSURE_ARG_POINTER(aSheetURI);
113662:   NS_ENSURE_ARG(aSheetType == AGENT_SHEET || aSheetType == USER_SHEET);
113662: 
113662:   nsCOMPtr<nsIDOMWindow> window = do_QueryReferent(mWindow);
113662:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
113662:   
113662:   nsCOMPtr<nsIDOMDocument> ddoc;
113662:   nsresult rv = window->GetDocument(getter_AddRefs(ddoc));
113662:   NS_ENSURE_SUCCESS(rv, rv);
113662:   NS_ENSURE_TRUE(ddoc, NS_ERROR_FAILURE);
113662: 
113662:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(ddoc);
113662:   NS_ENSURE_TRUE(doc, NS_ERROR_INVALID_ARG);
113662: 
113662:   nsIDocument::additionalSheetType type = 
113662:     aSheetType == AGENT_SHEET ? nsIDocument::eAgentSheet :
113662:                                 nsIDocument::eUserSheet;
113662: 
113662:   rv = doc->LoadAdditionalStyleSheet(type, aSheetURI);
113662:   NS_ENSURE_SUCCESS(rv, rv);
113662: 
113662:   return NS_OK;
113662: }
113662: 
113662: NS_IMETHODIMP
113988: nsDOMWindowUtils::RemoveSheet(nsIURI *aSheetURI, uint32_t aSheetType)
113662: {
113662:   if (!IsUniversalXPConnectCapable()) {
113662:     return NS_ERROR_DOM_SECURITY_ERR;
113662:   }
113662: 
113662:   NS_ENSURE_ARG_POINTER(aSheetURI);
113662:   NS_ENSURE_ARG(aSheetType == AGENT_SHEET || aSheetType == USER_SHEET);
113662: 
113662:   nsCOMPtr<nsIDOMWindow> window = do_QueryReferent(mWindow);
113662:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
113662: 
113662:   nsCOMPtr<nsIDOMDocument> ddoc;
113662:   nsresult rv = window->GetDocument(getter_AddRefs(ddoc));
113662:   NS_ENSURE_SUCCESS(rv, rv);
113662:   NS_ENSURE_TRUE(ddoc, NS_ERROR_FAILURE);
113662: 
113662:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(ddoc);
113662:   NS_ENSURE_TRUE(doc, NS_ERROR_INVALID_ARG);
113662: 
113662:   nsIDocument::additionalSheetType type = 
113662:     aSheetType == AGENT_SHEET ? nsIDocument::eAgentSheet :
113662:                                 nsIDocument::eUserSheet;
113662: 
113662:   doc->RemoveAdditionalStyleSheet(type, aSheetURI);
113662:   return NS_OK;
113662: }
