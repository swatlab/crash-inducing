 84549: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 84549: 
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 84549: 
 99497: #ifndef mozilla_net_SpdySession2_h
 99497: #define mozilla_net_SpdySession2_h
 84549: 
 84549: // SPDY as defined by
 84549: // http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft2
 84549: 
 99497: #include "ASpdySession.h"
 84549: #include "nsClassHashtable.h"
 84549: #include "nsDataHashtable.h"
 84549: #include "nsDeque.h"
 84549: #include "nsHashKeys.h"
 84549: #include "zlib.h"
 84549: 
 84549: class nsHttpConnection;
 84549: class nsISocketTransport;
 84549: 
 84549: namespace mozilla { namespace net {
 84549: 
 99497: class SpdyStream2;
 84549: 
 99497: class SpdySession2 : public ASpdySession
 84549:                    , public nsAHttpConnection
 84549:                    , public nsAHttpSegmentReader
 84549:                    , public nsAHttpSegmentWriter
 84549: {
 84549: public:
 84549:   NS_DECL_ISUPPORTS
 84549:   NS_DECL_NSAHTTPTRANSACTION
 98400:   NS_DECL_NSAHTTPCONNECTION(mConnection)
 84549:   NS_DECL_NSAHTTPSEGMENTREADER
 84549:   NS_DECL_NSAHTTPSEGMENTWRITER
 84549: 
 99497:   SpdySession2(nsAHttpTransaction *, nsISocketTransport *, PRInt32);
 99497:   ~SpdySession2();
 84549: 
 84549:   bool AddStream(nsAHttpTransaction *, PRInt32);
 84549:   bool CanReuse() { return !mShouldGoAway && !mClosed; }
 84549:   bool RoomForMoreStreams();
 90871: 
 93844:   // When the connection is active this is called every 1 second
 90871:   void ReadTimeoutTick(PRIntervalTime now);
 90871:   
 90872:   // Idle time represents time since "goodput".. e.g. a data or header frame
 90872:   PRIntervalTime IdleTime();
 90872: 
 99497:   PRUint32 RegisterStreamID(SpdyStream2 *);
 84549: 
 84549:   const static PRUint8 kFlag_Control   = 0x80;
 84549: 
 84549:   const static PRUint8 kFlag_Data_FIN  = 0x01;
 84549:   const static PRUint8 kFlag_Data_UNI  = 0x02;
 84549:   const static PRUint8 kFlag_Data_ZLIB = 0x02;
 84549:   
 95463:   // The protocol document for v2 specifies that the
 95463:   // highest value (3) is the highest priority, but in
 95463:   // reality 0 is the highest priority. 
 95463:   //
 95463:   // Draft 3 notes here https://sites.google.com/a/chromium.org/dev/spdy/spdy-protocol/
 95463:   // are the best guide to the mistake. Also see
 95463:   // GetLowestPriority() and GetHighestPriority() in spdy_framer.h of
 95463:   // chromium source.
 95463: 
 95463:   const static PRUint8 kPri00   = 0 << 6; // highest
 95463:   const static PRUint8 kPri01   = 1 << 6;
 95463:   const static PRUint8 kPri02   = 2 << 6;
 95463:   const static PRUint8 kPri03   = 3 << 6; // lowest
 84549: 
 84549:   enum
 84549:   {
 84549:     CONTROL_TYPE_FIRST = 0,
 84549:     CONTROL_TYPE_SYN_STREAM = 1,
 84549:     CONTROL_TYPE_SYN_REPLY = 2,
 84549:     CONTROL_TYPE_RST_STREAM = 3,
 84549:     CONTROL_TYPE_SETTINGS = 4,
 84549:     CONTROL_TYPE_NOOP = 5,
 84549:     CONTROL_TYPE_PING = 6,
 84549:     CONTROL_TYPE_GOAWAY = 7,
 84549:     CONTROL_TYPE_HEADERS = 8,
 84549:     CONTROL_TYPE_WINDOW_UPDATE = 9,               /* no longer in v2 */
 84549:     CONTROL_TYPE_LAST = 10
 84549:   };
 84549: 
 90452:   enum rstReason
 84549:   {
 84549:     RST_PROTOCOL_ERROR = 1,
 84549:     RST_INVALID_STREAM = 2,
 84549:     RST_REFUSED_STREAM = 3,
 84549:     RST_UNSUPPORTED_VERSION = 4,
 84549:     RST_CANCEL = 5,
 84549:     RST_INTERNAL_ERROR = 6,
 84549:     RST_FLOW_CONTROL_ERROR = 7,
 84549:     RST_BAD_ASSOC_STREAM = 8
 84549:   };
 84549: 
 84549:   enum
 84549:   {
 84549:     SETTINGS_TYPE_UPLOAD_BW = 1, // kb/s
 84549:     SETTINGS_TYPE_DOWNLOAD_BW = 2, // kb/s
 84549:     SETTINGS_TYPE_RTT = 3, // ms
 84549:     SETTINGS_TYPE_MAX_CONCURRENT = 4, // streams
 84549:     SETTINGS_TYPE_CWND = 5, // packets
 84549:     SETTINGS_TYPE_DOWNLOAD_RETRANS_RATE = 6, // percentage
 84549:     SETTINGS_TYPE_INITIAL_WINDOW = 7  // bytes. Not used in v2.
 84549:   };
 84549: 
 84549:   // This should be big enough to hold all of your control packets,
 84549:   // but if it needs to grow for huge headers it can do so dynamically.
 84549:   // About 1% of requests to SPDY google services seem to be > 1000
 84549:   // with all less than 2000.
 88247:   const static PRUint32 kDefaultBufferSize = 2048;
 84549: 
 88247:   // kDefaultQueueSize must be >= other queue size constants
 88247:   const static PRUint32 kDefaultQueueSize =  16384;
 88247:   const static PRUint32 kQueueMinimumCleanup = 8192;
 88247:   const static PRUint32 kQueueTailRoom    =  4096;
 88247:   const static PRUint32 kQueueReserved    =  1024;
 88247: 
 84549:   const static PRUint32 kDefaultMaxConcurrent = 100;
 84549:   const static PRUint32 kMaxStreamID = 0x7800000;
 84549:   
 98989:   // This is a sentinel for a deleted stream. It is not a valid
 98989:   // 31 bit stream ID.
 98989:   const static PRUint32 kDeadStreamID = 0xffffdead;
 98989:   
 99497:   static nsresult HandleSynStream(SpdySession2 *);
 99497:   static nsresult HandleSynReply(SpdySession2 *);
 99497:   static nsresult HandleRstStream(SpdySession2 *);
 99497:   static nsresult HandleSettings(SpdySession2 *);
 99497:   static nsresult HandleNoop(SpdySession2 *);
 99497:   static nsresult HandlePing(SpdySession2 *);
 99497:   static nsresult HandleGoAway(SpdySession2 *);
 99497:   static nsresult HandleHeaders(SpdySession2 *);
 99497:   static nsresult HandleWindowUpdate(SpdySession2 *);
 84549: 
 84549:   static void EnsureBuffer(nsAutoArrayPtr<char> &,
 84549:                            PRUint32, PRUint32, PRUint32 &);
 84549: 
 84549:   // For writing the SPDY data stream to LOG4
 99497:   static void LogIO(SpdySession2 *, SpdyStream2 *, const char *,
 84549:                     const char *, PRUint32);
 84549: 
 88247:   // an overload of nsAHttpConnection
 88247:   void TransactionHasDataToWrite(nsAHttpTransaction *);
 88247: 
 99497:   // a similar version for SpdyStream2
 99497:   void TransactionHasDataToWrite(SpdyStream2 *);
 88248: 
 88248:   // an overload of nsAHttpSegementReader
 88248:   virtual nsresult CommitToSegmentSize(PRUint32 size);
 88248:   
 84549: private:
 84549: 
 84549:   enum stateType {
 84549:     BUFFERING_FRAME_HEADER,
 84549:     BUFFERING_CONTROL_FRAME,
 84549:     PROCESSING_DATA_FRAME,
 88247:     DISCARDING_DATA_FRAME,
 84549:     PROCESSING_CONTROL_SYN_REPLY,
 84549:     PROCESSING_CONTROL_RST_STREAM
 84549:   };
 84549: 
 91115:   void        DeterminePingThreshold();
 90452:   nsresult    HandleSynReplyForValidStream();
 88247:   PRUint32    GetWriteQueueSize();
 84549:   void        ChangeDownstreamState(enum stateType);
 88247:   void        ResetDownstreamState();
 84549:   nsresult    DownstreamUncompress(char *, PRUint32);
 84549:   void        zlibInit();
 84549:   nsresult    FindHeader(nsCString, nsDependentCSubstring &);
 84549:   nsresult    ConvertHeaders(nsDependentCSubstring &,
 84549:                              nsDependentCSubstring &);
 84549:   void        GeneratePing(PRUint32);
 91115:   void        ClearPing(bool);
 84549:   void        GenerateRstStream(PRUint32, PRUint32);
 84549:   void        GenerateGoAway();
 99497:   void        CleanupStream(SpdyStream2 *, nsresult, rstReason);
100224:   void        CloseStream(SpdyStream2 *, nsresult);
 84549: 
 88247:   void        SetWriteCallbacks();
 84549:   void        FlushOutputQueue();
 84549: 
 84549:   bool        RoomForMoreConcurrent();
 99497:   void        ActivateStream(SpdyStream2 *);
 84549:   void        ProcessPending();
 98989:   nsresult    SetInputFrameDataStream(PRUint32);
 99497:   bool        VerifyStream(SpdyStream2 *, PRUint32);
 99496:   void        SetNeedsCleanup();
 84549: 
 90872:   // a wrapper for all calls to the nshttpconnection level segment writer. Used
 90872:   // to track network I/O for timeout purposes
 90872:   nsresult   NetworkRead(nsAHttpSegmentWriter *, char *, PRUint32, PRUint32 *);
 90872:   
 88247:   static PLDHashOperator ShutdownEnumerator(nsAHttpTransaction *,
 99497:                                             nsAutoPtr<SpdyStream2> &,
 84549:                                             void *);
 84549: 
 84549:   // This is intended to be nsHttpConnectionMgr:nsHttpConnectionHandle taken
 86570:   // from the first transaction on this session. That object contains the
 84549:   // pointer to the real network-level nsHttpConnection object.
 84549:   nsRefPtr<nsAHttpConnection> mConnection;
 84549: 
 84549:   // The underlying socket transport object is needed to propogate some events
 84549:   nsISocketTransport         *mSocketTransport;
 84549: 
 84549:   // These are temporary state variables to hold the argument to
 84549:   // Read/WriteSegments so it can be accessed by On(read/write)segment
 84549:   // further up the stack.
 84549:   nsAHttpSegmentReader       *mSegmentReader;
 84549:   nsAHttpSegmentWriter       *mSegmentWriter;
 84549: 
 86570:   PRUint32          mSendingChunkSize;        /* the transmission chunk size */
 84549:   PRUint32          mNextStreamID;            /* 24 bits */
 84549:   PRUint32          mConcurrentHighWater;     /* max parallelism on session */
 84549: 
 84549:   stateType         mDownstreamState; /* in frame, between frames, etc..  */
 84549: 
 84549:   // Maintain 5 indexes - one by stream ID, one by transaction ptr,
 84549:   // one list of streams ready to write, one list of streams that are queued
 84549:   // due to max parallelism settings, and one list of streams
 84549:   // that must be given priority to write for window updates. The objects
 86570:   // are not ref counted - they get destroyed
 84549:   // by the nsClassHashtable implementation when they are removed from
 84549:   // there.
 99497:   nsDataHashtable<nsUint32HashKey, SpdyStream2 *>     mStreamIDHash;
 84549:   nsClassHashtable<nsPtrHashKey<nsAHttpTransaction>,
 99497:                    SpdyStream2>                       mStreamTransactionHash;
 84549:   nsDeque                                             mReadyForWrite;
 84549:   nsDeque                                             mQueuedStreams;
 84549: 
 84549:   // UrgentForWrite is meant to carry window updates. They were defined in
 84549:   // the v2 spec but apparently never implemented so are now scheduled to
 84549:   // be removed. But they will be reintroduced for v3, so we will leave
 84549:   // this queue in place to ease that transition.
 84549:   nsDeque           mUrgentForWrite;
 84549: 
 84549:   // Compression contexts for header transport using deflate.
 84549:   // SPDY compresses only HTTP headers and does not reset zlib in between
 84549:   // frames.
 84549:   z_stream            mDownstreamZlib;
 84549:   z_stream            mUpstreamZlib;
 84549: 
 88247:   // mInputFrameBuffer is used to store received control packets and the 8 bytes
 84549:   // of header on data packets
 88247:   PRUint32             mInputFrameBufferSize;
 88247:   PRUint32             mInputFrameBufferUsed;
 88247:   nsAutoArrayPtr<char> mInputFrameBuffer;
 84549:   
 88247:   // mInputFrameDataSize/Read are used for tracking the amount of data consumed
 84549:   // in a data frame. the data itself is not buffered in spdy
 88247:   // The frame size is mInputFrameDataSize + the constant 8 byte header
 88247:   PRUint32             mInputFrameDataSize;
 88247:   PRUint32             mInputFrameDataRead;
 88247:   bool                 mInputFrameDataLast; // This frame was marked FIN
 84549: 
 84549:   // When a frame has been received that is addressed to a particular stream
 84549:   // (e.g. a data frame after the stream-id has been decoded), this points
 84549:   // to the stream.
 99497:   SpdyStream2          *mInputFrameDataStream;
 84549:   
 88247:   // mNeedsCleanup is a state variable to defer cleanup of a closed stream
 88247:   // If needed, It is set in session::OnWriteSegments() and acted on and
 88247:   // cleared when the stack returns to session::WriteSegments(). The stream
 88247:   // cannot be destroyed directly out of OnWriteSegments because
 88247:   // stream::writeSegments() is on the stack at that time.
 99497:   SpdyStream2          *mNeedsCleanup;
 84549: 
 84549:   // The CONTROL_TYPE value for a control frame
 84549:   PRUint32             mFrameControlType;
 84549: 
 84549:   // This reason code in the last processed RESET frame
 84549:   PRUint32             mDownstreamRstReason;
 84549: 
 84549:   // These are used for decompressing downstream spdy response headers
 84549:   // This is done at the session level because sometimes the stream
 84549:   // has already been canceled but the decompression still must happen
 84549:   // to keep the zlib state correct for the next state of headers.
 84549:   PRUint32             mDecompressBufferSize;
 84549:   PRUint32             mDecompressBufferUsed;
 84549:   nsAutoArrayPtr<char> mDecompressBuffer;
 84549: 
 84549:   // for the conversion of downstream http headers into spdy formatted headers
 84549:   nsCString            mFlatHTTPResponseHeaders;
 84549:   PRUint32             mFlatHTTPResponseHeadersOut;
 84549: 
 88247:   // when set, the session will go away when it reaches 0 streams. This flag
 88247:   // is set when: the stream IDs are running out (at either the client or the
 88247:   // server), when DontReuse() is called, a RST that is not specific to a
 88247:   // particular stream is received, a GOAWAY frame has been received from
 88247:   // the server.
 84549:   bool                 mShouldGoAway;
 84549: 
 84549:   // the session has received a nsAHttpTransaction::Close()  call
 84549:   bool                 mClosed;
 84549: 
 84549:   // the session received a GoAway frame with a valid GoAwayID
 84549:   bool                 mCleanShutdown;
 84549: 
 84549:   // If a GoAway message was received this is the ID of the last valid
 84549:   // stream. 0 otherwise. (0 is never a valid stream id.)
 84549:   PRUint32             mGoAwayID;
 84549: 
 84549:   // The limit on number of concurrent streams for this session. Normally it
 84549:   // is basically unlimited, but the SETTINGS control message from the
 84549:   // server might bring it down.
 84549:   PRUint32             mMaxConcurrent;
 84549: 
 84549:   // The actual number of concurrent streams at this moment. Generally below
 84549:   // mMaxConcurrent, but the max can be lowered in real time to a value
 84549:   // below the current value
 84549:   PRUint32             mConcurrent;
 84549: 
 84549:   // The number of server initiated SYN-STREAMS, tracked for telemetry
 84549:   PRUint32             mServerPushedResources;
 84549: 
 84549:   // This is a output queue of bytes ready to be written to the SSL stream.
 84549:   // When that streams returns WOULD_BLOCK on direct write the bytes get
 84549:   // coalesced together here. This results in larger writes to the SSL layer.
 84549:   // The buffer is not dynamically grown to accomodate stream writes, but
 84549:   // does expand to accept infallible session wide frames like GoAway and RST.
 84549:   PRUint32             mOutputQueueSize;
 84549:   PRUint32             mOutputQueueUsed;
 84549:   PRUint32             mOutputQueueSent;
 84549:   nsAutoArrayPtr<char> mOutputQueueBuffer;
 90872: 
 91115:   PRIntervalTime       mPingThreshold;
 90872:   PRIntervalTime       mLastReadEpoch;     // used for ping timeouts
 90872:   PRIntervalTime       mLastDataReadEpoch; // used for IdleTime()
 90872:   PRIntervalTime       mPingSentEpoch;
 90872:   PRUint32             mNextPingID;
 91115:   bool                 mPingThresholdExperiment;
 84549: };
 84549: 
 84549: }} // namespace mozilla::net
 84549: 
 99497: #endif // mozilla_net_SpdySession2_h
