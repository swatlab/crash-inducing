    1: /** -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@netscape.com>
 7009:  *   Federico Mena-Quintero <federico@novell.com>
30479:  *   Joe Drew <joe@drew.ca>
32424:  *   Bobby Holley <bobbyholley@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsISupports.idl"
    1: 
32424: interface imgIDecoderObserver;
    1: 
30479: %{C++
30479: #include "gfxImageSurface.h"
30479: #include "gfxContext.h"
30479: #include "gfxMatrix.h"
30479: #include "gfxRect.h"
30479: #include "gfxPattern.h"
30479: #include "gfxASurface.h"
30479: #include "nsRect.h"
52215: #include "nsSize.h"
52212: #include "limits.h"
52212: 
52204: class nsIFrame;
30479: %}
30479: 
30479: [ptr] native gfxImageSurface(gfxImageSurface);
30479: [ptr] native gfxASurface(gfxASurface);
30479: native gfxImageFormat(gfxASurface::gfxImageFormat);
30479: [ptr] native gfxContext(gfxContext);
30479: [ref] native gfxMatrix(gfxMatrix);
30479: [ref] native gfxRect(gfxRect);
30479: native gfxGraphicsFilter(gfxPattern::GraphicsFilter);
30479: [ref] native nsIntRect(nsIntRect);
52215: [ref] native nsIntSize(nsIntSize);
52204: [ptr] native nsIFrame(nsIFrame);
30479: 
    1: /**
30479:  * imgIContainer is the interface that represents an image. It allows
30479:  * access to frames as Thebes surfaces, and permits users to extract subregions
30479:  * as other imgIContainers. It also allows drawing of images on to Thebes
30479:  * contexts.
    1:  *
30479:  * Internally, imgIContainer also manages animation of images.
    1:  */
52215: [scriptable, uuid(239dfa70-2285-4d63-99cd-e9b7ff9555c7)]
    1: interface imgIContainer : nsISupports
    1: {
    1:   /**
54975:    * The width of the container rectangle.  In the case of any error,
54975:    * zero is returned, and an exception will be thrown.
30479:    */
30479:   readonly attribute PRInt32 width;
30479: 
30479:   /**
54975:    * The height of the container rectangle.  In the case of any error,
54975:    * zero is returned, and an exception will be thrown.
30479:    */
30479:   readonly attribute PRInt32 height;
30479: 
30479:   /**
50552:     * Enumerated values for the 'type' attribute (below).
50552:     */
50552:   const unsigned short TYPE_RASTER = 0;
50552:   const unsigned short TYPE_VECTOR = 1;
50552: 
50552:   /**
50552:    * The type of this image (one of the TYPE_* values above).
50552:    */
50552:   readonly attribute unsigned short type;
50552: 
50552:   /**
50552:    * Direct C++ accessor for 'type' attribute, for convenience.
50552:    */
58677:   [noscript, notxpcom] PRUint16 GetType();
50552: 
50552:   /**
33531:    * Whether this image is animated. You can only be guaranteed that querying
33531:    * this will not throw if STATUS_DECODE_COMPLETE is set on the imgIRequest.
33531:    *
33531:    * @throws NS_ERROR_NOT_AVAILABLE if the animated state cannot be determined.
30479:    */
30479:   readonly attribute boolean animated;
30479: 
30479:   /**
30479:    * Whether the current frame is opaque; that is, needs the background painted
30479:    * behind it.
30479:    */
30479:   readonly attribute boolean currentFrameIsOpaque;
30479: 
30479:   /**
32424:    * Flags for imgIContainer operations.
32424:    *
32424:    * Meanings:
32424:    *
32424:    * FLAG_NONE: Lack of flags
32424:    *
32424:    * FLAG_SYNC_DECODE: Forces synchronous/non-progressive decode of all
48223:    * available data before the call returns. It is an error to pass this flag
48223:    * from a call stack that originates in a decoder (ie, from a decoder
48223:    * observer event).
30479:    */
32424: 
32424:   const long FLAG_NONE            = 0x0;
32424:   const long FLAG_SYNC_DECODE     = 0x1;
30479: 
30479:   /**
32424:     * Constants for specifying various "special" frames.
32424:     *
32424:     * FRAME_FIRST: The first frame
32424:     * FRAME_CURRENT: The current frame
32424:     *
32424:     * FRAME_MAX_VALUE should be set to the value of the maximum constant above,
32424:     * as it is used for ensuring that a valid value was passed in.
32424:     */
32424:   const unsigned long FRAME_FIRST = 0;
32424:   const unsigned long FRAME_CURRENT = 1;
32424:   const unsigned long FRAME_MAX_VALUE = 1;
32424: 
32424:   /**
32424:    * Get a surface for the given frame. This may be a platform-native,
32424:    * optimized surface, so you cannot inspect its pixel data.
32424:    *
32424:    * @param aWhichFrame Frame specifier of the FRAME_* variety.
32424:    * @param aFlags Flags of the FLAG_* variety
32424:    */
32424:   [noscript] gfxASurface getFrame(in PRUint32 aWhichFrame,
32424:                                   in PRUint32 aFlags);
32424: 
32424:   /**
32424:    * Create and return a new copy of the given frame that you can write to
30479:    * and otherwise inspect the pixels of.
32424:    *
32424:    * @param aWhichFrame Frame specifier of the FRAME_* variety.
32424:    * @param aFlags Flags of the FLAG_* variety
30479:    */
32424:   [noscript] gfxImageSurface copyFrame(in PRUint32 aWhichFrame,
32424:                                        in PRUint32 aFlags);
30479: 
30479:   /**
30479:    * Create a new imgContainer that contains only a single frame, which itself
32424:    * contains a subregion of the given frame.
30479:    *
32424:    * @param aWhichFrame Frame specifier of the FRAME_* variety.
30479:    * @param aRect the area of the current frame to be duplicated in the
30479:    *              returned imgContainer's frame.
32424:    * @param aFlags Flags of the FLAG_* variety
30479:    */
32424:   [noscript] imgIContainer extractFrame(in PRUint32 aWhichFrame,
32424:                                         [const] in nsIntRect aRect,
32424:                                         in PRUint32 aFlags);
30479: 
30479:   /**
30479:    * Draw the current frame on to the context specified.
30479:    *
42457:    * @param aContext The Thebes context to draw the image to.
30479:    * @param aFilter The filter to be used if we're scaling the image.
30479:    * @param aUserSpaceToImageSpace The transformation from user space (e.g.,
30479:    *                               appunits) to image space.
30479:    * @param aFill The area in the context to draw pixels to. Image will be
30479:    *              automatically tiled as necessary.
30759:    * @param aSubimage The area of the image, in pixels, that we are allowed to
30479:    *                  sample from.
52215:    * @param aViewportSize
52215:    *          The size (in CSS pixels) of the viewport that would be available
52215:    *          for the full image to occupy, if we were drawing the full image.
52215:    *          (Note that we might not actually be drawing the full image -- we
52215:    *          might be restricted by aSubimage -- but we still need the full
52215:    *          image's viewport-size in order for SVG images with the "viewBox"
52215:    *          attribute to position their content correctly.)
32424:    * @param aFlags Flags of the FLAG_* variety
30479:    */
47231:   [noscript] void draw(in gfxContext aContext,
47231:                        in gfxGraphicsFilter aFilter,
47231:                        [const] in gfxMatrix aUserSpaceToImageSpace,
47231:                        [const] in gfxRect aFill,
47231:                        [const] in nsIntRect aSubimage,
52215:                        [const] in nsIntSize aViewportSize,
47231:                        in PRUint32 aFlags);
30479: 
52204:   /**
52204:    * If this image is TYPE_VECTOR, i.e. is really an embedded SVG document,
52204:    * this method returns a pointer to the root nsIFrame of that document. If
52204:    * not (or if the root nsIFrame isn't available for some reason), this method
52204:    * returns nsnull.
52204:    *
52204:    * "notxpcom" for convenience, since we have no need for nsresult return-val.
52204:    */
52204:   [notxpcom] nsIFrame GetRootLayoutFrame();
52204: 
32424:   /*
32424:    * Ensures that an image is decoding. Calling this function guarantees that
32424:    * the image will at some point fire off decode notifications. Calling draw(),
32424:    * getFrame(), copyFrame(), or extractCurrentFrame() triggers the same
32424:    * mechanism internally. Thus, if you want to be sure that the image will be
32424:    * decoded but don't want to access it until then, you must call
32424:    * requestDecode().
32424:    */
32424:   void requestDecode();
32424: 
32424:   /**
32424:     * Increments the lock count on the image. An image will not be discarded
32424:     * as long as the lock count is nonzero. Note that it is still possible for
32424:     * the image to be undecoded if decode-on-draw is enabled and the image
32424:     * was never drawn.
32424:     *
32424:     * Upon instantiation images have a lock count of zero.
32424:     */
32424:   void lockImage();
32424: 
32424:   /**
32424:     * Decreases the lock count on the image. If the lock count drops to zero,
32424:     * the image is allowed to discard its frame data to save memory.
32424:     *
32424:     * Upon instantiation images have a lock count of zero. It is an error to
32424:     * call this method without first having made a matching lockImage() call.
32424:     * In other words, the lock count is not allowed to be negative.
32424:     */
32424:   void unlockImage();
30479: 
30479:   /**
    1:    * Animation mode Constants
    1:    *   0 = normal
    1:    *   1 = don't animate
    1:    *   2 = loop once
    1:    */
    1:   const short kNormalAnimMode   = 0;
    1:   const short kDontAnimMode     = 1;
    1:   const short kLoopOnceAnimMode = 2;
    1: 
    1:   attribute unsigned short animationMode;
    1: 
50553:   /* Methods to control animation */
    1:   void resetAnimation();
    1: };
