29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
25100:  * vim: set ts=8 sw=4 et tw=79:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS object implementation.
    1:  */
33160: #define __STDC_LIMIT_MACROS
33160: 
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsbit.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jshash.h" /* Added by JSIFY */
    1: #include "jsdhash.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
 8444: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
 8444: #include "jsparse.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
32738: #include "jsscriptinlines.h"
24499: #include "jsstaticcheck.h"
33160: #include "jsstdint.h"
    1: #include "jsstr.h"
24499: #include "jstracer.h"
25215: #include "jsdbgapi.h"
    1: 
    1: #if JS_HAS_GENERATORS
    1: #include "jsiter.h"
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #if JS_HAS_XDR
    1: #include "jsxdrapi.h"
    1: #endif
    1: 
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058: #include "jsdtracef.h"
 7058: #endif
 7058: 
30283: #include "jsatominlines.h"
32737: #include "jsscriptinlines.h"
30283: 
15453: #include "jsautooplen.h"
15453: 
    1: #ifdef JS_THREADSAFE
    1: #define NATIVE_DROP_PROPERTY js_DropProperty
    1: 
    1: extern void
    1: js_DropProperty(JSContext *cx, JSObject *obj, JSProperty *prop);
    1: #else
    1: #define NATIVE_DROP_PROPERTY NULL
    1: #endif
    1: 
    1: JS_FRIEND_DATA(JSObjectOps) js_ObjectOps = {
28353:     NULL,
    1:     js_LookupProperty,      js_DefineProperty,
    1:     js_GetProperty,         js_SetProperty,
    1:     js_GetAttributes,       js_SetAttributes,
    1:     js_DeleteProperty,      js_DefaultValue,
    1:     js_Enumerate,           js_CheckAccess,
    1:     NULL,                   NATIVE_DROP_PROPERTY,
    1:     js_Call,                js_Construct,
26828:     js_HasInstance,         js_TraceObject,
32603:     js_Clear
    1: };
    1: 
    1: JSClass js_ObjectClass = {
    1:     js_Object_str,
    1:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
    1:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
30654:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   NULL,
    1:     JSCLASS_NO_OPTIONAL_MEMBERS
    1: };
    1: 
    1: #if JS_HAS_OBJ_PROTO_PROP
    1: 
    1: static JSBool
    1: obj_getSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
    1: static JSBool
    1: obj_setSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
    1: static JSBool
    1: obj_getCount(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
    1: static JSPropertySpec object_props[] = {
    1:     /* These two must come first; see object_props[slot].name usage below. */
    1:     {js_proto_str, JSSLOT_PROTO, JSPROP_PERMANENT|JSPROP_SHARED,
    1:                                                   obj_getSlot,  obj_setSlot},
    1:     {js_parent_str,JSSLOT_PARENT,JSPROP_READONLY|JSPROP_PERMANENT|JSPROP_SHARED,
    1:                                                   obj_getSlot,  obj_setSlot},
18669:     {js_count_str, 0,            JSPROP_READONLY|JSPROP_PERMANENT|JSPROP_SHARED,
18669:                                                   obj_getCount, NULL},
    1:     {0,0,0,0,0}
    1: };
    1: 
    1: /* NB: JSSLOT_PROTO and JSSLOT_PARENT are already indexes into object_props. */
    1: #define JSSLOT_COUNT 2
    1: 
    1: static JSBool
    1: ReportStrictSlot(JSContext *cx, uint32 slot)
    1: {
    1:     if (slot == JSSLOT_PROTO)
    1:         return JS_TRUE;
    1:     return JS_ReportErrorFlagsAndNumber(cx,
    1:                                         JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                         js_GetErrorMessage, NULL,
    1:                                         JSMSG_DEPRECATED_USAGE,
    1:                                         object_props[slot].name);
    1: }
    1: 
    1: static JSBool
    1: obj_getSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     uint32 slot;
    1:     jsid propid;
    1:     JSAccessMode mode;
    1:     uintN attrs;
    1:     JSObject *pobj;
    1:     JSClass *clasp;
    1: 
    1:     slot = (uint32) JSVAL_TO_INT(id);
    1:     if (id == INT_TO_JSVAL(JSSLOT_PROTO)) {
    1:         propid = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
    1:         mode = JSACC_PROTO;
    1:     } else {
    1:         propid = ATOM_TO_JSID(cx->runtime->atomState.parentAtom);
    1:         mode = JSACC_PARENT;
    1:     }
    1: 
31501:     /* Let obj->checkAccess get the slot's value, based on the access mode. */
31501:     if (!obj->checkAccess(cx, propid, mode, vp, &attrs))
    1:         return JS_FALSE;
    1: 
    1:     pobj = JSVAL_TO_OBJECT(*vp);
    1:     if (pobj) {
    1:         clasp = OBJ_GET_CLASS(cx, pobj);
    1:         if (clasp == &js_CallClass || clasp == &js_BlockClass) {
    1:             /* Censor activations and lexical scopes per ECMA-262. */
    1:             *vp = JSVAL_NULL;
27539:         } else {
27539:             /*
27539:              * DeclEnv only exists as a parent for a Call object which we
27539:              * censor. So it cannot escape to scripts.
27539:              */
27539:             JS_ASSERT(clasp != &js_DeclEnvClass);
27539:             if (pobj->map->ops->thisObject) {
25521:                 pobj = pobj->map->ops->thisObject(cx, pobj);
    1:                 if (!pobj)
    1:                     return JS_FALSE;
    1:                 *vp = OBJECT_TO_JSVAL(pobj);
    1:             }
    1:         }
27539:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: obj_setSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSObject *pobj;
    1:     uint32 slot;
    1:     jsid propid;
    1:     uintN attrs;
    1: 
    1:     if (!JSVAL_IS_OBJECT(*vp))
    1:         return JS_TRUE;
    1:     pobj = JSVAL_TO_OBJECT(*vp);
    1: 
    1:     if (pobj) {
    1:         /*
    1:          * Innerize pobj here to avoid sticking unwanted properties on the
    1:          * outer object. This ensures that any with statements only grant
    1:          * access to the inner object.
    1:          */
    1:         OBJ_TO_INNER_OBJECT(cx, pobj);
    1:         if (!pobj)
    1:             return JS_FALSE;
    1:     }
    1:     slot = (uint32) JSVAL_TO_INT(id);
    1:     if (JS_HAS_STRICT_OPTION(cx) && !ReportStrictSlot(cx, slot))
    1:         return JS_FALSE;
    1: 
    1:     /* __parent__ is readonly and permanent, only __proto__ may be set. */
    1:     propid = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
31501:     if (!obj->checkAccess(cx, propid, (JSAccessMode)(JSACC_PROTO|JSACC_WRITE), vp, &attrs))
    1:         return JS_FALSE;
    1: 
28003:     return js_SetProtoOrParent(cx, obj, slot, pobj, JS_TRUE);
    1: }
    1: 
    1: static JSBool
    1: obj_getCount(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     jsval iter_state;
    1:     jsid num_properties;
    1:     JSBool ok;
    1: 
    1:     if (JS_HAS_STRICT_OPTION(cx) && !ReportStrictSlot(cx, JSSLOT_COUNT))
    1:         return JS_FALSE;
    1: 
33128:     iter_state = JSVAL_NULL;
33128:     JSAutoEnumStateRooter tvr(cx, obj, &iter_state);
33128: 
    1:     /* Get the number of properties to enumerate. */
31501:     ok = obj->enumerate(cx, JSENUMERATE_INIT, &iter_state, &num_properties);
    1:     if (!ok)
    1:         goto out;
    1: 
    1:     if (!JSVAL_IS_INT(num_properties)) {
    1:         JS_ASSERT(0);
    1:         *vp = JSVAL_ZERO;
    1:         goto out;
    1:     }
    1:     *vp = num_properties;
    1: 
    1: out:
33128:     if (!JSVAL_IS_NULL(iter_state))
33128:         ok &= obj->enumerate(cx, JSENUMERATE_DESTROY, &iter_state, 0);
    1:     return ok;
    1: }
    1: 
    1: #else  /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
    1: #define object_props NULL
    1: 
    1: #endif /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
    1: JSBool
28003: js_SetProtoOrParent(JSContext *cx, JSObject *obj, uint32 slot, JSObject *pobj,
28003:                     JSBool checkForCycles)
    1: {
28003:     JS_ASSERT(slot == JSSLOT_PARENT || slot == JSSLOT_PROTO);
28005:     JS_ASSERT_IF(!checkForCycles, obj != pobj);
28003: 
28003:     if (slot == JSSLOT_PROTO) {
28831:         if (OBJ_IS_NATIVE(obj)) {
28310:             JS_LOCK_OBJ(cx, obj);
28003:             bool ok = !!js_GetMutableScope(cx, obj);
28003:             JS_UNLOCK_OBJ(cx, obj);
28003:             if (!ok)
28003:                 return JS_FALSE;
28831:         }
28003: 
28003:         /*
28003:          * Regenerate property cache shape ids for all of the scopes along the
28003:          * old prototype chain to invalidate their property cache entries, in
30258:          * case any entries were filled by looking up through obj.
28003:          */
28935:         JSObject *oldproto = obj;
28003:         while (oldproto && OBJ_IS_NATIVE(oldproto)) {
28003:             JS_LOCK_OBJ(cx, oldproto);
28003:             JSScope *scope = OBJ_SCOPE(oldproto);
30258:             scope->protoShapeChange(cx);
30645:             JSObject *tmp = STOBJ_GET_PROTO(oldproto);
28003:             JS_UNLOCK_OBJ(cx, oldproto);
28003:             oldproto = tmp;
28003:         }
28003:     }
28003: 
28003:     if (!pobj || !checkForCycles) {
28003:         if (slot == JSSLOT_PROTO)
32603:             obj->setProto(pobj);
28003:         else
32603:             obj->setParent(pobj);
28003:     } else {
28003:         /*
28003:          * Use the GC machinery to serialize access to all objects on the
28003:          * prototype or parent chain.
28003:          */
11041:         JSSetSlotRequest ssr;
11041:         ssr.obj = obj;
11041:         ssr.pobj = pobj;
11041:         ssr.slot = (uint16) slot;
28003:         ssr.cycle = false;
28003: 
28003:         JSRuntime *rt = cx->runtime;
11041:         JS_LOCK_GC(rt);
11041:         ssr.next = rt->setSlotRequests;
11041:         rt->setSlotRequests = &ssr;
16099:         for (;;) {
11041:             js_GC(cx, GC_SET_SLOT_REQUEST);
11041:             JS_UNLOCK_GC(rt);
16099:             if (!rt->setSlotRequests)
16099:                 break;
16099:             JS_LOCK_GC(rt);
16099:         }
11041: 
28003:         if (ssr.cycle) {
28003:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28003:                                  JSMSG_CYCLIC_VALUE,
    1: #if JS_HAS_OBJ_PROTO_PROP
    1:                                  object_props[slot].name
    1: #else
    1:                                  (slot == JSSLOT_PROTO) ? js_proto_str
    1:                                                         : js_parent_str
    1: #endif
    1:                                  );
    1:             return JS_FALSE;
    1:         }
28003:     }
    1:     return JS_TRUE;
    1: }
    1: 
18907: static JSHashNumber
    1: js_hash_object(const void *key)
    1: {
    1:     return (JSHashNumber)JS_PTR_TO_UINT32(key) >> JSVAL_TAGBITS;
    1: }
    1: 
    1: static JSHashEntry *
    1: MarkSharpObjects(JSContext *cx, JSObject *obj, JSIdArray **idap)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSHashTable *table;
    1:     JSHashNumber hash;
    1:     JSHashEntry **hep, *he;
    1:     jsatomid sharpid;
    1:     JSIdArray *ida;
    1:     JSBool ok;
    1:     jsint i, length;
    1:     jsid id;
    1: #if JS_HAS_GETTER_SETTER
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     uintN attrs;
    1: #endif
    1:     jsval val;
11139: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     map = &cx->sharpObjectMap;
23915:     JS_ASSERT(map->depth >= 1);
    1:     table = map->table;
    1:     hash = js_hash_object(obj);
    1:     hep = JS_HashTableRawLookup(table, hash, obj);
    1:     he = *hep;
    1:     if (!he) {
    1:         sharpid = 0;
    1:         he = JS_HashTableRawAdd(table, hep, hash, obj,
    1:                                 JS_UINT32_TO_PTR(sharpid));
    1:         if (!he) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1: 
    1:         ida = JS_Enumerate(cx, obj);
    1:         if (!ida)
    1:             return NULL;
    1: 
    1:         ok = JS_TRUE;
    1:         for (i = 0, length = ida->length; i < length; i++) {
    1:             id = ida->vector[i];
    1: #if JS_HAS_GETTER_SETTER
31501:             ok = obj->lookupProperty(cx, id, &obj2, &prop);
    1:             if (!ok)
    1:                 break;
    1:             if (!prop)
    1:                 continue;
31501:             ok = obj2->getAttributes(cx, id, prop, &attrs);
    1:             if (ok) {
    1:                 if (OBJ_IS_NATIVE(obj2) &&
    1:                     (attrs & (JSPROP_GETTER | JSPROP_SETTER))) {
25218:                     JSScopeProperty *sprop = (JSScopeProperty *) prop;
    1:                     val = JSVAL_NULL;
    1:                     if (attrs & JSPROP_GETTER)
32658:                         val = sprop->getterValue();
    1:                     if (attrs & JSPROP_SETTER) {
    1:                         if (val != JSVAL_NULL) {
    1:                             /* Mark the getter, then set val to setter. */
    1:                             ok = (MarkSharpObjects(cx, JSVAL_TO_OBJECT(val),
    1:                                                    NULL)
    1:                                   != NULL);
    1:                         }
32658:                         val = sprop->setterValue();
    1:                     }
    1:                 } else {
31501:                     ok = obj->getProperty(cx, id, &val);
31501:                 }
31501:             }
31501:             obj2->dropProperty(cx, prop);
    1: #else
31501:             ok = obj->getProperty(cx, id, &val);
    1: #endif
    1:             if (!ok)
    1:                 break;
    1:             if (!JSVAL_IS_PRIMITIVE(val) &&
    1:                 !MarkSharpObjects(cx, JSVAL_TO_OBJECT(val), NULL)) {
    1:                 ok = JS_FALSE;
    1:                 break;
    1:             }
    1:         }
    1:         if (!ok || !idap)
    1:             JS_DestroyIdArray(cx, ida);
    1:         if (!ok)
    1:             return NULL;
    1:     } else {
    1:         sharpid = JS_PTR_TO_UINT32(he->value);
    1:         if (sharpid == 0) {
    1:             sharpid = ++map->sharpgen << SHARP_ID_SHIFT;
    1:             he->value = JS_UINT32_TO_PTR(sharpid);
    1:         }
    1:         ida = NULL;
    1:     }
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: }
    1: 
    1: JSHashEntry *
    1: js_EnterSharpObject(JSContext *cx, JSObject *obj, JSIdArray **idap,
    1:                     jschar **sp)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSHashTable *table;
    1:     JSIdArray *ida;
    1:     JSHashNumber hash;
    1:     JSHashEntry *he, **hep;
    1:     jsatomid sharpid;
    1:     char buf[20];
    1:     size_t len;
    1: 
25087:     if (!JS_CHECK_OPERATION_LIMIT(cx))
    1:         return NULL;
    1: 
    1:     /* Set to null in case we return an early error. */
    1:     *sp = NULL;
    1:     map = &cx->sharpObjectMap;
    1:     table = map->table;
    1:     if (!table) {
    1:         table = JS_NewHashTable(8, js_hash_object, JS_CompareValues,
    1:                                 JS_CompareValues, NULL, NULL);
    1:         if (!table) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1:         map->table = table;
    1:         JS_KEEP_ATOMS(cx->runtime);
    1:     }
    1: 
    1:     /* From this point the control must flow either through out: or bad:. */
    1:     ida = NULL;
    1:     if (map->depth == 0) {
23915:         /*
23915:          * Although MarkSharpObjects tries to avoid invoking getters,
23915:          * it ends up doing so anyway under some circumstances; for
23915:          * example, if a wrapped object has getters, the wrapper will
23915:          * prevent MarkSharpObjects from recognizing them as such.
23915:          * This could lead to js_LeaveSharpObject being called while
23915:          * MarkSharpObjects is still working.
23915:          *
23915:          * Increment map->depth while we call MarkSharpObjects, to
23915:          * ensure that such a call doesn't free the hash table we're
23915:          * still using.
23915:          */
23915:         ++map->depth;
    1:         he = MarkSharpObjects(cx, obj, &ida);
23915:         --map->depth;
    1:         if (!he)
    1:             goto bad;
    1:         JS_ASSERT((JS_PTR_TO_UINT32(he->value) & SHARP_BIT) == 0);
    1:         if (!idap) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             ida = NULL;
    1:         }
    1:     } else {
    1:         hash = js_hash_object(obj);
    1:         hep = JS_HashTableRawLookup(table, hash, obj);
    1:         he = *hep;
    1: 
    1:         /*
    1:          * It's possible that the value of a property has changed from the
    1:          * first time the object's properties are traversed (when the property
    1:          * ids are entered into the hash table) to the second (when they are
31501:          * converted to strings), i.e., the JSObject::getProperty() call is not
    1:          * idempotent.
    1:          */
    1:         if (!he) {
    1:             he = JS_HashTableRawAdd(table, hep, hash, obj, NULL);
    1:             if (!he) {
    1:                 JS_ReportOutOfMemory(cx);
    1:                 goto bad;
    1:             }
    1:             sharpid = 0;
    1:             goto out;
    1:         }
    1:     }
    1: 
    1:     sharpid = JS_PTR_TO_UINT32(he->value);
    1:     if (sharpid != 0) {
    1:         len = JS_snprintf(buf, sizeof buf, "#%u%c",
    1:                           sharpid >> SHARP_ID_SHIFT,
    1:                           (sharpid & SHARP_BIT) ? '#' : '=');
    1:         *sp = js_InflateString(cx, buf, &len);
    1:         if (!*sp) {
    1:             if (ida)
    1:                 JS_DestroyIdArray(cx, ida);
    1:             goto bad;
    1:         }
    1:     }
    1: 
    1: out:
    1:     JS_ASSERT(he);
    1:     if ((sharpid & SHARP_BIT) == 0) {
    1:         if (idap && !ida) {
    1:             ida = JS_Enumerate(cx, obj);
    1:             if (!ida) {
    1:                 if (*sp) {
30851:                     cx->free(*sp);
    1:                     *sp = NULL;
    1:                 }
    1:                 goto bad;
    1:             }
    1:         }
    1:         map->depth++;
    1:     }
    1: 
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: 
    1: bad:
    1:     /* Clean up the sharpObjectMap table on outermost error. */
    1:     if (map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: void
    1: js_LeaveSharpObject(JSContext *cx, JSIdArray **idap)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSIdArray *ida;
    1: 
    1:     map = &cx->sharpObjectMap;
    1:     JS_ASSERT(map->depth > 0);
    1:     if (--map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     if (idap) {
    1:         ida = *idap;
    1:         if (ida) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             *idap = NULL;
    1:         }
    1:     }
    1: }
    1: 
18907: static intN
    1: gc_sharp_table_entry_marker(JSHashEntry *he, intN i, void *arg)
    1: {
  583:     JS_CALL_OBJECT_TRACER((JSTracer *)arg, (JSObject *)he->key,
  583:                           "sharp table entry");
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: void
  583: js_TraceSharpMap(JSTracer *trc, JSSharpObjectMap *map)
    1: {
    1:     JS_ASSERT(map->depth > 0);
    1:     JS_ASSERT(map->table);
    1: 
    1:     /*
    1:      * During recursive calls to MarkSharpObjects a non-native object or
    1:      * object with a custom getProperty method can potentially return an
    1:      * unrooted value or even cut from the object graph an argument of one of
    1:      * MarkSharpObjects recursive invocations. So we must protect map->table
    1:      * entries against GC.
    1:      *
    1:      * We can not simply use JSTempValueRooter to mark the obj argument of
    1:      * MarkSharpObjects during recursion as we have to protect *all* entries
    1:      * in JSSharpObjectMap including those that contains otherwise unreachable
    1:      * objects just allocated through custom getProperty. Otherwise newer
    1:      * allocations can re-use the address of an object stored in the hashtable
    1:      * confusing js_EnterSharpObject. So to address the problem we simply
    1:      * mark all objects from map->table.
    1:      *
    1:      * An alternative "proper" solution is to use JSTempValueRooter in
    1:      * MarkSharpObjects with code to remove during finalization entries
    1:      * with otherwise unreachable objects. But this is way too complex
    1:      * to justify spending efforts.
    1:      */
  583:     JS_HashTableEnumerateEntries(map->table, gc_sharp_table_entry_marker, trc);
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
 4127: static JSBool
 4127: obj_toSource(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSBool ok, outermost;
 4127:     JSObject *obj;
    1:     JSHashEntry *he;
    1:     JSIdArray *ida;
    1:     jschar *chars, *ochars, *vsharp;
    1:     const jschar *idstrchars, *vchars;
    1:     size_t nchars, idstrlength, gsoplength, vlength, vsharplength, curlen;
16069:     const char *comma;
    1:     jsint i, j, length, valcnt;
    1:     jsid id;
    1: #if JS_HAS_GETTER_SETTER
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     uintN attrs;
    1: #endif
    1:     jsval *val;
 6917:     jsval localroot[4] = {JSVAL_NULL, JSVAL_NULL, JSVAL_NULL, JSVAL_NULL};
 6917:     JSTempValueRooter tvr;
 1490:     JSString *gsopold[2];
    1:     JSString *gsop[2];
    1:     JSString *idstr, *valstr, *str;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
18989:     MUST_FLOW_THROUGH("out");
 6917:     JS_PUSH_TEMP_ROOT(cx, 4, localroot, &tvr);
    1: 
    1:     /* If outermost, we need parentheses to be an expression, not a block. */
    1:     outermost = (cx->sharpObjectMap.depth == 0);
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !(he = js_EnterSharpObject(cx, obj, &ida, &chars))) {
 6917:         ok = JS_FALSE;
 6917:         goto out;
 6917:     }
    1:     if (IS_SHARP(he)) {
    1:         /*
    1:          * We didn't enter -- obj is already "sharp", meaning we've visited it
    1:          * already in our depth first search, and therefore chars contains a
    1:          * string of the form "#n#".
    1:          */
    1:         JS_ASSERT(!ida);
    1: #if JS_HAS_SHARP_VARS
    1:         nchars = js_strlen(chars);
    1: #else
    1:         chars[0] = '{';
    1:         chars[1] = '}';
    1:         chars[2] = 0;
    1:         nchars = 2;
    1: #endif
    1:         goto make_string;
    1:     }
    1:     JS_ASSERT(ida);
    1:     ok = JS_TRUE;
    1: 
    1:     if (!chars) {
    1:         /* If outermost, allocate 4 + 1 for "({})" and the terminator. */
30851:         chars = (jschar *) js_malloc(((outermost ? 4 : 2) + 1) * sizeof(jschar));
    1:         nchars = 0;
    1:         if (!chars)
    1:             goto error;
    1:         if (outermost)
    1:             chars[nchars++] = '(';
    1:     } else {
    1:         /* js_EnterSharpObject returned a string of the form "#n=" in chars. */
    1:         MAKE_SHARP(he);
    1:         nchars = js_strlen(chars);
    1:         chars = (jschar *)
30851:             js_realloc((ochars = chars), (nchars + 2 + 1) * sizeof(jschar));
    1:         if (!chars) {
30851:             js_free(ochars);
    1:             goto error;
    1:         }
    1:         if (outermost) {
    1:             /*
    1:              * No need for parentheses around the whole shebang, because #n=
    1:              * unambiguously begins an object initializer, and never a block
    1:              * statement.
    1:              */
    1:             outermost = JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     chars[nchars++] = '{';
    1: 
    1:     comma = NULL;
    1: 
    1:     /*
    1:      * We have four local roots for cooked and raw value GC safety.  Hoist the
 6917:      * "localroot + 2" out of the loop using the val local, which refers to
 6917:      * the raw (unconverted, "uncooked") values.
    1:      */
 6917:     val = localroot + 2;
    1: 
    1:     for (i = 0, length = ida->length; i < length; i++) {
  969:         JSBool idIsLexicalIdentifier, needOldStyleGetterSetter;
  969: 
 4127:         /* Get strings for id and value and GC-root them via vp. */
    1:         id = ida->vector[i];
    1: 
    1: #if JS_HAS_GETTER_SETTER
31501:         ok = obj->lookupProperty(cx, id, &obj2, &prop);
    1:         if (!ok)
    1:             goto error;
  969: #endif
  969: 
  969:         /*
  969:          * Convert id to a jsval and then to a string.  Decide early whether we
  969:          * prefer get/set or old getter/setter syntax.
  969:          */
  969:         idstr = js_ValueToString(cx, ID_TO_VALUE(id));
  969:         if (!idstr) {
  969:             ok = JS_FALSE;
31501:             obj2->dropProperty(cx, prop);
  969:             goto error;
  969:         }
 4127:         *vp = STRING_TO_JSVAL(idstr);                   /* local root */
  969:         idIsLexicalIdentifier = js_IsIdentifier(idstr);
  969:         needOldStyleGetterSetter =
  969:             !idIsLexicalIdentifier ||
29366:             js_CheckKeyword(idstr->chars(), idstr->length()) != TOK_EOF;
  969: 
  969: #if JS_HAS_GETTER_SETTER
  969: 
    1:         valcnt = 0;
    1:         if (prop) {
31501:             ok = obj2->getAttributes(cx, id, prop, &attrs);
    1:             if (!ok) {
31501:                 obj2->dropProperty(cx, prop);
    1:                 goto error;
    1:             }
    1:             if (OBJ_IS_NATIVE(obj2) &&
    1:                 (attrs & (JSPROP_GETTER | JSPROP_SETTER))) {
25218:                 JSScopeProperty *sprop = (JSScopeProperty *) prop;
    1:                 if (attrs & JSPROP_GETTER) {
32658:                     val[valcnt] = sprop->getterValue();
 1490:                     gsopold[valcnt] =
 1490:                         ATOM_TO_STRING(cx->runtime->atomState.getterAtom);
    1:                     gsop[valcnt] =
 1490:                         ATOM_TO_STRING(cx->runtime->atomState.getAtom);
 1677: 
 1677:                     valcnt++;
    1:                 }
    1:                 if (attrs & JSPROP_SETTER) {
32658:                     val[valcnt] = sprop->setterValue();
 1490:                     gsopold[valcnt] =
 1490:                         ATOM_TO_STRING(cx->runtime->atomState.setterAtom);
    1:                     gsop[valcnt] =
 1490:                         ATOM_TO_STRING(cx->runtime->atomState.setAtom);
 1677: 
    1:                     valcnt++;
 1677:                 }
    1:             } else {
    1:                 valcnt = 1;
    1:                 gsop[0] = NULL;
 1490:                 gsopold[0] = NULL;
31501:                 ok = obj->getProperty(cx, id, &val[0]);
31501:             }
31501:             obj2->dropProperty(cx, prop);
    1:         }
    1: 
    1: #else  /* !JS_HAS_GETTER_SETTER */
    1: 
  969:         /*
  969:          * We simplify the source code at the price of minor dead code bloat in
18863:          * the ECMA version (for testing only, see jsversion.h).  The null
  969:          * default values in gsop[j] suffice to disable non-ECMA getter and
  969:          * setter code.
  969:          */
    1:         valcnt = 1;
    1:         gsop[0] = NULL;
 1490:         gsopold[0] = NULL;
31501:         ok = obj->getProperty(cx, id, &val[0]);
    1: 
    1: #endif /* !JS_HAS_GETTER_SETTER */
    1: 
    1:         if (!ok)
    1:             goto error;
    1: 
    1:         /*
    1:          * If id is a string that's not an identifier, then it needs to be
    1:          * quoted.  Also, negative integer ids must be quoted.
    1:          */
 4529:         if (JSID_IS_ATOM(id)
  969:             ? !idIsLexicalIdentifier
 4529:             : (!JSID_IS_INT(id) || JSID_TO_INT(id) < 0)) {
    1:             idstr = js_QuoteString(cx, idstr, (jschar)'\'');
    1:             if (!idstr) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
 4127:             *vp = STRING_TO_JSVAL(idstr);               /* local root */
    1:         }
29366:         idstr->getCharsAndLength(idstrchars, idstrlength);
    1: 
    1:         for (j = 0; j < valcnt; j++) {
    1:             /* Convert val[j] to its canonical source form. */
    1:             valstr = js_ValueToSource(cx, val[j]);
    1:             if (!valstr) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
 6917:             localroot[j] = STRING_TO_JSVAL(valstr);     /* local root */
29366:             valstr->getCharsAndLength(vchars, vlength);
    1: 
 1490:             if (vchars[0] == '#')
 1490:                 needOldStyleGetterSetter = JS_TRUE;
 1490: 
 1490:             if (needOldStyleGetterSetter)
 1490:                 gsop[j] = gsopold[j];
 1490: 
    1:             /* If val[j] is a non-sharp object, consider sharpening it. */
    1:             vsharp = NULL;
    1:             vsharplength = 0;
    1: #if JS_HAS_SHARP_VARS
    1:             if (!JSVAL_IS_PRIMITIVE(val[j]) && vchars[0] != '#') {
    1:                 he = js_EnterSharpObject(cx, JSVAL_TO_OBJECT(val[j]), NULL,
    1:                                          &vsharp);
    1:                 if (!he) {
    1:                     ok = JS_FALSE;
    1:                     goto error;
    1:                 }
    1:                 if (IS_SHARP(he)) {
    1:                     vchars = vsharp;
    1:                     vlength = js_strlen(vchars);
 1490:                     needOldStyleGetterSetter = JS_TRUE;
 1490:                     gsop[j] = gsopold[j];
    1:                 } else {
    1:                     if (vsharp) {
    1:                         vsharplength = js_strlen(vsharp);
    1:                         MAKE_SHARP(he);
 1490:                         needOldStyleGetterSetter = JS_TRUE;
 1490:                         gsop[j] = gsopold[j];
    1:                     }
    1:                     js_LeaveSharpObject(cx, NULL);
    1:                 }
    1:             }
    1: #endif
    1: 
 2149: #ifndef OLD_GETTER_SETTER
 2149:             /*
 2149:              * Remove '(function ' from the beginning of valstr and ')' from the
 2149:              * end so that we can put "get" in front of the function definition.
 2149:              */
 2149:             if (gsop[j] && VALUE_IS_FUNCTION(cx, val[j]) &&
 2149:                 !needOldStyleGetterSetter) {
 2149:                 JSFunction *fun = JS_ValueToFunction(cx, val[j]);
 2149:                 const jschar *start = vchars;
 2149:                 const jschar *end = vchars + vlength;
 2149: 
 2149:                 uint8 parenChomp = 0;
 2149:                 if (vchars[0] == '(') {
 2149:                     vchars++;
 2149:                     parenChomp = 1;
 2149:                 }
 2149: 
 2149:                 /*
 2149:                  * Try to jump "getter" or "setter" keywords, if we suspect
 2149:                  * they might appear here.  This code can be confused by people
 2149:                  * defining Function.prototype.toString, so let's be cautious.
 2149:                  */
 2149:                 if (JSFUN_GETTER_TEST(fun->flags) ||
 2149:                     JSFUN_SETTER_TEST(fun->flags)) { /* skip "getter/setter" */
 2326:                     const jschar *tmp = js_strchr_limit(vchars, ' ', end);
 2326:                     if (tmp)
 2326:                         vchars = tmp + 1;
 2149:                 }
 2149: 
 2149:                 /* Try to jump "function" keyword. */
 2149:                 if (vchars)
 2149:                     vchars = js_strchr_limit(vchars, ' ', end);
 2149: 
 2149:                 if (vchars) {
 2149:                     if (*vchars == ' ')
 2149:                         vchars++;
 2149:                     vlength = end - vchars - parenChomp;
 2149:                 } else {
 2149:                     gsop[j] = NULL;
 2149:                     vchars = start;
 2149:                 }
 2149:             }
 2149: #else
 2149:             needOldStyleGetterSetter = JS_TRUE;
 2149:             gsop[j] = gsopold[j];
 2149: #endif
 2149: 
    1: #define SAFE_ADD(n)                                                          \
    1:     JS_BEGIN_MACRO                                                           \
    1:         size_t n_ = (n);                                                     \
    1:         curlen += n_;                                                        \
    1:         if (curlen < n_)                                                     \
    1:             goto overflow;                                                   \
    1:     JS_END_MACRO
    1: 
    1:             curlen = nchars;
    1:             if (comma)
    1:                 SAFE_ADD(2);
    1:             SAFE_ADD(idstrlength + 1);
    1:             if (gsop[j])
29366:                 SAFE_ADD(gsop[j]->length() + 1);
    1:             SAFE_ADD(vsharplength);
    1:             SAFE_ADD(vlength);
    1:             /* Account for the trailing null. */
    1:             SAFE_ADD((outermost ? 2 : 1) + 1);
    1: #undef SAFE_ADD
    1: 
    1:             if (curlen > (size_t)-1 / sizeof(jschar))
    1:                 goto overflow;
    1: 
    1:             /* Allocate 1 + 1 at end for closing brace and terminating 0. */
    1:             chars = (jschar *)
30851:                 js_realloc((ochars = chars), curlen * sizeof(jschar));
    1:             if (!chars) {
    1:                 /* Save code space on error: let JS_free ignore null vsharp. */
30851:                 cx->free(vsharp);
30851:                 js_free(ochars);
    1:                 goto error;
    1:             }
    1: 
    1:             if (comma) {
    1:                 chars[nchars++] = comma[0];
    1:                 chars[nchars++] = comma[1];
    1:             }
    1:             comma = ", ";
    1: 
  969:             if (needOldStyleGetterSetter) {
  969:                 js_strncpy(&chars[nchars], idstrchars, idstrlength);
  969:                 nchars += idstrlength;
  969:                 if (gsop[j]) {
  969:                     chars[nchars++] = ' ';
29366:                     gsoplength = gsop[j]->length();
29366:                     js_strncpy(&chars[nchars], gsop[j]->chars(),
  969:                                gsoplength);
  969:                     nchars += gsoplength;
  969:                 }
  969:                 chars[nchars++] = ':';
  969:             } else {  /* New style "decompilation" */
    1:                 if (gsop[j]) {
29366:                     gsoplength = gsop[j]->length();
29366:                     js_strncpy(&chars[nchars], gsop[j]->chars(),
  969:                                gsoplength);
    1:                     nchars += gsoplength;
    1:                     chars[nchars++] = ' ';
    1:                 }
    1:                 js_strncpy(&chars[nchars], idstrchars, idstrlength);
    1:                 nchars += idstrlength;
  969:                 /* Extraneous space after id here will be extracted later */
    1:                 chars[nchars++] = gsop[j] ? ' ' : ':';
  969:             }
 1490: 
    1:             if (vsharplength) {
    1:                 js_strncpy(&chars[nchars], vsharp, vsharplength);
    1:                 nchars += vsharplength;
    1:             }
    1:             js_strncpy(&chars[nchars], vchars, vlength);
    1:             nchars += vlength;
    1: 
    1:             if (vsharp)
30851:                 cx->free(vsharp);
    1:         }
    1:     }
    1: 
    1:     chars[nchars++] = '}';
    1:     if (outermost)
    1:         chars[nchars++] = ')';
    1:     chars[nchars] = 0;
    1: 
    1:   error:
    1:     js_LeaveSharpObject(cx, &ida);
    1: 
    1:     if (!ok) {
    1:         if (chars)
30851:             js_free(chars);
 6917:         goto out;
    1:     }
    1: 
    1:     if (!chars) {
    1:         JS_ReportOutOfMemory(cx);
 6917:         ok = JS_FALSE;
 6917:         goto out;
    1:     }
    1:   make_string:
 4718:     str = js_NewString(cx, chars, nchars);
    1:     if (!str) {
30851:         js_free(chars);
 6917:         ok = JS_FALSE;
 6917:         goto out;
    1:     }
 4127:     *vp = STRING_TO_JSVAL(str);
 6917:     ok = JS_TRUE;
 6917:   out:
 6917:     JS_POP_TEMP_ROOT(cx, &tvr);
 6917:     return ok;
    1: 
    1:   overflow:
30851:     cx->free(vsharp);
30851:     js_free(chars);
    1:     chars = NULL;
    1:     goto error;
    1: }
    1: #endif /* JS_HAS_TOSOURCE */
    1: 
 4127: static JSBool
 4127: obj_toString(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     JSObject *obj;
    1:     jschar *chars;
    1:     size_t nchars;
    1:     const char *clazz, *prefix;
    1:     JSString *str;
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj)
11809:         return JS_FALSE;
12674:     obj = js_GetWrappedObject(cx, obj);
    1:     clazz = OBJ_GET_CLASS(cx, obj)->name;
    1:     nchars = 9 + strlen(clazz);         /* 9 for "[object ]" */
30851:     chars = (jschar *) cx->malloc((nchars + 1) * sizeof(jschar));
    1:     if (!chars)
    1:         return JS_FALSE;
    1: 
    1:     prefix = "[object ";
    1:     nchars = 0;
    1:     while ((chars[nchars] = (jschar)*prefix) != 0)
    1:         nchars++, prefix++;
    1:     while ((chars[nchars] = (jschar)*clazz) != 0)
    1:         nchars++, clazz++;
    1:     chars[nchars++] = ']';
    1:     chars[nchars] = 0;
    1: 
 4718:     str = js_NewString(cx, chars, nchars);
    1:     if (!str) {
30851:         cx->free(chars);
    1:         return JS_FALSE;
    1:     }
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: obj_toLocaleString(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     jsval thisv;
    1:     JSString *str;
    1: 
11809:     thisv = JS_THIS(cx, vp);
11809:     if (JSVAL_IS_NULL(thisv))
11809:         return JS_FALSE;
11809: 
11809:     str = js_ValueToString(cx, thisv);
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: obj_valueOf(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     *vp = JS_THIS(cx, vp);
11809:     return !JSVAL_IS_NULL(*vp);
    1: }
    1: 
23075: #ifdef JS_TRACER
23075: static jsval FASTCALL
23075: Object_p_valueOf(JSContext* cx, JSObject* obj, JSString *hint)
23075: {
23075:     return OBJECT_TO_JSVAL(obj);
23075: }
23075: #endif
23075: 
    1: /*
    1:  * Check whether principals subsumes scopeobj's principals, and return true
    1:  * if so (or if scopeobj has no principals, for backward compatibility with
    1:  * the JS API, which does not require principals), and false otherwise.
    1:  */
    1: JSBool
    1: js_CheckPrincipalsAccess(JSContext *cx, JSObject *scopeobj,
    1:                          JSPrincipals *principals, JSAtom *caller)
    1: {
18870:     JSSecurityCallbacks *callbacks;
    1:     JSPrincipals *scopePrincipals;
    1:     const char *callerstr;
    1: 
18870:     callbacks = JS_GetSecurityCallbacks(cx);
18870:     if (callbacks && callbacks->findObjectPrincipals) {
18870:         scopePrincipals = callbacks->findObjectPrincipals(cx, scopeobj);
    1:         if (!principals || !scopePrincipals ||
    1:             !principals->subsume(principals, scopePrincipals)) {
    1:             callerstr = js_AtomToPrintableString(cx, caller);
    1:             if (!callerstr)
    1:                 return JS_FALSE;
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_INDIRECT_CALL, callerstr);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
    1: js_CheckScopeChainValidity(JSContext *cx, JSObject *scopeobj, const char *caller)
    1: {
    1:     JSClass *clasp;
    1:     JSExtendedClass *xclasp;
    1:     JSObject *inner;
    1: 
    1:     if (!scopeobj)
    1:         goto bad;
    1: 
    1:     OBJ_TO_INNER_OBJECT(cx, scopeobj);
    1:     if (!scopeobj)
    1:         return NULL;
    1: 
    1:     inner = scopeobj;
    1: 
    1:     /* XXX This is an awful gross hack. */
    1:     while (scopeobj) {
    1:         clasp = OBJ_GET_CLASS(cx, scopeobj);
    1:         if (clasp->flags & JSCLASS_IS_EXTENDED) {
    1:             xclasp = (JSExtendedClass*)clasp;
    1:             if (xclasp->innerObject &&
    1:                 xclasp->innerObject(cx, scopeobj) != scopeobj) {
    1:                 goto bad;
    1:             }
    1:         }
    1: 
    1:         scopeobj = OBJ_GET_PARENT(cx, scopeobj);
    1:     }
    1: 
    1:     return inner;
    1: 
    1: bad:
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                          JSMSG_BAD_INDIRECT_CALL, caller);
    1:     return NULL;
    1: }
    1: 
12690: const char *
12690: js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
12690:                    JSPrincipals *principals, uintN *linenop)
12690: {
12690:     uint32 flags;
18870: #ifdef DEBUG
18870:     JSSecurityCallbacks *callbacks = JS_GetSecurityCallbacks(cx);
18870: #endif
18870: 
18870:     JS_ASSERT(principals || !(callbacks  && callbacks->findObjectPrincipals));
12690:     flags = JS_GetScriptFilenameFlags(caller->script);
12690:     if ((flags & JSFILENAME_PROTECTED) &&
18472:         principals &&
12690:         strcmp(principals->codebase, "[System Principal]")) {
12690:         *linenop = 0;
12690:         return principals->codebase;
12690:     }
12690: 
29901:     if (caller->regs && js_GetOpcode(cx, caller->script, caller->regs->pc) == JSOP_EVAL) {
29901:         JS_ASSERT(js_GetOpcode(cx, caller->script, caller->regs->pc + JSOP_EVAL_LENGTH) == JSOP_LINENO);
29901:         *linenop = GET_UINT16(caller->regs->pc + JSOP_EVAL_LENGTH);
13504:     } else {
21685:         *linenop = js_FramePCToLineNumber(cx, caller);
13504:     }
12690:     return caller->script->filename;
12690: }
12690: 
24375: #ifndef EVAL_CACHE_CHAIN_LIMIT
24375: # define EVAL_CACHE_CHAIN_LIMIT 4
24375: #endif
24375: 
24375: static inline JSScript **
24375: EvalCacheHash(JSContext *cx, JSString *str)
24375: {
24375:     const jschar *s;
24375:     size_t n;
24375:     uint32 h;
24375: 
29366:     str->getCharsAndLength(s, n);
24375:     if (n > 100)
24375:         n = 100;
24375:     for (h = 0; n; s++, n--)
24375:         h = JS_ROTATE_LEFT32(h, 4) ^ *s;
24375: 
24375:     h *= JS_GOLDEN_RATIO;
24375:     h >>= 32 - JS_EVAL_CACHE_SHIFT;
24375:     return &JS_SCRIPTS_TO_GC(cx)[h];
24375: }
24375: 
20408: static JSBool
20408: obj_eval(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
33271:     JSStackFrame *fp, *caller, *callerFrame;
    1:     JSBool indirectCall;
24375:     JSPrincipals *principals;
    1:     const char *file;
    1:     uintN line;
24375:     JSString *str;
    1:     JSScript *script;
    1:     JSBool ok;
24375:     JSScript **bucket = NULL;   /* avoid GCC warning with early decl&init */
 6766: #if JS_HAS_EVAL_THIS_SCOPE
 6766:     JSObject *callerScopeChain = NULL, *callerVarObj = NULL;
33188:     JSBool setCallerScopeChain = JS_FALSE, setCallerVarObj = JS_FALSE;
34311:     JSTempValueRooter scopetvr, varobjtvr;
 6766: #endif
    1: 
22652:     fp = js_GetTopStackFrame(cx);
22652:     caller = js_GetScriptedCaller(cx, fp);
33188:     if (!caller) {
33188:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
33188:                              JSMSG_BAD_INDIRECT_CALL, js_eval_str);
33188:         return JS_FALSE;
33188:     }
33188: 
33188:     indirectCall = (caller->regs && *caller->regs->pc != JSOP_EVAL);
    1: 
 2112:     /*
25744:      * This call to js_GetWrappedObject is safe because of the security checks
25744:      * we do below. However, the control flow below is confusing, so we double
25744:      * check. There are two cases:
25744:      * - Direct call: This object is never used. So unwrapping can't hurt.
25744:      * - Indirect call: If this object isn't already the scope chain (which
25744:      *   we're guaranteed to be allowed to access) then we do a security
25744:      *   check.
25744:      */
25744:     obj = js_GetWrappedObject(cx, obj);
25744: 
25744:     /*
 2112:      * Ban all indirect uses of eval (global.foo = eval; global.foo(...)) and
 2112:      * calls that attempt to use a non-global object as the "with" object in
 2112:      * the former indirect case.
 2112:      */
25744:     {
25744:         JSObject *parent = OBJ_GET_PARENT(cx, obj);
25744:         if (indirectCall || parent) {
25744:             uintN flags = parent
 2157:                           ? JSREPORT_ERROR
 2157:                           : JSREPORT_STRICT | JSREPORT_WARNING;
 2157:             if (!JS_ReportErrorFlagsAndNumber(cx, flags, js_GetErrorMessage, NULL,
 2157:                                               JSMSG_BAD_INDIRECT_CALL,
 2157:                                               js_eval_str)) {
    1:                 return JS_FALSE;
    1:             }
 2157:         }
25744:     }
    1: 
    1:     if (!JSVAL_IS_STRING(argv[0])) {
    1:         *rval = argv[0];
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /*
    1:      * If the caller is a lightweight function and doesn't have a variables
    1:      * object, then we need to provide one for the compiler to stick any
    1:      * declared (var) variables into.
    1:      */
33188:     if (!caller->varobj && !js_GetCallObject(cx, caller))
    1:         return JS_FALSE;
    1: 
23064:     /* Accept an optional trailing argument that overrides the scope object. */
25744:     JSObject *scopeobj = NULL;
23064:     if (argc >= 2) {
23064:         if (!js_ValueToObject(cx, argv[1], &scopeobj))
    1:             return JS_FALSE;
23064:         argv[1] = OBJECT_TO_JSVAL(scopeobj);
    1:     }
    1: 
11437:     /* From here on, control must exit through label out with ok set. */
18989:     MUST_FLOW_THROUGH("out");
33188:     uintN staticLevel = caller->script->staticLevel + 1;
    1:     if (!scopeobj) {
 6766: #if JS_HAS_EVAL_THIS_SCOPE
33188:         /*
33188:          * If we see an indirect call, then run eval in the global scope. We do
33188:          * this so the compiler can make assumptions about what bindings may or
33188:          * may not exist in the current frame if it doesn't see 'eval'.
33188:          */
 6766:         if (indirectCall) {
33188:             /* Pretend that we're top level. */
33188:             staticLevel = 0;
33188: 
 6766:             callerScopeChain = js_GetScopeChain(cx, caller);
11437:             if (!callerScopeChain) {
11437:                 ok = JS_FALSE;
11437:                 goto out;
11437:             }
33188: 
 6766:             OBJ_TO_INNER_OBJECT(cx, obj);
11437:             if (!obj) {
11437:                 ok = JS_FALSE;
11437:                 goto out;
11437:             }
33188: 
11437:             ok = js_CheckPrincipalsAccess(cx, obj,
22962:                                           JS_StackFramePrincipals(cx, caller),
11437:                                           cx->runtime->atomState.evalAtom);
11437:             if (!ok)
11437:                 goto out;
 6766: 
33188:             /* NB: We know obj is a global object here. */
33188:             JS_ASSERT(!OBJ_GET_PARENT(cx, obj));
33188:             scopeobj = obj;
 6766: 
 6766:             /* Set fp->scopeChain too, for the compiler. */
 6766:             caller->scopeChain = fp->scopeChain = scopeobj;
 6766: 
 6766:             /* Remember scopeobj so we can null its private when done. */
33188:             setCallerScopeChain = JS_TRUE;
34311:             JS_PUSH_TEMP_ROOT_OBJECT(cx, callerScopeChain, &scopetvr);
 6766: 
 6766:             callerVarObj = caller->varobj;
 6766:             if (obj != callerVarObj) {
 6766:                 /* Set fp->varobj too, for the compiler. */
 6766:                 caller->varobj = fp->varobj = obj;
 6766:                 setCallerVarObj = JS_TRUE;
34311:                 JS_PUSH_TEMP_ROOT_OBJECT(cx, callerVarObj, &varobjtvr);
 6766:             }
 6766:         }
 6766: #endif
 6766: 
 2112:         /*
 2112:          * Compile using caller's current scope object.
 2112:          *
 2112:          * NB: This means that native callers (who reach this point through
 2112:          * the C API) must use the two parameter form.
 2112:          */
 2112:         scopeobj = js_GetScopeChain(cx, caller);
 6766:         if (!scopeobj) {
 6766:             ok = JS_FALSE;
 6766:             goto out;
 6766:         }
23064:     } else {
25744:         scopeobj = js_GetWrappedObject(cx, scopeobj);
25744:         OBJ_TO_INNER_OBJECT(cx, scopeobj);
25744:         if (!scopeobj) {
25744:             ok = JS_FALSE;
25744:             goto out;
25744:         }
33188: 
23064:         ok = js_CheckPrincipalsAccess(cx, scopeobj,
23064:                                       JS_StackFramePrincipals(cx, caller),
23064:                                       cx->runtime->atomState.evalAtom);
23064:         if (!ok)
23064:             goto out;
23064: 
33188:         /* We're pretending that we're in global code. */
33188:         staticLevel = 0;
    1:     }
    1: 
    1:     /* Ensure we compile this eval with the right object in the scope chain. */
    1:     scopeobj = js_CheckScopeChainValidity(cx, scopeobj, js_eval_str);
 6766:     if (!scopeobj) {
 6766:         ok = JS_FALSE;
 6766:         goto out;
 6766:     }
    1: 
 2452:     principals = JS_EvalFramePrincipals(cx, fp, caller);
12690:     file = js_ComputeFilename(cx, caller, principals, &line);
24375: 
24375:     str = JSVAL_TO_STRING(argv[0]);
24375:     script = NULL;
24375: 
24375:     /* Cache local eval scripts indexed by source qualified by scope. */
24375:     bucket = EvalCacheHash(cx, str);
33188:     if (!indirectCall && caller->fun) {
24375:         uintN count = 0;
24375:         JSScript **scriptp = bucket;
24375: 
24375:         EVAL_CACHE_METER(probe);
24375:         while ((script = *scriptp) != NULL) {
33750:             if (script->savedCallerFun &&
24375:                 script->version == cx->version &&
24375:                 (script->principals == principals ||
24375:                  (principals->subsume(principals, script->principals) &&
24375:                   script->principals->subsume(script->principals, principals)))) {
24375:                 /*
24375:                  * Get the prior (cache-filling) eval's saved caller function.
27012:                  * See JSCompiler::compileScript in jsparse.cpp.
24375:                  */
34290:                 JSFunction *fun = script->getFunction(0);
24375: 
24375:                 if (fun == caller->fun) {
24375:                     /*
24375:                      * Get the source string passed for safekeeping in the
27012:                      * atom map by the prior eval to JSCompiler::compileScript.
24375:                      */
24375:                     JSString *src = ATOM_TO_STRING(script->atomMap.vector[0]);
24375: 
24375:                     if (src == str || js_EqualStrings(src, str)) {
24375:                         /*
24375:                          * Source matches, qualify by comparing scopeobj to the
24375:                          * COMPILE_N_GO-memoized parent of the first literal
24375:                          * function or regexp object if any. If none, then this
24375:                          * script has no compiled-in dependencies on the prior
24375:                          * eval's scopeobj.
24375:                          */
32723:                         JSObjectArray *objarray = script->objects();
24375:                         int i = 1;
34290: 
24375:                         if (objarray->length == 1) {
24375:                             if (script->regexpsOffset != 0) {
32723:                                 objarray = script->regexps();
24375:                                 i = 0;
24375:                             } else {
24375:                                 EVAL_CACHE_METER(noscope);
24375:                                 i = -1;
24375:                             }
24375:                         }
24375:                         if (i < 0 ||
24375:                             STOBJ_GET_PARENT(objarray->vector[i]) == scopeobj) {
24375:                             EVAL_CACHE_METER(hit);
24375:                             *scriptp = script->u.nextToGC;
24375:                             script->u.nextToGC = NULL;
24375:                             break;
24375:                         }
24375:                     }
24375:                 }
24375:             }
24375: 
24375:             if (++count == EVAL_CACHE_CHAIN_LIMIT) {
24375:                 script = NULL;
24375:                 break;
24375:             }
24375:             EVAL_CACHE_METER(step);
24375:             scriptp = &script->u.nextToGC;
24375:         }
24375:     }
24375: 
33281:     /*
33281:      * We can't have a callerFrame (down in js_Execute's terms) if we're in
33281:      * global code. This includes indirect eval and direct eval called with a
33281:      * scope object parameter.
33281:      */
33271:     callerFrame = (staticLevel != 0) ? caller : NULL;
24375:     if (!script) {
33188:         script = JSCompiler::compileScript(cx, scopeobj, callerFrame,
34290:                                            principals,
34290:                                            TCF_COMPILE_N_GO | TCF_NEED_MUTABLE_SCRIPT,
29366:                                            str->chars(), str->length(),
33751:                                            NULL, file, line, str, staticLevel);
 6766:         if (!script) {
 6766:             ok = JS_FALSE;
 6766:             goto out;
 6766:         }
24375:     }
    1: 
    1:     if (argc < 2) {
    1:         /* Execute using caller's new scope object (might be a Call object). */
    1:         scopeobj = caller->scopeChain;
    1:     }
    1: 
    1:     /*
    1:      * Belt-and-braces: check that the lesser of eval's principals and the
    1:      * caller's principals has access to scopeobj.
    1:      */
    1:     ok = js_CheckPrincipalsAccess(cx, scopeobj, principals,
    1:                                   cx->runtime->atomState.evalAtom);
    1:     if (ok)
33271:         ok = js_Execute(cx, scopeobj, script, callerFrame, JSFRAME_EVAL, rval);
    1: 
24375:     script->u.nextToGC = *bucket;
24375:     *bucket = script;
18316: #ifdef CHECK_SCRIPT_OWNER
18316:     script->owner = NULL;
18316: #endif
 6766: 
 6766: out:
 6766: #if JS_HAS_EVAL_THIS_SCOPE
 6766:     /* Restore OBJ_GET_PARENT(scopeobj) not callerScopeChain in case of Call. */
34311:     if (setCallerVarObj) {
34311:         caller->varobj = callerVarObj;
34311:         JS_POP_TEMP_ROOT(cx, &varobjtvr);
34311:     }
34311:     if (setCallerScopeChain) {
 6766:         caller->scopeChain = callerScopeChain;
34311:         JS_POP_TEMP_ROOT(cx, &scopetvr);
34311:     }
 6766: #endif
    1:     return ok;
    1: }
    1: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: 
    1: static JSBool
    1: obj_watch_handler(JSContext *cx, JSObject *obj, jsval id, jsval old, jsval *nvp,
    1:                   void *closure)
    1: {
    1:     JSObject *callable;
18870:     JSSecurityCallbacks *callbacks;
    1:     JSStackFrame *caller;
    1:     JSPrincipals *subject, *watcher;
    1:     JSResolvingKey key;
    1:     JSResolvingEntry *entry;
    1:     uint32 generation;
    1:     jsval argv[3];
    1:     JSBool ok;
    1: 
    1:     callable = (JSObject *) closure;
    1: 
18870:     callbacks = JS_GetSecurityCallbacks(cx);
18870:     if (callbacks && callbacks->findObjectPrincipals) {
    1:         /* Skip over any obj_watch_* frames between us and the real subject. */
22652:         caller = js_GetScriptedCaller(cx, NULL);
    1:         if (caller) {
    1:             /*
    1:              * Only call the watch handler if the watcher is allowed to watch
    1:              * the currently executing script.
    1:              */
18870:             watcher = callbacks->findObjectPrincipals(cx, callable);
    1:             subject = JS_StackFramePrincipals(cx, caller);
    1: 
    1:             if (watcher && subject && !watcher->subsume(watcher, subject)) {
    1:                 /* Silently don't call the watch handler. */
    1:                 return JS_TRUE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     /* Avoid recursion on (obj, id) already being watched on cx. */
    1:     key.obj = obj;
    1:     key.id = id;
    1:     if (!js_StartResolving(cx, &key, JSRESFLAG_WATCH, &entry))
    1:         return JS_FALSE;
    1:     if (!entry)
    1:         return JS_TRUE;
    1:     generation = cx->resolvingTable->generation;
    1: 
    1:     argv[0] = id;
    1:     argv[1] = old;
    1:     argv[2] = *nvp;
    1:     ok = js_InternalCall(cx, obj, OBJECT_TO_JSVAL(callable), 3, argv, nvp);
    1:     js_StopResolving(cx, &key, JSRESFLAG_WATCH, entry, generation);
    1:     return ok;
    1: }
    1: 
    1: static JSBool
 4127: obj_watch(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSObject *callable;
    1:     jsval userid, value;
    1:     jsid propid;
 4127:     JSObject *obj;
    1:     uintN attrs;
    1: 
16519:     if (argc <= 1) {
16519:         js_ReportMissingArg(cx, vp, 1);
16519:         return JS_FALSE;
16519:     }
16519: 
 4127:     callable = js_ValueToCallableObject(cx, &vp[3], 0);
    1:     if (!callable)
    1:         return JS_FALSE;
    1: 
    1:     /* Compute the unique int/atom symbol id needed by js_LookupProperty. */
 4127:     userid = vp[2];
    1:     if (!JS_ValueToId(cx, userid, &propid))
    1:         return JS_FALSE;
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
31501:     if (!obj || !obj->checkAccess(cx, propid, JSACC_WATCH, &value, &attrs))
    1:         return JS_FALSE;
    1:     if (attrs & JSPROP_READONLY)
    1:         return JS_TRUE;
 4127:     *vp = JSVAL_VOID;
15602: 
15602:     if (OBJ_IS_DENSE_ARRAY(cx, obj) && !js_MakeArraySlow(cx, obj))
15602:         return JS_FALSE;
    1:     return JS_SetWatchPoint(cx, obj, userid, obj_watch_handler, callable);
    1: }
    1: 
    1: static JSBool
 4127: obj_unwatch(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     JSObject *obj;
11809: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj)
11809:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
16519:     return JS_ClearWatchPoint(cx, obj, argc != 0 ? vp[2] : JSVAL_VOID,
16519:                               NULL, NULL);
    1: }
    1: 
    1: #endif /* JS_HAS_OBJ_WATCHPOINT */
    1: 
    1: /*
    1:  * Prototype and property query methods, to complement the 'in' and
    1:  * 'instanceof' operators.
    1:  */
    1: 
    1: /* Proposed ECMA 15.2.4.5. */
20408: static JSBool
20408: obj_hasOwnProperty(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 4127: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     return obj &&
16519:            js_HasOwnPropertyHelper(cx, obj->map->ops->lookupProperty, argc, vp);
    1: }
    1: 
    1: JSBool
16519: js_HasOwnPropertyHelper(JSContext *cx, JSLookupPropOp lookup, uintN argc,
16519:                         jsval *vp)
    1: {
    1:     jsid id;
16519:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
    1:         return JS_FALSE;
32721: 
32721:     JSBool found;
32721:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
32721:     if (!obj || !js_HasOwnProperty(cx, lookup, obj, id, &found))
32721:         return JS_FALSE;
32721:     *vp = BOOLEAN_TO_JSVAL(found);
32721:     return JS_TRUE;
18062: }
18062: 
18062: JSBool
18062: js_HasOwnProperty(JSContext *cx, JSLookupPropOp lookup, JSObject *obj, jsid id,
32721:                   JSBool *foundp)
18062: {
18062:     JSObject *obj2;
18062:     JSProperty *prop;
18062:     JSScopeProperty *sprop;
18062: 
18062:     if (!lookup(cx, obj, id, &obj2, &prop))
    1:         return JS_FALSE;
    1:     if (!prop) {
32721:         *foundp = JS_FALSE;
    1:     } else if (obj2 == obj) {
32721:         *foundp = JS_TRUE;
    1:     } else {
    1:         JSClass *clasp;
    1:         JSExtendedClass *xclasp;
 4780:         JSObject *outer;
 4780: 
 4780:         clasp = OBJ_GET_CLASS(cx, obj2);
 4780:         if (!(clasp->flags & JSCLASS_IS_EXTENDED) ||
 4780:             !(xclasp = (JSExtendedClass *) clasp)->outerObject) {
 4780:             outer = NULL;
 4780:         } else {
 4780:             outer = xclasp->outerObject(cx, obj2);
 4780:             if (!outer)
 4780:                 return JS_FALSE;
 4780:         }
 4780:         if (outer == obj) {
32721:             *foundp = JS_TRUE;
 4843:         } else if (OBJ_IS_NATIVE(obj2) && OBJ_GET_CLASS(cx, obj) == clasp) {
    1:             /*
    1:              * The combination of JSPROP_SHARED and JSPROP_PERMANENT in a
    1:              * delegated property makes that property appear to be direct in
    1:              * all delegating instances of the same native class.  This hack
    1:              * avoids bloating every function instance with its own 'length'
    1:              * (AKA 'arity') property.  But it must not extend across class
    1:              * boundaries, to avoid making hasOwnProperty lie (bug 320854).
    1:              *
    1:              * It's not really a hack, of course: a permanent property can't
    1:              * be deleted, and JSPROP_SHARED means "don't allocate a slot in
    1:              * any instance, prototype or delegating".  Without a slot, and
    1:              * without the ability to remove and recreate (with differences)
    1:              * the property, there is no way to tell whether it is directly
    1:              * owned, or indirectly delegated.
    1:              */
    1:             sprop = (JSScopeProperty *)prop;
32721:             *foundp = SPROP_IS_SHARED_PERMANENT(sprop);
    1:         } else {
32721:             *foundp = JS_FALSE;
    1:         }
    1:     }
    1:     if (prop)
31501:         obj2->dropProperty(cx, prop);
    1:     return JS_TRUE;
    1: }
    1: 
20408: #ifdef JS_TRACER
26395: static JSBool FASTCALL
20915: Object_p_hasOwnProperty(JSContext* cx, JSObject* obj, JSString *str)
20408: {
20927:     jsid id;
32721:     JSBool found;
20927: 
24614:     if (!js_ValueToStringId(cx, STRING_TO_JSVAL(str), &id) ||
32721:         !js_HasOwnProperty(cx, obj->map->ops->lookupProperty, obj, id, &found)) {
27166:         js_SetBuiltinError(cx);
20927:         return JSVAL_TO_BOOLEAN(JSVAL_VOID);
24614:     }
24614: 
32721:     return found;
20408: }
20408: #endif
20408: 
    1: /* Proposed ECMA 15.2.4.6. */
    1: static JSBool
 4127: obj_isPrototypeOf(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSBool b;
    1: 
16519:     if (!js_IsDelegate(cx, JS_THIS_OBJECT(cx, vp),
16519:                        argc != 0 ? vp[2] : JSVAL_VOID, &b)) {
    1:         return JS_FALSE;
16519:     }
 4127:     *vp = BOOLEAN_TO_JSVAL(b);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* Proposed ECMA 15.2.4.7. */
20408: static JSBool
20408: obj_propertyIsEnumerable(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsid id;
18062:     JSObject *obj;
18062: 
18062:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
18062:         return JS_FALSE;
18062: 
18062:     obj = JS_THIS_OBJECT(cx, vp);
18062:     return obj && js_PropertyIsEnumerable(cx, obj, id, vp);
18062: }
18062: 
20408: #ifdef JS_TRACER
26395: static JSBool FASTCALL
20915: Object_p_propertyIsEnumerable(JSContext* cx, JSObject* obj, JSString *str)
20408: {
20408:     jsid id = ATOM_TO_JSID(STRING_TO_JSVAL(str));
20408:     jsval v;
24614: 
24614:     if (!js_PropertyIsEnumerable(cx, obj, id, &v)) {
27166:         js_SetBuiltinError(cx);
20408:         return JSVAL_TO_BOOLEAN(JSVAL_VOID);
24614:     }
24614: 
20408:     JS_ASSERT(JSVAL_IS_BOOLEAN(v));
20408:     return JSVAL_TO_BOOLEAN(v);
20408: }
20408: #endif
20408: 
18062: JSBool
18062: js_PropertyIsEnumerable(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
18062: {
18062:     JSObject *pobj;
    1:     uintN attrs;
    1:     JSProperty *prop;
    1:     JSBool ok;
    1: 
31501:     if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
    1: 
    1:     if (!prop) {
 4127:         *vp = JSVAL_FALSE;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /*
    1:      * XXX ECMA spec error compatible: return false unless hasOwnProperty.
    1:      * The ECMA spec really should be fixed so propertyIsEnumerable and the
    1:      * for..in loop agree on whether prototype properties are enumerable,
    1:      * obviously by fixing this method (not by breaking the for..in loop!).
    1:      *
    1:      * We check here for shared permanent prototype properties, which should
    1:      * be treated as if they are local to obj.  They are an implementation
    1:      * technique used to satisfy ECMA requirements; users should not be able
    1:      * to distinguish a shared permanent proto-property from a local one.
    1:      */
 4127:     if (pobj != obj &&
 4127:         !(OBJ_IS_NATIVE(pobj) &&
    1:           SPROP_IS_SHARED_PERMANENT((JSScopeProperty *)prop))) {
31501:         pobj->dropProperty(cx, prop);
 4127:         *vp = JSVAL_FALSE;
    1:         return JS_TRUE;
    1:     }
    1: 
31501:     ok = pobj->getAttributes(cx, id, prop, &attrs);
31501:     pobj->dropProperty(cx, prop);
    1:     if (ok)
 4127:         *vp = BOOLEAN_TO_JSVAL((attrs & JSPROP_ENUMERATE) != 0);
    1:     return ok;
    1: }
    1: 
    1: #if JS_HAS_GETTER_SETTER
24145: JS_FRIEND_API(JSBool)
24145: js_obj_defineGetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsval fval, junk;
    1:     jsid id;
 4127:     JSObject *obj;
    1:     uintN attrs;
    1: 
16519:     if (argc <= 1 || JS_TypeOfValue(cx, vp[3]) != JSTYPE_FUNCTION) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_GETTER_OR_SETTER,
    1:                              js_getter_str);
    1:         return JS_FALSE;
    1:     }
16519:     fval = vp[3];
    1: 
 4127:     if (!JS_ValueToId(cx, vp[2], &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_CheckRedeclaration(cx, obj, id, JSPROP_GETTER, NULL, NULL))
    1:         return JS_FALSE;
    1:     /*
    1:      * Getters and setters are just like watchpoints from an access
    1:      * control point of view.
    1:      */
31501:     if (!obj->checkAccess(cx, id, JSACC_WATCH, &junk, &attrs))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
31501:     return obj->defineProperty(cx, id, JSVAL_VOID,
32573:                                js_CastAsPropertyOp(JSVAL_TO_OBJECT(fval)), JS_PropertyStub,
32573:                                JSPROP_ENUMERATE | JSPROP_GETTER | JSPROP_SHARED);
    1: }
    1: 
24145: JS_FRIEND_API(JSBool)
24145: js_obj_defineSetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsval fval, junk;
    1:     jsid id;
 4127:     JSObject *obj;
    1:     uintN attrs;
    1: 
16519:     if (argc <= 1 || JS_TypeOfValue(cx, vp[3]) != JSTYPE_FUNCTION) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_GETTER_OR_SETTER,
    1:                              js_setter_str);
    1:         return JS_FALSE;
    1:     }
16519:     fval = vp[3];
    1: 
 4127:     if (!JS_ValueToId(cx, vp[2], &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_CheckRedeclaration(cx, obj, id, JSPROP_SETTER, NULL, NULL))
    1:         return JS_FALSE;
    1:     /*
    1:      * Getters and setters are just like watchpoints from an access
    1:      * control point of view.
    1:      */
31501:     if (!obj->checkAccess(cx, id, JSACC_WATCH, &junk, &attrs))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
31501:     return obj->defineProperty(cx, id, JSVAL_VOID,
32573:                                JS_PropertyStub, js_CastAsPropertyOp(JSVAL_TO_OBJECT(fval)),
32573:                                JSPROP_ENUMERATE | JSPROP_SETTER | JSPROP_SHARED);
    1: }
    1: 
    1: static JSBool
 4127: obj_lookupGetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsid id;
11809:     JSObject *obj, *pobj;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1: 
16519:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
31501:     if (!obj || !obj->lookupProperty(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
    1:     if (prop) {
    1:         if (OBJ_IS_NATIVE(pobj)) {
    1:             sprop = (JSScopeProperty *) prop;
    1:             if (sprop->attrs & JSPROP_GETTER)
32658:                 *vp = sprop->getterValue();
    1:         }
31501:         pobj->dropProperty(cx, prop);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: obj_lookupSetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsid id;
11809:     JSObject *obj, *pobj;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1: 
16519:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
31501:     if (!obj || !obj->lookupProperty(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
    1:     if (prop) {
    1:         if (OBJ_IS_NATIVE(pobj)) {
    1:             sprop = (JSScopeProperty *) prop;
    1:             if (sprop->attrs & JSPROP_SETTER)
32658:                 *vp = sprop->setterValue();
    1:         }
31501:         pobj->dropProperty(cx, prop);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: #endif /* JS_HAS_GETTER_SETTER */
    1: 
16380: JSBool
16380: obj_getPrototypeOf(JSContext *cx, uintN argc, jsval *vp)
16380: {
16380:     JSObject *obj;
16380:     uintN attrs;
16380: 
16519:     if (argc == 0) {
16519:         js_ReportMissingArg(cx, vp, 0);
16519:         return JS_FALSE;
16519:     }
16519: 
31844:     if (JSVAL_IS_PRIMITIVE(vp[2])) {
33166:         char *bytes = js_DecompileValueGenerator(cx, 0 - argc, vp[2], NULL);
31844:         if (!bytes)
16380:             return JS_FALSE;
31844:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
31844:                              JSMSG_UNEXPECTED_TYPE, bytes, "not an object");
31844:         JS_free(cx, bytes);
31844:         return JS_FALSE;
31844:     }
31844: 
31844:     obj = JSVAL_TO_OBJECT(vp[2]);
31501:     return obj->checkAccess(cx, ATOM_TO_JSID(cx->runtime->atomState.protoAtom),
16380:                             JSACC_PROTO, vp, &attrs);
16380: }
16380: 
32721: static JSBool
32721: obj_getOwnPropertyDescriptor(JSContext *cx, uintN argc, jsval *vp)
32721: {
32721:     if (argc == 0 || JSVAL_IS_PRIMITIVE(vp[2])) {
32721:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
32721:         return JS_FALSE;
32721:     }
32721: 
32721:     JSObject *obj = JSVAL_TO_OBJECT(vp[2]);
32721: 
32721:     JSAutoTempIdRooter nameidr(cx);
32721:     if (!JS_ValueToId(cx, argc >= 2 ? vp[3] : JSVAL_VOID, nameidr.addr()))
32721:         return JS_FALSE;
32721: 
32721:     JSBool found;
32721:     if (!js_HasOwnProperty(cx, obj->map->ops->lookupProperty, obj, nameidr.id(), &found))
32721:         return JS_FALSE;
32721:     if (!found) {
32721:         *vp = JSVAL_VOID;
32721:         return JS_TRUE;
32721:     }
32721: 
32721:     JSObject *pobj;
32721:     JSProperty *prop;
32721:     if (!obj->lookupProperty(cx, nameidr.id(), &pobj, &prop))
32721:         return JS_FALSE;
32721:     JS_ASSERT(prop);
32721: 
32721:     JSBool ok = JS_FALSE;
32721:     uintN attrs;
32721:     JSAtomState &atomState = cx->runtime->atomState;
32724:     JSObject *desc;
32721:     MUST_FLOW_THROUGH("drop_property");
32721: 
32721:     if (!pobj->getAttributes(cx, nameidr.id(), prop, &attrs))
32721:         goto drop_property;
32721: 
32721:     /* We have our own property, so start creating the descriptor. */
32722:     desc = js_NewObject(cx, &js_ObjectClass, NULL, NULL);
32721:     if (!desc)
32721:         goto drop_property;
32721:     *vp = OBJECT_TO_JSVAL(desc); /* Root and return. */
32721: 
32721:     if (!(attrs & (JSPROP_GETTER | JSPROP_SETTER))) {
32721:         JSAutoTempValueRooter tvr(cx);
32721:         if (!obj->getProperty(cx, nameidr.id(), tvr.addr()) ||
32721:             !desc->defineProperty(cx, ATOM_TO_JSID(atomState.valueAtom), tvr.value(),
32721:                                   JS_PropertyStub, JS_PropertyStub, JSPROP_ENUMERATE) ||
32721:             !desc->defineProperty(cx, ATOM_TO_JSID(atomState.writableAtom),
32721:                                   BOOLEAN_TO_JSVAL((attrs & JSPROP_READONLY) == 0),
32721:                                   JS_PropertyStub, JS_PropertyStub, JSPROP_ENUMERATE)) {
32721:             goto drop_property;
32721:         }
32721:     } else {
32721:         jsval getter = JSVAL_VOID, setter = JSVAL_VOID;
32721:         if (OBJ_IS_NATIVE(obj)) {
32721:             JSScopeProperty *sprop = reinterpret_cast<JSScopeProperty *>(prop);
32721:             if (attrs & JSPROP_GETTER)
32721:                 getter = js_CastAsObjectJSVal(sprop->getter);
32721:             if (attrs & JSPROP_SETTER)
32721:                 setter = js_CastAsObjectJSVal(sprop->setter);
32721:         }
32721:         if (!desc->defineProperty(cx, ATOM_TO_JSID(atomState.getAtom),
32721:                                   getter, JS_PropertyStub, JS_PropertyStub,
32721:                                   JSPROP_ENUMERATE) ||
32721:             !desc->defineProperty(cx, ATOM_TO_JSID(atomState.setAtom),
32721:                                   setter, JS_PropertyStub, JS_PropertyStub,
32721:                                   JSPROP_ENUMERATE)) {
32721:             goto drop_property;
32721:         }
32721:     }
32721: 
32721:     ok = desc->defineProperty(cx, ATOM_TO_JSID(atomState.enumerableAtom),
32721:                               BOOLEAN_TO_JSVAL((attrs & JSPROP_ENUMERATE) != 0),
32721:                               JS_PropertyStub, JS_PropertyStub, JSPROP_ENUMERATE) &&
32721:          desc->defineProperty(cx, ATOM_TO_JSID(atomState.configurableAtom),
32721:                               BOOLEAN_TO_JSVAL((attrs & JSPROP_PERMANENT) == 0),
32721:                               JS_PropertyStub, JS_PropertyStub, JSPROP_ENUMERATE);
32721: 
32721:   drop_property:
32721:     pobj->dropProperty(cx, prop);
32721:     return ok;
32721: }
32721: 
33155: static JSBool
33155: obj_keys(JSContext *cx, uintN argc, jsval *vp)
33155: {
33155:     jsval v = argc == 0 ? JSVAL_VOID : vp[2];
33155:     if (JSVAL_IS_PRIMITIVE(v)) {
33155:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
33155:         return JS_FALSE;
33155:     }
33155: 
33155:     JSObject *obj = JSVAL_TO_OBJECT(v);
33155:     JSAutoIdArray ida(cx, JS_Enumerate(cx, obj));
33155:     if (!ida)
33155:         return JS_FALSE;
33155: 
33155:     JSObject *proto;
33155:     if (!js_GetClassPrototype(cx, NULL, INT_TO_JSID(JSProto_Array), &proto))
33155:         return JS_FALSE;
33155:     vp[1] = OBJECT_TO_JSVAL(proto);
33155: 
33160:     JS_ASSERT(ida.length() <= UINT32_MAX);
33160:     JSObject *aobj = js_NewArrayWithSlots(cx, proto, uint32(ida.length()));
33155:     if (!aobj)
33155:         return JS_FALSE;
33155:     *vp = OBJECT_TO_JSVAL(aobj);
33155: 
33638:     JS_ASSERT(DSLOTS_IS_NOT_NULL(aobj));
33155:     jsval *slots = aobj->dslots;
33155:     size_t len = ida.length();
33155:     JS_ASSERT(js_DenseArrayCapacity(aobj) >= len);
33155:     for (size_t i = 0; i < len; i++) {
33155:         jsid id = ida[i];
33155:         if (JSID_IS_INT(id)) {
33155:             if (!js_ValueToStringId(cx, INT_JSID_TO_JSVAL(id), &slots[i]))
33155:                 return JS_FALSE;
33155:         } else {
33155:             /*
33155:              * Object-valued ids are a possibility admitted by SpiderMonkey for
33155:              * the purposes of E4X.  It's unclear whether they could ever be
33155:              * detected here -- the "obvious" possibility, a property referred
33155:              * to by a QName, actually appears as a string jsid -- but in the
33155:              * interests of fidelity we pass object jsids through unchanged.
33155:              */
33155:             slots[i] = ID_TO_VALUE(id);
33155:         }
33155:     }
33155: 
33175:     JS_ASSERT(len <= UINT32_MAX);
33175:     aobj->fslots[JSSLOT_ARRAY_COUNT] = len;
33175: 
33155:     return JS_TRUE;
33155: }
33155: 
32721: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: const char js_watch_str[] = "watch";
    1: const char js_unwatch_str[] = "unwatch";
    1: #endif
    1: const char js_hasOwnProperty_str[] = "hasOwnProperty";
    1: const char js_isPrototypeOf_str[] = "isPrototypeOf";
    1: const char js_propertyIsEnumerable_str[] = "propertyIsEnumerable";
    1: #if JS_HAS_GETTER_SETTER
    1: const char js_defineGetter_str[] = "__defineGetter__";
    1: const char js_defineSetter_str[] = "__defineSetter__";
    1: const char js_lookupGetter_str[] = "__lookupGetter__";
    1: const char js_lookupSetter_str[] = "__lookupSetter__";
    1: #endif
    1: 
23075: JS_DEFINE_TRCINFO_1(obj_valueOf,
23075:     (3, (static, JSVAL,     Object_p_valueOf,               CONTEXT, THIS, STRING,  0, 0)))
20930: JS_DEFINE_TRCINFO_1(obj_hasOwnProperty,
24614:     (3, (static, BOOL_FAIL, Object_p_hasOwnProperty,        CONTEXT, THIS, STRING,  0, 0)))
20930: JS_DEFINE_TRCINFO_1(obj_propertyIsEnumerable,
24614:     (3, (static, BOOL_FAIL, Object_p_propertyIsEnumerable,  CONTEXT, THIS, STRING,  0, 0)))
20408: 
    1: static JSFunctionSpec object_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,             obj_toSource,                0,0),
    1: #endif
16519:     JS_FN(js_toString_str,             obj_toString,                0,0),
16519:     JS_FN(js_toLocaleString_str,       obj_toLocaleString,          0,0),
32669:     JS_TN(js_valueOf_str,              obj_valueOf,                 0,0, &obj_valueOf_trcinfo),
    1: #if JS_HAS_OBJ_WATCHPOINT
16519:     JS_FN(js_watch_str,                obj_watch,                   2,0),
16519:     JS_FN(js_unwatch_str,              obj_unwatch,                 1,0),
    1: #endif
32669:     JS_TN(js_hasOwnProperty_str,       obj_hasOwnProperty,          1,0, &obj_hasOwnProperty_trcinfo),
16519:     JS_FN(js_isPrototypeOf_str,        obj_isPrototypeOf,           1,0),
32669:     JS_TN(js_propertyIsEnumerable_str, obj_propertyIsEnumerable,    1,0, &obj_propertyIsEnumerable_trcinfo),
    1: #if JS_HAS_GETTER_SETTER
24145:     JS_FN(js_defineGetter_str,         js_obj_defineGetter,         2,0),
24145:     JS_FN(js_defineSetter_str,         js_obj_defineSetter,         2,0),
16519:     JS_FN(js_lookupGetter_str,         obj_lookupGetter,            1,0),
16519:     JS_FN(js_lookupSetter_str,         obj_lookupSetter,            1,0),
    1: #endif
 4127:     JS_FS_END
    1: };
    1: 
16380: static JSFunctionSpec object_static_methods[] = {
16519:     JS_FN("getPrototypeOf",            obj_getPrototypeOf,          1,0),
32721:     JS_FN("getOwnPropertyDescriptor",  obj_getOwnPropertyDescriptor,2,0),
33155:     JS_FN("keys",                      obj_keys,                    1,0),
16380:     JS_FS_END
16380: };
16380: 
30732: static bool
30732: AllocSlots(JSContext *cx, JSObject *obj, size_t nslots);
30732: 
26822: static inline bool
32615: InitScopeForObject(JSContext* cx, JSObject* obj, JSObject* proto, JSObjectOps* ops)
26822: {
28353:     JS_ASSERT(OPS_IS_NATIVE(ops));
28353:     JS_ASSERT(proto == OBJ_GET_PROTO(cx, obj));
28353: 
30645:     /* Share proto's emptyScope only if obj is similar to proto. */
32615:     JSClass *clasp = OBJ_GET_CLASS(cx, obj);
30645:     JSScope *scope;
30645:     if (proto && js_ObjectIsSimilarToProto(cx, obj, ops, clasp, proto)) {
30645:         scope = OBJ_SCOPE(proto)->getEmptyScope(cx, clasp);
30645:         if (!scope)
30645:             goto bad;
30645:     } else {
32652:         scope = JSScope::create(cx, ops, clasp, obj, js_GenerateShape(cx, false));
28353:         if (!scope)
28353:             goto bad;
28353: 
30258:         /* Let JSScope::create set freeslot so as to reserve slots. */
28353:         JS_ASSERT(scope->freeslot >= JSSLOT_PRIVATE);
28353:         if (scope->freeslot > JS_INITIAL_NSLOTS &&
30732:             !AllocSlots(cx, obj, scope->freeslot)) {
30258:             JSScope::destroy(cx, scope);
28353:             goto bad;
28353:         }
30645:     }
32777:     obj->map = scope;
28353:     return true;
28353: 
28353:   bad:
32777:     /* The GC nulls map initially. It should still be null on error. */
32777:     JS_ASSERT(!obj->map);
26822:     return false;
26822: }
26822: 
30439: JSObject *
30439: js_NewObjectWithGivenProto(JSContext *cx, JSClass *clasp, JSObject *proto,
30439:                            JSObject *parent, size_t objectSize)
30439: {
30439: #ifdef INCLUDE_MOZILLA_DTRACE
30439:     if (JAVASCRIPT_OBJECT_CREATE_START_ENABLED())
30439:         jsdtrace_object_create_start(cx->fp, clasp);
30439: #endif
30439: 
30439:     /* Assert that the class is a proper class. */
30439:     JS_ASSERT_IF(clasp->flags & JSCLASS_IS_EXTENDED,
30439:                  ((JSExtendedClass *)clasp)->equality);
30439: 
30439:     /* Always call the class's getObjectOps hook if it has one. */
30439:     JSObjectOps *ops = clasp->getObjectOps
30439:                        ? clasp->getObjectOps(cx, clasp)
30439:                        : &js_ObjectOps;
30439: 
30439:     /*
30439:      * Allocate an object from the GC heap and initialize all its fields before
30439:      * doing any operation that can potentially trigger GC. Functions have a
30439:      * larger non-standard allocation size.
30439:      */
30439:     JSObject* obj;
30439:     if (clasp == &js_FunctionClass && !objectSize) {
33581:         obj = (JSObject*) js_NewGCFunction(cx);
30439: #ifdef DEBUG
30439:         memset((uint8 *) obj + sizeof(JSObject), JS_FREE_PATTERN,
30439:                sizeof(JSFunction) - sizeof(JSObject));
30439: #endif
30439:     } else {
30439:         JS_ASSERT(!objectSize || objectSize == sizeof(JSObject));
33581:         obj = js_NewGCObject(cx);
30439:     }
30439:     if (!obj)
30439:         goto out;
30439: 
30439:     /*
30439:      * Default parent to the parent of the prototype, which was set from
30439:      * the parent of the prototype's constructor.
30439:      */
32684:     obj->init(clasp,
32684:               proto,
32684:               (!parent && proto) ? proto->getParent() : parent,
33694:               JSObject::defaultPrivate(clasp),
33694:               OPS_IS_NATIVE(ops) ? DSLOTS_NULL_INIT_OBJECT_NATIVE : DSLOTS_NULL_INIT_OBJECT_NONNATIVE);
30439: 
30439:     if (OPS_IS_NATIVE(ops)) {
32615:         if (!InitScopeForObject(cx, obj, proto, ops)) {
30439:             obj = NULL;
30439:             goto out;
30439:         }
30439:     } else {
30439:         JS_ASSERT(ops->objectMap->ops == ops);
30439:         obj->map = const_cast<JSObjectMap *>(ops->objectMap);
30439:     }
30439: 
30439:     /*
30439:      * Do not call debug hooks on trace, because we might be in a non-_FAIL
30439:      * builtin. See bug 481444.
30439:      */
30439:     if (cx->debugHooks->objectHook && !JS_ON_TRACE(cx)) {
30439:         JSAutoTempValueRooter tvr(cx, obj);
30439:         JS_KEEP_ATOMS(cx->runtime);
30439:         cx->debugHooks->objectHook(cx, obj, JS_TRUE,
30439:                                    cx->debugHooks->objectHookData);
30439:         JS_UNKEEP_ATOMS(cx->runtime);
33952:         cx->weakRoots.finalizableNewborns[FINALIZE_OBJECT] = obj;
30439:     }
30439: 
30439: out:
30439: #ifdef INCLUDE_MOZILLA_DTRACE
30439:     if (JAVASCRIPT_OBJECT_CREATE_ENABLED())
30439:         jsdtrace_object_create(cx, clasp, obj);
30439:     if (JAVASCRIPT_OBJECT_CREATE_DONE_ENABLED())
30439:         jsdtrace_object_create_done(cx->fp, clasp);
30439: #endif
30439:     return obj;
30439: }
30439: 
30439: JSObject *
30439: js_NewObject(JSContext *cx, JSClass *clasp, JSObject *proto,
30439:              JSObject *parent, size_t objectSize)
30439: {
30439:     jsid id;
30439: 
30439:     /* Bootstrap the ur-object, and make it the default prototype object. */
30439:     if (!proto) {
30439:         if (!js_GetClassId(cx, clasp, &id))
30439:             return NULL;
30439:         if (!js_GetClassPrototype(cx, parent, id, &proto))
30439:             return NULL;
30439:         if (!proto &&
30439:             !js_GetClassPrototype(cx, parent, INT_TO_JSID(JSProto_Object),
30439:                                   &proto)) {
30439:             return NULL;
30439:         }
30439:     }
30439: 
30439:     return js_NewObjectWithGivenProto(cx, clasp, proto, parent, objectSize);
30439: }
30439: 
30439: JSBool
30439: js_Object(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
30439: {
30439:     if (argc == 0) {
30439:         /* Trigger logic below to construct a blank object. */
30439:         obj = NULL;
30439:     } else {
30439:         /* If argv[0] is null or undefined, obj comes back null. */
30439:         if (!js_ValueToObject(cx, argv[0], &obj))
30439:             return JS_FALSE;
30439:     }
30439:     if (!obj) {
30439:         JS_ASSERT(!argc || JSVAL_IS_NULL(argv[0]) || JSVAL_IS_VOID(argv[0]));
30439:         if (JS_IsConstructing(cx))
30439:             return JS_TRUE;
30439:         obj = js_NewObject(cx, &js_ObjectClass, NULL, NULL);
30439:         if (!obj)
30439:             return JS_FALSE;
30439:     }
30439:     *rval = OBJECT_TO_JSVAL(obj);
30439:     return JS_TRUE;
30439: }
30439: 
32615: #ifdef JS_TRACER
32615: 
32615: static inline JSObject*
32684: NewNativeObject(JSContext* cx, JSClass* clasp, JSObject* proto,
32684:                 JSObject *parent, jsval privateSlotValue)
32615: {
32615:     JS_ASSERT(JS_ON_TRACE(cx));
33581:     JSObject* obj = js_NewGCObject(cx);
32615:     if (!obj)
32615:         return NULL;
32615: 
33694:     obj->init(clasp, proto, parent, privateSlotValue, DSLOTS_NULL_INIT_NATIVE);
32615:     return InitScopeForObject(cx, obj, proto, &js_ObjectOps) ? obj : NULL;
32615: }
32615: 
32615: JSObject* FASTCALL
32615: js_Object_tn(JSContext* cx, JSObject* proto)
32615: {
32684:     JS_ASSERT(!(js_ObjectClass.flags & JSCLASS_HAS_PRIVATE));
32684:     return NewNativeObject(cx, &js_ObjectClass, proto, proto->getParent(),
32684:                            JSVAL_VOID);
32615: }
32615: 
32615: JS_DEFINE_TRCINFO_1(js_Object,
32615:     (2, (extern, CONSTRUCTOR_RETRY, js_Object_tn, CONTEXT, CALLEE_PROTOTYPE, 0, 0)))
32615: 
32615: JSObject* FASTCALL
32615: js_NewInstance(JSContext *cx, JSClass *clasp, JSObject *ctor)
32615: {
32615:     JS_ASSERT(HAS_FUNCTION_CLASS(ctor));
32615: 
32615:     JSAtom *atom = cx->runtime->atomState.classPrototypeAtom;
32615: 
32615:     JSScope *scope = OBJ_SCOPE(ctor);
32615: #ifdef JS_THREADSAFE
32615:     if (scope->title.ownercx != cx)
32615:         return NULL;
32615: #endif
32615:     if (!scope->owned()) {
32615:         scope = js_GetMutableScope(cx, ctor);
32615:         if (!scope)
32615:             return NULL;
32615:     }
32615: 
32615:     JSScopeProperty *sprop = scope->lookup(ATOM_TO_JSID(atom));
32615:     jsval pval = sprop ? STOBJ_GET_SLOT(ctor, sprop->slot) : JSVAL_HOLE;
32615: 
32615:     JSObject *proto;
32615:     if (!JSVAL_IS_PRIMITIVE(pval)) {
32615:         /* An object in ctor.prototype, let's use it as the new instance's proto. */
32615:         proto = JSVAL_TO_OBJECT(pval);
32615:     } else if (pval == JSVAL_HOLE) {
32615:         /* No ctor.prototype yet, inline and optimize fun_resolve's prototype code. */
32615:         proto = js_NewObject(cx, clasp, NULL, OBJ_GET_PARENT(cx, ctor));
32615:         if (!proto)
32615:             return NULL;
32615:         if (!js_SetClassPrototype(cx, ctor, proto, JSPROP_ENUMERATE | JSPROP_PERMANENT))
32615:             return NULL;
32615:     } else {
32615:         /* Primitive value in .prototype means we use Object.prototype for proto. */
32615:         if (!js_GetClassPrototype(cx, JSVAL_TO_OBJECT(ctor->fslots[JSSLOT_PARENT]),
32615:                                   INT_TO_JSID(JSProto_Object), &proto)) {
32615:             return NULL;
32615:         }
32615:     }
32615: 
32684:     return NewNativeObject(cx, clasp, proto, ctor->getParent(),
32684:                            JSObject::defaultPrivate(clasp));
32615: }
32615: 
32615: JS_DEFINE_CALLINFO_3(extern, CONSTRUCTOR_RETRY, js_NewInstance, CONTEXT, CLASS, OBJECT, 0, 0)
32615: 
32615: #else  /* !JS_TRACER */
32615: 
32615: # define js_Object_trcinfo NULL
32615: 
32615: #endif /* !JS_TRACER */
32615: 
    1: /*
23435:  * Given pc pointing after a property accessing bytecode, return true if the
23435:  * access is "object-detecting" in the sense used by web scripts, e.g., when
23435:  * checking whether document.all is defined.
23435:  */
30034: JS_REQUIRES_STACK JSBool
23435: Detecting(JSContext *cx, jsbytecode *pc)
23435: {
23435:     JSScript *script;
25474:     jsbytecode *endpc;
23435:     JSOp op;
23435:     JSAtom *atom;
23435: 
23435:     script = cx->fp->script;
25474:     endpc = script->code + script->length;
25215:     for (;; pc += js_CodeSpec[op].length) {
31814:         JS_ASSERT_IF(!cx->fp->imacpc, script->code <= pc && pc < endpc);
25474: 
23435:         /* General case: a branch or equality op follows the access. */
25215:         op = js_GetOpcode(cx, script, pc);
23435:         if (js_CodeSpec[op].format & JOF_DETECTING)
23435:             return JS_TRUE;
23435: 
23435:         switch (op) {
23435:           case JSOP_NULL:
23435:             /*
23435:              * Special case #1: handle (document.all == null).  Don't sweat
23435:              * about JS1.2's revision of the equality operators here.
23435:              */
25474:             if (++pc < endpc) {
25215:                 op = js_GetOpcode(cx, script, pc);
25474:                 return *pc == JSOP_EQ || *pc == JSOP_NE;
25474:             }
25474:             return JS_FALSE;
23435: 
23435:           case JSOP_NAME:
23435:             /*
23435:              * Special case #2: handle (document.all == undefined).  Don't
23435:              * worry about someone redefining undefined, which was added by
23435:              * Edition 3, so is read/write for backward compatibility.
23435:              */
23435:             GET_ATOM_FROM_BYTECODE(script, pc, 0, atom);
25474:             if (atom == cx->runtime->atomState.typeAtoms[JSTYPE_VOID] &&
25474:                 (pc += js_CodeSpec[op].length) < endpc) {
25215:                 op = js_GetOpcode(cx, script, pc);
23435:                 return op == JSOP_EQ || op == JSOP_NE ||
23435:                        op == JSOP_STRICTEQ || op == JSOP_STRICTNE;
23435:             }
23435:             return JS_FALSE;
23435: 
23435:           default:
23435:             /*
23435:              * At this point, anything but an extended atom index prefix means
23435:              * we're not detecting.
23435:              */
23435:             if (!(js_CodeSpec[op].format & JOF_INDEXBASE))
23435:                 return JS_FALSE;
23435:             break;
23435:         }
23435:     }
23435: }
23435: 
23435: /*
23435:  * Infer lookup flags from the currently executing bytecode. This does
23435:  * not attempt to infer JSRESOLVE_WITH, because the current bytecode
23435:  * does not indicate whether we are in a with statement. Return defaultFlags
23435:  * if a currently executing bytecode cannot be determined.
23435:  */
30034: uintN
30034: js_InferFlags(JSContext *cx, uintN defaultFlags)
23435: {
30035: #ifdef JS_TRACER
30034:     if (JS_ON_TRACE(cx))
30034:         return cx->bailExit->lookupFlags;
30035: #endif
30034: 
30034:     JS_ASSERT_NOT_ON_TRACE(cx);
30034: 
23435:     JSStackFrame *fp;
23435:     jsbytecode *pc;
23435:     const JSCodeSpec *cs;
23435:     uint32 format;
23435:     uintN flags = 0;
23435: 
23435:     fp = js_GetTopStackFrame(cx);
23435:     if (!fp || !fp->regs)
23435:         return defaultFlags;
23435:     pc = fp->regs->pc;
25215:     cs = &js_CodeSpec[js_GetOpcode(cx, fp->script, pc)];
23435:     format = cs->format;
23435:     if (JOF_MODE(format) != JOF_NAME)
23435:         flags |= JSRESOLVE_QUALIFIED;
23435:     if ((format & (JOF_SET | JOF_FOR)) ||
23435:         (fp->flags & JSFRAME_ASSIGNING)) {
23435:         flags |= JSRESOLVE_ASSIGNING;
32680:     } else if (cs->length >= 0) {
23435:         pc += cs->length;
25474:         if (pc < cx->fp->script->code + cx->fp->script->length && Detecting(cx, pc))
23435:             flags |= JSRESOLVE_DETECTING;
23435:     }
23435:     if (format & JOF_DECLARING)
23435:         flags |= JSRESOLVE_DECLARING;
23435:     return flags;
23435: }
23435: 
23435: /*
    1:  * ObjectOps and Class for with-statement stack objects.
    1:  */
    1: static JSBool
    1: with_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                     JSProperty **propp)
    1: {
23435:     /* Fixes bug 463997 */
23435:     uintN flags = cx->resolveFlags;
23435:     if (flags == JSRESOLVE_INFER)
30034:         flags = js_InferFlags(cx, flags);
23435:     flags |= JSRESOLVE_WITH;
23435:     JSAutoResolveFlags rf(cx, flags);
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_LookupProperty(cx, obj, id, objp, propp);
31501:     return proto->lookupProperty(cx, id, objp, propp);
    1: }
    1: 
    1: static JSBool
    1: with_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_GetProperty(cx, obj, id, vp);
31501:     return proto->getProperty(cx, id, vp);
    1: }
    1: 
    1: static JSBool
    1: with_SetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_SetProperty(cx, obj, id, vp);
31501:     return proto->setProperty(cx, id, vp);
    1: }
    1: 
    1: static JSBool
    1: with_GetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                    uintN *attrsp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_GetAttributes(cx, obj, id, prop, attrsp);
31501:     return proto->getAttributes(cx, id, prop, attrsp);
    1: }
    1: 
    1: static JSBool
    1: with_SetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                    uintN *attrsp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_SetAttributes(cx, obj, id, prop, attrsp);
31501:     return proto->setAttributes(cx, id, prop, attrsp);
    1: }
    1: 
    1: static JSBool
    1: with_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, jsval *rval)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_DeleteProperty(cx, obj, id, rval);
31501:     return proto->deleteProperty(cx, id, rval);
    1: }
    1: 
    1: static JSBool
    1: with_DefaultValue(JSContext *cx, JSObject *obj, JSType hint, jsval *vp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_DefaultValue(cx, obj, hint, vp);
31501:     return proto->defaultValue(cx, hint, vp);
    1: }
    1: 
    1: static JSBool
    1: with_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
    1:                jsval *statep, jsid *idp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_Enumerate(cx, obj, enum_op, statep, idp);
31501:     return proto->enumerate(cx, enum_op, statep, idp);
    1: }
    1: 
    1: static JSBool
    1: with_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
    1:                  jsval *vp, uintN *attrsp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_CheckAccess(cx, obj, id, mode, vp, attrsp);
31501:     return proto->checkAccess(cx, id, mode, vp, attrsp);
    1: }
    1: 
    1: static JSObject *
    1: with_ThisObject(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return obj;
31501:     return proto->thisObject(cx);
    1: }
    1: 
    1: JS_FRIEND_DATA(JSObjectOps) js_WithObjectOps = {
28353:     NULL,
    1:     with_LookupProperty,    js_DefineProperty,
    1:     with_GetProperty,       with_SetProperty,
    1:     with_GetAttributes,     with_SetAttributes,
    1:     with_DeleteProperty,    with_DefaultValue,
    1:     with_Enumerate,         with_CheckAccess,
    1:     with_ThisObject,        NATIVE_DROP_PROPERTY,
    1:     NULL,                   NULL,
26828:     NULL,                   js_TraceObject,
32603:     js_Clear
    1: };
    1: 
    1: static JSObjectOps *
    1: with_getObjectOps(JSContext *cx, JSClass *clasp)
    1: {
    1:     return &js_WithObjectOps;
    1: }
    1: 
    1: JSClass js_WithClass = {
    1:     "With",
    1:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_IS_ANONYMOUS,
    1:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
30654:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   NULL,
    1:     with_getObjectOps,
    1:     0,0,0,0,0,0,0
    1: };
    1: 
22652: JS_REQUIRES_STACK JSObject *
    1: js_NewWithObject(JSContext *cx, JSObject *proto, JSObject *parent, jsint depth)
    1: {
    1:     JSObject *obj;
    1: 
30439:     obj = js_NewObject(cx, &js_WithClass, proto, parent);
    1:     if (!obj)
    1:         return NULL;
31452:     obj->setPrivate(cx->fp);
    1:     OBJ_SET_BLOCK_DEPTH(cx, obj, depth);
    1:     return obj;
    1: }
    1: 
    1: JSObject *
    1: js_NewBlockObject(JSContext *cx)
    1: {
    1:     /*
    1:      * Null obj's proto slot so that Object.prototype.* does not pollute block
28093:      * scopes and to give the block object its own scope.
    1:      */
30645:     JSObject *blockObj = js_NewObjectWithGivenProto(cx, &js_BlockClass, NULL, NULL);
28093:     JS_ASSERT_IF(blockObj, !OBJ_IS_CLONED_BLOCK(blockObj));
28093:     return blockObj;
    1: }
    1: 
    1: JSObject *
30645: js_CloneBlockObject(JSContext *cx, JSObject *proto, JSStackFrame *fp)
    1: {
30645:     JS_ASSERT(!OBJ_IS_CLONED_BLOCK(proto));
14860:     JS_ASSERT(STOBJ_GET_CLASS(proto) == &js_BlockClass);
30645: 
33581:     JSObject *clone = js_NewGCObject(cx);
    1:     if (!clone)
    1:         return NULL;
30645: 
30645:     JSScope *scope = OBJ_SCOPE(proto);
30645:     scope->hold();
32717:     JS_ASSERT(!scope->owned());
32777:     clone->map = scope;
30645: 
30645:     clone->classword = jsuword(&js_BlockClass);
32603:     clone->setProto(proto);
32603:     clone->setParent(NULL);  // caller's responsibility
31452:     clone->setPrivate(fp);
30645:     clone->fslots[JSSLOT_BLOCK_DEPTH] = proto->fslots[JSSLOT_BLOCK_DEPTH];
30645:     JS_ASSERT(scope->freeslot == JSSLOT_BLOCK_DEPTH + 1);
30645:     for (uint32 i = JSSLOT_BLOCK_DEPTH + 1; i < JS_INITIAL_NSLOTS; ++i)
30645:         clone->fslots[i] = JSVAL_VOID;
33638:     clone->dslots = DSLOTS_NULL_CLONE_BLOCK_OBJECT;
14860:     JS_ASSERT(OBJ_IS_CLONED_BLOCK(clone));
    1:     return clone;
    1: }
    1: 
22652: JS_REQUIRES_STACK JSBool
11859: js_PutBlockObject(JSContext *cx, JSBool normalUnwind)
    1: {
 3457:     JSStackFrame *fp;
11859:     JSObject *obj;
14860:     uintN depth, count;
14860: 
14860:     /* Blocks have one fixed slot available for the first local.*/
14860:     JS_STATIC_ASSERT(JS_INITIAL_NSLOTS == JSSLOT_BLOCK_DEPTH + 2);
 3457: 
11859:     fp = cx->fp;
11859:     obj = fp->scopeChain;
11859:     JS_ASSERT(OBJ_GET_CLASS(cx, obj) == &js_BlockClass);
32684:     JS_ASSERT(obj->getPrivate() == cx->fp);
14860:     JS_ASSERT(OBJ_IS_CLONED_BLOCK(obj));
14860: 
14860:     /*
14860:      * Block objects should never be exposed to scripts. Thus the clone should
14860:      * not own the property map and rather always share it with the prototype
28353:      * object. This allows us to skip updating OBJ_SCOPE(obj)->freeslot after
14860:      * we copy the stack slots into reserved slots.
14860:      */
14860:     JS_ASSERT(OBJ_SCOPE(obj)->object != obj);
14860: 
14860:     /* Block objects should not have reserved slots before they are put. */
14860:     JS_ASSERT(STOBJ_NSLOTS(obj) == JS_INITIAL_NSLOTS);
14860: 
14860:     /* The block and its locals must be on the current stack for GC safety. */
 3457:     depth = OBJ_BLOCK_DEPTH(cx, obj);
14860:     count = OBJ_BLOCK_COUNT(cx, obj);
16072:     JS_ASSERT(depth <= (size_t) (fp->regs->sp - StackBase(fp)));
16072:     JS_ASSERT(count <= (size_t) (fp->regs->sp - StackBase(fp) - depth));
14860: 
32725:     /* See comments in CheckDestructuring from jsparse.cpp. */
14860:     JS_ASSERT(count >= 1);
14860: 
16072:     depth += fp->script->nfixed;
16072:     obj->fslots[JSSLOT_BLOCK_DEPTH + 1] = fp->slots[depth];
14860:     if (normalUnwind && count > 1) {
14860:         --count;
14860:         JS_LOCK_OBJ(cx, obj);
30732:         if (!AllocSlots(cx, obj, JS_INITIAL_NSLOTS + count))
11758:             normalUnwind = JS_FALSE;
14860:         else
16072:             memcpy(obj->dslots, fp->slots + depth + 1, count * sizeof(jsval));
14860:         JS_UNLOCK_OBJ(cx, obj);
14860:     }
14860: 
11758:     /* We must clear the private slot even with errors. */
31452:     obj->setPrivate(NULL);
11859:     fp->scopeChain = OBJ_GET_PARENT(cx, obj);
11758:     return normalUnwind;
    1: }
    1: 
    1: static JSBool
    1: block_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
32717:     /*
32717:      * Block objects are never exposed to script, and the engine handles them
32717:      * with care. So unlike other getters, this one can assert (rather than
32717:      * check) certain invariants about obj.
32717:      */
32717:     JS_ASSERT(obj->getClass() == &js_BlockClass);
14860:     JS_ASSERT(OBJ_IS_CLONED_BLOCK(obj));
32717:     uintN index = (uintN) JSVAL_TO_INT(id);
32717:     JS_ASSERT(index < OBJ_BLOCK_COUNT(cx, obj));
32717: 
31452:     JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
14860:     if (fp) {
16072:         index += fp->script->nfixed + OBJ_BLOCK_DEPTH(cx, obj);
16072:         JS_ASSERT(index < fp->script->nslots);
16072:         *vp = fp->slots[index];
32717:         return true;
32717:     }
32717: 
32717:     /* Values are in reserved slots immediately following DEPTH. */
32717:     uint32 slot = JSSLOT_BLOCK_DEPTH + 1 + index;
32717:     JS_LOCK_OBJ(cx, obj);
32717:     JS_ASSERT(slot < STOBJ_NSLOTS(obj));
32717:     *vp = STOBJ_GET_SLOT(obj, slot);
32717:     JS_UNLOCK_OBJ(cx, obj);
32717:     return true;
14860: }
14860: 
14860: static JSBool
14860: block_setProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
14860: {
32717:     JS_ASSERT(obj->getClass() == &js_BlockClass);
32717:     JS_ASSERT(OBJ_IS_CLONED_BLOCK(obj));
32717:     uintN index = (uintN) JSVAL_TO_INT(id);
32717:     JS_ASSERT(index < OBJ_BLOCK_COUNT(cx, obj));
32717: 
31452:     JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
14860:     if (fp) {
16072:         index += fp->script->nfixed + OBJ_BLOCK_DEPTH(cx, obj);
16072:         JS_ASSERT(index < fp->script->nslots);
16072:         fp->slots[index] = *vp;
32717:         return true;
32717:     }
32717: 
32717:     /* Values are in reserved slots immediately following DEPTH. */
32717:     uint32 slot = JSSLOT_BLOCK_DEPTH + 1 + index;
32717:     JS_LOCK_OBJ(cx, obj);
32717:     JS_ASSERT(slot < STOBJ_NSLOTS(obj));
32717:     STOBJ_SET_SLOT(obj, slot, *vp);
32717:     JS_UNLOCK_OBJ(cx, obj);
32717:     return true;
32717: }
32717: 
32717: JSBool
33166: js_DefineBlockVariable(JSContext *cx, JSObject *obj, jsid id, intN index)
32717: {
32717:     JS_ASSERT(obj->getClass() == &js_BlockClass);
32717:     JS_ASSERT(!OBJ_IS_CLONED_BLOCK(obj));
32717: 
32717:     /* Use JSPROP_ENUMERATE to aid the disassembler. */
32717:     return js_DefineNativeProperty(cx, obj, id, JSVAL_VOID,
32717:                                    block_getProperty, block_setProperty,
32717:                                    JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_SHARED,
32717:                                    SPROP_HAS_SHORTID, index, NULL);
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
 3235: #define NO_PARENT_INDEX ((uint32)-1)
 3235: 
 3235: uint32
 3235: FindObjectIndex(JSObjectArray *array, JSObject *obj)
    1: {
    1:     size_t i;
 3235: 
 3235:     if (array) {
 3235:         i = array->length;
 3235:         do {
 3235: 
 3235:             if (array->vector[--i] == obj)
    1:                 return i;
 3235:         } while (i != 0);
    1:     }
    1: 
    1:     return NO_PARENT_INDEX;
    1: }
    1: 
28093: JSBool
28093: js_XDRBlockObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
 3235:     uint32 parentId;
    1:     JSObject *obj, *parent;
    1:     uint16 depth, count, i;
    1:     uint32 tmp;
    1:     JSScopeProperty *sprop;
    1:     jsid propid;
    1:     JSAtom *atom;
    1:     int16 shortid;
    1:     JSBool ok;
    1: 
    1:     cx = xdr->cx;
    1: #ifdef __GNUC__
    1:     obj = NULL;         /* quell GCC overwarning */
    1: #endif
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         obj = *objp;
    1:         parent = OBJ_GET_PARENT(cx, obj);
 3235:         parentId = (xdr->script->objectsOffset == 0)
 3235:                    ? NO_PARENT_INDEX
32723:                    : FindObjectIndex(xdr->script->objects(), parent);
 2531:         depth = (uint16)OBJ_BLOCK_DEPTH(cx, obj);
 2531:         count = (uint16)OBJ_BLOCK_COUNT(cx, obj);
    1:         tmp = (uint32)(depth << 16) | count;
    1:     }
    1: #ifdef __GNUC__ /* suppress bogus gcc warnings */
    1:     else count = 0;
    1: #endif
    1: 
    1:     /* First, XDR the parent atomid. */
    1:     if (!JS_XDRUint32(xdr, &parentId))
    1:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         obj = js_NewBlockObject(cx);
    1:         if (!obj)
    1:             return JS_FALSE;
    1:         *objp = obj;
    1: 
    1:         /*
    1:          * If there's a parent id, then get the parent out of our script's
 3235:          * object array. We know that we XDR block object in outer-to-inner
 3235:          * order, which means that getting the parent now will work.
    1:          */
 3235:         if (parentId == NO_PARENT_INDEX)
    1:             parent = NULL;
 3235:         else
32723:             parent = xdr->script->getObject(parentId);
    1:         STOBJ_SET_PARENT(obj, parent);
    1:     }
    1: 
33178:     JSAutoTempValueRooter tvr(cx, obj);
33178: 
33178:     if (!JS_XDRUint32(xdr, &tmp))
33178:         return false;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         depth = (uint16)(tmp >> 16);
    1:         count = (uint16)tmp;
    1:         STOBJ_SET_SLOT(obj, JSSLOT_BLOCK_DEPTH, INT_TO_JSVAL(depth));
    1:     }
    1: 
    1:     /*
    1:      * XDR the block object's properties. We know that there are 'count'
    1:      * properties to XDR, stored as id/shortid pairs. We do not XDR any
    1:      * non-native properties, only those that the compiler created.
    1:      */
    1:     sprop = NULL;
    1:     ok = JS_TRUE;
    1:     for (i = 0; i < count; i++) {
    1:         if (xdr->mode == JSXDR_ENCODE) {
    1:             /* Find a property to XDR. */
    1:             do {
    1:                 /* If sprop is NULL, this is the first property. */
    1:                 sprop = sprop ? sprop->parent : OBJ_SCOPE(obj)->lastProp;
    1:             } while (!(sprop->flags & SPROP_HAS_SHORTID));
    1: 
32717:             JS_ASSERT(sprop->getter == block_getProperty);
    1:             propid = sprop->id;
    1:             JS_ASSERT(JSID_IS_ATOM(propid));
    1:             atom = JSID_TO_ATOM(propid);
    1:             shortid = sprop->shortid;
    1:             JS_ASSERT(shortid >= 0);
    1:         }
    1: 
    1:         /* XDR the real id, then the shortid. */
    1:         if (!js_XDRStringAtom(xdr, &atom) ||
    1:             !JS_XDRUint16(xdr, (uint16 *)&shortid)) {
33178:             return false;
    1:         }
    1: 
    1:         if (xdr->mode == JSXDR_DECODE) {
33178:             if (!js_DefineBlockVariable(cx, obj, ATOM_TO_JSID(atom), shortid))
33178:                 return false;
    1:         }
    1:     }
    1: 
31692:     if (xdr->mode == JSXDR_DECODE) {
31692:         /* Do as the parser does and make this block scope shareable. */
31692:         OBJ_SCOPE(obj)->object = NULL;
31692:     }
33178:     return true;
    1: }
    1: 
    1: #endif
    1: 
14860: static uint32
14860: block_reserveSlots(JSContext *cx, JSObject *obj)
14860: {
14860:     return OBJ_IS_CLONED_BLOCK(obj) ? OBJ_BLOCK_COUNT(cx, obj) : 0;
14860: }
14860: 
    1: JSClass js_BlockClass = {
    1:     "Block",
28093:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_IS_ANONYMOUS,
32717:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,   JS_PropertyStub,
30654:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,    NULL,
28093:     NULL, NULL, NULL, NULL, NULL, NULL, NULL, block_reserveSlots
    1: };
    1: 
    1: JSObject *
14322: js_InitEval(JSContext *cx, JSObject *obj)
    1: {
 2112:     /* ECMA (15.1.2.1) says 'eval' is a property of the global object. */
 2112:     if (!js_DefineFunction(cx, obj, cx->runtime->atomState.evalAtom,
20408:                            obj_eval, 1, 0)) {
    1:         return NULL;
    1:     }
    1: 
14322:     return obj;
14322: }
14322: 
14322: JSObject *
14322: js_InitObjectClass(JSContext *cx, JSObject *obj)
14322: {
25897:     return js_InitClass(cx, obj, NULL, &js_ObjectClass, js_Object, 1,
28086:                         object_props, object_methods, NULL, object_static_methods);
    1: }
    1: 
25897: JSObject *
25897: js_InitClass(JSContext *cx, JSObject *obj, JSObject *parent_proto,
25897:              JSClass *clasp, JSNative constructor, uintN nargs,
25897:              JSPropertySpec *ps, JSFunctionSpec *fs,
28086:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
25897: {
25897:     JSAtom *atom;
25897:     JSProtoKey key;
25897:     JSObject *proto, *ctor;
25897:     JSTempValueRooter tvr;
25897:     jsval cval, rval;
25897:     JSBool named;
25897:     JSFunction *fun;
25897: 
25897:     atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
25897:     if (!atom)
25897:         return NULL;
25897: 
25897:     /*
25897:      * When initializing a standard class, if no parent_proto (grand-proto of
25897:      * instances of the class, parent-proto of the class's prototype object)
25897:      * is given, we must use Object.prototype if it is available.  Otherwise,
25897:      * we could look up the wrong binding for a class name in obj.  Example:
25897:      *
25897:      *   String = Array;
25897:      *   print("hi there".join);
25897:      *
25897:      * should print undefined, not Array.prototype.join.  This is required by
25897:      * ECMA-262, alas.  It might have been better to make String readonly and
25897:      * permanent in the global object, instead -- but that's too big a change
25897:      * to swallow at this point.
25897:      */
25897:     key = JSCLASS_CACHED_PROTO_KEY(clasp);
25897:     if (key != JSProto_Null &&
25897:         !parent_proto &&
25897:         !js_GetClassPrototype(cx, obj, INT_TO_JSID(JSProto_Object),
25897:                               &parent_proto)) {
25897:         return NULL;
25897:     }
25897: 
25897:     /* Create a prototype object for this class. */
30439:     proto = js_NewObject(cx, clasp, parent_proto, obj);
25897:     if (!proto)
25897:         return NULL;
25897: 
25897:     /* After this point, control must exit via label bad or out. */
25897:     JS_PUSH_TEMP_ROOT_OBJECT(cx, proto, &tvr);
25897: 
25897:     if (!constructor) {
25897:         /*
25897:          * Lacking a constructor, name the prototype (e.g., Math) unless this
25897:          * class (a) is anonymous, i.e. for internal use only; (b) the class
25897:          * of obj (the global object) is has a reserved slot indexed by key;
25897:          * and (c) key is not the null key.
25897:          */
25897:         if ((clasp->flags & JSCLASS_IS_ANONYMOUS) &&
25897:             (OBJ_GET_CLASS(cx, obj)->flags & JSCLASS_IS_GLOBAL) &&
25897:             key != JSProto_Null) {
25897:             named = JS_FALSE;
25897:         } else {
31501:             named = obj->defineProperty(cx, ATOM_TO_JSID(atom),
25897:                                         OBJECT_TO_JSVAL(proto),
25897:                                         JS_PropertyStub, JS_PropertyStub,
25897:                                         (clasp->flags & JSCLASS_IS_ANONYMOUS)
25897:                                         ? JSPROP_READONLY | JSPROP_PERMANENT
32573:                                         : 0);
25897:             if (!named)
25897:                 goto bad;
25897:         }
25897: 
25897:         ctor = proto;
25897:     } else {
25897:         /* Define the constructor function in obj's scope. */
25897:         fun = js_DefineFunction(cx, obj, atom, constructor, nargs,
25897:                                 JSFUN_STUB_GSOPS);
25897:         named = (fun != NULL);
25897:         if (!fun)
25897:             goto bad;
25897: 
25897:         /*
25897:          * Remember the class this function is a constructor for so that
25897:          * we know to create an object of this class when we call the
25897:          * constructor.
25897:          */
25897:         FUN_CLASP(fun) = clasp;
25897: 
25897:         /*
25897:          * Optionally construct the prototype object, before the class has
25897:          * been fully initialized.  Allow the ctor to replace proto with a
25897:          * different object, as is done for operator new -- and as at least
25897:          * XML support requires.
25897:          */
25897:         ctor = FUN_OBJECT(fun);
25897:         if (clasp->flags & JSCLASS_CONSTRUCT_PROTOTYPE) {
25897:             cval = OBJECT_TO_JSVAL(ctor);
25897:             if (!js_InternalConstruct(cx, proto, cval, 0, NULL, &rval))
25897:                 goto bad;
25897:             if (!JSVAL_IS_PRIMITIVE(rval) && JSVAL_TO_OBJECT(rval) != proto)
25897:                 proto = JSVAL_TO_OBJECT(rval);
25897:         }
25897: 
25897:         /* Connect constructor and prototype by named properties. */
25897:         if (!js_SetClassPrototype(cx, ctor, proto,
25897:                                   JSPROP_READONLY | JSPROP_PERMANENT)) {
25897:             goto bad;
25897:         }
25897: 
25897:         /* Bootstrap Function.prototype (see also JS_InitStandardClasses). */
25897:         if (OBJ_GET_CLASS(cx, ctor) == clasp)
25897:             OBJ_SET_PROTO(cx, ctor, proto);
25897:     }
25897: 
25897:     /* Add properties and methods to the prototype and the constructor. */
25897:     if ((ps && !JS_DefineProperties(cx, proto, ps)) ||
25897:         (fs && !JS_DefineFunctions(cx, proto, fs)) ||
25897:         (static_ps && !JS_DefineProperties(cx, ctor, static_ps)) ||
25897:         (static_fs && !JS_DefineFunctions(cx, ctor, static_fs))) {
25897:         goto bad;
25897:     }
25897: 
25897:     /* If this is a standard class, cache its prototype. */
25897:     if (key != JSProto_Null && !js_SetClassObject(cx, obj, key, ctor))
25897:         goto bad;
25897: 
25897: out:
25897:     JS_POP_TEMP_ROOT(cx, &tvr);
25897:     return proto;
25897: 
25897: bad:
25897:     if (named)
31501:         (void) obj->deleteProperty(cx, ATOM_TO_JSID(atom), &rval);
25897:     proto = NULL;
25897:     goto out;
25897: }
25897: 
    1: #define SLOTS_TO_DYNAMIC_WORDS(nslots)                                        \
    1:   (JS_ASSERT((nslots) > JS_INITIAL_NSLOTS), (nslots) + 1 - JS_INITIAL_NSLOTS)
    1: 
    1: #define DYNAMIC_WORDS_TO_SLOTS(words)                                         \
    1:   (JS_ASSERT((words) > 1), (words) - 1 + JS_INITIAL_NSLOTS)
    1: 
30454: 
30732: static bool
30732: AllocSlots(JSContext *cx, JSObject *obj, size_t nslots)
    1: {
33638:     JS_ASSERT(!DSLOTS_IS_NOT_NULL(obj));
30454:     JS_ASSERT(nslots > JS_INITIAL_NSLOTS);
30454: 
30454:     jsval* slots;
30851:     slots = (jsval*) cx->malloc(SLOTS_TO_DYNAMIC_WORDS(nslots) * sizeof(jsval));
30454:     if (!slots)
30454:         return true;
30454: 
30454:     *slots++ = nslots;
30454:     /* clear the newly allocated cells. */
30454:     for (jsuint n = JS_INITIAL_NSLOTS; n < nslots; ++n)
30454:         slots[n - JS_INITIAL_NSLOTS] = JSVAL_VOID;
30454:     obj->dslots = slots;
30454: 
30454:     return true;
30454: }
30454: 
30454: bool
30454: js_GrowSlots(JSContext *cx, JSObject *obj, size_t nslots)
30454: {
    1:     /*
    1:      * Minimal number of dynamic slots to allocate.
    1:      */
30454:     const size_t MIN_DYNAMIC_WORDS = 4;
    1: 
    1:     /*
    1:      * The limit to switch to linear allocation strategy from the power of 2
    1:      * growth no to waste too much memory.
    1:      */
30454:     const size_t LINEAR_GROWTH_STEP = JS_BIT(16);
30454: 
30454:     /* If we are allocating fslots, there is nothing to do. */
30454:     if (nslots <= JS_INITIAL_NSLOTS)
    1:         return JS_TRUE;
30454: 
30454:     size_t nwords = SLOTS_TO_DYNAMIC_WORDS(nslots);
30454: 
    1:     /*
    1:      * Round up nslots so the number of bytes in dslots array is power
    1:      * of 2 to ensure exponential grouth.
    1:      */
30454:     uintN log;
    1:     if (nwords <= MIN_DYNAMIC_WORDS) {
    1:         nwords = MIN_DYNAMIC_WORDS;
    1:     } else if (nwords < LINEAR_GROWTH_STEP) {
    1:         JS_CEILING_LOG2(log, nwords);
    1:         nwords = JS_BIT(log);
    1:     } else {
    1:         nwords = JS_ROUNDUP(nwords, LINEAR_GROWTH_STEP);
    1:     }
30454:     nslots = DYNAMIC_WORDS_TO_SLOTS(nwords);
30454: 
30454:     /*
30454:      * If nothing was allocated yet, treat it as initial allocation (but with
30454:      * the exponential growth algorithm applied).
30454:      */
33638:     jsval* slots = DSLOTS_NORMALIZE(obj);
    1:     if (!slots)
30732:         return AllocSlots(cx, obj, nslots);
30454: 
30454:     size_t oslots = size_t(slots[-1]);
30454: 
30851:     slots = (jsval*) cx->realloc(slots - 1, nwords * sizeof(jsval));
30454:     *slots++ = nslots;
30454:     obj->dslots = slots;
30454: 
30454:     /* Initialize the additional slots we added. */
30454:     JS_ASSERT(nslots > oslots);
30454:     for (size_t i = oslots; i < nslots; i++)
30454:         slots[i - JS_INITIAL_NSLOTS] = JSVAL_VOID;
30454: 
30454:     return true;
30454: }
30454: 
30454: void
30454: js_ShrinkSlots(JSContext *cx, JSObject *obj, size_t nslots)
30454: {
33638:     jsval* slots = DSLOTS_NORMALIZE(obj);
30454: 
30454:     /* Nothing to shrink? */
30454:     if (!slots)
30454:         return;
30454: 
30454:     JS_ASSERT(size_t(slots[-1]) > JS_INITIAL_NSLOTS);
30454:     JS_ASSERT(nslots <= size_t(slots[-1]));
30454: 
30454:     if (nslots <= JS_INITIAL_NSLOTS) {
30851:         cx->free(slots - 1);
33638:         obj->dslots = DSLOTS_NULL_SHRINK_SLOTS;
    1:     } else {
30454:         size_t nwords = SLOTS_TO_DYNAMIC_WORDS(nslots);
30851:         slots = (jsval*) cx->realloc(slots - 1, nwords * sizeof(jsval));
30454:         *slots++ = nslots;
    1:         obj->dslots = slots;
30454:     }
    1: }
    1: 
30732: bool
30732: js_EnsureReservedSlots(JSContext *cx, JSObject *obj, size_t nreserved)
30732: {
30732:     JS_ASSERT(OBJ_IS_NATIVE(obj));
33638:     JS_ASSERT(!DSLOTS_IS_NOT_NULL(obj));
30732: 
30732:     uintN nslots = JSSLOT_FREE(STOBJ_GET_CLASS(obj)) + nreserved;
30732:     if (nslots > STOBJ_NSLOTS(obj) && !AllocSlots(cx, obj, nslots))
30732:         return false;
30732: 
30732:     JSScope *scope = OBJ_SCOPE(obj);
30732:     if (scope->owned()) {
30732: #ifdef JS_THREADSAFE
30732:         JS_ASSERT(scope->title.ownercx->thread == cx->thread);
30732: #endif
30732:         JS_ASSERT(scope->freeslot == JSSLOT_FREE(STOBJ_GET_CLASS(obj)));
30732:         if (scope->freeslot < nslots)
30732:             scope->freeslot = nslots;
30732:     }
30732:     return true;
30732: }
30732: 
    1: extern JSBool
    1: js_GetClassId(JSContext *cx, JSClass *clasp, jsid *idp)
    1: {
    1:     JSProtoKey key;
    1:     JSAtom *atom;
    1: 
    1:     key = JSCLASS_CACHED_PROTO_KEY(clasp);
    1:     if (key != JSProto_Null) {
    1:         *idp = INT_TO_JSID(key);
    1:     } else if (clasp->flags & JSCLASS_IS_ANONYMOUS) {
    1:         *idp = INT_TO_JSID(JSProto_Object);
    1:     } else {
    1:         atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
    1:         if (!atom)
    1:             return JS_FALSE;
    1:         *idp = ATOM_TO_JSID(atom);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
32615: JSObject*
32684: js_NewNativeObject(JSContext *cx, JSClass *clasp, JSObject *proto,
32684:                    jsval privateSlotValue)
25897: {
28353:     JS_ASSERT(!clasp->getObjectOps);
32615:     JS_ASSERT(proto->map->ops == &js_ObjectOps);
32615:     JS_ASSERT(OBJ_GET_CLASS(cx, proto) == clasp);
28353: 
33581:     JSObject* obj = js_NewGCObject(cx);
25897:     if (!obj)
25897:         return NULL;
25897: 
32615:     JSScope *scope = OBJ_SCOPE(proto)->getEmptyScope(cx, clasp);
32615:     if (!scope) {
32777:         JS_ASSERT(!obj->map);
32615:         return NULL;
32615:     }
32777:     obj->map = scope;
33694:     obj->init(clasp, proto, proto->getParent(), privateSlotValue,
33694:               DSLOTS_NULL_INIT_JSNATIVE);
32615:     return obj;
32615: }
25897: 
 3164: JS_BEGIN_EXTERN_C
 3164: 
18907: static JSObject *
    1: js_InitNullClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JS_ASSERT(0);
    1:     return NULL;
    1: }
    1: 
    1: #define JS_PROTO(name,code,init) extern JSObject *init(JSContext *, JSObject *);
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: 
    1: static JSObjectOp lazy_prototype_init[JSProto_LIMIT] = {
    1: #define JS_PROTO(name,code,init) init,
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: };
    1: 
 3164: JS_END_EXTERN_C
 3164: 
    1: JSBool
    1: js_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key,
    1:                   JSObject **objp)
    1: {
    1:     JSBool ok;
    1:     JSObject *tmp, *cobj;
    1:     JSResolvingKey rkey;
    1:     JSResolvingEntry *rentry;
    1:     uint32 generation;
    1:     JSObjectOp init;
    1:     jsval v;
    1: 
    1:     while ((tmp = OBJ_GET_PARENT(cx, obj)) != NULL)
    1:         obj = tmp;
    1:     if (!(OBJ_GET_CLASS(cx, obj)->flags & JSCLASS_IS_GLOBAL)) {
    1:         *objp = NULL;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     ok = JS_GetReservedSlot(cx, obj, key, &v);
    1:     if (!ok)
    1:         return JS_FALSE;
    1:     if (!JSVAL_IS_PRIMITIVE(v)) {
    1:         *objp = JSVAL_TO_OBJECT(v);
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     rkey.obj = obj;
    1:     rkey.id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[key]);
    1:     if (!js_StartResolving(cx, &rkey, JSRESFLAG_LOOKUP, &rentry))
    1:         return JS_FALSE;
    1:     if (!rentry) {
    1:         /* Already caching key in obj -- suppress recursion. */
    1:         *objp = NULL;
    1:         return JS_TRUE;
    1:     }
    1:     generation = cx->resolvingTable->generation;
    1: 
    1:     cobj = NULL;
    1:     init = lazy_prototype_init[key];
    1:     if (init) {
    1:         if (!init(cx, obj)) {
    1:             ok = JS_FALSE;
    1:         } else {
    1:             ok = JS_GetReservedSlot(cx, obj, key, &v);
    1:             if (ok && !JSVAL_IS_PRIMITIVE(v))
    1:                 cobj = JSVAL_TO_OBJECT(v);
    1:         }
    1:     }
    1: 
    1:     js_StopResolving(cx, &rkey, JSRESFLAG_LOOKUP, rentry, generation);
    1:     *objp = cobj;
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_SetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key, JSObject *cobj)
    1: {
    1:     JS_ASSERT(!OBJ_GET_PARENT(cx, obj));
    1:     if (!(OBJ_GET_CLASS(cx, obj)->flags & JSCLASS_IS_GLOBAL))
    1:         return JS_TRUE;
    1: 
    1:     return JS_SetReservedSlot(cx, obj, key, OBJECT_TO_JSVAL(cobj));
    1: }
    1: 
    1: JSBool
    1: js_FindClassObject(JSContext *cx, JSObject *start, jsid id, jsval *vp)
    1: {
22652:     JSStackFrame *fp;
    1:     JSObject *obj, *cobj, *pobj;
    1:     JSProtoKey key;
    1:     JSProperty *prop;
 8893:     jsval v;
    1:     JSScopeProperty *sprop;
    1: 
22652:     /*
22652:      * Find the global object. Use cx->fp directly to avoid falling off
22652:      * trace; all JIT-elided stack frames have the same global object as
22652:      * cx->fp.
22652:      */
22652:     VOUCH_DOES_NOT_REQUIRE_STACK();
22652:     if (!start && (fp = cx->fp) != NULL)
22652:         start = fp->scopeChain;
22652: 
22652:     if (start) {
    1:         /* Find the topmost object in the scope chain. */
    1:         do {
    1:             obj = start;
    1:             start = OBJ_GET_PARENT(cx, obj);
    1:         } while (start);
    1:     } else {
    1:         obj = cx->globalObject;
    1:         if (!obj) {
    1:             *vp = JSVAL_VOID;
    1:             return JS_TRUE;
    1:         }
    1:     }
    1: 
    1:     OBJ_TO_INNER_OBJECT(cx, obj);
    1:     if (!obj)
    1:         return JS_FALSE;
    1: 
    1:     if (JSID_IS_INT(id)) {
 3164:         key = (JSProtoKey) JSID_TO_INT(id);
    1:         JS_ASSERT(key != JSProto_Null);
    1:         if (!js_GetClassObject(cx, obj, key, &cobj))
    1:             return JS_FALSE;
    1:         if (cobj) {
    1:             *vp = OBJECT_TO_JSVAL(cobj);
    1:             return JS_TRUE;
    1:         }
    1:         id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[key]);
    1:     }
    1: 
    1:     JS_ASSERT(OBJ_IS_NATIVE(obj));
10217:     if (js_LookupPropertyWithFlags(cx, obj, id, JSRESOLVE_CLASSNAME,
10217:                                    &pobj, &prop) < 0) {
    1:         return JS_FALSE;
    1:     }
 8893:     v = JSVAL_VOID;
 8893:     if (prop)  {
 8893:         if (OBJ_IS_NATIVE(pobj)) {
    1:             sprop = (JSScopeProperty *) prop;
 8893:             if (SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(pobj))) {
 8893:                 v = LOCKED_OBJ_GET_SLOT(pobj, sprop->slot);
 8893:                 if (JSVAL_IS_PRIMITIVE(v))
 8893:                     v = JSVAL_VOID;
 8893:             }
 8893:         }
31501:         pobj->dropProperty(cx, prop);
 8893:     }
 8893:     *vp = v;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
    1: js_ConstructObject(JSContext *cx, JSClass *clasp, JSObject *proto,
    1:                    JSObject *parent, uintN argc, jsval *argv)
    1: {
    1:     jsid id;
    1:     jsval cval, rval;
    1:     JSObject *obj, *ctor;
    1: 
33178:     JSAutoTempValueRooter argtvr(cx, argc, argv);
    1: 
    1:     if (!js_GetClassId(cx, clasp, &id) ||
    1:         !js_FindClassObject(cx, parent, id, &cval)) {
    1:         return NULL;
    1:     }
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(cval)) {
    1:         js_ReportIsNotFunction(cx, &cval, JSV2F_CONSTRUCT | JSV2F_SEARCH_STACK);
    1:         return NULL;
    1:     }
    1: 
33178:     /* Protect cval in case a crazy getter for .prototype uproots it. */
33178:     JSAutoTempValueRooter tvr(cx, cval);
    1: 
    1:     /*
    1:      * If proto or parent are NULL, set them to Constructor.prototype and/or
    1:      * Constructor.__parent__, just like JSOP_NEW does.
    1:      */
    1:     ctor = JSVAL_TO_OBJECT(cval);
    1:     if (!parent)
    1:         parent = OBJ_GET_PARENT(cx, ctor);
    1:     if (!proto) {
31501:         if (!ctor->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
    1:                                &rval)) {
33178:             return NULL;
    1:         }
    1:         if (JSVAL_IS_OBJECT(rval))
    1:             proto = JSVAL_TO_OBJECT(rval);
    1:     }
    1: 
30439:     obj = js_NewObject(cx, clasp, proto, parent);
    1:     if (!obj)
33178:         return NULL;
    1: 
    1:     if (!js_InternalConstruct(cx, obj, cval, argc, argv, &rval))
33178:         return NULL;
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(rval))
33178:         return obj;
    1: 
    1:     /*
    1:      * If the instance's class differs from what was requested, throw a type
    1:      * error.  If the given class has both the JSCLASS_HAS_PRIVATE and the
    1:      * JSCLASS_CONSTRUCT_PROTOTYPE flags, and the instance does not have its
    1:      * private data set at this point, then the constructor was replaced and
    1:      * we should throw a type error.
    1:      */
33178:     obj = JSVAL_TO_OBJECT(rval);
    1:     if (OBJ_GET_CLASS(cx, obj) != clasp ||
    1:         (!(~clasp->flags & (JSCLASS_HAS_PRIVATE |
    1:                             JSCLASS_CONSTRUCT_PROTOTYPE)) &&
31452:          !obj->getPrivate())) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_WRONG_CONSTRUCTOR, clasp->name);
33178:         return NULL;
33178:     }
    1:     return obj;
    1: }
    1: 
    1: /* XXXbe if one adds props, deletes earlier props, adds more, the last added
    1:          won't recycle the deleted props' slots. */
    1: JSBool
    1: js_AllocSlot(JSContext *cx, JSObject *obj, uint32 *slotp)
    1: {
28353:     JS_ASSERT(OBJ_IS_NATIVE(obj));
28353: 
28353:     JSScope *scope = OBJ_SCOPE(obj);
32603:     JSClass *clasp = obj->getClass();
28353:     if (scope->freeslot == JSSLOT_FREE(clasp) && clasp->reserveSlots) {
28353:         /* Adjust scope->freeslot to include computed reserved slots, if any. */
28353:         scope->freeslot += clasp->reserveSlots(cx, obj);
28353:     }
28353: 
28353:     if (scope->freeslot >= STOBJ_NSLOTS(obj) &&
30454:         !js_GrowSlots(cx, obj, scope->freeslot + 1)) {
    1:         return JS_FALSE;
    1:     }
    1: 
14860:     /* js_ReallocSlots or js_FreeSlot should set the free slots to void. */
28353:     JS_ASSERT(JSVAL_IS_VOID(STOBJ_GET_SLOT(obj, scope->freeslot)));
28353:     *slotp = scope->freeslot++;
    1:     return JS_TRUE;
    1: }
    1: 
    1: void
    1: js_FreeSlot(JSContext *cx, JSObject *obj, uint32 slot)
    1: {
28353:     JS_ASSERT(OBJ_IS_NATIVE(obj));
28353: 
28353:     JSScope *scope = OBJ_SCOPE(obj);
    1:     LOCKED_OBJ_SET_SLOT(obj, slot, JSVAL_VOID);
30454:     if (scope->freeslot == slot + 1)
28353:         scope->freeslot = slot;
    1: }
    1: 
30270: 
30270: /* JSVAL_INT_MAX as a string */
30270: #define JSVAL_INT_MAX_STRING "1073741823"
30270: 
30270: /*
30270:  * Convert string indexes that convert to int jsvals as ints to save memory.
30270:  * Care must be taken to use this macro every time a property name is used, or
30270:  * else double-sets, incorrect property cache misses, or other mistakes could
30270:  * occur.
30270:  */
11524: jsid
30270: js_CheckForStringIndex(jsid id)
    1: {
30270:     if (!JSID_IS_ATOM(id))
30270:         return id;
30270: 
30270:     JSAtom *atom = JSID_TO_ATOM(id);
30270:     JSString *str = ATOM_TO_STRING(atom);
30270:     const jschar *s = str->flatChars();
30270:     jschar ch = *s;
30270: 
30270:     JSBool negative = (ch == '-');
30270:     if (negative)
30270:         ch = *++s;
30270: 
30270:     if (!JS7_ISDEC(ch))
30270:         return id;
30270: 
30270:     size_t n = str->flatLength() - negative;
30270:     if (n > sizeof(JSVAL_INT_MAX_STRING) - 1)
30270:         return id;
30270: 
30270:     const jschar *cp = s;
30270:     const jschar *end = s + n;
30270: 
    1:     jsuint index = JS7_UNDEC(*cp++);
    1:     jsuint oldIndex = 0;
    1:     jsuint c = 0;
    1: 
    1:     if (index != 0) {
    1:         while (JS7_ISDEC(*cp)) {
    1:             oldIndex = index;
    1:             c = JS7_UNDEC(*cp);
    1:             index = 10 * index + c;
    1:             cp++;
    1:         }
    1:     }
22608: 
22608:     /*
22608:      * Non-integer indexes can't be represented as integers.  Also, distinguish
22608:      * index "-0" from "0", because JSVAL_INT cannot.
22608:      */
22608:     if (cp != end || (negative && index == 0))
22608:         return id;
30270: 
22608:     if (oldIndex < JSVAL_INT_MAX / 10 ||
22608:         (oldIndex == JSVAL_INT_MAX / 10 && c <= (JSVAL_INT_MAX % 10))) {
    1:         if (negative)
    1:             index = 0 - index;
    1:         id = INT_TO_JSID((jsint)index);
    1:     }
30270: 
    1:     return id;
    1: }
    1: 
    1: static JSBool
11377: PurgeProtoChain(JSContext *cx, JSObject *obj, jsid id)
    1: {
11377:     JSScope *scope;
11377:     JSScopeProperty *sprop;
11377: 
11377:     while (obj) {
11377:         if (!OBJ_IS_NATIVE(obj)) {
11377:             obj = OBJ_GET_PROTO(cx, obj);
11377:             continue;
11377:         }
11377:         JS_LOCK_OBJ(cx, obj);
11377:         scope = OBJ_SCOPE(obj);
30258:         sprop = scope->lookup(id);
11377:         if (sprop) {
18308:             PCMETER(JS_PROPERTY_CACHE(cx).pcpurges++);
30258:             scope->shadowingShapeChange(cx, sprop);
11377:             JS_UNLOCK_SCOPE(cx, scope);
27019: 
30645:             if (!STOBJ_GET_PARENT(obj)) {
27019:                 /*
27019:                  * All scope chains end in a global object, so this will change
27019:                  * the global shape. jstracer.cpp assumes that the global shape
27019:                  * never changes on trace, so we must deep-bail here.
27019:                  */
27019:                 js_LeaveTrace(cx);
27019:             }
11377:             return JS_TRUE;
11377:         }
32603:         obj = obj->getProto();
11377:         JS_UNLOCK_SCOPE(cx, scope);
11377:     }
    1:     return JS_FALSE;
11377: }
11377: 
25936: void
25936: js_PurgeScopeChainHelper(JSContext *cx, JSObject *obj, jsid id)
    1: {
32603:     JS_ASSERT(obj->isDelegate());
32603:     PurgeProtoChain(cx, obj->getProto(), id);
28397: 
28397:     /*
28397:      * We must purge the scope chain only for Call objects as they are the only
28397:      * kind of cacheable non-global object that can gain properties after outer
28397:      * properties with the same names have been cached or traced. Call objects
28397:      * may gain such properties via eval introducing new vars; see bug 490364.
28397:      */
28397:     if (STOBJ_GET_CLASS(obj) == &js_CallClass) {
11377:         while ((obj = OBJ_GET_PARENT(cx, obj)) != NULL) {
11377:             if (PurgeProtoChain(cx, obj, id))
28397:                 break;
28397:         }
11377:     }
    1: }
    1: 
    1: JSScopeProperty *
    1: js_AddNativeProperty(JSContext *cx, JSObject *obj, jsid id,
    1:                      JSPropertyOp getter, JSPropertyOp setter, uint32 slot,
    1:                      uintN attrs, uintN flags, intN shortid)
    1: {
    1:     JSScope *scope;
    1:     JSScopeProperty *sprop;
    1: 
32658:     JS_ASSERT(!(flags & SPROP_IS_METHOD));
32658: 
11377:     /*
11377:      * Purge the property cache of now-shadowed id in obj's scope chain. Do
11377:      * this optimistically (assuming no failure below) before locking obj, so
11377:      * we can lock the shadowed scope.
11377:      */
25936:     js_PurgeScopeChain(cx, obj, id);
11377: 
    1:     JS_LOCK_OBJ(cx, obj);
    1:     scope = js_GetMutableScope(cx, obj);
    1:     if (!scope) {
    1:         sprop = NULL;
    1:     } else {
11377:         /* Convert string indices to integers if appropriate. */
30270:         id = js_CheckForStringIndex(id);
30258:         sprop = scope->add(cx, id, getter, setter, slot, attrs, flags, shortid);
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     return sprop;
    1: }
    1: 
    1: JSScopeProperty *
    1: js_ChangeNativePropertyAttrs(JSContext *cx, JSObject *obj,
    1:                              JSScopeProperty *sprop, uintN attrs, uintN mask,
    1:                              JSPropertyOp getter, JSPropertyOp setter)
    1: {
    1:     JSScope *scope;
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
    1:     scope = js_GetMutableScope(cx, obj);
    1:     if (!scope) {
    1:         sprop = NULL;
    1:     } else {
30258:         sprop = scope->change(cx, sprop, attrs, mask, getter, setter);
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     return sprop;
    1: }
    1: 
    1: JSBool
    1: js_DefineProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
32573:                   JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
    1: {
27932:     return js_DefineNativeProperty(cx, obj, id, value, getter, setter, attrs,
32573:                                    0, 0, NULL);
    1: }
    1: 
    1: /*
    1:  * Backward compatibility requires allowing addProperty hooks to mutate the
    1:  * nominal initial value of a slot-full property, while GC safety wants that
    1:  * value to be stored before the call-out through the hook.  Optimize to do
    1:  * both while saving cycles for classes that stub their addProperty hook.
    1:  */
32658: static inline bool
32658: AddPropertyHelper(JSContext *cx, JSClass *clasp, JSObject *obj, JSScope *scope,
32658:                   JSScopeProperty *sprop, jsval *vp)
32658: {
32658:     if (clasp->addProperty != JS_PropertyStub) {
32658:         jsval nominal = *vp;
32658: 
32658:         if (!clasp->addProperty(cx, obj, SPROP_USERID(sprop), vp))
32658:             return false;
32658:         if (*vp != nominal) {
32658:             if (SPROP_HAS_VALID_SLOT(sprop, scope))
32658:                 LOCKED_OBJ_SET_SLOT(obj, sprop->slot, *vp);
32658:         }
32658:     }
32658:     return true;
32658: }
    1: 
27932: JSBool
    1: js_DefineNativeProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
    1:                         JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
24852:                         uintN flags, intN shortid, JSProperty **propp,
28397:                         uintN defineHow /* = 0 */)
    1: {
    1:     JSClass *clasp;
    1:     JSScope *scope;
    1:     JSScopeProperty *sprop;
30645:     JSBool added;
    1: 
32658:     JS_ASSERT((defineHow & ~(JSDNP_CACHE_RESULT | JSDNP_DONT_PURGE | JSDNP_SET_METHOD)) == 0);
27492:     js_LeaveTraceIfGlobalObject(cx, obj);
27492: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
    1: 
    1: #if JS_HAS_GETTER_SETTER
    1:     /*
    1:      * If defining a getter or setter, we must check for its counterpart and
    1:      * update the attributes and property ops.  A getter or setter is really
    1:      * only half of a property.
    1:      */
14646:     sprop = NULL;
    1:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
    1:         JSObject *pobj;
    1:         JSProperty *prop;
    1: 
    1:         /*
    1:          * If JS_THREADSAFE and id is found, js_LookupProperty returns with
    1:          * sprop non-null and pobj locked.  If pobj == obj, the property is
    1:          * already in obj and obj has its own (mutable) scope.  So if we are
    1:          * defining a getter whose setter was already defined, or vice versa,
    1:          * finish the job via js_ChangeScopePropertyAttributes, and refresh
    1:          * the property cache line for (obj, id) to map sprop.
    1:          */
    1:         if (!js_LookupProperty(cx, obj, id, &pobj, &prop))
27932:             return JS_FALSE;
    1:         sprop = (JSScopeProperty *) prop;
    1:         if (sprop &&
    1:             pobj == obj &&
    1:             (sprop->attrs & (JSPROP_GETTER | JSPROP_SETTER))) {
33152:             sprop = OBJ_SCOPE(obj)->change(cx, sprop, attrs,
33152:                                            JSPROP_GETTER | JSPROP_SETTER,
    1:                                            (attrs & JSPROP_GETTER)
    1:                                            ? getter
    1:                                            : sprop->getter,
    1:                                            (attrs & JSPROP_SETTER)
    1:                                            ? setter
    1:                                            : sprop->setter);
    1: 
    1:             /* NB: obj == pobj, so we can share unlock code at the bottom. */
    1:             if (!sprop)
27934:                 goto error;
14646:         } else if (prop) {
31501:             /* NB: call JSObject::dropProperty, as pobj might not be native. */
31501:             pobj->dropProperty(cx, prop);
    1:             prop = NULL;
14646:             sprop = NULL;
    1:         }
    1:     }
    1: #endif /* JS_HAS_GETTER_SETTER */
    1: 
11377:     /*
28397:      * Purge the property cache of any properties named by id that are about
28397:      * to be shadowed in obj's scope chain unless it is known a priori that it
28397:      * is not possible. We do this before locking obj to avoid nesting locks.
28312:      */
28397:     if (!(defineHow & JSDNP_DONT_PURGE))
28312:         js_PurgeScopeChain(cx, obj, id);
28312: 
28312:     /*
28312:      * Check whether a readonly property or setter is being defined on a known
28312:      * prototype object. See the comment in jscntxt.h before protoHazardShape's
28312:      * member declaration.
11377:      */
32603:     if (obj->isDelegate() && (attrs & (JSPROP_READONLY | JSPROP_SETTER)))
28312:         cx->runtime->protoHazardShape = js_GenerateShape(cx, false);
11377: 
    1:     /* Lock if object locking is required by this implementation. */
    1:     JS_LOCK_OBJ(cx, obj);
    1: 
    1:     /* Use the object's class getter and setter by default. */
32603:     clasp = obj->getClass();
32658:     if (!(defineHow & JSDNP_SET_METHOD)) {
    1:         if (!getter)
    1:             getter = clasp->getProperty;
    1:         if (!setter)
    1:             setter = clasp->setProperty;
32658:     }
    1: 
    1:     /* Get obj's own scope if it has one, or create a new one for obj. */
    1:     scope = js_GetMutableScope(cx, obj);
    1:     if (!scope)
27934:         goto error;
    1: 
27930:     added = false;
14646:     if (!sprop) {
18750:         /* Add a new property, or replace an existing one of the same id. */
    1:         if (clasp->flags & JSCLASS_SHARE_ALL_PROPERTIES)
    1:             attrs |= JSPROP_SHARED;
32658: 
32658:         if (defineHow & JSDNP_SET_METHOD) {
32658:             JS_ASSERT(clasp == &js_ObjectClass);
32658:             JS_ASSERT(VALUE_IS_FUNCTION(cx, value));
32658:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
32658:             JS_ASSERT(!getter && !setter);
32658: 
32658:             JSObject *funobj = JSVAL_TO_OBJECT(value);
32658:             if (FUN_OBJECT(GET_FUNCTION_PRIVATE(cx, funobj)) == funobj) {
32658:                 flags |= SPROP_IS_METHOD;
32658:                 getter = js_CastAsPropertyOp(funobj);
32658:             }
32658:         }
32658: 
33584:         added = !scope->lookup(id);
30258:         sprop = scope->add(cx, id, getter, setter, SPROP_INVALID_SLOT, attrs,
30258:                            flags, shortid);
    1:         if (!sprop)
27934:             goto error;
14646:     }
    1: 
    1:     /* Store value before calling addProperty, in case the latter GC's. */
32568:     if (SPROP_HAS_VALID_SLOT(sprop, scope))
32658:         LOCKED_OBJ_SET_SLOT(obj, sprop->slot, value);
    1: 
    1:     /* XXXbe called with lock held */
32658:     if (!AddPropertyHelper(cx, clasp, obj, scope, sprop, &value)) {
30258:         scope->remove(cx, id);
32658:         goto error;
32658:     }
    1: 
28397:     if (defineHow & JSDNP_CACHE_RESULT) {
24852:         JS_ASSERT_NOT_ON_TRACE(cx);
27932:         JSPropCacheEntry *entry;
27930:         entry = js_FillPropertyCache(cx, obj, 0, 0, obj, sprop, added);
27932:         TRACE_2(SetPropHit, entry, sprop);
24852:     }
    1:     if (propp)
    1:         *propp = (JSProperty *) sprop;
    1:     else
    1:         JS_UNLOCK_OBJ(cx, obj);
27932:     return JS_TRUE;
    1: 
27934: error: // TRACE_2 jumps here on error, as well.
    1:     JS_UNLOCK_OBJ(cx, obj);
27932:     return JS_FALSE;
    1: }
    1: 
    1: JS_FRIEND_API(JSBool)
    1: js_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                   JSProperty **propp)
    1: {
19712:     return js_LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags,
19712:                                       objp, propp) >= 0;
10217: }
10217: 
16072: #define SCOPE_DEPTH_ACCUM(bs,val)                                             \
16072:     JS_SCOPE_DEPTH_METERING(JS_BASIC_STATS_ACCUM(bs, val))
10217: 
10217: int
    1: js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:                            JSObject **objp, JSProperty **propp)
    1: {
    1:     JSObject *start, *obj2, *proto;
10217:     int protoIndex;
    1:     JSScope *scope;
    1:     JSScopeProperty *sprop;
    1:     JSClass *clasp;
    1:     JSResolveOp resolve;
    1:     JSResolvingKey key;
    1:     JSResolvingEntry *entry;
    1:     uint32 generation;
    1:     JSNewResolveOp newresolve;
    1:     JSBool ok;
    1: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
    1:     /* Search scopes starting with obj and following the prototype link. */
    1:     start = obj;
10217:     for (protoIndex = 0; ; protoIndex++) {
    1:         JS_LOCK_OBJ(cx, obj);
    1:         scope = OBJ_SCOPE(obj);
30258:         sprop = scope->lookup(id);
    1: 
    1:         /* Try obj's class resolve hook if id was not found in obj's scope. */
    1:         if (!sprop) {
32603:             clasp = obj->getClass();
    1:             resolve = clasp->resolve;
    1:             if (resolve != JS_ResolveStub) {
    1:                 /* Avoid recursion on (obj, id) already being resolved on cx. */
    1:                 key.obj = obj;
    1:                 key.id = id;
    1: 
    1:                 /*
    1:                  * Once we have successfully added an entry for (obj, key) to
    1:                  * cx->resolvingTable, control must go through cleanup: before
    1:                  * returning.  But note that JS_DHASH_ADD may find an existing
    1:                  * entry, in which case we bail to suppress runaway recursion.
    1:                  */
    1:                 if (!js_StartResolving(cx, &key, JSRESFLAG_LOOKUP, &entry)) {
    1:                     JS_UNLOCK_OBJ(cx, obj);
10217:                     return -1;
    1:                 }
    1:                 if (!entry) {
    1:                     /* Already resolving id in obj -- suppress recursion. */
    1:                     JS_UNLOCK_OBJ(cx, obj);
    1:                     goto out;
    1:                 }
    1:                 generation = cx->resolvingTable->generation;
    1: 
    1:                 /* Null *propp here so we can test it at cleanup: safely. */
    1:                 *propp = NULL;
    1: 
    1:                 if (clasp->flags & JSCLASS_NEW_RESOLVE) {
    1:                     newresolve = (JSNewResolveOp)resolve;
23435:                     if (flags == JSRESOLVE_INFER)
30034:                         flags = js_InferFlags(cx, flags);
    1:                     obj2 = (clasp->flags & JSCLASS_NEW_RESOLVE_GETS_START)
    1:                            ? start
    1:                            : NULL;
    1:                     JS_UNLOCK_OBJ(cx, obj);
    1: 
    1:                     /* Protect id and all atoms from a GC nested in resolve. */
    1:                     JS_KEEP_ATOMS(cx->runtime);
    1:                     ok = newresolve(cx, obj, ID_TO_VALUE(id), flags, &obj2);
    1:                     JS_UNKEEP_ATOMS(cx->runtime);
    1:                     if (!ok)
    1:                         goto cleanup;
    1: 
    1:                     JS_LOCK_OBJ(cx, obj);
    1:                     if (obj2) {
    1:                         /* Resolved: juggle locks and lookup id again. */
    1:                         if (obj2 != obj) {
    1:                             JS_UNLOCK_OBJ(cx, obj);
15525:                             if (OBJ_IS_NATIVE(obj2))
    1:                                 JS_LOCK_OBJ(cx, obj2);
    1:                         }
11377:                         protoIndex = 0;
11377:                         for (proto = start; proto && proto != obj2;
11377:                              proto = OBJ_GET_PROTO(cx, proto)) {
11377:                             protoIndex++;
11377:                         }
28353:                         if (!OBJ_IS_NATIVE(obj2)) {
    1:                             /* Whoops, newresolve handed back a foreign obj2. */
    1:                             JS_ASSERT(obj2 != obj);
31501:                             ok = obj2->lookupProperty(cx, id, objp, propp);
    1:                             if (!ok || *propp)
    1:                                 goto cleanup;
    1:                             JS_LOCK_OBJ(cx, obj2);
    1:                         } else {
    1:                             /*
    1:                              * Require that obj2 have its own scope now, as we
    1:                              * do for old-style resolve.  If it doesn't, then
    1:                              * id was not truly resolved, and we'll find it in
    1:                              * the proto chain, or miss it if obj2's proto is
    1:                              * not on obj's proto chain.  That last case is a
    1:                              * "too bad!" case.
    1:                              */
28353:                             scope = OBJ_SCOPE(obj2);
30645:                             if (scope->owned())
30258:                                 sprop = scope->lookup(id);
    1:                         }
    1:                         if (sprop) {
30645:                             JS_ASSERT(scope == OBJ_SCOPE(obj2));
30645:                             JS_ASSERT(scope->owned());
    1:                             obj = obj2;
    1:                         } else if (obj2 != obj) {
15525:                             if (OBJ_IS_NATIVE(obj2))
    1:                                 JS_UNLOCK_OBJ(cx, obj2);
    1:                             JS_LOCK_OBJ(cx, obj);
    1:                         }
    1:                     }
    1:                 } else {
    1:                     /*
    1:                      * Old resolve always requires id re-lookup if obj owns
    1:                      * its scope after resolve returns.
    1:                      */
    1:                     JS_UNLOCK_OBJ(cx, obj);
    1:                     ok = resolve(cx, obj, ID_TO_VALUE(id));
    1:                     if (!ok)
    1:                         goto cleanup;
    1:                     JS_LOCK_OBJ(cx, obj);
28353:                     JS_ASSERT(OBJ_IS_NATIVE(obj));
    1:                     scope = OBJ_SCOPE(obj);
30645:                     if (scope->owned())
30258:                         sprop = scope->lookup(id);
    1:                 }
    1: 
    1:             cleanup:
    1:                 js_StopResolving(cx, &key, JSRESFLAG_LOOKUP, entry, generation);
10217:                 if (!ok)
10217:                     return -1;
10217:                 if (*propp)
10217:                     return protoIndex;
    1:             }
    1:         }
    1: 
    1:         if (sprop) {
10217:             SCOPE_DEPTH_ACCUM(&cx->runtime->protoLookupDepthStats, protoIndex);
    1:             JS_ASSERT(OBJ_SCOPE(obj) == scope);
30645:             *objp = obj;
    1: 
    1:             *propp = (JSProperty *) sprop;
10217:             return protoIndex;
    1:         }
    1: 
32603:         proto = obj->getProto();
    1:         JS_UNLOCK_OBJ(cx, obj);
    1:         if (!proto)
    1:             break;
10217:         if (!OBJ_IS_NATIVE(proto)) {
31501:             if (!proto->lookupProperty(cx, id, objp, propp))
10217:                 return -1;
12495:             return protoIndex + 1;
10217:         }
30645: 
30645:         /*
30645:          * Correctness elsewhere (the property cache and JIT), not here in
30645:          * particular, depends on all the objects on the prototype chain having
30645:          * different scopes. This is just a convenient place to check.
30645:          *
30645:          * Cloned Block objects do in fact share their prototype's scope -- but
30645:          * that is really just a memory-saving hack, safe because Blocks cannot
30645:          * be on the prototype chain of other objects.
30645:          */
30645:         JS_ASSERT_IF(OBJ_GET_CLASS(cx, obj) != &js_BlockClass,
30645:                      OBJ_SCOPE(obj) != OBJ_SCOPE(proto));
30645: 
    1:         obj = proto;
    1:     }
    1: 
    1: out:
    1:     *objp = NULL;
    1:     *propp = NULL;
10217:     return protoIndex;
10217: }
10217: 
27575: JSPropCacheEntry *
27575: js_FindPropertyHelper(JSContext *cx, jsid id, JSBool cacheResult,
27575:                       JSObject **objp, JSObject **pobjp, JSProperty **propp)
    1: {
27539:     JSObject *scopeChain, *obj, *parent, *pobj;
27575:     JSPropCacheEntry *entry;
11377:     int scopeIndex, protoIndex;
    1:     JSProperty *prop;
27575: 
27575:     JS_ASSERT_IF(cacheResult, !JS_ON_TRACE(cx));
27539:     scopeChain = js_GetTopStackFrame(cx)->scopeChain;
27539: 
27539:     /* Scan entries on the scope chain that we can cache across. */
27575:     entry = JS_NO_PROP_CACHE_FILL;
27539:     obj = scopeChain;
27539:     parent = OBJ_GET_PARENT(cx, obj);
27539:     for (scopeIndex = 0;
27539:          parent
31467:          ? js_IsCacheableNonGlobalScope(obj)
27539:          : obj->map->ops->lookupProperty == js_LookupProperty;
27539:          ++scopeIndex) {
11377:         protoIndex =
19712:             js_LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags,
19712:                                        &pobj, &prop);
21979:         if (protoIndex < 0)
27575:             return NULL;
27539: 
27539:         if (prop) {
27539: #ifdef DEBUG
27539:             if (parent) {
27539:                 JSClass *clasp = OBJ_GET_CLASS(cx, obj);
27539:                 JS_ASSERT(OBJ_IS_NATIVE(pobj));
27539:                 JS_ASSERT(OBJ_GET_CLASS(cx, pobj) == clasp);
27539:                 if (clasp == &js_BlockClass) {
27539:                     /*
27539:                      * Block instances on the scope chain are immutable and
27539:                      * always share their scope with compile-time prototypes.
27539:                      */
30645:                     JS_ASSERT(pobj == obj);
30645:                     JS_ASSERT(protoIndex == 0);
11377:                 } else {
27539:                     /* Call and DeclEnvClass objects have no prototypes. */
27539:                     JS_ASSERT(!OBJ_GET_PROTO(cx, obj));
27539:                     JS_ASSERT(protoIndex == 0);
27539:                 }
27539:             }
27539: #endif
27575:             if (cacheResult) {
27930:                 entry = js_FillPropertyCache(cx, scopeChain,
27575:                                              scopeIndex, protoIndex, pobj,
27930:                                              (JSScopeProperty *) prop, false);
27539:             }
27539:             SCOPE_DEPTH_ACCUM(&rt->scopeSearchDepthStats, scopeIndex);
27539:             goto out;
27539:         }
27539: 
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             goto out;
27539:         }
27539:         obj = parent;
27539:         parent = OBJ_GET_PARENT(cx, obj);
27539:     }
27539: 
27539:     for (;;) {
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
27575:             return NULL;
27539:         if (prop) {
11377:             PCMETER(JS_PROPERTY_CACHE(cx).nofills++);
27539:             goto out;
27539:         }
27539: 
27539:         /*
27539:          * We conservatively assume that a resolve hook could mutate the scope
31501:          * chain during JSObject::lookupProperty. So we read parent here again.
27539:          */
27539:         parent = OBJ_GET_PARENT(cx, obj);
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             break;
27539:         }
27539:         obj = parent;
27539:     }
27539: 
27539:   out:
27539:     JS_ASSERT(!!pobj == !!prop);
    1:     *objp = obj;
    1:     *pobjp = pobj;
    1:     *propp = prop;
27575:     return entry;
    1: }
    1: 
    1: JS_FRIEND_API(JSBool)
    1: js_FindProperty(JSContext *cx, jsid id, JSObject **objp, JSObject **pobjp,
    1:                 JSProperty **propp)
    1: {
27575:     return !!js_FindPropertyHelper(cx, id, false, objp, pobjp, propp);
    1: }
    1: 
27319: JSObject *
27575: js_FindIdentifierBase(JSContext *cx, JSObject *scopeChain, jsid id)
    1: {
27237:     /*
27237:      * This function should not be called for a global object or from the
27237:      * trace and should have a valid cache entry for native scopeChain.
27237:      */
27319:     JS_ASSERT(OBJ_GET_PARENT(cx, scopeChain));
27237:     JS_ASSERT(!JS_ON_TRACE(cx));
27237: 
27319:     JSObject *obj = scopeChain;
27319: 
27237:     /*
27319:      * Loop over cacheable objects on the scope chain until we find a
27319:      * property. We also stop when we reach the global object skipping any
27319:      * farther checks or lookups. For details see the JSOP_BINDNAME case of
27319:      * js_Interpret.
27237:      */
31467:     for (int scopeIndex = 0; js_IsCacheableNonGlobalScope(obj); scopeIndex++) {
27237:         JSObject *pobj;
27236:         JSProperty *prop;
27319:         int protoIndex = js_LookupPropertyWithFlags(cx, obj, id,
27319:                                                     cx->resolveFlags,
27237:                                                     &pobj, &prop);
27237:         if (protoIndex < 0)
27237:             return NULL;
27237:         if (prop) {
27237:             JS_ASSERT(OBJ_IS_NATIVE(pobj));
27319:             JS_ASSERT(OBJ_GET_CLASS(cx, pobj) == OBJ_GET_CLASS(cx, obj));
27575: #ifdef DEBUG
27575:             JSPropCacheEntry *entry =
27575: #endif
27930:             js_FillPropertyCache(cx, scopeChain,
27490:                                  scopeIndex, protoIndex, pobj,
27930:                                  (JSScopeProperty *) prop, false);
27575:             JS_ASSERT(entry);
27237:             JS_UNLOCK_OBJ(cx, pobj);
27237:             return obj;
27237:         }
27237: 
27319:         /* Call and other cacheable objects always have a parent. */
27319:         obj = OBJ_GET_PARENT(cx, obj);
27319:         if (!OBJ_GET_PARENT(cx, obj))
27237:             return obj;
27237:     }
27319: 
27319:     /* Loop until we find a property or reach the global object. */
27237:     do {
27237:         JSObject *pobj;
27237:         JSProperty *prop;
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:             return NULL;
    1:         if (prop) {
31501:             pobj->dropProperty(cx, prop);
27237:             break;
27237:         }
27319: 
27319:         /*
27319:          * We conservatively assume that a resolve hook could mutate the scope
31501:          * chain during JSObject::lookupProperty. So we must check if parent is
31501:          * not null here even if it wasn't before the lookup.
27319:          */
27319:         JSObject *parent = OBJ_GET_PARENT(cx, obj);
27319:         if (!parent)
27319:             break;
27237:         obj = parent;
27319:     } while (OBJ_GET_PARENT(cx, obj));
    1:     return obj;
    1: }
    1: 
    1: JSBool
    1: js_NativeGet(JSContext *cx, JSObject *obj, JSObject *pobj,
32658:              JSScopeProperty *sprop, uintN getHow, jsval *vp)
    1: {
27490:     js_LeaveTraceIfGlobalObject(cx, pobj);
27490: 
27490:     JSScope *scope;
27490:     uint32 slot;
27490:     int32 sample;
27538:     JSTempValueRooter tvr, tvr2;
27490:     JSBool ok;
27490: 
    1:     JS_ASSERT(OBJ_IS_NATIVE(pobj));
    1:     JS_ASSERT(JS_IS_OBJ_LOCKED(cx, pobj));
27490:     scope = OBJ_SCOPE(pobj);
27490: 
27490:     slot = sprop->slot;
27490:     *vp = (slot != SPROP_INVALID_SLOT)
27490:           ? LOCKED_OBJ_GET_SLOT(pobj, slot)
27490:           : JSVAL_VOID;
27490:     if (SPROP_HAS_STUB_GETTER(sprop))
32658:         return true;
32658: 
32658:     if (JS_UNLIKELY(sprop->isMethod()) && (getHow & JSGET_NO_METHOD_BARRIER)) {
32658:         JS_ASSERT(sprop->methodValue() == *vp);
32658:         return true;
32658:     }
27490: 
27490:     sample = cx->runtime->propertyRemovals;
    1:     JS_UNLOCK_SCOPE(cx, scope);
    1:     JS_PUSH_TEMP_ROOT_SPROP(cx, sprop, &tvr);
27538:     JS_PUSH_TEMP_ROOT_OBJECT(cx, pobj, &tvr2);
32658:     ok = sprop->get(cx, obj, pobj, vp);
27538:     JS_POP_TEMP_ROOT(cx, &tvr2);
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1:     if (!ok)
32658:         return false;
    1: 
    1:     JS_LOCK_SCOPE(cx, scope);
    1:     if (SLOT_IN_SCOPE(slot, scope) &&
    1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
30258:          scope->has(sprop))) {
32658:         jsval v = *vp;
32658:         if (!scope->methodWriteBarrier(cx, sprop, v)) {
32658:             JS_UNLOCK_SCOPE(cx, scope);
32658:             return false;
32658:         }
32658:         LOCKED_OBJ_SET_SLOT(pobj, slot, v);
32658:     }
32658: 
32658:     return true;
    1: }
    1: 
    1: JSBool
32658: js_NativeSet(JSContext *cx, JSObject *obj, JSScopeProperty *sprop, bool added,
32658:              jsval *vp)
    1: {
27490:     js_LeaveTraceIfGlobalObject(cx, obj);
27490: 
27490:     JSScope *scope;
27490:     uint32 slot;
27490:     int32 sample;
27490:     JSTempValueRooter tvr;
27490:     JSBool ok;
27490: 
    1:     JS_ASSERT(OBJ_IS_NATIVE(obj));
    1:     JS_ASSERT(JS_IS_OBJ_LOCKED(cx, obj));
27490:     scope = OBJ_SCOPE(obj);
27490: 
27490:     slot = sprop->slot;
27490:     if (slot != SPROP_INVALID_SLOT) {
27490:         OBJ_CHECK_SLOT(obj, slot);
27490: 
27490:         /* If sprop has a stub setter, keep scope locked and just store *vp. */
32658:         if (SPROP_HAS_STUB_SETTER(sprop)) {
32658:             if (!added && !scope->methodWriteBarrier(cx, sprop, *vp)) {
32658:                 JS_UNLOCK_SCOPE(cx, scope);
32658:                 return false;
32658:             }
32658:             LOCKED_OBJ_SET_SLOT(obj, slot, *vp);
32658:             return true;
32658:         }
27490:     } else {
    1:         /*
    1:          * Allow API consumers to create shared properties with stub setters.
    1:          * Such properties lack value storage, so setting them is like writing
    1:          * to /dev/null.
25100:          *
25100:          * But we can't short-circuit if there's a scripted getter or setter
25100:          * since we might need to throw. In that case, we let SPROP_SET
25100:          * decide whether to throw an exception. See bug 478047.
    1:          */
25100:         if (!(sprop->attrs & JSPROP_GETTER) && SPROP_HAS_STUB_SETTER(sprop)) {
25100:             JS_ASSERT(!(sprop->attrs & JSPROP_SETTER));
32658:             return true;
    1:         }
27490:     }
27490: 
27490:     sample = cx->runtime->propertyRemovals;
    1:     JS_UNLOCK_SCOPE(cx, scope);
    1:     JS_PUSH_TEMP_ROOT_SPROP(cx, sprop, &tvr);
32658:     ok = sprop->set(cx, obj, vp);
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1:     if (!ok)
32658:         return false;
    1: 
    1:     JS_LOCK_SCOPE(cx, scope);
    1:     if (SLOT_IN_SCOPE(slot, scope) &&
    1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
30258:          scope->has(sprop))) {
32658:         jsval v = *vp;
32658:         if (!added && !scope->methodWriteBarrier(cx, sprop, v)) {
32658:             JS_UNLOCK_SCOPE(cx, scope);
32658:             return false;
32658:         }
32658:         LOCKED_OBJ_SET_SLOT(obj, slot, v);
32658:     }
32658: 
32658:     return true;
    1: }
    1: 
    1: JSBool
32658: js_GetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uintN getHow,
27575:                      jsval *vp)
    1: {
25942:     JSObject *aobj, *obj2;
11377:     int protoIndex;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1: 
32658:     JS_ASSERT_IF(getHow & JSGET_CACHE_RESULT, !JS_ON_TRACE(cx));
32658: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
25942:     aobj = js_GetProtoIfDenseArray(cx, obj);
25942:     protoIndex = js_LookupPropertyWithFlags(cx, aobj, id, cx->resolveFlags,
19712:                                             &obj2, &prop);
11377:     if (protoIndex < 0)
    1:         return JS_FALSE;
    1:     if (!prop) {
    1:         *vp = JSVAL_VOID;
    1: 
    1:         if (!OBJ_GET_CLASS(cx, obj)->getProperty(cx, obj, ID_TO_VALUE(id), vp))
    1:             return JS_FALSE;
    1: 
32658:         PCMETER(getHow & JSGET_CACHE_RESULT && JS_PROPERTY_CACHE(cx).nofills++);
11377: 
    1:         /*
    1:          * Give a strict warning if foo.bar is evaluated by a script for an
    1:          * object foo with no property named 'bar'.
    1:          */
24598:         jsbytecode *pc;
24598:         if (JSVAL_IS_VOID(*vp) && ((pc = js_GetCurrentBytecodePC(cx)) != NULL)) {
    1:             JSOp op;
    1:             uintN flags;
    1: 
 3164:             op = (JSOp) *pc;
25215:             if (op == JSOP_TRAP) {
25215:                 JS_ASSERT_NOT_ON_TRACE(cx);
25215:                 op = JS_GetTrapOpcode(cx, cx->fp->script, pc);
25215:             }
    1:             if (op == JSOP_GETXPROP) {
    1:                 flags = JSREPORT_ERROR;
    1:             } else {
    1:                 if (!JS_HAS_STRICT_OPTION(cx) ||
31814:                     (op != JSOP_GETPROP && op != JSOP_GETELEM) ||
31911:                     js_CurrentPCIsInImacro(cx)) {
    1:                     return JS_TRUE;
    1:                 }
    1: 
    1:                 /*
    1:                  * XXX do not warn about missing __iterator__ as the function
    1:                  * may be called from JS_GetMethodById. See bug 355145.
    1:                  */
    1:                 if (id == ATOM_TO_JSID(cx->runtime->atomState.iteratorAtom))
    1:                     return JS_TRUE;
    1: 
25213:                 /* Do not warn about tests like (obj[prop] == undefined). */
25213:                 if (cx->resolveFlags == JSRESOLVE_INFER) {
25213:                     js_LeaveTrace(cx);
    1:                     pc += js_CodeSpec[op].length;
    1:                     if (Detecting(cx, pc))
    1:                         return JS_TRUE;
25213:                 } else if (cx->resolveFlags & JSRESOLVE_DETECTING) {
25213:                     return JS_TRUE;
25213:                 }
    1: 
    1:                 flags = JSREPORT_WARNING | JSREPORT_STRICT;
    1:             }
    1: 
    1:             /* Ok, bad undefined property reference: whine about it. */
    1:             if (!js_ReportValueErrorFlags(cx, flags, JSMSG_UNDEFINED_PROP,
    1:                                           JSDVG_IGNORE_STACK, ID_TO_VALUE(id),
    1:                                           NULL, NULL, NULL)) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     if (!OBJ_IS_NATIVE(obj2)) {
31501:         obj2->dropProperty(cx, prop);
31501:         return obj2->getProperty(cx, id, vp);
    1:     }
    1: 
    1:     sprop = (JSScopeProperty *) prop;
27490: 
32658:     if (getHow & JSGET_CACHE_RESULT) {
24499:         JS_ASSERT_NOT_ON_TRACE(cx);
27930:         js_FillPropertyCache(cx, aobj, 0, protoIndex, obj2, sprop, false);
27490:     }
27932: 
32658:     if (!js_NativeGet(cx, obj, obj2, sprop, getHow, vp))
27932:         return JS_FALSE;
27932: 
27490:     JS_UNLOCK_OBJ(cx, obj2);
27490:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
11377: js_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
32658:     return js_GetPropertyHelper(cx, obj, id, JSGET_METHOD_BARRIER, vp);
11377: }
11377: 
11377: JSBool
32658: js_GetMethod(JSContext *cx, JSObject *obj, jsid id, uintN getHow, jsval *vp)
26187: {
29913:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
29913: 
26187:     if (obj->map->ops == &js_ObjectOps ||
26187:         obj->map->ops->getProperty == js_GetProperty) {
32658:         return js_GetPropertyHelper(cx, obj, id, getHow, vp);
32658:     }
32658:     JS_ASSERT_IF(getHow & JSGET_CACHE_RESULT, OBJ_IS_DENSE_ARRAY(cx, obj));
26187: #if JS_HAS_XML_SUPPORT
26187:     if (OBJECT_IS_XML(cx, obj))
26187:         return js_GetXMLMethod(cx, obj, id, vp);
26187: #endif
31501:     return obj->getProperty(cx, id, vp);
26187: }
26187: 
27372: JS_FRIEND_API(JSBool)
27372: js_CheckUndeclaredVarAssignment(JSContext *cx)
27372: {
27372:     JSStackFrame *fp;
27372:     if (!JS_HAS_STRICT_OPTION(cx) ||
27372:         !(fp = js_GetTopStackFrame(cx)) ||
27372:         !fp->regs ||
27372:         js_GetOpcode(cx, fp->script, fp->regs->pc) != JSOP_SETNAME) {
27372:         return JS_TRUE;
27372:     }
27372: 
27372:     JSAtom *atom;
27372:     GET_ATOM_FROM_BYTECODE(fp->script, fp->regs->pc, 0, atom);
27372: 
27372:     const char *bytes = js_AtomToPrintableString(cx, atom);
27372:     return bytes &&
27372:            JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING | JSREPORT_STRICT,
27372:                                         js_GetErrorMessage, NULL,
27372:                                         JSMSG_UNDECLARED_VAR, bytes);
27372: }
27372: 
27932: /*
27932:  * Note: all non-error exits in this function must notify the tracer using
32658:  * SetPropHit when called from the interpreter, which is detected by testing
32658:  * (defineHow & JSDNP_CACHE_RESULT).
27932:  */
27932: JSBool
32658: js_SetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uintN defineHow,
27575:                      jsval *vp)
11377: {
11377:     int protoIndex;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1:     JSScope *scope;
    1:     uintN attrs, flags;
    1:     intN shortid;
    1:     JSClass *clasp;
    1:     JSPropertyOp getter, setter;
27930:     bool added;
    1: 
32658:     JS_ASSERT((defineHow & ~(JSDNP_CACHE_RESULT | JSDNP_SET_METHOD)) == 0);
32658:     if (defineHow & JSDNP_CACHE_RESULT)
28398:         JS_ASSERT_NOT_ON_TRACE(cx);
28398: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
22452:     /*
22452:      * We peek at OBJ_SCOPE(obj) without locking obj. Any race means a failure
22452:      * to seal before sharing, which is inherently ambiguous.
22452:      */
30258:     if (OBJ_SCOPE(obj)->sealed() && OBJ_SCOPE(obj)->object == obj) {
22452:         flags = JSREPORT_ERROR;
22452:         goto read_only_error;
22452:     }
22452: 
19712:     protoIndex = js_LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags,
19712:                                             &pobj, &prop);
11377:     if (protoIndex < 0)
27932:         return JS_FALSE;
27237:     if (prop) {
27237:         if (!OBJ_IS_NATIVE(pobj)) {
31501:             pobj->dropProperty(cx, prop);
    1:             prop = NULL;
    1:         }
27237:     } else {
27237:         /* We should never add properties to lexical blocks.  */
27237:         JS_ASSERT(OBJ_GET_CLASS(cx, obj) != &js_BlockClass);
27237: 
27372:         if (!OBJ_GET_PARENT(cx, obj) && !js_CheckUndeclaredVarAssignment(cx))
27932:             return JS_FALSE;
27237:     }
    1:     sprop = (JSScopeProperty *) prop;
    1: 
    1:     /*
    1:      * Now either sprop is null, meaning id was not found in obj or one of its
    1:      * prototypes; or sprop is non-null, meaning id was found in pobj's scope.
    1:      * If JS_THREADSAFE and sprop is non-null, then scope is locked, and sprop
31501:      * is held: we must JSObject::dropProperty or JS_UNLOCK_SCOPE before we
31501:      * return (the two are equivalent for native objects, but we use
31501:      * JS_UNLOCK_SCOPE because it is cheaper).
    1:      */
    1:     attrs = JSPROP_ENUMERATE;
    1:     flags = 0;
    1:     shortid = 0;
    1:     clasp = OBJ_GET_CLASS(cx, obj);
    1:     getter = clasp->getProperty;
    1:     setter = clasp->setProperty;
    1: 
    1:     if (sprop) {
    1:         /*
    1:          * Set scope for use below.  It was locked by js_LookupProperty, and
    1:          * we know pobj owns it (i.e., scope->object == pobj).  Therefore we
    1:          * optimize JS_UNLOCK_OBJ(cx, pobj) into JS_UNLOCK_SCOPE(cx, scope).
    1:          */
    1:         scope = OBJ_SCOPE(pobj);
    1: 
    1:         attrs = sprop->attrs;
    1:         if ((attrs & JSPROP_READONLY) ||
30258:             (scope->sealed() && (attrs & JSPROP_SHARED))) {
    1:             JS_UNLOCK_SCOPE(cx, scope);
    1: 
    1:             /*
    1:              * Here, we'll either return true or goto read_only_error, which
    1:              * reports a strict warning or throws an error.  So we redefine
    1:              * the |flags| local variable to be JSREPORT_* flags to pass to
    1:              * JS_ReportErrorFlagsAndNumberUC at label read_only_error.  We
    1:              * must likewise re-task flags further below for the other 'goto
    1:              * read_only_error;' case.
    1:              */
    1:             flags = JSREPORT_ERROR;
    1:             if (attrs & JSPROP_READONLY) {
    1:                 if (!JS_HAS_STRICT_OPTION(cx)) {
    1:                     /* Just return true per ECMA if not in strict mode. */
32658:                     PCMETER((defineHow & JSDNP_CACHE_RESULT) && JS_PROPERTY_CACHE(cx).rofills++);
32850:                     if (defineHow & JSDNP_CACHE_RESULT) {
32850:                         JS_ASSERT_NOT_ON_TRACE(cx);
27932:                         TRACE_2(SetPropHit, JS_NO_PROP_CACHE_FILL, sprop);
32850:                     }
27932:                     return JS_TRUE;
32577: #ifdef JS_TRACER
27934:                 error: // TRACE_2 jumps here in case of error.
27934:                     return JS_FALSE;
32577: #endif
    1:                 }
    1: 
    1:                 /* Strict mode: report a read-only strict warning. */
    1:                 flags = JSREPORT_STRICT | JSREPORT_WARNING;
    1:             }
    1:             goto read_only_error;
    1:         }
    1: 
32568:         if (pobj != obj) {
    1:             /*
    1:              * We found id in a prototype object: prepare to share or shadow.
11377:              *
    1:              * NB: Thanks to the immutable, garbage-collected property tree
    1:              * maintained by jsscope.c in cx->runtime, we needn't worry about
    1:              * sprop going away behind our back after we've unlocked scope.
    1:              */
    1:             JS_UNLOCK_SCOPE(cx, scope);
    1: 
27932:             /* Don't clone a shared prototype property. */
    1:             if (attrs & JSPROP_SHARED) {
32658:                 if (defineHow & JSDNP_CACHE_RESULT) {
32850:                     JS_ASSERT_NOT_ON_TRACE(cx);
27932:                     JSPropCacheEntry *entry;
27932:                     entry = js_FillPropertyCache(cx, obj, 0, protoIndex, pobj, sprop, false);
27932:                     TRACE_2(SetPropHit, entry, sprop);
27932:                 }
27932: 
    1:                 if (SPROP_HAS_STUB_SETTER(sprop) &&
    1:                     !(sprop->attrs & JSPROP_GETTER)) {
27932:                     return JS_TRUE;
27932:                 }
27932: 
32658:                 return sprop->set(cx, obj, vp);
    1:             }
    1: 
    1:             /* Restore attrs to the ECMA default for new properties. */
    1:             attrs = JSPROP_ENUMERATE;
    1: 
    1:             /*
    1:              * Preserve the shortid, getter, and setter when shadowing any
    1:              * property that has a shortid.  An old API convention requires
    1:              * that the property's getter and setter functions receive the
    1:              * shortid, not id, when they are called on the shadow we are
    1:              * about to create in obj's scope.
    1:              */
    1:             if (sprop->flags & SPROP_HAS_SHORTID) {
    1:                 flags = SPROP_HAS_SHORTID;
    1:                 shortid = sprop->shortid;
    1:                 getter = sprop->getter;
    1:                 setter = sprop->setter;
    1:             }
    1: 
    1:             /*
    1:              * Forget we found the proto-property now that we've copied any
    1:              * needed member values.
    1:              */
    1:             sprop = NULL;
    1:         }
    1: #ifdef __GNUC__ /* suppress bogus gcc warnings */
    1:     } else {
    1:         scope = NULL;
    1: #endif
    1:     }
    1: 
27930:     added = false;
    1:     if (!sprop) {
11377:         /*
11377:          * Purge the property cache of now-shadowed id in obj's scope chain.
11377:          * Do this early, before locking obj to avoid nesting locks.
11377:          */
25936:         js_PurgeScopeChain(cx, obj, id);
11377: 
    1:         /* Find or make a property descriptor with the right heritage. */
    1:         JS_LOCK_OBJ(cx, obj);
    1:         scope = js_GetMutableScope(cx, obj);
    1:         if (!scope) {
    1:             JS_UNLOCK_OBJ(cx, obj);
27932:             return JS_FALSE;
    1:         }
32658: 
    1:         if (clasp->flags & JSCLASS_SHARE_ALL_PROPERTIES)
    1:             attrs |= JSPROP_SHARED;
32658: 
32658:         /*
32658:          * Check for Object class here to avoid defining a method on a class
32658:          * with magic resolve, addProperty, getProperty, etc. hooks.
32658:          */
32658:         if ((defineHow & JSDNP_SET_METHOD) &&
32658:             obj->getClass() == &js_ObjectClass) {
32658:             JS_ASSERT(VALUE_IS_FUNCTION(cx, *vp));
32658:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
32658: 
32658:             JSObject *funobj = JSVAL_TO_OBJECT(*vp);
32658:             if (FUN_OBJECT(GET_FUNCTION_PRIVATE(cx, funobj)) == funobj) {
32658:                 flags |= SPROP_IS_METHOD;
32658:                 getter = js_CastAsPropertyOp(funobj);
32658:             }
32658:         }
32658: 
30258:         sprop = scope->add(cx, id, getter, setter, SPROP_INVALID_SLOT, attrs,
30258:                            flags, shortid);
    1:         if (!sprop) {
    1:             JS_UNLOCK_SCOPE(cx, scope);
27932:             return JS_FALSE;
    1:         }
    1: 
    1:         /*
    1:          * Initialize the new property value (passed to setter) to undefined.
    1:          * Note that we store before calling addProperty, to match the order
    1:          * in js_DefineNativeProperty.
    1:          */
    1:         if (SPROP_HAS_VALID_SLOT(sprop, scope))
    1:             LOCKED_OBJ_SET_SLOT(obj, sprop->slot, JSVAL_VOID);
    1: 
    1:         /* XXXbe called with obj locked */
32658:         if (!AddPropertyHelper(cx, clasp, obj, scope, sprop, vp)) {
30258:             scope->remove(cx, id);
    1:             JS_UNLOCK_SCOPE(cx, scope);
32658:             return JS_FALSE;
32658:         }
27930:         added = true;
    1:     }
    1: 
32658:     if (defineHow & JSDNP_CACHE_RESULT) {
32850:         JS_ASSERT_NOT_ON_TRACE(cx);
27932:         JSPropCacheEntry *entry;
27932:         entry = js_FillPropertyCache(cx, obj, 0, 0, obj, sprop, added);
27932:         TRACE_2(SetPropHit, entry, sprop);
27932:     }
27932: 
32658:     if (!js_NativeSet(cx, obj, sprop, added, vp))
27575:         return NULL;
27575: 
27490:     JS_UNLOCK_SCOPE(cx, scope);
27932:     return JS_TRUE;
    1: 
    1:   read_only_error:
    1:     return js_ReportValueErrorFlags(cx, flags, JSMSG_READ_ONLY,
    1:                                     JSDVG_IGNORE_STACK, ID_TO_VALUE(id), NULL,
27932:                                     NULL, NULL);
    1: }
    1: 
    1: JSBool
11377: js_SetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
11377: {
27932:     return js_SetPropertyHelper(cx, obj, id, false, vp);
11377: }
11377: 
11377: JSBool
    1: js_GetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                  uintN *attrsp)
    1: {
    1:     JSBool noprop, ok;
    1:     JSScopeProperty *sprop;
    1: 
    1:     noprop = !prop;
    1:     if (noprop) {
    1:         if (!js_LookupProperty(cx, obj, id, &obj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop) {
    1:             *attrsp = 0;
    1:             return JS_TRUE;
    1:         }
    1:         if (!OBJ_IS_NATIVE(obj)) {
31501:             ok = obj->getAttributes(cx, id, prop, attrsp);
31501:             obj->dropProperty(cx, prop);
    1:             return ok;
    1:         }
    1:     }
    1:     sprop = (JSScopeProperty *)prop;
    1:     *attrsp = sprop->attrs;
    1:     if (noprop)
31501:         obj->dropProperty(cx, prop);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: js_SetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                  uintN *attrsp)
    1: {
    1:     JSBool noprop, ok;
    1:     JSScopeProperty *sprop;
    1: 
    1:     noprop = !prop;
    1:     if (noprop) {
    1:         if (!js_LookupProperty(cx, obj, id, &obj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop)
    1:             return JS_TRUE;
    1:         if (!OBJ_IS_NATIVE(obj)) {
31501:             ok = obj->setAttributes(cx, id, prop, attrsp);
31501:             obj->dropProperty(cx, prop);
    1:             return ok;
    1:         }
    1:     }
    1:     sprop = (JSScopeProperty *)prop;
    1:     sprop = js_ChangeNativePropertyAttrs(cx, obj, sprop, *attrsp, 0,
    1:                                          sprop->getter, sprop->setter);
    1:     if (noprop)
31501:         obj->dropProperty(cx, prop);
    1:     return (sprop != NULL);
    1: }
    1: 
    1: JSBool
    1: js_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, jsval *rval)
    1: {
    1:     JSObject *proto;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1:     JSScope *scope;
    1:     JSBool ok;
    1: 
    1:     *rval = JSVAL_TRUE;
    1: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
    1:     if (!js_LookupProperty(cx, obj, id, &proto, &prop))
    1:         return JS_FALSE;
    1:     if (!prop || proto != obj) {
    1:         /*
    1:          * If the property was found in a native prototype, check whether it's
    1:          * shared and permanent.  Such a property stands for direct properties
    1:          * in all delegating objects, matching ECMA semantics without bloating
    1:          * each delegating object.
    1:          */
    1:         if (prop) {
    1:             if (OBJ_IS_NATIVE(proto)) {
    1:                 sprop = (JSScopeProperty *)prop;
    1:                 if (SPROP_IS_SHARED_PERMANENT(sprop))
    1:                     *rval = JSVAL_FALSE;
    1:             }
31501:             proto->dropProperty(cx, prop);
    1:             if (*rval == JSVAL_FALSE)
    1:                 return JS_TRUE;
    1:         }
    1: 
    1:         /*
    1:          * If no property, or the property comes unshared or impermanent from
    1:          * a prototype, call the class's delProperty hook, passing rval as the
    1:          * result parameter.
    1:          */
    1:         return OBJ_GET_CLASS(cx, obj)->delProperty(cx, obj, ID_TO_VALUE(id),
    1:                                                    rval);
    1:     }
    1: 
    1:     sprop = (JSScopeProperty *)prop;
    1:     if (sprop->attrs & JSPROP_PERMANENT) {
31501:         obj->dropProperty(cx, prop);
    1:         *rval = JSVAL_FALSE;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /* XXXbe called with obj locked */
32603:     if (!obj->getClass()->delProperty(cx, obj, SPROP_USERID(sprop), rval)) {
31501:         obj->dropProperty(cx, prop);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     scope = OBJ_SCOPE(obj);
    1:     if (SPROP_HAS_VALID_SLOT(sprop, scope))
    1:         GC_POKE(cx, LOCKED_OBJ_GET_SLOT(obj, sprop->slot));
    1: 
30258:     ok = scope->remove(cx, id);
31501:     obj->dropProperty(cx, prop);
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_DefaultValue(JSContext *cx, JSObject *obj, JSType hint, jsval *vp)
    1: {
    1:     jsval v, save;
    1:     JSString *str;
    1: 
    1:     v = save = OBJECT_TO_JSVAL(obj);
    1:     switch (hint) {
    1:       case JSTYPE_STRING:
    1:         /*
30443:          * Optimize for String objects with standard toString methods. Support
30443:          * new String(...) instances whether mutated to have their own scope or
30443:          * not, as well as direct String.prototype references.
30443:          */
30443:         if (OBJ_GET_CLASS(cx, obj) == &js_StringClass) {
30443:             jsid toStringId = ATOM_TO_JSID(cx->runtime->atomState.toStringAtom);
30443: 
30443:             JS_LOCK_OBJ(cx, obj);
30443:             JSScope *scope = OBJ_SCOPE(obj);
30443:             JSScopeProperty *sprop = scope->lookup(toStringId);
30645:             JSObject *pobj = obj;
30645: 
30645:             if (!sprop) {
32603:                 pobj = obj->getProto();
30645: 
30645:                 if (pobj && OBJ_GET_CLASS(cx, pobj) == &js_StringClass) {
30443:                     JS_UNLOCK_SCOPE(cx, scope);
30645:                     JS_LOCK_OBJ(cx, pobj);
30645:                     scope = OBJ_SCOPE(pobj);
30443:                     sprop = scope->lookup(toStringId);
30443:                 }
30443:             }
30443: 
30443:             if (sprop &&
32568:                 SPROP_HAS_STUB_GETTER(sprop) &&
30443:                 SPROP_HAS_VALID_SLOT(sprop, scope)) {
30645:                 jsval fval = LOCKED_OBJ_GET_SLOT(pobj, sprop->slot);
30443: 
30443:                 if (VALUE_IS_FUNCTION(cx, fval)) {
30443:                     JSObject *funobj = JSVAL_TO_OBJECT(fval);
30443:                     JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
30443: 
30443:                     if (FUN_FAST_NATIVE(fun) == js_str_toString) {
30443:                         JS_UNLOCK_SCOPE(cx, scope);
32684:                         *vp = obj->fslots[JSSLOT_PRIMITIVE_THIS];
30443:                         return JS_TRUE;
30443:                     }
30443:                 }
30443:             }
30443:             JS_UNLOCK_SCOPE(cx, scope);
30443:         }
30443: 
30443:         /*
    1:          * Propagate the exception if js_TryMethod finds an appropriate
    1:          * method, and calling that method returned failure.
    1:          */
    1:         if (!js_TryMethod(cx, obj, cx->runtime->atomState.toStringAtom, 0, NULL,
    1:                           &v)) {
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         if (!JSVAL_IS_PRIMITIVE(v)) {
    1:             if (!OBJ_GET_CLASS(cx, obj)->convert(cx, obj, hint, &v))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
    1: 
    1:       default:
    1:         if (!OBJ_GET_CLASS(cx, obj)->convert(cx, obj, hint, &v))
    1:             return JS_FALSE;
    1:         if (!JSVAL_IS_PRIMITIVE(v)) {
    1:             JSType type = JS_TypeOfValue(cx, v);
    1:             if (type == hint ||
    1:                 (type == JSTYPE_FUNCTION && hint == JSTYPE_OBJECT)) {
    1:                 goto out;
    1:             }
    1:             if (!js_TryMethod(cx, obj, cx->runtime->atomState.toStringAtom, 0,
    1:                               NULL, &v)) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1:     }
    1:     if (!JSVAL_IS_PRIMITIVE(v)) {
    1:         /* Avoid recursive death when decompiling in js_ReportValueError. */
    1:         if (hint == JSTYPE_STRING) {
    1:             str = JS_InternString(cx, OBJ_GET_CLASS(cx, obj)->name);
    1:             if (!str)
    1:                 return JS_FALSE;
    1:         } else {
    1:             str = NULL;
    1:         }
    1:         *vp = OBJECT_TO_JSVAL(obj);
    1:         js_ReportValueError2(cx, JSMSG_CANT_CONVERT_TO,
    1:                              JSDVG_SEARCH_STACK, save, str,
    1:                              (hint == JSTYPE_VOID)
    1:                              ? "primitive type"
 4342:                              : JS_TYPE_STR(hint));
    1:         return JS_FALSE;
    1:     }
    1: out:
    1:     *vp = v;
    1:     return JS_TRUE;
    1: }
    1: 
15677: /*
17049:  * Private type used to enumerate properties of a native JS object. It is
17049:  * allocated as necessary from JSENUMERATE_INIT and is freed when running the
17049:  * GC. The structure is not allocated when there are no enumerable properties
17049:  * in the object. Instead for the empty enumerator the code uses JSVAL_ZERO as
17049:  * the enumeration state.
17049:  *
33128:  * JSThreadData.nativeEnumCache caches the enumerators using scope's shape to
17049:  * avoid repeated scanning of scopes for enumerable properties. The cache
17049:  * entry is either JSNativeEnumerator* or, for the empty enumerator, the shape
17049:  * value itself. The latter is stored as (shape << 1) | 1 to ensure that it is
17049:  * always different from JSNativeEnumerator* values.
33128:  *
33128:  * We cache the enumerators in the JSENUMERATE_INIT case of js_Enumerate, not
33128:  * during JSENUMERATE_DESTROY. The GC can invoke the latter case during the
33128:  * finalization when JSNativeEnumerator contains finalized ids and the
33128:  * enumerator must be freed.
15677:  */
15677: struct JSNativeEnumerator {
17049:     /*
17049:      * The index into the ids array. It runs from the length down to 1 when
17049:      * the enumerator is running. It is 0 when the enumerator is finished and
33128:      * can be reused on a cache hit.
17049:     */
33128:     uint32                  cursor;
15677:     uint32                  length;     /* length of ids array */
17049:     uint32                  shape;      /* "shape" number -- see jsscope.h */
15677:     jsid                    ids[1];     /* enumeration id array */
33128: 
33128:     static inline size_t size(uint32 length) {
33128:         JS_ASSERT(length != 0);
33128:         return offsetof(JSNativeEnumerator, ids) +
33128:                (size_t) length * sizeof(jsid);
33128:     }
33128: 
33128:     bool isFinished() const {
33128:         return cursor == 0;
33128:     }
33128: 
33128:     void mark(JSTracer *trc) {
33128:         JS_ASSERT(length >= 1);
33128:         jsid *cursor = ids;
33128:         jsid *end = ids + length;
33128:         do {
33128:             js_TraceId(trc, *cursor);
33128:         } while (++cursor != end);
33128:     }
15677: };
    1: 
17049: /* The tagging of shape values requires one bit. */
17049: JS_STATIC_ASSERT((jsuword) SHAPE_OVERFLOW_BIT <=
17049:                  ((jsuword) 1 << (JS_BITS_PER_WORD - 1)));
17049: 
33128: static void
33128: SetEnumeratorCache(JSContext *cx, jsuword *cachep, jsuword newcache)
33128: {
33128:     jsuword old = *cachep;
33128:     *cachep = newcache;
33128:     if (!(old & jsuword(1)) && old) {
33128:         /* Free the cached enumerator unless it is running. */
33128:         JSNativeEnumerator *ne = reinterpret_cast<JSNativeEnumerator *>(old);
33128:         if (ne->isFinished())
33128:             cx->free(ne);
33128:     }
33128: }
33128: 
    1: JSBool
    1: js_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
    1:              jsval *statep, jsid *idp)
    1: {
33128:     /* Here cx is JSTracer when enum_op is JSENUMERATE_MARK. */
33128:     JSClass *clasp = obj->getClass();
33128:     JSEnumerateOp enumerate = clasp->enumerate;
11835:     if (clasp->flags & JSCLASS_NEW_ENUMERATE) {
11835:         JS_ASSERT(enumerate != JS_EnumerateStub);
    1:         return ((JSNewEnumerateOp) enumerate)(cx, obj, enum_op, statep, idp);
11835:     }
    1: 
    1:     switch (enum_op) {
33128:       case JSENUMERATE_INIT: {
    1:         if (!enumerate(cx, obj))
33128:             return false;
15677: 
15677:         /*
15677:          * The set of all property ids is pre-computed when the iterator is
15677:          * initialized to avoid problems caused by properties being deleted
15677:          * during the iteration.
15677:          *
15677:          * Use a do-while(0) loop to avoid too many nested ifs. If ne is null
33128:          * after the loop, it indicates an empty enumerator.
15677:          */
33128:         JSNativeEnumerator *ne;
33128:         uint32 length;
33128:         do {
33128:             uint32 shape = OBJ_SHAPE(obj);
33128: 
33128:             ENUM_CACHE_METER(nativeEnumProbes);
33128:             jsuword *cachep = &JS_THREAD_DATA(cx)->
33128:                               nativeEnumCache[NATIVE_ENUM_CACHE_HASH(shape)];
33128:             jsuword oldcache = *cachep;
33128:             if (oldcache & (jsuword) 1) {
33128:                 if (uint32(oldcache >> 1) == shape) {
33128:                     /* scope has a shape with no enumerable properties. */
15677:                     ne = NULL;
    1:                     length = 0;
33128:                     break;
33128:                 }
33128:             } else if (oldcache != jsuword(0)) {
33128:                 ne = reinterpret_cast<JSNativeEnumerator *>(oldcache);
33128:                 JS_ASSERT(ne->length >= 1);
33128:                 if (ne->shape == shape && ne->isFinished()) {
33128:                     /* Mark ne as active. */
33128:                     ne->cursor = ne->length;
33128:                     length = ne->length;
33128:                     JS_ASSERT(!ne->isFinished());
33128:                     break;
33128:                 }
33128:             }
33128:             ENUM_CACHE_METER(nativeEnumMisses);
33128: 
    1:             JS_LOCK_OBJ(cx, obj);
33128: 
33128:             /* Count all enumerable properties in object's scope. */
33128:             JSScope *scope = OBJ_SCOPE(obj);
17049:             length = 0;
33128:             for (JSScopeProperty *sprop = SCOPE_LAST_PROP(scope);
33128:                  sprop;
33128:                  sprop = sprop->parent) {
 9090:                 if ((sprop->attrs & JSPROP_ENUMERATE) &&
    1:                     !(sprop->flags & SPROP_IS_ALIAS) &&
30258:                     (!scope->hadMiddleDelete() || scope->has(sprop))) {
    1:                     length++;
    1:                 }
    1:             }
17049:             if (length == 0) {
32735:                /*
32735:                 * Cache the scope without enumerable properties unless its
32735:                 * shape overflows, see bug 440834.
32735:                 */
33128:                 JS_UNLOCK_SCOPE(cx, scope);
33128:                 if (shape < SHAPE_OVERFLOW_BIT) {
33128:                     SetEnumeratorCache(cx, cachep,
33128:                                        (jsuword(shape) << 1) | jsuword(1));
33128:                 }
33128:                 ne = NULL;
15677:                 break;
17049:             }
17049: 
33128:             ne = (JSNativeEnumerator *)
33128:                  cx->mallocNoReport(JSNativeEnumerator::size(length));
15677:             if (!ne) {
33128:                 /* Report the OOM error outside the lock. */
15677:                 JS_UNLOCK_SCOPE(cx, scope);
33128:                 JS_ReportOutOfMemory(cx);
33128:                 return false;
    1:             }
15677:             ne->cursor = length;
15677:             ne->length = length;
17049:             ne->shape = shape;
33128: 
33128:             jsid *ids = ne->ids;
33128:             for (JSScopeProperty *sprop = SCOPE_LAST_PROP(scope);
33128:                  sprop;
33128:                  sprop = sprop->parent) {
 9090:                 if ((sprop->attrs & JSPROP_ENUMERATE) &&
    1:                     !(sprop->flags & SPROP_IS_ALIAS) &&
30258:                     (!scope->hadMiddleDelete() || scope->has(sprop))) {
15677:                     JS_ASSERT(ids < ne->ids + length);
15677:                     *ids++ = sprop->id;
15677:                 }
15677:             }
15677:             JS_ASSERT(ids == ne->ids + length);
15677:             JS_UNLOCK_SCOPE(cx, scope);
15677: 
32735:             /*
32735:              * Do not cache enumerators for objects with with a shape
32735:              * that had overflowed, see bug 440834.
32735:              */
32735:             if (shape < SHAPE_OVERFLOW_BIT)
33128:                 SetEnumeratorCache(cx, cachep, reinterpret_cast<jsuword>(ne));
33128:         } while (0);
33128: 
33128:         if (!ne) {
33128:             JS_ASSERT(length == 0);
33128:             *statep = JSVAL_ZERO;
33128:         } else {
33128:             JS_ASSERT(length != 0);
33128:             JS_ASSERT(ne->cursor == length);
33128:             JS_ASSERT(!(reinterpret_cast<jsuword>(ne) & jsuword(1)));
15677:             *statep = PRIVATE_TO_JSVAL(ne);
15677:         }
17049:         if (idp)
17049:             *idp = INT_TO_JSVAL(length);
    1:         break;
33128:       }
    1: 
    1:       case JSENUMERATE_NEXT:
33128:       case JSENUMERATE_DESTROY: {
17049:         if (*statep == JSVAL_ZERO) {
17049:             *statep = JSVAL_NULL;
17049:             break;
17049:         }
33128:         JSNativeEnumerator *ne = (JSNativeEnumerator *)
33128:                                  JSVAL_TO_PRIVATE(*statep);
15677:         JS_ASSERT(ne->length >= 1);
17049:         JS_ASSERT(ne->cursor >= 1);
17049:         if (enum_op == JSENUMERATE_NEXT) {
33128:             uint32 newcursor = ne->cursor - 1;
17049:             *idp = ne->ids[newcursor];
33128:             if (newcursor != 0) {
17049:                 ne->cursor = newcursor;
33128:                 break;
33128:             }
17049:         } else {
17049:             /* The enumerator has not iterated over all ids. */
29865:             JS_ASSERT(enum_op == JSENUMERATE_DESTROY);
33128:         }
33128:         *statep = JSVAL_ZERO;
33128: 
33128:         jsuword *cachep = &JS_THREAD_DATA(cx)->
33128:                           nativeEnumCache[NATIVE_ENUM_CACHE_HASH(ne->shape)];
33128:         if (reinterpret_cast<jsuword>(ne) == *cachep) {
33128:             /* Mark the cached iterator as available. */
17049:             ne->cursor = 0;
33128:         } else {
33128:             cx->free(ne);
17049:         }
    1:         break;
    1:       }
33128:     }
33128:     return true;
    1: }
    1: 
    1: void
33128: js_MarkEnumeratorState(JSTracer *trc, JSObject *obj, jsval state)
33128: {
33128:     if (JSVAL_IS_TRACEABLE(state)) {
33128:         JS_CALL_TRACER(trc, JSVAL_TO_TRACEABLE(state),
33128:                        JSVAL_TRACE_KIND(state), "enumerator_value");
33128:     } else if (obj->map->ops->enumerate == js_Enumerate &&
33128:                !(obj->getClass()->flags & JSCLASS_NEW_ENUMERATE)) {
33128:         /* Check if state stores JSNativeEnumerator. */
33128:         JS_ASSERT(JSVAL_IS_INT(state) ||
33128:                   JSVAL_IS_NULL(state) ||
33128:                   JSVAL_IS_VOID(state));
33128:         if (JSVAL_IS_INT(state) && state != JSVAL_ZERO)
33128:             ((JSNativeEnumerator *) JSVAL_TO_PRIVATE(state))->mark(trc);
33128:     }
33128: }
33128: 
33128: void
33128: js_PurgeCachedNativeEnumerators(JSContext *cx, JSThreadData *data)
33128: {
33128:     jsuword *cachep = &data->nativeEnumCache[0];
33128:     jsuword *end = cachep + JS_ARRAY_LENGTH(data->nativeEnumCache);
33128:     for (; cachep != end; ++cachep)
33128:         SetEnumeratorCache(cx, cachep, jsuword(0));
33128: 
17049: #ifdef JS_DUMP_ENUM_CACHE_STATS
17049:     printf("nativeEnumCache hit rate %g%%\n",
33128:            100.0 * (cx->runtime->nativeEnumProbes -
33128:                     cx->runtime->nativeEnumMisses) /
33128:            cx->runtime->nativeEnumProbes);
17049: #endif
17049: }
17049: 
    1: JSBool
    1: js_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
    1:                jsval *vp, uintN *attrsp)
    1: {
    1:     JSBool writing;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
    1:     JSClass *clasp;
    1:     JSScopeProperty *sprop;
18870:     JSSecurityCallbacks *callbacks;
    1:     JSCheckAccessOp check;
    1: 
    1:     writing = (mode & JSACC_WRITE) != 0;
    1:     switch (mode & JSACC_TYPEMASK) {
    1:       case JSACC_PROTO:
    1:         pobj = obj;
    1:         if (!writing)
    1:             *vp = OBJECT_TO_JSVAL(OBJ_GET_PROTO(cx, obj));
    1:         *attrsp = JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       case JSACC_PARENT:
    1:         JS_ASSERT(!writing);
    1:         pobj = obj;
    1:         *vp = OBJECT_TO_JSVAL(OBJ_GET_PARENT(cx, obj));
    1:         *attrsp = JSPROP_READONLY | JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       default:
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop) {
    1:             if (!writing)
    1:                 *vp = JSVAL_VOID;
    1:             *attrsp = 0;
11842:             pobj = obj;
11842:             break;
11842:         }
11842: 
    1:         if (!OBJ_IS_NATIVE(pobj)) {
31501:             pobj->dropProperty(cx, prop);
11842: 
11842:             /* Avoid diverging for non-natives that reuse js_CheckAccess. */
11961:             if (pobj->map->ops->checkAccess == js_CheckAccess) {
16403:                 if (!writing) {
11961:                     *vp = JSVAL_VOID;
16403:                     *attrsp = 0;
16403:                 }
11842:                 break;
11961:             }
31501:             return pobj->checkAccess(cx, id, mode, vp, attrsp);
    1:         }
    1: 
    1:         sprop = (JSScopeProperty *)prop;
    1:         *attrsp = sprop->attrs;
    1:         if (!writing) {
    1:             *vp = (SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(pobj)))
    1:                   ? LOCKED_OBJ_GET_SLOT(pobj, sprop->slot)
    1:                   : JSVAL_VOID;
    1:         }
31501:         pobj->dropProperty(cx, prop);
    1:     }
    1: 
    1:     /*
    1:      * If obj's class has a stub (null) checkAccess hook, use the per-runtime
    1:      * checkObjectAccess callback, if configured.
    1:      *
    1:      * We don't want to require all classes to supply a checkAccess hook; we
    1:      * need that hook only for certain classes used when precompiling scripts
    1:      * and functions ("brutal sharing").  But for general safety of built-in
    1:      * magic properties such as __proto__ and __parent__, we route all access
    1:      * checks, even for classes that stub out checkAccess, through the global
    1:      * checkObjectAccess hook.  This covers precompilation-based sharing and
    1:      * (possibly unintended) runtime sharing across trust boundaries.
    1:      */
    1:     clasp = OBJ_GET_CLASS(cx, pobj);
    1:     check = clasp->checkAccess;
18870:     if (!check) {
18870:         callbacks = JS_GetSecurityCallbacks(cx);
18870:         check = callbacks ? callbacks->checkObjectAccess : NULL;
18870:     }
    1:     return !check || check(cx, pobj, ID_TO_VALUE(id), mode, vp);
    1: }
    1: 
    1: #ifdef JS_THREADSAFE
    1: void
    1: js_DropProperty(JSContext *cx, JSObject *obj, JSProperty *prop)
    1: {
    1:     JS_UNLOCK_OBJ(cx, obj);
    1: }
    1: #endif
    1: 
    1: #ifdef NARCISSUS
    1: static JSBool
    1: GetCurrentExecutionContext(JSContext *cx, JSObject *obj, jsval *rval)
    1: {
    1:     JSObject *tmp;
    1:     jsval xcval;
    1: 
    1:     while ((tmp = OBJ_GET_PARENT(cx, obj)) != NULL)
    1:         obj = tmp;
31501:     if (!obj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.ExecutionContextAtom), &xcval))
    1:         return JS_FALSE;
    1:     if (JSVAL_IS_PRIMITIVE(xcval)) {
    1:         JS_ReportError(cx, "invalid ExecutionContext in global object");
    1:         return JS_FALSE;
    1:     }
31501:     if (!JSVAL_TO_OBJECT(xcval)->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.currentAtom),
    1:                                              rval)) {
    1:         return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: #endif
    1: 
    1: JSBool
    1: js_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSClass *clasp;
    1: 
    1:     clasp = OBJ_GET_CLASS(cx, JSVAL_TO_OBJECT(argv[-2]));
    1:     if (!clasp->call) {
    1: #ifdef NARCISSUS
    1:         JSObject *callee, *args;
    1:         jsval fval, nargv[3];
    1:         JSBool ok;
    1: 
    1:         callee = JSVAL_TO_OBJECT(argv[-2]);
31501:         if (!callee->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.__call__Atom), &fval))
    1:             return JS_FALSE;
    1:         if (VALUE_IS_FUNCTION(cx, fval)) {
    1:             if (!GetCurrentExecutionContext(cx, obj, &nargv[2]))
    1:                 return JS_FALSE;
22652:             args = js_GetArgsObject(cx, js_GetTopStackFrame(cx));
    1:             if (!args)
    1:                 return JS_FALSE;
    1:             nargv[0] = OBJECT_TO_JSVAL(obj);
    1:             nargv[1] = OBJECT_TO_JSVAL(args);
    1:             return js_InternalCall(cx, callee, fval, 3, nargv, rval);
    1:         }
    1:         if (JSVAL_IS_OBJECT(fval) && JSVAL_TO_OBJECT(fval) != callee) {
    1:             argv[-2] = fval;
    1:             ok = js_Call(cx, obj, argc, argv, rval);
    1:             argv[-2] = OBJECT_TO_JSVAL(callee);
    1:             return ok;
    1:         }
    1: #endif
22652:         js_ReportIsNotFunction(cx, &argv[-2], js_GetTopStackFrame(cx)->flags & JSFRAME_ITERATOR);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->call(cx, obj, argc, argv, rval);
    1: }
    1: 
    1: JSBool
    1: js_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:              jsval *rval)
    1: {
    1:     JSClass *clasp;
    1: 
    1:     clasp = OBJ_GET_CLASS(cx, JSVAL_TO_OBJECT(argv[-2]));
    1:     if (!clasp->construct) {
    1: #ifdef NARCISSUS
    1:         JSObject *callee, *args;
    1:         jsval cval, nargv[2];
    1:         JSBool ok;
    1: 
    1:         callee = JSVAL_TO_OBJECT(argv[-2]);
31501:         if (!callee->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.__construct__Atom),
    1:                                  &cval)) {
    1:             return JS_FALSE;
    1:         }
    1:         if (VALUE_IS_FUNCTION(cx, cval)) {
    1:             if (!GetCurrentExecutionContext(cx, obj, &nargv[1]))
    1:                 return JS_FALSE;
22652:             args = js_GetArgsObject(cx, js_GetTopStackFrame(cx));
    1:             if (!args)
    1:                 return JS_FALSE;
    1:             nargv[0] = OBJECT_TO_JSVAL(args);
    1:             return js_InternalCall(cx, callee, cval, 2, nargv, rval);
    1:         }
    1:         if (JSVAL_IS_OBJECT(cval) && JSVAL_TO_OBJECT(cval) != callee) {
    1:             argv[-2] = cval;
    1:             ok = js_Call(cx, obj, argc, argv, rval);
    1:             argv[-2] = OBJECT_TO_JSVAL(callee);
    1:             return ok;
    1:         }
    1: #endif
 4521:         js_ReportIsNotFunction(cx, &argv[-2], JSV2F_CONSTRUCT);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->construct(cx, obj, argc, argv, rval);
    1: }
    1: 
    1: JSBool
    1: js_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
    1:     JSClass *clasp;
    1: 
    1:     clasp = OBJ_GET_CLASS(cx, obj);
    1:     if (clasp->hasInstance)
    1:         return clasp->hasInstance(cx, obj, v, bp);
    1: #ifdef NARCISSUS
    1:     {
    1:         jsval fval, rval;
    1: 
31501:         if (!obj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.__hasInstance__Atom), &fval))
    1:             return JS_FALSE;
    1:         if (VALUE_IS_FUNCTION(cx, fval)) {
10525:             if (!js_InternalCall(cx, obj, fval, 1, &v, &rval))
10525:                 return JS_FALSE;
10525:             *bp = js_ValueToBoolean(rval);
10525:             return JS_TRUE;
    1:         }
    1:     }
    1: #endif
    1:     js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
    1:                         JSDVG_SEARCH_STACK, OBJECT_TO_JSVAL(obj), NULL);
    1:     return JS_FALSE;
    1: }
    1: 
    1: JSBool
    1: js_IsDelegate(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
    1:     JSObject *obj2;
    1: 
    1:     *bp = JS_FALSE;
    1:     if (JSVAL_IS_PRIMITIVE(v))
    1:         return JS_TRUE;
    1:     obj2 = JSVAL_TO_OBJECT(v);
    1:     while ((obj2 = OBJ_GET_PROTO(cx, obj2)) != NULL) {
    1:         if (obj2 == obj) {
    1:             *bp = JS_TRUE;
    1:             break;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: js_GetClassPrototype(JSContext *cx, JSObject *scope, jsid id,
    1:                      JSObject **protop)
    1: {
    1:     jsval v;
    1:     JSObject *ctor;
    1: 
    1:     if (!js_FindClassObject(cx, scope, id, &v))
    1:         return JS_FALSE;
    1:     if (VALUE_IS_FUNCTION(cx, v)) {
    1:         ctor = JSVAL_TO_OBJECT(v);
31501:         if (!ctor->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom), &v))
    1:             return JS_FALSE;
    1:         if (!JSVAL_IS_PRIMITIVE(v)) {
    1:             /*
    1:              * Set the newborn root in case v is otherwise unreferenced.
    1:              * It's ok to overwrite newborn roots here, since the getter
    1:              * called just above could have.  Unlike the common GC rooting
    1:              * model, our callers do not have to protect protop thanks to
    1:              * this newborn root, since they all immediately create a new
    1:              * instance that delegates to this object, or just query the
    1:              * prototype for its class.
    1:              */
33952:             cx->weakRoots.finalizableNewborns[FINALIZE_OBJECT] =
33952:                 JSVAL_TO_OBJECT(v);
    1:         }
    1:     }
    1:     *protop = JSVAL_IS_OBJECT(v) ? JSVAL_TO_OBJECT(v) : NULL;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * For shared precompilation of function objects, we support cloning on entry
    1:  * to an execution context in which the function declaration or expression
    1:  * should be processed as if it were not precompiled, where the precompiled
    1:  * function's scope chain does not match the execution context's.  The cloned
    1:  * function object carries its execution-context scope in its parent slot; it
    1:  * links to the precompiled function (the "clone-parent") via its proto slot.
    1:  *
    1:  * Note that this prototype-based delegation leaves an unchecked access path
    1:  * from the clone to the clone-parent's 'constructor' property.  If the clone
    1:  * lives in a less privileged or shared scope than the clone-parent, this is
    1:  * a security hole, a sharing hazard, or both.  Therefore we check all such
    1:  * accesses with the following getter/setter pair, which we use when defining
    1:  * 'constructor' in f.prototype for all function objects f.
    1:  */
    1: static JSBool
    1: CheckCtorGetAccess(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSAtom *atom;
    1:     uintN attrs;
    1: 
    1:     atom = cx->runtime->atomState.constructorAtom;
 4529:     JS_ASSERT(id == ATOM_TO_JSID(atom));
31501:     return obj->checkAccess(cx, ATOM_TO_JSID(atom), JSACC_READ, vp, &attrs);
    1: }
    1: 
    1: static JSBool
    1: CheckCtorSetAccess(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSAtom *atom;
    1:     uintN attrs;
    1: 
    1:     atom = cx->runtime->atomState.constructorAtom;
 4529:     JS_ASSERT(id == ATOM_TO_JSID(atom));
31501:     return obj->checkAccess(cx, ATOM_TO_JSID(atom), JSACC_WRITE, vp, &attrs);
    1: }
    1: 
    1: JSBool
    1: js_SetClassPrototype(JSContext *cx, JSObject *ctor, JSObject *proto,
    1:                      uintN attrs)
    1: {
    1:     /*
    1:      * Use the given attributes for the prototype property of the constructor,
    1:      * as user-defined constructors have a DontDelete prototype (which may be
    1:      * reset), while native or "system" constructors have DontEnum | ReadOnly |
    1:      * DontDelete.
    1:      */
31501:     if (!ctor->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
31501:                               OBJECT_TO_JSVAL(proto), JS_PropertyStub, JS_PropertyStub,
32573:                               attrs)) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /*
    1:      * ECMA says that Object.prototype.constructor, or f.prototype.constructor
    1:      * for a user-defined function f, is DontEnum.
    1:      */
31501:     return proto->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.constructorAtom),
32573:                                  OBJECT_TO_JSVAL(ctor), CheckCtorGetAccess, CheckCtorSetAccess, 0);
    1: }
    1: 
    1: JSBool
 2383: js_PrimitiveToObject(JSContext *cx, jsval *vp)
 2383: {
 2383:     JSClass *clasp;
 2383:     JSObject *obj;
 2383: 
 2383:     /* Table to map primitive value's tag into the corresponding class. */
 2383:     JS_STATIC_ASSERT(JSVAL_INT == 1);
 2383:     JS_STATIC_ASSERT(JSVAL_DOUBLE == 2);
 2383:     JS_STATIC_ASSERT(JSVAL_STRING == 4);
31521:     JS_STATIC_ASSERT(JSVAL_SPECIAL == 6);
 2383:     static JSClass *const PrimitiveClasses[] = {
 2383:         &js_NumberClass,    /* INT     */
 2383:         &js_NumberClass,    /* DOUBLE  */
 2383:         &js_NumberClass,    /* INT     */
 2383:         &js_StringClass,    /* STRING  */
 2383:         &js_NumberClass,    /* INT     */
 2383:         &js_BooleanClass,   /* BOOLEAN */
 2383:         &js_NumberClass     /* INT     */
 2383:     };
 2383: 
 2383:     JS_ASSERT(!JSVAL_IS_OBJECT(*vp));
15521:     JS_ASSERT(!JSVAL_IS_VOID(*vp));
 2383:     clasp = PrimitiveClasses[JSVAL_TAG(*vp) - 1];
30439:     obj = js_NewObject(cx, clasp, NULL, NULL);
 2383:     if (!obj)
 2383:         return JS_FALSE;
32684:     obj->fslots[JSSLOT_PRIMITIVE_THIS] = *vp;
 2383:     *vp = OBJECT_TO_JSVAL(obj);
 2383:     return JS_TRUE;
 2383: }
 2383: 
 2383: JSBool
    1: js_ValueToObject(JSContext *cx, jsval v, JSObject **objp)
    1: {
    1:     JSObject *obj;
    1: 
    1:     if (JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v)) {
    1:         obj = NULL;
    1:     } else if (JSVAL_IS_OBJECT(v)) {
    1:         obj = JSVAL_TO_OBJECT(v);
31501:         if (!obj->defaultValue(cx, JSTYPE_OBJECT, &v))
    1:             return JS_FALSE;
26017:         if (!JSVAL_IS_PRIMITIVE(v))
    1:             obj = JSVAL_TO_OBJECT(v);
    1:     } else {
 2383:         if (!js_PrimitiveToObject(cx, &v))
    1:             return JS_FALSE;
 2383:         obj = JSVAL_TO_OBJECT(v);
    1:     }
    1:     *objp = obj;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
    1: js_ValueToNonNullObject(JSContext *cx, jsval v)
    1: {
    1:     JSObject *obj;
    1: 
    1:     if (!js_ValueToObject(cx, v, &obj))
    1:         return NULL;
 7897:     if (!obj)
 7897:         js_ReportIsNullOrUndefined(cx, JSDVG_SEARCH_STACK, v, NULL);
    1:     return obj;
    1: }
    1: 
    1: JSBool
    1: js_TryValueOf(JSContext *cx, JSObject *obj, JSType type, jsval *rval)
    1: {
    1:     jsval argv[1];
    1: 
    1:     argv[0] = ATOM_KEY(cx->runtime->atomState.typeAtoms[type]);
    1:     return js_TryMethod(cx, obj, cx->runtime->atomState.valueOfAtom, 1, argv,
    1:                         rval);
    1: }
    1: 
    1: JSBool
    1: js_TryMethod(JSContext *cx, JSObject *obj, JSAtom *atom,
    1:              uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSErrorReporter older;
    1:     jsid id;
    1:     jsval fval;
    1:     JSBool ok;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
    1:     /*
    1:      * Report failure only if an appropriate method was found, and calling it
    1:      * returned failure.  We propagate failure in this case to make exceptions
    1:      * behave properly.
    1:      */
    1:     older = JS_SetErrorReporter(cx, NULL);
    1:     id = ATOM_TO_JSID(atom);
    1:     fval = JSVAL_VOID;
32658:     ok = js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, &fval);
    1:     if (!ok)
    1:         JS_ClearPendingException(cx);
    1:     JS_SetErrorReporter(cx, older);
    1: 
24499:     if (JSVAL_IS_PRIMITIVE(fval))
24499:         return JS_TRUE;
24499:     return js_InternalCall(cx, obj, fval, argc, argv, rval);
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: JSBool
    1: js_XDRObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
    1:     JSAtom *atom;
    1:     JSClass *clasp;
    1:     uint32 classId, classDef;
    1:     JSProtoKey protoKey;
    1:     jsid classKey;
    1:     JSObject *proto;
    1: 
    1:     cx = xdr->cx;
    1:     atom = NULL;
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         clasp = OBJ_GET_CLASS(cx, *objp);
    1:         classId = JS_XDRFindClassIdByName(xdr, clasp->name);
    1:         classDef = !classId;
    1:         if (classDef) {
    1:             if (!JS_XDRRegisterClass(xdr, clasp, &classId))
    1:                 return JS_FALSE;
    1:             protoKey = JSCLASS_CACHED_PROTO_KEY(clasp);
    1:             if (protoKey != JSProto_Null) {
    1:                 classDef |= (protoKey << 1);
    1:             } else {
    1:                 atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
    1:                 if (!atom)
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:     } else {
    1:         clasp = NULL;           /* quell GCC overwarning */
    1:         classDef = 0;
    1:     }
    1: 
    1:     /*
    1:      * XDR a flag word, which could be 0 for a class use, in which case no
    1:      * name follows, only the id in xdr's class registry; 1 for a class def,
    1:      * in which case the flag word is followed by the class name transferred
    1:      * from or to atom; or a value greater than 1, an odd number that when
    1:      * divided by two yields the JSProtoKey for class.  In the last case, as
    1:      * in the 0 classDef case, no name is transferred via atom.
    1:      */
    1:     if (!JS_XDRUint32(xdr, &classDef))
    1:         return JS_FALSE;
 4875:     if (classDef == 1 && !js_XDRStringAtom(xdr, &atom))
    1:         return JS_FALSE;
    1: 
    1:     if (!JS_XDRUint32(xdr, &classId))
    1:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         if (classDef) {
    1:             /* NB: we know that JSProto_Null is 0 here, for backward compat. */
 3164:             protoKey = (JSProtoKey) (classDef >> 1);
    1:             classKey = (protoKey != JSProto_Null)
    1:                        ? INT_TO_JSID(protoKey)
    1:                        : ATOM_TO_JSID(atom);
    1:             if (!js_GetClassPrototype(cx, NULL, classKey, &proto))
    1:                 return JS_FALSE;
    1:             clasp = OBJ_GET_CLASS(cx, proto);
    1:             if (!JS_XDRRegisterClass(xdr, clasp, &classId))
    1:                 return JS_FALSE;
    1:         } else {
    1:             clasp = JS_XDRFindClassById(xdr, classId);
    1:             if (!clasp) {
    1:                 char numBuf[12];
    1:                 JS_snprintf(numBuf, sizeof numBuf, "%ld", (long)classId);
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_CANT_FIND_CLASS, numBuf);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (!clasp->xdrObject) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_CANT_XDR_CLASS, clasp->name);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->xdrObject(xdr, objp);
    1: }
    1: 
    1: #endif /* JS_HAS_XDR */
    1: 
10217: #ifdef JS_DUMP_SCOPE_METERS
    1: 
    1: #include <stdio.h>
10217: 
10217: JSBasicStats js_entry_count_bs = JS_INIT_STATIC_BASIC_STATS;
    1: 
    1: static void
    1: MeterEntryCount(uintN count)
    1: {
10217:     JS_BASIC_STATS_ACCUM(&js_entry_count_bs, count);
10217: }
10217: 
    1: void
    1: js_DumpScopeMeters(JSRuntime *rt)
    1: {
    1:     static FILE *logfp;
    1:     if (!logfp)
    1:         logfp = fopen("/tmp/scope.stats", "a");
    1: 
    1:     {
10217:         double mean, sigma;
10217: 
10217:         mean = JS_MeanAndStdDevBS(&js_entry_count_bs, &sigma);
10217: 
10217:         fprintf(logfp, "scopes %u entries %g mean %g sigma %g max %u",
10217:                 js_entry_count_bs.num, js_entry_count_bs.sum, mean, sigma,
10217:                 js_entry_count_bs.max);
10217:     }
10217: 
10217:     JS_DumpHistogram(&js_entry_count_bs, logfp);
10217:     JS_BASIC_STATS_INIT(&js_entry_count_bs);
    1:     fflush(logfp);
    1: }
    1: #endif
    1: 
  583: #ifdef DEBUG
11835: void
11835: js_PrintObjectSlotName(JSTracer *trc, char *buf, size_t bufsize)
  583: {
32684:     JS_ASSERT(trc->debugPrinter == js_PrintObjectSlotName);
32684: 
32684:     JSObject *obj = (JSObject *)trc->debugPrintArg;
32684:     uint32 slot = (uint32)trc->debugPrintIndex;
32684:     JS_ASSERT(slot >= JSSLOT_START(obj->getClass()));
32684: 
  583:     JSScopeProperty *sprop;
11835:     if (OBJ_IS_NATIVE(obj)) {
32684:         JSScope *scope = OBJ_SCOPE(obj);
  583:         sprop = SCOPE_LAST_PROP(scope);
  583:         while (sprop && sprop->slot != slot)
  583:             sprop = sprop->parent;
11835:     } else {
11835:         sprop = NULL;
11835:     }
  583: 
  583:     if (!sprop) {
32684:         const char *slotname = NULL;
32684:         JSClass *clasp = obj->getClass();
  583:         if (clasp->flags & JSCLASS_IS_GLOBAL) {
32684:             uint32 key = slot - JSSLOT_START(clasp);
  583: #define JS_PROTO(name,code,init)                                              \
  583:     if ((code) == key) { slotname = js_##name##_str; goto found; }
  583: #include "jsproto.tbl"
  583: #undef JS_PROTO
  583:         }
  583:       found:
  583:         if (slotname)
  583:             JS_snprintf(buf, bufsize, "CLASS_OBJECT(%s)", slotname);
  583:         else
  583:             JS_snprintf(buf, bufsize, "**UNKNOWN SLOT %ld**", (long)slot);
  583:     } else {
32684:         jsval nval = ID_TO_VALUE(sprop->id);
  583:         if (JSVAL_IS_INT(nval)) {
  583:             JS_snprintf(buf, bufsize, "%ld", (long)JSVAL_TO_INT(nval));
  583:         } else if (JSVAL_IS_STRING(nval)) {
  583:             js_PutEscapedString(buf, bufsize, JSVAL_TO_STRING(nval), 0);
  583:         } else {
  583:             JS_snprintf(buf, bufsize, "**FINALIZED ATOM KEY**");
  583:         }
  583:     }
  583: }
  583: #endif
  583: 
  583: void
  583: js_TraceObject(JSTracer *trc, JSObject *obj)
    1: {
    1:     JS_ASSERT(OBJ_IS_NATIVE(obj));
32684: 
32684:     JSContext *cx = trc->context;
32684:     JSScope *scope = OBJ_SCOPE(obj);
30645:     if (scope->owned() && IS_GC_MARKING_TRACER(trc)) {
11377:         /*
30645:          * Check whether we should shrink the object's slots. Skip this check
30645:          * if the scope is shared, since for Block objects and flat closures
30645:          * that share their scope, scope->freeslot can be an underestimate.
11377:          */
30454:         size_t slots = scope->freeslot;
30454:         if (STOBJ_NSLOTS(obj) != slots)
30454:             js_ShrinkSlots(cx, obj, slots);
30454:     }
30454: 
10217: #ifdef JS_DUMP_SCOPE_METERS
    1:     MeterEntryCount(scope->entryCount);
    1: #endif
    1: 
30852:     scope->trace(trc);
    1: 
 5816:     if (!JS_CLIST_IS_EMPTY(&cx->runtime->watchPointList))
 5816:         js_TraceWatchPoints(trc, obj);
    1: 
    1:     /* No one runs while the GC is running, so we can use LOCKED_... here. */
32684:     JSClass *clasp = obj->getClass();
  583:     if (clasp->mark) {
  583:         if (clasp->flags & JSCLASS_MARK_IS_TRACE)
11377:             ((JSTraceOp) clasp->mark)(trc, obj);
  583:         else if (IS_GC_MARKING_TRACER(trc))
  583:             (void) clasp->mark(cx, obj, trc);
  583:     }
    1: 
32603:     obj->traceProtoAndParent(trc);
32603: 
    1:     /*
11377:      * An unmutated object that shares a prototype object's scope. We can't
11377:      * tell how many slots are in use in obj by looking at its scope, so we
11377:      * use STOBJ_NSLOTS(obj).
11377:      *
11377:      * NB: In case clasp->mark mutates something, leave this code here --
11377:      * don't move it up and unify it with the |if (!traceScope)| section
11377:      * above.
    1:      */
32684:     uint32 nslots = STOBJ_NSLOTS(obj);
30645:     if (scope->owned() && scope->freeslot < nslots)
28353:         nslots = scope->freeslot;
32684:     JS_ASSERT(nslots >= JSSLOT_START(clasp));
32684: 
32684:     for (uint32 i = JSSLOT_START(clasp); i != nslots; ++i) {
32684:         jsval v = STOBJ_GET_SLOT(obj, i);
  583:         if (JSVAL_IS_TRACEABLE(v)) {
11835:             JS_SET_TRACING_DETAILS(trc, js_PrintObjectSlotName, obj, i);
  583:             JS_CallTracer(trc, JSVAL_TO_TRACEABLE(v), JSVAL_TRACE_KIND(v));
  583:         }
  583:     }
    1: }
    1: 
    1: void
    1: js_Clear(JSContext *cx, JSObject *obj)
    1: {
    1:     JSScope *scope;
    1:     uint32 i, n;
    1: 
    1:     /*
    1:      * Clear our scope and the property cache of all obj's properties only if
30645:      * obj owns the scope (i.e., not if obj is sharing another object's scope).
30645:      * NB: we do not clear any reserved slots lying below JSSLOT_FREE(clasp).
    1:      */
    1:     JS_LOCK_OBJ(cx, obj);
    1:     scope = OBJ_SCOPE(obj);
30645:     if (scope->owned()) {
    1:         /* Now that we're done using scope->lastProp/table, clear scope. */
30258:         scope->clear(cx);
    1: 
    1:         /* Clear slot values and reset freeslot so we're consistent. */
    1:         i = STOBJ_NSLOTS(obj);
32603:         n = JSSLOT_FREE(obj->getClass());
    1:         while (--i >= n)
    1:             STOBJ_SET_SLOT(obj, i, JSVAL_VOID);
28353:         scope->freeslot = n;
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1: }
    1: 
32603: /* On failure the function unlocks the object. */
32603: static bool
32603: ReservedSlotIndexOK(JSContext *cx, JSObject *obj, JSClass *clasp,
32603:                     uint32 index, uint32 limit)
    1: {
32620:     JS_ASSERT(JS_IS_OBJ_LOCKED(cx, obj));
32603: 
32603:     /* Check the computed, possibly per-instance, upper bound. */
32603:     if (clasp->reserveSlots)
32603:         limit += clasp->reserveSlots(cx, obj);
32603:     if (index >= limit) {
32603:         JS_UNLOCK_OBJ(cx, obj);
32603:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
32603:                              JSMSG_RESERVED_SLOT_RANGE);
32603:         return false;
32603:     }
32603:     return true;
32603: }
32603: 
32603: bool
32603: js_GetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval *vp)
32603: {
32603:     if (!OBJ_IS_NATIVE(obj)) {
32603:         *vp = JSVAL_VOID;
32603:         return true;
32603:     }
32603: 
32603:     JSClass *clasp = obj->getClass();
32603:     uint32 limit = JSCLASS_RESERVED_SLOTS(clasp);
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
32603:     if (index >= limit && !ReservedSlotIndexOK(cx, obj, clasp, index, limit))
32603:         return false;
32603: 
32603:     uint32 slot = JSSLOT_START(clasp) + index;
32603:     *vp = (slot < STOBJ_NSLOTS(obj)) ? STOBJ_GET_SLOT(obj, slot) : JSVAL_VOID;
    1:     JS_UNLOCK_OBJ(cx, obj);
32603:     return true;
32603: }
32603: 
32603: bool
32603: js_SetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval v)
    1: {
32603:     if (!OBJ_IS_NATIVE(obj))
32603:         return true;
32603: 
32603:     JSClass *clasp = OBJ_GET_CLASS(cx, obj);
32603:     uint32 limit = JSCLASS_RESERVED_SLOTS(clasp);
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
32603:     if (index >= limit && !ReservedSlotIndexOK(cx, obj, clasp, index, limit))
32603:         return false;
32603: 
32603:     uint32 slot = JSSLOT_START(clasp) + index;
33638:     if (slot >= JS_INITIAL_NSLOTS && !DSLOTS_IS_NOT_NULL(obj)) {
    1:         /*
30645:          * At this point, obj may or may not own scope, and we may or may not
30645:          * need to allocate dslots. If scope is shared, scope->freeslot may not
30645:          * be accurate for obj (see comment below).
    1:          */
32603:         uint32 nslots = JSSLOT_FREE(clasp);
    1:         if (clasp->reserveSlots)
    1:             nslots += clasp->reserveSlots(cx, obj);
    1:         JS_ASSERT(slot < nslots);
30732:         if (!AllocSlots(cx, obj, nslots)) {
32603:             JS_UNLOCK_OBJ(cx, obj);
32603:             return false;
    1:         }
    1:     }
    1: 
30645:     /*
30645:      * Whether or not we grew nslots, we may need to advance freeslot.
30645:      *
30645:      * If scope is shared, do not modify scope->freeslot. It is OK for freeslot
30645:      * to be an underestimate in objects with shared scopes, as they will get
30645:      * their own scopes before mutating, and elsewhere (e.g. js_TraceObject) we
30645:      * use STOBJ_NSLOTS(obj) rather than rely on freeslot.
30645:      */
32603:     JSScope *scope = OBJ_SCOPE(obj);
30645:     if (scope->owned() && slot >= scope->freeslot)
28353:         scope->freeslot = slot + 1;
    1: 
    1:     STOBJ_SET_SLOT(obj, slot, v);
25939:     GC_POKE(cx, JS_NULL);
    1:     JS_UNLOCK_SCOPE(cx, scope);
32603:     return true;
    1: }
    1: 
12674: JSObject *
12674: js_GetWrappedObject(JSContext *cx, JSObject *obj)
12674: {
12674:     JSClass *clasp;
12674: 
12674:     clasp = OBJ_GET_CLASS(cx, obj);
12674:     if (clasp->flags & JSCLASS_IS_EXTENDED) {
12674:         JSExtendedClass *xclasp;
12674:         JSObject *obj2;
12674: 
12674:         xclasp = (JSExtendedClass *)clasp;
12674:         if (xclasp->wrappedObject && (obj2 = xclasp->wrappedObject(cx, obj)))
12674:             return obj2;
12674:     }
12674:     return obj;
12674: }
12674: 
26059: JSBool
26059: js_IsCallable(JSObject *obj, JSContext *cx)
26059: {
26059:     if (!OBJ_IS_NATIVE(obj))
26059:         return obj->map->ops->call != NULL;
26059: 
26059:     JS_LOCK_OBJ(cx, obj);
26059:     JSBool callable = (obj->map->ops == &js_ObjectOps)
26059:                       ? HAS_FUNCTION_CLASS(obj) || STOBJ_GET_CLASS(obj)->call
26059:                       : obj->map->ops->call != NULL;
26059:     JS_UNLOCK_OBJ(cx, obj);
26059:     return callable;
26059: }
26059: 
27641: void
27641: js_ReportGetterOnlyAssignment(JSContext *cx)
27641: {
27641:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
27641:                          JSMSG_GETTER_ONLY, NULL);
27641: }
27641: 
27641: JS_FRIEND_API(JSBool)
27641: js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
27641: {
27641:     js_ReportGetterOnlyAssignment(cx);
27641:     return JS_FALSE;
27641: }
27641: 
24294: #ifdef DEBUG
19714: 
19714: /*
19714:  * Routines to print out values during debugging.  These are FRIEND_API to help
19714:  * the debugger find them and to support temporarily hacking js_Dump* calls
19714:  * into other code.
19714:  */
19714: 
19714: void
19714: dumpChars(const jschar *s, size_t n)
19714: {
19714:     size_t i;
19714: 
19714:     if (n == (size_t) -1) {
19714:         while (s[++n]) ;
19714:     }
19714: 
    1:     fputc('"', stderr);
19714:     for (i = 0; i < n; i++) {
19714:         if (s[i] == '\n')
19714:             fprintf(stderr, "\\n");
19714:         else if (s[i] == '\t')
19714:             fprintf(stderr, "\\t");
19714:         else if (s[i] >= 32 && s[i] < 127)
19714:             fputc(s[i], stderr);
19714:         else if (s[i] <= 255)
19714:             fprintf(stderr, "\\x%02x", (unsigned int) s[i]);
19714:         else
19714:             fprintf(stderr, "\\u%04x", (unsigned int) s[i]);
19714:     }
19714:     fputc('"', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpChars(const jschar *s, size_t n)
19714: {
19714:     fprintf(stderr, "jschar * (%p) = ", (void *) s);
19714:     dumpChars(s, n);
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: void
19714: dumpString(JSString *str)
19714: {
29366:     dumpChars(str->chars(), str->length());
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpString(JSString *str)
19714: {
19714:     fprintf(stderr, "JSString* (%p) = jschar * (%p) = ",
29366:             (void *) str, (void *) str->chars());
19714:     dumpString(str);
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: JS_FRIEND_API(void)
19714: js_DumpAtom(JSAtom *atom)
19714: {
19714:     fprintf(stderr, "JSAtom* (%p) = ", (void *) atom);
19714:     js_DumpValue(ATOM_KEY(atom));
19714: }
19714: 
19714: void
19714: dumpValue(jsval val)
19714: {
19714:     if (JSVAL_IS_NULL(val)) {
19714:         fprintf(stderr, "null");
19714:     } else if (JSVAL_IS_VOID(val)) {
19714:         fprintf(stderr, "undefined");
26674:     } else if (JSVAL_IS_OBJECT(val) &&
26674:                HAS_FUNCTION_CLASS(JSVAL_TO_OBJECT(val))) {
26674:         JSObject *funobj = JSVAL_TO_OBJECT(val);
31452:         JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
26674:         fprintf(stderr, "<%s %s at %p (JSFunction at %p)>",
26674:                 fun->atom ? "function" : "unnamed",
26674:                 fun->atom ? JS_GetStringBytes(ATOM_TO_STRING(fun->atom)) : "function",
26674:                 (void *) funobj,
26674:                 (void *) fun);
19714:     } else if (JSVAL_IS_OBJECT(val)) {
19714:         JSObject *obj = JSVAL_TO_OBJECT(val);
19714:         JSClass *cls = STOBJ_GET_CLASS(obj);
19714:         fprintf(stderr, "<%s%s at %p>",
19714:                 cls->name,
19714:                 cls == &js_ObjectClass ? "" : " object",
25218:                 (void *) obj);
19714:     } else if (JSVAL_IS_INT(val)) {
19714:         fprintf(stderr, "%d", JSVAL_TO_INT(val));
19714:     } else if (JSVAL_IS_STRING(val)) {
19714:         dumpString(JSVAL_TO_STRING(val));
19714:     } else if (JSVAL_IS_DOUBLE(val)) {
19714:         fprintf(stderr, "%g", *JSVAL_TO_DOUBLE(val));
19714:     } else if (val == JSVAL_TRUE) {
19714:         fprintf(stderr, "true");
19714:     } else if (val == JSVAL_FALSE) {
19714:         fprintf(stderr, "false");
19714:     } else if (val == JSVAL_HOLE) {
19714:         fprintf(stderr, "hole");
19714:     } else {
19714:         /* jsvals are pointer-sized, and %p is portable */
19714:         fprintf(stderr, "unrecognized jsval %p", (void *) val);
19714:     }
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpValue(jsval val)
19714: {
28665:     fprintf(stderr, "jsval %p = ", (void *) val);
19714:     dumpValue(val);
19714:     fputc('\n', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpId(jsid id)
19714: {
28665:     fprintf(stderr, "jsid %p = ", (void *) id);
19714:     dumpValue(ID_TO_VALUE(id));
19714:     fputc('\n', stderr);
19714: }
19714: 
20208: static void
19714: dumpScopeProp(JSScopeProperty *sprop)
19714: {
19714:     jsid id = sprop->id;
19714:     uint8 attrs = sprop->attrs;
19714: 
19714:     fprintf(stderr, "    ");
19714:     if (attrs & JSPROP_ENUMERATE) fprintf(stderr, "enumerate ");
19714:     if (attrs & JSPROP_READONLY) fprintf(stderr, "readonly ");
19714:     if (attrs & JSPROP_PERMANENT) fprintf(stderr, "permanent ");
19714:     if (attrs & JSPROP_GETTER) fprintf(stderr, "getter ");
19714:     if (attrs & JSPROP_SETTER) fprintf(stderr, "setter ");
19714:     if (attrs & JSPROP_SHARED) fprintf(stderr, "shared ");
19714:     if (sprop->flags & SPROP_IS_ALIAS) fprintf(stderr, "alias ");
19714:     if (JSID_IS_ATOM(id))
19714:         dumpString(JSVAL_TO_STRING(ID_TO_VALUE(id)));
19714:     else if (JSID_IS_INT(id))
19714:         fprintf(stderr, "%d", (int) JSID_TO_INT(id));
19714:     else
19714:         fprintf(stderr, "unknown jsid %p", (void *) id);
19714:     fprintf(stderr, ": slot %d", sprop->slot);
19714:     fprintf(stderr, "\n");
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpObject(JSObject *obj)
19714: {
19714:     uint32 i, slots;
    1:     JSClass *clasp;
19714:     jsuint reservedEnd;
    1: 
13437:     fprintf(stderr, "object %p\n", (void *) obj);
19714:     clasp = STOBJ_GET_CLASS(obj);
    1:     fprintf(stderr, "class %p %s\n", (void *)clasp, clasp->name);
19714: 
19714:     /* OBJ_IS_DENSE_ARRAY ignores the cx argument. */
19714:     if (OBJ_IS_DENSE_ARRAY(BOGUS_CX, obj)) {
13437:         slots = JS_MIN((jsuint) obj->fslots[JSSLOT_ARRAY_LENGTH],
25475:                        js_DenseArrayCapacity(obj));
19714:         fprintf(stderr, "elements\n");
13437:         for (i = 0; i < slots; i++) {
19714:             fprintf(stderr, " %3d: ", i);
19714:             dumpValue(obj->dslots[i]);
19714:             fprintf(stderr, "\n");
19714:             fflush(stderr);
19714:         }
13437:         return;
13437:     }
13437: 
19714:     if (OBJ_IS_NATIVE(obj)) {
19714:         JSScope *scope = OBJ_SCOPE(obj);
30258:         if (scope->sealed())
19714:             fprintf(stderr, "sealed\n");
19714: 
19714:         fprintf(stderr, "properties:\n");
19714:         for (JSScopeProperty *sprop = SCOPE_LAST_PROP(scope); sprop;
19714:              sprop = sprop->parent) {
30258:             if (!scope->hadMiddleDelete() || scope->has(sprop))
19714:                 dumpScopeProp(sprop);
19714:         }
19714:     } else {
19714:         if (!OBJ_IS_NATIVE(obj))
19714:             fprintf(stderr, "not native\n");
19714:     }
19714: 
31452:     fprintf(stderr, "proto ");
31452:     dumpValue(OBJECT_TO_JSVAL(STOBJ_GET_PROTO(obj)));
31452:     fputc('\n', stderr);
31452: 
31452:     fprintf(stderr, "parent ");
31452:     dumpValue(OBJECT_TO_JSVAL(STOBJ_GET_PARENT(obj)));
31452:     fputc('\n', stderr);
31452: 
31452:     i = JSSLOT_PRIVATE;
31452:     if (clasp->flags & JSCLASS_HAS_PRIVATE) {
31452:         i = JSSLOT_PRIVATE + 1;
31452:         fprintf(stderr, "private %p\n", obj->getPrivate());
31452:     }
31452: 
19714:     fprintf(stderr, "slots:\n");
31452:     reservedEnd = i + JSCLASS_RESERVED_SLOTS(clasp);
32717:     slots = (OBJ_IS_NATIVE(obj) && OBJ_SCOPE(obj)->owned())
28353:             ? OBJ_SCOPE(obj)->freeslot
28353:             : STOBJ_NSLOTS(obj);
31452:     for (; i < slots; i++) {
19714:         fprintf(stderr, " %3d ", i);
31452:         if (i < reservedEnd)
19714:             fprintf(stderr, "(reserved) ");
19714:         fprintf(stderr, "= ");
19714:         dumpValue(STOBJ_GET_SLOT(obj, i));
19714:         fputc('\n', stderr);
19714:     }
19714:     fputc('\n', stderr);
    1: }
    1: 
28665: static void
28665: MaybeDumpObject(const char *name, JSObject *obj)
28665: {
28665:     if (obj) {
28665:         fprintf(stderr, "  %s: ", name);
28665:         dumpValue(OBJECT_TO_JSVAL(obj));
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
32774: static void
32774: MaybeDumpValue(const char *name, jsval v)
32774: {
32774:     if (!JSVAL_IS_NULL(v)) {
32774:         fprintf(stderr, "  %s: ", name);
32774:         dumpValue(v);
32774:         fputc('\n', stderr);
32774:     }
32774: }
32774: 
28665: JS_FRIEND_API(void)
28665: js_DumpStackFrame(JSStackFrame *fp)
28665: {
28665:     jsval *sp = NULL;
28665: 
28665:     for (; fp; fp = fp->down) {
28665:         fprintf(stderr, "JSStackFrame at %p\n", (void *) fp);
31939:         if (fp->argv)
31939:             dumpValue(fp->argv[-2]);
28665:         else
28665:             fprintf(stderr, "global frame, no callee");
28665:         fputc('\n', stderr);
28665: 
28665:         if (fp->script)
28665:             fprintf(stderr, "file %s line %u\n", fp->script->filename, (unsigned) fp->script->lineno);
28665: 
28665:         if (fp->regs) {
28665:             if (!fp->regs->pc) {
28665:                 fprintf(stderr, "*** regs && !regs->pc, skipping frame\n\n");
28665:                 continue;
28665:             }
28665:             if (!fp->script) {
28665:                 fprintf(stderr, "*** regs && !script, skipping frame\n\n");
28665:                 continue;
28665:             }
28665:             jsbytecode *pc = fp->regs->pc;
28665:             sp = fp->regs->sp;
28665:             if (fp->imacpc) {
28665:                 fprintf(stderr, "  pc in imacro at %p\n  called from ", pc);
28665:                 pc = fp->imacpc;
28665:             } else {
28665:                 fprintf(stderr, "  ");
28665:             }
28665:             fprintf(stderr, "pc = %p\n", pc);
28665:             fprintf(stderr, "  current op: %s\n", js_CodeName[*pc]);
28665:         }
28665:         if (sp && fp->slots) {
28690:             fprintf(stderr, "  slots: %p\n", (void *) fp->slots);
28690:             fprintf(stderr, "  sp:    %p = slots + %u\n", (void *) sp, (unsigned) (sp - fp->slots));
28665:             if (sp - fp->slots < 10000) { // sanity
28665:                 for (jsval *p = fp->slots; p < sp; p++) {
28665:                     fprintf(stderr, "    %p: ", (void *) p);
28665:                     dumpValue(*p);
28665:                     fputc('\n', stderr);
28665:                 }
28665:             }
28665:         } else {
28665:             fprintf(stderr, "  sp:    %p\n", (void *) sp);
28665:             fprintf(stderr, "  slots: %p\n", (void *) fp->slots);
28665:         }
28690:         fprintf(stderr, "  argv:  %p (argc: %u)\n", (void *) fp->argv, (unsigned) fp->argc);
28665:         MaybeDumpObject("callobj", fp->callobj);
30248:         MaybeDumpObject("argsobj", JSVAL_TO_OBJECT(fp->argsobj));
28665:         MaybeDumpObject("varobj", fp->varobj);
32774:         MaybeDumpValue("this", fp->thisv);
28665:         fprintf(stderr, "  rval: ");
28665:         dumpValue(fp->rval);
28665:         fputc('\n', stderr);
28665: 
28665:         fprintf(stderr, "  flags:");
28665:         if (fp->flags == 0)
28665:             fprintf(stderr, " none");
28665:         if (fp->flags & JSFRAME_CONSTRUCTING)
28665:             fprintf(stderr, " constructing");
28665:         if (fp->flags & JSFRAME_COMPUTED_THIS)
28665:             fprintf(stderr, " computed_this");
28665:         if (fp->flags & JSFRAME_ASSIGNING)
28665:             fprintf(stderr, " assigning");
28665:         if (fp->flags & JSFRAME_DEBUGGER)
28665:             fprintf(stderr, " debugger");
28665:         if (fp->flags & JSFRAME_EVAL)
28665:             fprintf(stderr, " eval");
28665:         if (fp->flags & JSFRAME_ROOTED_ARGV)
28665:             fprintf(stderr, " rooted_argv");
28665:         if (fp->flags & JSFRAME_YIELDING)
28665:             fprintf(stderr, " yielding");
28665:         if (fp->flags & JSFRAME_ITERATOR)
28665:             fprintf(stderr, " iterator");
28665:         if (fp->flags & JSFRAME_GENERATOR)
28665:             fprintf(stderr, " generator");
31823:         if (fp->flags & JSFRAME_OVERRIDE_ARGS)
31823:             fprintf(stderr, " overridden_args");
28665:         fputc('\n', stderr);
28665: 
28665:         if (fp->scopeChain)
28665:             fprintf(stderr, "  scopeChain: (JSObject *) %p\n", (void *) fp->scopeChain);
28665:         if (fp->blockChain)
28665:             fprintf(stderr, "  blockChain: (JSObject *) %p\n", (void *) fp->blockChain);
28665: 
28665:         if (fp->dormantNext)
28690:             fprintf(stderr, "  dormantNext: (JSStackFrame *) %p\n", (void *) fp->dormantNext);
28665:         if (fp->displaySave)
28690:             fprintf(stderr, "  displaySave: (JSStackFrame *) %p\n", (void *) fp->displaySave);
28665: 
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
    1: #endif
