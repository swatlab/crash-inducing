 40362: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 40362:  * vim: set ts=8 sw=4 et tw=98:
 40362:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 40359: 
 40359: #include "jspropertycache.h"
 52503: #include "jscntxt.h"
 52503: #include "jsnum.h"
 52503: #include "jsobjinlines.h"
 87171: #include "jsopcodeinlines.h"
 40359: #include "jspropertycacheinlines.h"
 40359: 
 40359: using namespace js;
 40359: 
 86484: PropertyCacheEntry *
 91237: PropertyCache::fill(JSContext *cx, JSObject *obj, unsigned scopeIndex, JSObject *pobj,
 83221:                     const Shape *shape)
 40359: {
 40362:     JS_ASSERT(this == &JS_PROPERTY_CACHE(cx));
 40359:     JS_ASSERT(!cx->runtime->gcRunning);
 40359: 
 40359:     /*
 40359:      * Check for overdeep scope and prototype chain. Because resolve, getter,
 40359:      * and setter hooks can change the prototype chain using JS_SetPrototype
 69855:      * after LookupPropertyWithFlags has returned, we calculate the protoIndex
 69855:      * here and not in LookupPropertyWithFlags.
 40359:      *
 40359:      * The scopeIndex can't be wrong. We require JS_SetParent calls to happen
 40359:      * before any running script might consult a parent-linked scope chain. If
 40359:      * this requirement is not satisfied, the fill in progress will never hit,
 83221:      * but scope shape tests ensure nothing malfunctions.
 40359:      */
 69855:     JS_ASSERT_IF(obj == pobj, scopeIndex == 0);
 40359: 
 40359:     JSObject *tmp = obj;
 91237:     for (unsigned i = 0; i < scopeIndex; i++)
 86483:         tmp = &tmp->asScope().enclosingScope();
 40359: 
 91237:     unsigned protoIndex = 0;
 69855:     while (tmp != pobj) {
 83307:         /*
 83307:          * Don't cache entries across prototype lookups which can mutate in
 83307:          * arbitrary ways without a shape change.
 83307:          */
 83307:         if (tmp->hasUncacheableProto()) {
 83307:             PCMETER(noprotos++);
 83307:             return JS_NO_PROP_CACHE_FILL;
 83307:         }
 83307: 
 49194:         tmp = tmp->getProto();
 49194: 
 40359:         /*
 40359:          * We cannot cache properties coming from native objects behind
 49194:          * non-native ones on the prototype chain. The non-natives can
 49194:          * mutate in arbitrary way without changing any shapes.
 40359:          */
 40430:         if (!tmp || !tmp->isNative()) {
 40362:             PCMETER(noprotos++);
 40359:             return JS_NO_PROP_CACHE_FILL;
 40359:         }
 40359:         ++protoIndex;
 40359:     }
 40359: 
 86418:     typedef PropertyCacheEntry Entry;
 86418:     if (scopeIndex > Entry::MaxScopeIndex || protoIndex > Entry::MaxProtoIndex) {
 40362:         PCMETER(longchains++);
 40359:         return JS_NO_PROP_CACHE_FILL;
 40359:     }
 40359: 
 40359:     /*
 40359:      * Optimize the cached vword based on our parameters and the current pc's
 40359:      * opcode format flags.
 40359:      */
 77343:     jsbytecode *pc;
 84304:     (void) cx->stack.currentScript(&pc);
 86419:     JSOp op = JSOp(*pc);
 86419:     const JSCodeSpec *cs = &js_CodeSpec[op];
 40359: 
 83221:     if ((cs->format & JOF_SET) && obj->watched())
 40359:         return JS_NO_PROP_CACHE_FILL;
 40359: 
 40359:     if (obj == pobj) {
 40359:         JS_ASSERT(scopeIndex == 0 && protoIndex == 0);
 40359:     } else {
 40359: #ifdef DEBUG
 40359:         if (scopeIndex == 0) {
 40359:             JS_ASSERT(protoIndex != 0);
 40359:             JS_ASSERT((protoIndex == 1) == (obj->getProto() == pobj));
 40359:         }
 40359: #endif
 40359: 
 40359:         if (scopeIndex != 0 || protoIndex != 1) {
 40359:             /*
 40359:              * Make sure that a later shadowing assignment will enter
 40359:              * PurgeProtoChain and invalidate this entry, bug 479198.
 40359:              */
 83248:             if (!obj->isDelegate())
 83248:                 return JS_NO_PROP_CACHE_FILL;
 40359:         }
 40359:     }
 40359: 
 86419:     PropertyCacheEntry *entry = &table[hash(pc, obj->lastProperty())];
 40374:     PCMETER(entry->vword.isNull() || recycles++);
 83221:     entry->assign(pc, obj->lastProperty(), pobj->lastProperty(), shape, scopeIndex, protoIndex);
 40359: 
 40362:     empty = false;
 40362:     PCMETER(fills++);
 40359: 
 40359:     /*
 40359:      * The modfills counter is not exact. It increases if a getter or setter
 40359:      * recurse into the interpreter.
 40359:      */
 40362:     PCMETER(entry == pctestentry || modfills++);
 40362:     PCMETER(pctestentry = NULL);
 40359:     return entry;
 40359: }
 40359: 
 86542: PropertyName *
 40362: PropertyCache::fullTest(JSContext *cx, jsbytecode *pc, JSObject **objp, JSObject **pobjp,
 40362:                         PropertyCacheEntry *entry)
 40359: {
 40359:     JSObject *obj, *pobj, *tmp;
 77343:     JSScript *script = cx->stack.currentScript();
 51446: 
 40362:     JS_ASSERT(this == &JS_PROPERTY_CACHE(cx));
 84755:     JS_ASSERT(uint32_t(pc - script->code) < script->length);
 40359: 
 84195:     JSOp op = JSOp(*pc);
 40359:     const JSCodeSpec &cs = js_CodeSpec[op];
 40359: 
 40359:     obj = *objp;
 40359: 
 40359:     if (entry->kpc != pc) {
 40362:         PCMETER(kpcmisses++);
 40359: 
103195:         PropertyName *name = GetNameFromBytecode(cx, script, pc, op);
 40359: #ifdef DEBUG_notme
 57812:         JSAutoByteString printable;
 40359:         fprintf(stderr,
 40359:                 "id miss for %s from %s:%u"
 83221:                 " (pc %u, kpc %u, kshape %p, shape %p)\n",
 86542:                 js_AtomToPrintableString(cx, name, &printable),
 51449:                 script->filename,
 51449:                 js_PCToLineNumber(cx, script, pc),
 51449:                 pc - script->code,
 51449:                 entry->kpc - script->code,
 40359:                 entry->kshape,
 83221:                 obj->lastProperty());
 51449:                 js_Disassemble1(cx, script, pc,
 51449:                                 pc - script->code,
 40359:                                 JS_FALSE, stderr);
 40359: #endif
 40359: 
 86542:         return name;
 40359:     }
 40359: 
 83221:     if (entry->kshape != obj->lastProperty()) {
 40362:         PCMETER(kshapemisses++);
103195:         return GetNameFromBytecode(cx, script, pc, op);
 40359:     }
 40359: 
 40359:     /*
 40362:      * PropertyCache::test handles only the direct and immediate-prototype hit
 83221:      * cases. All others go here.
 40359:      */
 40359:     pobj = obj;
 40359: 
 40359:     if (JOF_MODE(cs.format) == JOF_NAME) {
 86418:         uint8_t scopeIndex = entry->scopeIndex;
 86418:         while (scopeIndex > 0) {
 86483:             tmp = pobj->enclosingScope();
 40430:             if (!tmp || !tmp->isNative())
 40359:                 break;
 40359:             pobj = tmp;
 86418:             scopeIndex--;
 40359:         }
 40359: 
 40359:         *objp = pobj;
 40359:     }
 40359: 
 86418:     uint8_t protoIndex = entry->protoIndex;
 86418:     while (protoIndex > 0) {
 40359:         tmp = pobj->getProto();
 40430:         if (!tmp || !tmp->isNative())
 40359:             break;
 40359:         pobj = tmp;
 86418:         protoIndex--;
 40359:     }
 40359: 
 83221:     if (pobj->lastProperty() == entry->pshape) {
 40359: #ifdef DEBUG
103195:         PropertyName *name = GetNameFromBytecode(cx, script, pc, op);
 97828:         JS_ASSERT(pobj->nativeContains(cx, NameToId(name)));
 40359: #endif
 40359:         *pobjp = pobj;
 40359:         return NULL;
 40359:     }
 40359: 
 40362:     PCMETER(vcapmisses++);
103195:     return GetNameFromBytecode(cx, script, pc, op);
 40359: }
 40359: 
 40359: #ifdef DEBUG
 40362: void
 40362: PropertyCache::assertEmpty()
 40362: {
 40362:     JS_ASSERT(empty);
 91237:     for (unsigned i = 0; i < SIZE; i++) {
 40362:         JS_ASSERT(!table[i].kpc);
 40362:         JS_ASSERT(!table[i].kshape);
 83221:         JS_ASSERT(!table[i].pshape);
 83221:         JS_ASSERT(!table[i].prop);
 86418:         JS_ASSERT(!table[i].scopeIndex);
 86418:         JS_ASSERT(!table[i].protoIndex);
 40362:     }
 40362: }
 40359: #endif
 40359: 
 40359: void
 91250: PropertyCache::purge(JSRuntime *rt)
 40359: {
 40362:     if (empty) {
 40362:         assertEmpty();
 40359:         return;
 40359:     }
 40359: 
 40362:     PodArrayZero(table);
 40362:     empty = true;
 40359: 
 40359: #ifdef JS_PROPERTY_CACHE_METERING
 40359:   { static FILE *fp;
 40359:     if (!fp)
 40359:         fp = fopen("/tmp/propcache.stats", "w");
 40359:     if (fp) {
 40359:         fputs("Property cache stats for ", fp);
 91250:         fprintf(fp, "GC %lu\n", (unsigned long)rt->gcNumber);
 40359: 
 40362: # define P(mem) fprintf(fp, "%11s %10lu\n", #mem, (unsigned long)mem)
 40359:         P(fills);
 40359:         P(nofills);
 40359:         P(rofills);
 40359:         P(disfills);
 40359:         P(oddfills);
 53656:         P(add2dictfills);
 40359:         P(modfills);
 40359:         P(brandfills);
 40359:         P(noprotos);
 40359:         P(longchains);
 40359:         P(recycles);
 40359:         P(tests);
 40359:         P(pchits);
 40359:         P(protopchits);
 40359:         P(initests);
 40359:         P(inipchits);
 40359:         P(inipcmisses);
 40359:         P(settests);
 40359:         P(addpchits);
 40359:         P(setpchits);
 40359:         P(setpcmisses);
 40359:         P(setmisses);
 40359:         P(kpcmisses);
 40359:         P(kshapemisses);
 40359:         P(vcapmisses);
 40359:         P(misses);
 40359:         P(flushes);
 40359:         P(pcpurges);
 40359: # undef P
 40359: 
 40359:         fprintf(fp, "hit rates: pc %g%% (proto %g%%), set %g%%, ini %g%%, full %g%%\n",
 40362:                 (100. * pchits) / tests,
 40362:                 (100. * protopchits) / tests,
 40362:                 (100. * (addpchits + setpchits))
 40362:                 / settests,
 40362:                 (100. * inipchits) / initests,
 40362:                 (100. * (tests - misses)) / tests);
 40359:         fflush(fp);
 40359:     }
 40359:   }
 40359: #endif
 40359: 
 40362:     PCMETER(flushes++);
 40359: }
 40359: 
 40359: void
 64357: PropertyCache::restore(PropertyCacheEntry *entry)
 64357: {
 64357:     PropertyCacheEntry *entry2;
 64357: 
 64357:     empty = false;
 64357: 
 64357:     entry2 = &table[hash(entry->kpc, entry->kshape)];
 64357:     *entry2 = *entry;
 64357: }
