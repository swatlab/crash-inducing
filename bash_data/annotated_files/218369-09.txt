162892: /* This Source Code Form is subject to the terms of the Mozilla Public
162892:  * License, v. 2.0. If a copy of the MPL was not distributed with this
162892:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
162892: 
162892: #include "nsISupports.idl"
162892: 
162892: interface nsIInputStream;
162892: interface nsIOutputStream;
162892: interface nsICacheEntryDoomCallback;
162892: 
162892: // ************************ REMOVE **********************
162892: typedef long nsCacheAccessMode;
162892: typedef long nsCacheStoragePolicy;
162892: 
162892: interface nsICacheListener;
162892: interface nsIFile;
201508: interface nsICacheEntryMetaDataVisitor;
162892: 
218369: [scriptable, uuid(972dc51d-df01-4b1e-b7f3-76dbcc603b1e)]
162892: interface nsICacheEntry : nsISupports
162892: {
162892:   /**
196658:    * Placeholder for the initial value of expiration time.
196658:    */
196658:   const unsigned long NO_EXPIRATION_TIME = 0xFFFFFFFF;
196658: 
196658:   /**
162892:    * Get the key identifying the cache entry.
162892:    */
162892:   readonly attribute ACString key;
162892: 
162892:   /**
184910:    * Whether the entry is memory/only or persisted to disk.
184910:    * Note: private browsing entries are reported as persistent for consistency
184910:    * while are not actually persisted to disk.
162892:    */
184910:   readonly attribute boolean persistent;
162892: 
162892:   /**
162892:    * Get the number of times the cache entry has been opened.
162892:    */
162892:   readonly attribute long  fetchCount;
162892: 
162892:   /**
162892:    * Get the last time the cache entry was opened (in seconds since the Epoch).
162892:    */
162892:   readonly attribute uint32_t  lastFetched;
162892: 
162892:   /**
162892:    * Get the last time the cache entry was modified (in seconds since the Epoch).
162892:    */
162892:   readonly attribute uint32_t  lastModified;
162892: 
162892:   /**
162892:    * Get the expiration time of the cache entry (in seconds since the Epoch).
162892:    */
162892:   readonly attribute uint32_t  expirationTime;
162892: 
162892:   /**
162892:    * Set the time at which the cache entry should be considered invalid (in
162892:    * seconds since the Epoch).
162892:    */
162892:   void setExpirationTime(in uint32_t expirationTime);
162892: 
162892:   /**
162892:    * Open blocking input stream to cache data.  Use the stream transport
162892:    * service to asynchronously read this stream on a background thread.
162892:    * The returned stream MAY implement nsISeekableStream.
162892:    *
162892:    * @param offset
162892:    *        read starting from this offset into the cached data.  an offset
162892:    *        beyond the end of the stream has undefined consequences.
162892:    *
196658:    * @return non-blocking, buffered input stream.
162892:    */
162892:   nsIInputStream openInputStream(in long long offset);
162892: 
162892:   /**
162892:    * Open non-blocking output stream to cache data.  The returned stream
162892:    * MAY implement nsISeekableStream.
162892:    *
162892:    * If opening an output stream to existing cached data, the data will be
162892:    * truncated to the specified offset.
162892:    *
162892:    * @param offset
162892:    *        write starting from this offset into the cached data.  an offset
162892:    *        beyond the end of the stream has undefined consequences.
162892:    *
196658:    * @return blocking, buffered output stream.
162892:    */
162892:   nsIOutputStream openOutputStream(in long long offset);
162892: 
162892:   /**
162892:     * Stores the Content-Length specified in the HTTP header for this
162892:     * entry. Checked before we write to the cache entry, to prevent ever
162892:     * taking up space in the cache for an entry that we know up front
162892:     * is going to have to be evicted anyway. See bug 588507.
162892:     */
162892:   attribute int64_t predictedDataSize;
162892: 
162892:   /**
162892:    * Get/set security info on the cache entry for this descriptor.
162892:    */
162892:   attribute nsISupports securityInfo;
162892: 
162892:   /**
162892:    * Get the size of the cache entry data, as stored. This may differ
162892:    * from the entry's dataSize, if the entry is compressed.
162892:    */
162892:   readonly attribute unsigned long storageDataSize;
162892: 
162892:   /**
162892:    * Asynchronously doom an entry. Listener will be notified about the status
162892:    * of the operation. Null may be passed if caller doesn't care about the
162892:    * result.
162892:    */
162892:   void asyncDoom(in nsICacheEntryDoomCallback listener);
162892: 
162892:   /**
162892:    * Methods for accessing meta data.  Meta data is a table of key/value
162892:    * string pairs.  The strings do not have to conform to any particular
162892:    * charset, but they must be null terminated.
162892:    */
162892:   string getMetaDataElement(in string key);
162892:   void   setMetaDataElement(in string key, in string value);
162892: 
162892:   /**
201508:    * Obtain the list of metadata keys this entry keeps.
201508:    *
201508:    * NOTE: The callback is invoked under the CacheFile's lock.  It means
201508:    * there should not be made any calls to the entry from the visitor and
201508:    * if the values need to be processed somehow, it's better to cache them
201508:    * and process outside the callback.
201508:    */
201508:   void visitMetaData(in nsICacheEntryMetaDataVisitor visitor);
201508: 
201508:   /**
162892:    * Claims that all metadata on this entry are up-to-date and this entry
162892:    * now can be delivered to other waiting consumers.
162892:    *
162892:    * We need such method since metadata must be delivered synchronously.
162892:    */
162892:   void metaDataReady();
162892: 
162892:   /**
162892:    * Called by consumer upon 304/206 response from the server.  This marks
162892:    * the entry content as positively revalidated.
162892:    * Consumer uses this method after the consumer has returned ENTRY_NEEDS_REVALIDATION
162892:    * result from onCacheEntryCheck and after successfull revalidation with the server.
162892:    */
162892:   void setValid();
162892: 
162892:   /**
162892:    * Doom this entry and open a new, empty, entry for write.  Consumer has
196658:    * to exchange the entry this method is called on for the newly created.
162892:    * Used on 200 responses to conditional requests.
162892:    *
184910:    * @param aMemoryOnly
184910:    *    - whether the entry is to be created as memory/only regardless how
184910:    *      the entry being recreated persistence is set
162892:    * @returns
162892:    *    - an entry that can be used to write to
162892:    * @throws
162892:    *    - NS_ERROR_NOT_AVAILABLE when the entry cannot be from some reason
162892:    *      recreated for write
162892:    */
184910:   nsICacheEntry recreate([optional] in boolean aMemoryOnly);
162892: 
162892:   /**
162892:    * Returns the length of data this entry holds.
162892:    * @throws
162892:    *    NS_ERROR_IN_PROGRESS when the write is still in progress.
162892:    */
162892:   readonly attribute long long dataSize;
162892: 
196658:   /****************************************************************************
196658:    * The following methods might be added to some nsICacheEntryInternal
196658:    * interface since we want to remove them as soon as the old cache backend is
196658:    * completely removed.
196658:    */
196658: 
162892:   /**
196658:    * @deprecated
162892:    * FOR BACKWARD COMPATIBILITY ONLY
162892:    * When the old cache backend is eventually removed, this method
162892:    * can be removed too.
162892:    *
162892:    * In the new backend: this method is no-op
162892:    * In the old backend: this method delegates to nsICacheEntryDescriptor.close()
162892:    */
162892:   void close();
162892: 
162892:   /**
196658:    * @deprecated
162892:    * FOR BACKWARD COMPATIBILITY ONLY
162892:    * Marks the entry as valid so that others can use it and get only readonly
162892:    * access when the entry is held by the 1st writer.
162892:    */
162892:   void markValid();
162892: 
162892:   /**
196658:    * @deprecated
162892:    * FOR BACKWARD COMPATIBILITY ONLY
162892:    * Marks the entry as valid when write access is acquired.
162892:    */
162892:   void maybeMarkValid();
162892: 
162892:   /**
196658:    * @deprecated
162892:    * FOR BACKWARD COMPATIBILITY ONLY / KINDA HACK
162892:    * @param aWriteAllowed
196658:    *    Consumer indicates whether write to the entry is allowed for it.
196658:    *    Depends on implementation how the flag is handled.
162892:    * @returns
196658:    *    true when write access is acquired for this entry,
162892:    *    false otherwise
162892:    */
162892:   boolean hasWriteAccess(in boolean aWriteAllowed);
162892: };
201508: 
201508: /**
201508:  * Argument for nsICacheEntry.visitMetaData, provides access to all metadata
201508:  * keys and values stored on the entry.
201508:  */
201508: [scriptable, uuid(fea3e276-6ba5-4ceb-a581-807d1f43f6d0)]
201508: interface nsICacheEntryMetaDataVisitor : nsISupports
201508: {
201508:   /**
201508:    * Called over each key / value pair.
201508:    */
201508:   void onMetaDataElement(in string key, in string value);
201508: };
