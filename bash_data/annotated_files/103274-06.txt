 29366: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 32658:  * vim: set ts=8 sw=4 et tw=99:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JavaScript bytecode interpreter.
     1:  */
 95341: 
 95341: #include "mozilla/FloatingPoint.h"
 95341: 
     1: #include <stdio.h>
     1: #include <string.h>
     1: #include <math.h>
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
     1: #include "jsprf.h"
     1: #include "jsapi.h"
     1: #include "jsarray.h"
     1: #include "jsatom.h"
     1: #include "jsbool.h"
     1: #include "jscntxt.h"
 25087: #include "jsdate.h"
 18863: #include "jsversion.h"
     1: #include "jsdbgapi.h"
     1: #include "jsfun.h"
     1: #include "jsgc.h"
     1: #include "jsinterp.h"
     1: #include "jsiter.h"
     1: #include "jslock.h"
     1: #include "jsnum.h"
     1: #include "jsobj.h"
     1: #include "jsopcode.h"
 40359: #include "jspropertycache.h"
     1: #include "jsscope.h"
     1: #include "jsscript.h"
     1: #include "jsstr.h"
 30268: #include "jslibmath.h"
 80202: 
 97569: #include "gc/Marking.h"
 68931: #ifdef JS_METHODJIT
 52558: #include "methodjit/MethodJIT.h"
 52558: #include "methodjit/Logging.h"
 68931: #endif
 76244: #include "vm/Debugger.h"
 76244: 
 34349: #include "jsatominlines.h"
 76194: #include "jsinferinlines.h"
 53840: #include "jsinterpinlines.h"
 42714: #include "jsobjinlines.h"
 87171: #include "jsopcodeinlines.h"
 56556: #include "jsprobes.h"
 40359: #include "jspropertycacheinlines.h"
 34349: #include "jsscopeinlines.h"
 34349: #include "jsscriptinlines.h"
 74875: #include "jstypedarrayinlines.h"
  7058: 
 69223: #include "vm/Stack-inl.h"
 72107: #include "vm/String-inl.h"
 69223: 
     1: #if JS_HAS_XML_SUPPORT
     1: #include "jsxml.h"
     1: #endif
     1: 
 15453: #include "jsautooplen.h"
 15453: 
 54832: #if defined(JS_METHODJIT) && defined(JS_MONOIC)
 54832: #include "methodjit/MonoIC.h"
 54832: #endif
 54832: 
 37741: using namespace js;
 54707: using namespace js::gc;
 76194: using namespace js::types;
 37741: 
 47405: /* Some objects (e.g., With) delegate 'this' to another object. */
 47405: static inline JSObject *
 48470: CallThisObjectHook(JSContext *cx, JSObject *obj, Value *argv)
 47405: {
 47405:     JSObject *thisp = obj->thisObject(cx);
 47405:     if (!thisp)
 47405:         return NULL;
 48470:     argv[-1].setObject(*thisp);
 47405:     return thisp;
 47405: }
 47405: 
 68904: /*
 68904:  * ECMA requires "the global object", but in embeddings such as the browser,
 68904:  * which have multiple top-level objects (windows, frames, etc. in the DOM),
 68904:  * we prefer fun's parent.  An example that causes this code to run:
 68904:  *
 68904:  *   // in window w1
 68904:  *   function f() { return this }
 68904:  *   function g() { return f }
 68904:  *
 68904:  *   // in window w2
 68904:  *   var h = w1.g()
 68904:  *   alert(h() == w1)
 68904:  *
 68904:  * The alert should display "true".
 68904:  */
 55711: bool
 77822: js::BoxNonStrictThis(JSContext *cx, const CallReceiver &call)
 48470: {
 50489:     /*
 50489:      * Check for SynthesizeFrame poisoning and fast constructors which
 68904:      * didn't check their callee properly.
 50489:      */
 68904:     Value &thisv = call.thisv();
 68904:     JS_ASSERT(!thisv.isMagic());
 68904: 
 61734: #ifdef DEBUG
 83234:     JSFunction *fun = call.callee().isFunction() ? call.callee().toFunction() : NULL;
 61734:     JS_ASSERT_IF(fun && fun->isInterpreted(), !fun->inStrictMode());
 61734: #endif
 61734: 
 68904:     if (thisv.isNullOrUndefined()) {
 86483:         JSObject *thisp = call.callee().global().thisObject(cx);
 97353:         JS_ASSERT(!IsPoisonedPtr(thisp));
 68904:         if (!thisp)
 68904:             return false;
 68904:         call.thisv().setObject(*thisp);
 68904:         return true;
 68904:     }
 68904: 
 68904:     if (!thisv.isObject())
 68904:         return !!js_PrimitiveToObject(cx, &thisv);
 61734: 
 53004:     return true;
 47405: }
 47405: 
     1: #if JS_HAS_NO_SUCH_METHOD
     1: 
 84755: const uint32_t JSSLOT_FOUND_FUNCTION  = 0;
 84755: const uint32_t JSSLOT_SAVED_ID        = 1;
 14789: 
 48470: Class js_NoSuchMethodClass = {
 12579:     "NoSuchMethod",
 28093:     JSCLASS_HAS_RESERVED_SLOTS(2) | JSCLASS_IS_ANONYMOUS,
 89143:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
 89143:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub,
 12579: };
 12579: 
 12579: /*
 12579:  * When JSOP_CALLPROP or JSOP_CALLELEM does not find the method property of
 12579:  * the base object, we search for the __noSuchMethod__ method in the base.
 12579:  * If it exists, we store the method and the property's id into an object of
 12579:  * NoSuchMethod class and store this object into the callee's stack slot.
 76829:  * Later, Invoke will recognise such an object and transfer control to
 12579:  * NoSuchMethod that invokes the method like:
 12579:  *
 12579:  *   this.__noSuchMethod__(id, args)
 12579:  *
 12579:  * where id is the name of the method that this invocation attempted to
 12579:  * call by name, and args is an Array containing this invocation's actual
 12579:  * parameters.
 12579:  */
 77822: bool
 97353: js::OnUnknownMethod(JSContext *cx, HandleObject obj, Value idval_, Value *vp)
 48470: {
 99421:     RootedValue idval(cx, idval_);
 99421: 
 99421:     RootedId id(cx, NameToId(cx->runtime->atomState.noSuchMethodAtom));
 99421:     RootedValue value(cx);
 98960:     if (!GetMethod(cx, obj, id, 0, value.address()))
 33178:         return false;
 77391:     TypeScript::MonitorUnknown(cx, cx->fp()->script(), cx->regs().pc);
 76194: 
 97353:     if (value.reference().isPrimitive()) {
 97353:         *vp = value;
 12579:     } else {
     1: #if JS_HAS_XML_SUPPORT
 12610:         /* Extract the function name from function::name qname. */
 97353:         if (idval.reference().isObject()) {
 97353:             JSObject *obj = &idval.reference().toObject();
 98960:             if (js_GetLocalNameFromFunctionQName(obj, id.address(), cx))
 86855:                 idval = IdToValue(id);
 12610:         }
     1: #endif
 83221: 
 95355:         JSObject *obj = NewObjectWithClassProto(cx, &js_NoSuchMethodClass, NULL, NULL);
 33178:         if (!obj)
 33178:             return false;
 47497: 
 97353:         obj->setSlot(JSSLOT_FOUND_FUNCTION, value);
 86855:         obj->setSlot(JSSLOT_SAVED_ID, idval);
 86855:         vp->setObject(*obj);
 12579:     }
 33178:     return true;
 12579: }
 12579: 
 86484: static JSBool
 91237: NoSuchMethod(JSContext *cx, unsigned argc, Value *vp)
     1: {
 42714:     InvokeArgsGuard args;
 69223:     if (!cx->stack.pushInvokeArgs(cx, 2, &args))
 14789:         return JS_FALSE;
 12579: 
 48470:     JS_ASSERT(vp[0].isObject());
 48470:     JS_ASSERT(vp[1].isObject());
 48470:     JSObject *obj = &vp[0].toObject();
 40410:     JS_ASSERT(obj->getClass() == &js_NoSuchMethodClass);
 14789: 
 68893:     args.calleev() = obj->getSlot(JSSLOT_FOUND_FUNCTION);
 50468:     args.thisv() = vp[1];
 55746:     args[0] = obj->getSlot(JSSLOT_SAVED_ID);
 59234:     JSObject *argsobj = NewDenseCopiedArray(cx, argc, vp + 2);
 42714:     if (!argsobj)
 42714:         return JS_FALSE;
 50468:     args[1].setObject(*argsobj);
 69223:     JSBool ok = Invoke(cx, args);
 50468:     vp[0] = args.rval();
   348:     return ok;
     1: }
     1: 
     1: #endif /* JS_HAS_NO_SUCH_METHOD */
     1: 
 86484: bool
103274: js::ReportIsNotFunction(JSContext *cx, const Value &v, MaybeConstruct construct)
103274: {
103274:     unsigned error = construct ? JSMSG_NOT_CONSTRUCTOR : JSMSG_NOT_FUNCTION;
103274:     js_ReportValueError3(cx, error, JSDVG_SEARCH_STACK, v, NULL, NULL, NULL);
103274:     return false;
103274: }
103274: 
103274: bool
103274: js::ReportIsNotFunction(JSContext *cx, const Value *vp, MaybeConstruct construct)
103274: {
103274:     ptrdiff_t spIndex = cx->stack.spIndexOf(vp);
103274:     unsigned error = construct ? JSMSG_NOT_CONSTRUCTOR : JSMSG_NOT_FUNCTION;
103274:     js_ReportValueError3(cx, error, spIndex, *vp, NULL, NULL, NULL);
103274:     return false;
103274: }
103274: 
103274: JSObject *
103274: js::ValueToCallable(JSContext *cx, const Value *vp, MaybeConstruct construct)
103274: {
103274:     if (vp->isObject()) {
103274:         JSObject *callable = &vp->toObject();
103274:         if (callable->isCallable())
103274:             return callable;
103274:     }
103274: 
103274:     ReportIsNotFunction(cx, vp, construct);
103274:     return NULL;
103274: }
103274: 
103274: bool
 77822: js::RunScript(JSContext *cx, JSScript *script, StackFrame *fp)
 52558: {
 52558:     JS_ASSERT(script);
 63047:     JS_ASSERT(fp == cx->fp());
 63047:     JS_ASSERT(fp->script() == script);
 94586:     JS_ASSERT_IF(!fp->isGeneratorFrame(), cx->regs().pc == script->code);
101075:     JS_ASSERT_IF(fp->isEvalFrame(), script->isActiveEval);
 63047: #ifdef JS_METHODJIT_SPEW
 63047:     JMCheckLogging();
 63047: #endif
 63047: 
 94586:     JS_CHECK_RECURSION(cx, return false);
 94586: 
 62584:     /* FIXME: Once bug 470510 is fixed, make this an assert. */
 62954:     if (script->compileAndGo) {
 96793:         if (fp->global().isCleared()) {
 62584:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CLEARED_SCOPE);
 64365:             return false;
 63047:         }
 63047:     }
 63047: 
 91690: #ifdef DEBUG
 91690:     struct CheckStackBalance {
 91690:         JSContext *cx;
 91690:         StackFrame *fp;
 99421:         RootedObject enumerators;
 91690:         CheckStackBalance(JSContext *cx)
 97353:           : cx(cx), fp(cx->fp()), enumerators(cx, cx->enumerators)
 91690:         {}
 91690:         ~CheckStackBalance() {
 91690:             JS_ASSERT(fp == cx->fp());
 91690:             JS_ASSERT_IF(!fp->isGeneratorFrame(), enumerators == cx->enumerators);
 91690:         }
 91690:     } check(cx);
 91690: #endif
 91690: 
 63047: #ifdef JS_METHODJIT
 63047:     mjit::CompileStatus status;
 87654:     status = mjit::CanMethodJIT(cx, script, script->code, fp->isConstructing(),
 77461:                                 mjit::CompileRequest_Interpreter);
 63047:     if (status == mjit::Compile_Error)
 64365:         return false;
 64365: 
 64365:     if (status == mjit::Compile_Okay)
 93359:         return mjit::JaegerStatusToSuccess(mjit::JaegerShot(cx, false));
 63047: #endif
 63047: 
 64365:     return Interpret(cx, fp);
 62584: }
 52558: 
 53557: /*
 53557:  * Find a function reference and its 'this' value implicit first parameter
 53557:  * under argc arguments on cx's stack, and call the function.  Push missing
 53557:  * required arguments, allocate declared local variables, and pop everything
 53557:  * when done.  Then push the return value.
 53557:  */
 77822: bool
 79387: js::InvokeKernel(JSContext *cx, CallArgs args, MaybeConstruct construct)
 79387: {
 79387:     JS_ASSERT(args.length() <= StackSpace::ARGS_LENGTH_MAX);
 76194:     JS_ASSERT(!cx->compartment->activeAnalysis);
 76194: 
 77341:     /* MaybeConstruct is a subset of InitialFrameFlags */
 77341:     InitialFrameFlags initial = (InitialFrameFlags) construct;
 77341: 
103274:     if (args.calleev().isPrimitive())
103274:         return ReportIsNotFunction(cx, &args.calleev(), construct);
 53557: 
 68893:     JSObject &callee = args.callee();
 53840:     Class *clasp = callee.getClass();
 53557: 
 53557:     /* Invoke non-functions. */
 77817:     if (JS_UNLIKELY(clasp != &FunctionClass)) {
 53557: #if JS_HAS_NO_SUCH_METHOD
 53557:         if (JS_UNLIKELY(clasp == &js_NoSuchMethodClass))
 79387:             return NoSuchMethod(cx, args.length(), args.base());
 53557: #endif
 71695:         JS_ASSERT_IF(construct, !clasp->construct);
103274:         if (!clasp->call)
103274:             return ReportIsNotFunction(cx, &args.calleev(), construct);
 71695:         return CallJSNative(cx, clasp->call, args);
 53557:     }
 53557: 
 53557:     /* Invoke native functions. */
 99421:     RootedFunction fun(cx, callee.toFunction());
 86533:     JS_ASSERT_IF(construct, !fun->isNativeConstructor());
 55713:     if (fun->isNative())
 94094:         return CallJSNative(cx, fun->native(), args);
 53557: 
 95084:     if (!TypeMonitorCall(cx, args, construct))
 95084:         return false;
 77917: 
 77917:     /* Get pointer to new frame/slots, prepare arguments. */
 77917:     InvokeFrameGuard ifg;
 77917:     if (!cx->stack.pushInvokeFrame(cx, args, initial, &ifg))
 55565:         return false;
 55565: 
 77917:     /* Run function until JSOP_STOP, JSOP_RETURN or error. */
101075:     JSBool ok = RunScript(cx, fun->script(), ifg.fp());
 91690: 
 91690:     /* Propagate the return value out. */
101075:     args.rval() = ifg.fp()->returnValue();
 77917:     JS_ASSERT_IF(ok && construct, !args.rval().isPrimitive());
 77917:     return ok;
 55565: }
 55565: 
 55565: bool
 91237: js::Invoke(JSContext *cx, const Value &thisv, const Value &fval, unsigned argc, Value *argv,
 76829:            Value *rval)
     1: {
 42714:     InvokeArgsGuard args;
 69223:     if (!cx->stack.pushInvokeArgs(cx, argc, &args))
 57687:         return false;
  6040: 
 68893:     args.calleev() = fval;
 50468:     args.thisv() = thisv;
 87623:     PodCopy(args.array(), argv, argc);
 48470: 
 57761:     if (args.thisv().isObject()) {
 57761:         /*
 57761:          * We must call the thisObject hook in case we are not called from the
 57761:          * interpreter, where a prior bytecode has computed an appropriate
 57761:          * |this| already.
 57761:          */
 57761:         JSObject *thisp = args.thisv().toObject().thisObject(cx);
 57761:         if (!thisp)
 57761:              return false;
 57761:         args.thisv().setObject(*thisp);
 57761:     }
 57761: 
 69223:     if (!Invoke(cx, args))
 57687:         return false;
 42714: 
 50468:     *rval = args.rval();
 57687:     return true;
 57687: }
 57687: 
 57687: bool
103274: js::InvokeConstructorKernel(JSContext *cx, CallArgs args)
 86533: {
 86533:     JS_ASSERT(!FunctionClass.construct);
 86533: 
 86533:     args.thisv().setMagic(JS_IS_CONSTRUCTING);
 86533: 
103274:     if (!args.calleev().isObject())
103274:         return ReportIsNotFunction(cx, &args.calleev(), CONSTRUCT);
103274: 
103274:     JSObject &callee = args.callee();
103274:     if (callee.isFunction()) {
103274:         JSFunction *fun = callee.toFunction();
 86533: 
 86533:         if (fun->isNativeConstructor()) {
 86533:             Probes::calloutBegin(cx, fun);
 94094:             bool ok = CallJSNativeConstructor(cx, fun->native(), args);
 86533:             Probes::calloutEnd(cx, fun);
 86533:             return ok;
 86533:         }
 86533: 
 86533:         if (!fun->isInterpretedConstructor())
103274:             return ReportIsNotFunction(cx, &args.calleev(), CONSTRUCT);
 86533: 
 86533:         if (!InvokeKernel(cx, args, CONSTRUCT))
 86533:             return false;
 86533: 
 86533:         JS_ASSERT(args.rval().isObject());
 86533:         return true;
 86533:     }
103274: 
103274:     Class *clasp = callee.getClass();
103274:     if (!clasp->construct)
103274:         return ReportIsNotFunction(cx, &args.calleev(), CONSTRUCT);
103274: 
 86533:     return CallJSNativeConstructor(cx, clasp->construct, args);
 86533: }
 86533: 
 86533: bool
 91237: js::InvokeConstructor(JSContext *cx, const Value &fval, unsigned argc, Value *argv, Value *rval)
 57687: {
 57687:     InvokeArgsGuard args;
 69223:     if (!cx->stack.pushInvokeArgs(cx, argc, &args))
 57687:         return false;
 57687: 
 68893:     args.calleev() = fval;
 57687:     args.thisv().setMagic(JS_THIS_POISON);
 87623:     PodCopy(args.array(), argv, argc);
 57687: 
 57687:     if (!InvokeConstructor(cx, args))
 57687:         return false;
 57687: 
 57687:     *rval = args.rval();
 57687:     return true;
     1: }
     1: 
 48470: bool
 91237: js::InvokeGetterOrSetter(JSContext *cx, JSObject *obj, const Value &fval, unsigned argc, Value *argv,
 76829:                          Value *rval)
     1: {
     1:     /*
 76829:      * Invoke could result in another try to get or set the same id again, see
 76829:      * bug 355497.
     1:      */
 64246:     JS_CHECK_RECURSION(cx, return false);
     1: 
 76829:     return Invoke(cx, ObjectValue(*obj), fval, argc, argv, rval);
 48470: }
 48470: 
 64364: bool
 99364: js::ExecuteKernel(JSContext *cx, JSScript *script_, JSObject &scopeChain, const Value &thisv,
 71695:                   ExecuteType type, StackFrame *evalInFrame, Value *result)
 71695: {
 71695:     JS_ASSERT_IF(evalInFrame, type == EXECUTE_DEBUG);
 98921:     JS_ASSERT_IF(type == EXECUTE_GLOBAL, !scopeChain.isScope());
 64364: 
 99421:     JS::Rooted<JSScript*> script(cx, script_);
 86437: 
 64364:     if (script->isEmpty()) {
 64364:         if (result)
 64364:             result->setUndefined();
 64364:         return true;
 64364:     }
 64364: 
 71695:     ExecuteFrameGuard efg;
 71695:     if (!cx->stack.pushExecuteFrame(cx, script, thisv, scopeChain, type, evalInFrame, &efg))
 64364:         return false;
 64364: 
 86437:     if (!script->ensureRanAnalysis(cx, &scopeChain))
 86437:         return false;
101075:     TypeScript::SetThis(cx, script, efg.fp()->thisValue());
 64364: 
 53555:     Probes::startExecution(cx, script);
101075:     bool ok = RunScript(cx, script, efg.fp());
 53555:     Probes::stopExecution(cx, script);
 53555: 
 91690:     /* Propgate the return value out. */
 91690:     if (result)
101075:         *result = efg.fp()->returnValue();
 91690:     return ok;
 48470: }
 48470: 
 48470: bool
 77822: js::Execute(JSContext *cx, JSScript *script, JSObject &scopeChainArg, Value *rval)
 71695: {
 71695:     /* The scope chain could be anything, so innerize just in case. */
 99421:     RootedObject scopeChain(cx, &scopeChainArg);
 98960:     scopeChain = GetInnerObject(cx, scopeChain);
 71695:     if (!scopeChain)
 71695:         return false;
 71695: 
 71695:     /* If we were handed a non-native object, complain bitterly. */
 71695:     if (!scopeChain->isNative()) {
 71695:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NON_NATIVE_SCOPE);
 71695:         return false;
 71695:     }
 71695:     JS_ASSERT(!scopeChain->getOps()->defineProperty);
 71695: 
 71695:     /* The VAROBJFIX option makes varObj == globalObj in global code. */
 83248:     if (!cx->hasRunOption(JSOPTION_VAROBJFIX)) {
 83248:         if (!scopeChain->setVarObj(cx))
 83248:             return false;
 83248:     }
 71695: 
 71695:     /* Use the scope chain as 'this', modulo outerization. */
 71695:     JSObject *thisObj = scopeChain->thisObject(cx);
 71695:     if (!thisObj)
 71695:         return false;
 71695:     Value thisv = ObjectValue(*thisObj);
 71695: 
 76829:     return ExecuteKernel(cx, script, *scopeChain, thisv, EXECUTE_GLOBAL,
 71695:                          NULL /* evalInFrame */, rval);
 71695: }
 71695: 
 48529: JSBool
 98960: js::HasInstance(JSContext *cx, HandleObject obj, const Value *v, JSBool *bp)
 48529: {
 48529:     Class *clasp = obj->getClass();
 48529:     if (clasp->hasInstance)
 48529:         return clasp->hasInstance(cx, obj, v, bp);
 48529:     js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
 48529:                         JSDVG_SEARCH_STACK, ObjectValue(*obj), NULL);
 48529:     return JS_FALSE;
 48529: }
 48529: 
 48470: bool
 88099: js::LooselyEqual(JSContext *cx, const Value &lval, const Value &rval, bool *result)
 64551: {
 64551: #if JS_HAS_XML_SUPPORT
 64551:     if (JS_UNLIKELY(lval.isObject() && lval.toObject().isXML()) ||
 64551:                     (rval.isObject() && rval.toObject().isXML())) {
 88099:         JSBool res;
 88099:         if (!js_TestXMLEquality(cx, lval, rval, &res))
 88099:             return false;
 88099:         *result = !!res;
 88099:         return true;
 64551:     }
 64551: #endif
 64551: 
 64551:     if (SameType(lval, rval)) {
 64551:         if (lval.isString()) {
 64551:             JSString *l = lval.toString();
 64551:             JSString *r = rval.toString();
 64551:             return EqualStrings(cx, l, r, result);
 64551:         }
 64551: 
 64551:         if (lval.isDouble()) {
 64551:             double l = lval.toDouble(), r = rval.toDouble();
 88220:             *result = (l == r);
 64551:             return true;
 64551:         }
 64551: 
 64551:         if (lval.isObject()) {
 64551:             JSObject *l = &lval.toObject();
 64551:             JSObject *r = &rval.toObject();
 64551: 
 78614:             if (JSEqualityOp eq = l->getClass()->ext.equality) {
 88099:                 JSBool res;
102586:                 Rooted<JSObject*> lobj(cx, l);
102586:                 if (!eq(cx, lobj, &rval, &res))
 88099:                     return false;
 88099:                 *result = !!res;
 88099:                 return true;
 64551:             }
 64551: 
 64551:             *result = l == r;
 64551:             return true;
 64551:         }
 64551: 
 64551:         *result = lval.payloadAsRawUint32() == rval.payloadAsRawUint32();
 64551:         return true;
 64551:     }
 64551: 
 64551:     if (lval.isNullOrUndefined()) {
 64551:         *result = rval.isNullOrUndefined();
 64551:         return true;
 64551:     }
 64551: 
 64551:     if (rval.isNullOrUndefined()) {
 64551:         *result = false;
 64551:         return true;
 64551:     }
 64551: 
 99421:     RootedValue lvalue(cx, lval);
 99421:     RootedValue rvalue(cx, rval);
 97353: 
 97353:     if (!ToPrimitive(cx, lvalue.address()))
 64551:         return false;
 97353:     if (!ToPrimitive(cx, rvalue.address()))
 64551:         return false;
 64551: 
 97353:     if (lvalue.reference().isString() && rvalue.reference().isString()) {
 97353:         JSString *l = lvalue.reference().toString();
 97353:         JSString *r = rvalue.reference().toString();
 64551:         return EqualStrings(cx, l, r, result);
 64551:     }
 64551: 
 64551:     double l, r;
 73894:     if (!ToNumber(cx, lvalue, &l) || !ToNumber(cx, rvalue, &r))
 64551:         return false;
 88220:     *result = (l == r);
 64551:     return true;
 64551: }
 64551: 
 64551: bool
 88099: js::StrictlyEqual(JSContext *cx, const Value &lref, const Value &rref, bool *equal)
 48470: {
 48470:     Value lval = lref, rval = rref;
 48470:     if (SameType(lval, rval)) {
 48470:         if (lval.isString())
 59890:             return EqualStrings(cx, lval.toString(), rval.toString(), equal);
 59890:         if (lval.isDouble()) {
 88220:             *equal = (lval.toDouble() == rval.toDouble());
 53418:             return true;
 59890:         }
 59890:         if (lval.isObject()) {
 68893:             *equal = lval.toObject() == rval.toObject();
 59890:             return true;
 59890:         }
 59890:         if (lval.isUndefined()) {
 59890:             *equal = true;
 59890:             return true;
 59890:         }
 59890:         *equal = lval.payloadAsRawUint32() == rval.payloadAsRawUint32();
 59890:         return true;
 48470:     }
 48470: 
 48470:     if (lval.isDouble() && rval.isInt32()) {
 48470:         double ld = lval.toDouble();
 48470:         double rd = rval.toInt32();
 88220:         *equal = (ld == rd);
 59890:         return true;
     1:     }
 48470:     if (lval.isInt32() && rval.isDouble()) {
 48470:         double ld = lval.toInt32();
 48470:         double rd = rval.toDouble();
 88220:         *equal = (ld == rd);
 59890:         return true;
 59890:     }
 59890: 
 59890:     *equal = false;
 59890:     return true;
     1: }
     1: 
 32760: static inline bool
 48470: IsNegativeZero(const Value &v)
 48470: {
 95341:     return v.isDouble() && MOZ_DOUBLE_IS_NEGATIVE_ZERO(v.toDouble());
 32760: }
 32760: 
 32760: static inline bool
 48470: IsNaN(const Value &v)
 48470: {
 95341:     return v.isDouble() && MOZ_DOUBLE_IS_NaN(v.toDouble());
 48470: }
 48470: 
 48470: bool
 88099: js::SameValue(JSContext *cx, const Value &v1, const Value &v2, bool *same)
 59890: {
 59890:     if (IsNegativeZero(v1)) {
 59890:         *same = IsNegativeZero(v2);
 48470:         return true;
 59890:     }
 59890:     if (IsNegativeZero(v2)) {
 59890:         *same = false;
 59890:         return true;
 59890:     }
 59890:     if (IsNaN(v1) && IsNaN(v2)) {
 59890:         *same = true;
 59890:         return true;
 59890:     }
 59890:     return StrictlyEqual(cx, v1, v2, same);
 48470: }
 48470: 
 48470: JSType
 77822: js::TypeOfValue(JSContext *cx, const Value &vref)
 48470: {
 48470:     Value v = vref;
 48470:     if (v.isNumber())
 48470:         return JSTYPE_NUMBER;
 48470:     if (v.isString())
 48470:         return JSTYPE_STRING;
 48470:     if (v.isNull())
 48470:         return JSTYPE_OBJECT;
 48470:     if (v.isUndefined())
 48470:         return JSTYPE_VOID;
 48470:     if (v.isObject())
 48622:         return v.toObject().typeOf(cx);
 48470:     JS_ASSERT(v.isBoolean());
 48470:     return JSTYPE_BOOLEAN;
 48470: }
 48470: 
     1: /*
 11672:  * Enter the new with scope using an object at sp[-1] and associate the depth
 11672:  * of the with block with sp + stackIndex.
 11672:  */
 77822: static bool
 91450: EnterWith(JSContext *cx, int stackIndex)
 11672: {
 69223:     StackFrame *fp = cx->fp();
 69223:     Value *sp = cx->regs().sp;
 11672:     JS_ASSERT(stackIndex < 0);
101075:     JS_ASSERT(int(cx->regs().stackDepth()) + stackIndex >= 0);
 48470: 
 99421:     RootedObject obj(cx);
 48470:     if (sp[-1].isObject()) {
 48470:         obj = &sp[-1].toObject();
 11672:     } else {
 11672:         obj = js_ValueToNonNullObject(cx, sp[-1]);
 11672:         if (!obj)
101075:             return false;
 48470:         sp[-1].setObject(*obj);
 48470:     }
 48470: 
101075:     WithObject *withobj = WithObject::create(cx, obj, fp->scopeChain(),
101075:                                              cx->regs().stackDepth() + stackIndex);
 11672:     if (!withobj)
101075:         return false;
101075: 
101075:     fp->pushOnScopeChain(*withobj);
101075:     return true;
     1: }
     1: 
 86484: /* Unwind block and scope chains to match the given depth. */
 86484: void
 86484: js::UnwindScope(JSContext *cx, uint32_t stackDepth)
 77822: {
 69223:     StackFrame *fp = cx->fp();
101075:     JS_ASSERT(stackDepth <= cx->regs().stackDepth());
 98921: 
101995:     for (ScopeIter si(fp, cx); !si.done(); ++si) {
 98921:         switch (si.type()) {
 98921:           case ScopeIter::Block:
 98921:             if (si.staticBlock().stackDepth() < stackDepth)
 98921:                 return;
 98921:             fp->popBlock(cx);
 86077:             break;
 98921:           case ScopeIter::With:
 98921:             if (si.scope().asWith().stackDepth() < stackDepth)
 98921:                 return;
 98921:             fp->popWith(cx);
 11758:             break;
 98921:           case ScopeIter::Call:
 98921:           case ScopeIter::StrictEvalScope:
 98921:             break;
 98921:         }
 11758:     }
 11758: }
 11758: 
 91947: void
 91947: js::UnwindForUncatchableException(JSContext *cx, const FrameRegs &regs)
 91947: {
 91947: 
 91947:     /* c.f. the regular (catchable) TryNoteIter loop in Interpret. */
 91947:     for (TryNoteIter tni(regs); !tni.done(); ++tni) {
 91947:         JSTryNote *tn = *tni;
 91947:         if (tn->kind == JSTRY_ITER) {
101075:             Value *sp = regs.spForStackDepth(tn->stackDepth);
 91947:             UnwindIteratorForUncatchableException(cx, &sp[-1].toObject());
 91947:         }
 91947:     }
 91947: }
 91947: 
 91947: TryNoteIter::TryNoteIter(const FrameRegs &regs)
 91947:   : regs(regs),
 91947:     script(regs.fp()->script()),
 91947:     pcOffset(regs.pc - script->main())
 91947: {
 97361:     if (script->hasTrynotes()) {
 91947:         tn = script->trynotes()->vector;
 91947:         tnEnd = tn + script->trynotes()->length;
 91947:     } else {
 91947:         tn = tnEnd = NULL;
 91947:     }
 91947:     settle();
 91947: }
 91947: 
 91947: void
 91947: TryNoteIter::operator++()
 91947: {
 91947:     ++tn;
 91947:     settle();
 91947: }
 91947: 
 91947: bool
 91947: TryNoteIter::done() const
 91947: {
 91947:     return tn == tnEnd;
 91947: }
 91947: 
 91947: void
 91947: TryNoteIter::settle()
 91947: {
 91947:     for (; tn != tnEnd; ++tn) {
 91947:         /* If pc is out of range, try the next one. */
 91947:         if (pcOffset - tn->start >= tn->length)
 91947:             continue;
 91947: 
 91947:         /*
 91947:          * We have a note that covers the exception pc but we must check
 91947:          * whether the interpreter has already executed the corresponding
 91947:          * handler. This is possible when the executed bytecode implements
 91947:          * break or return from inside a for-in loop.
 91947:          *
 91947:          * In this case the emitter generates additional [enditer] and [gosub]
 91947:          * opcodes to close all outstanding iterators and execute the finally
 91947:          * blocks. If such an [enditer] throws an exception, its pc can still
 91947:          * be inside several nested for-in loops and try-finally statements
 91947:          * even if we have already closed the corresponding iterators and
 91947:          * invoked the finally blocks.
 91947:          *
 91947:          * To address this, we make [enditer] always decrease the stack even
 91947:          * when its implementation throws an exception. Thus already executed
 91947:          * [enditer] and [gosub] opcodes will have try notes with the stack
 91947:          * depth exceeding the current one and this condition is what we use to
 91947:          * filter them out.
 91947:          */
101075:         if (tn->stackDepth <= regs.stackDepth())
 91947:             break;
 91947:     }
 91947: }
 91947: 
 77822: /*
 91691:  * Increment/decrement the value 'v'. The resulting value is stored in *slot.
 91691:  * The result of the expression (taking into account prefix/postfix) is stored
 91691:  * in *expr.
 77822:  */
 77822: static bool
 91691: DoIncDec(JSContext *cx, JSScript *script, jsbytecode *pc, const Value &v, Value *slot, Value *expr)
 12611: {
 91691:     const JSCodeSpec &cs = js_CodeSpec[*pc];
 91691: 
 91691:     if (v.isInt32()) {
 91691:         int32_t i = v.toInt32();
 91691:         if (i > JSVAL_INT_MIN && i < JSVAL_INT_MAX) {
 91691:             int32_t sum = i + (cs.format & JOF_INC ? 1 : -1);
 91691:             *slot = Int32Value(sum);
 91691:             *expr = (cs.format & JOF_POST) ? Int32Value(i) : *slot;
 91691:             return true;
 91691:         }
 91691:     }
 91691: 
 40828:     double d;
101616:     if (!ToNumber(cx, v, &d))
 91691:         return false;
 91691: 
 91691:     double sum = d + (cs.format & JOF_INC ? 1 : -1);
 91691:     *slot = NumberValue(sum);
 91691:     *expr = (cs.format & JOF_POST) ? NumberValue(d) : *slot;
 91691: 
 91691:     TypeScript::MonitorOverflow(cx, script, pc);
 91691:     return true;
 12611: }
 12611: 
 55638: #define PUSH_COPY(v)             do { *regs.sp++ = v; assertSameCompartment(cx, regs.sp[-1]); } while (0)
 76194: #define PUSH_COPY_SKIP_CHECK(v)  *regs.sp++ = v
 48470: #define PUSH_NULL()              regs.sp++->setNull()
 48470: #define PUSH_UNDEFINED()         regs.sp++->setUndefined()
 48470: #define PUSH_BOOLEAN(b)          regs.sp++->setBoolean(b)
 48470: #define PUSH_DOUBLE(d)           regs.sp++->setDouble(d)
 48470: #define PUSH_INT32(i)            regs.sp++->setInt32(i)
 55638: #define PUSH_STRING(s)           do { regs.sp++->setString(s); assertSameCompartment(cx, regs.sp[-1]); } while (0)
 55638: #define PUSH_OBJECT(obj)         do { regs.sp++->setObject(obj); assertSameCompartment(cx, regs.sp[-1]); } while (0)
 55638: #define PUSH_OBJECT_OR_NULL(obj) do { regs.sp++->setObjectOrNull(obj); assertSameCompartment(cx, regs.sp[-1]); } while (0)
 48470: #define PUSH_HOLE()              regs.sp++->setMagic(JS_ARRAY_HOLE)
 48470: #define POP_COPY_TO(v)           v = *--regs.sp
 69223: #define POP_RETURN_VALUE()       regs.fp()->setReturnValue(*--regs.sp)
 48470: 
 82080: #define VALUE_TO_BOOLEAN(cx, vp, b)                                           \
 12551:     JS_BEGIN_MACRO                                                            \
 48470:         vp = &regs.sp[-1];                                                    \
 48470:         if (vp->isNull()) {                                                   \
 48470:             b = false;                                                        \
 48470:         } else if (vp->isBoolean()) {                                         \
 48470:             b = vp->toBoolean();                                              \
 12551:         } else {                                                              \
 48470:             b = !!js_ValueToBoolean(*vp);                                     \
 12551:         }                                                                     \
 12551:     JS_END_MACRO
 12551: 
 82080: #define POP_BOOLEAN(cx, vp, b)   do { VALUE_TO_BOOLEAN(cx, vp, b); regs.sp--; } while(0)
 82080: 
 48470: #define FETCH_OBJECT(cx, n, obj)                                              \
 12551:     JS_BEGIN_MACRO                                                            \
 48470:         Value *vp_ = &regs.sp[n];                                             \
 91560:         obj = ToObject(cx, (vp_));                                            \
 91560:         if (!obj)                                                             \
 91560:             goto error;                                                       \
 12551:     JS_END_MACRO
 12551: 
 12611: /*
     1:  * Threaded interpretation via computed goto appears to be well-supported by
     1:  * GCC 3 and higher.  IBM's C compiler when run with the right options (e.g.,
     1:  * -qlanglvl=extended) also supports threading.  Ditto the SunPro C compiler.
     1:  * Currently it's broken for JS_VERSION < 160, though this isn't worth fixing.
     1:  * Add your compiler support macros here.
     1:  */
     1: #ifndef JS_THREADED_INTERP
     1: # if JS_VERSION >= 160 && (                                                   \
     1:     __GNUC__ >= 3 ||                                                          \
     1:     (__IBMC__ >= 700 && defined __IBM_COMPUTED_GOTO) ||                       \
     1:     __SUNPRO_C >= 0x570)
     1: #  define JS_THREADED_INTERP 1
     1: # else
     1: #  define JS_THREADED_INTERP 0
     1: # endif
     1: #endif
     1: 
 77168: template<typename T>
 77168: class GenericInterruptEnabler : public InterpreterFrames::InterruptEnablerBase {
 77168:   public:
 77168:     GenericInterruptEnabler(T *variable, T value) : variable(variable), value(value) { }
 77168:     void enableInterrupts() const { *variable = value; }
 77168: 
 77168:   private:
 77168:     T *variable;
 77168:     T value;
 77168: };
 77168: 
 77168: inline InterpreterFrames::InterpreterFrames(JSContext *cx, FrameRegs *regs,
 77168:                                             const InterruptEnablerBase &enabler)
 77168:   : context(cx), regs(regs), enabler(enabler)
 77168: {
 88135:     older = cx->runtime->interpreterFrames;
 88135:     cx->runtime->interpreterFrames = this;
 77168: }
 77168: 
 77168: inline InterpreterFrames::~InterpreterFrames()
 77168: {
 88135:     context->runtime->interpreterFrames = older;
 77168: }
 77168: 
 95355: #if defined(DEBUG) && !defined(JS_THREADSAFE) && !defined(JSGC_ROOT_ANALYSIS)
 86855: void
103195: js::AssertValidPropertyCacheHit(JSContext *cx, JSObject *start_,
103195:                                 JSObject *found, PropertyCacheEntry *entry)
 27164: {
 87171:     jsbytecode *pc;
103195:     JSScript *script = cx->stack.currentScript(&pc);
 86855: 
 90410:     uint64_t sample = cx->runtime->gcNumber;
 64357:     PropertyCacheEntry savedEntry = *entry;
 27164: 
103195:     RootedPropertyName name(cx, GetNameFromBytecode(cx, script, pc, JSOp(*pc)));
 99421:     RootedObject start(cx, start_);
 27164: 
 27164:     JSObject *obj, *pobj;
 27164:     JSProperty *prop;
 33166:     JSBool ok;
 27164: 
 87657:     if (JOF_OPMODE(*pc) == JOF_NAME)
 87657:         ok = FindProperty(cx, name, start, &obj, &pobj, &prop);
 87657:     else
 98960:         ok = baseops::LookupProperty(cx, start, name.reference(), &pobj, &prop);
 86855:     JS_ASSERT(ok);
 86855: 
 64296:     if (cx->runtime->gcNumber != sample)
 64357:         JS_PROPERTY_CACHE(cx).restore(&savedEntry);
 27164:     JS_ASSERT(prop);
 27164:     JS_ASSERT(pobj == found);
 27164: 
 52503:     const Shape *shape = (Shape *) prop;
 83221:     JS_ASSERT(entry->prop == shape);
 86855: }
 86855: #endif /* DEBUG && !JS_THREADSAFE */
 27164: 
 27164: /*
     1:  * Ensure that the intrepreter switch can close call-bytecode cases in the
     1:  * same way as non-call bytecodes.
     1:  */
     1: JS_STATIC_ASSERT(JSOP_NAME_LENGTH == JSOP_CALLNAME_LENGTH);
     1: JS_STATIC_ASSERT(JSOP_GETARG_LENGTH == JSOP_CALLARG_LENGTH);
     1: JS_STATIC_ASSERT(JSOP_GETLOCAL_LENGTH == JSOP_CALLLOCAL_LENGTH);
     1: JS_STATIC_ASSERT(JSOP_XMLNAME_LENGTH == JSOP_CALLXMLNAME_LENGTH);
     1: 
 11377: /*
 11377:  * Same for JSOP_SETNAME and JSOP_SETPROP, which differ only slightly but
 94227:  * remain distinct for the decompiler.
 11377:  */
 11377: JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETPROP_LENGTH);
 11377: 
 15464: /* See TRY_BRANCH_AFTER_COND. */
 15464: JS_STATIC_ASSERT(JSOP_IFNE_LENGTH == JSOP_IFEQ_LENGTH);
 15464: JS_STATIC_ASSERT(JSOP_IFNE == JSOP_IFEQ + 1);
 15464: 
 16051: /* For the fastest case inder JSOP_INCNAME, etc. */
 16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_DECNAME_LENGTH);
 16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_NAMEINC_LENGTH);
 16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_NAMEDEC_LENGTH);
 16051: 
 42641: /*
 42641:  * Inline fast paths for iteration. js_IteratorMore and js_IteratorNext handle
 42641:  * all cases, but we inline the most frequently taken paths here.
 42641:  */
 42641: static inline bool
 48470: IteratorMore(JSContext *cx, JSObject *iterobj, bool *cond, Value *rval)
 42641: {
 77817:     if (iterobj->isIterator()) {
 72108:         NativeIterator *ni = iterobj->getNativeIterator();
 61055:         if (ni->isKeyIter()) {
 42641:             *cond = (ni->props_cursor < ni->props_end);
 61055:             return true;
 61055:         }
 61055:     }
102586:     Rooted<JSObject*> iobj(cx, iterobj);
102586:     if (!js_IteratorMore(cx, iobj, rval))
 42641:         return false;
 48470:     *cond = rval->isTrue();
 42641:     return true;
 42641: }
 42641: 
 42641: static inline bool
 48470: IteratorNext(JSContext *cx, JSObject *iterobj, Value *rval)
 42641: {
 77817:     if (iterobj->isIterator()) {
 72108:         NativeIterator *ni = iterobj->getNativeIterator();
 61055:         if (ni->isKeyIter()) {
 60785:             JS_ASSERT(ni->props_cursor < ni->props_end);
 87655:             rval->setString(*ni->current());
 61055:             ni->incCursor();
 42641:             return true;
 42641:         }
 42641:     }
 42641:     return js_IteratorNext(cx, iterobj, rval);
 42641: }
 42641: 
 76194: /*
 76194:  * For bytecodes which push values and then fall through, make sure the
 76194:  * types of the pushed values are consistent with type inference information.
 76194:  */
 76194: static inline void
 76194: TypeCheckNextBytecode(JSContext *cx, JSScript *script, unsigned n, const FrameRegs &regs)
 76194: {
 76194: #ifdef DEBUG
 78413:     if (cx->typeInferenceEnabled() &&
 84195:         n == GetBytecodeLength(regs.pc)) {
 77391:         TypeScript::CheckBytecode(cx, script, regs.pc, regs.sp);
 76194:     }
 76194: #endif
 76194: }
 76194: 
 77822: JS_NEVER_INLINE bool
 77822: js::Interpret(JSContext *cx, StackFrame *entryFrame, InterpMode interpMode)
     1: {
 69855:     JSAutoResolveFlags rf(cx, RESOLVE_INFER);
     1: 
 90410:     gc::MaybeVerifyBarriers(cx, true);
 82130: 
 76194:     JS_ASSERT(!cx->compartment->activeAnalysis);
 76194: 
 77237: #if JS_THREADED_INTERP
 95113: #define CHECK_PCCOUNT_INTERRUPTS() JS_ASSERT_IF(script->hasScriptCounts, jumpTable == interruptJumpTable)
 77237: #else
 95113: #define CHECK_PCCOUNT_INTERRUPTS() JS_ASSERT_IF(script->hasScriptCounts, switchMask == -1)
 77237: #endif
 77237: 
 48470:     /*
 48470:      * Macros for threaded interpreter loop
 48470:      */
     1: #if JS_THREADED_INTERP
 15510:     static void *const normalJumpTable[] = {
     1: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
     1:         JS_EXTENSION &&L_##op,
     1: # include "jsopcode.tbl"
     1: # undef OPDEF
     1:     };
     1: 
 23111:     static void *const interruptJumpTable[] = {
 17408: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format)              \
 23111:         JS_EXTENSION &&interrupt,
 17408: # include "jsopcode.tbl"
 17408: # undef OPDEF
 17408:     };
 23111: 
 23111:     register void * const *jumpTable = normalJumpTable;
     1: 
 77168:     typedef GenericInterruptEnabler<void * const *> InterruptEnabler;
 77168:     InterruptEnabler interruptEnabler(&jumpTable, interruptJumpTable);
 23111: 
 18171: # define DO_OP()            JS_BEGIN_MACRO                                    \
 77237:                                 CHECK_PCCOUNT_INTERRUPTS();                   \
 18161:                                 JS_EXTENSION_(goto *jumpTable[op]);           \
 18161:                             JS_END_MACRO
 15453: # define DO_NEXT_OP(n)      JS_BEGIN_MACRO                                    \
 76194:                                 TypeCheckNextBytecode(cx, script, n, regs);   \
101796:                                 js::gc::MaybeVerifyBarriers(cx);              \
 13168:                                 op = (JSOp) *(regs.pc += (n));                \
 15453:                                 DO_OP();                                      \
 15453:                             JS_END_MACRO
 15453: 
 82645: # define BEGIN_CASE(OP)     L_##OP:
     1: # define END_CASE(OP)       DO_NEXT_OP(OP##_LENGTH);
     1: # define END_VARLEN_CASE    DO_NEXT_OP(len);
 15453: # define ADD_EMPTY_CASE(OP) BEGIN_CASE(OP)                                    \
 15453:                                 JS_ASSERT(js_CodeSpec[OP].length == 1);       \
 15453:                                 op = (JSOp) *++regs.pc;                       \
 15453:                                 DO_OP();
 15453: 
 15453: # define END_EMPTY_CASES
 15453: 
 15453: #else /* !JS_THREADED_INTERP */
 15453: 
 91237:     register int switchMask = 0;
 91237:     int switchOp;
 91237:     typedef GenericInterruptEnabler<int> InterruptEnabler;
 77168:     InterruptEnabler interruptEnabler(&switchMask, -1);
 23111: 
     1: # define DO_OP()            goto do_op
 15453: # define DO_NEXT_OP(n)      JS_BEGIN_MACRO                                    \
 15453:                                 JS_ASSERT((n) == len);                        \
 15453:                                 goto advance_pc;                              \
 15453:                             JS_END_MACRO
 15453: 
 82645: # define BEGIN_CASE(OP)     case OP:
 15453: # define END_CASE(OP)       END_CASE_LEN(OP##_LENGTH)
 15453: # define END_CASE_LEN(n)    END_CASE_LENX(n)
 15453: # define END_CASE_LENX(n)   END_CASE_LEN##n
 15453: 
 15453: /*
 15453:  * To share the code for all len == 1 cases we use the specialized label with
 15453:  * code that falls through to advance_pc: .
 15453:  */
 15453: # define END_CASE_LEN1      goto advance_pc_by_one;
 15453: # define END_CASE_LEN2      len = 2; goto advance_pc;
 15453: # define END_CASE_LEN3      len = 3; goto advance_pc;
 15453: # define END_CASE_LEN4      len = 4; goto advance_pc;
 15453: # define END_CASE_LEN5      len = 5; goto advance_pc;
 90965: # define END_CASE_LEN6      len = 6; goto advance_pc;
 89253: # define END_CASE_LEN7      len = 7; goto advance_pc;
 95101: # define END_CASE_LEN8      len = 8; goto advance_pc;
 95101: # define END_CASE_LEN9      len = 9; goto advance_pc;
 95101: # define END_CASE_LEN10     len = 10; goto advance_pc;
101073: # define END_CASE_LEN11     len = 11; goto advance_pc;
101073: # define END_CASE_LEN12     len = 12; goto advance_pc;
 15453: # define END_VARLEN_CASE    goto advance_pc;
 15453: # define ADD_EMPTY_CASE(OP) BEGIN_CASE(OP)
 15453: # define END_EMPTY_CASES    goto advance_pc_by_one;
 15453: 
 18617: #endif /* !JS_THREADED_INTERP */
 18617: 
 77168: #define ENABLE_INTERRUPTS() (interruptEnabler.enableInterrupts())
 77168: 
 48470: #define LOAD_ATOM(PCOFF, atom)                                                \
  3235:     JS_BEGIN_MACRO                                                            \
 82642:         JS_ASSERT((size_t)(atoms - script->atoms) <                           \
 90965:                   (size_t)(script->natoms - GET_UINT32_INDEX(regs.pc + PCOFF)));\
 90965:         atom = atoms[GET_UINT32_INDEX(regs.pc + PCOFF)];                      \
  3235:     JS_END_MACRO
  3235: 
 86542: #define LOAD_NAME(PCOFF, name)                                                \
 86542:     JS_BEGIN_MACRO                                                            \
 86542:         JSAtom *atom;                                                         \
 86542:         LOAD_ATOM((PCOFF), atom);                                             \
 86542:         name = atom->asPropertyName();                                        \
 86542:     JS_END_MACRO
 86542: 
 48470: #define LOAD_DOUBLE(PCOFF, dbl)                                               \
 90965:     (dbl = script->getConst(GET_UINT32_INDEX(regs.pc + (PCOFF))).toDouble())
 48470: 
 82644: #if defined(JS_METHODJIT)
 63095:     bool useMethodJIT = false;
 70312: #endif
 63095: 
 62777: #ifdef JS_METHODJIT
 63095: 
 63095: #define RESET_USE_METHODJIT()                                                 \
 63095:     JS_BEGIN_MACRO                                                            \
 63095:         useMethodJIT = cx->methodJitEnabled &&                                \
 76194:            (interpMode == JSINTERP_NORMAL ||                                  \
 76194:             interpMode == JSINTERP_REJOIN ||                                  \
 76194:             interpMode == JSINTERP_SKIP_TRAP);                                \
 63095:     JS_END_MACRO
 62574: 
 77341: #define CHECK_PARTIAL_METHODJIT(status)                                       \
 77341:     JS_BEGIN_MACRO                                                            \
 84195:         switch (status) {                                                     \
 84195:           case mjit::Jaeger_UnfinishedAtTrap:                                 \
 84195:             interpMode = JSINTERP_SKIP_TRAP;                                  \
 84195:             /* FALLTHROUGH */                                                 \
 84195:           case mjit::Jaeger_Unfinished:                                       \
 77341:             op = (JSOp) *regs.pc;                                             \
 77421:             RESTORE_INTERP_VARS_CHECK_EXCEPTION();                            \
 77341:             DO_OP();                                                          \
 84195:           default:;                                                           \
 77341:         }                                                                     \
 77341:     JS_END_MACRO
 77341: 
 62574: #else
 62574: 
 63095: #define RESET_USE_METHODJIT() ((void) 0)
 63095: 
 62574: #endif
 62574: 
 33564: #define RESTORE_INTERP_VARS()                                                 \
 17410:     JS_BEGIN_MACRO                                                            \
 77171:         SET_SCRIPT(regs.fp()->script());                                      \
 69223:         atoms = FrameAtomBase(cx, regs.fp());                                 \
 69223:         JS_ASSERT(&cx->regs() == &regs);                                      \
 77421:     JS_END_MACRO
 77421: 
 77421: #define RESTORE_INTERP_VARS_CHECK_EXCEPTION()                                 \
 77421:     JS_BEGIN_MACRO                                                            \
 77421:         RESTORE_INTERP_VARS();                                                \
 60211:         if (cx->isExceptionPending())                                         \
 48470:             goto error;                                                       \
 77171:         CHECK_INTERRUPT_HANDLER();                                            \
 33564:     JS_END_MACRO
 33564: 
     1:     /*
 11758:      * Prepare to call a user-supplied branch handler, and abort the script
 11758:      * if it returns false.
 11758:      */
 17410: #define CHECK_BRANCH()                                                        \
  3235:     JS_BEGIN_MACRO                                                            \
 88135:         if (cx->runtime->interrupt && !js_HandleExecutionInterrupt(cx))       \
 11859:             goto error;                                                       \
  3235:     JS_END_MACRO
 23442: 
 17410: #define BRANCH(n)                                                             \
 17410:     JS_BEGIN_MACRO                                                            \
 25627:         regs.pc += (n);                                                       \
 25627:         op = (JSOp) *regs.pc;                                                 \
 77465:         if ((n) <= 0)                                                         \
 77465:             goto check_backedge;                                              \
 17611:         DO_OP();                                                              \
 17410:     JS_END_MACRO
 16072: 
 77171: #define SET_SCRIPT(s)                                                         \
 77171:     JS_BEGIN_MACRO                                                            \
 77171:         script = (s);                                                         \
 84195:         if (script->hasAnyBreakpointsOrStepMode())                            \
 77171:             ENABLE_INTERRUPTS();                                              \
 95113:         if (script->hasScriptCounts)                                          \
 82134:             ENABLE_INTERRUPTS();                                              \
 84195:         JS_ASSERT_IF(interpMode == JSINTERP_SKIP_TRAP,                        \
 84195:                      script->hasAnyBreakpointsOrStepMode());                  \
 77171:     JS_END_MACRO
 77171: 
 53840: #define CHECK_INTERRUPT_HANDLER()                                             \
 53840:     JS_BEGIN_MACRO                                                            \
 91178:         if (cx->runtime->debugHooks.interruptHook)                            \
 53840:             ENABLE_INTERRUPTS();                                              \
 53840:     JS_END_MACRO
 53840: 
 76194:     /* Repoint cx->regs to a local variable for faster access. */
 69223:     FrameRegs regs = cx->regs();
 76194:     PreserveRegsGuard interpGuard(cx, regs);
 56201: 
 77168:     /*
 77168:      * Help Debugger find frames running scripts that it has put in
 77168:      * single-step mode.
 77168:      */
 77168:     InterpreterFrames interpreterFrame(cx, &regs, interruptEnabler);
 77168: 
 53840:     /* Copy in hot values that change infrequently. */
 53840:     JSRuntime *const rt = cx->runtime;
 99421:     Rooted<JSScript*> script(cx);
 77171:     SET_SCRIPT(regs.fp()->script());
 53840:     CHECK_INTERRUPT_HANDLER();
 53840: 
 95355:     /*
 95355:      * Pool of rooters for use in this interpreter frame. References to these
 95355:      * are used for local variables within interpreter cases. This avoids
 95355:      * creating new rooters each time an interpreter case is entered, and also
 95355:      * correctness pitfalls due to incorrect compilation of destructor calls
 95355:      * around computed gotos.
 95355:      */
 99421:     RootedValue rootValue0(cx), rootValue1(cx);
 99421:     RootedString rootString0(cx), rootString1(cx);
 99421:     RootedObject rootObject0(cx), rootObject1(cx);
 99421:     RootedFunction rootFunction0(cx);
 99421:     RootedTypeObject rootType0(cx);
 99421:     RootedPropertyName rootName0(cx);
 99421:     RootedId rootId0(cx);
 95355: 
 84803:     if (rt->profilingScripts)
 84803:         ENABLE_INTERRUPTS();
 84803: 
 53840:     if (!entryFrame)
 69223:         entryFrame = regs.fp();
 18308: 
 53631:     /*
 53840:      * Initialize the index segment register used by LOAD_ATOM and
 53840:      * GET_FULL_INDEX macros below. As a register we use a pointer based on
 53840:      * the atom map to turn frequently executed LOAD_ATOM into simple array
 87976:      * access. For less frequent object loads we have to recover the segment
 87976:      * from atoms pointer first.
     1:      */
 94934:     HeapPtrAtom *atoms = script->atoms;
 42717: 
 20908: #if JS_HAS_GENERATORS
 69223:     if (JS_UNLIKELY(regs.fp()->isGeneratorFrame())) {
101075:         JS_ASSERT(size_t(regs.pc - script->code) <= script->length);
101075:         JS_ASSERT(regs.stackDepth() <= script->nslots);
     1: 
     1:         /*
 11758:          * To support generator_throw and to catch ignored exceptions,
 60211:          * fail if cx->isExceptionPending() is true.
     1:          */
 60211:         if (cx->isExceptionPending())
 53557:             goto error;
     1:     }
 42717: #endif
     1: 
 84070:     /* State communicated between non-local jumps: */
 91435:     bool interpReturnOK;
 84070: 
 56201:     /* Don't call the script prologue if executing between Method and Trace JIT. */
 56201:     if (interpMode == JSINTERP_NORMAL) {
 76194:         StackFrame *fp = regs.fp();
101075:         if (!fp->isGeneratorFrame() && !fp->prologue(cx, UseNewTypeAtEntry(cx, fp)))
 76194:             goto error;
 84070:         if (cx->compartment->debugMode()) {
 84070:             JSTrapStatus status = ScriptDebugPrologue(cx, fp);
 84070:             switch (status) {
 84070:               case JSTRAP_CONTINUE:
 84070:                 break;
 84070:               case JSTRAP_RETURN:
 91435:                 interpReturnOK = true;
 84070:                 goto forced_return;
 84070:               case JSTRAP_THROW:
 84070:               case JSTRAP_ERROR:
 84070:                 goto error;
 84070:               default:
 84070:                 JS_NOT_REACHED("bad ScriptDebugPrologue status");
 84070:             }
 84070:         }
 76194:     }
 76194: 
 76194:     /* The REJOIN mode acts like the normal mode, except the prologue is skipped. */
 76194:     if (interpMode == JSINTERP_REJOIN)
 76194:         interpMode = JSINTERP_NORMAL;
 76194: 
 56201:     CHECK_INTERRUPT_HANDLER();
 56201: 
 63095:     RESET_USE_METHODJIT();
 63095: 
 15453:     /*
 15453:      * It is important that "op" be initialized before calling DO_OP because
 15453:      * it is possible for "op" to be specially assigned during the normal
 15453:      * processing of an opcode while looping. We rely on DO_NEXT_OP to manage
 15453:      * "op" correctly in all other cases.
 15453:      */
 48470:     JSOp op;
 91450:     int32_t len;
 15453:     len = 0;
 60214: 
 15453:     DO_NEXT_OP(len);
 15453: 
     1: #if JS_THREADED_INTERP
     1:     /*
     1:      * This is a loop, but it does not look like a loop. The loop-closing
 15453:      * jump is distributed throughout goto *jumpTable[op] inside of DO_OP.
 15453:      * When interrupts are enabled, jumpTable is set to interruptJumpTable
 23111:      * where all jumps point to the interrupt label. The latter, after
 15453:      * calling the interrupt handler, dispatches through normalJumpTable to
 15453:      * continue the normal bytecode processing.
 15453:      */
 31481: 
 23111: #else /* !JS_THREADED_INTERP */
 15453:     for (;;) {
 15453:       advance_pc_by_one:
 15453:         JS_ASSERT(js_CodeSpec[op].length == 1);
 15453:         len = 1;
 15453:       advance_pc:
 15453:         regs.pc += len;
 13168:         op = (JSOp) *regs.pc;
 15453: 
 15453:       do_op:
 77237:         CHECK_PCCOUNT_INTERRUPTS();
 90410:         js::gc::MaybeVerifyBarriers(cx);
 91237:         switchOp = int(op) | switchMask;
 15453:       do_switch:
 15453:         switch (switchOp) {
 27490: #endif
 31481: 
 48470: #if JS_THREADED_INTERP
 48470:   interrupt:
 48470: #else /* !JS_THREADED_INTERP */
 48470:   case -1:
 48470:     JS_ASSERT(switchMask == -1);
 48470: #endif /* !JS_THREADED_INTERP */
 48470:     {
 48470:         bool moreInterrupts = false;
 77237: 
 84803:         if (cx->runtime->profilingScripts) {
 95113:             if (!script->hasScriptCounts)
 94574:                 script->initScriptCounts(cx);
 84803:             moreInterrupts = true;
 84803:         }
 84803: 
 95113:         if (script->hasScriptCounts) {
 94574:             PCCounts counts = script->getPCCounts(regs.pc);
 94574:             counts.get(PCCounts::BASE_INTERP)++;
 77237:             moreInterrupts = true;
 77237:         }
 77237: 
 91178:         JSInterruptHook hook = cx->runtime->debugHooks.interruptHook;
 77171:         if (hook || script->stepModeEnabled()) {
 48470:             Value rval;
 77171:             JSTrapStatus status = JSTRAP_CONTINUE;
 78614:             if (hook)
 91178:                 status = hook(cx, script, regs.pc, &rval, cx->runtime->debugHooks.interruptHookData);
 77171:             if (status == JSTRAP_CONTINUE && script->stepModeEnabled())
 77171:                 status = Debugger::onSingleStep(cx, &rval);
 77171:             switch (status) {
 48470:               case JSTRAP_ERROR:
 48470:                 goto error;
 48470:               case JSTRAP_CONTINUE:
 48470:                 break;
 48470:               case JSTRAP_RETURN:
 69223:                 regs.fp()->setReturnValue(rval);
 91435:                 interpReturnOK = true;
 48470:                 goto forced_return;
 48470:               case JSTRAP_THROW:
 60211:                 cx->setPendingException(rval);
 48470:                 goto error;
 48470:               default:;
 48470:             }
 48470:             moreInterrupts = true;
 48470:         }
 48470: 
 84195:         if (script->hasAnyBreakpointsOrStepMode())
 84195:             moreInterrupts = true;
 84195: 
 84195:         if (script->hasBreakpointsAt(regs.pc) && interpMode != JSINTERP_SKIP_TRAP) {
 84195:             Value rval;
 84195:             JSTrapStatus status = Debugger::onTrap(cx, &rval);
 84195:             switch (status) {
 84195:               case JSTRAP_ERROR:
 84195:                 goto error;
 84195:               case JSTRAP_RETURN:
 84195:                 regs.fp()->setReturnValue(rval);
 91435:                 interpReturnOK = true;
 84195:                 goto forced_return;
 84195:               case JSTRAP_THROW:
 84195:                 cx->setPendingException(rval);
 84195:                 goto error;
 84195:               default:
 84195:                 break;
 84195:             }
 84195:             JS_ASSERT(status == JSTRAP_CONTINUE);
 84195:             CHECK_INTERRUPT_HANDLER();
 84195:             JS_ASSERT(rval.isInt32() && rval.toInt32() == op);
 84195:         }
 84195: 
 84195:         interpMode = JSINTERP_NORMAL;
 84195: 
 48470: #if JS_THREADED_INTERP
 48470:         jumpTable = moreInterrupts ? interruptJumpTable : normalJumpTable;
 48470:         JS_EXTENSION_(goto *normalJumpTable[op]);
 48470: #else
 48470:         switchMask = moreInterrupts ? -1 : 0;
 91237:         switchOp = int(op);
 48470:         goto do_switch;
 48470: #endif
 48470:     }
 48470: 
 48470: /* No-ops for ease of decompilation. */
 48470: ADD_EMPTY_CASE(JSOP_NOP)
 86580: ADD_EMPTY_CASE(JSOP_UNUSED1)
 86580: ADD_EMPTY_CASE(JSOP_UNUSED2)
 86877: ADD_EMPTY_CASE(JSOP_UNUSED3)
 86877: ADD_EMPTY_CASE(JSOP_UNUSED8)
 86877: ADD_EMPTY_CASE(JSOP_UNUSED9)
 86877: ADD_EMPTY_CASE(JSOP_UNUSED10)
 86877: ADD_EMPTY_CASE(JSOP_UNUSED11)
 86877: ADD_EMPTY_CASE(JSOP_UNUSED12)
 86877: ADD_EMPTY_CASE(JSOP_UNUSED13)
 88137: ADD_EMPTY_CASE(JSOP_UNUSED15)
 89818: ADD_EMPTY_CASE(JSOP_UNUSED17)
 90965: ADD_EMPTY_CASE(JSOP_UNUSED18)
 90965: ADD_EMPTY_CASE(JSOP_UNUSED19)
 90965: ADD_EMPTY_CASE(JSOP_UNUSED20)
 90965: ADD_EMPTY_CASE(JSOP_UNUSED21)
 90965: ADD_EMPTY_CASE(JSOP_UNUSED22)
 90965: ADD_EMPTY_CASE(JSOP_UNUSED23)
 93245: ADD_EMPTY_CASE(JSOP_UNUSED24)
 93245: ADD_EMPTY_CASE(JSOP_UNUSED25)
 94227: ADD_EMPTY_CASE(JSOP_UNUSED29)
 94227: ADD_EMPTY_CASE(JSOP_UNUSED30)
 94278: ADD_EMPTY_CASE(JSOP_UNUSED31)
 48470: ADD_EMPTY_CASE(JSOP_CONDSWITCH)
 48470: ADD_EMPTY_CASE(JSOP_TRY)
 48470: #if JS_HAS_XML_SUPPORT
 48470: ADD_EMPTY_CASE(JSOP_STARTXML)
 48470: ADD_EMPTY_CASE(JSOP_STARTXMLEXPR)
 48470: #endif
 83115: ADD_EMPTY_CASE(JSOP_LOOPHEAD)
 87961: ADD_EMPTY_CASE(JSOP_LOOPENTRY)
 48470: END_EMPTY_CASES
 48470: 
 82079: BEGIN_CASE(JSOP_LABEL)
 82079: END_CASE(JSOP_LABEL)
 82079: 
 77465: check_backedge:
 77465: {
 77465:     CHECK_BRANCH();
 83115:     if (op != JSOP_LOOPHEAD)
 77465:         DO_OP();
 77465: 
 77465: #ifdef JS_METHODJIT
 77468:     if (!useMethodJIT)
 77468:         DO_OP();
 77465:     mjit::CompileStatus status =
 87654:         mjit::CanMethodJIT(cx, script, regs.pc, regs.fp()->isConstructing(),
 87654:                            mjit::CompileRequest_Interpreter);
 77465:     if (status == mjit::Compile_Error)
 77465:         goto error;
 77465:     if (status == mjit::Compile_Okay) {
 77465:         void *ncode =
 77465:             script->nativeCodeForPC(regs.fp()->isConstructing(), regs.pc);
 87654:         JS_ASSERT(ncode);
 93359:         mjit::JaegerStatus status = mjit::JaegerShotAtSafePoint(cx, ncode, true);
 93359:         if (status == mjit::Jaeger_ThrowBeforeEnter)
 93359:             goto error;
 77465:         CHECK_PARTIAL_METHODJIT(status);
 77465:         interpReturnOK = (status == mjit::Jaeger_Returned);
 77465:         if (entryFrame != regs.fp())
 77465:             goto jit_return;
 77465:         regs.fp()->setFinishedInInterpreter();
 77465:         goto leave_on_safe_point;
 77465:     }
 77465:     if (status == mjit::Compile_Abort)
 77465:         useMethodJIT = false;
 77465: #endif /* JS_METHODJIT */
 77465: 
 77465:     DO_OP();
 77465: }
 77465: 
 48470: /* ADD_EMPTY_CASE is not used here as JSOP_LINENO_LENGTH == 3. */
 48470: BEGIN_CASE(JSOP_LINENO)
 54840: END_CASE(JSOP_LINENO)
 48470: 
 84493: BEGIN_CASE(JSOP_UNDEFINED)
 48470:     PUSH_UNDEFINED();
 84493: END_CASE(JSOP_UNDEFINED)
 48470: 
 48470: BEGIN_CASE(JSOP_POP)
 48470:     regs.sp--;
 48470: END_CASE(JSOP_POP)
 48470: 
 48470: BEGIN_CASE(JSOP_POPN)
101075:     JS_ASSERT(GET_UINT16(regs.pc) <= regs.stackDepth());
 48470:     regs.sp -= GET_UINT16(regs.pc);
 48470: #ifdef DEBUG
101075:     if (StaticBlockObject *block = regs.fp()->maybeBlockChain())
101075:         JS_ASSERT(regs.stackDepth() >= block->stackDepth() + block->slotCount());
 48470: #endif
 48470: END_CASE(JSOP_POPN)
 48470: 
 48470: BEGIN_CASE(JSOP_SETRVAL)
 48470: BEGIN_CASE(JSOP_POPV)
 51056:     POP_RETURN_VALUE();
 48470: END_CASE(JSOP_POPV)
 48470: 
 48470: BEGIN_CASE(JSOP_ENTERWITH)
 86077:     if (!EnterWith(cx, -1))
 48470:         goto error;
 48470: 
 48470:     /*
 48470:      * We must ensure that different "with" blocks have different stack depth
 48470:      * associated with them. This allows the try handler search to properly
 48470:      * recover the scope chain. Thus we must keep the stack at least at the
 48470:      * current level.
 48470:      *
 48470:      * We set sp[-1] to the current "with" object to help asserting the
 48470:      * enter/leave balance in [leavewith].
 48470:      */
 96793:     regs.sp[-1].setObject(*regs.fp()->scopeChain());
 48470: END_CASE(JSOP_ENTERWITH)
 48470: 
 48470: BEGIN_CASE(JSOP_LEAVEWITH)
 96793:     JS_ASSERT(regs.sp[-1].toObject() == *regs.fp()->scopeChain());
 98921:     regs.fp()->popWith(cx);
 48470:     regs.sp--;
 48470: END_CASE(JSOP_LEAVEWITH)
 48470: 
 48470: BEGIN_CASE(JSOP_RETURN)
 51056:     POP_RETURN_VALUE();
 48470:     /* FALL THROUGH */
 48470: 
 51056: BEGIN_CASE(JSOP_RETRVAL)    /* fp return value already set */
 48470: BEGIN_CASE(JSOP_STOP)
 48470: {
 48470:     /*
 48470:      * When the inlined frame exits with an exception or an error, ok will be
 48470:      * false after the inline_return label.
 48470:      */
 48470:     CHECK_BRANCH();
 48470: 
 48470:     interpReturnOK = true;
 69223:     if (entryFrame != regs.fp())
 48470:   inline_return:
 48470:     {
 84067:         if (cx->compartment->debugMode())
 84067:             interpReturnOK = ScriptDebugEpilogue(cx, regs.fp(), interpReturnOK);
 84067: 
101075:         if (!regs.fp()->isYielding())
101075:             regs.fp()->epilogue(cx);
101075: 
101075:         /* The JIT inlines the epilogue. */
 64330: #ifdef JS_METHODJIT
 56201:   jit_return:
 64330: #endif
 77341: 
 77341:         /* The results of lowered call/apply frames need to be shifted. */
 77341:         bool shiftResult = regs.fp()->loweredCallOrApply();
 77341: 
 71697:         cx->stack.popInlineFrame(regs);
 69223: 
 77341:         RESTORE_INTERP_VARS();
 48470: 
 84195:         JS_ASSERT(*regs.pc == JSOP_NEW || *regs.pc == JSOP_CALL ||
 74915:                   *regs.pc == JSOP_FUNCALL || *regs.pc == JSOP_FUNAPPLY);
 74915: 
 48470:         /* Resume execution in the calling frame. */
 63095:         RESET_USE_METHODJIT();
 48470:         if (JS_LIKELY(interpReturnOK)) {
 77391:             TypeScript::Monitor(cx, script, regs.pc, regs.sp[-1]);
 77341: 
 77341:             if (shiftResult) {
 77341:                 regs.sp[-2] = regs.sp[-1];
 77341:                 regs.sp--;
 77341:             }
 77341: 
 84950:             len = JSOP_CALL_LENGTH;
 51682:             DO_NEXT_OP(len);
 51682:         }
 74915: 
 74915:         /* Increment pc so that |sp - fp->slots == ReconstructStackDepth(pc)|. */
 74915:         regs.pc += JSOP_CALL_LENGTH;
 51682:         goto error;
 48470:     } else {
101075:         JS_ASSERT(regs.stackDepth() == 0);
 48470:     }
 48470:     interpReturnOK = true;
 48470:     goto exit;
 48470: }
 48470: 
 48470: BEGIN_CASE(JSOP_DEFAULT)
 48470:     regs.sp--;
 48470:     /* FALL THROUGH */
 48470: BEGIN_CASE(JSOP_GOTO)
 48470: {
 48470:     len = GET_JUMP_OFFSET(regs.pc);
 48470:     BRANCH(len);
 48470: }
 48470: END_CASE(JSOP_GOTO)
 48470: 
 48470: BEGIN_CASE(JSOP_IFEQ)
 48470: {
 48470:     bool cond;
 48470:     Value *_;
 48470:     POP_BOOLEAN(cx, _, cond);
 48470:     if (cond == false) {
 48470:         len = GET_JUMP_OFFSET(regs.pc);
 48470:         BRANCH(len);
 48470:     }
 48470: }
 48470: END_CASE(JSOP_IFEQ)
 48470: 
 48470: BEGIN_CASE(JSOP_IFNE)
 48470: {
 48470:     bool cond;
 48470:     Value *_;
 48470:     POP_BOOLEAN(cx, _, cond);
 48470:     if (cond != false) {
 48470:         len = GET_JUMP_OFFSET(regs.pc);
 48470:         BRANCH(len);
 48470:     }
 48470: }
 48470: END_CASE(JSOP_IFNE)
 48470: 
 48470: BEGIN_CASE(JSOP_OR)
 48470: {
 48470:     bool cond;
 82080:     Value *_;
 82080:     VALUE_TO_BOOLEAN(cx, _, cond);
 48470:     if (cond == true) {
 48470:         len = GET_JUMP_OFFSET(regs.pc);
 48470:         DO_NEXT_OP(len);
 48470:     }
 48470: }
 48470: END_CASE(JSOP_OR)
 48470: 
 48470: BEGIN_CASE(JSOP_AND)
 48470: {
 48470:     bool cond;
 82080:     Value *_;
 82080:     VALUE_TO_BOOLEAN(cx, _, cond);
 48470:     if (cond == false) {
 48470:         len = GET_JUMP_OFFSET(regs.pc);
 48470:         DO_NEXT_OP(len);
 48470:     }
 48470: }
 48470: END_CASE(JSOP_AND)
 48470: 
 48470: /*
 48470:  * If the index value at sp[n] is not an int that fits in a jsval, it could
 48470:  * be an object (an XML QName, AttributeName, or AnyName), but only if we are
 48470:  * compiling with JS_HAS_XML_SUPPORT.  Otherwise convert the index value to a
 48470:  * string atom id.
 48470:  */
 48470: #define FETCH_ELEMENT_ID(obj, n, id)                                          \
 48470:     JS_BEGIN_MACRO                                                            \
 48470:         const Value &idval_ = regs.sp[n];                                     \
 98960:         if (!ValueToId(cx, obj, idval_, id.address()))                        \
 48470:             goto error;                                                       \
 48470:     JS_END_MACRO
 48470: 
 48470: #define TRY_BRANCH_AFTER_COND(cond,spdec)                                     \
 48470:     JS_BEGIN_MACRO                                                            \
 48470:         JS_ASSERT(js_CodeSpec[op].length == 1);                               \
 91237:         unsigned diff_ = (unsigned) GET_UINT8(regs.pc) - (unsigned) JSOP_IFEQ;         \
 48470:         if (diff_ <= 1) {                                                     \
 48470:             regs.sp -= spdec;                                                 \
 48470:             if (cond == (diff_ != 0)) {                                       \
 48470:                 ++regs.pc;                                                    \
 48470:                 len = GET_JUMP_OFFSET(regs.pc);                               \
 48470:                 BRANCH(len);                                                  \
 48470:             }                                                                 \
 48470:             len = 1 + JSOP_IFEQ_LENGTH;                                       \
 48470:             DO_NEXT_OP(len);                                                  \
 48470:         }                                                                     \
 48470:     JS_END_MACRO
 48470: 
 48470: BEGIN_CASE(JSOP_IN)
 48470: {
 48470:     const Value &rref = regs.sp[-1];
 48470:     if (!rref.isObject()) {
 48470:         js_ReportValueError(cx, JSMSG_IN_NOT_OBJECT, -1, rref, NULL);
 48470:         goto error;
 48470:     }
 99421:     RootedObject &obj = rootObject0;
 97353:     obj = &rref.toObject();
 99421:     RootedId &id = rootId0;
 48470:     FETCH_ELEMENT_ID(obj, -2, id);
 48470:     JSObject *obj2;
 48470:     JSProperty *prop;
 80442:     if (!obj->lookupGeneric(cx, id, &obj2, &prop))
 48470:         goto error;
 48470:     bool cond = prop != NULL;
 48470:     TRY_BRANCH_AFTER_COND(cond, 2);
 48470:     regs.sp--;
 48470:     regs.sp[-1].setBoolean(cond);
 48470: }
 48470: END_CASE(JSOP_IN)
 48470: 
 48470: BEGIN_CASE(JSOP_ITER)
 48470: {
101075:     JS_ASSERT(regs.stackDepth() >= 1);
 87974:     uint8_t flags = GET_UINT8(regs.pc);
 91160:     if (!ValueToIterator(cx, flags, &regs.sp[-1]))
 48470:         goto error;
 48470:     CHECK_INTERRUPT_HANDLER();
 48470:     JS_ASSERT(!regs.sp[-1].isPrimitive());
 48470: }
 48470: END_CASE(JSOP_ITER)
 48470: 
 48470: BEGIN_CASE(JSOP_MOREITER)
 48470: {
101075:     JS_ASSERT(regs.stackDepth() >= 1);
 48470:     JS_ASSERT(regs.sp[-1].isObject());
 48470:     PUSH_NULL();
 48470:     bool cond;
 48470:     if (!IteratorMore(cx, &regs.sp[-2].toObject(), &cond, &regs.sp[-1]))
 48470:         goto error;
 48470:     CHECK_INTERRUPT_HANDLER();
 48470:     regs.sp[-1].setBoolean(cond);
 48470: }
 48470: END_CASE(JSOP_MOREITER)
 48470: 
 74052: BEGIN_CASE(JSOP_ITERNEXT)
 74052: {
101075:     JS_ASSERT(regs.stackDepth() >= unsigned(GET_INT8(regs.pc)));
 77824:     Value *itervp = regs.sp - GET_INT8(regs.pc);
 77824:     JS_ASSERT(itervp->isObject());
 74052:     PUSH_NULL();
 77824:     if (!IteratorNext(cx, &itervp->toObject(), &regs.sp[-1]))
 74052:         goto error;
 74052: }
 74052: END_CASE(JSOP_ITERNEXT)
 74052: 
 48470: BEGIN_CASE(JSOP_ENDITER)
 48470: {
101075:     JS_ASSERT(regs.stackDepth() >= 1);
 91160:     bool ok = CloseIterator(cx, &regs.sp[-1].toObject());
 48470:     regs.sp--;
 48470:     if (!ok)
 48470:         goto error;
 48470: }
 48470: END_CASE(JSOP_ENDITER)
 48470: 
 48470: BEGIN_CASE(JSOP_DUP)
 48470: {
101075:     JS_ASSERT(regs.stackDepth() >= 1);
 48470:     const Value &rref = regs.sp[-1];
 48470:     PUSH_COPY(rref);
 48470: }
 48470: END_CASE(JSOP_DUP)
 48470: 
 48470: BEGIN_CASE(JSOP_DUP2)
 48470: {
101075:     JS_ASSERT(regs.stackDepth() >= 2);
 48470:     const Value &lref = regs.sp[-2];
 48470:     const Value &rref = regs.sp[-1];
 48470:     PUSH_COPY(lref);
 48470:     PUSH_COPY(rref);
 48470: }
 48470: END_CASE(JSOP_DUP2)
 48470: 
 48470: BEGIN_CASE(JSOP_SWAP)
 48470: {
101075:     JS_ASSERT(regs.stackDepth() >= 2);
 48470:     Value &lref = regs.sp[-2];
 48470:     Value &rref = regs.sp[-1];
 48470:     lref.swap(rref);
 48470: }
 48470: END_CASE(JSOP_SWAP)
 48470: 
 48470: BEGIN_CASE(JSOP_PICK)
 48470: {
 87974:     unsigned i = GET_UINT8(regs.pc);
101075:     JS_ASSERT(regs.stackDepth() >= i + 1);
 87974:     Value lval = regs.sp[-int(i + 1)];
 48470:     memmove(regs.sp - (i + 1), regs.sp - i, sizeof(Value) * i);
 48470:     regs.sp[-1] = lval;
 48470: }
 48470: END_CASE(JSOP_PICK)
 48470: 
 48470: BEGIN_CASE(JSOP_SETCONST)
 48470: {
 86542:     PropertyName *name;
 86542:     LOAD_NAME(0, name);
 71694:     JSObject &obj = regs.fp()->varObj();
 48470:     const Value &ref = regs.sp[-1];
 86542:     if (!obj.defineProperty(cx, name, ref,
 78614:                             JS_PropertyStub, JS_StrictPropertyStub,
 48470:                             JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY)) {
 48470:         goto error;
 48470:     }
 48470: }
 82827: END_CASE(JSOP_SETCONST);
 48470: 
 48470: #if JS_HAS_DESTRUCTURING
 48470: BEGIN_CASE(JSOP_ENUMCONSTELEM)
 48470: {
 48470:     const Value &ref = regs.sp[-3];
 48470:     JSObject *obj;
 48470:     FETCH_OBJECT(cx, -2, obj);
 99421:     RootedId &id = rootId0;
 48470:     FETCH_ELEMENT_ID(obj, -1, id);
 80624:     if (!obj->defineGeneric(cx, id, ref,
 78614:                             JS_PropertyStub, JS_StrictPropertyStub,
 48470:                             JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY)) {
 48470:         goto error;
 48470:     }
 48470:     regs.sp -= 3;
 48470: }
 48470: END_CASE(JSOP_ENUMCONSTELEM)
 48470: #endif
 48470: 
 53092: BEGIN_CASE(JSOP_BINDGNAME)
 96793:     PUSH_OBJECT(regs.fp()->global());
 53092: END_CASE(JSOP_BINDGNAME)
 53092: 
 48470: BEGIN_CASE(JSOP_BINDNAME)
 48470: {
 48470:     JSObject *obj;
 48470:     do {
 48470:         /*
 48470:          * We can skip the property lookup for the global object. If the
 48470:          * property does not exist anywhere on the scope chain, JSOP_SETNAME
 48470:          * adds the property to the global.
 48470:          *
 48470:          * As a consequence of this optimization for the global object we run
 48470:          * its JSRESOLVE_ASSIGNING-tolerant resolve hooks only in JSOP_SETNAME,
 48470:          * after the interpreter evaluates the right- hand-side of the
 48470:          * assignment, and not here.
 48470:          *
 48470:          * This should be transparent to the hooks because the script, instead
 48470:          * of name = rhs, could have used global.name = rhs given a global
 48470:          * object reference, which also calls the hooks only after evaluating
 48470:          * the rhs. We desire such resolve hook equivalence between the two
 48470:          * forms.
 48470:          */
 96793:         obj = regs.fp()->scopeChain();
 83239:         if (obj->isGlobal())
 48470:             break;
 48470: 
 99421:         RootedPropertyName &name = rootName0;
 86855:         LOAD_NAME(0, name);
 48470: 
 99421:         RootedObject &scopeChain = rootObject0;
 97353:         scopeChain = regs.fp()->scopeChain();
 97353: 
 97353:         obj = FindIdentifierBase(cx, scopeChain, name);
 48470:         if (!obj)
 48470:             goto error;
 48470:     } while (0);
 48470:     PUSH_OBJECT(*obj);
 48470: }
 48470: END_CASE(JSOP_BINDNAME)
 48470: 
 48470: #define BITWISE_OP(OP)                                                        \
 48470:     JS_BEGIN_MACRO                                                            \
 48470:         int32_t i, j;                                                         \
 84161:         if (!ToInt32(cx, regs.sp[-2], &i))                                    \
 48470:             goto error;                                                       \
 84161:         if (!ToInt32(cx, regs.sp[-1], &j))                                    \
 48470:             goto error;                                                       \
 48470:         i = i OP j;                                                           \
 48470:         regs.sp--;                                                            \
 48470:         regs.sp[-1].setInt32(i);                                              \
 48470:     JS_END_MACRO
 48470: 
 48470: BEGIN_CASE(JSOP_BITOR)
 48470:     BITWISE_OP(|);
 48470: END_CASE(JSOP_BITOR)
 48470: 
 48470: BEGIN_CASE(JSOP_BITXOR)
 48470:     BITWISE_OP(^);
 48470: END_CASE(JSOP_BITXOR)
 48470: 
 48470: BEGIN_CASE(JSOP_BITAND)
 48470:     BITWISE_OP(&);
 48470: END_CASE(JSOP_BITAND)
 48470: 
 48470: #undef BITWISE_OP
 48470: 
 64551: #define EQUALITY_OP(OP)                                                       \
 64551:     JS_BEGIN_MACRO                                                            \
 64551:         Value rval = regs.sp[-1];                                             \
 64551:         Value lval = regs.sp[-2];                                             \
 88099:         bool cond;                                                            \
 64551:         if (!LooselyEqual(cx, lval, rval, &cond))                             \
 64319:             goto error;                                                       \
 64319:         cond = cond OP JS_TRUE;                                               \
 48470:         TRY_BRANCH_AFTER_COND(cond, 2);                                       \
 48470:         regs.sp--;                                                            \
 48470:         regs.sp[-1].setBoolean(cond);                                         \
 48470:     JS_END_MACRO
 48470: 
 48470: BEGIN_CASE(JSOP_EQ)
 64551:     EQUALITY_OP(==);
 48470: END_CASE(JSOP_EQ)
 48470: 
 48470: BEGIN_CASE(JSOP_NE)
 64551:     EQUALITY_OP(!=);
 48470: END_CASE(JSOP_NE)
 48470: 
 48470: #undef EQUALITY_OP
 48470: 
 48470: #define STRICT_EQUALITY_OP(OP, COND)                                          \
 48470:     JS_BEGIN_MACRO                                                            \
 48470:         const Value &rref = regs.sp[-1];                                      \
 48470:         const Value &lref = regs.sp[-2];                                      \
 88099:         bool equal;                                                           \
 59890:         if (!StrictlyEqual(cx, lref, rref, &equal))                           \
 59890:             goto error;                                                       \
 59908:         COND = equal OP JS_TRUE;                                              \
 48470:         regs.sp--;                                                            \
 48470:     JS_END_MACRO
 48470: 
 48470: BEGIN_CASE(JSOP_STRICTEQ)
 48470: {
 48470:     bool cond;
 48470:     STRICT_EQUALITY_OP(==, cond);
 48470:     regs.sp[-1].setBoolean(cond);
 48470: }
 48470: END_CASE(JSOP_STRICTEQ)
 48470: 
 48470: BEGIN_CASE(JSOP_STRICTNE)
 48470: {
 48470:     bool cond;
 48470:     STRICT_EQUALITY_OP(!=, cond);
 48470:     regs.sp[-1].setBoolean(cond);
 48470: }
 48470: END_CASE(JSOP_STRICTNE)
 48470: 
 48470: BEGIN_CASE(JSOP_CASE)
 48470: {
 48470:     bool cond;
 48470:     STRICT_EQUALITY_OP(==, cond);
 48470:     if (cond) {
 48470:         regs.sp--;
 48470:         len = GET_JUMP_OFFSET(regs.pc);
 48470:         BRANCH(len);
 48470:     }
 48470: }
 48470: END_CASE(JSOP_CASE)
 48470: 
 48470: #undef STRICT_EQUALITY_OP
 48470: 
 48470: BEGIN_CASE(JSOP_LT)
 88413: {
 88413:     bool cond;
 88413:     const Value &lref = regs.sp[-2];
 88413:     const Value &rref = regs.sp[-1];
 88413:     if (!LessThanOperation(cx, lref, rref, &cond))
 88413:         goto error;
 88413:     TRY_BRANCH_AFTER_COND(cond, 2);
 88413:     regs.sp[-2].setBoolean(cond);
 88413:     regs.sp--;
 88413: }
 48470: END_CASE(JSOP_LT)
 48470: 
 48470: BEGIN_CASE(JSOP_LE)
 88413: {
 88413:     bool cond;
 88413:     const Value &lref = regs.sp[-2];
 88413:     const Value &rref = regs.sp[-1];
 88413:     if (!LessThanOrEqualOperation(cx, lref, rref, &cond))
 88413:         goto error;
 88413:     TRY_BRANCH_AFTER_COND(cond, 2);
 88413:     regs.sp[-2].setBoolean(cond);
 88413:     regs.sp--;
 88413: }
 48470: END_CASE(JSOP_LE)
 48470: 
 48470: BEGIN_CASE(JSOP_GT)
 88413: {
 88413:     bool cond;
 88413:     const Value &lref = regs.sp[-2];
 88413:     const Value &rref = regs.sp[-1];
 88413:     if (!GreaterThanOperation(cx, lref, rref, &cond))
 88413:         goto error;
 88413:     TRY_BRANCH_AFTER_COND(cond, 2);
 88413:     regs.sp[-2].setBoolean(cond);
 88413:     regs.sp--;
 88413: }
 48470: END_CASE(JSOP_GT)
 48470: 
 48470: BEGIN_CASE(JSOP_GE)
 88413: {
 88413:     bool cond;
 88413:     const Value &lref = regs.sp[-2];
 88413:     const Value &rref = regs.sp[-1];
 88413:     if (!GreaterThanOrEqualOperation(cx, lref, rref, &cond))
 88413:         goto error;
 88413:     TRY_BRANCH_AFTER_COND(cond, 2);
 88413:     regs.sp[-2].setBoolean(cond);
 88413:     regs.sp--;
 88413: }
 48470: END_CASE(JSOP_GE)
 48470: 
 48470: #define SIGNED_SHIFT_OP(OP)                                                   \
 48470:     JS_BEGIN_MACRO                                                            \
 48470:         int32_t i, j;                                                         \
 84161:         if (!ToInt32(cx, regs.sp[-2], &i))                                    \
 48470:             goto error;                                                       \
 84161:         if (!ToInt32(cx, regs.sp[-1], &j))                                    \
 48470:             goto error;                                                       \
 48470:         i = i OP (j & 31);                                                    \
 48470:         regs.sp--;                                                            \
 48470:         regs.sp[-1].setInt32(i);                                              \
 48470:     JS_END_MACRO
 48470: 
 48470: BEGIN_CASE(JSOP_LSH)
 48470:     SIGNED_SHIFT_OP(<<);
 48470: END_CASE(JSOP_LSH)
 48470: 
 48470: BEGIN_CASE(JSOP_RSH)
 48470:     SIGNED_SHIFT_OP(>>);
 48470: END_CASE(JSOP_RSH)
 48470: 
 48470: #undef SIGNED_SHIFT_OP
 48470: 
 48470: BEGIN_CASE(JSOP_URSH)
 48470: {
 48470:     uint32_t u;
 84161:     if (!ToUint32(cx, regs.sp[-2], &u))
 48470:         goto error;
 48470:     int32_t j;
 84161:     if (!ToInt32(cx, regs.sp[-1], &j))
 48470:         goto error;
 48470: 
 48470:     u >>= (j & 31);
 48470: 
 48470:     regs.sp--;
 84755:     if (!regs.sp[-1].setNumber(uint32_t(u)))
 77391:         TypeScript::MonitorOverflow(cx, script, regs.pc);
 48470: }
 48470: END_CASE(JSOP_URSH)
 48470: 
 48470: BEGIN_CASE(JSOP_ADD)
 48470: {
 87809:     Value lval = regs.sp[-2];
 76194:     Value rval = regs.sp[-1];
 87809:     if (!AddOperation(cx, lval, rval, &regs.sp[-2]))
 87809:         goto error;
 87809:     regs.sp--;
 87809: }
 87809: END_CASE(JSOP_ADD)
 87809: 
 87809: BEGIN_CASE(JSOP_SUB)
 87809: {
 99421:     RootedValue &lval = rootValue0, &rval = rootValue1;
 97353:     lval = regs.sp[-2];
 97353:     rval = regs.sp[-1];
 87809:     if (!SubOperation(cx, lval, rval, &regs.sp[-2]))
 87809:         goto error;
 48470:     regs.sp--;
 87809: }
 87809: END_CASE(JSOP_SUB)
 87809: 
 87809: BEGIN_CASE(JSOP_MUL)
 87809: {
 99421:     RootedValue &lval = rootValue0, &rval = rootValue1;
 97353:     lval = regs.sp[-2];
 97353:     rval = regs.sp[-1];
 87809:     if (!MulOperation(cx, lval, rval, &regs.sp[-2]))
 48470:         goto error;
 48470:     regs.sp--;
 87809: }
 48470: END_CASE(JSOP_MUL)
 48470: 
 48470: BEGIN_CASE(JSOP_DIV)
 48470: {
 99421:     RootedValue &lval = rootValue0, &rval = rootValue1;
 97353:     lval = regs.sp[-2];
 97353:     rval = regs.sp[-1];
 87809:     if (!DivOperation(cx, lval, rval, &regs.sp[-2]))
 73894:         goto error;
 48470:     regs.sp--;
 48470: }
 48470: END_CASE(JSOP_DIV)
 48470: 
 48470: BEGIN_CASE(JSOP_MOD)
 48470: {
 99421:     RootedValue &lval = rootValue0, &rval = rootValue1;
 97353:     lval = regs.sp[-2];
 97353:     rval = regs.sp[-1];
 87809:     if (!ModOperation(cx, lval, rval, &regs.sp[-2]))
 73894:         goto error;
 48470:     regs.sp--;
 48470: }
 48470: END_CASE(JSOP_MOD)
 48470: 
 48470: BEGIN_CASE(JSOP_NOT)
 48470: {
 48470:     Value *_;
 48470:     bool cond;
 48470:     POP_BOOLEAN(cx, _, cond);
 48470:     PUSH_BOOLEAN(!cond);
 48470: }
 48470: END_CASE(JSOP_NOT)
 48470: 
 48470: BEGIN_CASE(JSOP_BITNOT)
 48470: {
 48470:     int32_t i;
 84161:     if (!ToInt32(cx, regs.sp[-1], &i))
 48470:         goto error;
 48470:     i = ~i;
 48470:     regs.sp[-1].setInt32(i);
 48470: }
 48470: END_CASE(JSOP_BITNOT)
 48470: 
 48470: BEGIN_CASE(JSOP_NEG)
 48470: {
 48470:     /*
 48470:      * When the operand is int jsval, INT32_FITS_IN_JSVAL(i) implies
 48470:      * INT32_FITS_IN_JSVAL(-i) unless i is 0 or INT32_MIN when the
 90955:      * results, -0.0 or INT32_MAX + 1, are double values.
 48470:      */
 76194:     Value ref = regs.sp[-1];
 48470:     int32_t i;
 48470:     if (ref.isInt32() && (i = ref.toInt32()) != 0 && i != INT32_MIN) {
 48470:         i = -i;
 48470:         regs.sp[-1].setInt32(i);
 48470:     } else {
 48470:         double d;
 73894:         if (!ToNumber(cx, regs.sp[-1], &d))
 48470:             goto error;
 48470:         d = -d;
 76194:         if (!regs.sp[-1].setNumber(d) && !ref.isDouble())
 77391:             TypeScript::MonitorOverflow(cx, script, regs.pc);
 48470:     }
 48470: }
 48470: END_CASE(JSOP_NEG)
 48470: 
 48470: BEGIN_CASE(JSOP_POS)
 73894:     if (!ToNumber(cx, &regs.sp[-1]))
 48470:         goto error;
 76194:     if (!regs.sp[-1].isInt32())
 77391:         TypeScript::MonitorOverflow(cx, script, regs.pc);
 48470: END_CASE(JSOP_POS)
 48470: 
 48470: BEGIN_CASE(JSOP_DELNAME)
 48470: {
 99421:     RootedPropertyName &name = rootName0;
 86542:     LOAD_NAME(0, name);
 95355: 
 99421:     RootedObject &scopeObj = rootObject0;
 95355:     scopeObj = cx->stack.currentScriptedScopeChain();
 95355: 
 48470:     JSObject *obj, *obj2;
 48470:     JSProperty *prop;
 95355:     if (!FindProperty(cx, name, scopeObj, &obj, &obj2, &prop))
 48470:         goto error;
 48470: 
 54169:     /* Strict mode code should never contain JSOP_DELNAME opcodes. */
 54169:     JS_ASSERT(!script->strictModeCode);
 54169: 
 48470:     /* ECMA says to return true if name is undefined or inherited. */
 48470:     PUSH_BOOLEAN(true);
 48470:     if (prop) {
 86542:         if (!obj->deleteProperty(cx, name, &regs.sp[-1], false))
 48470:             goto error;
 48470:     }
 48470: }
 48470: END_CASE(JSOP_DELNAME)
 48470: 
 48470: BEGIN_CASE(JSOP_DELPROP)
 48470: {
 99421:     RootedPropertyName &name = rootName0;
 86542:     LOAD_NAME(0, name);
 48470: 
 48470:     JSObject *obj;
 48470:     FETCH_OBJECT(cx, -1, obj);
 48470: 
 99421:     RootedValue &rval = rootValue0;
 97353:     if (!obj->deleteProperty(cx, name, rval.address(), script->strictModeCode))
 48470:         goto error;
 48470: 
 48470:     regs.sp[-1] = rval;
 48470: }
 48470: END_CASE(JSOP_DELPROP)
 48470: 
 48470: BEGIN_CASE(JSOP_DELELEM)
 48470: {
 48470:     /* Fetch the left part and resolve it to a non-null object. */
 48470:     JSObject *obj;
 48470:     FETCH_OBJECT(cx, -2, obj);
 48470: 
 99421:     RootedValue &propval = rootValue0;
 98960:     propval = regs.sp[-1];
 86790:     Value &rval = regs.sp[-2];
 86790: 
 86790:     if (!obj->deleteByValue(cx, propval, &rval, script->strictModeCode))
 48470:         goto error;
 48470: 
 48470:     regs.sp--;
 48470: }
 48470: END_CASE(JSOP_DELELEM)
 48470: 
 77357: BEGIN_CASE(JSOP_TOID)
 77357: {
 77357:     /*
 82827:      * Increment or decrement requires use to lookup the same property twice, but we need to avoid
 82827:      * the oberservable stringification the second time.
 77357:      * There must be an object value below the id, which will not be popped
 77357:      * but is necessary in interning the id for XML.
 77357:      */
 90123:     Value objval = regs.sp[-2];
 90123:     Value idval = regs.sp[-1];
 90123:     if (!ToIdOperation(cx, objval, idval, &regs.sp[-1]))
 82827:         goto error;
 82827: }
 77357: END_CASE(JSOP_TOID)
 77357: 
 48470: BEGIN_CASE(JSOP_TYPEOFEXPR)
 48470: BEGIN_CASE(JSOP_TYPEOF)
 48470: {
 48470:     const Value &ref = regs.sp[-1];
 78614:     JSType type = JS_TypeOfValue(cx, ref);
 86542:     regs.sp[-1].setString(rt->atomState.typeAtoms[type]);
 48470: }
 48470: END_CASE(JSOP_TYPEOF)
 48470: 
 48470: BEGIN_CASE(JSOP_VOID)
 48470:     regs.sp[-1].setUndefined();
 48470: END_CASE(JSOP_VOID)
 48470: 
 48470: BEGIN_CASE(JSOP_INCELEM)
 48470: BEGIN_CASE(JSOP_DECELEM)
 48470: BEGIN_CASE(JSOP_ELEMINC)
 48470: BEGIN_CASE(JSOP_ELEMDEC)
 83221:     /* No-op */
 83221: END_CASE(JSOP_INCELEM)
 48470: 
 48470: BEGIN_CASE(JSOP_INCPROP)
 48470: BEGIN_CASE(JSOP_DECPROP)
 48470: BEGIN_CASE(JSOP_PROPINC)
 48470: BEGIN_CASE(JSOP_PROPDEC)
 48470: BEGIN_CASE(JSOP_INCNAME)
 48470: BEGIN_CASE(JSOP_DECNAME)
 48470: BEGIN_CASE(JSOP_NAMEINC)
 48470: BEGIN_CASE(JSOP_NAMEDEC)
 53092: BEGIN_CASE(JSOP_INCGNAME)
 53092: BEGIN_CASE(JSOP_DECGNAME)
 53092: BEGIN_CASE(JSOP_GNAMEINC)
 53092: BEGIN_CASE(JSOP_GNAMEDEC)
 83221:     /* No-op */
 83221: END_CASE(JSOP_INCPROP)
 48470: 
 95101: BEGIN_CASE(JSOP_DECALIASEDVAR)
 95101: BEGIN_CASE(JSOP_ALIASEDVARDEC)
 95101: BEGIN_CASE(JSOP_INCALIASEDVAR)
 95101: BEGIN_CASE(JSOP_ALIASEDVARINC)
 95101:     /* No-op */
 95101: END_CASE(JSOP_ALIASEDVARINC)
 95101: 
 91691: BEGIN_CASE(JSOP_DECARG)
 91691: BEGIN_CASE(JSOP_ARGDEC)
 91691: BEGIN_CASE(JSOP_INCARG)
 91691: BEGIN_CASE(JSOP_ARGINC)
 48470: {
 95101:     unsigned i = GET_ARGNO(regs.pc);
101075:     if (script->argsObjAliasesFormals()) {
101075:         const Value &arg = regs.fp()->argsObj().arg(i);
101075:         Value v;
101075:         if (!DoIncDec(cx, script, regs.pc, arg, &v, &regs.sp[0]))
101075:             goto error;
101075:         regs.fp()->argsObj().setArg(i, v);
101075:     } else {
101075:         Value &arg = regs.fp()->unaliasedFormal(i);
 91691:         if (!DoIncDec(cx, script, regs.pc, arg, &arg, &regs.sp[0]))
 91691:             goto error;
101075:     }
 91691:     regs.sp++;
 91691: }
 91691: END_CASE(JSOP_ARGINC);
 48470: 
 48470: BEGIN_CASE(JSOP_DECLOCAL)
 48470: BEGIN_CASE(JSOP_LOCALDEC)
 48470: BEGIN_CASE(JSOP_INCLOCAL)
 48470: BEGIN_CASE(JSOP_LOCALINC)
 91691: {
 95101:     unsigned i = GET_SLOTNO(regs.pc);
101075:     Value &local = regs.fp()->unaliasedLocal(i);
 91691:     if (!DoIncDec(cx, script, regs.pc, local, &local, &regs.sp[0]))
 48470:         goto error;
 91691:     regs.sp++;
 91691: }
 91691: END_CASE(JSOP_LOCALINC)
 48470: 
 48470: BEGIN_CASE(JSOP_THIS)
 69223:     if (!ComputeThis(cx, regs.fp()))
 69223:         goto error;
 69223:     PUSH_COPY(regs.fp()->thisValue());
 48470: END_CASE(JSOP_THIS)
 48470: 
 48470: BEGIN_CASE(JSOP_GETPROP)
 48470: BEGIN_CASE(JSOP_GETXPROP)
 76194: BEGIN_CASE(JSOP_LENGTH)
 86855: BEGIN_CASE(JSOP_CALLPROP)
 86752: {
101203:     RootedValue rval(cx);
103195:     if (!GetPropertyOperation(cx, script, regs.pc, regs.sp[-1], rval.address()))
 86752:         goto error;
 86752: 
101203:     TypeScript::Monitor(cx, script, regs.pc, rval.reference());
 86752: 
 86752:     regs.sp[-1] = rval;
 86752:     assertSameCompartment(cx, regs.sp[-1]);
 86752: }
 86752: END_CASE(JSOP_GETPROP)
 86752: 
 53092: BEGIN_CASE(JSOP_SETGNAME)
 48470: BEGIN_CASE(JSOP_SETNAME)
 48470: BEGIN_CASE(JSOP_SETPROP)
 48470: {
 86855:     const Value &rval = regs.sp[-1];
 86855:     const Value &lval = regs.sp[-2];
 86855: 
 86855:     if (!SetPropertyOperation(cx, regs.pc, lval, rval))
 48470:         goto error;
 82827: 
 82827:     regs.sp[-2] = regs.sp[-1];
 82827:     regs.sp--;
 82827: }
 82827: END_CASE(JSOP_SETPROP)
 48470: 
 48470: BEGIN_CASE(JSOP_GETELEM)
 91807: BEGIN_CASE(JSOP_CALLELEM)
 48470: {
 48470:     Value &lref = regs.sp[-2];
 48470:     Value &rref = regs.sp[-1];
 91807:     if (!GetElementOperation(cx, op, lref, rref, &regs.sp[-2]))
 48470:         goto error;
 90694:     TypeScript::Monitor(cx, script, regs.pc, regs.sp[-2]);
 48470:     regs.sp--;
 48470: }
 48470: END_CASE(JSOP_GETELEM)
 48470: 
 48470: BEGIN_CASE(JSOP_SETELEM)
 48470: {
 99421:     RootedObject &obj = rootObject0;
 48470:     FETCH_OBJECT(cx, -3, obj);
 99421:     RootedId &id = rootId0;
 48470:     FETCH_ELEMENT_ID(obj, -2, id);
 88054:     Value &value = regs.sp[-1];
 91183:     if (!SetObjectElementOperation(cx, obj, id, value, script->strictModeCode))
 48470:         goto error;
 88054:     regs.sp[-3] = value;
 82827:     regs.sp -= 2;
 82827: }
 82827: END_CASE(JSOP_SETELEM)
 48470: 
 48470: BEGIN_CASE(JSOP_ENUMELEM)
 48470: {
 99421:     RootedObject &obj = rootObject0;
 99421:     RootedValue &rval = rootValue0;
 97353: 
 48470:     /* Funky: the value to set is under the [obj, id] pair. */
 48470:     FETCH_OBJECT(cx, -2, obj);
 99421:     RootedId &id = rootId0;
 48470:     FETCH_ELEMENT_ID(obj, -1, id);
 97353:     rval = regs.sp[-3];
 97353:     if (!obj->setGeneric(cx, id, rval.address(), script->strictModeCode))
 48470:         goto error;
 48470:     regs.sp -= 3;
 48470: }
 48470: END_CASE(JSOP_ENUMELEM)
 48470: 
 71851: BEGIN_CASE(JSOP_EVAL)
 71851: {
 71851:     CallArgs args = CallArgsFromSp(GET_ARGC(regs.pc), regs.sp);
 96793:     if (IsBuiltinEvalForScope(regs.fp()->scopeChain(), args.calleev())) {
 71851:         if (!DirectEval(cx, args))
 71851:             goto error;
 71851:     } else {
 76829:         if (!InvokeKernel(cx, args))
 71851:             goto error;
 71851:     }
 71851:     CHECK_INTERRUPT_HANDLER();
 71851:     regs.sp = args.spAfterCall();
 77391:     TypeScript::Monitor(cx, script, regs.pc, regs.sp[-1]);
 71851: }
 71851: END_CASE(JSOP_EVAL)
 71851: 
 93251: BEGIN_CASE(JSOP_FUNAPPLY)
103261:     if (!GuardFunApplyArgumentsOptimization(cx))
 93251:         goto error;
 93251:     /* FALL THROUGH */
 93251: 
 71851: BEGIN_CASE(JSOP_NEW)
 71851: BEGIN_CASE(JSOP_CALL)
 71851: BEGIN_CASE(JSOP_FUNCALL)
 71851: {
101075:     JS_ASSERT(regs.stackDepth() >= 2 + GET_ARGC(regs.pc));
 71851:     CallArgs args = CallArgsFromSp(GET_ARGC(regs.pc), regs.sp);
 71851: 
 77341:     bool construct = (*regs.pc == JSOP_NEW);
 71851: 
 99421:     RootedFunction &fun = rootFunction0;
 73069:     /* Don't bother trying to fast-path calls to scripted non-constructors. */
 95355:     if (!IsFunctionObject(args.calleev(), fun.address()) || !fun->isInterpretedConstructor()) {
 71851:         if (construct) {
 76829:             if (!InvokeConstructorKernel(cx, args))
 71695:                 goto error;
 71851:         } else {
 76829:             if (!InvokeKernel(cx, args))
 71851:                 goto error;
 71851:         }
 92094:         Value *newsp = args.spAfterCall();
 92094:         TypeScript::Monitor(cx, script, regs.pc, newsp[-1]);
 92094:         regs.sp = newsp;
 48470:         CHECK_INTERRUPT_HANDLER();
 71851:         len = JSOP_CALL_LENGTH;
 71851:         DO_NEXT_OP(len);
 71851:     }
 71851: 
 95084:     if (!TypeMonitorCall(cx, args, construct))
 95084:         goto error;
 76194: 
 77341:     InitialFrameFlags initial = construct ? INITIAL_CONSTRUCT : INITIAL_NONE;
 77341: 
 72552:     JSScript *newScript = fun->script();
 89163: 
 89163:     if (newScript->compileAndGo && newScript->hasClearedGlobal()) {
 89163:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CLEARED_SCOPE);
 89163:         goto error;
 89163:     }
 89163: 
 83283:     if (!cx->stack.pushInlineFrame(cx, regs, args, *fun, newScript, initial))
 77341:         goto error;
 77341: 
 77341:     RESTORE_INTERP_VARS();
 63095:     RESET_USE_METHODJIT();
 48482: 
 77884:     bool newType = cx->typeInferenceEnabled() && UseNewType(cx, script, regs.pc);
 77884: 
 56201: #ifdef JS_METHODJIT
 77884:     if (!newType) {
 56201:         /* Try to ensure methods are method JIT'd.  */
 87654:         mjit::CompileStatus status = mjit::CanMethodJIT(cx, script, script->code,
 99701:                                                         construct,
 99701:                                                         mjit::CompileRequest_Interpreter);
 56201:         if (status == mjit::Compile_Error)
 56201:             goto error;
 82645:         if (status == mjit::Compile_Okay) {
 77341:             mjit::JaegerStatus status = mjit::JaegerShot(cx, true);
 77341:             CHECK_PARTIAL_METHODJIT(status);
 93359:             interpReturnOK = mjit::JaegerStatusToSuccess(status);
 76829:             CHECK_INTERRUPT_HANDLER();
 56201:             goto jit_return;
 56201:         }
 71851:     }
 56201: #endif
 56201: 
101075:     if (!regs.fp()->prologue(cx, newType))
 56201:         goto error;
 56201: 
 84070:     if (cx->compartment->debugMode()) {
 84070:         switch (ScriptDebugPrologue(cx, regs.fp())) {
 84070:           case JSTRAP_CONTINUE:
 84070:             break;
 84070:           case JSTRAP_RETURN:
 91435:             interpReturnOK = true;
 84070:             goto forced_return;
 84070:           case JSTRAP_THROW:
 84070:           case JSTRAP_ERROR:
 84070:             goto error;
 84070:           default:
 84070:             JS_NOT_REACHED("bad ScriptDebugPrologue status");
 84070:         }
 84070:     }
 84067: 
 56201:     CHECK_INTERRUPT_HANDLER();
 56201: 
 48470:     /* Load first op and dispatch it (safe since JSOP_STOP). */
 48470:     op = (JSOp) *regs.pc;
 48470:     DO_OP();
 48470: }
 48470: 
 48470: BEGIN_CASE(JSOP_SETCALL)
 48470: {
 48470:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_LEFTSIDE_OF_ASS);
 48470:     goto error;
 48470: }
 48470: END_CASE(JSOP_SETCALL)
 48470: 
 86855: BEGIN_CASE(JSOP_IMPLICITTHIS)
 86855: {
 99421:     RootedPropertyName &name = rootName0;
 86855:     LOAD_NAME(0, name);
 86855: 
 99421:     RootedObject &scopeObj = rootObject0;
 95355:     scopeObj = cx->stack.currentScriptedScopeChain();
 95355: 
 86855:     JSObject *obj, *obj2;
 86855:     JSProperty *prop;
 95355:     if (!FindPropertyHelper(cx, name, false, scopeObj, &obj, &obj2, &prop))
 86855:         goto error;
 86855: 
 86855:     Value v;
 86855:     if (!ComputeImplicitThis(cx, obj, &v))
 86855:         goto error;
 86855:     PUSH_COPY(v);
 86855: }
 86855: END_CASE(JSOP_IMPLICITTHIS)
 53100: 
 53092: BEGIN_CASE(JSOP_GETGNAME)
 53092: BEGIN_CASE(JSOP_CALLGNAME)
 48470: BEGIN_CASE(JSOP_NAME)
 48470: BEGIN_CASE(JSOP_CALLNAME)
 48470: {
 99421:     RootedValue &rval = rootValue0;
 95355: 
103195:     if (!NameOperation(cx, script, regs.pc, rval.address()))
 48470:         goto error;
 48470: 
 48470:     PUSH_COPY(rval);
 80962:     TypeScript::Monitor(cx, script, regs.pc, rval);
 48470: }
 48470: END_CASE(JSOP_NAME)
 48470: 
 48470: BEGIN_CASE(JSOP_UINT16)
 48470:     PUSH_INT32((int32_t) GET_UINT16(regs.pc));
 48470: END_CASE(JSOP_UINT16)
 48470: 
 48470: BEGIN_CASE(JSOP_UINT24)
 48470:     PUSH_INT32((int32_t) GET_UINT24(regs.pc));
 48470: END_CASE(JSOP_UINT24)
 48470: 
 48470: BEGIN_CASE(JSOP_INT8)
 48470:     PUSH_INT32(GET_INT8(regs.pc));
 48470: END_CASE(JSOP_INT8)
 48470: 
 48470: BEGIN_CASE(JSOP_INT32)
 48470:     PUSH_INT32(GET_INT32(regs.pc));
 48470: END_CASE(JSOP_INT32)
 48470: 
 48470: BEGIN_CASE(JSOP_DOUBLE)
 48470: {
 48470:     double dbl;
 48470:     LOAD_DOUBLE(0, dbl);
 48470:     PUSH_DOUBLE(dbl);
 48470: }
 48470: END_CASE(JSOP_DOUBLE)
 48470: 
 48470: BEGIN_CASE(JSOP_STRING)
 48470: {
 48470:     JSAtom *atom;
 48470:     LOAD_ATOM(0, atom);
 64345:     PUSH_STRING(atom);
 48470: }
 48470: END_CASE(JSOP_STRING)
 48470: 
 48470: BEGIN_CASE(JSOP_OBJECT)
 48470: {
 89253:     PUSH_OBJECT(*script->getObject(GET_UINT32_INDEX(regs.pc)));
 48470: }
 48470: END_CASE(JSOP_OBJECT)
 48470: 
 48470: BEGIN_CASE(JSOP_REGEXP)
 48470: {
 48470:     /*
 48470:      * Push a regexp object cloned from the regexp literal object mapped by the
 80627:      * bytecode at pc.
 48470:      */
 87976:     uint32_t index = GET_UINT32_INDEX(regs.pc);
 96793:     JSObject *proto = regs.fp()->global().getOrCreateRegExpPrototype(cx);
 80627:     if (!proto)
 80627:         goto error;
 89918:     JSObject *obj = CloneRegExpObject(cx, script->getRegExp(index), proto);
 48470:     if (!obj)
 48470:         goto error;
 48470:     PUSH_OBJECT(*obj);
 48470: }
 48470: END_CASE(JSOP_REGEXP)
 48470: 
 48470: BEGIN_CASE(JSOP_ZERO)
 48470:     PUSH_INT32(0);
 48470: END_CASE(JSOP_ZERO)
 48470: 
 48470: BEGIN_CASE(JSOP_ONE)
 48470:     PUSH_INT32(1);
 48470: END_CASE(JSOP_ONE)
 48470: 
 48470: BEGIN_CASE(JSOP_NULL)
 48470:     PUSH_NULL();
 48470: END_CASE(JSOP_NULL)
 48470: 
 48470: BEGIN_CASE(JSOP_FALSE)
 48470:     PUSH_BOOLEAN(false);
 48470: END_CASE(JSOP_FALSE)
 48470: 
 48470: BEGIN_CASE(JSOP_TRUE)
 48470:     PUSH_BOOLEAN(true);
 48470: END_CASE(JSOP_TRUE)
 48470: 
 48470: {
 48470: BEGIN_CASE(JSOP_TABLESWITCH)
 48470: {
 48470:     jsbytecode *pc2 = regs.pc;
 48470:     len = GET_JUMP_OFFSET(pc2);
 48470: 
 48470:     /*
 48470:      * ECMAv2+ forbids conversion of discriminant, so we will skip to the
 48470:      * default case if the discriminant isn't already an int jsval.  (This
 91450:      * opcode is emitted only for dense int-domain switches.)
 48470:      */
 48470:     const Value &rref = *--regs.sp;
 48470:     int32_t i;
 48470:     if (rref.isInt32()) {
 48470:         i = rref.toInt32();
 48470:     } else {
 48518:         double d;
 95341:         /* Don't use MOZ_DOUBLE_IS_INT32; treat -0 (double) as 0. */
 48518:         if (!rref.isDouble() || (d = rref.toDouble()) != (i = int32_t(rref.toDouble())))
 48470:             DO_NEXT_OP(len);
 48470:     }
 48470: 
 48470:     pc2 += JUMP_OFFSET_LEN;
 91450:     int32_t low = GET_JUMP_OFFSET(pc2);
 48470:     pc2 += JUMP_OFFSET_LEN;
 91450:     int32_t high = GET_JUMP_OFFSET(pc2);
 48470: 
 48470:     i -= low;
 91688:     if ((uint32_t)i < (uint32_t)(high - low + 1)) {
 48470:         pc2 += JUMP_OFFSET_LEN + JUMP_OFFSET_LEN * i;
 91450:         int32_t off = (int32_t) GET_JUMP_OFFSET(pc2);
 48470:         if (off)
 48470:             len = off;
 48470:     }
 48470: }
 48470: END_VARLEN_CASE
 48470: }
 48470: 
 48470: {
 86877: BEGIN_CASE(JSOP_LOOKUPSWITCH)
 48470: {
 91450:     int32_t off;
 48470:     off = JUMP_OFFSET_LEN;
 48470: 
 48470:     /*
 86877:      * JSOP_LOOKUPSWITCH are never used if any atom index in it would exceed
 86877:      * 64K limit.
 48470:      */
 77659:     JS_ASSERT(atoms == script->atoms);
 48470:     jsbytecode *pc2 = regs.pc;
 48470: 
 48470:     Value lval = regs.sp[-1];
 48470:     regs.sp--;
 48470: 
 91450:     int npairs;
 48470:     if (!lval.isPrimitive())
 48470:         goto end_lookup_switch;
 48470: 
 48470:     pc2 += off;
 91450:     npairs = GET_UINT16(pc2);
 48470:     pc2 += UINT16_LEN;
 48470:     JS_ASSERT(npairs);  /* empty switch uses JSOP_TABLESWITCH */
 48470: 
 48470:     bool match;
 48470: #define SEARCH_PAIRS(MATCH_CODE)                                              \
 48470:     for (;;) {                                                                \
 90965:         Value rval = script->getConst(GET_UINT32_INDEX(pc2));                 \
 48470:         MATCH_CODE                                                            \
 90965:         pc2 += UINT32_INDEX_LEN;                                              \
 48470:         if (match)                                                            \
 48470:             break;                                                            \
 48470:         pc2 += off;                                                           \
 48470:         if (--npairs == 0) {                                                  \
 48470:             pc2 = regs.pc;                                                    \
 48470:             break;                                                            \
 48470:         }                                                                     \
 48470:     }
 48470: 
 48470:     if (lval.isString()) {
 59890:         JSLinearString *str = lval.toString()->ensureLinear(cx);
 59890:         if (!str)
 59890:             goto error;
 59890:         JSLinearString *str2;
 48470:         SEARCH_PAIRS(
 48470:             match = (rval.isString() &&
 64345:                      ((str2 = &rval.toString()->asLinear()) == str ||
 59890:                       EqualStrings(str2, str)));
 48470:         )
 48470:     } else if (lval.isNumber()) {
 48470:         double ldbl = lval.toNumber();
 48470:         SEARCH_PAIRS(
 48470:             match = rval.isNumber() && ldbl == rval.toNumber();
 48470:         )
 48470:     } else {
 48470:         SEARCH_PAIRS(
 48470:             match = (lval == rval);
 48470:         )
 48470:     }
 48470: #undef SEARCH_PAIRS
 48470: 
 48470:   end_lookup_switch:
 86877:     len = GET_JUMP_OFFSET(pc2);
 48470: }
 48470: END_VARLEN_CASE
 48470: }
 48470: 
 99552: BEGIN_CASE(JSOP_ACTUALSFILLED)
 99552: {
 99552:     PUSH_INT32(JS_MAX(regs.fp()->numActualArgs(), GET_UINT16(regs.pc)));
 99552: }
 99552: END_CASE(JSOP_ACTUALSFILLED)
 99552: 
 48470: BEGIN_CASE(JSOP_ARGUMENTS)
 99225:     JS_ASSERT(!regs.fp()->fun()->hasRest());
 95100:     if (script->needsArgsObj()) {
101075:         ArgumentsObject *obj = ArgumentsObject::createExpected(cx, regs.fp());
 95100:         if (!obj)
 95100:             goto error;
 95100:         PUSH_COPY(ObjectValue(*obj));
 95100:     } else {
 93250:         PUSH_COPY(MagicValue(JS_OPTIMIZED_ARGUMENTS));
 95100:     }
 48470: END_CASE(JSOP_ARGUMENTS)
 48470: 
 99225: BEGIN_CASE(JSOP_REST)
 99225: {
 99225:     JSObject *rest = regs.fp()->createRestParameter(cx);
 99225:     if (!rest)
 99225:         goto error;
 99225:     PUSH_COPY(ObjectValue(*rest));
 99225:     if (!SetInitializerObjectType(cx, script, regs.pc, rest))
 99225:         goto error;
 99225: }
 99225: END_CASE(JSOP_REST)
 99225: 
 95101: BEGIN_CASE(JSOP_CALLALIASEDVAR)
 95101: BEGIN_CASE(JSOP_GETALIASEDVAR)
 95101: {
 95101:     ScopeCoordinate sc = ScopeCoordinate(regs.pc);
101073:     PUSH_COPY(regs.fp()->aliasedVarScope(sc).aliasedVar(sc));
 95101: }
 95101: END_CASE(JSOP_GETALIASEDVAR)
 95101: 
 95101: BEGIN_CASE(JSOP_SETALIASEDVAR)
 95101: {
 95101:     ScopeCoordinate sc = ScopeCoordinate(regs.pc);
101073:     regs.fp()->aliasedVarScope(sc).setAliasedVar(sc, regs.sp[-1]);
 95101: }
 95101: END_CASE(JSOP_SETALIASEDVAR)
 95101: 
 48470: BEGIN_CASE(JSOP_GETARG)
 48470: BEGIN_CASE(JSOP_CALLARG)
 95101: {
 95101:     unsigned i = GET_ARGNO(regs.pc);
101075:     if (script->argsObjAliasesFormals())
101075:         PUSH_COPY(regs.fp()->argsObj().arg(i));
101075:     else
101075:         PUSH_COPY(regs.fp()->unaliasedFormal(i));
 95101: }
 48470: END_CASE(JSOP_GETARG)
 48470: 
 48470: BEGIN_CASE(JSOP_SETARG)
 95101: {
 95101:     unsigned i = GET_ARGNO(regs.pc);
101075:     if (script->argsObjAliasesFormals())
101075:         regs.fp()->argsObj().setArg(i, regs.sp[-1]);
101075:     else
101075:         regs.fp()->unaliasedFormal(i) = regs.sp[-1];
 95101: }
 82827: END_CASE(JSOP_SETARG)
 48470: 
 48470: BEGIN_CASE(JSOP_GETLOCAL)
 86855: BEGIN_CASE(JSOP_CALLLOCAL)
 95101: {
 95101:     unsigned i = GET_SLOTNO(regs.pc);
101075:     PUSH_COPY_SKIP_CHECK(regs.fp()->unaliasedLocal(i));
 89723: 
 76194:     /*
 76194:      * Skip the same-compartment assertion if the local will be immediately
 76194:      * popped. We do not guarantee sync for dead locals when coming in from the
 76194:      * method JIT, and a GETLOCAL followed by POP is not considered to be
 76194:      * a use of the variable.
 76194:      */
 76194:     if (regs.pc[JSOP_GETLOCAL_LENGTH] != JSOP_POP)
 76194:         assertSameCompartment(cx, regs.sp[-1]);
 95101: }
 48470: END_CASE(JSOP_GETLOCAL)
 48470: 
 48470: BEGIN_CASE(JSOP_SETLOCAL)
 95101: {
 95101:     unsigned i = GET_SLOTNO(regs.pc);
101075:     regs.fp()->unaliasedLocal(i) = regs.sp[-1];
 95101: }
 82827: END_CASE(JSOP_SETLOCAL)
 48470: 
 48470: BEGIN_CASE(JSOP_DEFCONST)
 48470: BEGIN_CASE(JSOP_DEFVAR)
 48470: {
 90965:     PropertyName *dn = atoms[GET_UINT32_INDEX(regs.pc)]->asPropertyName();
 90230: 
 90230:     /* ES5 10.5 step 8 (with subsequent errata). */
 91237:     unsigned attrs = JSPROP_ENUMERATE;
 90230:     if (!regs.fp()->isEvalFrame())
 90230:         attrs |= JSPROP_PERMANENT;
 90230:     if (op == JSOP_DEFCONST)
 90230:         attrs |= JSPROP_READONLY;
 90230: 
 90230:     /* Step 8b. */
 99421:     RootedObject &obj = rootObject0;
 95355:     obj = &regs.fp()->varObj();
 90230: 
 90230:     if (!DefVarOrConstOperation(cx, obj, dn, attrs))
 48470:         goto error;
 48470: }
 48470: END_CASE(JSOP_DEFVAR)
 48470: 
 48470: BEGIN_CASE(JSOP_DEFFUN)
 48470: {
 48470:     /*
 48470:      * A top-level function defined in Global or Eval code (see ECMA-262
 48470:      * Ed. 3), or else a SpiderMonkey extension: a named function statement in
 48470:      * a compound statement (not at the top statement level of global code, or
 48470:      * at the top level of a function body).
 48470:      */
 99421:     RootedFunction &fun = rootFunction0;
 95355:     fun = script->getFunction(GET_UINT32_INDEX(regs.pc));
 48470: 
 48470:     /*
 48470:      * If static link is not current scope, clone fun's object to link to the
 48470:      * current scope via parent. We do this to enable sharing of compiled
 48470:      * functions among multiple equivalent scopes, amortizing the cost of
 48470:      * compilation over a number of executions.  Examples include XUL scripts
 48470:      * and event handlers shared among Firefox or other Mozilla app chrome
 48470:      * windows, and user-defined JS functions precompiled and then shared among
 48470:      * requests in server-side JS.
 48470:      */
 98921:     HandleObject scopeChain = regs.fp()->scopeChain();
 98921:     if (fun->environment() != scopeChain) {
 98921:         fun = CloneFunctionObjectIfNotSingleton(cx, fun, scopeChain);
 97353:         if (!fun)
 48470:             goto error;
 98921:     } else {
 98921:         JS_ASSERT(script->compileAndGo);
 98921:         JS_ASSERT(regs.fp()->isGlobalFrame() || regs.fp()->isEvalInFunction());
 48470:     }
 48470: 
 48470:     /*
 48470:      * ECMA requires functions defined when entering Eval code to be
 48470:      * impermanent.
 48470:      */
 91237:     unsigned attrs = regs.fp()->isEvalFrame()
 48470:                   ? JSPROP_ENUMERATE
 48470:                   : JSPROP_ENUMERATE | JSPROP_PERMANENT;
 48470: 
 48470:     /*
 48470:      * We define the function as a property of the variable object and not the
 48470:      * current scope chain even for the case of function expression statements
 48470:      * and functions defined by eval inside let or with blocks.
 48470:      */
 99421:     RootedObject &parent = rootObject0;
 97353:     parent = &regs.fp()->varObj();
 48605: 
 61216:     /* ES5 10.5 (NB: with subsequent errata). */
 99421:     RootedPropertyName &name = rootName0;
 97353:     name = fun->atom->asPropertyName();
 48605:     JSProperty *prop = NULL;
 48605:     JSObject *pobj;
 80442:     if (!parent->lookupProperty(cx, name, &pobj, &prop))
 61216:         goto error;
 61216: 
 99421:     RootedValue &rval = rootValue0;
 97353:     rval = ObjectValue(*fun);
 61216: 
 61216:     do {
 61216:         /* Steps 5d, 5f. */
 61216:         if (!prop || pobj != parent) {
 80624:             if (!parent->defineProperty(cx, name, rval,
 80624:                                         JS_PropertyStub, JS_StrictPropertyStub, attrs))
 80624:             {
 80624:                 goto error;
 80624:             }
 61216:             break;
 61216:         }
 61216: 
 61216:         /* Step 5e. */
 61216:         JS_ASSERT(parent->isNative());
 61216:         Shape *shape = reinterpret_cast<Shape *>(prop);
 61216:         if (parent->isGlobal()) {
 61216:             if (shape->configurable()) {
 80624:                 if (!parent->defineProperty(cx, name, rval,
 80624:                                             JS_PropertyStub, JS_StrictPropertyStub, attrs))
 80624:                 {
 80624:                     goto error;
 80624:                 }
 61216:                 break;
 61216:             }
 61216: 
 61216:             if (shape->isAccessorDescriptor() || !shape->writable() || !shape->enumerable()) {
 61216:                 JSAutoByteString bytes;
 86542:                 if (js_AtomToPrintableString(cx, name, &bytes)) {
 61216:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 86542:                                          JSMSG_CANT_REDEFINE_PROP, bytes.ptr());
 61216:                 }
 61216:                 goto error;
 61216:             }
 61216:         }
 48470: 
 48470:         /*
 61216:          * Non-global properties, and global properties which we aren't simply
 61216:          * redefining, must be set.  First, this preserves their attributes.
 61216:          * Second, this will produce warnings and/or errors as necessary if the
 61216:          * specified Call object property is not writable (const).
 48470:          */
 61216: 
 61216:         /* Step 5f. */
 97353:         if (!parent->setProperty(cx, name, rval.address(), script->strictModeCode))
 61216:             goto error;
 61216:     } while (false);
 48470: }
 48470: END_CASE(JSOP_DEFFUN)
 48470: 
 48470: BEGIN_CASE(JSOP_LAMBDA)
 48470: {
 48470:     /* Load the specified function object literal. */
 99421:     RootedFunction &fun = rootFunction0;
 95355:     fun = script->getFunction(GET_UINT32_INDEX(regs.pc));
 98921: 
 98921:     JSFunction *obj = CloneFunctionObjectIfNotSingleton(cx, fun, regs.fp()->scopeChain());
 48470:     if (!obj)
 48470:         goto error;
 48470: 
 76194:     JS_ASSERT(obj->getProto());
 48470:     PUSH_OBJECT(*obj);
 48470: }
 48470: END_CASE(JSOP_LAMBDA)
 48470: 
 48470: BEGIN_CASE(JSOP_CALLEE)
 69223:     JS_ASSERT(regs.fp()->isNonEvalFunctionFrame());
101075:     PUSH_COPY(regs.fp()->calleev());
 48470: END_CASE(JSOP_CALLEE)
 48470: 
 48470: BEGIN_CASE(JSOP_GETTER)
 48470: BEGIN_CASE(JSOP_SETTER)
 48470: {
 84195:     JSOp op2 = JSOp(*++regs.pc);
 99421:     RootedId &id = rootId0;
 48470:     Value rval;
 91450:     int i;
 48470:     JSObject *obj;
 48470:     switch (op2) {
 48470:       case JSOP_SETNAME:
 48470:       case JSOP_SETPROP:
 48470:       {
 86542:         PropertyName *name;
 86542:         LOAD_NAME(0, name);
 97828:         id = NameToId(name);
 48470:         rval = regs.sp[-1];
 48470:         i = -1;
 48470:         goto gs_pop_lval;
 48470:       }
 48470:       case JSOP_SETELEM:
 48470:         rval = regs.sp[-1];
 48470:         id = JSID_VOID;
 48470:         i = -2;
 48470:       gs_pop_lval:
 48470:         FETCH_OBJECT(cx, i - 1, obj);
 48470:         break;
 48470: 
 48470:       case JSOP_INITPROP:
 48470:       {
101075:         JS_ASSERT(regs.stackDepth() >= 2);
 48470:         rval = regs.sp[-1];
 48470:         i = -1;
 86542:         PropertyName *name;
 86542:         LOAD_NAME(0, name);
 97828:         id = NameToId(name);
 48470:         goto gs_get_lval;
 48470:       }
 48470:       default:
 48470:         JS_ASSERT(op2 == JSOP_INITELEM);
101075:         JS_ASSERT(regs.stackDepth() >= 3);
 48470:         rval = regs.sp[-1];
 48470:         id = JSID_VOID;
 48470:         i = -2;
 48470:       gs_get_lval:
 48470:       {
 48470:         const Value &lref = regs.sp[i-1];
 48470:         JS_ASSERT(lref.isObject());
 48470:         obj = &lref.toObject();
 48470:         break;
 48470:       }
 48470:     }
 48470: 
 48470:     /* Ensure that id has a type suitable for use with obj. */
 48470:     if (JSID_IS_VOID(id))
 48470:         FETCH_ELEMENT_ID(obj, i, id);
 48470: 
 48470:     if (!js_IsCallable(rval)) {
 86542:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_GETTER_OR_SETTER,
 86542:                              (op == JSOP_GETTER) ? js_getter_str : js_setter_str);
 48470:         goto error;
 48470:     }
 48470: 
 50518:     /*
 50518:      * Getters and setters are just like watchpoints from an access control
 50518:      * point of view.
 50518:      */
 48470:     Value rtmp;
 91237:     unsigned attrs;
 50518:     if (!CheckAccess(cx, obj, id, JSACC_WATCH, &rtmp, &attrs))
 50518:         goto error;
 48470: 
 62395:     PropertyOp getter;
 62395:     StrictPropertyOp setter;
 48470:     if (op == JSOP_GETTER) {
 48470:         getter = CastAsPropertyOp(&rval.toObject());
 78614:         setter = JS_StrictPropertyStub;
 48470:         attrs = JSPROP_GETTER;
 48470:     } else {
 78614:         getter = JS_PropertyStub;
 62395:         setter = CastAsStrictPropertyOp(&rval.toObject());
 48470:         attrs = JSPROP_SETTER;
 48470:     }
 48470:     attrs |= JSPROP_ENUMERATE | JSPROP_SHARED;
 48470: 
 80624:     if (!obj->defineGeneric(cx, id, UndefinedValue(), getter, setter, attrs))
 48470:         goto error;
 48470: 
 48470:     regs.sp += i;
 48470:     if (js_CodeSpec[op2].ndefs > js_CodeSpec[op2].nuses) {
 48470:         JS_ASSERT(js_CodeSpec[op2].ndefs == js_CodeSpec[op2].nuses + 1);
 48470:         regs.sp[-1] = rval;
 55638:         assertSameCompartment(cx, regs.sp[-1]);
 48470:     }
 48470:     len = js_CodeSpec[op2].length;
 48470:     DO_NEXT_OP(len);
 48470: }
 48470: 
 48470: BEGIN_CASE(JSOP_HOLE)
 48470:     PUSH_HOLE();
 48470: END_CASE(JSOP_HOLE)
 48470: 
 48470: BEGIN_CASE(JSOP_NEWINIT)
 48470: {
 87974:     uint8_t i = GET_UINT8(regs.pc);
 48470:     JS_ASSERT(i == JSProto_Array || i == JSProto_Object);
 87974: 
 48470:     JSObject *obj;
 48470:     if (i == JSProto_Array) {
 59234:         obj = NewDenseEmptyArray(cx);
 58056:     } else {
 83231:         gc::AllocKind kind = GuessObjectGCKind(0);
 77817:         obj = NewBuiltinClassInstance(cx, &ObjectClass, kind);
 58056:     }
 93664:     if (!obj || !SetInitializerObjectType(cx, script, regs.pc, obj))
 48470:         goto error;
 48470: 
 48470:     PUSH_OBJECT(*obj);
 99053:     TypeScript::Monitor(cx, script, regs.pc, regs.sp[-1]);
 99053: 
 48470:     CHECK_INTERRUPT_HANDLER();
 48470: }
 48470: END_CASE(JSOP_NEWINIT)
 48470: 
 58056: BEGIN_CASE(JSOP_NEWARRAY)
 58056: {
 58056:     unsigned count = GET_UINT24(regs.pc);
 59234:     JSObject *obj = NewDenseAllocatedArray(cx, count);
 93664:     if (!obj || !SetInitializerObjectType(cx, script, regs.pc, obj))
 58056:         goto error;
 58056: 
 58056:     PUSH_OBJECT(*obj);
 99053:     TypeScript::Monitor(cx, script, regs.pc, regs.sp[-1]);
 99053: 
 58056:     CHECK_INTERRUPT_HANDLER();
 58056: }
 58056: END_CASE(JSOP_NEWARRAY)
 58056: 
 58056: BEGIN_CASE(JSOP_NEWOBJECT)
 58056: {
 99421:     RootedObject &baseobj = rootObject0;
 95355:     baseobj = script->getObject(GET_UINT32_INDEX(regs.pc));
 95355: 
 99421:     RootedObject &obj = rootObject1;
 95355:     obj = CopyInitializerObject(cx, baseobj);
 93664:     if (!obj || !SetInitializerObjectType(cx, script, regs.pc, obj))
 58056:         goto error;
 58056: 
 58056:     PUSH_OBJECT(*obj);
 99053:     TypeScript::Monitor(cx, script, regs.pc, regs.sp[-1]);
 99053: 
 58056:     CHECK_INTERRUPT_HANDLER();
 58056: }
 58056: END_CASE(JSOP_NEWOBJECT)
 58056: 
 48470: BEGIN_CASE(JSOP_ENDINIT)
 48470: {
 51109:     /* FIXME remove JSOP_ENDINIT bug 588522 */
101075:     JS_ASSERT(regs.stackDepth() >= 1);
 51109:     JS_ASSERT(regs.sp[-1].isObject());
 48470: }
 48470: END_CASE(JSOP_ENDINIT)
 48470: 
 48470: BEGIN_CASE(JSOP_INITPROP)
 48470: {
 48470:     /* Load the property's initial value into rval. */
101075:     JS_ASSERT(regs.stackDepth() >= 2);
 48470:     Value rval = regs.sp[-1];
 48470: 
 48470:     /* Load the object being initialized into lval/obj. */
 99421:     RootedObject &obj = rootObject0;
 95355:     obj = &regs.sp[-2].toObject();
 60780:     JS_ASSERT(obj->isObject());
 48470: 
 99421:     RootedId &id = rootId0;
 98960: 
 97828:     PropertyName *name;
 97828:     LOAD_NAME(0, name);
 98960:     id = NameToId(name);
 97828: 
 97828:     if (JS_UNLIKELY(name == cx->runtime->atomState.protoAtom)
 98960:         ? !baseops::SetPropertyHelper(cx, obj, id, 0, &rval, script->strictModeCode)
 86855:         : !DefineNativeProperty(cx, obj, id, rval, NULL, NULL,
 94227:                                 JSPROP_ENUMERATE, 0, 0, 0)) {
 48470:         goto error;
 48470:     }
 86855: 
 48470:     regs.sp--;
 48470: }
 48470: END_CASE(JSOP_INITPROP);
 48470: 
101314: BEGIN_CASE(JSOP_INITELEM_INC)
 48470: BEGIN_CASE(JSOP_INITELEM)
 48470: {
 48470:     /* Pop the element's value into rval. */
101075:     JS_ASSERT(regs.stackDepth() >= 3);
 48470:     const Value &rref = regs.sp[-1];
 48470: 
 99421:     RootedObject &obj = rootObject0;
 97353: 
 48470:     /* Find the object being initialized at top of stack. */
 48470:     const Value &lref = regs.sp[-3];
 48470:     JS_ASSERT(lref.isObject());
 97353:     obj = &lref.toObject();
 48470: 
 48470:     /* Fetch id now that we have obj. */
 99421:     RootedId &id = rootId0;
 48470:     FETCH_ELEMENT_ID(obj, -2, id);
 48470: 
 48470:     /*
 48470:      * If rref is a hole, do not call JSObject::defineProperty. In this case,
 48470:      * obj must be an array, so if the current op is the last element
 48470:      * initialiser, set the array length to one greater than id.
 48470:      */
 48470:     if (rref.isMagic(JS_ARRAY_HOLE)) {
 48470:         JS_ASSERT(obj->isArray());
 48470:         JS_ASSERT(JSID_IS_INT(id));
 91688:         JS_ASSERT(uint32_t(JSID_TO_INT(id)) < StackSpace::ARGS_LENGTH_MAX);
 84195:         if (JSOp(regs.pc[JSOP_INITELEM_LENGTH]) == JSOP_ENDINIT &&
 91688:             !js_SetLengthProperty(cx, obj, (uint32_t) (JSID_TO_INT(id) + 1))) {
 48470:             goto error;
 48470:         }
 48470:     } else {
 80624:         if (!obj->defineGeneric(cx, id, rref, NULL, NULL, JSPROP_ENUMERATE))
 48470:             goto error;
 48470:     }
101314:     if (op == JSOP_INITELEM_INC) {
101314:         JS_ASSERT(obj->isArray());
101314:         if (JSID_TO_INT(id) == INT32_MAX) {
101314:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
101314:                                  JSMSG_SPREAD_TOO_LARGE);
101616:             goto error;
101314:         }
101314:         regs.sp[-2].setInt32(JSID_TO_INT(id) + 1);
101314:         regs.sp--;
101314:     } else {
 48470:         regs.sp -= 2;
 48470:     }
101314: }
 48470: END_CASE(JSOP_INITELEM)
 48470: 
101314: BEGIN_CASE(JSOP_SPREAD)
101314: {
101314:     int32_t count = regs.sp[-2].toInt32();
101715:     RootedObject arr(cx, &regs.sp[-3].toObject());
101314:     const Value iterable = regs.sp[-1];
101715:     ForOfIterator iter(cx, iterable);
101715:     while (iter.next()) {
101715:         if (count == INT32_MAX) {
101715:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
101715:                                  JSMSG_SPREAD_TOO_LARGE);
101715:             goto error;
101715:         }
101715:         if (!arr->defineElement(cx, count++, iter.value(), NULL, NULL, JSPROP_ENUMERATE))
101715:             goto error;
101715:     }
101715:     if (!iter.close())
101314:         goto error;
101314:     regs.sp[-2].setInt32(count);
101314:     regs.sp--;
101314: }
101314: END_CASE(JSOP_SPREAD)
101314: 
 48470: {
 48470: BEGIN_CASE(JSOP_GOSUB)
 48470:     PUSH_BOOLEAN(false);
 91450:     int32_t i = (regs.pc - script->code) + JSOP_GOSUB_LENGTH;
 48470:     len = GET_JUMP_OFFSET(regs.pc);
 48470:     PUSH_INT32(i);
 48470: END_VARLEN_CASE
 48470: }
 48470: 
 48470: {
 48470: BEGIN_CASE(JSOP_RETSUB)
 48470:     /* Pop [exception or hole, retsub pc-index]. */
 48470:     Value rval, lval;
 48470:     POP_COPY_TO(rval);
 48470:     POP_COPY_TO(lval);
 48470:     JS_ASSERT(lval.isBoolean());
 48470:     if (lval.toBoolean()) {
 48470:         /*
 48470:          * Exception was pending during finally, throw it *before* we adjust
 48470:          * pc, because pc indexes into script->trynotes.  This turns out not to
 48470:          * be necessary, but it seems clearer.  And it points out a FIXME:
 48470:          * 350509, due to Igor Bukanov.
 48470:          */
 60211:         cx->setPendingException(rval);
 48470:         goto error;
 48470:     }
 48470:     JS_ASSERT(rval.isInt32());
 48470:     len = rval.toInt32();
 77659:     regs.pc = script->code;
 48470: END_VARLEN_CASE
 48470: }
 48470: 
 48470: BEGIN_CASE(JSOP_EXCEPTION)
 60211:     PUSH_COPY(cx->getPendingException());
 60211:     cx->clearPendingException();
 48470:     CHECK_BRANCH();
 48470: END_CASE(JSOP_EXCEPTION)
 48470: 
 48470: BEGIN_CASE(JSOP_FINALLY)
 48470:     CHECK_BRANCH();
 48470: END_CASE(JSOP_FINALLY)
 48470: 
 48470: BEGIN_CASE(JSOP_THROWING)
 60211: {
 60211:     JS_ASSERT(!cx->isExceptionPending());
 60211:     Value v;
 60211:     POP_COPY_TO(v);
 60211:     cx->setPendingException(v);
 60211: }
 48470: END_CASE(JSOP_THROWING)
 48470: 
 48470: BEGIN_CASE(JSOP_THROW)
 60211: {
 60211:     JS_ASSERT(!cx->isExceptionPending());
 48470:     CHECK_BRANCH();
 60211:     Value v;
 60211:     POP_COPY_TO(v);
 60211:     cx->setPendingException(v);
 48470:     /* let the code at error try to catch the exception. */
 48470:     goto error;
 60211: }
 48470: 
 48470: BEGIN_CASE(JSOP_INSTANCEOF)
 48470: {
 48470:     const Value &rref = regs.sp[-1];
 48529:     if (rref.isPrimitive()) {
 48529:         js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS, -1, rref, NULL);
 48529:         goto error;
 48529:     }
 99421:     RootedObject &obj = rootObject0;
 98960:     obj = &rref.toObject();
 48470:     const Value &lref = regs.sp[-2];
 48470:     JSBool cond = JS_FALSE;
 48547:     if (!HasInstance(cx, obj, &lref, &cond))
 48470:         goto error;
 48470:     regs.sp--;
 48470:     regs.sp[-1].setBoolean(cond);
 48470: }
 48470: END_CASE(JSOP_INSTANCEOF)
 48470: 
 48470: BEGIN_CASE(JSOP_DEBUGGER)
 48470: {
 75402:     JSTrapStatus st = JSTRAP_CONTINUE;
 48470:     Value rval;
 91178:     if (JSDebuggerHandler handler = cx->runtime->debugHooks.debuggerHandler)
 91178:         st = handler(cx, script, regs.pc, &rval, cx->runtime->debugHooks.debuggerHandlerData);
 75402:     if (st == JSTRAP_CONTINUE)
 75513:         st = Debugger::onDebuggerStatement(cx, &rval);
 75402:     switch (st) {
 48470:       case JSTRAP_ERROR:
 48470:         goto error;
 48470:       case JSTRAP_CONTINUE:
 48470:         break;
 48470:       case JSTRAP_RETURN:
 69223:         regs.fp()->setReturnValue(rval);
 91435:         interpReturnOK = true;
 48470:         goto forced_return;
 48470:       case JSTRAP_THROW:
 60211:         cx->setPendingException(rval);
 48470:         goto error;
 48470:       default:;
 48470:     }
 48470:     CHECK_INTERRUPT_HANDLER();
 48470: }
 48470: END_CASE(JSOP_DEBUGGER)
 48470: 
 48470: #if JS_HAS_XML_SUPPORT
 48470: BEGIN_CASE(JSOP_DEFXMLNS)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 53568:     if (!js_SetDefaultXMLNamespace(cx, regs.sp[-1]))
 53568:         goto error;
 53568:     regs.sp--;
 48470: }
 48470: END_CASE(JSOP_DEFXMLNS)
 48470: 
 48470: BEGIN_CASE(JSOP_ANYNAME)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 97353:     cx->runtime->gcExactScanningEnabled = false;
 97353: 
 48470:     jsid id;
 48470:     if (!js_GetAnyName(cx, &id))
 48470:         goto error;
 48470:     PUSH_COPY(IdToValue(id));
 48470: }
 48470: END_CASE(JSOP_ANYNAME)
 98644: #endif
 48470: 
 48470: BEGIN_CASE(JSOP_QNAMEPART)
 48470: {
 80780:     /*
 80780:      * We do not JS_ASSERT(!script->strictModeCode) here because JSOP_QNAMEPART
 80780:      * is used for __proto__ and (in contexts where we favor JSOP_*ELEM instead
 80780:      * of JSOP_*PROP) obj.prop compiled as obj['prop'].
 80780:      */
 80780: 
 48470:     JSAtom *atom;
 48470:     LOAD_ATOM(0, atom);
 64345:     PUSH_STRING(atom);
 48470: }
 48470: END_CASE(JSOP_QNAMEPART)
 48470: 
 98644: #if JS_HAS_XML_SUPPORT
 48470: BEGIN_CASE(JSOP_QNAMECONST)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     JSAtom *atom;
 48470:     LOAD_ATOM(0, atom);
 64345:     Value rval = StringValue(atom);
 48470:     Value lval = regs.sp[-1];
 48470:     JSObject *obj = js_ConstructXMLQNameObject(cx, lval, rval);
 48470:     if (!obj)
 48470:         goto error;
 48470:     regs.sp[-1].setObject(*obj);
 48470: }
 48470: END_CASE(JSOP_QNAMECONST)
 48470: 
 48470: BEGIN_CASE(JSOP_QNAME)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     Value rval = regs.sp[-1];
 48470:     Value lval = regs.sp[-2];
 48470:     JSObject *obj = js_ConstructXMLQNameObject(cx, lval, rval);
 48470:     if (!obj)
 48470:         goto error;
 48470:     regs.sp--;
 48470:     regs.sp[-1].setObject(*obj);
 48470: }
 48470: END_CASE(JSOP_QNAME)
 48470: 
 48470: BEGIN_CASE(JSOP_TOATTRNAME)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     Value rval;
 48470:     rval = regs.sp[-1];
 48470:     if (!js_ToAttributeName(cx, &rval))
 48470:         goto error;
 48470:     regs.sp[-1] = rval;
 48470: }
 48470: END_CASE(JSOP_TOATTRNAME)
 48470: 
 48470: BEGIN_CASE(JSOP_TOATTRVAL)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     Value rval;
 48470:     rval = regs.sp[-1];
 48470:     JS_ASSERT(rval.isString());
 48470:     JSString *str = js_EscapeAttributeValue(cx, rval.toString(), JS_FALSE);
 48470:     if (!str)
 48470:         goto error;
 48470:     regs.sp[-1].setString(str);
 48470: }
 48470: END_CASE(JSOP_TOATTRVAL)
 48470: 
 48470: BEGIN_CASE(JSOP_ADDATTRNAME)
 48470: BEGIN_CASE(JSOP_ADDATTRVAL)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     Value rval = regs.sp[-1];
 48470:     Value lval = regs.sp[-2];
 48470:     JSString *str = lval.toString();
 48470:     JSString *str2 = rval.toString();
 48470:     str = js_AddAttributePart(cx, op == JSOP_ADDATTRNAME, str, str2);
 48470:     if (!str)
 48470:         goto error;
 48470:     regs.sp--;
 48470:     regs.sp[-1].setString(str);
 48470: }
 48470: END_CASE(JSOP_ADDATTRNAME)
 48470: 
 48470: BEGIN_CASE(JSOP_BINDXMLNAME)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     Value lval;
 48470:     lval = regs.sp[-1];
 48470:     JSObject *obj;
 48470:     jsid id;
 48470:     if (!js_FindXMLProperty(cx, lval, &obj, &id))
 48470:         goto error;
 48470:     regs.sp[-1].setObjectOrNull(obj);
 48470:     PUSH_COPY(IdToValue(id));
 48470: }
 48470: END_CASE(JSOP_BINDXMLNAME)
 48470: 
 48470: BEGIN_CASE(JSOP_SETXMLNAME)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     JSObject *obj = &regs.sp[-3].toObject();
 48470:     Value rval = regs.sp[-1];
 99421:     RootedId &id = rootId0;
 48470:     FETCH_ELEMENT_ID(obj, -2, id);
 80625:     if (!obj->setGeneric(cx, id, &rval, script->strictModeCode))
 48470:         goto error;
 48470:     rval = regs.sp[-1];
 48470:     regs.sp -= 2;
 48470:     regs.sp[-1] = rval;
 48470: }
 48470: END_CASE(JSOP_SETXMLNAME)
 48470: 
 48470: BEGIN_CASE(JSOP_CALLXMLNAME)
 48470: BEGIN_CASE(JSOP_XMLNAME)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     Value lval = regs.sp[-1];
 48470:     JSObject *obj;
 99421:     RootedId &id = rootId0;
 98960:     if (!js_FindXMLProperty(cx, lval, &obj, id.address()))
 48470:         goto error;
 48470:     Value rval;
 78675:     if (!obj->getGeneric(cx, id, &rval))
 48470:         goto error;
 48470:     regs.sp[-1] = rval;
 86855:     if (op == JSOP_CALLXMLNAME) {
 86855:         Value v;
 86855:         if (!ComputeImplicitThis(cx, obj, &v))
 86855:             goto error;
 86855:         PUSH_COPY(v);
 86855:     }
 48470: }
 48470: END_CASE(JSOP_XMLNAME)
 48470: 
 48470: BEGIN_CASE(JSOP_DESCENDANTS)
 48470: BEGIN_CASE(JSOP_DELDESC)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     JSObject *obj;
 48470:     FETCH_OBJECT(cx, -2, obj);
 78614:     jsval rval = regs.sp[-1];
 48470:     if (!js_GetXMLDescendants(cx, obj, rval, &rval))
 48470:         goto error;
 48470: 
 48470:     if (op == JSOP_DELDESC) {
 78614:         regs.sp[-1] = rval;   /* set local root */
 48470:         if (!js_DeleteXMLListElements(cx, JSVAL_TO_OBJECT(rval)))
 48470:             goto error;
 48470:         rval = JSVAL_TRUE;                  /* always succeed */
 48470:     }
 48470: 
 48470:     regs.sp--;
 78614:     regs.sp[-1] = rval;
 48470: }
 48470: END_CASE(JSOP_DESCENDANTS)
 48470: 
 48470: BEGIN_CASE(JSOP_FILTER)
 80780: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     /*
 48470:      * We push the hole value before jumping to [enditer] so we can detect the
 48470:      * first iteration and direct js_StepXMLListFilter to initialize filter's
 48470:      * state.
 48470:      */
 48470:     PUSH_HOLE();
 48470:     len = GET_JUMP_OFFSET(regs.pc);
 48470:     JS_ASSERT(len > 0);
 80780: }
 48470: END_VARLEN_CASE
 48470: 
 48470: BEGIN_CASE(JSOP_ENDFILTER)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     bool cond = !regs.sp[-1].isMagic();
 48470:     if (cond) {
 48470:         /* Exit the "with" block left from the previous iteration. */
 98921:         regs.fp()->popWith(cx);
 48470:     }
 48470:     if (!js_StepXMLListFilter(cx, cond))
 48470:         goto error;
 48470:     if (!regs.sp[-1].isNull()) {
 48470:         /*
 48470:          * Decrease sp after EnterWith returns as we use sp[-1] there to root
 48470:          * temporaries.
 48470:          */
 48470:         JS_ASSERT(IsXML(regs.sp[-1]));
 86077:         if (!EnterWith(cx, -2))
 48470:             goto error;
 48470:         regs.sp--;
 48470:         len = GET_JUMP_OFFSET(regs.pc);
 48470:         JS_ASSERT(len < 0);
 48470:         BRANCH(len);
 48470:     }
 48470:     regs.sp--;
 48470: }
 48470: END_CASE(JSOP_ENDFILTER);
 48470: 
 48470: BEGIN_CASE(JSOP_TOXML)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 97353:     cx->runtime->gcExactScanningEnabled = false;
 97353: 
 48470:     Value rval = regs.sp[-1];
 48470:     JSObject *obj = js_ValueToXMLObject(cx, rval);
 48470:     if (!obj)
 48470:         goto error;
 48470:     regs.sp[-1].setObject(*obj);
 48470: }
 48470: END_CASE(JSOP_TOXML)
 48470: 
 48470: BEGIN_CASE(JSOP_TOXMLLIST)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     Value rval = regs.sp[-1];
 48470:     JSObject *obj = js_ValueToXMLListObject(cx, rval);
 48470:     if (!obj)
 48470:         goto error;
 48470:     regs.sp[-1].setObject(*obj);
 48470: }
 48470: END_CASE(JSOP_TOXMLLIST)
 48470: 
 48470: BEGIN_CASE(JSOP_XMLTAGEXPR)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     Value rval = regs.sp[-1];
 84160:     JSString *str = ToString(cx, rval);
 48470:     if (!str)
 48470:         goto error;
 48470:     regs.sp[-1].setString(str);
 48470: }
 48470: END_CASE(JSOP_XMLTAGEXPR)
 48470: 
 48470: BEGIN_CASE(JSOP_XMLELTEXPR)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     Value rval = regs.sp[-1];
 48470:     JSString *str;
 48470:     if (IsXML(rval)) {
 48470:         str = js_ValueToXMLString(cx, rval);
 48470:     } else {
 84160:         str = ToString(cx, rval);
 48470:         if (str)
 48470:             str = js_EscapeElementValue(cx, str);
 48470:     }
 48470:     if (!str)
 48470:         goto error;
 48470:     regs.sp[-1].setString(str);
 48470: }
 48470: END_CASE(JSOP_XMLELTEXPR)
 48470: 
 48470: BEGIN_CASE(JSOP_XMLCDATA)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 90965:     JSAtom *atom = script->getAtom(GET_UINT32_INDEX(regs.pc));
 90965:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_TEXT, NULL, atom);
 48470:     if (!obj)
 48470:         goto error;
 48470:     PUSH_OBJECT(*obj);
 48470: }
 48470: END_CASE(JSOP_XMLCDATA)
 48470: 
 48470: BEGIN_CASE(JSOP_XMLCOMMENT)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 90965:     JSAtom *atom = script->getAtom(GET_UINT32_INDEX(regs.pc));
 90965:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_COMMENT, NULL, atom);
 48470:     if (!obj)
 48470:         goto error;
 48470:     PUSH_OBJECT(*obj);
 48470: }
 48470: END_CASE(JSOP_XMLCOMMENT)
 48470: 
 48470: BEGIN_CASE(JSOP_XMLPI)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 90965:     JSAtom *atom = script->getAtom(GET_UINT32_INDEX(regs.pc));
 48470:     Value rval = regs.sp[-1];
 48470:     JSString *str2 = rval.toString();
 90965:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_PROCESSING_INSTRUCTION, atom, str2);
 48470:     if (!obj)
 48470:         goto error;
 48470:     regs.sp[-1].setObject(*obj);
 48470: }
 48470: END_CASE(JSOP_XMLPI)
 48470: 
 48470: BEGIN_CASE(JSOP_GETFUNNS)
 48470: {
 80780:     JS_ASSERT(!script->strictModeCode);
 80780: 
 48470:     Value rval;
 96793:     if (!cx->fp()->global().getFunctionNamespace(cx, &rval))
 48470:         goto error;
 48470:     PUSH_COPY(rval);
 48470: }
 48470: END_CASE(JSOP_GETFUNNS)
 48470: #endif /* JS_HAS_XML_SUPPORT */
 48470: 
 48470: BEGIN_CASE(JSOP_ENTERBLOCK)
 86078: BEGIN_CASE(JSOP_ENTERLET0)
 86078: BEGIN_CASE(JSOP_ENTERLET1)
 48470: {
 89253:     StaticBlockObject &blockObj = script->getObject(GET_UINT32_INDEX(regs.pc))->asStaticBlock();
 98921: 
101075:     if (op == JSOP_ENTERBLOCK) {
101075:         JS_ASSERT(regs.stackDepth() == blockObj.stackDepth());
101075:         JS_ASSERT(regs.stackDepth() + blockObj.slotCount() <= script->nslots);
101075:         Value *vp = regs.sp + blockObj.slotCount();
101075:         SetValueRangeToUndefined(regs.sp, vp);
101075:         regs.sp = vp;
101075:     }
101075: 
 98921:     /* Clone block iff there are any closed-over variables. */
 98921:     if (!regs.fp()->pushBlock(cx, blockObj))
 98921:         goto error;
 48470: }
 48470: END_CASE(JSOP_ENTERBLOCK)
 48470: 
 86078: BEGIN_CASE(JSOP_LEAVEBLOCK)
 86078: BEGIN_CASE(JSOP_LEAVEFORLETIN)
 48470: BEGIN_CASE(JSOP_LEAVEBLOCKEXPR)
 48470: {
 98921:     DebugOnly<uint32_t> blockDepth = regs.fp()->blockChain().stackDepth();
 98921: 
 98921:     regs.fp()->popBlock(cx);
 86077: 
 86078:     if (op == JSOP_LEAVEBLOCK) {
 86078:         /* Pop the block's slots. */
 48470:         regs.sp -= GET_UINT16(regs.pc);
101075:         JS_ASSERT(regs.stackDepth() == blockDepth);
 86078:     } else if (op == JSOP_LEAVEBLOCKEXPR) {
 86078:         /* Pop the block's slots maintaining the topmost expr. */
 86078:         Value *vp = &regs.sp[-1];
 86078:         regs.sp -= GET_UINT16(regs.pc);
101075:         JS_ASSERT(regs.stackDepth() == blockDepth + 1);
 48470:         regs.sp[-1] = *vp;
 48470:     } else {
 86078:         /* Another op will pop; nothing to do here. */
 86078:         len = JSOP_LEAVEFORLETIN_LENGTH;
 86078:         DO_NEXT_OP(len);
 48470:     }
 48470: }
 48470: END_CASE(JSOP_LEAVEBLOCK)
 48470: 
 48470: #if JS_HAS_GENERATORS
 48470: BEGIN_CASE(JSOP_GENERATOR)
 48470: {
 60211:     JS_ASSERT(!cx->isExceptionPending());
101075:     regs.fp()->initGeneratorFrame();
 48470:     regs.pc += JSOP_GENERATOR_LENGTH;
 48470:     JSObject *obj = js_NewGenerator(cx);
 48470:     if (!obj)
 48470:         goto error;
 69223:     regs.fp()->setReturnValue(ObjectValue(*obj));
101075:     regs.fp()->setYielding();
 48470:     interpReturnOK = true;
 69223:     if (entryFrame != regs.fp())
 48470:         goto inline_return;
 48470:     goto exit;
 48470: }
 48470: 
 48470: BEGIN_CASE(JSOP_YIELD)
 60211:     JS_ASSERT(!cx->isExceptionPending());
 69223:     JS_ASSERT(regs.fp()->isNonEvalFunctionFrame());
101075:     if (cx->innermostGenerator()->state == JSGEN_CLOSING) {
101075:         js_ReportValueError(cx, JSMSG_BAD_GENERATOR_YIELD, JSDVG_SEARCH_STACK,
101075:                             ObjectValue(regs.fp()->callee()), NULL);
 53840:         goto error;
 53840:     }
 69223:     regs.fp()->setReturnValue(regs.sp[-1]);
 69223:     regs.fp()->setYielding();
 48470:     regs.pc += JSOP_YIELD_LENGTH;
 91435:     interpReturnOK = true;
 48470:     goto exit;
 48470: 
 48470: BEGIN_CASE(JSOP_ARRAYPUSH)
 48470: {
 84755:     uint32_t slot = GET_UINT16(regs.pc);
 48470:     JS_ASSERT(script->nfixed <= slot);
 48470:     JS_ASSERT(slot < script->nslots);
 99421:     RootedObject &obj = rootObject0;
101075:     obj = &regs.fp()->unaliasedLocal(slot).toObject();
 73079:     if (!js_NewbornArrayPush(cx, obj, regs.sp[-1]))
 48470:         goto error;
 48470:     regs.sp--;
 48470: }
 48470: END_CASE(JSOP_ARRAYPUSH)
 48470: #endif /* JS_HAS_GENERATORS */
 48470: 
 48470: #if JS_THREADED_INTERP
 48470:   L_JSOP_BACKPATCH:
 48470:   L_JSOP_BACKPATCH_POP:
 48470: 
 48470: # if !JS_HAS_GENERATORS
 48470:   L_JSOP_GENERATOR:
 48470:   L_JSOP_YIELD:
 48470:   L_JSOP_ARRAYPUSH:
 48470: # endif
 48470: 
 48470: # if !JS_HAS_DESTRUCTURING
 48470:   L_JSOP_ENUMCONSTELEM:
 48470: # endif
 48470: 
 48470: # if !JS_HAS_XML_SUPPORT
 48470:   L_JSOP_CALLXMLNAME:
 48470:   L_JSOP_STARTXMLEXPR:
 48470:   L_JSOP_STARTXML:
 48470:   L_JSOP_DELDESC:
 48470:   L_JSOP_GETFUNNS:
 48470:   L_JSOP_XMLPI:
 48470:   L_JSOP_XMLCOMMENT:
 48470:   L_JSOP_XMLCDATA:
 48470:   L_JSOP_XMLELTEXPR:
 48470:   L_JSOP_XMLTAGEXPR:
 48470:   L_JSOP_TOXMLLIST:
 48470:   L_JSOP_TOXML:
 48470:   L_JSOP_ENDFILTER:
 48470:   L_JSOP_FILTER:
 48470:   L_JSOP_DESCENDANTS:
 48470:   L_JSOP_XMLNAME:
 48470:   L_JSOP_SETXMLNAME:
 48470:   L_JSOP_BINDXMLNAME:
 48470:   L_JSOP_ADDATTRVAL:
 48470:   L_JSOP_ADDATTRNAME:
 48470:   L_JSOP_TOATTRVAL:
 48470:   L_JSOP_TOATTRNAME:
 48470:   L_JSOP_QNAME:
 48470:   L_JSOP_QNAMECONST:
 48470:   L_JSOP_ANYNAME:
 48470:   L_JSOP_DEFXMLNS:
 48470: # endif
 48470: 
 48470: #endif /* !JS_THREADED_INTERP */
 31481: #if !JS_THREADED_INTERP
     1:           default:
     1: #endif
     1:           {
     1:             char numBuf[12];
     1:             JS_snprintf(numBuf, sizeof numBuf, "%d", op);
     1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
     1:                                  JSMSG_BAD_BYTECODE, numBuf);
 11859:             goto error;
     1:           }
     1: 
     1: #if !JS_THREADED_INTERP
     1:         } /* switch (op) */
 23111:     } /* for (;;) */
     1: #endif /* !JS_THREADED_INTERP */
     1: 
 11859:   error:
 69223:     JS_ASSERT(&cx->regs() == &regs);
 84755:     JS_ASSERT(uint32_t(regs.pc - script->code) < script->length);
 24245: 
 94586:     /* When rejoining, we must not err before finishing Interpret's prologue. */
 94586:     JS_ASSERT(interpMode != JSINTERP_REJOIN);
 94586: 
 91947:     if (cx->isExceptionPending()) {
 59996:         /* Restore atoms local in case we will resume. */
 77659:         atoms = script->atoms;
 59996: 
 11758:         /* Call debugger throw hook if set. */
 91178:         if (cx->runtime->debugHooks.throwHook || !cx->compartment->getDebuggees().empty()) {
 75439:             Value rval;
 76226:             JSTrapStatus st = Debugger::onExceptionUnwind(cx, &rval);
 75439:             if (st == JSTRAP_CONTINUE) {
 91947:                 if (JSThrowHook handler = cx->runtime->debugHooks.throwHook)
 91178:                     st = handler(cx, script, regs.pc, &rval, cx->runtime->debugHooks.throwHookData);
 75439:             }
 75439: 
 75439:             switch (st) {
     1:               case JSTRAP_ERROR:
 60211:                 cx->clearPendingException();
 11859:                 goto error;
     1:               case JSTRAP_RETURN:
 60211:                 cx->clearPendingException();
 69223:                 regs.fp()->setReturnValue(rval);
 91435:                 interpReturnOK = true;
 11758:                 goto forced_return;
     1:               case JSTRAP_THROW:
 60211:                 cx->setPendingException(rval);
     1:               case JSTRAP_CONTINUE:
     1:               default:;
     1:             }
 23111:             CHECK_INTERRUPT_HANDLER();
     1:         }
     1: 
 91947:         for (TryNoteIter tni(regs); !tni.done(); ++tni) {
 91947:             JSTryNote *tn = *tni;
 91947: 
 91947:             UnwindScope(cx, tn->stackDepth);
  3025: 
  3025:             /*
  3025:              * Set pc to the first bytecode after the the try note to point
  3025:              * to the beginning of catch or finally or to [enditer] closing
  3025:              * the for-in loop.
  1825:              */
 77659:             regs.pc = (script)->main() + tn->start + tn->length;
101075:             regs.sp = regs.spForStackDepth(tn->stackDepth);
  1825: 
  3025:             switch (tn->kind) {
 20420:               case JSTRY_CATCH:
 86077:                   JS_ASSERT(*regs.pc == JSOP_ENTERBLOCK);
 86077: 
  3025: #if JS_HAS_GENERATORS
  3025:                 /* Catch cannot intercept the closing of a generator. */
 60211:                   if (JS_UNLIKELY(cx->getPendingException().isMagic(JS_GENERATOR_CLOSING)))
  3025:                     break;
  3025: #endif
  3025: 
  1825:                 /*
 60211:                  * Don't clear exceptions to save cx->exception from GC
  3025:                  * until it is pushed to the stack via [exception] in the
  3025:                  * catch block.
  3025:                  */
  3025:                 len = 0;
  3025:                 DO_NEXT_OP(len);
  3025: 
 20420:               case JSTRY_FINALLY:
  3025:                 /*
  3025:                  * Push (true, exception) pair for finally to indicate that
  1825:                  * [retsub] should rethrow the exception.
  1825:                  */
 48470:                 PUSH_BOOLEAN(true);
 60211:                 PUSH_COPY(cx->getPendingException());
 60211:                 cx->clearPendingException();
  3025:                 len = 0;
  3025:                 DO_NEXT_OP(len);
  3025: 
 42641:               case JSTRY_ITER: {
 42641:                 /* This is similar to JSOP_ENDITER in the interpreter loop. */
 84195:                 JS_ASSERT(JSOp(*regs.pc) == JSOP_ENDITER);
 91160:                 bool ok = UnwindIteratorForException(cx, &regs.sp[-1].toObject());
 42641:                 regs.sp -= 1;
 11859:                 if (!ok)
 11859:                     goto error;
 42641:               }
 11859:            }
 91947:         }
 91947: 
  3025:         /*
 11859:          * Propagate the exception or error to the caller unless the exception
 11859:          * is an asynchronous return from a generator.
  3025:          */
 91435:         interpReturnOK = false;
  1969: #if JS_HAS_GENERATORS
 60211:         if (JS_UNLIKELY(cx->isExceptionPending() &&
 60211:                         cx->getPendingException().isMagic(JS_GENERATOR_CLOSING))) {
 60211:             cx->clearPendingException();
 91435:             interpReturnOK = true;
 69223:             regs.fp()->clearReturnValue();
  1969:         }
  1969: #endif
 91947:     } else {
 91947:         UnwindForUncatchableException(cx, regs);
 91947:         interpReturnOK = false;
     1:     }
     1: 
 11758:   forced_return:
 86484:     UnwindScope(cx, 0);
 97878:     regs.setToEndOfScript();
 11758: 
 69223:     if (entryFrame != regs.fp())
     1:         goto inline_return;
     1: 
 11758:   exit:
 84067:     if (cx->compartment->debugMode())
 84067:         interpReturnOK = ScriptDebugEpilogue(cx, regs.fp(), interpReturnOK);
101075:     if (!regs.fp()->isYielding())
101075:         regs.fp()->epilogue(cx);
 69223:     regs.fp()->setFinishedInInterpreter();
 56201: 
 73087: #ifdef JS_METHODJIT
 56201:     /*
 56201:      * This path is used when it's guaranteed the method can be finished
 56201:      * inside the JIT.
 56201:      */
 56201:   leave_on_safe_point:
 53145: #endif
 73087: 
 90410:     gc::MaybeVerifyBarriers(cx, true);
 53133:     return interpReturnOK;
 86542: }
