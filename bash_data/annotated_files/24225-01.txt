17092: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
17092:  *
17092:  * ***** BEGIN LICENSE BLOCK *****
17092:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
17092:  *
17092:  * The contents of this file are subject to the Mozilla Public License Version
17092:  * 1.1 (the "License"); you may not use this file except in compliance with
17092:  * the License. You may obtain a copy of the License at
17092:  * http://www.mozilla.org/MPL/
17092:  *
17092:  * Software distributed under the License is distributed on an "AS IS" basis,
17092:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
17092:  * for the specific language governing rights and limitations under the
17092:  * License.
17092:  *
17092:  * The Original Code is mozilla.org code.
17092:  *
17092:  * The Initial Developer of the Original Code is
17092:  *   Mozilla Foundation
17092:  * Portions created by the Initial Developer are Copyright (C) 2008
17092:  * the Initial Developer. All Rights Reserved.
17092:  *
17092:  * Contributor(s):
17092:  *   Jason Orendorff <jorendorff@mozilla.com>
17092:  *
17092:  * Alternatively, the contents of this file may be used under the terms of
17092:  * either of the GNU General Public License Version 2 or later (the "GPL"),
17092:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
17092:  * in which case the provisions of the GPL or the LGPL are applicable instead
17092:  * of those above. If you wish to allow use of your version of this file only
17092:  * under the terms of either the GPL or the LGPL, and not to allow others to
17092:  * use your version of this file under the terms of the MPL, indicate your
17092:  * decision by deleting the provisions above and replace them with the notice
17092:  * and other provisions required by the GPL or the LGPL. If you do not delete
17092:  * the provisions above, a recipient may use your version of this file under
17092:  * the terms of any one of the MPL, the GPL or the LGPL.
17092:  *
17092:  * ***** END LICENSE BLOCK ***** */
17092: 
17092: #include "jsapi.h"
17092: #include "jsobj.h"
17092: #include "jsstr.h"
17092: #include "jscntxt.h"  /* for error messages */
17092: #include "nsCOMPtr.h"
17092: #include "xpcprivate.h"
17092: #include "xpcinlines.h"
17092: #include "xpcquickstubs.h"
17092: #include "XPCWrapper.h"
17092: #include "XPCNativeWrapper.h"
17092: 
17092: static const xpc_qsHashEntry *
17092: LookupEntry(PRUint32 tableSize, const xpc_qsHashEntry *table, const nsID &iid)
17092: {
17092:     size_t i;
17092:     const xpc_qsHashEntry *p;
17092: 
17092:     i = iid.m0 % tableSize;
17092:     do
17092:     {
17092:         p = table + i;
17092:         if(p->iid.Equals(iid))
17092:             return p;
17092:         i = p->chain;
17092:     } while(i != XPC_QS_NULL_INDEX);
17092:     return nsnull;
17092: }
17092: 
17092: static const xpc_qsHashEntry *
17092: LookupInterfaceOrAncestor(PRUint32 tableSize, const xpc_qsHashEntry *table,
17092:                           const nsID &iid)
17092: {
17092:     const xpc_qsHashEntry *p = LookupEntry(tableSize, table, iid);
17092:     if(!p)
17092:     {
17092:         /*
17092:          * On a miss, we have to search for every interface the object
17092:          * supports, including ancestors.
17092:          */
17092:         nsCOMPtr<nsIInterfaceInfo> info;
17092:         if(NS_FAILED(nsXPConnect::GetXPConnect()->GetInfoForIID(
17092:                           &iid, getter_AddRefs(info))))
17092:             return nsnull;
17092: 
17092:         nsIID *piid;
17092:         for(;;)
17092:         {
17092:             nsCOMPtr<nsIInterfaceInfo> parent;
17092:             if(NS_FAILED(info->GetParent(getter_AddRefs(parent))) ||
17092:                !parent ||
17092:                NS_FAILED(parent->GetInterfaceIID(&piid)))
17092:             {
17092:                 break;
17092:             }
17092:             p = LookupEntry(tableSize, table, *piid);
17092:             if(p)
17092:                 break;
17092:             info.swap(parent);
17092:         }
17092:     }
17092:     return p;
17092: }
17092: 
24145: static JSBool
24145: PropertyOpForwarder(JSContext *cx, uintN argc, jsval *vp)
24145: {
24145:     // Layout:
24145:     //   this = our this
24145:     //   property op to call = callee reserved slot 0
24145:     //   name of the property = callee reserved slot 1
24145: 
24145:     JSObject *callee = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));
24145:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
24145:     jsval v;
24145: 
24145:     if(!JS_GetReservedSlot(cx, callee, 0, &v))
24145:         return JS_FALSE;
24145:     JSObject *ptrobj = JSVAL_TO_OBJECT(v);
24145:     JSPropertyOp *popp = static_cast<JSPropertyOp *>(JS_GetPrivate(cx, ptrobj));
24145: 
24145:     if(!JS_GetReservedSlot(cx, callee, 1, &v))
24145:         return JS_FALSE;
24145: 
24225:     jsval argval = (argc > 0) ? JS_ARGV(cx, vp)[0] : JSVAL_VOID;
24225:     JS_SET_RVAL(cx, vp, argval);
24145:     return (*popp)(cx, obj, v, vp);
24145: }
24145: 
24145: static void
24145: PointerFinalize(JSContext *cx, JSObject *obj)
24145: {
24145:     JSPropertyOp *popp = static_cast<JSPropertyOp *>(JS_GetPrivate(cx, obj));
24145:     delete popp;
24145: }
24145: 
24145: static JSClass
24145: PointerHolderClass = {
24145:     "Pointer", JSCLASS_HAS_PRIVATE,
24145:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,
24145:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, PointerFinalize,
24145:     JSCLASS_NO_OPTIONAL_MEMBERS
24145: };
24145: 
24145: static JSObject *
24145: GeneratePropertyOp(JSContext *cx, JSObject *obj, jsval idval, uintN argc,
24145:                    const char *name, JSPropertyOp pop)
24145: {
24145:     // The JS engine provides two reserved slots on function objects for
24145:     // XPConnect to use. Use them to stick the necessary info here.
24145:     JSFunction *fun =
24145:         JS_NewFunction(cx, reinterpret_cast<JSNative>(PropertyOpForwarder),
24145:                        argc, JSFUN_FAST_NATIVE, obj, name);
24145:     if(!fun)
24145:         return JS_FALSE;
24145: 
24145:     JSObject *funobj = JS_GetFunctionObject(fun);
24145: 
24145:     JSAutoTempValueRooter tvr(cx, OBJECT_TO_JSVAL(funobj));
24145: 
24145:     // Unfortunately, we cannot guarantee that JSPropertyOp is aligned. Use a
24145:     // second object to work around this.
24145:     JSObject *ptrobj = JS_NewObject(cx, &PointerHolderClass, nsnull, funobj);
24145:     if(!ptrobj)
24145:         return JS_FALSE;
24145:     JSPropertyOp *popp = new JSPropertyOp;
24145:     if(!popp)
24145:         return JS_FALSE;
24145:     *popp = pop;
24145:     JS_SetPrivate(cx, ptrobj, popp);
24145: 
24145:     JS_SetReservedSlot(cx, funobj, 0, OBJECT_TO_JSVAL(ptrobj));
24145:     JS_SetReservedSlot(cx, funobj, 1, idval);
24145:     return funobj;
24145: }
24145: 
24145: static JSBool
24145: ReifyPropertyOps(JSContext *cx, JSObject *obj, jsval idval, jsid interned_id,
24145:                  const char *name, JSPropertyOp getter, JSPropertyOp setter,
24145:                  JSObject **getterobjp, JSObject **setterobjp)
24145: {
24145:     // Generate both getter and setter and stash them in the prototype.
24145:     jsval roots[2] = { JSVAL_NULL, JSVAL_NULL };
24145:     JSAutoTempValueRooter tvr(cx, 2, roots);
24145: 
24145:     uintN attrs = JSPROP_SHARED;
24145:     JSObject *getterobj;
24145:     if(getter)
24145:     {
24145:         getterobj = GeneratePropertyOp(cx, obj, idval, 0, name, getter);
24145:         if(!getterobj)
24145:             return JS_FALSE;
24145:         roots[0] = OBJECT_TO_JSVAL(getterobj);
24145:         attrs |= JSPROP_GETTER;
24145:     }
24145:     else
24145:         getterobj = nsnull;
24145: 
24145:     JSObject *setterobj;
24145:     if (setter)
24145:     {
24145:         setterobj = GeneratePropertyOp(cx, obj, idval, 1, name, setter);
24145:         if(!setterobj)
24145:             return JS_FALSE;
24145:         roots[1] = OBJECT_TO_JSVAL(setterobj);
24145:         attrs |= JSPROP_SETTER;
24145:     }
24145:     else
24145:         setterobj = nsnull;
24145: 
24145:     if(getterobjp)
24145:         *getterobjp = getterobj;
24145:     if(setterobjp)
24145:         *setterobjp = setterobj;
24145:     return JS_DefinePropertyById(cx, obj, interned_id, JSVAL_VOID,
24145:                                  (JSPropertyOp)getterobj,
24145:                                  (JSPropertyOp)setterobj,
24145:                                  attrs);
24145: }
24145: 
24145: static JSBool
24145: LookupGetterOrSetter(JSContext *cx, JSBool wantGetter, jsval *vp)
24145: {
24145:     uintN attrs;
24145:     JSBool found;
24145:     JSPropertyOp getter, setter;
24145:     JSObject *obj2;
24145:     jsid interned_id;
24145:     jsval v;
24145: 
24145:     XPC_QS_ASSERT_CONTEXT_OK(cx);
24145:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
24145:     if (!obj)
24145:         return JS_FALSE;
24145:     jsval idval = JS_ARGV(cx, vp)[0];
24145: 
24145:     const char *name = JSVAL_IS_STRING(idval)
24145:                        ? JS_GetStringBytes(JSVAL_TO_STRING(idval))
24145:                        : nsnull;
24145:     if(!JS_ValueToId(cx, idval, &interned_id) ||
24145:        !JS_LookupPropertyWithFlagsById(cx, obj, interned_id,
24145:                                        JSRESOLVE_QUALIFIED, &obj2, &v) ||
24145:        (obj2 &&
24145:         !JS_GetPropertyAttrsGetterAndSetterById(cx, obj2, interned_id, &attrs,
24145:                                                 &found, &getter, &setter)))
24145:         return JS_FALSE;
24145: 
24145:     // No property at all means no getters or setters possible.
24145:     if(!obj2 || !found)
24145:     {
24145:         JS_SET_RVAL(cx, vp, JSVAL_VOID);
24145:         return JS_TRUE;
24145:     }
24145: 
24145:     // Inline obj_lookup[GS]etter here.
24145:     if(wantGetter)
24145:     {
24145:         if(attrs & JSPROP_GETTER)
24145:         {
24145:             JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(getter));
24145:             return JS_TRUE;
24145:         }
24145:     }
24145:     else
24145:     {
24145:         if(attrs & JSPROP_SETTER)
24145:         {
24145:             JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(setter));
24145:             return JS_TRUE;
24145:         }
24145:     }
24145: 
24145:     // Since XPConnect doesn't use JSPropertyOps in any other contexts,
24145:     // ensuring that we have an XPConnect prototype object ensures that
24145:     // we are only going to expose quickstubbed properties to script.
24145:     // Also be careful not to overwrite existing properties!
24145:     if(!name ||
24145:        !IS_PROTO_CLASS(STOBJ_GET_CLASS(obj2)) ||
24145:        (attrs & (JSPROP_GETTER | JSPROP_SETTER)) ||
24145:        !(getter || setter))
24145:     {
24145:         JS_SET_RVAL(cx, vp, JSVAL_VOID);
24145:         return JS_TRUE;
24145:     }
24145: 
24145:     JSObject *getterobj, *setterobj;
24145:     if(!ReifyPropertyOps(cx, obj, idval, interned_id, name, getter, setter,
24145:                          &getterobj, &setterobj))
24145:         return JS_FALSE;
24145: 
24145:     JSObject *wantedobj = wantGetter ? getterobj : setterobj;
24145:     v = wantedobj ? OBJECT_TO_JSVAL(wantedobj) : JSVAL_VOID;
24145:     JS_SET_RVAL(cx, vp, v);
24145:     return JS_TRUE;
24145: }
24145: 
24145: static JSBool
24145: SharedLookupGetter(JSContext *cx, uintN argc, jsval *vp)
24145: {
24145:     return LookupGetterOrSetter(cx, PR_TRUE, vp);
24145: }
24145: 
24145: static JSBool
24145: SharedLookupSetter(JSContext *cx, uintN argc, jsval *vp)
24145: {
24145:     return LookupGetterOrSetter(cx, PR_FALSE, vp);
24145: }
24145: 
24145: // XXX Hack! :-/
24145: JS_FRIEND_API(JSBool) js_obj_defineGetter(JSContext *cx, uintN argc, jsval *vp);
24145: JS_FRIEND_API(JSBool) js_obj_defineSetter(JSContext *cx, uintN argc, jsval *vp);
24145: 
24145: static JSBool
24145: DefineGetterOrSetter(JSContext *cx, uintN argc, JSBool wantGetter, jsval *vp)
24145: {
24145:     uintN attrs;
24145:     JSBool found;
24145:     JSPropertyOp getter, setter;
24145:     JSObject *obj2;
24145:     jsval v;
24145:     jsid interned_id;
24145: 
24145:     XPC_QS_ASSERT_CONTEXT_OK(cx);
24145:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
24145:     if (!obj)
24145:         return JS_FALSE;
24145:     JSFastNative forward = wantGetter ? js_obj_defineGetter : js_obj_defineSetter;
24145:     jsval id = (argc >= 1) ? JS_ARGV(cx, vp)[0] : JSVAL_VOID;
24145:     if(!JSVAL_IS_STRING(id))
24145:         return forward(cx, argc, vp);
24145:     JSString *str = JSVAL_TO_STRING(id);
24145: 
24145:     const char *name = JS_GetStringBytes(str);
24145:     if(!JS_ValueToId(cx, id, &interned_id) ||
24145:        !JS_LookupPropertyWithFlagsById(cx, obj, interned_id,
24145:                                        JSRESOLVE_QUALIFIED, &obj2, &v) ||
24145:        (obj2 &&
24145:         !JS_GetPropertyAttrsGetterAndSetterById(cx, obj2, interned_id, &attrs,
24145:                                                 &found, &getter, &setter)))
24145:         return JS_FALSE;
24145: 
24145:     // The property didn't exist, already has a getter or setter, or is not
24145:     // our property, then just forward now.
24145:     if(!obj2 ||
24145:        (attrs & (JSPROP_GETTER | JSPROP_SETTER)) ||
24145:        !(getter || setter) ||
24145:        !IS_PROTO_CLASS(STOBJ_GET_CLASS(obj2)))
24145:         return forward(cx, argc, vp);
24145: 
24145:     // Reify the getter and setter...
24145:     if(!ReifyPropertyOps(cx, obj, id, interned_id, name, getter, setter,
24145:                          nsnull, nsnull))
24145:         return JS_FALSE;
24145: 
24145:     return forward(cx, argc, vp);
24145: }
24145: 
24145: static JSBool
24145: SharedDefineGetter(JSContext *cx, uintN argc, jsval *vp)
24145: {
24145:     return DefineGetterOrSetter(cx, argc, PR_TRUE, vp);
24145: }
24145: 
24145: static JSBool
24145: SharedDefineSetter(JSContext *cx, uintN argc, jsval *vp)
24145: {
24145:     return DefineGetterOrSetter(cx, argc, PR_FALSE, vp);
24145: }
24145: 
24145: 
17092: JSBool
17092: xpc_qsDefineQuickStubs(JSContext *cx, JSObject *proto, uintN flags,
17092:                        PRUint32 ifacec, const nsIID **interfaces,
17092:                        PRUint32 tableSize, const xpc_qsHashEntry *table)
17092: {
19260:     /*
19260:      * Walk interfaces in reverse order to behave like XPConnect when a
19260:      * feature is defined in more than one of the interfaces.
19260:      *
19260:      * XPCNativeSet::FindMethod returns the first matching feature it finds,
19260:      * searching the interfaces forward.  Here, definitions toward the
19260:      * front of 'interfaces' overwrite those toward the back.
19260:      */
24145:     PRBool definedProperty = PR_FALSE;
19260:     for(uint32 i = ifacec; i-- != 0;)
17092:     {
17092:         const nsID &iid = *interfaces[i];
17092:         const xpc_qsHashEntry *entry =
17092:             LookupInterfaceOrAncestor(tableSize, table, iid);
17092: 
17092:         if(entry)
17092:         {
17092:             for(;;)
17092:             {
17092:                 // Define quick stubs for attributes.
17092:                 const xpc_qsPropertySpec *ps = entry->properties;
17092:                 if(ps)
17092:                 {
17092:                     for(; ps->name; ps++)
17092:                     {
24145:                         definedProperty = PR_TRUE;
17092:                         if(!JS_DefineProperty(cx, proto, ps->name, JSVAL_VOID,
17092:                                               ps->getter, ps->setter,
17092:                                               flags | JSPROP_SHARED))
17092:                             return JS_FALSE;
17092:                     }
17092:                 }
17092: 
17092:                 // Define quick stubs for methods.
17092:                 const xpc_qsFunctionSpec *fs = entry->functions;
17092:                 if(fs)
17092:                 {
17092:                     for(; fs->name; fs++)
17092:                     {
17092:                         if(!JS_DefineFunction(
17092:                                cx, proto, fs->name,
17092:                                reinterpret_cast<JSNative>(fs->native),
17092:                                fs->arity, flags | JSFUN_FAST_NATIVE))
17092:                             return JS_FALSE;
17092:                     }
17092:                 }
17092: 
17092:                 // Next.
17092:                 size_t j = entry->parentInterface;
17092:                 if(j == XPC_QS_NULL_INDEX)
17092:                     break;
17092:                 entry = table + j;
17092:             }
17092:         }
17092:     }
24145: 
24145:     static JSFunctionSpec getterfns[] = {
24145:         JS_FN("__lookupGetter__", SharedLookupGetter, 1, 0),
24145:         JS_FN("__lookupSetter__", SharedLookupSetter, 1, 0),
24145:         JS_FN("__defineGetter__", SharedDefineGetter, 2, 0),
24145:         JS_FN("__defineSetter__", SharedDefineSetter, 2, 0),
24145:         JS_FS_END
24145:     };
24145: 
24145:     if(definedProperty && !JS_DefineFunctions(cx, proto, getterfns))
24145:         return JS_FALSE;
24145: 
17092:     return JS_TRUE;
17092: }
17092: 
17092: JSBool
17092: xpc_qsThrow(JSContext *cx, nsresult rv)
17092: {
17092:     XPCThrower::Throw(rv, cx);
17092:     return JS_FALSE;
17092: }
17092: 
17092: /**
17092:  * Get the interface name and member name (for error messages).
17092:  *
17092:  * We could instead have each quick stub pass its name to the error-handling
17092:  * functions, as that name is statically known.  But that would be redundant;
17092:  * the information is handy at runtime anyway.  Also, this code often produces
17092:  * a more specific error message, e.g. "[nsIDOMHTMLDocument.appendChild]"
17092:  * rather than "[nsIDOMNode.appendChild]".
17092:  */
17092: static void
21218: GetMemberInfo(JSObject *obj,
17092:               jsval memberId,
17092:               const char **ifaceName,
17092:               const char **memberName)
17092: {
17092:     // Get the interface name.  From DefinePropertyIfFound (in
17092:     // xpcwrappednativejsops.cpp) and XPCThrower::Verbosify.
17092:     //
17092:     // We could instead make the quick stub could pass in its interface name,
17092:     // but this code often produces a more specific error message, e.g.
17092:     *ifaceName = "Unknown";
21218: 
21218:     NS_ASSERTION(IS_WRAPPER_CLASS(STOBJ_GET_CLASS(obj)) ||
21218:                  STOBJ_GET_CLASS(obj) == &XPC_WN_Tearoff_JSClass,
21218:                  "obj must be an XPCWrappedNative");
21218:     XPCWrappedNative *wrapper = (XPCWrappedNative *) STOBJ_GET_PRIVATE(obj);
17092:     XPCWrappedNativeProto *proto = wrapper->GetProto();
17092:     if(proto)
17092:     {
17092:         XPCNativeSet *set = proto->GetSet();
17092:         if(set)
17092:         {
17092:             XPCNativeMember *member;
17092:             XPCNativeInterface *iface;
17092: 
17092:             if(set->FindMember(memberId, &member, &iface))
17092:                 *ifaceName = iface->GetNameString();
17092:         }
17092:     }
17092: 
17092:     *memberName = (JSVAL_IS_STRING(memberId)
17092:                    ? JS_GetStringBytes(JSVAL_TO_STRING(memberId))
17092:                    : "unknown");
17092: }
17092: 
17092: static void
17092: GetMethodInfo(JSContext *cx,
17092:               jsval *vp,
17092:               const char **ifaceName,
17092:               const char **memberName)
17092: {
17092:     JSObject *funobj = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));
17092:     NS_ASSERTION(JS_ObjectIsFunction(cx, funobj),
17092:                  "JSFastNative callee should be Function object");
17092:     JSString *str = JS_GetFunctionId((JSFunction *) JS_GetPrivate(cx, funobj));
17092:     jsval methodId = str ? STRING_TO_JSVAL(str) : JSVAL_NULL;
17092: 
21218:     GetMemberInfo(JSVAL_TO_OBJECT(vp[1]), methodId, ifaceName, memberName);
17092: }
17092: 
17092: static JSBool
17092: ThrowCallFailed(JSContext *cx, nsresult rv,
17092:                 const char *ifaceName, const char *memberName)
17092: {
17092:     // From XPCThrower::ThrowBadResult.
17092:     char* sz;
17092:     const char* format;
17092:     const char* name;
17092: 
17092:     /*
17092:      *  If there is a pending exception when the native call returns and
17092:      *  it has the same error result as returned by the native call, then
17092:      *  the native call may be passing through an error from a previous JS
17092:      *  call. So we'll just throw that exception into our JS.
17092:      */
17092:     if(XPCThrower::CheckForPendingException(rv, cx))
17092:         return JS_FALSE;
17092: 
17092:     // else...
17092: 
17092:     if(!nsXPCException::NameAndFormatForNSResult(
17092:             NS_ERROR_XPC_NATIVE_RETURNED_FAILURE, nsnull, &format) ||
17092:         !format)
17092:     {
17092:         format = "";
17092:     }
17092: 
17092:     if(nsXPCException::NameAndFormatForNSResult(rv, &name, nsnull)
17092:         && name)
17092:     {
17092:         sz = JS_smprintf("%s 0x%x (%s) [%s.%s]",
17092:                          format, rv, name, ifaceName, memberName);
17092:     }
17092:     else
17092:     {
17092:         sz = JS_smprintf("%s 0x%x [%s.%s]",
17092:                          format, rv, ifaceName, memberName);
17092:     }
17092: 
17092:     XPCThrower::BuildAndThrowException(cx, rv, sz);
17092: 
17092:     if(sz)
17092:         JS_smprintf_free(sz);
17092: 
17092:     return JS_FALSE;
17092: }
17092: 
17092: JSBool
21218: xpc_qsThrowGetterSetterFailed(JSContext *cx, nsresult rv, JSObject *obj,
21218:                               jsval memberId)
17092: {
17092:     const char *ifaceName, *memberName;
21218:     GetMemberInfo(obj, memberId, &ifaceName, &memberName);
17092:     return ThrowCallFailed(cx, rv, ifaceName, memberName);
17092: }
17092: 
17092: JSBool
21218: xpc_qsThrowMethodFailed(JSContext *cx, nsresult rv, jsval *vp)
17092: {
17092:     const char *ifaceName, *memberName;
21218:     GetMethodInfo(cx, vp, &ifaceName, &memberName);
17092:     return ThrowCallFailed(cx, rv, ifaceName, memberName);
17092: }
17092: 
17092: JSBool
17092: xpc_qsThrowMethodFailedWithCcx(XPCCallContext &ccx, nsresult rv)
17092: {
17092:     ThrowBadResult(rv, ccx);
17092:     return JS_FALSE;
17092: }
17092: 
17092: static void
17092: ThrowBadArg(JSContext *cx, nsresult rv,
17092:             const char *ifaceName, const char *memberName, uintN paramnum)
17092: {
17092:     // From XPCThrower::ThrowBadParam.
17092:     char* sz;
17092:     const char* format;
17092: 
17092:     if(!nsXPCException::NameAndFormatForNSResult(rv, nsnull, &format))
17092:         format = "";
17092: 
17092:     sz = JS_smprintf("%s arg %u [%s.%s]",
17092:                      format, (unsigned int) paramnum, ifaceName, memberName);
17092: 
17092:     XPCThrower::BuildAndThrowException(cx, rv, sz);
17092: 
17092:     if(sz)
17092:         JS_smprintf_free(sz);
17092: }
17092: 
17092: void
21218: xpc_qsThrowBadArg(JSContext *cx, nsresult rv, jsval *vp, uintN paramnum)
17092: {
17092:     const char *ifaceName, *memberName;
21218:     GetMethodInfo(cx, vp, &ifaceName, &memberName);
17092:     ThrowBadArg(cx, rv, ifaceName, memberName, paramnum);
17092: }
17092: 
17092: void
17092: xpc_qsThrowBadArgWithCcx(XPCCallContext &ccx, nsresult rv, uintN paramnum)
17092: {
17092:     XPCThrower::ThrowBadParam(rv, paramnum, ccx);
17092: }
17092: 
17092: void
17092: xpc_qsThrowBadSetterValue(JSContext *cx, nsresult rv,
21218:                           JSObject *obj, jsval propId)
17092: {
17092:     const char *ifaceName, *memberName;
21218:     GetMemberInfo(obj, propId, &ifaceName, &memberName);
17092:     ThrowBadArg(cx, rv, ifaceName, memberName, 0);
17092: }
17092: 
17092: xpc_qsDOMString::xpc_qsDOMString(JSContext *cx, jsval *pval)
17092: {
17092:     // From the T_DOMSTRING case in XPCConvert::JSData2Native.
17092:     typedef implementation_type::char_traits traits;
17092:     jsval v;
17092:     JSString *s;
23249:     const PRUnichar *chars;
17092:     size_t len;
17092: 
17092:     v = *pval;
17092:     if(JSVAL_IS_STRING(v))
17092:     {
17092:         s = JSVAL_TO_STRING(v);
17092:     }
17092:     else
17092:     {
17092:         if(JSVAL_IS_NULL(v))
17092:         {
17092:             (new(mBuf) implementation_type(
17092:                 traits::sEmptyBuffer, PRUint32(0)))->SetIsVoid(PR_TRUE);
17092:             mValid = JS_TRUE;
17092:             return;
17092:         }
17092: 
17092:         s = JS_ValueToString(cx, v);
17092:         if(!s)
17092:         {
17092:             mValid = JS_FALSE;
17092:             return;
17092:         }
17092:         *pval = STRING_TO_JSVAL(s);  // Root the new string.
17092:     }
17092: 
17092:     len = JS_GetStringLength(s);
23249:     chars = (len == 0 ? traits::sEmptyBuffer : (const PRUnichar*)JS_GetStringChars(s));
17092:     new(mBuf) implementation_type(chars, len);
17092:     mValid = JS_TRUE;
17092: }
17092: 
17092: xpc_qsAString::xpc_qsAString(JSContext *cx, jsval *pval)
17092: {
17092:     // From the T_ASTRING case in XPCConvert::JSData2Native.
17092:     typedef implementation_type::char_traits traits;
17092:     jsval v;
17092:     JSString *s;
23249:     const PRUnichar *chars;
17092:     size_t len;
17092: 
17092:     v = *pval;
17092:     if(JSVAL_IS_STRING(v))
17092:     {
17092:         s = JSVAL_TO_STRING(v);
17092:     }
17092:     else
17092:     {
17092:         if(JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v))
17092:         {
17092:             (new(mBuf) implementation_type(
17092:                 traits::sEmptyBuffer, PRUint32(0)))->SetIsVoid(PR_TRUE);
17092:             mValid = JS_TRUE;
17092:             return;
17092:         }
17092: 
17092:         s = JS_ValueToString(cx, v);
17092:         if(!s)
17092:         {
17092:             mValid = JS_FALSE;
17092:             return;
17092:         }
17092:         *pval = STRING_TO_JSVAL(s);  // Root the new string.
17092:     }
17092: 
17092:     len = JS_GetStringLength(s);
23249:     chars = (len == 0 ? traits::sEmptyBuffer : (const PRUnichar*)JS_GetStringChars(s));
17092:     new(mBuf) implementation_type(chars, len);
17092:     mValid = JS_TRUE;
17092: }
17092: 
17092: xpc_qsACString::xpc_qsACString(JSContext *cx, jsval *pval)
17092: {
17092:     // From the T_CSTRING case in XPCConvert::JSData2Native.
17092:     jsval v;
17092:     JSString *s;
17092: 
17092:     v = *pval;
17092:     if(JSVAL_IS_STRING(v))
17092:     {
17092:         s = JSVAL_TO_STRING(v);
17092:     }
17092:     else
17092:     {
17092:         if(JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v))
17092:         {
17092:             (new(mBuf) implementation_type())->SetIsVoid(PR_TRUE);
17092:             mValid = JS_TRUE;
17092:             return;
17092:         }
17092: 
17092:         s = JS_ValueToString(cx, v);
17092:         if(!s)
17092:         {
17092:             mValid = JS_FALSE;
17092:             return;
17092:         }
17092:         *pval = STRING_TO_JSVAL(s);  // Root the new string.
17092:     }
17092: 
17092:     const char *bytes = JS_GetStringBytes(s);
17092:     size_t len = JS_GetStringLength(s);
17092:     new(mBuf) implementation_type(bytes, len);
17092:     mValid = JS_TRUE;
17092: }
17092: 
21218: static nsresult
21218: getNativeFromWrapper(XPCWrappedNative *wrapper,
21218:                      const nsIID &iid,
21218:                      void **ppThis,
21218:                      nsISupports **pThisRef,
21218:                      jsval *vp)
21218: {
21218:     nsISupports *idobj = wrapper->GetIdentityObject();
21218: 
21218:     // Try using the QITableEntry to avoid the extra AddRef and Release.
21218:     QITableEntry* entries = wrapper->GetOffsets();
21218:     if(entries)
21218:     {
21218:         for(QITableEntry* e = entries; e->iid; e++)
21218:         {
21218:             if(e->iid->Equals(iid))
21218:             {
21218:                 *ppThis = (char*) idobj + e->offset - entries[0].offset;
21218:                 *vp = OBJECT_TO_JSVAL(wrapper->GetFlatJSObject());
21218:                 *pThisRef = nsnull;
21218:                 return NS_OK;
21218:             }
21218:         }
21218:     }
21218: 
21218:     nsresult rv = idobj->QueryInterface(iid, ppThis);
21218:     *pThisRef = static_cast<nsISupports*>(*ppThis);
21218:     if(NS_SUCCEEDED(rv))
21218:         *vp = OBJECT_TO_JSVAL(wrapper->GetFlatJSObject());
21218:     return rv;
21218: }
21218: 
17092: JSBool
17092: xpc_qsUnwrapThisImpl(JSContext *cx,
17092:                      JSObject *obj,
17092:                      const nsIID &iid,
17092:                      void **ppThis,
21218:                      nsISupports **pThisRef,
21218:                      jsval *vp)
17092: {
17092:     // From XPCWrappedNative::GetWrappedNativeOfJSObject.
17092:     //
17092:     // Usually IS_WRAPPER_CLASS is true the first time through the while loop,
17092:     // and the QueryInterface then succeeds.
17092: 
17092:     NS_ASSERTION(obj, "this == null");
17092: 
17092:     JSObject *cur = obj;
17092:     while(cur)
17092:     {
17092:         JSClass *clazz;
17092:         XPCWrappedNative *wrapper;
17092:         nsresult rv;
17092: 
17092:         clazz = STOBJ_GET_CLASS(cur);
17092:         if(IS_WRAPPER_CLASS(clazz))
17092:         {
17092:             wrapper = (XPCWrappedNative*) xpc_GetJSPrivate(cur);
17092:             NS_ASSERTION(wrapper, "XPCWN wrapping nothing");
17092:         }
17092:         else if(clazz == &XPC_WN_Tearoff_JSClass)
17092:         {
17092:             wrapper = (XPCWrappedNative*) xpc_GetJSPrivate(STOBJ_GET_PARENT(cur));
17092:             NS_ASSERTION(wrapper, "XPCWN wrapping nothing");
17092:         }
17092:         else if(clazz == &sXPC_XOW_JSClass.base)
17092:         {
17092:             JSObject *unsafeObj = XPCWrapper::Unwrap(cx, cur);
17092:             if(unsafeObj)
17092:             {
17092:                 cur = unsafeObj;
17092:                 continue;
17092:             }
17092: 
17092:             // This goto is a bug, dutifully copied from
17092:             // XPCWrappedNative::GetWrappedNativeOfJSObject.
17092:             goto next;
17092:         }
17092:         else if(XPCNativeWrapper::IsNativeWrapperClass(clazz))
17092:         {
24010:             if(!XPCNativeWrapper::GetWrappedNative(cx, cur, &wrapper) ||
24010:                !wrapper)
23769:                 goto next;
17092:         }
17092:         else if(IsXPCSafeJSObjectWrapperClass(clazz))
17092:         {
17092:             cur = STOBJ_GET_PARENT(cur);
17092:             NS_ASSERTION(cur, "SJOW wrapping nothing");
17092:             continue;
17092:         }
17092:         else {
17092:             goto next;
17092:         }
17092: 
21218:         rv = getNativeFromWrapper(wrapper, iid, ppThis, pThisRef, vp);
17092:         if(NS_SUCCEEDED(rv))
17092:             return JS_TRUE;
17092:         if(rv != NS_ERROR_NO_INTERFACE)
17092:             return xpc_qsThrow(cx, rv);
17092: 
17092:     next:
17092:         cur = STOBJ_GET_PROTO(cur);
17092:     }
17092: 
17092:     // If we didn't find a wrapper using the given obj, try again with obj's
17092:     // outer object, if it's got one.
17092: 
17092:     JSClass *clazz = STOBJ_GET_CLASS(obj);
17092: 
17092:     if((clazz->flags & JSCLASS_IS_EXTENDED) &&
17092:         ((JSExtendedClass*)clazz)->outerObject)
17092:     {
17092:         JSObject *outer = ((JSExtendedClass*)clazz)->outerObject(cx, obj);
17092: 
17092:         // Protect against infinite recursion through XOWs.
17092:         JSObject *unsafeObj;
17092:         clazz = STOBJ_GET_CLASS(outer);
17092:         if(clazz == &sXPC_XOW_JSClass.base &&
17092:            (unsafeObj = XPCWrapper::Unwrap(cx, outer)))
17092:         {
17092:             outer = unsafeObj;
17092:         }
17092: 
17092:         if(outer && outer != obj)
21218:             return xpc_qsUnwrapThisImpl(cx, outer, iid, ppThis, pThisRef, vp);
17092:     }
17092: 
21218:     *pThisRef = nsnull;
17092:     return xpc_qsThrow(cx, NS_ERROR_XPC_BAD_OP_ON_WN_PROTO);
17092: }
17092: 
17092: JSBool
17092: xpc_qsUnwrapThisFromCcxImpl(XPCCallContext &ccx,
17092:                             const nsIID &iid,
21218:                             void **ppThis,
21218:                             nsISupports **pThisRef,
21218:                             jsval *vp)
17092: {
17092:     XPCWrappedNative *wrapper = ccx.GetWrapper();
17092:     if(!wrapper)
17092:         return xpc_qsThrow(ccx.GetJSContext(), NS_ERROR_XPC_BAD_OP_ON_WN_PROTO);
17092:     if(!wrapper->IsValid())
17092:         return xpc_qsThrow(ccx.GetJSContext(), NS_ERROR_XPC_HAS_BEEN_SHUTDOWN);
17092: 
21218:     nsresult rv = getNativeFromWrapper(wrapper, iid, ppThis, pThisRef, vp);
17092:     if(NS_FAILED(rv))
17092:         return xpc_qsThrow(ccx.GetJSContext(), rv);
17092:     return JS_TRUE;
17092: }
17092: 
17092: nsresult
17092: xpc_qsUnwrapArgImpl(JSContext *cx,
17092:                     jsval v,
17092:                     const nsIID &iid,
17092:                     void **ppArg)
17092: {
17092:     // From XPCConvert::JSData2Native
17092:     if(JSVAL_IS_VOID(v) || JSVAL_IS_NULL(v))
17092:         return NS_OK;
17092: 
17092:     if(!JSVAL_IS_OBJECT(v))
17092:     {
17092:         return ((JSVAL_IS_INT(v) && JSVAL_TO_INT(v) == 0)
17092:                 ? NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL
17092:                 : NS_ERROR_XPC_BAD_CONVERT_JS);
17092:     }
17092:     JSObject *src = JSVAL_TO_OBJECT(v);
17092: 
17092:     // From XPCConvert::JSObject2NativeInterface
17092:     XPCWrappedNative* wrappedNative =
17092:         XPCWrappedNative::GetWrappedNativeOfJSObject(cx, src);
17092:     nsISupports *iface;
17092:     if(wrappedNative)
17092:     {
17092:         iface = wrappedNative->GetIdentityObject();
17092:         if(NS_FAILED(iface->QueryInterface(iid, ppArg)))
17092:             return NS_ERROR_XPC_BAD_CONVERT_JS;
17092:         return NS_OK;
17092:     }
17092:     // else...
17092:     // Slow path.
17092: 
17092:     // XXX E4X breaks the world. Don't try wrapping E4X objects!
17092:     // This hack can be removed (or changed accordingly) when the
17092:     // DOM <-> E4X bindings are complete, see bug 270553
17092:     if(JS_TypeOfValue(cx, OBJECT_TO_JSVAL(src)) == JSTYPE_XML)
17092:         return NS_ERROR_XPC_BAD_CONVERT_JS;
17092: 
17092:     // Does the JSObject have 'nsISupportness'?
17092:     // XXX hmm, I wonder if this matters anymore with no
17092:     // oldstyle DOM objects around.
17092:     if(XPCConvert::GetISupportsFromJSObject(src, &iface))
17092:     {
17092:         if(!iface || NS_FAILED(iface->QueryInterface(iid, ppArg)))
17092:             return NS_ERROR_XPC_BAD_CONVERT_JS;
17092:         return NS_OK;
17092:     }
17092: 
17092:     // Create the ccx needed for quick stubs.
17092:     XPCCallContext ccx(JS_CALLER, cx);
17092:     if(!ccx.IsValid())
17092:         return NS_ERROR_XPC_BAD_CONVERT_JS;
17092: 
17092:     nsXPCWrappedJS *wrapper;
17092:     nsresult rv =
17092:         nsXPCWrappedJS::GetNewOrUsed(ccx, src, iid, nsnull, &wrapper);
17092:     if(NS_FAILED(rv) || !wrapper)
17092:         return rv;
17092: 
17092:     // We need to go through the QueryInterface logic to make this return
17092:     // the right thing for the various 'special' interfaces; e.g.
17092:     // nsIPropertyBag. We must use AggregatedQueryInterface in cases where
17092:     // there is an outer to avoid nasty recursion.
17092:     rv = wrapper->QueryInterface(iid, ppArg);
17092:     NS_RELEASE(wrapper);
17092:     return rv;
17092: }
17092: 
17092: JSBool
17092: xpc_qsJsvalToCharStr(JSContext *cx, jsval *pval, char **pstr)
17092: {
17092:     jsval v = *pval;
17092:     JSString *str;
17092: 
17092:     if(JSVAL_IS_STRING(v))
17092:     {
17092:         str = JSVAL_TO_STRING(v);
17092:     }
17092:     else if(JSVAL_IS_VOID(v) || JSVAL_IS_NULL(v))
17092:     {
17092:         *pstr = NULL;
17092:         return JS_TRUE;
17092:     }
17092:     else
17092:     {
17092:         if(!(str = JS_ValueToString(cx, v)))
17092:             return JS_FALSE;
17092:         *pval = STRING_TO_JSVAL(str);  // Root the new string.
17092:     }
17092: 
17092:     *pstr = JS_GetStringBytes(str);
17092:     return JS_TRUE;
17092: }
17092: 
17092: JSBool
17092: xpc_qsJsvalToWcharStr(JSContext *cx, jsval *pval, PRUnichar **pstr)
17092: {
17092:     jsval v = *pval;
17092:     JSString *str;
17092: 
17092:     if(JSVAL_IS_STRING(v))
17092:     {
17092:         str = JSVAL_TO_STRING(v);
17092:     }
17092:     else if(JSVAL_IS_VOID(v) || JSVAL_IS_NULL(v))
17092:     {
17092:         *pstr = NULL;
17092:         return JS_TRUE;
17092:     }
17092:     else
17092:     {
17092:         if(!(str = JS_ValueToString(cx, v)))
17092:             return JS_FALSE;
17092:         *pval = STRING_TO_JSVAL(str);  // Root the new string.
17092:     }
17092: 
23249:     *pstr = (PRUnichar*)JS_GetStringChars(str);
17092:     return JS_TRUE;
17092: }
17092: 
17092: JSBool
17092: xpc_qsStringToJsval(JSContext *cx, const nsAString &str, jsval *rval)
17092: {
17092:     // From the T_DOMSTRING case in XPCConvert::NativeData2JS.
17092:     if(str.IsVoid())
17092:     {
17092:         *rval = JSVAL_NULL;
17092:         return JS_TRUE;
17092:     }
17092: 
17092:     JSString *jsstr = XPCStringConvert::ReadableToJSString(cx, str);
17092:     if(!jsstr)
17092:         return JS_FALSE;
17092:     *rval = STRING_TO_JSVAL(jsstr);
17092:     return JS_TRUE;
17092: }
17092: 
17092: JSBool
17092: xpc_qsXPCOMObjectToJsval(XPCCallContext &ccx, nsISupports *p,
23258:                          nsWrapperCache *cache, XPCNativeInterface *iface,
23258:                          jsval *rval)
17092: {
17092:     // From the T_INTERFACE case in XPCConvert::NativeData2JS.
17092:     // This is one of the slowest things quick stubs do.
17092: 
17092:     JSObject *scope = ccx.GetCurrentJSObject();
17092:     NS_ASSERTION(scope, "bad ccx");
17092: 
22842:     if(!iface)
22842:         return xpc_qsThrow(ccx, NS_ERROR_XPC_BAD_CONVERT_NATIVE);
22842: 
17092:     // XXX The OBJ_IS_NOT_GLOBAL here is not really right. In
17092:     // fact, this code is depending on the fact that the
17092:     // global object will not have been collected, and
17092:     // therefore this NativeInterface2JSObject will not end up
17092:     // creating a new XPCNativeScriptableShared.
17092:     nsresult rv;
22842:     if(!XPCConvert::NativeInterface2JSObject(ccx, rval, nsnull, p, nsnull,
23258:                                              iface, cache, scope, PR_TRUE,
22842:                                              OBJ_IS_NOT_GLOBAL, &rv))
17092:     {
17092:         // I can't tell if NativeInterface2JSObject throws JS exceptions
17092:         // or not.  This is a sloppy stab at the right semantics; the
17092:         // method really ought to be fixed to behave consistently.
17092:         if(!JS_IsExceptionPending(ccx))
17092:             xpc_qsThrow(ccx, NS_FAILED(rv) ? rv : NS_ERROR_UNEXPECTED);
17092:         return JS_FALSE;
17092:     }
17092: 
17092: #ifdef DEBUG
22841:     JSObject* jsobj = JSVAL_TO_OBJECT(*rval);
22841:     if(jsobj && !STOBJ_GET_PARENT(jsobj))
17092:         NS_ASSERTION(STOBJ_GET_CLASS(jsobj)->flags & JSCLASS_IS_GLOBAL,
17092:                      "Why did we recreate this wrapper?");
17092: #endif
22841: 
17092:     return JS_TRUE;
17092: }
17092: 
17092: JSBool
17092: xpc_qsVariantToJsval(XPCCallContext &ccx,
17092:                      nsIVariant *p,
17092:                      uintN paramNum,
17092:                      jsval *rval)
17092: {
17092:     // From the T_INTERFACE case in XPCConvert::NativeData2JS.
17092:     // Error handling is in XPCWrappedNative::CallMethod.
17092:     if(p)
17092:     {
17092:         nsresult rv;
17092:         JSBool ok = XPCVariant::VariantDataToJS(ccx, p,
17092:                                                 ccx.GetCurrentJSObject(),
17092:                                                 &rv, rval);
17092:         if (!ok)
17092:             XPCThrower::ThrowBadParam(rv, 0, ccx);
17092:         return ok;
17092:     }
17092:     *rval = JSVAL_NULL;
17092:     return JS_TRUE;
17092: }
17092: 
17092: JSBool
17092: xpc_qsReadOnlySetter(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
17092: {
17092:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
17092:                          JSMSG_GETTER_ONLY, NULL);
17092:     return JS_FALSE;
17092: }
17092: 
17092: #ifdef DEBUG
17092: void
17092: xpc_qsAssertContextOK(JSContext *cx)
17092: {
17092:     XPCPerThreadData *thread = XPCPerThreadData::GetData(cx);
17092:     XPCJSContextStack* stack = thread->GetJSContextStack();
17092: 
17092:     JSContext* topJSContext = nsnull;
17092:     nsresult rv = stack->Peek(&topJSContext);
17092:     NS_ASSERTION(NS_SUCCEEDED(rv), "XPCJSContextStack::Peek failed");
17092: 
17092:     // This is what we're actually trying to assert here.
17092:     NS_ASSERTION(cx == topJSContext, "wrong context on XPCJSContextStack!");
17092: 
17092:     NS_ASSERTION(XPCPerThreadData::IsMainThread(cx),
17092:                  "XPConnect quick stub called on non-main thread");
17092: }
17092: #endif
