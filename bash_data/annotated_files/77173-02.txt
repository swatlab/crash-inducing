59954: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
54707:  *
54707:  * ***** BEGIN LICENSE BLOCK *****
54707:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54707:  *
54707:  * The contents of this file are subject to the Mozilla Public License Version
54707:  * 1.1 (the "License"); you may not use this file except in compliance with
54707:  * the License. You may obtain a copy of the License at
54707:  * http://www.mozilla.org/MPL/
54707:  *
54707:  * Software distributed under the License is distributed on an "AS IS" basis,
54707:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54707:  * for the specific language governing rights and limitations under the
54707:  * License.
54707:  *
54707:  * The Original Code is SpiderMonkey code.
54707:  *
54707:  * The Initial Developer of the Original Code is
54707:  * Mozilla Corporation.
54707:  * Portions created by the Initial Developer are Copyright (C) 2010
54707:  * the Initial Developer. All Rights Reserved.
54707:  *
54707:  * Contributor(s):
54707:  *
54707:  *
54707:  * Alternatively, the contents of this file may be used under the terms of
54707:  * either of the GNU General Public License Version 2 or later (the "GPL"),
54707:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54707:  * in which case the provisions of the GPL or the LGPL are applicable instead
54707:  * of those above. If you wish to allow use of your version of this file only
54707:  * under the terms of either the GPL or the LGPL, and not to allow others to
54707:  * use your version of this file under the terms of the MPL, indicate your
54707:  * decision by deleting the provisions above and replace them with the notice
54707:  * and other provisions required by the GPL or the LGPL. If you do not delete
54707:  * the provisions above, a recipient may use your version of this file under
54707:  * the terms of any one of the MPL, the GPL or the LGPL.
54707:  *
54707:  * ***** END LICENSE BLOCK ***** */
54707: 
54707: #ifndef jscompartment_h___
54707: #define jscompartment_h___
54707: 
74472: #include "jsclist.h"
54733: #include "jscntxt.h"
74472: #include "jsfun.h"
54707: #include "jsgc.h"
74472: #include "jsgcstats.h"
54707: #include "jsobj.h"
75452: #include "vm/GlobalObject.h"
54707: 
56018: #ifdef _MSC_VER
56018: #pragma warning(push)
56018: #pragma warning(disable:4251) /* Silence warning about JS_FRIEND_API and data members. */
56018: #endif
56018: 
71317: namespace JSC { class ExecutableAllocator; }
71317: namespace WTF { class BumpPointerAllocator; }
60168: 
56773: namespace js {
59733: 
59733: /* Holds the number of recording attemps for an address. */
59733: typedef HashMap<jsbytecode*,
59733:                 size_t,
59733:                 DefaultHasher<jsbytecode*>,
59733:                 SystemAllocPolicy> RecordAttemptMap;
59733: 
59733: /* Holds the profile data for loops. */
59733: typedef HashMap<jsbytecode*,
59733:                 LoopProfile*,
59733:                 DefaultHasher<jsbytecode*>,
59733:                 SystemAllocPolicy> LoopProfileMap;
59733: 
59733: class Oracle;
59733: 
59733: typedef HashSet<JSScript *,
59733:                 DefaultHasher<JSScript *>,
59733:                 SystemAllocPolicy> TracedScriptSet;
59733: 
61687: typedef HashMap<JSFunction *,
61687:                 JSString *,
61687:                 DefaultHasher<JSFunction *>,
61687:                 SystemAllocPolicy> ToSourceCache;
61687: 
62032: struct TraceMonitor;
62032: 
60574: /* Holds the execution state during trace execution. */
60574: struct TracerState
60574: {
60574:     JSContext*     cx;                  // current VM context handle
62032:     TraceMonitor*  traceMonitor;        // current TM
60574:     double*        stackBase;           // native stack base
60574:     double*        sp;                  // native stack pointer, stack[0] is spbase[0]
60574:     double*        eos;                 // first unusable word after the native stack / begin of globals
60574:     FrameInfo**    callstackBase;       // call stack base
60574:     void*          sor;                 // start of rp stack
60574:     FrameInfo**    rp;                  // call stack pointer
60574:     void*          eor;                 // first unusable word after the call stack
60574:     VMSideExit*    lastTreeExitGuard;   // guard we exited on during a tree call
60574:     VMSideExit*    lastTreeCallGuard;   // guard we want to grow from if the tree
60574:                                         // call exit guard mismatched
60574:     void*          rpAtLastTreeCall;    // value of rp at innermost tree call guard
60574:     VMSideExit*    outermostTreeExitGuard; // the last side exit returned by js_CallTree
60574:     TreeFragment*  outermostTree;       // the outermost tree we initially invoked
60574:     VMSideExit**   innermostNestedGuardp;
60574:     VMSideExit*    innermost;
60574:     uint64         startTime;
60574:     TracerState*   prev;
60574: 
60574:     // Used by _FAIL builtins; see jsbuiltins.h. The builtin sets the
60574:     // JSBUILTIN_BAILED bit if it bails off trace and the JSBUILTIN_ERROR bit
60574:     // if an error or exception occurred.
60574:     uint32         builtinStatus;
60574: 
60574:     // Used to communicate the location of the return value in case of a deep bail.
60574:     double*        deepBailSp;
60574: 
60574:     // Used when calling natives from trace to root the vp vector.
60574:     uintN          nativeVpLen;
60574:     js::Value*     nativeVp;
60574: 
60574:     TracerState(JSContext *cx, TraceMonitor *tm, TreeFragment *ti,
71363:                 VMSideExit** innermostNestedGuardp);
60574:     ~TracerState();
60574: };
60574: 
60574: /*
60574:  * Storage for the execution state and store during trace execution. Generated
60574:  * code depends on the fact that the globals begin |MAX_NATIVE_STACK_SLOTS|
60574:  * doubles after the stack begins. Thus, on trace, |TracerState::eos| holds a
60574:  * pointer to the first global.
60574:  */
60574: struct TraceNativeStorage
60574: {
69223:     /* Max number of stack slots/frame that may need to be restored in LeaveTree. */
69223:     static const size_t MAX_NATIVE_STACK_SLOTS  = 4096;
69223:     static const size_t MAX_CALL_STACK_ENTRIES  = 500;
69223: 
60574:     double stack_global_buf[MAX_NATIVE_STACK_SLOTS + GLOBAL_SLOTS_BUFFER_SIZE];
60574:     FrameInfo *callstack_buf[MAX_CALL_STACK_ENTRIES];
60574: 
60574:     double *stack() { return stack_global_buf; }
60574:     double *global() { return stack_global_buf + MAX_NATIVE_STACK_SLOTS; }
60574:     FrameInfo **callstack() { return callstack_buf; }
60574: };
60574: 
60574: /* Holds data to track a single globa. */
60574: struct GlobalState {
60574:     JSObject*               globalObj;
60574:     uint32                  globalShape;
60574:     SlotList*               globalSlots;
60574: };
60574: 
59733: /*
59734:  * Trace monitor. Every JSCompartment has an associated trace monitor
59734:  * that keeps track of loop frequencies for all JavaScript code loaded
59734:  * into that runtime.
59733:  */
59733: struct TraceMonitor {
59733:     /*
59734:      * The context currently executing JIT-compiled code in this compartment, or
59733:      * NULL if none. Among other things, this can in certain cases prevent
59733:      * last-ditch GC and suppress calls to JS_ReportOutOfMemory.
59733:      *
59733:      * !tracecx && !recorder: not on trace
59733:      * !tracecx && recorder: recording
59733:      * tracecx && !recorder: executing a trace
59733:      * tracecx && recorder: executing inner loop, recording outer loop
59733:      */
59733:     JSContext               *tracecx;
59733: 
60574:     /*
60574:      * State for the current tree execution.  bailExit is valid if the tree has
60574:      * called back into native code via a _FAIL builtin and has not yet bailed,
60574:      * else garbage (NULL in debug builds).
60574:      */
60574:     js::TracerState     *tracerState;
60574:     js::VMSideExit      *bailExit;
60574: 
59736:     /* Counts the number of iterations run by the currently executing trace. */
59736:     unsigned                iterationCounter;
59736: 
59733:     /*
59733:      * Cached storage to use when executing on trace. While we may enter nested
59733:      * traces, we always reuse the outer trace's storage, so never need more
59733:      * than of these.
59733:      */
59733:     TraceNativeStorage      *storage;
59733: 
59733:     /*
59733:      * There are 4 allocators here.  This might seem like overkill, but they
59733:      * have different lifecycles, and by keeping them separate we keep the
59733:      * amount of retained memory down significantly.  They are flushed (ie.
59733:      * all the allocated memory is freed) periodically.
59733:      *
59733:      * - dataAlloc has the lifecycle of the monitor.  It's flushed only when
59733:      *   the monitor is flushed.  It's used for fragments.
59733:      *
59733:      * - traceAlloc has the same flush lifecycle as the dataAlloc, but it is
59733:      *   also *marked* when a recording starts and rewinds to the mark point
59733:      *   if recording aborts.  So you can put things in it that are only
59733:      *   reachable on a successful record/compile cycle like GuardRecords and
59733:      *   SideExits.
59733:      *
59733:      * - tempAlloc is flushed after each recording, successful or not.  It's
59733:      *   used to store LIR code and for all other elements in the LIR
59733:      *   pipeline.
59733:      *
59733:      * - codeAlloc has the same lifetime as dataAlloc, but its API is
59733:      *   different (CodeAlloc vs. VMAllocator).  It's used for native code.
59733:      *   It's also a good idea to keep code and data separate to avoid I-cache
59733:      *   vs. D-cache issues.
59733:      */
59733:     VMAllocator*            dataAlloc;
59733:     VMAllocator*            traceAlloc;
59733:     VMAllocator*            tempAlloc;
59733:     nanojit::CodeAlloc*     codeAlloc;
59733:     nanojit::Assembler*     assembler;
59733:     FrameInfoCache*         frameCache;
59733: 
59733:     /* This gets incremented every time the monitor is flushed. */
59733:     uintN                   flushEpoch;
59733: 
59733:     Oracle*                 oracle;
59733:     TraceRecorder*          recorder;
59733: 
59733:     /* If we are profiling a loop, this tracks the current profile. Otherwise NULL. */
59733:     LoopProfile*            profile;
59733: 
59733:     GlobalState             globalStates[MONITOR_N_GLOBAL_STATES];
59733:     TreeFragment            *vmfragments[FRAGMENT_TABLE_SIZE];
59733:     RecordAttemptMap*       recordAttempts;
59733: 
59733:     /* A hashtable mapping PC values to loop profiles for those loops. */
59733:     LoopProfileMap*         loopProfiles;
59733: 
59733:     /*
59733:      * Maximum size of the code cache before we start flushing. 1/16 of this
59733:      * size is used as threshold for the regular expression code cache.
59733:      */
59733:     uint32                  maxCodeCacheBytes;
59733: 
59733:     /*
59733:      * If nonzero, do not flush the JIT cache after a deep bail. That would
59733:      * free JITted code pages that we will later return to. Instead, set the
59733:      * needFlush flag so that it can be flushed later.
59733:      */
59733:     JSBool                  needFlush;
59733: 
59733:     // Cached temporary typemap to avoid realloc'ing every time we create one.
59733:     // This must be used in only one place at a given time. It must be cleared
59733:     // before use.
59733:     TypeMap*                cachedTempTypeMap;
59733: 
59733:     /* Scripts with recorded fragments. */
59733:     TracedScriptSet         tracedScripts;
59733: 
59733: #ifdef DEBUG
59733:     /* Fields needed for fragment/guard profiling. */
59733:     nanojit::Seq<nanojit::Fragment*>* branches;
59733:     uint32                  lastFragID;
59733:     VMAllocator*            profAlloc;
59733:     FragStatsMap*           profTab;
69633: 
69633:     void logFragProfile();
59733: #endif
59733: 
69633:     TraceMonitor();
69633:     ~TraceMonitor();
69633: 
69633:     bool init(JSRuntime* rt);
69633: 
59733:     bool ontrace() const {
59733:         return !!tracecx;
59733:     }
59733: 
59733:     /* Flush the JIT cache. */
59733:     void flush();
59733: 
59733:     /* Sweep any cache entry pointing to dead GC things. */
60258:     void sweep(JSContext *cx);
59733: 
60574:     /* Mark any tracer stacks that are active. */
60574:     void mark(JSTracer *trc);
60574: 
59733:     bool outOfMemory() const;
69289: 
69289:     JS_FRIEND_API(void) getCodeAllocStats(size_t &total, size_t &frag_size, size_t &free_size) const;
69289:     JS_FRIEND_API(size_t) getVMAllocatorsMainSize() const;
69289:     JS_FRIEND_API(size_t) getVMAllocatorsReserveSize() const;
76306:     JS_FRIEND_API(size_t) getTraceMonitorSize() const;
59733: };
59733: 
56773: namespace mjit {
56773: class JaegerCompartment;
56773: }
56773: }
56773: 
74466: /* Defined in jsapi.cpp */
74466: extern JSClass js_dummy_class;
74466: 
76766: /* Number of potentially reusable scriptsToGC to search for the eval cache. */
59733: #ifndef JS_EVAL_CACHE_SHIFT
59733: # define JS_EVAL_CACHE_SHIFT        6
59733: #endif
59733: #define JS_EVAL_CACHE_SIZE          JS_BIT(JS_EVAL_CACHE_SHIFT)
59733: 
59954: namespace js {
59954: 
59954: class NativeIterCache {
59954:     static const size_t SIZE = size_t(1) << 8;
59954:     
59954:     /* Cached native iterators. */
59954:     JSObject            *data[SIZE];
59954: 
59954:     static size_t getIndex(uint32 key) {
59954:         return size_t(key) % SIZE;
59954:     }
59954: 
59954:   public:
59954:     /* Native iterator most recently started. */
59954:     JSObject            *last;
59954: 
59954:     NativeIterCache()
59954:       : last(NULL) {
59954:         PodArrayZero(data);
59954:     }
59954: 
59954:     void purge() {
59954:         PodArrayZero(data);
59954:         last = NULL;
59954:     }
59954: 
59954:     JSObject *get(uint32 key) const {
59954:         return data[getIndex(key)];
59954:     }
59954: 
59954:     void set(uint32 key, JSObject *iterobj) {
59954:         data[getIndex(key)] = iterobj;
59954:     }
59954: };
59954: 
72075: class MathCache;
72075: 
61432: /*
61432:  * A single-entry cache for some base-10 double-to-string conversions. This
61432:  * helps date-format-xparb.js.  It also avoids skewing the results for
61432:  * v8-splay.js when measured by the SunSpider harness, where the splay tree
61432:  * initialization (which includes many repeated double-to-string conversions)
61432:  * is erroneously included in the measurement; see bug 562553.
61432:  */
61432: class DtoaCache {
61432:     double        d;
61432:     jsint         base;
64345:     JSFixedString *s;      // if s==NULL, d and base are not valid
61432:   public:
61432:     DtoaCache() : s(NULL) {}
61432:     void purge() { s = NULL; }
61432: 
64345:     JSFixedString *lookup(jsint base, double d) {
61432:         return this->s && base == this->base && d == this->d ? this->s : NULL;
61432:     }
61432: 
64345:     void cache(jsint base, double d, JSFixedString *s) {
61432:         this->base = base;
61432:         this->d = d;
61432:         this->s = s;
61432:     }
61432: 
61432: };
61432: 
73899: struct ScriptFilenameEntry
73899: {
73899:     bool marked;
73899:     char filename[1];
73899: };
73899: 
73899: struct ScriptFilenameHasher
73899: {
73899:     typedef const char *Lookup;
73899:     static HashNumber hash(const char *l) { return JS_HashString(l); }
73899:     static bool match(const ScriptFilenameEntry *e, const char *l) {
73899:         return strcmp(e->filename, l) == 0;
73899:     }
73899: };
73899: 
73899: typedef HashSet<ScriptFilenameEntry *,
73899:                 ScriptFilenameHasher,
73899:                 SystemAllocPolicy> ScriptFilenameTable;
73899: 
59954: } /* namespace js */
59954: 
55650: struct JS_FRIEND_API(JSCompartment) {
54707:     JSRuntime                    *rt;
54707:     JSPrincipals                 *principals;
54707: 
55746:     js::gc::ArenaList            arenas[js::gc::FINALIZE_LIMIT];
54707:     js::gc::FreeLists            freeLists;
54707: 
68896:     uint32                       gcBytes;
68896:     uint32                       gcTriggerBytes;
60258:     size_t                       gcLastBytes;
60258: 
64258:     bool                         hold;
73901:     bool                         isSystemCompartment;
64258: 
59733: #ifdef JS_TRACER
72548:   private:
72548:     /*
72548:      * Trace-tree JIT recorder/interpreter state.  It's created lazily because
72548:      * many compartments don't end up needing it.
72548:      */
72548:     js::TraceMonitor             *traceMonitor_;
59733: #endif
59733: 
72548:   public:
59954:     /* Hashed lists of scripts created by eval to garbage-collect. */
76766:     JSScript                     *scriptsToGC[JS_EVAL_CACHE_SIZE];
59733: 
54707:     void                         *data;
59895:     bool                         active;  // GC flag, whether there are active frames
75497:     bool                         hasDebugModeCodeToDrop;
54707:     js::WrapperMap               crossCompartmentWrappers;
54707: 
56773: #ifdef JS_METHODJIT
72551:   private:
72551:     /* This is created lazily because many compartments don't need it. */
72551:     js::mjit::JaegerCompartment  *jaegerCompartment_;
69289:     /*
69289:      * This function is here so that xpconnect/src/xpcjsruntime.cpp doesn't
69289:      * need to see the declaration of JaegerCompartment, which would require
69289:      * #including MethodJIT.h into xpconnect/src/xpcjsruntime.cpp, which is
69289:      * difficult due to reasons explained in bug 483677.
69289:      */
72551:   public:
72551:     bool hasJaegerCompartment() {
72551:         return !!jaegerCompartment_;
72551:     }
72551: 
72551:     js::mjit::JaegerCompartment *jaegerCompartment() const {
72551:         JS_ASSERT(jaegerCompartment_);
72551:         return jaegerCompartment_;
72551:     }
72551: 
72551:     bool ensureJaegerCompartmentExists(JSContext *cx);
72551: 
69289:     size_t getMjitCodeSize() const;
56773: #endif
71317:     WTF::BumpPointerAllocator    *regExpAllocator;
56773: 
62077:     /*
62077:      * Shared scope property tree, and arena-pool for allocating its nodes.
62077:      */
62077:     js::PropertyTree             propertyTree;
62077: 
62077: #ifdef DEBUG
62077:     /* Property metering. */
62077:     jsrefcount                   livePropTreeNodes;
62077:     jsrefcount                   totalPropTreeNodes;
62077:     jsrefcount                   propTreeKidsChunks;
62077:     jsrefcount                   liveDictModeNodes;
62077: #endif
62077: 
62077:     /*
62077:      * Runtime-shared empty scopes for well-known built-in objects that lack
62077:      * class prototypes (the usual locus of an emptyShape). Mnemonic: ABCDEW
62077:      */
62077:     js::EmptyShape               *emptyArgumentsShape;
62077:     js::EmptyShape               *emptyBlockShape;
62077:     js::EmptyShape               *emptyCallShape;
62077:     js::EmptyShape               *emptyDeclEnvShape;
62077:     js::EmptyShape               *emptyEnumeratorShape;
62077:     js::EmptyShape               *emptyWithShape;
62077: 
62077:     typedef js::HashSet<js::EmptyShape *,
62077:                         js::DefaultHasher<js::EmptyShape *>,
62077:                         js::SystemAllocPolicy> EmptyShapeSet;
62077: 
62077:     EmptyShapeSet                emptyShapes;
62077: 
64377:     /*
67942:      * Initial shapes given to RegExp and String objects, encoding the initial
67942:      * sets of built-in instance properties and the fixed slots where they must
67942:      * be stored (see JSObject::JSSLOT_(REGEXP|STRING)_*). Later property
67942:      * additions may cause these shapes to not be used by a RegExp or String
67942:      * (even along the entire shape parent chain, should the object go into
67942:      * dictionary mode). But because all the initial properties are
67942:      * non-configurable, they will always map to fixed slots.
64377:      */
64377:     const js::Shape              *initialRegExpShape;
67942:     const js::Shape              *initialStringShape;
64377: 
75489:   private:
75489:     enum { DebugFromC = 1, DebugFromJS = 2 };
76243: 
75489:     uintN                        debugModeBits;  // see debugMode() below
76243: 
75489:   public:
56773:     JSCList                      scripts;        // scripts in this compartment
54707: 
59954:     js::NativeIterCache          nativeIterCache;
59954: 
69244:     typedef js::Maybe<js::ToSourceCache> LazyToSourceCache;
64213:     LazyToSourceCache            toSourceCache;
61687: 
73899:     js::ScriptFilenameTable      scriptFilenameTable;
73899: 
62077:     JSCompartment(JSRuntime *rt);
54707:     ~JSCompartment();
54707: 
54707:     bool init();
54707: 
63083:     /* Mark cross-compartment wrappers. */
64258:     void markCrossCompartmentWrappers(JSTracer *trc);
62077: 
54707:     bool wrap(JSContext *cx, js::Value *vp);
54707:     bool wrap(JSContext *cx, JSString **strp);
54707:     bool wrap(JSContext *cx, JSObject **objp);
54707:     bool wrapId(JSContext *cx, jsid *idp);
54707:     bool wrap(JSContext *cx, js::PropertyOp *op);
62395:     bool wrap(JSContext *cx, js::StrictPropertyOp *op);
54707:     bool wrap(JSContext *cx, js::PropertyDescriptor *desc);
54707:     bool wrap(JSContext *cx, js::AutoIdVector &props);
54707: 
59895:     void sweep(JSContext *cx, uint32 releaseInterval);
54707:     void purge(JSContext *cx);
54707:     void finishArenaLists();
69651:     void finalizeObjectArenaLists(JSContext *cx);
69651:     void finalizeStringArenaLists(JSContext *cx);
69651:     void finalizeShapeArenaLists(JSContext *cx);
54707:     bool arenaListsAreEmpty();
59735: 
72110:     void setGCLastBytes(size_t lastBytes, JSGCInvocationKind gckind);
68896:     void reduceGCTriggerBytes(uint32 amount);
60258: 
61432:     js::DtoaCache dtoaCache;
61432: 
59735:   private:
59735:     js::MathCache                *mathCache;
59735: 
59735:     js::MathCache *allocMathCache(JSContext *cx);
59735: 
62574:     typedef js::HashMap<jsbytecode*,
62574:                         size_t,
62574:                         js::DefaultHasher<jsbytecode*>,
62574:                         js::SystemAllocPolicy> BackEdgeMap;
62574: 
62574:     BackEdgeMap                  backEdgeTable;
62574: 
75452:     /*
75452:      * Weak reference to each global in this compartment that is a debuggee.
75452:      * Each global has its own list of debuggers.
75452:      */
75452:     js::GlobalObjectSet              debuggees;
75402: 
75506:   public:
75506:     js::BreakpointSiteMap            breakpointSites;
75506: 
75506:   private:
63147:     JSCompartment *thisForCtor() { return this; }
76248: 
59735:   public:
59735:     js::MathCache *getMathCache(JSContext *cx) {
59735:         return mathCache ? mathCache : allocMathCache(cx);
59735:     }
62077: 
72549: #ifdef JS_TRACER
72548:     bool hasTraceMonitor() {
72548:         return !!traceMonitor_;
72548:     }
72548: 
72548:     js::TraceMonitor *allocAndInitTraceMonitor(JSContext *cx);
72548: 
72548:     js::TraceMonitor *traceMonitor() const {
72548:         JS_ASSERT(traceMonitor_);
72548:         return traceMonitor_;
72548:     }
72549: #endif
72548: 
62574:     size_t backEdgeCount(jsbytecode *pc) const;
62574:     size_t incBackEdgeCount(jsbytecode *pc);
74472: 
75489:     /*
75489:      * There are dueling APIs for debug mode. It can be enabled or disabled via
75489:      * JS_SetDebugModeForCompartment. It is automatically enabled and disabled
75513:      * by Debugger objects. Therefore debugModeBits has the DebugFromC bit set
75513:      * if the C API wants debug mode and the DebugFromJS bit set if debuggees
76243:      * is non-empty.
75489:      */
75489:     bool debugMode() const { return !!debugModeBits; }
75489: 
75489:     /*
75489:      * True if any scripts from this compartment are on the JS stack in the
75489:      * calling thread. cx is a context in the calling thread, and it is assumed
75489:      * that no other thread is using this compartment.
75489:      */
75497:     bool hasScriptsOnStack(JSContext *cx);
75489: 
75497:   private:
75489:     /* This is called only when debugMode() has just toggled. */
75489:     void updateForDebugMode(JSContext *cx);
75489: 
75497:   public:
75452:     js::GlobalObjectSet &getDebuggees() { return debuggees; }
75497:     bool addDebuggee(JSContext *cx, js::GlobalObject *global);
75497:     void removeDebuggee(JSContext *cx, js::GlobalObject *global,
75497:                         js::GlobalObjectSet::Enum *debuggeesEnum = NULL);
75506:     bool setDebugModeFromC(JSContext *cx, bool b);
75497: 
75506:     js::BreakpointSite *getBreakpointSite(jsbytecode *pc);
75506:     js::BreakpointSite *getOrCreateBreakpointSite(JSContext *cx, JSScript *script, jsbytecode *pc,
75506:                                                   JSObject *scriptObject);
75513:     void clearBreakpointsIn(JSContext *cx, js::Debugger *dbg, JSScript *script, JSObject *handler);
75506:     void clearTraps(JSContext *cx, JSScript *script);
77173:     bool markTrapClosuresIteratively(JSTracer *trc);
76248: 
75506:   private:
75506:     void sweepBreakpoints(JSContext *cx);
76246: 
76246:   public:
74472:     js::WatchpointMap *watchpointMap;
54707: };
54707: 
76766: #define JS_SCRIPTS_TO_GC(cx)    ((cx)->compartment->scriptsToGC)
62077: #define JS_PROPERTY_TREE(cx)    ((cx)->compartment->propertyTree)
62077: 
62032: /*
62032:  * N.B. JS_ON_TRACE(cx) is true if JIT code is on the stack in the current
62032:  * thread, regardless of whether cx is the context in which that trace is
62032:  * executing. cx must be a context on the current thread.
62032:  */
62033: static inline bool
73071: JS_ON_TRACE(const JSContext *cx)
62033: {
62032: #ifdef JS_TRACER
62033:     if (JS_THREAD_DATA(cx)->onTraceCompartment)
72548:         return JS_THREAD_DATA(cx)->onTraceCompartment->traceMonitor()->ontrace();
62032: #endif
62033:     return false;
62033: }
62033: 
62033: #ifdef JS_TRACER
62033: static inline js::TraceMonitor *
62033: JS_TRACE_MONITOR_ON_TRACE(JSContext *cx)
62033: {
62033:     JS_ASSERT(JS_ON_TRACE(cx));
72548:     return JS_THREAD_DATA(cx)->onTraceCompartment->traceMonitor();
62033: }
62033: 
62033: /*
62033:  * Only call this directly from the interpreter loop or the method jit.
62033:  * Otherwise, we may get the wrong compartment, and thus the wrong
62033:  * TraceMonitor.
62033:  */
62033: static inline js::TraceMonitor *
62033: JS_TRACE_MONITOR_FROM_CONTEXT(JSContext *cx)
62033: {
72548:     return cx->compartment->traceMonitor();
72548: }
72548: 
72548: /*
72548:  * This one also creates the TraceMonitor if it doesn't already exist.
72548:  * It returns NULL if the lazy creation fails due to OOM.
72548:  */
72548: static inline js::TraceMonitor *
72548: JS_TRACE_MONITOR_FROM_CONTEXT_WITH_LAZY_INIT(JSContext *cx)
72548: {
72548:     if (!cx->compartment->hasTraceMonitor())
72548:         return cx->compartment->allocAndInitTraceMonitor(cx);
72548:         
72548:     return cx->compartment->traceMonitor();
62033: }
62033: #endif
62033: 
62033: static inline js::TraceRecorder *
62033: TRACE_RECORDER(JSContext *cx)
62033: {
62033: #ifdef JS_TRACER
62033:     if (JS_THREAD_DATA(cx)->recordingCompartment)
72548:         return JS_THREAD_DATA(cx)->recordingCompartment->traceMonitor()->recorder;
62033: #endif
62033:     return NULL;
62033: }
62033: 
62033: static inline js::LoopProfile *
62033: TRACE_PROFILER(JSContext *cx)
62033: {
62033: #ifdef JS_TRACER
62033:     if (JS_THREAD_DATA(cx)->profilingCompartment)
72548:         return JS_THREAD_DATA(cx)->profilingCompartment->traceMonitor()->profile;
62033: #endif
62033:     return NULL;
62033: }
62032: 
59735: namespace js {
59735: static inline MathCache *
59735: GetMathCache(JSContext *cx)
59735: {
59735:     return cx->compartment->getMathCache(cx);
59735: }
59735: }
59735: 
56018: #ifdef _MSC_VER
56018: #pragma warning(pop)
56018: #endif
56018: 
54733: namespace js {
54733: 
54733: class PreserveCompartment {
54733:   protected:
54733:     JSContext *cx;
54733:   private:
54733:     JSCompartment *oldCompartment;
54738:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
54733:   public:
54737:      PreserveCompartment(JSContext *cx JS_GUARD_OBJECT_NOTIFIER_PARAM) : cx(cx) {
54737:         JS_GUARD_OBJECT_NOTIFIER_INIT;
54733:         oldCompartment = cx->compartment;
54733:     }
54733: 
54733:     ~PreserveCompartment() {
54733:         cx->compartment = oldCompartment;
54733:     }
54733: };
54733: 
54733: class SwitchToCompartment : public PreserveCompartment {
54733:   public:
64288:     SwitchToCompartment(JSContext *cx, JSCompartment *newCompartment
64288:                         JS_GUARD_OBJECT_NOTIFIER_PARAM)
64288:         : PreserveCompartment(cx)
64288:     {
64288:         JS_GUARD_OBJECT_NOTIFIER_INIT;
54733:         cx->compartment = newCompartment;
54733:     }
54733: 
64288:     SwitchToCompartment(JSContext *cx, JSObject *target JS_GUARD_OBJECT_NOTIFIER_PARAM)
64288:         : PreserveCompartment(cx)
64288:     {
64288:         JS_GUARD_OBJECT_NOTIFIER_INIT;
56578:         cx->compartment = target->getCompartment();
54733:     }
64288: 
64288:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
54733: };
54733: 
60162: class AssertCompartmentUnchanged {
60162:   protected:
60162:     JSContext * const cx;
60162:     JSCompartment * const oldCompartment;
60162:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
60162:   public:
60162:      AssertCompartmentUnchanged(JSContext *cx JS_GUARD_OBJECT_NOTIFIER_PARAM)
60162:      : cx(cx), oldCompartment(cx->compartment) {
60162:         JS_GUARD_OBJECT_NOTIFIER_INIT;
60162:     }
60162: 
60162:     ~AssertCompartmentUnchanged() {
60162:         JS_ASSERT(cx->compartment == oldCompartment);
60162:     }
60162: };
60162: 
54733: }
54733: 
54733: #endif /* jscompartment_h___ */
