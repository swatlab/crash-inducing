    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Nate Nielsen <nielsen@memberwebs.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* High level class and public functions implementation. */
    1: 
    1: #include "xpcprivate.h"
    1: #include "XPCNativeWrapper.h"
    1: #include "nsBaseHashtable.h"
    1: #include "nsHashKeys.h"
   33: #include "jsatom.h"
   33: #include "jsfun.h"
    1: #include "jsobj.h"
   33: #include "jsscript.h"
 3310: #include "nsThreadUtilsInternal.h"
18543: #include "dom_quickstubs.h"
    1: 
20462: NS_IMPL_THREADSAFE_ISUPPORTS6(nsXPConnect,
 3310:                               nsIXPConnect,
 3310:                               nsISupportsWeakReference,
20312:                               nsIThreadObserver,
20462:                               nsIJSRuntimeService,
20462:                               nsIJSContextStack,
20462:                               nsIThreadJSContextStack)
    1: 
    1: nsXPConnect* nsXPConnect::gSelf = nsnull;
    1: JSBool       nsXPConnect::gOnceAliveNowDead = JS_FALSE;
14170: PRUint32     nsXPConnect::gReportAllJSExceptions = 0;
    1: 
 8870: // Global cache of the default script security manager (QI'd to
 8870: // nsIScriptSecurityManager)
 8870: nsIScriptSecurityManager *gScriptSecurityManager = nsnull;
 8870: 
    1: const char XPC_CONTEXT_STACK_CONTRACTID[] = "@mozilla.org/js/xpc/ContextStack;1";
    1: const char XPC_RUNTIME_CONTRACTID[]       = "@mozilla.org/js/xpc/RuntimeService;1";
    1: const char XPC_EXCEPTION_CONTRACTID[]     = "@mozilla.org/js/xpc/Exception;1";
    1: const char XPC_CONSOLE_CONTRACTID[]       = "@mozilla.org/consoleservice;1";
    1: const char XPC_SCRIPT_ERROR_CONTRACTID[]  = "@mozilla.org/scripterror;1";
    1: const char XPC_ID_CONTRACTID[]            = "@mozilla.org/js/xpc/ID;1";
    1: const char XPC_XPCONNECT_CONTRACTID[]     = "@mozilla.org/js/xpc/XPConnect;1";
    1: 
    1: /***************************************************************************/
    1: 
    1: nsXPConnect::nsXPConnect()
    1:     :   mRuntime(nsnull),
    1:         mInterfaceInfoManager(do_GetService(NS_INTERFACEINFOMANAGER_SERVICE_CONTRACTID)),
    1:         mDefaultSecurityManager(nsnull),
    1:         mDefaultSecurityManagerFlags(0),
    1:         mShuttingDown(JS_FALSE),
 7286:         mCycleCollectionContext(nsnull),
 7286:         mCycleCollecting(PR_FALSE)
    1: {
20312:     mRuntime = XPCJSRuntime::newXPCJSRuntime(this);
    1: 
    1:     nsCycleCollector_registerRuntime(nsIProgrammingLanguage::JAVASCRIPT, this);
 7286: #ifdef DEBUG_CC
 7286:     mJSRoots.ops = nsnull;
 7286: #endif
    1: 
    1: #ifdef XPC_TOOLS_SUPPORT
    1:   {
    1:     char* filename = PR_GetEnv("MOZILLA_JS_PROFILER_OUTPUT");
    1:     if(filename && *filename)
    1:     {
    1:         mProfilerOutputFile = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
    1:         if(mProfilerOutputFile &&
    1:            NS_SUCCEEDED(mProfilerOutputFile->InitWithNativePath(nsDependentCString(filename))))
    1:         {
    1:             mProfiler = do_GetService(XPCTOOLS_PROFILER_CONTRACTID);
    1:             if(mProfiler)
    1:             {
    1:                 if(NS_SUCCEEDED(mProfiler->Start()))
    1:                 {
    1: #ifdef DEBUG
    1:                     printf("***** profiling JavaScript. Output to: %s\n",
    1:                            filename);
    1: #endif
    1:                 }
    1:             }
    1:         }
    1:     }
    1:   }
    1: #endif
14170:     char* reportableEnv = PR_GetEnv("MOZ_REPORT_ALL_JS_EXCEPTIONS");
14170:     if(reportableEnv && *reportableEnv)
14170:         gReportAllJSExceptions = 1;
    1: }
    1: 
    1: nsXPConnect::~nsXPConnect()
    1: {
 1084:     NS_ASSERTION(!mCycleCollectionContext,
 1084:                  "Didn't call FinishCycleCollection?");
    1:     nsCycleCollector_forgetRuntime(nsIProgrammingLanguage::JAVASCRIPT);
    1: 
 2991:     JSContext *cx = nsnull;
 2991:     if (mRuntime) {
 3100:         // Create our own JSContext rather than an XPCCallContext, since
 3100:         // otherwise we will create a new safe JS context and attach a
 3100:         // components object that won't get GCed.
 3100:         // And do this before calling CleanupAllThreads, so that we
 3100:         // don't create an extra xpcPerThreadData.
 2991:         cx = JS_NewContext(mRuntime->GetJSRuntime(), 8192);
 2991:     }
 2991: 
 2991:     XPCPerThreadData::CleanupAllThreads();
    1:     mShuttingDown = JS_TRUE;
 2991:     if (cx) {
 2991:         JS_BeginRequest(cx);
    1: 
 2991:         // XXX Call even if |mRuntime| null?
 2991:         XPCWrappedNativeScope::SystemIsBeingShutDown(cx);
 2991: 
 2991:         mRuntime->SystemIsBeingShutDown(cx);
 2991: 
 2991:         JS_EndRequest(cx);
 2991:         JS_DestroyContext(cx);
    1:     }
    1: 
    1:     NS_IF_RELEASE(mDefaultSecurityManager);
    1: 
 8870:     gScriptSecurityManager = nsnull;
 8870: 
    1:     // shutdown the logging system
    1:     XPC_LOG_FINISH();
    1: 
    1:     delete mRuntime;
    1: 
    1:     gSelf = nsnull;
    1:     gOnceAliveNowDead = JS_TRUE;
    1: }
    1: 
    1: // static
    1: nsXPConnect*
    1: nsXPConnect::GetXPConnect()
    1: {
    1:     if(!gSelf)
    1:     {
    1:         if(gOnceAliveNowDead)
    1:             return nsnull;
    1:         gSelf = new nsXPConnect();
    1:         if(!gSelf)
    1:             return nsnull;
    1: 
20312:         if(!gSelf->mRuntime ||
20462:            !gSelf->mInterfaceInfoManager)
    1:         {
    1:             // ctor failed to create an acceptable instance
    1:             delete gSelf;
    1:             gSelf = nsnull;
    1:         }
    1:         else
    1:         {
    1:             // Initial extra ref to keep the singleton alive
    1:             // balanced by explicit call to ReleaseXPConnectSingleton()
    1:             NS_ADDREF(gSelf);
 3310:             if (NS_FAILED(NS_SetGlobalThreadObserver(gSelf))) {
 3310:                 NS_RELEASE(gSelf);
 3310:                 // Fall through to returning null
 3310:             }
    1:         }
    1:     }
    1:     return gSelf;
    1: }
    1: 
    1: // static
    1: nsXPConnect*
    1: nsXPConnect::GetSingleton()
    1: {
    1:     nsXPConnect* xpc = nsXPConnect::GetXPConnect();
    1:     NS_IF_ADDREF(xpc);
    1:     return xpc;
    1: }
    1: 
    1: // static
    1: void
    1: nsXPConnect::ReleaseXPConnectSingleton()
    1: {
    1:     nsXPConnect* xpc = gSelf;
    1:     if(xpc)
    1:     {
 3310:         NS_SetGlobalThreadObserver(nsnull);
    1: 
    1: #ifdef XPC_TOOLS_SUPPORT
    1:         if(xpc->mProfiler)
    1:         {
    1:             xpc->mProfiler->Stop();
    1:             xpc->mProfiler->WriteResults(xpc->mProfilerOutputFile);
    1:         }
    1: #endif
    1: 
  858: #ifdef DEBUG
    1:         // force a dump of the JavaScript gc heap if JS is still alive
  858:         // if requested through XPC_SHUTDOWN_HEAP_DUMP environment variable
20462:         {
20462:             // autoscope
    1:             XPCCallContext ccx(NATIVE_CALLER);
    1:             if(ccx.IsValid())
    1:             {
  858:                 const char* dumpName = getenv("XPC_SHUTDOWN_HEAP_DUMP");
  858:                 if(dumpName)
  858:                 {
  858:                     FILE* dumpFile = (*dumpName == '\0' ||
  858:                                       strcmp(dumpName, "stdout") == 0)
  858:                                      ? stdout
  858:                                      : fopen(dumpName, "w");
  858:                     if(dumpFile)
  858:                     {
  917:                         JS_DumpHeap(ccx, dumpFile, nsnull, 0, nsnull,
 3233:                                     static_cast<size_t>(-1), nsnull);
  858:                         if(dumpFile != stdout)
  858:                             fclose(dumpFile);
  858:                     }
  858:                 }
    1:             }
20462:         }
    1: #endif
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         // NOTE: to see really interesting stuff turn on the prlog stuff.
    1:         // See the comment at the top of xpclog.h to see how to do that.
    1:         xpc->DebugDump(7);
    1: #endif
    1:         nsrefcnt cnt;
    1:         NS_RELEASE2(xpc, cnt);
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         if(0 != cnt)
    1:             printf("*** dangling reference to nsXPConnect: refcnt=%d\n", cnt);
    1:         else
    1:             printf("+++ XPConnect had no dangling references.\n");
    1: #endif
    1:     }
    1: }
    1: 
    1: // static
    1: nsresult
    1: nsXPConnect::GetInterfaceInfoManager(nsIInterfaceInfoSuperManager** iim,
    1:                                      nsXPConnect* xpc /*= nsnull*/)
    1: {
    1:     if(!xpc && !(xpc = GetXPConnect()))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     *iim = xpc->mInterfaceInfoManager;
    1:     NS_IF_ADDREF(*iim);
    1:     return NS_OK;
    1: }
    1: 
    1: // static
    1: XPCJSRuntime*
20312: nsXPConnect::GetRuntimeInstance()
    1: {
20312:     nsXPConnect* xpc = GetXPConnect();
20312:     NS_ASSERTION(xpc, "Must not be called if XPC failed to initialize");
20312:     return xpc->GetRuntime();
    1: }
    1: 
    1: // static
    1: JSBool
    1: nsXPConnect::IsISupportsDescendant(nsIInterfaceInfo* info)
    1: {
    1:     PRBool found = PR_FALSE;
    1:     if(info)
    1:         info->HasAncestor(&NS_GET_IID(nsISupports), &found);
    1:     return found;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: typedef PRBool (*InfoTester)(nsIInterfaceInfoManager* manager, const void* data,
    1:                              nsIInterfaceInfo** info);
    1: 
    1: static PRBool IIDTester(nsIInterfaceInfoManager* manager, const void* data,
    1:                         nsIInterfaceInfo** info)
    1: {
    1:     return NS_SUCCEEDED(manager->GetInfoForIID((const nsIID *) data, info)) &&
    1:            *info;
    1: }
    1: 
    1: static PRBool NameTester(nsIInterfaceInfoManager* manager, const void* data,
    1:                       nsIInterfaceInfo** info)
    1: {
    1:     return NS_SUCCEEDED(manager->GetInfoForName((const char *) data, info)) &&
    1:            *info;
    1: }
    1: 
    1: static nsresult FindInfo(InfoTester tester, const void* data, 
    1:                          nsIInterfaceInfoSuperManager* iism,
    1:                          nsIInterfaceInfo** info)
    1: {
    1:     if(tester(iism, data, info))
    1:         return NS_OK;
    1:     
    1:     // If not found, then let's ask additional managers.
    1: 
    1:     PRBool yes;
    1:     nsCOMPtr<nsISimpleEnumerator> list;
    1: 
    1:     if(NS_SUCCEEDED(iism->HasAdditionalManagers(&yes)) && yes &&
    1:        NS_SUCCEEDED(iism->EnumerateAdditionalManagers(getter_AddRefs(list))) &&
    1:        list)
    1:     {
    1:         PRBool more;
    1:         nsCOMPtr<nsIInterfaceInfoManager> current;
    1: 
    1:         while(NS_SUCCEEDED(list->HasMoreElements(&more)) && more &&
    1:               NS_SUCCEEDED(list->GetNext(getter_AddRefs(current))) && current)
    1:         {
    1:             if(tester(current, data, info))
    1:                 return NS_OK;
    1:         }
    1:     }
    1:     
    1:     return NS_ERROR_NO_INTERFACE;
    1: }    
    1: 
    1: nsresult
    1: nsXPConnect::GetInfoForIID(const nsIID * aIID, nsIInterfaceInfo** info)
    1: {
    1:     return FindInfo(IIDTester, aIID, mInterfaceInfoManager, info);
    1: }
    1: 
    1: nsresult
    1: nsXPConnect::GetInfoForName(const char * name, nsIInterfaceInfo** info)
    1: {
    1:     return FindInfo(NameTester, name, mInterfaceInfoManager, info);
    1: }
    1: 
    1: static JSGCCallback gOldJSGCCallback;
10141: // Whether cycle collection was run.
10141: static PRBool gDidCollection;
10141: // Whether starting cycle collection was successful.
10141: static PRBool gInCollection;
10141: // Whether cycle collection collected anything.
10141: static PRBool gCollected;
    1: 
18907: static JSBool
 7286: XPCCycleCollectGCCallback(JSContext *cx, JSGCStatus status)
    1: {
 7286:     // Launch the cycle collector.
 7286:     if(status == JSGC_MARK_END)
 7286:     {
 7286:         // This is the hook between marking and sweeping in the JS GC. Do cycle
 7286:         // collection.
10141:         if(!gDidCollection)
10141:         {
10141:             NS_ASSERTION(!gInCollection, "Recursing?");
10141: 
10141:             gDidCollection = PR_TRUE;
10141:             gInCollection = nsCycleCollector_beginCollection();
10141:         }
    1: 
 7286:         // Mark JS objects that are held by XPCOM objects that are in cycles
 7286:         // that will not be collected.
20312:         nsXPConnect::GetRuntimeInstance()->
 7286:             TraceXPConnectRoots(cx->runtime->gcMarkingTracer);
    1:     }
 7339:     else if(status == JSGC_END)
10141:     {
10141:         if(gInCollection)
10141:         {
10141:             gInCollection = PR_FALSE;
10141:             gCollected = nsCycleCollector_finishCollection();
10141:         }
20312:         nsXPConnect::GetRuntimeInstance()->RestoreContextGlobals();
10141:     }
    1: 
 7339:     PRBool ok = gOldJSGCCallback ? gOldJSGCCallback(cx, status) : JS_TRUE;
 7339: 
 7339:     if(status == JSGC_BEGIN)
20312:         nsXPConnect::GetRuntimeInstance()->UnsetContextGlobals();
 7339: 
 7339:     return ok;
    1: }
    1: 
10141: PRBool
 7286: nsXPConnect::Collect()
    1: {
 7286:     // We're dividing JS objects into 2 categories:
 7286:     //
 7286:     // 1. "real" roots, held by the JS engine itself or rooted through the root
 7286:     //    and lock JS APIs. Roots from this category are considered black in the
 7286:     //    cycle collector, any cycle they participate in is uncollectable.
 7286:     //
 7286:     // 2. roots held by C++ objects that participate in cycle collection,
 7286:     //    held by XPConnect (see XPCJSRuntime::TraceXPConnectRoots). Roots from
 7286:     //    this category are considered grey in the cycle collector, their final
 7286:     //    color depends on the objects that hold them. It is thus very important
 7286:     //    to always traverse the objects that hold these objects during cycle
 7286:     //    collection (see XPCJSRuntime::AddXPConnectRoots).
 7286:     //
 7286:     // Note that if a root is in both categories it is the fact that it is in
 7286:     // category 1 that takes precedence, so it will be considered black.
 7286:     //
 7286:     //
 7286:     // We split up garbage collection into 3 phases (1, 3 and 4) and do cycle
 7286:     // collection between the first 2 phases of garbage collection:
 7286:     //
 7286:     // 1. marking of the roots in category 1 by having the JS GC do its marking
 7286:     // 2. cycle collection
 7286:     // 3. marking of the roots in category 2 by
 7286:     //    XPCJSRuntime::TraceXPConnectRoots 
 7286:     // 4. sweeping of unmarked JS objects
 7286:     //
 7286:     // During cycle collection, marked JS objects (and the objects they hold)
 7286:     // will be colored black. White objects holding roots from category 2 will
 7286:     // be forgotten by XPConnect (in the unlink callback of the white objects).
 7286:     // During phase 3 we'll only mark black objects holding JS objects (white
 7286:     // objects were forgotten) and white JS objects will be swept during
 7286:     // phase 4.
 7286:     // Because splitting up the JS GC itself is hard, we're going to use a GC
 7286:     // callback to do phase 2 and 3 after phase 1 has ended (see
 7286:     // XPCCycleCollectGCCallback).
 7286:     //
 7286:     // If DEBUG_CC is not defined the cycle collector will not traverse  roots
 7286:     // from category 1 or any JS objects held by them. Any JS objects they hold
 7286:     // will already be marked by the JS GC and will thus be colored black
 7286:     // themselves. Any C++ objects they hold will have a missing (untraversed)
 7286:     // edge from the JS object to the C++ object and so it will be marked black
 7286:     // too. This decreases the number of objects that the cycle collector has to
 7286:     // deal with.
 7286:     // To improve debugging, if DEBUG_CC is defined all JS objects are
 7286:     // traversed.
    1: 
 7286:     XPCCallContext cycleCollectionContext(NATIVE_CALLER);
 7286:     if(!cycleCollectionContext.IsValid())
 1084:     {
 7286:         return PR_FALSE;
 1084:     }
 1084: 
 7286:     mCycleCollecting = PR_TRUE;
 7286:     mCycleCollectionContext = &cycleCollectionContext;
10141:     gDidCollection = PR_FALSE;
10141:     gInCollection = PR_FALSE;
10141:     gCollected = PR_FALSE;
 7286: 
 1084:     JSContext *cx = mCycleCollectionContext->GetJSContext();
 7286:     gOldJSGCCallback = JS_SetGCCallback(cx, XPCCycleCollectGCCallback);
    1:     JS_GC(cx);
    1:     JS_SetGCCallback(cx, gOldJSGCCallback);
    1:     gOldJSGCCallback = nsnull;
    1: 
 7286:     mCycleCollectionContext = nsnull;
 7286:     mCycleCollecting = PR_FALSE;
 7286: 
10141:     return gCollected;
 7286: }
 7286: 
 8146: // JSTRACE_XML can recursively hold on to more JSTRACE_XML objects, adding it to
 8146: // the cycle collector avoids stack overflow.
13824: #define ADD_TO_CC(_kind)    ((_kind) == JSTRACE_OBJECT || (_kind) == JSTRACE_XML)
 8146: 
 7286: #ifdef DEBUG_CC
 7286: struct NoteJSRootTracer : public JSTracer
 7286: {
 7286:     NoteJSRootTracer(PLDHashTable *aObjects,
 7286:                      nsCycleCollectionTraversalCallback& cb)
 7286:       : mObjects(aObjects),
 7286:         mCb(cb)
 7286:     {
 7286:     }
 7286:     PLDHashTable* mObjects;
 7286:     nsCycleCollectionTraversalCallback& mCb;
 7286: };
 7286: 
18907: static void
 7286: NoteJSRoot(JSTracer *trc, void *thing, uint32 kind)
 7286: {
 8146:     if(ADD_TO_CC(kind))
 7286:     {
 7286:         NoteJSRootTracer *tracer = static_cast<NoteJSRootTracer*>(trc);
 7286:         PLDHashEntryHdr *entry = PL_DHashTableOperate(tracer->mObjects, thing,
 7286:                                                       PL_DHASH_ADD);
 7286:         if(entry && !reinterpret_cast<PLDHashEntryStub*>(entry)->key)
 7286:         {
 7286:             reinterpret_cast<PLDHashEntryStub*>(entry)->key = thing;
 7286:             tracer->mCb.NoteRoot(nsIProgrammingLanguage::JAVASCRIPT, thing,
 7286:                                  nsXPConnect::GetXPConnect());
 7286:         }
 7286:     }
 8146:     else if(kind != JSTRACE_DOUBLE && kind != JSTRACE_STRING)
 8146:     {
 8146:         JS_TraceChildren(trc, thing, kind);
 8146:     }
 7286: }
 7286: #endif
 7286: 
 7286: nsresult 
 7286: nsXPConnect::BeginCycleCollection(nsCycleCollectionTraversalCallback &cb)
 7286: {
 7286: #ifdef DEBUG_CC
 7286:     NS_ASSERTION(!mJSRoots.ops, "Didn't call FinishCollection?");
 7286: 
 7286:     if(!mCycleCollectionContext)
 7286:     {
 7286:         // Being called from nsCycleCollector::ExplainLiveExpectedGarbage.
 7286:         mExplainCycleCollectionContext = new XPCCallContext(NATIVE_CALLER);
 7286:         if(!mExplainCycleCollectionContext ||
 7286:            !mExplainCycleCollectionContext->IsValid())
 7286:         {
 7286:             mExplainCycleCollectionContext = nsnull;
 7286:             return PR_FALSE;
 7286:         }
 7286: 
 7286:         mCycleCollectionContext = mExplainCycleCollectionContext;
 7286: 
 7286:         // Record all objects held by the JS runtime. This avoids doing a
 7286:         // complete GC if we're just tracing to explain (from
 7286:         // ExplainLiveExpectedGarbage), which makes the results of cycle
 7286:         // collection identical for DEBUG_CC and non-DEBUG_CC builds.
 7286:         if(!PL_DHashTableInit(&mJSRoots, PL_DHashGetStubOps(), nsnull,
 7286:                               sizeof(PLDHashEntryStub), PL_DHASH_MIN_SIZE)) {
 7286:             mJSRoots.ops = nsnull;
 7286: 
 7286:             return NS_ERROR_OUT_OF_MEMORY;
 7286:         }
 7286: 
20312:         GetRuntime()->UnsetContextGlobals();
10193: 
 7286:         PRBool alreadyCollecting = mCycleCollecting;
 7286:         mCycleCollecting = PR_TRUE;
 7286:         NoteJSRootTracer trc(&mJSRoots, cb);
 7286:         JS_TRACER_INIT(&trc, mCycleCollectionContext->GetJSContext(),
 7286:                        NoteJSRoot);
 7286:         JS_TraceRuntime(&trc);
 7286:         mCycleCollecting = alreadyCollecting;
 7286:     }
 7286: #else
 7286:     NS_ASSERTION(mCycleCollectionContext,
 7286:                  "Didn't call nsXPConnect::Collect()?");
 7286: #endif
 7286: 
 7286:     GetRuntime()->AddXPConnectRoots(mCycleCollectionContext->GetJSContext(),
 7286:                                     cb);
 2954: 
    1: #ifndef XPCONNECT_STANDALONE
 7286:     if(!mScopes.IsInitialized())
 7286:     {
 7286:         mScopes.Init();
 7286:     }
 7286:     NS_ASSERTION(mScopes.Count() == 0, "Didn't clear mScopes?");
 1084:     XPCWrappedNativeScope::TraverseScopes(*mCycleCollectionContext);
    1: #endif
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: #ifndef XPCONNECT_STANDALONE
    1: void
    1: nsXPConnect::RecordTraversal(void *p, nsISupports *s)
    1: {
 7286:     mScopes.Put(p, s);
    1: }
    1: #endif
    1: 
    1: nsresult 
    1: nsXPConnect::FinishCycleCollection()
    1: {
 7286: #ifdef DEBUG_CC
 7286:     if(mExplainCycleCollectionContext)
 7286:     {
 1084:         mCycleCollectionContext = nsnull;
 7286:         mExplainCycleCollectionContext = nsnull;
10193: 
20312:         GetRuntime()->RestoreContextGlobals();
 7286:     }
 7286: #endif
 7286: 
 7286: #ifndef XPCONNECT_STANDALONE
 7286:     mScopes.Clear();
 7286: #endif
 7286: 
 7286: #ifdef DEBUG_CC
 7286:     if(mJSRoots.ops)
 7286:     {
 7286:         PL_DHashTableFinish(&mJSRoots);
 7286:         mJSRoots.ops = nsnull;
 7286:     }
 7286: #endif
 7286: 
    1:     return NS_OK;
    1: }
    1: 
 3669: nsCycleCollectionParticipant *
 3669: nsXPConnect::ToParticipant(void *p)
 3669: {
 3669:     return this;
 3669: }
 3669: 
 1829: NS_IMETHODIMP
10981: nsXPConnect::RootAndUnlinkJSObjects(void *p)
 1829: {
 1829:     return NS_OK;
 1829: }
 1829: 
 5183: #ifdef DEBUG_CC
 5183: void
 5183: nsXPConnect::PrintAllReferencesTo(void *p)
 5183: {
 5183: #ifdef DEBUG
 5183:     if(!mCycleCollectionContext) {
 5183:         NS_NOTREACHED("no context");
 5183:         return;
 5183:     }
 5183:     JS_DumpHeap(*mCycleCollectionContext, stdout, nsnull, 0, p,
 5183:                 0x7fffffff, nsnull);
 5183: #endif
 5183: }
 5183: #endif
 5183: 
 1829: NS_IMETHODIMP
 1829: nsXPConnect::Unlink(void *p)
    1: {
    1:     return NS_OK;
    1: }
    1: 
 1829: NS_IMETHODIMP
 1829: nsXPConnect::Unroot(void *p)
    1: {
    1:     return NS_OK;
    1: }
    1: 
 7286: struct TraversalTracer : public JSTracer
   33: {
 7286:     TraversalTracer(nsCycleCollectionTraversalCallback &aCb) : cb(aCb)
 7286:     {
 7286:     }
 7286:     nsCycleCollectionTraversalCallback &cb;
 1846: };
   33: 
18907: static void
 1846: NoteJSChild(JSTracer *trc, void *thing, uint32 kind)
   33: {
 8146:     if(ADD_TO_CC(kind))
 1846:     {
 7286:         TraversalTracer *tracer = static_cast<TraversalTracer*>(trc);
13202: #if defined(DEBUG) && defined(DEBUG_CC)
13202:         // based on DumpNotify in jsapi.c
13202:         if (tracer->debugPrinter) {
13202:             char buffer[200];
13202:             tracer->debugPrinter(trc, buffer, sizeof(buffer));
13202:             tracer->cb.NoteNextEdgeName(buffer);
13202:         } else if (tracer->debugPrintIndex != (size_t)-1) {
13202:             char buffer[200];
13202:             JS_snprintf(buffer, sizeof(buffer), "%s[%lu]",
13202:                         static_cast<const char *>(tracer->debugPrintArg),
13202:                         tracer->debugPrintIndex);
13202:             tracer->cb.NoteNextEdgeName(buffer);
13202:         } else {
13202:             tracer->cb.NoteNextEdgeName(
13202:               static_cast<const char*>(tracer->debugPrintArg));
13202:         }
13202: #endif
 7286:         tracer->cb.NoteScriptChild(nsIProgrammingLanguage::JAVASCRIPT, thing);
 1846:     }
 8146:     else if(kind != JSTRACE_DOUBLE && kind != JSTRACE_STRING)
 8146:     {
 8146:         JS_TraceChildren(trc, thing, kind);
 8146:     }
 1846: }
 1846: 
 1829: NS_IMETHODIMP
 1846: nsXPConnect::Traverse(void *p, nsCycleCollectionTraversalCallback &cb)
    1: {
 1084:     if(!mCycleCollectionContext)
 1084:         return NS_ERROR_FAILURE;
 1084: 
 1084:     JSContext *cx = mCycleCollectionContext->GetJSContext();
    1: 
 8005:     uint32 traceKind = js_GetGCThingTraceKind(p);
 7286: 
 7286:     CCNodeType type;
    1: 
 1846: #ifdef DEBUG_CC
11407:     {
11406:     // Note that the conditions under which we specify GCMarked vs.
11406:     // GCUnmarked are different between ExplainLiveExpectedGarbage and
11406:     // the normal case.  In the normal case, we're saying that anything
11406:     // reachable from a JS runtime root is itself such a root.  This
11406:     // doesn't actually break anything; it really just does some of the
11406:     // cycle collector's work for it.  However, when debugging, we
11406:     // (1) actually need to know what the root is and (2) don't want to
11406:     // do an extra GC, so we use mJSRoots, built from JS_TraceRuntime,
11406:     // which produces a different result because we didn't call
11406:     // JS_TraceChildren to trace everything that was reachable.
 7286:     if(mJSRoots.ops)
 7286:     {
11406:         // ExplainLiveExpectedGarbage codepath
 7286:         PLDHashEntryHdr* entry =
 7286:             PL_DHashTableOperate(&mJSRoots, p, PL_DHASH_LOOKUP);
 7286:         type = PL_DHASH_ENTRY_IS_BUSY(entry) ? GCMarked : GCUnmarked;
 7286:     }
 7286:     else
 7286:     {
11406:         // Normal codepath (matches non-DEBUG_CC codepath).
 7286:         type = JS_IsAboutToBeFinalized(cx, p) ? GCUnmarked : GCMarked;
 7286:     }
 7286: 
11407:     char name[72];
 8005:     if(traceKind == JSTRACE_OBJECT)
 1846:     {
 3233:         JSObject *obj = static_cast<JSObject*>(p);
    1:         JSClass *clazz = OBJ_GET_CLASS(cx, obj);
    1:         if(XPCNativeWrapper::IsNativeWrapperClass(clazz))
    1:         {
10858:             XPCWrappedNative* wn = XPCNativeWrapper::GetWrappedNative(obj);
   33:             if(wn)
   33:             {
   33:                 XPCNativeScriptableInfo* si = wn->GetScriptableInfo();
    1:                 if(si)
   33:                 {
    1:                     JS_snprintf(name, sizeof(name), "XPCNativeWrapper (%s)",
    1:                                 si->GetJSClass()->name);
   33:                 }
   33:                 else
   33:                 {
   33:                     nsIClassInfo* ci = wn->GetClassInfo();
   33:                     char* className = nsnull;
   33:                     if(ci)
   33:                         ci->GetClassDescription(&className);
   33:                     if(className)
   33:                     {
   33:                         JS_snprintf(name, sizeof(name), "XPCNativeWrapper (%s)",
   33:                                     className);
   33:                         PR_Free(className);
   33:                     }
   33:                     else
   33:                     {
   33:                         XPCNativeSet* set = wn->GetSet();
   33:                         XPCNativeInterface** array = set->GetInterfaceArray();
   33:                         PRUint16 count = set->GetInterfaceCount();
   33: 
   33:                         if(count > 0)
 1846:                             JS_snprintf(name, sizeof(name),
 1846:                                         "XPCNativeWrapper (%s)",
   33:                                         array[0]->GetNameString());
    1:                         else
    1:                             JS_snprintf(name, sizeof(name), "XPCNativeWrapper");
    1:                     }
   33:                 }
   33:             }
   33:             else
   33:             {
   33:                 JS_snprintf(name, sizeof(name), "XPCNativeWrapper");
   33:             }
   33:         }
   33:         else
    1:         {
    1:             XPCNativeScriptableInfo* si = nsnull;
    1:             if(IS_PROTO_CLASS(clazz))
    1:             {
    1:                 XPCWrappedNativeProto* p =
10858:                     (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
    1:                 si = p->GetScriptableInfo();
    1:             }
    1:             if(si)
   33:             {
 1846:                 JS_snprintf(name, sizeof(name), "JS Object (%s - %s)",
 1846:                             clazz->name, si->GetJSClass()->name);
   33:             }
   33:             else if(clazz == &js_ScriptClass)
   33:             {
10858:                 JSScript* script = (JSScript*) xpc_GetJSPrivate(obj);
   33:                 if(script->filename)
   33:                 {
   33:                     JS_snprintf(name, sizeof(name), "JS Object (Script - %s)",
   33:                                 script->filename);
    1:                 }
    1:                 else
    1:                 {
   33:                     JS_snprintf(name, sizeof(name), "JS Object (Script)");
    1:                 }
   33:             }
   33:             else if(clazz == &js_FunctionClass)
   33:             {
10858:                 JSFunction* fun = (JSFunction*) xpc_GetJSPrivate(obj);
12529:                 JSString* str = JS_GetFunctionId(fun);
12529:                 if(str)
   33:                 {
 7286:                     NS_ConvertUTF16toUTF8
12529:                         fname(JS_GetStringChars(str));
   33:                     JS_snprintf(name, sizeof(name), "JS Object (Function - %s)",
 7286:                                 fname.get());
   33:                 }
   33:                 else
   33:                 {
   33:                     JS_snprintf(name, sizeof(name), "JS Object (Function)");
   33:                 }
   33:             }
   33:             else
   33:             {
   33:                 JS_snprintf(name, sizeof(name), "JS Object (%s)", clazz->name);
   33:             }
   33:         }
 1846:     }
 1846:     else
 1846:     {
18520:         static const char trace_types[JSTRACE_LIMIT][7] = {
11407:             "Object",
11407:             "Double",
11407:             "String",
11407:             "Xml"
11407:         };
11407:         JS_snprintf(name, sizeof(name), "JS %s", trace_types[traceKind]);
11407:     }
11407: 
18520:     if(traceKind == JSTRACE_OBJECT) {
11407:         JSObject *global = static_cast<JSObject*>(p), *parent;
11407:         while((parent = JS_GetParent(cx, global)))
11407:             global = parent;
11407:         char fullname[100];
11407:         JS_snprintf(fullname, sizeof(fullname), "%s (global=%p)", name, global);
11407:         cb.DescribeNode(type, 0, sizeof(JSObject), fullname);
11407:     } else {
11407:         cb.DescribeNode(type, 0, sizeof(JSObject), name);
11407:     }
11407: 
 1846:     }
    1: #else
 7286:     type = JS_IsAboutToBeFinalized(cx, p) ? GCUnmarked : GCMarked;
 7286:     cb.DescribeNode(type, 0);
    1: #endif
 1846: 
 8146:     if(!ADD_TO_CC(traceKind))
 7230:         return NS_OK;
 7230: 
 7286: #ifndef DEBUG_CC
 7286:     // There's no need to trace objects that have already been marked by the JS
 7286:     // GC. Any JS objects hanging from them will already be marked. Only do this
 7286:     // if DEBUG_CC is not defined, else we do want to know about all JS objects
 7286:     // to get better graphs and explanations.
 7286:     if(type == GCMarked)
 7286:         return NS_OK;
 7286: #endif
 7286: 
 7286:     TraversalTracer trc(cb);
 1846: 
 1846:     JS_TRACER_INIT(&trc, cx, NoteJSChild);
 8005:     JS_TraceChildren(&trc, p, traceKind);
 1846: 
 8005:     if(traceKind != JSTRACE_OBJECT)
    1:         return NS_OK;
    1:     
 3233:     JSObject *obj = static_cast<JSObject*>(p);
 1846:     JSClass* clazz = OBJ_GET_CLASS(cx, obj);
 1846: 
 1846:     if(clazz == &XPC_WN_Tearoff_JSClass)
    1:     {
    1:         // A tearoff holds a strong reference to its native object
    1:         // (see XPCWrappedNative::FlatJSObjectFinalized). Its XPCWrappedNative
    1:         // will be held alive through the parent of the JSObject of the tearoff.
    1:         XPCWrappedNativeTearOff *to =
10858:             (XPCWrappedNativeTearOff*) xpc_GetJSPrivate(obj);
18993:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "xpc_GetJSPrivate(obj)->mNative");
    1:         cb.NoteXPCOMChild(to->GetNative());
    1:     }
 1846:     // XXX XPCNativeWrapper seems to be the only class that doesn't hold a
 1846:     //     strong reference to its nsISupports private. This test does seem
 1846:     //     fragile though, we should probably whitelist classes that do hold
 1846:     //     a strong reference, but that might not be possible.
    1:     else if(clazz->flags & JSCLASS_HAS_PRIVATE &&
 1846:             clazz->flags & JSCLASS_PRIVATE_IS_NSISUPPORTS &&
 1846:             !XPCNativeWrapper::IsNativeWrapperClass(clazz))
    1:     {
18993:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "xpc_GetJSPrivate(obj)");
10858:         cb.NoteXPCOMChild(static_cast<nsISupports*>(xpc_GetJSPrivate(obj)));
    1:     }
   33: 
    1: #ifndef XPCONNECT_STANDALONE
    1:     if(clazz->flags & JSCLASS_IS_GLOBAL)
    1:     {
    1:         nsISupports *principal = nsnull;
 7286:         mScopes.Get(obj, &principal);
22064:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "scope principal");
    1:         cb.NoteXPCOMChild(principal);
    1:     }
    1: #endif
    1: 
    1:     return NS_OK;
    1: }
    1: 
 7286: PRInt32
 7286: nsXPConnect::GetRequestDepth(JSContext* cx)
 7286: {
 7286:     PRInt32 requestDepth = cx->outstandingRequests;
 7286:     XPCCallContext* context = GetCycleCollectionContext();
 7286:     if(context && cx == context->GetJSContext())
 7286:         // Ignore the request from the XPCCallContext we created for cycle
 7286:         // collection.
 7286:         --requestDepth;
 7286:     return requestDepth;
 7286: }
 7286: 
 7286: class JSContextParticipant : public nsCycleCollectionParticipant
 7286: {
 7286: public:
10981:     NS_IMETHOD RootAndUnlinkJSObjects(void *n)
 7286:     {
 7286:         return NS_OK;
 7286:     }
 7286:     NS_IMETHOD Unlink(void *n)
 7286:     {
 7286:         // We must not unlink a JSContext because Root/Unroot don't ensure that
 7286:         // the pointer is still valid.
 7286:         return NS_OK;
 7286:     }
 7286:     NS_IMETHOD Unroot(void *n)
 7286:     {
 7286:         return NS_OK;
 7286:     }
 7286:     NS_IMETHODIMP Traverse(void *n, nsCycleCollectionTraversalCallback &cb)
 7286:     {
 7286:         JSContext *cx = static_cast<JSContext*>(n);
 7286: 
 7286:         // Add cx->requestDepth to the refcount, if there are outstanding
 7286:         // requests the context needs to be kept alive and adding unknown
 7286:         // edges will ensure that any cycles this context is in won't be
 7286:         // collected.
 7286:         PRInt32 refCount = nsXPConnect::GetXPConnect()->GetRequestDepth(cx) + 1;
 7286: 
 7286: #ifdef DEBUG_CC
 7286:         cb.DescribeNode(RefCounted, refCount, sizeof(JSContext),
 7286:                         "JSContext");
13202:         cb.NoteNextEdgeName("[global object]");
 7286: #else
 7286:         cb.DescribeNode(RefCounted, refCount);
 7286: #endif
 7286: 
20312:         void* globalObject = (cx->globalObject)
20312:                              ? cx->globalObject
20312:                              : nsXPConnect::GetRuntimeInstance()->
20312:                                  GetUnsetContextGlobal(cx);
 7286: 
 7286:         cb.NoteScriptChild(nsIProgrammingLanguage::JAVASCRIPT, globalObject);
 7286: 
 7286:         return NS_OK;
 7286:     }
 7286: };
 7286: 
 7286: static JSContextParticipant JSContext_cycleCollectorGlobal;
 7286: 
 7286: // static
 7286: nsCycleCollectionParticipant*
 7286: nsXPConnect::JSContextParticipant()
 7286: {
 7286:     return &JSContext_cycleCollectorGlobal;
 7286: }
 7286: 
 7286: NS_IMETHODIMP_(void)
 7286: nsXPConnect::NoteJSContext(JSContext *aJSContext,
 7286:                            nsCycleCollectionTraversalCallback &aCb)
 7286: {
 7286:     aCb.NoteNativeChild(aJSContext, &JSContext_cycleCollectorGlobal);
 7286: }
 7286: 
    1: 
    1: /***************************************************************************/
    1: /***************************************************************************/
    1: // nsIXPConnect interface methods...
    1: 
    1: inline nsresult UnexpectedFailure(nsresult rv)
    1: {
    1:     NS_ERROR("This is not supposed to fail!");
    1:     return rv;
    1: }
    1: 
 3162: class SaveFrame
 3162: {
 3162: public:
 3162:     SaveFrame(JSContext *cx)
 3162:         : mJSContext(cx) {
 3162:         mFrame = JS_SaveFrameChain(mJSContext);
 3162:     }
 3162: 
 3162:     ~SaveFrame() {
 3162:         JS_RestoreFrameChain(mJSContext, mFrame);
 3162:     }
 3162: 
 3162: private:
 3162:     JSContext *mJSContext;
 3162:     JSStackFrame *mFrame;
 3162: };
 3162: 
    1: /* void initClasses (in JSContextPtr aJSContext, in JSObjectPtr aGlobalJSObj); */
    1: NS_IMETHODIMP
    1: nsXPConnect::InitClasses(JSContext * aJSContext, JSObject * aGlobalJSObj)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aGlobalJSObj, "bad param");
    1: 
 3162:     SaveFrame sf(aJSContext);
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if(!xpc_InitJSxIDClassObjects())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if(!xpc_InitWrappedNativeJSOps())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope* scope =
    1:         XPCWrappedNativeScope::GetNewOrUsed(ccx, aGlobalJSObj);
    1: 
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     scope->RemoveWrappedNativeProtos();
    1: 
    1:     if(!nsXPCComponents::AttachNewComponentsObject(ccx, scope, aGlobalJSObj))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     // Initialize any properties IDispatch needs on the global object
    1:     XPCIDispatchExtension::Initialize(ccx, aGlobalJSObj);
    1: #endif
    1: 
    1:     if (!XPCNativeWrapper::AttachNewConstructorObject(ccx, aGlobalJSObj))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if (!XPC_SJOW_AttachNewConstructorObject(ccx, aGlobalJSObj))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
18907: static JSBool
    1: TempGlobalResolve(JSContext *aJSContext, JSObject *obj, jsval id)
    1: {
    1:     JSBool resolved;
    1:     return JS_ResolveStandardClass(aJSContext, obj, id, &resolved);
    1: }
    1: 
    1: static JSClass xpcTempGlobalClass = {
20823:     "xpcTempGlobalClass", JSCLASS_GLOBAL_FLAGS,
    1:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
    1:     JS_EnumerateStub, TempGlobalResolve, JS_ConvertStub,   JS_FinalizeStub,
    1:     JSCLASS_NO_OPTIONAL_MEMBERS
    1: };
    1: 
    1: /* nsIXPConnectJSObjectHolder initClassesWithNewWrappedGlobal (in JSContextPtr aJSContext, in nsISupports aCOMObj, in nsIIDRef aIID, in PRUint32 aFlags); */
    1: NS_IMETHODIMP
    1: nsXPConnect::InitClassesWithNewWrappedGlobal(JSContext * aJSContext,
    1:                                              nsISupports *aCOMObj,
    1:                                              const nsIID & aIID,
    1:                                              PRUint32 aFlags,
    1:                                              nsIXPConnectJSObjectHolder **_retval)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aCOMObj, "bad param");
    1:     NS_ASSERTION(_retval, "bad param");
    1: 
    1:     // XXX This is not pretty. We make a temporary global object and
    1:     // init it with all the Components object junk just so we have a
    1:     // parent with an xpc scope to use when wrapping the object that will
    1:     // become the 'real' global.
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1: 
 7987:     PRBool system = (aFlags & nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT) != 0;
 7987:     JSObject* tempGlobal = JS_NewSystemObject(aJSContext, &xpcTempGlobalClass,
 7987:                                               nsnull, nsnull, system);
    1: 
    1:     if(!tempGlobal ||
    1:        !JS_SetParent(aJSContext, tempGlobal, nsnull) ||
    1:        !JS_SetPrototype(aJSContext, tempGlobal, nsnull))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
22065:     jsval v;
    1:     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
    1:     {
    1:         // Scope for our auto-marker; it just needs to keep tempGlobal alive
    1:         // long enough for InitClasses and WrapNative to do their work
    1:         AUTO_MARK_JSVAL(ccx, OBJECT_TO_JSVAL(tempGlobal));
    1: 
    1:         if(NS_FAILED(InitClasses(aJSContext, tempGlobal)))
    1:             return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:         nsresult rv;
22065:         if(!XPCConvert::NativeInterface2JSObject(ccx, &v,
22065:                                                  getter_AddRefs(holder),
22071:                                                  aCOMObj, &aIID, tempGlobal,
22071:                                                  PR_FALSE, OBJ_IS_GLOBAL, &rv))
    1:             return UnexpectedFailure(rv);
    1: 
    1:         NS_ASSERTION(NS_SUCCEEDED(rv) && holder, "Didn't wrap properly");
    1:     }
    1: 
22065:     JSObject* globalJSObj = JSVAL_TO_OBJECT(v);
22065:     if(!globalJSObj)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if(aFlags & nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT)
    1:         NS_ASSERTION(JS_IsSystemObject(aJSContext, globalJSObj), "huh?!");
    1: 
    1:     // voodoo to fixup scoping and parenting...
    1: 
    1:     JS_SetParent(aJSContext, globalJSObj, nsnull);
    1: 
    1:     JSObject* oldGlobal = JS_GetGlobalObject(aJSContext);
    1:     if(!oldGlobal || oldGlobal == tempGlobal)
    1:         JS_SetGlobalObject(aJSContext, globalJSObj);
    1: 
    1:     if((aFlags & nsIXPConnect::INIT_JS_STANDARD_CLASSES) &&
    1:        !JS_InitStandardClasses(aJSContext, globalJSObj))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNative* wrapper =
 3233:         reinterpret_cast<XPCWrappedNative*>(holder.get());
    1:     XPCWrappedNativeScope* scope = wrapper->GetScope();
    1: 
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     NS_ASSERTION(scope->GetGlobalJSObject() == tempGlobal, "stealing scope!");
    1: 
    1:     scope->SetGlobal(ccx, globalJSObj);
    1: 
    1:     JSObject* protoJSObject = wrapper->HasProto() ?
    1:                                     wrapper->GetProto()->GetJSProtoObject() :
    1:                                     globalJSObj;
    1:     if(protoJSObject)
    1:     {
    1:         if(protoJSObject != globalJSObj)
    1:             JS_SetParent(aJSContext, protoJSObject, globalJSObj);
    1:         JS_SetPrototype(aJSContext, protoJSObject, scope->GetPrototypeJSObject());
    1:     }
    1: 
 3162:     SaveFrame sf(ccx);
    1:     if(!nsXPCComponents::AttachNewComponentsObject(ccx, scope, globalJSObj))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if (!XPCNativeWrapper::AttachNewConstructorObject(ccx, globalJSObj))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if (!XPC_SJOW_AttachNewConstructorObject(ccx, globalJSObj))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     NS_ADDREF(*_retval = holder);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIXPConnectJSObjectHolder wrapNative (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsISupports aCOMObj, in nsIIDRef aIID); */
    1: NS_IMETHODIMP
    1: nsXPConnect::WrapNative(JSContext * aJSContext,
    1:                         JSObject * aScope,
    1:                         nsISupports *aCOMObj,
    1:                         const nsIID & aIID,
22065:                         nsIXPConnectJSObjectHolder **aHolder)
22065: {
22065:     NS_ASSERTION(aHolder, "bad param");
22065: 
22065:     jsval v;
22071:     return WrapNativeToJSVal(aJSContext, aScope, aCOMObj, aIID, &v, aHolder);
22065: }
22065: 
22071: /* void wrapNativeToJSVal (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsISupports aCOMObj, in nsIIDRef aIID, out JSVal aVal, out nsIXPConnectJSObjectHolder aHolder); */
22065: NS_IMETHODIMP
22065: nsXPConnect::WrapNativeToJSVal(JSContext * aJSContext,
22065:                                JSObject * aScope,
22065:                                nsISupports *aCOMObj,
22071:                                const nsIID & aIID,
22065:                                jsval *aVal,
22065:                                nsIXPConnectJSObjectHolder **aHolder)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aScope, "bad param");
    1:     NS_ASSERTION(aCOMObj, "bad param");
    1: 
22065:     if(aHolder)
22065:         *aHolder = nsnull;
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     nsresult rv;
22071:     if(!XPCConvert::NativeInterface2JSObject(ccx, aVal, aHolder, aCOMObj, &aIID,
22071:                                              aScope, PR_FALSE,
    1:                                              OBJ_IS_NOT_GLOBAL, &rv))
    1:         return rv;
    1: 
    1: #ifdef DEBUG
22065:     NS_ASSERTION(!XPCNativeWrapper::IsNativeWrapper(JSVAL_TO_OBJECT(*aVal)),
    1:                  "Shouldn't be returning a native wrapper here");
    1: #endif
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: /* void wrapJS (in JSContextPtr aJSContext, in JSObjectPtr aJSObj, in nsIIDRef aIID, [iid_is (aIID), retval] out nsQIResult result); */
    1: NS_IMETHODIMP
    1: nsXPConnect::WrapJS(JSContext * aJSContext,
    1:                     JSObject * aJSObj,
    1:                     const nsIID & aIID,
    1:                     void * *result)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aJSObj, "bad param");
    1:     NS_ASSERTION(result, "bad param");
    1: 
    1:     *result = nsnull;
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     nsresult rv;
    1:     if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
 5491:                                              &aIID, nsnull, &rv))
    1:         return rv;
    1:     return NS_OK;
    1: }
    1: 
    1: /* void wrapJSAggregatedToNative (in nsISupports aOuter, in JSContextPtr aJSContext, in JSObjectPtr aJSObj, in nsIIDRef aIID, [iid_is (aIID), retval] out nsQIResult result); */
    1: NS_IMETHODIMP
    1: nsXPConnect::WrapJSAggregatedToNative(nsISupports *aOuter,
    1:                                       JSContext * aJSContext,
    1:                                       JSObject * aJSObj,
    1:                                       const nsIID & aIID,
    1:                                       void * *result)
    1: {
    1:     NS_ASSERTION(aOuter, "bad param");
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aJSObj, "bad param");
    1:     NS_ASSERTION(result, "bad param");
    1: 
    1:     *result = nsnull;
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     nsresult rv;
    1:     if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
 5491:                                              &aIID, aOuter, &rv))
    1:         return rv;
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIXPConnectWrappedNative getWrappedNativeOfJSObject (in JSContextPtr aJSContext, in JSObjectPtr aJSObj); */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetWrappedNativeOfJSObject(JSContext * aJSContext,
    1:                                         JSObject * aJSObj,
    1:                                         nsIXPConnectWrappedNative **_retval)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aJSObj, "bad param");
    1:     NS_ASSERTION(_retval, "bad param");
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     nsIXPConnectWrappedNative* wrapper =
    1:         XPCWrappedNative::GetWrappedNativeOfJSObject(aJSContext, aJSObj);
    1:     if(wrapper)
    1:     {
    1:         NS_ADDREF(wrapper);
    1:         *_retval = wrapper;
    1:         return NS_OK;
    1:     }
    1:     // else...
    1:     *_retval = nsnull;
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* nsIXPConnectWrappedNative getWrappedNativeOfNativeObject (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsISupports aCOMObj, in nsIIDRef aIID); */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetWrappedNativeOfNativeObject(JSContext * aJSContext,
    1:                                             JSObject * aScope,
    1:                                             nsISupports *aCOMObj,
    1:                                             const nsIID & aIID,
    1:                                             nsIXPConnectWrappedNative **_retval)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aScope, "bad param");
    1:     NS_ASSERTION(aCOMObj, "bad param");
    1:     NS_ASSERTION(_retval, "bad param");
    1: 
    1:     *_retval = nsnull;
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope* scope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     AutoMarkingNativeInterfacePtr iface(ccx);
    1:     iface = XPCNativeInterface::GetNewOrUsed(ccx, &aIID);
    1:     if(!iface)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     XPCWrappedNative* wrapper;
    1: 
    1:     nsresult rv = XPCWrappedNative::GetUsedOnly(ccx, aCOMObj, scope, iface,
    1:                                                 &wrapper);
    1:     if(NS_FAILED(rv))
    1:         return NS_ERROR_FAILURE;
 3233:     *_retval = static_cast<nsIXPConnectWrappedNative*>(wrapper);
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIXPConnectJSObjectHolder reparentWrappedNativeIfFound (in JSContextPtr aJSContext, in JSObjectPtr aScope, in JSObjectPtr aNewParent, in nsISupports aCOMObj); */
    1: NS_IMETHODIMP
    1: nsXPConnect::ReparentWrappedNativeIfFound(JSContext * aJSContext,
    1:                                           JSObject * aScope,
    1:                                           JSObject * aNewParent,
    1:                                           nsISupports *aCOMObj,
    1:                                           nsIXPConnectJSObjectHolder **_retval)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope* scope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope* scope2 =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aNewParent);
    1:     if(!scope2)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     return XPCWrappedNative::
    1:         ReparentWrapperIfFound(ccx, scope, scope2, aNewParent, aCOMObj,
    1:                                (XPCWrappedNative**) _retval);
    1: }
    1: 
18907: static JSDHashOperator
    1: MoveableWrapperFinder(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                       uint32 number, void *arg)
    1: {
    1:     // Every element counts.
 3233:     nsVoidArray *va = static_cast<nsVoidArray *>(arg);
    1:     va->AppendElement(((Native2WrappedNativeMap::Entry*)hdr)->value);
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: /* void reparentScopeAwareWrappers(in JSContextPtr aJSContext, in JSObjectPtr  aOldScope, in JSObjectPtr  aNewScope); */
    1: NS_IMETHODIMP
    1: nsXPConnect::ReparentScopeAwareWrappers(JSContext *aJSContext,
    1:                                         JSObject *aOldScope,
    1:                                         JSObject *aNewScope)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope *oldScope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aOldScope);
    1:     if(!oldScope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope *newScope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aNewScope);
    1:     if(!newScope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
 4187:     // First, look through the old scope and find all of the wrappers that
 4187:     // we're going to move.
 4187:     nsVoidArray wrappersToMove;
 4187: 
    1:     {   // scoped lock
20312:         XPCAutoLock lock(GetRuntime()->GetMapLock());
    1:         Native2WrappedNativeMap *map = oldScope->GetWrappedNativeMap();
 4187:         wrappersToMove.SizeTo(map->Count());
    1:         map->Enumerate(MoveableWrapperFinder, &wrappersToMove);
 4187:     }
    1: 
    1:     // Now that we have the wrappers, reparent them to the new scope.
    1:     for(PRInt32 i = 0, stop = wrappersToMove.Count(); i < stop; ++i)
    1:     {
    1:         // First, check to see if this wrapper really needs to be
    1:         // reparented.
    1: 
    1:         XPCWrappedNative *wrapper =
 3233:             static_cast<XPCWrappedNative *>(wrappersToMove[i]);
    1:         nsISupports *identity = wrapper->GetIdentityObject();
    1:         nsCOMPtr<nsIClassInfo> info(do_QueryInterface(identity));
    1: 
    1:         // ClassInfo is implemented as singleton objects. If the identity
    1:         // object here is the same object as returned by the QI, then it
    1:         // is the singleton classinfo, so we don't need to reparent it.
    1:         if(SameCOMIdentity(identity, info))
    1:             info = nsnull;
    1: 
    1:         if(!info)
    1:             continue;
    1: 
    1:         XPCNativeScriptableCreateInfo sciProto;
    1:         XPCNativeScriptableCreateInfo sciWrapper;
    1: 
    1:         nsresult rv =
    1:             XPCWrappedNative::GatherScriptableCreateInfo(identity,
    1:                                                          info.get(),
    1:                                                          &sciProto,
    1:                                                          &sciWrapper);
    1:         if(NS_FAILED(rv))
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         // If the wrapper doesn't want precreate, then we don't need to
    1:         // worry about reparenting it.
    1:         if(!sciWrapper.GetFlags().WantPreCreate())
    1:             continue;
    1: 
    1:         JSObject *newParent = aOldScope;
    1:         rv = sciWrapper.GetCallback()->PreCreate(identity, ccx, aOldScope,
    1:                                                  &newParent);
    1:         if(NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         if(newParent != aOldScope)
    1:         {
    1:             // The wrapper returned a new parent. If the new parent is in
    1:             // a different scope, then we need to reparent it, otherwise,
    1:             // the old scope is fine.
    1: 
    1:             XPCWrappedNativeScope *betterScope =
    1:                 XPCWrappedNativeScope::FindInJSObjectScope(ccx, newParent);
    1:             if(betterScope == oldScope)
    1:                 continue;
    1: 
    1:             NS_ASSERTION(betterScope == newScope, "Weird scope returned");
    1:         }
    1:         else
    1:         {
    1:             // The old scope still works for this wrapper.
    1:             continue;
    1:         }
    1: 
    1:         // Now, reparent the wrapper, since we know that it wants to be
    1:         // reparented.
    1: 
    1:         nsRefPtr<XPCWrappedNative> junk;
    1:         rv = XPCWrappedNative::ReparentWrapperIfFound(ccx, oldScope,
    1:                                                       newScope, newParent,
    1:                                                       wrapper->GetIdentityObject(),
    1:                                                       getter_AddRefs(junk));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* void setSecurityManagerForJSContext (in JSContextPtr aJSContext, in nsIXPCSecurityManager aManager, in PRUint16 flags); */
    1: NS_IMETHODIMP
    1: nsXPConnect::SetSecurityManagerForJSContext(JSContext * aJSContext,
    1:                                             nsIXPCSecurityManager *aManager,
    1:                                             PRUint16 flags)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCContext* xpcc = ccx.GetXPCContext();
    1: 
    1:     NS_IF_ADDREF(aManager);
    1:     nsIXPCSecurityManager* oldManager = xpcc->GetSecurityManager();
    1:     NS_IF_RELEASE(oldManager);
    1: 
    1:     xpcc->SetSecurityManager(aManager);
    1:     xpcc->SetSecurityManagerFlags(flags);
    1:     return NS_OK;
    1: }
    1: 
    1: /* void getSecurityManagerForJSContext (in JSContextPtr aJSContext, out nsIXPCSecurityManager aManager, out PRUint16 flags); */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetSecurityManagerForJSContext(JSContext * aJSContext,
    1:                                             nsIXPCSecurityManager **aManager,
    1:                                             PRUint16 *flags)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aManager, "bad param");
    1:     NS_ASSERTION(flags, "bad param");
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCContext* xpcc = ccx.GetXPCContext();
    1: 
    1:     nsIXPCSecurityManager* manager = xpcc->GetSecurityManager();
    1:     NS_IF_ADDREF(manager);
    1:     *aManager = manager;
    1:     *flags = xpcc->GetSecurityManagerFlags();
    1:     return NS_OK;
    1: }
    1: 
    1: /* void setDefaultSecurityManager (in nsIXPCSecurityManager aManager, in PRUint16 flags); */
    1: NS_IMETHODIMP
    1: nsXPConnect::SetDefaultSecurityManager(nsIXPCSecurityManager *aManager,
    1:                                        PRUint16 flags)
    1: {
    1:     NS_IF_ADDREF(aManager);
    1:     NS_IF_RELEASE(mDefaultSecurityManager);
    1:     mDefaultSecurityManager = aManager;
    1:     mDefaultSecurityManagerFlags = flags;
 8870: 
 8870:     nsCOMPtr<nsIScriptSecurityManager> ssm =
 8870:         do_QueryInterface(mDefaultSecurityManager);
 8870: 
 8870:     // Remember the result of the above QI for fast access to the
 8870:     // script securityt manager.
 8870:     gScriptSecurityManager = ssm;
 8870: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* void getDefaultSecurityManager (out nsIXPCSecurityManager aManager, out PRUint16 flags); */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetDefaultSecurityManager(nsIXPCSecurityManager **aManager,
    1:                                        PRUint16 *flags)
    1: {
    1:     NS_ASSERTION(aManager, "bad param");
    1:     NS_ASSERTION(flags, "bad param");
    1: 
    1:     NS_IF_ADDREF(mDefaultSecurityManager);
    1:     *aManager = mDefaultSecurityManager;
    1:     *flags = mDefaultSecurityManagerFlags;
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIStackFrame createStackFrameLocation (in PRUint32 aLanguage, in string aFilename, in string aFunctionName, in PRInt32 aLineNumber, in nsIStackFrame aCaller); */
    1: NS_IMETHODIMP
    1: nsXPConnect::CreateStackFrameLocation(PRUint32 aLanguage,
    1:                                       const char *aFilename,
    1:                                       const char *aFunctionName,
    1:                                       PRInt32 aLineNumber,
    1:                                       nsIStackFrame *aCaller,
    1:                                       nsIStackFrame **_retval)
    1: {
    1:     NS_ASSERTION(_retval, "bad param");
    1: 
    1:     return XPCJSStack::CreateStackFrameLocation(aLanguage,
    1:                                                 aFilename,
    1:                                                 aFunctionName,
    1:                                                 aLineNumber,
    1:                                                 aCaller,
    1:                                                 _retval);
    1: }
    1: 
    1: /* readonly attribute nsIStackFrame CurrentJSStack; */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetCurrentJSStack(nsIStackFrame * *aCurrentJSStack)
    1: {
    1:     NS_ASSERTION(aCurrentJSStack, "bad param");
    1:     *aCurrentJSStack = nsnull;
    1: 
    1:     JSContext* cx;
    1:     // is there a current context available?
20462:     if(NS_SUCCEEDED(Peek(&cx)) && cx)
    1:     {
    1:         nsCOMPtr<nsIStackFrame> stack;
    1:         XPCJSStack::CreateStack(cx, getter_AddRefs(stack));
    1:         if(stack)
    1:         {
    1:             // peel off native frames...
    1:             PRUint32 language;
    1:             nsCOMPtr<nsIStackFrame> caller;
    1:             while(stack &&
    1:                   NS_SUCCEEDED(stack->GetLanguage(&language)) &&
    1:                   language != nsIProgrammingLanguage::JAVASCRIPT &&
    1:                   NS_SUCCEEDED(stack->GetCaller(getter_AddRefs(caller))) &&
    1:                   caller)
    1:             {
    1:                 stack = caller;
    1:             }
    1:             NS_IF_ADDREF(*aCurrentJSStack = stack);
    1:         }
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute nsIXPCNativeCallContext CurrentNativeCallContext; */
    1: NS_IMETHODIMP
10286: nsXPConnect::GetCurrentNativeCallContext(nsAXPCNativeCallContext * *aCurrentNativeCallContext)
    1: {
    1:     NS_ASSERTION(aCurrentNativeCallContext, "bad param");
    1: 
10490:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
    1:     if(data)
    1:     {
10286:         *aCurrentNativeCallContext = data->GetCallContext();
    1:         return NS_OK;
    1:     }
    1:     //else...
    1:     *aCurrentNativeCallContext = nsnull;
    1:     return UnexpectedFailure(NS_ERROR_FAILURE);
    1: }
    1: 
    1: /* attribute nsIException PendingException; */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetPendingException(nsIException * *aPendingException)
    1: {
    1:     NS_ASSERTION(aPendingException, "bad param");
    1: 
10490:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
    1:     if(!data)
    1:     {
    1:         *aPendingException = nsnull;
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1:     }
    1: 
    1:     return data->GetException(aPendingException);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXPConnect::SetPendingException(nsIException * aPendingException)
    1: {
10490:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
    1:     if(!data)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     data->SetException(aPendingException);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXPConnect::SyncJSContexts(void)
    1: {
20312:     // Do-nothing compatibility function
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIXPCFunctionThisTranslator setFunctionThisTranslator (in nsIIDRef aIID, in nsIXPCFunctionThisTranslator aTranslator); */
    1: NS_IMETHODIMP
    1: nsXPConnect::SetFunctionThisTranslator(const nsIID & aIID,
    1:                                        nsIXPCFunctionThisTranslator *aTranslator,
    1:                                        nsIXPCFunctionThisTranslator **_retval)
    1: {
20312:     XPCJSRuntime* rt = GetRuntime();
    1:     nsIXPCFunctionThisTranslator* old;
    1:     IID2ThisTranslatorMap* map = rt->GetThisTranslatorMap();
    1: 
    1:     {
    1:         XPCAutoLock lock(rt->GetMapLock()); // scoped lock
    1:         if(_retval)
    1:         {
    1:             old = map->Find(aIID);
    1:             NS_IF_ADDREF(old);
    1:             *_retval = old;
    1:         }
    1:         map->Add(aIID, aTranslator);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIXPCFunctionThisTranslator getFunctionThisTranslator (in nsIIDRef aIID); */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetFunctionThisTranslator(const nsIID & aIID,
    1:                                        nsIXPCFunctionThisTranslator **_retval)
    1: {
20312:     XPCJSRuntime* rt = GetRuntime();
    1:     nsIXPCFunctionThisTranslator* old;
    1:     IID2ThisTranslatorMap* map = rt->GetThisTranslatorMap();
    1: 
    1:     {
    1:         XPCAutoLock lock(rt->GetMapLock()); // scoped lock
    1:         old = map->Find(aIID);
    1:         NS_IF_ADDREF(old);
    1:         *_retval = old;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: /* void setSafeJSContextForCurrentThread (in JSContextPtr cx); */
    1: NS_IMETHODIMP 
    1: nsXPConnect::SetSafeJSContextForCurrentThread(JSContext * cx)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1:     return ccx.GetThreadData()->GetJSContextStack()->SetSafeJSContext(cx);
    1: }
    1: 
    1: /* void clearAllWrappedNativeSecurityPolicies (); */
    1: NS_IMETHODIMP
    1: nsXPConnect::ClearAllWrappedNativeSecurityPolicies()
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     return XPCWrappedNativeScope::ClearAllWrappedNativeSecurityPolicies(ccx);
    1: }
    1: 
    1: /* void restoreWrappedNativePrototype (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsIClassInfo aClassInfo, in nsIXPConnectJSObjectHolder aPrototype); */
    1: NS_IMETHODIMP 
    1: nsXPConnect::RestoreWrappedNativePrototype(JSContext * aJSContext, 
    1:                                            JSObject * aScope, 
    1:                                            nsIClassInfo * aClassInfo, 
    1:                                            nsIXPConnectJSObjectHolder * aPrototype)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if(!aClassInfo || !aPrototype)
    1:         return UnexpectedFailure(NS_ERROR_INVALID_ARG);
    1: 
    1:     JSObject *protoJSObject;
    1:     nsresult rv = aPrototype->GetJSObject(&protoJSObject);
    1:     if(NS_FAILED(rv))
    1:         return UnexpectedFailure(rv);
    1: 
10858:     if(!IS_PROTO_CLASS(STOBJ_GET_CLASS(protoJSObject)))
    1:         return UnexpectedFailure(NS_ERROR_INVALID_ARG);
    1: 
    1:     XPCWrappedNativeScope* scope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeProto *proto =
10858:         (XPCWrappedNativeProto*)xpc_GetJSPrivate(protoJSObject);
    1:     if(!proto)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if(scope != proto->GetScope())
    1:     {
    1:         NS_ERROR("Attempt to reset prototype to a prototype from a"
    1:                  "different scope!");
    1: 
    1:         return UnexpectedFailure(NS_ERROR_INVALID_ARG);
    1:     }
    1: 
    1:     XPCNativeScriptableInfo *si = proto->GetScriptableInfo();
    1: 
    1:     if(si && si->GetFlags().DontSharePrototype())
    1:         return UnexpectedFailure(NS_ERROR_INVALID_ARG);
    1: 
    1:     ClassInfo2WrappedNativeProtoMap* map = scope->GetWrappedNativeProtoMap();
20312:     XPCLock* lock = GetRuntime()->GetMapLock();
    1: 
    1:     {   // scoped lock
    1:         XPCAutoLock al(lock);
    1: 
    1:         XPCWrappedNativeProtoMap* detachedMap =
    1:             GetRuntime()->GetDetachedWrappedNativeProtoMap();
    1: 
    1:         // If we're replacing an old proto, make sure to put it on the
    1:         // map of detached wrapped native protos so that the old proto
    1:         // gets properly cleaned up, especially during shutdown.
    1:         XPCWrappedNativeProto *oldProto = map->Find(aClassInfo);
    1:         if(oldProto)
    1:         {
    1:             detachedMap->Add(oldProto);
    1: 
    1:             // ClassInfo2WrappedNativeProtoMap doesn't ever replace
    1:             // entries in the map, so now since we know there's an
    1:             // entry for aClassInfo in the map we have to remove it to
    1:             // be able to add the new one.
    1:             map->Remove(aClassInfo);
    1: 
    1:             // This code should do the right thing even if we're
    1:             // restoring the current proto, but warn in that case
    1:             // since doing that is pointless.
    1:             NS_ASSERTION(proto != oldProto,
    1:                          "Restoring current prototype, fix caller!");
    1:         }
    1: 
    1:         map->Add(aClassInfo, proto);
    1: 
    1:         // Remove the prototype from the map of detached wrapped
    1:         // native prototypes now that the prototype is part of a scope
    1:         // again.
    1:         detachedMap->Remove(proto);
    1:     }
    1: 
    1:     // The global in this scope didn't change, but a prototype did
    1:     // (most likely the global object's prototype), which means the
    1:     // scope needs to get a chance to update its cached
    1:     // Object.prototype pointers etc.
    1:     scope->SetGlobal(ccx, aScope);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXPConnect::CreateSandbox(JSContext *cx, nsIPrincipal *principal,
    1:                            nsIXPConnectJSObjectHolder **_retval)
    1: {
    1: #ifdef XPCONNECT_STANDALONE
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: #else /* XPCONNECT_STANDALONE */
    1:     XPCCallContext ccx(NATIVE_CALLER, cx);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     *_retval = nsnull;
    1: 
    1:     jsval rval = JSVAL_VOID;
    1:     AUTO_MARK_JSVAL(ccx, &rval);
    1: 
    1:     nsresult rv = xpc_CreateSandboxObject(cx, &rval, principal);
    1:     NS_ASSERTION(NS_FAILED(rv) || !JSVAL_IS_PRIMITIVE(rval),
    1:                  "Bad return value from xpc_CreateSandboxObject()!");
    1: 
    1:     if (NS_SUCCEEDED(rv) && !JSVAL_IS_PRIMITIVE(rval)) {
 2072:         *_retval = XPCJSObjectHolder::newHolder(ccx, JSVAL_TO_OBJECT(rval));
    1:         NS_ENSURE_TRUE(*_retval, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:         NS_ADDREF(*_retval);
    1:     }
    1: 
    1:     return rv;
    1: #endif /* XPCONNECT_STANDALONE */
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXPConnect::EvalInSandboxObject(const nsAString& source, JSContext *cx,
    1:                                  nsIXPConnectJSObjectHolder *sandbox,
 3573:                                  PRBool returnStringOnly, jsval *rval)
    1: {
    1: #ifdef XPCONNECT_STANDALONE
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: #else /* XPCONNECT_STANDALONE */
    1:     if (!sandbox)
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     JSObject *obj;
    1:     nsresult rv = sandbox->GetJSObject(&obj);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     return xpc_EvalInSandbox(cx, obj, source,
 3573:                              NS_ConvertUTF16toUTF8(source).get(), 1,
 3573:                              returnStringOnly, rval);
    1: #endif /* XPCONNECT_STANDALONE */
    1: }
    1: 
 8990: /* void GetXPCWrappedNativeJSClassInfo(out JSClassConstPtr clazz, out JSObjectOpsConstPtr ops1, out JSObjectOpsConstPtr ops2); */
 8990: NS_IMETHODIMP
 8990: nsXPConnect::GetXPCWrappedNativeJSClassInfo(const JSClass **clazz,
 8990:                                             JSGetObjectOps *ops1,
 8990:                                             JSGetObjectOps *ops2)
 8990: {
 8990:     // Expose the JSClass and JSGetObjectOps pointers used by
 8990:     // IS_WRAPPER_CLASS(). If that macro ever changes, this function
 8990:     // needs to stay in sync.
 8990: 
 8990:     *clazz = &XPC_WN_NoHelper_JSClass.base;
 8990:     *ops1 = XPC_WN_GetObjectOpsNoCall;
 8990:     *ops2 = XPC_WN_GetObjectOpsWithCall;
 8990: 
 8990:     return NS_OK;
 8990: }
 8990: 
    1: /* nsIXPConnectJSObjectHolder getWrappedNativePrototype (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsIClassInfo aClassInfo); */
    1: NS_IMETHODIMP 
    1: nsXPConnect::GetWrappedNativePrototype(JSContext * aJSContext, 
    1:                                        JSObject * aScope, 
    1:                                        nsIClassInfo *aClassInfo, 
    1:                                        nsIXPConnectJSObjectHolder **_retval)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope* scope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCNativeScriptableCreateInfo sciProto;
    1:     XPCWrappedNative::GatherProtoScriptableCreateInfo(aClassInfo, &sciProto);
    1: 
    1:     AutoMarkingWrappedNativeProtoPtr proto(ccx);
    1:     proto = XPCWrappedNativeProto::GetNewOrUsed(ccx, scope, aClassInfo, 
    1:                                                 &sciProto, JS_FALSE,
    1:                                                 OBJ_IS_NOT_GLOBAL);
    1:     if(!proto)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     nsIXPConnectJSObjectHolder* holder;
    1:     *_retval = holder = XPCJSObjectHolder::newHolder(ccx, 
    1:                                                      proto->GetJSProtoObject());
    1:     if(!holder)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     NS_ADDREF(holder);
    1:     return NS_OK;
    1: }
    1: 
 4042: /* [noscript] JSVal GetCrossOriginWrapperForValue(in JSContextPtr aJSContext, in JSVal aCurrentVal); */
 4042: NS_IMETHODIMP
 9848: nsXPConnect::GetXOWForObject(JSContext * aJSContext,
 4042:                              JSObject * aParent,
 4042:                              JSObject * aWrappedObj,
 4042:                              jsval * rval)
 4042: {
 4042:     *rval = OBJECT_TO_JSVAL(aWrappedObj);
 4042:     return XPC_XOW_WrapObject(aJSContext, aParent, rval)
 4042:            ? NS_OK : NS_ERROR_FAILURE;
 4042: }
 4042: 
 9848: static inline PRBool
 9848: PerformOp(JSContext *cx, PRUint32 aWay, JSObject *obj)
 9848: {
 9848:     NS_ASSERTION(aWay == nsIXPConnect::XPC_XOW_CLEARSCOPE,
 9848:                  "Nothing else is implemented yet");
 9848: 
 9848:     JS_ClearScope(cx, obj);
 9848:     return PR_TRUE;
 9848: }
 9848: 
 9848: /* [noscript] void updateXOWs (in JSContextPtr aJSContext,
 9848:  *                             in nsIXPConnectJSObjectHolder aObject,
 9848:  *                             in PRUint32 aWay); */
 9848: NS_IMETHODIMP
 9848: nsXPConnect::UpdateXOWs(JSContext* aJSContext,
 9848:                         nsIXPConnectWrappedNative* aObject,
 9848:                         PRUint32 aWay)
 9848: {
 9848:     typedef WrappedNative2WrapperMap::Link Link;
 9848:     XPCWrappedNative* wn = static_cast<XPCWrappedNative *>(aObject);
 9848:     XPCWrappedNativeScope* scope = wn->GetScope();
 9848:     WrappedNative2WrapperMap* map = scope->GetWrapperMap();
 9848:     Link* list;
 9848: 
 9848:     {
20312:         XPCAutoLock al(GetRuntime()->GetMapLock());
 9848: 
 9848:         list = map->FindLink(wn->GetFlatJSObject());
 9848:     }
 9848: 
 9848:     if(!list)
 9848:         return NS_OK; // No wrappers to update.
 9848: 
 9848:     AutoJSRequestWithNoCallContext req(aJSContext);
 9848: 
 9848:     Link* cur = list;
 9848:     if(cur->obj && !PerformOp(aJSContext, aWay, cur->obj))
 9848:         return NS_ERROR_FAILURE;
 9848: 
 9848:     for(cur = (Link *)PR_NEXT_LINK(list); cur != list;
 9848:         cur = (Link *)PR_NEXT_LINK(cur))
 9848:     {
 9848:         if(!PerformOp(aJSContext, aWay, cur->obj))
 9848:             return NS_ERROR_FAILURE;
 9848:     }
 9848: 
 9848:     return NS_OK;
 9848: }
 9848: 
    1: /* void releaseJSContext (in JSContextPtr aJSContext, in PRBool noGC); */
    1: NS_IMETHODIMP 
    1: nsXPConnect::ReleaseJSContext(JSContext * aJSContext, PRBool noGC)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
10490:     XPCPerThreadData* tls = XPCPerThreadData::GetData(aJSContext);
    1:     if(tls)
    1:     {
    1:         XPCCallContext* ccx = nsnull;
    1:         for(XPCCallContext* cur = tls->GetCallContext(); 
    1:             cur; 
    1:             cur = cur->GetPrevCallContext())
    1:         {
    1:             if(cur->GetJSContext() == aJSContext)
    1:             {
    1:                 ccx = cur;
    1:                 // Keep looping to find the deepest matching call context.
    1:             }
    1:         }
    1:     
    1:         if(ccx)
    1:         {
    1: #ifdef DEBUG_xpc_hacker
18543:             printf("!xpc - deferring destruction of JSContext @ %p\n", 
18543:                    (void *)aJSContext);
    1: #endif
    1:             ccx->SetDestroyJSContextInDestructor(JS_TRUE);
    1:             JS_ClearNewbornRoots(aJSContext);
    1:             return NS_OK;
    1:         }
    1:         // else continue on and synchronously destroy the JSContext ...
    1: 
    1:         NS_ASSERTION(!tls->GetJSContextStack() || 
    1:                      !tls->GetJSContextStack()->
    1:                         DEBUG_StackHasJSContext(aJSContext),
    1:                      "JSContext still in threadjscontextstack!");
    1:     }
    1:     
    1:     if(noGC)
    1:         JS_DestroyContextNoGC(aJSContext);
    1:     else
    1:         JS_DestroyContext(aJSContext);
    1:     return NS_OK;
    1: }
    1: 
    1: /* void debugDump (in short depth); */
    1: NS_IMETHODIMP
    1: nsXPConnect::DebugDump(PRInt16 depth)
    1: {
    1: #ifdef DEBUG
    1:     depth-- ;
    1:     XPC_LOG_ALWAYS(("nsXPConnect @ %x with mRefCnt = %d", this, mRefCnt.get()));
    1:     XPC_LOG_INDENT();
    1:         XPC_LOG_ALWAYS(("gSelf @ %x", gSelf));
    1:         XPC_LOG_ALWAYS(("gOnceAliveNowDead is %d", (int)gOnceAliveNowDead));
    1:         XPC_LOG_ALWAYS(("mDefaultSecurityManager @ %x", mDefaultSecurityManager));
    1:         XPC_LOG_ALWAYS(("mDefaultSecurityManagerFlags of %x", mDefaultSecurityManagerFlags));
    1:         XPC_LOG_ALWAYS(("mInterfaceInfoManager @ %x", mInterfaceInfoManager.get()));
    1:         if(mRuntime)
    1:         {
    1:             if(depth)
    1:                 mRuntime->DebugDump(depth);
    1:             else
    1:                 XPC_LOG_ALWAYS(("XPCJSRuntime @ %x", mRuntime));
    1:         }
    1:         else
    1:             XPC_LOG_ALWAYS(("mRuntime is null"));
    1:         XPCWrappedNativeScope::DebugDumpAllScopes(depth);
    1:     XPC_LOG_OUTDENT();
    1: #endif
    1:     return NS_OK;
    1: }
    1: 
    1: /* void debugDumpObject (in nsISupports aCOMObj, in short depth); */
    1: NS_IMETHODIMP
    1: nsXPConnect::DebugDumpObject(nsISupports *p, PRInt16 depth)
    1: {
    1: #ifdef DEBUG
    1:     if(!depth)
    1:         return NS_OK;
    1:     if(!p)
    1:     {
    1:         XPC_LOG_ALWAYS(("*** Cound not dump object with NULL address"));
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsIXPConnect* xpc;
    1:     nsIXPCWrappedJSClass* wjsc;
    1:     nsIXPConnectWrappedNative* wn;
    1:     nsIXPConnectWrappedJS* wjs;
    1: 
    1:     if(NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPConnect),
    1:                         (void**)&xpc)))
    1:     {
    1:         XPC_LOG_ALWAYS(("Dumping a nsIXPConnect..."));
    1:         xpc->DebugDump(depth);
    1:         NS_RELEASE(xpc);
    1:     }
    1:     else if(NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPCWrappedJSClass),
    1:                         (void**)&wjsc)))
    1:     {
    1:         XPC_LOG_ALWAYS(("Dumping a nsIXPCWrappedJSClass..."));
    1:         wjsc->DebugDump(depth);
    1:         NS_RELEASE(wjsc);
    1:     }
    1:     else if(NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPConnectWrappedNative),
    1:                         (void**)&wn)))
    1:     {
    1:         XPC_LOG_ALWAYS(("Dumping a nsIXPConnectWrappedNative..."));
    1:         wn->DebugDump(depth);
    1:         NS_RELEASE(wn);
    1:     }
    1:     else if(NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPConnectWrappedJS),
    1:                         (void**)&wjs)))
    1:     {
    1:         XPC_LOG_ALWAYS(("Dumping a nsIXPConnectWrappedJS..."));
    1:         wjs->DebugDump(depth);
    1:         NS_RELEASE(wjs);
    1:     }
    1:     else
    1:         XPC_LOG_ALWAYS(("*** Could not dump the nsISupports @ %x", p));
    1: #endif
    1:     return NS_OK;
    1: }
    1: 
 5905: /* void debugDumpJSStack (in PRBool showArgs, in PRBool showLocals, in PRBool showThisProps); */
    1: NS_IMETHODIMP
 5905: nsXPConnect::DebugDumpJSStack(PRBool showArgs,
    1:                               PRBool showLocals,
    1:                               PRBool showThisProps)
    1: {
    1:     JSContext* cx;
20462:     if(NS_FAILED(Peek(&cx)))
 5905:         printf("failed to peek into nsIThreadJSContextStack service!\n");
    1:     else if(!cx)
 5905:         printf("there is no JSContext on the nsIThreadJSContextStack!\n");
    1:     else
 5905:         xpc_DumpJSStack(cx, showArgs, showLocals, showThisProps);
18403: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* void debugDumpEvalInJSStackFrame (in PRUint32 aFrameNumber, in string aSourceText); */
    1: NS_IMETHODIMP
    1: nsXPConnect::DebugDumpEvalInJSStackFrame(PRUint32 aFrameNumber, const char *aSourceText)
    1: {
    1:     JSContext* cx;
20462:     if(NS_FAILED(Peek(&cx)))
    1:         printf("failed to peek into nsIThreadJSContextStack service!\n");
    1:     else if(!cx)
    1:         printf("there is no JSContext on the nsIThreadJSContextStack!\n");
    1:     else
    1:         xpc_DumpEvalInJSStackFrame(cx, aFrameNumber, aSourceText);
18403: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* JSVal variantToJS (in JSContextPtr ctx, in JSObjectPtr scope, in nsIVariant value); */
    1: NS_IMETHODIMP 
    1: nsXPConnect::VariantToJS(JSContext* ctx, JSObject* scope, nsIVariant* value, jsval* _retval)
    1: {
    1:     NS_PRECONDITION(ctx, "bad param");
    1:     NS_PRECONDITION(scope, "bad param");
    1:     NS_PRECONDITION(value, "bad param");
    1:     NS_PRECONDITION(_retval, "bad param");
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, ctx);
    1:     if(!ccx.IsValid())
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsresult rv = NS_OK;
    1:     if(!XPCVariant::VariantDataToJS(ccx, value, scope, &rv, _retval))
    1:     {
    1:         if(NS_FAILED(rv)) 
    1:             return rv;
    1: 
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIVariant JSToVariant (in JSContextPtr ctx, in JSVal value); */
    1: NS_IMETHODIMP 
    1: nsXPConnect::JSToVariant(JSContext* ctx, jsval value, nsIVariant** _retval)
    1: {
    1:     NS_PRECONDITION(ctx, "bad param");
    1:     NS_PRECONDITION(value, "bad param");
    1:     NS_PRECONDITION(_retval, "bad param");
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, ctx);
    1:     if(!ccx.IsValid())
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     *_retval = XPCVariant::newVariant(ccx, value);
    1:     if(!(*_retval)) 
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
 9531: /* void flagSystemFilenamePrefix (in string filenamePrefix,
 9531:  *                                in PRBool aWantNativeWrappers); */
    1: NS_IMETHODIMP 
 9531: nsXPConnect::FlagSystemFilenamePrefix(const char *aFilenamePrefix,
 9531:                                       PRBool aWantNativeWrappers)
    1: {
    1:     NS_PRECONDITION(aFilenamePrefix, "bad param");
    1: 
20312:     JSRuntime* rt = GetRuntime()->GetJSRuntime();;
 9531:     uint32 flags = JSFILENAME_SYSTEM;
 9531:     if(aWantNativeWrappers)
 9531:         flags |= JSFILENAME_PROTECTED;
 9531:     if(!JS_FlagScriptFilenamePrefix(rt, aFilenamePrefix, flags))
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     return NS_OK;
    1: }
    1: 
 3310: NS_IMETHODIMP
 3310: nsXPConnect::OnProcessNextEvent(nsIThreadInternal *aThread, PRBool aMayWait,
 3310:                                 PRUint32 aRecursionDepth)
 3310: {
 3310:     // Push a null JSContext so that we don't see any script during
 3310:     // event processing.
20462:     return Push(nsnull);
 3310: }
 3310: 
 3310: NS_IMETHODIMP
 3310: nsXPConnect::AfterProcessNextEvent(nsIThreadInternal *aThread,
 3310:                                    PRUint32 aRecursionDepth)
 3310: {
20462:     return Pop(nsnull);
 3310: }
 3310: 
 3310: NS_IMETHODIMP
 3310: nsXPConnect::OnDispatchedEvent(nsIThreadInternal* aThread)
 3310: {
 3310:     NS_NOTREACHED("Why tell us?");
 3310:     return NS_ERROR_UNEXPECTED;
 3310: }
 3310: 
 7230: NS_IMETHODIMP
 7230: nsXPConnect::AddJSHolder(void* aHolder, nsScriptObjectTracer* aTracer)
 7230: {
 7230:     return mRuntime->AddJSHolder(aHolder, aTracer);
 7230: }
 7230: 
 7230: NS_IMETHODIMP
 7230: nsXPConnect::RemoveJSHolder(void* aHolder)
 7230: {
 7230:     return mRuntime->RemoveJSHolder(aHolder);
 7230: }
 7230: 
14170: NS_IMETHODIMP
14170: nsXPConnect::SetReportAllJSExceptions(PRBool newval)
14170: {
14170:     // Ignore if the environment variable was set.
14170:     if (gReportAllJSExceptions != 1)
14170:         gReportAllJSExceptions = newval ? 2 : 0;
14170: 
14170:     return NS_OK;
14170: }
14170: 
18543: /* [noscript, notxpcom] PRBool defineDOMQuickStubs (in JSContextPtr cx, in JSObjectPtr proto, in PRUint32 flags, in PRUint32 interfaceCount, [array, size_is (interfaceCount)] in nsIIDPtr interfaceArray); */
18543: NS_IMETHODIMP_(PRBool)
18543: nsXPConnect::DefineDOMQuickStubs(JSContext * cx,
18543:                                  JSObject * proto,
18543:                                  PRUint32 flags,
18543:                                  PRUint32 interfaceCount,
18543:                                  const nsIID * *interfaceArray)
18543: {
18543:     return DOM_DefineQuickStubs(cx, proto, flags,
18543:                                 interfaceCount, interfaceArray);
18543: }
18543: 
20312: /* attribute JSRuntime runtime; */
20312: NS_IMETHODIMP
20312: nsXPConnect::GetRuntime(JSRuntime **runtime)
20312: {
20312:     if(!runtime)
20312:         return NS_ERROR_NULL_POINTER;
20312: 
20312:     *runtime = GetRuntime()->GetJSRuntime();
20312:     return NS_OK;
20312: }
20312: 
20312: /* attribute nsIXPCScriptable backstagePass; */
20312: NS_IMETHODIMP
20312: nsXPConnect::GetBackstagePass(nsIXPCScriptable **bsp)
20312: {
20312:     if(!mBackstagePass) {
20312: #ifndef XPCONNECT_STANDALONE
20312:         nsCOMPtr<nsIPrincipal> sysprin;
20312:         nsCOMPtr<nsIScriptSecurityManager> secman =
20312:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
20312:         if(!secman)
20312:             return NS_ERROR_NOT_AVAILABLE;
20312:         if(NS_FAILED(secman->GetSystemPrincipal(getter_AddRefs(sysprin))))
20312:             return NS_ERROR_NOT_AVAILABLE;
20312: 
20312:         mBackstagePass = new BackstagePass(sysprin);
20312: #else
20312:         mBackstagePass = new BackstagePass();
20312: #endif
20312:         if(!mBackstagePass)
20312:             return NS_ERROR_OUT_OF_MEMORY;
20312:     }
20312:     NS_ADDREF(*bsp = mBackstagePass);
20312:     return NS_OK;
20312: }
20312: 
20462: //  nsIJSContextStack and nsIThreadJSContextStack implementations
20462: 
20462: /* readonly attribute PRInt32 Count; */
20462: NS_IMETHODIMP
20462: nsXPConnect::GetCount(PRInt32 *aCount)
20462: {
20462:     if(!aCount)
20462:         return NS_ERROR_NULL_POINTER;
20462: 
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
20462: 
20462:     if(!data)
20462:     {
20462:         *aCount = 0;
20462:         return NS_ERROR_FAILURE;
20462:     }
20462: 
20462:     return data->GetJSContextStack()->GetCount(aCount);
20462: }
20462: 
20462: /* JSContext Peek (); */
20462: NS_IMETHODIMP
20462: nsXPConnect::Peek(JSContext * *_retval)
20462: {
20462:     if(!_retval)
20462:         return NS_ERROR_NULL_POINTER;
20462: 
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
20462: 
20462:     if(!data)
20462:     {
20462:         *_retval = nsnull;
20462:         return NS_ERROR_FAILURE;
20462:     }
20462: 
20462:     return data->GetJSContextStack()->Peek(_retval);
20462: }
20462: 
20462: /* JSContext Pop (); */
20462: NS_IMETHODIMP
20462: nsXPConnect::Pop(JSContext * *_retval)
20462: {
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
20462: 
20462:     if(!data)
20462:     {
20462:         if(_retval)
20462:             *_retval = nsnull;
20462:         return NS_ERROR_FAILURE;
20462:     }
20462: 
20462:     return data->GetJSContextStack()->Pop(_retval);
20462: }
20462: 
20462: /* void Push (in JSContext cx); */
20462: NS_IMETHODIMP
20462: nsXPConnect::Push(JSContext * cx)
20462: {
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(cx);
20462: 
20462:     if(!data)
20462:         return NS_ERROR_FAILURE;
20462: 
20462:     return data->GetJSContextStack()->Push(cx);
20462: }
20462: 
20462: /* attribute JSContext SafeJSContext; */
20462: NS_IMETHODIMP
20462: nsXPConnect::GetSafeJSContext(JSContext * *aSafeJSContext)
20462: {
20462:     NS_ASSERTION(aSafeJSContext, "loser!");
20462: 
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
20462: 
20462:     if(!data)
20462:     {
20462:         *aSafeJSContext = nsnull;
20462:         return NS_ERROR_FAILURE;
20462:     }
20462: 
20462:     return data->GetJSContextStack()->GetSafeJSContext(aSafeJSContext);
20462: }
20462: 
20462: /* attribute JSContext SafeJSContext; */
20462: NS_IMETHODIMP
20462: nsXPConnect::SetSafeJSContext(JSContext * aSafeJSContext)
20462: {
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(aSafeJSContext);
20462: 
20462:     if(!data)
20462:         return NS_ERROR_FAILURE;
20462: 
20462:     return data->GetJSContextStack()->SetSafeJSContext(aSafeJSContext);
20462: }
20462: 
    1: /* These are here to be callable from a debugger */
    1: JS_BEGIN_EXTERN_C
18403: JS_EXPORT_API(void) DumpJSStack()
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
    1:     if(NS_SUCCEEDED(rv) && xpc)
 5905:         xpc->DebugDumpJSStack(PR_TRUE, PR_TRUE, PR_FALSE);
    1:     else
    1:         printf("failed to get XPConnect service!\n");
    1: }
    1: 
18403: JS_EXPORT_API(void) DumpJSEval(PRUint32 frameno, const char* text)
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
    1:     if(NS_SUCCEEDED(rv) && xpc)
    1:         xpc->DebugDumpEvalInJSStackFrame(frameno, text);
    1:     else
    1:         printf("failed to get XPConnect service!\n");
    1: }
    1: 
18403: JS_EXPORT_API(void) DumpJSObject(JSObject* obj)
    1: {
    1:     xpc_DumpJSObject(obj);
    1: }
    1: 
18403: JS_EXPORT_API(void) DumpJSValue(jsval val)
    1: {
    1:     printf("Dumping 0x%lx. Value tag is %lu.\n", val, JSVAL_TAG(val));
    1:     if(JSVAL_IS_NULL(val)) {
    1:         printf("Value is null\n");
    1:     }
    1:     else if(JSVAL_IS_OBJECT(val)) {
    1:         printf("Value is an object\n");
    1:         JSObject* obj = JSVAL_TO_OBJECT(val);
    1:         DumpJSObject(obj);
    1:     }
    1:     else if(JSVAL_IS_NUMBER(val)) {
    1:         printf("Value is a number: ");
    1:         if(JSVAL_IS_INT(val))
    1:           printf("Integer %i\n", JSVAL_TO_INT(val));
    1:         else if(JSVAL_IS_DOUBLE(val))
    1:           printf("Floating-point value %f\n", *JSVAL_TO_DOUBLE(val));
    1:     }
    1:     else if(JSVAL_IS_STRING(val)) {
    1:         printf("Value is a string: ");
    1:         JSString* string = JSVAL_TO_STRING(val);
    1:         char* bytes = JS_GetStringBytes(string);
    1:         printf("<%s>\n", bytes);
    1:     }
    1:     else if(JSVAL_IS_BOOLEAN(val)) {
    1:         printf("Value is boolean: ");
    1:         printf(JSVAL_TO_BOOLEAN(val) ? "true" : "false");
    1:     }
    1:     else if(JSVAL_IS_VOID(val)) {
    1:         printf("Value is undefined\n");
    1:     }
    1:     else {
    1:         printf("No idea what this value is.\n");
    1:     }
    1: }
    1: JS_END_EXTERN_C
18403: 
