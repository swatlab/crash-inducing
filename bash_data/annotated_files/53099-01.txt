29366: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
32658:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
52522: #define __STDC_LIMIT_MACROS
52522: 
    1: /*
    1:  * JavaScript bytecode interpreter.
    1:  */
    1: #include <stdio.h>
    1: #include <string.h>
    1: #include <math.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
    1: #include "jscntxt.h"
25087: #include "jsdate.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
40359: #include "jspropertycache.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
18989: #include "jsstaticcheck.h"
17584: #include "jstracer.h"
30268: #include "jslibmath.h"
32581: #include "jsvector.h"
34349: 
34349: #include "jsatominlines.h"
42714: #include "jscntxtinlines.h"
42714: #include "jsdtracef.h"
42714: #include "jsobjinlines.h"
40359: #include "jspropertycacheinlines.h"
34349: #include "jsscopeinlines.h"
34349: #include "jsscriptinlines.h"
32607: #include "jsstrinlines.h"
52520: #include "jscntxtinlines.h"
 7058: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
15453: #include "jsautooplen.h"
15453: 
37741: using namespace js;
37741: 
15996: /* jsinvoke_cpp___ indicates inclusion from jsinvoke.cpp. */
15996: #if !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___
12551: 
42717: #ifdef DEBUG
42717: jsbytecode *const JSStackFrame::sInvalidPC = (jsbytecode *)0xbeef;
42717: #endif
    1: 
    1: JSObject *
    1: js_GetScopeChain(JSContext *cx, JSStackFrame *fp)
    1: {
26238:     JSObject *sharedBlock = fp->blockChain;
26238: 
26238:     if (!sharedBlock) {
    1:         /*
    1:          * Don't force a call object for a lightweight function call, but do
    1:          * insist that there is a call object for a heavyweight function call.
    1:          */
    1:         JS_ASSERT(!fp->fun ||
    1:                   !(fp->fun->flags & JSFUN_HEAVYWEIGHT) ||
    1:                   fp->callobj);
    1:         JS_ASSERT(fp->scopeChain);
    1:         return fp->scopeChain;
    1:     }
    1: 
26238:     /* We don't handle cloning blocks on trace.  */
37741:     LeaveTrace(cx);
26238: 
    1:     /*
    1:      * We have one or more lexical scopes to reflect into fp->scopeChain, so
    1:      * make sure there's a call object at the current head of the scope chain,
    1:      * if this frame is a call frame.
26238:      *
26238:      * Also, identify the innermost compiler-allocated block we needn't clone.
26238:      */
26238:     JSObject *limitBlock, *limitClone;
    1:     if (fp->fun && !fp->callobj) {
42714:         JS_ASSERT_IF(fp->scopeChain->getClass() == &js_BlockClass,
42714:                      fp->scopeChain->getPrivate() != js_FloatingFrameIfGenerator(cx, fp));
25217:         if (!js_GetCallObject(cx, fp))
    1:             return NULL;
26238: 
26238:         /* We know we must clone everything on blockChain. */
26238:         limitBlock = limitClone = NULL;
26238:     } else {
26238:         /*
26238:          * scopeChain includes all blocks whose static scope we're within that
26238:          * have already been cloned.  Find the innermost such block.  Its
26238:          * prototype should appear on blockChain; we'll clone blockChain up
26238:          * to, but not including, that prototype.
26238:          */
26238:         limitClone = fp->scopeChain;
40826:         while (limitClone->getClass() == &js_WithClass)
39930:             limitClone = limitClone->getParent();
26238:         JS_ASSERT(limitClone);
26238: 
26238:         /*
26238:          * It may seem like we don't know enough about limitClone to be able
26238:          * to just grab its prototype as we do here, but it's actually okay.
26238:          *
26238:          * If limitClone is a block object belonging to this frame, then its
26238:          * prototype is the innermost entry in blockChain that we have already
26238:          * cloned, and is thus the place to stop when we clone below.
26238:          *
26238:          * Otherwise, there are no blocks for this frame on scopeChain, and we
26238:          * need to clone the whole blockChain.  In this case, limitBlock can
26238:          * point to any object known not to be on blockChain, since we simply
26238:          * loop until we hit limitBlock or NULL.  If limitClone is a block, it
26238:          * isn't a block from this function, since blocks can't be nested
26238:          * within themselves on scopeChain (recursion is dynamic nesting, not
26238:          * static nesting).  If limitClone isn't a block, its prototype won't
26238:          * be a block either.  So we can just grab limitClone's prototype here
26238:          * regardless of its type or which frame it belongs to.
26238:          */
39928:         limitBlock = limitClone->getProto();
26238: 
26238:         /* If the innermost block has already been cloned, we are done. */
26238:         if (limitBlock == sharedBlock)
26238:             return fp->scopeChain;
26238:     }
26238: 
26238:     /*
26238:      * Special-case cloning the innermost block; this doesn't have enough in
26238:      * common with subsequent steps to include in the loop.
26238:      *
30645:      * js_CloneBlockObject leaves the clone's parent slot uninitialized. We
30645:      * populate it below.
30645:      */
30645:     JSObject *innermostNewChild = js_CloneBlockObject(cx, sharedBlock, fp);
26238:     if (!innermostNewChild)
26238:         return NULL;
52522:     AutoObjectRooter tvr(cx, innermostNewChild);
26238: 
26238:     /*
26238:      * Clone our way towards outer scopes until we reach the innermost
26238:      * enclosing function, or the innermost block we've already cloned.
26238:      */
26238:     JSObject *newChild = innermostNewChild;
26186:     for (;;) {
39928:         JS_ASSERT(newChild->getProto() == sharedBlock);
39930:         sharedBlock = sharedBlock->getParent();
26238: 
26238:         /* Sometimes limitBlock will be NULL, so check that first.  */
26238:         if (sharedBlock == limitBlock || !sharedBlock)
26238:             break;
26238: 
26238:         /* As in the call above, we don't know the real parent yet.  */
52522:         JSObject *clone = js_CloneBlockObject(cx, sharedBlock, fp);
26238:         if (!clone)
26186:             return NULL;
26238: 
39930:         newChild->setParent(clone);
26238:         newChild = clone;
26238:     }
39930:     newChild->setParent(fp->scopeChain);
30645: 
26238: 
26238:     /*
26238:      * If we found a limit block belonging to this frame, then we should have
26238:      * found it in blockChain.
26238:      */
26238:     JS_ASSERT_IF(limitBlock &&
40826:                  limitBlock->getClass() == &js_BlockClass &&
42714:                  limitClone->getPrivate() == js_FloatingFrameIfGenerator(cx, fp),
26238:                  sharedBlock);
26238: 
26238:     /* Place our newly cloned blocks at the head of the scope chain.  */
26238:     fp->scopeChain = innermostNewChild;
52809:     return innermostNewChild;
    1: }
    1: 
 2383: JSBool
52531: js_GetPrimitiveThis(JSContext *cx, Value *vp, Class *clasp, const Value **vpp)
    1: {
52525:     const Value *p = &vp[1];
52525:     if (p->isObject()) {
53059:         JSObject *obj = ComputeThisFromVp(cx, vp);
52525:         if (!InstanceOf(cx, obj, clasp, vp + 2))
 4127:             return JS_FALSE;
52531:         *vpp = &obj->getPrimitiveThis();
52531:     } else {
52531:         *vpp = p;
 4127:     }
 2383:     return JS_TRUE;
 4127: }
 4127: 
47405: /* Some objects (e.g., With) delegate 'this' to another object. */
47405: static inline JSObject *
53059: CallThisObjectHook(JSContext *cx, JSObject *obj, Value *argv)
47405: {
47405:     JSObject *thisp = obj->thisObject(cx);
47405:     if (!thisp)
47405:         return NULL;
53059:     argv[-1].setObject(*thisp);
47405:     return thisp;
47405: }
47405: 
    1: /*
 4127:  * ECMA requires "the global object", but in embeddings such as the browser,
 4127:  * which have multiple top-level objects (windows, frames, etc. in the DOM),
 4127:  * we prefer fun's parent.  An example that causes this code to run:
    1:  *
    1:  *   // in window w1
    1:  *   function f() { return this }
    1:  *   function g() { return f }
    1:  *
    1:  *   // in window w2
    1:  *   var h = w1.g()
    1:  *   alert(h() == w1)
    1:  *
    1:  * The alert should display "true".
    1:  */
15996: JS_STATIC_INTERPRET JSObject *
52522: ComputeGlobalThis(JSContext *cx, Value *argv)
 4127: {
47520:     /* Find the inner global. */
47520:     JSObject *inner;
53076:     if (argv[-2].isPrimitive() || !argv[-2].toObject().getParent()) {
47520:         inner = cx->globalObject;
47520:         OBJ_TO_INNER_OBJECT(cx, inner);
47520:         if (!inner)
47520:             return NULL;
47520:     } else {
53076:         inner = argv[-2].toObject().getGlobal();
47520:     }
47520:     JS_ASSERT(inner->getClass()->flags & JSCLASS_IS_GLOBAL);
47405: 
47520:     JSObject *scope = JS_GetGlobalForScopeChain(cx);
47520:     if (scope == inner) {
47520:         /*
47520:          * The outer object has not moved along to a new inner object.
47520:          * This means we qualify for the cache slot in the global.
47520:          */
53059:         const Value &thisv = inner->getReservedSlot(JSRESERVED_GLOBAL_THIS);
53059:         if (!thisv.isUndefined()) {
47521:             argv[-1] = thisv;
53076:             return thisv.toObjectOrNull();
47521:         }
47520: 
47520:         JSObject *stuntThis = CallThisObjectHook(cx, inner, argv);
47520:         JS_ALWAYS_TRUE(js_SetReservedSlot(cx, inner, JSRESERVED_GLOBAL_THIS,
53076:                                           ObjectOrNullValue(stuntThis)));
47520:         return stuntThis;
47405:     }
47405: 
47520:     return CallThisObjectHook(cx, inner, argv);
47405: }
47405: 
53059: namespace js {
53059: 
47449: JSObject *
53059: ComputeThisFromArgv(JSContext *cx, Value *argv)
47405: {
53059:     JS_ASSERT(!argv[-1].isMagic(JS_THIS_POISON));
53059:     if (argv[-1].isNull())
53059:         return ComputeGlobalThis(cx, argv);
47449: 
47405:     JSObject *thisp;
47405: 
53059:     JS_ASSERT(!argv[-1].isNull());
53059:     if (argv[-1].isPrimitive()) {
47405:         if (!js_PrimitiveToObject(cx, &argv[-1]))
47405:             return NULL;
53076:         thisp = argv[-1].toObjectOrNull();
34292:         return thisp;
34292:     } 
34292: 
53076:     thisp = &argv[-1].toObject();
47405:     if (thisp->getClass() == &js_CallClass || thisp->getClass() == &js_BlockClass)
53059:         return ComputeGlobalThis(cx, argv);
47405: 
47405:     return CallThisObjectHook(cx, thisp, argv);
47405: }
47405: 
53059: }
53059: 
    1: #if JS_HAS_NO_SUCH_METHOD
    1: 
32684: const uint32 JSSLOT_FOUND_FUNCTION  = JSSLOT_PRIVATE;
32684: const uint32 JSSLOT_SAVED_ID        = JSSLOT_PRIVATE + 1;
14789: 
52522: Class js_NoSuchMethodClass = {
12579:     "NoSuchMethod",
28093:     JSCLASS_HAS_RESERVED_SLOTS(2) | JSCLASS_IS_ANONYMOUS,
52522:     PropertyStub,     PropertyStub,     PropertyStub,      PropertyStub,
52522:     EnumerateStub,    ResolveStub,      ConvertStub,       NULL,
12579:     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
12579: };
12579: 
12579: /*
12579:  * When JSOP_CALLPROP or JSOP_CALLELEM does not find the method property of
12579:  * the base object, we search for the __noSuchMethod__ method in the base.
12579:  * If it exists, we store the method and the property's id into an object of
12579:  * NoSuchMethod class and store this object into the callee's stack slot.
12579:  * Later, js_Invoke will recognise such an object and transfer control to
12579:  * NoSuchMethod that invokes the method like:
12579:  *
12579:  *   this.__noSuchMethod__(id, args)
12579:  *
12579:  * where id is the name of the method that this invocation attempted to
12579:  * call by name, and args is an Array containing this invocation's actual
12579:  * parameters.
12579:  */
15996: JS_STATIC_INTERPRET JSBool
52522: js_OnUnknownMethod(JSContext *cx, Value *vp)
12579: {
52522:     JS_ASSERT(!vp[1].isPrimitive());
33178: 
53076:     JSObject *obj = &vp[1].toObject();
33178:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.noSuchMethodAtom);
52522:     AutoValueRooter tvr(cx);
33178:     if (!js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, tvr.addr()))
33178:         return false;
52522:     if (tvr.value().isPrimitive()) {
33178:         vp[0] = tvr.value();
12579:     } else {
    1: #if JS_HAS_XML_SUPPORT
12610:         /* Extract the function name from function::name qname. */
52522:         if (vp[0].isObject()) {
53076:             obj = &vp[0].toObject();
33178:             if (!js_IsFunctionQName(cx, obj, &id))
33178:                 return false;
52924:             if (!JSID_IS_VOID(id))
52924:                 vp[0] = IdToValue(id);
12610:         }
    1: #endif
47497:         obj = js_NewGCObject(cx);
33178:         if (!obj)
33178:             return false;
47497: 
47497:         /*
47497:          * Null map to cause prompt and safe crash if this object were to
47497:          * escape due to a bug. This will make the object appear to be a
47497:          * stillborn instance that needs no finalization, which is sound:
47497:          * NoSuchMethod helper objects own no manually allocated resources.
47497:          */
47497:         obj->map = NULL;
47497:         obj->init(&js_NoSuchMethodClass, NULL, NULL, tvr.value());
14789:         obj->fslots[JSSLOT_SAVED_ID] = vp[0];
53021:         vp[0].setObject(*obj);
12579:     }
33178:     return true;
12579: }
12579: 
24499: static JS_REQUIRES_STACK JSBool
52522: NoSuchMethod(JSContext *cx, uintN argc, Value *vp, uint32 flags)
    1: {
42714:     InvokeArgsGuard args;
42714:     if (!cx->stack().pushInvokeArgs(cx, 2, args))
14789:         return JS_FALSE;
12579: 
52525:     JS_ASSERT(vp[0].isObject());
52525:     JS_ASSERT(vp[1].isObject());
53076:     JSObject *obj = &vp[0].toObject();
40410:     JS_ASSERT(obj->getClass() == &js_NoSuchMethodClass);
14789: 
52524:     Value *invokevp = args.getvp();
14789:     invokevp[0] = obj->fslots[JSSLOT_FOUND_FUNCTION];
14789:     invokevp[1] = vp[1];
14789:     invokevp[2] = obj->fslots[JSSLOT_SAVED_ID];
42714:     JSObject *argsobj = js_NewArrayObject(cx, argc, vp + 2);
42714:     if (!argsobj)
42714:         return JS_FALSE;
53021:     invokevp[3].setObject(*argsobj);
42714:     JSBool ok = (flags & JSINVOKE_CONSTRUCT)
53058:                 ? InvokeConstructor(cx, args)
52522:                 : Invoke(cx, args, flags);
52536:     vp[0] = invokevp[0];
  348:     return ok;
    1: }
    1: 
    1: #endif /* JS_HAS_NO_SUCH_METHOD */
    1: 
52522: namespace js {
    1: 
43281: class AutoPreserveEnumerators {
43281:     JSContext *cx;
43281:     JSObject *enumerators;
43281: 
43281:   public:
43281:     AutoPreserveEnumerators(JSContext *cx) : cx(cx), enumerators(cx->enumerators)
43281:     {
43281:     }
43281: 
43281:     ~AutoPreserveEnumerators()
43281:     {
43281:         cx->enumerators = enumerators;
43281:     }
43281: };
43281: 
47449: static JS_REQUIRES_STACK bool
53059: callJSNative(JSContext *cx, CallOp callOp, JSObject *thisp, uintN argc, Value *argv, Value *rval)
47495: {
53059:     Value *vp = argv - 2;
47495:     if (callJSFastNative(cx, callOp, argc, vp)) {
47495:         *rval = JS_RVAL(cx, vp);
47495:         return true;
47495:     }
47495:     return false;
47495: }
47495: 
47495: template <typename T>
47495: static JS_REQUIRES_STACK bool
53059: InvokeCommon(JSContext *cx, JSFunction *fun, JSScript *script, T native,
47449:        const InvokeArgsGuard &args, uintN flags)
    1: {
47449:     uintN argc = args.getArgc();
53059:     Value *vp = args.getvp();
42714: 
42714:     if (native && fun && fun->isFastNative()) {
16519: #ifdef DEBUG_NOT_THROWING
16519:         JSBool alreadyThrowing = cx->throwing;
16519: #endif
53059:         JSBool ok = callJSFastNative(cx, (FastNative) native, argc, vp);
16519:         JS_RUNTIME_METER(cx->runtime, nativeCalls);
16519: #ifdef DEBUG_NOT_THROWING
16519:         if (ok && !alreadyThrowing)
16519:             ASSERT_NOT_THROWING(cx);
16519: #endif
42714:         return ok;
16519:     }
16519: 
42714:     /* Calculate slot usage. */
42714:     uintN nmissing;
42714:     uintN nvars;
42714:     if (fun) {
42714:         if (fun->isInterpreted()) {
42714:             uintN minargs = fun->nargs;
42714:             nmissing = minargs > argc ? minargs - argc : 0;
42714:             nvars = fun->u.i.nvars;
42714:         } else if (fun->isFastNative()) {
42714:             nvars = nmissing = 0;
42714:         } else {
42714:             uintN minargs = fun->nargs;
42714:             nmissing = (minargs > argc ? minargs - argc : 0) + fun->u.n.extra;
42714:             nvars = 0;
 6040:         }
42714:     } else {
42714:         nvars = nmissing = 0;
 6040:     }
 6040: 
42714:     uintN nfixed = script ? script->nslots : 0;
41965: 
41965:     /*
42714:      * Get a pointer to new frame/slots. This memory is not "claimed", so the
42714:      * code before pushInvokeFrame must not reenter the interpreter.
41965:      */
42717:     JSFrameRegs regs;
42714:     InvokeFrameGuard frame;
42714:     if (!cx->stack().getInvokeFrame(cx, args, nmissing, nfixed, frame))
42714:         return false;
42714:     JSStackFrame *fp = frame.getFrame();
42709: 
42714:     /* Initialize missing missing arguments and new local variables. */
53059:     Value *missing = vp + 2 + argc;
53059:     SetValueRangeToUndefined(missing, nmissing);
53059:     SetValueRangeToUndefined(fp->slots(), nvars);
42709: 
42714:     /* Initialize frame. */
42714:     fp->thisv = vp[1];
42714:     fp->callobj = NULL;
42714:     fp->argsobj = NULL;
42714:     fp->script = script;
42714:     fp->fun = fun;
42714:     fp->argc = argc;
42714:     fp->argv = vp + 2;
53076:     fp->rval = (flags & JSINVOKE_CONSTRUCT) ? fp->thisv : UndefinedValue();
42714:     fp->annotation = NULL;
42714:     fp->scopeChain = NULL;
42714:     fp->blockChain = NULL;
42714:     fp->imacpc = NULL;
42714:     fp->flags = flags;
42714:     fp->displaySave = NULL;
42709: 
42717:     /* Initialize regs. */
42717:     if (script) {
42717:         regs.pc = script->code;
42717:         regs.sp = fp->slots() + script->nfixed;
42717:     } else {
42717:         regs.pc = NULL;
42717:         regs.sp = fp->slots();
 6040:     }
 6040: 
42714:     /* Officially push |fp|. |frame|'s destructor pops. */
42717:     cx->stack().pushInvokeFrame(cx, args, frame, regs);
 6040: 
42714:     /* Now that the frame has been pushed, fix up the scope chain. */
53076:     JSObject *parent = vp[0].toObject().getParent();
    1:     if (native) {
47495:         /* Slow natives and call ops expect the caller's scopeChain as their scopeChain. */
42714:         if (JSStackFrame *down = fp->down)
42714:             fp->scopeChain = down->scopeChain;
 3307: 
37777:         /* Ensure that we have a scope chain. */
42714:         if (!fp->scopeChain)
42714:             fp->scopeChain = parent;
26728:     } else {
    1:         /* Use parent scope so js_GetCallObject can find the right "Call". */
42714:         fp->scopeChain = parent;
42714:         if (fun->isHeavyweight() && !js_GetCallObject(cx, fp))
42714:             return false;
26728:     }
26728: 
26728:     /* Call the hook if present after we fully initialized the frame. */
42714:     JSInterpreterHook hook = cx->debugHooks->callHook;
42714:     void *hookData = NULL;
26728:     if (hook)
42714:         hookData = hook(cx, fp, JS_TRUE, 0, cx->debugHooks->callHookData);
26728: 
42714:     DTrace::enterJSFun(cx, fp, fun, fp->down, fp->argc, fp->argv);
29445: 
26728:     /* Call the function, either a native method or an interpreted script. */
42714:     JSBool ok;
26728:     if (native) {
26728: #ifdef DEBUG_NOT_THROWING
26728:         JSBool alreadyThrowing = cx->throwing;
26728: #endif
47495: 
53076:         JSObject *thisp = fp->thisv.toObjectOrNull();
47485:         ok = callJSNative(cx, native, thisp, fp->argc, fp->argv, &fp->rval);
47495: 
42714:         JS_ASSERT(cx->fp == fp);
26728:         JS_RUNTIME_METER(cx->runtime, nativeCalls);
26728: #ifdef DEBUG_NOT_THROWING
26728:         if (ok && !alreadyThrowing)
26728:             ASSERT_NOT_THROWING(cx);
26728: #endif
26728:     } else {
26728:         JS_ASSERT(script);
43281:         AutoPreserveEnumerators preserve(cx);
52522:         ok = Interpret(cx);
    1:     }
    1: 
42714:     DTrace::exitJSFun(cx, fp, fun, fp->rval);
29445: 
    1:     if (hookData) {
 2433:         hook = cx->debugHooks->callHook;
    1:         if (hook)
42714:             hook(cx, fp, JS_FALSE, &ok, hookData);
    1:     }
    1: 
42714:     fp->putActivationObjects(cx);
42714:     *vp = fp->rval;
    1:     return ok;
    1: }
    1: 
47449: /*
47495:  * Find a function reference and its 'this' value implicit first parameter
47449:  * under argc arguments on cx's stack, and call the function.  Push missing
47449:  * required arguments, allocate declared local variables, and pop everything
47449:  * when done.  Then push the return value.
47449:  */
53059: JS_REQUIRES_STACK bool
53059: Invoke(JSContext *cx, const InvokeArgsGuard &args, uintN flags)
47449: {
53059:     Value *vp = args.getvp();
47449:     uintN argc = args.getArgc();
47449:     JS_ASSERT(argc <= JS_ARGS_LENGTH_MAX);
47449: 
53059:     const Value &v = vp[0];
53059:     if (v.isPrimitive()) {
47449:         js_ReportIsNotFunction(cx, vp, flags & JSINVOKE_FUNFLAGS);
47449:         return false;
47449:     }
47449: 
53076:     JSObject *funobj = &v.toObject();
53059:     Class *clasp = funobj->getClass();
47449: 
47449:     if (clasp == &js_FunctionClass) {
47449:         /* Get private data and set derived locals from it. */
47449:         JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
53059:         Native native;
47449:         JSScript *script;
47449:         if (FUN_INTERPRETED(fun)) {
47449:             native = NULL;
47449:             script = fun->u.i.script;
47449:             JS_ASSERT(script);
47449: 
47449:             if (script->isEmpty()) {
47449:                 if (flags & JSINVOKE_CONSTRUCT) {
53059:                     JS_ASSERT(vp[1].isObject());
47449:                     *vp = vp[1];
47449:                 } else {
53059:                     vp->setUndefined();
47449:                 }
47449:                 return true;
47449:             }
47449:         } else {
47449:             native = fun->u.n.native;
47449:             script = NULL;
47449:         }
47449: 
47449:         if (JSFUN_BOUND_METHOD_TEST(fun->flags)) {
47449:             /* Handle bound method special case. */
53059:             vp[1].setObject(*funobj->getParent());
53059:         } else if (!vp[1].isObjectOrNull()) {
47449:             JS_ASSERT(!(flags & JSINVOKE_CONSTRUCT));
53059:             if (PrimitiveThisTest(fun, vp[1]))
53059:                 return InvokeCommon(cx, fun, script, native, args, flags);
47449:         }
47449: 
47449:         if (flags & JSINVOKE_CONSTRUCT) {
53059:             JS_ASSERT(args.getvp()[1].isObject());
47449:         } else {
47449:             /*
47449:              * We must call js_ComputeThis in case we are not called from the
47449:              * interpreter, where a prior bytecode has computed an appropriate
47449:              * |this| already.
47449:              *
47449:              * But we need to compute |this| eagerly only for so-called "slow"
47449:              * (i.e., not fast) native functions. Fast natives must use either
47449:              * JS_THIS or JS_THIS_OBJECT, and scripted functions will go through
47449:              * the appropriate this-computing bytecode, e.g., JSOP_THIS.
47449:              */
47449:             if (native && (!fun || !(fun->flags & JSFUN_FAST_NATIVE))) {
53059:                 Value *vp = args.getvp();
53059:                 if (!ComputeThisFromVp(cx, vp))
47449:                     return false;
47449:                 flags |= JSFRAME_COMPUTED_THIS;
47449:             }
47449:         }
53059:         return InvokeCommon(cx, fun, script, native, args, flags);
47449:     }
47449: 
47449: #if JS_HAS_NO_SUCH_METHOD
47449:     if (clasp == &js_NoSuchMethodClass)
47449:         return NoSuchMethod(cx, argc, vp, flags);
47449: #endif
47449: 
47449:     /* Function is inlined, all other classes use object ops. */
47449:     const JSObjectOps *ops = funobj->map->ops;
47449: 
47449:     /* Try a call or construct native object op. */
47449:     if (flags & JSINVOKE_CONSTRUCT) {
53059:         if (!vp[1].isObjectOrNull()) {
47449:             if (!js_PrimitiveToObject(cx, &vp[1]))
47449:                 return false;
47449:         }
53059:         Native native = ops->construct;
47449:         if (!native) {
47449:             js_ReportIsNotFunction(cx, vp, flags & JSINVOKE_FUNFLAGS);
47449:             return false;
47449:         }
53059:         return InvokeCommon(cx, NULL, NULL, native, args, flags);
47449:     }
53059:     CallOp callOp = ops->call;
47495:     if (!callOp) {
47495:         js_ReportIsNotFunction(cx, vp, flags & JSINVOKE_FUNFLAGS);
47495:         return false;
47495:     }
53059:     return InvokeCommon(cx, NULL, NULL, callOp, args, flags);
53059: }
53059: 
53059: extern JS_REQUIRES_STACK JS_FRIEND_API(bool)
53059: InvokeFriendAPI(JSContext *cx, const InvokeArgsGuard &args, uintN flags)
53059: {
53059:     return Invoke(cx, args, flags);
47495: }
47449: 
24612: JSBool
53059: InternalInvoke(JSContext *cx, const Value &thisv, const Value &fval, uintN flags,
53059:                   uintN argc, Value *argv, Value *rval)
    1: {
42714:     LeaveTrace(cx);
    1: 
42714:     InvokeArgsGuard args;
42714:     if (!cx->stack().pushInvokeArgs(cx, argc, args))
 6040:         return JS_FALSE;
 6040: 
42714:     args.getvp()[0] = fval;
47495:     args.getvp()[1] = thisv;
53059:     memcpy(args.getvp() + 2, argv, argc * sizeof(Value));
 6040: 
52522:     if (!Invoke(cx, args, flags))
42714:         return JS_FALSE;
42714: 
    1:     /*
47494:      * Store *rval in the lastInternalResult pigeon-hole GC root, solely
47494:      * so users of js_InternalInvoke and its direct and indirect
47494:      * (js_ValueToString for example) callers do not need to manage roots
47494:      * for local, temporary references to such results.
    1:      */
42714:     *rval = *args.getvp();
53059:     if (rval->isMarkable())
53059:         cx->weakRoots.lastInternalResult = rval->asGCThing();
    1: 
42714:     return JS_TRUE;
    1: }
    1: 
52522: bool
52522: InternalGetOrSet(JSContext *cx, JSObject *obj, jsid id, const Value &fval,
53059:                  JSAccessMode mode, uintN argc, Value *argv, Value *rval)
    1: {
37741:     LeaveTrace(cx);
24499: 
    1:     /*
52522:      * InternalInvoke could result in another try to get or set the same id
    1:      * again, see bug 355497.
    1:      */
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
52522:     return InternalCall(cx, obj, fval, argc, argv, rval);
    1: }
    1: 
52522: bool
53095: Execute(JSContext *cx, JSObject *chain, JSScript *script,
52522:         JSStackFrame *down, uintN flags, Value *result)
    1: {
34290:     if (script->isEmpty()) {
34290:         if (result)
52522:             result->setUndefined();
34290:         return JS_TRUE;
34290:     }
34290: 
37741:     LeaveTrace(cx);
28134: 
41862:     DTrace::ExecutionScope executionScope(script);
42714:     /*
42714:      * Get a pointer to new frame/slots. This memory is not "claimed", so the
42714:      * code before pushExecuteFrame must not reenter the interpreter.
42714:      *
42714:      * N.B. when fp->argv is removed (bug 539144), argv will have to be copied
42714:      * in before execution and copied out after.
42714:      */
42717:     JSFrameRegs regs;
42714:     ExecuteFrameGuard frame;
42714:     if (!cx->stack().getExecuteFrame(cx, down, 0, script->nslots, frame))
42714:         return false;
42714:     JSStackFrame *fp = frame.getFrame();
42714: 
52582:     /* Initialize fixed slots (GVAR ops expecte NULL). */
52582:     SetValueRangeToNull(fp->slots(), script->nfixed);
42714: 
42714: #if JS_HAS_SHARP_VARS
42714:     JS_STATIC_ASSERT(SHARP_NSLOTS == 2);
42714:     if (script->hasSharps) {
42714:         JS_ASSERT(script->nfixed >= SHARP_NSLOTS);
52522:         Value *sharps = &fp->slots()[script->nfixed - SHARP_NSLOTS];
42714:         if (down && down->script && down->script->hasSharps) {
42714:             JS_ASSERT(down->script->nfixed >= SHARP_NSLOTS);
42714:             int base = (down->fun && !(down->flags & JSFRAME_SPECIAL))
42714:                        ? down->fun->sharpSlotBase(cx)
42714:                        : down->script->nfixed - SHARP_NSLOTS;
42714:             if (base < 0)
42714:                 return false;
42714:             sharps[0] = down->slots()[base];
42714:             sharps[1] = down->slots()[base + 1];
42714:         } else {
52522:             sharps[0].setUndefined();
52522:             sharps[1].setUndefined();
42714:         }
42714:     }
42714: #endif
42714: 
42714:     /* Initialize frame. */
42714:     JSObject *initialVarObj;
    1:     if (down) {
16072:         /* Propagate arg state for eval and the debugger API. */
42714:         fp->callobj = down->callobj;
42714:         fp->argsobj = down->argsobj;
42714:         fp->fun = (script->staticLevel > 0) ? down->fun : NULL;
42714:         fp->thisv = down->thisv;
47405:         fp->flags = flags | (down->flags & JSFRAME_COMPUTED_THIS);
42714:         fp->argc = down->argc;
42714:         fp->argv = down->argv;
42714:         fp->annotation = down->annotation;
42714:         fp->scopeChain = chain;
37777: 
37777:         /*
37777:          * We want to call |down->varobj()|, but this requires knowing the
37777:          * CallStack of |down|. If |down == cx->fp|, the callstack is simply
37777:          * the context's active callstack, so we can use |down->varobj(cx)|.
37777:          * When |down != cx->fp|, we need to do a slow linear search. Luckily,
38586:          * this only happens with indirect eval and JS_EvaluateInStackFrame.
37777:          */
42714:         initialVarObj = (down == cx->fp)
42714:                         ? down->varobj(cx)
42714:                         : down->varobj(cx->containingCallStack(down));
37777:     } else {
42714:         fp->callobj = NULL;
42714:         fp->argsobj = NULL;
42714:         fp->fun = NULL;
42714:         /* Ininitialize fp->thisv after pushExecuteFrame. */
47405:         fp->flags = flags | JSFRAME_COMPUTED_THIS;
42714:         fp->argc = 0;
42714:         fp->argv = NULL;
42714:         fp->annotation = NULL;
42714: 
42714:         JSObject *innerizedChain = chain;
42714:         OBJ_TO_INNER_OBJECT(cx, innerizedChain);
42714:         if (!innerizedChain)
42714:             return false;
42714:         fp->scopeChain = innerizedChain;
42714: 
42714:         initialVarObj = (cx->options & JSOPTION_VAROBJFIX)
42714:                         ? chain->getGlobal()
42714:                         : chain;
37777:     }
42742:     JS_ASSERT(initialVarObj->map->ops->defineProperty == js_DefineProperty);
42742: 
42714:     fp->script = script;
42714:     fp->imacpc = NULL;
52522:     fp->rval.setUndefined();
42714:     fp->blockChain = NULL;
42714: 
42717:     /* Initialize regs. */
42717:     regs.pc = script->code;
52522:     regs.sp = fp->base();
42717: 
42714:     /* Officially push |fp|. |frame|'s destructor pops. */
42717:     cx->stack().pushExecuteFrame(cx, frame, regs, initialVarObj);
42714: 
42714:     /* Now that the frame has been pushed, we can call the thisObject hook. */
42714:     if (!down) {
42714:         JSObject *thisp = chain->thisObject(cx);
42714:         if (!thisp)
42714:             return false;
52795:         fp->thisv.setObject(*thisp);
16072:     }
21685: 
42714:     void *hookData = NULL;
42714:     if (JSInterpreterHook hook = cx->debugHooks->executeHook)
42714:         hookData = hook(cx, fp, JS_TRUE, 0, cx->debugHooks->executeHookData);
    1: 
43281:     AutoPreserveEnumerators preserve(cx);
52522:     JSBool ok = Interpret(cx);
17828:     if (result)
42714:         *result = fp->rval;
    1: 
    1:     if (hookData) {
42714:         if (JSInterpreterHook hook = cx->debugHooks->executeHook)
42714:             hook(cx, fp, JS_FALSE, &ok, hookData);
    1:     }
15584: 
52562:     return !!ok;
    1: }
    1: 
52522: bool
52522: CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs,
    1:                    JSObject **objp, JSProperty **propp)
    1: {
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     uintN oldAttrs, report;
30258:     bool isFunction;
    1:     const char *type, *name;
    1: 
24592:     /*
24592:      * Both objp and propp must be either null or given. When given, *propp
24592:      * must be null. This way we avoid an extra "if (propp) *propp = NULL" for
42587:      * the common case of a nonexistent property.
24592:      */
24592:     JS_ASSERT(!objp == !propp);
24592:     JS_ASSERT_IF(propp, !*propp);
24592: 
24592:     /* The JSPROP_INITIALIZER case below may generate a warning. Since we must
24592:      * drop the property before reporting it, we insists on !propp to avoid
24592:      * looking up the property again after the reporting is done.
24592:      */
24592:     JS_ASSERT_IF(attrs & JSPROP_INITIALIZER, attrs == JSPROP_INITIALIZER);
24592:     JS_ASSERT_IF(attrs == JSPROP_INITIALIZER, !propp);
24592: 
31501:     if (!obj->lookupProperty(cx, id, &obj2, &prop))
43290:         return false;
    1:     if (!prop)
43290:         return true;
43290:     if (obj2->isNative()) {
43290:         oldAttrs = ((JSScopeProperty *) prop)->attributes();
    1: 
43290:         /* If our caller doesn't want prop, unlock obj2. */
43290:         if (!propp)
43290:             JS_UNLOCK_OBJ(cx, obj2);
43290:     } else {
43290:         if (!obj2->getAttributes(cx, id, &oldAttrs))
43290:             return false;
    1:     }
    1: 
    1:     if (!propp) {
    1:         prop = NULL;
24592:     } else {
24592:         *objp = obj2;
24592:         *propp = prop;
    1:     }
    1: 
    1:     if (attrs == JSPROP_INITIALIZER) {
    1:         /* Allow the new object to override properties. */
    1:         if (obj2 != obj)
    1:             return JS_TRUE;
24592: 
24592:         /* The property must be dropped already. */
24592:         JS_ASSERT(!prop);
    1:         report = JSREPORT_WARNING | JSREPORT_STRICT;
30258: 
30258: #ifdef __GNUC__
30258:         isFunction = false;     /* suppress bogus gcc warnings */
30258: #endif
    1:     } else {
    1:         /* We allow redeclaring some non-readonly properties. */
    1:         if (((oldAttrs | attrs) & JSPROP_READONLY) == 0) {
24592:             /* Allow redeclaration of variables and functions. */
    1:             if (!(attrs & (JSPROP_GETTER | JSPROP_SETTER)))
    1:                 return JS_TRUE;
24592: 
24592:             /*
24592:              * Allow adding a getter only if a property already has a setter
24592:              * but no getter and similarly for adding a setter. That is, we
24592:              * allow only the following transitions:
24592:              *
24592:              *   no-property --> getter --> getter + setter
24592:              *   no-property --> setter --> getter + setter
24592:              */
    1:             if ((~(oldAttrs ^ attrs) & (JSPROP_GETTER | JSPROP_SETTER)) == 0)
    1:                 return JS_TRUE;
24592: 
24592:             /*
24592:              * Allow redeclaration of an impermanent property (in which case
24592:              * anyone could delete it and redefine it, willy-nilly).
24592:              */
    1:             if (!(oldAttrs & JSPROP_PERMANENT))
    1:                 return JS_TRUE;
    1:         }
24592:         if (prop)
31501:             obj2->dropProperty(cx, prop);
    1: 
    1:         report = JSREPORT_ERROR;
    1:         isFunction = (oldAttrs & (JSPROP_GETTER | JSPROP_SETTER)) != 0;
    1:         if (!isFunction) {
52522:             Value value;
31501:             if (!obj->getProperty(cx, id, &value))
24592:                 return JS_FALSE;
53021:             isFunction = IsFunctionObject(value);
    1:         }
    1:     }
    1: 
    1:     type = (attrs == JSPROP_INITIALIZER)
    1:            ? "property"
    1:            : (oldAttrs & attrs & JSPROP_GETTER)
    1:            ? js_getter_str
    1:            : (oldAttrs & attrs & JSPROP_SETTER)
    1:            ? js_setter_str
    1:            : (oldAttrs & JSPROP_READONLY)
    1:            ? js_const_str
    1:            : isFunction
    1:            ? js_function_str
    1:            : js_var_str;
52924:     name = js_ValueToPrintableString(cx, IdToValue(id));
    1:     if (!name)
24592:         return JS_FALSE;
52562:     return !!JS_ReportErrorFlagsAndNumber(cx, report,
    1:                                           js_GetErrorMessage, NULL,
    1:                                           JSMSG_REDECLARED_VAR,
    1:                                           type, name);
    1: }
    1: 
52522: static JS_ALWAYS_INLINE bool
52522: EqualObjects(JSContext *cx, JSObject *lobj, JSObject *robj)
    1: {
52522:     return lobj == robj ||
52795:            lobj->wrappedObject(cx) == robj->wrappedObject(cx);
52522: }
    1: 
52522: bool
52634: StrictlyEqual(JSContext *cx, const Value &lref, const Value &rref)
52522: {
52634:     Value lval = lref, rval = rref;
53021:     if (SameType(lval, rval)) {
52634:         if (lval.isString())
53076:             return js_EqualStrings(lval.toString(), rval.toString());
52634:         if (lval.isDouble())
53076:             return JSDOUBLE_COMPARE(lval.toDouble(), ==, rval.toDouble(), JS_FALSE);
52634:         if (lval.isObject())
53076:             return EqualObjects(cx, &lval.toObject(), &rval.toObject());
53076:         return lval.payloadAsRawUint32() == rval.payloadAsRawUint32();
    1:     }
52522: 
52634:     if (lval.isDouble() && rval.isInt32()) {
53076:         double ld = lval.toDouble();
53076:         double rd = rval.toInt32();
    1:         return JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
    1:     }
52634:     if (lval.isInt32() && rval.isDouble()) {
53076:         double ld = lval.toInt32();
53076:         double rd = rval.toDouble();
    1:         return JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
    1:     }
52522: 
52522:     return false;
    1: }
    1: 
32760: static inline bool
52522: IsNegativeZero(const Value &v)
32760: {
53076:     return v.isDouble() && JSDOUBLE_IS_NEGZERO(v.toDouble());
32760: }
32760: 
32760: static inline bool
52522: IsNaN(const Value &v)
32760: {
53076:     return v.isDouble() && JSDOUBLE_IS_NaN(v.toDouble());
32760: }
32760: 
52522: bool
53008: SameValue(const Value &v1, const Value &v2, JSContext *cx)
32760: {
32760:     if (IsNegativeZero(v1))
32760:         return IsNegativeZero(v2);
32760:     if (IsNegativeZero(v2))
52522:         return false;
32760:     if (IsNaN(v1) && IsNaN(v2))
52522:         return true;
52522:     return StrictlyEqual(cx, v1, v2);
32760: }
32760: 
52522: JSType
52522: TypeOfValue(JSContext *cx, const Value &vref)
52522: {
52536:     Value v = vref;
52522:     if (v.isNumber())
52522:         return JSTYPE_NUMBER;
52522:     if (v.isString())
52522:         return JSTYPE_STRING;
52522:     if (v.isNull())
52522:         return JSTYPE_OBJECT;
52522:     if (v.isUndefined())
52522:         return JSTYPE_VOID;
52522:     if (v.isObject())
53076:         return v.toObject().map->ops->typeOf(cx, &v.toObject());
52522:     JS_ASSERT(v.isBoolean());
52522:     return JSTYPE_BOOLEAN;
52522: }
52522: 
52522: bool
52522: InstanceOfSlow(JSContext *cx, JSObject *obj, Class *clasp, Value *argv)
52522: {
52522:     JS_ASSERT(!obj || obj->getClass() != clasp);
52522:     if (argv) {
52522:         JSFunction *fun = js_ValueToFunction(cx, &argv[-2], 0);
52522:         if (fun) {
52522:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
52522:                                  JSMSG_INCOMPATIBLE_PROTO,
52522:                                  clasp->name, JS_GetFunctionName(fun),
52522:                                  obj
52522:                                  ? obj->getClass()->name
52522:                                  : js_null_str);
52522:         }
52522:     }
52522:     return false;
52522: }
52522: 
52522: JS_REQUIRES_STACK bool
53058: InvokeConstructor(JSContext *cx, const InvokeArgsGuard &args)
    1: {
42714:     JSFunction *fun = NULL;
42714:     JSObject *obj2 = NULL;
52522:     Value *vp = args.getvp();
52522: 
    1:     /* XXX clean up to avoid special cases above ObjectOps layer */
53076:     if (vp->isPrimitive() || (obj2 = &vp->toObject())->isFunction() ||
    1:         !obj2->map->ops->construct)
    1:     {
    1:         fun = js_ValueToFunction(cx, vp, JSV2F_CONSTRUCT);
    1:         if (!fun)
    1:             return JS_FALSE;
    1:     }
    1: 
42714:     JSObject *proto, *parent;
52522:     Class *clasp = &js_ObjectClass;
52522:     if (vp->isPrimitive()) {
52522:         proto = NULL;
52522:         parent = NULL;
    1:         fun = NULL;
    1:     } else {
    1:         /*
    1:          * Get the constructor prototype object for this function.
    1:          * Use the nominal 'this' parameter slot, vp[1], as a local
    1:          * root to protect this prototype, in case it has no other
    1:          * strong refs.
    1:          */
53076:         JSObject *obj2 = &vp->toObject();
31501:         if (!obj2->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
    1:                                &vp[1])) {
    1:             return JS_FALSE;
    1:         }
52522:         const Value &v = vp[1];
52522:         if (v.isObjectOrNull())
53076:             proto = v.toObjectOrNull();
52522:         else
52522:             proto = NULL;
39930:         parent = obj2->getParent();
39930: 
39930:         if (obj2->getClass() == &js_FunctionClass) {
42714:             JSFunction *f = GET_FUNCTION_PRIVATE(cx, obj2);
42714:             if (!f->isInterpreted() && f->u.n.clasp)
42714:                 clasp = f->u.n.clasp;
13702:         }
13702:     }
42714:     JSObject *obj = NewObject(cx, clasp, proto, parent);
    1:     if (!obj)
    1:         return JS_FALSE;
    1: 
47531:     /* Keep |obj| rooted in case vp[1] is overwritten with a primitive. */
47531:     AutoObjectRooter tvr(cx, obj);
47531: 
    1:     /* Now we have an object with a constructor method; call it. */
52526:     vp[1].setObject(*obj);
52522:     if (!Invoke(cx, args, JSINVOKE_CONSTRUCT))
    1:         return JS_FALSE;
    1: 
    1:     /* Check the return value and if it's primitive, force it to be obj. */
53059:     const Value &rval = *vp;
53059:     if (rval.isPrimitive()) {
    1:         if (!fun) {
    1:             /* native [[Construct]] returning primitive is error */
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_NEW_RESULT,
52522:                                  js_ValueToPrintableString(cx, *vp));
    1:             return JS_FALSE;
    1:         }
52526:         vp->setObject(*obj);
    1:     }
    1: 
    1:     JS_RUNTIME_METER(cx->runtime, constructs);
    1:     return JS_TRUE;
    1: }
    1: 
52528: bool
52534: ValueToId(JSContext *cx, const Value &v, jsid *idp)
    1: {
52528:     int32_t i;
52924:     if (ValueFitsInInt32(v, &i) && INT_FITS_IN_JSID(i)) {
52528:         *idp = INT_TO_JSID(i);
52528:         return true;
52528:     }
    1: 
    1: #if JS_HAS_XML_SUPPORT
52534:     if (v.isObject()) {
53076:         JSObject *obj = &v.toObject();
42693:         if (obj->isXML()) {
52795:             *idp = OBJECT_TO_JSID(obj);
    1:             return JS_TRUE;
    1:         }
52795:         if (!js_IsFunctionQName(cx, obj, idp))
    1:             return JS_FALSE;
52924:         if (!JSID_IS_VOID(*idp))
    1:             return JS_TRUE;
    1:     }
    1: #endif
    1: 
52534:     return js_ValueToStringId(cx, v, idp);
    1: }
    1: 
52522: } /* namespace js */
42641: 
    1: /*
11672:  * Enter the new with scope using an object at sp[-1] and associate the depth
11672:  * of the with block with sp + stackIndex.
11672:  */
22652: JS_STATIC_INTERPRET JS_REQUIRES_STACK JSBool
12551: js_EnterWith(JSContext *cx, jsint stackIndex)
11672: {
52522:     JSStackFrame *fp = cx->fp;
52522:     Value *sp = cx->regs->sp;
52522:     JS_ASSERT(stackIndex < 0);
52522:     JS_ASSERT(fp->base() <= sp + stackIndex);
11672: 
52522:     JSObject *obj;
52522:     if (sp[-1].isObject()) {
53076:         obj = &sp[-1].toObject();
11672:     } else {
11672:         obj = js_ValueToNonNullObject(cx, sp[-1]);
11672:         if (!obj)
    1:             return JS_FALSE;
53059:         sp[-1].setObject(*obj);
11672:     }
11672: 
52522:     JSObject *parent = js_GetScopeChain(cx, fp);
11672:     if (!parent)
11672:         return JS_FALSE;
11672: 
11672:     OBJ_TO_INNER_OBJECT(cx, obj);
11672:     if (!obj)
11672:         return JS_FALSE;
11672: 
52522:     JSObject *withobj = js_NewWithObject(cx, obj, parent,
52522:                                          sp + stackIndex - fp->base());
11672:     if (!withobj)
11672:         return JS_FALSE;
11672: 
11672:     fp->scopeChain = withobj;
    1:     return JS_TRUE;
    1: }
    1: 
22652: JS_STATIC_INTERPRET JS_REQUIRES_STACK void
12551: js_LeaveWith(JSContext *cx)
11672: {
11672:     JSObject *withobj;
11672: 
11672:     withobj = cx->fp->scopeChain;
40826:     JS_ASSERT(withobj->getClass() == &js_WithClass);
42714:     JS_ASSERT(withobj->getPrivate() == js_FloatingFrameIfGenerator(cx, cx->fp));
11758:     JS_ASSERT(OBJ_BLOCK_DEPTH(cx, withobj) >= 0);
39930:     cx->fp->scopeChain = withobj->getParent();
31452:     withobj->setPrivate(NULL);
11672: }
11672: 
52522: JS_REQUIRES_STACK Class *
12551: js_IsActiveWithOrBlock(JSContext *cx, JSObject *obj, int stackDepth)
11758: {
52522:     Class *clasp;
11758: 
40826:     clasp = obj->getClass();
11758:     if ((clasp == &js_WithClass || clasp == &js_BlockClass) &&
42714:         obj->getPrivate() == js_FloatingFrameIfGenerator(cx, cx->fp) &&
11758:         OBJ_BLOCK_DEPTH(cx, obj) >= stackDepth) {
11758:         return clasp;
11758:     }
11758:     return NULL;
11758: }
11758: 
11758: /*
11758:  * Unwind block and scope chains to match the given depth. The function sets
11758:  * fp->sp on return to stackDepth.
11758:  */
42717: JS_STATIC_INTERPRET JS_REQUIRES_STACK JSBool
42717: js_UnwindScope(JSContext *cx, jsint stackDepth, JSBool normalUnwind)
11758: {
11758:     JSObject *obj;
52522:     Class *clasp;
11758: 
11758:     JS_ASSERT(stackDepth >= 0);
52522:     JS_ASSERT(cx->fp->base() + stackDepth <= cx->regs->sp);
11758: 
42717:     JSStackFrame *fp = cx->fp;
39930:     for (obj = fp->blockChain; obj; obj = obj->getParent()) {
40826:         JS_ASSERT(obj->getClass() == &js_BlockClass);
11758:         if (OBJ_BLOCK_DEPTH(cx, obj) < stackDepth)
11758:             break;
11758:     }
11758:     fp->blockChain = obj;
11758: 
11758:     for (;;) {
11758:         obj = fp->scopeChain;
12551:         clasp = js_IsActiveWithOrBlock(cx, obj, stackDepth);
11758:         if (!clasp)
11758:             break;
11758:         if (clasp == &js_BlockClass) {
11758:             /* Don't fail until after we've updated all stacks. */
11859:             normalUnwind &= js_PutBlockObject(cx, normalUnwind);
11758:         } else {
12551:             js_LeaveWith(cx);
11758:         }
11758:     }
11758: 
52522:     cx->regs->sp = fp->base() + stackDepth;
11758:     return normalUnwind;
11758: }
11758: 
15996: JS_STATIC_INTERPRET JSBool
52522: js_DoIncDec(JSContext *cx, const JSCodeSpec *cs, Value *vp, Value *vp2)
12611: {
40828:     if (cs->format & JOF_POST) {
40828:         double d;
52529:         if (!ValueToNumber(cx, *vp, &d))
12611:             return JS_FALSE;
52998:         vp->setNumber(d);
40828:         (cs->format & JOF_INC) ? ++d : --d;
52998:         vp2->setNumber(d);
52597:         return JS_TRUE;
40828:     }
40828: 
40828:     double d;
40828:     if (!ValueToNumber(cx, *vp, &d))
12611:         return JS_FALSE;
40828:     (cs->format & JOF_INC) ? ++d : --d;
52998:     vp->setNumber(d);
52998:     *vp2 = *vp;
12611:     return JS_TRUE;
12611: }
12611: 
52522: const Value &
47573: js_GetUpvar(JSContext *cx, uintN level, UpvarCookie cookie)
27168: {
47573:     level -= cookie.level();
27168:     JS_ASSERT(level < JS_DISPLAY_SIZE);
27168: 
27168:     JSStackFrame *fp = cx->display[level];
27168:     JS_ASSERT(fp->script);
27168: 
47573:     uintN slot = cookie.slot();
52522:     Value *vp;
27168: 
40394:     if (!fp->fun || (fp->flags & JSFRAME_EVAL)) {
42714:         vp = fp->slots() + fp->script->nfixed;
27168:     } else if (slot < fp->fun->nargs) {
27168:         vp = fp->argv;
47573:     } else if (slot == UpvarCookie::CALLEE_SLOT) {
27168:         vp = &fp->argv[-2];
27168:         slot = 0;
27168:     } else {
27168:         slot -= fp->fun->nargs;
27168:         JS_ASSERT(slot < fp->script->nslots);
42714:         vp = fp->slots();
27168:     }
27168: 
27168:     return vp[slot];
27168: }
27168: 
15453: #ifdef DEBUG
15453: 
22652: JS_STATIC_INTERPRET JS_REQUIRES_STACK void
26954: js_TraceOpcode(JSContext *cx)
15453: {
15453:     FILE *tracefp;
15453:     JSStackFrame *fp;
15453:     JSFrameRegs *regs;
15453:     intN ndefs, n, nuses;
15453:     JSString *str;
15453:     JSOp op;
15453: 
15453:     tracefp = (FILE *) cx->tracefp;
15453:     JS_ASSERT(tracefp);
15453:     fp = cx->fp;
42717:     regs = cx->regs;
26954: 
26954:     /*
26954:      * Operations in prologues don't produce interesting values, and
26954:      * js_DecompileValueGenerator isn't set up to handle them anyway.
26954:      */
27233:     if (cx->tracePrevPc && regs->pc >= fp->script->main) {
27233:         JSOp tracePrevOp = JSOp(*cx->tracePrevPc);
27233:         ndefs = js_GetStackDefs(cx, &js_CodeSpec[tracePrevOp], tracePrevOp,
27233:                                 fp->script, cx->tracePrevPc);
26954: 
26954:         /*
32658:          * If there aren't that many elements on the stack, then we have
32658:          * probably entered a new frame, and printing output would just be
32658:          * misleading.
26954:          */
26954:         if (ndefs != 0 &&
42714:             ndefs < regs->sp - fp->slots()) {
15453:             for (n = -ndefs; n < 0; n++) {
52750:                 char *bytes = DecompileValueGenerator(cx, n, regs->sp[n], NULL);
15453:                 if (bytes) {
15453:                     fprintf(tracefp, "%s %s",
15453:                             (n == -ndefs) ? "  output:" : ",",
15453:                             bytes);
30851:                     cx->free(bytes);
41965:                 } else {
41965:                     JS_ClearPendingException(cx);
15453:                 }
15453:             }
52522:             fprintf(tracefp, " @ %u\n", (uintN) (regs->sp - fp->base()));
15453:         }
15453:         fprintf(tracefp, "  stack: ");
52522:         for (Value *siter = fp->base(); siter < regs->sp; siter++) {
15453:             str = js_ValueToString(cx, *siter);
41965:             if (!str) {
15453:                 fputs("<null>", tracefp);
41965:             } else {
41965:                 JS_ClearPendingException(cx);
15453:                 js_FileEscapedString(tracefp, str, 0);
41965:             }
15453:             fputc(' ', tracefp);
15453:         }
15453:         fputc('\n', tracefp);
15453:     }
15453: 
21685:     fprintf(tracefp, "%4u: ",
21685:             js_PCToLineNumber(cx, fp->script, fp->imacpc ? fp->imacpc : regs->pc));
15453:     js_Disassemble1(cx, fp->script, regs->pc,
25144:                     regs->pc - fp->script->code,
15453:                     JS_FALSE, tracefp);
15453:     op = (JSOp) *regs->pc;
26955:     nuses = js_GetStackUses(&js_CodeSpec[op], op, regs->pc);
15453:     if (nuses != 0) {
15453:         for (n = -nuses; n < 0; n++) {
52750:             char *bytes = DecompileValueGenerator(cx, n, regs->sp[n], NULL);
15453:             if (bytes) {
15453:                 fprintf(tracefp, "%s %s",
15453:                         (n == -nuses) ? "  inputs:" : ",",
15453:                         bytes);
30851:                 cx->free(bytes);
41965:             } else {
41965:                 JS_ClearPendingException(cx);
15453:             }
15453:         }
52522:         fprintf(tracefp, " @ %u\n", (uintN) (regs->sp - fp->base()));
15453:     }
27233:     cx->tracePrevPc = regs->pc;
26954: 
26954:     /* It's nice to have complete traces when debugging a crash.  */
26954:     fflush(tracefp);
15453: }
15453: 
15453: #endif /* DEBUG */
15453: 
12551: #ifdef JS_OPMETER
    1: 
    1: # include <stdlib.h>
    1: 
12551: # define HIST_NSLOTS            8
12551: 
    1: /*
    1:  * The second dimension is hardcoded at 256 because we know that many bits fit
    1:  * in a byte, and mainly to optimize away multiplying by JSOP_LIMIT to address
    1:  * any particular row.
    1:  */
    1: static uint32 succeeds[JSOP_LIMIT][256];
    1: static uint32 slot_ops[JSOP_LIMIT][HIST_NSLOTS];
    1: 
15996: JS_STATIC_INTERPRET void
12551: js_MeterOpcodePair(JSOp op1, JSOp op2)
12551: {
12551:     if (op1 != JSOP_STOP)
12551:         ++succeeds[op1][op2];
12551: }
12551: 
15996: JS_STATIC_INTERPRET void
12551: js_MeterSlotOpcode(JSOp op, uint32 slot)
12551: {
12551:     if (slot < HIST_NSLOTS)
12551:         ++slot_ops[op][slot];
12551: }
12551: 
    1: typedef struct Edge {
    1:     const char  *from;
    1:     const char  *to;
    1:     uint32      count;
    1: } Edge;
    1: 
    1: static int
    1: compare_edges(const void *a, const void *b)
    1: {
    1:     const Edge *ea = (const Edge *) a;
    1:     const Edge *eb = (const Edge *) b;
    1: 
    1:     return (int32)eb->count - (int32)ea->count;
    1: }
    1: 
    1: void
    1: js_DumpOpMeters()
    1: {
    1:     const char *name, *from, *style;
    1:     FILE *fp;
    1:     uint32 total, count;
    1:     uint32 i, j, nedges;
    1:     Edge *graph;
    1: 
    1:     name = getenv("JS_OPMETER_FILE");
    1:     if (!name)
    1:         name = "/tmp/ops.dot";
    1:     fp = fopen(name, "w");
    1:     if (!fp) {
    1:         perror(name);
    1:         return;
    1:     }
    1: 
    1:     total = nedges = 0;
    1:     for (i = 0; i < JSOP_LIMIT; i++) {
    1:         for (j = 0; j < JSOP_LIMIT; j++) {
    1:             count = succeeds[i][j];
    1:             if (count != 0) {
    1:                 total += count;
    1:                 ++nedges;
    1:             }
    1:         }
    1:     }
    1: 
    1: # define SIGNIFICANT(count,total) (200. * (count) >= (total))
    1: 
30851:     graph = (Edge *) js_calloc(nedges * sizeof graph[0]);
    1:     for (i = nedges = 0; i < JSOP_LIMIT; i++) {
12410:         from = js_CodeName[i];
    1:         for (j = 0; j < JSOP_LIMIT; j++) {
    1:             count = succeeds[i][j];
    1:             if (count != 0 && SIGNIFICANT(count, total)) {
    1:                 graph[nedges].from = from;
12410:                 graph[nedges].to = js_CodeName[j];
    1:                 graph[nedges].count = count;
    1:                 ++nedges;
    1:             }
    1:         }
    1:     }
    1:     qsort(graph, nedges, sizeof(Edge), compare_edges);
    1: 
    1: # undef SIGNIFICANT
    1: 
    1:     fputs("digraph {\n", fp);
    1:     for (i = 0, style = NULL; i < nedges; i++) {
    1:         JS_ASSERT(i == 0 || graph[i-1].count >= graph[i].count);
    1:         if (!style || graph[i-1].count != graph[i].count) {
    1:             style = (i > nedges * .75) ? "dotted" :
    1:                     (i > nedges * .50) ? "dashed" :
    1:                     (i > nedges * .25) ? "solid" : "bold";
    1:         }
    1:         fprintf(fp, "  %s -> %s [label=\"%lu\" style=%s]\n",
    1:                 graph[i].from, graph[i].to,
    1:                 (unsigned long)graph[i].count, style);
    1:     }
30851:     js_free(graph);
    1:     fputs("}\n", fp);
    1:     fclose(fp);
    1: 
    1:     name = getenv("JS_OPMETER_HIST");
    1:     if (!name)
    1:         name = "/tmp/ops.hist";
    1:     fp = fopen(name, "w");
    1:     if (!fp) {
    1:         perror(name);
    1:         return;
    1:     }
    1:     fputs("bytecode", fp);
    1:     for (j = 0; j < HIST_NSLOTS; j++)
    1:         fprintf(fp, "  slot %1u", (unsigned)j);
    1:     putc('\n', fp);
    1:     fputs("========", fp);
    1:     for (j = 0; j < HIST_NSLOTS; j++)
    1:         fputs(" =======", fp);
    1:     putc('\n', fp);
    1:     for (i = 0; i < JSOP_LIMIT; i++) {
    1:         for (j = 0; j < HIST_NSLOTS; j++) {
    1:             if (slot_ops[i][j] != 0) {
    1:                 /* Reuse j in the next loop, since we break after. */
12410:                 fprintf(fp, "%-8.8s", js_CodeName[i]);
    1:                 for (j = 0; j < HIST_NSLOTS; j++)
    1:                     fprintf(fp, " %7lu", (unsigned long)slot_ops[i][j]);
    1:                 putc('\n', fp);
    1:                 break;
    1:             }
    1:         }
    1:     }
    1:     fclose(fp);
    1: }
    1: 
    1: #endif /* JS_OPSMETER */
    1: 
15996: #endif /* !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___ */
15996: 
15996: #ifndef  jsinvoke_cpp___
12551: 
39932: #ifdef JS_REPRMETER
39932: // jsval representation metering: this measures the kinds of jsvals that
39932: // are used as inputs to each JSOp.
39932: namespace reprmeter {
39932:     enum Repr {
39932:         NONE,
39932:         INT,
39932:         DOUBLE,
39932:         BOOLEAN_PROPER,
39932:         BOOLEAN_OTHER,
39932:         STRING,
39932:         OBJECT_NULL,
39932:         OBJECT_PLAIN,
39932:         FUNCTION_INTERPRETED,
39932:         FUNCTION_FASTNATIVE,
39932:         FUNCTION_SLOWNATIVE,
39932:         ARRAY_SLOW,
39932:         ARRAY_DENSE
39932:     };
39932: 
39932:     // Return the |repr| value giving the representation of the given jsval.
39932:     static Repr
39932:     GetRepr(jsval v)
39932:     {
39932:         if (JSVAL_IS_INT(v))
39932:             return INT;
39932:         if (JSVAL_IS_DOUBLE(v))
39932:             return DOUBLE;
39932:         if (JSVAL_IS_SPECIAL(v)) {
39932:             return (v == JSVAL_TRUE || v == JSVAL_FALSE)
39932:                    ? BOOLEAN_PROPER
39932:                    : BOOLEAN_OTHER;
39932:         }
39932:         if (JSVAL_IS_STRING(v))
39932:             return STRING;
39932: 
39932:         JS_ASSERT(JSVAL_IS_OBJECT(v));
39932: 
39932:         JSObject *obj = JSVAL_TO_OBJECT(v);
39932:         if (VALUE_IS_FUNCTION(cx, v)) {
39932:             JSFunction *fun = GET_FUNCTION_PRIVATE(cx, obj);
39932:             if (FUN_INTERPRETED(fun))
39932:                 return FUNCTION_INTERPRETED;
39932:             if (fun->flags & JSFUN_FAST_NATIVE)
39932:                 return FUNCTION_FASTNATIVE;
39932:             return FUNCTION_SLOWNATIVE;
39932:         }
39932:         // This must come before the general array test, because that
39932:         // one subsumes this one.
39932:         if (!obj)
39932:             return OBJECT_NULL;
39932:         if (obj->isDenseArray())
39932:             return ARRAY_DENSE;
39932:         if (obj->isArray())
39932:             return ARRAY_SLOW;
39932:         return OBJECT_PLAIN;
39932:     }
39932: 
39932:     static const char *reprName[] = { "invalid", "int", "double", "bool", "special",
39932:                                       "string", "null", "object", 
39932:                                       "fun:interp", "fun:fast", "fun:slow",
39932:                                       "array:slow", "array:dense" };
39932: 
39932:     // Logically, a tuple of (JSOp, repr_1, ..., repr_n) where repr_i is
39932:     // the |repr| of the ith input to the JSOp.
39932:     struct OpInput {
39932:         enum { max_uses = 16 };
39932: 
39932:         JSOp op;
39932:         Repr uses[max_uses];
39932: 
39932:         OpInput() : op(JSOp(255)) {
39932:             for (int i = 0; i < max_uses; ++i)
39932:                 uses[i] = NONE;
39932:         }
39932: 
39932:         OpInput(JSOp op) : op(op) {
39932:             for (int i = 0; i < max_uses; ++i)
39932:                 uses[i] = NONE;
39932:         }
39932: 
39932:         // Hash function
39932:         operator uint32() const {
39932:             uint32 h = op;
39932:             for (int i = 0; i < max_uses; ++i)
39932:                 h = h * 7 + uses[i] * 13;
39932:             return h;
39932:         }
39932: 
39932:         bool operator==(const OpInput &opinput) const {
39932:             if (op != opinput.op)
39932:                 return false;
39932:             for (int i = 0; i < max_uses; ++i) {
39932:                 if (uses[i] != opinput.uses[i])
39932:                     return false;
39932:             }
39932:             return true;
39932:         }
39932: 
39932:         OpInput &operator=(const OpInput &opinput) {
39932:             op = opinput.op;
39932:             for (int i = 0; i < max_uses; ++i)
39932:                 uses[i] = opinput.uses[i];
39932:             return *this;
39932:         }
39932:     };
39932: 
39932:     typedef HashMap<OpInput, uint64, DefaultHasher<OpInput>, SystemAllocPolicy> OpInputHistogram;
39932: 
39932:     OpInputHistogram opinputs;
39932:     bool             opinputsInitialized = false;
39932: 
39932:     // Record an OpInput for the current op. This should be called just
39932:     // before executing the op.
39932:     static void
42748:     MeterRepr(JSContext *cx)
39932:     {
39932:         // Note that we simply ignore the possibility of errors (OOMs)
39932:         // using the hash map, since this is only metering code.
39932: 
39932:         if (!opinputsInitialized) {
39932:             opinputs.init();
39932:             opinputsInitialized = true;
39932:         }
39932: 
42748:         JSOp op = JSOp(*cx->regs->pc);
42748:         int nuses = js_GetStackUses(&js_CodeSpec[op], op, cx->regs->pc);
39932: 
39932:         // Build the OpInput.
39932:         OpInput opinput(op);
42748:         for (int i = 0; i < nuses; ++i) {
42748:             jsval v = cx->regs->sp[-nuses+i];
39932:             opinput.uses[i] = GetRepr(v);
39932:         }
39932: 
39932:         OpInputHistogram::AddPtr p = opinputs.lookupForAdd(opinput);
39932:         if (p)
39932:             ++p->value;
39932:         else
39932:             opinputs.add(p, opinput, 1);
39932:     }
39932: 
39932:     void
39932:     js_DumpReprMeter()
39932:     {
39932:         FILE *f = fopen("/tmp/reprmeter.txt", "w");
39932:         JS_ASSERT(f);
39932:         for (OpInputHistogram::Range r = opinputs.all(); !r.empty(); r.popFront()) {
39932:             const OpInput &o = r.front().key;
39932:             uint64 c = r.front().value;
39932:             fprintf(f, "%3d,%s", o.op, js_CodeName[o.op]);
39932:             for (int i = 0; i < OpInput::max_uses && o.uses[i] != NONE; ++i)
39932:                 fprintf(f, ",%s", reprName[o.uses[i]]);
39932:             fprintf(f, ",%llu\n", c);
39932:         }
39932:         fclose(f);
39932:     }
39932: }
39932: #endif /* JS_REPRMETER */
39932: 
52536: #define PUSH_COPY(v)             *regs.sp++ = v
52522: #define PUSH_NULL()              regs.sp++->setNull()
52522: #define PUSH_UNDEFINED()         regs.sp++->setUndefined()
52522: #define PUSH_BOOLEAN(b)          regs.sp++->setBoolean(b)
52539: #define PUSH_DOUBLE(d)           regs.sp++->setDouble(d)
52522: #define PUSH_INT32(i)            regs.sp++->setInt32(i)
52522: #define PUSH_STRING(s)           regs.sp++->setString(s)
52526: #define PUSH_OBJECT(obj)         regs.sp++->setObject(obj)
52526: #define PUSH_OBJECT_OR_NULL(obj) regs.sp++->setObject(obj)
52522: #define PUSH_HOLE()              regs.sp++->setMagic(JS_ARRAY_HOLE)
52536: #define POP_COPY_TO(v)           v = *--regs.sp
12551: 
52522: #define POP_BOOLEAN(cx, vp, b)                                                \
12551:     JS_BEGIN_MACRO                                                            \
52522:         vp = &regs.sp[-1];                                                    \
52522:         if (vp->isNull()) {                                                   \
52522:             b = false;                                                        \
52522:         } else if (vp->isBoolean()) {                                         \
53076:             b = vp->toBoolean();                                              \
12551:         } else {                                                              \
52562:             b = !!js_ValueToBoolean(*vp);                                     \
12551:         }                                                                     \
13168:         regs.sp--;                                                            \
12551:     JS_END_MACRO
12551: 
52522: #define VALUE_TO_OBJECT(cx, vp, obj)                                          \
12551:     JS_BEGIN_MACRO                                                            \
52522:         if ((vp)->isObject()) {                                               \
53076:             obj = &(vp)->toObject();                                          \
12551:         } else {                                                              \
53059:             obj = js_ValueToNonNullObject(cx, *(vp));                         \
12551:             if (!obj)                                                         \
12551:                 goto error;                                                   \
53059:             (vp)->setObject(*obj);                                            \
12551:         }                                                                     \
12551:     JS_END_MACRO
12551: 
52522: #define FETCH_OBJECT(cx, n, obj)                                              \
12551:     JS_BEGIN_MACRO                                                            \
52522:         Value *vp_ = &regs.sp[n];                                             \
52522:         VALUE_TO_OBJECT(cx, vp_, obj);                                        \
12551:     JS_END_MACRO
12551: 
12551: #define DEFAULT_VALUE(cx, n, hint, v)                                         \
12551:     JS_BEGIN_MACRO                                                            \
52634:         JS_ASSERT(v.isObject());                                              \
13168:         JS_ASSERT(v == regs.sp[n]);                                           \
53076:         if (!v.toObject().defaultValue(cx, hint, &regs.sp[n]))                \
12551:             goto error;                                                       \
13168:         v = regs.sp[n];                                                       \
12551:     JS_END_MACRO
12551: 
52522: /* Test whether v is an int in the range [-2^31 + 1, 2^31 - 2] */
52522: static JS_ALWAYS_INLINE bool
52542: CanIncDecWithoutOverflow(int32_t i)
52522: {
52548:     return (i > JSVAL_INT_MIN) && (i < JSVAL_INT_MAX);
52522: }
12611: 
12611: /*
12551:  * Conditional assert to detect failure to clear a pending exception that is
12551:  * suppressed (or unintentional suppression of a wanted exception).
12551:  */
12551: #if defined DEBUG_brendan || defined DEBUG_mrbkap || defined DEBUG_shaver
12551: # define DEBUG_NOT_THROWING 1
12551: #endif
12551: 
12551: #ifdef DEBUG_NOT_THROWING
12551: # define ASSERT_NOT_THROWING(cx) JS_ASSERT(!(cx)->throwing)
    1: #else
12551: # define ASSERT_NOT_THROWING(cx) /* nothing */
    1: #endif
12551: 
12551: /*
12551:  * Define JS_OPMETER to instrument bytecode succession, generating a .dot file
12551:  * on shutdown that shows the graph of significant predecessor/successor pairs
12551:  * executed, where the edge labels give the succession counts.  The .dot file
12551:  * is named by the JS_OPMETER_FILE envariable, and defaults to /tmp/ops.dot.
12551:  *
12551:  * Bonus feature: JS_OPMETER also enables counters for stack-addressing ops
16429:  * such as JSOP_GETLOCAL, JSOP_INCARG, via METER_SLOT_OP. The resulting counts
12551:  * are written to JS_OPMETER_HIST, defaulting to /tmp/ops.hist.
12551:  */
12551: #ifndef JS_OPMETER
12551: # define METER_OP_INIT(op)      /* nothing */
12551: # define METER_OP_PAIR(op1,op2) /* nothing */
12551: # define METER_SLOT_OP(op,slot) /* nothing */
12551: #else
12551: 
12551: /*
12551:  * The second dimension is hardcoded at 256 because we know that many bits fit
12551:  * in a byte, and mainly to optimize away multiplying by JSOP_LIMIT to address
12551:  * any particular row.
12551:  */
12551: # define METER_OP_INIT(op)      ((op) = JSOP_STOP)
12551: # define METER_OP_PAIR(op1,op2) (js_MeterOpcodePair(op1, op2))
12551: # define METER_SLOT_OP(op,slot) (js_MeterSlotOpcode(op, slot))
12551: 
    1: #endif
    1: 
39932: #ifdef JS_REPRMETER
42748: # define METER_REPR(cx)         (reprmeter::MeterRepr(cx))
39932: #else
42748: # define METER_REPR(cx)         ((void) 0)
39932: #endif /* JS_REPRMETER */
39932: 
    1: /*
    1:  * Threaded interpretation via computed goto appears to be well-supported by
    1:  * GCC 3 and higher.  IBM's C compiler when run with the right options (e.g.,
    1:  * -qlanglvl=extended) also supports threading.  Ditto the SunPro C compiler.
    1:  * Currently it's broken for JS_VERSION < 160, though this isn't worth fixing.
    1:  * Add your compiler support macros here.
    1:  */
    1: #ifndef JS_THREADED_INTERP
    1: # if JS_VERSION >= 160 && (                                                   \
    1:     __GNUC__ >= 3 ||                                                          \
    1:     (__IBMC__ >= 700 && defined __IBM_COMPUTED_GOTO) ||                       \
    1:     __SUNPRO_C >= 0x570)
    1: #  define JS_THREADED_INTERP 1
    1: # else
    1: #  define JS_THREADED_INTERP 0
    1: # endif
    1: #endif
    1: 
15453: /*
27164:  * Deadlocks or else bad races are likely if JS_THREADSAFE, so we must rely on
27164:  * single-thread DEBUG js shell testing to verify property cache hits.
27164:  */
27164: #if defined DEBUG && !defined JS_THREADSAFE
27164: 
27164: # define ASSERT_VALID_PROPERTY_CACHE_HIT(pcoff,obj,pobj,entry)                \
27164:     JS_BEGIN_MACRO                                                            \
27164:         if (!AssertValidPropertyCacheHit(cx, script, regs, pcoff, obj, pobj,  \
27164:                                          entry)) {                            \
27164:             goto error;                                                       \
27164:         }                                                                     \
27164:     JS_END_MACRO
27164: 
27164: static bool
27164: AssertValidPropertyCacheHit(JSContext *cx, JSScript *script, JSFrameRegs& regs,
27164:                             ptrdiff_t pcoff, JSObject *start, JSObject *found,
40362:                             PropertyCacheEntry *entry)
27164: {
27164:     uint32 sample = cx->runtime->gcNumber;
27164: 
27164:     JSAtom *atom;
27164:     if (pcoff >= 0)
27164:         GET_ATOM_FROM_BYTECODE(script, regs.pc, pcoff, atom);
27164:     else
27164:         atom = cx->runtime->atomState.lengthAtom;
27164: 
27164:     JSObject *obj, *pobj;
27164:     JSProperty *prop;
33166:     JSBool ok;
27164: 
27164:     if (JOF_OPMODE(*regs.pc) == JOF_NAME) {
27164:         ok = js_FindProperty(cx, ATOM_TO_JSID(atom), &obj, &pobj, &prop);
27164:     } else {
27164:         obj = start;
27164:         ok = js_LookupProperty(cx, obj, ATOM_TO_JSID(atom), &pobj, &prop);
27164:     }
27164:     if (!ok)
27164:         return false;
40847:     if (cx->runtime->gcNumber != sample || entry->vshape() != pobj->shape()) {
31501:         pobj->dropProperty(cx, prop);
27164:         return true;
27164:     }
27164:     JS_ASSERT(prop);
27164:     JS_ASSERT(pobj == found);
27164: 
27164:     JSScopeProperty *sprop = (JSScopeProperty *) prop;
40374:     if (entry->vword.isSlot()) {
40374:         JS_ASSERT(entry->vword.toSlot() == sprop->slot);
32658:         JS_ASSERT(!sprop->isMethod());
40374:     } else if (entry->vword.isSprop()) {
40374:         JS_ASSERT(entry->vword.toSprop() == sprop);
32658:         JS_ASSERT_IF(sprop->isMethod(),
53076:                      &sprop->methodObject() == &pobj->lockedGetSlot(sprop->slot).toObject());
27164:     } else {
52522:         Value v;
52522:         JS_ASSERT(entry->vword.isFunObj());
40374:         JS_ASSERT(!entry->vword.isNull());
40847:         JS_ASSERT(pobj->scope()->brandedOrHasMethodBarrier());
40265:         JS_ASSERT(sprop->hasDefaultGetterOrIsMethod());
40847:         JS_ASSERT(SPROP_HAS_VALID_SLOT(sprop, pobj->scope()));
40847:         v = pobj->lockedGetSlot(sprop->slot);
53076:         JS_ASSERT(&entry->vword.toFunObj() == &v.toObject());
32658: 
32658:         if (sprop->isMethod()) {
32658:             JS_ASSERT(js_CodeSpec[*regs.pc].format & JOF_CALLOP);
53076:             JS_ASSERT(&sprop->methodObject() == &v.toObject());
32658:         }
27164:     }
27164: 
31501:     pobj->dropProperty(cx, prop);
27164:     return true;
27164: }
27164: 
27164: #else
27164: # define ASSERT_VALID_PROPERTY_CACHE_HIT(pcoff,obj,pobj,entry) ((void) 0)
27164: #endif
27164: 
27164: /*
    1:  * Ensure that the intrepreter switch can close call-bytecode cases in the
    1:  * same way as non-call bytecodes.
    1:  */
    1: JS_STATIC_ASSERT(JSOP_NAME_LENGTH == JSOP_CALLNAME_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETGVAR_LENGTH == JSOP_CALLGVAR_LENGTH);
18308: JS_STATIC_ASSERT(JSOP_GETUPVAR_LENGTH == JSOP_CALLUPVAR_LENGTH);
28952: JS_STATIC_ASSERT(JSOP_GETUPVAR_DBG_LENGTH == JSOP_CALLUPVAR_DBG_LENGTH);
28952: JS_STATIC_ASSERT(JSOP_GETUPVAR_DBG_LENGTH == JSOP_GETUPVAR_LENGTH);
27012: JS_STATIC_ASSERT(JSOP_GETDSLOT_LENGTH == JSOP_CALLDSLOT_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETARG_LENGTH == JSOP_CALLARG_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETLOCAL_LENGTH == JSOP_CALLLOCAL_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_XMLNAME_LENGTH == JSOP_CALLXMLNAME_LENGTH);
    1: 
11377: /*
28952:  * Same for debuggable flat closures defined at top level in another function
28952:  * or program fragment.
28952:  */
28952: JS_STATIC_ASSERT(JSOP_DEFFUN_FC_LENGTH == JSOP_DEFFUN_DBGFC_LENGTH);
28952: 
28952: /*
11377:  * Same for JSOP_SETNAME and JSOP_SETPROP, which differ only slightly but
32658:  * remain distinct for the decompiler. Likewise for JSOP_INIT{PROP,METHOD}.
11377:  */
11377: JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETPROP_LENGTH);
32658: JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETMETHOD_LENGTH);
32658: JS_STATIC_ASSERT(JSOP_INITPROP_LENGTH == JSOP_INITMETHOD_LENGTH);
11377: 
15464: /* See TRY_BRANCH_AFTER_COND. */
15464: JS_STATIC_ASSERT(JSOP_IFNE_LENGTH == JSOP_IFEQ_LENGTH);
15464: JS_STATIC_ASSERT(JSOP_IFNE == JSOP_IFEQ + 1);
15464: 
16051: /* For the fastest case inder JSOP_INCNAME, etc. */
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_DECNAME_LENGTH);
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_NAMEINC_LENGTH);
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_NAMEDEC_LENGTH);
16051: 
27479: #ifdef JS_TRACER
27479: # define ABORT_RECORDING(cx, reason)                                          \
27479:     JS_BEGIN_MACRO                                                            \
27479:         if (TRACE_RECORDER(cx))                                               \
37741:             AbortRecording(cx, reason);                                       \
27479:     JS_END_MACRO
27479: #else
27464: # define ABORT_RECORDING(cx, reason)    ((void) 0)
27479: #endif
27479: 
42641: /*
42641:  * Inline fast paths for iteration. js_IteratorMore and js_IteratorNext handle
42641:  * all cases, but we inline the most frequently taken paths here.
42641:  */
42641: static inline bool
52524: IteratorMore(JSContext *cx, JSObject *iterobj, bool *cond, Value *rval)
42641: {
42641:     if (iterobj->getClass() == &js_IteratorClass.base) {
42641:         NativeIterator *ni = (NativeIterator *) iterobj->getPrivate();
42641:         *cond = (ni->props_cursor < ni->props_end);
42641:     } else {
42641:         if (!js_IteratorMore(cx, iterobj, rval))
42641:             return false;
52532:         *cond = rval->isTrue();
42641:     }
42641:     return true;
42641: }
42641: 
42641: static inline bool
52524: IteratorNext(JSContext *cx, JSObject *iterobj, Value *rval)
42641: {
42641:     if (iterobj->getClass() == &js_IteratorClass.base) {
42641:         NativeIterator *ni = (NativeIterator *) iterobj->getPrivate();
42641:         JS_ASSERT(ni->props_cursor < ni->props_end);
53059:         if (ni->isKeyIter()) {
53059:             jsid id = *ni->currentKey();
52924:             if (JSID_IS_ATOM(id)) {
52924:                 rval->setString(JSID_TO_STRING(id));
53059:                 ni->incKeyCursor();
42641:                 return true;
42641:             }
42641:             /* Take the slow path if we have to stringify a numeric property name. */
52924:         } else {
53059:             *rval = *ni->currentValue();
52924:             ni->incValueCursor();
52924:             return true;
52924:         }
42641:     }
42641:     return js_IteratorNext(cx, iterobj, rval);
42641: }
42641: 
52523: 
52522: namespace js {
52522: 
52522: JS_REQUIRES_STACK bool
52522: Interpret(JSContext *cx)
    1: {
29368: #ifdef MOZ_TRACEVIS
31063:     TraceVisStateObj tvso(cx, S_INTERP);
29368: #endif
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_INFER);
    1: 
26954: # ifdef DEBUG
26954:     /*
26954:      * We call this macro from BEGIN_CASE in threaded interpreters,
26954:      * and before entering the switch in non-threaded interpreters.
26954:      * However, reaching such points doesn't mean we've actually
26954:      * fetched an OP from the instruction stream: some opcodes use
26954:      * 'op=x; DO_OP()' to let another opcode's implementation finish
26954:      * their work, and many opcodes share entry points with a run of
26954:      * consecutive BEGIN_CASEs.
26954:      *
26954:      * Take care to trace OP only when it is the opcode fetched from
26954:      * the instruction stream, so the trace matches what one would
26954:      * expect from looking at the code.  (We do omit POPs after SETs;
26954:      * unfortunate, but not worth fixing.)
26954:      */
26954: #  define TRACE_OPCODE(OP)  JS_BEGIN_MACRO                                    \
26954:                                 if (JS_UNLIKELY(cx->tracefp != NULL) &&       \
26954:                                     (OP) == *regs.pc)                         \
26954:                                     js_TraceOpcode(cx);                       \
26954:                             JS_END_MACRO
26954: # else
26954: #  define TRACE_OPCODE(OP)  ((void) 0)
26954: # endif
26954: 
52522:     /*
52522:      * Macros for threaded interpreter loop
52522:      */
    1: #if JS_THREADED_INTERP
15510:     static void *const normalJumpTable[] = {
    1: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
    1:         JS_EXTENSION &&L_##op,
    1: # include "jsopcode.tbl"
    1: # undef OPDEF
    1:     };
    1: 
23111:     static void *const interruptJumpTable[] = {
17408: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format)              \
23111:         JS_EXTENSION &&interrupt,
17408: # include "jsopcode.tbl"
17408: # undef OPDEF
17408:     };
23111: 
23111:     register void * const *jumpTable = normalJumpTable;
    1: 
    1:     METER_OP_INIT(op);      /* to nullify first METER_OP_PAIR */
    1: 
23111: # define ENABLE_INTERRUPTS() ((void) (jumpTable = interruptJumpTable))
23111: 
18171: # ifdef JS_TRACER
23111: #  define CHECK_RECORDER()                                                    \
23111:     JS_ASSERT_IF(TRACE_RECORDER(cx), jumpTable == interruptJumpTable)
18171: # else
18171: #  define CHECK_RECORDER()  ((void)0)
18171: # endif
18171: 
18171: # define DO_OP()            JS_BEGIN_MACRO                                    \
18171:                                 CHECK_RECORDER();                             \
18161:                                 JS_EXTENSION_(goto *jumpTable[op]);           \
18161:                             JS_END_MACRO
15453: # define DO_NEXT_OP(n)      JS_BEGIN_MACRO                                    \
39923:                                 METER_OP_PAIR(op, JSOp(regs.pc[n]));          \
13168:                                 op = (JSOp) *(regs.pc += (n));                \
42748:                                 METER_REPR(cx);                               \
15453:                                 DO_OP();                                      \
15453:                             JS_END_MACRO
15453: 
24497: # define BEGIN_CASE(OP)     L_##OP: TRACE_OPCODE(OP); CHECK_RECORDER();
    1: # define END_CASE(OP)       DO_NEXT_OP(OP##_LENGTH);
    1: # define END_VARLEN_CASE    DO_NEXT_OP(len);
15453: # define ADD_EMPTY_CASE(OP) BEGIN_CASE(OP)                                    \
15453:                                 JS_ASSERT(js_CodeSpec[OP].length == 1);       \
15453:                                 op = (JSOp) *++regs.pc;                       \
15453:                                 DO_OP();
15453: 
15453: # define END_EMPTY_CASES
15453: 
15453: #else /* !JS_THREADED_INTERP */
15453: 
23111:     register intN switchMask = 0;
23111:     intN switchOp;
23111: 
23111: # define ENABLE_INTERRUPTS() ((void) (switchMask = -1))
23111: 
23111: # ifdef JS_TRACER
23111: #  define CHECK_RECORDER()                                                    \
23111:     JS_ASSERT_IF(TRACE_RECORDER(cx), switchMask == -1)
23111: # else
23111: #  define CHECK_RECORDER()  ((void)0)
23111: # endif
23111: 
    1: # define DO_OP()            goto do_op
15453: # define DO_NEXT_OP(n)      JS_BEGIN_MACRO                                    \
15453:                                 JS_ASSERT((n) == len);                        \
15453:                                 goto advance_pc;                              \
15453:                             JS_END_MACRO
15453: 
23111: # define BEGIN_CASE(OP)     case OP: CHECK_RECORDER();
15453: # define END_CASE(OP)       END_CASE_LEN(OP##_LENGTH)
15453: # define END_CASE_LEN(n)    END_CASE_LENX(n)
15453: # define END_CASE_LENX(n)   END_CASE_LEN##n
15453: 
15453: /*
15453:  * To share the code for all len == 1 cases we use the specialized label with
15453:  * code that falls through to advance_pc: .
15453:  */
15453: # define END_CASE_LEN1      goto advance_pc_by_one;
15453: # define END_CASE_LEN2      len = 2; goto advance_pc;
15453: # define END_CASE_LEN3      len = 3; goto advance_pc;
15453: # define END_CASE_LEN4      len = 4; goto advance_pc;
15453: # define END_CASE_LEN5      len = 5; goto advance_pc;
15453: # define END_VARLEN_CASE    goto advance_pc;
15453: # define ADD_EMPTY_CASE(OP) BEGIN_CASE(OP)
15453: # define END_EMPTY_CASES    goto advance_pc_by_one;
15453: 
18617: #endif /* !JS_THREADED_INTERP */
18617: 
15453:     /* Check for too deep of a native thread stack. */
11758:     JS_CHECK_RECURSION(cx, return JS_FALSE);
11758: 
52522:     JSRuntime *const rt = cx->runtime;
    1: 
    1:     /* Set registerized frame pointer and derived script pointer. */
52522:     JSStackFrame *fp = cx->fp;
52522:     JSScript *script = fp->script;
34290:     JS_ASSERT(!script->isEmpty());
34290:     JS_ASSERT(script->length > 1);
    1: 
52522:     /* Count of JS function calls that nest in this C Interpret frame. */
52522:     uintN inlineCallCount = 0;
    1: 
 3235:     /*
 3235:      * Initialize the index segment register used by LOAD_ATOM and
17454:      * GET_FULL_INDEX macros below. As a register we use a pointer based on
 3235:      * the atom map to turn frequently executed LOAD_ATOM into simple array
 3235:      * access. For less frequent object and regexp loads we have to recover
 3235:      * the segment from atoms pointer first.
 3235:      */
52522:     JSAtom **atoms = script->atomMap.vector;
    1: 
52525: #define LOAD_ATOM(PCOFF, atom)                                                \
 3235:     JS_BEGIN_MACRO                                                            \
21685:         JS_ASSERT(fp->imacpc                                                  \
21685:                   ? atoms == COMMON_ATOMS_START(&rt->atomState) &&            \
21685:                     GET_INDEX(regs.pc + PCOFF) < js_common_atom_count         \
21685:                   : (size_t)(atoms - script->atomMap.vector) <                \
13168:                     (size_t)(script->atomMap.length -                         \
13168:                              GET_INDEX(regs.pc + PCOFF)));                    \
13168:         atom = atoms[GET_INDEX(regs.pc + PCOFF)];                             \
 3235:     JS_END_MACRO
 3235: 
 3235: #define GET_FULL_INDEX(PCOFF)                                                 \
13168:     (atoms - script->atomMap.vector + GET_INDEX(regs.pc + PCOFF))
 3235: 
52525: #define LOAD_OBJECT(PCOFF, obj)                                               \
32723:     (obj = script->getObject(GET_FULL_INDEX(PCOFF)))
 3235: 
 3235: #define LOAD_FUNCTION(PCOFF)                                                  \
32723:     (fun = script->getFunction(GET_FULL_INDEX(PCOFF)))
    1: 
52682: #define LOAD_DOUBLE(PCOFF, dbl)                                               \
53076:     (dbl = script->getConst(GET_FULL_INDEX(PCOFF)).toDouble())
52682: 
17598: #ifdef JS_TRACER
17598: 
29368: #ifdef MOZ_TRACEVIS
31063: #if JS_THREADED_INTERP
29368: #define MONITOR_BRANCH_TRACEVIS                                               \
29368:     JS_BEGIN_MACRO                                                            \
29368:         if (jumpTable != interruptJumpTable)                                  \
38585:             EnterTraceVisState(cx, S_RECORD, R_NONE);                         \
29368:     JS_END_MACRO
31063: #else /* !JS_THREADED_INTERP */
31063: #define MONITOR_BRANCH_TRACEVIS                                               \
31063:     JS_BEGIN_MACRO                                                            \
38585:         EnterTraceVisState(cx, S_RECORD, R_NONE);                             \
31063:     JS_END_MACRO
31063: #endif
29368: #else
29368: #define MONITOR_BRANCH_TRACEVIS
29368: #endif
29368: 
33564: #define RESTORE_INTERP_VARS()                                                 \
17410:     JS_BEGIN_MACRO                                                            \
17923:         fp = cx->fp;                                                          \
17923:         script = fp->script;                                                  \
24293:         atoms = FrameAtomBase(cx, fp);                                        \
17923:         currentVersion = (JSVersion) script->version;                         \
42717:         JS_ASSERT(cx->regs == &regs);                                         \
52525:         if (cx->throwing)                                                     \
52525:             goto error;                                                       \
33564:     JS_END_MACRO
33564: 
33564: #define MONITOR_BRANCH(reason)                                                \
33564:     JS_BEGIN_MACRO                                                            \
33564:         if (TRACING_ENABLED(cx)) {                                            \
41777:             MonitorResult r = MonitorLoopEdge(cx, inlineCallCount, reason);   \
41777:             if (r == MONITOR_RECORDING) {                                     \
33564:                 JS_ASSERT(TRACE_RECORDER(cx));                                \
33564:                 MONITOR_BRANCH_TRACEVIS;                                      \
33564:                 ENABLE_INTERRUPTS();                                          \
33564:             }                                                                 \
33564:             RESTORE_INTERP_VARS();                                            \
41777:             JS_ASSERT_IF(cx->throwing, r == MONITOR_ERROR);                   \
41777:             if (r == MONITOR_ERROR)                                           \
41777:                 goto error;                                                   \
17923:         }                                                                     \
17410:     JS_END_MACRO
17410: 
17598: #else /* !JS_TRACER */
17598: 
33564: #define MONITOR_BRANCH(reason) ((void) 0)
17598: 
17598: #endif /* !JS_TRACER */
17598: 
    1:     /*
11758:      * Prepare to call a user-supplied branch handler, and abort the script
11758:      * if it returns false.
11758:      */
17410: #define CHECK_BRANCH()                                                        \
 3235:     JS_BEGIN_MACRO                                                            \
25087:         if (!JS_CHECK_OPERATION_LIMIT(cx))                                    \
11859:             goto error;                                                       \
 3235:     JS_END_MACRO
23442: 
27038: #ifndef TRACE_RECORDER
27038: #define TRACE_RECORDER(cx) (false)
27038: #endif
27038: 
17410: #define BRANCH(n)                                                             \
17410:     JS_BEGIN_MACRO                                                            \
25627:         regs.pc += (n);                                                       \
25627:         op = (JSOp) *regs.pc;                                                 \
26375:         if ((n) <= 0) {                                                       \
26375:             CHECK_BRANCH();                                                   \
25627:             if (op == JSOP_NOP) {                                             \
27038:                 if (TRACE_RECORDER(cx)) {                                     \
34351:                     MONITOR_BRANCH(Record_Branch);                            \
27038:                     op = (JSOp) *regs.pc;                                     \
27038:                 } else {                                                      \
25627:                     op = (JSOp) *++regs.pc;                                   \
27038:                 }                                                             \
32776:             } else if (op == JSOP_TRACE) {                                    \
34351:                 MONITOR_BRANCH(Record_Branch);                                \
25627:                 op = (JSOp) *regs.pc;                                         \
17410:             }                                                                 \
26375:         }                                                                     \
17611:         DO_OP();                                                              \
17410:     JS_END_MACRO
16072: 
18989:     MUST_FLOW_THROUGH("exit");
18308:     ++cx->interpLevel;
18308: 
18308:     /*
    1:      * Optimized Get and SetVersion for proper script language versioning.
    1:      *
52522:      * If any native method or Class/JSObjectOps hook calls js_SetVersion
    1:      * and changes cx->version, the effect will "stick" and we will stop
    1:      * maintaining currentVersion.  This is relied upon by testsuites, for
    1:      * the most part -- web browsers select version before compiling and not
    1:      * at run-time.
    1:      */
52522:     JSVersion currentVersion = (JSVersion) script->version;
52522:     JSVersion originalVersion = (JSVersion) cx->version;
    1:     if (currentVersion != originalVersion)
    1:         js_SetVersion(cx, currentVersion);
    1: 
18308:     /* Update the static-link display. */
27012:     if (script->staticLevel < JS_DISPLAY_SIZE) {
27012:         JSStackFrame **disp = &cx->display[script->staticLevel];
18308:         fp->displaySave = *disp;
18308:         *disp = fp;
18308:     }
    1: 
23111: #define CHECK_INTERRUPT_HANDLER()                                             \
23111:     JS_BEGIN_MACRO                                                            \
41863:         if (cx->debugHooks->interruptHook)                                    \
23111:             ENABLE_INTERRUPTS();                                              \
23111:     JS_END_MACRO
23111: 
    1:     /*
    1:      * Load the debugger's interrupt hook here and after calling out to native
    1:      * functions (but not to getters, setters, or other native hooks), so we do
    1:      * not have to reload it each time through the interpreter loop -- we hope
    1:      * the compiler can keep it in a register when it is non-null.
    1:      */
23111:     CHECK_INTERRUPT_HANDLER();
    1: 
42717:     /*
42717:      * Access to |cx->regs| is very common, so we copy in and repoint to a
42717:      * local variable, and copy out on exit.
42717:      */
42717:     JS_ASSERT(cx->regs);
52522:     JSFrameRegs *const prevContextRegs = cx->regs;
52522:     JSFrameRegs regs = *cx->regs;
42717:     cx->setCurrentRegs(&regs);
42717: 
20908: #if JS_HAS_GENERATORS
42717:     if (JS_UNLIKELY(fp->isGenerator())) {
42717:         JS_ASSERT(prevContextRegs == &cx->generatorFor(fp)->savedRegs);
13168:         JS_ASSERT((size_t) (regs.pc - script->code) <= script->length);
52522:         JS_ASSERT((size_t) (regs.sp - fp->base()) <= StackDepth(script));
    1: 
    1:         /*
11758:          * To support generator_throw and to catch ignored exceptions,
11758:          * fail if cx->throwing is set.
    1:          */
11758:         if (cx->throwing) {
    1: #ifdef DEBUG_NOT_THROWING
11442:             if (cx->exception != JSVAL_ARETURN) {
    1:                 printf("JS INTERPRETER CALLED WITH PENDING EXCEPTION %lx\n",
    1:                        (unsigned long) cx->exception);
11442:             }
    1: #endif
11859:             goto error;
10592:         }
    1:     }
42717: #endif
    1: 
33546: #ifdef JS_TRACER
42717:     /* We cannot reenter the interpreter while recording. */
33546:     if (TRACE_RECORDER(cx))
37741:         AbortRecording(cx, "attempt to reenter interpreter while recording");
33546: #endif
33546: 
52522:     /* State communicated between non-local jumps: */
52522:     JSBool interpReturnOK;
52522:     JSAtom *atomNotDefined;
52522: 
15453:     /*
15453:      * It is important that "op" be initialized before calling DO_OP because
15453:      * it is possible for "op" to be specially assigned during the normal
15453:      * processing of an opcode while looping. We rely on DO_NEXT_OP to manage
15453:      * "op" correctly in all other cases.
15453:      */
52522:     JSOp op;
52571:     jsint len;
15453:     len = 0;
52561: #if JS_THREADED_INTERP
15453:     DO_NEXT_OP(len);
52522: #else
52522:     DO_NEXT_OP(len);
52522: #endif
15453: 
    1: #if JS_THREADED_INTERP
    1:     /*
    1:      * This is a loop, but it does not look like a loop. The loop-closing
15453:      * jump is distributed throughout goto *jumpTable[op] inside of DO_OP.
15453:      * When interrupts are enabled, jumpTable is set to interruptJumpTable
23111:      * where all jumps point to the interrupt label. The latter, after
15453:      * calling the interrupt handler, dispatches through normalJumpTable to
15453:      * continue the normal bytecode processing.
15453:      */
31481: 
23111: #else /* !JS_THREADED_INTERP */
15453:     for (;;) {
15453:       advance_pc_by_one:
15453:         JS_ASSERT(js_CodeSpec[op].length == 1);
15453:         len = 1;
15453:       advance_pc:
15453:         regs.pc += len;
13168:         op = (JSOp) *regs.pc;
15453: 
15453:       do_op:
23111:         CHECK_RECORDER();
26954:         TRACE_OPCODE(op);
23111:         switchOp = intN(op) | switchMask;
15453:       do_switch:
15453:         switch (switchOp) {
27490: #endif
31481: 
53094: #if JS_THREADED_INTERP
53094:   interrupt:
53094: #else /* !JS_THREADED_INTERP */
53094:   case -1:
53094:     JS_ASSERT(switchMask == -1);
53094: #endif /* !JS_THREADED_INTERP */
53094:     {
53094:         bool moreInterrupts = false;
53094:         JSInterruptHook hook = cx->debugHooks->interruptHook;
53094:         if (hook) {
53094: #ifdef JS_TRACER
53094:             if (TRACE_RECORDER(cx))
53094:                 AbortRecording(cx, "interrupt hook");
53094: #endif
53094:             Value rval;
53094:             switch (hook(cx, script, regs.pc, Jsvalify(&rval),
53094:                          cx->debugHooks->interruptHookData)) {
53094:               case JSTRAP_ERROR:
53094:                 goto error;
53094:               case JSTRAP_CONTINUE:
53094:                 break;
53094:               case JSTRAP_RETURN:
53094:                 fp->rval = rval;
53094:                 interpReturnOK = JS_TRUE;
53094:                 goto forced_return;
53094:               case JSTRAP_THROW:
53094:                 cx->throwing = JS_TRUE;
53094:                 cx->exception = rval;
53094:                 goto error;
53094:               default:;
53094:             }
53094:             moreInterrupts = true;
53094:         }
53094: 
53094: #ifdef JS_TRACER
53094:         if (TraceRecorder* tr = TRACE_RECORDER(cx)) {
53094:             AbortableRecordingStatus status = tr->monitorRecording(op);
53094:             JS_ASSERT_IF(cx->throwing, status == ARECORD_ERROR);
53094:             switch (status) {
53094:               case ARECORD_CONTINUE:
53094:                 moreInterrupts = true;
53094:                 break;
53094:               case ARECORD_IMACRO:
53094:               case ARECORD_IMACRO_ABORTED:
53094:                 atoms = COMMON_ATOMS_START(&rt->atomState);
53094:                 op = JSOp(*regs.pc);
53094:                 if (status == ARECORD_IMACRO)
53094:                     DO_OP();    /* keep interrupting for op. */
53094:                 break;
53094:               case ARECORD_ERROR:
53094:                 // The code at 'error:' aborts the recording.
53094:                 goto error;
53094:               case ARECORD_ABORTED:
53094:               case ARECORD_COMPLETED:
53094:                 break;
53094:               case ARECORD_STOP:
53094:                 /* A 'stop' error should have already aborted recording. */
53094:               default:
53094:                 JS_NOT_REACHED("Bad recording status");
53094:             }
53094:         }
53094: #endif /* !JS_TRACER */
53094: 
53094: #if JS_THREADED_INTERP
53094: #ifdef MOZ_TRACEVIS
53094:         if (!moreInterrupts)
53094:             ExitTraceVisState(cx, R_ABORT);
53094: #endif
53094:         jumpTable = moreInterrupts ? interruptJumpTable : normalJumpTable;
53094:         JS_EXTENSION_(goto *normalJumpTable[op]);
53094: #else
53094:         switchMask = moreInterrupts ? -1 : 0;
53094:         switchOp = intN(op);
53094:         goto do_switch;
53094: #endif
53094:     }
53094: 
53094: /* No-ops for ease of decompilation. */
53094: ADD_EMPTY_CASE(JSOP_NOP)
53094: ADD_EMPTY_CASE(JSOP_CONDSWITCH)
53094: ADD_EMPTY_CASE(JSOP_TRY)
53094: ADD_EMPTY_CASE(JSOP_TRACE)
53094: #if JS_HAS_XML_SUPPORT
53094: ADD_EMPTY_CASE(JSOP_STARTXML)
53094: ADD_EMPTY_CASE(JSOP_STARTXMLEXPR)
53094: #endif
53094: END_EMPTY_CASES
53094: 
53094: /* ADD_EMPTY_CASE is not used here as JSOP_LINENO_LENGTH == 3. */
53094: BEGIN_CASE(JSOP_LINENO)
53094: END_CASE(JSOP_LINENO)
53094: 
53094: BEGIN_CASE(JSOP_PUSH)
53094:     PUSH_UNDEFINED();
53094: END_CASE(JSOP_PUSH)
53094: 
53094: BEGIN_CASE(JSOP_POP)
53094:     regs.sp--;
53094: END_CASE(JSOP_POP)
53094: 
53094: BEGIN_CASE(JSOP_POPN)
53094: {
53094:     regs.sp -= GET_UINT16(regs.pc);
53094: #ifdef DEBUG
53094:     JS_ASSERT(fp->base() <= regs.sp);
53094:     JSObject *obj = fp->blockChain;
53094:     JS_ASSERT_IF(obj,
53094:                  OBJ_BLOCK_DEPTH(cx, obj) + OBJ_BLOCK_COUNT(cx, obj)
53094:                  <= (size_t) (regs.sp - fp->base()));
53094:     for (obj = fp->scopeChain; obj; obj = obj->getParent()) {
53094:         Class *clasp = obj->getClass();
53094:         if (clasp != &js_BlockClass && clasp != &js_WithClass)
53094:             continue;
53094:         if (obj->getPrivate() != js_FloatingFrameIfGenerator(cx, fp))
53094:             break;
53094:         JS_ASSERT(fp->base() + OBJ_BLOCK_DEPTH(cx, obj)
53094:                              + ((clasp == &js_BlockClass)
53094:                                 ? OBJ_BLOCK_COUNT(cx, obj)
53094:                                 : 1)
53094:                   <= regs.sp);
53094:     }
53094: #endif
53094: }
53094: END_CASE(JSOP_POPN)
53094: 
53094: BEGIN_CASE(JSOP_SETRVAL)
53094: BEGIN_CASE(JSOP_POPV)
53094:     ASSERT_NOT_THROWING(cx);
53094:     POP_COPY_TO(fp->rval);
53094: END_CASE(JSOP_POPV)
53094: 
53094: BEGIN_CASE(JSOP_ENTERWITH)
53094:     if (!js_EnterWith(cx, -1))
53094:         goto error;
53094: 
53094:     /*
53094:      * We must ensure that different "with" blocks have different stack depth
53094:      * associated with them. This allows the try handler search to properly
53094:      * recover the scope chain. Thus we must keep the stack at least at the
53094:      * current level.
53094:      *
53094:      * We set sp[-1] to the current "with" object to help asserting the
53094:      * enter/leave balance in [leavewith].
53094:      */
53094:     regs.sp[-1].setObject(*fp->scopeChain);
53094: END_CASE(JSOP_ENTERWITH)
53094: 
53094: BEGIN_CASE(JSOP_LEAVEWITH)
53094:     JS_ASSERT(&regs.sp[-1].toObject() == fp->scopeChain);
53094:     regs.sp--;
53094:     js_LeaveWith(cx);
53094: END_CASE(JSOP_LEAVEWITH)
53094: 
53094: BEGIN_CASE(JSOP_RETURN)
53094:     POP_COPY_TO(fp->rval);
53094:     /* FALL THROUGH */
53094: 
53094: BEGIN_CASE(JSOP_RETRVAL)    /* fp->rval already set */
53094: BEGIN_CASE(JSOP_STOP)
53094: {
53094:     /*
53094:      * When the inlined frame exits with an exception or an error, ok will be
53094:      * false after the inline_return label.
53094:      */
53094:     ASSERT_NOT_THROWING(cx);
53094:     CHECK_BRANCH();
53094: 
53094:     if (fp->imacpc) {
53094:         /*
53094:          * If we are at the end of an imacro, return to its caller in the
53094:          * current frame.
53094:          */
53094:         JS_ASSERT(op == JSOP_STOP);
53094:         JS_ASSERT((uintN)(regs.sp - fp->slots()) <= script->nslots);
53094:         regs.pc = fp->imacpc + js_CodeSpec[*fp->imacpc].length;
53094:         fp->imacpc = NULL;
53094:         atoms = script->atomMap.vector;
53094:         op = JSOp(*regs.pc);
53094:         DO_OP();
53094:     }
53094: 
53094:     JS_ASSERT(regs.sp == fp->base());
53094:     if ((fp->flags & JSFRAME_CONSTRUCTING) && fp->rval.isPrimitive())
53094:         fp->rval = fp->thisv;
53094: 
53094:     interpReturnOK = true;
53094:     if (inlineCallCount)
53094:   inline_return:
53094:     {
53094:         JS_ASSERT(!fp->blockChain);
53094:         JS_ASSERT(!js_IsActiveWithOrBlock(cx, fp->scopeChain, 0));
53094: 
53094:         if (JS_LIKELY(script->staticLevel < JS_DISPLAY_SIZE))
53094:             cx->display[script->staticLevel] = fp->displaySave;
53094: 
53094:         void *hookData = fp->hookData;
53094:         if (JS_UNLIKELY(hookData != NULL)) {
53094:             if (JSInterpreterHook hook = cx->debugHooks->callHook) {
53094:                 hook(cx, fp, JS_FALSE, &interpReturnOK, hookData);
53094:                 CHECK_INTERRUPT_HANDLER();
53094:             }
53094:         }
53094: 
53094:         /*
53094:          * If fp has a call object, sync values and clear the back-
53094:          * pointer. This can happen for a lightweight function if it calls eval
53094:          * unexpectedly (in a way that is hidden from the compiler). See bug
53094:          * 325540.
53094:          */
53094:         fp->putActivationObjects(cx);
53094: 
53094:         DTrace::exitJSFun(cx, fp, fp->fun, fp->rval);
53094: 
53094:         /* Restore context version only if callee hasn't set version. */
53094:         if (JS_LIKELY(cx->version == currentVersion)) {
53094:             currentVersion = fp->callerVersion;
53094:             if (currentVersion != cx->version)
53094:                 js_SetVersion(cx, currentVersion);
53094:         }
53094: 
53094:         /*
53094:          * If inline-constructing, replace primitive rval with the new object
53094:          * passed in via |this|, and instrument this constructor invocation.
53094:          */
53094:         if (fp->flags & JSFRAME_CONSTRUCTING) {
53094:             if (fp->rval.isPrimitive())
53094:                 fp->rval = fp->thisv;
53094:             JS_RUNTIME_METER(cx->runtime, constructs);
53094:         }
53094: 
53094:         JSStackFrame *down = fp->down;
53094:         bool recursive = fp->script == down->script;
53094: 
53094:         /* Pop the frame. */
53094:         cx->stack().popInlineFrame(cx, fp, down);
53094: 
53094:         /* Propagate return value before fp is lost. */
53094:         regs.sp[-1] = fp->rval;
53094: 
53094:         /* Sync interpreter registers. */
53094:         fp = cx->fp;
53094:         script = fp->script;
53094:         atoms = FrameAtomBase(cx, fp);
53094: 
53094:         /* Resume execution in the calling frame. */
53094:         inlineCallCount--;
53094:         if (JS_LIKELY(interpReturnOK)) {
53094:             JS_ASSERT(js_CodeSpec[js_GetOpcode(cx, script, regs.pc)].length
53094:                       == JSOP_CALL_LENGTH);
53094:             TRACE_0(LeaveFrame);
53094:             if (!TRACE_RECORDER(cx) && recursive) {
53094:                 if (*(regs.pc + JSOP_CALL_LENGTH) == JSOP_TRACE) {
53094:                     regs.pc += JSOP_CALL_LENGTH;
53094:                     MONITOR_BRANCH(Record_LeaveFrame);
53094:                     op = (JSOp)*regs.pc;
53094:                     DO_OP();
53094:                 }
53094:             }
53094:             if (*(regs.pc + JSOP_CALL_LENGTH) == JSOP_TRACE ||
53094:                 *(regs.pc + JSOP_CALL_LENGTH) == JSOP_NOP) {
53094:                 JS_STATIC_ASSERT(JSOP_TRACE_LENGTH == JSOP_NOP_LENGTH);
53094:                 regs.pc += JSOP_CALL_LENGTH;
53094:                 len = JSOP_TRACE_LENGTH;
53094:             } else {
53094:                 len = JSOP_CALL_LENGTH;
53094:             }
53094:             DO_NEXT_OP(len);
53094:         }
53094:         goto error;
53094:     }
53094:     interpReturnOK = true;
53094:     goto exit;
53094: }
53094: 
53094: BEGIN_CASE(JSOP_DEFAULT)
53094:     regs.sp--;
53094:     /* FALL THROUGH */
53094: BEGIN_CASE(JSOP_GOTO)
53094: {
53094:     len = GET_JUMP_OFFSET(regs.pc);
53094:     BRANCH(len);
53094: }
53094: END_CASE(JSOP_GOTO)
53094: 
53094: BEGIN_CASE(JSOP_IFEQ)
53094: {
53094:     bool cond;
53094:     Value *_;
53094:     POP_BOOLEAN(cx, _, cond);
53094:     if (cond == false) {
53094:         len = GET_JUMP_OFFSET(regs.pc);
53094:         BRANCH(len);
53094:     }
53094: }
53094: END_CASE(JSOP_IFEQ)
53094: 
53094: BEGIN_CASE(JSOP_IFNE)
53094: {
53094:     bool cond;
53094:     Value *_;
53094:     POP_BOOLEAN(cx, _, cond);
53094:     if (cond != false) {
53094:         len = GET_JUMP_OFFSET(regs.pc);
53094:         BRANCH(len);
53094:     }
53094: }
53094: END_CASE(JSOP_IFNE)
53094: 
53094: BEGIN_CASE(JSOP_OR)
53094: {
53094:     bool cond;
53094:     Value *vp;
53094:     POP_BOOLEAN(cx, vp, cond);
53094:     if (cond == true) {
53094:         len = GET_JUMP_OFFSET(regs.pc);
53094:         PUSH_COPY(*vp);
53094:         DO_NEXT_OP(len);
53094:     }
53094: }
53094: END_CASE(JSOP_OR)
53094: 
53094: BEGIN_CASE(JSOP_AND)
53094: {
53094:     bool cond;
53094:     Value *vp;
53094:     POP_BOOLEAN(cx, vp, cond);
53094:     if (cond == false) {
53094:         len = GET_JUMP_OFFSET(regs.pc);
53094:         PUSH_COPY(*vp);
53094:         DO_NEXT_OP(len);
53094:     }
53094: }
53094: END_CASE(JSOP_AND)
53094: 
53094: BEGIN_CASE(JSOP_DEFAULTX)
53094:     regs.sp--;
53094:     /* FALL THROUGH */
53094: BEGIN_CASE(JSOP_GOTOX)
53094: {
53094:     len = GET_JUMPX_OFFSET(regs.pc);
53094:     BRANCH(len);
53094: }
53094: END_CASE(JSOP_GOTOX);
53094: 
53094: BEGIN_CASE(JSOP_IFEQX)
53094: {
53094:     bool cond;
53094:     Value *_;
53094:     POP_BOOLEAN(cx, _, cond);
53094:     if (cond == false) {
53094:         len = GET_JUMPX_OFFSET(regs.pc);
53094:         BRANCH(len);
53094:     }
53094: }
53094: END_CASE(JSOP_IFEQX)
53094: 
53094: BEGIN_CASE(JSOP_IFNEX)
53094: {
53094:     bool cond;
53094:     Value *_;
53094:     POP_BOOLEAN(cx, _, cond);
53094:     if (cond != false) {
53094:         len = GET_JUMPX_OFFSET(regs.pc);
53094:         BRANCH(len);
53094:     }
53094: }
53094: END_CASE(JSOP_IFNEX)
53094: 
53094: BEGIN_CASE(JSOP_ORX)
53094: {
53094:     bool cond;
53094:     Value *vp;
53094:     POP_BOOLEAN(cx, vp, cond);
53094:     if (cond == true) {
53094:         len = GET_JUMPX_OFFSET(regs.pc);
53094:         PUSH_COPY(*vp);
53094:         DO_NEXT_OP(len);
53094:     }
53094: }
53094: END_CASE(JSOP_ORX)
53094: 
53094: BEGIN_CASE(JSOP_ANDX)
53094: {
53094:     bool cond;
53094:     Value *vp;
53094:     POP_BOOLEAN(cx, vp, cond);
53094:     if (cond == JS_FALSE) {
53094:         len = GET_JUMPX_OFFSET(regs.pc);
53094:         PUSH_COPY(*vp);
53094:         DO_NEXT_OP(len);
53094:     }
53094: }
53094: END_CASE(JSOP_ANDX)
53094: 
53094: /*
53094:  * If the index value at sp[n] is not an int that fits in a jsval, it could
53094:  * be an object (an XML QName, AttributeName, or AnyName), but only if we are
53094:  * compiling with JS_HAS_XML_SUPPORT.  Otherwise convert the index value to a
53094:  * string atom id.
53094:  */
53094: #define FETCH_ELEMENT_ID(obj, n, id)                                          \
53094:     JS_BEGIN_MACRO                                                            \
53094:         const Value &idval_ = regs.sp[n];                                     \
53094:         int32_t i_;                                                           \
53094:         if (ValueFitsInInt32(idval_, &i_) && INT_FITS_IN_JSID(i_)) {          \
53094:             id = INT_TO_JSID(i_);                                             \
53094:         } else {                                                              \
53094:             if (!js_InternNonIntElementId(cx, obj, idval_, &id, &regs.sp[n])) \
53094:                 goto error;                                                   \
53094:         }                                                                     \
53094:     JS_END_MACRO
53094: 
53094: #define TRY_BRANCH_AFTER_COND(cond,spdec)                                     \
53094:     JS_BEGIN_MACRO                                                            \
53094:         JS_ASSERT(js_CodeSpec[op].length == 1);                               \
53094:         uintN diff_ = (uintN) regs.pc[1] - (uintN) JSOP_IFEQ;                 \
53094:         if (diff_ <= 1) {                                                     \
53094:             regs.sp -= spdec;                                                 \
53094:             if (cond == (diff_ != 0)) {                                       \
53094:                 ++regs.pc;                                                    \
53094:                 len = GET_JUMP_OFFSET(regs.pc);                               \
53094:                 BRANCH(len);                                                  \
53094:             }                                                                 \
53094:             len = 1 + JSOP_IFEQ_LENGTH;                                       \
53094:             DO_NEXT_OP(len);                                                  \
53094:         }                                                                     \
53094:     JS_END_MACRO
53094: 
53094: BEGIN_CASE(JSOP_IN)
53094: {
53094:     const Value &rref = regs.sp[-1];
53094:     if (!rref.isObject()) {
53094:         js_ReportValueError(cx, JSMSG_IN_NOT_OBJECT, -1, rref, NULL);
53094:         goto error;
53094:     }
53094:     JSObject *obj = &rref.toObject();
53094:     jsid id;
53094:     FETCH_ELEMENT_ID(obj, -2, id);
53094:     JSObject *obj2;
53094:     JSProperty *prop;
53094:     if (!obj->lookupProperty(cx, id, &obj2, &prop))
53094:         goto error;
53094:     bool cond = prop != NULL;
53094:     if (prop)
53094:         obj2->dropProperty(cx, prop);
53094:     TRY_BRANCH_AFTER_COND(cond, 2);
53094:     regs.sp--;
53094:     regs.sp[-1].setBoolean(cond);
53094: }
53094: END_CASE(JSOP_IN)
53094: 
53094: BEGIN_CASE(JSOP_ITER)
53094: {
53094:     JS_ASSERT(regs.sp > fp->base());
53094:     uintN flags = regs.pc[1];
53094:     if (!js_ValueToIterator(cx, flags, &regs.sp[-1]))
53094:         goto error;
53094:     CHECK_INTERRUPT_HANDLER();
53094:     JS_ASSERT(!regs.sp[-1].isPrimitive());
53094: }
53094: END_CASE(JSOP_ITER)
53094: 
53094: BEGIN_CASE(JSOP_MOREITER)
53094: {
53094:     JS_ASSERT(regs.sp - 1 >= fp->base());
53094:     JS_ASSERT(regs.sp[-1].isObject());
53094:     PUSH_NULL();
53094:     bool cond;
53094:     if (!IteratorMore(cx, &regs.sp[-2].toObject(), &cond, &regs.sp[-1]))
53094:         goto error;
53094:     CHECK_INTERRUPT_HANDLER();
53094:     TRY_BRANCH_AFTER_COND(cond, 1);
53094:     JS_ASSERT(regs.pc[1] == JSOP_IFNEX);
53094:     regs.sp[-1].setBoolean(cond);
53094: }
53094: END_CASE(JSOP_MOREITER)
53094: 
53094: BEGIN_CASE(JSOP_ENDITER)
53094: {
53094:     JS_ASSERT(regs.sp - 1 >= fp->base());
53099:     bool ok = !!js_CloseIterator(cx, &regs.sp[-1].toObject());
53094:     regs.sp--;
53094:     if (!ok)
53094:         goto error;
53094: }
53094: END_CASE(JSOP_ENDITER)
53094: 
53094: BEGIN_CASE(JSOP_FORARG)
53094: {
53094:     JS_ASSERT(regs.sp - 1 >= fp->base());
53094:     uintN slot = GET_ARGNO(regs.pc);
53094:     JS_ASSERT(slot < fp->fun->nargs);
53094:     JS_ASSERT(regs.sp[-1].isObject());
53094:     if (!IteratorNext(cx, &regs.sp[-1].toObject(), &fp->argv[slot]))
53094:         goto error;
53094: }
53094: END_CASE(JSOP_FORARG)
53094: 
53094: BEGIN_CASE(JSOP_FORLOCAL)
53094: {
53094:     JS_ASSERT(regs.sp - 1 >= fp->base());
53094:     uintN slot = GET_SLOTNO(regs.pc);
53094:     JS_ASSERT(slot < fp->script->nslots);
53094:     JS_ASSERT(regs.sp[-1].isObject());
53094:     if (!IteratorNext(cx, &regs.sp[-1].toObject(), &fp->slots()[slot]))
53094:         goto error;
53094: }
53094: END_CASE(JSOP_FORLOCAL)
53094: 
53094: BEGIN_CASE(JSOP_FORNAME)
53094: {
53094:     JS_ASSERT(regs.sp - 1 >= fp->base());
53094:     JSAtom *atom;
53094:     LOAD_ATOM(0, atom);
53094:     jsid id = ATOM_TO_JSID(atom);
53094:     JSObject *obj, *obj2;
53094:     JSProperty *prop;
53094:     if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
53094:         goto error;
53094:     if (prop)
53094:         obj2->dropProperty(cx, prop);
53094:     {
53094:         AutoValueRooter tvr(cx);
53094:         JS_ASSERT(regs.sp[-1].isObject());
53094:         if (!IteratorNext(cx, &regs.sp[-1].toObject(), tvr.addr()))
53094:             goto error;
53094:         if (!obj->setProperty(cx, id, tvr.addr()))
53094:             goto error;
53094:     }
53094: }
53094: END_CASE(JSOP_FORNAME)
53094: 
53094: BEGIN_CASE(JSOP_FORPROP)
53094: {
53094:     JS_ASSERT(regs.sp - 2 >= fp->base());
53094:     JSAtom *atom;
53094:     LOAD_ATOM(0, atom);
53094:     jsid id = ATOM_TO_JSID(atom);
53094:     JSObject *obj;
53094:     FETCH_OBJECT(cx, -1, obj);
53094:     {
53094:         AutoValueRooter tvr(cx);
53094:         JS_ASSERT(regs.sp[-2].isObject());
53094:         if (!IteratorNext(cx, &regs.sp[-2].toObject(), tvr.addr()))
53094:             goto error;
53094:         if (!obj->setProperty(cx, id, tvr.addr()))
53094:             goto error;
53094:     }
53094:     regs.sp--;
53094: }
53094: END_CASE(JSOP_FORPROP)
53094: 
53094: BEGIN_CASE(JSOP_FORELEM)
53094:     /*
53094:      * JSOP_FORELEM simply dups the property identifier at top of stack and
53094:      * lets the subsequent JSOP_ENUMELEM opcode sequence handle the left-hand
53094:      * side expression evaluation and assignment. This opcode exists solely to
53094:      * help the decompiler.
53094:      */
53094:     JS_ASSERT(regs.sp - 1 >= fp->base());
53094:     JS_ASSERT(regs.sp[-1].isObject());
53094:     PUSH_NULL();
53094:     if (!IteratorNext(cx, &regs.sp[-2].toObject(), &regs.sp[-1]))
53094:         goto error;
53094: END_CASE(JSOP_FORELEM)
53094: 
53094: BEGIN_CASE(JSOP_DUP)
53094: {
53094:     JS_ASSERT(regs.sp > fp->base());
53094:     const Value &rref = regs.sp[-1];
53094:     PUSH_COPY(rref);
53094: }
53094: END_CASE(JSOP_DUP)
53094: 
53094: BEGIN_CASE(JSOP_DUP2)
53094: {
53094:     JS_ASSERT(regs.sp - 2 >= fp->base());
53094:     const Value &lref = regs.sp[-2];
53094:     const Value &rref = regs.sp[-1];
53094:     PUSH_COPY(lref);
53094:     PUSH_COPY(rref);
53094: }
53094: END_CASE(JSOP_DUP2)
53094: 
53094: BEGIN_CASE(JSOP_SWAP)
53094: {
53094:     JS_ASSERT(regs.sp - 2 >= fp->base());
53094:     Value &lref = regs.sp[-2];
53094:     Value &rref = regs.sp[-1];
53094:     lref.swap(rref);
53094: }
53094: END_CASE(JSOP_SWAP)
53094: 
53094: BEGIN_CASE(JSOP_PICK)
53094: {
53094:     jsint i = regs.pc[1];
53094:     JS_ASSERT(regs.sp - (i+1) >= fp->base());
53094:     Value lval = regs.sp[-(i+1)];
53094:     memmove(regs.sp - (i+1), regs.sp - i, sizeof(Value)*i);
53094:     regs.sp[-1] = lval;
53094: }
53094: END_CASE(JSOP_PICK)
53094: 
53094: #define NATIVE_GET(cx,obj,pobj,sprop,getHow,vp)                               \
53094:     JS_BEGIN_MACRO                                                            \
53094:         if (sprop->hasDefaultGetter()) {                                      \
53094:             /* Fast path for Object instance properties. */                   \
53094:             JS_ASSERT((sprop)->slot != SPROP_INVALID_SLOT ||                  \
53094:                       !sprop->hasDefaultSetter());                            \
53094:             if (((sprop)->slot != SPROP_INVALID_SLOT))                        \
53094:                 *(vp) = (pobj)->lockedGetSlot((sprop)->slot);                 \
53094:             else                                                              \
53094:                 (vp)->setUndefined();                                         \
53094:         } else {                                                              \
53094:             if (!js_NativeGet(cx, obj, pobj, sprop, getHow, vp))              \
53094:                 goto error;                                                   \
53094:         }                                                                     \
53094:     JS_END_MACRO
53094: 
53094: #define NATIVE_SET(cx,obj,sprop,entry,vp)                                     \
53094:     JS_BEGIN_MACRO                                                            \
53094:         TRACE_2(SetPropHit, entry, sprop);                                    \
53094:         if (sprop->hasDefaultSetter() &&                                      \
53094:             (sprop)->slot != SPROP_INVALID_SLOT &&                            \
53094:             !(obj)->scope()->brandedOrHasMethodBarrier()) {                   \
53094:             /* Fast path for, e.g., plain Object instance properties. */      \
53094:             (obj)->lockedSetSlot((sprop)->slot, *vp);                         \
53094:         } else {                                                              \
53094:             if (!js_NativeSet(cx, obj, sprop, false, vp))                     \
53094:                 goto error;                                                   \
53094:         }                                                                     \
53094:     JS_END_MACRO
53094: 
53094: /*
53094:  * Skip the JSOP_POP typically found after a JSOP_SET* opcode, where oplen is
53094:  * the constant length of the SET opcode sequence, and spdec is the constant
53094:  * by which to decrease the stack pointer to pop all of the SET op's operands.
53094:  *
53094:  * NB: unlike macros that could conceivably be replaced by functions (ignoring
53094:  * goto error), where a call should not have to be braced in order to expand
53094:  * correctly (e.g., in if (cond) FOO(); else BAR()), these three macros lack
53094:  * JS_{BEGIN,END}_MACRO brackets. They are also indented so as to align with
53094:  * nearby opcode code.
53094:  */
53094: #define SKIP_POP_AFTER_SET(oplen,spdec)                                       \
53094:             if (regs.pc[oplen] == JSOP_POP) {                                 \
53094:                 regs.sp -= spdec;                                             \
53094:                 regs.pc += oplen + JSOP_POP_LENGTH;                           \
53094:                 op = (JSOp) *regs.pc;                                         \
53094:                 DO_OP();                                                      \
53094:             }
53094: 
53094: #define END_SET_CASE(OP)                                                      \
53094:             SKIP_POP_AFTER_SET(OP##_LENGTH, 1);                               \
53094:           END_CASE(OP)
53094: 
53094: #define END_SET_CASE_STORE_RVAL(OP,spdec)                                     \
53094:             SKIP_POP_AFTER_SET(OP##_LENGTH, spdec);                           \
53094:             {                                                                 \
53094:                 Value *newsp = regs.sp - ((spdec) - 1);                       \
53094:                 newsp[-1] = regs.sp[-1];                                      \
53094:                 regs.sp = newsp;                                              \
53094:             }                                                                 \
53094:           END_CASE(OP)
53094: 
53094: BEGIN_CASE(JSOP_SETCONST)
53094: {
53094:     JSAtom *atom;
53094:     LOAD_ATOM(0, atom);
53094:     JSObject *obj = fp->varobj(cx);
53094:     const Value &ref = regs.sp[-1];
53094:     if (!obj->defineProperty(cx, ATOM_TO_JSID(atom), ref,
53094:                              PropertyStub, PropertyStub,
53094:                              JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY)) {
53094:         goto error;
53094:     }
53094: }
53094: END_SET_CASE(JSOP_SETCONST);
53094: 
53094: #if JS_HAS_DESTRUCTURING
53094: BEGIN_CASE(JSOP_ENUMCONSTELEM)
53094: {
53094:     const Value &ref = regs.sp[-3];
53094:     JSObject *obj;
53094:     FETCH_OBJECT(cx, -2, obj);
53094:     jsid id;
53094:     FETCH_ELEMENT_ID(obj, -1, id);
53094:     if (!obj->defineProperty(cx, id, ref,
53094:                              PropertyStub, PropertyStub,
53094:                              JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY)) {
53094:         goto error;
53094:     }
53094:     regs.sp -= 3;
53094: }
53094: END_CASE(JSOP_ENUMCONSTELEM)
53094: #endif
53094: 
53094: BEGIN_CASE(JSOP_BINDNAME)
53094: {
53094:     JSObject *obj;
53094:     do {
53094:         /*
53094:          * We can skip the property lookup for the global object. If the
53094:          * property does not exist anywhere on the scope chain, JSOP_SETNAME
53094:          * adds the property to the global.
53094:          *
53094:          * As a consequence of this optimization for the global object we run
53094:          * its JSRESOLVE_ASSIGNING-tolerant resolve hooks only in JSOP_SETNAME,
53094:          * after the interpreter evaluates the right- hand-side of the
53094:          * assignment, and not here.
53094:          *
53094:          * This should be transparent to the hooks because the script, instead
53094:          * of name = rhs, could have used global.name = rhs given a global
53094:          * object reference, which also calls the hooks only after evaluating
53094:          * the rhs. We desire such resolve hook equivalence between the two
53094:          * forms.
53094:          */
53094:         obj = fp->scopeChain;
53094:         if (!obj->getParent())
53094:             break;
53094: 
53094:         PropertyCacheEntry *entry;
53094:         JSObject *obj2;
53094:         JSAtom *atom;
53094:         JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
53094:         if (!atom) {
53094:             ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
53094:             break;
53094:         }
53094: 
53094:         jsid id = ATOM_TO_JSID(atom);
53094:         obj = js_FindIdentifierBase(cx, fp->scopeChain, id);
53094:         if (!obj)
53094:             goto error;
53094:     } while (0);
53094:     PUSH_OBJECT(*obj);
53094: }
53094: END_CASE(JSOP_BINDNAME)
53094: 
53094: BEGIN_CASE(JSOP_IMACOP)
53094:     JS_ASSERT(JS_UPTRDIFF(fp->imacpc, script->code) < script->length);
53094:     op = JSOp(*fp->imacpc);
53094:     DO_OP();
53094: 
53094: #define BITWISE_OP(OP)                                                        \
53094:     JS_BEGIN_MACRO                                                            \
53094:         int32_t i, j;                                                         \
53094:         if (!ValueToECMAInt32(cx, regs.sp[-2], &i))                           \
53094:             goto error;                                                       \
53094:         if (!ValueToECMAInt32(cx, regs.sp[-1], &j))                           \
53094:             goto error;                                                       \
53094:         i = i OP j;                                                           \
53094:         regs.sp--;                                                            \
53094:         regs.sp[-1].setInt32(i);                                              \
53094:     JS_END_MACRO
53094: 
53094: BEGIN_CASE(JSOP_BITOR)
53094:     BITWISE_OP(|);
53094: END_CASE(JSOP_BITOR)
53094: 
53094: BEGIN_CASE(JSOP_BITXOR)
53094:     BITWISE_OP(^);
53094: END_CASE(JSOP_BITXOR)
53094: 
53094: BEGIN_CASE(JSOP_BITAND)
53094:     BITWISE_OP(&);
53094: END_CASE(JSOP_BITAND)
53094: 
53094: #undef BITWISE_OP
53094: 
53094: /*
53094:  * NB: These macros can't use JS_BEGIN_MACRO/JS_END_MACRO around their bodies
53094:  * because they begin if/else chains, so callers must not put semicolons after
53094:  * the call expressions!
53094:  */
53094: #if JS_HAS_XML_SUPPORT
53094: #define XML_EQUALITY_OP(OP)                                                   \
53094:     if ((lval.isObject() && lval.toObject().isXML()) ||                       \
53094:         (rval.isObject() && rval.toObject().isXML())) {                       \
53094:         if (!js_TestXMLEquality(cx, lval, rval, &cond))                       \
53094:             goto error;                                                       \
53094:         cond = cond OP JS_TRUE;                                               \
53094:     } else
53094: 
53094: #define EXTENDED_EQUALITY_OP(OP)                                              \
53094:     if (((clasp = l->getClass())->flags & JSCLASS_IS_EXTENDED) &&             \
53094:         ((ExtendedClass *)clasp)->equality) {                                 \
53094:         if (!((ExtendedClass *)clasp)->equality(cx, l, &rval, &cond))         \
53094:             goto error;                                                       \
53094:         cond = cond OP JS_TRUE;                                               \
53094:     } else
53094: #else
53094: #define XML_EQUALITY_OP(OP)             /* nothing */
53094: #define EXTENDED_EQUALITY_OP(OP)        /* nothing */
53094: #endif
53094: 
53094: #define EQUALITY_OP(OP, IFNAN)                                                \
53094:     JS_BEGIN_MACRO                                                            \
53094:         Class *clasp;                                                         \
53094:         JSBool cond;                                                          \
53094:         Value rval = regs.sp[-1];                                             \
53094:         Value lval = regs.sp[-2];                                             \
53094:         XML_EQUALITY_OP(OP)                                                   \
53094:         if (SameType(lval, rval)) {                                           \
53094:             if (lval.isString()) {                                            \
53094:                 JSString *l = lval.toString(), *r = rval.toString();          \
53094:                 cond = js_EqualStrings(l, r) OP JS_TRUE;                      \
53094:             } else if (lval.isDouble()) {                                     \
53094:                 double l = lval.toDouble(), r = rval.toDouble();              \
53094:                 cond = JSDOUBLE_COMPARE(l, OP, r, IFNAN);                     \
53094:             } else if (lval.isObject()) {                                     \
53094:                 JSObject *l = &lval.toObject(), *r = &rval.toObject();        \
53094:                 EXTENDED_EQUALITY_OP(OP)                                      \
53094:                 cond = l OP r;                                                \
53094:             } else {                                                          \
53094:                 cond = lval.payloadAsRawUint32() OP rval.payloadAsRawUint32();\
53094:             }                                                                 \
53094:         } else {                                                              \
53094:             if (lval.isNullOrUndefined()) {                                   \
53094:                 cond = rval.isNullOrUndefined() OP true;                      \
53094:             } else if (rval.isNullOrUndefined()) {                            \
53094:                 cond = true OP false;                                         \
53094:             } else {                                                          \
53094:                 if (lval.isObject())                                          \
53094:                     DEFAULT_VALUE(cx, -2, JSTYPE_VOID, lval);                 \
53094:                 if (rval.isObject())                                          \
53094:                     DEFAULT_VALUE(cx, -1, JSTYPE_VOID, rval);                 \
53094:                 if (lval.isString() && rval.isString()) {                     \
53094:                     JSString *l = lval.toString(), *r = rval.toString();      \
53094:                     cond = js_EqualStrings(l, r) OP JS_TRUE;                  \
53094:                 } else {                                                      \
53094:                     double l, r;                                              \
53094:                     if (!ValueToNumber(cx, lval, &l) ||                       \
53094:                         !ValueToNumber(cx, rval, &r)) {                       \
53094:                         goto error;                                           \
53094:                     }                                                         \
53094:                     cond = JSDOUBLE_COMPARE(l, OP, r, IFNAN);                 \
53094:                 }                                                             \
53094:             }                                                                 \
53094:         }                                                                     \
53094:         TRY_BRANCH_AFTER_COND(cond, 2);                                       \
53094:         regs.sp--;                                                            \
53094:         regs.sp[-1].setBoolean(cond);                                         \
53094:     JS_END_MACRO
53094: 
53094: BEGIN_CASE(JSOP_EQ)
53094:     EQUALITY_OP(==, false);
53094: END_CASE(JSOP_EQ)
53094: 
53094: BEGIN_CASE(JSOP_NE)
53094:     EQUALITY_OP(!=, true);
53094: END_CASE(JSOP_NE)
53094: 
53094: #undef EQUALITY_OP
53094: #undef XML_EQUALITY_OP
53094: #undef EXTENDED_EQUALITY_OP
53094: 
53094: #define STRICT_EQUALITY_OP(OP, COND)                                          \
53094:     JS_BEGIN_MACRO                                                            \
53094:         const Value &rref = regs.sp[-1];                                      \
53094:         const Value &lref = regs.sp[-2];                                      \
53094:         COND = StrictlyEqual(cx, lref, rref) OP true;                         \
53094:         regs.sp--;                                                            \
53094:     JS_END_MACRO
53094: 
53094: BEGIN_CASE(JSOP_STRICTEQ)
53094: {
53094:     bool cond;
53094:     STRICT_EQUALITY_OP(==, cond);
53094:     regs.sp[-1].setBoolean(cond);
53094: }
53094: END_CASE(JSOP_STRICTEQ)
53094: 
53094: BEGIN_CASE(JSOP_STRICTNE)
53094: {
53094:     bool cond;
53094:     STRICT_EQUALITY_OP(!=, cond);
53094:     regs.sp[-1].setBoolean(cond);
53094: }
53094: END_CASE(JSOP_STRICTNE)
53094: 
53094: BEGIN_CASE(JSOP_CASE)
53094: {
53094:     bool cond;
53094:     STRICT_EQUALITY_OP(==, cond);
53094:     if (cond) {
53094:         regs.sp--;
53094:         len = GET_JUMP_OFFSET(regs.pc);
53094:         BRANCH(len);
53094:     }
53094: }
53094: END_CASE(JSOP_CASE)
53094: 
53094: BEGIN_CASE(JSOP_CASEX)
53094: {
53094:     bool cond;
53094:     STRICT_EQUALITY_OP(==, cond);
53094:     if (cond) {
53094:         regs.sp--;
53094:         len = GET_JUMPX_OFFSET(regs.pc);
53094:         BRANCH(len);
53094:     }
53094: }
53094: END_CASE(JSOP_CASEX)
53094: 
53094: #undef STRICT_EQUALITY_OP
53094: 
53094: #define RELATIONAL_OP(OP)                                                     \
53094:     JS_BEGIN_MACRO                                                            \
53094:         Value rval = regs.sp[-1];                                             \
53094:         Value lval = regs.sp[-2];                                             \
53094:         bool cond;                                                            \
53094:         /* Optimize for two int-tagged operands (typical loop control). */    \
53094:         if (lval.isInt32() && rval.isInt32()) {                               \
53094:             cond = lval.toInt32() OP rval.toInt32();                          \
53094:         } else {                                                              \
53094:             if (lval.isObject())                                              \
53094:                 DEFAULT_VALUE(cx, -2, JSTYPE_NUMBER, lval);                   \
53094:             if (rval.isObject())                                              \
53094:                 DEFAULT_VALUE(cx, -1, JSTYPE_NUMBER, rval);                   \
53094:             if (lval.isString() && rval.isString()) {                         \
53094:                 JSString *l = lval.toString(), *r = rval.toString();          \
53094:                 cond = js_CompareStrings(l, r) OP 0;                          \
53094:             } else {                                                          \
53094:                 double l, r;                                                  \
53094:                 if (!ValueToNumber(cx, lval, &l) ||                           \
53094:                     !ValueToNumber(cx, rval, &r)) {                           \
53094:                     goto error;                                               \
53094:                 }                                                             \
53094:                 cond = JSDOUBLE_COMPARE(l, OP, r, false);                     \
53094:             }                                                                 \
53094:         }                                                                     \
53094:         TRY_BRANCH_AFTER_COND(cond, 2);                                       \
53094:         regs.sp--;                                                            \
53094:         regs.sp[-1].setBoolean(cond);                                         \
53094:     JS_END_MACRO
53094: 
53094: BEGIN_CASE(JSOP_LT)
53094:     RELATIONAL_OP(<);
53094: END_CASE(JSOP_LT)
53094: 
53094: BEGIN_CASE(JSOP_LE)
53094:     RELATIONAL_OP(<=);
53094: END_CASE(JSOP_LE)
53094: 
53094: BEGIN_CASE(JSOP_GT)
53094:     RELATIONAL_OP(>);
53094: END_CASE(JSOP_GT)
53094: 
53094: BEGIN_CASE(JSOP_GE)
53094:     RELATIONAL_OP(>=);
53094: END_CASE(JSOP_GE)
53094: 
53094: #undef RELATIONAL_OP
53094: 
53094: #define SIGNED_SHIFT_OP(OP)                                                   \
53094:     JS_BEGIN_MACRO                                                            \
53094:         int32_t i, j;                                                         \
53094:         if (!ValueToECMAInt32(cx, regs.sp[-2], &i))                           \
53094:             goto error;                                                       \
53094:         if (!ValueToECMAInt32(cx, regs.sp[-1], &j))                           \
53094:             goto error;                                                       \
53094:         i = i OP (j & 31);                                                    \
53094:         regs.sp--;                                                            \
53094:         regs.sp[-1].setInt32(i);                                              \
53094:     JS_END_MACRO
53094: 
53094: BEGIN_CASE(JSOP_LSH)
53094:     SIGNED_SHIFT_OP(<<);
53094: END_CASE(JSOP_LSH)
53094: 
53094: BEGIN_CASE(JSOP_RSH)
53094:     SIGNED_SHIFT_OP(>>);
53094: END_CASE(JSOP_RSH)
53094: 
53094: #undef SIGNED_SHIFT_OP
53094: 
53094: BEGIN_CASE(JSOP_URSH)
53094: {
53094:     uint32_t u;
53094:     if (!ValueToECMAUint32(cx, regs.sp[-2], &u))
53094:         goto error;
53094:     int32_t j;
53094:     if (!ValueToECMAInt32(cx, regs.sp[-1], &j))
53094:         goto error;
53094: 
53094:     u >>= (j & 31);
53094: 
53094:     regs.sp--;
53094: 	regs.sp[-1].setNumber(uint32(u));
53094: }
53094: END_CASE(JSOP_URSH)
53094: 
53094: BEGIN_CASE(JSOP_ADD)
53094: {
53094:     Value rval = regs.sp[-1];
53094:     Value lval = regs.sp[-2];
53094: 
53094:     if (lval.isInt32() && rval.isInt32()) {
53094:         int32_t l = lval.toInt32(), r = rval.toInt32();
53094:         int32_t sum = l + r;
53094:         regs.sp--;
53094:         if (JS_UNLIKELY(bool((l ^ sum) & (r ^ sum) & 0x80000000)))
53094:             regs.sp[-1].setDouble(double(l) + double(r));
53094:         else
53094:             regs.sp[-1].setInt32(sum);
53094:     } else
53094: #if JS_HAS_XML_SUPPORT
53094:     if (IsXML(lval) && IsXML(rval)) {
53094:         if (!js_ConcatenateXML(cx, &lval.toObject(), &rval.toObject(), &rval))
53094:             goto error;
53094:         regs.sp--;
53094:         regs.sp[-1] = rval;
53094:     } else
53094: #endif
53094:     {
53094:         if (lval.isObject()) 
53094:             DEFAULT_VALUE(cx, -2, JSTYPE_VOID, lval);
53094:         if (rval.isObject())
53094:             DEFAULT_VALUE(cx, -1, JSTYPE_VOID, rval);
53094:         bool lIsString, rIsString;
53094:         if ((lIsString = lval.isString()) | (rIsString = rval.isString())) {
53094:             JSString *lstr, *rstr;
53094:             if (lIsString) {
53094:                 lstr = lval.toString();
53094:             } else {
53094:                 lstr = js_ValueToString(cx, lval);
53094:                 if (!lstr)
53094:                     goto error;
53094:                 regs.sp[-2].setString(lstr);
53094:             }
53094:             if (rIsString) {
53094:                 rstr = rval.toString();
53094:             } else {
53094:                 rstr = js_ValueToString(cx, rval);
53094:                 if (!rstr)
53094:                     goto error;
53094:                 regs.sp[-1].setString(rstr);
53094:             }
53094:             JSString *str = js_ConcatStrings(cx, lstr, rstr);
53094:             if (!str)
53094:                 goto error;
53094:             regs.sp--;
53094:             regs.sp[-1].setString(str);
53094:         } else {
53094:             double l, r;
53094:             if (!ValueToNumber(cx, lval, &l) || !ValueToNumber(cx, rval, &r))
53094:                 goto error;
53094:             l += r;
53094:             regs.sp--;
53094:             regs.sp[-1].setNumber(l);
53094:         }
53094:     }
53094: }
53094: END_CASE(JSOP_ADD)
53094: 
53094: BEGIN_CASE(JSOP_OBJTOSTR)
53094: {
53094:     const Value &ref = regs.sp[-1];
53094:     if (ref.isObject()) {
53094:         JSString *str = js_ValueToString(cx, ref);
53094:         if (!str)
53094:             goto error;
53094:         regs.sp[-1].setString(str);
53094:     }
53094: }
53094: END_CASE(JSOP_OBJTOSTR)
53094: 
53094: BEGIN_CASE(JSOP_CONCATN)
53094: {
53094:     JSCharBuffer buf(cx);
53094:     uintN argc = GET_ARGC(regs.pc);
53094:     for (Value *vp = regs.sp - argc; vp < regs.sp; vp++) {
53094:         JS_ASSERT(vp->isPrimitive());
53094:         if (!js_ValueToCharBuffer(cx, *vp, buf))
53094:             goto error;
53094:     }
53094:     JSString *str = js_NewStringFromCharBuffer(cx, buf);
53094:     if (!str)
53094:         goto error;
53094:     regs.sp -= argc - 1;
53094:     regs.sp[-1].setString(str);
53094: }
53094: END_CASE(JSOP_CONCATN)
53094: 
53094: #define BINARY_OP(OP)                                                         \
53094:     JS_BEGIN_MACRO                                                            \
53094:         double d1, d2;                                                        \
53094:         if (!ValueToNumber(cx, regs.sp[-2], &d1) ||                           \
53094:             !ValueToNumber(cx, regs.sp[-1], &d2)) {                           \
53094:             goto error;                                                       \
53094:         }                                                                     \
53094:         double d = d1 OP d2;                                                  \
53094:         regs.sp--;                                                            \
53094:         regs.sp[-1].setNumber(d);                                             \
53094:     JS_END_MACRO
53094: 
53094: BEGIN_CASE(JSOP_SUB)
53094:     BINARY_OP(-);
53094: END_CASE(JSOP_SUB)
53094: 
53094: BEGIN_CASE(JSOP_MUL)
53094:     BINARY_OP(*);
53094: END_CASE(JSOP_MUL)
53094: 
53094: #undef BINARY_OP
53094: 
53094: BEGIN_CASE(JSOP_DIV)
53094: {
53094:     double d1, d2;
53094:     if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
53094:         !ValueToNumber(cx, regs.sp[-1], &d2)) {
53094:         goto error;
53094:     }
53094:     regs.sp--;
53094:     if (d2 == 0) {
53094:         const Value *vp;
53094: #ifdef XP_WIN
53094:         /* XXX MSVC miscompiles such that (NaN == 0) */
53094:         if (JSDOUBLE_IS_NaN(d2))
53094:             vp = &rt->NaNValue;
53094:         else
53094: #endif
53094:         if (d1 == 0 || JSDOUBLE_IS_NaN(d1))
53094:             vp = &rt->NaNValue;
53094:         else if (JSDOUBLE_IS_NEG(d1) != JSDOUBLE_IS_NEG(d2))
53094:             vp = &rt->negativeInfinityValue;
53094:         else
53094:             vp = &rt->positiveInfinityValue;
53094:         regs.sp[-1] = *vp;
53094:     } else {
53094:         d1 /= d2;
53094:         regs.sp[-1].setNumber(d1);
53094:     }
53094: }
53094: END_CASE(JSOP_DIV)
53094: 
53094: BEGIN_CASE(JSOP_MOD)
53094: {
53094:     Value &lref = regs.sp[-2];
53094:     Value &rref = regs.sp[-1];
53094:     int32_t l, r;
53094:     if (lref.isInt32() && rref.isInt32() &&
53094:         (l = lref.toInt32()) >= 0 && (r = rref.toInt32()) > 0) {
53094:         int32_t mod = l % r;
53094:         regs.sp--;
53094:         regs.sp[-1].setInt32(mod);
53094:     } else {
53094:         double d1, d2;
53094:         if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
53094:             !ValueToNumber(cx, regs.sp[-1], &d2)) {
53094:             goto error;
53094:         }
53094:         regs.sp--;
53094:         if (d2 == 0) {
53094:             regs.sp[-1].setDouble(js_NaN);
53094:         } else {
53094:             d1 = js_fmod(d1, d2);
53094:             regs.sp[-1].setDouble(d1);
53094:         }
53094:     }
53094: }
53094: END_CASE(JSOP_MOD)
53094: 
53094: BEGIN_CASE(JSOP_NOT)
53094: {
53094:     Value *_;
53094:     bool cond;
53094:     POP_BOOLEAN(cx, _, cond);
53094:     PUSH_BOOLEAN(!cond);
53094: }
53094: END_CASE(JSOP_NOT)
53094: 
53094: BEGIN_CASE(JSOP_BITNOT)
53094: {
53094:     int32_t i;
53094:     if (!ValueToECMAInt32(cx, regs.sp[-1], &i))
53094:         goto error;
53094:     i = ~i;
53094:     regs.sp[-1].setInt32(i);
53094: }
53094: END_CASE(JSOP_BITNOT)
53094: 
53094: BEGIN_CASE(JSOP_NEG)
53094: {
53094:     /*
53094:      * When the operand is int jsval, INT32_FITS_IN_JSVAL(i) implies
53094:      * INT32_FITS_IN_JSVAL(-i) unless i is 0 or INT32_MIN when the
53094:      * results, -0.0 or INT32_MAX + 1, are jsdouble values.
53094:      */
53094:     const Value &ref = regs.sp[-1];
53094:     int32_t i;
53094:     if (ref.isInt32() && (i = ref.toInt32()) != 0 && i != INT32_MIN) {
53094:         i = -i;
53094:         regs.sp[-1].setInt32(i);
53094:     } else {
53094:         double d;
53094:         if (!ValueToNumber(cx, regs.sp[-1], &d))
53094:             goto error;
53094:         d = -d;
53094:         regs.sp[-1].setDouble(d);
53094:     }
53094: }
53094: END_CASE(JSOP_NEG)
53094: 
53094: BEGIN_CASE(JSOP_POS)
53094:     if (!ValueToNumber(cx, &regs.sp[-1]))
53094:         goto error;
53094: END_CASE(JSOP_POS)
53094: 
53094: BEGIN_CASE(JSOP_DELNAME)
53094: {
53094:     JSAtom *atom;
53094:     LOAD_ATOM(0, atom);
53094:     jsid id = ATOM_TO_JSID(atom);
53094:     JSObject *obj, *obj2;
53094:     JSProperty *prop;
53094:     if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
53094:         goto error;
53094: 
53094:     /* ECMA says to return true if name is undefined or inherited. */
53094:     PUSH_BOOLEAN(true);
53094:     if (prop) {
53094:         obj2->dropProperty(cx, prop);
53094:         if (!obj->deleteProperty(cx, id, &regs.sp[-1]))
53094:             goto error;
53094:     }
53094: }
53094: END_CASE(JSOP_DELNAME)
53094: 
53094: BEGIN_CASE(JSOP_DELPROP)
53094: {
53094:     JSAtom *atom;
53094:     LOAD_ATOM(0, atom);
53094:     jsid id = ATOM_TO_JSID(atom);
53094: 
53094:     JSObject *obj;
53094:     FETCH_OBJECT(cx, -1, obj);
53094: 
53094:     Value rval;
53094:     if (!obj->deleteProperty(cx, id, &rval))
53094:         goto error;
53094: 
53094:     regs.sp[-1] = rval;
53094: }
53094: END_CASE(JSOP_DELPROP)
53094: 
53094: BEGIN_CASE(JSOP_DELELEM)
53094: {
53094:     /* Fetch the left part and resolve it to a non-null object. */
53094:     JSObject *obj;
53094:     FETCH_OBJECT(cx, -2, obj);
53094: 
53094:     /* Fetch index and convert it to id suitable for use with obj. */
53094:     jsid id;
53094:     FETCH_ELEMENT_ID(obj, -1, id);
53094: 
53094:     /* Get or set the element. */
53094:     if (!obj->deleteProperty(cx, id, &regs.sp[-2]))
53094:         goto error;
53094: 
53094:     regs.sp--;
53094: }
53094: END_CASE(JSOP_DELELEM)
53094: 
53094: BEGIN_CASE(JSOP_TYPEOFEXPR)
53094: BEGIN_CASE(JSOP_TYPEOF)
53094: {
53094:     const Value &ref = regs.sp[-1];
53094:     JSType type = JS_TypeOfValue(cx, Jsvalify(ref));
53094:     JSAtom *atom = rt->atomState.typeAtoms[type];
53094:     regs.sp[-1].setString(ATOM_TO_STRING(atom));
53094: }
53094: END_CASE(JSOP_TYPEOF)
53094: 
53094: BEGIN_CASE(JSOP_VOID)
53094:     regs.sp[-1].setUndefined();
53094: END_CASE(JSOP_VOID)
53094: 
53094: {
53094:     JSObject *obj;
53094:     JSAtom *atom;
53094:     jsid id;
53094:     jsint i;
53094: 
53094: BEGIN_CASE(JSOP_INCELEM)
53094: BEGIN_CASE(JSOP_DECELEM)
53094: BEGIN_CASE(JSOP_ELEMINC)
53094: BEGIN_CASE(JSOP_ELEMDEC)
53094: 
53094:     /*
53094:      * Delay fetching of id until we have the object to ensure the proper
53094:      * evaluation order. See bug 372331.
53094:      */
53094:     id = JSID_VOID;
53094:     i = -2;
53094:     goto fetch_incop_obj;
53094: 
53094: BEGIN_CASE(JSOP_INCPROP)
53094: BEGIN_CASE(JSOP_DECPROP)
53094: BEGIN_CASE(JSOP_PROPINC)
53094: BEGIN_CASE(JSOP_PROPDEC)
53094:     LOAD_ATOM(0, atom);
53094:     id = ATOM_TO_JSID(atom);
53094:     i = -1;
53094: 
53094:   fetch_incop_obj:
53094:     FETCH_OBJECT(cx, i, obj);
53094:     if (JSID_IS_VOID(id))
53094:         FETCH_ELEMENT_ID(obj, -1, id);
53094:     goto do_incop;
53094: 
53094: BEGIN_CASE(JSOP_INCNAME)
53094: BEGIN_CASE(JSOP_DECNAME)
53094: BEGIN_CASE(JSOP_NAMEINC)
53094: BEGIN_CASE(JSOP_NAMEDEC)
53094: {
53094:     obj = fp->scopeChain;
53094: 
53094:     JSObject *obj2;
53094:     PropertyCacheEntry *entry;
53094:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
53094:     if (!atom) {
53094:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
53094:         if (obj == obj2 && entry->vword.isSlot()) {
53094:             uint32 slot = entry->vword.toSlot();
53094:             JS_ASSERT(slot < obj->scope()->freeslot);
53094:             Value &rref = obj->getSlotRef(slot);
53094:             int32_t tmp;
53094:             if (JS_LIKELY(rref.isInt32() && CanIncDecWithoutOverflow(tmp = rref.toInt32()))) {
53094:                 int32_t inc = tmp + ((js_CodeSpec[op].format & JOF_INC) ? 1 : -1);
53094:                 if (!(js_CodeSpec[op].format & JOF_POST))
53094:                     tmp = inc;
53094:                 rref.getInt32Ref() = inc;
53094:                 PUSH_INT32(tmp);
53094:                 len = JSOP_INCNAME_LENGTH;
53094:                 DO_NEXT_OP(len);
53094:             }
53094:         }
53094:         LOAD_ATOM(0, atom);
53094:     }
53094: 
53094:     id = ATOM_TO_JSID(atom);
53094:     JSProperty *prop;
53094:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
53094:         goto error;
53094:     if (!prop) {
53094:         atomNotDefined = atom;
53094:         goto atom_not_defined;
53094:     }
53094:     obj2->dropProperty(cx, prop);
53094: }
53094: 
53094: do_incop:
53094: {
53094:     /*
53094:      * We need a root to store the value to leave on the stack until
53094:      * we have done with obj->setProperty.
53094:      */
53094:     PUSH_NULL();
53094:     if (!obj->getProperty(cx, id, &regs.sp[-1]))
53094:         goto error;
53094: 
53094:     const JSCodeSpec *cs = &js_CodeSpec[op];
53094:     JS_ASSERT(cs->ndefs == 1);
53094:     JS_ASSERT((cs->format & JOF_TMPSLOT_MASK) == JOF_TMPSLOT2);
53094:     Value &ref = regs.sp[-1];
53094:     int32_t tmp;
53094:     if (JS_LIKELY(ref.isInt32() && CanIncDecWithoutOverflow(tmp = ref.toInt32()))) {
53094:         int incr = (cs->format & JOF_INC) ? 1 : -1;
53094:         if (cs->format & JOF_POST)
53094:             ref.getInt32Ref() = tmp + incr;
53094:         else
53094:             ref.getInt32Ref() = tmp += incr;
53094:         fp->flags |= JSFRAME_ASSIGNING;
53094:         JSBool ok = obj->setProperty(cx, id, &ref);
53094:         fp->flags &= ~JSFRAME_ASSIGNING;
53094:         if (!ok)
53094:             goto error;
53094: 
53094:         /*
53094:          * We must set regs.sp[-1] to tmp for both post and pre increments
53094:          * as the setter overwrites regs.sp[-1].
53094:          */
53094:         ref.setInt32(tmp);
53094:     } else {
53094:         /* We need an extra root for the result. */
53094:         PUSH_NULL();
53094:         if (!js_DoIncDec(cx, cs, &regs.sp[-2], &regs.sp[-1]))
53094:             goto error;
53094:         fp->flags |= JSFRAME_ASSIGNING;
53094:         JSBool ok = obj->setProperty(cx, id, &regs.sp[-1]);
53094:         fp->flags &= ~JSFRAME_ASSIGNING;
53094:         if (!ok)
53094:             goto error;
53094:         regs.sp--;
53094:     }
53094: 
53094:     if (cs->nuses == 0) {
53094:         /* regs.sp[-1] already contains the result of name increment. */
53094:     } else {
53094:         regs.sp[-1 - cs->nuses] = regs.sp[-1];
53094:         regs.sp -= cs->nuses;
53094:     }
53094:     len = cs->length;
53094:     DO_NEXT_OP(len);
53094: }
53094: }
53094: 
53094: {
53094:     int incr, incr2;
53094:     Value *vp;
53094: 
53094:     /* Position cases so the most frequent i++ does not need a jump. */
53094: BEGIN_CASE(JSOP_DECARG)
53094:     incr = -1; incr2 = -1; goto do_arg_incop;
53094: BEGIN_CASE(JSOP_ARGDEC)
53094:     incr = -1; incr2 =  0; goto do_arg_incop;
53094: BEGIN_CASE(JSOP_INCARG)
53094:     incr =  1; incr2 =  1; goto do_arg_incop;
53094: BEGIN_CASE(JSOP_ARGINC)
53094:     incr =  1; incr2 =  0;
53094: 
53094:   do_arg_incop:
53094:     // If we initialize in the declaration, MSVC complains that the labels skip init.
53094:     uint32 slot;
53094:     slot = GET_ARGNO(regs.pc);
53094:     JS_ASSERT(slot < fp->fun->nargs);
53094:     METER_SLOT_OP(op, slot);
53094:     vp = fp->argv + slot;
53094:     goto do_int_fast_incop;
53094: 
53094: BEGIN_CASE(JSOP_DECLOCAL)
53094:     incr = -1; incr2 = -1; goto do_local_incop;
53094: BEGIN_CASE(JSOP_LOCALDEC)
53094:     incr = -1; incr2 =  0; goto do_local_incop;
53094: BEGIN_CASE(JSOP_INCLOCAL)
53094:     incr =  1; incr2 =  1; goto do_local_incop;
53094: BEGIN_CASE(JSOP_LOCALINC)
53094:     incr =  1; incr2 =  0;
53094: 
53094:   /*
53094:    * do_local_incop comes right before do_int_fast_incop as we want to
53094:    * avoid an extra jump for variable cases as local++ is more frequent
53094:    * than arg++.
53094:    */
53094:   do_local_incop:
53094:     slot = GET_SLOTNO(regs.pc);
53094:     JS_ASSERT(slot < fp->script->nslots);
53094:     vp = fp->slots() + slot;
53094:     METER_SLOT_OP(op, slot);
53094:     vp = fp->slots() + slot;
53094: 
53094:   do_int_fast_incop:
53094:     int32_t tmp;
53094:     if (JS_LIKELY(vp->isInt32() && CanIncDecWithoutOverflow(tmp = vp->toInt32()))) {
53094:         vp->getInt32Ref() = tmp + incr;
53094:         JS_ASSERT(JSOP_INCARG_LENGTH == js_CodeSpec[op].length);
53094:         SKIP_POP_AFTER_SET(JSOP_INCARG_LENGTH, 0);
53094:         PUSH_INT32(tmp + incr2);
53094:     } else {
53094:         PUSH_COPY(*vp);
53094:         if (!js_DoIncDec(cx, &js_CodeSpec[op], &regs.sp[-1], vp))
53094:             goto error;
53094:     }
53094:     len = JSOP_INCARG_LENGTH;
53094:     JS_ASSERT(len == js_CodeSpec[op].length);
53094:     DO_NEXT_OP(len);
53094: }
53094: 
53094: /* NB: This macro doesn't use JS_BEGIN_MACRO/JS_END_MACRO around its body. */
53094: #define FAST_GLOBAL_INCREMENT_OP(SLOWOP,INCR,INCR2)                           \
53094:     op2 = SLOWOP;                                                             \
53094:     incr = INCR;                                                              \
53094:     incr2 = INCR2;                                                            \
53094:     goto do_global_incop
53094: 
53094: {
53094:     JSOp op2;
53094:     int incr, incr2;
53094: 
53094: BEGIN_CASE(JSOP_DECGVAR)
53094:     FAST_GLOBAL_INCREMENT_OP(JSOP_DECNAME, -1, -1);
53094: BEGIN_CASE(JSOP_GVARDEC)
53094:     FAST_GLOBAL_INCREMENT_OP(JSOP_NAMEDEC, -1,  0);
53094: BEGIN_CASE(JSOP_INCGVAR)
53094:     FAST_GLOBAL_INCREMENT_OP(JSOP_INCNAME,  1,  1);
53094: BEGIN_CASE(JSOP_GVARINC)
53094:     FAST_GLOBAL_INCREMENT_OP(JSOP_NAMEINC,  1,  0);
53094: 
53094: #undef FAST_GLOBAL_INCREMENT_OP
53094: 
53094:   do_global_incop:
53094:     JS_ASSERT((js_CodeSpec[op].format & JOF_TMPSLOT_MASK) ==
53094:               JOF_TMPSLOT2);
53094:     uint32 slot = GET_SLOTNO(regs.pc);
53094:     JS_ASSERT(slot < GlobalVarCount(fp));
53094:     METER_SLOT_OP(op, slot);
53094:     const Value &lref = fp->slots()[slot];
53094:     if (lref.isNull()) {
53094:         op = op2;
53094:         DO_OP();
53094:     }
53094:     slot = (uint32)lref.toInt32();
53094:     JS_ASSERT(fp->varobj(cx) == cx->activeCallStack()->getInitialVarObj());
53094:     JSObject *varobj = cx->activeCallStack()->getInitialVarObj();
53094: 
53094:     /* XXX all this code assumes that varobj is either a callobj or global and
53094:      * that it cannot be accessed in a MT way. This is either true now or
53094:      * coming soon. */
53094: 
53094:     Value &rref = varobj->getSlotRef(slot);
53094:     int32_t tmp;
53094:     if (JS_LIKELY(rref.isInt32() && CanIncDecWithoutOverflow(tmp = rref.toInt32()))) {
53094:         PUSH_INT32(tmp + incr2);
53094:         rref.getInt32Ref() = tmp + incr;
53094:     } else {
53094:         PUSH_COPY(rref);
53094:         if (!js_DoIncDec(cx, &js_CodeSpec[op], &regs.sp[-1], &rref))
53094:             goto error;
53094:     }
53094:     len = JSOP_INCGVAR_LENGTH;  /* all gvar incops are same length */
53094:     JS_ASSERT(len == js_CodeSpec[op].length);
53094:     DO_NEXT_OP(len);
53094: }
53094: 
53094: BEGIN_CASE(JSOP_THIS)
53094:     if (!fp->getThisObject(cx))
53094:         goto error;
53094:     PUSH_COPY(fp->thisv);
53094: END_CASE(JSOP_THIS)
53094: 
53094: BEGIN_CASE(JSOP_UNBRANDTHIS)
53094: {
53094:     JSObject *obj = fp->getThisObject(cx);
53094:     if (!obj)
53094:         goto error;
53094:     if (!obj->unbrand(cx))
53094:         goto error;
53094: }
53094: END_CASE(JSOP_UNBRANDTHIS)
53094: 
53094: {
53094:     JSObject *obj;
53094:     Value *vp;
53094:     jsint i;
53094: 
53094: BEGIN_CASE(JSOP_GETTHISPROP)
53094:     obj = fp->getThisObject(cx);
53094:     if (!obj)
53094:         goto error;
53094:     i = 0;
53094:     PUSH_NULL();
53094:     goto do_getprop_with_obj;
53094: 
53094: BEGIN_CASE(JSOP_GETARGPROP)
53094: {
53094:     i = ARGNO_LEN;
53094:     uint32 slot = GET_ARGNO(regs.pc);
53094:     JS_ASSERT(slot < fp->fun->nargs);
53094:     PUSH_COPY(fp->argv[slot]);
53094:     goto do_getprop_body;
53094: }
53094: 
53094: BEGIN_CASE(JSOP_GETLOCALPROP)
53094: {
53094:     i = SLOTNO_LEN;
53094:     uint32 slot = GET_SLOTNO(regs.pc);
53094:     JS_ASSERT(slot < script->nslots);
53094:     PUSH_COPY(fp->slots()[slot]);
53094:     goto do_getprop_body;
53094: }
53094: 
53094: BEGIN_CASE(JSOP_GETPROP)
53094: BEGIN_CASE(JSOP_GETXPROP)
53094:     i = 0;
53094: 
53094:   do_getprop_body:
53094:     vp = &regs.sp[-1];
53094: 
53094:   do_getprop_with_lval:
53094:     VALUE_TO_OBJECT(cx, vp, obj);
53094: 
53094:   do_getprop_with_obj:
53094:     {
53094:         Value rval;
53094:         do {
53094:             /*
53094:              * We do not impose the method read barrier if in an imacro,
53094:              * assuming any property gets it does (e.g., for 'toString'
53094:              * from JSOP_NEW) will not be leaked to the calling script.
53094:              */
53094:             JSObject *aobj = js_GetProtoIfDenseArray(obj);
53094: 
53094:             PropertyCacheEntry *entry;
53094:             JSObject *obj2;
53094:             JSAtom *atom;
53094:             JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
53094:             if (!atom) {
53094:                 ASSERT_VALID_PROPERTY_CACHE_HIT(i, aobj, obj2, entry);
53094:                 if (entry->vword.isFunObj()) {
53094:                     rval.setObject(entry->vword.toFunObj());
53094:                 } else if (entry->vword.isSlot()) {
53094:                     uint32 slot = entry->vword.toSlot();
53094:                     JS_ASSERT(slot < obj2->scope()->freeslot);
53094:                     rval = obj2->lockedGetSlot(slot);
53094:                 } else {
53094:                     JS_ASSERT(entry->vword.isSprop());
53094:                     JSScopeProperty *sprop = entry->vword.toSprop();
53094:                     NATIVE_GET(cx, obj, obj2, sprop,
53094:                                fp->imacpc ? JSGET_NO_METHOD_BARRIER : JSGET_METHOD_BARRIER,
53094:                                &rval);
53094:                 }
53094:                 break;
53094:             }
53094: 
53094:             jsid id = ATOM_TO_JSID(atom);
53094:             if (JS_LIKELY(aobj->map->ops->getProperty == js_GetProperty)
53094:                 ? !js_GetPropertyHelper(cx, obj, id,
53094:                                         fp->imacpc
53094:                                         ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
53094:                                         : JSGET_CACHE_RESULT | JSGET_METHOD_BARRIER,
53094:                                         &rval)
53094:                 : !obj->getProperty(cx, id, &rval)) {
53094:                 goto error;
53094:             }
53094:         } while (0);
53094: 
53094:         regs.sp[-1] = rval;
53094:         JS_ASSERT(JSOP_GETPROP_LENGTH + i == js_CodeSpec[op].length);
53094:         len = JSOP_GETPROP_LENGTH + i;
53094:     }
53094: END_VARLEN_CASE
53094: 
53094: BEGIN_CASE(JSOP_LENGTH)
53094:     vp = &regs.sp[-1];
53094:     if (vp->isString()) {
53094:         vp->setInt32(vp->toString()->length());
53094:     } else if (vp->isObject()) {
53094:         JSObject *obj = &vp->toObject();
53094:         if (obj->isArray()) {
53094:             jsuint length = obj->getArrayLength();
53094:             regs.sp[-1].setNumber(length);
53094:         } else if (obj->isArguments() && !obj->isArgsLengthOverridden()) {
53094:             uint32 length = obj->getArgsLength();
53094:             JS_ASSERT(length < INT32_MAX);
53094:             regs.sp[-1].setInt32(int32_t(length));
53094:         } else {
53094:             i = -2;
53094:             goto do_getprop_with_lval;
53094:         }
53094:     } else {
53094:         i = -2;
53094:         goto do_getprop_with_lval;
53094:     }
53094: END_CASE(JSOP_LENGTH)
53094: 
53094: }
53094: 
53094: BEGIN_CASE(JSOP_CALLPROP)
53094: {
53094:     Value lval = regs.sp[-1];
53094: 
53094:     Value objv;
53094:     if (lval.isObject()) {
53094:         objv = lval;
53094:     } else {
53094:         JSProtoKey protoKey;
53094:         if (lval.isString()) {
53094:             protoKey = JSProto_String;
53094:         } else if (lval.isNumber()) {
53094:             protoKey = JSProto_Number;
53094:         } else if (lval.isBoolean()) {
53094:             protoKey = JSProto_Boolean;
53094:         } else {
53094:             JS_ASSERT(lval.isNull() || lval.isUndefined());
53094:             js_ReportIsNullOrUndefined(cx, -1, lval, NULL);
53094:             goto error;
53094:         }
53094:         JSObject *pobj;
53094:         if (!js_GetClassPrototype(cx, NULL, protoKey, &pobj))
53094:             goto error;
53094:         objv.setObject(*pobj);
53094:     }
53094: 
53094:     JSObject *aobj = js_GetProtoIfDenseArray(&objv.toObject());
53094:     Value rval;
53094: 
53094:     PropertyCacheEntry *entry;
53094:     JSObject *obj2;
53094:     JSAtom *atom;
53094:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
53094:     if (!atom) {
53094:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, aobj, obj2, entry);
53094:         if (entry->vword.isFunObj()) {
53094:             rval.setObject(entry->vword.toFunObj());
53094:         } else if (entry->vword.isSlot()) {
53094:             uint32 slot = entry->vword.toSlot();
53094:             JS_ASSERT(slot < obj2->scope()->freeslot);
53094:             rval = obj2->lockedGetSlot(slot);
53094:         } else {
53094:             JS_ASSERT(entry->vword.isSprop());
53094:             JSScopeProperty *sprop = entry->vword.toSprop();
53094:             NATIVE_GET(cx, &objv.toObject(), obj2, sprop, JSGET_NO_METHOD_BARRIER, &rval);
53094:         }
53094:         regs.sp[-1] = rval;
53094:         PUSH_COPY(lval);
53094:         goto end_callprop;
53094:     }
53094: 
53094:     /*
53094:      * Cache miss: use the immediate atom that was loaded for us under
53094:      * PropertyCache::test.
53094:      */
53094:     jsid id;
53094:     id = ATOM_TO_JSID(atom);
53094: 
53094:     PUSH_NULL();
53094:     if (lval.isObject()) {
53094:         if (!js_GetMethod(cx, &objv.toObject(), id,
53094:                           JS_LIKELY(aobj->map->ops->getProperty == js_GetProperty)
53094:                           ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
53094:                           : JSGET_NO_METHOD_BARRIER,
53094:                           &rval)) {
53094:             goto error;
53094:         }
53094:         regs.sp[-1] = objv;
53094:         regs.sp[-2] = rval;
53094:     } else {
53094:         JS_ASSERT(objv.toObject().map->ops->getProperty == js_GetProperty);
53094:         if (!js_GetPropertyHelper(cx, &objv.toObject(), id,
53094:                                   JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER,
53094:                                   &rval)) {
53094:             goto error;
53094:         }
53094:         regs.sp[-1] = lval;
53094:         regs.sp[-2] = rval;
53094:     }
53094: 
53094:   end_callprop:
53094:     /* Wrap primitive lval in object clothing if necessary. */
53094:     if (lval.isPrimitive()) {
53094:         /* FIXME: https://bugzilla.mozilla.org/show_bug.cgi?id=412571 */
53094:         JSObject *funobj;
53094:         if (!IsFunctionObject(rval, &funobj) ||
53094:             !PrimitiveThisTest(GET_FUNCTION_PRIVATE(cx, funobj), lval)) {
53094:             if (!js_PrimitiveToObject(cx, &regs.sp[-1]))
53094:                 goto error;
53094:         }
53094:     }
53094: #if JS_HAS_NO_SUCH_METHOD
53094:     if (JS_UNLIKELY(rval.isUndefined())) {
53094:         LOAD_ATOM(0, atom);
53094:         regs.sp[-2].setString(ATOM_TO_STRING(atom));
53094:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
53094:             goto error;
53094:     }
53094: #endif
53094: }
53094: END_CASE(JSOP_CALLPROP)
53094: 
53094: BEGIN_CASE(JSOP_UNBRAND)
53094:     JS_ASSERT(regs.sp - fp->slots() >= 1);
53094:     if (!regs.sp[-1].toObject().unbrand(cx))
53094:         goto error;
53094: END_CASE(JSOP_UNBRAND)
53094: 
53094: BEGIN_CASE(JSOP_SETNAME)
53094: BEGIN_CASE(JSOP_SETPROP)
53094: BEGIN_CASE(JSOP_SETMETHOD)
53094: {
53094:     Value &rref = regs.sp[-1];
53094:     JS_ASSERT_IF(op == JSOP_SETMETHOD, IsFunctionObject(rref));
53094:     Value &lref = regs.sp[-2];
53094:     JS_ASSERT_IF(op == JSOP_SETNAME, lref.isObject());
53094:     JSObject *obj;
53094:     VALUE_TO_OBJECT(cx, &lref, obj);
53094: 
53094:     do {
53094:         PropertyCache *cache = &JS_PROPERTY_CACHE(cx);
53094: 
53094:         /*
53094:          * Probe the property cache, specializing for two important
53094:          * set-property cases. First:
53094:          *
53094:          *   function f(a, b, c) {
53094:          *     var o = {p:a, q:b, r:c};
53094:          *     return o;
53094:          *   }
53094:          *
53094:          * or similar real-world cases, which evolve a newborn native
53094:          * object predicatably through some bounded number of property
53094:          * additions. And second:
53094:          *
53094:          *   o.p = x;
53094:          *
53094:          * in a frequently executed method or loop body, where p will
53094:          * (possibly after the first iteration) always exist in native
53094:          * object o.
53094:          */
53094:         PropertyCacheEntry *entry;
53094:         JSObject *obj2;
53094:         JSAtom *atom;
53094:         if (cache->testForSet(cx, regs.pc, obj, &entry, &obj2, &atom)) {
53094:             /*
53094:              * Fast property cache hit, only partially confirmed by
53094:              * testForSet. We know that the entry applies to regs.pc and
53094:              * that obj's shape matches.
53094:              *
53094:              * The entry predicts either a new property to be added
53094:              * directly to obj by this set, or on an existing "own"
53094:              * property, or on a prototype property that has a setter.
53094:              */
53094:             JS_ASSERT(entry->vword.isSprop());
53094:             JSScopeProperty *sprop = entry->vword.toSprop();
53094:             JS_ASSERT_IF(sprop->isDataDescriptor(), sprop->writable());
53094:             JS_ASSERT_IF(sprop->hasSlot(), entry->vcapTag() == 0);
53094: 
53094:             JSScope *scope = obj->scope();
53094:             JS_ASSERT(!scope->sealed());
53094: 
53094:             /*
53094:              * Fastest path: check whether the cached sprop is already
53094:              * in scope and call NATIVE_SET and break to get out of the
53094:              * do-while(0). But we can call NATIVE_SET only if obj owns
53094:              * scope or sprop is shared.
53094:              */
53094:             bool checkForAdd;
53094:             if (!sprop->hasSlot()) {
53094:                 if (entry->vcapTag() == 0 ||
53094:                     ((obj2 = obj->getProto()) &&
53094:                      obj2->isNative() &&
53094:                      obj2->shape() == entry->vshape())) {
53094:                     goto fast_set_propcache_hit;
53094:                 }
53094: 
53094:                 /* The cache entry doesn't apply. vshape mismatch. */
53094:                 checkForAdd = false;
53094:             } else if (!scope->isSharedEmpty()) {
53094:                 if (sprop == scope->lastProperty() || scope->hasProperty(sprop)) {
53094:                   fast_set_propcache_hit:
53094:                     PCMETER(cache->pchits++);
53094:                     PCMETER(cache->setpchits++);
53094:                     NATIVE_SET(cx, obj, sprop, entry, &rref);
53094:                     break;
53094:                 }
53094:                 checkForAdd = sprop->hasSlot() && sprop->parent == scope->lastProperty();
53094:             } else {
53094:                 /*
53094:                  * We check that cx own obj here and will continue to
53094:                  * own it after js_GetMutableScope returns so we can
53094:                  * continue to skip JS_UNLOCK_OBJ calls.
53094:                  */
53094:                 JS_ASSERT(CX_OWNS_OBJECT_TITLE(cx, obj));
53094:                 scope = js_GetMutableScope(cx, obj);
53094:                 JS_ASSERT(CX_OWNS_OBJECT_TITLE(cx, obj));
53094:                 if (!scope)
53094:                     goto error;
53094:                 checkForAdd = !sprop->parent;
53094:             }
53094: 
53094:             uint32 slot;
53094:             if (checkForAdd &&
53094:                 entry->vshape() == rt->protoHazardShape &&
53094:                 sprop->hasDefaultSetter() &&
53094:                 (slot = sprop->slot) == scope->freeslot) {
53094:                 /*
53094:                  * Fast path: adding a plain old property that was once
53094:                  * at the frontier of the property tree, whose slot is
53094:                  * next to claim among the allocated slots in obj,
53094:                  * where scope->table has not been created yet.
53094:                  *
53094:                  * We may want to remove hazard conditions above and
53094:                  * inline compensation code here, depending on
53094:                  * real-world workloads.
53094:                  */
53094:                 PCMETER(cache->pchits++);
53094:                 PCMETER(cache->addpchits++);
53094: 
53094:                 if (slot < obj->numSlots()) {
53094:                     ++scope->freeslot;
53094:                 } else {
53094:                     if (!js_AllocSlot(cx, obj, &slot))
53094:                         goto error;
53094:                     JS_ASSERT(slot + 1 == scope->freeslot);
53094:                 }
53094: 
53094:                 /*
53094:                  * If this obj's number of reserved slots differed, or
53094:                  * if something created a hash table for scope, we must
53094:                  * pay the price of JSScope::putProperty.
53094:                  *
53094:                  * (A built-in object with a pre-allocated but not fixed
53094:                  * population of reserved slots  hook can cause scopes of the
53094:                  * same shape to have different freeslot values. Arguments,
53094:                  * Block, Call, and certain Function objects pre-allocate
53094:                  * reserveds lots this way. This is what causes the slot !=
53094:                  * sprop->slot case. See js_GetMutableScope. FIXME 558451)
53094:                  */
53094:                 if (slot == sprop->slot && !scope->table) {
53094:                     scope->extend(cx, sprop);
53094:                 } else {
53094:                     JSScopeProperty *sprop2 =
53094:                         scope->putProperty(cx, sprop->id,
53094:                                            sprop->getter(), sprop->setter(),
53094:                                            slot, sprop->attributes(),
53094:                                            sprop->getFlags(), sprop->shortid);
53094:                     if (!sprop2) {
53094:                         js_FreeSlot(cx, obj, slot);
53094:                         goto error;
53094:                     }
53094:                     sprop = sprop2;
53094:                 }
53094: 
53094:                 /*
53094:                  * No method change check here because here we are
53094:                  * adding a new property, not updating an existing
53094:                  * slot's value that might contain a method of a
53094:                  * branded scope.
53094:                  */
53094:                 TRACE_2(SetPropHit, entry, sprop);
53094:                 obj->lockedSetSlot(slot, rref);
53094: 
53094:                 /*
53094:                  * Purge the property cache of the id we may have just
53094:                  * shadowed in obj's scope and proto chains. We do this
53094:                  * after unlocking obj's scope to avoid lock nesting.
53094:                  */
53094:                 js_PurgeScopeChain(cx, obj, sprop->id);
53094:                 break;
53094:             }
53094:             PCMETER(cache->setpcmisses++);
53094:             atom = NULL;
53094:         } else if (!atom) {
53094:             /*
53094:              * Slower property cache hit, fully confirmed by testForSet (in
53094:              * the slow path, via fullTest).
53094:              */
53094:             ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
53094:             JSScopeProperty *sprop = NULL;
53094:             if (obj == obj2) {
53094:                 sprop = entry->vword.toSprop();
53094:                 JS_ASSERT(sprop->writable());
53094:                 JS_ASSERT(!obj2->scope()->sealed());
53094:                 NATIVE_SET(cx, obj, sprop, entry, &rref);
53094:             }
53094:             if (sprop)
53094:                 break;
53094:         }
53094: 
53094:         if (!atom)
53094:             LOAD_ATOM(0, atom);
53094:         jsid id = ATOM_TO_JSID(atom);
53094:         if (entry && JS_LIKELY(obj->map->ops->setProperty == js_SetProperty)) {
53094:             uintN defineHow;
53094:             if (op == JSOP_SETMETHOD)
53094:                 defineHow = JSDNP_CACHE_RESULT | JSDNP_SET_METHOD;
53094:             else if (op == JSOP_SETNAME)
53094:                 defineHow = JSDNP_CACHE_RESULT | JSDNP_UNQUALIFIED;
53094:             else
53094:                 defineHow = JSDNP_CACHE_RESULT;
53094:             if (!js_SetPropertyHelper(cx, obj, id, defineHow, &rref))
53094:                 goto error;
53094:         } else {
53094:             if (!obj->setProperty(cx, id, &rref))
53094:                 goto error;
53094:             ABORT_RECORDING(cx, "Non-native set");
53094:         }
53094:     } while (0);
53094: }
53094: END_SET_CASE_STORE_RVAL(JSOP_SETPROP, 2);
53094: 
53094: BEGIN_CASE(JSOP_GETELEM)
53094: {
53094:     Value &lref = regs.sp[-2];
53094:     Value &rref = regs.sp[-1];
53094:     if (lref.isString() && rref.isInt32()) {
53094:         JSString *str = lref.toString();
53094:         int32_t i = rref.toInt32();
53094:         if (size_t(i) < str->length()) {
53094:             str = JSString::getUnitString(cx, str, size_t(i));
53094:             if (!str)
53094:                 goto error;
53094:             regs.sp--;
53094:             regs.sp[-1].setString(str);
53094:             len = JSOP_GETELEM_LENGTH;
53094:             DO_NEXT_OP(len);
53094:         }
53094:     }
53094: 
53094:     JSObject *obj;
53094:     VALUE_TO_OBJECT(cx, &lref, obj);
53094: 
53094:     const Value *copyFrom;
53094:     Value rval;
53094:     jsid id;
53094:     if (rref.isInt32()) {
53094:         int32_t i = rref.toInt32();
53094:         if (obj->isDenseArray()) {
53094:             jsuint idx = jsuint(i);
53094: 
53094:             if (idx < obj->getArrayLength() &&
53094:                 idx < obj->getDenseArrayCapacity()) {
53094:                 copyFrom = obj->addressOfDenseArrayElement(idx);
53094:                 if (!copyFrom->isMagic())
53094:                     goto end_getelem;
53094: 
53094:                 /* Reload retval from the stack in the rare hole case. */
53094:                 copyFrom = &regs.sp[-1];
53094:             }
53094:         } else if (obj->isArguments()
53094: #ifdef JS_TRACER
53094:                    && !GetArgsPrivateNative(obj)
53094: #endif
53094:                   ) {
53094:             uint32 arg = uint32(i);
53094: 
53094:             if (arg < obj->getArgsLength()) {
53094:                 JSStackFrame *afp = (JSStackFrame *) obj->getPrivate();
53094:                 if (afp) {
53094:                     copyFrom = &afp->argv[arg];
53094:                     goto end_getelem;
53094:                 }
53094: 
53094:                 copyFrom = obj->addressOfArgsElement(arg);
53094:                 if (!copyFrom->isMagic())
53094:                     goto end_getelem;
53094:                 copyFrom = &regs.sp[-1];
53094:             }
53094:         }
53094:         if (JS_LIKELY(INT_FITS_IN_JSID(i)))
53094:             id = INT_TO_JSID(i);
53094:         else
53094:             goto intern_big_int;
53094:     } else {
53094:       intern_big_int:
53094:         if (!js_InternNonIntElementId(cx, obj, rref, &id))
53094:             goto error;
53094:     }
53094: 
53094:     if (!obj->getProperty(cx, id, &rval))
53094:         goto error;
53094:     copyFrom = &rval;
53094: 
53094:   end_getelem:
53094:     regs.sp--;
53094:     regs.sp[-1] = *copyFrom;
53094: }
53094: END_CASE(JSOP_GETELEM)
53094: 
53094: BEGIN_CASE(JSOP_CALLELEM)
53094: {
53094:     /* Fetch the left part and resolve it to a non-null object. */
53094:     JSObject *obj;
53094:     FETCH_OBJECT(cx, -2, obj);
53094: 
53094:     /* Fetch index and convert it to id suitable for use with obj. */
53094:     jsid id;
53094:     FETCH_ELEMENT_ID(obj, -1, id);
53094: 
53094:     /* Get or set the element. */
53094:     if (!js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, &regs.sp[-2]))
53094:         goto error;
53094: 
53094: #if JS_HAS_NO_SUCH_METHOD
53094:     if (JS_UNLIKELY(regs.sp[-2].isUndefined())) {
53094:         regs.sp[-2] = regs.sp[-1];
53094:         regs.sp[-1].setObject(*obj);
53094:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
53094:             goto error;
53094:     } else
53094: #endif
53094:     {
53094:         regs.sp[-1].setObject(*obj);
53094:     }
53094: }
53094: END_CASE(JSOP_CALLELEM)
53094: 
53094: BEGIN_CASE(JSOP_SETELEM)
53094: {
53094:     JSObject *obj;
53094:     FETCH_OBJECT(cx, -3, obj);
53094:     jsid id;
53094:     FETCH_ELEMENT_ID(obj, -2, id);
53094:     do {
53094:         if (obj->isDenseArray() && JSID_IS_INT(id)) {
53094:             jsuint length = obj->getDenseArrayCapacity();
53094:             jsint i = JSID_TO_INT(id);
53094:             if ((jsuint)i < length) {
53094:                 if (obj->getDenseArrayElement(i).isMagic(JS_ARRAY_HOLE)) {
53094:                     if (js_PrototypeHasIndexedProperties(cx, obj))
53094:                         break;
53094:                     if ((jsuint)i >= obj->getArrayLength())
53094:                         obj->setDenseArrayLength(i + 1);
53094:                     obj->incDenseArrayCountBy(1);
53094:                 }
53094:                 obj->setDenseArrayElement(i, regs.sp[-1]);
53094:                 goto end_setelem;
53094:             }
53094:         }
53094:     } while (0);
53094:     if (!obj->setProperty(cx, id, &regs.sp[-1]))
53094:         goto error;
53094:   end_setelem:;
53094: }
53094: END_SET_CASE_STORE_RVAL(JSOP_SETELEM, 3)
53094: 
53094: BEGIN_CASE(JSOP_ENUMELEM)
53094: {
53094:     /* Funky: the value to set is under the [obj, id] pair. */
53094:     JSObject *obj;
53094:     FETCH_OBJECT(cx, -2, obj);
53094:     jsid id;
53094:     FETCH_ELEMENT_ID(obj, -1, id);
53094:     if (!obj->setProperty(cx, id, &regs.sp[-3]))
53094:         goto error;
53094:     regs.sp -= 3;
53094: }
53094: END_CASE(JSOP_ENUMELEM)
53094: 
53094: {
53094:     JSFunction *fun;
53094:     JSObject *obj;
53094:     uintN flags;
53094:     uintN argc;
53094:     Value *vp;
53094: 
53094: BEGIN_CASE(JSOP_NEW)
53094: {
53094:     /* Get immediate argc and find the constructor function. */
53094:     argc = GET_ARGC(regs.pc);
53094:     vp = regs.sp - (2 + argc);
53094:     JS_ASSERT(vp >= fp->base());
53094: 
53094:     /*
53094:      * Assign lval, obj, and fun exactly as the code at inline_call: expects to
53094:      * find them, to avoid nesting a js_Interpret call via js_InvokeConstructor.
53094:      */
53094:     if (IsFunctionObject(vp[0], &obj)) {
53094:         fun = GET_FUNCTION_PRIVATE(cx, obj);
53094:         if (fun->isInterpreted()) {
53094:             /* Root as we go using vp[1]. */
53094:             if (!obj->getProperty(cx,
53094:                                   ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
53094:                                   &vp[1])) {
53094:                 goto error;
53094:             }
53094:             JSObject *proto = vp[1].isObject() ? &vp[1].toObject() : NULL;
53094:             JSObject *obj2 = NewObject(cx, &js_ObjectClass, proto, obj->getParent());
53094:             if (!obj2)
53094:                 goto error;
53094: 
53094:             if (fun->u.i.script->isEmpty()) {
53094:                 vp[0].setObject(*obj2);
53094:                 regs.sp = vp + 1;
53094:                 goto end_new;
53094:             }
53094: 
53094:             vp[1].setObject(*obj2);
53094:             flags = JSFRAME_CONSTRUCTING;
53094:             goto inline_call;
53094:         }
53094:     }
53094: 
53094:     if (!InvokeConstructor(cx, InvokeArgsGuard(vp, argc)))
53094:         goto error;
53094:     regs.sp = vp + 1;
53094:     CHECK_INTERRUPT_HANDLER();
53094:     TRACE_0(NativeCallComplete);
53094: 
53094:   end_new:;
53094: }
53094: END_CASE(JSOP_NEW)
53094: 
53094: BEGIN_CASE(JSOP_CALL)
53094: BEGIN_CASE(JSOP_EVAL)
53094: BEGIN_CASE(JSOP_APPLY)
53094: {
53094:     argc = GET_ARGC(regs.pc);
53094:     vp = regs.sp - (argc + 2);
53094: 
53094:     if (IsFunctionObject(*vp, &obj)) {
53094:         fun = GET_FUNCTION_PRIVATE(cx, obj);
53094: 
53094:         /* Clear frame flags since this is not a constructor call. */
53094:         flags = 0;
53094:         if (FUN_INTERPRETED(fun))
53094:       inline_call:
53094:         {
53094:             JSScript *newscript = fun->u.i.script;
53094:             if (JS_UNLIKELY(newscript->isEmpty())) {
53094:                 vp->setUndefined();
53094:                 regs.sp = vp + 1;
53094:                 goto end_call;
53094:             }
53094: 
53094:             /* Restrict recursion of lightweight functions. */
53094:             if (JS_UNLIKELY(inlineCallCount >= JS_MAX_INLINE_CALL_COUNT)) {
53094:                 js_ReportOverRecursed(cx);
53094:                 goto error;
53094:             }
53094: 
53094:             /*
53094:              * Get pointer to new frame/slots, without changing global state.
53094:              * Initialize missing args if there are any.
53094:              */
53094:             StackSpace &stack = cx->stack();
53094:             uintN nfixed = newscript->nslots;
53094:             uintN funargs = fun->nargs;
53094:             JSStackFrame *newfp;
53094:             if (argc < funargs) {
53094:                 uintN missing = funargs - argc;
53094:                 newfp = stack.getInlineFrame(cx, regs.sp, missing, nfixed);
53094:                 if (!newfp)
53094:                     goto error;
53094:                 SetValueRangeToUndefined(regs.sp, missing);
53094:             } else {
53094:                 newfp = stack.getInlineFrame(cx, regs.sp, 0, nfixed);
53094:                 if (!newfp)
53094:                     goto error;
53094:             }
53094: 
53094:             /* Initialize stack frame. */
53094:             newfp->callobj = NULL;
53094:             newfp->argsobj = NULL;
53094:             newfp->script = newscript;
53094:             newfp->fun = fun;
53094:             newfp->argc = argc;
53094:             newfp->argv = vp + 2;
53094:             newfp->rval = UndefinedValue();
53094:             newfp->annotation = NULL;
53094:             newfp->scopeChain = obj->getParent();
53094:             newfp->flags = flags;
53094:             newfp->blockChain = NULL;
53094:             if (JS_LIKELY(newscript->staticLevel < JS_DISPLAY_SIZE)) {
53094:                 JSStackFrame **disp = &cx->display[newscript->staticLevel];
53094:                 newfp->displaySave = *disp;
53094:                 *disp = newfp;
53094:             }
53094:             JS_ASSERT(!JSFUN_BOUND_METHOD_TEST(fun->flags));
53094:             newfp->thisv = vp[1];
53094:             newfp->imacpc = NULL;
53094: 
53094:             /* Push void to initialize local variables. */
53094:             Value *newsp = newfp->base();
53094:             SetValueRangeToUndefined(newfp->slots(), newsp);
53094: 
53094:             /* Switch version if currentVersion wasn't overridden. */
53094:             newfp->callerVersion = (JSVersion) cx->version;
53094:             if (JS_LIKELY(cx->version == currentVersion)) {
53094:                 currentVersion = (JSVersion) newscript->version;
53094:                 if (JS_UNLIKELY(currentVersion != cx->version))
53094:                     js_SetVersion(cx, currentVersion);
53094:             }
53094: 
53094:             /* Push the frame. */
53094:             stack.pushInlineFrame(cx, fp, regs.pc, newfp);
53094: 
53094:             /* Initializer regs after pushInlineFrame snapshots pc. */
53094:             regs.pc = newscript->code;
53094:             regs.sp = newsp;
53094: 
53094:             /* Import into locals. */
53094:             JS_ASSERT(newfp == cx->fp);
53094:             fp = newfp;
53094:             script = newscript;
53094:             atoms = script->atomMap.vector;
53094: 
53094:             /* Now that the new frame is rooted, maybe create a call object. */
53094:             if (fun->isHeavyweight() && !js_GetCallObject(cx, fp))
53094:                 goto error;
53094: 
53094:             /* Call the debugger hook if present. */
53094:             if (JSInterpreterHook hook = cx->debugHooks->callHook) {
53094:                 fp->hookData = hook(cx, fp, JS_TRUE, 0,
53094:                                     cx->debugHooks->callHookData);
53094:                 CHECK_INTERRUPT_HANDLER();
53094:             } else {
53094:                 fp->hookData = NULL;
53094:             }
53094: 
53094:             inlineCallCount++;
53094:             JS_RUNTIME_METER(rt, inlineCalls);
53094: 
53094:             DTrace::enterJSFun(cx, fp, fun, fp->down, fp->argc, fp->argv);
53094: 
53094: #ifdef JS_TRACER
53094:             if (TraceRecorder *tr = TRACE_RECORDER(cx)) {
53094:                 AbortableRecordingStatus status = tr->record_EnterFrame(inlineCallCount);
53094:                 RESTORE_INTERP_VARS();
53094:                 if (StatusAbortsRecorderIfActive(status)) {
53094:                     if (TRACE_RECORDER(cx)) {
53094:                         JS_ASSERT(TRACE_RECORDER(cx) == tr);
53094:                         AbortRecording(cx, "record_EnterFrame failed");
53094:                     }
53094:                     if (status == ARECORD_ERROR)
53094:                         goto error;
53094:                 }
53094:             } else if (fp->script == fp->down->script &&
53094:                        *fp->down->savedPC == JSOP_CALL &&
53094:                        *regs.pc == JSOP_TRACE) {
53094:                 MONITOR_BRANCH(Record_EnterFrame);
53094:             }
53094: #endif
53094: 
53094:             /* Load first op and dispatch it (safe since JSOP_STOP). */
53094:             op = (JSOp) *regs.pc;
53094:             DO_OP();
53094:         }
53094: 
53094:         if (fun->flags & JSFUN_FAST_NATIVE) {
53094:             DTrace::enterJSFun(cx, NULL, fun, fp, argc, vp + 2, vp);
53094: 
53094:             JS_ASSERT(fun->u.n.extra == 0);
53094:             JS_ASSERT(vp[1].isObjectOrNull() || PrimitiveThisTest(fun, vp[1]));
53094:             JSBool ok = ((FastNative) fun->u.n.native)(cx, argc, vp);
53094:             DTrace::exitJSFun(cx, NULL, fun, *vp, vp);
53094:             regs.sp = vp + 1;
53094:             if (!ok)
53094:                 goto error;
53094:             TRACE_0(NativeCallComplete);
53094:             goto end_call;
53094:         }
53094:     }
53094: 
53094:     bool ok;
53094:     ok = Invoke(cx, InvokeArgsGuard(vp, argc), 0);
53094:     regs.sp = vp + 1;
53094:     CHECK_INTERRUPT_HANDLER();
53094:     if (!ok)
53094:         goto error;
53094:     JS_RUNTIME_METER(rt, nonInlineCalls);
53094:     TRACE_0(NativeCallComplete);
53094: 
53094:   end_call:;
53094: }
53094: END_CASE(JSOP_CALL)
53094: }
53094: 
53094: BEGIN_CASE(JSOP_SETCALL)
53094: {
53094:     uintN argc = GET_ARGC(regs.pc);
53094:     Value *vp = regs.sp - argc - 2;
53094:     JSBool ok = Invoke(cx, InvokeArgsGuard(vp, argc), 0);
53094:     if (ok)
53094:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_LEFTSIDE_OF_ASS);
53094:     goto error;
53094: }
53094: END_CASE(JSOP_SETCALL)
53094: 
53094: BEGIN_CASE(JSOP_NAME)
53094: BEGIN_CASE(JSOP_CALLNAME)
53094: {
53094:     JSObject *obj = fp->scopeChain;
53094: 
53094:     JSScopeProperty *sprop;
53094:     Value rval;
53094: 
53094:     PropertyCacheEntry *entry;
53094:     JSObject *obj2;
53094:     JSAtom *atom;
53094:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
53094:     if (!atom) {
53094:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
53094:         if (entry->vword.isFunObj()) {
53094:             PUSH_OBJECT(entry->vword.toFunObj());
53094:             goto do_push_obj_if_call;
53094:         }
53094: 
53094:         if (entry->vword.isSlot()) {
53094:             uintN slot = entry->vword.toSlot();
53094:             JS_ASSERT(slot < obj2->scope()->freeslot);
53094:             PUSH_COPY(obj2->lockedGetSlot(slot));
53094:             goto do_push_obj_if_call;
53094:         }
53094: 
53094:         JS_ASSERT(entry->vword.isSprop());
53094:         sprop = entry->vword.toSprop();
53094:         goto do_native_get;
53094:     }
53094: 
53094:     jsid id;
53094:     id = ATOM_TO_JSID(atom);
53094:     JSProperty *prop;
53094:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
53094:         goto error;
53094:     if (!prop) {
53094:         /* Kludge to allow (typeof foo == "undefined") tests. */
53094:         JSOp op2 = js_GetOpcode(cx, script, regs.pc + JSOP_NAME_LENGTH);
53094:         if (op2 == JSOP_TYPEOF) {
53094:             PUSH_UNDEFINED();
53094:             len = JSOP_NAME_LENGTH;
53094:             DO_NEXT_OP(len);
53094:         }
53094:         atomNotDefined = atom;
53094:         goto atom_not_defined;
53094:     }
53094: 
53094:     /* Take the slow path if prop was not found in a native object. */
53094:     if (!obj->isNative() || !obj2->isNative()) {
53094:         obj2->dropProperty(cx, prop);
53094:         if (!obj->getProperty(cx, id, &rval))
53094:             goto error;
53094:     } else {
53094:         sprop = (JSScopeProperty *)prop;
53094:   do_native_get:
53094:         NATIVE_GET(cx, obj, obj2, sprop, JSGET_METHOD_BARRIER, &rval);
53094:         JS_UNLOCK_OBJ(cx, obj2);
53094:     }
53094: 
53094:     PUSH_COPY(rval);
53094: 
53094:   do_push_obj_if_call:
53094:     /* obj must be on the scope chain, thus not a function. */
53094:     if (op == JSOP_CALLNAME)
53094:         PUSH_OBJECT(*obj);
53094: }
53094: END_CASE(JSOP_NAME)
53094: 
53094: BEGIN_CASE(JSOP_UINT16)
53094:     PUSH_INT32((int32_t) GET_UINT16(regs.pc));
53094: END_CASE(JSOP_UINT16)
53094: 
53094: BEGIN_CASE(JSOP_UINT24)
53094:     PUSH_INT32((int32_t) GET_UINT24(regs.pc));
53094: END_CASE(JSOP_UINT24)
53094: 
53094: BEGIN_CASE(JSOP_INT8)
53094:     PUSH_INT32(GET_INT8(regs.pc));
53094: END_CASE(JSOP_INT8)
53094: 
53094: BEGIN_CASE(JSOP_INT32)
53094:     PUSH_INT32(GET_INT32(regs.pc));
53094: END_CASE(JSOP_INT32)
53094: 
53094: BEGIN_CASE(JSOP_INDEXBASE)
53094:     /*
53094:      * Here atoms can exceed script->atomMap.length as we use atoms as a
53094:      * segment register for object literals as well.
53094:      */
53094:     atoms += GET_INDEXBASE(regs.pc);
53094: END_CASE(JSOP_INDEXBASE)
53094: 
53094: BEGIN_CASE(JSOP_INDEXBASE1)
53094: BEGIN_CASE(JSOP_INDEXBASE2)
53094: BEGIN_CASE(JSOP_INDEXBASE3)
53094:     atoms += (op - JSOP_INDEXBASE1 + 1) << 16;
53094: END_CASE(JSOP_INDEXBASE3)
53094: 
53094: BEGIN_CASE(JSOP_RESETBASE0)
53094: BEGIN_CASE(JSOP_RESETBASE)
53094:     atoms = script->atomMap.vector;
53094: END_CASE(JSOP_RESETBASE)
53094: 
53094: BEGIN_CASE(JSOP_DOUBLE)
53094: {
53094:     JS_ASSERT(!fp->imacpc);
53094:     JS_ASSERT(size_t(atoms - script->atomMap.vector) <= script->atomMap.length);
53094:     double dbl;
53094:     LOAD_DOUBLE(0, dbl);
53094:     PUSH_DOUBLE(dbl);
53094: }
53094: END_CASE(JSOP_DOUBLE)
53094: 
53094: BEGIN_CASE(JSOP_STRING)
53094: {
53094:     JSAtom *atom;
53094:     LOAD_ATOM(0, atom);
53094:     PUSH_STRING(ATOM_TO_STRING(atom));
53094: }
53094: END_CASE(JSOP_STRING)
53094: 
53094: BEGIN_CASE(JSOP_OBJECT)
53094: {
53094:     JSObject *obj;
53094:     LOAD_OBJECT(0, obj);
53094:     /* Only XML and RegExp objects are emitted. */
53094:     PUSH_OBJECT(*obj);
53094: }
53094: END_CASE(JSOP_OBJECT)
53094: 
53094: BEGIN_CASE(JSOP_REGEXP)
53094: {
53094:     /*
53094:      * Push a regexp object cloned from the regexp literal object mapped by the
53094:      * bytecode at pc. ES5 finally fixed this bad old ES3 design flaw which was
53094:      * flouted by many browser-based implementations.
53094:      *
53094:      * We avoid the js_GetScopeChain call here and pass fp->scopeChain as
53094:      * js_GetClassPrototype uses the latter only to locate the global.
53094:      */
53094:     jsatomid index = GET_FULL_INDEX(0);
53094:     JSObject *proto;
53094:     if (!js_GetClassPrototype(cx, fp->scopeChain, JSProto_RegExp, &proto))
53094:         goto error;
53094:     JS_ASSERT(proto);
53094:     JSObject *obj = js_CloneRegExpObject(cx, script->getRegExp(index), proto);
53094:     if (!obj)
53094:         goto error;
53094:     PUSH_OBJECT(*obj);
53094: }
53094: END_CASE(JSOP_REGEXP)
53094: 
53094: BEGIN_CASE(JSOP_ZERO)
53094:     PUSH_INT32(0);
53094: END_CASE(JSOP_ZERO)
53094: 
53094: BEGIN_CASE(JSOP_ONE)
53094:     PUSH_INT32(1);
53094: END_CASE(JSOP_ONE)
53094: 
53094: BEGIN_CASE(JSOP_NULL)
53094:     PUSH_NULL();
53094: END_CASE(JSOP_NULL)
53094: 
53094: BEGIN_CASE(JSOP_FALSE)
53094:     PUSH_BOOLEAN(false);
53094: END_CASE(JSOP_FALSE)
53094: 
53094: BEGIN_CASE(JSOP_TRUE)
53094:     PUSH_BOOLEAN(true);
53094: END_CASE(JSOP_TRUE)
53094: 
53094: {
53094: BEGIN_CASE(JSOP_TABLESWITCH)
53094: {
53094:     jsbytecode *pc2 = regs.pc;
53094:     len = GET_JUMP_OFFSET(pc2);
53094: 
53094:     /*
53094:      * ECMAv2+ forbids conversion of discriminant, so we will skip to the
53094:      * default case if the discriminant isn't already an int jsval.  (This
53094:      * opcode is emitted only for dense jsint-domain switches.)
53094:      */
53094:     const Value &rref = *--regs.sp;
53094:     int32_t i;
53094:     if (rref.isInt32()) {
53094:         i = rref.toInt32();
53094:     } else if (rref.isDouble() && rref.toDouble() == 0) {
53094:         /* Treat -0 (double) as 0. */
53094:         i = 0;
53094:     } else {
53094:         DO_NEXT_OP(len);
53094:     }
53094: 
53094:     pc2 += JUMP_OFFSET_LEN;
53094:     jsint low = GET_JUMP_OFFSET(pc2);
53094:     pc2 += JUMP_OFFSET_LEN;
53094:     jsint high = GET_JUMP_OFFSET(pc2);
53094: 
53094:     i -= low;
53094:     if ((jsuint)i < (jsuint)(high - low + 1)) {
53094:         pc2 += JUMP_OFFSET_LEN + JUMP_OFFSET_LEN * i;
53094:         jsint off = (jsint) GET_JUMP_OFFSET(pc2);
53094:         if (off)
53094:             len = off;
53094:     }
53094: }
53094: END_VARLEN_CASE
53094: }
53094: 
53094: {
53094: BEGIN_CASE(JSOP_TABLESWITCHX)
53094: {
53094:     jsbytecode *pc2 = regs.pc;
53094:     len = GET_JUMPX_OFFSET(pc2);
53094: 
53094:     /*
53094:      * ECMAv2+ forbids conversion of discriminant, so we will skip to the
53094:      * default case if the discriminant isn't already an int jsval.  (This
53094:      * opcode is emitted only for dense jsint-domain switches.)
53094:      */
53094:     const Value &rref = *--regs.sp;
53094:     int32_t i;
53094:     if (rref.isInt32()) {
53094:         i = rref.toInt32();
53094:     } else if (rref.isDouble() && rref.toDouble() == 0) {
53094:         /* Treat -0 (double) as 0. */
53094:         i = 0;
53094:     } else {
53094:         DO_NEXT_OP(len);
53094:     }
53094: 
53094:     pc2 += JUMPX_OFFSET_LEN;
53094:     jsint low = GET_JUMP_OFFSET(pc2);
53094:     pc2 += JUMP_OFFSET_LEN;
53094:     jsint high = GET_JUMP_OFFSET(pc2);
53094: 
53094:     i -= low;
53094:     if ((jsuint)i < (jsuint)(high - low + 1)) {
53094:         pc2 += JUMP_OFFSET_LEN + JUMPX_OFFSET_LEN * i;
53094:         jsint off = (jsint) GET_JUMPX_OFFSET(pc2);
53094:         if (off)
53094:             len = off;
53094:     }
53094: }
53094: END_VARLEN_CASE
53094: }
53094: 
53094: {
53094: BEGIN_CASE(JSOP_LOOKUPSWITCHX)
53094: {
53094:     jsint off;
53094:     off = JUMPX_OFFSET_LEN;
53094:     goto do_lookup_switch;
53094: 
53094: BEGIN_CASE(JSOP_LOOKUPSWITCH)
53094:     off = JUMP_OFFSET_LEN;
53094: 
53094:   do_lookup_switch:
53094:     /*
53094:      * JSOP_LOOKUPSWITCH and JSOP_LOOKUPSWITCHX are never used if any atom
53094:      * index in it would exceed 64K limit.
53094:      */
53094:     JS_ASSERT(!fp->imacpc);
53094:     JS_ASSERT(atoms == script->atomMap.vector);
53094:     jsbytecode *pc2 = regs.pc;
53094: 
53094:     Value lval = regs.sp[-1];
53094:     regs.sp--;
53094: 
53094:     if (!lval.isPrimitive())
53094:         goto end_lookup_switch;
53094: 
53094:     pc2 += off;
53094:     jsint npairs;
53094:     npairs = (jsint) GET_UINT16(pc2);
53094:     pc2 += UINT16_LEN;
53094:     JS_ASSERT(npairs);  /* empty switch uses JSOP_TABLESWITCH */
53094: 
53094:     bool match;
53094: #define SEARCH_PAIRS(MATCH_CODE)                                              \
53094:     for (;;) {                                                                \
53094:         Value rval = script->getConst(GET_INDEX(pc2));                        \
53094:         MATCH_CODE                                                            \
53094:         pc2 += INDEX_LEN;                                                     \
53094:         if (match)                                                            \
53094:             break;                                                            \
53094:         pc2 += off;                                                           \
53094:         if (--npairs == 0) {                                                  \
53094:             pc2 = regs.pc;                                                    \
53094:             break;                                                            \
53094:         }                                                                     \
53094:     }
53094: 
53094:     if (lval.isString()) {
53094:         JSString *str = lval.toString();
53094:         JSString *str2;
53094:         SEARCH_PAIRS(
53094:             match = (rval.isString() &&
53094:                      ((str2 = rval.toString()) == str ||
53094:                       js_EqualStrings(str2, str)));
53094:         )
53094:     } else if (lval.isNumber()) {
53094:         double ldbl = lval.toNumber();
53094:         SEARCH_PAIRS(
53094:             match = rval.isNumber() && ldbl == rval.toNumber();
53094:         )
53094:     } else {
53094:         SEARCH_PAIRS(
53094:             match = (lval == rval);
53094:         )
53094:     }
53094: #undef SEARCH_PAIRS
53094: 
53094:   end_lookup_switch:
53094:     len = (op == JSOP_LOOKUPSWITCH)
53094:           ? GET_JUMP_OFFSET(pc2)
53094:           : GET_JUMPX_OFFSET(pc2);
53094: }
53094: END_VARLEN_CASE
53094: }
53094: 
53094: BEGIN_CASE(JSOP_TRAP)
53094: {
53094:     Value rval;
53094:     JSTrapStatus status = JS_HandleTrap(cx, script, regs.pc, Jsvalify(&rval));
53094:     switch (status) {
53094:       case JSTRAP_ERROR:
53094:         goto error;
53094:       case JSTRAP_RETURN:
53094:         fp->rval = rval;
53094:         interpReturnOK = JS_TRUE;
53094:         goto forced_return;
53094:       case JSTRAP_THROW:
53094:         cx->throwing = JS_TRUE;
53094:         cx->exception = rval;
53094:         goto error;
53094:       default:
53094:         break;
53094:     }
53094:     JS_ASSERT(status == JSTRAP_CONTINUE);
53094:     CHECK_INTERRUPT_HANDLER();
53094:     JS_ASSERT(rval.isInt32());
53094:     op = (JSOp) rval.toInt32();
53094:     JS_ASSERT((uintN)op < (uintN)JSOP_LIMIT);
53094:     DO_OP();
53094: }
53094: 
53094: BEGIN_CASE(JSOP_ARGUMENTS)
53094: {
53094:     Value rval;
53094:     if (!js_GetArgsValue(cx, fp, &rval))
53094:         goto error;
53094:     PUSH_COPY(rval);
53094: }
53094: END_CASE(JSOP_ARGUMENTS)
53094: 
53094: BEGIN_CASE(JSOP_ARGSUB)
53094: {
53094:     jsid id = INT_TO_JSID(GET_ARGNO(regs.pc));
53094:     Value rval;
53094:     if (!js_GetArgsProperty(cx, fp, id, &rval))
53094:         goto error;
53094:     PUSH_COPY(rval);
53094: }
53094: END_CASE(JSOP_ARGSUB)
53094: 
53094: BEGIN_CASE(JSOP_ARGCNT)
53094: {
53094:     jsid id = ATOM_TO_JSID(rt->atomState.lengthAtom);
53094:     Value rval;
53094:     if (!js_GetArgsProperty(cx, fp, id, &rval))
53094:         goto error;
53094:     PUSH_COPY(rval);
53094: }
53094: END_CASE(JSOP_ARGCNT)
53094: 
53094: BEGIN_CASE(JSOP_GETARG)
53094: BEGIN_CASE(JSOP_CALLARG)
53094: {
53094:     uint32 slot = GET_ARGNO(regs.pc);
53094:     JS_ASSERT(slot < fp->fun->nargs);
53094:     METER_SLOT_OP(op, slot);
53094:     PUSH_COPY(fp->argv[slot]);
53094:     if (op == JSOP_CALLARG)
53094:         PUSH_NULL();
53094: }
53094: END_CASE(JSOP_GETARG)
53094: 
53094: BEGIN_CASE(JSOP_SETARG)
53094: {
53094:     uint32 slot = GET_ARGNO(regs.pc);
53094:     JS_ASSERT(slot < fp->fun->nargs);
53094:     METER_SLOT_OP(op, slot);
53094:     fp->argv[slot] = regs.sp[-1];
53094: }
53094: END_SET_CASE(JSOP_SETARG)
53094: 
53094: BEGIN_CASE(JSOP_GETLOCAL)
53094: {
53094:     uint32 slot = GET_SLOTNO(regs.pc);
53094:     JS_ASSERT(slot < script->nslots);
53094:     PUSH_COPY(fp->slots()[slot]);
53094: }
53094: END_CASE(JSOP_GETLOCAL)
53094: 
53094: BEGIN_CASE(JSOP_CALLLOCAL)
53094: {
53094:     uint32 slot = GET_SLOTNO(regs.pc);
53094:     JS_ASSERT(slot < script->nslots);
53094:     PUSH_COPY(fp->slots()[slot]);
53094:     PUSH_NULL();
53094: }
53094: END_CASE(JSOP_CALLLOCAL)
53094: 
53094: BEGIN_CASE(JSOP_SETLOCAL)
53094: {
53094:     uint32 slot = GET_SLOTNO(regs.pc);
53094:     JS_ASSERT(slot < script->nslots);
53094:     fp->slots()[slot] = regs.sp[-1];
53094: }
53094: END_SET_CASE(JSOP_SETLOCAL)
53094: 
53094: BEGIN_CASE(JSOP_GETUPVAR)
53094: BEGIN_CASE(JSOP_CALLUPVAR)
53094: {
53094:     JSUpvarArray *uva = script->upvars();
53094: 
53094:     uintN index = GET_UINT16(regs.pc);
53094:     JS_ASSERT(index < uva->length);
53094: 
53094:     const Value &rval = js_GetUpvar(cx, script->staticLevel, uva->vector[index]);
53094:     PUSH_COPY(rval);
53094: 
53094:     if (op == JSOP_CALLUPVAR)
53094:         PUSH_NULL();
53094: }
53094: END_CASE(JSOP_GETUPVAR)
53094: 
53094: BEGIN_CASE(JSOP_GETUPVAR_DBG)
53094: BEGIN_CASE(JSOP_CALLUPVAR_DBG)
53094: {
53094:     JSFunction *fun = fp->fun;
53094:     JS_ASSERT(FUN_KIND(fun) == JSFUN_INTERPRETED);
53094:     JS_ASSERT(fun->u.i.wrapper);
53094: 
53094:     /* Scope for tempPool mark and local names allocation in it. */
53094:     JSObject *obj, *obj2;
53094:     JSProperty *prop;
53094:     jsid id;
53094:     JSAtom *atom;
53094:     {
53094:         void *mark = JS_ARENA_MARK(&cx->tempPool);
53094:         jsuword *names = js_GetLocalNameArray(cx, fun, &cx->tempPool);
53094:         if (!names)
53094:             goto error;
53094: 
53094:         uintN index = fun->countArgsAndVars() + GET_UINT16(regs.pc);
53094:         atom = JS_LOCAL_NAME_TO_ATOM(names[index]);
53094:         id = ATOM_TO_JSID(atom);
53094: 
53094:         JSBool ok = js_FindProperty(cx, id, &obj, &obj2, &prop);
53094:         JS_ARENA_RELEASE(&cx->tempPool, mark);
53094:         if (!ok)
53094:             goto error;
53094:     }
53094: 
53094:     if (!prop) {
53094:         atomNotDefined = atom;
53094:         goto atom_not_defined;
53094:     }
53094: 
53094:     /* Minimize footprint with generic code instead of NATIVE_GET. */
53094:     obj2->dropProperty(cx, prop);
53094:     Value *vp = regs.sp;
53094:     PUSH_NULL();
53094:     if (!obj->getProperty(cx, id, vp))
53094:         goto error;
53094: 
53094:     if (op == JSOP_CALLUPVAR_DBG)
53094:         PUSH_NULL();
53094: }
53094: END_CASE(JSOP_GETUPVAR_DBG)
53094: 
53094: BEGIN_CASE(JSOP_GETDSLOT)
53094: BEGIN_CASE(JSOP_CALLDSLOT)
53094: {
53094:     JS_ASSERT(fp->argv);
53094:     JSObject *obj = &fp->argv[-2].toObject();
53094:     JS_ASSERT(obj);
53094:     JS_ASSERT(obj->dslots);
53094: 
53094:     uintN index = GET_UINT16(regs.pc);
53094:     JS_ASSERT(JS_INITIAL_NSLOTS + index < obj->dslots[-1].toPrivateUint32());
53094:     JS_ASSERT_IF(obj->scope()->object == obj,
53094:                  JS_INITIAL_NSLOTS + index < obj->scope()->freeslot);
53094: 
53094:     PUSH_COPY(obj->dslots[index]);
53094:     if (op == JSOP_CALLDSLOT)
53094:         PUSH_NULL();
53094: }
53094: END_CASE(JSOP_GETDSLOT)
53094: 
53094: BEGIN_CASE(JSOP_GETGVAR)
53094: BEGIN_CASE(JSOP_CALLGVAR)
53094: {
53094:     uint32 slot = GET_SLOTNO(regs.pc);
53094:     JS_ASSERT(slot < GlobalVarCount(fp));
53094:     METER_SLOT_OP(op, slot);
53094:     const Value &lval = fp->slots()[slot];
53094:     if (lval.isNull()) {
53094:         op = (op == JSOP_GETGVAR) ? JSOP_NAME : JSOP_CALLNAME;
53094:         DO_OP();
53094:     }
53094:     JS_ASSERT(fp->varobj(cx) == cx->activeCallStack()->getInitialVarObj());
53094:     JSObject *varobj = cx->activeCallStack()->getInitialVarObj();
53094: 
53094:     /* XXX all this code assumes that varobj is either a callobj or global and
53094:      * that it cannot be accessed in a MT way. This is either true now or
53094:      * coming soon. */
53094: 
53094:     slot = (uint32)lval.toInt32();
53094:     const Value &rref = varobj->lockedGetSlot(slot);
53094:     PUSH_COPY(rref);
53094:     if (op == JSOP_CALLGVAR)
53094:         PUSH_NULL();
53094: }
53094: END_CASE(JSOP_GETGVAR)
53094: 
53094: BEGIN_CASE(JSOP_SETGVAR)
53094: {
53094:     uint32 slot = GET_SLOTNO(regs.pc);
53094:     JS_ASSERT(slot < GlobalVarCount(fp));
53094:     METER_SLOT_OP(op, slot);
53094:     const Value &rref = regs.sp[-1];
53094:     JS_ASSERT(fp->varobj(cx) == cx->activeCallStack()->getInitialVarObj());
53094:     JSObject *obj = cx->activeCallStack()->getInitialVarObj();
53094:     const Value &lref = fp->slots()[slot];
53094:     if (lref.isNull()) {
53094:         /*
53094:          * Inline-clone and deoptimize JSOP_SETNAME code here because
53094:          * JSOP_SETGVAR has arity 1: [rref], not arity 2: [obj, rref]
53094:          * as JSOP_SETNAME does, where [obj] is due to JSOP_BINDNAME.
53094:          */
53094: #ifdef JS_TRACER
53094:         if (TRACE_RECORDER(cx))
53094:             AbortRecording(cx, "SETGVAR with NULL slot");
53094: #endif
53094:         JSAtom *atom;
53094:         LOAD_ATOM(0, atom);
53094:         jsid id = ATOM_TO_JSID(atom);
53094:         Value rval = rref;
53094:         if (!obj->setProperty(cx, id, &rval))
53094:             goto error;
53094:     } else {
53094:         uint32 slot = (uint32)lref.toInt32();
53094:         JS_LOCK_OBJ(cx, obj);
53094:         JSScope *scope = obj->scope();
53094:         if (!scope->methodWriteBarrier(cx, slot, rref)) {
53094:             JS_UNLOCK_SCOPE(cx, scope);
53094:             goto error;
53094:         }
53094:         obj->lockedSetSlot(slot, rref);
53094:         JS_UNLOCK_SCOPE(cx, scope);
53094:     }
53094: }
53094: END_SET_CASE(JSOP_SETGVAR)
53094: 
53094: BEGIN_CASE(JSOP_DEFCONST)
53094: BEGIN_CASE(JSOP_DEFVAR)
53094: {
53094:     uint32 index = GET_INDEX(regs.pc);
53094:     JSAtom *atom = atoms[index];
53094: 
53094:     /*
53094:      * index is relative to atoms at this point but for global var
53094:      * code below we need the absolute value.
53094:      */
53094:     index += atoms - script->atomMap.vector;
53094:     JSObject *obj = fp->varobj(cx);
53094:     JS_ASSERT(obj->map->ops->defineProperty == js_DefineProperty);
53094:     uintN attrs = JSPROP_ENUMERATE;
53094:     if (!(fp->flags & JSFRAME_EVAL))
53094:         attrs |= JSPROP_PERMANENT;
53094:     if (op == JSOP_DEFCONST)
53094:         attrs |= JSPROP_READONLY;
53094: 
53094:     /* Lookup id in order to check for redeclaration problems. */
53094:     jsid id = ATOM_TO_JSID(atom);
53094:     JSProperty *prop = NULL;
53094:     JSObject *obj2;
53094:     if (op == JSOP_DEFVAR) {
53094:         /*
53094:          * Redundant declaration of a |var|, even one for a non-writable
53094:          * property like |undefined| in ES5, does nothing.
53094:          */
53094:         if (!obj->lookupProperty(cx, id, &obj2, &prop))
53094:             goto error;
53094:     } else {
53094:         if (!CheckRedeclaration(cx, obj, id, attrs, &obj2, &prop))
53094:             goto error;
53094:     }
53094: 
53094:     /* Bind a variable only if it's not yet defined. */
53094:     if (!prop) {
53094:         if (!js_DefineNativeProperty(cx, obj, id, UndefinedValue(), PropertyStub, PropertyStub,
53094:                                      attrs, 0, 0, &prop)) {
53094:             goto error;
53094:         }
53094:         JS_ASSERT(prop);
53094:         obj2 = obj;
53094:     }
53094: 
53094:     /*
53094:      * Try to optimize a property we either just created, or found
53094:      * directly in the global object, that is permanent, has a slot,
53094:      * and has stub getter and setter, into a "fast global" accessed
53094:      * by the JSOP_*GVAR opcodes.
53094:      */
53094:     if (!fp->fun &&
53094:         index < GlobalVarCount(fp) &&
53094:         obj2 == obj &&
53094:         obj->isNative()) {
53094:         JSScopeProperty *sprop = (JSScopeProperty *) prop;
53094:         if (!sprop->configurable() &&
53094:             SPROP_HAS_VALID_SLOT(sprop, obj->scope()) &&
53094:             sprop->hasDefaultGetterOrIsMethod() &&
53094:             sprop->hasDefaultSetter()) {
53094:             /*
53094:              * Fast globals use frame variables to map the global name's atom
53094:              * index to the permanent varobj slot number, tagged as a jsval.
53094:              * The atom index for the global's name literal is identical to its
53094:              * variable index.
53094:              */
53094:             fp->slots()[index].setInt32(sprop->slot);
53094:         }
53094:     }
53094: 
53094:     obj2->dropProperty(cx, prop);
53094: }
53094: END_CASE(JSOP_DEFVAR)
53094: 
53094: BEGIN_CASE(JSOP_DEFFUN)
53094: {
53094:     PropertyOp getter, setter;
53094:     bool doSet;
53094:     JSObject *pobj;
53094:     JSProperty *prop;
53094:     uint32 old;
53094: 
53094:     /*
53094:      * A top-level function defined in Global or Eval code (see ECMA-262
53094:      * Ed. 3), or else a SpiderMonkey extension: a named function statement in
53094:      * a compound statement (not at the top statement level of global code, or
53094:      * at the top level of a function body).
53094:      */
53094:     JSFunction *fun;
53094:     LOAD_FUNCTION(0);
53094:     JSObject *obj = FUN_OBJECT(fun);
53094: 
53094:     JSObject *obj2;
53094:     if (FUN_NULL_CLOSURE(fun)) {
53094:         /*
53094:          * Even a null closure needs a parent for principals finding.
53094:          * FIXME: bug 476950, although debugger users may also demand some kind
53094:          * of scope link for debugger-assisted eval-in-frame.
53094:          */
53094:         obj2 = fp->scopeChain;
53094:     } else {
53094:         JS_ASSERT(!FUN_FLAT_CLOSURE(fun));
53094: 
53094:         /*
53094:          * Inline js_GetScopeChain a bit to optimize for the case of a
53094:          * top-level function.
53094:          */
53094:         if (!fp->blockChain) {
53094:             obj2 = fp->scopeChain;
53094:         } else {
53094:             obj2 = js_GetScopeChain(cx, fp);
53094:             if (!obj2)
53094:                 goto error;
53094:         }
53094:     }
53094: 
53094:     /*
53094:      * If static link is not current scope, clone fun's object to link to the
53094:      * current scope via parent. We do this to enable sharing of compiled
53094:      * functions among multiple equivalent scopes, amortizing the cost of
53094:      * compilation over a number of executions.  Examples include XUL scripts
53094:      * and event handlers shared among Firefox or other Mozilla app chrome
53094:      * windows, and user-defined JS functions precompiled and then shared among
53094:      * requests in server-side JS.
53094:      */
53094:     if (obj->getParent() != obj2) {
53094:         obj = CloneFunctionObject(cx, fun, obj2);
53094:         if (!obj)
53094:             goto error;
53094:     }
53094: 
53094:     /*
53094:      * Protect obj from any GC hiding below JSObject::setProperty or
53094:      * JSObject::defineProperty.  All paths from here must flow through the
53094:      * fp->scopeChain code below the parent->defineProperty call.
53094:      */
53094:     MUST_FLOW_THROUGH("restore_scope");
53094:     fp->scopeChain = obj;
53094: 
53094:     Value rval = ObjectValue(*obj);
53094: 
53094:     /*
53094:      * ECMA requires functions defined when entering Eval code to be
53094:      * impermanent.
53094:      */
53094:     uintN attrs = (fp->flags & JSFRAME_EVAL)
53094:                   ? JSPROP_ENUMERATE
53094:                   : JSPROP_ENUMERATE | JSPROP_PERMANENT;
53094: 
53094:     /*
53094:      * Load function flags that are also property attributes.  Getters and
53094:      * setters do not need a slot, their value is stored elsewhere in the
53094:      * property itself, not in obj slots.
53094:      */
53094:     getter = setter = PropertyStub;
53094:     uintN flags = JSFUN_GSFLAG2ATTR(fun->flags);
53094:     if (flags) {
53094:         /* Function cannot be both getter a setter. */
53094:         JS_ASSERT(flags == JSPROP_GETTER || flags == JSPROP_SETTER);
53094:         attrs |= flags | JSPROP_SHARED;
53094:         rval.setUndefined();
53094:         if (flags == JSPROP_GETTER)
53094:             getter = CastAsPropertyOp(obj);
53094:         else
53094:             setter = CastAsPropertyOp(obj);
53094:     }
53094: 
53094:     /*
53094:      * We define the function as a property of the variable object and not the
53094:      * current scope chain even for the case of function expression statements
53094:      * and functions defined by eval inside let or with blocks.
53094:      */
53094:     JSObject *parent = fp->varobj(cx);
53094:     JS_ASSERT(parent);
53094: 
53094:     /*
53094:      * Check for a const property of the same name -- or any kind of property
53094:      * if executing with the strict option.  We check here at runtime as well
53094:      * as at compile-time, to handle eval as well as multiple HTML script tags.
53094:      */
53094:     jsid id = ATOM_TO_JSID(fun->atom);
53094:     prop = NULL;
53094:     JSBool ok = CheckRedeclaration(cx, parent, id, attrs, &pobj, &prop);
53094:     if (!ok)
53094:         goto restore_scope;
53094: 
53094:     /*
53094:      * We deviate from 10.1.2 in ECMA 262 v3 and under eval use for function
53094:      * declarations JSObject::setProperty, not JSObject::defineProperty, to
53094:      * preserve the JSOP_PERMANENT attribute of existing properties and make
53094:      * sure that such properties cannot be deleted.
53094:      *
53094:      * We also use JSObject::setProperty for the existing properties of Call
53094:      * objects with matching attributes to preserve the native getters and
53094:      * setters that store the value of the property in the interpreter frame,
53094:      * see bug 467495.
53094:      */
53094:     doSet = (attrs == JSPROP_ENUMERATE);
53094:     JS_ASSERT_IF(doSet, fp->flags & JSFRAME_EVAL);
53094:     if (prop) {
53094:         if (parent == pobj &&
53094:             parent->getClass() == &js_CallClass &&
53094:             (old = ((JSScopeProperty *) prop)->attributes(),
53094:              !(old & (JSPROP_GETTER|JSPROP_SETTER)) &&
53094:              (old & (JSPROP_ENUMERATE|JSPROP_PERMANENT)) == attrs)) {
53094:             /*
53094:              * js_CheckRedeclaration must reject attempts to add a getter or
53094:              * setter to an existing property without a getter or setter.
53094:              */
53094:             JS_ASSERT(!(attrs & ~(JSPROP_ENUMERATE|JSPROP_PERMANENT)));
53094:             JS_ASSERT(!(old & JSPROP_READONLY));
53094:             doSet = JS_TRUE;
53094:         }
53094:         pobj->dropProperty(cx, prop);
53094:     }
53094:     ok = doSet
53094:          ? parent->setProperty(cx, id, &rval)
53094:          : parent->defineProperty(cx, id, rval, getter, setter, attrs);
53094: 
53094:   restore_scope:
53094:     /* Restore fp->scopeChain now that obj is defined in fp->callobj. */
53094:     fp->scopeChain = obj2;
53094:     if (!ok)
53094:         goto error;
53094: }
53094: END_CASE(JSOP_DEFFUN)
53094: 
53094: BEGIN_CASE(JSOP_DEFFUN_FC)
53094: BEGIN_CASE(JSOP_DEFFUN_DBGFC)
53094: {
53094:     JSFunction *fun;
53094:     LOAD_FUNCTION(0);
53094: 
53094:     JSObject *obj = (op == JSOP_DEFFUN_FC)
53094:                     ? js_NewFlatClosure(cx, fun)
53094:                     : js_NewDebuggableFlatClosure(cx, fun);
53094:     if (!obj)
53094:         goto error;
53094: 
53094:     Value rval = ObjectValue(*obj);
53094: 
53094:     uintN attrs = (fp->flags & JSFRAME_EVAL)
53094:                   ? JSPROP_ENUMERATE
53094:                   : JSPROP_ENUMERATE | JSPROP_PERMANENT;
53094: 
53094:     uintN flags = JSFUN_GSFLAG2ATTR(fun->flags);
53094:     if (flags) {
53094:         attrs |= flags | JSPROP_SHARED;
53094:         rval.setUndefined();
53094:     }
53094: 
53094:     JSObject *parent = fp->varobj(cx);
53094:     JS_ASSERT(parent);
53094: 
53094:     jsid id = ATOM_TO_JSID(fun->atom);
53094:     JSBool ok = CheckRedeclaration(cx, parent, id, attrs, NULL, NULL);
53094:     if (ok) {
53094:         if (attrs == JSPROP_ENUMERATE) {
53094:             JS_ASSERT(fp->flags & JSFRAME_EVAL);
53094:             ok = parent->setProperty(cx, id, &rval);
53094:         } else {
53094:             JS_ASSERT(attrs & JSPROP_PERMANENT);
53094: 
53094:             ok = parent->defineProperty(cx, id, rval,
53094:                                         (flags & JSPROP_GETTER)
53094:                                         ? CastAsPropertyOp(obj)
53094:                                         : PropertyStub,
53094:                                         (flags & JSPROP_SETTER)
53094:                                         ? CastAsPropertyOp(obj)
53094:                                         : PropertyStub,
53094:                                         attrs);
53094:         }
53094:     }
53094: 
53094:     if (!ok)
53094:         goto error;
53094: }
53094: END_CASE(JSOP_DEFFUN_FC)
53094: 
53094: BEGIN_CASE(JSOP_DEFLOCALFUN)
53094: {
53094:     /*
53094:      * Define a local function (i.e., one nested at the top level of another
53094:      * function), parented by the current scope chain, stored in a local
53094:      * variable slot that the compiler allocated.  This is an optimization over
53094:      * JSOP_DEFFUN that avoids requiring a call object for the outer function's
53094:      * activation.
53094:      */
53094:     JSFunction *fun;
53094:     LOAD_FUNCTION(SLOTNO_LEN);
53094:     JS_ASSERT(fun->isInterpreted());
53094:     JS_ASSERT(!FUN_FLAT_CLOSURE(fun));
53094:     JSObject *obj = FUN_OBJECT(fun);
53094: 
53094:     if (FUN_NULL_CLOSURE(fun)) {
53094:         obj = CloneFunctionObject(cx, fun, fp->scopeChain);
53094:         if (!obj)
53094:             goto error;
53094:     } else {
53094:         JSObject *parent = js_GetScopeChain(cx, fp);
53094:         if (!parent)
53094:             goto error;
53094: 
53094:         if (obj->getParent() != parent) {
53094: #ifdef JS_TRACER
53094:             if (TRACE_RECORDER(cx))
53094:                 AbortRecording(cx, "DEFLOCALFUN for closure");
53094: #endif
53094:             obj = CloneFunctionObject(cx, fun, parent);
53094:             if (!obj)
53094:                 goto error;
53094:         }
53094:     }
53094: 
53094:     uint32 slot = GET_SLOTNO(regs.pc);
53094:     TRACE_2(DefLocalFunSetSlot, slot, obj);
53094: 
53094:     fp->slots()[slot].setObject(*obj);
53094: }
53094: END_CASE(JSOP_DEFLOCALFUN)
53094: 
53094: BEGIN_CASE(JSOP_DEFLOCALFUN_FC)
53094: {
53094:     JSFunction *fun;
53094:     LOAD_FUNCTION(SLOTNO_LEN);
53094: 
53094:     JSObject *obj = js_NewFlatClosure(cx, fun);
53094:     if (!obj)
53094:         goto error;
53094: 
53094:     uint32 slot = GET_SLOTNO(regs.pc);
53094:     TRACE_2(DefLocalFunSetSlot, slot, obj);
53094: 
53094:     fp->slots()[slot].setObject(*obj);
53094: }
53094: END_CASE(JSOP_DEFLOCALFUN_FC)
53094: 
53094: BEGIN_CASE(JSOP_DEFLOCALFUN_DBGFC)
53094: {
53094:     JSFunction *fun;
53094:     LOAD_FUNCTION(SLOTNO_LEN);
53094: 
53094:     JSObject *obj = js_NewDebuggableFlatClosure(cx, fun);
53094:     if (!obj)
53094:         goto error;
53094: 
53094:     uint32 slot = GET_SLOTNO(regs.pc);
53094:     fp->slots()[slot].setObject(*obj);
53094: }
53094: END_CASE(JSOP_DEFLOCALFUN_DBGFC)
53094: 
53094: BEGIN_CASE(JSOP_LAMBDA)
53094: {
53094:     /* Load the specified function object literal. */
53094:     JSFunction *fun;
53094:     LOAD_FUNCTION(0);
53094:     JSObject *obj = FUN_OBJECT(fun);
53094: 
53094:     /* do-while(0) so we can break instead of using a goto. */
53094:     do {
53094:         JSObject *parent;
53094:         if (FUN_NULL_CLOSURE(fun)) {
53094:             parent = fp->scopeChain;
53094: 
53094:             if (obj->getParent() == parent) {
53094:                 op = JSOp(regs.pc[JSOP_LAMBDA_LENGTH]);
53094: 
53094:                 /*
53094:                  * Optimize ({method: function () { ... }, ...}) and
53094:                  * this.method = function () { ... }; bytecode sequences.
53094:                  */
53094:                 if (op == JSOP_SETMETHOD) {
53094: #ifdef DEBUG
53094:                     JSOp op2 = JSOp(regs.pc[JSOP_LAMBDA_LENGTH + JSOP_SETMETHOD_LENGTH]);
53094:                     JS_ASSERT(op2 == JSOP_POP || op2 == JSOP_POPV);
53094: #endif
53094: 
53094:                     const Value &lref = regs.sp[-1];
53094:                     if (lref.isObject() &&
53094:                         lref.toObject().getClass() == &js_ObjectClass) {
53094:                         break;
53094:                     }
53094:                 } else if (op == JSOP_INITMETHOD) {
53094: #ifdef DEBUG
53094:                     const Value &lref = regs.sp[-1];
53094:                     JS_ASSERT(lref.isObject());
53094:                     JSObject *obj2 = &lref.toObject();
53094:                     JS_ASSERT(obj2->getClass() == &js_ObjectClass);
53094:                     JS_ASSERT(obj2->scope()->object == obj2);
53094: #endif
53094:                     break;
53094:                 }
53094:             }
53094:         } else {
53094:             parent = js_GetScopeChain(cx, fp);
53094:             if (!parent)
53094:                 goto error;
53094:         }
53094: 
53094:         obj = CloneFunctionObject(cx, fun, parent);
53094:         if (!obj)
53094:             goto error;
53094:     } while (0);
53094: 
53094:     PUSH_OBJECT(*obj);
53094: }
53094: END_CASE(JSOP_LAMBDA)
53094: 
53094: BEGIN_CASE(JSOP_LAMBDA_FC)
53094: {
53094:     JSFunction *fun;
53094:     LOAD_FUNCTION(0);
53094: 
53094:     JSObject *obj = js_NewFlatClosure(cx, fun);
53094:     if (!obj)
53094:         goto error;
53094: 
53094:     PUSH_OBJECT(*obj);
53094: }
53094: END_CASE(JSOP_LAMBDA_FC)
53094: 
53094: BEGIN_CASE(JSOP_LAMBDA_DBGFC)
53094: {
53094:     JSFunction *fun;
53094:     LOAD_FUNCTION(0);
53094: 
53094:     JSObject *obj = js_NewDebuggableFlatClosure(cx, fun);
53094:     if (!obj)
53094:         goto error;
53094: 
53094:     PUSH_OBJECT(*obj);
53094: }
53094: END_CASE(JSOP_LAMBDA_DBGFC)
53094: 
53094: BEGIN_CASE(JSOP_CALLEE)
53094:     PUSH_COPY(fp->argv[-2]);
53094: END_CASE(JSOP_CALLEE)
53094: 
53094: BEGIN_CASE(JSOP_GETTER)
53094: BEGIN_CASE(JSOP_SETTER)
53094: {
53094:   do_getter_setter:
53094:     JSOp op2 = (JSOp) *++regs.pc;
53094:     jsid id;
53094:     Value rval;
53094:     jsint i;
53094:     JSObject *obj;
53094:     switch (op2) {
53094:       case JSOP_INDEXBASE:
53094:         atoms += GET_INDEXBASE(regs.pc);
53094:         regs.pc += JSOP_INDEXBASE_LENGTH - 1;
53094:         goto do_getter_setter;
53094:       case JSOP_INDEXBASE1:
53094:       case JSOP_INDEXBASE2:
53094:       case JSOP_INDEXBASE3:
53094:         atoms += (op2 - JSOP_INDEXBASE1 + 1) << 16;
53094:         goto do_getter_setter;
53094: 
53094:       case JSOP_SETNAME:
53094:       case JSOP_SETPROP:
53094:       {
53094:         JSAtom *atom;
53094:         LOAD_ATOM(0, atom);
53094:         id = ATOM_TO_JSID(atom);
53094:         rval = regs.sp[-1];
53094:         i = -1;
53094:         goto gs_pop_lval;
53094:       }
53094:       case JSOP_SETELEM:
53094:         rval = regs.sp[-1];
53094:         id = JSID_VOID;
53094:         i = -2;
53094:       gs_pop_lval:
53094:         FETCH_OBJECT(cx, i - 1, obj);
53094:         break;
53094: 
53094:       case JSOP_INITPROP:
53094:       {
53094:         JS_ASSERT(regs.sp - fp->base() >= 2);
53094:         rval = regs.sp[-1];
53094:         i = -1;
53094:         JSAtom *atom;
53094:         LOAD_ATOM(0, atom);
53094:         id = ATOM_TO_JSID(atom);
53094:         goto gs_get_lval;
53094:       }
53094:       default:
53094:         JS_ASSERT(op2 == JSOP_INITELEM);
53094: 
53094:         JS_ASSERT(regs.sp - fp->base() >= 3);
53094:         rval = regs.sp[-1];
53094:         id = JSID_VOID;
53094:         i = -2;
53094:       gs_get_lval:
53094:       {
53094:         const Value &lref = regs.sp[i-1];
53094:         JS_ASSERT(lref.isObject());
53094:         obj = &lref.toObject();
53094:         break;
53094:       }
53094:     }
53094: 
53094:     /* Ensure that id has a type suitable for use with obj. */
53094:     if (JSID_IS_VOID(id))
53094:         FETCH_ELEMENT_ID(obj, i, id);
53094: 
53094:     if (!js_IsCallable(rval)) {
53094:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
53094:                              JSMSG_BAD_GETTER_OR_SETTER,
53094:                              (op == JSOP_GETTER)
53094:                              ? js_getter_str
53094:                              : js_setter_str);
53094:         goto error;
53094:     }
53094: 
53094:     /*
53094:      * Getters and setters are just like watchpoints from an access control
53094:      * point of view.
53094:      */
53094:     Value rtmp;
53094:     uintN attrs;
53094:     if (!CheckAccess(cx, obj, id, JSACC_WATCH, &rtmp, &attrs))
53094:         goto error;
53094: 
53094:     PropertyOp getter, setter;
53094:     if (op == JSOP_GETTER) {
53094:         getter = CastAsPropertyOp(&rval.toObject());
53094:         setter = PropertyStub;
53094:         attrs = JSPROP_GETTER;
53094:     } else {
53094:         getter = PropertyStub;
53094:         setter = CastAsPropertyOp(&rval.toObject());
53094:         attrs = JSPROP_SETTER;
53094:     }
53094:     attrs |= JSPROP_ENUMERATE | JSPROP_SHARED;
53094: 
53094:     /* Check for a readonly or permanent property of the same name. */
53094:     if (!CheckRedeclaration(cx, obj, id, attrs, NULL, NULL))
53094:         goto error;
53094: 
53094:     if (!obj->defineProperty(cx, id, UndefinedValue(), getter, setter, attrs))
53094:         goto error;
53094: 
53094:     regs.sp += i;
53094:     if (js_CodeSpec[op2].ndefs > js_CodeSpec[op2].nuses) {
53094:         JS_ASSERT(js_CodeSpec[op2].ndefs == js_CodeSpec[op2].nuses + 1);
53094:         regs.sp[-1] = rval;
53094:     }
53094:     len = js_CodeSpec[op2].length;
53094:     DO_NEXT_OP(len);
53094: }
53094: 
53094: BEGIN_CASE(JSOP_HOLE)
53094:     PUSH_HOLE();
53094: END_CASE(JSOP_HOLE)
53094: 
53094: BEGIN_CASE(JSOP_NEWARRAY)
53094: {
53094:     len = GET_UINT16(regs.pc);
53094:     cx->assertValidStackDepth(len);
53094:     JSObject *obj = js_NewArrayObject(cx, len, regs.sp - len, JS_TRUE);
53094:     if (!obj)
53094:         goto error;
53094:     regs.sp -= len - 1;
53094:     regs.sp[-1].setObject(*obj);
53094: }
53094: END_CASE(JSOP_NEWARRAY)
53094: 
53094: BEGIN_CASE(JSOP_NEWINIT)
53094: {
53094:     jsint i = GET_INT8(regs.pc);
53094:     JS_ASSERT(i == JSProto_Array || i == JSProto_Object);
53094:     JSObject *obj;
53094:     if (i == JSProto_Array) {
53094:         obj = js_NewArrayObject(cx, 0, NULL);
53094:         if (!obj)
53094:             goto error;
53094:     } else {
53094:         obj = NewBuiltinClassInstance(cx, &js_ObjectClass);
53094:         if (!obj)
53094:             goto error;
53094: 
53094:         if (regs.pc[JSOP_NEWINIT_LENGTH] != JSOP_ENDINIT) {
53094:             JS_LOCK_OBJ(cx, obj);
53094:             JSScope *scope = js_GetMutableScope(cx, obj);
53094:             if (!scope) {
53094:                 JS_UNLOCK_OBJ(cx, obj);
53094:                 goto error;
53094:             }
53094: 
53094:             /*
53094:              * We cannot assume that js_GetMutableScope above creates a scope
53094:              * owned by cx and skip JS_UNLOCK_SCOPE. A new object debugger
53094:              * hook may add properties to the newly created object, suspend
53094:              * the current request and share the object with other threads.
53094:              */
53094:             JS_UNLOCK_SCOPE(cx, scope);
53094:         }
53094:     }
53094: 
53094:     PUSH_OBJECT(*obj);
53094:     CHECK_INTERRUPT_HANDLER();
53094: }
53094: END_CASE(JSOP_NEWINIT)
53094: 
53094: BEGIN_CASE(JSOP_ENDINIT)
53094: {
53094:     /* Re-set the newborn root to the top of this object tree. */
53094:     JS_ASSERT(regs.sp - fp->base() >= 1);
53094:     const Value &lref = regs.sp[-1];
53094:     JS_ASSERT(lref.isObject());
53094:     cx->weakRoots.finalizableNewborns[FINALIZE_OBJECT] = &lref.toObject();
53094: }
53094: END_CASE(JSOP_ENDINIT)
53094: 
53094: BEGIN_CASE(JSOP_INITPROP)
53094: BEGIN_CASE(JSOP_INITMETHOD)
53094: {
53094:     /* Load the property's initial value into rval. */
53094:     JS_ASSERT(regs.sp - fp->base() >= 2);
53094:     Value rval = regs.sp[-1];
53094: 
53094:     /* Load the object being initialized into lval/obj. */
53094:     JSObject *obj = &regs.sp[-2].toObject();
53094:     JS_ASSERT(obj->isNative());
53094: 
53094:     JSScope *scope = obj->scope();
53094: 
53094:     /*
53094:      * Probe the property cache. 
53094:      *
53094:      * We can not assume that the object created by JSOP_NEWINIT is still
53094:      * single-threaded as the debugger can access it from other threads.
53094:      * So check first.
53094:      *
53094:      * On a hit, if the cached sprop has a non-default setter, it must be
53094:      * __proto__. If sprop->parent != scope->lastProperty(), there is a
53094:      * repeated property name. The fast path does not handle these two cases.
53094:      */
53094:     PropertyCacheEntry *entry;
53094:     JSScopeProperty *sprop;
53094:     if (CX_OWNS_OBJECT_TITLE(cx, obj) &&
53094:         JS_PROPERTY_CACHE(cx).testForInit(rt, regs.pc, obj, scope, &sprop, &entry) &&
53094:         sprop->hasDefaultSetter() &&
53094:         sprop->parent == scope->lastProperty())
53094:     {
53094:         /* Fast path. Property cache hit. */
53094:         uint32 slot = sprop->slot;
53094:         JS_ASSERT(slot == scope->freeslot);
53094:         if (slot < obj->numSlots()) {
53094:             ++scope->freeslot;
53094:         } else {
53094:             if (!js_AllocSlot(cx, obj, &slot))
53094:                 goto error;
53094:             JS_ASSERT(slot == sprop->slot);
53094:         }
53094: 
53094:         JS_ASSERT(!scope->lastProperty() ||
53094:                   scope->shape == scope->lastProperty()->shape);
53094:         if (scope->table) {
53094:             JSScopeProperty *sprop2 =
53094:                 scope->addProperty(cx, sprop->id, sprop->getter(), sprop->setter(), slot,
53094:                                    sprop->attributes(), sprop->getFlags(), sprop->shortid);
53094:             if (!sprop2) {
53094:                 js_FreeSlot(cx, obj, slot);
53094:                 goto error;
53094:             }
53094:             JS_ASSERT(sprop2 == sprop);
53094:         } else {
53094:             JS_ASSERT(!scope->isSharedEmpty());
53094:             scope->extend(cx, sprop);
53094:         }
53094: 
53094:         /*
53094:          * No method change check here because here we are adding a new
53094:          * property, not updating an existing slot's value that might
53094:          * contain a method of a branded scope.
53094:          */
53094:         TRACE_2(SetPropHit, entry, sprop);
53094:         obj->lockedSetSlot(slot, rval);
53094:     } else {
53094:         PCMETER(JS_PROPERTY_CACHE(cx).inipcmisses++);
53094: 
53094:         /* Get the immediate property name into id. */
53094:         JSAtom *atom;
53094:         LOAD_ATOM(0, atom);
53094:         jsid id = ATOM_TO_JSID(atom);
53094: 
53094:         /* Set the property named by obj[id] to rval. */
53094:         if (!CheckRedeclaration(cx, obj, id, JSPROP_INITIALIZER, NULL, NULL))
53094:             goto error;
53094: 
53094:         uintN defineHow = (op == JSOP_INITMETHOD)
53094:                           ? JSDNP_CACHE_RESULT | JSDNP_SET_METHOD
53094:                           : JSDNP_CACHE_RESULT;
53094:         if (!(JS_UNLIKELY(atom == cx->runtime->atomState.protoAtom)
53094:               ? js_SetPropertyHelper(cx, obj, id, defineHow, &rval)
53094:               : js_DefineNativeProperty(cx, obj, id, rval, NULL, NULL,
53094:                                         JSPROP_ENUMERATE, 0, 0, NULL,
53094:                                         defineHow))) {
53094:             goto error;
53094:         }
53094:     }
53094: 
53094:     /* Common tail for property cache hit and miss cases. */
53094:     regs.sp--;
53094: }
53094: END_CASE(JSOP_INITPROP);
53094: 
53094: BEGIN_CASE(JSOP_INITELEM)
53094: {
53094:     /* Pop the element's value into rval. */
53094:     JS_ASSERT(regs.sp - fp->base() >= 3);
53094:     const Value &rref = regs.sp[-1];
53094: 
53094:     /* Find the object being initialized at top of stack. */
53094:     const Value &lref = regs.sp[-3];
53094:     JS_ASSERT(lref.isObject());
53094:     JSObject *obj = &lref.toObject();
53094: 
53094:     /* Fetch id now that we have obj. */
53094:     jsid id;
53094:     FETCH_ELEMENT_ID(obj, -2, id);
53094: 
53094:     /*
53094:      * Check for property redeclaration strict warning (we may be in an object
53094:      * initialiser, not an array initialiser).
53094:      */
53094:     if (!CheckRedeclaration(cx, obj, id, JSPROP_INITIALIZER, NULL, NULL))
53094:         goto error;
53094: 
53094:     /*
53094:      * If rref is a hole, do not call JSObject::defineProperty. In this case,
53094:      * obj must be an array, so if the current op is the last element
53094:      * initialiser, set the array length to one greater than id.
53094:      */
53094:     if (rref.isMagic(JS_ARRAY_HOLE)) {
53094:         JS_ASSERT(obj->isArray());
53094:         JS_ASSERT(JSID_IS_INT(id));
53094:         JS_ASSERT(jsuint(JSID_TO_INT(id)) < JS_ARGS_LENGTH_MAX);
53094:         if (js_GetOpcode(cx, script, regs.pc + JSOP_INITELEM_LENGTH) == JSOP_ENDINIT &&
53094:             !js_SetLengthProperty(cx, obj, (jsuint) (JSID_TO_INT(id) + 1))) {
53094:             goto error;
53094:         }
53094:     } else {
53094:         if (!obj->defineProperty(cx, id, rref, NULL, NULL, JSPROP_ENUMERATE))
53094:             goto error;
53094:     }
53094:     regs.sp -= 2;
53094: }
53094: END_CASE(JSOP_INITELEM)
53094: 
53094: #if JS_HAS_SHARP_VARS
53094: 
53094: BEGIN_CASE(JSOP_DEFSHARP)
53094: {
53094:     uint32 slot = GET_UINT16(regs.pc);
53094:     JS_ASSERT(slot + 1 < fp->script->nfixed);
53094:     const Value &lref = fp->slots()[slot];
53094:     JSObject *obj;
53094:     if (lref.isObject()) {
53094:         obj = &lref.toObject();
53094:     } else {
53094:         JS_ASSERT(lref.isUndefined());
53094:         obj = js_NewArrayObject(cx, 0, NULL);
53094:         if (!obj)
53094:             goto error;
53094:         fp->slots()[slot].setObject(*obj);
53094:     }
53094:     jsint i = (jsint) GET_UINT16(regs.pc + UINT16_LEN);
53094:     jsid id = INT_TO_JSID(i);
53094:     const Value &rref = regs.sp[-1];
53094:     if (rref.isPrimitive()) {
53094:         char numBuf[12];
53094:         JS_snprintf(numBuf, sizeof numBuf, "%u", (unsigned) i);
53094:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
53094:                              JSMSG_BAD_SHARP_DEF, numBuf);
53094:         goto error;
53094:     }
53094:     if (!obj->defineProperty(cx, id, rref, NULL, NULL, JSPROP_ENUMERATE))
53094:         goto error;
53094: }
53094: END_CASE(JSOP_DEFSHARP)
53094: 
53094: BEGIN_CASE(JSOP_USESHARP)
53094: {
53094:     uint32 slot = GET_UINT16(regs.pc);
53094:     JS_ASSERT(slot + 1 < fp->script->nfixed);
53094:     const Value &lref = fp->slots()[slot];
53094:     jsint i = (jsint) GET_UINT16(regs.pc + UINT16_LEN);
53094:     Value rval;
53094:     if (lref.isUndefined()) {
53094:         rval.setUndefined();
53094:     } else {
53094:         JSObject *obj = &fp->slots()[slot].toObject();
53094:         jsid id = INT_TO_JSID(i);
53094:         if (!obj->getProperty(cx, id, &rval))
53094:             goto error;
53094:     }
53094:     if (!rval.isObjectOrNull()) {
53094:         char numBuf[12];
53094: 
53094:         JS_snprintf(numBuf, sizeof numBuf, "%u", (unsigned) i);
53094:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
53094:                              JSMSG_BAD_SHARP_USE, numBuf);
53094:         goto error;
53094:     }
53094:     PUSH_COPY(rval);
53094: }
53094: END_CASE(JSOP_USESHARP)
53094: 
53094: BEGIN_CASE(JSOP_SHARPINIT)
53094: {
53094:     uint32 slot = GET_UINT16(regs.pc);
53094:     JS_ASSERT(slot + 1 < fp->script->nfixed);
53094:     Value *vp = &fp->slots()[slot];
53094:     Value rval = vp[1];
53094: 
53094:     /*
53094:      * We peek ahead safely here because empty initialisers get zero
53094:      * JSOP_SHARPINIT ops, and non-empty ones get two: the first comes
53094:      * immediately after JSOP_NEWINIT followed by one or more property
53094:      * initialisers; and the second comes directly before JSOP_ENDINIT.
53094:      */
53094:     if (regs.pc[JSOP_SHARPINIT_LENGTH] != JSOP_ENDINIT) {
53094:         rval.setInt32(rval.isUndefined() ? 1 : rval.toInt32() + 1);
53094:     } else {
53094:         JS_ASSERT(rval.isInt32());
53094:         rval.getInt32Ref() -= 1;
53094:         if (rval.toInt32() == 0)
53094:             vp[0].setUndefined();
53094:     }
53094:     vp[1] = rval;
53094: }
53094: END_CASE(JSOP_SHARPINIT)
53094: 
53094: #endif /* JS_HAS_SHARP_VARS */
53094: 
53094: {
53094: BEGIN_CASE(JSOP_GOSUB)
53094:     PUSH_BOOLEAN(false);
53094:     jsint i = (regs.pc - script->main) + JSOP_GOSUB_LENGTH;
53094:     PUSH_INT32(i);
53094:     len = GET_JUMP_OFFSET(regs.pc);
53094: END_VARLEN_CASE
53094: }
53094: 
53094: {
53094: BEGIN_CASE(JSOP_GOSUBX)
53094:     PUSH_BOOLEAN(false);
53094:     jsint i = (regs.pc - script->main) + JSOP_GOSUBX_LENGTH;
53094:     len = GET_JUMPX_OFFSET(regs.pc);
53094:     PUSH_INT32(i);
53094: END_VARLEN_CASE
53094: }
53094: 
53094: {
53094: BEGIN_CASE(JSOP_RETSUB)
53094:     /* Pop [exception or hole, retsub pc-index]. */
53094:     Value rval, lval;
53094:     POP_COPY_TO(rval);
53094:     POP_COPY_TO(lval);
53094:     JS_ASSERT(lval.isBoolean());
53094:     if (lval.toBoolean()) {
53094:         /*
53094:          * Exception was pending during finally, throw it *before* we adjust
53094:          * pc, because pc indexes into script->trynotes.  This turns out not to
53094:          * be necessary, but it seems clearer.  And it points out a FIXME:
53094:          * 350509, due to Igor Bukanov.
53094:          */
53094:         cx->throwing = JS_TRUE;
53094:         cx->exception = rval;
53094:         goto error;
53094:     }
53094:     JS_ASSERT(rval.isInt32());
53094:     len = rval.toInt32();
53094:     regs.pc = script->main;
53094: END_VARLEN_CASE
53094: }
53094: 
53094: BEGIN_CASE(JSOP_EXCEPTION)
53094:     JS_ASSERT(cx->throwing);
53094:     PUSH_COPY(cx->exception);
53094:     cx->throwing = JS_FALSE;
53094:     CHECK_BRANCH();
53094: END_CASE(JSOP_EXCEPTION)
53094: 
53094: BEGIN_CASE(JSOP_FINALLY)
53094:     CHECK_BRANCH();
53094: END_CASE(JSOP_FINALLY)
53094: 
53094: BEGIN_CASE(JSOP_THROWING)
53094:     JS_ASSERT(!cx->throwing);
53094:     cx->throwing = JS_TRUE;
53094:     POP_COPY_TO(cx->exception);
53094: END_CASE(JSOP_THROWING)
53094: 
53094: BEGIN_CASE(JSOP_THROW)
53094:     JS_ASSERT(!cx->throwing);
53094:     CHECK_BRANCH();
53094:     cx->throwing = JS_TRUE;
53094:     POP_COPY_TO(cx->exception);
53094:     /* let the code at error try to catch the exception. */
53094:     goto error;
53094: 
53094: BEGIN_CASE(JSOP_SETLOCALPOP)
53094: {
53094:     /*
53094:      * The stack must have a block with at least one local slot below the
53094:      * exception object.
53094:      */
53094:     JS_ASSERT((size_t) (regs.sp - fp->base()) >= 2);
53094:     uint32 slot = GET_UINT16(regs.pc);
53094:     JS_ASSERT(slot + 1 < script->nslots);
53094:     POP_COPY_TO(fp->slots()[slot]);
53094: }
53094: END_CASE(JSOP_SETLOCALPOP)
53094: 
53094: BEGIN_CASE(JSOP_IFPRIMTOP)
53094:     /*
53094:      * If the top of stack is of primitive type, jump to our target. Otherwise
53094:      * advance to the next opcode.
53094:      */
53094:     JS_ASSERT(regs.sp > fp->base());
53094:     if (regs.sp[-1].isPrimitive()) {
53094:         len = GET_JUMP_OFFSET(regs.pc);
53094:         BRANCH(len);
53094:     }
53094: END_CASE(JSOP_IFPRIMTOP)
53094: 
53094: BEGIN_CASE(JSOP_PRIMTOP)
53094:     JS_ASSERT(regs.sp > fp->base());
53094:     if (regs.sp[-1].isObject()) {
53094:         jsint i = GET_INT8(regs.pc);
53094:         js_ReportValueError2(cx, JSMSG_CANT_CONVERT_TO, -2, regs.sp[-2], NULL,
53094:                              (i == JSTYPE_VOID) ? "primitive type" : JS_TYPE_STR(i));
53094:         goto error;
53094:     }
53094: END_CASE(JSOP_PRIMTOP)
53094: 
53094: BEGIN_CASE(JSOP_OBJTOP)
53094:     if (regs.sp[-1].isPrimitive()) {
53094:         js_ReportValueError(cx, GET_UINT16(regs.pc), -1, regs.sp[-1], NULL);
53094:         goto error;
53094:     }
53094: END_CASE(JSOP_OBJTOP)
53094: 
53094: BEGIN_CASE(JSOP_INSTANCEOF)
53094: {
53094:     const Value &rref = regs.sp[-1];
53094:     JSObject *obj;
53094:     if (rref.isPrimitive() ||
53094:         !(obj = &rref.toObject())->map->ops->hasInstance) {
53094:         js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
53094:                             -1, rref, NULL);
53094:         goto error;
53094:     }
53094:     const Value &lref = regs.sp[-2];
53094:     JSBool cond = JS_FALSE;
53094:     if (!obj->map->ops->hasInstance(cx, obj, &lref, &cond))
53094:         goto error;
53094:     regs.sp--;
53094:     regs.sp[-1].setBoolean(cond);
53094: }
53094: END_CASE(JSOP_INSTANCEOF)
53094: 
53094: #if JS_HAS_DEBUGGER_KEYWORD
53094: BEGIN_CASE(JSOP_DEBUGGER)
53094: {
53094:     JSDebuggerHandler handler = cx->debugHooks->debuggerHandler;
53094:     if (handler) {
53094:         Value rval;
53094:         switch (handler(cx, script, regs.pc, Jsvalify(&rval), cx->debugHooks->debuggerHandlerData)) {
53094:         case JSTRAP_ERROR:
53094:             goto error;
53094:         case JSTRAP_CONTINUE:
53094:             break;
53094:         case JSTRAP_RETURN:
53094:             fp->rval = rval;
53094:             interpReturnOK = JS_TRUE;
53094:             goto forced_return;
53094:         case JSTRAP_THROW:
53094:             cx->throwing = JS_TRUE;
53094:             cx->exception = rval;
53094:             goto error;
53094:         default:;
53094:         }
53094:         CHECK_INTERRUPT_HANDLER();
53094:     }
53094: }
53094: END_CASE(JSOP_DEBUGGER)
53094: #endif /* JS_HAS_DEBUGGER_KEYWORD */
53094: 
53094: #if JS_HAS_XML_SUPPORT
53094: BEGIN_CASE(JSOP_DEFXMLNS)
53094: {
53094:     Value rval;
53094:     POP_COPY_TO(rval);
53094:     if (!js_SetDefaultXMLNamespace(cx, rval))
53094:         goto error;
53094: }
53094: END_CASE(JSOP_DEFXMLNS)
53094: 
53094: BEGIN_CASE(JSOP_ANYNAME)
53094: {
53094:     jsid id;
53094:     if (!js_GetAnyName(cx, &id))
53094:         goto error;
53094:     PUSH_COPY(IdToValue(id));
53094: }
53094: END_CASE(JSOP_ANYNAME)
53094: 
53094: BEGIN_CASE(JSOP_QNAMEPART)
53094: {
53094:     JSAtom *atom;
53094:     LOAD_ATOM(0, atom);
53094:     PUSH_STRING(ATOM_TO_STRING(atom));
53094: }
53094: END_CASE(JSOP_QNAMEPART)
53094: 
53094: BEGIN_CASE(JSOP_QNAMECONST)
53094: {
53094:     JSAtom *atom;
53094:     LOAD_ATOM(0, atom);
53094:     Value rval = StringValue(ATOM_TO_STRING(atom));
53094:     Value lval = regs.sp[-1];
53094:     JSObject *obj = js_ConstructXMLQNameObject(cx, lval, rval);
53094:     if (!obj)
53094:         goto error;
53094:     regs.sp[-1].setObject(*obj);
53094: }
53094: END_CASE(JSOP_QNAMECONST)
53094: 
53094: BEGIN_CASE(JSOP_QNAME)
53094: {
53094:     Value rval = regs.sp[-1];
53094:     Value lval = regs.sp[-2];
53094:     JSObject *obj = js_ConstructXMLQNameObject(cx, lval, rval);
53094:     if (!obj)
53094:         goto error;
53094:     regs.sp--;
53094:     regs.sp[-1].setObject(*obj);
53094: }
53094: END_CASE(JSOP_QNAME)
53094: 
53094: BEGIN_CASE(JSOP_TOATTRNAME)
53094: {
53094:     Value rval;
53094:     rval = regs.sp[-1];
53094:     if (!js_ToAttributeName(cx, &rval))
53094:         goto error;
53094:     regs.sp[-1] = rval;
53094: }
53094: END_CASE(JSOP_TOATTRNAME)
53094: 
53094: BEGIN_CASE(JSOP_TOATTRVAL)
53094: {
53094:     Value rval;
53094:     rval = regs.sp[-1];
53094:     JS_ASSERT(rval.isString());
53094:     JSString *str = js_EscapeAttributeValue(cx, rval.toString(), JS_FALSE);
53094:     if (!str)
53094:         goto error;
53094:     regs.sp[-1].setString(str);
53094: }
53094: END_CASE(JSOP_TOATTRVAL)
53094: 
53094: BEGIN_CASE(JSOP_ADDATTRNAME)
53094: BEGIN_CASE(JSOP_ADDATTRVAL)
53094: {
53094:     Value rval = regs.sp[-1];
53094:     Value lval = regs.sp[-2];
53094:     JSString *str = lval.toString();
53094:     JSString *str2 = rval.toString();
53094:     str = js_AddAttributePart(cx, op == JSOP_ADDATTRNAME, str, str2);
53094:     if (!str)
53094:         goto error;
53094:     regs.sp--;
53094:     regs.sp[-1].setString(str);
53094: }
53094: END_CASE(JSOP_ADDATTRNAME)
53094: 
53094: BEGIN_CASE(JSOP_BINDXMLNAME)
53094: {
53094:     Value lval;
53094:     lval = regs.sp[-1];
53094:     JSObject *obj;
53094:     jsid id;
53094:     if (!js_FindXMLProperty(cx, lval, &obj, &id))
53094:         goto error;
53094:     regs.sp[-1].setObjectOrNull(obj);
53094:     PUSH_COPY(IdToValue(id));
53094: }
53094: END_CASE(JSOP_BINDXMLNAME)
53094: 
53094: BEGIN_CASE(JSOP_SETXMLNAME)
53094: {
53094:     JSObject *obj = &regs.sp[-3].toObject();
53094:     Value rval = regs.sp[-1];
53094:     jsid id;
53094:     FETCH_ELEMENT_ID(obj, -2, id);
53094:     if (!obj->setProperty(cx, id, &rval))
53094:         goto error;
53094:     rval = regs.sp[-1];
53094:     regs.sp -= 2;
53094:     regs.sp[-1] = rval;
53094: }
53094: END_CASE(JSOP_SETXMLNAME)
53094: 
53094: BEGIN_CASE(JSOP_CALLXMLNAME)
53094: BEGIN_CASE(JSOP_XMLNAME)
53094: {
53094:     Value lval = regs.sp[-1];
53094:     JSObject *obj;
53094:     jsid id;
53094:     if (!js_FindXMLProperty(cx, lval, &obj, &id))
53094:         goto error;
53094:     Value rval;
53094:     if (!obj->getProperty(cx, id, &rval))
53094:         goto error;
53094:     regs.sp[-1] = rval;
53094:     if (op == JSOP_CALLXMLNAME)
53094:         PUSH_OBJECT(*obj);
53094: }
53094: END_CASE(JSOP_XMLNAME)
53094: 
53094: BEGIN_CASE(JSOP_DESCENDANTS)
53094: BEGIN_CASE(JSOP_DELDESC)
53094: {
53094:     JSObject *obj;
53094:     FETCH_OBJECT(cx, -2, obj);
53094:     jsval rval = Jsvalify(regs.sp[-1]);
53094:     if (!js_GetXMLDescendants(cx, obj, rval, &rval))
53094:         goto error;
53094: 
53094:     if (op == JSOP_DELDESC) {
53094:         regs.sp[-1] = Valueify(rval);   /* set local root */
53094:         if (!js_DeleteXMLListElements(cx, JSVAL_TO_OBJECT(rval)))
53094:             goto error;
53094:         rval = JSVAL_TRUE;                  /* always succeed */
53094:     }
53094: 
53094:     regs.sp--;
53094:     regs.sp[-1] = Valueify(rval);
53094: }
53094: END_CASE(JSOP_DESCENDANTS)
53094: 
53094: {
53094: BEGIN_CASE(JSOP_FILTER)
53094:     /*
53094:      * We push the hole value before jumping to [enditer] so we can detect the
53094:      * first iteration and direct js_StepXMLListFilter to initialize filter's
53094:      * state.
53094:      */
53094:     PUSH_HOLE();
53094:     len = GET_JUMP_OFFSET(regs.pc);
53094:     JS_ASSERT(len > 0);
53094: END_VARLEN_CASE
53094: }
53094: 
53094: BEGIN_CASE(JSOP_ENDFILTER)
53094: {
53094:     bool cond = !regs.sp[-1].isMagic();
53094:     if (cond) {
53094:         /* Exit the "with" block left from the previous iteration. */
53094:         js_LeaveWith(cx);
53094:     }
53094:     if (!js_StepXMLListFilter(cx, cond))
53094:         goto error;
53094:     if (!regs.sp[-1].isNull()) {
53094:         /*
53094:          * Decrease sp after EnterWith returns as we use sp[-1] there to root
53094:          * temporaries.
53094:          */
53094:         JS_ASSERT(IsXML(regs.sp[-1]));
53094:         if (!js_EnterWith(cx, -2))
53094:             goto error;
53094:         regs.sp--;
53094:         len = GET_JUMP_OFFSET(regs.pc);
53094:         JS_ASSERT(len < 0);
53094:         BRANCH(len);
53094:     }
53094:     regs.sp--;
53094: }
53094: END_CASE(JSOP_ENDFILTER);
53094: 
53094: BEGIN_CASE(JSOP_TOXML)
53094: {
53094:     Value rval = regs.sp[-1];
53094:     JSObject *obj = js_ValueToXMLObject(cx, rval);
53094:     if (!obj)
53094:         goto error;
53094:     regs.sp[-1].setObject(*obj);
53094: }
53094: END_CASE(JSOP_TOXML)
53094: 
53094: BEGIN_CASE(JSOP_TOXMLLIST)
53094: {
53094:     Value rval = regs.sp[-1];
53094:     JSObject *obj = js_ValueToXMLListObject(cx, rval);
53094:     if (!obj)
53094:         goto error;
53094:     regs.sp[-1].setObject(*obj);
53094: }
53094: END_CASE(JSOP_TOXMLLIST)
53094: 
53094: BEGIN_CASE(JSOP_XMLTAGEXPR)
53094: {
53094:     Value rval = regs.sp[-1];
53094:     JSString *str = js_ValueToString(cx, rval);
53094:     if (!str)
53094:         goto error;
53094:     regs.sp[-1].setString(str);
53094: }
53094: END_CASE(JSOP_XMLTAGEXPR)
53094: 
53094: BEGIN_CASE(JSOP_XMLELTEXPR)
53094: {
53094:     Value rval = regs.sp[-1];
53094:     JSString *str;
53094:     if (IsXML(rval)) {
53094:         str = js_ValueToXMLString(cx, rval);
53094:     } else {
53094:         str = js_ValueToString(cx, rval);
53094:         if (str)
53094:             str = js_EscapeElementValue(cx, str);
53094:     }
53094:     if (!str)
53094:         goto error;
53094:     regs.sp[-1].setString(str);
53094: }
53094: END_CASE(JSOP_XMLELTEXPR)
53094: 
53094: BEGIN_CASE(JSOP_XMLCDATA)
53094: {
53094:     JSAtom *atom;
53094:     LOAD_ATOM(0, atom);
53094:     JSString *str = ATOM_TO_STRING(atom);
53094:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_TEXT, NULL, str);
53094:     if (!obj)
53094:         goto error;
53094:     PUSH_OBJECT(*obj);
53094: }
53094: END_CASE(JSOP_XMLCDATA)
53094: 
53094: BEGIN_CASE(JSOP_XMLCOMMENT)
53094: {
53094:     JSAtom *atom;
53094:     LOAD_ATOM(0, atom);
53094:     JSString *str = ATOM_TO_STRING(atom);
53094:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_COMMENT, NULL, str);
53094:     if (!obj)
53094:         goto error;
53094:     PUSH_OBJECT(*obj);
53094: }
53094: END_CASE(JSOP_XMLCOMMENT)
53094: 
53094: BEGIN_CASE(JSOP_XMLPI)
53094: {
53094:     JSAtom *atom;
53094:     LOAD_ATOM(0, atom);
53094:     JSString *str = ATOM_TO_STRING(atom);
53094:     Value rval = regs.sp[-1];
53094:     JSString *str2 = rval.toString();
53094:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_PROCESSING_INSTRUCTION, str, str2);
53094:     if (!obj)
53094:         goto error;
53094:     regs.sp[-1].setObject(*obj);
53094: }
53094: END_CASE(JSOP_XMLPI)
53094: 
53094: BEGIN_CASE(JSOP_GETFUNNS)
53094: {
53094:     Value rval;
53094:     if (!js_GetFunctionNamespace(cx, &rval))
53094:         goto error;
53094:     PUSH_COPY(rval);
53094: }
53094: END_CASE(JSOP_GETFUNNS)
53094: #endif /* JS_HAS_XML_SUPPORT */
53094: 
53094: BEGIN_CASE(JSOP_ENTERBLOCK)
53094: {
53094:     JSObject *obj;
53094:     LOAD_OBJECT(0, obj);
53094:     JS_ASSERT(!OBJ_IS_CLONED_BLOCK(obj));
53094:     JS_ASSERT(fp->base() + OBJ_BLOCK_DEPTH(cx, obj) == regs.sp);
53094:     Value *vp = regs.sp + OBJ_BLOCK_COUNT(cx, obj);
53094:     JS_ASSERT(regs.sp < vp);
53094:     JS_ASSERT(vp <= fp->slots() + script->nslots);
53094:     SetValueRangeToUndefined(regs.sp, vp);
53094:     regs.sp = vp;
53094: 
53094: #ifdef DEBUG
53094:     JS_ASSERT(fp->blockChain == obj->getParent());
53094: 
53094:     /*
53094:      * The young end of fp->scopeChain may omit blocks if we haven't closed
53094:      * over them, but if there are any closure blocks on fp->scopeChain, they'd
53094:      * better be (clones of) ancestors of the block we're entering now;
53094:      * anything else we should have popped off fp->scopeChain when we left its
53094:      * static scope.
53094:      */
53094:     JSObject *obj2 = fp->scopeChain;
53094:     Class *clasp;
53094:     while ((clasp = obj2->getClass()) == &js_WithClass)
53094:         obj2 = obj2->getParent();
53094:     if (clasp == &js_BlockClass &&
53094:         obj2->getPrivate() == js_FloatingFrameIfGenerator(cx, fp)) {
53094:         JSObject *youngestProto = obj2->getProto();
53094:         JS_ASSERT(!OBJ_IS_CLONED_BLOCK(youngestProto));
53094:         JSObject *parent = obj;
53094:         while ((parent = parent->getParent()) != youngestProto)
53094:             JS_ASSERT(parent);
53094:     }
53094: #endif
53094: 
53094:     fp->blockChain = obj;
53094: }
53094: END_CASE(JSOP_ENTERBLOCK)
53094: 
53094: BEGIN_CASE(JSOP_LEAVEBLOCKEXPR)
53094: BEGIN_CASE(JSOP_LEAVEBLOCK)
53094: {
53094: #ifdef DEBUG
53094:     JS_ASSERT(fp->blockChain->getClass() == &js_BlockClass);
53094:     uintN blockDepth = OBJ_BLOCK_DEPTH(cx, fp->blockChain);
53094: 
53094:     JS_ASSERT(blockDepth <= StackDepth(script));
53094: #endif
53094:     /*
53094:      * If we're about to leave the dynamic scope of a block that has been
53094:      * cloned onto fp->scopeChain, clear its private data, move its locals from
53094:      * the stack into the clone, and pop it off the chain.
53094:      */
53094:     JSObject *obj = fp->scopeChain;
53094:     if (obj->getProto() == fp->blockChain) {
53094:         JS_ASSERT(obj->getClass() == &js_BlockClass);
53094:         if (!js_PutBlockObject(cx, JS_TRUE))
53094:             goto error;
53094:     }
53094: 
53094:     /* Pop the block chain, too.  */
53094:     fp->blockChain = fp->blockChain->getParent();
53094: 
53094:     /* Move the result of the expression to the new topmost stack slot. */
53094:     Value *vp = NULL;  /* silence GCC warnings */
53094:     if (op == JSOP_LEAVEBLOCKEXPR)
53094:         vp = &regs.sp[-1];
53094:     regs.sp -= GET_UINT16(regs.pc);
53094:     if (op == JSOP_LEAVEBLOCKEXPR) {
53094:         JS_ASSERT(fp->base() + blockDepth == regs.sp - 1);
53094:         regs.sp[-1] = *vp;
53094:     } else {
53094:         JS_ASSERT(fp->base() + blockDepth == regs.sp);
53094:     }
53094: }
53094: END_CASE(JSOP_LEAVEBLOCK)
53094: 
53094: #if JS_HAS_GENERATORS
53094: BEGIN_CASE(JSOP_GENERATOR)
53094: {
53094:     ASSERT_NOT_THROWING(cx);
53094:     regs.pc += JSOP_GENERATOR_LENGTH;
53094:     JSObject *obj = js_NewGenerator(cx);
53094:     if (!obj)
53094:         goto error;
53094:     JS_ASSERT(!fp->callobj && !fp->argsobj);
53094:     fp->rval.setObject(*obj);
53094:     interpReturnOK = true;
53094:     if (inlineCallCount != 0)
53094:         goto inline_return;
53094:     goto exit;
53094: }
53094: 
53094: BEGIN_CASE(JSOP_YIELD)
53094:     ASSERT_NOT_THROWING(cx);
53094:     if (cx->generatorFor(fp)->state == JSGEN_CLOSING) {
53094:         js_ReportValueError(cx, JSMSG_BAD_GENERATOR_YIELD,
53094:                             JSDVG_SEARCH_STACK, fp->argv[-2], NULL);
53094:         goto error;
53094:     }
53094:     fp->rval = regs.sp[-1];
53094:     fp->flags |= JSFRAME_YIELDING;
53094:     regs.pc += JSOP_YIELD_LENGTH;
53094:     interpReturnOK = JS_TRUE;
53094:     goto exit;
53094: 
53094: BEGIN_CASE(JSOP_ARRAYPUSH)
53094: {
53094:     uint32 slot = GET_UINT16(regs.pc);
53094:     JS_ASSERT(script->nfixed <= slot);
53094:     JS_ASSERT(slot < script->nslots);
53094:     JSObject *obj = &fp->slots()[slot].toObject();
53094:     if (!js_ArrayCompPush(cx, obj, regs.sp[-1]))
53094:         goto error;
53094:     regs.sp--;
53094: }
53094: END_CASE(JSOP_ARRAYPUSH)
53094: #endif /* JS_HAS_GENERATORS */
53094: 
53094:   L_JSOP_UNUSED180:
53094: 
53094: #if JS_THREADED_INTERP
53094:   L_JSOP_BACKPATCH:
53094:   L_JSOP_BACKPATCH_POP:
53094: 
53094: # if !JS_HAS_GENERATORS
53094:   L_JSOP_GENERATOR:
53094:   L_JSOP_YIELD:
53094:   L_JSOP_ARRAYPUSH:
53094: # endif
53094: 
53094: # if !JS_HAS_SHARP_VARS
53094:   L_JSOP_DEFSHARP:
53094:   L_JSOP_USESHARP:
53094:   L_JSOP_SHARPINIT:
53094: # endif
53094: 
53094: # if !JS_HAS_DESTRUCTURING
53094:   L_JSOP_ENUMCONSTELEM:
53094: # endif
53094: 
53094: # if !JS_HAS_XML_SUPPORT
53094:   L_JSOP_CALLXMLNAME:
53094:   L_JSOP_STARTXMLEXPR:
53094:   L_JSOP_STARTXML:
53094:   L_JSOP_DELDESC:
53094:   L_JSOP_GETFUNNS:
53094:   L_JSOP_XMLPI:
53094:   L_JSOP_XMLCOMMENT:
53094:   L_JSOP_XMLCDATA:
53094:   L_JSOP_XMLELTEXPR:
53094:   L_JSOP_XMLTAGEXPR:
53094:   L_JSOP_TOXMLLIST:
53094:   L_JSOP_TOXML:
53094:   L_JSOP_ENDFILTER:
53094:   L_JSOP_FILTER:
53094:   L_JSOP_DESCENDANTS:
53094:   L_JSOP_XMLNAME:
53094:   L_JSOP_SETXMLNAME:
53094:   L_JSOP_BINDXMLNAME:
53094:   L_JSOP_ADDATTRVAL:
53094:   L_JSOP_ADDATTRNAME:
53094:   L_JSOP_TOATTRVAL:
53094:   L_JSOP_TOATTRNAME:
53094:   L_JSOP_QNAME:
53094:   L_JSOP_QNAMECONST:
53094:   L_JSOP_QNAMEPART:
53094:   L_JSOP_ANYNAME:
53094:   L_JSOP_DEFXMLNS:
53094: # endif
53094: 
53094:   L_JSOP_UNUSED218:
53094: 
53094: #endif /* !JS_THREADED_INTERP */
31481: #if !JS_THREADED_INTERP
    1:           default:
    1: #endif
    1:           {
    1:             char numBuf[12];
    1:             JS_snprintf(numBuf, sizeof numBuf, "%d", op);
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_BYTECODE, numBuf);
11859:             goto error;
    1:           }
    1: 
    1: #if !JS_THREADED_INTERP
    1:         } /* switch (op) */
23111:     } /* for (;;) */
    1: #endif /* !JS_THREADED_INTERP */
    1: 
11859:   error:
42717:     JS_ASSERT(cx->regs == &regs);
39895: #ifdef JS_TRACER
21685:     if (fp->imacpc && cx->throwing) {
21685:         // Handle other exceptions as if they came from the imacro-calling pc.
21685:         regs.pc = fp->imacpc;
21685:         fp->imacpc = NULL;
21685:         atoms = script->atomMap.vector;
21685:     }
39895: #endif
21685: 
26277:     JS_ASSERT((size_t)((fp->imacpc ? fp->imacpc : regs.pc) - script->code) < script->length);
24245: 
27490: #ifdef JS_TRACER
24245:     /*
24245:      * This abort could be weakened to permit tracing through exceptions that
24245:      * are thrown and caught within a loop, with the co-operation of the tracer.
24245:      * For now just bail on any sign of trouble.
24245:      */
27490:     if (TRACE_RECORDER(cx))
37741:         AbortRecording(cx, "error or exception while recording");
27490: #endif
24245: 
11859:     if (!cx->throwing) {
11859:         /* This is an error, not a catchable exception, quit the frame ASAP. */
52522:         interpReturnOK = JS_FALSE;
11859:     } else {
41863:         JSThrowHook handler;
 1825:         JSTryNote *tn, *tnlimit;
 1825:         uint32 offset;
 1825: 
11758:         /* Call debugger throw hook if set. */
 2433:         handler = cx->debugHooks->throwHook;
    1:         if (handler) {
52522:             Value rval;
52522:             switch (handler(cx, script, regs.pc, Jsvalify(&rval),
 2433:                             cx->debugHooks->throwHookData)) {
    1:               case JSTRAP_ERROR:
    1:                 cx->throwing = JS_FALSE;
11859:                 goto error;
    1:               case JSTRAP_RETURN:
    1:                 cx->throwing = JS_FALSE;
    1:                 fp->rval = rval;
52522:                 interpReturnOK = JS_TRUE;
11758:                 goto forced_return;
    1:               case JSTRAP_THROW:
    1:                 cx->exception = rval;
    1:               case JSTRAP_CONTINUE:
    1:               default:;
    1:             }
23111:             CHECK_INTERRUPT_HANDLER();
    1:         }
    1: 
    1:         /*
    1:          * Look for a try block in script that can catch this exception.
    1:          */
 3235:         if (script->trynotesOffset == 0)
 1825:             goto no_catch;
 1825: 
13168:         offset = (uint32)(regs.pc - script->main);
32723:         tn = script->trynotes()->vector;
32723:         tnlimit = tn + script->trynotes()->length;
 3025:         do {
 3025:             if (offset - tn->start >= tn->length)
 3025:                 continue;
 3025: 
 3025:             /*
 3025:              * We have a note that covers the exception pc but we must check
 3025:              * whether the interpreter has already executed the corresponding
 3025:              * handler. This is possible when the executed bytecode
 3025:              * implements break or return from inside a for-in loop.
 3025:              *
 3025:              * In this case the emitter generates additional [enditer] and
 3025:              * [gosub] opcodes to close all outstanding iterators and execute
 3025:              * the finally blocks. If such an [enditer] throws an exception,
 3025:              * its pc can still be inside several nested for-in loops and
 3025:              * try-finally statements even if we have already closed the
 3025:              * corresponding iterators and invoked the finally blocks.
 3025:              *
 3025:              * To address this, we make [enditer] always decrease the stack
 3025:              * even when its implementation throws an exception. Thus already
 3025:              * executed [enditer] and [gosub] opcodes will have try notes
 3025:              * with the stack depth exceeding the current one and this
 3025:              * condition is what we use to filter them out.
 3025:              */
52522:             if (tn->stackDepth > regs.sp - fp->base())
 3025:                 continue;
 3025: 
 3025:             /*
 3025:              * Set pc to the first bytecode after the the try note to point
 3025:              * to the beginning of catch or finally or to [enditer] closing
 3025:              * the for-in loop.
 1825:              */
13168:             regs.pc = (script)->main + tn->start + tn->length;
13168: 
52522:             JSBool ok = js_UnwindScope(cx, tn->stackDepth, JS_TRUE);
52522:             JS_ASSERT(regs.sp == fp->base() + tn->stackDepth);
11758:             if (!ok) {
11758:                 /*
11758:                  * Restart the handler search with updated pc and stack depth
11758:                  * to properly notify the debugger.
11758:                  */
11859:                 goto error;
11758:             }
 1825: 
 3025:             switch (tn->kind) {
20420:               case JSTRY_CATCH:
25215:                 JS_ASSERT(js_GetOpcode(cx, fp->script, regs.pc) == JSOP_ENTERBLOCK);
 3025: 
 3025: #if JS_HAS_GENERATORS
 3025:                 /* Catch cannot intercept the closing of a generator. */
52524:                 if (JS_UNLIKELY(cx->exception.isMagic(JS_GENERATOR_CLOSING)))
 3025:                     break;
 3025: #endif
 3025: 
 1825:                 /*
 3025:                  * Don't clear cx->throwing to save cx->exception from GC
 3025:                  * until it is pushed to the stack via [exception] in the
 3025:                  * catch block.
 3025:                  */
 3025:                 len = 0;
 3025:                 DO_NEXT_OP(len);
 3025: 
20420:               case JSTRY_FINALLY:
 3025:                 /*
 3025:                  * Push (true, exception) pair for finally to indicate that
 1825:                  * [retsub] should rethrow the exception.
 1825:                  */
52522:                 PUSH_BOOLEAN(true);
52522:                 PUSH_COPY(cx->exception);
 1825:                 cx->throwing = JS_FALSE;
 3025:                 len = 0;
 3025:                 DO_NEXT_OP(len);
 3025: 
42641:               case JSTRY_ITER: {
42641:                 /* This is similar to JSOP_ENDITER in the interpreter loop. */
25215:                 JS_ASSERT(js_GetOpcode(cx, fp->script, regs.pc) == JSOP_ENDITER);
42641:                 AutoValueRooter tvr(cx, cx->exception);
42641:                 cx->throwing = false;
53099:                 ok = js_CloseIterator(cx, &regs.sp[-1].toObject());
42641:                 regs.sp -= 1;
11859:                 if (!ok)
11859:                     goto error;
42641:                 cx->throwing = true;
42641:                 cx->exception = tvr.value();
42641:               }
11859:            }
11859:         } while (++tn != tnlimit);
11859: 
11859:       no_catch:
 3025:         /*
11859:          * Propagate the exception or error to the caller unless the exception
11859:          * is an asynchronous return from a generator.
 3025:          */
52522:         interpReturnOK = JS_FALSE;
 1969: #if JS_HAS_GENERATORS
52522:         if (JS_UNLIKELY(cx->throwing &&
52524:                         cx->exception.isMagic(JS_GENERATOR_CLOSING))) {
 1969:             cx->throwing = JS_FALSE;
52522:             interpReturnOK = JS_TRUE;
52522:             fp->rval.setUndefined();
 1969:         }
 1969: #endif
    1:     }
    1: 
11758:   forced_return:
    1:     /*
52522:      * Unwind the scope making sure that interpReturnOK stays false even when
52522:      * js_UnwindScope returns true.
11859:      *
52522:      * When a trap handler returns JSTRAP_RETURN, we jump here with
52522:      * interpReturnOK set to true bypassing any finally blocks.
    1:      */
52522:     interpReturnOK &= js_UnwindScope(cx, 0, interpReturnOK || cx->throwing);
52522:     JS_ASSERT(regs.sp == fp->base());
11758: 
27233: #ifdef DEBUG
27233:     cx->tracePrevPc = NULL;
27233: #endif
27233: 
    1:     if (inlineCallCount)
    1:         goto inline_return;
    1: 
11758:   exit:
    1:     /*
11377:      * At this point we are inevitably leaving an interpreted function or a
11377:      * top-level script, and returning to one of:
11758:      * (a) an "out of line" call made through js_Invoke;
11758:      * (b) a js_Execute activation;
11758:      * (c) a generator (SendToGenerator, jsiter.c).
11758:      *
11859:      * We must not be in an inline frame. The check above ensures that for the
11859:      * error case and for a normal return, the code jumps directly to parent's
11859:      * frame pc.
    1:      */
11758:     JS_ASSERT(inlineCallCount == 0);
42717:     JS_ASSERT(cx->regs == &regs);
42717:     *prevContextRegs = regs;
42717:     cx->setCurrentRegs(prevContextRegs);
42717: 
18181: #ifdef JS_TRACER
19093:     if (TRACE_RECORDER(cx))
52522:         AbortRecording(cx, "recording out of Interpret");
18181: #endif
13168: 
42717:     JS_ASSERT_IF(!fp->isGenerator(), !fp->blockChain);
42717:     JS_ASSERT_IF(!fp->isGenerator(), !js_IsActiveWithOrBlock(cx, fp->scopeChain, 0));
16072: 
52522:     /* Undo the remaining effects committed on entry to Interpret. */
27012:     if (script->staticLevel < JS_DISPLAY_SIZE)
27012:         cx->display[script->staticLevel] = fp->displaySave;
    1:     if (cx->version == currentVersion && currentVersion != originalVersion)
    1:         js_SetVersion(cx, originalVersion);
18308:     --cx->interpLevel;
18706: 
52522:     return interpReturnOK;
    1: 
    1:   atom_not_defined:
    1:     {
11720:         const char *printable;
11720: 
52522:         printable = js_AtomToPrintableString(cx, atomNotDefined);
    1:         if (printable)
    1:             js_ReportIsNotDefined(cx, printable);
11859:         goto error;
11859:     }
11859: }
12551: 
52522: } /* namespace js */
52522: 
15996: #endif /* !defined jsinvoke_cpp___ */
