    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *    Mark Hammond <mhammond@skippinet.com.au>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIArray.h"
    1: #include "nsIScriptTimeoutHandler.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIJSRuntimeService.h"
    1: #include "nsJSUtils.h"
    1: #include "nsDOMJSUtils.h"
    1: #include "nsContentUtils.h"
    1: #include "nsJSEnvironment.h"
    1: #include "nsServiceManagerUtils.h"
    1: #include "nsDOMError.h"
10986: #include "nsGlobalWindow.h"
39061: #include "nsIContentSecurityPolicy.h"
    1: 
    1: static const char kSetIntervalStr[] = "setInterval";
    1: static const char kSetTimeoutStr[] = "setTimeout";
    1: 
    1: // Our JS nsIScriptTimeoutHandler implementation.
    1: class nsJSScriptTimeoutHandler: public nsIScriptTimeoutHandler
    1: {
    1: public:
    1:   // nsISupports
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 7230:   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(nsJSScriptTimeoutHandler)
    1: 
    1:   nsJSScriptTimeoutHandler();
    1:   ~nsJSScriptTimeoutHandler();
    1: 
    1:   virtual const PRUnichar *GetHandlerText();
    1:   virtual void *GetScriptObject() {
    1:     return mFunObj;
    1:   }
    1:   virtual void GetLocation(const char **aFileName, PRUint32 *aLineNo) {
    1:     *aFileName = mFileName.get();
    1:     *aLineNo = mLineNo;
    1:   }
    1: 
    1:   virtual PRUint32 GetScriptTypeID() {
    1:         return nsIProgrammingLanguage::JAVASCRIPT;
    1:   }
    1:   virtual PRUint32 GetScriptVersion() {
    1:         return mVersion;
    1:   }
    1: 
    1:   virtual nsIArray *GetArgv() {
    1:     return mArgv;
    1:   }
    1:   // Called by the timeout mechanism so the secret 'lateness' arg can be
    1:   // added.
    1:   virtual void SetLateness(PRIntervalTime aHowLate);
    1: 
10986:   nsresult Init(nsGlobalWindow *aWindow, PRBool *aIsInterval,
    1:                 PRInt32 *aInterval);
    1: 
    1:   void ReleaseJSObjects();
    1: 
    1: private:
    1: 
    1:   nsCOMPtr<nsIScriptContext> mContext;
    1: 
    1:   // filename, line number and JS language version string of the
    1:   // caller of setTimeout()
16013:   nsCString mFileName;
    1:   PRUint32 mLineNo;
    1:   PRUint32 mVersion;
    1:   nsCOMPtr<nsIArray> mArgv;
    1: 
    1:   // The JS expression to evaluate or function to call, if !mExpr
    1:   JSString *mExpr;
    1:   JSObject *mFunObj;
    1: };
    1: 
    1: 
    1: // nsJSScriptTimeoutHandler
    1: // QueryInterface implementation for nsJSScriptTimeoutHandler
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsJSScriptTimeoutHandler)
10981: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsJSScriptTimeoutHandler)
    1:   tmp->ReleaseJSObjects();
10981: NS_IMPL_CYCLE_COLLECTION_ROOT_END
10981: NS_IMPL_CYCLE_COLLECTION_UNLINK_0(nsJSScriptTimeoutHandler)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsJSScriptTimeoutHandler)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContext)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mArgv)
 7230:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
 7230: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsJSScriptTimeoutHandler)
 7230:   NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mExpr)
 7230:   NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mFunObj)
 7230: NS_IMPL_CYCLE_COLLECTION_TRACE_END
 7230: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsJSScriptTimeoutHandler)
    1:   NS_INTERFACE_MAP_ENTRY(nsIScriptTimeoutHandler)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
    1: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsJSScriptTimeoutHandler)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsJSScriptTimeoutHandler)
    1: 
    1: nsJSScriptTimeoutHandler::nsJSScriptTimeoutHandler() :
    1:   mLineNo(0),
    1:   mVersion(nsnull),
    1:   mExpr(nsnull),
    1:   mFunObj(nsnull)
    1: {
    1: }
    1: 
    1: nsJSScriptTimeoutHandler::~nsJSScriptTimeoutHandler()
    1: {
    1:   ReleaseJSObjects();
    1: }
    1: 
    1: void
    1: nsJSScriptTimeoutHandler::ReleaseJSObjects()
    1: {
    1:   if (mExpr || mFunObj) {
    1:     if (mExpr) {
 7230:       NS_DROP_JS_OBJECTS(this, nsJSScriptTimeoutHandler);
    1:       mExpr = nsnull;
    1:     } else if (mFunObj) {
 7230:       NS_DROP_JS_OBJECTS(this, nsJSScriptTimeoutHandler);
    1:       mFunObj = nsnull;
    1:     } else {
    1:       NS_WARNING("No func and no expr - roots may not have been removed");
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
10986: nsJSScriptTimeoutHandler::Init(nsGlobalWindow *aWindow, PRBool *aIsInterval,
    1:                                PRInt32 *aInterval)
    1: {
10986:   mContext = aWindow->GetContextInternal();
10986:   if (!mContext) {
    1:     // This window was already closed, or never properly initialized,
    1:     // don't let a timer be scheduled on such a window.
    1: 
    1:     return NS_ERROR_NOT_INITIALIZED;
    1:   }
    1: 
10286:   nsAXPCNativeCallContext *ncc = nsnull;
    1:   nsresult rv = nsContentUtils::XPConnect()->
10286:     GetCurrentNativeCallContext(&ncc);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!ncc)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:   JSContext *cx = nsnull;
    1: 
    1:   rv = ncc->GetJSContext(&cx);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint32 argc;
    1:   jsval *argv = nsnull;
    1: 
    1:   ncc->GetArgc(&argc);
    1:   ncc->GetArgvPtr(&argv);
    1: 
    1:   JSString *expr = nsnull;
    1:   JSObject *funobj = nsnull;
    1:   int32 interval = 0;
    1: 
    1:   JSAutoRequest ar(cx);
    1: 
    1:   if (argc < 1) {
39061:     ::JS_ReportError(cx, "Function %s requires at least 2 parameter",
 3106:                      *aIsInterval ? kSetIntervalStr : kSetTimeoutStr);
 2458:     return NS_ERROR_DOM_TYPE_ERR;
    1:   }
    1: 
    1:   if (argc > 1 && !::JS_ValueToECMAInt32(cx, argv[1], &interval)) {
    1:     ::JS_ReportError(cx,
    1:                      "Second argument to %s must be a millisecond interval",
    1:                      aIsInterval ? kSetIntervalStr : kSetTimeoutStr);
 2458:     return NS_ERROR_DOM_TYPE_ERR;
    1:   }
    1: 
 3106:   if (argc == 1) {
 3106:     // If no interval was specified, treat this like a timeout, to avoid
 3106:     // setting an interval of 0 milliseconds.
 3106:     *aIsInterval = PR_FALSE;
 3106:   }
 3106: 
    1:   switch (::JS_TypeOfValue(cx, argv[0])) {
    1:   case JSTYPE_FUNCTION:
    1:     funobj = JSVAL_TO_OBJECT(argv[0]);
    1:     break;
    1: 
    1:   case JSTYPE_STRING:
    1:   case JSTYPE_OBJECT:
    1:     expr = ::JS_ValueToString(cx, argv[0]);
    1:     if (!expr)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     argv[0] = STRING_TO_JSVAL(expr);
    1:     break;
    1: 
    1:   default:
    1:     ::JS_ReportError(cx, "useless %s call (missing quotes around argument?)",
 3106:                      *aIsInterval ? kSetIntervalStr : kSetTimeoutStr);
    1: 
    1:     // Return an error that nsGlobalWindow can recognize and turn into NS_OK.
    1:     return NS_ERROR_DOM_TYPE_ERR;
    1:   }
    1: 
    1:   if (expr) {
39061:     // if CSP is enabled, and setTimeout/setInterval was called with a string
39061:     // or object, disable the registration and log an error
39061:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(aWindow->GetExtantDocument());
39061: 
39061:     if (doc) {
39061:       nsCOMPtr<nsIContentSecurityPolicy> csp;
39061:       nsresult rv = doc->NodePrincipal()->GetCsp(getter_AddRefs(csp));
39061:       NS_ENSURE_SUCCESS(rv, rv);
39061: 
39061:       if (csp) {
39061:         PRBool allowsEval;
39061:         // this call will send violation reports as warranted (and return true if
39061:         // reportOnly is set).
39061:         rv = csp->GetAllowsEval(&allowsEval);
39061:         NS_ENSURE_SUCCESS(rv, rv);
39061: 
39061:         if (!allowsEval) {
39061:           ::JS_ReportError(cx, "call to %s blocked by CSP",
39061:                             *aIsInterval ? kSetIntervalStr : kSetTimeoutStr);
39061: 
39061:           // Note: Our only caller knows to turn NS_ERROR_DOM_TYPE_ERR into NS_OK.
39061:           return NS_ERROR_DOM_TYPE_ERR;
39061:         }
39061:       }
39061:     } // if there's no document, we don't have to do anything.
39061: 
 7230:     rv = NS_HOLD_JS_OBJECTS(this, nsJSScriptTimeoutHandler);
 7230:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     mExpr = expr;
 5898: 
10986:     nsIPrincipal *prin = aWindow->GetPrincipal();
10986: 
 5898:     // Get the calling location.
 5898:     const char *filename;
12690:     if (nsJSUtils::GetCallingLocation(cx, &filename, &mLineNo, prin)) {
 5898:       mFileName.Assign(filename);
 5898:     }
    1:   } else if (funobj) {
 7230:     rv = NS_HOLD_JS_OBJECTS(this, nsJSScriptTimeoutHandler);
 7230:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     mFunObj = funobj;
    1: 
    1:     // Create our arg array - leave an extra slot for a secret final argument
    1:     // that indicates to the called function how "late" the timeout is.  We
    1:     // will fill that in when SetLateness is called.
    1:     nsCOMPtr<nsIArray> array;
    1:     rv = NS_CreateJSArgv(cx, (argc > 1) ? argc - 1 : argc, nsnull,
    1:                          getter_AddRefs(array));
    1:     if (NS_FAILED(rv)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
 5898: 
    1:     PRUint32 dummy;
    1:     jsval *jsargv = nsnull;
    1:     nsCOMPtr<nsIJSArgArray> jsarray(do_QueryInterface(array));
 3233:     jsarray->GetArgs(&dummy, reinterpret_cast<void **>(&jsargv));
 5898: 
    1:     // must have worked - we own the impl! :)
    1:     NS_ASSERTION(jsargv, "No argv!");
    1:     for (PRInt32 i = 2; (PRUint32)i < argc; ++i) {
    1:       jsargv[i - 2] = argv[i];
    1:     }
    1:     // final arg slot remains null, array has rooted vals.
    1:     mArgv = array;
    1:   } else {
    1:     NS_WARNING("No func and no expr - why are we here?");
    1:   }
    1:   *aInterval = interval;
    1:   return NS_OK;
    1: }
    1: 
    1: void nsJSScriptTimeoutHandler::SetLateness(PRIntervalTime aHowLate)
    1: {
    1:   nsCOMPtr<nsIJSArgArray> jsarray(do_QueryInterface(mArgv));
    1:   if (jsarray) {
    1:     PRUint32 argc;
    1:     jsval *jsargv;
41664:     nsresult rv = jsarray->GetArgs(&argc, reinterpret_cast<void **>(&jsargv));
41664:     if (NS_SUCCEEDED(rv) && jsargv && argc)
    1:       jsargv[argc-1] = INT_TO_JSVAL((jsint) aHowLate);
    1:   } else {
    1:     NS_ERROR("How can our argv not handle this?");
    1:   }
    1: }
    1: 
    1: const PRUnichar *
    1: nsJSScriptTimeoutHandler::GetHandlerText()
    1: {
    1:   NS_ASSERTION(mExpr, "No expression, so no handler text!");
 3233:   return reinterpret_cast<const PRUnichar *>
 3233:                          (::JS_GetStringChars(mExpr));
    1: }
    1: 
10986: nsresult NS_CreateJSTimeoutHandler(nsGlobalWindow *aWindow,
 3106:                                    PRBool *aIsInterval,
    1:                                    PRInt32 *aInterval,
    1:                                    nsIScriptTimeoutHandler **aRet)
    1: {
    1:   *aRet = nsnull;
    1:   nsJSScriptTimeoutHandler *handler = new nsJSScriptTimeoutHandler();
    1:   if (!handler)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
10986:   nsresult rv = handler->Init(aWindow, aIsInterval, aInterval);
    1:   if (NS_FAILED(rv)) {
    1:     delete handler;
    1:     return rv;
    1:   }
 4427: 
 4427:   NS_ADDREF(*aRet = handler);
 4427: 
 4427:   return NS_OK;
    1: }
