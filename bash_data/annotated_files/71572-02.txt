32195: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
32195: /* ***** BEGIN LICENSE BLOCK *****
32195:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
32195:  *
32195:  * The contents of this file are subject to the Mozilla Public License Version
32195:  * 1.1 (the "License"); you may not use this file except in compliance with
32195:  * the License. You may obtain a copy of the License at
32195:  * http://www.mozilla.org/MPL/
32195:  *
32195:  * Software distributed under the License is distributed on an "AS IS" basis,
32195:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
32195:  * for the specific language governing rights and limitations under the
32195:  * License.
32195:  *
32195:  * The Original Code is mozilla.org code.
32195:  *
32195:  * The Initial Developer of the Original Code is
32195:  *   Mozilla Corporation.
32195:  * Portions created by the Initial Developer are Copyright (C) 2007
32195:  * the Initial Developer. All Rights Reserved.
32195:  *
32195:  * Contributor(s):
32195:  *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
32836:  *   Mark Steele <mwsteele@gmail.com>
32195:  *
32195:  * Alternatively, the contents of this file may be used under the terms of
32195:  * either the GNU General Public License Version 2 or later (the "GPL"), or
32195:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
32195:  * in which case the provisions of the GPL or the LGPL are applicable instead
32195:  * of those above. If you wish to allow use of your version of this file only
32195:  * under the terms of either the GPL or the LGPL, and not to allow others to
32195:  * use your version of this file under the terms of the MPL, indicate your
32195:  * decision by deleting the provisions above and replace them with the notice
32195:  * and other provisions required by the GPL or the LGPL. If you do not delete
32195:  * the provisions above, a recipient may use your version of this file under
32195:  * the terms of any one of the MPL, the GPL or the LGPL.
32195:  *
32195:  * ***** END LICENSE BLOCK ***** */
32195: 
32195: #ifndef WEBGLCONTEXT_H_
32195: #define WEBGLCONTEXT_H_
32195: 
32195: #include <stdarg.h>
43474: #include <vector>
32195: 
32195: #include "nsTArray.h"
32195: #include "nsDataHashtable.h"
32195: #include "nsRefPtrHashtable.h"
32195: #include "nsHashKeys.h"
32195: 
32195: #include "nsIDocShell.h"
32195: 
57635: #include "nsIDOMWebGLRenderingContext.h"
32195: #include "nsICanvasRenderingContextInternal.h"
42402: #include "nsHTMLCanvasElement.h"
32195: #include "nsWeakReference.h"
32195: #include "nsIDOMHTMLElement.h"
32835: #include "nsIJSNativeInitializer.h"
32195: 
47910: #include "GLContextProvider.h"
42402: #include "Layers.h"
32195: 
47204: #include "CheckedInt.h"
47204: 
32195: class nsIDocShell;
57631: class nsIPropertyBag;
32195: 
32195: namespace mozilla {
32195: 
32195: class WebGLTexture;
32195: class WebGLBuffer;
32195: class WebGLProgram;
32195: class WebGLShader;
32195: class WebGLFramebuffer;
32195: class WebGLRenderbuffer;
43010: class WebGLUniformLocation;
32195: 
32195: class WebGLZeroingObject;
43474: class WebGLContextBoundObject;
32195: 
51422: enum FakeBlackStatus { DoNotNeedFakeBlack, DoNeedFakeBlack, DontKnowIfNeedFakeBlack };
51422: 
63064: struct VertexAttrib0Status {
63064:     enum { Default, EmulatedUninitializedArray, EmulatedInitializedArray };
63064: };
63064: 
70168: struct BackbufferClearingStatus {
70168:     enum { NotClearedSinceLastPresented, ClearedToDefaultValues, HasBeenDrawnTo };
70168: };
70168: 
55904: struct WebGLTexelFormat {
70163:     enum { Generic, Auto, RGBA8, RGB8, RGBX8, BGRA8, BGR8, BGRX8, RGBA5551, RGBA4444, RGB565, R8, RA8, A8,
70163:            RGBA32F, RGB32F, A32F, R32F, RA32F };
55904: };
55904: 
55904: struct WebGLTexelPremultiplicationOp {
55904:     enum { Generic, None, Premultiply, Unmultiply };
55904: };
55904: 
55904: int GetWebGLTexelFormat(GLenum format, GLenum type);
55904: 
51422: inline PRBool is_pot_assuming_nonnegative(WebGLsizei x)
51422: {
51422:     return (x & (x-1)) == 0;
51422: }
51422: 
32195: class WebGLObjectBaseRefPtr
32195: {
32195: protected:
32195:     friend class WebGLZeroingObject;
32195: 
32195:     WebGLObjectBaseRefPtr()
32195:         : mRawPtr(0)
32195:     {
32195:     }
32195: 
32195:     WebGLObjectBaseRefPtr(nsISupports *rawPtr)
32195:         : mRawPtr(rawPtr)
32195:     {
32195:     }
32195: 
32195:     void Zero() {
32195:         if (mRawPtr) {
32195:             // Note: RemoveRefOwner isn't called here, because
32195:             // the entire owner array will be cleared.
32195:             mRawPtr->Release();
32195:             mRawPtr = 0;
32195:         }
32195:     }
32195: 
32195: protected:
32195:     nsISupports *mRawPtr;
32195: };
32195: 
32195: template <class T>
32195: class WebGLObjectRefPtr
32195:     : public WebGLObjectBaseRefPtr
32195: {
32195: public:
32195:     typedef T element_type;
32195: 
32195:     WebGLObjectRefPtr()
32195:     { }
32195: 
32195:     WebGLObjectRefPtr(const WebGLObjectRefPtr<T>& aSmartPtr)
32195:         : WebGLObjectBaseRefPtr(aSmartPtr.mRawPtr)
32195:     {
32195:         if (mRawPtr) {
32195:             RawPtr()->AddRef();
32195:             RawPtr()->AddRefOwner(this);
32195:         }
32195:     }
32195: 
32195:     WebGLObjectRefPtr(T *aRawPtr)
32195:         : WebGLObjectBaseRefPtr(aRawPtr)
32195:     {
32195:         if (mRawPtr) {
32195:             RawPtr()->AddRef();
32195:             RawPtr()->AddRefOwner(this);
32195:         }
32195:     }
32195: 
32195:     WebGLObjectRefPtr(const already_AddRefed<T>& aSmartPtr)
32195:         : WebGLObjectBaseRefPtr(aSmartPtr.mRawPtr)
32195:           // construct from |dont_AddRef(expr)|
32195:     {
32195:         if (mRawPtr) {
32195:             RawPtr()->AddRef();
32195:             RawPtr()->AddRefOwner(this);
32195:         }
32195:     }
32195: 
32195:     ~WebGLObjectRefPtr() {
32195:         if (mRawPtr) {
32195:             RawPtr()->RemoveRefOwner(this);
32195:             RawPtr()->Release();
32195:         }
32195:     }
32195: 
32195:     WebGLObjectRefPtr<T>&
32195:     operator=(const WebGLObjectRefPtr<T>& rhs)
32195:     {
32195:         assign_with_AddRef(static_cast<T*>(rhs.mRawPtr));
32195:         return *this;
32195:     }
32195: 
32195:     WebGLObjectRefPtr<T>&
32195:     operator=(T* rhs)
32195:     {
32195:         assign_with_AddRef(rhs);
32195:         return *this;
32195:     }
32195: 
32195:     WebGLObjectRefPtr<T>&
32195:     operator=(const already_AddRefed<T>& rhs)
32195:     {
32195:         assign_assuming_AddRef(static_cast<T*>(rhs.mRawPtr));
32195:         return *this;
32195:     }
32195: 
32195:     T* get() const {
32195:         return const_cast<T*>(static_cast<T*>(mRawPtr));
32195:     }
32195: 
32195:     operator T*() const {
32195:         return get();
32195:     }
32195: 
32195:     T* operator->() const {
32195:         NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL WebGLObjectRefPtr with operator->()!");
32195:         return get();
32195:     }
32195: 
32195:     T& operator*() const {
32195:         NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL WebGLObjectRefPtr with operator*()!");
32195:         return *get();
32195:     }
32195: 
32195: private:
32195:     T* RawPtr() { return static_cast<T*>(mRawPtr); }
32195: 
32195:     void assign_with_AddRef(T* rawPtr) {
32195:         if (rawPtr) {
32195:             rawPtr->AddRef();
32195:             rawPtr->AddRefOwner(this);
32195:         }
32195: 
32195:         assign_assuming_AddRef(rawPtr);
32195:     }
32195: 
32195:     void assign_assuming_AddRef(T* newPtr) {
32195:         T* oldPtr = RawPtr();
32195:         mRawPtr = newPtr;
32195:         if (oldPtr) {
32195:             oldPtr->RemoveRefOwner(this);
32195:             oldPtr->Release();
32195:         }
32195:     }
32195: };
32195: 
32195: class WebGLBuffer;
32195: 
32195: struct WebGLVertexAttribData {
57634:     // note that these initial values are what GL initializes vertex attribs to
32195:     WebGLVertexAttribData()
57634:         : buf(0), stride(0), size(4), byteOffset(0),
57634:           type(LOCAL_GL_FLOAT), enabled(PR_FALSE), normalized(PR_FALSE)
32195:     { }
32195: 
32195:     WebGLObjectRefPtr<WebGLBuffer> buf;
42916:     WebGLuint stride;
42916:     WebGLuint size;
43009:     GLuint byteOffset;
43009:     GLenum type;
32195:     PRBool enabled;
51898:     PRBool normalized;
43009: 
43333:     GLuint componentSize() const {
43009:         switch(type) {
43009:             case LOCAL_GL_BYTE:
43333:                 return sizeof(GLbyte);
43009:                 break;
43009:             case LOCAL_GL_UNSIGNED_BYTE:
43333:                 return sizeof(GLubyte);
43009:                 break;
43009:             case LOCAL_GL_SHORT:
43333:                 return sizeof(GLshort);
43009:                 break;
43009:             case LOCAL_GL_UNSIGNED_SHORT:
43333:                 return sizeof(GLushort);
43009:                 break;
43009:             // XXX case LOCAL_GL_FIXED:
43009:             case LOCAL_GL_FLOAT:
43333:                 return sizeof(GLfloat);
43009:                 break;
43333:             default:
43333:                 NS_ERROR("Should never get here!");
43333:                 return 0;
43009:         }
43333:     }
43333: 
43333:     GLuint actualStride() const {
43333:         if (stride) return stride;
43333:         return size * componentSize();
43009:     }
32195: };
32195: 
57631: struct WebGLContextOptions {
57631:     // these are defaults
57631:     WebGLContextOptions()
57631:         : alpha(true), depth(true), stencil(false),
70165:           premultipliedAlpha(true), antialias(false),
70165:           preserveDrawingBuffer(false)
57631:     { }
57631: 
57631:     bool operator==(const WebGLContextOptions& other) const {
57631:         return
57631:             alpha == other.alpha &&
57631:             depth == other.depth &&
57631:             stencil == other.stencil &&
57631:             premultipliedAlpha == other.premultipliedAlpha &&
70165:             antialias == other.antialias &&
70165:             preserveDrawingBuffer == other.preserveDrawingBuffer;
57631:     }
57631: 
57631:     bool operator!=(const WebGLContextOptions& other) const {
70165:         return !operator==(other);
57631:     }
57631: 
57631:     bool alpha;
57631:     bool depth;
57631:     bool stencil;
57631:     bool premultipliedAlpha;
70165:     bool antialias;
70165:     bool preserveDrawingBuffer;
57631: };
57631: 
32195: class WebGLContext :
57635:     public nsIDOMWebGLRenderingContext,
32195:     public nsICanvasRenderingContextInternal,
32195:     public nsSupportsWeakReference
32195: {
32195: public:
32195:     WebGLContext();
32195:     virtual ~WebGLContext();
32195: 
43655:     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
43655: 
57635:     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(WebGLContext, nsIDOMWebGLRenderingContext)
43655: 
57635:     NS_DECL_NSIDOMWEBGLRENDERINGCONTEXT
32195: 
32195:     // nsICanvasRenderingContextInternal
42402:     NS_IMETHOD SetCanvasElement(nsHTMLCanvasElement* aParentCanvas);
32195:     NS_IMETHOD SetDimensions(PRInt32 width, PRInt32 height);
32195:     NS_IMETHOD InitializeWithSurface(nsIDocShell *docShell, gfxASurface *surface, PRInt32 width, PRInt32 height)
32195:         { return NS_ERROR_NOT_IMPLEMENTED; }
50903:     NS_IMETHOD Reset()
50903:         { /* (InitializeWithSurface) */ return NS_ERROR_NOT_IMPLEMENTED; }
32195:     NS_IMETHOD Render(gfxContext *ctx, gfxPattern::GraphicsFilter f);
32195:     NS_IMETHOD GetInputStream(const char* aMimeType,
32195:                               const PRUnichar* aEncoderOptions,
32195:                               nsIInputStream **aStream);
32195:     NS_IMETHOD GetThebesSurface(gfxASurface **surface);
32195:     NS_IMETHOD SetIsOpaque(PRBool b) { return NS_OK; };
57631:     NS_IMETHOD SetContextOptions(nsIPropertyBag *aOptions);
57631: 
46902:     NS_IMETHOD SetIsIPC(PRBool b) { return NS_ERROR_NOT_IMPLEMENTED; }
46517:     NS_IMETHOD Redraw(const gfxRect&) { return NS_ERROR_NOT_IMPLEMENTED; }
46756:     NS_IMETHOD Swap(mozilla::ipc::Shmem& aBack,
46756:                     PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h)
46756:                     { return NS_ERROR_NOT_IMPLEMENTED; }
46890:     NS_IMETHOD Swap(PRUint32 nativeID,
46890:                     PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h)
46890:                     { return NS_ERROR_NOT_IMPLEMENTED; }
32195: 
42916:     nsresult SynthesizeGLError(WebGLenum err);
42916:     nsresult SynthesizeGLError(WebGLenum err, const char *fmt, ...);
42477: 
43098:     nsresult ErrorInvalidEnum(const char *fmt = 0, ...);
43098:     nsresult ErrorInvalidOperation(const char *fmt = 0, ...);
43098:     nsresult ErrorInvalidValue(const char *fmt = 0, ...);
47813:     nsresult ErrorInvalidEnumInfo(const char *info, PRUint32 enumvalue) {
47813:         return ErrorInvalidEnum("%s: invalid enum value 0x%x", info, enumvalue);
46443:     }
63070:     nsresult ErrorOutOfMemory(const char *fmt = 0, ...);
42477: 
51418:     WebGLTexture *activeBoundTextureForTarget(WebGLenum target) {
51418:         return target == LOCAL_GL_TEXTURE_2D ? mBound2DTextures[mActiveTexture]
51418:                                              : mBoundCubeMapTextures[mActiveTexture];
51418:     }
51418: 
64542:     already_AddRefed<CanvasLayer> GetCanvasLayer(nsDisplayListBuilder* aBuilder,
64542:                                                  CanvasLayer *aOldLayer,
47731:                                                  LayerManager *aManager);
64542:     void MarkContextClean() { mInvalidated = PR_FALSE; }
42402: 
43099:     // a number that increments every time we have an event that causes
43099:     // all context resources to be lost.
47204:     PRUint32 Generation() { return mGeneration.value(); }
51422: 
70167:     // this is similar to GLContext::ClearSafely, but is more comprehensive
70167:     // (takes care of scissor, stencil write mask, dithering, viewport...)
70167:     // WebGL has more complex needs than GLContext as content controls GL state.
70167:     void ForceClearFramebufferWithDefaultValues(PRUint32 mask, const nsIntRect& viewportRect);
70167: 
70168:     // if the preserveDrawingBuffer context option is false, we need to clear the back buffer
70168:     // after it's been presented to the compositor. This function does that if needed.
70168:     // See section 2.2 in the WebGL spec.
70168:     void EnsureBackbufferClearedAsNeeded();
70168: 
63064: protected:
51422:     void SetDontKnowIfNeedFakeBlack() {
51422:         mFakeBlackStatus = DontKnowIfNeedFakeBlack;
51422:     }
51422: 
51422:     PRBool NeedFakeBlack();
51422:     void BindFakeBlackTextures();
51422:     void UnbindFakeBlackTextures();
51422: 
63064:     int WhatDoesVertexAttrib0Need();
51898:     void DoFakeVertexAttrib0(WebGLuint vertexCount);
51898:     void UndoFakeVertexAttrib0();
63064:     void InvalidateFakeVertexAttrib0();
51898: 
43655:     nsCOMPtr<nsIDOMHTMLCanvasElement> mCanvasElement;
43655:     nsHTMLCanvasElement *HTMLCanvasElement() {
43655:         return static_cast<nsHTMLCanvasElement*>(mCanvasElement.get());
43655:     }
32195: 
42402:     nsRefPtr<gl::GLContext> gl;
32195: 
32195:     PRInt32 mWidth, mHeight;
47204:     CheckedUint32 mGeneration;
32195: 
57631:     WebGLContextOptions mOptions;
57631: 
47731:     PRPackedBool mInvalidated;
47731:     PRPackedBool mResetLayer;
53695:     PRPackedBool mVerbose;
57631:     PRPackedBool mOptionsFrozen;
32195: 
42916:     WebGLuint mActiveTexture;
42916:     WebGLenum mSynthesizedGLError;
42477: 
47653:     // whether shader validation is supported
47653:     PRBool mShaderValidation;
47653: 
47653:     // some GL constants
51418:     PRInt32 mGLMaxVertexAttribs;
51418:     PRInt32 mGLMaxTextureUnits;
51418:     PRInt32 mGLMaxTextureSize;
51418:     PRInt32 mGLMaxCubeMapTextureSize;
51418:     PRInt32 mGLMaxTextureImageUnits;
51418:     PRInt32 mGLMaxVertexTextureImageUnits;
51418:     PRInt32 mGLMaxVaryingVectors;
51418:     PRInt32 mGLMaxFragmentUniformVectors;
51418:     PRInt32 mGLMaxVertexUniformVectors;
47653: 
70163:     // extensions
70163:     enum WebGLExtensionID {
70163:         WebGL_OES_texture_float,
70163:         WebGLExtensionID_Max
70163:     };
70164:     nsCOMPtr<nsIWebGLExtension> mEnabledExtensions[WebGLExtensionID_Max];
70164:     PRBool IsExtensionEnabled(WebGLExtensionID ext) const {
70164:         NS_ABORT_IF_FALSE(ext >= 0 && ext < WebGLExtensionID_Max, "bogus index!");
70163:         return mEnabledExtensions[ext] != nsnull;
70163:     }
70163: 
43595:     PRBool InitAndValidateGL();
61295:     PRBool ValidateBuffers(PRInt32* maxAllowedCount, const char *info);
46443:     PRBool ValidateCapabilityEnum(WebGLenum cap, const char *info);
58667:     PRBool ValidateBlendEquationEnum(WebGLenum cap, const char *info);
58667:     PRBool ValidateBlendFuncDstEnum(WebGLenum mode, const char *info);
58667:     PRBool ValidateBlendFuncSrcEnum(WebGLenum mode, const char *info);
58667:     PRBool ValidateBlendFuncEnumsCompatibility(WebGLenum sfactor, WebGLenum dfactor, const char *info);
46443:     PRBool ValidateTextureTargetEnum(WebGLenum target, const char *info);
46443:     PRBool ValidateComparisonEnum(WebGLenum target, const char *info);
46443:     PRBool ValidateStencilOpEnum(WebGLenum action, const char *info);
47813:     PRBool ValidateFaceEnum(WebGLenum face, const char *info);
47206:     PRBool ValidateBufferUsageEnum(WebGLenum target, const char *info);
70163:     PRBool ValidateTexFormatAndType(WebGLenum format, WebGLenum type, int jsArrayType,
46443:                                       PRUint32 *texelSize, const char *info);
47813:     PRBool ValidateDrawModeEnum(WebGLenum mode, const char *info);
63071:     PRBool ValidateAttribIndex(WebGLuint index, const char *info);
70170:     PRBool ValidateStencilParamsForDrawCall();
32195: 
32195:     void Invalidate();
47910:     void DestroyResourcesAndContext();
32195: 
42402:     void MakeContextCurrent() { gl->MakeCurrent(); }
32195: 
37417:     // helpers
42916:     nsresult TexImage2D_base(WebGLenum target, WebGLint level, WebGLenum internalformat,
55904:                              WebGLsizei width, WebGLsizei height, WebGLsizei srcStrideOrZero, WebGLint border,
42916:                              WebGLenum format, WebGLenum type,
55904:                              void *data, PRUint32 byteLength,
70163:                              int jsArrayType,
55904:                              int srcFormat, PRBool srcPremultiplied);
42916:     nsresult TexSubImage2D_base(WebGLenum target, WebGLint level,
42916:                                 WebGLint xoffset, WebGLint yoffset,
55904:                                 WebGLsizei width, WebGLsizei height, WebGLsizei srcStrideOrZero,
42916:                                 WebGLenum format, WebGLenum type,
55904:                                 void *pixels, PRUint32 byteLength,
70163:                                 int jsArrayType,
55904:                                 int srcFormat, PRBool srcPremultiplied);
43853:     nsresult ReadPixels_base(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height,
43853:                              WebGLenum format, WebGLenum type, void *data, PRUint32 byteLength);
51420:     nsresult TexParameter_base(WebGLenum target, WebGLenum pname,
51420:                                WebGLint *intParamPtr, WebGLfloat *floatParamPtr);
37417: 
55906:     void ConvertImage(size_t width, size_t height, size_t srcStride, size_t dstStride,
55904:                       const PRUint8*src, PRUint8 *dst,
55904:                       int srcFormat, PRBool srcPremultiplied,
55904:                       int dstFormat, PRBool dstPremultiplied,
55904:                       size_t dstTexelSize);
55904: 
37417:     nsresult DOMElementToImageSurface(nsIDOMElement *imageOrCanvas,
34454:                                       gfxImageSurface **imageOut,
55904:                                       int *format);
32195: 
60093:     nsresult CopyTexSubImage2D_base(WebGLenum target,
60093:                                     WebGLint level,
60093:                                     WebGLenum internalformat,
60093:                                     WebGLint xoffset,
60093:                                     WebGLint yoffset,
60093:                                     WebGLint x,
60093:                                     WebGLint y,
60093:                                     WebGLsizei width,
60093:                                     WebGLsizei height,
60093:                                     bool sub
60093:                                   );
60093: 
43099:     // Conversion from public nsI* interfaces to concrete objects
43099:     template<class ConcreteObjectType, class BaseInterfaceType>
47811:     PRBool GetConcreteObject(const char *info,
47811:                              BaseInterfaceType *aInterface,
43099:                              ConcreteObjectType **aConcreteObject,
43099:                              PRBool *isNull = 0,
47811:                              PRBool *isDeleted = 0,
47811:                              PRBool generateErrors = PR_TRUE);
43099: 
43099:     template<class ConcreteObjectType, class BaseInterfaceType>
47811:     PRBool GetConcreteObjectAndGLName(const char *info,
47811:                                       BaseInterfaceType *aInterface,
43099:                                       ConcreteObjectType **aConcreteObject,
43099:                                       WebGLuint *aGLObjectName,
43099:                                       PRBool *isNull = 0,
43099:                                       PRBool *isDeleted = 0);
43099: 
43099:     template<class ConcreteObjectType, class BaseInterfaceType>
47811:     PRBool GetGLName(const char *info,
47811:                      BaseInterfaceType *aInterface,
43099:                      WebGLuint *aGLObjectName,
43099:                      PRBool *isNull = 0,
43099:                      PRBool *isDeleted = 0);
43099: 
43099:     template<class ConcreteObjectType, class BaseInterfaceType>
47811:     PRBool CanGetConcreteObject(const char *info,
47811:                                 BaseInterfaceType *aInterface,
43099:                                 PRBool *isNull = 0,
43099:                                 PRBool *isDeleted = 0);
43099: 
63067:     PRInt32 MaxTextureSizeForTarget(WebGLenum target) const {
63067:         return target == LOCAL_GL_TEXTURE_2D ? mGLMaxTextureSize : mGLMaxCubeMapTextureSize;
63067:     }
32195: 
32195:     // the buffers bound to the current program's attribs
32195:     nsTArray<WebGLVertexAttribData> mAttribBuffers;
32195: 
32195:     // the textures bound to any sampler uniforms
32195:     nsTArray<WebGLObjectRefPtr<WebGLTexture> > mUniformTextures;
32195: 
32195:     // textures bound to 
32195:     nsTArray<WebGLObjectRefPtr<WebGLTexture> > mBound2DTextures;
32195:     nsTArray<WebGLObjectRefPtr<WebGLTexture> > mBoundCubeMapTextures;
32195: 
32195:     WebGLObjectRefPtr<WebGLBuffer> mBoundArrayBuffer;
32195:     WebGLObjectRefPtr<WebGLBuffer> mBoundElementArrayBuffer;
60037:     // note nsRefPtr -- this stays alive even after being deleted,
60037:     // and is only explicitly removed from the current state via
60037:     // a call to UseProgram.
60037:     nsRefPtr<WebGLProgram> mCurrentProgram;
32195: 
56959:     PRUint32 mMaxFramebufferColorAttachments;
32195: 
35494:     nsRefPtr<WebGLFramebuffer> mBoundFramebuffer;
32195:     nsRefPtr<WebGLRenderbuffer> mBoundRenderbuffer;
32195: 
32195:     // lookup tables for GL name -> object wrapper
32195:     nsRefPtrHashtable<nsUint32HashKey, WebGLTexture> mMapTextures;
32195:     nsRefPtrHashtable<nsUint32HashKey, WebGLBuffer> mMapBuffers;
32195:     nsRefPtrHashtable<nsUint32HashKey, WebGLProgram> mMapPrograms;
32195:     nsRefPtrHashtable<nsUint32HashKey, WebGLShader> mMapShaders;
32195:     nsRefPtrHashtable<nsUint32HashKey, WebGLFramebuffer> mMapFramebuffers;
32195:     nsRefPtrHashtable<nsUint32HashKey, WebGLRenderbuffer> mMapRenderbuffers;
32195: 
55904:     // PixelStore parameters
58672:     PRUint32 mPixelStorePackAlignment, mPixelStoreUnpackAlignment, mPixelStoreColorspaceConversion;
43639:     PRBool mPixelStoreFlipY, mPixelStorePremultiplyAlpha;
43639: 
51422:     FakeBlackStatus mFakeBlackStatus;
51422: 
51422:     WebGLuint mBlackTexture2D, mBlackTextureCubeMap;
51422:     PRBool mBlackTexturesAreInitialized;
51422: 
51898:     WebGLfloat mVertexAttrib0Vector[4];
63064:     WebGLfloat mFakeVertexAttrib0BufferObjectVector[4];
63064:     size_t mFakeVertexAttrib0BufferObjectSize;
63064:     GLuint mFakeVertexAttrib0BufferObject;
63064:     int mFakeVertexAttrib0BufferStatus;
51898: 
70170:     WebGLint mStencilRefFront, mStencilRefBack;
70170:     WebGLuint mStencilValueMaskFront, mStencilValueMaskBack,
70170:               mStencilWriteMaskFront, mStencilWriteMaskBack;
70166:     realGLboolean mColorWriteMask[4];
70166:     realGLboolean mDepthWriteMask;
70166:     realGLboolean mScissorTestEnabled;
70166:     realGLboolean mDitherEnabled;
70166:     WebGLfloat mColorClearValue[4];
70166:     WebGLint mStencilClearValue;
70166:     WebGLfloat mDepthClearValue;
58671: 
70168:     int mBackbufferClearingStatus;
70168: 
42472: public:
32195:     // console logging helpers
42472:     static void LogMessage(const char *fmt, ...);
42477:     static void LogMessage(const char *fmt, va_list ap);
53695:     void LogMessageIfVerbose(const char *fmt, ...);
55908:     void LogMessageIfVerbose(const char *fmt, va_list ap);
51422: 
51422:     friend class WebGLTexture;
56959:     friend class WebGLFramebuffer;
32195: };
32195: 
32195: // this class is a mixin for the named type wrappers, and is used
32195: // by WebGLObjectRefPtr to tell the object who holds references, so that
32195: // we can zero them out appropriately when the object is deleted, because
32195: // it will be unbound in the GL.
32195: class WebGLZeroingObject
32195: {
32195: public:
32195:     WebGLZeroingObject()
32195:     { }
32195: 
32195:     void AddRefOwner(WebGLObjectBaseRefPtr *owner) {
32195:         mRefOwners.AppendElement(owner);
32195:     }
32195: 
32195:     void RemoveRefOwner(WebGLObjectBaseRefPtr *owner) {
32195:         mRefOwners.RemoveElement(owner);
32195:     }
32195: 
32195:     void ZeroOwners() {
32195:         WebGLObjectBaseRefPtr **owners = mRefOwners.Elements();
32195:         
32195:         for (PRUint32 i = 0; i < mRefOwners.Length(); i++) {
32195:             owners[i]->Zero();
32195:         }
32195: 
32195:         mRefOwners.Clear();
32195:     }
32195: 
32195: protected:
32195:     nsTArray<WebGLObjectBaseRefPtr *> mRefOwners;
32195: };
32195: 
43099: // this class is a mixin for GL objects that have dimensions
43099: // that we need to track.
42473: class WebGLRectangleObject
42473: {
42473: protected:
42473:     WebGLRectangleObject()
42473:         : mWidth(0), mHeight(0) { }
42473: 
42473: public:
42916:     WebGLsizei width() { return mWidth; }
42916:     void width(WebGLsizei value) { mWidth = value; }
42473: 
42916:     WebGLsizei height() { return mHeight; }
42916:     void height(WebGLsizei value) { mHeight = value; }
42473: 
42916:     void setDimensions(WebGLsizei width, WebGLsizei height) {
42473:         mWidth = width;
42473:         mHeight = height;
42473:     }
42473: 
42473:     void setDimensions(WebGLRectangleObject *rect) {
42473:         if (rect) {
42473:             mWidth = rect->width();
42473:             mHeight = rect->height();
42473:         } else {
42473:             mWidth = 0;
42473:             mHeight = 0;
42473:         }
42473:     }
42473: 
42473: protected:
42916:     WebGLsizei mWidth;
42916:     WebGLsizei mHeight;
42473: };
42473: 
43099: // This class is a mixin for objects that are tied to a specific
43099: // context (which is to say, all of them).  They provide initialization
43099: // as well as comparison with the current context.
43099: class WebGLContextBoundObject
43099: {
43099: public:
43099:     WebGLContextBoundObject(WebGLContext *context) {
43099:         mContext = context;
43099:         mContextGeneration = context->Generation();
43099:     }
43099: 
43099:     PRBool IsCompatibleWithContext(WebGLContext *other) {
43099:         return mContext == other &&
43099:             mContextGeneration == other->Generation();
43099:     }
43099: 
43099: protected:
43099:     WebGLContext *mContext;
43099:     PRUint32 mContextGeneration;
43099: };
43099: 
42471: #define WEBGLBUFFER_PRIVATE_IID \
42471:     {0xd69f22e9, 0x6f98, 0x48bd, {0xb6, 0x94, 0x34, 0x17, 0xed, 0x06, 0x11, 0xab}}
32195: class WebGLBuffer :
32195:     public nsIWebGLBuffer,
43099:     public WebGLZeroingObject,
43099:     public WebGLContextBoundObject
32195: {
32195: public:
42471:     NS_DECLARE_STATIC_IID_ACCESSOR(WEBGLBUFFER_PRIVATE_IID)
42471: 
43099:     WebGLBuffer(WebGLContext *context, WebGLuint name) :
43099:         WebGLContextBoundObject(context),
62489:         mName(name), mDeleted(PR_FALSE), mHasEverBeenBound(PR_FALSE),
43099:         mByteLength(0), mTarget(LOCAL_GL_NONE), mData(nsnull)
32195:     { }
32195: 
43009:     ~WebGLBuffer() {
43009:         Delete();
43009:     }
43009: 
32195:     void Delete() {
32195:         if (mDeleted)
32195:             return;
32195:         ZeroOwners();
37417: 
43009:         free(mData);
43009:         mData = nsnull;
43009: 
32195:         mDeleted = PR_TRUE;
37417:         mByteLength = 0;
32195:     }
37417: 
43009:     PRBool Deleted() const { return mDeleted; }
62489:     PRBool HasEverBeenBound() { return mHasEverBeenBound; }
62489:     void SetHasEverBeenBound(PRBool x) { mHasEverBeenBound = x; }
43009:     GLuint GLName() const { return mName; }
43009:     GLuint ByteLength() const { return mByteLength; }
43009:     GLenum Target() const { return mTarget; }
43009:     const void *Data() const { return mData; }
32195: 
43009:     void SetByteLength(GLuint byteLength) { mByteLength = byteLength; }
43009:     void SetTarget(GLenum target) { mTarget = target; }
43009: 
43009:     // element array buffers are the only buffers for which we need to keep a copy of the data.
43009:     // this method assumes that the byte length has previously been set by calling SetByteLength.
63070:     PRBool CopyDataIfElementArray(const void* data) {
43009:         if (mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
43009:             mData = realloc(mData, mByteLength);
63070:             if (!mData)
63070:                 return PR_FALSE;
43009:             memcpy(mData, data, mByteLength);
43009:         }
63070:         return PR_TRUE;
43009:     }
43009: 
43009:     // same comments as for CopyElementArrayData
63070:     PRBool ZeroDataIfElementArray() {
43009:         if (mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
43009:             mData = realloc(mData, mByteLength);
63070:             if (!mData)
63070:                 return PR_FALSE;
43009:             memset(mData, 0, mByteLength);
43009:         }
63070:         return PR_TRUE;
43009:     }
43009: 
43009:     // same comments as for CopyElementArrayData
43009:     void CopySubDataIfElementArray(GLuint byteOffset, GLuint byteLength, const void* data) {
43009:         if (mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
43009:             memcpy((void*) (size_t(mData)+byteOffset), data, byteLength);
43009:         }
43009:     }
43009: 
43009:     // this method too is only for element array buffers. It returns the maximum value in the part of
43009:     // the buffer starting at given offset, consisting of given count of elements. The type T is the type
43009:     // to interprete the array elements as, must be GLushort or GLubyte.
43009:     template<typename T>
61295:     PRInt32 FindMaxElementInSubArray(GLuint count, GLuint byteOffset)
43009:     {
43009:         const T* start = reinterpret_cast<T*>(reinterpret_cast<size_t>(mData) + byteOffset);
43009:         const T* stop = start + count;
43009:         T result = 0;
43009:         for(const T* ptr = start; ptr != stop; ++ptr) {
43009:             if (*ptr > result) result = *ptr;
43009:         }
43009:         return result;
32195:     }
32195: 
61295:     void InvalidateCachedMaxElements() {
61295:       mHasCachedMaxUbyteElement = PR_FALSE;
61295:       mHasCachedMaxUshortElement = PR_FALSE;
61295:     }
61295: 
61295:     PRInt32 FindMaxUbyteElement() {
61295:       if (mHasCachedMaxUbyteElement) {
61295:         return mCachedMaxUbyteElement;
61295:       } else {
61295:         mHasCachedMaxUbyteElement = PR_TRUE;
61295:         mCachedMaxUbyteElement = FindMaxElementInSubArray<GLubyte>(mByteLength, 0);
61295:         return mCachedMaxUbyteElement;
61295:       }
61295:     }
61295: 
61295:     PRInt32 FindMaxUshortElement() {
61295:       if (mHasCachedMaxUshortElement) {
61295:         return mCachedMaxUshortElement;
61295:       } else {
61295:         mHasCachedMaxUshortElement = PR_TRUE;
61295:         mCachedMaxUshortElement = FindMaxElementInSubArray<GLshort>(mByteLength>>1, 0);
61295:         return mCachedMaxUshortElement;
61295:       }
61295:     }
61295: 
32195:     NS_DECL_ISUPPORTS
32195:     NS_DECL_NSIWEBGLBUFFER
32195: protected:
42916:     WebGLuint mName;
32195:     PRBool mDeleted;
62489:     PRBool mHasEverBeenBound;
43009:     GLuint mByteLength;
43009:     GLenum mTarget;
61295: 
61295:     PRUint8 mCachedMaxUbyteElement;
61295:     PRBool mHasCachedMaxUbyteElement;
61295:     PRUint16 mCachedMaxUshortElement;
61295:     PRBool mHasCachedMaxUshortElement;
61295: 
43009:     void* mData; // in the case of an Element Array Buffer, we keep a copy.
32195: };
32195: 
42471: NS_DEFINE_STATIC_IID_ACCESSOR(WebGLBuffer, WEBGLBUFFER_PRIVATE_IID)
42471: 
42471: #define WEBGLTEXTURE_PRIVATE_IID \
42471:     {0x4c19f189, 0x1f86, 0x4e61, {0x96, 0x21, 0x0a, 0x11, 0xda, 0x28, 0x10, 0xdd}}
32195: class WebGLTexture :
32195:     public nsIWebGLTexture,
42473:     public WebGLZeroingObject,
43099:     public WebGLRectangleObject,
43099:     public WebGLContextBoundObject
32195: {
32195: public:
42471:     NS_DECLARE_STATIC_IID_ACCESSOR(WEBGLTEXTURE_PRIVATE_IID)
42471: 
43099:     WebGLTexture(WebGLContext *context, WebGLuint name) :
43099:         WebGLContextBoundObject(context),
62489:         mDeleted(PR_FALSE), mHasEverBeenBound(PR_FALSE), mName(name),
51422:         mTarget(0),
51422:         mMinFilter(LOCAL_GL_NEAREST_MIPMAP_LINEAR),
51422:         mMagFilter(LOCAL_GL_LINEAR),
51422:         mWrapS(LOCAL_GL_REPEAT),
51422:         mWrapT(LOCAL_GL_REPEAT),
51422:         mFacesCount(0),
51422:         mMaxLevelWithCustomImages(0),
51422:         mHaveGeneratedMipmap(PR_FALSE),
51895:         mFakeBlackStatus(DoNotNeedFakeBlack)
58664:     {
58664:     }
32195: 
32195:     void Delete() {
32195:         if (mDeleted)
32195:             return;
32195:         ZeroOwners();
32195:         mDeleted = PR_TRUE;
32195:     }
32195: 
32195:     PRBool Deleted() { return mDeleted; }
62489:     PRBool HasEverBeenBound() { return mHasEverBeenBound; }
62489:     void SetHasEverBeenBound(PRBool x) { mHasEverBeenBound = x; }
42916:     WebGLuint GLName() { return mName; }
32195: 
32195:     NS_DECL_ISUPPORTS
32195:     NS_DECL_NSIWEBGLTEXTURE
51422: 
32195: protected:
57631:     friend class WebGLContext;
57631:     friend class WebGLFramebuffer;
57631: 
51422:     PRBool mDeleted;
62489:     PRBool mHasEverBeenBound;
42916:     WebGLuint mName;
51422: 
57631:     // we store information about the various images that are part of
57631:     // this texture (cubemap faces, mipmap levels)
51422: 
51422:     struct ImageInfo {
51422:         ImageInfo() : mWidth(0), mHeight(0), mFormat(0), mType(0), mIsDefined(PR_FALSE) {}
51422:         PRBool operator==(const ImageInfo& a) const {
51422:             return mWidth == a.mWidth && mHeight == a.mHeight &&
51422:                    mFormat == a.mFormat && mType == a.mType;
51422:         }
51422:         PRBool operator!=(const ImageInfo& a) const {
51422:             return !(*this == a);
51422:         }
51422:         PRBool IsSquare() const {
51422:             return mWidth == mHeight;
51422:         }
51422:         PRBool IsPositive() const {
51422:             return mWidth > 0 && mHeight > 0;
51422:         }
51422:         PRBool IsPowerOfTwo() const {
51422:             return is_pot_assuming_nonnegative(mWidth) &&
51422:                    is_pot_assuming_nonnegative(mHeight); // negative sizes should never happen (caught in texImage2D...)
51422:         }
51422:         WebGLsizei mWidth, mHeight;
51422:         WebGLenum mFormat, mType;
51422:         PRBool mIsDefined;
51422:     };
51422: 
58673: public:
58673: 
70163:     ImageInfo& ImageInfoAt(size_t level, size_t face = 0) {
51422: #ifdef DEBUG
51422:         if (face >= mFacesCount)
51422:             NS_ERROR("wrong face index, must be 0 for TEXTURE_2D and at most 5 for cube maps");
51422: #endif
51422:         // no need to check level as a wrong value would be caught by ElementAt().
51422:         return mImageInfos.ElementAt(level * mFacesCount + face);
51422:     }
51422: 
51422:     const ImageInfo& ImageInfoAt(size_t level, size_t face) const {
51422:         return const_cast<WebGLTexture*>(this)->ImageInfoAt(level, face);
51422:     }
51422: 
63069:     PRBool HasImageInfoAt(size_t level, size_t face) const {
63069:         return level <= mMaxLevelWithCustomImages &&
63069:                face < mFacesCount &&
63069:                ImageInfoAt(level, 0).mIsDefined;
63069:     }
63069: 
63068:     static size_t FaceForTarget(WebGLenum target) {
63068:         return target == LOCAL_GL_TEXTURE_2D ? 0 : target - LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X;
63068:     }
63068: 
58673: protected:
58673: 
51422:     WebGLenum mTarget;
51422:     WebGLenum mMinFilter, mMagFilter, mWrapS, mWrapT;
51422: 
51422:     size_t mFacesCount, mMaxLevelWithCustomImages;
51422:     nsTArray<ImageInfo> mImageInfos;
51422: 
51422:     PRBool mHaveGeneratedMipmap;
51422:     FakeBlackStatus mFakeBlackStatus;
51422: 
51422:     void EnsureMaxLevelWithCustomImagesAtLeast(size_t aMaxLevelWithCustomImages) {
71173:         mMaxLevelWithCustomImages = NS_MAX(mMaxLevelWithCustomImages, aMaxLevelWithCustomImages);
51422:         mImageInfos.EnsureLengthAtLeast((mMaxLevelWithCustomImages + 1) * mFacesCount);
51422:     }
51422: 
70163:     PRBool CheckFloatTextureFilterParams() const {
70163:         // Without OES_texture_float_linear, only NEAREST and NEAREST_MIMPAMP_NEAREST are supported
70163:         return (mMagFilter == LOCAL_GL_NEAREST) &&
70163:             (mMinFilter == LOCAL_GL_NEAREST || mMinFilter == LOCAL_GL_NEAREST_MIPMAP_NEAREST);
70163:     }
70163: 
51422:     PRBool DoesMinFilterRequireMipmap() const {
51422:         return !(mMinFilter == LOCAL_GL_NEAREST || mMinFilter == LOCAL_GL_LINEAR);
51422:     }
51422: 
51422:     PRBool AreBothWrapModesClampToEdge() const {
51422:         return mWrapS == LOCAL_GL_CLAMP_TO_EDGE && mWrapT == LOCAL_GL_CLAMP_TO_EDGE;
51422:     }
51422: 
51422:     PRBool DoesTexture2DMipmapHaveAllLevelsConsistentlyDefined(size_t face) const {
51422:         if (mHaveGeneratedMipmap)
51422:             return PR_TRUE;
51422: 
51422:         ImageInfo expected = ImageInfoAt(0, face);
51422: 
51422:         // checks if custom level>0 images are all defined up to the highest level defined
51422:         // and have the expected dimensions
51422:         for (size_t level = 0; level <= mMaxLevelWithCustomImages; ++level) {
51422:             const ImageInfo& actual = ImageInfoAt(level, face);
51422:             if (actual != expected)
51422:                 return PR_FALSE;
71173:             expected.mWidth = NS_MAX(1, expected.mWidth >> 1);
71173:             expected.mHeight = NS_MAX(1, expected.mHeight >> 1);
51422: 
51422:             // if the current level has size 1x1, we can stop here: the spec doesn't seem to forbid the existence
51422:             // of extra useless levels.
51422:             if (actual.mWidth == 1 && actual.mHeight == 1)
51422:                 return PR_TRUE;
51422:         }
51422: 
51422:         // if we're here, we've exhausted all levels without finding a 1x1 image
51422:         return PR_FALSE;
51422:     }
51422: 
51422: public:
51422: 
51422:     void SetDontKnowIfNeedFakeBlack() {
51422:         mFakeBlackStatus = DontKnowIfNeedFakeBlack;
51422:         mContext->SetDontKnowIfNeedFakeBlack();
51422:     }
51422: 
51422:     void Bind(WebGLenum aTarget) {
51422:         // this function should only be called by bindTexture().
51422:         // it assumes that the GL context is already current.
51422: 
62489:         PRBool firstTimeThisTextureIsBound = !mHasEverBeenBound;
51422: 
51422:         if (!firstTimeThisTextureIsBound && aTarget != mTarget) {
51422:             mContext->ErrorInvalidOperation("bindTexture: this texture has already been bound to a different target");
51422:             // very important to return here before modifying texture state! This was the place when I lost a whole day figuring
51422:             // very strange 'invalid write' crashes.
51422:             return;
51422:         }
51422: 
51422:         mTarget = aTarget;
51422: 
51422:         mContext->gl->fBindTexture(mTarget, mName);
51422: 
51422:         if (firstTimeThisTextureIsBound) {
51422:             mFacesCount = (mTarget == LOCAL_GL_TEXTURE_2D) ? 1 : 6;
51422:             EnsureMaxLevelWithCustomImagesAtLeast(0);
51422:             SetDontKnowIfNeedFakeBlack();
51422: 
51422:             // thanks to the WebKit people for finding this out: GL_TEXTURE_WRAP_R is not
51422:             // present in GLES 2, but is present in GL and it seems as if for cube maps
51422:             // we need to set it to GL_CLAMP_TO_EDGE to get the expected GLES behavior.
51422:             if (mTarget == LOCAL_GL_TEXTURE_CUBE_MAP && !mContext->gl->IsGLES2())
51422:                 mContext->gl->fTexParameteri(mTarget, LOCAL_GL_TEXTURE_WRAP_R, LOCAL_GL_CLAMP_TO_EDGE);
51422:         }
62489: 
62489:         mHasEverBeenBound = PR_TRUE;
51422:     }
51422: 
51422:     void SetImageInfo(WebGLenum aTarget, WebGLint aLevel,
51422:                       WebGLsizei aWidth, WebGLsizei aHeight,
63068:                       WebGLenum aFormat = 0, WebGLenum aType = 0)
63068:     {
63068:         if ( (aTarget == LOCAL_GL_TEXTURE_2D) != (mTarget == LOCAL_GL_TEXTURE_2D) )
63068:             return;
63068: 
63068:         size_t face = FaceForTarget(aTarget);
51422: 
51422:         EnsureMaxLevelWithCustomImagesAtLeast(aLevel);
51422: 
51422:         ImageInfo& imageInfo = ImageInfoAt(aLevel, face);
51422:         imageInfo.mWidth  = aWidth;
51422:         imageInfo.mHeight = aHeight;
51422:         if (aFormat)
51422:             imageInfo.mFormat = aFormat;
51422:         if (aType)
51422:             imageInfo.mType = aType;
51422:         imageInfo.mIsDefined = PR_TRUE;
51422: 
51422:         if (aLevel > 0)
51422:             SetCustomMipmap();
51422: 
51422:         SetDontKnowIfNeedFakeBlack();
51422:     }
51422: 
51422:     void SetMinFilter(WebGLenum aMinFilter) {
51422:         mMinFilter = aMinFilter;
51422:         SetDontKnowIfNeedFakeBlack();
51422:     }
51422:     void SetMagFilter(WebGLenum aMagFilter) {
51422:         mMagFilter = aMagFilter;
51422:         SetDontKnowIfNeedFakeBlack();
51422:     }
51422:     void SetWrapS(WebGLenum aWrapS) {
51422:         mWrapS = aWrapS;
51422:         SetDontKnowIfNeedFakeBlack();
51422:     }
51422:     void SetWrapT(WebGLenum aWrapT) {
51422:         mWrapT = aWrapT;
51422:         SetDontKnowIfNeedFakeBlack();
51422:     }
51422: 
51422:     void SetGeneratedMipmap() {
51422:         if (!mHaveGeneratedMipmap) {
51422:             mHaveGeneratedMipmap = PR_TRUE;
51422:             SetDontKnowIfNeedFakeBlack();
51422:         }
51422:     }
51422: 
51422:     void SetCustomMipmap() {
51422:         if (mHaveGeneratedMipmap) {
51422:             // if we were in GeneratedMipmap mode and are now switching to CustomMipmap mode,
51422:             // we need to compute now all the mipmap image info.
51422: 
51422:             // since we were in GeneratedMipmap mode, we know that the level 0 images all have the same info,
51422:             // and are power-of-two.
51422:             ImageInfo imageInfo = ImageInfoAt(0, 0);
51422:             NS_ASSERTION(imageInfo.IsPowerOfTwo(), "this texture is NPOT, so how could GenerateMipmap() ever accept it?");
51422: 
71173:             WebGLsizei size = NS_MAX(imageInfo.mWidth, imageInfo.mHeight);
51422: 
51422:             // so, the size is a power of two, let's find its log in base 2.
51422:             size_t maxLevel = 0;
51422:             for (WebGLsizei n = size; n > 1; n >>= 1)
51422:                 ++maxLevel;
51422: 
51422:             EnsureMaxLevelWithCustomImagesAtLeast(maxLevel);
51422: 
51422:             for (size_t level = 1; level <= maxLevel; ++level) {
51422:                 // again, since the sizes are powers of two, no need for any max(1,x) computation
51422:                 imageInfo.mWidth >>= 1;
51422:                 imageInfo.mHeight >>= 1;
51422:                 for(size_t face = 0; face < mFacesCount; ++face)
51422:                     ImageInfoAt(level, face) = imageInfo;
51422:             }
51422:         }
51422:         mHaveGeneratedMipmap = PR_FALSE;
51422:     }
51422: 
51895:     PRBool IsFirstImagePowerOfTwo() const {
51895:         return ImageInfoAt(0, 0).IsPowerOfTwo();
51895:     }
51895: 
51895:     PRBool AreAllLevel0ImageInfosEqual() const {
51895:         for (size_t face = 1; face < mFacesCount; ++face) {
51895:             if (ImageInfoAt(0, face) != ImageInfoAt(0, 0))
51422:                 return PR_FALSE;
51422:         }
51422:         return PR_TRUE;
51422:     }
51422: 
51422:     PRBool IsMipmapTexture2DComplete() const {
51422:         if (mTarget != LOCAL_GL_TEXTURE_2D)
51422:             return PR_FALSE;
51895:         if (!ImageInfoAt(0, 0).IsPositive())
51422:             return PR_FALSE;
51422:         if (mHaveGeneratedMipmap)
51422:             return PR_TRUE;
51422:         return DoesTexture2DMipmapHaveAllLevelsConsistentlyDefined(0);
51422:     }
51422: 
51422:     PRBool IsCubeComplete() const {
51422:         if (mTarget != LOCAL_GL_TEXTURE_CUBE_MAP)
51422:             return PR_FALSE;
51422:         const ImageInfo &first = ImageInfoAt(0, 0);
51422:         if (!first.IsPositive() || !first.IsSquare())
51422:             return PR_FALSE;
51895:         return AreAllLevel0ImageInfosEqual();
51422:     }
51422: 
51422:     PRBool IsMipmapCubeComplete() const {
51422:         if (!IsCubeComplete()) // in particular, this checks that this is a cube map
51422:             return PR_FALSE;
51422:         for (size_t face = 0; face < mFacesCount; ++face) {
51422:             if (!DoesTexture2DMipmapHaveAllLevelsConsistentlyDefined(face))
51422:                 return PR_FALSE;
51422:         }
51422:         return PR_TRUE;
51422:     }
51422: 
51422:     PRBool NeedFakeBlack() {
51422:         // handle this case first, it's the generic case
51422:         if (mFakeBlackStatus == DoNotNeedFakeBlack)
51422:             return PR_FALSE;
51422: 
51422:         if (mFakeBlackStatus == DontKnowIfNeedFakeBlack) {
51422:             // Determine if the texture needs to be faked as a black texture.
51422:             // See 3.8.2 Shader Execution in the OpenGL ES 2.0.24 spec.
51422: 
55909:             for (size_t face = 0; face < mFacesCount; ++face) {
58675:                 if (!ImageInfoAt(0, face).mIsDefined) {
58675:                     // In case of undefined texture image, we don't print any message because this is a very common
58675:                     // and often legitimate case, for example when doing asynchronous texture loading.
58675:                     // An extreme case of this is the photowall google demo.
58675:                     // Exiting early here allows us to avoid making noise on valid webgl code.
55909:                     mFakeBlackStatus = DoNeedFakeBlack;
55909:                     return PR_TRUE;
55909:                 }
58675:             }
55909: 
51895:             const char *msg_rendering_as_black
51895:                 = "A texture is going to be rendered as if it were black, as per the OpenGL ES 2.0.24 spec section 3.8.2, "
51895:                   "because it";
51895: 
51422:             if (mTarget == LOCAL_GL_TEXTURE_2D)
51422:             {
51422:                 if (DoesMinFilterRequireMipmap())
51422:                 {
51895:                     if (!IsMipmapTexture2DComplete()) {
53695:                         mContext->LogMessageIfVerbose
53695:                             ("%s is a 2D texture, with a minification filter requiring a mipmap, "
51895:                              "and is not mipmap complete (as defined in section 3.7.10).", msg_rendering_as_black);
51895:                         mFakeBlackStatus = DoNeedFakeBlack;
70163:                     } else if (!ImageInfoAt(0).IsPowerOfTwo()) {
53695:                         mContext->LogMessageIfVerbose
53695:                             ("%s is a 2D texture, with a minification filter requiring a mipmap, "
51895:                              "and either its width or height is not a power of two.", msg_rendering_as_black);
51422:                         mFakeBlackStatus = DoNeedFakeBlack;
51422:                     }
51422:                 }
51422:                 else // no mipmap required
51422:                 {
70163:                     if (!ImageInfoAt(0).IsPositive()) {
53695:                         mContext->LogMessageIfVerbose
53695:                             ("%s is a 2D texture and its width or height is equal to zero.",
51895:                              msg_rendering_as_black);
51895:                         mFakeBlackStatus = DoNeedFakeBlack;
70163:                     } else if (!AreBothWrapModesClampToEdge() && !ImageInfoAt(0).IsPowerOfTwo()) {
53695:                         mContext->LogMessageIfVerbose
53695:                             ("%s is a 2D texture, with a minification filter not requiring a mipmap, "
51895:                              "with its width or height not a power of two, and with a wrap mode "
51895:                              "different from CLAMP_TO_EDGE.", msg_rendering_as_black);
51422:                         mFakeBlackStatus = DoNeedFakeBlack;
51422:                     }
51422:                 }
51422:             }
51895:             else // cube map
51422:             {
51422:                 PRBool areAllLevel0ImagesPOT = PR_TRUE;
51422:                 for (size_t face = 0; face < mFacesCount; ++face)
51422:                     areAllLevel0ImagesPOT &= ImageInfoAt(0, face).IsPowerOfTwo();
51422: 
51422:                 if (DoesMinFilterRequireMipmap())
51422:                 {
51895:                     if (!IsMipmapCubeComplete()) {
53695:                         mContext->LogMessageIfVerbose("%s is a cube map texture, with a minification filter requiring a mipmap, "
51895:                                    "and is not mipmap cube complete (as defined in section 3.7.10).",
51895:                                    msg_rendering_as_black);
51895:                         mFakeBlackStatus = DoNeedFakeBlack;
51895:                     } else if (!areAllLevel0ImagesPOT) {
53695:                         mContext->LogMessageIfVerbose("%s is a cube map texture, with a minification filter requiring a mipmap, "
51895:                                    "and either the width or the height of some level 0 image is not a power of two.",
51895:                                    msg_rendering_as_black);
51422:                         mFakeBlackStatus = DoNeedFakeBlack;
51422:                     }
51422:                 }
51422:                 else // no mipmap required
51422:                 {
51895:                     if (!IsCubeComplete()) {
53695:                         mContext->LogMessageIfVerbose("%s is a cube map texture, with a minification filter not requiring a mipmap, "
51895:                                    "and is not cube complete (as defined in section 3.7.10).",
51895:                                    msg_rendering_as_black);
51895:                         mFakeBlackStatus = DoNeedFakeBlack;
51895:                     } else if (!AreBothWrapModesClampToEdge() && !areAllLevel0ImagesPOT) {
53695:                         mContext->LogMessageIfVerbose("%s is a cube map texture, with a minification filter not requiring a mipmap, "
51895:                                    "with some level 0 image having width or height not a power of two, and with a wrap mode "
51895:                                    "different from CLAMP_TO_EDGE.", msg_rendering_as_black);
51422:                         mFakeBlackStatus = DoNeedFakeBlack;
51422:                     }
51422:                 }
51422:             }
51422: 
51422:             // we have exhausted all cases where we do need fakeblack, so if the status is still unknown,
51422:             // that means that we do NOT need it.
51422:             if (mFakeBlackStatus == DontKnowIfNeedFakeBlack)
51422:                 mFakeBlackStatus = DoNotNeedFakeBlack;
51422:         }
51422: 
51422:         return mFakeBlackStatus == DoNeedFakeBlack;
51422:     }
32195: };
32195: 
42471: NS_DEFINE_STATIC_IID_ACCESSOR(WebGLTexture, WEBGLTEXTURE_PRIVATE_IID)
42471: 
43098: #define WEBGLSHADER_PRIVATE_IID \
43098:     {0x48cce975, 0xd459, 0x4689, {0x83, 0x82, 0x37, 0x82, 0x6e, 0xac, 0xe0, 0xa7}}
43098: class WebGLShader :
43098:     public nsIWebGLShader,
43099:     public WebGLZeroingObject,
43099:     public WebGLContextBoundObject
43098: {
43098: public:
43098:     NS_DECLARE_STATIC_IID_ACCESSOR(WEBGLSHADER_PRIVATE_IID)
43098: 
43099:     WebGLShader(WebGLContext *context, WebGLuint name, WebGLenum stype) :
43099:         WebGLContextBoundObject(context),
47653:         mName(name), mDeleted(PR_FALSE), mType(stype),
60037:         mNeedsTranslation(true), mAttachCount(0)
43098:     { }
43098: 
43098:     void Delete() {
43098:         if (mDeleted)
43098:             return;
43098:         ZeroOwners();
43098:         mDeleted = PR_TRUE;
43098:     }
43099: 
60037:     PRBool Deleted() { return mDeleted && mAttachCount == 0; }
43098:     WebGLuint GLName() { return mName; }
43098:     WebGLenum ShaderType() { return mType; }
43098: 
60037:     PRUint32 AttachCount() { return mAttachCount; }
60037:     void IncrementAttachCount() { mAttachCount++; }
60037:     void DecrementAttachCount() { mAttachCount--; }
60037: 
47653:     void SetSource(const nsCString& src) {
47653:         // XXX do some quick gzip here maybe -- getting this will be very rare
47653:         mSource.Assign(src);
47653:     }
47653: 
47653:     const nsCString& Source() const { return mSource; }
47653: 
47653:     void SetNeedsTranslation() { mNeedsTranslation = true; }
47653:     bool NeedsTranslation() const { return mNeedsTranslation; }
47653: 
47653:     void SetTranslationSuccess() {
47653:         mTranslationLog.SetIsVoid(PR_TRUE);
47653:         mNeedsTranslation = false;
47653:     }
47653: 
47653:     void SetTranslationFailure(const nsCString& msg) {
47653:         mTranslationLog.Assign(msg);
47653:     }
47653: 
47653:     const nsCString& TranslationLog() const { return mTranslationLog; }
47653: 
43098:     NS_DECL_ISUPPORTS
43098:     NS_DECL_NSIWEBGLSHADER
43098: protected:
43098:     WebGLuint mName;
43098:     PRBool mDeleted;
43098:     WebGLenum mType;
47653:     nsCString mSource;
47653:     nsCString mTranslationLog;
47653:     bool mNeedsTranslation;
60037:     PRUint32 mAttachCount;
43098: };
43098: 
43098: NS_DEFINE_STATIC_IID_ACCESSOR(WebGLShader, WEBGLSHADER_PRIVATE_IID)
43098: 
42471: #define WEBGLPROGRAM_PRIVATE_IID \
42471:     {0xb3084a5b, 0xa5b4, 0x4ee0, {0xa0, 0xf0, 0xfb, 0xdd, 0x64, 0xaf, 0x8e, 0x82}}
32195: class WebGLProgram :
32195:     public nsIWebGLProgram,
43099:     public WebGLZeroingObject,
43099:     public WebGLContextBoundObject
32195: {
32195: public:
42471:     NS_DECLARE_STATIC_IID_ACCESSOR(WEBGLPROGRAM_PRIVATE_IID)
42471: 
43099:     WebGLProgram(WebGLContext *context, WebGLuint name) :
43099:         WebGLContextBoundObject(context),
60037:         mName(name), mDeleted(PR_FALSE), mDeletePending(PR_FALSE),
60037:         mLinkStatus(PR_FALSE), mGeneration(0),
43474:         mUniformMaxNameLength(0), mAttribMaxNameLength(0),
43474:         mUniformCount(0), mAttribCount(0)
43331:     {
43331:         mMapUniformLocations.Init();
43331:     }
38926: 
38926:     void Delete() {
38926:         if (mDeleted)
38926:             return;
38926:         ZeroOwners();
38926:         mDeleted = PR_TRUE;
38926:     }
43098: 
60037:     void DetachShaders() {
60037:         for (PRUint32 i = 0; i < mAttachedShaders.Length(); ++i) {
69415:             if (mAttachedShaders[i])
60037:                 mAttachedShaders[i]->DecrementAttachCount();
60037:         }
60037:         mAttachedShaders.Clear();
60037:     }
60037: 
60037:     PRBool Deleted() { return mDeleted && !mDeletePending; }
60037:     void SetDeletePending() { mDeletePending = PR_TRUE; }
60037:     void ClearDeletePending() { mDeletePending = PR_FALSE; }
60037:     PRBool HasDeletePending() { return mDeletePending; }
60037: 
42916:     WebGLuint GLName() { return mName; }
69415:     const nsTArray<nsRefPtr<WebGLShader> >& AttachedShaders() const { return mAttachedShaders; }
43098:     PRBool LinkStatus() { return mLinkStatus; }
47204:     PRUint32 Generation() const { return mGeneration.value(); }
43098:     void SetLinkStatus(PRBool val) { mLinkStatus = val; }
43098: 
43098:     PRBool ContainsShader(WebGLShader *shader) {
43098:         return mAttachedShaders.Contains(shader);
43098:     }
43098: 
43098:     // return true if the shader wasn't already attached
43098:     PRBool AttachShader(WebGLShader *shader) {
43098:         if (ContainsShader(shader))
43098:             return PR_FALSE;
43098:         mAttachedShaders.AppendElement(shader);
60037:         shader->IncrementAttachCount();
43098:         return PR_TRUE;
43098:     }
43098: 
43098:     // return true if the shader was found and removed
43098:     PRBool DetachShader(WebGLShader *shader) {
60037:         if (mAttachedShaders.RemoveElement(shader)) {
60037:             shader->DecrementAttachCount();
60037:             return PR_TRUE;
60037:         }
60037:         return PR_FALSE;
43098:     }
43098: 
57637:     PRBool HasAttachedShaderOfType(GLenum shaderType) {
43098:         for (PRUint32 i = 0; i < mAttachedShaders.Length(); ++i) {
69415:             if (mAttachedShaders[i] && mAttachedShaders[i]->ShaderType() == shaderType) {
43098:                 return PR_TRUE;
43098:             }
57637:         }
57637:         return PR_FALSE;
57637:     }
43098: 
57637:     PRBool HasBothShaderTypesAttached() {
57637:         return
57637:             HasAttachedShaderOfType(LOCAL_GL_VERTEX_SHADER) &&
57637:             HasAttachedShaderOfType(LOCAL_GL_FRAGMENT_SHADER);
43098:     }
38926: 
43331:     PRBool NextGeneration()
43331:     {
47204:         if (!(mGeneration+1).valid())
43331:             return PR_FALSE; // must exit without changing mGeneration
47204:         ++mGeneration;
43331:         mMapUniformLocations.Clear();
43331:         return PR_TRUE;
43331:     }
43331:     
56959: 
43331:     already_AddRefed<WebGLUniformLocation> GetUniformLocationObject(GLint glLocation);
43331: 
43474:     /* Called only after LinkProgram */
43474:     PRBool UpdateInfo(gl::GLContext *gl);
43474: 
43474:     /* Getters for cached program info */
43474:     WebGLint UniformMaxNameLength() const { return mUniformMaxNameLength; }
43474:     WebGLint AttribMaxNameLength() const { return mAttribMaxNameLength; }
43474:     WebGLint UniformCount() const { return mUniformCount; }
43474:     WebGLint AttribCount() const { return mAttribCount; }
43474:     bool IsAttribInUse(unsigned i) const { return mAttribsInUse[i]; }
43474: 
38926:     NS_DECL_ISUPPORTS
38926:     NS_DECL_NSIWEBGLPROGRAM
38926: protected:
42916:     WebGLuint mName;
43098:     PRPackedBool mDeleted;
60037:     PRPackedBool mDeletePending;
43098:     PRPackedBool mLinkStatus;
60037:     // attached shaders of the program object
69415:     nsTArray<nsRefPtr<WebGLShader> > mAttachedShaders;
60037:     CheckedUint32 mGeneration;
60037: 
60037:     // post-link data
43331:     nsRefPtrHashtable<nsUint32HashKey, WebGLUniformLocation> mMapUniformLocations;
43474:     GLint mUniformMaxNameLength;
43474:     GLint mAttribMaxNameLength;
43474:     GLint mUniformCount;
43474:     GLint mAttribCount;
43474:     std::vector<bool> mAttribsInUse;
38926: };
38926: 
42471: NS_DEFINE_STATIC_IID_ACCESSOR(WebGLProgram, WEBGLPROGRAM_PRIVATE_IID)
42471: 
56959: #define WEBGLRENDERBUFFER_PRIVATE_IID \
56959:     {0x3cbc2067, 0x5831, 0x4e3f, {0xac, 0x52, 0x7e, 0xf4, 0x5c, 0x04, 0xff, 0xae}}
56959: class WebGLRenderbuffer :
56959:     public nsIWebGLRenderbuffer,
56959:     public WebGLZeroingObject,
56959:     public WebGLRectangleObject,
56959:     public WebGLContextBoundObject
56959: {
56959: public:
56959:     NS_DECLARE_STATIC_IID_ACCESSOR(WEBGLRENDERBUFFER_PRIVATE_IID)
56959: 
56959:     WebGLRenderbuffer(WebGLContext *context, WebGLuint name, WebGLuint secondBufferName = 0) :
56959:         WebGLContextBoundObject(context),
56959:         mName(name),
56959:         mInternalFormat(0),
62489:         mDeleted(PR_FALSE), mHasEverBeenBound(PR_FALSE), mInitialized(PR_FALSE)
56959:     { }
56959: 
56959:     void Delete() {
56959:         if (mDeleted)
56959:             return;
56959:         ZeroOwners();
56959:         mDeleted = PR_TRUE;
56959:     }
56959:     PRBool Deleted() const { return mDeleted; }
62489:     PRBool HasEverBeenBound() { return mHasEverBeenBound; }
62489:     void SetHasEverBeenBound(PRBool x) { mHasEverBeenBound = x; }
56959:     WebGLuint GLName() const { return mName; }
56959: 
56959:     PRBool Initialized() const { return mInitialized; }
56959:     void SetInitialized(PRBool aInitialized) { mInitialized = aInitialized; }
56959: 
56959:     WebGLenum InternalFormat() const { return mInternalFormat; }
56959:     void SetInternalFormat(WebGLenum aInternalFormat) { mInternalFormat = aInternalFormat; }
56959: 
56959:     NS_DECL_ISUPPORTS
56959:     NS_DECL_NSIWEBGLRENDERBUFFER
56959: 
56959: protected:
56959:     WebGLuint mName;
56959:     WebGLenum mInternalFormat;
56959: 
56959:     PRBool mDeleted;
62489:     PRBool mHasEverBeenBound;
56959:     PRBool mInitialized;
56959: 
56959:     friend class WebGLFramebuffer;
56959: };
56959: 
56959: NS_DEFINE_STATIC_IID_ACCESSOR(WebGLRenderbuffer, WEBGLRENDERBUFFER_PRIVATE_IID)
56959: 
58664: class WebGLFramebufferAttachment
58664: {
60041:     // deleting a texture or renderbuffer immediately detaches it
60041:     WebGLObjectRefPtr<WebGLTexture> mTexturePtr;
60041:     WebGLObjectRefPtr<WebGLRenderbuffer> mRenderbufferPtr;
58664:     WebGLenum mAttachmentPoint;
60039:     WebGLint mTextureLevel;
60039:     WebGLenum mTextureCubeMapFace;
58664: 
58664: public:
58664:     WebGLFramebufferAttachment(WebGLenum aAttachmentPoint)
58664:         : mAttachmentPoint(aAttachmentPoint)
58664:     {}
58664: 
58664:     PRBool IsNull() const {
58664:         return !mTexturePtr && !mRenderbufferPtr;
58664:     }
58664: 
58673:     PRBool HasAlpha() const {
58673:         WebGLenum format = 0;
58673:         if (mTexturePtr)
58673:             format = mTexturePtr->ImageInfoAt(0,0).mFormat;
58673:         if (mRenderbufferPtr)
58673:             format = mRenderbufferPtr->InternalFormat();
58673:         return format == LOCAL_GL_RGBA ||
58673:                format == LOCAL_GL_LUMINANCE_ALPHA ||
58673:                format == LOCAL_GL_ALPHA ||
58673:                format == LOCAL_GL_RGBA4 ||
58673:                format == LOCAL_GL_RGB5_A1;
58673:     }
58673: 
60039:     void SetTexture(WebGLTexture *tex, WebGLint level, WebGLenum face) {
58664:         mTexturePtr = tex;
58664:         mRenderbufferPtr = nsnull;
60039:         mTextureLevel = level;
60039:         mTextureCubeMapFace = face;
58664:     }
58664:     void SetRenderbuffer(WebGLRenderbuffer *rb) {
58664:         mTexturePtr = nsnull;
58664:         mRenderbufferPtr = rb;
58664:     }
58664:     WebGLTexture *Texture() const {
58664:         return mTexturePtr.get();
58664:     }
58664:     WebGLRenderbuffer *Renderbuffer() const {
58664:         return mRenderbufferPtr.get();
58664:     }
60039:     WebGLint TextureLevel() const {
60039:         return mTextureLevel;
60039:     }
60039:     WebGLenum TextureCubeMapFace() const {
60039:         return mTextureCubeMapFace;
60039:     }
58664: 
58664:     PRBool IsIncompatibleWithAttachmentPoint() const
58664:     {
58664:         // textures can only be color textures in WebGL
58664:         if (mTexturePtr)
58664:             return mAttachmentPoint != LOCAL_GL_COLOR_ATTACHMENT0;
58664: 
58664:         if (mRenderbufferPtr) {
58664:             WebGLenum format = mRenderbufferPtr->InternalFormat();
58664:             switch (mAttachmentPoint) {
58664:                 case LOCAL_GL_COLOR_ATTACHMENT0:
58664:                     return format != LOCAL_GL_RGB565 &&
58664:                            format != LOCAL_GL_RGB5_A1 &&
58664:                            format != LOCAL_GL_RGBA4;
58664:                 case LOCAL_GL_DEPTH_ATTACHMENT:
58664:                     return format != LOCAL_GL_DEPTH_COMPONENT16;
58664:                 case LOCAL_GL_STENCIL_ATTACHMENT:
58664:                     return format != LOCAL_GL_STENCIL_INDEX8;
58664:                 case LOCAL_GL_DEPTH_STENCIL_ATTACHMENT:
58664:                     return format != LOCAL_GL_DEPTH_STENCIL;
58664:             }
58664:         }
58664: 
58664:         return PR_FALSE; // no attachment at all, so no incompatibility
58664:     }
58664: 
58664:     PRBool HasUninitializedRenderbuffer() const {
58664:         return mRenderbufferPtr && !mRenderbufferPtr->Initialized();
58664:     }
58664: };
58664: 
42471: #define WEBGLFRAMEBUFFER_PRIVATE_IID \
42471:     {0x0052a16f, 0x4bc9, 0x4a55, {0x9d, 0xa3, 0x54, 0x95, 0xaa, 0x4e, 0x80, 0xb9}}
38926: class WebGLFramebuffer :
38926:     public nsIWebGLFramebuffer,
42473:     public WebGLZeroingObject,
43099:     public WebGLRectangleObject,
43099:     public WebGLContextBoundObject
38926: {
38926: public:
42471:     NS_DECLARE_STATIC_IID_ACCESSOR(WEBGLFRAMEBUFFER_PRIVATE_IID)
42471: 
43099:     WebGLFramebuffer(WebGLContext *context, WebGLuint name) :
43099:         WebGLContextBoundObject(context),
62489:         mName(name), mDeleted(PR_FALSE), mHasEverBeenBound(PR_FALSE),
58664:         mColorAttachment(LOCAL_GL_COLOR_ATTACHMENT0),
58664:         mDepthAttachment(LOCAL_GL_DEPTH_ATTACHMENT),
58664:         mStencilAttachment(LOCAL_GL_STENCIL_ATTACHMENT),
58664:         mDepthStencilAttachment(LOCAL_GL_DEPTH_STENCIL_ATTACHMENT)
43099:     { }
32195: 
32195:     void Delete() {
32195:         if (mDeleted)
32195:             return;
32195:         ZeroOwners();
32195:         mDeleted = PR_TRUE;
32195:     }
32195:     PRBool Deleted() { return mDeleted; }
62489:     PRBool HasEverBeenBound() { return mHasEverBeenBound; }
62489:     void SetHasEverBeenBound(PRBool x) { mHasEverBeenBound = x; }
42916:     WebGLuint GLName() { return mName; }
32195: 
56959:     nsresult FramebufferRenderbuffer(WebGLenum target,
56959:                                      WebGLenum attachment,
56959:                                      WebGLenum rbtarget,
56959:                                      nsIWebGLRenderbuffer *rbobj)
56959:     {
56959:         WebGLuint renderbuffername;
56959:         PRBool isNull;
56959:         WebGLRenderbuffer *wrb;
56959: 
56959:         if (!mContext->GetConcreteObjectAndGLName("framebufferRenderbuffer: renderbuffer",
56959:                                                   rbobj, &wrb, &renderbuffername, &isNull))
56959:         {
56959:             return NS_OK;
56959:         }
56959: 
56959:         if (target != LOCAL_GL_FRAMEBUFFER)
56959:             return mContext->ErrorInvalidEnumInfo("framebufferRenderbuffer: target", target);
56959: 
56959:         if (rbtarget != LOCAL_GL_RENDERBUFFER)
56959:             return mContext->ErrorInvalidEnumInfo("framebufferRenderbuffer: renderbuffer target:", rbtarget);
56959: 
56959:         switch (attachment) {
56959:         case LOCAL_GL_DEPTH_ATTACHMENT:
58664:             mDepthAttachment.SetRenderbuffer(wrb);
56959:             break;
56959:         case LOCAL_GL_STENCIL_ATTACHMENT:
58664:             mStencilAttachment.SetRenderbuffer(wrb);
56959:             break;
56959:         case LOCAL_GL_DEPTH_STENCIL_ATTACHMENT:
58664:             mDepthStencilAttachment.SetRenderbuffer(wrb);
56959:             break;
56959:         default:
56959:             // finish checking that the 'attachment' parameter is among the allowed values
58664:             if (attachment != LOCAL_GL_COLOR_ATTACHMENT0)
56959:                 return mContext->ErrorInvalidEnumInfo("framebufferRenderbuffer: attachment", attachment);
56959:             if (!isNull) {
57631:                 // ReadPixels needs alpha and size information, but only
57631:                 // for COLOR_ATTACHMENT0
57631:                 setDimensions(wrb);
57631:             }
58664:             mColorAttachment.SetRenderbuffer(wrb);
56959:             break;
56959:         }
56959: 
56959:         mContext->MakeContextCurrent();
60039:         if (attachment == LOCAL_GL_DEPTH_STENCIL_ATTACHMENT) {
60039:             mContext->gl->fFramebufferRenderbuffer(target, LOCAL_GL_DEPTH_ATTACHMENT, rbtarget, renderbuffername);
60039:             mContext->gl->fFramebufferRenderbuffer(target, LOCAL_GL_STENCIL_ATTACHMENT, rbtarget, renderbuffername);
60039:         } else {
56959:             mContext->gl->fFramebufferRenderbuffer(target, attachment, rbtarget, renderbuffername);
60039:         }
56959: 
56959:         return NS_OK;
56959:     }
56959: 
56959:     nsresult FramebufferTexture2D(WebGLenum target,
56959:                                   WebGLenum attachment,
56959:                                   WebGLenum textarget,
56959:                                   nsIWebGLTexture *tobj,
56959:                                   WebGLint level)
56959:     {
56959:         WebGLuint texturename;
56959:         PRBool isNull;
56959:         WebGLTexture *wtex;
56959: 
56959:         if (!mContext->GetConcreteObjectAndGLName("framebufferTexture2D: texture",
56959:                                                   tobj, &wtex, &texturename, &isNull))
56959:         {
56959:             return NS_OK;
56959:         }
56959: 
56959:         if (target != LOCAL_GL_FRAMEBUFFER)
56959:             return mContext->ErrorInvalidEnumInfo("framebufferTexture2D: target", target);
56959: 
56959:         if (!isNull && textarget != LOCAL_GL_TEXTURE_2D &&
56959:             (textarget < LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X ||
56959:             textarget > LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))
56959:             return mContext->ErrorInvalidEnumInfo("framebufferTexture2D: invalid texture target", textarget);
56959: 
56959:         if (!isNull && level > 0)
56959:             return mContext->ErrorInvalidValue("framebufferTexture2D: level must be 0");
56959: 
60039:         WebGLint face = (textarget == LOCAL_GL_TEXTURE_2D) ? 0 : textarget;
56959:         switch (attachment) {
56959:         case LOCAL_GL_DEPTH_ATTACHMENT:
60039:             mDepthAttachment.SetTexture(wtex, level, face);
58664:             break;
56959:         case LOCAL_GL_STENCIL_ATTACHMENT:
60039:             mStencilAttachment.SetTexture(wtex, level, face);
58664:             break;
56959:         case LOCAL_GL_DEPTH_STENCIL_ATTACHMENT:
60039:             mDepthStencilAttachment.SetTexture(wtex, level, face);
56959:             break;
56959:         default:
58664:             if (attachment != LOCAL_GL_COLOR_ATTACHMENT0)
56959:                 return mContext->ErrorInvalidEnumInfo("framebufferTexture2D: attachment", attachment);
57631: 
57631:             // keep data for readPixels, function only uses COLOR_ATTACHMENT0
57631:             setDimensions(wtex);
57631: 
60039:             mColorAttachment.SetTexture(wtex, level, face);
56959:             break;
56959:         }
56959: 
56959:         mContext->MakeContextCurrent();
60039:         if (attachment == LOCAL_GL_DEPTH_STENCIL_ATTACHMENT) {
60039:             mContext->gl->fFramebufferTexture2D(target, LOCAL_GL_DEPTH_ATTACHMENT, textarget, texturename, level);
60039:             mContext->gl->fFramebufferTexture2D(target, LOCAL_GL_STENCIL_ATTACHMENT, textarget, texturename, level);
60039:         } else {
56959:             mContext->gl->fFramebufferTexture2D(target, attachment, textarget, texturename, level);
60039:         }
56959: 
56959:         return NS_OK;
56959:     }
56959: 
58664:     PRBool CheckAndInitializeRenderbuffers()
56959:     {
58664:         if (HasBadAttachments()) {
56959:             mContext->SynthesizeGLError(LOCAL_GL_INVALID_FRAMEBUFFER_OPERATION);
56959:             return PR_FALSE;
56959:         }
56959: 
58664:         if (mColorAttachment.HasUninitializedRenderbuffer() ||
58664:             mDepthAttachment.HasUninitializedRenderbuffer() ||
58664:             mStencilAttachment.HasUninitializedRenderbuffer() ||
58664:             mDepthStencilAttachment.HasUninitializedRenderbuffer())
56959:         {
56959:             InitializeRenderbuffers();
56959:         }
56959: 
56959:         return PR_TRUE;
56959:     }
56959: 
58664:     PRBool HasBadAttachments() const {
58664:         if (mColorAttachment.IsIncompatibleWithAttachmentPoint() ||
58664:             mDepthAttachment.IsIncompatibleWithAttachmentPoint() ||
58664:             mStencilAttachment.IsIncompatibleWithAttachmentPoint() ||
58664:             mDepthStencilAttachment.IsIncompatibleWithAttachmentPoint())
58664:         {
58664:             // some attachment is incompatible with its attachment point
58664:             return PR_TRUE;
58664:         }
58664:         else if (int(mDepthAttachment.IsNull()) +
58664:                  int(mStencilAttachment.IsNull()) +
58664:                  int(mDepthStencilAttachment.IsNull()) <= 1)
58664:         {
58664:             // has at least two among Depth, Stencil, DepthStencil
58664:             return PR_TRUE;
58664:         }
58664:         else return PR_FALSE;
56959:     }
56959: 
60039:     const WebGLFramebufferAttachment& ColorAttachment() const {
60039:         return mColorAttachment;
60039:     }
60039: 
60039:     const WebGLFramebufferAttachment& DepthAttachment() const {
60039:         return mDepthAttachment;
60039:     }
60039: 
60039:     const WebGLFramebufferAttachment& StencilAttachment() const {
60039:         return mStencilAttachment;
60039:     }
60039: 
60039:     const WebGLFramebufferAttachment& DepthStencilAttachment() const {
60039:         return mDepthStencilAttachment;
60039:     }
60039: 
60039:     const WebGLFramebufferAttachment& GetAttachment(WebGLenum attachment) const {
60039:         if (attachment == LOCAL_GL_DEPTH_STENCIL_ATTACHMENT)
60039:             return mDepthStencilAttachment;
60039:         if (attachment == LOCAL_GL_DEPTH_ATTACHMENT)
60039:             return mDepthAttachment;
60039:         if (attachment == LOCAL_GL_STENCIL_ATTACHMENT)
60039:             return mStencilAttachment;
60039: 
60039:         NS_ASSERTION(attachment == LOCAL_GL_COLOR_ATTACHMENT0, "bad attachment!");
58673:         return mColorAttachment;
57631:     }
57631: 
58664:     NS_DECL_ISUPPORTS
58664:     NS_DECL_NSIWEBGLFRAMEBUFFER
58664: 
32195: protected:
56959: 
56959:     // protected because WebGLContext should only call InitializeRenderbuffers
56959:     void InitializeRenderbuffers()
56959:     {
56959:         mContext->MakeContextCurrent();
56959: 
56959:         if (mContext->gl->fCheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER) != LOCAL_GL_FRAMEBUFFER_COMPLETE)
56959:             return;
56959: 
70167:         PRUint32 mask = 0;
56959: 
70167:         if (mColorAttachment.HasUninitializedRenderbuffer())
70167:             mask |= LOCAL_GL_COLOR_BUFFER_BIT;
56959: 
70167:         if (mDepthAttachment.HasUninitializedRenderbuffer() ||
70167:             mDepthStencilAttachment.HasUninitializedRenderbuffer())
70167:         {
70167:             mask |= LOCAL_GL_DEPTH_BUFFER_BIT;
56959:         }
56959: 
70167:         if (mStencilAttachment.HasUninitializedRenderbuffer() ||
70167:             mDepthStencilAttachment.HasUninitializedRenderbuffer())
70167:         {
70167:             mask |= LOCAL_GL_STENCIL_BUFFER_BIT;
56959:         }
56959: 
56959:         // the one useful line of code
70167:         mContext->ForceClearFramebufferWithDefaultValues(mask, nsIntRect(0,0,width(),height()));
56959: 
70167:         if (mColorAttachment.HasUninitializedRenderbuffer())
58664:             mColorAttachment.Renderbuffer()->SetInitialized(PR_TRUE);
56959: 
70167:         if (mDepthAttachment.HasUninitializedRenderbuffer())
58664:             mDepthAttachment.Renderbuffer()->SetInitialized(PR_TRUE);
56959: 
70167:         if (mStencilAttachment.HasUninitializedRenderbuffer())
58664:             mStencilAttachment.Renderbuffer()->SetInitialized(PR_TRUE);
58664: 
70167:         if (mDepthStencilAttachment.HasUninitializedRenderbuffer())
58664:             mDepthStencilAttachment.Renderbuffer()->SetInitialized(PR_TRUE);
56959:     }
56959: 
42916:     WebGLuint mName;
57631:     PRPackedBool mDeleted;
62489:     PRBool mHasEverBeenBound;
58664: 
56959:     // we only store pointers to attached renderbuffers, not to attached textures, because
56959:     // we will only need to initialize renderbuffers. Textures are already initialized.
58664:     WebGLFramebufferAttachment mColorAttachment,
58664:                                mDepthAttachment,
58664:                                mStencilAttachment,
58664:                                mDepthStencilAttachment;
32195: };
32195: 
42471: NS_DEFINE_STATIC_IID_ACCESSOR(WebGLFramebuffer, WEBGLFRAMEBUFFER_PRIVATE_IID)
42471: 
43010: #define WEBGLUNIFORMLOCATION_PRIVATE_IID \
43010:     {0x01a8a614, 0xb109, 0x42f1, {0xb4, 0x40, 0x8d, 0x8b, 0x87, 0x0b, 0x43, 0xa7}}
43010: class WebGLUniformLocation :
43010:     public nsIWebGLUniformLocation,
43099:     public WebGLZeroingObject,
43099:     public WebGLContextBoundObject
43010: {
43010: public:
43010:     NS_DECLARE_STATIC_IID_ACCESSOR(WEBGLUNIFORMLOCATION_PRIVATE_IID)
43010: 
43099:     WebGLUniformLocation(WebGLContext *context, WebGLProgram *program, GLint location) :
43331:         WebGLContextBoundObject(context), mProgram(program), mProgramGeneration(program->Generation()),
43331:         mLocation(location) { }
43010: 
43010:     WebGLProgram *Program() const { return mProgram; }
43010:     GLint Location() const { return mLocation; }
47204:     PRUint32 ProgramGeneration() const { return mProgramGeneration; }
43010: 
43010:     // needed for our generic helpers to check nsIxxx parameters, see GetConcreteObject.
43010:     PRBool Deleted() { return PR_FALSE; }
43010: 
43010:     NS_DECL_ISUPPORTS
43010:     NS_DECL_NSIWEBGLUNIFORMLOCATION
43010: protected:
43010:     WebGLObjectRefPtr<WebGLProgram> mProgram;
47204:     PRUint32 mProgramGeneration;
43010:     GLint mLocation;
43010: };
43010: 
43010: NS_DEFINE_STATIC_IID_ACCESSOR(WebGLUniformLocation, WEBGLUNIFORMLOCATION_PRIVATE_IID)
43010: 
51421: #define WEBGLACTIVEINFO_PRIVATE_IID \
51421:     {0x90def5ec, 0xc672, 0x4ac3, {0xb8, 0x97, 0x04, 0xa2, 0x6d, 0xda, 0x66, 0xd7}}
51421: class WebGLActiveInfo :
51421:     public nsIWebGLActiveInfo
51421: {
51421: public:
51421:     NS_DECLARE_STATIC_IID_ACCESSOR(WEBGLACTIVEINFO_PRIVATE_IID)
51421: 
51421:     WebGLActiveInfo(WebGLint size, WebGLenum type, const char *nameptr, PRUint32 namelength) :
51421:         mDeleted(PR_FALSE),
51421:         mSize(size),
51421:         mType(type)
51421:     {
51421:         mName.AssignASCII(nameptr, namelength);
51421:     }
51421: 
51421:     void Delete() {
51421:         if (mDeleted)
51421:             return;
51421:         mDeleted = PR_TRUE;
51421:     }
51421: 
51421:     PRBool Deleted() { return mDeleted; }
51421: 
51421:     NS_DECL_ISUPPORTS
51421:     NS_DECL_NSIWEBGLACTIVEINFO
51421: protected:
51421:     PRBool mDeleted;
51421:     WebGLint mSize;
51421:     WebGLenum mType;
51421:     nsString mName;
51421: };
51421: 
51421: NS_DEFINE_STATIC_IID_ACCESSOR(WebGLActiveInfo, WEBGLACTIVEINFO_PRIVATE_IID)
51421: 
70163: #define WEBGLEXTENSION_PRIVATE_IID \
70163:     {0x457dd0b2, 0x9f77, 0x4c23, {0x95, 0x70, 0x9d, 0x62, 0x65, 0xc1, 0xa4, 0x81}}
70163: class WebGLExtension :
70164:     public nsIWebGLExtension,
70164:     public WebGLContextBoundObject,
70164:     public WebGLZeroingObject
70163: {
70163: public:
70163:     WebGLExtension(WebGLContext *baseContext)
70164:         : WebGLContextBoundObject(baseContext)
70163:     {}
70163: 
70163:     NS_DECL_ISUPPORTS
70163:     NS_DECL_NSIWEBGLEXTENSION
70163: 
70163:     NS_DECLARE_STATIC_IID_ACCESSOR(WEBGLEXTENSION_PRIVATE_IID)
70163: };
70163: 
70163: NS_DEFINE_STATIC_IID_ACCESSOR(WebGLExtension, WEBGLACTIVEINFO_PRIVATE_IID)
70163: 
43099: /**
43099:  ** Template implementations
43099:  **/
43099: 
43099: /* Helper function taking a BaseInterfaceType pointer and check that
43099:  * it matches the required concrete implementation type (if it's
43099:  * non-null), that it's not null/deleted unless we allowed it to, and
43099:  * obtain a pointer to the concrete object.
43099:  *
43099:  * By default, null (respectively: deleted) aInterface pointers are
43099:  * not allowed, but if you pass a non-null isNull (respectively:
43099:  * isDeleted) pointer, then they become allowed and the value at
47811:  * isNull (respecively isDeleted) is overwritten.
47811:  *
47811:  * If generateErrors is true (which is the default) then upon errors,
47811:  * GL errors are synthesized and error messages are printed, prepended by
47811:  * the 'info' string.
43099:  */
43099: 
43099: template<class ConcreteObjectType, class BaseInterfaceType>
47811: inline PRBool
47811: WebGLContext::GetConcreteObject(const char *info,
47811:                                 BaseInterfaceType *aInterface,
43099:                                 ConcreteObjectType **aConcreteObject,
43099:                                 PRBool *isNull,
47811:                                 PRBool *isDeleted,
47811:                                 PRBool generateErrors)
43099: {
43099:     if (!aInterface) {
43099:         if (NS_LIKELY(isNull)) {
43099:             // non-null isNull means that the caller will accept a null arg
43099:             *isNull = PR_TRUE;
43099:             if(isDeleted) *isDeleted = PR_FALSE;
43099:             *aConcreteObject = 0;
43099:             return PR_TRUE;
43099:         } else {
47811:             if (generateErrors)
47811:                 ErrorInvalidValue("%s: null object passed as argument", info);
43099:             return PR_FALSE;
43099:         }
43099:     }
43099: 
43099:     if (isNull)
43099:         *isNull = PR_FALSE;
43099: 
43099:     nsresult rv;
43099:     nsCOMPtr<ConcreteObjectType> tmp(do_QueryInterface(aInterface, &rv));
43099:     if (NS_FAILED(rv))
43099:         return PR_FALSE;
43099: 
43099:     *aConcreteObject = tmp;
43099: 
43099:     if (!(*aConcreteObject)->IsCompatibleWithContext(this)) {
43099:         // the object doesn't belong to this WebGLContext
55263:         if (generateErrors)
47811:             ErrorInvalidOperation("%s: object from different WebGL context (or older generation of this one) "
47811:                                   "passed as argument", info);
43099:         return PR_FALSE;
43099:     }
43099: 
43099:     if ((*aConcreteObject)->Deleted()) {
43099:         if (NS_LIKELY(isDeleted)) {
43099:             // non-null isDeleted means that the caller will accept a deleted arg
43099:             *isDeleted = PR_TRUE;
43099:             return PR_TRUE;
43099:         } else {
47811:             if (generateErrors)
55263:                 ErrorInvalidValue("%s: deleted object passed as argument", info);
43099:             return PR_FALSE;
43099:         }
43099:     }
43099: 
43099:     if (isDeleted)
43099:       *isDeleted = PR_FALSE;
43099: 
43099:     return PR_TRUE;
43099: }
43099: 
43099: /* Same as GetConcreteObject, and in addition gets the GL object name.
43099:  * Null objects give the name 0.
43099:  */
43099: template<class ConcreteObjectType, class BaseInterfaceType>
47811: inline PRBool
47811: WebGLContext::GetConcreteObjectAndGLName(const char *info,
47811:                                          BaseInterfaceType *aInterface,
43099:                                          ConcreteObjectType **aConcreteObject,
43099:                                          WebGLuint *aGLObjectName,
43099:                                          PRBool *isNull,
43099:                                          PRBool *isDeleted)
43099: {
47811:     PRBool result = GetConcreteObject(info, aInterface, aConcreteObject, isNull, isDeleted);
43099:     if (result == PR_FALSE) return PR_FALSE;
43099:     *aGLObjectName = *aConcreteObject ? (*aConcreteObject)->GLName() : 0;
43099:     return PR_TRUE;
43099: }
43099: 
43099: /* Same as GetConcreteObjectAndGLName when you don't need the concrete object pointer.
43099:  */
43099: template<class ConcreteObjectType, class BaseInterfaceType>
47811: inline PRBool
47811: WebGLContext::GetGLName(const char *info,
47811:                         BaseInterfaceType *aInterface,
43099:                         WebGLuint *aGLObjectName,
43099:                         PRBool *isNull,
43099:                         PRBool *isDeleted)
43099: {
43099:     ConcreteObjectType *aConcreteObject;
47811:     return GetConcreteObjectAndGLName(info, aInterface, &aConcreteObject, aGLObjectName, isNull, isDeleted);
43099: }
43099: 
43099: /* Same as GetConcreteObject when you only want to check if the conversion succeeds.
43099:  */
43099: template<class ConcreteObjectType, class BaseInterfaceType>
47811: inline PRBool
47811: WebGLContext::CanGetConcreteObject(const char *info,
47811:                               BaseInterfaceType *aInterface,
43099:                               PRBool *isNull,
43099:                               PRBool *isDeleted)
43099: {
43099:     ConcreteObjectType *aConcreteObject;
47811:     return GetConcreteObject(info, aInterface, &aConcreteObject, isNull, isDeleted, PR_FALSE);
43099: }
43099: 
32195: }
32195: 
32195: #endif
