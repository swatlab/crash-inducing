12041: #
12041: # ***** BEGIN LICENSE BLOCK *****
12041: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
12041: #
12041: # The contents of this file are subject to the Mozilla Public License Version
12041: # 1.1 (the "License"); you may not use this file except in compliance with
12041: # the License. You may obtain a copy of the License at
12041: # http://www.mozilla.org/MPL/
12041: #
12041: # Software distributed under the License is distributed on an "AS IS" basis,
12041: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
12041: # for the specific language governing rights and limitations under the
12041: # License.
12041: #
12041: # The Original Code is mozilla.org code.
12041: #
12041: # The Initial Developer of the Original Code is
12041: # Mozilla Foundation.
12041: # Portions created by the Initial Developer are Copyright (C) 2008
12041: # the Initial Developer. All Rights Reserved.
12041: #
12041: # Contributor(s):
12041: #   Robert Sayre <sayrer@gmail.com>
12041: #   Jeff Walden <jwalden+bmo@mit.edu>
12041: #
12041: # Alternatively, the contents of this file may be used under the terms of
12041: # either the GNU General Public License Version 2 or later (the "GPL"), or
12041: # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
12041: # in which case the provisions of the GPL or the LGPL are applicable instead
12041: # of those above. If you wish to allow use of your version of this file only
12041: # under the terms of either the GPL or the LGPL, and not to allow others to
12041: # use your version of this file under the terms of the MPL, indicate your
12041: # decision by deleting the provisions above and replace them with the notice
12041: # and other provisions required by the GPL or the LGPL. If you do not delete
12041: # the provisions above, a recipient may use your version of this file under
12041: # the terms of any one of the MPL, the GPL or the LGPL.
12041: #
12041: # ***** END LICENSE BLOCK *****
12041: 
15290: import codecs
36897: from datetime import datetime, timedelta
12041: import itertools
14025: import logging
12041: import os
15290: import re
34283: import select
24149: import shutil
14025: import signal
24149: import subprocess
12041: import sys
14025: import threading
36106: import tempfile
46150: import zipfile
50985: import sqlite3
28231: 
39594: SCRIPT_DIR = os.path.abspath(os.path.realpath(os.path.dirname(sys.argv[0])))
39594: sys.path.insert(0, SCRIPT_DIR)
39594: import automationutils
39594: 
39394: _DEFAULT_WEB_SERVER = "127.0.0.1"
39394: _DEFAULT_HTTP_PORT = 8888
39394: _DEFAULT_SSL_PORT = 4443
43727: _DEFAULT_WEBSOCKET_PORT = 9988
12041: 
37238: #expand _DIST_BIN = __XPC_BIN_PATH__
37238: #expand _IS_WIN32 = len("__WIN32__") != 0
37238: #expand _IS_MAC = __IS_MAC__ != 0
37238: #expand _IS_LINUX = __IS_LINUX__ != 0
37238: #ifdef IS_CYGWIN
37238: #expand _IS_CYGWIN = __IS_CYGWIN__ == 1
37238: #else
37238: _IS_CYGWIN = False
37238: #endif
37238: #expand _IS_CAMINO = __IS_CAMINO__ != 0
37238: #expand _BIN_SUFFIX = __BIN_SUFFIX__
37238: #expand _PERL = __PERL__
37161: 
37238: #expand _DEFAULT_APP = "./" + __BROWSER_PATH__
37238: #expand _CERTS_SRC_DIR = __CERTS_SRC_DIR__
37238: #expand _IS_TEST_BUILD = __IS_TEST_BUILD__
37238: #expand _IS_DEBUG_BUILD = __IS_DEBUG_BUILD__
37238: #expand _CRASHREPORTER = __CRASHREPORTER__ == 1
14025: 
39594: 
39594: if _IS_WIN32:
39594:   import ctypes, ctypes.wintypes, time, msvcrt
39594: else:
39594:   import errno
39594: 
39594: 
39606: # We use the logging system here primarily because it'll handle multiple
39606: # threads, which is needed to process the output of the server and application
39606: # processes simultaneously.
39606: _log = logging.getLogger()
39606: handler = logging.StreamHandler(sys.stdout)
39606: _log.setLevel(logging.INFO)
39606: _log.addHandler(handler)
39606: 
39606: 
14025: #################
12041: # PROFILE SETUP #
14025: #################
12041: 
15290: class SyntaxError(Exception):
15290:   "Signifies a syntax error on a particular line in server-locations.txt."
15290: 
15290:   def __init__(self, lineno, msg = None):
15290:     self.lineno = lineno
15290:     self.msg = msg
15290: 
15290:   def __str__(self):
15290:     s = "Syntax error on line " + str(self.lineno)
15290:     if self.msg:
15290:       s += ": %s." % self.msg
15290:     else:
15290:       s += "."
15290:     return s
15290: 
15290: 
15290: class Location:
15290:   "Represents a location line in server-locations.txt."
15290: 
15290:   def __init__(self, scheme, host, port, options):
15290:     self.scheme = scheme
15290:     self.host = host
15290:     self.port = port
15290:     self.options = options
15290: 
37238: class Automation(object):
37238:   """
37238:   Runs the browser from a script, and provides useful utilities
37238:   for setting up the browser environment.
37238:   """
15290: 
37238:   DIST_BIN = _DIST_BIN
37238:   IS_WIN32 = _IS_WIN32
37238:   IS_MAC = _IS_MAC
37238:   IS_LINUX = _IS_LINUX
37238:   IS_CYGWIN = _IS_CYGWIN
37238:   IS_CAMINO = _IS_CAMINO
37238:   BIN_SUFFIX = _BIN_SUFFIX
37238:   PERL = _PERL
37238: 
37238:   UNIXISH = not IS_WIN32 and not IS_MAC
37238: 
37238:   DEFAULT_APP = _DEFAULT_APP
37238:   CERTS_SRC_DIR = _CERTS_SRC_DIR
37238:   IS_TEST_BUILD = _IS_TEST_BUILD
37238:   IS_DEBUG_BUILD = _IS_DEBUG_BUILD
37238:   CRASHREPORTER = _CRASHREPORTER
37238: 
37238:   # timeout, in seconds
37238:   DEFAULT_TIMEOUT = 60.0
39394:   DEFAULT_WEB_SERVER = _DEFAULT_WEB_SERVER
39394:   DEFAULT_HTTP_PORT = _DEFAULT_HTTP_PORT
39394:   DEFAULT_SSL_PORT = _DEFAULT_SSL_PORT
43718:   DEFAULT_WEBSOCKET_PORT = _DEFAULT_WEBSOCKET_PORT
37238: 
37238:   def __init__(self):
39606:     self.log = _log
43493:     self.lastTestSeen = "automation.py"
51227:     self.haveDumpedScreen = False
37238: 
43718:   def setServerInfo(self, 
43718:                     webServer = _DEFAULT_WEB_SERVER, 
43718:                     httpPort = _DEFAULT_HTTP_PORT, 
43718:                     sslPort = _DEFAULT_SSL_PORT,
48302:                     webSocketPort = _DEFAULT_WEBSOCKET_PORT):
39394:     self.webServer = webServer
39364:     self.httpPort = httpPort
39364:     self.sslPort = sslPort
43718:     self.webSocketPort = webSocketPort
39364: 
37238:   @property
37238:   def __all__(self):
37238:     return [
37238:            "UNIXISH",
37238:            "IS_WIN32",
37238:            "IS_MAC",
37238:            "log",
37238:            "runApp",
37238:            "Process",
37238:            "addCommonOptions",
37238:            "initializeProfile",
37238:            "DIST_BIN",
37238:            "DEFAULT_APP",
37238:            "CERTS_SRC_DIR",
37238:            "environment",
37238:            "IS_TEST_BUILD",
37238:            "IS_DEBUG_BUILD",
37238:            "DEFAULT_TIMEOUT",
37238:           ]
37238: 
37238:   class Process(subprocess.Popen):
37238:     """
37238:     Represents our view of a subprocess.
37238:     It adds a kill() method which allows it to be stopped explicitly.
37238:     """
37238: 
39606:     def __init__(self,
39606:                  args,
39606:                  bufsize=0,
39606:                  executable=None,
39606:                  stdin=None,
39606:                  stdout=None,
39606:                  stderr=None,
39606:                  preexec_fn=None,
39606:                  close_fds=False,
39606:                  shell=False,
39606:                  cwd=None,
39606:                  env=None,
39606:                  universal_newlines=False,
39606:                  startupinfo=None,
39606:                  creationflags=0):
39606:       subprocess.Popen.__init__(self, args, bufsize, executable,
39606:                                 stdin, stdout, stderr,
39606:                                 preexec_fn, close_fds,
39606:                                 shell, cwd, env,
39606:                                 universal_newlines, startupinfo, creationflags)
39606:       self.log = _log
39606: 
37238:     def kill(self):
37238:       if Automation().IS_WIN32:
37238:         import platform
37238:         pid = "%i" % self.pid
37238:         if platform.release() == "2000":
37238:           # Windows 2000 needs 'kill.exe' from the 
37238:           #'Windows 2000 Resource Kit tools'. (See bug 475455.)
37238:           try:
37238:             subprocess.Popen(["kill", "-f", pid]).wait()
37238:           except:
37238:             self.log.info("TEST-UNEXPECTED-FAIL | automation.py | Missing 'kill' utility to kill process with pid=%s. Kill it manually!", pid)
37238:         else:
37238:           # Windows XP and later.
37238:           subprocess.Popen(["taskkill", "/F", "/PID", pid]).wait()
37238:       else:
37238:         os.kill(self.pid, signal.SIGKILL)
37238: 
37238:   def readLocations(self, locationsPath = "server-locations.txt"):
15290:     """
15290:     Reads the locations at which the Mochitest HTTP server is available from
15290:     server-locations.txt.
15290:     """
15290: 
18848:     locationFile = codecs.open(locationsPath, "r", "UTF-8")
15290: 
15290:     # Perhaps more detail than necessary, but it's the easiest way to make sure
15290:     # we get exactly the format we want.  See server-locations.txt for the exact
15290:     # format guaranteed here.
15290:     lineRe = re.compile(r"^(?P<scheme>[a-z][-a-z0-9+.]*)"
15290:                       r"://"
15290:                       r"(?P<host>"
15290:                         r"\d+\.\d+\.\d+\.\d+"
15290:                         r"|"
15290:                         r"(?:[a-z0-9](?:[-a-z0-9]*[a-z0-9])?\.)*"
15290:                         r"[a-z](?:[-a-z0-9]*[a-z0-9])?"
15290:                       r")"
15290:                       r":"
15290:                       r"(?P<port>\d+)"
15290:                       r"(?:"
15290:                       r"\s+"
18848:                       r"(?P<options>\S+(?:,\S+)*)"
15290:                       r")?$")
15290:     locations = []
15290:     lineno = 0
15290:     seenPrimary = False
15290:     for line in locationFile:
15290:       lineno += 1
15290:       if line.startswith("#") or line == "\n":
15290:         continue
15290:       
15290:       match = lineRe.match(line)
15290:       if not match:
15290:         raise SyntaxError(lineno)
15290: 
15290:       options = match.group("options")
15290:       if options:
15290:         options = options.split(",")
15290:         if "primary" in options:
15290:           if seenPrimary:
15290:             raise SyntaxError(lineno, "multiple primary locations")
15290:           seenPrimary = True
15290:       else:
15290:         options = []
15290: 
35240:       locations.append(Location(match.group("scheme"), match.group("host"),
35240:                                 match.group("port"), options))
15290: 
15290:     if not seenPrimary:
15290:       raise SyntaxError(lineno + 1, "missing primary location")
15290: 
15290:     return locations
15290: 
50985:   def setupPermissionsDatabase(self, profileDir, permissions):
50985:     # Open database and create table
50985:     permDB = sqlite3.connect(os.path.join(profileDir, "permissions.sqlite"))
50985:     cursor = permDB.cursor();
51164:     # SQL copied from nsPermissionManager.cpp
50985:     cursor.execute("""CREATE TABLE moz_hosts (
50985:        id INTEGER PRIMARY KEY,
50985:        host TEXT,
50985:        type TEXT,
50985:        permission INTEGER,
50985:        expireType INTEGER,
50985:        expireTime INTEGER)""")
50985: 
50985:     # Insert desired permissions
50985:     c = 0
50985:     for perm in permissions.keys():
51988:       for host,allow in permissions[perm]:
50985:         c += 1
51988:         cursor.execute("INSERT INTO moz_hosts values(?, ?, ?, ?, 0, 0)",
51988:                        (c, host, perm, 1 if allow else 2))
50985: 
50985:     # Commit and close
50985:     permDB.commit()
50985:     cursor.close()
50985: 
39364:   def initializeProfile(self, profileDir, extraPrefs = [], useServerLocations = False):
12041:     " Sets up the standard testing profile."
12041: 
39364:     prefs = []
12041:     # Start with a clean slate.
12041:     shutil.rmtree(profileDir, True)
12041:     os.mkdir(profileDir)
12041: 
50985:     # Set up permissions database
50985:     locations = self.readLocations()
50985:     self.setupPermissionsDatabase(profileDir,
51988:       {'allowXULXBL':[(l.host, 'noxul' not in l.options) for l in locations]});
50985: 
12041:     part = """\
12041: user_pref("browser.dom.window.dump.enabled", true);
15122: user_pref("dom.allow_scripts_to_close_windows", true);
12041: user_pref("dom.disable_open_during_load", false);
12041: user_pref("dom.max_script_run_time", 0); // no slow script dialogs
28016: user_pref("dom.max_chrome_script_run_time", 0);
34095: user_pref("dom.popup_maximum", -1);
12041: user_pref("signed.applets.codebase_principal_support", true);
12041: user_pref("security.warn_submit_insecure", false);
12041: user_pref("browser.shell.checkDefaultBrowser", false);
18847: user_pref("shell.checkDefaultClient", false);
12041: user_pref("browser.warnOnQuit", false);
12533: user_pref("accessibility.typeaheadfind.autostart", false);
12572: user_pref("javascript.options.showInConsole", true);
14747: user_pref("layout.debug.enable_data_xbl", true);
14946: user_pref("browser.EULA.override", true);
20389: user_pref("javascript.options.jit.content", true);
19034: user_pref("gfx.color_management.force_srgb", true);
23578: user_pref("network.manage-offline-status", false);
28026: user_pref("test.mousescroll", true);
23756: user_pref("security.default_personal_cert", "Select Automatically"); // Need to client auth test be w/o any dialogs
25455: user_pref("network.http.prompt-temp-redirect", false);
26837: user_pref("media.cache_size", 100);
27070: user_pref("security.warn_viewing_mixed", false);
50355: user_pref("app.update.enabled", false);
43816: 
43816: // Only load extensions from the application and user profile
43816: // AddonManager.SCOPE_PROFILE + AddonManager.SCOPE_APPLICATION
43816: user_pref("extensions.enabledScopes", 5);
14977: 
46184: user_pref("extensions.testpilot.runStudies", false);
46184: 
39364: user_pref("geo.wifi.uri", "http://%(server)s/tests/dom/tests/mochitest/geolocation/network_geolocation.sjs");
31577: user_pref("geo.wifi.testing", true);
51780: user_pref("geo.ignore.location_filter", true);
31577: 
14977: user_pref("camino.warn_when_closing", false); // Camino-only, harmless to others
29285: 
29285: // Make url-classifier updates so rare that they won't affect tests
29285: user_pref("urlclassifier.updateinterval", 172800);
29285: // Point the url-classifier to the local testing server for fast failures
39364: user_pref("browser.safebrowsing.provider.0.gethashURL", "http://%(server)s/safebrowsing-dummy/gethash");
39364: user_pref("browser.safebrowsing.provider.0.keyURL", "http://%(server)s/safebrowsing-dummy/newkey");
39364: user_pref("browser.safebrowsing.provider.0.updateURL", "http://%(server)s/safebrowsing-dummy/update");
39364: """ % { "server" : self.webServer + ":" + str(self.httpPort) }
12041:     prefs.append(part)
12041: 
39364:     if useServerLocations == False:
39364:       part = """
39364: user_pref("capability.principal.codebase.p1.granted",
39364:           "UniversalXPConnect UniversalBrowserRead UniversalBrowserWrite \
39364:            UniversalPreferencesRead UniversalPreferencesWrite \
39364:            UniversalFileRead");
39364: user_pref("capability.principal.codebase.p1.id", "%(origin)s");
39364: user_pref("capability.principal.codebase.p1.subjectName", "");
39364: """  % { "origin": "http://" + self.webServer + ":" + str(self.httpPort) }
39364:       prefs.append(part)
39364:     else:
15290:       # Grant God-power to all the privileged servers on which tests run.
15290:       privileged = filter(lambda loc: "privileged" in loc.options, locations)
15290:       for (i, l) in itertools.izip(itertools.count(1), privileged):
12041:         part = """
12041: user_pref("capability.principal.codebase.p%(i)d.granted",
12041:           "UniversalXPConnect UniversalBrowserRead UniversalBrowserWrite \
12041:            UniversalPreferencesRead UniversalPreferencesWrite \
12041:            UniversalFileRead");
15290: user_pref("capability.principal.codebase.p%(i)d.id", "%(origin)s");
12041: user_pref("capability.principal.codebase.p%(i)d.subjectName", "");
15290: """  % { "i": i,
39394:          "origin": (l.scheme + "://" + l.host + ":" + str(l.port)) }
12041:         prefs.append(part)
12041: 
15290:       # We need to proxy every server but the primary one.
15290:       origins = ["'%s://%s:%s'" % (l.scheme, l.host, l.port)
15290:                 for l in filter(lambda l: "primary" not in l.options, locations)]
15290:       origins = ", ".join(origins)
12041: 
12041:       pacURL = """data:text/plain,
12041: function FindProxyForURL(url, host)
12041: {
35240:   var origins = [%(origins)s];
15290:   var regex = new RegExp('^([a-z][-a-z0-9+.]*)' +
15290:                          '://' +
15290:                          '(?:[^/@]*@)?' +
15290:                          '(.*?)' +
15290:                          '(?::(\\\\\\\\d+))?/');
12041:   var matches = regex.exec(url);
12041:   if (!matches)
12041:     return 'DIRECT';
15290:   var isHttp = matches[1] == 'http';
18848:   var isHttps = matches[1] == 'https';
48366:   var isWebSocket = matches[1] == 'ws';
15290:   if (!matches[3])
18848:   {
48366:     if (isHttp | isWebSocket) matches[3] = '80';
48366:     if (isHttps) matches[3] = '443';
18848:   }
48366:   if (isWebSocket)
43718:     matches[1] = 'http';
18848: 
15290:   var origin = matches[1] + '://' + matches[2] + ':' + matches[3];
15290:   if (origins.indexOf(origin) < 0)
15290:     return 'DIRECT';
15290:   if (isHttp)
39394:     return 'PROXY %(remote)s:%(httpport)s';
48366:   if (isHttps || isWebSocket)
39394:     return 'PROXY %(remote)s:%(sslport)s';
12041:   return 'DIRECT';
39394: }""" % { "origins": origins,
39394:          "remote":  self.webServer,
39394:          "httpport":self.httpPort,
48302:          "sslport": self.sslPort }
12041:       pacURL = "".join(pacURL.splitlines())
12041: 
39364:       part += """
12041: user_pref("network.proxy.type", 2);
12041: user_pref("network.proxy.autoconfig_url", "%(pacURL)s");
14977: 
14977: user_pref("camino.use_system_proxy_settings", false); // Camino-only, harmless to others
12041: """ % {"pacURL": pacURL}
12041:       prefs.append(part)
12041: 
33841:     for v in extraPrefs:
33841:       thispref = v.split("=")
33841:       if len(thispref) < 2:
34188:         print "Error: syntax error in --setpref=" + v
33841:         sys.exit(1)
33841:       part = 'user_pref("%s", %s);\n' % (thispref[0], thispref[1])
33841:       prefs.append(part)
33841: 
12041:     # write the preferences
12041:     prefsFile = open(profileDir + "/" + "user.js", "a")
12041:     prefsFile.write("".join(prefs))
12041:     prefsFile.close()
12041: 
37238:   def addCommonOptions(self, parser):
34783:     "Adds command-line options which are common to mochitest and reftest."
34783: 
34783:     parser.add_option("--setpref",
34783:                       action = "append", type = "string",
34783:                       default = [],
34783:                       dest = "extraPrefs", metavar = "PREF=VALUE",
34783:                       help = "defines an extra user preference")  
34783: 
37238:   def fillCertificateDB(self, profileDir, certPath, utilityPath, xrePath):
18848:     pwfilePath = os.path.join(profileDir, ".crtdbpw")
18848:   
18848:     pwfile = open(pwfilePath, "w")
18848:     pwfile.write("\n")
18848:     pwfile.close()
18848: 
18848:     # Create head of the ssltunnel configuration file
24791:     sslTunnelConfigPath = os.path.join(profileDir, "ssltunnel.cfg")
18848:     sslTunnelConfig = open(sslTunnelConfigPath, "w")
18848:   
18848:     sslTunnelConfig.write("httpproxy:1\n")
24791:     sslTunnelConfig.write("certdbdir:%s\n" % certPath)
39394:     sslTunnelConfig.write("forward:127.0.0.1:%s\n" % self.httpPort)
48302:     sslTunnelConfig.write("websocketserver:%s:%s\n" % (self.webServer, self.webSocketPort))
39394:     sslTunnelConfig.write("listen:*:%s:pgo server certificate\n" % self.sslPort)
18848: 
23756:     # Configure automatic certificate and bind custom certificates, client authentication
37238:     locations = self.readLocations()
18848:     locations.pop(0)
18848:     for loc in locations:
18848:       if loc.scheme == "https" and "nocert" not in loc.options:
18848:         customCertRE = re.compile("^cert=(?P<nickname>[0-9a-zA-Z_ ]+)")
23756:         clientAuthRE = re.compile("^clientauth=(?P<clientauth>[a-z]+)")
18848:         for option in loc.options:
18848:           match = customCertRE.match(option)
18848:           if match:
18848:             customcert = match.group("nickname");
39394:             sslTunnelConfig.write("listen:%s:%s:%s:%s\n" %
39394:                       (loc.host, loc.port, self.sslPort, customcert))
23756: 
23756:           match = clientAuthRE.match(option)
23756:           if match:
23756:             clientauth = match.group("clientauth");
39394:             sslTunnelConfig.write("clientauth:%s:%s:%s:%s\n" %
39394:                       (loc.host, loc.port, self.sslPort, clientauth))
18848: 
18848:     sslTunnelConfig.close()
18848: 
18848:     # Pre-create the certification database for the profile
37238:     env = self.environment(xrePath = xrePath)
37238:     certutil = os.path.join(utilityPath, "certutil" + self.BIN_SUFFIX)
37238:     pk12util = os.path.join(utilityPath, "pk12util" + self.BIN_SUFFIX)
23756: 
37238:     status = self.Process([certutil, "-N", "-d", profileDir, "-f", pwfilePath], env = env).wait()
18848:     if status != 0:
18848:       return status
18848: 
23756:     # Walk the cert directory and add custom CAs and client certs
24791:     files = os.listdir(certPath)
18848:     for item in files:
18848:       root, ext = os.path.splitext(item)
18848:       if ext == ".ca":
24210:         trustBits = "CT,,"
24210:         if root.endswith("-object"):
24210:           trustBits = "CT,,CT"
37238:         self.Process([certutil, "-A", "-i", os.path.join(certPath, item),
24210:                     "-d", profileDir, "-f", pwfilePath, "-n", root, "-t", trustBits],
24791:                     env = env).wait()
23756:       if ext == ".client":
37238:         self.Process([pk12util, "-i", os.path.join(certPath, item), "-w",
23907:                     pwfilePath, "-d", profileDir], 
24791:                     env = env).wait()
18848: 
18848:     os.unlink(pwfilePath)
18848:     return 0
18848: 
37238:   def environment(self, env = None, xrePath = None, crashreporter = True):
37238:     if xrePath == None:
37238:       xrePath = self.DIST_BIN
18848:     if env == None:
18848:       env = dict(os.environ)
18848: 
39594:     ldLibraryPath = os.path.abspath(os.path.join(SCRIPT_DIR, xrePath))
37238:     if self.UNIXISH or self.IS_MAC:
24791:       envVar = "LD_LIBRARY_PATH"
37238:       if self.IS_MAC:
24791:         envVar = "DYLD_LIBRARY_PATH"
33678:       else: # unixish
33678:         env['MOZILLA_FIVE_HOME'] = xrePath
24791:       if envVar in env:
24791:         ldLibraryPath = ldLibraryPath + ":" + env[envVar]
24791:       env[envVar] = ldLibraryPath
37238:     elif self.IS_WIN32:
24791:       env["PATH"] = env["PATH"] + ";" + ldLibraryPath
18848: 
31181:     if crashreporter:
25988:       env['MOZ_CRASHREPORTER_NO_REPORT'] = '1'
25988:       env['MOZ_CRASHREPORTER'] = '1'
34936:     else:
34936:       env['MOZ_CRASHREPORTER_DISABLE'] = '1'
34936: 
37238:     env['GNOME_DISABLE_CRASH_DIALOG'] = '1'
36964:     env['XRE_NO_WINDOWS_CRASH_DIALOG'] = '1'
18848:     return env
12041: 
34283:   if IS_WIN32:
34283:     PeekNamedPipe = ctypes.windll.kernel32.PeekNamedPipe
34283:     GetLastError = ctypes.windll.kernel32.GetLastError
36106: 
37238:     def readWithTimeout(self, f, timeout):
34283:       """Try to read a line of output from the file object |f|.
34283:       |f| must be a  pipe, like the |stdout| member of a subprocess.Popen
34283:       object created with stdout=PIPE. If no output
34283:       is received within |timeout| seconds, return a blank line.
34283:       Returns a tuple (line, did_timeout), where |did_timeout| is True
34283:       if the read timed out, and False otherwise."""
35004:       if timeout is None:
35004:         # shortcut to allow callers to pass in "None" for no timeout.
35004:         return (f.readline(), False)
39594:       x = msvcrt.get_osfhandle(f.fileno())
39594:       l = ctypes.c_long()
39594:       done = time.time() + timeout
39594:       while time.time() < done:
39594:         if self.PeekNamedPipe(x, None, 0, None, ctypes.byref(l), None) == 0:
37238:           err = self.GetLastError()
34283:           if err == 38 or err == 109: # ERROR_HANDLE_EOF || ERROR_BROKEN_PIPE
34283:             return ('', False)
35004:           else:
35004:             log.error("readWithTimeout got error: %d", err)
37492:         if l.value > 0:
35004:           # we're assuming that the output is line-buffered,
35004:           # which is not unreasonable
34283:           return (f.readline(), False)
39594:         time.sleep(0.01)
34283:       return ('', True)
36106: 
37238:     def isPidAlive(self, pid):
36106:       STILL_ACTIVE = 259
36106:       PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
39594:       pHandle = ctypes.windll.kernel32.OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, 0, pid)
36106:       if not pHandle:
36106:         return False
37552:       pExitCode = ctypes.wintypes.DWORD()
46265:       ctypes.windll.kernel32.GetExitCodeProcess(pHandle, ctypes.byref(pExitCode))
39594:       ctypes.windll.kernel32.CloseHandle(pHandle)
36106:       if (pExitCode.value == STILL_ACTIVE):
36106:         return True
34283:       else:
36106:         return False
36106: 
37238:     def killPid(self, pid):
36106:       PROCESS_TERMINATE = 0x0001
39594:       pHandle = ctypes.windll.kernel32.OpenProcess(PROCESS_TERMINATE, 0, pid)
36106:       if not pHandle:
36106:         return
39594:       success = ctypes.windll.kernel32.TerminateProcess(pHandle, 1)
39594:       ctypes.windll.kernel32.CloseHandle(pHandle)
36106: 
36106:   else:
36106: 
37238:     def readWithTimeout(self, f, timeout):
34283:       """Try to read a line of output from the file object |f|. If no output
34283:       is received within |timeout| seconds, return a blank line.
34283:       Returns a tuple (line, did_timeout), where |did_timeout| is True
34283:       if the read timed out, and False otherwise."""
34283:       (r, w, e) = select.select([f], [], [], timeout)
34283:       if len(r) == 0:
34283:         return ('', True)
34283:       return (f.readline(), False)
25988: 
37238:     def isPidAlive(self, pid):
36106:       try:
36106:         # kill(pid, 0) checks for a valid PID without actually sending a signal
36106:         # The method throws OSError if the PID is invalid, which we catch below.
36106:         os.kill(pid, 0)
36106: 
36278:         # Wait on it to see if it's a zombie. This can throw OSError.ECHILD if
36278:         # the process terminates before we get to this point.
36106:         wpid, wstatus = os.waitpid(pid, os.WNOHANG)
36106:         if wpid == 0:
36106:           return True
36106: 
36106:         return False
36106:       except OSError, err:
36278:         # Catch the errors we might expect from os.kill/os.waitpid, 
36278:         # and re-raise any others
39594:         if err.errno == errno.ESRCH or err.errno == errno.ECHILD:
36106:           return False
36106:         raise
36106: 
37238:     def killPid(self, pid):
36106:       os.kill(pid, signal.SIGKILL)
36106: 
51227:   if UNIXISH:
51227:     def dumpScreen(self, utilityPath):
51227:       self.haveDumpedScreen = True;
51227: 
51227:       screentopng = os.path.join(utilityPath, "screentopng")
51227:       try:
51227:         dumper = self.Process([screentopng], bufsize=-1,
51227:                               stdout=subprocess.PIPE, close_fds=True)
51227:       except OSError, err:
51227:         self.log.info("Failed to start %s for screenshot: %s",
51227:                       screentopng, err.strerror)
51227:         return
51227: 
51227:       image = dumper.stdout.read()
51227:       status = dumper.wait()
51227:       if status != 0:
51227:         self.log.info("screentopng exited with code %d", status)
51227:         return
51227: 
51227:       import base64
51227:       encoded = base64.b64encode(image)
51227:       self.log.info("SCREENSHOT: data:image/png;base64,%s", encoded)
51227: 
39680:   def killAndGetStack(self, proc, utilityPath, debuggerInfo):
39680:     """Kill the process, preferrably in a way that gets us a stack trace."""
51227:     if self.UNIXISH and not debuggerInfo and not self.haveDumpedScreen:
51227:       self.dumpScreen(utilityPath)
51227: 
39680:     if self.CRASHREPORTER and not debuggerInfo:
37238:       if self.UNIXISH:
38718:         # ABRT will get picked up by Breakpad's signal handler
38718:         os.kill(proc.pid, signal.SIGABRT)
34284:         return
37238:       elif self.IS_WIN32:
34284:         # We should have a "crashinject" program in our utility path
34284:         crashinject = os.path.normpath(os.path.join(utilityPath, "crashinject.exe"))
34284:         if os.path.exists(crashinject) and subprocess.Popen([crashinject, str(proc.pid)]).wait() == 0:
34284:           return
35004:       #TODO: kill the process such that it triggers Breakpad on OS X (bug 525296)
37238:     self.log.info("Can't trigger Breakpad, just killing process")
34284:     proc.kill()
34284: 
46248:   def waitForFinish(self, proc, utilityPath, timeout, maxTime, startTime, debuggerInfo, symbolsPath):
37323:     """ Look for timeout or crashes and return the status after the process terminates """
37323:     stackFixerProcess = None
46248:     stackFixerFunction = None
37323:     didTimeout = False
37323:     if proc.stdout is None:
37323:       self.log.info("TEST-INFO: Not logging stdout or stderr due to debugger connection")
37323:     else:
37323:       logsource = proc.stdout
46248: 
46248:       if self.IS_DEBUG_BUILD and (self.IS_MAC or self.IS_LINUX) and symbolsPath and os.path.exists(symbolsPath):
46248:         # Run each line through a function in fix_stack_using_bpsyms.py (uses breakpad symbol files)
46248:         # This method is preferred for Tinderbox builds, since native symbols may have been stripped.
46248:         sys.path.insert(0, utilityPath)
46248:         import fix_stack_using_bpsyms as stackFixerModule
46248:         stackFixerFunction = lambda line: stackFixerModule.fixSymbols(line, symbolsPath)
46248:         del sys.path[0]
46248:       elif self.IS_DEBUG_BUILD and self.IS_MAC and False:
46248:         # Run each line through a function in fix_macosx_stack.py (uses atos)
46248:         sys.path.insert(0, utilityPath)
46248:         import fix_macosx_stack as stackFixerModule
46248:         stackFixerFunction = lambda line: stackFixerModule.fixSymbols(line)
46248:         del sys.path[0]
46248:       elif self.IS_DEBUG_BUILD and self.IS_LINUX:
46248:         # Run logsource through fix-linux-stack.pl (uses addr2line)
46248:         # This method is preferred for developer machines, so we don't have to run "make buildsymbols".
38373:         stackFixerProcess = self.Process([self.PERL, os.path.join(utilityPath, "fix-linux-stack.pl")],
37323:                                          stdin=logsource,
37323:                                          stdout=subprocess.PIPE)
37323:         logsource = stackFixerProcess.stdout
37323: 
37323:       (line, didTimeout) = self.readWithTimeout(logsource, timeout)
37323:       hitMaxTime = False
37323:       while line != "" and not didTimeout:
43493:         if "TEST-START" in line and "|" in line:
43493:           self.lastTestSeen = line.split("|")[1].strip()
46248:         if stackFixerFunction:
46248:           line = stackFixerFunction(line)
37323:         self.log.info(line.rstrip())
51227:         if self.UNIXISH and not debuggerInfo and not self.haveDumpedScreen and "TEST-UNEXPECTED-FAIL" in line and "Test timed out." in line:
51227:           self.dumpScreen(utilityPath)
51227: 
37323:         (line, didTimeout) = self.readWithTimeout(logsource, timeout)
37323:         if not hitMaxTime and maxTime and datetime.now() - startTime > timedelta(seconds = maxTime):
37323:           # Kill the application, but continue reading from stack fixer so as not to deadlock on stackFixerProcess.wait().
37323:           hitMaxTime = True
43493:           self.log.info("TEST-UNEXPECTED-FAIL | %s | application ran for longer than allowed maximum time of %d seconds", self.lastTestSeen, int(maxTime))
39680:           self.killAndGetStack(proc, utilityPath, debuggerInfo)
37323:       if didTimeout:
43493:         self.log.info("TEST-UNEXPECTED-FAIL | %s | application timed out after %d seconds with no output", self.lastTestSeen, int(timeout))
39680:         self.killAndGetStack(proc, utilityPath, debuggerInfo)
37323: 
37323:     status = proc.wait()
43493:     if status == 0:
43493:       self.lastTestSeen = "Main app process exited normally"
37323:     if status != 0 and not didTimeout and not hitMaxTime:
43493:       self.log.info("TEST-UNEXPECTED-FAIL | %s | Exited with code %d during test run", self.lastTestSeen, status)
37323:     if stackFixerProcess is not None:
37323:       fixerStatus = stackFixerProcess.wait()
37323:       if fixerStatus != 0 and not didTimeout and not hitMaxTime:
37323:         self.log.info("TEST-UNEXPECTED-FAIL | automation.py | Stack fixer process exited with code %d during test run", fixerStatus)
37323:     return status
37323: 
37323:   def buildCommandLine(self, app, debuggerInfo, profileDir, testURL, extraArgs):
37323:     """ build the application command line """
37323: 
37323:     cmd = app
37323:     if self.IS_MAC and not self.IS_CAMINO and not cmd.endswith("-bin"):
37323:       cmd += "-bin"
37323:     cmd = os.path.abspath(cmd)
37323: 
37323:     args = []
37323: 
37323:     if debuggerInfo:
37323:       args.extend(debuggerInfo["args"])
37323:       args.append(cmd)
37323:       cmd = os.path.abspath(debuggerInfo["path"])
37323: 
37323:     if self.IS_MAC:
37323:       args.append("-foreground")
37323: 
37323:     if self.IS_CYGWIN:
37323:       profileDirectory = commands.getoutput("cygpath -w \"" + profileDir + "/\"")
37323:     else:
37323:       profileDirectory = profileDir + "/"
37323: 
37323:     args.extend(("-no-remote", "-profile", profileDirectory))
37323:     if testURL is not None:
37323:       if self.IS_CAMINO:
37323:         args.extend(("-url", testURL))
37323:       else:
37323:         args.append((testURL))
37323:     args.extend(extraArgs)
37323:     return cmd, args
37323: 
37323:   def checkForZombies(self, processLog):
37323:     """ Look for hung processes """
37323:     if not os.path.exists(processLog):
37323:       self.log.info('INFO | automation.py | PID log not found: %s', processLog)
37323:     else:
37323:       self.log.info('INFO | automation.py | Reading PID log: %s', processLog)
37323:       processList = []
37323:       pidRE = re.compile(r'launched child process (\d+)$')
37323:       processLogFD = open(processLog)
37323:       for line in processLogFD:
37323:         self.log.info(line.rstrip())
37323:         m = pidRE.search(line)
37323:         if m:
37323:           processList.append(int(m.group(1)))
37323:       processLogFD.close()
37323: 
37323:       for processPID in processList:
37323:         self.log.info("INFO | automation.py | Checking for orphan process with PID: %d", processPID)
37323:         if self.isPidAlive(processPID):
37323:           self.log.info("TEST-UNEXPECTED-FAIL | automation.py | child process %d still alive after shutdown", processPID)
37323:           self.killPid(processPID)
37323: 
37238:   def runApp(self, testURL, env, app, profileDir, extraArgs,
37238:              runSSLTunnel = False, utilityPath = None,
37238:              xrePath = None, certPath = None,
36885:              debuggerInfo = None, symbolsPath = None,
37238:              timeout = -1, maxTime = None):
36897:     """
36897:     Run the app, log the duration it took to execute, return the status code.
36897:     Kills the app if it runs for longer than |maxTime| seconds, or outputs nothing for |timeout| seconds.
36897:     """
12041: 
37238:     if utilityPath == None:
37238:       utilityPath = self.DIST_BIN
37238:     if xrePath == None:
37238:       xrePath = self.DIST_BIN
37238:     if certPath == None:
37238:       certPath = self.CERTS_SRC_DIR
37238:     if timeout == -1:
37238:       timeout = self.DEFAULT_TIMEOUT
37238: 
33054:     # copy env so we don't munge the caller's environment
33054:     env = dict(env);
33678:     env["NO_EM_RESTART"] = "1"
36106:     tmpfd, processLog = tempfile.mkstemp(suffix='pidlog')
36106:     os.close(tmpfd)
36106:     env["MOZ_PROCESS_LOG"] = processLog
33054: 
37238:     if self.IS_TEST_BUILD and runSSLTunnel:
18848:       # create certificate database for the profile
37238:       certificateStatus = self.fillCertificateDB(profileDir, certPath, utilityPath, xrePath)
18848:       if certificateStatus != 0:
37238:         self.log.info("TEST-UNEXPECTED FAIL | automation.py | Certificate integration failed")
18848:         return certificateStatus
18848: 
19851:       # start ssltunnel to provide https:// URLs capability
37238:       ssltunnel = os.path.join(utilityPath, "ssltunnel" + self.BIN_SUFFIX)
37238:       ssltunnelProcess = self.Process([ssltunnel, 
37238:                                os.path.join(profileDir, "ssltunnel.cfg")], 
37238:                                env = self.environment(xrePath = xrePath))
37238:       self.log.info("INFO | automation.py | SSL tunnel pid: %d", ssltunnelProcess.pid)
12041: 
37323:     cmd, args = self.buildCommandLine(app, debuggerInfo, profileDir, testURL, extraArgs)
25783:     startTime = datetime.now()
25819: 
25819:     if debuggerInfo and debuggerInfo["interactive"]:
39680:       # If an interactive debugger is attached, don't redirect output
39680:       # and don't use timeouts.
39680:       timeout = None
39680:       maxTime = None
25819:       outputPipe = None
25819:     else:
25819:       outputPipe = subprocess.PIPE
25819: 
43496:     self.lastTestSeen = "automation.py"
37238:     proc = self.Process([cmd] + args,
37238:                  env = self.environment(env, xrePath = xrePath,
31181:                                    crashreporter = not debuggerInfo),
31181:                  stdout = outputPipe,
31181:                  stderr = subprocess.STDOUT)
37238:     self.log.info("INFO | automation.py | Application pid: %d", proc.pid)
25819: 
46248:     status = self.waitForFinish(proc, utilityPath, timeout, maxTime, startTime, debuggerInfo, symbolsPath)
37238:     self.log.info("INFO | automation.py | Application ran for: %s", str(datetime.now() - startTime))
12041: 
36106:     # Do a final check for zombie child processes.
37323:     self.checkForZombies(processLog)
43493:     automationutils.checkForCrashes(os.path.join(profileDir, "minidumps"), symbolsPath, self.lastTestSeen)
25988: 
36576:     if os.path.exists(processLog):
36576:       os.unlink(processLog)
36576: 
37238:     if self.IS_TEST_BUILD and runSSLTunnel:
18848:       ssltunnelProcess.kill()
18848: 
25783:     return status
46150: 
46150:   """ 
46150:    Copies an "installed" extension into the extensions directory of the given profile
46150:    extensionSource - the source location of the extension files.  This can be either 
46150:                      a directory or a path to an xpi file.
46150:    profileDir      - the profile directory we are copying into.  We will create the
46150:                      "extensions" directory there if it doesn't exist
46150:    extensionID     - the id of the extension to be used as the containing directory for the
46150:                      extension, i.e.
46150:                  this is the name of the folder in the <profileDir>/extensions/<extensionID>
46150:   """
46150:   def installExtension(self, extensionSource, profileDir, extensionID):
46150:     if (not os.path.exists(extensionSource)):
46150:       self.log.info("INFO | automation.py | Cannot install extension no source at: %s", extensionSource) 
46150:       
46150:     if (not os.path.exists(profileDir)):
46150:       self.log.info("INFO | automation.py | Cannot install extension invalid profileDir at: %s", profileDir)
46150: 
46150:     # See if we have an XPI or a directory
46150:     if (os.path.isfile(extensionSource)):
46150:       tmpd = tempfile.mkdtemp()
46150:       extrootdir = self.extractZip(extensionSource, tmpd)
46150:     else:
46150:       extrootdir = extensionSource 
46150:     extnsdir = os.path.join(profileDir, "extensions")
46150:     extnshome = os.path.join(extnsdir, extensionID)
46150: 
46150:     # Now we copy the extension source into the extnshome
46150:     shutil.copytree(extrootdir, extnshome)
46150: 
46150:   def extractZip(self, filename, dest):
46150:     z = zipfile.ZipFile(filename, 'r')
46150:     for n in z.namelist():
46150:       fullpath = os.path.join(dest, n)
46150:       parentdir = os.path.dirname(fullpath)
46150:       if not os.path.isdir(parentdir):
46150:         os.makedirs(parentdir)
46150:       if (not n.endswith(os.sep)):
46150:         data = z.read(n)
46150:         f = open(fullpath, 'w')
46150:         f.write(data)
46150:         f.close()
46150:     z.close()
46150:     return dest
46150: 
