    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla SVG project.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Crocodile Clips Ltd..
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Alex Fritze <alex.fritze@crocodile-clips.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef __NS_SVGELEMENT_H__
    1: #define __NS_SVGELEMENT_H__
    1: 
    1: /*
    1:   nsSVGElement is the base class for all SVG content elements.
    1:   It implements all the common DOM interfaces and handles attributes.
    1: */
    1: 
    1: #include "nsString.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIDOMSVGElement.h"
    1: #include "nsGenericElement.h"
 4306: #include "nsStyledElement.h"
    1: #include "nsISVGValue.h"
    1: #include "nsISVGValueObserver.h"
    1: #include "nsWeakReference.h"
    1: 
23697: #ifdef MOZ_SMIL
23697: #include "nsISMILAttr.h"
23697: #include "nsSMILAnimationController.h"
23697: #endif
23697: 
    1: class nsSVGSVGElement;
    1: class nsSVGLength2;
    1: class nsSVGNumber2;
 6045: class nsSVGInteger;
 6788: class nsSVGAngle;
 6325: class nsSVGBoolean;
 5347: class nsSVGEnum;
 5347: struct nsSVGEnumMapping;
24554: class nsSVGViewBox;
15353: class nsSVGString;
64109: class nsSVGClass;
43120: struct gfxMatrix;
47840: namespace mozilla {
58554: class SVGAnimatedNumberList;
58554: class SVGNumberList;
47840: class SVGAnimatedLengthList;
47840: class SVGUserUnitList;
58893: class SVGAnimatedPointList;
57113: class SVGAnimatedPathSegList;
59469: class SVGAnimatedPreserveAspectRatio;
47840: }
47840: 
67659: typedef nsStyledElementNotElementCSSInlineStyle nsSVGElementBase;
 4306: 
 4306: class nsSVGElement : public nsSVGElementBase,    // nsIContent
    1:                      public nsISVGValueObserver  // :nsISupportsWeakReference
    1: {
    1: protected:
48124:   nsSVGElement(already_AddRefed<nsINodeInfo> aNodeInfo);
    1:   nsresult Init();
    1:   virtual ~nsSVGElement();
    1: 
    1: public:
58554:   typedef mozilla::SVGNumberList SVGNumberList;
58554:   typedef mozilla::SVGAnimatedNumberList SVGAnimatedNumberList;
57113:   typedef mozilla::SVGUserUnitList SVGUserUnitList;
57113:   typedef mozilla::SVGAnimatedLengthList SVGAnimatedLengthList;
58893:   typedef mozilla::SVGAnimatedPointList SVGAnimatedPointList;
57113:   typedef mozilla::SVGAnimatedPathSegList SVGAnimatedPathSegList;
59470:   typedef mozilla::SVGAnimatedPreserveAspectRatio SVGAnimatedPreserveAspectRatio;
57113: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   // nsIContent interface methods
    1: 
 9755:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
 9755:                               nsIContent* aBindingParent,
 9755:                               PRBool aCompileEventHandlers);
 9755: 
    1:   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
    1:                              PRBool aNotify);
    1: 
16389:   virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,
16389:                                               PRInt32 aModType) const;
16389: 
    1:   virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
    1: 
    1:   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker);
    1: 
    1:   static const MappedAttributeEntry sFillStrokeMap[];
    1:   static const MappedAttributeEntry sGraphicsMap[];
    1:   static const MappedAttributeEntry sTextContentElementsMap[];
    1:   static const MappedAttributeEntry sFontSpecificationMap[];
    1:   static const MappedAttributeEntry sGradientStopMap[];
    1:   static const MappedAttributeEntry sViewportsMap[];
    1:   static const MappedAttributeEntry sMarkersMap[];
    1:   static const MappedAttributeEntry sColorMap[];
    1:   static const MappedAttributeEntry sFiltersMap[];
    1:   static const MappedAttributeEntry sFEFloodMap[];
 4029:   static const MappedAttributeEntry sLightingEffectsMap[];
    1: 
    1:   // nsIDOMNode
 4306:   NS_IMETHOD IsSupported(const nsAString& aFeature, const nsAString& aVersion,
 4306:                          PRBool* aReturn);
    1:   
    1:   // nsIDOMSVGElement
    1:   NS_IMETHOD GetId(nsAString & aId);
    1:   NS_IMETHOD SetId(const nsAString & aId);
    1:   NS_IMETHOD GetOwnerSVGElement(nsIDOMSVGSVGElement** aOwnerSVGElement);
    1:   NS_IMETHOD GetViewportElement(nsIDOMSVGElement** aViewportElement);
    1: 
    1:   // nsISVGValueObserver
    1:   NS_IMETHOD WillModifySVGObservable(nsISVGValue* observable,
    1:                                      nsISVGValue::modificationType aModType);
    1:   NS_IMETHOD DidModifySVGObservable (nsISVGValue* observable,
    1:                                      nsISVGValue::modificationType aModType);
    1: 
    1:   // nsISupportsWeakReference
    1:   // implementation inherited from nsSupportsWeakReference
    1: 
10681:   // Gets the element that establishes the rectangular viewport against which
10681:   // we should resolve percentage lengths (our "coordinate context"). Returns
25598:   // nsnull for outer <svg> or SVG without an <svg> parent (invalid SVG).
25598:   nsSVGSVGElement* GetCtx();
    1: 
27899:   /**
27899:    * Returns aMatrix post-multiplied by the transform from the userspace
27899:    * established by this element to the userspace established by its parent.
27899:    */
27899:   virtual gfxMatrix PrependLocalTransformTo(const gfxMatrix &aMatrix);
27899: 
41504:   // Setter for to set the current <animateMotion> transformation
41504:   // Only visible for nsSVGGraphicElement, so it's a no-op here, and that
41504:   // subclass has the useful implementation.
41504:   virtual void SetAnimateMotionTransform(const gfxMatrix* aMatrix) {/*no-op*/}
41504: 
55139:   PRBool IsStringAnimatable(PRUint8 aAttrEnum) {
55139:     return GetStringInfo().mStringInfo[aAttrEnum].mIsAnimatable;
55139:   }
58640:   PRBool NumberAttrAllowsPercentage(PRUint8 aAttrEnum) {
58640:     return GetNumberInfo().mNumberInfo[aAttrEnum].mPercentagesAllowed;
58640:   }
    1:   virtual void DidChangeLength(PRUint8 aAttrEnum, PRBool aDoSetAttr);
    1:   virtual void DidChangeNumber(PRUint8 aAttrEnum, PRBool aDoSetAttr);
 6045:   virtual void DidChangeInteger(PRUint8 aAttrEnum, PRBool aDoSetAttr);
 6788:   virtual void DidChangeAngle(PRUint8 aAttrEnum, PRBool aDoSetAttr);
 6325:   virtual void DidChangeBoolean(PRUint8 aAttrEnum, PRBool aDoSetAttr);
 5347:   virtual void DidChangeEnum(PRUint8 aAttrEnum, PRBool aDoSetAttr);
24554:   virtual void DidChangeViewBox(PRBool aDoSetAttr);
23313:   virtual void DidChangePreserveAspectRatio(PRBool aDoSetAttr);
58554:   virtual void DidChangeNumberList(PRUint8 aAttrEnum, PRBool aDoSetAttr);
47840:   virtual void DidChangeLengthList(PRUint8 aAttrEnum, PRBool aDoSetAttr);
58893:   virtual void DidChangePointList(PRBool aDoSetAttr);
57113:   virtual void DidChangePathSegList(PRBool aDoSetAttr);
24028:   virtual void DidChangeString(PRUint8 aAttrEnum) {}
    1: 
37222:   virtual void DidAnimateLength(PRUint8 aAttrEnum);
37220:   virtual void DidAnimateNumber(PRUint8 aAttrEnum);
38297:   virtual void DidAnimateInteger(PRUint8 aAttrEnum);
38295:   virtual void DidAnimateAngle(PRUint8 aAttrEnum);
37456:   virtual void DidAnimateBoolean(PRUint8 aAttrEnum);
37442:   virtual void DidAnimateEnum(PRUint8 aAttrEnum);
38296:   virtual void DidAnimateViewBox();
37974:   virtual void DidAnimatePreserveAspectRatio();
58554:   virtual void DidAnimateNumberList(PRUint8 aAttrEnum);
47840:   virtual void DidAnimateLengthList(PRUint8 aAttrEnum);
58893:   virtual void DidAnimatePointList();
57113:   virtual void DidAnimatePathSegList();
38843:   virtual void DidAnimateTransform();
55139:   virtual void DidAnimateString(PRUint8 aAttrEnum);
64109:   virtual void DidAnimateClass();
23697: 
    1:   void GetAnimatedLengthValues(float *aFirst, ...);
    1:   void GetAnimatedNumberValues(float *aFirst, ...);
 6045:   void GetAnimatedIntegerValues(PRInt32 *aFirst, ...);
58554:   SVGAnimatedNumberList* GetAnimatedNumberList(PRUint8 aAttrEnum);
58554:   SVGAnimatedNumberList* GetAnimatedNumberList(nsIAtom *aAttrName);
57113:   void GetAnimatedLengthListValues(SVGUserUnitList *aFirst, ...);
57113:   SVGAnimatedLengthList* GetAnimatedLengthList(PRUint8 aAttrEnum);
58893:   virtual SVGAnimatedPointList* GetAnimatedPointList() {
58893:     return nsnull;
58893:   }
57113:   virtual SVGAnimatedPathSegList* GetAnimPathSegList() {
57113:     // DOM interface 'SVGAnimatedPathData' (*inherited* by nsSVGPathElement)
57113:     // has a member called 'animatedPathSegList' member, so we have a shorter
57113:     // name so we don't get hidden by the GetAnimatedPathSegList declared by
57113:     // NS_DECL_NSIDOMSVGANIMATEDPATHDATA.
57113:     return nsnull;
57113:   }
    1: 
23697: #ifdef MOZ_SMIL
55139:   virtual nsISMILAttr* GetAnimatedAttr(PRInt32 aNamespaceID, nsIAtom* aName);
24029:   void AnimationNeedsResample();
24029:   void FlushAnimations();
57113: #else
57113:   void AnimationNeedsResample() { /* do nothing */ }
57113:   void FlushAnimations() { /* do nothing */ }
23697: #endif
23697: 
    1:   virtual void RecompileScriptEventListeners();
    1: 
24028:   void GetStringBaseValue(PRUint8 aAttrEnum, nsAString& aResult) const;
24028:   void SetStringBaseValue(PRUint8 aAttrEnum, const nsAString& aValue);
24028: 
58893:   virtual nsIAtom* GetPointListAttrName() const {
58893:     return nsnull;
58893:   }
57113:   virtual nsIAtom* GetPathDataAttrName() const {
57113:     return nsnull;
57113:   }
57113: 
    1: protected:
    1:   virtual nsresult AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                                 const nsAString* aValue, PRBool aNotify);
    1:   virtual PRBool ParseAttribute(PRInt32 aNamespaceID, nsIAtom* aAttribute,
    1:                                 const nsAString& aValue, nsAttrValue& aResult);
23697:   static nsresult ReportAttributeParseFailure(nsIDocument* aDocument,
23697:                                               nsIAtom* aAttribute,
23697:                                               const nsAString& aValue);
    1: 
    1:   // Hooks for subclasses
    1:   virtual PRBool IsEventName(nsIAtom* aName);
    1: 
    1:   void UpdateContentStyleRule();
39488: #ifdef MOZ_SMIL
39488:   void UpdateAnimatedContentStyleRule();
63693:   mozilla::css::StyleRule* GetAnimatedContentStyleRule();
39488: #endif // MOZ_SMIL
39488: 
    1:   nsISVGValue* GetMappedAttribute(PRInt32 aNamespaceID, nsIAtom* aName);
    1:   nsresult AddMappedSVGValue(nsIAtom* aName, nsISupports* aValue,
    1:                              PRInt32 aNamespaceID = kNameSpaceID_None);
    1:   
    1:   static nsIAtom* GetEventNameForAttr(nsIAtom* aAttr);
    1: 
    1:   struct LengthInfo {
    1:     nsIAtom** mName;
    1:     float     mDefaultValue;
 6788:     PRUint8   mDefaultUnitType;
    1:     PRUint8   mCtxType;
    1:   };
    1: 
    1:   struct LengthAttributesInfo {
    1:     nsSVGLength2* mLengths;
    1:     LengthInfo*   mLengthInfo;
    1:     PRUint32      mLengthCount;
    1: 
    1:     LengthAttributesInfo(nsSVGLength2 *aLengths,
    1:                          LengthInfo *aLengthInfo,
    1:                          PRUint32 aLengthCount) :
    1:       mLengths(aLengths), mLengthInfo(aLengthInfo), mLengthCount(aLengthCount)
    1:       {}
 8288: 
 8288:     void Reset(PRUint8 aAttrEnum);
    1:   };
    1: 
    1:   struct NumberInfo {
    1:     nsIAtom** mName;
    1:     float     mDefaultValue;
58640:     PRPackedBool mPercentagesAllowed;
    1:   };
    1: 
    1:   struct NumberAttributesInfo {
    1:     nsSVGNumber2* mNumbers;
    1:     NumberInfo*   mNumberInfo;
    1:     PRUint32      mNumberCount;
    1: 
    1:     NumberAttributesInfo(nsSVGNumber2 *aNumbers,
    1:                          NumberInfo *aNumberInfo,
    1:                          PRUint32 aNumberCount) :
    1:       mNumbers(aNumbers), mNumberInfo(aNumberInfo), mNumberCount(aNumberCount)
    1:       {}
 8288: 
 8288:     void Reset(PRUint8 aAttrEnum);
    1:   };
    1: 
 6045:   struct IntegerInfo {
 6045:     nsIAtom** mName;
 6045:     PRInt32   mDefaultValue;
 6045:   };
 6045: 
 6045:   struct IntegerAttributesInfo {
 6045:     nsSVGInteger* mIntegers;
 6045:     IntegerInfo*  mIntegerInfo;
 6045:     PRUint32      mIntegerCount;
 6045: 
 6045:     IntegerAttributesInfo(nsSVGInteger *aIntegers,
 6045:                           IntegerInfo *aIntegerInfo,
 6045:                           PRUint32 aIntegerCount) :
 6045:       mIntegers(aIntegers), mIntegerInfo(aIntegerInfo), mIntegerCount(aIntegerCount)
 6045:       {}
 8288: 
 8288:     void Reset(PRUint8 aAttrEnum);
 6045:   };
 6045: 
 6788:   struct AngleInfo {
 6788:     nsIAtom** mName;
 6788:     float     mDefaultValue;
 6788:     PRUint8   mDefaultUnitType;
 6788:   };
 6788: 
 6788:   struct AngleAttributesInfo {
 6788:     nsSVGAngle* mAngles;
 6788:     AngleInfo*  mAngleInfo;
 6788:     PRUint32    mAngleCount;
 6788: 
 6788:     AngleAttributesInfo(nsSVGAngle *aAngles,
 6788:                         AngleInfo *aAngleInfo,
 6788:                         PRUint32 aAngleCount) :
 6788:       mAngles(aAngles), mAngleInfo(aAngleInfo), mAngleCount(aAngleCount)
 6788:       {}
 8288: 
 8288:     void Reset(PRUint8 aAttrEnum);
 6788:   };
 6788: 
 6325:   struct BooleanInfo {
 6325:     nsIAtom**    mName;
 6325:     PRPackedBool mDefaultValue;
 6325:   };
 6325: 
 6325:   struct BooleanAttributesInfo {
 6325:     nsSVGBoolean* mBooleans;
 6325:     BooleanInfo*  mBooleanInfo;
 6325:     PRUint32      mBooleanCount;
 6325: 
 6325:     BooleanAttributesInfo(nsSVGBoolean *aBooleans,
 6325:                           BooleanInfo *aBooleanInfo,
 6325:                           PRUint32 aBooleanCount) :
 6325:       mBooleans(aBooleans), mBooleanInfo(aBooleanInfo), mBooleanCount(aBooleanCount)
 6325:       {}
 8288: 
 8288:     void Reset(PRUint8 aAttrEnum);
 6325:   };
 6325: 
 6045:   friend class nsSVGEnum;
 6045: 
 5347:   struct EnumInfo {
 5347:     nsIAtom**         mName;
 5347:     nsSVGEnumMapping* mMapping;
 5347:     PRUint16          mDefaultValue;
 5347:   };
 5347: 
 5347:   struct EnumAttributesInfo {
 5347:     nsSVGEnum* mEnums;
 5347:     EnumInfo*  mEnumInfo;
 5347:     PRUint32   mEnumCount;
 5347: 
 5347:     EnumAttributesInfo(nsSVGEnum *aEnums,
 5347:                        EnumInfo *aEnumInfo,
 5347:                        PRUint32 aEnumCount) :
 5347:       mEnums(aEnums), mEnumInfo(aEnumInfo), mEnumCount(aEnumCount)
 5347:       {}
 8288: 
 8288:     void Reset(PRUint8 aAttrEnum);
 5347:   };
 5347: 
58554:   struct NumberListInfo {
58554:     nsIAtom** mName;
58554:   };
58554: 
58554:   struct NumberListAttributesInfo {
58554:     SVGAnimatedNumberList* mNumberLists;
58554:     NumberListInfo*        mNumberListInfo;
58554:     PRUint32               mNumberListCount;
58554: 
58554:     NumberListAttributesInfo(SVGAnimatedNumberList *aNumberLists,
58554:                              NumberListInfo *aNumberListInfo,
58554:                              PRUint32 aNumberListCount)
58554:       : mNumberLists(aNumberLists)
58554:       , mNumberListInfo(aNumberListInfo)
58554:       , mNumberListCount(aNumberListCount)
58554:     {}
58554: 
58554:     void Reset(PRUint8 aAttrEnum);
58554:   };
58554: 
47840:   struct LengthListInfo {
47840:     nsIAtom** mName;
47840:     PRUint8   mAxis;
47840:     /**
47840:      * Flag to indicate whether appending zeros to the end of the list would
47840:      * change the rendering of the SVG for the attribute in question. For x and
47840:      * y on the <text> element this is true, but for dx and dy on <text> this
47840:      * is false. This flag is fed down to SVGLengthListSMILType so it can
47840:      * determine if it can sensibly animate from-to lists of different lengths,
47840:      * which is desirable in the case of dx and dy.
47840:      */
47840:     PRPackedBool mCouldZeroPadList;
47840:   };
47840: 
47840:   struct LengthListAttributesInfo {
57113:     SVGAnimatedLengthList* mLengthLists;
47840:     LengthListInfo*        mLengthListInfo;
47840:     PRUint32               mLengthListCount;
47840: 
57113:     LengthListAttributesInfo(SVGAnimatedLengthList *aLengthLists,
47840:                              LengthListInfo *aLengthListInfo,
47840:                              PRUint32 aLengthListCount)
47840:       : mLengthLists(aLengthLists)
47840:       , mLengthListInfo(aLengthListInfo)
47840:       , mLengthListCount(aLengthListCount)
47840:     {}
47840: 
47840:     void Reset(PRUint8 aAttrEnum);
47840:   };
47840: 
15353:   struct StringInfo {
15353:     nsIAtom**    mName;
15353:     PRInt32      mNamespaceID;
55139:     PRPackedBool mIsAnimatable;
15353:   };
15353: 
15353:   struct StringAttributesInfo {
15353:     nsSVGString*  mStrings;
15353:     StringInfo*   mStringInfo;
15353:     PRUint32      mStringCount;
15353: 
15353:     StringAttributesInfo(nsSVGString *aStrings,
15353:                          StringInfo *aStringInfo,
15353:                          PRUint32 aStringCount) :
15353:       mStrings(aStrings), mStringInfo(aStringInfo), mStringCount(aStringCount)
15353:       {}
15353: 
15353:     void Reset(PRUint8 aAttrEnum);
15353:   };
15353: 
    1:   virtual LengthAttributesInfo GetLengthInfo();
    1:   virtual NumberAttributesInfo GetNumberInfo();
 6045:   virtual IntegerAttributesInfo GetIntegerInfo();
 6788:   virtual AngleAttributesInfo GetAngleInfo();
 6325:   virtual BooleanAttributesInfo GetBooleanInfo();
 6325:   virtual EnumAttributesInfo GetEnumInfo();
24554:   // We assume all viewboxes and preserveAspectRatios are alike
24554:   // so we don't need to wrap the class
24554:   virtual nsSVGViewBox *GetViewBox();
59470:   virtual SVGAnimatedPreserveAspectRatio *GetPreserveAspectRatio();
58554:   virtual NumberListAttributesInfo GetNumberListInfo();
47840:   virtual LengthListAttributesInfo GetLengthListInfo();
15353:   virtual StringAttributesInfo GetStringInfo();
64109:   virtual nsSVGClass *GetClass();
    1: 
 6788:   static nsSVGEnumMapping sSVGUnitTypesMap[];
 6788: 
15523: private:
 6944:   /* read <number-optional-number> */
15523:   nsresult
15523:   ParseNumberOptionalNumber(const nsAString& aValue,
15523:                             PRUint32 aIndex1, PRUint32 aIndex2);
 6944: 
 6944:   /* read <integer-optional-integer> */
15523:   nsresult
15523:   ParseIntegerOptionalInteger(const nsAString& aValue,
15523:                               PRUint32 aIndex1, PRUint32 aIndex2);
 6944: 
 8288:   void ResetOldStyleBaseType(nsISVGValue *svg_value);
 8288: 
38453:   struct ObservableModificationData {
38453:     // Only to be used if |name| is non-null.  Otherwise, modType will
38453:     // be 0 to indicate NS_OK should be returned and 1 to indicate
38453:     // NS_ERROR_UNEXPECTED should be returned.
38453:     ObservableModificationData(const nsAttrName* aName, PRUint32 aModType):
38453:       name(aName), modType(aModType)
38453:     {}
38453:     const nsAttrName* name;
38453:     PRUint8 modType;
38453:   };
38453:   ObservableModificationData
38453:     GetModificationDataForObservable(nsISVGValue* aObservable,
38453:                                      nsISVGValue::modificationType aModType);
38453: 
63693:   nsRefPtr<mozilla::css::StyleRule> mContentStyleRule;
    1:   nsAttrAndChildArray mMappedAttributes;
    1: 
    1:   PRPackedBool mSuppressNotification;
    1: };
    1: 
    1: /**
    1:  * A macro to implement the NS_NewSVGXXXElement() functions.
    1:  */
    1: #define NS_IMPL_NS_NEW_SVG_ELEMENT(_elementName)                             \
    1: nsresult                                                                     \
    1: NS_NewSVG##_elementName##Element(nsIContent **aResult,                       \
48124:                                  already_AddRefed<nsINodeInfo> aNodeInfo)    \
    1: {                                                                            \
37218:   nsRefPtr<nsSVG##_elementName##Element> it =                                \
11169:     new nsSVG##_elementName##Element(aNodeInfo);                             \
    1:   if (!it)                                                                   \
    1:     return NS_ERROR_OUT_OF_MEMORY;                                           \
    1:                                                                              \
37218:   nsresult rv = it->Init();                                                  \
37218:                                                                              \
37218:   if (NS_FAILED(rv)) {                                                       \
37218:     return rv;                                                               \
37218:   }                                                                          \
37218:                                                                              \
37218:   *aResult = it.forget().get();                                              \
37218:                                                                              \
37218:   return rv;                                                                 \
37218: }
37218: 
37218: #define NS_IMPL_NS_NEW_SVG_ELEMENT_CHECK_PARSER(_elementName)                \
37218: nsresult                                                                     \
37218: NS_NewSVG##_elementName##Element(nsIContent **aResult,                       \
48124:                                  already_AddRefed<nsINodeInfo> aNodeInfo,    \
56805:                                  FromParser aFromParser)                     \
37218: {                                                                            \
37218:   nsRefPtr<nsSVG##_elementName##Element> it =                                \
37218:     new nsSVG##_elementName##Element(aNodeInfo, aFromParser);                \
37218:   if (!it)                                                                   \
37218:     return NS_ERROR_OUT_OF_MEMORY;                                           \
    1:                                                                              \
    1:   nsresult rv = it->Init();                                                  \
    1:                                                                              \
    1:   if (NS_FAILED(rv)) {                                                       \
    1:     return rv;                                                               \
    1:   }                                                                          \
    1:                                                                              \
37218:   *aResult = it.forget().get();                                              \
    1:                                                                              \
    1:   return rv;                                                                 \
    1: }
    1: 
23193:  // No unlinking, we'd need to null out the value pointer (the object it
23193: // points to is held by the element) and null-check it everywhere.
23193: #define NS_SVG_VAL_IMPL_CYCLE_COLLECTION(_val, _element)                     \
23193: NS_IMPL_CYCLE_COLLECTION_CLASS(_val)                                         \
23193: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(_val)                                \
23193:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(_element, nsIContent) \
23193: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END                                        \
23193: NS_IMPL_CYCLE_COLLECTION_UNLINK_0(_val)
23193: 
23193: 
    1: #endif // __NS_SVGELEMENT_H__
