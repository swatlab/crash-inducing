    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:set et cin sw=2 sts=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla <object> loading code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Christian Biesinger <cbiesinger@web.de>.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
36843:  * A base class implementing nsIObjectLoadingContent for use by
    1:  * various content nodes that want to provide plugin/document/image
    1:  * loading functionality (eg <embed>, <object>, <applet>, etc).
    1:  */
    1: 
    1: #ifndef NSOBJECTLOADINGCONTENT_H_
    1: #define NSOBJECTLOADINGCONTENT_H_
    1: 
    1: #include "nsImageLoadingContent.h"
    1: #include "nsIStreamListener.h"
 3556: #include "nsFrameLoader.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIChannelEventSink.h"
    1: #include "nsIObjectLoadingContent.h"
    1: #include "nsIRunnable.h"
35581: #include "nsIFrame.h"
89114: #include "nsPluginInstanceOwner.h"
89114: #include "nsIThreadInternal.h"
    1: 
15571: class nsAsyncInstantiateEvent;
89114: class nsStopPluginRunnable;
    1: class AutoNotifier;
    1: class AutoFallback;
    1: class AutoSetInstantiatingToFalse;
89114: class nsObjectFrame;
    1: 
19014: enum PluginSupportState {
37151:   ePluginUnsupported,  // The plugin is not supported (e.g. not installed)
37151:   ePluginDisabled,     // The plugin has been explicitly disabled by the user
19014:   ePluginBlocklisted,  // The plugin is blocklisted and disabled
33384:   ePluginOutdated,     // The plugin is considered outdated, but not disabled
37151:   ePluginOtherState,   // Something else (e.g. uninitialized or not a plugin)
80300:   ePluginCrashed,
84557:   ePluginClickToPlay   // The plugin is disabled until the user clicks on it
19014: };
19014: 
    1: /**
    1:  * INVARIANTS OF THIS CLASS
    1:  * - mChannel is non-null between asyncOpen and onStopRequest (NOTE: Only needs
    1:  *   to be valid until onStopRequest is called on mFinalListener, not
    1:  *   necessarily until the channel calls onStopRequest on us)
    1:  * - mChannel corresponds to the channel that gets passed to the
    1:  *   nsIRequestObserver/nsIStreamListener methods
    1:  * - mChannel can be cancelled and ODA calls will stop
    1:  * - mFinalListener is non-null (only) after onStartRequest has been called on
    1:  *   it and before onStopRequest has been called on it
    1:  *   (i.e. calling onStopRequest doesn't violate the nsIRequestObserver
    1:  *   contract)
    1:  * - mFrameLoader is null while this node is not in a document (XXX this
    1:  *   invariant only exists due to nsFrameLoader suckage and needs to go away)
    1:  * - mInstantiating is true while in LoadObject (it may be true in other
    1:  *   cases as well). Only the function that set mInstantiating should trigger
    1:  *   frame construction or notifications like ContentStatesChanged or flushes.
    1:  */
    1: class nsObjectLoadingContent : public nsImageLoadingContent
    1:                              , public nsIStreamListener
    1:                              , public nsIFrameLoaderOwner
    1:                              , public nsIObjectLoadingContent
    1:                              , public nsIInterfaceRequestor
    1:                              , public nsIChannelEventSink
    1: {
    1:   friend class AutoNotifier;
    1:   friend class AutoFallback;
    1:   friend class AutoSetInstantiatingToFalse;
89114:   friend class nsStopPluginRunnable;
89114:   friend class nsAsyncInstantiateEvent;
    1: 
    1:   public:
    1:     // This enum's values must be the same as the constants on
    1:     // nsIObjectLoadingContent
    1:     enum ObjectType {
    1:       eType_Loading  = TYPE_LOADING,  ///< Type not yet known
    1:       eType_Image    = TYPE_IMAGE,    ///< This content is an image
    1:       eType_Plugin   = TYPE_PLUGIN,   ///< This content is a plugin
    1:       eType_Document = TYPE_DOCUMENT, ///< This is a document type (e.g. HTML)
    1:       eType_Null     = TYPE_NULL      ///< Type can't be handled
    1:     };
    1: 
    1:     nsObjectLoadingContent();
    1:     virtual ~nsObjectLoadingContent();
    1: 
    1:     NS_DECL_NSIREQUESTOBSERVER
    1:     NS_DECL_NSISTREAMLISTENER
    1:     NS_DECL_NSIFRAMELOADEROWNER
    1:     NS_DECL_NSIOBJECTLOADINGCONTENT
    1:     NS_DECL_NSIINTERFACEREQUESTOR
    1:     NS_DECL_NSICHANNELEVENTSINK
    1: 
    1: #ifdef HAVE_CPP_AMBIGUITY_RESOLVING_USING
    1:     // Fix gcc compile warnings
    1:     using nsImageLoadingContent::OnStartRequest;
    1:     using nsImageLoadingContent::OnDataAvailable;
    1:     using nsImageLoadingContent::OnStopRequest;
    1: #endif
    1: 
    1:     ObjectType Type() { return mType; }
    1: 
    1:     /**
    1:      * Object state. This is a bitmask consisting of a subset of
    1:      * NS_EVENT_STATE_BROKEN, NS_EVENT_STATE_USERDISABLED and
    1:      * NS_EVENT_STATE_SUPPRESSED representing the current state of the object.
    1:      */
56168:     nsEventStates ObjectState() const;
    1: 
79445:     void SetIsNetworkCreated(bool aNetworkCreated)
50721:     {
50721:       mNetworkCreated = aNetworkCreated;
50721:     }
89114: 
89114:     // Can flush layout.
89114:     nsresult InstantiatePluginInstance(const char* aMimeType, nsIURI* aURI);
89114: 
89114:     void NotifyOwnerDocumentActivityChanged();
89114: 
91089:     bool SrcStreamLoading() { return mSrcStreamLoading; };
89114: 
    1:   protected:
    1:     /**
    1:      * Load the object from the given URI.
    1:      * @param aURI       The URI to load.
    1:      * @param aNotify If true, nsIDocumentObserver state change notifications
    1:      *                will be sent as needed.
    1:      * @param aTypeHint  MIME Type hint. Overridden by the server unless this
    1:      *                   class has the eOverrideServerType capability.
    1:      * @param aForceLoad If true, the object will be refetched even if the URI
    1:      *                   is the same as the currently-loaded object.
    1:      * @note Prefer the nsIURI-taking version of this function if a URI object
    1:      *       is already available.
    1:      * @see the URI-taking version of this function for a detailed description
    1:      *      of how a plugin will be found.
    1:      */
    1:     nsresult LoadObject(const nsAString& aURI,
79445:                         bool aNotify,
    1:                         const nsCString& aTypeHint = EmptyCString(),
79445:                         bool aForceLoad = false);
    1:     /**
    1:      * Loads the object from the given URI.
    1:      *
    1:      * The URI and type can both be null; if the URI is null a plugin will be
    1:      * instantiated in the hope that there is a <param> with a useful URI
    1:      * somewhere around. Other attributes of |this| QI'd to nsIContent will be
    1:      * inspected. This function attempts hard to find a suitable plugin.
    1:      *
    1:      * The instantiated plugin depends on three values:
    1:      * - The passed-in URI
    1:      * - The passed-in type hint
    1:      * - The classid attribute, if eSupportClassID is among the capabilities
    1:      *   and such an attribute is present..
    1:      *
    1:      * Supported class ID attributes override any other value.
    1:      *
    1:      * If no class ID is present and aForceType is true, the handler given by
    1:      * aTypeHint will be instantiated for this content.
    1:      * If the URI is null or not supported, and a type hint is given, the plugin
    1:      * corresponding to that type is instantiated.
    1:      *
    1:      * Otherwise a request to that URI is made and the type sent by the server
    1:      * is used to find a suitable handler.
    1:      *
    1:      * @param aForceLoad If true, the object will be refetched even if the URI
    1:      *                   is the same as the currently-loaded object.
    1:      */
    1:     nsresult LoadObject(nsIURI* aURI,
79445:                         bool aNotify,
    1:                         const nsCString& aTypeHint = EmptyCString(),
79445:                         bool aForceLoad = false);
    1: 
    1:     enum Capabilities {
    1:       eSupportImages    = PR_BIT(0), // Images are supported (imgILoader)
    1:       eSupportPlugins   = PR_BIT(1), // Plugins are supported (nsIPluginHost)
    1:       eSupportDocuments = PR_BIT(2), // Documents are supported
    1:                                      // (nsIDocumentLoaderFactory)
    1:                                      // This flag always includes SVG
    1:       eSupportSVG       = PR_BIT(3), // SVG is supported (image/svg+xml)
    1:       eSupportClassID   = PR_BIT(4), // The classid attribute is supported
    1:       eOverrideServerType = PR_BIT(5) // The server-sent MIME type is ignored
    1:                                       // (ignored if no type is specified)
    1:     };
    1: 
    1:     /**
    1:      * Returns the list of capabilities this content node supports. This is a
    1:      * bitmask consisting of flags from the Capabilities enum.
    1:      *
    1:      * The default implementation supports all types but no classids.
    1:      */
    1:     virtual PRUint32 GetCapabilities() const;
    1: 
    1:     /**
    1:      * Fall back to rendering the alternative content.
    1:      */
79445:     void Fallback(bool aNotify);
    1: 
    1:     /**
    1:      * Subclasses must call this function when they are removed from the
    1:      * document.
    1:      *
    1:      * XXX This is a temporary workaround for docshell suckyness
    1:      */
    1:     void RemovedFromDocument();
    1: 
77323:     static void Traverse(nsObjectLoadingContent *tmp,
77323:                          nsCycleCollectionTraversalCallback &cb);
    1: 
35581:     void CreateStaticClone(nsObjectLoadingContent* aDest) const;
89114: 
92637:     void DoStopPlugin(nsPluginInstanceOwner* aInstanceOwner, bool aDelayedStop,
92637:                       bool aForcedReentry = false);
89114: 
    1:   private:
89114: 
89114:     void NotifyContentObjectWrapper();
89114: 
    1:     /**
    1:      * Check whether the given request represents a successful load.
    1:      */
79445:     static bool IsSuccessfulRequest(nsIRequest* aRequest);
    1: 
    1:     /**
    1:      * Check whether the URI can be handled internally.
    1:      */
79445:     static bool CanHandleURI(nsIURI* aURI);
    1: 
    1:     /**
    1:      * Checks whether the given type is a supported document type.
    1:      */
79445:     bool IsSupportedDocument(const nsCString& aType);
    1: 
    1:     /**
    1:      * Unload the currently loaded content. This removes all state related to
    1:      * the displayed content and sets the type to eType_Null.
    1:      * Note: This does not send any notifications.
    1:      */
    1:     void UnloadContent();
    1: 
    1:     /**
    1:      * Notifies document observes about a new type/state of this object.
    1:      * Triggers frame construction as needed. mType must be set correctly when
    1:      * this method is called. This method is cheap if the type and state didn't
    1:      * actually change.
    1:      *
    1:      * @param aSync If a synchronous frame construction is required. If false,
    1:      *              the construction may either be sync or async.
71121:      * @param aNotify if false, only need to update the state of our element.
    1:      */
56168:     void NotifyStateChanged(ObjectType aOldType, nsEventStates aOldState,
79445:                             bool aSync, bool aNotify);
    1: 
    1:     /**
    1:      * Fires the "Plugin not found" event. This function doesn't do any checks
    1:      * whether it should be fired, the caller should do that.
    1:      */
19014:     static void FirePluginError(nsIContent* thisContent, PluginSupportState state);
    1: 
    1:     ObjectType GetTypeOfContent(const nsCString& aMIMEType);
    1: 
    1:     /**
    1:      * For a classid, returns the MIME type that can be used to instantiate
    1:      * a plugin for this ID.
    1:      *
    1:      * @return NS_ERROR_NOT_AVAILABLE Unsupported class ID.
    1:      */
    1:     nsresult TypeForClassID(const nsAString& aClassID, nsACString& aType);
    1: 
    1:     /**
92488:      * Gets the base URI to be used for this object. This differs from
92488:      * nsIContent::GetBaseURI in that it takes codebase attributes into
92488:      * account.
92488:      */
92488:     void GetObjectBaseURI(nsIContent* thisContent, nsIURI** aURI);
92488: 
92488: 
92488:     /**
89114:      * Gets the frame that's associated with this content node.
89114:      * Does not flush.
    1:      */
89114:     nsObjectFrame* GetExistingFrame();
    1: 
    1:     /**
 5870:      * Handle being blocked by a content policy.  aStatus is the nsresult
 5870:      * return value of the Should* call, while aRetval is what it returned in
 5870:      * its out parameter.
 5870:      */
 5870:     void HandleBeingBlockedByContentPolicy(nsresult aStatus,
 5870:                                            PRInt16 aRetval);
 5870: 
 5870:     /**
    1:      * Get the plugin support state for the given content node and MIME type.
    1:      * This is used for purposes of determining whether to fire PluginNotFound
    1:      * events etc.  aContentType is the MIME type we ended up with.
    1:      *
    1:      * This should only be called if the type of this content is eType_Null.
    1:      */
89887:     PluginSupportState GetPluginSupportState(nsIContent* aContent, const nsCString& aContentType);
    1: 
    1:     /**
    1:      * If the plugin for aContentType is disabled, return ePluginDisabled.
    1:      * Otherwise (including if there is no plugin for aContentType at all),
    1:      * return ePluginUnsupported.
    1:      *
    1:      * This should only be called if the type of this content is eType_Null.
    1:      */
89887:     PluginSupportState GetPluginDisabledState(const nsCString& aContentType);
    1: 
    1:     /**
12297:      * When there is no usable plugin available this will send UI events and
12297:      * update the AutoFallback object appropriate to the reason for there being
12297:      * no plugin available.
12297:      */
89887:     void UpdateFallbackState(nsIContent* aContent, AutoFallback& fallback, const nsCString& aTypeHint);
89887: 
89887:     nsresult IsPluginEnabledForType(const nsCString& aMIMEType);
89887:     bool IsPluginEnabledByExtension(nsIURI* uri, nsCString& mimeType);
12297: 
12297:     /**
    1:      * The final listener to ship the data to (imagelib, uriloader, etc)
    1:      */
    1:     nsCOMPtr<nsIStreamListener> mFinalListener;
    1: 
    1:     /**
    1:      * Frame loader, for content documents we load.
    1:      */
 3556:     nsRefPtr<nsFrameLoader>     mFrameLoader;
    1: 
    1:     /**
    1:      * A pending nsAsyncInstantiateEvent (may be null).  This is a weak ref.
    1:      */
    1:     nsIRunnable                *mPendingInstantiateEvent;
    1: 
    1:     /**
    1:      * The content type of the resource we were last asked to load.
    1:      */
    1:     nsCString                   mContentType;
    1: 
    1:     /**
    1:      * The channel that's currently being loaded. This is a weak reference.
    1:      * Non-null between asyncOpen and onStopRequest.
    1:      */
    1:     nsIChannel*                 mChannel;
    1: 
    1:     // The data we were last asked to load
    1:     nsCOMPtr<nsIURI>            mURI;
    1: 
    1:     /**
    1:      * Type of the currently-loaded content.
    1:      */
    1:     ObjectType                  mType          : 16;
    1: 
    1:     /**
    1:      * Whether we are about to call instantiate on our frame. If we aren't,
    1:      * SetFrame needs to asynchronously call Instantiate.
    1:      */
79445:     bool                        mInstantiating : 1;
    1:     // Blocking status from content policy
79445:     bool                        mUserDisabled  : 1;
79445:     bool                        mSuppressed    : 1;
50721: 
50721:     // True when the object is created for an element which the parser has
50721:     // created using NS_FROM_PARSER_NETWORK flag. If the element is modified,
50721:     // it may lose the flag.
79445:     bool                        mNetworkCreated : 1;
50721: 
84557:     // Used to keep track of whether or not a plugin should be played.
84557:     // This is used for click-to-play plugins.
84557:     bool                        mShouldPlay : 1;
84557: 
92637:     // Protects DoStopPlugin from reentry (bug 724781).
92637:     bool                        mIsStopping : 1;
92637: 
91089:     // Used to track when we might try to instantiate a plugin instance based on
91089:     // a src data stream being delivered to this object. When this is true we don't
91089:     // want plugin instance instantiation code to attempt to load src data again or
91089:     // we'll deliver duplicate streams. Should be cleared when we are not loading
91089:     // src data.
91089:     bool mSrcStreamLoading;
89114: 
19014:     // A specific state that caused us to fallback
37151:     PluginSupportState          mFallbackReason;
    1: 
35581:     nsWeakFrame                 mPrintFrame;
35581: 
89114:     nsRefPtr<nsPluginInstanceOwner> mInstanceOwner;
    1: };
    1: 
    1: #endif
