43527: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
43527:  * ***** BEGIN LICENSE BLOCK *****
43527:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43527:  *
43527:  * The contents of this file are subject to the Mozilla Public License Version
43527:  * 1.1 (the "License"); you may not use this file except in compliance with
43527:  * the License. You may obtain a copy of the License at
43527:  * http://www.mozilla.org/MPL/
43527:  *
43527:  * Software distributed under the License is distributed on an "AS IS" basis,
43527:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43527:  * for the specific language governing rights and limitations under the
43527:  * License.
43527:  *
43527:  * The Original Code is Mozilla Corporation code.
43527:  *
43527:  * The Initial Developer of the Original Code is Mozilla Corporation.
43527:  * Portions created by the Initial Developer are Copyright (C) 2009-2010
43527:  * the Initial Developer. All Rights Reserved.
43527:  *
43527:  * Contributor(s):
43527:  *   Jonathan Kew <jfkthame@gmail.com>
43527:  *
43527:  * Alternatively, the contents of this file may be used under the terms of
43527:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43527:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43527:  * in which case the provisions of the GPL or the LGPL are applicable instead
43527:  * of those above. If you wish to allow use of your version of this file only
43527:  * under the terms of either the GPL or the LGPL, and not to allow others to
43527:  * use your version of this file under the terms of the MPL, indicate your
43527:  * decision by deleting the provisions above and replace them with the notice
43527:  * and other provisions required by the GPL or the LGPL. If you do not delete
43527:  * the provisions above, a recipient may use your version of this file under
43527:  * the terms of any one of the MPL, the GPL or the LGPL.
43527:  *
43527:  * ***** END LICENSE BLOCK ***** */
43527: 
43527: #include "prtypes.h"
43527: #include "prmem.h"
43527: #include "nsString.h"
43527: #include "nsBidiUtils.h"
43527: #include "nsMathUtils.h"
43527: 
43527: #include "gfxTypes.h"
43527: 
43527: #include "gfxContext.h"
43527: #include "gfxPlatform.h"
43527: #include "gfxHarfBuzzShaper.h"
43527: #include "gfxFontUtils.h"
43527: #include "gfxUnicodeProperties.h"
43527: 
43527: #include "harfbuzz/hb-unicode.h"
47360: #include "harfbuzz/hb-ot.h"
43527: 
43527: #include "nsUnicodeRange.h"
47360: #include "nsCRT.h"
43527: 
43527: #define FloatToFixed(f) (65536 * (f))
43527: #define FixedToFloat(f) ((f) * (1.0 / 65536.0))
43527: 
43527: using namespace mozilla; // for AutoSwap_* types
43527: 
43527: /*
43527:  * Creation and destruction; on deletion, release any font tables we're holding
43527:  */
43527: 
43527: gfxHarfBuzzShaper::gfxHarfBuzzShaper(gfxFont *aFont)
43527:     : gfxFontShaper(aFont),
43527:       mHBFace(nsnull),
47360:       mHBLanguage(nsnull),
48292:       mKernTable(nsnull),
43527:       mHmtxTable(nsnull),
43527:       mNumLongMetrics(0),
43527:       mCmapTable(nsnull),
43527:       mCmapFormat(-1),
43527:       mSubtableOffset(0),
43527:       mUVSTableOffset(0),
43527:       mUseHintedWidths(aFont->ProvidesHintedWidths())
43527: {
43527: }
43527: 
43527: gfxHarfBuzzShaper::~gfxHarfBuzzShaper()
43527: {
43527:     hb_blob_destroy(mCmapTable);
43527:     hb_blob_destroy(mHmtxTable);
54184:     hb_blob_destroy(mKernTable);
43527:     hb_face_destroy(mHBFace);
43527: }
43527: 
43527: /*
43527:  * HarfBuzz callback access to font table data
43527:  */
43527: 
43527: // callback for HarfBuzz to get a font table (in hb_blob_t form)
43527: // from the shaper (passed as aUserData)
43527: static hb_blob_t *
43527: HBGetTable(hb_tag_t aTag, void *aUserData)
43527: {
43527:     gfxHarfBuzzShaper *shaper = static_cast<gfxHarfBuzzShaper*>(aUserData);
43527:     return shaper->GetFont()->GetFontTable(aTag);
43527: }
43527: 
43527: /*
43527:  * HarfBuzz font callback functions; user_data is a ptr to a
43527:  * FontCallbackData struct
43527:  */
43527: 
43527: struct FontCallbackData {
43527:     FontCallbackData(gfxHarfBuzzShaper *aShaper, gfxContext *aContext)
43527:         : mShaper(aShaper), mContext(aContext)
43527:     { }
43527: 
43527:     gfxHarfBuzzShaper *mShaper;
43527:     gfxContext        *mContext;
43527: };
43527: 
43527: #define UNICODE_BMP_LIMIT 0x10000
43527: 
43527: hb_codepoint_t
43527: gfxHarfBuzzShaper::GetGlyph(hb_codepoint_t unicode,
43527:                             hb_codepoint_t variation_selector) const
43527: {
43527:     // we only instantiate a harfbuzz shaper if there's a cmap available
43527:     NS_ASSERTION(mFont->GetFontEntry()->HasCmapTable(),
43527:                  "we cannot be using this font!");
43527: 
43673:     NS_ASSERTION(mCmapTable && (mCmapFormat > 0) && (mSubtableOffset > 0),
43673:                  "cmap data not correctly set up, expect disaster");
43527: 
43527:     const PRUint8* data = (const PRUint8*)hb_blob_lock(mCmapTable);
43527: 
43527:     hb_codepoint_t gid;
43527:     switch (mCmapFormat) {
43527:     case 4:
43527:         gid = unicode < UNICODE_BMP_LIMIT ?
43527:             gfxFontUtils::MapCharToGlyphFormat4(data + mSubtableOffset, unicode) : 0;
43527:         break;
43527:     case 12:
43527:         gid = gfxFontUtils::MapCharToGlyphFormat12(data + mSubtableOffset, unicode);
43527:         break;
43527:     default:
43527:         NS_WARNING("unsupported cmap format, glyphs will be missing");
43527:         gid = 0;
43527:         break;
43527:     }
43527: 
43527:     if (gid && variation_selector && mUVSTableOffset) {
43527:         hb_codepoint_t varGID =
43527:             gfxFontUtils::MapUVSToGlyphFormat14(data + mUVSTableOffset,
43527:                                                 unicode, variation_selector);
43527:         if (varGID) {
43527:             gid = varGID;
43527:         }
43527:         // else the variation sequence was not supported, use default mapping
43527:         // of the character code alone
43527:     }
43527: 
43527:     hb_blob_unlock(mCmapTable);
43527: 
43527:     return gid;
43527: }
43527: 
43527: static hb_codepoint_t
43527: HBGetGlyph(hb_font_t *font, hb_face_t *face, const void *user_data,
43527:            hb_codepoint_t unicode, hb_codepoint_t variation_selector)
43527: {
43527:     const FontCallbackData *fcd =
43527:         static_cast<const FontCallbackData*>(user_data);
43527:     return fcd->mShaper->GetGlyph(unicode, variation_selector);
43527: }
43527: 
43527: struct HMetricsHeader {
43527:     AutoSwap_PRUint32    tableVersionNumber;
43527:     AutoSwap_PRInt16     ascender;
43527:     AutoSwap_PRInt16     descender;
43527:     AutoSwap_PRInt16     lineGap;
43527:     AutoSwap_PRUint16    advanceWidthMax;
43527:     AutoSwap_PRInt16     minLeftSideBearing;
43527:     AutoSwap_PRInt16     minRightSideBearing;
43527:     AutoSwap_PRInt16     xMaxExtent;
43527:     AutoSwap_PRInt16     caretSlopeRise;
43527:     AutoSwap_PRInt16     caretSlopeRun;
43527:     AutoSwap_PRInt16     caretOffset;
43527:     AutoSwap_PRInt16     reserved[4];
43527:     AutoSwap_PRInt16     metricDataFormat;
43527:     AutoSwap_PRUint16    numberOfHMetrics;
43527: };
43527: 
43527: struct HLongMetric {
43527:     AutoSwap_PRUint16    advanceWidth;
43527:     AutoSwap_PRInt16     lsb;
43527: };
43527: 
43527: struct HMetrics {
43527:     HLongMetric          metrics[1]; // actually numberOfHMetrics
43527: // the variable-length metrics[] array is immediately followed by:
43527: //  AutoSwap_PRUint16    leftSideBearing[];
43527: };
43527: 
43527: void
43527: gfxHarfBuzzShaper::GetGlyphMetrics(gfxContext *aContext,
43527:                                    hb_codepoint_t glyph,
43527:                                    hb_glyph_metrics_t *metrics) const
43527: {
43527:     if (mUseHintedWidths) {
43527:         metrics->x_advance = mFont->GetHintedGlyphWidth(aContext, glyph);
43527:         return;
43527:     }
43527: 
43527:     // font did not implement GetHintedGlyphWidth, so get an unhinted value
43527:     // directly from the font tables
43527: 
43673:     NS_ASSERTION((mNumLongMetrics > 0) && mHmtxTable != nsnull,
43673:                  "font is lacking metrics, we shouldn't be here");
43527: 
43527:     if (glyph >= mNumLongMetrics) {
43527:         glyph = mNumLongMetrics - 1;
43527:     }
43527: 
48070:     // glyph must be valid now, because we checked during initialization
48070:     // that mNumLongMetrics is > 0, and that the hmtx table is large enough
48070:     // to contain mNumLongMetrics records
43527:     const HMetrics* hmtx =
43527:         reinterpret_cast<const HMetrics*>(hb_blob_lock(mHmtxTable));
43527:     metrics->x_advance =
43527:         FloatToFixed(mFont->FUnitsToDevUnitsFactor() *
43527:                      PRUint16(hmtx->metrics[glyph].advanceWidth));
43527:     hb_blob_unlock(mHmtxTable);
43527: 
43527:     // TODO: set additional metrics if/when harfbuzz needs them
43527: }
43527: 
43527: static void
43527: HBGetGlyphMetrics(hb_font_t *font, hb_face_t *face, const void *user_data,
43527:                   hb_codepoint_t glyph, hb_glyph_metrics_t *metrics)
43527: {
43527:     const FontCallbackData *fcd =
43527:         static_cast<const FontCallbackData*>(user_data);
43527:     fcd->mShaper->GetGlyphMetrics(fcd->mContext, glyph, metrics);
43527: }
43527: 
43527: static hb_bool_t
43527: HBGetContourPoint(hb_font_t *font, hb_face_t *face, const void *user_data,
43527:                   unsigned int point_index, hb_codepoint_t glyph,
43527:                   hb_position_t *x, hb_position_t *y)
43527: {
43527:     /* not yet implemented - no support for used of hinted contour points
43527:        to fine-tune anchor positions in GPOS AnchorFormat2 */
43527:     return false;
43527: }
43527: 
48292: struct KernHeaderFmt0 {
48292:     AutoSwap_PRUint16 nPairs;
48292:     AutoSwap_PRUint16 searchRange;
48292:     AutoSwap_PRUint16 entrySelector;
48292:     AutoSwap_PRUint16 rangeShift;
48292: };
48292: 
48292: struct KernPair {
48292:     AutoSwap_PRUint16 left;
48292:     AutoSwap_PRUint16 right;
48292:     AutoSwap_PRInt16  value;
48292: };
48292: 
48292: // Find a kern pair in a Format 0 subtable.
48292: // The aSubtable parameter points to the subtable itself, NOT its header,
48292: // as the header structure differs between Windows and Mac (v0 and v1.0)
48292: // versions of the 'kern' table.
48292: // aSubtableLen is the length of the subtable EXCLUDING its header.
48292: // If the pair <aFirstGlyph,aSecondGlyph> is found, the kerning value is
48292: // added to aValue, so that multiple subtables can accumulate a total
48292: // kerning value for a given pair.
48292: static void
48292: GetKernValueFmt0(const void* aSubtable,
48292:                  PRUint32 aSubtableLen,
48292:                  PRUint16 aFirstGlyph,
48292:                  PRUint16 aSecondGlyph,
48292:                  PRInt32& aValue,
48292:                  PRBool   aIsOverride = PR_FALSE,
48292:                  PRBool   aIsMinimum = PR_FALSE)
48292: {
48292:     const KernHeaderFmt0* hdr =
48292:         reinterpret_cast<const KernHeaderFmt0*>(aSubtable);
48292: 
48292:     const KernPair *lo = reinterpret_cast<const KernPair*>(hdr + 1);
48292:     const KernPair *hi = lo + PRUint16(hdr->nPairs);
48292: 
48292:     if (reinterpret_cast<const char*>(aSubtable) + aSubtableLen <
48292:         reinterpret_cast<const char*>(hi)) {
48292:         // subtable is not large enough to contain the claimed number
48292:         // of kern pairs, so just ignore it
48292:         return;
48292:     }
48292: 
48292: #define KERN_PAIR_KEY(l,r) (PRUint32((PRUint16(l) << 16) + PRUint16(r)))
48292: 
48292:     PRUint32 key = KERN_PAIR_KEY(aFirstGlyph, aSecondGlyph);
48292:     while (lo < hi) {
48292:         const KernPair *mid = lo + (hi - lo) / 2;
48292:         if (KERN_PAIR_KEY(mid->left, mid->right) < key) {
48292:             lo = mid + 1;
48292:         } else {
48292:             hi = mid;
48292:         }
48292:     }
48292: 
48292:     if (KERN_PAIR_KEY(lo->left, lo->right) == key) {
48292:         if (aIsOverride) {
48292:             aValue = PRInt16(lo->value);
48292:         } else if (aIsMinimum) {
48292:             aValue = PR_MAX(aValue, PRInt16(lo->value));
48292:         } else {
48292:             aValue += PRInt16(lo->value);
48292:         }
48292:     }
48292: }
48292: 
48292: // Get kerning value from Apple (version 1.0) kern table,
48292: // subtable format 2 (simple N x M array of kerning values)
48292: 
48292: // See http://developer.apple.com/fonts/TTRefMan/RM06/Chap6kern.html
48292: // for details of version 1.0 format 2 subtable.
48292: 
48292: struct KernHeaderVersion1Fmt2 {
48292:     KernTableSubtableHeaderVersion1 header;
48292:     AutoSwap_PRUint16 rowWidth;
48292:     AutoSwap_PRUint16 leftOffsetTable;
48292:     AutoSwap_PRUint16 rightOffsetTable;
48292:     AutoSwap_PRUint16 array;
48292: };
48292: 
48292: struct KernClassTableHdr {
48292:     AutoSwap_PRUint16 firstGlyph;
48292:     AutoSwap_PRUint16 nGlyphs;
48292:     AutoSwap_PRUint16 offsets[1]; // actually an array of nGlyphs entries	
48292: };
48292: 
48292: static PRInt16
48292: GetKernValueVersion1Fmt2(const void* aSubtable,
48292:                          PRUint32 aSubtableLen,
48292:                          PRUint16 aFirstGlyph,
48292:                          PRUint16 aSecondGlyph)
48292: {
48292:     if (aSubtableLen < sizeof(KernHeaderVersion1Fmt2)) {
48292:         return 0;
48292:     }
48292: 
48292:     const char* base = reinterpret_cast<const char*>(aSubtable);
48292:     const char* subtableEnd = base + aSubtableLen;
48292: 
48292:     const KernHeaderVersion1Fmt2* h =
48292:         reinterpret_cast<const KernHeaderVersion1Fmt2*>(aSubtable);
48292:     PRUint32 offset = h->array;
48292: 
48292:     const KernClassTableHdr* leftClassTable =
48292:         reinterpret_cast<const KernClassTableHdr*>(base +
48292:                                                    PRUint16(h->leftOffsetTable));
48292:     if (reinterpret_cast<const char*>(leftClassTable) +
48292:         sizeof(KernClassTableHdr) > subtableEnd) {
48292:         return 0;
48292:     }
48292:     if (aFirstGlyph >= PRUint16(leftClassTable->firstGlyph)) {
48292:         aFirstGlyph -= PRUint16(leftClassTable->firstGlyph);
48292:         if (aFirstGlyph < PRUint16(leftClassTable->nGlyphs)) {
48292:             if (reinterpret_cast<const char*>(leftClassTable) +
48292:                 sizeof(KernClassTableHdr) +
48292:                 aFirstGlyph * sizeof(PRUint16) >= subtableEnd) {
48292:                 return 0;
48292:             }
48292:             offset = PRUint16(leftClassTable->offsets[aFirstGlyph]);
48292:         }
48292:     }
48292: 
48292:     const KernClassTableHdr* rightClassTable =
48292:         reinterpret_cast<const KernClassTableHdr*>(base +
48292:                                                    PRUint16(h->rightOffsetTable));
48292:     if (reinterpret_cast<const char*>(rightClassTable) +
48292:         sizeof(KernClassTableHdr) > subtableEnd) {
48292:         return 0;
48292:     }
48292:     if (aSecondGlyph >= PRUint16(rightClassTable->firstGlyph)) {
48292:         aSecondGlyph -= PRUint16(rightClassTable->firstGlyph);
48292:         if (aSecondGlyph < PRUint16(rightClassTable->nGlyphs)) {
48292:             if (reinterpret_cast<const char*>(rightClassTable) +
48292:                 sizeof(KernClassTableHdr) +
48292:                 aSecondGlyph * sizeof(PRUint16) >= subtableEnd) {
48292:                 return 0;
48292:             }
48292:             offset += PRUint16(rightClassTable->offsets[aSecondGlyph]);
48292:         }
48292:     }
48292: 
48292:     const AutoSwap_PRInt16* pval =
48292:         reinterpret_cast<const AutoSwap_PRInt16*>(base + offset);
48292:     if (reinterpret_cast<const char*>(pval + 1) >= subtableEnd) {
48292:         return 0;
48292:     }
48292:     return *pval;
48292: }
48292: 
48292: // Get kerning value from Apple (version 1.0) kern table,
48292: // subtable format 3 (simple N x M array of kerning values)
48292: 
48292: // See http://developer.apple.com/fonts/TTRefMan/RM06/Chap6kern.html
48292: // for details of version 1.0 format 3 subtable.
48292: 
48292: struct KernHeaderVersion1Fmt3 {
48292:     KernTableSubtableHeaderVersion1 header;
48292:     AutoSwap_PRUint16 glyphCount;
48292:     PRUint8 kernValueCount;
48292:     PRUint8 leftClassCount;
48292:     PRUint8 rightClassCount;
48292:     PRUint8 flags;
48292: };
48292: 
48292: static PRInt16
48292: GetKernValueVersion1Fmt3(const void* aSubtable,
48292:                          PRUint32 aSubtableLen,
48292:                          PRUint16 aFirstGlyph,
48292:                          PRUint16 aSecondGlyph)
48292: {
48292:     // check that we can safely read the header fields
48292:     if (aSubtableLen < sizeof(KernHeaderVersion1Fmt3)) {
48292:         return 0;
48292:     }
48292: 
48292:     const KernHeaderVersion1Fmt3* hdr =
48292:         reinterpret_cast<const KernHeaderVersion1Fmt3*>(aSubtable);
48292:     if (hdr->flags != 0) {
48292:         return 0;
48292:     }
48292: 
48292:     PRUint16 glyphCount = hdr->glyphCount;
48292: 
48292:     // check that table is large enough for the arrays
48292:     if (sizeof(KernHeaderVersion1Fmt3) +
48292:         hdr->kernValueCount * sizeof(PRInt16) +
48292:         glyphCount + glyphCount +
48292:         hdr->leftClassCount * hdr->rightClassCount > aSubtableLen) {
48292:         return 0;
48292:     }
48292:         
48292:     if (aFirstGlyph >= glyphCount || aSecondGlyph >= glyphCount) {
48292:         // glyphs are out of range for the class tables
48292:         return 0;
48292:     }
48292: 
48292:     // get pointers to the four arrays within the subtable
48292:     const AutoSwap_PRInt16* kernValue =
48292:         reinterpret_cast<const AutoSwap_PRInt16*>(hdr + 1);
48292:     const PRUint8* leftClass =
48292:         reinterpret_cast<const PRUint8*>(kernValue + hdr->kernValueCount);
48292:     const PRUint8* rightClass = leftClass + glyphCount;
48292:     const PRUint8* kernIndex = rightClass + glyphCount;
48292: 
48292:     PRUint8 lc = leftClass[aFirstGlyph];
48292:     PRUint8 rc = rightClass[aSecondGlyph];
48292:     if (lc >= hdr->leftClassCount || rc >= hdr->rightClassCount) {
48292:         return 0;
48292:     }
48292: 
48292:     PRUint8 ki = kernIndex[leftClass[aFirstGlyph] * hdr->rightClassCount +
48292:                            rightClass[aSecondGlyph]];
48292:     if (ki >= hdr->kernValueCount) {
48292:         return 0;
48292:     }
48292: 
48292:     return kernValue[ki];
48292: }
48292: 
48292: #define KERN0_COVERAGE_HORIZONTAL   0x0001
48292: #define KERN0_COVERAGE_MINIMUM      0x0002
48292: #define KERN0_COVERAGE_CROSS_STREAM 0x0004
48292: #define KERN0_COVERAGE_OVERRIDE     0x0008
48292: #define KERN0_COVERAGE_RESERVED     0x00F0
48292: 
48292: #define KERN1_COVERAGE_VERTICAL     0x8000
48292: #define KERN1_COVERAGE_CROSS_STREAM 0x4000
48292: #define KERN1_COVERAGE_VARIATION    0x2000
48292: #define KERN1_COVERAGE_RESERVED     0x1F00
48292: 
48292: hb_position_t
48292: gfxHarfBuzzShaper::GetKerning(PRUint16 aFirstGlyph,
48292:                               PRUint16 aSecondGlyph) const
48292: {
48292:     // We want to ignore any kern pairs involving <space>, because we are
48292:     // handling words in isolation, the only space characters seen here are
48292:     // the ones artificially added by the textRun code.
48292:     PRUint32 spaceGlyph = mFont->GetSpaceGlyph();
48292:     if (aFirstGlyph == spaceGlyph || aSecondGlyph == spaceGlyph) {
48292:         return 0;
48292:     }
48292: 
48292:     if (!mKernTable) {
48292:         mKernTable = mFont->GetFontTable(TRUETYPE_TAG('k','e','r','n'));
48292:         if (!mKernTable) {
48292:             mKernTable = hb_blob_create_empty();
48292:         }
48292:     }
48292: 
48292:     PRUint32 len = hb_blob_get_length(mKernTable);
48292:     if (len < sizeof(KernTableVersion0)) {
48292:         return 0;
48292:     }
48292: 
48292:     PRInt32 value = 0;
48292:     const char* base = reinterpret_cast<const char*>(hb_blob_lock(mKernTable));
48292: 
48292:     // First try to interpret as "version 0" kern table
48292:     // (see http://www.microsoft.com/typography/otspec/kern.htm)
48292:     const KernTableVersion0* kern0 =
48292:         reinterpret_cast<const KernTableVersion0*>(base);
48292:     if (PRUint16(kern0->version) == 0) {
48292:         PRUint16 nTables = kern0->nTables;
48292:         PRUint32 offs = sizeof(KernTableVersion0);
48292:         for (PRUint16 i = 0; i < nTables; ++i) {
48292:             if (offs + sizeof(KernTableSubtableHeaderVersion0) > len) {
48292:                 break;
48292:             }
48292:             const KernTableSubtableHeaderVersion0* st0 =
48292:                 reinterpret_cast<const KernTableSubtableHeaderVersion0*>
48292:                                 (base + offs);
48292:             PRUint16 subtableLen = PRUint16(st0->length);
48292:             if (offs + subtableLen > len) {
48292:                 break;
48292:             }
48292:             offs += subtableLen;
48292:             PRUint16 coverage = st0->coverage;
48292:             if (!(coverage & KERN0_COVERAGE_HORIZONTAL)) {
48292:                 // we only care about horizontal kerning (for now)
48292:                 continue;
48292:             }
48292:             if (coverage &
48292:                 (KERN0_COVERAGE_CROSS_STREAM | KERN0_COVERAGE_RESERVED)) {
48292:                 // we don't support cross-stream kerning, and
48292:                 // reserved bits should be zero;
48292:                 // ignore the subtable if not
48292:                 continue;
48292:             }
48292:             PRUint8 format = (coverage >> 8);
48292:             switch (format) {
48292:             case 0:
48292:                 GetKernValueFmt0(st0 + 1, subtableLen - sizeof(*st0),
48292:                                  aFirstGlyph, aSecondGlyph, value,
48292:                                  (coverage & KERN0_COVERAGE_OVERRIDE) != 0,
48292:                                  (coverage & KERN0_COVERAGE_MINIMUM) != 0);
48292:                 break;
48292:             default:
48292:                 // TODO: implement support for other formats,
48292:                 // if they're ever used in practice
48292: #if DEBUG
48292:                 {
48292:                     char buf[1024];
48292:                     sprintf(buf, "unknown kern subtable in %s: "
48292:                                  "ver 0 format %d\n",
48292:                             NS_ConvertUTF16toUTF8(mFont->GetName()).get(),
48292:                             format);
48292:                     NS_WARNING(buf);
48292:                 }
48292: #endif
48292:                 break;
48292:             }
48292:         }
48292:     } else {
48292:         // It wasn't a "version 0" table; check if it is Apple version 1.0
48292:         // (see http://developer.apple.com/fonts/TTRefMan/RM06/Chap6kern.html)
48292:         const KernTableVersion1* kern1 =
48292:             reinterpret_cast<const KernTableVersion1*>(base);
48292:         if (PRUint32(kern1->version) == 0x00010000) {
48292:             PRUint32 nTables = kern1->nTables;
48292:             PRUint32 offs = sizeof(KernTableVersion1);
48292:             for (PRUint32 i = 0; i < nTables; ++i) {
48292:                 if (offs + sizeof(KernTableSubtableHeaderVersion1) > len) {
48292:                     break;
48292:                 }
48292:                 const KernTableSubtableHeaderVersion1* st1 =
48292:                     reinterpret_cast<const KernTableSubtableHeaderVersion1*>
48292:                                     (base + offs);
48292:                 PRUint32 subtableLen = PRUint32(st1->length);
48292:                 offs += subtableLen;
48292:                 PRUint16 coverage = st1->coverage;
48292:                 if (coverage &
48292:                     (KERN1_COVERAGE_VERTICAL     |
48292:                      KERN1_COVERAGE_CROSS_STREAM |
48292:                      KERN1_COVERAGE_VARIATION    |
48292:                      KERN1_COVERAGE_RESERVED)) {
48292:                     // we only care about horizontal kerning (for now),
48292:                     // we don't support cross-stream kerning,
48292:                     // we don't support variations,
48292:                     // reserved bits should be zero;
48292:                     // ignore the subtable if not
48292:                     continue;
48292:                 }
48292:                 PRUint8 format = (coverage & 0xff);
48292:                 switch (format) {
48292:                 case 0:
48292:                     GetKernValueFmt0(st1 + 1, subtableLen - sizeof(*st1),
48292:                                      aFirstGlyph, aSecondGlyph, value);
48292:                     break;
48292:                 case 2:
48292:                     value = GetKernValueVersion1Fmt2(st1, subtableLen,
48292:                                                      aFirstGlyph, aSecondGlyph);
48292:                     break;
48292:                 case 3:
48292:                     value = GetKernValueVersion1Fmt3(st1, subtableLen,
48292:                                                      aFirstGlyph, aSecondGlyph);
48292:                     break;
48292:                 default:
48292:                     // TODO: implement support for other formats.
48292:                     // Note that format 1 cannot be supported here,
48292:                     // as it requires the full glyph array to run the FSM,
48292:                     // not just the current glyph pair.
48292: #if DEBUG
48292:                     {
48292:                         char buf[1024];
48292:                         sprintf(buf, "unknown kern subtable in %s: "
48292:                                      "ver 0 format %d\n",
48292:                                 NS_ConvertUTF16toUTF8(mFont->GetName()).get(),
48292:                                 format);
48292:                         NS_WARNING(buf);
48292:                     }
48292: #endif
48292:                     break;
48292:                 }
48292:             }
48292:         }
48292:     }
48292: 
48292:     hb_blob_unlock(mKernTable);
48292: 
48292:     if (value != 0) {
48292:         return FloatToFixed(mFont->FUnitsToDevUnitsFactor() * value);
48292:     }
48292:     return 0;
48292: }
48292: 
43527: static hb_position_t
43527: HBGetKerning(hb_font_t *font, hb_face_t *face, const void *user_data,
43527:              hb_codepoint_t first_glyph, hb_codepoint_t second_glyph)
43527: {
48292:     const FontCallbackData *fcd =
48292:         static_cast<const FontCallbackData*>(user_data);
48292:     return fcd->mShaper->GetKerning(first_glyph, second_glyph);
43527: }
43527: 
43527: /*
43527:  * HarfBuzz unicode property callbacks
43527:  */
43527: 
43527: static hb_codepoint_t
43527: HBGetMirroring(hb_codepoint_t aCh)
43527: {
43527:     return gfxUnicodeProperties::GetMirroredChar(aCh);
43527: }
43527: 
43527: static hb_category_t
43527: HBGetGeneralCategory(hb_codepoint_t aCh)
43527: {
43527:     return hb_category_t(gfxUnicodeProperties::GetGeneralCategory(aCh));
43527: }
43527: 
43527: static hb_script_t
43527: HBGetScript(hb_codepoint_t aCh)
43527: {
43527:     return hb_script_t(gfxUnicodeProperties::GetScriptCode(aCh));
43527: }
43527: 
43527: static unsigned int
43527: HBGetCombiningClass(hb_codepoint_t aCh)
43527: {
43527:     return gfxUnicodeProperties::GetCombiningClass(aCh);
43527: }
43527: 
43527: static unsigned int
43527: HBGetEastAsianWidth(hb_codepoint_t aCh)
43527: {
43527:     return gfxUnicodeProperties::GetEastAsianWidth(aCh);
43527: }
43527: 
43527: /*
43527:  * gfxFontShaper override to initialize the text run using HarfBuzz
43527:  */
43527: 
43527: static hb_font_funcs_t * sHBFontFuncs = nsnull;
43527: static hb_unicode_funcs_t * sHBUnicodeFuncs = nsnull;
43527: 
43527: PRBool
43527: gfxHarfBuzzShaper::InitTextRun(gfxContext *aContext,
43527:                                gfxTextRun *aTextRun,
43527:                                const PRUnichar *aString,
43527:                                PRUint32 aRunStart,
43527:                                PRUint32 aRunLength,
43527:                                PRInt32 aRunScript)
43527: {
43527:     // some font back-ends require this in order to get proper hinted metrics
43527:     mFont->SetupCairoFont(aContext);
43527: 
43527:     if (!mHBFace) {
43673:         // set up the harfbuzz face etc the first time we use the font
43673: 
43527:         if (!sHBFontFuncs) {
43527:             // static function callback pointers, initialized by the first
43527:             // harfbuzz shaper used
43527:             sHBFontFuncs = hb_font_funcs_copy(hb_font_funcs_create());
43527:             hb_font_funcs_set_glyph_func(sHBFontFuncs, HBGetGlyph);
43527:             hb_font_funcs_set_glyph_metrics_func(sHBFontFuncs,
43527:                                                  HBGetGlyphMetrics);
43527:             hb_font_funcs_set_contour_point_func(sHBFontFuncs,
43527:                                                  HBGetContourPoint);
43527:             hb_font_funcs_set_kerning_func(sHBFontFuncs, HBGetKerning);
43527: 
43527:             sHBUnicodeFuncs = hb_unicode_funcs_copy(hb_unicode_funcs_create());
43527:             hb_unicode_funcs_set_mirroring_func(sHBUnicodeFuncs,
43527:                                                 HBGetMirroring);
43527:             hb_unicode_funcs_set_script_func(sHBUnicodeFuncs, HBGetScript);
43527:             hb_unicode_funcs_set_general_category_func(sHBUnicodeFuncs,
43527:                                                        HBGetGeneralCategory);
43527:             hb_unicode_funcs_set_combining_class_func(sHBUnicodeFuncs,
43527:                                                       HBGetCombiningClass);
43527:             hb_unicode_funcs_set_eastasian_width_func(sHBUnicodeFuncs,
43527:                                                       HBGetEastAsianWidth);
43527:         }
43527: 
43527:         mHBFace = hb_face_create_for_tables(HBGetTable, nsnull, this);
43673: 
43673:         // get the cmap table and find offset to our subtable
43673:         mCmapTable = mFont->GetFontTable(TRUETYPE_TAG('c','m','a','p'));
43673:         if (!mCmapTable) {
43673:             NS_WARNING("failed to load cmap, glyphs will be missing");
43673:             return PR_FALSE;
43673:         }
43673:         const PRUint8* data = (const PRUint8*)hb_blob_lock(mCmapTable);
43673:         PRBool symbol;
43673:         mCmapFormat =
43673:             gfxFontUtils::FindPreferredSubtable(data,
43673:                                                 hb_blob_get_length(mCmapTable),
43673:                                                 &mSubtableOffset,
43673:                                                 &mUVSTableOffset,
43673:                                                 &symbol);
43673:         hb_blob_unlock(mCmapTable);
43673: 
43673:         if (!mUseHintedWidths) {
43673:             // if font doesn't implement hinted widths, we will be reading
43673:             // the hmtx table directly;
43673:             // read mNumLongMetrics from hhea table without caching its blob,
43673:             // and preload/cache the hmtx table
43673:             hb_blob_t *hheaTable =
43673:                 mFont->GetFontTable(TRUETYPE_TAG('h','h','e','a'));
43673:             if (hheaTable &&
43673:                 hb_blob_get_length(hheaTable) >= sizeof(HMetricsHeader)) {
43673:                 const HMetricsHeader* hhea =
43673:                     reinterpret_cast<const HMetricsHeader*>
43673:                         (hb_blob_lock(hheaTable));
43673:                 mNumLongMetrics = hhea->numberOfHMetrics;
43673:                 hb_blob_unlock(hheaTable);
43673: 
48070:                 if (mNumLongMetrics > 0 &&
48070:                     PRInt16(hhea->metricDataFormat) == 0) {
48070:                     // no point reading hmtx if number of entries is zero!
48070:                     // in that case, we won't be able to use this font
48070:                     // (this method will return FALSE below if mHmtx is null)
43673:                     mHmtxTable =
43673:                         mFont->GetFontTable(TRUETYPE_TAG('h','m','t','x'));
48070:                     if (hb_blob_get_length(mHmtxTable) <
48070:                         mNumLongMetrics * sizeof(HLongMetric)) {
48070:                         // hmtx table is not large enough for the claimed
48070:                         // number of entries: invalid, do not use.
48070:                         hb_blob_destroy(mHmtxTable);
48070:                         mHmtxTable = nsnull;
48070:                     }
48070:                 }
43673:             }
43673:             hb_blob_destroy(hheaTable);
43673:         }
47360: 
47360:         if (mFont->GetStyle()->languageOverride) {
47360:             mHBLanguage =
47360:                 hb_ot_tag_to_language(mFont->GetStyle()->languageOverride);
47360:         } else if (mFont->GetFontEntry()->mLanguageOverride) {
47360:             mHBLanguage =
47360:                 hb_ot_tag_to_language(mFont->GetFontEntry()->mLanguageOverride);
47360:         } else {
47360:             nsCString langString;
47360:             mFont->GetStyle()->language->ToUTF8String(langString);
47360:             mHBLanguage = hb_language_from_string(langString.get());
47360:         }
43673:     }
43673: 
43673:     if (mCmapFormat <= 0 || (!mUseHintedWidths && !mHmtxTable)) {
43673:         // unable to shape with this font
43673:         return PR_FALSE;
43527:     }
43527: 
43527:     FontCallbackData fcd(this, aContext);
43527:     hb_font_t *font = hb_font_create();
43527:     hb_font_set_funcs(font, sHBFontFuncs, nsnull, &fcd);
43527:     hb_font_set_ppem(font, mFont->GetAdjustedSize(), mFont->GetAdjustedSize());
43527:     PRUint32 scale = FloatToFixed(mFont->GetAdjustedSize()); // 16.16 fixed-point
43527:     hb_font_set_scale(font, scale, scale);
43527: 
43527:     // aRunStart and aRunLength define the section of the textRun and of
43527:     // aString that is to be drawn with this particular font
43527: 
43527:     PRBool disableLigatures =
43527:         (aTextRun->GetFlags() &
43527:          gfxTextRunFactory::TEXT_DISABLE_OPTIONAL_LIGATURES) != 0;
43527: 
43527:     nsAutoTArray<hb_feature_t,20> features;
43527: 
43527:     // Ligature features are enabled by default in the generic shaper,
43527:     // so we explicitly turn them off if necessary (for letter-spacing)
43527:     if (disableLigatures) {
43527:         hb_feature_t ligaOff = { HB_TAG('l','i','g','a'), 0, 0, -1 };
43527:         hb_feature_t cligOff = { HB_TAG('c','l','i','g'), 0, 0, -1 };
43527:         features.AppendElement(ligaOff);
43527:         features.AppendElement(cligOff);
43527:     }
43527: 
47360:     // css features need to be merged with the existing ones, if any
47360:     const nsTArray<gfxFontFeature> *cssFeatures =
47360:         mFont->GetStyle()->featureSettings;
47360:     if (!cssFeatures) {
47360:         cssFeatures = mFont->GetFontEntry()->mFeatureSettings;
47360:     }
47360:     if (cssFeatures) {
47360:         for (PRUint32 i = 0; i < cssFeatures->Length(); ++i) {
47360:             PRUint32 j;
47360:             for (j = 0; j < features.Length(); ++j) {
47360:                 if (cssFeatures->ElementAt(i).mTag == features[j].tag) {
47360:                     features[j].value = cssFeatures->ElementAt(i).mValue;
47360:                     break;
47360:                 }
47360:             }
47360:             if (j == features.Length()) {
47360:                 const gfxFontFeature& f = cssFeatures->ElementAt(i);
47360:                 hb_feature_t hbf = { f.mTag, f.mValue, 0, -1 };
47360:                 features.AppendElement(hbf);
47360:             }
47360:         }
47360:     }
47360: 
43527:     hb_buffer_t *buffer = hb_buffer_create(aRunLength);
43527:     hb_buffer_set_unicode_funcs(buffer, sHBUnicodeFuncs);
43527:     hb_buffer_set_direction(buffer,
43527:                             aTextRun->IsRightToLeft() ?
43527:                                 HB_DIRECTION_RTL : HB_DIRECTION_LTR);
43527:     hb_buffer_set_script(buffer, hb_script_t(aRunScript));
47360:     hb_buffer_set_language(buffer, mHBLanguage);
43527: 
46211:     hb_buffer_add_utf16(buffer, reinterpret_cast<const uint16_t*>(aString + aRunStart),
46211:                         aRunLength, 0, aRunLength);
43527: 
43527:     hb_shape(font, mHBFace, buffer, features.Elements(), features.Length());
43527: 
43527:     if (aTextRun->IsRightToLeft()) {
43527:         hb_buffer_reverse(buffer);
43527:     }
43527: 
43527:     nsresult rv = SetGlyphsFromRun(aContext, aTextRun, buffer,
43527:                                    aRunStart, aRunLength);
43527:     NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "failed to store glyphs into textrun");
43527:     hb_buffer_destroy(buffer);
43527:     hb_font_destroy(font);
43527: 
43527:     return PR_TRUE;
43527: }
43527: 
43527: #define SMALL_GLYPH_RUN 128 // some testing indicates that 90%+ of text runs
43527:                             // will fit without requiring separate allocation
43527:                             // for charToGlyphArray
43527: 
43527: nsresult
43527: gfxHarfBuzzShaper::SetGlyphsFromRun(gfxContext *aContext,
43527:                                     gfxTextRun *aTextRun,
43527:                                     hb_buffer_t *aBuffer,
43527:                                     PRUint32 aTextRunOffset,
43527:                                     PRUint32 aRunLength)
43527: {
43527:     PRInt32 numGlyphs = hb_buffer_get_length(aBuffer);
43527:     if (numGlyphs == 0)
43527:         return NS_OK;
43527: 
43527:     const hb_glyph_info_t *ginfo = hb_buffer_get_glyph_infos(aBuffer);
43527: 
43527:     nsAutoTArray<gfxTextRun::DetailedGlyph,1> detailedGlyphs;
43527: 
43527:     static const PRInt32 NO_GLYPH = -1;
43527:     nsAutoTArray<PRInt32,SMALL_GLYPH_RUN> charToGlyphArray;
43527:     if (!charToGlyphArray.SetLength(aRunLength))
43527:         return NS_ERROR_OUT_OF_MEMORY;
43527: 
43527:     PRInt32 *charToGlyph = charToGlyphArray.Elements();
43527:     for (PRUint32 offset = 0; offset < aRunLength; ++offset) {
43527:         charToGlyph[offset] = NO_GLYPH;
43527:     }
43527: 
43527:     for (PRInt32 i = 0; i < numGlyphs; ++i) {
43527:         PRInt32 loc = ginfo[i].cluster;
43527:         if (loc < aRunLength) {
43527:             charToGlyph[loc] = i;
43527:         }
43527:     }
43527: 
43527:     PRInt32 glyphStart = 0; // looking for a clump that starts at this glyph
43527:     PRInt32 charStart = 0; // and this char index within the range of the run
43527: 
48292:     // factor to convert 16.16 fixed-point pixels to app units
48292:     float hb2appUnits = aTextRun->GetAppUnitsPerDevUnit() / 65536.0;
48292: 
48292:     // keep track of y-position to set glyph offsets if needed
48292:     nscoord yPos = 0;
48292: 
48292:     const hb_glyph_position_t *posInfo = hb_buffer_get_glyph_positions(aBuffer);
48292: 
43527:     while (glyphStart < numGlyphs) {
43527: 
43527:         PRBool inOrder = PR_TRUE;
43527:         PRInt32 charEnd = ginfo[glyphStart].cluster;
43527:         PRInt32 glyphEnd = glyphStart;
43527:         PRInt32 charLimit = aRunLength;
43527:         while (charEnd < charLimit) {
43527:             // This is normally executed once for each iteration of the outer loop,
43527:             // but in unusual cases where the character/glyph association is complex,
43527:             // the initial character range might correspond to a non-contiguous
43527:             // glyph range with "holes" in it. If so, we will repeat this loop to
43527:             // extend the character range until we have a contiguous glyph sequence.
43527:             charEnd += 1;
43527:             while (charEnd != charLimit && charToGlyph[charEnd] == NO_GLYPH) {
43527:                 charEnd += 1;
43527:             }
43527: 
43527:             // find the maximum glyph index covered by the clump so far
43527:             for (PRInt32 i = charStart; i < charEnd; ++i) {
43527:                 if (charToGlyph[i] != NO_GLYPH) {
43527:                     glyphEnd = PR_MAX(glyphEnd, charToGlyph[i] + 1);
43527:                     // update extent of glyph range
43527:                 }
43527:             }
43527: 
43527:             if (glyphEnd == glyphStart + 1) {
43527:                 // for the common case of a single-glyph clump,
43527:                 // we can skip the following checks
43527:                 break;
43527:             }
43527: 
43527:             if (glyphEnd == glyphStart) {
43527:                 // no glyphs, try to extend the clump
43527:                 continue;
43527:             }
43527: 
43527:             // check whether all glyphs in the range are associated with the characters
43527:             // in our clump; if not, we have a discontinuous range, and should extend it
43527:             // unless we've reached the end of the text
43527:             PRBool allGlyphsAreWithinCluster = PR_TRUE;
43527:             PRInt32 prevGlyphCharIndex = charStart - 1;
43527:             for (PRInt32 i = glyphStart; i < glyphEnd; ++i) {
43527:                 PRInt32 glyphCharIndex = ginfo[i].cluster;
43527:                 if (glyphCharIndex < charStart || glyphCharIndex >= charEnd) {
43527:                     allGlyphsAreWithinCluster = PR_FALSE;
43527:                     break;
43527:                 }
43527:                 if (glyphCharIndex <= prevGlyphCharIndex) {
43527:                     inOrder = PR_FALSE;
43527:                 }
43527:                 prevGlyphCharIndex = glyphCharIndex;
43527:             }
43527:             if (allGlyphsAreWithinCluster) {
43527:                 break;
43527:             }
43527:         }
43527: 
43527:         NS_ASSERTION(glyphStart < glyphEnd,
43527:                      "character/glyph clump contains no glyphs!");
43527:         NS_ASSERTION(charStart != charEnd,
43527:                      "character/glyph clump contains no characters!");
43527: 
43527:         // Now charStart..charEnd is a ligature clump, corresponding to glyphStart..glyphEnd;
43527:         // Set baseCharIndex to the char we'll actually attach the glyphs to (1st of ligature),
43527:         // and endCharIndex to the limit (position beyond the last char),
43527:         // adjusting for the offset of the stringRange relative to the textRun.
43527:         PRInt32 baseCharIndex, endCharIndex;
43527:         while (charEnd < aRunLength && charToGlyph[charEnd] == NO_GLYPH)
43527:             charEnd++;
43527:         baseCharIndex = charStart;
43527:         endCharIndex = charEnd;
43527: 
43527:         // Then we check if the clump falls outside our actual string range;
43527:         // if so, just go to the next.
43527:         if (baseCharIndex >= aRunLength) {
43527:             glyphStart = glyphEnd;
43527:             charStart = charEnd;
43527:             continue;
43527:         }
43527:         // Ensure we won't try to go beyond the valid length of the textRun's text
43527:         endCharIndex = PR_MIN(endCharIndex, aRunLength);
43527: 
48292:         // Now we're ready to set the glyph info in the textRun
43527:         PRInt32 glyphsInClump = glyphEnd - glyphStart;
43527: 
43527:         // Check for default-ignorable char that didn't get filtered, combined,
43527:         // etc by the shaping process, and remove from the run.
43527:         // (This may be done within harfbuzz eventually.)
43527:         if (glyphsInClump == 1 && baseCharIndex + 1 == endCharIndex &&
43527:             aTextRun->FilterIfIgnorable(aTextRunOffset + baseCharIndex)) {
43527:             glyphStart = glyphEnd;
43527:             charStart = charEnd;
43527:             continue;
43527:         }
43527: 
43527:         // Check if it's a simple one-to-one mapping
48292:         nscoord advance = NS_roundf(hb2appUnits * posInfo[glyphStart].x_advance);
43527:         if (glyphsInClump == 1 &&
43527:             gfxTextRun::CompressedGlyph::IsSimpleGlyphID(ginfo[glyphStart].codepoint) &&
43527:             gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&
43527:             aTextRun->IsClusterStart(aTextRunOffset + baseCharIndex) &&
48292:             posInfo[glyphStart].x_offset == 0 &&
48292:             posInfo[glyphStart].y_offset == 0 && yPos == 0)
43527:         {
43527:             gfxTextRun::CompressedGlyph g;
43527:             aTextRun->SetSimpleGlyph(aTextRunOffset + baseCharIndex,
43527:                                      g.SetSimpleGlyph(advance,
43527:                                          ginfo[glyphStart].codepoint));
43527:         } else {
43527:             // collect all glyphs in a list to be assigned to the first char;
43527:             // there must be at least one in the clump, and we already measured
43527:             // its advance, hence the placement of the loop-exit test and the
43527:             // measurement of the next glyph
43527:             while (1) {
43527:                 gfxTextRun::DetailedGlyph* details =
43527:                     detailedGlyphs.AppendElement();
43527:                 details->mGlyphID = ginfo[glyphStart].codepoint;
48292:                 details->mXOffset = posInfo[glyphStart].x_offset == 0 ?
48292:                                         0 : hb2appUnits * posInfo[glyphStart].x_offset;
48292:                 details->mYOffset = yPos - (posInfo[glyphStart].y_offset == 0 ?
48292:                                         0 : hb2appUnits * posInfo[glyphStart].y_offset);
43527:                 details->mAdvance = advance;
48292:                 if (posInfo[glyphStart].y_advance != 0) {
48292:                     yPos -= hb2appUnits * posInfo[glyphStart].y_advance;
48292:                 }
48292:                 if (++glyphStart >= glyphEnd) {
43527:                     break;
43527:                 }
48292:                 advance = NS_roundf(hb2appUnits * posInfo[glyphStart].x_advance);
43527:             }
43527: 
43527:             gfxTextRun::CompressedGlyph g;
43527:             g.SetComplex(aTextRun->IsClusterStart(aTextRunOffset + baseCharIndex),
43527:                          PR_TRUE, detailedGlyphs.Length());
43527:             aTextRun->SetGlyphs(aTextRunOffset + baseCharIndex,
43527:                                 g, detailedGlyphs.Elements());
43527: 
43527:             detailedGlyphs.Clear();
43527:         }
43527: 
43527:         // the rest of the chars in the group are ligature continuations,
43527:         // no associated glyphs
43527:         while (++baseCharIndex != endCharIndex && baseCharIndex < aRunLength) {
43527:             gfxTextRun::CompressedGlyph g;
43527:             g.SetComplex(inOrder &&
43527:                          aTextRun->IsClusterStart(aTextRunOffset + baseCharIndex),
43527:                          PR_FALSE, 0);
43527:             aTextRun->SetGlyphs(aTextRunOffset + baseCharIndex, g, nsnull);
43527:         }
43527: 
43527:         glyphStart = glyphEnd;
43527:         charStart = charEnd;
43527:     }
43527: 
43527:     return NS_OK;
43527: }
