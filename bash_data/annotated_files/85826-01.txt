43629: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
41369: /* ***** BEGIN LICENSE BLOCK *****
41369:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
41369:  *
41369:  * The contents of this file are subject to the Mozilla Public License Version
41369:  * 1.1 (the "License"); you may not use this file except in compliance with
41369:  * the License. You may obtain a copy of the License at
41369:  * http://www.mozilla.org/MPL/
41369:  *
41369:  * Software distributed under the License is distributed on an "AS IS" basis,
41369:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
41369:  * for the specific language governing rights and limitations under the
41369:  * License.
41369:  *
41369:  * The Original Code is mozilla.org code.
41369:  *
41369:  * The Initial Developer of the Original Code is
60123:  * the Mozilla Foundation.
41369:  * Portions created by the Initial Developer are Copyright (C) 2009
41369:  * the Initial Developer. All Rights Reserved.
41369:  *
41369:  * Contributor(s):
41369:  *   Vladimir Vukicevic <vladimir@pobox.com>
41369:  *   Mark Steele <mwsteele@gmail.com>
41369:  *   Bas Schouten <bschouten@mozilla.com>
41369:  *
41369:  * Alternatively, the contents of this file may be used under the terms of
41369:  * either the GNU General Public License Version 2 or later (the "GPL"), or
41369:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
41369:  * in which case the provisions of the GPL or the LGPL are applicable instead
41369:  * of those above. If you wish to allow use of your version of this file only
41369:  * under the terms of either the GPL or the LGPL, and not to allow others to
41369:  * use your version of this file under the terms of the MPL, indicate your
41369:  * decision by deleting the provisions above and replace them with the notice
41369:  * and other provisions required by the GPL or the LGPL. If you do not delete
41369:  * the provisions above, a recipient may use your version of this file under
41369:  * the terms of any one of the MPL, the GPL or the LGPL.
41369:  *
41369:  * ***** END LICENSE BLOCK ***** */
41369: 
41369: 
41369: #include <string.h>
41369: #include <stdio.h>
41369: 
41369: #include "prlink.h"
55380: #include "prenv.h"
41369: 
53690: #include "nsThreadUtils.h"
53690: 
59442: #include "gfxPlatform.h"
41369: #include "GLContext.h"
42402: #include "GLContextProvider.h"
41369: 
63285: #include "gfxCrashReporterUtils.h"
73465: #include "gfxUtils.h"
63285: 
72361: #include "mozilla/Util.h" // for DebugOnly
72361: 
41369: namespace mozilla {
41369: namespace gl {
41369: 
55380: #ifdef DEBUG
55380: // see comment near declaration in GLContext.h. Should be thread-local.
55380: GLContext* GLContext::sCurrentGLContext = nsnull;
55380: #endif
55380: 
42402: // define this here since it's global to GLContextProvider, not any
42402: // specific implementation
42402: const ContextFormat ContextFormat::BasicRGBA32Format(ContextFormat::BasicRGBA32);
42402: 
41369: #define MAX_SYMBOL_LENGTH 128
41369: #define MAX_SYMBOL_NAMES 5
41369: 
82479: // should match the order of GLExtensions
82479: static const char *sExtensionNames[] = {
82479:     "GL_EXT_framebuffer_object",
82479:     "GL_ARB_framebuffer_object",
82479:     "GL_ARB_texture_rectangle",
82479:     "GL_EXT_bgra",
82479:     "GL_EXT_texture_format_BGRA8888",
82479:     "GL_OES_depth24",
82479:     "GL_OES_depth32",
82479:     "GL_OES_stencil8",
82479:     "GL_OES_texture_npot",
82479:     "GL_OES_depth_texture",
82479:     "GL_OES_packed_depth_stencil",
82479:     "GL_IMG_read_format",
82479:     "GL_EXT_read_format_bgra",
82479:     "GL_APPLE_client_storage",
82479:     "GL_ARB_texture_non_power_of_two",
82479:     "GL_ARB_pixel_buffer_object",
82479:     "GL_ARB_ES2_compatibility",
82479:     "GL_OES_texture_float",
82479:     "GL_ARB_texture_float",
82479:     "GL_EXT_unpack_subimage",
82479:     "GL_OES_standard_derivatives",
82479:     "GL_EXT_framebuffer_blit",
82479:     "GL_ANGLE_framebuffer_blit",
82479:     "GL_EXT_framebuffer_multisample",
82479:     "GL_ANGLE_framebuffer_multisample",
82479:     "GL_OES_rgb8_rgba8",
82479:     "GL_ARB_robustness",
84592:     "GL_EXT_robustness",
82479:     NULL
82479: };
82479: 
79445: bool
41369: LibrarySymbolLoader::OpenLibrary(const char *library)
41369: {
41369:     PRLibSpec lspec;
41369:     lspec.type = PR_LibSpec_Pathname;
41369:     lspec.value.pathname = library;
41369: 
41369:     mLibrary = PR_LoadLibraryWithFlags(lspec, PR_LD_LAZY | PR_LD_LOCAL);
41369:     if (!mLibrary)
80486:         return false;
41369: 
80486:     return true;
42402: }
42402: 
79445: bool
79445: LibrarySymbolLoader::LoadSymbols(SymLoadStruct *firstStruct, bool tryplatform, const char *prefix)
42402: {
42402:     return LoadSymbols(mLibrary, firstStruct, tryplatform ? mLookupFunc : nsnull, prefix);
41369: }
41369: 
41369: PRFuncPtr
42402: LibrarySymbolLoader::LookupSymbol(PRLibrary *lib,
42402:                                   const char *sym,
42402:                                   PlatformLookupFunction lookupFunction)
41369: {
41369:     PRFuncPtr res = 0;
41369: 
41369:     // try finding it in the library directly, if we have one
42402:     if (lib) {
42402:         res = PR_FindFunctionSymbol(lib, sym);
41369:     }
41369: 
47911:     // then try looking it up via the lookup symbol
47911:     if (!res && lookupFunction) {
47911:         res = lookupFunction(sym);
47911:     }
47911: 
47911:     // finally just try finding it in the process
41369:     if (!res) {
41369:         PRLibrary *leakedLibRef;
41369:         res = PR_FindFunctionSymbolAndLibrary(sym, &leakedLibRef);
41369:     }
41369: 
41369:     return res;
41369: }
41369: 
79445: bool
42402: LibrarySymbolLoader::LoadSymbols(PRLibrary *lib,
42402:                                  SymLoadStruct *firstStruct,
42402:                                  PlatformLookupFunction lookupFunction,
42402:                                  const char *prefix)
41369: {
41369:     char sbuf[MAX_SYMBOL_LENGTH * 2];
47908:     int failCount = 0;
41369: 
41369:     SymLoadStruct *ss = firstStruct;
41369:     while (ss->symPointer) {
41369:         *ss->symPointer = 0;
41369: 
41369:         for (int i = 0; i < MAX_SYMBOL_NAMES; i++) {
41369:             if (ss->symNames[i] == nsnull)
41369:                 break;
41369: 
41369:             const char *s = ss->symNames[i];
41369:             if (prefix && *prefix != 0) {
41369:                 strcpy(sbuf, prefix);
41369:                 strcat(sbuf, ss->symNames[i]);
41369:                 s = sbuf;
41369:             }
41369: 
42402:             PRFuncPtr p = LookupSymbol(lib, s, lookupFunction);
41369:             if (p) {
41369:                 *ss->symPointer = p;
41369:                 break;
41369:             }
41369:         }
41369: 
41369:         if (*ss->symPointer == 0) {
41369:             fprintf (stderr, "Can't find symbol '%s'\n", ss->symNames[0]);
47908:             failCount++;
41369:         }
41369: 
41369:         ss++;
41369:     }
41369: 
80486:     return failCount == 0 ? true : false;
41369: }
41369: 
41369: /*
41369:  * XXX - we should really know the ARB/EXT variants of these
41369:  * instead of only handling the symbol if it's exposed directly.
41369:  */
41369: 
79445: bool
79445: GLContext::InitWithPrefix(const char *prefix, bool trygl)
41369: {
63285:     ScopedGfxFeatureReporter reporter("GL Context");
63285: 
41369:     if (mInitialized) {
63285:         reporter.SetSuccessful();
80486:         return true;
41369:     }
41369: 
41369:     SymLoadStruct symbols[] = {
55380:         { (PRFuncPtr*) &mSymbols.fActiveTexture, { "ActiveTexture", "ActiveTextureARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fAttachShader, { "AttachShader", "AttachShaderARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBindAttribLocation, { "BindAttribLocation", "BindAttribLocationARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBindBuffer, { "BindBuffer", "BindBufferARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBindTexture, { "BindTexture", "BindTextureARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBlendColor, { "BlendColor", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBlendEquation, { "BlendEquation", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBlendEquationSeparate, { "BlendEquationSeparate", "BlendEquationSeparateEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBlendFunc, { "BlendFunc", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBlendFuncSeparate, { "BlendFuncSeparate", "BlendFuncSeparateEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBufferData, { "BufferData", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBufferSubData, { "BufferSubData", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fClear, { "Clear", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fClearColor, { "ClearColor", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fClearStencil, { "ClearStencil", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fColorMask, { "ColorMask", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fCullFace, { "CullFace", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDetachShader, { "DetachShader", "DetachShaderARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDepthFunc, { "DepthFunc", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDepthMask, { "DepthMask", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDisable, { "Disable", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDisableVertexAttribArray, { "DisableVertexAttribArray", "DisableVertexAttribArrayARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDrawArrays, { "DrawArrays", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDrawElements, { "DrawElements", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fEnable, { "Enable", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fEnableVertexAttribArray, { "EnableVertexAttribArray", "EnableVertexAttribArrayARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fFinish, { "Finish", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fFlush, { "Flush", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fFrontFace, { "FrontFace", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetActiveAttrib, { "GetActiveAttrib", "GetActiveAttribARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetActiveUniform, { "GetActiveUniform", "GetActiveUniformARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetAttachedShaders, { "GetAttachedShaders", "GetAttachedShadersARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetAttribLocation, { "GetAttribLocation", "GetAttribLocationARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetIntegerv, { "GetIntegerv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetFloatv, { "GetFloatv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetBooleanv, { "GetBooleanv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetBufferParameteriv, { "GetBufferParameteriv", "GetBufferParameterivARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetError, { "GetError", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetProgramiv, { "GetProgramiv", "GetProgramivARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetProgramInfoLog, { "GetProgramInfoLog", "GetProgramInfoLogARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fTexParameteri, { "TexParameteri", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fTexParameterf, { "TexParameterf", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetString, { "GetString", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetTexParameterfv, { "GetTexParameterfv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetTexParameteriv, { "GetTexParameteriv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetUniformfv, { "GetUniformfv", "GetUniformfvARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetUniformiv, { "GetUniformiv", "GetUniformivARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetUniformLocation, { "GetUniformLocation", "GetUniformLocationARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetVertexAttribfv, { "GetVertexAttribfv", "GetVertexAttribfvARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetVertexAttribiv, { "GetVertexAttribiv", "GetVertexAttribivARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fHint, { "Hint", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fIsBuffer, { "IsBuffer", "IsBufferARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fIsEnabled, { "IsEnabled", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fIsProgram, { "IsProgram", "IsProgramARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fIsShader, { "IsShader", "IsShaderARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fIsTexture, { "IsTexture", "IsTextureARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fLineWidth, { "LineWidth", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fLinkProgram, { "LinkProgram", "LinkProgramARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fPixelStorei, { "PixelStorei", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fPolygonOffset, { "PolygonOffset", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fReadPixels, { "ReadPixels", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fSampleCoverage, { "SampleCoverage", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fScissor, { "Scissor", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fStencilFunc, { "StencilFunc", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fStencilFuncSeparate, { "StencilFuncSeparate", "StencilFuncSeparateEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fStencilMask, { "StencilMask", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fStencilMaskSeparate, { "StencilMaskSeparate", "StencilMaskSeparateEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fStencilOp, { "StencilOp", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fStencilOpSeparate, { "StencilOpSeparate", "StencilOpSeparateEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fTexImage2D, { "TexImage2D", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fTexSubImage2D, { "TexSubImage2D", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform1f, { "Uniform1f", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform1fv, { "Uniform1fv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform1i, { "Uniform1i", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform1iv, { "Uniform1iv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform2f, { "Uniform2f", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform2fv, { "Uniform2fv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform2i, { "Uniform2i", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform2iv, { "Uniform2iv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform3f, { "Uniform3f", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform3fv, { "Uniform3fv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform3i, { "Uniform3i", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform3iv, { "Uniform3iv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform4f, { "Uniform4f", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform4fv, { "Uniform4fv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform4i, { "Uniform4i", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniform4iv, { "Uniform4iv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniformMatrix2fv, { "UniformMatrix2fv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniformMatrix3fv, { "UniformMatrix3fv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUniformMatrix4fv, { "UniformMatrix4fv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fUseProgram, { "UseProgram", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fValidateProgram, { "ValidateProgram", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fVertexAttribPointer, { "VertexAttribPointer", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fVertexAttrib1f, { "VertexAttrib1f", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fVertexAttrib2f, { "VertexAttrib2f", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fVertexAttrib3f, { "VertexAttrib3f", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fVertexAttrib4f, { "VertexAttrib4f", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fVertexAttrib1fv, { "VertexAttrib1fv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fVertexAttrib2fv, { "VertexAttrib2fv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fVertexAttrib3fv, { "VertexAttrib3fv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fVertexAttrib4fv, { "VertexAttrib4fv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fViewport, { "Viewport", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fCompileShader, { "CompileShader", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fCopyTexImage2D, { "CopyTexImage2D", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fCopyTexSubImage2D, { "CopyTexSubImage2D", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetShaderiv, { "GetShaderiv", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetShaderInfoLog, { "GetShaderInfoLog", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetShaderSource, { "GetShaderSource", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fShaderSource, { "ShaderSource", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fVertexAttribPointer, { "VertexAttribPointer", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBindFramebuffer, { "BindFramebuffer", "BindFramebufferEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fBindRenderbuffer, { "BindRenderbuffer", "BindRenderbufferEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fCheckFramebufferStatus, { "CheckFramebufferStatus", "CheckFramebufferStatusEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fFramebufferRenderbuffer, { "FramebufferRenderbuffer", "FramebufferRenderbufferEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fFramebufferTexture2D, { "FramebufferTexture2D", "FramebufferTexture2DEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGenerateMipmap, { "GenerateMipmap", "GenerateMipmapEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetFramebufferAttachmentParameteriv, { "GetFramebufferAttachmentParameteriv", "GetFramebufferAttachmentParameterivEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGetRenderbufferParameteriv, { "GetRenderbufferParameteriv", "GetRenderbufferParameterivEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fIsFramebuffer, { "IsFramebuffer", "IsFramebufferEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fIsRenderbuffer, { "IsRenderbuffer", "IsRenderbufferEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fRenderbufferStorage, { "RenderbufferStorage", "RenderbufferStorageEXT", NULL } },
47908: 
55380:         { (PRFuncPtr*) &mSymbols.fGenBuffers, { "GenBuffers", "GenBuffersARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGenTextures, { "GenTextures", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fCreateProgram, { "CreateProgram", "CreateProgramARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fCreateShader, { "CreateShader", "CreateShaderARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGenFramebuffers, { "GenFramebuffers", "GenFramebuffersEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fGenRenderbuffers, { "GenRenderbuffers", "GenRenderbuffersEXT", NULL } },
47908: 
55380:         { (PRFuncPtr*) &mSymbols.fDeleteBuffers, { "DeleteBuffers", "DeleteBuffersARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDeleteTextures, { "DeleteTextures", "DeleteTexturesARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDeleteProgram, { "DeleteProgram", "DeleteProgramARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDeleteShader, { "DeleteShader", "DeleteShaderARB", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDeleteFramebuffers, { "DeleteFramebuffers", "DeleteFramebuffersEXT", NULL } },
55380:         { (PRFuncPtr*) &mSymbols.fDeleteRenderbuffers, { "DeleteRenderbuffers", "DeleteRenderbuffersEXT", NULL } },
41369: 
41369:         { NULL, { NULL } },
41369: 
41369:     };
41369: 
41369:     mInitialized = LoadSymbols(&symbols[0], trygl, prefix);
49076: 
84805:     // Load OpenGL ES 2.0 symbols, or desktop if we aren't using ES 2.
84805:     if (mInitialized) {
84805:         if (mIsGLES2) {
84805:             SymLoadStruct symbols_ES2[] = {
84805:                 { (PRFuncPtr*) &mSymbols.fGetShaderPrecisionFormat, { "GetShaderPrecisionFormat", NULL } },
84805:                 { (PRFuncPtr*) &mSymbols.fClearDepthf, { "ClearDepthf", NULL } },
84805:                 { (PRFuncPtr*) &mSymbols.fDepthRangef, { "DepthRangef", NULL } },
84805:                 { NULL, { NULL } },
84805:             };
84805: 
84805:             if (!LoadSymbols(&symbols_ES2[0], trygl, prefix)) {
84805:                 NS_RUNTIMEABORT("OpenGL ES 2.0 supported, but symbols could not be loaded.");
84805:                 mInitialized = false;
84805:             }
84805:         } else {
84805:             SymLoadStruct symbols_desktop[] = {
84805:                 { (PRFuncPtr*) &mSymbols.fClearDepth, { "ClearDepth", NULL } },
84805:                 { (PRFuncPtr*) &mSymbols.fDepthRange, { "DepthRange", NULL } },
84805:                 { (PRFuncPtr*) &mSymbols.fReadBuffer, { "ReadBuffer", NULL } },
84805:                 { (PRFuncPtr*) &mSymbols.fMapBuffer, { "MapBuffer", NULL } },
84805:                 { (PRFuncPtr*) &mSymbols.fUnmapBuffer, { "UnmapBuffer", NULL } },
84805:                 { NULL, { NULL } },
84805:             };
84805: 
84805:             if (!LoadSymbols(&symbols_desktop[0], trygl, prefix)) {
84805:                 NS_RUNTIMEABORT("Desktop symbols failed to load.");
84805:                 mInitialized = false;
84805:             }
84805:         }
84805:     }
84805: 
62487:     const char *glVendorString;
62487: 
62449:     if (mInitialized) {
62487:         glVendorString = (const char *)fGetString(LOCAL_GL_VENDOR);
57418:         const char *vendorMatchStrings[VendorOther] = {
57418:                 "Intel",
57418:                 "NVIDIA",
57418:                 "ATI",
57418:                 "Qualcomm"
57418:         };
57418:         mVendor = VendorOther;
57418:         for (int i = 0; i < VendorOther; ++i) {
57418:             if (DoesVendorStringMatch(glVendorString, vendorMatchStrings[i])) {
57418:                 mVendor = i;
57418:                 break;
57418:             }
57418:         }
62487:     }
62487: 
62487:     if (mInitialized) {
54959: #ifdef DEBUG
54959:         static bool once = false;
54959:         if (!once) {
57418:             const char *vendors[VendorOther] = {
57418:                 "Intel",
57418:                 "NVIDIA",
57418:                 "ATI",
57418:                 "Qualcomm"
57418:             };
57418: 
54959:             once = true;
57418:             if (mVendor < VendorOther) {
57418:                 printf_stderr("OpenGL vendor ('%s') recognized as: %s\n",
57418:                               glVendorString, vendors[mVendor]);
57418:             } else {
57418:                 printf_stderr("OpenGL vendor ('%s') unrecognized\n", glVendorString);
57418:             }
54959:         }
54959: #endif
57631: 
62487:         InitExtensions();
62487: 
62487:         NS_ASSERTION(!IsExtensionSupported(GLContext::ARB_pixel_buffer_object) ||
62487:                      (mSymbols.fMapBuffer && mSymbols.fUnmapBuffer),
62487:                      "ARB_pixel_buffer_object supported without glMapBuffer/UnmapBuffer being available!");
62487: 
84592:         if (SupportsRobustness()) {
84592:             if (IsExtensionSupported(ARB_robustness)) {
82479:                 SymLoadStruct robustnessSymbols[] = {
82479:                     { (PRFuncPtr*) &mSymbols.fGetGraphicsResetStatus, { "GetGraphicsResetStatusARB", NULL } },
82479:                     { NULL, { NULL } },
82479:                 };
82479: 
82479:                 if (!LoadSymbols(&robustnessSymbols[0], trygl, prefix)) {
82479:                     NS_RUNTIMEABORT("GL supports ARB_robustness without supplying GetGraphicsResetStatusARB.");
82479:                     mInitialized = false;
84592:                 } else {
84592:                     mHasRobustness = true;
82479:                 }
84592:             } else if (IsExtensionSupported(EXT_robustness)) {
84592:                 SymLoadStruct robustnessSymbols[] = {
84592:                     { (PRFuncPtr*) &mSymbols.fGetGraphicsResetStatus, { "GetGraphicsResetStatusEXT", NULL } },
84592:                     { NULL, { NULL } },
84592:                 };
82479: 
84592:                 if (!LoadSymbols(&robustnessSymbols[0], trygl, prefix)) {
84592:                     NS_RUNTIMEABORT("GL supports EGL_robustness without supplying GetGraphicsResetStatusEXT.");
84592:                     mInitialized = false;
84592:                 } else {
82479:                     mHasRobustness = true;
82479:                 }
84592:             }
84592:         }
82479: 
80614:         // Check for aux symbols based on extensions
80614:         if (IsExtensionSupported(GLContext::ANGLE_framebuffer_blit) ||
80614:             IsExtensionSupported(GLContext::EXT_framebuffer_blit)) {
80614:             SymLoadStruct auxSymbols[] = {
80614:                     { (PRFuncPtr*) &mSymbols.fBlitFramebuffer, { "BlitFramebuffer", "BlitFramebufferEXT", "BlitFramebufferANGLE", NULL } },
80614:                     { NULL, { NULL } },
80614:             };
80614:             if (!LoadSymbols(&auxSymbols[0], trygl, prefix)) {
80614:                 NS_RUNTIMEABORT("GL supports framebuffer_blit without supplying glBlitFramebuffer");
80614:                 mInitialized = false;
80614:             }
80614:         }
80616: 
80616:         if (IsExtensionSupported(GLContext::ANGLE_framebuffer_multisample) ||
80616:             IsExtensionSupported(GLContext::EXT_framebuffer_multisample)) {
80616:             SymLoadStruct auxSymbols[] = {
80616:                     { (PRFuncPtr*) &mSymbols.fRenderbufferStorageMultisample, { "RenderbufferStorageMultisample", "RenderbufferStorageMultisampleEXT", "RenderbufferStorageMultisampleANGLE", NULL } },
80616:                     { NULL, { NULL } },
80616:             };
80616:             if (!LoadSymbols(&auxSymbols[0], trygl, prefix)) {
80616:                 NS_RUNTIMEABORT("GL supports framebuffer_multisample without supplying glRenderbufferStorageMultisample");
80616:                 mInitialized = false;
80616:             }
80616:         }
80614:     }
80614: 
80614:     if (mInitialized) {
62487:         GLint v[4];
62487: 
62487:         fGetIntegerv(LOCAL_GL_SCISSOR_BOX, v);
62487:         mScissorStack.AppendElement(nsIntRect(v[0], v[1], v[2], v[3]));
62487: 
62487:         fGetIntegerv(LOCAL_GL_VIEWPORT, v);
62487:         mViewportStack.AppendElement(nsIntRect(v[0], v[1], v[2], v[3]));
62487: 
62487:         fGetIntegerv(LOCAL_GL_MAX_TEXTURE_SIZE, &mMaxTextureSize);
70172:         fGetIntegerv(LOCAL_GL_MAX_RENDERBUFFER_SIZE, &mMaxRenderbufferSize);
81033:         mMaxTextureImageSize = mMaxTextureSize;
62487: 
57631:         UpdateActualFormat();
49076:     }
49076: 
55380: #ifdef DEBUG
55380:     if (PR_GetEnv("MOZ_GL_DEBUG"))
55380:         mDebugMode |= DebugEnabled;
55380: 
55380:     // enables extra verbose output, informing of the start and finish of every GL call.
55380:     // useful e.g. to record information to investigate graphics system crashes/lockups
55380:     if (PR_GetEnv("MOZ_GL_DEBUG_VERBOSE"))
55380:         mDebugMode |= DebugTrace;
55380: 
55380:     // aborts on GL error. Can be useful to debug quicker code that is known not to generate any GL error in principle.
55380:     if (PR_GetEnv("MOZ_GL_DEBUG_ABORT_ON_ERROR"))
55380:         mDebugMode |= DebugAbortOnError;
55380: #endif
55380: 
63285:     if (mInitialized)
63285:         reporter.SetSuccessful();
63285:     else {
60078:         // if initialization fails, ensure all symbols are zero, to avoid hard-to-understand bugs
60078:         mSymbols.Zero();
63285:     }
60078: 
43628:     return mInitialized;
43628: }
41369: 
49076: void
49076: GLContext::InitExtensions()
49076: {
49076:     MakeCurrent();
49076:     const GLubyte *extensions = fGetString(LOCAL_GL_EXTENSIONS);
85826:     if (!extensions)
85826:         return;
85826: 
49076:     char *exts = strdup((char *)extensions);
49076: 
54889: #ifdef DEBUG
52047:     static bool once = false;
54889: #else
54889:     const bool once = true;
54889: #endif
52047: 
52047:     if (!once) {
49076:         printf_stderr("GL extensions: %s\n", exts);
52047:     }
49076: 
49076:     char *s = exts;
49076:     bool done = false;
49076:     while (!done) {
49076:         char *space = strchr(s, ' ');
49076:         if (space) {
49076:             *space = '\0';
49076:         } else {
49076:             done = true;
49076:         }
49076: 
49076:         for (int i = 0; sExtensionNames[i]; ++i) {
49076:             if (strcmp(s, sExtensionNames[i]) == 0) {
52047:                 if (!once) {
49076:                     printf_stderr("Found extension %s\n", s);
52047:                 }
49076:                 mAvailableExtensions[i] = 1;
49076:             }
49076:         }
49076: 
49076:         s = space+1;
49076:     }
49076: 
49076:     free(exts);
52047: 
54889: #ifdef DEBUG
52047:     once = true;
54889: #endif
49076: }
49076: 
79445: bool
43628: GLContext::IsExtensionSupported(const char *extension)
43628: {
57246:     return ListHasExtension(fGetString(LOCAL_GL_EXTENSIONS), extension);
57246: }
57246: 
57246: // Common code for checking for both GL extensions and GLX extensions.
79445: bool
57246: GLContext::ListHasExtension(const GLubyte *extensions, const char *extension)
57246: {
57853:     // fix bug 612572 - we were crashing as we were calling this function with extensions==null
57853:     if (extensions == nsnull || extension == nsnull)
80486:         return false;
57853: 
43628:     const GLubyte *start;
43628:     GLubyte *where, *terminator;
43628: 
43628:     /* Extension names should not have spaces. */
43628:     where = (GLubyte *) strchr(extension, ' ');
43628:     if (where || *extension == '\0')
80486:         return false;
43628: 
43628:     /* 
43628:      * It takes a bit of care to be fool-proof about parsing the
43628:      * OpenGL extensions string. Don't be fooled by sub-strings,
43628:      * etc. 
43628:      */
43628:     start = extensions;
43628:     for (;;) {
43628:         where = (GLubyte *) strstr((const char *) start, extension);
43628:         if (!where) {
43628:             break;
43628:         }
43628:         terminator = where + strlen(extension);
43628:         if (where == start || *(where - 1) == ' ') {
43628:             if (*terminator == ' ' || *terminator == '\0') {
80486:                 return true;
43628:             }
43628:         }
43628:         start = terminator;
43628:     }
80486:     return false;
41369: }
41369: 
46977: already_AddRefed<TextureImage>
46977: GLContext::CreateTextureImage(const nsIntSize& aSize,
46977:                               TextureImage::ContentType aContentType,
57421:                               GLenum aWrapMode,
79445:                               bool aUseNearestFilter)
46977: {
46977:     MakeCurrent();
46977: 
46977:     GLuint texture;
46977:     fGenTextures(1, &texture);
46977: 
46977:     fActiveTexture(LOCAL_GL_TEXTURE0);
46977:     fBindTexture(LOCAL_GL_TEXTURE_2D, texture);
46977: 
46977:     GLint texfilter = aUseNearestFilter ? LOCAL_GL_NEAREST : LOCAL_GL_LINEAR;
46977:     fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MIN_FILTER, texfilter);
46977:     fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MAG_FILTER, texfilter);
46977:     fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_S, aWrapMode);
46977:     fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_T, aWrapMode);
46977: 
57421:     return CreateBasicTextureImage(texture, aSize, aWrapMode, aContentType, this);
46977: }
46977: 
79815: void GLContext::ApplyFilterToBoundTexture(gfxPattern::GraphicsFilter aFilter)
79815: {
79815:     if (aFilter == gfxPattern::FILTER_NEAREST) {
79815:         fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MIN_FILTER, LOCAL_GL_NEAREST);
79815:         fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MAG_FILTER, LOCAL_GL_NEAREST);
79815:     } else {
79815:         if (aFilter != gfxPattern::FILTER_GOOD) {
79815:             NS_WARNING("Unsupported filter type!");
79815:         }
79815:         fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MIN_FILTER, LOCAL_GL_LINEAR);
79815:        fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MAG_FILTER, LOCAL_GL_LINEAR);
79815:     }
79815: }
79815: 
46977: BasicTextureImage::~BasicTextureImage()
46977: {
53690:     GLContext *ctx = mGLContext;
53690:     if (ctx->IsDestroyed() || !NS_IsMainThread()) {
53690:         ctx = ctx->GetSharedContext();
47967:     }
53690: 
53690:     // If we have a context, then we need to delete the texture;
53690:     // if we don't have a context (either real or shared),
53690:     // then they went away when the contex was deleted, because it
53690:     // was the only one that had access to it.
53690:     if (ctx && !ctx->IsDestroyed()) {
53690:         mGLContext->MakeCurrent();
53690:         mGLContext->fDeleteTextures(1, &mTexture);
53690:     }
46977: }
46977: 
60739: gfxASurface*
46977: BasicTextureImage::BeginUpdate(nsIntRegion& aRegion)
46977: {
60739:     NS_ASSERTION(!mUpdateSurface, "BeginUpdate() without EndUpdate()?");
46977: 
46977:     // determine the region the client will need to repaint
77141:     GetUpdateRegion(aRegion);
60728:     mUpdateRegion = aRegion;
46977: 
60728:     nsIntRect rgnSize = mUpdateRegion.GetBounds();
60728:     if (!nsIntRect(nsIntPoint(0, 0), mSize).Contains(rgnSize)) {
46977:         NS_ERROR("update outside of image");
46977:         return NULL;
46977:     }
46977: 
77141:     ImageFormat format =
77141:         (GetContentType() == gfxASurface::CONTENT_COLOR) ?
77141:         gfxASurface::ImageFormatRGB24 : gfxASurface::ImageFormatARGB32;
60739:     mUpdateSurface =
59442:         GetSurfaceForUpdate(gfxIntSize(rgnSize.width, rgnSize.height), format);
59442: 
60739:     if (!mUpdateSurface || mUpdateSurface->CairoStatus()) {
60739:         mUpdateSurface = NULL;
46977:         return NULL;
60739:     }
46977: 
60739:     mUpdateSurface->SetDeviceOffset(gfxPoint(-rgnSize.x, -rgnSize.y));
47946: 
60739:     return mUpdateSurface;
46977: }
46977: 
60740: void
77141: BasicTextureImage::GetUpdateRegion(nsIntRegion& aForRegion)
77141: {
77141:   // if the texture hasn't been initialized yet, or something important
77141:   // changed, we need to recreate our backing surface and force the
77141:   // client to paint everything
77141:   if (mTextureState != Valid)
77141:       aForRegion = nsIntRect(nsIntPoint(0, 0), mSize);
77141: }
77141: 
77141: void
46977: BasicTextureImage::EndUpdate()
46977: {
60739:     NS_ASSERTION(!!mUpdateSurface, "EndUpdate() without BeginUpdate()?");
46977: 
46977:     // FIXME: this is the slow boat.  Make me fast (with GLXPixmap?).
47946: 
47946:     // Undo the device offset that BeginUpdate set; doesn't much matter for us here,
47946:     // but important if we ever do anything directly with the surface.
60739:     mUpdateSurface->SetDeviceOffset(gfxPoint(0, 0));
47946: 
59442:     bool relative = FinishedSurfaceUpdate();
59442: 
59439:     mShaderType =
60739:         mGLContext->UploadSurfaceToTexture(mUpdateSurface,
60728:                                            mUpdateRegion,
59439:                                            mTexture,
63843:                                            mTextureState == Created,
60728:                                            mUpdateOffset,
59442:                                            relative);
59442:     FinishedSurfaceUpload();
59442: 
60739:     mUpdateSurface = nsnull;
63843:     mTextureState = Valid;
46977: }
46977: 
67635: void
67635: BasicTextureImage::BindTexture(GLenum aTextureUnit)
67635: {
67635:     mGLContext->fActiveTexture(aTextureUnit);
73465:     mGLContext->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
67635:     mGLContext->fActiveTexture(LOCAL_GL_TEXTURE0);
67635: }
67635: 
79815: void
79815: BasicTextureImage::ApplyFilter()
79815: {
79815:   mGLContext->ApplyFilterToBoundTexture(mFilter);
79815: }
79815: 
79815: 
59442: already_AddRefed<gfxASurface>
59442: BasicTextureImage::GetSurfaceForUpdate(const gfxIntSize& aSize, ImageFormat aFmt)
59442: {
59442:     return gfxPlatform::GetPlatform()->
59442:         CreateOffscreenSurface(aSize, gfxASurface::ContentFromFormat(aFmt));
59442: }
59442: 
59442: bool
59442: BasicTextureImage::FinishedSurfaceUpdate()
59442: {
59442:     return false;
59442: }
59442: 
59442: void
59442: BasicTextureImage::FinishedSurfaceUpload()
59442: {
59442: }
59442: 
59443: bool 
73465: BasicTextureImage::DirectUpdate(gfxASurface* aSurf, const nsIntRegion& aRegion, const nsIntPoint& aFrom /* = nsIntPoint(0, 0) */)
59443: {
59443:     nsIntRect bounds = aRegion.GetBounds();
60728:     nsIntRegion region;
63843:     if (mTextureState != Valid) {
59443:         bounds = nsIntRect(0, 0, mSize.width, mSize.height);
60728:         region = nsIntRegion(bounds);
60728:     } else {
60728:         region = aRegion;
59443:     }
59443: 
59443:     mShaderType =
59443:         mGLContext->UploadSurfaceToTexture(aSurf,
60728:                                            region,
59443:                                            mTexture,
63843:                                            mTextureState == Created,
73465:                                            bounds.TopLeft() + aFrom,
80486:                                            false);
63843:     mTextureState = Valid;
59443:     return true;
59443: }
59443: 
54505: void
54505: BasicTextureImage::Resize(const nsIntSize& aSize)
54505: {
60739:     NS_ASSERTION(!mUpdateSurface, "Resize() while in update?");
54505: 
54505:     mGLContext->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
54505: 
54505:     mGLContext->fTexImage2D(LOCAL_GL_TEXTURE_2D,
54505:                             0,
54505:                             LOCAL_GL_RGBA,
54505:                             aSize.width,
54505:                             aSize.height,
54505:                             0,
54505:                             LOCAL_GL_RGBA,
54505:                             LOCAL_GL_UNSIGNED_BYTE,
54505:                             NULL);
54505: 
67639:     mTextureState = Allocated;
56953:     mSize = aSize;
54505: }
54505: 
73465: TiledTextureImage::TiledTextureImage(GLContext* aGL,
73465:                                      nsIntSize aSize,
73465:                                      TextureImage::ContentType aContentType,
79445:                                      bool aUseNearestFilter)
73465:     : TextureImage(aSize, LOCAL_GL_CLAMP_TO_EDGE, aContentType, aUseNearestFilter)
73465:     , mCurrentImage(0)
80486:     , mInUpdate(false)
73465:     , mGL(aGL)
73465:     , mUseNearestFilter(aUseNearestFilter)
73465:     , mTextureState(Created)
73465: {
73465:     mTileSize = mGL->GetMaxTextureSize();
73465:     if (aSize != nsIntSize(0,0)) {
73465:         Resize(aSize);
73465:     }
73465: }
73465: 
73465: TiledTextureImage::~TiledTextureImage()
73465: {
73465: }
73465: 
73465: bool 
73465: TiledTextureImage::DirectUpdate(gfxASurface* aSurf, const nsIntRegion& aRegion, const nsIntPoint& aFrom /* = nsIntPoint(0, 0) */)
73465: {
73465:     nsIntRegion region;
73465:     if (mTextureState != Valid) {
77141:         nsIntRect bounds = nsIntRect(0, 0, mSize.width, mSize.height);
73465:         region = nsIntRegion(bounds);
73465:     } else {
73465:         region = aRegion;
73465:     }
73465: 
79445:     bool result = true;
73465:     for (unsigned i = 0; i < mImages.Length(); i++) {
77141:         int xPos = (i % mColumns) * mTileSize;
77141:         int yPos = (i / mColumns) * mTileSize;
73465:         nsIntRegion tileRegion;
73465:         tileRegion.And(region, nsIntRect(nsIntPoint(xPos,yPos), mImages[i]->GetSize())); // intersect with tile
73465:         if (tileRegion.IsEmpty())
73465:             continue;
73465:         tileRegion.MoveBy(-xPos, -yPos); // translate into tile local space
73465:         result &= mImages[i]->DirectUpdate(aSurf,
73465:                                            tileRegion,
73465:                                            aFrom + nsIntPoint(xPos, yPos));
73465:     }
73465:     mShaderType = mImages[0]->GetShaderProgramType();
73465:     mTextureState = Valid;
73465:     return result;
73465: }
73465: 
77141: void
77141: TiledTextureImage::GetUpdateRegion(nsIntRegion& aForRegion)
77141: {
77141:     if (mTextureState != Valid) {
77141:         // if the texture hasn't been initialized yet, or something important
77141:         // changed, we need to recreate our backing surface and force the
77141:         // client to paint everything
77141:         aForRegion = nsIntRect(nsIntPoint(0, 0), mSize);
77141:         return;
77141:     }
77141: 
77141:     nsIntRegion newRegion;
77141: 
77141:     // We need to query each texture with the region it will be drawing and
77141:     // set aForRegion to be the combination of all of these regions
77141:     for (unsigned i = 0; i < mImages.Length(); i++) {
77141:         int xPos = (i % mColumns) * mTileSize;
77141:         int yPos = (i / mColumns) * mTileSize;
77141:         nsIntRect imageRect = nsIntRect(nsIntRect(nsIntPoint(xPos,yPos), mImages[i]->GetSize()));
77141: 
77141:         if (aForRegion.Intersects(imageRect)) {
77141:             // Make a copy of the region
77141:             nsIntRegion subRegion;
77141:             subRegion.And(aForRegion, imageRect);
77141:             // Translate it into tile-space
77141:             subRegion.MoveBy(-xPos, -yPos);
77141:             // Query region
77141:             mImages[i]->GetUpdateRegion(subRegion);
77141:             // Translate back
77141:             subRegion.MoveBy(xPos, yPos);
77141:             // Add to the accumulated region
77141:             newRegion.Or(newRegion, subRegion);
77141:         }
77141:     }
77141: 
77141:     aForRegion = newRegion;
77141: }
77141: 
73465: gfxASurface*
73465: TiledTextureImage::BeginUpdate(nsIntRegion& aRegion)
73465: {
73465:     NS_ASSERTION(!mInUpdate, "nested update");
80486:     mInUpdate = true;
73465: 
77141:     // Note, we don't call GetUpdateRegion here as if the updated region is
77141:     // fully contained in a single tile, we get to avoid iterating through
77141:     // the tiles again (and a little copying).
73465:     if (mTextureState != Valid)
73465:     {
73465:         // if the texture hasn't been initialized yet, or something important
73465:         // changed, we need to recreate our backing surface and force the
73465:         // client to paint everything
77141:         aRegion = nsIntRect(nsIntPoint(0, 0), mSize);
73465:     }
73465: 
77141:     nsIntRect bounds = aRegion.GetBounds();
77141: 
73465:     for (unsigned i = 0; i < mImages.Length(); i++) {
77141:         int xPos = (i % mColumns) * mTileSize;
77141:         int yPos = (i / mColumns) * mTileSize;
73465:         nsIntRegion imageRegion = nsIntRegion(nsIntRect(nsIntPoint(xPos,yPos), mImages[i]->GetSize()));
73465: 
73465:         // a single Image can handle this update request
73465:         if (imageRegion.Contains(aRegion)) {
73465:             // adjust for tile offset
73465:             aRegion.MoveBy(-xPos, -yPos);
73465:             // forward the actual call
73465:             nsRefPtr<gfxASurface> surface = mImages[i]->BeginUpdate(aRegion);
73465:             // caller expects container space
73465:             aRegion.MoveBy(xPos, yPos);
77141:             // Correct the device offset
77141:             gfxPoint offset = surface->GetDeviceOffset();
77141:             surface->SetDeviceOffset(gfxPoint(offset.x - xPos,
77141:                                               offset.y - yPos));
73465:             // we don't have a temp surface
73465:             mUpdateSurface = nsnull;
73465:             // remember which image to EndUpdate
73465:             mCurrentImage = i;
73465:             return surface.get();
73465:         }
73465:     }
77141: 
77141:     // Get the real updated region, taking into account the capabilities of
77141:     // each TextureImage tile
77141:     GetUpdateRegion(aRegion);
77141:     mUpdateRegion = aRegion;
77141:     bounds = aRegion.GetBounds();
77141: 
73465:     // update covers multiple Images - create a temp surface to paint in
73465:     gfxASurface::gfxImageFormat format =
73465:         (GetContentType() == gfxASurface::CONTENT_COLOR) ?
73465:         gfxASurface::ImageFormatRGB24 : gfxASurface::ImageFormatARGB32;
73465:     mUpdateSurface = gfxPlatform::GetPlatform()->
73465:         CreateOffscreenSurface(gfxIntSize(bounds.width, bounds.height), gfxASurface::ContentFromFormat(format));
73465:     mUpdateSurface->SetDeviceOffset(gfxPoint(-bounds.x, -bounds.y));
77141: 
73465:     return mUpdateSurface;
73465: }
73465: 
73465: void
73465: TiledTextureImage::EndUpdate()
73465: {
73465:     NS_ASSERTION(mInUpdate, "EndUpdate not in update");
73465:     if (!mUpdateSurface) { // update was to a single TextureImage
73465:         mImages[mCurrentImage]->EndUpdate();
80486:         mInUpdate = false;
73465:         mTextureState = Valid;
73465:         mShaderType = mImages[mCurrentImage]->GetShaderProgramType();
73465:         return;
73465:     }
73465: 
73465:     // upload tiles from temp surface
73465:     for (unsigned i = 0; i < mImages.Length(); i++) {
77141:         int xPos = (i % mColumns) * mTileSize;
77141:         int yPos = (i / mColumns) * mTileSize;
73465:         nsIntRect imageRect = nsIntRect(nsIntPoint(xPos,yPos), mImages[i]->GetSize());
77141: 
73465:         nsIntRegion subregion;
73465:         subregion.And(mUpdateRegion, imageRect);
73465:         if (subregion.IsEmpty())
73465:             continue;
73465:         subregion.MoveBy(-xPos, -yPos); // Tile-local space
73465:         // copy tile from temp surface
73465:         gfxASurface* surf = mImages[i]->BeginUpdate(subregion);
73465:         nsRefPtr<gfxContext> ctx = new gfxContext(surf);
73465:         gfxUtils::ClipToRegion(ctx, subregion);
73465:         ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
73465:         ctx->SetSource(mUpdateSurface, gfxPoint(-xPos, -yPos));
73465:         ctx->Paint();
73465:         mImages[i]->EndUpdate();
73465:     }
73465: 
73465:     mUpdateSurface = nsnull;
80486:     mInUpdate = false;
73465:     mShaderType = mImages[0]->GetShaderProgramType();
77141:     mTextureState = Valid;
73465: }
73465: 
73465: void TiledTextureImage::BeginTileIteration()
73465: {
73465:     mCurrentImage = 0;
73465: }
73465: 
79445: bool TiledTextureImage::NextTile()
73465: {
73465:     if (mCurrentImage + 1 < mImages.Length()) {
73465:         mCurrentImage++;
80486:         return true;
73465:     }
80486:     return false;
73465: }
73465: 
73465: nsIntRect TiledTextureImage::GetTileRect()
73465: {
73465:     nsIntRect rect = mImages[mCurrentImage]->GetTileRect();
73465:     unsigned int xPos = (mCurrentImage % mColumns) * mTileSize;
73465:     unsigned int yPos = (mCurrentImage / mColumns) * mTileSize;
75173:     rect.MoveBy(xPos, yPos);
73465:     return rect;
73465: }
73465: 
73465: void
73465: TiledTextureImage::BindTexture(GLenum aTextureUnit)
73465: {
73465:     mImages[mCurrentImage]->BindTexture(aTextureUnit);
73465: }
73465: 
79815: void
79815: TiledTextureImage::ApplyFilter()
79815: {
79815:    mGL->ApplyFilterToBoundTexture(mFilter);
79815: }
79815: 
73465: /*
73465:  * simple resize, just discards everything. we can be more clever just
73465:  * adding or discarding tiles, but do we want this?
73465:  */
73465: void TiledTextureImage::Resize(const nsIntSize& aSize)
73465: {
73465:     if (mSize == aSize && mTextureState != Created) {
73465:         return;
73465:     }
73465:     mSize = aSize;
73465:     mImages.Clear();
73465:     // calculate rows and columns, rounding up
73465:     mColumns = (aSize.width  + mTileSize - 1) / mTileSize;
73465:     mRows    = (aSize.height + mTileSize - 1) / mTileSize;
73465: 
73465:     for (unsigned int row = 0; row < mRows; row++) {
73465:       for (unsigned int col = 0; col < mColumns; col++) {
73465:           nsIntSize size( // use tilesize first, then the remainder
73465:                   (col+1) * mTileSize > (unsigned int)aSize.width  ? aSize.width  % mTileSize : mTileSize,
73465:                   (row+1) * mTileSize > (unsigned int)aSize.height ? aSize.height % mTileSize : mTileSize);
73465:           nsRefPtr<TextureImage> teximg =
73465:                   mGL->TileGenFunc(size, mContentType, mUseNearestFilter);
73465:           mImages.AppendElement(teximg.forget());
73465:       }
73465:     }
73465:     mTextureState = Allocated;
73465: }
73465: 
77132: PRUint32 TiledTextureImage::GetTileCount()
77132: {
77132:     return mImages.Length();
77132: }
77132: 
79445: bool
80621: GLContext::ResizeOffscreenFBO(const gfxIntSize& aSize, const bool aUseReadFBO, const bool aDisableAA)
47908: {
70172:     if (!IsOffscreenSizeAllowed(aSize))
80486:         return false;
70172: 
47908:     MakeCurrent();
47908: 
80612:     const bool alpha = mCreationFormat.alpha > 0;
80612:     const int depth = mCreationFormat.depth;
80612:     const int stencil = mCreationFormat.stencil;
80617:     int samples = mCreationFormat.samples;
80617: 
81327:     GLint maxSamples = 0;
81327:     if (SupportsFramebufferMultisample() && !aDisableAA)
81327:         fGetIntegerv(LOCAL_GL_MAX_SAMPLES, &maxSamples);
81327: 
81327:     samples = NS_MIN(samples, maxSamples);
80651: 
80651:     const bool useDrawMSFBO = (samples > 0);
80617: 
85066:     if (!useDrawMSFBO && !aUseReadFBO) {
85066:         // Early out, as no FBO resize work is necessary.
80617:         return true;
85066:     }
80617: 
80614:     const bool firstTime = (mOffscreenDrawFBO == 0 && mOffscreenReadFBO == 0);
80603: 
80614:     GLuint curBoundFramebufferDraw = 0;
80614:     GLuint curBoundFramebufferRead = 0;
80614:     GLuint curBoundRenderbuffer = 0;
80610:     GLuint curBoundTexture = 0;
47908: 
47908:     GLint viewport[4];
47908: 
80612:     const bool useDepthStencil =
49076:             !mIsGLES2 || IsExtensionSupported(OES_packed_depth_stencil);
49076: 
47908:     // save a few things for later restoring
80614:     curBoundFramebufferDraw = GetBoundDrawFBO();
80614:     curBoundFramebufferRead = GetBoundReadFBO();
80614:     fGetIntegerv(LOCAL_GL_RENDERBUFFER_BINDING, (GLint*) &curBoundRenderbuffer);
80610:     fGetIntegerv(LOCAL_GL_TEXTURE_BINDING_2D, (GLint*) &curBoundTexture);
47908:     fGetIntegerv(LOCAL_GL_VIEWPORT, viewport);
47908: 
80612:     // the context format of what we're defining
80612:     // This becomes mActualFormat on success
80617:     ContextFormat cf(mCreationFormat);
57631: 
80612:     // Create everything we need for the resize, so if it fails, we haven't broken anything
80612:     // If successful, these new resized objects will replace their associated member vars in GLContext
80614:     GLuint newOffscreenDrawFBO = 0;
80614:     GLuint newOffscreenReadFBO = 0;
80612:     GLuint newOffscreenTexture = 0;
80617:     GLuint newOffscreenColorRB = 0;
80612:     GLuint newOffscreenDepthRB = 0;
80612:     GLuint newOffscreenStencilRB = 0;
80612: 
80617:     // Create the buffers and texture
80617:     if (aUseReadFBO) {
80614:         fGenFramebuffers(1, &newOffscreenReadFBO);
80617:         fGenTextures(1, &newOffscreenTexture);
80617:     }
80617: 
80617:     if (useDrawMSFBO) {
80617:         fGenFramebuffers(1, &newOffscreenDrawFBO);
80617:         fGenRenderbuffers(1, &newOffscreenColorRB);
80617:     } else {
80614:         newOffscreenDrawFBO = newOffscreenReadFBO;
80617:     }
80598: 
49076:     if (depth && stencil && useDepthStencil) {
80612:         fGenRenderbuffers(1, &newOffscreenDepthRB);
48311:     } else {
47908:         if (depth) {
80612:             fGenRenderbuffers(1, &newOffscreenDepthRB);
47908:         }
47908: 
47908:         if (stencil) {
80612:             fGenRenderbuffers(1, &newOffscreenStencilRB);
47908:         }
48311:     }
47908: 
80617:    // Allocate texture
80617:     if (aUseReadFBO) {
80617:         fBindTexture(LOCAL_GL_TEXTURE_2D, newOffscreenTexture);
80617:         fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MIN_FILTER, LOCAL_GL_LINEAR);
80617:         fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MAG_FILTER, LOCAL_GL_LINEAR);
80617: 
47908:         if (alpha) {
47908:             fTexImage2D(LOCAL_GL_TEXTURE_2D,
47908:                         0,
47908:                         LOCAL_GL_RGBA,
47908:                         aSize.width, aSize.height,
47908:                         0,
47908:                         LOCAL_GL_RGBA,
47908:                         LOCAL_GL_UNSIGNED_BYTE,
47908:                         NULL);
57631: 
57631:             cf.red = cf.green = cf.blue = cf.alpha = 8;
47908:         } else {
47908:             fTexImage2D(LOCAL_GL_TEXTURE_2D,
47908:                         0,
47908:                         LOCAL_GL_RGB,
47908:                         aSize.width, aSize.height,
47908:                         0,
47908:                         LOCAL_GL_RGB,
49076: #ifdef XP_WIN
49076:                         LOCAL_GL_UNSIGNED_BYTE,
49076: #else
48311:                         mIsGLES2 ? LOCAL_GL_UNSIGNED_SHORT_5_6_5
47908:                                  : LOCAL_GL_UNSIGNED_BYTE,
49076: #endif
47908:                         NULL);
57631: 
57631: #ifdef XP_WIN
57631:             cf.red = cf.green = cf.blue = 8;
57631: #else
57631:             cf.red = 5;
57631:             cf.green = 6;
57631:             cf.blue = 5;
57631: #endif
57631:             cf.alpha = 0;
47908:         }
80617:     }
80617:     cf.samples = samples;
47908: 
80617:     // Allocate color buffer
80617:     if (useDrawMSFBO) {
80617:         GLenum colorFormat;
80617:         if (!mIsGLES2 || IsExtensionSupported(OES_rgb8_rgba8))
80617:             colorFormat = alpha ? LOCAL_GL_RGBA8 : LOCAL_GL_RGB8;
80617:         else
80617:             colorFormat = alpha ? LOCAL_GL_RGBA4 : LOCAL_GL_RGB565;
80617: 
80617:         fBindRenderbuffer(LOCAL_GL_RENDERBUFFER, newOffscreenColorRB);
80617:         fRenderbufferStorageMultisample(LOCAL_GL_RENDERBUFFER,
80617:                                         samples,
80617:                                         colorFormat,
80617:                                         aSize.width, aSize.height);
80617:     }
80617: 
80617:     // Allocate depth and stencil buffers
49076:     if (depth && stencil && useDepthStencil) {
80612:         fBindRenderbuffer(LOCAL_GL_RENDERBUFFER, newOffscreenDepthRB);
80617:         if (useDrawMSFBO) {
80617:             fRenderbufferStorageMultisample(LOCAL_GL_RENDERBUFFER,
80617:                                             samples,
80617:                                             LOCAL_GL_DEPTH24_STENCIL8,
80617:                                             aSize.width, aSize.height);
80617:         } else {
48311:             fRenderbufferStorage(LOCAL_GL_RENDERBUFFER,
48311:                                  LOCAL_GL_DEPTH24_STENCIL8,
48311:                                  aSize.width, aSize.height);
80617:         }
57631:         cf.depth = 24;
57631:         cf.stencil = 8;
48311:     } else {
47908:         if (depth) {
49076:             GLenum depthType;
49076:             if (mIsGLES2) {
49076:                 if (IsExtensionSupported(OES_depth32)) {
49076:                     depthType = LOCAL_GL_DEPTH_COMPONENT32;
73708:                     cf.depth = 32;
49076:                 } else if (IsExtensionSupported(OES_depth24)) {
49076:                     depthType = LOCAL_GL_DEPTH_COMPONENT24;
73708:                     cf.depth = 24;
49076:                 } else {
49076:                     depthType = LOCAL_GL_DEPTH_COMPONENT16;
73708:                    cf.depth = 16;
49076:                 }
49076:             } else {
49076:                 depthType = LOCAL_GL_DEPTH_COMPONENT24;
73708:                 cf.depth = 24;
49076:             }
49076: 
80612:             fBindRenderbuffer(LOCAL_GL_RENDERBUFFER, newOffscreenDepthRB);
80617:             if (useDrawMSFBO) {
80617:                 fRenderbufferStorageMultisample(LOCAL_GL_RENDERBUFFER,
80617:                                                 samples,
80617:                                                 depthType,
47908:                                                 aSize.width, aSize.height);
80617:             } else {
80617:                 fRenderbufferStorage(LOCAL_GL_RENDERBUFFER,
80617:                                      depthType,
80617:                                      aSize.width, aSize.height);
80617:             }
47908:         }
47908: 
47908:         if (stencil) {
80612:             fBindRenderbuffer(LOCAL_GL_RENDERBUFFER, newOffscreenStencilRB);
80617:             if (useDrawMSFBO) {
80617:                 fRenderbufferStorageMultisample(LOCAL_GL_RENDERBUFFER,
80617:                                                 samples,
80617:                                                 LOCAL_GL_STENCIL_INDEX8,
80617:                                                 aSize.width, aSize.height);
80617:             } else {
47908:                 fRenderbufferStorage(LOCAL_GL_RENDERBUFFER,
47908:                                      LOCAL_GL_STENCIL_INDEX8,
47908:                                      aSize.width, aSize.height);
80617:             }
57631:             cf.stencil = 8;
47908:         }
48311:     }
47908: 
80612:     // Now assemble the FBO
80617:     fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, newOffscreenDrawFBO);    // If we're not using a separate draw FBO, this will be the read FBO
80617:     if (useDrawMSFBO) {
80617:         fFramebufferRenderbuffer(LOCAL_GL_FRAMEBUFFER,
47908:                                  LOCAL_GL_COLOR_ATTACHMENT0,
80617:                                  LOCAL_GL_RENDERBUFFER,
80617:                                  newOffscreenColorRB);
80617:     }
48311: 
49076:     if (depth && stencil && useDepthStencil) {
48311:         fFramebufferRenderbuffer(LOCAL_GL_FRAMEBUFFER,
48311:                                  LOCAL_GL_DEPTH_ATTACHMENT,
48311:                                  LOCAL_GL_RENDERBUFFER,
80612:                                  newOffscreenDepthRB);
48311:         fFramebufferRenderbuffer(LOCAL_GL_FRAMEBUFFER,
48311:                                  LOCAL_GL_STENCIL_ATTACHMENT,
48311:                                  LOCAL_GL_RENDERBUFFER,
80612:                                  newOffscreenDepthRB);
48311:     } else {
47908:         if (depth) {
47908:             fFramebufferRenderbuffer(LOCAL_GL_FRAMEBUFFER,
47908:                                      LOCAL_GL_DEPTH_ATTACHMENT,
47908:                                      LOCAL_GL_RENDERBUFFER,
80612:                                      newOffscreenDepthRB);
47908:         }
47908: 
47908:         if (stencil) {
47908:             fFramebufferRenderbuffer(LOCAL_GL_FRAMEBUFFER,
47908:                                      LOCAL_GL_STENCIL_ATTACHMENT,
47908:                                      LOCAL_GL_RENDERBUFFER,
80612:                                      newOffscreenStencilRB);
48311:         }
80603:     }
80603: 
80617:     if (aUseReadFBO) {
80617:         fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, newOffscreenReadFBO);
80617:         fFramebufferTexture2D(LOCAL_GL_FRAMEBUFFER,
80617:                               LOCAL_GL_COLOR_ATTACHMENT0,
80617:                               LOCAL_GL_TEXTURE_2D,
80617:                               newOffscreenTexture,
80617:                               0);
80617:     }
80617: 
47908:     // We should be all resized.  Check for framebuffer completeness.
80614:     GLenum status;
80614:     bool framebuffersComplete = true;
80614: 
80614:     fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, newOffscreenDrawFBO);
80614:     status = fCheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER);
47908:     if (status != LOCAL_GL_FRAMEBUFFER_COMPLETE) {
80614:         NS_WARNING("DrawFBO: Incomplete");
80614: #ifdef DEBUG
80614:         printf_stderr("Framebuffer status: %X\n", status);
80614: #endif
80614:         framebuffersComplete = false;
80614:     }
80614: 
80614:     fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, newOffscreenReadFBO);
80614:     status = fCheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER);
80614:     if (status != LOCAL_GL_FRAMEBUFFER_COMPLETE) {
80614:         NS_WARNING("ReadFBO: Incomplete");
80614: #ifdef DEBUG
80614:         printf_stderr("Framebuffer status: %X\n", status);
80614: #endif
80614:         framebuffersComplete = false;
80614:     }
80614: 
80614:     if (!framebuffersComplete) {
80614:         NS_WARNING("Error resizing offscreen framebuffer -- framebuffer(s) not complete");
80612: 
80612:         // Clean up the mess
80614:         fDeleteFramebuffers(1, &newOffscreenDrawFBO);
80614:         fDeleteFramebuffers(1, &newOffscreenReadFBO);
80612:         fDeleteTextures(1, &newOffscreenTexture);
80617:         fDeleteRenderbuffers(1, &newOffscreenColorRB);
80612:         fDeleteRenderbuffers(1, &newOffscreenDepthRB);
80612:         fDeleteRenderbuffers(1, &newOffscreenStencilRB);
80612: 
80614:         BindReadFBO(curBoundFramebufferRead);
80614:         BindDrawFBO(curBoundFramebufferDraw);
80612:         fBindTexture(LOCAL_GL_TEXTURE_2D, curBoundTexture);
80612:         fBindRenderbuffer(LOCAL_GL_RENDERBUFFER, curBoundRenderbuffer);
80612:         fViewport(viewport[0], viewport[1], viewport[2], viewport[3]);
80612: 
80486:         return false;
47908:     }
47908: 
80612:     // Success, so delete the old and busted
80614:     fDeleteFramebuffers(1, &mOffscreenDrawFBO);
80614:     fDeleteFramebuffers(1, &mOffscreenReadFBO);
80612:     fDeleteTextures(1, &mOffscreenTexture);
80617:     fDeleteRenderbuffers(1, &mOffscreenColorRB);
80612:     fDeleteRenderbuffers(1, &mOffscreenDepthRB);
80612:     fDeleteRenderbuffers(1, &mOffscreenStencilRB);
80612: 
80612:     // Update currently bound references if we're changing what they were point to
80612:     // This way we don't rebind to old buffers when we're done here
80614:     if (curBoundFramebufferDraw == mOffscreenDrawFBO)
80614:         curBoundFramebufferDraw = newOffscreenDrawFBO;
80614:     if (curBoundFramebufferRead == mOffscreenReadFBO)
80614:         curBoundFramebufferRead = newOffscreenReadFBO;
80612:     if (curBoundTexture == mOffscreenTexture)
80612:         curBoundTexture = newOffscreenTexture;
80617:     if (curBoundRenderbuffer == mOffscreenColorRB)
80617:         curBoundRenderbuffer = newOffscreenColorRB;
80617:     else if (curBoundRenderbuffer == mOffscreenDepthRB)
80612:         curBoundRenderbuffer = newOffscreenDepthRB;
80612:     else if (curBoundRenderbuffer == mOffscreenStencilRB)
80612:         curBoundRenderbuffer = newOffscreenStencilRB;
80612: 
80612:     // Replace with the new hotness
80614:     mOffscreenDrawFBO = newOffscreenDrawFBO;
80614:     mOffscreenReadFBO = newOffscreenReadFBO;
80612:     mOffscreenTexture = newOffscreenTexture;
80617:     mOffscreenColorRB = newOffscreenColorRB;
80612:     mOffscreenDepthRB = newOffscreenDepthRB;
80612:     mOffscreenStencilRB = newOffscreenStencilRB;
80612: 
47908:     mOffscreenSize = aSize;
47908:     mOffscreenActualSize = aSize;
47908: 
57631:     mActualFormat = cf;
49076: 
52047: #ifdef DEBUG
84816:     if (DebugMode()) {
80617:         printf_stderr("%s %dx%d offscreen FBO: r: %d g: %d b: %d a: %d depth: %d stencil: %d samples: %d\n",
80614:                       firstTime ? "Created" : "Resized",
80614:                       mOffscreenActualSize.width, mOffscreenActualSize.height,
49076:                       mActualFormat.red, mActualFormat.green, mActualFormat.blue, mActualFormat.alpha,
80617:                       mActualFormat.depth, mActualFormat.stencil, mActualFormat.samples);
80612:     }
80610: #endif
47908: 
80614:     // Make sure we know that the buffers are new and thus dirty:
80614:     ForceDirtyFBOs();
80614: 
85066:     // We're good, and the framebuffer is already attached.
85066:     // Now restore the GL state back to what it was before the resize took place.
80614:     BindDrawFBO(curBoundFramebufferDraw);
80614:     BindReadFBO(curBoundFramebufferRead);
47908:     fBindTexture(LOCAL_GL_TEXTURE_2D, curBoundTexture);
47908:     fBindRenderbuffer(LOCAL_GL_RENDERBUFFER, curBoundRenderbuffer);
47908: 
47908:     // -don't- restore the viewport the first time through this, since
47908:     // the previous one isn't valid.
85066:     if (firstTime)
85066:         fViewport(0, 0, aSize.width, aSize.height); // XXX This is coming out in 711642
85066:     else
47908:         fViewport(viewport[0], viewport[1], viewport[2], viewport[3]);
47908: 
80486:     return true;
47908: }
47908: 
47908: void
47908: GLContext::DeleteOffscreenFBO()
47908: {
80614:     fDeleteFramebuffers(1, &mOffscreenDrawFBO);
80614:     fDeleteFramebuffers(1, &mOffscreenReadFBO);
47908:     fDeleteTextures(1, &mOffscreenTexture);
80617:     fDeleteRenderbuffers(1, &mOffscreenColorRB);
47908:     fDeleteRenderbuffers(1, &mOffscreenDepthRB);
47908:     fDeleteRenderbuffers(1, &mOffscreenStencilRB);
47908: 
80614:     mOffscreenDrawFBO = 0;
80614:     mOffscreenReadFBO = 0;
47908:     mOffscreenTexture = 0;
80617:     mOffscreenColorRB = 0;
47908:     mOffscreenDepthRB = 0;
47908:     mOffscreenStencilRB = 0;
47908: }
47908: 
47908: void
47908: GLContext::ClearSafely()
47908: {
70916:     // bug 659349 --- we must be very careful here: clearing a GL framebuffer is nontrivial, relies on a lot of state,
70916:     // and in the case of the backbuffer of a WebGL context, state is exposed to scripts.
70916:     //
70916:     // The code here is taken from WebGLContext::ForceClearFramebufferWithDefaultValues, but I didn't find a good way of
70916:     // sharing code with it. WebGL's code is somewhat performance-critical as it is typically called on every frame, so
70916:     // WebGL keeps track of GL state to avoid having to query it everytime, and also tries to only do work for actually
70916:     // present buffers (e.g. stencil buffer). Doing that here seems like premature optimization,
70916:     // as ClearSafely() is called only when e.g. a canvas is resized, not on every animation frame.
47908: 
70916:     realGLboolean scissorTestEnabled;
70916:     realGLboolean ditherEnabled;
70916:     realGLboolean colorWriteMask[4];
70916:     realGLboolean depthWriteMask;
70916:     GLint stencilWriteMaskFront, stencilWriteMaskBack;
70916:     GLfloat colorClearValue[4];
70916:     GLfloat depthClearValue;
70916:     GLint stencilClearValue;
47908: 
70916:     // save current GL state
70916:     fGetBooleanv(LOCAL_GL_SCISSOR_TEST, &scissorTestEnabled);
70916:     fGetBooleanv(LOCAL_GL_DITHER, &ditherEnabled);
70916:     fGetBooleanv(LOCAL_GL_COLOR_WRITEMASK, colorWriteMask);
70916:     fGetBooleanv(LOCAL_GL_DEPTH_WRITEMASK, &depthWriteMask);
70916:     fGetIntegerv(LOCAL_GL_STENCIL_WRITEMASK, &stencilWriteMaskFront);
70916:     fGetIntegerv(LOCAL_GL_STENCIL_BACK_WRITEMASK, &stencilWriteMaskBack);
70916:     fGetFloatv(LOCAL_GL_COLOR_CLEAR_VALUE, colorClearValue);
70916:     fGetFloatv(LOCAL_GL_DEPTH_CLEAR_VALUE, &depthClearValue);
70916:     fGetIntegerv(LOCAL_GL_STENCIL_CLEAR_VALUE, &stencilClearValue);
70916: 
70916:     // prepare GL state for clearing
70916:     fDisable(LOCAL_GL_SCISSOR_TEST);
70916:     fDisable(LOCAL_GL_DITHER);
70916:     PushViewportRect(nsIntRect(0, 0, mOffscreenSize.width, mOffscreenSize.height));
70916: 
70916:     fColorMask(1, 1, 1, 1);
70916:     fClearColor(0.f, 0.f, 0.f, 0.f);
70916: 
70916:     fDepthMask(1);
48309:     fClearDepth(1.0f);
47908: 
70916:     fStencilMask(0xffffffff);
70916:     fClearStencil(0);
47908: 
70916:     // do clear
70916:     fClear(LOCAL_GL_COLOR_BUFFER_BIT |
70916:            LOCAL_GL_DEPTH_BUFFER_BIT |
70916:            LOCAL_GL_STENCIL_BUFFER_BIT);
70916: 
70916:     // restore GL state after clearing
70916:     fColorMask(colorWriteMask[0],
70916:                colorWriteMask[1],
70916:                colorWriteMask[2],
70916:                colorWriteMask[3]);
70916:     fClearColor(colorClearValue[0],
70916:                 colorClearValue[1],
70916:                 colorClearValue[2],
70916:                 colorClearValue[3]);
70916: 
70916:     fDepthMask(depthWriteMask);
70916:     fClearDepth(depthClearValue);
70916: 
70916:     fStencilMaskSeparate(LOCAL_GL_FRONT, stencilWriteMaskFront);
70916:     fStencilMaskSeparate(LOCAL_GL_BACK, stencilWriteMaskBack);
70916:     fClearStencil(stencilClearValue);
70916: 
70916:     PopViewportRect();
70916: 
70916:     if (ditherEnabled)
70916:         fEnable(LOCAL_GL_DITHER);
70916:     else
70916:         fDisable(LOCAL_GL_DITHER);
70916: 
70916:     if (scissorTestEnabled)
70916:         fEnable(LOCAL_GL_SCISSOR_TEST);
70916:     else
70916:         fDisable(LOCAL_GL_SCISSOR_TEST);
70916: 
47908: }
47908: 
47908: void
47908: GLContext::UpdateActualFormat()
47908: {
49076:     ContextFormat nf;
49076: 
52045:     fGetIntegerv(LOCAL_GL_RED_BITS, (GLint*) &nf.red);
52045:     fGetIntegerv(LOCAL_GL_GREEN_BITS, (GLint*) &nf.green);
52045:     fGetIntegerv(LOCAL_GL_BLUE_BITS, (GLint*) &nf.blue);
49076:     fGetIntegerv(LOCAL_GL_ALPHA_BITS, (GLint*) &nf.alpha);
49076:     fGetIntegerv(LOCAL_GL_DEPTH_BITS, (GLint*) &nf.depth);
52045:     fGetIntegerv(LOCAL_GL_STENCIL_BITS, (GLint*) &nf.stencil);
49076: 
49076:     mActualFormat = nf;
47908: }
47908: 
49071: void
49071: GLContext::MarkDestroyed()
49071: {
54505:     if (IsDestroyed())
54505:         return;
54505: 
49071:     MakeCurrent();
49071:     DeleteOffscreenFBO();
54505: 
54505:     fDeleteProgram(mBlitProgram);
54505:     mBlitProgram = 0;
54505:     fDeleteFramebuffers(1, &mBlitFramebuffer);
54505:     mBlitFramebuffer = 0;
54505: 
55380:     mSymbols.Zero();
49071: }
49071: 
49071: already_AddRefed<gfxImageSurface>
49071: GLContext::ReadTextureImage(GLuint aTexture,
49071:                             const gfxIntSize& aSize,
49071:                             GLenum aTextureFormat)
49071: {
49071:     MakeCurrent();
49071: 
49071:     nsRefPtr<gfxImageSurface> isurf;
49071: 
54505:     GLint oldrb, oldfb, oldprog, oldPackAlignment;
49071:     GLint success;
49071: 
49071:     GLuint rb = 0, fb = 0;
49071:     GLuint vs = 0, fs = 0, prog = 0;
49071: 
49071:     const char *vShader =
49071:         "attribute vec4 aVertex;\n"
49071:         "attribute vec2 aTexCoord;\n"
49071:         "varying vec2 vTexCoord;\n"
49071:         "void main() { gl_Position = aVertex; vTexCoord = aTexCoord; }";
49071:     const char *fShader =
49071:         "#ifdef GL_ES\n"
49071:         "precision mediump float;\n"
49071:         "#endif\n"
49071:         "varying vec2 vTexCoord;\n"
49071:         "uniform sampler2D uTexture;\n"
49071:         "void main() { gl_FragColor = texture2D(uTexture, vTexCoord); }";
49071: 
49071:     float verts[4*4] = {
49071:         -1.0f, -1.0f, 0.0f, 1.0f,
49071:          1.0f, -1.0f, 0.0f, 1.0f,
49071:         -1.0f,  1.0f, 0.0f, 1.0f,
49071:          1.0f,  1.0f, 0.0f, 1.0f
49071:     };
49071: 
49071:     float texcoords[2*4] = {
49071:         0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f
49071:     };
49071: 
49071:     fGetIntegerv(LOCAL_GL_RENDERBUFFER_BINDING, &oldrb);
49071:     fGetIntegerv(LOCAL_GL_FRAMEBUFFER_BINDING, &oldfb);
49071:     fGetIntegerv(LOCAL_GL_CURRENT_PROGRAM, &oldprog);
49071:     fGetIntegerv(LOCAL_GL_PACK_ALIGNMENT, &oldPackAlignment);
49071: 
54505:     PushViewportRect(nsIntRect(0, 0, aSize.width, aSize.height));
54505: 
49071:     fGenRenderbuffers(1, &rb);
49071:     fBindRenderbuffer(LOCAL_GL_RENDERBUFFER, rb);
49071:     fRenderbufferStorage(LOCAL_GL_RENDERBUFFER, LOCAL_GL_RGBA,
49071:                          aSize.width, aSize.height);
49071: 
49071:     fGenFramebuffers(1, &fb);
49071:     fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, fb);
49071:     fFramebufferRenderbuffer(LOCAL_GL_FRAMEBUFFER, LOCAL_GL_COLOR_ATTACHMENT0,
49071:                              LOCAL_GL_RENDERBUFFER, rb);
49071: 
49071:     if (fCheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER) !=
49071:         LOCAL_GL_FRAMEBUFFER_COMPLETE)
49071:     {
49071:         goto cleanup;
49071:     }
49071: 
49071:     vs = fCreateShader(LOCAL_GL_VERTEX_SHADER);
49071:     fs = fCreateShader(LOCAL_GL_FRAGMENT_SHADER);
49071:     fShaderSource(vs, 1, (const GLchar**) &vShader, NULL);
49071:     fShaderSource(fs, 1, (const GLchar**) &fShader, NULL);
49071:     prog = fCreateProgram();
49071:     fAttachShader(prog, vs);
49071:     fAttachShader(prog, fs);
49071:     fBindAttribLocation(prog, 0, "aVertex");
49071:     fBindAttribLocation(prog, 1, "aTexCoord");
49071:     fLinkProgram(prog);
49071: 
49071:     fGetProgramiv(prog, LOCAL_GL_LINK_STATUS, &success);
49071:     if (!success) {
49071:         goto cleanup;
49071:     }
49071: 
49071:     fUseProgram(prog);
49071: 
49071:     fEnableVertexAttribArray(0);
49071:     fEnableVertexAttribArray(1);
49071: 
49071:     fVertexAttribPointer(0, 4, LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0, verts);
49071:     fVertexAttribPointer(1, 2, LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0, texcoords);
49071: 
49071:     fActiveTexture(LOCAL_GL_TEXTURE0);
49071:     fBindTexture(LOCAL_GL_TEXTURE_2D, aTexture);
49071: 
49071:     fUniform1i(fGetUniformLocation(prog, "uTexture"), 0);
49071: 
49071:     fDrawArrays(LOCAL_GL_TRIANGLE_STRIP, 0, 4);
49071: 
49071:     fDisableVertexAttribArray(1);
49071:     fDisableVertexAttribArray(0);
49071: 
49071:     isurf = new gfxImageSurface(aSize, gfxASurface::ImageFormatARGB32);
49071:     if (!isurf || isurf->CairoStatus()) {
49071:         isurf = nsnull;
49071:         goto cleanup;
49071:     }
49071: 
49071:     if (oldPackAlignment != 4)
49071:         fPixelStorei(LOCAL_GL_PACK_ALIGNMENT, 4);
49071: 
49071:     fReadPixels(0, 0, aSize.width, aSize.height,
49071:                 LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE,
49071:                 isurf->Data());
49071: 
49071:     if (oldPackAlignment != 4)
49071:         fPixelStorei(LOCAL_GL_PACK_ALIGNMENT, oldPackAlignment);
49071: 
49071:  cleanup:
49071:     // note that deleting 0 has no effect in any of these calls
49071:     fDeleteRenderbuffers(1, &rb);
49071:     fDeleteFramebuffers(1, &fb);
49071:     fDeleteShader(vs);
49071:     fDeleteShader(fs);
49071:     fDeleteProgram(prog);
49071: 
49071:     fBindRenderbuffer(LOCAL_GL_RENDERBUFFER, oldrb);
49071:     fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, oldfb);
49071:     fUseProgram(oldprog);
54505: 
54505:     PopViewportRect();
49071: 
49071:     return isurf.forget();
49071: }
49071: 
49076: void
49076: GLContext::ReadPixelsIntoImageSurface(GLint aX, GLint aY,
49076:                                       GLsizei aWidth, GLsizei aHeight,
49076:                                       gfxImageSurface *aDest)
49076: {
49076:     MakeCurrent();
49076: 
49076:     if (aDest->Format() != gfxASurface::ImageFormatARGB32 &&
49076:         aDest->Format() != gfxASurface::ImageFormatRGB24)
49076:     {
49076:         NS_WARNING("ReadPixelsIntoImageSurface called with invalid image format");
49076:         return;
49076:     }
49076: 
49076:     if (aDest->Width() != aWidth ||
49076:         aDest->Height() != aHeight ||
49076:         aDest->Stride() != aWidth * 4)
49076:     {
49076:         NS_WARNING("ReadPixelsIntoImageSurface called with wrong size or stride surface");
49076:         return;
49076:     }
49076: 
49076:     GLint currentPackAlignment = 0;
49076:     fGetIntegerv(LOCAL_GL_PACK_ALIGNMENT, &currentPackAlignment);
49076:     fPixelStorei(LOCAL_GL_PACK_ALIGNMENT, 4);
49076: 
49076:     // defaults for desktop
49076:     GLenum format = LOCAL_GL_BGRA;
49076:     GLenum datatype = LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV;
49076:     bool swap = false;
49076: 
49076:     if (IsGLES2()) {
49076:         datatype = LOCAL_GL_UNSIGNED_BYTE;
49076: 
49076:         if (IsExtensionSupported(gl::GLContext::EXT_read_format_bgra) ||
49076:             IsExtensionSupported(gl::GLContext::IMG_read_format) ||
49076:             IsExtensionSupported(gl::GLContext::EXT_bgra))
49076:         {
49076:             format = LOCAL_GL_BGRA;
49076:         } else {
49076:             format = LOCAL_GL_RGBA;
49076:             swap = true;
49076:         }
49076:     }
49076: 
49076:     fReadPixels(0, 0, aWidth, aHeight,
49076:                 format, datatype,
49076:                 aDest->Data());
49076: 
49076:     if (swap) {
49076:         // swap B and R bytes
49076:         for (int j = 0; j < aHeight; ++j) {
49076:             PRUint32 *row = (PRUint32*) (aDest->Data() + aDest->Stride() * j);
49076:             for (int i = 0; i < aWidth; ++i) {
49076:                 *row = (*row & 0xff00ff00) | ((*row & 0xff) << 16) | ((*row & 0xff0000) >> 16);
49076:                 row++;
49076:             }
49076:         }
49076:     }
49076: 
49076:     fPixelStorei(LOCAL_GL_PACK_ALIGNMENT, currentPackAlignment);
49076: }
49076: 
54505: void
54505: GLContext::BlitTextureImage(TextureImage *aSrc, const nsIntRect& aSrcRect,
54505:                             TextureImage *aDst, const nsIntRect& aDstRect)
54505: {
54505:     NS_ASSERTION(!aSrc->InUpdate(), "Source texture is in update!");
54505:     NS_ASSERTION(!aDst->InUpdate(), "Destination texture is in update!");
54505: 
73465:     if (aSrcRect.IsEmpty() || aDstRect.IsEmpty())
73465:         return;
73465: 
57418:     // only save/restore this stuff on Qualcomm Adreno, to work
57418:     // around an apparent bug
57418:     int savedFb = 0;
57418:     if (mVendor == VendorQualcomm) {
57418:         fGetIntegerv(LOCAL_GL_FRAMEBUFFER_BINDING, &savedFb);
57418:     }
57418: 
54505:     fDisable(LOCAL_GL_SCISSOR_TEST);
54505:     fDisable(LOCAL_GL_BLEND);
54505: 
73465:     // 2.0 means scale up by two
73465:     float blitScaleX = float(aDstRect.width) / float(aSrcRect.width);
73465:     float blitScaleY = float(aDstRect.height) / float(aSrcRect.height);
54505: 
73465:     // We start iterating over all destination tiles
73465:     aDst->BeginTileIteration();
73465:     do {
73465:         // calculate portion of the tile that is going to be painted to
73465:         nsIntRect dstSubRect;
73465:         nsIntRect dstTextureRect = aDst->GetTileRect();
73465:         dstSubRect.IntersectRect(aDstRect, dstTextureRect);
73465: 
73465:         // this tile is not part of the destination rectangle aDstRect
73465:         if (dstSubRect.IsEmpty())
73465:             continue;
73465: 
73465:         // (*) transform the rect of this tile into the rectangle defined by aSrcRect...
73465:         nsIntRect dstInSrcRect(dstSubRect);
73465:         dstInSrcRect.MoveBy(-aDstRect.TopLeft());
73465:         // ...which might be of different size, hence scale accordingly
73465:         dstInSrcRect.ScaleRoundOut(1.0f / blitScaleX, 1.0f / blitScaleY);
73465:         dstInSrcRect.MoveBy(aSrcRect.TopLeft());
73465: 
73465:         SetBlitFramebufferForDestTexture(aDst->GetTextureID());
54505:         UseBlitProgram();
54505: 
73465:         aSrc->BeginTileIteration();
73465:         // now iterate over all tiles in the source Image...
73465:         do {
73465:             // calculate portion of the source tile that is in the source rect
73465:             nsIntRect srcSubRect;
73465:             nsIntRect srcTextureRect = aSrc->GetTileRect();
73465:             srcSubRect.IntersectRect(aSrcRect, srcTextureRect);
54505: 
73465:             // this tile is not part of the source rect
73465:             if (srcSubRect.IsEmpty()) {
73465:                 continue;
73465:             }
73465:             // calculate intersection of source rect with destination rect
73465:             srcSubRect.IntersectRect(srcSubRect, dstInSrcRect);
73465:             // this tile does not overlap the current destination tile
73465:             if (srcSubRect.IsEmpty()) {
73465:                 continue;
73465:             }
73465:             // We now have the intersection of 
73465:             //     the current source tile 
73465:             // and the desired source rectangle
73465:             // and the destination tile
73465:             // and the desired destination rectange
73465:             // in destination space.
73465:             // We need to transform this back into destination space, inverting the transform from (*)
73465:             nsIntRect srcSubInDstRect(srcSubRect);
73465:             srcSubInDstRect.MoveBy(-aSrcRect.TopLeft());
73465:             srcSubInDstRect.ScaleRoundOut(blitScaleX, blitScaleY);
73465:             srcSubInDstRect.MoveBy(aDstRect.TopLeft());
73465: 
73465:             // we transform these rectangles to be relative to the current src and dst tiles, respectively
73465:             nsIntSize srcSize = srcTextureRect.Size();
73465:             nsIntSize dstSize = dstTextureRect.Size();
73465:             srcSubRect.MoveBy(-srcTextureRect.x, -srcTextureRect.y);
73465:             srcSubInDstRect.MoveBy(-dstTextureRect.x, -dstTextureRect.y);
73465: 
73465:             float dx0 = 2.0 * float(srcSubInDstRect.x) / float(dstSize.width) - 1.0;
73465:             float dy0 = 2.0 * float(srcSubInDstRect.y) / float(dstSize.height) - 1.0;
73465:             float dx1 = 2.0 * float(srcSubInDstRect.x + srcSubInDstRect.width) / float(dstSize.width) - 1.0;
73465:             float dy1 = 2.0 * float(srcSubInDstRect.y + srcSubInDstRect.height) / float(dstSize.height) - 1.0;
54505:             PushViewportRect(nsIntRect(0, 0, dstSize.width, dstSize.height));
54505: 
57420:             RectTriangles rects;
57421:             if (aSrc->GetWrapMode() == LOCAL_GL_REPEAT) {
57421:                 rects.addRect(/* dest rectangle */
57421:                         dx0, dy0, dx1, dy1,
57421:                         /* tex coords */
73465:                         srcSubRect.x / float(srcSize.width),
73465:                         srcSubRect.y / float(srcSize.height),
73465:                         srcSubRect.XMost() / float(srcSize.width),
73465:                         srcSubRect.YMost() / float(srcSize.height));
57421:             } else {
73465:                 DecomposeIntoNoRepeatTriangles(srcSubRect, srcSize, rects);
57420: 
57420:                 // now put the coords into the d[xy]0 .. d[xy]1 coordinate space
57420:                 // from the 0..1 that it comes out of decompose
70073:                 RectTriangles::vert_coord* v = (RectTriangles::vert_coord*)rects.vertexPointer();
73465: 
73465:                 for (unsigned int i = 0; i < rects.elements(); ++i) {
70073:                     v[i].x = (v[i].x * (dx1 - dx0)) + dx0;
70073:                     v[i].y = (v[i].y * (dy1 - dy0)) + dy0;
57420:                 }
57421:             }
57421: 
73465:             TextureImage::ScopedBindTexture texBind(aSrc, LOCAL_GL_TEXTURE0);
54505: 
54505:             fBindBuffer(LOCAL_GL_ARRAY_BUFFER, 0);
54505: 
70073:             fVertexAttribPointer(0, 2, LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0, rects.vertexPointer());
70073:             fVertexAttribPointer(1, 2, LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0, rects.texCoordPointer());
54505: 
54505:             fEnableVertexAttribArray(0);
54505:             fEnableVertexAttribArray(1);
54505: 
70073:             fDrawArrays(LOCAL_GL_TRIANGLES, 0, rects.elements());
54505: 
54505:             fDisableVertexAttribArray(0);
54505:             fDisableVertexAttribArray(1);
54505: 
73465:             PopViewportRect();
73465:         } while (aSrc->NextTile());
73465:     } while (aDst->NextTile());
73465: 
54505:     fVertexAttribPointer(0, 2, LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0, NULL);
54505:     fVertexAttribPointer(1, 2, LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0, NULL);
54505: 
57418:     // unbind the previous texture from the framebuffer
54505:     SetBlitFramebufferForDestTexture(0);
54505: 
57418:     // then put back the previous framebuffer, and don't
57418:     // enable stencil if it wasn't enabled on entry to work
57418:     // around Adreno 200 bug that causes us to crash if
57418:     // we enable scissor test while the current FBO is invalid
57418:     // (which it will be, once we assign texture 0 to the color
57418:     // attachment)
57418:     if (mVendor == VendorQualcomm) {
57418:         fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, savedFb);
57418:     }
57418: 
54505:     fEnable(LOCAL_GL_SCISSOR_TEST);
54505:     fEnable(LOCAL_GL_BLEND);
54505: }
54505: 
60728: static unsigned int 
60728: DataOffset(gfxImageSurface *aSurf, const nsIntPoint &aPoint)
60728: {
60728:   unsigned int data = aPoint.y * aSurf->Stride();
60728:   data += aPoint.x * gfxASurface::BytePerPixelFromFormat(aSurf->Format());
60728:   return data;
60728: }
59436: 
59436: ShaderProgramType 
59436: GLContext::UploadSurfaceToTexture(gfxASurface *aSurface, 
60728:                                   const nsIntRegion& aDstRegion,
59436:                                   GLuint& aTexture,
59436:                                   bool aOverwrite,
60728:                                   const nsIntPoint& aSrcPoint,
59442:                                   bool aPixelBuffer)
59436: {
59436:     bool textureInited = aOverwrite ? false : true;
59436:     MakeCurrent();
59436:     fActiveTexture(LOCAL_GL_TEXTURE0);
59436:   
59436:     if (!aTexture) {
59436:         fGenTextures(1, &aTexture);
59436:         fBindTexture(LOCAL_GL_TEXTURE_2D, aTexture);
59436:         fTexParameteri(LOCAL_GL_TEXTURE_2D, 
59436:                        LOCAL_GL_TEXTURE_MIN_FILTER, 
59436:                        LOCAL_GL_LINEAR);
59436:         fTexParameteri(LOCAL_GL_TEXTURE_2D, 
59436:                        LOCAL_GL_TEXTURE_MAG_FILTER, 
59436:                        LOCAL_GL_LINEAR);
59436:         fTexParameteri(LOCAL_GL_TEXTURE_2D, 
59436:                        LOCAL_GL_TEXTURE_WRAP_S, 
59436:                        LOCAL_GL_CLAMP_TO_EDGE);
59436:         fTexParameteri(LOCAL_GL_TEXTURE_2D, 
59436:                        LOCAL_GL_TEXTURE_WRAP_T, 
59436:                        LOCAL_GL_CLAMP_TO_EDGE);
59436:         textureInited = false;
59436:     } else {
59436:         fBindTexture(LOCAL_GL_TEXTURE_2D, aTexture);
59436:     }
59436: 
60728:     nsIntRegion paintRegion;
60728:     if (!textureInited) {
60728:         paintRegion = nsIntRegion(aDstRegion.GetBounds());
60728:     } else {
60728:         paintRegion = aDstRegion;
60728:     }
60728: 
59436:     nsRefPtr<gfxImageSurface> imageSurface = aSurface->GetAsImageSurface();
59465:     unsigned char* data = NULL;
59436: 
59436:     if (!imageSurface || 
59436:         (imageSurface->Format() != gfxASurface::ImageFormatARGB32 &&
59436:          imageSurface->Format() != gfxASurface::ImageFormatRGB24 &&
73014:          imageSurface->Format() != gfxASurface::ImageFormatRGB16_565 &&
73014:          imageSurface->Format() != gfxASurface::ImageFormatA8)) {
59436:         // We can't get suitable pixel data for the surface, make a copy
60728:         nsIntRect bounds = aDstRegion.GetBounds();
59436:         imageSurface = 
60728:           new gfxImageSurface(gfxIntSize(bounds.width, bounds.height), 
59436:                               gfxASurface::ImageFormatARGB32);
59436:   
59436:         nsRefPtr<gfxContext> context = new gfxContext(imageSurface);
59436: 
60728:         context->Translate(-gfxPoint(aSrcPoint.x, aSrcPoint.y));
59436:         context->SetSource(aSurface);
59436:         context->Paint();
59465:         data = imageSurface->Data();
60714:         NS_ASSERTION(!aPixelBuffer,
60714:                      "Must be using an image compatible surface with pixel buffers!");
59436:     } else {
59465:         // If a pixel buffer is bound the data pointer parameter is relative
59465:         // to the start of the data block.
59465:         if (!aPixelBuffer) {
59465:               data = imageSurface->Data();
59465:         }
60728:         data += DataOffset(imageSurface, aSrcPoint);
59436:     }
59436: 
59436:     GLenum format;
59436:     GLenum internalformat;
59436:     GLenum type;
59436:     PRInt32 pixelSize = gfxASurface::BytePerPixelFromFormat(imageSurface->Format());
59436:     ShaderProgramType shader;
59436: 
59436:     switch (imageSurface->Format()) {
59436:         case gfxASurface::ImageFormatARGB32:
59436:             format = LOCAL_GL_RGBA;
59436:             type = LOCAL_GL_UNSIGNED_BYTE;
59436:             shader = BGRALayerProgramType;
59436:             break;
59436:         case gfxASurface::ImageFormatRGB24:
59436:             // Treat RGB24 surfaces as RGBA32 except for the shader
59436:             // program used.
59436:             format = LOCAL_GL_RGBA;
59436:             type = LOCAL_GL_UNSIGNED_BYTE;
59436:             shader = BGRXLayerProgramType;
59436:             break;
59436:         case gfxASurface::ImageFormatRGB16_565:
59436:             format = LOCAL_GL_RGB;
59436:             type = LOCAL_GL_UNSIGNED_SHORT_5_6_5;
59436:             shader = RGBALayerProgramType;
59436:             break;
73014:         case gfxASurface::ImageFormatA8:
73014:             format = LOCAL_GL_LUMINANCE;
73014:             type = LOCAL_GL_UNSIGNED_BYTE;
73014:             // We don't have a specific luminance shader
73014:             shader = ShaderProgramType(0);
73014:             break;
59436:         default:
59436:             NS_ASSERTION(false, "Unhandled image surface format!");
60123:             format = 0;
60123:             type = 0;
60123:             shader = ShaderProgramType(0);
59436:     }
59436: 
74304:     PRInt32 stride = imageSurface->Stride();
74304: 
74302: #ifndef USE_GLES2
59436:     internalformat = LOCAL_GL_RGBA;
59436: #else
59436:     internalformat = format;
60728: #endif
59436: 
60728:     nsIntRegionRectIterator iter(paintRegion);
60728:     const nsIntRect *iterRect;
60728: 
60728:     // Top left point of the region's bounding rectangle.
60728:     nsIntPoint topLeft = paintRegion.GetBounds().TopLeft();
60728: 
60728:     while ((iterRect = iter.Next())) {
60728:         // The inital data pointer is at the top left point of the region's
60728:         // bounding rectangle. We need to find the offset of this rect
60728:         // within the region and adjust the data pointer accordingly.
60728:         unsigned char *rectData = 
60728:             data + DataOffset(imageSurface, iterRect->TopLeft() - topLeft);
60728: 
74304:         NS_ASSERTION(textureInited || (iterRect->x == 0 && iterRect->y == 0), 
74304:                      "Must be uploading to the origin when we don't have an existing texture");
59436: 
59436:         if (textureInited) {
74304:             TexSubImage2D(LOCAL_GL_TEXTURE_2D,
59436:                           0,
60728:                           iterRect->x,
60728:                           iterRect->y,
60728:                           iterRect->width,
60728:                           iterRect->height,
74304:                           stride,
74304:                           pixelSize,
59436:                           format,
59436:                           type,
60728:                           rectData);
59436:         } else {
74304:             TexImage2D(LOCAL_GL_TEXTURE_2D,
59436:                        0,
59436:                        internalformat,
60728:                        iterRect->width,
60728:                        iterRect->height,
74304:                        stride,
74304:                        pixelSize,
59436:                        0,
59436:                        format,
59436:                        type,
60728:                        rectData);
60728:         }
60728: 
59436:     }
59436: 
74304:     return shader;
74304: }
74304: 
74304: static GLint GetAddressAlignment(ptrdiff_t aAddress)
74304: {
74304:     if (!(aAddress & 0x7)) {
74304:        return 8;
74304:     } else if (!(aAddress & 0x3)) {
74304:         return 4;
74304:     } else if (!(aAddress & 0x1)) {
74304:         return 2;
74304:     } else {
74304:         return 1;
74304:     }
74304: }
74304: 
74304: void
74304: GLContext::TexImage2D(GLenum target, GLint level, GLint internalformat, 
74304:                       GLsizei width, GLsizei height, GLsizei stride,
74304:                       GLint pixelsize, GLint border, GLenum format, 
74304:                       GLenum type, const GLvoid *pixels)
74304: {
81648: #ifdef USE_GLES2
81648:     // Use GLES-specific workarounds for GL_UNPACK_ROW_LENGTH; these are
81648:     // implemented in TexSubImage2D.
74304:     fTexImage2D(target,
74304:                 border,
74304:                 internalformat,
74304:                 width,
74304:                 height,
74304:                 border,
74304:                 format,
74304:                 type,
74304:                 NULL);
81648:     TexSubImage2D(target,
74304:                   level,
74304:                   0,
81648:                   0,
74304:                   width,
81648:                   height,
81648:                   stride,
81648:                   pixelsize,
74304:                   format,
74304:                   type,
81648:                   pixels);
81648: #else
81648:     fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 
81648:                  NS_MIN(GetAddressAlignment((ptrdiff_t)pixels),
81648:                         GetAddressAlignment((ptrdiff_t)stride)));
81648:     int rowLength = stride/pixelsize;
81648:     fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, rowLength);
74304:     fTexImage2D(target,
74304:                 level,
74304:                 internalformat,
74304:                 width,
74304:                 height,
74304:                 border,
74304:                 format,
74304:                 type,
74304:                 pixels);
59436:     fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, 0);
74304:     fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);
81648: #endif
74304: }
59436: 
74304: void
74304: GLContext::TexSubImage2D(GLenum target, GLint level, 
74304:                          GLint xoffset, GLint yoffset, 
74304:                          GLsizei width, GLsizei height, GLsizei stride,
74304:                          GLint pixelsize, GLenum format, 
74304:                          GLenum type, const GLvoid* pixels)
74304: {
81648: #ifdef USE_GLES2
81648:   if (IsExtensionSupported(EXT_unpack_subimage)) {
81648:         TexSubImage2DWithUnpackSubimageGLES(target, level, xoffset, yoffset,
81648:                                             width, height, stride,
81648:                                             pixelsize, format, type, pixels);
81648:     } else {
81648:         TexSubImage2DWithoutUnpackSubimage(target, level, xoffset, yoffset,
81648:                                            width, height, stride,
81648:                                            pixelsize, format, type, pixels);
81648:     }
81648: #else
74304:     fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,
74304:                  NS_MIN(GetAddressAlignment((ptrdiff_t)pixels),
74304:                         GetAddressAlignment((ptrdiff_t)stride)));
78280:     int rowLength = stride/pixelsize;
78280:     fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, rowLength);
74304:     fTexSubImage2D(target,
74304:                    level,
74304:                    xoffset,
74304:                    yoffset,
74304:                    width,
74304:                    height,
74304:                    format,
74304:                    type,
74304:                    pixels);
81648:     fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, 0);
81648:     fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);
81648: #endif
81648: }
74304: 
81648: void
81648: GLContext::TexSubImage2DWithUnpackSubimageGLES(GLenum target, GLint level,
81648:                                                GLint xoffset, GLint yoffset,
81648:                                                GLsizei width, GLsizei height,
81648:                                                GLsizei stride, GLint pixelsize,
81648:                                                GLenum format, GLenum type,
81648:                                                const GLvoid* pixels)
81648: {
81648:     fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,
81648:                  NS_MIN(GetAddressAlignment((ptrdiff_t)pixels),
81648:                         GetAddressAlignment((ptrdiff_t)stride)));
81648:     if (stride == width * pixelsize) {
81648:         // No need to use GL_UNPACK_ROW_LENGTH.
81648:         fTexSubImage2D(target,
81648:                        level,
81648:                        xoffset,
81648:                        yoffset,
81648:                        width,
81648:                        height,
81648:                        format,
81648:                        type,
81648:                        pixels);
81648:     } else {
81648:         // When using GL_UNPACK_ROW_LENGTH, we need to work around a Tegra
81648:         // driver crash where the driver apparently tries to read
81648:         // (stride - width * pixelsize) bytes past the end of the last input
81648:         // row. We only upload the first height-1 rows using GL_UNPACK_ROW_LENGTH,
81648:         // and then we upload the final row separately. See bug 697990.
81648:         int rowLength = stride/pixelsize;
81648:         fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, rowLength);
81648:         fTexSubImage2D(target,
81648:                        level,
81648:                        xoffset,
81648:                        yoffset,
81648:                        width,
81648:                        height-1,
81648:                        format,
81648:                        type,
81648:                        pixels);
74304:         fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, 0);
81648:         fTexSubImage2D(target,
81648:                        level,
81648:                        xoffset,
81648:                        yoffset+height-1,
81648:                        width,
81648:                        1,
81648:                        format,
81648:                        type,
81648:                        (const unsigned char *)pixels+(height-1)*stride);
81648:     }
81648:     fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);
81648: }
81648: 
81648: void
81648: GLContext::TexSubImage2DWithoutUnpackSubimage(GLenum target, GLint level,
81648:                                               GLint xoffset, GLint yoffset,
81648:                                               GLsizei width, GLsizei height,
81648:                                               GLsizei stride, GLint pixelsize,
81648:                                               GLenum format, GLenum type,
81648:                                               const GLvoid* pixels)
81648: {
81648:     if (stride == width * pixelsize) {
81648:         fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,
81648:                      NS_MIN(GetAddressAlignment((ptrdiff_t)pixels),
81648:                             GetAddressAlignment((ptrdiff_t)stride)));
81648:         fTexSubImage2D(target,
81648:                        level,
81648:                        xoffset,
81648:                        yoffset,
81648:                        width,
81648:                        height,
81648:                        format,
81648:                        type,
81648:                        pixels);
81648:     } else {
81648:         // Not using the whole row of texture data and GL_UNPACK_ROW_LENGTH
81648:         // isn't supported. We make a copy of the texture data we're using,
81648:         // such that we're using the whole row of data in the copy. This turns
81648:         // out to be more efficient than uploading row-by-row; see bug 698197.
81648:         unsigned char *newPixels = new unsigned char[width*height*pixelsize];
81648:         unsigned char *rowDest = newPixels;
81648:         const unsigned char *rowSource = (const unsigned char *)pixels;
81648:         for (int h = 0; h < height; h++) {
81648:             memcpy(rowDest, rowSource, width*pixelsize);
81648:             rowDest += width*pixelsize;
81648:             rowSource += stride;
81648:         }
81648: 
81648:         stride = width*pixelsize;
81648:         fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,
81648:                      NS_MIN(GetAddressAlignment((ptrdiff_t)newPixels),
81648:                             GetAddressAlignment((ptrdiff_t)stride)));
81648:         fTexSubImage2D(target,
81648:                        level,
81648:                        xoffset,
81648:                        yoffset,
81648:                        width,
81648:                        height,
81648:                        format,
81648:                        type,
81648:                        newPixels);
81648:         delete [] newPixels;
81648:     }
74304:     fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);
59436: }
59436: 
54505: void
57420: GLContext::RectTriangles::addRect(GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1,
57420:                                   GLfloat tx0, GLfloat ty0, GLfloat tx1, GLfloat ty1)
57420: {
70073:     vert_coord v;
70073:     v.x = x0; v.y = y0;
70073:     vertexCoords.AppendElement(v);
70073:     v.x = x1; v.y = y0;
70073:     vertexCoords.AppendElement(v);
70073:     v.x = x0; v.y = y1;
70073:     vertexCoords.AppendElement(v);
57420: 
70073:     v.x = x0; v.y = y1;
70073:     vertexCoords.AppendElement(v);
70073:     v.x = x1; v.y = y0;
70073:     vertexCoords.AppendElement(v);
70073:     v.x = x1; v.y = y1;
70073:     vertexCoords.AppendElement(v);
57420: 
70073:     tex_coord t;
70073:     t.u = tx0; t.v = ty0;
70073:     texCoords.AppendElement(t);
70073:     t.u = tx1; t.v = ty0;
70073:     texCoords.AppendElement(t);
70073:     t.u = tx0; t.v = ty1;
70073:     texCoords.AppendElement(t);
57420: 
70073:     t.u = tx0; t.v = ty1;
70073:     texCoords.AppendElement(t);
70073:     t.u = tx1; t.v = ty0;
70073:     texCoords.AppendElement(t);
70073:     t.u = tx1; t.v = ty1;
70073:     texCoords.AppendElement(t);
57420: }
57420: 
57420: static GLfloat
57420: WrapTexCoord(GLfloat v)
57420: {
57420:     // fmodf gives negative results for negative numbers;
57420:     // that is, fmodf(0.75, 1.0) == 0.75, but
57420:     // fmodf(-0.75, 1.0) == -0.75.  For the negative case,
57420:     // the result we need is 0.25, so we add 1.0f.
57420:     if (v < 0.0f) {
57420:         return 1.0f + fmodf(v, 1.0f);
57420:     }
57420: 
57420:     return fmodf(v, 1.0f);
57420: }
57420: 
57420: void
57420: GLContext::DecomposeIntoNoRepeatTriangles(const nsIntRect& aTexCoordRect,
57420:                                           const nsIntSize& aTexSize,
57420:                                           RectTriangles& aRects)
57420: {
57420:     // normalize this
57420:     nsIntRect tcr(aTexCoordRect);
57420:     while (tcr.x > aTexSize.width)
57420:         tcr.x -= aTexSize.width;
57420:     while (tcr.y > aTexSize.height)
57420:         tcr.y -= aTexSize.height;
57420: 
57420:     // Compute top left and bottom right tex coordinates
57420:     GLfloat tl[2] =
57420:         { GLfloat(tcr.x) / GLfloat(aTexSize.width),
57420:           GLfloat(tcr.y) / GLfloat(aTexSize.height) };
57420:     GLfloat br[2] =
57420:         { GLfloat(tcr.XMost()) / GLfloat(aTexSize.width),
57420:           GLfloat(tcr.YMost()) / GLfloat(aTexSize.height) };
57420: 
57420:     // then check if we wrap in either the x or y axis; if we do,
57420:     // then also use fmod to figure out the "true" non-wrapping
57420:     // texture coordinates.
57420: 
57420:     bool xwrap = false, ywrap = false;
57420:     if (tcr.x < 0 || tcr.x > aTexSize.width ||
57420:         tcr.XMost() < 0 || tcr.XMost() > aTexSize.width)
57420:     {
57420:         xwrap = true;
57420:         tl[0] = WrapTexCoord(tl[0]);
57420:         br[0] = WrapTexCoord(br[0]);
57420:     }
57420: 
57420:     if (tcr.y < 0 || tcr.y > aTexSize.height ||
57420:         tcr.YMost() < 0 || tcr.YMost() > aTexSize.height)
57420:     {
57420:         ywrap = true;
57420:         tl[1] = WrapTexCoord(tl[1]);
57420:         br[1] = WrapTexCoord(br[1]);
57420:     }
57420: 
57420:     NS_ASSERTION(tl[0] >= 0.0f && tl[0] <= 1.0f &&
57420:                  tl[1] >= 0.0f && tl[1] <= 1.0f &&
57420:                  br[0] >= 0.0f && br[0] <= 1.0f &&
57420:                  br[1] >= 0.0f && br[1] <= 1.0f,
57420:                  "Somehow generated invalid texture coordinates");
57420: 
57420:     // If xwrap is false, the texture will be sampled from tl[0]
57420:     // .. br[0].  If xwrap is true, then it will be split into tl[0]
57420:     // .. 1.0, and 0.0 .. br[0].  Same for the Y axis.  The
57420:     // destination rectangle is also split appropriately, according
57420:     // to the calculated xmid/ymid values.
57420: 
57420:     // There isn't a 1:1 mapping between tex coords and destination coords;
57420:     // when computing midpoints, we have to take that into account.  We
57420:     // need to map the texture coords, which are (in the wrap case):
57420:     // |tl->1| and |0->br| to the |0->1| range of the vertex coords.  So
57420:     // we have the length (1-tl)+(br) that needs to map into 0->1.
57420:     // These are only valid if there is wrap involved, they won't be used
57420:     // otherwise.
57420:     GLfloat xlen = (1.0f - tl[0]) + br[0];
57420:     GLfloat ylen = (1.0f - tl[1]) + br[1];
57420: 
57420:     NS_ASSERTION(!xwrap || xlen > 0.0f, "xlen isn't > 0, what's going on?");
57420:     NS_ASSERTION(!ywrap || ylen > 0.0f, "ylen isn't > 0, what's going on?");
57420:     NS_ASSERTION(aTexCoordRect.width <= aTexSize.width &&
57420:                  aTexCoordRect.height <= aTexSize.height, "tex coord rect would cause tiling!");
57420: 
57420:     if (!xwrap && !ywrap) {
57420:         aRects.addRect(0.0f, 0.0f, 1.0f, 1.0f,
57420:                        tl[0], tl[1], br[0], br[1]);
57420:     } else if (!xwrap && ywrap) {
57420:         GLfloat ymid = (1.0f - tl[1]) / ylen;
57420:         aRects.addRect(0.0f, 0.0f,
57420:                        1.0f, ymid,
57420:                        tl[0], tl[1],
57420:                        br[0], 1.0f);
57420:         aRects.addRect(0.0f, ymid,
57420:                        1.0f, 1.0f,
57420:                        tl[0], 0.0f,
57420:                        br[0], br[1]);
57420:     } else if (xwrap && !ywrap) {
57420:         GLfloat xmid = (1.0f - tl[0]) / xlen;
57420:         aRects.addRect(0.0f, 0.0f,
57420:                        xmid, 1.0f,
57420:                        tl[0], tl[1],
57420:                        1.0f, br[1]);
57420:         aRects.addRect(xmid, 0.0f,
57420:                        1.0f, 1.0f,
57420:                        0.0f, tl[1],
57420:                        br[0], br[1]);
57420:     } else {
57420:         GLfloat xmid = (1.0f - tl[0]) / xlen;
57420:         GLfloat ymid = (1.0f - tl[1]) / ylen;
57420:         aRects.addRect(0.0f, 0.0f,
57420:                        xmid, ymid,
57420:                        tl[0], tl[1],
57420:                        1.0f, 1.0f);
57420:         aRects.addRect(xmid, 0.0f,
57420:                        1.0f, ymid,
57420:                        0.0f, tl[1],
57420:                        br[0], 1.0f);
57420:         aRects.addRect(0.0f, ymid,
57420:                        xmid, 1.0f,
57420:                        tl[0], 0.0f,
57420:                        1.0f, br[1]);
57420:         aRects.addRect(xmid, ymid,
57420:                        1.0f, 1.0f,
57420:                        0.0f, 0.0f,
57420:                        br[0], br[1]);
57420:     }
57420: }
57420: 
57420: void
54505: GLContext::UseBlitProgram()
54505: {
54505:     if (mBlitProgram) {
54505:         fUseProgram(mBlitProgram);
54505:         return;
54505:     }
54505: 
54505:     mBlitProgram = fCreateProgram();
54505: 
54505:     GLuint shaders[2];
54505:     shaders[0] = fCreateShader(LOCAL_GL_VERTEX_SHADER);
54505:     shaders[1] = fCreateShader(LOCAL_GL_FRAGMENT_SHADER);
54505: 
54505:     const char *blitVSSrc = 
54505:         "attribute vec2 aVertex;"
54505:         "attribute vec2 aTexCoord;"
54505:         "varying vec2 vTexCoord;"
54505:         "void main() {"
54505:         "  vTexCoord = aTexCoord;"
54505:         "  gl_Position = vec4(aVertex, 0.0, 1.0);"
54505:         "}";
54505:     const char *blitFSSrc = "#ifdef GL_ES\nprecision mediump float;\n#endif\n"
54505:         "uniform sampler2D uSrcTexture;"
54505:         "varying vec2 vTexCoord;"
54505:         "void main() {"
54505:         "  gl_FragColor = texture2D(uSrcTexture, vTexCoord);"
54505:         "}";
54505: 
54505:     fShaderSource(shaders[0], 1, (const GLchar**) &blitVSSrc, NULL);
54505:     fShaderSource(shaders[1], 1, (const GLchar**) &blitFSSrc, NULL);
54505: 
54505:     for (int i = 0; i < 2; ++i) {
54505:         GLint success, len = 0;
54505: 
54505:         fCompileShader(shaders[i]);
54505:         fGetShaderiv(shaders[i], LOCAL_GL_COMPILE_STATUS, &success);
54505:         NS_ASSERTION(success, "Shader compilation failed!");
54505: 
54505:         if (!success) {
54505:             nsCAutoString log;
54505:             fGetShaderiv(shaders[i], LOCAL_GL_INFO_LOG_LENGTH, (GLint*) &len);
54505:             log.SetCapacity(len);
54505:             fGetShaderInfoLog(shaders[i], len, (GLint*) &len, (char*) log.BeginWriting());
54505:             log.SetLength(len);
54505: 
71730:             printf_stderr("Shader %d compilation failed:\n%s\n", log.get());
54505:             return;
54505:         }
54505: 
54505:         fAttachShader(mBlitProgram, shaders[i]);
54505:         fDeleteShader(shaders[i]);
54505:     }
54505: 
54505:     fBindAttribLocation(mBlitProgram, 0, "aVertex");
54505:     fBindAttribLocation(mBlitProgram, 1, "aTexCoord");
54505: 
54505:     fLinkProgram(mBlitProgram);
54505: 
54505:     GLint success, len = 0;
54505:     fGetProgramiv(mBlitProgram, LOCAL_GL_LINK_STATUS, &success);
54505:     NS_ASSERTION(success, "Shader linking failed!");
54505: 
54505:     if (!success) {
54505:         nsCAutoString log;
54505:         fGetProgramiv(mBlitProgram, LOCAL_GL_INFO_LOG_LENGTH, (GLint*) &len);
54505:         log.SetCapacity(len);
54505:         fGetProgramInfoLog(mBlitProgram, len, (GLint*) &len, (char*) log.BeginWriting());
54505:         log.SetLength(len);
54505: 
71730:         printf_stderr("Program linking failed:\n%s\n", log.get());
54505:         return;
54505:     }
54505: 
54505:     fUseProgram(mBlitProgram);
54505:     fUniform1i(fGetUniformLocation(mBlitProgram, "uSrcTexture"), 0);
54505: }
54505: 
54505: void
54505: GLContext::SetBlitFramebufferForDestTexture(GLuint aTexture)
54505: {
54505:     if (!mBlitFramebuffer) {
54505:         fGenFramebuffers(1, &mBlitFramebuffer);
54505:     }
54505: 
54505:     fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, mBlitFramebuffer);
54505:     fFramebufferTexture2D(LOCAL_GL_FRAMEBUFFER,
54505:                           LOCAL_GL_COLOR_ATTACHMENT0,
54505:                           LOCAL_GL_TEXTURE_2D,
54505:                           aTexture,
54505:                           0);
54505: 
83160:     GLenum result = fCheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER);
83160:     if (aTexture && (result != LOCAL_GL_FRAMEBUFFER_COMPLETE)) {
83160:         nsCAutoString msg;
83160:         msg.Append("Framebuffer not complete -- error 0x");
83160:         msg.AppendInt(result, 16);
81261:         // Note: if you are hitting this, it is likely that
54505:         // your texture is not texture complete -- that is, you
54505:         // allocated a texture name, but didn't actually define its
54505:         // size via a call to TexImage2D.
83160:         NS_RUNTIMEABORT(msg.get());
54505:     }
54505: }
54505: 
47908: #ifdef DEBUG
47908: 
47908: void
47908: GLContext::CreatedProgram(GLContext *aOrigin, GLuint aName)
47908: {
47908:     mTrackedPrograms.AppendElement(NamedResource(aOrigin, aName));
47908: }
47908: 
47908: void
47908: GLContext::CreatedShader(GLContext *aOrigin, GLuint aName)
47908: {
47908:     mTrackedShaders.AppendElement(NamedResource(aOrigin, aName));
47908: }
47908: 
47908: void
47908: GLContext::CreatedBuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames)
47908: {
47908:     for (GLsizei i = 0; i < aCount; ++i) {
47908:         mTrackedBuffers.AppendElement(NamedResource(aOrigin, aNames[i]));
47908:     }
47908: }
47908: 
47908: void
47908: GLContext::CreatedTextures(GLContext *aOrigin, GLsizei aCount, GLuint *aNames)
47908: {
47908:     for (GLsizei i = 0; i < aCount; ++i) {
47908:         mTrackedTextures.AppendElement(NamedResource(aOrigin, aNames[i]));
47908:     }
47908: }
47908: 
47908: void
47908: GLContext::CreatedFramebuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames)
47908: {
47908:     for (GLsizei i = 0; i < aCount; ++i) {
47908:         mTrackedFramebuffers.AppendElement(NamedResource(aOrigin, aNames[i]));
47908:     }
47908: }
47908: 
47908: void
47908: GLContext::CreatedRenderbuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames)
47908: {
47908:     for (GLsizei i = 0; i < aCount; ++i) {
47908:         mTrackedRenderbuffers.AppendElement(NamedResource(aOrigin, aNames[i]));
47908:     }
47908: }
47908: 
47908: static void
47908: RemoveNamesFromArray(GLContext *aOrigin, GLsizei aCount, GLuint *aNames, nsTArray<GLContext::NamedResource>& aArray)
47908: {
47908:     for (GLsizei j = 0; j < aCount; ++j) {
47908:         GLuint name = aNames[j];
52047:         // name 0 can be ignored
52047:         if (name == 0)
52047:             continue;
52047: 
79445:         bool found = false;
47908:         for (PRUint32 i = 0; i < aArray.Length(); ++i) {
47908:             if (aArray[i].name == name) {
47908:                 aArray.RemoveElementAt(i);
80486:                 found = true;
47908:                 break;
47908:             }
47908:         }
47908:     }
47908: }
47908: 
47908: void
47908: GLContext::DeletedProgram(GLContext *aOrigin, GLuint aName)
47908: {
47908:     RemoveNamesFromArray(aOrigin, 1, &aName, mTrackedPrograms);
47908: }
47908: 
47908: void
47908: GLContext::DeletedShader(GLContext *aOrigin, GLuint aName)
47908: {
47908:     RemoveNamesFromArray(aOrigin, 1, &aName, mTrackedShaders);
47908: }
47908: 
47908: void
47908: GLContext::DeletedBuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames)
47908: {
47908:     RemoveNamesFromArray(aOrigin, aCount, aNames, mTrackedBuffers);
47908: }
47908: 
47908: void
47908: GLContext::DeletedTextures(GLContext *aOrigin, GLsizei aCount, GLuint *aNames)
47908: {
47908:     RemoveNamesFromArray(aOrigin, aCount, aNames, mTrackedTextures);
47908: }
47908: 
47908: void
47908: GLContext::DeletedFramebuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames)
47908: {
47908:     RemoveNamesFromArray(aOrigin, aCount, aNames, mTrackedFramebuffers);
47908: }
47908: 
47908: void
47908: GLContext::DeletedRenderbuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames)
47908: {
47908:     RemoveNamesFromArray(aOrigin, aCount, aNames, mTrackedRenderbuffers);
47908: }
47908: 
47908: static void
47908: MarkContextDestroyedInArray(GLContext *aContext, nsTArray<GLContext::NamedResource>& aArray)
47908: {
47908:     for (PRUint32 i = 0; i < aArray.Length(); ++i) {
47908:         if (aArray[i].origin == aContext)
80486:             aArray[i].originDeleted = true;
47908:     }
47908: }
47908: 
47908: void
47908: GLContext::SharedContextDestroyed(GLContext *aChild)
47908: {
47908:     MarkContextDestroyedInArray(aChild, mTrackedPrograms);
47908:     MarkContextDestroyedInArray(aChild, mTrackedShaders);
47908:     MarkContextDestroyedInArray(aChild, mTrackedTextures);
47908:     MarkContextDestroyedInArray(aChild, mTrackedFramebuffers);
47908:     MarkContextDestroyedInArray(aChild, mTrackedRenderbuffers);
47908:     MarkContextDestroyedInArray(aChild, mTrackedBuffers);
47908: }
47908: 
47908: static void
47908: ReportArrayContents(const nsTArray<GLContext::NamedResource>& aArray)
47908: {
47908:     nsTArray<GLContext::NamedResource> copy(aArray);
47908:     copy.Sort();
47908: 
47908:     GLContext *lastContext = NULL;
47908:     for (PRUint32 i = 0; i < copy.Length(); ++i) {
47908:         if (lastContext != copy[i].origin) {
47908:             if (lastContext)
47908:                 printf_stderr("\n");
47908:             printf_stderr("  [%p - %s] ", copy[i].origin, copy[i].originDeleted ? "deleted" : "live");
47908:             lastContext = copy[i].origin;
47908:         }
47908:         printf_stderr("%d ", copy[i].name);
47908:     }
47908:     printf_stderr("\n");
47908: }
47908: 
47908: void
47908: GLContext::ReportOutstandingNames()
47908: {
47908:     printf_stderr("== GLContext %p ==\n", this);
47908:     printf_stderr("Outstanding Textures:\n");
47908:     ReportArrayContents(mTrackedTextures);
47908:     printf_stderr("Outstanding Buffers:\n");
47908:     ReportArrayContents(mTrackedBuffers);
47908:     printf_stderr("Outstanding Programs:\n");
47908:     ReportArrayContents(mTrackedPrograms);
47908:     printf_stderr("Outstanding Shaders:\n");
47908:     ReportArrayContents(mTrackedShaders);
47908:     printf_stderr("Outstanding Framebuffers:\n");
47908:     ReportArrayContents(mTrackedFramebuffers);
47908:     printf_stderr("Outstanding Renderbuffers:\n");
47908:     ReportArrayContents(mTrackedRenderbuffers);
47908: }
47908: 
47908: #endif /* DEBUG */
47908: 
41369: } /* namespace gl */
41369: } /* namespace mozilla */
