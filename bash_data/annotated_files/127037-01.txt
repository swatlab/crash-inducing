100179: /* This Source Code Form is subject to the terms of the Mozilla Public
100179:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
100179:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
100179: 
100179: #include "MediaManager.h"
100179: 
100179: #include "MediaStreamGraph.h"
100179: #include "nsIDOMFile.h"
100179: #include "nsIEventTarget.h"
116351: #include "nsIUUIDGenerator.h"
100179: #include "nsIScriptGlobalObject.h"
101616: #include "nsIPopupWindowManager.h"
126735: #include "nsISupportsArray.h"
100179: 
116351: // For PR_snprintf
116351: #include "prprf.h"
116351: 
100179: #include "nsJSUtils.h"
100179: #include "nsDOMFile.h"
101616: #include "nsGlobalWindow.h"
100179: 
116454: #include "mozilla/Preferences.h"
116454: 
104350: /* Using WebRTC backend on Desktops (Mac, Windows, Linux), otherwise default */
115703: #include "MediaEngineDefault.h"
104350: #if defined(MOZ_WEBRTC)
104350: #include "MediaEngineWebRTC.h"
104350: #endif
104350: 
100179: namespace mozilla {
100179: 
118976: #ifdef PR_LOGGING
120415: PRLogModuleInfo*
120415: GetMediaManagerLog()
120415: {
120415:   static PRLogModuleInfo *sLog;
120415:   if (!sLog)
120415:     sLog = PR_NewLogModule("MediaManager");
120415:   return sLog;
120415: }
120415: #define LOG(msg) PR_LOG(GetMediaManagerLog(), PR_LOG_DEBUG, msg)
118976: #else
118976: #define LOG(msg)
118976: #endif
116429: 
116429: 
100179: /**
100179:  * Send an error back to content. The error is the form a string.
114595:  * Do this only on the main thread. The success callback is also passed here
114595:  * so it can be released correctly.
100179:  */
100179: class ErrorCallbackRunnable : public nsRunnable
100179: {
100179: public:
114595:   ErrorCallbackRunnable(
114595:     already_AddRefed<nsIDOMGetUserMediaSuccessCallback> aSuccess,
114595:     already_AddRefed<nsIDOMGetUserMediaErrorCallback> aError,
108991:     const nsString& aErrorMsg, uint64_t aWindowID)
114595:     : mSuccess(aSuccess)
114595:     , mError(aError)
100179:     , mErrorMsg(aErrorMsg)
127037:     , mWindowID(aWindowID)
127037:     , mManager(MediaManager::GetInstance()) {}
100179: 
100179:   NS_IMETHOD
100179:   Run()
100179:   {
100179:     // Only run if the window is still active.
114595:     NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
114595: 
114595:     nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> success(mSuccess);
114595:     nsCOMPtr<nsIDOMGetUserMediaErrorCallback> error(mError);
114595: 
127037:     if (!(mManager->IsWindowStillActive(mWindowID))) {
120005:       return NS_OK;
120005:     }
120005:     // This is safe since we're on main-thread, and the windowlist can only
120005:     // be invalidated from the main-thread (see OnNavigation)
114595:     error->OnError(mErrorMsg);
100179:     return NS_OK;
100179:   }
100179: 
100179: private:
114595:   already_AddRefed<nsIDOMGetUserMediaSuccessCallback> mSuccess;
114595:   already_AddRefed<nsIDOMGetUserMediaErrorCallback> mError;
100179:   const nsString mErrorMsg;
108991:   uint64_t mWindowID;
127037:   nsRefPtr<MediaManager> mManager; // get ref to this when creating the runnable
100179: };
100179: 
100179: /**
100179:  * Invoke the "onSuccess" callback in content. The callback will take a
100179:  * DOMBlob in the case of {picture:true}, and a MediaStream in the case of
100179:  * {audio:true} or {video:true}. There is a constructor available for each
100179:  * form. Do this only on the main thread.
100179:  */
100179: class SuccessCallbackRunnable : public nsRunnable
100179: {
100179: public:
114595:   SuccessCallbackRunnable(
114595:     already_AddRefed<nsIDOMGetUserMediaSuccessCallback> aSuccess,
114595:     already_AddRefed<nsIDOMGetUserMediaErrorCallback> aError,
108991:     nsIDOMFile* aFile, uint64_t aWindowID)
100179:     : mSuccess(aSuccess)
114595:     , mError(aError)
100179:     , mFile(aFile)
127037:     , mWindowID(aWindowID)
127037:     , mManager(MediaManager::GetInstance()) {}
100179: 
100179:   NS_IMETHOD
100179:   Run()
100179:   {
100179:     // Only run if the window is still active.
114595:     NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
114595: 
114595:     nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> success(mSuccess);
114595:     nsCOMPtr<nsIDOMGetUserMediaErrorCallback> error(mError);
114595: 
127037:     if (!(mManager->IsWindowStillActive(mWindowID))) {
120005:       return NS_OK;
120005:     }
120005:     // This is safe since we're on main-thread, and the windowlist can only
120005:     // be invalidated from the main-thread (see OnNavigation)
114595:     success->OnSuccess(mFile);
100179:     return NS_OK;
100179:   }
100179: 
100179: private:
114595:   already_AddRefed<nsIDOMGetUserMediaSuccessCallback> mSuccess;
114595:   already_AddRefed<nsIDOMGetUserMediaErrorCallback> mError;
100179:   nsCOMPtr<nsIDOMFile> mFile;
108991:   uint64_t mWindowID;
127037:   nsRefPtr<MediaManager> mManager; // get ref to this when creating the runnable
100179: };
100179: 
100179: /**
114595:  * Invoke the GetUserMediaDevices success callback. Wrapped in a runnable
114595:  * so that it may be called on the main thread. The error callback is also
114595:  * passed so it can be released correctly.
114595:  */
114595: class DeviceSuccessCallbackRunnable: public nsRunnable
114595: {
114595: public:
114595:   DeviceSuccessCallbackRunnable(
114595:     already_AddRefed<nsIGetUserMediaDevicesSuccessCallback> aSuccess,
114595:     already_AddRefed<nsIDOMGetUserMediaErrorCallback> aError,
114595:     const nsTArray<nsCOMPtr<nsIMediaDevice> >& aDevices)
114595:     : mSuccess(aSuccess)
114595:     , mError(aError)
114595:     , mDevices(aDevices) {}
114595: 
114595:   NS_IMETHOD
114595:   Run()
114595:   {
114595:     NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
114595: 
114595:     nsCOMPtr<nsIGetUserMediaDevicesSuccessCallback> success(mSuccess);
114595:     nsCOMPtr<nsIDOMGetUserMediaErrorCallback> error(mError);
114595: 
114595:     nsCOMPtr<nsIWritableVariant> devices =
114595:       do_CreateInstance("@mozilla.org/variant;1");
114595: 
114595:     int32_t len = mDevices.Length();
114595:     if (len == 0) {
114595:       devices->SetAsEmptyArray();
114595:       success->OnSuccess(devices);
114595:       return NS_OK;
114595:     }
114595: 
114595:     nsTArray<nsIMediaDevice*> tmp(len);
114595:     for (int32_t i = 0; i < len; i++) {
114595:       tmp.AppendElement(mDevices.ElementAt(i));
114595:     }
114595: 
114595:     devices->SetAsArray(nsIDataType::VTYPE_INTERFACE,
114595:                         &NS_GET_IID(nsIMediaDevice),
114595:                         mDevices.Length(),
114595:                         const_cast<void*>(
114595:                           static_cast<const void*>(tmp.Elements())
114595:                         ));
114595: 
114595:     success->OnSuccess(devices);
114595:     return NS_OK;
114595:   }
114595: 
114595: private:
114595:   already_AddRefed<nsIGetUserMediaDevicesSuccessCallback> mSuccess;
114595:   already_AddRefed<nsIDOMGetUserMediaErrorCallback> mError;
114595:   nsTArray<nsCOMPtr<nsIMediaDevice> > mDevices;
114595: };
114595: 
114595: /**
114595:  * nsIMediaDevice implementation.
114595:  */
114595: NS_IMPL_THREADSAFE_ISUPPORTS1(MediaDevice, nsIMediaDevice)
114595: 
114595: NS_IMETHODIMP
114595: MediaDevice::GetName(nsAString& aName)
114595: {
114595:   aName.Assign(mName);
114595:   return NS_OK;
114595: }
114595: 
114595: NS_IMETHODIMP
114595: MediaDevice::GetType(nsAString& aType)
114595: {
114595:   aType.Assign(mType);
114595:   return NS_OK;
114595: }
114595: 
126252: NS_IMETHODIMP
126252: MediaDevice::GetId(nsAString& aID)
126252: {
126252:   aID.Assign(mID);
126252:   return NS_OK;
126252: }
126252: 
114595: MediaEngineSource*
114595: MediaDevice::GetSource()
114595: {
114595:   return mSource;
114595: }
114595: 
114595: /**
104350:  * Creates a MediaStream, attaches a listener and fires off a success callback
114595:  * to the DOM with the stream. We also pass in the error callback so it can
114595:  * be released correctly.
104350:  *
104350:  * All of this must be done on the main thread!
118976:  *
118976:  * Note that the various GetUserMedia Runnable classes currently allow for
118976:  * two streams.  If we ever need to support getting more than two streams
118976:  * at once, we could convert everything to nsTArray<nsRefPtr<blah> >'s,
118976:  * though that would complicate the constructors some.  Currently the
118976:  * GetUserMedia spec does not allow for more than 2 streams to be obtained in
118976:  * one call, to simplify handling of constraints.
100179:  */
104350: class GetUserMediaStreamRunnable : public nsRunnable
100179: {
100179: public:
114595:   GetUserMediaStreamRunnable(
114595:     already_AddRefed<nsIDOMGetUserMediaSuccessCallback> aSuccess,
114595:     already_AddRefed<nsIDOMGetUserMediaErrorCallback> aError,
118976:     uint64_t aWindowID,
118976:     MediaEngineSource* aAudioSource,
118976:     MediaEngineSource* aVideoSource)
104350:     : mSuccess(aSuccess)
114595:     , mError(aError)
118976:     , mAudioSource(aAudioSource)
118976:     , mVideoSource(aVideoSource)
127037:     , mWindowID(aWindowID)
127037:     , mManager(MediaManager::GetInstance()) {}
104350: 
104350:   ~GetUserMediaStreamRunnable() {}
100179: 
100179:   NS_IMETHOD
100179:   Run()
100179:   {
114595:     NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
114595: 
121787:     // We're on main-thread, and the windowlist can only
121787:     // be invalidated from the main-thread (see OnNavigation)
127037:     StreamListeners* listeners = mManager->GetWindowListeners(mWindowID);
121787:     if (!listeners) {
121787:       // This window is no longer live.
121787:       return NS_OK;
121787:     }
121787: 
104350:     // Create a media stream.
119960:     nsRefPtr<nsDOMLocalMediaStream> stream;
118976:     uint32_t hints = (mAudioSource ? nsDOMMediaStream::HINT_CONTENTS_AUDIO : 0);
118976:     hints |= (mVideoSource ? nsDOMMediaStream::HINT_CONTENTS_VIDEO : 0);
118976: 
120304:     stream = nsDOMLocalMediaStream::CreateSourceStream(hints);
126551:     if (!stream) {
118976:       nsCOMPtr<nsIDOMGetUserMediaErrorCallback> error(mError);
118976:       LOG(("Returning error for getUserMedia() - no stream"));
118976:       error->OnError(NS_LITERAL_STRING("NO_STREAM"));
118976:       return NS_OK;
118976:     }
120005: 
121787:     nsPIDOMWindow *window = static_cast<nsPIDOMWindow*>
121787:       (nsGlobalWindow::GetInnerWindowWithId(mWindowID));
104351:     if (window && window->GetExtantDoc()) {
104351:       stream->CombineWithPrincipal(window->GetExtantDoc()->NodePrincipal());
104351:     }
104351: 
119959:     // Ensure there's a thread for gum to proxy to off main thread
119959:     nsIThread *mediaThread = MediaManager::GetThread();
119959: 
100179:     // Add our listener. We'll call Start() on the source when get a callback
100179:     // that the MediaStream has started consuming. The listener is freed
100179:     // when the page is invalidated (on navigation or close).
100179:     GetUserMediaCallbackMediaStreamListener* listener =
119959:       new GetUserMediaCallbackMediaStreamListener(mediaThread, stream,
119959:                                                   mAudioSource,
118976:                                                   mVideoSource);
104350:     stream->GetStream()->AddListener(listener);
100179: 
104350:     // No need for locking because we always do this in the main thread.
121787:     listeners->AppendElement(listener);
104350: 
119959:     // Dispatch to the media thread to ask it to start the sources,
119959:     // because that can take a while
119959:     nsRefPtr<MediaOperationRunnable> runnable(
119959:       new MediaOperationRunnable(MEDIA_START, stream,
119959:                                  mAudioSource, mVideoSource));
119959:     mediaThread->Dispatch(runnable, NS_DISPATCH_NORMAL);
119959: 
104350:     // We're in the main thread, so no worries here either.
114595:     nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> success(mSuccess);
114595:     nsCOMPtr<nsIDOMGetUserMediaErrorCallback> error(mError);
114595: 
127037:     if (!(mManager->IsWindowStillActive(mWindowID))) {
120005:       return NS_OK;
120005:     }
120005:     // This is safe since we're on main-thread, and the windowlist can only
120005:     // be invalidated from the main-thread (see OnNavigation)
118976:     LOG(("Returning success for getUserMedia()"));
126551:     success->OnSuccess(static_cast<nsIDOMLocalMediaStream*>(stream));
100179: 
100179:     return NS_OK;
100179:   }
100179: 
100179: private:
114595:   already_AddRefed<nsIDOMGetUserMediaSuccessCallback> mSuccess;
114595:   already_AddRefed<nsIDOMGetUserMediaErrorCallback> mError;
118976:   nsRefPtr<MediaEngineSource> mAudioSource;
118976:   nsRefPtr<MediaEngineSource> mVideoSource;
108991:   uint64_t mWindowID;
127037:   nsRefPtr<MediaManager> mManager; // get ref to this when creating the runnable
100179: };
100179: 
100179: /**
100179:  * Runs on a seperate thread and is responsible for enumerating devices.
100179:  * Depending on whether a picture or stream was asked for, either
104350:  * ProcessGetUserMedia or ProcessGetUserMediaSnapshot is called, and the results
104350:  * are sent back to the DOM.
100179:  *
104350:  * Do not run this on the main thread. The success and error callbacks *MUST*
104350:  * be dispatched on the main thread!
100179:  */
100179: class GetUserMediaRunnable : public nsRunnable
100179: {
100179: public:
114595:   /**
114595:    * The caller can choose to provide a MediaDevice as the last argument,
114595:    * if one is not provided, a default device is automatically chosen.
114595:    */
100179:   GetUserMediaRunnable(bool aAudio, bool aVideo, bool aPicture,
114595:     already_AddRefed<nsIDOMGetUserMediaSuccessCallback> aSuccess,
114595:     already_AddRefed<nsIDOMGetUserMediaErrorCallback> aError,
121787:     uint64_t aWindowID, MediaDevice* aAudioDevice, MediaDevice* aVideoDevice)
114595:     : mAudio(aAudio)
114595:     , mVideo(aVideo)
114595:     , mPicture(aPicture)
114595:     , mSuccess(aSuccess)
114595:     , mError(aError)
114595:     , mWindowID(aWindowID)
115703:     , mDeviceChosen(true)
118976:     , mBackendChosen(false)
127037:     , mManager(MediaManager::GetInstance())
118976:     {
118976:       if (mAudio) {
118976:         mAudioDevice = aAudioDevice;
118976:       }
118976:       if (mVideo) {
118976:         mVideoDevice = aVideoDevice;
118976:       }
118976:     }
114595: 
114595:   GetUserMediaRunnable(bool aAudio, bool aVideo, bool aPicture,
114595:     already_AddRefed<nsIDOMGetUserMediaSuccessCallback> aSuccess,
114595:     already_AddRefed<nsIDOMGetUserMediaErrorCallback> aError,
121787:     uint64_t aWindowID)
100179:     : mAudio(aAudio)
100179:     , mVideo(aVideo)
100179:     , mPicture(aPicture)
100179:     , mSuccess(aSuccess)
100179:     , mError(aError)
114595:     , mWindowID(aWindowID)
115704:     , mDeviceChosen(false)
127037:     , mBackendChosen(false)
127037:     , mManager(MediaManager::GetInstance()) {}
100179: 
115703:   /**
115703:    * The caller can also choose to provide their own backend instead of
115703:    * using the one provided by MediaManager::GetBackend.
115703:    */
115703:   GetUserMediaRunnable(bool aAudio, bool aVideo,
115703:     already_AddRefed<nsIDOMGetUserMediaSuccessCallback> aSuccess,
115703:     already_AddRefed<nsIDOMGetUserMediaErrorCallback> aError,
121787:     uint64_t aWindowID, MediaEngine* aBackend)
115703:     : mAudio(aAudio)
115703:     , mVideo(aVideo)
115703:     , mPicture(false)
115703:     , mSuccess(aSuccess)
115703:     , mError(aError)
115703:     , mWindowID(aWindowID)
115703:     , mDeviceChosen(false)
115703:     , mBackendChosen(true)
127037:     , mBackend(aBackend)
127037:     , mManager(MediaManager::GetInstance()) {}
115703: 
115703:   ~GetUserMediaRunnable() {
115703:     if (mBackendChosen) {
115703:       delete mBackend;
115703:     }
115703:   }
100179: 
100179:   NS_IMETHOD
100179:   Run()
100179:   {
114595:     NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
114595: 
115703:     // Was a backend provided?
115703:     if (!mBackendChosen) {
115703:       mBackend = mManager->GetBackend();
115703:     }
115703: 
114595:     // Was a device provided?
115703:     if (!mDeviceChosen) {
114595:       nsresult rv = SelectDevice();
114595:       if (rv != NS_OK) {
114595:         return rv;
114595:       }
114595:     }
114595: 
108114:     // It is an error if audio or video are requested along with picture.
108006:     if (mPicture && (mAudio || mVideo)) {
108006:       NS_DispatchToMainThread(new ErrorCallbackRunnable(
114595:         mSuccess, mError, NS_LITERAL_STRING("NOT_SUPPORTED_ERR"), mWindowID
108006:       ));
108006:       return NS_OK;
108114:     }
108114: 
118976:     if (mPicture) {
118976:       ProcessGetUserMediaSnapshot(mVideoDevice->GetSource(), 0);
100179:       return NS_OK;
100179:     }
100179: 
122305:     // There's a bug in the permission code that can leave us with mAudio but no audio device
122305:     ProcessGetUserMedia((mAudio && mAudioDevice) ? mAudioDevice->GetSource() : nullptr,
122305:                         (mVideo && mVideoDevice) ? mVideoDevice->GetSource() : nullptr);
100179:     return NS_OK;
100179:   }
100179: 
114595:   nsresult
116351:   Denied()
116351:   {
116351:     if (NS_IsMainThread()) {
120005:       // This is safe since we're on main-thread, and the window can only
120005:       // be invalidated from the main-thread (see OnNavigation)
116351:       nsCOMPtr<nsIDOMGetUserMediaErrorCallback> error(mError);
116351:       error->OnError(NS_LITERAL_STRING("PERMISSION_DENIED"));
116351:     } else {
120005:       // This will re-check the window being alive on main-thread
116351:       NS_DispatchToMainThread(new ErrorCallbackRunnable(
116351:         mSuccess, mError, NS_LITERAL_STRING("PERMISSION_DENIED"), mWindowID
116351:       ));
116351:     }
116351: 
116351:     return NS_OK;
116351:   }
116351: 
116351:   nsresult
118976:   SetAudioDevice(MediaDevice* aAudioDevice)
116351:   {
118976:     mAudioDevice = aAudioDevice;
118976:     mDeviceChosen = true;
118976:     return NS_OK;
118976:   }
118976: 
118976:   nsresult
118976:   SetVideoDevice(MediaDevice* aVideoDevice)
118976:   {
118976:     mVideoDevice = aVideoDevice;
116351:     mDeviceChosen = true;
116351:     return NS_OK;
116351:   }
116351: 
116351:   nsresult
114595:   SelectDevice()
114595:   {
119135:     bool found = false;
114595:     uint32_t count;
114595:     if (mPicture || mVideo) {
114595:       nsTArray<nsRefPtr<MediaEngineVideoSource> > videoSources;
115703:       mBackend->EnumerateVideoDevices(&videoSources);
114595: 
114595:       count = videoSources.Length();
114595:       if (count <= 0) {
114595:         NS_DispatchToMainThread(new ErrorCallbackRunnable(
114595:           mSuccess, mError, NS_LITERAL_STRING("NO_DEVICES_FOUND"), mWindowID
114595:         ));
114595:         return NS_ERROR_FAILURE;
114595:       }
119135: 
119135:       // Pick the first available device.
119135:       for (uint32_t i = 0; i < count; i++) {
119135:         nsRefPtr<MediaEngineVideoSource> vSource = videoSources[i];
119135:         if (vSource->IsAvailable()) {
119135:           found = true;
119135:           mVideoDevice = new MediaDevice(videoSources[i]);
125410:           break;
119135:         }
119135:       }
119135: 
119135:       if (!found) {
119135:         NS_DispatchToMainThread(new ErrorCallbackRunnable(
119135:           mSuccess, mError, NS_LITERAL_STRING("HARDWARE_UNAVAILABLE"), mWindowID
119135:         ));
119135:         return NS_ERROR_FAILURE;
119135:       }
118976:       LOG(("Selected video device"));
118976:     }
121190: 
121190:     found = false;
118976:     if (mAudio) {
114595:       nsTArray<nsRefPtr<MediaEngineAudioSource> > audioSources;
115703:       mBackend->EnumerateAudioDevices(&audioSources);
114595: 
114595:       count = audioSources.Length();
114595:       if (count <= 0) {
114595:         NS_DispatchToMainThread(new ErrorCallbackRunnable(
114595:           mSuccess, mError, NS_LITERAL_STRING("NO_DEVICES_FOUND"), mWindowID
114595:         ));
114595:         return NS_ERROR_FAILURE;
114595:       }
119135: 
119135:       for (uint32_t i = 0; i < count; i++) {
119135:         nsRefPtr<MediaEngineAudioSource> aSource = audioSources[i];
119135:         if (aSource->IsAvailable()) {
119135:           found = true;
119135:           mAudioDevice = new MediaDevice(audioSources[i]);
125410:           break;
119135:         }
119135:       }
119135: 
119135:       if (!found) {
119135:         NS_DispatchToMainThread(new ErrorCallbackRunnable(
119135:           mSuccess, mError, NS_LITERAL_STRING("HARDWARE_UNAVAILABLE"), mWindowID
119135:         ));
119135:         return NS_ERROR_FAILURE;
119135:       }
118976:       LOG(("Selected audio device"));
114595:     }
114595: 
114595:     return NS_OK;
114595:   }
114595: 
104350:   /**
104350:    * Allocates a video or audio device and returns a MediaStream via
104350:    * a GetUserMediaStreamRunnable. Runs off the main thread.
104350:    */
104350:   void
118976:   ProcessGetUserMedia(MediaEngineSource* aAudioSource, MediaEngineSource* aVideoSource)
104350:   {
118976:     nsresult rv;
118976:     if (aAudioSource) {
118976:       rv = aAudioSource->Allocate();
104350:       if (NS_FAILED(rv)) {
118976:         LOG(("Failed to allocate audiosource %d",rv));
104350:         NS_DispatchToMainThread(new ErrorCallbackRunnable(
114595:                                   mSuccess, mError, NS_LITERAL_STRING("HARDWARE_UNAVAILABLE"), mWindowID
104350:                                                           ));
104350:         return;
104350:       }
118976:     }
118976:     if (aVideoSource) {
118976:       rv = aVideoSource->Allocate();
118976:       if (NS_FAILED(rv)) {
118976:         LOG(("Failed to allocate videosource %d\n",rv));
118976:         if (aAudioSource) {
118976:           aAudioSource->Deallocate();
118976:         }
118976:         NS_DispatchToMainThread(new ErrorCallbackRunnable(
118976:           mSuccess, mError, NS_LITERAL_STRING("HARDWARE_UNAVAILABLE"), mWindowID
118976:                                                           ));
118976:         return;
118976:       }
118976:     }
104350: 
104350:     NS_DispatchToMainThread(new GetUserMediaStreamRunnable(
121787:       mSuccess, mError, mWindowID, aAudioSource, aVideoSource
104350:     ));
104350:     return;
104350:   }
104350: 
104350:   /**
104350:    * Allocates a video device, takes a snapshot and returns a DOMFile via
104350:    * a SuccessRunnable or an error via the ErrorRunnable. Off the main thread.
104350:    */
104350:   void
104350:   ProcessGetUserMediaSnapshot(MediaEngineSource* aSource, int aDuration)
104350:   {
104350:     nsresult rv = aSource->Allocate();
104350:     if (NS_FAILED(rv)) {
104350:       NS_DispatchToMainThread(new ErrorCallbackRunnable(
114595:         mSuccess, mError, NS_LITERAL_STRING("HARDWARE_UNAVAILABLE"), mWindowID
104350:       ));
104350:       return;
104350:     }
104350: 
114595:     /**
114595:      * Display picture capture UI here before calling Snapshot() - Bug 748835.
114595:      */
104350:     nsCOMPtr<nsIDOMFile> file;
104350:     aSource->Snapshot(aDuration, getter_AddRefs(file));
104350:     aSource->Deallocate();
104350: 
104350:     NS_DispatchToMainThread(new SuccessCallbackRunnable(
114595:       mSuccess, mError, file, mWindowID
104350:     ));
104350:     return;
104350:   }
104350: 
100179: private:
100179:   bool mAudio;
100179:   bool mVideo;
100179:   bool mPicture;
100179: 
114595:   already_AddRefed<nsIDOMGetUserMediaSuccessCallback> mSuccess;
114595:   already_AddRefed<nsIDOMGetUserMediaErrorCallback> mError;
108991:   uint64_t mWindowID;
118976:   nsRefPtr<MediaDevice> mAudioDevice;
118976:   nsRefPtr<MediaDevice> mVideoDevice;
100179: 
115703:   bool mDeviceChosen;
115703:   bool mBackendChosen;
115703: 
115703:   MediaEngine* mBackend;
127037:   nsRefPtr<MediaManager> mManager; // get ref to this when creating the runnable
100179: };
100179: 
114595: /**
114595:  * Similar to GetUserMediaRunnable, but used for the chrome-only
114595:  * GetUserMediaDevices function. Enumerates a list of audio & video devices,
114595:  * wraps them up in nsIMediaDevice objects and returns it to the success
114595:  * callback.
114595:  */
114595: class GetUserMediaDevicesRunnable : public nsRunnable
114595: {
114595: public:
114595:   GetUserMediaDevicesRunnable(
114595:     already_AddRefed<nsIGetUserMediaDevicesSuccessCallback> aSuccess,
114595:     already_AddRefed<nsIDOMGetUserMediaErrorCallback> aError)
114595:     : mSuccess(aSuccess)
127037:     , mError(aError)
127037:     , mManager(MediaManager::GetInstance())
127037:     {}
114595:   ~GetUserMediaDevicesRunnable() {}
114595: 
114595:   NS_IMETHOD
114595:   Run()
114595:   {
114595:     NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
114595: 
115564:     uint32_t audioCount, videoCount, i;
114595: 
114595:     nsTArray<nsRefPtr<MediaEngineVideoSource> > videoSources;
127037:     mManager->GetBackend()->EnumerateVideoDevices(&videoSources);
114595:     videoCount = videoSources.Length();
114595: 
114595:     nsTArray<nsRefPtr<MediaEngineAudioSource> > audioSources;
127037:     mManager->GetBackend()->EnumerateAudioDevices(&audioSources);
118458:     audioCount = audioSources.Length();
114595: 
114595:     nsTArray<nsCOMPtr<nsIMediaDevice> > *devices =
114595:       new nsTArray<nsCOMPtr<nsIMediaDevice> >;
114595: 
119135:     /**
119135:      * We only display available devices in the UI for now. We can easily
119135:      * change this later, when we implement a more sophisticated UI that
119135:      * lets the user revoke a device currently held by another tab (or
119135:      * we decide to provide a stream from a device already allocated).
119135:      */
114595:     for (i = 0; i < videoCount; i++) {
127035:       MediaEngineVideoSource *vSource = videoSources[i];
119135:       if (vSource->IsAvailable()) {
119135:         devices->AppendElement(new MediaDevice(vSource));
119135:       }
114595:     }
114595:     for (i = 0; i < audioCount; i++) {
127035:       MediaEngineAudioSource *aSource = audioSources[i];
119135:       if (aSource->IsAvailable()) {
119135:         devices->AppendElement(new MediaDevice(aSource));
119135:       }
114595:     }
114595: 
114595:     NS_DispatchToMainThread(new DeviceSuccessCallbackRunnable(
114595:       mSuccess, mError, *devices
114595:     ));
114595:     return NS_OK;
114595:   }
114595: 
114595: private:
114595:   already_AddRefed<nsIGetUserMediaDevicesSuccessCallback> mSuccess;
114595:   already_AddRefed<nsIDOMGetUserMediaErrorCallback> mError;
127037:   nsRefPtr<MediaManager> mManager;
114595: };
100179: 
126735: NS_IMPL_THREADSAFE_ISUPPORTS2(MediaManager, nsIMediaManagerService, nsIObserver)
100179: 
126735: /* static */ StaticRefPtr<MediaManager> MediaManager::sSingleton;
126735: 
126735: /* static */ already_AddRefed<MediaManager>
126735: MediaManager::GetInstance()
126735: {
126735:   // so we can have non-refcounted getters
126735:   nsRefPtr<MediaManager> service = MediaManager::Get();
126735:   return service.forget();
126735: }
100179: 
100179: /**
100179:  * The entry point for this file. A call from Navigator::mozGetUserMedia
100179:  * will end up here. MediaManager is a singleton that is responsible
100179:  * for handling all incoming getUserMedia calls from every window.
100179:  */
100179: nsresult
114595: MediaManager::GetUserMedia(bool aPrivileged, nsPIDOMWindow* aWindow,
114595:   nsIMediaStreamOptions* aParams,
114595:   nsIDOMGetUserMediaSuccessCallback* aOnSuccess,
114595:   nsIDOMGetUserMediaErrorCallback* aOnError)
100179: {
114595:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
114595: 
100179:   NS_ENSURE_TRUE(aParams, NS_ERROR_NULL_POINTER);
104350:   NS_ENSURE_TRUE(aWindow, NS_ERROR_NULL_POINTER);
119454:   NS_ENSURE_TRUE(aOnError, NS_ERROR_NULL_POINTER);
119454:   NS_ENSURE_TRUE(aOnSuccess, NS_ERROR_NULL_POINTER);
100179: 
114595:   nsCOMPtr<nsIDOMGetUserMediaSuccessCallback> onSuccess(aOnSuccess);
114595:   nsCOMPtr<nsIDOMGetUserMediaErrorCallback> onError(aOnError);
114595: 
114595:   /* Get options */
114595:   nsresult rv;
115703:   bool fake, audio, video, picture;
115703: 
115703:   rv = aParams->GetFake(&fake);
115703:   NS_ENSURE_SUCCESS(rv, rv);
104350: 
114595:   rv = aParams->GetPicture(&picture);
114595:   NS_ENSURE_SUCCESS(rv, rv);
114595: 
114595:   rv = aParams->GetAudio(&audio);
114595:   NS_ENSURE_SUCCESS(rv, rv);
114595: 
114595:   rv = aParams->GetVideo(&video);
114595:   NS_ENSURE_SUCCESS(rv, rv);
114595: 
118976:   nsCOMPtr<nsIMediaDevice> audiodevice;
118976:   rv = aParams->GetAudioDevice(getter_AddRefs(audiodevice));
118976:   NS_ENSURE_SUCCESS(rv, rv);
118976: 
118976:   nsCOMPtr<nsIMediaDevice> videodevice;
118976:   rv = aParams->GetVideoDevice(getter_AddRefs(videodevice));
114595:   NS_ENSURE_SUCCESS(rv, rv);
114595: 
114595:   // If a device was provided, make sure it support the type of stream requested.
118976:   if (audiodevice) {
114595:     nsString type;
118976:     audiodevice->GetType(type);
118976:     if (audio && !type.EqualsLiteral("audio")) {
114595:       return NS_ERROR_FAILURE;
114595:     }
118976:   }
118976:   if (videodevice) {
118976:     nsString type;
118976:     videodevice->GetType(type);
118976:     if ((picture || video) && !type.EqualsLiteral("video")) {
114595:         return NS_ERROR_FAILURE;
114595:     }
114595:   }
114595: 
114595:   // We only support "front" or "back". TBD: Send to GetUserMediaRunnable.
114595:   nsString cameraType;
114595:   rv = aParams->GetCamera(cameraType);
100179:   NS_ENSURE_SUCCESS(rv, rv);
100179: 
104350:   /**
104350:    * If we were asked to get a picture, before getting a snapshot, we check if
104350:    * the calling page is allowed to open a popup. We do this because
104350:    * {picture:true} will open a new "window" to let the user preview or select
104350:    * an image, on Android. The desktop UI for {picture:true} is TBD, at which
104350:    * may point we can decide whether to extend this test there as well.
104350:    */
104350: #if !defined(MOZ_WEBRTC)
114595:   if (picture && !aPrivileged) {
109470:     if (aWindow->GetPopupControlState() > openControlled) {
104350:       nsCOMPtr<nsIPopupWindowManager> pm =
104350:         do_GetService(NS_POPUPWINDOWMANAGER_CONTRACTID);
114595:       if (!pm) {
109470:         return NS_OK;
114595:       }
108991:       uint32_t permission;
104350:       nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
104689:       pm->TestPermission(doc->NodePrincipal(), &permission);
109470:       if ((permission == nsIPopupWindowManager::DENY_POPUP)) {
104350:         nsCOMPtr<nsIDOMDocument> domDoc = aWindow->GetExtantDocument();
104350:         nsGlobalWindow::FirePopupBlockedEvent(
106838:           domDoc, aWindow, nullptr, EmptyString(), EmptyString()
104350:         );
109470:         return NS_OK;
109470:       }
104350:     }
104350:   }
104350: #endif
104350: 
119975:   static bool created = false;
119975:   if (!created) {
119975:     // Force MediaManager to startup before we try to access it from other threads
119975:     // Hack: should init singleton earlier unless it's expensive (mem or CPU)
119975:     (void) MediaManager::Get();
119975:   }
119975: 
100179:   // Store the WindowID in a hash table and mark as active. The entry is removed
100179:   // when this window is closed or navigated away from.
108991:   uint64_t windowID = aWindow->WindowID();
119959:   nsRefPtr<GetUserMediaRunnable> gUMRunnable;
120005:   // This is safe since we're on main-thread, and the windowlist can only
120005:   // be invalidated from the main-thread (see OnNavigation)
120005:   StreamListeners* listeners = GetActiveWindows()->Get(windowID);
100179:   if (!listeners) {
100179:     listeners = new StreamListeners;
120005:     GetActiveWindows()->Put(windowID, listeners);
100179:   }
100179: 
116454:   // Developer preference for turning off permission check.
116454:   if (Preferences::GetBool("media.navigator.permission.disabled", false)) {
116454:     aPrivileged = true;
116454:   }
116454: 
114595:   /**
114595:    * Pass runnables along to GetUserMediaRunnable so it can add the
114595:    * MediaStreamListener to the runnable list. The last argument can
114595:    * optionally be a MediaDevice object, which should provided if one was
114595:    * selected by the user via the UI, or was provided by privileged code
114595:    * via the device: attribute via nsIMediaStreamOptions.
115703:    *
115703:    * If a fake stream was requested, we force the use of the default backend.
114595:    */
115703:   if (fake) {
115703:     // Fake stream from default backend.
115703:     gUMRunnable = new GetUserMediaRunnable(
121787:       audio, video, onSuccess.forget(), onError.forget(), windowID,
121787:       new MediaEngineDefault()
115703:                                            );
118976:   } else if (audiodevice || videodevice) {
115703:     // Stream from provided device.
114595:     gUMRunnable = new GetUserMediaRunnable(
121787:       audio, video, picture, onSuccess.forget(), onError.forget(), windowID,
118976:       static_cast<MediaDevice*>(audiodevice.get()),
118976:       static_cast<MediaDevice*>(videodevice.get())
100179:                                            );
114595:   } else {
115703:     // Stream from default device from WebRTC backend.
114595:     gUMRunnable = new GetUserMediaRunnable(
121787:       audio, video, picture, onSuccess.forget(), onError.forget(), windowID
114595:                                            );
114595:   }
100179: 
118976: #ifdef ANDROID
109470:   if (picture) {
109470:     // ShowFilePickerForMimeType() must run on the Main Thread! (on Android)
109470:     NS_DispatchToMainThread(gUMRunnable);
118976:   }
118976:   // XXX No support for Audio or Video in Android yet
118976: #else
118976:   // XXX No full support for picture in Desktop yet (needs proper UI)
118976:   if (aPrivileged || fake) {
116351:     mMediaThread->Dispatch(gUMRunnable, NS_DISPATCH_NORMAL);
116351:   } else {
116351:     // Ask for user permission, and dispatch runnable (or not) when a response
116351:     // is received via an observer notification. Each call is paired with its
116351:     // runnable by a GUID.
116351:     nsresult rv;
116351:     nsCOMPtr<nsIUUIDGenerator> uuidgen =
116351:       do_GetService("@mozilla.org/uuid-generator;1", &rv);
116351:     NS_ENSURE_SUCCESS(rv, rv);
100179: 
116351:     // Generate a call ID.
116351:     nsID id;
116351:     rv = uuidgen->GenerateUUIDInPlace(&id);
116351:     NS_ENSURE_SUCCESS(rv, rv);
116351: 
116351:     char buffer[NSID_LENGTH];
116351:     id.ToProvidedString(buffer);
116351:     NS_ConvertUTF8toUTF16 callID(buffer);
116351: 
116351:     // Store the current callback.
116351:     mActiveCallbacks.Put(callID, gUMRunnable);
116351: 
116351:     // Construct JSON structure with both the windowID and the callID.
116351:     nsAutoString data;
116351:     data.Append(NS_LITERAL_STRING("{\"windowID\":"));
116351: 
116351:     // Convert window ID to string.
116351:     char windowBuffer[32];
116351:     PR_snprintf(windowBuffer, 32, "%llu", aWindow->GetOuterWindow()->WindowID());
116351:     data.Append(NS_ConvertUTF8toUTF16(windowBuffer));
116351: 
116351:     data.Append(NS_LITERAL_STRING(", \"callID\":\""));
116351:     data.Append(callID);
116351:     data.Append(NS_LITERAL_STRING("\"}"));
116351: 
116351:     nsCOMPtr<nsIObserverService> obs = services::GetObserverService();
116351:     obs->NotifyObservers(aParams, "getUserMedia:request", data.get());
109470:   }
118976: #endif
116351: 
100179:   return NS_OK;
100179: }
100179: 
114595: nsresult
114595: MediaManager::GetUserMediaDevices(nsPIDOMWindow* aWindow,
114595:   nsIGetUserMediaDevicesSuccessCallback* aOnSuccess,
114595:   nsIDOMGetUserMediaErrorCallback* aOnError)
114595: {
114595:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
114595: 
119454:   NS_ENSURE_TRUE(aOnError, NS_ERROR_NULL_POINTER);
119454:   NS_ENSURE_TRUE(aOnSuccess, NS_ERROR_NULL_POINTER);
119454: 
114595:   nsCOMPtr<nsIGetUserMediaDevicesSuccessCallback> onSuccess(aOnSuccess);
114595:   nsCOMPtr<nsIDOMGetUserMediaErrorCallback> onError(aOnError);
114595: 
114595:   nsCOMPtr<nsIRunnable> gUMDRunnable = new GetUserMediaDevicesRunnable(
114595:     onSuccess.forget(), onError.forget()
114595:   );
114595: 
114595:   nsCOMPtr<nsIThread> deviceThread;
114595:   nsresult rv = NS_NewThread(getter_AddRefs(deviceThread));
114595:   NS_ENSURE_SUCCESS(rv, rv);
114595: 
114595: 
114595:   deviceThread->Dispatch(gUMDRunnable, NS_DISPATCH_NORMAL);
114595:   return NS_OK;
114595: }
114595: 
100179: MediaEngine*
100179: MediaManager::GetBackend()
100179: {
104350:   // Plugin backends as appropriate. The default engine also currently
104350:   // includes picture support for Android.
120005:   // This IS called off main-thread.
120005:   MutexAutoLock lock(mMutex);
100179:   if (!mBackend) {
104350: #if defined(MOZ_WEBRTC)
104350:     mBackend = new MediaEngineWebRTC();
104350: #else
100179:     mBackend = new MediaEngineDefault();
104350: #endif
100179:   }
100179:   return mBackend;
100179: }
100179: 
100179: void
108991: MediaManager::OnNavigation(uint64_t aWindowID)
100179: {
120005:   NS_ASSERTION(NS_IsMainThread(), "OnNavigation called off main thread");
120005: 
100179:   // Invalidate this window. The runnables check this value before making
100179:   // a call to content.
120005: 
120005:   // This is safe since we're on main-thread, and the windowlist can only
120005:   // be added to from the main-thread (see OnNavigation)
121787:   StreamListeners* listeners = GetWindowListeners(aWindowID);
100179:   if (!listeners) {
100179:     return;
100179:   }
100179: 
108991:   uint32_t length = listeners->Length();
108991:   for (uint32_t i = 0; i < length; i++) {
100179:     nsRefPtr<GetUserMediaCallbackMediaStreamListener> listener =
100179:       listeners->ElementAt(i);
100179:     listener->Invalidate();
127035:     listener->Remove();
100179:   }
100179:   listeners->Clear();
100179: 
120005:   GetActiveWindows()->Remove(aWindowID);
119959: }
100179: 
100179: nsresult
100179: MediaManager::Observe(nsISupports* aSubject, const char* aTopic,
100179:   const PRUnichar* aData)
100179: {
116351:   NS_ASSERTION(NS_IsMainThread(), "Observer invoked off the main thread");
116351:   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
100179: 
116351:   if (!strcmp(aTopic, "xpcom-shutdown")) {
100179:     obs->RemoveObserver(this, "xpcom-shutdown");
116351:     obs->RemoveObserver(this, "getUserMedia:response:allow");
116351:     obs->RemoveObserver(this, "getUserMedia:response:deny");
100179: 
100179:     // Close off any remaining active windows.
119959:     {
119959:       MutexAutoLock lock(mMutex);
120005:       GetActiveWindows()->Clear();
116351:       mActiveCallbacks.Clear();
106838:       sSingleton = nullptr;
119959:     }
100179: 
100179:     return NS_OK;
100179:   }
100179: 
116351:   if (!strcmp(aTopic, "getUserMedia:response:allow")) {
116351:     nsString key(aData);
116351:     nsRefPtr<nsRunnable> runnable;
116351:     if (!mActiveCallbacks.Get(key, getter_AddRefs(runnable))) {
116351:       return NS_OK;
116351:     }
120005:     mActiveCallbacks.Remove(key);
116351: 
116351:     if (aSubject) {
126686:       // A particular device or devices were chosen by the user.
118976:       // NOTE: does not allow setting a device to null; assumes nullptr
116351:       GetUserMediaRunnable* gUMRunnable =
116351:         static_cast<GetUserMediaRunnable*>(runnable.get());
126686: 
126686:       nsCOMPtr<nsISupportsArray> array(do_QueryInterface(aSubject));
126686:       MOZ_ASSERT(array);
126686:       uint32_t len = 0;
126686:       array->Count(&len);
126686:       MOZ_ASSERT(len);
126686:       if (!len) {
126686:         gUMRunnable->Denied(); // neither audio nor video were selected
126686:         return NS_OK;
126686:       }
126686:       for (uint32_t i = 0; i < len; i++) {
126686:         nsCOMPtr<nsISupports> supports;
126686:         array->GetElementAt(i,getter_AddRefs(supports));
126686:         nsCOMPtr<nsIMediaDevice> device(do_QueryInterface(supports));
126686:         MOZ_ASSERT(device); // shouldn't be returning anything else...
126686:         if (device) {
118976:           nsString type;
118976:           device->GetType(type);
118976:           if (type.EqualsLiteral("video")) {
118976:             gUMRunnable->SetVideoDevice(static_cast<MediaDevice*>(device.get()));
118976:           } else if (type.EqualsLiteral("audio")) {
118976:             gUMRunnable->SetAudioDevice(static_cast<MediaDevice*>(device.get()));
118976:           } else {
118976:             NS_WARNING("Unknown device type in getUserMedia");
118976:           }
116351:         }
116351:       }
126686:     }
116351: 
120005:     // Reuse the same thread to save memory.
116351:     mMediaThread->Dispatch(runnable, NS_DISPATCH_NORMAL);
116351:     return NS_OK;
116351:   }
116351: 
116351:   if (!strcmp(aTopic, "getUserMedia:response:deny")) {
116351:     nsString key(aData);
116351:     nsRefPtr<nsRunnable> runnable;
120005:     if (!mActiveCallbacks.Get(key, getter_AddRefs(runnable))) {
120005:       return NS_OK;
120005:     }
120005:     mActiveCallbacks.Remove(key);
120005: 
116351:     GetUserMediaRunnable* gUMRunnable =
116351:       static_cast<GetUserMediaRunnable*>(runnable.get());
116351:     gUMRunnable->Denied();
116351:     return NS_OK;
116351:   }
116351: 
116351:   return NS_OK;
116351: }
116351: 
126735: static PLDHashOperator
126735: WindowsHashToArrayFunc (const uint64_t& aId,
126735:                         StreamListeners* aData,
126735:                         void *userArg)
126735: {
126735:     nsISupportsArray *array =
126735:         static_cast<nsISupportsArray *>(userArg);
126735:     nsPIDOMWindow *window = static_cast<nsPIDOMWindow*>
126735:       (nsGlobalWindow::GetInnerWindowWithId(aId));
126735:     (void) aData;
126735: 
126735:     MOZ_ASSERT(window);
126735:     if (window) {
126735:       array->AppendElement(window);
126735:     }
126735:     return PL_DHASH_NEXT;
126735: }
126735: 
126735: 
126735: nsresult
126735: MediaManager::GetActiveMediaCaptureWindows(nsISupportsArray **aArray)
126735: {
126735:   MOZ_ASSERT(aArray);
126735:   nsISupportsArray *array;
126735:   nsresult rv = NS_NewISupportsArray(&array); // AddRefs
126735:   if (NS_FAILED(rv))
126735:     return rv;
126735: 
126735:   mActiveWindows.EnumerateRead(WindowsHashToArrayFunc, array);
126735: 
126735:   *aArray = array;
126735:   return NS_OK;
126735: }
126735: 
100179: } // namespace mozilla
