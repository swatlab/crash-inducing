    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:ts=2:et:sw=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   L. David Baron <dbaron@dbaron.org>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* representation of one line within a block frame, a CSS line box */
    1: 
    1: #ifndef nsLineBox_h___
    1: #define nsLineBox_h___
    1: 
    1: #include "nsILineIterator.h"
32107: #include "nsIFrame.h"
    1: 
    1: class nsLineBox;
    1: class nsFloatCache;
    1: class nsFloatCacheList;
    1: class nsFloatCacheFreeList;
    1: 
    1: // State cached after reflowing a float. This state is used during
    1: // incremental reflow when we avoid reflowing a float.
    1: class nsFloatCache {
    1: public:
    1:   nsFloatCache();
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   ~nsFloatCache();
    1: #else
    1:   ~nsFloatCache() { }
    1: #endif
    1: 
    1:   nsFloatCache* Next() const { return mNext; }
    1: 
32107:   nsIFrame* mFloat;                     // floating frame
    1: 
    1: protected:
    1:   nsFloatCache* mNext;
    1: 
    1:   friend class nsFloatCacheList;
    1:   friend class nsFloatCacheFreeList;
    1: };
    1: 
    1: //----------------------------------------
    1: 
    1: class nsFloatCacheList {
    1: public:
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   nsFloatCacheList();
    1: #else
    1:   nsFloatCacheList() : mHead(nsnull) { }
    1: #endif
    1:   ~nsFloatCacheList();
    1: 
    1:   PRBool IsEmpty() const {
    1:     return nsnull == mHead;
    1:   }
    1: 
    1:   PRBool NotEmpty() const {
    1:     return nsnull != mHead;
    1:   }
    1: 
    1:   nsFloatCache* Head() const {
    1:     return mHead;
    1:   }
    1: 
    1:   nsFloatCache* Tail() const;
    1: 
    1:   void DeleteAll();
    1: 
    1:   nsFloatCache* Find(nsIFrame* aOutOfFlowFrame);
    1: 
    1:   // Remove a nsFloatCache from this list.  Deleting this nsFloatCache
    1:   // becomes the caller's responsibility.
    1:   void Remove(nsFloatCache* aElement) { RemoveAndReturnPrev(aElement); }
    1:   
    1:   // Steal away aList's nsFloatCache objects and put them in this
    1:   // list.  aList must not be empty.
    1:   void Append(nsFloatCacheFreeList& aList);
    1: 
    1: protected:
    1:   nsFloatCache* mHead;
    1: 
    1:   // Remove a nsFloatCache from this list.  Deleting this nsFloatCache
    1:   // becomes the caller's responsibility. Returns the nsFloatCache that was
    1:   // before aElement, or nsnull if aElement was the first.
    1:   nsFloatCache* RemoveAndReturnPrev(nsFloatCache* aElement);
    1:   
    1:   friend class nsFloatCacheFreeList;
    1: };
    1: 
    1: //---------------------------------------
    1: // Like nsFloatCacheList, but with fast access to the tail
    1: 
    1: class nsFloatCacheFreeList : private nsFloatCacheList {
    1: public:
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   nsFloatCacheFreeList();
    1:   ~nsFloatCacheFreeList();
    1: #else
    1:   nsFloatCacheFreeList() : mTail(nsnull) { }
    1:   ~nsFloatCacheFreeList() { }
    1: #endif
    1: 
    1:   // Reimplement trivial functions
    1:   PRBool IsEmpty() const {
    1:     return nsnull == mHead;
    1:   }
    1: 
    1:   nsFloatCache* Head() const {
    1:     return mHead;
    1:   }
    1: 
    1:   nsFloatCache* Tail() const {
    1:     return mTail;
    1:   }
    1:   
    1:   PRBool NotEmpty() const {
    1:     return nsnull != mHead;
    1:   }
    1: 
    1:   void DeleteAll();
    1: 
    1:   // Steal away aList's nsFloatCache objects and put them on this
    1:   // free-list.  aList must not be empty.
    1:   void Append(nsFloatCacheList& aList);
    1: 
    1:   void Append(nsFloatCache* aFloatCache);
    1: 
    1:   void Remove(nsFloatCache* aElement);
    1: 
    1:   // Remove an nsFloatCache object from this list and return it, or create
32108:   // a new one if this one is empty; Set its mFloat to aFloat.
32108:   nsFloatCache* Alloc(nsIFrame* aFloat);
    1:   
    1: protected:
    1:   nsFloatCache* mTail;
    1: 
    1:   friend class nsFloatCacheList;
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: #define LINE_MAX_BREAK_TYPE  ((1 << 4) - 1)
49001: #define LINE_MAX_CHILD_COUNT PR_INT32_MAX
    1: 
    1: #if NS_STYLE_CLEAR_LAST_VALUE > 15
    1: need to rearrange the mBits bitfield;
    1: #endif
    1: 
    1: // Funtion to create a line box
    1: nsLineBox* NS_NewLineBox(nsIPresShell* aPresShell, nsIFrame* aFrame,
    1:                          PRInt32 aCount, PRBool aIsBlock);
    1: 
    1: class nsLineList;
    1: 
    1: // don't use the following names outside of this file.  Instead, use
    1: // nsLineList::iterator, etc.  These are just here to allow them to
    1: // be specified as parameters to methods of nsLineBox.
    1: class nsLineList_iterator;
    1: class nsLineList_const_iterator;
    1: class nsLineList_reverse_iterator;
    1: class nsLineList_const_reverse_iterator;
    1: 
    1: /**
    1:  * Users must have the class that is to be part of the list inherit
    1:  * from nsLineLink.  If they want to be efficient, it should be the
    1:  * first base class.  (This was originally nsCLink in a templatized
    1:  * nsCList, but it's still useful separately.)
    1:  */
    1: 
    1: class nsLineLink {
    1: 
    1:   public:
    1:     friend class nsLineList;
    1:     friend class nsLineList_iterator;
    1:     friend class nsLineList_reverse_iterator;
    1:     friend class nsLineList_const_iterator;
    1:     friend class nsLineList_const_reverse_iterator;
    1: 
    1:   private:
    1:     nsLineLink *_mNext; // or head
    1:     nsLineLink *_mPrev; // or tail
    1: 
    1: };
    1: 
    1: 
    1: /**
    1:  * The nsLineBox class represents a horizontal line of frames. It contains
    1:  * enough state to support incremental reflow of the frames, event handling
    1:  * for the frames, and rendering of the frames.
    1:  */
    1: class nsLineBox : public nsLineLink {
    1: private:
    1:   nsLineBox(nsIFrame* aFrame, PRInt32 aCount, PRBool aIsBlock);
    1:   ~nsLineBox();
    1:   
    1:   // Overloaded new operator. Uses an arena (which comes from the presShell)
    1:   // to perform the allocation.
    1:   void* operator new(size_t sz, nsIPresShell* aPresShell) CPP_THROW_NEW;
    1:   void operator delete(void* aPtr, size_t sz);
    1: 
    1: public:
    1:   // Use these two functions to allocate and destroy line boxes
    1:   friend nsLineBox* NS_NewLineBox(nsIPresShell* aPresShell, nsIFrame* aFrame,
    1:                                   PRInt32 aCount, PRBool aIsBlock);
    1: 
    1:   void Destroy(nsIPresShell* aPresShell);
    1: 
    1:   // mBlock bit
    1:   PRBool IsBlock() const {
    1:     return mFlags.mBlock;
    1:   }
    1:   PRBool IsInline() const {
    1:     return 0 == mFlags.mBlock;
    1:   }
    1: 
    1:   // mDirty bit
    1:   void MarkDirty() {
    1:     mFlags.mDirty = 1;
    1:   }
    1:   void ClearDirty() {
    1:     mFlags.mDirty = 0;
    1:   }
    1:   PRBool IsDirty() const {
    1:     return mFlags.mDirty;
    1:   }
    1: 
    1:   // mPreviousMarginDirty bit
    1:   void MarkPreviousMarginDirty() {
    1:     mFlags.mPreviousMarginDirty = 1;
    1:   }
    1:   void ClearPreviousMarginDirty() {
    1:     mFlags.mPreviousMarginDirty = 0;
    1:   }
    1:   PRBool IsPreviousMarginDirty() const {
    1:     return mFlags.mPreviousMarginDirty;
    1:   }
    1: 
    1:   // mHasClearance bit
    1:   void SetHasClearance() {
    1:     mFlags.mHasClearance = 1;
    1:   }
    1:   void ClearHasClearance() {
    1:     mFlags.mHasClearance = 0;
    1:   }
    1:   PRBool HasClearance() const {
    1:     return mFlags.mHasClearance;
    1:   }
    1: 
    1:   // mImpactedByFloat bit
    1:   void SetLineIsImpactedByFloat(PRBool aValue) {
    1:     NS_ASSERTION((PR_FALSE==aValue || PR_TRUE==aValue), "somebody is playing fast and loose with bools and bits!");
    1:     mFlags.mImpactedByFloat = aValue;
    1:   }
    1:   PRBool IsImpactedByFloat() const {
    1:     return mFlags.mImpactedByFloat;
    1:   }
    1: 
    1:   // mLineWrapped bit
    1:   void SetLineWrapped(PRBool aOn) {
    1:     NS_ASSERTION((PR_FALSE==aOn || PR_TRUE==aOn), "somebody is playing fast and loose with bools and bits!");
    1:     mFlags.mLineWrapped = aOn;
    1:   }
    1:   PRBool IsLineWrapped() const {
    1:     return mFlags.mLineWrapped;
    1:   }
    1: 
 6029:   // mInvalidateTextRuns bit
 6029:   void SetInvalidateTextRuns(PRBool aOn) {
 6029:     NS_ASSERTION((PR_FALSE==aOn || PR_TRUE==aOn), "somebody is playing fast and loose with bools and bits!");
 6029:     mFlags.mInvalidateTextRuns = aOn;
 6029:   }
 6029:   PRBool GetInvalidateTextRuns() const {
 6029:     return mFlags.mInvalidateTextRuns;
 6029:   }
 6029: 
    1:   // mResizeReflowOptimizationDisabled bit
    1:   void DisableResizeReflowOptimization() {
    1:     mFlags.mResizeReflowOptimizationDisabled = PR_TRUE;
    1:   }
    1:   void EnableResizeReflowOptimization() {
    1:     mFlags.mResizeReflowOptimizationDisabled = PR_FALSE;
    1:   }
    1:   PRBool ResizeReflowOptimizationDisabled() const {
    1:     return mFlags.mResizeReflowOptimizationDisabled;
    1:   }
    1: 
31327:   // mHasBullet bit
31327:   void SetHasBullet() {
31327:     mFlags.mHasBullet = PR_TRUE;
31327:     InvalidateCachedIsEmpty();
31327:   }
31327:   void ClearHasBullet() {
31327:     mFlags.mHasBullet = PR_FALSE;
31327:     InvalidateCachedIsEmpty();
31327:   }
31327:   PRBool HasBullet() const {
31327:     return mFlags.mHasBullet;
31327:   }
31327: 
49001:   // mHadFloatPushed bit
49001:   void SetHadFloatPushed() {
49001:     mFlags.mHadFloatPushed = PR_TRUE;
49001:   }
49001:   void ClearHadFloatPushed() {
49001:     mFlags.mHadFloatPushed = PR_FALSE;
49001:   }
49001:   PRBool HadFloatPushed() const {
49001:     return mFlags.mHadFloatPushed;
49001:   }
49001: 
31327: 
    1:   // mChildCount value
    1:   PRInt32 GetChildCount() const {
    1:     return (PRInt32) mFlags.mChildCount;
    1:   }
    1:   void SetChildCount(PRInt32 aNewCount) {
    1:     if (aNewCount < 0) {
    1:       NS_WARNING("negative child count");
    1:       aNewCount = 0;
    1:     }
    1:     if (aNewCount > LINE_MAX_CHILD_COUNT) {
    1:       aNewCount = LINE_MAX_CHILD_COUNT;
    1:     }
    1:     mFlags.mChildCount = aNewCount;
    1:   }
    1: 
    1:   // mBreakType value
    1:   // Break information is applied *before* the line if the line is a block,
    1:   // or *after* the line if the line is an inline. Confusing, I know, but
    1:   // using different names should help.
    1:   PRBool HasBreakBefore() const {
    1:     return IsBlock() && NS_STYLE_CLEAR_NONE != mFlags.mBreakType;
    1:   }
    1:   void SetBreakTypeBefore(PRUint8 aBreakType) {
    1:     NS_ASSERTION(IsBlock(), "Only blocks have break-before");
    1:     NS_ASSERTION(aBreakType <= NS_STYLE_CLEAR_LEFT_AND_RIGHT,
    1:                  "Only float break types are allowed before a line");
    1:     mFlags.mBreakType = aBreakType;
    1:   }
    1:   PRUint8 GetBreakTypeBefore() const {
    1:     return IsBlock() ? mFlags.mBreakType : NS_STYLE_CLEAR_NONE;
    1:   }
    1: 
    1:   PRBool HasBreakAfter() const {
    1:     return !IsBlock() && NS_STYLE_CLEAR_NONE != mFlags.mBreakType;
    1:   }
    1:   void SetBreakTypeAfter(PRUint8 aBreakType) {
    1:     NS_ASSERTION(!IsBlock(), "Only inlines have break-after");
    1:     NS_ASSERTION(aBreakType <= LINE_MAX_BREAK_TYPE, "bad break type");
    1:     mFlags.mBreakType = aBreakType;
    1:   }
    1:   PRBool HasFloatBreakAfter() const {
    1:     return !IsBlock() && (NS_STYLE_CLEAR_LEFT == mFlags.mBreakType ||
    1:                           NS_STYLE_CLEAR_RIGHT == mFlags.mBreakType ||
    1:                           NS_STYLE_CLEAR_LEFT_AND_RIGHT == mFlags.mBreakType);
    1:   }
    1:   PRUint8 GetBreakTypeAfter() const {
    1:     return !IsBlock() ? mFlags.mBreakType : NS_STYLE_CLEAR_NONE;
    1:   }
    1: 
    1:   // mCarriedOutBottomMargin value
    1:   nsCollapsingMargin GetCarriedOutBottomMargin() const;
    1:   // Returns PR_TRUE if the margin changed
    1:   PRBool SetCarriedOutBottomMargin(nsCollapsingMargin aValue);
    1: 
    1:   // mFloats
    1:   PRBool HasFloats() const {
    1:     return (IsInline() && mInlineData) && mInlineData->mFloats.NotEmpty();
    1:   }
    1:   nsFloatCache* GetFirstFloat();
    1:   void FreeFloats(nsFloatCacheFreeList& aFreeList);
    1:   void AppendFloats(nsFloatCacheFreeList& aFreeList);
    1:   PRBool RemoveFloat(nsIFrame* aFrame);
    1: 
    1:   // Combined area is the area of the line that should influence the
    1:   // overflow area of its parent block.  The combined area should be
    1:   // used for painting-related things, but should never be used for
    1:   // layout (except for handling of 'overflow').
55026:   void SetOverflowAreas(const nsOverflowAreas& aOverflowAreas);
55026:   nsRect GetOverflowArea(nsOverflowType aType) {
55026:     return mData ? mData->mOverflowAreas.Overflow(aType) : mBounds;
    1:   }
55026:   nsOverflowAreas GetOverflowAreas() {
55026:     if (mData) {
55026:       return mData->mOverflowAreas;
55026:     }
55026:     return nsOverflowAreas(mBounds, mBounds);
55026:   }
55026:   nsRect GetVisualOverflowArea()
55026:     { return GetOverflowArea(eVisualOverflow); }
55026:   nsRect GetScrollableOverflowArea()
55026:     { return GetOverflowArea(eScrollableOverflow); }
    1: 
    1:   void SlideBy(nscoord aDY) {
    1:     mBounds.y += aDY;
    1:     if (mData) {
55026:       NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
55026:         mData->mOverflowAreas.Overflow(otype).y += aDY;
55026:       }
    1:     }
    1:   }
    1: 
    1:   /**
    1:    * The ascent (distance from top to baseline) of the linebox is the
    1:    * ascent of the anonymous inline box (for which we don't actually
    1:    * create a frame) that wraps all the consecutive inline children of a
    1:    * block.
    1:    *
    1:    * This is currently unused for block lines.
    1:    */
    1:   nscoord GetAscent() const { return mAscent; }
    1:   void SetAscent(nscoord aAscent) { mAscent = aAscent; }
    1: 
    1:   nscoord GetHeight() const {
    1:     return mBounds.height;
    1:   }
    1: 
36647:   static void DeleteLineList(nsPresContext* aPresContext, nsLineList& aLines,
36647:                              nsIFrame* aDestructRoot);
    1: 
    1:   // search from end to beginning of [aBegin, aEnd)
    1:   // Returns PR_TRUE if it found the line and PR_FALSE if not.
    1:   // Moves aEnd as it searches so that aEnd points to the resulting line.
33389:   // aLastFrameBeforeEnd is the last frame before aEnd (so if aEnd is
33389:   // the end of the line list, it's just the last frame in the frame
33389:   // list).
    1:   static PRBool RFindLineContaining(nsIFrame* aFrame,
    1:                                     const nsLineList_iterator& aBegin,
    1:                                     nsLineList_iterator& aEnd,
33389:                                     nsIFrame* aLastFrameBeforeEnd,
    1:                                     PRInt32* aFrameIndexInLine);
    1: 
    1: #ifdef DEBUG
    1:   char* StateToString(char* aBuf, PRInt32 aBufSize) const;
    1: 
    1:   void List(FILE* out, PRInt32 aIndent) const;
    1: #endif
    1: 
    1:   nsIFrame* LastChild() const;
    1: 
    1:   PRBool IsLastChild(nsIFrame* aFrame) const;
    1: 
    1:   PRInt32 IndexOf(nsIFrame* aFrame) const;
    1: 
    1:   PRBool Contains(nsIFrame* aFrame) const {
    1:     return IndexOf(aFrame) >= 0;
    1:   }
    1: 
    1:   // whether the line box is "logically" empty (just like nsIFrame::IsEmpty)
    1:   PRBool IsEmpty() const;
    1: 
    1:   // Call this only while in Reflow() for the block the line belongs
    1:   // to, only between reflowing the line (or sliding it, if we skip
    1:   // reflowing it) and the end of reflowing the block.
    1:   PRBool CachedIsEmpty();
    1: 
    1:   void InvalidateCachedIsEmpty() {
    1:     mFlags.mEmptyCacheValid = PR_FALSE;
    1:   }
    1: 
    1:   // For debugging purposes
    1:   PRBool IsValidCachedIsEmpty() {
    1:     return mFlags.mEmptyCacheValid;
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   static PRInt32 GetCtorCount();
    1: #endif
    1: 
    1:   nsIFrame* mFirstChild;
    1: 
    1:   nsRect mBounds;
    1: 
    1:   struct FlagBits {
    1:     PRUint32 mDirty : 1;
    1:     PRUint32 mPreviousMarginDirty : 1;
    1:     PRUint32 mHasClearance : 1;
    1:     PRUint32 mBlock : 1;
    1:     PRUint32 mImpactedByFloat : 1;
    1:     PRUint32 mLineWrapped: 1;
 6029:     PRUint32 mInvalidateTextRuns : 1;
    1:     PRUint32 mResizeReflowOptimizationDisabled: 1;  // default 0 = means that the opt potentially applies to this line. 1 = never skip reflowing this line for a resize reflow
    1:     PRUint32 mEmptyCacheValid: 1;
    1:     PRUint32 mEmptyCacheState: 1;
31327:     // mHasBullet indicates that this is an inline line whose block's
32392:     // bullet is adjacent to this line and non-empty.
31327:     PRUint32 mHasBullet : 1;
49001:     // Indicates that this line *may* have a placeholder for a float
49001:     // that was pushed to a later column or page.
49001:     PRUint32 mHadFloatPushed : 1;
    1:     PRUint32 mBreakType : 4;
    1: 
49001:     // FIXME: Move this out of FlagBits
49001:     PRUint32 mChildCount;
    1:   };
    1: 
    1:   struct ExtraData {
55026:     ExtraData(const nsRect& aBounds) : mOverflowAreas(aBounds, aBounds) {
    1:     }
55026:     nsOverflowAreas mOverflowAreas;
    1:   };
    1: 
    1:   struct ExtraBlockData : public ExtraData {
    1:     ExtraBlockData(const nsRect& aBounds)
    1:       : ExtraData(aBounds),
    1:         mCarriedOutBottomMargin()
    1:     {
    1:     }
    1:     nsCollapsingMargin mCarriedOutBottomMargin;
    1:   };
    1: 
    1:   struct ExtraInlineData : public ExtraData {
    1:     ExtraInlineData(const nsRect& aBounds) : ExtraData(aBounds) {
    1:     }
    1:     nsFloatCacheList mFloats;
    1:   };
    1: 
    1: protected:
    1:   nscoord mAscent;           // see |SetAscent| / |GetAscent|
    1:   union {
    1:     PRUint32 mAllFlags;
    1:     FlagBits mFlags;
    1:   };
    1: 
    1:   union {
    1:     ExtraData* mData;
    1:     ExtraBlockData* mBlockData;
    1:     ExtraInlineData* mInlineData;
    1:   };
    1: 
    1:   void Cleanup();
    1:   void MaybeFreeData();
    1: };
    1: 
    1: /**
    1:  * A linked list type where the items in the list must inherit from
    1:  * a link type to fuse allocations.
    1:  *
    1:  * API heavily based on the |list| class in the C++ standard.
    1:  */
    1:  
    1: class nsLineList_iterator {
    1:   public:
    1:     friend class nsLineList;
    1:     friend class nsLineList_reverse_iterator;
    1:     friend class nsLineList_const_iterator;
    1:     friend class nsLineList_const_reverse_iterator;
    1: 
    1:     typedef nsLineList_iterator         iterator_self_type;
    1:     typedef nsLineList_reverse_iterator iterator_reverse_type;
    1: 
    1:     typedef nsLineBox&                  reference;
    1:     typedef const nsLineBox&            const_reference;
    1: 
    1:     typedef nsLineBox*                  pointer;
    1:     typedef const nsLineBox*            const_pointer;
    1: 
    1:     typedef PRUint32                    size_type;
    1:     typedef PRInt32                     difference_type;
    1: 
    1:     typedef nsLineLink                  link_type;
    1: 
    1: #ifdef NS_DEBUG
    1:     nsLineList_iterator() { memset(&mCurrent, 0xcd, sizeof(mCurrent)); }
    1: #else
    1:     // Auto generated default constructor OK.
    1: #endif
    1:     // Auto generated copy-constructor OK.
    1: 
    1:     inline iterator_self_type&
    1:         operator=(const iterator_self_type& aOther);
    1:     inline iterator_self_type&
    1:         operator=(const iterator_reverse_type& aOther);
    1: 
    1:     iterator_self_type& operator++()
    1:     {
    1:       mCurrent = mCurrent->_mNext;
    1:       return *this;
    1:     }
    1: 
    1:     iterator_self_type operator++(int)
    1:     {
    1:       iterator_self_type rv(*this);
    1:       mCurrent = mCurrent->_mNext;
    1:       return rv;
    1:     }
    1: 
    1:     iterator_self_type& operator--()
    1:     {
    1:       mCurrent = mCurrent->_mPrev;
    1:       return *this;
    1:     }
    1: 
    1:     iterator_self_type operator--(int)
    1:     {
    1:       iterator_self_type rv(*this);
    1:       mCurrent = mCurrent->_mPrev;
    1:       return rv;
    1:     }
    1: 
    1:     reference operator*()
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return *static_cast<pointer>(mCurrent);
    1:     }
    1: 
    1:     pointer operator->()
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<pointer>(mCurrent);
    1:     }
    1: 
    1:     pointer get()
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<pointer>(mCurrent);
    1:     }
    1: 
    1:     operator pointer()
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<pointer>(mCurrent);
    1:     }
    1: 
    1:     const_reference operator*() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return *static_cast<const_pointer>(mCurrent);
    1:     }
    1: 
    1:     const_pointer operator->() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<const_pointer>(mCurrent);
    1:     }
    1: 
    1: #ifndef __MWERKS__
    1:     operator const_pointer() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<const_pointer>(mCurrent);
    1:     }
    1: #endif /* !__MWERKS__ */
    1: 
    1:     iterator_self_type next()
    1:     {
    1:       iterator_self_type copy(*this);
    1:       return ++copy;
    1:     }
    1: 
    1:     const iterator_self_type next() const
    1:     {
    1:       iterator_self_type copy(*this);
    1:       return ++copy;
    1:     }
    1: 
    1:     iterator_self_type prev()
    1:     {
    1:       iterator_self_type copy(*this);
    1:       return --copy;
    1:     }
    1: 
    1:     const iterator_self_type prev() const
    1:     {
    1:       iterator_self_type copy(*this);
    1:       return --copy;
    1:     }
    1: 
    1:     // Passing by value rather than by reference and reference to const
    1:     // to keep AIX happy.
    1:     PRBool operator==(const iterator_self_type aOther) const
 3309:     {
24819:       NS_ABORT_IF_FALSE(mListLink == aOther.mListLink, "comparing iterators over different lists");
 3309:       return mCurrent == aOther.mCurrent;
 3309:     }
    1:     PRBool operator!=(const iterator_self_type aOther) const
 3309:     {
24819:       NS_ABORT_IF_FALSE(mListLink == aOther.mListLink, "comparing iterators over different lists");
 3309:       return mCurrent != aOther.mCurrent;
 3309:     }
    1:     PRBool operator==(const iterator_self_type aOther)
 3309:     {
24819:       NS_ABORT_IF_FALSE(mListLink == aOther.mListLink, "comparing iterators over different lists");
 3309:       return mCurrent == aOther.mCurrent;
 3309:     }
    1:     PRBool operator!=(const iterator_self_type aOther)
 3309:     {
24819:       NS_ABORT_IF_FALSE(mListLink == aOther.mListLink, "comparing iterators over different lists");
 3309:       return mCurrent != aOther.mCurrent;
 3309:     }
    1: 
    1:   private:
    1:     link_type *mCurrent;
 4204: #ifdef DEBUG
    1:     link_type *mListLink; // the list's link, i.e., the end
    1: #endif
    1: };
    1: 
    1: class nsLineList_reverse_iterator {
    1: 
    1:   public:
    1: 
    1:     friend class nsLineList;
    1:     friend class nsLineList_iterator;
    1:     friend class nsLineList_const_iterator;
    1:     friend class nsLineList_const_reverse_iterator;
    1: 
    1:     typedef nsLineList_reverse_iterator iterator_self_type;
    1:     typedef nsLineList_iterator         iterator_reverse_type;
    1: 
    1:     typedef nsLineBox&                  reference;
    1:     typedef const nsLineBox&            const_reference;
    1: 
    1:     typedef nsLineBox*                  pointer;
    1:     typedef const nsLineBox*            const_pointer;
    1: 
    1:     typedef PRUint32                    size_type;
    1:     typedef PRInt32                     difference_type;
    1: 
    1:     typedef nsLineLink                  link_type;
    1: 
    1: #ifdef NS_DEBUG
    1:     nsLineList_reverse_iterator() { memset(&mCurrent, 0xcd, sizeof(mCurrent)); }
    1: #else
    1:     // Auto generated default constructor OK.
    1: #endif
    1:     // Auto generated copy-constructor OK.
    1: 
    1:     inline iterator_self_type&
    1:         operator=(const iterator_reverse_type& aOther);
    1:     inline iterator_self_type&
    1:         operator=(const iterator_self_type& aOther);
    1: 
    1:     iterator_self_type& operator++()
    1:     {
    1:       mCurrent = mCurrent->_mPrev;
    1:       return *this;
    1:     }
    1: 
    1:     iterator_self_type operator++(int)
    1:     {
    1:       iterator_self_type rv(*this);
    1:       mCurrent = mCurrent->_mPrev;
    1:       return rv;
    1:     }
    1: 
    1:     iterator_self_type& operator--()
    1:     {
    1:       mCurrent = mCurrent->_mNext;
    1:       return *this;
    1:     }
    1: 
    1:     iterator_self_type operator--(int)
    1:     {
    1:       iterator_self_type rv(*this);
    1:       mCurrent = mCurrent->_mNext;
    1:       return rv;
    1:     }
    1: 
    1:     reference operator*()
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return *static_cast<pointer>(mCurrent);
    1:     }
    1: 
    1:     pointer operator->()
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<pointer>(mCurrent);
    1:     }
    1: 
    1:     pointer get()
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<pointer>(mCurrent);
    1:     }
    1: 
    1:     operator pointer()
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<pointer>(mCurrent);
    1:     }
    1: 
    1:     const_reference operator*() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return *static_cast<const_pointer>(mCurrent);
    1:     }
    1: 
    1:     const_pointer operator->() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<const_pointer>(mCurrent);
    1:     }
    1: 
    1: #ifndef __MWERKS__
    1:     operator const_pointer() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<const_pointer>(mCurrent);
    1:     }
    1: #endif /* !__MWERKS__ */
    1: 
    1:     // Passing by value rather than by reference and reference to const
    1:     // to keep AIX happy.
    1:     PRBool operator==(const iterator_self_type aOther) const
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent == aOther.mCurrent;
 4204:     }
    1:     PRBool operator!=(const iterator_self_type aOther) const
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent != aOther.mCurrent;
 4204:     }
    1:     PRBool operator==(const iterator_self_type aOther)
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent == aOther.mCurrent;
 4204:     }
    1:     PRBool operator!=(const iterator_self_type aOther)
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent != aOther.mCurrent;
 4204:     }
    1: 
    1:   private:
    1:     link_type *mCurrent;
 4204: #ifdef DEBUG
    1:     link_type *mListLink; // the list's link, i.e., the end
    1: #endif
    1: };
    1: 
    1: class nsLineList_const_iterator {
    1:   public:
    1: 
    1:     friend class nsLineList;
    1:     friend class nsLineList_iterator;
    1:     friend class nsLineList_reverse_iterator;
    1:     friend class nsLineList_const_reverse_iterator;
    1: 
    1:     typedef nsLineList_const_iterator           iterator_self_type;
    1:     typedef nsLineList_const_reverse_iterator   iterator_reverse_type;
    1:     typedef nsLineList_iterator                 iterator_nonconst_type;
    1:     typedef nsLineList_reverse_iterator         iterator_nonconst_reverse_type;
    1: 
    1:     typedef nsLineBox&                  reference;
    1:     typedef const nsLineBox&            const_reference;
    1: 
    1:     typedef nsLineBox*                  pointer;
    1:     typedef const nsLineBox*            const_pointer;
    1: 
    1:     typedef PRUint32                    size_type;
    1:     typedef PRInt32                     difference_type;
    1: 
    1:     typedef nsLineLink                  link_type;
    1: 
 4204: #ifdef DEBUG
    1:     nsLineList_const_iterator() { memset(&mCurrent, 0xcd, sizeof(mCurrent)); }
    1: #else
    1:     // Auto generated default constructor OK.
    1: #endif
    1:     // Auto generated copy-constructor OK.
    1: 
    1:     inline iterator_self_type&
    1:         operator=(const iterator_nonconst_type& aOther);
    1:     inline iterator_self_type&
    1:         operator=(const iterator_nonconst_reverse_type& aOther);
    1:     inline iterator_self_type&
    1:         operator=(const iterator_self_type& aOther);
    1:     inline iterator_self_type&
    1:         operator=(const iterator_reverse_type& aOther);
    1: 
    1:     iterator_self_type& operator++()
    1:     {
    1:       mCurrent = mCurrent->_mNext;
    1:       return *this;
    1:     }
    1: 
    1:     iterator_self_type operator++(int)
    1:     {
    1:       iterator_self_type rv(*this);
    1:       mCurrent = mCurrent->_mNext;
    1:       return rv;
    1:     }
    1: 
    1:     iterator_self_type& operator--()
    1:     {
    1:       mCurrent = mCurrent->_mPrev;
    1:       return *this;
    1:     }
    1: 
    1:     iterator_self_type operator--(int)
    1:     {
    1:       iterator_self_type rv(*this);
    1:       mCurrent = mCurrent->_mPrev;
    1:       return rv;
    1:     }
    1: 
    1:     const_reference operator*() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return *static_cast<const_pointer>(mCurrent);
    1:     }
    1: 
    1:     const_pointer operator->() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<const_pointer>(mCurrent);
    1:     }
    1: 
    1:     const_pointer get() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<const_pointer>(mCurrent);
    1:     }
    1: 
    1: #ifndef __MWERKS__
    1:     operator const_pointer() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<const_pointer>(mCurrent);
    1:     }
    1: #endif /* !__MWERKS__ */
    1: 
    1:     const iterator_self_type next() const
    1:     {
    1:       iterator_self_type copy(*this);
    1:       return ++copy;
    1:     }
    1: 
    1:     const iterator_self_type prev() const
    1:     {
    1:       iterator_self_type copy(*this);
    1:       return --copy;
    1:     }
    1: 
    1:     // Passing by value rather than by reference and reference to const
    1:     // to keep AIX happy.
    1:     PRBool operator==(const iterator_self_type aOther) const
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent == aOther.mCurrent;
 4204:     }
    1:     PRBool operator!=(const iterator_self_type aOther) const
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent != aOther.mCurrent;
 4204:     }
    1:     PRBool operator==(const iterator_self_type aOther)
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent == aOther.mCurrent;
 4204:     }
    1:     PRBool operator!=(const iterator_self_type aOther)
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent != aOther.mCurrent;
 4204:     }
    1: 
    1:   private:
    1:     const link_type *mCurrent;
 4204: #ifdef DEBUG
    1:     const link_type *mListLink; // the list's link, i.e., the end
    1: #endif
    1: };
    1: 
    1: class nsLineList_const_reverse_iterator {
    1:   public:
    1: 
    1:     friend class nsLineList;
    1:     friend class nsLineList_iterator;
    1:     friend class nsLineList_reverse_iterator;
    1:     friend class nsLineList_const_iterator;
    1: 
    1:     typedef nsLineList_const_reverse_iterator   iterator_self_type;
    1:     typedef nsLineList_const_iterator           iterator_reverse_type;
    1:     typedef nsLineList_iterator                 iterator_nonconst_reverse_type;
    1:     typedef nsLineList_reverse_iterator         iterator_nonconst_type;
    1: 
    1:     typedef nsLineBox&                  reference;
    1:     typedef const nsLineBox&            const_reference;
    1: 
    1:     typedef nsLineBox*                  pointer;
    1:     typedef const nsLineBox*            const_pointer;
    1: 
    1:     typedef PRUint32                    size_type;
    1:     typedef PRInt32                     difference_type;
    1: 
    1:     typedef nsLineLink                  link_type;
    1: 
 4204: #ifdef DEBUG
    1:     nsLineList_const_reverse_iterator() { memset(&mCurrent, 0xcd, sizeof(mCurrent)); }
    1: #else
    1:     // Auto generated default constructor OK.
    1: #endif
    1:     // Auto generated copy-constructor OK.
    1: 
    1:     inline iterator_self_type&
    1:         operator=(const iterator_nonconst_type& aOther);
    1:     inline iterator_self_type&
    1:         operator=(const iterator_nonconst_reverse_type& aOther);
    1:     inline iterator_self_type&
    1:         operator=(const iterator_self_type& aOther);
    1:     inline iterator_self_type&
    1:         operator=(const iterator_reverse_type& aOther);
    1: 
    1:     iterator_self_type& operator++()
    1:     {
    1:       mCurrent = mCurrent->_mPrev;
    1:       return *this;
    1:     }
    1: 
    1:     iterator_self_type operator++(int)
    1:     {
    1:       iterator_self_type rv(*this);
    1:       mCurrent = mCurrent->_mPrev;
    1:       return rv;
    1:     }
    1: 
    1:     iterator_self_type& operator--()
    1:     {
    1:       mCurrent = mCurrent->_mNext;
    1:       return *this;
    1:     }
    1: 
    1:     iterator_self_type operator--(int)
    1:     {
    1:       iterator_self_type rv(*this);
    1:       mCurrent = mCurrent->_mNext;
    1:       return rv;
    1:     }
    1: 
    1:     const_reference operator*() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return *static_cast<const_pointer>(mCurrent);
    1:     }
    1: 
    1:     const_pointer operator->() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<const_pointer>(mCurrent);
    1:     }
    1: 
    1:     const_pointer get() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<const_pointer>(mCurrent);
    1:     }
    1: 
    1: #ifndef __MWERKS__
    1:     operator const_pointer() const
    1:     {
15676:       NS_ABORT_IF_FALSE(mCurrent != mListLink, "running past end");
 3233:       return static_cast<const_pointer>(mCurrent);
    1:     }
    1: #endif /* !__MWERKS__ */
    1: 
    1:     // Passing by value rather than by reference and reference to const
    1:     // to keep AIX happy.
    1:     PRBool operator==(const iterator_self_type aOther) const
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent == aOther.mCurrent;
 4204:     }
    1:     PRBool operator!=(const iterator_self_type aOther) const
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent != aOther.mCurrent;
 4204:     }
    1:     PRBool operator==(const iterator_self_type aOther)
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent == aOther.mCurrent;
 4204:     }
    1:     PRBool operator!=(const iterator_self_type aOther)
 4204:     {
 4204:       NS_ASSERTION(mListLink == aOther.mListLink, "comparing iterators over different lists");
 4204:       return mCurrent != aOther.mCurrent;
 4204:     }
    1: 
    1: //private:
    1:     const link_type *mCurrent;
 4204: #ifdef DEBUG
    1:     const link_type *mListLink; // the list's link, i.e., the end
    1: #endif
    1: };
    1: 
    1: class nsLineList {
    1: 
    1:   public:
    1: 
    1:   friend class nsLineList_iterator;
    1:   friend class nsLineList_reverse_iterator;
    1:   friend class nsLineList_const_iterator;
    1:   friend class nsLineList_const_reverse_iterator;
    1: 
    1:   typedef PRUint32                    size_type;
    1:   typedef PRInt32                     difference_type;
    1: 
    1:   typedef nsLineLink                  link_type;
    1: 
    1:   private:
    1:     link_type mLink;
    1: 
    1:   public:
    1:     typedef nsLineList                  self_type;
    1: 
    1:     typedef nsLineBox&                  reference;
    1:     typedef const nsLineBox&            const_reference;
    1: 
    1:     typedef nsLineBox*                  pointer;
    1:     typedef const nsLineBox*            const_pointer;
    1: 
    1:     typedef nsLineList_iterator         iterator;
    1:     typedef nsLineList_reverse_iterator reverse_iterator;
    1:     typedef nsLineList_const_iterator   const_iterator;
    1:     typedef nsLineList_const_reverse_iterator const_reverse_iterator;
    1: 
    1:     nsLineList()
    1:     {
33284:       MOZ_COUNT_CTOR(nsLineList);
    1:       clear();
    1:     }
    1: 
33284:     ~nsLineList()
33284:     {
33284:       MOZ_COUNT_DTOR(nsLineList);
33284:     }
33284: 
    1:     const_iterator begin() const
    1:     {
    1:       const_iterator rv;
    1:       rv.mCurrent = mLink._mNext;
 4204: #ifdef DEBUG
    1:       rv.mListLink = &mLink;
    1: #endif
    1:       return rv;
    1:     }
    1: 
    1:     iterator begin()
    1:     {
    1:       iterator rv;
    1:       rv.mCurrent = mLink._mNext;
 4204: #ifdef DEBUG
    1:       rv.mListLink = &mLink;
    1: #endif
    1:       return rv;
    1:     }
    1: 
    1:     iterator begin(nsLineBox* aLine)
    1:     {
    1:       iterator rv;
    1:       rv.mCurrent = aLine;
 4204: #ifdef DEBUG
    1:       rv.mListLink = &mLink;
    1: #endif
    1:       return rv;
    1:     }
    1: 
    1:     const_iterator end() const
    1:     {
    1:       const_iterator rv;
    1:       rv.mCurrent = &mLink;
 4204: #ifdef DEBUG
    1:       rv.mListLink = &mLink;
    1: #endif
    1:       return rv;
    1:     }
    1: 
    1:     iterator end()
    1:     {
    1:       iterator rv;
    1:       rv.mCurrent = &mLink;
 4204: #ifdef DEBUG
    1:       rv.mListLink = &mLink;
    1: #endif
    1:       return rv;
    1:     }
    1: 
    1:     const_reverse_iterator rbegin() const
    1:     {
    1:       const_reverse_iterator rv;
    1:       rv.mCurrent = mLink._mPrev;
 4204: #ifdef DEBUG
    1:       rv.mListLink = &mLink;
    1: #endif
    1:       return rv;
    1:     }
    1: 
    1:     reverse_iterator rbegin()
    1:     {
    1:       reverse_iterator rv;
    1:       rv.mCurrent = mLink._mPrev;
 4204: #ifdef DEBUG
    1:       rv.mListLink = &mLink;
    1: #endif
    1:       return rv;
    1:     }
    1: 
53721:     reverse_iterator rbegin(nsLineBox* aLine)
53721:     {
53721:       reverse_iterator rv;
53721:       rv.mCurrent = aLine;
53721: #ifdef DEBUG
53721:       rv.mListLink = &mLink;
53721: #endif
53721:       return rv;
53721:     }
53721: 
    1:     const_reverse_iterator rend() const
    1:     {
    1:       const_reverse_iterator rv;
    1:       rv.mCurrent = &mLink;
 4204: #ifdef DEBUG
    1:       rv.mListLink = &mLink;
    1: #endif
    1:       return rv;
    1:     }
    1: 
    1:     reverse_iterator rend()
    1:     {
    1:       reverse_iterator rv;
    1:       rv.mCurrent = &mLink;
 4204: #ifdef DEBUG
    1:       rv.mListLink = &mLink;
    1: #endif
    1:       return rv;
    1:     }
    1: 
    1:     PRBool empty() const
    1:     {
    1:       return mLink._mNext == &mLink;
    1:     }
    1: 
    1:     // NOTE: O(N).
    1:     size_type size() const
    1:     {
    1:       size_type count = 0;
    1:       for (const link_type *cur = mLink._mNext;
    1:            cur != &mLink;
    1:            cur = cur->_mNext)
    1:       {
    1:         ++count;
    1:       }
    1:       return count;
    1:     }
    1: 
    1:     pointer front()
    1:     {
    1:       NS_ASSERTION(!empty(), "no element to return");
 3233:       return static_cast<pointer>(mLink._mNext);
    1:     }
    1: 
    1:     const_pointer front() const
    1:     {
    1:       NS_ASSERTION(!empty(), "no element to return");
 3233:       return static_cast<const_pointer>(mLink._mNext);
    1:     }
    1: 
    1:     pointer back()
    1:     {
    1:       NS_ASSERTION(!empty(), "no element to return");
 3233:       return static_cast<pointer>(mLink._mPrev);
    1:     }
    1: 
    1:     const_pointer back() const
    1:     {
    1:       NS_ASSERTION(!empty(), "no element to return");
 3233:       return static_cast<const_pointer>(mLink._mPrev);
    1:     }
    1: 
    1:     void push_front(pointer aNew)
    1:     {
    1:       aNew->_mNext = mLink._mNext;
    1:       mLink._mNext->_mPrev = aNew;
    1:       aNew->_mPrev = &mLink;
    1:       mLink._mNext = aNew;
    1:     }
    1: 
    1:     void pop_front()
    1:         // NOTE: leaves dangling next/prev pointers
    1:     {
    1:       NS_ASSERTION(!empty(), "no element to pop");
    1:       link_type *newFirst = mLink._mNext->_mNext;
    1:       newFirst->_mPrev = &mLink;
    1:       // mLink._mNext->_mNext = nsnull;
    1:       // mLink._mNext->_mPrev = nsnull;
    1:       mLink._mNext = newFirst;
    1:     }
    1: 
    1:     void push_back(pointer aNew)
    1:     {
    1:       aNew->_mPrev = mLink._mPrev;
    1:       mLink._mPrev->_mNext = aNew;
    1:       aNew->_mNext = &mLink;
    1:       mLink._mPrev = aNew;
    1:     }
    1: 
    1:     void pop_back()
    1:         // NOTE: leaves dangling next/prev pointers
    1:     {
    1:       NS_ASSERTION(!empty(), "no element to pop");
    1:       link_type *newLast = mLink._mPrev->_mPrev;
    1:       newLast->_mNext = &mLink;
    1:       // mLink._mPrev->_mPrev = nsnull;
    1:       // mLink._mPrev->_mNext = nsnull;
    1:       mLink._mPrev = newLast;
    1:     }
    1: 
    1:     // inserts x before position
    1:     iterator before_insert(iterator position, pointer x)
    1:     {
    1:       // use |mCurrent| to prevent DEBUG_PASS_END assertions
    1:       x->_mPrev = position.mCurrent->_mPrev;
    1:       x->_mNext = position.mCurrent;
    1:       position.mCurrent->_mPrev->_mNext = x;
    1:       position.mCurrent->_mPrev = x;
    1:       return --position;
    1:     }
    1: 
    1:     // inserts x after position
    1:     iterator after_insert(iterator position, pointer x)
    1:     {
    1:       // use |mCurrent| to prevent DEBUG_PASS_END assertions
    1:       x->_mNext = position.mCurrent->_mNext;
    1:       x->_mPrev = position.mCurrent;
    1:       position.mCurrent->_mNext->_mPrev = x;
    1:       position.mCurrent->_mNext = x;
    1:       return ++position;
    1:     }
    1: 
    1:     // returns iterator pointing to after the element
    1:     iterator erase(iterator position)
    1:         // NOTE: leaves dangling next/prev pointers
    1:     {
    1:       position->_mPrev->_mNext = position->_mNext;
    1:       position->_mNext->_mPrev = position->_mPrev;
    1:       return ++position;
    1:     }
    1: 
    1:     void swap(self_type& y)
    1:     {
    1:       link_type tmp(y.mLink);
    1:       y.mLink = mLink;
    1:       mLink = tmp;
68810: 
68810:       if (!empty()) {
68810:         mLink._mNext->_mPrev = &mLink;
68810:         mLink._mPrev->_mNext = &mLink;
68810:       }
68810: 
68810:       if (!y.empty()) {
68810:         y.mLink._mNext->_mPrev = &y.mLink;
68810:         y.mLink._mPrev->_mNext = &y.mLink;
68810:       }
    1:     }
    1: 
    1:     void clear()
    1:         // NOTE:  leaves dangling next/prev pointers
    1:     {
    1:       mLink._mNext = &mLink;
    1:       mLink._mPrev = &mLink;
    1:     }
    1: 
    1:     // inserts the conts of x before position and makes x empty
    1:     void splice(iterator position, self_type& x)
    1:     {
    1:       // use |mCurrent| to prevent DEBUG_PASS_END assertions
    1:       position.mCurrent->_mPrev->_mNext = x.mLink._mNext;
    1:       x.mLink._mNext->_mPrev = position.mCurrent->_mPrev;
    1:       x.mLink._mPrev->_mNext = position.mCurrent;
    1:       position.mCurrent->_mPrev = x.mLink._mPrev;
    1:       x.clear();
    1:     }
    1: 
    1:     // Inserts element *i from list x before position and removes
    1:     // it from x.
    1:     void splice(iterator position, self_type& x, iterator i)
    1:     {
    1:       NS_ASSERTION(!x.empty(), "Can't insert from empty list.");
    1:       NS_ASSERTION(position != i && position.mCurrent != i->_mNext,
    1:                    "We don't check for this case.");
    1: 
    1:       // remove from |x|
    1:       i->_mPrev->_mNext = i->_mNext;
    1:       i->_mNext->_mPrev = i->_mPrev;
    1: 
    1:       // use |mCurrent| to prevent DEBUG_PASS_END assertions
    1:       // link into |this|, before-side
    1:       i->_mPrev = position.mCurrent->_mPrev;
    1:       position.mCurrent->_mPrev->_mNext = i.get();
    1: 
    1:       // link into |this|, after-side
    1:       i->_mNext = position.mCurrent;
    1:       position.mCurrent->_mPrev = i.get();
    1:     }
    1: 
    1:     // Inserts elements in [|first|, |last|), which are in |x|,
    1:     // into |this| before |position| and removes them from |x|.
    1:     void splice(iterator position, self_type& x, iterator first,
    1:                 iterator last)
    1:     {
    1:       NS_ASSERTION(!x.empty(), "Can't insert from empty list.");
    1: 
    1:       if (first == last)
    1:         return;
    1: 
    1:       --last; // so we now want to move [first, last]
    1:       // remove from |x|
    1:       first->_mPrev->_mNext = last->_mNext;
    1:       last->_mNext->_mPrev = first->_mPrev;
    1: 
    1:       // use |mCurrent| to prevent DEBUG_PASS_END assertions
    1:       // link into |this|, before-side
    1:       first->_mPrev = position.mCurrent->_mPrev;
    1:       position.mCurrent->_mPrev->_mNext = first.get();
    1: 
    1:       // link into |this|, after-side
    1:       last->_mNext = position.mCurrent;
    1:       position.mCurrent->_mPrev = last.get();
    1:     }
    1: 
    1: };
    1: 
    1: 
    1: // Many of these implementations of operator= don't work yet.  I don't
    1: // know why.
    1: 
 4204: #ifdef DEBUG
    1: 
    1:   // NOTE: ASSIGN_FROM is meant to be used *only* as the entire body
    1:   // of a function and therefore lacks PR_{BEGIN,END}_MACRO
    1: #define ASSIGN_FROM(other_)          \
    1:   mCurrent = other_.mCurrent;        \
    1:   mListLink = other_.mListLink;      \
    1:   return *this;
    1: 
    1: #else /* !NS_LINELIST_DEBUG_PASS_END */
    1: 
    1: #define ASSIGN_FROM(other_)          \
    1:   mCurrent = other_.mCurrent;        \
    1:   return *this;
    1: 
    1: #endif /* !NS_LINELIST_DEBUG_PASS_END */
    1: 
    1: inline
    1: nsLineList_iterator&
    1: nsLineList_iterator::operator=(const nsLineList_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: inline
    1: nsLineList_iterator&
    1: nsLineList_iterator::operator=(const nsLineList_reverse_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: inline
    1: nsLineList_reverse_iterator&
    1: nsLineList_reverse_iterator::operator=(const nsLineList_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: inline
    1: nsLineList_reverse_iterator&
    1: nsLineList_reverse_iterator::operator=(const nsLineList_reverse_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: inline
    1: nsLineList_const_iterator&
    1: nsLineList_const_iterator::operator=(const nsLineList_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: inline
    1: nsLineList_const_iterator&
    1: nsLineList_const_iterator::operator=(const nsLineList_reverse_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: inline
    1: nsLineList_const_iterator&
    1: nsLineList_const_iterator::operator=(const nsLineList_const_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: inline
    1: nsLineList_const_iterator&
    1: nsLineList_const_iterator::operator=(const nsLineList_const_reverse_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: inline
    1: nsLineList_const_reverse_iterator&
    1: nsLineList_const_reverse_iterator::operator=(const nsLineList_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: inline
    1: nsLineList_const_reverse_iterator&
    1: nsLineList_const_reverse_iterator::operator=(const nsLineList_reverse_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: inline
    1: nsLineList_const_reverse_iterator&
    1: nsLineList_const_reverse_iterator::operator=(const nsLineList_const_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: inline
    1: nsLineList_const_reverse_iterator&
    1: nsLineList_const_reverse_iterator::operator=(const nsLineList_const_reverse_iterator& aOther)
    1: {
    1:   ASSIGN_FROM(aOther)
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: 
21112: class NS_FINAL_CLASS nsLineIterator : public nsILineIterator
21112: {
    1: public:
    1:   nsLineIterator();
21112:   ~nsLineIterator();
    1: 
21112:   virtual void DisposeLineIterator();
    1: 
21112:   virtual PRInt32 GetNumLines();
21112:   virtual PRBool GetDirection();
    1:   NS_IMETHOD GetLine(PRInt32 aLineNumber,
    1:                      nsIFrame** aFirstFrameOnLine,
    1:                      PRInt32* aNumFramesOnLine,
    1:                      nsRect& aLineBounds,
    1:                      PRUint32* aLineFlags);
77946:   virtual PRInt32 FindLineContaining(nsIFrame* aFrame);
    1:   NS_IMETHOD FindFrameAt(PRInt32 aLineNumber,
    1:                          nscoord aX,
    1:                          nsIFrame** aFrameFound,
    1:                          PRBool* aXIsBeforeFirstFrame,
    1:                          PRBool* aXIsAfterLastFrame);
    1: 
    1:   NS_IMETHOD GetNextSiblingOnLine(nsIFrame*& aFrame, PRInt32 aLineNumber);
    1: #ifdef IBMBIDI
    1:   NS_IMETHOD CheckLineOrder(PRInt32                  aLine,
    1:                             PRBool                   *aIsReordered,
    1:                             nsIFrame                 **aFirstVisual,
    1:                             nsIFrame                 **aLastVisual);
    1: #endif
    1:   nsresult Init(nsLineList& aLines, PRBool aRightToLeft);
    1: 
21112: private:
    1:   nsLineBox* PrevLine() {
    1:     if (0 == mIndex) {
    1:       return nsnull;
    1:     }
    1:     return mLines[--mIndex];
    1:   }
    1: 
    1:   nsLineBox* NextLine() {
    1:     if (mIndex >= mNumLines - 1) {
    1:       return nsnull;
    1:     }
    1:     return mLines[++mIndex];
    1:   }
    1: 
    1:   nsLineBox* LineAt(PRInt32 aIndex) {
    1:     if ((aIndex < 0) || (aIndex >= mNumLines)) {
    1:       return nsnull;
    1:     }
    1:     return mLines[aIndex];
    1:   }
    1: 
    1:   nsLineBox** mLines;
    1:   PRInt32 mIndex;
    1:   PRInt32 mNumLines;
    1:   PRPackedBool mRightToLeft;
    1: };
    1: 
    1: #endif /* nsLineBox_h___ */
