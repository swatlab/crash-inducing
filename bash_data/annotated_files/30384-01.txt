    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Mike Shaver <shaver@mozilla.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* Data conversion between native and JavaScript types. */
    1: 
    1: #include "xpcprivate.h"
    1: #include "nsString.h"
    1: #include "XPCNativeWrapper.h"
    1: #include "nsIAtom.h"
 4042: #include "XPCWrapper.h"
20762: #include "nsJSPrincipals.h"
21618: #include "nsWrapperCache.h"
    1: 
    1: //#define STRICT_CHECK_OF_UNICODE
    1: #ifdef STRICT_CHECK_OF_UNICODE
    1: #define ILLEGAL_RANGE(c) (0!=((c) & 0xFF80))
    1: #else // STRICT_CHECK_OF_UNICODE
    1: #define ILLEGAL_RANGE(c) (0!=((c) & 0xFF00))
    1: #endif // STRICT_CHECK_OF_UNICODE
    1: 
    1: #define ILLEGAL_CHAR_RANGE(c) (0!=((c) & 0x80))
    1: /*
    1: * This is a table driven scheme to determine if the types of the params of the
    1: * given method exclude that method from being reflected via XPConnect.
    1: *
    1: * The table can be appended and modified as requirements change. However...
    1: *
    1: * The table ASSUMES that all the type idenetifiers are contiguous starting
    1: * at ZERO. And, it also ASSUMES that the additional criteria of whether or
    1: * not a give type is reflectable are its use as a pointer and/or 'out' type.
    1: *
    1: * The table has a row for each type and columns for the combinations of
    1: * that type being used as a pointer type and/or as an 'out' param.
    1: */
    1: 
    1: #define XPC_MK_BIT(p,o) (1 << (((p)?1:0)+((o)?2:0)))
    1: #define XPC_IS_REFLECTABLE(f, p, o) ((f) & XPC_MK_BIT((p),(o)))
    1: #define XPC_MK_FLAG(np_no,p_no,np_o,p_o) \
    1:         ((uint8)((np_no) | ((p_no) << 1) | ((np_o) << 2) | ((p_o) << 3)))
    1: 
    1: /***********************************************************/
    1: // xpt uses 5 bits for this info. We deal with the possibility that
    1: // some new types might exist that we don't know about.
    1: 
    1: #define XPC_FLAG_COUNT (1 << 5)
    1: 
    1: /* '1' means 'reflectable'. '0' means 'not reflectable'.        */
    1: static uint8 xpc_reflectable_flags[XPC_FLAG_COUNT] = {
    1:     /* 'p' stands for 'pointer' and 'o' stands for 'out'        */
    1:     /*          !p&!o, p&!o, !p&o, p&o                          */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_I8                */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_I16               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_I32               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_I64               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_U8                */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_U16               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_U32               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_U64               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_FLOAT             */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_DOUBLE            */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_BOOL              */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_CHAR              */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_WCHAR             */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 ), /* T_VOID              */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_IID               */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  0 ), /* T_DOMSTRING         */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_CHAR_STR          */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_WCHAR_STR         */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_INTERFACE         */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_INTERFACE_IS      */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_ARRAY             */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_PSTRING_SIZE_IS   */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_PWSTRING_SIZE_IS  */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  0 ), /* T_UTF8STRING        */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  0 ), /* T_CSTRING           */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  0 ), /* T_ASTRING           */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 ), /* 26 - reserved       */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 ), /* 27 - reserved       */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 ), /* 28 - reserved       */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 ), /* 29 - reserved       */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 ), /* 30 - reserved       */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 )  /* 31 - reserved       */
    1:     };
    1: 
    1: static intN sXPCOMUCStringFinalizerIndex = -1;
    1: 
    1: /***********************************************************/
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::IsMethodReflectable(const XPTMethodDescriptor& info)
    1: {
    1:     if(XPT_MD_IS_NOTXPCOM(info.flags) || XPT_MD_IS_HIDDEN(info.flags))
    1:         return JS_FALSE;
    1: 
    1:     for(int i = info.num_args-1; i >= 0; i--)
    1:     {
    1:         const nsXPTParamInfo& param = info.params[i];
    1:         const nsXPTType& type = param.GetType();
    1: 
    1:         uint8 base_type = type.TagPart();
    1:         NS_ASSERTION(base_type < XPC_FLAG_COUNT, "BAD TYPE");
    1: 
    1:         if(!XPC_IS_REFLECTABLE(xpc_reflectable_flags[base_type],
    1:                                type.IsPointer(), param.IsOut()))
    1:             return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
18543: // static
18543: JSBool
18543: XPCConvert::GetISupportsFromJSObject(JSObject* obj, nsISupports** iface)
    1: {
10858:     JSClass* jsclass = STOBJ_GET_CLASS(obj);
    1:     NS_ASSERTION(jsclass, "obj has no class");
    1:     if(jsclass &&
    1:        (jsclass->flags & JSCLASS_HAS_PRIVATE) &&
    1:        (jsclass->flags & JSCLASS_PRIVATE_IS_NSISUPPORTS))
    1:     {
10858:         *iface = (nsISupports*) xpc_GetJSPrivate(obj);
    1:         return JS_TRUE;
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
18907: static void
    1: FinalizeXPCOMUCString(JSContext *cx, JSString *str)
    1: {
    1:     NS_ASSERTION(sXPCOMUCStringFinalizerIndex != -1,
    1:                  "XPCConvert: XPCOM Unicode string finalizer called uninitialized!");
    1: 
    1:     jschar* buffer = JS_GetStringChars(str);
    1:     nsMemory::Free(buffer);
    1: }
    1: 
    1: 
    1: static JSBool
    1: AddXPCOMUCStringFinalizer()
    1: {
    1: 
    1:     sXPCOMUCStringFinalizerIndex =
    1:         JS_AddExternalStringFinalizer(FinalizeXPCOMUCString);
    1: 
    1:     if(sXPCOMUCStringFinalizerIndex == -1)
    1:     {        
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: //static
    1: void
    1: XPCConvert::RemoveXPCOMUCStringFinalizer()
    1: {
    1:     JS_RemoveExternalStringFinalizer(FinalizeXPCOMUCString);
    1:     sXPCOMUCStringFinalizerIndex = -1;
    1: }
    1: 
18752: 
18752: #define FIT_32(cx,i,d)      (INT_FITS_IN_JSVAL(i) \
18752:                              ? *d = INT_TO_JSVAL(i), JS_TRUE    \
18752:                              : JS_NewDoubleValue(cx, i, d))
18752: 
18752: #define FIT_U32(cx,i,d)     ((i) <= JSVAL_INT_MAX \
18752:                              ? *d = INT_TO_JSVAL(i), JS_TRUE    \
18752:                              : JS_NewDoubleValue(cx, i, d))
18752: 
18752: /*
18752:  * Support for 64 bit conversions where 'long long' not supported.
18752:  * (from John Fairhurst <mjf35@cam.ac.uk>)
18752:  */
18752: 
18752: #ifdef HAVE_LONG_LONG
18752: 
18752: #define INT64_TO_DOUBLE(i)      ((jsdouble) (i))
18752: // Win32 can't handle uint64 to double conversion
18752: #define UINT64_TO_DOUBLE(u)     ((jsdouble) (int64) (u))
18752: 
18752: #else
18752: 
18752: inline jsdouble
18752: INT64_TO_DOUBLE(const int64 &v)
18752: {
18752:     jsdouble d;
18752:     LL_L2D(d, v);
18752:     return d;
18752: }
18752: 
18752: // if !HAVE_LONG_LONG, then uint64 is a typedef of int64
18752: #define UINT64_TO_DOUBLE INT64_TO_DOUBLE
18752: 
18752: #endif
18752: 
    1: // static
    1: JSBool
    1: XPCConvert::NativeData2JS(XPCCallContext& ccx, jsval* d, const void* s,
    1:                           const nsXPTType& type, const nsID* iid,
    1:                           JSObject* scope, nsresult* pErr)
    1: {
    1:     NS_PRECONDITION(s, "bad param");
    1:     NS_PRECONDITION(d, "bad param");
    1: 
    1:     JSContext* cx = ccx.GetJSContext();
    1: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_NATIVE;
    1: 
    1:     switch(type.TagPart())
    1:     {
    1:     case nsXPTType::T_I8    : *d = INT_TO_JSVAL((int32)*((int8*)s));     break;
    1:     case nsXPTType::T_I16   : *d = INT_TO_JSVAL((int32)*((int16*)s));    break;
18752:     case nsXPTType::T_I32   : return FIT_32(cx,*((int32*)s),d);
18752:     case nsXPTType::T_I64   :
18752:         return JS_NewNumberValue(cx, INT64_TO_DOUBLE(*((int64*)s)), d);
    1:     case nsXPTType::T_U8    : *d = INT_TO_JSVAL((int32)*((uint8*)s));    break;
    1:     case nsXPTType::T_U16   : *d = INT_TO_JSVAL((int32)*((uint16*)s));   break;
18752:     case nsXPTType::T_U32   : return FIT_U32(cx,*((uint32*)s),d);
18752:     case nsXPTType::T_U64   :
18752:         return JS_NewNumberValue(cx, UINT64_TO_DOUBLE(*((uint64*)s)), d);
18752:     case nsXPTType::T_FLOAT : return JS_NewNumberValue(cx, *((float*)s), d);
18752:     case nsXPTType::T_DOUBLE: return JS_NewNumberValue(cx, *((double*)s), d);
    1:     case nsXPTType::T_BOOL  : *d = *((PRBool*)s)?JSVAL_TRUE:JSVAL_FALSE; break;
    1:     case nsXPTType::T_CHAR  :
    1:         {
    1:             char* p = (char*)s;
    1:             if(!p)
    1:                 return JS_FALSE;
    1: 
    1: #ifdef STRICT_CHECK_OF_UNICODE
    1:             NS_ASSERTION(! ILLEGAL_CHAR_RANGE(p) , "passing non ASCII data");
    1: #endif // STRICT_CHECK_OF_UNICODE
    1: 
    1:             JSString* str;
    1:             if(!(str = JS_NewStringCopyN(cx, p, 1)))
    1:                 return JS_FALSE;
    1:             *d = STRING_TO_JSVAL(str);
    1:             break;
    1:         }
    1:     case nsXPTType::T_WCHAR :
    1:         {
    1:             jschar* p = (jschar*)s;
    1:             if(!p)
    1:                 return JS_FALSE;
    1:             JSString* str;
    1:             if(!(str = JS_NewUCStringCopyN(cx, p, 1)))
    1:                 return JS_FALSE;
    1:             *d = STRING_TO_JSVAL(str);
    1:             break;
    1:         }
    1:     default:
    1:         if(!type.IsPointer())
    1:         {
    1:             XPC_LOG_ERROR(("XPCConvert::NativeData2JS : unsupported type"));
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         // set the default result
    1:         *d = JSVAL_NULL;
    1: 
    1:         switch(type.TagPart())
    1:         {
    1:         case nsXPTType::T_VOID:
    1:             XPC_LOG_ERROR(("XPCConvert::NativeData2JS : void* params not supported"));
    1:             return JS_FALSE;
    1: 
    1:         case nsXPTType::T_IID:
    1:             {
    1:                 nsID* iid2 = *((nsID**)s);
    1:                 if(!iid2)
    1:                     break;
    1:                 JSObject* obj;
    1:                 if(!(obj = xpc_NewIDObject(cx, scope, *iid2)))
    1:                     return JS_FALSE;
    1:                 *d = OBJECT_TO_JSVAL(obj);
    1:                 break;
    1:             }
    1: 
    1:         case nsXPTType::T_ASTRING:
    1:             // Fall through to T_DOMSTRING case
    1: 
    1:         case nsXPTType::T_DOMSTRING:
    1:             {
    1:                 const nsAString* p = *((const nsAString**)s);
    1:                 if(!p)
    1:                     break;
    1: 
    1:                 if(!p->IsVoid()) {
30306:                     jsval str = XPCStringConvert::ReadableToJSVal(cx, *p);
    1:                     if(!str)
    1:                         return JS_FALSE;
    1: 
30306:                     *d = str;
    1:                 }
    1: 
    1:                 // *d is defaulted to JSVAL_NULL so no need to set it
    1:                 // again if p is a "void" string
    1: 
    1:                 break;
    1:             }
    1: 
    1:         case nsXPTType::T_CHAR_STR:
    1:             {
    1:                 char* p = *((char**)s);
    1:                 if(!p)
    1:                     break;
    1: 
    1: #ifdef STRICT_CHECK_OF_UNICODE
    1:                 PRBool isAscii = PR_TRUE;
    1:                 char* t;
    1:                 for(t=p; *t && isAscii ; t++) {
    1:                   if(ILLEGAL_CHAR_RANGE(*t))
    1:                       isAscii = PR_FALSE;
    1:                 }
    1:                 NS_ASSERTION(isAscii, "passing non ASCII data");
    1: #endif // STRICT_CHECK_OF_UNICODE
    1:                 JSString* str;
    1:                 if(!(str = JS_NewStringCopyZ(cx, p)))
    1:                     return JS_FALSE;
    1:                 *d = STRING_TO_JSVAL(str);
    1:                 break;
    1:             }
    1: 
    1:         case nsXPTType::T_WCHAR_STR:
    1:             {
    1:                 jschar* p = *((jschar**)s);
    1:                 if(!p)
    1:                     break;
    1:                 JSString* str;
    1:                 if(!(str = JS_NewUCStringCopyZ(cx, p)))
    1:                     return JS_FALSE;
    1:                 *d = STRING_TO_JSVAL(str);
    1:                 break;
    1:             }
    1:         case nsXPTType::T_UTF8STRING:
    1:             {                          
    1:                 const nsACString* cString = *((const nsACString**)s);
    1: 
    1:                 if(!cString)
    1:                     break;
    1:                 
    1:                 if(!cString->IsVoid()) 
    1:                 {
    1:                     PRUint32 len;
    1:                     jschar *p = (jschar *)UTF8ToNewUnicode(*cString, &len);
    1: 
    1:                     if(!p)
    1:                         return JS_FALSE;
    1: 
    1:                     if(sXPCOMUCStringFinalizerIndex == -1 && 
    1:                        !AddXPCOMUCStringFinalizer())
    1:                         return JS_FALSE;
    1: 
    1:                     JSString* jsString =
    1:                         JS_NewExternalString(cx, p, len,
    1:                                              sXPCOMUCStringFinalizerIndex);
    1: 
    1:                     if(!jsString) {
    1:                         nsMemory::Free(p); 
    1:                         return JS_FALSE; 
    1:                     }
    1: 
    1:                     *d = STRING_TO_JSVAL(jsString);
    1:                 }
    1: 
    1:                 break;
    1: 
    1:             }
    1:         case nsXPTType::T_CSTRING:
    1:             {                          
    1:                 const nsACString* cString = *((const nsACString**)s);
    1: 
    1:                 if(!cString)
    1:                     break;
    1:                 
    1:                 if(!cString->IsVoid()) 
    1:                 {
    1:                     PRUnichar* unicodeString = ToNewUnicode(*cString);
    1:                     if(!unicodeString)
    1:                         return JS_FALSE;
    1: 
    1:                     if(sXPCOMUCStringFinalizerIndex == -1 && 
    1:                        !AddXPCOMUCStringFinalizer())
    1:                         return JS_FALSE;
    1: 
    1:                     JSString* jsString = JS_NewExternalString(cx,
    1:                                              (jschar*)unicodeString,
    1:                                              cString->Length(),
    1:                                              sXPCOMUCStringFinalizerIndex);
    1: 
    1:                     if(!jsString)
    1:                     {
    1:                         nsMemory::Free(unicodeString);
    1:                         return JS_FALSE;
    1:                     }
    1: 
    1:                     *d = STRING_TO_JSVAL(jsString);
    1:                 }
    1: 
    1:                 break;
    1:             }
    1: 
    1:         case nsXPTType::T_INTERFACE:
    1:         case nsXPTType::T_INTERFACE_IS:
    1:             {
    1:                 nsISupports* iface = *((nsISupports**)s);
    1:                 if(iface)
    1:                 {
    1:                     if(iid->Equals(NS_GET_IID(nsIVariant)))
    1:                     {
    1:                         nsCOMPtr<nsIVariant> variant = do_QueryInterface(iface);
    1:                         if(!variant)
    1:                             return JS_FALSE;
    1: 
    1:                         return XPCVariant::VariantDataToJS(ccx, variant, 
    1:                                                            scope, pErr, d);
    1:                     }
    1:                     // else...
    1:                     
    1:                     // XXX The OBJ_IS_NOT_GLOBAL here is not really right. In
    1:                     // fact, this code is depending on the fact that the
    1:                     // global object will not have been collected, and
    1:                     // therefore this NativeInterface2JSObject will not end up
    1:                     // creating a new XPCNativeScriptableShared.
22841:                     if(!NativeInterface2JSObject(ccx, d, nsnull, iface, iid,
23258:                                                  nsnull, nsnull, scope, PR_TRUE,
22115:                                                  OBJ_IS_NOT_GLOBAL, pErr))
    1:                         return JS_FALSE;
    1: 
22363: #ifdef DEBUG
22841:                     JSObject* jsobj = JSVAL_TO_OBJECT(*d);
22841:                     if(jsobj && !STOBJ_GET_PARENT(jsobj))
10858:                         NS_ASSERTION(STOBJ_GET_CLASS(jsobj)->flags & JSCLASS_IS_GLOBAL,
    1:                                      "Why did we recreate this wrapper?");
22363: #endif
    1:                 }
    1:                 break;
    1:             }
    1:         default:
    1:             NS_ASSERTION(0, "bad type");
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::JSData2Native(XPCCallContext& ccx, void* d, jsval s,
    1:                           const nsXPTType& type,
    1:                           JSBool useAllocator, const nsID* iid,
    1:                           nsresult* pErr)
    1: {
    1:     NS_PRECONDITION(d, "bad param");
    1: 
    1:     JSContext* cx = ccx.GetJSContext();
    1: 
    1:     int32    ti;
    1:     uint32   tu;
    1:     jsdouble td;
    1:     JSBool isDOMString = JS_TRUE;
    1: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS;
    1: 
    1:     switch(type.TagPart())
    1:     {
    1:     case nsXPTType::T_I8     :
    1:         if(!JS_ValueToECMAInt32(cx, s, &ti))
    1:             return JS_FALSE;
    1:         *((int8*)d)  = (int8) ti;
    1:         break;
    1:     case nsXPTType::T_I16    :
    1:         if(!JS_ValueToECMAInt32(cx, s, &ti))
    1:             return JS_FALSE;
    1:         *((int16*)d)  = (int16) ti;
    1:         break;
    1:     case nsXPTType::T_I32    :
    1:         if(!JS_ValueToECMAInt32(cx, s, (int32*)d))
    1:             return JS_FALSE;
    1:         break;
    1:     case nsXPTType::T_I64    :
    1:         if(JSVAL_IS_INT(s))
    1:         {
    1:             if(!JS_ValueToECMAInt32(cx, s, &ti))
    1:                 return JS_FALSE;
    1:             LL_I2L(*((int64*)d),ti);
    1: 
    1:         }
    1:         else
    1:         {
    1:             if(!JS_ValueToNumber(cx, s, &td))
    1:                 return JS_FALSE;
    1:             LL_D2L(*((int64*)d),td);
    1:         }
    1:         break;
    1:     case nsXPTType::T_U8     :
    1:         if(!JS_ValueToECMAUint32(cx, s, &tu))
    1:             return JS_FALSE;
    1:         *((uint8*)d)  = (uint8) tu;
    1:         break;
    1:     case nsXPTType::T_U16    :
    1:         if(!JS_ValueToECMAUint32(cx, s, &tu))
    1:             return JS_FALSE;
    1:         *((uint16*)d)  = (uint16) tu;
    1:         break;
    1:     case nsXPTType::T_U32    :
    1:         if(!JS_ValueToECMAUint32(cx, s, (uint32*)d))
    1:             return JS_FALSE;
    1:         break;
    1:     case nsXPTType::T_U64    :
    1:         if(JSVAL_IS_INT(s))
    1:         {
    1:             if(!JS_ValueToECMAUint32(cx, s, &tu))
    1:                 return JS_FALSE;
    1:             LL_UI2L(*((int64*)d),tu);
    1:         }
    1:         else
    1:         {
    1:             if(!JS_ValueToNumber(cx, s, &td))
    1:                 return JS_FALSE;
    1: #ifdef XP_WIN
    1:             // Note: Win32 can't handle double to uint64 directly
    1:             *((uint64*)d) = (uint64)((int64) td);
    1: #else
    1:             LL_D2L(*((uint64*)d),td);
    1: #endif
    1:         }
    1:         break;
    1:     case nsXPTType::T_FLOAT  :
    1:         if(!JS_ValueToNumber(cx, s, &td))
    1:             return JS_FALSE;
    1:         *((float*)d) = (float) td;
    1:         break;
    1:     case nsXPTType::T_DOUBLE :
    1:         if(!JS_ValueToNumber(cx, s, (double*)d))
    1:             return JS_FALSE;
    1:         break;
    1:     case nsXPTType::T_BOOL   :
    1:         if(!JS_ValueToBoolean(cx, s, (JSBool*)d))
    1:             return JS_FALSE;
    1:         break;
    1:     case nsXPTType::T_CHAR   :
    1:         {
    1:             char* bytes=nsnull;
    1:             JSString* str;
    1: 
    1:             if(!(str = JS_ValueToString(cx, s))||
    1:                !(bytes = JS_GetStringBytes(str)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1: #ifdef DEBUG
    1:             jschar* chars=nsnull;
    1:             if(nsnull!=(chars = JS_GetStringChars(str)))
    1:             {
    1:                 NS_ASSERTION((! ILLEGAL_RANGE(chars[0])),"U+0080/U+0100 - U+FFFF data lost");
    1:             }
    1: #endif // DEBUG
    1:             *((char*)d) = bytes[0];
    1:             break;
    1:         }
    1:     case nsXPTType::T_WCHAR  :
    1:         {
    1:             jschar* chars=nsnull;
    1:             JSString* str;
    1:             if(!(str = JS_ValueToString(cx, s))||
    1:                !(chars = JS_GetStringChars(str)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1:             *((uint16*)d)  = (uint16) chars[0];
    1:             break;
    1:         }
    1:     default:
    1:         if(!type.IsPointer())
    1:         {
    1:             NS_ASSERTION(0,"unsupported type");
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         switch(type.TagPart())
    1:         {
    1:         case nsXPTType::T_VOID:
    1:             XPC_LOG_ERROR(("XPCConvert::JSData2Native : void* params not supported"));
    1:             NS_ASSERTION(0,"void* params not supported");
    1:             return JS_FALSE;
    1:         case nsXPTType::T_IID:
    1:         {
    1:             NS_ASSERTION(useAllocator,"trying to convert a JSID to nsID without allocator : this would leak");
    1: 
    1:             JSObject* obj;
    1:             const nsID* pid=nsnull;
    1: 
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1:                 // else ...
    1:                 *((const nsID**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             if(!JSVAL_IS_OBJECT(s) ||
    1:                (!(obj = JSVAL_TO_OBJECT(s))) ||
10204:                (!(pid = xpc_JSObjectToID(cx, obj))) ||
10204:                (!(pid = (const nsID*) nsMemory::Clone(pid, sizeof(nsID)))))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1:             *((const nsID**)d) = pid;
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_ASTRING:        
    1:         {            
    1:             isDOMString = JS_FALSE;
    1:             // Fall through to T_DOMSTRING case.
    1:         }
    1:         case nsXPTType::T_DOMSTRING:
    1:         {
    1:             static const PRUnichar EMPTY_STRING[] = { '\0' };
    1:             static const PRUnichar VOID_STRING[] = { 'u', 'n', 'd', 'e', 'f', 'i', 'n', 'e', 'd', '\0' };
    1: 
    1:             const PRUnichar* chars;
    1:             JSString* str = nsnull;
    1:             JSBool isNewString = JS_FALSE;
    1:             PRUint32 length;
    1: 
    1:             if(JSVAL_IS_VOID(s))
    1:             {
    1:                 if(isDOMString) 
    1:                 {
    1:                     chars  = VOID_STRING;
    1:                     length = NS_ARRAY_LENGTH(VOID_STRING) - 1;
    1:                 }
    1:                 else
    1:                 {
    1:                     chars = EMPTY_STRING;
    1:                     length = 0;
    1:                 }
    1:             }
    1:             else if(!JSVAL_IS_NULL(s))
    1:             {
    1:                 str = JS_ValueToString(cx, s);
    1:                 if(!str)
    1:                     return JS_FALSE;
    1: 
    1:                 length = (PRUint32) JS_GetStringLength(str);
    1:                 if(length)
    1:                 {
    1:                     chars = (const PRUnichar*) JS_GetStringChars(str);
    1:                     if(!chars)
    1:                         return JS_FALSE;
    1:                     if(STRING_TO_JSVAL(str) != s)
    1:                         isNewString = JS_TRUE;
    1:                 }
    1:                 else
    1:                 {
    1:                     str = nsnull;
    1:                     chars = EMPTY_STRING;
    1:                 }
    1:             }
    1: 
    1:             if(useAllocator)
    1:             {
    1:                 // XXX extra string copy when isNewString
    1:                 if(str && !isNewString)
    1:                 {
    1:                     XPCReadableJSStringWrapper *wrapper =
 9332:                         XPCStringConvert::JSStringToReadable(ccx, str);
    1:                     if(!wrapper)
    1:                         return JS_FALSE;
    1: 
    1:                     *((const nsAString**)d) = wrapper;
    1:                 }
    1:                 else if(JSVAL_IS_NULL(s))
    1:                 {
    1:                     XPCReadableJSStringWrapper *wrapper =
    1:                         new XPCReadableJSStringWrapper();
    1:                     if(!wrapper)
    1:                         return JS_FALSE;
    1: 
    1:                     *((const nsAString**)d) = wrapper;
    1:                 }
    1:                 else
    1:                 {
    1:                     // use nsString to encourage sharing
    1:                     const nsAString *rs = new nsString(chars, length);
    1:                     if(!rs)
    1:                         return JS_FALSE;
    1:                     *((const nsAString**)d) = rs;
    1:                 }
    1:             }
    1:             else
    1:             {
    1:                 nsAString* ws = *((nsAString**)d);
    1: 
    1:                 if(JSVAL_IS_NULL(s) || (!isDOMString && JSVAL_IS_VOID(s)))
    1:                 {
    1:                     ws->Truncate();
    1:                     ws->SetIsVoid(PR_TRUE);
    1:                 }
    1:                 else
    1:                     ws->Assign(chars, length);
    1:             }
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_CHAR_STR:
    1:         {
    1:             char* bytes=nsnull;
    1:             JSString* str;
    1: 
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1:                 // else ...
    1:                 *((char**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             if(!(str = JS_ValueToString(cx, s))||
    1:                !(bytes = JS_GetStringBytes(str)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1: #ifdef DEBUG
    1:             jschar* chars=nsnull;
    1:             if(nsnull != (chars = JS_GetStringChars(str)))
    1:             {
    1:                 PRBool legalRange = PR_TRUE;
    1:                 int len = JS_GetStringLength(str);
    1:                 jschar* t;
    1:                 PRInt32 i=0;
    1:                 for(t=chars; (i< len) && legalRange ; i++,t++) {
    1:                   if(ILLEGAL_RANGE(*t))
    1:                       legalRange = PR_FALSE;
    1:                 }
    1:                 NS_ASSERTION(legalRange,"U+0080/U+0100 - U+FFFF data lost");
    1:             }
    1: #endif // DEBUG
    1:             if(useAllocator)
    1:             {
    1:                 int len = (JS_GetStringLength(str) + 1) * sizeof(char);
    1:                 if(!(*((void**)d) = nsMemory::Alloc(len)))
    1:                 {
    1:                     return JS_FALSE;
    1:                 }
    1:                 memcpy(*((void**)d), bytes, len);
    1:             }
    1:             else
    1:                 *((char**)d) = bytes;
    1: 
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_WCHAR_STR:
    1:         {
    1:             jschar* chars=nsnull;
    1:             JSString* str;
    1: 
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1:                 // else ...
    1:                 *((jschar**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             if(!(str = JS_ValueToString(cx, s))||
    1:                !(chars = JS_GetStringChars(str)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1:             if(useAllocator)
    1:             {
    1:                 int byte_len = (JS_GetStringLength(str)+1)*sizeof(jschar);
    1:                 if(!(*((void**)d) = nsMemory::Alloc(byte_len)))
    1:                 {
    1:                     // XXX should report error
    1:                     return JS_FALSE;
    1:                 }
    1:                 memcpy(*((void**)d), chars, byte_len);
    1:             }
    1:             else
    1:                 *((jschar**)d) = chars;
    1: 
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_UTF8STRING:            
    1:         {
    1:             jschar* chars;
    1:             PRUint32 length;
    1:             JSString* str;
    1: 
    1:             if(JSVAL_IS_NULL(s) || JSVAL_IS_VOID(s))
    1:             {
    1:                 if(useAllocator) 
    1:                 {
    1:                     nsACString *rs = new nsCString();
    1:                     if(!rs) 
    1:                         return JS_FALSE;
    1: 
    1:                     rs->SetIsVoid(PR_TRUE);
    1:                     *((nsACString**)d) = rs;
    1:                 }
    1:                 else
    1:                 {
    1:                     nsCString* rs = *((nsCString**)d);
    1:                     rs->Truncate();
    1:                     rs->SetIsVoid(PR_TRUE);
    1:                 }
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             // The JS val is neither null nor void...
    1: 
    1:             if(!(str = JS_ValueToString(cx, s))||
    1:                !(chars = JS_GetStringChars(str)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             length = JS_GetStringLength(str);
    1: 
    1:             nsCString *rs;
    1:             if(useAllocator)
    1:             {                
    1:                 // Use nsCString to enable sharing
    1:                 rs = new nsCString();
    1:                 if(!rs)
    1:                     return JS_FALSE;
    1: 
    1:                 *((const nsCString**)d) = rs;
    1:             }
    1:             else
    1:             {
    1:                 rs = *((nsCString**)d);
    1:             }
    1:             CopyUTF16toUTF8(nsDependentString((const PRUnichar*)chars, length),
    1:                             *rs);
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_CSTRING:
    1:         {
    1:             const char* chars;            
    1:             PRUint32 length;
    1:             JSString* str;
    1: 
    1:             if(JSVAL_IS_NULL(s) || JSVAL_IS_VOID(s))
    1:             {
    1:                 if(useAllocator)
    1:                 {
    1:                     nsACString *rs = new nsCString();
    1:                     if(!rs) 
    1:                         return JS_FALSE;
    1: 
    1:                     rs->SetIsVoid(PR_TRUE);
    1:                     *((nsACString**)d) = rs;
    1:                 }
    1:                 else
    1:                 {
    1:                     nsACString* rs = *((nsACString**)d);
    1:                     rs->Truncate();
    1:                     rs->SetIsVoid(PR_TRUE);
    1:                 }
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             // The JS val is neither null nor void...
    1: 
    1:             if(!(str = JS_ValueToString(cx, s)) ||
    1:                !(chars = JS_GetStringBytes(str)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             length = JS_GetStringLength(str);
    1: 
    1:             if(useAllocator)
    1:             {
    1:                 const nsACString *rs = new nsCString(chars, length);
    1: 
    1:                 if(!rs)
    1:                     return JS_FALSE;
    1: 
    1:                 *((const nsACString**)d) = rs;
    1:             }
    1:             else
    1:             {
    1:                 nsACString* rs = *((nsACString**)d);
    1: 
    1:                 rs->Assign(nsDependentCString(chars, length));
    1:             }
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_INTERFACE:
    1:         case nsXPTType::T_INTERFACE_IS:
    1:         {
    1:             JSObject* obj;
    1:             NS_ASSERTION(iid,"can't do interface conversions without iid");
    1: 
    1:             if(iid->Equals(NS_GET_IID(nsIVariant)))
    1:             {
    1:                 XPCVariant* variant = XPCVariant::newVariant(ccx, s);
    1:                 if(!variant)
    1:                     return JS_FALSE;
 3233:                 *((nsISupports**)d) = static_cast<nsIVariant*>(variant);
    1:                 return JS_TRUE;
    1:             }
    1:             else if(iid->Equals(NS_GET_IID(nsIAtom)) &&
    1:                     JSVAL_IS_STRING(s))
    1:             {
    1:                 // We're trying to pass a string as an nsIAtom.  Let's atomize!
    1:                 JSString* str = JSVAL_TO_STRING(s);
    1:                 PRUnichar* chars =
 3233:                     reinterpret_cast<PRUnichar*>(JS_GetStringChars(str));
    1:                 if (!chars) {
    1:                     if (pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1:                 PRUint32 length = JS_GetStringLength(str);
    1:                 nsIAtom* atom = NS_NewAtom(nsDependentString(chars, length));
    1:                 if (!atom && pErr)
    1:                     *pErr = NS_ERROR_OUT_OF_MEMORY;
    1:                 *((nsISupports**)d) = atom;
    1:                 return atom != nsnull;                
    1:             }
    1:             //else ...
    1: 
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1:                 // else ...
    1:                 *((nsISupports**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             // only wrap JSObjects
    1:             if(!JSVAL_IS_OBJECT(s) || !(obj = JSVAL_TO_OBJECT(s)))
    1:             {
    1:                 if(pErr && JSVAL_IS_INT(s) && 0 == JSVAL_TO_INT(s))
    1:                     *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL;
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             return JSObject2NativeInterface(ccx, (void**)d, obj, iid,
 5491:                                             nsnull, pErr);
    1:         }
    1:         default:
    1:             NS_ASSERTION(0, "bad type");
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
22841: inline JSBool
22841: CreateHolderIfNeeded(XPCCallContext& ccx, JSObject* obj, jsval* d,
22147:                      nsIXPConnectJSObjectHolder** dest)
22147: {
22841:     if(dest)
22841:     {
22147:         XPCJSObjectHolder* objHolder = XPCJSObjectHolder::newHolder(ccx, obj);
22147:         if(!objHolder)
22147:             return JS_FALSE;
22147:         
22147:         NS_ADDREF(*dest = objHolder);
22841:     }
22841: 
22841:     *d = OBJECT_TO_JSVAL(obj);
22147: 
22147:     return JS_TRUE;
22147: }
22147: 
    1: /***************************************************************************/
    1: // static
    1: JSBool
    1: XPCConvert::NativeInterface2JSObject(XPCCallContext& ccx,
22841:                                      jsval* d,
    1:                                      nsIXPConnectJSObjectHolder** dest,
    1:                                      nsISupports* src,
    1:                                      const nsID* iid,
22842:                                      XPCNativeInterface* Interface,
23258:                                      nsWrapperCache *cache,
    1:                                      JSObject* scope,
    1:                                      PRBool allowNativeWrapper,
    1:                                      PRBool isGlobal,
    1:                                      nsresult* pErr)
    1: {
    1:     NS_ASSERTION(scope, "bad param");
    1: 
22841:     *d = JSVAL_NULL;
22841:     if(dest)
    1:         *dest = nsnull;
    1:     if(!src)
    1:         return JS_TRUE;
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_NATIVE;
    1: 
    1: // #define this if we want to 'double wrap' of JSObjects.
    1: // This is for the case where we have a JSObject wrapped for native use
    1: // which needs to be converted to a JSObject. Originally, we were unwrapping
    1: // and just exposing the underlying JSObject. This causes anomolies when
    1: // JSComponents are accessed from other JS code - they don't act like
    1: // other xpconnect wrapped components. Eventually we want to build a new
    1: // kind of wrapper especially for JS <-> JS. For now we are building a wrapper
    1: // around a wrapper. This is not optimal, but good enough for now.
    1: #define XPC_DO_DOUBLE_WRAP 1
    1: 
    1: #ifndef XPC_DO_DOUBLE_WRAP
    1:     // is this a wrapped JS object?
    1:     if(nsXPCWrappedJSClass::IsWrappedJS(src))
    1:     {
    1:         NS_ASSERTION(!isGlobal, "The global object must be native");
    1: 
    1:         // verify that this wrapper is for the right interface
    1:         nsCOMPtr<nsISupports> wrapper;
22842:         if(Interface)
22842:             src->QueryInterface(*Interface->GetIID(),
22842:                                 (void**)getter_AddRefs(wrapper));
22842:         else if(iid)
22841:             src->QueryInterface(*iid, (void**)getter_AddRefs(wrapper));
22842:         else
22842:             wrapper = do_QueryInterface(src);
22841:         nsCOMPtr<nsIXPConnectJSObjectHolder> holder =
22841:             do_QueryInterface(wrapper);
22841:         JSObject* flat;
22841:         if(!holder || !(flat = holder->GetFlatJSObject()))
    1:             return JS_FALSE;
22841: 
22841:         *d = OBJECT_TO_JSVAL(flat);
22841:         if(dest)
22841:             holder.swap(*dest);
22841:         return JS_TRUE;
    1:     }
    1:     else
    1: #endif /* XPC_DO_DOUBLE_WRAP */
    1:     {
    1:         XPCWrappedNativeScope* xpcscope =
    1:             XPCWrappedNativeScope::FindInJSObjectScope(ccx, scope);
    1:         if(!xpcscope)
    1:             return JS_FALSE;
    1: 
30001:         if(!cache)
30001:             CallQueryInterface(src, &cache);
30001:         JSObject *flat;
30001:         if(cache)
30001:         {
30001:             flat = cache->GetWrapper();
30001:             if(!dest)
30001:             {
30001:                 if(!flat)
30001:                 {
30001:                     jsval slim;
30001:                     if(ConstructSlimWrapper(ccx, src, cache, Interface,
30001:                                             xpcscope, &slim))
30001:                     {
30001:                         *d = slim;
30001:                         return JS_TRUE;
30001:                     }
30384: 
30384:                     // Even if ConstructSlimWrapper returns JS_FALSE it might
30384:                     // have created a wrapper (while calling the PreCreate
30384:                     // hook). In that case we need to fall through because we
30384:                     // either have a slim wrapper that needs to be morphed or
30384:                     // we have an XPCWrappedNative.
30384:                     flat = cache->GetWrapper();
30001:                 }
30001:                 else if(!IS_WRAPPER_CLASS(STOBJ_GET_CLASS(flat)))
30001:                 {
30001:                     JSObject* global = JS_GetGlobalForObject(ccx, flat);
30001:                     if(global == xpcscope->GetGlobalJSObject())
30001:                     {
30001:                         *d = OBJECT_TO_JSVAL(flat);
30001:                         return JS_TRUE;
30001:                     }
30001:                 }
30001:             }
30001:         }
30001:         else
30001:         {
30001:             flat = nsnull;
30001:         }
30001: 
22842:         AutoMarkingNativeInterfacePtr iface(ccx, Interface);
22842:         if(!iface && iid)
22842:         {
    1:             iface = XPCNativeInterface::GetNewOrUsed(ccx, iid);
    1:             if(!iface)
    1:                 return JS_FALSE;
22842:         }
    1: 
21618:         nsresult rv;
    1:         XPCWrappedNative* wrapper;
22841:         nsRefPtr<XPCWrappedNative> strongWrapper;
30001:         if(!flat)
21618:         {
30001:             rv = XPCWrappedNative::GetNewOrUsed(ccx, src, xpcscope, iface,
30001:                                                 cache, isGlobal,
30001:                                                 getter_AddRefs(strongWrapper));
30001: 
30001:             wrapper = strongWrapper;
30001:         }
30001:         else if(IS_WRAPPER_CLASS(STOBJ_GET_CLASS(flat)))
30001:         {
30001:             wrapper = static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(flat));
30001: 
22841:             // If asked to return the wrapper we'll return a strong reference,
30001:             // otherwise we'll just return its JSObject in d (which should be
22841:             // rooted in that case).
22841:             if(dest)
22841:                 strongWrapper = wrapper;
22842:             if(iface)
21618:                 wrapper->FindTearOff(ccx, iface, JS_FALSE, &rv);
22842:             else
22842:                 rv = NS_OK;
21618:         }
21618:         else
21618:         {
30001:             NS_ASSERTION(IS_SLIM_WRAPPER(flat),
30001:                          "What kind of wrapper is this?");
30001:             SLIM_LOG(("***** morphing from XPCConvert::NativeInterface2JSObject"
30001:                       "(%p)\n",
30001:                       static_cast<nsISupports*>(xpc_GetJSPrivate(flat))));
30001: 
30001:             rv = XPCWrappedNative::Morph(ccx, flat, iface, cache,
22841:                                          getter_AddRefs(strongWrapper));
22841:             wrapper = strongWrapper;
21618:         }
21618: 
    1:         if(pErr)
    1:             *pErr = rv;
    1:         if(NS_SUCCEEDED(rv) && wrapper)
    1:         {
12585:             uint32 flags = 0;
30001:             flat = wrapper->GetFlatJSObject();
22147:             jsval v = OBJECT_TO_JSVAL(flat);
25725: 
25727:             JSBool sameOrigin;
25725:             if (allowNativeWrapper &&
25727:                 !xpc_SameScope(wrapper->GetScope(), xpcscope, &sameOrigin))
    1:             {
    1:                 // Cross scope access detected. Check if chrome code
    1:                 // is accessing non-chrome objects, and if so, wrap
    1:                 // the XPCWrappedNative with an XPCNativeWrapper to
    1:                 // prevent user-defined properties from shadowing DOM
    1:                 // properties from chrome code.
    1: 
    1:                 // printf("Wrapped native accessed across scope boundary\n");
    1: 
    1:                 JSScript* script = nsnull;
16566:                 JSObject* callee = nsnull;
    1:                 if(ccx.GetXPCContext()->CallerTypeIsJavaScript())
    1:                 {
    1:                     // Called from JS.  We're going to hand the resulting
    1:                     // JSObject to said JS, so look for the script we want on
    1:                     // the stack.
    1:                     JSContext* cx = ccx;
22652:                     JSStackFrame* fp = JS_GetScriptedCaller(cx, NULL);
22652:                     if(fp)
    1:                     {
    1:                         script = fp->script;
16566:                         callee = fp->callee;
    1:                     }
    1:                 }
    1:                 else if(ccx.GetXPCContext()->CallerTypeIsNative())
    1:                 {
16566:                     callee = ccx.GetCallee();
    1:                     if(callee && JS_ObjectIsFunction(ccx, callee))
    1:                     {
    1:                         // Called from c++, and calling out to |callee|, which
    1:                         // is a JS function object.  Look for the script for
    1:                         // this function.
    1:                         JSFunction* fun =
10858:                             (JSFunction*) xpc_GetJSPrivate(callee);
    1:                         NS_ASSERTION(fun,
    1:                                      "Must have JSFunction for a Function "
    1:                                      "object");
    1:                         script = JS_GetFunctionScript(ccx, fun);
    1:                     }
16566:                     else
16566:                     {
16566:                         // Else we don't know whom we're calling, so don't
16566:                         // create XPCNativeWrappers.
16566:                         callee = nsnull;
16566:                     }
    1:                 }
    1:                 // else don't create XPCNativeWrappers, since we have
    1:                 // no idea what's calling what here.
    1: 
12585:                 flags = script ? JS_GetScriptFilenameFlags(script) : 0;
    1:                 NS_ASSERTION(flags != JSFILENAME_NULL, "null script filename");
    1: 
12585:                 if(!JS_IsSystemObject(ccx, flat))
12584:                 {
22841:                     // From here on we might create new JSObjects, so we need to
22841:                     // make sure that wrapper stays alive.
22841:                     if(!strongWrapper)
22841:                         strongWrapper = wrapper;
22841: 
22147:                     JSObject *destObj = nsnull;
25727:                     JSBool triedWrapping = JS_FALSE;
12584:                     if(flags & JSFILENAME_PROTECTED)
    1:                     {
    1: #ifdef DEBUG_XPCNativeWrapper
    1:                         {
    1:                             char *s = wrapper->ToString(ccx);
12584:                             printf("Content accessed from chrome, wrapping "
12584:                                    "wrapper (%s) in XPCNativeWrapper\n", s);
    1:                             if (s)
    1:                                 JS_smprintf_free(s);
    1:                         }
    1: #endif
20762:                         nsIScriptSecurityManager *ssm =
20762:                             XPCWrapper::GetSecurityManager();
20762:                         nsCOMPtr<nsIPrincipal> objPrincipal;
20762:                         if(callee)
20762:                         {
20762:                             // Prefer getting the object princpal here.
20762:                             nsresult rv =
20762:                                 ssm->GetObjectPrincipal(ccx, callee,
20762:                                                         getter_AddRefs(objPrincipal));
20762:                             if(NS_FAILED(rv))
20762:                                 return JS_FALSE;
20762:                         }
20762:                         else
20762:                         {
20762:                             JSPrincipals *scriptPrincipal =
20762:                                 JS_GetScriptPrincipals(ccx, script);
20762:                             if(scriptPrincipal)
20762:                             {
20762:                                 nsJSPrincipals *nsjsp =
20762:                                     static_cast<nsJSPrincipals *>(scriptPrincipal);
20762:                                 objPrincipal = nsjsp->nsIPrincipalPtr;
20762:                             }
20762:                         }
    1: 
22147:                         destObj =
16566:                             XPCNativeWrapper::GetNewOrUsed(ccx, wrapper,
20762:                                                            objPrincipal);
25727:                         triedWrapping = JS_TRUE;
    1:                     }
22147:                     else if (flags & JSFILENAME_SYSTEM)
12584:                     {
12584: #ifdef DEBUG_mrbkap
12584:                         printf("Content accessed from chrome, wrapping in an "
12584:                                "XPCSafeJSObjectWrapper\n");
12584: #endif
12584: 
22147:                         if(XPC_SJOW_Construct(ccx, nsnull, 1, &v, &v))
22147:                             destObj = JSVAL_TO_OBJECT(v);
25727:                         triedWrapping = JS_TRUE;
22147:                     }
25727:                     else if (!sameOrigin)
22115:                     {
22147:                         // Reaching across scopes from content code. Wrap
22147:                         // the new object in a XOW.
22147:                         if (XPC_XOW_WrapObject(ccx, scope, &v))
22147:                             destObj = JSVAL_TO_OBJECT(v);
25727:                         triedWrapping = JS_TRUE;
22065:                     }
22115: 
25727:                     if(triedWrapping)
27664:                     {
27664:                         if(!destObj)
27664:                             return JS_FALSE;
27664: 
27664:                         jsval wrappedObjVal = OBJECT_TO_JSVAL(destObj);
27664:                         AUTO_MARK_JSVAL(ccx, &wrappedObjVal);
27664:                         if(wrapper->NeedsChromeWrapper())
27664:                         {
27664:                             if(!XPC_SOW_WrapObject(ccx, xpcscope->GetGlobalJSObject(),
27664:                                                    OBJECT_TO_JSVAL(destObj),
27664:                                                    &wrappedObjVal))
27664:                                 return JS_FALSE;
27664:                         }
27664: 
27664:                         return CreateHolderIfNeeded(ccx, JSVAL_TO_OBJECT(wrappedObjVal),
27664:                                                     d, dest);
27664:                     }
12585:                 }
12585:             }
    1: 
10858:             const char *name = STOBJ_GET_CLASS(flat)->name;
 4042:             if(allowNativeWrapper &&
 4042:                !(flags & JSFILENAME_SYSTEM) &&
12585:                !JS_IsSystemObject(ccx, flat) &&
 4042:                XPC_XOW_ClassNeedsXOW(name))
 4042:             {
22841:                 // From here on we might create new JSObjects, so we need to
22841:                 // make sure that wrapper stays alive.
22841:                 if(!strongWrapper)
22841:                     strongWrapper = wrapper;
22147: 
27664:                 AUTO_MARK_JSVAL(ccx, &v);
22841:                 return XPC_XOW_WrapObject(ccx, scope, &v) &&
27664:                        (!wrapper->NeedsChromeWrapper() ||
27664:                         XPC_SOW_WrapObject(ccx, xpcscope->GetGlobalJSObject(),
27664:                                            v, &v)) &&
22841:                        CreateHolderIfNeeded(ccx, JSVAL_TO_OBJECT(v), d, dest);
 4042:             }
 4042: 
28705:             if(allowNativeWrapper && wrapper->NeedsChromeWrapper())
27664:             {
27664:                 if(!XPC_SOW_WrapObject(ccx, xpcscope->GetGlobalJSObject(), v, d))
27664:                     return JS_FALSE;
28705:             }
28705:             else
28705:             {
28705:                 *d = v;
27664:             }
22841:             if(dest)
22841:                 *dest = strongWrapper.forget().get();
    1:             return JS_TRUE;
    1:         }
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::JSObject2NativeInterface(XPCCallContext& ccx,
    1:                                      void** dest, JSObject* src,
    1:                                      const nsID* iid,
    1:                                      nsISupports* aOuter,
    1:                                      nsresult* pErr)
    1: {
    1:     NS_ASSERTION(dest, "bad param");
    1:     NS_ASSERTION(src, "bad param");
    1:     NS_ASSERTION(iid, "bad param");
    1: 
    1:     JSContext* cx = ccx.GetJSContext();
    1: 
    1:     *dest = nsnull;
    1:      if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS;
    1: 
    1:     nsISupports* iface;
    1: 
    1:     if(!aOuter)
    1:     {
    1:         // Note that if we have a non-null aOuter then it means that we are
    1:         // forcing the creation of a wrapper even if the object *is* a 
    1:         // wrappedNative or other wise has 'nsISupportness'. 
    1:         // This allows wrapJSAggregatedToNative to work.
    1: 
    1:         // Is this really a native xpcom object with a wrapper?
    1:         XPCWrappedNative* wrappedNative =
    1:                     XPCWrappedNative::GetWrappedNativeOfJSObject(cx, src);
    1:         if(wrappedNative)
    1:         {
    1:             iface = wrappedNative->GetIdentityObject();
    1:             return NS_SUCCEEDED(iface->QueryInterface(*iid, dest));
    1:         }
    1:         // else...
    1:         
    1:         // XXX E4X breaks the world. Don't try wrapping E4X objects!
    1:         // This hack can be removed (or changed accordingly) when the
    1:         // DOM <-> E4X bindings are complete, see bug 270553
    1:         if(JS_TypeOfValue(cx, OBJECT_TO_JSVAL(src)) == JSTYPE_XML)
    1:             return JS_FALSE;
    1: 
    1:         // Does the JSObject have 'nsISupportness'?
    1:         // XXX hmm, I wonder if this matters anymore with no 
    1:         // oldstyle DOM objects around.
10858:         if(GetISupportsFromJSObject(src, &iface))
    1:         {
    1:             if(iface)
    1:                 return NS_SUCCEEDED(iface->QueryInterface(*iid, dest));
    1: 
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     // else...
    1: 
    1:     nsXPCWrappedJS* wrapper;
 5491:     nsresult rv = nsXPCWrappedJS::GetNewOrUsed(ccx, src, *iid, aOuter, &wrapper);
    1:     if(pErr)
    1:         *pErr = rv;
    1:     if(NS_SUCCEEDED(rv) && wrapper)
    1:     {
    1:         // We need to go through the QueryInterface logic to make this return
    1:         // the right thing for the various 'special' interfaces; e.g. 
    1:         // nsIPropertyBag. We must use AggregatedQueryInterface in cases where 
    1:         // there is an outer to avoid nasty recursion.
    1:         rv = aOuter ? wrapper->AggregatedQueryInterface(*iid, dest) :
    1:                       wrapper->QueryInterface(*iid, dest);
    1:         if(pErr)
    1:             *pErr = rv;
    1:         NS_RELEASE(wrapper);
    1:         return NS_SUCCEEDED(rv);        
    1:     }
    1: 
    1:     // else...
    1:     return JS_FALSE;
    1: }
    1: 
    1: /***************************************************************************/
    1: /***************************************************************************/
    1: 
    1: // static
    1: nsresult
    1: XPCConvert::ConstructException(nsresult rv, const char* message,
    1:                                const char* ifaceName, const char* methodName,
    1:                                nsISupports* data,
19303:                                nsIException** exceptn,
21377:                                JSContext* cx,
21377:                                jsval* jsExceptionPtr)
    1: {
21377:     NS_ASSERTION(!cx == !jsExceptionPtr, "Expected cx and jsExceptionPtr to cooccur.");
21377: 
    1:     static const char format[] = "\'%s\' when calling method: [%s::%s]";
    1:     const char * msg = message;
    1:     char* sz = nsnull;
    1:     nsXPIDLString xmsg;
    1:     nsCAutoString sxmsg;
    1: 
    1:     nsCOMPtr<nsIScriptError> errorObject = do_QueryInterface(data);
    1:     if(errorObject) {
11566:         if (NS_SUCCEEDED(errorObject->GetMessageMoz(getter_Copies(xmsg)))) {
    1:             CopyUTF16toUTF8(xmsg, sxmsg);
    1:             msg = sxmsg.get();
    1:         }
    1:     }
    1:     if(!msg)
    1:         if(!nsXPCException::NameAndFormatForNSResult(rv, nsnull, &msg) || ! msg)
    1:             msg = "<error>";
    1:     if(ifaceName && methodName)
    1:         msg = sz = JS_smprintf(format, msg, ifaceName, methodName);
    1: 
    1:     nsresult res = nsXPCException::NewException(msg, rv, nsnull, data, exceptn);
    1: 
21377:     if(NS_SUCCEEDED(res) && cx && jsExceptionPtr && *exceptn)
19303:     {
27587:         nsCOMPtr<nsIXPCException> xpcEx = do_QueryInterface(*exceptn);
19303:         if(xpcEx)
27587:             xpcEx->StowJSVal(cx, *jsExceptionPtr);
19303:     }
19303: 
    1:     if(sz)
    1:         JS_smprintf_free(sz);
    1:     return res;
    1: }
    1: 
    1: /********************************/
    1: 
20444: class AutoExceptionRestorer : public JSAutoTempValueRooter
20444: {
20444: public:
20444:     AutoExceptionRestorer(JSContext *cx, jsval v)
20444:         : JSAutoTempValueRooter(cx, v),
20444:           mVal(v)
20444:     {
20444:         JS_ClearPendingException(mContext);
20444:     }
20444: 
20444:     ~AutoExceptionRestorer()
20444:     {
20444:         JS_SetPendingException(mContext, mVal);
20444:     }
20444: 
20444: private:
20444:     jsval mVal;
20444: };
20444: 
    1: // static
    1: nsresult
    1: XPCConvert::JSValToXPCException(XPCCallContext& ccx,
    1:                                 jsval s,
    1:                                 const char* ifaceName,
    1:                                 const char* methodName,
    1:                                 nsIException** exceptn)
    1: {
    1:     JSContext* cx = ccx.GetJSContext();
20444:     AutoExceptionRestorer aer(cx, s);
    1: 
    1:     if(!JSVAL_IS_PRIMITIVE(s))
    1:     {
    1:         // we have a JSObject
    1:         JSObject* obj = JSVAL_TO_OBJECT(s);
    1: 
    1:         if(!obj)
    1:         {
    1:             NS_ASSERTION(0, "when is an object not an object?");
    1:             return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         // is this really a native xpcom object with a wrapper?
    1:         XPCWrappedNative* wrapper;
    1:         if(nsnull != (wrapper =
    1:            XPCWrappedNative::GetWrappedNativeOfJSObject(cx,obj)))
    1:         {
    1:             nsISupports* supports = wrapper->GetIdentityObject();
    1:             nsCOMPtr<nsIException> iface = do_QueryInterface(supports);
    1:             if(iface)
    1:             {
    1:                 // just pass through the exception (with extra ref and all)
    1:                 nsIException* temp = iface;
    1:                 NS_ADDREF(temp);
    1:                 *exceptn = temp;
    1:                 return NS_OK;
    1:             }
    1:             else
    1:             {
    1:                 // it is a wrapped native, but not an exception!
    1:                 return ConstructException(NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT,
    1:                                           nsnull, ifaceName, methodName, supports,
21377:                                           exceptn, nsnull, nsnull);
    1:             }
    1:         }
    1:         else
    1:         {
    1:             // It is a JSObject, but not a wrapped native...
    1: 
    1:             // If it is an engine Error with an error report then let's
    1:             // extract the report and build an xpcexception from that
    1:             const JSErrorReport* report;
    1:             if(nsnull != (report = JS_ErrorFromException(cx, s)))
    1:             {
    1:                 const char* message = nsnull;
    1:                 JSString* str;
    1:                 if(nsnull != (str = JS_ValueToString(cx, s)))
    1:                     message = JS_GetStringBytes(str);
    1:                 return JSErrorToXPCException(ccx, message, ifaceName,
    1:                                              methodName, report, exceptn);
    1:             }
    1: 
    1: 
    1:             uintN ignored;
    1:             JSBool found;
    1: 
    1:             // heuristic to see if it might be usable as an xpcexception
    1:             if(JS_GetPropertyAttributes(cx, obj, "message", &ignored, &found) &&
    1:                found &&
    1:                JS_GetPropertyAttributes(cx, obj, "result", &ignored, &found) &&
    1:                found)
    1:             {
    1:                 // lets try to build a wrapper around the JSObject
    1:                 nsXPCWrappedJS* jswrapper;
    1:                 nsresult rv =
    1:                     nsXPCWrappedJS::GetNewOrUsed(ccx, obj,
    1:                                                  NS_GET_IID(nsIException),
    1:                                                  nsnull, &jswrapper);
    1:                 if(NS_FAILED(rv))
    1:                     return rv;
 3233:                 *exceptn = reinterpret_cast<nsIException*>
 3233:                            (jswrapper);
    1:                 return NS_OK;
    1:             }
    1: 
    1: 
    1:             // XXX we should do a check against 'js_ErrorClass' here and
    1:             // do the right thing - even though it has no JSErrorReport,
    1:             // The fact that it is a JSError exceptions means we can extract
    1:             // particular info and our 'result' should reflect that.
    1: 
    1:             // otherwise we'll just try to convert it to a string
    1: 
    1:             JSString* str = JS_ValueToString(cx, s);
    1:             if(!str)
    1:                 return NS_ERROR_FAILURE;
    1: 
    1:             return ConstructException(NS_ERROR_XPC_JS_THREW_JS_OBJECT,
    1:                                       JS_GetStringBytes(str),
    1:                                       ifaceName, methodName, nsnull,
21377:                                       exceptn, cx, &s);
    1:         }
    1:     }
    1: 
    1:     if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:     {
    1:         return ConstructException(NS_ERROR_XPC_JS_THREW_NULL,
    1:                                   nsnull, ifaceName, methodName, nsnull,
21377:                                   exceptn, cx, &s);
    1:     }
    1: 
    1:     if(JSVAL_IS_NUMBER(s))
    1:     {
    1:         // lets see if it looks like an nsresult
    1:         nsresult rv;
    1:         double number;
    1:         JSBool isResult = JS_FALSE;
    1: 
    1:         if(JSVAL_IS_INT(s))
    1:         {
    1:             rv = (nsresult) JSVAL_TO_INT(s);
    1:             if(NS_FAILED(rv))
    1:                 isResult = JS_TRUE;
    1:             else
    1:                 number = (double) JSVAL_TO_INT(s);
    1:         }
    1:         else
    1:         {
    1:             number = *(JSVAL_TO_DOUBLE(s));
    1:             if(number > 0.0 &&
    1:                number < (double)0xffffffff &&
    1:                0.0 == fmod(number,1))
    1:             {
    1:                 rv = (nsresult) number;
    1:                 if(NS_FAILED(rv))
    1:                     isResult = JS_TRUE;
    1:             }
    1:         }
    1: 
    1:         if(isResult)
    1:             return ConstructException(rv, nsnull, ifaceName, methodName,
21377:                                       nsnull, exceptn, cx, &s);
    1:         else
    1:         {
19303:             // XXX all this nsISupportsDouble code seems a little redundant
19303:             // now that we're storing the jsval in the exception...
    1:             nsISupportsDouble* data;
    1:             nsCOMPtr<nsIComponentManager> cm;
    1:             if(NS_FAILED(NS_GetComponentManager(getter_AddRefs(cm))) || !cm ||
    1:                NS_FAILED(cm->CreateInstanceByContractID(
    1:                                 NS_SUPPORTS_DOUBLE_CONTRACTID,
    1:                                 nsnull,
    1:                                 NS_GET_IID(nsISupportsDouble),
    1:                                 (void**)&data)))
    1:                 return NS_ERROR_FAILURE;
    1:             data->SetData(number);
    1:             rv = ConstructException(NS_ERROR_XPC_JS_THREW_NUMBER, nsnull,
21377:                                     ifaceName, methodName, data, exceptn, cx, &s);
    1:             NS_RELEASE(data);
    1:             return rv;
    1:         }
    1:     }
    1: 
    1:     // otherwise we'll just try to convert it to a string
19303:     // Note: e.g., JSBools get converted to JSStrings by this code.
    1: 
    1:     JSString* str = JS_ValueToString(cx, s);
    1:     if(str)
    1:         return ConstructException(NS_ERROR_XPC_JS_THREW_STRING,
    1:                                   JS_GetStringBytes(str),
    1:                                   ifaceName, methodName, nsnull,
21377:                                   exceptn, cx, &s);
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /********************************/
    1: 
    1: // static
    1: nsresult
    1: XPCConvert::JSErrorToXPCException(XPCCallContext& ccx,
    1:                                   const char* message,
    1:                                   const char* ifaceName,
    1:                                   const char* methodName,
    1:                                   const JSErrorReport* report,
    1:                                   nsIException** exceptn)
    1: {
    1:     nsresult rv = NS_ERROR_FAILURE;
    1:     nsScriptError* data;
    1:     if(report)
    1:     {
    1:         nsAutoString bestMessage;
    1:         if(report && report->ucmessage)
    1:         {
    1:             bestMessage = (const PRUnichar *)report->ucmessage;
    1:         }
    1:         else if(message)
    1:         {
    1:             bestMessage.AssignWithConversion(message);
    1:         }
    1:         else
    1:         {
    1:             bestMessage.AssignLiteral("JavaScript Error");
    1:         }
    1: 
    1:         data = new nsScriptError();
    1:         if(!data)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         NS_ADDREF(data);
    1:         data->Init(bestMessage.get(),
    1:                    NS_ConvertASCIItoUTF16(report->filename).get(),
    1:                    (const PRUnichar *)report->uclinebuf, report->lineno,
    1:                    report->uctokenptr - report->uclinebuf, report->flags,
    1:                    "XPConnect JavaScript");
    1:     }
    1:     else
    1:         data = nsnull;
    1: 
    1:     if(data)
    1:     {
    1:         nsCAutoString formattedMsg;
    1:         data->ToString(formattedMsg);
    1: 
    1:         rv = ConstructException(NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS,
    1:                                 formattedMsg.get(), ifaceName, methodName, data,
21377:                                 exceptn, nsnull, nsnull);
    1: 
    1:         NS_RELEASE(data);
    1:     }
    1:     else
    1:     {
    1:         rv = ConstructException(NS_ERROR_XPC_JAVASCRIPT_ERROR,
    1:                                 nsnull, ifaceName, methodName, nsnull,
21377:                                 exceptn, nsnull, nsnull);
    1:     }
    1:     return rv;
    1: }
    1: 
    1: 
    1: /***************************************************************************/
    1: 
    1: /*
    1: ** Note: on some platforms va_list is defined as an array,
    1: ** and requires array notation.
    1: */
    1: #ifdef HAVE_VA_COPY
    1: #define VARARGS_ASSIGN(foo, bar)	VA_COPY(foo,bar)
    1: #elif defined(HAVE_VA_LIST_AS_ARRAY)
    1: #define VARARGS_ASSIGN(foo, bar)	foo[0] = bar[0]
    1: #else
    1: #define VARARGS_ASSIGN(foo, bar)	(foo) = (bar)
    1: #endif
    1: 
    1: // We assert below that these formats all begin with "%i".
    1: const char* XPC_ARG_FORMATTER_FORMAT_STRINGS[] = {"%ip", "%iv", "%is", nsnull};
    1: 
18907: JSBool
    1: XPC_JSArgumentFormatter(JSContext *cx, const char *format,
    1:                         JSBool fromJS, jsval **vpp, va_list *app)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER, cx);
    1:     if(!ccx.IsValid())
    1:         return JS_FALSE;
    1: 
    1:     jsval *vp;
    1:     va_list ap;
    1: 
    1:     vp = *vpp;
    1:     VARARGS_ASSIGN(ap, *app);
    1: 
    1:     nsXPTType type;
    1:     const nsIID* iid;
    1:     void* p;
    1: 
    1:     NS_ASSERTION(format[0] == '%' && format[1] == 'i', "bad format!");
    1:     char which = format[2];
    1: 
    1:     if(fromJS)
    1:     {
    1:         switch(which)
    1:         {
    1:             case 'p':
    1:                 type = nsXPTType((uint8)(TD_INTERFACE_TYPE | XPT_TDP_POINTER));                
    1:                 iid = &NS_GET_IID(nsISupports);
    1:                 break;
    1:             case 'v':
    1:                 type = nsXPTType((uint8)(TD_INTERFACE_TYPE | XPT_TDP_POINTER));                
    1:                 iid = &NS_GET_IID(nsIVariant);
    1:                 break;
    1:             case 's':
    1:                 type = nsXPTType((uint8)(TD_DOMSTRING | XPT_TDP_POINTER));                
    1:                 iid = nsnull;
    1:                 p = va_arg(ap, void *);
    1:                 break;
    1:             default:
    1:                 NS_ERROR("bad format!");
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         if(!XPCConvert::JSData2Native(ccx, &p, vp[0], type, JS_FALSE,
    1:                                       iid, nsnull))
    1:             return JS_FALSE;
    1:         
    1:         if(which != 's')
    1:             *va_arg(ap, void **) = p;
    1:     }
    1:     else
    1:     {
    1:         switch(which)
    1:         {
    1:             case 'p':
    1:                 type = nsXPTType((uint8)(TD_INTERFACE_TYPE | XPT_TDP_POINTER));                
    1:                 iid  = va_arg(ap, const nsIID*);
    1:                 break;
    1:             case 'v':
    1:                 type = nsXPTType((uint8)(TD_INTERFACE_TYPE | XPT_TDP_POINTER));                
    1:                 iid = &NS_GET_IID(nsIVariant);
    1:                 break;
    1:             case 's':
    1:                 type = nsXPTType((uint8)(TD_DOMSTRING | XPT_TDP_POINTER));                
    1:                 iid = nsnull;
    1:                 break;
    1:             default:
    1:                 NS_ERROR("bad format!");
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         // NOTE: MUST be retrieved *after* the iid in the 'p' case above.
    1:         p = va_arg(ap, void *);
    1: 
    1:         if(!XPCConvert::NativeData2JS(ccx, &vp[0], &p, type, iid,
    1:                                       JS_GetGlobalObject(cx), nsnull))
    1:             return JS_FALSE;
    1:     }
    1:     *vpp = vp + 1;
    1:     VARARGS_ASSIGN(*app, ap);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: // array fun...
    1: 
    1: #ifdef POPULATE
    1: #undef POPULATE
    1: #endif
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::NativeArray2JS(XPCCallContext& ccx,
    1:                            jsval* d, const void** s,
    1:                            const nsXPTType& type, const nsID* iid,
    1:                            JSUint32 count, JSObject* scope,
    1:                            nsresult* pErr)
    1: {
    1:     NS_PRECONDITION(s, "bad param");
    1:     NS_PRECONDITION(d, "bad param");
    1: 
    1:     JSContext* cx = ccx.GetJSContext();
    1: 
    1:     // XXX add support for putting chars in a string rather than an array
    1: 
    1:     // XXX add support to indicate *which* array element was not convertable
    1: 
    1:     JSObject *array = JS_NewArrayObject(cx, count, nsnull);
    1: 
    1:     if(!array)
    1:         return JS_FALSE;
    1: 
    1:     // root this early
    1:     *d = OBJECT_TO_JSVAL(array);
    1:     AUTO_MARK_JSVAL(ccx, d);
    1: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_NATIVE;
    1: 
    1:     JSUint32 i;
    1:     jsval current = JSVAL_NULL;
    1:     AUTO_MARK_JSVAL(ccx, &current);
    1: 
    1: #define POPULATE(_t)                                                         \
    1:     PR_BEGIN_MACRO                                                           \
    1:         for(i = 0; i < count; i++)                                           \
    1:         {                                                                    \
    1:             if(!NativeData2JS(ccx, &current, ((_t*)*s)+i, type, iid,         \
    1:                               scope, pErr) ||                                \
    1:                !JS_SetElement(cx, array, i, &current))                       \
    1:                 goto failure;                                                \
    1:         }                                                                    \
    1:     PR_END_MACRO
    1: 
    1:     // XXX check IsPtr - esp. to handle array of nsID (as opposed to nsID*)
    1: 
    1:     switch(type.TagPart())
    1:     {
    1:     case nsXPTType::T_I8            : POPULATE(int8);           break;
    1:     case nsXPTType::T_I16           : POPULATE(int16);          break;
    1:     case nsXPTType::T_I32           : POPULATE(int32);          break;
    1:     case nsXPTType::T_I64           : POPULATE(int64);          break;
    1:     case nsXPTType::T_U8            : POPULATE(uint8);          break;
    1:     case nsXPTType::T_U16           : POPULATE(uint16);         break;
    1:     case nsXPTType::T_U32           : POPULATE(uint32);         break;
    1:     case nsXPTType::T_U64           : POPULATE(uint64);         break;
    1:     case nsXPTType::T_FLOAT         : POPULATE(float);          break;
    1:     case nsXPTType::T_DOUBLE        : POPULATE(double);         break;
    1:     case nsXPTType::T_BOOL          : POPULATE(PRBool);         break;
    1:     case nsXPTType::T_CHAR          : POPULATE(char);           break;
    1:     case nsXPTType::T_WCHAR         : POPULATE(jschar);         break;
    1:     case nsXPTType::T_VOID          : NS_ASSERTION(0,"bad type"); goto failure;
    1:     case nsXPTType::T_IID           : POPULATE(nsID*);          break;
    1:     case nsXPTType::T_DOMSTRING     : NS_ASSERTION(0,"bad type"); goto failure;
    1:     case nsXPTType::T_CHAR_STR      : POPULATE(char*);          break;
    1:     case nsXPTType::T_WCHAR_STR     : POPULATE(jschar*);        break;
    1:     case nsXPTType::T_INTERFACE     : POPULATE(nsISupports*);   break;
    1:     case nsXPTType::T_INTERFACE_IS  : POPULATE(nsISupports*);   break;
    1:     case nsXPTType::T_UTF8STRING    : NS_ASSERTION(0,"bad type"); goto failure;
    1:     case nsXPTType::T_CSTRING       : NS_ASSERTION(0,"bad type"); goto failure;
    1:     case nsXPTType::T_ASTRING       : NS_ASSERTION(0,"bad type"); goto failure;
    1:     default                         : NS_ASSERTION(0,"bad type"); goto failure;
    1:     }
    1: 
    1:     if(pErr)
    1:         *pErr = NS_OK;
    1:     return JS_TRUE;
    1: 
    1: failure:
    1:     return JS_FALSE;
    1: 
    1: #undef POPULATE
    1: }
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::JSArray2Native(XPCCallContext& ccx, void** d, jsval s,
    1:                            JSUint32 count, JSUint32 capacity,
    1:                            const nsXPTType& type,
    1:                            JSBool useAllocator, const nsID* iid,
    1:                            uintN* pErr)
    1: {
    1:     NS_PRECONDITION(d, "bad param");
    1: 
    1:     JSContext* cx = ccx.GetJSContext();
    1: 
    1:     // No Action, FRee memory, RElease object
    1:     enum CleanupMode {na, fr, re};
    1: 
    1:     CleanupMode cleanupMode;
    1: 
    1:     JSObject* jsarray = nsnull;
    1:     void* array = nsnull;
    1:     JSUint32 initedCount;
    1:     jsval current;
    1: 
    1:     // XXX add support for getting chars from strings
    1: 
    1:     // XXX add support to indicate *which* array element was not convertable
    1: 
    1:     if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:     {
    1:         if(0 != count)
    1:         {
    1:             if(pErr)
    1:                 *pErr = NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY;
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         // If a non-zero capacity was indicated then we build an
    1:         // empty array rather than return nsnull.
    1:         if(0 != capacity)
    1:             goto fill_array;
    1: 
    1:         *d = nsnull;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     if(!JSVAL_IS_OBJECT(s))
    1:     {
    1:         if(pErr)
    1:             *pErr = NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY;
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     jsarray = JSVAL_TO_OBJECT(s);
    1:     if(!JS_IsArrayObject(cx, jsarray))
    1:     {
    1:         if(pErr)
    1:             *pErr = NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY;
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     jsuint len;
    1:     if(!JS_GetArrayLength(cx, jsarray, &len) || len < count || capacity < count)
    1:     {
    1:         if(pErr)
    1:             *pErr = NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY;
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS;
    1: 
    1: #define POPULATE(_mode, _t)                                                  \
    1:     PR_BEGIN_MACRO                                                           \
    1:         cleanupMode = _mode;                                                 \
    1:         if (capacity > ~(size_t)0 / sizeof(_t) ||                            \
    1:             nsnull == (array = nsMemory::Alloc(capacity * sizeof(_t))))      \
    1:         {                                                                    \
    1:             if(pErr)                                                         \
    1:                 *pErr = NS_ERROR_OUT_OF_MEMORY;                              \
    1:             goto failure;                                                    \
    1:         }                                                                    \
    1:         for(initedCount = 0; initedCount < count; initedCount++)             \
    1:         {                                                                    \
    1:             if(!JS_GetElement(cx, jsarray, initedCount, &current) ||         \
    1:                !JSData2Native(ccx, ((_t*)array)+initedCount, current, type,  \
    1:                               useAllocator, iid, pErr))                      \
    1:                 goto failure;                                                \
    1:         }                                                                    \
    1:     PR_END_MACRO
    1: 
    1: 
    1:     // XXX check IsPtr - esp. to handle array of nsID (as opposed to nsID*)
    1: 
    1:     // XXX make extra space at end of char* and wchar* and null termintate
    1: 
    1: fill_array:
    1:     switch(type.TagPart())
    1:     {
    1:     case nsXPTType::T_I8            : POPULATE(na, int8);           break;
    1:     case nsXPTType::T_I16           : POPULATE(na, int16);          break;
    1:     case nsXPTType::T_I32           : POPULATE(na, int32);          break;
    1:     case nsXPTType::T_I64           : POPULATE(na, int64);          break;
    1:     case nsXPTType::T_U8            : POPULATE(na, uint8);          break;
    1:     case nsXPTType::T_U16           : POPULATE(na, uint16);         break;
    1:     case nsXPTType::T_U32           : POPULATE(na, uint32);         break;
    1:     case nsXPTType::T_U64           : POPULATE(na, uint64);         break;
    1:     case nsXPTType::T_FLOAT         : POPULATE(na, float);          break;
    1:     case nsXPTType::T_DOUBLE        : POPULATE(na, double);         break;
    1:     case nsXPTType::T_BOOL          : POPULATE(na, PRBool);         break;
    1:     case nsXPTType::T_CHAR          : POPULATE(na, char);           break;
    1:     case nsXPTType::T_WCHAR         : POPULATE(na, jschar);         break;
    1:     case nsXPTType::T_VOID          : NS_ASSERTION(0,"bad type"); goto failure;
    1:     case nsXPTType::T_IID           : POPULATE(fr, nsID*);          break;
    1:     case nsXPTType::T_DOMSTRING     : NS_ASSERTION(0,"bad type"); goto failure;
    1:     case nsXPTType::T_CHAR_STR      : POPULATE(fr, char*);          break;
    1:     case nsXPTType::T_WCHAR_STR     : POPULATE(fr, jschar*);        break;
    1:     case nsXPTType::T_INTERFACE     : POPULATE(re, nsISupports*);   break;
    1:     case nsXPTType::T_INTERFACE_IS  : POPULATE(re, nsISupports*);   break;
    1:     case nsXPTType::T_UTF8STRING    : NS_ASSERTION(0,"bad type"); goto failure;
    1:     case nsXPTType::T_CSTRING       : NS_ASSERTION(0,"bad type"); goto failure;
    1:     case nsXPTType::T_ASTRING       : NS_ASSERTION(0,"bad type"); goto failure;
    1:     default                         : NS_ASSERTION(0,"bad type"); goto failure;
    1:     }
    1: 
    1:     *d = array;
    1:     if(pErr)
    1:         *pErr = NS_OK;
    1:     return JS_TRUE;
    1: 
    1: failure:
    1:     // we may need to cleanup the partially filled array of converted stuff
    1:     if(array)
    1:     {
    1:         if(cleanupMode == re)
    1:         {
    1:             nsISupports** a = (nsISupports**) array;
    1:             for(PRUint32 i = 0; i < initedCount; i++)
    1:             {
    1:                 nsISupports* p = a[i];
    1:                 NS_IF_RELEASE(p);
    1:             }
    1:         }
    1:         else if(cleanupMode == fr && useAllocator)
    1:         {
    1:             void** a = (void**) array;
    1:             for(PRUint32 i = 0; i < initedCount; i++)
    1:             {
    1:                 void* p = a[i];
    1:                 if(p) nsMemory::Free(p);
    1:             }
    1:         }
    1:         nsMemory::Free(array);
    1:     }
    1: 
    1:     return JS_FALSE;
    1: 
    1: #undef POPULATE
    1: }
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::NativeStringWithSize2JS(XPCCallContext& ccx,
    1:                                     jsval* d, const void* s,
    1:                                     const nsXPTType& type,
    1:                                     JSUint32 count,
    1:                                     nsresult* pErr)
    1: {
    1:     NS_PRECONDITION(s, "bad param");
    1:     NS_PRECONDITION(d, "bad param");
    1: 
    1:     JSContext* cx = ccx.GetJSContext();
    1: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_NATIVE;
    1: 
    1:     if(!type.IsPointer())
    1:     {
    1:         XPC_LOG_ERROR(("XPCConvert::NativeStringWithSize2JS : unsupported type"));
    1:         return JS_FALSE;
    1:     }
    1:     switch(type.TagPart())
    1:     {
    1:         case nsXPTType::T_PSTRING_SIZE_IS:
    1:         {
    1:             char* p = *((char**)s);
    1:             if(!p)
    1:                 break;
    1:             JSString* str;
    1:             if(!(str = JS_NewStringCopyN(cx, p, count)))
    1:                 return JS_FALSE;
    1:             *d = STRING_TO_JSVAL(str);
    1:             break;
    1:         }
    1:         case nsXPTType::T_PWSTRING_SIZE_IS:
    1:         {
    1:             jschar* p = *((jschar**)s);
    1:             if(!p)
    1:                 break;
    1:             JSString* str;
    1:             if(!(str = JS_NewUCStringCopyN(cx, p, count)))
    1:                 return JS_FALSE;
    1:             *d = STRING_TO_JSVAL(str);
    1:             break;
    1:         }
    1:         default:
    1:             XPC_LOG_ERROR(("XPCConvert::NativeStringWithSize2JS : unsupported type"));
    1:             return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::JSStringWithSize2Native(XPCCallContext& ccx, void* d, jsval s,
    1:                                     JSUint32 count, JSUint32 capacity,
    1:                                     const nsXPTType& type,
    1:                                     JSBool useAllocator,
    1:                                     uintN* pErr)
    1: {
    1:     NS_PRECONDITION(s, "bad param");
    1:     NS_PRECONDITION(d, "bad param");
    1: 
    1:     JSContext* cx = ccx.GetJSContext();
    1: 
    1:     JSUint32 len;
    1: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_NATIVE;
    1: 
    1:     if(capacity < count)
    1:     {
    1:         if(pErr)
    1:             *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     if(!type.IsPointer())
    1:     {
    1:         XPC_LOG_ERROR(("XPCConvert::JSStringWithSize2Native : unsupported type"));
    1:         return JS_FALSE;
    1:     }
    1:     switch(type.TagPart())
    1:     {
    1:         case nsXPTType::T_PSTRING_SIZE_IS:
    1:         {
    1:             char* bytes=nsnull;
    1:             JSString* str;
    1: 
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(0 != count)
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
    1:                     return JS_FALSE;
    1:                 }
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1: 
    1:                 if(useAllocator && 0 != capacity)
    1:                 {
    1:                     len = (capacity + 1) * sizeof(char);
    1:                     if(!(*((void**)d) = nsMemory::Alloc(len)))
    1:                         return JS_FALSE;
    1:                     return JS_TRUE;
    1:                 }
    1:                 // else ...
    1: 
    1:                 *((char**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             if(!(str = JS_ValueToString(cx, s))||
    1:                !(bytes = JS_GetStringBytes(str)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             len = JS_GetStringLength(str);
    1:             if(len > count)
    1:             {
    1:                 if(pErr)
    1:                     *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             if(len < capacity)
    1:                 len = capacity;
    1: 
    1:             if(useAllocator)
    1:             {
    1:                 JSUint32 alloc_len = (len + 1) * sizeof(char);
    1:                 if(!(*((void**)d) = nsMemory::Alloc(alloc_len)))
    1:                 {
    1:                     return JS_FALSE;
    1:                 }
    1:                 memcpy(*((char**)d), bytes, count);
    1:                 (*((char**)d))[count] = 0;
    1:             }
    1:             else
    1:                 *((char**)d) = bytes;
    1: 
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_PWSTRING_SIZE_IS:
    1:         {
    1:             jschar* chars=nsnull;
    1:             JSString* str;
    1: 
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(0 != count)
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
    1:                     return JS_FALSE;
    1:                 }
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1: 
    1:                 if(useAllocator && 0 != capacity)
    1:                 {
    1:                     len = (capacity + 1) * sizeof(jschar);
    1:                     if(!(*((void**)d) = nsMemory::Alloc(len)))
    1:                         return JS_FALSE;
    1:                     return JS_TRUE;
    1:                 }
    1: 
    1:                 // else ...
    1:                 *((jschar**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             if(!(str = JS_ValueToString(cx, s))||
    1:                !(chars = JS_GetStringChars(str)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             len = JS_GetStringLength(str);
    1:             if(len > count)
    1:             {
    1:                 if(pErr)
    1:                     *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
    1:                 return JS_FALSE;
    1:             }
    1:             if(len < capacity)
    1:                 len = capacity;
    1: 
    1:             if(useAllocator)
    1:             {
    1:                 JSUint32 alloc_len = (len + 1) * sizeof(jschar);
    1:                 if(!(*((void**)d) = nsMemory::Alloc(alloc_len)))
    1:                 {
    1:                     // XXX should report error
    1:                     return JS_FALSE;
    1:                 }
    1:                 memcpy(*((jschar**)d), chars, alloc_len);
    1:                 (*((jschar**)d))[count] = 0;
    1:             }
    1:             else
    1:                 *((jschar**)d) = chars;
    1: 
    1:             return JS_TRUE;
    1:         }
    1:         default:
    1:             XPC_LOG_ERROR(("XPCConvert::JSStringWithSize2Native : unsupported type"));
    1:             return JS_FALSE;
    1:     }
    1: }
    1: 
