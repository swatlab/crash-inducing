    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Steve Clark <buster@netscape.com>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   L. David Baron <dbaron@dbaron.org>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   IBM Corporation
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* state and methods used while laying out a single line of a block frame */
    1: 
    1: #define PL_ARENA_CONST_ALIGN_MASK (sizeof(void*)-1)
    1: #include "plarena.h"
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsLineLayout.h"
    1: #include "nsBlockFrame.h"
    1: #include "nsInlineFrame.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsSpaceManager.h"
    1: #include "nsStyleContext.h"
    1: #include "nsPresContext.h"
    1: #include "nsIFontMetrics.h"
12989: #include "nsIThebesFontMetrics.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsPlaceholderFrame.h"
    1: #include "nsIDocument.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIContent.h"
    1: #include "nsTextFragment.h"
    1: #include "nsBidiUtils.h"
    1: #include "nsLayoutUtils.h"
 6247: #include "nsTextFrame.h"
11780: #include "nsCSSRendering.h"
    1: 
    1: #ifdef DEBUG
    1: #undef  NOISY_HORIZONTAL_ALIGN
    1: #undef  NOISY_VERTICAL_ALIGN
    1: #undef  REALLY_NOISY_VERTICAL_ALIGN
    1: #undef  NOISY_REFLOW
    1: #undef  REALLY_NOISY_REFLOW
    1: #undef  NOISY_PUSHING
    1: #undef  REALLY_NOISY_PUSHING
    1: #undef  DEBUG_ADD_TEXT
    1: #undef  NOISY_MAX_ELEMENT_SIZE
    1: #undef  REALLY_NOISY_MAX_ELEMENT_SIZE
    1: #undef  NOISY_CAN_PLACE_FRAME
    1: #undef  NOISY_TRIM
    1: #undef  REALLY_NOISY_TRIM
    1: #endif
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: #define FIX_BUG_50257
    1: 
    1: #define PLACED_LEFT  0x1
    1: #define PLACED_RIGHT 0x2
    1: 
    1: nsLineLayout::nsLineLayout(nsPresContext* aPresContext,
    1:                            nsSpaceManager* aSpaceManager,
    1:                            const nsHTMLReflowState* aOuterReflowState,
    1:                            const nsLineList::iterator* aLine)
    1:   : mPresContext(aPresContext),
    1:     mSpaceManager(aSpaceManager),
    1:     mBlockReflowState(aOuterReflowState),
    1:     mLastOptionalBreakContent(nsnull),
    1:     mForceBreakContent(nsnull),
    1:     mLastOptionalBreakContentOffset(-1),
    1:     mForceBreakContentOffset(-1),
16166:     mLastOptionalBreakPriority(eNoBreak),
    1:     mBlockRS(nsnull),/* XXX temporary */
    1:     mMinLineHeight(0),
    1:     mTextIndent(0)
    1: {
    1:   NS_ASSERTION(aSpaceManager || aOuterReflowState->frame->GetType() ==
    1:                                   nsGkAtoms::letterFrame,
    1:                "space manager should be present");
    1:   MOZ_COUNT_CTOR(nsLineLayout);
    1: 
    1:   // Stash away some style data that we need
    1:   mStyleText = aOuterReflowState->frame->GetStyleText();
    1:   mTextAlign = mStyleText->mTextAlign;
    1:   mLineNumber = 0;
    1:   mFlags = 0; // default all flags to false except those that follow here...
    1:   mPlacedFloats = 0;
    1:   mTotalPlacedFrames = 0;
    1:   mTopEdge = 0;
 7069:   mTrimmableWidth = 0;
    1: 
    1:   // Instead of always pre-initializing the free-lists for frames and
    1:   // spans, we do it on demand so that situations that only use a few
    1:   // frames and spans won't waste a lot of time in unneeded
    1:   // initialization.
    1:   PL_INIT_ARENA_POOL(&mArena, "nsLineLayout", 1024);
    1:   mFrameFreeList = nsnull;
    1:   mSpanFreeList = nsnull;
    1: 
    1:   mCurrentSpan = mRootSpan = nsnull;
    1:   mSpanDepth = 0;
    1: 
    1:   if (aLine) {
    1:     SetFlag(LL_GOTLINEBOX, PR_TRUE);
    1:     mLineBox = *aLine;
    1:   }
    1: }
    1: 
    1: nsLineLayout::~nsLineLayout()
    1: {
    1:   MOZ_COUNT_DTOR(nsLineLayout);
    1: 
    1:   NS_ASSERTION(nsnull == mRootSpan, "bad line-layout user");
    1: 
    1:   // PL_FreeArenaPool takes our memory and puts in on a global free list so
    1:   // that the next time an arena makes an allocation it will not have to go
    1:   // all the way down to malloc.  This is desirable as this class is created
    1:   // and destroyed in a tight loop.
    1:   //
    1:   // I looked at the code.  It is not technically necessary to call
    1:   // PL_FinishArenaPool() after PL_FreeArenaPool(), but from an API
    1:   // standpoint, I think we are susposed to.  It will be very fast anyway,
    1:   // since PL_FreeArenaPool() has done all the work.
    1:   PL_FreeArenaPool(&mArena);
    1:   PL_FinishArenaPool(&mArena);
    1: }
    1: 
    1: // Find out if the frame has a non-null prev-in-flow, i.e., whether it
    1: // is a continuation.
    1: inline PRBool
    1: HasPrevInFlow(nsIFrame *aFrame)
    1: {
    1:   nsIFrame *prevInFlow = aFrame->GetPrevInFlow();
    1:   return prevInFlow != nsnull;
    1: }
    1: 
    1: void
    1: nsLineLayout::BeginLineReflow(nscoord aX, nscoord aY,
    1:                               nscoord aWidth, nscoord aHeight,
    1:                               PRBool aImpactedByFloats,
    1:                               PRBool aIsTopOfPage)
    1: {
    1:   NS_ASSERTION(nsnull == mRootSpan, "bad linelayout user");
 8982:   NS_ASSERTION(aWidth != NS_UNCONSTRAINEDSIZE,
 8982:                "should no longer be using unconstrained widths");
    1: #ifdef DEBUG
    1:   if ((aWidth != NS_UNCONSTRAINEDSIZE) && CRAZY_WIDTH(aWidth)) {
    1:     NS_NOTREACHED("bad width");
    1:     nsFrame::ListTag(stdout, mBlockReflowState->frame);
    1:     printf(": Init: bad caller: width WAS %d(0x%x)\n",
    1:            aWidth, aWidth);
    1:   }
    1:   if ((aHeight != NS_UNCONSTRAINEDSIZE) && CRAZY_HEIGHT(aHeight)) {
    1:     NS_NOTREACHED("bad height");
    1:     nsFrame::ListTag(stdout, mBlockReflowState->frame);
    1:     printf(": Init: bad caller: height WAS %d(0x%x)\n",
    1:            aHeight, aHeight);
    1:   }
    1: #endif
    1: #ifdef NOISY_REFLOW
    1:   nsFrame::ListTag(stdout, mBlockReflowState->frame);
    1:   printf(": BeginLineReflow: %d,%d,%d,%d impacted=%s %s\n",
    1:          aX, aY, aWidth, aHeight,
    1:          aImpactedByFloats?"true":"false",
    1:          aIsTopOfPage ? "top-of-page" : "");
    1: #endif
    1: #ifdef DEBUG
    1:   mSpansAllocated = mSpansFreed = mFramesAllocated = mFramesFreed = 0;
    1: #endif
    1: 
    1:   SetFlag(LL_FIRSTLETTERSTYLEOK, PR_FALSE);
    1:   SetFlag(LL_ISTOPOFPAGE, aIsTopOfPage);
    1:   mPlacedFloats = 0;
    1:   SetFlag(LL_IMPACTEDBYFLOATS, aImpactedByFloats);
    1:   mTotalPlacedFrames = 0;
15350:   SetFlag(LL_LINEISEMPTY, PR_TRUE);
    1:   SetFlag(LL_LINEENDSINBR, PR_FALSE);
    1:   mSpanDepth = 0;
    1:   mMaxTopBoxHeight = mMaxBottomBoxHeight = 0;
    1: 
    1:   PerSpanData* psd;
    1:   NewPerSpanData(&psd);
    1:   mCurrentSpan = mRootSpan = psd;
    1:   psd->mReflowState = mBlockReflowState;
    1:   psd->mLeftEdge = aX;
    1:   psd->mX = aX;
    1:   psd->mRightEdge = aX + aWidth;
    1: 
    1:   mTopEdge = aY;
    1: 
    1:   psd->mNoWrap = !mStyleText->WhiteSpaceCanWrap();
    1:   psd->mDirection = mBlockReflowState->mStyleVisibility->mDirection;
    1:   psd->mChangedFrameDirection = PR_FALSE;
    1: 
    1:   // If this is the first line of a block then see if the text-indent
    1:   // property amounts to anything.
    1: 
    1:   if (0 == mLineNumber && !HasPrevInFlow(mBlockReflowState->frame)) {
    1:     nscoord indent = 0;
    1:     nsStyleUnit unit = mStyleText->mTextIndent.GetUnit();
    1:     if (eStyleUnit_Coord == unit) {
    1:       indent = mStyleText->mTextIndent.GetCoordValue();
    1:     }
    1:     else if (eStyleUnit_Percent == unit) {
    1:       nscoord width =
    1:         nsHTMLReflowState::GetContainingBlockContentWidth(mBlockReflowState);
    1:       if ((0 != width) && (NS_UNCONSTRAINEDSIZE != width)) {
    1:         indent = nscoord(mStyleText->mTextIndent.GetPercentValue() * width);
    1:       }
 1993:       if (GetFlag(LL_GOTLINEBOX)) {
 1668:         mLineBox->DisableResizeReflowOptimization();
    1:       }
 1993:     }
    1: 
    1:     mTextIndent = indent;
    1: 
    1:     if (NS_STYLE_DIRECTION_RTL == psd->mDirection) {
    1:       psd->mRightEdge -= indent;
    1:     }
    1:     else {
    1:       psd->mX += indent;
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsLineLayout::EndLineReflow()
    1: {
    1: #ifdef NOISY_REFLOW
    1:   nsFrame::ListTag(stdout, mBlockReflowState->frame);
    1:   printf(": EndLineReflow: width=%d\n", mRootSpan->mX - mRootSpan->mLeftEdge);
    1: #endif
    1: 
    1:   FreeSpan(mRootSpan);
    1:   mCurrentSpan = mRootSpan = nsnull;
    1: 
    1:   NS_ASSERTION(mSpansAllocated == mSpansFreed, "leak");
    1:   NS_ASSERTION(mFramesAllocated == mFramesFreed, "leak");
    1: 
    1: #if 0
    1:   static PRInt32 maxSpansAllocated = NS_LINELAYOUT_NUM_SPANS;
    1:   static PRInt32 maxFramesAllocated = NS_LINELAYOUT_NUM_FRAMES;
    1:   if (mSpansAllocated > maxSpansAllocated) {
    1:     printf("XXX: saw a line with %d spans\n", mSpansAllocated);
    1:     maxSpansAllocated = mSpansAllocated;
    1:   }
    1:   if (mFramesAllocated > maxFramesAllocated) {
    1:     printf("XXX: saw a line with %d frames\n", mFramesAllocated);
    1:     maxFramesAllocated = mFramesAllocated;
    1:   }
    1: #endif
    1: }
    1: 
    1: // XXX swtich to a single mAvailLineWidth that we adjust as each frame
    1: // on the line is placed. Each span can still have a per-span mX that
    1: // tracks where a child frame is going in its span; they don't need a
    1: // per-span mLeftEdge?
    1: 
    1: void
15299: nsLineLayout::UpdateBand(const nsRect& aNewAvailSpace,
    1:                          PRBool aPlacedLeftFloat,
    1:                          nsIFrame* aFloatFrame)
    1: {
    1: #ifdef REALLY_NOISY_REFLOW
    1:   printf("nsLL::UpdateBand %d, %d, %d, %d, frame=%p placedLeft=%s\n  will set mImpacted to PR_TRUE\n",
15299:          aNewAvailSpace.x, aNewAvailSpace.y,
15299:          aNewAvailSpace.width, aNewAvailSpace.height,
15299:          aFloatFrame, aPlacedLeftFloat?"true":"false");
    1: #endif
    1: #ifdef DEBUG
15299:   if ((aNewAvailSpace.width != NS_UNCONSTRAINEDSIZE) && CRAZY_WIDTH(aNewAvailSpace.width)) {
    1:     nsFrame::ListTag(stdout, mBlockReflowState->frame);
    1:     printf(": UpdateBand: bad caller: width WAS %d(0x%x)\n",
15299:            aNewAvailSpace.width, aNewAvailSpace.width);
    1:   }
15299:   if ((aNewAvailSpace.height != NS_UNCONSTRAINEDSIZE) && CRAZY_HEIGHT(aNewAvailSpace.height)) {
    1:     nsFrame::ListTag(stdout, mBlockReflowState->frame);
    1:     printf(": UpdateBand: bad caller: height WAS %d(0x%x)\n",
15299:            aNewAvailSpace.height, aNewAvailSpace.height);
    1:   }
    1: #endif
    1: 
    1:   // Compute the difference between last times width and the new width
15299:   NS_ASSERTION(mRootSpan->mRightEdge != NS_UNCONSTRAINEDSIZE &&
15299:                aNewAvailSpace.width != NS_UNCONSTRAINEDSIZE,
 8982:                "shouldn't use unconstrained widths anymore");
15299:   // The root span's mLeftEdge moves to aX
15299:   nscoord deltaX = aNewAvailSpace.x - mRootSpan->mLeftEdge;
15299:   // The width of all spans changes by this much (the root span's
15299:   // mRightEdge moves to aX + aWidth, its new width is aWidth)
15299:   nscoord deltaWidth = aNewAvailSpace.width - (mRootSpan->mRightEdge - mRootSpan->mLeftEdge);
    1: #ifdef NOISY_REFLOW
    1:   nsFrame::ListTag(stdout, mBlockReflowState->frame);
15299:   printf(": UpdateBand: %d,%d,%d,%d deltaWidth=%d deltaX=%d %s float\n",
15299:          aNewAvailSpace.x, aNewAvailSpace.y,
15299:          aNewAvailSpace.width, aNewAvailSpace.height, deltaWidth, deltaX,
    1:          aPlacedLeftFloat ? "left" : "right");
    1: #endif
    1: 
15299:   // Update the root span position
15299:   mRootSpan->mLeftEdge += deltaX;
15299:   mRootSpan->mRightEdge += deltaX;
15299:   mRootSpan->mX += deltaX;
15299: 
15299:   // Now update the right edges of the open spans to account for any
15299:   // change in available space width
15299:   for (PerSpanData* psd = mCurrentSpan; psd; psd = psd->mParent) {
15299:     psd->mRightEdge += deltaWidth;
15299:     psd->mContainsFloat = PR_TRUE;
16579:     NS_ASSERTION(psd->mX - mTrimmableWidth <= psd->mRightEdge,
15299:                  "We placed a float where there was no room!");
15299: #ifdef NOISY_REFLOW
15299:     printf("  span %p: oldRightEdge=%d newRightEdge=%d\n",
15299:            psd, psd->mRightEdge - deltaRightEdge, psd->mRightEdge);
15299: #endif
15299:   }
15299:   NS_ASSERTION(mRootSpan->mContainsFloat &&
15299:                mRootSpan->mLeftEdge == aNewAvailSpace.x &&
15299:                mRootSpan->mRightEdge == aNewAvailSpace.XMost(),
15299:                "root span was updated incorrectly?");
15299: 
15299:   // Update frame bounds
15299:   // Note: Only adjust the outermost frames (the ones that are direct
15299:   // children of the block), not the ones in the child spans. The reason
15299:   // is simple: the frames in the spans have coordinates local to their
15299:   // parent therefore they are moved when their parent span is moved.
15299:   if (deltaX != 0) {
15299:     for (PerFrameData* pfd = mRootSpan->mFirstFrame; pfd; pfd = pfd->mNext) {
15299:       pfd->mBounds.x += deltaX;
15299:     }
15299:   }
15299: 
15299:   mTopEdge = aNewAvailSpace.y;
    1:   mPlacedFloats |= (aPlacedLeftFloat ? PLACED_LEFT : PLACED_RIGHT);
    1:   SetFlag(LL_IMPACTEDBYFLOATS, PR_TRUE);
    1: 
    1:   SetFlag(LL_LASTFLOATWASLETTERFRAME,
    1:           nsGkAtoms::letterFrame == aFloatFrame->GetType());
    1: }
    1: 
    1: nsresult
    1: nsLineLayout::NewPerSpanData(PerSpanData** aResult)
    1: {
    1:   PerSpanData* psd = mSpanFreeList;
    1:   if (nsnull == psd) {
    1:     void *mem;
    1:     PL_ARENA_ALLOCATE(mem, &mArena, sizeof(PerSpanData));
    1:     if (nsnull == mem) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
 3233:     psd = reinterpret_cast<PerSpanData*>(mem);
    1:   }
    1:   else {
    1:     mSpanFreeList = psd->mNextFreeSpan;
    1:   }
    1:   psd->mParent = nsnull;
    1:   psd->mFrame = nsnull;
    1:   psd->mFirstFrame = nsnull;
    1:   psd->mLastFrame = nsnull;
    1:   psd->mContainsFloat = PR_FALSE;
    1:   psd->mZeroEffectiveSpanBox = PR_FALSE;
11711:   psd->mHasNonemptyContent = PR_FALSE;
    1: 
    1: #ifdef DEBUG
    1:   mSpansAllocated++;
    1: #endif
    1:   *aResult = psd;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsLineLayout::BeginSpan(nsIFrame* aFrame,
    1:                         const nsHTMLReflowState* aSpanReflowState,
    1:                         nscoord aLeftEdge,
    1:                         nscoord aRightEdge)
    1: {
 8982:   NS_ASSERTION(aRightEdge != NS_UNCONSTRAINEDSIZE,
 8982:                "should no longer be using unconstrained sizes");
    1: #ifdef NOISY_REFLOW
    1:   nsFrame::IndentBy(stdout, mSpanDepth+1);
    1:   nsFrame::ListTag(stdout, aFrame);
    1:   printf(": BeginSpan leftEdge=%d rightEdge=%d\n", aLeftEdge, aRightEdge);
    1: #endif
    1: 
    1:   PerSpanData* psd;
    1:   nsresult rv = NewPerSpanData(&psd);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // Link up span frame's pfd to point to its child span data
    1:     PerFrameData* pfd = mCurrentSpan->mLastFrame;
    1:     NS_ASSERTION(pfd->mFrame == aFrame, "huh?");
    1:     pfd->mSpan = psd;
    1: 
    1:     // Init new span
    1:     psd->mFrame = pfd;
    1:     psd->mParent = mCurrentSpan;
    1:     psd->mReflowState = aSpanReflowState;
    1:     psd->mLeftEdge = aLeftEdge;
    1:     psd->mX = aLeftEdge;
    1:     psd->mRightEdge = aRightEdge;
    1: 
    1:     psd->mNoWrap =
    1:       !aSpanReflowState->frame->GetStyleText()->WhiteSpaceCanWrap();
    1:     psd->mDirection = aSpanReflowState->mStyleVisibility->mDirection;
    1:     psd->mChangedFrameDirection = PR_FALSE;
    1: 
    1:     // Switch to new span
    1:     mCurrentSpan = psd;
    1:     mSpanDepth++;
    1:   }
    1:   return rv;
    1: }
    1: 
 8983: nscoord
 8983: nsLineLayout::EndSpan(nsIFrame* aFrame)
    1: {
    1:   NS_ASSERTION(mSpanDepth > 0, "end-span without begin-span");
    1: #ifdef NOISY_REFLOW
    1:   nsFrame::IndentBy(stdout, mSpanDepth);
    1:   nsFrame::ListTag(stdout, aFrame);
    1:   printf(": EndSpan width=%d\n", mCurrentSpan->mX - mCurrentSpan->mLeftEdge);
    1: #endif
    1:   PerSpanData* psd = mCurrentSpan;
 8983:   nscoord widthResult = psd->mLastFrame ? (psd->mX - psd->mLeftEdge) : 0;
    1: 
    1:   mSpanDepth--;
    1:   mCurrentSpan->mReflowState = nsnull;  // no longer valid so null it out!
    1:   mCurrentSpan = mCurrentSpan->mParent;
 8983:   return widthResult;
    1: }
    1: 
    1: PRInt32
    1: nsLineLayout::GetCurrentSpanCount() const
    1: {
    1:   NS_ASSERTION(mCurrentSpan == mRootSpan, "bad linelayout user");
    1:   PRInt32 count = 0;
    1:   PerFrameData* pfd = mRootSpan->mFirstFrame;
    1:   while (nsnull != pfd) {
    1:     count++;
    1:     pfd = pfd->mNext;
    1:   }
    1:   return count;
    1: }
    1: 
    1: void
    1: nsLineLayout::SplitLineTo(PRInt32 aNewCount)
    1: {
    1:   NS_ASSERTION(mCurrentSpan == mRootSpan, "bad linelayout user");
    1: 
    1: #ifdef REALLY_NOISY_PUSHING
    1:   printf("SplitLineTo %d (current count=%d); before:\n", aNewCount,
    1:          GetCurrentSpanCount());
    1:   DumpPerSpanData(mRootSpan, 1);
    1: #endif
    1:   PerSpanData* psd = mRootSpan;
    1:   PerFrameData* pfd = psd->mFirstFrame;
    1:   while (nsnull != pfd) {
    1:     if (--aNewCount == 0) {
    1:       // Truncate list at pfd (we keep pfd, but anything following is freed)
    1:       PerFrameData* next = pfd->mNext;
    1:       pfd->mNext = nsnull;
    1:       psd->mLastFrame = pfd;
    1: 
    1:       // Now release all of the frames following pfd
    1:       pfd = next;
    1:       while (nsnull != pfd) {
    1:         next = pfd->mNext;
    1:         pfd->mNext = mFrameFreeList;
    1:         mFrameFreeList = pfd;
    1: #ifdef DEBUG
    1:         mFramesFreed++;
    1: #endif
    1:         if (nsnull != pfd->mSpan) {
    1:           FreeSpan(pfd->mSpan);
    1:         }
    1:         pfd = next;
    1:       }
    1:       break;
    1:     }
    1:     pfd = pfd->mNext;
    1:   }
    1: #ifdef NOISY_PUSHING
    1:   printf("SplitLineTo %d (current count=%d); after:\n", aNewCount,
    1:          GetCurrentSpanCount());
    1:   DumpPerSpanData(mRootSpan, 1);
    1: #endif
    1: }
    1: 
    1: void
    1: nsLineLayout::PushFrame(nsIFrame* aFrame)
    1: {
    1:   PerSpanData* psd = mCurrentSpan;
    1:   NS_ASSERTION(psd->mLastFrame->mFrame == aFrame, "pushing non-last frame");
    1: 
    1: #ifdef REALLY_NOISY_PUSHING
    1:   nsFrame::IndentBy(stdout, mSpanDepth);
    1:   printf("PushFrame %p, before:\n", psd);
    1:   DumpPerSpanData(psd, 1);
    1: #endif
    1: 
    1:   // Take the last frame off of the span's frame list
    1:   PerFrameData* pfd = psd->mLastFrame;
    1:   if (pfd == psd->mFirstFrame) {
    1:     // We are pushing away the only frame...empty the list
    1:     psd->mFirstFrame = nsnull;
    1:     psd->mLastFrame = nsnull;
    1:   }
    1:   else {
    1:     PerFrameData* prevFrame = pfd->mPrev;
    1:     prevFrame->mNext = nsnull;
    1:     psd->mLastFrame = prevFrame;
    1:   }
    1: 
    1:   // Now free it, and if it has a span, free that too
    1:   pfd->mNext = mFrameFreeList;
    1:   mFrameFreeList = pfd;
    1: #ifdef DEBUG
    1:   mFramesFreed++;
    1: #endif
    1:   if (nsnull != pfd->mSpan) {
    1:     FreeSpan(pfd->mSpan);
    1:   }
    1: #ifdef NOISY_PUSHING
    1:   nsFrame::IndentBy(stdout, mSpanDepth);
    1:   printf("PushFrame: %p after:\n", psd);
    1:   DumpPerSpanData(psd, 1);
    1: #endif
    1: }
    1: 
    1: void
    1: nsLineLayout::FreeSpan(PerSpanData* psd)
    1: {
    1:   // Free its frames
    1:   PerFrameData* pfd = psd->mFirstFrame;
    1:   while (nsnull != pfd) {
    1:     if (nsnull != pfd->mSpan) {
    1:       FreeSpan(pfd->mSpan);
    1:     }
    1:     PerFrameData* next = pfd->mNext;
    1:     pfd->mNext = mFrameFreeList;
    1:     mFrameFreeList = pfd;
    1: #ifdef DEBUG
    1:     mFramesFreed++;
    1: #endif
    1:     pfd = next;
    1:   }
    1: 
    1:   // Now put the span on the free list since it's free too
    1:   psd->mNextFreeSpan = mSpanFreeList;
    1:   mSpanFreeList = psd;
    1: #ifdef DEBUG
    1:   mSpansFreed++;
    1: #endif
    1: }
    1: 
    1: PRBool
    1: nsLineLayout::IsZeroHeight()
    1: {
    1:   PerSpanData* psd = mCurrentSpan;
    1:   PerFrameData* pfd = psd->mFirstFrame;
    1:   while (nsnull != pfd) {
    1:     if (0 != pfd->mBounds.height) {
    1:       return PR_FALSE;
    1:     }
    1:     pfd = pfd->mNext;
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsLineLayout::NewPerFrameData(PerFrameData** aResult)
    1: {
    1:   PerFrameData* pfd = mFrameFreeList;
    1:   if (nsnull == pfd) {
    1:     void *mem;
    1:     PL_ARENA_ALLOCATE(mem, &mArena, sizeof(PerFrameData));
    1:     if (nsnull == mem) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
 3233:     pfd = reinterpret_cast<PerFrameData*>(mem);
    1:   }
    1:   else {
    1:     mFrameFreeList = pfd->mNext;
    1:   }
    1:   pfd->mSpan = nsnull;
    1:   pfd->mNext = nsnull;
    1:   pfd->mPrev = nsnull;
    1:   pfd->mFrame = nsnull;
    1:   pfd->mFlags = 0;  // all flags default to false
    1: 
    1: #ifdef DEBUG
    1:   pfd->mVerticalAlign = 0xFF;
    1:   mFramesAllocated++;
    1: #endif
    1:   *aResult = pfd;
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsLineLayout::LineIsBreakable() const
    1: {
15350:   // XXX mTotalPlacedFrames should go away and we should just use
15350:   // LL_LINEISEMPTY here instead
    1:   if ((0 != mTotalPlacedFrames) || GetFlag(LL_IMPACTEDBYFLOATS)) {
    1:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: // Checks all four sides for percentage units.  This means it should
    1: // only be used for things (margin, padding) where percentages on top
    1: // and bottom depend on the *width* just like percentages on left and
    1: // right.
    1: static PRBool
    1: HasPercentageUnitSide(const nsStyleSides& aSides)
    1: {
    1:   NS_FOR_CSS_SIDES(side) {
    1:     if (eStyleUnit_Percent == aSides.GetUnit(side))
    1:       return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
 1068: inline PRBool
 1068: WidthDependsOnContainer(const nsStyleCoord& aCoord)
 1068: {
 1068:   return aCoord.GetUnit() == eStyleUnit_Percent ||
 1068:          (aCoord.GetUnit() == eStyleUnit_Enumerated &&
 8046:           (aCoord.GetIntValue() == NS_STYLE_WIDTH_AVAILABLE ||
 8046:            aCoord.GetIntValue() == NS_STYLE_WIDTH_FIT_CONTENT));
 1068: 
 1068: }
 1068: 
    1: static PRBool
    1: IsPercentageAware(const nsIFrame* aFrame)
    1: {
    1:   NS_ASSERTION(aFrame, "null frame is not allowed");
    1: 
    1:   nsIAtom *fType = aFrame->GetType();
    1:   if (fType == nsGkAtoms::textFrame) {
    1:     // None of these things can ever be true for text frames.
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // Some of these things don't apply to non-replaced inline frames
    1:   // (that is, fType == nsGkAtoms::inlineFrame || fType ==
    1:   // nsGkAtoms::positionedInlineFrame), but we won't bother making
    1:   // things unnecessarily complicated, since they'll probably be set
    1:   // quite rarely.
    1: 
    1:   const nsStyleMargin* margin = aFrame->GetStyleMargin();
    1:   if (HasPercentageUnitSide(margin->mMargin)) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   const nsStylePadding* padding = aFrame->GetStylePadding();
    1:   if (HasPercentageUnitSide(padding->mPadding)) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // Note that borders can't be aware of percentages
    1: 
    1:   const nsStylePosition* pos = aFrame->GetStylePosition();
    1: 
 1068:   if (WidthDependsOnContainer(pos->mWidth) ||
 1068:       WidthDependsOnContainer(pos->mMaxWidth) ||
 1068:       WidthDependsOnContainer(pos->mMinWidth) ||
    1:       eStyleUnit_Percent == pos->mOffset.GetRightUnit() ||
    1:       eStyleUnit_Percent == pos->mOffset.GetLeftUnit()) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   if (eStyleUnit_Auto == pos->mWidth.GetUnit()) {
    1:     // We need to check for frames that shrink-wrap when they're auto
    1:     // width.
    1:     const nsStyleDisplay* disp = aFrame->GetStyleDisplay();
    1:     if (disp->mDisplay == NS_STYLE_DISPLAY_INLINE_BLOCK ||
    1:         disp->mDisplay == NS_STYLE_DISPLAY_INLINE_TABLE ||
    1:         fType == nsGkAtoms::HTMLButtonControlFrame ||
    1:         fType == nsGkAtoms::gfxButtonControlFrame ||
    1:         fType == nsGkAtoms::fieldSetFrame ||
    1:         fType == nsGkAtoms::comboboxDisplayFrame) {
    1:       return PR_TRUE;
    1:     }
 8142: 
 8142:     // Handle SVG, which doesn't map width/height into style
 8265:     if ((
 8265: #ifdef MOZ_SVG
 8265:          fType == nsGkAtoms::svgOuterSVGFrame ||
 8265: #endif
 8142:          fType == nsGkAtoms::subDocumentFrame) &&
 8142:         const_cast<nsIFrame*>(aFrame)->GetIntrinsicSize().width.GetUnit() ==
 8142:         eStyleUnit_Percent) {
 8142:       return PR_TRUE;
 8142:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsLineLayout::ReflowFrame(nsIFrame* aFrame,
    1:                           nsReflowStatus& aReflowStatus,
    1:                           nsHTMLReflowMetrics* aMetrics,
    1:                           PRBool& aPushedFrame)
    1: {
    1:   // Initialize OUT parameter
    1:   aPushedFrame = PR_FALSE;
    1: 
    1:   PerFrameData* pfd;
    1:   nsresult rv = NewPerFrameData(&pfd);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   PerSpanData* psd = mCurrentSpan;
    1:   psd->AppendFrame(pfd);
    1: 
    1: #ifdef REALLY_NOISY_REFLOW
    1:   nsFrame::IndentBy(stdout, mSpanDepth);
    1:   printf("%p: Begin ReflowFrame pfd=%p ", psd, pfd);
    1:   nsFrame::ListTag(stdout, aFrame);
    1:   printf("\n");
    1: #endif
    1: 
    1:   // See if this frame depends on the width of its containing block.  If
    1:   // so, disable resize reflow optimizations for the line.  (Note that,
    1:   // to be conservative, we do this if we *try* to fit a frame on a
    1:   // line, even if we don't succeed.)
    1:   if (GetFlag(LL_GOTLINEBOX) && IsPercentageAware(aFrame)) {
    1:     mLineBox->DisableResizeReflowOptimization();
    1:   }
    1: 
    1:   // Compute the available size for the frame. This available width
    1:   // includes room for the side margins.
    1:   // For now, set the available height to unconstrained always.
    1:   nsSize availSize(mBlockReflowState->ComputedWidth(), NS_UNCONSTRAINEDSIZE);
    1: 
    1:   // Setup reflow state for reflowing the frame
    1:   nsHTMLReflowState reflowState(mPresContext, *psd->mReflowState,
    1:                                 aFrame, availSize);
    1:   reflowState.mLineLayout = this;
    1:   reflowState.mFlags.mIsTopOfPage = GetFlag(LL_ISTOPOFPAGE);
    1:   mTextJustificationNumSpaces = 0;
    1:   mTextJustificationNumLetters = 0;
    1: 
    1:   // Inline-ish and text-ish things don't compute their width;
    1:   // everything else does.  We need to give them an available width that
    1:   // reflects the space left on the line.
    1:   NS_ASSERTION(psd->mRightEdge != NS_UNCONSTRAINEDSIZE,
    1:                "shouldn't have unconstrained widths anymore");
    1:   if (reflowState.ComputedWidth() == NS_UNCONSTRAINEDSIZE)
    1:     reflowState.availableWidth = psd->mRightEdge - psd->mX;
    1: 
    1:   // Stash copies of some of the computed state away for later
    1:   // (vertical alignment, for example)
    1:   pfd->mFrame = aFrame;
    1:   pfd->mMargin = reflowState.mComputedMargin;
    1:   pfd->mBorderPadding = reflowState.mComputedBorderPadding;
    1:   pfd->mFrameType = reflowState.mFrameType;
    1:   pfd->SetFlag(PFD_RELATIVEPOS,
    1:                (reflowState.mStyleDisplay->mPosition == NS_STYLE_POSITION_RELATIVE));
    1:   if (pfd->GetFlag(PFD_RELATIVEPOS)) {
    1:     pfd->mOffsets = reflowState.mComputedOffsets;
    1:   }
    1: 
    1:   // NOTE: While the x coordinate remains relative to the parent span,
    1:   // the y coordinate is fixed at the top edge for the line. During
    1:   // VerticalAlignFrames we will repair this so that the y coordinate
    1:   // is properly set and relative to the appropriate span.
    1:   pfd->mBounds.x = psd->mX;
    1:   pfd->mBounds.y = mTopEdge;
    1: 
    1:   // We want to guarantee that we always make progress when
    1:   // formatting. Therefore, if the object being placed on the line is
    1:   // too big for the line, but it is the only thing on the line and is not
    1:   // impacted by a float, then we go ahead and place it anyway. (If the line
    1:   // is impacted by one or more floats, then it is safe to break because
    1:   // we can move the line down below float(s).)
    1:   //
    1:   // Capture this state *before* we reflow the frame in case it clears
    1:   // the state out. We need to know how to treat the current frame
    1:   // when breaking.
15350:   PRBool notSafeToBreak = LineIsEmpty() && !GetFlag(LL_IMPACTEDBYFLOATS);
    1:   
    1:   // Apply start margins (as appropriate) to the frame computing the
    1:   // new starting x,y coordinates for the frame.
    1:   ApplyStartMargin(pfd, reflowState);
    1: 
    1:   // Let frame know that are reflowing it. Note that we don't bother
    1:   // positioning the frame yet, because we're probably going to end up
    1:   // moving it when we do the vertical alignment
    1:   nscoord x = pfd->mBounds.x;
    1:   nscoord y = pfd->mBounds.y;
    1: 
    1:   aFrame->WillReflow(mPresContext);
    1: 
    1:   // Adjust spacemanager coordinate system for the frame. The
    1:   // spacemanager coordinates are <b>inside</b> the current spans
    1:   // border+padding, but the x/y coordinates are not (recall that
    1:   // frame coordinates are relative to the parents origin and that the
    1:   // parents border/padding is <b>inside</b> the parent
    1:   // frame. Therefore we have to subtract out the parents
    1:   // border+padding before translating.
    1:   nsHTMLReflowMetrics metrics;
    1: #ifdef DEBUG
    1:   metrics.width = nscoord(0xdeadbeef);
    1:   metrics.height = nscoord(0xdeadbeef);
    1: #endif
    1:   nscoord tx = x - psd->mReflowState->mComputedBorderPadding.left;
    1:   nscoord ty = y - psd->mReflowState->mComputedBorderPadding.top;
    1:   mSpaceManager->Translate(tx, ty);
    1: 
    1:   nsIAtom* frameType = aFrame->GetType();
    1:   PRInt32 savedOptionalBreakOffset;
16166:   gfxBreakPriority savedOptionalBreakPriority;
    1:   nsIContent* savedOptionalBreakContent =
16166:     GetLastOptionalBreakPosition(&savedOptionalBreakOffset,
16166:                                  &savedOptionalBreakPriority);
    1: 
    1:   rv = aFrame->Reflow(mPresContext, metrics, reflowState, aReflowStatus);
    1:   if (NS_FAILED(rv)) {
    1:     NS_WARNING( "Reflow of frame failed in nsLineLayout" );
    1:     return rv;
    1:   }
    1:   
    1:   pfd->mJustificationNumSpaces = mTextJustificationNumSpaces;
    1:   pfd->mJustificationNumLetters = mTextJustificationNumLetters;
    1: 
11711:   // See if the frame is a placeholderFrame and if it is process
11711:   // the float. At the same time, check if the frame has any non-collapsed-away
11711:   // content.
    1:   PRBool placedFloat = PR_FALSE;
12912:   PRBool isEmpty;
12912:   if (!frameType) {
12912:     isEmpty = pfd->mFrame->IsEmpty();
12912:   } else {
    1:     if (nsGkAtoms::placeholderFrame == frameType) {
12912:       isEmpty = PR_TRUE;
    1:       pfd->SetFlag(PFD_SKIPWHENTRIMMINGWHITESPACE, PR_TRUE);
    1:       nsIFrame* outOfFlowFrame = nsLayoutUtils::GetFloatFromPlaceholder(aFrame);
    1:       if (outOfFlowFrame) {
 3233:         nsPlaceholderFrame* placeholder = static_cast<nsPlaceholderFrame*>(aFrame);
16579:         // Add mTrimmableWidth to the available width since if the line ends
16579:         // here, the width of the inline content will be reduced by
16579:         // mTrimmableWidth.
16579:         nscoord availableWidth = psd->mRightEdge - (psd->mX - mTrimmableWidth);
16579:         if (psd->mNoWrap) {
16579:           // If we place floats after inline content where there's
16579:           // no break opportunity, we don't know how much additional
16579:           // width is required for the non-breaking content after the float,
16579:           // so we can't know whether the float plus that content will fit
16579:           // on the line. So for now, don't place floats after inline
16579:           // content where there's no break opportunity. This is incorrect
16579:           // but hopefully rare. Fixing it will require significant
16579:           // restructuring of line layout.
16579:           // We might as well allow zero-width floats to be placed, though.
16579:           availableWidth = 0;
16579:         }
    1:         // XXXldb What is this test supposed to be?
 1158:         if (!NS_SUBTREE_DIRTY(aFrame)) {
    1:           // incremental reflow of child
15299:           placedFloat = InitFloat(placeholder, availableWidth, aReflowStatus);
    1:         }
    1:         else {
15299:           placedFloat = AddFloat(placeholder, availableWidth, aReflowStatus);
    1:         }
 8759:         NS_ASSERTION(!(outOfFlowFrame->GetType() == nsGkAtoms::letterFrame &&
 8759:                        GetFirstLetterStyleOK()),
 8759:                     "FirstLetterStyle set on line with floating first letter");
    1:       }
    1:     }
    1:     else if (nsGkAtoms::textFrame == frameType) {
    1:       // Note non-empty text-frames for inline frame compatibility hackery
    1:       pfd->SetFlag(PFD_ISTEXTFRAME, PR_TRUE);
11711:       nsTextFrame* textFrame = static_cast<nsTextFrame*>(pfd->mFrame);
12912:       isEmpty = !textFrame->HasNoncollapsedCharacters();
12912:       if (!isEmpty) {
    1:         pfd->SetFlag(PFD_ISNONEMPTYTEXTFRAME, PR_TRUE);
11711:         nsIContent* content = textFrame->GetContent();
    1: 
    1:         const nsTextFragment* frag = content->GetText();
    1:         if (frag) {
    1:           pfd->SetFlag(PFD_ISNONWHITESPACETEXTFRAME,
    1:                        !content->TextIsOnlyWhitespace());
    1: // fix for bug 40882
    1: #ifdef IBMBIDI
    1:           if (mPresContext->BidiEnabled()) {
    1:             if (frag->Is2b()) {
    1:               //PRBool isVisual;
    1:               //mPresContext->IsVisualMode(isVisual);
    1:               PRUnichar ch = /*(isVisual) ?
    1:                               *(frag->Get2b() + frag->GetLength() - 1) :*/ *frag->Get2b();
    1:               if (IS_BIDI_DIACRITIC(ch)) {
    1:                 mPresContext->PropertyTable()->SetProperty(aFrame,
    1:                            nsGkAtoms::endsInDiacritic, NS_INT32_TO_PTR(ch),
    1:                                                            nsnull, nsnull);
    1:               }
    1:             }
    1:           }
    1: #endif // IBMBIDI
    1:         }
    1:       }
    1:     }
11711:     else if (nsGkAtoms::brFrame == frameType) {
11711:       pfd->SetFlag(PFD_SKIPWHENTRIMMINGWHITESPACE, PR_TRUE);
12912:       isEmpty = PR_FALSE;
11711:     } else {
11711:       if (nsGkAtoms::letterFrame==frameType) {
11563:         pfd->SetFlag(PFD_ISLETTERFRAME, PR_TRUE);
11563:       }
12912:       if (pfd->mSpan) {
12912:         isEmpty = !pfd->mSpan->mHasNonemptyContent && pfd->mFrame->IsSelfEmpty();
12912:       } else {
12912:         isEmpty = pfd->mFrame->IsEmpty();
    1:       }
11560:     }
11711:   }
    1: 
    1:   mSpaceManager->Translate(-tx, -ty);
    1: 
    1:   NS_ASSERTION(metrics.width>=0, "bad width");
    1:   NS_ASSERTION(metrics.height>=0,"bad height");
    1:   if (metrics.width<0) metrics.width=0;
    1:   if (metrics.height<0) metrics.height=0;
    1: 
    1: #ifdef DEBUG
    1:   // Note: break-before means ignore the reflow metrics since the
    1:   // frame will be reflowed another time.
    1:   if (!NS_INLINE_IS_BREAK_BEFORE(aReflowStatus)) {
    1:     if (CRAZY_WIDTH(metrics.width) || CRAZY_HEIGHT(metrics.height)) {
    1:       printf("nsLineLayout: ");
    1:       nsFrame::ListTag(stdout, aFrame);
    1:       printf(" metrics=%d,%d!\n", metrics.width, metrics.height);
    1:     }
    1:     if ((metrics.width == nscoord(0xdeadbeef)) ||
    1:         (metrics.height == nscoord(0xdeadbeef))) {
    1:       printf("nsLineLayout: ");
    1:       nsFrame::ListTag(stdout, aFrame);
    1:       printf(" didn't set w/h %d,%d!\n", metrics.width, metrics.height);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   // Unlike with non-inline reflow, the overflow area here does *not*
    1:   // include the accumulation of the frame's bounds and its inline
    1:   // descendants' bounds. Nor does it include the outline area; it's
    1:   // just the union of the bounds of any absolute children. That is
    1:   // added in later by nsLineLayout::ReflowInlineFrames.
    1:   pfd->mCombinedArea = metrics.mOverflowArea;
    1: 
    1:   pfd->mBounds.width = metrics.width;
    1:   pfd->mBounds.height = metrics.height;
    1: 
    1:   // Size the frame, but |RelativePositionFrames| will size the view.
    1:   aFrame->SetSize(nsSize(metrics.width, metrics.height));
    1: 
    1:   // Tell the frame that we're done reflowing it
    1:   aFrame->DidReflow(mPresContext, &reflowState, NS_FRAME_REFLOW_FINISHED);
    1: 
    1:   if (aMetrics) {
    1:     *aMetrics = metrics;
    1:   }
    1: 
    1:   if (!NS_INLINE_IS_BREAK_BEFORE(aReflowStatus)) {
    1:     // If frame is complete and has a next-in-flow, we need to delete
    1:     // them now. Do not do this when a break-before is signaled because
    1:     // the frame is going to get reflowed again (and may end up wanting
    1:     // a next-in-flow where it ends up).
    1:     if (NS_FRAME_IS_COMPLETE(aReflowStatus)) {
    1:       nsIFrame* kidNextInFlow = aFrame->GetNextInFlow();
    1:       if (nsnull != kidNextInFlow) {
    1:         // Remove all of the childs next-in-flows. Make sure that we ask
    1:         // the right parent to do the removal (it's possible that the
    1:         // parent is not this because we are executing pullup code)
 3233:         nsHTMLContainerFrame* parent = static_cast<nsHTMLContainerFrame*>
 3233:                                                   (kidNextInFlow->GetParent());
    1:         parent->DeleteNextInFlowChild(mPresContext, kidNextInFlow);
    1:       }
    1:     }
    1: 
    1:     // Check whether this frame breaks up text runs. All frames break up text
    1:     // runs (hence return false here) except for text frames and inline containers.
    1:     PRBool continuingTextRun = aFrame->CanContinueTextRun();
    1:     
11372:     // Clear any residual mTrimmableWidth if this isn't a text frame
11372:     if (!continuingTextRun && !pfd->GetFlag(PFD_SKIPWHENTRIMMINGWHITESPACE)) {
11372:       mTrimmableWidth = 0;
11372:     }
11372: 
    1:     // See if we can place the frame. If we can't fit it, then we
    1:     // return now.
 8806:     PRBool optionalBreakAfterFits;
    1:     if (CanPlaceFrame(pfd, reflowState, notSafeToBreak, continuingTextRun,
 1664:                       savedOptionalBreakContent != nsnull, metrics,
 8806:                       aReflowStatus, &optionalBreakAfterFits)) {
12912:       if (!isEmpty) {
11712:         psd->mHasNonemptyContent = PR_TRUE;
15350:         SetFlag(LL_LINEISEMPTY, PR_FALSE);
11712:       }
11712: 
    1:       // Place the frame, updating aBounds with the final size and
    1:       // location.  Then apply the bottom+right margins (as
    1:       // appropriate) to the frame.
    1:       PlaceFrame(pfd, metrics);
    1:       PerSpanData* span = pfd->mSpan;
    1:       if (span) {
    1:         // The frame we just finished reflowing is an inline
    1:         // container.  It needs its child frames vertically aligned,
    1:         // so do most of it now.
    1:         VerticalAlignFrames(span);
    1:       }
    1:       
    1:       if (!continuingTextRun) {
15350:         if (!psd->mNoWrap && (!LineIsEmpty() || placedFloat)) {
    1:           // record soft break opportunity after this content that can't be
    1:           // part of a text run. This is not a text frame so we know
    1:           // that offset PR_INT32_MAX means "after the content".
16166:           if (NotifyOptionalBreakPosition(aFrame->GetContent(), PR_INT32_MAX, optionalBreakAfterFits, eNormalBreak)) {
    1:             // If this returns true then we are being told to actually break here.
    1:             aReflowStatus = NS_INLINE_LINE_BREAK_AFTER(aReflowStatus);
    1:           }
    1:         }
    1:       }
    1:     }
    1:     else {
    1:       PushFrame(aFrame);
    1:       aPushedFrame = PR_TRUE;
    1:       // Undo any saved break positions that the frame might have told us about,
    1:       // since we didn't end up placing it
    1:       RestoreSavedBreakPosition(savedOptionalBreakContent,
16166:                                 savedOptionalBreakOffset,
16166:                                 savedOptionalBreakPriority);
    1:     }
    1:   }
    1:   else {
    1:     PushFrame(aFrame);
    1:   }
    1:   
    1: #ifdef REALLY_NOISY_REFLOW
    1:   nsFrame::IndentBy(stdout, mSpanDepth);
    1:   printf("End ReflowFrame ");
    1:   nsFrame::ListTag(stdout, aFrame);
    1:   printf(" status=%x\n", aReflowStatus);
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsLineLayout::ApplyStartMargin(PerFrameData* pfd,
    1:                                nsHTMLReflowState& aReflowState)
    1: {
    1:   NS_ASSERTION(aReflowState.mStyleDisplay->mFloats == NS_STYLE_FLOAT_NONE,
    1:                "How'd we get a floated inline frame? "
    1:                "The frame ctor should've dealt with this.");
    1: 
    1:   // XXXwaterson probably not the right way to get this; e.g., embeddings, etc.
    1:   PRBool ltr = (NS_STYLE_DIRECTION_LTR == aReflowState.mStyleVisibility->mDirection);
    1: 
    1:   // Only apply start-margin on the first-in flow for inline frames
    1:   if (pfd->mFrame->GetPrevContinuation()) {
    1:     // Zero this out so that when we compute the max-element-width of
    1:     // the frame we will properly avoid adding in the starting margin.
    1:     if (ltr)
    1:       pfd->mMargin.left = 0;
    1:     else
    1:       pfd->mMargin.right = 0;
    1:   }
    1:   else {
    1:     pfd->mBounds.x += ltr ? pfd->mMargin.left : pfd->mMargin.right;
    1: 
    1:     NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aReflowState.availableWidth,
    1:                  "shouldn't have unconstrained widths anymore");
    1:     if (NS_UNCONSTRAINEDSIZE == aReflowState.ComputedWidth()) {
    1:       // For inline-ish and text-ish things (which don't compute widths
    1:       // in the reflow state), adjust available width to account for the
    1:       // left margin. The right margin will be accounted for when we
    1:       // finish flowing the frame.
    1:       aReflowState.availableWidth -= ltr ? pfd->mMargin.left : pfd->mMargin.right;
    1:     }
    1:   }
    1: }
    1: 
 1664: nscoord
 1664: nsLineLayout::GetCurrentFrameXDistanceFromBlock()
 1664: {
 1664:   PerSpanData* psd;
 1664:   nscoord x = 0;
 1664:   for (psd = mCurrentSpan; psd; psd = psd->mParent) {
 1664:     x += psd->mX;
 1664:   }
 1664:   return x;
 1664: }
 1664: 
    1: /**
    1:  * See if the frame can be placed now that we know it's desired size.
    1:  * We can always place the frame if the line is empty. Note that we
    1:  * know that the reflow-status is not a break-before because if it was
    1:  * ReflowFrame above would have returned false, preventing this method
    1:  * from being called. The logic in this method assumes that.
    1:  *
    1:  * Note that there is no check against the Y coordinate because we
    1:  * assume that the caller will take care of that.
    1:  */
    1: PRBool
    1: nsLineLayout::CanPlaceFrame(PerFrameData* pfd,
    1:                             const nsHTMLReflowState& aReflowState,
    1:                             PRBool aNotSafeToBreak,
    1:                             PRBool aFrameCanContinueTextRun,
 1664:                             PRBool aCanRollBackBeforeFrame,
    1:                             nsHTMLReflowMetrics& aMetrics,
 8806:                             nsReflowStatus& aStatus,
 8806:                             PRBool* aOptionalBreakAfterFits)
    1: {
    1:   NS_PRECONDITION(pfd && pfd->mFrame, "bad args, null pointers for frame data");
 8806:   
 8806:   *aOptionalBreakAfterFits = PR_TRUE;
    1:   // Compute right margin to use
    1:   if (0 != pfd->mBounds.width) {
    1:     NS_ASSERTION(aReflowState.mStyleDisplay->mFloats == NS_STYLE_FLOAT_NONE,
    1:                  "How'd we get a floated inline frame? "
    1:                  "The frame ctor should've dealt with this.");
    1: 
    1:     // XXXwaterson this is probably not exactly right; e.g., embeddings, etc.
    1:     PRBool ltr = (NS_STYLE_DIRECTION_LTR == aReflowState.mStyleVisibility->mDirection);
    1: 
    1:     if ((NS_FRAME_IS_NOT_COMPLETE(aStatus) || (pfd->mFrame->GetNextContinuation() && !pfd->mFrame->GetNextInFlow())) 
    1:         && !pfd->GetFlag(PFD_ISLETTERFRAME)) {
    1:       // Only apply end margin for the last-in-flow. Zero this out so
    1:       // that when we compute the max-element-width of the frame we
    1:       // will properly avoid adding in the end margin.
    1:       if (ltr)
    1:         pfd->mMargin.right = 0;
    1:       else
    1:         pfd->mMargin.left = 0;
    1:     }
    1:   }
    1:   else {
    1:     // Don't apply margin to empty frames.
    1:     pfd->mMargin.left = pfd->mMargin.right = 0;
    1:   }
    1: 
    1:   PerSpanData* psd = mCurrentSpan;
    1:   if (psd->mNoWrap) {
    1:     // When wrapping is off, everything fits.
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   PRBool ltr = NS_STYLE_DIRECTION_LTR == aReflowState.mStyleVisibility->mDirection;
    1:   nscoord endMargin = ltr ? pfd->mMargin.right : pfd->mMargin.left;
    1: 
    1: #ifdef NOISY_CAN_PLACE_FRAME
    1:   if (nsnull != psd->mFrame) {
    1:     nsFrame::ListTag(stdout, psd->mFrame->mFrame);
    1:   }
    1:   else {
    1:     nsFrame::ListTag(stdout, mBlockReflowState->frame);
    1:   } 
    1:   printf(": aNotSafeToBreak=%s frame=", aNotSafeToBreak ? "true" : "false");
    1:   nsFrame::ListTag(stdout, pfd->mFrame);
    1:   printf(" frameWidth=%d\n", pfd->mBounds.XMost() + endMargin - psd->mX);
    1: #endif
    1: 
    1:   // Set outside to PR_TRUE if the result of the reflow leads to the
    1:   // frame sticking outside of our available area.
 7069:   PRBool outside = pfd->mBounds.XMost() - mTrimmableWidth + endMargin > psd->mRightEdge;
    1:   if (!outside) {
    1:     // If it fits, it fits
    1: #ifdef NOISY_CAN_PLACE_FRAME
    1:     printf("   ==> inside\n");
    1: #endif
    1:     return PR_TRUE;
    1:   }
 8806:   *aOptionalBreakAfterFits = PR_FALSE;
    1: 
    1:   // When it doesn't fit, check for a few special conditions where we
    1:   // allow it to fit anyway.
    1:   if (0 == pfd->mMargin.left + pfd->mBounds.width + pfd->mMargin.right) {
    1:     // Empty frames always fit right where they are
    1: #ifdef NOISY_CAN_PLACE_FRAME
    1:     printf("   ==> empty frame fits\n");
    1: #endif
    1:     return PR_TRUE;
    1:   }
    1: 
    1: #ifdef FIX_BUG_50257
    1:   // another special case:  always place a BR
    1:   if (nsGkAtoms::brFrame == pfd->mFrame->GetType()) {
    1: #ifdef NOISY_CAN_PLACE_FRAME
    1:     printf("   ==> BR frame fits\n");
    1: #endif
    1:     return PR_TRUE;
    1:   }
    1: #endif
    1: 
    1:   if (aNotSafeToBreak) {
    1:     // There are no frames on the line that take up width and the line is
    1:     // not impacted by floats, so we must allow the current frame to be
    1:     // placed on the line
    1: #ifdef NOISY_CAN_PLACE_FRAME
    1:     printf("   ==> not-safe and not-impacted fits: ");
    1:     while (nsnull != psd) {
    1:       printf("<psd=%p x=%d left=%d> ", psd, psd->mX, psd->mLeftEdge);
    1:       psd = psd->mParent;
    1:     }
    1:     printf("\n");
    1: #endif
    1:     return PR_TRUE;
    1:   }
    1:  
    1:   // Special check for span frames
    1:   if (pfd->mSpan && pfd->mSpan->mContainsFloat) {
    1:     // If the span either directly or indirectly contains a float then
    1:     // it fits. Why? It's kind of complicated, but here goes:
    1:     //
    1:     // 1. CanPlaceFrame is used for all frame placements on a line,
    1:     // and in a span. This includes recursively placement of frames
    1:     // inside of spans, and the span itself. Because the logic always
    1:     // checks for room before proceeding (the code above here), the
    1:     // only things on a line will be those things that "fit".
    1:     //
    1:     // 2. Before a float is placed on a line, the line has to be empty
    1:     // (otherwise it's a "below current line" float and will be placed
    1:     // after the line).
    1:     //
    1:     // Therefore, if the span directly or indirectly has a float
    1:     // then it means that at the time of the placement of the float
    1:     // the line was empty. Because of #1, only the frames that fit can
    1:     // be added after that point, therefore we can assume that the
    1:     // current span being placed has fit.
    1:     //
    1:     // So how do we get here and have a span that should already fit
    1:     // and yet doesn't: Simple: span's that have the no-wrap attribute
    1:     // set on them and contain a float and are placed where they
    1:     // don't naturally fit.
    1:     return PR_TRUE;
    1:  }
    1: 
    1:   if (aFrameCanContinueTextRun) {
 8153:     // Let it fit, but we reserve the right to roll back.
 8153:     // Note that we usually won't get here because a text frame will break
 8153:     // itself to avoid exceeding the available width.
    1:     // We'll only get here for text frames that couldn't break early enough.
    1: #ifdef NOISY_CAN_PLACE_FRAME
    1:     printf("   ==> placing overflowing textrun, requesting backup\n");
    1: #endif
 8153: 
 8153:     // We will want to try backup.
 8153:     SetFlag(LL_NEEDBACKUP, PR_TRUE);
    1:     return PR_TRUE;
    1:   }
    1: 
    1: #ifdef NOISY_CAN_PLACE_FRAME
    1:   printf("   ==> didn't fit\n");
    1: #endif
    1:   aStatus = NS_INLINE_LINE_BREAK_BEFORE();
    1:   return PR_FALSE;
    1: }
    1: 
    1: /**
    1:  * Place the frame. Update running counters.
    1:  */
    1: void
    1: nsLineLayout::PlaceFrame(PerFrameData* pfd, nsHTMLReflowMetrics& aMetrics)
    1: {
    1:   // If frame is zero width then do not apply its left and right margins.
    1:   PerSpanData* psd = mCurrentSpan;
    1:   PRBool emptyFrame = PR_FALSE;
    1:   if ((0 == pfd->mBounds.width) && (0 == pfd->mBounds.height)) {
    1:     pfd->mBounds.x = psd->mX;
    1:     pfd->mBounds.y = mTopEdge;
    1:     emptyFrame = PR_TRUE;
    1:   }
    1: 
    1:   // Record ascent and update max-ascent and max-descent values
    1:   if (aMetrics.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE)
    1:     pfd->mAscent = pfd->mFrame->GetBaseline();
    1:   else
    1:     pfd->mAscent = aMetrics.ascent;
    1: 
    1:   PRBool ltr = (NS_STYLE_DIRECTION_LTR == pfd->mFrame->GetStyleVisibility()->mDirection);
    1:   // Advance to next X coordinate
    1:   psd->mX = pfd->mBounds.XMost() + (ltr ? pfd->mMargin.right : pfd->mMargin.left);
    1: 
    1:   // Count the number of non-empty frames on the line...
    1:   if (!emptyFrame) {
    1:     mTotalPlacedFrames++;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsLineLayout::AddBulletFrame(nsIFrame* aFrame,
    1:                              const nsHTMLReflowMetrics& aMetrics)
    1: {
    1:   NS_ASSERTION(mCurrentSpan == mRootSpan, "bad linelayout user");
    1: 
    1:   PerFrameData* pfd;
    1:   nsresult rv = NewPerFrameData(&pfd);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     mRootSpan->AppendFrame(pfd);
    1:     pfd->mFrame = aFrame;
    1:     pfd->mMargin.SizeTo(0, 0, 0, 0);
    1:     pfd->mBorderPadding.SizeTo(0, 0, 0, 0);
    1:     pfd->mFrameType = NS_FRAME_REPLACED(NS_CSS_FRAME_TYPE_INLINE);
    1:     pfd->mFlags = 0;  // all flags default to false
    1:     pfd->SetFlag(PFD_ISBULLET, PR_TRUE);
    1:     if (aMetrics.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE)
    1:       pfd->mAscent = aFrame->GetBaseline();
    1:     else
    1:       pfd->mAscent = aMetrics.ascent;
    1: 
    1:     // Note: y value will be updated during vertical alignment
    1:     pfd->mBounds = aFrame->GetRect();
    1:     pfd->mCombinedArea = aMetrics.mOverflowArea;
    1:   }
    1:   return rv;
    1: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsLineLayout::DumpPerSpanData(PerSpanData* psd, PRInt32 aIndent)
    1: {
    1:   nsFrame::IndentBy(stdout, aIndent);
 3233:   printf("%p: left=%d x=%d right=%d\n", static_cast<void*>(psd),
    1:          psd->mLeftEdge, psd->mX, psd->mRightEdge);
    1:   PerFrameData* pfd = psd->mFirstFrame;
    1:   while (nsnull != pfd) {
    1:     nsFrame::IndentBy(stdout, aIndent+1);
    1:     nsFrame::ListTag(stdout, pfd->mFrame);
    1:     printf(" %d,%d,%d,%d\n", pfd->mBounds.x, pfd->mBounds.y,
    1:            pfd->mBounds.width, pfd->mBounds.height);
    1:     if (pfd->mSpan) {
    1:       DumpPerSpanData(pfd->mSpan, aIndent + 1);
    1:     }
    1:     pfd = pfd->mNext;
    1:   }
    1: }
    1: #endif
    1: 
    1: #define VALIGN_OTHER  0
    1: #define VALIGN_TOP    1
    1: #define VALIGN_BOTTOM 2
    1: 
    1: void
    1: nsLineLayout::VerticalAlignLine()
    1: {
    1:   // Synthesize a PerFrameData for the block frame
    1:   PerFrameData rootPFD;
    1:   rootPFD.mFrame = mBlockReflowState->frame;
    1:   rootPFD.mFrameType = mBlockReflowState->mFrameType;
    1:   rootPFD.mAscent = 0;
    1:   mRootSpan->mFrame = &rootPFD;
    1: 
    1:   // Partially place the children of the block frame. The baseline for
    1:   // this operation is set to zero so that the y coordinates for all
    1:   // of the placed children will be relative to there.
    1:   PerSpanData* psd = mRootSpan;
    1:   VerticalAlignFrames(psd);
    1: 
    1:   // Compute the line-height. The line-height will be the larger of:
    1:   //
    1:   // [1] maxY - minY (the distance between the highest childs top edge
    1:   // and the lowest childs bottom edge)
    1:   //
    1:   // [2] the maximum logical box height (since not every frame may have
    1:   // participated in #1; for example: top/bottom aligned frames)
    1:   //
    1:   // [3] the minimum line height (line-height property set on the
    1:   // block frame)
    1:   nscoord lineHeight = psd->mMaxY - psd->mMinY;
    1: 
    1:   // Now that the line-height is computed, we need to know where the
    1:   // baseline is in the line. Position baseline so that mMinY is just
    1:   // inside the top of the line box.
    1:   nscoord baselineY;
    1:   if (psd->mMinY < 0) {
    1:     baselineY = mTopEdge - psd->mMinY;
    1:   }
    1:   else {
    1:     baselineY = mTopEdge;
    1:   }
    1: 
    1:   // It's also possible that the line-height isn't tall enough because
    1:   // of top/bottom aligned elements that were not accounted for in
    1:   // min/max Y.
    1:   //
    1:   // The CSS2 spec doesn't really say what happens when to the
    1:   // baseline in this situations. What we do is if the largest top
    1:   // aligned box height is greater than the line-height then we leave
    1:   // the baseline alone. If the largest bottom aligned box is greater
    1:   // than the line-height then we slide the baseline down by the extra
    1:   // amount.
    1:   //
    1:   // Navigator 4 gives precedence to the first top/bottom aligned
    1:   // object.  We just let bottom aligned objects win.
    1:   if (lineHeight < mMaxBottomBoxHeight) {
    1:     // When the line is shorter than the maximum top aligned box
    1:     nscoord extra = mMaxBottomBoxHeight - lineHeight;
    1:     baselineY += extra;
    1:     lineHeight = mMaxBottomBoxHeight;
    1:   }
    1:   if (lineHeight < mMaxTopBoxHeight) {
    1:     lineHeight = mMaxTopBoxHeight;
    1:   }
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:   printf("  [line]==> lineHeight=%d baselineY=%d\n", lineHeight, baselineY);
    1: #endif
    1: 
    1:   // Now position all of the frames in the root span. We will also
    1:   // recurse over the child spans and place any top/bottom aligned
    1:   // frames we find.
    1:   // XXX PERFORMANCE: set a bit per-span to avoid the extra work
    1:   // (propagate it upward too)
    1:   for (PerFrameData* pfd = psd->mFirstFrame; pfd; pfd = pfd->mNext) {
15274:     if (pfd->mVerticalAlign == VALIGN_OTHER) {
15274:       pfd->mBounds.y += baselineY;
15274:       pfd->mFrame->SetRect(pfd->mBounds);
    1:     }
    1:   }
15274:   PlaceTopBottomFrames(psd, -mTopEdge, lineHeight);
    1: 
    1:   // Fill in returned line-box and max-element-width data
    1:   mLineBox->mBounds.x = psd->mLeftEdge;
    1:   mLineBox->mBounds.y = mTopEdge;
    1:   mLineBox->mBounds.width = psd->mX - psd->mLeftEdge;
    1:   mLineBox->mBounds.height = lineHeight;
    1:   mFinalLineHeight = lineHeight;
    1:   mLineBox->SetAscent(baselineY - mTopEdge);
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:   printf(
    1:     "  [line]==> bounds{x,y,w,h}={%d,%d,%d,%d} lh=%d a=%d\n",
    1:     mLineBox->mBounds.x, mLineBox->mBounds.y,
    1:     mLineBox->mBounds.width, mLineBox->mBounds.height,
    1:     mFinalLineHeight, mLineBox->GetAscent());
    1: #endif
    1: 
    1:   // Undo root-span mFrame pointer to prevent brane damage later on...
    1:   mRootSpan->mFrame = nsnull;
    1: }
    1: 
    1: void
    1: nsLineLayout::PlaceTopBottomFrames(PerSpanData* psd,
    1:                                    nscoord aDistanceFromTop,
    1:                                    nscoord aLineHeight)
    1: {
15274:   for (PerFrameData* pfd = psd->mFirstFrame; pfd; pfd = pfd->mNext) {
    1:     PerSpanData* span = pfd->mSpan;
    1: #ifdef DEBUG
    1:     NS_ASSERTION(0xFF != pfd->mVerticalAlign, "umr");
    1: #endif
    1:     switch (pfd->mVerticalAlign) {
    1:       case VALIGN_TOP:
    1:         if (span) {
15275:           pfd->mBounds.y = -aDistanceFromTop - span->mMinY;
    1:         }
    1:         else {
    1:           pfd->mBounds.y = -aDistanceFromTop + pfd->mMargin.top;
    1:         }
    1:         pfd->mFrame->SetRect(pfd->mBounds);
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:         printf("    ");
    1:         nsFrame::ListTag(stdout, pfd->mFrame);
    1:         printf(": y=%d dTop=%d [bp.top=%d topLeading=%d]\n",
    1:                pfd->mBounds.y, aDistanceFromTop,
    1:                span ? pfd->mBorderPadding.top : 0,
    1:                span ? span->mTopLeading : 0);
    1: #endif
    1:         break;
    1:       case VALIGN_BOTTOM:
    1:         if (span) {
    1:           // Compute bottom leading
15275:           pfd->mBounds.y = -aDistanceFromTop + aLineHeight - span->mMaxY;
    1:         }
    1:         else {
    1:           pfd->mBounds.y = -aDistanceFromTop + aLineHeight -
    1:             pfd->mMargin.bottom - pfd->mBounds.height;
    1:         }
    1:         pfd->mFrame->SetRect(pfd->mBounds);
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:         printf("    ");
    1:         nsFrame::ListTag(stdout, pfd->mFrame);
    1:         printf(": y=%d\n", pfd->mBounds.y);
    1: #endif
    1:         break;
    1:     }
    1:     if (span) {
    1:       nscoord distanceFromTop = aDistanceFromTop + pfd->mBounds.y;
    1:       PlaceTopBottomFrames(span, distanceFromTop, aLineHeight);
    1:     }
    1:   }
    1: }
    1: 
    1: #define VERTICAL_ALIGN_FRAMES_NO_MINIMUM 32767
    1: #define VERTICAL_ALIGN_FRAMES_NO_MAXIMUM -32768
    1: 
    1: // Vertically place frames within a given span. Note: this doesn't
    1: // place top/bottom aligned frames as those have to wait until the
    1: // entire line box height is known. This is called after the span
    1: // frame has finished being reflowed so that we know its height.
    1: void
    1: nsLineLayout::VerticalAlignFrames(PerSpanData* psd)
    1: {
    1:   // Get parent frame info
    1:   PerFrameData* spanFramePFD = psd->mFrame;
    1:   nsIFrame* spanFrame = spanFramePFD->mFrame;
    1: 
    1:   // Get the parent frame's font for all of the frames in this span
    1:   nsStyleContext* styleContext = spanFrame->GetStyleContext();
    1:   nsIRenderingContext* rc = mBlockReflowState->rendContext;
 1105:   nsLayoutUtils::SetFontFromStyle(mBlockReflowState->rendContext, styleContext);
    1:   nsCOMPtr<nsIFontMetrics> fm;
    1:   rc->GetFontMetrics(*getter_AddRefs(fm));
    1: 
11894:   PRBool preMode = mStyleText->WhiteSpaceIsSignificant();
    1: 
    1:   // See if the span is an empty continuation. It's an empty continuation iff:
    1:   // - it has a prev-in-flow
    1:   // - it has no next in flow
    1:   // - it's zero sized
20514:   PRBool emptyContinuation = psd != mRootSpan &&
20514:     spanFrame->GetPrevInFlow() && !spanFrame->GetNextInFlow() &&
    1:     (0 == spanFramePFD->mBounds.width) && (0 == spanFramePFD->mBounds.height);
    1: 
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:   printf("[%sSpan]", (psd == mRootSpan)?"Root":"");
    1:   nsFrame::ListTag(stdout, spanFrame);
    1:   printf(": preMode=%s strictMode=%s w/h=%d,%d emptyContinuation=%s",
    1:          preMode ? "yes" : "no",
 6515:          mPresContext->CompatibilityMode() != eCompatibility_NavQuirks ? "yes" : "no",
    1:          spanFramePFD->mBounds.width, spanFramePFD->mBounds.height,
    1:          emptyContinuation ? "yes" : "no");
    1:   if (psd != mRootSpan) {
    1:     printf(" bp=%d,%d,%d,%d margin=%d,%d,%d,%d",
    1:            spanFramePFD->mBorderPadding.top,
    1:            spanFramePFD->mBorderPadding.right,
    1:            spanFramePFD->mBorderPadding.bottom,
    1:            spanFramePFD->mBorderPadding.left,
    1:            spanFramePFD->mMargin.top,
    1:            spanFramePFD->mMargin.right,
    1:            spanFramePFD->mMargin.bottom,
    1:            spanFramePFD->mMargin.left);
    1:   }
    1:   printf("\n");
    1: #endif
    1: 
    1:   // Compute the span's mZeroEffectiveSpanBox flag. What we are trying
    1:   // to determine is how we should treat the span: should it act
    1:   // "normally" according to css2 or should it effectively
    1:   // "disappear".
    1:   //
    1:   // In general, if the document being processed is in full standards
    1:   // mode then it should act normally (with one exception). The
    1:   // exception case is when a span is continued and yet the span is
    1:   // empty (e.g. compressed whitespace). For this kind of span we treat
    1:   // it as if it were not there so that it doesn't impact the
    1:   // line-height.
    1:   //
    1:   // In almost standards mode or quirks mode, we should sometimes make
    1:   // it disappear. The cases that matter are those where the span
    1:   // contains no real text elements that would provide an ascent and
    1:   // descent and height. However, if css style elements have been
    1:   // applied to the span (border/padding/margin) so that it's clear the
    1:   // document author is intending css2 behavior then we act as if strict
    1:   // mode is set.
    1:   //
    1:   // This code works correctly for preMode, because a blank line
    1:   // in PRE mode is encoded as a text node with a LF in it, since
    1:   // text nodes with only whitespace are considered in preMode.
    1:   //
    1:   // Much of this logic is shared with the various implementations of
    1:   // nsIFrame::IsEmpty since they need to duplicate the way it makes
    1:   // some lines empty.  However, nsIFrame::IsEmpty can't be reused here
    1:   // since this code sets zeroEffectiveSpanBox even when there are
    1:   // non-empty children.
    1:   PRBool zeroEffectiveSpanBox = PR_FALSE;
    1:   // XXXldb If we really have empty continuations, then all these other
    1:   // checks don't make sense for them.
    1:   // XXXldb This should probably just use nsIFrame::IsSelfEmpty, assuming that
    1:   // it agrees with this code.  (If it doesn't agree, it probably should.)
 6515:   if ((emptyContinuation ||
 6515:        mPresContext->CompatibilityMode() != eCompatibility_FullStandards) &&
    1:       ((psd == mRootSpan) ||
    1:        ((0 == spanFramePFD->mBorderPadding.top) &&
    1:         (0 == spanFramePFD->mBorderPadding.right) &&
    1:         (0 == spanFramePFD->mBorderPadding.bottom) &&
    1:         (0 == spanFramePFD->mBorderPadding.left) &&
    1:         (0 == spanFramePFD->mMargin.top) &&
    1:         (0 == spanFramePFD->mMargin.right) &&
    1:         (0 == spanFramePFD->mMargin.bottom) &&
    1:         (0 == spanFramePFD->mMargin.left)))) {
    1:     // This code handles an issue with compatibility with non-css
    1:     // conformant browsers. In particular, there are some cases
    1:     // where the font-size and line-height for a span must be
    1:     // ignored and instead the span must *act* as if it were zero
    1:     // sized. In general, if the span contains any non-compressed
    1:     // text then we don't use this logic.
    1:     // However, this is not propagated outwards, since (in compatibility
    1:     // mode) we don't want big line heights for things like
    1:     // <p><font size="-1">Text</font></p>
    1: 
    1:     // We shouldn't include any whitespace that collapses, unless we're
    1:     // preformatted (in which case it shouldn't, but the width=0 test is
    1:     // perhaps incorrect).  This includes whitespace at the beginning of
    1:     // a line and whitespace preceded (?) by other whitespace.
    1:     // See bug 134580 and bug 155333.
    1:     zeroEffectiveSpanBox = PR_TRUE;
    1:     for (PerFrameData* pfd = psd->mFirstFrame; pfd; pfd = pfd->mNext) {
    1:       if (pfd->GetFlag(PFD_ISTEXTFRAME) &&
    1:           (pfd->GetFlag(PFD_ISNONWHITESPACETEXTFRAME) || preMode ||
    1:            pfd->mBounds.width != 0)) {
    1:         zeroEffectiveSpanBox = PR_FALSE;
    1:         break;
    1:       }
    1:     }
    1:   }
    1:   psd->mZeroEffectiveSpanBox = zeroEffectiveSpanBox;
    1: 
    1:   // Setup baselineY, minY, and maxY
    1:   nscoord baselineY, minY, maxY;
    1:   if (psd == mRootSpan) {
    1:     // Use a zero baselineY since we don't yet know where the baseline
    1:     // will be (until we know how tall the line is; then we will
    1:     // know). In addition, use extreme values for the minY and maxY
    1:     // values so that only the child frames will impact their values
    1:     // (since these are children of the block, there is no span box to
    1:     // provide initial values).
    1:     baselineY = 0;
    1:     minY = VERTICAL_ALIGN_FRAMES_NO_MINIMUM;
    1:     maxY = VERTICAL_ALIGN_FRAMES_NO_MAXIMUM;
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:     printf("[RootSpan]");
    1:     nsFrame::ListTag(stdout, spanFrame);
    1:     printf(": pass1 valign frames: topEdge=%d minLineHeight=%d zeroEffectiveSpanBox=%s\n",
    1:            mTopEdge, mMinLineHeight,
    1:            zeroEffectiveSpanBox ? "yes" : "no");
    1: #endif
    1:   }
    1:   else {
    1:     // Compute the logical height for this span. The logical height
    1:     // is based on the line-height value, not the font-size. Also
    1:     // compute the top leading.
16031:     nscoord logicalHeight = nsHTMLReflowState::CalcLineHeight(spanFrame);
    1:     nscoord contentHeight = spanFramePFD->mBounds.height -
    1:       spanFramePFD->mBorderPadding.top - spanFramePFD->mBorderPadding.bottom;
    1: 
    1:     // Special-case for a ::first-letter frame, set the line height to
    1:     // the frame height if the user has left line-height == normal 
20514:     if (spanFramePFD->GetFlag(PFD_ISLETTERFRAME) &&
20514:         !spanFrame->GetPrevInFlow() &&
    1:         spanFrame->GetStyleText()->mLineHeight.GetUnit() == eStyleUnit_Normal) {
    1:       logicalHeight = spanFramePFD->mBounds.height;
    1:     }
    1: 
    1:     nscoord leading = logicalHeight - contentHeight;
    1:     psd->mTopLeading = leading / 2;
    1:     psd->mBottomLeading = leading - psd->mTopLeading;
    1:     psd->mLogicalHeight = logicalHeight;
    1: 
    1:     if (zeroEffectiveSpanBox) {
    1:       // When the span-box is to be ignored, zero out the initial
    1:       // values so that the span doesn't impact the final line
    1:       // height. The contents of the span can impact the final line
    1:       // height.
    1: 
    1:       // Note that things are readjusted for this span after its children
    1:       // are reflowed
    1:       minY = VERTICAL_ALIGN_FRAMES_NO_MINIMUM;
    1:       maxY = VERTICAL_ALIGN_FRAMES_NO_MAXIMUM;
    1:     }
    1:     else {
    1: 
    1:       // The initial values for the min and max Y values are in the spans
    1:       // coordinate space, and cover the logical height of the span. If
    1:       // there are child frames in this span that stick out of this area
    1:       // then the minY and maxY are updated by the amount of logical
    1:       // height that is outside this range.
    1:       minY = spanFramePFD->mBorderPadding.top - psd->mTopLeading;
    1:       maxY = minY + psd->mLogicalHeight;
    1:     }
    1: 
    1:     // This is the distance from the top edge of the parents visual
    1:     // box to the baseline. The span already computed this for us,
    1:     // so just use it.
    1:     baselineY = spanFramePFD->mAscent;
    1: 
    1: 
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:     printf("[%sSpan]", (psd == mRootSpan)?"Root":"");
    1:     nsFrame::ListTag(stdout, spanFrame);
    1:     printf(": baseLine=%d logicalHeight=%d topLeading=%d h=%d bp=%d,%d zeroEffectiveSpanBox=%s\n",
    1:            baselineY, psd->mLogicalHeight, psd->mTopLeading,
    1:            spanFramePFD->mBounds.height,
    1:            spanFramePFD->mBorderPadding.top, spanFramePFD->mBorderPadding.bottom,
    1:            zeroEffectiveSpanBox ? "yes" : "no");
    1: #endif
    1:   }
    1: 
    1:   nscoord maxTopBoxHeight = 0;
    1:   nscoord maxBottomBoxHeight = 0;
    1:   PerFrameData* pfd = psd->mFirstFrame;
    1:   while (nsnull != pfd) {
    1:     nsIFrame* frame = pfd->mFrame;
    1: 
    1:     // sanity check (see bug 105168, non-reproducible crashes from null frame)
    1:     NS_ASSERTION(frame, "null frame in PerFrameData - something is very very bad");
    1:     if (!frame) {
    1:       return;
    1:     }
    1: 
    1:     // Compute the logical height of the frame
    1:     nscoord logicalHeight;
    1:     nscoord topLeading;
    1:     PerSpanData* frameSpan = pfd->mSpan;
    1:     if (frameSpan) {
    1:       // For span frames the logical-height and top-leading was
    1:       // pre-computed when the span was reflowed.
    1:       logicalHeight = frameSpan->mLogicalHeight;
    1:       topLeading = frameSpan->mTopLeading;
    1:     }
    1:     else {
    1:       // For other elements the logical height is the same as the
    1:       // frames height plus its margins.
    1:       logicalHeight = pfd->mBounds.height + pfd->mMargin.top +
    1:         pfd->mMargin.bottom;
    1:       topLeading = 0;
    1:     }
    1: 
    1:     // Get vertical-align property
    1:     const nsStyleTextReset* textStyle = frame->GetStyleTextReset();
    1:     nsStyleUnit verticalAlignUnit = textStyle->mVerticalAlign.GetUnit();
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:     printf("  [frame]");
    1:     nsFrame::ListTag(stdout, frame);
    1:     printf(": verticalAlignUnit=%d (enum == %d)\n",
    1:            verticalAlignUnit,
    1:            ((eStyleUnit_Enumerated == verticalAlignUnit)
    1:             ? textStyle->mVerticalAlign.GetIntValue()
    1:             : -1));
    1: #endif
    1: 
    1:     PRUint8 verticalAlignEnum;
    1:     nscoord parentAscent, parentDescent, parentXHeight;
    1:     nscoord parentSuperscript, parentSubscript;
    1:     nscoord coordOffset, percentOffset, elementLineHeight;
    1:     nscoord revisedBaselineY;
    1:     switch (verticalAlignUnit) {
    1:       case eStyleUnit_Enumerated:
    1:       default:
    1:         if (eStyleUnit_Enumerated == verticalAlignUnit) {
    1:           verticalAlignEnum = textStyle->mVerticalAlign.GetIntValue();
    1:         }
    1:         else {
    1:           verticalAlignEnum = NS_STYLE_VERTICAL_ALIGN_BASELINE;
    1:         }
    1:         switch (verticalAlignEnum) {
    1:           default:
    1:           case NS_STYLE_VERTICAL_ALIGN_BASELINE:
    1:             // The elements baseline is aligned with the baseline of
    1:             // the parent.
    1:             pfd->mBounds.y = baselineY - pfd->mAscent;
    1:             pfd->mVerticalAlign = VALIGN_OTHER;
    1:             break;
    1: 
    1:           case NS_STYLE_VERTICAL_ALIGN_SUB:
    1:             // Lower the baseline of the box to the subscript offset
    1:             // of the parent's box. This is identical to the baseline
    1:             // alignment except for the addition of the subscript
    1:             // offset to the baseline Y.
    1:             fm->GetSubscriptOffset(parentSubscript);
    1:             revisedBaselineY = baselineY + parentSubscript;
    1:             pfd->mBounds.y = revisedBaselineY - pfd->mAscent;
    1:             pfd->mVerticalAlign = VALIGN_OTHER;
    1:             break;
    1: 
    1:           case NS_STYLE_VERTICAL_ALIGN_SUPER:
    1:             // Raise the baseline of the box to the superscript offset
    1:             // of the parent's box. This is identical to the baseline
    1:             // alignment except for the subtraction of the superscript
    1:             // offset to the baseline Y.
    1:             fm->GetSuperscriptOffset(parentSuperscript);
    1:             revisedBaselineY = baselineY - parentSuperscript;
    1:             pfd->mBounds.y = revisedBaselineY - pfd->mAscent;
    1:             pfd->mVerticalAlign = VALIGN_OTHER;
    1:             break;
    1: 
    1:           case NS_STYLE_VERTICAL_ALIGN_TOP:
15275:           {
    1:             pfd->mVerticalAlign = VALIGN_TOP;
15275:             nscoord subtreeHeight = logicalHeight;
15275:             if (frameSpan) {
15275:               subtreeHeight = frameSpan->mMaxY - frameSpan->mMinY;
15275:               NS_ASSERTION(subtreeHeight >= logicalHeight,
15275:                            "unexpected subtree height");
15275:             }
15275:             if (subtreeHeight > maxTopBoxHeight) {
15275:               maxTopBoxHeight = subtreeHeight;
    1:             }
    1:             break;
15275:           }
    1: 
    1:           case NS_STYLE_VERTICAL_ALIGN_BOTTOM:
15275:           {
    1:             pfd->mVerticalAlign = VALIGN_BOTTOM;
15275:             nscoord subtreeHeight = logicalHeight;
15275:             if (frameSpan) {
15275:               subtreeHeight = frameSpan->mMaxY - frameSpan->mMinY;
15275:               NS_ASSERTION(subtreeHeight >= logicalHeight,
15275:                            "unexpected subtree height");
15275:             }
15275:             if (subtreeHeight > maxBottomBoxHeight) {
15275:               maxBottomBoxHeight = subtreeHeight;
    1:             }
    1:             break;
15275:           }
    1: 
    1:           case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
    1:             // Align the midpoint of the frame with 1/2 the parents
    1:             // x-height above the baseline.
    1:             fm->GetXHeight(parentXHeight);
    1:             if (frameSpan) {
    1:               pfd->mBounds.y = baselineY -
    1:                 (parentXHeight + pfd->mBounds.height)/2;
    1:             }
    1:             else {
    1:               pfd->mBounds.y = baselineY - (parentXHeight + logicalHeight)/2 +
    1:                 pfd->mMargin.top;
    1:             }
    1:             pfd->mVerticalAlign = VALIGN_OTHER;
    1:             break;
    1: 
    1:           case NS_STYLE_VERTICAL_ALIGN_TEXT_TOP:
    1:             // The top of the logical box is aligned with the top of
    1:             // the parent elements text.
    1:             fm->GetMaxAscent(parentAscent);
    1:             if (frameSpan) {
    1:               pfd->mBounds.y = baselineY - parentAscent -
    1:                 pfd->mBorderPadding.top + frameSpan->mTopLeading;
    1:             }
    1:             else {
    1:               pfd->mBounds.y = baselineY - parentAscent + pfd->mMargin.top;
    1:             }
    1:             pfd->mVerticalAlign = VALIGN_OTHER;
    1:             break;
    1: 
    1:           case NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM:
    1:             // The bottom of the logical box is aligned with the
    1:             // bottom of the parent elements text.
    1:             fm->GetMaxDescent(parentDescent);
    1:             if (frameSpan) {
    1:               pfd->mBounds.y = baselineY + parentDescent -
    1:                 pfd->mBounds.height + pfd->mBorderPadding.bottom -
    1:                 frameSpan->mBottomLeading;
    1:             }
    1:             else {
    1:               pfd->mBounds.y = baselineY + parentDescent -
    1:                 pfd->mBounds.height - pfd->mMargin.bottom;
    1:             }
    1:             pfd->mVerticalAlign = VALIGN_OTHER;
    1:             break;
    1: 
    1:           case NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE:
    1:             // Align the midpoint of the frame with the baseline of the parent.
    1:             if (frameSpan) {
    1:               pfd->mBounds.y = baselineY - pfd->mBounds.height/2;
    1:             }
    1:             else {
    1:               pfd->mBounds.y = baselineY - logicalHeight/2 + pfd->mMargin.top;
    1:             }
    1:             pfd->mVerticalAlign = VALIGN_OTHER;
    1:             break; 	    
    1:         }
    1:         break;
    1: 
    1:       case eStyleUnit_Coord:
    1:         // According to the CSS2 spec (10.8.1), a positive value
    1:         // "raises" the box by the given distance while a negative value
    1:         // "lowers" the box by the given distance (with zero being the
    1:         // baseline). Since Y coordinates increase towards the bottom of
    1:         // the screen we reverse the sign.
    1:         coordOffset = textStyle->mVerticalAlign.GetCoordValue();
    1:         revisedBaselineY = baselineY - coordOffset;
    1:         pfd->mBounds.y = revisedBaselineY - pfd->mAscent;
    1:         pfd->mVerticalAlign = VALIGN_OTHER;
    1:         break;
    1: 
    1:       case eStyleUnit_Percent:
    1:         // Similar to a length value (eStyleUnit_Coord) except that the
    1:         // percentage is a function of the elements line-height value.
16031:         elementLineHeight = nsHTMLReflowState::CalcLineHeight(frame);
    1:         percentOffset = nscoord(
    1:           textStyle->mVerticalAlign.GetPercentValue() * elementLineHeight
    1:           );
    1:         revisedBaselineY = baselineY - percentOffset;
    1:         pfd->mBounds.y = revisedBaselineY - pfd->mAscent;
    1:         pfd->mVerticalAlign = VALIGN_OTHER;
    1:         break;
    1:     }
    1: 
    1:     // Update minY/maxY for frames that we just placed. Do not factor
    1:     // text into the equation.
    1:     if (pfd->mVerticalAlign == VALIGN_OTHER) {
    1:       // Text frames do not contribute to the min/max Y values for the
    1:       // line (instead their parent frame's font-size contributes).
    1:       // XXXrbs -- relax this restriction because it causes text frames
    1:       //           to jam together when 'font-size-adjust' is enabled
    1:       //           and layout is using dynamic font heights (bug 20394)
    1:       //        -- Note #1: With this code enabled and with the fact that we are not
    1:       //           using Em[Ascent|Descent] as nsDimensions for text metrics in
    1:       //           GFX mean that the discussion in bug 13072 cannot hold.
    1:       //        -- Note #2: We still don't want empty-text frames to interfere.
    1:       //           For example in quirks mode, avoiding empty text frames prevents
    1:       //           "tall" lines around elements like <hr> since the rules of <hr>
    1:       //           in quirks.css have pseudo text contents with LF in them.
    1: #if 0
    1:       if (!pfd->GetFlag(PFD_ISTEXTFRAME)) {
    1: #else
    1:       // Only consider non empty text frames when line-height=normal
    1:       PRBool canUpdate = !pfd->GetFlag(PFD_ISTEXTFRAME);
    1:       if (!canUpdate && pfd->GetFlag(PFD_ISNONWHITESPACETEXTFRAME)) {
 1364:         canUpdate =
 1364:           frame->GetStyleText()->mLineHeight.GetUnit() == eStyleUnit_Normal;
    1:       }
    1:       if (canUpdate) {
    1: #endif
    1:         nscoord yTop, yBottom;
    1:         if (frameSpan) {
    1:           // For spans that were are now placing, use their position
    1:           // plus their already computed min-Y and max-Y values for
    1:           // computing yTop and yBottom.
    1:           yTop = pfd->mBounds.y + frameSpan->mMinY;
    1:           yBottom = pfd->mBounds.y + frameSpan->mMaxY;
    1:         }
    1:         else {
    1:           yTop = pfd->mBounds.y - pfd->mMargin.top;
    1:           yBottom = yTop + logicalHeight;
    1:         }
    1:         if (!preMode &&
 6515:             mPresContext->CompatibilityMode() != eCompatibility_FullStandards &&
    1:             !logicalHeight) {
    1:           // Check if it's a BR frame that is not alone on its line (it
    1:           // is given a height of zero to indicate this), and if so reset
    1:           // yTop and yBottom so that BR frames don't influence the line.
    1:           if (nsGkAtoms::brFrame == frame->GetType()) {
    1:             yTop = VERTICAL_ALIGN_FRAMES_NO_MINIMUM;
    1:             yBottom = VERTICAL_ALIGN_FRAMES_NO_MAXIMUM;
    1:           }
    1:         }
    1:         if (yTop < minY) minY = yTop;
    1:         if (yBottom > maxY) maxY = yBottom;
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:         printf("     [frame]raw: a=%d h=%d bp=%d,%d logical: h=%d leading=%d y=%d minY=%d maxY=%d\n",
    1:                pfd->mAscent, pfd->mBounds.height,
    1:                pfd->mBorderPadding.top, pfd->mBorderPadding.bottom,
    1:                logicalHeight,
    1:                pfd->mSpan ? topLeading : 0,
    1:                pfd->mBounds.y, minY, maxY);
    1: #endif
    1:       }
    1:       if (psd != mRootSpan) {
    1:         frame->SetRect(pfd->mBounds);
    1:       }
    1:     }
    1:     pfd = pfd->mNext;
    1:   }
    1: 
    1:   // Factor in the minimum line-height when handling the root-span for
    1:   // the block.
    1:   if (psd == mRootSpan) {
    1:     // We should factor in the block element's minimum line-height (as
    1:     // defined in section 10.8.1 of the css2 spec) assuming that
    1:     // mZeroEffectiveSpanBox is not set on the root span.  This only happens
    1:     // in some cases in quirks mode:
    1:     //  (1) if the root span contains non-whitespace text directly (this
    1:     //      is handled by mZeroEffectiveSpanBox
    1:     //  (2) if this is the first line of an LI element (whether or not
    1:     //      there is a bullet (NN4/IE5 quirk)
    1:     //  (3) if this is the last line of an LI, DT, or DD element
    1:     //      (The last line before a block also counts, but not before a
    1:     //      BR) (NN4/IE5 quirk)
    1:     PRBool applyMinLH = !(psd->mZeroEffectiveSpanBox); // (1) above
    1:     PRBool isFirstLine = !mLineNumber; // if the line number is 0
    1:     PRBool isLastLine = (!mLineBox->IsLineWrapped() && !GetFlag(LL_LINEENDSINBR));
    1:     PRBool foundLI = PR_FALSE;  // hack to fix bug 50480.
    1:     //XXX: rather than remembering if we've found an LI, we really should be checking
    1:     //     for the existence of a bullet frame.  Likewise, the code below should not
    1:     //     be checking for any particular content tag type, but rather should
    1:     //     be checking for the existence of a bullet frame to determine if it's a list element or not.
    1:     if (!applyMinLH && (isFirstLine || isLastLine)) {
    1:       nsIContent* blockContent = mRootSpan->mFrame->mFrame->GetContent();
    1:       if (blockContent) {
    1:         nsIAtom *blockTagAtom = blockContent->Tag();
    1:         // (2) above, if the first line of LI
    1:         if (isFirstLine && blockTagAtom == nsGkAtoms::li) {
    1:           // if the line is empty, then don't force the min height
    1:           // (see bug 75963)
    1:           if (!IsZeroHeight()) {
    1:             applyMinLH = PR_TRUE;
    1:             foundLI = PR_TRUE;
    1:           }
    1:         }
    1:         // (3) above, if the last line of LI, DT, or DD
    1:         else if (!applyMinLH && isLastLine &&
    1:                  ((blockTagAtom == nsGkAtoms::li) ||
    1:                   (blockTagAtom == nsGkAtoms::dt) ||
    1:                   (blockTagAtom == nsGkAtoms::dd))) {
    1:           applyMinLH = PR_TRUE;
    1:         }
    1:       }
    1:     }
    1:     if (applyMinLH) {
11711:       if (psd->mHasNonemptyContent || preMode || foundLI) {
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:         printf("  [span]==> adjusting min/maxY: currentValues: %d,%d", minY, maxY);
    1: #endif
    1:         nscoord minimumLineHeight = mMinLineHeight;
    1:         nscoord fontAscent, fontHeight;
    1:         fm->GetMaxAscent(fontAscent);
    1:         fm->GetHeight(fontHeight);
    1: 
    1:         nscoord leading = minimumLineHeight - fontHeight;
    1:         nscoord yTop = -fontAscent - leading/2;
    1:         nscoord yBottom = yTop + minimumLineHeight;
    1:         if (yTop < minY) minY = yTop;
    1:         if (yBottom > maxY) maxY = yBottom;
    1: 
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:         printf(" new values: %d,%d\n", minY, maxY);
    1: #endif
    1:       }
    1:       else {
    1:         // XXX issues:
    1:         // [1] BR's on empty lines stop working
    1:         // [2] May not honor css2's notion of handling empty elements
    1:         // [3] blank lines in a pre-section ("\n") (handled with preMode)
    1: 
    1:         // XXX Are there other problems with this?
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:         printf("  [span]==> zapping min/maxY: currentValues: %d,%d newValues: 0,0\n",
    1:                minY, maxY);
    1: #endif
    1:         minY = maxY = 0;
    1:       }
    1:     }
    1:   }
    1: 
    1:   if ((minY == VERTICAL_ALIGN_FRAMES_NO_MINIMUM) ||
    1:       (maxY == VERTICAL_ALIGN_FRAMES_NO_MAXIMUM)) {
    1:     minY = maxY = baselineY;
    1:   }
    1: 
    1:   if ((psd != mRootSpan) && (psd->mZeroEffectiveSpanBox)) {
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:     printf("   [span]adjusting for zeroEffectiveSpanBox\n");
    1:     printf("     Original: minY=%d, maxY=%d, height=%d, ascent=%d, logicalHeight=%d, topLeading=%d, bottomLeading=%d\n",
    1:            minY, maxY, spanFramePFD->mBounds.height,
    1:            spanFramePFD->mAscent,
    1:            psd->mLogicalHeight, psd->mTopLeading, psd->mBottomLeading);
    1: #endif
    1:     nscoord goodMinY = spanFramePFD->mBorderPadding.top - psd->mTopLeading;
    1:     nscoord goodMaxY = goodMinY + psd->mLogicalHeight;
    1:     if (minY > goodMinY) {
    1:       nscoord adjust = minY - goodMinY; // positive
    1: 
    1:       // shrink the logical extents
    1:       psd->mLogicalHeight -= adjust;
    1:       psd->mTopLeading -= adjust;
    1:     }
    1:     if (maxY < goodMaxY) {
    1:       nscoord adjust = goodMaxY - maxY;
    1:       psd->mLogicalHeight -= adjust;
    1:       psd->mBottomLeading -= adjust;
    1:     }
    1:     if (minY > 0) {
    1: 
    1:       // shrink the content by moving its top down.  This is tricky, since
    1:       // the top is the 0 for many coordinates, so what we do is
    1:       // move everything else up.
    1:       spanFramePFD->mAscent -= minY; // move the baseline up
    1:       spanFramePFD->mBounds.height -= minY; // move the bottom up
    1:       psd->mTopLeading += minY;
    1: 
    1:       pfd = psd->mFirstFrame;
    1:       while (nsnull != pfd) {
    1:         pfd->mBounds.y -= minY; // move all the children back up
    1:         pfd->mFrame->SetRect(pfd->mBounds);
    1:         pfd = pfd->mNext;
    1:       }
    1:       maxY -= minY; // since minY is in the frame's own coordinate system
    1:       minY = 0;
    1:     }
    1:     if (maxY < spanFramePFD->mBounds.height) {
    1:       nscoord adjust = spanFramePFD->mBounds.height - maxY;
    1:       spanFramePFD->mBounds.height -= adjust; // move the bottom up
    1:       psd->mBottomLeading += adjust;
    1:     }
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:     printf("     New: minY=%d, maxY=%d, height=%d, ascent=%d, logicalHeight=%d, topLeading=%d, bottomLeading=%d\n",
    1:            minY, maxY, spanFramePFD->mBounds.height,
    1:            spanFramePFD->mAscent,
    1:            psd->mLogicalHeight, psd->mTopLeading, psd->mBottomLeading);
    1: #endif
    1:   }
    1: 
    1:   psd->mMinY = minY;
    1:   psd->mMaxY = maxY;
    1: #ifdef NOISY_VERTICAL_ALIGN
    1:   printf("  [span]==> minY=%d maxY=%d delta=%d maxTopBoxHeight=%d maxBottomBoxHeight=%d\n",
    1:          minY, maxY, maxY - minY, maxTopBoxHeight, maxBottomBoxHeight);
    1: #endif
    1:   if (maxTopBoxHeight > mMaxTopBoxHeight) {
    1:     mMaxTopBoxHeight = maxTopBoxHeight;
    1:   }
    1:   if (maxBottomBoxHeight > mMaxBottomBoxHeight) {
    1:     mMaxBottomBoxHeight = maxBottomBoxHeight;
    1:   }
    1: }
    1: 
    1: static void SlideSpanFrameRect(nsIFrame* aFrame, nscoord aDeltaWidth)
    1: {
    1:   nsRect r = aFrame->GetRect();
    1:   r.x -= aDeltaWidth;
    1:   aFrame->SetRect(r);
    1: }
    1: 
    1: PRBool
    1: nsLineLayout::TrimTrailingWhiteSpaceIn(PerSpanData* psd,
    1:                                        nscoord* aDeltaWidth)
    1: {
    1: #ifndef IBMBIDI
    1: // XXX what about NS_STYLE_DIRECTION_RTL?
    1:   if (NS_STYLE_DIRECTION_RTL == psd->mDirection) {
    1:     *aDeltaWidth = 0;
    1:     return PR_TRUE;
    1:   }
    1: #endif
    1: 
    1:   PerFrameData* pfd = psd->mFirstFrame;
    1:   if (!pfd) {
    1:     *aDeltaWidth = 0;
    1:     return PR_FALSE;
    1:   }
    1:   pfd = pfd->Last();
    1:   while (nsnull != pfd) {
    1: #ifdef REALLY_NOISY_TRIM
    1:     nsFrame::ListTag(stdout, (psd == mRootSpan
    1:                               ? mBlockReflowState->frame
    1:                               : psd->mFrame->mFrame));
    1:     printf(": attempting trim of ");
    1:     nsFrame::ListTag(stdout, pfd->mFrame);
    1:     printf("\n");
    1: #endif
    1:     PerSpanData* childSpan = pfd->mSpan;
    1:     if (childSpan) {
    1:       // Maybe the child span has the trailing white-space in it?
    1:       if (TrimTrailingWhiteSpaceIn(childSpan, aDeltaWidth)) {
    1:         nscoord deltaWidth = *aDeltaWidth;
    1:         if (deltaWidth) {
    1:           // Adjust the child spans frame size
    1:           pfd->mBounds.width -= deltaWidth;
    1:           if (psd != mRootSpan) {
    1:             // When the child span is not a direct child of the block
    1:             // we need to update the child spans frame rectangle
    1:             // because it most likely will not be done again. Spans
    1:             // that are direct children of the block will be updated
    1:             // later, however, because the VerticalAlignFrames method
    1:             // will be run after this method.
    1:             nsIFrame* f = pfd->mFrame;
    1:             nsRect r = f->GetRect();
    1:             r.width -= deltaWidth;
    1:             f->SetRect(r);
    1:           }
    1: 
    1:           // Adjust the right edge of the span that contains the child span
    1:           psd->mX -= deltaWidth;
    1: 
    1:           // Slide any frames that follow the child span over by the
    1:           // right amount. The only thing that can follow the child
    1:           // span is empty stuff, so we are just making things
    1:           // sensible (keeping the combined area honest).
    1:           while (pfd->mNext) {
    1:             pfd = pfd->mNext;
    1:             pfd->mBounds.x -= deltaWidth;
    1:             if (psd != mRootSpan) {
    1:               // When the child span is not a direct child of the block
    1:               // we need to update the child spans frame rectangle
    1:               // because it most likely will not be done again. Spans
    1:               // that are direct children of the block will be updated
    1:               // later, however, because the VerticalAlignFrames method
    1:               // will be run after this method.
    1:               SlideSpanFrameRect(pfd->mFrame, deltaWidth);
    1:             }
    1:           }
    1:         }
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:     else if (!pfd->GetFlag(PFD_ISTEXTFRAME) &&
    1:              !pfd->GetFlag(PFD_SKIPWHENTRIMMINGWHITESPACE)) {
    1:       // If we hit a frame on the end that's not text and not a placeholder,
    1:       // then there is no trailing whitespace to trim. Stop the search.
    1:       *aDeltaWidth = 0;
    1:       return PR_TRUE;
    1:     }
 8514:     else if (pfd->GetFlag(PFD_ISTEXTFRAME)) {
 8514:       // Call TrimTrailingWhiteSpace even on empty textframes because they
 8514:       // might have a soft hyphen which should now appear, changing the frame's
 8514:       // width
 8514:       nsTextFrame::TrimOutput trimOutput = static_cast<nsTextFrame*>(pfd->mFrame)->
 8514:           TrimTrailingWhiteSpace(mBlockReflowState->rendContext);
    1: #ifdef NOISY_TRIM
    1:       nsFrame::ListTag(stdout, (psd == mRootSpan
    1:                                 ? mBlockReflowState->frame
    1:                                 : psd->mFrame->mFrame));
    1:       printf(": trim of ");
    1:       nsFrame::ListTag(stdout, pfd->mFrame);
 8514:       printf(" returned %d\n", trimOutput.mDeltaWidth);
    1: #endif
 8514:       if (trimOutput.mLastCharIsJustifiable && pfd->mJustificationNumSpaces > 0) {
    1:         pfd->mJustificationNumSpaces--;
    1:       }
    1:       
 8514:       if (trimOutput.mChanged) {
 8514:         pfd->SetFlag(PFD_RECOMPUTEOVERFLOW, PR_TRUE);
 8514:       }
 8514: 
 8514:       if (trimOutput.mDeltaWidth) {
 8514:         pfd->mBounds.width -= trimOutput.mDeltaWidth;
    1: 
    1:         // See if the text frame has already been placed in its parent
    1:         if (psd != mRootSpan) {
    1:           // The frame was already placed during psd's
    1:           // reflow. Update the frames rectangle now.
    1:           pfd->mFrame->SetRect(pfd->mBounds);
    1:         }
    1: 
    1:         // Adjust containing span's right edge
 8514:         psd->mX -= trimOutput.mDeltaWidth;
    1: 
    1:         // Slide any frames that follow the text frame over by the
    1:         // right amount. The only thing that can follow the text
    1:         // frame is empty stuff, so we are just making things
    1:         // sensible (keeping the combined area honest).
    1:         while (pfd->mNext) {
    1:           pfd = pfd->mNext;
 8514:           pfd->mBounds.x -= trimOutput.mDeltaWidth;
    1:           if (psd != mRootSpan) {
    1:             // When the child span is not a direct child of the block
    1:             // we need to update the child spans frame rectangle
    1:             // because it most likely will not be done again. Spans
    1:             // that are direct children of the block will be updated
    1:             // later, however, because the VerticalAlignFrames method
    1:             // will be run after this method.
 8514:             SlideSpanFrameRect(pfd->mFrame, trimOutput.mDeltaWidth);
    1:           }
    1:         }
    1:       }
    1: 
 8514:       if (pfd->GetFlag(PFD_ISNONEMPTYTEXTFRAME) || trimOutput.mChanged) {
    1:         // Pass up to caller so they can shrink their span
 8514:         *aDeltaWidth = trimOutput.mDeltaWidth;
    1:         return PR_TRUE;
    1:       }
 8514:     }
    1:     pfd = pfd->mPrev;
    1:   }
    1: 
    1:   *aDeltaWidth = 0;
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsLineLayout::TrimTrailingWhiteSpace()
    1: {
    1:   PerSpanData* psd = mRootSpan;
    1:   nscoord deltaWidth;
    1:   TrimTrailingWhiteSpaceIn(psd, &deltaWidth);
    1:   return 0 != deltaWidth;
    1: }
    1: 
    1: void
    1: nsLineLayout::ComputeJustificationWeights(PerSpanData* aPSD,
    1:                                           PRInt32* aNumSpaces,
    1:                                           PRInt32* aNumLetters)
    1: {
    1:   NS_ASSERTION(aPSD, "null arg");
    1:   NS_ASSERTION(aNumSpaces, "null arg");
    1:   NS_ASSERTION(aNumLetters, "null arg");
    1:   PRInt32 numSpaces = 0;
    1:   PRInt32 numLetters = 0;
    1: 
    1:   for (PerFrameData* pfd = aPSD->mFirstFrame; pfd != nsnull; pfd = pfd->mNext) {
    1: 
    1:     if (PR_TRUE == pfd->GetFlag(PFD_ISTEXTFRAME)) {
    1:       numSpaces += pfd->mJustificationNumSpaces;
    1:       numLetters += pfd->mJustificationNumLetters;
    1:     }
    1:     else if (pfd->mSpan != nsnull) {
    1:       PRInt32 spanSpaces;
    1:       PRInt32 spanLetters;
    1: 
    1:       ComputeJustificationWeights(pfd->mSpan, &spanSpaces, &spanLetters);
    1: 
    1:       numSpaces += spanSpaces;
    1:       numLetters += spanLetters;
    1:     }
    1:   }
    1: 
    1:   *aNumSpaces = numSpaces;
    1:   *aNumLetters = numLetters;
    1: }
    1: 
    1: nscoord 
    1: nsLineLayout::ApplyFrameJustification(PerSpanData* aPSD, FrameJustificationState* aState)
    1: {
    1:   NS_ASSERTION(aPSD, "null arg");
    1:   NS_ASSERTION(aState, "null arg");
    1: 
    1:   nscoord deltaX = 0;
    1:   for (PerFrameData* pfd = aPSD->mFirstFrame; pfd != nsnull; pfd = pfd->mNext) {
    1:     // Don't reposition bullets (and other frames that occur out of X-order?)
    1:     if (!pfd->GetFlag(PFD_ISBULLET)) {
    1:       nscoord dw = 0;
    1:       
    1:       pfd->mBounds.x += deltaX;
    1:       
    1:       if (PR_TRUE == pfd->GetFlag(PFD_ISTEXTFRAME)) {
    1:         if (aState->mTotalWidthForSpaces > 0 &&
    1:             aState->mTotalNumSpaces > 0) {
    1:           aState->mNumSpacesProcessed += pfd->mJustificationNumSpaces;
    1: 
    1:           nscoord newAllocatedWidthForSpaces =
    1:             (aState->mTotalWidthForSpaces*aState->mNumSpacesProcessed)
    1:               /aState->mTotalNumSpaces;
    1:           
    1:           dw += newAllocatedWidthForSpaces - aState->mWidthForSpacesProcessed;
    1: 
    1:           aState->mWidthForSpacesProcessed = newAllocatedWidthForSpaces;
    1:         }
    1: 
    1:         if (aState->mTotalWidthForLetters > 0 &&
    1:             aState->mTotalNumLetters > 0) {
    1:           aState->mNumLettersProcessed += pfd->mJustificationNumLetters;
    1: 
    1:           nscoord newAllocatedWidthForLetters =
    1:             (aState->mTotalWidthForLetters*aState->mNumLettersProcessed)
    1:               /aState->mTotalNumLetters;
    1:           
    1:           dw += newAllocatedWidthForLetters - aState->mWidthForLettersProcessed;
    1: 
    1:           aState->mWidthForLettersProcessed = newAllocatedWidthForLetters;
    1:         }
 6247:         
 6247:         if (dw) {
 6247:           pfd->SetFlag(PFD_RECOMPUTEOVERFLOW, PR_TRUE);
 6247:         }
    1:       }
    1:       else {
    1:         if (nsnull != pfd->mSpan) {
    1:           dw += ApplyFrameJustification(pfd->mSpan, aState);
    1:         }
    1:       }
    1:       
    1:       pfd->mBounds.width += dw;
    1: 
    1:       deltaX += dw;
    1:       pfd->mFrame->SetRect(pfd->mBounds);
    1:     }
    1:   }
    1:   return deltaX;
    1: }
    1: 
    1: void
    1: nsLineLayout::HorizontalAlignFrames(nsRect& aLineBounds,
    1:                                     PRBool aAllowJustify)
    1: {
    1:   PerSpanData* psd = mRootSpan;
 8982:   NS_ASSERTION(psd->mRightEdge != NS_UNCONSTRAINEDSIZE,
 8982:                "shouldn't have unconstrained widths anymore");
 8982:   nscoord availWidth = psd->mRightEdge - psd->mLeftEdge;
    1:   nscoord remainingWidth = availWidth - aLineBounds.width;
    1: #ifdef NOISY_HORIZONTAL_ALIGN
    1:     nsFrame::ListTag(stdout, mBlockReflowState->frame);
    1:     printf(": availWidth=%d lineWidth=%d delta=%d\n",
    1:            availWidth, aLineBounds.width, remainingWidth);
    1: #endif
    1: #ifdef IBMBIDI
    1:   nscoord dx = 0;
    1: #endif
    1: 
    1:   if (remainingWidth > 0)
    1:   {
    1: #ifndef IBMBIDI
    1:     nscoord dx = 0;
    1: #endif
    1:     switch (mTextAlign) {
    1:       case NS_STYLE_TEXT_ALIGN_JUSTIFY:
    1:         // If this is not the last line then go ahead and justify the
    1:         // frames in the line.
    1:         if (aAllowJustify) {
    1:           PRInt32 numSpaces;
    1:           PRInt32 numLetters;
    1:             
    1:           ComputeJustificationWeights(psd, &numSpaces, &numLetters);
    1: 
    1:           if (numSpaces > 0) {
    1:             FrameJustificationState state =
    1:               { numSpaces, numLetters, remainingWidth, 0, 0, 0, 0, 0 };
    1: 
    1:             // Apply the justification, and make sure to update our linebox
    1:             // width to account for it.
    1:             aLineBounds.width += ApplyFrameJustification(psd, &state);
 9806:             remainingWidth = availWidth - aLineBounds.width;
    1:             break;
    1:           }
    1:         }
    1:         // Fall through to the default case if we were told not to
    1:         // justify anything or could not justify to fill the space.
    1: 
    1:       case NS_STYLE_TEXT_ALIGN_DEFAULT:
    1:         if (NS_STYLE_DIRECTION_LTR == psd->mDirection) {
    1:           // default alignment for left-to-right is left so do nothing
    1:           break;
    1:         }
    1:         // Fall through to align right case for default alignment
    1:         // used when the direction is right-to-left.
    1: 
    1:       case NS_STYLE_TEXT_ALIGN_RIGHT:
    1:       case NS_STYLE_TEXT_ALIGN_MOZ_RIGHT:
    1:         dx = remainingWidth;
    1:         break;
    1: 
    1:       case NS_STYLE_TEXT_ALIGN_LEFT:
    1:       case NS_STYLE_TEXT_ALIGN_MOZ_LEFT:
    1:         break;
    1: 
    1:       case NS_STYLE_TEXT_ALIGN_CENTER:
    1:       case NS_STYLE_TEXT_ALIGN_MOZ_CENTER:
    1:         dx = remainingWidth / 2;
    1:         break;
    1:     }
    1: #ifdef IBMBIDI
    1:   }
    1:   else if (remainingWidth < 0) {
    1:     if (NS_STYLE_DIRECTION_RTL == psd->mDirection) {
    1:       dx = remainingWidth;
    1:       psd->mX += dx;
    1:       psd->mLeftEdge += dx;
    1:     }
    1:   }
    1:   PRBool isRTL = ( (NS_STYLE_DIRECTION_RTL == psd->mDirection)
    1:                 && (!psd->mChangedFrameDirection) );
    1:   if (dx || isRTL) {
    1:     nscoord maxX = aLineBounds.XMost() + dx;
    1:     PRBool isVisualRTL = PR_FALSE;
    1: 
    1:     if (isRTL) {
 7726:       if (psd->mLastFrame->GetFlag(PFD_ISBULLET) ) {
 7726:         PerFrameData* bulletPfd = psd->mLastFrame;
 7726:         bulletPfd->mBounds.x -= remainingWidth;
 7726:         bulletPfd->mFrame->SetRect(bulletPfd->mBounds);
 7726:       }
    1:   
    1:       psd->mChangedFrameDirection = PR_TRUE;
    1: 
    1:       isVisualRTL = mPresContext->IsVisualMode();
    1:     }
    1:     if (dx || isVisualRTL)
    1: #else
    1:     if (0 != dx)
    1: #endif
    1:     {
 7726:       for (PerFrameData* pfd = psd->mFirstFrame; pfd; pfd = pfd->mNext) {
    1: #ifdef IBMBIDI
    1:         if (isVisualRTL) {
    1:           // XXXldb Ugh.  Could we handle this earlier so we don't get here?
    1:           maxX = pfd->mBounds.x = maxX - (pfd->mMargin.left + pfd->mBounds.width + pfd->mMargin.right);
    1:         }
    1:         else
    1: #endif // IBMBIDI
    1:           pfd->mBounds.x += dx;
    1:         pfd->mFrame->SetRect(pfd->mBounds);
    1:       }
    1:       aLineBounds.x += dx;
    1:     }
    1: #ifndef IBMBIDI
    1:     if ((NS_STYLE_DIRECTION_RTL == psd->mDirection) &&
    1:         !psd->mChangedFrameDirection) {
    1:       psd->mChangedFrameDirection = PR_TRUE;
    1:   
    1:       PerFrameData* pfd = psd->mFirstFrame;
    1:       PRUint32 maxX = psd->mRightEdge;
    1:       while (nsnull != pfd) {
    1:         pfd->mBounds.x = maxX - (pfd->mMargin.left + pfd->mBounds.width + pfd->mMargin.right);
    1:         pfd->mFrame->SetRect(pfd->mBounds);
    1:         maxX = pfd->mBounds.x;
    1:         pfd = pfd->mNext;
    1:       }
    1:     }
    1: #endif // ndef IBMBIDI
    1:   }
    1: }
    1: 
    1: void
    1: nsLineLayout::RelativePositionFrames(nsRect& aCombinedArea)
    1: {
    1:   RelativePositionFrames(mRootSpan, aCombinedArea);
    1: }
    1: 
    1: void
    1: nsLineLayout::RelativePositionFrames(PerSpanData* psd, nsRect& aCombinedArea)
    1: {
    1:   nsRect combinedAreaResult;
    1:   if (nsnull != psd->mFrame) {
    1:     // The span's overflow area comes in three parts:
    1:     // -- this frame's width and height
    1:     // -- the pfd->mCombinedArea, which is the area of a bullet or the union
    1:     // of a relatively positioned frame's absolute children
    1:     // -- the bounds of all inline descendants
    1:     // The former two parts are computed right here, we gather the descendants
    1:     // below.
 8935:     // At this point psd->mFrame->mBounds might be out of date since
 8935:     // bidi reordering can move and resize the frames. So use the frame's
 8935:     // rect instead of mBounds.
 8935:     nsRect adjustedBounds(nsPoint(0, 0), psd->mFrame->mFrame->GetSize());
15339: 
15339:     // Text-shadow overflow
15339:     if (mPresContext->CompatibilityMode() != eCompatibility_NavQuirks) {
15339:       nsRect shadowRect = nsLayoutUtils::GetTextShadowRectsUnion(adjustedBounds,
15339:                                                                  psd->mFrame->mFrame);
15339:       adjustedBounds.UnionRect(adjustedBounds, shadowRect);
15339:     }
15339: 
    1:     combinedAreaResult.UnionRect(psd->mFrame->mCombinedArea, adjustedBounds);
    1:   }
    1:   else {
    1:     // The minimum combined area for the frames that are direct
    1:     // children of the block starts at the upper left corner of the
    1:     // line and is sized to match the size of the line's bounding box
    1:     // (the same size as the values returned from VerticalAlignFrames)
    1:     combinedAreaResult.x = psd->mLeftEdge;
    1:     // If this turns out to be negative, the rect will be treated as empty.
    1:     // Which is just fine.
    1:     combinedAreaResult.width = psd->mX - combinedAreaResult.x;
    1:     combinedAreaResult.y = mTopEdge;
    1:     combinedAreaResult.height = mFinalLineHeight;
    1:   }
    1: 
    1:   for (PerFrameData* pfd = psd->mFirstFrame; pfd; pfd = pfd->mNext) {
    1:     nsIFrame* frame = pfd->mFrame;
 8935:     nsPoint origin = frame->GetPosition();
    1: 
    1:     // Adjust the origin of the frame
    1:     if (pfd->GetFlag(PFD_RELATIVEPOS)) {
    1:       // right and bottom are handled by
    1:       // nsHTMLReflowState::ComputeRelativeOffsets
    1:       nsPoint change(pfd->mOffsets.left, pfd->mOffsets.top);
    1:       origin += change;
 8935:       frame->SetPosition(origin);
    1:     }
    1: 
    1:     // We must position the view correctly before positioning its
    1:     // descendants so that widgets are positioned properly (since only
    1:     // some views have widgets).
    1:     if (frame->HasView())
    1:       nsContainerFrame::SyncFrameViewAfterReflow(mPresContext, frame,
    1:                                                  frame->GetView(),
    1:                                                  &pfd->mCombinedArea, //ignored
    1:                                                  NS_FRAME_NO_SIZE_VIEW);
    1: 
    1:     // Note: the combined area of a child is in its coordinate
    1:     // system. We adjust the childs combined area into our coordinate
    1:     // system before computing the aggregated value by adding in
    1:     // <b>x</b> and <b>y</b> which were computed above.
    1:     nsRect r;
    1:     if (pfd->mSpan) {
    1:       // Compute a new combined area for the child span before
    1:       // aggregating it into our combined area.
    1:       RelativePositionFrames(pfd->mSpan, r);
    1:     } else {
 6247:       r = pfd->mCombinedArea;
 7717:       if (pfd->GetFlag(PFD_ISTEXTFRAME)) {
 6247:         if (pfd->GetFlag(PFD_RECOMPUTEOVERFLOW)) {
 6247:           nsTextFrame* f = static_cast<nsTextFrame*>(frame);
 6247:           r = f->RecomputeOverflowRect();
 6247:         }
 6247:         frame->FinishAndStoreOverflow(&r, frame->GetSize());
 7717:       }
    1: 
    1:       // If we have something that's not an inline but with a complex frame
    1:       // hierarchy inside that contains views, they need to be
    1:       // positioned.
    1:       // All descendant views must be repositioned even if this frame
    1:       // does have a view in case this frame's view does not have a
    1:       // widget and some of the descendant views do have widgets --
    1:       // otherwise the widgets won't be repositioned.
    1:       nsContainerFrame::PositionChildViews(frame);
    1:     }
    1: 
    1:     // Do this here (rather than along with NS_FRAME_OUTSIDE_CHILDREN
    1:     // handling below) so we get leaf frames as well.  No need to worry
    1:     // about the root span, since it doesn't have a frame.
    1:     if (frame->HasView())
    1:       nsContainerFrame::SyncFrameViewAfterReflow(mPresContext, frame,
    1:                                                  frame->GetView(), &r,
    1:                                                  NS_FRAME_NO_MOVE_VIEW);
    1: 
    1:     combinedAreaResult.UnionRect(combinedAreaResult, r + origin);
    1:   }
    1: 
    1:   // If we just computed a spans combined area, we need to update its
    1:   // NS_FRAME_OUTSIDE_CHILDREN bit..
    1:   if (psd->mFrame) {
    1:     PerFrameData* spanPFD = psd->mFrame;
    1:     nsIFrame* frame = spanPFD->mFrame;
    1:     frame->FinishAndStoreOverflow(&combinedAreaResult, frame->GetSize());
    1:   }
    1:   aCombinedArea = combinedAreaResult;
    1: }
11780: 
11780: void
11780: nsLineLayout::CombineTextDecorations(nsPresContext* aPresContext,
11780:                                      PRUint8 aDecorations,
11780:                                      nsIFrame* aFrame,
11780:                                      nsRect& aCombinedArea,
11780:                                      nscoord aAscentOverride,
11780:                                      float aUnderlineSizeRatio)
11780: {
11780:   if (!(aDecorations & (NS_STYLE_TEXT_DECORATION_UNDERLINE |
11780:                         NS_STYLE_TEXT_DECORATION_OVERLINE |
11780:                         NS_STYLE_TEXT_DECORATION_LINE_THROUGH)))
11780:     return;
11780: 
11780:   nsCOMPtr<nsIFontMetrics> fm;
11780:   nsLayoutUtils::GetFontMetricsForFrame(aFrame, getter_AddRefs(fm));
12989:   nsIThebesFontMetrics* tfm = static_cast<nsIThebesFontMetrics*>(fm.get());
12989:   gfxFontGroup* fontGroup = tfm->GetThebesFontGroup();
12989:   gfxFont* firstFont = fontGroup->GetFontAt(0);
12989:   if (!firstFont)
12989:     return; // OOM
12989:   const gfxFont::Metrics& metrics = firstFont->GetMetrics();
12989: 
12989:   gfxFloat ascent = aAscentOverride == 0 ? metrics.maxAscent :
12989:                       aPresContext->AppUnitsToGfxUnits(aAscentOverride);
11780:   nsRect decorationArea;
11780:   if (aDecorations & (NS_STYLE_TEXT_DECORATION_UNDERLINE |
11780:                       NS_STYLE_TEXT_DECORATION_OVERLINE)) {
11780:     gfxSize size(aPresContext->AppUnitsToGfxUnits(aCombinedArea.width),
12989:                  metrics.underlineSize);
11780:     if (aDecorations & NS_STYLE_TEXT_DECORATION_OVERLINE) {
11780:       decorationArea =
11780:         nsCSSRendering::GetTextDecorationRect(aPresContext, size, ascent,
14210:                           metrics.maxAscent, NS_STYLE_TEXT_DECORATION_OVERLINE,
11780:                           NS_STYLE_BORDER_STYLE_SOLID);
11780:       aCombinedArea.UnionRect(aCombinedArea, decorationArea);
11780:     }
11780:     if (aDecorations & NS_STYLE_TEXT_DECORATION_UNDERLINE) {
12989:       aUnderlineSizeRatio = PR_MAX(aUnderlineSizeRatio, 1.0f);
11780:       size.height *= aUnderlineSizeRatio;
12989:       gfxFloat underlineOffset = fontGroup->GetUnderlineOffset();
11780:       decorationArea =
11780:         nsCSSRendering::GetTextDecorationRect(aPresContext, size, ascent,
12989:                           underlineOffset,
12989:                           NS_STYLE_TEXT_DECORATION_UNDERLINE,
11780:                           NS_STYLE_BORDER_STYLE_SOLID);
11780:       aCombinedArea.UnionRect(aCombinedArea, decorationArea);
11780:     }
11780:   }
11780:   if (aDecorations & NS_STYLE_TEXT_DECORATION_LINE_THROUGH) {
11780:     gfxSize size(aPresContext->AppUnitsToGfxUnits(aCombinedArea.width),
12989:                  metrics.strikeoutSize);
11780:     decorationArea =
11780:       nsCSSRendering::GetTextDecorationRect(aPresContext, size, ascent,
12989:                         metrics.strikeoutOffset,
12989:                         NS_STYLE_TEXT_DECORATION_LINE_THROUGH,
11780:                         NS_STYLE_BORDER_STYLE_SOLID);
11780:     aCombinedArea.UnionRect(aCombinedArea, decorationArea);
11780:   }
11780: }
