33486: /* vim: se cin sw=2 ts=2 et : */
33486: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
33486:  *
33486:  * ***** BEGIN LICENSE BLOCK *****
33486:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
33486:  *
33486:  * The contents of this file are subject to the Mozilla Public License Version
33486:  * 1.1 (the "License"); you may not use this file except in compliance with
33486:  * the License. You may obtain a copy of the License at
33486:  * http://www.mozilla.org/MPL/
33486:  *
33486:  * Software distributed under the License is distributed on an "AS IS" basis,
33486:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
33486:  * for the specific language governing rights and limitations under the
33486:  * License.
33486:  *
33486:  * The Original Code is mozilla.org code.
33486:  *
33486:  * The Initial Developer of the Original Code is
33486:  * Mozilla Foundation.
33486:  * Portions created by the Initial Developer are Copyright (C) 2009
33486:  * the Initial Developer. All Rights Reserved.
33486:  *
33486:  * Contributor(s):
33486:  *   Rob Arnold <tellrob@gmail.com>
33486:  *
33486:  * Alternatively, the contents of this file may be used under the terms of
33486:  * either the GNU General Public License Version 2 or later (the "GPL"), or
33486:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
33486:  * in which case the provisions of the GPL or the LGPL are applicable instead
33486:  * of those above. If you wish to allow use of your version of this file only
33486:  * under the terms of either the GPL or the LGPL, and not to allow others to
33486:  * use your version of this file under the terms of the MPL, indicate your
33486:  * decision by deleting the provisions above and replace them with the notice
33486:  * and other provisions required by the GPL or the LGPL. If you do not delete
33486:  * the provisions above, a recipient may use your version of this file under
33486:  * the terms of any one of the MPL, the GPL or the LGPL.
33486:  *
33486:  * ***** END LICENSE BLOCK ***** */
33486: 
33486: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486: 
33486: #include "TaskbarTabPreview.h"
33486: #include "nsWindowGFX.h"
33486: #include "nsUXThemeData.h"
33486: #include <nsITaskbarPreviewController.h>
33486: 
33486: #define TASKBARPREVIEW_HWNDID L"TaskbarTabPreviewHwnd"
33486: 
33486: namespace mozilla {
33486: namespace widget {
33486: 
33486: NS_IMPL_ISUPPORTS1(TaskbarTabPreview, nsITaskbarTabPreview)
33486: 
33486: const PRUnichar *const kWindowClass = L"MozillaTaskbarPreviewClass";
33486: 
33486: TaskbarTabPreview::TaskbarTabPreview(ITaskbarList4 *aTaskbar, nsITaskbarPreviewController *aController, HWND aHWND, nsIDocShell *aShell)
33486:   : TaskbarPreview(aTaskbar, aController, aHWND, aShell),
33486:     mProxyWindow(NULL),
33486:     mIcon(NULL),
33486:     mRegistered(PR_FALSE)
33486: {
39175:   WindowHook &hook = GetWindowHook();
39175:   hook.AddMonitor(WM_WINDOWPOSCHANGED, MainWindowHook, this);
33486: }
33486: 
33486: TaskbarTabPreview::~TaskbarTabPreview() {
33486:   if (mIcon) {
33486:     ::DestroyIcon(mIcon);
33486:     mIcon = NULL;
33486:   }
41139:   if (mWnd)
41139:     DetachFromNSWindow();
33486: }
33486: 
33486: nsresult
33486: TaskbarTabPreview::ShowActive(PRBool active) {
33486:   NS_ASSERTION(mVisible && CanMakeTaskbarCalls(), "ShowActive called on invisible window or before taskbar calls can be made for this window");
33486:   return FAILED(mTaskbar->SetTabActive(active ? mProxyWindow : NULL, mWnd, 0))
33486:        ? NS_ERROR_FAILURE
33486:        : NS_OK;
33486: }
33486: 
33486: HWND &
33486: TaskbarTabPreview::PreviewWindow() {
33486:   return mProxyWindow;
33486: }
33486: 
33486: nativeWindow
33486: TaskbarTabPreview::GetHWND() {
33486:   return mProxyWindow;
33486: }
33486: 
33486: void
33486: TaskbarTabPreview::EnsureRegistration() {
33486:   NS_ASSERTION(mVisible && CanMakeTaskbarCalls(), "EnsureRegistration called when it is not safe to do so");
33486: 
33486:   (void) UpdateTaskbarProperties();
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarTabPreview::GetTitle(nsAString &aTitle) {
33486:   aTitle = mTitle;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarTabPreview::SetTitle(const nsAString &aTitle) {
33486:   mTitle = aTitle;
33486:   return mVisible ? UpdateTitle() : NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarTabPreview::SetIcon(imgIContainer *icon) {
33486:   HICON hIcon = NULL;
33486:   if (icon) {
33486:     nsresult rv;
33486:     rv = nsWindowGfx::CreateIcon(icon, PR_FALSE, 0, 0, &hIcon);
33486:     NS_ENSURE_SUCCESS(rv, rv);
33486:   }
33486: 
33486:   if (mIcon)
33486:     ::DestroyIcon(mIcon);
33486:   mIcon = hIcon;
33486:   mIconImage = icon;
33486:   return mVisible ? UpdateIcon() : NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarTabPreview::GetIcon(imgIContainer **icon) {
33965:   NS_IF_ADDREF(*icon = mIconImage);
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarTabPreview::Move(nsITaskbarTabPreview *aNext) {
33486:   if (aNext == this)
33486:     return NS_ERROR_INVALID_ARG;
33486:   mNext = aNext;
33486:   return CanMakeTaskbarCalls() ? UpdateNext() : NS_OK;
33486: }
33486: 
33486: nsresult
33486: TaskbarTabPreview::UpdateTaskbarProperties() {
33486:   if (mRegistered)
33486:     return NS_OK;
33486: 
33486:   if (FAILED(mTaskbar->RegisterTab(mProxyWindow, mWnd)))
33486:     return NS_ERROR_FAILURE;
33486: 
33486:   nsresult rv = UpdateNext();
33486:   NS_ENSURE_SUCCESS(rv, rv);
33486:   rv = TaskbarPreview::UpdateTaskbarProperties();
33486:   mRegistered = PR_TRUE;
33486:   return rv;
33486: }
33486: 
33486: LRESULT
33486: TaskbarTabPreview::WndProc(UINT nMsg, WPARAM wParam, LPARAM lParam) {
33486:   nsRefPtr<TaskbarTabPreview> kungFuDeathGrip(this);
33486:   switch (nMsg) {
33486:     case WM_CREATE:
33486:       TaskbarPreview::EnableCustomDrawing(mProxyWindow, PR_TRUE);
33486:       return 0;
33486:     case WM_CLOSE:
33486:       mController->OnClose();
33486:       return 0;
33486:     case WM_ACTIVATE:
39177:       if (LOWORD(wParam) == WA_ACTIVE) {
33486:         PRBool activateWindow;
33486:         nsresult rv = mController->OnActivate(&activateWindow);
33486:         if (NS_SUCCEEDED(rv) && activateWindow) {
33486:           ::SetActiveWindow(mWnd);
33486:           if (::IsIconic(mWnd))
33486:             ::ShowWindow(mWnd, SW_RESTORE);
33486:           else
33486:             ::BringWindowToTop(mWnd);
33486:         }
33486:       }
33486:       return 0;
33486:     case WM_GETICON:
33486:       return (LRESULT)mIcon;
39177:     case WM_SYSCOMMAND:
39177:       // Forward syscommands like restore/minimize/maximize to the container
39177:       // window. Do not forward close since that's intended for the tab.
39177:       return wParam == SC_CLOSE
39177:            ? ::DefWindowProcW(mProxyWindow, WM_SYSCOMMAND, wParam, lParam)
39177:            : ::SendMessageW(mWnd, WM_SYSCOMMAND, wParam, lParam);
39177:       return 0;
33486:   }
33486:   return TaskbarPreview::WndProc(nMsg, wParam, lParam);
33486: }
33486: 
33486: /* static */
33486: LRESULT CALLBACK
33486: TaskbarTabPreview::GlobalWndProc(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam) {
33486:   TaskbarTabPreview *preview(nsnull);
33486:   if (nMsg == WM_CREATE) {
33486:     CREATESTRUCT *cs = reinterpret_cast<CREATESTRUCT*>(lParam);
33486:     preview = reinterpret_cast<TaskbarTabPreview*>(cs->lpCreateParams);
33486:     if (!::SetPropW(hWnd, TASKBARPREVIEW_HWNDID, preview))
33486:       NS_ERROR("Could not associate native window with tab preview");
33486:     preview->mProxyWindow = hWnd;
33486:   } else {
33486:     preview = reinterpret_cast<TaskbarTabPreview*>(::GetPropW(hWnd, TASKBARPREVIEW_HWNDID));
33486:   }
33486: 
33486:   if (preview)
33486:     return preview->WndProc(nMsg, wParam, lParam);
33486:   return ::DefWindowProcW(hWnd, nMsg, wParam, lParam);
33486: }
33486: 
33486: nsresult
33486: TaskbarTabPreview::Enable() {
33486:   WNDCLASSW wc;
33486:   HINSTANCE module = GetModuleHandle(NULL);
33486: 
33486:   if (!GetClassInfoW(module, kWindowClass, &wc)) {
33486:     wc.style         = 0;
33486:     wc.lpfnWndProc   = GlobalWndProc;
33486:     wc.cbClsExtra    = 0;
33486:     wc.cbWndExtra    = 0;
33486:     wc.hInstance     = module;
33486:     wc.hIcon         = NULL;
33486:     wc.hCursor       = NULL;
33486:     wc.hbrBackground = (HBRUSH) NULL;
33486:     wc.lpszMenuName  = (LPCWSTR) NULL;
33486:     wc.lpszClassName = kWindowClass;
33486:     RegisterClassW(&wc);
33486:   }
33486:   ::CreateWindowW(kWindowClass, L"TaskbarPreviewWindow",
39177:                   WS_CAPTION | WS_SYSMENU, 0, 0, 200, 60, NULL, NULL, module, this);
33486:   // GlobalWndProc will set mProxyWindow so that WM_CREATE can have a valid HWND
33486:   if (!mProxyWindow)
33486:     return NS_ERROR_INVALID_ARG;
33486: 
39175:   UpdateProxyWindowStyle();
39175: 
33486:   nsresult rv = TaskbarPreview::Enable();
33486:   nsresult rvUpdate;
33486:   rvUpdate = UpdateTitle();
33486:   if (NS_FAILED(rvUpdate))
33486:     rv = rvUpdate;
33486: 
33486:   rvUpdate = UpdateIcon();
33486:   if (NS_FAILED(rvUpdate))
33486:     rv = rvUpdate;
33486: 
33486:   return rv;
33486: }
33486: 
33486: nsresult
33486: TaskbarTabPreview::Disable() {
33486:   TaskbarPreview::Disable();
33486: 
33486:   if (FAILED(mTaskbar->UnregisterTab(mProxyWindow)))
33486:     return NS_ERROR_FAILURE;
33486:   mRegistered = PR_FALSE;
33486: 
33486:   // TaskbarPreview::WndProc will set mProxyWindow to null
33486:   if (!DestroyWindow(mProxyWindow))
33486:     return NS_ERROR_FAILURE;
33486:   mProxyWindow = NULL;
33486:   return NS_OK;
33486: }
33486: 
33486: void
41139: TaskbarTabPreview::DetachFromNSWindow() {
33486:   (void) SetVisible(PR_FALSE);
39175:   WindowHook &hook = GetWindowHook();
39175:   hook.RemoveMonitor(WM_WINDOWPOSCHANGED, MainWindowHook, this);
39175: 
41139:   TaskbarPreview::DetachFromNSWindow();
33486: }
33486: 
39175: /* static */
39175: PRBool
39175: TaskbarTabPreview::MainWindowHook(void *aContext,
39175:                                   HWND hWnd, UINT nMsg,
39175:                                   WPARAM wParam, LPARAM lParam,
39175:                                   LRESULT *aResult) {
39175:   if (nMsg == WM_WINDOWPOSCHANGED) {
39175:     TaskbarTabPreview *preview = reinterpret_cast<TaskbarTabPreview*>(aContext);
39175:     WINDOWPOS *pos = reinterpret_cast<WINDOWPOS*>(lParam);
39175:     if (SWP_FRAMECHANGED == (pos->flags & SWP_FRAMECHANGED))
39175:       preview->UpdateProxyWindowStyle();
39175:   } else {
39175:     NS_NOTREACHED("Style changed hook fired on non-style changed message");
39175:   }
39175:   return PR_FALSE;
39175: }
39175: 
39175: void
39175: TaskbarTabPreview::UpdateProxyWindowStyle() {
39175:   if (!mProxyWindow)
39175:     return;
39175: 
39175:   DWORD minMaxMask = WS_MINIMIZE | WS_MAXIMIZE;
39175:   DWORD windowStyle = GetWindowLongW(mWnd, GWL_STYLE);
39175: 
39175:   DWORD proxyStyle = GetWindowLongW(mProxyWindow, GWL_STYLE);
39175:   proxyStyle &= ~minMaxMask;
39175:   proxyStyle |= windowStyle & minMaxMask;
39175:   SetWindowLongW(mProxyWindow, GWL_STYLE, proxyStyle);
39175: 
39175:   DWORD exStyle = (WS_MAXIMIZE == (windowStyle & WS_MAXIMIZE)) ? WS_EX_TOOLWINDOW : 0;
39175:   SetWindowLongW(mProxyWindow, GWL_EXSTYLE, exStyle);
39175: }
39175: 
33486: nsresult
33486: TaskbarTabPreview::UpdateTitle() {
33486:   NS_ASSERTION(mVisible, "UpdateTitle called on invisible preview");
33486: 
33486:   if (!::SetWindowTextW(mProxyWindow, mTitle.get()))
33486:     return NS_ERROR_FAILURE;
33486:   return NS_OK;
33486: }
33486: 
33486: nsresult
33486: TaskbarTabPreview::UpdateIcon() {
33486:   NS_ASSERTION(mVisible, "UpdateIcon called on invisible preview");
33486: 
33486:   ::SendMessageW(mProxyWindow, WM_SETICON, ICON_SMALL, (LPARAM)mIcon);
33486: 
33486:   return NS_OK;
33486: }
33486: 
33486: nsresult
33486: TaskbarTabPreview::UpdateNext() {
33486:   NS_ASSERTION(CanMakeTaskbarCalls() && mVisible, "UpdateNext called on invisible tab preview");
33486:   HWND hNext = NULL;
33486:   if (mNext) {
33486:     PRBool visible;
33486:     nsresult rv = mNext->GetVisible(&visible);
33486: 
33486:     NS_ENSURE_SUCCESS(rv, rv);
33486: 
33486:     // Can only move next to enabled previews
33486:     if (!visible)
33486:       return NS_ERROR_FAILURE;
33486: 
33486:     hNext = (HWND)mNext->GetHWND();
33486: 
33486:     // hNext must be registered with the taskbar if the call is to succeed
33486:     mNext->EnsureRegistration();
33486:   }
33486:   if (FAILED(mTaskbar->SetTabOrder(mProxyWindow, hNext)))
33486:     return NS_ERROR_FAILURE;
33486:   return NS_OK;
33486: }
33486: 
33486: 
33486: } // namespace widget
33486: } // namespace mozilla
33486: 
33486: #endif // MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
