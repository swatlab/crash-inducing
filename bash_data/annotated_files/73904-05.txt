35117: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35117:  * vim: set ts=8 sw=4 et tw=99:
35117:  *
35117:  * ***** BEGIN LICENSE BLOCK *****
35117:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35117:  *
35117:  * The contents of this file are subject to the Mozilla Public License Version
35117:  * 1.1 (the "License"); you may not use this file except in compliance with
35117:  * the License. You may obtain a copy of the License at
35117:  * http://www.mozilla.org/MPL/
35117:  *
35117:  * Software distributed under the License is distributed on an "AS IS" basis,
35117:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35117:  * for the specific language governing rights and limitations under the
35117:  * License.
35117:  *
35117:  * The Original Code is Mozilla Communicator client code, released
35117:  * March 31, 1998.
35117:  *
35117:  * The Initial Developer of the Original Code is
35117:  * Netscape Communications Corporation.
35117:  * Portions created by the Initial Developer are Copyright (C) 1998
35117:  * the Initial Developer. All Rights Reserved.
35117:  *
35117:  * Contributor(s):
35117:  *
35117:  * Alternatively, the contents of this file may be used under the terms of
35117:  * either of the GNU General Public License Version 2 or later (the "GPL"),
35117:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35117:  * in which case the provisions of the GPL or the LGPL are applicable instead
35117:  * of those above. If you wish to allow use of your version of this file only
35117:  * under the terms of either the GPL or the LGPL, and not to allow others to
35117:  * use your version of this file under the terms of the MPL, indicate your
35117:  * decision by deleting the provisions above and replace them with the notice
35117:  * and other provisions required by the GPL or the LGPL. If you do not delete
35117:  * the provisions above, a recipient may use your version of this file under
35117:  * the terms of any one of the MPL, the GPL or the LGPL.
35117:  *
35117:  * ***** END LICENSE BLOCK ***** */
35117: 
35117: #ifndef jsobjinlines_h___
35117: #define jsobjinlines_h___
35117: 
52503: #include <new>
40901: #include "jsdate.h"
52503: #include "jsfun.h"
40901: #include "jsiter.h"
52503: #include "jslock.h"
40900: #include "jsobj.h"
53555: #include "jsprobes.h"
52503: #include "jspropertytree.h"
63085: #include "jsproxy.h"
35117: #include "jsscope.h"
47497: #include "jsstaticcheck.h"
68896: #include "jstypedarray.h"
42693: #include "jsxml.h"
42693: 
52503: /* Headers included for inline implementations used by this header. */
52503: #include "jsbool.h"
47447: #include "jscntxt.h"
52503: #include "jsnum.h"
64296: #include "jsscriptinlines.h"
52503: #include "jsstr.h"
40858: 
69639: #include "vm/GlobalObject.h"
69639: 
63085: #include "jsfuninlines.h"
54707: #include "jsgcinlines.h"
54707: #include "jsprobes.h"
64345: #include "jsscopeinlines.h"
54707: 
54563: inline bool
54563: JSObject::preventExtensions(JSContext *cx, js::AutoIdVector *props)
52503: {
54563:     JS_ASSERT(isExtensible());
54563: 
54563:     if (js::FixOp fix = getOps()->fix) {
54563:         bool success;
54563:         if (!fix(cx, this, &success, props))
54563:             return false;
54563:         if (!success) {
54563:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_CHANGE_EXTENSIBILITY);
54563:             return false;
54563:         }
54563:     } else {
54563:         if (!GetPropertyNames(cx, this, JSITER_HIDDEN | JSITER_OWNONLY, props))
54563:             return false;
54563:     }
54563: 
52503:     if (isNative())
54563:         extensibleShapeChange(cx);
54563: 
54563:     flags |= NOT_EXTENSIBLE;
54563:     return true;
52503: }
52503: 
52503: inline bool
57748: JSObject::brand(JSContext *cx)
52503: {
52503:     JS_ASSERT(!generic());
52503:     JS_ASSERT(!branded());
52503:     JS_ASSERT(isNative());
52503:     generateOwnShape(cx);
52503:     if (js_IsPropertyCacheDisabled(cx))  // check for rt->shapeGen overflow
52503:         return false;
52503:     flags |= BRANDED;
52503:     return true;
52503: }
52503: 
52503: inline bool
52503: JSObject::unbrand(JSContext *cx)
52503: {
52503:     JS_ASSERT(isNative());
59227:     if (branded()) {
59227:         generateOwnShape(cx);
59227:         if (js_IsPropertyCacheDisabled(cx))  // check for rt->shapeGen overflow
59227:             return false;
59227:         flags &= ~BRANDED;
59227:     }
52503:     setGeneric();
52503:     return true;
52503: }
52503: 
54707: inline void
57806: JSObject::syncSpecialEquality()
57806: {
57806:     if (clasp->ext.equality)
57806:         flags |= JSObject::HAS_EQUALITY;
57806: }
57806: 
57806: inline void
57817: JSObject::finalize(JSContext *cx)
54707: {
54707:     /* Cope with stillborn objects that have no map. */
68935:     if (isNewborn())
54707:         return;
54707: 
73746:     js::Probes::finalizeObject(this);
73746: 
54707:     /* Finalize obj first, in case it needs map and slots. */
54707:     js::Class *clasp = getClass();
54707:     if (clasp->finalize)
54707:         clasp->finalize(cx, this);
54707: 
54707:     finish(cx);
54707: }
54707: 
52503: /* 
64296:  * Initializer for Call objects for functions and eval frames. Set class,
64296:  * parent, map, and shape, and allocate slots.
64296:  */
64296: inline void
64364: JSObject::initCall(JSContext *cx, const js::Bindings &bindings, JSObject *parent)
64296: {
64296:     init(cx, &js_CallClass, NULL, parent, NULL, false);
68935:     lastProp = bindings.lastShape();
64296: 
64296:     /*
64296:      * If |bindings| is for a function that has extensible parents, that means
64296:      * its Call should have its own shape; see js::Bindings::extensibleParents.
64296:      */
64364:     if (bindings.extensibleParents())
64296:         setOwnShape(js_GenerateShape(cx));
64296:     else
69637:         objShape = lastProp->shapeid;
64296: }
64296: 
64296: /*
64296:  * Initializer for cloned block objects. Set class, prototype, frame, map, and
64296:  * shape.
64296:  */
64296: inline void
69223: JSObject::initClonedBlock(JSContext *cx, JSObject *proto, js::StackFrame *frame)
64296: {
64296:     init(cx, &js_BlockClass, proto, NULL, frame, false);
64296: 
64296:     /* Cloned blocks copy their prototype's map; it had better be shareable. */
64296:     JS_ASSERT(!proto->inDictionaryMode() || proto->lastProp->frozen());
68935:     lastProp = proto->lastProp;
64296: 
64296:     /*
64296:      * If the prototype has its own shape, that means the clone should, too; see
64296:      * js::Bindings::extensibleParents.
64296:      */
64296:     if (proto->hasOwnShape())
64296:         setOwnShape(js_GenerateShape(cx));
64296:     else
69637:         objShape = lastProp->shapeid;
64296: }
64296: 
64296: /* 
64296:  * Mark a compile-time block as OWN_SHAPE, indicating that its run-time clones
64296:  * also need unique shapes. See js::Bindings::extensibleParents.
64296:  */
64296: inline void
64296: JSObject::setBlockOwnShape(JSContext *cx) {
64296:     JS_ASSERT(isStaticBlock());
64296:     setOwnShape(js_GenerateShape(cx));
64296: }
64296: 
64296: /*
52503:  * Property read barrier for deferred cloning of compiler-created function
52503:  * objects optimized as typically non-escaping, ad-hoc methods in obj.
52503:  */
62790: inline const js::Shape *
52503: JSObject::methodReadBarrier(JSContext *cx, const js::Shape &shape, js::Value *vp)
52503: {
52503:     JS_ASSERT(canHaveMethodBarrier());
52503:     JS_ASSERT(hasMethodBarrier());
52503:     JS_ASSERT(nativeContains(shape));
52503:     JS_ASSERT(shape.isMethod());
68893:     JS_ASSERT(shape.methodObject() == vp->toObject());
62588:     JS_ASSERT(shape.writable());
62588:     JS_ASSERT(shape.slot != SHAPE_INVALID_SLOT);
62588:     JS_ASSERT(shape.hasDefaultSetter() || shape.setterOp() == js_watch_set);
62588:     JS_ASSERT(!isGlobal());  /* i.e. we are not changing the global shape */
52503: 
52503:     JSObject *funobj = &vp->toObject();
62790:     JSFunction *fun = funobj->getFunctionPrivate();
62790:     JS_ASSERT(fun == funobj);
62790:     JS_ASSERT(FUN_NULL_CLOSURE(fun));
52503: 
52503:     funobj = CloneFunctionObject(cx, fun, funobj->getParent());
52503:     if (!funobj)
62790:         return NULL;
52503:     funobj->setMethodObj(*this);
52503: 
62588:     /*
62588:      * Replace the method property with an ordinary data property. This is
62588:      * equivalent to this->setProperty(cx, shape.id, vp) except that any
62588:      * watchpoint on the property is not triggered.
62588:      */
62588:     uint32 slot = shape.slot;
62588:     const js::Shape *newshape = methodShapeChange(cx, shape);
62588:     if (!newshape)
62588:         return NULL;
62588:     JS_ASSERT(!newshape->isMethod());
62588:     JS_ASSERT(newshape->slot == slot);
52503:     vp->setObject(*funobj);
62588:     nativeSetSlot(slot, *vp);
62790:     return newshape;
52503: }
52503: 
52503: static JS_ALWAYS_INLINE bool
52503: ChangesMethodValue(const js::Value &prev, const js::Value &v)
52503: {
52503:     JSObject *prevObj;
52503:     return prev.isObject() && (prevObj = &prev.toObject())->isFunction() &&
52503:            (!v.isObject() || &v.toObject() != prevObj);
52503: }
52503: 
60797: inline const js::Shape *
52503: JSObject::methodWriteBarrier(JSContext *cx, const js::Shape &shape, const js::Value &v)
52503: {
59227:     if (brandedOrHasMethodBarrier() && shape.slot != SHAPE_INVALID_SLOT) {
56567:         const js::Value &prev = nativeGetSlot(shape.slot);
52503: 
72559:         if (ChangesMethodValue(prev, v))
52503:             return methodShapeChange(cx, shape);
52503:     }
60797:     return &shape;
52503: }
52503: 
52503: inline bool
52503: JSObject::methodWriteBarrier(JSContext *cx, uint32 slot, const js::Value &v)
52503: {
59227:     if (brandedOrHasMethodBarrier()) {
56567:         const js::Value &prev = nativeGetSlot(slot);
52503: 
72559:         if (ChangesMethodValue(prev, v))
52503:             return methodShapeChange(cx, slot);
52503:     }
52503:     return true;
52503: }
52503: 
52503: inline bool
52503: JSObject::ensureClassReservedSlots(JSContext *cx)
52503: {
52503:     return !nativeEmpty() || ensureClassReservedSlotsForEmptyObject(cx);
52503: }
52503: 
48470: inline js::Value
47404: JSObject::getReservedSlot(uintN index) const
47404: {
55746:     return (index < numSlots()) ? getSlot(index) : js::UndefinedValue();
47404: }
47404: 
40901: inline bool
48676: JSObject::canHaveMethodBarrier() const
48676: {
48676:     return isObject() || isFunction() || isPrimitive() || isDate();
48676: }
48676: 
48676: inline bool
40901: JSObject::isPrimitive() const
40901: {
40901:     return isNumber() || isString() || isBoolean();
40901: }
40901: 
48470: inline const js::Value &
40901: JSObject::getPrimitiveThis() const
40901: {
40901:     JS_ASSERT(isPrimitive());
55746:     return getSlot(JSSLOT_PRIMITIVE_THIS);
40901: }
40901: 
40901: inline void
48470: JSObject::setPrimitiveThis(const js::Value &pthis)
40901: {
40901:     JS_ASSERT(isPrimitive());
55746:     setSlot(JSSLOT_PRIMITIVE_THIS, pthis);
40901: }
40901: 
58534: inline /* gc::FinalizeKind */ unsigned
58534: JSObject::finalizeKind() const
58056: {
69246:     return js::gc::FinalizeKind(arenaHeader()->getThingKind());
58056: }
58056: 
55746: inline size_t
55746: JSObject::numFixedSlots() const
40797: {
55746:     if (isFunction())
55746:         return JSObject::FUN_CLASS_RESERVED_SLOTS;
55746:     if (!hasSlotsArray())
55746:         return capacity;
58534:     return js::gc::GetGCKindSlots(js::gc::FinalizeKind(finalizeKind()));
55746: }
55746: 
55746: inline size_t
55746: JSObject::slotsAndStructSize(uint32 nslots) const
55746: {
55746:     bool isFun = isFunction() && this == (JSObject*) getPrivate();
55746: 
55746:     int ndslots = hasSlotsArray() ? nslots : 0;
55746:     int nfslots = isFun ? 0 : numFixedSlots();
55746: 
55746:     return sizeof(js::Value) * (ndslots + nfslots)
72087:            + (isFun ? sizeof(JSFunction) : sizeof(JSObject));
40797: }
40797: 
40796: inline uint32
40796: JSObject::getArrayLength() const
40796: {
40796:     JS_ASSERT(isArray());
55746:     return (uint32)(size_t) getPrivate();
40796: }
40796: 
40901: inline void
48537: JSObject::setArrayLength(uint32 length)
40901: {
48537:     JS_ASSERT(isArray());
55746:     setPrivate((void*) length);
41850: }
41850: 
41850: inline uint32
55746: JSObject::getDenseArrayCapacity()
41782: {
41782:     JS_ASSERT(isDenseArray());
55746:     return numSlots();
55746: }
55746: 
55746: inline js::Value*
55746: JSObject::getDenseArrayElements()
55746: {
55746:     JS_ASSERT(isDenseArray());
55746:     return getSlots();
55746: }
55746: 
55746: inline const js::Value &
55746: JSObject::getDenseArrayElement(uintN idx)
55746: {
55746:     JS_ASSERT(isDenseArray());
55746:     return getSlot(idx);
55746: }
55746: 
55746: inline js::Value *
55746: JSObject::addressOfDenseArrayElement(uintN idx)
55746: {
55746:     JS_ASSERT(isDenseArray());
55746:     return &getSlotRef(idx);
54426: }
54426: 
54426: inline void
55746: JSObject::setDenseArrayElement(uintN idx, const js::Value &val)
54426: {
54426:     JS_ASSERT(isDenseArray());
55746:     setSlot(idx, val);
54426: }
54426: 
54426: inline void
55746: JSObject::shrinkDenseArrayElements(JSContext *cx, uintN cap)
54425: {
54425:     JS_ASSERT(isDenseArray());
55746:     shrinkSlots(cx, cap);
40796: }
40796: 
60243: inline bool
60243: JSObject::callIsForEval() const
60243: {
60243:     JS_ASSERT(isCall());
60243:     JS_ASSERT(getSlot(JSSLOT_CALL_CALLEE).isObjectOrNull());
60243:     JS_ASSERT_IF(getSlot(JSSLOT_CALL_CALLEE).isObject(),
60243:                  getSlot(JSSLOT_CALL_CALLEE).toObject().isFunction());
60243:     return getSlot(JSSLOT_CALL_CALLEE).isNull();
60243: }
60243: 
69223: inline js::StackFrame *
59969: JSObject::maybeCallObjStackFrame() const
59969: {
59969:     JS_ASSERT(isCall());
69223:     return reinterpret_cast<js::StackFrame *>(getPrivate());
59969: }
59969: 
53840: inline void
60146: JSObject::setCallObjCallee(JSObject *callee)
53840: {
53840:     JS_ASSERT(isCall());
60146:     JS_ASSERT_IF(callee, callee->isFunction());
60146:     return getSlotRef(JSSLOT_CALL_CALLEE).setObjectOrNull(callee);
53840: }
53840: 
60146: inline JSObject *
53840: JSObject::getCallObjCallee() const
53840: {
53840:     JS_ASSERT(isCall());
60146:     return getSlot(JSSLOT_CALL_CALLEE).toObjectOrNull();
53840: }
53840: 
53840: inline JSFunction *
53840: JSObject::getCallObjCalleeFunction() const
53840: {
53840:     JS_ASSERT(isCall());
55746:     return getSlot(JSSLOT_CALL_CALLEE).toObject().getFunctionPrivate();
53840: }
53840: 
53840: inline const js::Value &
53840: JSObject::getCallObjArguments() const
53840: {
53840:     JS_ASSERT(isCall());
60243:     JS_ASSERT(!callIsForEval());
55746:     return getSlot(JSSLOT_CALL_ARGUMENTS);
53840: }
53840: 
53840: inline void
53840: JSObject::setCallObjArguments(const js::Value &v)
53840: {
53840:     JS_ASSERT(isCall());
60243:     JS_ASSERT(!callIsForEval());
55746:     setSlot(JSSLOT_CALL_ARGUMENTS, v);
53840: }
53840: 
48470: inline const js::Value &
59969: JSObject::callObjArg(uintN i) const
59969: {
59969:     JS_ASSERT(isCall());
59969:     JS_ASSERT(i < getCallObjCalleeFunction()->nargs);
59969:     return getSlot(JSObject::CALL_RESERVED_SLOTS + i);
59969: }
59969: 
59969: inline js::Value &
59969: JSObject::callObjArg(uintN i)
59969: {
59969:     JS_ASSERT(isCall());
59969:     JS_ASSERT(i < getCallObjCalleeFunction()->nargs);
59969:     return getSlotRef(JSObject::CALL_RESERVED_SLOTS + i);
59969: }
59969: 
59969: inline const js::Value &
59969: JSObject::callObjVar(uintN i) const
59969: {
59969:     JSFunction *fun = getCallObjCalleeFunction();
59969:     JS_ASSERT(fun->nargs == fun->script()->bindings.countArgs());
59969:     JS_ASSERT(i < fun->script()->bindings.countVars());
59969:     return getSlot(JSObject::CALL_RESERVED_SLOTS + fun->nargs + i);
59969: }
59969: 
59969: inline js::Value &
59969: JSObject::callObjVar(uintN i)
59969: {
59969:     JSFunction *fun = getCallObjCalleeFunction();
59969:     JS_ASSERT(fun->nargs == fun->script()->bindings.countArgs());
59969:     JS_ASSERT(i < fun->script()->bindings.countVars());
59969:     return getSlotRef(JSObject::CALL_RESERVED_SLOTS + fun->nargs + i);
59969: }
59969: 
59969: inline const js::Value &
40901: JSObject::getDateUTCTime() const
40901: {
40901:     JS_ASSERT(isDate());
55746:     return getSlot(JSSLOT_DATE_UTC_TIME);
40901: }
40901: 
40901: inline void 
48470: JSObject::setDateUTCTime(const js::Value &time)
40901: {
40901:     JS_ASSERT(isDate());
55746:     setSlot(JSSLOT_DATE_UTC_TIME, time);
40901: }
40901: 
52503: inline js::Value *
52503: JSObject::getFlatClosureUpvars() const
52503: {
59969: #ifdef DEBUG
59969:     JSFunction *fun = getFunctionPrivate();
59969:     JS_ASSERT(fun->isFlatClosure());
59969:     JS_ASSERT(fun->script()->bindings.countUpvars() == fun->script()->upvars()->length);
59969: #endif
55746:     return (js::Value *) getSlot(JSSLOT_FLAT_CLOSURE_UPVARS).toPrivate();
52503: }
52503: 
52503: inline js::Value
52503: JSObject::getFlatClosureUpvar(uint32 i) const
52503: {
59968:     JS_ASSERT(i < getFunctionPrivate()->script()->bindings.countUpvars());
52503:     return getFlatClosureUpvars()[i];
52503: }
52503: 
59969: inline js::Value &
59969: JSObject::getFlatClosureUpvar(uint32 i)
59969: {
59969:     JS_ASSERT(i < getFunctionPrivate()->script()->bindings.countUpvars());
59969:     return getFlatClosureUpvars()[i];
59969: }
59969: 
52503: inline void
52503: JSObject::setFlatClosureUpvars(js::Value *upvars)
52503: {
52503:     JS_ASSERT(isFunction());
52503:     JS_ASSERT(FUN_FLAT_CLOSURE(getFunctionPrivate()));
55746:     getSlotRef(JSSLOT_FLAT_CLOSURE_UPVARS).setPrivate(upvars);
52503: }
52503: 
48676: inline bool
48676: JSObject::hasMethodObj(const JSObject& obj) const
48676: {
55746:     return JSSLOT_FUN_METHOD_OBJ < numSlots() &&
55746:            getSlot(JSSLOT_FUN_METHOD_OBJ).isObject() &&
68893:            getSlot(JSSLOT_FUN_METHOD_OBJ).toObject() == obj;
48676: }
48676: 
48676: inline void
48676: JSObject::setMethodObj(JSObject& obj)
48676: {
55746:     getSlotRef(JSSLOT_FUN_METHOD_OBJ).setObject(obj);
48676: }
48676: 
55632: inline js::NativeIterator *
42641: JSObject::getNativeIterator() const
42641: {
55632:     return (js::NativeIterator *) getPrivate();
42641: }
42641: 
42641: inline void
55632: JSObject::setNativeIterator(js::NativeIterator *ni)
42641: {
42641:     setPrivate(ni);
42641: }
42641: 
59890: inline JSLinearString *
59890: JSObject::getNamePrefix() const
59890: {
59890:     JS_ASSERT(isNamespace() || isQName());
59890:     const js::Value &v = getSlot(JSSLOT_NAME_PREFIX);
64345:     return !v.isUndefined() ? &v.toString()->asLinear() : NULL;
59890: }
59890: 
42693: inline jsval
59890: JSObject::getNamePrefixVal() const
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
55746:     return js::Jsvalify(getSlot(JSSLOT_NAME_PREFIX));
42693: }
42693: 
42693: inline void
59890: JSObject::setNamePrefix(JSLinearString *prefix)
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
59890:     setSlot(JSSLOT_NAME_PREFIX, prefix ? js::StringValue(prefix) : js::UndefinedValue());
59890: }
59890: 
59890: inline void
59890: JSObject::clearNamePrefix()
59890: {
59890:     JS_ASSERT(isNamespace() || isQName());
59890:     setSlot(JSSLOT_NAME_PREFIX, js::UndefinedValue());
59890: }
59890: 
59890: inline JSLinearString *
59890: JSObject::getNameURI() const
59890: {
59890:     JS_ASSERT(isNamespace() || isQName());
59890:     const js::Value &v = getSlot(JSSLOT_NAME_URI);
64345:     return !v.isUndefined() ? &v.toString()->asLinear() : NULL;
42693: }
42693: 
42693: inline jsval
59890: JSObject::getNameURIVal() const
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
55746:     return js::Jsvalify(getSlot(JSSLOT_NAME_URI));
42693: }
42693: 
42693: inline void
59890: JSObject::setNameURI(JSLinearString *uri)
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
59890:     setSlot(JSSLOT_NAME_URI, uri ? js::StringValue(uri) : js::UndefinedValue());
42693: }
42693: 
42693: inline jsval
42693: JSObject::getNamespaceDeclared() const
42693: {
42693:     JS_ASSERT(isNamespace());
55746:     return js::Jsvalify(getSlot(JSSLOT_NAMESPACE_DECLARED));
42693: }
42693: 
42693: inline void
42693: JSObject::setNamespaceDeclared(jsval decl)
42693: {
42693:     JS_ASSERT(isNamespace());
55746:     setSlot(JSSLOT_NAMESPACE_DECLARED, js::Valueify(decl));
42693: }
42693: 
59890: inline JSLinearString *
59890: JSObject::getQNameLocalName() const
59890: {
59890:     JS_ASSERT(isQName());
59890:     const js::Value &v = getSlot(JSSLOT_QNAME_LOCAL_NAME);
64345:     return !v.isUndefined() ? &v.toString()->asLinear() : NULL;
59890: }
59890: 
42693: inline jsval
59890: JSObject::getQNameLocalNameVal() const
42693: {
42693:     JS_ASSERT(isQName());
55746:     return js::Jsvalify(getSlot(JSSLOT_QNAME_LOCAL_NAME));
42693: }
42693: 
42693: inline void
59890: JSObject::setQNameLocalName(JSLinearString *name)
42693: {
42693:     JS_ASSERT(isQName());
59890:     setSlot(JSSLOT_QNAME_LOCAL_NAME, name ? js::StringValue(name) : js::UndefinedValue());
42693: }
42693: 
47417: inline JSObject *
47417: JSObject::getWithThis() const
47417: {
55746:     return &getSlot(JSSLOT_WITH_THIS).toObject();
47417: }
47417: 
47417: inline void
47417: JSObject::setWithThis(JSObject *thisp)
47417: {
55746:     getSlotRef(JSSLOT_WITH_THIS).setObject(*thisp);
47417: }
47417: 
40864: inline void
55746: JSObject::init(JSContext *cx, js::Class *aclasp, JSObject *proto, JSObject *parent,
55746:                void *priv, bool useHoles)
35117: {
52503:     clasp = aclasp;
59911:     flags = 0;
52503: 
52503: #ifdef DEBUG
52503:     /*
52503:      * NB: objShape must not be set here; rather, the caller must call setMap
52503:      * or setSharedNonNativeMap after calling init. To defend this requirement
64357:      * we set objShape to a value that obj->shape() is asserted never to return.
52503:      */
68935:     objShape = INVALID_SHAPE;
52503: #endif
52503: 
52503:     setProto(proto);
52503:     setParent(parent);
52503: 
55746:     privateData = priv;
55746:     slots = fixedSlots();
55746: 
55746:     /*
55746:      * Fill the fixed slots with undefined or array holes.  This object must
55746:      * already have its capacity filled in, as by js_NewGCObject.
55746:      */
55746:     JS_ASSERT(capacity == numFixedSlots());
55746:     ClearValueRange(slots, capacity, useHoles);
52503: 
55746:     emptyShapes = NULL;
53638: }
53638: 
53638: inline void
52503: JSObject::finish(JSContext *cx)
52503: {
52503:     if (hasSlotsArray())
52503:         freeSlotsArray(cx);
55748:     if (emptyShapes)
64560:         cx->free_(emptyShapes);
52503: }
52503: 
55746: inline bool
55746: JSObject::initSharingEmptyShape(JSContext *cx,
55746:                                 js::Class *aclasp,
52503:                                 JSObject *proto,
52503:                                 JSObject *parent,
55746:                                 void *privateValue,
55746:                                 /* js::gc::FinalizeKind */ unsigned kind)
52503: {
55746:     init(cx, aclasp, proto, parent, privateValue, false);
52503: 
55746:     JS_ASSERT(!isDenseArray());
55746: 
55746:     js::EmptyShape *empty = proto->getEmptyShape(cx, aclasp, kind);
55746:     if (!empty)
55746:         return false;
55746: 
54426:     setMap(empty);
55746:     return true;
53638: }
53638: 
53638: inline void
36997: JSObject::freeSlotsArray(JSContext *cx)
36997: {
36997:     JS_ASSERT(hasSlotsArray());
64560:     cx->free_(slots);
55746: }
55746: 
55746: inline void
55746: JSObject::revertToFixedSlots(JSContext *cx)
55746: {
55746:     JS_ASSERT(hasSlotsArray());
55746:     size_t fixed = numFixedSlots();
55746:     JS_ASSERT(capacity >= fixed);
55746:     memcpy(fixedSlots(), slots, fixed * sizeof(js::Value));
55746:     freeSlotsArray(cx);
55746:     slots = fixedSlots();
55746:     capacity = fixed;
36997: }
36997: 
37685: inline bool
52503: JSObject::hasProperty(JSContext *cx, jsid id, bool *foundp, uintN flags)
37685: {
52503:     JSObject *pobj;
52503:     JSProperty *prop;
52503:     JSAutoResolveFlags rf(cx, flags);
52503:     if (!lookupProperty(cx, id, &pobj, &prop))
37685:         return false;
52503:     *foundp = !!prop;
52503:     return true;
37685: }
52503: 
52503: inline bool
52503: JSObject::isCallable()
52503: {
52503:     return isFunction() || getClass()->call;
37685: }
52503: 
68894: inline JSPrincipals *
68894: JSObject::principals(JSContext *cx)
68894: {
69647:     JSSecurityCallbacks *cb = JS_GetSecurityCallbacks(cx);
69647:     if (JSObjectPrincipalsFinder finder = cb ? cb->findObjectPrincipals : NULL)
69647:         return finder(cx, this);
68894:     return NULL;
68894: }
68894: 
68935: inline uint32
68935: JSObject::slotSpan() const
68935: {
68935:     return lastProp->slotSpan;
68935: }
68935: 
68935: inline bool
68935: JSObject::containsSlot(uint32 slot) const
68935: {
68935:     return slot < slotSpan();
68935: }
68935: 
68935: inline void
68935: JSObject::setMap(js::Shape *amap)
68935: {
68935:     JS_ASSERT(!hasOwnShape());
68935:     lastProp = amap;
69637:     objShape = lastProp->shapeid;
68935: }
68935: 
68935: inline js::Value &
68935: JSObject::nativeGetSlotRef(uintN slot)
68935: {
68935:     JS_ASSERT(isNative());
68935:     JS_ASSERT(containsSlot(slot));
68935:     return getSlotRef(slot);
68935: }
68935: 
68935: inline const js::Value &
68935: JSObject::nativeGetSlot(uintN slot) const
68935: {
68935:     JS_ASSERT(isNative());
68935:     JS_ASSERT(containsSlot(slot));
68935:     return getSlot(slot);
68935: }
68935: 
68935: inline void
68935: JSObject::nativeSetSlot(uintN slot, const js::Value &value)
68935: {
68935:     JS_ASSERT(isNative());
68935:     JS_ASSERT(containsSlot(slot));
68935:     return setSlot(slot, value);
68935: }
68935: 
68935: inline bool
68935: JSObject::isNative() const
68935: {
68935:     return lastProp->isNative();
68935: }
68935: 
68935: inline bool
68935: JSObject::isNewborn() const
68935: {
68935:     return !lastProp;
68935: }
68935: 
68935: inline void
68935: JSObject::clearOwnShape()
68935: {
68935:     flags &= ~OWN_SHAPE;
69637:     objShape = lastProp->shapeid;
68935: }
68935: 
68935: inline void
68935: JSObject::setOwnShape(uint32 s)
68935: {
68935:     flags |= OWN_SHAPE;
68935:     objShape = s;
68935: }
68935: 
68935: inline js::Shape **
68935: JSObject::nativeSearch(jsid id, bool adding)
68935: {
68935:     return js::Shape::search(compartment()->rt, &lastProp, id, adding);
68935: }
68935: 
68935: inline const js::Shape *
68935: JSObject::nativeLookup(jsid id)
68935: {
68935:     JS_ASSERT(isNative());
68935:     return SHAPE_FETCH(nativeSearch(id));
68935: }
68935: 
68935: inline bool
68935: JSObject::nativeContains(jsid id)
68935: {
68935:     return nativeLookup(id) != NULL;
68935: }
68935: 
68935: inline bool
68935: JSObject::nativeContains(const js::Shape &shape)
68935: {
69637:     return nativeLookup(shape.propid) == &shape;
68935: }
68935: 
68935: inline const js::Shape *
68935: JSObject::lastProperty() const
68935: {
68935:     JS_ASSERT(isNative());
69637:     JS_ASSERT(!JSID_IS_VOID(lastProp->propid));
68935:     return lastProp;
68935: }
68935: 
68935: inline bool
68935: JSObject::nativeEmpty() const
68935: {
68935:     return lastProperty()->isEmptyShape();
68935: }
68935: 
68935: inline bool
68935: JSObject::inDictionaryMode() const
68935: {
68935:     return lastProperty()->inDictionary();
68935: }
68935: 
68935: inline uint32
68935: JSObject::propertyCount() const
68935: {
68935:     return lastProperty()->entryCount();
68935: }
68935: 
68935: inline bool
68935: JSObject::hasPropertyTable() const
68935: {
68935:     return lastProperty()->hasTable();
68935: }
68935: 
68935: /*
68935:  * FIXME: shape must not be null, should use a reference here and other places.
68935:  */
68935: inline void
68935: JSObject::setLastProperty(const js::Shape *shape)
68935: {
68935:     JS_ASSERT(!inDictionaryMode());
69637:     JS_ASSERT(!JSID_IS_VOID(shape->propid));
69637:     JS_ASSERT_IF(lastProp, !JSID_IS_VOID(lastProp->propid));
68935:     JS_ASSERT(shape->compartment() == compartment());
68935: 
68935:     lastProp = const_cast<js::Shape *>(shape);
68935: }
68935: 
68935: inline void
68935: JSObject::removeLastProperty()
68935: {
68935:     JS_ASSERT(!inDictionaryMode());
69637:     JS_ASSERT(!JSID_IS_VOID(lastProp->parent->propid));
68935: 
68935:     lastProp = lastProp->parent;
68935: }
68935: 
68935: inline void
68935: JSObject::setSharedNonNativeMap()
68935: {
68935:     setMap(&js::Shape::sharedNonNative);
68935: }
68935: 
52503: static inline bool
52503: js_IsCallable(const js::Value &v)
52503: {
52503:     return v.isObject() && v.toObject().isCallable();
37685: }
37685: 
40388: namespace js {
40388: 
48470: class AutoPropDescArrayRooter : private AutoGCRooter
40388: {
40388:   public:
48470:     AutoPropDescArrayRooter(JSContext *cx)
40388:       : AutoGCRooter(cx, DESCRIPTORS), descriptors(cx)
40388:     { }
40388: 
48470:     PropDesc *append() {
48470:         if (!descriptors.append(PropDesc()))
40388:             return NULL;
40388:         return &descriptors.back();
40388:     }
40388: 
48470:     PropDesc& operator[](size_t i) {
40388:         JS_ASSERT(i < descriptors.length());
40388:         return descriptors[i];
40388:     }
40388: 
40388:     friend void AutoGCRooter::trace(JSTracer *trc);
40388: 
40388:   private:
48470:     PropDescArray descriptors;
40388: };
40388: 
48470: class AutoPropertyDescriptorRooter : private AutoGCRooter, public PropertyDescriptor
42733: {
42733:   public:
48470:     AutoPropertyDescriptorRooter(JSContext *cx) : AutoGCRooter(cx, DESCRIPTOR) {
42733:         obj = NULL;
42733:         attrs = 0;
62395:         getter = (PropertyOp) NULL;
62395:         setter = (StrictPropertyOp) NULL;
48470:         value.setUndefined();
42733:     }
42733: 
52503:     AutoPropertyDescriptorRooter(JSContext *cx, PropertyDescriptor *desc)
52503:       : AutoGCRooter(cx, DESCRIPTOR)
52503:     {
47498:         obj = desc->obj;
47498:         attrs = desc->attrs;
47498:         getter = desc->getter;
47498:         setter = desc->setter;
47498:         value = desc->value;
47498:     }
47498: 
42733:     friend void AutoGCRooter::trace(JSTracer *trc);
42733: };
42733: 
40858: static inline bool
55746: InitScopeForObject(JSContext* cx, JSObject* obj, js::Class *clasp, JSObject* proto,
55746:                    gc::FinalizeKind kind)
40858: {
48622:     JS_ASSERT(clasp->isNative());
40858:     JS_ASSERT(proto == obj->getProto());
40858: 
52503:     /* Share proto's emptyShape only if obj is similar to proto. */
52503:     js::EmptyShape *empty = NULL;
40858: 
52503:     if (proto) {
52503:         if (proto->canProvideEmptyShape(clasp)) {
55746:             empty = proto->getEmptyShape(cx, clasp, kind);
52503:             if (!empty)
40858:                 goto bad;
40858:         }
40858:     }
40858: 
52503:     if (!empty) {
52503:         empty = js::EmptyShape::create(cx, clasp);
52503:         if (!empty)
40858:             goto bad;
55746:         uint32 freeslot = JSSLOT_FREE(clasp);
55746:         if (freeslot > obj->numSlots() && !obj->allocSlots(cx, freeslot))
40858:             goto bad;
40858:     }
40858: 
52503:     obj->setMap(empty);
40858:     return true;
40858: 
40858:   bad:
40858:     /* The GC nulls map initially. It should still be null on error. */
68935:     JS_ASSERT(obj->isNewborn());
40858:     return false;
40858: }
40858: 
68896: static inline bool
68896: CanBeFinalizedInBackground(gc::FinalizeKind kind, Class *clasp)
68896: {
69651: #ifdef JS_THREADSAFE
68896:     JS_ASSERT(kind <= gc::FINALIZE_OBJECT_LAST);
68896:     /* If the class has no finalizer or a finalizer that is safe to call on
68896:      * a different thread, we change the finalize kind. For example,
68896:      * FINALIZE_OBJECT0 calls the finalizer on the main thread,
68896:      * FINALIZE_OBJECT0_BACKGROUND calls the finalizer on the gcHelperThread.
68896:      * kind % 2 prevents from recursivly incrementing the finalize kind because
68896:      * we can call NewObject with a background finalize kind.
68896:      */
68896:     if (kind % 2 == 0 && (!clasp->finalize || clasp->flags & JSCLASS_CONCURRENT_FINALIZER))
68896:         return true;
69651: #endif
68896:     return false;
68896: }
68896: 
47497: /*
47497:  * Helper optimized for creating a native instance of the given class (not the
50450:  * class's prototype object). Use this in preference to NewObject, but use
50450:  * NewBuiltinClassInstance if you need the default class prototype as proto,
50450:  * and its parent global as parent.
47497:  */
40858: static inline JSObject *
55746: NewNativeClassInstance(JSContext *cx, Class *clasp, JSObject *proto,
55746:                        JSObject *parent, gc::FinalizeKind kind)
47497: {
47497:     JS_ASSERT(proto);
47497:     JS_ASSERT(parent);
68896:     JS_ASSERT(kind <= gc::FINALIZE_OBJECT_LAST);
47497: 
47497:     /*
47497:      * Allocate an object from the GC heap and initialize all its fields before
50450:      * doing any operation that can potentially trigger GC.
47497:      */
68896: 
68896:     if (CanBeFinalizedInBackground(kind, clasp))
68896:         kind = (gc::FinalizeKind)(kind + 1);
68896: 
55746:     JSObject* obj = js_NewGCObject(cx, kind);
50450: 
47497:     if (obj) {
47497:         /*
47497:          * Default parent to the parent of the prototype, which was set from
47497:          * the parent of the prototype's constructor.
47497:          */
55746:         bool useHoles = (clasp == &js_ArrayClass);
55746:         obj->init(cx, clasp, proto, parent, NULL, useHoles);
47497: 
52503:         JS_ASSERT(proto->canProvideEmptyShape(clasp));
55746:         js::EmptyShape *empty = proto->getEmptyShape(cx, clasp, kind);
47497: 
52503:         if (empty)
52503:             obj->setMap(empty);
52503:         else
47497:             obj = NULL;
47497:     }
47497: 
47497:     return obj;
47497: }
47497: 
55746: static inline JSObject *
55746: NewNativeClassInstance(JSContext *cx, Class *clasp, JSObject *proto, JSObject *parent)
55746: {
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(JSCLASS_RESERVED_SLOTS(clasp));
55746:     return NewNativeClassInstance(cx, clasp, proto, parent, kind);
55746: }
55746: 
47497: bool
47497: FindClassPrototype(JSContext *cx, JSObject *scope, JSProtoKey protoKey, JSObject **protop,
48470:                    Class *clasp);
47497: 
47497: /*
47497:  * Helper used to create Boolean, Date, RegExp, etc. instances of built-in
48470:  * classes with class prototypes of the same Class. See, e.g., jsdate.cpp,
47497:  * jsregexp.cpp, and js_PrimitiveToObject in jsobj.cpp. Use this to get the
47497:  * right default proto and parent for clasp in cx.
47497:  */
47497: static inline JSObject *
55746: NewBuiltinClassInstance(JSContext *cx, Class *clasp, gc::FinalizeKind kind)
47497: {
47497:     VOUCH_DOES_NOT_REQUIRE_STACK();
47497: 
47497:     JSProtoKey protoKey = JSCLASS_CACHED_PROTO_KEY(clasp);
47497:     JS_ASSERT(protoKey != JSProto_Null);
47497: 
47497:     /* NB: inline-expanded and specialized version of js_GetClassPrototype. */
62953:     JSObject *global;
71696:     if (!cx->hasfp()) {
62953:         global = cx->globalObject;
73904:         if (!NULLABLE_OBJ_TO_INNER_OBJECT(cx, global))
47535:             return NULL;
62953:     } else {
62953:         global = cx->fp()->scopeChain().getGlobal();
62953:     }
60566:     JS_ASSERT(global->isGlobal());
47497: 
69237:     const Value &v = global->getReservedSlot(JSProto_LIMIT + protoKey);
47497:     JSObject *proto;
48470:     if (v.isObject()) {
48470:         proto = &v.toObject();
47497:         JS_ASSERT(proto->getParent() == global);
47497:     } else {
47497:         if (!FindClassPrototype(cx, global, protoKey, &proto, clasp))
47497:             return NULL;
47497:     }
47497: 
55746:     return NewNativeClassInstance(cx, clasp, proto, global, kind);
55746: }
55746: 
55746: static inline JSObject *
55746: NewBuiltinClassInstance(JSContext *cx, Class *clasp)
55746: {
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(JSCLASS_RESERVED_SLOTS(clasp));
55746:     return NewBuiltinClassInstance(cx, clasp, kind);
47497: }
47497: 
50450: static inline JSProtoKey
50450: GetClassProtoKey(js::Class *clasp)
50450: {
50450:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
50450:     if (key != JSProto_Null)
50450:         return key;
50450:     if (clasp->flags & JSCLASS_IS_ANONYMOUS)
50450:         return JSProto_Object;
50450:     return JSProto_Null;
50450: }
50450: 
50450: namespace WithProto {
50450:     enum e {
50450:         Class = 0,
50450:         Given = 1
50450:     };
50450: }
50450: 
47497: /*
50450:  * Create an instance of any class, native or not, JSFunction-sized or not.
50450:  *
50450:  * If withProto is 'Class':
50450:  *    If proto is null:
50450:  *      for a built-in class:
50450:  *        use the memoized original value of the class constructor .prototype
50450:  *        property object
50450:  *      else if available
50450:  *        the current value of .prototype
50450:  *      else
50450:  *        Object.prototype.
50450:  *
50450:  *    If parent is null, default it to proto->getParent() if proto is non
50450:  *    null, else to null.
50450:  *
50450:  * If withProto is 'Given':
50450:  *    We allocate an object with exactly the given proto.  A null parent
50450:  *    defaults to proto->getParent() if proto is non-null (else to null).
50450:  *
50450:  * If isFunction is true, return a JSFunction-sized object. If isFunction is
50450:  * false, return a normal object.
50450:  *
50450:  * Note that as a template, there will be lots of instantiations, which means
50450:  * the internals will be specialized based on the template parameters.
47497:  */
59234: static JS_ALWAYS_INLINE bool
59234: FindProto(JSContext *cx, js::Class *clasp, JSObject *parent, JSObject ** proto)
59234: {
59234:     JSProtoKey protoKey = GetClassProtoKey(clasp);
59234:     if (!js_GetClassPrototype(cx, parent, protoKey, proto, clasp))
59234:         return false;
59234:     if (!(*proto) && !js_GetClassPrototype(cx, parent, JSProto_Object, proto))
59234:         return false;
59234: 
59234:     return true;
59234: }
59234: 
50450: namespace detail
40858: {
50450: template <bool withProto, bool isFunction>
50450: static JS_ALWAYS_INLINE JSObject *
55746: NewObject(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent,
55746:           gc::FinalizeKind kind)
50450: {
50450:     /* Bootstrap the ur-object, and make it the default prototype object. */
50450:     if (withProto == WithProto::Class && !proto) {
59234:         if (!FindProto(cx, clasp, parent, &proto))
50450:           return NULL;
50450:     }
50450: 
40858:     /*
40858:      * Allocate an object from the GC heap and initialize all its fields before
40858:      * doing any operation that can potentially trigger GC. Functions have a
40858:      * larger non-standard allocation size.
50450:      *
50450:      * The should be specialized by the template.
40858:      */
68896: 
68896:     if (!isFunction && CanBeFinalizedInBackground(kind, clasp))
68896:         kind = (gc::FinalizeKind)(kind + 1);
68896: 
55746:     JSObject* obj = isFunction ? js_NewGCFunction(cx) : js_NewGCObject(cx, kind);
40858:     if (!obj)
40858:         goto out;
40858: 
55746:     /* This needs to match up with the size of JSFunction::data_padding. */
55746:     JS_ASSERT_IF(isFunction, kind == gc::FINALIZE_OBJECT2);
55746: 
40858:     /*
40858:      * Default parent to the parent of the prototype, which was set from
40858:      * the parent of the prototype's constructor.
40858:      */
55746:     obj->init(cx, clasp, proto,
55746:               (!parent && proto) ? proto->getParent() : parent,
55746:               NULL, clasp == &js_ArrayClass);
40858: 
48622:     if (clasp->isNative()) {
55746:         if (!InitScopeForObject(cx, obj, clasp, proto, kind)) {
40858:             obj = NULL;
40858:             goto out;
40858:         }
40858:     } else {
52503:         obj->setSharedNonNativeMap();
40858:     }
40858: 
40858: out:
53555:     Probes::createObject(cx, obj);
40858:     return obj;
40858: }
55746: } /* namespace detail */
40858: 
50450: static JS_ALWAYS_INLINE JSObject *
70297: NewFunction(JSContext *cx, js::GlobalObject &global)
70297: {
70297:     JSObject *proto;
70297:     if (!js_GetClassPrototype(cx, &global, JSProto_Function, &proto))
70297:         return NULL;
70297:     return detail::NewObject<WithProto::Given, true>(cx, &js_FunctionClass, proto, &global,
70297:                                                      gc::FINALIZE_OBJECT2);
70297: }
70297: 
70297: static JS_ALWAYS_INLINE JSObject *
50500: NewFunction(JSContext *cx, JSObject *parent)
50450: {
55746:     return detail::NewObject<WithProto::Class, true>(cx, &js_FunctionClass, NULL, parent,
55746:                                                      gc::FINALIZE_OBJECT2);
55746: }
55746: 
55746: template <WithProto::e withProto>
55746: static JS_ALWAYS_INLINE JSObject *
55746: NewNonFunction(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent,
55746:                gc::FinalizeKind kind)
55746: {
55746:     return detail::NewObject<withProto, false>(cx, clasp, proto, parent, kind);
50450: }
50450: 
50450: template <WithProto::e withProto>
50450: static JS_ALWAYS_INLINE JSObject *
50450: NewNonFunction(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent)
50450: {
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(JSCLASS_RESERVED_SLOTS(clasp));
55746:     return detail::NewObject<withProto, false>(cx, clasp, proto, parent, kind);
55746: }
55746: 
55746: template <WithProto::e withProto>
55746: static JS_ALWAYS_INLINE JSObject *
55746: NewObject(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent,
55746:           gc::FinalizeKind kind)
55746: {
55746:     if (clasp == &js_FunctionClass)
55746:         return detail::NewObject<withProto, true>(cx, clasp, proto, parent, kind);
55746:     return detail::NewObject<withProto, false>(cx, clasp, proto, parent, kind);
50450: }
50450: 
50450: template <WithProto::e withProto>
50450: static JS_ALWAYS_INLINE JSObject *
48470: NewObject(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent)
40858: {
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(JSCLASS_RESERVED_SLOTS(clasp));
55746:     return NewObject<withProto>(cx, clasp, proto, parent, kind);
55746: }
55746: 
55746: /*
61705:  * As for gc::GetGCObjectKind, where numSlots is a guess at the final size of
55746:  * the object, zero if the final size is unknown.
55746:  */
55746: static inline gc::FinalizeKind
55746: GuessObjectGCKind(size_t numSlots, bool isArray)
55746: {
55746:     if (numSlots)
55746:         return gc::GetGCObjectKind(numSlots);
55746:     return isArray ? gc::FINALIZE_OBJECT8 : gc::FINALIZE_OBJECT4;
55746: }
55746: 
55746: /*
55746:  * Get the GC kind to use for scripted 'new' on the given class.
55746:  * FIXME bug 547327: estimate the size from the allocation site.
55746:  */
55746: static inline gc::FinalizeKind
55746: NewObjectGCKind(JSContext *cx, js::Class *clasp)
55746: {
55746:     if (clasp == &js_ArrayClass || clasp == &js_SlowArrayClass)
55746:         return gc::FINALIZE_OBJECT8;
55746:     if (clasp == &js_FunctionClass)
55746:         return gc::FINALIZE_OBJECT2;
55746:     return gc::FINALIZE_OBJECT4;
40858: }
40858: 
69242: static JS_ALWAYS_INLINE JSObject*
69242: NewObjectWithClassProto(JSContext *cx, Class *clasp, JSObject *proto,
69242:                         /*gc::FinalizeKind*/ unsigned _kind)
69242: {
69242:     JS_ASSERT(clasp->isNative());
69242:     gc::FinalizeKind kind = gc::FinalizeKind(_kind);
69242: 
69242:     if (CanBeFinalizedInBackground(kind, clasp))
69242:         kind = (gc::FinalizeKind)(kind + 1);
69242: 
69242:     JSObject* obj = js_NewGCObject(cx, kind);
69242:     if (!obj)
69242:         return NULL;
69242: 
69242:     if (!obj->initSharingEmptyShape(cx, clasp, proto, proto->getParent(), NULL, kind))
69242:         return NULL;
69242:     return obj;
69242: }
69242: 
58056: /* Make an object with pregenerated shape from a NEWOBJECT bytecode. */
58056: static inline JSObject *
58056: CopyInitializerObject(JSContext *cx, JSObject *baseobj)
58056: {
58056:     JS_ASSERT(baseobj->getClass() == &js_ObjectClass);
58056:     JS_ASSERT(!baseobj->inDictionaryMode());
58056: 
58534:     gc::FinalizeKind kind = gc::FinalizeKind(baseobj->finalizeKind());
58056:     JSObject *obj = NewBuiltinClassInstance(cx, &js_ObjectClass, kind);
58056: 
58056:     if (!obj || !obj->ensureSlots(cx, baseobj->numSlots()))
58056:         return NULL;
58056: 
58056:     obj->flags = baseobj->flags;
58056:     obj->lastProp = baseobj->lastProp;
58056:     obj->objShape = baseobj->objShape;
58056: 
58056:     return obj;
58056: }
58056: 
64377: inline bool
64377: DefineConstructorAndPrototype(JSContext *cx, JSObject *global,
64377:                               JSProtoKey key, JSFunction *ctor, JSObject *proto)
64377: {
64377:     JS_ASSERT(global->isGlobal());
64377:     JS_ASSERT(!global->nativeEmpty()); /* reserved slots already allocated */
64377:     JS_ASSERT(ctor);
64377:     JS_ASSERT(proto);
64377: 
64377:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[key]);
64377:     JS_ASSERT(!global->nativeLookup(id));
64377: 
69237:     if (!global->addDataProperty(cx, id, key + JSProto_LIMIT * 2, 0))
64377:         return false;
64377: 
69237:     global->setSlot(key, ObjectValue(*ctor));
69237:     global->setSlot(key + JSProto_LIMIT, ObjectValue(*proto));
69237:     global->setSlot(key + JSProto_LIMIT * 2, ObjectValue(*ctor));
64377:     return true;
64377: }
64377: 
47497: } /* namespace js */
40388: 
35117: #endif /* jsobjinlines_h___ */
