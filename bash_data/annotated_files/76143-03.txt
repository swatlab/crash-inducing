53178: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
53178:  * vim: set ts=4 sw=4 et tw=99:
53178:  *
53178:  * ***** BEGIN LICENSE BLOCK *****
53168:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
53168:  *
53168:  * The contents of this file are subject to the Mozilla Public License Version
53168:  * 1.1 (the "License"); you may not use this file except in compliance with
53168:  * the License. You may obtain a copy of the License at
53168:  * http://www.mozilla.org/MPL/
53168:  *
53168:  * Software distributed under the License is distributed on an "AS IS" basis,
53168:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
53168:  * for the specific language governing rights and limitations under the
53168:  * License.
53168:  *
53168:  * The Original Code is Mozilla Jaegermonkey.
53168:  *
53168:  * The Initial Developer of the Original Code is the Mozilla Foundation.
53168:  *
53168:  * Portions created by the Initial Developer are Copyright (C) 2010
53168:  * the Initial Developer. All Rights Reserved.
53168:  *
53168:  * Contributor(s):
53168:  *   Andrew Drake <drakedevel@gmail.com>
53168:  *
53168:  * Alternatively, the contents of this file may be used under the terms of
53168:  * either the GNU General Public License Version 2 or later (the "GPL"), or
53168:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
53168:  * in which case the provisions of the GPL or the LGPL are applicable instead
53168:  * of those above. If you wish to allow use of your version of this file only
53168:  * under the terms of either the GPL or the LGPL, and not to allow others to
53168:  * use your version of this file under the terms of the MPL, indicate your
53168:  * decision by deleting the provisions above and replace them with the notice
53168:  * and other provisions required by the GPL or the LGPL. If you do not delete
53168:  * the provisions above, a recipient may use your version of this file under
53168:  * the terms of any one of the MPL, the GPL or the LGPL.
53168:  *
53168:  * ***** END LICENSE BLOCK ***** */
53168: 
53168: #ifdef JS_METHODJIT
53178: 
53168: #include "Retcon.h"
53168: #include "MethodJIT.h"
53168: #include "Compiler.h"
75997: #include "StubCalls.h"
53168: #include "jsdbgapi.h"
53168: #include "jsnum.h"
75636: #include "assembler/assembler/LinkBuffer.h"
75636: #include "assembler/assembler/RepatchBuffer.h"
53168: 
53168: #include "jscntxtinlines.h"
75864: #include "jsinterpinlines.h"
53168: 
76030: #include "MethodJIT-inl.h"
76030: 
53168: using namespace js;
53168: using namespace js::mjit;
53168: 
53168: namespace js {
53168: namespace mjit {
53168: 
53168: AutoScriptRetrapper::~AutoScriptRetrapper()
53168: {
53168:     while (!traps.empty()) {
53168:         jsbytecode *pc = traps.back();
53168:         traps.popBack();
53168:         *pc = JSOP_TRAP;
53168:     }
53168: }
53168: 
53168: bool
53168: AutoScriptRetrapper::untrap(jsbytecode *pc)
53168: {
53168:     if (!traps.append(pc))
53168:         return false;
68895:     *pc = JS_GetTrapOpcode(traps.allocPolicy().context(), script, pc);
53168:     return true;
53168: }
53168: 
76020: static inline JSRejoinState ScriptedRejoin(uint32 pcOffset)
76020: {
76020:     return REJOIN_SCRIPTED | (pcOffset << 1);
76020: }
76020: 
76020: static inline JSRejoinState StubRejoin(RejoinState rejoin)
76020: {
76020:     return rejoin << 1;
76020: }
76020: 
76020: static inline void
76020: SetRejoinState(StackFrame *fp, const CallSite &site, void **location)
76020: {
76020:     if (site.rejoin == REJOIN_SCRIPTED) {
76020:         fp->setRejoin(ScriptedRejoin(site.pcOffset));
76020:         *location = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolineScripted);
76020:     } else {
76020:         fp->setRejoin(StubRejoin(site.rejoin));
76020:         *location = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpoline);
76020:     }
76020: }
76020: 
76020: void
76020: Recompiler::patchCall(JITScript *jit, StackFrame *fp, void **location)
53168: {
55503:     uint8* codeStart = (uint8 *)jit->code.m_code.executableAddress();
75936: 
62075:     CallSite *callSites_ = jit->callSites();
55503:     for (uint32 i = 0; i < jit->nCallSites; i++) {
62075:         if (callSites_[i].codeOffset + codeStart == *location) {
76019:             JS_ASSERT(callSites_[i].inlineIndex == analyze::CrossScriptSSA::OUTER_FRAME);
76020:             SetRejoinState(fp, callSites_[i], location);
76020:             return;
75936:         }
75936:     }
75936: 
53168:     JS_NOT_REACHED("failed to find call site");
75864: }
75864: 
53168: void
76115: Recompiler::patchNative(JSContext *cx, JITScript *jit, StackFrame *fp,
76115:                         jsbytecode *pc, CallSite *inlined, RejoinState rejoin)
75636: {
75636:     /*
75636:      * There is a native IC at pc which triggered a recompilation. The recompilation
75636:      * could have been triggered either by the native call itself, or by a SplatApplyArgs
75636:      * preparing for the native call. Either way, we don't want to patch up the call,
75636:      * but will instead steal the pool for the native IC so it doesn't get freed
76020:      * with the old script, and patch up the jump at the end to go to the interpoline.
75636:      */
76020:     fp->setRejoin(StubRejoin(rejoin));
76067: 
76067:     /* :XXX: We might crash later if this fails. */
76067:     cx->compartment->jaegerCompartment->orphanedNativeFrames.append(fp);
76020: 
75636:     unsigned i;
75716:     ic::CallICInfo *callICs = jit->callICs();
75636:     for (i = 0; i < jit->nCallICs; i++) {
75864:         CallSite *call = callICs[i].call;
76115:         if (inlined) {
76115:             /*
76115:              * The IC and regs.inlined will have two different call sites for
76115:              * the same point in the script. The IC site refers to the scripted
76115:              * return and regs.inlined has the prologue site (which was in use
76115:              * when the native stub was generated.
76115:              */
76115:             if (call->inlineIndex == inlined->inlineIndex && call->pcOffset == inlined->pcOffset)
75636:                 break;
76115:         } else if (call->inlineIndex == uint32(-1) &&
76115:                    call->pcOffset == uint32(pc - jit->script->code)) {
76115:             break;
76115:         }
75636:     }
75636:     JS_ASSERT(i < jit->nCallICs);
75716:     ic::CallICInfo &ic = callICs[i];
75636:     JS_ASSERT(ic.fastGuardedNative);
75636: 
75636:     JSC::ExecutablePool *&pool = ic.pools[ic::CallICInfo::Pool_NativeStub];
75636: 
75636:     if (!pool) {
75636:         /* Already stole this stub. */
76020:         return;
75636:     }
75636: 
76020:     /* Patch the native fallthrough to go to the interpoline. */
76020:     {
76027:         void *interpoline = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpoline);
76020:         uint8 *start = (uint8 *)ic.nativeJump.executableAddress();
76020:         JSC::RepatchBuffer repatch(JSC::JITCode(start - 32, 64));
76027: #ifdef JS_CPU_X64
76027:         repatch.repatch(ic.nativeJump, interpoline);
76027: #else
76027:         repatch.relink(ic.nativeJump, JSC::CodeLocationLabel(interpoline));
76027: #endif
75636:     }
75636: 
76020:     /* :XXX: We leak the pool if this fails. Oh well. */
76020:     cx->compartment->jaegerCompartment->orphanedNativePools.append(pool);
75636: 
76020:     /* Mark as stolen in case there are multiple calls on the stack. */
76020:     pool = NULL;
75636: }
75636: 
76001: StackFrame *
76001: Recompiler::expandInlineFrameChain(JSContext *cx, StackFrame *outer, InlineFrame *inner)
75864: {
76001:     StackFrame *parent;
75864:     if (inner->parent)
75864:         parent = expandInlineFrameChain(cx, outer, inner->parent);
75864:     else
75864:         parent = outer;
75864: 
76019:     JaegerSpew(JSpew_Recompile, "Expanding inline frame\n");
75864: 
76001:     StackFrame *fp = (StackFrame *) ((uint8 *)outer + sizeof(Value) * inner->depth);
75864:     fp->initInlineFrame(inner->fun, parent, inner->parentpc);
75864:     uint32 pcOffset = inner->parentpc - parent->script()->code;
75864: 
76020:     void **location = fp->addressOfNativeReturnAddress();
76020:     *location = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolineScripted);
76020:     parent->setRejoin(ScriptedRejoin(pcOffset));
75864: 
75864:     return fp;
75864: }
75864: 
75864: /*
76020:  * Whether a given return address for a frame indicates it returns directly
76020:  * into JIT code.
76020:  */
76020: static inline bool
76020: JITCodeReturnAddress(void *data)
76020: {
76020:     return data != NULL  /* frame is interpreted */
76020:         && data != JS_FUNC_TO_DATA_PTR(void *, JaegerTrampolineReturn)
76020:         && data != JS_FUNC_TO_DATA_PTR(void *, JaegerInterpoline)
76020:         && data != JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolineScripted);
76020: }
76020: 
76020: /*
75864:  * Expand all inlined frames within fp per 'inlined' and update next and regs
75864:  * to refer to the new innermost frame.
75864:  */
75864: void
76001: Recompiler::expandInlineFrames(JSContext *cx, StackFrame *fp, mjit::CallSite *inlined,
76001:                                StackFrame *next, VMFrame *f)
75864: {
75864:     JS_ASSERT_IF(next, next->prev() == fp && next->prevInline() == inlined);
75864: 
75883:     /*
75883:      * Treat any frame expansion as a recompilation event, so that f.jit() is
75883:      * stable if no recompilations have occurred.
75883:      */
75883:     cx->compartment->types.frameExpansions++;
75883: 
76020:     /*
76020:      * Patch the VMFrame's return address if it is returning at the given inline site.
76020:      * Note there is no worry about handling a native or CompileFunction call here,
76020:      * as such IC stubs are not generated within inline frames.
76020:      */
75864:     void **frameAddr = f->returnAddressLocation();
75911:     uint8* codeStart = (uint8 *)fp->jit()->code.m_code.executableAddress();
75864: 
75864:     InlineFrame *inner = &fp->jit()->inlineFrames()[inlined->inlineIndex];
75864:     jsbytecode *innerpc = inner->fun->script()->code + inlined->pcOffset;
75864: 
76001:     StackFrame *innerfp = expandInlineFrameChain(cx, fp, inner);
75864: 
76115:     /* Check if the VMFrame returns into the inlined frame. */
76143:     if (f->stubRejoin && (f->stubRejoin & 0x1) && f->fp() == fp) {
76115:         /* The VMFrame is calling CompileFunction. */
76143:         innerfp->setRejoin(StubRejoin((RejoinState) f->stubRejoin));
76115:         *frameAddr = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpoline);
76115:     }
76128:     if (*frameAddr == codeStart + inlined->codeOffset) {
76115:         /* The VMFrame returns directly into the expanded frame. */
76115:         SetRejoinState(innerfp, *inlined, frameAddr);
76115:     }
76115: 
76115:     if (f->fp() == fp) {
76001:         JS_ASSERT(f->regs.inlined() == inlined);
76001:         f->regs.expandInline(innerfp, innerpc);
75864:     }
75864: 
76020:     /*
76020:      * Note: unlike the case for recompilation, during frame expansion we don't
76020:      * need to worry about the next VMFrame holding a reference to the inlined
76020:      * frame in its entryncode. entryncode is non-NULL only if the next frame's
76020:      * code was discarded and has executed via the Interpoline, which can only
76020:      * happen after all inline frames have been expanded.
76020:      */
75864: 
75864:     if (next) {
75864:         next->resetInlinePrev(innerfp, innerpc);
75864:         void **addr = next->addressOfNativeReturnAddress();
76020:         if (JITCodeReturnAddress(*addr)) {
76020:             innerfp->setRejoin(ScriptedRejoin(inlined->pcOffset));
76020:             *addr = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolineScripted);
75864:         }
75864:     }
75864: }
75864: 
75864: void
75864: ExpandInlineFrames(JSContext *cx, bool all)
75864: {
75864:     if (!all) {
75864:         VMFrame *f = cx->compartment->jaegerCompartment->activeFrame();
76001:         if (f && f->regs.inlined() && cx->fp() == f->fp())
76001:             mjit::Recompiler::expandInlineFrames(cx, f->fp(), f->regs.inlined(), NULL, f);
75864:         return;
75864:     }
75864: 
75864:     for (VMFrame *f = cx->compartment->jaegerCompartment->activeFrame();
75864:          f != NULL;
75864:          f = f->previous) {
75864: 
76001:         if (f->regs.inlined()) {
76001:             StackSegment &seg = cx->stack.space().containingSegment(f->fp());
76001:             FrameRegs &regs = seg.currentRegs();
76001:             if (regs.fp() == f->fp()) {
76001:                 JS_ASSERT(&regs == &f->regs);
76001:                 mjit::Recompiler::expandInlineFrames(cx, f->fp(), f->regs.inlined(), NULL, f);
75864:             } else {
76001:                 StackFrame *nnext = seg.computeNextFrame(f->fp());
76001:                 mjit::Recompiler::expandInlineFrames(cx, f->fp(), f->regs.inlined(), nnext, f);
75864:             }
75864:         }
75864: 
76001:         StackFrame *end = f->entryfp->prev();
76001:         StackFrame *next = NULL;
76001:         for (StackFrame *fp = f->fp(); fp != end; fp = fp->prev()) {
75864:             mjit::CallSite *inlined;
75864:             fp->pc(cx, next, &inlined);
75864:             if (next && inlined) {
75864:                 mjit::Recompiler::expandInlineFrames(cx, fp, inlined, next, f);
75864:                 fp = next;
75864:                 next = NULL;
75864:             } else {
75864:                 next = fp;
75864:             }
75864:         }
75864:     }
75864: }
75864: 
53391: Recompiler::Recompiler(JSContext *cx, JSScript *script)
53391:   : cx(cx), script(script)
53168: {    
53168: }
53168: 
53168: /*
75636:  * Recompilation can be triggered either by the debugger (turning debug mode on for
75636:  * a script or setting/clearing a trap), or by dynamic changes in type information
76020:  * from type inference. When recompiling we don't immediately recompile the JIT
76020:  * code, but destroy the old code and remove all references to the code, including
76020:  * those from active stack frames. Things to do:
75636:  *
76020:  * - Purge scripted call inline caches calling into the script.
75636:  *
76020:  * - For frames with an ncode return address in the original script, redirect
76020:  *   to the interpoline.
75636:  *
75636:  * - For VMFrames with a stub call return address in the original script,
76020:  *   redirect to the interpoline.
75636:  *
76020:  * - For VMFrames whose entryncode address (the value of entryfp->ncode before
76020:  *   being clobbered with JaegerTrampolineReturn) is in the original script,
76020:  *   redirect that entryncode to the interpoline.
75636:  */
76020: void
76030: Recompiler::recompile(bool resetUses)
75636: {
75636:     JS_ASSERT(script->hasJITCode());
75636: 
75636:     JaegerSpew(JSpew_Recompile, "recompiling script (file \"%s\") (line \"%d\") (length \"%d\")\n",
75636:                script->filename, script->lineno, script->length);
75636: 
75892:     types::AutoEnterTypeInference enter(cx, true);
75892: 
75636:     /*
53168:      * The strategy for this goes as follows:
53168:      * 
53168:      * 1) Scan the stack, looking at all return addresses that could go into JIT
53168:      *    code.
53168:      * 2) If an address corresponds to a call site registered by |callSite| during
76020:      *    the last compilation, patch it to go to the interpoline.
76020:      * 3) Purge the old compiled state.
53168:      */
56854: 
56854:     // Find all JIT'd stack frames to account for return addresses that will
56854:     // need to be patched after recompilation.
76020:     VMFrame *nextf = NULL;
56854:     for (VMFrame *f = script->compartment->jaegerCompartment->activeFrame();
56854:          f != NULL;
56854:          f = f->previous) {
56854: 
56854:         // Scan all frames owned by this VMFrame.
69223:         StackFrame *end = f->entryfp->prev();
76001:         StackFrame *next = NULL;
69223:         for (StackFrame *fp = f->fp(); fp != end; fp = fp->prev()) {
75864:             if (fp->script() != script) {
75864:                 next = fp;
75864:                 continue;
75864:             }
56854: 
75864:             if (next) {
75636:                 // check for a scripted call returning into the recompiled script.
75864:                 // this misses scanning the entry fp, which cannot return directly
75864:                 // into JIT code.
75864:                 void **addr = next->addressOfNativeReturnAddress();
75864: 
76020:                 if (JITCodeReturnAddress(*addr)) {
76020:                     JS_ASSERT(fp->jit()->isValidCode(*addr));
76020:                     patchCall(fp->jit(), fp, addr);
76020:                 } else if (nextf && nextf->entryfp == next &&
76020:                            JITCodeReturnAddress(nextf->entryncode)) {
76020:                     JS_ASSERT(fp->jit()->isValidCode(nextf->entryncode));
76020:                     patchCall(fp->jit(), fp, &nextf->entryncode);
62075:                 }
75864:             }
75636: 
75636:             next = fp;
62075:         }
62075: 
76020:         /*
76020:          * Check if the VMFrame returns directly into the recompiled script.
76020:          * This depends on an important invariant that f->fp() reflects the
76020:          * frame at the point where the call occurred, irregardless of any
76020:          * frames which were pushed inside the call.
76020:          */
76001:         StackFrame *fp = f->fp();
62075:         void **addr = f->returnAddressLocation();
76020:         RejoinState rejoin = (RejoinState) f->stubRejoin;
76020:         if (rejoin == REJOIN_NATIVE || rejoin == REJOIN_NATIVE_LOWERED) {
75636:             // Native call.
76127:             if (fp->script() == script && fp->isConstructing())
76115:                 patchNative(cx, script->jitCtor, fp, fp->pc(cx, NULL), NULL, rejoin);
76127:             else if (fp->script() == script)
76115:                 patchNative(cx, script->jitNormal, fp, fp->pc(cx, NULL), NULL, rejoin);
76020:         } else if (rejoin) {
76020:             /* Recompilation triggered by CompileFunction. */
76143:             if (fp->script() == script) {
76143:                 fp->setRejoin(StubRejoin(rejoin));
76020:                 *addr = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpoline);
75997:             }
75743:         } else if (script->jitCtor && script->jitCtor->isValidCode(*addr)) {
76020:             patchCall(script->jitCtor, fp, addr);
55503:         } else if (script->jitNormal && script->jitNormal->isValidCode(*addr)) {
76020:             patchCall(script->jitNormal, fp, addr);
53168:         }
53168: 
76020:         nextf = f;
57766:     }
55503: 
76020:     if (script->jitNormal) {
76020:         cleanup(script->jitNormal);
76020:         ReleaseScriptCode(cx, script, true);
76020:     }
76020:     if (script->jitCtor) {
76020:         cleanup(script->jitCtor);
76020:         ReleaseScriptCode(cx, script, false);
76020:     }
75879: 
76030:     if (resetUses) {
76030:         /*
76030:          * Wait for the script to get warm again before doing another compile,
76030:          * unless we are recompiling *because* the script got hot.
76030:          */
76030:         script->resetUseCount();
76030:     }
76030: 
75883:     cx->compartment->types.recompilations++;
62075: }
62075: 
76020: void
76020: Recompiler::cleanup(JITScript *jit)
62075: {
75636:     while (!JS_CLIST_IS_EMPTY(&jit->callers)) {
75636:         JaegerSpew(JSpew_Recompile, "Purging IC caller\n");
75636: 
75636:         JS_STATIC_ASSERT(offsetof(ic::CallICInfo, links) == 0);
75636:         ic::CallICInfo *ic = (ic::CallICInfo *) jit->callers.next;
75636: 
75636:         uint8 *start = (uint8 *)ic->funGuard.executableAddress();
75716:         JSC::RepatchBuffer repatch(JSC::JITCode(start - 32, 64));
75636: 
75636:         repatch.repatch(ic->funGuard, NULL);
75636:         repatch.relink(ic->funJump, ic->slowPathStart);
75636:         ic->purgeGuardedObject();
75636:     }
53168: }
53168: 
53170: } /* namespace mjit */
53170: } /* namespace js */
53168: 
53178: #endif /* JS_METHODJIT */
53178: 
