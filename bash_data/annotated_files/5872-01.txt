   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: // vim:cindent:ts=2:et:sw=2:
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Dan Rosen <dr@netscape.com>
   1:  *   Mats Palmgren <mats.palmgren@bredband.net>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: /*
   1:  * construction of a frame tree that is nearly isomorphic to the content
   1:  * tree and updating of that tree in response to dynamic changes
   1:  */
   1: 
   1: #include "nsCSSFrameConstructor.h"
   1: #include "nsCRT.h"
   1: #include "nsIAtom.h"
   1: #include "nsIURL.h"
   1: #include "nsISupportsArray.h"
   1: #include "nsHashtable.h"
   1: #include "nsIHTMLDocument.h"
   1: #include "nsIStyleRule.h"
   1: #include "nsIFrame.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsPresContext.h"
   1: #include "nsILinkHandler.h"
   1: #include "nsIDocument.h"
   1: #include "nsTableFrame.h"
   1: #include "nsTableColGroupFrame.h"
   1: #include "nsTableColFrame.h"
   1: #include "nsIDOMHTMLDocument.h"
   1: #include "nsIDOMHTMLTableColElement.h"
   1: #include "nsIDOMHTMLTableCaptionElem.h"
   1: #include "nsHTMLParts.h"
   1: #include "nsIPresShell.h"
   1: #include "nsStyleSet.h"
   1: #include "nsIViewManager.h"
   1: #include "nsIEventStateManager.h"
   1: #include "nsIScrollableView.h"
   1: #include "nsStyleConsts.h"
   1: #include "nsTableOuterFrame.h"
   1: #include "nsIDOMXULElement.h"
   1: #include "nsHTMLContainerFrame.h"
   1: #include "nsINameSpaceManager.h"
   1: #include "nsIDOMHTMLSelectElement.h"
   1: #include "nsIDOMHTMLLegendElement.h"
   1: #include "nsIComboboxControlFrame.h"
   1: #include "nsIListControlFrame.h"
   1: #include "nsISelectControlFrame.h"
   1: #include "nsIRadioControlFrame.h"
   1: #include "nsICheckboxControlFrame.h"
   1: #include "nsIDOMCharacterData.h"
   1: #include "nsIDOMHTMLImageElement.h"
   1: #include "nsPlaceholderFrame.h"
   1: #include "nsTableRowGroupFrame.h"
   1: #include "nsStyleChangeList.h"
   1: #include "nsIFormControl.h"
   1: #include "nsCSSAnonBoxes.h"
   1: #include "nsCSSPseudoElements.h"
   1: #include "nsIDeviceContext.h"
   1: #include "nsTextFragment.h"
   1: #include "nsISupportsArray.h"
   1: #include "nsIAnonymousContentCreator.h"
   1: #include "nsFrameManager.h"
   1: #include "nsLegendFrame.h"
   1: #include "nsIContentIterator.h"
   1: #include "nsBoxLayoutState.h"
   1: #include "nsBindingManager.h"
   1: #include "nsXBLBinding.h"
   1: #include "nsITheme.h"
   1: #include "nsContentCID.h"
   1: #include "nsContentUtils.h"
   1: #include "nsIDocShell.h"
   1: #include "nsIDocShellTreeItem.h"
   1: #include "nsObjectFrame.h"
   1: #include "nsRuleNode.h"
   1: #include "nsIDOMMutationEvent.h"
   1: #include "nsChildIterator.h"
   1: #include "nsCSSRendering.h"
   1: #include "nsISelectElement.h"
   1: #include "nsLayoutErrors.h"
   1: #include "nsLayoutUtils.h"
   1: #include "nsAutoPtr.h"
   1: #include "nsBoxFrame.h"
   1: #include "nsIBoxLayout.h"
   1: #include "nsImageFrame.h"
   1: #include "nsIObjectLoadingContent.h"
   1: #include "nsContentErrors.h"
3645: #include "nsIPrincipal.h"
   1: #include "nsIDOMWindowInternal.h"
   1: 
   1: #include "nsBox.h"
   1: 
   1: #ifdef MOZ_XUL
   1: #include "nsIRootBox.h"
   1: #include "nsIDOMXULCommandDispatcher.h"
   1: #include "nsIDOMXULDocument.h"
   1: #include "nsIXULDocument.h"
   1: #endif
   1: #ifdef ACCESSIBILITY
   1: #include "nsIAccessibilityService.h"
   1: #include "nsIAccessibleEvent.h"
   1: #endif
   1: 
   1: #include "nsInlineFrame.h"
   1: #include "nsBlockFrame.h"
   1: 
   1: #include "nsIScrollableFrame.h"
   1: 
   1: #include "nsIXBLService.h"
   1: 
   1: #undef NOISY_FIRST_LETTER
   1: 
   1: #ifdef MOZ_MATHML
   1: #include "nsMathMLParts.h"
   1: #endif
   1: 
   1: nsIFrame*
   1: NS_NewHTMLCanvasFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: #ifdef MOZ_SVG
   1: #include "nsISVGTextContentMetrics.h"
   1: #include "nsStyleUtil.h"
   1: 
   1: PRBool
   1: NS_SVGEnabled();
   1: nsIFrame*
   1: NS_NewSVGOuterSVGFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGInnerSVGFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGPathGeometryFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGGFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGGenericContainerFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: #ifdef MOZ_SVG_FOREIGNOBJECT
   1: nsIFrame*
   1: NS_NewSVGForeignObjectFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: #endif
   1: nsIFrame*
   1: NS_NewSVGAFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGGlyphFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsIFrame* parent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGTextFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGTSpanFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsIFrame* parent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGContainerFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGUseFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: PRBool 
   1: NS_SVG_TestFeatures (const nsAString& value);
   1: PRBool 
   1: NS_SVG_TestsSupported (const nsIAtom *atom);
   1: PRBool 
   1: NS_SVG_LangSupported (const nsIAtom *atom);
   1: extern nsIFrame*
   1: NS_NewSVGLinearGradientFrame(nsIPresShell *aPresShell, nsIContent *aContent, nsStyleContext* aContext);
   1: extern nsIFrame*
   1: NS_NewSVGRadialGradientFrame(nsIPresShell *aPresShell, nsIContent *aContent, nsStyleContext* aContext);
   1: extern nsIFrame*
   1: NS_NewSVGStopFrame(nsIPresShell *aPresShell, nsIContent *aContent, nsIFrame *aParentFrame, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGMarkerFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: extern nsIFrame*
   1: NS_NewSVGImageFrame(nsIPresShell *aPresShell, nsIContent *aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGClipPathFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGTextPathFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsIFrame* parent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGFilterFrame(nsIPresShell *aPresShell, nsIContent *aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGPatternFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGMaskFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSVGLeafFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: #endif
   1: 
   1: #include "nsIDocument.h"
   1: #include "nsIDOMElement.h"
   1: #include "nsIDOMNodeList.h"
   1: #include "nsIDOMDocument.h"
   1: #include "nsIDOMDocumentXBL.h"
   1: #include "nsIScrollable.h"
   1: #include "nsINodeInfo.h"
   1: #include "prenv.h"
   1: #include "nsWidgetsCID.h"
   1: #include "nsNodeInfoManager.h"
   1: #include "nsContentCreatorFunctions.h"
   1: #include "nsIServiceManager.h"
   1: 
   1: // Global object maintenance
   1: nsIXBLService * nsCSSFrameConstructor::gXBLService = nsnull;
   1: 
   1: // Global prefs
   1: static PRBool gGotXBLFormPrefs = PR_FALSE;
   1: static PRBool gUseXBLForms = PR_FALSE;
   1: 
   1: #ifdef DEBUG
   1: // Set the environment variable GECKO_FRAMECTOR_DEBUG_FLAGS to one or
   1: // more of the following flags (comma separated) for handy debug
   1: // output.
   1: static PRBool gNoisyContentUpdates = PR_FALSE;
   1: static PRBool gReallyNoisyContentUpdates = PR_FALSE;
   1: static PRBool gNoisyInlineConstruction = PR_FALSE;
   1: static PRBool gVerifyFastFindFrame = PR_FALSE;
   1: static PRBool gTablePseudoFrame = PR_FALSE;
   1: 
   1: struct FrameCtorDebugFlags {
   1:   const char* name;
   1:   PRBool* on;
   1: };
   1: 
   1: static FrameCtorDebugFlags gFlags[] = {
   1:   { "content-updates",              &gNoisyContentUpdates },
   1:   { "really-noisy-content-updates", &gReallyNoisyContentUpdates },
   1:   { "noisy-inline",                 &gNoisyInlineConstruction },
   1:   { "fast-find-frame",              &gVerifyFastFindFrame },
   1:   { "table-pseudo",                 &gTablePseudoFrame },
   1: };
   1: 
   1: #define NUM_DEBUG_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
   1: #endif
   1: 
   1: 
   1: #ifdef MOZ_XUL
   1: #include "nsMenuFrame.h"
   1: #include "nsPopupSetFrame.h"
   1: #include "nsTreeColFrame.h"
   1: #include "nsIBoxObject.h"
   1: #include "nsPIListBoxObject.h"
   1: #include "nsListBoxBodyFrame.h"
   1: #include "nsListItemFrame.h"
   1: 
   1: //------------------------------------------------------------------
   1: 
   1: nsIFrame*
   1: NS_NewAutoRepeatBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewRootBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewDocElementBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewThumbFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewDeckFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, nsIBoxLayout* aLayoutManager = nsnull);
   1: 
   1: nsIFrame*
   1: NS_NewLeafBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewStackFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, nsIBoxLayout* aLayoutManager = nsnull);
   1: 
   1: nsIFrame*
   1: NS_NewProgressMeterFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewImageBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewTextBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewGroupBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewButtonBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewSplitterFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewMenuPopupFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewPopupSetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewMenuFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
   1: 
   1: nsIFrame*
   1: NS_NewMenuBarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewTreeBodyFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: // grid
   1: nsresult
   1: NS_NewGridLayout2 ( nsIPresShell* aPresShell, nsIBoxLayout** aNewLayout );
   1: nsresult
   1: NS_NewGridRowLeafLayout ( nsIPresShell* aPresShell, nsIBoxLayout** aNewLayout );
   1: nsIFrame*
   1: NS_NewGridRowLeafFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot, nsIBoxLayout* aLayout);
   1: nsresult
   1: NS_NewGridRowGroupLayout ( nsIPresShell* aPresShell, nsIBoxLayout** aNewLayout );
   1: nsIFrame*
   1: NS_NewGridRowGroupFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot, nsIBoxLayout* aLayout);
   1: 
   1: nsresult
   1: NS_NewListBoxLayout ( nsIPresShell* aPresShell, nsCOMPtr<nsIBoxLayout>& aNewLayout );
   1: 
   1: // end grid
   1: 
   1: nsIFrame*
   1: NS_NewTitleBarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewResizerFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: 
   1: #endif
   1: 
   1: nsIFrame*
   1: NS_NewHTMLScrollFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot);
   1: 
   1: nsIFrame*
   1: NS_NewXULScrollFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot);
   1: 
   1: nsIFrame*
   1: NS_NewSliderFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewScrollbarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewScrollbarButtonFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: 
   1: #ifdef NOISY_FINDFRAME
   1: static PRInt32 FFWC_totalCount=0;
   1: static PRInt32 FFWC_doLoop=0;
   1: static PRInt32 FFWC_doSibling=0;
   1: static PRInt32 FFWC_recursions=0;
   1: static PRInt32 FFWC_nextInFlows=0;
   1: static PRInt32 FFWC_slowSearchForText=0;
   1: #endif
   1: 
   1: static nsresult
   1: DeletingFrameSubtree(nsFrameManager* aFrameManager,
   1:                      nsIFrame*       aFrame);
   1: 
   1: #ifdef  MOZ_SVG
   1: 
   1: static nsIFrame *
   1: SVG_GetFirstNonAAncestorFrame(nsIFrame *aParentFrame)
   1: {
   1:   for (nsIFrame *ancestorFrame = aParentFrame; ancestorFrame != nsnull;
   1:        ancestorFrame = ancestorFrame->GetParent()) {
   1:     if (ancestorFrame->GetType() != nsGkAtoms::svgAFrame) {
   1:       return ancestorFrame;
   1:     }
   1:   }
   1:   return nsnull;
   1: }
   1: 
   1: // Test to see if this language is supported
   1: static PRBool
   1: SVG_TestLanguage(const nsSubstring& lstr, const nsSubstring& prefs) 
   1: {
   1:   // Compare list to attribute value, which may be a list
   1:   // According to the SVG 1.1 Spec (at least as I read it), we should take
   1:   // the first attribute value and check it for any matches in the users
   1:   // preferences, including any prefix matches.
   1:   // This algorithm is O(M*N)
   1:   PRInt32 vbegin = 0;
   1:   PRInt32 vlen = lstr.Length();
   1:   while (vbegin < vlen) {
   1:     PRInt32 vend = lstr.FindChar(PRUnichar(','), vbegin);
   1:     if (vend == kNotFound) {
   1:       vend = vlen;
   1:     }
   1:     PRInt32 gbegin = 0;
   1:     PRInt32 glen = prefs.Length();
   1:     while (gbegin < glen) {
   1:       PRInt32 gend = prefs.FindChar(PRUnichar(','), gbegin);
   1:       if (gend == kNotFound) {
   1:         gend = glen;
   1:       }
   1:       const nsDefaultStringComparator defaultComparator;
   1:       const nsStringComparator& comparator = 
3233:                   static_cast<const nsStringComparator&>(defaultComparator);
   1:       if (nsStyleUtil::DashMatchCompare(Substring(lstr, vbegin, vend-vbegin),
   1:                                         Substring(prefs, gbegin, gend-gbegin),
   1:                                         comparator)) {
   1:         return PR_TRUE;
   1:       }
   1:       gbegin = gend + 1;
   1:     }
   1:     vbegin = vend + 1;
   1:   }
   1:   return PR_FALSE;
   1: }
   1: #endif
   1: 
   1: static inline nsIFrame*
   1: GetFieldSetAreaFrame(nsIFrame* aFieldsetFrame)
   1: {
   1:   // Depends on the fieldset child frame order - see ConstructFieldSetFrame() below.
   1:   nsIFrame* firstChild = aFieldsetFrame->GetFirstChild(nsnull);
   1:   return firstChild && firstChild->GetNextSibling() ? firstChild->GetNextSibling() : firstChild;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: static PRBool
2829: IsInlineOutside(nsIFrame* aFrame)
2829: {
2829:   return aFrame->GetStyleDisplay()->IsInlineOutside();
2829: }
2829: 
4696: /**
4696:  * True if aFrame is an actual inline frame in the sense of non-replaced
4696:  * display:inline CSS boxes.  In other words, it can be affected by {ib}
4696:  * splitting and can contain first-letter frames.  Basically, this is either an
4696:  * inline frame (positioned or otherwise) or an line frame (this last because
4696:  * it can contain first-letter and because inserting blocks in the middle of it
4696:  * needs to terminate it).
4696:  */
   1: static PRBool
4696: IsInlineFrame(const nsIFrame* aFrame)
4696: {
4696:   return aFrame->IsFrameOfType(nsIFrame::eLineParticipant);
   1: }
   1: 
   1: //----------------------------------------------------------------------
5324: //
5324: // When inline frames get weird and have block frames in them, we
5324: // annotate them to help us respond to incremental content changes
5324: // more easily.
5324: 
5324: static inline PRBool
5324: IsFrameSpecial(nsIFrame* aFrame)
5324: {
5324:   return (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) != 0;
5324: }
5324: 
5324: static nsIFrame* GetSpecialSibling(nsIFrame* aFrame)
5324: {
5324:   // We only store the "special sibling" annotation with the first
5324:   // frame in the continuation chain. Walk back to find that frame now.
5324:   aFrame = aFrame->GetFirstContinuation();
5324: 
5324:   void* value = aFrame->GetProperty(nsGkAtoms::IBSplitSpecialSibling);
5324: 
5324:   return static_cast<nsIFrame*>(value);
5324: }
5324: 
5324: static nsIFrame*
5324: GetIBSplitSpecialPrevSibling(nsIFrame* aFrame)
5324: {
5324:   NS_PRECONDITION(IsFrameSpecial(aFrame) && !IsInlineFrame(aFrame),
5324:                   "Shouldn't call this");
5324:   
5324:   // We only store the "special sibling" annotation with the first
5324:   // frame in the continuation chain. Walk back to find that frame now.  
5324:   return
5324:     static_cast<nsIFrame*>
5324:     (aFrame->GetFirstContinuation()->
5324:        GetProperty(nsGkAtoms::IBSplitSpecialPrevSibling));
5324: }
5324: 
5324: static nsIFrame*
5324: GetLastSpecialSibling(nsIFrame* aFrame)
5324: {
5324:   for (nsIFrame *frame = aFrame, *next; ; frame = next) {
5324:     next = GetSpecialSibling(frame);
5324:     if (!next)
5324:       return frame;
5324:   }
5324:   NS_NOTREACHED("unreachable code");
5324:   return nsnull;
5324: }
5324: 
5324: static void
5324: SetFrameIsSpecial(nsIFrame* aFrame, nsIFrame* aSpecialSibling)
5324: {
5324:   NS_PRECONDITION(aFrame, "bad args!");
5324: 
5324:   // Mark the frame and all of its siblings as "special".
5324:   for (nsIFrame* frame = aFrame; frame != nsnull; frame = frame->GetNextContinuation()) {
5324:     frame->AddStateBits(NS_FRAME_IS_SPECIAL);
5324:   }
5324: 
5324:   if (aSpecialSibling) {
5324:     // We should be the first-in-flow
5324:     NS_ASSERTION(!aFrame->GetPrevInFlow(),
5324:                  "assigning special sibling to other than first-in-flow!");
5324: 
5324:     // Store the "special sibling" (if we were given one) with the
5324:     // first frame in the flow.
5324:     aFrame->SetProperty(nsGkAtoms::IBSplitSpecialSibling, aSpecialSibling);
5324:   }
5324: }
5324: 
5324: static nsIFrame*
5324: GetIBContainingBlockFor(nsIFrame* aFrame)
5324: {
5324:   NS_PRECONDITION(IsFrameSpecial(aFrame),
5324:                   "GetIBContainingBlockFor() should only be called on known IB frames");
5324: 
5324:   // Get the first "normal" ancestor of the target frame.
5324:   nsIFrame* parentFrame;
5324:   do {
5324:     parentFrame = aFrame->GetParent();
5324: 
5324:     if (! parentFrame) {
5324:       NS_ERROR("no unsplit block frame in IB hierarchy");
5324:       return aFrame;
5324:     }
5324: 
5324:     // Note that we ignore non-special frames which have a pseudo on their
5324:     // style context -- they're not the frames we're looking for!  In
5324:     // particular, they may be hiding a real parent that _is_ special.
5324:     if (!IsFrameSpecial(parentFrame) &&
5324:         !parentFrame->GetStyleContext()->GetPseudoType())
5324:       break;
5324: 
5324:     aFrame = parentFrame;
5324:   } while (1);
5324:  
5324:   // post-conditions
5324:   NS_ASSERTION(parentFrame, "no normal ancestor found for special frame in GetIBContainingBlockFor");
5324:   NS_ASSERTION(parentFrame != aFrame, "parentFrame is actually the child frame - bogus reslt");
5324: 
5324:   return parentFrame;
5324: }
5324: 
5324: //----------------------------------------------------------------------
   1: 
   1: // Block/inline frame construction logic. We maintain a few invariants here:
   1: //
   1: // 1. Block frames contain block and inline frames.
   1: //
   1: // 2. Inline frames only contain inline frames. If an inline parent has a block
   1: // child then the block child is migrated upward until it lands in a block
   1: // parent (the inline frames containing block is where it will end up).
   1: 
   1: static nsIFrame*
   1: FindFirstBlock(nsIFrame* aKid, nsIFrame** aPrevKid)
   1: {
   1:   nsIFrame* prevKid = nsnull;
   1:   while (aKid) {
2829:     if (!IsInlineOutside(aKid)) {
   1:       *aPrevKid = prevKid;
   1:       return aKid;
   1:     }
   1:     prevKid = aKid;
   1:     aKid = aKid->GetNextSibling();
   1:   }
   1:   *aPrevKid = nsnull;
   1:   return nsnull;
   1: }
   1: 
   1: static nsIFrame*
   1: FindLastBlock(nsIFrame* aKid)
   1: {
   1:   nsIFrame* lastBlock = nsnull;
   1:   while (aKid) {
2829:     if (!IsInlineOutside(aKid)) {
   1:       lastBlock = aKid;
   1:     }
   1:     aKid = aKid->GetNextSibling();
   1:   }
   1:   return lastBlock;
   1: }
   1: 
   1: /*
   1:  * Unlike the special (next) sibling, the special previous sibling
   1:  * property points only from the anonymous block to the original
   1:  * inline that preceded it.  DO NOT CHANGE THAT -- the
   1:  * GetParentStyleContextFrame code depends on it!  It is useful for
   1:  * finding the "special parent" of a frame (i.e., a frame from which a
   1:  * good parent style context can be obtained), one looks at the
   1:  * special previous sibling annotation of the real parent of the frame
   1:  * (if the real parent has NS_FRAME_IS_SPECIAL).
   1:  */
   1: inline void
5324: MarkIBSpecialPrevSibling(nsIFrame *aAnonymousFrame,
   1:                          nsIFrame *aSpecialParent)
   1: {
5324:   aAnonymousFrame->SetProperty(nsGkAtoms::IBSplitSpecialPrevSibling,
   1:                                aSpecialParent, nsnull, nsnull);
   1: }
   1: 
   1: // -----------------------------------------------------------
   1: 
   1: // Helper function that recursively removes content to frame mappings and
   1: // undisplayed content mappings.
   1: // This differs from DeletingFrameSubtree() because the frames have not yet been
   1: // added to the frame hierarchy.
   1: // XXXbz it would really help if we merged the two methods somehow... :(
   1: static void
   1: DoCleanupFrameReferences(nsFrameManager*  aFrameManager,
   1:                          nsIFrame*        aFrameIn)
   1: {
   1:   nsIContent* content = aFrameIn->GetContent();
   1: 
   1:   if (aFrameIn->GetType() == nsGkAtoms::placeholderFrame) {
3233:     nsPlaceholderFrame* placeholder = static_cast<nsPlaceholderFrame*>
3233:                                                  (aFrameIn);
   1:     // if the frame is a placeholder use the out of flow frame
   1:     aFrameIn = nsPlaceholderFrame::GetRealFrameForPlaceholder(placeholder);
   1: 
   1:     // And don't forget to unregister the placeholder mapping.  Note that this
   1:     // means it's the caller's responsibility to actually destroy the
   1:     // out-of-flow pointed to by the placeholder, since after this point the
   1:     // out-of-flow is not reachable via the placeholder.
   1:     aFrameManager->UnregisterPlaceholderFrame(placeholder);
   1:   }
   1: 
   1:   // Remove the mapping from the content object to its frame
   1:   aFrameManager->RemoveAsPrimaryFrame(content, aFrameIn);
   1:   aFrameManager->ClearAllUndisplayedContentIn(content);
   1: 
   1:   // Recursively walk the child frames.
   1:   nsIAtom* childListName = nsnull;
   1:   PRInt32 childListIndex = 0;
   1:   do {
   1:     nsIFrame* childFrame = aFrameIn->GetFirstChild(childListName);
   1:     while (childFrame) {
   1:       DoCleanupFrameReferences(aFrameManager, childFrame);
   1:     
   1:       // Get the next sibling child frame
   1:       childFrame = childFrame->GetNextSibling();
   1:     }
   1: 
   1:     childListName = aFrameIn->GetAdditionalChildListName(childListIndex++);
   1:   } while (childListName);
   1: }
   1: 
   1: // Helper function that walks a frame list and calls DoCleanupFrameReference()
   1: static void
   1: CleanupFrameReferences(nsFrameManager*  aFrameManager,
   1:                        nsIFrame*        aFrameList)
   1: {
   1:   while (aFrameList) {
   1:     DoCleanupFrameReferences(aFrameManager, aFrameList);
   1: 
   1:     // Get the sibling frame
   1:     aFrameList = aFrameList->GetNextSibling();
   1:   }
   1: }
   1: 
   1: // -----------------------------------------------------------
   1: 
   1: // Structure used when constructing formatting object trees.
   1: struct nsFrameItems {
   1:   nsIFrame* childList;
   1:   nsIFrame* lastChild;
   1:   
   1:   nsFrameItems(nsIFrame* aFrame = nsnull);
   1: 
   1:   // Appends the frame to the end of the list
   1:   void AddChild(nsIFrame* aChild);
   1: 
   1:   // Inserts the frame somewhere in the list
   1:   void InsertChildAfter(nsIFrame* aChild, nsIFrame* aAfter);
   1: 
4368:   // Remove the frame from the list, return PR_FALSE if not found.  If
4368:   // aPrevSibling is given, it must have aChild as its GetNextSibling().
4368:   // aPrevSibling may be null to indicate that the list should be searched.
4368:   PRBool RemoveChild(nsIFrame* aChild, nsIFrame* aPrevSibling);
   1: };
   1: 
   1: nsFrameItems::nsFrameItems(nsIFrame* aFrame)
   1:   : childList(aFrame), lastChild(aFrame)
   1: {
   1: }
   1: 
   1: void 
   1: nsFrameItems::AddChild(nsIFrame* aChild)
   1: {
   1: #ifdef DEBUG
   1:   nsIFrame* oldLastChild = lastChild;
   1: #endif
   1:   
   1:   if (childList == nsnull) {
   1:     childList = lastChild = aChild;
   1:   }
   1:   else
   1:   {
   1:     NS_ASSERTION(aChild != lastChild,
   1:                  "Same frame being added to frame list twice?");
   1:     lastChild->SetNextSibling(aChild);
   1:     lastChild = aChild;
   1:   }
   1:   // if aChild has siblings, lastChild needs to be the last one
   1:   for (nsIFrame* sib = lastChild->GetNextSibling(); sib;
   1:        sib = sib->GetNextSibling()) {
   1:     NS_ASSERTION(oldLastChild != sib, "Loop in frame list");
   1:     lastChild = sib;
   1:   }
   1: }
   1: 
   1: void
   1: nsFrameItems::InsertChildAfter(nsIFrame* aChild, nsIFrame* aAfter)
   1: {
   1:   if (!childList || (aAfter && !aAfter->GetNextSibling())) {
   1:     // Appending to the end of the list
   1:     AddChild(aChild);
   1:     return;
   1:   }
   1:   if (!aAfter) {
   1:     // Inserting at beginning of list
   1:     aChild->SetNextSibling(childList);
   1:     childList = aChild;
   1:     return;
   1:   }
   1:   aChild->SetNextSibling(aAfter->GetNextSibling());
   1:   aAfter->SetNextSibling(aChild);
   1: }
   1: 
   1: PRBool
4368: nsFrameItems::RemoveChild(nsIFrame* aFrame, nsIFrame* aPrevSibling)
   1: {
   1:   NS_PRECONDITION(aFrame, "null ptr");
4368: 
4368:   nsIFrame* prev;
4368:   if (aPrevSibling) {
4368:     prev = aPrevSibling;
4368:   } else {
4368:     prev = nsnull;
4368:     nsIFrame* sib;
4368:     for (sib = childList; sib && sib != aFrame; sib = sib->GetNextSibling()) {
   1:       prev = sib;
   1:     }
   1:     if (!sib) {
   1:       return PR_FALSE;
   1:     }
4368:   }
4368: 
4368:   NS_ASSERTION(!prev || prev->GetNextSibling() == aFrame,
4368:                "Unexpected prevsibling");
4368: 
4368:   if (aFrame == childList) {
4368:     childList = aFrame->GetNextSibling();
   1:   } else {
4368:     prev->SetNextSibling(aFrame->GetNextSibling());
4368:   }
4368:   if (aFrame == lastChild) {
   1:     lastChild = prev;
   1:   }
4368:   aFrame->SetNextSibling(nsnull);
   1:   return PR_TRUE;
   1: }
   1: 
   1: // -----------------------------------------------------------
   1: 
   1: // Structure used when constructing formatting object trees. Contains
   1: // state information needed for absolutely positioned elements
   1: struct nsAbsoluteItems : nsFrameItems {
   1:   // containing block for absolutely positioned elements
   1:   nsIFrame* containingBlock;
   1:   
   1:   nsAbsoluteItems(nsIFrame* aContainingBlock);
   1: #ifdef DEBUG
   1:   // XXXbz Does this need a debug-only assignment operator that nulls out the
   1:   // childList in the nsAbsoluteItems we're copying?  Introducing a difference
   1:   // between debug and non-debug behavior seems bad, so I guess not...
   1:   ~nsAbsoluteItems() {
   1:     NS_ASSERTION(!childList,
   1:                  "Dangling child list.  Someone forgot to insert it?");
   1:   }
   1: #endif
   1:   
   1:   // Appends the frame to the end of the list
   1:   void AddChild(nsIFrame* aChild);
   1: };
   1: 
   1: nsAbsoluteItems::nsAbsoluteItems(nsIFrame* aContainingBlock)
   1:   : containingBlock(aContainingBlock)
   1: {
   1: }
   1: 
   1: // Additional behavior is that it sets the frame's NS_FRAME_OUT_OF_FLOW flag
   1: void
   1: nsAbsoluteItems::AddChild(nsIFrame* aChild)
   1: {
 238:   NS_ASSERTION(aChild->PresContext()->FrameManager()->
   1:                GetPlaceholderFrameFor(aChild),
   1:                "Child without placeholder being added to nsAbsoluteItems?");
   1:   aChild->AddStateBits(NS_FRAME_OUT_OF_FLOW);
   1:   nsFrameItems::AddChild(aChild);
   1: }
   1: 
   1: // Structures used to record the creation of pseudo table frames where 
   1: // the content belongs to some ancestor. 
   1: // PseudoFrames are necessary when the childframe cannot be the direct
   1: // ancestor of the content based parent frame. The amount of necessary pseudo
   1: // frames is limited as the worst case would be table frame nested directly
   1: // into another table frame. So the member structures of nsPseudoFrames can be
   1: // viewed as a ring buffer where you start with the necessary frame type and
   1: // add higher frames as long as necessary to fit into the initial parent frame.
   1: // mLowestType is some sort of stack pointer which shows the start of the
   1: // ringbuffer. The insertion of pseudo frames can happen between every
   1: // two frames so we need to push and pop the pseudo frame data when children
   1: // of a frame are created.
   1: // The colgroup frame is special as it can harbour only col children.
   1: // Once all children of given frame are known, the pseudo frames can be
   1: // processed that means attached to the corresponding parent frames.
   1: // The behaviour is in general described at
   1: // http://www.w3.org/TR/CSS21/tables.html#anonymous-boxes
   1: // however there are implementation details that extend the CSS 2.1
   1: // specification:
   1: // 1. every table frame is wrapped in an outer table frame, which is always a
   1: //    pseudo frame.
   1: // 2. the outer table frame will be also created to hold a caption.
   1: // 3. each table cell will have a pseudo inner table cell frame.
   1: // 4. a colgroup frame is created between a column and a table
   1: // 5. a rowgroup frame is created between a row and a table
   1: // A table frame can only have rowgroups or column groups as children.
   1: // A outer table frame can only have one caption and one table frame
   1: // as children.
   1: // Every table even if all table frames are specified will require the
   1: // creation of two types of pseudo frames: the outer table frame and the inner
   1: // table cell frames.
   1: 
   1: struct nsPseudoFrameData {
   1:   nsIFrame*    mFrame; // created pseudo frame
   1:   nsFrameItems mChildList;  // child frames pending to be added to the pseudo
   1:   nsFrameItems mChildList2; // child frames pending to be added to the pseudo
   1: 
   1:   nsPseudoFrameData();
   1:   nsPseudoFrameData(nsPseudoFrameData& aOther);
   1:   void Reset();
   1: #ifdef DEBUG
   1:   void Dump();
   1: #endif
   1: };
   1: 
   1: struct nsPseudoFrames {
   1:   nsPseudoFrameData mTableOuter; 
   1:   nsPseudoFrameData mTableInner;  
   1:   nsPseudoFrameData mRowGroup;   
   1:   nsPseudoFrameData mColGroup;
   1:   nsPseudoFrameData mRow;   
   1:   nsPseudoFrameData mCellOuter;
   1:   nsPseudoFrameData mCellInner;
   1: 
   1:   // the frame type of the most descendant pseudo frame, no AddRef
   1:   nsIAtom*          mLowestType;
   1: 
   1:   nsPseudoFrames();
   1:   nsPseudoFrames& operator=(const nsPseudoFrames& aOther);
   1:   void Reset(nsPseudoFrames* aSave = nsnull);
   1:   PRBool IsEmpty() { return (!mLowestType && !mColGroup.mFrame); }
   1: #ifdef DEBUG
   1:   void Dump();
   1: #endif
   1: };
   1: 
   1: nsPseudoFrameData::nsPseudoFrameData()
   1: : mFrame(nsnull), mChildList(), mChildList2()
   1: {}
   1: 
   1: nsPseudoFrameData::nsPseudoFrameData(nsPseudoFrameData& aOther)
   1: : mFrame(aOther.mFrame), mChildList(aOther.mChildList), 
   1:   mChildList2(aOther.mChildList2)
   1: {}
   1: 
   1: void
   1: nsPseudoFrameData::Reset()
   1: {
   1:   mFrame = nsnull;
   1:   mChildList.childList  = mChildList.lastChild  = nsnull;
   1:   mChildList2.childList = mChildList2.lastChild = nsnull;
   1: }
   1: 
   1: #ifdef DEBUG
   1: void
   1: nsPseudoFrameData::Dump()
   1: {
   1:   nsIFrame* main = nsnull;
   1:   nsIFrame* second = nsnull;
3233:   printf("        %p\n", static_cast<void*>(mFrame));
   1:   main = mChildList.childList;
   1: 
   1:  
   1:   second = mChildList2.childList;
   1:   while (main || second) {
3233:     printf("          %p   %p\n", static_cast<void*>(main),
3233:            static_cast<void*>(second));
   1:     if (main)
   1:       main = main->GetNextSibling();
   1:     if (second)
   1:       second = second->GetNextSibling();
   1:   }
   1: }
   1: #endif
   1: nsPseudoFrames::nsPseudoFrames() 
   1: : mTableOuter(), mTableInner(), mRowGroup(), mColGroup(), 
   1:   mRow(), mCellOuter(), mCellInner(), mLowestType(nsnull)
   1: {}
   1: 
   1: nsPseudoFrames& nsPseudoFrames::operator=(const nsPseudoFrames& aOther)
   1: {
   1:   mTableOuter = aOther.mTableOuter;
   1:   mTableInner = aOther.mTableInner;
   1:   mColGroup   = aOther.mColGroup;
   1:   mRowGroup   = aOther.mRowGroup;
   1:   mRow        = aOther.mRow;
   1:   mCellOuter  = aOther.mCellOuter;
   1:   mCellInner  = aOther.mCellInner;
   1:   mLowestType = aOther.mLowestType;
   1: 
   1:   return *this;
   1: }
   1: void
   1: nsPseudoFrames::Reset(nsPseudoFrames* aSave) 
   1: {
   1:   if (aSave) {
   1:     *aSave = *this;
   1:   }
   1: 
   1:   mTableOuter.Reset();
   1:   mTableInner.Reset();
   1:   mColGroup.Reset();
   1:   mRowGroup.Reset();
   1:   mRow.Reset();
   1:   mCellOuter.Reset();
   1:   mCellInner.Reset();
   1:   mLowestType = nsnull;
   1: }
   1: 
   1: #ifdef DEBUG
   1: void
   1: nsPseudoFrames::Dump()
   1: {
   1:   if (IsEmpty()) {
   1:     // check that it is really empty, warn otherwise
   1:     NS_ASSERTION(!mTableOuter.mFrame,    "Pseudo Outer Table Frame not empty");
   1:     NS_ASSERTION(!mTableOuter.mChildList.childList, "Pseudo Outer Table Frame has primary children");
   1:     NS_ASSERTION(!mTableOuter.mChildList2.childList,"Pseudo Outer Table Frame has secondary children");
   1:     NS_ASSERTION(!mTableInner.mFrame,    "Pseudo Inner Table Frame not empty");
   1:     NS_ASSERTION(!mTableInner.mChildList.childList, "Pseudo Inner Table Frame has primary children");
   1:     NS_ASSERTION(!mTableInner.mChildList2.childList,"Pseudo Inner Table Frame has secondary children");
   1:     NS_ASSERTION(!mColGroup.mFrame,      "Pseudo Colgroup Frame not empty");
   1:     NS_ASSERTION(!mColGroup.mChildList.childList,   "Pseudo Colgroup Table Frame has primary children");
   1:     NS_ASSERTION(!mColGroup.mChildList2.childList,  "Pseudo Colgroup Table Frame has secondary children");
   1:     NS_ASSERTION(!mRowGroup.mFrame,      "Pseudo Rowgroup Frame not empty");
   1:     NS_ASSERTION(!mRowGroup.mChildList.childList,   "Pseudo Rowgroup Frame has primary children");
   1:     NS_ASSERTION(!mRowGroup.mChildList2.childList,  "Pseudo Rowgroup Frame has secondary children");
   1:     NS_ASSERTION(!mRow.mFrame,           "Pseudo Row Frame not empty");
   1:     NS_ASSERTION(!mRow.mChildList.childList,        "Pseudo Row Frame has primary children");
   1:     NS_ASSERTION(!mRow.mChildList2.childList,       "Pseudo Row Frame has secondary children");
   1:     NS_ASSERTION(!mCellOuter.mFrame,     "Pseudo Outer Cell Frame not empty");
   1:     NS_ASSERTION(!mCellOuter.mChildList.childList,  "Pseudo Outer Cell Frame has primary children");
   1:     NS_ASSERTION(!mCellOuter.mChildList2.childList, "Pseudo Outer Cell Frame has secondary children");
   1:     NS_ASSERTION(!mCellInner.mFrame,     "Pseudo Inner Cell Frame not empty");
   1:     NS_ASSERTION(!mCellInner.mChildList.childList,  "Pseudo Inner Cell Frame has primary children");
   1:     NS_ASSERTION(!mCellInner.mChildList2.childList, "Pseudo inner Cell Frame has secondary children");
   1:   }
   1:   else {
   1:     if (mTableOuter.mFrame || mTableOuter.mChildList.childList || mTableOuter.mChildList2.childList) {
   1:       if (nsGkAtoms::tableOuterFrame == mLowestType) {
   1:         printf("LOW OuterTable\n");
   1:       }
   1:       else {
   1:         printf("    OuterTable\n");
   1:       }
   1:       mTableOuter.Dump();
   1:     }
   1:     if (mTableInner.mFrame || mTableInner.mChildList.childList || mTableInner.mChildList2.childList) {
   1:       if (nsGkAtoms::tableFrame == mLowestType) {
   1:         printf("LOW InnerTable\n");
   1:       }
   1:       else {
   1:         printf("    InnerTable\n");
   1:       }
   1:       mTableInner.Dump();
   1:     }
   1:     if (mColGroup.mFrame || mColGroup.mChildList.childList || mColGroup.mChildList2.childList) {
   1:       if (nsGkAtoms::tableColGroupFrame == mLowestType) {
   1:         printf("LOW ColGroup\n");
   1:       }
   1:       else {
   1:         printf("    ColGroup\n");
   1:       }
   1:       mColGroup.Dump();
   1:     }
   1:     if (mRowGroup.mFrame || mRowGroup.mChildList.childList || mRowGroup.mChildList2.childList) {
   1:       if (nsGkAtoms::tableRowGroupFrame == mLowestType) {
   1:         printf("LOW RowGroup\n");
   1:       }
   1:       else {
   1:         printf("    RowGroup\n");
   1:       }
   1:       mRowGroup.Dump();
   1:     }
   1:     if (mRow.mFrame || mRow.mChildList.childList || mRow.mChildList2.childList) {
   1:       if (nsGkAtoms::tableRowFrame == mLowestType) {
   1:         printf("LOW Row\n");
   1:       }
   1:       else {
   1:         printf("    Row\n");
   1:       }
   1:       mRow.Dump();
   1:     }
   1:     
   1:     if (mCellOuter.mFrame || mCellOuter.mChildList.childList || mCellOuter.mChildList2.childList) {
   1:       if (IS_TABLE_CELL(mLowestType)) {
   1:         printf("LOW OuterCell\n");
   1:       }
   1:       else {
   1:         printf("    OuterCell\n");
   1:       }
   1:       mCellOuter.Dump();
   1:     }
   1:     if (mCellInner.mFrame || mCellInner.mChildList.childList || mCellInner.mChildList2.childList) {
   1:       printf("    InnerCell\n");
   1:       mCellInner.Dump();
   1:     }
   1:   }
   1: }
   1: #endif
   1: // -----------------------------------------------------------
   1: 
   1: // Structure for saving the existing state when pushing/poping containing
   1: // blocks. The destructor restores the state to its previous state
   1: class nsFrameConstructorSaveState {
   1: public:
   1:   nsFrameConstructorSaveState();
   1:   ~nsFrameConstructorSaveState();
   1: 
   1: private:
   1:   nsAbsoluteItems* mItems;                // pointer to struct whose data we save/restore
   1:   PRBool*          mFirstLetterStyle;
   1:   PRBool*          mFirstLineStyle;
   1: 
   1:   nsAbsoluteItems  mSavedItems;           // copy of original data
   1:   PRBool           mSavedFirstLetterStyle;
   1:   PRBool           mSavedFirstLineStyle;
   1: 
   1:   // The name of the child list in which our frames would belong
   1:   nsIAtom* mChildListName;
   1:   nsFrameConstructorState* mState;
   1: 
   1:   friend class nsFrameConstructorState;
   1: };
   1: 
   1: // Structure used for maintaining state information during the
   1: // frame construction process
   1: class nsFrameConstructorState {
   1: public:
   1:   nsPresContext            *mPresContext;
   1:   nsIPresShell             *mPresShell;
   1:   nsFrameManager           *mFrameManager;
   1: 
   1: #ifdef MOZ_XUL
   1:   // The root box, if any.
   1:   nsIRootBox*               mRootBox;
   1:   // Frames destined for the nsGkAtoms::popupList.
   1:   nsAbsoluteItems           mPopupItems;
   1: #endif
   1: 
   1:   // Containing block information for out-of-flow frames.
   1:   nsAbsoluteItems           mFixedItems;
   1:   nsAbsoluteItems           mAbsoluteItems;
   1:   nsAbsoluteItems           mFloatedItems;
   1:   PRBool                    mFirstLetterStyle;
   1:   PRBool                    mFirstLineStyle;
   1:   nsCOMPtr<nsILayoutHistoryState> mFrameState;
   1:   nsPseudoFrames            mPseudoFrames;
   1: 
   1:   // Constructor
   1:   // Use the passed-in history state.
   1:   nsFrameConstructorState(nsIPresShell*          aPresShell,
   1:                           nsIFrame*              aFixedContainingBlock,
   1:                           nsIFrame*              aAbsoluteContainingBlock,
   1:                           nsIFrame*              aFloatContainingBlock,
   1:                           nsILayoutHistoryState* aHistoryState);
   1:   // Get the history state from the pres context's pres shell.
   1:   nsFrameConstructorState(nsIPresShell*          aPresShell,
   1:                           nsIFrame*              aFixedContainingBlock,
   1:                           nsIFrame*              aAbsoluteContainingBlock,
   1:                           nsIFrame*              aFloatContainingBlock);
   1: 
   1:   ~nsFrameConstructorState();
   1:   
   1:   // Function to push the existing absolute containing block state and
   1:   // create a new scope. Code that uses this function should get matching
   1:   // logic in GetAbsoluteContainingBlock.
   1:   void PushAbsoluteContainingBlock(nsIFrame* aNewAbsoluteContainingBlock,
   1:                                    nsFrameConstructorSaveState& aSaveState);
   1: 
   1:   // Function to push the existing float containing block state and
   1:   // create a new scope. Code that uses this function should get matching
   1:   // logic in GetFloatContainingBlock.
   1:   // Pushing a null float containing block forbids any frames from being
   1:   // floated until a new float containing block is pushed.
   1:   // XXX we should get rid of null float containing blocks and teach the
   1:   // various frame classes to deal with floats instead.
   1:   void PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
   1:                                 nsFrameConstructorSaveState& aSaveState,
   1:                                 PRBool aFirstLetterStyle,
   1:                                 PRBool aFirstLineStyle);
   1: 
   1:   // Function to return the proper geometric parent for a frame with display
   1:   // struct given by aStyleDisplay and parent's frame given by
   1:   // aContentParentFrame.  If the frame is not allowed to be positioned, pass
   1:   // false for aCanBePositioned.
   1:   nsIFrame* GetGeometricParent(const nsStyleDisplay* aStyleDisplay,
   1:                                nsIFrame* aContentParentFrame);
   1: 
   1:   /**
   1:    * Function to add a new frame to the right frame list.  This MUST be called
   1:    * on frames before their children have been processed if the frames might
   1:    * conceivably be out-of-flow; otherwise cleanup in error cases won't work
   1:    * right.  Also, this MUST be called on frames after they have been
   1:    * initialized.
   1:    * @param aNewFrame the frame to add
   1:    * @param aFrameItems the list to add in-flow frames to
   1:    * @param aStyleDisplay the display struct for aNewFrame
   1:    * @param aContent the content pointer for aNewFrame
   1:    * @param aStyleContext the style context of aNewFrame
   1:    * @param aParentFrame the parent frame for the content if it were in-flow
   1:    * @param aCanBePositioned pass false if the frame isn't allowed to be
   1:    *        positioned
   1:    * @param aCanBeFloated pass false if the frame isn't allowed to be
   1:    *        floated
   1:    * @param aIsOutOfFlowPopup pass true if the frame is an out-of-flow popup
   1:    *        (XUL-only)
   1:    * @throws NS_ERROR_OUT_OF_MEMORY if it happens.
   1:    * @note If this method throws, that means that aNewFrame was not inserted
   1:    *       into any frame lists.  Furthermore, this method will handle cleanup
   1:    *       of aNewFrame (via calling CleanupFrameReferences() and Destroy() on
   1:    *       it).
   1:    */
   1:   nsresult AddChild(nsIFrame* aNewFrame,
   1:                     nsFrameItems& aFrameItems,
   1:                     const nsStyleDisplay* aStyleDisplay,
   1:                     nsIContent* aContent,
   1:                     nsStyleContext* aStyleContext,
   1:                     nsIFrame* aParentFrame,
   1:                     PRBool aCanBePositioned = PR_TRUE,
   1:                     PRBool aCanBeFloated = PR_TRUE,
   1:                     PRBool aIsOutOfFlowPopup = PR_FALSE,
   1:                     PRBool aInsertAfter = PR_FALSE,
   1:                     nsIFrame* aInsertAfterFrame = nsnull);
   1: 
   1: protected:
   1:   friend class nsFrameConstructorSaveState;
   1: 
   1:   /**
   1:    * ProcessFrameInsertions takes the frames in aFrameItems and adds them as
   1:    * kids to the aChildListName child list of |aFrameItems.containingBlock|.
   1:    */
   1:   void ProcessFrameInsertions(nsAbsoluteItems& aFrameItems,
   1:                               nsIAtom* aChildListName);
   1: };
   1: 
   1: nsFrameConstructorState::nsFrameConstructorState(nsIPresShell*          aPresShell,
   1:                                                  nsIFrame*              aFixedContainingBlock,
   1:                                                  nsIFrame*              aAbsoluteContainingBlock,
   1:                                                  nsIFrame*              aFloatContainingBlock,
   1:                                                  nsILayoutHistoryState* aHistoryState)
   1:   : mPresContext(aPresShell->GetPresContext()),
   1:     mPresShell(aPresShell),
   1:     mFrameManager(aPresShell->FrameManager()),
   1: #ifdef MOZ_XUL    
   1:     mRootBox(nsIRootBox::GetRootBox(aPresShell)),
   1:     mPopupItems(mRootBox ? mRootBox->GetPopupSetFrame() : nsnull),
   1: #endif
   1:     mFixedItems(aFixedContainingBlock),
   1:     mAbsoluteItems(aAbsoluteContainingBlock),
   1:     mFloatedItems(aFloatContainingBlock),
   1:     mFirstLetterStyle(PR_FALSE),
   1:     mFirstLineStyle(PR_FALSE),
   1:     mFrameState(aHistoryState),
   1:     mPseudoFrames()
   1: {
5327:   MOZ_COUNT_CTOR(nsFrameConstructorState);
   1: }
   1: 
   1: nsFrameConstructorState::nsFrameConstructorState(nsIPresShell* aPresShell,
   1:                                                  nsIFrame*     aFixedContainingBlock,
   1:                                                  nsIFrame*     aAbsoluteContainingBlock,
   1:                                                  nsIFrame*     aFloatContainingBlock)
   1:   : mPresContext(aPresShell->GetPresContext()),
   1:     mPresShell(aPresShell),
   1:     mFrameManager(aPresShell->FrameManager()),
   1: #ifdef MOZ_XUL    
   1:     mRootBox(nsIRootBox::GetRootBox(aPresShell)),
   1:     mPopupItems(mRootBox ? mRootBox->GetPopupSetFrame() : nsnull),
   1: #endif
   1:     mFixedItems(aFixedContainingBlock),
   1:     mAbsoluteItems(aAbsoluteContainingBlock),
   1:     mFloatedItems(aFloatContainingBlock),
   1:     mFirstLetterStyle(PR_FALSE),
   1:     mFirstLineStyle(PR_FALSE),
   1:     mPseudoFrames()
   1: {
5327:   MOZ_COUNT_CTOR(nsFrameConstructorState);
   1:   mFrameState = aPresShell->GetDocument()->GetLayoutHistoryState();
   1: }
   1: 
   1: nsFrameConstructorState::~nsFrameConstructorState()
   1: {
   1:   // Frame order comparison functions only work properly when the placeholders
   1:   // have been inserted into the frame tree. So for example if we have a new float
   1:   // containing the placeholder for a new abs-pos frame, and we process the abs-pos
   1:   // insertion first, then we won't be able to find the right place to insert in
   1:   // in the abs-pos list. So put floats in first, because they can contain placeholders
   1:   // for abs-pos and fixed-pos items whose containing blocks are outside the floats.
   1:   // Then put abs-pos frames in, because they can contain placeholders for fixed-pos
   1:   // items whose containing block is outside the abs-pos frames. 
5327:   MOZ_COUNT_DTOR(nsFrameConstructorState);
   1:   ProcessFrameInsertions(mFloatedItems, nsGkAtoms::floatList);
   1:   ProcessFrameInsertions(mAbsoluteItems, nsGkAtoms::absoluteList);
   1:   ProcessFrameInsertions(mFixedItems, nsGkAtoms::fixedList);
   1: #ifdef MOZ_XUL
   1:   ProcessFrameInsertions(mPopupItems, nsGkAtoms::popupList);
   1: #endif
   1: }
   1: 
   1: static nsIFrame*
   1: AdjustAbsoluteContainingBlock(nsPresContext* aPresContext,
   1:                               nsIFrame*       aContainingBlockIn)
   1: {
   1:   if (!aContainingBlockIn) {
   1:     return nsnull;
   1:   }
   1:   
   1:   // Always use the container's first in flow.
   1:   return aContainingBlockIn->GetFirstInFlow();
   1: }
   1: 
   1: void
   1: nsFrameConstructorState::PushAbsoluteContainingBlock(nsIFrame* aNewAbsoluteContainingBlock,
   1:                                                      nsFrameConstructorSaveState& aSaveState)
   1: {
   1:   aSaveState.mItems = &mAbsoluteItems;
   1:   aSaveState.mSavedItems = mAbsoluteItems;
   1:   aSaveState.mChildListName = nsGkAtoms::absoluteList;
   1:   aSaveState.mState = this;
   1:   mAbsoluteItems = 
   1:     nsAbsoluteItems(AdjustAbsoluteContainingBlock(mPresContext,
   1:                                                   aNewAbsoluteContainingBlock));
   1: }
   1: 
   1: void
   1: nsFrameConstructorState::PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
   1:                                                   nsFrameConstructorSaveState& aSaveState,
   1:                                                   PRBool aFirstLetterStyle,
   1:                                                   PRBool aFirstLineStyle)
   1: {
   1:   // XXXbz we should probably just be able to assert that
   1:   // aNewFloatContainingBlock is a float containing block... see XXX comment at
   1:   // the top of ProcessChildren.
   1:   NS_PRECONDITION(!aNewFloatContainingBlock ||
   1:                   aNewFloatContainingBlock->GetContentInsertionFrame()->
   1:                     IsFloatContainingBlock(),
   1:                   "Please push a real float containing block!");
   1:   aSaveState.mItems = &mFloatedItems;
   1:   aSaveState.mFirstLetterStyle = &mFirstLetterStyle;
   1:   aSaveState.mFirstLineStyle = &mFirstLineStyle;
   1:   aSaveState.mSavedItems = mFloatedItems;
   1:   aSaveState.mSavedFirstLetterStyle = mFirstLetterStyle;
   1:   aSaveState.mSavedFirstLineStyle = mFirstLineStyle;
   1:   aSaveState.mChildListName = nsGkAtoms::floatList;
   1:   aSaveState.mState = this;
   1:   mFloatedItems = nsAbsoluteItems(aNewFloatContainingBlock);
   1:   mFirstLetterStyle = aFirstLetterStyle;
   1:   mFirstLineStyle = aFirstLineStyle;
   1: }
   1: 
   1: nsIFrame*
   1: nsFrameConstructorState::GetGeometricParent(const nsStyleDisplay* aStyleDisplay,
   1:                                             nsIFrame* aContentParentFrame)
   1: {
   1:   NS_PRECONDITION(aStyleDisplay, "Must have display struct!");
   1: 
   1:   // If there is no container for a fixed, absolute, or floating root
   1:   // frame, we will ignore the positioning.  This hack is originally
   1:   // brought to you by the letter T: tables, since other roots don't
   1:   // even call into this code.  See bug 178855.
   1:   //
   1:   // XXX Disabling positioning in this case is a hack.  If one was so inclined,
   1:   // one could support this either by (1) inserting a dummy block between the
   1:   // table and the canvas or (2) teaching the canvas how to reflow positioned
   1:   // elements. (1) has the usual problems when multiple frames share the same
   1:   // content (notice all the special cases in this file dealing with inner
   1:   // tables and outer tables which share the same content). (2) requires some
   1:   // work and possible factoring.
   1:   //
   1:   // XXXbz couldn't we just force position to "static" on roots and
   1:   // float to "none"?  That's OK per CSS 2.1, as far as I can tell.
   1:   
   1:   if (aStyleDisplay->IsFloating() && mFloatedItems.containingBlock) {
   1:     NS_ASSERTION(!aStyleDisplay->IsAbsolutelyPositioned(),
   1:                  "Absolutely positioned _and_ floating?");
   1:     return mFloatedItems.containingBlock;
   1:   }
   1: 
   1:   if (aStyleDisplay->mPosition == NS_STYLE_POSITION_ABSOLUTE &&
   1:       mAbsoluteItems.containingBlock) {
   1:     return mAbsoluteItems.containingBlock;
   1:   }
   1: 
   1:   if (aStyleDisplay->mPosition == NS_STYLE_POSITION_FIXED &&
   1:       mFixedItems.containingBlock) {
   1:     return mFixedItems.containingBlock;
   1:   }
   1: 
   1:   return aContentParentFrame;
   1: }
   1: 
   1: nsresult
   1: nsFrameConstructorState::AddChild(nsIFrame* aNewFrame,
   1:                                   nsFrameItems& aFrameItems,
   1:                                   const nsStyleDisplay* aStyleDisplay,
   1:                                   nsIContent* aContent,
   1:                                   nsStyleContext* aStyleContext,
   1:                                   nsIFrame* aParentFrame,
   1:                                   PRBool aCanBePositioned,
   1:                                   PRBool aCanBeFloated,
   1:                                   PRBool aIsOutOfFlowPopup,
   1:                                   PRBool aInsertAfter,
   1:                                   nsIFrame* aInsertAfterFrame)
   1: {
   1:   // The comments in GetGeometricParent regarding root table frames
   1:   // all apply here, unfortunately.
   1: 
   1:   PRBool needPlaceholder = PR_FALSE;
   1:   nsFrameItems* frameItems = &aFrameItems;
   1: #ifdef MOZ_XUL
   1:   if (NS_UNLIKELY(aIsOutOfFlowPopup)) {
   1:       NS_ASSERTION(aNewFrame->GetParent() == mPopupItems.containingBlock,
   1:                    "Popup whose parent is not the popup containing block?");
   1:       NS_ASSERTION(mPopupItems.containingBlock, "Must have a popup set frame!");
   1:       needPlaceholder = PR_TRUE;
   1:       frameItems = &mPopupItems;
   1:   }
   1:   else
   1: #endif // MOZ_XUL
   1:   if (aCanBeFloated && aStyleDisplay->IsFloating() &&
   1:       mFloatedItems.containingBlock) {
   1:     NS_ASSERTION(aNewFrame->GetParent() == mFloatedItems.containingBlock,
   1:                  "Float whose parent is not the float containing block?");
   1:     needPlaceholder = PR_TRUE;
   1:     frameItems = &mFloatedItems;
   1:   }
   1:   else if (aCanBePositioned) {
   1:     if (aStyleDisplay->mPosition == NS_STYLE_POSITION_ABSOLUTE &&
   1:         mAbsoluteItems.containingBlock) {
   1:       NS_ASSERTION(aNewFrame->GetParent() == mAbsoluteItems.containingBlock,
   1:                    "Abs pos whose parent is not the abs pos containing block?");
   1:       needPlaceholder = PR_TRUE;
   1:       frameItems = &mAbsoluteItems;
   1:     }
   1:     if (aStyleDisplay->mPosition == NS_STYLE_POSITION_FIXED &&
   1:         mFixedItems.containingBlock) {
   1:       NS_ASSERTION(aNewFrame->GetParent() == mFixedItems.containingBlock,
   1:                    "Fixed pos whose parent is not the fixed pos containing block?");
   1:       needPlaceholder = PR_TRUE;
   1:       frameItems = &mFixedItems;
   1:     }
   1:   }
   1: 
   1:   if (needPlaceholder) {
   1:     NS_ASSERTION(frameItems != &aFrameItems,
   1:                  "Putting frame in-flow _and_ want a placeholder?");
   1:     nsIFrame* placeholderFrame;
   1:     nsresult rv =
   1:       nsCSSFrameConstructor::CreatePlaceholderFrameFor(mPresShell,
   1:                                                        mPresContext,
   1:                                                        mFrameManager,
   1:                                                        aContent,
   1:                                                        aNewFrame,
   1:                                                        aStyleContext,
   1:                                                        aParentFrame,
   1:                                                        &placeholderFrame);
   1:     if (NS_FAILED(rv)) {
   1:       // Note that aNewFrame could be the top frame for a scrollframe setup,
   1:       // hence already set as the primary frame.  So we have to clean up here.
   1:       // But it shouldn't have any out-of-flow kids.
   1:       // XXXbz Maybe add a utility function to assert that?
   1:       CleanupFrameReferences(mFrameManager, aNewFrame);
   1:       aNewFrame->Destroy();
   1:       return rv;
   1:     }
   1: 
   1:     // Add the placeholder frame to the flow
   1:     aFrameItems.AddChild(placeholderFrame);
   1:   }
   1: #ifdef DEBUG
   1:   else {
   1:     NS_ASSERTION(aNewFrame->GetParent() == aParentFrame,
   1:                  "In-flow frame has wrong parent");
   1:   }
   1: #endif
   1: 
   1:   if (aInsertAfter) {
   1:     frameItems->InsertChildAfter(aNewFrame, aInsertAfterFrame);
   1:   } else {
   1:     frameItems->AddChild(aNewFrame);
   1:   }
   1: 
   1:   // Now add the special siblings too.
   1:   nsIFrame* specialSibling = aNewFrame;
   1:   while (specialSibling && IsFrameSpecial(specialSibling)) {
4696:     specialSibling = GetSpecialSibling(specialSibling);
   1:     if (specialSibling) {
   1:       NS_ASSERTION(frameItems == &aFrameItems,
   1:                    "IB split ending up in an out-of-flow childlist?");
   1:       frameItems->AddChild(specialSibling);
   1:     }
   1:   }
   1:   
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsFrameConstructorState::ProcessFrameInsertions(nsAbsoluteItems& aFrameItems,
   1:                                                 nsIAtom* aChildListName)
   1: {
   1: #define NS_NONXUL_LIST_TEST (&aFrameItems == &mFloatedItems &&             \
   1:                              aChildListName == nsGkAtoms::floatList)    || \
   1:                             (&aFrameItems == &mAbsoluteItems &&            \
   1:                              aChildListName == nsGkAtoms::absoluteList) || \
   1:                             (&aFrameItems == &mFixedItems &&               \
   1:                              aChildListName == nsGkAtoms::fixedList)
   1: #ifdef MOZ_XUL
   1:   NS_PRECONDITION(NS_NONXUL_LIST_TEST ||
   1:                   (&aFrameItems == &mPopupItems &&
   1:                    aChildListName == nsGkAtoms::popupList), 
   1:                   "Unexpected aFrameItems/aChildListName combination");
   1: #else
   1:   NS_PRECONDITION(NS_NONXUL_LIST_TEST,
   1:                   "Unexpected aFrameItems/aChildListName combination");
   1: #endif
   1: 
   1:   nsIFrame* firstNewFrame = aFrameItems.childList;
   1:   
   1:   if (!firstNewFrame) {
   1:     return;
   1:   }
   1:   
   1:   nsIFrame* containingBlock = aFrameItems.containingBlock;
   1: 
   1:   NS_ASSERTION(containingBlock,
   1:                "Child list without containing block?");
   1:   
   1:   // Insert the frames hanging out in aItems.  We can use SetInitialChildList()
   1:   // if the containing block hasn't been reflown yet (so NS_FRAME_FIRST_REFLOW
   1:   // is set) and doesn't have any frames in the aChildListName child list yet.
   1:   nsIFrame* firstChild = containingBlock->GetFirstChild(aChildListName);
   1:   nsresult rv = NS_OK;
   1:   if (!firstChild && (containingBlock->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
   1:     rv = containingBlock->SetInitialChildList(aChildListName, firstNewFrame);
   1:   } else {
   1:     // Note that whether the frame construction context is doing an append or
   1:     // not is not helpful here, since it could be appending to some frame in
   1:     // the middle of the document, which means we're not necessarily
   1:     // appending to the children of the containing block.
   1:     //
   1:     // We need to make sure the 'append to the end of document' case is fast.
   1:     // So first test the last child of the containing block
   1:     nsIFrame* lastChild = nsLayoutUtils::GetLastSibling(firstChild);
   1: 
   1:     // CompareTreePosition uses placeholder hierarchy for out of flow frames,
   1:     // so this will make out-of-flows respect the ordering of placeholders,
   1:     // which is great because it takes care of anonymous content.
   1:     if (!lastChild ||
   1:         nsLayoutUtils::CompareTreePosition(lastChild, firstNewFrame, containingBlock) < 0) {
   1:       // no lastChild, or lastChild comes before the new children, so just append
   1:       rv = containingBlock->AppendFrames(aChildListName, firstNewFrame);
   1:     } else {
   1:       nsIFrame* insertionPoint = nsnull;
   1:       // try the other children
   1:       for (nsIFrame* f = firstChild; f != lastChild; f = f->GetNextSibling()) {
   1:         PRInt32 compare =
   1:           nsLayoutUtils::CompareTreePosition(f, firstNewFrame, containingBlock);
   1:         if (compare > 0) {
   1:           // f comes after the new children, so stop here and insert after
   1:           // the previous frame
   1:           break;
   1:         }
   1:         insertionPoint = f;
   1:       }
   1: 
   1:       rv = containingBlock->InsertFrames(aChildListName, insertionPoint,
   1:                                          firstNewFrame);
   1:     }
   1:   }
   1:   aFrameItems.childList = nsnull;
   1:   // XXXbz And if NS_FAILED(rv), what?  I guess we need to clean up the list
   1:   // and deal with all the placeholders... but what if the placeholders aren't
   1:   // in the document yet?  Could that happen?
   1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Frames getting lost!");
   1: }
   1: 
   1: 
   1: nsFrameConstructorSaveState::nsFrameConstructorSaveState()
   1:   : mItems(nsnull),
   1:     mFirstLetterStyle(nsnull),
   1:     mFirstLineStyle(nsnull),
   1:     mSavedItems(nsnull),
   1:     mSavedFirstLetterStyle(PR_FALSE),
   1:     mSavedFirstLineStyle(PR_FALSE),
   1:     mChildListName(nsnull),
   1:     mState(nsnull)
   1: {
   1: }
   1: 
   1: nsFrameConstructorSaveState::~nsFrameConstructorSaveState()
   1: {
   1:   // Restore the state
   1:   if (mItems) {
   1:     NS_ASSERTION(mState, "Can't have mItems set without having a state!");
   1:     mState->ProcessFrameInsertions(*mItems, mChildListName);
   1:     *mItems = mSavedItems;
   1: #ifdef DEBUG
   1:     // We've transferred the child list, so drop the pointer we held to it.
   1:     // Note that this only matters for the assert in ~nsAbsoluteItems.
   1:     mSavedItems.childList = nsnull;
   1: #endif
   1:   }
   1:   if (mFirstLetterStyle) {
   1:     *mFirstLetterStyle = mSavedFirstLetterStyle;
   1:   }
   1:   if (mFirstLineStyle) {
   1:     *mFirstLineStyle = mSavedFirstLineStyle;
   1:   }
   1: }
   1: 
   1: static 
   1: PRBool IsBorderCollapse(nsIFrame* aFrame)
   1: {
   1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent()) {
   1:     if (nsGkAtoms::tableFrame == frame->GetType()) {
   1:       return ((nsTableFrame*)frame)->IsBorderCollapse();
   1:     }
   1:   }
   1:   NS_ASSERTION(PR_FALSE, "program error");
   1:   return PR_FALSE;
   1: }
   1: 
   1: /**
   1:  * Utility method, called from MoveChildrenTo(), that recursively
   1:  * descends down the frame hierarchy looking for floating frames that
   1:  * need parent pointer adjustments to account for the containment block
   1:  * changes that could occur as the result of the reparenting done in
   1:  * MoveChildrenTo().
   1:  */
   1: static void
   1: AdjustFloatParentPtrs(nsIFrame*                aFrame,
   1:                       nsFrameConstructorState& aState,
   1:                       nsFrameConstructorState& aOuterState)
   1: {
   1:   NS_PRECONDITION(aFrame, "must have frame to work with");
   1: 
   1:   nsIFrame *outOfFlowFrame = nsPlaceholderFrame::GetRealFrameFor(aFrame);
   1:   if (outOfFlowFrame != aFrame) {
   1:     if (outOfFlowFrame->GetStyleDisplay()->IsFloating()) {
   1:       // Update the parent pointer for outOfFlowFrame since its
   1:       // containing block has changed as the result of reparenting
   1:       // and move it from the outer state to the inner, bug 307277.
   1:       
   1:       nsIFrame *parent = aState.mFloatedItems.containingBlock;
   1:       NS_ASSERTION(parent, "Should have float containing block here!");
   1:       NS_ASSERTION(outOfFlowFrame->GetParent() == aOuterState.mFloatedItems.containingBlock,
   1:                    "expected the float to be a child of the outer CB");
   1: 
4368:       if (aOuterState.mFloatedItems.RemoveChild(outOfFlowFrame, nsnull)) {
   1:         aState.mFloatedItems.AddChild(outOfFlowFrame);
   1:       } else {
   1:         NS_NOTREACHED("float wasn't in the outer state float list");
   1:       }
   1: 
   1:       outOfFlowFrame->SetParent(parent);
   1:       if (outOfFlowFrame->GetStateBits() &
   1:           (NS_FRAME_HAS_VIEW | NS_FRAME_HAS_CHILD_WITH_VIEW)) {
   1:         // We don't need to walk up the tree, since we're doing this
   1:         // recursively.
   1:         parent->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
   1:       }
   1:     }
   1: 
   1:     // All out-of-flows are automatically float containing blocks, so we're
   1:     // done here.
   1:     return;
   1:   }
   1: 
   1:   if (aFrame->IsFloatContainingBlock()) {
   1:     // No need to recurse further; floats whose placeholders are
   1:     // inside a block already have the right parent.
   1:     return;
   1:   }
   1: 
   1:   // Dive down into children to see if any of their
   1:   // placeholders need adjusting.
   1:   nsIFrame *childFrame = aFrame->GetFirstChild(nsnull);
   1:   while (childFrame) {
   1:     // XXX_kin: Do we need to prevent descent into anonymous content here?
   1: 
   1:     AdjustFloatParentPtrs(childFrame, aState, aOuterState);
   1:     childFrame = childFrame->GetNextSibling();
   1:   }
   1: }
   1: 
   1: /**
4696:  * Moves frames to a new parent, updating the style context and propagating
4696:  * relevant frame state bits. |aState| may be null, in which case the parent
   1:  * pointers of out-of-flow frames will remain untouched.
   1:  */
   1: static void
   1: MoveChildrenTo(nsFrameManager*          aFrameManager,
   1:                nsIFrame*                aNewParent,
   1:                nsIFrame*                aFrameList,
5585:                nsIFrame*                aFrameListEnd,
   1:                nsFrameConstructorState* aState,
   1:                nsFrameConstructorState* aOuterState)
   1: {
   1:   PRBool setHasChildWithView = PR_FALSE;
   1: 
5585:   while (aFrameList && aFrameList != aFrameListEnd) {
   1:     if (!setHasChildWithView
   1:         && (aFrameList->GetStateBits() & (NS_FRAME_HAS_VIEW | NS_FRAME_HAS_CHILD_WITH_VIEW))) {
   1:       setHasChildWithView = PR_TRUE;
   1:     }
   1: 
   1:     aFrameList->SetParent(aNewParent);
   1: 
   1:     // If aState is not null, the caller expects us to make adjustments so that
   1:     // floats whose placeholders are descendants of frames in aFrameList point
   1:     // to the correct parent.
   1:     if (aState) {
   1:       NS_ASSERTION(aOuterState, "need an outer state too");
   1:       AdjustFloatParentPtrs(aFrameList, *aState, *aOuterState);
   1:     }
   1: 
   1:     aFrameList = aFrameList->GetNextSibling();
   1:   }
   1: 
   1:   if (setHasChildWithView) {
4696:     do {
   1:       aNewParent->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
4696:       aNewParent = aNewParent->GetParent();
4696:     } while (aNewParent &&
4696:              !(aNewParent->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW));
   1:   }
   1: }
   1: 
   1: // -----------------------------------------------------------
   1: 
   1: 
   1: // Structure used to ensure that bindings are properly enqueued in the
   1: // binding manager's attached queue.
   1: struct nsAutoEnqueueBinding
   1: {
   1:   nsAutoEnqueueBinding(nsIDocument* aDocument) :
   1:     mDocument(aDocument)
   1:   {}
   1: 
   1:   ~nsAutoEnqueueBinding();
   1: 
   1:   nsRefPtr<nsXBLBinding> mBinding;
   1: private:
   1:   nsIDocument* mDocument;
   1: };
   1: 
   1: nsAutoEnqueueBinding::~nsAutoEnqueueBinding()
   1: {
   1:   if (mBinding) {
   1:     mDocument->BindingManager()->AddToAttachedQueue(mBinding);
   1:   }
   1: }
   1: 
   1: 
   1: // Helper function that determines the child list name that aChildFrame
   1: // is contained in
   1: static nsIAtom*
   1: GetChildListNameFor(nsIFrame*       aChildFrame)
   1: {
   1:   nsIAtom*      listName;
   1:   
   1:   // See if the frame is moved out of the flow
   1:   if (aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
   1:     // Look at the style information to tell
   1:     const nsStyleDisplay* disp = aChildFrame->GetStyleDisplay();
   1:     
   1:     if (NS_STYLE_POSITION_ABSOLUTE == disp->mPosition) {
   1:       listName = nsGkAtoms::absoluteList;
   1:     } else if (NS_STYLE_POSITION_FIXED == disp->mPosition) {
   1:       listName = nsGkAtoms::fixedList;
   1: #ifdef MOZ_XUL
   1:     } else if (NS_STYLE_DISPLAY_POPUP == disp->mDisplay) {
   1:       // Out-of-flows that are DISPLAY_POPUP must be kids of the root popup set
   1: #ifdef DEBUG
   1:       nsIFrame* parent = aChildFrame->GetParent();
3129:       NS_ASSERTION(parent && parent->GetType() == nsGkAtoms::popupSetFrame,
3129:                    "Unexpected parent");
   1: #endif // DEBUG
   1: 
   1:       // XXX FIXME: Bug 350740
   1:       // Return here, because the postcondition for this function actually
   1:       // fails for this case, since the popups are not in a "real" frame list
   1:       // in the popup set.
   1:       return nsGkAtoms::popupList;      
   1: #endif // MOZ_XUL
   1:     } else {
   1:       NS_ASSERTION(aChildFrame->GetStyleDisplay()->IsFloating(),
   1:                    "not a floated frame");
   1:       listName = nsGkAtoms::floatList;
   1:     }
   1: 
   1:   } else {
   1:     listName = nsnull;
   1:   }
   1: 
   1: #ifdef NS_DEBUG
   1:   // Verify that the frame is actually in that child list or in the
   1:   // corresponding overflow list.
   1:   nsIFrame* parent = aChildFrame->GetParent();
   1:   PRBool found = nsFrameList(parent->GetFirstChild(listName))
   1:                    .ContainsFrame(aChildFrame);
   1:   if (!found) {
   1:     if (!(aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
   1:       found = nsFrameList(parent->GetFirstChild(nsGkAtoms::overflowList))
   1:                 .ContainsFrame(aChildFrame);
   1:     }
   1:     else if (aChildFrame->GetStyleDisplay()->IsFloating()) {
   1:       found = nsFrameList(parent->GetFirstChild(nsGkAtoms::overflowOutOfFlowList))
   1:                 .ContainsFrame(aChildFrame);
   1:     }
   1:     // else it's positioned and should have been on the 'listName' child list.
   1:     NS_POSTCONDITION(found, "not in child list");
   1:   }
   1: #endif
   1: 
   1:   return listName;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: nsCSSFrameConstructor::nsCSSFrameConstructor(nsIDocument *aDocument,
   1:                                              nsIPresShell *aPresShell)
   1:   : mDocument(aDocument)
   1:   , mPresShell(aPresShell)
   1:   , mInitialContainingBlock(nsnull)
   1:   , mFixedContainingBlock(nsnull)
   1:   , mDocElementContainingBlock(nsnull)
   1:   , mGfxScrollFrame(nsnull)
   1:   , mPageSequenceFrame(nsnull)
   1:   , mUpdateCount(0)
   1:   , mQuotesDirty(PR_FALSE)
   1:   , mCountersDirty(PR_FALSE)
   1:   , mInitialContainingBlockIsAbsPosContainer(PR_FALSE)
   1:   , mIsDestroyingFrameTree(PR_FALSE)
   1: {
   1:   if (!gGotXBLFormPrefs) {
   1:     gGotXBLFormPrefs = PR_TRUE;
   1: 
   1:     gUseXBLForms =
   1:       nsContentUtils::GetBoolPref("nglayout.debug.enable_xbl_forms");
   1:   }
   1: 
   1:   // XXXbz this should be in Init() or something!
   1:   if (!mPendingRestyles.Init()) {
   1:     // now what?
   1:   }
   1: 
   1: #ifdef DEBUG
   1:   static PRBool gFirstTime = PR_TRUE;
   1:   if (gFirstTime) {
   1:     gFirstTime = PR_FALSE;
   1:     char* flags = PR_GetEnv("GECKO_FRAMECTOR_DEBUG_FLAGS");
   1:     if (flags) {
   1:       PRBool error = PR_FALSE;
   1:       for (;;) {
   1:         char* comma = PL_strchr(flags, ',');
   1:         if (comma)
   1:           *comma = '\0';
   1: 
   1:         PRBool found = PR_FALSE;
   1:         FrameCtorDebugFlags* flag = gFlags;
   1:         FrameCtorDebugFlags* limit = gFlags + NUM_DEBUG_FLAGS;
   1:         while (flag < limit) {
   1:           if (PL_strcasecmp(flag->name, flags) == 0) {
   1:             *(flag->on) = PR_TRUE;
   1:             printf("nsCSSFrameConstructor: setting %s debug flag on\n", flag->name);
   1:             found = PR_TRUE;
   1:             break;
   1:           }
   1:           ++flag;
   1:         }
   1: 
   1:         if (! found)
   1:           error = PR_TRUE;
   1: 
   1:         if (! comma)
   1:           break;
   1: 
   1:         *comma = ',';
   1:         flags = comma + 1;
   1:       }
   1: 
   1:       if (error) {
   1:         printf("Here are the available GECKO_FRAMECTOR_DEBUG_FLAGS:\n");
   1:         FrameCtorDebugFlags* flag = gFlags;
   1:         FrameCtorDebugFlags* limit = gFlags + NUM_DEBUG_FLAGS;
   1:         while (flag < limit) {
   1:           printf("  %s\n", flag->name);
   1:           ++flag;
   1:         }
   1:         printf("Note: GECKO_FRAMECTOR_DEBUG_FLAGS is a comma separated list of flag\n");
   1:         printf("names (no whitespace)\n");
   1:       }
   1:     }
   1:   }
   1: #endif
   1: }
   1: 
   1: nsIXBLService * nsCSSFrameConstructor::GetXBLService()
   1: {
   1:   if (!gXBLService) {
   1:     nsresult rv = CallGetService("@mozilla.org/xbl;1", &gXBLService);
   1:     if (NS_FAILED(rv))
   1:       gXBLService = nsnull;
   1:   }
   1:   
   1:   return gXBLService;
   1: }
   1: 
   1: void
   1: nsCSSFrameConstructor::NotifyDestroyingFrame(nsIFrame* aFrame)
   1: {
   1:   if (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) {
   1:     if (mQuoteList.DestroyNodesFor(aFrame))
   1:       QuotesDirty();
   1:   }
   1: 
   1:   if (mCounterManager.DestroyNodesFor(aFrame)) {
   1:     // Technically we don't need to update anything if we destroyed only
   1:     // USE nodes.  However, this is unlikely to happen in the real world
   1:     // since USE nodes generally go along with INCREMENT nodes.
   1:     CountersDirty();
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreateAttributeContent(nsIContent* aParentContent,
   1:                                               nsIFrame* aParentFrame,
   1:                                               PRInt32 aAttrNamespace,
   1:                                               nsIAtom* aAttrName,
   1:                                               nsStyleContext* aStyleContext,
3793:                                               nsCOMArray<nsIContent>& aGeneratedContent,
   1:                                               nsIContent** aNewContent,
   1:                                               nsIFrame** aNewFrame)
   1: {
   1:   *aNewFrame = nsnull;
   1:   *aNewContent = nsnull;
   1:   nsCOMPtr<nsIContent> content;
   1:   nsresult rv = NS_NewAttributeContent(mDocument->NodeInfoManager(),
   1:                                        aAttrNamespace, aAttrName,
   1:                                        getter_AddRefs(content));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
1111:   content->SetNativeAnonymous(PR_TRUE);
1111: 
   1:   // Set aContent as the parent content so that event handling works.
   1:   rv = content->BindToTree(mDocument, aParentContent, content, PR_TRUE);
   1:   if (NS_FAILED(rv)) {
   1:     content->UnbindFromTree();
   1:     return rv;
   1:   }
   1: 
   1:   // Create a text frame and initialize it
   1:   nsIFrame* textFrame = NS_NewTextFrame(mPresShell, aStyleContext);
   1:   rv = textFrame->Init(content, aParentFrame, nsnull);
3793:   if (NS_SUCCEEDED(rv)) {
3793:     if (NS_UNLIKELY(!aGeneratedContent.AppendObject(content))) {
3793:       rv = NS_ERROR_OUT_OF_MEMORY;
3793:     }
3793:   }
3793: 
   1:   if (NS_FAILED(rv)) {
   1:     content->UnbindFromTree();
   1:     textFrame->Destroy();
   1:     textFrame = nsnull;
   1:     content = nsnull;
   1:   }
   1: 
   1:   *aNewFrame = textFrame;
   1:   content.swap(*aNewContent);
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreateGeneratedFrameFor(nsIFrame*             aParentFrame,
   1:                                                nsIContent*           aContent,
   1:                                                nsStyleContext*       aStyleContext,
   1:                                                const nsStyleContent* aStyleContent,
   1:                                                PRUint32              aContentIndex,
3793:                                                nsCOMArray<nsIContent>& aGeneratedContent,
   1:                                                nsIFrame**            aFrame)
   1: {
   1:   *aFrame = nsnull;  // initialize OUT parameter
   1: 
   1:   // The QuoteList needs the content attached to the frame.
   1:   nsCOMPtr<nsIDOMCharacterData>* textPtr = nsnull;
   1: 
   1:   // Get the content value
   1:   const nsStyleContentData &data = aStyleContent->ContentAt(aContentIndex);
   1:   nsStyleContentType  type = data.mType;
   1: 
   1:   nsCOMPtr<nsIContent> content;
   1: 
   1:   if (eStyleContentType_Image == type) {
   1:     if (!data.mContent.mImage) {
   1:       // CSS had something specified that couldn't be converted to an
   1:       // image object
   1:       return NS_ERROR_FAILURE;
   1:     }
   1:     
   1:     // Create an image content object and pass it the image request.
   1:     // XXX Check if it's an image type we can handle...
   1: 
   1:     nsCOMPtr<nsINodeInfo> nodeInfo;
   1:     mDocument->NodeInfoManager()->GetNodeInfo(nsGkAtoms::img, nsnull,
   1:                                               kNameSpaceID_None,
   1:                                               getter_AddRefs(nodeInfo));
   1: 
   1:     nsresult rv = NS_NewGenConImageContent(getter_AddRefs(content), nodeInfo,
   1:                                            data.mContent.mImage);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
1111:     content->SetNativeAnonymous(PR_TRUE);
1111:   
   1:     // Set aContent as the parent content and set the document object. This
   1:     // way event handling works
   1:     // Hack the binding parent to make document rules not match (not
   1:     // like it matters, since we already have a non-element style
   1:     // context... which is totally wacky, but anyway).
   1:     rv = content->BindToTree(mDocument, aContent, content, PR_TRUE);
   1:     if (NS_FAILED(rv)) {
   1:       content->UnbindFromTree();
   1:       return rv;
   1:     }
   1:     
   1:     // Create an image frame and initialize it
   1:     nsIFrame* imageFrame = NS_NewImageFrame(mPresShell, aStyleContext);
   1:     if (NS_UNLIKELY(!imageFrame)) {
3793:       content->UnbindFromTree();
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1: 
   1:     rv = imageFrame->Init(content, aParentFrame, nsnull);
3793:     if (NS_FAILED(rv) || NS_UNLIKELY(!aGeneratedContent.AppendObject(content))) {
3793:       content->UnbindFromTree();
   1:       imageFrame->Destroy();
3793:       return NS_FAILED(rv) ? rv : NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1: 
   1:     // Return the image frame
   1:     *aFrame = imageFrame;
   1: 
   1:   } else {
   1: 
   1:     nsAutoString contentString;
   1: 
   1:     switch (type) {
   1:     case eStyleContentType_String:
   1:       contentString = data.mContent.mString;
   1:       break;
   1:   
   1:     case eStyleContentType_Attr:
   1:       {
   1:         nsCOMPtr<nsIAtom> attrName;
   1:         PRInt32 attrNameSpace = kNameSpaceID_None;
   1:         contentString = data.mContent.mString;
   1:         PRInt32 barIndex = contentString.FindChar('|'); // CSS namespace delimiter
   1:         if (-1 != barIndex) {
   1:           nsAutoString  nameSpaceVal;
   1:           contentString.Left(nameSpaceVal, barIndex);
   1:           PRInt32 error;
   1:           attrNameSpace = nameSpaceVal.ToInteger(&error, 10);
   1:           contentString.Cut(0, barIndex + 1);
   1:           if (contentString.Length()) {
   1:             attrName = do_GetAtom(contentString);
   1:           }
   1:         }
   1:         else {
   1:           attrName = do_GetAtom(contentString);
   1:         }
   1: 
   1:         if (!attrName) {
   1:           return NS_ERROR_OUT_OF_MEMORY;
   1:         }
   1: 
   1:         nsresult rv =
   1:           CreateAttributeContent(aContent, aParentFrame, attrNameSpace,
3793:                                  attrName, aStyleContext, aGeneratedContent,
   1:                                  getter_AddRefs(content), aFrame);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:       }
   1:       break;
   1:   
   1:     case eStyleContentType_Counter:
   1:     case eStyleContentType_Counters:
   1:       {
   1:         nsCSSValue::Array *counters = data.mContent.mCounters;
   1:         nsCounterList *counterList = mCounterManager.CounterListFor(
   1:             nsDependentString(counters->Item(0).GetStringBufferValue()));
   1:         if (!counterList)
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:         nsCounterUseNode* node =
   1:           new nsCounterUseNode(counters, aParentFrame, aContentIndex,
   1:                                type == eStyleContentType_Counters);
   1:         if (!node)
   1:           return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:         counterList->Insert(node);
   1:         PRBool dirty = counterList->IsDirty();
   1:         if (!dirty) {
   1:           if (counterList->IsLast(node)) {
   1:             node->Calc(counterList);
   1:             node->GetText(contentString);
   1:           }
   1:           // In all other cases (list already dirty or node not at the end),
   1:           // just start with an empty string for now and when we recalculate
   1:           // the list we'll change the value to the right one.
   1:           else {
   1:             counterList->SetDirty();
   1:             CountersDirty();
   1:           }
   1:         }
   1: 
   1:         textPtr = &node->mText; // text node assigned below
   1:       }
   1:       break;
   1: 
   1:     case eStyleContentType_Image:
   1:       NS_NOTREACHED("handled by if above");
   1:       return NS_ERROR_UNEXPECTED;
   1:   
   1:     case eStyleContentType_OpenQuote:
   1:     case eStyleContentType_CloseQuote:
   1:     case eStyleContentType_NoOpenQuote:
   1:     case eStyleContentType_NoCloseQuote:
   1:       {
   1:         nsQuoteNode* node = new nsQuoteNode(type, aParentFrame, aContentIndex);
   1:         if (!node)
   1:           return NS_ERROR_OUT_OF_MEMORY;
   1:         mQuoteList.Insert(node);
   1:         if (mQuoteList.IsLast(node))
   1:           mQuoteList.Calc(node);
   1:         else
   1:           QuotesDirty();
   1: 
   1:         // Don't generate a text node or any text for 'no-open-quote' and
   1:         // 'no-close-quote'.
   1:         if (node->IsHiddenQuote())
   1:           return NS_OK;
   1: 
   1:         textPtr = &node->mText; // text node assigned below
   1:         contentString = *node->Text();
   1:       }
   1:       break;
   1:   
   1:     case eStyleContentType_AltContent:
   1:       {
   1:         // Use the "alt" attribute; if that fails and the node is an HTML
   1:         // <input>, try the value attribute and then fall back to some default
   1:         // localized text we have.
   1:         nsresult rv = NS_OK;
   1:         if (aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::alt)) {
   1:           rv = CreateAttributeContent(aContent, aParentFrame,
   1:                                       kNameSpaceID_None, nsGkAtoms::alt,
3793:                                       aStyleContext, aGeneratedContent,
3793:                                       getter_AddRefs(content), aFrame);
   1:         } else if (aContent->IsNodeOfType(nsINode::eHTML) &&
   1:                    aContent->NodeInfo()->Equals(nsGkAtoms::input)) {
   1:           if (aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
   1:             rv = CreateAttributeContent(aContent, aParentFrame,
   1:                                         kNameSpaceID_None, nsGkAtoms::value,
3793:                                         aStyleContext, aGeneratedContent,
3793:                                         getter_AddRefs(content), aFrame);
   1:           } else {
   1:             nsXPIDLString temp;
   1:             rv = nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
   1:                                                     "Submit", temp);
   1:             contentString = temp;
   1:           }
   1:         } else {
   1:           *aFrame = nsnull;
   1:           rv = NS_ERROR_NOT_AVAILABLE;
   1:           return rv; // Don't fall through to the warning below.
   1:         }
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:       }
   1:       break;
   1:     } // switch
   1:   
   1: 
   1:     if (!content) {
   1:       // Create a text content node
   1:       nsIFrame* textFrame = nsnull;
   1:       nsCOMPtr<nsIContent> textContent;
   1:       NS_NewTextNode(getter_AddRefs(textContent),
   1:                      mDocument->NodeInfoManager());
   1:       if (textContent) {
   1:         // Set the text
   1:         textContent->SetText(contentString, PR_TRUE);
   1: 
   1:         if (textPtr) {
   1:           *textPtr = do_QueryInterface(textContent);
   1:           NS_ASSERTION(*textPtr, "must implement nsIDOMCharacterData");
   1:         }
   1: 
1111:         textContent->SetNativeAnonymous(PR_TRUE);
1111: 
   1:         // Set aContent as the parent content so that event handling works.
   1:         nsresult rv = textContent->BindToTree(mDocument, aContent, textContent,
   1:                                               PR_TRUE);
   1:         if (NS_FAILED(rv)) {
   1:           textContent->UnbindFromTree();
   1:           return rv;
   1:         }
   1: 
   1:         // Create a text frame and initialize it
   1:         textFrame = NS_NewTextFrame(mPresShell, aStyleContext);
   1:         if (!textFrame) {
   1:           // XXX The quotes/counters code doesn't like the text pointer
   1:           // being null in case of dynamic changes!
   1:           NS_NOTREACHED("this OOM case isn't handled very well");
   1:           return NS_ERROR_OUT_OF_MEMORY;
   1:         }
   1: 
   1:         textFrame->Init(textContent, aParentFrame, nsnull);
   1: 
   1:         content = textContent;
3793:         if (NS_UNLIKELY(!aGeneratedContent.AppendObject(content))) {
3793:           NS_NOTREACHED("this OOM case isn't handled very well");
3793:           return NS_ERROR_OUT_OF_MEMORY;
3793:         }
   1:       } else {
   1:         // XXX The quotes/counters code doesn't like the text pointer
   1:         // being null in case of dynamic changes!
   1:         NS_NOTREACHED("this OOM case isn't handled very well");
   1:       }
   1: 
   1:       // Return the text frame
   1:       *aFrame = textFrame;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /*
   1:  *
   1:  * aFrame - the frame that should be the parent of the generated
   1:  *   content.  This is the frame for the corresponding content node,
   1:  *   which must not be a leaf frame.
   1:  */
   1: PRBool
   1: nsCSSFrameConstructor::CreateGeneratedContentFrame(nsFrameConstructorState& aState,
   1:                                                    nsIFrame*        aFrame,
   1:                                                    nsIContent*      aContent,
   1:                                                    nsStyleContext*  aStyleContext,
   1:                                                    nsIAtom*         aPseudoElement,
   1:                                                    nsIFrame**       aResult)
   1: {
   1:   *aResult = nsnull; // initialize OUT parameter
   1: 
   1:   if (!aContent->IsNodeOfType(nsINode::eELEMENT))
   1:     return PR_FALSE;
   1: 
   1:   nsStyleSet *styleSet = mPresShell->StyleSet();
   1: 
   1:   // Probe for the existence of the pseudo-element
   1:   nsRefPtr<nsStyleContext> pseudoStyleContext;
   1:   pseudoStyleContext = styleSet->ProbePseudoStyleFor(aContent,
   1:                                                      aPseudoElement,
   1:                                                      aStyleContext);
   1: 
   1:   if (pseudoStyleContext) {
   1:     // |ProbePseudoStyleContext| checks the 'display' property and the
   1:     // |ContentCount()| of the 'content' property for us.
   1: 
   1:     // Create a block box or an inline box depending on the value of
   1:     // the 'display' property
   1:     nsIFrame*     containerFrame;
   1:     nsFrameItems  childFrames;
3793:     nsresult rv;
   1: 
   1:     const PRUint8 disp = pseudoStyleContext->GetStyleDisplay()->mDisplay;
   1:     if (disp == NS_STYLE_DISPLAY_BLOCK ||
   1:         disp == NS_STYLE_DISPLAY_INLINE_BLOCK) {
   1:       PRUint32 flags = 0;
   1:       if (disp == NS_STYLE_DISPLAY_INLINE_BLOCK) {
   1:         flags = NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT;
   1:       }
   1:       containerFrame = NS_NewBlockFrame(mPresShell, pseudoStyleContext, flags);
   1:     } else {
   1:       containerFrame = NS_NewInlineFrame(mPresShell, pseudoStyleContext);
   1:     }
3793: 
3793:     if (NS_UNLIKELY(!containerFrame)) {
3793:       return PR_FALSE;
3793:     }
   1:     InitAndRestoreFrame(aState, aContent, aFrame, nsnull, containerFrame);
   1:     // XXXbz should we be passing in a non-null aContentParentFrame?
   1:     nsHTMLContainerFrame::CreateViewForFrame(containerFrame, nsnull, PR_FALSE);
   1: 
   1:     // Mark the frame as being associated with generated content
   1:     containerFrame->AddStateBits(NS_FRAME_GENERATED_CONTENT);
   1: 
3793:     // Create an array to hold all the generated content created for this
3793:     // frame below in CreateGeneratedFrameFor. No destructor function is
3793:     // specified because the property is only set here and is removed in
3793:     // a single place - nsContainerFrame::Destroy.
3793:     nsCOMArray<nsIContent>* generatedContent = new nsCOMArray<nsIContent>;
3793:     rv = containerFrame->SetProperty(nsGkAtoms::generatedContent,
3793:                                      generatedContent);
3793:     if (NS_UNLIKELY(!generatedContent) || NS_FAILED(rv)) {
3793:       containerFrame->Destroy(); // this also destroys the created view
3793:       delete generatedContent;
3793:       return PR_FALSE;
3793:     }
3793: 
   1:     // Create another pseudo style context to use for all the generated child
   1:     // frames
   1:     nsRefPtr<nsStyleContext> textStyleContext;
   1:     textStyleContext = styleSet->ResolveStyleForNonElement(pseudoStyleContext);
   1: 
   1:     // Now create content objects (and child frames) for each value of the
   1:     // 'content' property
   1: 
   1:     const nsStyleContent* styleContent = pseudoStyleContext->GetStyleContent();
   1:     PRUint32 contentCount = styleContent->ContentCount();
   1:     for (PRUint32 contentIndex = 0; contentIndex < contentCount; contentIndex++) {
   1:       nsIFrame* frame;
   1: 
   1:       // Create a frame
3793:       rv = CreateGeneratedFrameFor(containerFrame,
   1:                                    aContent, textStyleContext,
3793:                                    styleContent, contentIndex,
3793:                                    *generatedContent, &frame);
   1:       // Non-elements can't possibly have a view, so don't bother checking
3793:       if (NS_SUCCEEDED(rv) && frame) {
   1:         // Add it to the list of child frames
   1:         childFrames.AddChild(frame);
   1:       }
   1:     }
   1: 
   1:     if (childFrames.childList) {
   1:       containerFrame->SetInitialChildList(nsnull, childFrames.childList);
   1:     }
   1:     *aResult = containerFrame;
   1:     return PR_TRUE;
   1:   }
   1: 
   1:   return PR_FALSE;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreateInputFrame(nsFrameConstructorState& aState,
   1:                                         nsIContent*              aContent,
   1:                                         nsIFrame*                aParentFrame,
   1:                                         nsIAtom*                 aTag,
   1:                                         nsStyleContext*          aStyleContext,
   1:                                         nsIFrame**               aFrame,
   1:                                         const nsStyleDisplay*    aStyleDisplay,
   1:                                         PRBool&                  aFrameHasBeenInitialized,
   1:                                         PRBool&                  aAddedToFrameList,
4461:                                         nsFrameItems&            aFrameItems,
4461:                                         PRBool                   aHasPseudoParent)
   1: {
   1:   // Make sure to keep IsSpecialContent in synch with this code
   1:   
   1:   // Note: do not do anything in this method that assumes pseudo-frames have
   1:   // been processed.  If you feel the urge to do something like that, fix
   1:   // callers accordingly.
   1:   nsCOMPtr<nsIFormControl> control = do_QueryInterface(aContent);
   1:   NS_ASSERTION(control, "input is not an nsIFormControl!");
   1: 
   1:   switch (control->GetType()) {
   1:     case NS_FORM_INPUT_SUBMIT:
   1:     case NS_FORM_INPUT_RESET:
   1:     case NS_FORM_INPUT_BUTTON:
   1:     {
   1:       if (gUseXBLForms)
4461:         return NS_OK; // update IsSpecialContent if this becomes functional
   1: 
   1:       nsresult rv = ConstructButtonFrame(aState, aContent, aParentFrame,
   1:                                          aTag, aStyleContext, aFrame,
4461:                                          aStyleDisplay, aFrameItems,
4461:                                          aHasPseudoParent);
   1:       aAddedToFrameList = PR_TRUE;
   1:       aFrameHasBeenInitialized = PR_TRUE;
   1:       return rv;
   1:     }
   1: 
   1:     case NS_FORM_INPUT_CHECKBOX:
   1:       if (gUseXBLForms)
   1:         return NS_OK; // see comment above
   1:       return ConstructCheckboxControlFrame(aFrame, aContent, aStyleContext);
   1: 
   1:     case NS_FORM_INPUT_RADIO:
   1:       if (gUseXBLForms)
   1:         return NS_OK; // see comment above
   1:       return ConstructRadioControlFrame(aFrame, aContent, aStyleContext);
   1: 
   1:     case NS_FORM_INPUT_FILE:
   1:     {
   1:       *aFrame = NS_NewFileControlFrame(mPresShell, aStyleContext);
   1: 
   1:       if (*aFrame) {
   1:         // The (block-like) file control frame should have a space manager
   1:         (*aFrame)->AddStateBits(NS_BLOCK_SPACE_MGR);
   1:         return NS_OK;
   1:       }
   1:       else {
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:       }
   1:     }
   1: 
   1:     case NS_FORM_INPUT_HIDDEN:
   1:       return NS_OK; // this does not create a frame so it needs special handling
   1:                     // in IsSpecialContent
   1: 
   1:     case NS_FORM_INPUT_IMAGE:
   1:       return CreateHTMLImageFrame(aContent, aStyleContext,
   1:                                   NS_NewImageControlFrame, aFrame);
   1: 
   1:     case NS_FORM_INPUT_TEXT:
   1:     case NS_FORM_INPUT_PASSWORD:
   1:     {
   1:       *aFrame = NS_NewTextControlFrame(mPresShell, aStyleContext);
   1:       
   1:       return NS_UNLIKELY(!*aFrame) ? NS_ERROR_OUT_OF_MEMORY : NS_OK;
   1:     }
   1: 
   1:     default:
   1:       NS_ASSERTION(0, "Unknown input type!");
   1:       return NS_ERROR_INVALID_ARG;
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreateHTMLImageFrame(nsIContent* aContent,
   1:                                             nsStyleContext* aStyleContext,
   1:                                             ImageFrameCreatorFunc aFunc,
   1:                                             nsIFrame** aFrame)
   1: {
   1:   *aFrame = nsnull;
   1: 
   1:   // Make sure to keep IsSpecialContent in synch with this code
   1:   if (nsImageFrame::ShouldCreateImageFrameFor(aContent, aStyleContext)) {
   1:     *aFrame = (*aFunc)(mPresShell, aStyleContext);
   1:      
   1:     if (NS_UNLIKELY(!*aFrame))
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: static PRBool
   1: TextIsOnlyWhitespace(nsIContent* aContent)
   1: {
   1:   return aContent->IsNodeOfType(nsINode::eTEXT) &&
   1:          aContent->TextIsOnlyWhitespace();
   1: }
   1:     
   1: /****************************************************
   1:  **  BEGIN TABLE SECTION
   1:  ****************************************************/
   1: 
   1: // The term pseudo frame is being used instead of anonymous frame, since anonymous
   1: // frame has been used elsewhere to refer to frames that have generated content
   1: 
   1: // aIncludeSpecial applies to captions, col groups, cols and cells.
   1: // These do not generate pseudo frame wrappers for foreign children. 
   1: 
   1: static PRBool
   1: IsTableRelated(PRUint8 aDisplay,
   1:                PRBool  aIncludeSpecial) 
   1: {
   1:   if ((aDisplay == NS_STYLE_DISPLAY_TABLE)              ||
   1:       (aDisplay == NS_STYLE_DISPLAY_INLINE_TABLE)       ||
   1:       (aDisplay == NS_STYLE_DISPLAY_TABLE_HEADER_GROUP) ||
   1:       (aDisplay == NS_STYLE_DISPLAY_TABLE_ROW_GROUP)    ||
   1:       (aDisplay == NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP) ||
   1:       (aDisplay == NS_STYLE_DISPLAY_TABLE_ROW)) {
   1:     return PR_TRUE;
   1:   }
   1:   else if (aIncludeSpecial && 
   1:            ((aDisplay == NS_STYLE_DISPLAY_TABLE_CAPTION)      ||
   1:             (aDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP) ||
   1:             (aDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN)       ||
   1:             (aDisplay == NS_STYLE_DISPLAY_TABLE_CELL))) {
   1:     return PR_TRUE;
   1:   }
   1:   else return PR_FALSE;
   1: }
   1: 
   1: static PRBool
   1: IsTableRelated(nsIAtom* aParentType,
   1:                PRBool   aIncludeSpecial)
   1: {
   1:   if ((nsGkAtoms::tableFrame         == aParentType)  ||
   1:       (nsGkAtoms::tableRowGroupFrame == aParentType)  ||
   1:       (nsGkAtoms::tableRowFrame      == aParentType)) {
   1:     return PR_TRUE;
   1:   }
   1:   else if (aIncludeSpecial && 
   1:            ((nsGkAtoms::tableCaptionFrame  == aParentType)  ||
   1:             (nsGkAtoms::tableColGroupFrame == aParentType)  ||
   1:             (nsGkAtoms::tableColFrame      == aParentType)  ||
   1:             IS_TABLE_CELL(aParentType))) {
   1:     return PR_TRUE;
   1:   }
   1:   else return PR_FALSE;
   1: }
   1:            
   1: static nsIFrame*
   1: AdjustCaptionParentFrame(nsIFrame* aParentFrame) 
   1: {
   1:   if (nsGkAtoms::tableFrame == aParentFrame->GetType()) {
   1:     return aParentFrame->GetParent();;
   1:   }
   1:   return aParentFrame;
   1: }
   1:  
   1: /**
   1:  * If the parent frame is a |tableFrame| and the child is a
   1:  * |captionFrame|, then we want to insert the frames beneath the
   1:  * |tableFrame|'s parent frame. Returns |PR_TRUE| if the parent frame
   1:  * needed to be fixed up.
   1:  */
   1: static PRBool
   1: GetCaptionAdjustedParent(nsIFrame*        aParentFrame,
   1:                          const nsIFrame*  aChildFrame,
   1:                          nsIFrame**       aAdjParentFrame)
   1: {
   1:   *aAdjParentFrame = aParentFrame;
   1:   PRBool haveCaption = PR_FALSE;
   1: 
   1:   if (nsGkAtoms::tableCaptionFrame == aChildFrame->GetType()) {
   1:     haveCaption = PR_TRUE;
   1:     *aAdjParentFrame = AdjustCaptionParentFrame(aParentFrame);
   1:   }
   1:   return haveCaption;
   1: }
   1:    
   1: static nsresult 
   1: ProcessPseudoFrame(nsPseudoFrameData& aPseudoData,
   1:                    nsIFrame*&         aParent)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   aParent = aPseudoData.mFrame;
   1:   nsFrameItems* items = &aPseudoData.mChildList;
   1:   if (items && items->childList) {
   1:     rv = aParent->SetInitialChildList(nsnull, items->childList);
   1:     if (NS_FAILED(rv)) return rv;
   1:   }
   1:   aPseudoData.Reset();
   1:   return rv;
   1: }
   1: 
   1: static nsresult 
   1: ProcessPseudoRowGroupFrame(nsPseudoFrameData& aPseudoData,
   1:                            nsIFrame*&         aParent)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   aParent = aPseudoData.mFrame;
   1:   nsFrameItems* items = &aPseudoData.mChildList;
   1:   if (items && items->childList) {
   1:     nsTableRowGroupFrame* rgFrame = nsTableFrame::GetRowGroupFrame(aParent);
   1:     rv = rgFrame->SetInitialChildList(nsnull, items->childList);
   1:     if (NS_FAILED(rv)) return rv;
   1:   }
   1:   aPseudoData.Reset();
   1:   return rv;
   1: }
   1: 
   1: static nsresult 
   1: ProcessPseudoTableFrame(nsPseudoFrames& aPseudoFrames,
   1:                         nsIFrame*&      aParent)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   // process the col group frame, if it exists
   1:   if (aPseudoFrames.mColGroup.mFrame) {
   1:     rv = ProcessPseudoFrame(aPseudoFrames.mColGroup, aParent);
   1:   }
   1: 
   1:   // process the inner table frame
   1:   rv = ProcessPseudoFrame(aPseudoFrames.mTableInner, aParent);
   1: 
   1:   // process the outer table frame
   1:   aParent = aPseudoFrames.mTableOuter.mFrame;
   1:   nsFrameItems* items = &aPseudoFrames.mTableOuter.mChildList;
   1:   if (items && items->childList) {
   1:     rv = aParent->SetInitialChildList(nsnull, items->childList);
   1:     if (NS_FAILED(rv)) return rv;
   1:   }
   1:   nsFrameItems* captions = &aPseudoFrames.mTableOuter.mChildList2;
   1:   if (captions && captions->childList) {
   1:     rv = aParent->SetInitialChildList(nsGkAtoms::captionList, captions->childList);
   1:   }
   1:   aPseudoFrames.mTableOuter.Reset();
   1:   return rv;
   1: }
   1: 
   1: static nsresult 
   1: ProcessPseudoCellFrame(nsPseudoFrames& aPseudoFrames,
   1:                        nsIFrame*&      aParent)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   rv = ProcessPseudoFrame(aPseudoFrames.mCellInner, aParent);
   1:   if (NS_FAILED(rv)) return rv;
   1:   rv = ProcessPseudoFrame(aPseudoFrames.mCellOuter, aParent);
   1:   return rv;
   1: }
   1: 
   1: // limit the processing up to the frame type indicated by aHighestType.
   1: // make a complete processing when aHighestType is null
   1: static nsresult 
   1: ProcessPseudoFrames(nsFrameConstructorState& aState,
   1:                     nsIAtom*        aHighestType,
   1:                     nsIFrame*&      aHighestFrame)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   aHighestFrame = nsnull;
   1: 
   1: #ifdef DEBUG
   1:   if (gTablePseudoFrame) {
   1:     printf("*** ProcessPseudoFrames enter***\n");
   1:     aState.mPseudoFrames.Dump();
   1:   }
   1: #endif
   1: 
   1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
   1: 
   1:   if (nsGkAtoms::tableFrame == pseudoFrames.mLowestType) {
   1:     if (pseudoFrames.mColGroup.mFrame) {
   1:       rv = ProcessPseudoFrame(pseudoFrames.mColGroup, aHighestFrame);
   1:       if (nsGkAtoms::tableColGroupFrame == aHighestType) return rv;
   1:     }
   1:     rv = ProcessPseudoTableFrame(pseudoFrames, aHighestFrame);
   1:     if (nsGkAtoms::tableOuterFrame == aHighestType) return rv;
   1:     
   1:     if (pseudoFrames.mCellOuter.mFrame) {
   1:       rv = ProcessPseudoCellFrame(pseudoFrames, aHighestFrame);
   1:       if (IS_TABLE_CELL(aHighestType)) return rv;
   1:     }
   1:     if (pseudoFrames.mRow.mFrame) {
   1:       rv = ProcessPseudoFrame(pseudoFrames.mRow, aHighestFrame);
   1:       if (nsGkAtoms::tableRowFrame == aHighestType) return rv;
   1:     }
   1:     if (pseudoFrames.mRowGroup.mFrame) {
   1:       rv = ProcessPseudoRowGroupFrame(pseudoFrames.mRowGroup, aHighestFrame);
   1:       if (nsGkAtoms::tableRowGroupFrame == aHighestType) return rv;
   1:     }
   1:   }
   1:   else if (nsGkAtoms::tableRowGroupFrame == pseudoFrames.mLowestType) {
   1:     rv = ProcessPseudoRowGroupFrame(pseudoFrames.mRowGroup, aHighestFrame);
   1:     if (nsGkAtoms::tableRowGroupFrame == aHighestType) return rv;
   1:     if (pseudoFrames.mColGroup.mFrame) {
   1:       nsIFrame* colGroupHigh;
   1:       rv = ProcessPseudoFrame(pseudoFrames.mColGroup, colGroupHigh);
   1:       if (aHighestFrame &&
   1:           nsGkAtoms::tableRowGroupFrame == aHighestFrame->GetType() &&
   1:           !pseudoFrames.mTableInner.mFrame) {
   1:         // table frames are special they can have two types of pseudo frames as
   1:         // children that need to be processed in one pass, we only need to link
   1:         // them if the parent is not a pseudo where the link is already done
   1:         // We sort this later out inside nsTableFrame.
   1:         colGroupHigh->SetNextSibling(aHighestFrame); 
   1:       }
   1:       aHighestFrame = colGroupHigh;
   1:       if (nsGkAtoms::tableColGroupFrame == aHighestType) return rv;
   1:     }
   1:     if (pseudoFrames.mTableOuter.mFrame) {
   1:       rv = ProcessPseudoTableFrame(pseudoFrames, aHighestFrame);
   1:       if (nsGkAtoms::tableOuterFrame == aHighestType) return rv;
   1:     }
   1:     if (pseudoFrames.mCellOuter.mFrame) {
   1:       rv = ProcessPseudoCellFrame(pseudoFrames, aHighestFrame);
   1:       if (IS_TABLE_CELL(aHighestType)) return rv;
   1:     }
   1:     if (pseudoFrames.mRow.mFrame) {
   1:       rv = ProcessPseudoFrame(pseudoFrames.mRow, aHighestFrame);
   1:       if (nsGkAtoms::tableRowFrame == aHighestType) return rv;
   1:     }
   1:   }
   1:   else if (nsGkAtoms::tableRowFrame == pseudoFrames.mLowestType) {
   1:     rv = ProcessPseudoFrame(pseudoFrames.mRow, aHighestFrame);
   1:     if (nsGkAtoms::tableRowFrame == aHighestType) return rv;
   1: 
   1:     if (pseudoFrames.mRowGroup.mFrame) {
   1:       rv = ProcessPseudoRowGroupFrame(pseudoFrames.mRowGroup, aHighestFrame);
   1:       if (nsGkAtoms::tableRowGroupFrame == aHighestType) return rv;
   1:     }
   1:     if (pseudoFrames.mColGroup.mFrame) {
   1:       nsIFrame* colGroupHigh;
   1:       rv = ProcessPseudoFrame(pseudoFrames.mColGroup, colGroupHigh);
   1:       if (aHighestFrame &&
   1:           nsGkAtoms::tableRowGroupFrame == aHighestFrame->GetType() &&
   1:           !pseudoFrames.mTableInner.mFrame) {
   1:         // table frames are special they can have two types of pseudo frames as
   1:         // children that need to be processed in one pass, we only need to link
   1:         // them if the parent is not a pseudo where the link is already done
   1:         // We sort this later out inside nsTableFrame.
   1:         colGroupHigh->SetNextSibling(aHighestFrame); 
   1:       }
   1:       aHighestFrame = colGroupHigh;
   1:       if (nsGkAtoms::tableColGroupFrame == aHighestType) return rv;
   1:     }
   1:     if (pseudoFrames.mTableOuter.mFrame) {
   1:       rv = ProcessPseudoTableFrame(pseudoFrames, aHighestFrame);
   1:       if (nsGkAtoms::tableOuterFrame == aHighestType) return rv;
   1:     }
   1:     if (pseudoFrames.mCellOuter.mFrame) {
   1:       rv = ProcessPseudoCellFrame(pseudoFrames, aHighestFrame);
   1:       if (IS_TABLE_CELL(aHighestType)) return rv;
   1:     }
   1:   }
   1:   else if (IS_TABLE_CELL(pseudoFrames.mLowestType)) {
   1:     rv = ProcessPseudoCellFrame(pseudoFrames, aHighestFrame);
   1:     if (IS_TABLE_CELL(aHighestType)) return rv;
   1: 
   1:     if (pseudoFrames.mRow.mFrame) {
   1:       rv = ProcessPseudoFrame(pseudoFrames.mRow, aHighestFrame);
   1:       if (nsGkAtoms::tableRowFrame == aHighestType) return rv;
   1:     }
   1:     if (pseudoFrames.mRowGroup.mFrame) {
   1:       rv = ProcessPseudoRowGroupFrame(pseudoFrames.mRowGroup, aHighestFrame);
   1:       if (nsGkAtoms::tableRowGroupFrame == aHighestType) return rv;
   1:     }
   1:     if (pseudoFrames.mColGroup.mFrame) {
   1:       nsIFrame* colGroupHigh;
   1:       rv = ProcessPseudoFrame(pseudoFrames.mColGroup, colGroupHigh);
   1:       if (aHighestFrame &&
   1:           nsGkAtoms::tableRowGroupFrame == aHighestFrame->GetType() &&
   1:           !pseudoFrames.mTableInner.mFrame) {
   1:         // table frames are special they can have two types of pseudo frames as
   1:         // children that need to be processed in one pass, we only need to link
   1:         // them if the parent is not a pseudo where the link is already done
   1:         // We sort this later out inside nsTableFrame.
   1:         colGroupHigh->SetNextSibling(aHighestFrame); 
   1:       }
   1:       aHighestFrame = colGroupHigh;
   1:       if (nsGkAtoms::tableColGroupFrame == aHighestType) return rv;
   1:     }
   1:     if (pseudoFrames.mTableOuter.mFrame) {
   1:       rv = ProcessPseudoTableFrame(pseudoFrames, aHighestFrame);
   1:     }
   1:   }
   1:   else if (pseudoFrames.mColGroup.mFrame) { 
   1:     // process the col group frame
   1:     rv = ProcessPseudoFrame(pseudoFrames.mColGroup, aHighestFrame);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: static nsresult 
   1: ProcessPseudoFrames(nsFrameConstructorState& aState,
   1:                     nsFrameItems&   aItems)
   1: {
   1: 
   1: #ifdef DEBUG
   1:   if (gTablePseudoFrame) {
   1:     printf("*** ProcessPseudoFrames complete enter***\n");
   1:     aState.mPseudoFrames.Dump();
   1:   }
   1: #endif
   1:  
   1:   nsIFrame* highestFrame;
   1:   nsresult rv = ProcessPseudoFrames(aState, nsnull, highestFrame);
   1:   if (highestFrame) {
   1:     aItems.AddChild(highestFrame);
   1:   }
   1:  
   1: #ifdef DEBUG
   1:   if (gTablePseudoFrame) {
   1:     printf("*** ProcessPseudoFrames complete leave, highestframe:%p***\n",
3233:            static_cast<void*>(highestFrame));
   1:     aState.mPseudoFrames.Dump();
   1:   }
   1: #endif
   1:   aState.mPseudoFrames.Reset();
   1:   return rv;
   1: }
   1: 
   1: static nsresult 
   1: ProcessPseudoFrames(nsFrameConstructorState& aState,
   1:                     nsIAtom*        aHighestType)
   1: {
   1: #ifdef DEBUG
   1:   if (gTablePseudoFrame) {
   1:     printf("*** ProcessPseudoFrames limited enter highest:");
   1:     if (nsGkAtoms::tableOuterFrame == aHighestType) 
   1:       printf("OuterTable");
   1:     else if (nsGkAtoms::tableFrame == aHighestType) 
   1:       printf("InnerTable");
   1:     else if (nsGkAtoms::tableColGroupFrame == aHighestType) 
   1:       printf("ColGroup");
   1:     else if (nsGkAtoms::tableRowGroupFrame == aHighestType) 
   1:       printf("RowGroup");
   1:     else if (nsGkAtoms::tableRowFrame == aHighestType) 
   1:       printf("Row");
   1:     else if (IS_TABLE_CELL(aHighestType)) 
   1:       printf("Cell");
   1:     else 
   1:       NS_ASSERTION(PR_FALSE, "invalid call to ProcessPseudoFrames ");
   1:     printf("***\n");
   1:     aState.mPseudoFrames.Dump();
   1:   }
   1: #endif
   1:  
   1:   nsIFrame* highestFrame;
   1:   nsresult rv = ProcessPseudoFrames(aState, aHighestType, highestFrame);
   1: 
   1: #ifdef DEBUG
   1:   if (gTablePseudoFrame) {
   1:     printf("*** ProcessPseudoFrames limited leave:%p***\n",
3233:            static_cast<void*>(highestFrame));
   1:     aState.mPseudoFrames.Dump();
   1:   }
   1: #endif
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreatePseudoTableFrame(PRInt32                  aNameSpaceID,
   1:                                               nsFrameConstructorState& aState, 
   1:                                               nsIFrame*                aParentFrameIn)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsIFrame* parentFrame = (aState.mPseudoFrames.mCellInner.mFrame) 
   1:                           ? aState.mPseudoFrames.mCellInner.mFrame : aParentFrameIn;
   1:   if (!parentFrame) return rv;
   1: 
   1:   nsStyleContext *parentStyle;
   1:   nsRefPtr<nsStyleContext> childStyle;
   1: 
   1:   parentStyle = parentFrame->GetStyleContext(); 
   1:   nsIContent* parentContent = parentFrame->GetContent();   
   1: 
   1:   // Thankfully, the parent can't change display type without causing
   1:   // frame reconstruction, so this won't need to change.
   1:   nsIAtom *pseudoType;
   1:   if (parentStyle->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE)
   1:     pseudoType = nsCSSAnonBoxes::inlineTable;
   1:   else
   1:     pseudoType = nsCSSAnonBoxes::table;
   1: 
   1:   // create the SC for the inner table which will be the parent of the outer table's SC
   1:   childStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(parentContent,
   1:                                                              pseudoType,
   1:                                                              parentStyle);
   1: 
   1:   nsPseudoFrameData& pseudoOuter = aState.mPseudoFrames.mTableOuter;
   1:   nsPseudoFrameData& pseudoInner = aState.mPseudoFrames.mTableInner;
   1: 
   1:   // construct the pseudo outer and inner as part of the pseudo frames
   1:   nsFrameItems items;
   1:   rv = ConstructTableFrame(aState, parentContent,
   1:                            parentFrame, childStyle, aNameSpaceID,
   1:                            PR_TRUE, items, PR_TRUE, pseudoOuter.mFrame, 
   1:                            pseudoInner.mFrame);
   1: 
   1:   if (NS_FAILED(rv)) return rv;
   1: 
   1:   // set pseudo data for the newly created frames
   1:   pseudoOuter.mChildList.AddChild(pseudoInner.mFrame);
   1:   aState.mPseudoFrames.mLowestType = nsGkAtoms::tableFrame;
   1: 
   1:   // set pseudo data for the parent
   1:   if (aState.mPseudoFrames.mCellInner.mFrame) {
   1:     aState.mPseudoFrames.mCellInner.mChildList.AddChild(pseudoOuter.mFrame);
   1:   }
   1: #ifdef DEBUG
   1:   if (gTablePseudoFrame) {
   1:      printf("*** CreatePseudoTableFrame ***\n");
   1:     aState.mPseudoFrames.Dump();
   1:   }
   1: #endif
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreatePseudoRowGroupFrame(PRInt32                  aNameSpaceID,
   1:                                                  nsFrameConstructorState& aState, 
   1:                                                  nsIFrame*                aParentFrameIn)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsIFrame* parentFrame = (aState.mPseudoFrames.mTableInner.mFrame) 
   1:                           ? aState.mPseudoFrames.mTableInner.mFrame : aParentFrameIn;
   1:   if (!parentFrame) return rv;
   1: 
   1:   nsStyleContext *parentStyle;
   1:   nsRefPtr<nsStyleContext> childStyle;
   1: 
   1:   parentStyle = parentFrame->GetStyleContext();
   1:   nsIContent* parentContent = parentFrame->GetContent();
   1: 
   1:   childStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(parentContent,
   1:                                                              nsCSSAnonBoxes::tableRowGroup, 
   1:                                                              parentStyle);
   1: 
   1:   nsPseudoFrameData& pseudo = aState.mPseudoFrames.mRowGroup;
   1: 
   1:   // construct the pseudo row group as part of the pseudo frames
   1:   PRBool pseudoParent;
   1:   nsFrameItems items;
   1:   rv = ConstructTableRowGroupFrame(aState, parentContent,
   1:                                    parentFrame, childStyle, aNameSpaceID,
   1:                                    PR_TRUE, items, pseudo.mFrame, pseudoParent);
   1:   if (NS_FAILED(rv)) return rv;
   1: 
   1:   // set pseudo data for the newly created frames
   1:   aState.mPseudoFrames.mLowestType = nsGkAtoms::tableRowGroupFrame;
   1: 
   1:   // set pseudo data for the parent
   1:   if (aState.mPseudoFrames.mTableInner.mFrame) {
   1:     aState.mPseudoFrames.mTableInner.mChildList.AddChild(pseudo.mFrame);
   1:   }
   1: #ifdef DEBUG
   1:   if (gTablePseudoFrame) {
   1:      printf("*** CreatePseudoRowGroupFrame ***\n");
   1:     aState.mPseudoFrames.Dump();
   1:   }
   1: #endif
   1:   return rv;
   1: }
   1: 
   1: nsresult 
   1: nsCSSFrameConstructor::CreatePseudoColGroupFrame(PRInt32                  aNameSpaceID,
   1:                                                  nsFrameConstructorState& aState, 
   1:                                                  nsIFrame*                aParentFrameIn)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsIFrame* parentFrame = (aState.mPseudoFrames.mTableInner.mFrame) 
   1:                           ? aState.mPseudoFrames.mTableInner.mFrame : aParentFrameIn;
   1:   if (!parentFrame) return rv;
   1: 
   1:   nsStyleContext *parentStyle;
   1:   nsRefPtr<nsStyleContext> childStyle;
   1: 
   1:   parentStyle = parentFrame->GetStyleContext();
   1:   nsIContent* parentContent = parentFrame->GetContent();
   1: 
   1:   childStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(parentContent,
   1:                                                              nsCSSAnonBoxes::tableColGroup, 
   1:                                                              parentStyle);
   1: 
   1:   nsPseudoFrameData& pseudo = aState.mPseudoFrames.mColGroup;
   1: 
   1:   // construct the pseudo col group as part of the pseudo frames
   1:   PRBool pseudoParent;
   1:   nsFrameItems items;
   1:   rv = ConstructTableColGroupFrame(aState, parentContent,
   1:                                    parentFrame, childStyle, aNameSpaceID,
   1:                                    PR_TRUE, items, pseudo.mFrame, pseudoParent);
   1:   if (NS_FAILED(rv)) return rv;
   1:   ((nsTableColGroupFrame*)pseudo.mFrame)->SetColType(eColGroupAnonymousCol);
   1: 
   1:   // Do not set  aState.mPseudoFrames.mLowestType here as colgroup frame will
   1:   // be always below a table frame but we can not descent any further as col
   1:   // frames can not have children and will not wrap table foreign frames.
   1: 
   1:   // set pseudo data for the parent
   1:   if (aState.mPseudoFrames.mTableInner.mFrame) {
   1:     aState.mPseudoFrames.mTableInner.mChildList.AddChild(pseudo.mFrame);
   1:   }
   1: #ifdef DEBUG
   1:   if (gTablePseudoFrame) {
   1:      printf("*** CreatePseudoColGroupFrame ***\n");
   1:     aState.mPseudoFrames.Dump();
   1:   }
   1: #endif
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreatePseudoRowFrame(PRInt32                  aNameSpaceID,
   1:                                             nsFrameConstructorState& aState, 
   1:                                             nsIFrame*                aParentFrameIn)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsIFrame* parentFrame = aParentFrameIn;
   1:   if (aState.mPseudoFrames.mRowGroup.mFrame) {
   1:     parentFrame = (nsIFrame*) nsTableFrame::GetRowGroupFrame(aState.mPseudoFrames.mRowGroup.mFrame);
   1:   }
   1:   if (!parentFrame) return rv;
   1: 
   1:   nsStyleContext *parentStyle;
   1:   nsRefPtr<nsStyleContext> childStyle;
   1: 
   1:   parentStyle = parentFrame->GetStyleContext();
   1:   nsIContent* parentContent = parentFrame->GetContent();
   1: 
   1:   childStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(parentContent,
   1:                                                              nsCSSAnonBoxes::tableRow, 
   1:                                                              parentStyle);
   1: 
   1:   nsPseudoFrameData& pseudo = aState.mPseudoFrames.mRow;
   1: 
   1:   // construct the pseudo row as part of the pseudo frames
   1:   PRBool pseudoParent;
   1:   nsFrameItems items;
   1:   rv = ConstructTableRowFrame(aState, parentContent,
   1:                               parentFrame, childStyle, aNameSpaceID,
   1:                               PR_TRUE, items, pseudo.mFrame, pseudoParent);
   1:   if (NS_FAILED(rv)) return rv;
   1: 
   1:   aState.mPseudoFrames.mLowestType = nsGkAtoms::tableRowFrame;
   1: 
   1:   // set pseudo data for the parent
   1:   if (aState.mPseudoFrames.mRowGroup.mFrame) {
   1:     aState.mPseudoFrames.mRowGroup.mChildList.AddChild(pseudo.mFrame);
   1:   }
   1: #ifdef DEBUG
   1:   if (gTablePseudoFrame) {
   1:      printf("*** CreatePseudoRowFrame ***\n");
   1:     aState.mPseudoFrames.Dump();
   1:   }
   1: #endif
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreatePseudoCellFrame(PRInt32                  aNameSpaceID,
   1:                                              nsFrameConstructorState& aState, 
   1:                                              nsIFrame*                aParentFrameIn)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsIFrame* parentFrame = (aState.mPseudoFrames.mRow.mFrame) 
   1:                           ? aState.mPseudoFrames.mRow.mFrame : aParentFrameIn;
   1:   if (!parentFrame) return rv;
   1: 
   1:   nsStyleContext *parentStyle;
   1:   nsRefPtr<nsStyleContext> childStyle;
   1: 
   1:   parentStyle = parentFrame->GetStyleContext();
   1:   nsIContent* parentContent = parentFrame->GetContent();
   1: 
   1:   childStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(parentContent,
   1:                                                              nsCSSAnonBoxes::tableCell, 
   1:                                                              parentStyle);
   1: 
   1:   nsPseudoFrameData& pseudoOuter = aState.mPseudoFrames.mCellOuter;
   1:   nsPseudoFrameData& pseudoInner = aState.mPseudoFrames.mCellInner;
   1: 
   1:   // construct the pseudo outer and inner as part of the pseudo frames
   1:   PRBool pseudoParent;
   1:   nsFrameItems items;
   1:   rv = ConstructTableCellFrame(aState, parentContent, parentFrame, childStyle,
   1:                                aNameSpaceID, PR_TRUE, items,
   1:                                pseudoOuter.mFrame, pseudoInner.mFrame,
   1:                                pseudoParent);
   1:   if (NS_FAILED(rv)) return rv;
   1: 
   1:   // set pseudo data for the newly created frames
   1:   pseudoOuter.mChildList.AddChild(pseudoInner.mFrame);
   1:   // give it nsGkAtoms::tableCellFrame, if it is really nsGkAtoms::bcTableCellFrame, it will match later
   1:   aState.mPseudoFrames.mLowestType = nsGkAtoms::tableCellFrame;
   1: 
   1:   // set pseudo data for the parent
   1:   if (aState.mPseudoFrames.mRow.mFrame) {
   1:     aState.mPseudoFrames.mRow.mChildList.AddChild(pseudoOuter.mFrame);
   1:   }
   1: #ifdef DEBUG
   1:   if (gTablePseudoFrame) {
   1:      printf("*** CreatePseudoCellFrame ***\n");
   1:     aState.mPseudoFrames.Dump();
   1:   }
   1: #endif
   1:   return rv;
   1: }
   1: 
   1: // called if the parent is not a table
   1: nsresult 
   1: nsCSSFrameConstructor::GetPseudoTableFrame(PRInt32                  aNameSpaceID,
   1:                                            nsFrameConstructorState& aState, 
   1:                                            nsIFrame&                aParentFrameIn)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
   1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
   1: 
   1:   if (pseudoFrames.IsEmpty()) {
   1:     PRBool created = PR_FALSE;
   1:     if (nsGkAtoms::tableRowGroupFrame == parentFrameType) { // row group parent
   1:       rv = CreatePseudoRowFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:       if (NS_FAILED(rv)) return rv;
   1:       created = PR_TRUE;
   1:     }
   1:     if (created || (nsGkAtoms::tableRowFrame == parentFrameType)) { // row parent
   1:       rv = CreatePseudoCellFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:       if (NS_FAILED(rv)) return rv;
   1:     }
   1:     rv = CreatePseudoTableFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:   }
   1:   else {
   1:     if (!pseudoFrames.mTableInner.mFrame) { 
   1:       if (pseudoFrames.mRowGroup.mFrame && !(pseudoFrames.mRow.mFrame)) {
   1:         rv = CreatePseudoRowFrame(aNameSpaceID, aState);
   1:         if (NS_FAILED(rv)) return rv;
   1:       }
   1:       if (pseudoFrames.mRow.mFrame && !(pseudoFrames.mCellOuter.mFrame)) {
   1:         rv = CreatePseudoCellFrame(aNameSpaceID, aState);
   1:         if (NS_FAILED(rv)) return rv;
   1:       }
   1:       CreatePseudoTableFrame(aNameSpaceID, aState);
   1:     }
   1:   }
   1:   return rv;
   1: }
   1: 
   1: // called if the parent is not a col group
   1: nsresult 
   1: nsCSSFrameConstructor::GetPseudoColGroupFrame(PRInt32                  aNameSpaceID,
   1:                                               nsFrameConstructorState& aState, 
   1:                                               nsIFrame&                aParentFrameIn)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
   1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
   1: 
   1:   if (pseudoFrames.IsEmpty()) {
   1:     PRBool created = PR_FALSE;
   1:     if (nsGkAtoms::tableRowGroupFrame == parentFrameType) {  // row group parent
   1:       rv = CreatePseudoRowFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:       created = PR_TRUE;
   1:     }
   1:     if (created || (nsGkAtoms::tableRowFrame == parentFrameType)) { // row parent
   1:       rv = CreatePseudoCellFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:       created = PR_TRUE;
   1:     }
   1:     if (created || IS_TABLE_CELL(parentFrameType) || // cell parent
   1:         (nsGkAtoms::tableCaptionFrame == parentFrameType)  || // caption parent
   1:         !IsTableRelated(parentFrameType, PR_TRUE)) { // block parent
   1:       rv = CreatePseudoTableFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:     }
   1:     rv = CreatePseudoColGroupFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:   }
   1:   else {
   1:     if (!pseudoFrames.mColGroup.mFrame) {
   1:       if (!pseudoFrames.mTableInner.mFrame) {
   1:         if (pseudoFrames.mRowGroup.mFrame && !(pseudoFrames.mRow.mFrame)) {
   1:           rv = CreatePseudoRowFrame(aNameSpaceID, aState);
   1:         }
   1:         if (pseudoFrames.mRow.mFrame && !(pseudoFrames.mCellOuter.mFrame)) {
   1:           rv = CreatePseudoCellFrame(aNameSpaceID, aState);
   1:         }
   1:         if (pseudoFrames.mCellOuter.mFrame && !(pseudoFrames.mTableOuter.mFrame)) {
   1:           rv = CreatePseudoTableFrame(aNameSpaceID, aState);
   1:         }
   1:       }
   1:       rv = CreatePseudoColGroupFrame(aNameSpaceID, aState);
   1:     }
   1:   }
   1:   return rv;
   1: }
   1: 
   1: // called if the parent is not a row group
   1: nsresult 
   1: nsCSSFrameConstructor::GetPseudoRowGroupFrame(PRInt32                  aNameSpaceID,
   1:                                               nsFrameConstructorState& aState, 
   1:                                               nsIFrame&                aParentFrameIn)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
   1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
   1: 
   1:   if (!pseudoFrames.mLowestType) {
   1:     PRBool created = PR_FALSE;
   1:     if (nsGkAtoms::tableRowFrame == parentFrameType) {  // row parent
   1:       rv = CreatePseudoCellFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:       created = PR_TRUE;
   1:     }
   1:     if (created || IS_TABLE_CELL(parentFrameType) || // cell parent
   1:         (nsGkAtoms::tableCaptionFrame == parentFrameType)  || // caption parent
   1:         !IsTableRelated(parentFrameType, PR_TRUE)) { // block parent
   1:       rv = CreatePseudoTableFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:     }
   1:     rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:   }
   1:   else {
   1:     if (!pseudoFrames.mRowGroup.mFrame) { 
   1:       if (pseudoFrames.mRow.mFrame && !(pseudoFrames.mCellOuter.mFrame)) {
   1:         rv = CreatePseudoCellFrame(aNameSpaceID, aState);
   1:       }
   1:       if (pseudoFrames.mCellOuter.mFrame && !(pseudoFrames.mTableOuter.mFrame)) {
   1:         rv = CreatePseudoTableFrame(aNameSpaceID, aState);
   1:       }
   1:       rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState);
   1:     }
   1:   }
   1:   return rv;
   1: }
   1: 
   1: // called if the parent is not a row
   1: nsresult
   1: nsCSSFrameConstructor::GetPseudoRowFrame(PRInt32                  aNameSpaceID,
   1:                                          nsFrameConstructorState& aState, 
   1:                                          nsIFrame&                aParentFrameIn)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
   1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
   1: 
   1:   if (!pseudoFrames.mLowestType) {
   1:     PRBool created = PR_FALSE;
   1:     if (IS_TABLE_CELL(parentFrameType) || // cell parent
   1:        (nsGkAtoms::tableCaptionFrame == parentFrameType)  || // caption parent
   1:         !IsTableRelated(parentFrameType, PR_TRUE)) { // block parent
   1:       rv = CreatePseudoTableFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:       created = PR_TRUE;
   1:     }
   1:     if (created || (nsGkAtoms::tableFrame == parentFrameType)) { // table parent
   1:       rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:     }
   1:     rv = CreatePseudoRowFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:   }
   1:   else {
   1:     if (!pseudoFrames.mRow.mFrame) { 
   1:       if (pseudoFrames.mCellOuter.mFrame && !pseudoFrames.mTableOuter.mFrame) {
   1:         rv = CreatePseudoTableFrame(aNameSpaceID, aState);
   1:       }
   1:       if (pseudoFrames.mTableInner.mFrame && !(pseudoFrames.mRowGroup.mFrame)) {
   1:         rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState);
   1:       }
   1:       rv = CreatePseudoRowFrame(aNameSpaceID, aState);
   1:     }
   1:   }
   1:   return rv;
   1: }
   1: 
   1: // called if the parent is not a cell or block
   1: nsresult 
   1: nsCSSFrameConstructor::GetPseudoCellFrame(PRInt32                  aNameSpaceID,
   1:                                           nsFrameConstructorState& aState, 
   1:                                           nsIFrame&                aParentFrameIn)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
   1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
   1: 
   1:   if (!pseudoFrames.mLowestType) {
   1:     PRBool created = PR_FALSE;
   1:     if (nsGkAtoms::tableFrame == parentFrameType) { // table parent
   1:       rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:       created = PR_TRUE;
   1:     }
   1:     if (created || (nsGkAtoms::tableRowGroupFrame == parentFrameType)) { // row group parent
   1:       rv = CreatePseudoRowFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:       created = PR_TRUE;
   1:     }
   1:     rv = CreatePseudoCellFrame(aNameSpaceID, aState, &aParentFrameIn);
   1:   }
   1:   else if (!pseudoFrames.mCellOuter.mFrame) { 
   1:     if (pseudoFrames.mTableInner.mFrame && !(pseudoFrames.mRowGroup.mFrame)) {
   1:       rv = CreatePseudoRowGroupFrame(aNameSpaceID, aState);
   1:     }
   1:     if (pseudoFrames.mRowGroup.mFrame && !(pseudoFrames.mRow.mFrame)) {
   1:       rv = CreatePseudoRowFrame(aNameSpaceID, aState);
   1:     }
   1:     rv = CreatePseudoCellFrame(aNameSpaceID, aState);
   1:   }
   1:   return rv;
   1: }
   1: 
   1: nsresult 
   1: nsCSSFrameConstructor::GetParentFrame(PRInt32                  aNameSpaceID,
   1:                                       nsIFrame&                aParentFrameIn, 
   1:                                       nsIAtom*                 aChildFrameType, 
   1:                                       nsFrameConstructorState& aState, 
   1:                                       nsIFrame*&               aParentFrame,
   1:                                       PRBool&                  aIsPseudoParent)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsIAtom* parentFrameType = aParentFrameIn.GetType();
   1:   nsIFrame* pseudoParentFrame = nsnull;
   1:   nsPseudoFrames& pseudoFrames = aState.mPseudoFrames;
   1:   aParentFrame = &aParentFrameIn;
   1:   aIsPseudoParent = PR_FALSE;
   1: 
   1:   if (nsGkAtoms::tableOuterFrame == aChildFrameType) { // table child
   1:     if (IsTableRelated(parentFrameType, PR_TRUE) &&
   1:         (nsGkAtoms::tableCaptionFrame != parentFrameType) ) { // need pseudo cell parent
   1:       rv = GetPseudoCellFrame(aNameSpaceID, aState, aParentFrameIn);
   1:       if (NS_FAILED(rv)) return rv;
   1:       pseudoParentFrame = pseudoFrames.mCellInner.mFrame;
   1:     }
   1:   } 
   1:   else if (nsGkAtoms::tableCaptionFrame == aChildFrameType) { // caption child
   1:     if (nsGkAtoms::tableOuterFrame != parentFrameType) { // need pseudo table parent
   1:       rv = GetPseudoTableFrame(aNameSpaceID, aState, aParentFrameIn);
   1:       if (NS_FAILED(rv)) return rv;
   1:       pseudoParentFrame = pseudoFrames.mTableOuter.mFrame;
   1:     }
   1:   }
   1:   else if (nsGkAtoms::tableColGroupFrame == aChildFrameType) { // col group child
   1:     if (nsGkAtoms::tableFrame != parentFrameType) { // need pseudo table parent
   1:       rv = GetPseudoTableFrame(aNameSpaceID, aState, aParentFrameIn);
   1:       if (NS_FAILED(rv)) return rv;
   1:       pseudoParentFrame = pseudoFrames.mTableInner.mFrame;
   1:     }
   1:   }
   1:   else if (nsGkAtoms::tableColFrame == aChildFrameType) { // col child
   1:     if (nsGkAtoms::tableColGroupFrame != parentFrameType) { // need pseudo col group parent
   1:       rv = GetPseudoColGroupFrame(aNameSpaceID, aState, aParentFrameIn);
   1:       if (NS_FAILED(rv)) return rv;
   1:       pseudoParentFrame = pseudoFrames.mColGroup.mFrame;
   1:     }
   1:   }
   1:   else if (nsGkAtoms::tableRowGroupFrame == aChildFrameType) { // row group child
   1:     // XXX can this go away?
   1:     if (nsGkAtoms::tableFrame != parentFrameType) {
   1:       // trees allow row groups to contain row groups, so don't create pseudo frames
   1:         rv = GetPseudoTableFrame(aNameSpaceID, aState, aParentFrameIn);
   1:         if (NS_FAILED(rv)) return rv;
   1:         pseudoParentFrame = pseudoFrames.mTableInner.mFrame;
   1:      }
   1:   }
   1:   else if (nsGkAtoms::tableRowFrame == aChildFrameType) { // row child
   1:     if (nsGkAtoms::tableRowGroupFrame != parentFrameType) { // need pseudo row group parent
   1:       rv = GetPseudoRowGroupFrame(aNameSpaceID, aState, aParentFrameIn);
   1:       if (NS_FAILED(rv)) return rv;
   1:       pseudoParentFrame = pseudoFrames.mRowGroup.mFrame;
   1:     }
   1:   }
   1:   else if (IS_TABLE_CELL(aChildFrameType)) { // cell child
   1:     if (nsGkAtoms::tableRowFrame != parentFrameType) { // need pseudo row parent
   1:       rv = GetPseudoRowFrame(aNameSpaceID, aState, aParentFrameIn);
   1:       if (NS_FAILED(rv)) return rv;
   1:       pseudoParentFrame = pseudoFrames.mRow.mFrame;
   1:     }
   1:   }
   1:   else if (nsGkAtoms::tableFrame == aChildFrameType) { // invalid
   1:     NS_ASSERTION(PR_FALSE, "GetParentFrame called on nsGkAtoms::tableFrame child");
   1:   }
   1:   else { // foreign frame
   1:     if (IsTableRelated(parentFrameType, PR_FALSE)) { // need pseudo cell parent
   1:       rv = GetPseudoCellFrame(aNameSpaceID, aState, aParentFrameIn);
   1:       if (NS_FAILED(rv)) return rv;
   1:       pseudoParentFrame = pseudoFrames.mCellInner.mFrame;
   1:     }
   1:   }
   1:   
   1:   if (pseudoParentFrame) {
   1:     aParentFrame = pseudoParentFrame;
   1:     aIsPseudoParent = PR_TRUE;
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: static PRBool
   1: IsSpecialContent(nsIContent*     aContent,
   1:                  nsIAtom*        aTag,
   1:                  PRInt32         aNameSpaceID,
   1:                  nsStyleContext* aStyleContext)
   1: {
   1:   // Gross hack. Return true if this is a content node that we'd create a
   1:   // frame for based on something other than display -- in other words if this
   1:   // is a node that could never have a nsTableCellFrame, for example.
   1:   if (aContent->IsNodeOfType(nsINode::eHTML) ||
   1:       aNameSpaceID == kNameSpaceID_XHTML) {
   1:     // XXXbz this is duplicating some logic from ConstructHTMLFrame....
   1:     // Would be nice to avoid that.  :(
   1: 
   1:     if (aTag == nsGkAtoms::input) {
   1:       nsCOMPtr<nsIFormControl> control = do_QueryInterface(aContent);
   1:       if (control) {
   1:         PRInt32 type = control->GetType();
   1:         if (NS_FORM_INPUT_HIDDEN == type) {
   1:           return PR_FALSE; // input hidden does not create a special frame
   1:         }
   1:         else if (NS_FORM_INPUT_IMAGE == type) {
   1:           return nsImageFrame::ShouldCreateImageFrameFor(aContent, aStyleContext);
   1:         }
   1:       }
   1: 
   1:       return PR_TRUE;
   1:     }
   1: 
   1:     if (aTag == nsGkAtoms::img) {
   1:       return nsImageFrame::ShouldCreateImageFrameFor(aContent, aStyleContext);
   1:     }
   1: 
   1:     if (aTag == nsGkAtoms::object ||
   1:         aTag == nsGkAtoms::applet ||
   1:         aTag == nsGkAtoms::embed) {
   1:       return !(aContent->IntrinsicState() &
   1:              (NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED |
   1:               NS_EVENT_STATE_SUPPRESSED));
   1:     }
   1: 
   1:     return
   1:       aTag == nsGkAtoms::br ||
   1:       aTag == nsGkAtoms::wbr ||
   1:       aTag == nsGkAtoms::textarea ||
   1:       aTag == nsGkAtoms::select ||
   1:       aTag == nsGkAtoms::fieldset ||
   1:       aTag == nsGkAtoms::legend ||
   1:       aTag == nsGkAtoms::frameset ||
   1:       aTag == nsGkAtoms::iframe ||
   1:       aTag == nsGkAtoms::spacer ||
   1:       aTag == nsGkAtoms::button ||
   1:       aTag == nsGkAtoms::isindex ||
   1:       aTag == nsGkAtoms::canvas;
   1:   }
   1: 
   1: 
   1:   if (aNameSpaceID == kNameSpaceID_XUL)
   1:     return
   1: #ifdef MOZ_XUL
   1:       aTag == nsGkAtoms::button ||
   1:       aTag == nsGkAtoms::checkbox ||
   1:       aTag == nsGkAtoms::radio ||
   1:       aTag == nsGkAtoms::autorepeatbutton ||
   1:       aTag == nsGkAtoms::titlebar ||
   1:       aTag == nsGkAtoms::resizer ||
   1:       aTag == nsGkAtoms::image ||
   1:       aTag == nsGkAtoms::spring ||
   1:       aTag == nsGkAtoms::spacer ||
   1:       aTag == nsGkAtoms::treechildren ||
   1:       aTag == nsGkAtoms::treecol ||
   1:       aTag == nsGkAtoms::text ||
   1:       aTag == nsGkAtoms::description ||
   1:       aTag == nsGkAtoms::label ||
   1:       aTag == nsGkAtoms::menu ||
   1:       aTag == nsGkAtoms::menuitem ||
   1:       aTag == nsGkAtoms::menubutton ||
   1:       aTag == nsGkAtoms::menubar ||
   1:       aTag == nsGkAtoms::popupgroup ||
   1:       aTag == nsGkAtoms::iframe ||
   1:       aTag == nsGkAtoms::editor ||
   1:       aTag == nsGkAtoms::browser ||
   1:       aTag == nsGkAtoms::progressmeter ||
   1: #endif
   1:       aTag == nsGkAtoms::slider ||
   1:       aTag == nsGkAtoms::scrollbar ||
   1:       aTag == nsGkAtoms::scrollbarbutton ||
   1: #ifdef MOZ_XUL
   1:       aTag == nsGkAtoms::splitter ||
   1: #endif
   1:       PR_FALSE;
   1: 
   1: #ifdef MOZ_SVG
   1:   if (aNameSpaceID == kNameSpaceID_SVG && NS_SVGEnabled()) {
   1:     // All SVG content is special...
   1:     return PR_TRUE;
   1:   }
   1: #endif
   1: 
   1: #ifdef MOZ_MATHML
   1:   if (aNameSpaceID == kNameSpaceID_MathML)
   1:     return
   1:       aTag == nsGkAtoms::mi_ ||
   1:       aTag == nsGkAtoms::mn_ ||
   1:       aTag == nsGkAtoms::ms_ ||
   1:       aTag == nsGkAtoms::mtext_ ||
   1:       aTag == nsGkAtoms::mo_ ||
   1:       aTag == nsGkAtoms::mfrac_ ||
   1:       aTag == nsGkAtoms::msup_ ||
   1:       aTag == nsGkAtoms::msub_ ||
   1:       aTag == nsGkAtoms::msubsup_ ||
   1:       aTag == nsGkAtoms::munder_ ||
   1:       aTag == nsGkAtoms::mover_ ||
   1:       aTag == nsGkAtoms::munderover_ ||
   1:       aTag == nsGkAtoms::mphantom_ ||
   1:       aTag == nsGkAtoms::mpadded_ ||
   1:       aTag == nsGkAtoms::mspace_ ||
   1:       aTag == nsGkAtoms::mfenced_ ||
   1:       aTag == nsGkAtoms::mmultiscripts_ ||
   1:       aTag == nsGkAtoms::mstyle_ ||
   1:       aTag == nsGkAtoms::msqrt_ ||
   1:       aTag == nsGkAtoms::mroot_ ||
   1:       aTag == nsGkAtoms::maction_ ||
   1:       aTag == nsGkAtoms::mrow_   ||
   1:       aTag == nsGkAtoms::merror_ ||
   1:       aTag == nsGkAtoms::none   ||
 442:       aTag == nsGkAtoms::mprescripts_ ||
 442:       (aTag == nsGkAtoms::mtable_ &&
 442:        aStyleContext->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_TABLE) ||
 442:       aTag == nsGkAtoms::math;
   1: #endif
   1:   return PR_FALSE;
   1: }
   1:                                       
   1: nsresult
   1: nsCSSFrameConstructor::AdjustParentFrame(nsFrameConstructorState&     aState,
   1:                                          nsIContent*                  aChildContent,
   1:                                          nsIFrame* &                  aParentFrame,
   1:                                          nsIAtom*                     aTag,
   1:                                          PRInt32                      aNameSpaceID,
   1:                                          nsStyleContext*              aChildStyle,
   1:                                          nsFrameItems* &              aFrameItems,
   1:                                          nsFrameConstructorSaveState& aSaveState,
   1:                                          PRBool&                      aSuppressFrame,
   1:                                          PRBool&                      aCreatedPseudo)
   1: {
   1:   NS_PRECONDITION(aChildStyle, "Must have child's style context");
   1:   NS_PRECONDITION(aFrameItems, "Must have frame items to work with");
   1: 
   1:   aSuppressFrame = PR_FALSE;
   1:   aCreatedPseudo = PR_FALSE;
   1:   if (!aParentFrame) {
   1:     // Nothing to do here
   1:     return NS_OK;
   1:   }
   1: 
   1:   PRBool childIsSpecialContent = PR_FALSE; // lazy lookup
   1:   // Only use the outer table frame as parent if the child is going to use a
   1:   // tableCaptionFrame, otherwise the inner table frame is the parent
   1:   // (bug 341858).
   1:   nsIAtom* parentType = aParentFrame->GetType();
4194:   NS_ASSERTION(parentType != nsGkAtoms::tableOuterFrame,
4194:                "Shouldn't be happening");
4194:   if (parentType == nsGkAtoms::tableColGroupFrame) {
   1:     childIsSpecialContent = IsSpecialContent(aChildContent, aTag, aNameSpaceID,
   1:                                              aChildStyle);
   1:     if (childIsSpecialContent ||
   1:         (aChildStyle->GetStyleDisplay()->mDisplay !=
   1:          NS_STYLE_DISPLAY_TABLE_COLUMN)) {
   1:       aSuppressFrame = PR_TRUE;
   1:       return NS_OK;
   1:     }
   1:   }
   1:  
   1:   // If our parent is a table, table-row-group, or table-row, and
   1:   // we're not table-related in any way, we have to create table
   1:   // pseudo-frames so that we have a table cell to live in.
   1:   if (IsTableRelated(aParentFrame->GetType(), PR_FALSE) &&
   1:       (!IsTableRelated(aChildStyle->GetStyleDisplay()->mDisplay, PR_TRUE) ||
   1:        // Also need to create a pseudo-parent if the child is going to end up
   1:        // with a frame based on something other than display.
   1:        childIsSpecialContent || // looked it up before
   1:        IsSpecialContent(aChildContent, aTag, aNameSpaceID, aChildStyle))) {
   1:     nsresult rv = GetPseudoCellFrame(aNameSpaceID, aState, *aParentFrame);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1: 
   1:     NS_ASSERTION(aState.mPseudoFrames.mCellInner.mFrame,
   1:                  "Must have inner cell frame now!");
   1: 
   1:     aParentFrame = aState.mPseudoFrames.mCellInner.mFrame;
   1:     aFrameItems = &aState.mPseudoFrames.mCellInner.mChildList;
   1:     // We pushed an anonymous table cell.  The inner block of this
   1:     // needs to become the float containing block.
   1:     aState.PushFloatContainingBlock(aParentFrame, aSaveState, PR_FALSE,
   1:                                     PR_FALSE);
   1:     aCreatedPseudo = PR_TRUE;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
4368: // Pull all the captions present in aItems out  into aCaptions
4368: static void
4368: PullOutCaptionFrames(nsFrameItems& aItems, nsFrameItems& aCaptions)
4368: {
4368:   nsIFrame *child = aItems.childList;
4368:   nsIFrame* prev = nsnull;
4368:   while (child) {
4368:     nsIFrame *nextSibling = child->GetNextSibling();
4368:     if (nsGkAtoms::tableCaptionFrame == child->GetType()) {
4368:       aItems.RemoveChild(child, prev);
4368:       aCaptions.AddChild(child);
4368:     } else {
4368:       prev = child;
4368:     }
4368:     child = nextSibling;
4368:   }
4368: }
4368: 
4368: 
   1: // Construct the outer, inner table frames and the children frames for the table. 
   1: // XXX Page break frames for pseudo table frames are not constructed to avoid the risk
   1: // associated with revising the pseudo frame mechanism. The long term solution
   1: // of having frames handle page-break-before/after will solve the problem. 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructTableFrame(nsFrameConstructorState& aState,
   1:                                            nsIContent*              aContent,
   1:                                            nsIFrame*                aContentParent,
   1:                                            nsStyleContext*          aStyleContext,
   1:                                            PRInt32                  aNameSpaceID,
   1:                                            PRBool                   aIsPseudo,
   1:                                            nsFrameItems&            aChildItems,
   1:                                            PRBool                   aAllowOutOfFlow,
   1:                                            nsIFrame*&               aNewOuterFrame,
   1:                                            nsIFrame*&               aNewInnerFrame)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1: 
   1:   // create the pseudo SC for the outer table as a child of the inner SC
   1:   nsRefPtr<nsStyleContext> outerStyleContext;
   1:   outerStyleContext = mPresShell->StyleSet()->
   1:     ResolvePseudoStyleFor(aContent, nsCSSAnonBoxes::tableOuter, aStyleContext);
   1: 
   1:   // Create the outer table frame which holds the caption and inner table frame
   1: #ifdef MOZ_MATHML
   1:   if (kNameSpaceID_MathML == aNameSpaceID)
   1:     aNewOuterFrame = NS_NewMathMLmtableOuterFrame(mPresShell,
   1:                                                   outerStyleContext);
   1:   else
   1: #endif
   1:     aNewOuterFrame = NS_NewTableOuterFrame(mPresShell, outerStyleContext);
   1: 
   1:   nsIFrame* parentFrame = aContentParent;
   1:   nsFrameItems* frameItems = &aChildItems;
   1:   // We may need to push a float containing block
   1:   nsFrameConstructorSaveState floatSaveState;
   1:   if (!aIsPseudo) {
   1:     // this frame may have a pseudo parent
   1:     PRBool hasPseudoParent = PR_FALSE;
   1:     GetParentFrame(aNameSpaceID,*parentFrame, nsGkAtoms::tableOuterFrame,
   1:                    aState, parentFrame, hasPseudoParent);
   1:     if (!hasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aChildItems);
   1:     }
   1:     if (hasPseudoParent) {
   1:       aState.PushFloatContainingBlock(parentFrame, floatSaveState,
   1:                                       PR_FALSE, PR_FALSE);
   1:       frameItems = &aState.mPseudoFrames.mCellInner.mChildList;
   1:       if (aState.mPseudoFrames.mTableOuter.mFrame) {
   1:         ProcessPseudoFrames(aState, nsGkAtoms::tableOuterFrame);
   1:       }
   1:     }
   1:   }
   1: 
   1:   const nsStyleDisplay* disp = outerStyleContext->GetStyleDisplay();
   1:   // We need the aAllowOutOfFlow thing for MathML.  See bug 355993.
   1:   // Once bug 348577 is fixed, we should remove this code.  At that
   1:   // point, the aAllowOutOfFlow arg can go away.
   1:   nsIFrame* geometricParent =
   1:     aAllowOutOfFlow ? aState.GetGeometricParent(disp, parentFrame) :
   1:                       parentFrame;
   1: 
   1:   // Init the table outer frame and see if we need to create a view, e.g.
   1:   // the frame is absolutely positioned  
   1:   InitAndRestoreFrame(aState, aContent, geometricParent, nsnull, aNewOuterFrame);  
   1:   nsHTMLContainerFrame::CreateViewForFrame(aNewOuterFrame, aContentParent,
   1:                                            PR_FALSE);
   1: 
   1:   // Create the inner table frame
   1: #ifdef MOZ_MATHML
   1:   if (kNameSpaceID_MathML == aNameSpaceID)
   1:     aNewInnerFrame = NS_NewMathMLmtableFrame(mPresShell, aStyleContext);
   1:   else
   1: #endif
   1:     aNewInnerFrame = NS_NewTableFrame(mPresShell, aStyleContext);
   1:  
   1:   InitAndRestoreFrame(aState, aContent, aNewOuterFrame, nsnull,
   1:                       aNewInnerFrame);
   1: 
   1:   if (!aIsPseudo) {
   1:     // Put the newly created frames into the right child list
   1:     aNewOuterFrame->SetInitialChildList(nsnull, aNewInnerFrame);
   1: 
   1:     rv = aState.AddChild(aNewOuterFrame, *frameItems, disp, aContent,
   1:                          outerStyleContext, parentFrame, aAllowOutOfFlow,
   1:                          aAllowOutOfFlow);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1: 
   1:     nsFrameItems childItems;
   1:     rv = ProcessChildren(aState, aContent, aNewInnerFrame, PR_FALSE, childItems,
   1:                          PR_FALSE);
   1:     // XXXbz what about cleaning up?
   1:     if (NS_FAILED(rv)) return rv;
   1: 
   1:     // if there are any anonymous children for the table, create frames for them
   1:     CreateAnonymousFrames(nsnull, aState, aContent, aNewInnerFrame,
   1:                           PR_FALSE, childItems);
   1: 
   1:     nsFrameItems captionItems;
4368:     PullOutCaptionFrames(childItems, captionItems);
4368: 
   1:     // Set the inner table frame's initial primary list 
   1:     aNewInnerFrame->SetInitialChildList(nsnull, childItems.childList);
   1: 
   1:     // Set the outer table frame's secondary childlist lists
   1:     if (captionItems.childList) {
   1:         aNewOuterFrame->SetInitialChildList(nsGkAtoms::captionList,
   1:                                             captionItems.childList);
   1:     }
   1:  }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructTableCaptionFrame(nsFrameConstructorState& aState,
   1:                                                   nsIContent*              aContent,
   1:                                                   nsIFrame*                aParentFrameIn,
   1:                                                   nsStyleContext*          aStyleContext,
   1:                                                   PRInt32                  aNameSpaceID,
   1:                                                   nsFrameItems&            aChildItems,
   1:                                                   nsIFrame*&               aNewFrame,
   1:                                                   PRBool&                  aIsPseudoParent)
   1: 
   1: {
   1:   nsresult rv = NS_OK;
   1:   if (!aParentFrameIn) return rv;
   1: 
   1:   nsIFrame* parentFrame = aParentFrameIn;
   1:   aIsPseudoParent = PR_FALSE;
   1:   // this frame may have a pseudo parent
   1:   GetParentFrame(aNameSpaceID, *aParentFrameIn, 
   1:                  nsGkAtoms::tableCaptionFrame, aState, parentFrame,
   1:                  aIsPseudoParent);
   1:   if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:     ProcessPseudoFrames(aState, aChildItems);
   1:   }
   1: 
   1:   aNewFrame = NS_NewTableCaptionFrame(mPresShell, aStyleContext);
   1:   if (NS_UNLIKELY(!aNewFrame)) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1:   InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewFrame);
   1:   // XXXbz should we be passing in a non-null aContentParentFrame?
   1:   nsHTMLContainerFrame::CreateViewForFrame(aNewFrame, nsnull, PR_FALSE);
   1: 
   1:   PRBool haveFirstLetterStyle, haveFirstLineStyle;
1254:   ShouldHaveSpecialBlockStyle(aContent, aStyleContext,
   1:                               &haveFirstLetterStyle, &haveFirstLineStyle);
   1: 
   1:   // The caption frame is a float container
   1:   nsFrameConstructorSaveState floatSaveState;
   1:   aState.PushFloatContainingBlock(aNewFrame, floatSaveState,
   1:                                   haveFirstLetterStyle, haveFirstLineStyle);
   1:   nsFrameItems childItems;
   1:   rv = ProcessChildren(aState, aContent, aNewFrame,
   1:                        PR_TRUE, childItems, PR_TRUE);
   1:   if (NS_FAILED(rv)) return rv;
   1:   aNewFrame->SetInitialChildList(nsnull, childItems.childList);
   1:   if (aIsPseudoParent) {
   1:     aState.mPseudoFrames.mTableOuter.mChildList2.AddChild(aNewFrame);
   1:   }
   1:   
   1:   return rv;
   1: }
   1: 
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructTableRowGroupFrame(nsFrameConstructorState& aState,
   1:                                                    nsIContent*              aContent,
   1:                                                    nsIFrame*                aParentFrameIn,
   1:                                                    nsStyleContext*          aStyleContext,
   1:                                                    PRInt32                  aNameSpaceID,
   1:                                                    PRBool                   aIsPseudo,
   1:                                                    nsFrameItems&            aChildItems,
   1:                                                    nsIFrame*&               aNewFrame, 
   1:                                                    PRBool&                  aIsPseudoParent)
   1: {
   1:   nsresult rv = NS_OK;
   1:   if (!aParentFrameIn) return rv;
   1: 
   1:   nsIFrame* parentFrame = aParentFrameIn;
   1:   aIsPseudoParent = PR_FALSE;
   1:   if (!aIsPseudo) {
   1:     // this frame may have a pseudo parent
   1:     GetParentFrame(aNameSpaceID, *aParentFrameIn, 
   1:                    nsGkAtoms::tableRowGroupFrame, aState, parentFrame,
   1:                    aIsPseudoParent);
   1:     if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aChildItems);
   1:     }
   1:     if (!aIsPseudo && aIsPseudoParent && aState.mPseudoFrames.mRowGroup.mFrame) {
   1:       ProcessPseudoFrames(aState, nsGkAtoms::tableRowGroupFrame);
   1:     }
   1:   }
   1: 
   1:   const nsStyleDisplay* styleDisplay = aStyleContext->GetStyleDisplay();
   1: 
   1:   aNewFrame = NS_NewTableRowGroupFrame(mPresShell, aStyleContext);
   1: 
   1:   nsIFrame* scrollFrame = nsnull;
   1:   if (styleDisplay->IsScrollableOverflow()) {
   1:     // Create an area container for the frame
   1:     BuildScrollFrame(aState, aContent, aStyleContext, aNewFrame, parentFrame,
   1:                      nsnull, scrollFrame, aStyleContext);
   1: 
   1:   } 
   1:   else {
   1:     if (NS_UNLIKELY(!aNewFrame)) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:     InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewFrame);
   1:     // XXXbz should we be passing in a non-null aContentParentFrame?
   1:     nsHTMLContainerFrame::CreateViewForFrame(aNewFrame, nsnull, PR_FALSE);
   1:   }
   1: 
   1:   if (!aIsPseudo) {
   1:     nsFrameItems childItems;
   1:     rv = ProcessChildren(aState, aContent, aNewFrame, PR_FALSE, childItems,
   1:                          PR_FALSE);
   1:     
   1:     if (NS_FAILED(rv)) return rv;
   1: 
   1:     // if there are any anonymous children for the table, create frames for them
   1:     CreateAnonymousFrames(nsnull, aState, aContent, aNewFrame,
   1:                           PR_FALSE, childItems);
   1: 
   1:     aNewFrame->SetInitialChildList(nsnull, childItems.childList);
   1:     if (aIsPseudoParent) {
   1:       nsIFrame* child = (scrollFrame) ? scrollFrame : aNewFrame;
   1:       aState.mPseudoFrames.mTableInner.mChildList.AddChild(child);
   1:     }
   1:   } 
   1: 
   1:   // if there is a scroll frame, use it as the one constructed
   1:   if (scrollFrame) {
   1:     aNewFrame = scrollFrame;
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructTableColGroupFrame(nsFrameConstructorState& aState,
   1:                                                    nsIContent*              aContent,
   1:                                                    nsIFrame*                aParentFrameIn,
   1:                                                    nsStyleContext*          aStyleContext,
   1:                                                    PRInt32                  aNameSpaceID,
   1:                                                    PRBool                   aIsPseudo,
   1:                                                    nsFrameItems&            aChildItems,
   1:                                                    nsIFrame*&               aNewFrame, 
   1:                                                    PRBool&                  aIsPseudoParent)
   1: {
   1:   nsresult rv = NS_OK;
   1:   if (!aParentFrameIn) return rv;
   1: 
   1:   nsIFrame* parentFrame = aParentFrameIn;
   1:   aIsPseudoParent = PR_FALSE;
   1:   if (!aIsPseudo) {
   1:     // this frame may have a pseudo parent
   1:     GetParentFrame(aNameSpaceID, *aParentFrameIn,
   1:                    nsGkAtoms::tableColGroupFrame, aState, parentFrame,
   1:                    aIsPseudoParent);
   1:     if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aChildItems);
   1:     }
   1:     if (!aIsPseudo && aIsPseudoParent && aState.mPseudoFrames.mColGroup.mFrame) {
   1:       ProcessPseudoFrames(aState, nsGkAtoms::tableColGroupFrame);
   1:     }
   1:   }
   1: 
   1:   aNewFrame = NS_NewTableColGroupFrame(mPresShell, aStyleContext);
   1:   if (NS_UNLIKELY(!aNewFrame)) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1:   InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewFrame);
   1: 
   1:   if (!aIsPseudo) {
   1:     nsFrameItems childItems;
   1:     rv = ProcessChildren(aState, aContent, aNewFrame, PR_FALSE, childItems,
   1:                          PR_FALSE);
   1:     if (NS_FAILED(rv)) return rv;
   1:     aNewFrame->SetInitialChildList(nsnull, childItems.childList);
   1:     if (aIsPseudoParent) {
   1:       aState.mPseudoFrames.mTableInner.mChildList.AddChild(aNewFrame);
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructTableRowFrame(nsFrameConstructorState& aState,
   1:                                               nsIContent*              aContent,
   1:                                               nsIFrame*                aParentFrameIn,
   1:                                               nsStyleContext*          aStyleContext,
   1:                                               PRInt32                  aNameSpaceID,
   1:                                               PRBool                   aIsPseudo,
   1:                                               nsFrameItems&            aChildItems,
   1:                                               nsIFrame*&               aNewFrame,
   1:                                               PRBool&                  aIsPseudoParent)
   1: {
   1:   nsresult rv = NS_OK;
   1:   if (!aParentFrameIn) return rv;
   1: 
   1:   nsIFrame* parentFrame = aParentFrameIn;
   1:   aIsPseudoParent = PR_FALSE;
   1:   if (!aIsPseudo) {
   1:     // this frame may have a pseudo parent
   1:     GetParentFrame(aNameSpaceID, *aParentFrameIn,
   1:                    nsGkAtoms::tableRowFrame, aState, parentFrame,
   1:                    aIsPseudoParent);
   1:     if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aChildItems);
   1:     }
   1:     if (!aIsPseudo && aIsPseudoParent && aState.mPseudoFrames.mRow.mFrame) {
   1:       ProcessPseudoFrames(aState, nsGkAtoms::tableRowFrame);
   1:     }
   1:   }
   1: 
   1: #ifdef MOZ_MATHML
   1:   if (kNameSpaceID_MathML == aNameSpaceID)
   1:     aNewFrame = NS_NewMathMLmtrFrame(mPresShell, aStyleContext);
   1:   else
   1: #endif
   1:     aNewFrame = NS_NewTableRowFrame(mPresShell, aStyleContext);
   1: 
   1:   if (NS_UNLIKELY(!aNewFrame)) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1:   InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewFrame);
   1:   // XXXbz should we be passing in a non-null aContentParentFrame?
   1:   nsHTMLContainerFrame::CreateViewForFrame(aNewFrame, nsnull, PR_FALSE);
   1:   if (!aIsPseudo) {
   1:     nsFrameItems childItems;
   1:     rv = ProcessChildren(aState, aContent, aNewFrame, PR_FALSE, childItems,
   1:                          PR_FALSE);
   1:     if (NS_FAILED(rv)) return rv;
   1:     // if there are any anonymous children for the table, create frames for them
   1:     CreateAnonymousFrames(nsnull, aState, aContent, aNewFrame,
   1:                           PR_FALSE, childItems);
   1: 
   1:     aNewFrame->SetInitialChildList(nsnull, childItems.childList);
   1:     if (aIsPseudoParent) {
   1:       aState.mPseudoFrames.mRowGroup.mChildList.AddChild(aNewFrame);
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1:       
   1: nsresult
   1: nsCSSFrameConstructor::ConstructTableColFrame(nsFrameConstructorState& aState,
   1:                                               nsIContent*              aContent,
   1:                                               nsIFrame*                aParentFrameIn,
   1:                                               nsStyleContext*          aStyleContext,
   1:                                               PRInt32                  aNameSpaceID,
   1:                                               PRBool                   aIsPseudo,
   1:                                               nsFrameItems&            aChildItems,
   1:                                               nsIFrame*&               aNewFrame,
   1:                                               PRBool&                  aIsPseudoParent)
   1: {
   1:   nsresult rv = NS_OK;
   1:   if (!aParentFrameIn || !aStyleContext) return rv;
   1: 
   1:   nsIFrame* parentFrame = aParentFrameIn;
   1:   aIsPseudoParent = PR_FALSE;
   1:   if (!aIsPseudo) {
   1:     // this frame may have a pseudo parent
   1:     GetParentFrame(aNameSpaceID, *aParentFrameIn,
   1:                    nsGkAtoms::tableColFrame, aState, parentFrame,
   1:                    aIsPseudoParent);
   1:     if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aChildItems);
   1:     }
   1:   }
   1: 
   1:   aNewFrame = NS_NewTableColFrame(mPresShell, aStyleContext);
   1:   if (NS_UNLIKELY(!aNewFrame)) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1:   InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewFrame);
   1: 
   1:   // construct additional col frames if the col frame has a span > 1
   1:   PRInt32 span = 1;
   1:   nsCOMPtr<nsIDOMHTMLTableColElement> cgContent(do_QueryInterface(aContent));
   1:   if (cgContent) { 
   1:     cgContent->GetSpan(&span);
   1:     nsIFrame* lastCol = aNewFrame;
   1:     nsStyleContext* styleContext = nsnull;
   1:     for (PRInt32 spanX = 1; spanX < span; spanX++) {
   1:       // The same content node should always resolve to the same style context.
   1:       if (1 == spanX)
   1:         styleContext = aNewFrame->GetStyleContext();
   1:       nsIFrame* newCol = NS_NewTableColFrame(mPresShell, styleContext);
   1:       if (NS_UNLIKELY(!newCol)) {
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:       }
4192:       InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, newCol, PR_FALSE);
   1:       ((nsTableColFrame*)newCol)->SetColType(eColAnonymousCol);
   1:       lastCol->SetNextSibling(newCol);
   1:       lastCol = newCol;
   1:     }
   1:   }
   1: 
   1:   if (!aIsPseudo && aIsPseudoParent) {
   1:       aState.mPseudoFrames.mColGroup.mChildList.AddChild(aNewFrame);
   1:   }
   1:   
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructTableCellFrame(nsFrameConstructorState& aState,
   1:                                                nsIContent*              aContent,
   1:                                                nsIFrame*                aParentFrameIn,
   1:                                                nsStyleContext*          aStyleContext,
   1:                                                PRInt32                  aNameSpaceID,
   1:                                                PRBool                   aIsPseudo,
   1:                                                nsFrameItems&            aChildItems,
   1:                                                nsIFrame*&               aNewCellOuterFrame,
   1:                                                nsIFrame*&               aNewCellInnerFrame,
   1:                                                PRBool&                  aIsPseudoParent)
   1: {
   1:   nsresult rv = NS_OK;
   1:   if (!aParentFrameIn) return rv;
   1: 
   1:   nsIFrame* parentFrame = aParentFrameIn;
   1:   aIsPseudoParent = PR_FALSE;
   1:   if (!aIsPseudo) {
   1:     // this frame may have a pseudo parent
   1:     // use nsGkAtoms::tableCellFrame which will match if it is really nsGkAtoms::bcTableCellFrame
   1:     GetParentFrame(aNameSpaceID, *aParentFrameIn,
   1:                    nsGkAtoms::tableCellFrame, aState, parentFrame,
   1:                    aIsPseudoParent);
   1:     if (!aIsPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aChildItems);
   1:     }
   1:     if (!aIsPseudo && aIsPseudoParent && aState.mPseudoFrames.mCellOuter.mFrame) {
   1:       ProcessPseudoFrames(aState, nsGkAtoms::tableCellFrame);
   1:     }
   1:   }
   1: #ifdef MOZ_MATHML
   1:   // <mtable> is border separate in mathml.css and the MathML code doesn't implement
   1:   // border collapse. For those users who style <mtable> with border collapse,
   1:   // give them the default non-MathML table frames that understand border collpase.
   1:   // This won't break us because MathML table frames are all subclasses of the default
   1:   // table code, and so we can freely mix <mtable> with <mtr> or <tr>, <mtd> or <td>.
   1:   // What will happen is just that non-MathML frames won't understand MathML attributes
   1:   // and will therefore miss the special handling that the MathML code does.
   1:   if (kNameSpaceID_MathML == aNameSpaceID && !IsBorderCollapse(parentFrame))
   1:     aNewCellOuterFrame = NS_NewMathMLmtdFrame(mPresShell, aStyleContext);
   1:   else
   1: #endif
   1:     aNewCellOuterFrame = NS_NewTableCellFrame(mPresShell, aStyleContext,
   1:                                               IsBorderCollapse(parentFrame));
   1: 
   1:   if (NS_UNLIKELY(!aNewCellOuterFrame)) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   // Initialize the table cell frame
   1:   InitAndRestoreFrame(aState, aContent, parentFrame, nsnull, aNewCellOuterFrame);
   1:   // XXXbz should we be passing in a non-null aContentParentFrame?
   1:   nsHTMLContainerFrame::CreateViewForFrame(aNewCellOuterFrame, nsnull, PR_FALSE);
   1:   
   1:   // Resolve pseudo style and initialize the body cell frame
   1:   nsRefPtr<nsStyleContext> innerPseudoStyle;
   1:   innerPseudoStyle = mPresShell->StyleSet()->
   1:     ResolvePseudoStyleFor(aContent,
   1:                           nsCSSAnonBoxes::cellContent, aStyleContext);
   1: 
   1:   // Create a block frame that will format the cell's content
   1: #ifdef MOZ_MATHML
   1:   if (kNameSpaceID_MathML == aNameSpaceID)
   1:     aNewCellInnerFrame = NS_NewMathMLmtdInnerFrame(mPresShell, innerPseudoStyle);
   1:   else
   1: #endif
   1:     aNewCellInnerFrame = NS_NewTableCellInnerFrame(mPresShell, innerPseudoStyle);
   1: 
   1: 
   1:   if (NS_UNLIKELY(!aNewCellInnerFrame)) {
   1:     aNewCellOuterFrame->Destroy();
   1:     aNewCellOuterFrame = nsnull;
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   InitAndRestoreFrame(aState, aContent, aNewCellOuterFrame, nsnull, aNewCellInnerFrame);
   1: 
   1:   if (!aIsPseudo) {
   1:     PRBool haveFirstLetterStyle, haveFirstLineStyle;
1254:     ShouldHaveSpecialBlockStyle(aContent, aStyleContext,
   1:                                 &haveFirstLetterStyle, &haveFirstLineStyle);
   1: 
   1:     // The block frame is a float container
   1:     nsFrameConstructorSaveState floatSaveState;
   1:     aState.PushFloatContainingBlock(aNewCellInnerFrame, floatSaveState,
   1:                                     haveFirstLetterStyle, haveFirstLineStyle);
   1: 
   1:     // Process the child content
   1:     nsFrameItems childItems;
   1:     rv = ProcessChildren(aState, aContent, aNewCellInnerFrame, 
   1:                          PR_TRUE, childItems, PR_TRUE);
   1: 
   1:     if (NS_FAILED(rv)) {
   1:       // Clean up
   1:       // XXXbz kids of this stuff need to be cleaned up too!
   1:       aNewCellInnerFrame->Destroy();
   1:       aNewCellInnerFrame = nsnull;
   1:       aNewCellOuterFrame->Destroy();
   1:       aNewCellOuterFrame = nsnull;
   1:       return rv;
   1:     }
   1: 
   1:     aNewCellInnerFrame->SetInitialChildList(nsnull, childItems.childList);
   1:     aNewCellOuterFrame->SetInitialChildList(nsnull, aNewCellInnerFrame);
   1:     if (aIsPseudoParent) {
   1:       aState.mPseudoFrames.mRow.mChildList.AddChild(aNewCellOuterFrame);
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: static PRBool 
   1: NeedFrameFor(nsIFrame*   aParentFrame,
   1:              nsIContent* aChildContent) 
   1: {
   1:   // don't create a whitespace frame if aParentFrame doesn't want it
   1:   if ((NS_FRAME_EXCLUDE_IGNORABLE_WHITESPACE & aParentFrame->GetStateBits())
   1:       && TextIsOnlyWhitespace(aChildContent)) {
   1:     return PR_FALSE;
   1:   }
   1:   return PR_TRUE;
   1: }
   1: 
   1: const nsStyleDisplay* 
   1: nsCSSFrameConstructor::GetDisplay(nsIFrame* aFrame)
   1: {
   1:   if (nsnull == aFrame) {
   1:     return nsnull;
   1:   }
   1:   return aFrame->GetStyleContext()->GetStyleDisplay();
   1: }
   1: 
   1: /***********************************************
   1:  * END TABLE SECTION
   1:  ***********************************************/
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructDocElementTableFrame(nsIContent*     aDocElement,
   1:                                                      nsIFrame*       aParentFrame,
   1:                                                      nsIFrame**      aNewTableFrame,
   1:                                                      nsFrameConstructorState& aState)
   1: {
   1:   nsFrameItems    frameItems;
   1: 
   1:   // XXXbz this is wrong.  We should at least be setting the fixed container in
   1:   // the framestate here.  Better yet, we should pass through aState
   1:   // unmodified.  Can't do that, though, because then a fixed or absolute
   1:   // positioned root table with auto offsets would look for a block to compute
   1:   // its hypothetical box and crash.  So we just disable fixed positioning
   1:   // altogether in documents where the root is a table.  Oh, well.
   1:   nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull,
   1:                                 aState.mFrameState);
   1:   ConstructFrame(state, aDocElement, aParentFrame, frameItems);
   1:   *aNewTableFrame = frameItems.childList;
   1:   if (!*aNewTableFrame) {
   1:     NS_WARNING("cannot get table contentFrame");
   1:     // XXXbz maybe better to return the error from ConstructFrame?
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: static PRBool CheckOverflow(nsPresContext* aPresContext,
   1:                             const nsStyleDisplay* aDisplay)
   1: {
   1:   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
   1:     return PR_FALSE;
   1: 
   1:   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_CLIP)
   1:     aPresContext->SetViewportOverflowOverride(NS_STYLE_OVERFLOW_HIDDEN,
   1:                                               NS_STYLE_OVERFLOW_HIDDEN);
   1:   else
   1:     aPresContext->SetViewportOverflowOverride(aDisplay->mOverflowX,
   1:                                               aDisplay->mOverflowY);
   1:   return PR_TRUE;
   1: }
   1: 
   1: /**
   1:  * This checks the root element and the HTML BODY, if any, for an "overflow" property
   1:  * that should be applied to the viewport. If one is found then we return the
   1:  * element that we took the overflow from (which should then be treated as
   1:  * "overflow:visible"), and we store the overflow style in the prescontext.
   1:  * @return if scroll was propagated from some content node, the content node it
   1:  *         was propagated from.
   1:  */
   1: nsIContent*
   1: nsCSSFrameConstructor::PropagateScrollToViewport()
   1: {
   1:   // Set default
   1:   nsPresContext* presContext = mPresShell->GetPresContext();
   1:   presContext->SetViewportOverflowOverride(NS_STYLE_OVERFLOW_AUTO,
   1:                                            NS_STYLE_OVERFLOW_AUTO);
   1: 
   1:   // We never mess with the viewport scroll state
   1:   // when printing or in print preview
   1:   if (presContext->IsPaginated()) {
   1:     return nsnull;
   1:   }
   1: 
   1:   nsIContent* docElement = mDocument->GetRootContent();
   1: 
   1:   // Check the style on the document root element
   1:   nsStyleSet *styleSet = mPresShell->StyleSet();
   1:   nsRefPtr<nsStyleContext> rootStyle;
   1:   rootStyle = styleSet->ResolveStyleFor(docElement, nsnull);
   1:   if (!rootStyle) {
   1:     return nsnull;
   1:   }
   1:   if (CheckOverflow(presContext, rootStyle->GetStyleDisplay())) {
   1:     // tell caller we stole the overflow style from the root element
   1:     return docElement;
   1:   }
   1:   
   1:   // Don't look in the BODY for non-HTML documents or HTML documents
   1:   // with non-HTML roots
   1:   // XXX this should be earlier; we shouldn't even look at the document root
   1:   // for non-HTML documents. Fix this once we support explicit CSS styling
   1:   // of the viewport
   1:   // XXX what about XHTML?
   1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(mDocument));
   1:   if (!htmlDoc || !docElement->IsNodeOfType(nsINode::eHTML)) {
   1:     return nsnull;
   1:   }
   1:   
   1:   nsCOMPtr<nsIDOMHTMLElement> body;
   1:   htmlDoc->GetBody(getter_AddRefs(body));
   1:   nsCOMPtr<nsIContent> bodyElement = do_QueryInterface(body);
   1:   
   1:   if (!bodyElement ||
   1:       !bodyElement->NodeInfo()->Equals(nsGkAtoms::body)) {
   1:     // The body is not a <body> tag, it's a <frameset>.
   1:     return nsnull;
   1:   }
   1: 
   1:   nsRefPtr<nsStyleContext> bodyStyle;
   1:   bodyStyle = styleSet->ResolveStyleFor(bodyElement, rootStyle);
   1:   if (!bodyStyle) {
   1:     return nsnull;
   1:   }
   1: 
   1:   if (CheckOverflow(presContext, bodyStyle->GetStyleDisplay())) {
   1:     // tell caller we stole the overflow style from the body element
   1:     return bodyElement;
   1:   }
   1: 
   1:   return nsnull;
   1: }
   1: 
   1: /**
   1:  * New one
   1:  */
   1: nsresult
   1: nsCSSFrameConstructor::ConstructDocElementFrame(nsFrameConstructorState& aState,
   1:                                                 nsIContent*              aDocElement,
   1:                                                 nsIFrame*                aParentFrame,
   1:                                                 nsIFrame**               aNewFrame)
   1: {
   1:     // how the root frame hierarchy should look
   1: 
   1:     /*
   1: 
   1: ---------------No Scrollbars------
   1: 
   1: 
   1:      AreaFrame or BoxFrame (InitialContainingBlock)
   1:   
   1: 
   1: 
   1: ---------------Gfx Scrollbars ------
   1: 
   1: 
   1:      ScrollFrame
   1: 
   1:          ^
   1:          |
   1:          |
   1:      AreaFrame or BoxFrame (InitialContainingBlock)
   1:           
   1: */    
   1: 
   1:   *aNewFrame = nsnull;
   1: 
   1:   if (!mTempFrameTreeState)
   1:     aState.mPresShell->CaptureHistoryState(getter_AddRefs(mTempFrameTreeState));
   1: 
   1:   // ----- reattach gfx scrollbars ------
   1:   // Gfx scrollframes were created in the root frame but the primary frame map may have been destroyed if a 
   1:   // new style sheet was loaded so lets reattach the frames to their content.
   1:   // XXX this seems truly bogus, we wipe out mGfxScrollFrame below
   1:   if (mGfxScrollFrame) {
   1:     nsIFrame* gfxScrollbarFrame1 = mGfxScrollFrame->GetFirstChild(nsnull);
   1:     if (gfxScrollbarFrame1) {
   1:       // XXX This works, but why?
   1:       aState.mFrameManager->
   1:         SetPrimaryFrameFor(gfxScrollbarFrame1->GetContent(), gfxScrollbarFrame1);
   1: 
   1:       nsIFrame* gfxScrollbarFrame2 = gfxScrollbarFrame1->GetNextSibling();
   1:       if (gfxScrollbarFrame2) {
   1:         // XXX This works, but why?
   1:         aState.mFrameManager->
   1:           SetPrimaryFrameFor(gfxScrollbarFrame2->GetContent(), gfxScrollbarFrame2);
   1:       }
   1:     }
   1:   }
   1: 
   1:   // --------- CREATE AREA OR BOX FRAME -------
   1:   nsRefPtr<nsStyleContext> styleContext;
   1:   styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
   1:                                                          nsnull);
   1: 
   1:   const nsStyleDisplay* display = styleContext->GetStyleDisplay();
   1: 
   1:   // Ensure that our XBL bindings are installed.
   1:   if (display->mBinding) {
   1:     // Get the XBL loader.
   1:     nsresult rv;
   1:     PRBool resolveStyle;
   1:     
   1:     nsIXBLService * xblService = GetXBLService();
   1:     if (!xblService)
   1:       return NS_ERROR_FAILURE;
   1: 
   1:     nsRefPtr<nsXBLBinding> binding;
3645:     rv = xblService->LoadBindings(aDocElement, display->mBinding->mURI,
3645:                                   display->mBinding->mOriginPrincipal,
3645:                                   PR_FALSE, getter_AddRefs(binding),
3645:                                   &resolveStyle);
   1:     if (NS_FAILED(rv))
   1:       return NS_OK; // Binding will load asynchronously.
   1: 
   1:     if (binding) {
   1:       mDocument->BindingManager()->AddToAttachedQueue(binding);
   1:     }
   1: 
   1:     if (resolveStyle) {
   1:       styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
   1:                                                              nsnull);
   1:       display = styleContext->GetStyleDisplay();
   1:     }
   1:   }
   1: 
   1:   // --------- IF SCROLLABLE WRAP IN SCROLLFRAME --------
   1: 
   1: #ifdef DEBUG
   1:   PRBool propagatedScrollToViewport =
   1:     PropagateScrollToViewport() == aDocElement;
   1: 
   1:   NS_ASSERTION(!display->IsScrollableOverflow() || 
   1:                aState.mPresContext->IsPaginated() ||
   1:                propagatedScrollToViewport,
   1:                "Scrollbars should have been propagated to the viewport");
   1: #endif
   1: 
   1:   nsIFrame* contentFrame = nsnull;
   1:   PRBool isBlockFrame = PR_FALSE;
   1:   nsresult rv;
   1: 
   1:   // The rules from CSS 2.1, section 9.2.4, have already been applied
   1:   // by the style system, so we can assume that display->mDisplay is
   1:   // either NONE, BLOCK, or TABLE.
   1: 
   1:   PRBool docElemIsTable = (display->mDisplay == NS_STYLE_DISPLAY_TABLE) &&
   1:                           !IsSpecialContent(aDocElement, aDocElement->Tag(),
   1:                                             aDocElement->GetNameSpaceID(),
   1:                                             styleContext);
   1: 
   1:   if (docElemIsTable) {
   1:     // if the document is a table then just populate it.
   1:     rv = ConstructDocElementTableFrame(aDocElement, aParentFrame, &contentFrame,
   1:                                        aState);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1:     styleContext = contentFrame->GetStyleContext();
   1:   } else {
   1:     // otherwise build a box or a block
   1: #ifdef MOZ_XUL
   1:     if (aDocElement->IsNodeOfType(nsINode::eXUL)) {
   1:       contentFrame = NS_NewDocElementBoxFrame(mPresShell, styleContext);
   1:     }
   1:     else
   1: #endif 
   1: #ifdef MOZ_SVG
3026:     if (aDocElement->GetNameSpaceID() == kNameSpaceID_SVG) {
3026:       if (aDocElement->Tag() == nsGkAtoms::svg && NS_SVGEnabled()) {
   1:         contentFrame = NS_NewSVGOuterSVGFrame(mPresShell, aDocElement, styleContext);
3026:       } else {
3026:         return NS_ERROR_FAILURE;
3026:       }
   1:     }
   1:     else 
   1: #endif
   1:     {
   1:       contentFrame = NS_NewDocumentElementFrame(mPresShell, styleContext);
   1:       isBlockFrame = PR_TRUE;
   1:     }
   1:     
   1:     if (NS_UNLIKELY(!contentFrame)) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1: 
   1:     // initialize the child
   1:     InitAndRestoreFrame(aState, aDocElement, aParentFrame, nsnull, contentFrame);
   1:   }
   1: 
   1:   // set the primary frame
   1:   aState.mFrameManager->SetPrimaryFrameFor(aDocElement, contentFrame);
   1: 
   1:   *aNewFrame = contentFrame;
   1: 
   1:   mInitialContainingBlock = contentFrame;
   1:   mInitialContainingBlockIsAbsPosContainer = PR_FALSE;
   1: 
   1:   // if it was a table then we don't need to process our children.
   1:   if (!docElemIsTable) {
   1:     // Process the child content
   1:     nsFrameConstructorSaveState absoluteSaveState;
   1:     nsFrameConstructorSaveState floatSaveState;
   1:     nsFrameItems                childItems;
   1: 
   1:     if (isBlockFrame) {
   1:       PRBool haveFirstLetterStyle, haveFirstLineStyle;
1254:       ShouldHaveSpecialBlockStyle(aDocElement, styleContext,
   1:                                   &haveFirstLetterStyle, &haveFirstLineStyle);
   1:       mInitialContainingBlockIsAbsPosContainer = PR_TRUE;
   1:       aState.PushAbsoluteContainingBlock(contentFrame, absoluteSaveState);
   1:       aState.PushFloatContainingBlock(contentFrame, floatSaveState,
   1:                                       haveFirstLetterStyle,
   1:                                       haveFirstLineStyle);
   1:     }
   1: 
   1:     // Create any anonymous frames the doc element frame requires
   1:     // This must happen before ProcessChildren to ensure that popups are
   1:     // never constructed before the popupset.
   1:     CreateAnonymousFrames(nsnull, aState, aDocElement, contentFrame,
   1:                           PR_FALSE, childItems, PR_TRUE);
   1:     ProcessChildren(aState, aDocElement, contentFrame, PR_TRUE, childItems,
   1:                     isBlockFrame);
   1: 
   1:     // Set the initial child lists
   1:     contentFrame->SetInitialChildList(nsnull, childItems.childList);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructRootFrame(nsIContent*     aDocElement,
   1:                                           nsIFrame**      aNewFrame)
   1: {
   1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   1:   NS_PRECONDITION(aNewFrame, "null out param");
   1:   
   1:   // how the root frame hierarchy should look
   1: 
   1:     /*
   1: 
   1: ---------------No Scrollbars------
   1: 
   1: 
   1: 
   1:      ViewPortFrame (FixedContainingBlock) <---- RootView
   1: 
   1:          ^
   1:          |
   1:      RootFrame(DocElementContainingBlock)
   1:   
   1: 
   1: 
   1: ---------------Gfx Scrollbars ------
   1: 
   1: 
   1:      ViewPortFrame (FixedContainingBlock) <---- RootView
   1: 
   1:          ^
   1:          |
   1:      ScrollFrame
   1: 
   1:          ^
   1:          |
   1:      RootFrame(DocElementContainingBlock)
   1:           
   1: */    
   1: 
   1:   // Set up our style rule observer.
   1:   {
   1:     mPresShell->StyleSet()->SetBindingManager(mDocument->BindingManager());
   1:   }
   1: 
   1:   // --------- BUILD VIEWPORT -----------
   1:   nsIFrame*                 viewportFrame = nsnull;
   1:   nsRefPtr<nsStyleContext> viewportPseudoStyle;
   1:   nsStyleSet *styleSet = mPresShell->StyleSet();
   1: 
   1:   viewportPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
   1:                                                         nsCSSAnonBoxes::viewport,
   1:                                                         nsnull);
   1: 
   1:   viewportFrame = NS_NewViewportFrame(mPresShell, viewportPseudoStyle);
   1: 
   1:   nsPresContext* presContext = mPresShell->GetPresContext();
   1: 
   1:   // XXXbz do we _have_ to pass a null content pointer to that frame?
   1:   // Would it really kill us to pass in the root element or something?
   1:   // What would that break?
   1:   viewportFrame->Init(nsnull, nsnull, nsnull);
   1: 
   1:   // Bind the viewport frame to the root view
   1:   nsIViewManager* viewManager = mPresShell->GetViewManager();
   1:   nsIView*        rootView;
   1: 
   1:   viewManager->GetRootView(rootView);
   1:   viewportFrame->SetView(rootView);
   1: 
   1:   nsContainerFrame::SyncFrameViewProperties(presContext, viewportFrame,
   1:                                             viewportPseudoStyle, rootView);
   1: 
   1:   // The viewport is the containing block for 'fixed' elements
   1:   mFixedContainingBlock = viewportFrame;
   1: 
   1:   // --------- CREATE ROOT FRAME -------
   1: 
   1: 
   1:   // Create the root frame. The document element's frame is a child of the
   1:   // root frame.
   1:   //
   1:   // The root frame serves two purposes:
   1:   // - reserves space for any margins needed for the document element's frame
   1:   // - renders the document element's background. This ensures the background covers
   1:   //   the entire canvas as specified by the CSS2 spec
   1: 
   1:   PRBool isPaginated = presContext->IsRootPaginatedDocument();
   1: 
   1:   nsIFrame* rootFrame = nsnull;
   1:   nsIAtom* rootPseudo;
   1:         
   1:   if (!isPaginated) {
   1: #ifdef MOZ_XUL
   1:     if (aDocElement->IsNodeOfType(nsINode::eXUL))
   1:     {
   1:       // pass a temporary stylecontext, the correct one will be set later
   1:       rootFrame = NS_NewRootBoxFrame(mPresShell, viewportPseudoStyle);
   1:     } else
   1: #endif
   1:     {
   1:       // pass a temporary stylecontext, the correct one will be set later
   1:       rootFrame = NS_NewCanvasFrame(mPresShell, viewportPseudoStyle);
   1:     }
   1: 
   1:     rootPseudo = nsCSSAnonBoxes::canvas;
   1:     mDocElementContainingBlock = rootFrame;
   1:   } else {
   1:     // Create a page sequence frame
   1:     rootFrame = NS_NewSimplePageSequenceFrame(mPresShell, viewportPseudoStyle);
   1:     mPageSequenceFrame = rootFrame;
   1:     rootPseudo = nsCSSAnonBoxes::pageSequence;
   1:   }
   1: 
   1: 
   1:   // --------- IF SCROLLABLE WRAP IN SCROLLFRAME --------
   1: 
   1:   // If the device supports scrolling (e.g., in galley mode on the screen and
   1:   // for print-preview, but not when printing), then create a scroll frame that
   1:   // will act as the scrolling mechanism for the viewport. 
   1:   // XXX Do we even need a viewport when printing to a printer?
   1: 
   1:   // As long as the webshell doesn't prohibit it, and the device supports
   1:   // it, create a scroll frame that will act as the scolling mechanism for
   1:   // the viewport.
   1:   //
   1:   // Threre are three possible values stored in the docshell:
   1:   //  1) nsIScrollable::Scrollbar_Never = no scrollbars
   1:   //  2) nsIScrollable::Scrollbar_Auto = scrollbars appear if needed
   1:   //  3) nsIScrollable::Scrollbar_Always = scrollbars always
   1:   // Only need to create a scroll frame/view for cases 2 and 3.
   1: 
   1:   PRBool isHTML = aDocElement->IsNodeOfType(nsINode::eHTML);
   1:   PRBool isXUL = PR_FALSE;
   1: 
   1:   if (!isHTML) {
   1:     isXUL = aDocElement->IsNodeOfType(nsINode::eXUL);
   1:   }
   1: 
   1:   // Never create scrollbars for XUL documents
   1:   PRBool isScrollable = !isXUL;
   1: 
   1:   // Never create scrollbars for frameset documents.
   1:   if (isHTML) {
   1:     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
   1:     if (htmlDoc && htmlDoc->GetIsFrameset())
   1:       isScrollable = PR_FALSE;
   1:   }
   1: 
   1:   if (isPaginated) {
   1:     isScrollable = presContext->HasPaginatedScrolling();
   1:   }
   1: 
   1:   // We no longer need to do overflow propagation here. It's taken care of
   1:   // when we construct frames for the element whose overflow might be
   1:   // propagated
   1:   NS_ASSERTION(!isScrollable || !isXUL,
   1:                "XUL documents should never be scrollable - see above");
   1: 
   1:   nsIFrame* newFrame = rootFrame;
   1:   nsRefPtr<nsStyleContext> rootPseudoStyle;
   1:   // we must create a state because if the scrollbars are GFX it needs the 
   1:   // state to build the scrollbar frames.
   1:   nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull);
   1: 
   1:   nsIFrame* parentFrame = viewportFrame;
   1: 
   1:   // If paginated, make sure we don't put scrollbars in
   1:   if (!isScrollable) {
   1:     rootPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
   1:                                                       rootPseudo,
   1:                                                       viewportPseudoStyle);
   1:   } else {
   1:       if (rootPseudo == nsCSSAnonBoxes::canvas) {
   1:         rootPseudo = nsCSSAnonBoxes::scrolledCanvas;
   1:       } else {
   1:         NS_ASSERTION(rootPseudo == nsCSSAnonBoxes::pageSequence,
   1:                      "Unknown root pseudo");
   1:         rootPseudo = nsCSSAnonBoxes::scrolledPageSequence;
   1:       }
   1: 
   1:       // Build the frame. We give it the content we are wrapping which is the document,
   1:       // the root frame, the parent view port frame, and we should get back the new
   1:       // frame and the scrollable view if one was created.
   1: 
   1:       // resolve a context for the scrollframe
   1:       nsRefPtr<nsStyleContext>  styleContext;
   1:       styleContext = styleSet->ResolvePseudoStyleFor(nsnull,
   1:                                                      nsCSSAnonBoxes::viewportScroll,
   1:                                                      viewportPseudoStyle);
   1: 
   1:       // Note that the viewport scrollframe is always built with
   1:       // overflow:auto style. This forces the scroll frame to create
   1:       // anonymous content for both scrollbars. This is necessary even
   1:       // if the HTML or BODY elements are overriding the viewport
   1:       // scroll style to 'hidden' --- dynamic style changes might put
   1:       // scrollbars back on the viewport and we don't want to have to
   1:       // reframe the viewport to create the scrollbar content.
   1:       newFrame = nsnull;
   1:       rootPseudoStyle = BeginBuildingScrollFrame( state,
   1:                                                   aDocElement,
   1:                                                   styleContext,
   1:                                                   viewportFrame,
   1:                                                   nsnull,
   1:                                                   rootPseudo,
   1:                                                   PR_TRUE,
   1:                                                   newFrame);
   1: 
   1:       nsIScrollableFrame* scrollable;
   1:       CallQueryInterface(newFrame, &scrollable);
   1:       NS_ENSURE_TRUE(scrollable, NS_ERROR_FAILURE);
   1: 
   1:       nsIScrollableView* scrollableView = scrollable->GetScrollableView();
   1:       NS_ENSURE_TRUE(scrollableView, NS_ERROR_FAILURE);
   1: 
   1:       viewManager->SetRootScrollableView(scrollableView);
   1:       parentFrame = newFrame;
   1: 
   1:       mGfxScrollFrame = newFrame;
   1:   }
   1:   
   1:   rootFrame->SetStyleContextWithoutNotification(rootPseudoStyle);
   1:   rootFrame->Init(aDocElement, parentFrame, nsnull);
   1:   
   1:   if (isScrollable) {
   1:     FinishBuildingScrollFrame(parentFrame, rootFrame);
   1:   }
   1:   
   1:   if (isPaginated) { // paginated
   1:     // Create the first page
   1:     // Set the initial child lists
   1:     nsIFrame *pageFrame, *pageContentFrame;
   1:     ConstructPageFrame(mPresShell, presContext, rootFrame, nsnull,
   1:                        pageFrame, pageContentFrame);
   1:     rootFrame->SetInitialChildList(nsnull, pageFrame);
   1: 
   1:     // The eventual parent of the document element frame.
   1:     // XXX should this be set for every new page (in ConstructPageFrame)?
   1:     mDocElementContainingBlock = pageContentFrame;
   1:   }
   1: 
   1:   viewportFrame->SetInitialChildList(nsnull, newFrame);
   1:   
   1:   *aNewFrame = viewportFrame;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructPageFrame(nsIPresShell*   aPresShell,
   1:                                           nsPresContext* aPresContext,
   1:                                           nsIFrame*       aParentFrame,
   1:                                           nsIFrame*       aPrevPageFrame,
   1:                                           nsIFrame*&      aPageFrame,
   1:                                           nsIFrame*&      aPageContentFrame)
   1: {
   1:   nsStyleContext* parentStyleContext = aParentFrame->GetStyleContext();
   1:   nsStyleSet *styleSet = aPresShell->StyleSet();
   1: 
   1:   nsRefPtr<nsStyleContext> pagePseudoStyle;
   1:   pagePseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
   1:                                                     nsCSSAnonBoxes::page,
   1:                                                     parentStyleContext);
   1: 
   1:   aPageFrame = NS_NewPageFrame(aPresShell, pagePseudoStyle);
   1:   if (NS_UNLIKELY(!aPageFrame))
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:   // Initialize the page frame and force it to have a view. This makes printing of
   1:   // the pages easier and faster.
   1:   aPageFrame->Init(nsnull, aParentFrame, aPrevPageFrame);
   1: 
   1:   nsRefPtr<nsStyleContext> pageContentPseudoStyle;
   1:   pageContentPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
   1:                                                            nsCSSAnonBoxes::pageContent,
   1:                                                            pagePseudoStyle);
   1: 
   1:   aPageContentFrame = NS_NewPageContentFrame(aPresShell, pageContentPseudoStyle);
   1:   if (NS_UNLIKELY(!aPageContentFrame))
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:   // Initialize the page content frame and force it to have a view. Also make it the
   1:   // containing block for fixed elements which are repeated on every page.
4006:   nsIFrame* prevPageContentFrame = nsnull;
4006:   if (aPrevPageFrame) {
4006:     prevPageContentFrame = aPrevPageFrame->GetFirstChild(nsnull);
4006:     NS_ASSERTION(prevPageContentFrame, "missing page content frame");
4006:   }
4006:   aPageContentFrame->Init(nsnull, aPageFrame, prevPageContentFrame);
   1:   mFixedContainingBlock = aPageContentFrame;
   1: 
   1:   aPageFrame->SetInitialChildList(nsnull, aPageContentFrame);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /* static */
   1: nsresult
   1: nsCSSFrameConstructor::CreatePlaceholderFrameFor(nsIPresShell*    aPresShell, 
   1:                                                  nsPresContext*  aPresContext,
   1:                                                  nsFrameManager*  aFrameManager,
   1:                                                  nsIContent*      aContent,
   1:                                                  nsIFrame*        aFrame,
   1:                                                  nsStyleContext*  aStyleContext,
   1:                                                  nsIFrame*        aParentFrame,
   1:                                                  nsIFrame**       aPlaceholderFrame)
   1: {
   1:   nsRefPtr<nsStyleContext> placeholderStyle = aPresShell->StyleSet()->
   1:     ResolveStyleForNonElement(aStyleContext->GetParent());
   1:   
   1:   // The placeholder frame gets a pseudo style context
   1:   nsPlaceholderFrame* placeholderFrame =
   1:     (nsPlaceholderFrame*)NS_NewPlaceholderFrame(aPresShell, placeholderStyle);
   1: 
   1:   if (placeholderFrame) {
   1:     placeholderFrame->Init(aContent, aParentFrame, nsnull);
   1:   
   1:     // The placeholder frame has a pointer back to the out-of-flow frame
   1:     placeholderFrame->SetOutOfFlowFrame(aFrame);
   1:   
   1:     aFrame->AddStateBits(NS_FRAME_OUT_OF_FLOW);
   1: 
   1:     // Add mapping from absolutely positioned frame to its placeholder frame
   1:     aFrameManager->RegisterPlaceholderFrame(placeholderFrame);
   1: 
3233:     *aPlaceholderFrame = static_cast<nsIFrame*>(placeholderFrame);
   1:     
   1:     return NS_OK;
   1:   }
   1:   else {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructRadioControlFrame(nsIFrame**      aNewFrame,
   1:                                                   nsIContent*     aContent,
   1:                                                   nsStyleContext* aStyleContext)
   1: {
   1:   *aNewFrame = NS_NewGfxRadioControlFrame(mPresShell, aStyleContext);
   1:   if (NS_UNLIKELY(!*aNewFrame)) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   nsRefPtr<nsStyleContext> radioStyle;
   1:   radioStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
   1:                                                              nsCSSAnonBoxes::radio,
   1:                                                              aStyleContext);
   1:   nsIRadioControlFrame* radio = nsnull;
   1:   if (*aNewFrame && NS_SUCCEEDED(CallQueryInterface(*aNewFrame, &radio))) {
   1:     radio->SetRadioButtonFaceStyleContext(radioStyle);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructCheckboxControlFrame(nsIFrame**      aNewFrame,
   1:                                                      nsIContent*     aContent,
   1:                                                      nsStyleContext* aStyleContext)
   1: {
   1:   *aNewFrame = NS_NewGfxCheckboxControlFrame(mPresShell, aStyleContext);
   1:   if (NS_UNLIKELY(!*aNewFrame)) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   nsRefPtr<nsStyleContext> checkboxStyle;
   1:   checkboxStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
   1:                                                                 nsCSSAnonBoxes::check, 
   1:                                                                 aStyleContext);
   1:   nsICheckboxControlFrame* checkbox = nsnull;
   1:   if (*aNewFrame && NS_SUCCEEDED(CallQueryInterface(*aNewFrame, &checkbox))) {
   1:     checkbox->SetCheckboxFaceStyleContext(checkboxStyle);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructButtonFrame(nsFrameConstructorState& aState,
   1:                                             nsIContent*              aContent,
   1:                                             nsIFrame*                aParentFrame,
   1:                                             nsIAtom*                 aTag,
   1:                                             nsStyleContext*          aStyleContext,
   1:                                             nsIFrame**               aNewFrame,
   1:                                             const nsStyleDisplay*    aStyleDisplay,
4461:                                             nsFrameItems&            aFrameItems,
4461:                                             PRBool                   aHasPseudoParent)
4461: {
4461:   if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
4461:     ProcessPseudoFrames(aState, aFrameItems); 
4461:   }      
4461: 
   1:   *aNewFrame = nsnull;
   1:   nsIFrame* buttonFrame = nsnull;
   1:   
   1:   if (nsGkAtoms::button == aTag) {
   1:     buttonFrame = NS_NewHTMLButtonControlFrame(mPresShell, aStyleContext);
   1:   }
   1:   else {
   1:     buttonFrame = NS_NewGfxButtonControlFrame(mPresShell, aStyleContext);
   1:   }
   1:   if (NS_UNLIKELY(!buttonFrame)) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1:   // Initialize the button frame
   1:   nsresult rv = InitAndRestoreFrame(aState, aContent,
   1:                                     aState.GetGeometricParent(aStyleDisplay, aParentFrame),
   1:                                     nsnull, buttonFrame);
   1:   if (NS_FAILED(rv)) {
   1:     buttonFrame->Destroy();
   1:     return rv;
   1:   }
   1:   // See if we need to create a view, e.g. the frame is absolutely positioned
   1:   nsHTMLContainerFrame::CreateViewForFrame(buttonFrame, aParentFrame, PR_FALSE);
   1: 
   1:   
   1:   
   1:   nsRefPtr<nsStyleContext> styleContext;
   1:   styleContext = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
   1:                                                                nsCSSAnonBoxes::buttonContent,
   1:                                                                aStyleContext);
   1:                                                                
   1:   nsIFrame* areaFrame = NS_NewAreaFrame(mPresShell, styleContext,
   1:                                         NS_BLOCK_SPACE_MGR);
   1: 
   1:   if (NS_UNLIKELY(!areaFrame)) {
   1:     buttonFrame->Destroy();
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1:   rv = InitAndRestoreFrame(aState, aContent, buttonFrame, nsnull, areaFrame);
   1:   if (NS_FAILED(rv)) {
   1:     areaFrame->Destroy();
   1:     buttonFrame->Destroy();
   1:     return rv;
   1:   }
   1: 
   1:   rv = aState.AddChild(buttonFrame, aFrameItems, aStyleDisplay, aContent,
   1:                                 aStyleContext, aParentFrame);
   1:   if (NS_FAILED(rv)) {
   1:     areaFrame->Destroy();
   1:     buttonFrame->Destroy();
   1:     return rv;
   1:   }
   1: 
   1:   
   1:   if (!buttonFrame->IsLeaf()) { 
   1:     // input type="button" have only anonymous content
   1:     // The area frame is a float container
   1:     PRBool haveFirstLetterStyle, haveFirstLineStyle;
1254:     ShouldHaveSpecialBlockStyle(aContent, aStyleContext,
   1:                                 &haveFirstLetterStyle, &haveFirstLineStyle);
   1:     nsFrameConstructorSaveState floatSaveState;
   1:     aState.PushFloatContainingBlock(areaFrame, floatSaveState,
   1:                                     haveFirstLetterStyle,
   1:                                     haveFirstLineStyle);
   1: 
   1:     // Process children
   1:     nsFrameConstructorSaveState absoluteSaveState;
   1:     nsFrameItems                childItems;
   1: 
   1:     if (aStyleDisplay->IsPositioned()) {
   1:       // The area frame becomes a container for child frames that are
   1:       // absolutely positioned
   1:       aState.PushAbsoluteContainingBlock(areaFrame, absoluteSaveState);
   1:     }
   1: 
   1:     rv = ProcessChildren(aState, aContent, areaFrame, PR_TRUE, childItems,
2829:                          buttonFrame->GetStyleDisplay()->IsBlockOutside());
   1:     if (NS_FAILED(rv)) return rv;
   1:   
   1:     // Set the areas frame's initial child lists
   1:     areaFrame->SetInitialChildList(nsnull, childItems.childList);
   1:   }
   1: 
   1:   buttonFrame->SetInitialChildList(nsnull, areaFrame);
   1: 
   1:   nsFrameItems  anonymousChildItems;
   1:   // if there are any anonymous children create frames for them
   1:   CreateAnonymousFrames(aTag, aState, aContent, buttonFrame,
   1:                           PR_FALSE, anonymousChildItems);
   1:   if (anonymousChildItems.childList) {
   1:     // the anonymous content is already parented to the area frame
   1:     aState.mFrameManager->AppendFrames(areaFrame, nsnull, anonymousChildItems.childList);
   1:   }
   1: 
   1:   // our new button frame returned is the top frame. 
   1:   *aNewFrame = buttonFrame; 
   1: 
   1:   return NS_OK;  
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructSelectFrame(nsFrameConstructorState& aState,
   1:                                             nsIContent*              aContent,
   1:                                             nsIFrame*                aParentFrame,
   1:                                             nsIAtom*                 aTag,
   1:                                             nsStyleContext*          aStyleContext,
   1:                                             nsIFrame*&               aNewFrame,
   1:                                             const nsStyleDisplay*    aStyleDisplay,
   1:                                             PRBool&                  aFrameHasBeenInitialized,
   1:                                             nsFrameItems&            aFrameItems)
   1: {
   1:   nsresult rv = NS_OK;
   1:   const PRInt32 kNoSizeSpecified = -1;
   1: 
   1:   // Construct a frame-based listbox or combobox
   1:   nsCOMPtr<nsIDOMHTMLSelectElement> sel(do_QueryInterface(aContent));
   1:   PRInt32 size = 1;
   1:   if (sel) {
   1:     sel->GetSize(&size); 
   1:     PRBool multipleSelect = PR_FALSE;
   1:     sel->GetMultiple(&multipleSelect);
   1:      // Construct a combobox if size=1 or no size is specified and its multiple select
   1:     if (((1 == size || 0 == size) || (kNoSizeSpecified  == size)) && (PR_FALSE == multipleSelect)) {
   1:         // Construct a frame-based combo box.
   1:         // The frame-based combo box is built out of three parts. A display area, a button and
   1:         // a dropdown list. The display area and button are created through anonymous content.
   1:         // The drop-down list's frame is created explicitly. The combobox frame shares its content
   1:         // with the drop-down list.
   1:       PRUint32 flags = NS_BLOCK_SPACE_MGR;
   1:       nsIFrame* comboboxFrame = NS_NewComboboxControlFrame(mPresShell, aStyleContext, flags);
   1: 
   1:       // Save the history state so we don't restore during construction
   1:       // since the complete tree is required before we restore.
   1:       nsILayoutHistoryState *historyState = aState.mFrameState;
   1:       aState.mFrameState = nsnull;
   1:       // Initialize the combobox frame
   1:       InitAndRestoreFrame(aState, aContent,
   1:                           aState.GetGeometricParent(aStyleDisplay, aParentFrame),
   1:                           nsnull, comboboxFrame);
   1: 
   1:       nsHTMLContainerFrame::CreateViewForFrame(comboboxFrame, aParentFrame, PR_FALSE);
   1: 
   1:       rv = aState.AddChild(comboboxFrame, aFrameItems, aStyleDisplay,
   1:                            aContent, aStyleContext, aParentFrame);
   1:       if (NS_FAILED(rv)) {
   1:         return rv;
   1:       }
   1:       
   1:       ///////////////////////////////////////////////////////////////////
   1:       // Combobox - Old Native Implementation
   1:       ///////////////////////////////////////////////////////////////////
   1:       nsIComboboxControlFrame* comboBox = nsnull;
   1:       CallQueryInterface(comboboxFrame, &comboBox);
   1:       NS_ASSERTION(comboBox, "NS_NewComboboxControlFrame returned frame that "
   1:                              "doesn't implement nsIComboboxControlFrame");
   1: 
   1:         // Resolve pseudo element style for the dropdown list
   1:       nsRefPtr<nsStyleContext> listStyle;
   1:       listStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
   1:                                                                 nsCSSAnonBoxes::dropDownList, 
   1:                                                                 aStyleContext);
   1: 
   1:         // Create a listbox
   1:       nsIFrame* listFrame = NS_NewListControlFrame(mPresShell, listStyle);
   1: 
   1:         // Notify the listbox that it is being used as a dropdown list.
   1:       nsIListControlFrame * listControlFrame;
   1:       rv = CallQueryInterface(listFrame, &listControlFrame);
   1:       if (NS_SUCCEEDED(rv)) {
   1:         listControlFrame->SetComboboxFrame(comboboxFrame);
   1:       }
   1:          // Notify combobox that it should use the listbox as it's popup
   1:       comboBox->SetDropDown(listFrame);
   1: 
   1:       NS_ASSERTION(!listStyle->GetStyleDisplay()->IsPositioned(),
   1:                    "Ended up with positioned dropdown list somehow.");
   1:       NS_ASSERTION(!listStyle->GetStyleDisplay()->IsFloating(),
   1:                    "Ended up with floating dropdown list somehow.");
   1:       
   1:       // Initialize the scroll frame positioned. Note that it is NOT
   1:       // initialized as absolutely positioned.
   1:       nsIFrame* scrolledFrame = NS_NewSelectsAreaFrame(mPresShell, aStyleContext, flags);
   1: 
   1:       InitializeSelectFrame(aState, listFrame, scrolledFrame, aContent,
   1:                             comboboxFrame, listStyle, PR_TRUE, aFrameItems);
   1: 
   1:         // Set flag so the events go to the listFrame not child frames.
   1:         // XXX: We should replace this with a real widget manager similar
   1:         // to how the nsFormControlFrame works. Re-directing events is a temporary Kludge.
   1:       NS_ASSERTION(listFrame->GetView(), "ListFrame's view is nsnull");
   1:       //listFrame->GetView()->SetViewFlags(NS_VIEW_PUBLIC_FLAG_DONT_CHECK_CHILDREN);
   1: 
   1:       // Create display and button frames from the combobox's anonymous content.
   1:       // The anonymous content is appended to existing anonymous content for this
   1:       // element (the scrollbars).
   1: 
   1:       nsFrameItems childItems;
   1:       CreateAnonymousFrames(nsGkAtoms::combobox, aState, aContent,
   1:                             comboboxFrame, PR_TRUE, childItems);
   1:   
   1:       comboboxFrame->SetInitialChildList(nsnull, childItems.childList);
   1: 
   1:       // Initialize the additional popup child list which contains the
   1:       // dropdown list frame.
   1:       nsFrameItems popupItems;
   1:       popupItems.AddChild(listFrame);
4448:       comboboxFrame->SetInitialChildList(nsGkAtoms::selectPopupList,
   1:                                          popupItems.childList);
   1: 
   1:       aNewFrame = comboboxFrame;
   1:       aFrameHasBeenInitialized = PR_TRUE;
   1:       aState.mFrameState = historyState;
   1:       if (aState.mFrameState && aState.mFrameManager) {
   1:         // Restore frame state for the entire subtree of |comboboxFrame|.
   1:         aState.mFrameManager->RestoreFrameState(comboboxFrame,
   1:                                                 aState.mFrameState);
   1:       }
   1:     } else {
   1:       ///////////////////////////////////////////////////////////////////
   1:       // ListBox - Old Native Implementation
   1:       ///////////////////////////////////////////////////////////////////
   1:       nsIFrame* listFrame = NS_NewListControlFrame(mPresShell, aStyleContext);
   1:       if (listFrame) {
   1:         rv = NS_OK;
   1:       }
   1:       else {
   1:         rv = NS_ERROR_OUT_OF_MEMORY;
   1:       }
   1: 
   1:       nsIFrame* scrolledFrame = NS_NewSelectsAreaFrame(
   1:         mPresShell, aStyleContext, NS_BLOCK_SPACE_MGR);
   1: 
   1:       // ******* this code stolen from Initialze ScrollFrame ********
   1:       // please adjust this code to use BuildScrollFrame.
   1: 
   1:       InitializeSelectFrame(aState, listFrame, scrolledFrame, aContent,
   1:                             aParentFrame, aStyleContext, PR_FALSE, aFrameItems);
   1: 
   1:       aNewFrame = listFrame;
   1: 
   1:       aFrameHasBeenInitialized = PR_TRUE;
   1:     }
   1:   }
   1:   return rv;
   1: 
   1: }
   1: 
   1: /**
   1:  * Used to be InitializeScrollFrame but now it's only used for the select tag
   1:  * But the select tag should really be fixed to use GFX scrollbars that can
   1:  * be create with BuildScrollFrame.
   1:  */
   1: nsresult
   1: nsCSSFrameConstructor::InitializeSelectFrame(nsFrameConstructorState& aState,
   1:                                              nsIFrame*                scrollFrame,
   1:                                              nsIFrame*                scrolledFrame,
   1:                                              nsIContent*              aContent,
   1:                                              nsIFrame*                aParentFrame,
   1:                                              nsStyleContext*          aStyleContext,
   1:                                              PRBool                   aBuildCombobox,
   1:                                              nsFrameItems&            aFrameItems)
   1: {
   1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
   1: 
   1:   // Initialize it
   1:   nsIFrame* geometricParent = aState.GetGeometricParent(display, aParentFrame);
   1:     
   1:   // We don't call InitAndRestoreFrame for scrollFrame because we can only
   1:   // restore the frame state after its parts have been created (in particular,
   1:   // the scrollable view). So we have to split Init and Restore.
   1: 
   1:   // Initialize the frame
   1:   scrollFrame->Init(aContent, geometricParent, nsnull);
   1: 
   1:   if (!aBuildCombobox) {
   1:     nsresult rv = aState.AddChild(scrollFrame, aFrameItems, display,
   1:                                   aContent, aStyleContext, aParentFrame);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1:   }
   1:       
   1:   nsHTMLContainerFrame::CreateViewForFrame(scrollFrame, aParentFrame,
   1:                                            aBuildCombobox);
   1:   if (aBuildCombobox) {
   1:     // Give the drop-down list a popup widget
   1:     nsIView* view = scrollFrame->GetView();
   1:     NS_ASSERTION(view, "We asked for a view but didn't get one");
   1:     if (view) {
   1:       view->GetViewManager()->SetViewFloating(view, PR_TRUE);
   1: 
   1:       nsWidgetInitData widgetData;
   1:       widgetData.mWindowType  = eWindowType_popup;
   1:       widgetData.mBorderStyle = eBorderStyle_default;
   1: 
   1: #if defined(XP_MACOSX) || defined(XP_BEOS) 
   1:       static NS_DEFINE_IID(kCPopUpCID,  NS_POPUP_CID);
   1:       view->CreateWidget(kCPopUpCID, &widgetData, nsnull);
   1: #else
   1:       static NS_DEFINE_IID(kCChildCID, NS_CHILD_CID);
   1:       view->CreateWidget(kCChildCID, &widgetData, nsnull);
   1: #endif
   1:     }
   1:   }
   1: 
   1:   nsStyleContext* scrolledPseudoStyle;
   1:   BuildScrollFrame(aState, aContent, aStyleContext, scrolledFrame,
   1:                    geometricParent, aParentFrame, scrollFrame,
   1:                    scrolledPseudoStyle);
   1: 
   1:   if (aState.mFrameState && aState.mFrameManager) {
   1:     // Restore frame state for the scroll frame
   1:     aState.mFrameManager->RestoreFrameStateFor(scrollFrame, aState.mFrameState);
   1:   }
   1: 
   1:   // The area frame is a float container
   1:   PRBool haveFirstLetterStyle, haveFirstLineStyle;
1254:   ShouldHaveSpecialBlockStyle(aContent, aStyleContext,
   1:                               &haveFirstLetterStyle, &haveFirstLineStyle);
   1:   nsFrameConstructorSaveState floatSaveState;
   1:   aState.PushFloatContainingBlock(scrolledFrame, floatSaveState,
   1:                                   haveFirstLetterStyle, haveFirstLineStyle);
   1: 
   1:   // Process children
   1:   nsFrameConstructorSaveState absoluteSaveState;
   1:   nsFrameItems                childItems;
   1: 
   1:   if (display->IsPositioned()) {
   1:     // The area frame becomes a container for child frames that are
   1:     // absolutely positioned
   1:     aState.PushAbsoluteContainingBlock(scrolledFrame, absoluteSaveState);
   1:   }
   1: 
   1:   ProcessChildren(aState, aContent, scrolledFrame, PR_FALSE,
   1:                   childItems, PR_TRUE);
   1: 
   1:   // Set the scrolled frame's initial child lists
   1:   scrolledFrame->SetInitialChildList(nsnull, childItems.childList);
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructFieldSetFrame(nsFrameConstructorState& aState,
   1:                                               nsIContent*              aContent,
   1:                                               nsIFrame*                aParentFrame,
   1:                                               nsIAtom*                 aTag,
   1:                                               nsStyleContext*          aStyleContext,
   1:                                               nsIFrame*&               aNewFrame,
   1:                                               nsFrameItems&            aFrameItems,
   1:                                               const nsStyleDisplay*    aStyleDisplay,
   1:                                               PRBool&                  aFrameHasBeenInitialized)
   1: {
   1:   nsIFrame* newFrame = NS_NewFieldSetFrame(mPresShell, aStyleContext);
   1:   if (NS_UNLIKELY(!newFrame)) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   // Initialize it
   1:   InitAndRestoreFrame(aState, aContent, 
   1:                       aState.GetGeometricParent(aStyleDisplay, aParentFrame),
   1:                       nsnull, newFrame);
   1: 
   1:   // See if we need to create a view, e.g. the frame is absolutely
   1:   // positioned
   1:   nsHTMLContainerFrame::CreateViewForFrame(newFrame, aParentFrame, PR_FALSE);
   1: 
   1:   // Resolve style and initialize the frame
   1:   nsRefPtr<nsStyleContext> styleContext;
   1:   styleContext = mPresShell->StyleSet()->ResolvePseudoStyleFor(aContent,
   1:                                                                nsCSSAnonBoxes::fieldsetContent,
   1:                                                                aStyleContext);
   1:   
   1:   nsIFrame* areaFrame = NS_NewAreaFrame(mPresShell, styleContext,
   1:                                      NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT);
   1:   InitAndRestoreFrame(aState, aContent, newFrame, nsnull, areaFrame);
   1: 
   1:   nsresult rv = aState.AddChild(newFrame, aFrameItems, aStyleDisplay, aContent,
   1:                                 aStyleContext, aParentFrame);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1:   
   1: 
   1:   // The area frame is a float container
   1:   PRBool haveFirstLetterStyle, haveFirstLineStyle;
1254:   ShouldHaveSpecialBlockStyle(aContent, aStyleContext,
   1:                               &haveFirstLetterStyle, &haveFirstLineStyle);
   1:   nsFrameConstructorSaveState floatSaveState;
   1:   aState.PushFloatContainingBlock(areaFrame, floatSaveState,
   1:                                   haveFirstLetterStyle,
   1:                                   haveFirstLineStyle);
   1: 
   1:   // Process children
   1:   nsFrameConstructorSaveState absoluteSaveState;
   1:   nsFrameItems                childItems;
   1: 
   1:   if (aStyleDisplay->IsPositioned()) {
   1:     // The area frame becomes a container for child frames that are
   1:     // absolutely positioned
   1:     aState.PushAbsoluteContainingBlock(areaFrame, absoluteSaveState);
   1:   }
   1: 
   1:   ProcessChildren(aState, aContent, areaFrame, PR_TRUE,
   1:                   childItems, PR_TRUE);
   1: 
   1:   static NS_DEFINE_IID(kLegendFrameCID, NS_LEGEND_FRAME_CID);
   1:   nsIFrame * child      = childItems.childList;
   1:   nsIFrame * previous   = nsnull;
   1:   nsIFrame* legendFrame = nsnull;
   1:   while (nsnull != child) {
   1:     nsresult result = child->QueryInterface(kLegendFrameCID, (void**)&legendFrame);
   1:     if (NS_SUCCEEDED(result) && legendFrame) {
   1:       // We want the legend to be the first frame in the fieldset child list.
   1:       // That way the EventStateManager will do the right thing when tabbing
   1:       // from a selection point within the legend (bug 236071), which is
   1:       // used for implementing legend access keys (bug 81481).
   1:       // GetAdjustedParentFrame() below depends on this frame order.
   1:       if (nsnull != previous) {
   1:         previous->SetNextSibling(legendFrame->GetNextSibling());
   1:       } else {
   1:         childItems.childList = legendFrame->GetNextSibling();
   1:       }
   1:       legendFrame->SetNextSibling(areaFrame);
   1:       legendFrame->SetParent(newFrame);
   1:       break;
   1:     }
   1:     previous = child;
   1:     child = child->GetNextSibling();
   1:   }
   1: 
   1:   // Set the scrolled frame's initial child lists
   1:   areaFrame->SetInitialChildList(nsnull, childItems.childList);
   1: 
   1:   // Set the scroll frame's initial child list
   1:   newFrame->SetInitialChildList(nsnull, legendFrame ? legendFrame : areaFrame);
   1: 
   1:   // our new frame returned is the top frame which is the list frame. 
   1:   aNewFrame = newFrame; 
   1: 
   1:   // yes we have already initialized our frame 
   1:   aFrameHasBeenInitialized = PR_TRUE; 
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructTextFrame(nsFrameConstructorState& aState,
   1:                                           nsIContent*              aContent,
   1:                                           nsIFrame*                aParentFrame,
   1:                                           nsStyleContext*          aStyleContext,
   1:                                           nsFrameItems&            aFrameItems,
   1:                                           PRBool                   aPseudoParent)
   1: {
   1:   // process pending pseudo frames. whitespace doesn't have an effect.
   1:   if (!aPseudoParent && !aState.mPseudoFrames.IsEmpty() &&
   1:       !TextIsOnlyWhitespace(aContent))
   1:     ProcessPseudoFrames(aState, aFrameItems);
   1: 
   1:   nsIFrame* newFrame = nsnull;
   1: 
   1: #ifdef MOZ_SVG
   1:   if (aParentFrame->IsFrameOfType(nsIFrame::eSVG)) {
   1:     nsIFrame *ancestorFrame = SVG_GetFirstNonAAncestorFrame(aParentFrame);
   1:     if (ancestorFrame) {
   1:       nsISVGTextContentMetrics* metrics;
   1:       CallQueryInterface(ancestorFrame, &metrics);
   1:       if (!metrics) {
   1:         return NS_OK;
   1:       }
   1:       newFrame = NS_NewSVGGlyphFrame(mPresShell, aContent,
   1:                                      ancestorFrame, aStyleContext);
   1:     }
   1:   }
   1:   else {
   1:     newFrame = NS_NewTextFrame(mPresShell, aStyleContext);
   1:   }
   1: #else
   1:   newFrame = NS_NewTextFrame(mPresShell, aStyleContext);
   1: #endif
   1: 
   1:   if (NS_UNLIKELY(!newFrame))
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:   nsresult rv = InitAndRestoreFrame(aState, aContent, aParentFrame,
   1:                                     nsnull, newFrame);
   1: 
   1:   if (NS_FAILED(rv)) {
   1:     newFrame->Destroy();
   1:     return rv;
   1:   }
   1: 
   1:   // We never need to create a view for a text frame.
   1: 
   1:   // Set the frame's initial child list to null.
   1:   newFrame->SetInitialChildList(nsnull, nsnull);
   1: 
   1:   // Add the newly constructed frame to the flow
   1:   aFrameItems.AddChild(newFrame);
   1: 
   1:   // Text frames don't go in the content->frame hash table, because
   1:   // they're anonymous. This keeps the hash table smaller
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructHTMLFrame(nsFrameConstructorState& aState,
   1:                                           nsIContent*              aContent,
   1:                                           nsIFrame*                aParentFrame,
   1:                                           nsIAtom*                 aTag,
   1:                                           PRInt32                  aNameSpaceID,
   1:                                           nsStyleContext*          aStyleContext,
   1:                                           nsFrameItems&            aFrameItems,
   1:                                           PRBool                   aHasPseudoParent)
   1: {
   1:   // Ignore the tag if it's not HTML content and if it doesn't extend (via XBL)
   1:   // a valid HTML namespace.
   1:   if (!aContent->IsNodeOfType(nsINode::eHTML) &&
   1:       aNameSpaceID != kNameSpaceID_XHTML) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   PRBool    frameHasBeenInitialized = PR_FALSE;
   1:   nsIFrame* newFrame = nsnull;  // the frame we construct
   1:   PRBool    addToHashTable = PR_TRUE;
   1:   PRBool    isFloatContainer = PR_FALSE;
   1:   PRBool    addedToFrameList = PR_FALSE;
   1:   nsresult  rv = NS_OK;
   1:   
   1:   PRBool triedFrame = PR_FALSE;
   1: 
   1:   // See if the element is absolute or fixed positioned
   1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
   1: 
   1:   // Create a frame based on the tag
   1:   if (nsGkAtoms::img == aTag) {
   1:     // Make sure to keep IsSpecialContent in synch with this code
   1:     rv = CreateHTMLImageFrame(aContent, aStyleContext, NS_NewImageFrame,
   1:                               &newFrame);
   1:     if (newFrame) {
   1:       if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:         ProcessPseudoFrames(aState, aFrameItems); 
   1:       }
   1:     }
   1:   }
   1:   else if (nsGkAtoms::br == aTag) {
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     newFrame = NS_NewBRFrame(mPresShell, aStyleContext);
   1:     triedFrame = PR_TRUE;
   1: 
   1:     // BR frames don't go in the content->frame hash table: typically
   1:     // there are many BR content objects and this would increase the size
   1:     // of the hash table, and it's doubtful we need the mapping anyway
   1:     addToHashTable = PR_FALSE;
   1:   }
   1:   else if (nsGkAtoms::wbr == aTag) {
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     newFrame = NS_NewWBRFrame(mPresShell, aStyleContext);
   1:     triedFrame = PR_TRUE;
   1:   }
   1:   else if (nsGkAtoms::input == aTag) {
   1:     // Make sure to keep IsSpecialContent in synch with this code
   1:     rv = CreateInputFrame(aState, aContent, aParentFrame,
   1:                           aTag, aStyleContext, &newFrame,
   1:                           display, frameHasBeenInitialized,
4461:                           addedToFrameList, aFrameItems,
4461:                           aHasPseudoParent);
4461:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty() &&
4461:         newFrame && !addedToFrameList) {
4461:       // We'll still be adding this new frame, and it's a replaced
4461:       // element, so process pseudo-frames now.
4461:       ProcessPseudoFrames(aState, aFrameItems);       
4461:     }
   1:   }
   1:   else if (nsGkAtoms::textarea == aTag) {
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     newFrame = NS_NewTextControlFrame(mPresShell, aStyleContext);
   1:     triedFrame = PR_TRUE;
   1:   }
   1:   else if (nsGkAtoms::select == aTag) {
   1:     if (!gUseXBLForms) {
   1:       if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:         ProcessPseudoFrames(aState, aFrameItems); 
   1:       }
   1:       rv = ConstructSelectFrame(aState, aContent, aParentFrame,
   1:                                 aTag, aStyleContext, newFrame,
   1:                                 display, frameHasBeenInitialized,
   1:                                 aFrameItems);
   1:       if (newFrame) {
   1:         NS_ASSERTION(nsPlaceholderFrame::GetRealFrameFor(aFrameItems.lastChild) ==
   1:                      newFrame,
   1:                      "Frame didn't get added to aFrameItems?");
   1:         addedToFrameList = PR_TRUE;
   1:       }
   1:     }
   1:   }
   1:   else if (nsGkAtoms::object == aTag ||
   1:            nsGkAtoms::applet == aTag ||
   1:            nsGkAtoms::embed == aTag) {
   1:     // Make sure to keep IsSpecialContent in synch with this code
   1:     if (!(aContent->IntrinsicState() &
   1:           (NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED |
   1:            NS_EVENT_STATE_SUPPRESSED))) {
   1:       if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:         ProcessPseudoFrames(aState, aFrameItems); 
   1:       }
   1: 
   1:       nsCOMPtr<nsIObjectLoadingContent> objContent(do_QueryInterface(aContent));
   1:       NS_ASSERTION(objContent,
   1:                    "applet, embed and object must implement nsIObjectLoadingContent!");
   1:       if (!objContent) {
   1:         // XBL might trigger this... 
   1:         return NS_ERROR_UNEXPECTED;
   1:       }
   1: 
   1:       PRUint32 type;
   1:       objContent->GetDisplayedType(&type);
   1:       if (type == nsIObjectLoadingContent::TYPE_LOADING) {
   1:         // Ideally, this should show the standby attribute
   1:         // XXX Should we return something that is replaced, or make
   1:         // nsFrame replaced but not its subclasses?
   1:         newFrame = NS_NewEmptyFrame(mPresShell, aStyleContext);
   1:       }
   1:       else if (type == nsIObjectLoadingContent::TYPE_PLUGIN)
   1:         newFrame = NS_NewObjectFrame(mPresShell, aStyleContext);
   1:       else if (type == nsIObjectLoadingContent::TYPE_IMAGE)
   1:         newFrame = NS_NewImageFrame(mPresShell, aStyleContext);
   1:       else if (type == nsIObjectLoadingContent::TYPE_DOCUMENT)
   1:         newFrame = NS_NewSubDocumentFrame(mPresShell, aStyleContext);
   1: #ifdef DEBUG
   1:       else
   1:         NS_ERROR("Shouldn't get here if we're not broken and not "
   1:                  "suppressed and not blocked");
   1: #endif
   1: 
   1:       triedFrame = PR_TRUE;
   1:     }
   1:   }
   1:   else if (nsGkAtoms::fieldset == aTag) {
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     rv = ConstructFieldSetFrame(aState, aContent, aParentFrame,
   1:                                 aTag, aStyleContext, newFrame,
   1:                                 aFrameItems, display, frameHasBeenInitialized);
   1:     NS_ASSERTION(nsPlaceholderFrame::GetRealFrameFor(aFrameItems.lastChild) ==
   1:                  newFrame,
   1:                  "Frame didn't get added to aFrameItems?");
   1:     addedToFrameList = PR_TRUE;
   1:   }
   1:   else if (nsGkAtoms::legend == aTag) {
   1:     NS_ASSERTION(!display->IsAbsolutelyPositioned() && !display->IsFloating(),
   1:                  "Legends should not be positioned and should not float");
   1:     
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     newFrame = NS_NewLegendFrame(mPresShell, aStyleContext);
   1:     triedFrame = PR_TRUE;
   1: 
   1:     isFloatContainer = PR_TRUE;
   1:   }
   1:   else if (nsGkAtoms::frameset == aTag) {
   1:     NS_ASSERTION(!display->IsAbsolutelyPositioned() && !display->IsFloating(),
   1:                  "Framesets should not be positioned and should not float");
   1:     
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:    
   1:     newFrame = NS_NewHTMLFramesetFrame(mPresShell, aStyleContext);
   1:     triedFrame = PR_TRUE;
   1:   }
   1:   else if (nsGkAtoms::iframe == aTag) {
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     
   1:     newFrame = NS_NewSubDocumentFrame(mPresShell, aStyleContext);
   1:     triedFrame = PR_TRUE;
   1: 
   1:     if (newFrame) {
   1:       // the nsSubDocumentFrame needs to know about its content parent during ::Init.
   1:       // there is no reasonable way to get the value there.
   1:       // so we store it as a frame property.
   1:       nsCOMPtr<nsIAtom> contentParentAtom = do_GetAtom("contentParent");
   1:       aState.mPresContext->PropertyTable()->
   1:         SetProperty(newFrame, contentParentAtom,
   1:                     aParentFrame, nsnull, nsnull);
   1:     }
   1:   }
   1:   else if (nsGkAtoms::spacer == aTag) {
   1:     NS_ASSERTION(!display->IsAbsolutelyPositioned() && !display->IsFloating(),
   1:                  "Spacers should not be positioned and should not float");
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     newFrame = NS_NewSpacerFrame(mPresShell, aStyleContext);
   1:     triedFrame = PR_TRUE;
   1:   }
   1:   else if (nsGkAtoms::button == aTag) {
   1:     rv = ConstructButtonFrame(aState, aContent, aParentFrame,
   1:                               aTag, aStyleContext, &newFrame,
4461:                               display, aFrameItems, aHasPseudoParent);
   1:     // the html4 button needs to act just like a 
   1:     // regular button except contain html content
   1:     // so it must be replaced or html outside it will
   1:     // draw into its borders. -EDV
   1:     frameHasBeenInitialized = PR_TRUE;
   1:     addedToFrameList = PR_TRUE;
   1:     isFloatContainer = PR_TRUE;
   1:   }
   1:   else if (nsGkAtoms::isindex == aTag) {
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems);
   1:     }
   1:     newFrame = NS_NewIsIndexFrame(mPresShell, aStyleContext);
   1:     triedFrame = PR_TRUE;
   1:   }
   1:   else if (nsGkAtoms::canvas == aTag) {
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     newFrame = NS_NewHTMLCanvasFrame(mPresShell, aStyleContext);
   1:     triedFrame = PR_TRUE;
   1:   }
   1: 
   1:   if (NS_UNLIKELY(triedFrame && !newFrame)) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1:   else if (NS_FAILED(rv) || !newFrame) {
   1:     return rv;
   1:   }
   1: 
   1:   // If we succeeded in creating a frame then initialize it, process its
   1:   // children (if requested), and set the initial child list
   1: 
   1:   // Note: at this point we should construct kids for newFrame only if
   1:   // it's not a leaf and hasn't been initialized yet.
   1:   
   1:   if (!frameHasBeenInitialized) {
   1:     NS_ASSERTION(!addedToFrameList,
   1:                  "Frames that were already added to the frame list should be "
   1:                  "initialized by now!");
   1:     nsIFrame* geometricParent = aState.GetGeometricParent(display,
   1:                                                           aParentFrame);
   1:      
   1:     rv = InitAndRestoreFrame(aState, aContent, geometricParent, nsnull, newFrame);
   1:     NS_ASSERTION(NS_SUCCEEDED(rv), "InitAndRestoreFrame failed");
   1:     // See if we need to create a view, e.g. the frame is absolutely
   1:     // positioned
   1:     nsHTMLContainerFrame::CreateViewForFrame(newFrame, aParentFrame, PR_FALSE);
   1: 
   1:     rv = aState.AddChild(newFrame, aFrameItems, display, aContent,
   1:                          aStyleContext, aParentFrame);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1:     addedToFrameList = PR_TRUE;
   1:       
   1:     // Process the child content if requested
   1:     nsFrameItems childItems;
   1:     nsFrameConstructorSaveState absoluteSaveState;
   1:     nsFrameConstructorSaveState floatSaveState;
   1:     if (!newFrame->IsLeaf()) {
   1:       if (display->IsPositioned()) {
   1:         aState.PushAbsoluteContainingBlock(newFrame, absoluteSaveState);
   1:       }
   1:       if (isFloatContainer) {
   1:         PRBool haveFirstLetterStyle, haveFirstLineStyle;
1254:         ShouldHaveSpecialBlockStyle(aContent, aStyleContext,
1254:                                     &haveFirstLetterStyle,
1254:                                     &haveFirstLineStyle);
   1:         aState.PushFloatContainingBlock(newFrame, floatSaveState,
   1:                                         PR_FALSE, PR_FALSE);
   1:       }
   1: 
   1:       // Process the child frames
   1:       rv = ProcessChildren(aState, aContent, newFrame,
   1:                            PR_TRUE, childItems, PR_FALSE);
   1:     }
   1: 
   1:     // if there are any anonymous children create frames for them
   1:     CreateAnonymousFrames(aTag, aState, aContent, newFrame,
   1:                           PR_FALSE, childItems);
   1: 
   1:     // Set the frame's initial child list
   1:     if (childItems.childList) {
   1:       newFrame->SetInitialChildList(nsnull, childItems.childList);
   1:     }
   1:   }
   1: 
   1:   if (!addedToFrameList) {
   1:     // Gotta do it here.  Note that things like absolutely positioned replaced
   1:     // elements and the like will end up in this code.   So use the AddChild
   1:     // on the state.
   1:     rv = aState.AddChild(newFrame, aFrameItems, display, aContent,
   1:                          aStyleContext, aParentFrame);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1:   }
   1: 
   1:   if (addToHashTable) {
   1:     // Add a mapping from content object to primary frame. Note that for
   1:     // floated and positioned frames this is the out-of-flow frame and not
   1:     // the placeholder frame
   1:     aState.mFrameManager->SetPrimaryFrameFor(aContent, newFrame);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreateAnonymousFrames(nsIAtom*                 aTag,
   1:                                              nsFrameConstructorState& aState,
   1:                                              nsIContent*              aParent,
   1:                                              nsIFrame*                aNewFrame,
   1:                                              PRBool                   aAppendToExisting,
   1:                                              nsFrameItems&            aChildItems,
   1:                                              PRBool                   aIsRoot)
   1: {
   1:   // See if we might have anonymous content
   1:   // by looking at the tag rather than doing a QueryInterface on
   1:   // the frame.  Only these tags' frames can have anonymous content
   1:   // through nsIAnonymousContentCreator.  We do this check for
   1:   // performance reasons. If we did a QueryInterface on every tag it
   1:   // would be inefficient.
   1: 
   1:   // nsGenericElement::SetDocument ought to keep a list like this one,
   1:   // but it can't because scroll frames get around this.
   1:   if (!aIsRoot &&
   1:       aTag != nsGkAtoms::input &&
   1:       aTag != nsGkAtoms::textarea &&
   1:       aTag != nsGkAtoms::combobox &&
   1:       aTag != nsGkAtoms::isindex &&
   1:       aTag != nsGkAtoms::scrollbar
   1: #ifdef MOZ_SVG
   1:       && aTag != nsGkAtoms::use
   1: #endif
   1:       )
   1:     return NS_OK;
   1: 
   1:   return CreateAnonymousFrames(aState, aParent, mDocument, aNewFrame,
   1:                                aAppendToExisting, aChildItems);
   1: }
   1: 
   1: // after the node has been constructed and initialized create any
   1: // anonymous content a node needs.
   1: nsresult
   1: nsCSSFrameConstructor::CreateAnonymousFrames(nsFrameConstructorState& aState,
   1:                                              nsIContent*              aParent,
   1:                                              nsIDocument*             aDocument,
   1:                                              nsIFrame*                aParentFrame,
   1:                                              PRBool                   aAppendToExisting,
   1:                                              nsFrameItems&            aChildItems)
   1: {
1717:   nsIAnonymousContentCreator* creator = nsnull;
1717:   CallQueryInterface(aParentFrame, &creator);
   1:   if (!creator)
   1:     return NS_OK;
   1: 
   1:   nsresult rv;
   1: 
   1:   nsAutoTArray<nsIContent*, 4> newAnonymousItems;
   1:   rv = creator->CreateAnonymousContent(newAnonymousItems);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRUint32 count = newAnonymousItems.Length();
   1:   if (count == 0) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   // save the incoming pseudo frame state, so that we don't end up
   1:   // with those pseudoframes in aChildItems
   1:   nsPseudoFrames priorPseudoFrames; 
   1:   aState.mPseudoFrames.Reset(&priorPseudoFrames);
   1: 
   1:   for (PRUint32 i=0; i < count; i++) {
   1:     // get our child's content and set its parent to our content
   1:     nsIContent* content = newAnonymousItems[i];
   1:     NS_ASSERTION(content, "null anonymous content?");
   1: 
   1:     content->SetNativeAnonymous(PR_TRUE);
   1: 
   1:     nsIContent* bindingParent = content;
   1: #ifdef MOZ_SVG
   1:     // least-surprise CSS binding until we do the SVG specified
   1:     // cascading rules for <svg:use> - bug 265894
   1:     if (aParent &&
   1:         aParent->NodeInfo()->Equals(nsGkAtoms::use, kNameSpaceID_SVG))
   1:       bindingParent = aParent;
   1: #endif
   1: 
   1:     rv = content->BindToTree(aDocument, aParent, bindingParent, PR_TRUE);
   1:     if (NS_FAILED(rv)) {
   1:       content->UnbindFromTree();
   1:       return rv;
   1:     }
   1: 
   1:     nsIFrame* newFrame = creator->CreateFrameFor(content);
   1:     if (newFrame) {
   1:       aChildItems.AddChild(newFrame);
   1:     }
   1:     else {
   1:       // create the frame and attach it to our frame
   1:       ConstructFrame(aState, content, aParentFrame, aChildItems);
   1:     }
1346:   }
   1: 
   1:   creator->PostCreateFrames();
   1: 
   1:   // process the current pseudo frame state
   1:   if (!aState.mPseudoFrames.IsEmpty()) {
   1:     ProcessPseudoFrames(aState, aChildItems);
   1:   }
   1: 
   1:   // restore the incoming pseudo frame state 
   1:   aState.mPseudoFrames = priorPseudoFrames;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: static
   1: PRBool IsXULDisplayType(const nsStyleDisplay* aDisplay)
   1: {
   1:   return (aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX || 
   1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_GRID || 
   1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_STACK ||
   1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_BOX ||
   1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID ||
   1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_STACK ||
   1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID_GROUP ||
   1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID_LINE ||
   1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_DECK ||
   1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_POPUP ||
   1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GROUPBOX
   1:           );
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructXULFrame(nsFrameConstructorState& aState,
   1:                                          nsIContent*              aContent,
   1:                                          nsIFrame*                aParentFrame,
   1:                                          nsIAtom*                 aTag,
   1:                                          PRInt32                  aNameSpaceID,
   1:                                          nsStyleContext*          aStyleContext,
   1:                                          nsFrameItems&            aFrameItems,
   1:                                          PRBool                   aXBLBaseTag,
   1:                                          PRBool                   aHasPseudoParent,
   1:                                          PRBool*                  aHaltProcessing)
   1: {
   1:   *aHaltProcessing = PR_FALSE;
   1: 
   1:   PRBool    primaryFrameSet = PR_FALSE;
   1:   nsresult  rv = NS_OK;
   1:   PRBool    isPopup = PR_FALSE;
   1:   PRBool    frameHasBeenInitialized = PR_FALSE;
   1: 
   1:   // XXXbz somewhere here we should process pseudo frames if !aHasPseudoParent
   1:   
   1:   // this is the new frame that will be created
   1:   nsIFrame* newFrame = nsnull;
   1:   
   1:   // this is the also the new frame that is created. But if a scroll frame is needed
   1:   // the content will be mapped to the scrollframe and topFrame will point to it.
   1:   // newFrame will still point to the child that we created like a "div" for example.
   1:   nsIFrame* topFrame = nsnull;
   1: 
   1:   // Store aParentFrame away, since we plan to stomp on it later
   1:   nsIFrame* origParentFrame = aParentFrame;
   1: 
   1:   NS_ASSERTION(aTag != nsnull, "null XUL tag");
   1:   if (aTag == nsnull)
   1:     return NS_OK;
   1: 
   1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
   1:   
   1:   PRBool isXULNS = (aNameSpaceID == kNameSpaceID_XUL);
   1:   PRBool isXULDisplay = IsXULDisplayType(display);
   1: 
   1:    // don't apply xul display types to tag based frames
   1:   if (isXULDisplay && !isXULNS) {
   1:     isXULDisplay = !IsSpecialContent(aContent, aTag, aNameSpaceID, aStyleContext);
   1:   }
   1: 
   1:   PRBool triedFrame = PR_FALSE;
   1: 
   1:   if (isXULNS || isXULDisplay) {
   1:     PRBool mayBeScrollable = PR_FALSE;
   1: 
   1:     if (isXULNS) {
   1:       triedFrame = PR_TRUE;
   1:     
   1:       // First try creating a frame based on the tag
   1:       // Make sure to keep IsSpecialContent in synch with this code
   1: #ifdef MOZ_XUL
   1:       // BUTTON CONSTRUCTION
   1:       if (aTag == nsGkAtoms::button || aTag == nsGkAtoms::checkbox || aTag == nsGkAtoms::radio) {
   1:         newFrame = NS_NewButtonBoxFrame(mPresShell, aStyleContext);
   1: 
   1:         // Boxes can scroll.
   1:         mayBeScrollable = PR_TRUE;
   1:       } // End of BUTTON CONSTRUCTION logic
   1:       // AUTOREPEATBUTTON CONSTRUCTION
   1:       else if (aTag == nsGkAtoms::autorepeatbutton) {
   1:         newFrame = NS_NewAutoRepeatBoxFrame(mPresShell, aStyleContext);
   1: 
   1:         // Boxes can scroll.
   1:         mayBeScrollable = PR_TRUE;
   1:       } // End of AUTOREPEATBUTTON CONSTRUCTION logic
   1: 
   1:       // TITLEBAR CONSTRUCTION
   1:       else if (aTag == nsGkAtoms::titlebar) {
   1:         newFrame = NS_NewTitleBarFrame(mPresShell, aStyleContext);
   1: 
   1:         // Boxes can scroll.
   1:         mayBeScrollable = PR_TRUE;
   1:       } // End of TITLEBAR CONSTRUCTION logic
   1: 
   1:       // RESIZER CONSTRUCTION
   1:       else if (aTag == nsGkAtoms::resizer) {
   1:         newFrame = NS_NewResizerFrame(mPresShell, aStyleContext);
   1: 
   1:         // Boxes can scroll.
   1:         mayBeScrollable = PR_TRUE;
   1:       } // End of RESIZER CONSTRUCTION logic
   1: 
   1:       else if (aTag == nsGkAtoms::image) {
   1:         newFrame = NS_NewImageBoxFrame(mPresShell, aStyleContext);
   1:       }
   1:       else if (aTag == nsGkAtoms::spring ||
   1:                aTag == nsGkAtoms::spacer) {
   1:         newFrame = NS_NewLeafBoxFrame(mPresShell, aStyleContext);
   1:       }
   1:        else if (aTag == nsGkAtoms::treechildren) {
   1:         newFrame = NS_NewTreeBodyFrame(mPresShell, aStyleContext);
   1:       }
   1:       else if (aTag == nsGkAtoms::treecol) {
   1:         newFrame = NS_NewTreeColFrame(mPresShell, aStyleContext);
   1:       }
   1:       // TEXT CONSTRUCTION
   1:       else if (aTag == nsGkAtoms::text || aTag == nsGkAtoms::label ||
   1:                aTag == nsGkAtoms::description) {
   1:         if ((aTag == nsGkAtoms::label || aTag == nsGkAtoms::description) && 
   1:             (! aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value))) {
2345:           // XXX we should probably be calling ConstructBlock here to handle
2345:           // things like columns etc
   1:           newFrame = NS_NewAreaFrame(mPresShell, aStyleContext,
   1:                                      NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT);
   1:         }
   1:         else {
   1:           newFrame = NS_NewTextBoxFrame(mPresShell, aStyleContext);
   1:         }
   1:       }
   1:       // End of TEXT CONSTRUCTION logic
   1: 
   1:        // Menu Construction    
   1:       else if (aTag == nsGkAtoms::menu ||
   1:                aTag == nsGkAtoms::menuitem || 
   1:                aTag == nsGkAtoms::menubutton) {
   1:         // A derived class box frame
   1:         // that has custom reflow to prevent menu children
   1:         // from becoming part of the flow.
   1:         newFrame = NS_NewMenuFrame(mPresShell, aStyleContext,
   1:           (aTag != nsGkAtoms::menuitem));
   1:       }
   1:       else if (aTag == nsGkAtoms::menubar) {
   1:   #ifdef XP_MACOSX
   1:         // On Mac OS X, we use the system menubar for any root chrome shell
   1:         // XUL menubars.
   1:         PRBool isRootChromeShell = PR_FALSE;
   1:         nsCOMPtr<nsISupports> container = aState.mPresContext->GetContainer();
   1:         if (container) {
   1:           nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
   1:           if (treeItem) {
   1:             PRInt32 type;
   1:             treeItem->GetItemType(&type);
   1:             if (nsIDocShellTreeItem::typeChrome == type) {
   1:               nsCOMPtr<nsIDocShellTreeItem> parent;
   1:               treeItem->GetParent(getter_AddRefs(parent));
   1:               isRootChromeShell = !parent;
   1:             }
   1:           }
   1:         }
   1: 
   1:         if (isRootChromeShell) {
   1:           *aHaltProcessing = PR_TRUE;
   1:           return NS_OK;
   1:         }
   1:   #endif
   1: 
   1:         newFrame = NS_NewMenuBarFrame(mPresShell, aStyleContext);
   1:       }
   1:       else if (aTag == nsGkAtoms::popupgroup) {
   1:         // This frame contains child popups
   1:         newFrame = NS_NewPopupSetFrame(mPresShell, aStyleContext);
   1:       }
   1:       else if (aTag == nsGkAtoms::iframe || aTag == nsGkAtoms::editor ||
   1:                aTag == nsGkAtoms::browser) {
   1:         newFrame = NS_NewSubDocumentFrame(mPresShell, aStyleContext);
   1:       }
   1:       // PROGRESS METER CONSTRUCTION
   1:       else if (aTag == nsGkAtoms::progressmeter) {
   1:         newFrame = NS_NewProgressMeterFrame(mPresShell, aStyleContext);
   1:       }
   1:       // End of PROGRESS METER CONSTRUCTION logic
   1:       else
   1: #endif
   1:       // SLIDER CONSTRUCTION
   1:       if (aTag == nsGkAtoms::slider) {
   1:         newFrame = NS_NewSliderFrame(mPresShell, aStyleContext);
   1:       }
   1:       // End of SLIDER CONSTRUCTION logic
   1: 
   1:       // SCROLLBAR CONSTRUCTION
   1:       else if (aTag == nsGkAtoms::scrollbar) {
   1:         newFrame = NS_NewScrollbarFrame(mPresShell, aStyleContext);
   1:       }
   1:       // End of SCROLLBAR CONSTRUCTION logic
   1: 
   1:       // SCROLLBUTTON CONSTRUCTION
   1:       else if (aTag == nsGkAtoms::scrollbarbutton) {
   1:         newFrame = NS_NewScrollbarButtonFrame(mPresShell, aStyleContext);
   1:       }
   1:       // End of SCROLLBUTTON CONSTRUCTION logic
   1: 
   1: #ifdef MOZ_XUL
   1:       // SPLITTER CONSTRUCTION
   1:       else if (aTag == nsGkAtoms::splitter) {
   1:         newFrame = NS_NewSplitterFrame(mPresShell, aStyleContext);
   1:       }
   1:       // End of SPLITTER CONSTRUCTION logic
   1: 
   1:       else {
   1:         triedFrame = PR_FALSE;
   1:       }
   1: #endif
   1:     }
   1: 
   1:     // Display types for XUL start here
   1:     // Make sure this is kept in sync with nsCSSProps::kDisplayKTable
   1:     // First is BOX
   1:     if (!newFrame && isXULDisplay) {
   1:       triedFrame = PR_TRUE;
   1:   
   1:       if (display->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX ||
   1:                display->mDisplay == NS_STYLE_DISPLAY_BOX) {
   1:         newFrame = NS_NewBoxFrame(mPresShell, aStyleContext, PR_FALSE, nsnull);
   1: 
   1:         // Boxes can scroll.
   1:         mayBeScrollable = PR_TRUE;
   1:       } // End of BOX CONSTRUCTION logic
   1: #ifdef MOZ_XUL
   1:       // ------- Begin Grid ---------
   1:       else if (display->mDisplay == NS_STYLE_DISPLAY_INLINE_GRID ||
   1:                display->mDisplay == NS_STYLE_DISPLAY_GRID) {
   1:         nsCOMPtr<nsIBoxLayout> layout;
   1:         NS_NewGridLayout2(mPresShell, getter_AddRefs(layout));
   1:         newFrame = NS_NewBoxFrame(mPresShell, aStyleContext, PR_FALSE, layout);
   1: 
   1:         // Boxes can scroll.
   1:         mayBeScrollable = PR_TRUE;
   1:       } //------- End Grid ------
   1: 
   1:       // ------- Begin Rows/Columns ---------
   1:       else if (display->mDisplay == NS_STYLE_DISPLAY_GRID_GROUP) {
   1:         nsCOMPtr<nsIBoxLayout> layout;
   1:       
   1:         if (aTag == nsGkAtoms::listboxbody) {
   1:           NS_NewListBoxLayout(mPresShell, layout);
   1:           newFrame = NS_NewListBoxBodyFrame(mPresShell, aStyleContext, PR_FALSE, layout);
   1:         }
   1:         else
   1:         {
   1:           NS_NewGridRowGroupLayout(mPresShell, getter_AddRefs(layout));
   1:           newFrame = NS_NewGridRowGroupFrame(mPresShell, aStyleContext, PR_FALSE, layout);
   1:         }
   1: 
   1:         // Boxes can scroll.
   1:         if (display->IsScrollableOverflow()) {
   1:           // set the top to be the newly created scrollframe
   1:           BuildScrollFrame(aState, aContent, aStyleContext, newFrame,
   1:                            aParentFrame, nsnull, topFrame, aStyleContext);
   1: 
   1:           // we have a scrollframe so the parent becomes the scroll frame.
   1:           aParentFrame = newFrame->GetParent();
   1: 
   1:           primaryFrameSet = PR_TRUE;
   1: 
   1:           frameHasBeenInitialized = PR_TRUE;
   1:         }
   1:       } //------- End Grid ------
   1: 
   1:       // ------- Begin Row/Column ---------
   1:       else if (display->mDisplay == NS_STYLE_DISPLAY_GRID_LINE) {
   1:         nsCOMPtr<nsIBoxLayout> layout;
   1: 
   1: 
   1:         NS_NewGridRowLeafLayout(mPresShell, getter_AddRefs(layout));
   1: 
   1:         if (aTag == nsGkAtoms::listitem)
   1:           newFrame = NS_NewListItemFrame(mPresShell, aStyleContext, PR_FALSE, layout);
   1:         else
   1:           newFrame = NS_NewGridRowLeafFrame(mPresShell, aStyleContext, PR_FALSE, layout);
   1: 
   1:         // Boxes can scroll.
   1:         mayBeScrollable = PR_TRUE;
   1:       } //------- End Grid ------
   1:       // End of STACK CONSTRUCTION logic
   1:        // DECK CONSTRUCTION
   1:       else if (display->mDisplay == NS_STYLE_DISPLAY_DECK) {
   1:         newFrame = NS_NewDeckFrame(mPresShell, aStyleContext);
   1:       }
   1:       // End of DECK CONSTRUCTION logic
   1:       else if (display->mDisplay == NS_STYLE_DISPLAY_GROUPBOX) {
   1:         newFrame = NS_NewGroupBoxFrame(mPresShell, aStyleContext);
   1: 
   1:         // Boxes can scroll.
   1:         mayBeScrollable = PR_TRUE;
   1:       } 
   1:       // STACK CONSTRUCTION
   1:       else if (display->mDisplay == NS_STYLE_DISPLAY_STACK ||
   1:                display->mDisplay == NS_STYLE_DISPLAY_INLINE_STACK) {
   1:         newFrame = NS_NewStackFrame(mPresShell, aStyleContext);
   1: 
   1:         mayBeScrollable = PR_TRUE;
   1:       }
   1:       else if (display->mDisplay == NS_STYLE_DISPLAY_POPUP) {
   1:         // If a popup is inside a menu, then the menu understands the complex
   1:         // rules/behavior governing the cascade of multiple menu popups and can handle
   1:         // having the real popup frame placed under it as a child.  
   1:         // If, however, the parent is *not* a menu frame, then we need to create
   1:         // a placeholder frame for the popup, and then we add the popup frame to the
   1:         // root popup set (that manages all such "detached" popups).
3129:         if (aParentFrame->GetType() != nsGkAtoms::menuFrame) {
   1:           if (!aState.mPopupItems.containingBlock) {
   1:             // Just don't create a frame for this popup; we can't do
   1:             // anything with it, since there is no root popup set.
   1:             *aHaltProcessing = PR_TRUE;
   1:             NS_ASSERTION(!aState.mRootBox, "Popup containing block is missing");
   1:             return NS_OK;
   1:           }
   1: 
   1: #ifdef NS_DEBUG
3129:           NS_ASSERTION(aState.mPopupItems.containingBlock->GetType() ==
3129:                        nsGkAtoms::popupSetFrame,
3129:                        "Popup containing block isn't a nsIPopupSetFrame");
   1: #endif
   1:           isPopup = PR_TRUE;
   1:         }
   1: 
   1:         // This is its own frame that derives from box.
   1:         newFrame = NS_NewMenuPopupFrame(mPresShell, aStyleContext);
   1: 
   1:         if (aTag == nsGkAtoms::tooltip) {
   1:           if (aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::_default,
   1:                                     nsGkAtoms::_true, eIgnoreCase)) {
   1:             // Tell the root box about the tooltip.
   1:             if (aState.mRootBox)
   1:               aState.mRootBox->SetDefaultTooltip(aContent);
   1:           }
   1:         }
   1:       }
   1:       
   1:       else {
   1:         triedFrame = PR_FALSE;
   1:       }
   1: #endif // MOZ_XUL
   1:     }
   1: 
   1:     if (mayBeScrollable && display->IsScrollableOverflow()) {
   1:       // set the top to be the newly created scrollframe
   1:       BuildScrollFrame(aState, aContent, aStyleContext, newFrame,
   1:                        aParentFrame, nsnull, topFrame, aStyleContext);
   1: 
   1:       // we have a scrollframe so the parent becomes the scroll frame.
   1:       // XXXldb Do we really want to do this?  The one case where it
   1:       // matters when |frameHasBeenInitialized| is true is one where
   1:       // I think we'd be better off the other way around.
   1:       aParentFrame = newFrame->GetParent();
   1:       primaryFrameSet = PR_TRUE;
   1:       frameHasBeenInitialized = PR_TRUE;
   1:     }
   1:   }
   1:   
   1:   if (NS_UNLIKELY(triedFrame && !newFrame))
   1:   {
   1:     rv = NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   // If we succeeded in creating a frame then initialize it, process its
   1:   // children (if requested), and set the initial child list
   1:   if (NS_SUCCEEDED(rv) && newFrame != nsnull) {
   1: 
   1:     // if no top frame was created then the top is the new frame
   1:     if (topFrame == nsnull)
   1:         topFrame = newFrame;
   1: 
   1:     // xul does not support absolute positioning
   1:     nsIFrame* geometricParent;
   1: #ifdef MOZ_XUL
   1:     if (isPopup) {
   1:       NS_ASSERTION(aState.mPopupItems.containingBlock, "How did we get here?");
   1:       geometricParent = aState.mPopupItems.containingBlock;
   1:     }
   1:     else
   1: #endif
   1:     {
   1:       geometricParent = aParentFrame;
   1:     }
   1:     
   1:     /*
   1:       nsIFrame* geometricParent = aState.GetGeometricParent(display, aParentFrame);
   1:     */
   1:     // if the new frame was already initialized to initialize it again.
   1:     if (!frameHasBeenInitialized) {
   1: 
   1:       rv = InitAndRestoreFrame(aState, aContent, geometricParent, nsnull, newFrame);
   1: 
   1:       if (NS_FAILED(rv)) {
   1:         newFrame->Destroy();
   1:         return rv;
   1:       }
   1:       
   1:       /*
   1:       // if our parent is a block frame then do things the way html likes it
   1:       // if not then we are in a box so do what boxes like. On example is boxes
   1:       // do not support the absolute positioning of their children. While html blocks
   1:       // that's why we call different things here.
   1:       nsIAtom* frameType = geometricParent->GetType();
   1:       if ((frameType == nsGkAtoms::blockFrame) ||
   1:           (frameType == nsGkAtoms::areaFrame)) {
   1:       */
   1:         // See if we need to create a view, e.g. the frame is absolutely positioned
   1:         nsHTMLContainerFrame::CreateViewForFrame(newFrame, aParentFrame, PR_FALSE);
   1: 
   1:       /*
   1:       } else {
   1:           // we are in a box so do the box thing.
   1:         nsBoxFrame::CreateViewForFrame(aState.mPresContext, newFrame,
   1:                                                  aStyleContext, PR_FALSE);
   1:       }
   1:       */
   1:       
   1:     }
   1: 
   1:     // Add the new frame to our list of frame items.  Note that we
   1:     // don't support floating or positioning of XUL frames.
   1:     rv = aState.AddChild(topFrame, aFrameItems, display, aContent,
   1:                          aStyleContext, origParentFrame, PR_FALSE, PR_FALSE,
   1:                          isPopup);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1: 
   1: #ifdef MOZ_XUL
   1:     if (aTag == nsGkAtoms::popupgroup) {
   1:       nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
   1:       if (rootBox) {
   1:         NS_ASSERTION(rootBox->GetPopupSetFrame() == newFrame,
   1:                      "Unexpected PopupSetFrame");
   1:         aState.mPopupItems.containingBlock = rootBox->GetPopupSetFrame();
   1:       }      
   1:     }
   1: #endif
   1: 
2345:     // If the new frame isn't a float containing block, then push a null
2345:     // float containing block to disable floats. This is needed to disable
2345:     // floats within XUL frames.
2192:     nsFrameConstructorSaveState floatSaveState;
2345:     PRBool isFloatContainingBlock =
2345:       newFrame->GetContentInsertionFrame()->IsFloatContainingBlock();
2345:     aState.PushFloatContainingBlock(isFloatContainingBlock ? newFrame : nsnull,
2345:                                     floatSaveState, PR_FALSE, PR_FALSE);
2192: 
   1:     // Process the child content if requested
   1:     nsFrameItems childItems;
   1:     if (!newFrame->IsLeaf()) {
   1:       // XXXbz don't we need calls to ShouldBuildChildFrames
   1:       // elsewhere too?  Why only for XUL?
   1:       if (mDocument->BindingManager()->ShouldBuildChildFrames(aContent)) {
   1:         rv = ProcessChildren(aState, aContent, newFrame, PR_FALSE,
   1:                              childItems, PR_FALSE);
   1:       }
   1:     }
   1:       
   1:     CreateAnonymousFrames(aTag, aState, aContent, newFrame, PR_FALSE,
   1:                           childItems);
   1: 
   1:     // Set the frame's initial child list
   1:     newFrame->SetInitialChildList(nsnull, childItems.childList);
   1:   }
   1: 
   1: #ifdef MOZ_XUL
   1:   // register tooltip support if needed
   1:   if (aTag == nsGkAtoms::treechildren || // trees always need titletips
   1:       aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltiptext) ||
   1:       aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltip))
   1:   {
   1:     nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
   1:     if (rootBox)
   1:       rootBox->AddTooltipSupport(aContent);
   1:   }
   1: #endif
   1: 
   1: // addToHashTable:
   1: 
   1:   if (topFrame) {
   1:     // the top frame is always what we map the content to. This is the frame that contains a pointer
   1:     // to the content node.
   1: 
   1:     // Add a mapping from content object to primary frame. Note that for
   1:     // floated and positioned frames this is the out-of-flow frame and not
   1:     // the placeholder frame
   1:     if (!primaryFrameSet)
   1:         aState.mFrameManager->SetPrimaryFrameFor(aContent, topFrame);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
3129: nsresult
3129: nsCSSFrameConstructor::AddLazyChildren(nsIContent* aContent,
3129:                                        nsLazyFrameConstructionCallback* aCallback,
3129:                                        void* aArg)
3129: {
3129:   nsCOMPtr<nsIRunnable> event =
3129:     new LazyGenerateChildrenEvent(aContent, mPresShell, aCallback, aArg);
3129:   return NS_DispatchToCurrentThread(event);
3129: }
3129: 
   1: already_AddRefed<nsStyleContext>
   1: nsCSSFrameConstructor::BeginBuildingScrollFrame(nsFrameConstructorState& aState,
   1:                                                 nsIContent*              aContent,
   1:                                                 nsStyleContext*          aContentStyle,
   1:                                                 nsIFrame*                aParentFrame,
   1:                                                 nsIFrame*                aContentParentFrame,
   1:                                                 nsIAtom*                 aScrolledPseudo,
   1:                                                 PRBool                   aIsRoot,
   1:                                                 nsIFrame*&               aNewFrame)
   1: {
   1:   nsIFrame* parentFrame = nsnull;
   1:   nsIFrame* gfxScrollFrame = aNewFrame;
   1: 
   1:   nsFrameItems anonymousItems;
   1: 
   1:   nsRefPtr<nsStyleContext> contentStyle = aContentStyle;
   1: 
   1:   if (!gfxScrollFrame) {
   1:     // Build a XULScrollFrame when the child is a box, otherwise an
   1:     // HTMLScrollFrame
   1:     if (IsXULDisplayType(aContentStyle->GetStyleDisplay())) {
   1:       gfxScrollFrame = NS_NewXULScrollFrame(mPresShell, contentStyle, aIsRoot);
   1:     } else {
   1:       gfxScrollFrame = NS_NewHTMLScrollFrame(mPresShell, contentStyle, aIsRoot);
   1:     }
   1: 
   1:     InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, gfxScrollFrame);
   1: 
   1:     // Create a view
   1:     nsHTMLContainerFrame::CreateViewForFrame(gfxScrollFrame,
   1:                                              aContentParentFrame, PR_FALSE);
   1:   }
   1: 
   1:   // if there are any anonymous children for the scroll frame, create
   1:   // frames for them.
   1:   CreateAnonymousFrames(aState, aContent, mDocument, gfxScrollFrame,
   1:                         PR_FALSE, anonymousItems);
   1: 
   1:   parentFrame = gfxScrollFrame;
   1:   aNewFrame = gfxScrollFrame;
   1: 
   1:   // we used the style that was passed in. So resolve another one.
   1:   nsStyleSet *styleSet = mPresShell->StyleSet();
   1:   nsStyleContext* aScrolledChildStyle = styleSet->ResolvePseudoStyleFor(aContent,
   1:                                                                         aScrolledPseudo,
   1:                                                                         contentStyle).get();
   1: 
   1:   if (gfxScrollFrame) {
   1:      gfxScrollFrame->SetInitialChildList(nsnull, anonymousItems.childList);
   1:   }
   1: 
   1:   return aScrolledChildStyle;
   1: }
   1: 
   1: void
   1: nsCSSFrameConstructor::FinishBuildingScrollFrame(nsIFrame* aScrollFrame,
   1:                                                  nsIFrame* aScrolledFrame)
   1: {
   1:   aScrollFrame->AppendFrames(nsnull, aScrolledFrame);
   1: 
   1:   // force the scrolled frame to have a view. The view will be parented to
   1:   // the correct anonymous inner view because the scrollframes override
   1:   // nsIFrame::GetParentViewForChildFrame.
   1:   nsHTMLContainerFrame::CreateViewForFrame(aScrolledFrame, nsnull, PR_TRUE);
   1:   nsIView* view = aScrolledFrame->GetView();
   1:   if (!view)
   1:     return;
   1: }
   1: 
   1: 
   1: /**
   1:  * Called to wrap a gfx scrollframe around a frame. The hierarchy will look like this
   1:  *
   1:  * ------- for gfx scrollbars ------
   1:  *
   1:  *
   1:  *            ScrollFrame
   1:  *                 ^
   1:  *                 |
   1:  *               Frame (scrolled frame you passed in)
   1:  *
   1:  *
   1:  *-----------------------------------
   1:  * LEGEND:
   1:  * 
   1:  * ScrollFrame: This is a frame that manages gfx cross platform frame based scrollbars.
   1:  *
   1:  * @param aContent the content node of the child to wrap.
   1:  * @param aScrolledFrame The frame of the content to wrap. This should not be
   1:  *                    Initialized. This method will initialize it with a scrolled pseudo
   1:  *                    and no nsIContent. The content will be attached to the scrollframe 
   1:  *                    returned.
   1:  * @param aContentStyle the style context that has already been resolved for the content being passed in.
   1:  *
   1:  * @param aParentFrame The parent to attach the scroll frame to
   1:  *
   1:  * @param aNewFrame The new scrollframe or gfx scrollframe that we create. It will contain the
   1:  *                  scrolled frame you passed in. (returned)
   1:  *                  If this is not null, we'll just use it
   1:  * @param aScrolledContentStyle the style that was resolved for the scrolled frame. (returned)
   1:  */
   1: nsresult
   1: nsCSSFrameConstructor::BuildScrollFrame(nsFrameConstructorState& aState,
   1:                                         nsIContent*              aContent,
   1:                                         nsStyleContext*          aContentStyle,
   1:                                         nsIFrame*                aScrolledFrame,
   1:                                         nsIFrame*                aParentFrame,
   1:                                         nsIFrame*                aContentParentFrame,
   1:                                         nsIFrame*&               aNewFrame, 
   1:                                         nsStyleContext*&         aScrolledContentStyle)
   1: {
   1:     nsRefPtr<nsStyleContext> scrolledContentStyle =
   1:       BeginBuildingScrollFrame(aState, aContent, aContentStyle, aParentFrame,
   1:                                aContentParentFrame, nsCSSAnonBoxes::scrolledContent,
   1:                                PR_FALSE, aNewFrame);
   1:     
   1:     aScrolledFrame->SetStyleContextWithoutNotification(scrolledContentStyle);
   1:     InitAndRestoreFrame(aState, aContent, aNewFrame, nsnull, aScrolledFrame);
   1: 
   1:     FinishBuildingScrollFrame(aNewFrame, aScrolledFrame);
   1: 
   1:     aScrolledContentStyle = scrolledContentStyle;
   1: 
   1:     // now set the primary frame to the ScrollFrame
   1:     aState.mFrameManager->SetPrimaryFrameFor( aContent, aNewFrame );
   1:     return NS_OK;
   1: 
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructFrameByDisplayType(nsFrameConstructorState& aState,
   1:                                                    const nsStyleDisplay*    aDisplay,
   1:                                                    nsIContent*              aContent,
   1:                                                    PRInt32                  aNameSpaceID,
   1:                                                    nsIAtom*                 aTag,
   1:                                                    nsIFrame*                aParentFrame,
   1:                                                    nsStyleContext*          aStyleContext,
   1:                                                    nsFrameItems&            aFrameItems,
   1:                                                    PRBool                   aHasPseudoParent)
   1: {
   1:   PRBool    primaryFrameSet = PR_FALSE;
   1:   nsIFrame* newFrame = nsnull;  // the frame we construct
   1:   PRBool    addToHashTable = PR_TRUE;
   1:   PRBool    addedToFrameList = PR_FALSE;
   1:   nsresult  rv = NS_OK;
   1: 
   1:   // The style system ensures that floated and positioned frames are
   1:   // block-level.
   1:   NS_ASSERTION(!(aDisplay->IsFloating() ||
   1:                  aDisplay->IsAbsolutelyPositioned()) ||
2829:                aDisplay->IsBlockOutside(),
   1:                "Style system did not apply CSS2.1 section 9.7 fixups");
   1: 
   1:   // If this is "body", try propagating its scroll style to the viewport
   1:   // Note that we need to do this even if the body is NOT scrollable;
   1:   // it might have dynamically changed from scrollable to not scrollable,
   1:   // and that might need to be propagated.
   1:   PRBool propagatedScrollToViewport = PR_FALSE;
   1:   if (aContent->NodeInfo()->Equals(nsGkAtoms::body) &&
   1:       aContent->IsNodeOfType(nsINode::eHTML)) {
   1:     propagatedScrollToViewport =
   1:       PropagateScrollToViewport() == aContent;
   1:   }
   1: 
   1:   // If the frame is a block-level frame and is scrollable, then wrap it
   1:   // in a scroll frame.
   1:   // XXX Ignore tables for the time being
   1:   if (aDisplay->IsBlockInside() &&
   1:       aDisplay->IsScrollableOverflow() &&
   1:       !propagatedScrollToViewport) {
   1: 
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1: 
   1:     nsRefPtr<nsStyleContext> scrolledContentStyle
   1:       = BeginBuildingScrollFrame(aState, aContent, aStyleContext,
   1:                                  aState.GetGeometricParent(aDisplay, aParentFrame),
   1:                                  aParentFrame,
   1:                                  nsCSSAnonBoxes::scrolledContent,
   1:                                  PR_FALSE, newFrame);
   1:     
   1:     // Initialize it
   1:     // pass a temporary stylecontext, the correct one will be set later
   1:     nsIFrame* scrolledFrame =
   1:         NS_NewAreaFrame(mPresShell, aStyleContext,
   1:                         NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT);
   1: 
   1:     nsFrameItems blockItem;
   1:     rv = ConstructBlock(aState,
   1:                         scrolledContentStyle->GetStyleDisplay(), aContent,
   1:                         newFrame, newFrame, scrolledContentStyle,
   1:                         &scrolledFrame, blockItem, aDisplay->IsPositioned());
   1:     NS_ASSERTION(blockItem.childList == scrolledFrame,
   1:                  "Scrollframe's frameItems should be exactly the scrolled frame");
   1:     FinishBuildingScrollFrame(newFrame, scrolledFrame);
   1: 
   1:     rv = aState.AddChild(newFrame, aFrameItems, aDisplay, aContent,
   1:                          aStyleContext, aParentFrame);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1: 
   1:     addedToFrameList = PR_TRUE;
   1:   }
   1:   // See if the frame is absolute or fixed positioned
   1:   else if (aDisplay->IsAbsolutelyPositioned() &&
   1:            (NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay ||
   1:             NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay)) {
   1: 
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1: 
   1:     // Create a frame to wrap up the absolute positioned item
   1:     // pass a temporary stylecontext, the correct one will be set later
   1:     newFrame = NS_NewAbsoluteItemWrapperFrame(mPresShell, aStyleContext);
   1: 
   1:     rv = ConstructBlock(aState, aDisplay, aContent,
   1:                         aState.GetGeometricParent(aDisplay, aParentFrame), aParentFrame,
   1:                         aStyleContext, &newFrame, aFrameItems, PR_TRUE);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1: 
   1:     addedToFrameList = PR_TRUE;
   1:   }
   1:   // See if the frame is floated and it's a block frame
   1:   else if (aDisplay->IsFloating() &&
   1:            (NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay ||
   1:             NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay)) {
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     // Create an area frame
   1:     // pass a temporary stylecontext, the correct one will be set later
   1:     newFrame = NS_NewFloatingItemWrapperFrame(mPresShell, aStyleContext);
   1: 
   1:     rv = ConstructBlock(aState, aDisplay, aContent, 
   1:                         aState.GetGeometricParent(aDisplay, aParentFrame),
   1:                         aParentFrame, aStyleContext, &newFrame, aFrameItems,
   1:                         aDisplay->mPosition == NS_STYLE_POSITION_RELATIVE);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1: 
   1:     addedToFrameList = PR_TRUE;
   1:   }
   1:   // See if it's relatively positioned
   1:   else if ((NS_STYLE_POSITION_RELATIVE == aDisplay->mPosition) &&
   1:            ((NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay) ||
   1:             (NS_STYLE_DISPLAY_INLINE == aDisplay->mDisplay) ||
   1:             (NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay))) {
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     // Is it block-level or inline-level?
   1:     if ((NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay) ||
   1:         (NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay)) {
   1:       // Create a wrapper frame. No space manager, though
   1:       newFrame = NS_NewRelativeItemWrapperFrame(mPresShell, aStyleContext);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       ConstructBlock(aState, aDisplay, aContent,
   1:                      aParentFrame, nsnull, aStyleContext, &newFrame,
   1:                      aFrameItems, PR_TRUE);
   1:       addedToFrameList = PR_TRUE;
   1:     } else {
   1:       // Create a positioned inline frame
   1:       newFrame = NS_NewPositionedInlineFrame(mPresShell, aStyleContext);
   1:       // Note that we want to insert the inline after processing kids, since
   1:       // processing of kids may split the inline.
   1:       ConstructInline(aState, aDisplay, aContent,
   1:                       aParentFrame, aStyleContext, PR_TRUE, newFrame);
   1:     }
   1:   }
   1:   // See if it's a block frame of some sort
   1:   else if ((NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay) ||
   1:            (NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay) ||
   1:            (NS_STYLE_DISPLAY_RUN_IN == aDisplay->mDisplay) ||
   1:            (NS_STYLE_DISPLAY_COMPACT == aDisplay->mDisplay) ||
   1:            (NS_STYLE_DISPLAY_INLINE_BLOCK == aDisplay->mDisplay)) {
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     PRUint32 flags = 0;
   1:     if (NS_STYLE_DISPLAY_INLINE_BLOCK == aDisplay->mDisplay) {
   1:       flags = NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT;
   1:     }
   1:     // Create the block frame
   1:     newFrame = NS_NewBlockFrame(mPresShell, aStyleContext, flags);
   1:     if (newFrame) { // That worked so construct the block and its children
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       rv = ConstructBlock(aState, aDisplay, aContent,
   1:                           aParentFrame, nsnull, aStyleContext, &newFrame,
   1:                           aFrameItems, PR_FALSE);
   1:       addedToFrameList = PR_TRUE;
   1:     }
   1:     else {
   1:       rv = NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:   }
   1:   // See if it's an inline frame of some sort
   1:   else if ((NS_STYLE_DISPLAY_INLINE == aDisplay->mDisplay) ||
   1:            (NS_STYLE_DISPLAY_MARKER == aDisplay->mDisplay)) {
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:     // Create the inline frame
   1:     newFrame = NS_NewInlineFrame(mPresShell, aStyleContext);
   1:     if (newFrame) { // That worked so construct the inline and its children
   1:       // Note that we want to insert the inline after processing kids, since
   1:       // processing of kids may split the inline.
   1:       rv = ConstructInline(aState, aDisplay, aContent,
   1:                            aParentFrame, aStyleContext, PR_FALSE, newFrame);
   1:     }
   1:     else {
   1:       rv = NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1: 
   1:     // To keep the hash table small don't add inline frames (they're
   1:     // typically things like FONT and B), because we can quickly
   1:     // find them if we need to
   1:     addToHashTable = PR_FALSE;
   1:   }
   1:   // otherwise let the display property influence the frame type to create
   1:   else {
   1:     // XXX This section now only handles table frames; should be
   1:     // factored out probably
   1: 
   1:     // Use the 'display' property to choose a frame type
   1:     switch (aDisplay->mDisplay) {
   1:     case NS_STYLE_DISPLAY_TABLE:
   1:     case NS_STYLE_DISPLAY_INLINE_TABLE:
   1:     {
   1:       nsIFrame* innerTable;
   1:       rv = ConstructTableFrame(aState, aContent, 
   1:                                aParentFrame, aStyleContext,
   1:                                aNameSpaceID, PR_FALSE, aFrameItems, PR_TRUE,
   1:                                newFrame, innerTable);
   1:       addedToFrameList = PR_TRUE;
   1:       // Note: table construction function takes care of initializing
   1:       // the frame, processing children, and setting the initial child
   1:       // list
   1:       break;
   1:     }
   1:   
   1:     // the next 5 cases are only relevant if the parent is not a table, ConstructTableFrame handles children
   1:     case NS_STYLE_DISPLAY_TABLE_CAPTION:
   1:     {
   1:       // aParentFrame may be an inner table frame rather than an outer frame 
   1:       // In this case we need to get the outer frame.
4194:       nsIFrame* parentFrame = AdjustCaptionParentFrame(aParentFrame);
   1:       rv = ConstructTableCaptionFrame(aState, aContent, parentFrame,
   1:                                       aStyleContext, aNameSpaceID, aFrameItems,
   1:                                       newFrame, aHasPseudoParent);
   1:       if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
   1:         aFrameItems.AddChild(newFrame);
   1:       }
   1:       return rv;
   1:     }
   1: 
   1:     case NS_STYLE_DISPLAY_TABLE_ROW_GROUP:
   1:     case NS_STYLE_DISPLAY_TABLE_HEADER_GROUP:
   1:     case NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP:
   1:       rv = ConstructTableRowGroupFrame(aState, aContent, aParentFrame,
   1:                                        aStyleContext, aNameSpaceID, PR_FALSE,
   1:                                        aFrameItems, newFrame,
   1:                                        aHasPseudoParent);
   1:       if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
   1:         aFrameItems.AddChild(newFrame);
   1:       }
   1:       return rv;
   1: 
   1:     case NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP:
   1:       rv = ConstructTableColGroupFrame(aState, aContent, aParentFrame,
   1:                                        aStyleContext, aNameSpaceID,
   1:                                        PR_FALSE, aFrameItems, newFrame,
   1:                                        aHasPseudoParent);
   1:       if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
   1:         aFrameItems.AddChild(newFrame);
   1:       }
   1:       return rv;
   1:    
   1:     case NS_STYLE_DISPLAY_TABLE_COLUMN:
   1:       rv = ConstructTableColFrame(aState, aContent, aParentFrame,
   1:                                   aStyleContext, aNameSpaceID, PR_FALSE,
   1:                                   aFrameItems, newFrame, aHasPseudoParent);
   1:       if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
   1:         aFrameItems.AddChild(newFrame);
   1:       }
   1:       return rv;
   1:   
   1:     case NS_STYLE_DISPLAY_TABLE_ROW:
   1:       rv = ConstructTableRowFrame(aState, aContent, aParentFrame,
   1:                                   aStyleContext, aNameSpaceID, PR_FALSE,
   1:                                   aFrameItems, newFrame, aHasPseudoParent);
   1:       if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
   1:         aFrameItems.AddChild(newFrame);
   1:       }
   1:       return rv;
   1:   
   1:     case NS_STYLE_DISPLAY_TABLE_CELL:
   1:       {
   1:         nsIFrame* innerTable;
   1:         rv = ConstructTableCellFrame(aState, aContent, aParentFrame,
   1:                                      aStyleContext, aNameSpaceID,
   1:                                      PR_FALSE, aFrameItems, newFrame,
   1:                                      innerTable, aHasPseudoParent);
   1:         if (NS_SUCCEEDED(rv) && !aHasPseudoParent) {
   1:           aFrameItems.AddChild(newFrame);
   1:         }
   1:         return rv;
   1:       }
   1:   
   1:     default:
   1:       NS_NOTREACHED("How did we get here?");
   1:       break;
   1:     }
   1:   }
   1: 
   1:   if (!addedToFrameList) {
   1:     // Gotta do it here
   1:     NS_ASSERTION(!aDisplay->IsAbsolutelyPositioned() &&
   1:                  !aDisplay->IsFloating(),
   1:                  "Things that could be out-of-flow need to handle adding "
   1:                  "to the frame list themselves");
   1:     
   1:     rv = aState.AddChild(newFrame, aFrameItems, aDisplay, aContent,
   1:                          aStyleContext, aParentFrame);
   1:     NS_ASSERTION(NS_SUCCEEDED(rv),
   1:                  "Cases where AddChild() can fail must handle it themselves");
   1:   }
   1: 
   1:   if (newFrame && addToHashTable) {
   1:     // Add a mapping from content object to primary frame. Note that for
   1:     // floated and positioned frames this is the out-of-flow frame and not
   1:     // the placeholder frame
   1:     if (!primaryFrameSet) {
   1:       aState.mFrameManager->SetPrimaryFrameFor(aContent, newFrame);
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult 
   1: nsCSSFrameConstructor::InitAndRestoreFrame(const nsFrameConstructorState& aState,
   1:                                            nsIContent*              aContent,
   1:                                            nsIFrame*                aParentFrame,
   1:                                            nsIFrame*                aPrevInFlow,
   1:                                            nsIFrame*                aNewFrame,
   1:                                            PRBool                   aAllowCounters)
   1: {
   1:   nsresult rv = NS_OK;
   1:   
   1:   NS_ASSERTION(aNewFrame, "Null frame cannot be initialized");
   1:   if (!aNewFrame)
   1:     return NS_ERROR_NULL_POINTER;
   1: 
   1:   // Initialize the frame
   1:   rv = aNewFrame->Init(aContent, aParentFrame, aPrevInFlow);
   1: 
   1:   if (aState.mFrameState && aState.mFrameManager) {
   1:     // Restore frame state for just the newly created frame.
   1:     aState.mFrameManager->RestoreFrameStateFor(aNewFrame, aState.mFrameState);
   1:   }
   1: 
   1:   if (aAllowCounters && !aPrevInFlow &&
   1:       mCounterManager.AddCounterResetsAndIncrements(aNewFrame)) {
   1:     CountersDirty();
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: already_AddRefed<nsStyleContext>
   1: nsCSSFrameConstructor::ResolveStyleContext(nsIFrame*         aParentFrame,
   1:                                            nsIContent*       aContent)
   1: {
 822:   nsStyleContext* parentStyleContext;
 822:   if (aContent->GetParent()) {
 549:     aParentFrame = nsFrame::CorrectStyleParentFrame(aParentFrame, nsnull);
 549:   
   1:     // Resolve the style context based on the content object and the parent
   1:     // style context
 822:     parentStyleContext = aParentFrame->GetStyleContext();
 822:   } else {
 822:     // This has got to be a call from ConstructDocElementTableFrame.
 822:     // Not sure how best to asserrt that here.
 822:     parentStyleContext = nsnull;
 822:   }
   1: 
   1:   nsStyleSet *styleSet = mPresShell->StyleSet();
   1: 
   1:   if (aContent->IsNodeOfType(nsINode::eELEMENT)) {
   1:     return styleSet->ResolveStyleFor(aContent, parentStyleContext);
   1:   } else {
   1: 
   1:     NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
   1:                  "shouldn't waste time creating style contexts for "
   1:                  "comments and processing instructions");
   1: 
   1:     return styleSet->ResolveStyleForNonElement(parentStyleContext);
   1:   }
   1: }
   1: 
   1: // MathML Mod - RBS
   1: #ifdef MOZ_MATHML
   1: nsresult
   1: nsCSSFrameConstructor::ConstructMathMLFrame(nsFrameConstructorState& aState,
   1:                                             nsIContent*              aContent,
   1:                                             nsIFrame*                aParentFrame,
   1:                                             nsIAtom*                 aTag,
   1:                                             PRInt32                  aNameSpaceID,
   1:                                             nsStyleContext*          aStyleContext,
   1:                                             nsFrameItems&            aFrameItems,
   1:                                             PRBool                   aHasPseudoParent)
   1: {
   1:   // Make sure that we remain confined in the MathML world
   1:   if (aNameSpaceID != kNameSpaceID_MathML) 
   1:     return NS_OK;
   1: 
   1:   nsresult  rv = NS_OK;
   1:   PRBool    ignoreInterTagWhitespace = PR_TRUE;
   1: 
   1:   NS_ASSERTION(aTag != nsnull, "null MathML tag");
   1:   if (aTag == nsnull)
   1:     return NS_OK;
   1: 
   1:   // Initialize the new frame
   1:   nsIFrame* newFrame = nsnull;
   1: 
   1:   // Make sure to keep IsSpecialContent in synch with this code
   1:   const nsStyleDisplay* disp = aStyleContext->GetStyleDisplay();
   1: 
   1:   // Leverage IsSpecialContent to check if one of the |if aTag| below will
   1:   // surely match (knowing that aNameSpaceID == kNameSpaceID_MathML here)
 442:   if (IsSpecialContent(aContent, aTag, aNameSpaceID, aStyleContext)) {
   1:     // process pending pseudo frames
   1:     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
   1:       ProcessPseudoFrames(aState, aFrameItems); 
   1:     }
   1:   }
   1: 
   1:   if (aTag == nsGkAtoms::mi_ ||
   1:       aTag == nsGkAtoms::mn_ ||
   1:       aTag == nsGkAtoms::ms_ ||
   1:       aTag == nsGkAtoms::mtext_)
   1:     newFrame = NS_NewMathMLTokenFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::mo_)
   1:     newFrame = NS_NewMathMLmoFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::mfrac_)
   1:     newFrame = NS_NewMathMLmfracFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::msup_)
   1:     newFrame = NS_NewMathMLmsupFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::msub_)
   1:     newFrame = NS_NewMathMLmsubFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::msubsup_)
   1:     newFrame = NS_NewMathMLmsubsupFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::munder_)
   1:     newFrame = NS_NewMathMLmunderFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::mover_)
   1:     newFrame = NS_NewMathMLmoverFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::munderover_)
   1:     newFrame = NS_NewMathMLmunderoverFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::mphantom_)
   1:     newFrame = NS_NewMathMLmphantomFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::mpadded_)
   1:     newFrame = NS_NewMathMLmpaddedFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::mspace_ ||
   1:            aTag == nsGkAtoms::none    ||
   1:            aTag == nsGkAtoms::mprescripts_)
   1:     newFrame = NS_NewMathMLmspaceFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::mfenced_)
   1:     newFrame = NS_NewMathMLmfencedFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::mmultiscripts_)
   1:     newFrame = NS_NewMathMLmmultiscriptsFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::mstyle_)
   1:     newFrame = NS_NewMathMLmstyleFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::msqrt_)
   1:     newFrame = NS_NewMathMLmsqrtFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::mroot_)
   1:     newFrame = NS_NewMathMLmrootFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::maction_)
   1:     newFrame = NS_NewMathMLmactionFrame(mPresShell, aStyleContext);
   1:   else if (aTag == nsGkAtoms::mrow_ ||
   1:            aTag == nsGkAtoms::merror_)
   1:     newFrame = NS_NewMathMLmrowFrame(mPresShell, aStyleContext);
   1:   // CONSTRUCTION of MTABLE elements
   1:   else if (aTag == nsGkAtoms::mtable_ &&
   1:            disp->mDisplay == NS_STYLE_DISPLAY_TABLE) {
   1:     // <mtable> is an inline-table -- but this isn't yet supported.
   1:     // What we do here is to wrap the table in an anonymous containing
   1:     // block so that it can mix better with other surrounding MathML markups
   1:     // This assumes that the <mtable> is not positioned or floated.
   1:     // (MathML does not allow/support positioned or floated elements at all.)
 442:     // XXXbz once we stop doing this mess, fix IsSpecialContent accordingly.
   1: 
   1:     nsStyleContext* parentContext = aParentFrame->GetStyleContext();
   1:     nsStyleSet *styleSet = mPresShell->StyleSet();
   1: 
   1:     // first, create a MathML mrow frame that will wrap the block frame
   1:     nsRefPtr<nsStyleContext> mrowContext;
   1:     mrowContext = styleSet->ResolvePseudoStyleFor(aContent,
   1:                                                   nsCSSAnonBoxes::mozMathInline,
   1:                                                   parentContext);
   1:     newFrame = NS_NewMathMLmrowFrame(mPresShell, mrowContext);
   1:     if (NS_UNLIKELY(!newFrame)) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:     InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, newFrame);
   1: 
   1:     
   1:     nsRefPtr<nsStyleContext> blockContext;
   1:     blockContext = styleSet->ResolvePseudoStyleFor(aContent,
 680:                                                    nsCSSAnonBoxes::mozMathMLAnonymousBlock,
   1:                                                    mrowContext);
   1:     
   1:     // then, create a block frame that will wrap the table frame
   1:     nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, blockContext,
   1:                                             NS_BLOCK_SPACE_MGR |
   1:                                             NS_BLOCK_MARGIN_ROOT);
   1:     if (NS_UNLIKELY(!newFrame)) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:     InitAndRestoreFrame(aState, aContent, newFrame, nsnull, blockFrame);
   1: 
   1:     // then, create the table frame itself
4170:     nsRefPtr<nsStyleContext> tableContext =
4170:       ResolveStyleContext(blockFrame, aContent);
   1: 
   1:     nsFrameItems tempItems;
   1:     nsIFrame* outerTable;
   1:     nsIFrame* innerTable;
   1:     
 442:     // XXXbz note: since we're constructing a table frame, and it does things
 442:     // based on whether its parent is a pseudo or not, we need to save our
 442:     // pseudo state here.  This can go away if we switch to a direct
 442:     // construction of mtable as an inline-table.
 442:     nsPseudoFrames priorPseudoFrames; 
 442:     aState.mPseudoFrames.Reset(&priorPseudoFrames);
 442: 
   1:     // Pass PR_FALSE for aAllowOutOfFlow so that the resulting table will be
   1:     // guaranteed to be in-flow (and in particular, a descendant of the <math>
   1:     // in the _frame_ tree).
   1:     rv = ConstructTableFrame(aState, aContent, blockFrame, tableContext,
   1:                              aNameSpaceID, PR_FALSE, tempItems, PR_FALSE,
   1:                              outerTable, innerTable);
   1:     // Note: table construction function takes care of initializing the frame,
   1:     // processing children, and setting the initial child list
   1: 
 442:     NS_ASSERTION(aState.mPseudoFrames.IsEmpty(),
 442:                  "How did we end up with pseudo-frames here?");
 442: 
 442:     // restore the incoming pseudo frame state.  Note that we MUST do this
 442:     // before adding things to aFrameItems.
 442:     aState.mPseudoFrames = priorPseudoFrames;
 442:     
   1:     // set the outerTable as the initial child of the anonymous block
   1:     blockFrame->SetInitialChildList(nsnull, outerTable);
   1: 
   1:     // set the block frame as the initial child of the mrow frame
   1:     newFrame->SetInitialChildList(nsnull, blockFrame);
   1: 
   1:     // add the new frame to the flow
   1:     // XXXbz this is wrong.  What if it's out-of-flow?  For that matter, this
   1:     // is putting the frame in the wrong child list in the "pseudoParent ==
   1:     // PR_TRUE" case, which I assume we can hit.
   1:     aFrameItems.AddChild(newFrame);
   1: 
   1:     return rv; 
   1:   }
   1:   // End CONSTRUCTION of MTABLE elements 
   1: 
   1:   else if (aTag == nsGkAtoms::math) { 
   1:     // root <math> element
   1:     const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
   1:     PRBool isBlock = (NS_STYLE_DISPLAY_BLOCK == display->mDisplay);
   1:     newFrame = NS_NewMathMLmathFrame(mPresShell, isBlock, aStyleContext);
   1:   }
   1:   else {
   1:     return NS_OK;
   1:   }
   1: 
   1:   // If we succeeded in creating a frame then initialize it, process its
   1:   // children (if requested), and set the initial child list
   1:   if (newFrame) {
   1:     // record that children that are ignorable whitespace should be excluded
   1:     if (ignoreInterTagWhitespace) {
   1:       newFrame->AddStateBits(NS_FRAME_EXCLUDE_IGNORABLE_WHITESPACE);
   1:     }
   1: 
   1:     // Only <math> elements can be floated or positioned.  All other MathML
   1:     // should be in-flow.
   1:     PRBool isMath = aTag == nsGkAtoms::math;
   1: 
   1:     nsIFrame* geometricParent =
   1:       isMath ? aState.GetGeometricParent(disp, aParentFrame) : aParentFrame;
   1:     
   1:     InitAndRestoreFrame(aState, aContent, geometricParent, nsnull, newFrame);
   1: 
   1:     // See if we need to create a view, e.g. the frame is absolutely positioned
   1:     nsHTMLContainerFrame::CreateViewForFrame(newFrame, aParentFrame, PR_FALSE);
   1: 
   1:     rv = aState.AddChild(newFrame, aFrameItems, disp, aContent, aStyleContext,
   1:                          aParentFrame, isMath, isMath);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1: 
   1:     // Push a null float containing block to disable floating within mathml
   1:     nsFrameConstructorSaveState floatSaveState;
   1:     aState.PushFloatContainingBlock(nsnull, floatSaveState, PR_FALSE,
   1:                                     PR_FALSE);
   1: 
   1:     // Same for absolute positioning
   1:     nsFrameConstructorSaveState absoluteSaveState;
   1:     aState.PushAbsoluteContainingBlock(nsnull, absoluteSaveState);
   1: 
   1:     // MathML frames are inline frames, so just process their kids
   1:     nsFrameItems childItems;
   1:     if (!newFrame->IsLeaf()) {
   1:       rv = ProcessChildren(aState, aContent, newFrame, PR_TRUE,
   1:                            childItems, PR_FALSE);
   1:     }
   1: 
   1:     CreateAnonymousFrames(aTag, aState, aContent, newFrame, PR_FALSE,
   1:                           childItems);
   1: 
   1:     // Set the frame's initial child list
   1:     newFrame->SetInitialChildList(nsnull, childItems.childList);
   1:  
   1:     return rv;
   1:   }
   1:   else {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: }
   1: #endif // MOZ_MATHML
   1: 
   1: // SVG 
   1: #ifdef MOZ_SVG
   1: nsresult
   1: nsCSSFrameConstructor::TestSVGConditions(nsIContent* aContent,
   1:                                          PRBool&     aHasRequiredExtensions,
   1:                                          PRBool&     aHasRequiredFeatures,
   1:                                          PRBool&     aHasSystemLanguage)
   1: {
   1:   nsAutoString value;
   1: 
   1:   // Only elements can have tests on them
   1:   if (! aContent->IsNodeOfType(nsINode::eELEMENT)) {
   1:     aHasRequiredExtensions = PR_FALSE;
   1:     aHasRequiredFeatures = PR_FALSE;
   1:     aHasSystemLanguage = PR_FALSE;
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Required Extensions
   1:   //
   1:   // The requiredExtensions  attribute defines a list of required language
   1:   // extensions. Language extensions are capabilities within a user agent that
   1:   // go beyond the feature set defined in the SVG specification.
   1:   // Each extension is identified by a URI reference.
   1:   // For now, claim that mozilla's SVG implementation supports
   1:   // no extensions.  So, if extensions are required, we don't have
   1:   // them available. Empty-string should always set aHasRequiredExtensions to
   1:   // false.
   1:   aHasRequiredExtensions = !aContent->HasAttr(kNameSpaceID_None,
   1:                                               nsGkAtoms::requiredExtensions);
   1: 
   1:   // Required Features
   1:   aHasRequiredFeatures = PR_TRUE;
   1:   if (aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::requiredFeatures, value)) {
   1:     aHasRequiredFeatures = !value.IsEmpty() && NS_SVG_TestFeatures(value);
   1:   }
   1: 
   1:   // systemLanguage
   1:   //
   1:   // Evaluates to "true" if one of the languages indicated by user preferences
   1:   // exactly equals one of the languages given in the value of this parameter,
   1:   // or if one of the languages indicated by user preferences exactly equals a
   1:   // prefix of one of the languages given in the value of this parameter such
   1:   // that the first tag character following the prefix is "-".
   1:   aHasSystemLanguage = PR_TRUE;
   1:   if (aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::systemLanguage,
   1:                         value)) {
   1:     // Get our language preferences
   1:     nsAutoString langPrefs(nsContentUtils::GetLocalizedStringPref("intl.accept_languages"));
   1:     if (!langPrefs.IsEmpty()) {
   1:       langPrefs.StripWhitespace();
   1:       value.StripWhitespace();
   1: #ifdef  DEBUG_scooter
   1:       printf("Calling SVG_TestLanguage('%s','%s')\n", NS_ConvertUTF16toUTF8(value).get(), 
   1:                                                       NS_ConvertUTF16toUTF8(langPrefs).get());
   1: #endif
   1:       aHasSystemLanguage = SVG_TestLanguage(value, langPrefs);
   1:     } else {
   1:       // For now, evaluate to true.
   1:       NS_WARNING("no default language specified for systemLanguage conditional test");
   1:       aHasSystemLanguage = !value.IsEmpty();
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::SVGSwitchProcessChildren(nsFrameConstructorState& aState,
   1:                                                 nsIContent*              aContent,
   1:                                                 nsIFrame*                aFrame,
   1:                                                 nsFrameItems&            aFrameItems)
   1: {
   1:   nsresult rv = NS_OK;
   1:   PRBool hasRequiredExtensions = PR_FALSE;
   1:   PRBool hasRequiredFeatures = PR_FALSE;
   1:   PRBool hasSystemLanguage = PR_FALSE;
   1: 
   1:   // save the incoming pseudo frame state
   1:   nsPseudoFrames priorPseudoFrames;
   1:   aState.mPseudoFrames.Reset(&priorPseudoFrames);
   1: 
   1:   // The 'switch' element evaluates the requiredFeatures,
   1:   // requiredExtensions and systemLanguage attributes on its direct child
   1:   // elements in order, and then processes and renders the first child for
   1:   // which these attributes evaluate to true. All others will be bypassed and
   1:   // therefore not rendered.
   1:   PRInt32 childCount = aContent->GetChildCount();
   1:   for (PRInt32 i = 0; i < childCount; ++i) {
   1:     nsIContent* child = aContent->GetChildAt(i);
   1: 
   1:     // Skip over children that aren't elements
   1:     if (!child->IsNodeOfType(nsINode::eELEMENT)) {
   1:       continue;
   1:     }
   1: 
   1:     rv = TestSVGConditions(child,
   1:                            hasRequiredExtensions,
   1:                            hasRequiredFeatures,
   1:                            hasSystemLanguage);
   1: #ifdef DEBUG_scooter
   1:     nsAutoString str;
   1:     child->Tag()->ToString(str);
   1:     printf("Child tag: %s\n", NS_ConvertUTF16toUTF8(str).get());
   1:     printf("SwitchProcessChildren: Required Extensions = %s, Required Features = %s, System Language = %s\n",
   1:             hasRequiredExtensions ? "true" : "false",
   1:             hasRequiredFeatures ? "true" : "false",
   1:             hasSystemLanguage ? "true" : "false");
   1: #endif
   1:     if (NS_FAILED(rv))
   1:       return rv;
   1: 
   1:     if (hasRequiredExtensions &&
   1:         hasRequiredFeatures &&
   1:         hasSystemLanguage) {
   1: 
   1:       rv = ConstructFrame(aState, child,
   1:                           aFrame, aFrameItems);
   1: 
   1:       if (NS_FAILED(rv))
   1:         return rv;
   1: 
   1:       // No errors -- break out of loop (only render the first matching element)
   1:       break;
   1:     }
   1:   }
   1: 
   1:   // process the current pseudo frame state
   1:   if (!aState.mPseudoFrames.IsEmpty()) {
   1:     ProcessPseudoFrames(aState, aFrameItems);
   1:   }
   1: 
   1:   // restore the incoming pseudo frame state
   1:   aState.mPseudoFrames = priorPseudoFrames;
   1: 
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructSVGFrame(nsFrameConstructorState& aState,
   1:                                          nsIContent*              aContent,
   1:                                          nsIFrame*                aParentFrame,
   1:                                          nsIAtom*                 aTag,
   1:                                          PRInt32                  aNameSpaceID,
   1:                                          nsStyleContext*          aStyleContext,
   1:                                          nsFrameItems&            aFrameItems,
   1:                                          PRBool                   aHasPseudoParent,
   1:                                          PRBool*                  aHaltProcessing)
   1: {
   1:   NS_ASSERTION(aNameSpaceID == kNameSpaceID_SVG, "SVG frame constructed in wrong namespace");
   1:   *aHaltProcessing = PR_FALSE;
   1: 
   1:   nsresult  rv = NS_OK;
   1:   PRBool forceView = PR_FALSE;
   1:   PRBool isOuterSVGNode = PR_FALSE;
   1:   const nsStyleDisplay* disp = aStyleContext->GetStyleDisplay();
   1:   
   1:   NS_ASSERTION(aTag != nsnull, "null SVG tag");
   1:   if (aTag == nsnull)
   1:     return NS_OK;
   1: 
   1:   // XXXbz somewhere here we should process pseudo frames if !aHasPseudoParent
   1: 
   1:   // Initialize the new frame
   1:   nsIFrame* newFrame = nsnull;
   1:  
   1:   // Default to aParentFrame for the geometricParent; it's adjusted in
   1:   // cases when we allow anything else.
   1:   nsIFrame* geometricParent = aParentFrame;
   1: 
   1:   PRBool parentIsSVG = PR_FALSE;
   1:   if (aParentFrame && aParentFrame->GetContent()) {
   1:     PRInt32 parentNSID;
   1:     nsIAtom* parentTag =
   1:       mDocument->BindingManager()->ResolveTag(aParentFrame->GetContent(),
   1:                                               &parentNSID);
   1: 
   1:     parentIsSVG = parentNSID == kNameSpaceID_SVG
   1: #ifdef MOZ_SVG_FOREIGNOBJECT
   1:                   // It's not clear whether the SVG spec intends to allow any SVG
   1:                   // content within svg:foreignObject at all (SVG 1.1, section
   1:                   // 23.2), but if it does, it better be svg:svg.  So given that
   1:                   // we're allowing it, treat it as a non-SVG parent.
   1:                   && parentTag != nsGkAtoms::foreignObject
   1: #endif
   1:                   ;
   1:   }
   1: 
   1:   if ((aTag != nsGkAtoms::svg && !parentIsSVG) ||
   1:       (aTag == nsGkAtoms::desc || aTag == nsGkAtoms::title)) {
   1:     // Sections 5.1 and G.4 of SVG 1.1 say that SVG elements other than
   1:     // svg:svg not contained within svg:svg are incorrect, although they
   1:     // don't seem to specify error handling.  Ignore them, since many of
   1:     // our frame classes can't deal.  It *may* be that the document
   1:     // should at that point be considered in error according to F.2, but
   1:     // it's hard to tell.
   1:     //
   1:     // Style mutation can't change this situation, so don't bother
   1:     // adding to the undisplayed content map.
   1:     //
   1:     // We don't currently handle any UI for desc/title
   1:     *aHaltProcessing = PR_TRUE;
   1:     return NS_OK;
   1:   }
   1:   
3441:   // Are we another child of a switch which already has a child
3441:   if (aParentFrame && 
3441:       aParentFrame->GetType() == nsGkAtoms::svgSwitch &&
3441:       aParentFrame->GetFirstChild(nsnull)) {
3441:     *aHaltProcessing = PR_TRUE;
3441:     return NS_OK;
3441:   }
3441: 
   1:   // See if this element supports conditionals & if it does,
   1:   // handle it
   1:   if (((aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::requiredFeatures) ||
   1:         aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::requiredExtensions)) &&
   1:         NS_SVG_TestsSupported(aTag)) ||
   1:       (aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::systemLanguage) &&
   1:        NS_SVG_LangSupported(aTag))) {
   1: 
   1:     PRBool hasRequiredExtentions = PR_FALSE;
   1:     PRBool hasRequiredFeatures = PR_FALSE;
   1:     PRBool hasSystemLanguage = PR_FALSE;
   1:     TestSVGConditions(aContent, hasRequiredExtentions, 
   1:                       hasRequiredFeatures, hasSystemLanguage);
   1:     // Note that just returning is probably not right.  According
   1:     // to the spec, <use> is allowed to use an element that fails its
   1:     // conditional, but because we never actually create the frame when
   1:     // a conditional fails and when we use GetReferencedFrame to find the
   1:     // references, things don't work right.
   1:     // XXX FIXME XXX
   1:     if (!hasRequiredExtentions || !hasRequiredFeatures ||
   1:         !hasSystemLanguage) {
   1:       *aHaltProcessing = PR_TRUE;
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   // Make sure to keep IsSpecialContent in synch with this code
   1:   if (aTag == nsGkAtoms::svg) {
   1:     if (!parentIsSVG) {
   1:       // This is the outermost <svg> element.
   1:       isOuterSVGNode = PR_TRUE;
   1: 
   1:       // Set the right geometricParent
   1:       geometricParent = aState.GetGeometricParent(disp, aParentFrame);
   1:       
   1:       forceView = PR_TRUE;
   1:       newFrame = NS_NewSVGOuterSVGFrame(mPresShell, aContent, aStyleContext);
   1:     }
   1:     else {
   1:       // This is an inner <svg> element
   1:       newFrame = NS_NewSVGInnerSVGFrame(mPresShell, aContent, aStyleContext);
   1:     }
   1:   }
   1:   else if (aTag == nsGkAtoms::g ||
   1:            aTag == nsGkAtoms::svgSwitch) {
   1:     newFrame = NS_NewSVGGFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::polygon ||
   1:            aTag == nsGkAtoms::polyline ||
   1:            aTag == nsGkAtoms::circle ||
   1:            aTag == nsGkAtoms::ellipse ||
   1:            aTag == nsGkAtoms::line ||
   1:            aTag == nsGkAtoms::rect ||
   1:            aTag == nsGkAtoms::path)
   1:     newFrame = NS_NewSVGPathGeometryFrame(mPresShell, aContent, aStyleContext);
   1:   else if (aTag == nsGkAtoms::defs) {
   1:     newFrame = NS_NewSVGContainerFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1: #ifdef MOZ_SVG_FOREIGNOBJECT
   1:   else if (aTag == nsGkAtoms::foreignObject) {
   1:     newFrame = NS_NewSVGForeignObjectFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1: #endif
   1:   else if (aTag == nsGkAtoms::a) {
   1:     newFrame = NS_NewSVGAFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::text) {
   1:     newFrame = NS_NewSVGTextFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::tspan) {
   1:     nsIFrame *ancestorFrame = SVG_GetFirstNonAAncestorFrame(aParentFrame);
   1:     if (ancestorFrame) {
   1:       nsISVGTextContentMetrics* metrics;
   1:       CallQueryInterface(ancestorFrame, &metrics);
   1:       if (metrics)
   1:         newFrame = NS_NewSVGTSpanFrame(mPresShell, aContent,
   1:                                        ancestorFrame, aStyleContext);
   1:     }
   1:   }
   1:   else if (aTag == nsGkAtoms::linearGradient) {
   1:     newFrame = NS_NewSVGLinearGradientFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::radialGradient) {
   1:     newFrame = NS_NewSVGRadialGradientFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::stop) {
   1:     newFrame = NS_NewSVGStopFrame(mPresShell, aContent, aParentFrame, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::use) {
   1:     newFrame = NS_NewSVGUseFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::marker) {
   1:     newFrame = NS_NewSVGMarkerFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::image) {
   1:     newFrame = NS_NewSVGImageFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::clipPath) {
   1:     newFrame = NS_NewSVGClipPathFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::textPath) {
   1:     nsIFrame *ancestorFrame = SVG_GetFirstNonAAncestorFrame(aParentFrame);
   1:     if (ancestorFrame &&
   1:         ancestorFrame->GetType() == nsGkAtoms::svgTextFrame) {
   1:       newFrame = NS_NewSVGTextPathFrame(mPresShell, aContent,
   1:                                         ancestorFrame, aStyleContext);
   1:     }
   1:   }
   1:   else if (aTag == nsGkAtoms::filter) {
   1:     newFrame = NS_NewSVGFilterFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::pattern) {
   1:     newFrame = NS_NewSVGPatternFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::mask) {
   1:     newFrame = NS_NewSVGMaskFrame(mPresShell, aContent, aStyleContext);
   1:   }
   1:   else if (aTag == nsGkAtoms::feDistantLight ||
   1:            aTag == nsGkAtoms::fePointLight ||
   1:            aTag == nsGkAtoms::feSpotLight ||
   1:            aTag == nsGkAtoms::feBlend ||
   1:            aTag == nsGkAtoms::feColorMatrix ||
   1:            aTag == nsGkAtoms::feFuncR ||
   1:            aTag == nsGkAtoms::feFuncG ||
   1:            aTag == nsGkAtoms::feFuncB ||
   1:            aTag == nsGkAtoms::feFuncA ||
   1:            aTag == nsGkAtoms::feComposite ||
   1:            aTag == nsGkAtoms::feConvolveMatrix ||
   1:            aTag == nsGkAtoms::feDisplacementMap ||
   1:            aTag == nsGkAtoms::feFlood ||
   1:            aTag == nsGkAtoms::feGaussianBlur ||
   1:            aTag == nsGkAtoms::feImage ||
   1:            aTag == nsGkAtoms::feMergeNode ||
   1:            aTag == nsGkAtoms::feMorphology ||
   1:            aTag == nsGkAtoms::feOffset ||
   1:            aTag == nsGkAtoms::feTile ||
   1:            aTag == nsGkAtoms::feTurbulence) {
   1:     // We don't really use the frame, just need it for the style
   1:     // information, so create the simplest possible frame.
   1:     newFrame = NS_NewSVGLeafFrame(mPresShell, aStyleContext);
   1:   }
   1: 
   1:   
   1:   if (newFrame == nsnull) {
   1:     // Either we have an unknown tag, or construction of a frame
   1:     // failed. One reason why frame construction for a known tag might
   1:     // have failed is that the content element doesn't implement all
   1:     // interfaces required by the frame. This happens e.g. when using
   1:     // 'extends' in xbl to extend an xbl binding from an svg
   1:     // element. In that case, the bound content element will always be
   1:     // a standard xml element, and not be of the right type.
   1:     // The best we can do here is to create a generic svg container frame.
   1:     // XXXldb This really isn't what the SVG spec says to do.
   1: #ifdef DEBUG
   1:     // printf("Warning: Creating SVGGenericContainerFrame for tag <");
   1:     // nsAutoString str;
   1:     // aTag->ToString(str);
   1:     // printf("%s>\n", NS_ConvertUTF16toUTF8(str).get());
   1: #endif
   1:     newFrame = NS_NewSVGGenericContainerFrame(mPresShell, aContent, aStyleContext);
   1:   }  
   1:   // If we succeeded in creating a frame then initialize it, process its
   1:   // children (if requested), and set the initial child list
   1:   if (newFrame != nsnull) {
   1:     InitAndRestoreFrame(aState, aContent, geometricParent, nsnull, newFrame);
   1:     nsHTMLContainerFrame::CreateViewForFrame(newFrame, aParentFrame, forceView);
   1: 
   1:     rv = aState.AddChild(newFrame, aFrameItems, disp, aContent, aStyleContext,
   1:                          aParentFrame, isOuterSVGNode, isOuterSVGNode);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1: 
   1:     nsFrameItems childItems;
   1: #ifdef MOZ_SVG_FOREIGNOBJECT
   1:     if (aTag == nsGkAtoms::foreignObject) { 
   1:       // Resolve pseudo style and create an inner block frame
   1:       // XXX this breaks style inheritance
   1:       nsRefPtr<nsStyleContext> innerPseudoStyle;
   1:       innerPseudoStyle = mPresShell->StyleSet()->
   1:         ResolvePseudoStyleFor(aContent,
   1:                               nsCSSAnonBoxes::mozSVGForeignContent, aStyleContext);
   1:     
   1:       nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, innerPseudoStyle,
   1:                                               NS_BLOCK_SPACE_MGR |
   1:                                                 NS_BLOCK_MARGIN_ROOT);
   1:       if (NS_UNLIKELY(!blockFrame))
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:     
   1:       // Claim to be relatively positioned so that we end up being the
   1:       // absolute containing block.
   1:       nsFrameConstructorSaveState saveState;
   1:       aState.PushFloatContainingBlock(nsnull, saveState, PR_FALSE, PR_FALSE);
   1:       const nsStyleDisplay* disp = innerPseudoStyle->GetStyleDisplay();
   1:       rv = ConstructBlock(aState, disp, aContent,
   1:                           newFrame, newFrame, innerPseudoStyle,
   1:                           &blockFrame, childItems, PR_TRUE);
   1:       // Give the blockFrame a view so that GetOffsetTo works for descendants
   1:       // of blockFrame with views...
   1:       nsHTMLContainerFrame::CreateViewForFrame(blockFrame, nsnull, PR_TRUE);
   1:     } else
   1: #endif  // MOZ_SVG_FOREIGNOBJECT
   1:     {
   1:       // Process the child content if requested.
   1:       if (!newFrame->IsLeaf()) {
   1:         if (aTag == nsGkAtoms::svgSwitch) {
   1:           rv = SVGSwitchProcessChildren(aState, aContent, newFrame,
   1:                                         childItems);
   1:         } else {
   1:           rv = ProcessChildren(aState, aContent, newFrame, PR_TRUE, childItems,
   1:                                PR_FALSE);
   1:         }
   1: 
   1:       }
   1:       CreateAnonymousFrames(aTag, aState, aContent, newFrame,
   1:                             PR_FALSE, childItems);
   1:     }
   1: 
   1:     // Set the frame's initial child list
   1:     newFrame->SetInitialChildList(nsnull, childItems.childList);
   1:     return rv;
   1:   }
   1:   else {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: }
   1: #endif // MOZ_SVG
   1: 
   1: PRBool
   1: nsCSSFrameConstructor::PageBreakBefore(nsFrameConstructorState& aState,
   1:                                        nsIContent*              aContent,
   1:                                        nsIFrame*                aParentFrame,
   1:                                        nsStyleContext*          aStyleContext,
   1:                                        nsFrameItems&            aFrameItems)
   1: {
   1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
   1: 
   1:   // See if page-break-before is set for all elements except row groups, rows, cells 
   1:   // (these are handled internally by tables) and construct a page break frame if so.
   1:   if (NS_STYLE_DISPLAY_NONE != display->mDisplay &&
   1:       (NS_STYLE_DISPLAY_TABLE == display->mDisplay ||
   1:        !IsTableRelated(display->mDisplay, PR_TRUE))) { 
   1:     if (display->mBreakBefore) {
   1:       ConstructPageBreakFrame(aState, aContent, aParentFrame, aStyleContext,
   1:                               aFrameItems);
   1:     }
   1:     return display->mBreakAfter;
   1:   }
   1:   return PR_FALSE;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructPageBreakFrame(nsFrameConstructorState& aState,
   1:                                                nsIContent*              aContent,
   1:                                                nsIFrame*                aParentFrame,
   1:                                                nsStyleContext*          aStyleContext,
   1:                                                nsFrameItems&            aFrameItems)
   1: {
   1:   nsRefPtr<nsStyleContext> pseudoStyle;
   1:   pseudoStyle = mPresShell->StyleSet()->ResolvePseudoStyleFor(nsnull,
   1:                                                               nsCSSAnonBoxes::pageBreak,
   1:                                                               aStyleContext);
   1:   nsIFrame* pageBreakFrame = NS_NewPageBreakFrame(mPresShell, pseudoStyle);
   1:   if (pageBreakFrame) {
   1:     InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, pageBreakFrame);
   1:     aFrameItems.AddChild(pageBreakFrame);
   1: 
   1:     return NS_OK;
   1:   }
   1:   else {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructFrame(nsFrameConstructorState& aState,
   1:                                       nsIContent*              aContent,
   1:                                       nsIFrame*                aParentFrame,
   1:                                       nsFrameItems&            aFrameItems)
   1: 
   1: {
   1:   NS_PRECONDITION(nsnull != aParentFrame, "no parent frame");
   1: 
   1:   nsresult rv = NS_OK;
   1: 
   1:   // don't create a whitespace frame if aParent doesn't want it
   1:   if (!NeedFrameFor(aParentFrame, aContent)) {
   1:     return rv;
   1:   }
   1: 
   1:   // never create frames for comments or PIs
   1:   if (aContent->IsNodeOfType(nsINode::eCOMMENT) ||
   1:       aContent->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION))
   1:     return rv;
   1: 
   1:   nsRefPtr<nsStyleContext> styleContext;
   1:   styleContext = ResolveStyleContext(aParentFrame, aContent);
   1: 
   1:   PRBool pageBreakAfter = PR_FALSE;
   1: 
   1:   if (aState.mPresContext->IsPaginated()) {
   1:     // See if there is a page break before, if so construct one. Also see if there is one after
   1:     pageBreakAfter = PageBreakBefore(aState, aContent, aParentFrame,
   1:                                      styleContext, aFrameItems);
   1:   }
   1: 
   1:   // construct the frame
   1:   rv = ConstructFrameInternal(aState, aContent, aParentFrame,
   1:                               aContent->Tag(), aContent->GetNameSpaceID(),
   1:                               styleContext, aFrameItems, PR_FALSE);
   1: 
   1:   if (NS_SUCCEEDED(rv) && pageBreakAfter) {
   1:     // Construct the page break after
   1:     ConstructPageBreakFrame(aState, aContent, aParentFrame, styleContext,
   1:                             aFrameItems);
   1:   }
   1:   
   1:   return rv;
   1: }
   1: 
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructFrameInternal( nsFrameConstructorState& aState,
   1:                                                nsIContent*              aContent,
   1:                                                nsIFrame*                aParentFrame,
   1:                                                nsIAtom*                 aTag,
   1:                                                PRInt32                  aNameSpaceID,
   1:                                                nsStyleContext*          aStyleContext,
   1:                                                nsFrameItems&            aFrameItems,
   1:                                                PRBool                   aXBLBaseTag)
   1: {
   1:   // The following code allows the user to specify the base tag
   1:   // of an element using XBL.  XUL and HTML objects (like boxes, menus, etc.)
   1:   // can then be extended arbitrarily.
   1:   const nsStyleDisplay* display = aStyleContext->GetStyleDisplay();
   1:   nsRefPtr<nsStyleContext> styleContext(aStyleContext);
   1:   nsAutoEnqueueBinding binding(mDocument);
   1:   if (!aXBLBaseTag)
   1:   {
   1:     
   1:     // Ensure that our XBL bindings are installed.
   1:     if (display->mBinding) {
   1:       // Get the XBL loader.
   1:       nsresult rv;
   1:       // Load the bindings.
   1:       PRBool resolveStyle;
   1:       
   1:       nsIXBLService * xblService = GetXBLService();
   1:       if (!xblService)
   1:         return NS_ERROR_FAILURE;
   1: 
3645:       rv = xblService->LoadBindings(aContent, display->mBinding->mURI,
3645:                                     display->mBinding->mOriginPrincipal,
3645:                                     PR_FALSE, getter_AddRefs(binding.mBinding),
   1:                                     &resolveStyle);
   1:       if (NS_FAILED(rv))
   1:         return NS_OK;
   1: 
   1:       if (resolveStyle) {
   1:         styleContext = ResolveStyleContext(aParentFrame, aContent);
   1:         display = styleContext->GetStyleDisplay();
   1:       }
   1: 
   1:       PRInt32 nameSpaceID;
   1:       nsCOMPtr<nsIAtom> baseTag =
   1:         mDocument->BindingManager()->ResolveTag(aContent, &nameSpaceID);
   1: 
   1:       if (baseTag != aTag || aNameSpaceID != nameSpaceID) {
   1:         // Construct the frame using the XBL base tag.
   1:         rv = ConstructFrameInternal(aState,
   1:                                     aContent,
   1:                                     aParentFrame,
   1:                                     baseTag,
   1:                                     nameSpaceID,
   1:                                     styleContext,
   1:                                     aFrameItems,
   1:                                     PR_TRUE);
   1:         return rv;
   1:       }
   1:     }
   1:   }
   1: 
   1:   // Pre-check for display "none" - if we find that, don't create
   1:   // any frame at all
   1:   if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
   1:     aState.mFrameManager->SetUndisplayedContent(aContent, styleContext);
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsIFrame* adjParentFrame = aParentFrame;
   1:   nsFrameItems* frameItems = &aFrameItems;
   1:   PRBool pseudoParent = PR_FALSE;
   1:   PRBool suppressFrame = PR_FALSE;
   1:   nsFrameConstructorSaveState pseudoSaveState;
   1:   nsresult rv = AdjustParentFrame(aState, aContent, adjParentFrame,
   1:                                   aTag, aNameSpaceID, styleContext,
   1:                                   frameItems, pseudoSaveState,
   1:                                   suppressFrame, pseudoParent);
   1:   if (NS_FAILED(rv) || suppressFrame) {
   1:     return rv;
   1:   }
   1: 
   1:   if (aContent->IsNodeOfType(nsINode::eTEXT)) 
   1:     return ConstructTextFrame(aState, aContent, adjParentFrame, styleContext,
   1:                               *frameItems, pseudoParent);
   1: 
   1: #ifdef MOZ_SVG
   1:   // Don't create frames for non-SVG children of SVG elements
   1:   if (aNameSpaceID != kNameSpaceID_SVG &&
   1:       aParentFrame &&
   1:       aParentFrame->IsFrameOfType(nsIFrame::eSVG)
   1: #ifdef MOZ_SVG_FOREIGNOBJECT
   1:       && !aParentFrame->IsFrameOfType(nsIFrame::eSVGForeignObject)
   1: #endif
   1:       ) {
   1:     return NS_OK;
   1:   }
   1: #endif
   1: 
   1:   // Style resolution can normally happen lazily.  However, getting the
   1:   // Visibility struct can cause |SetBidiEnabled| to be called on the
   1:   // pres context, and this needs to happen before we start reflow, so
   1:   // do it now, when constructing frames.  See bug 115921.
   1:   {
   1:     styleContext->GetStyleVisibility();
   1:   }
   1:   // Start background loads during frame construction. This is just
   1:   // a hint; the paint code will do the right thing in any case.
   1:   {
   1:     styleContext->GetStyleBackground();
   1:   }
   1: 
   1:   nsIFrame* lastChild = frameItems->lastChild;
   1: 
   1:   // Handle specific frame types
   1:   rv = ConstructHTMLFrame(aState, aContent, adjParentFrame, aTag, aNameSpaceID,
   1:                           styleContext, *frameItems, pseudoParent);
   1: 
   1:   // Failing to find a matching HTML frame, try creating a specialized
   1:   // XUL frame. This is temporary, pending planned factoring of this
   1:   // whole process into separate, pluggable steps.
   1:   if (NS_SUCCEEDED(rv) &&
   1:       (!frameItems->childList || lastChild == frameItems->lastChild)) {
   1:     PRBool haltProcessing;
   1: 
   1:     rv = ConstructXULFrame(aState, aContent, adjParentFrame, aTag,
   1:                            aNameSpaceID, styleContext,
   1:                            *frameItems, aXBLBaseTag, pseudoParent,
   1:                            &haltProcessing);
   1: 
   1:     if (haltProcessing) {
   1:       return rv;
   1:     }
   1:   } 
   1: 
   1: // MathML Mod - RBS
   1: #ifdef MOZ_MATHML
   1:   if (NS_SUCCEEDED(rv) &&
   1:       (!frameItems->childList || lastChild == frameItems->lastChild)) {
   1:     rv = ConstructMathMLFrame(aState, aContent, adjParentFrame, aTag,
   1:                               aNameSpaceID, styleContext, *frameItems,
   1:                               pseudoParent);
   1:   }
   1: #endif
   1: 
   1: // SVG
   1: #ifdef MOZ_SVG
   1:   if (NS_SUCCEEDED(rv) &&
   1:       (!frameItems->childList || lastChild == frameItems->lastChild) &&
   1:       aNameSpaceID == kNameSpaceID_SVG &&
   1:       NS_SVGEnabled()) {
   1:     PRBool haltProcessing;
   1:     rv = ConstructSVGFrame(aState, aContent, adjParentFrame, aTag,
   1:                            aNameSpaceID, styleContext,
   1:                            *frameItems, pseudoParent, &haltProcessing);
   1:     if (haltProcessing) {
   1:       return rv;
   1:     }
   1:   }
   1: #endif
   1: 
   1:   if (NS_SUCCEEDED(rv) &&
   1:       (!frameItems->childList || lastChild == frameItems->lastChild)) {
   1:     // When there is no explicit frame to create, assume it's a
   1:     // container and let display style dictate the rest
   1:     rv = ConstructFrameByDisplayType(aState, display, aContent, aNameSpaceID,
   1:                                      aTag, adjParentFrame, styleContext,
   1:                                      *frameItems, pseudoParent);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: 
   1: inline PRBool
   1: IsRootBoxFrame(nsIFrame *aFrame)
   1: {
   1:   return (aFrame->GetType() == nsGkAtoms::rootFrame);
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ReconstructDocElementHierarchy()
   1: {
   1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   1:   return ReconstructDocElementHierarchyInternal();
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ReconstructDocElementHierarchyInternal()
   1: {
   1: #ifdef DEBUG
   1:   if (gNoisyContentUpdates) {
   1:     printf("nsCSSFrameConstructor::ReconstructDocElementHierarchy\n");
   1:   }
   1: #endif
   1: 
   1:   nsresult rv = NS_OK;
   1: 
   1:   // XXXbz is that null-check needed?  Why?
   1:   if (mDocument && mPresShell) {
   1:     nsIContent *rootContent = mDocument->GetRootContent();
   1:     
   1:     if (rootContent) {
   1:       // Before removing the frames associated with the content object, ask them to save their
   1:       // state onto a temporary state object.
   1:       CaptureStateForFramesOf(rootContent, mTempFrameTreeState);
   1: 
   1:       nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
   1:                                     nsnull, nsnull, mTempFrameTreeState);
   1: 
   1:       // Get the frame that corresponds to the document element
   1:       nsIFrame* docElementFrame =
   1:         state.mFrameManager->GetPrimaryFrameFor(rootContent, -1);
   1:         
   1:       // Remove any existing fixed items: they are always on the
   1:       // FixedContainingBlock.  Note that this has to be done before we call
   1:       // ClearPlaceholderFrameMap(), since RemoveFixedItems uses the
   1:       // placeholder frame map.
   1:       rv = RemoveFixedItems(state);
   1:       if (NS_SUCCEEDED(rv)) {
   1:         // Clear the hash tables that map from content to frame and out-of-flow
   1:         // frame to placeholder frame
   1:         state.mFrameManager->ClearPrimaryFrameMap();
   1:         state.mFrameManager->ClearPlaceholderFrameMap();
   1:         state.mFrameManager->ClearUndisplayedContentMap();
   1: 
1228:         if (docElementFrame) {
   1:           // Take the docElementFrame, and remove it from its parent.
   1:         
   1:           // XXXbz So why can't we reuse ContentRemoved?
   1: 
   1:           NS_ASSERTION(docElementFrame->GetParent() == mDocElementContainingBlock,
   1:                        "Unexpected doc element parent frame");
   1: 
   1:           // Remove the old document element hieararchy
   1:           rv = state.mFrameManager->RemoveFrame(mDocElementContainingBlock,
   1:                                                 nsnull, docElementFrame);
   1:           if (NS_FAILED(rv)) {
   1:             return rv;
   1:           }
   1: 
1228:         }
1228: 
   1:         // Create the new document element hierarchy
   1:         nsIFrame*                 newChild;
   1:         rv = ConstructDocElementFrame(state, rootContent,
   1:                                       mDocElementContainingBlock, &newChild);
   1: 
   1:         // newChild could be null even if |rv| is success, thanks to XBL.
   1:         if (NS_SUCCEEDED(rv) && newChild) {
   1:           rv = state.mFrameManager->InsertFrames(mDocElementContainingBlock,
   1:                                                  nsnull, nsnull, newChild);
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: 
   1: nsIFrame*
   1: nsCSSFrameConstructor::GetFrameFor(nsIContent* aContent)
   1: {
   1:   // Get the primary frame associated with the content
   1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
   1: 
   1:   if (!frame)
   1:     return nsnull;
   1: 
   1:   nsIFrame* insertionFrame = frame->GetContentInsertionFrame();
   1: 
   1:   NS_ASSERTION(insertionFrame == frame || !frame->IsLeaf(),
   1:     "The insertion frame is the primary frame or the primary frame isn't a leaf");
   1: 
   1:   return insertionFrame;
   1: }
   1: 
   1: nsIFrame*
   1: nsCSSFrameConstructor::GetAbsoluteContainingBlock(nsIFrame* aFrame)
   1: {
   1:   NS_PRECONDITION(nsnull != mInitialContainingBlock, "no initial containing block");
   1:   
   1:   // Starting with aFrame, look for a frame that is absolutely positioned or
   1:   // relatively positioned
   1:   nsIFrame* containingBlock = nsnull;
   1:   for (nsIFrame* frame = aFrame; frame && !containingBlock;
   1:        frame = frame->GetParent()) {
   1:     if (frame->IsFrameOfType(nsIFrame::eMathML)) {
   1:       // If it's mathml, bail out -- no absolute positioning out from inside
   1:       // mathml frames.  Note that we don't make this part of the loop
   1:       // condition because of the mInitialContainingBlock stuff at the
   1:       // end of this method...
   1:       return nsnull;
   1:     }
   1:     
   1:     // Is it positioned?
   1:     // If it's table-related then ignore it, because for the time
   1:     // being table-related frames are not containers for absolutely
   1:     // positioned child frames.
   1:     const nsStyleDisplay* disp = frame->GetStyleDisplay();
   1: 
   1:     if (disp->IsPositioned() && !IsTableRelated(disp->mDisplay, PR_TRUE)) {
   1:       // Find the outermost wrapped block under this frame
   1:       for (nsIFrame* wrappedFrame = aFrame; wrappedFrame != frame->GetParent();
   1:            wrappedFrame = wrappedFrame->GetParent()) {
   1:         nsIAtom* frameType = wrappedFrame->GetType();
   1:         if (nsGkAtoms::areaFrame == frameType ||
   1:             nsGkAtoms::blockFrame == frameType ||
   1:             nsGkAtoms::positionedInlineFrame == frameType) {
   1:           containingBlock = wrappedFrame;
   1:         } else if (nsGkAtoms::fieldSetFrame == frameType) {
   1:           // If the positioned frame is a fieldset, use the area frame inside it.
   1:           // We don't use GetContentInsertionFrame for fieldsets yet.
   1:           containingBlock = GetFieldSetAreaFrame(wrappedFrame);
   1:         }
   1:       }
   1: 
   1: #ifdef DEBUG
   1:       if (!containingBlock)
   1:         NS_WARNING("Positioned frame that does not handle positioned kids; looking further up the parent chain");
   1: #endif
   1:     }
   1:   }
   1: 
   1:   // If we found an absolutely positioned containing block, then use the first-in-flow.
   1:   if (containingBlock)
   1:     return AdjustAbsoluteContainingBlock(mPresShell->GetPresContext(),
   1:                                          containingBlock);
   1: 
   1:   // If we didn't find it, then use the initial containing block if it
   1:   // supports abs pos kids.
   1:   return mInitialContainingBlockIsAbsPosContainer ? mInitialContainingBlock : nsnull;
   1: }
   1: 
   1: nsIFrame*
   1: nsCSSFrameConstructor::GetFloatContainingBlock(nsIFrame* aFrame)
   1: {
   1:   NS_PRECONDITION(mInitialContainingBlock, "no initial containing block");
   1:   
   1:   // Starting with aFrame, look for a frame that is a float containing block.
   1:   // IF we hit a mathml frame, bail out; we don't allow floating out of mathml
   1:   // frames, because they don't seem to be able to deal.
   1:   for (nsIFrame* containingBlock = aFrame;
2192:        containingBlock && !containingBlock->IsFrameOfType(nsIFrame::eMathML) &&
2192:        !containingBlock->IsBoxFrame();
   1:        containingBlock = containingBlock->GetParent()) {
   1:     if (containingBlock->IsFloatContainingBlock()) {
   1:       return containingBlock;
   1:     }
   1:   }
   1: 
   1:   // If we didn't find a containing block, then there just isn't
   1:   // one.... return null
   1:   return nsnull;
   1: }
   1: 
   1: /**
   1:  * This function will check whether aContainer has :after generated content.
   1:  * If so, appending to it should actually insert.  The return value is the
   1:  * parent to use for newly-appended content.  *aAfterFrame points to the :after
   1:  * frame before which appended content should go, if there is one.
   1:  */
   1: static nsIFrame*
   1: AdjustAppendParentForAfterContent(nsPresContext* aPresContext,
   1:                                   nsIContent* aContainer,
   1:                                   nsIFrame* aParentFrame,
   1:                                   nsIFrame** aAfterFrame)
   1: {
   1:   // See if the parent has an :after pseudo-element.  Check for the presence
   1:   // of style first, since nsLayoutUtils::GetAfterFrame is sorta expensive.
   1:   nsStyleContext* parentStyle = aParentFrame->GetStyleContext();
   1:   if (nsLayoutUtils::HasPseudoStyle(aContainer, parentStyle,
   1:                                     nsCSSPseudoElements::after,
   1:                                     aPresContext)) {
   1:     nsIFrame* afterFrame = nsLayoutUtils::GetAfterFrame(aParentFrame);
   1:     if (afterFrame) {
   1:       *aAfterFrame = afterFrame;
   1:       return afterFrame->GetParent();
   1:     }
   1:   }
   1: 
   1:   *aAfterFrame = nsnull;
   1:   return aParentFrame;
   1: }
   1: 
   1: /**
   1:  * This function is called by ContentAppended() and ContentInserted()
   1:  * when appending flowed frames to a parent's principal child list. It
   1:  * handles the case where the parent frame has :after pseudo-element
   1:  * generated content.
   1:  */
   1: nsresult
4696: nsCSSFrameConstructor::AppendFrames(nsFrameConstructorState&       aState,
   1:                                     nsIContent*                    aContainer,
   1:                                     nsIFrame*                      aParentFrame,
4696:                                     nsFrameItems&                  aFrameList,
   1:                                     nsIFrame*                      aAfterFrame)
   1: {
   1: #ifdef DEBUG
   1:   nsIFrame* debugAfterFrame;
   1:   nsIFrame* debugNewParent =
   1:     ::AdjustAppendParentForAfterContent(aState.mPresContext, aContainer,
   1:                                         aParentFrame, &debugAfterFrame);
   1:   NS_ASSERTION(debugNewParent == aParentFrame, "Incorrect parent");
   1:   NS_ASSERTION(debugAfterFrame == aAfterFrame, "Incorrect after frame");
   1: #endif
   1: 
   1:   nsFrameManager* frameManager = aState.mFrameManager;
   1:   if (aAfterFrame) {
4696:     NS_ASSERTION(!IsFrameSpecial(aParentFrame) ||
4696:                  IsInlineFrame(aParentFrame) ||
4696:                  !IsInlineOutside(aAfterFrame),
4696:                  "Shouldn't have inline :after content on the block in an "
4696:                  "{ib} split");
   1:     nsFrameList frames(aParentFrame->GetFirstChild(nsnull));
   1: 
   1:     // Insert the frames before the :after pseudo-element.
   1:     return frameManager->InsertFrames(aParentFrame, nsnull,
   1:                                       frames.GetPrevSiblingFor(aAfterFrame),
4696:                                       aFrameList.childList);
4696:   }
4696: 
4696:   if (IsFrameSpecial(aParentFrame) &&
4696:       !IsInlineFrame(aParentFrame) &&
4696:       IsInlineOutside(aFrameList.lastChild)) {
4696:     NS_ASSERTION(!aParentFrame->GetNextContinuation(), "Shouldn't happen");
4696:     
4696:     // We want to put some of the frames into the following inline frame.
4696:     nsIFrame* lastBlock = FindLastBlock(aFrameList.childList);
4696:     nsIFrame* firstTrailingInline;
4696:     if (lastBlock) {
4696:       firstTrailingInline = lastBlock->GetNextSibling();
4696:       lastBlock->SetNextSibling(nsnull);
4696:       aFrameList.lastChild = lastBlock;
4696:     } else {
4696:       firstTrailingInline = aFrameList.childList;
4696:       aFrameList = nsFrameItems();
4696:     }
4696: 
4696:     NS_ASSERTION(firstTrailingInline, "How did that happen?");
4696:     nsIFrame* parentFrame = aParentFrame;
4696: 
5327:     // As we go up the tree creating trailing inlines, we have to move floats
5327:     // up to ancestor blocks.  This means that at any given time we'll be
5327:     // working with two frame constructor states, and aState is one of the two
5327:     // only at the first step.  Create some space to do this so we don't have
5327:     // to allocate as we go.
5327:     char stateBuf[2 * sizeof(nsFrameConstructorState)];
5327:     nsFrameConstructorState* sourceState = &aState;
5327:     nsFrameConstructorState* targetState =
5327:       reinterpret_cast<nsFrameConstructorState*>(stateBuf);
5327: 
4696:     // Now we loop, because it might be the case that the parent of our special
4696:     // block is another special block, and that we're at the very end of it,
4696:     // and in that case if we create a new special inline we'll have to create
4696:     // a parent for it too.
4696:     do {
4696:       NS_ASSERTION(IsFrameSpecial(parentFrame) && !IsInlineFrame(parentFrame),
4696:                    "Shouldn't be in this code");
4696:       nsIFrame* inlineSibling = GetSpecialSibling(parentFrame);
4696:       PRBool isPositioned = PR_FALSE;
4696:       nsIContent* content = nsnull;
4696:       nsStyleContext* styleContext = nsnull;
4696:       if (!inlineSibling) {
5324:         nsIFrame* firstInline = GetIBSplitSpecialPrevSibling(parentFrame);
4696:         NS_ASSERTION(firstInline, "How did that happen?");
4696: 
4696:         content = firstInline->GetContent();
4696:         styleContext = firstInline->GetStyleContext();
4696:         isPositioned = (styleContext->GetStyleDisplay()->mPosition ==
4696:                         NS_STYLE_POSITION_RELATIVE);
4696:       }
4696: 
4696:       nsIFrame* stateParent =
4696:         inlineSibling ? inlineSibling->GetParent() : parentFrame->GetParent();
4696: 
5327:       new (targetState)
5327:         nsFrameConstructorState(mPresShell, mFixedContainingBlock,
4696:                                 GetAbsoluteContainingBlock(stateParent),
4696:                                 GetFloatContainingBlock(stateParent));
4696:       nsIFrame* newInlineSibling =
5327:         MoveFramesToEndOfIBSplit(*sourceState, inlineSibling,
4696:                                  isPositioned, content,
4696:                                  styleContext, firstTrailingInline,
5327:                                  parentFrame, targetState);
5327: 
5327:       if (sourceState == &aState) {
5327:         NS_ASSERTION(targetState ==
5327:                        reinterpret_cast<nsFrameConstructorState*>(stateBuf),
5327:                      "Bogus target state?");
5327:         // Set sourceState to the value targetState should have next.
5327:         sourceState = targetState + 1;
5327:       } else {
5327:         // Go ahead and process whatever insertions we didn't move out
5327:         sourceState->~nsFrameConstructorState();
5327:       }
5327: 
5327:       // We're done with the source state.  The target becomes the new source,
5327:       // and we point the target pointer to the available memory.
5327:       nsFrameConstructorState* temp = sourceState;
5327:       sourceState = targetState;
5327:       targetState = temp;;
4696: 
4696:       if (inlineSibling) {
4696:         // we're all set -- we just moved things to a frame that was already
4696:         // there.
4696:         NS_ASSERTION(newInlineSibling == inlineSibling, "What happened?");
4696:         break;
4696:       }
4696: 
5322:       SetFrameIsSpecial(parentFrame->GetFirstContinuation(), newInlineSibling);
4696:       
4696:       // We had to create a frame for this new inline sibling.  Figure out
4696:       // the right parentage for it.
4696:       // XXXbz add a test for this?
4696:       nsIFrame* newParentFrame = parentFrame->GetParent();
4696:       NS_ASSERTION(!IsInlineFrame(newParentFrame),
4696:                    "The block in an {ib} split shouldn't be living inside "
4696:                    "an inline");
4696:       if (!IsFrameSpecial(newParentFrame) ||
4696:           newParentFrame->GetNextContinuation() ||
4696:           parentFrame->GetNextSibling()) {
4696:         // Just insert after parentFrame
4696:         frameManager->InsertFrames(newParentFrame, nsnull, parentFrame,
4696:                                    newInlineSibling);
4696:         firstTrailingInline = nsnull;
4696:       } else {
4696:         // recurse up the tree
4696:         parentFrame = newParentFrame;
4696:         firstTrailingInline = newInlineSibling;
4696:       }      
4696:     } while (firstTrailingInline);
5327: 
5327:     // Process the float insertions on the last target state we had.
5327:     sourceState->~nsFrameConstructorState();
4696:   }
4696:     
4696:   if (!aFrameList.childList) {
4696:     // It all got eaten by the special inline
4696:     return NS_OK;
4696:   }
4696:   
4696:   return frameManager->AppendFrames(aParentFrame, nsnull,
4696:                                     aFrameList.childList);
   1: }
   1: 
   1: /**
   1:  * Find the ``rightmost'' frame for the anonymous content immediately
   1:  * preceding aChild, following continuation if necessary.
   1:  */
   1: static nsIFrame*
   1: FindPreviousAnonymousSibling(nsIPresShell* aPresShell,
   1:                              nsIDocument*  aDocument,
   1:                              nsIContent*   aContainer,
   1:                              nsIContent*   aChild)
   1: {
   1:   NS_PRECONDITION(aDocument, "null document from content element in FindNextAnonymousSibling");
   1: 
   1:   nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(aDocument));
   1:   NS_ASSERTION(xblDoc, "null xblDoc for content element in FindNextAnonymousSibling");
   1:   if (! xblDoc)
   1:     return nsnull;
   1: 
   1:   // Grovel through the anonymous elements looking for aChild. We'll
   1:   // start our search for a previous frame there.
   1:   nsCOMPtr<nsIDOMNodeList> nodeList;
   1:   nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(aContainer));
   1:   xblDoc->GetAnonymousNodes(elt, getter_AddRefs(nodeList));
   1: 
   1:   if (! nodeList)
   1:     return nsnull;
   1: 
   1:   PRUint32 length;
   1:   nodeList->GetLength(&length);
   1: 
   1:   PRInt32 index;
   1:   for (index = PRInt32(length) - 1; index >= 0; --index) {
   1:     nsCOMPtr<nsIDOMNode> node;
   1:     nodeList->Item(PRUint32(index), getter_AddRefs(node));
   1: 
   1:     nsCOMPtr<nsIContent> child = do_QueryInterface(node);
   1:     if (child == aChild)
   1:       break;
   1:   }
   1: 
   1:   // We want the node immediately before aChild. Keep going until we
   1:   // run off the beginning of the nodeList, or we find a frame.
   1:   while (--index >= 0) {
   1:     nsCOMPtr<nsIDOMNode> node;
   1:     nodeList->Item(PRUint32(index), getter_AddRefs(node));
   1: 
   1:     nsCOMPtr<nsIContent> child = do_QueryInterface(node);
   1: 
   1:     // Get its frame. If it doesn't have one, continue on to the
   1:     // anonymous element that preceded it.
   1:     nsIFrame* prevSibling = aPresShell->GetPrimaryFrameFor(child);
   1:     if (prevSibling) {
   1:       // The frame may be a special frame (a split inline frame that
   1:       // contains a block).  Get the last part of that split.
   1:       if (IsFrameSpecial(prevSibling)) {
4696:         prevSibling = GetLastSpecialSibling(prevSibling);
   1:       }
   1: 
   1:       // The frame may have a continuation. If so, we want the
   1:       // last continuation as our previous sibling.
   1:       prevSibling = prevSibling->GetLastContinuation();
   1: 
   1:       // If the frame is out-of-flow, GPFF() will have returned the
   1:       // out-of-flow frame; we want the placeholder.
   1:       if (prevSibling->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
   1:         nsIFrame *placeholderFrame;
   1:         aPresShell->GetPlaceholderFrameFor(prevSibling, &placeholderFrame);
   1:         NS_ASSERTION(placeholderFrame, "no placeholder for out-of-flow frame");
   1:         prevSibling = placeholderFrame;
   1:       }
   1: 
   1:       // Found a previous sibling, we're done!
   1:       return prevSibling;
   1:     }
   1:   }
   1: 
   1:   return nsnull;
   1: }
   1: 
   1: /**
   1:  * Find the frame for the anonymous content immediately following
   1:  * aChild.
   1:  */
   1: static nsIFrame*
   1: FindNextAnonymousSibling(nsIPresShell* aPresShell,
   1:                          nsIDocument*  aDocument,
   1:                          nsIContent*   aContainer,
   1:                          nsIContent*   aChild)
   1: {
   1:   NS_PRECONDITION(aDocument, "null document from content element in FindNextAnonymousSibling");
   1: 
   1:   nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(aDocument));
   1:   NS_ASSERTION(xblDoc, "null xblDoc for content element in FindNextAnonymousSibling");
   1:   if (! xblDoc)
   1:     return nsnull;
   1: 
   1:   // Grovel through the anonymous elements looking for aChild
   1:   nsCOMPtr<nsIDOMNodeList> nodeList;
   1:   nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(aContainer));
   1:   xblDoc->GetAnonymousNodes(elt, getter_AddRefs(nodeList));
   1: 
   1:   if (! nodeList)
   1:     return nsnull;
   1: 
   1:   PRUint32 length;
   1:   nodeList->GetLength(&length);
   1: 
   1:   PRInt32 index;
   1:   for (index = 0; index < PRInt32(length); ++index) {
   1:     nsCOMPtr<nsIDOMNode> node;
   1:     nodeList->Item(PRUint32(index), getter_AddRefs(node));
   1: 
   1:     nsCOMPtr<nsIContent> child = do_QueryInterface(node);
   1:     if (child == aChild)
   1:       break;
   1:   }
   1: 
   1:   // We want the node immediately after aChild. Keep going until we
   1:   // run off the end of the nodeList, or we find a next sibling.
   1:   while (++index < PRInt32(length)) {
   1:     nsCOMPtr<nsIDOMNode> node;
   1:     nodeList->Item(PRUint32(index), getter_AddRefs(node));
   1: 
   1:     nsCOMPtr<nsIContent> child = do_QueryInterface(node);
   1: 
   1:     // Get its frame
   1:     nsIFrame* nextSibling = aPresShell->GetPrimaryFrameFor(child);
   1:     if (nextSibling) {
   1:       // The primary frame should never be a continuation
   1:       NS_ASSERTION(!nextSibling->GetPrevInFlow(),
   1:                    "primary frame is a continuation!?");
   1: 
   1:       // If the frame is out-of-flow, GPFF() will have returned the
   1:       // out-of-flow frame; we want the placeholder.
   1:       if (nextSibling->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
   1:         nsIFrame* placeholderFrame;
   1:         aPresShell->GetPlaceholderFrameFor(nextSibling, &placeholderFrame);
   1:         NS_ASSERTION(placeholderFrame, "no placeholder for out-of-flow frame");
   1:         nextSibling = placeholderFrame;
   1:       }
   1: 
   1:       // Found a next sibling, we're done!
   1:       return nextSibling;
   1:     }
   1:   }
   1: 
   1:   return nsnull;
   1: }
   1: 
   1: #define UNSET_DISPLAY 255
   1: // This gets called to see if the frames corresponding to aSiblingDisplay and aDisplay
   1: // should be siblings in the frame tree. Although (1) rows and cols, (2) row groups 
   1: // and col groups, (3) row groups and captions (4) legends and content inside fieldsets
   1: // are siblings from a content perspective, they are not considered siblings in the 
   1: // frame tree.
   1: PRBool
   1: nsCSSFrameConstructor::IsValidSibling(nsIFrame*              aParentFrame,
1502:                                       nsIFrame*              aSibling,
   1:                                       PRUint8                aSiblingDisplay,
   1:                                       nsIContent&            aContent,
   1:                                       PRUint8&               aDisplay)
   1: {
   1:   if ((NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == aSiblingDisplay) ||
   1:       (NS_STYLE_DISPLAY_TABLE_COLUMN       == aSiblingDisplay) ||
   1:       (NS_STYLE_DISPLAY_TABLE_CAPTION      == aSiblingDisplay) ||
   1:       (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == aSiblingDisplay) ||
   1:       (NS_STYLE_DISPLAY_TABLE_ROW_GROUP    == aSiblingDisplay) ||
   1:       (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == aSiblingDisplay)) {
   1:     // if we haven't already, construct a style context to find the display type of aContent
   1:     if (UNSET_DISPLAY == aDisplay) {
   1:       nsRefPtr<nsStyleContext> styleContext;
1502:       nsIFrame* styleParent;
1502:       PRBool providerIsChild;
1502:       if (NS_FAILED(aSibling->
1502:                       GetParentStyleContextFrame(aSibling->PresContext(),
1502:                                                  &styleParent,
1502:                                                  &providerIsChild)) ||
1502:           !styleParent) {
1502:         NS_NOTREACHED("Shouldn't happen");
1502:         return PR_FALSE;
1502:       }
1502:       styleContext = ResolveStyleContext(styleParent, &aContent);
   1:       if (!styleContext) return PR_FALSE;
   1:       const nsStyleDisplay* display = styleContext->GetStyleDisplay();
   1:       aDisplay = display->mDisplay;
   1:     }
   1:     switch (aSiblingDisplay) {
   1:     case NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP:
   1:       return (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == aDisplay);
   1:     case NS_STYLE_DISPLAY_TABLE_COLUMN:
   1:       return (NS_STYLE_DISPLAY_TABLE_COLUMN == aDisplay);
   1:     case NS_STYLE_DISPLAY_TABLE_CAPTION:
   1:       return (NS_STYLE_DISPLAY_TABLE_CAPTION == aDisplay);
   1:     default: // all of the row group types
   1:       return (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == aDisplay) ||
   1:              (NS_STYLE_DISPLAY_TABLE_ROW_GROUP    == aDisplay) ||
   1:              (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == aDisplay) ||
   1:              (NS_STYLE_DISPLAY_TABLE_CAPTION      == aDisplay);
   1:     }
   1:   }
   1:   else if (nsGkAtoms::fieldSetFrame == aParentFrame->GetType()) {
   1:     // Legends can be sibling of legends but not of other content in the fieldset
1502:     nsIAtom* sibType = aSibling->GetType();
   1:     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(&aContent));
   1: 
   1:     if ((legendContent  && (nsGkAtoms::legendFrame != sibType)) ||
   1:         (!legendContent && (nsGkAtoms::legendFrame == sibType)))
   1:       return PR_FALSE;
   1:   }
   1: 
   1:   return PR_TRUE;
   1: }
   1: 
   1: /**
   1:  * Find the ``rightmost'' frame for the content immediately preceding
   1:  * aIndexInContainer, following continuations if necessary.
   1:  */
   1: nsIFrame*
   1: nsCSSFrameConstructor::FindPreviousSibling(nsIContent*       aContainer,
   1:                                            nsIFrame*         aContainerFrame,
   1:                                            PRInt32           aIndexInContainer,
   1:                                            const nsIContent* aChild)
   1: {
   1:   NS_ASSERTION(aContainer, "null argument");
   1: 
   1:   ChildIterator first, iter;
   1:   nsresult rv = ChildIterator::Init(aContainer, &first, &iter);
   1:   NS_ENSURE_SUCCESS(rv, nsnull);
   1:   iter.seek(aIndexInContainer);
   1: 
   1:   PRUint8 childDisplay = UNSET_DISPLAY;
   1:   // Note: not all content objects are associated with a frame (e.g., if it's
   1:   // `display: hidden') so keep looking until we find a previous frame
   1:   while (iter-- != first) {
   1:     nsIFrame* prevSibling = mPresShell->GetPrimaryFrameFor(nsCOMPtr<nsIContent>(*iter));
   1: 
   1:     if (prevSibling) {
   1:       // The frame may be a special frame (a split inline frame that
   1:       // contains a block).  Get the last part of that split.
   1:       if (IsFrameSpecial(prevSibling)) {
4696:         prevSibling = GetLastSpecialSibling(prevSibling);
   1:       }
   1: 
   1:       // The frame may have a continuation. Get the last continuation
   1:       prevSibling = prevSibling->GetLastContinuation();
   1: 
   1:       // XXXbz should the IsValidSibling check be after we get the
   1:       // placeholder for out-of-flows?
   1:       const nsStyleDisplay* display = prevSibling->GetStyleDisplay();
   1:   
1502:       if (aChild && !IsValidSibling(aContainerFrame, prevSibling, 
   1:                                     display->mDisplay, (nsIContent&)*aChild,
   1:                                     childDisplay))
   1:         continue;
   1: 
   1:       // If the frame is out-of-flow, GPFF() will have returned the
   1:       // out-of-flow frame; we want the placeholder.
   1:       if (prevSibling->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
   1:         nsIFrame* placeholderFrame;
   1:         mPresShell->GetPlaceholderFrameFor(prevSibling, &placeholderFrame);
   1:         NS_ASSERTION(placeholderFrame, "no placeholder for out-of-flow frame");
   1:         prevSibling = placeholderFrame;
   1:       }
   1: 
   1: #ifdef DEBUG
   1:       nsIFrame* containerFrame = nsnull;
   1:       containerFrame = mPresShell->GetPrimaryFrameFor(aContainer);
   1:       NS_ASSERTION(prevSibling != containerFrame, "Previous Sibling is the Container's frame");
   1: #endif
   1:       // Found a previous sibling, we're done!
   1:       return prevSibling;
   1:     }
   1:   }
   1: 
   1:   return nsnull;
   1: }
   1: 
   1: /**
   1:  * Find the frame for the content node immediately following
   1:  * aIndexInContainer.
   1:  */
   1: nsIFrame*
   1: nsCSSFrameConstructor::FindNextSibling(nsIContent*       aContainer,
   1:                                        nsIFrame*         aContainerFrame,
   1:                                        PRInt32           aIndexInContainer,
   1:                                        const nsIContent* aChild)
   1: {
   1:   ChildIterator iter, last;
   1:   nsresult rv = ChildIterator::Init(aContainer, &iter, &last);
   1:   NS_ENSURE_SUCCESS(rv, nsnull);
   1:   iter.seek(aIndexInContainer);
   1: 
   1:   // Catch the case where someone tries to append
   1:   if (iter == last)
   1:     return nsnull;
   1: 
   1:   PRUint8 childDisplay = UNSET_DISPLAY;
   1: 
   1:   while (++iter != last) {
   1:     nsIFrame* nextSibling =
   1:       mPresShell->GetPrimaryFrameFor(nsCOMPtr<nsIContent>(*iter));
   1: 
   1:     if (nextSibling) {
   1:       // The frame primary frame should never be a continuation
   1:       NS_ASSERTION(!nextSibling->GetPrevInFlow(),
   1:                    "primary frame is a continuation!?");
   1: 
   1:       // XXXbz should the IsValidSibling check be after we get the
   1:       // placeholder for out-of-flows?
   1:       const nsStyleDisplay* display = nextSibling->GetStyleDisplay();
   1: 
1502:       if (aChild && !IsValidSibling(aContainerFrame, nextSibling, 
   1:                                     display->mDisplay, (nsIContent&)*aChild,
   1:                                     childDisplay))
   1:         continue;
   1: 
   1:       // If the frame is out-of-flow, GPFF() will have returned the
   1:       // out-of-flow frame; we want the placeholder.
   1:       if (nextSibling->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
   1:         // Nope. Get the place-holder instead
   1:         nsIFrame* placeholderFrame;
   1:         mPresShell->GetPlaceholderFrameFor(nextSibling, &placeholderFrame);
   1:         NS_ASSERTION(placeholderFrame, "no placeholder for out-of-flow frame");
   1:         nextSibling = placeholderFrame;
   1:       }
   1: 
   1:       // We found a next sibling, we're done!
   1:       return nextSibling;
   1:     }
   1:   }
   1: 
   1:   return nsnull;
   1: }
   1: 
   1: inline PRBool
   1: ShouldIgnoreSelectChild(nsIContent* aContainer)
   1: {
   1:   // Ignore options and optgroups inside a select (size > 1)
   1:   nsIAtom *containerTag = aContainer->Tag();
   1: 
   1:   if (containerTag == nsGkAtoms::optgroup ||
   1:       containerTag == nsGkAtoms::select) {
   1:     nsIContent* selectContent = aContainer;
   1: 
   1:     while (containerTag != nsGkAtoms::select) {
   1:       selectContent = selectContent->GetParent();
   1:       if (!selectContent) {
   1:         break;
   1:       }
   1:       containerTag = selectContent->Tag();
   1:     }
   1: 
   1:     nsCOMPtr<nsISelectElement> selectElement = do_QueryInterface(selectContent);
   1:     if (selectElement) {
   1:       nsAutoString selSize;
   1:       aContainer->GetAttr(kNameSpaceID_None, nsGkAtoms::size, selSize);
   1:       if (!selSize.IsEmpty()) {
   1:         PRInt32 err;
   1:         return (selSize.ToInteger(&err) > 1);
   1:       }
   1:     }
   1:   }
   1: 
   1:   return PR_FALSE;
   1: }
   1: 
   1: // For fieldsets, returns the area frame, if the child is not a legend. 
   1: static nsIFrame*
   1: GetAdjustedParentFrame(nsIFrame*       aParentFrame,
   1:                        nsIAtom*        aParentFrameType,
   1:                        nsIContent*     aParentContent,
   1:                        PRInt32         aChildIndex)
   1: {
4194:   NS_PRECONDITION(nsGkAtoms::tableOuterFrame != aParentFrameType,
4194:                   "Shouldn't be happening!");
4194:   
   1:   nsIContent *childContent = aParentContent->GetChildAt(aChildIndex);
   1:   nsIFrame* newParent = nsnull;
   1: 
4194:   if (nsGkAtoms::fieldSetFrame == aParentFrameType) {
   1:     // If the parent is a fieldSet, use the fieldSet's area frame as the
   1:     // parent unless the new content is a legend. 
   1:     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(childContent));
   1:     if (!legendContent) {
   1:       newParent = GetFieldSetAreaFrame(aParentFrame);
   1:     }
   1:   }
   1:   return (newParent) ? newParent : aParentFrame;
   1: }
   1: 
   1: static void
   1: InvalidateCanvasIfNeeded(nsIFrame* aFrame);
   1: 
   1: static PRBool
   1: IsSpecialFramesetChild(nsIContent* aContent)
   1: {
   1:   // IMPORTANT: This must match the conditions in nsHTMLFramesetFrame::Init.
   1:   return aContent->IsNodeOfType(nsINode::eHTML) &&
   1:     (aContent->Tag() == nsGkAtoms::frameset ||
   1:      aContent->Tag() == nsGkAtoms::frame);
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ContentAppended(nsIContent*     aContainer,
   1:                                        PRInt32         aNewIndexInContainer)
   1: {
   1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   1: #ifdef DEBUG
   1:   if (gNoisyContentUpdates) {
   1:     printf("nsCSSFrameConstructor::ContentAppended container=%p index=%d\n",
3233:            static_cast<void*>(aContainer), aNewIndexInContainer);
   1:     if (gReallyNoisyContentUpdates && aContainer) {
   1:       aContainer->List(stdout, 0);
   1:     }
   1:   }
   1: #endif
   1: 
   1: #ifdef MOZ_XUL
   1:   if (aContainer) {
   1:     PRInt32 namespaceID;
   1:     nsIAtom* tag =
   1:       mDocument->BindingManager()->ResolveTag(aContainer, &namespaceID);
   1: 
   1:     // Just ignore tree tags, anyway we don't create any frames for them.
   1:     if (tag == nsGkAtoms::treechildren ||
   1:         tag == nsGkAtoms::treeitem ||
   1:         tag == nsGkAtoms::treerow ||
   1:         (namespaceID == kNameSpaceID_XUL && gUseXBLForms &&
   1:          ShouldIgnoreSelectChild(aContainer)))
   1:       return NS_OK;
   1: 
   1:   }
   1: #endif // MOZ_XUL
   1: 
   1:   // Get the frame associated with the content
   1:   nsIFrame* parentFrame = GetFrameFor(aContainer);
   1:   if (! parentFrame)
   1:     return NS_OK;
   1: 
   1:   // See if we have an XBL insertion point. If so, then that's our
   1:   // real parent frame; if not, then the frame hasn't been built yet
   1:   // and we just bail.
   1:   //
   1:   nsIFrame* insertionPoint;
   1:   PRBool multiple = PR_FALSE;
   1:   GetInsertionPoint(parentFrame, nsnull, &insertionPoint, &multiple);
   1:   if (! insertionPoint)
   1:     return NS_OK; // Don't build the frames.
   1: 
   1:   PRBool hasInsertion = PR_FALSE;
   1:   if (!multiple) {
   1:     nsIDocument* document = nsnull; 
   1:     nsIContent *firstAppendedChild =
   1:       aContainer->GetChildAt(aNewIndexInContainer);
   1:     if (firstAppendedChild) {
   1:       document = firstAppendedChild->GetDocument();
   1:     }
   1:     if (document &&
   1:         document->BindingManager()->GetInsertionParent(firstAppendedChild)) {
   1:       hasInsertion = PR_TRUE;
   1:     }
   1:   }
   1:   
   1:   if (multiple || hasInsertion) {
   1:     // We have an insertion point.  There are some additional tests we need to do
   1:     // in order to ensure that an append is a safe operation.
   1:     PRUint32 childCount = 0;
   1:       
   1:     if (!multiple) {
   1:       // We may need to make multiple ContentInserted calls instead.  A
   1:       // reasonable heuristic to employ (in order to maintain good performance)
   1:       // is to find out if the insertion point's content node contains any
   1:       // explicit children.  If it does not, then it is highly likely that 
   1:       // an append is occurring.  (Note it is not definite, and there are insane
   1:       // cases we will not deal with by employing this heuristic, but it beats
   1:       // always falling back to multiple ContentInserted calls).
   1:       //
   1:       // In the multiple insertion point case, we know we're going to need to do
   1:       // multiple ContentInserted calls anyway.
   1:       childCount = insertionPoint->GetContent()->GetChildCount();
   1:     }
   1: 
   1:     if (multiple || childCount > 0) {
   1:       // Now comes the fun part.  For each appended child, we must obtain its
   1:       // insertion point and find its exact position within that insertion point.
   1:       // We then make a ContentInserted call with the correct computed index.
   1:       nsIContent* insertionContent = insertionPoint->GetContent();
   1:       
   1:       PRUint32 containerCount = aContainer->GetChildCount();
   1:       for (PRUint32 i = aNewIndexInContainer; i < containerCount; i++) {
   1:         nsIContent *child = aContainer->GetChildAt(i);
   1:         if (multiple) {
   1:           // Filters are in effect, so the insertion point needs to be refetched for
   1:           // each child.
   1:           GetInsertionPoint(parentFrame, child, &insertionPoint);
   1:           if (!insertionPoint) {
   1:             // This content node doesn't have an insertion point, so we just
   1:             // skip over it
   1:             continue;
   1:           }
   1:           insertionContent = insertionPoint->GetContent();
   1:         }
   1: 
   1:         // Construct an iterator to locate this child at its correct index.
   1:         ChildIterator iter, last;
   1:         for (ChildIterator::Init(insertionContent, &iter, &last);
   1:          iter != last;
   1:          ++iter) {
   1:           LAYOUT_PHASE_TEMP_EXIT();
   1:           nsIContent* item = nsCOMPtr<nsIContent>(*iter);
   1:           if (item == child)
   1:             // Call ContentInserted with this index.
   1:             ContentInserted(aContainer, child,
4696:                             iter.index(), mTempFrameTreeState);
   1:           LAYOUT_PHASE_TEMP_REENTER();
   1:         }
   1:       }
   1: 
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   parentFrame = insertionPoint;
   1: 
   1:   if (parentFrame->GetType() == nsGkAtoms::frameSetFrame) {
   1:     // Check whether we have any kids we care about.
   1:     PRUint32 count = aContainer->GetChildCount();
   1:     for (PRUint32 i = aNewIndexInContainer; i < count; ++i) {
   1:       if (IsSpecialFramesetChild(aContainer->GetChildAt(i))) {
   1:         // Just reframe the parent, since framesets are weird like that.
   1:         return RecreateFramesForContent(parentFrame->GetContent());
   1:       }
   1:     }
   1:   }
   1:   
   1:   if (parentFrame->IsLeaf()) {
   1:     // Nothing to do here; we shouldn't be constructing kids of leaves
   1:     return NS_OK;
   1:   }
   1:   
4696:   // If the frame we are manipulating is a ``special'' frame (that is, one
4696:   // that's been created as a result of a block-in-inline situation) then we
4696:   // need to append to the last special sibling, not to the frame itself.
   1:   if (IsFrameSpecial(parentFrame)) {
   1: #ifdef DEBUG
   1:     if (gNoisyContentUpdates) {
   1:       printf("nsCSSFrameConstructor::ContentAppended: parentFrame=");
   1:       nsFrame::ListTag(stdout, parentFrame);
   1:       printf(" is special\n");
   1:     }
   1: #endif
   1: 
   1:     // Since we're appending, we'll walk to the last anonymous frame
   1:     // that was created for the broken inline frame.
4696:     parentFrame = GetLastSpecialSibling(parentFrame);
   1:   }
   1: 
   1:   // Get the parent frame's last continuation
   1:   parentFrame = parentFrame->GetLastContinuation();
   1: 
   1:   nsIAtom* frameType = parentFrame->GetType();
4194:   // Deal with fieldsets
   1:   parentFrame = ::GetAdjustedParentFrame(parentFrame, frameType,
   1:                                          aContainer, aNewIndexInContainer);
   1: 
   1:   // Deal with possible :after generated content on the parent
   1:   nsIFrame* parentAfterFrame;
   1:   parentFrame =
   1:     ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
   1:                                         aContainer, parentFrame,
   1:                                         &parentAfterFrame);
   1:   
   1:   // Create some new frames
   1:   PRUint32                count;
   1:   nsFrameItems            frameItems;
   1:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
   1:                                 GetAbsoluteContainingBlock(parentFrame),
   1:                                 GetFloatContainingBlock(parentFrame));
   1: 
   1:   // See if the containing block has :first-letter style applied.
   1:   PRBool haveFirstLetterStyle = PR_FALSE, haveFirstLineStyle = PR_FALSE;
   1:   nsIFrame* containingBlock = state.mFloatedItems.containingBlock;
   1:   if (containingBlock) {
1254:     haveFirstLetterStyle = HasFirstLetterStyle(containingBlock);
1243:     haveFirstLineStyle =
1254:       ShouldHaveFirstLineStyle(containingBlock->GetContent(),
1243:                                containingBlock->GetStyleContext());
   1:   }
   1: 
   1:   if (haveFirstLetterStyle) {
   1:     // Before we get going, remove the current letter frames
   1:     RemoveLetterFrames(state.mPresContext, state.mPresShell,
   1:                        state.mFrameManager, containingBlock);
   1:   }
   1: 
   1:   // if the container is a table and a caption was appended, it needs to be put in
   1:   // the outer table frame's additional child list. 
   1:   nsFrameItems captionItems;
   1: 
   1:   // The last frame that we added to the list.
   1:   nsIFrame* oldNewFrame = nsnull;
   1: 
   1:   PRUint32 i;
   1:   count = aContainer->GetChildCount();
   1:   for (i = aNewIndexInContainer; i < count; i++) {
   1:     nsIFrame* newFrame = nsnull;
   1:     nsIContent *childContent = aContainer->GetChildAt(i);
4368: 
   1:     ConstructFrame(state, childContent, parentFrame, frameItems);
   1:     newFrame = frameItems.lastChild;
   1: 
   1:     if (newFrame && newFrame != oldNewFrame) {
   1:       InvalidateCanvasIfNeeded(newFrame);
   1:       oldNewFrame = newFrame;
   1:     }
   1:   }
   1: 
4368:   if (nsGkAtoms::tableFrame == frameType) {
4368:     // Pull out the captions.  Note that we don't want to do that as we go,
4368:     // because processing a single caption can add a whole bunch of things to
4368:     // the frame items due to pseudoframe processing.  So we'd have to pull
4368:     // captions from a list anyway; might as well do that here.
4368:     PullOutCaptionFrames(frameItems, captionItems);
4368:   }
4368:   
4368: 
   1:   // process the current pseudo frame state
   1:   if (!state.mPseudoFrames.IsEmpty()) {
   1:     ProcessPseudoFrames(state, frameItems);
   1:   }
   1: 
   1:   if (haveFirstLineStyle && parentFrame == containingBlock) {
   1:     // It's possible that some of the new frames go into a
   1:     // first-line frame. Look at them and see...
   1:     AppendFirstLineFrames(state, containingBlock->GetContent(),
   1:                           containingBlock, frameItems); 
   1:   }
   1: 
   1:   nsresult result = NS_OK;
   1: 
   1:   // Notify the parent frame passing it the list of new frames
4696:   if (NS_SUCCEEDED(result) &&
4696:       (frameItems.childList || captionItems.childList)) {
   1:     // Perform special check for diddling around with the frames in
   1:     // a special inline frame.
   1: 
4696:     // We can't have a block ::after inside an inline, so it's safe to ignore
4696:     // the fact that we're not really appending if there's ::after content.
4696:     // Indeed, if we're inserting before the ::after content that means the
4696:     // ::after content is not the last child of the block in the {ib} split,
4696:     // which is the only case in which we care whether we're appending.
4696:     if (WipeContainingBlock(state, containingBlock, parentFrame, frameItems,
4696:                             PR_TRUE, nsnull)) {
   1:       return NS_OK;
   1:     }
   1: 
   1:     // Append the flowed frames to the principal child list, tables need special treatment
   1:     if (nsGkAtoms::tableFrame == frameType) {
   1:       if (captionItems.childList) { // append the caption to the outer table
   1:         nsIFrame* outerTable = parentFrame->GetParent();
   1:         if (outerTable) { 
   1:           state.mFrameManager->AppendFrames(outerTable,
   1:                                             nsGkAtoms::captionList,
   1:                                             captionItems.childList);
   1:         }
   1:       }
   1:       if (frameItems.childList) { // append children of the inner table
4696:         AppendFrames(state, aContainer, parentFrame, frameItems,
   1:                      parentAfterFrame);
   1:       }
   1:     }
   1:     else {
4696:       AppendFrames(state, aContainer, parentFrame, frameItems,
   1:                    parentAfterFrame);
   1:     }
   1:   }
   1: 
   1:   // Recover first-letter frames
   1:   if (haveFirstLetterStyle) {
   1:     RecoverLetterFrames(state, containingBlock);
   1:   }
   1: 
   1: #ifdef DEBUG
   1:   if (gReallyNoisyContentUpdates) {
   1:     nsIFrameDebug* fdbg = nsnull;
   1:     CallQueryInterface(parentFrame, &fdbg);
   1:     if (fdbg) {
   1:       printf("nsCSSFrameConstructor::ContentAppended: resulting frame model:\n");
   1:       fdbg->List(stdout, 0);
   1:     }
   1:   }
   1: #endif
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: #ifdef MOZ_XUL
   1: 
   1: enum content_operation
   1: {
   1:     CONTENT_INSERTED,
   1:     CONTENT_REMOVED
   1: };
   1: 
   1: // Helper function to lookup the listbox body frame and send a notification
   1: // for insertion or removal of content
   1: static
   1: PRBool NotifyListBoxBody(nsPresContext*    aPresContext,
   1:                          nsIContent*        aContainer,
   1:                          nsIContent*        aChild,
   1:                          PRInt32            aIndexInContainer,
   1:                          nsIDocument*       aDocument,                         
   1:                          nsIFrame*          aChildFrame,
   1:                          PRBool             aUseXBLForms,
   1:                          content_operation  aOperation)
   1: {
   1:   if (!aContainer)
   1:     return PR_FALSE;
   1: 
   1:   if (aContainer->IsNodeOfType(nsINode::eXUL) &&
   1:       aChild->IsNodeOfType(nsINode::eXUL) &&
   1:       aContainer->Tag() == nsGkAtoms::listbox &&
   1:       aChild->Tag() == nsGkAtoms::listitem) {
   1:     nsCOMPtr<nsIDOMXULElement> xulElement = do_QueryInterface(aContainer);
   1:     nsCOMPtr<nsIBoxObject> boxObject;
   1:     xulElement->GetBoxObject(getter_AddRefs(boxObject));
   1:     nsCOMPtr<nsPIListBoxObject> listBoxObject = do_QueryInterface(boxObject);
   1:     if (listBoxObject) {
   1:       nsIListBoxObject* listboxBody = listBoxObject->GetListBoxBody();
   1:       if (listboxBody) {
3233:         nsListBoxBodyFrame *listBoxBodyFrame = static_cast<nsListBoxBodyFrame*>(listboxBody);
   1:         if (aOperation == CONTENT_REMOVED) {
   1:           // Except if we have an aChildFrame and its parent is not the right
   1:           // thing, then we don't do this.  Pseudo frames are so much fun....
   1:           if (!aChildFrame || aChildFrame->GetParent() == listBoxBodyFrame) {
   1:             listBoxBodyFrame->OnContentRemoved(aPresContext, aChildFrame,
   1:                                                aIndexInContainer);
   1:             return PR_TRUE;
   1:           }
   1:         } else {
   1:           listBoxBodyFrame->OnContentInserted(aPresContext, aChild);
   1:           return PR_TRUE;
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   PRInt32 namespaceID;
   1:   nsIAtom* tag =
   1:     aDocument->BindingManager()->ResolveTag(aContainer, &namespaceID);
   1: 
   1:   // Just ignore tree tags, anyway we don't create any frames for them.
3116:   if (aContainer->GetParent() &&
3116:       (tag == nsGkAtoms::treechildren ||
   1:        tag == nsGkAtoms::treeitem ||
   1:        tag == nsGkAtoms::treerow ||
   1:        (namespaceID == kNameSpaceID_XUL && aUseXBLForms &&
3116:         ShouldIgnoreSelectChild(aContainer))))
   1:     return PR_TRUE;
   1: 
   1:   return PR_FALSE;
   1: }
   1: #endif // MOZ_XUL
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ContentInserted(nsIContent*            aContainer,
   1:                                        nsIContent*            aChild,
   1:                                        PRInt32                aIndexInContainer,
4696:                                        nsILayoutHistoryState* aFrameState)
   1: {
   1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   1:   // XXXldb Do we need to re-resolve style to handle the CSS2 + combinator and
   1:   // the :empty pseudo-class?
   1: #ifdef DEBUG
   1:   if (gNoisyContentUpdates) {
   1:     printf("nsCSSFrameConstructor::ContentInserted container=%p child=%p index=%d\n",
3233:            static_cast<void*>(aContainer),
3233:            static_cast<void*>(aChild),
   1:            aIndexInContainer);
   1:     if (gReallyNoisyContentUpdates) {
   1:       (aContainer ? aContainer : aChild)->List(stdout, 0);
   1:     }
   1:   }
   1: #endif
   1: 
   1:   nsresult rv = NS_OK;
   1: 
   1: #ifdef MOZ_XUL
   1:   if (NotifyListBoxBody(mPresShell->GetPresContext(), aContainer, aChild,
   1:                         aIndexInContainer, 
   1:                         mDocument, nsnull, gUseXBLForms, CONTENT_INSERTED))
   1:     return NS_OK;
   1: #endif // MOZ_XUL
   1:   
   1:   // If we have a null parent, then this must be the document element
   1:   // being inserted
   1:   if (! aContainer) {
   1:     nsIContent *docElement = mDocument->GetRootContent();
   1: 
   1:     if (aChild == docElement) {
   1:       NS_PRECONDITION(nsnull == mInitialContainingBlock, "initial containing block already created");
   1:       
   1:       if (!mDocElementContainingBlock)
   1:         return NS_OK; // We get into this situation when an XBL binding is asynchronously
   1:                       // applied to the root tag (e.g., <window> in XUL).  It's ok.  We can
   1:                       // just bail here because the root will really be built later during
   1:                       // InitialReflow.
   1: 
   1:       // Create frames for the document element and its child elements
   1:       nsIFrame*               docElementFrame;
   1:       nsFrameConstructorState state(mPresShell, mFixedContainingBlock, nsnull,
   1:                                     nsnull, aFrameState);
3026:       rv = ConstructDocElementFrame(state,
   1:                                     docElement, 
   1:                                     mDocElementContainingBlock,
   1:                                     &docElementFrame);
   1:     
3026:       if (NS_SUCCEEDED(rv) && docElementFrame) {
   1:         if (mDocElementContainingBlock->GetStateBits() & NS_FRAME_FIRST_REFLOW) {
   1:           // Set the initial child list for the parent and wait on the initial
   1:           // reflow.
   1:           mDocElementContainingBlock->SetInitialChildList(nsnull, 
   1:                                                           docElementFrame);
   1:         } else {
   1:           // Whoops, we've already received our initial reflow! Insert the doc.
   1:           // element as a child so it reflows (note that containing block is
   1:           // empty, so we can simply append).
   1:           NS_ASSERTION(mDocElementContainingBlock->GetFirstChild(nsnull) == nsnull,
   1:                        "Unexpected child of document element containing block");
   1:           mDocElementContainingBlock->AppendFrames(nsnull, docElementFrame);
   1:         }
   1:         InvalidateCanvasIfNeeded(docElementFrame);
   1: #ifdef DEBUG
3026:         if (gReallyNoisyContentUpdates) {
   1:           nsIFrameDebug* fdbg = nsnull;
   1:           CallQueryInterface(docElementFrame, &fdbg);
   1:           if (fdbg) {
   1:             printf("nsCSSFrameConstructor::ContentInserted: resulting frame model:\n");
   1:             fdbg->List(stdout, 0);
   1:           }
   1:         }
   1: #endif
   1:       }
3026:     }
   1: 
   1:     // otherwise this is not a child of the root element, and we
   1:     // won't let it have a frame.
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Otherwise, we've got parent content. Find its frame.
   1:   nsIFrame* parentFrame = GetFrameFor(aContainer);
   1:   if (! parentFrame)
   1:     return NS_OK; // XXXwaterson will this break selects? (See ``Here
   1:     // we have been notified...'' below.)
   1: 
   1:   // See if we have an XBL insertion point. If so, then that's our
   1:   // real parent frame; if not, then the frame hasn't been built yet
   1:   // and we just bail.
   1:   nsIFrame* insertionPoint;
   1:   GetInsertionPoint(parentFrame, aChild, &insertionPoint);
   1:   if (! insertionPoint)
   1:     return NS_OK; // Don't build the frames.
   1: 
   1:   parentFrame = insertionPoint;
   1: 
   1:   // Find the frame that precedes the insertion point. Walk backwards
   1:   // from the parent frame to get the parent content, because if an
   1:   // XBL insertion point is involved, we'll need to use _that_ to find
   1:   // the preceding frame.
   1:   nsIContent* container = parentFrame->GetContent();
   1: 
   1:   // XXX if the insertionPoint was different from the original
   1:   // parentFrame, then aIndexInContainer is most likely completely
   1:   // wrong. What we need to do here is remember the original index,
   1:   // then as we insert, search the child list where we're about to put
   1:   // the new frame to make sure that it appears after any siblings
   1:   // with a lower index, and before any siblings with a higher
   1:   // index. Same with FindNextSibling(), below.
   1:   nsIFrame* prevSibling = (aIndexInContainer >= 0)
   1:     ? FindPreviousSibling(container, parentFrame, aIndexInContainer, aChild)
   1:     : FindPreviousAnonymousSibling(mPresShell, mDocument, aContainer, aChild);
   1: 
   1:   PRBool    isAppend = PR_FALSE;
   1:   nsIFrame* appendAfterFrame;  // This is only looked at when isAppend is true
   1:   nsIFrame* nextSibling = nsnull;
   1:     
   1:   // If there is no previous sibling, then find the frame that follows
   1:   if (! prevSibling) {
   1:     nextSibling = (aIndexInContainer >= 0)
   1:       ? FindNextSibling(container, parentFrame, aIndexInContainer, aChild)
   1:       : FindNextAnonymousSibling(mPresShell, mDocument, aContainer, aChild);
   1:   }
   1: 
   1:   // Now, find the geometric parent so that we can handle
   1:   // continuations properly. Use the prev sibling if we have it;
   1:   // otherwise use the next sibling.
   1:   if (prevSibling) {
4194:     parentFrame = prevSibling->GetParent()->GetContentInsertionFrame();
   1:   }
   1:   else if (nextSibling) {
4194:     parentFrame = nextSibling->GetParent()->GetContentInsertionFrame();
   1:   }
   1:   else {
   1:     // No previous or next sibling, so treat this like an appended frame.
   1:     isAppend = PR_TRUE;
4194:     // Deal with fieldsets
   1:     parentFrame = ::GetAdjustedParentFrame(parentFrame, parentFrame->GetType(),
   1:                                            aContainer, aIndexInContainer);
   1:     parentFrame =
   1:       ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
   1:                                           aContainer, parentFrame,
   1:                                           &appendAfterFrame);
   1:   }
   1: 
   1:   if (parentFrame->GetType() == nsGkAtoms::frameSetFrame &&
   1:       IsSpecialFramesetChild(aChild)) {
   1:     // Just reframe the parent, since framesets are weird like that.
   1:     return RecreateFramesForContent(parentFrame->GetContent());
   1:   }
   1:   
   1:   // Don't construct kids of leaves
   1:   if (parentFrame->IsLeaf()) {
   1:     return NS_OK;
   1:   }
   1:   
   1:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
   1:                                 GetAbsoluteContainingBlock(parentFrame),
   1:                                 GetFloatContainingBlock(parentFrame),
   1:                                 aFrameState);
   1: 
   1: 
   1:   // Recover state for the containing block - we need to know if
   1:   // it has :first-letter or :first-line style applied to it. The
   1:   // reason we care is that the internal structure in these cases
   1:   // is not the normal structure and requires custom updating
   1:   // logic.
   1:   nsIFrame* containingBlock = state.mFloatedItems.containingBlock;
   1:   PRBool haveFirstLetterStyle = PR_FALSE;
   1:   PRBool haveFirstLineStyle = PR_FALSE;
   1: 
   1:   // In order to shave off some cycles, we only dig up the
   1:   // containing block haveFirst* flags if the parent frame where
   1:   // the insertion/append is occurring is an inline or block
   1:   // container. For other types of containers this isn't relevant.
   1:   const nsStyleDisplay* parentDisplay = parentFrame->GetStyleDisplay();
   1: 
   1:   // Examine the parentFrame where the insertion is taking
   1:   // place. If it's a certain kind of container then some special
   1:   // processing is done.
   1:   if ((NS_STYLE_DISPLAY_BLOCK == parentDisplay->mDisplay) ||
   1:       (NS_STYLE_DISPLAY_LIST_ITEM == parentDisplay->mDisplay) ||
   1:       (NS_STYLE_DISPLAY_INLINE == parentDisplay->mDisplay) ||
   1:       (NS_STYLE_DISPLAY_INLINE_BLOCK == parentDisplay->mDisplay)) {
   1:     // Recover the special style flags for the containing block
   1:     if (containingBlock) {
1254:       haveFirstLetterStyle = HasFirstLetterStyle(containingBlock);
1243:       haveFirstLineStyle =
1254:         ShouldHaveFirstLineStyle(containingBlock->GetContent(),
1243:                                  containingBlock->GetStyleContext());
   1:     }
   1: 
   1:     if (haveFirstLetterStyle) {
   1:       // Get the correct parentFrame and prevSibling - if a
   1:       // letter-frame is present, use its parent.
   1:       if (parentFrame->GetType() == nsGkAtoms::letterFrame) {
   1:         parentFrame = parentFrame->GetParent();
   1:         container = parentFrame->GetContent();
   1:       }
   1: 
   1:       // Remove the old letter frames before doing the insertion
   1:       RemoveLetterFrames(state.mPresContext, mPresShell,
   1:                          state.mFrameManager,
   1:                          state.mFloatedItems.containingBlock);
   1: 
   1:       // Removing the letterframes messes around with the frame tree, removing
   1:       // and creating frames.  We need to reget our prevsibling.
   1:       // See XXX comment the first time we do this in this method....
   1:       prevSibling = (aIndexInContainer >= 0)
   1:         ? FindPreviousSibling(container, parentFrame, aIndexInContainer,
   1:                               aChild)
   1:         : FindPreviousAnonymousSibling(mPresShell, mDocument, aContainer,
   1:                                        aChild);
   1: 
   1:       // If there is no previous sibling, then find the frame that follows
   1:       if (! prevSibling) {
   1:         nextSibling = (aIndexInContainer >= 0)
   1:           ? FindNextSibling(container, parentFrame, aIndexInContainer, aChild)
   1:           : FindNextAnonymousSibling(mPresShell, mDocument, aContainer, aChild);
   1:       }
   1:     }
   1:   }
   1: 
   1:   // if the container is a table and a caption will be appended, it needs to be
   1:   // put in the outer table frame's additional child list.
   1:   
   1:   nsFrameItems frameItems, captionItems;
   1: 
   1:   ConstructFrame(state, aChild, parentFrame, frameItems);
   1:   if (frameItems.childList) {
   1:     InvalidateCanvasIfNeeded(frameItems.childList);
   1:     
   1:     if (nsGkAtoms::tableCaptionFrame == frameItems.childList->GetType()) {
   1:       NS_ASSERTION(frameItems.childList == frameItems.lastChild ,
   1:                    "adding a non caption frame to the caption childlist?");
   1:       captionItems.AddChild(frameItems.childList);
   1:       frameItems = nsFrameItems();
   1:     }
   1:   }
   1: 
   1:   // process the current pseudo frame state
   1:   if (!state.mPseudoFrames.IsEmpty())
   1:     ProcessPseudoFrames(state, frameItems);
   1: 
4194:   // If the parent of our current prevSibling is different from the frame we'll
4194:   // actually use as the parent, then the calculated insertion point is now
4194:   // invalid and as it is unknown where to insert correctly we append instead
4194:   // (bug 341858).
4194:   if (prevSibling && frameItems.childList &&
4194:       frameItems.childList->GetParent() != prevSibling->GetParent()) {
   1:     prevSibling = nsnull;
   1:     isAppend = PR_TRUE;
   1:     parentFrame =
   1:       ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
   1:                                           aContainer,
   1:                                           frameItems.childList->GetParent(),
   1:                                           &appendAfterFrame);
   1:   }
   1: 
   1:   // Perform special check for diddling around with the frames in
   1:   // a special inline frame.
4696:   // We can't have a block ::after inside an inline, so it's safe to ignore
4696:   // the fact that we're not really appending if there's ::after content.
4696:   // Indeed, if we're inserting before the ::after content that means the
4696:   // ::after content is not the last child of the block in the {ib} split,
4696:   // which is the only case in which we care whether we're appending.
4696:   if (WipeContainingBlock(state, containingBlock, parentFrame, frameItems,
4696:                           isAppend, prevSibling))
   1:     return NS_OK;
   1: 
   1:   if (haveFirstLineStyle && parentFrame == containingBlock) {
   1:     // It's possible that the new frame goes into a first-line
   1:     // frame. Look at it and see...
   1:     if (isAppend) {
   1:       // Use append logic when appending
   1:       AppendFirstLineFrames(state, containingBlock->GetContent(),
   1:                             containingBlock, frameItems); 
   1:     }
   1:     else {
   1:       // Use more complicated insert logic when inserting
   1:       InsertFirstLineFrames(state, aContainer, containingBlock, &parentFrame,
   1:                             prevSibling, frameItems);
   1:     }
   1:   }
   1:       
4696:   nsIFrame* const newFrame = frameItems.childList;
   1:   if (NS_SUCCEEDED(rv) && newFrame) {
   1:     NS_ASSERTION(!captionItems.childList, "leaking caption frames");
   1:     if (!prevSibling) {
   1:       // We're inserting the new frame as the first child. See if the
   1:       // parent has a :before pseudo-element
   1:       nsIFrame* firstChild = parentFrame->GetFirstChild(nsnull);
   1: 
   1:       if (firstChild &&
   1:           nsLayoutUtils::IsGeneratedContentFor(aContainer, firstChild,
   1:                                                nsCSSPseudoElements::before)) {
   1:         // Insert the new frames after the last continuation of the :before
   1:         prevSibling = firstChild->GetLastContinuation();
   1:         nsIFrame* newParent = prevSibling->GetParent();
   1:         if (newParent != parentFrame) {
   1:           nsHTMLContainerFrame::ReparentFrameViewList(state.mPresContext,
   1:                                                       newFrame, parentFrame,
   1:                                                       newParent);
   1:           parentFrame = newParent;
   1:         }
3663:         // We perhaps could leave this true and take the AppendFrames path
3663:         // below, but we'd have to update appendAfterFrame and it seems safer
3663:         // to force all insert-after-:before cases to take these to take the
3663:         // InsertFrames path
3663:         isAppend = PR_FALSE;
3663:       }
3663:     }
3663: 
3663:     // Notify the parent frame
3663:     if (isAppend) {
4696:       AppendFrames(state, aContainer, parentFrame, frameItems,
4696:                    appendAfterFrame);
3663:     } else {
   1:       state.mFrameManager->InsertFrames(parentFrame,
   1:                                         nsnull, prevSibling, newFrame);
   1:     }
   1:   }
   1:   else {
   1:     // we might have a caption treat it here
   1:     nsIFrame* newCaptionFrame = captionItems.childList;
   1:     if (NS_SUCCEEDED(rv) && newCaptionFrame) {
   1:       nsIFrame* outerTableFrame;
   1:       if (GetCaptionAdjustedParent(parentFrame, newCaptionFrame, &outerTableFrame)) {
4194:         // If the parent of our current prevSibling is different from the frame
4194:         // we'll actually use as the parent, then the calculated insertion
4194:         // point is now invalid (bug 341382).
4194:         if (prevSibling && prevSibling->GetParent() != outerTableFrame) {
   1:           prevSibling = nsnull;
   1:         }
   1:         // If the parent is not a outer table frame we will try to add frames
   1:         // to a named child list that the parent does not honour and the frames
   1:         // will get lost
   1:         NS_ASSERTION(nsGkAtoms::tableOuterFrame == outerTableFrame->GetType(),
   1:                      "Pseudo frame construction failure, "
   1:                      "a caption can be only a child of a outer table frame");
   1:         if (isAppend) {
   1:           state.mFrameManager->AppendFrames(outerTableFrame,
   1:                                             nsGkAtoms::captionList,
   1:                                             newCaptionFrame);
   1:         }
   1:         else {
   1:           state.mFrameManager->InsertFrames(outerTableFrame,
   1:                                             nsGkAtoms::captionList,
   1:                                             prevSibling, newCaptionFrame);
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   if (haveFirstLetterStyle) {
   1:     // Recover the letter frames for the containing block when
   1:     // it has first-letter style.
   1:     RecoverLetterFrames(state, state.mFloatedItems.containingBlock);
   1:   }
   1: 
   1: #ifdef DEBUG
   1:   if (gReallyNoisyContentUpdates && parentFrame) {
   1:     nsIFrameDebug* fdbg = nsnull;
   1:     CallQueryInterface(parentFrame, &fdbg);
   1:     if (fdbg) {
   1:       printf("nsCSSFrameConstructor::ContentInserted: resulting frame model:\n");
   1:       fdbg->List(stdout, 0);
   1:     }
   1:   }
   1: #endif
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ReinsertContent(nsIContent*     aContainer,
   1:                                        nsIContent*     aChild)
   1: {
   1:   PRInt32 ix = aContainer->IndexOf(aChild);
   1:   // XXX For now, do a brute force remove and insert.
   1:   // XXXbz this probably doesn't work so well with anonymous content
   1:   // XXXbz doesn't this need to do the state-saving stuff that
   1:   // RecreateFramesForContent does?
   1:   nsresult res = ContentRemoved(aContainer, aChild, ix, PR_TRUE);
   1: 
   1:   if (NS_SUCCEEDED(res)) {
4696:     res = ContentInserted(aContainer, aChild, ix, nsnull);
   1:   }
   1: 
   1:   return res;
   1: }
   1: 
   1: /**
   1:  * Called when a frame subtree is about to be deleted. Two important
   1:  * things happen:
   1:  *
   1:  * 1. For each frame in the subtree, we remove the mapping from the
   1:  *    content object to its frame
   1:  *
2454:  * 2. For child frames that have been moved out of the flow, we enqueue
2454:  *    the out-of-flow frame for deletion *if* the out-of-flow frame's
   1:  *    geometric parent is not in |aRemovedFrame|'s hierarchy (e.g., an
   1:  *    absolutely positioned element that has been promoted to be a direct
   1:  *    descendant of an area frame).
   1:  *
   1:  * Note: this function should only be called by DeletingFrameSubtree()
   1:  *
   1:  * @param   aRemovedFrame this is the frame that was removed from the
   1:  *            content model. As we recurse we need to remember this so we
   1:  *            can check if out-of-flow frames are a descendant of the frame
   1:  *            being removed
   1:  * @param   aFrame the local subtree that is being deleted. This is initially
   1:  *            the same as aRemovedFrame, but as we recurse down the tree
   1:  *            this changes
   1:  */
   1: static nsresult
   1: DoDeletingFrameSubtree(nsFrameManager* aFrameManager,
   1:                        nsVoidArray&    aDestroyQueue,
   1:                        nsIFrame*       aRemovedFrame,
   1:                        nsIFrame*       aFrame)
   1: {
   1:   // Remove the mapping from the content object to its frame.
   1:   nsIContent* content = aFrame->GetContent();
   1:   if (content) {
   1:     aFrameManager->RemoveAsPrimaryFrame(content, aFrame);
   1:     aFrameManager->ClearAllUndisplayedContentIn(content);
   1:   }
   1: 
   1:   nsIAtom* childListName = nsnull;
   1:   PRInt32 childListIndex = 0;
   1: 
   1:   do {
   1:     // Walk aFrame's normal flow child frames looking for placeholder frames.
   1:     nsIFrame* childFrame = aFrame->GetFirstChild(childListName);
   1:     for (; childFrame; childFrame = childFrame->GetNextSibling()) {
   1:       if (NS_LIKELY(nsGkAtoms::placeholderFrame != childFrame->GetType())) {
   1:         DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
   1:                                aRemovedFrame, childFrame);
   1: 
   1:       } else {
   1:         nsIFrame* outOfFlowFrame =
   1:           nsPlaceholderFrame::GetRealFrameForPlaceholder(childFrame);
   1:   
   1:         // Remove the mapping from the out-of-flow frame to its placeholder.
   1:         aFrameManager->UnregisterPlaceholderFrame((nsPlaceholderFrame*)childFrame);
   1:         // Don't SetOutOfFlowFrame(nsnull) here because the float cache depends
   1:         // on it when the float is removed later on, see bug 348688 comment 6.
   1:         
   1:         // Queue the out-of-flow frame to be destroyed only if aRemovedFrame is _not_
   1:         // one of its ancestor frames or if it is a popup frame. 
   1:         // If aRemovedFrame is an ancestor of the out-of-flow frame, then 
   1:         // the out-of-flow frame will be destroyed by aRemovedFrame.
   1:         if (outOfFlowFrame->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_POPUP ||
   1:             !nsLayoutUtils::IsProperAncestorFrame(aRemovedFrame, outOfFlowFrame)) {
   1:           NS_ASSERTION(aDestroyQueue.IndexOf(outOfFlowFrame) == kNotFound,
   1:                        "out-of-flow is already in the destroy queue");
   1:           aDestroyQueue.AppendElement(outOfFlowFrame);
   1:           // Recurse into the out-of-flow, it is now the aRemovedFrame.
   1:           DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
   1:                                  outOfFlowFrame, outOfFlowFrame);
   1:         }
   1:         else {
   1:           // Also recurse into the out-of-flow when it's a descendant of aRemovedFrame
   1:           // since we don't walk those lists, see |childListName| increment below.
   1:           DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
   1:                                  aRemovedFrame, outOfFlowFrame);
   1:         }
   1:       }
   1:     }
   1: 
   1:     // Move to next child list but skip lists with frames we should have
   1:     // a placeholder for.
   1:     do {
   1:       childListName = aFrame->GetAdditionalChildListName(childListIndex++);
   1:     } while (childListName == nsGkAtoms::floatList    ||
   1:              childListName == nsGkAtoms::absoluteList ||
   1:              childListName == nsGkAtoms::overflowOutOfFlowList ||
   1:              childListName == nsGkAtoms::fixedList);
   1:   } while (childListName);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:  * Called when a frame is about to be deleted. Calls DoDeletingFrameSubtree()
   1:  * for aFrame and each of its continuing frames
   1:  */
   1: static nsresult
   1: DeletingFrameSubtree(nsFrameManager* aFrameManager,
   1:                      nsIFrame*       aFrame)
   1: {
   1:   NS_ENSURE_TRUE(aFrame, NS_OK); // XXXldb Remove this sometime in the future.
   1: 
   1:   // If there's no frame manager it's probably because the pres shell is
   1:   // being destroyed.
   1:   if (NS_UNLIKELY(!aFrameManager)) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsAutoVoidArray destroyQueue;
   1: 
   1:   // If it's a "special" block-in-inline frame, then we can't really deal.
   1:   // That really shouldn't be happening.
   1:   NS_ASSERTION(!IsFrameSpecial(aFrame),
   1:                "DeletingFrameSubtree on a special frame.  Prepare to crash.");
   1: 
   1:   do {
   1:     DoDeletingFrameSubtree(aFrameManager, destroyQueue, aFrame, aFrame);
   1: 
   1:     // If it's split, then get the continuing frame. Note that we only do
   1:     // this for the top-most frame being deleted. Don't do it if we're
   1:     // recursing over a subtree, because those continuing frames should be
   1:     // found as part of the walk over the top-most frame's continuing frames.
   1:     // Walking them again will make this an N^2/2 algorithm.
   1:     aFrame = aFrame->GetNextContinuation();
   1:   } while (aFrame);
   1: 
   1:   // Now destroy any out-of-flow frames that have been enqueued for
   1:   // destruction.
   1:   for (PRInt32 i = destroyQueue.Count() - 1; i >= 0; --i) {
3233:     nsIFrame* outOfFlowFrame = static_cast<nsIFrame*>(destroyQueue[i]);
   1: 
   1:     // Ask the out-of-flow's parent to delete the out-of-flow
   1:     // frame from the right list.
   1:     aFrameManager->RemoveFrame(outOfFlowFrame->GetParent(),
   1:                                GetChildListNameFor(outOfFlowFrame),
   1:                                outOfFlowFrame);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::RemoveMappingsForFrameSubtree(nsIFrame* aRemovedFrame)
   1: {
   1:   if (NS_UNLIKELY(mIsDestroyingFrameTree)) {
   1:     // The frame tree might not be in a consistent state after
   1:     // WillDestroyFrameTree() has been called. Most likely we're destroying
   1:     // the pres shell which means the frame manager takes care of clearing all
   1:     // mappings so there is no need to walk the frame tree here, bug 372576.
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Save the frame tree's state before deleting it
   1:   CaptureStateFor(aRemovedFrame, mTempFrameTreeState);
   1: 
   1:   return ::DeletingFrameSubtree(mPresShell->FrameManager(), aRemovedFrame);
   1: }
   1: 
4162: static void UnregisterPlaceholderChain(nsFrameManager* frameManager,
4162:                                        nsPlaceholderFrame* placeholderFrame)
4162: {
4162:   // Remove the mapping from the frame to its placeholder
4162:   nsPlaceholderFrame* curFrame = placeholderFrame;
4162:   do {
4162:     frameManager->UnregisterPlaceholderFrame(curFrame);
4162:     curFrame = static_cast<nsPlaceholderFrame*>(curFrame->GetNextContinuation());
4162:   } while (curFrame);
4162: }
4162: 
   1: nsresult
   1: nsCSSFrameConstructor::ContentRemoved(nsIContent*     aContainer,
   1:                                       nsIContent*     aChild,
   1:                                       PRInt32         aIndexInContainer,
   1:                                       PRBool          aInReinsertContent)
   1: {
   1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   1:   // XXXldb Do we need to re-resolve style to handle the CSS2 + combinator and
   1:   // the :empty pseudo-class?
   1: 
   1: #ifdef DEBUG
   1:   if (gNoisyContentUpdates) {
   1:     printf("nsCSSFrameConstructor::ContentRemoved container=%p child=%p index=%d\n",
3233:            static_cast<void*>(aContainer),
3233:            static_cast<void*>(aChild),
   1:            aIndexInContainer);
   1:     if (gReallyNoisyContentUpdates) {
   1:       aContainer->List(stdout, 0);
   1:     }
   1:   }
   1: #endif
   1: 
   1:   nsFrameManager *frameManager = mPresShell->FrameManager();
   1:   nsPresContext *presContext = mPresShell->GetPresContext();
   1:   nsresult                  rv = NS_OK;
   1: 
   1:   // Find the child frame that maps the content
   1:   nsIFrame* childFrame =
   1:     mPresShell->FrameManager()->GetPrimaryFrameFor(aChild, aIndexInContainer);
   1: 
   1:   if (! childFrame) {
   1:     frameManager->ClearUndisplayedContentIn(aChild, aContainer);
   1:   }
   1: 
   1: #ifdef MOZ_XUL
   1:   if (NotifyListBoxBody(presContext, aContainer, aChild, aIndexInContainer, 
   1:                         mDocument, childFrame, gUseXBLForms, CONTENT_REMOVED))
   1:     return NS_OK;
   1: 
   1: #endif // MOZ_XUL
   1: 
   1:   if (childFrame) {
   1:     InvalidateCanvasIfNeeded(childFrame);
   1:     
   1:     // If the frame we are manipulating is a special frame then do
   1:     // something different instead of just inserting newly created
   1:     // frames.
   1:     // NOTE: if we are in ReinsertContent, 
   1:     //       then do not reframe as we are already doing just that!
4696:     if (!aInReinsertContent &&
4696:         MaybeRecreateContainerForIBSplitterFrame(childFrame, &rv)) {
4696:       return rv;
   1:     }
   1: 
   1:     // Get the childFrame's parent frame
   1:     nsIFrame* parentFrame = childFrame->GetParent();
   1: 
   1:     if (parentFrame->GetType() == nsGkAtoms::frameSetFrame &&
   1:         IsSpecialFramesetChild(aChild)) {
   1:       // Just reframe the parent, since framesets are weird like that.
   1:       return RecreateFramesForContent(parentFrame->GetContent());
   1:     }
   1: 
   1:     // Examine the containing-block for the removed content and see if
   1:     // :first-letter style applies.
   1:     nsIFrame* containingBlock = GetFloatContainingBlock(parentFrame);
1254:     PRBool haveFLS = containingBlock && HasFirstLetterStyle(containingBlock);
   1:     if (haveFLS) {
   1:       // Trap out to special routine that handles adjusting a blocks
   1:       // frame tree when first-letter style is present.
   1: #ifdef NOISY_FIRST_LETTER
   1:       printf("ContentRemoved: containingBlock=");
   1:       nsFrame::ListTag(stdout, containingBlock);
   1:       printf(" parentFrame=");
   1:       nsFrame::ListTag(stdout, parentFrame);
   1:       printf(" childFrame=");
   1:       nsFrame::ListTag(stdout, childFrame);
   1:       printf("\n");
   1: #endif
   1: 
   1:       // First update the containing blocks structure by removing the
   1:       // existing letter frames. This makes the subsequent logic
   1:       // simpler.
   1:       RemoveLetterFrames(presContext, mPresShell, frameManager,
   1:                          containingBlock);
   1: 
   1:       // Recover childFrame and parentFrame
   1:       childFrame = mPresShell->GetPrimaryFrameFor(aChild);
   1:       if (!childFrame) {
   1:         frameManager->ClearUndisplayedContentIn(aChild, aContainer);
   1:         return NS_OK;
   1:       }
   1:       parentFrame = childFrame->GetParent();
   1: 
   1: #ifdef NOISY_FIRST_LETTER
   1:       printf("  ==> revised parentFrame=");
   1:       nsFrame::ListTag(stdout, parentFrame);
   1:       printf(" childFrame=");
   1:       nsFrame::ListTag(stdout, childFrame);
   1:       printf("\n");
   1: #endif
   1:     }
   1: 
   1: #ifdef DEBUG
   1:     if (gReallyNoisyContentUpdates) {
   1:       printf("nsCSSFrameConstructor::ContentRemoved: childFrame=");
   1:       nsFrame::ListTag(stdout, childFrame);
   1:       printf("\n");
   1: 
   1:       nsIFrameDebug* fdbg = nsnull;
   1:       CallQueryInterface(parentFrame, &fdbg);
   1:       if (fdbg)
   1:         fdbg->List(stdout, 0);
   1:     }
   1: #endif
   1: 
   1:     // Walk the frame subtree deleting any out-of-flow frames, and
   1:     // remove the mapping from content objects to frames
   1:     ::DeletingFrameSubtree(frameManager, childFrame);
   1: 
   1:     // See if the child frame is an out-of-flow
   1:     if (childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
   1:       nsPlaceholderFrame* placeholderFrame =
   1:         frameManager->GetPlaceholderFrameFor(childFrame);
   1:       NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
   1: 
4162:       UnregisterPlaceholderChain(frameManager, placeholderFrame);
   1: 
   1:       // Now we remove the out-of-flow frame
   1:       // XXX has to be done first for now: for floats, the block's line list
   1:       // contains an array of pointers to the placeholder - we have to
   1:       // remove the float first (which gets rid of the lines
   1:       // reference to the placeholder and float) and then remove the
   1:       // placeholder
   1:       rv = frameManager->RemoveFrame(parentFrame,
   1:                                      GetChildListNameFor(childFrame),
   1:                                      childFrame);
   1: 
   1:       // Remove the placeholder frame first (XXX second for now) (so
   1:       // that it doesn't retain a dangling pointer to memory)
   1:       nsIFrame* placeholderParent = placeholderFrame->GetParent();
   1:       ::DeletingFrameSubtree(frameManager, placeholderFrame);
   1:       rv |= frameManager->RemoveFrame(placeholderParent,
   1:                                       nsnull, placeholderFrame);
   1:     } else {
   1:       // Notify the parent frame that it should delete the frame
   1:       // check for a table caption which goes on an additional child list with a different parent
   1:       nsIFrame* outerTableFrame; 
   1:       if (GetCaptionAdjustedParent(parentFrame, childFrame, &outerTableFrame)) {
   1:         rv = frameManager->RemoveFrame(outerTableFrame,
   1:                                        nsGkAtoms::captionList,
   1:                                        childFrame);
   1:       }
   1:       else {
   1:         rv = frameManager->RemoveFrame(parentFrame, nsnull, childFrame);
   1:       }
   1:     }
   1: 
   1:     if (mInitialContainingBlock == childFrame) {
   1:       mInitialContainingBlock = nsnull;
   1:       mInitialContainingBlockIsAbsPosContainer = PR_FALSE;
   1:     }
   1: 
   1:     if (haveFLS && mInitialContainingBlock) {
   1:       NS_ASSERTION(containingBlock == GetFloatContainingBlock(parentFrame),
   1:                    "What happened here?");
   1:       nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
   1:                                     GetAbsoluteContainingBlock(parentFrame),
   1:                                     containingBlock);
   1:       RecoverLetterFrames(state, containingBlock);
   1:     }
   1: 
   1: #ifdef DEBUG
   1:     if (gReallyNoisyContentUpdates && parentFrame) {
   1:       nsIFrameDebug* fdbg = nsnull;
   1:       CallQueryInterface(parentFrame, &fdbg);
   1:       if (fdbg) {
   1:         printf("nsCSSFrameConstructor::ContentRemoved: resulting frame model:\n");
   1:         fdbg->List(stdout, 0);
   1:       }
   1:     }
   1: #endif
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: #ifdef DEBUG
   1:   // To ensure that the functions below are only called within
   1:   // |ApplyRenderingChangeToTree|.
   1: static PRBool gInApplyRenderingChangeToTree = PR_FALSE;
   1: #endif
   1: 
   1: static void
   1: DoApplyRenderingChangeToTree(nsIFrame* aFrame,
   1:                              nsIViewManager* aViewManager,
   1:                              nsFrameManager* aFrameManager,
   1:                              nsChangeHint aChange);
   1: 
   1: /**
   1:  * @param aBoundsRect returns the bounds enclosing the areas covered by aFrame and its childre
   1:  * This rect is relative to aFrame's parent
   1:  */
   1: static void
   1: UpdateViewsForTree(nsIFrame* aFrame, nsIViewManager* aViewManager,
   1:                    nsFrameManager* aFrameManager,
 134:                    nsChangeHint aChange)
   1: {
   1:   NS_PRECONDITION(gInApplyRenderingChangeToTree,
   1:                   "should only be called within ApplyRenderingChangeToTree");
   1: 
   1:   nsIView* view = aFrame->GetView();
   1:   if (view) {
   1:     if (aChange & nsChangeHint_SyncFrameView) {
 238:       nsContainerFrame::SyncFrameViewProperties(aFrame->PresContext(),
   1:                                                 aFrame, nsnull, view);
   1:     }
   1:   }
   1: 
   1:   // now do children of frame
   1:   PRInt32 listIndex = 0;
   1:   nsIAtom* childList = nsnull;
   1: 
   1:   do {
   1:     nsIFrame* child = aFrame->GetFirstChild(childList);
   1:     while (child) {
   1:       if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
   1:         // only do frames that are in flow
   1:         if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
   1:           // get out of flow frame and start over there
   1:           nsIFrame* outOfFlowFrame =
   1:             nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
   1: 
   1:           DoApplyRenderingChangeToTree(outOfFlowFrame, aViewManager,
   1:                                        aFrameManager, aChange);
   1:         }
   1:         else {  // regular frame
 134:           UpdateViewsForTree(child, aViewManager, aFrameManager, aChange);
   1:         }
   1:       }
   1:       child = child->GetNextSibling();
   1:     }
   1:     childList = aFrame->GetAdditionalChildListName(listIndex++);
   1:   } while (childList);
   1: }
   1: 
   1: static void
   1: DoApplyRenderingChangeToTree(nsIFrame* aFrame,
   1:                              nsIViewManager* aViewManager,
   1:                              nsFrameManager* aFrameManager,
   1:                              nsChangeHint aChange)
   1: {
   1:   NS_PRECONDITION(gInApplyRenderingChangeToTree,
   1:                   "should only be called within ApplyRenderingChangeToTree");
   1: 
  94:   for ( ; aFrame; aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame)) {
   1:     // Get view if this frame has one and trigger an update. If the
   1:     // frame doesn't have a view, find the nearest containing view
   1:     // (adjusting r's coordinate system to reflect the nesting) and
   1:     // update there.
 134:     UpdateViewsForTree(aFrame, aViewManager, aFrameManager, aChange);
   1: 
   1:     // if frame has view, will already be invalidated
 134:     if (aChange & nsChangeHint_RepaintFrame) {
 134:       aFrame->Invalidate(aFrame->GetOverflowRect());
   1:     }
   1:   }
   1: }
   1: 
   1: static void
   1: ApplyRenderingChangeToTree(nsPresContext* aPresContext,
   1:                            nsIFrame* aFrame,
   1:                            nsChangeHint aChange)
   1: {
   1:   nsIPresShell *shell = aPresContext->PresShell();
   1:   PRBool isPaintingSuppressed = PR_FALSE;
   1:   shell->IsPaintingSuppressed(&isPaintingSuppressed);
   1:   if (isPaintingSuppressed) {
   1:     // Don't allow synchronous rendering changes when painting is turned off.
   1:     aChange = NS_SubtractHint(aChange, nsChangeHint_RepaintFrame);
   1:     if (!aChange) {
   1:       return;
   1:     }
   1:   }
   1: 
   1:   // If the frame's background is propagated to an ancestor, walk up to
   1:   // that ancestor.
   1:   const nsStyleBackground *bg;
   1:   PRBool isCanvas;
   1:   while (!nsCSSRendering::FindBackground(aPresContext, aFrame,
   1:                                          &bg, &isCanvas)) {
   1:     aFrame = aFrame->GetParent();
   1:     NS_ASSERTION(aFrame, "root frame must paint");
   1:   }
   1: 
   1:   nsIViewManager* viewManager = aPresContext->GetViewManager();
   1: 
   1:   // Trigger rendering updates by damaging this frame and any
   1:   // continuations of this frame.
   1: 
   1:   // XXX this needs to detect the need for a view due to an opacity change and deal with it...
   1: 
   1:   viewManager->BeginUpdateViewBatch();
   1: 
   1: #ifdef DEBUG
   1:   gInApplyRenderingChangeToTree = PR_TRUE;
   1: #endif
   1:   DoApplyRenderingChangeToTree(aFrame, viewManager, shell->FrameManager(),
   1:                                aChange);
   1: #ifdef DEBUG
   1:   gInApplyRenderingChangeToTree = PR_FALSE;
   1: #endif
   1:   
   1:   viewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
   1: }
   1: 
   1: /**
   1:  * This method invalidates the canvas when frames are removed or added for a
   1:  * node that might have its background propagated to the canvas, i.e., a
   1:  * document root node or an HTML BODY which is a child of the root node.
   1:  *
   1:  * @param aFrame a frame for a content node about to be removed or a frme that
   1:  *               was just created for a content node that was inserted.
   1:  */ 
   1: static void
   1: InvalidateCanvasIfNeeded(nsIFrame* aFrame)
   1: {
   1:   NS_ASSERTION(aFrame, "Must have frame!");
   1: 
   1:   //  Note that for both in ContentRemoved and ContentInserted the content node
   1:   //  will still have the right parent pointer, so looking at that is ok.
   1:   
   1:   nsIContent* node = aFrame->GetContent();
   1:   nsIContent* parent = node->GetParent();
   1:   if (parent) {
   1:     // Has a parent; might not be what we want
   1:     nsIContent* grandParent = parent->GetParent();
   1:     if (grandParent) {
   1:       // Has a grandparent, so not what we want
   1:       return;
   1:     }
   1: 
   1:     // Check whether it's an HTML body
   1:     if (node->Tag() != nsGkAtoms::body ||
   1:         !node->IsNodeOfType(nsINode::eHTML)) {
   1:       return;
   1:     }
   1:   }
   1: 
   1:   // At this point the node has no parent or it's an HTML <body> child of the
   1:   // root.  We might not need to invalidate in this case (eg we might be in
   1:   // XHTML or something), but chances are we want to.  Play it safe.  Find the
   1:   // frame to invalidate and do it.
   1:   nsIFrame *ancestor = aFrame;
   1:   const nsStyleBackground *bg;
   1:   PRBool isCanvas;
 238:   nsPresContext* presContext = aFrame->PresContext();
   1:   while (!nsCSSRendering::FindBackground(presContext, ancestor,
   1:                                          &bg, &isCanvas)) {
   1:     ancestor = ancestor->GetParent();
   1:     NS_ASSERTION(ancestor, "canvas must paint");
   1:   }
   1: 
   1:   if (ancestor->GetType() == nsGkAtoms::canvasFrame) {
   1:     // The canvas frame's dimensions are not meaningful; invalidate the
   1:     // viewport instead.
   1:     ancestor = ancestor->GetParent();
   1:   }
   1: 
   1:   if (ancestor != aFrame) {
   1:     ApplyRenderingChangeToTree(presContext, ancestor,
   1:                                nsChangeHint_RepaintFrame);
   1:   }
   1: }
   1: 
   1: nsresult
2724: nsCSSFrameConstructor::StyleChangeReflow(nsIFrame* aFrame)
   1: {
   1:   // If the frame hasn't even received an initial reflow, then don't
   1:   // send it a style-change reflow!
   1:   if (aFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)
   1:     return NS_OK;
   1: 
   1: #ifdef DEBUG
   1:   if (gNoisyContentUpdates) {
   1:     printf("nsCSSFrameConstructor::StyleChangeReflow: aFrame=");
   1:     nsFrame::ListTag(stdout, aFrame);
   1:     printf("\n");
   1:   }
   1: #endif
   1: 
   1:   // If the frame is part of a split block-in-inline hierarchy, then
   1:   // target the style-change reflow at the first ``normal'' ancestor
   1:   // so we're sure that the style change will propagate to any
   1:   // anonymously created siblings.
   1:   if (IsFrameSpecial(aFrame))
   1:     aFrame = GetIBContainingBlockFor(aFrame);
   1: 
1158:   mPresShell->FrameNeedsReflow(aFrame, nsIPresShell::eStyleChange,
1158:                                NS_FRAME_IS_DIRTY);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CharacterDataChanged(nsIContent* aContent,
   1:                                             PRBool aAppend)
   1: {
   1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   1:   nsresult      rv = NS_OK;
   1: 
   1:   // Find the child frame
   1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
   1: 
   1:   // Notify the first frame that maps the content. It will generate a reflow
   1:   // command
   1: 
   1:   // It's possible the frame whose content changed isn't inserted into the
   1:   // frame hierarchy yet, or that there is no frame that maps the content
   1:   if (nsnull != frame) {
   1: #if 0
   1:     NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
   1:        ("nsCSSFrameConstructor::CharacterDataChanged: content=%p[%s] subcontent=%p frame=%p",
   1:         aContent, ContentTag(aContent, 0),
   1:         aSubContent, frame));
   1: #endif
   1: 
   1:     // Special check for text content that is a child of a letter frame.  If
   1:     // this happens, we should remove the letter frame, do whatever we're
   1:     // planning to do with this notification, then put the letter frame back.
   1:     // Note that this is basically what ReinsertContent ends up doing; the
   1:     // reason we dont' want to call that here is that our text content could be
   1:     // native anonymous, in which case ReinsertContent would completely barf on
   1:     // it.  And reinserting the non-anonymous ancestor would just lead us to
   1:     // come back into this notification (e.g. if quotes or counters are
   1:     // involved), leading to a loop.
   1:     nsIFrame* block = GetFloatContainingBlock(frame);
   1:     PRBool haveFirstLetterStyle = PR_FALSE;
   1:     if (block) {
   1:       // See if the block has first-letter style applied to it.
1254:       haveFirstLetterStyle = HasFirstLetterStyle(block);
   1:       if (haveFirstLetterStyle) {
   1:         RemoveLetterFrames(mPresShell->GetPresContext(), mPresShell,
   1:                            mPresShell->FrameManager(), block);
   1:         // Reget |frame|, since we might have killed it.
   1:         // Do we really need to call CharacterDataChanged in this case, though?
   1:         frame = mPresShell->GetPrimaryFrameFor(aContent);
   1:         NS_ASSERTION(frame, "Should have frame here!");
   1:       }
   1:     }
   1: 
   1:     frame->CharacterDataChanged(mPresShell->GetPresContext(), aContent,
   1:                                 aAppend);
   1: 
   1:     if (haveFirstLetterStyle) {
   1:       nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
   1:                                     GetAbsoluteContainingBlock(frame),
   1:                                     block, nsnull);
   1:       RecoverLetterFrames(state, block);
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ProcessRestyledFrames(nsStyleChangeList& aChangeList)
   1: {
   1:   PRInt32 count = aChangeList.Count();
   1:   if (!count)
   1:     return NS_OK;
   1: 
   1:   nsPropertyTable *propTable = mPresShell->GetPresContext()->PropertyTable();
   1: 
   1:   // Mark frames so that we skip frames that die along the way, bug 123049.
   1:   // A frame can be in the list multiple times with different hints. Further
   1:   // optmization is possible if nsStyleChangeList::AppendChange could coalesce
   1:   PRInt32 index = count;
   1: 
   1:   while (0 <= --index) {
   1:     const nsStyleChangeData* changeData;
   1:     aChangeList.ChangeAt(index, &changeData);
   1:     if (changeData->mFrame) {
   1:       propTable->SetProperty(changeData->mFrame,
   1:                              nsGkAtoms::changeListProperty,
   1:                              nsnull, nsnull, nsnull);
   1:     }
   1:   }
   1: 
   1:   index = count;
   1:   while (0 <= --index) {
   1:     nsIFrame* frame;
   1:     nsIContent* content;
   1:     nsChangeHint hint;
   1:     aChangeList.ChangeAt(index, frame, content, hint);
   1: 
   1:     // skip any frame that has been destroyed due to a ripple effect
   1:     if (frame) {
   1:       nsresult res;
   1: 
   1:       propTable->GetProperty(frame, nsGkAtoms::changeListProperty, &res);
   1: 
   1:       if (NS_PROPTABLE_PROP_NOT_THERE == res)
   1:         continue;
   1:     }
   1: 
   1:     if (hint & nsChangeHint_ReconstructFrame) {
   1:       RecreateFramesForContent(content);
   1:     } else {
   1:       NS_ASSERTION(frame, "This shouldn't happen");
   1:       if (hint & nsChangeHint_ReflowFrame) {
2724:         StyleChangeReflow(frame);
   1:       }
   1:       if (hint & (nsChangeHint_RepaintFrame | nsChangeHint_SyncFrameView)) {
   1:         ApplyRenderingChangeToTree(mPresShell->GetPresContext(), frame, hint);
   1:       }
   1:       if (hint & nsChangeHint_UpdateCursor) {
   1:         nsIViewManager* viewMgr = mPresShell->GetViewManager();
   1:         if (viewMgr)
   1:           viewMgr->SynthesizeMouseMove(PR_FALSE);
   1:       }
   1:     }
   1: 
   1: #ifdef DEBUG
   1:     // reget from content since it may have been regenerated...
   1:     if (content) {
   1:       nsIFrame* frame = mPresShell->GetPrimaryFrameFor(content);
   1:       if (frame) {
   1:         mPresShell->FrameManager()->DebugVerifyStyleTree(frame);
   1:       }
   1:     } else {
   1:       NS_WARNING("Unable to test style tree integrity -- no content node");
   1:     }
   1: #endif
   1:   }
   1: 
   1:   // cleanup references
   1:   index = count;
   1:   while (0 <= --index) {
   1:     const nsStyleChangeData* changeData;
   1:     aChangeList.ChangeAt(index, &changeData);
   1:     if (changeData->mFrame) {
   1:       propTable->DeleteProperty(changeData->mFrame,
   1:                                 nsGkAtoms::changeListProperty);
   1:     }
   1:   }
   1: 
   1:   aChangeList.Clear();
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsCSSFrameConstructor::RestyleElement(nsIContent     *aContent,
   1:                                       nsIFrame       *aPrimaryFrame,
   1:                                       nsChangeHint   aMinHint)
   1: {
   1:   if (aMinHint & nsChangeHint_ReconstructFrame) {
   1:     RecreateFramesForContent(aContent);
   1:   } else if (aPrimaryFrame) {
   1:     nsStyleChangeList changeList;
   1:     if (aMinHint) {
   1:       changeList.AppendChange(aPrimaryFrame, aContent, aMinHint);
   1:     }
   1:     nsChangeHint frameChange = mPresShell->FrameManager()->
   1:       ComputeStyleChangeFor(aPrimaryFrame, &changeList, aMinHint);
   1: 
   1:     if (frameChange & nsChangeHint_ReconstructFrame) {
   1:       RecreateFramesForContent(aContent);
   1:       changeList.Clear();
   1:     } else {
   1:       ProcessRestyledFrames(changeList);
   1:     }
   1:   } else {
   1:     // no frames, reconstruct for content
   1:     MaybeRecreateFramesForContent(aContent);
   1:   }
   1: }
   1: 
   1: void
   1: nsCSSFrameConstructor::RestyleLaterSiblings(nsIContent *aContent)
   1: {
   1:   nsIContent *parent = aContent->GetParent();
   1:   if (!parent)
   1:     return; // root element has no later siblings
   1: 
   1:   for (PRInt32 index = parent->IndexOf(aContent) + 1,
   1:                index_end = parent->GetChildCount();
   1:        index != index_end; ++index) {
   1:     nsIContent *child = parent->GetChildAt(index);
   1:     if (!child->IsNodeOfType(nsINode::eELEMENT))
   1:       continue;
   1: 
   1:     nsIFrame* primaryFrame = mPresShell->GetPrimaryFrameFor(child);
   1:     RestyleElement(child, primaryFrame, NS_STYLE_HINT_NONE);
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ContentStatesChanged(nsIContent* aContent1,
   1:                                             nsIContent* aContent2,
   1:                                             PRInt32 aStateMask) 
   1: {
   1:   DoContentStateChanged(aContent1, aStateMask);
   1:   DoContentStateChanged(aContent2, aStateMask);
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsCSSFrameConstructor::DoContentStateChanged(nsIContent* aContent,
   1:                                              PRInt32 aStateMask) 
   1: {
   1:   nsStyleSet *styleSet = mPresShell->StyleSet();
   1:   nsPresContext *presContext = mPresShell->GetPresContext();
   1:   NS_ASSERTION(styleSet, "couldn't get style set");
   1: 
   1:   if (aContent) {
   1:     nsChangeHint hint = NS_STYLE_HINT_NONE;
   1:     // Any change to a content state that affects which frames we construct
   1:     // must lead to a frame reconstruct here if we already have a frame.
   1:     // Note that we never decide through non-CSS means to not create frames
   1:     // based on content states, so if we already don't have a frame we don't
   1:     // need to force a reframe -- if it's needed, the HasStateDependentStyle
   1:     // call will handle things.
   1:     nsIFrame* primaryFrame = mPresShell->GetPrimaryFrameFor(aContent);
   1:     if (primaryFrame) {
   1:       // If it's generated content, ignore LOADING/etc state changes on it.
   1:       if (!primaryFrame->IsGeneratedContentFrame() &&
   1:           (aStateMask & (NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED |
   1:                          NS_EVENT_STATE_SUPPRESSED | NS_EVENT_STATE_LOADING))) {
   1:         hint = nsChangeHint_ReconstructFrame;
   1:       } else {          
   1:         PRUint8 app = primaryFrame->GetStyleDisplay()->mAppearance;
   1:         if (app) {
   1:           nsITheme *theme = presContext->GetTheme();
   1:           if (theme && theme->ThemeSupportsWidget(presContext,
   1:                                                   primaryFrame, app)) {
   1:             PRBool repaint = PR_FALSE;
   1:             theme->WidgetStateChanged(primaryFrame, app, nsnull, &repaint);
   1:             if (repaint) {
   1:               NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
   1:             }
   1:           }
   1:         }
   1:       }
   1:     }
   1: 
   1:     nsReStyleHint rshint = 
   1:       styleSet->HasStateDependentStyle(presContext, aContent, aStateMask);
   1:       
   1:     PostRestyleEvent(aContent, rshint, hint);
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::AttributeChanged(nsIContent* aContent,
   1:                                         PRInt32 aNameSpaceID,
   1:                                         nsIAtom* aAttribute,
3410:                                         PRInt32 aModType,
3410:                                         PRUint32 aStateMask)
   1: {
   1:   nsresult  result = NS_OK;
   1: 
   1:   // Hold onto the PresShell to prevent ourselves from being destroyed.
   1:   // XXXbz how, exactly, would this attribute change cause us to be
   1:   // destroyed from inside this function?
   1:   nsCOMPtr<nsIPresShell> shell = mPresShell;
   1: 
   1:   // Get the frame associated with the content which is the highest in the frame tree
   1:   nsIFrame* primaryFrame = shell->GetPrimaryFrameFor(aContent); 
   1: 
   1: #if 0
   1:   NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
   1:      ("HTMLStyleSheet::AttributeChanged: content=%p[%s] frame=%p",
   1:       aContent, ContentTag(aContent, 0), frame));
   1: #endif
   1: 
   1:   // the style tag has its own interpretation based on aHint 
4036:   nsChangeHint hint = aContent->GetAttributeChangeHint(aAttribute, aModType);
   1: 
   1:   PRBool reframe = (hint & nsChangeHint_ReconstructFrame) != 0;
   1: 
   1: #ifdef MOZ_XUL
   1:   // The following listbox widget trap prevents offscreen listbox widget
   1:   // content from being removed and re-inserted (which is what would
   1:   // happen otherwise).
   1:   if (!primaryFrame && !reframe) {
   1:     PRInt32 namespaceID;
   1:     nsIAtom* tag =
   1:       mDocument->BindingManager()->ResolveTag(aContent, &namespaceID);
   1: 
   1:     if (namespaceID == kNameSpaceID_XUL &&
   1:         (tag == nsGkAtoms::listitem ||
   1:          tag == nsGkAtoms::listcell))
   1:       return NS_OK;
   1:   }
   1: 
   1:   if (aAttribute == nsGkAtoms::tooltiptext ||
   1:       aAttribute == nsGkAtoms::tooltip) 
   1:   {
   1:     nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
   1:     if (rootBox) {
   1:       if (aModType == nsIDOMMutationEvent::REMOVAL)
   1:         rootBox->RemoveTooltipSupport(aContent);
   1:       if (aModType == nsIDOMMutationEvent::ADDITION)
   1:         rootBox->AddTooltipSupport(aContent);
   1:     }
   1:   }
   1: 
   1: #endif // MOZ_XUL
   1: 
   1:   if (primaryFrame) {
   1:     // See if we have appearance information for a theme.
   1:     const nsStyleDisplay* disp = primaryFrame->GetStyleDisplay();
   1:     if (disp->mAppearance) {
   1:       nsPresContext* presContext = mPresShell->GetPresContext();
   1:       nsITheme *theme = presContext->GetTheme();
4036:       if (theme && theme->ThemeSupportsWidget(presContext, primaryFrame, disp->mAppearance)) {
   1:         PRBool repaint = PR_FALSE;
4036:         theme->WidgetStateChanged(primaryFrame, disp->mAppearance, aAttribute, &repaint);
   1:         if (repaint)
   1:           NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
   1:       }
   1:     }
   1:    
   1:     // let the frame deal with it now, so we don't have to deal later
   1:     result = primaryFrame->AttributeChanged(aNameSpaceID, aAttribute,
   1:                                             aModType);
   1:     // XXXwaterson should probably check for special IB siblings
   1:     // here, and propagate the AttributeChanged notification to
   1:     // them, as well. Currently, inline frames don't do anything on
   1:     // this notification, so it's not that big a deal.
   1:   }
   1: 
   1:   // See if we can optimize away the style re-resolution -- must be called after
   1:   // the frame's AttributeChanged() in case it does something that affects the style
   1:   nsFrameManager *frameManager = shell->FrameManager();
   1:   nsReStyleHint rshint = frameManager->HasAttributeDependentStyle(aContent,
   1:                                                                   aAttribute,
3410:                                                                   aModType,
3410:                                                                   aStateMask);
   1: 
   1:   PostRestyleEvent(aContent, rshint, hint);
   1: 
   1:   return result;
   1: }
   1: 
   1: void
   1: nsCSSFrameConstructor::EndUpdate()
   1: {
   1:   if (mUpdateCount == 1) {
   1:     // This is the end of our last update.  Before we decrement
   1:     // mUpdateCount, recalc quotes and counters as needed.
   1: 
 550:     RecalcQuotesAndCounters();
 550:     NS_ASSERTION(mUpdateCount == 1, "Odd update count");
 550:   }
 550: 
 550:   --mUpdateCount;
 550: }
 550: 
 550: void
 550: nsCSSFrameConstructor::RecalcQuotesAndCounters()
 550: {
   1:   if (mQuotesDirty) {
   1:     mQuotesDirty = PR_FALSE;
   1:     mQuoteList.RecalcAll();
   1:   }
   1: 
   1:   if (mCountersDirty) {
   1:     mCountersDirty = PR_FALSE;
   1:     mCounterManager.RecalcAll();
   1:   }
   1: 
   1:   NS_ASSERTION(!mQuotesDirty, "Quotes updates will be lost");
   1:   NS_ASSERTION(!mCountersDirty, "Counter updates will be lost");  
   1: }
   1: 
   1: void
   1: nsCSSFrameConstructor::WillDestroyFrameTree()
   1: {
   1: #if defined(DEBUG_dbaron_off)
   1:   mCounterManager.Dump();
   1: #endif
   1: 
   1:   mIsDestroyingFrameTree = PR_TRUE;
   1: 
   1:   // Prevent frame tree destruction from being O(N^2)
   1:   mQuoteList.Clear();
   1:   mCounterManager.Clear();
   1: 
   1:   // Cancel all pending re-resolves
   1:   mRestyleEvent.Revoke();
   1: }
   1: 
   1: //STATIC
   1: 
   1: // XXXbz I'd really like this method to go away. Once we have inline-block and
   1: // I can just use that for sized broken images, that can happen, maybe.
   1: void nsCSSFrameConstructor::GetAlternateTextFor(nsIContent*    aContent,
   1:                                                 nsIAtom*       aTag,  // content object's tag
   1:                                                 nsXPIDLString& aAltText)
   1: {
   1:   // The "alt" attribute specifies alternate text that is rendered
   1:   // when the image can not be displayed
   1: 
   1:   // If there's no "alt" attribute, and aContent is an input    
   1:   // element, then use the value of the "value" attribute
   1:   if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::alt, aAltText) &&
   1:       nsGkAtoms::input == aTag) {
   1:     // If there's no "value" attribute either, then use the localized string 
   1:     // for "Submit" as the alternate text.
   1:     if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::value, aAltText)) {
   1:       nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
   1:                                          "Submit", aAltText);      
   1:     }
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreateContinuingOuterTableFrame(nsIPresShell*    aPresShell,
   1:                                                        nsPresContext*  aPresContext,
   1:                                                        nsIFrame*        aFrame,
   1:                                                        nsIFrame*        aParentFrame,
   1:                                                        nsIContent*      aContent,
   1:                                                        nsStyleContext*  aStyleContext,
   1:                                                        nsIFrame**       aContinuingFrame)
   1: {
   1:   nsIFrame* newFrame = NS_NewTableOuterFrame(aPresShell, aStyleContext);
   1: 
   1:   if (newFrame) {
   1:     newFrame->Init(aContent, aParentFrame, aFrame);
   1:     // XXXbz should we be passing in a non-null aContentParentFrame?
   1:     nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1: 
   1:     // Create a continuing inner table frame, and if there's a caption then
   1:     // replicate the caption
   1:     nsFrameItems  newChildFrames;
   1: 
   1:     nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
   1:     if (childFrame) {
   1:       nsIFrame* continuingTableFrame;
   1:       nsresult rv = CreateContinuingFrame(aPresContext, childFrame, newFrame,
   1:                                           &continuingTableFrame);
   1:       if (NS_FAILED(rv)) {
   1:         newFrame->Destroy();
   1:         *aContinuingFrame = nsnull;
   1:         return rv;
   1:       }
   1:       newChildFrames.AddChild(continuingTableFrame);
   1:       
   1:       NS_ASSERTION(!childFrame->GetNextSibling(),"there can be only one inner table frame");
   1:     }
   1: 
   1:     // Set the outer table's initial child list
   1:     newFrame->SetInitialChildList(nsnull, newChildFrames.childList);
   1:     
   1:     *aContinuingFrame = newFrame;
   1:     return NS_OK;
   1:   }
   1:   else {
   1:     *aContinuingFrame = nsnull;
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreateContinuingTableFrame(nsIPresShell* aPresShell, 
   1:                                                   nsPresContext*  aPresContext,
   1:                                                   nsIFrame*        aFrame,
   1:                                                   nsIFrame*        aParentFrame,
   1:                                                   nsIContent*      aContent,
   1:                                                   nsStyleContext*  aStyleContext,
   1:                                                   nsIFrame**       aContinuingFrame)
   1: {
   1:   nsIFrame* newFrame = NS_NewTableFrame(aPresShell, aStyleContext);
   1: 
   1:   if (newFrame) {
   1:     newFrame->Init(aContent, aParentFrame, aFrame);
   1:     // XXXbz should we be passing in a non-null aContentParentFrame?
   1:     nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1: 
   1:     // Replicate any header/footer frames
   1:     nsFrameItems  childFrames;
   1:     nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
   1:     for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
   1:       // See if it's a header/footer, possibly wrapped in a scroll frame.
   1:       nsTableRowGroupFrame* rowGroupFrame =
   1:         nsTableFrame::GetRowGroupFrame(childFrame);
   1:       if (rowGroupFrame) {
   1:         // If the row group was continued, then don't replicate it.
   1:         nsIFrame* rgNextInFlow = rowGroupFrame->GetNextInFlow();
   1:         if (rgNextInFlow) {
   1:           rowGroupFrame->SetRepeatable(PR_FALSE);
   1:         }
   1:         else if (rowGroupFrame->IsRepeatable()) {        
   1:           // Replicate the header/footer frame.
   1:           nsTableRowGroupFrame*   headerFooterFrame;
   1:           nsFrameItems            childItems;
   1:           nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
   1:                                         GetAbsoluteContainingBlock(newFrame),
   1:                                         nsnull);
   1: 
3233:           headerFooterFrame = static_cast<nsTableRowGroupFrame*>
3233:                                          (NS_NewTableRowGroupFrame(aPresShell, rowGroupFrame->GetStyleContext()));
   1:           nsIContent* headerFooter = rowGroupFrame->GetContent();
   1:           headerFooterFrame->Init(headerFooter, newFrame, nsnull);
   1:           ProcessChildren(state, headerFooter, headerFooterFrame,
   1:                           PR_FALSE, childItems, PR_FALSE);
   1:           NS_ASSERTION(!state.mFloatedItems.childList, "unexpected floated element");
   1:           headerFooterFrame->SetInitialChildList(nsnull, childItems.childList);
   1:           headerFooterFrame->SetRepeatable(PR_TRUE);
   1: 
   1:           // Table specific initialization
   1:           headerFooterFrame->InitRepeatedFrame(aPresContext, rowGroupFrame);
   1: 
   1:           // XXX Deal with absolute and fixed frames...
   1:           childFrames.AddChild(headerFooterFrame);
   1:         }
   1:       }
   1:     }
   1:     
   1:     // Set the table frame's initial child list
   1:     newFrame->SetInitialChildList(nsnull, childFrames.childList);
   1:     
   1:     *aContinuingFrame = newFrame;
   1:     return NS_OK;
   1:   }
   1:   else {
   1:     *aContinuingFrame = nsnull;
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreateContinuingFrame(nsPresContext* aPresContext,
   1:                                              nsIFrame*       aFrame,
   1:                                              nsIFrame*       aParentFrame,
   1:                                              nsIFrame**      aContinuingFrame,
   1:                                              PRBool          aIsFluid)
   1: {
   1:   nsIPresShell*              shell = aPresContext->PresShell();
   1:   nsStyleContext*            styleContext = aFrame->GetStyleContext();
   1:   nsIFrame*                  newFrame = nsnull;
   1:   nsresult                   rv = NS_OK;
   1:   nsIFrame*                  nextContinuation = aFrame->GetNextContinuation();
   1:   nsIFrame*                  nextInFlow = aFrame->GetNextInFlow();
   1: 
   1:   // Use the frame type to determine what type of frame to create
   1:   nsIAtom* frameType = aFrame->GetType();
   1:   nsIContent* content = aFrame->GetContent();
   1: 
   1:   NS_ASSERTION(aFrame->GetSplittableType() != NS_FRAME_NOT_SPLITTABLE,
   1:                "why CreateContinuingFrame for a non-splittable frame?");
   1:   
   1:   if (nsGkAtoms::textFrame == frameType) {
   1:     newFrame = NS_NewContinuingTextFrame(shell, styleContext);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1:     }
   1:     
   1:   } else if (nsGkAtoms::inlineFrame == frameType) {
   1:     newFrame = NS_NewInlineFrame(shell, styleContext);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1:     }
   1:   
   1:   } else if (nsGkAtoms::blockFrame == frameType) {
   1:     newFrame = NS_NewBlockFrame(shell, styleContext);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1:     }
   1:   
   1:   } else if (nsGkAtoms::areaFrame == frameType) {
   1:     newFrame = NS_NewAreaFrame(shell, styleContext, 0);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1:     }
   1:   
   1:   } else if (nsGkAtoms::columnSetFrame == frameType) {
   1:     newFrame = NS_NewColumnSetFrame(shell, styleContext, 0);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1:     }
   1:   
   1:   } else if (nsGkAtoms::positionedInlineFrame == frameType) {
   1:     newFrame = NS_NewPositionedInlineFrame(shell, styleContext);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1:     }
   1: 
   1:   } else if (nsGkAtoms::pageFrame == frameType) {
   1:     nsIFrame* pageContentFrame;
   1:     rv = ConstructPageFrame(shell, aPresContext, aParentFrame, aFrame,
   1:                             newFrame, pageContentFrame);
   1:   } else if (nsGkAtoms::tableOuterFrame == frameType) {
   1:     rv = CreateContinuingOuterTableFrame(shell, aPresContext, aFrame, aParentFrame,
   1:                                          content, styleContext, &newFrame);
   1: 
   1:   } else if (nsGkAtoms::tableFrame == frameType) {
   1:     rv = CreateContinuingTableFrame(shell, aPresContext, aFrame, aParentFrame,
   1:                                     content, styleContext, &newFrame);
   1: 
   1:   } else if (nsGkAtoms::tableRowGroupFrame == frameType) {
   1:     newFrame = NS_NewTableRowGroupFrame(shell, styleContext);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1:     }
   1: 
   1:   } else if (nsGkAtoms::tableRowFrame == frameType) {
   1:     newFrame = NS_NewTableRowFrame(shell, styleContext);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1: 
   1:       // Create a continuing frame for each table cell frame
   1:       nsFrameItems  newChildList;
   1:       nsIFrame* cellFrame = aFrame->GetFirstChild(nsnull);
   1:       while (cellFrame) {
   1:         // See if it's a table cell frame
   1:         if (IS_TABLE_CELL(cellFrame->GetType())) {
   1:           nsIFrame* continuingCellFrame;
   1:           rv = CreateContinuingFrame(aPresContext, cellFrame, newFrame,
   1:                                      &continuingCellFrame);
   1:           if (NS_FAILED(rv)) {
   1:             nsFrameList tmp(newChildList.childList);
   1:             tmp.DestroyFrames();
   1:             newFrame->Destroy();
   1:             *aContinuingFrame = nsnull;
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1:           }
   1:           newChildList.AddChild(continuingCellFrame);
   1:         }
   1:         cellFrame = cellFrame->GetNextSibling();
   1:       }
   1:       
   1:       // Set the table cell's initial child list
   1:       newFrame->SetInitialChildList(nsnull, newChildList.childList);
   1:     }
   1: 
   1:   } else if (IS_TABLE_CELL(frameType)) {
   1:     newFrame = NS_NewTableCellFrame(shell, styleContext, IsBorderCollapse(aParentFrame));
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1: 
   1:       // Create a continuing area frame
   1:       nsIFrame* continuingAreaFrame;
   1:       nsIFrame* areaFrame = aFrame->GetFirstChild(nsnull);
   1:       rv = CreateContinuingFrame(aPresContext, areaFrame, newFrame,
   1:                                  &continuingAreaFrame);
   1:       if (NS_FAILED(rv)) {
   1:         newFrame->Destroy();
   1:         *aContinuingFrame = nsnull;
   1:         return rv;
   1:       }
   1: 
   1:       // Set the table cell's initial child list
   1:       newFrame->SetInitialChildList(nsnull, continuingAreaFrame);
   1:     }
   1:   
   1:   } else if (nsGkAtoms::lineFrame == frameType) {
   1:     newFrame = NS_NewFirstLineFrame(shell, styleContext);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1:     }
   1:   
   1:   } else if (nsGkAtoms::letterFrame == frameType) {
   1:     newFrame = NS_NewFirstLetterFrame(shell, styleContext);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1:     }
   1: 
   1:   } else if (nsGkAtoms::imageFrame == frameType) {
   1:     newFrame = NS_NewImageFrame(shell, styleContext);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1:     }
   1:   } else if (nsGkAtoms::placeholderFrame == frameType) {
   1:     // create a continuing out of flow frame
   1:     nsIFrame* oofFrame = nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
   1:     nsIFrame* oofContFrame;
   1:     rv = CreateContinuingFrame(aPresContext, oofFrame, aParentFrame, &oofContFrame);
   1:     if (NS_FAILED(rv)) {
   1:       *aContinuingFrame = nsnull;
   1:       return rv;
   1:     }
   1:     // create a continuing placeholder frame
   1:     rv = CreatePlaceholderFrameFor(shell, aPresContext, shell->FrameManager(),
   1:                                    content, oofContFrame, styleContext,
   1:                                    aParentFrame, &newFrame);
   1:     if (NS_FAILED(rv)) {
   1:       oofContFrame->Destroy();
   1:       *aContinuingFrame = nsnull;
   1:       return rv;
   1:     }
   1:     newFrame->Init(content, aParentFrame, aFrame);
   1:   } else if (nsGkAtoms::fieldSetFrame == frameType) {
   1:     newFrame = NS_NewFieldSetFrame(shell, styleContext);
   1: 
   1:     if (newFrame) {
   1:       newFrame->Init(content, aParentFrame, aFrame);
   1: 
   1:       // XXXbz should we be passing in a non-null aContentParentFrame?
   1:       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
   1: 
   1:       // Create a continuing area frame
   1:       // XXXbz we really shouldn't have to do this by hand!
   1:       nsIFrame* continuingAreaFrame;
   1:       nsIFrame* areaFrame = GetFieldSetAreaFrame(aFrame);
   1:       rv = CreateContinuingFrame(aPresContext, areaFrame, newFrame,
   1:                                  &continuingAreaFrame);
   1:       if (NS_FAILED(rv)) {
   1:         newFrame->Destroy();
   1:         *aContinuingFrame = nsnull;
   1:         return rv;
   1:       }
   1:       // Set the fieldset's initial child list
   1:       newFrame->SetInitialChildList(nsnull, continuingAreaFrame);
   1:     }
   1:   } else {
   1:     NS_NOTREACHED("unexpected frame type");
   1:     *aContinuingFrame = nsnull;
   1:     return NS_ERROR_UNEXPECTED;
   1:   }
   1: 
   1:   *aContinuingFrame = newFrame;
   1: 
   1:   if (!newFrame) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   // Init() set newFrame to be a fluid continuation of aFrame.
   1:   // If we want a non-fluid continuation, we need to call SetPrevContinuation()
   1:   // to reset NS_FRAME_IS_FLUID_CONTINUATION.
   1:   if (!aIsFluid) {
   1:     newFrame->SetPrevContinuation(aFrame);
   1:   }
   1: 
   1:   // A continuation of generated content is also generated content
   1:   if (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) {
   1:     newFrame->AddStateBits(NS_FRAME_GENERATED_CONTENT);
   1:   }
   1: 
   1:   if (nextInFlow) {
   1:     nextInFlow->SetPrevInFlow(newFrame);
   1:     newFrame->SetNextInFlow(nextInFlow);
   1:   } else if (nextContinuation) {
   1:     nextContinuation->SetPrevContinuation(newFrame);
   1:     newFrame->SetNextContinuation(nextContinuation);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
4347: nsresult
4347: nsCSSFrameConstructor::ReplicateFixedFrames(nsPageContentFrame* aParentFrame)
4347: {
4347:   // Now deal with fixed-pos things....  They should appear on all pages, and
4347:   // the placeholders must be kids of a block, so we want to move over the
4347:   // placeholders when processing the child of the pageContentFrame.
4347: 
4347:   nsIFrame* prevPageContentFrame = aParentFrame->GetPrevInFlow();
   1:   if (!prevPageContentFrame) {
4347:     return NS_OK;
4347:   }
4347:   nsIFrame* docRootFrame = aParentFrame->GetFirstChild(nsnull);
4366:   nsIFrame* prevDocRootFrame = prevPageContentFrame->GetFirstChild(nsnull);
4366:   if (!docRootFrame || !prevDocRootFrame) {
4366:     // document's root element frame missing
   1:     return NS_ERROR_UNEXPECTED;
   1:   }
   1: 
   1:   nsFrameItems fixedPlaceholders;
   1:   nsIFrame* firstFixed = prevPageContentFrame->GetFirstChild(nsGkAtoms::fixedList);
   1:   if (!firstFixed) {
   1:     return NS_OK;
   1:   }
   1: 
4347:   //XXXbz Should mInitialContainingBlock be docRootFrame? It probably doesn't matter.
   1:   nsFrameConstructorState state(mPresShell, aParentFrame,
   1:                                 mInitialContainingBlock,
   1:                                 mInitialContainingBlock);
   1: 
4366:   // Iterate across fixed frames and replicate each whose placeholder is a
4366:   // descendant of aFrame. (We don't want to explicitly copy placeholders that
4366:   // are within fixed frames, because that would cause duplicates on the new
4366:   // page - bug 389619)
   1:   for (nsIFrame* fixed = firstFixed; fixed; fixed = fixed->GetNextSibling()) {
4366:     nsIFrame* prevPlaceholder = nsnull;
4366:     mPresShell->GetPlaceholderFrameFor(fixed, &prevPlaceholder);
4366:     if (prevPlaceholder &&
4366:         nsLayoutUtils::IsProperAncestorFrame(prevDocRootFrame, prevPlaceholder)) {
4347:       nsresult rv = ConstructFrame(state, fixed->GetContent(),
4347:                                    docRootFrame, fixedPlaceholders);
4347:       NS_ENSURE_SUCCESS(rv, rv);
   1:     }
4366:   }
   1: 
   1:   // Add the placeholders to our primary child list.
   1:   // XXXbz this is a little screwed up, since the fixed frames will have the
   1:   // wrong parent block and hence auto-positioning will be broken.  Oh, well.
4347:   NS_ASSERTION(!docRootFrame->GetFirstChild(nsnull),
4347:                "leaking frames; doc root continuation must be empty");
4347:   docRootFrame->SetInitialChildList(nsnull, fixedPlaceholders.childList);
   1:   return NS_OK;
   1: }
   1: 
   1: // Helper function that searches the immediate child frames 
   1: // (and their children if the frames are "special")
   1: // for a frame that maps the specified content object
   1: nsIFrame*
   1: nsCSSFrameConstructor::FindFrameWithContent(nsFrameManager*  aFrameManager,
   1:                                             nsIFrame*        aParentFrame,
   1:                                             nsIContent*      aParentContent,
   1:                                             nsIContent*      aContent,
   1:                                             nsFindFrameHint* aHint)
   1: {
   1:   
   1: #ifdef NOISY_FINDFRAME
   1:   FFWC_totalCount++;
   1:   printf("looking for content=%p, given aParentFrame %p parentContent %p, hint is %s\n", 
   1:          aContent, aParentFrame, aParentContent, aHint ? "set" : "NULL");
   1: #endif
   1: 
   1:   NS_ENSURE_TRUE(aParentFrame != nsnull, nsnull);
   1: 
   1:   do {
   1:     // Search for the frame in each child list that aParentFrame supports
   1:     nsIAtom* listName = nsnull;
   1:     PRInt32 listIndex = 0;
   1:     PRBool searchAgain;
   1: 
   1:     do {
   1: #ifdef NOISY_FINDFRAME
   1:       FFWC_doLoop++;
   1: #endif
   1:       nsIFrame* kidFrame = nsnull;
   1: 
   1:       searchAgain = PR_FALSE;
   1: 
   1:       // if we were given an hint, try to use it here to find a good
   1:       // previous frame to start our search (|kidFrame|).
   1:       if (aHint) {
   1: #ifdef NOISY_FINDFRAME
   1:         printf("  hint frame is %p\n", aHint->mPrimaryFrameForPrevSibling);
   1: #endif
   1:         // start with the primary frame for aContent's previous sibling
   1:         kidFrame = aHint->mPrimaryFrameForPrevSibling;
   1:         // But if it's out of flow, start from its placeholder.
   1:         if (kidFrame && (kidFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
   1:           kidFrame = aFrameManager->GetPlaceholderFrameFor(kidFrame);
   1:         }
   1: 
   1:         if (kidFrame) {
   1:           // then use the next sibling frame as our starting point
   1:           if (kidFrame->GetNextSibling()) {
   1:             kidFrame = kidFrame->GetNextSibling();
   1:           }
   1:           else {
   1:             // The hint frame had no next sibling. Try the next-in-flow or
   1:             // special sibling of the parent of the hint frame (or its
   1:             // associated placeholder).
   1:             nsIFrame *parentFrame = kidFrame->GetParent();
   1:             kidFrame = nsnull;
   1:             if (parentFrame) {
  94:               parentFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(parentFrame);
   1:             }
   1:             if (parentFrame) {
   1:               // Found it, continue the search with its first child.
   1:               kidFrame = parentFrame->GetFirstChild(listName);
   1:               // Leave |aParentFrame| as-is, since the only time we'll
   1:               // reuse it is if the hint fails.
   1:             }
   1:           }
   1: #ifdef NOISY_FINDFRAME
   1:           printf("  hint gives us kidFrame=%p with parent frame %p content %p\n", 
   1:                   kidFrame, aParentFrame, aParentContent);
   1: #endif
   1:         }
   1:       }
   1:       if (!kidFrame) {  // we didn't have enough info to prune, start searching from the beginning
   1:         kidFrame = aParentFrame->GetFirstChild(listName);
   1:       }
   1:       while (kidFrame) {
   1:         // See if the child frame points to the content object we're
   1:         // looking for
   1:         nsIContent* kidContent = kidFrame->GetContent();
   1:         if (kidContent == aContent) {
   1: 
   1:           // We found a match.  Return the out-of-flow if it's a placeholder
   1:           return nsPlaceholderFrame::GetRealFrameFor(kidFrame);
   1:         }
   1: 
   1:         // only do this if there is content
   1:         if (kidContent) {
   1:           // We search the immediate children only, but if the child frame has
   1:           // the same content pointer as its parent then we need to search its
   1:           // child frames, too.
   1:           // We also need to search if the child content is anonymous and scoped
   1:           // to the parent content.
   1:           if (aParentContent == kidContent ||
   1:               (aParentContent && (aParentContent == kidContent->GetBindingParent()))) 
   1:           {
   1: #ifdef NOISY_FINDFRAME
   1:             FFWC_recursions++;
   1:             printf("  recursing with new parent set to kidframe=%p, parentContent=%p\n", 
   1:                    kidFrame, aParentContent);
   1: #endif
   1:             nsIFrame* matchingFrame =
   1:                 FindFrameWithContent(aFrameManager, kidFrame,
   1:                                      aParentContent, aContent, nsnull);
   1: 
   1:             if (matchingFrame) {
   1:               return matchingFrame;
   1:             }
   1:           }
   1:         }
   1: 
   1:         // Get the next sibling frame
   1:         kidFrame = kidFrame->GetNextSibling();
   1: #ifdef NOISY_FINDFRAME
   1:         FFWC_doSibling++;
   1:         if (kidFrame) {
   1:           printf("  searching sibling frame %p\n", kidFrame);
   1:         }
   1: #endif
   1:       }
   1: 
   1:       if (aHint) {
   1:         // If we get here, and we had a hint, then we didn't find a frame.
   1:         // The hint may have been a frame whose location in the frame tree
   1:         // doesn't match the location of its corresponding element in the
   1:         // DOM tree, e.g. a floated or absolutely positioned frame, or e.g.
   1:         // a <col> frame, in which case we'd be off in the weeds looking
   1:         // through something other than the primary frame list.
   1:         // Reboot the search from scratch, without the hint, but using the
   1:         // null child list again.
   1:         aHint = nsnull;
   1:         searchAgain = PR_TRUE;
   1:       } else {
   1:         listName = aParentFrame->GetAdditionalChildListName(listIndex++);
   1:       }
   1:     } while(listName || searchAgain);
   1: 
   1:     // We didn't find a matching frame. If aFrame has a next-in-flow,
   1:     // then continue looking there
  94:     aParentFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aParentFrame);
   1: #ifdef NOISY_FINDFRAME
   1:     if (aParentFrame) {
   1:       FFWC_nextInFlows++;
   1:       printf("  searching NIF frame %p\n", aParentFrame);
   1:     }
   1: #endif
   1:   } while (aParentFrame);
   1: 
   1:   // No matching frame
   1:   return nsnull;
   1: }
   1: 
   1: // Request to find the primary frame associated with a given content object.
   1: // This is typically called by the pres shell when there is no mapping in
   1: // the pres shell hash table
   1: nsresult
   1: nsCSSFrameConstructor::FindPrimaryFrameFor(nsFrameManager*  aFrameManager,
   1:                                            nsIContent*      aContent,
   1:                                            nsIFrame**       aFrame,
   1:                                            nsFindFrameHint* aHint)
   1: {
   1:   NS_ASSERTION(aFrameManager && aContent && aFrame, "bad arg");
   1: 
   1:   *aFrame = nsnull;  // initialize OUT parameter 
   1: 
   1:   // We want to be able to quickly map from a content object to its frame,
   1:   // but we also want to keep the hash table small. Therefore, many frames
   1:   // are not added to the hash table when they're first created:
   1:   // - text frames
   1:   // - inline frames (often things like FONT and B)
   1:   // - BR frames
   1:   // - internal table frames (row-group, row, cell, col-group, col)
   1:   //
   1:   // That means we need to need to search for the frame
   1:   nsIFrame*              parentFrame;   // this pointer is used to iterate across all frames that map to parentContent
   1: 
   1:   // Get the frame that corresponds to the parent content object.
   1:   // Note that this may recurse indirectly, because the pres shell will
   1:   // call us back if there is no mapping in the hash table
   1:   nsCOMPtr<nsIContent> parentContent = aContent->GetParent(); // Get this once
   1:   if (parentContent) {
   1:     parentFrame = aFrameManager->GetPrimaryFrameFor(parentContent, -1);
   1:     while (parentFrame) {
   1:       // Search the child frames for a match
   1:       *aFrame = FindFrameWithContent(aFrameManager, parentFrame,
   1:                                      parentContent, aContent, aHint);
   1: #ifdef NOISY_FINDFRAME
   1:       printf("FindFrameWithContent returned %p\n", *aFrame);
   1: #endif
   1: 
   1: #ifdef DEBUG
   1:       // if we're given a hint and we were told to verify, then compare the resulting frame with
   1:       // the frame we get by calling FindFrameWithContent *without* the hint.  
   1:       // Assert if they do not match
   1:       // Note that this makes finding frames *slower* than it was before the fix.
   1:       if (gVerifyFastFindFrame && aHint) 
   1:       {
   1: #ifdef NOISY_FINDFRAME
   1:         printf("VERIFYING...\n");
   1: #endif
   1:         nsIFrame *verifyTestFrame =
   1:             FindFrameWithContent(aFrameManager, parentFrame,
   1:                                  parentContent, aContent, nsnull);
   1: #ifdef NOISY_FINDFRAME
   1:         printf("VERIFY returned %p\n", verifyTestFrame);
   1: #endif
   1:         NS_ASSERTION(verifyTestFrame == *aFrame, "hint shortcut found wrong frame");
   1:       }
   1: #endif
   1:       // If we found a match, then add a mapping to the hash table so
   1:       // next time this will be quick
   1:       if (*aFrame) {
   1:         aFrameManager->SetPrimaryFrameFor(aContent, *aFrame);
   1:         break;
   1:       }
   1:       else if (IsFrameSpecial(parentFrame)) {
   1:         // If it's a "special" frame (that is, part of an inline
   1:         // that's been split because it contained a block), we need to
   1:         // follow the out-of-flow "special sibling" link, and search
   1:         // *that* subtree as well.
4696:         parentFrame = GetSpecialSibling(parentFrame);
   1:       }
   1:       else {
   1:         break;
   1:       }
   1:     }
   1:   }
   1: 
   1:   if (aHint && !*aFrame)
   1:   { // if we had a hint, and we didn't get a frame, see if we should try the slow way
   1:     if (aContent->IsNodeOfType(nsINode::eTEXT)) 
   1:     {
   1: #ifdef NOISY_FINDFRAME
   1:       FFWC_slowSearchForText++;
   1: #endif
   1:       // since we're passing in a null hint, we're guaranteed to only recurse once
   1:       return FindPrimaryFrameFor(aFrameManager, aContent, aFrame, nsnull);
   1:     }
   1:   }
   1: 
   1: #ifdef NOISY_FINDFRAME
   1:   printf("%10s %10s %10s %10s %10s \n", 
   1:          "total", "doLoop", "doSibling", "recur", "nextIF", "slowSearch");
   1:   printf("%10d %10d %10d %10d %10d \n", 
   1:          FFWC_totalCount, FFWC_doLoop, FFWC_doSibling, FFWC_recursions, 
   1:          FFWC_nextInFlows, FFWC_slowSearchForText);
   1: #endif
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::GetInsertionPoint(nsIFrame*     aParentFrame,
   1:                                          nsIContent*   aChildContent,
   1:                                          nsIFrame**    aInsertionPoint,
   1:                                          PRBool*       aMultiple)
   1: {
   1:   // Make the insertion point be the parent frame by default, in case
   1:   // we have to bail early.
   1:   *aInsertionPoint = aParentFrame;
   1: 
   1:   nsIContent* container = aParentFrame->GetContent();
   1:   if (!container)
   1:     return NS_OK;
   1: 
   1:   nsBindingManager *bindingManager = mDocument->BindingManager();
   1: 
   1:   nsIContent* insertionElement;
   1:   if (aChildContent) {
   1:     // We've got an explicit insertion child. Check to see if it's
   1:     // anonymous.
   1:     if (aChildContent->GetBindingParent() == container) {
   1:       // This child content is anonymous. Don't use the insertion
   1:       // point, since that's only for the explicit kids.
   1:       return NS_OK;
   1:     }
   1: 
   1:     PRUint32 index;
   1:     insertionElement = bindingManager->GetInsertionPoint(container,
   1:                                                          aChildContent,
   1:                                                          &index);
   1:   }
   1:   else {
   1:     PRBool multiple;
   1:     PRUint32 index;
   1:     insertionElement = bindingManager->GetSingleInsertionPoint(container,
   1:                                                                &index,
   1:                                                                &multiple);
   1:     if (multiple && aMultiple)
   1:       *aMultiple = multiple; // Record the fact that filters are in use.
   1:   }
   1: 
   1:   if (insertionElement) {
   1:     nsIFrame* insertionPoint = mPresShell->GetPrimaryFrameFor(insertionElement);
   1:     if (insertionPoint) {
   1:       // Use the content insertion frame of the insertion point.
   1:       insertionPoint = insertionPoint->GetContentInsertionFrame();
   1:       if (insertionPoint && insertionPoint != aParentFrame) 
   1:         GetInsertionPoint(insertionPoint, aChildContent, aInsertionPoint, aMultiple);
   1:     }
   1:     else {
   1:       // There was no frame created yet for the insertion point.
   1:       *aInsertionPoint = nsnull;
   1:     }
   1:   }
   1: 
   1:   // fieldsets have multiple insertion points.  Note that we might
   1:   // have to look at insertionElement here...
   1:   if (aMultiple && !*aMultiple) {
   1:     nsIContent* content = insertionElement ? insertionElement : container;
   1:     if (content->IsNodeOfType(nsINode::eHTML) &&
   1:         content->Tag() == nsGkAtoms::fieldset) {
   1:       *aMultiple = PR_TRUE;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // Capture state for the frame tree rooted at the frame associated with the
   1: // content object, aContent
   1: nsresult
   1: nsCSSFrameConstructor::CaptureStateForFramesOf(nsIContent* aContent,
   1:                                                nsILayoutHistoryState* aHistoryState)
   1: {
   1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
   1:   if (frame) {
   1:     CaptureStateFor(frame, aHistoryState);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: // Capture state for the frame tree rooted at aFrame.
   1: nsresult
   1: nsCSSFrameConstructor::CaptureStateFor(nsIFrame* aFrame,
   1:                                        nsILayoutHistoryState* aHistoryState)
   1: {
   1:   if (aFrame && aHistoryState) {
   1:     mPresShell->FrameManager()->CaptureFrameState(aFrame, aHistoryState);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::MaybeRecreateFramesForContent(nsIContent* aContent)
   1: {
   1:   nsresult result = NS_OK;
   1:   nsFrameManager *frameManager = mPresShell->FrameManager();
   1: 
   1:   nsStyleContext *oldContext = frameManager->GetUndisplayedContent(aContent);
   1:   if (oldContext) {
   1:     // The parent has a frame, so try resolving a new context.
   1:     nsRefPtr<nsStyleContext> newContext = mPresShell->StyleSet()->
   1:       ResolveStyleFor(aContent, oldContext->GetParent());
   1: 
   1:     frameManager->ChangeUndisplayedContent(aContent, newContext);
   1:     if (newContext->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_NONE) {
   1:       result = RecreateFramesForContent(aContent);
   1:     }
   1:   }
   1:   return result;
   1: }
   1: 
   1: PRBool
4696: nsCSSFrameConstructor::MaybeRecreateContainerForIBSplitterFrame(nsIFrame* aFrame,
4696:                                                                 nsresult* aResult)
4696: {
4696:   NS_PRECONDITION(aFrame, "Must have a frame");
4696:   NS_PRECONDITION(aFrame->GetParent(), "Frame shouldn't be root");
4696:   NS_PRECONDITION(aResult, "Null out param?");
4696:   NS_PRECONDITION(aFrame == aFrame->GetFirstContinuation(),
4696:                   "aFrame not the result of GetPrimaryFrameFor()?");
4696: 
4696:   if (IsFrameSpecial(aFrame)) {
4696:     // The removal functions can't handle removal of an {ib} split directly; we
4696:     // need to rebuild the containing block.
   1: #ifdef DEBUG
   1:     if (gNoisyContentUpdates) {
4696:       printf("nsCSSFrameConstructor::MaybeRecreateContainerForIBSplitterFrame: "
4696:              "frame=");
   1:       nsFrame::ListTag(stdout, aFrame);
   1:       printf(" is special\n");
   1:     }
   1: #endif
4696: 
   1:     *aResult = ReframeContainingBlock(aFrame);
   1:     return PR_TRUE;
   1:   }
   1: 
4696:   // We might still need to reconstruct things if the parent of aFrame is
4696:   // special, since in that case the removal of aFrame might affect the
4696:   // splitting of its parent.
4696:   nsIFrame* parent = aFrame->GetParent();
4696:   if (!IsFrameSpecial(parent)) {
4696:     return PR_FALSE;
4696:   }
4696: 
4717:   // If aFrame is an inline, then it cannot possibly have caused the splitting.
4717:   // If the frame is being reconstructed and being changed to a block, the
4717:   // ContentInserted call will handle the containing block reframe.  So in this
4717:   // case, try to be conservative about whether we need to reframe.  The only
4717:   // case when it's needed is if the inline is the only child of the tail end
4717:   // of an {ib} split, because the splitting code doesn't produce this tail end
4717:   // if it would have no kids.  If that ever changes, this code should change.
4717:   if (IsInlineOutside(aFrame) &&
4717:       (
4717:        // Not a kid of the third part of the IB split
4717:        GetSpecialSibling(parent) || !IsInlineOutside(parent) ||
4717:        // Or not the only child
4717:        aFrame->GetLastContinuation()->GetNextSibling() ||
4717:        aFrame != parent->GetFirstContinuation()->GetFirstChild(nsnull)
4717:       )) {
4717:     return PR_FALSE;
4717:   }
4717: 
4696: #ifdef DEBUG
5310:   if (gNoisyContentUpdates) {
4696:     printf("nsCSSFrameConstructor::MaybeRecreateContainerForIBSplitterFrame: "
4696:            "frame=");
4696:     nsFrame::ListTag(stdout, parent);
4696:     printf(" is special\n");
4696:   }
4696: #endif
4696: 
4696:   *aResult = ReframeContainingBlock(parent);
4696:   return PR_TRUE;
4696: }
4696:  
   1: nsresult
   1: nsCSSFrameConstructor::RecreateFramesForContent(nsIContent* aContent)
   1: {
   1:   // If there is no document, we don't want to recreate frames for it.  (You
   1:   // shouldn't generally be giving this method content without a document
   1:   // anyway).
   1:   // Rebuilding the frame tree can have bad effects, especially if it's the
   1:   // frame tree for chrome (see bug 157322).
   1:   NS_ENSURE_TRUE(aContent->GetDocument(), NS_ERROR_FAILURE);
   1: 
   1:   // Is the frame `special'? If so, we need to reframe the containing
   1:   // block *here*, rather than trying to remove and re-insert the
   1:   // content (which would otherwise result in *two* nested reframe
   1:   // containing block from ContentRemoved() and ContentInserted(),
4696:   // below!).  We'd really like to optimize away one of those
4696:   // containing block reframes, hence the code here.
   1: 
   1:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(aContent);
   1: 
   1:   nsresult rv = NS_OK;
   1: 
4696:   if (frame && MaybeRecreateContainerForIBSplitterFrame(frame, &rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   nsCOMPtr<nsIContent> container = aContent->GetParent();
   1:   if (container) {
   1:     // XXXbz what if this is anonymous content?
   1:     PRInt32 indexInContainer = container->IndexOf(aContent);
   1:     // Before removing the frames associated with the content object,
   1:     // ask them to save their state onto a temporary state object.
   1:     CaptureStateForFramesOf(aContent, mTempFrameTreeState);
   1: 
   1:     // Remove the frames associated with the content object on which
   1:     // the attribute change occurred.
   1:     rv = ContentRemoved(container, aContent, indexInContainer,
   1:                         PR_FALSE);
   1: 
   1:     if (NS_SUCCEEDED(rv)) {
   1:       // Now, recreate the frames associated with this content object.
   1:       rv = ContentInserted(container, aContent,
4696:                            indexInContainer, mTempFrameTreeState);
   1:     }
   1:   } else {
   1:     // The content is the root node, so just rebuild the world.
   1:     ReconstructDocElementHierarchy();
   1:   }
   1: 
   1: #ifdef ACCESSIBILITY
   1:   if (mPresShell->IsAccessibilityActive()) {
   1:     PRUint32 event;
   1:     if (frame) {
   1:       nsIFrame *newFrame = mPresShell->GetPrimaryFrameFor(aContent);
4516:       event = newFrame ? nsIAccessibleEvent::EVENT_ASYNCH_SIGNIFICANT_CHANGE :
4516:                          nsIAccessibleEvent::EVENT_ASYNCH_HIDE;
   1:     }
   1:     else {
4516:       event = nsIAccessibleEvent::EVENT_ASYNCH_SHOW;
   1:     }
   1: 
   1:     // A significant enough change occured that this part
   1:     // of the accessible tree is no longer valid.
   1:     nsCOMPtr<nsIAccessibilityService> accService = 
   1:       do_GetService("@mozilla.org/accessibilityService;1");
   1:     if (accService) {
   1:       accService->InvalidateSubtreeFor(mPresShell, aContent, event);
   1:     }
   1:   }
   1: #endif
   1: 
   1:   return rv;
   1: }
   1: 
   1: //////////////////////////////////////////////////////////////////////
   1: 
   1: // Block frame construction code
   1: 
   1: already_AddRefed<nsStyleContext>
   1: nsCSSFrameConstructor::GetFirstLetterStyle(nsIContent* aContent,
   1:                                            nsStyleContext* aStyleContext)
   1: {
   1:   if (aContent) {
   1:     return mPresShell->StyleSet()->
   1:       ResolvePseudoStyleFor(aContent,
   1:                             nsCSSPseudoElements::firstLetter, aStyleContext);
   1:   }
   1:   return nsnull;
   1: }
   1: 
   1: already_AddRefed<nsStyleContext>
   1: nsCSSFrameConstructor::GetFirstLineStyle(nsIContent* aContent,
   1:                                          nsStyleContext* aStyleContext)
   1: {
   1:   if (aContent) {
   1:     return mPresShell->StyleSet()->
   1:       ResolvePseudoStyleFor(aContent,
   1:                             nsCSSPseudoElements::firstLine, aStyleContext);
   1:   }
   1:   return nsnull;
   1: }
   1: 
   1: // Predicate to see if a given content (block element) has
   1: // first-letter style applied to it.
   1: PRBool
1254: nsCSSFrameConstructor::ShouldHaveFirstLetterStyle(nsIContent* aContent,
   1:                                                   nsStyleContext* aStyleContext)
   1: {
   1:   return nsLayoutUtils::HasPseudoStyle(aContent, aStyleContext,
   1:                                        nsCSSPseudoElements::firstLetter,
   1:                                        mPresShell->GetPresContext());
   1: }
   1: 
   1: PRBool
1254: nsCSSFrameConstructor::HasFirstLetterStyle(nsIFrame* aBlockFrame)
 551: {
 551:   NS_PRECONDITION(aBlockFrame, "Need a frame");
 551:   
 551: #ifdef DEBUG
 551:   nsBlockFrame* block;
 551:   NS_ASSERTION(NS_SUCCEEDED(aBlockFrame->QueryInterface(kBlockFrameCID,
 551:                                                         (void**)&block)) &&
 551:                block,
 551:                "Not a block frame?");
 551: #endif
 551: 
 551:   return (aBlockFrame->GetStateBits() & NS_BLOCK_HAS_FIRST_LETTER_STYLE) != 0;
 551: }
 551: 
 551: PRBool
1254: nsCSSFrameConstructor::ShouldHaveFirstLineStyle(nsIContent* aContent,
   1:                                                 nsStyleContext* aStyleContext)
   1: {
   1:   return nsLayoutUtils::HasPseudoStyle(aContent, aStyleContext,
   1:                                        nsCSSPseudoElements::firstLine,
   1:                                        mPresShell->GetPresContext());
   1: }
   1: 
   1: void
1254: nsCSSFrameConstructor::ShouldHaveSpecialBlockStyle(nsIContent* aContent,
   1:                                                    nsStyleContext* aStyleContext,
   1:                                                    PRBool* aHaveFirstLetterStyle,
   1:                                                    PRBool* aHaveFirstLineStyle)
   1: {
   1:   *aHaveFirstLetterStyle =
1254:     ShouldHaveFirstLetterStyle(aContent, aStyleContext);
   1:   *aHaveFirstLineStyle =
1254:     ShouldHaveFirstLineStyle(aContent, aStyleContext);
   1: }
   1: 
   1: /**
   1:  * Request to process the child content elements and create frames.
   1:  *
   1:  * @param   aContent the content object whose child elements to process
   1:  * @param   aFrame the frame associated with aContent. This will be the
   1:  *            parent frame (both content and geometric) for the flowed
   1:  *            child frames
   1:  */
   1: nsresult
   1: nsCSSFrameConstructor::ProcessChildren(nsFrameConstructorState& aState,
   1:                                        nsIContent*              aContent,
   1:                                        nsIFrame*                aFrame,
   1:                                        PRBool                   aCanHaveGeneratedContent,
   1:                                        nsFrameItems&            aFrameItems,
   1:                                        PRBool                   aParentIsBlock)
   1: {
   1:   NS_PRECONDITION(!aFrame->IsLeaf(), "Bogus ProcessChildren caller!");
   1:   // XXXbz ideally, this would do all the pushing of various
   1:   // containing blocks as needed, so callers don't have to do it...
   1:   nsresult rv = NS_OK;
 549:   // :before/:after content should have the same style context parent
 549:   // as normal kids.
 549:   nsStyleContext* styleContext =
 549:     nsFrame::CorrectStyleParentFrame(aFrame, nsnull)->GetStyleContext();
   1:     
   1:   if (aCanHaveGeneratedContent) {
   1:     // Probe for generated content before
   1:     nsIFrame* generatedFrame;
   1:     if (CreateGeneratedContentFrame(aState, aFrame, aContent,
   1:                                     styleContext, nsCSSPseudoElements::before,
   1:                                     &generatedFrame)) {
   1:       // Add the generated frame to the child list
   1:       aFrameItems.AddChild(generatedFrame);
   1:     }
   1:   }
   1: 
   1:  
   1:   // save the incoming pseudo frame state
   1:   nsPseudoFrames priorPseudoFrames;
   1:   aState.mPseudoFrames.Reset(&priorPseudoFrames);
   1: 
   1:   ChildIterator iter, last;
   1:   for (ChildIterator::Init(aContent, &iter, &last);
   1:        iter != last;
   1:        ++iter) {
   1:     rv = ConstructFrame(aState, nsCOMPtr<nsIContent>(*iter),
   1:                         aFrame, aFrameItems);
   1:     if (NS_FAILED(rv))
   1:       return rv;
   1:   }
   1: 
   1:   // process the current pseudo frame state
   1:   if (!aState.mPseudoFrames.IsEmpty()) {
   1:     ProcessPseudoFrames(aState, aFrameItems);
   1:   }
   1: 
   1:   // restore the incoming pseudo frame state
   1:   aState.mPseudoFrames = priorPseudoFrames;
   1: 
   1:   if (aCanHaveGeneratedContent) {
   1:     // Probe for generated content after
   1:     nsIFrame* generatedFrame;
   1:     if (CreateGeneratedContentFrame(aState, aFrame, aContent,
   1:                                     styleContext, nsCSSPseudoElements::after,
   1:                                     &generatedFrame)) {
   1:       // Add the generated frame to the child list
   1:       aFrameItems.AddChild(generatedFrame);
   1:     }
   1:   }
   1: 
   1:   if (aParentIsBlock) {
   1:     if (aState.mFirstLetterStyle) {
   1:       rv = WrapFramesInFirstLetterFrame(aState, aContent, aFrame, aFrameItems);
   1:     }
   1:     if (aState.mFirstLineStyle) {
   1:       rv = WrapFramesInFirstLineFrame(aState, aContent, aFrame, aFrameItems);
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: // Support for :first-line style
   1: 
   1: static void
   1: ReparentFrame(nsFrameManager* aFrameManager,
   1:               nsIFrame* aNewParentFrame,
   1:               nsIFrame* aFrame)
   1: {
   1:   aFrame->SetParent(aNewParentFrame);
   1:   aFrameManager->ReParentStyleContext(aFrame);
   1:   if (aFrame->GetStateBits() &
   1:       (NS_FRAME_HAS_VIEW | NS_FRAME_HAS_CHILD_WITH_VIEW)) {
   1:     // No need to walk up the tree, since the bits are already set
   1:     // right on the parent of aNewParentFrame.
   1:     NS_ASSERTION(aNewParentFrame->GetParent()->GetStateBits() &
   1:                    NS_FRAME_HAS_CHILD_WITH_VIEW,
   1:                  "aNewParentFrame's parent should have this bit set!");
   1:     aNewParentFrame->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
   1:   }
   1: }
   1: 
   1: // Special routine to handle placing a list of frames into a block
   1: // frame that has first-line style. The routine ensures that the first
   1: // collection of inline frames end up in a first-line frame.
   1: nsresult
   1: nsCSSFrameConstructor::WrapFramesInFirstLineFrame(
   1:   nsFrameConstructorState& aState,
   1:   nsIContent*              aBlockContent,
   1:   nsIFrame*                aBlockFrame,
   1:   nsFrameItems&            aFrameItems)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   // Find the first and last inline frame in aFrameItems
   1:   nsIFrame* kid = aFrameItems.childList;
   1:   nsIFrame* firstInlineFrame = nsnull;
   1:   nsIFrame* lastInlineFrame = nsnull;
   1:   while (kid) {
2829:     if (IsInlineOutside(kid)) {
   1:       if (!firstInlineFrame) firstInlineFrame = kid;
   1:       lastInlineFrame = kid;
   1:     }
   1:     else {
   1:       break;
   1:     }
   1:     kid = kid->GetNextSibling();
   1:   }
   1: 
   1:   // If we don't find any inline frames, then there is nothing to do
   1:   if (!firstInlineFrame) {
   1:     return rv;
   1:   }
   1: 
   1:   // Create line frame
   1:   nsStyleContext* parentStyle = aBlockFrame->GetStyleContext();
   1:   nsRefPtr<nsStyleContext> firstLineStyle = GetFirstLineStyle(aBlockContent,
   1:                                                               parentStyle);
   1: 
   1:   nsIFrame* lineFrame = NS_NewFirstLineFrame(mPresShell, firstLineStyle);
   1: 
   1:   if (lineFrame) {
   1:     // Initialize the line frame
   1:     rv = InitAndRestoreFrame(aState, aBlockContent, aBlockFrame, nsnull,
   1:                              lineFrame);
   1: 
   1:     // Mangle the list of frames we are giving to the block: first
   1:     // chop the list in two after lastInlineFrame
   1:     nsIFrame* secondBlockFrame = lastInlineFrame->GetNextSibling();
   1:     lastInlineFrame->SetNextSibling(nsnull);
   1: 
   1:     // The lineFrame will be the block's first child; the rest of the
   1:     // frame list (after lastInlineFrame) will be the second and
   1:     // subsequent children; join the list together and reset
   1:     // aFrameItems appropriately.
   1:     if (secondBlockFrame) {
   1:       lineFrame->SetNextSibling(secondBlockFrame);
   1:     }
   1:     if (aFrameItems.childList == lastInlineFrame) {
   1:       // Just in case the block had exactly one inline child
   1:       aFrameItems.lastChild = lineFrame;
   1:     }
   1:     aFrameItems.childList = lineFrame;
   1: 
   1:     // Give the inline frames to the lineFrame <b>after</b> reparenting them
   1:     kid = firstInlineFrame;
   1:     NS_ASSERTION(lineFrame->GetStyleContext() == firstLineStyle,
   1:                  "Bogus style context on line frame");
   1:     while (kid) {
   1:       ReparentFrame(aState.mFrameManager, lineFrame, kid);
   1:       kid = kid->GetNextSibling();
   1:     }
   1:     lineFrame->SetInitialChildList(nsnull, firstInlineFrame);
   1:   }
   1:   else {
   1:     rv = NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: // Special routine to handle appending a new frame to a block frame's
   1: // child list. Takes care of placing the new frame into the right
   1: // place when first-line style is present.
   1: nsresult
   1: nsCSSFrameConstructor::AppendFirstLineFrames(
   1:   nsFrameConstructorState& aState,
   1:   nsIContent*              aBlockContent,
   1:   nsIFrame*                aBlockFrame,
   1:   nsFrameItems&            aFrameItems)
   1: {
   1:   // It's possible that aBlockFrame needs to have a first-line frame
   1:   // created because it doesn't currently have any children.
   1:   nsIFrame* blockKid = aBlockFrame->GetFirstChild(nsnull);
   1:   if (!blockKid) {
   1:     return WrapFramesInFirstLineFrame(aState, aBlockContent,
   1:                                       aBlockFrame, aFrameItems);
   1:   }
   1: 
   1:   // Examine the last block child - if it's a first-line frame then
   1:   // appended frames need special treatment.
   1:   nsresult rv = NS_OK;
   1:   nsFrameList blockFrames(blockKid);
   1:   nsIFrame* lastBlockKid = blockFrames.LastChild();
   1:   if (lastBlockKid->GetType() != nsGkAtoms::lineFrame) {
   1:     // No first-line frame at the end of the list, therefore there is
   1:     // an interveening block between any first-line frame the frames
   1:     // we are appending. Therefore, we don't need any special
   1:     // treatment of the appended frames.
   1:     return rv;
   1:   }
   1:   nsIFrame* lineFrame = lastBlockKid;
   1: 
   1:   // Find the first and last inline frame in aFrameItems
   1:   nsIFrame* kid = aFrameItems.childList;
   1:   nsIFrame* firstInlineFrame = nsnull;
   1:   nsIFrame* lastInlineFrame = nsnull;
   1:   while (kid) {
2829:     if (IsInlineOutside(kid)) {
   1:       if (!firstInlineFrame) firstInlineFrame = kid;
   1:       lastInlineFrame = kid;
   1:     }
   1:     else {
   1:       break;
   1:     }
   1:     kid = kid->GetNextSibling();
   1:   }
   1: 
   1:   // If we don't find any inline frames, then there is nothing to do
   1:   if (!firstInlineFrame) {
   1:     return rv;
   1:   }
   1: 
   1:   // The inline frames get appended to the lineFrame. Make sure they
   1:   // are reparented properly.
   1:   nsIFrame* remainingFrames = lastInlineFrame->GetNextSibling();
   1:   lastInlineFrame->SetNextSibling(nsnull);
   1:   kid = firstInlineFrame;
   1:   while (kid) {
   1:     ReparentFrame(aState.mFrameManager, lineFrame, kid);
   1:     kid = kid->GetNextSibling();
   1:   }
   1:   aState.mFrameManager->AppendFrames(lineFrame, nsnull, firstInlineFrame);
   1: 
   1:   // The remaining frames get appended to the block frame
   1:   if (remainingFrames) {
   1:     aFrameItems.childList = remainingFrames;
   1:   }
   1:   else {
   1:     aFrameItems.childList = nsnull;
   1:     aFrameItems.lastChild = nsnull;
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: // Special routine to handle inserting a new frame into a block
   1: // frame's child list. Takes care of placing the new frame into the
   1: // right place when first-line style is present.
   1: nsresult
   1: nsCSSFrameConstructor::InsertFirstLineFrames(
   1:   nsFrameConstructorState& aState,
   1:   nsIContent*              aContent,
   1:   nsIFrame*                aBlockFrame,
   1:   nsIFrame**               aParentFrame,
   1:   nsIFrame*                aPrevSibling,
   1:   nsFrameItems&            aFrameItems)
   1: {
   1:   nsresult rv = NS_OK;
   1:   // XXXbz If you make this method actually do something, check to make sure
   1:   // that the caller is passing what you expect.  In particular, which content
   1:   // is aContent?
   1: #if 0
   1:   nsIFrame* parentFrame = *aParentFrame;
   1:   nsIFrame* newFrame = aFrameItems.childList;
2829:   PRBool isInline = IsInlineOutside(newFrame);
   1: 
   1:   if (!aPrevSibling) {
   1:     // Insertion will become the first frame. Two cases: we either
   1:     // already have a first-line frame or we don't.
   1:     nsIFrame* firstBlockKid = aBlockFrame->GetFirstChild(nsnull);
   1:     if (firstBlockKid->GetType() == nsGkAtoms::lineFrame) {
   1:       // We already have a first-line frame
   1:       nsIFrame* lineFrame = firstBlockKid;
   1: 
   1:       if (isInline) {
   1:         // Easy case: the new inline frame will go into the lineFrame.
   1:         ReparentFrame(aState.mFrameManager, lineFrame, newFrame);
   1:         aState.mFrameManager->InsertFrames(lineFrame, nsnull, nsnull,
   1:                                            newFrame);
   1: 
   1:         // Since the frame is going into the lineFrame, don't let it
   1:         // go into the block too.
   1:         aFrameItems.childList = nsnull;
   1:         aFrameItems.lastChild = nsnull;
   1:       }
   1:       else {
   1:         // Harder case: We are about to insert a block level element
   1:         // before the first-line frame.
   1:         // XXX need a method to steal away frames from the line-frame
   1:       }
   1:     }
   1:     else {
   1:       // We do not have a first-line frame
   1:       if (isInline) {
   1:         // We now need a first-line frame to contain the inline frame.
   1:         nsIFrame* lineFrame = NS_NewFirstLineFrame(firstLineStyle);
   1:         if (!lineFrame) {
   1:           rv = NS_ERROR_OUT_OF_MEMORY;
   1:         }
   1: 
   1:         if (NS_SUCCEEDED(rv)) {
   1:           // Lookup first-line style context
   1:           nsStyleContext* parentStyle = aBlockFrame->GetStyleContext();
   1:           nsRefPtr<nsStyleContext> firstLineStyle =
   1:             GetFirstLineStyle(aContent, parentStyle);
   1: 
   1:           // Initialize the line frame
   1:           rv = InitAndRestoreFrame(aState, aContent, aBlockFrame,
   1:                                    nsnull, lineFrame);
   1: 
   1:           // Make sure the caller inserts the lineFrame into the
   1:           // blocks list of children.
   1:           aFrameItems.childList = lineFrame;
   1:           aFrameItems.lastChild = lineFrame;
   1: 
   1:           // Give the inline frames to the lineFrame <b>after</b>
   1:           // reparenting them
   1:           NS_ASSERTION(lineFrame->GetStyleContext() == firstLineStyle,
   1:                        "Bogus style context on line frame");
   1:           ReparentFrame(aPresContext, lineFrame, newFrame);
   1:           lineFrame->SetInitialChildList(nsnull, newFrame);
   1:         }
   1:       }
   1:       else {
   1:         // Easy case: the regular insertion logic can insert the new
   1:         // frame because it's a block frame.
   1:       }
   1:     }
   1:   }
   1:   else {
   1:     // Insertion will not be the first frame.
   1:     nsIFrame* prevSiblingParent = aPrevSibling->GetParent();
   1:     if (prevSiblingParent == aBlockFrame) {
   1:       // Easy case: The prev-siblings parent is the block
   1:       // frame. Therefore the prev-sibling is not currently in a
   1:       // line-frame. Therefore the new frame which is going after it,
   1:       // regardless of type, is not going into a line-frame.
   1:     }
   1:     else {
   1:       // If the prevSiblingParent is not the block-frame then it must
   1:       // be a line-frame (if it were a letter-frame, that logic would
   1:       // already have adjusted the prev-sibling to be the
   1:       // letter-frame).
   1:       if (isInline) {
   1:         // Easy case: the insertion can go where the caller thinks it
   1:         // should go (which is into prevSiblingParent).
   1:       }
   1:       else {
   1:         // Block elements don't end up in line-frames, therefore
   1:         // change the insertion point to aBlockFrame. However, there
   1:         // might be more inline elements following aPrevSibling that
   1:         // need to be pulled out of the line-frame and become children
   1:         // of the block.
   1:         nsIFrame* nextSibling = aPrevSibling->GetNextSibling();
   1:         nsIFrame* nextLineFrame = prevSiblingParent->GetNextInFlow();
   1:         if (nextSibling || nextLineFrame) {
   1:           // Oy. We have work to do. Create a list of the new frames
   1:           // that are going into the block by stripping them away from
   1:           // the line-frame(s).
   1:           nsFrameList list(nextSibling);
   1:           if (nextSibling) {
   1:             nsLineFrame* lineFrame = (nsLineFrame*) prevSiblingParent;
   1:             lineFrame->StealFramesFrom(nextSibling);
   1:           }
   1: 
   1:           nsLineFrame* nextLineFrame = (nsLineFrame*) lineFrame;
   1:           for (;;) {
   1:             nextLineFrame = nextLineFrame->GetNextInFlow();
   1:             if (!nextLineFrame) {
   1:               break;
   1:             }
   1:             nsIFrame* kids = nextLineFrame->GetFirstChild(nsnull);
   1:           }
   1:         }
   1:         else {
   1:           // We got lucky: aPrevSibling was the last inline frame in
   1:           // the line-frame.
   1:           ReparentFrame(aState.mFrameManager, aBlockFrame, newFrame);
   1:           aState.mFrameManager->InsertFrames(aBlockFrame, nsnull,
   1:                                              prevSiblingParent, newFrame);
   1:           aFrameItems.childList = nsnull;
   1:           aFrameItems.lastChild = nsnull;
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1: #endif
   1:   return rv;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: // First-letter support
   1: 
   1: // Determine how many characters in the text fragment apply to the
   1: // first letter
   1: static PRInt32
   1: FirstLetterCount(const nsTextFragment* aFragment)
   1: {
   1:   PRInt32 count = 0;
   1:   PRInt32 firstLetterLength = 0;
   1:   PRBool done = PR_FALSE;
   1: 
   1:   PRInt32 i, n = aFragment->GetLength();
   1:   for (i = 0; i < n; i++) {
   1:     PRUnichar ch = aFragment->CharAt(i);
   1:     if (XP_IS_SPACE(ch)) {
   1:       if (firstLetterLength) {
   1:         done = PR_TRUE;
   1:         break;
   1:       }
   1:       count++;
   1:       continue;
   1:     }
   1:     // XXX I18n
   1:     if ((ch == '\'') || (ch == '\"')) {
   1:       if (firstLetterLength) {
   1:         done = PR_TRUE;
   1:         break;
   1:       }
   1:       // keep looping
   1:       firstLetterLength = 1;
   1:     }
   1:     else {
   1:       count++;
   1:       done = PR_TRUE;
   1:       break;
   1:     }
   1:   }
   1: 
   1:   return count;
   1: }
   1: 
   1: static PRBool
   1: NeedFirstLetterContinuation(nsIContent* aContent)
   1: {
   1:   NS_PRECONDITION(aContent, "null ptr");
   1: 
   1:   PRBool result = PR_FALSE;
   1:   if (aContent) {
   1:     const nsTextFragment* frag = aContent->GetText();
   1:     if (frag) {
   1:       PRInt32 flc = FirstLetterCount(frag);
   1:       PRInt32 tl = frag->GetLength();
   1:       if (flc < tl) {
   1:         result = PR_TRUE;
   1:       }
   1:     }
   1:   }
   1:   return result;
   1: }
   1: 
   1: static PRBool IsFirstLetterContent(nsIContent* aContent)
   1: {
   1:   return aContent->TextLength() &&
   1:          !aContent->TextIsOnlyWhitespace();
   1: }
   1: 
   1: /**
   1:  * Create a letter frame, only make it a floating frame.
   1:  */
   1: void
   1: nsCSSFrameConstructor::CreateFloatingLetterFrame(
   1:   nsFrameConstructorState& aState,
   1:   nsIFrame* aBlockFrame,
   1:   nsIContent* aTextContent,
   1:   nsIFrame* aTextFrame,
   1:   nsIContent* aBlockContent,
   1:   nsIFrame* aParentFrame,
   1:   nsStyleContext* aStyleContext,
   1:   nsFrameItems& aResult)
   1: {
   1:   // Create the first-letter-frame
   1:   nsresult rv;
   1:   nsIFrame* letterFrame;
   1:   nsStyleSet *styleSet = mPresShell->StyleSet();
   1: 
   1:   letterFrame = NS_NewFirstLetterFrame(mPresShell, aStyleContext);
   1:   // We don't want to use a text content for a non-text frame (because we want
   1:   // its primary frame to be a text frame).  So use its parent for the
   1:   // first-letter.
   1:   nsIContent* letterContent = aTextContent->GetParent();
   1:   NS_ASSERTION(letterContent->GetBindingParent() != letterContent,
   1:                "Reframes of this letter frame will mess with the root of a "
   1:                "native anonymous content subtree!");
   1:   InitAndRestoreFrame(aState, letterContent,
   1:                       aState.GetGeometricParent(aStyleContext->GetStyleDisplay(),
   1:                                                 aParentFrame),
   1:                       nsnull, letterFrame);
   1: 
   1:   // Init the text frame to refer to the letter frame. Make sure we
   1:   // get a proper style context for it (the one passed in is for the
   1:   // letter frame and will have the float property set on it; the text
   1:   // frame shouldn't have that set).
   1:   nsRefPtr<nsStyleContext> textSC;
   1:   textSC = styleSet->ResolveStyleForNonElement(aStyleContext);
   1:   aTextFrame->SetStyleContextWithoutNotification(textSC);
   1:   InitAndRestoreFrame(aState, aTextContent, letterFrame, nsnull, aTextFrame);
   1: 
   1:   // And then give the text frame to the letter frame
   1:   letterFrame->SetInitialChildList(nsnull, aTextFrame);
   1: 
   1:   // See if we will need to continue the text frame (does it contain
   1:   // more than just the first-letter text or not?) If it does, then we
   1:   // create (in advance) a continuation frame for it.
   1:   nsIFrame* nextTextFrame = nsnull;
   1:   if (NeedFirstLetterContinuation(aTextContent)) {
   1:     // Create continuation
   1:     rv = CreateContinuingFrame(aState.mPresContext, aTextFrame, aParentFrame,
   1:                                &nextTextFrame);
   1:     if (NS_FAILED(rv)) {
   1:       letterFrame->Destroy();
   1:       return;
   1:     }
   1:     // Repair the continuations style context
   1:     nsStyleContext* parentStyleContext = aStyleContext->GetParent();
   1:     if (parentStyleContext) {
   1:       nsRefPtr<nsStyleContext> newSC;
   1:       newSC = styleSet->ResolveStyleForNonElement(parentStyleContext);
   1:       if (newSC) {
   1:         nextTextFrame->SetStyleContext(newSC);
   1:       }
   1:     }
   1:   }
   1: 
   1:   NS_ASSERTION(aResult.childList == nsnull,
   1:                "aResult should be an empty nsFrameItems!");
   1:   nsIFrame* insertAfter = nsnull;
   1:   nsIFrame* f;
   1:   // Put the new float before any of the floats in the block we're
   1:   // doing first-letter for, that is, before any floats whose parent is aBlockFrame
   1:   for (f = aState.mFloatedItems.childList; f; f = f->GetNextSibling()) {
   1:     if (f->GetParent() == aBlockFrame)
   1:       break;
   1:     insertAfter = f;
   1:   }
   1: 
   1:   rv = aState.AddChild(letterFrame, aResult, letterFrame->GetStyleDisplay(),
   1:                        letterContent, aStyleContext, aParentFrame, PR_FALSE,
   1:                        PR_TRUE, PR_FALSE, PR_TRUE, insertAfter);
   1: 
   1:   if (nextTextFrame) {
   1:     if (NS_FAILED(rv)) {
   1:       nextTextFrame->Destroy();
   1:     } else {
   1:       aResult.AddChild(nextTextFrame);
   1:     }
   1:   }
   1: }
   1: 
   1: /**
   1:  * Create a new letter frame for aTextFrame. The letter frame will be
   1:  * a child of aParentFrame.
   1:  */
   1: nsresult
   1: nsCSSFrameConstructor::CreateLetterFrame(nsFrameConstructorState& aState,
   1:                                          nsIFrame* aBlockFrame,
   1:                                          nsIContent* aTextContent,
   1:                                          nsIFrame* aParentFrame,
   1:                                          nsFrameItems& aResult)
   1: {
   1:   NS_PRECONDITION(aTextContent->IsNodeOfType(nsINode::eTEXT),
   1:                   "aTextContent isn't text");
   1: 
 551: #ifdef DEBUG
 551:   {
 551:     nsBlockFrame* block;
 551:     NS_ASSERTION(NS_SUCCEEDED(aBlockFrame->QueryInterface(kBlockFrameCID,
 551:                                                           (void**)&block)) &&
 551:                  block,
 551:                  "Not a block frame?");
 551:   }
 551: #endif
 551: 
   1:   // Get style context for the first-letter-frame
   1:   nsStyleContext* parentStyleContext = aParentFrame->GetStyleContext();
   1:   if (parentStyleContext) {
   1:     // Use content from containing block so that we can actually
   1:     // find a matching style rule.
   1:     nsIContent* blockContent = aState.mFloatedItems.containingBlock->GetContent();
   1: 
   1:     NS_ASSERTION(blockContent == aBlockFrame->GetContent(),
   1:                  "Unexpected block content");
   1: 
   1:     // Create first-letter style rule
   1:     nsRefPtr<nsStyleContext> sc = GetFirstLetterStyle(blockContent,
   1:                                                       parentStyleContext);
   1:     if (sc) {
   1:       nsRefPtr<nsStyleContext> textSC;
   1:           textSC = mPresShell->StyleSet()->ResolveStyleForNonElement(sc);
   1:     
   1:       // Create a new text frame (the original one will be discarded)
   1:       // pass a temporary stylecontext, the correct one will be set later
   1:       nsIFrame* textFrame = NS_NewTextFrame(mPresShell, textSC);
   1: 
   1:       // Create the right type of first-letter frame
   1:       const nsStyleDisplay* display = sc->GetStyleDisplay();
   1:       if (display->IsFloating()) {
   1:         // Make a floating first-letter frame
   1:         CreateFloatingLetterFrame(aState, aBlockFrame, aTextContent, textFrame,
   1:                                   blockContent, aParentFrame,
   1:                                   sc, aResult);
   1:       }
   1:       else {
   1:         // Make an inflow first-letter frame
   1:         nsIFrame* letterFrame = NS_NewFirstLetterFrame(mPresShell, sc);
   1: 
   1:         if (letterFrame) {
   1:           // Initialize the first-letter-frame.  We don't want to use a text
   1:           // content for a non-text frame (because we want its primary frame to
   1:           // be a text frame).  So use its parent for the first-letter.
   1:           nsIContent* letterContent = aTextContent->GetParent();
   1:           NS_ASSERTION(letterContent->GetBindingParent() != letterContent,
   1:                        "Reframes of this letter frame will mess with the root "
   1:                        "of a native anonymous content subtree!");
   1:           letterFrame->Init(letterContent, aParentFrame, nsnull);
   1: 
   1:           InitAndRestoreFrame(aState, aTextContent, letterFrame, nsnull,
   1:                               textFrame);
   1: 
   1:           letterFrame->SetInitialChildList(nsnull, textFrame);
   1:           aResult.childList = aResult.lastChild = letterFrame;
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::WrapFramesInFirstLetterFrame(
   1:   nsFrameConstructorState& aState,
   1:   nsIContent*              aBlockContent,
   1:   nsIFrame*                aBlockFrame,
   1:   nsFrameItems&            aBlockFrames)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
 551:   aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_STYLE);
 551: 
   1:   nsIFrame* parentFrame = nsnull;
   1:   nsIFrame* textFrame = nsnull;
   1:   nsIFrame* prevFrame = nsnull;
   1:   nsFrameItems letterFrames;
   1:   PRBool stopLooking = PR_FALSE;
   1:   rv = WrapFramesInFirstLetterFrame(aState, aBlockFrame, aBlockFrame,
   1:                                     aBlockFrames.childList,
   1:                                     &parentFrame, &textFrame, &prevFrame,
   1:                                     letterFrames, &stopLooking);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1:   if (parentFrame) {
   1:     if (parentFrame == aBlockFrame) {
   1:       // Text textFrame out of the blocks frame list and substitute the
   1:       // letter frame(s) instead.
   1:       nsIFrame* nextSibling = textFrame->GetNextSibling();
   1:       textFrame->SetNextSibling(nsnull);
   1:       if (prevFrame) {
   1:         prevFrame->SetNextSibling(letterFrames.childList);
   1:       }
   1:       else {
   1:         aBlockFrames.childList = letterFrames.childList;
   1:       }
   1:       letterFrames.lastChild->SetNextSibling(nextSibling);
   1: 
   1:       // Destroy the old textFrame
   1:       textFrame->Destroy();
   1: 
   1:       // Repair lastChild; the only time this needs to happen is when
   1:       // the block had one child (the text frame).
   1:       if (!nextSibling) {
   1:         aBlockFrames.lastChild = letterFrames.lastChild;
   1:       }
   1:     }
   1:     else {
   1:       // Take the old textFrame out of the inline parents child list
   1:       ::DeletingFrameSubtree(aState.mFrameManager, textFrame);
   1:       parentFrame->RemoveFrame(nsnull, textFrame);
   1: 
   1:       // Insert in the letter frame(s)
   1:       parentFrame->InsertFrames(nsnull, prevFrame, letterFrames.childList);
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::WrapFramesInFirstLetterFrame(
   1:   nsFrameConstructorState& aState,
   1:   nsIFrame*                aBlockFrame,
   1:   nsIFrame*                aParentFrame,
   1:   nsIFrame*                aParentFrameList,
   1:   nsIFrame**               aModifiedParent,
   1:   nsIFrame**               aTextFrame,
   1:   nsIFrame**               aPrevFrame,
   1:   nsFrameItems&            aLetterFrames,
   1:   PRBool*                  aStopLooking)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsIFrame* prevFrame = nsnull;
   1:   nsIFrame* frame = aParentFrameList;
   1: 
   1:   while (frame) {
   1:     nsIFrame* nextFrame = frame->GetNextSibling();
   1: 
4696:     if (nsGkAtoms::textFrame == frame->GetType()) {
   1:       // Wrap up first-letter content in a letter frame
   1:       nsIContent* textContent = frame->GetContent();
   1:       if (IsFirstLetterContent(textContent)) {
   1:         // Create letter frame to wrap up the text
   1:         rv = CreateLetterFrame(aState, aBlockFrame, textContent,
   1:                                aParentFrame, aLetterFrames);
   1:         if (NS_FAILED(rv)) {
   1:           return rv;
   1:         }
   1: 
   1:         // Provide adjustment information for parent
   1:         *aModifiedParent = aParentFrame;
   1:         *aTextFrame = frame;
   1:         *aPrevFrame = prevFrame;
   1:         *aStopLooking = PR_TRUE;
   1:         return NS_OK;
   1:       }
   1:     }
4696:     else if (IsInlineFrame(frame)) {
   1:       nsIFrame* kids = frame->GetFirstChild(nsnull);
   1:       WrapFramesInFirstLetterFrame(aState, aBlockFrame, frame, kids,
   1:                                    aModifiedParent, aTextFrame,
   1:                                    aPrevFrame, aLetterFrames, aStopLooking);
   1:       if (*aStopLooking) {
   1:         return NS_OK;
   1:       }
   1:     }
   1:     else {
   1:       // This will stop us looking to create more letter frames. For
   1:       // example, maybe the frame-type is "letterFrame" or
   1:       // "placeholderFrame". This keeps us from creating extra letter
   1:       // frames, and also prevents us from creating letter frames when
   1:       // the first real content child of a block is not text (e.g. an
   1:       // image, hr, etc.)
   1:       *aStopLooking = PR_TRUE;
   1:       break;
   1:     }
   1: 
   1:     prevFrame = frame;
   1:     frame = nextFrame;
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::RemoveFloatingFirstLetterFrames(
   1:   nsPresContext* aPresContext,
   1:   nsIPresShell* aPresShell,
   1:   nsFrameManager* aFrameManager,
   1:   nsIFrame* aBlockFrame,
   1:   PRBool* aStopLooking)
   1: {
   1:   // First look for the float frame that is a letter frame
   1:   nsIFrame* floatFrame = aBlockFrame->GetFirstChild(nsGkAtoms::floatList);
   1:   while (floatFrame) {
   1:     // See if we found a floating letter frame
   1:     if (nsGkAtoms::letterFrame == floatFrame->GetType()) {
   1:       break;
   1:     }
   1:     floatFrame = floatFrame->GetNextSibling();
   1:   }
   1:   if (!floatFrame) {
   1:     // No such frame
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Take the text frame away from the letter frame (so it isn't
   1:   // destroyed when we destroy the letter frame).
   1:   nsIFrame* textFrame = floatFrame->GetFirstChild(nsnull);
   1:   if (!textFrame) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Discover the placeholder frame for the letter frame
   1:   nsIFrame* parentFrame;
   1:   nsPlaceholderFrame* placeholderFrame = 
   1:     aFrameManager->GetPlaceholderFrameFor(floatFrame);
   1: 
   1:   if (!placeholderFrame) {
   1:     // Somethings really wrong
   1:     return NS_OK;
   1:   }
   1:   parentFrame = placeholderFrame->GetParent();
   1:   if (!parentFrame) {
   1:     // Somethings really wrong
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Create a new text frame with the right style context that maps
   1:   // all of the content that was previously part of the letter frame
   1:   // (and probably continued elsewhere).
   1:   nsStyleContext* parentSC = parentFrame->GetStyleContext();
   1:   if (!parentSC) {
   1:     return NS_OK;
   1:   }
   1:   nsIContent* textContent = textFrame->GetContent();
   1:   if (!textContent) {
   1:     return NS_OK;
   1:   }
   1:   nsRefPtr<nsStyleContext> newSC;
   1:   newSC = aPresShell->StyleSet()->ResolveStyleForNonElement(parentSC);
   1:   if (!newSC) {
   1:     return NS_OK;
   1:   }
   1:   nsIFrame* newTextFrame = NS_NewTextFrame(aPresShell, newSC);
   1:   if (NS_UNLIKELY(!newTextFrame)) {
   1:     return NS_ERROR_OUT_OF_MEMORY;;
   1:   }
   1:   newTextFrame->Init(textContent, parentFrame, nsnull);
   1: 
   1:   // Destroy the old text frame's continuations (the old text frame
   1:   // will be destroyed when its letter frame is destroyed).
   1:   nsIFrame* nextTextFrame = textFrame->GetNextInFlow();
   1:   if (nextTextFrame) {
   1:     nsIFrame* nextTextParent = nextTextFrame->GetParent();
   1:     if (nextTextParent) {
   1:       nsSplittableFrame::BreakFromPrevFlow(nextTextFrame);
   1:       ::DeletingFrameSubtree(aFrameManager, nextTextFrame);
   1:       aFrameManager->RemoveFrame(nextTextParent, nsnull, nextTextFrame);
   1:     }
   1:   }
   1: 
   1:   // First find out where (in the content) the placeholder frames
   1:   // text is and its previous sibling frame, if any.  Note that:
   1:   // 1)  The placeholder had better be in the principal child list of
   1:   //     parentFrame.
   1:   // 2)  It's probably near the beginning (since we're a first-letter frame),
   1:   //     so just doing a linear search for the prevSibling is ok.
   1:   // 3)  Trying to use FindPreviousSibling will fail if the first-letter is in
   1:   //     anonymous content (eg generated content).
   1:   nsFrameList siblingList(parentFrame->GetFirstChild(nsnull));
   1:   NS_ASSERTION(siblingList.ContainsFrame(placeholderFrame),
   1:                "Placeholder not in parent's principal child list?");
   1:   nsIFrame* prevSibling = siblingList.GetPrevSiblingFor(placeholderFrame);
   1: 
   1:   // Now that everything is set...
   1: #ifdef NOISY_FIRST_LETTER
   1:   printf("RemoveFloatingFirstLetterFrames: textContent=%p oldTextFrame=%p newTextFrame=%p\n",
   1:          textContent.get(), textFrame, newTextFrame);
   1: #endif
4162: 
4162:   UnregisterPlaceholderChain(aFrameManager, placeholderFrame);
   1: 
   1:   // Remove the float frame
   1:   ::DeletingFrameSubtree(aFrameManager, floatFrame);
   1:   aFrameManager->RemoveFrame(aBlockFrame, nsGkAtoms::floatList,
   1:                              floatFrame);
   1: 
   1:   // Remove placeholder frame
4162:   ::DeletingFrameSubtree(aFrameManager, placeholderFrame);
   1:   aFrameManager->RemoveFrame(parentFrame, nsnull, placeholderFrame);
   1: 
   1:   // Insert text frame in its place
   1:   aFrameManager->InsertFrames(parentFrame, nsnull,
   1:                               prevSibling, newTextFrame);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::RemoveFirstLetterFrames(nsPresContext* aPresContext,
   1:                                                nsIPresShell* aPresShell,
   1:                                                nsFrameManager* aFrameManager,
   1:                                                nsIFrame* aFrame,
   1:                                                PRBool* aStopLooking)
   1: {
   1:   nsIFrame* prevSibling = nsnull;
   1:   nsIFrame* kid = aFrame->GetFirstChild(nsnull);
   1: 
   1:   while (kid) {
4696:     if (nsGkAtoms::letterFrame == kid->GetType()) {
   1:       // Bingo. Found it. First steal away the text frame.
   1:       nsIFrame* textFrame = kid->GetFirstChild(nsnull);
   1:       if (!textFrame) {
   1:         break;
   1:       }
   1: 
   1:       // Create a new textframe
   1:       nsStyleContext* parentSC = aFrame->GetStyleContext();
   1:       if (!parentSC) {
   1:         break;
   1:       }
   1:       nsIContent* textContent = textFrame->GetContent();
   1:       if (!textContent) {
   1:         break;
   1:       }
   1:       nsRefPtr<nsStyleContext> newSC;
   1:       newSC = aPresShell->StyleSet()->ResolveStyleForNonElement(parentSC);
   1:       if (!newSC) {
   1:         break;
   1:       }
   1:       textFrame = NS_NewTextFrame(aPresShell, newSC);
   1:       textFrame->Init(textContent, aFrame, nsnull);
   1: 
   1:       // Next rip out the kid and replace it with the text frame
   1:       ::DeletingFrameSubtree(aFrameManager, kid);
   1:       aFrameManager->RemoveFrame(aFrame, nsnull, kid);
   1: 
   1:       // Insert text frame in its place
   1:       aFrameManager->InsertFrames(aFrame, nsnull, prevSibling, textFrame);
   1: 
   1:       *aStopLooking = PR_TRUE;
   1:       break;
   1:     }
4696:     else if (IsInlineFrame(kid)) {
   1:       // Look inside child inline frame for the letter frame
   1:       RemoveFirstLetterFrames(aPresContext, aPresShell, aFrameManager, kid,
   1:                               aStopLooking);
   1:       if (*aStopLooking) {
   1:         break;
   1:       }
   1:     }
   1:     prevSibling = kid;
   1:     kid = kid->GetNextSibling();
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::RemoveLetterFrames(nsPresContext* aPresContext,
   1:                                           nsIPresShell* aPresShell,
   1:                                           nsFrameManager* aFrameManager,
   1:                                           nsIFrame* aBlockFrame)
   1: {
   1:   PRBool stopLooking = PR_FALSE;
   1:   nsresult rv = RemoveFloatingFirstLetterFrames(aPresContext, aPresShell,
   1:                                                 aFrameManager,
   1:                                                 aBlockFrame, &stopLooking);
   1:   if (NS_SUCCEEDED(rv) && !stopLooking) {
   1:     rv = RemoveFirstLetterFrames(aPresContext, aPresShell, aFrameManager,
   1:                                  aBlockFrame, &stopLooking);
   1:   }
   1:   return rv;
   1: }
   1: 
   1: // Fixup the letter frame situation for the given block
   1: nsresult
   1: nsCSSFrameConstructor::RecoverLetterFrames(nsFrameConstructorState& aState,
   1:                                            nsIFrame* aBlockFrame)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
 551:   aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_STYLE);
 551: 
   1:   nsIFrame* blockKids = aBlockFrame->GetFirstChild(nsnull);
   1:   nsIFrame* parentFrame = nsnull;
   1:   nsIFrame* textFrame = nsnull;
   1:   nsIFrame* prevFrame = nsnull;
   1:   nsFrameItems letterFrames;
   1:   PRBool stopLooking = PR_FALSE;
   1:   rv = WrapFramesInFirstLetterFrame(aState, aBlockFrame, aBlockFrame, blockKids,
   1:                                     &parentFrame, &textFrame, &prevFrame,
   1:                                     letterFrames, &stopLooking);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1:   if (parentFrame) {
   1:     // Take the old textFrame out of the parents child list
   1:     ::DeletingFrameSubtree(aState.mFrameManager, textFrame);
   1:     parentFrame->RemoveFrame(nsnull, textFrame);
   1: 
   1:     // Insert in the letter frame(s)
   1:     parentFrame->InsertFrames(nsnull, prevFrame, letterFrames.childList);
   1:   }
   1:   return rv;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: // listbox Widget Routines
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::CreateListBoxContent(nsPresContext* aPresContext,
   1:                                             nsIFrame*       aParentFrame,
   1:                                             nsIFrame*       aPrevFrame,
   1:                                             nsIContent*     aChild,
   1:                                             nsIFrame**      aNewFrame,
   1:                                             PRBool          aIsAppend,
   1:                                             PRBool          aIsScrollbar,
   1:                                             nsILayoutHistoryState* aFrameState)
   1: {
   1: #ifdef MOZ_XUL
   1:   nsresult rv = NS_OK;
   1: 
   1:   // Construct a new frame
   1:   if (nsnull != aParentFrame) {
   1:     nsFrameItems            frameItems;
   1:     nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
   1:                                   GetAbsoluteContainingBlock(aParentFrame),
   1:                                   GetFloatContainingBlock(aParentFrame), 
   1:                                   mTempFrameTreeState);
   1: 
   1:     nsRefPtr<nsStyleContext> styleContext;
   1:     styleContext = ResolveStyleContext(aParentFrame, aChild);
   1: 
   1:     // Pre-check for display "none" - only if we find that, do we create
   1:     // any frame at all
   1:     const nsStyleDisplay* display = styleContext->GetStyleDisplay();
   1: 
   1:     if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
   1:       *aNewFrame = nsnull;
   1:       return NS_OK;
   1:     }
   1: 
   1:     rv = ConstructFrameInternal(state, aChild,
   1:                                 aParentFrame, aChild->Tag(),
   1:                                 aChild->GetNameSpaceID(),
   1:                                 styleContext, frameItems, PR_FALSE);
 516:     if (!state.mPseudoFrames.IsEmpty()) {
 516:       ProcessPseudoFrames(state, frameItems); 
 516:     }
   1: 
   1:     nsIFrame* newFrame = frameItems.childList;
   1:     *aNewFrame = newFrame;
   1: 
   1:     if (NS_SUCCEEDED(rv) && (nsnull != newFrame)) {
   1:       // Notify the parent frame
   1:       if (aIsAppend)
   1:         rv = ((nsListBoxBodyFrame*)aParentFrame)->ListBoxAppendFrames(newFrame);
   1:       else
   1:         rv = ((nsListBoxBodyFrame*)aParentFrame)->ListBoxInsertFrames(aPrevFrame, newFrame);
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: #else
   1:   return NS_ERROR_FAILURE;
   1: #endif
   1: }
   1: 
   1: //----------------------------------------
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructBlock(nsFrameConstructorState& aState,
   1:                                       const nsStyleDisplay*    aDisplay,
   1:                                       nsIContent*              aContent,
   1:                                       nsIFrame*                aParentFrame,
   1:                                       nsIFrame*                aContentParentFrame,
   1:                                       nsStyleContext*          aStyleContext,
   1:                                       nsIFrame**               aNewFrame,
   1:                                       nsFrameItems&            aFrameItems,
   1:                                       PRBool                   aAbsPosContainer)
   1: {
   1:   // Create column wrapper if necessary
   1:   nsIFrame* blockFrame = *aNewFrame;
   1:   nsIFrame* parent = aParentFrame;
   1:   nsIFrame* contentParent = aContentParentFrame;
   1:   nsRefPtr<nsStyleContext> blockStyle = aStyleContext;
   1:   const nsStyleColumn* columns = aStyleContext->GetStyleColumn();
   1: 
   1:   if (columns->mColumnCount != NS_STYLE_COLUMN_COUNT_AUTO
   1:       || columns->mColumnWidth.GetUnit() != eStyleUnit_Auto) {
   1:     nsIFrame* columnSetFrame = nsnull;
   1:     columnSetFrame = NS_NewColumnSetFrame(mPresShell, aStyleContext, 0);
   1:     if (!columnSetFrame) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1: 
   1:     InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, columnSetFrame);
   1:     // See if we need to create a view, e.g. the frame is absolutely positioned
   1:     nsHTMLContainerFrame::CreateViewForFrame(columnSetFrame, aContentParentFrame,
   1:                                              PR_FALSE);
   1:     blockStyle = mPresShell->StyleSet()->
   1:       ResolvePseudoStyleFor(aContent, nsCSSAnonBoxes::columnContent,
   1:                             aStyleContext);
   1:     contentParent = columnSetFrame;
   1:     parent = columnSetFrame;
   1:     *aNewFrame = columnSetFrame;
   1: 
   1:     columnSetFrame->SetInitialChildList(nsnull, blockFrame);
   1:   }
   1: 
   1:   blockFrame->SetStyleContextWithoutNotification(blockStyle);
   1:   InitAndRestoreFrame(aState, aContent, parent, nsnull, blockFrame);
   1: 
   1:   nsresult rv = aState.AddChild(*aNewFrame, aFrameItems, aDisplay,
   1:                                 aContent, aStyleContext,
   1:                                 aContentParentFrame ? aContentParentFrame :
   1:                                                       aParentFrame);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   // See if we need to create a view, e.g. the frame is absolutely positioned
   1:   nsHTMLContainerFrame::CreateViewForFrame(blockFrame, contentParent, PR_FALSE);
   1: 
   1:   // We should make the outer frame be the absolute containing block,
   1:   // if one is required. We have to do this because absolute
   1:   // positioning must be computed with respect to the CSS dimensions
   1:   // of the element, which are the dimensions of the outer block. But
   1:   // we can't really do that because only blocks can have absolute
   1:   // children. So use the block and try to compensate with hacks
   1:   // in nsBlockFrame::CalculateContainingBlockSizeForAbsolutes.
   1:   nsFrameConstructorSaveState absoluteSaveState;
   1:   if (aAbsPosContainer) {
   1:     //    NS_ASSERTION(aRelPos, "should have made area frame for this");
   1:     aState.PushAbsoluteContainingBlock(blockFrame, absoluteSaveState);
   1:   }
   1: 
   1:   // See if the block has first-letter style applied to it...
   1:   PRBool haveFirstLetterStyle, haveFirstLineStyle;
1254:   ShouldHaveSpecialBlockStyle(aContent, aStyleContext,
   1:                               &haveFirstLetterStyle, &haveFirstLineStyle);
   1: 
   1:   // Process the child content
   1:   nsFrameItems childItems;
   1:   nsFrameConstructorSaveState floatSaveState;
   1:   aState.PushFloatContainingBlock(blockFrame, floatSaveState,
   1:                                   haveFirstLetterStyle,
   1:                                   haveFirstLineStyle);
   1:   rv = ProcessChildren(aState, aContent, blockFrame, PR_TRUE, childItems,
   1:                        PR_TRUE);
   1: 
   1:   CreateAnonymousFrames(aContent->Tag(), aState, aContent, blockFrame,
   1:                         PR_FALSE, childItems);
   1: 
   1:   // Set the frame's initial child list
   1:   blockFrame->SetInitialChildList(nsnull, childItems.childList);
   1: 
   1:   return rv;
   1: }
   1: 
   1: PRBool
   1: nsCSSFrameConstructor::AreAllKidsInline(nsIFrame* aFrameList)
   1: {
   1:   nsIFrame* kid = aFrameList;
   1:   while (kid) {
2829:     if (!IsInlineOutside(kid)) {
   1:       return PR_FALSE;
   1:     }
   1:     kid = kid->GetNextSibling();
   1:   }
   1:   return PR_TRUE;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ConstructInline(nsFrameConstructorState& aState,
   1:                                        const nsStyleDisplay*    aDisplay,
   1:                                        nsIContent*              aContent,
   1:                                        nsIFrame*                aParentFrame,
   1:                                        nsStyleContext*          aStyleContext,
   1:                                        PRBool                   aIsPositioned,
   1:                                        nsIFrame*                aNewFrame)
   1: {
   1:   // Initialize the frame
   1:   InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, aNewFrame);
   1: 
   1:   nsFrameConstructorSaveState absoluteSaveState;  // definition cannot be inside next block
   1:                                                   // because the object's destructor is significant
   1:                                                   // this is part of the fix for bug 42372
   1: 
   1:   // Any inline frame might need a view (because of opacity, or fixed background)
   1:   // XXXbz should we be passing in a non-null aContentParentFrame?
   1:   nsHTMLContainerFrame::CreateViewForFrame(aNewFrame, nsnull, PR_FALSE);
   1: 
   1:   if (aIsPositioned) {                            
   1:     // Relatively positioned frames becomes a container for child
   1:     // frames that are positioned
   1:     aState.PushAbsoluteContainingBlock(aNewFrame, absoluteSaveState);
   1:   }
   1: 
   1:   // Process the child content
   1:   nsFrameItems childItems;
   1:   PRBool kidsAllInline;
   1:   nsresult rv = ProcessInlineChildren(aState, aContent, aNewFrame, PR_TRUE,
   1:                                       childItems, &kidsAllInline);
   1:   if (kidsAllInline) {
   1:     // Set the inline frame's initial child list
   1:     CreateAnonymousFrames(aContent->Tag(), aState, aContent, aNewFrame,
   1:                           PR_FALSE, childItems);
   1: 
   1:     aNewFrame->SetInitialChildList(nsnull, childItems.childList);
   1:     return rv;
   1:   }
   1: 
   1:   // This inline frame contains several types of children. Therefore
   1:   // this frame has to be chopped into several pieces. We will produce
   1:   // as a result of this 3 lists of children. The first list contains
   1:   // all of the inline children that precede the first block child
   1:   // (and may be empty). The second list contains all of the block
   1:   // children and any inlines that are between them (and must not be
   1:   // empty, otherwise - why are we here?). The final list contains all
   1:   // of the inline children that follow the final block child.
   1: 
   1:   // Find the first block child which defines list1 and list2
   1:   nsIFrame* list1 = childItems.childList;
   1:   nsIFrame* prevToFirstBlock;
   1:   nsIFrame* list2 = FindFirstBlock(list1, &prevToFirstBlock);
   1:   if (prevToFirstBlock) {
   1:     prevToFirstBlock->SetNextSibling(nsnull);
   1:   }
   1:   else {
   1:     list1 = nsnull;
   1:   }
   1: 
   1:   // Find the last block child which defines the end of list2 and the
   1:   // start of list3
   1:   nsIFrame* afterFirstBlock = list2->GetNextSibling();
   1:   nsIFrame* list3 = nsnull;
   1:   nsIFrame* lastBlock = FindLastBlock(afterFirstBlock);
   1:   if (!lastBlock) {
   1:     lastBlock = list2;
   1:   }
   1:   list3 = lastBlock->GetNextSibling();
   1:   lastBlock->SetNextSibling(nsnull);
   1: 
   1:   // list1's frames belong to this inline frame so go ahead and take them
   1:   aNewFrame->SetInitialChildList(nsnull, list1);
   1:                                              
   1:   // list2's frames belong to an anonymous block that we create right
   1:   // now. The anonymous block will be the parent of the block children
   1:   // of the inline.
   1:   nsIAtom* blockStyle;
   1:   nsRefPtr<nsStyleContext> blockSC;
   1:   nsIFrame* blockFrame;
   1:   if (aIsPositioned) {
   1:     blockStyle = nsCSSAnonBoxes::mozAnonymousPositionedBlock;
   1:     
   1:     blockSC = mPresShell->StyleSet()->
   1:       ResolvePseudoStyleFor(aContent, blockStyle, aStyleContext);
   1:       
   1:     blockFrame = NS_NewRelativeItemWrapperFrame(mPresShell, blockSC);
   1:   }
   1:   else {
   1:     blockStyle = nsCSSAnonBoxes::mozAnonymousBlock;
   1: 
   1:     blockSC = mPresShell->StyleSet()->
   1:       ResolvePseudoStyleFor(aContent, blockStyle, aStyleContext);
   1: 
   1:     blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
   1:   }
   1: 
   1:   InitAndRestoreFrame(aState, aContent, aParentFrame, nsnull, blockFrame, PR_FALSE);  
   1: 
   1:   // Any inline frame could have a view (e.g., opacity)
   1:   // XXXbz should we be passing in a non-null aContentParentFrame?
   1:   nsHTMLContainerFrame::CreateViewForFrame(blockFrame, nsnull, PR_FALSE);
   1: 
   1:   if (blockFrame->HasView() || aNewFrame->HasView()) {
   1:     // Move list2's frames into the new view
   1:     nsHTMLContainerFrame::ReparentFrameViewList(aState.mPresContext, list2,
   1:                                                 list2->GetParent(), blockFrame);
   1:   }
   1: 
   1:   blockFrame->SetInitialChildList(nsnull, list2);
   1: 
   1:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
   1:                                 GetAbsoluteContainingBlock(blockFrame),
   1:                                 GetFloatContainingBlock(blockFrame));
   1: 
   1:   // If we have an inline between two blocks all inside an inline and the inner
   1:   // inline contains a float, the float will end up in the float list of the
   1:   // parent block of the inline, but its parent pointer will be the anonymous
   1:   // block we create...  AdjustFloatParentPtrs() deals with this by moving the
   1:   // float from the outer state |aState| to the inner |state|.
5585:   MoveChildrenTo(state.mFrameManager, blockFrame, list2, nsnull, &state,
5585:                  &aState);
   1: 
   1:   // list3's frames belong to another inline frame
   1:   nsIFrame* inlineFrame = nsnull;
   1: 
4696:   // If we ever start constructing a second inline in the split even when
4696:   // list3 is null, the logic in MaybeRecreateContainerForIBSplitterFrame
4696:   // needs to be adjusted.  Also, if you're changing this code also change
4696:   // AppendFrames().
   1:   if (list3) {
4696:     inlineFrame = MoveFramesToEndOfIBSplit(aState, nsnull,
4696:                                            aIsPositioned, aContent,
4696:                                            aStyleContext, list3,
4696:                                            blockFrame, nsnull);
4696:     
4696:   }
4696: 
4696:   // Mark the frames as special (note: marking for inlineFrame is handled by
4696:   // MoveFramesToEndOfIBSplit). That way if any of the append/insert/remove
4696:   // methods try to fiddle with the children, the containing block will be
4696:   // reframed instead.
   1:   SetFrameIsSpecial(aNewFrame, blockFrame);
   1:   SetFrameIsSpecial(blockFrame, inlineFrame);
5324:   MarkIBSpecialPrevSibling(blockFrame, aNewFrame);
   1: 
   1: #ifdef DEBUG
   1:   if (gNoisyInlineConstruction) {
   1:     nsIFrameDebug*  frameDebug;
   1: 
   1:     printf("nsCSSFrameConstructor::ConstructInline:\n");
   1:     if (NS_SUCCEEDED(CallQueryInterface(aNewFrame, &frameDebug))) {
   1:       printf("  ==> leading inline frame:\n");
   1:       frameDebug->List(stdout, 2);
   1:     }
   1:     if (NS_SUCCEEDED(CallQueryInterface(blockFrame, &frameDebug))) {
   1:       printf("  ==> block frame:\n");
   1:       frameDebug->List(stdout, 2);
   1:     }
   1:     if (inlineFrame &&
   1:         NS_SUCCEEDED(CallQueryInterface(inlineFrame, &frameDebug))) {
   1:       printf("  ==> trailing inline frame:\n");
   1:       frameDebug->List(stdout, 2);
   1:     }
   1:   }
   1: #endif
   1: 
   1:   return rv;
   1: }
   1: 
4696: nsIFrame*
4696: nsCSSFrameConstructor::MoveFramesToEndOfIBSplit(nsFrameConstructorState& aState,
4696:                                                 nsIFrame* aExistingEndFrame,
4696:                                                 PRBool aIsPositioned,
4696:                                                 nsIContent* aContent,
4696:                                                 nsStyleContext* aStyleContext,
4696:                                                 nsIFrame* aFramesToMove,
4696:                                                 nsIFrame* aBlockPart,
4696:                                                 nsFrameConstructorState* aTargetState)
4696: {
4696:   NS_PRECONDITION(aFramesToMove, "Must have frames to move");
4696:   NS_PRECONDITION(aBlockPart, "Must have a block part");
4696: 
4696:   nsIFrame* inlineFrame = aExistingEndFrame;
4696:   if (!inlineFrame) {
4696:     if (aIsPositioned) {
4696:       inlineFrame = NS_NewPositionedInlineFrame(mPresShell, aStyleContext);
4696:     }
4696:     else {
4696:       inlineFrame = NS_NewInlineFrame(mPresShell, aStyleContext);
4696:     }
4696: 
4696:     InitAndRestoreFrame(aState, aContent, aBlockPart->GetParent(), nsnull,
4696:                         inlineFrame, PR_FALSE);
4696: 
4696:     // Any frame might need a view
4696:     // XXXbz should we be passing in a non-null aContentParentFrame?
4696:     nsHTMLContainerFrame::CreateViewForFrame(inlineFrame, nsnull, PR_FALSE);
4696:   }
4696:   
4696:   if (inlineFrame->HasView() || aFramesToMove->GetParent()->HasView()) {
4696:     // Move list3's frames into the new view
4696:     nsHTMLContainerFrame::ReparentFrameViewList(aState.mPresContext,
4696:                                                 aFramesToMove,
4696:                                                 aFramesToMove->GetParent(),
4696:                                                 inlineFrame);
4696:   }
4696: 
4696:   // Reparent (cheaply) the frames in list3
5585:   nsIFrame* existingFirstChild = inlineFrame->GetFirstChild(nsnull);
5585:   if (!existingFirstChild &&
4696:       (inlineFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
4696:     inlineFrame->SetInitialChildList(nsnull, aFramesToMove);
4696:   } else {
4696:     inlineFrame->InsertFrames(nsnull, nsnull, aFramesToMove);
4696:   }
4696:   nsFrameConstructorState* startState = aTargetState ? &aState : nsnull;
4696:   MoveChildrenTo(aState.mFrameManager, inlineFrame, aFramesToMove,
5585:                  existingFirstChild, aTargetState, startState);
4696:   SetFrameIsSpecial(inlineFrame, nsnull);
4696:   return inlineFrame;
4696: }
4696:  
   1: nsresult
   1: nsCSSFrameConstructor::ProcessInlineChildren(nsFrameConstructorState& aState,
   1:                                              nsIContent*              aContent,
   1:                                              nsIFrame*                aFrame,
   1:                                              PRBool                   aCanHaveGeneratedContent,
   1:                                              nsFrameItems&            aFrameItems,
   1:                                              PRBool*                  aKidsAllInline)
   1: {
   1:   nsresult rv = NS_OK;
   1:   nsStyleContext* styleContext = nsnull;
   1: 
   1:   // save the pseudo frame state 
   1:   nsPseudoFrames prevPseudoFrames; 
   1:   aState.mPseudoFrames.Reset(&prevPseudoFrames);
   1: 
   1:   if (aCanHaveGeneratedContent) {
   1:     // Probe for generated content before
   1:     nsIFrame* generatedFrame;
   1:     styleContext = aFrame->GetStyleContext();
   1:     if (CreateGeneratedContentFrame(aState, aFrame, aContent,
   1:                                     styleContext, nsCSSPseudoElements::before,
   1:                                     &generatedFrame)) {
   1:       // Add the generated frame to the child list
   1:       aFrameItems.AddChild(generatedFrame);
   1:     }
   1:   }
   1: 
   1:   // Iterate the child content objects and construct frames
   1:   PRBool allKidsInline = PR_TRUE;
   1:   ChildIterator iter, last;
   1:   for (ChildIterator::Init(aContent, &iter, &last);
   1:        iter != last;
   1:        ++iter) {
   1:     // Construct a child frame
   1:     nsIFrame* oldLastChild = aFrameItems.lastChild;
   1:     rv = ConstructFrame(aState, nsCOMPtr<nsIContent>(*iter),
   1:                         aFrame, aFrameItems);
   1: 
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1: 
   1:     // Examine newly added children (we may have added more than one
   1:     // child if the child was another inline frame that ends up
   1:     // being carved in 3 pieces) to maintain the allKidsInline flag.
   1:     if (allKidsInline) {
   1:       nsIFrame* kid;
   1:       if (oldLastChild) {
   1:         kid = oldLastChild->GetNextSibling();
   1:       }
   1:       else {
   1:         kid = aFrameItems.childList;
   1:       }
   1:       while (kid) {
2829:         if (!IsInlineOutside(kid)) {
   1:           allKidsInline = PR_FALSE;
   1:           break;
   1:         }
   1:         kid = kid->GetNextSibling();
   1:       }
   1:     }
   1:   }
   1: 
   1:   if (aCanHaveGeneratedContent) {
   1:     // Probe for generated content after
   1:     nsIFrame* generatedFrame;
   1:     if (CreateGeneratedContentFrame(aState, aFrame, aContent,
   1:                                     styleContext, nsCSSPseudoElements::after,
   1:                                     &generatedFrame)) {
   1:       // Add the generated frame to the child list
   1:       aFrameItems.AddChild(generatedFrame);
   1:     }
   1:   }
   1: 
   1:   // process the current pseudo frame state
   1:   if (!aState.mPseudoFrames.IsEmpty()) {
   1:     ProcessPseudoFrames(aState, aFrameItems);
   1:     // recompute allKidsInline to take into account new child frames
   1:     // XXX we DON'T do this yet because anonymous table children should
   1:     // be accepted as inline children, until we turn on inline-table.
   1:     // See bug 297537.
   1:     // allKidsInline = AreAllKidsInline(aFrameItems.childList);
   1:   }
   1:   // restore the pseudo frame state
   1:   aState.mPseudoFrames = prevPseudoFrames;
   1: 
   1:   *aKidsAllInline = allKidsInline;
   1: 
   1:   return rv;
   1: }
   1: 
   1: PRBool
   1: nsCSSFrameConstructor::WipeContainingBlock(nsFrameConstructorState& aState,
   1:                                            nsIFrame* aContainingBlock,
   1:                                            nsIFrame* aFrame,
4696:                                            const nsFrameItems& aFrameList,
4696:                                            PRBool aIsAppend,
4696:                                            nsIFrame* aPrevSibling)
4696: {
4696:   if (!aFrameList.childList) {
4696:     return PR_FALSE;
4696:   }
4696:   
   1:   // Before we go and append the frames, check for a special
   1:   // situation: an inline frame that will now contain block
   1:   // frames. This is a no-no and the frame construction logic knows
4696:   // how to fix this.  See defition of IsInlineFrame() for what "an
4696:   // inline" is.  Whether we have "a block" is tested for by
4696:   // AreAllKidsInline.
4696: 
4696:   // We also need to check for an append of content ending in an
4696:   // inline to the block in an {ib} split or an insert of content
4696:   // starting with an inline to the start of that block.  If that
4696:   // happens, we also need to reframe, since that content needs to go
4696:   // into the following or preceding inline in the split.
4696: 
4696:   if (IsInlineFrame(aFrame)) {
4696:     // Nothing to do if all kids are inline
4696:     if (AreAllKidsInline(aFrameList.childList)) {
   1:       return PR_FALSE;
4696:     }
4696:   } else if (!IsFrameSpecial(aFrame)) {
4696:     return PR_FALSE;
4696:   } else {
4696:     // aFrame is the block in an {ib} split.  Check that we're not
4696:     // messing up either end of it.
4696:     if (aIsAppend) {
5324:       // Will be handled in AppendFrames(), unless we have floats that we can't
5324:       // move out because there might be no float containing block to move them
5324:       // into.
5324:       if (!aState.mFloatedItems.childList) {
4696:         return PR_FALSE;
4696:       }
4696: 
5324:       // Walk up until we get a float containing block that's not part of an
5324:       // {ib} split, since otherwise we might have to ship floats out of it
5324:       // too.
5324:       nsIFrame* floatContainer = aFrame;
5324:       do {
5324:         floatContainer =
5324:           GetFloatContainingBlock(GetIBSplitSpecialPrevSibling(floatContainer));
5324:         if (!floatContainer) {
5324:           break;
5324:         }
5324:         if (!IsFrameSpecial(floatContainer)) {
5324:           return PR_FALSE;
5324:         }
5324:       } while (1);
5324:     }
5324:     
4696:     if (aPrevSibling && !aPrevSibling->GetNextSibling()) {
4696:       // This is an append that won't go through AppendFrames.  We can bail out
4696:       // if the last frame we're appending is not inline
4696:       if (!aFrameList.lastChild->GetStyleDisplay()->IsInlineOutside()) {
4696:         return PR_FALSE;
4696:       }
4696:     } else {
4696:       // We can bail out if we're not inserting at the beginning or if
4696:       // the first frame we're inserting is not inline.
4696:       if (aPrevSibling ||
4696:           !aFrameList.childList->GetStyleDisplay()->IsInlineOutside()) {
4696:         return PR_FALSE;
4696:       }
4696:     }
4696:   }
   1: 
   1:   // Ok, reverse tracks: wipe out the frames we just created
   1:   nsFrameManager *frameManager = aState.mFrameManager;
   1: 
   1:   // Destroy the frames. As we do make sure any content to frame mappings
   1:   // or entries in the undisplayed content map are removed
   1:   frameManager->ClearAllUndisplayedContentIn(aFrame->GetContent());
   1: 
4696:   CleanupFrameReferences(frameManager, aFrameList.childList);
   1:   if (aState.mAbsoluteItems.childList) {
   1:     CleanupFrameReferences(frameManager, aState.mAbsoluteItems.childList);
   1:   }
   1:   if (aState.mFixedItems.childList) {
   1:     CleanupFrameReferences(frameManager, aState.mFixedItems.childList);
   1:   }
   1:   if (aState.mFloatedItems.childList) {
   1:     CleanupFrameReferences(frameManager, aState.mFloatedItems.childList);
   1:   }
   1: #ifdef MOZ_XUL
   1:   if (aState.mPopupItems.childList) {
   1:     CleanupFrameReferences(frameManager, aState.mPopupItems.childList);
   1:   }
   1: #endif
4696:   nsFrameList tmp(aFrameList.childList);
   1:   tmp.DestroyFrames();
   1: 
   1:   tmp.SetFrames(aState.mAbsoluteItems.childList);
   1:   tmp.DestroyFrames();
   1:   aState.mAbsoluteItems.childList = nsnull;
   1: 
   1:   tmp.SetFrames(aState.mFixedItems.childList);
   1:   tmp.DestroyFrames();
   1:   aState.mFixedItems.childList = nsnull;
   1: 
   1:   tmp.SetFrames(aState.mFloatedItems.childList);
   1:   tmp.DestroyFrames();
   1:   aState.mFloatedItems.childList = nsnull;
   1: 
   1: #ifdef MOZ_XUL
   1:   tmp.SetFrames(aState.mPopupItems.childList);
   1:   tmp.DestroyFrames();
   1:   aState.mPopupItems.childList = nsnull;
   1: #endif
   1: 
   1:   // If we don't have a containing block, start with aFrame and look for one.
   1:   if (!aContainingBlock) {
   1:     aContainingBlock = aFrame;
   1:   }
   1:   
   1:   // To find the right block to reframe, just walk up the tree until we find a
   1:   // frame that is:
   1:   // 1)  Not part of an IB split (not special)
   1:   // 2)  Not a pseudo-frame
   1:   // 3)  Not an inline frame
   1:   // We're guaranteed to find one, since nsStyleContext::ApplyStyleFixups
   1:   // enforces that the root is display:none, display:table, or display:block.
   1:   // Note that walking up "too far" is OK in terms of correctness, even if it
   1:   // might be a little inefficient.  This is why we walk out of all
   1:   // pseudo-frames -- telling which ones are or are not OK to walk out of is
   1:   // too hard (and I suspect that we do in fact need to walk out of all of
   1:   // them).
2829:   while (IsFrameSpecial(aContainingBlock) || IsInlineOutside(aContainingBlock) ||
   1:          aContainingBlock->GetStyleContext()->GetPseudoType()) {
   1:     aContainingBlock = aContainingBlock->GetParent();
   1:     NS_ASSERTION(aContainingBlock,
   1:                  "Must have non-inline, non-special, non-pseudo frame as root "
   1:                  "(or child of root, for a table root)!");
   1:   }
   1: 
   1:   // Tell parent of the containing block to reformulate the
   1:   // entire block. This is painful and definitely not optimal
   1:   // but it will *always* get the right answer.
   1: 
   1:   nsIContent *blockContent = aContainingBlock->GetContent();
   1:   nsCOMPtr<nsIContent> parentContainer = blockContent->GetParent();
   1: #ifdef DEBUG
   1:   if (gNoisyContentUpdates) {
   1:     printf("nsCSSFrameConstructor::WipeContainingBlock: blockContent=%p parentContainer=%p\n",
3233:            static_cast<void*>(blockContent),
3233:            static_cast<void*>(parentContainer));
   1:   }
   1: #endif
   1:   if (parentContainer) {
   1:     ReinsertContent(parentContainer, blockContent);
   1:   }
   1:   else if (blockContent->GetCurrentDoc() == mDocument) {
   1:     ReconstructDocElementHierarchyInternal();
   1:   }
   1:   return PR_TRUE;
   1: }
   1: 
   1: nsresult
   1: nsCSSFrameConstructor::ReframeContainingBlock(nsIFrame* aFrame)
   1: {
   1: 
   1: #ifdef DEBUG
   1:   // ReframeContainingBlock is a NASTY routine, it causes terrible performance problems
   1:   // so I want to see when it is happening!  Unfortunately, it is happening way to often because
   1:   // so much content on the web causes 'special' block-in-inline frame situations and we handle them
   1:   // very poorly
   1:   if (gNoisyContentUpdates) {
   1:     printf("nsCSSFrameConstructor::ReframeContainingBlock frame=%p\n",
3233:            static_cast<void*>(aFrame));
   1:   }
   1: #endif
   1: 
   1:   PRBool isReflowing;
   1:   mPresShell->IsReflowLocked(&isReflowing);
   1:   if(isReflowing) {
   1:     // don't ReframeContainingBlock, this will result in a crash
   1:     // if we remove a tree that's in reflow - see bug 121368 for testcase
   1:     NS_ASSERTION(0, "Atemptted to nsCSSFrameConstructor::ReframeContainingBlock during a Reflow!!!");
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Get the first "normal" ancestor of the target frame.
   1:   nsIFrame* containingBlock = GetIBContainingBlockFor(aFrame);
   1:   if (containingBlock) {
   1:     // From here we look for the containing block in case the target
   1:     // frame is already a block (which can happen when an inline frame
   1:     // wraps some of its content in an anonymous block; see
   1:     // ConstructInline)
   1:    
   1:     // NOTE: We used to get the FloatContainingBlock here, but it was often wrong.
   1:     // GetIBContainingBlock works much better and provides the correct container in all cases
   1:     // so GetFloatContainingBlock(aFrame) has been removed
   1: 
   1:     // And get the containingBlock's content
   1:     nsCOMPtr<nsIContent> blockContent = containingBlock->GetContent();
   1:     if (blockContent) {
   1:       // Now find the containingBlock's content's parent
   1:       nsCOMPtr<nsIContent> parentContainer = blockContent->GetParent();
   1:       if (parentContainer) {
   1: #ifdef DEBUG
   1:         if (gNoisyContentUpdates) {
   1:           printf("  ==> blockContent=%p, parentContainer=%p\n",
3233:                  static_cast<void*>(blockContent),
3233:                  static_cast<void*>(parentContainer));
   1:         }
   1: #endif
   1:         return ReinsertContent(parentContainer, blockContent);
   1:       }
   1:     }
   1:   }
   1: 
   1:   // If we get here, we're screwed!
   1:   return ReconstructDocElementHierarchyInternal();
   1: }
   1: 
   1: nsresult nsCSSFrameConstructor::RemoveFixedItems(const nsFrameConstructorState& aState)
   1: {
   1:   nsresult rv=NS_OK;
   1: 
   1:   if (mFixedContainingBlock) {
   1:     nsIFrame *fixedChild = nsnull;
   1:     do {
   1:       fixedChild = mFixedContainingBlock->GetFirstChild(nsGkAtoms::fixedList);
   1:       if (fixedChild) {
   1:         // Remove the placeholder so it doesn't end up sitting about pointing
   1:         // to the removed fixed frame.
4162:         nsPlaceholderFrame *placeholderFrame =
4162:           aState.mFrameManager->GetPlaceholderFrameFor(fixedChild);
   1:         NS_ASSERTION(placeholderFrame, "no placeholder for fixed-pos frame");
   1:         NS_ASSERTION(placeholderFrame->GetType() ==
   1:                      nsGkAtoms::placeholderFrame,
   1:                      "Wrong type");
4162:         UnregisterPlaceholderChain(aState.mFrameManager, placeholderFrame);
   1:         nsIFrame* placeholderParent = placeholderFrame->GetParent();
   1:         ::DeletingFrameSubtree(aState.mFrameManager, placeholderFrame);
   1:         rv = aState.mFrameManager->RemoveFrame(placeholderParent, nsnull,
   1:                                                placeholderFrame);
   1:         if (NS_FAILED(rv)) {
   1:           NS_WARNING("Error removing placeholder for fixed frame in RemoveFixedItems");
   1:           break;
   1:         }
   1: 
   1:         ::DeletingFrameSubtree(aState.mFrameManager, fixedChild);
   1:         rv = aState.mFrameManager->RemoveFrame(mFixedContainingBlock,
   1:                                                nsGkAtoms::fixedList,
   1:                                                fixedChild);
   1:         if (NS_FAILED(rv)) {
   1:           NS_WARNING("Error removing frame from fixed containing block in RemoveFixedItems");
   1:           break;
   1:         }
   1:       }
   1:     } while(fixedChild);
   1:   } else {
   1:     NS_WARNING( "RemoveFixedItems called with no FixedContainingBlock data member set");
   1:   }
   1:   return rv;
   1: }
   1: 
   1: PR_STATIC_CALLBACK(PLDHashOperator)
   1: CollectRestyles(nsISupports* aContent,
   1:                 nsCSSFrameConstructor::RestyleData& aData,
   1:                 void* aRestyleArrayPtr)
   1: {
   1:   nsCSSFrameConstructor::RestyleEnumerateData** restyleArrayPtr =
3233:     static_cast<nsCSSFrameConstructor::RestyleEnumerateData**>
3233:                (aRestyleArrayPtr);
   1:   nsCSSFrameConstructor::RestyleEnumerateData* currentRestyle =
   1:     *restyleArrayPtr;
3233:   currentRestyle->mContent = static_cast<nsIContent*>(aContent);
   1:   currentRestyle->mRestyleHint = aData.mRestyleHint;
   1:   currentRestyle->mChangeHint = aData.mChangeHint;
   1: 
   1:   // Increment to the next slot in the array
   1:   *restyleArrayPtr = currentRestyle + 1; 
   1: 
   1:   return PL_DHASH_NEXT;
   1: }
   1: 
   1: void
   1: nsCSSFrameConstructor::ProcessOneRestyle(nsIContent* aContent,
   1:                                          nsReStyleHint aRestyleHint,
   1:                                          nsChangeHint aChangeHint)
   1: {
   1:   NS_PRECONDITION(aContent, "Must have content node");
   1:   
   1:   if (!aContent->IsInDoc() ||
   1:       aContent->GetCurrentDoc() != mDocument) {
   1:     // Content node has been removed from our document; nothing else
   1:     // to do here
   1:     return;
   1:   }
   1:   
   1:   nsIFrame* primaryFrame = mPresShell->GetPrimaryFrameFor(aContent);
   1:   if (aRestyleHint & eReStyle_Self) {
   1:     RestyleElement(aContent, primaryFrame, aChangeHint);
   1:   } else if (aChangeHint &&
   1:                (primaryFrame ||
   1:                 (aChangeHint & nsChangeHint_ReconstructFrame))) {
   1:     // Don't need to recompute style; just apply the hint
   1:     nsStyleChangeList changeList;
   1:     changeList.AppendChange(primaryFrame, aContent, aChangeHint);
   1:     ProcessRestyledFrames(changeList);
   1:   }
   1: 
   1:   if (aRestyleHint & eReStyle_LaterSiblings) {
   1:     RestyleLaterSiblings(aContent);
   1:   }
   1: }
   1: 
   1: void
   1: nsCSSFrameConstructor::ProcessPendingRestyles()
   1: {
   1:   PRUint32 count = mPendingRestyles.Count();
   1:   if (!count) {
   1:     // Nothing to do
   1:     return;
   1:   }
   1:   
   1:   NS_PRECONDITION(mDocument, "No document?  Pshaw!\n");
   1: 
   1:   nsCSSFrameConstructor::RestyleEnumerateData* restylesToProcess =
   1:     new nsCSSFrameConstructor::RestyleEnumerateData[count];
   1:   if (!restylesToProcess) {
   1:     return;
   1:   }
   1: 
   1:   nsCSSFrameConstructor::RestyleEnumerateData* lastRestyle = restylesToProcess;
   1:   mPendingRestyles.Enumerate(CollectRestyles, &lastRestyle);
   1: 
   1:   NS_ASSERTION(lastRestyle - restylesToProcess ==
   1:                PRInt32(count),
   1:                "Enumeration screwed up somehow");
   1: 
   1:   // Clear the hashtable so we don't end up trying to process a restyle we're
   1:   // already processing, sending us into an infinite loop.
   1:   mPendingRestyles.Clear();
   1: 
   1:   // Make sure to not rebuild quote or counter lists while we're
   1:   // processing restyles
   1:   BeginUpdate();
   1: 
   1:   for (nsCSSFrameConstructor::RestyleEnumerateData* currentRestyle =
   1:          restylesToProcess;
   1:        currentRestyle != lastRestyle;
   1:        ++currentRestyle) {
   1:     ProcessOneRestyle(currentRestyle->mContent,
   1:                       currentRestyle->mRestyleHint,
   1:                       currentRestyle->mChangeHint);
   1:   }
   1: 
   1:   delete [] restylesToProcess;
   1: 
   1:   EndUpdate();
   1: 
   1: #ifdef DEBUG
   1:   mPresShell->VerifyStyleTree();
   1: #endif
   1: }
   1: 
   1: void
   1: nsCSSFrameConstructor::PostRestyleEvent(nsIContent* aContent,
   1:                                         nsReStyleHint aRestyleHint,
   1:                                         nsChangeHint aMinChangeHint)
   1: {
   1:   if (aRestyleHint == 0 && !aMinChangeHint) {
   1:     // Nothing to do here
   1:     return;
   1:   }
   1: 
   1:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eELEMENT),
   1:                "Shouldn't be trying to restyle non-elements directly");
   1: 
   1:   RestyleData existingData;
   1:   existingData.mRestyleHint = nsReStyleHint(0);
   1:   existingData.mChangeHint = NS_STYLE_HINT_NONE;
   1: 
   1:   mPendingRestyles.Get(aContent, &existingData);
   1:   existingData.mRestyleHint =
   1:     nsReStyleHint(existingData.mRestyleHint | aRestyleHint);
   1:   NS_UpdateHint(existingData.mChangeHint, aMinChangeHint);
   1: 
   1:   mPendingRestyles.Put(aContent, existingData);
   1:     
   1:   if (!mRestyleEvent.IsPending()) {
   1:     nsRefPtr<RestyleEvent> ev = new RestyleEvent(this);
   1:     if (NS_FAILED(NS_DispatchToCurrentThread(ev))) {
   1:       NS_WARNING("failed to dispatch restyle event");
   1:       // XXXbz and what?
   1:     } else {
   1:       mRestyleEvent = ev;
   1:     }
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP nsCSSFrameConstructor::RestyleEvent::Run() {
   1:   if (!mConstructor)
   1:     return NS_OK;  // event was revoked
   1: 
5872:   nsCOMPtr<nsIViewManager> viewManager =
   1:     mConstructor->mPresShell->GetViewManager();
   1:   NS_ASSERTION(viewManager, "Must have view manager for update");
   1: 
   1:   viewManager->BeginUpdateViewBatch();
   1:   // Force flushing of any pending content notifications that might have queued
   1:   // up while our event was pending.  That will ensure that we don't construct
   1:   // frames for content right now that's still waiting to be notified on,
   1:   mConstructor->mPresShell->GetDocument()->
   1:     FlushPendingNotifications(Flush_ContentAndNotify);
   1: 
   1:   // Make sure that any restyles that happen from now on will go into
   1:   // a new event.
   1:   mConstructor->mRestyleEvent.Forget();
   1: 
   1:   mConstructor->ProcessPendingRestyles();
5872:   mConstructor->mDocument->BindingManager()->ProcessAttachedQueue();
   1:   viewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
   1: 
   1:   return NS_OK;
   1: }
   1: 
3129: NS_IMETHODIMP
3129: nsCSSFrameConstructor::LazyGenerateChildrenEvent::Run()
3129: {
3129:   mPresShell->GetDocument()->FlushPendingNotifications(Flush_Layout);
3129: 
3129:   // this is hard-coded to handle only menu popup frames
3129:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(mContent);
3129:   if (frame && frame->GetType() == nsGkAtoms::menuPopupFrame) {
3799: #ifdef MOZ_XUL
3129:     // it is possible that the frame is different than the one that requested
3129:     // the lazy generation, but as long as it's a popup frame that hasn't
3129:     // generated its children yet, that's OK.
3233:     nsMenuPopupFrame* menuPopupFrame = static_cast<nsMenuPopupFrame *>(frame);
3129:     if (menuPopupFrame->HasGeneratedChildren())
3129:       return NS_OK;
3129: 
3129:     // indicate that the children have been generated
3129:     menuPopupFrame->SetGeneratedChildren();
3799: #endif
3129: 
3129:     nsFrameItems childItems;
3129:     nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull);
3129:     nsCSSFrameConstructor* fc = mPresShell->FrameConstructor();
3129:     nsresult rv = fc->ProcessChildren(state, mContent, frame, PR_FALSE,
3129:                                       childItems, PR_FALSE);
3129:     if (NS_FAILED(rv))
3129:       return rv;
3129: 
3129:     fc->CreateAnonymousFrames(mContent->Tag(), state, mContent, frame,
3129:                               PR_FALSE, childItems);
3129:     frame->SetInitialChildList(nsnull, childItems.childList);
3129: 
3129:     if (mCallback)
3129:       mCallback(mContent, frame, mArg);
3129: 
3129:     // call XBL constructors after the frames are created
3129:     mPresShell->GetDocument()->BindingManager()->ProcessAttachedQueue();
3129:   }
3129: 
3129:   return NS_OK;
3129: }
