    1: /* -*- Mode: objc; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License
    1:  * Version 1.1 (the "License"); you may not use this file except in
    1:  * compliance with the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is 
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Josh Aas <josh@mozilla.com>
    1:  *   Mark Mentovai <mark@moxienet.com>
    1:  *   HÃ¥kan Waara <hwaara@gmail.com>
    1:  *   Stuart Morgan <stuart.morgan@alumni.case.edu>
54312:  *   Mats Palmgren <matspal@gmail.com>
22821:  *   Thomas K. Dyas <tdyas@zecador.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or 
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
46321: #ifdef MOZ_LOGGING
46321: #define FORCE_PR_LOG
46321: #endif
46321: #include "prlog.h"
46321: 
    1: #include <unistd.h>
    1:  
    1: #include "nsChildView.h"
 3574: #include "nsCocoaWindow.h"
    1: 
11978: #include "nsObjCExceptions.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsToolkit.h"
    1: #include "nsCRT.h"
12394: #include "nsIPrefService.h"
12394: #include "nsIPrefBranch.h"
    1: 
    1: #include "nsIFontMetrics.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIRegion.h"
    1: #include "nsIRollupListener.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIServiceManager.h"
 3545: #include "nsILocalFile.h"
 3545: #include "nsILocalFileMac.h"
    1: #include "nsGfxCIID.h"
 8345: #include "nsIMenuRollup.h"
29316: #include "nsIDOMSimpleGestureEvent.h"
29840: #include "nsIPluginInstance.h"
60289: #include "nsThemeConstants.h"
    1: 
    1: #include "nsDragService.h"
26757: #include "nsClipboard.h"
    1: #include "nsCursorManager.h"
    1: #include "nsWindowMap.h"
    1: #include "nsCocoaUtils.h"
21081: #include "nsMenuUtilsX.h"
10884: #include "nsMenuBarX.h"
43436: #ifdef __LP64__
43436: #include "ComplexTextInputPanel.h"
43436: #endif
    1: 
    1: #include "gfxContext.h"
    1: #include "gfxQuartzSurface.h"
34711: #include "nsRegion.h"
41434: #include "Layers.h"
41434: #include "LayerManagerOGL.h"
62870: #include "GLContext.h"
    1: 
15067: #include <dlfcn.h>
15067: 
27993: #include <ApplicationServices/ApplicationServices.h>
27993: 
41434: using namespace mozilla::layers;
62870: using namespace mozilla::gl;
    1: #undef DEBUG_IME
    1: #undef DEBUG_UPDATE
    1: #undef INVALIDATE_DEBUGGING  // flash areas as they are invalidated
    1: 
25019: // Don't put more than this many rects in the dirty region, just fluff
25019: // out to the bounding-box if there are more
25019: #define MAX_RECTS_IN_REGION 100
25019: 
 3545: #ifdef PR_LOGGING
 3545: PRLogModuleInfo* sCocoaLog = nsnull;
 3545: #endif
 3545: 
    1: extern "C" {
    1:   CG_EXTERN void CGContextResetCTM(CGContextRef);
    1:   CG_EXTERN void CGContextSetCTM(CGContextRef, CGAffineTransform);
    1:   CG_EXTERN void CGContextResetClip(CGContextRef);
36745: 
36745:   // CGSPrivate.h
36745:   typedef NSInteger CGSConnection;
36745:   typedef NSInteger CGSWindow;
36745:   extern CGSConnection _CGSDefaultConnection();
36745:   extern CGError CGSGetScreenRectForWindow(const CGSConnection cid, CGSWindow wid, CGRect *outRect);
36745:   extern CGError CGSGetWindowLevel(const CGSConnection cid, CGSWindow wid, CGWindowLevel *level);
55856:   extern CGError CGSGetWindowAlpha(const CGSConnection cid, const CGSWindow wid, float* alpha);
    1: }
    1: 
50708: // defined in nsMenuBarX.mm
50708: extern NSMenu* sApplicationMenu; // Application menu shared by all menubars
50708: 
33316: // these are defined in nsCocoaWindow.mm
33316: extern PRBool gConsumeRollupEvent;
33316: 
33316: PRBool gChildViewMethodsSwizzled = PR_FALSE;
33316: 
33316: extern nsISupportsArray *gDraggedTransferables;
33316: 
32976: ChildView* ChildViewMouseTracker::sLastMouseEventView = nil;
  539: 
    1: static NS_DEFINE_CID(kRegionCID, NS_REGION_CID);
    1: #ifdef INVALIDATE_DEBUGGING
    1: static void blinkRect(Rect* r);
    1: static void blinkRgn(RgnHandle rgn);
    1: #endif
    1: 
    1: nsIRollupListener * gRollupListener = nsnull;
36806: nsIMenuRollup     * gMenuRollup = nsnull;
    1: nsIWidget         * gRollupWidget   = nsnull;
    1: 
22847: PRUint32 gLastModifierState = 0;
22847: 
25064: PRBool gUserCancelledDrag = PR_FALSE;
    1: 
27993: PRUint32 nsChildView::sLastInputEventCount = 0;
27993: 
    1: @interface ChildView(Private)
    1: 
    1: // sets up our view, attaching it to its owning gecko view
 6754: - (id)initWithFrame:(NSRect)inFrame geckoChild:(nsChildView*)inChild;
61878: - (void)forceRefreshOpenGL;
    1: 
    1: // sends gecko an ime composition event
40645: - (void) sendCompositionEvent:(PRInt32)aEventType;
    1: 
    1: // sends gecko an ime text event
    1: - (void) sendTextEvent:(PRUnichar*) aBuffer 
    1:                        attributedString:(NSAttributedString*) aString
    1:                        selectedRange:(NSRange)selRange
    1:                        markedRange:(NSRange)markRange
    1:                        doCommit:(BOOL)doCommit;
    1: 
 2315: // do generic gecko event setup with a generic cocoa event. accepts nil inEvent.
 2315: - (void) convertGenericCocoaEvent:(NSEvent*)inEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent;
 2315: 
 2315: // set up a gecko mouse event based on a cocoa mouse event
 2315: - (void) convertCocoaMouseEvent:(NSEvent*)aMouseEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent;
 2315: 
 2315: // set up a gecko key event based on a cocoa key event
 2315: - (void) convertCocoaKeyEvent:(NSEvent*)aKeyEvent toGeckoEvent:(nsKeyEvent*)outGeckoEvent;
    1: 
    1: - (NSMenu*)contextMenu;
    1: 
    1: - (void)setIsPluginView:(BOOL)aIsPlugin;
  130: - (BOOL)isPluginView;
32120: - (void)setPluginEventModel:(NPEventModel)eventModel;
54248: - (void)setPluginDrawingModel:(NPDrawingModel)drawingModel;
32120: - (NPEventModel)pluginEventModel;
54248: - (NPDrawingModel)pluginDrawingModel;
    1: 
61078: #ifndef NP_NO_CARBON
61078: - (void)setPluginTSMInComposition:(BOOL)inComposition;
61078: #endif
61078: 
    1: - (BOOL)isRectObscuredBySubview:(NSRect)inRect;
    1: 
    1: - (void)processPendingRedraws;
    1: 
 3574: - (void)maybeInitContextMenuTracking;
 3574: 
14962: + (NSEvent*)makeNewCocoaEventWithType:(NSEventType)type fromEvent:(NSEvent*)theEvent;
14962: 
55858: - (void)drawRect:(NSRect)aRect inContext:(CGContextRef)aContext;
55858: 
61287: // Called using performSelector:withObject:afterDelay:0 to release
61287: // aWidgetArray (and its contents) the next time through the run loop.
61287: - (void)releaseWidgets:(NSArray*)aWidgetArray;
61287: 
    1: #if USE_CLICK_HOLD_CONTEXTMENU
    1:  // called on a timer two seconds after a mouse down to see if we should display
    1:  // a context menu (click-hold)
    1: - (void)clickHoldCallback:(id)inEvent;
    1: #endif
    1: 
    1: #ifdef ACCESSIBILITY
    1: - (id<mozAccessible>)accessible;
    1: #endif
    1: 
20387: - (BOOL)isFirstResponder;
20387: 
39094: - (BOOL)isDragInProgress;
39094: 
20387: - (void)fireKeyEventForFlagsChanged:(NSEvent*)theEvent keyDown:(BOOL)isKeyDown;
20387: 
47792: - (BOOL)inactiveWindowAcceptsMouseEvent:(NSEvent*)aEvent;
47792: 
    1: @end
    1: 
    1: #pragma mark -
    1: 
20528: // Key code constants
20528: enum
20528: {
20528:   kEscapeKeyCode      = 0x35,
20528:   kRCommandKeyCode    = 0x36, // right command key
20528:   kCommandKeyCode     = 0x37,
20528:   kShiftKeyCode       = 0x38,
20528:   kCapsLockKeyCode    = 0x39,
20528:   kOptionkeyCode      = 0x3A,
20528:   kControlKeyCode     = 0x3B,
20528:   kRShiftKeyCode      = 0x3C, // right shift key
20528:   kROptionKeyCode     = 0x3D, // right option key
20528:   kRControlKeyCode    = 0x3E, // right control key
20528:   kClearKeyCode       = 0x47,
20528: 
20528:   // function keys
20528:   kF1KeyCode          = 0x7A,
20528:   kF2KeyCode          = 0x78,
20528:   kF3KeyCode          = 0x63,
20528:   kF4KeyCode          = 0x76,
20528:   kF5KeyCode          = 0x60,
20528:   kF6KeyCode          = 0x61,
20528:   kF7KeyCode          = 0x62,
20528:   kF8KeyCode          = 0x64,
20528:   kF9KeyCode          = 0x65,
20528:   kF10KeyCode         = 0x6D,
20528:   kF11KeyCode         = 0x67,
20528:   kF12KeyCode         = 0x6F,
20528:   kF13KeyCode         = 0x69,
20528:   kF14KeyCode         = 0x6B,
20528:   kF15KeyCode         = 0x71,
20528:   
20528:   kPrintScreenKeyCode = kF13KeyCode,
20528:   kScrollLockKeyCode  = kF14KeyCode,
20528:   kPauseKeyCode       = kF15KeyCode,
20528:   
20528:   // keypad
20528:   kKeypad0KeyCode     = 0x52,
20528:   kKeypad1KeyCode     = 0x53,
20528:   kKeypad2KeyCode     = 0x54,
20528:   kKeypad3KeyCode     = 0x55,
20528:   kKeypad4KeyCode     = 0x56,
20528:   kKeypad5KeyCode     = 0x57,
20528:   kKeypad6KeyCode     = 0x58,
20528:   kKeypad7KeyCode     = 0x59,
20528:   kKeypad8KeyCode     = 0x5B,
20528:   kKeypad9KeyCode     = 0x5C,
20528: 
20528:   kKeypadMultiplyKeyCode  = 0x43,
20528:   kKeypadAddKeyCode       = 0x45,
20528:   kKeypadSubtractKeyCode  = 0x4E,
20528:   kKeypadDecimalKeyCode   = 0x41,
20528:   kKeypadDivideKeyCode    = 0x4B,
20528:   kKeypadEqualsKeyCode    = 0x51, // no correpsonding gecko key code
20528:   kEnterKeyCode           = 0x4C,
20528:   kReturnKeyCode          = 0x24,
20528:   kPowerbookEnterKeyCode  = 0x34, // Enter on Powerbook's keyboard is different
20528:   
20528:   kInsertKeyCode          = 0x72, // also help key
20528:   kDeleteKeyCode          = 0x75, // also forward delete key
20528:   kTabKeyCode             = 0x30,
20528:   kTildeKeyCode           = 0x32,
20528:   kBackspaceKeyCode       = 0x33,
20528:   kHomeKeyCode            = 0x73, 
20528:   kEndKeyCode             = 0x77,
20528:   kPageUpKeyCode          = 0x74,
20528:   kPageDownKeyCode        = 0x79,
20528:   kLeftArrowKeyCode       = 0x7B,
20528:   kRightArrowKeyCode      = 0x7C,
20528:   kUpArrowKeyCode         = 0x7E,
20528:   kDownArrowKeyCode       = 0x7D
20528: };
20528: 
    1: /* Convenience routines to go from a gecko rect to cocoa NSRects and back
    1:  *
    1:  * Gecko rects (nsRect) contain an origin (x,y) in a coordinate
    1:  * system with (0,0) in the top-left of the screen. Cocoa rects
    1:  * (NSRect) contain an origin (x,y) in a coordinate system with
    1:  * (0,0) in the bottom-left of the screen. Both nsRect and NSRect
    1:  * contain width/height info, with no difference in their use.
    1:  * If a Cocoa rect is from a flipped view, there is no need to
    1:  * convert coordinate systems.
    1:  */
    1: 
    1: static inline void
23738: GeckoRectToNSRect(const nsIntRect & inGeckoRect, NSRect & outCocoaRect)
    1: {
    1:   outCocoaRect.origin.x = inGeckoRect.x;
    1:   outCocoaRect.origin.y = inGeckoRect.y;
    1:   outCocoaRect.size.width = inGeckoRect.width;
    1:   outCocoaRect.size.height = inGeckoRect.height;
    1: }
    1: 
    1: static inline void
23738: NSRectToGeckoRect(const NSRect & inCocoaRect, nsIntRect & outGeckoRect)
23738: {
23738:   outGeckoRect.x = NSToIntRound(inCocoaRect.origin.x);
23738:   outGeckoRect.y = NSToIntRound(inCocoaRect.origin.y);
23738:   outGeckoRect.width = NSToIntRound(inCocoaRect.origin.x + inCocoaRect.size.width) - outGeckoRect.x;
23738:   outGeckoRect.height = NSToIntRound(inCocoaRect.origin.y + inCocoaRect.size.height) - outGeckoRect.y;
23738: }
    1: 
    1: static inline void 
23738: ConvertGeckoRectToMacRect(const nsIntRect& aRect, Rect& outMacRect)
    1: {
    1:   outMacRect.left = aRect.x;
    1:   outMacRect.top = aRect.y;
    1:   outMacRect.right = aRect.x + aRect.width;
    1:   outMacRect.bottom = aRect.y + aRect.height;
    1: }
    1: 
    1: // Flips a screen coordinate from a point in the cocoa coordinate system (bottom-left rect) to a point
    1: // that is a "flipped" cocoa coordinate system (starts in the top-left).
    1: static inline void
    1: FlipCocoaScreenCoordinate(NSPoint &inPoint)
    1: {  
 8779:   inPoint.y = nsCocoaUtils::FlippedScreenY(inPoint.y);
    1: }
    1: 
32019: static void
32019: InitNPCocoaEvent(NPCocoaEvent* event)
32019: {
32019:   memset(event, 0, sizeof(NPCocoaEvent));
32019: }
32019: 
    1: static PRUint32
    1: UnderlineAttributeToTextRangeType(PRUint32 aUnderlineStyle, NSRange selRange)
    1: {
    1: #ifdef DEBUG_IME
    1:   NSLog(@"****in underlineAttributeToTextRangeType = %d", aUnderlineStyle);
    1: #endif
    1: 
    1:   // For more info on the underline attribute, please see: 
    1:   // http://developer.apple.com/techpubs/macosx/Cocoa/TasksAndConcepts/ProgrammingTopics/AttributedStrings/Tasks/AccessingAttrs.html
    1:   // We are not clear where the define for value 2 is right now. 
    1:   // To see this value in japanese ime, type 'aaaaaaaaa' and hit space to make the
    1:   // ime send you some part of text in 1 (NSSingleUnderlineStyle) and some part in 2. 
    1:   // ftang will ask apple for more details
    1:   //
20129:   // It probably means show 1-pixel thickness underline vs 2-pixel thickness.
    1:   
    1:   PRUint32 attr;
    1:   if (selRange.length == 0) {
    1:     switch (aUnderlineStyle) {
    1:       case 1:
    1:         attr = NS_TEXTRANGE_RAWINPUT;
    1:         break;
    1:       case 2:
    1:       default:
    1:         attr = NS_TEXTRANGE_SELECTEDRAWTEXT;
    1:         break;
    1:     }
    1:   }
    1:   else {
    1:     switch (aUnderlineStyle) {
    1:       case 1:
    1:         attr = NS_TEXTRANGE_CONVERTEDTEXT;
    1:         break;
    1:       case 2:
    1:       default:
    1:         attr = NS_TEXTRANGE_SELECTEDCONVERTEDTEXT;
    1:         break;
    1:     }
    1:   }
    1:   return attr;
    1: }
    1: 
    1: static PRUint32
    1: CountRanges(NSAttributedString *aString)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
    1:   // Iterate through aString for the NSUnderlineStyleAttributeName and count the 
    1:   // different segments adjusting limitRange as we go.
    1:   PRUint32 count = 0;
    1:   NSRange effectiveRange;
    1:   NSRange limitRange = NSMakeRange(0, [aString length]);
    1:   while (limitRange.length > 0) {
    1:     [aString attribute:NSUnderlineStyleAttributeName 
    1:                atIndex:limitRange.location 
    1:  longestEffectiveRange:&effectiveRange
    1:                inRange:limitRange];
    1:     limitRange = NSMakeRange(NSMaxRange(effectiveRange), 
    1:                              NSMaxRange(limitRange) - NSMaxRange(effectiveRange));
    1:     count++;
    1:   }
    1:   return count;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0);
    1: }
    1: 
    1: static void
    1: ConvertAttributeToGeckoRange(NSAttributedString *aString, NSRange markRange, NSRange selRange, PRUint32 inCount, nsTextRange* aRanges)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   // Convert the Cocoa range into the nsTextRange Array used in Gecko.
    1:   // Iterate through the attributed string and map the underline attribute to Gecko IME textrange attributes.
    1:   // We may need to change the code here if we change the implementation of validAttributesForMarkedText.
    1:   PRUint32 i = 0;
    1:   NSRange effectiveRange;
    1:   NSRange limitRange = NSMakeRange(0, [aString length]);
    1:   while ((limitRange.length > 0) && (i < inCount)) {
    1:     id attributeValue = [aString attribute:NSUnderlineStyleAttributeName 
    1:                               atIndex:limitRange.location 
    1:                               longestEffectiveRange:&effectiveRange
    1:                               inRange:limitRange];
    1:     aRanges[i].mStartOffset = effectiveRange.location;                         
    1:     aRanges[i].mEndOffset = NSMaxRange(effectiveRange);                         
    1:     aRanges[i].mRangeType = UnderlineAttributeToTextRangeType([attributeValue intValue], selRange); 
    1:     limitRange = NSMakeRange(NSMaxRange(effectiveRange), 
    1:                              NSMaxRange(limitRange) - NSMaxRange(effectiveRange));
    1:     i++;
    1:   }
    1:   // Get current caret position.
    1:   aRanges[i].mStartOffset = selRange.location + selRange.length;                         
44169:   aRanges[i].mEndOffset = aRanges[i].mStartOffset;                         
    1:   aRanges[i].mRangeType = NS_TEXTRANGE_CARETPOSITION;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: static void
    1: FillTextRangeInTextEvent(nsTextEvent *aTextEvent, NSAttributedString* aString, NSRange markRange, NSRange selRange)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   // Count the number of segments in the attributed string and add one more count for sending current caret position to Gecko.
    1:   // Allocate the right size of nsTextRange and draw caret at right position.
    1:   // Convert the attributed string into an array of nsTextRange and get current caret position by calling above functions.
    1:   PRUint32 count = CountRanges(aString) + 1;
    1:   aTextEvent->rangeArray = new nsTextRange[count];
11978:   if (aTextEvent->rangeArray) {
    1:     aTextEvent->rangeCount = count;
    1:     ConvertAttributeToGeckoRange(aString, markRange, selRange, aTextEvent->rangeCount,  aTextEvent->rangeArray);
    1:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
32916: #if defined(DEBUG) && defined(PR_LOGGING)
32916: 
32916: static void DebugPrintAllKeyboardLayouts()
32916: {
33316:   nsCocoaTextInputHandler::DebugPrintAllKeyboardLayouts(sCocoaLog);
33316:   nsCocoaIMEHandler::DebugPrintAllIMEModes(sCocoaLog);
32302: }
32916: 
32916: #endif // defined(DEBUG) && defined(PR_LOGGING)
32916: 
32916: #pragma mark -
32916: 
32916: nsChildView::nsChildView() : nsBaseWidget()
32916: , mView(nsnull)
32916: , mParentView(nsnull)
32916: , mParentWidget(nsnull)
32916: , mVisible(PR_FALSE)
32916: , mDrawing(PR_FALSE)
32916: , mPluginDrawing(PR_FALSE)
50639: , mIsDispatchPaint(PR_FALSE)
39656: , mPluginInstanceOwner(nsnull)
32916: {
32916: #ifdef PR_LOGGING
32916:   if (!sCocoaLog) {
32916:     sCocoaLog = PR_NewLogModule("nsCocoaWidgets");
32916: #ifdef DEBUG
32916:     DebugPrintAllKeyboardLayouts();
32916: #endif // DEBUG
32916:   }
32302: #endif // PR_LOGGING
 3545: 
39839:   memset(&mPluginCGContext, 0, sizeof(mPluginCGContext));
43647: #ifndef NP_NO_QUICKDRAW
39839:   memset(&mPluginQDPort, 0, sizeof(mPluginQDPort));
43647: #endif
39839: 
 5676:   SetBackgroundColor(NS_RGB(255, 255, 255));
 5676:   SetForegroundColor(NS_RGB(0, 0, 0));
    1: }
    1: 
    1: nsChildView::~nsChildView()
    1: {
30427:   // Notify the children that we're gone.  childView->ResetParent() can change
30427:   // our list of children while it's being iterated, so the way we iterate the
30427:   // list must allow for this.
30427:   for (nsIWidget* kid = mLastChild; kid;) {
 3233:     nsChildView* childView = static_cast<nsChildView*>(kid);
30427:     kid = kid->GetPrevSibling();
27679:     childView->ResetParent();
    1:   }
    1: 
15567:   NS_WARN_IF_FALSE(mOnDestroyCalled, "nsChildView object destroyed without calling Destroy()");
15567: 
15567:   // An nsChildView object that was in use can be destroyed without Destroy()
15567:   // ever being called on it.  So we also need to do a quick, safe cleanup
15567:   // here (it's too late to just call Destroy(), which can cause crashes).
15567:   // It's particularly important to make sure widgetDestroyed is called on our
15567:   // mView -- this method NULLs mView's mGeckoChild, and NULL checks on
15567:   // mGeckoChild are used throughout the ChildView class to tell if it's safe
15567:   // to use a ChildView object.
15567:   [mView widgetDestroyed]; // Safe if mView is nil.
15567:   mParentWidget = nil;
15567:   TearDownView(); // Safe if called twice.
    1: }
    1: 
15919: NS_IMPL_ISUPPORTS_INHERITED1(nsChildView, nsBaseWidget, nsIPluginWidget)
    1: 
33013: nsresult nsChildView::Create(nsIWidget *aParent,
33013:                              nsNativeWidget aNativeParent,
23738:                              const nsIntRect &aRect,
    1:                              EVENT_CALLBACK aHandleEventFunction,
    1:                              nsIDeviceContext *aContext,
    1:                              nsIAppShell *aAppShell,
    1:                              nsIToolkit *aToolkit,
33013:                              nsWidgetInitData *aInitData)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
40740:   // Because the hidden window is created outside of an event loop,
40740:   // we need to provide an autorelease pool to avoid leaking cocoa objects
40740:   // (see bug 559075).
40740:   nsAutoreleasePool localPool;
40740: 
24707:   // See NSView (MethodSwizzling) below.
38435:   if (!gChildViewMethodsSwizzled) {
24707:     nsToolkit::SwizzleMethods([NSView class], @selector(mouseDownCanMoveWindow),
24707:                               @selector(nsChildView_NSView_mouseDownCanMoveWindow));
61078: #ifndef NP_NO_CARBON
61078:     Class IMKInputSessionClass = ::NSClassFromString(@"IMKInputSession");
61078:     nsToolkit::SwizzleMethods(IMKInputSessionClass, @selector(handleEvent:),
61078:                               @selector(nsChildView_IMKInputSession_handleEvent:));
61078:     nsToolkit::SwizzleMethods(IMKInputSessionClass, @selector(commitComposition),
61078:                               @selector(nsChildView_IMKInputSession_commitComposition));
61078:     nsToolkit::SwizzleMethods(IMKInputSessionClass, @selector(finishSession),
61078:                               @selector(nsChildView_IMKInputSession_finishSession));
61078: #endif
24707:     gChildViewMethodsSwizzled = PR_TRUE;
24707:   }
11675: 
    1:   mBounds = aRect;
    1: 
    1:   BaseCreate(aParent, aRect, aHandleEventFunction, 
    1:              aContext, aAppShell, aToolkit, aInitData);
    1: 
    1:   // inherit things from the parent view and create our parallel 
    1:   // NSView in the Cocoa display system
    1:   mParentView = nil;
    1:   if (aParent) {
33013:     // This is the case when we're the popup content view of a popup window.
    1:     SetBackgroundColor(aParent->GetBackgroundColor());
    1:     SetForegroundColor(aParent->GetForegroundColor());
    1: 
    1:     // inherit the top-level window. NS_NATIVE_WIDGET is always a NSView
    1:     // regardless of if we're asking a window or a view (for compatibility
    1:     // with windows).
    1:     mParentView = (NSView*)aParent->GetNativeData(NS_NATIVE_WIDGET); 
    1:     mParentWidget = aParent;   
33013:   } else {
33013:     // This is the normal case. When we're the root widget of the view hiararchy,
33013:     // aNativeParent will be the contentView of our window, since that's what
33013:     // nsCocoaWindow returns when asked for an NS_NATIVE_VIEW.
 3233:     mParentView = reinterpret_cast<NSView*>(aNativeParent);
33013:   }
    1:   
    1:   // create our parallel NSView and hook it up to our parent. Recall
    1:   // that NS_NATIVE_WIDGET is the NSView.
    1:   NSRect r;
    1:   GeckoRectToNSRect(mBounds, r);
    1:   mView = [CreateCocoaView(r) retain];
    1:   if (!mView) return NS_ERROR_FAILURE;
    1: 
37446:   [(ChildView*)mView setIsPluginView:(mWindowType == eWindowType_plugin)];
37446: 
    1:   // If this view was created in a Gecko view hierarchy, the initial state
    1:   // is hidden.  If the view is attached only to a native NSView but has
    1:   // no Gecko parent (as in embedding), the initial state is visible.
    1:   if (mParentWidget)
    1:     [mView setHidden:YES];
    1:   else
    1:     mVisible = PR_TRUE;
    1: 
    1:   // Hook it up in the NSView hierarchy.
    1:   if (mParentView) {
    1:     [mParentView addSubview:mView];
    1:   }
    1: 
    1:   // if this is a ChildView, make sure that our per-window data
    1:   // is set up
    1:   if ([mView isKindOfClass:[ChildView class]])
29297:     [[WindowDataMap sharedWindowDataMap] ensureDataForWindow:[mView window]];
    1: 
33316:   mTextInputHandler.Init(this);
33316: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: // Creates the appropriate child view. Override to create something other than
    1: // our |ChildView| object. Autoreleases, so caller must retain.
    1: NSView*
    1: nsChildView::CreateCocoaView(NSRect inFrame)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 6754:   return [[[ChildView alloc] initWithFrame:inFrame geckoChild:this] autorelease];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: void nsChildView::TearDownView()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if (!mView)
    1:     return;
    1: 
    1:   NSWindow* win = [mView window];
    1:   NSResponder* responder = [win firstResponder];
    1: 
    1:   // We're being unhooked from the view hierarchy, don't leave our view
    1:   // or a child view as the window first responder.
    1:   if (responder && [responder isKindOfClass:[NSView class]] &&
    1:       [(NSView*)responder isDescendantOf:mView]) {
    1:     [win makeFirstResponder:[mView superview]];
    1:   }
    1: 
 2000:   // If mView is win's contentView, win (mView's NSWindow) "owns" mView --
 2000:   // win has retained mView, and will detach it from the view hierarchy and
 2000:   // release it when necessary (when win is itself destroyed (in a call to
 2000:   // [win dealloc])).  So all we need to do here is call [mView release] (to
 2000:   // match the call to [mView retain] in nsChildView::StandardCreate()).
 2000:   // Also calling [mView removeFromSuperviewWithoutNeedingDisplay] causes
 2000:   // mView to be released again and dealloced, while remaining win's
 2000:   // contentView.  So if we do that here, win will (for a short while) have
 2000:   // an invalid contentView (for the consequences see bmo bugs 381087 and
 2000:   // 374260).
 2000:   if ([mView isEqual:[win contentView]]) {
    1:     [mView release];
 2000:   } else {
 2000:     // Stop NSView hierarchy being changed during [ChildView drawRect:]
 2000:     [mView performSelectorOnMainThread:@selector(delayedTearDown) withObject:nil waitUntilDone:false];
 2000:   }
    1:   mView = nil;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
31534: nsCocoaWindow*
31534: nsChildView::GetXULWindowWidget()
31534: {
32510:   id windowDelegate = [[mView window] delegate];
31534:   if (windowDelegate && [windowDelegate isKindOfClass:[WindowDelegate class]]) {
31534:     return [(WindowDelegate *)windowDelegate geckoWidget];
31534:   }
31534:   return nsnull;
31534: }
31534: 
    1: NS_IMETHODIMP nsChildView::Destroy()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   if (mOnDestroyCalled)
    1:     return NS_OK;
    1:   mOnDestroyCalled = PR_TRUE;
    1: 
    1:   [mView widgetDestroyed];
    1: 
    1:   nsBaseWidget::Destroy();
    1: 
10305:   ReportDestroyEvent(); 
    1:   mParentWidget = nil;
    1: 
    1:   TearDownView();
    1: 
25875:   nsBaseWidget::OnDestroy();
25875: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: #pragma mark -
    1: 
    1: #if 0
    1: static void PrintViewHierarchy(NSView *view)
    1: {
    1:   while (view) {
    1:     NSLog(@"  view is %x, frame %@", view, NSStringFromRect([view frame]));
    1:     view = [view superview];
    1:   }
    1: }
    1: #endif
    1: 
    1: // Return native data according to aDataType
    1: void* nsChildView::GetNativeData(PRUint32 aDataType)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSNULL;
11978: 
    1:   void* retVal = nsnull;
    1: 
    1:   switch (aDataType) 
    1:   {
 6013:     case NS_NATIVE_WIDGET:
    1:     case NS_NATIVE_DISPLAY:
    1:       retVal = (void*)mView;
    1:       break;
    1: 
    1:     case NS_NATIVE_WINDOW:
32510:       retVal = [mView window];
    1:       break;
    1: 
 6013:     case NS_NATIVE_GRAPHIC:
31561:       NS_ERROR("Requesting NS_NATIVE_GRAPHIC on a Mac OS X child view!");
 6013:       retVal = nsnull;
    1:       break;
    1: 
    1:     case NS_NATIVE_OFFSETX:
    1:       retVal = 0;
    1:       break;
    1: 
    1:     case NS_NATIVE_OFFSETY:
    1:       retVal = 0;
    1:       break;
    1: 
    1:     case NS_NATIVE_PLUGIN_PORT:
  130:     case NS_NATIVE_PLUGIN_PORT_QD:
30549:     case NS_NATIVE_PLUGIN_PORT_CG:
30549:     {
37446:       // The NP_CGContext pointer should always be NULL in the Cocoa event model.
37446:       if ([(ChildView*)mView pluginEventModel] == NPEventModelCocoa)
37446:         return nsnull;
    1: 
30549:       UpdatePluginPort();
54248: #ifndef NP_NO_QUICKDRAW
54248:       if (aDataType != NS_NATIVE_PLUGIN_PORT_CG) {
54248:         retVal = (void*)&mPluginQDPort;
54248:         break;
54248:       }
54248: #endif
32799:       retVal = (void*)&mPluginCGContext;
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return retVal;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL;
    1: }
    1: 
    1: #pragma mark -
    1: 
16601: nsTransparencyMode nsChildView::GetTransparencyMode()
16601: {
34853:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
34853: 
34853:   nsCocoaWindow* windowWidget = GetXULWindowWidget();
34853:   return windowWidget ? windowWidget->GetTransparencyMode() : eTransparencyOpaque;
34853: 
34853:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(eTransparencyOpaque);
 9499: }
 9499: 
 9499: // This is called by nsContainerFrame on the root widget for all window types
16601: // except popup windows (when nsCocoaWindow::SetTransparencyMode is used instead).
16601: void nsChildView::SetTransparencyMode(nsTransparencyMode aMode)
16601: {
16601:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
16601: 
34853:   nsCocoaWindow* windowWidget = GetXULWindowWidget();
34853:   if (windowWidget) {
34853:     windowWidget->SetTransparencyMode(aMode);
16601:   }
16601: 
16601:   NS_OBJC_END_TRY_ABORT_BLOCK;
 9499: }
 9499: 
    1: NS_IMETHODIMP nsChildView::IsVisible(PRBool& outState)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   if (!mVisible) {
    1:     outState = mVisible;
    1:   }
    1:   else {
    1:     // mVisible does not accurately reflect the state of a hidden tabbed view
    1:     // so verify that the view has a window as well
    1:     outState = ([mView window] != nil);
    1:     // now check native widget hierarchy visibility
    1:     if (outState && NSIsEmptyRect([mView visibleRect])) {
    1:       outState = PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
14641: void nsChildView::HidePlugin()
14641: {
33357:   NS_ASSERTION(mWindowType == eWindowType_plugin,
33357:                "HidePlugin called on non-plugin view");
14641: 
54248: #ifndef NP_NO_QUICKDRAW
54248:   if (mPluginInstanceOwner && mView &&
54248:       [(ChildView*)mView pluginDrawingModel] == NPDrawingModelQuickDraw) {
32799:     NPWindow* window;
14641:     mPluginInstanceOwner->GetWindow(window);
14641:     nsCOMPtr<nsIPluginInstance> instance;
14641:     mPluginInstanceOwner->GetInstance(*getter_AddRefs(instance));
14641:     if (window && instance) {
14641:        window->clipRect.top = 0;
14641:        window->clipRect.left = 0;
14641:        window->clipRect.bottom = 0;
14641:        window->clipRect.right = 0;
14641:        instance->SetWindow(window);
14641:     }
14641:   }
54248: #endif
14641: }
14641: 
30549: void nsChildView::UpdatePluginPort()
30549: {
33357:   NS_ASSERTION(mWindowType == eWindowType_plugin,
33357:                "UpdatePluginPort called on non-plugin view");
30549: 
43647: #if !defined(NP_NO_CARBON) || !defined(NP_NO_QUICKDRAW)
32510:   NSWindow* cocoaWindow = [mView window];
32019:   WindowRef carbonWindow = cocoaWindow ? (WindowRef)[cocoaWindow windowRef] : NULL;
32120: #endif
32019: 
54248:   if (!mView
54248: #ifndef NP_NO_QUICKDRAW
54248:     || [(ChildView*)mView pluginDrawingModel] != NPDrawingModelQuickDraw
54248: #endif
54248:     ) {
30549:     // [NSGraphicsContext currentContext] is supposed to "return the
30549:     // current graphics context of the current thread."  But sometimes
30549:     // (when called while mView isn't focused for drawing) it returns a
30549:     // graphics context for the wrong window.  [window graphicsContext]
30549:     // (which "provides the graphics context associated with the window
30549:     // for the current thread") seems always to return the "right"
30549:     // graphics context.  See bug 500130.
32799:     mPluginCGContext.context = NULL;
32799:     mPluginCGContext.window = NULL;
32120: #ifndef NP_NO_CARBON
32019:     if (carbonWindow) {
32799:       mPluginCGContext.context = (CGContextRef)[[cocoaWindow graphicsContext] graphicsPort];
32799:       mPluginCGContext.window = carbonWindow;
32019:     }
32120: #endif
32120:   }
32120: #ifndef NP_NO_QUICKDRAW
32120:   else {
32019:     if (carbonWindow) {
32799:       mPluginQDPort.port = ::GetWindowPort(carbonWindow);
30549: 
30549:       NSPoint viewOrigin = [mView convertPoint:NSZeroPoint toView:nil];
32019:       NSRect frame = [[cocoaWindow contentView] frame];
30549:       viewOrigin.y = frame.size.height - viewOrigin.y;
30549: 
30549:       // need to convert view's origin to window coordinates.
30549:       // then, encode as "SetOrigin" ready values.
32799:       mPluginQDPort.portx = (PRInt32)-viewOrigin.x;
32799:       mPluginQDPort.porty = (PRInt32)-viewOrigin.y;
30549:     } else {
32799:       mPluginQDPort.port = NULL;
30549:     }
30549:   }
32120: #endif
30549: }
30549: 
14641: static void HideChildPluginViews(NSView* aView)
14641: {
14641:   NSArray* subviews = [aView subviews];
14641: 
14641:   for (unsigned int i = 0; i < [subviews count]; ++i) {
14641:     NSView* view = [subviews objectAtIndex: i];
14641: 
14641:     if (![view isKindOfClass:[ChildView class]])
14641:       continue;
14641: 
14641:     ChildView* childview = static_cast<ChildView*>(view);
14641:     if ([childview isPluginView]) {
14641:       nsChildView* widget = static_cast<nsChildView*>([childview widget]);
14641:       if (widget) {
14641:         widget->HidePlugin();
14641:       }
14641:     } else {
14641:       HideChildPluginViews(view);
14641:     }
14641:   }
14641: }
14641: 
    1: // Hide or show this component
    1: NS_IMETHODIMP nsChildView::Show(PRBool aState)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   if (aState != mVisible) {
40740:     // Provide an autorelease pool because this gets called during startup
40740:     // on the "hidden window", resulting in cocoa object leakage if there's
40740:     // no pool in place.
40740:     nsAutoreleasePool localPool;
40740: 
    1:     [mView setHidden:!aState];
    1:     mVisible = aState;
52100:     if (!mVisible && IsPluginView())
52100:       HidePlugin();
    1:   }
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
27679: // Change the parent of this widget
21041: NS_IMETHODIMP
21041: nsChildView::SetParent(nsIWidget* aNewParent)
21041: {
21041:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
21041: 
21041:   NS_ENSURE_ARG(aNewParent);
54312: 
54312:   if (mOnDestroyCalled)
54312:     return NS_OK;
54312: 
54312:   // make sure we stay alive
54312:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
54312:   
54312:   // remove us from our existing parent
54312:   if (mParentWidget)
54312:     mParentWidget->RemoveChild(this);
54312: 
54312:   nsresult rv = ReparentNativeWidget(aNewParent);
54312:   if (NS_SUCCEEDED(rv))
54312:     mParentWidget = aNewParent;
54312: 
54312:   // add us to the new parent
54312:   mParentWidget->AddChild(this);
54312:   return NS_OK;
54312:   
54312:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
54312: }
54312: 
54312: NS_IMETHODIMP
54312: nsChildView::ReparentNativeWidget(nsIWidget* aNewParent)
54312: {
54312:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
54312: 
54312:   NS_PRECONDITION(aNewParent, "");
54312: 
54312:   if (mOnDestroyCalled)
54312:     return NS_OK;
54312: 
21041:   NSView<mozView>* newParentView =
21041:    (NSView*)aNewParent->GetNativeData(NS_NATIVE_WIDGET); 
21041:   NS_ENSURE_TRUE(newParentView, NS_ERROR_FAILURE);
21041: 
21041:   // we hold a ref to mView, so this is safe
21041:   [mView removeFromSuperview];
21041:   mParentView   = newParentView;
21041:   [mParentView addSubview:mView];
21041:   return NS_OK;
21041: 
21041:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
21041: }
    1: 
27679: void nsChildView::ResetParent()
27679: {
27679:   if (!mOnDestroyCalled) {
27679:     if (mParentWidget)
27679:       mParentWidget->RemoveChild(this);
27679:     if (mView)
27679:       [mView removeFromSuperview];
27679:   }
27679:   mParentWidget = nsnull;
27679: }
27679: 
20723: nsIWidget*
41321: nsChildView::GetParent()
    1: {
    1:   return mParentWidget;
    1: }
    1: 
50783: float
50783: nsChildView::GetDPI()
50783: {
50783:   NSWindow* window = [mView window];
50873:   if (window && [window isKindOfClass:[BaseWindow class]]) {
50873:     return [(BaseWindow*)window getDPI];
50873:   }
50873: 
50873:   return 96.0;
50783: }
50783: 
    1: NS_IMETHODIMP nsChildView::Enable(PRBool aState)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsChildView::IsEnabled(PRBool *aState)
    1: {
    1:   // unimplemented
    1:   if (aState)
    1:    *aState = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsChildView::SetFocus(PRBool aRaise)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   NSWindow* window = [mView window];
29018:   if (window)
29018:     [window makeFirstResponder:mView];
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: // Override to set the cursor on the mac
    1: NS_IMETHODIMP nsChildView::SetCursor(nsCursor aCursor)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
39094:   if ([mView isDragInProgress])
39094:     return NS_OK; // Don't change the cursor during dragging.
39094: 
    1:   nsBaseWidget::SetCursor(aCursor);
39278:   return [[nsCursorManager sharedInstance] setCursor:aCursor];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: // implement to fix "hidden virtual function" warning
    1: NS_IMETHODIMP nsChildView::SetCursor(imgIContainer* aCursor,
    1:                                       PRUint32 aHotspotX, PRUint32 aHotspotY)
    1: {
39278:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
39278: 
39278:   nsBaseWidget::SetCursor(aCursor, aHotspotX, aHotspotY);
39278:   return [[nsCursorManager sharedInstance] setCursorWithImage:aCursor hotSpotX:aHotspotX hotSpotY:aHotspotY];
39278: 
39278:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: #pragma mark -
    1: 
    1: // Get this component dimension
23738: NS_IMETHODIMP nsChildView::GetBounds(nsIntRect &aRect)
    1: {
54180:   if (!mView) {
    1:     aRect = mBounds;
54180:   } else {
54180:     NSRect frame = [mView frame];
54180:     NSRectToGeckoRect(frame, aRect);
54180:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsChildView::ConstrainPosition(PRBool aAllowSlop,
    1:                                              PRInt32 *aX, PRInt32 *aY)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // Move this component, aX and aY are in the parent widget coordinate system
    1: NS_IMETHODIMP nsChildView::Move(PRInt32 aX, PRInt32 aY)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 7635:   if (!mView || (mBounds.x == aX && mBounds.y == aY))
 7635:     return NS_OK;
 7635: 
    1:   mBounds.x = aX;
    1:   mBounds.y = aY;
    1: 
    1:   NSRect r;
    1:   GeckoRectToNSRect(mBounds, r);
    1:   [mView setFrame:r];
    1: 
 7635:   if (mVisible)
    1:     [mView setNeedsDisplay:YES];
    1: 
    1:   ReportMoveEvent();
 7635: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: NS_IMETHODIMP nsChildView::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 7635:   if (!mView || (mBounds.width == aWidth && mBounds.height == aHeight))
 7635:     return NS_OK;
 7635: 
    1:   mBounds.width  = aWidth;
    1:   mBounds.height = aHeight;
    1: 
    1:   NSRect r;
    1:   GeckoRectToNSRect(mBounds, r);
    1:   [mView setFrame:r];
    1: 
    1:   if (mVisible && aRepaint)
    1:     [mView setNeedsDisplay:YES];
    1: 
    1:   ReportSizeEvent();
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: NS_IMETHODIMP nsChildView::Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 7635:   BOOL isMoving = (mBounds.x != aX || mBounds.y != aY);
 7635:   BOOL isResizing = (mBounds.width != aWidth || mBounds.height != aHeight);
 7635:   if (!mView || (!isMoving && !isResizing))
 7635:     return NS_OK;
 7635: 
 7635:   if (isMoving) {
 7635:     mBounds.x = aX;
 7635:     mBounds.y = aY;
 7635:   }
 7635:   if (isResizing) {
 7635:     mBounds.width  = aWidth;
 7635:     mBounds.height = aHeight;
 7635:   }
 7635: 
 7635:   NSRect r;
 7635:   GeckoRectToNSRect(mBounds, r);
 7635:   [mView setFrame:r];
 7635: 
 7635:   if (mVisible && aRepaint)
 7635:     [mView setNeedsDisplay:YES];
 7635: 
10305:   if (isMoving) {
 7635:     ReportMoveEvent();
10305:     if (mOnDestroyCalled)
10305:       return NS_OK;
10305:   }
 7635:   if (isResizing)
 7635:     ReportSizeEvent();
 7635: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
16520: static const PRInt32 resizeIndicatorWidth = 15;
16520: static const PRInt32 resizeIndicatorHeight = 15;
16520: PRBool nsChildView::ShowsResizeIndicator(nsIntRect* aResizerRect)
16520: {
16520:   NSView *topLevelView = mView, *superView = nil;
17108:   while ((superView = [topLevelView superview]))
16520:     topLevelView = superView;
16520: 
32298:   if (![[topLevelView window] showsResizeIndicator] ||
32298:       !([[topLevelView window] styleMask] & NSResizableWindowMask))
16520:     return PR_FALSE;
16520: 
16520:   if (aResizerRect) {
16520:     NSSize bounds = [topLevelView bounds].size;
16520:     NSPoint corner = NSMakePoint(bounds.width, [topLevelView isFlipped] ? bounds.height : 0);
16520:     corner = [topLevelView convertPoint:corner toView:mView];
16520:     aResizerRect->SetRect(NSToIntRound(corner.x) - resizeIndicatorWidth,
16520:                           NSToIntRound(corner.y) - resizeIndicatorHeight,
16520:                           resizeIndicatorWidth, resizeIndicatorHeight);
16520:   }
16520:   return PR_TRUE;
16520: }
16520: 
24684: // In QuickDraw mode the coordinate system used here should be that of the
24684: // browser window's content region (defined as everything but the 22-pixel
24684: // high titlebar).  But in CoreGraphics mode the coordinate system should be
24684: // that of the browser window as a whole (including its titlebar).  Both
24684: // coordinate systems have a top-left origin.  See bmo bug 474491.
24684: //
24684: // There's a bug in this method's code -- it currently uses the QuickDraw
24684: // coordinate system for both the QuickDraw and CoreGraphics drawing modes.
24684: // This bug is fixed by the patch for bug 474491.  But the Flash plugin (both
24684: // version 10.0.12.36 from Adobe and version 9.0 r151 from Apple) has Mozilla-
24684: // specific code to work around this bug, which breaks when we fix it (see bmo
24684: // bug 477077).  So we'll need to coordinate releasing a fix for this bug with
24684: // Adobe and other major plugin vendors that support the CoreGraphics mode.
23738: NS_IMETHODIMP nsChildView::GetPluginClipRect(nsIntRect& outClipRect, nsIntPoint& outOrigin, PRBool& outWidgetVisible)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
33357:   NS_ASSERTION(mWindowType == eWindowType_plugin,
33357:                "GetPluginClipRect must only be called on a plugin widget");
33357:   if (mWindowType != eWindowType_plugin) return NS_ERROR_FAILURE;
    1:   
32510:   NSWindow* window = [mView window];
    1:   if (!window) return NS_ERROR_FAILURE;
    1:   
    1:   NSPoint viewOrigin = [mView convertPoint:NSZeroPoint toView:nil];
24681:   NSRect frame = [[window contentView] frame];
    1:   viewOrigin.y = frame.size.height - viewOrigin.y;
    1:   
    1:   // set up the clipping region for plugins.
    1:   NSRect visibleBounds = [mView visibleRect];
    1:   NSPoint clipOrigin   = [mView convertPoint:visibleBounds.origin toView:nil];
    1:   
24681:   // Convert from cocoa to QuickDraw coordinates
    1:   clipOrigin.y = frame.size.height - clipOrigin.y;
    1:   
23738:   outClipRect.x = NSToIntRound(clipOrigin.x);
23738:   outClipRect.y = NSToIntRound(clipOrigin.y);
    1: 
30515:   // need to convert view's origin to window coordinates.
30515:   // then, encode as "SetOrigin" ready values.
30515:   outOrigin.x = -NSToIntRound(viewOrigin.x);
30515:   outOrigin.y = -NSToIntRound(viewOrigin.y);
    1: 
    1:   PRBool isVisible;
    1:   IsVisible(isVisible);
    1:   if (isVisible && [mView window] != nil) {
23738:     outClipRect.width  = NSToIntRound(visibleBounds.origin.x + visibleBounds.size.width) - NSToIntRound(visibleBounds.origin.x);
23738:     outClipRect.height = NSToIntRound(visibleBounds.origin.y + visibleBounds.size.height) - NSToIntRound(visibleBounds.origin.y);
30515: 
30515:     if (mClipRects) {
30515:       nsIntRect clipBounds;
32120:       for (PRInt32 i = 0; i < mClipRectCount; ++i) {
30515:         clipBounds.UnionRect(clipBounds, mClipRects[i]);
30515:       }
30515:       outClipRect.IntersectRect(outClipRect, clipBounds - outOrigin);
30515:     }
30515: 
30515:     // XXXroc should this be !outClipRect.IsEmpty()?
    1:     outWidgetVisible = PR_TRUE;
    1:   }
    1:   else {
    1:     outClipRect.width = 0;
    1:     outClipRect.height = 0;
    1:     outWidgetVisible = PR_FALSE;
    1:   }
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
54249: #ifndef NP_NO_CARBON
54249: static void InitializeEventRecord(EventRecord* event, Point* aMousePosition)
54249: {
54249:   memset(event, 0, sizeof(EventRecord));
54249:   if (aMousePosition) {
54249:     event->where = *aMousePosition;
54249:   } else {
54249:     ::GetGlobalMouse(&event->where);
54249:   }
54249:   event->when = ::TickCount();
54249:   event->modifiers = ::GetCurrentKeyModifiers();
54249: }
54249: #endif
54249: 
54249: void nsChildView::PaintQD()
54249: {
54249: #ifndef NP_NO_CARBON
54249:   void *pluginPort = this->GetNativeData(NS_NATIVE_PLUGIN_PORT_QD);
54249:   void *window = ::GetWindowFromPort(static_cast<NP_Port*>(pluginPort)->port);
54249: 
54249:   NS_SUCCEEDED(StartDrawPlugin());
54249:   EventRecord updateEvent;
54249:   InitializeEventRecord(&updateEvent, nsnull);
54249:   updateEvent.what = updateEvt;
54249:   updateEvent.message = UInt32(window);
54249: 
54249:   nsCOMPtr<nsIPluginInstance> instance;
54249:   mPluginInstanceOwner->GetInstance(*getter_AddRefs(instance));
54249: 
54249:   instance->HandleEvent(&updateEvent, nsnull);
54249:   EndDrawPlugin();
54249: #endif
54249: }
54249: 
    1: NS_IMETHODIMP nsChildView::StartDrawPlugin()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
33357:   NS_ASSERTION(mWindowType == eWindowType_plugin,
33357:                "StartDrawPlugin must only be called on a plugin widget");
33357:   if (mWindowType != eWindowType_plugin) return NS_ERROR_FAILURE;
  130: 
32120:   // This code is necessary for both Quickdraw and CoreGraphics in 32-bit builds.
32120:   // See comments below about why. In 64-bit CoreGraphics mode we will not keep
32120:   // this region up to date, plugins should not depend on it.
32120: #ifndef __LP64__
32510:   NSWindow* window = [mView window];
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
32019:   // In QuickDraw drawing mode, prevent reentrant handling of any plugin event
32019:   // (this emulates behavior on the 1.8 branch, where only QuickDraw mode is
32019:   // supported).  But in CoreGraphics drawing mode only do this if the current
32019:   // plugin event isn't an update/paint event.  This allows popupcontextmenu()
32019:   // to work properly from a plugin that supports the Cocoa event model,
32019:   // without regressing bug 409615.  See bug 435041.  (StartDrawPlugin() and
32019:   // EndDrawPlugin() wrap every call to nsIPluginInstance::HandleEvent() --
32019:   // not just calls that "draw" or paint.)
54248:   PRBool isQDPlugin = [(ChildView*)mView pluginDrawingModel] == NPDrawingModelQuickDraw;
54248:   if (isQDPlugin || mIsDispatchPaint) {
32019:     if (mPluginDrawing)
32019:       return NS_ERROR_FAILURE;
32019:   }
32019: 
    1:   // It appears that the WindowRef from which we get the plugin port undergoes the
    1:   // traditional BeginUpdate/EndUpdate cycle, which, if you recall, sets the visible
    1:   // region to the intersection of the visible region and the update region. Since
    1:   // we don't know here if we're being drawn inside a BeginUpdate/EndUpdate pair
    1:   // (which seem to occur in [NSWindow display]), and we don't want to have the burden
    1:   // of correctly doing Carbon invalidates of the plugin rect, we manually set the
14027:   // visible region to be the entire port every time. It is necessary to set up our
14027:   // window's port even for CoreGraphics plugins, because they may still use Carbon
14027:   // internally (see bug #420527 for details).
14027:   CGrafPtr port = ::GetWindowPort(WindowRef([window windowRef]));
54248:   if (isQDPlugin) {
32799:     port = mPluginQDPort.port;
54248:   }
14027: 
    1:   RgnHandle pluginRegion = ::NewRgn();
    1:   if (pluginRegion) {
14027:     PRBool portChanged = (port != CGrafPtr(GetQDGlobalsThePort()));
    1:     CGrafPtr oldPort;
    1:     GDHandle oldDevice;
    1: 
    1:     if (portChanged) {
    1:       ::GetGWorld(&oldPort, &oldDevice);
14027:       ::SetGWorld(port, ::IsPortOffscreen(port) ? nsnull : ::GetMainDevice());
    1:     }
    1: 
    1:     ::SetOrigin(0, 0);
    1:     
23738:     nsIntRect clipRect; // this is in native window coordinates
23738:     nsIntPoint origin;
    1:     PRBool visible;
    1:     GetPluginClipRect(clipRect, origin, visible);
    1:     
    1:     // XXX if we're not visible, set an empty clip region?
    1:     Rect pluginRect;
    1:     ConvertGeckoRectToMacRect(clipRect, pluginRect);
    1:     
    1:     ::RectRgn(pluginRegion, &pluginRect);
14027:     ::SetPortVisibleRegion(port, pluginRegion);
14027:     ::SetPortClipRegion(port, pluginRegion);
    1:     
    1:     // now set up the origin for the plugin
    1:     ::SetOrigin(origin.x, origin.y);
    1:     
    1:     ::DisposeRgn(pluginRegion);
    1: 
    1:     if (portChanged)
    1:       ::SetGWorld(oldPort, oldDevice);
    1:   }
32120: #endif
    1: 
    1:   mPluginDrawing = PR_TRUE;
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: NS_IMETHODIMP nsChildView::EndDrawPlugin()
    1: {
33357:   NS_ASSERTION(mWindowType == eWindowType_plugin,
33357:                "EndDrawPlugin must only be called on a plugin widget");
33357:   if (mWindowType != eWindowType_plugin) return NS_ERROR_FAILURE;
  130: 
    1:   mPluginDrawing = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
14641: NS_IMETHODIMP nsChildView::SetPluginInstanceOwner(nsIPluginInstanceOwner* aInstanceOwner)
14641: {
14641:   mPluginInstanceOwner = aInstanceOwner;
14641: 
14641:   return NS_OK;
14641: }
14641: 
32019: NS_IMETHODIMP nsChildView::SetPluginEventModel(int inEventModel)
32019: {
32120:   [(ChildView*)mView setPluginEventModel:(NPEventModel)inEventModel];
32019:   return NS_OK;
32019: }
32019: 
32019: NS_IMETHODIMP nsChildView::GetPluginEventModel(int* outEventModel)
32019: {
32120:   *outEventModel = [(ChildView*)mView pluginEventModel];
32019:   return NS_OK;
32019: }
32019: 
54248: NS_IMETHODIMP nsChildView::SetPluginDrawingModel(int inDrawingModel)
54248: {
54248:   [(ChildView*)mView setPluginDrawingModel:(NPDrawingModel)inDrawingModel];
54248:   return NS_OK;
54248: }
54248: 
43436: NS_IMETHODIMP nsChildView::StartComplexTextInputForCurrentEvent()
43436: {
43436:   [(ChildView*)mView pluginRequestsComplexTextInputForCurrentEvent];
43436:   return NS_OK;
43436: }
43436: 
14962: static NSString* ToNSString(const nsAString& aString)
14962: {
14962:   return [NSString stringWithCharacters:aString.BeginReading()
14962:                                  length:aString.Length()];
14962: }
14962: 
15097: struct KeyboardLayoutOverride {
15097:   PRInt32 mKeyboardLayout;
15097:   PRBool mOverrideEnabled;
15097: };
15097: 
15097: static KeyboardLayoutOverride gOverrideKeyboardLayout;
14962: 
14962: static const PRUint32 sModifierFlagMap[][2] = {
14962:   { nsIWidget::CAPS_LOCK, NSAlphaShiftKeyMask },
14962:   { nsIWidget::SHIFT_L, NSShiftKeyMask },
20611:   { nsIWidget::SHIFT_R, NSShiftKeyMask },
14962:   { nsIWidget::CTRL_L, NSControlKeyMask },
20611:   { nsIWidget::CTRL_R, NSControlKeyMask },
14962:   { nsIWidget::ALT_L, NSAlternateKeyMask },
20611:   { nsIWidget::ALT_R, NSAlternateKeyMask },
20611:   { nsIWidget::COMMAND_L, NSCommandKeyMask },
20611:   { nsIWidget::COMMAND_R, NSCommandKeyMask },
14962:   { nsIWidget::NUMERIC_KEY_PAD, NSNumericPadKeyMask },
14962:   { nsIWidget::HELP, NSHelpKeyMask },
14962:   { nsIWidget::FUNCTION, NSFunctionKeyMask }
14962: };
14999: nsresult nsChildView::SynthesizeNativeKeyEvent(PRInt32 aNativeKeyboardLayout,
14962:                                                PRInt32 aNativeKeyCode,
14962:                                                PRUint32 aModifierFlags,
14962:                                                const nsAString& aCharacters,
14962:                                                const nsAString& aUnmodifiedCharacters)
14962: {
14999:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
14962:   
14962:   PRUint32 modifierFlags = 0;
14962:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(sModifierFlagMap); ++i) {
14962:     if (aModifierFlags & sModifierFlagMap[i][0]) {
14962:       modifierFlags |= sModifierFlagMap[i][1];
14962:     }
14962:   }
14962:   int windowNumber = [[mView window] windowNumber];
20611:   BOOL sendFlagsChangedEvent = NO;
20611:   switch (aNativeKeyCode) {
20611:     case kCapsLockKeyCode:
20611:     case kRCommandKeyCode:
20611:     case kCommandKeyCode:
20611:     case kShiftKeyCode:
20611:     case kOptionkeyCode:
20611:     case kControlKeyCode:
20611:     case kRShiftKeyCode:
20611:     case kROptionKeyCode:
20611:     case kRControlKeyCode:
20611:       sendFlagsChangedEvent = YES;
20611:   }
20528:   NSEventType eventType = sendFlagsChangedEvent ? NSFlagsChanged : NSKeyDown;
20528:   NSEvent* downEvent = [NSEvent keyEventWithType:eventType
14962:                                         location:NSMakePoint(0,0)
14962:                                    modifierFlags:modifierFlags
14962:                                        timestamp:0
14962:                                     windowNumber:windowNumber
14962:                                          context:[NSGraphicsContext currentContext]
14962:                                       characters:ToNSString(aCharacters)
14962:                      charactersIgnoringModifiers:ToNSString(aUnmodifiedCharacters)
14962:                                        isARepeat:NO
14962:                                          keyCode:aNativeKeyCode];
14962: 
20528:   NSEvent* upEvent = sendFlagsChangedEvent ? nil :
20528:                        [ChildView makeNewCocoaEventWithType:NSKeyUp
14962:                                                   fromEvent:downEvent];
14962: 
20528:   if (downEvent && (sendFlagsChangedEvent || upEvent)) {
15097:     KeyboardLayoutOverride currentLayout = gOverrideKeyboardLayout;
15097:     gOverrideKeyboardLayout.mKeyboardLayout = aNativeKeyboardLayout;
15097:     gOverrideKeyboardLayout.mOverrideEnabled = PR_TRUE;
14984:     [NSApp sendEvent:downEvent];
20528:     if (upEvent)
14984:       [NSApp sendEvent:upEvent];
14962:     // processKeyDownEvent and keyUp block exceptions so we're sure to
14962:     // reach here to restore gOverrideKeyboardLayout
14962:     gOverrideKeyboardLayout = currentLayout;
14962:   }
14962: 
14999:   return NS_OK;
14999: 
14999:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
14962: }
    1: 
32976: nsresult nsChildView::SynthesizeNativeMouseEvent(nsIntPoint aPoint,
32976:                                                  PRUint32 aNativeMessage,
32976:                                                  PRUint32 aModifierFlags)
32976: {
32976:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
32976: 
32976:   // Move the mouse cursor to the requested position and reconnect it to the mouse.
32976:   CGWarpMouseCursorPosition(CGPointMake(aPoint.x, aPoint.y));
32976:   CGAssociateMouseAndMouseCursorPosition(true);
32976: 
32976:   // aPoint is given with the origin on the top left, but convertScreenToBase
32976:   // expects a point in a coordinate system that has its origin on the bottom left.
32976:   NSPoint screenPoint = NSMakePoint(aPoint.x, [[NSScreen mainScreen] frame].size.height - aPoint.y);
32976:   NSPoint windowPoint = [[mView window] convertScreenToBase:screenPoint];
32976: 
34069:   NSEvent* event = [NSEvent mouseEventWithType:aNativeMessage
32976:                                       location:windowPoint
32976:                                  modifierFlags:aModifierFlags
32976:                                      timestamp:[NSDate timeIntervalSinceReferenceDate]
32976:                                   windowNumber:[[mView window] windowNumber]
32976:                                        context:nil
32976:                                    eventNumber:0
32976:                                     clickCount:1
32976:                                       pressure:0.0];
32976: 
32976:   if (!event)
32976:     return NS_ERROR_FAILURE;
32976: 
32976:   [NSApp sendEvent:event];
32976:   return NS_OK;
32976: 
32976:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
32976: }
32976: 
21081: // First argument has to be an NSMenu representing the application's top-level
21081: // menu bar. The returned item is *not* retained.
21081: static NSMenuItem* NativeMenuItemWithLocation(NSMenu* menubar, NSString* locationString)
21081: {
21081:   NSArray* indexes = [locationString componentsSeparatedByString:@"|"];
15578:   unsigned int indexCount = [indexes count];
15578:   if (indexCount == 0)
21081:     return nil;
15578: 
15578:   NSMenu* currentSubmenu = [NSApp mainMenu];
21081:   for (unsigned int i = 0; i < indexCount; i++) {
15578:     int targetIndex;
15578:     // We remove the application menu from consideration for the top-level menu
15578:     if (i == 0)
15578:       targetIndex = [[indexes objectAtIndex:i] intValue] + 1;
15578:     else
15578:       targetIndex = [[indexes objectAtIndex:i] intValue];
15578:     int itemCount = [currentSubmenu numberOfItems];
15578:     if (targetIndex < itemCount) {
15578:       NSMenuItem* menuItem = [currentSubmenu itemAtIndex:targetIndex];
21081:       // if this is the last index just return the menu item
21081:       if (i == (indexCount - 1))
21081:         return menuItem;
21081:       // if this is not the last index find the submenu and keep going
15578:       if ([menuItem hasSubmenu])
21081:         currentSubmenu = [menuItem submenu];
15578:       else
21081:         return nil;
21081:     }
21081:   }
21081: 
21081:   return nil;
21081: }
21081: 
21081: // Used for testing native menu system structure and event handling.
21081: NS_IMETHODIMP nsChildView::ActivateNativeMenuItemAt(const nsAString& indexString)
21081: {
21081:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
21081: 
21081:   NSString* locationString = [NSString stringWithCharacters:indexString.BeginReading() length:indexString.Length()];
21081:   NSMenuItem* item = NativeMenuItemWithLocation([NSApp mainMenu], locationString);
16264:   // We can't perform an action on an item with a submenu, that will raise
16264:   // an obj-c exception.
21081:   if (item && ![item hasSubmenu]) {
21081:     NSMenu* parent = [item menu];
21081:     if (parent) {
15578:       // NSLog(@"Performing action for native menu item titled: %@\n",
15578:       //       [[currentSubmenu itemAtIndex:targetIndex] title]);
21081:       [parent performActionForItemAtIndex:[parent indexOfItem:item]];
21081:       return NS_OK;
21081:     }
21081:   }
15578:   return NS_ERROR_FAILURE;
16264: 
16264:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
16264: }
16264: 
21081: // Used for testing native menu system structure and event handling.
21081: NS_IMETHODIMP nsChildView::ForceUpdateNativeMenuAt(const nsAString& indexString)
21081: {
21081:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
21081: 
31534:   nsCocoaWindow *widget = GetXULWindowWidget();
16264:   if (widget) {
16264:     nsMenuBarX* mb = widget->GetMenuBar();
16264:     if (mb) {
21081:       if (indexString.IsEmpty())
16264:         mb->ForceNativeMenuReload();
21081:       else
21081:         mb->ForceUpdateNativeMenuAt(indexString);
21081:     }
21081:   }
16264:   return NS_OK;
21081: 
21081:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
16264: }
16264: 
    1: #pragma mark -
    1: 
    1: #ifdef INVALIDATE_DEBUGGING
    1: 
    1: static Boolean KeyDown(const UInt8 theKey)
    1: {
    1:   KeyMap map;
    1:   GetKeys(map);
    1:   return ((*((UInt8 *)map + (theKey >> 3)) >> (theKey & 7)) & 1) != 0;
    1: }
    1: 
    1: static Boolean caps_lock()
    1: {
    1:   return KeyDown(0x39);
    1: }
    1: 
    1: static void blinkRect(Rect* r)
    1: {
    1:   StRegionFromPool oldClip;
    1:   if (oldClip != NULL)
    1:     ::GetClip(oldClip);
    1: 
    1:   ::ClipRect(r);
    1:   ::InvertRect(r);
    1:   UInt32 end = ::TickCount() + 5;
    1:   while (::TickCount() < end) ;
    1:   ::InvertRect(r);
    1: 
    1:   if (oldClip != NULL)
    1:     ::SetClip(oldClip);
    1: }
    1: 
    1: static void blinkRgn(RgnHandle rgn)
    1: {
    1:   StRegionFromPool oldClip;
    1:   if (oldClip != NULL)
    1:     ::GetClip(oldClip);
    1: 
    1:   ::SetClip(rgn);
    1:   ::InvertRgn(rgn);
    1:   UInt32 end = ::TickCount() + 5;
    1:   while (::TickCount() < end) ;
    1:   ::InvertRgn(rgn);
    1: 
    1:   if (oldClip != NULL)
    1:     ::SetClip(oldClip);
    1: }
    1: 
    1: #endif
    1: 
    1: // Invalidate this component's visible area
23738: NS_IMETHODIMP nsChildView::Invalidate(const nsIntRect &aRect, PRBool aIsSynchronous)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   if (!mView || !mVisible)
    1:     return NS_OK;
    1: 
    1:   NSRect r;
    1:   GeckoRectToNSRect(aRect, r);
    1:   
    1:   if (aIsSynchronous) {
    1:     [mView displayRect:r];
    1:   }
    1:   else if ([NSView focusView]) {
    1:     // if a view is focussed (i.e. being drawn), then postpone the invalidate so that we
    1:     // don't lose it.
    1:     [mView setNeedsPendingDisplayInRect:r];
    1:   }
    1:   else {
    1:     [mView setNeedsDisplayInRect:r];
    1:   }
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
54780: PRBool
54780: nsChildView::GetShouldAccelerate()
54780: {
62139:   // Don't use OpenGL for transparent windows or for popup windows.
62139:   if (!mView || ![[mView window] isOpaque] ||
62139:       [[mView window] isKindOfClass:[PopupWindow class]])
54780:     return PR_FALSE;
54780: 
54780:   return nsBaseWidget::GetShouldAccelerate();
54780: }
54780: 
    1: inline PRUint16 COLOR8TOCOLOR16(PRUint8 color8)
    1: {
    1:   // return (color8 == 0xFF ? 0xFFFF : (color8 << 8));
    1:   return (color8 << 8) | color8;  /* (color8 * 257) == (color8 * 0x0101) */
    1: }
    1: 
22920: // The OS manages repaints well enough on its own, so we don't have to
22920: // flush them out here.  In other words, the OS will automatically call
22920: // displayIfNeeded at the appropriate times, so we don't need to do it
22920: // ourselves.  See bmo bug 459319.
    1: NS_IMETHODIMP nsChildView::Update()
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: #pragma mark -
    1: 
55293: nsresult nsChildView::ConfigureChildren(const nsTArray<Configuration>& aConfigurations)
55293: {
55293:   for (PRUint32 i = 0; i < aConfigurations.Length(); ++i) {
55293:     const Configuration& config = aConfigurations[i];
55293:     nsChildView* child = static_cast<nsChildView*>(config.mChild);
30515: #ifdef DEBUG
30515:     nsWindowType kidType;
55293:     child->GetWindowType(kidType);
30515: #endif
52100:     NS_ASSERTION(kidType == eWindowType_plugin,
52100:                  "Configured widget is not a plugin type");
55293:     NS_ASSERTION(child->GetParent() == this,
30515:                  "Configured widget is not a child of the right widget");
52100: 
52100:     // nsIWidget::Show() doesn't get called on plugin widgets unless we call
52100:     // it from here.  See bug 592563.
55293:     child->Show(!config.mClipRegion.IsEmpty());
52100: 
55297:     PRBool repaint = PR_FALSE;
55297: #ifndef NP_NO_QUICKDRAW
55297:     repaint = child->mView &&
55295:       [(ChildView*)child->mView pluginDrawingModel] == NPDrawingModelQuickDraw;
55297: #endif
52100:     child->Resize(
55293:         config.mBounds.x, config.mBounds.y,
55293:         config.mBounds.width, config.mBounds.height,
55295:         repaint);
52100: 
52100:     // Store the clip region here in case GetPluginClipRect needs it.
55293:     child->StoreWindowClipRegion(config.mClipRegion);
30515:   }
30515:   return NS_OK;
30515: }
30515: 
 6118: // Invokes callback and ProcessEvent methods on Event Listener object
    1: NS_IMETHODIMP nsChildView::DispatchEvent(nsGUIEvent* event, nsEventStatus& aStatus)
    1: {
12976: #ifdef DEBUG
12976:   debug_DumpEvent(stdout, event->widget, event, nsCAutoString("something"), 0);
12976: #endif
12976: 
49150:   NS_ASSERTION(!(mTextInputHandler.IsIMEComposing() && NS_IS_KEY_EVENT(event)),
22410:     "Any key events should not be fired during IME composing");
22410: 
    1:   aStatus = nsEventStatus_eIgnore;
    1: 
29942:   nsCOMPtr<nsIWidget> kungFuDeathGrip = do_QueryInterface(mParentWidget ? mParentWidget : this);
    1:   if (mParentWidget) {
    1:     nsWindowType type;
    1:     mParentWidget->GetWindowType(type);
    1:     if (type == eWindowType_popup) {
 4173:       // use the parent popup's widget if there is no view
 4173:       void* clientData = nsnull;
 4173:       if (event->widget)
 4173:         event->widget->GetClientData(clientData);
10305:       if (!clientData)
    1:         event->widget = mParentWidget;
    1:     }
 4173:   }
    1: 
50639:   PRBool restoreIsDispatchPaint = mIsDispatchPaint;
50639:   mIsDispatchPaint = mIsDispatchPaint || event->eventStructType == NS_PAINT_EVENT;
50639: 
    1:   if (mEventCallback)
    1:     aStatus = (*mEventCallback)(event);
    1: 
50639:   mIsDispatchPaint = restoreIsDispatchPaint;
50639: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool nsChildView::DispatchWindowEvent(nsGUIEvent &event)
    1: {
    1:   nsEventStatus status;
    1:   DispatchEvent(&event, status);
    1:   return ConvertStatus(status);
    1: }
    1: 
    1: #pragma mark -
    1: 
    1: PRBool nsChildView::ReportDestroyEvent()
    1: {
    1:   nsGUIEvent event(PR_TRUE, NS_DESTROY, this);
    1:   event.time = PR_IntervalNow();
 3653:   return DispatchWindowEvent(event);
    1: }
    1: 
    1: PRBool nsChildView::ReportMoveEvent()
    1: {
    1:   nsGUIEvent moveEvent(PR_TRUE, NS_MOVE, this);
    1:   moveEvent.refPoint.x = mBounds.x;
    1:   moveEvent.refPoint.y = mBounds.y;
    1:   moveEvent.time       = PR_IntervalNow();
 3653:   return DispatchWindowEvent(moveEvent);
    1: }
    1: 
    1: PRBool nsChildView::ReportSizeEvent()
    1: {
    1:   nsSizeEvent sizeEvent(PR_TRUE, NS_SIZE, this);
    1:   sizeEvent.time        = PR_IntervalNow();
    1:   sizeEvent.windowSize  = &mBounds;
    1:   sizeEvent.mWinWidth   = mBounds.width;
    1:   sizeEvent.mWinHeight  = mBounds.height;
 3653:   return DispatchWindowEvent(sizeEvent);
    1: }
    1: 
    1: #pragma mark -
    1: 
25183: //    Return the offset between this child view and the screen.
25183: //    @return       -- widget origin in screen coordinates
25183: nsIntPoint nsChildView::WidgetToScreenOffset()
25183: {
25183:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
25183: 
25183:   NSPoint temp;
25183:   temp.x = 0;
25183:   temp.y = 0;
25183:   
25183:   // 1. First translate this point into window coords. The returned point is always in
    1:   //    bottom-left coordinates.
25183:   temp = [mView convertPoint:temp toView:nil];  
    1:   
    1:   // 2. We turn the window-coord rect's origin into screen (still bottom-left) coords.
32510:   temp = [[mView window] convertBaseToScreen:temp];
    1:   
    1:   // 3. Since we're dealing in bottom-left coords, we need to make it top-left coords
    1:   //    before we pass it back to Gecko.
25183:   FlipCocoaScreenCoordinate(temp);
25183:   
25183:   return nsIntPoint(NSToIntRound(temp.x), NSToIntRound(temp.y));
25183: 
25183:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(nsIntPoint(0,0));
    1: }
    1: 
    1: NS_IMETHODIMP nsChildView::CaptureRollupEvents(nsIRollupListener * aListener, 
36806:                                                nsIMenuRollup * aMenuRollup,
    1:                                                PRBool aDoCapture, 
    1:                                                PRBool aConsumeRollupEvent)
    1: {
    1:   // this never gets called, only top-level windows can be rollup widgets
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsChildView::SetTitle(const nsAString& title)
    1: {
 3653:   // child views don't have titles
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsChildView::GetAttention(PRInt32 aCycleCount)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   [NSApp requestUserAttention:NSInformationalRequest];
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
27993: /* static */
27993: PRBool nsChildView::DoHasPendingInputEvent()
27993: {
27993:   return sLastInputEventCount != GetCurrentInputEventCount(); 
27993: }
27993: 
27993: /* static */
27993: PRUint32 nsChildView::GetCurrentInputEventCount()
27993: {
27993:   // Can't use kCGAnyInputEventType because that updates too rarely for us (and
27993:   // always in increments of 30+!) and because apparently it's sort of broken
27993:   // on Tiger.  So just go ahead and query the counters we care about.
27993:   static const CGEventType eventTypes[] = {
27993:     kCGEventLeftMouseDown,
27993:     kCGEventLeftMouseUp,
27993:     kCGEventRightMouseDown,
27993:     kCGEventRightMouseUp,
27993:     kCGEventMouseMoved,
27993:     kCGEventLeftMouseDragged,
27993:     kCGEventRightMouseDragged,
27993:     kCGEventKeyDown,
27993:     kCGEventKeyUp,
27993:     kCGEventScrollWheel,
27993:     kCGEventTabletPointer,
27993:     kCGEventOtherMouseDown,
27993:     kCGEventOtherMouseUp,
27993:     kCGEventOtherMouseDragged
27993:   };
27993: 
27993:   PRUint32 eventCount = 0;
27993:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(eventTypes); ++i) {
27993:     eventCount +=
27993:       CGEventSourceCounterForEventType(kCGEventSourceStateCombinedSessionState,
27993:                                        eventTypes[i]);
27993:   }
27993:   return eventCount;
27993: }
27993: 
27993: /* static */
27993: void nsChildView::UpdateCurrentInputEventCount()
27993: {
27993:   sLastInputEventCount = GetCurrentInputEventCount();
27993: }
27993: 
27993: PRBool nsChildView::HasPendingInputEvent()
27993: {
27993:   return DoHasPendingInputEvent();
27993: }
    1: 
    1: #pragma mark -
    1: 
23538: // Force Input Method Editor to commit the uncommitted input
15919: // Note that this and other IME methods don't necessarily
    1: // get called on the same ChildView that input is going through.
    1: NS_IMETHODIMP nsChildView::ResetInputState()
    1: {
    1: #ifdef DEBUG_IME
    1:   NSLog(@"**** ResetInputState");
    1: #endif
    1: 
49150:   mTextInputHandler.CommitIMEComposition();
    1:   return NS_OK;
    1: }
    1: 
    1: // 'open' means that it can take non-ASCII chars
    1: NS_IMETHODIMP nsChildView::SetIMEOpenState(PRBool aState)
    1: {
  539: #ifdef DEBUG_IME
  539:   NSLog(@"**** SetIMEOpenState aState = %d", aState);
  539: #endif
  539: 
49150:   mTextInputHandler.SetIMEOpenState(aState);
  539:   return NS_OK;
    1: }
    1: 
    1: // 'open' means that it can take non-ASCII chars
    1: NS_IMETHODIMP nsChildView::GetIMEOpenState(PRBool* aState)
    1: {
  539: #ifdef DEBUG_IME
  539:   NSLog(@"**** GetIMEOpenState");
  539: #endif
  539: 
49150:   *aState = mTextInputHandler.IsIMEOpened();
  539:   return NS_OK;
  539: }
  539: 
58017: NS_IMETHODIMP nsChildView::SetInputMode(const IMEContext& aContext)
    1: {
  539: #ifdef DEBUG_IME
58017:   NSLog(@"**** SetInputMode mStatus = %d", aContext.mStatus);
  539: #endif
  539: 
58019:   mIMEContext = aContext;
58017:   switch (aContext.mStatus) {
15919:     case nsIWidget::IME_STATUS_ENABLED:
22788:     case nsIWidget::IME_STATUS_PLUGIN:
49150:       mTextInputHandler.SetASCIICapableOnly(PR_FALSE);
49150:       mTextInputHandler.EnableIME(PR_TRUE);
  539:       break;
15919:     case nsIWidget::IME_STATUS_DISABLED:
49150:       mTextInputHandler.SetASCIICapableOnly(PR_FALSE);
49150:       mTextInputHandler.EnableIME(PR_FALSE);
  539:       break;
15919:     case nsIWidget::IME_STATUS_PASSWORD:
49150:       mTextInputHandler.SetASCIICapableOnly(PR_TRUE);
49150:       mTextInputHandler.EnableIME(PR_FALSE);
  539:       break;
  539:     default:
  539:       NS_ERROR("not implemented!");
  539:   }
  539:   return NS_OK;
  539: }
  539: 
58019: NS_IMETHODIMP nsChildView::GetInputMode(IMEContext& aContext)
    1: {
  539: #ifdef DEBUG_IME
58019:   NSLog(@"**** GetInputMode");
  539: #endif
  539: 
58019:   aContext = mIMEContext;
  539:   return NS_OK;
    1: }
    1: 
    1: // Destruct and don't commit the IME composition string.
    1: NS_IMETHODIMP nsChildView::CancelIMEComposition()
    1: {
    1: #ifdef DEBUG_IME
    1:   NSLog(@"**** CancelIMEComposition");
    1: #endif
    1: 
49150:   mTextInputHandler.CancelIMEComposition();
    1:   return NS_OK;
    1: }
    1: 
 2475: NS_IMETHODIMP nsChildView::GetToggledKeyState(PRUint32 aKeyCode,
 2475:                                               PRBool* aLEDState)
 2475: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 2475: #ifdef DEBUG_IME
 2475:   NSLog(@"**** GetToggledKeyState");
 2475: #endif
 2475:   NS_ENSURE_ARG_POINTER(aLEDState);
 2475:   PRUint32 key;
 2475:   switch (aKeyCode) {
 2475:     case NS_VK_CAPS_LOCK:
 2475:       key = alphaLock;
 2475:       break;
 2475:     case NS_VK_NUM_LOCK:
 2475:       key = kEventKeyModifierNumLockMask;
 2475:       break;
 2475:     // Mac doesn't support SCROLL_LOCK state.
 2475:     default:
 2475:       return NS_ERROR_NOT_IMPLEMENTED;
 2475:   }
33068:   PRUint32 modifierFlags = ::GetCurrentKeyModifiers();
 2475:   *aLEDState = (modifierFlags & key) != 0;
 2475:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 2475: }
 2475: 
33316: NS_IMETHODIMP nsChildView::OnIMEFocusChange(PRBool aFocus)
33316: {
33316:   mTextInputHandler.OnFocusChangeInGecko(aFocus);
33316:   // XXX Return NS_ERROR_NOT_IMPLEMENTED, see bug 496360.
33316:   return NS_ERROR_NOT_IMPLEMENTED;
33316: }
33316: 
33316: NSView<mozView>* nsChildView::GetEditorView()
33316: {
33316:   NSView<mozView>* editorView = mView;
33316:   // We need to get editor's view. E.g., when the focus is in the bookmark
33316:   // dialog, the view is <panel> element of the dialog.  At this time, the key
33316:   // events are processed the parent window's view that has native focus.
33316:   nsQueryContentEvent textContent(PR_TRUE, NS_QUERY_TEXT_CONTENT, this);
33316:   textContent.InitForQueryTextContent(0, 0);
33316:   DispatchWindowEvent(textContent);
33316:   if (textContent.mSucceeded && textContent.mReply.mFocusedWidget) {
33316:     NSView<mozView>* view = static_cast<NSView<mozView>*>(
33316:       textContent.mReply.mFocusedWidget->GetNativeData(NS_NATIVE_WIDGET));
33316:     if (view)
33316:       editorView = view;
33316:   }
33316:   return editorView;
33316: }
33316: 
    1: #pragma mark -
    1: 
    1: gfxASurface*
    1: nsChildView::GetThebesSurface()
    1: {
    1:   if (!mTempThebesSurface) {
    1:     mTempThebesSurface = new gfxQuartzSurface(gfxSize(1, 1), gfxASurface::ImageFormatARGB32);
    1:   }
    1: 
 1556:   return mTempThebesSurface;
    1: }
    1: 
60224: void
60224: nsChildView::DrawOver(LayerManager* aManager, nsIntRect aRect)
60224: {
62870:   if (!ShowsResizeIndicator(nsnull)) {
62870:     return;
62870:   }
62870: 
62870:   nsRefPtr<LayerManagerOGL> manager(static_cast<LayerManagerOGL*>(aManager));
62870:   if (!manager) {
62870:     return;
62870:   }
62870: 
62870:   float bottomX = aRect.x + aRect.width;
62870:   float bottomY = aRect.y + aRect.height;
62870: 
62870:   nsRefPtr<gfxQuartzSurface> image =
62870:     new gfxQuartzSurface(gfxIntSize(15, 15), gfxASurface::ImageFormatARGB32);
62870:   CGContextRef ctx = image->GetCGContext();
62870: 
62870:   CGContextSetShouldAntialias(ctx, false);
62870:   CGPoint points[6];
62870:   points[0] = CGPointMake(13.0f, 4.0f);
62870:   points[1] = CGPointMake(3.0f, 14.0f);
62870:   points[2] = CGPointMake(13.0f, 8.0f);
62870:   points[3] = CGPointMake(7.0f, 14.0f);
62870:   points[4] = CGPointMake(13.0f, 12.0f);
62870:   points[5] = CGPointMake(11.0f, 14.0f);
62870:   CGContextSetRGBStrokeColor(ctx, 0.00f, 0.00f, 0.00f, 0.15f);
62870:   CGContextStrokeLineSegments(ctx, points, 6);
62870: 
62870:   points[0] = CGPointMake(13.0f, 5.0f);
62870:   points[1] = CGPointMake(4.0f, 14.0f);
62870:   points[2] = CGPointMake(13.0f, 9.0f);
62870:   points[3] = CGPointMake(8.0f, 14.0f);
62870:   points[4] = CGPointMake(13.0f, 13.0f);
62870:   points[5] = CGPointMake(12.0f, 14.0f);
62870:   CGContextSetRGBStrokeColor(ctx, 0.13f, 0.13f, 0.13f, 0.54f);
62870:   CGContextStrokeLineSegments(ctx, points, 6);
62870: 
62870:   points[0] = CGPointMake(13.0f, 6.0f);
62870:   points[1] = CGPointMake(5.0f, 14.0f);
62870:   points[2] = CGPointMake(13.0f, 10.0f);
62870:   points[3] = CGPointMake(9.0f, 14.0f);
62870:   points[5] = CGPointMake(13.0f, 13.9f);
62870:   points[4] = CGPointMake(13.0f, 14.0f);
62870:   CGContextSetRGBStrokeColor(ctx, 0.84f, 0.84f, 0.84f, 0.55f);
62870:   CGContextStrokeLineSegments(ctx, points, 6);
62870: 
62870:   GLuint tex = 0;
62870: 
62870:   ShaderProgramType shader =
62870: #ifdef MOZ_ENABLE_LIBXUL
62870:     manager->gl()->UploadSurfaceToTexture(image, nsIntRect(0, 0, 15, 15), tex);
62870: #else
62870:     manager->gl()->UploadSurfaceToTextureExternal(image, nsIntRect(0, 0, 15, 15), tex);
62870: #endif
62870: 
62870:   ColorTextureLayerProgram *program =
62870:     manager->GetColorTextureLayerProgram(shader);
62870:   program->Activate();
62870:   program->SetLayerQuadRect(nsIntRect(bottomX - 15,
62870:                                       bottomY - 15,
62870:                                       15,
62870:                                       15));
62870:   program->SetLayerTransform(gfx3DMatrix());
62870:   program->SetLayerOpacity(1.0);
62870:   program->SetRenderOffset(nsIntPoint(0,0));
62870:   program->SetTextureUnit(0);
62870: 
62870:   manager->BindAndDrawQuad(program);
62870:   manager->gl()->fDeleteTextures(1, &tex);
60224: }
60224: 
60289: void
60289: nsChildView::UpdateThemeGeometries(const nsTArray<ThemeGeometry>& aThemeGeometries)
60289: {
60289:   NSWindow* win = [mView window];
60289:   if (!win || ![win isKindOfClass:[ToolbarWindow class]])
60289:     return;
60289: 
60289:   float unifiedToolbarHeight = 0;
60289:   nsIntRect topPixelStrip(0, 0, [win frame].size.width, 1);
60289: 
60289:   for (PRUint32 i = 0; i < aThemeGeometries.Length(); ++i) {
60289:     const ThemeGeometry& g = aThemeGeometries[i];
60289:     if ((g.mWidgetType == NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR ||
60289:          g.mWidgetType == NS_THEME_TOOLBAR) &&
60289:         g.mRect.Contains(topPixelStrip)) {
60289:       unifiedToolbarHeight = g.mRect.YMost();
60289:     }
60289:   }
60289:   [(ToolbarWindow*)win setUnifiedToolbarHeight:unifiedToolbarHeight];
60289: }
60289: 
 6348: NS_IMETHODIMP
 6348: nsChildView::BeginSecureKeyboardInput()
 6348: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 6348:   nsresult rv = nsBaseWidget::BeginSecureKeyboardInput();
62281:   if (NS_SUCCEEDED(rv)) {
 6348:     ::EnableSecureEventInput();
62281:   }
 6348:   return rv;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 6348: }
 6348: 
 6348: NS_IMETHODIMP
 6348: nsChildView::EndSecureKeyboardInput()
 6348: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 6348:   nsresult rv = nsBaseWidget::EndSecureKeyboardInput();
62281:   if (NS_SUCCEEDED(rv)) {
 6348:     ::DisableSecureEventInput();
62281:   }
 6348:   return rv;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 6348: }
 6348: 
    1: #ifdef ACCESSIBILITY
42313: already_AddRefed<nsAccessible>
42313: nsChildView::GetDocumentAccessible()
42313: {
42313:   nsAccessible *docAccessible = nsnull;
42313:   if (mAccessible) {
42313:     CallQueryReferent(mAccessible.get(), &docAccessible);
42313:     return docAccessible;
42313:   }
42313: 
    1:   // need to fetch the accessible anew, because it has gone away.
    1:   nsEventStatus status;
    1:   nsAccessibleEvent event(PR_TRUE, NS_GETACCESSIBLE, this);
    1:   DispatchEvent(&event, status);
    1: 
    1:   // cache the accessible in our weak ptr
42313:   mAccessible =
42313:     do_GetWeakReference(static_cast<nsIAccessible*>(event.mAccessible));
42313: 
42313:   NS_IF_ADDREF(event.mAccessible);
42313:   return event.mAccessible;
    1: }
    1: #endif
    1: 
    1: #pragma mark -
    1: 
    1: @implementation ChildView
    1: 
    1: // globalDragPboard is non-null during native drag sessions that did not originate
    1: // in our native NSView (it is set in |draggingEntered:|). It is unset when the
    1: // drag session ends for this view, either with the mouse exiting or when a drop
    1: // occurs in this view.
    1: NSPasteboard* globalDragPboard = nil;
    1: 
34629: // gLastDragView and gLastDragMouseDownEvent are used to communicate information
34629: // to the drag service during drag invocation (starting a drag in from the view).
34629: // gLastDragView is only non-null while mouseDragged is on the call stack.
 6245: NSView* gLastDragView = nil;
34629: NSEvent* gLastDragMouseDownEvent = nil;
    1: 
22821: + (void)initialize
22821: {
22821:   static BOOL initialized = NO;
22821: 
22821:   if (!initialized) {
22821:     // Inform the OS about the types of services (from the "Services" menu)
22821:     // that we can handle.
26757: 
26757:     NSArray *sendTypes = [[NSArray alloc] initWithObjects:NSStringPboardType,NSHTMLPboardType,nil];
36983:     NSArray *returnTypes = [[NSArray alloc] initWithObjects:NSStringPboardType,NSHTMLPboardType,nil];
26757:     
22821:     [NSApp registerServicesMenuSendTypes:sendTypes returnTypes:returnTypes];
22821: 
26757:     [sendTypes release];
26757:     [returnTypes release];
26757: 
22821:     initialized = YES;
22821:   }
22821: }
22821: 
 6754: // initWithFrame:geckoChild:
 6754: - (id)initWithFrame:(NSRect)inFrame geckoChild:(nsChildView*)inChild
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   if ((self = [super initWithFrame:inFrame])) {
    1:     mGeckoChild = inChild;
    1:     mIsPluginView = NO;
32120: #ifndef NP_NO_CARBON
32120:     mPluginEventModel = NPEventModelCarbon;
32120: #else
32120:     mPluginEventModel = NPEventModelCocoa;
32120: #endif
54248: #ifndef NP_NO_QUICKDRAW
54248:     mPluginDrawingModel = NPDrawingModelQuickDraw;
54248: #else
54248:     mPluginDrawingModel = NPDrawingModelCoreGraphics;
54248: #endif
    1:     mCurKeyEvent = nil;
 8339:     mKeyDownHandled = PR_FALSE;
13042:     mKeyPressHandled = NO;
12429:     mKeyPressSent = NO;
43368:     mPendingDisplay = NO;
47792:     mBlockedLastMouseDown = NO;
    1: 
    1:     // initialization for NSTextInput
    1:     mMarkedRange.location = NSNotFound;
    1:     mMarkedRange.length = 0;
12429: 
13976:     mLastMouseDownEvent = nil;
47792:     mClickThroughMouseDownEvent = nil;
    1:     mDragService = nsnull;
15585: 
39656: #ifndef NP_NO_CARBON
15585:     mPluginTSMDoc = nil;
61078:     mPluginTSMInComposition = NO;
39656: #endif
43436:     mPluginComplexTextInputRequested = NO;
20793: 
61078:     mIgnoreNextKeyUpEvent = NO;
61078: 
20793:     mGestureState = eGestureState_None;
20793:     mCumulativeMagnification = 0.0;
20793:     mCumulativeRotation = 0.0;
32542: 
61878:     // We can't call forceRefreshOpenGL here because, in order to work around
61878:     // the bug, it seems we need to have a draw already happening. Therefore,
61878:     // we call it in drawRect:inContext:, when we know that a draw is in
61878:     // progress.
61878:     mDidForceRefreshOpenGL = NO;
61878: 
32542:     [self setFocusRingType:NSFocusRingTypeNone];
    1:   }
    1:   
    1:   // register for things we'll take from other applications
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView initWithFrame: registering drag types\n"));
    1:   [self registerForDraggedTypes:[NSArray arrayWithObjects:NSFilenamesPboardType,
    1:                                                           NSStringPboardType,
21404:                                                           NSHTMLPboardType,
    1:                                                           NSURLPboardType,
 3545:                                                           NSFilesPromisePboardType,
 1933:                                                           kWildcardPboardType,
 6273:                                                           kCorePboardType_url,
 6387:                                                           kCorePboardType_urld,
 6273:                                                           kCorePboardType_urln,
    1:                                                           nil]];
19344:   [[NSNotificationCenter defaultCenter] addObserver:self
41061:                                            selector:@selector(windowBecameMain:)
41061:                                                name:NSWindowDidBecomeMainNotification
41061:                                              object:nil];
41061:   [[NSNotificationCenter defaultCenter] addObserver:self
41061:                                            selector:@selector(windowResignedMain:)
41061:                                                name:NSWindowDidResignMainNotification
41061:                                              object:nil];
41061:   [[NSNotificationCenter defaultCenter] addObserver:self
20457:                                            selector:@selector(systemMetricsChanged)
19344:                                                name:NSControlTintDidChangeNotification
19344:                                              object:nil];
19492:   [[NSNotificationCenter defaultCenter] addObserver:self
20457:                                            selector:@selector(systemMetricsChanged)
19492:                                                name:NSSystemColorsDidChangeNotification
19492:                                              object:nil];
20457:   [[NSDistributedNotificationCenter defaultCenter] addObserver:self
20457:                                                       selector:@selector(systemMetricsChanged)
20457:                                                           name:@"AppleAquaScrollBarVariantChanged"
20457:                                                         object:nil
20457:                                             suspensionBehavior:NSNotificationSuspensionBehaviorDeliverImmediately]; 
41434:   [[NSNotificationCenter defaultCenter] addObserver:self
41434:                                            selector:@selector(_surfaceNeedsUpdate:)
41434:                                                name:NSViewGlobalFrameDidChangeNotification
41434:                                              object:self];
    1: 
    1:   return self;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
61878: // Work around bug 603134.
61878: // OS X has a bug that causes new OpenGL windows to only paint once or twice,
61878: // then stop painting altogether. By clearing the drawable from the GL context,
61878: // and then resetting the view to ourselves, we convince OS X to start updating
61878: // again.
61878: // This can cause a flash in new windows - bug 631339 - but it's very hard to
61878: // fix that while maintaining this workaround.
61878: - (void)forceRefreshOpenGL
61878: {
61878:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
61878: 
61878:   [mGLContext clearDrawable];
61878:   [mGLContext setView:self];
61878: 
61878:   NS_OBJC_END_TRY_ABORT_BLOCK;
61878: }
61878: 
    1: - (void)dealloc
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
43776:   [mGLContext release];
    1:   [mPendingDirtyRects release];
13976:   [mLastMouseDownEvent release];
47792:   [mClickThroughMouseDownEvent release];
34051:   ChildViewMouseTracker::OnDestroyView(self);
33318: #ifndef NP_NO_CARBON
15585:   if (mPluginTSMDoc)
15585:     ::DeleteTSMDocument(mPluginTSMDoc);
33318: #endif
    1: 
19344:   [[NSNotificationCenter defaultCenter] removeObserver:self];
20457:   [[NSDistributedNotificationCenter defaultCenter] removeObserver:self];
19344: 
 6013:   [super dealloc];    
 6013: 
32120: #ifndef NP_NO_QUICKDRAW
 6013:   // This sets the current port to _savePort.
 6013:   // todo: Only do if a Quickdraw plugin is present in the hierarchy!
 6013:   ::SetPort(NULL);
32120: #endif
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
41061: - (void)updatePluginTopLevelWindowStatus:(BOOL)hasMain
41061: {
41321:   if (!mGeckoChild)
41321:     return;
41321: 
41061:   nsGUIEvent pluginEvent(PR_TRUE, NS_NON_RETARGETED_PLUGIN_EVENT, mGeckoChild);
41061:   NPCocoaEvent cocoaEvent;
41061:   InitNPCocoaEvent(&cocoaEvent);
41061:   cocoaEvent.type = NPCocoaEventWindowFocusChanged;
41061:   cocoaEvent.data.focus.hasFocus = hasMain;
41061:   pluginEvent.pluginEvent = &cocoaEvent;
41061:   mGeckoChild->DispatchWindowEvent(pluginEvent);
41061: }
41061: 
41061: - (void)windowBecameMain:(NSNotification*)inNotification
41061: {
41061:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
41061: 
41061:   if (mIsPluginView && mPluginEventModel == NPEventModelCocoa) {
41061:     if ((NSWindow*)[inNotification object] == [self window]) {
41061:       [self updatePluginTopLevelWindowStatus:YES];
41061:     }
41061:   }
41061: 
41061:   NS_OBJC_END_TRY_ABORT_BLOCK;
41061: }
41061: 
41061: - (void)windowResignedMain:(NSNotification*)inNotification
41061: {
41061:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
41061: 
41061:   if (mIsPluginView && mPluginEventModel == NPEventModelCocoa) {
41061:     if ((NSWindow*)[inNotification object] == [self window]) {
41061:       [self updatePluginTopLevelWindowStatus:NO];
41061:     }
41061:   }
41061: 
41061:   NS_OBJC_END_TRY_ABORT_BLOCK;
41061: }
41061: 
    1: - (void)widgetDestroyed
    1: {
49150:   mGeckoChild->TextInputHandler()->OnDestroyView(self);
    1:   mGeckoChild = nsnull;
20736: 
 6789:   // Just in case we're destroyed abruptly and missed the draggingExited
 6789:   // or performDragOperation message.
 6789:   NS_IF_RELEASE(mDragService);
    1: }
    1: 
    1: // mozView method, return our gecko child view widget. Note this does not AddRef.
    1: - (nsIWidget*) widget
    1: {
 3233:   return static_cast<nsIWidget*>(mGeckoChild);
    1: }
    1: 
20457: - (void)systemMetricsChanged
19344: {
19344:   if (!mGeckoChild)
19344:     return;
19344: 
19344:   nsGUIEvent guiEvent(PR_TRUE, NS_THEMECHANGED, mGeckoChild);
19344:   mGeckoChild->DispatchWindowEvent(guiEvent);
19344: }
19344: 
    1: - (void)setNeedsPendingDisplay
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   mPendingFullDisplay = YES;
43368:   if (!mPendingDisplay) {
    1:     [self performSelector:@selector(processPendingRedraws) withObject:nil afterDelay:0];
43368:     mPendingDisplay = YES;
43368:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)setNeedsPendingDisplayInRect:(NSRect)invalidRect
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if (!mPendingDirtyRects)
    1:     mPendingDirtyRects = [[NSMutableArray alloc] initWithCapacity:1];
    1:   [mPendingDirtyRects addObject:[NSValue valueWithRect:invalidRect]];
43368:   if (!mPendingDisplay) {
    1:     [self performSelector:@selector(processPendingRedraws) withObject:nil afterDelay:0];
43368:     mPendingDisplay = YES;
43368:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: // Clears the queue of any pending invalides
    1: - (void)processPendingRedraws
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if (mPendingFullDisplay) {
    1:     [self setNeedsDisplay:YES];
    1:   }
43368:   else if (mPendingDirtyRects) {
    1:     unsigned int count = [mPendingDirtyRects count];
    1:     for (unsigned int i = 0; i < count; ++i) {
    1:       [self setNeedsDisplayInRect:[[mPendingDirtyRects objectAtIndex:i] rectValue]];
    1:     }
    1:   }
    1:   mPendingFullDisplay = NO;
43368:   mPendingDisplay = NO;
    1:   [mPendingDirtyRects release];
    1:   mPendingDirtyRects = nil;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
34054: - (void)setNeedsDisplayInRect:(NSRect)aRect
34054: {
34054:   [super setNeedsDisplayInRect:aRect];
34054: 
34054:   if ([[self window] isKindOfClass:[ToolbarWindow class]]) {
34054:     ToolbarWindow* window = (ToolbarWindow*)[self window];
34054:     if ([window drawsContentsIntoWindowFrame]) {
34054:       // Tell it to mark the rect in the titlebar as dirty.
34054:       NSView* borderView = [[window contentView] superview];
34054:       [window setTitlebarNeedsDisplayInRect:[self convertRect:aRect toView:borderView]];
34054:     }
34054:   }
34054: }
34054: 
    1: - (NSString*)description
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   return [NSString stringWithFormat:@"ChildView %p, gecko child %p, frame %@", self, mGeckoChild, NSStringFromRect([self frame])];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: // Make the origin of this view the topLeft corner (gecko origin) rather
    1: // than the bottomLeft corner (standard cocoa origin).
    1: - (BOOL)isFlipped
    1: {
    1:   return YES;
    1: }
    1: 
    1: - (BOOL)isOpaque
    1: {
54250:   return [[self window] isOpaque] && !mIsPluginView;
    1: }
    1: 
    1: -(void)setIsPluginView:(BOOL)aIsPlugin
    1: {
    1:   mIsPluginView = aIsPlugin;
    1: }
    1: 
  130: -(BOOL)isPluginView
    1: {
    1:   return mIsPluginView;
    1: }
    1: 
57526: // Are we processing an NSLeftMouseDown event that will fail to click through?
57526: // If so, we shouldn't focus or unfocus a plugin.
57526: - (BOOL)isInFailingLeftClickThrough
57526: {
57526:   if (!mGeckoChild)
57526:     return NO;
57526: 
57526:   if (!mClickThroughMouseDownEvent ||
57526:       [mClickThroughMouseDownEvent type] != NSLeftMouseDown)
57526:     return NO;
57526: 
57526:   BOOL retval =
57526:     !ChildViewMouseTracker::WindowAcceptsEvent([self window],
57526:                                                mClickThroughMouseDownEvent,
57526:                                                self, PR_TRUE);
57526: 
57526:   // If we return YES here, this will result in us not being focused,
57526:   // which will stop us receiving mClickThroughMouseDownEvent in
57526:   // [ChildView mouseDown:].  So we need to release and null-out
57526:   // mClickThroughMouseDownEvent here.
57526:   if (retval) {
57526:     [mClickThroughMouseDownEvent release];
57526:     mClickThroughMouseDownEvent = nil;
57526:   }
57526: 
57526:   return retval;
57526: }
57526: 
32120: - (void)setPluginEventModel:(NPEventModel)eventModel
32120: {
32120:   mPluginEventModel = eventModel;
32120: }
32120: 
54248: - (void)setPluginDrawingModel:(NPDrawingModel)drawingModel
54248: {
54248:   mPluginDrawingModel = drawingModel;
54248: }
54248: 
61078: - (NPEventModel)pluginEventModel
32120: {
32120:   return mPluginEventModel;
32019: }
32019: 
61078: - (NPDrawingModel)pluginDrawingModel
54248: {
54248:   return mPluginDrawingModel;
54248: }
54248: 
61078: #ifndef NP_NO_CARBON
61078: - (void)setPluginTSMInComposition:(BOOL)inComposition
61078: {
61078:   mPluginTSMInComposition = inComposition;
61078: }
61078: #endif
61078: 
 4208: - (void)sendFocusEvent:(PRUint32)eventType
 4208: {
 4208:   if (!mGeckoChild)
 4208:     return;
 4208: 
 4208:   nsEventStatus status = nsEventStatus_eIgnore;
 4208:   nsGUIEvent focusGuiEvent(PR_TRUE, eventType, mGeckoChild);
 4208:   focusGuiEvent.time = PR_IntervalNow();
 4208:   mGeckoChild->DispatchEvent(&focusGuiEvent, status);
 4208: }
 4208: 
    1: // We accept key and mouse events, so don't keep passing them up the chain. Allow
41321: // this to be a 'focused' widget for event dispatch.
    1: - (BOOL)acceptsFirstResponder
    1: {
    1:   return YES;
    1: }
    1: 
47792: // Accept mouse down events on background windows
47792: - (BOOL)acceptsFirstMouse:(NSEvent*)aEvent
47792: {
47792:   if (![[self window] isKindOfClass:[PopupWindow class]]) {
47792:     // We rely on this function to tell us that the mousedown was on a
47792:     // background window. Inside mouseDown we can't tell whether we were
47792:     // inactive because at that point we've already been made active.
47792:     // Unfortunately, acceptsFirstMouse is called for PopupWindows even when
47792:     // their parent window is active, so ignore this on them for now.
47792:     mClickThroughMouseDownEvent = [aEvent retain];
47792:   }
47792:   return YES;
47792: }
47792: 
21644: - (void)viewWillMoveToWindow:(NSWindow *)newWindow
21644: {
21644:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
21644: 
21644:   if (!newWindow)
21644:     HideChildPluginViews(self);
21644: 
21644:   [super viewWillMoveToWindow:newWindow];
21644: 
21644:   NS_OBJC_END_TRY_ABORT_BLOCK;
21644: }
21644: 
32510: - (void)viewDidMoveToWindow
32510: {
37446:   if (mPluginEventModel == NPEventModelCocoa &&
37446:       [self window] && [self isPluginView] && mGeckoChild) {
32510:     mGeckoChild->UpdatePluginPort();
32510:   }
32510: 
32510:   [super viewDidMoveToWindow];
32510: }
32510: 
    1: - (void)scrollRect:(NSRect)aRect by:(NSSize)offset
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   // Update any pending dirty rects to reflect the new scroll position
    1:   if (mPendingDirtyRects) {
    1:     unsigned int count = [mPendingDirtyRects count];
    1:     for (unsigned int i = 0; i < count; ++i) {
    1:       NSRect oldRect = [[mPendingDirtyRects objectAtIndex:i] rectValue];
    1:       NSRect newRect = NSOffsetRect(oldRect, offset.width, offset.height);
    1:       [mPendingDirtyRects replaceObjectAtIndex:i
    1:                                     withObject:[NSValue valueWithRect:newRect]];
    1:     }
    1:   }
    1:   [super scrollRect:aRect by:offset];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (BOOL)mouseDownCanMoveWindow
    1: {
    1:   return NO;
    1: }
    1: 
    1: - (void)lockFocus
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
32326: #ifndef NP_NO_QUICKDRAW
    1:   // Set the current GrafPort to a "safe" port before calling [NSQuickDrawView lockFocus],
    1:   // so that the NSQuickDrawView stashes a pointer to this known-good port internally.
    1:   // It will set the port back to this port on destruction.
 6013:   ::SetPort(NULL);  // todo: only do if a Quickdraw plugin is present in the hierarchy!
32326: #endif
32326: 
    1:   [super lockFocus];
11978: 
43776:   if (mGLContext) {
43776:     if ([mGLContext view] != self) {
43776:       [mGLContext setView:self];
43776:     }
43776: 
43776:     [mGLContext makeCurrentContext];
41434:   }
41434: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
41434: -(void)update
41434: {
43776:   if (mGLContext) {
43776:     [mGLContext update];
41434:   }
41434: }
41434: 
41434: - (void) _surfaceNeedsUpdate:(NSNotification*)notification
41434: {
41434:    [self update];
41434: }
41434: 
    1: // The display system has told us that a portion of our view is dirty. Tell
    1: // gecko to paint it
    1: - (void)drawRect:(NSRect)aRect
    1: {
34054:   CGContextRef cgContext = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
34054:   [self drawRect:aRect inContext:cgContext];
34054: 
35620:   // If we're a transparent window and our contents have changed, we need
34054:   // to make sure the shadow is updated to the new contents.
35620:   if ([[self window] isKindOfClass:[BaseWindow class]]) {
35620:     [(BaseWindow*)[self window] deferredInvalidateShadow];
35620:   }
34054: }
34054: 
55858: - (void)drawRect:(NSRect)aRect inTitlebarContext:(CGContextRef)aContext
55858: {
57913:   if (!mGeckoChild)
57913:     return;
57913: 
55858:   // Title bar drawing only works if we really draw into aContext, which only
55858:   // the basic layer manager will do.
55858:   nsBaseWidget::AutoUseBasicLayerManager setupLayerManager(mGeckoChild);
55858:   [self drawRect:aRect inContext:aContext];
55858: }
55858: 
34054: - (void)drawRect:(NSRect)aRect inContext:(CGContextRef)aContext
34054: {
    1:   PRBool isVisible;
19295:   if (!mGeckoChild || NS_FAILED(mGeckoChild->IsVisible(isVisible)) ||
31102:       !isVisible)
    1:     return;
    1: 
54249: #ifndef NP_NO_QUICKDRAW
54249:   if (mIsPluginView && mPluginDrawingModel == NPDrawingModelQuickDraw) {
54249:     mGeckoChild->PaintQD();
54249:     return;
54249:   }
54249: #endif
54249: 
54250:   // Don't ever draw non-QuickDraw plugin views explicitly; they'll be drawn as
54250:   // part of their parent widget.
54250:   if (mIsPluginView)
54250:     return;
54250: 
34054: #ifdef DEBUG_UPDATE
23738:   nsIntRect geckoBounds;
    1:   mGeckoChild->GetBounds(geckoBounds);
    1: 
    1:   fprintf (stderr, "---- Update[%p][%p] [%f %f %f %f] cgc: %p\n  gecko bounds: [%d %d %d %d]\n",
    1:            self, mGeckoChild,
34054:            aRect.origin.x, aRect.origin.y, aRect.size.width, aRect.size.height, aContext,
    1:            geckoBounds.x, geckoBounds.y, geckoBounds.width, geckoBounds.height);
    1: 
34054:   CGAffineTransform xform = CGContextGetCTM(aContext);
    1:   fprintf (stderr, "  xform in: [%f %f %f %f %f %f]\n", xform.a, xform.b, xform.c, xform.d, xform.tx, xform.ty);
    1: #endif
38805:   // Create the event so we can fill in its region
38805:   nsPaintEvent paintEvent(PR_TRUE, NS_PAINT, mGeckoChild);
    1: 
55859:   nsIntRect boundingRect =
55859:     nsIntRect(aRect.origin.x, aRect.origin.y, aRect.size.width, aRect.size.height);
    1:   const NSRect *rects;
32120:   NSInteger count, i;
34054:   [[NSView focusView] getRectsBeingDrawn:&rects count:&count];
25019:   if (count < MAX_RECTS_IN_REGION) {
    1:     for (i = 0; i < count; ++i) {
34054:       // Add the rect to the region.
34054:       const NSRect& r = [self convertRect:rects[i] fromView:[NSView focusView]];
38805:       paintEvent.region.Or(paintEvent.region,
38805:         nsIntRect(r.origin.x, r.origin.y, r.size.width, r.size.height));
    1:     }
55859:     paintEvent.region.And(paintEvent.region, boundingRect);
25019:   } else {
55859:     paintEvent.region = boundingRect;
34054:   }
    1: 
54250: #ifndef NP_NO_QUICKDRAW
54250:   // Subtract quickdraw plugin rectangles from the region
30516:   NSArray* subviews = [self subviews];
30516:   for (int i = 0; i < int([subviews count]); ++i) {
30516:     NSView* view = [subviews objectAtIndex:i];
30516:     if (![view isKindOfClass:[ChildView class]] || [view isHidden])
30516:       continue;
54250:     ChildView* cview = (ChildView*) view;
54250:     if ([cview isPluginView] && [cview pluginDrawingModel] == NPDrawingModelQuickDraw) {
30516:       NSRect frame = [view frame];
38805:       paintEvent.region.Sub(paintEvent.region,
38805:         nsIntRect(frame.origin.x, frame.origin.y, frame.size.width, frame.size.height));
30516:     }
54250:   }
54250: #endif
30516: 
58812:   if (mGeckoChild->GetLayerManager(nsnull)->GetBackendType() == LayerManager::LAYERS_OPENGL) {
58812:     LayerManagerOGL *manager = static_cast<LayerManagerOGL*>(mGeckoChild->GetLayerManager(nsnull));
41434:     manager->SetClippingRegion(paintEvent.region); 
43776:     if (!mGLContext) {
43776:       mGLContext = (NSOpenGLContext *)manager->gl()->GetNativeData(mozilla::gl::GLContext::NativeGLContext);
43776:       [mGLContext retain];
43776:     }
41434:     mGeckoChild->DispatchWindowEvent(paintEvent);
61878: 
61878:     // Force OpenGL to refresh the very first time we draw. This works around a
61878:     // Mac OS X bug that stops windows updating on OS X when we use OpenGL.
61878:     if (!mDidForceRefreshOpenGL) {
61878:       [self performSelector:@selector(forceRefreshOpenGL) withObject:nil afterDelay:0];
61878:       mDidForceRefreshOpenGL = YES;
61878:     }
61878: 
41434:     return;
41434:   }
41434: 
41434:   // Create Cairo objects.
41434:   NSSize bufferSize = [self bounds].size;
41434:   nsRefPtr<gfxQuartzSurface> targetSurface =
41434:     new gfxQuartzSurface(aContext, gfxSize(bufferSize.width, bufferSize.height));
60644:   targetSurface->SetAllowUseAsSource(PR_FALSE);
41434: 
41434:   nsRefPtr<gfxContext> targetContext = new gfxContext(targetSurface);
41434: 
34054:   // Set up the clip region.
38805:   nsIntRegionRectIterator iter(paintEvent.region);
38805:   targetContext->NewPath();
38805:   for (;;) {
38805:     const nsIntRect* r = iter.Next();
38805:     if (!r)
38805:       break;
38805:     targetContext->Rectangle(gfxRect(r->x, r->y, r->width, r->height));
38805:   }
34054:   targetContext->Clip();
34054: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
38805:   PRBool painted;
38805:   {
47746:     nsBaseWidget::AutoLayerManagerSetup
47746:       setupLayerManager(mGeckoChild, targetContext, BasicLayerManager::BUFFER_NONE);
38805:     painted = mGeckoChild->DispatchWindowEvent(paintEvent);
38805:   }
38805: 
34628:   if (!painted && [self isOpaque]) {
34628:     // Gecko refused to draw, but we've claimed to be opaque, so we have to
34628:     // draw something--fill with white.
34628:     CGContextSetRGBFillColor(aContext, 1, 1, 1, 1);
34628:     CGContextFillRect(aContext, CGRectMake(aRect.origin.x, aRect.origin.y,
34628:                                            aRect.size.width, aRect.size.height));
34628:   }
37194: 
    1:   // note that the cairo surface *MUST* be destroyed at this point,
    1:   // or bad things will happen (since we can't keep the cgContext around
    1:   // beyond this drawRect message handler)
    1: 
    1: #ifdef DEBUG_UPDATE
    1:   fprintf (stderr, "---- update done ----\n");
    1: 
    1: #if 0
34054:   CGContextSetRGBStrokeColor (aContext,
    1:                             ((((unsigned long)self) & 0xff)) / 255.0,
    1:                             ((((unsigned long)self) & 0xff00) >> 8) / 255.0,
    1:                             ((((unsigned long)self) & 0xff0000) >> 16) / 255.0,
    1:                             0.5);
    1: #endif 
34054:   CGContextSetRGBStrokeColor(aContext, 1, 0, 0, 0.8);
34054:   CGContextSetLineWidth(aContext, 4.0);
34054:   CGContextStrokeRect(aContext,
    1:                       CGRectMake(aRect.origin.x, aRect.origin.y, aRect.size.width, aRect.size.height));
    1: #endif
    1: }
    1: 
61287: - (void)releaseWidgets:(NSArray*)aWidgetArray
61287: {
61287:   if (!aWidgetArray) {
61287:     return;
61287:   }
61287:   NSInteger count = [aWidgetArray count];
61287:   for (NSInteger i = 0; i < count; ++i) {
61287:     NSNumber* pointer = (NSNumber*) [aWidgetArray objectAtIndex:i];
61287:     nsIWidget* widget = (nsIWidget*) [pointer unsignedIntegerValue];
61287:     NS_RELEASE(widget);
61287:   }
61287: }
61287: 
34856: - (void)viewWillDraw
34856: {
35619:   if (mGeckoChild) {
61287:     // The OS normally *will* draw our NSWindow, no matter what we do here.
61287:     // But Gecko can delete our parent widget(s) (along with mGeckoChild)
61287:     // while processing an NS_WILL_PAINT event, which closes our NSWindow and
61287:     // makes the OS throw an NSInternalInconsistencyException assertion when
61287:     // it tries to draw it.  Sometimes the OS also aborts the browser process.
61287:     // So we need to retain our parent(s) here and not release it/them until
61287:     // the next time through the main thread's run loop.  When we do this we
61287:     // also need to retain and release mGeckoChild, which holds a strong
61287:     // reference to us (otherwise we might have been deleted by the time
61287:     // releaseWidgets: is called on us).  See bug 550392.
61287:     nsIWidget* parent = mGeckoChild->GetParent();
61287:     if (parent) {
61287:       NSMutableArray* widgetArray = [NSMutableArray arrayWithCapacity:3];
61287:       while (parent) {
61287:         NS_ADDREF(parent);
61287:         [widgetArray addObject:[NSNumber numberWithUnsignedInteger:(NSUInteger)parent]];
61287:         parent = parent->GetParent();
61287:       }
61287:       NS_ADDREF(mGeckoChild);
61287:       [widgetArray addObject:[NSNumber numberWithUnsignedInteger:(NSUInteger)mGeckoChild]];
61287:       [self performSelector:@selector(releaseWidgets:)
61287:                  withObject:widgetArray
61287:                  afterDelay:0];
61287:     }
34856:     nsPaintEvent paintEvent(PR_TRUE, NS_WILL_PAINT, mGeckoChild);
34856:     mGeckoChild->DispatchWindowEvent(paintEvent);
34856:   }
35619:   [super viewWillDraw];
35619: }
34856: 
 3595: // Allows us to turn off setting up the clip region
    1: // before each drawRect. We already clip within gecko.
    1: - (BOOL)wantsDefaultClipping
    1: {
    1:   return NO;
    1: }
    1: 
    1: #if USE_CLICK_HOLD_CONTEXTMENU
    1: //
    1: // -clickHoldCallback:
    1: //
    1: // called from a timer two seconds after a mouse down to see if we should display
    1: // a context menu (click-hold). |anEvent| is the original mouseDown event. If we're
    1: // still in that mouseDown by this time, put up the context menu, otherwise just
    1: // fuhgeddaboutit. |anEvent| has been retained by the OS until after this callback
    1: // fires so we're ok there.
    1: //
    1: // This code currently messes in a bunch of edge cases (bugs 234751, 232964, 232314)
    1: // so removing it until we get it straightened out.
    1: //
    1: - (void)clickHoldCallback:(id)theEvent;
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if( theEvent == [NSApp currentEvent] ) {
    1:     // we're still in the middle of the same mousedown event here, activate
    1:     // click-hold context menu by triggering the right mouseDown action.
    1:     NSEvent* clickHoldEvent = [NSEvent mouseEventWithType:NSRightMouseDown
    1:                                                   location:[theEvent locationInWindow]
38441:                                              modifierFlags:[theEvent modifierFlags]
    1:                                                  timestamp:[theEvent timestamp]
    1:                                               windowNumber:[theEvent windowNumber]
    1:                                                    context:[theEvent context]
    1:                                                eventNumber:[theEvent eventNumber]
    1:                                                 clickCount:[theEvent clickCount]
    1:                                                   pressure:[theEvent pressure]];
    1:     [self rightMouseDown:clickHoldEvent];
    1:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: #endif
    1: 
 3574: // If we've just created a non-native context menu, we need to mark it as
 3574: // such and let the OS (and other programs) know when it opens and closes
 3574: // (this is how the OS knows to close other programs' context menus when
 3574: // ours open).  We send the initial notification here, but others are sent
 3574: // in nsCocoaWindow::Show().
 3574: - (void)maybeInitContextMenuTracking
 3574: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 3574:   if (!gRollupWidget)
 3574:     return;
12536: 
12536:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
12536:   if (prefs) {
12536:     PRBool useNativeContextMenus;
12536:     nsresult rv = prefs->GetBoolPref("ui.use_native_popup_windows", &useNativeContextMenus);
12536:     if (NS_SUCCEEDED(rv) && useNativeContextMenus)
12536:       return;
12536:   }
12536: 
 7637:   NSWindow *popupWindow = (NSWindow*)gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
 7637:   if (!popupWindow || ![popupWindow isKindOfClass:[PopupWindow class]])
 3574:     return;
 7637: 
 3574:   [[NSDistributedNotificationCenter defaultCenter]
 3574:     postNotificationName:@"com.apple.HIToolbox.beginMenuTrackingNotification"
 3574:                   object:@"org.mozilla.gecko.PopupWindow"];
 7637:   [(PopupWindow*)popupWindow setIsContextMenu:YES];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 3574: }
 3574: 
28346: // Returns true if the event should no longer be processed, false otherwise.
28346: // This does not return whether or not anything was rolled up.
 8345: - (BOOL)maybeRollup:(NSEvent*)theEvent
 8345: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
28346:   BOOL consumeEvent = NO;
28346: 
 8345:   if (gRollupWidget && gRollupListener) {
 8345:     NSWindow* currentPopup = static_cast<NSWindow*>(gRollupWidget->GetNativeData(NS_NATIVE_WINDOW));
 8779:     if (!nsCocoaUtils::IsEventOverWindow(theEvent, currentPopup)) {
28346:       // event is not over the rollup window, default is to roll up
28346:       PRBool shouldRollup = PR_TRUE;
28346: 
28346:       // check to see if scroll events should roll up the popup
 8345:       if ([theEvent type] == NSScrollWheel) {
28346:         gRollupListener->ShouldRollupOnMouseWheelEvent(&shouldRollup);
28346:         // always consume scroll events that aren't over the popup
28346:         consumeEvent = YES;
28346:       }
28346: 
 8345:       // if we're dealing with menus, we probably have submenus and
 8345:       // we don't want to rollup if the click is in a parent menu of
 8345:       // the current submenu
29148:       PRUint32 popupsToRollup = PR_UINT32_MAX;
36806:       if (gMenuRollup) {
10352:         nsAutoTArray<nsIWidget*, 5> widgetChain;
36806:         gMenuRollup->GetSubmenuWidgetChain(&widgetChain);
36806:         PRUint32 sameTypeCount = gMenuRollup->GetSubmenuWidgetChain(&widgetChain);
10352:         for (PRUint32 i = 0; i < widgetChain.Length(); i++) {
10352:           nsIWidget* widget = widgetChain[i];
 8345:           NSWindow* currWindow = (NSWindow*)widget->GetNativeData(NS_NATIVE_WINDOW);
 8779:           if (nsCocoaUtils::IsEventOverWindow(theEvent, currWindow)) {
42263:             // don't roll up if the mouse event occurred within a menu of the
42263:             // same type. If the mouse event occurred in a menu higher than
29148:             // that, roll up, but pass the number of popups to Rollup so
29148:             // that only those of the same type close up.
29148:             if (i < sameTypeCount) {
28346:               shouldRollup = PR_FALSE;
29148:             }
29148:             else {
29148:               popupsToRollup = sameTypeCount;
29148:             }
 8345:             break;
 8345:           }
28346:         }
28346:       }
28346: 
28346:       if (shouldRollup) {
29148:         gRollupListener->Rollup(popupsToRollup, nsnull);
28346:         consumeEvent = (BOOL)gConsumeRollupEvent;
28346:       }
28346:     }
28346:   }
28346: 
28346:   return consumeEvent;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 8345: }
 8345: 
20793: /*
20793:  * XXX - The swipeWithEvent, beginGestureWithEvent, magnifyWithEvent,
20793:  * rotateWithEvent, and endGestureWithEvent methods are part of a
20793:  * PRIVATE interface exported by nsResponder and reverse-engineering
20793:  * was necessary to obtain the methods' prototypes. Thus, Apple may
20793:  * change the interface in the future without notice.
20793:  *
20793:  * The prototypes were obtained from the following link:
20793:  * http://cocoadex.com/2008/02/nsevent-modifications-swipe-ro.html
20793:  */
20793: 
20793: - (void)swipeWithEvent:(NSEvent *)anEvent
20793: {
20793:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
20793: 
20793:   if (!anEvent || !mGeckoChild)
20793:     return;
20793: 
20793:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
20793: 
20793:   float deltaX = [anEvent deltaX];  // left=1.0, right=-1.0
20793:   float deltaY = [anEvent deltaY];  // up=1.0, down=-1.0
20793: 
20793:   // Setup the "swipe" event.
20793:   nsSimpleGestureEvent geckoEvent(PR_TRUE, NS_SIMPLE_GESTURE_SWIPE, mGeckoChild, 0, 0.0);
23284:   [self convertCocoaMouseEvent:anEvent toGeckoEvent:&geckoEvent];
20793: 
20793:   // Record the left/right direction.
20793:   if (deltaX > 0.0)
20793:     geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_LEFT;
20793:   else if (deltaX < 0.0)
20793:     geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_RIGHT;
20793: 
20793:   // Record the up/down direction.
20793:   if (deltaY > 0.0)
20793:     geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_UP;
20793:   else if (deltaY < 0.0)
20793:     geckoEvent.direction |= nsIDOMSimpleGestureEvent::DIRECTION_DOWN;
20793: 
20793:   // Send the event.
20793:   mGeckoChild->DispatchWindowEvent(geckoEvent);
20793: 
20793:   NS_OBJC_END_TRY_ABORT_BLOCK;
20793: }
20793: 
20793: - (void)beginGestureWithEvent:(NSEvent *)anEvent
20793: {
20793:   NS_ASSERTION(mGestureState == eGestureState_None, "mGestureState should be eGestureState_None");
20793: 
20793:   if (!anEvent)
20793:     return;
20793: 
20793:   mGestureState = eGestureState_StartGesture;
20793:   mCumulativeMagnification = 0;
20793:   mCumulativeRotation = 0.0;
20793: }
20793: 
20793: - (void)magnifyWithEvent:(NSEvent *)anEvent
20793: {
20793:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
20793: 
20793:   if (!anEvent || !mGeckoChild)
20793:     return;
20793: 
20793:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
20793: 
20793:   float deltaZ = [anEvent deltaZ];
20793: 
20793:   PRUint32 msg;
20793:   switch (mGestureState) {
20793:   case eGestureState_StartGesture:
20793:     msg = NS_SIMPLE_GESTURE_MAGNIFY_START;
20793:     mGestureState = eGestureState_MagnifyGesture;
20793:     break;
20793: 
20793:   case eGestureState_MagnifyGesture:
20793:     msg = NS_SIMPLE_GESTURE_MAGNIFY_UPDATE;
20793:     break;
20793: 
20793:   case eGestureState_None:
20793:   case eGestureState_RotateGesture:
20793:   default:
20793:     return;
20793:   }
20793: 
20793:   // Setup the event.
20793:   nsSimpleGestureEvent geckoEvent(PR_TRUE, msg, mGeckoChild, 0, deltaZ);
23284:   [self convertCocoaMouseEvent:anEvent toGeckoEvent:&geckoEvent];
20793: 
20793:   // Send the event.
20793:   mGeckoChild->DispatchWindowEvent(geckoEvent);
20793: 
20793:   // Keep track of the cumulative magnification for the final "magnify" event.
20793:   mCumulativeMagnification += deltaZ;
20793:   
20793:   NS_OBJC_END_TRY_ABORT_BLOCK;
20793: }
20793: 
20793: - (void)rotateWithEvent:(NSEvent *)anEvent
20793: {
20793:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
20793: 
20793:   if (!anEvent || !mGeckoChild)
20793:     return;
20793: 
20793:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
20793: 
20793:   float rotation = [anEvent rotation];
20793: 
20793:   PRUint32 msg;
20793:   switch (mGestureState) {
20793:   case eGestureState_StartGesture:
20793:     msg = NS_SIMPLE_GESTURE_ROTATE_START;
20793:     mGestureState = eGestureState_RotateGesture;
20793:     break;
20793: 
20793:   case eGestureState_RotateGesture:
20793:     msg = NS_SIMPLE_GESTURE_ROTATE_UPDATE;
20793:     break;
20793: 
20793:   case eGestureState_None:
20793:   case eGestureState_MagnifyGesture:
20793:   default:
20793:     return;
20793:   }
20793: 
20793:   // Setup the event.
20793:   nsSimpleGestureEvent geckoEvent(PR_TRUE, msg, mGeckoChild, 0, 0.0);
23284:   [self convertCocoaMouseEvent:anEvent toGeckoEvent:&geckoEvent];
20793:   geckoEvent.delta = -rotation;
20793:   if (rotation > 0.0) {
26874:     geckoEvent.direction = nsIDOMSimpleGestureEvent::ROTATION_COUNTERCLOCKWISE;
20793:   } else {
26874:     geckoEvent.direction = nsIDOMSimpleGestureEvent::ROTATION_CLOCKWISE;
20793:   }
20793: 
20793:   // Send the event.
20793:   mGeckoChild->DispatchWindowEvent(geckoEvent);
20793: 
20793:   // Keep track of the cumulative rotation for the final "rotate" event.
20793:   mCumulativeRotation += rotation;
20793: 
20793:   NS_OBJC_END_TRY_ABORT_BLOCK;
20793: }
20793: 
20793: - (void)endGestureWithEvent:(NSEvent *)anEvent
20793: {
20793:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
20793: 
20793:   if (!anEvent || !mGeckoChild) {
20793:     // Clear the gestures state if we cannot send an event.
20793:     mGestureState = eGestureState_None;
20793:     mCumulativeMagnification = 0.0;
20793:     mCumulativeRotation = 0.0;
20793:     return;
20793:   }
20793: 
20793:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
20793: 
20793:   switch (mGestureState) {
20793:   case eGestureState_MagnifyGesture:
20793:     {
20793:       // Setup the "magnify" event.
20793:       nsSimpleGestureEvent geckoEvent(PR_TRUE, NS_SIMPLE_GESTURE_MAGNIFY,
20793:                                       mGeckoChild, 0, mCumulativeMagnification);
23284:       [self convertCocoaMouseEvent:anEvent toGeckoEvent:&geckoEvent];
20793: 
20793:       // Send the event.
20793:       mGeckoChild->DispatchWindowEvent(geckoEvent);
20793:     }
20793:     break;
20793: 
20793:   case eGestureState_RotateGesture:
20793:     {
20793:       // Setup the "rotate" event.
20793:       nsSimpleGestureEvent geckoEvent(PR_TRUE, NS_SIMPLE_GESTURE_ROTATE, mGeckoChild, 0, 0.0);
23284:       [self convertCocoaMouseEvent:anEvent toGeckoEvent:&geckoEvent];
20793:       geckoEvent.delta = -mCumulativeRotation;
20793:       if (mCumulativeRotation > 0.0) {
26874:         geckoEvent.direction = nsIDOMSimpleGestureEvent::ROTATION_COUNTERCLOCKWISE;
20793:       } else {
26874:         geckoEvent.direction = nsIDOMSimpleGestureEvent::ROTATION_CLOCKWISE;
20793:       }
20793: 
20793:       // Send the event.
20793:       mGeckoChild->DispatchWindowEvent(geckoEvent);
20793:     }
20793:     break;
20793: 
20793:   case eGestureState_None:
20793:   case eGestureState_StartGesture:
20793:   default:
20793:     break;
20793:   }
20793: 
20793:   // Clear the gestures state.
20793:   mGestureState = eGestureState_None;
20793:   mCumulativeMagnification = 0.0;
20793:   mCumulativeRotation = 0.0;
20793: 
20793:   NS_OBJC_END_TRY_ABORT_BLOCK;
20793: }
20793: 
35622: // Returning NO from this method only disallows ordering on mousedown - in order
35622: // to prevent it for mouseup too, we need to call [NSApp preventWindowOrdering]
35622: // when handling the mousedown event.
35622: - (BOOL)shouldDelayWindowOrderingForEvent:(NSEvent*)aEvent
35622: {
35622:   // Always using system-provided window ordering for normal windows.
35622:   if (![[self window] isKindOfClass:[PopupWindow class]])
35622:     return NO;
35622: 
47792:   // Don't reorder when we don't have a parent window, like when we're a
47792:   // context menu or a tooltip.
47792:   return ![[self window] parentWindow];
35622: }
35622: 
    1: - (void)mouseDown:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
35622:   if ([self shouldDelayWindowOrderingForEvent:theEvent]) {
35622:     [NSApp preventWindowOrdering];
35622:   }
35622: 
13976:   // If we've already seen this event due to direct dispatch from menuForEvent:
13976:   // just bail; if not, remember it.
13976:   if (mLastMouseDownEvent == theEvent) {
13976:     [mLastMouseDownEvent release];
13976:     mLastMouseDownEvent = nil;
13976:     return;
13976:   }
13976:   else {
13976:     [mLastMouseDownEvent release];
13976:     mLastMouseDownEvent = [theEvent retain];
13976:   }
13976: 
34629:   [gLastDragMouseDownEvent release];
34629:   gLastDragMouseDownEvent = [theEvent retain];
34629: 
47792:   // We need isClickThrough because at this point the window we're in might
47792:   // already have become main, so the check for isMainWindow in
47792:   // WindowAcceptsEvent isn't enough. It also has to check isClickThrough.
47792:   BOOL isClickThrough = (theEvent == mClickThroughMouseDownEvent);
47792:   [mClickThroughMouseDownEvent release];
47792:   mClickThroughMouseDownEvent = nil;
47792: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
32976:   if ([self maybeRollup:theEvent] ||
47792:       !ChildViewMouseTracker::WindowAcceptsEvent([self window], theEvent, self, isClickThrough)) {
47792:     // Remember blocking because that means we want to block mouseup as well.
47792:     mBlockedLastMouseDown = YES;
    1:     return;
47792:   }
    1: 
    1: #if USE_CLICK_HOLD_CONTEXTMENU
    1:   // fire off timer to check for click-hold after two seconds. retains |theEvent|
    1:   [self performSelector:@selector(clickHoldCallback:) withObject:theEvent afterDelay:2.0];
    1: #endif
    1: 
  656:   // in order to send gecko events we'll need a gecko widget
  656:   if (!mGeckoChild)
  656:     return;
  656: 
38441:   NSUInteger modifierFlags = [theEvent modifierFlags];
32019: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_DOWN, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
47792: 
47792:   NSInteger clickCount = [theEvent clickCount];
47792:   if (mBlockedLastMouseDown && clickCount > 1) {
47792:     // Don't send a double click if the first click of the double click was
47792:     // blocked.
47792:     clickCount--;
47792:   }
47792:   geckoEvent.clickCount = clickCount;
47792: 
32019:   if (modifierFlags & NSControlKeyMask)
    1:     geckoEvent.button = nsMouseEvent::eRightButton;
    1:   else
    1:     geckoEvent.button = nsMouseEvent::eLeftButton;
    1: 
32019:   // Create event for use by plugins.
32019:   // This is going to our child view so we don't need to look up the destination
32019:   // event type.
32120: #ifndef NP_NO_CARBON
32019:   EventRecord carbonEvent;
32120:   if (mPluginEventModel == NPEventModelCarbon) {
32019:     carbonEvent.what = mouseDown;
32019:     carbonEvent.message = 0;
32019:     carbonEvent.when = ::TickCount();
32019:     ::GetGlobalMouse(&carbonEvent.where);
33068:     carbonEvent.modifiers = ::GetCurrentKeyModifiers();
34743:     geckoEvent.pluginEvent = &carbonEvent;
32019:   }
32120: #endif
32120:   NPCocoaEvent cocoaEvent;
32120:   if (mPluginEventModel == NPEventModelCocoa) {
32019:     InitNPCocoaEvent(&cocoaEvent);
32019:     NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
32019:     cocoaEvent.type = NPCocoaEventMouseDown;
32019:     cocoaEvent.data.mouse.modifierFlags = modifierFlags;
32019:     cocoaEvent.data.mouse.pluginX = point.x;
32019:     cocoaEvent.data.mouse.pluginY = point.y;
32019:     cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
47792:     cocoaEvent.data.mouse.clickCount = clickCount;
32019:     cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
32019:     cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
32019:     cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
34743:     geckoEvent.pluginEvent = &cocoaEvent;
32019:   }
    1: 
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
47792:   mBlockedLastMouseDown = NO;
    1: 
    1:   // XXX maybe call markedTextSelectionChanged:client: here?
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)mouseUp:(NSEvent *)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
47792:   if (!mGeckoChild || mBlockedLastMouseDown)
 2315:     return;
 2315: 
37413:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
37413: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
38441:   if ([theEvent modifierFlags] & NSControlKeyMask)
19247:     geckoEvent.button = nsMouseEvent::eRightButton;
19247:   else
19247:     geckoEvent.button = nsMouseEvent::eLeftButton;
 2315: 
32019:   // Create event for use by plugins.
32019:   // This is going to our child view so we don't need to look up the destination
32019:   // event type.
37413:   if (mIsPluginView) {
32120: #ifndef NP_NO_CARBON
32019:     EventRecord carbonEvent;
32120:     if (mPluginEventModel == NPEventModelCarbon) {
32019:       carbonEvent.what = mouseUp;
32019:       carbonEvent.message = 0;
32019:       carbonEvent.when = ::TickCount();
32019:       ::GetGlobalMouse(&carbonEvent.where);
33068:       carbonEvent.modifiers = ::GetCurrentKeyModifiers();
34743:       geckoEvent.pluginEvent = &carbonEvent;
32019:     }
32120: #endif
32120:     NPCocoaEvent cocoaEvent;
32120:     if (mPluginEventModel == NPEventModelCocoa) {
32019:       InitNPCocoaEvent(&cocoaEvent);
32019:       NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
32019:       cocoaEvent.type = NPCocoaEventMouseUp;
32019:       cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
32019:       cocoaEvent.data.mouse.pluginX = point.x;
32019:       cocoaEvent.data.mouse.pluginY = point.y;
32019:       cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
32019:       cocoaEvent.data.mouse.clickCount = [theEvent clickCount];
32019:       cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
32019:       cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
32019:       cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
34743:       geckoEvent.pluginEvent = &cocoaEvent;
32019:     }
37413:   }
    1: 
38852:   // This might destroy our widget (and null out mGeckoChild).
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
11978: 
37413:   // If our mouse-up event's location is over some other object (as might
37413:   // happen if it came at the end of a dragging operation), also send our
37413:   // Gecko frame a mouse-exit event.
38852:   if (mGeckoChild && mIsPluginView) {
37413: #ifndef NP_NO_CARBON
37413:     if (mPluginEventModel == NPEventModelCocoa)
37413: #endif
37413:     {
37413:       if (ChildViewMouseTracker::ViewForEvent(theEvent) != self) {
37413:         nsMouseEvent geckoExitEvent(PR_TRUE, NS_MOUSE_EXIT, nsnull, nsMouseEvent::eReal);
37413:         [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoExitEvent];
37413: 
37413:         NPCocoaEvent cocoaEvent;
37413:         InitNPCocoaEvent(&cocoaEvent);
37413:         NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
37413:         cocoaEvent.type = NPCocoaEventMouseExited;
37413:         cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
37413:         cocoaEvent.data.mouse.pluginX = point.x;
37413:         cocoaEvent.data.mouse.pluginY = point.y;
37413:         cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
37413:         cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
37413:         cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
37413:         cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
37413:         geckoExitEvent.pluginEvent = &cocoaEvent;
37413: 
37413:         mGeckoChild->DispatchWindowEvent(geckoExitEvent);
37413:       }
37413:     }
37413:   }
37413: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
32976: - (void)sendMouseEnterOrExitEvent:(NSEvent*)aEvent
32976:                             enter:(BOOL)aEnter
32976:                              type:(nsMouseEvent::exitType)aType
32976: {
32976:   if (!mGeckoChild)
32976:     return;
32976: 
32976:   NSPoint windowEventLocation = nsCocoaUtils::EventLocationForWindow(aEvent, [self window]);
32976:   NSPoint localEventLocation = [self convertPoint:windowEventLocation fromView:nil];
32976: 
32976:   PRUint32 msg = aEnter ? NS_MOUSE_ENTER : NS_MOUSE_EXIT;
32976:   nsMouseEvent event(PR_TRUE, msg, mGeckoChild, nsMouseEvent::eReal);
32976:   event.refPoint.x = nscoord((PRInt32)localEventLocation.x);
32976:   event.refPoint.y = nscoord((PRInt32)localEventLocation.y);
 2315: 
32019:   // Create event for use by plugins.
32976:   // This is going to our child view so we don't need to look up the destination
32976:   // event type.
43647: #ifndef NP_NO_CARBON  
34700:   EventRecord carbonEvent;
43647: #endif
34700:   NPCocoaEvent cocoaEvent;
34700:   if (mIsPluginView) {
32120: #ifndef NP_NO_CARBON  
32976:     if (mPluginEventModel == NPEventModelCarbon) {
32019:       carbonEvent.what = NPEventType_AdjustCursorEvent;
32019:       carbonEvent.message = 0;
32019:       carbonEvent.when = ::TickCount();
32019:       ::GetGlobalMouse(&carbonEvent.where);
33068:       carbonEvent.modifiers = ::GetCurrentKeyModifiers();
34743:       event.pluginEvent = &carbonEvent;
32019:     }
32120: #endif
32976:     if (mPluginEventModel == NPEventModelCocoa) {
32019:       InitNPCocoaEvent(&cocoaEvent);
32019:       cocoaEvent.type = ((msg == NS_MOUSE_ENTER) ? NPCocoaEventMouseEntered : NPCocoaEventMouseExited);
32976:       cocoaEvent.data.mouse.modifierFlags = [aEvent modifierFlags];
32019:       cocoaEvent.data.mouse.pluginX = 5;
32019:       cocoaEvent.data.mouse.pluginY = 5;
32976:       cocoaEvent.data.mouse.buttonNumber = [aEvent buttonNumber];
32976:       cocoaEvent.data.mouse.deltaX = [aEvent deltaX];
32976:       cocoaEvent.data.mouse.deltaY = [aEvent deltaY];
32976:       cocoaEvent.data.mouse.deltaZ = [aEvent deltaZ];
34743:       event.pluginEvent = &cocoaEvent;
32019:     }
34700:   }
 5762: 
32976:   event.exit = aType;
32976: 
32976:   nsEventStatus status; // ignored
32976:   mGeckoChild->DispatchEvent(&event, status);
32976: }
32976: 
32976: - (void)mouseMoved:(NSEvent*)aEvent
32976: {
32976:   ChildViewMouseTracker::MouseMoved(aEvent);
32976: }
32976: 
32976: - (void)handleMouseMoved:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 2315: 
32019:   // Create event for use by plugins.
32019:   // This is going to our child view so we don't need to look up the destination
32019:   // event type.
43647: #ifndef NP_NO_CARBON
34700:   EventRecord carbonEvent;
43647: #endif
34700:   NPCocoaEvent cocoaEvent;
34700:   if (mIsPluginView) {
32120: #ifndef NP_NO_CARBON
32120:     if (mPluginEventModel == NPEventModelCarbon) {
32019:       carbonEvent.what = NPEventType_AdjustCursorEvent;
32019:       carbonEvent.message = 0;
32019:       carbonEvent.when = ::TickCount();
32019:       ::GetGlobalMouse(&carbonEvent.where);
33068:       carbonEvent.modifiers = ::GetCurrentKeyModifiers();
34743:       geckoEvent.pluginEvent = &carbonEvent;
32019:     }
32120: #endif
32120:     if (mPluginEventModel == NPEventModelCocoa) {
32019:       InitNPCocoaEvent(&cocoaEvent);
32019:       NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
32019:       cocoaEvent.type = NPCocoaEventMouseMoved;
32019:       cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
32019:       cocoaEvent.data.mouse.pluginX = point.x;
32019:       cocoaEvent.data.mouse.pluginY = point.y;
32019:       cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
32019:       cocoaEvent.data.mouse.clickCount = [theEvent clickCount];
32019:       cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
32019:       cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
32019:       cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
34743:       geckoEvent.pluginEvent = &cocoaEvent;
32019:     }
34700:   }
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)mouseDragged:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
 6245:   gLastDragView = self;
    1: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 2315: 
32019:   // create event for use by plugins
37413:   if (mIsPluginView) {
32120: #ifndef NP_NO_CARBON
32019:     EventRecord carbonEvent;
32120:     if (mPluginEventModel == NPEventModelCarbon) {
32973:       carbonEvent.what = NPEventType_AdjustCursorEvent;
32019:       carbonEvent.message = 0;
32019:       carbonEvent.when = ::TickCount();
32019:       ::GetGlobalMouse(&carbonEvent.where);
33068:       carbonEvent.modifiers = btnState | ::GetCurrentKeyModifiers();
34743:       geckoEvent.pluginEvent = &carbonEvent;
32019:     }
32120: #endif
32120:     NPCocoaEvent cocoaEvent;
32120:     if (mPluginEventModel == NPEventModelCocoa) {
32019:       InitNPCocoaEvent(&cocoaEvent);
32019:       NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
32019:       cocoaEvent.type = NPCocoaEventMouseDragged;
32019:       cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
32019:       cocoaEvent.data.mouse.pluginX = point.x;
32019:       cocoaEvent.data.mouse.pluginY = point.y;
32019:       cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
32019:       cocoaEvent.data.mouse.clickCount = [theEvent clickCount];
32019:       cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
32019:       cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
32019:       cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
34743:       geckoEvent.pluginEvent = &cocoaEvent;
32019:     }
37413:   }
    1: 
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
    1: 
10305:   // Note, sending the above event might have destroyed our widget since we didn't retain.
10305:   // Fine so long as we don't access any local variables from here on.
 6245:   gLastDragView = nil;
34629: 
    1:   // XXX maybe call markedTextSelectionChanged:client: here?
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)rightMouseDown:(NSEvent *)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 8345:   [self maybeRollup:theEvent];
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   // The right mouse went down, fire off a right mouse down event to gecko
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_DOWN, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
    1:   geckoEvent.button = nsMouseEvent::eRightButton;
 2315:   geckoEvent.clickCount = [theEvent clickCount];
 2315: 
32019:   // create event for use by plugins
32120: #ifndef NP_NO_CARBON
32019:   EventRecord carbonEvent;
32120:   if (mPluginEventModel == NPEventModelCarbon) {
32019:     carbonEvent.what = mouseDown;
32019:     carbonEvent.message = 0;
32019:     carbonEvent.when = ::TickCount();
32019:     ::GetGlobalMouse(&carbonEvent.where);
32019:     carbonEvent.modifiers = controlKey;  // fake a context menu click
34743:     geckoEvent.pluginEvent = &carbonEvent;    
32019:   }
32120: #endif
32120:   NPCocoaEvent cocoaEvent;
32120:   if (mPluginEventModel == NPEventModelCocoa) {
32019:     InitNPCocoaEvent(&cocoaEvent);
32019:     NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
32019:     cocoaEvent.type = NPCocoaEventMouseDown;
32019:     cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
32019:     cocoaEvent.data.mouse.pluginX = point.x;
32019:     cocoaEvent.data.mouse.pluginY = point.y;
32019:     cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
32019:     cocoaEvent.data.mouse.clickCount = [theEvent clickCount];
32019:     cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
32019:     cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
32019:     cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
34743:     geckoEvent.pluginEvent = &cocoaEvent;
32019:   }
    1: 
18401:   PRBool handled = mGeckoChild->DispatchWindowEvent(geckoEvent);
10305:   if (!mGeckoChild)
10305:     return;
10305: 
    1:   if (!handled)
    1:     [super rightMouseDown:theEvent]; // let the superview do context menu stuff
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)rightMouseUp:(NSEvent *)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
    1:   geckoEvent.button = nsMouseEvent::eRightButton;
 2315:   geckoEvent.clickCount = [theEvent clickCount];
 2315: 
32019:   // create event for use by plugins
37413:   if (mIsPluginView) {
32120: #ifndef NP_NO_CARBON
32019:     EventRecord carbonEvent;
32120:     if (mPluginEventModel == NPEventModelCarbon) {
32019:       carbonEvent.what = mouseUp;
32019:       carbonEvent.message = 0;
32019:       carbonEvent.when = ::TickCount();
32019:       ::GetGlobalMouse(&carbonEvent.where);
32019:       carbonEvent.modifiers = controlKey;  // fake a context menu click
34743:       geckoEvent.pluginEvent = &carbonEvent;
32019:     }
32120: #endif
32120:     NPCocoaEvent cocoaEvent;
32120:     if (mPluginEventModel == NPEventModelCocoa) {
32019:       InitNPCocoaEvent(&cocoaEvent);
32019:       NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
32019:       cocoaEvent.type = NPCocoaEventMouseUp;
32019:       cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
32019:       cocoaEvent.data.mouse.pluginX = point.x;
32019:       cocoaEvent.data.mouse.pluginY = point.y;
32019:       cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
32019:       cocoaEvent.data.mouse.clickCount = [theEvent clickCount];
32019:       cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
32019:       cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
32019:       cocoaEvent.data.mouse.deltaZ = [theEvent deltaZ];
34743:       geckoEvent.pluginEvent = &cocoaEvent;
32019:     }
37413:   }
    1: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
 3574: - (void)rightMouseDragged:(NSEvent*)theEvent
 3574: {
 3574:   if (!mGeckoChild)
 3574:     return;
 3574: 
 3574:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
 3574:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 3574:   geckoEvent.button = nsMouseEvent::eRightButton;
 3574: 
 3574:   // send event into Gecko by going directly to the
 3574:   // the widget.
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 3574: }
 3574: 
    1: - (void)otherMouseDown:(NSEvent *)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
32976:   if ([self maybeRollup:theEvent] ||
47792:       !ChildViewMouseTracker::WindowAcceptsEvent([self window], theEvent, self))
 7637:     return;
 3574: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_DOWN, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 2315:   geckoEvent.button = nsMouseEvent::eMiddleButton;
    1:   geckoEvent.clickCount = [theEvent clickCount];
 2315: 
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)otherMouseUp:(NSEvent *)theEvent
    1: {
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
    1:   geckoEvent.button = nsMouseEvent::eMiddleButton;
    1: 
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
    1: }
    1: 
 3574: - (void)otherMouseDragged:(NSEvent*)theEvent
 3574: {
 3574:   if (!mGeckoChild)
 3574:     return;
 3574: 
 3574:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
 3574:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 3574:   geckoEvent.button = nsMouseEvent::eMiddleButton;
 3574: 
 3574:   // send event into Gecko by going directly to the
 3574:   // the widget.
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 3574: }
 3574: 
    1: // Handle an NSScrollWheel event for a single axis only.
    1: -(void)scrollWheel:(NSEvent*)theEvent forAxis:(enum nsMouseScrollEvent::nsMouseScrollFlags)inAxis
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
19319:   float scrollDelta = 0;
19319:   float scrollDeltaPixels = 0;
19319:   PRBool checkPixels = PR_TRUE;
19319: 
19319:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
19319:   if (prefs)
19319:     prefs->GetBoolPref("mousewheel.enable_pixel_scrolling", &checkPixels);
19319: 
19319:   // Calling deviceDeltaX or deviceDeltaY on theEvent will trigger a Cocoa
19319:   // assertion and an Objective-C NSInternalInconsistencyException if the
19319:   // underlying "Carbon" event doesn't contain pixel scrolling information.
19319:   // For these events, carbonEventKind is kEventMouseWheelMoved instead of
19319:   // kEventMouseScroll.
33236:   if (checkPixels) {
33236:     EventRef theCarbonEvent = [theEvent _eventRef];
33236:     UInt32 carbonEventKind = theCarbonEvent ? ::GetEventKind(theCarbonEvent) : 0;
38435:     if (carbonEventKind != kEventMouseScroll)
19319:       checkPixels = PR_FALSE;
33236:   }
33236: 
19319:   // Some scrolling devices supports pixel scrolling, e.g. a Macbook
19319:   // touchpad or a Mighty Mouse. On those devices, [event deviceDeltaX/Y]
19319:   // contains the amount of pixels to scroll. 
19319:   if (inAxis & nsMouseScrollEvent::kIsVertical) {
    1:     scrollDelta       = -[theEvent deltaY];
19319:     if (checkPixels && (scrollDelta == 0 || scrollDelta != floor(scrollDelta))) {
19319:       scrollDeltaPixels = -[theEvent deviceDeltaY];
19319:     }
19319:   } else if (inAxis & nsMouseScrollEvent::kIsHorizontal) {
    1:     scrollDelta       = -[theEvent deltaX];
19319:     if (checkPixels && (scrollDelta == 0 || scrollDelta != floor(scrollDelta))) {
19319:       scrollDeltaPixels = -[theEvent deviceDeltaX];
19319:     }
19319:   } else {
10305:     return; // caller screwed up
19319:   }
19319: 
19319:   BOOL hasPixels = (scrollDeltaPixels != 0);
19319: 
19319:   if (!hasPixels && scrollDelta == 0)
19319:     // No sense in firing off a Gecko event.
    1:      return;
    1: 
57004:   BOOL isMomentumScroll = [theEvent respondsToSelector:@selector(_scrollPhase)] &&
57004:                           [theEvent _scrollPhase] != 0;
57004: 
19319:   if (scrollDelta != 0) {
19319:     // Send the line scroll event.
    1:     nsMouseScrollEvent geckoEvent(PR_TRUE, NS_MOUSE_SCROLL, nsnull);
 2315:     [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
    1:     geckoEvent.scrollFlags |= inAxis;
    1: 
19319:     if (hasPixels)
19319:       geckoEvent.scrollFlags |= nsMouseScrollEvent::kHasPixels;
19319: 
57004:     if (isMomentumScroll)
57004:       geckoEvent.scrollFlags |= nsMouseScrollEvent::kIsMomentum;
57004: 
    1:     // Gecko only understands how to scroll by an integer value. Using floor
    1:     // and ceil is better than truncating the fraction, especially when
    1:     // |delta| < 1.
    1:     if (scrollDelta < 0)
    1:       geckoEvent.delta = (PRInt32)floorf(scrollDelta);
    1:     else
    1:       geckoEvent.delta = (PRInt32)ceilf(scrollDelta);
    1: 
34678:     NPCocoaEvent cocoaEvent;
34678:     if (mPluginEventModel == NPEventModelCocoa) {
34678:       InitNPCocoaEvent(&cocoaEvent);
34678:       NSPoint point = [self convertPoint:[theEvent locationInWindow] fromView:nil];
34678:       cocoaEvent.type = NPCocoaEventScrollWheel;
34678:       cocoaEvent.data.mouse.modifierFlags = [theEvent modifierFlags];
34678:       cocoaEvent.data.mouse.pluginX = point.x;
34678:       cocoaEvent.data.mouse.pluginY = point.y;
34678:       cocoaEvent.data.mouse.buttonNumber = [theEvent buttonNumber];
34678:       cocoaEvent.data.mouse.clickCount = 0;
34678:       if (inAxis & nsMouseScrollEvent::kIsHorizontal)
34678:         cocoaEvent.data.mouse.deltaX = [theEvent deltaX];
34678:       else
34678:         cocoaEvent.data.mouse.deltaX = 0.0;
34678:       if (inAxis & nsMouseScrollEvent::kIsVertical)
34678:         cocoaEvent.data.mouse.deltaY = [theEvent deltaY];
34678:       else
34678:         cocoaEvent.data.mouse.deltaY = 0.0;
34678:       cocoaEvent.data.mouse.deltaZ = 0.0;
34743:       geckoEvent.pluginEvent = &cocoaEvent;
34678:     }
34678: 
14024:     nsAutoRetainCocoaObject kungFuDeathGrip(self);
    1:     mGeckoChild->DispatchWindowEvent(geckoEvent);
10305:     if (!mGeckoChild)
10305:       return;
    1: 
33236: #ifndef NP_NO_CARBON
    1:     // dispatch scroll wheel carbon event for plugins
33236:     if (mPluginEventModel == NPEventModelCarbon) {
    1:       EventRef theEvent;
21081:       OSStatus err = ::CreateEvent(NULL,
    1:                                    kEventClassMouse,
    1:                                    kEventMouseWheelMoved,
    1:                                    TicksToEventTime(TickCount()),
    1:                                    kEventAttributeUserEvent,
    1:                                    &theEvent);
    1:       if (err == noErr) {
    1:         EventMouseWheelAxis axis;
    1:         if (inAxis & nsMouseScrollEvent::kIsVertical)
    1:           axis = kEventMouseWheelAxisY;
    1:         else if (inAxis & nsMouseScrollEvent::kIsHorizontal)
    1:           axis = kEventMouseWheelAxisX;
    1:         
    1:         SetEventParameter(theEvent,
    1:                           kEventParamMouseWheelAxis,
    1:                           typeMouseWheelAxis,
    1:                           sizeof(EventMouseWheelAxis),
    1:                           &axis);
    1:         
    1:         SInt32 delta = (SInt32)-geckoEvent.delta;
    1:         SetEventParameter(theEvent,
    1:                           kEventParamMouseWheelDelta,
    1:                           typeLongInteger,
    1:                           sizeof(SInt32),
    1:                           &delta);
    1:         
    1:         Point mouseLoc;
    1:         ::GetGlobalMouse(&mouseLoc);
    1:         SetEventParameter(theEvent,
    1:                           kEventParamMouseLocation,
    1:                           typeQDPoint,
    1:                           sizeof(Point),
    1:                           &mouseLoc);
    1:         
 1016:         ::SendEventToEventTarget(theEvent, GetWindowEventTarget((WindowRef)[[self window] windowRef]));
    1:         ReleaseEvent(theEvent);
    1:       }
    1:     }
33236: #endif
19319:   }
19319: 
19319:   if (hasPixels) {
19319:     // Send the pixel scroll event.
19319:     nsMouseScrollEvent geckoEvent(PR_TRUE, NS_MOUSE_PIXEL_SCROLL, nsnull);
19319:     [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
19319:     geckoEvent.scrollFlags |= inAxis;
57004:     if (isMomentumScroll)
57004:       geckoEvent.scrollFlags |= nsMouseScrollEvent::kIsMomentum;
19319:     geckoEvent.delta = NSToIntRound(scrollDeltaPixels);
19319:     nsAutoRetainCocoaObject kungFuDeathGrip(self);
19319:     mGeckoChild->DispatchWindowEvent(geckoEvent);
19319:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: -(void)scrollWheel:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 8345:   if ([self maybeRollup:theEvent])
 4358:     return;
    1: 
10305:   if (!mGeckoChild)
10305:     return;
10305: 
    1:   // It's possible for a single NSScrollWheel event to carry both useful
    1:   // deltaX and deltaY, for example, when the "wheel" is a trackpad.
    1:   // NSMouseScrollEvent can only carry one axis at a time, so the system
    1:   // event will be split into two Gecko events if necessary.
    1:   [self scrollWheel:theEvent forAxis:nsMouseScrollEvent::kIsVertical];
10305:   if (!mGeckoChild)
10305:     return;
    1:   [self scrollWheel:theEvent forAxis:nsMouseScrollEvent::kIsHorizontal];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: -(NSMenu*)menuForEvent:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 2462:   if (!mGeckoChild || [self isPluginView])
    1:     return nil;
    1: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 8345:   [self maybeRollup:theEvent];
10305:   if (!mGeckoChild)
10305:     return nil;
 4842: 
13976:   // Cocoa doesn't always dispatch a mouseDown: for a control-click event,
13976:   // depends on what we return from menuForEvent:. Gecko always expects one
13976:   // and expects the mouse down event before the context menu event, so
13976:   // get that event sent first if this is a left mouse click.
13976:   if ([theEvent type] == NSLeftMouseDown) {
13976:     [self mouseDown:theEvent];
13976:     if (!mGeckoChild)
13609:       return nil;
13976:   }
    1: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_CONTEXTMENU, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
    1:   geckoEvent.button = nsMouseEvent::eRightButton;
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
10305:   if (!mGeckoChild)
10305:     return nil;
 3574: 
12394:   [self maybeInitContextMenuTracking];
12394: 
    1:   // Go up our view chain to fetch the correct menu to return.
    1:   return [self contextMenu];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (NSMenu*)contextMenu
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   NSView* superView = [self superview];
    1:   if ([superView respondsToSelector:@selector(contextMenu)])
    1:     return [(NSView<mozView>*)superView contextMenu];
    1: 
    1:   return nil;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
33318: #ifndef NP_NO_CARBON
    1: static PRBool ConvertUnicodeToCharCode(PRUnichar inUniChar, unsigned char* outChar)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
    1:   UnicodeToTextInfo converterInfo;
    1:   TextEncoding      systemEncoding;
    1:   Str255            convertedString;
    1:   OSStatus          err;
    1:   
    1:   *outChar = 0;
    1:   
    1:   err = ::UpgradeScriptInfoToTextEncoding(smSystemScript, kTextLanguageDontCare, kTextRegionDontCare, NULL, &systemEncoding);
    1:   if (err != noErr)
    1:     return PR_FALSE;
    1:   
    1:   err = ::CreateUnicodeToTextInfoByEncoding(systemEncoding, &converterInfo);
    1:   if (err != noErr)
    1:     return PR_FALSE;
    1:   
    1:   err = ::ConvertFromUnicodeToPString(converterInfo, sizeof(PRUnichar), &inUniChar, convertedString);
    1:   if (err != noErr)
    1:     return PR_FALSE;
    1: 
    1:   *outChar = convertedString[1];
    1:   ::DisposeUnicodeToTextInfo(&converterInfo);
    1:   return PR_TRUE;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(PR_FALSE);
    1: }
33318: #endif // NP_NO_CARBON
    1: 
32019: static void ConvertCocoaKeyEventToNPCocoaEvent(NSEvent* cocoaEvent, NPCocoaEvent& pluginEvent, PRUint32 keyType = 0)
32019: {
34781:   InitNPCocoaEvent(&pluginEvent);
32019:   NSEventType nativeType = [cocoaEvent type];
32019:   switch (nativeType) {
32019:     case NSKeyDown:
32019:       pluginEvent.type = NPCocoaEventKeyDown;
32019:       break;
32019:     case NSKeyUp:
32019:       pluginEvent.type = NPCocoaEventKeyUp;
32019:       break;
32019:     case NSFlagsChanged:
32019:       pluginEvent.type = NPCocoaEventFlagsChanged;
32019:       break;
32019:     default:
32019:       printf("Asked to convert key event of unknown type to Cocoa plugin event!");
32019:   }
32019:   pluginEvent.data.key.modifierFlags = [cocoaEvent modifierFlags];
32019:   // don't try to access character data for flags changed events, it will raise an exception
32019:   if (nativeType != NSFlagsChanged) {
32019:     pluginEvent.data.key.characters = (NPNSString*)[cocoaEvent characters];
32019:     pluginEvent.data.key.charactersIgnoringModifiers = (NPNSString*)[cocoaEvent charactersIgnoringModifiers];
32019:     pluginEvent.data.key.isARepeat = [cocoaEvent isARepeat];
32019:     pluginEvent.data.key.keyCode = [cocoaEvent keyCode];
32019:   }
32019: }
32019: 
33318: #ifndef NP_NO_CARBON
29388: static void ConvertCocoaKeyEventToCarbonEvent(NSEvent* cocoaEvent, EventRecord& pluginEvent, PRUint32 keyType = 0)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:     UInt32 charCode = 0;
    1:     if ([cocoaEvent type] == NSFlagsChanged) {
29388:       pluginEvent.what = keyType == NS_KEY_DOWN ? keyDown : keyUp;
    1:     } else {
13547:       if ([[cocoaEvent characters] length] > 0)
    1:         charCode = [[cocoaEvent characters] characterAtIndex:0];
    1:       if ([cocoaEvent type] == NSKeyDown)
29388:         pluginEvent.what = [cocoaEvent isARepeat] ? autoKey : keyDown;
    1:       else
29388:         pluginEvent.what = keyUp;
    1:     }
    1: 
    1:     if (charCode >= 0x0080) {
    1:         switch (charCode) {
    1:         case NSUpArrowFunctionKey:
    1:             charCode = kUpArrowCharCode;
    1:             break;
    1:         case NSDownArrowFunctionKey:
    1:             charCode = kDownArrowCharCode;
    1:             break;
    1:         case NSLeftArrowFunctionKey:
    1:             charCode = kLeftArrowCharCode;
    1:             break;
    1:         case NSRightArrowFunctionKey:
    1:             charCode = kRightArrowCharCode;
    1:             break;
    1:         default:
    1:             unsigned char convertedCharCode;
    1:             if (ConvertUnicodeToCharCode(charCode, &convertedCharCode))
    1:               charCode = convertedCharCode;
    1:             //NSLog(@"charcode is %d, converted to %c, char is %@", charCode, convertedCharCode, [cocoaEvent characters]);
    1:             break;
    1:         }
    1:     }
38441:     pluginEvent.message = (charCode & 0x00FF) | ([cocoaEvent keyCode] << 8);
29388:     pluginEvent.when = ::TickCount();
29388:     ::GetGlobalMouse(&pluginEvent.where);
33068:     pluginEvent.modifiers = ::GetCurrentKeyModifiers();
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
33318: #endif // NP_NO_CARBON
    1: 
 7164: static PRBool IsPrintableChar(PRUnichar aChar)
 7164: {
 7164:   return (aChar >= 0x20 && aChar <= 0x7E) || aChar >= 0xA0;
 7164: }
 7164: 
 6825: static PRUint32 GetGeckoKeyCodeFromChar(PRUnichar aChar)
 6825: {
 6946:   // We don't support the key code for non-ASCII characters
 7164:   if (aChar > 0x7E)
 6946:     return 0;
 6946: 
 7164:   if (aChar >= 'a' && aChar <= 'z') // lowercase
 7164:     return PRUint32(toupper(aChar));
 7164:   else if (aChar >= 'A' && aChar <= 'Z') // uppercase
 7164:     return PRUint32(aChar);
 7164:   else if (aChar >= '0' && aChar <= '9')
 7164:     return PRUint32(aChar - '0' + NS_VK_0);
 7164: 
 6825:   switch (aChar)
 6825:   {
 6825:     case kReturnCharCode:
 6825:     case kEnterCharCode:
 6825:     case '\n':
 6825:       return NS_VK_RETURN;
 6825:     case '{':
 6825:     case '[':
 6825:       return NS_VK_OPEN_BRACKET;
 6825:     case '}':
 6825:     case ']':
 6825:       return NS_VK_CLOSE_BRACKET;
 6825:     case '\'':
 6825:     case '"':
 6825:       return NS_VK_QUOTE;
 6825: 
 6825:     case '\\':                  return NS_VK_BACK_SLASH;
 6825:     case ' ':                   return NS_VK_SPACE;
 6825:     case ';':                   return NS_VK_SEMICOLON;
 6825:     case '=':                   return NS_VK_EQUALS;
 6825:     case ',':                   return NS_VK_COMMA;
 6825:     case '.':                   return NS_VK_PERIOD;
 6825:     case '/':                   return NS_VK_SLASH;
 6825:     case '`':                   return NS_VK_BACK_QUOTE;
 6825:     case '\t':                  return NS_VK_TAB;
 7164:     case '-':                   return NS_VK_SUBTRACT;
 7164:     case '+':                   return NS_VK_ADD;
 6825: 
 6825:     default:
 7164:       if (!IsPrintableChar(aChar))
 6825:         NS_WARNING("GetGeckoKeyCodeFromChar has failed.");
 6825:       return 0;
 6825:     }
 7164: }
 6825: 
    1: static PRUint32 ConvertMacToGeckoKeyCode(UInt32 keyCode, nsKeyEvent* aKeyEvent, NSString* characters)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
    1:   PRUint32 geckoKeyCode = 0;
    1: 
    1:   switch (keyCode)
    1:   {
    1:     // modifiers. We don't get separate events for these
    1:     case kEscapeKeyCode:        geckoKeyCode = NS_VK_ESCAPE;         break;
 7636:     case kRCommandKeyCode:
    1:     case kCommandKeyCode:       geckoKeyCode = NS_VK_META;           break;
 7636:     case kRShiftKeyCode:
    1:     case kShiftKeyCode:         geckoKeyCode = NS_VK_SHIFT;          break;
    1:     case kCapsLockKeyCode:      geckoKeyCode = NS_VK_CAPS_LOCK;      break;
 7636:     case kRControlKeyCode:
    1:     case kControlKeyCode:       geckoKeyCode = NS_VK_CONTROL;        break;
 7636:     case kROptionKeyCode:
    1:     case kOptionkeyCode:        geckoKeyCode = NS_VK_ALT;            break;
    1:     case kClearKeyCode:         geckoKeyCode = NS_VK_CLEAR;          break;
    1: 
    1:     // function keys
    1:     case kF1KeyCode:            geckoKeyCode = NS_VK_F1;             break;
    1:     case kF2KeyCode:            geckoKeyCode = NS_VK_F2;             break;
    1:     case kF3KeyCode:            geckoKeyCode = NS_VK_F3;             break;
    1:     case kF4KeyCode:            geckoKeyCode = NS_VK_F4;             break;
    1:     case kF5KeyCode:            geckoKeyCode = NS_VK_F5;             break;
    1:     case kF6KeyCode:            geckoKeyCode = NS_VK_F6;             break;
    1:     case kF7KeyCode:            geckoKeyCode = NS_VK_F7;             break;
    1:     case kF8KeyCode:            geckoKeyCode = NS_VK_F8;             break;
    1:     case kF9KeyCode:            geckoKeyCode = NS_VK_F9;             break;
    1:     case kF10KeyCode:           geckoKeyCode = NS_VK_F10;            break;
    1:     case kF11KeyCode:           geckoKeyCode = NS_VK_F11;            break;
    1:     case kF12KeyCode:           geckoKeyCode = NS_VK_F12;            break;
    1:     // case kF13KeyCode:           geckoKeyCode = NS_VK_F13;            break;    // clash with the 3 below
    1:     // case kF14KeyCode:           geckoKeyCode = NS_VK_F14;            break;
    1:     // case kF15KeyCode:           geckoKeyCode = NS_VK_F15;            break;
    1:     case kPauseKeyCode:         geckoKeyCode = NS_VK_PAUSE;          break;
    1:     case kScrollLockKeyCode:    geckoKeyCode = NS_VK_SCROLL_LOCK;    break;
    1:     case kPrintScreenKeyCode:   geckoKeyCode = NS_VK_PRINTSCREEN;    break;
    1: 
    1:     // keypad
    1:     case kKeypad0KeyCode:       geckoKeyCode = NS_VK_NUMPAD0;        break;
    1:     case kKeypad1KeyCode:       geckoKeyCode = NS_VK_NUMPAD1;        break;
    1:     case kKeypad2KeyCode:       geckoKeyCode = NS_VK_NUMPAD2;        break;
    1:     case kKeypad3KeyCode:       geckoKeyCode = NS_VK_NUMPAD3;        break;
    1:     case kKeypad4KeyCode:       geckoKeyCode = NS_VK_NUMPAD4;        break;
    1:     case kKeypad5KeyCode:       geckoKeyCode = NS_VK_NUMPAD5;        break;
    1:     case kKeypad6KeyCode:       geckoKeyCode = NS_VK_NUMPAD6;        break;
    1:     case kKeypad7KeyCode:       geckoKeyCode = NS_VK_NUMPAD7;        break;
    1:     case kKeypad8KeyCode:       geckoKeyCode = NS_VK_NUMPAD8;        break;
    1:     case kKeypad9KeyCode:       geckoKeyCode = NS_VK_NUMPAD9;        break;
    1: 
    1:     case kKeypadMultiplyKeyCode:  geckoKeyCode = NS_VK_MULTIPLY;     break;
    1:     case kKeypadAddKeyCode:       geckoKeyCode = NS_VK_ADD;          break;
    1:     case kKeypadSubtractKeyCode:  geckoKeyCode = NS_VK_SUBTRACT;     break;
    1:     case kKeypadDecimalKeyCode:   geckoKeyCode = NS_VK_DECIMAL;      break;
    1:     case kKeypadDivideKeyCode:    geckoKeyCode = NS_VK_DIVIDE;       break;
    1: 
    1:     // these may clash with forward delete and help
    1:     case kInsertKeyCode:        geckoKeyCode = NS_VK_INSERT;         break;
    1:     case kDeleteKeyCode:        geckoKeyCode = NS_VK_DELETE;         break;
    1: 
    1:     case kBackspaceKeyCode:     geckoKeyCode = NS_VK_BACK;           break;
    1:     case kTabKeyCode:           geckoKeyCode = NS_VK_TAB;            break;
    1:     case kHomeKeyCode:          geckoKeyCode = NS_VK_HOME;           break;
    1:     case kEndKeyCode:           geckoKeyCode = NS_VK_END;            break;
    1:     case kPageUpKeyCode:        geckoKeyCode = NS_VK_PAGE_UP;        break;
    1:     case kPageDownKeyCode:      geckoKeyCode = NS_VK_PAGE_DOWN;      break;
    1:     case kLeftArrowKeyCode:     geckoKeyCode = NS_VK_LEFT;           break;
    1:     case kRightArrowKeyCode:    geckoKeyCode = NS_VK_RIGHT;          break;
    1:     case kUpArrowKeyCode:       geckoKeyCode = NS_VK_UP;             break;
    1:     case kDownArrowKeyCode:     geckoKeyCode = NS_VK_DOWN;           break;
 2959:     case kVK_ANSI_1:            geckoKeyCode = NS_VK_1;              break;
 2959:     case kVK_ANSI_2:            geckoKeyCode = NS_VK_2;              break;
 2959:     case kVK_ANSI_3:            geckoKeyCode = NS_VK_3;              break;
 2959:     case kVK_ANSI_4:            geckoKeyCode = NS_VK_4;              break;
 2959:     case kVK_ANSI_5:            geckoKeyCode = NS_VK_5;              break;
 2959:     case kVK_ANSI_6:            geckoKeyCode = NS_VK_6;              break;
 2959:     case kVK_ANSI_7:            geckoKeyCode = NS_VK_7;              break;
 2959:     case kVK_ANSI_8:            geckoKeyCode = NS_VK_8;              break;
 2959:     case kVK_ANSI_9:            geckoKeyCode = NS_VK_9;              break;
 2959:     case kVK_ANSI_0:            geckoKeyCode = NS_VK_0;              break;
    1: 
    1:     default:
    1:       // if we haven't gotten the key code already, look at the char code
26689:       if ([characters length])
26689:         geckoKeyCode = GetGeckoKeyCodeFromChar([characters characterAtIndex:0]);
    1:   }
    1: 
    1:   return geckoKeyCode;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0);
    1: }
    1: 
    1: static PRBool IsSpecialGeckoKey(UInt32 macKeyCode)
    1: {
    1:   PRBool  isSpecial;
    1:   
    1:   // this table is used to determine which keys are special and should not generate a charCode
    1:   switch (macKeyCode)
    1:   {
    1:     // modifiers - we don't get separate events for these yet
    1:     case kEscapeKeyCode:
    1:     case kShiftKeyCode:
 7636:     case kRShiftKeyCode:
    1:     case kCommandKeyCode:
 7636:     case kRCommandKeyCode:
    1:     case kCapsLockKeyCode:
    1:     case kControlKeyCode:
 7636:     case kRControlKeyCode:
    1:     case kOptionkeyCode:
 7636:     case kROptionKeyCode:
    1:     case kClearKeyCode:
    1:       
    1:       // function keys
    1:     case kF1KeyCode:
    1:     case kF2KeyCode:
    1:     case kF3KeyCode:
    1:     case kF4KeyCode:
    1:     case kF5KeyCode:
    1:     case kF6KeyCode:
    1:     case kF7KeyCode:
    1:     case kF8KeyCode:
    1:     case kF9KeyCode:
    1:     case kF10KeyCode:
    1:     case kF11KeyCode:
    1:     case kF12KeyCode:
    1:     case kPauseKeyCode:
    1:     case kScrollLockKeyCode:
    1:     case kPrintScreenKeyCode:
    1:       
    1:     case kInsertKeyCode:
    1:     case kDeleteKeyCode:
    1:     case kTabKeyCode:
    1:     case kBackspaceKeyCode:
    1:       
    1:     case kHomeKeyCode:
    1:     case kEndKeyCode:
    1:     case kPageUpKeyCode:
    1:     case kPageDownKeyCode:
    1:     case kLeftArrowKeyCode:
    1:     case kRightArrowKeyCode:
    1:     case kUpArrowKeyCode:
    1:     case kDownArrowKeyCode:
    1:     case kReturnKeyCode:
    1:     case kEnterKeyCode:
    1:     case kPowerbookEnterKeyCode:
    1:       isSpecial = PR_TRUE;
    1:       break;
    1:       
    1:     default:
    1:       isSpecial = PR_FALSE;
    1:       break;
    1:   }
    1:   
    1:   return isSpecial;
    1: }
    1: 
13738: static PRBool IsNormalCharInputtingEvent(const nsKeyEvent& aEvent)
13738: {
13738:   // this is not character inputting event, simply.
50708:   if (!aEvent.isChar || !aEvent.charCode || aEvent.isMeta)
13738:     return PR_FALSE;
13738:   // if this is unicode char inputting event, we don't need to check
13738:   // ctrl/alt/command keys
13738:   if (aEvent.charCode > 0x7F)
13738:     return PR_TRUE;
13738:   // ASCII chars should be inputted without ctrl/alt/command keys
50708:   return !aEvent.isControl && !aEvent.isAlt;
13738: }
13738: 
 2315: // Basic conversion for cocoa to gecko events, common to all conversions.
 2315: // Note that it is OK for inEvent to be nil.
 2315: - (void) convertGenericCocoaEvent:(NSEvent*)inEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2315:   NS_ASSERTION(outGeckoEvent, "convertGenericCocoaEvent:toGeckoEvent: requires non-null outGeckoEvent");
 2315:   if (!outGeckoEvent)
 2315:     return;
 2315: 
 2315:   outGeckoEvent->widget = [self widget];
 2315:   outGeckoEvent->time = PR_IntervalNow();
 2315: 
 2315:   if (inEvent) {
38441:     unsigned int modifiers = [inEvent modifierFlags];
 2315:     outGeckoEvent->isShift   = ((modifiers & NSShiftKeyMask) != 0);
 2315:     outGeckoEvent->isControl = ((modifiers & NSControlKeyMask) != 0);
 2315:     outGeckoEvent->isAlt     = ((modifiers & NSAlternateKeyMask) != 0);
 2315:     outGeckoEvent->isMeta    = ((modifiers & NSCommandKeyMask) != 0);
 2315:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: - (void) convertCocoaMouseEvent:(NSEvent*)aMouseEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
47792:   NS_ASSERTION(outGeckoEvent, "convertCocoaMouseEvent:toGeckoEvent: requires non-null aoutGeckoEvent");
47792:   if (!outGeckoEvent)
 2315:     return;
 2315: 
 2315:   [self convertGenericCocoaEvent:aMouseEvent toGeckoEvent:outGeckoEvent];
 2315: 
 2315:   // convert point to view coordinate system
32510:   NSPoint locationInWindow = nsCocoaUtils::EventLocationForWindow(aMouseEvent, [self window]);
31655:   NSPoint localPoint = [self convertPoint:locationInWindow fromView:nil];
 3233:   outGeckoEvent->refPoint.x = static_cast<nscoord>(localPoint.x);
 3233:   outGeckoEvent->refPoint.y = static_cast<nscoord>(localPoint.y);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
32302: // #define DEBUG_KB 1
32302: 
15029: static PRUint32
15067: UCKeyTranslateToUnicode(const UCKeyboardLayout* aHandle, UInt32 aKeyCode, UInt32 aModifiers,
15029:                         UInt32 aKbType)
15029: {
15029: #ifdef DEBUG_KB
15029:   NSLog(@"**** UCKeyTranslateToUnicode: aHandle: %p, aKeyCode: %X, aModifiers: %X, aKbType: %X",
15029:         aHandle, aKeyCode, aModifiers, aKbType);
15029:   PRBool isShift = aModifiers & shiftKey;
15029:   PRBool isCtrl = aModifiers & controlKey;
15029:   PRBool isOpt = aModifiers & optionKey;
15029:   PRBool isCmd = aModifiers & cmdKey;
15029:   PRBool isCL = aModifiers & alphaLock;
15029:   PRBool isNL = aModifiers & kEventKeyModifierNumLockMask;
15029:   NSLog(@"        Shift: %s, Ctrl: %s, Opt: %s, Cmd: %s, CapsLock: %s, NumLock: %s",
15029:         isShift ? "ON" : "off", isCtrl ? "ON" : "off", isOpt ? "ON" : "off",
15029:         isCmd ? "ON" : "off", isCL ? "ON" : "off", isNL ? "ON" : "off");
15029: #endif
15029:   UInt32 deadKeyState = 0;
15029:   UniCharCount len;
15029:   UniChar chars[5];
15029:   OSStatus err = ::UCKeyTranslate(aHandle, aKeyCode,
15029:                                   kUCKeyActionDown, aModifiers >> 8,
15029:                                   aKbType, kUCKeyTranslateNoDeadKeysMask,
15029:                                   &deadKeyState, 5, &len, chars);
15029:   PRUint32 ch = (err == noErr && len == 1) ? PRUint32(chars[0]) : 0;
15029: #ifdef DEBUG_KB
15029:   NSLog(@"       result: %X(%C)", ch, ch > ' ' ? ch : ' ');
15029: #endif
15029:   return ch;
15029: }
15029: 
15029: struct KeyTranslateData {
15029:   KeyTranslateData() {
15029:     mUchr.mLayout = nsnull;
15029:     mUchr.mKbType = 0;
38435:   }
15029: 
15029:   struct {
15067:     const UCKeyboardLayout* mLayout;
15029:     UInt32 mKbType;
15029:   } mUchr;
15029: };
15029: 
15029: static PRUint32
15029: GetUniCharFromKeyTranslate(KeyTranslateData& aData,
15029:                            UInt32 aKeyCode, UInt32 aModifiers)
15029: {
15029:   if (aData.mUchr.mLayout) {
15029:     return UCKeyTranslateToUnicode(aData.mUchr.mLayout, aKeyCode, aModifiers,
15029:                                    aData.mUchr.mKbType);
15029:   }
38435: 
15029:   return 0;
15029: }
15029: 
15072: static PRUint32
15072: GetUSLayoutCharFromKeyTranslate(UInt32 aKeyCode, UInt32 aModifiers)
15072: {
32302:   static const UCKeyboardLayout* sUSLayout = nsnull;
32302:   if (!sUSLayout) {
32302:     nsTISInputSource tis("com.apple.keylayout.US");
32302:     sUSLayout = tis.GetUCKeyboardLayout();
32302:     NS_ENSURE_TRUE(sUSLayout, 0);
32302:   }
32302: 
32302:   UInt32 kbType = 40; // ANSI, don't use actual layout
32302:   return UCKeyTranslateToUnicode(sUSLayout, aKeyCode, aModifiers, kbType);
15072: }
15029: 
 2315: - (void) convertCocoaKeyEvent:(NSEvent*)aKeyEvent toGeckoEvent:(nsKeyEvent*)outGeckoEvent
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2315:   NS_ASSERTION(aKeyEvent && outGeckoEvent, "convertCocoaKeyEvent:toGeckoEvent: requires non-null arguments");
 2315:   if (!aKeyEvent || !outGeckoEvent)
 2315:     return;
 2315: 
 2315:   [self convertGenericCocoaEvent:aKeyEvent toGeckoEvent:outGeckoEvent];
 2315: 
 2315:   // coords for key events are always 0,0
    1:   outGeckoEvent->refPoint.x = outGeckoEvent->refPoint.y = 0;
    1: 
    1:   // Initialize whether or not we are using charCodes to false.
    1:   outGeckoEvent->isChar = PR_FALSE;
    1: 
    1:   // Check to see if the message is a key press that does not involve
    1:   // one of our special key codes.
19704:   if (outGeckoEvent->message == NS_KEY_PRESS &&
38441:       !IsSpecialGeckoKey([aKeyEvent keyCode])) {
 2315:     outGeckoEvent->isChar = PR_TRUE; // this is not a special key
    1:     
    1:     outGeckoEvent->charCode = 0;
12429:     outGeckoEvent->keyCode  = 0; // not set for key press events
    1:     
14328:     NSString* chars = [aKeyEvent characters];
14328:     if ([chars length] > 0)
14328:       outGeckoEvent->charCode = [chars characterAtIndex:0];
    1:     
    1:     // convert control-modified charCode to raw charCode (with appropriate case)
    1:     if (outGeckoEvent->isControl && outGeckoEvent->charCode <= 26)
    1:       outGeckoEvent->charCode += (outGeckoEvent->isShift) ? ('A' - 1) : ('a' - 1);
    1: 
15704:     // Accel and access key handling needs to know the characters that this
15704:     // key produces with Shift up or down.  So, provide this information
15704:     // when Ctrl or Command or Alt is pressed.
14491:     if (outGeckoEvent->isControl || outGeckoEvent->isMeta ||
14491:         outGeckoEvent->isAlt) {
15029:       KeyTranslateData kt;
15067: 
32302:       PRBool isRomanKeyboardLayout;
38435: 
32302:       nsTISInputSource tis;
32302:       if (gOverrideKeyboardLayout.mOverrideEnabled) {
32302:         tis.InitByLayoutID(gOverrideKeyboardLayout.mKeyboardLayout);
32302:       } else {
32302:         tis.InitByCurrentKeyboardLayout();
32302:       }
32302:       kt.mUchr.mLayout = tis.GetUCKeyboardLayout();
32302:       isRomanKeyboardLayout = tis.IsASCIICapable();
15029: 
15097:       // If a keyboard layout override is set, we also need to force the
15097:       // keyboard type to something ANSI to avoid test failures on machines
15097:       // with JIS keyboards (since the pair of keyboard layout and physical
15097:       // keyboard type form the actual key layout).  This assumes that the
15097:       // test setting the override was written assuming an ANSI keyboard.
15097:       if (kt.mUchr.mLayout)
15097:         kt.mUchr.mKbType = gOverrideKeyboardLayout.mOverrideEnabled ? 40 : ::LMGetKbdType();
15097: 
38441:       UInt32 key = [aKeyEvent keyCode];
15079: 
15079:       // Caps lock and num lock modifier state:
15079:       UInt32 lockState = 0;
38441:       if ([aKeyEvent modifierFlags] & NSAlphaShiftKeyMask)
15079:         lockState |= alphaLock;
38441:       if ([aKeyEvent modifierFlags] & NSNumericPadKeyMask)
15079:         lockState |= kEventKeyModifierNumLockMask;
15072: 
15029:       // normal chars
15079:       PRUint32 unshiftedChar = GetUniCharFromKeyTranslate(kt, key, lockState);
15081:       UInt32 shiftLockMod = shiftKey | lockState;
15079:       PRUint32 shiftedChar = GetUniCharFromKeyTranslate(kt, key, shiftLockMod);
15079: 
15079:       // characters generated with Cmd key
15079:       // XXX we should remove CapsLock state, which changes characters from
15079:       //     Latin to Cyrillic with Russian layout on 10.4 only when Cmd key
15072:       //     is pressed.
15080:       UInt32 numState = (lockState & ~alphaLock); // only num lock state
15079:       PRUint32 uncmdedChar = GetUniCharFromKeyTranslate(kt, key, numState);
15096:       UInt32 shiftNumMod = numState | shiftKey;
15096:       PRUint32 uncmdedShiftChar =
15096:                  GetUniCharFromKeyTranslate(kt, key, shiftNumMod);
15079:       PRUint32 uncmdedUSChar = GetUSLayoutCharFromKeyTranslate(key, numState);
15080:       UInt32 cmdNumMod = cmdKey | numState;
15079:       PRUint32 cmdedChar = GetUniCharFromKeyTranslate(kt, key, cmdNumMod);
15080:       UInt32 cmdShiftNumMod = shiftKey | cmdNumMod;
15079:       PRUint32 cmdedShiftChar =
15079:         GetUniCharFromKeyTranslate(kt, key, cmdShiftNumMod);
15029: 
15029:       // Is the keyboard layout changed by Cmd key?
15029:       // E.g., Arabic, Russian, Hebrew, Greek and Dvorak-QWERTY.
15072:       PRBool isCmdSwitchLayout = uncmdedChar != cmdedChar;
15029:       // Is the keyboard layout for Latin, but Cmd key switches the layout?
15029:       // I.e., Dvorak-QWERTY
32302:       PRBool isDvorakQWERTY = isCmdSwitchLayout && isRomanKeyboardLayout;
15029: 
15029:       // If the current keyboard is not Dvorak-QWERTY or Cmd is not pressed,
15029:       // we should append unshiftedChar and shiftedChar for handling the
15704:       // normal characters.  These are the characters that the user is most
15704:       // likely to associate with this key.
14328:       if ((unshiftedChar || shiftedChar) &&
15029:           (!outGeckoEvent->isMeta || !isDvorakQWERTY)) {
14328:         nsAlternativeCharCode altCharCodes(unshiftedChar, shiftedChar);
14328:         outGeckoEvent->alternativeCharCodes.AppendElement(altCharCodes);
14328:       }
15072: 
15704:       // Most keyboard layouts provide the same characters in the NSEvents
15704:       // with Command+Shift as with Command.  However, with Command+Shift we
15704:       // want the character on the second level.  e.g. With a US QWERTY
15704:       // layout, we want "?" when the "/","?" key is pressed with
15704:       // Command+Shift.
15096: 
15096:       // On a German layout, the OS gives us '/' with Cmd+Shift+SS(eszett)
15096:       // even though Cmd+SS is 'SS' and Shift+'SS' is '?'.  This '/' seems
15096:       // like a hack to make the Cmd+"?" event look the same as the Cmd+"?"
15096:       // event on a US keyboard.  The user thinks they are typing Cmd+"?", so
15096:       // we'll prefer the "?" character, replacing charCode with shiftedChar
15096:       // when Shift is pressed.  However, in case there is a layout where the
15096:       // character unique to Cmd+Shift is the character that the user expects,
15096:       // we'll send it as an alternative char.
15096:       PRBool hasCmdShiftOnlyChar =
15096:         cmdedChar != cmdedShiftChar && uncmdedShiftChar != cmdedShiftChar;
15096:       PRUint32 originalCmdedShiftChar = cmdedShiftChar;
15096: 
15704:       // If we can make a good guess at the characters that the user would
15704:       // expect this key combination to produce (with and without Shift) then
15704:       // use those characters.  This also corrects for CapsLock, which was
15704:       // ignored above.
15072:       if (!isCmdSwitchLayout) {
15704:         // The characters produced with Command seem similar to those without
15704:         // Command.
15079:         if (unshiftedChar)
15079:           cmdedChar = unshiftedChar;
15096:         if (shiftedChar)
15072:           cmdedShiftChar = shiftedChar;
15072:       } else if (uncmdedUSChar == cmdedChar) {
15704:         // It looks like characters from a US layout are provided when Command
15704:         // is down.
15079:         PRUint32 ch = GetUSLayoutCharFromKeyTranslate(key, lockState);
15079:         if (ch)
15079:           cmdedChar = ch;
15079:         ch = GetUSLayoutCharFromKeyTranslate(key, shiftLockMod);
15096:         if (ch)
15072:           cmdedShiftChar = ch;
15072:       }
15072: 
15704:       // Only charCode (not alternativeCharCodes) is available to javascript,
15704:       // so attempt to set this to the most likely intended (or most useful)
15704:       // character.  Note that cmdedChar and cmdedShiftChar are usually
15704:       // Latin/ASCII characters and that is what is wanted here as accel
15704:       // keys are expected to be Latin characters.
15704:       //
15072:       // XXX We should do something similar when Control is down (bug 429510).
15072:       if (outGeckoEvent->isMeta &&
15072:            !(outGeckoEvent->isControl || outGeckoEvent->isAlt)) {
15072: 
15072:         // The character to use for charCode.
15072:         PRUint32 preferredCharCode = 0;
15072:         preferredCharCode = outGeckoEvent->isShift ? cmdedShiftChar : cmdedChar;
15072: 
15072:         if (preferredCharCode) {
15072: #ifdef DEBUG_KB
15072:           if (outGeckoEvent->charCode != preferredCharCode) {
15072:             NSLog(@"      charCode replaced: %X(%C) to %X(%C)",
15072:                   outGeckoEvent->charCode,
15072:                   outGeckoEvent->charCode > ' ' ? outGeckoEvent->charCode : ' ',
15072:                   preferredCharCode,
15072:                   preferredCharCode > ' ' ? preferredCharCode : ' ');
15072:           }
15072: #endif
15072:           outGeckoEvent->charCode = preferredCharCode;
15072:         }
15072:       }
15072: 
15029:       // If the current keyboard layout is switched by the Cmd key,
15072:       // we should append cmdedChar and shiftedCmdChar that are
15029:       // Latin char for the key. But don't append at Dvorak-QWERTY.
15072:       if ((cmdedChar || cmdedShiftChar) &&
15029:           isCmdSwitchLayout && !isDvorakQWERTY) {
15072:         nsAlternativeCharCode altCharCodes(cmdedChar, cmdedShiftChar);
15029:         outGeckoEvent->alternativeCharCodes.AppendElement(altCharCodes);
15029:       }
15096:       // Special case for 'SS' key of German layout. See the comment of
15096:       // hasCmdShiftOnlyChar definition for the detail.
15096:       if (hasCmdShiftOnlyChar && originalCmdedShiftChar) {
15096:         nsAlternativeCharCode altCharCodes(0, originalCmdedShiftChar);
15096:         outGeckoEvent->alternativeCharCodes.AppendElement(altCharCodes);
15096:       }
14328:     }
    1:   }
    1:   else {
    1:     NSString* characters = nil;
    1:     if ([aKeyEvent type] != NSFlagsChanged)
 2959:       characters = [aKeyEvent charactersIgnoringModifiers];
    1:     
19704:     outGeckoEvent->keyCode =
38441:       ConvertMacToGeckoKeyCode([aKeyEvent keyCode], outGeckoEvent, characters);
    1:     outGeckoEvent->charCode = 0;
    1:   } 
    1: 
 9889:   if (outGeckoEvent->message == NS_KEY_PRESS && !outGeckoEvent->isMeta)
  603:     [NSCursor setHiddenUntilMouseMoves:YES];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
33318: #ifndef NP_NO_CARBON
15585: // Called from PluginKeyEventsHandler() (a handler for Carbon TSM events) to
15585: // process a Carbon key event for the currently focused plugin.  Both Unicode
15585: // characters and "Mac encoding characters" (in the MBCS or "multibyte
15585: // character system") are (or should be) available from aKeyEvent, but here we
15585: // use the MCBS characters.  This is how the WebKit does things, and seems to
15585: // be what plugins expect.
15585: - (void) processPluginKeyEvent:(EventRef)aKeyEvent
15585: {
15585:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
15585: 
15585:   if (!mGeckoChild)
15585:     return;
15585: 
43436:   if (mPluginEventModel == NPEventModelCocoa) {
43436:     UInt32 size;
43436:     OSStatus status = ::GetEventParameter(aKeyEvent, kEventParamKeyUnicodes, typeUnicodeText, NULL, 0, &size, NULL);
43436:     if (status != noErr)
43436:       return;
43436: 
43436:     UniChar* chars = (UniChar*)malloc(size);
43436:     if (!chars)
43436:       return;
43436: 
43436:     status = ::GetEventParameter(aKeyEvent, kEventParamKeyUnicodes, typeUnicodeText, NULL, size, NULL, chars);
43436:     if (status != noErr) {
43436:       free(chars);
43436:       return;
43436:     }
43436: 
43436:     CFStringRef text = ::CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault, chars, (size / sizeof(UniChar)), kCFAllocatorNull);
43436:     if (!text) {
43436:       free(chars);
43436:       return;
43436:     }
43436: 
43436:     NPCocoaEvent cocoaTextEvent;
43436:     InitNPCocoaEvent(&cocoaTextEvent);
43436:     cocoaTextEvent.type = NPCocoaEventTextInput;
43436:     cocoaTextEvent.data.text.text = (NPNSString*)text;
43436: 
43436:     nsGUIEvent pluginTextEvent(PR_TRUE, NS_NON_RETARGETED_PLUGIN_EVENT, mGeckoChild);
43436:     pluginTextEvent.time = PR_IntervalNow();
43436:     pluginTextEvent.pluginEvent = (void*)&cocoaTextEvent;
43436:     mGeckoChild->DispatchWindowEvent(pluginTextEvent);
43436: 
43436:     ::CFRelease(text);
43436:     free(chars);
43436: 
43436:     return;
43436:   }
43436: 
15585:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
15585: 
15585:   UInt32 numCharCodes;
15585:   OSStatus status = ::GetEventParameter(aKeyEvent, kEventParamKeyMacCharCodes,
15585:                                         typeChar, NULL, 0, &numCharCodes, NULL);
15585:   if (status != noErr)
15585:     return;
15585: 
15585:   nsAutoTArray<unsigned char, 3> charCodes;
15585:   charCodes.SetLength(numCharCodes);
15585:   status = ::GetEventParameter(aKeyEvent, kEventParamKeyMacCharCodes,
15585:                                typeChar, NULL, numCharCodes, NULL, charCodes.Elements());
15585:   if (status != noErr)
15585:     return;
15585: 
15585:   UInt32 modifiers;
15585:   status = ::GetEventParameter(aKeyEvent, kEventParamKeyModifiers,
15585:                                typeUInt32, NULL, sizeof(modifiers), NULL, &modifiers);
15585:   if (status != noErr)
15585:     return;
15585: 
15585:   UInt32 macKeyCode;
15585:   status = ::GetEventParameter(aKeyEvent, kEventParamKeyCode,
15585:                                typeUInt32, NULL, sizeof(macKeyCode), NULL, &macKeyCode);
15585:   if (status != noErr)
15585:     return;
15585: 
15585:   EventRef cloneEvent = ::CopyEvent(aKeyEvent);
15585:   for (unsigned int i = 0; i < numCharCodes; ++i) {
15585:     status = ::SetEventParameter(cloneEvent, kEventParamKeyMacCharCodes,
15585:                                  typeChar, 1, charCodes.Elements() + i);
15585:     if (status != noErr)
15585:       break;
15585: 
15585:     EventRecord eventRec;
15585:     if (::ConvertEventRefToEventRecord(cloneEvent, &eventRec)) {
15585:       nsKeyEvent keyDownEvent(PR_TRUE, NS_KEY_DOWN, mGeckoChild);
15585: 
15585:       PRUint32 keyCode(ConvertMacToGeckoKeyCode(macKeyCode, &keyDownEvent, @""));
15585:       PRUint32 charCode(charCodes.ElementAt(i));
15585: 
15585:       keyDownEvent.time       = PR_IntervalNow();
34743:       keyDownEvent.pluginEvent  = &eventRec;
15585:       if (IsSpecialGeckoKey(macKeyCode)) {
15585:         keyDownEvent.keyCode  = keyCode;
15585:       } else {
15585:         keyDownEvent.charCode = charCode;
15585:         keyDownEvent.isChar   = PR_TRUE;
15585:       }
15585:       keyDownEvent.isShift   = ((modifiers & shiftKey) != 0);
15585:       keyDownEvent.isControl = ((modifiers & controlKey) != 0);
15585:       keyDownEvent.isAlt     = ((modifiers & optionKey) != 0);
15585:       keyDownEvent.isMeta    = ((modifiers & cmdKey) != 0); // Should never happen
15585:       mGeckoChild->DispatchWindowEvent(keyDownEvent);
15585:       if (!mGeckoChild)
15585:         break;
15585:     }
15585:   }
15585: 
15585:   ::ReleaseEvent(cloneEvent);
15585: 
15585:   NS_OBJC_END_TRY_ABORT_BLOCK;
15585: }
33318: #endif // NP_NO_CARBON
15585: 
43436: - (void)pluginRequestsComplexTextInputForCurrentEvent
43436: {
43436:   mPluginComplexTextInputRequested = YES;
43436: }
43436: 
40645: - (void)sendCompositionEvent:(PRInt32) aEventType
 2315: {
 2315: #ifdef DEBUG_IME
 2315:   NSLog(@"****in sendCompositionEvent; type = %d", aEventType);
 2315: #endif
 2315: 
 2462:   if (!mGeckoChild)
40645:     return;
 2462: 
 2315:   // static void init_composition_event( *aEvent, int aType)
 2315:   nsCompositionEvent event(PR_TRUE, aEventType, mGeckoChild);
 2315:   event.time = PR_IntervalNow();
 2315:   mGeckoChild->DispatchWindowEvent(event);
 2315: }
 2315: 
 2315: - (void)sendTextEvent:(PRUnichar*) aBuffer 
 2315:                       attributedString:(NSAttributedString*) aString  
 2315:                       selectedRange:(NSRange) selRange 
 2315:                       markedRange:(NSRange) markRange
 2315:                       doCommit:(BOOL) doCommit
 2315: {
 2315: #ifdef DEBUG_IME
 2315:   NSLog(@"****in sendTextEvent; string = '%@'", aString);
 2315:   NSLog(@" markRange = %d, %d;  selRange = %d, %d", markRange.location, markRange.length, selRange.location, selRange.length);
 2315: #endif
 2315: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
 2315:   nsTextEvent textEvent(PR_TRUE, NS_TEXT_TEXT, mGeckoChild);
 2315:   textEvent.time = PR_IntervalNow();
 2315:   textEvent.theText = aBuffer;
 2315:   if (!doCommit)
 2315:     FillTextRangeInTextEvent(&textEvent, aString, markRange, selRange);
 2315: 
 2315:   mGeckoChild->DispatchWindowEvent(textEvent);
 2315:   if (textEvent.rangeArray)
 2315:     delete [] textEvent.rangeArray;
 2315: }
 2315: 
 2315: #pragma mark -
 2315: // NSTextInput implementation
 2315: 
 2315: #define MAX_BUFFER_SIZE 32
 2315: 
 2315: - (void)insertText:(id)insertString
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in insertText: '%@'", insertString);
11914:   NSLog(@" markRange = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
 2462:   if (!mGeckoChild)
 2462:     return;
 2315: 
33316:   if (mGeckoChild->TextInputHandler()->IgnoreIMEComposition())
33316:     return;
33316: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 4726: 
 2315:   if (![insertString isKindOfClass:[NSAttributedString class]])
 2315:     insertString = [[[NSAttributedString alloc] initWithString:insertString] autorelease];
 2315: 
 2315:   NSString *tmpStr = [insertString string];
 2315:   unsigned int len = [tmpStr length];
49150:   if (!mGeckoChild->TextInputHandler()->IsIMEComposing() && len == 0)
 4726:     return; // nothing to do
 2315:   PRUnichar buffer[MAX_BUFFER_SIZE];
 2315:   PRUnichar *bufPtr = (len >= MAX_BUFFER_SIZE) ? new PRUnichar[len + 1] : buffer;
 2315:   [tmpStr getCharacters:bufPtr];
 4726:   bufPtr[len] = PRUnichar('\0');
 2315: 
49150:   if (len == 1 && !mGeckoChild->TextInputHandler()->IsIMEComposing()) {
12491:     // don't let the same event be fired twice when hitting
12491:     // enter/return! (Bug 420502)
12491:     if (mKeyPressSent)
12491:       return;
12491: 
 2315:     // dispatch keypress event with char instead of textEvent
 2315:     nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_PRESS, mGeckoChild);
 2315:     geckoEvent.time      = PR_IntervalNow();
 2315:     geckoEvent.charCode  = bufPtr[0]; // gecko expects OS-translated unicode
 7164:     geckoEvent.keyCode   = 0;
 2315:     geckoEvent.isChar    = PR_TRUE;
 8339:     if (mKeyDownHandled)
 2315:       geckoEvent.flags |= NS_EVENT_FLAG_NO_DEFAULT;
 2315:     // don't set other modifiers from the current event, because here in
 2315:     // -insertText: they've already been taken into account in creating
 2315:     // the input string.
 2315:         
32019:     // create event for use by plugins
32120: #ifndef NP_NO_CARBON
32019:     EventRecord carbonEvent;
32120: #endif
 2315:     if (mCurKeyEvent) {
13547:       // XXX The ASCII characters inputting mode of egbridge (Japanese IME)
13547:       // might send the keyDown event with wrong keyboard layout if other
13547:       // keyboard layouts are already loaded. In that case, the native event
13547:       // doesn't match to this gecko event...
32120: #ifndef NP_NO_CARBON
32120:       if (mPluginEventModel == NPEventModelCarbon) {
32019:         ConvertCocoaKeyEventToCarbonEvent(mCurKeyEvent, carbonEvent);
34743:         geckoEvent.pluginEvent = &carbonEvent;
39851:       }
32120: #endif
39851: 
38441:       geckoEvent.isShift = ([mCurKeyEvent modifierFlags] & NSShiftKeyMask) != 0;
 7164:       if (!IsPrintableChar(geckoEvent.charCode)) {
 6825:         geckoEvent.keyCode = 
38441:           ConvertMacToGeckoKeyCode([mCurKeyEvent keyCode], &geckoEvent,
 6825:                                    [mCurKeyEvent charactersIgnoringModifiers]);
 7164:         geckoEvent.charCode = 0;
 7164:       }
 6825:     } else {
 6825:       // Note that insertText is not called only at key pressing.
 7164:       if (!IsPrintableChar(geckoEvent.charCode)) {
 6825:         geckoEvent.keyCode = GetGeckoKeyCodeFromChar(geckoEvent.charCode);
 7164:         geckoEvent.charCode = 0;
 7164:       }
 2315:     }
 2315: 
21581:     PRBool keyPressHandled = mGeckoChild->DispatchWindowEvent(geckoEvent);
36941:     // Note: mGeckoChild might have become null here. Don't count on it from here on.
21581:     // Only record the results of dispatching geckoEvent if we're currently
21581:     // processing a keyDown event.
21581:     if (mCurKeyEvent) {
21581:       mKeyPressHandled = keyPressHandled;
12429:       mKeyPressSent = YES;
 2315:     }
21581:   }
 2315:   else {
49150:     if (!mGeckoChild->TextInputHandler()->IsIMEComposing()) {
 2315:       [self sendCompositionEvent:NS_COMPOSITION_START];
10305:       // Note: mGeckoChild might have become null here. Don't count on it from here on.
36941:       if (mGeckoChild) {
49150:         mGeckoChild->TextInputHandler()->OnStartIMEComposition(self);
10305:         // Note: mGeckoChild might have become null here. Don't count on it from here on.
 2315:       }
36941:     }
36941: 
49150:     if (mGeckoChild && mGeckoChild->TextInputHandler()->IgnoreIMECommit()) {
 4726:       tmpStr = [tmpStr init];
 4726:       len = 0;
 4726:       bufPtr[0] = PRUnichar('\0');
 4726:       insertString =
 4726:         [[[NSAttributedString alloc] initWithString:tmpStr] autorelease];
 4726:     }
 2315:     [self sendTextEvent:bufPtr attributedString:insertString
 2315:                                selectedRange:NSMakeRange(0, len)
 2315:                                markedRange:mMarkedRange
 2315:                                doCommit:YES];
10305:     // Note: mGeckoChild might have become null here. Don't count on it from here on.
10305: 
 2315:     [self sendCompositionEvent:NS_COMPOSITION_END];
10305:     // Note: mGeckoChild might have become null here. Don't count on it from here on.
36941:     if (mGeckoChild) {
49150:       mGeckoChild->TextInputHandler()->OnEndIMEComposition();
36941:       // Note: mGeckoChild might have become null here. Don't count on it from here on.
36941:     }
11914:     mMarkedRange = NSMakeRange(NSNotFound, 0);
 2315:   }
 2315: 
 2315:   if (bufPtr != buffer)
 2315:     delete[] bufPtr;
 4726: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: - (void)insertNewline:(id)sender
 2315: {
12574:   [self insertText:@"\n"];
 2315: }
 2315: 
 2315: - (void) doCommandBySelector:(SEL)aSelector
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12574: 
 2315: #if DEBUG_IME 
13042:   NSLog(@"**** in doCommandBySelector %s (ignore %d)", aSelector, mKeyPressHandled);
 2315: #endif
12574: 
13042:   if (!mKeyPressHandled)
 2315:     [super doCommandBySelector:aSelector];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: - (void) setMarkedText:(id)aString selectedRange:(NSRange)selRange
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2315: #if DEBUG_IME 
 2315:   NSLog(@"****in setMarkedText location: %d, length: %d", selRange.location, selRange.length);
11914:   NSLog(@" markRange = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315:   NSLog(@" aString = '%@'", aString);
 2315: #endif
 2315: 
36941:   if (!mGeckoChild)
36941:     return;
36941: 
33316:   if (mGeckoChild->TextInputHandler()->IgnoreIMEComposition())
33316:     return;
33316: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 4726: 
 2315:   if (![aString isKindOfClass:[NSAttributedString class]])
 2315:     aString = [[[NSAttributedString alloc] initWithString:aString] autorelease];
 2315: 
 2315:   NSMutableAttributedString *mutableAttribStr = aString;
 2315:   NSString *tmpStr = [mutableAttribStr string];
 2315:   unsigned int len = [tmpStr length];
 2315:   PRUnichar buffer[MAX_BUFFER_SIZE];
 2315:   PRUnichar *bufPtr = (len >= MAX_BUFFER_SIZE) ? new PRUnichar[len + 1] : buffer;
 2315:   [tmpStr getCharacters:bufPtr];
 4726:   bufPtr[len] = PRUnichar('\0');
 2315: 
 2315: #if DEBUG_IME 
 2315:   printf("****in setMarkedText, len = %d, text = ", len);
 2315:   PRUint32 n = 0;
 2315:   PRUint32 maxlen = len > 12 ? 12 : len;
11914:   for (PRUnichar *a = bufPtr; (*a != PRUnichar('\0')) && n<maxlen; a++, n++)
11914:     printf((*a&0xff80) ? "\\u%4X" : "%c", *a); 
 2315:   printf("\n");
 2315: #endif
 2315: 
 2315:   mMarkedRange.length = len;
 2315: 
49150:   if (!mGeckoChild->TextInputHandler()->IsIMEComposing() && len > 0) {
11914:     nsQueryContentEvent selection(PR_TRUE, NS_QUERY_SELECTED_TEXT, mGeckoChild);
11914:     mGeckoChild->DispatchWindowEvent(selection);
11914:     mMarkedRange.location = selection.mSucceeded ? selection.mReply.mOffset : 0;
 2315:     [self sendCompositionEvent:NS_COMPOSITION_START];
10305:     // Note: mGeckoChild might have become null here. Don't count on it from here on.
36941:     if (mGeckoChild) {
49150:       mGeckoChild->TextInputHandler()->OnStartIMEComposition(self);
10305:       // Note: mGeckoChild might have become null here. Don't count on it from here on.
 2315:     }
36941:   }
 2315: 
49150:   if (mGeckoChild->TextInputHandler()->IsIMEComposing()) {
49150:     mGeckoChild->TextInputHandler()->OnUpdateIMEComposition(tmpStr);
 4726: 
14534:     BOOL commit = len == 0;
 2315:     [self sendTextEvent:bufPtr attributedString:aString
 2315:                                   selectedRange:selRange
 2315:                                     markedRange:mMarkedRange
14534:                                        doCommit:commit];
10305:     // Note: mGeckoChild might have become null here. Don't count on it from here on.
10305: 
14534:     if (commit) {
14534:       [self sendCompositionEvent:NS_COMPOSITION_END];
36941:       // Note: mGeckoChild might have become null here. Don't count on it from here on.
36941:       if (mGeckoChild) {
49150:         mGeckoChild->TextInputHandler()->OnEndIMEComposition();
36941:         // Note: mGeckoChild might have become null here. Don't count on it from here on.
36941:       }
14534:     }
10305:   }
 2315: 
 2315:   if (bufPtr != buffer)
 2315:     delete[] bufPtr;
 4726: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: - (void) unmarkText
 2315: {
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in unmarkText");
 2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
36941:   if (mGeckoChild)
49150:     mGeckoChild->TextInputHandler()->CommitIMEComposition();
 2315: }
 2315: 
 2315: - (BOOL) hasMarkedText
 2315: {
11914: #if DEBUG_IME
11914:   NSLog(@"****in hasMarkText");
11914:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
11914: #endif
 2315:   return (mMarkedRange.location != NSNotFound) && (mMarkedRange.length != 0);
 2315: }
 2315: 
32120: - (NSInteger) conversationIdentifier
 2315: {
11914: #if DEBUG_IME
11914:   NSLog(@"****in conversationIdentifier");
11914: #endif
11914:   if (!mGeckoChild)
 2315:     return (long)self;
11914:   nsQueryContentEvent textContent(PR_TRUE, NS_QUERY_TEXT_CONTENT, mGeckoChild);
11914:   textContent.InitForQueryTextContent(0, 0);
11914:   mGeckoChild->DispatchWindowEvent(textContent);
11914:   if (!textContent.mSucceeded)
11914:     return (long)self;
11914: #if DEBUG_IME
11914:   NSLog(@" the ID = %ld", (long)textContent.mReply.mContentsRoot);
11914: #endif
11914:   return (long)textContent.mReply.mContentsRoot;
 2315: }
 2315: 
 2315: - (NSAttributedString *) attributedSubstringFromRange:(NSRange)theRange
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in attributedSubstringFromRange");
 2315:   NSLog(@" theRange      = %d, %d", theRange.location, theRange.length);
 2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
11914:   if (!mGeckoChild || theRange.length == 0)
 2462:     return nil;
 2462: 
11914:   nsAutoString str;
11914:   nsQueryContentEvent textContent(PR_TRUE, NS_QUERY_TEXT_CONTENT, mGeckoChild);
11914:   textContent.InitForQueryTextContent(theRange.location, theRange.length);
11914:   mGeckoChild->DispatchWindowEvent(textContent);
11914: 
11914:   if (!textContent.mSucceeded || textContent.mReply.mString.IsEmpty())
11914:     return nil;
11914: 
14962:   NSString* nsstr = ToNSString(textContent.mReply.mString);
11914:   NSAttributedString* result =
11914:     [[[NSAttributedString alloc] initWithString:nsstr
 2315:                                      attributes:nil] autorelease];
 2315:   return result;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 2315: }
 2315: 
 2315: - (NSRange) markedRange
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in markedRange");
 2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
 2315: 
 2315:   if (![self hasMarkedText]) {
 2315:     return NSMakeRange(NSNotFound, 0);
 2315:   }
 2315: 
 2315:   return mMarkedRange;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSMakeRange(0, 0));
 2315: }
 2315: 
 2315: - (NSRange) selectedRange
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in selectedRange");
 2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
11914:   if (!mGeckoChild)
11914:     return NSMakeRange(NSNotFound, 0);
11914:   nsQueryContentEvent selection(PR_TRUE, NS_QUERY_SELECTED_TEXT, mGeckoChild);
11914:   mGeckoChild->DispatchWindowEvent(selection);
11914:   if (!selection.mSucceeded)
11914:     return NSMakeRange(NSNotFound, 0);
11914: 
11914: #if DEBUG_IME
11914:   NSLog(@" result of selectedRange = %d, %d",
11914:         selection.mReply.mOffset, selection.mReply.mString.Length());
11914: #endif
11914:   return NSMakeRange(selection.mReply.mOffset,
11914:                      selection.mReply.mString.Length());
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSMakeRange(0, 0));
 2315: }
 2315: 
 2315: - (NSRect) firstRectForCharacterRange:(NSRange)theRange
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in firstRectForCharacterRange");
 2315:   NSLog(@" theRange      = %d, %d", theRange.location, theRange.length);
 2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
11914:   // XXX this returns first character rect or caret rect, it is limitation of
11914:   // now. We need more work for returns first line rect. But current
11914:   // implementation is enough for IMEs.
11914: 
11914:   NSRect rect;
11914:   if (!mGeckoChild || theRange.location == NSNotFound)
11914:     return rect;
11914: 
23738:   nsIntRect r;
11914:   PRBool useCaretRect = theRange.length == 0;
11914:   if (!useCaretRect) {
24836:     nsQueryContentEvent charRect(PR_TRUE, NS_QUERY_TEXT_RECT, mGeckoChild);
24836:     charRect.InitForQueryTextRect(theRange.location, 1);
11914:     mGeckoChild->DispatchWindowEvent(charRect);
11914:     if (charRect.mSucceeded)
11914:       r = charRect.mReply.mRect;
11914:     else
11914:       useCaretRect = PR_TRUE;
11914:   }
11914: 
11914:   if (useCaretRect) {
11914:     nsQueryContentEvent caretRect(PR_TRUE, NS_QUERY_CARET_RECT, mGeckoChild);
11914:     caretRect.InitForQueryCaretRect(theRange.location);
11914:     mGeckoChild->DispatchWindowEvent(caretRect);
11914:     if (!caretRect.mSucceeded)
11914:       return rect;
11914:     r = caretRect.mReply.mRect;
11914:     r.width = 0;
11914:   }
11914: 
11914:   nsIWidget* rootWidget = mGeckoChild->GetTopLevelWidget();
11914:   NSWindow* rootWindow =
11914:     static_cast<NSWindow*>(rootWidget->GetNativeData(NS_NATIVE_WINDOW));
11914:   NSView* rootView =
11914:     static_cast<NSView*>(rootWidget->GetNativeData(NS_NATIVE_WIDGET));
11914:   if (!rootWindow || !rootView)
11914:     return rect;
11914:   GeckoRectToNSRect(r, rect);
11914:   rect = [rootView convertRect:rect toView:nil];
11914:   rect.origin = [rootWindow convertBaseToScreen:rect.origin];
11914: #if DEBUG_IME
11914:   NSLog(@" result rect (x,y,w,h) = %f, %f, %f, %f",
11914:         rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
11914: #endif
11914:   return rect;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSMakeRect(0.0, 0.0, 0.0, 0.0));
 2315: }
 2315: 
32120: - (NSUInteger)characterIndexForPoint:(NSPoint)thePoint
 2315: {
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in characterIndexForPoint");
11914:   NSLog(@" markRange = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
 2315: 
 2315:   // To implement this, we'd have to grovel in text frames looking at text offsets.
 2315:   return 0;
 2315: }
 2315: 
 2315: - (NSArray*) validAttributesForMarkedText
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in validAttributesForMarkedText");
11914:   NSLog(@" markRange = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
 2315: 
 2315:   //return [NSArray arrayWithObjects:NSUnderlineStyleAttributeName, NSMarkedClauseSegmentAttributeName, NSTextInputReplacementRangeAttributeName, nil];
 2315:   return [NSArray array]; // empty array; we don't support any attributes right now
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 2315: }
 2315: 
 2315: #pragma mark -
 2315: 
 7100: + (NSEvent*)makeNewCocoaEventWithType:(NSEventType)type fromEvent:(NSEvent*)theEvent
 7100: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 7100:   NSEvent* newEvent = [NSEvent keyEventWithType:type
 7100:                                        location:[theEvent locationInWindow] 
38441:                                   modifierFlags:[theEvent modifierFlags]
 7100:                                       timestamp:[theEvent timestamp]
 7100:                                    windowNumber:[theEvent windowNumber]
 7100:                                         context:[theEvent context]
 7100:                                      characters:[theEvent characters]
 7100:                     charactersIgnoringModifiers:[theEvent charactersIgnoringModifiers]
 7100:                                       isARepeat:[theEvent isARepeat]
38441:                                         keyCode:[theEvent keyCode]];
 7100:   return newEvent;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 7100: }
 7100: 
14962: #ifdef PR_LOGGING
14962: static const char* ToEscapedString(NSString* aString, nsCAutoString& aBuf)
14962: {
14962:   for (PRUint32 i = 0; i < [aString length]; ++i) {
14962:     unichar ch = [aString characterAtIndex:i];
14962:     if (ch >= 32 && ch < 128) {
14962:       aBuf.Append(char(ch));
14962:     } else {
14962:       aBuf += nsPrintfCString("\\u%04x", ch);
14962:     }
14962:   }
14962:   return aBuf.get();
14962: }
14962: #endif
 7100: 
13042: // Returns PR_TRUE if Gecko claims to have handled the event, PR_FALSE otherwise.
39851: // We only send Carbon plugin events with NS_KEY_DOWN gecko events, and only send
39851: // Cocoa plugin events with NS_KEY_PRESS gecko events. This is because we want to
39851: // send repeat key down events to Cocoa plugins but not Carbon plugins.
50708: - (PRBool)processKeyDownEvent:(NSEvent*)theEvent
13042: {
13042:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 2462:   if (!mGeckoChild)
13042:     return NO;
 2462: 
14962: #ifdef PR_LOGGING
14962:   nsCAutoString str1;
14962:   nsCAutoString str2;
14962: #endif
14962:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS,
14962:          ("ChildView processKeyDownEvent: keycode=%d,modifiers=%x,chars=%s,charsIgnoringModifiers=%s\n",
38441:           [theEvent keyCode],
38441:           [theEvent modifierFlags],
14962:           ToEscapedString([theEvent characters], str1),
14962:           ToEscapedString([theEvent charactersIgnoringModifiers], str2)));
14962: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 2315:   mCurKeyEvent = theEvent;
 2315: 
 2315:   BOOL nonDeadKeyPress = [[theEvent characters] length] > 0;
49150:   if (nonDeadKeyPress && !mGeckoChild->TextInputHandler()->IsIMEComposing()) {
 8339:     NSResponder* firstResponder = [[self window] firstResponder];
 8339: 
55338:     nsKeyEvent geckoKeydown(PR_TRUE, NS_KEY_DOWN, nsnull);
55338:     [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoKeydown];
 2315: 
32120: #ifndef NP_NO_CARBON
32019:     EventRecord carbonEvent;
32120:     if (mPluginEventModel == NPEventModelCarbon) {
32019:       ConvertCocoaKeyEventToCarbonEvent(theEvent, carbonEvent);
55338:       geckoKeydown.pluginEvent = &carbonEvent;
32019:     }
32120: #endif
12429: 
55338:     mKeyDownHandled = mGeckoChild->DispatchWindowEvent(geckoKeydown);
55338:     if (!mGeckoChild) {
13042:       return mKeyDownHandled;
55338:     }
 8339: 
 2315:     // The key down event may have shifted the focus, in which
 2315:     // case we should not fire the key press.
 8339:     if (firstResponder != [[self window] firstResponder]) {
13042:       PRBool handled = mKeyDownHandled;
 2315:       mCurKeyEvent = nil;
 8339:       mKeyDownHandled = PR_FALSE;
13042:       return handled;
 2315:     }
 8339: 
12536:     // If this is the context menu key command, send a context menu key event.
38441:     unsigned int modifierFlags = [theEvent modifierFlags] & NSDeviceIndependentModifierFlagsMask;
12536:     if (modifierFlags == NSControlKeyMask && [[theEvent charactersIgnoringModifiers] isEqualToString:@" "]) {
12536:       nsMouseEvent contextMenuEvent(PR_TRUE, NS_CONTEXTMENU, [self widget], nsMouseEvent::eReal, nsMouseEvent::eContextMenuKey);
12536:       contextMenuEvent.isShift = contextMenuEvent.isControl = contextMenuEvent.isAlt = contextMenuEvent.isMeta = PR_FALSE;
13042:       PRBool cmEventHandled = mGeckoChild->DispatchWindowEvent(contextMenuEvent);
12536:       [self maybeInitContextMenuTracking];
12536:       // Bail, there is nothing else to do here.
13042:       PRBool handled = (cmEventHandled || mKeyDownHandled);
12536:       mCurKeyEvent = nil;
12536:       mKeyDownHandled = PR_FALSE;
13042:       return handled;
12536:     }
12536: 
55338:     nsKeyEvent geckoKeypress(PR_TRUE, NS_KEY_PRESS, nsnull);
55338:     [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoKeypress];
 2315: 
 2315:     // if this is a non-letter keypress, or the control key is down,
 2315:     // dispatch the keydown to gecko, so that we trap delete,
 2315:     // control-letter combinations etc before Cocoa tries to use
 2315:     // them for keybindings.
55338:     if ((!geckoKeypress.isChar || geckoKeypress.isControl) &&
49150:         !mGeckoChild->TextInputHandler()->IsIMEComposing()) {
12429:       if (mKeyDownHandled)
55338:         geckoKeypress.flags |= NS_EVENT_FLAG_NO_DEFAULT;
55338:       mKeyPressHandled = mGeckoChild->DispatchWindowEvent(geckoKeypress);
13042:       mKeyPressSent = YES;
 7100:       if (!mGeckoChild)
13042:         return (mKeyDownHandled || mKeyPressHandled);
12429:     }
12429:   }
12429: 
49150:   // Let Cocoa interpret the key events, caching IsIMEComposing first.
49150:   PRBool wasComposing = mGeckoChild->TextInputHandler()->IsIMEComposing();
21581:   PRBool interpretKeyEventsCalled = PR_FALSE;
50708:   if (mGeckoChild->TextInputHandler()->IsIMEEnabled() ||
50708:       mGeckoChild->TextInputHandler()->IsASCIICapableOnly()) {
21581:     [super interpretKeyEvents:[NSArray arrayWithObject:theEvent]];
21581:     interpretKeyEventsCalled = PR_TRUE;
21581:   }
21581: 
50708:   if (!mGeckoChild) {
50708:     return (mKeyDownHandled || mKeyPressHandled);
50708:   }
21581: 
33316:   if (!mKeyPressSent && nonDeadKeyPress && !wasComposing &&
49150:       !mGeckoChild->TextInputHandler()->IsIMEComposing()) {
55338:     nsKeyEvent geckoKeypress(PR_TRUE, NS_KEY_PRESS, nsnull);
55338:     [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoKeypress];
21581: 
21581:     // If we called interpretKeyEvents and this isn't normal character input
21581:     // then IME probably ate the event for some reason. We do not want to
21581:     // send a key press event in that case.
55338:     if (!(interpretKeyEventsCalled && IsNormalCharInputtingEvent(geckoKeypress))) {
55338:       if (mKeyDownHandled) {
55338:         geckoKeypress.flags |= NS_EVENT_FLAG_NO_DEFAULT;
55338:       }
55338:       mKeyPressHandled = mGeckoChild->DispatchWindowEvent(geckoKeypress);
21581:     }
21581:   }
21581: 
21581:   // Note: mGeckoChild might have become null here. Don't count on it from here on.
21581: 
21581:   PRBool handled = (mKeyDownHandled || mKeyPressHandled);
21581: 
21581:   // See note about nested event loops where these variables are declared in header.
21581:   mKeyPressHandled = NO;
21581:   mKeyPressSent = NO;
21581:   mCurKeyEvent = nil;
21581:   mKeyDownHandled = PR_FALSE;
21581: 
21581:   return handled;
21581: 
21581:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
21581: }
21581: 
43436: #ifdef NP_NO_CARBON
43436: - (NSTextInputContext *)inputContext
43436: {
43436:   if (mIsPluginView && mPluginEventModel == NPEventModelCocoa)
43436:     return [[ComplexTextInputPanel sharedComplexTextInputPanel] inputContext];
43436:   else
43436:     return [super inputContext];
43436: }
43436: #endif
43436: 
33318: #ifndef NP_NO_CARBON
15585: // Create a TSM document for use with plugins, so that we can support IME in
15585: // them.  Once it's created, if need be (re)activate it.  Some plugins (e.g.
15585: // the Flash plugin running in Camino) don't create their own TSM document --
15585: // without which IME can't work.  Others (e.g. the Flash plugin running in
15585: // Firefox) create a TSM document that (somehow) makes the input window behave
15585: // badly when it contains more than one kind of input (say Hiragana and
15585: // Romaji).  (We can't just use the per-NSView TSM documents that Cocoa
39656: // provides (those created and managed by the NSTSMInputContext class) -- for
15585: // some reason TSMProcessRawKeyEvent() doesn't work with them.)
15585: - (void)activatePluginTSMDoc
15585: {
15585:   if (!mPluginTSMDoc) {
15585:     // Create a TSM document that supports both non-Unicode and Unicode input.
15585:     // Though [ChildView processPluginKeyEvent:] only sends Mac char codes to
15585:     // the plugin, this makes the input window behave better when it contains
15585:     // more than one kind of input (say Hiragana and Romaji).  This is what
15585:     // the OS does when it creates a TSM document for use by an
15585:     // NSTSMInputContext class.
15585:     InterfaceTypeList supportedServices;
15585:     supportedServices[0] = kTextServiceDocumentInterfaceType;
15585:     supportedServices[1] = kUnicodeDocumentInterfaceType;
15585:     ::NewTSMDocument(2, supportedServices, &mPluginTSMDoc, 0);
15585:     // We'll need to use the "input window".
15585:     ::UseInputWindow(mPluginTSMDoc, YES);
15585:     ::ActivateTSMDocument(mPluginTSMDoc);
15585:   } else if (::TSMGetActiveDocument() != mPluginTSMDoc) {
15585:     ::ActivateTSMDocument(mPluginTSMDoc);
15585:   }
15585: }
33318: #endif // NP_NO_CARBON
15585: 
50708: // This is a private API that Cocoa uses.
50708: // Cocoa will call this after the menu system returns "NO" for "performKeyEquivalent:".
50708: // We want all they key events we can get so just return YES. In particular, this fixes
50708: // ctrl-tab - we don't get a "keyDown:" call for that without this.
50708: - (BOOL)_wantsKeyDownForEvent:(NSEvent*)event
50708: {
50708:   return YES;
50708: }
50708: 
61078: - (BOOL)inCocoaPluginComposition
61078: {
61078: #ifdef NP_NO_CARBON
61078:   return [[ComplexTextInputPanel sharedComplexTextInputPanel] inComposition];
61078: #else
61078:   return mPluginTSMInComposition;
61078: #endif
61078: }
61078: 
61078: - (void)sendCocoaNPAPITextEvent:(NSString*)string
61078: {
61078:   NPCocoaEvent cocoaTextEvent;
61078:   InitNPCocoaEvent(&cocoaTextEvent);
61078:   cocoaTextEvent.type = NPCocoaEventTextInput;
61078:   cocoaTextEvent.data.text.text = (NPNSString*)string;
61078:   
61078:   nsGUIEvent pluginTextEvent(PR_TRUE, NS_NON_RETARGETED_PLUGIN_EVENT, mGeckoChild);
61078:   pluginTextEvent.time = PR_IntervalNow();
61078:   pluginTextEvent.pluginEvent = (void*)&cocoaTextEvent;
61078:   mGeckoChild->DispatchWindowEvent(pluginTextEvent);
61078: }
61078: 
12429: - (void)keyDown:(NSEvent*)theEvent
12429: {
15585:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
15585: 
43436:   if (mGeckoChild && mIsPluginView) {
61078: #ifdef NP_NO_CARBON
43436:     if (mPluginEventModel == NPEventModelCocoa) {
61078:       ComplexTextInputPanel* ctiPanel = [ComplexTextInputPanel sharedComplexTextInputPanel];
61078: 
61078:       // If a composition is in progress then simply let the input panel continue it.
61078:       if ([self inCocoaPluginComposition]) {
61078:         // Don't send key up events for key downs associated with compositions.
61078:         mIgnoreNextKeyUpEvent = YES;
61078: 
61078:         NSString* textString = nil;
61078:         [ctiPanel interpretKeyEvent:theEvent string:&textString];
61078:         if (textString) {
61078:           [self sendCocoaNPAPITextEvent:textString];
61078:         }
61078: 
61078:         return;
61078:       }
61078: 
61078:       // Reset complex text input request flag.
43436:       mPluginComplexTextInputRequested = NO;
43436: 
61078:       // Send key down event to the plugin.
43436:       nsGUIEvent pluginEvent(PR_TRUE, NS_NON_RETARGETED_PLUGIN_EVENT, mGeckoChild);
43436:       NPCocoaEvent cocoaEvent;
43436:       ConvertCocoaKeyEventToNPCocoaEvent(theEvent, cocoaEvent);
43436:       pluginEvent.pluginEvent = &cocoaEvent;
43436:       mGeckoChild->DispatchWindowEvent(pluginEvent);
61078:       if (!mGeckoChild) {
43436:         return;
61078:       }
61078: 
61078:       // Start complex text composition if requested.
61078:       if (mPluginComplexTextInputRequested) {
61078:         // Don't send key up events for key downs associated with compositions.
61078:         mIgnoreNextKeyUpEvent = YES;
61078: 
61078:         NSString* textString = nil;
61078:         [ctiPanel interpretKeyEvent:theEvent string:&textString];
61078:         if (textString) {
61078:           [self sendCocoaNPAPITextEvent:textString];
61078:         }
61078: 
61078:         return;
61078:       }
61078: 
61078:       // Nothing else to do for Cocoa NPAPI plugins.
61078:       return;
58536:     }
58536: #endif
61078: 
61078: #ifndef NP_NO_CARBON
61078:     BOOL wasInComposition = NO;
61078:     if (mPluginEventModel == NPEventModelCocoa) {
61078:       if ([self inCocoaPluginComposition]) {
61078:         wasInComposition = YES;
61078: 
61078:         // Don't send key up events for key downs associated with compositions.
61078:         mIgnoreNextKeyUpEvent = YES;
61078:       }
61078:       else {
61078:         // Reset complex text input request flag.
61078:         mPluginComplexTextInputRequested = NO;
61078: 
61078:         // Send key down event to the plugin.
61078:         nsGUIEvent pluginEvent(PR_TRUE, NS_NON_RETARGETED_PLUGIN_EVENT, mGeckoChild);
61078:         NPCocoaEvent cocoaEvent;
61078:         ConvertCocoaKeyEventToNPCocoaEvent(theEvent, cocoaEvent);
61078:         pluginEvent.pluginEvent = &cocoaEvent;
61078:         mGeckoChild->DispatchWindowEvent(pluginEvent);
61078:         if (!mGeckoChild) {
43436:           return;
43436:         }
43436: 
61078:         // Only continue if plugin wants complex text input.
61078:         if (mPluginComplexTextInputRequested) {
61078:           // Don't send key up events for key downs associated with compositions.
61078:           mIgnoreNextKeyUpEvent = YES;
61078:         }
61078:         else {
43436:           return;
61078:         }
61078:       }
61078:     }
61078: 
43436:     // This will take care of all Carbon plugin events and also send Cocoa plugin
43436:     // text events when NSInputContext is not available (ifndef NP_NO_CARBON).
15585:     [self activatePluginTSMDoc];
15585:     // We use the active TSM document to pass a pointer to ourselves (the
15585:     // currently focused ChildView) to PluginKeyEventsHandler().  Because this
15585:     // pointer is weak, we should retain and release ourselves around the call
15585:     // to TSMProcessRawKeyEvent().
15585:     nsAutoRetainCocoaObject kungFuDeathGrip(self);
15585:     ::TSMSetDocumentProperty(mPluginTSMDoc, kFocusedChildViewTSMDocPropertyTag,
15585:                              sizeof(ChildView *), &self);
15585:     ::TSMProcessRawKeyEvent([theEvent _eventRef]);
15585:     ::TSMRemoveDocumentProperty(mPluginTSMDoc, kFocusedChildViewTSMDocPropertyTag);
61078: 
15585:     return;
32120: #endif
43436:   }
15585: 
50708:   PRBool handled = [self processKeyDownEvent:theEvent];
50708:   
50708:   // We always allow keyboard events to propagate to keyDown: but if they are not
50708:   // handled we give special Application menu items a chance to act.
50708:   if (!handled && sApplicationMenu) {
50708:     [sApplicationMenu performKeyEquivalent:theEvent];
50708:   }
15585: 
15585:   NS_OBJC_END_TRY_ABORT_BLOCK;
12429: }
12429: 
 2315: - (void)keyUp:(NSEvent*)theEvent
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
14962: #ifdef PR_LOGGING
14962:   nsCAutoString str1;
14962:   nsCAutoString str2;
14962: #endif
14962:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS,
14962:          ("ChildView keyUp: keycode=%d,modifiers=%x,chars=%s,charsIgnoringModifiers=%s\n",
38441:           [theEvent keyCode],
38441:           [theEvent modifierFlags],
14962:           ToEscapedString([theEvent characters], str1),
14962:           ToEscapedString([theEvent charactersIgnoringModifiers], str2)));
14962: 
15585:   if (!mGeckoChild)
15585:     return;
15585: 
61078:   if (mIgnoreNextKeyUpEvent) {
61078:     mIgnoreNextKeyUpEvent = NO;
61078:     return;
61078:   }
61078: 
15585:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
15585: 
15585:   if (mIsPluginView) {
32120:     if (mPluginEventModel == NPEventModelCocoa) {
61078:       // Don't send key up events to Cocoa plugins during composition.
61078:       if ([self inCocoaPluginComposition]) {
61078:         return;
61078:       }
61078: 
32019:       nsKeyEvent keyUpEvent(PR_TRUE, NS_KEY_UP, nsnull);
32019:       [self convertCocoaKeyEvent:theEvent toGeckoEvent:&keyUpEvent];
32019:       NPCocoaEvent pluginEvent;
32019:       ConvertCocoaKeyEventToNPCocoaEvent(theEvent, pluginEvent);
34743:       keyUpEvent.pluginEvent = &pluginEvent;
32019:       mGeckoChild->DispatchWindowEvent(keyUpEvent);
32120:     }
32120: #ifndef NP_NO_CARBON
32120:     if (mPluginEventModel == NPEventModelCarbon) {
15585:       // I'm not sure the call to TSMProcessRawKeyEvent() is needed here (though
15585:       // WebKit makes one).
15585:       ::TSMProcessRawKeyEvent([theEvent _eventRef]);
15585:       
15585:       // Don't send a keyUp event if the corresponding keyDown event(s) is/are
15585:       // still being processed (idea borrowed from WebKit).
15585:       ChildView *keyDownTarget = nil;
15585:       OSStatus status = ::TSMGetDocumentProperty(mPluginTSMDoc, kFocusedChildViewTSMDocPropertyTag,
15585:                                                  sizeof(ChildView *), nil, &keyDownTarget);
15585:       if (status != noErr)
15585:         keyDownTarget = nil;
15585:       if (keyDownTarget == self)
15585:         return;
15585:       
15585:       // PluginKeyEventsHandler() never sends keyUp events to [ChildView
15585:       // processPluginKeyEvent:], so we need to send them to Gecko here.  (This
15585:       // means that when commiting text from IME, several keyDown events may be
15585:       // sent to Gecko (in processPluginKeyEvent) for one keyUp event here.
15585:       // But this is how the WebKit does it, and games expect a keyUp event to
15585:       // be sent when it actually happens (they need to be able to detect how
15585:       // long a key has been held down) -- which wouldn't be possible if we sent
15585:       // them from processPluginKeyEvent.)
15585:       nsKeyEvent keyUpEvent(PR_TRUE, NS_KEY_UP, nsnull);
15585:       [self convertCocoaKeyEvent:theEvent toGeckoEvent:&keyUpEvent];
15585:       EventRecord macKeyUpEvent;
29388:       ConvertCocoaKeyEventToCarbonEvent(theEvent, macKeyUpEvent);
34743:       keyUpEvent.pluginEvent = &macKeyUpEvent;
15585:       mGeckoChild->DispatchWindowEvent(keyUpEvent);      
32120:     }
32120: #endif
15585:     return;
15585:   }
15585: 
 2315:   // if we don't have any characters we can't generate a keyUp event
49150:   if ([[theEvent characters] length] == 0 ||
49150:       mGeckoChild->TextInputHandler()->IsIMEComposing()) {
 2315:     return;
49150:   }
 2315: 
 2315:   nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_UP, nsnull);
 2315:   [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
 2315: 
 2315:   mGeckoChild->DispatchWindowEvent(geckoEvent);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: - (void)flagsChanged:(NSEvent*)theEvent
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
20387:   // CapsLock state and other modifier states are different:
20387:   // CapsLock state does not revert when the CapsLock key goes up, as the
22847:   // modifier state does for other modifier keys on key up.
20387:   if ([theEvent keyCode] == kCapsLockKeyCode) {
20387:     // Fire key down event for caps lock.
20387:     [self fireKeyEventForFlagsChanged:theEvent keyDown:YES];
20387:     if (!mGeckoChild)
20387:       return;
20387:     // XXX should we fire keyup event too? The keyup event for CapsLock key
20387:     // is never sent to gecko.
20387:   } else if ([theEvent type] == NSFlagsChanged) {
 2315:     // Fire key up/down events for the modifier keys (shift, alt, ctrl, command).
38441:     unsigned int modifiers = [theEvent modifierFlags] & NSDeviceIndependentModifierFlagsMask;
 2315:     const PRUint32 kModifierMaskTable[] =
 2315:       { NSShiftKeyMask, NSControlKeyMask, NSAlternateKeyMask, NSCommandKeyMask };
 2315:     const PRUint32 kModifierCount = sizeof(kModifierMaskTable) /
 2315:                                     sizeof(kModifierMaskTable[0]);
 2315: 
 2315:     for (PRUint32 i = 0; i < kModifierCount; i++) {
 2315:       PRUint32 modifierBit = kModifierMaskTable[i];
22847:       if ((modifiers & modifierBit) != (gLastModifierState & modifierBit)) {
20387:         BOOL isKeyDown = (modifiers & modifierBit) != 0 ? YES : NO;
20387: 
20387:         [self fireKeyEventForFlagsChanged:theEvent keyDown:isKeyDown];
20387: 
20387:         if (!mGeckoChild)
20387:           return;
20387: 
20387:         // Stop if focus has changed.
20387:         // Check to see if we are still the first responder.
20387:         if (![self isFirstResponder])
20387:           break;
20387:       }
20387:     }
20387: 
22847:     gLastModifierState = modifiers;
20387:   }
20387: 
20387:   NS_OBJC_END_TRY_ABORT_BLOCK;
20387: }
20387: 
20387: - (BOOL) isFirstResponder
20387: {
20387:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
20387: 
20387:   NSResponder* resp = [[self window] firstResponder];
20387:   return (resp == (NSResponder*)self);
20387: 
20387:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
20387: }
20387: 
39094: - (BOOL)isDragInProgress
39094: {
39094:   if (!mDragService)
39094:     return NO;
39094: 
39094:   nsCOMPtr<nsIDragSession> dragSession;
39094:   mDragService->GetCurrentSession(getter_AddRefs(dragSession));
39094:   return dragSession != nsnull;
39094: }
39094: 
20387: - (void)fireKeyEventForFlagsChanged:(NSEvent*)theEvent keyDown:(BOOL)isKeyDown
20387: {
20387:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
20387: 
22410:   if (!mGeckoChild || [theEvent type] != NSFlagsChanged ||
49150:       mGeckoChild->TextInputHandler()->IsIMEComposing()) {
20387:     return;
49150:   }
20387: 
20387:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
20387: 
20609:   PRUint32 message = isKeyDown ? NS_KEY_DOWN : NS_KEY_UP;
 2315: 
 2315:   // Fire a key event.
 2315:   nsKeyEvent geckoEvent(PR_TRUE, message, nsnull);
 2315:   [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
 2315: 
32019:   // create event for use by plugins
62865:   if (mIsPluginView) {
32120: #ifndef NP_NO_CARBON
32019:     EventRecord carbonEvent;
32120:     if (mPluginEventModel == NPEventModelCarbon) {
32019:       ConvertCocoaKeyEventToCarbonEvent(theEvent, carbonEvent, message);
34743:       geckoEvent.pluginEvent = &carbonEvent;
32019:     }
32120: #endif
32120:     NPCocoaEvent cocoaEvent;
32120:     if (mPluginEventModel == NPEventModelCocoa) {
32019:       ConvertCocoaKeyEventToNPCocoaEvent(theEvent, cocoaEvent, message);
34743:       geckoEvent.pluginEvent = &cocoaEvent;
32019:     }
62865:   }
 2315: 
 2315:   mGeckoChild->DispatchWindowEvent(geckoEvent);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
47792: - (BOOL)inactiveWindowAcceptsMouseEvent:(NSEvent*)aEvent
47792: {
49214:   // If we're being destroyed assume the default -- return YES.
49214:   if (!mGeckoChild)
49214:     return YES;
49214: 
47792:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_ACTIVATE, nsnull, nsMouseEvent::eReal);
47792:   [self convertCocoaMouseEvent:aEvent toGeckoEvent:&geckoEvent];
47792:   return !mGeckoChild->DispatchWindowEvent(geckoEvent);
47792: }
47792: 
57526: // Don't focus a plugin if we're in a left click-through that will fail (see
57526: // [ChildView isInFailingLeftClickThrough] above).
57526: - (BOOL)shouldFocusPlugin
41321: {
41321:   if (!mGeckoChild)
57526:     return NO;
57526: 
57526:   nsCocoaWindow* windowWidget = mGeckoChild->GetXULWindowWidget();
57526:   if (windowWidget && !windowWidget->ShouldFocusPlugin())
57526:     return NO;
57526: 
57526:   return YES;
57526: }
57526: 
57526: // Returns NO if the plugin shouldn't be focused/unfocused.
57526: - (BOOL)updateCocoaPluginFocusStatus:(BOOL)hasFocus
57526: {
57526:   if (!mGeckoChild)
57526:     return NO;
57526: 
57526:   if (![self shouldFocusPlugin])
57526:     return NO;
41321: 
41321:   nsGUIEvent pluginEvent(PR_TRUE, NS_NON_RETARGETED_PLUGIN_EVENT, mGeckoChild);
41321:   NPCocoaEvent cocoaEvent;
41321:   InitNPCocoaEvent(&cocoaEvent);
41321:   cocoaEvent.type = NPCocoaEventFocusChanged;
41321:   cocoaEvent.data.focus.hasFocus = hasFocus;
41321:   pluginEvent.pluginEvent = &cocoaEvent;
41321:   mGeckoChild->DispatchWindowEvent(pluginEvent);
57526: 
57526:   if (hasFocus)
57526:     [self sendFocusEvent:NS_PLUGIN_FOCUS];
57526: 
57526:   return YES;
41321: }
41321: 
41321: // We must always call through to our superclass, even when mGeckoChild is
41321: // nil -- otherwise the keyboard focus can end up in the wrong NSView.
41321: - (BOOL)becomeFirstResponder
41321: {
41321:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
41321: 
41321:   if (mIsPluginView && mPluginEventModel == NPEventModelCocoa) {
57526:     if (![self updateCocoaPluginFocusStatus:YES])
57526:       return NO;
41321:   }
41321: 
41321:   return [super becomeFirstResponder];
41321: 
41321:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(YES);
41321: }
41321: 
 2677: // We must always call through to our superclass, even when mGeckoChild is
 2677: // nil -- otherwise the keyboard focus can end up in the wrong NSView.
 2315: - (BOOL)resignFirstResponder
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
41321:   if (mIsPluginView && mPluginEventModel == NPEventModelCocoa) {
57526:     if (![self updateCocoaPluginFocusStatus:NO])
57526:       return NO;
41321:   }
41321: 
 2315:   return [super resignFirstResponder];
11978: 
41321:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(YES);
 2315: }
 2315: 
 2315: - (void)viewsWindowDidBecomeKey
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2315:   if (!mGeckoChild)
 2462:     return;
 2315: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 2315:   // check to see if the window implements the mozWindow protocol. This
 2315:   // allows embedders to avoid re-entrant calls to -makeKeyAndOrderFront,
29018:   // which can happen because these activate calls propagate out
 2315:   // to the embedder via nsIEmbeddingSiteWindow::SetFocus().
 2315:   BOOL isMozWindow = [[self window] respondsToSelector:@selector(setSuppressMakeKeyFront:)];
 2315:   if (isMozWindow)
 2315:     [[self window] setSuppressMakeKeyFront:YES];
 2315: 
 4208:   [self sendFocusEvent:NS_ACTIVATE];
 2315: 
 2315:   if (isMozWindow)
 2315:     [[self window] setSuppressMakeKeyFront:NO];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: - (void)viewsWindowDidResignKey
 2315: {
 2315:   if (!mGeckoChild)
 2462:     return;
 2315: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 4208:   [self sendFocusEvent:NS_DEACTIVATE];
 2315: }
 2315: 
 2677: // If the call to removeFromSuperview isn't delayed from nsChildView::
 2677: // TearDownView(), the NSView hierarchy might get changed during calls to
 2677: // [ChildView drawRect:], which leads to "beyond bounds" exceptions in
 2677: // NSCFArray.  For more info see bmo bug 373122.  Apple's docs claim that
 2315: // removeFromSuperviewWithoutNeedingDisplay "can be safely invoked during
 2315: // display" (whatever "display" means).  But it's _not_ true that it can be
 2677: // safely invoked during calls to [NSView drawRect:].  We use
 2677: // removeFromSuperview here because there's no longer any danger of being
 2677: // "invoked during display", and because doing do clears up bmo bug 384343.
 2315: - (void)delayedTearDown
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2677:   [self removeFromSuperview];
 2315:   [self release];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
    1: #pragma mark -
    1: 
    1: // drag'n'drop stuff
    1: #define kDragServiceContractID "@mozilla.org/widget/dragservice;1"
    1: 
39094: - (NSDragOperation)dragOperationForSession:(nsIDragSession*)aDragSession
39094: {
39094:   PRUint32 dragAction;
39094:   aDragSession->GetDragAction(&dragAction);
39094:   if (nsIDragService::DRAGDROP_ACTION_LINK & dragAction)
39094:     return NSDragOperationLink;
39094:   if (nsIDragService::DRAGDROP_ACTION_COPY & dragAction)
39094:     return NSDragOperationCopy;
39094:   if (nsIDragService::DRAGDROP_ACTION_MOVE & dragAction)
39094:     return NSDragOperationGeneric;
39094:   return NSDragOperationNone;
39094: }
39094: 
    1: // This is a utility function used by NSView drag event methods
    1: // to send events. It contains all of the logic needed for Gecko
39094: // dragging to work. Returns the appropriate cocoa drag operation code.
39094: - (NSDragOperation)doDragAction:(PRUint32)aMessage sender:(id)aSender
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 2958:   if (!mGeckoChild)
39094:     return NSDragOperationNone;
    1: 
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView doDragAction: entered\n"));
 3545: 
 2958:   if (!mDragService) {
 2958:     CallGetService(kDragServiceContractID, &mDragService);
 2958:     NS_ASSERTION(mDragService, "Couldn't get a drag service - big problem!");
 2958:     if (!mDragService)
39094:       return NSDragOperationNone;
 2958:   }
 2958: 
    1:   if (aMessage == NS_DRAGDROP_ENTER)
    1:     mDragService->StartDragSession();
    1: 
    1:   nsCOMPtr<nsIDragSession> dragSession;
    1:   mDragService->GetCurrentSession(getter_AddRefs(dragSession));
    1:   if (dragSession) {
  482:     if (aMessage == NS_DRAGDROP_OVER) {
  482:       // fire the drag event at the source. Just ignore whether it was
  482:       // cancelled or not as there isn't actually a means to stop the drag
  482:       mDragService->FireDragEventAtSource(NS_DRAGDROP_DRAG);
    1:       dragSession->SetCanDrop(PR_FALSE);
  482:     }
    1:     else if (aMessage == NS_DRAGDROP_DROP) {
16085:       // We make the assumption that the dragOver handlers have correctly set
    1:       // the |canDrop| property of the Drag Session.
    1:       PRBool canDrop = PR_FALSE;
18445:       if (!NS_SUCCEEDED(dragSession->GetCanDrop(&canDrop)) || !canDrop) {
37791:         [self doDragAction:NS_DRAGDROP_EXIT sender:aSender];
37791: 
18445:         nsCOMPtr<nsIDOMNode> sourceNode;
18445:         dragSession->GetSourceNode(getter_AddRefs(sourceNode));
18445:         if (!sourceNode) {
18445:           mDragService->EndDragSession(PR_FALSE);
18445:         }
39094:         return NSDragOperationNone;
    1:       }
18445:     }
    1:     
38441:     unsigned int modifierFlags = [[NSApp currentEvent] modifierFlags];
    1:     PRUint32 action = nsIDragService::DRAGDROP_ACTION_MOVE;
    1:     // force copy = option, alias = cmd-option, default is move
    1:     if (modifierFlags & NSAlternateKeyMask) {
    1:       if (modifierFlags & NSCommandKeyMask)
    1:         action = nsIDragService::DRAGDROP_ACTION_LINK;
    1:       else
    1:         action = nsIDragService::DRAGDROP_ACTION_COPY;
    1:     }
    1:     dragSession->SetDragAction(action);
    1:   }
    1: 
 6754:   // set up gecko event
18445:   nsDragEvent geckoEvent(PR_TRUE, aMessage, nsnull);
39092:   [self convertGenericCocoaEvent:[NSApp currentEvent] toGeckoEvent:&geckoEvent];
 6754: 
 6754:   // Use our own coordinates in the gecko event.
 6754:   // Convert event from gecko global coords to gecko view coords.
 6754:   NSPoint localPoint = [self convertPoint:[aSender draggingLocation] fromView:nil];
 6754:   geckoEvent.refPoint.x = static_cast<nscoord>(localPoint.x);
 6754:   geckoEvent.refPoint.y = static_cast<nscoord>(localPoint.y);
 6754: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 6754:   mGeckoChild->DispatchWindowEvent(geckoEvent);
10305:   if (!mGeckoChild)
39094:     return NSDragOperationNone;
39094: 
39094:   if (dragSession) {
39094:     switch (aMessage) {
39094:       case NS_DRAGDROP_ENTER:
39094:       case NS_DRAGDROP_OVER:
39094:         return [self dragOperationForSession:dragSession];
39094:       case NS_DRAGDROP_EXIT:
39094:       case NS_DRAGDROP_DROP: {
    1:         nsCOMPtr<nsIDOMNode> sourceNode;
    1:         dragSession->GetSourceNode(getter_AddRefs(sourceNode));
    1:         if (!sourceNode) {
    1:           // We're leaving a window while doing a drag that was
    1:           // initiated in a different app. End the drag session,
    1:           // since we're done with it for now (until the user
    1:           // drags back into mozilla).
  482:           mDragService->EndDragSession(PR_FALSE);
    1:         }
    1:       }
39094:     }
39094:   }
39094: 
39094:   return NSDragOperationGeneric;
39094: 
39094:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSDragOperationNone);
    1: }
    1: 
    1: - (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingEntered: entered\n"));
 3545:   
    1:   // there should never be a globalDragPboard when "draggingEntered:" is
    1:   // called, but just in case we'll take care of it here.
    1:   [globalDragPboard release];
    1: 
    1:   // Set the global drag pasteboard that will be used for this drag session.
    1:   // This will be set back to nil when the drag session ends (mouse exits
    1:   // the view or a drop happens within the view).
    1:   globalDragPboard = [[sender draggingPasteboard] retain];
    1: 
39094:   return [self doDragAction:NS_DRAGDROP_ENTER sender:sender];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSDragOperationNone);
    1: }
    1: 
    1: - (NSDragOperation)draggingUpdated:(id <NSDraggingInfo>)sender
    1: {
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingUpdated: entered\n"));
 3545: 
39094:   return [self doDragAction:NS_DRAGDROP_OVER sender:sender];
    1: }
    1: 
    1: - (void)draggingExited:(id <NSDraggingInfo>)sender
    1: {
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingExited: entered\n"));
 3545: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
    1:   [self doDragAction:NS_DRAGDROP_EXIT sender:sender];
 6789:   NS_IF_RELEASE(mDragService);
 2958: }
 2958: 
 2958: - (BOOL)performDragOperation:(id <NSDraggingInfo>)sender
 2958: {
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
39094:   BOOL handled = [self doDragAction:NS_DRAGDROP_DROP sender:sender] != NSDragOperationNone;
 6789:   NS_IF_RELEASE(mDragService);
 6789:   return handled;
 2958: }
 2958: 
 2958: // NSDraggingSource
 2958: - (void)draggedImage:(NSImage *)anImage endedAt:(NSPoint)aPoint operation:(NSDragOperation)operation
 2958: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 3592:   gDraggedTransferables = nsnull;
 3592: 
25064:   NSEvent *currentEvent = [NSApp currentEvent];
25064:   gUserCancelledDrag = ([currentEvent type] == NSKeyDown &&
25064:                         [currentEvent keyCode] == kEscapeKeyCode);
25064: 
 2958:   if (!mDragService) {
 2958:     CallGetService(kDragServiceContractID, &mDragService);
 2958:     NS_ASSERTION(mDragService, "Couldn't get a drag service - big problem!");
 2958:   }
 2958: 
 2958:   if (mDragService) {
27257:     // set the dragend point from the current mouse location
27257:     nsDragService* dragService = static_cast<nsDragService *>(mDragService);
27257:     NSPoint pnt = [NSEvent mouseLocation];
27257:     FlipCocoaScreenCoordinate(pnt);
27401:     dragService->SetDragEndPoint(nsIntPoint(NSToIntRound(pnt.x), NSToIntRound(pnt.y)));
27257: 
28780:     // XXX: dropEffect should be updated per |operation|. 
28780:     // As things stand though, |operation| isn't well handled within "our"
28780:     // events, that is, when the drop happens within the window: it is set
28780:     // either to NSDragOperationGeneric or to NSDragOperationNone.
28780:     // For that reason, it's not yet possible to override dropEffect per the
28780:     // given OS value, and it's also unclear what's the correct dropEffect 
28780:     // value for NSDragOperationGeneric that is passed by other applications.
28780:     // All that said, NSDragOperationNone is still reliable.
28780:     if (operation == NSDragOperationNone) {
28780:       nsCOMPtr<nsIDOMDataTransfer> dataTransfer;
28780:       dragService->GetDataTransfer(getter_AddRefs(dataTransfer));
28780:       nsCOMPtr<nsIDOMNSDataTransfer> dataTransferNS =
28780:         do_QueryInterface(dataTransfer);
28780: 
28780:       if (dataTransferNS)
28780:         dataTransferNS->SetDropEffectInt(nsIDragService::DRAGDROP_ACTION_NONE);
28780:     }
28780: 
 2958:     mDragService->EndDragSession(PR_TRUE);
 2958:     NS_RELEASE(mDragService);
 2958:   }
 2958: 
    1:   [globalDragPboard release];
    1:   globalDragPboard = nil;
34629:   [gLastDragMouseDownEvent release];
34629:   gLastDragMouseDownEvent = nil;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
 2958: // NSDraggingSource
 2958: // this is just implemented so we comply with the NSDraggingSource informal protocol
32120: - (NSDragOperation)draggingSourceOperationMaskForLocal:(BOOL)isLocal
    1: {
 2958:   return UINT_MAX;
    1: }
    1: 
 3545: // This method is a callback typically invoked in response to a drag ending on the desktop
 3545: // or a Findow folder window; the argument passed is a path to the drop location, to be used
 3545: // in constructing a complete pathname for the file(s) we want to create as a result of
 3545: // the drag.
32120: - (NSArray *)namesOfPromisedFilesDroppedAtDestination:(NSURL*)dropDestination
 3545: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 3545:   nsresult rv;
 3545: 
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView namesOfPromisedFilesDroppedAtDestination: entering callback for promised files\n"));
 3545: 
 3545:   nsCOMPtr<nsILocalFile> targFile;
 3545:   NS_NewLocalFile(EmptyString(), PR_TRUE, getter_AddRefs(targFile));
 3545:   nsCOMPtr<nsILocalFileMac> macLocalFile = do_QueryInterface(targFile);
 3545:   if (!macLocalFile) {
 3545:     NS_ERROR("No Mac local file");
 3545:     return nil;
 3545:   }
 3545: 
 3545:   if (!NS_SUCCEEDED(macLocalFile->InitWithCFURL((CFURLRef)dropDestination))) {
 3545:     NS_ERROR("failed InitWithCFURL");
 3545:     return nil;
 3545:   }
 3545: 
 3592:   if (!gDraggedTransferables)
 3592:     return nil;
 3545: 
 3545:   PRUint32 transferableCount;
 3592:   rv = gDraggedTransferables->Count(&transferableCount);
 3545:   if (NS_FAILED(rv))
 3545:     return nil;
 3545: 
 3545:   for (PRUint32 i = 0; i < transferableCount; i++) {
 3545:     nsCOMPtr<nsISupports> genericItem;
 3592:     gDraggedTransferables->GetElementAt(i, getter_AddRefs(genericItem));
 3545:     nsCOMPtr<nsITransferable> item(do_QueryInterface(genericItem));
 3545:     if (!item) {
 3545:       NS_ERROR("no transferable");
 3545:       return nil;
 3545:     }
 3545: 
 3545:     item->SetTransferData(kFilePromiseDirectoryMime, macLocalFile, sizeof(nsILocalFile*));
 3545:     
 3545:     // now request the kFilePromiseMime data, which will invoke the data provider
 3545:     // If successful, the returned data is a reference to the resulting file.
 3545:     nsCOMPtr<nsISupports> fileDataPrimitive;
 3545:     PRUint32 dataSize = 0;
 3545:     item->GetTransferData(kFilePromiseMime, getter_AddRefs(fileDataPrimitive), &dataSize);
 3545:   }
 3545:   
 3545:   NSPasteboard* generalPboard = [NSPasteboard pasteboardWithName:NSDragPboard];
 3545:   NSData* data = [generalPboard dataForType:@"application/x-moz-file-promise-dest-filename"];
 3545:   NSString* name = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
 3545:   NSArray* rslt = [NSArray arrayWithObject:name];
 3545: 
 3545:   [name release];
 3545: 
 3545:   return rslt;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 3545: }
    1: 
22821: #pragma mark -
22821: 
22821: // Support for the "Services" menu. We currently only support sending strings
26757: // and HTML to system services.
22821: 
22821: - (id)validRequestorForSendType:(NSString *)sendType
22821:                      returnType:(NSString *)returnType
22821: {
22821:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
22821: 
22821:   // sendType contains the type of data that the service would like this
22821:   // application to send to it.  sendType is nil if the service is not
22821:   // requesting any data.
22821:   //
22821:   // returnType contains the type of data the the service would like to
22821:   // return to this application (e.g., to overwrite the selection).
22821:   // returnType is nil if the service will not return any data.
22821:   //
22821:   // The following condition thus triggers when the service expects a string
36983:   // or HTML from us or no data at all AND when the service will either not
36983:   // send back any data to us or will send a string or HTML back to us.
36983: 
36983: #define IsSupportedType(typeStr) ([typeStr isEqual:NSStringPboardType] || [typeStr isEqual:NSHTMLPboardType])
36983: 
36983:   id result = nil;
36983: 
36983:   if ((!sendType || IsSupportedType(sendType)) &&
36983:       (!returnType || IsSupportedType(returnType))) {
22821:     if (mGeckoChild) {
36983:       // Assume that this object will be able to handle this request.
36983:       result = self;
36983: 
36983:       // Keep the ChildView alive during this operation.
22821:       nsAutoRetainCocoaObject kungFuDeathGrip(self);
26757:       
36983:       // Determine if there is a selection (if sending to the service).
36983:       if (sendType) {
26757:         nsQueryContentEvent event(PR_TRUE, NS_QUERY_CONTENT_STATE, mGeckoChild);
39229:         // This might destroy our widget (and null out mGeckoChild).
26757:         mGeckoChild->DispatchWindowEvent(event);
39229:         if (!mGeckoChild || !event.mSucceeded || !event.mReply.mHasSelection)
36983:           result = nil;
36983:       }
36983: 
36983:       // Determine if we can paste (if receiving data from the service).
39229:       if (mGeckoChild && returnType) {
36983:         nsContentCommandEvent command(PR_TRUE, NS_CONTENT_COMMAND_PASTE_TRANSFERABLE, mGeckoChild, PR_TRUE);
39229:         // This might possibly destroy our widget (and null out mGeckoChild).
36983:         mGeckoChild->DispatchWindowEvent(command);
39229:         if (!mGeckoChild || !command.mSucceeded || !command.mIsEnabled)
36983:           result = nil;
36983:       }
36983:     }
36983:   }
36983: 
36983: #undef IsSupportedType
36983: 
36983:   // Give the superclass a chance if this object will not handle this request.
36983:   if (!result)
36983:     result = [super validRequestorForSendType:sendType returnType:returnType];
36983: 
36983:   return result;
22821: 
22821:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
22821: }
22821: 
22821: - (BOOL)writeSelectionToPasteboard:(NSPasteboard *)pboard
22821:                              types:(NSArray *)types
22821: {
22821:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
22821: 
22821:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
22821: 
26757:   // Make sure that the service will accept strings or HTML.
26757:   if ([types containsObject:NSStringPboardType] == NO &&
26757:       [types containsObject:NSHTMLPboardType] == NO)
22821:     return NO;
22821: 
26757:   // Bail out if there is no Gecko object.
22821:   if (!mGeckoChild)
22821:     return NO;
26757: 
26757:   // Obtain the current selection.
26757:   nsQueryContentEvent event(PR_TRUE,
26757:                             NS_QUERY_SELECTION_AS_TRANSFERABLE,
26757:                             mGeckoChild);
26757:   mGeckoChild->DispatchWindowEvent(event);
26757:   if (!event.mSucceeded || !event.mReply.mTransferable)
22821:     return NO;
22821: 
26757:   // Transform the transferable to an NSDictionary.
26757:   NSDictionary* pasteboardOutputDict = nsClipboard::PasteboardDictFromTransferable(event.mReply.mTransferable);
26757:   if (!pasteboardOutputDict)
26757:     return NO;
26757: 
26757:   // Declare the pasteboard types.
26757:   unsigned int typeCount = [pasteboardOutputDict count];
26757:   NSMutableArray * types = [NSMutableArray arrayWithCapacity:typeCount];
26757:   [types addObjectsFromArray:[pasteboardOutputDict allKeys]];
26757:   [pboard declareTypes:types owner:nil];
26757: 
26757:   // Write the data to the pasteboard.
26757:   for (unsigned int i = 0; i < typeCount; i++) {
26757:     NSString* currentKey = [types objectAtIndex:i];
26757:     id currentValue = [pasteboardOutputDict valueForKey:currentKey];
26757: 
26757:     if (currentKey == NSStringPboardType ||
26757:         currentKey == kCorePboardType_url ||
26757:         currentKey == kCorePboardType_urld ||
26757:         currentKey == kCorePboardType_urln) {
26757:       [pboard setString:currentValue forType:currentKey];
26757:     } else if (currentKey == NSHTMLPboardType) {
26757:       [pboard setString:(nsClipboard::WrapHtmlForSystemPasteboard(currentValue)) forType:currentKey];
26757:     } else if (currentKey == NSTIFFPboardType) {
26757:       [pboard setData:currentValue forType:currentKey];
26757:     } else if (currentKey == NSFilesPromisePboardType) {
26757:       [pboard setPropertyList:currentValue forType:currentKey];        
26757:     }
26757:   }
26757: 
26757:   return YES;
22821: 
22821:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
22821: }
22821: 
36983: // Called if the service wants us to replace the current selection.
22821: - (BOOL)readSelectionFromPasteboard:(NSPasteboard *)pboard
22821: {
36983:   nsresult rv;
36983:   nsCOMPtr<nsITransferable> trans = do_CreateInstance("@mozilla.org/widget/transferable;1", &rv);
36983:   if (NS_FAILED(rv))
22821:     return NO;
36983: 
36983:   trans->AddDataFlavor(kUnicodeMime);
36983:   trans->AddDataFlavor(kHTMLMime);
36983: 
36983:   rv = nsClipboard::TransferableFromPasteboard(trans, pboard);
36983:   if (NS_FAILED(rv))
36983:     return NO;
36983: 
36983:   if (!mGeckoChild)
36983:     return NO;
36983: 
36983:   nsContentCommandEvent command(PR_TRUE,
36983:                                 NS_CONTENT_COMMAND_PASTE_TRANSFERABLE,
36983:                                 mGeckoChild);
36983:   command.mTransferable = trans;
36983:   mGeckoChild->DispatchWindowEvent(command);
36983:   
36983:   return command.mSucceeded && command.mIsEnabled;
22821: }
22821: 
    1: #pragma mark -
    1: 
    1: #ifdef ACCESSIBILITY
    1: 
    1: /* Every ChildView has a corresponding mozDocAccessible object that is doing all
    1:    the heavy lifting. The topmost ChildView corresponds to a mozRootAccessible
    1:    object.
    1: 
    1:    All ChildView needs to do is to route all accessibility calls (from the NSAccessibility APIs)
    1:    down to its object, pretending that they are the same.
    1: */
    1: - (id<mozAccessible>)accessible
    1: {
 2462:   if (!mGeckoChild)
 2462:     return nil;
 2462: 
    1:   id<mozAccessible> nativeAccessible = nil;
    1: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305:   nsCOMPtr<nsIWidget> kungFuDeathGrip2(mGeckoChild);
42313:   nsRefPtr<nsAccessible> accessible = mGeckoChild->GetDocumentAccessible();
10305:   if (!mGeckoChild)
10305:     return nil;
    1: 
    1:   if (accessible)
    1:     accessible->GetNativeInterface((void**)&nativeAccessible);
    1: 
    1: #ifdef DEBUG_hakan
    1:   NSAssert(![nativeAccessible isExpired], @"native acc is expired!!!");
    1: #endif
    1:   
    1:   return nativeAccessible;
    1: }
    1: 
    1: /* Implementation of formal mozAccessible formal protocol (enabling mozViews
    1:    to talk to mozAccessible objects in the accessibility module). */
    1: 
    1: - (BOOL)hasRepresentedView
    1: {
    1:   return YES;
    1: }
    1: 
    1: - (id)representedView
    1: {
    1:   return self;
    1: }
    1: 
    1: - (BOOL)isRoot
    1: {
    1:   return [[self accessible] isRoot];
    1: }
    1: 
    1: #ifdef DEBUG
    1: - (void)printHierarchy
    1: {
    1:   [[self accessible] printHierarchy];
    1: }
    1: #endif
    1: 
    1: #pragma mark -
    1: 
    1: // general
    1: 
    1: - (BOOL)accessibilityIsIgnored
    1: {
    1:   return [[self accessible] accessibilityIsIgnored];
    1: }
    1: 
    1: - (id)accessibilityHitTest:(NSPoint)point
    1: {
    1:   return [[self accessible] accessibilityHitTest:point];
    1: }
    1: 
    1: - (id)accessibilityFocusedUIElement
    1: {
    1:   return [[self accessible] accessibilityFocusedUIElement];
    1: }
    1: 
    1: // actions
    1: 
    1: - (NSArray*)accessibilityActionNames
    1: {
    1:   return [[self accessible] accessibilityActionNames];
    1: }
    1: 
    1: - (NSString*)accessibilityActionDescription:(NSString*)action
    1: {
    1:   return [[self accessible] accessibilityActionDescription:action];
    1: }
    1: 
    1: - (void)accessibilityPerformAction:(NSString*)action
    1: {
    1:   return [[self accessible] accessibilityPerformAction:action];
    1: }
    1: 
    1: // attributes
    1: 
    1: - (NSArray*)accessibilityAttributeNames
    1: {
    1:   return [[self accessible] accessibilityAttributeNames];
    1: }
    1: 
    1: - (BOOL)accessibilityIsAttributeSettable:(NSString*)attribute
    1: {
    1:   return [[self accessible] accessibilityIsAttributeSettable:attribute];
    1: }
    1: 
    1: - (id)accessibilityAttributeValue:(NSString*)attribute
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   id<mozAccessible> accessible = [self accessible];
    1:   
    1:   // if we're the root (topmost) accessible, we need to return our native AXParent as we
    1:   // traverse outside to the hierarchy of whoever embeds us. thus, fall back on NSView's
    1:   // default implementation for this attribute.
    1:   if ([attribute isEqualToString:NSAccessibilityParentAttribute] && [accessible isRoot]) {
    1:     id parentAccessible = [super accessibilityAttributeValue:attribute];
    1:     return parentAccessible;
    1:   }
    1: 
    1:   return [accessible accessibilityAttributeValue:attribute];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: #endif /* ACCESSIBILITY */
    1: 
    1: @end
  539: 
32976: #pragma mark -
32976: 
32976: void
32976: ChildViewMouseTracker::OnDestroyView(ChildView* aView)
32976: {
32976:   if (sLastMouseEventView == aView)
32976:     sLastMouseEventView = nil;
32976: }
32976: 
32976: void
35621: ChildViewMouseTracker::ReEvaluateMouseEnterState(NSEvent* aEvent)
32976: {
34051:   ChildView* oldView = sLastMouseEventView;
35621:   sLastMouseEventView = ViewForEvent(aEvent);
35621:   if (sLastMouseEventView != oldView) {
32976:     // Send enter and / or exit events.
35621:     nsMouseEvent::exitType type = [sLastMouseEventView window] == [oldView window] ?
32976:                                     nsMouseEvent::eChild : nsMouseEvent::eTopLevel;
34051:     [oldView sendMouseEnterOrExitEvent:aEvent enter:NO type:type];
32976:     // After the cursor exits the window set it to a visible regular arrow cursor.
32976:     if (type == nsMouseEvent::eTopLevel) {
32976:       [[nsCursorManager sharedInstance] setCursor:eCursor_standard];
32976:     }
35621:     [sLastMouseEventView sendMouseEnterOrExitEvent:aEvent enter:YES type:type];
35621:   }
35621: }
35621: 
35621: void
35621: ChildViewMouseTracker::MouseMoved(NSEvent* aEvent)
35621: {
35621:   ReEvaluateMouseEnterState(aEvent);
35621:   [sLastMouseEventView handleMouseMoved:aEvent];
32976: }
32976: 
32976: ChildView*
32976: ChildViewMouseTracker::ViewForEvent(NSEvent* aEvent)
32976: {
32976:   NSWindow* window = WindowForEvent(aEvent);
47792:   if (!window)
32976:     return nil;
32976: 
32976:   NSPoint windowEventLocation = nsCocoaUtils::EventLocationForWindow(aEvent, window);
32976:   NSView* view = [[[window contentView] superview] hitTest:windowEventLocation];
32976:   NS_ASSERTION(view, "How can the mouse be over a window but not over a view in that window?");
47792:   if (![view isKindOfClass:[ChildView class]])
47792:     return nil;
47792: 
47792:   ChildView* childView = (ChildView*)view;
49214:   // If childView is being destroyed return nil.
49214:   if (![childView widget])
49214:     return nil;
47792:   return WindowAcceptsEvent(window, aEvent, childView) ? childView : nil;
32976: }
32976: 
36745: static CGWindowLevel kDockWindowLevel = 0;
36745: static CGWindowLevel kPopupWindowLevel = 0;
36745: static CGWindowLevel kFloatingWindowLevel = 0;
36745: 
36745: static BOOL WindowNumberIsUnderPoint(NSInteger aWindowNumber, NSPoint aPoint) {
36745:   NSWindow* window = [NSApp windowWithWindowNumber:aWindowNumber];
36745:   if (window) {
36745:     // This is one of our own windows.
36745:     return NSMouseInRect(aPoint, [window frame], NO);
36745:   }
36745: 
36745:   CGSConnection cid = _CGSDefaultConnection();
36745: 
36745:   if (!kDockWindowLevel) {
36745:     // These constants are in fact function calls, so cache them.
36745:     kDockWindowLevel = kCGDockWindowLevel;
36745:     kPopupWindowLevel = kCGPopUpMenuWindowLevel;
36745:     kFloatingWindowLevel = kCGFloatingWindowLevel;
36745:   }
36745: 
36745:   // Some things put transparent windows on top of everything. Ignore them.
36745:   CGWindowLevel level;
36745:   if ((kCGErrorSuccess == CGSGetWindowLevel(cid, aWindowNumber, &level)) &&
36745:       (level == kDockWindowLevel ||     // Transparent layer, spanning the whole screen
36745:        level == kFloatingWindowLevel || // invisible Jing window
36745:        level > kPopupWindowLevel))      // Snapz Pro X while recording a screencast
36745:     return false;
36745: 
55856:   // Ignore transparent windows.
55856:   float alpha;
55856:   if ((kCGErrorSuccess == CGSGetWindowAlpha(cid, aWindowNumber, &alpha)) &&
55856:       alpha < 0.1f)
55856:     return false;
55856: 
36745:   CGRect rect;
36745:   if (kCGErrorSuccess != CGSGetScreenRectForWindow(cid, aWindowNumber, &rect))
36745:     return false;
36745: 
36745:   CGPoint point = { aPoint.x, nsCocoaUtils::FlippedScreenY(aPoint.y) };
36745:   return CGRectContainsPoint(rect, point);
36745: }
36745: 
36745: // Find the window number of the window under the given point, regardless of
36745: // which app the window belongs to. Returns 0 if no window was found.
36745: static NSInteger WindowNumberAtPoint(NSPoint aPoint) {
48710:   // We'd like to use the new windowNumberAtPoint API on 10.6 but we can't rely
48710:   // on it being up-to-date. For example, if we've just opened a window,
48710:   // windowNumberAtPoint might not know about it yet, so we'd send events to the
48710:   // wrong window. See bug 557986.
48710:   // So we'll have to find the right window manually by iterating over all
48710:   // windows on the screen and testing whether the mouse is inside the window's
48710:   // rect. We do this using private CGS functions.
36745:   // Another way of doing it would be to use tracking rects, but those are
36745:   // view-controlled, so they need to be reset whenever an NSView changes its
36745:   // size or position, which is expensive. See bug 300904 comment 20.
36745:   // A problem with using the CGS functions is that we only look at the windows'
36745:   // rects, not at the transparency of the actual pixel the mouse is over. This
36745:   // means that we won't treat transparent pixels as transparent to mouse
36745:   // events, which is a disadvantage over using tracking rects and leads to the
36745:   // crummy window level workarounds in WindowNumberIsUnderPoint.
36745:   // But speed is more important.
36745: 
36745:   // Get the window list.
32976:   NSInteger windowCount;
32976:   NSCountWindows(&windowCount);
32976:   NSInteger* windowList = (NSInteger*)malloc(sizeof(NSInteger) * windowCount);
32976:   if (!windowList)
32976:     return nil;
36745: 
32976:   // The list we get back here is in order from front to back.
32976:   NSWindowList(windowCount, windowList);
36745:   for (NSInteger i = 0; i < windowCount; i++) {
36745:     NSInteger windowNumber = windowList[i];
36745:     if (WindowNumberIsUnderPoint(windowNumber, aPoint)) {
36745:       free(windowList);
36745:       return windowNumber;
36745:     }
36745:   }
36745: 
36745:   free(windowList);
36745:   return 0;
36745: }
36745: 
36745: // Find Gecko window under the mouse. Returns nil if the mouse isn't over
36745: // any of our windows.
36745: NSWindow*
36745: ChildViewMouseTracker::WindowForEvent(NSEvent* anEvent)
36745: {
36745:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
32976: 
32976:   NSPoint screenPoint = nsCocoaUtils::ScreenLocationForEvent(anEvent);
36745:   NSInteger windowNumber = WindowNumberAtPoint(screenPoint);
36745: 
36745:   // This will return nil if windowNumber belongs to a window that we don't own.
36745:   return [NSApp windowWithWindowNumber:windowNumber];
32976: 
32976:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
32976: }
32976: 
32976: BOOL
47792: ChildViewMouseTracker::WindowAcceptsEvent(NSWindow* aWindow, NSEvent* aEvent,
47792:                                           ChildView* aView, BOOL aIsClickThrough)
32976: {
32976:   // Right mouse down events may get through to all windows, even to a top level
32976:   // window with an open sheet.
42317:   if (!aWindow || [aEvent type] == NSRightMouseDown)
32976:     return YES;
32976: 
32976:   id delegate = [aWindow delegate];
32976:   if (!delegate || ![delegate isKindOfClass:[WindowDelegate class]])
32976:     return YES;
32976: 
32976:   nsIWidget *windowWidget = [(WindowDelegate *)delegate geckoWidget];
32976:   if (!windowWidget)
32976:     return YES;
32976: 
32976:   nsWindowType windowType;
32976:   windowWidget->GetWindowType(windowType);
32976: 
42317:   NSWindow* topLevelWindow = nil;
42317: 
32976:   switch (windowType) {
32976:     case eWindowType_popup:
32976:       // If this is a context menu, it won't have a parent. So we'll always
32976:       // accept mouse move events on context menus even when none of our windows
32976:       // is active, which is the right thing to do.
32976:       // For panels, the parent window is the XUL window that owns the panel.
47792:       return WindowAcceptsEvent([aWindow parentWindow], aEvent, aView, aIsClickThrough);
32976: 
32976:     case eWindowType_toplevel:
32976:     case eWindowType_dialog:
42317:       if ([aWindow attachedSheet])
42317:         return NO;
42317: 
42317:       topLevelWindow = aWindow;
42317:       break;
32976:     case eWindowType_sheet: {
32976:       nsIWidget* parentWidget = windowWidget->GetSheetWindowParent();
32976:       if (!parentWidget)
32976:         return YES;
32976: 
42317:       topLevelWindow = (NSWindow*)parentWidget->GetNativeData(NS_NATIVE_WINDOW);
42317:       break;
32976:     }
32976: 
32976:     default:
32976:       return YES;
32976:   }
42317: 
42317:   if (!topLevelWindow ||
47792:       ([topLevelWindow isMainWindow] && !aIsClickThrough) ||
42317:       [aEvent type] == NSOtherMouseDown ||
42317:       (([aEvent modifierFlags] & NSCommandKeyMask) != 0 &&
42317:        [aEvent type] != NSMouseMoved))
42317:     return YES;
42317: 
42317:   // If we're here then we're dealing with a left click or mouse move on an
47792:   // inactive window or something similar. Ask Gecko what to do.
47792:   return [aView inactiveWindowAcceptsMouseEvent:aEvent];
32976: }
32976: 
32976: #pragma mark -
32976: 
33318: #ifndef NP_NO_CARBON
33318: 
15585: // Target for text services events sent as the result of calls made to
15585: // TSMProcessRawKeyEvent() in [ChildView keyDown:] (above) when a plugin has
15585: // the focus.  The calls to TSMProcessRawKeyEvent() short-circuit Cocoa-based
15585: // IME (which would otherwise interfere with our efforts) and allow Carbon-
15585: // based IME to work in plugins (via the NPAPI).  This strategy doesn't cause
15585: // trouble for plugins that (like the Java Embedding Plugin) bypass the NPAPI
15585: // to get their keyboard events and do their own Cocoa-based IME.
15585: OSStatus PluginKeyEventsHandler(EventHandlerCallRef inHandlerRef,
15585:                                 EventRef inEvent, void *userData)
15585: {
40740:   nsAutoreleasePool localPool;
15585: 
15585:   TSMDocumentID activeDoc = ::TSMGetActiveDocument();
15585:   if (!activeDoc) {
15585:     return eventNotHandledErr;
15585:   }
15585: 
15585:   ChildView *target = nil;
15585:   OSStatus status = ::TSMGetDocumentProperty(activeDoc, kFocusedChildViewTSMDocPropertyTag,
15585:                                              sizeof(ChildView *), nil, &target);
15585:   if (status != noErr)
15585:     target = nil;
15585:   if (!target) {
15585:     return eventNotHandledErr;
15585:   }
15585: 
15585:   EventRef keyEvent = NULL;
15585:   status = ::GetEventParameter(inEvent, kEventParamTextInputSendKeyboardEvent,
15585:                                typeEventRef, NULL, sizeof(EventRef), NULL, &keyEvent);
15585:   if ((status != noErr) || !keyEvent) {
15585:     return eventNotHandledErr;
15585:   }
15585: 
15585:   [target processPluginKeyEvent:keyEvent];
15585: 
15585:   return noErr;
15585: }
15585: 
15585: static EventHandlerRef gPluginKeyEventsHandler = NULL;
15585: 
15585: // Called from nsAppShell::Init()
15585: void NS_InstallPluginKeyEventsHandler()
15585: {
15585:   if (gPluginKeyEventsHandler)
15585:     return;
15585:   static const EventTypeSpec sTSMEvents[] =
15585:     { { kEventClassTextInput, kEventTextInputUnicodeForKeyEvent } };
15585:   ::InstallEventHandler(::GetEventDispatcherTarget(),
15585:                         ::NewEventHandlerUPP(PluginKeyEventsHandler),
15585:                         GetEventTypeCount(sTSMEvents),
15585:                         sTSMEvents,
15585:                         NULL,
15585:                         &gPluginKeyEventsHandler);
15585: }
15585: 
15585: // Called from nsAppShell::Exit()
15585: void NS_RemovePluginKeyEventsHandler()
15585: {
15585:   if (!gPluginKeyEventsHandler)
15585:     return;
15585:   ::RemoveEventHandler(gPluginKeyEventsHandler);
15585:   gPluginKeyEventsHandler = NULL;
15585: }
24707: 
61078: // IMKInputSession is an undocumented class in the HIToolbox framework.  It's
61078: // present on both Leopard and SnowLeopard, and is used at a low level to
61078: // process IME input regardless of which high-level API is used (Text Services
61078: // Manager or Cocoa).  It works the same way in both 32-bit and 64-bit code.
61078: @interface NSObject (IMKInputSessionMethodSwizzling)
61078: - (BOOL)nsChildView_IMKInputSession_handleEvent:(EventRef)theEvent;
61078: - (void)nsChildView_IMKInputSession_commitComposition;
61078: - (void)nsChildView_IMKInputSession_finishSession;
61078: @end
61078: 
61078: @implementation NSObject (IMKInputSessionMethodSwizzling)
61078: 
61078: - (BOOL)nsChildView_IMKInputSession_handleEvent:(EventRef)theEvent
61078: {
61078:   [self retain];
61078:   BOOL retval = [self nsChildView_IMKInputSession_handleEvent:theEvent];
61078:   NSUInteger retainCount = [self retainCount];
61078:   [self release];
61078:   // Return without doing anything if we've been deleted.
61078:   if (retainCount == 1) {
61078:     return retval;
61078:   }
61078: 
61078:   NSWindow *mainWindow = [NSApp mainWindow];
61078:   NSResponder *firstResponder = [mainWindow firstResponder];
61078:   if (![firstResponder isKindOfClass:[ChildView class]]) {
61078:     return retval;
61078:   }
61078: 
61078:   // 'charactersEntered' is the length (in bytes) of currently "marked text"
61078:   // -- text that's been entered in IME but not yet committed.  If it's
61078:   // non-zero we're composing text in an IME session; if it's zero we're
61078:   // not in an IME session.
61078:   NSInteger charactersEntered = 0;
61078:   object_getInstanceVariable(self, "charactersEntered", (void **) &charactersEntered);
61078:   [(ChildView*)firstResponder setPluginTSMInComposition:(charactersEntered != 0)];
61078: 
61078:   return retval;
61078: }
61078: 
61078: // This method is called whenever IME input is committed as a result of an
61078: // "abnormal" termination -- for example when changing the keyboard focus from
61078: // one input field to another.
61078: - (void)nsChildView_IMKInputSession_commitComposition
61078: {
61078:   NSWindow *mainWindow = [NSApp mainWindow];
61078:   NSResponder *firstResponder = [mainWindow firstResponder];
61078:   if ([firstResponder isKindOfClass:[ChildView class]]) {
61078:     [(ChildView*)firstResponder setPluginTSMInComposition:NO];
61078:   }
61078:   [self nsChildView_IMKInputSession_commitComposition];
61078: }
61078: 
61078: // This method is called just before we're deallocated.
61078: - (void)nsChildView_IMKInputSession_finishSession
61078: {
61078:   NSWindow *mainWindow = [NSApp mainWindow];
61078:   NSResponder *firstResponder = [mainWindow firstResponder];
61078:   if ([firstResponder isKindOfClass:[ChildView class]]) {
61078:     [(ChildView*)firstResponder setPluginTSMInComposition:NO];
61078:   }
61078:   [self nsChildView_IMKInputSession_finishSession];
61078: }
61078: 
61078: @end
61078: 
33318: #endif // NP_NO_CARBON
33318: 
24707: @interface NSView (MethodSwizzling)
24707: - (BOOL)nsChildView_NSView_mouseDownCanMoveWindow;
24707: @end
24707: 
24707: @implementation NSView (MethodSwizzling)
24707: 
24707: // All top-level browser windows belong to the ToolbarWindow class and have
24707: // NSTexturedBackgroundWindowMask turned on in their "style" (see particularly
24707: // [ToolbarWindow initWithContentRect:...] in nsCocoaWindow.mm).  This style
24707: // normally means the window "may be moved by clicking and dragging anywhere
24707: // in the window background", but we've suppressed this by giving the
24707: // ChildView class a mouseDownCanMoveWindow method that always returns NO.
24707: // Normally a ToolbarWindow's contentView (not a ChildView) returns YES when
24707: // NSTexturedBackgroundWindowMask is turned on.  But normally this makes no
24707: // difference.  However, under some (probably very unusual) circumstances
24707: // (and only on Leopard) it *does* make a difference -- for example it
24707: // triggers bmo bugs 431902 and 476393.  So here we make sure that a
24707: // ToolbarWindow's contentView always returns NO from the
24707: // mouseDownCanMoveWindow method.
24707: - (BOOL)nsChildView_NSView_mouseDownCanMoveWindow
24707: {
24707:   NSWindow *ourWindow = [self window];
24707:   NSView *contentView = [ourWindow contentView];
24707:   if ([ourWindow isKindOfClass:[ToolbarWindow class]] && (self == contentView))
24707:     return NO;
24707:   return [self nsChildView_NSView_mouseDownCanMoveWindow];
24707: }
24707: 
24707: @end
