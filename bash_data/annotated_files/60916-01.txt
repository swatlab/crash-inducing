    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
41384: #include "nsAccCache.h"
    1: #include "nsAccessibilityAtoms.h"
30820: #include "nsAccessibilityService.h"
47107: #include "nsAccTreeWalker.h"
41384: #include "nsAccUtils.h"
41384: #include "nsRootAccessible.h"
41384: #include "nsTextEquivUtils.h"
41384: 
    1: #include "nsIMutableArray.h"
    1: #include "nsICommandManager.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentType.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMNSHTMLDocument.h"
43504: #include "nsIDOMXULDocument.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMXULPopupElement.h"
    1: #include "nsIEditingSession.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIFrame.h"
    1: #include "nsHTMLSelectAccessible.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIViewManager.h"
37062: #include "nsIScrollableFrame.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIURI.h"
    1: #include "nsIWebNavigation.h"
29018: #include "nsFocusManager.h"
51350: #include "mozilla/dom/Element.h"
    1: #ifdef MOZ_XUL
    1: #include "nsIXULDocument.h"
    1: #endif
    1: 
51350: namespace dom = mozilla::dom;
51350: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // Static member initialization
    1: 
 6065: PRUint32 nsDocAccessible::gLastFocusedAccessiblesState = 0;
 6065: 
57845: static nsIAtom** kRelationAttrs[] =
57845: {
57845:   &nsAccessibilityAtoms::aria_labelledby,
57845:   &nsAccessibilityAtoms::aria_describedby,
57845:   &nsAccessibilityAtoms::aria_owns,
57845:   &nsAccessibilityAtoms::aria_controls,
57932:   &nsAccessibilityAtoms::aria_flowto,
57932:   &nsAccessibilityAtoms::_for,
57932:   &nsAccessibilityAtoms::control
57845: };
57845: 
57845: static const PRUint32 kRelationAttrsLen = NS_ARRAY_LENGTH(kRelationAttrs);
35523: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // Constructor/desctructor
35523: 
43504: nsDocAccessible::
43504:   nsDocAccessible(nsIDocument *aDocument, nsIContent *aRootContent,
43310:                   nsIWeakReference *aShell) :
54220:   nsHyperTextAccessibleWrap(aRootContent, aShell),
57890:   mDocument(aDocument), mScrollPositionChangedTicks(0), mIsLoaded(PR_FALSE),
57890:   mCacheRoot(nsnull), mIsPostCacheProcessing(PR_FALSE)
    1: {
57845:   mDependentIDsHash.Init();
31335:   // XXX aaronl should we use an algorithm for the initial cache size?
43538:   mAccessibleCache.Init(kDefaultCacheSize);
56292:   mNodeToAccessibleMap.Init(kDefaultCacheSize);
31335: 
    1:   // For GTK+ native window, we do nothing here.
43504:   if (!mDocument)
    1:     return;
    1: 
43310:   // nsAccDocManager creates document accessible when scrollable frame is
43310:   // available already, it should be safe time to add scroll listener.
43310:   AddScrollListener();
    1: }
    1: 
    1: nsDocAccessible::~nsDocAccessible()
    1: {
    1: }
    1: 
35523: 
16428: ////////////////////////////////////////////////////////////////////////////////
35523: // nsISupports
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDocAccessible)
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDocAccessible, nsAccessible)
60746:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mNotificationController,
60746:                                                   NotificationController)
32285: 
52279:   PRUint32 i, length = tmp->mChildDocuments.Length();
52279:   for (i = 0; i < length; ++i) {
52279:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mChildDocuments[i]");
52279:     cb.NoteXPCOMChild(static_cast<nsIAccessible*>(tmp->mChildDocuments[i].get()));
52279:   }
52279: 
43538:   CycleCollectorTraverseCache(tmp->mAccessibleCache, &cb);
16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDocAccessible, nsAccessible)
60746:   tmp->mNotificationController->Shutdown();
60746:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mNotificationController)
52279:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSTARRAY(mChildDocuments)
57845:   tmp->mDependentIDsHash.Clear();
56292:   tmp->mNodeToAccessibleMap.Clear();
43538:   ClearCache(tmp->mAccessibleCache);
16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
16428: 
16428: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDocAccessible)
29564:   NS_INTERFACE_MAP_STATIC_AMBIGUOUS(nsDocAccessible)
    1:   NS_INTERFACE_MAP_ENTRY(nsIAccessibleDocument)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDocumentObserver)
    1:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
29564:   NS_INTERFACE_MAP_ENTRY(nsIObserver)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIAccessibleDocument)
43504:     foundInterface = 0;
43504: 
43504:   nsresult status;
43504:   if (!foundInterface) {
43504:     // HTML document accessible must inherit from nsHyperTextAccessible to get
43504:     // support text interfaces. XUL document accessible doesn't need this.
43504:     // However at some point we may push <body> to implement the interfaces and
43504:     // return nsDocAccessible to inherit from nsAccessibleWrap.
43504: 
57859:     if (mDocument && mDocument->IsXUL())
43504:       status = nsAccessible::QueryInterface(aIID, (void**)&foundInterface);
43504:     else
43504:       status = nsHyperTextAccessible::QueryInterface(aIID,
43504:                                                      (void**)&foundInterface);
43504:   } else {
43504:     NS_ADDREF(foundInterface);
43504:     status = NS_OK;
43504:   }
43504: 
43504:   *aInstancePtr = foundInterface;
43504:   return status;
43504: }
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsDocAccessible, nsHyperTextAccessible)
    1: NS_IMPL_RELEASE_INHERITED(nsDocAccessible, nsHyperTextAccessible)
    1: 
35523: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsIAccessible
35523: 
20246: NS_IMETHODIMP
20246: nsDocAccessible::GetName(nsAString& aName)
    1: {
    1:   nsresult rv = NS_OK;
    1:   aName.Truncate();
13094:   if (mParent) {
13094:     rv = mParent->GetName(aName); // Allow owning iframe to override the name
    1:   }
    1:   if (aName.IsEmpty()) {
20246:     // Allow name via aria-labelledby or title attribute
20246:     rv = nsAccessible::GetName(aName);
    1:   }
13094:   if (aName.IsEmpty()) {
14340:     rv = GetTitle(aName);   // Try title element
14340:   }
14340:   if (aName.IsEmpty()) {   // Last resort: use URL
14340:     rv = GetURL(aName);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
35523: // nsAccessible public method
52027: PRUint32
52027: nsDocAccessible::NativeRole()
    1: {
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
43504:     nsCoreUtils::GetDocShellTreeItemFor(mDocument);
    1:   if (docShellTreeItem) {
    1:     nsCOMPtr<nsIDocShellTreeItem> sameTypeRoot;
    1:     docShellTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(sameTypeRoot));
 2395:     PRInt32 itemType;
 2395:     docShellTreeItem->GetItemType(&itemType);
    1:     if (sameTypeRoot == docShellTreeItem) {
    1:       // Root of content or chrome tree
52027:       if (itemType == nsIDocShellTreeItem::typeChrome)
52027:         return nsIAccessibleRole::ROLE_CHROME_WINDOW;
52027: 
52027:       if (itemType == nsIDocShellTreeItem::typeContent) {
52027: #ifdef MOZ_XUL
52027:         nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
52027:         if (xulDoc)
52027:           return nsIAccessibleRole::ROLE_APPLICATION;
52027: #endif
52027:         return nsIAccessibleRole::ROLE_DOCUMENT;
52027:       }
    1:     }
    1:     else if (itemType == nsIDocShellTreeItem::typeContent) {
52027:       return nsIAccessibleRole::ROLE_DOCUMENT;
 2395:     }
    1:   }
    1: 
52027:   return nsIAccessibleRole::ROLE_PANE; // Fall back;
    1: }
    1: 
35523: // nsAccessible public method
29320: void
29320: nsDocAccessible::SetRoleMapEntry(nsRoleMapEntry* aRoleMapEntry)
    1: {
29320:   NS_ASSERTION(mDocument, "No document during initialization!");
29320:   if (!mDocument)
29320:     return;
13094: 
13094:   mRoleMapEntry = aRoleMapEntry;
13094: 
29823:   nsIDocument *parentDoc = mDocument->GetParentDocument();
29823:   if (!parentDoc)
29823:     return; // No parent document for the root document
29823: 
13094:   // Allow use of ARIA role from outer to override
13094:   nsIContent *ownerContent = parentDoc->FindContentForSubDocument(mDocument);
43504:   if (ownerContent) {
43504:     nsRoleMapEntry *roleMapEntry = nsAccUtils::GetRoleMapEntry(ownerContent);
13094:     if (roleMapEntry)
13094:       mRoleMapEntry = roleMapEntry; // Override
13094:   }
    1: }
    1: 
  262: NS_IMETHODIMP 
 3018: nsDocAccessible::GetDescription(nsAString& aDescription)
 3018: {
13094:   if (mParent)
13094:     mParent->GetDescription(aDescription);
13094: 
13094:   if (aDescription.IsEmpty()) {
 6861:     nsAutoString description;
25175:     nsTextEquivUtils::
25175:       GetTextEquivFromIDRefs(this, nsAccessibilityAtoms::aria_describedby,
25175:                              description);
 6861:     aDescription = description;
13094:   }
13094: 
 3018:   return NS_OK;
 3018: }
 3018: 
35523: // nsAccessible public method
21256: nsresult
21256: nsDocAccessible::GetStateInternal(PRUint32 *aState, PRUint32 *aExtraState)
    1: {
43504:   *aState = 0;
43504: 
43504:   if (IsDefunct()) {
43504:     if (aExtraState)
43504:       *aExtraState = nsIAccessibleStates::EXT_STATE_DEFUNCT;
43504: 
43504:     return NS_OK_DEFUNCT_OBJECT;
43504:   }
43504: 
56987:   if (aExtraState) {
56987:     // The root content of the document might be removed so that mContent is
56987:     // out of date.
56987:     *aExtraState = (mContent->GetCurrentDoc() == mDocument) ?
56987:       0 : nsIAccessibleStates::EXT_STATE_STALE;
56987:   }
  262: 
 3826: #ifdef MOZ_XUL
  416:   nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
 3826:   if (!xulDoc)
 3826: #endif
 3826:   {
  416:     // XXX Need to invent better check to see if doc is focusable,
  416:     // which it should be if it is scrollable. A XUL document could be focusable.
  416:     // See bug 376803.
    1:     *aState |= nsIAccessibleStates::STATE_FOCUSABLE;
43504:     if (gLastFocusedNode == mDocument)
14924:       *aState |= nsIAccessibleStates::STATE_FOCUSED;
14924:   }
    1: 
57986:   if (!mIsLoaded) {
    1:     *aState |= nsIAccessibleStates::STATE_BUSY;
 1087:     if (aExtraState) {
 1087:       *aExtraState |= nsIAccessibleStates::EXT_STATE_STALE;
 1087:     }
    1:   }
    1:  
    1:   nsIFrame* frame = GetFrame();
    1:   while (frame != nsnull && !frame->HasView()) {
    1:     frame = frame->GetParent();
    1:   }
    1:  
11399:   if (frame == nsnull ||
11399:       !CheckVisibilityInParentChain(mDocument, frame->GetViewExternal())) {
11399:     *aState |= nsIAccessibleStates::STATE_INVISIBLE |
11399:                nsIAccessibleStates::STATE_OFFSCREEN;
    1:   }
    1: 
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
    1:   if (!editor) {
    1:     *aState |= nsIAccessibleStates::STATE_READONLY;
    1:   }
  512:   else if (aExtraState) {
  512:     *aExtraState |= nsIAccessibleStates::EXT_STATE_EDITABLE;
  512:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
35523: // nsAccessible public method
29320: nsresult
29565: nsDocAccessible::GetARIAState(PRUint32 *aState, PRUint32 *aExtraState)
13094: {
13094:   // Combine with states from outer doc
13094:   NS_ENSURE_ARG_POINTER(aState);
29565:   nsresult rv = nsAccessible::GetARIAState(aState, aExtraState);
13094:   NS_ENSURE_SUCCESS(rv, rv);
13094: 
36989:   if (mParent)  // Allow iframe/frame etc. to have final state override via ARIA
36989:     return mParent->GetARIAState(aState, aExtraState);
13094: 
13094:   return rv;
13094: }
13094: 
13094: NS_IMETHODIMP
13094: nsDocAccessible::GetAttributes(nsIPersistentProperties **aAttributes)
13094: {
13094:   nsAccessible::GetAttributes(aAttributes);
13094:   if (mParent) {
13094:     mParent->GetAttributes(aAttributes); // Add parent attributes (override inner)
13094:   }
13094:   return NS_OK;
13094: }
13094: 
    1: NS_IMETHODIMP nsDocAccessible::GetFocusedChild(nsIAccessible **aFocusedChild)
    1: {
29018:   // XXXndeakin P3 accessibility shouldn't be caching the focus
    1:   if (!gLastFocusedNode) {
    1:     *aFocusedChild = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Return an accessible for the current global focus, which does not have to
    1:   // be contained within the current document.
43504:   NS_IF_ADDREF(*aFocusedChild = GetAccService()->GetAccessible(gLastFocusedNode));
43504:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::TakeFocus()
    1: {
43504:   if (IsDefunct())
43504:     return NS_ERROR_FAILURE;
43504: 
  883:   PRUint32 state;
21256:   GetStateInternal(&state, nsnull);
  883:   if (0 == (state & nsIAccessibleStates::STATE_FOCUSABLE)) {
  883:     return NS_ERROR_FAILURE; // Not focusable
  645:   }
  883: 
43504:   // Focus the document.
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
43504:   NS_ENSURE_STATE(fm);
43504: 
29018:   nsCOMPtr<nsIDOMElement> newFocus;
43504:   return fm->MoveFocus(mDocument->GetWindow(), nsnull,
29167:                        nsIFocusManager::MOVEFOCUS_ROOT, 0,
29018:                        getter_AddRefs(newFocus));
 5696: }
    1: 
35523: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsIAccessibleDocument
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetURL(nsAString& aURL)
    1: {
43504:   if (IsDefunct())
43504:     return NS_ERROR_FAILURE;
43504: 
    1:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_GetInterface(container));
    1:   nsCAutoString theURL;
    1:   if (webNav) {
    1:     nsCOMPtr<nsIURI> pURI;
    1:     webNav->GetCurrentURI(getter_AddRefs(pURI));
    1:     if (pURI)
    1:       pURI->GetSpec(theURL);
    1:   }
    1:   CopyUTF8toUTF16(theURL, aURL);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetTitle(nsAString& aTitle)
    1: {
16977:   nsCOMPtr<nsIDOMNSDocument> domnsDocument(do_QueryInterface(mDocument));
16977:   if (domnsDocument) {
16977:     return domnsDocument->GetTitle(aTitle);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetMimeType(nsAString& aMimeType)
    1: {
    1:   nsCOMPtr<nsIDOMNSDocument> domnsDocument(do_QueryInterface(mDocument));
    1:   if (domnsDocument) {
    1:     return domnsDocument->GetContentType(aMimeType);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetDocType(nsAString& aDocType)
    1: {
    1:   nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(mDocument));
    1:   nsCOMPtr<nsIDOMDocumentType> docType;
    1: 
    1: #ifdef MOZ_XUL
    1:   nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
    1:   if (xulDoc) {
    1:     aDocType.AssignLiteral("window"); // doctype not implemented for XUL at time of writing - causes assertion
    1:     return NS_OK;
    1:   } else
    1: #endif
    1:   if (domDoc && NS_SUCCEEDED(domDoc->GetDoctype(getter_AddRefs(docType))) && docType) {
    1:     return docType->GetPublicId(aDocType);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetNameSpaceURIForID(PRInt16 aNameSpaceID, nsAString& aNameSpaceURI)
    1: {
    1:   if (mDocument) {
    1:     nsCOMPtr<nsINameSpaceManager> nameSpaceManager =
    1:         do_GetService(NS_NAMESPACEMANAGER_CONTRACTID);
    1:     if (nameSpaceManager)
    1:       return nameSpaceManager->GetNameSpaceURI(aNameSpaceID, aNameSpaceURI);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetWindowHandle(void **aWindow)
    1: {
54220:   NS_ENSURE_ARG_POINTER(aWindow);
54220:   *aWindow = GetNativeWindow();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocAccessible::GetWindow(nsIDOMWindow **aDOMWin)
    1: {
    1:   *aDOMWin = nsnull;
    1:   if (!mDocument) {
    1:     return NS_ERROR_FAILURE;  // Accessible is Shutdown()
    1:   }
    1:   *aDOMWin = mDocument->GetWindow();
    1: 
    1:   if (!*aDOMWin)
    1:     return NS_ERROR_FAILURE;  // No DOM Window
    1: 
    1:   NS_ADDREF(*aDOMWin);
    1: 
    1:   return NS_OK;
    1: }
    1: 
41374: NS_IMETHODIMP
41374: nsDocAccessible::GetDOMDocument(nsIDOMDocument **aDOMDocument)
    1: {
41374:   NS_ENSURE_ARG_POINTER(aDOMDocument);
41374:   *aDOMDocument = nsnull;
    1: 
41374:   if (mDocument)
41374:     CallQueryInterface(mDocument, aDOMDocument);
41374: 
    1:   return NS_OK;
    1: }
    1: 
52279: NS_IMETHODIMP
52279: nsDocAccessible::GetParentDocument(nsIAccessibleDocument** aDocument)
52279: {
52279:   NS_ENSURE_ARG_POINTER(aDocument);
52279:   *aDocument = nsnull;
52279: 
52279:   if (!IsDefunct())
52279:     NS_IF_ADDREF(*aDocument = ParentDocument());
52279: 
52279:   return NS_OK;
52279: }
52279: 
52279: NS_IMETHODIMP
52279: nsDocAccessible::GetChildDocumentCount(PRUint32* aCount)
52279: {
52279:   NS_ENSURE_ARG_POINTER(aCount);
52279:   *aCount = 0;
52279: 
52279:   if (!IsDefunct())
52279:     *aCount = ChildDocumentCount();
52279: 
52279:   return NS_OK;
52279: }
52279: 
52279: NS_IMETHODIMP
52279: nsDocAccessible::GetChildDocumentAt(PRUint32 aIndex,
52279:                                     nsIAccessibleDocument** aDocument)
52279: {
52279:   NS_ENSURE_ARG_POINTER(aDocument);
52279:   *aDocument = nsnull;
52279: 
52279:   if (IsDefunct())
52279:     return NS_OK;
52279: 
52279:   NS_IF_ADDREF(*aDocument = GetChildDocumentAt(aIndex));
52279:   return *aDocument ? NS_OK : NS_ERROR_INVALID_ARG;
52279: }
52279: 
35523: // nsIAccessibleHyperText method
 4625: NS_IMETHODIMP nsDocAccessible::GetAssociatedEditor(nsIEditor **aEditor)
    1: {
 4625:   NS_ENSURE_ARG_POINTER(aEditor);
20138:   *aEditor = nsnull;
19825: 
43504:   if (IsDefunct())
20138:     return NS_ERROR_FAILURE;
    1: 
20138:   // Check if document is editable (designMode="on" case). Otherwise check if
20138:   // the html:body (for HTML document case) or document element is editable.
43504:   if (!mDocument->HasFlag(NODE_IS_EDITABLE) &&
43504:       !mContent->HasFlag(NODE_IS_EDITABLE))
20138:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
    1:   nsCOMPtr<nsIEditingSession> editingSession(do_GetInterface(container));
    1:   if (!editingSession)
 4625:     return NS_OK; // No editing session interface
    1: 
    1:   nsCOMPtr<nsIEditor> editor;
 4625:   editingSession->GetEditorForWindow(mDocument->GetWindow(), getter_AddRefs(editor));
 4625:   if (!editor) {
 4625:     return NS_OK;
 4625:   }
 4625:   PRBool isEditable;
 4625:   editor->GetIsDocumentEditable(&isEditable);
 4625:   if (isEditable) {
 4625:     NS_ADDREF(*aEditor = editor);
 4625:   }
 4625:   return NS_OK;
    1: }
    1: 
52279: // nsDocAccessible public method
43538: nsAccessible *
56292: nsDocAccessible::GetCachedAccessible(nsINode *aNode)
    1: {
56292:   nsAccessible* accessible = mNodeToAccessibleMap.Get(aNode);
38062: 
38062:   // No accessible in the cache, check if the given ID is unique ID of this
43538:   // document accessible.
43538:   if (!accessible) {
56292:     if (GetNode() != aNode)
43538:       return nsnull;
43538: 
43538:     accessible = this;
38062:   }
38062: 
38000: #ifdef DEBUG
    1:   // All cached accessible nodes should be in the parent
    1:   // It will assert if not all the children were created
    1:   // when they were first cached, and no invalidation
    1:   // ever corrected parent accessible's child cache.
43538:   nsAccessible* parent(accessible->GetCachedParent());
36989:   if (parent)
43538:     parent->TestChildCache(accessible);
    1: #endif
38063: 
43538:   return accessible;
    1: }
    1: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsAccessNode
    1: 
43538: PRBool
21169: nsDocAccessible::Init()
    1: {
43765:   NS_LOG_ACCDOCCREATE_FOR("document initialize", mDocument, this)
43765: 
60746:   // Initialize notification controller.
60746:   nsCOMPtr<nsIPresShell> shell(GetPresShell());
60746:   mNotificationController = new NotificationController(this, shell);
60746:   if (!mNotificationController)
43538:     return PR_FALSE;
    1: 
    1:   AddEventListeners();
    1: 
52279:   nsDocAccessible* parentDocument = mParent->GetDocAccessible();
52279:   if (parentDocument)
52279:     parentDocument->AppendChildDocument(this);
52279: 
30410:   // Fire reorder event to notify new accessible document has been created and
30410:   // attached to the tree.
51377:   nsRefPtr<AccEvent> reorderEvent =
56292:     new AccEvent(nsIAccessibleEvent::EVENT_REORDER, mParent, eAutoDetect,
56292:                  AccEvent::eCoalesceFromSameSubtree);
56292:   if (reorderEvent) {
30410:     FireDelayedAccessibleEvent(reorderEvent);
43538:     return PR_TRUE;
    1:   }
    1: 
56292:   return PR_FALSE;
56292: }
56292: 
43538: void
21169: nsDocAccessible::Shutdown()
    1: {
43538:   if (!mWeakShell) // already shutdown
43538:     return;
    1: 
43310:   NS_LOG_ACCDOCDESTROY_FOR("document shutdown", mDocument, this)
43310: 
60746:   if (mNotificationController) {
60746:     mNotificationController->Shutdown();
60746:     mNotificationController = nsnull;
38755:   }
37537: 
43310:   RemoveEventListeners();
    1: 
52279:   if (mParent) {
52279:     nsDocAccessible* parentDocument = mParent->GetDocAccessible();
52279:     if (parentDocument)
52279:       parentDocument->RemoveChildDocument(this);
52279: 
43310:     mParent->RemoveChild(this);
52279:   }
52279: 
57162:   // Walk the array backwards because child documents remove themselves from the
57162:   // array as they are shutdown.
57162:   PRInt32 childDocCount = mChildDocuments.Length();
57162:   for (PRInt32 idx = childDocCount - 1; idx >= 0; idx--)
56639:     mChildDocuments[idx]->Shutdown();
56639: 
52279:   mChildDocuments.Clear();
    1: 
    1:   mWeakShell = nsnull;  // Avoid reentrancy
    1: 
57845:   mDependentIDsHash.Clear();
56292:   mNodeToAccessibleMap.Clear();
43538:   ClearCache(mAccessibleCache);
    1: 
12240:   nsCOMPtr<nsIDocument> kungFuDeathGripDoc = mDocument;
    1:   mDocument = nsnull;
    1: 
 9691:   nsHyperTextAccessibleWrap::Shutdown();
56639: 
56639:   GetAccService()->NotifyOfDocumentShutdown(kungFuDeathGripDoc);
    1: }
    1: 
21169: nsIFrame*
21169: nsDocAccessible::GetFrame()
    1: {
    1:   nsCOMPtr<nsIPresShell> shell(do_QueryReferent(mWeakShell));
    1: 
    1:   nsIFrame* root = nsnull;
    1:   if (shell)
    1:     root = shell->GetRootFrame();
    1: 
    1:   return root;
    1: }
    1: 
29564: PRBool
29564: nsDocAccessible::IsDefunct()
29564: {
43504:   return nsHyperTextAccessibleWrap::IsDefunct() || !mDocument;
29564: }
29564: 
35523: // nsDocAccessible protected member
    1: void nsDocAccessible::GetBoundsRect(nsRect& aBounds, nsIFrame** aRelativeFrame)
    1: {
    1:   *aRelativeFrame = GetFrame();
    1: 
    1:   nsIDocument *document = mDocument;
    1:   nsIDocument *parentDoc = nsnull;
    1: 
    1:   while (document) {
46225:     nsIPresShell *presShell = document->GetShell();
    1:     if (!presShell) {
    1:       return;
    1:     }
    1: 
37062:     nsRect scrollPort;
37062:     nsIScrollableFrame* sf = presShell->GetRootScrollFrameAsScrollableExternal();
37062:     if (sf) {
37062:       scrollPort = sf->GetScrollPortRect();
37062:     } else {
37361:       nsIFrame* rootFrame = presShell->GetRootFrame();
37361:       if (!rootFrame) {
37361:         return;
37361:       }
37361:       scrollPort = rootFrame->GetRect();
    1:     }
    1: 
    1:     if (parentDoc) {  // After first time thru loop
37062:       // XXXroc bogus code! scrollPort is relative to the viewport of
37062:       // this document, but we're intersecting rectangles derived from
37062:       // multiple documents and assuming they're all in the same coordinate
37062:       // system. See bug 514117.
37062:       aBounds.IntersectRect(scrollPort, aBounds);
    1:     }
    1:     else {  // First time through loop
37062:       aBounds = scrollPort;
    1:     }
    1: 
    1:     document = parentDoc = document->GetParentDocument();
    1:   }
    1: }
    1: 
35523: // nsDocAccessible protected member
    1: nsresult nsDocAccessible::AddEventListeners()
    1: {
    1:   // 1) Set up scroll position listener
    1:   // 2) Check for editor and listen for changes to editor
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell(GetPresShell());
    1:   NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem(do_QueryInterface(container));
    1:   NS_ENSURE_TRUE(docShellTreeItem, NS_ERROR_FAILURE);
    1: 
    1:   // Make sure we're a content docshell
    1:   // We don't want to listen to chrome progress
    1:   PRInt32 itemType;
    1:   docShellTreeItem->GetItemType(&itemType);
    1: 
    1:   PRBool isContent = (itemType == nsIDocShellTreeItem::typeContent);
    1: 
    1:   if (isContent) {
    1:     // We're not an editor yet, but we might become one
    1:     nsCOMPtr<nsICommandManager> commandManager = do_GetInterface(docShellTreeItem);
    1:     if (commandManager) {
    1:       commandManager->AddCommandObserver(this, "obs_documentCreated");
    1:     }
    1:   }
    1: 
 1249:   nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
 1249:   docShellTreeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
 1249:   if (rootTreeItem) {
43310:     nsRefPtr<nsRootAccessible> rootAccessible = GetRootAccessible();
 2395:     NS_ENSURE_TRUE(rootAccessible, NS_ERROR_FAILURE);
 2395:     nsRefPtr<nsCaretAccessible> caretAccessible = rootAccessible->GetCaretAccessible();
 2395:     if (caretAccessible) {
10873:       caretAccessible->AddDocSelectionListener(presShell);
 1249:     }
 1249:   }
 1249: 
    1:   // add document observer
    1:   mDocument->AddObserver(this);
    1:   return NS_OK;
    1: }
    1: 
35523: // nsDocAccessible protected member
    1: nsresult nsDocAccessible::RemoveEventListeners()
    1: {
    1:   // Remove listeners associated with content documents
    1:   // Remove scroll position listener
    1:   RemoveScrollListener();
    1: 
29795:   NS_ASSERTION(mDocument, "No document during removal of listeners.");
29795: 
29795:   if (mDocument) {
    1:     mDocument->RemoveObserver(this);
    1: 
29795:     nsCOMPtr<nsISupports> container = mDocument->GetContainer();
29795:     nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem(do_QueryInterface(container));
29795:     NS_ASSERTION(docShellTreeItem, "doc should support nsIDocShellTreeItem.");
29795: 
29795:     if (docShellTreeItem) {
29795:       PRInt32 itemType;
29795:       docShellTreeItem->GetItemType(&itemType);
29795:       if (itemType == nsIDocShellTreeItem::typeContent) {
29795:         nsCOMPtr<nsICommandManager> commandManager = do_GetInterface(docShellTreeItem);
29795:         if (commandManager) {
29795:           commandManager->RemoveCommandObserver(this, "obs_documentCreated");
29795:         }
29795:       }
29795:     }
29795:   }
29795: 
    1:   if (mScrollWatchTimer) {
    1:     mScrollWatchTimer->Cancel();
    1:     mScrollWatchTimer = nsnull;
10411:     NS_RELEASE_THIS(); // Kung fu death grip
    1:   }
    1: 
 1249:   nsRefPtr<nsRootAccessible> rootAccessible(GetRootAccessible());
 1249:   if (rootAccessible) {
 2395:     nsRefPtr<nsCaretAccessible> caretAccessible = rootAccessible->GetCaretAccessible();
 2395:     if (caretAccessible) {
11032:       // Don't use GetPresShell() which can call Shutdown() if it sees dead pres shell
11032:       nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
10873:       caretAccessible->RemoveDocSelectionListener(presShell);
 1249:     }
 1249:   }
 1249: 
    1:   return NS_OK;
    1: }
    1: 
    1: void nsDocAccessible::ScrollTimerCallback(nsITimer *aTimer, void *aClosure)
    1: {
 3233:   nsDocAccessible *docAcc = reinterpret_cast<nsDocAccessible*>(aClosure);
    1: 
    1:   if (docAcc && docAcc->mScrollPositionChangedTicks &&
    1:       ++docAcc->mScrollPositionChangedTicks > 2) {
    1:     // Whenever scroll position changes, mScrollPositionChangeTicks gets reset to 1
    1:     // We only want to fire accessibilty scroll event when scrolling stops or pauses
    1:     // Therefore, we wait for no scroll events to occur between 2 ticks of this timer
    1:     // That indicates a pause in scrolling, so we fire the accessibilty scroll event
37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_SCROLLING_END, docAcc);
 3152: 
    1:     docAcc->mScrollPositionChangedTicks = 0;
    1:     if (docAcc->mScrollWatchTimer) {
    1:       docAcc->mScrollWatchTimer->Cancel();
    1:       docAcc->mScrollWatchTimer = nsnull;
10411:       NS_RELEASE(docAcc); // Release kung fu death grip
    1:     }
    1:   }
    1: }
    1: 
35523: // nsDocAccessible protected member
    1: void nsDocAccessible::AddScrollListener()
    1: {
    1:   nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
37062:   if (!presShell)
37062:     return;
    1: 
37062:   nsIScrollableFrame* sf = presShell->GetRootScrollFrameAsScrollableExternal();
37062:   if (sf) {
37062:     sf->AddScrollPositionListener(this);
43310:     NS_LOG_ACCDOCCREATE_TEXT("add scroll listener")
37062:   }
    1: }
    1: 
35523: // nsDocAccessible protected member
    1: void nsDocAccessible::RemoveScrollListener()
    1: {
    1:   nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
37062:   if (!presShell)
37062:     return;
    1:  
37062:   nsIScrollableFrame* sf = presShell->GetRootScrollFrameAsScrollableExternal();
37062:   if (sf) {
37062:     sf->RemoveScrollPositionListener(this);
37062:   }
    1: }
    1: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsIScrollPositionListener
35523: 
37871: void nsDocAccessible::ScrollPositionDidChange(nscoord aX, nscoord aY)
    1: {
    1:   // Start new timer, if the timer cycles at least 1 full cycle without more scroll position changes,
    1:   // then the ::Notify() method will fire the accessibility event for scroll position changes
    1:   const PRUint32 kScrollPosCheckWait = 50;
    1:   if (mScrollWatchTimer) {
    1:     mScrollWatchTimer->SetDelay(kScrollPosCheckWait);  // Create new timer, to avoid leaks
    1:   }
    1:   else {
    1:     mScrollWatchTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:     if (mScrollWatchTimer) {
10411:       NS_ADDREF_THIS(); // Kung fu death grip
    1:       mScrollWatchTimer->InitWithFuncCallback(ScrollTimerCallback, this,
    1:                                               kScrollPosCheckWait,
    1:                                               nsITimer::TYPE_REPEATING_SLACK);
    1:     }
    1:   }
    1:   mScrollPositionChangedTicks = 1;
    1: }
    1: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsIObserver
35523: 
    1: NS_IMETHODIMP nsDocAccessible::Observe(nsISupports *aSubject, const char *aTopic,
    1:                                        const PRUnichar *aData)
    1: {
    1:   if (!nsCRT::strcmp(aTopic,"obs_documentCreated")) {    
 4625:     // State editable will now be set, readonly is now clear
43016:     // Normally we only fire delayed events created from the node, not an
51377:     // accessible object. See the AccStateChangeEvent constructor for details
43016:     // about this exceptional case.
51377:     nsRefPtr<AccEvent> event =
51377:       new AccStateChangeEvent(this, nsIAccessibleStates::EXT_STATE_EDITABLE,
 4625:                               PR_TRUE, PR_TRUE);
43016:     FireDelayedAccessibleEvent(event);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
35523: ////////////////////////////////////////////////////////////////////////////////
    1: // nsIDocumentObserver
    1: 
    1: NS_IMPL_NSIDOCUMENTOBSERVER_CORE_STUB(nsDocAccessible)
    1: NS_IMPL_NSIDOCUMENTOBSERVER_LOAD_STUB(nsDocAccessible)
    1: NS_IMPL_NSIDOCUMENTOBSERVER_STYLE_STUB(nsDocAccessible)
    1: 
    1: void
29833: nsDocAccessible::AttributeWillChange(nsIDocument *aDocument,
51352:                                      dom::Element* aElement,
51352:                                      PRInt32 aNameSpaceID,
29833:                                      nsIAtom* aAttribute, PRInt32 aModType)
29833: {
57932:   // XXX TODO: bugs 467143, 472142, 472143.
29833:   // Here we will want to cache whatever state we are potentially interested in,
29833:   // such as the existence of aria-pressed for button (so we know if we need to
29833:   // newly expose it as a toggle button) etc.
57845: 
59412:   // Update dependent IDs cache. Take care of elements that are accessible
59412:   // because dependent IDs cache doesn't contain IDs from non accessible
59412:   // elements.
57845:   if (aModType == nsIDOMMutationEvent::MODIFICATION ||
57845:       aModType == nsIDOMMutationEvent::REMOVAL) {
59412:     nsAccessible* accessible = GetCachedAccessible(aElement);
57845:     if (accessible)
57845:       RemoveDependentIDsFor(accessible, aAttribute);
57845:   }
29833: }
29833: 
29833: void
51350: nsDocAccessible::AttributeChanged(nsIDocument *aDocument,
51350:                                   dom::Element* aElement,
    1:                                   PRInt32 aNameSpaceID, nsIAtom* aAttribute,
35535:                                   PRInt32 aModType)
    1: {
60733:   NS_ASSERTION(!IsDefunct(),
60733:                "Attribute changed called on defunct document accessible!");
60733: 
59464:   // Proceed even if the element is not accessible because element may become
59464:   // accessible if it gets certain attribute.
59464:   if (UpdateAccessibleOnAttrChange(aElement, aAttribute))
59464:     return;
59464: 
59464:   // Ignore attribute change if the element doesn't have an accessible (at all
59464:   // or still) iff the element is not a root content of this document accessible
59464:   // (which is treated as attribute change on this document accessible).
60733:   // Note: we don't bail if all the content hasn't finished loading because
60733:   // these attributes are changing for a loaded part of the content.
59464:   nsAccessible* accessible = GetCachedAccessible(aElement);
59464:   if (!accessible && (mContent != aElement))
59464:     return;
59464: 
59464:   // Fire accessible events iff there's an accessible, otherwise we consider
59464:   // the accessible state wasn't changed, i.e. its state is initial state.
51350:   AttributeChangedImpl(aElement, aNameSpaceID, aAttribute);
 6065: 
59412:   // Update dependent IDs cache. Take care of accessible elements because no
59412:   // accessible element means either the element is not accessible at all or
59412:   // its accessible will be created later. It doesn't make sense to keep
59412:   // dependent IDs for non accessible elements. For the second case we'll update
59412:   // dependent IDs cache when its accessible is created.
57845:   if (aModType == nsIDOMMutationEvent::MODIFICATION ||
57845:       aModType == nsIDOMMutationEvent::ADDITION) {
57845:     AddDependentIDsFor(accessible, aAttribute);
57845:   }
57845: 
59412:   // If it was the focused node, cache the new state.
59412:   if (aElement == gLastFocusedNode)
59412:     gLastFocusedAccessiblesState = nsAccUtils::State(accessible);
 6065: }
 6065: 
35523: // nsDocAccessible protected member
 6065: void
 6065: nsDocAccessible::AttributeChangedImpl(nsIContent* aContent, PRInt32 aNameSpaceID, nsIAtom* aAttribute)
 6065: {
  577:   // Fire accessible event after short timer, because we need to wait for
  577:   // DOM attribute & resulting layout to actually change. Otherwise,
  577:   // assistive technology will retrieve the wrong state/value/selection info.
  577: 
    1:   // XXX todo
    1:   // We still need to handle special HTML cases here
    1:   // For example, if an <img>'s usemap attribute is modified
    1:   // Otherwise it may just be a state change, for example an object changing
    1:   // its visibility
23549:   // 
23549:   // XXX todo: report aria state changes for "undefined" literal value changes
23549:   // filed as bug 472142
23549:   //
23549:   // XXX todo:  invalidate accessible when aria state changes affect exposed role
23549:   // filed as bug 472143
    1: 
32514:   // Universal boolean properties that don't require a role. Fire the state
32514:   // change when disabled or aria-disabled attribute is set.
 6279:   if (aAttribute == nsAccessibilityAtoms::disabled ||
 8937:       aAttribute == nsAccessibilityAtoms::aria_disabled) {
32514: 
32514:     // Note. Checking the XUL or HTML namespace would not seem to gain us
32514:     // anything, because disabled attribute really is going to mean the same
32514:     // thing in any namespace.
32514: 
32514:     // Note. We use the attribute instead of the disabled state bit because
32514:     // ARIA's aria-disabled does not affect the disabled state bit.
32514: 
51377:     nsRefPtr<AccEvent> enabledChangeEvent =
51377:       new AccStateChangeEvent(aContent,
  652:                               nsIAccessibleStates::EXT_STATE_ENABLED,
  652:                               PR_TRUE);
32514: 
  652:     FireDelayedAccessibleEvent(enabledChangeEvent);
32514: 
51377:     nsRefPtr<AccEvent> sensitiveChangeEvent =
51377:       new AccStateChangeEvent(aContent,
  652:                               nsIAccessibleStates::EXT_STATE_SENSITIVE,
  652:                               PR_TRUE);
32514: 
  652:     FireDelayedAccessibleEvent(sensitiveChangeEvent);
  652:     return;
  652:   }
  652: 
 6279:   // Check for namespaced ARIA attribute
 8937:   if (aNameSpaceID == kNameSpaceID_None) {
 6279:     // Check for hyphenated aria-foo property?
39100:     if (StringBeginsWith(nsDependentAtomString(aAttribute),
39100:                          NS_LITERAL_STRING("aria-"))) {
 8937:       ARIAAttributeChanged(aContent, aAttribute);
 6279:     }
 6279:   }
  577: 
11915:   if (aAttribute == nsAccessibilityAtoms::alt ||
28314:       aAttribute == nsAccessibilityAtoms::title ||
28314:       aAttribute == nsAccessibilityAtoms::aria_label ||
28314:       aAttribute == nsAccessibilityAtoms::aria_labelledby) {
32196:     FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_NAME_CHANGE,
43504:                                aContent);
11915:     return;
11915:   }
11915: 
 8937:   if (aAttribute == nsAccessibilityAtoms::selected ||
 8937:       aAttribute == nsAccessibilityAtoms::aria_selected) {
 8937:     // ARIA or XUL selection
43504: 
43504:     nsAccessible *multiSelect =
43504:       nsAccUtils::GetMultiSelectableContainer(aContent);
    1:     // Multi selects use selection_add and selection_remove
    1:     // Single select widgets just mirror event_selection for
    1:     // whatever gets event_focus, which is done in
    1:     // nsRootAccessible::FireAccessibleFocusEvent()
    1:     // So right here we make sure only to deal with multi selects
    1:     if (multiSelect) {
    1:       // Need to find the right event to use here, SELECTION_WITHIN would
    1:       // seem right but we had started using it for something else
32196:       FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_SELECTION_WITHIN,
43504:                                  multiSelect->GetNode(),
51377:                                  AccEvent::eAllowDupes);
  577: 
    1:       static nsIContent::AttrValuesArray strings[] =
    1:         {&nsAccessibilityAtoms::_empty, &nsAccessibilityAtoms::_false, nsnull};
 8937:       if (aContent->FindAttrValueIn(kNameSpaceID_None, aAttribute,
 8937:                                     strings, eCaseMatters) >= 0) {
32196:         FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_SELECTION_REMOVE,
43504:                                    aContent);
  577:         return;
    1:       }
  577: 
32196:       FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_SELECTION_ADD,
43504:                                  aContent);
    1:     }
    1:   }
 4625: 
 4625:   if (aAttribute == nsAccessibilityAtoms::contenteditable) {
51377:     nsRefPtr<AccEvent> editableChangeEvent =
51377:       new AccStateChangeEvent(aContent,
 4625:                               nsIAccessibleStates::EXT_STATE_EDITABLE,
 4625:                               PR_TRUE);
 4625:     FireDelayedAccessibleEvent(editableChangeEvent);
 4625:     return;
 4625:   }
    1: }
  577: 
35523: // nsDocAccessible protected member
  577: void
  577: nsDocAccessible::ARIAAttributeChanged(nsIContent* aContent, nsIAtom* aAttribute)
  577: {
40142:   // Note: For universal/global ARIA states and properties we don't care if
40142:   // there is an ARIA role present or not.
40142: 
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_required) {
51377:     nsRefPtr<AccEvent> event =
51377:       new AccStateChangeEvent(aContent, nsIAccessibleStates::STATE_REQUIRED,
  577:                               PR_FALSE);
  577:     FireDelayedAccessibleEvent(event);
  577:     return;
  577:   }
  577: 
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_invalid) {
51377:     nsRefPtr<AccEvent> event =
51377:       new AccStateChangeEvent(aContent, nsIAccessibleStates::STATE_INVALID,
  577:                               PR_FALSE);
  577:     FireDelayedAccessibleEvent(event);
  577:     return;
  577:   }
  577: 
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_activedescendant) {
    1:     // The activedescendant universal property redirects accessible focus events
    1:     // to the element with the id that activedescendant points to
43504:     nsCOMPtr<nsINode> focusedNode = GetCurrentFocus();
43504:     if (nsCoreUtils::GetRoleContent(focusedNode) == aContent) {
59126:       nsAccessible* focusedAcc = GetAccService()->GetAccessible(focusedNode);
    1:       nsRefPtr<nsRootAccessible> rootAcc = GetRootAccessible();
59126:       if (rootAcc && focusedAcc) {
59126:         rootAcc->FireAccessibleFocusEvent(focusedAcc, nsnull, PR_TRUE);
    1:       }
43636:     }
    1:     return;
    1:   }
  577: 
40142:   // For aria drag and drop changes we fire a generic attribute change event;
40142:   // at least until native API comes up with a more meaningful event.
40142:   if (aAttribute == nsAccessibilityAtoms::aria_grabbed ||
40142:       aAttribute == nsAccessibilityAtoms::aria_dropeffect) {
40142:     FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_OBJECT_ATTRIBUTE_CHANGED,
43504:                                aContent);
40142:   }
40142: 
40142:   // We treat aria-expanded as a global ARIA state for historical reasons
40142:   if (aAttribute == nsAccessibilityAtoms::aria_expanded) {
51377:     nsRefPtr<AccEvent> event =
51377:       new AccStateChangeEvent(aContent, nsIAccessibleStates::STATE_EXPANDED,
40142:                               PR_FALSE);
40142:     FireDelayedAccessibleEvent(event);
40142:     return;
40142:   }
40142: 
 8937:   if (!aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::role)) {
    1:     // We don't care about these other ARIA attribute changes unless there is
    1:     // an ARIA role set for the element
  577:     // XXX: we should check the role map to see if the changed property is
  577:     // relevant for that particular role.
    1:     return;
    1:   }
  577: 
 8937:   // The following ARIA attributes only take affect when dynamic content role is present
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_checked ||
 8937:       aAttribute == nsAccessibilityAtoms::aria_pressed) {
 8937:     const PRUint32 kState = (aAttribute == nsAccessibilityAtoms::aria_checked) ?
 6065:                             nsIAccessibleStates::STATE_CHECKED : 
 6065:                             nsIAccessibleStates::STATE_PRESSED;
51377:     nsRefPtr<AccEvent> event =
51377:       new AccStateChangeEvent(aContent, kState, PR_FALSE);
 6065:     FireDelayedAccessibleEvent(event);
43504:     if (aContent == gLastFocusedNode) {
 6065:       // State changes for MIXED state currently only supported for focused item, because
 6065:       // otherwise we would need access to the old attribute value in this listener.
 8937:       // This is because we don't know if the previous value of aria-checked or aria-pressed was "mixed"
 6065:       // without caching that info.
43537:       nsAccessible *accessible = event->GetAccessible();
 6065:       if (accessible) {
 6065:         PRBool wasMixed = (gLastFocusedAccessiblesState & nsIAccessibleStates::STATE_MIXED) != 0;
20566:         PRBool isMixed  =
20566:           (nsAccUtils::State(accessible) & nsIAccessibleStates::STATE_MIXED) != 0;
 6065:         if (wasMixed != isMixed) {
51377:           nsRefPtr<AccEvent> event =
51377:             new AccStateChangeEvent(aContent, nsIAccessibleStates::STATE_MIXED,
 6065:                                     PR_FALSE, isMixed);
  577:           FireDelayedAccessibleEvent(event);
    1:         }
 6065:       }
 6065:     }
 4624:     return;
 4624:   }
 4624: 
 8937:   if (aAttribute == nsAccessibilityAtoms::aria_readonly) {
51377:     nsRefPtr<AccEvent> event =
51377:       new AccStateChangeEvent(aContent, nsIAccessibleStates::STATE_READONLY,
  577:                               PR_FALSE);
  577:     FireDelayedAccessibleEvent(event);
  577:     return;
  577:   }
  577: 
29090:   // Fire value change event whenever aria-valuetext is changed, or
29090:   // when aria-valuenow is changed and aria-valuetext is empty
29090:   if (aAttribute == nsAccessibilityAtoms::aria_valuetext ||      
29090:       (aAttribute == nsAccessibilityAtoms::aria_valuenow &&
29090:        (!aContent->HasAttr(kNameSpaceID_None,
29090:            nsAccessibilityAtoms::aria_valuetext) ||
29090:         aContent->AttrValueIs(kNameSpaceID_None,
29090:             nsAccessibilityAtoms::aria_valuetext, nsAccessibilityAtoms::_empty,
29090:             eCaseMatters)))) {
32196:     FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE,
43504:                                aContent);
  577:     return;
  577:   }
    1: }
    1: 
    1: void nsDocAccessible::ContentAppended(nsIDocument *aDocument,
    1:                                       nsIContent* aContainer,
42107:                                       nsIContent* aFirstNewContent,
42107:                                       PRInt32 /* unused */)
    1: {
 4296: }
 4296: 
    1: void nsDocAccessible::ContentStatesChanged(nsIDocument* aDocument,
    1:                                            nsIContent* aContent1,
    1:                                            nsIContent* aContent2,
56168:                                            nsEventStates aStateMask)
    1: {
57105:   if (aStateMask.HasState(NS_EVENT_STATE_CHECKED)) {
57105:     nsHTMLSelectOptionAccessible::SelectionChangedIfOption(aContent1);
57105:     nsHTMLSelectOptionAccessible::SelectionChangedIfOption(aContent2);
    1:   }
    1: 
57105:   if (aStateMask.HasState(NS_EVENT_STATE_INVALID)) {
57105:     nsRefPtr<AccEvent> event =
57105:       new AccStateChangeEvent(aContent1, nsIAccessibleStates::STATE_INVALID,
57105:                               PR_FALSE, PR_TRUE);
57105:     FireDelayedAccessibleEvent(event);
57105:    }
    1: }
    1: 
39698: void nsDocAccessible::DocumentStatesChanged(nsIDocument* aDocument,
56168:                                             nsEventStates aStateMask)
39698: {
39698: }
39698: 
 5681: void nsDocAccessible::CharacterDataWillChange(nsIDocument *aDocument,
 5681:                                               nsIContent* aContent,
 5681:                                               CharacterDataChangeInfo* aInfo)
 5681: {
 5681:   FireTextChangeEventForText(aContent, aInfo, PR_FALSE);
 5681: }
 5681: 
    1: void nsDocAccessible::CharacterDataChanged(nsIDocument *aDocument,
    1:                                            nsIContent* aContent,
    1:                                            CharacterDataChangeInfo* aInfo)
    1: {
 5681:   FireTextChangeEventForText(aContent, aInfo, PR_TRUE);
    1: }
    1: 
    1: void
    1: nsDocAccessible::ContentInserted(nsIDocument *aDocument, nsIContent* aContainer,
42107:                                  nsIContent* aChild, PRInt32 /* unused */)
    1: {
    1: }
    1: 
    1: void
    1: nsDocAccessible::ContentRemoved(nsIDocument *aDocument, nsIContent* aContainer,
48038:                                 nsIContent* aChild, PRInt32 /* unused */,
48038:                                 nsIContent* aPreviousSibling)
    1: {
    1: }
    1: 
    1: void
    1: nsDocAccessible::ParentChainChanged(nsIContent *aContent)
    1: {
    1: }
    1: 
35523: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsAccessible
35523: 
43310: #ifdef DEBUG_ACCDOCMGR
43310: nsresult
51377: nsDocAccessible::HandleAccEvent(AccEvent* aAccEvent)
43310: {
43310:   NS_LOG_ACCDOCLOAD_HANDLEEVENT(aAccEvent)
43310: 
43310:   return nsHyperTextAccessible::HandleAccEvent(aAccEvent);
43310: 
35523: }
43310: #endif
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // Public members
35523: 
54220: void*
54220: nsDocAccessible::GetNativeWindow() const
54220: {
54220:   nsCOMPtr<nsIPresShell> shell(do_QueryReferent(mWeakShell));
54220:   nsIViewManager* vm = shell->GetViewManager();
54220:   if (vm) {
54220:     nsCOMPtr<nsIWidget> widget;
54220:     vm->GetRootWidget(getter_AddRefs(widget));
54220:     if (widget)
54220:       return widget->GetNativeData(NS_NATIVE_WINDOW);
54220:   }
54220:   return nsnull;
54220: }
54220: 
52279: nsAccessible*
56292: nsDocAccessible::GetCachedAccessibleByUniqueIDInSubtree(void* aUniqueID)
52279: {
56292:   nsAccessible* child = GetCachedAccessibleByUniqueID(aUniqueID);
52279:   if (child)
52279:     return child;
52279: 
52279:   PRUint32 childDocCount = mChildDocuments.Length();
52279:   for (PRUint32 childDocIdx= 0; childDocIdx < childDocCount; childDocIdx++) {
52279:     nsDocAccessible* childDocument = mChildDocuments.ElementAt(childDocIdx);
56292:     child = childDocument->GetCachedAccessibleByUniqueIDInSubtree(aUniqueID);
52279:     if (child)
52279:       return child;
52279:   }
52279: 
52279:   return nsnull;
52279: }
35523: 
57413: bool
57413: nsDocAccessible::BindToDocument(nsAccessible* aAccessible,
57413:                                 nsRoleMapEntry* aRoleMapEntry)
57413: {
57413:   if (!aAccessible)
57413:     return false;
57413: 
57413:   // Put into DOM node cache.
57413:   if (aAccessible->IsPrimaryForNode() &&
57413:       !mNodeToAccessibleMap.Put(aAccessible->GetNode(), aAccessible))
57413:     return false;
57413: 
57413:   // Put into unique ID cache.
57413:   if (!mAccessibleCache.Put(aAccessible->UniqueID(), aAccessible)) {
57413:     if (aAccessible->IsPrimaryForNode())
57413:       mNodeToAccessibleMap.Remove(aAccessible->GetNode());
57414: 
57413:     return false;
57413:   }
57413: 
57413:   // Initialize the accessible.
57413:   if (!aAccessible->Init()) {
57413:     NS_ERROR("Failed to initialize an accessible!");
57413: 
57413:     UnbindFromDocument(aAccessible);
57413:     return false;
57413:   }
57413: 
57413:   aAccessible->SetRoleMapEntry(aRoleMapEntry);
57845:   AddDependentIDsFor(aAccessible);
57413:   return true;
57413: }
57413: 
57413: void
57413: nsDocAccessible::UnbindFromDocument(nsAccessible* aAccessible)
57413: {
57934:   NS_ASSERTION(mAccessibleCache.GetWeak(aAccessible->UniqueID()),
57934:                "Unbinding the unbound accessible!");
57934: 
57414:   // Remove an accessible from node-to-accessible map if it exists there.
57413:   if (aAccessible->IsPrimaryForNode() &&
57413:       mNodeToAccessibleMap.Get(aAccessible->GetNode()) == aAccessible)
57413:     mNodeToAccessibleMap.Remove(aAccessible->GetNode());
57413: 
57934:   if (!aAccessible->IsDefunct())
57845:     RemoveDependentIDsFor(aAccessible);
57845: 
57934:   void* uniqueID = aAccessible->UniqueID();
57413: 
57934:   NS_ASSERTION(!aAccessible->IsDefunct(), "Shutdown the shutdown accessible!");
57413:   aAccessible->Shutdown();
57934: 
57413:   mAccessibleCache.Remove(uniqueID);
57413: }
57413: 
56292: void
60746: nsDocAccessible::ContentInserted(nsIContent* aContainerNode,
60746:                                  nsIContent* aStartChildNode,
60746:                                  nsIContent* aEndChildNode)
56292: {
60746:   /// Pend tree update on content insertion until layout.
60746:   if (mNotificationController) {
56987:     // Update the whole tree of this document accessible when the container is
56987:     // null (document element is inserted or removed).
60746:     nsAccessible* container = aContainerNode ?
60746:       GetAccService()->GetCachedAccessibleOrContainer(aContainerNode) :
56987:       this;
56292: 
60746:     mNotificationController->ScheduleContentInsertion(container,
60746:                                                       aStartChildNode,
60746:                                                       aEndChildNode);
60746:   }
56987: }
56987: 
60746: void
60746: nsDocAccessible::ContentRemoved(nsIContent* aContainerNode,
60746:                                 nsIContent* aChildNode)
60746: {
60746:   // Update the whole tree of this document accessible when the container is
60746:   // null (document element is removed).
60746:   nsAccessible* container = aContainerNode ?
56987:     GetAccService()->GetCachedAccessibleOrContainer(aContainerNode) :
56987:     this;
56292: 
60746:   UpdateTree(container, aChildNode, PR_FALSE);
56292: }
56292: 
56292: void
56292: nsDocAccessible::RecreateAccessible(nsINode* aNode)
56292: {
56292:   // XXX: we shouldn't recreate whole accessible subtree that happens when
56292:   // hide event is handled, instead we should subclass hide and show events
56292:   // to handle them separately and implement their coalescence with normal hide
56292:   // and show events.
56292: 
56292:   nsAccessible* parent = nsnull;
56292: 
56292:   // Fire hide event for old accessible.
56292:   nsAccessible* oldAccessible =
56292:     GetAccService()->GetAccessibleInWeakShell(aNode, mWeakShell);
56292:   if (oldAccessible) {
56292:     parent = oldAccessible->GetParent();
56292: 
60746:     nsRefPtr<AccEvent> hideEvent = new AccHideEvent(oldAccessible, aNode);
56292:     if (hideEvent)
56292:       FireDelayedAccessibleEvent(hideEvent);
56292: 
56292:     // Unbind old accessible from tree.
56292:     parent->RemoveChild(oldAccessible);
56292: 
56292:     if (oldAccessible->IsPrimaryForNode() &&
56292:         mNodeToAccessibleMap.Get(oldAccessible->GetNode()) == oldAccessible)
56292:       mNodeToAccessibleMap.Remove(oldAccessible->GetNode());
56292: 
56292:   } else {
60916:     // Not accessible node may not have container accessible if we recreate
60916:     // an accessible asynchronously.
60916:     // XXX: asynchronous RecreateAccessible notifications should be coalesced
60916:     // with accessible tree mutation notifications. We could trigger
60916:     // ContentRemoved/ContentInserted pair for that but it moves us away from
60916:     // the idea to not recreate the whole subtree.
56292:     parent = GetAccService()->GetContainerAccessible(aNode, mWeakShell);
60916:     if (!parent)
60916:       return;
56292:   }
56292: 
56292:   // Get new accessible and fire show event.
56292:   parent->InvalidateChildren();
56292: 
56292:   nsAccessible* newAccessible =
56292:     GetAccService()->GetAccessibleInWeakShell(aNode, mWeakShell);
56292:   if (newAccessible) {
60746:     nsRefPtr<AccEvent> showEvent = new AccShowEvent(newAccessible, aNode);
56292:     if (showEvent)
56292:       FireDelayedAccessibleEvent(showEvent);
56292:   }
56292: 
56292:   // Fire reorder event.
56292:   if (oldAccessible || newAccessible) {
56292:     nsRefPtr<AccEvent> reorderEvent =
56292:       new AccEvent(nsIAccessibleEvent::EVENT_REORDER, parent->GetNode(),
56292:                    eAutoDetect, AccEvent::eCoalesceFromSameSubtree);
56292: 
56292:     if (reorderEvent)
56292:       FireDelayedAccessibleEvent(reorderEvent);
56292:   }
56292: }
56292: 
57890: void
57890: nsDocAccessible::NotifyOfCachingStart(nsAccessible* aAccessible)
57890: {
57890:   if (!mCacheRoot)
57890:     mCacheRoot = aAccessible;
57890: }
57890: 
57890: void
57890: nsDocAccessible::NotifyOfCachingEnd(nsAccessible* aAccessible)
57890: {
57890:   if (mCacheRoot == aAccessible && !mIsPostCacheProcessing) {
57890:     // Allow invalidation list insertions while container children are recached.
57890:     mIsPostCacheProcessing = PR_TRUE;
57890: 
57890:     // Invalidate children of container accessible for each element in
57890:     // invalidation list.
57890:     for (PRUint32 idx = 0; idx < mInvalidationList.Length(); idx++) {
57890:       nsIContent* content = mInvalidationList[idx];
57890:       nsAccessible* container =
57890:         GetAccService()->GetCachedContainerAccessible(content);
57890:       container->InvalidateChildren();
57890: 
57890:       // Make sure we keep children updated. While we're inside of caching loop
57890:       // then we must exist it with cached children.
57890:       container->EnsureChildren();
57890:     }
57890:     mInvalidationList.Clear();
57890: 
57890:     mCacheRoot = nsnull;
57890:     mIsPostCacheProcessing = PR_FALSE;
57890:   }
57890: }
57890: 
35523: ////////////////////////////////////////////////////////////////////////////////
57964: // nsAccessible protected
57964: 
57964: void
57964: nsDocAccessible::CacheChildren()
57964: {
57964:   // Search for accessible children starting from the document element since
57964:   // some web pages tend to insert elements under it rather than document body.
57964:   nsAccTreeWalker walker(mWeakShell, mDocument->GetRootElement(),
57964:                          GetAllowsAnonChildAccessibles());
57964: 
57964:   nsRefPtr<nsAccessible> child;
57964:   while ((child = walker.GetNextChild()) && AppendChild(child));
57964: }
57964: 
57964: ////////////////////////////////////////////////////////////////////////////////
35523: // Protected members
35523: 
 3950: void
57845: nsDocAccessible::AddDependentIDsFor(nsAccessible* aRelProvider,
57845:                                     nsIAtom* aRelAttr)
57845: {
57845:   for (PRUint32 idx = 0; idx < kRelationAttrsLen; idx++) {
57845:     nsIAtom* relAttr = *kRelationAttrs[idx];
57845:     if (aRelAttr && aRelAttr != relAttr)
57845:       continue;
57845: 
57932:     if (relAttr == nsAccessibilityAtoms::_for) {
57932:       if (!aRelProvider->GetContent()->IsHTML() ||
57932:           aRelProvider->GetContent()->Tag() != nsAccessibilityAtoms::label &&
57932:           aRelProvider->GetContent()->Tag() != nsAccessibilityAtoms::output)
57932:         continue;
57932: 
57932:     } else if (relAttr == nsAccessibilityAtoms::control) {
57932:       if (!aRelProvider->GetContent()->IsXUL() ||
57932:           aRelProvider->GetContent()->Tag() != nsAccessibilityAtoms::label &&
57932:           aRelProvider->GetContent()->Tag() != nsAccessibilityAtoms::description)
57932:         continue;
57932:     }
57932: 
57845:     IDRefsIterator iter(aRelProvider->GetContent(), relAttr);
57845:     while (true) {
57845:       const nsDependentSubstring id = iter.NextID();
57845:       if (id.IsEmpty())
57845:         break;
57845: 
57845:       AttrRelProviderArray* providers = mDependentIDsHash.Get(id);
57845:       if (!providers) {
57845:         providers = new AttrRelProviderArray();
57845:         if (providers) {
57845:           if (!mDependentIDsHash.Put(id, providers)) {
57845:             delete providers;
57845:             providers = nsnull;
57845:           }
57845:         }
57845:       }
57845: 
57845:       if (providers) {
57845:         AttrRelProvider* provider =
57845:           new AttrRelProvider(relAttr, aRelProvider->GetContent());
57890:         if (provider) {
57845:           providers->AppendElement(provider);
57890: 
57890:           // We've got here during the children caching. If the referenced
57890:           // content is not accessible then store it to pend its container
57890:           // children invalidation (this happens immediately after the caching
57890:           // is finished).
57890:           nsIContent* dependentContent = iter.GetElem(id);
57890:           if (dependentContent && !GetCachedAccessible(dependentContent)) {
57890:             mInvalidationList.AppendElement(dependentContent);
57890:           }
57890:         }
57845:       }
57845:     }
57845: 
57845:     // If the relation attribute is given then we don't have anything else to
57845:     // check.
57845:     if (aRelAttr)
57845:       break;
57845:   }
57845: }
57845: 
57845: void
57845: nsDocAccessible::RemoveDependentIDsFor(nsAccessible* aRelProvider,
57845:                                        nsIAtom* aRelAttr)
57845: {
57845:   for (PRUint32 idx = 0; idx < kRelationAttrsLen; idx++) {
57845:     nsIAtom* relAttr = *kRelationAttrs[idx];
57845:     if (aRelAttr && aRelAttr != *kRelationAttrs[idx])
57845:       continue;
57845: 
57845:     IDRefsIterator iter(aRelProvider->GetContent(), relAttr);
57845:     while (true) {
57845:       const nsDependentSubstring id = iter.NextID();
57845:       if (id.IsEmpty())
57845:         break;
57845: 
57845:       AttrRelProviderArray* providers = mDependentIDsHash.Get(id);
57845:       if (providers) {
57845:         for (PRUint32 jdx = 0; jdx < providers->Length(); ) {
57845:           AttrRelProvider* provider = (*providers)[jdx];
57845:           if (provider->mRelAttr == relAttr &&
57845:               provider->mContent == aRelProvider->GetContent())
57845:             providers->RemoveElement(provider);
57845:           else
57845:             jdx++;
57845:         }
57845:         if (providers->Length() == 0)
57845:           mDependentIDsHash.Remove(id);
57845:       }
57845:     }
57845: 
57845:     // If the relation attribute is given then we don't have anything else to
57845:     // check.
57845:     if (aRelAttr)
57845:       break;
57845:   }
57845: }
57845: 
59464: bool
59464: nsDocAccessible::UpdateAccessibleOnAttrChange(dom::Element* aElement,
59464:                                               nsIAtom* aAttribute)
59464: {
59464:   if (aAttribute == nsAccessibilityAtoms::role) {
59464:     // It is common for js libraries to set the role on the body element after
59464:     // the document has loaded. In this case we just update the role map entry.
59464:     if (mContent == aElement) {
59464:       SetRoleMapEntry(nsAccUtils::GetRoleMapEntry(aElement));
59464:       return true;
59464:     }
59464: 
59464:     // Recreate the accessible when role is changed because we might require a
59464:     // different accessible class for the new role or the accessible may expose
59464:     // a different sets of interfaces (COM restriction).
60851:     HandleNotification<nsDocAccessible, nsINode>
60851:       (this, &nsDocAccessible::RecreateAccessible, aElement);
60851: 
59464:     return true;
59464:   }
59464: 
59464:   if (aAttribute == nsAccessibilityAtoms::href ||
59464:       aAttribute == nsAccessibilityAtoms::onclick) {
59464:     // Not worth the expense to ensure which namespace these are in
59464:     // It doesn't kill use to recreate the accessible even if the attribute was used
59464:     // in the wrong namespace or an element that doesn't support it
60851:     HandleNotification<nsDocAccessible, nsINode>
60851:       (this, &nsDocAccessible::RecreateAccessible, aElement);
60851: 
59464:     return true;
59464:   }
59464: 
59464:   if (aAttribute == nsAccessibilityAtoms::aria_multiselectable &&
59464:       aElement->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::role)) {
59464:     // This affects whether the accessible supports SelectAccessible.
59464:     // COM says we cannot change what interfaces are supported on-the-fly,
59464:     // so invalidate this object. A new one will be created on demand.
60851:     HandleNotification<nsDocAccessible, nsINode>
60851:       (this, &nsDocAccessible::RecreateAccessible, aElement);
60851: 
59464:     return true;
59464:   }
59464: 
59464:   return false;
59464: }
59464: 
57845: void
43537: nsDocAccessible::FireValueChangeForTextFields(nsAccessible *aAccessible)
13353: {
52089:   if (aAccessible->Role() != nsIAccessibleRole::ROLE_ENTRY)
13353:     return;
13353: 
13353:   // Dependent value change event for text changes in textfields
51377:   nsRefPtr<AccEvent> valueChangeEvent =
51377:     new AccEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE, aAccessible,
56292:                  eAutoDetect, AccEvent::eRemoveDupes);
13353:   FireDelayedAccessibleEvent(valueChangeEvent);
13353: }
13353: 
13353: void
 5681: nsDocAccessible::FireTextChangeEventForText(nsIContent *aContent,
 5681:                                             CharacterDataChangeInfo* aInfo,
 5681:                                             PRBool aIsInserted)
 3950: {
43310:   if (!IsContentLoaded())
 4296:     return;
 4296: 
43441:   PRInt32 contentOffset = aInfo->mChangeStart;
43441:   PRUint32 contentLength = aIsInserted ?
43441:     aInfo->mReplaceLength: // text has been added
43441:     aInfo->mChangeEnd - contentOffset; // text has been removed
43441: 
43441:   if (contentLength == 0)
 3950:     return;
 3950: 
43504:   nsAccessible *accessible = GetAccService()->GetAccessible(aContent);
42800:   if (!accessible)
 3950:     return;
 3950: 
43441:   nsRefPtr<nsHyperTextAccessible> textAccessible =
43441:     do_QueryObject(accessible->GetParent());
42377:   if (!textAccessible)
 3950:     return;
 3950: 
47107:   // Get offset within hypertext accessible and invalidate cached offsets after
47107:   // this child accessible.
47107:   PRInt32 offset = textAccessible->GetChildOffset(accessible, PR_TRUE);
 3950: 
47107:   // Get added or removed text.
36654:   nsIFrame* frame = aContent->GetPrimaryFrame();
 8374:   if (!frame)
 8374:     return;
 5681: 
43441:   PRUint32 textOffset = 0;
43441:   nsresult rv = textAccessible->ContentToRenderedOffset(frame, contentOffset,
43441:                                                         &textOffset);
 5681:   if (NS_FAILED(rv))
 5681:     return;
 5681: 
43441:   nsAutoString text;
43441:   rv = accessible->AppendTextTo(text, textOffset, contentLength);
 5681:   if (NS_FAILED(rv))
 5681:     return;
 5681: 
47106:   if (text.IsEmpty())
43441:     return;
43441: 
43017:   // Normally we only fire delayed events created from the node, not an
51377:   // accessible object. See the AccTextChangeEvent constructor for details
43017:   // about this exceptional case.
51377:   nsRefPtr<AccEvent> event =
51377:     new AccTextChangeEvent(textAccessible, offset + textOffset, text,
56292:                           aIsInserted);
43017:   FireDelayedAccessibleEvent(event);
13353: 
43441:   FireValueChangeForTextFields(textAccessible);
 3950: }
 3950: 
35523: // nsDocAccessible public member
32196: nsresult
43504: nsDocAccessible::FireDelayedAccessibleEvent(PRUint32 aEventType, nsINode *aNode,
51377:                                             AccEvent::EEventRule aAllowDupes,
37339:                                             EIsFromUserInput aIsFromUserInput)
    1: {
51377:   nsRefPtr<AccEvent> event =
56292:     new AccEvent(aEventType, aNode, aIsFromUserInput, aAllowDupes);
  577:   NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
  577: 
13167:   return FireDelayedAccessibleEvent(event);
  577: }
  577: 
35523: // nsDocAccessible public member
  577: nsresult
51377: nsDocAccessible::FireDelayedAccessibleEvent(AccEvent* aEvent)
  577: {
32285:   NS_ENSURE_ARG(aEvent);
43310:   NS_LOG_ACCDOCLOAD_FIREEVENT(aEvent)
 4846: 
60746:   if (mNotificationController)
60746:     mNotificationController->QueueEvent(aEvent);
32196: 
37537:   return NS_OK;
    1: }
    1: 
29564: void
51377: nsDocAccessible::ProcessPendingEvent(AccEvent* aEvent)
    1: {
43537:   nsAccessible* accessible = aEvent->GetAccessible();
56292:   if (!accessible)
56292:     return;
11439: 
37537:   PRUint32 eventType = aEvent->GetEventType();
37339: 
43310:   if (eventType == nsIAccessibleEvent::EVENT_TEXT_CARET_MOVED) {
42800:     nsCOMPtr<nsIAccessibleText> accessibleText = do_QueryObject(accessible);
    1:     PRInt32 caretOffset;
56292:     if (accessibleText &&
56292:         NS_SUCCEEDED(accessibleText->GetCaretOffset(&caretOffset))) {
 4750: #ifdef DEBUG_A11Y
 3451:       PRUnichar chAtOffset;
 3451:       accessibleText->GetCharacterAtOffset(caretOffset, &chAtOffset);
 3451:       printf("\nCaret moved to %d with char %c", caretOffset, chAtOffset);
 3451: #endif
 8862: #ifdef DEBUG_CARET
 8862:       // Test caret line # -- fire an EVENT_ALERT on the focused node so we can watch the
 8862:       // line-number object attribute on it
43504:       nsAccessible* focusedAcc =
43504:         GetAccService()->GetAccessible(gLastFocusedNode);
43504:       nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_ALERT, focusedAcc);
 8862: #endif
51377:       nsRefPtr<AccEvent> caretMoveEvent =
51377:           new AccCaretMoveEvent(accessible, caretOffset);
15262:       if (!caretMoveEvent)
37537:         return;
 2688: 
37282:       nsEventShell::FireEvent(caretMoveEvent);
 2688: 
    1:       PRInt32 selectionCount;
    1:       accessibleText->GetSelectionCount(&selectionCount);
    1:       if (selectionCount) {  // There's a selection so fire selection change as well
37281:         nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_TEXT_SELECTION_CHANGED,
56292:                                 accessible);
    1:       }
    1:     }
    1:   }
    1:   else {
37537:     nsEventShell::FireEvent(aEvent);
37339: 
 4637:     // Post event processing
56292:     if (eventType == nsIAccessibleEvent::EVENT_HIDE)
56292:       ShutdownChildrenInSubtree(accessible);
 4637:   }
    1: }
56292: 
60746: void
60746: nsDocAccessible::ProcessContentInserted(nsAccessible* aContainer,
60746:                                         const nsTArray<nsCOMPtr<nsIContent> >* aInsertedContent)
60746: {
60746:   // Process the notification if the container accessible is still in tree.
60746:   if (!GetCachedAccessible(aContainer->GetNode()))
60746:     return;
60746: 
60746:   if (aContainer == this) {
60746:     // If new root content has been inserted then update it.
60746:     nsIContent* rootContent = nsCoreUtils::GetRoleContent(mDocument);
60746:     if (rootContent && rootContent != mContent)
60746:       mContent = rootContent;
60746: 
60746:     // Continue to update the tree even if we don't have root content.
60746:     // For example, elements may be inserted under the document element while
60746:     // there is no HTML body element.
60746:   }
60746: 
60746:   // XXX: Invalidate parent-child relations for container accessible and its
60746:   // children because there's no good way to find insertion point of new child
60746:   // accessibles into accessible tree. We need to invalidate children even
60746:   // there's no inserted accessibles in the end because accessible children
60746:   // are created while parent recaches child accessibles.
60746:   aContainer->InvalidateChildren();
60746: 
60746:   // The container might be changed, for example, because of the subsequent
60746:   // overlapping content insertion (i.e. other content was inserted between this
60746:   // inserted content and its container or the content was reinserted into
60746:   // different container of unrelated part of tree). These cases result in
60746:   // double processing, however generated events are coalesced and we don't
60746:   // harm an AT. On the another hand container can be different because direct
60746:   // container wasn't cached yet when we handled content insertion notification
60746:   // and therefore we can't ignore the case when container has been changed.
60867:   // Theoretically the element might be not in tree at all at this point what
60867:   // means there's no container.
60867:   for (PRUint32 idx = 0; idx < aInsertedContent->Length(); idx++) {
60867:     nsAccessible* directContainer =
60867:       GetAccService()->GetContainerAccessible(aInsertedContent->ElementAt(idx),
60867:                                               mWeakShell);
60867:     if (directContainer)
60746:       UpdateTree(directContainer, aInsertedContent->ElementAt(idx), PR_TRUE);
60746:   }
60867: }
60746: 
60746: void
60746: nsDocAccessible::UpdateTree(nsAccessible* aContainer, nsIContent* aChildNode,
60746:                             PRBool aIsInsert)
60746: {
60746:   PRUint32 updateFlags =
60746:     UpdateTreeInternal(aContainer, aChildNode, aChildNode->GetNextSibling(),
60746:                        aIsInsert);
60746: 
60746:   // Content insertion/removal is not cause of accessible tree change.
60746:   if (updateFlags == eNoAccessible)
60746:     return;
60746: 
60746:   // Check to see if change occurred inside an alert, and fire an EVENT_ALERT
60746:   // if it did.
60746:   if (aIsInsert && !(updateFlags & eAlertAccessible)) {
60746:     // XXX: tree traversal is perf issue, accessible should know if they are
60746:     // children of alert accessible to avoid this.
60746:     nsAccessible* ancestor = aContainer;
60746:     while (ancestor) {
60746:       if (ancestor->ARIARole() == nsIAccessibleRole::ROLE_ALERT) {
60746:         FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_ALERT,
60746:                                    ancestor->GetNode());
60746:         break;
60746:       }
60746: 
60746:       // Don't climb above this document.
60746:       if (ancestor == this)
60746:         break;
60746: 
60746:       ancestor = ancestor->GetParent();
60746:     }
60746:   }
60746: 
60746:   // Fire value change event.
60746:   if (aContainer->Role() == nsIAccessibleRole::ROLE_ENTRY) {
60746:     FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE,
60746:                                aContainer->GetNode());
60746:   }
60746: 
60746:   // Fire reorder event so the MSAA clients know the children have changed. Also
60746:   // the event is used internally by MSAA layer.
60746:   nsRefPtr<AccEvent> reorderEvent =
60746:     new AccEvent(nsIAccessibleEvent::EVENT_REORDER, aContainer->GetNode(),
60746:                  eAutoDetect, AccEvent::eCoalesceFromSameSubtree);
60746:   if (reorderEvent)
60746:     FireDelayedAccessibleEvent(reorderEvent);
60746: }
60746: 
56292: PRUint32
56292: nsDocAccessible::UpdateTreeInternal(nsAccessible* aContainer,
56292:                                     nsIContent* aStartNode,
56292:                                     nsIContent* aEndNode,
60746:                                     PRBool aIsInsert)
56292: {
56292:   PRUint32 updateFlags = eNoAccessible;
56292:   for (nsIContent* node = aStartNode; node != aEndNode;
56292:        node = node->GetNextSibling()) {
56292: 
56292:     // Tree update triggers for content insertion even if no content was
56292:     // inserted actually, check if the given content has a frame to discard
56292:     // this case early.
56292:     if (aIsInsert && !node->GetPrimaryFrame())
56292:       continue;
56292: 
56292:     nsAccessible* accessible = aIsInsert ?
56292:       GetAccService()->GetAccessibleInWeakShell(node, mWeakShell) :
56292:       GetCachedAccessible(node);
56292: 
56292:     if (!accessible) {
56292:       updateFlags |= UpdateTreeInternal(aContainer, node->GetFirstChild(),
60746:                                         nsnull, aIsInsert);
56292:       continue;
    1:     }
56292: 
56292:     updateFlags |= eAccessible;
56292: 
58370:     if (!aIsInsert) {
58370:       // Fire menupopup end event before hide event if a menu goes away.
58370: 
58370:       // XXX: We don't look into children of hidden subtree to find hiding
58370:       // menupopup (as we did prior bug 570275) because we don't do that when
58370:       // menu is showing (and that's impossible until bug 606924 is fixed).
58370:       // Nevertheless we should do this at least because layout coalesces
58370:       // the changes before our processing and we may miss some menupopup
58370:       // events. Now we just want to be consistent in content insertion/removal
58370:       // handling.
58433:       if (accessible->ARIARole() == nsIAccessibleRole::ROLE_MENUPOPUP) {
58370:         nsRefPtr<AccEvent> event =
58370:           new AccEvent(nsIAccessibleEvent::EVENT_MENUPOPUP_END, accessible);
58370: 
58370:         if (event)
58370:           FireDelayedAccessibleEvent(event);
58370:       }
58370:     }
58370: 
56292:     // Fire show/hide event.
56292:     nsRefPtr<AccEvent> event;
56292:     if (aIsInsert)
60746:       event = new AccShowEvent(accessible, node);
56292:     else
60746:       event = new AccHideEvent(accessible, node);
56292: 
56292:     if (event)
56292:       FireDelayedAccessibleEvent(event);
56292: 
56292:     if (aIsInsert) {
58433:       PRUint32 ariaRole = accessible->ARIARole();
58433:       if (ariaRole == nsIAccessibleRole::ROLE_MENUPOPUP) {
56292:         // Fire EVENT_MENUPOPUP_START if ARIA menu appears.
56292:         FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_MENUPOPUP_START,
60746:                                    node, AccEvent::eRemoveDupes);
56292: 
58433:       } else if (ariaRole == nsIAccessibleRole::ROLE_ALERT) {
56292:         // Fire EVENT_ALERT if ARIA alert appears.
56292:         updateFlags = eAlertAccessible;
56292:         FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_ALERT, node,
60746:                                    AccEvent::eRemoveDupes);
56292:       }
56292: 
56292:       // If focused node has been shown then it means its frame was recreated
56292:       // while it's focused. Fire focus event on new focused accessible. If
56292:       // the queue contains focus event for this node then it's suppressed by
56292:       // this one.
56292:       if (node == gLastFocusedNode) {
56292:         FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_FOCUS,
60746:                                    node, AccEvent::eCoalesceFromSameDocument);
56292:       }
56292:     } else {
56292:       // Update the tree for content removal.
59274:       // The accessible parent may differ from container accessible if
59274:       // the parent doesn't have own DOM node like list accessible for HTML
59274:       // selects.
59274:       nsAccessible* parent = accessible->GetParent();
59274:       NS_ASSERTION(parent, "No accessible parent?!");
59274:       parent->RemoveChild(accessible);
59274: 
56292:       UncacheChildrenInSubtree(accessible);
56292:     }
56292:   }
56292: 
56292:   return updateFlags;
    1: }
32285: 
43504: void
56292: nsDocAccessible::UncacheChildrenInSubtree(nsAccessible* aRoot)
11165: {
56292:   PRUint32 count = aRoot->GetCachedChildCount();
56292:   for (PRUint32 idx = 0; idx < count; idx++)
56292:     UncacheChildrenInSubtree(aRoot->GetCachedChildAt(idx));
11165: 
56292:   if (aRoot->IsPrimaryForNode() &&
56292:       mNodeToAccessibleMap.Get(aRoot->GetNode()) == aRoot)
56292:     mNodeToAccessibleMap.Remove(aRoot->GetNode());
11165: }
11165: 
43504: void
56292: nsDocAccessible::ShutdownChildrenInSubtree(nsAccessible* aAccessible)
    1: {
56292:   // Traverse through children and shutdown them before this accessible. When
56292:   // child gets shutdown then it removes itself from children array of its
56292:   //parent. Use jdx index to process the cases if child is not attached to the
56292:   // parent and as result doesn't remove itself from its children.
56292:   PRUint32 count = aAccessible->GetCachedChildCount();
56292:   for (PRUint32 idx = 0, jdx = 0; idx < count; idx++) {
56292:     nsAccessible* child = aAccessible->GetCachedChildAt(jdx);
56292:     if (!child->IsBoundToParent()) {
56292:       NS_ERROR("Parent refers to a child, child doesn't refer to parent!");
56292:       jdx++;
10580:     }
10580: 
56292:     ShutdownChildrenInSubtree(child);
10625:   }
 8231: 
57413:   UnbindFromDocument(aAccessible);
 8231: }
