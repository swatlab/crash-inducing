29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
18830:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS function support.
    1:  */
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsbit.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
31823: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
21866: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
47498: #include "jsproxy.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
    1: #include "jsexn.h"
18989: #include "jsstaticcheck.h"
32710: #include "jstracer.h"
    1: 
    1: #if JS_HAS_GENERATORS
    1: # include "jsiter.h"
    1: #endif
    1: 
11435: #if JS_HAS_XDR
11435: # include "jsxdrapi.h"
11435: #endif
11435: 
53520: #ifdef JS_METHODJIT
53520: #include "methodjit/MethodJIT.h"
53520: #endif
53520: 
30283: #include "jsatominlines.h"
42714: #include "jscntxtinlines.h"
51095: #include "jsfuninlines.h"
40410: #include "jsobjinlines.h"
48470: #include "jscntxtinlines.h"
30283: 
37741: using namespace js;
37741: 
51090: inline JSObject *
51090: JSObject::getThrowTypeError() const
51090: {
51090:     return &getGlobal()->getReservedSlot(JSRESERVED_GLOBAL_THROWTYPEERROR).toObject();
51090: }
51090: 
    1: JSBool
48470: js_GetArgsValue(JSContext *cx, JSStackFrame *fp, Value *vp)
    1: {
    1:     JSObject *argsobj;
    1: 
31823:     if (fp->flags & JSFRAME_OVERRIDE_ARGS) {
50510:         JS_ASSERT(fp->hasCallObj());
31823:         jsid id = ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom);
50510:         return fp->getCallObj()->getProperty(cx, id, vp);
    1:     }
    1:     argsobj = js_GetArgsObject(cx, fp);
    1:     if (!argsobj)
    1:         return JS_FALSE;
48470:     vp->setObject(*argsobj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
48470: js_GetArgsProperty(JSContext *cx, JSStackFrame *fp, jsid id, Value *vp)
    1: {
31823:     if (fp->flags & JSFRAME_OVERRIDE_ARGS) {
50510:         JS_ASSERT(fp->hasCallObj());
31823: 
31823:         jsid argumentsid = ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom);
48470:         Value v;
50510:         if (!fp->getCallObj()->getProperty(cx, argumentsid, &v))
31823:             return false;
31823: 
    1:         JSObject *obj;
48470:         if (v.isPrimitive()) {
31823:             obj = js_ValueToNonNullObject(cx, v);
    1:             if (!obj)
31823:                 return false;
    1:         } else {
48470:             obj = &v.toObject();
    1:         }
31501:         return obj->getProperty(cx, id, vp);
    1:     }
    1: 
48470:     vp->setUndefined();
    1:     if (JSID_IS_INT(id)) {
31823:         uint32 arg = uint32(JSID_TO_INT(id));
50510:         JSObject *argsobj = fp->maybeArgsObj();
51120:         if (arg < fp->numActualArgs()) {
31823:             if (argsobj) {
48470:                 if (argsobj->getArgsElement(arg).isMagic(JS_ARGS_HOLE))
31823:                     return argsobj->getProperty(cx, id, vp);
31823:             }
31823:             *vp = fp->argv[arg];
    1:         } else {
    1:             /*
    1:              * Per ECMA-262 Ed. 3, 10.1.8, last bulleted item, do not share
    1:              * storage between the formal parameter and arguments[k] for all
 4127:              * fp->argc <= k && k < fp->fun->nargs.  For example, in
    1:              *
    1:              *   function f(x) { x = 42; return arguments[0]; }
    1:              *   f();
    1:              *
    1:              * the call to f should return undefined, not 42.  If fp->argsobj
    1:              * is null at this point, as it would be in the example, return
    1:              * undefined in *vp.
    1:              */
31823:             if (argsobj)
31823:                 return argsobj->getProperty(cx, id, vp);
    1:         }
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
50510:         JSObject *argsobj = fp->maybeArgsObj();
40864:         if (argsobj && argsobj->isArgsLengthOverridden())
31823:             return argsobj->getProperty(cx, id, vp);
51120:         vp->setInt32(fp->numActualArgs());
    1:     }
31823:     return true;
    1: }
31823: 
31823: static JSObject *
31823: NewArguments(JSContext *cx, JSObject *parent, uint32 argc, JSObject *callee)
31823: {
40405:     JSObject *proto;
40405:     if (!js_GetClassPrototype(cx, parent, JSProto_Object, &proto))
31823:         return NULL;
31823: 
40405:     JSObject *argsobj = js_NewGCObject(cx);
40405:     if (!argsobj)
40405:         return NULL;
40405: 
40405:     /* Init immediately to avoid GC seeing a half-init'ed object. */
51095:     bool strict = callee->getFunctionPrivate()->inStrictMode();
51095:     argsobj->init(strict ? &StrictArgumentsClass : &js_ArgumentsClass, proto, parent,
51095:                   PrivateValue(NULL));
40864:     argsobj->setArgsLength(argc);
51095:     argsobj->setArgsCallee(ObjectValue(*callee));
43221:     argsobj->map = cx->runtime->emptyArgumentsScope->hold();
40405: 
40405:     /* This must come after argsobj->map has been set. */
40405:     if (!js_EnsureReservedSlots(cx, argsobj, argc))
40405:         return NULL;
51095: 
31823:     return argsobj;
31823: }
31823: 
31823: static void
48470: PutArguments(JSContext *cx, JSObject *argsobj, Value *args)
31823: {
51097:     JS_ASSERT(argsobj->isNormalArguments());
51091:     uint32 argc = argsobj->getArgsInitialLength();
31823:     for (uint32 i = 0; i != argc; ++i) {
48470:         if (!argsobj->getArgsElement(i).isMagic(JS_ARGS_HOLE))
41871:             argsobj->setArgsElement(i, args[i]);
31823:     }
    1: }
    1: 
    1: JSObject *
    1: js_GetArgsObject(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     /*
    1:      * We must be in a function activation; the function must be lightweight
    1:      * or else fp must have a variable object.
    1:      */
51056:     JS_ASSERT(fp->hasFunction());
51056:     JS_ASSERT_IF(fp->getFunction()->flags & JSFUN_HEAVYWEIGHT,
48531:                  fp->varobj(cx->containingSegment(fp)));
    1: 
    1:     /* Skip eval and debugger frames. */
    1:     while (fp->flags & JSFRAME_SPECIAL)
    1:         fp = fp->down;
    1: 
    1:     /* Create an arguments object for fp only if it lacks one. */
50510:     if (fp->hasArgsObj())
50510:         return fp->getArgsObj();
    1: 
47497:     /* Compute the arguments object's parent slot from fp's scope chain. */
51052:     JSObject *global = fp->getScopeChain()->getGlobal();
51120:     JSObject *argsobj = NewArguments(cx, global, fp->numActualArgs(), &fp->argv[-2].toObject());
31447:     if (!argsobj)
31823:         return argsobj;
31447: 
51097:     /*
51097:      * Strict mode functions have arguments which copy the initial parameter
51097:      * values.  It is the caller's responsibility to get the arguments object
51097:      * before any parameters are modified!  (The emitter ensures this by
51097:      * synthesizing an arguments access at the start of any strict mode
51097:      * function which contains an assignment to a parameter or which calls
51097:      * eval.)  Non-strict mode arguments use the frame pointer to retrieve
51097:      * up-to-date parameter values.
51097:      */
51097:     if (argsobj->isStrictArguments()) {
51120:         JS_ASSERT_IF(fp->numActualArgs() > 0,
51120:                      argsobj->dslots[-1].toPrivateUint32() >= fp->numActualArgs());
51120:         memcpy(argsobj->dslots, fp->argv, fp->numActualArgs() * sizeof(Value));
51097:     } else {
31452:         argsobj->setPrivate(fp);
51097:     }
51097: 
50510:     fp->setArgsObj(argsobj);
    1:     return argsobj;
    1: }
    1: 
31823: void
    1: js_PutArgsObject(JSContext *cx, JSStackFrame *fp)
    1: {
50510:     JSObject *argsobj = fp->getArgsObj();
51097:     if (argsobj->isNormalArguments()) {
31823:         JS_ASSERT(argsobj->getPrivate() == fp);
31823:         PutArguments(cx, argsobj, fp->argv);
31823:         argsobj->setPrivate(NULL);
51097:     } else {
51097:         JS_ASSERT(!argsobj->getPrivate());
51097:     }
50510:     fp->setArgsObj(NULL);
31823: }
    1: 
    1: /*
31823:  * Traced versions of js_GetArgsObject and js_PutArgsObject.
    1:  */
32709: 
32709: #ifdef JS_TRACER
31824: JSObject * JS_FASTCALL
49124: js_Arguments(JSContext *cx, JSObject *parent, uint32 argc, JSObject *callee)
31823: {
32709:     JSObject *argsobj = NewArguments(cx, parent, argc, callee);
33110:     if (!argsobj)
33110:         return NULL;
51097: 
51097:     if (callee->getFunctionPrivate()->inStrictMode()) {
51097:         /*
51097:          * Strict mode callers must copy arguments into the created arguments
51097:          * object.
51097:          */
51097:         JS_ASSERT(!argsobj->getPrivate());
51097:     } else {
49124:         argsobj->setPrivate(JS_ARGUMENT_OBJECT_ON_TRACE);
51097:     }
51097: 
32709:     return argsobj;
    1: }
32709: #endif
32709: 
49124: JS_DEFINE_CALLINFO_4(extern, OBJECT, js_Arguments, CONTEXT, OBJECT, UINT32, OBJECT,
49124:                      0, nanojit::ACCSET_STORE_ANY)
31823: 
31823: /* FIXME change the return type to void. */
31823: JSBool JS_FASTCALL
48470: js_PutArguments(JSContext *cx, JSObject *argsobj, Value *args)
31823: {
51097:     JS_ASSERT(argsobj->isNormalArguments());
49124:     JS_ASSERT(argsobj->getPrivate() == JS_ARGUMENT_OBJECT_ON_TRACE);
31823:     PutArguments(cx, argsobj, args);
34328:     argsobj->setPrivate(NULL);
31823:     return true;
    1: }
    1: 
48470: JS_DEFINE_CALLINFO_3(extern, BOOL, js_PutArguments, CONTEXT, OBJECT, VALUEPTR, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
31823: 
    1: static JSBool
48470: args_delProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
40405:     JS_ASSERT(obj->isArguments());
    1: 
48470:     if (JSID_IS_INT(id)) {
48470:         uintN arg = uintN(JSID_TO_INT(id));
51091:         if (arg < obj->getArgsInitialLength())
48470:             obj->setArgsElement(arg, MagicValue(JS_ARGS_HOLE));
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
40864:         obj->setArgsLengthOverridden();
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom)) {
48470:         obj->setArgsCallee(MagicValue(JS_ARGS_HOLE));
    1:     }
31447:     return true;
    1: }
    1: 
28952: static JS_REQUIRES_STACK JSObject *
50500: WrapEscapingClosure(JSContext *cx, JSStackFrame *fp, JSFunction *fun)
28952: {
29009:     JS_ASSERT(fun->optimizedClosure());
28952:     JS_ASSERT(!fun->u.i.wrapper);
28952: 
28952:     /*
28952:      * We do not attempt to reify Call and Block objects on demand for outer
28952:      * scopes. This could be done (see the "v8" patch in bug 494235) but it is
28952:      * fragile in the face of ongoing compile-time optimization. Instead, the
28952:      * _DBG* opcodes used by wrappers created here must cope with unresolved
28952:      * upvars and throw them as reference errors. Caveat debuggers!
28952:      */
28952:     JSObject *scopeChain = js_GetScopeChain(cx, fp);
28952:     if (!scopeChain)
28952:         return NULL;
28952: 
50500:     JSObject *wfunobj = NewFunction(cx, scopeChain);
28952:     if (!wfunobj)
28952:         return NULL;
48470:     AutoObjectRooter tvr(cx, wfunobj);
28952: 
28952:     JSFunction *wfun = (JSFunction *) wfunobj;
32684:     wfunobj->setPrivate(wfun);
28952:     wfun->nargs = 0;
28952:     wfun->flags = fun->flags | JSFUN_HEAVYWEIGHT;
28952:     wfun->u.i.nvars = 0;
28952:     wfun->u.i.nupvars = 0;
28952:     wfun->u.i.skipmin = fun->u.i.skipmin;
28952:     wfun->u.i.wrapper = true;
28952:     wfun->u.i.script = NULL;
28952:     wfun->u.i.names.taggedAtom = NULL;
28952:     wfun->atom = fun->atom;
28952: 
28952:     if (fun->hasLocalNames()) {
47609:         void *mark = JS_ARENA_MARK(&cx->tempPool);
28952:         jsuword *names = js_GetLocalNameArray(cx, fun, &cx->tempPool);
28952:         if (!names)
28952:             return NULL;
28952: 
28952:         JSBool ok = true;
28952:         for (uintN i = 0, n = fun->countLocalNames(); i != n; i++) {
28952:             jsuword name = names[i];
28952:             JSAtom *atom = JS_LOCAL_NAME_TO_ATOM(name);
28952:             JSLocalKind localKind = (i < fun->nargs)
28952:                                     ? JSLOCAL_ARG
28952:                                     : (i < fun->countArgsAndVars())
28952:                                     ? (JS_LOCAL_NAME_IS_CONST(name)
28952:                                        ? JSLOCAL_CONST
28952:                                        : JSLOCAL_VAR)
28952:                                     : JSLOCAL_UPVAR;
28952: 
28952:             ok = js_AddLocal(cx, wfun, atom, localKind);
28952:             if (!ok)
28952:                 break;
28952:         }
28952: 
47609:         JS_ARENA_RELEASE(&cx->tempPool, mark);
28952:         if (!ok)
28952:             return NULL;
28952:         JS_ASSERT(wfun->nargs == fun->nargs);
28952:         JS_ASSERT(wfun->u.i.nvars == fun->u.i.nvars);
28952:         JS_ASSERT(wfun->u.i.nupvars == fun->u.i.nupvars);
28952:         js_FreezeLocalNames(cx, wfun);
28952:     }
28952: 
28952:     JSScript *script = fun->u.i.script;
32723:     jssrcnote *snbase = script->notes();
28952:     jssrcnote *sn = snbase;
28952:     while (!SN_IS_TERMINATOR(sn))
28952:         sn = SN_NEXT(sn);
28952:     uintN nsrcnotes = (sn - snbase) + 1;
28952: 
28952:     /* NB: GC must not occur before wscript is homed in wfun->u.i.script. */
28952:     JSScript *wscript = js_NewScript(cx, script->length, nsrcnotes,
28952:                                      script->atomMap.length,
28952:                                      (script->objectsOffset != 0)
32723:                                      ? script->objects()->length
28952:                                      : 0,
28952:                                      fun->u.i.nupvars,
28952:                                      (script->regexpsOffset != 0)
32723:                                      ? script->regexps()->length
28952:                                      : 0,
28952:                                      (script->trynotesOffset != 0)
32723:                                      ? script->trynotes()->length
48470:                                      : 0,
48470:                                      (script->constOffset != 0)
48470:                                      ? script->consts()->length
52684:                                      : 0,
52555:                                      (script->globalsOffset != 0)
52555:                                      ? script->globals()->length
28952:                                      : 0);
28952:     if (!wscript)
28952:         return NULL;
28952: 
28952:     memcpy(wscript->code, script->code, script->length);
28952:     wscript->main = wscript->code + (script->main - script->code);
28952: 
32723:     memcpy(wscript->notes(), snbase, nsrcnotes * sizeof(jssrcnote));
28952:     memcpy(wscript->atomMap.vector, script->atomMap.vector,
28952:            wscript->atomMap.length * sizeof(JSAtom *));
28952:     if (script->objectsOffset != 0) {
32723:         memcpy(wscript->objects()->vector, script->objects()->vector,
32723:                wscript->objects()->length * sizeof(JSObject *));
28952:     }
28952:     if (script->regexpsOffset != 0) {
32723:         memcpy(wscript->regexps()->vector, script->regexps()->vector,
32723:                wscript->regexps()->length * sizeof(JSObject *));
28952:     }
28952:     if (script->trynotesOffset != 0) {
32723:         memcpy(wscript->trynotes()->vector, script->trynotes()->vector,
32723:                wscript->trynotes()->length * sizeof(JSTryNote));
28952:     }
52555:     if (script->globalsOffset != 0) {
52555:         memcpy(wscript->globals()->vector, script->globals()->vector,
52555:                wscript->globals()->length * sizeof(GlobalSlotArray::Entry));
52555:     }
28952: 
28952:     if (wfun->u.i.nupvars != 0) {
32723:         JS_ASSERT(wfun->u.i.nupvars == wscript->upvars()->length);
32723:         memcpy(wscript->upvars()->vector, script->upvars()->vector,
28952:                wfun->u.i.nupvars * sizeof(uint32));
28952:     }
28952: 
28952:     jsbytecode *pc = wscript->code;
28952:     while (*pc != JSOP_STOP) {
28952:         /* XYZZYbe should copy JSOP_TRAP? */
28952:         JSOp op = js_GetOpcode(cx, wscript, pc);
28952:         const JSCodeSpec *cs = &js_CodeSpec[op];
28952:         ptrdiff_t oplen = cs->length;
28952:         if (oplen < 0)
28952:             oplen = js_GetVariableBytecodeLength(pc);
28952: 
28952:         /*
28952:          * Rewrite JSOP_{GET,CALL}DSLOT as JSOP_{GET,CALL}UPVAR_DBG for the
28952:          * case where fun is an escaping flat closure. This works because the
28952:          * UPVAR and DSLOT ops by design have the same format: an upvar index
28952:          * immediate operand.
28952:          */
28952:         switch (op) {
28952:           case JSOP_GETUPVAR:       *pc = JSOP_GETUPVAR_DBG; break;
28952:           case JSOP_CALLUPVAR:      *pc = JSOP_CALLUPVAR_DBG; break;
28952:           case JSOP_GETDSLOT:       *pc = JSOP_GETUPVAR_DBG; break;
28952:           case JSOP_CALLDSLOT:      *pc = JSOP_CALLUPVAR_DBG; break;
28952:           case JSOP_DEFFUN_FC:      *pc = JSOP_DEFFUN_DBGFC; break;
28952:           case JSOP_DEFLOCALFUN_FC: *pc = JSOP_DEFLOCALFUN_DBGFC; break;
28952:           case JSOP_LAMBDA_FC:      *pc = JSOP_LAMBDA_DBGFC; break;
28952:           default:;
28952:         }
28952:         pc += oplen;
28952:     }
28952: 
28952:     /*
29009:      * Fill in the rest of wscript. This means if you add members to JSScript
29009:      * you must update this code. FIXME: factor into JSScript::clone method.
28952:      */
33750:     wscript->noScriptRval = script->noScriptRval;
33750:     wscript->savedCallerFun = script->savedCallerFun;
33750:     wscript->hasSharps = script->hasSharps;
35113:     wscript->strictModeCode = script->strictModeCode;
28952:     wscript->version = script->version;
28952:     wscript->nfixed = script->nfixed;
28952:     wscript->filename = script->filename;
28952:     wscript->lineno = script->lineno;
28952:     wscript->nslots = script->nslots;
28952:     wscript->staticLevel = script->staticLevel;
28952:     wscript->principals = script->principals;
28952:     if (wscript->principals)
28952:         JSPRINCIPALS_HOLD(cx, wscript->principals);
28952: #ifdef CHECK_SCRIPT_OWNER
28952:     wscript->owner = script->owner;
28952: #endif
28952: 
28952:     /* Deoptimize wfun from FUN_{FLAT,NULL}_CLOSURE to FUN_INTERPRETED. */
28952:     FUN_SET_KIND(wfun, JSFUN_INTERPRETED);
28952:     wfun->u.i.script = wscript;
28952:     return wfunobj;
28952: }
28952: 
    1: static JSBool
48470: ArgGetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
49124:     LeaveTrace(cx);
49124: 
48470:     if (!InstanceOf(cx, obj, &js_ArgumentsClass, NULL))
31447:         return true;
31447: 
48470:     if (JSID_IS_INT(id)) {
31447:         /*
31447:          * arg can exceed the number of arguments if a script changed the
31447:          * prototype to point to another Arguments object with a bigger argc.
31447:          */
48470:         uintN arg = uintN(JSID_TO_INT(id));
51091:         if (arg < obj->getArgsInitialLength()) {
31823:             JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
31823:             if (fp) {
31447:                 *vp = fp->argv[arg];
31823:             } else {
48470:                 const Value &v = obj->getArgsElement(arg);
48470:                 if (!v.isMagic(JS_ARGS_HOLE))
31823:                     *vp = v;
31823:             }
31823:         }
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
40864:         if (!obj->isArgsLengthOverridden())
51091:             vp->setInt32(obj->getArgsInitialLength());
31447:     } else {
48470:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom));
48470:         const Value &v = obj->getArgsCallee();
48470:         if (!v.isMagic(JS_ARGS_HOLE)) {
29009:             /*
29009:              * If this function or one in it needs upvars that reach above it
29009:              * in the scope chain, it must not be a null closure (it could be a
29009:              * flat closure, or an unoptimized closure -- the latter itself not
29009:              * necessarily heavyweight). Rather than wrap here, we simply throw
29009:              * to reduce code size and tell debugger users the truth instead of
29009:              * passing off a fibbing wrapper.
29009:              */
48470:             if (GET_FUNCTION_PRIVATE(cx, &v.toObject())->needsWrapper()) {
28964:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28964:                                      JSMSG_OPTIMIZED_CLOSURE_LEAK);
31447:                 return false;
28964:             }
31823:             *vp = v;
28964:         }
    1:     }
31447:     return true;
    1: }
    1: 
    1: static JSBool
48470: ArgSetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
35056: #ifdef JS_TRACER
35054:     // To be able to set a property here on trace, we would have to make
35054:     // sure any updates also get written back to the trace native stack.
35054:     // For simplicity, we just leave trace, since this is presumably not
35054:     // a common operation.
35054:     if (JS_ON_TRACE(cx)) {
37741:         DeepBail(cx);
35054:         return false;
35054:     }
35056: #endif
35054: 
48470:     if (!InstanceOf(cx, obj, &js_ArgumentsClass, NULL))
31447:         return true;
31447: 
48470:     if (JSID_IS_INT(id)) {
48470:         uintN arg = uintN(JSID_TO_INT(id));
51091:         if (arg < obj->getArgsInitialLength()) {
31823:             JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
31823:             if (fp) {
31447:                 fp->argv[arg] = *vp;
31823:                 return true;
31823:             }
31447:         }
31447:     } else {
48470:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom) ||
48470:                   JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom));
31447:     }
31823: 
31823:     /*
31823:      * For simplicity we use delete/set to replace the property with one
51095:      * backed by the default Object getter and setter. Note that we rely on
51095:      * args_delProperty to clear the corresponding reserved slot so the GC can
31823:      * collect its value.
31823:      */
40389:     AutoValueRooter tvr(cx);
31823:     return js_DeleteProperty(cx, obj, id, tvr.addr()) &&
31823:            js_SetProperty(cx, obj, id, vp);
31447: }
31447: 
31447: static JSBool
48470: args_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
31447:              JSObject **objp)
31447: {
51095:     JS_ASSERT(obj->isNormalArguments());
31823: 
31447:     *objp = NULL;
48470:     bool valid = false;
51099:     uintN attrs = JSPROP_SHARED;
48470:     if (JSID_IS_INT(id)) {
48470:         uint32 arg = uint32(JSID_TO_INT(id));
51099:         attrs = JSPROP_ENUMERATE | JSPROP_SHARED;
51091:         if (arg < obj->getArgsInitialLength() && !obj->getArgsElement(arg).isMagic(JS_ARGS_HOLE))
48470:             valid = true;
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
40864:         if (!obj->isArgsLengthOverridden())
48470:             valid = true;
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom)) {
51095:         if (!obj->getArgsCallee().isMagic(JS_ARGS_HOLE))
51095:             valid = true;
31447:     }
31823: 
48470:     if (valid) {
48470:         Value tmp = UndefinedValue();
51099:         if (!js_DefineProperty(cx, obj, id, &tmp, ArgGetter, ArgSetter, attrs))
31823:             return JS_FALSE;
31447:         *objp = obj;
31823:     }
31447:     return true;
31447: }
31447: 
31447: static JSBool
31447: args_enumerate(JSContext *cx, JSObject *obj)
31447: {
51095:     JS_ASSERT(obj->isNormalArguments());
31447: 
    1:     /*
31823:      * Trigger reflection in args_resolve using a series of js_LookupProperty
31823:      * calls.
    1:      */
51091:     int argc = int(obj->getArgsInitialLength());
31447:     for (int i = -2; i != argc; i++) {
31447:         jsid id = (i == -2)
31447:                   ? ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)
31447:                   : (i == -1)
31447:                   ? ATOM_TO_JSID(cx->runtime->atomState.calleeAtom)
48470:                   : INT_TO_JSID(i);
31447: 
31447:         JSObject *pobj;
31447:         JSProperty *prop;
31447:         if (!js_LookupProperty(cx, obj, id, &pobj, &prop))
31447:             return false;
31823: 
31823:         /* prop is null when the property was deleted. */
    1:         if (prop)
31501:             pobj->dropProperty(cx, prop);
    1:     }
31447:     return true;
    1: }
    1: 
51095: namespace {
51095: 
51095: JSBool
51095: StrictArgGetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
51095: {
51095:     LeaveTrace(cx);
51095: 
51095:     if (!InstanceOf(cx, obj, &StrictArgumentsClass, NULL))
51095:         return true;
51095: 
51095:     if (JSID_IS_INT(id)) {
51095:         /*
51095:          * arg can exceed the number of arguments if a script changed the
51095:          * prototype to point to another Arguments object with a bigger argc.
51095:          */
51095:         uintN arg = uintN(JSID_TO_INT(id));
51095:         if (arg < obj->getArgsInitialLength()) {
51095:             const Value &v = obj->getArgsElement(arg);
51095:             if (!v.isMagic(JS_ARGS_HOLE))
51095:                 *vp = v;
51095:         }
51095:     } else {
51095:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
51095:         if (!obj->isArgsLengthOverridden())
51095:             vp->setInt32(obj->getArgsInitialLength());
51095:     }
51095:     return true;
51095: }
51095: 
51095: JSBool
51095: StrictArgSetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
51095: {
51095:     if (!InstanceOf(cx, obj, &StrictArgumentsClass, NULL))
51095:         return true;
51095: 
51095:     if (JSID_IS_INT(id)) {
51095:         uintN arg = uintN(JSID_TO_INT(id));
51095:         if (arg < obj->getArgsInitialLength()) {
51095:             obj->setArgsElement(arg, *vp);
51095:             return true;
51095:         }
51095:     } else {
51095:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
51095:     }
51095: 
51095:     /*
51095:      * For simplicity we use delete/set to replace the property with one
51095:      * backed by the default Object getter and setter. Note that we rely on
51095:      * args_delProperty to clear the corresponding reserved slot so the GC can
51095:      * collect its value.
51095:      */
51095:     AutoValueRooter tvr(cx);
51095:     return js_DeleteProperty(cx, obj, id, tvr.addr()) &&
51095:            js_SetProperty(cx, obj, id, vp);
51095: }
51095: 
51095: JSBool
51095: strictargs_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags, JSObject **objp)
51095: {
51095:     JS_ASSERT(obj->isStrictArguments());
51095: 
51095:     *objp = NULL;
51095:     bool valid = false;
51099:     uintN attrs = JSPROP_SHARED;
51095:     if (JSID_IS_INT(id)) {
51095:         uint32 arg = uint32(JSID_TO_INT(id));
51099:         attrs = JSPROP_SHARED | JSPROP_ENUMERATE;
51095:         if (arg < obj->getArgsInitialLength() && !obj->getArgsElement(arg).isMagic(JS_ARGS_HOLE))
51095:             valid = true;
51095:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
51095:         if (!obj->isArgsLengthOverridden())
51095:             valid = true;
51095:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom)) {
51095:         Value tmp = UndefinedValue();
51095:         PropertyOp throwTypeError = CastAsPropertyOp(obj->getThrowTypeError());
51095:         uintN attrs = JSPROP_PERMANENT | JSPROP_GETTER | JSPROP_SETTER | JSPROP_SHARED;
51095:         if (!js_DefineProperty(cx, obj, id, &tmp, throwTypeError, throwTypeError, attrs))
51095:             return false;
51095: 
51095:         *objp = obj;
51095:         return true;
51095:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.callerAtom)) {
51095:         /*
51095:          * Strict mode arguments objects have an immutable poison-pill caller
51095:          * property that throws a TypeError on getting or setting.
51095:          */
51095:         PropertyOp throwTypeError = CastAsPropertyOp(obj->getThrowTypeError());
51095:         Value tmp = UndefinedValue();
51095:         if (!js_DefineProperty(cx, obj, id, &tmp, throwTypeError, throwTypeError,
51095:                                JSPROP_PERMANENT | JSPROP_GETTER | JSPROP_SETTER | JSPROP_SHARED)) {
51095:             return false;
51095:         }
51095: 
51095:         *objp = obj;
51095:         return true;
51095:     }
51095: 
51095:     if (valid) {
51095:         Value tmp = UndefinedValue();
51099:         if (!js_DefineProperty(cx, obj, id, &tmp, StrictArgGetter, StrictArgSetter, attrs))
51099:             return false;
51095:         *objp = obj;
51095:     }
51095:     return true;
51095: }
51095: 
51095: JSBool
51095: strictargs_enumerate(JSContext *cx, JSObject *obj)
51095: {
51095:     JS_ASSERT(obj->isStrictArguments());
51095: 
51095:     /*
51095:      * Trigger reflection in strictargs_resolve using a series of
51095:      * js_LookupProperty calls.  Beware deleted properties!
51095:      */
51095:     JSObject *pobj;
51095:     JSProperty *prop;
51095: 
51095:     // length
51095:     if (!js_LookupProperty(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom), &pobj, &prop))
51095:         return false;
51095:     if (prop)
51095:         pobj->dropProperty(cx, prop);
51095: 
51095:     // callee
51095:     if (!js_LookupProperty(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.calleeAtom), &pobj, &prop))
51095:         return false;
51095:     if (prop)
51095:         pobj->dropProperty(cx, prop);
51095: 
51095:     // caller
51095:     if (!js_LookupProperty(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.callerAtom), &pobj, &prop))
51095:         return false;
51095:     if (prop)
51095:         pobj->dropProperty(cx, prop);
51095: 
51095:     for (uint32 i = 0, argc = obj->getArgsInitialLength(); i < argc; i++) {
51095:         if (!js_LookupProperty(cx, obj, INT_TO_JSID(i), &pobj, &prop))
51095:             return false;
51095:         if (prop)
51095:             pobj->dropProperty(cx, prop);
51095:     }
51095: 
51095:     return true;
51095: }
51095: 
51095: } // namespace
51095: 
    1: #if JS_HAS_GENERATORS
    1: /*
42714:  * If a generator's arguments or call object escapes, and the generator frame
42714:  * is not executing, the generator object needs to be marked because it is not
42714:  * otherwise reachable. An executing generator is rooted by its invocation.  To
42714:  * distinguish the two cases (which imply different access paths to the
42714:  * generator object), we use the JSFRAME_FLOATING_GENERATOR flag, which is only
42714:  * set on the JSStackFrame kept in the generator object's JSGenerator.
    1:  */
  583: static void
  583: args_or_call_trace(JSTracer *trc, JSObject *obj)
    1: {
40405:     if (obj->isArguments()) {
49124:         if (obj->getPrivate() == JS_ARGUMENT_OBJECT_ON_TRACE)
32709:             return;
40405:     } else {
40405:         JS_ASSERT(obj->getClass() == &js_CallClass);
40405:     }
31823: 
31823:     JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
42714:     if (fp && fp->isFloatingGenerator()) {
42714:         JSObject *obj = js_FloatingFrameToGenerator(fp)->obj;
42714:         JS_CALL_OBJECT_TRACER(trc, obj, "generator object");
  583:     }
    1: }
    1: #else
  583: # define args_or_call_trace NULL
    1: #endif
    1: 
    1: /*
51095:  * The Arguments classes aren't initialized via JS_InitClass, because arguments
48462:  * objects have the initial value of Object.prototype as their [[Prototype]].
48462:  * However, Object.prototype.toString.call(arguments) === "[object Arguments]"
51095:  * per ES5 (although not ES3), so the class name is "Arguments" rather than
48462:  * "Object".
51095:  */
51095: 
51095: /*
    1:  *
    1:  * The JSClass functions below collaborate to lazily reflect and synchronize
    1:  * actual argument values, argument count, and callee function object stored
    1:  * in a JSStackFrame with their corresponding property values in the frame's
    1:  * arguments object.
    1:  */
48470: Class js_ArgumentsClass = {
48462:     "Arguments",
31823:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE |
40864:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::ARGS_FIXED_RESERVED_SLOTS) |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
48622:     PropertyStub,   /* addProperty */
48622:     args_delProperty,
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
48622:     args_enumerate,
48622:     (JSResolveOp) args_resolve,
48622:     ConvertStub,
48622:     NULL,           /* finalize   */
48622:     NULL,           /* reserved0   */
48622:     NULL,           /* checkAccess */
48622:     NULL,           /* call        */
48622:     NULL,           /* construct   */
48622:     NULL,           /* xdrObject   */
48622:     NULL,           /* hasInstance */
48622:     JS_CLASS_TRACE(args_or_call_trace)
    1: };
    1: 
51095: namespace js {
51095: 
51095: /*
51095:  * Strict mode arguments is significantly less magical than non-strict mode
51095:  * arguments, so it is represented by a different class while sharing some
51095:  * functionality.
51095:  */
51095: Class StrictArgumentsClass = {
51095:     "Arguments",
51095:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE |
51095:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::ARGS_FIXED_RESERVED_SLOTS) |
51095:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
51095:     PropertyStub,   /* addProperty */
51095:     args_delProperty,
51095:     PropertyStub,   /* getProperty */
51095:     PropertyStub,   /* setProperty */
51095:     strictargs_enumerate,
51095:     reinterpret_cast<JSResolveOp>(strictargs_resolve),
51095:     ConvertStub,
51095:     NULL,           /* finalize   */
51095:     NULL,           /* reserved0   */
51095:     NULL,           /* checkAccess */
51095:     NULL,           /* call        */
51095:     NULL,           /* construct   */
51095:     NULL,           /* xdrObject   */
51095:     NULL,           /* hasInstance */
51095:     JS_CLASS_TRACE(args_or_call_trace)
51095: };
51095: 
51095: }
51095: 
31823: const uint32 JSSLOT_CALLEE =                    JSSLOT_PRIVATE + 1;
31823: const uint32 JSSLOT_CALL_ARGUMENTS =            JSSLOT_PRIVATE + 2;
31823: const uint32 CALL_CLASS_FIXED_RESERVED_SLOTS =  2;
15588: 
28952: /*
28952:  * A Declarative Environment object stores its active JSStackFrame pointer in
28952:  * its private slot, just as Call and Arguments objects do.
28952:  */
48470: Class js_DeclEnvClass = {
27319:     js_Object_str,
28952:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
48622:     PropertyStub,   /* addProperty */
48622:     PropertyStub,   /* delProperty */
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub
27319: };
27319: 
29888: static JSBool
48470: CheckForEscapingClosure(JSContext *cx, JSObject *obj, Value *vp)
28952: {
40410:     JS_ASSERT(obj->getClass() == &js_CallClass ||
40410:               obj->getClass() == &js_DeclEnvClass);
28952: 
48470:     const Value &v = *vp;
48470: 
48470:     JSObject *funobj;
48470:     if (IsFunctionObject(v, &funobj)) {
28952:         JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
28952: 
28952:         /*
28952:          * Any escaping null or flat closure that reaches above itself or
28952:          * contains nested functions that reach above it must be wrapped.
28952:          * We can wrap only when this Call or Declarative Environment obj
28952:          * still has an active stack frame associated with it.
28952:          */
29009:         if (fun->needsWrapper()) {
37741:             LeaveTrace(cx);
29888: 
31823:             JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
28952:             if (fp) {
50500:                 JSObject *wrapper = WrapEscapingClosure(cx, fp, fun);
28952:                 if (!wrapper)
28952:                     return false;
48470:                 vp->setObject(*wrapper);
28952:                 return true;
28952:             }
28952: 
28952:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28952:                                  JSMSG_OPTIMIZED_CLOSURE_LEAK);
28952:             return false;
28952:         }
28952:     }
28952:     return true;
28952: }
28952: 
29888: static JSBool
48470: CalleeGetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
28952: {
28952:     return CheckForEscapingClosure(cx, obj, vp);
28952: }
28952: 
37694: static JSObject *
37694: NewCallObject(JSContext *cx, JSFunction *fun, JSObject *scopeChain)
37694: {
43221:     JSObject *callobj = js_NewGCObject(cx);
43221:     if (!callobj)
37694:         return NULL;
43221: 
43221:     /* Init immediately to avoid GC seeing a half-init'ed object. */
48470:     callobj->init(&js_CallClass, NULL, scopeChain, PrivateValue(NULL));
43221:     callobj->map = cx->runtime->emptyCallScope->hold();
43221: 
43221:     /* This must come after callobj->map has been set. */
43221:     if (!js_EnsureReservedSlots(cx, callobj, fun->countArgsAndVars()))
43221:         return NULL;
37694:     return callobj;
37694: }
37694: 
47497: static inline JSObject *
47497: NewDeclEnvObject(JSContext *cx, JSStackFrame *fp)
47497: {
47497:     JSObject *envobj = js_NewGCObject(cx);
47497:     if (!envobj)
47497:         return NULL;
47497: 
47497:     /* Init immediately to avoid GC seeing a half-init'ed object. */
51052:     envobj->init(&js_DeclEnvClass, NULL, fp->maybeScopeChain(), PrivateValue(fp));
47497:     envobj->map = cx->runtime->emptyDeclEnvScope->hold();
47497:     return envobj;
47497: }
47497: 
    1: JSObject *
25217: js_GetCallObject(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     /* Create a call object for fp only if it lacks one. */
51056:     JS_ASSERT(fp->hasFunction());
50510:     if (fp->hasCallObj())
50510:         return fp->getCallObj();
    1: 
25217: #ifdef DEBUG
25217:     /* A call object should be a frame's outermost scope chain element.  */
51052:     Class *classp = fp->getScopeChain()->getClass();
42714:     if (classp == &js_WithClass || classp == &js_BlockClass)
51052:         JS_ASSERT(fp->getScopeChain()->getPrivate() != js_FloatingFrameIfGenerator(cx, fp));
42714:     else if (classp == &js_CallClass)
51052:         JS_ASSERT(fp->getScopeChain()->getPrivate() != fp);
25217: #endif
    1: 
25217:     /*
27319:      * Create the call object, using the frame's enclosing scope as its
27319:      * parent, and link the call to its stack frame. For a named function
27319:      * expression Call's parent points to an environment object holding
27319:      * function's name.
25217:      */
51056:     JSAtom *lambdaName =
51056:         (fp->getFunction()->flags & JSFUN_LAMBDA) ? fp->getFunction()->atom : NULL;
27319:     if (lambdaName) {
47497:         JSObject *envobj = NewDeclEnvObject(cx, fp);
47497:         if (!envobj)
27660:             return NULL;
47497: 
47497:         /* Root envobj before js_DefineNativeProperty (-> JSClass.addProperty). */
51052:         fp->setScopeChain(envobj);
31939:         JS_ASSERT(fp->argv);
51052:         if (!js_DefineNativeProperty(cx, fp->getScopeChain(), ATOM_TO_JSID(lambdaName),
34352:                                      fp->calleeValue(),
28952:                                      CalleeGetter, NULL,
28312:                                      JSPROP_PERMANENT | JSPROP_READONLY,
28312:                                      0, 0, NULL)) {
28312:             return NULL;
28312:         }
27319:     }
27539: 
51056:     JSObject *callobj = NewCallObject(cx, fp->getFunction(), fp->getScopeChain());
37694:     if (!callobj)
    1:         return NULL;
15588: 
31452:     callobj->setPrivate(fp);
31939:     JS_ASSERT(fp->argv);
51056:     JS_ASSERT(fp->getFunction() == GET_FUNCTION_PRIVATE(cx, fp->callee()));
40410:     callobj->setSlot(JSSLOT_CALLEE, fp->calleeValue());
50510:     fp->setCallObj(callobj);
    1: 
25217:     /*
25217:      * Push callobj on the top of the scope chain, and make it the
25217:      * variables object.
25217:      */
51052:     fp->setScopeChain(callobj);
    1:     return callobj;
    1: }
    1: 
37694: JSObject * JS_FASTCALL
37694: js_CreateCallObjectOnTrace(JSContext *cx, JSFunction *fun, JSObject *callee, JSObject *scopeChain)
37694: {
37694:     JS_ASSERT(!js_IsNamedLambda(fun));
37694:     JSObject *callobj = NewCallObject(cx, fun, scopeChain);
37694:     if (!callobj)
37694:         return NULL;
48470:     callobj->setSlot(JSSLOT_CALLEE, ObjectValue(*callee));
37694:     return callobj;
37694: }
37694: 
39910: JS_DEFINE_CALLINFO_4(extern, OBJECT, js_CreateCallObjectOnTrace, CONTEXT, FUNCTION, OBJECT, OBJECT,
48613:                      0, nanojit::ACCSET_STORE_ANY)
37694: 
32589: JSFunction *
32589: js_GetCallObjectFunction(JSObject *obj)
15588: {
40410:     JS_ASSERT(obj->getClass() == &js_CallClass);
48470:     const Value &v = obj->getSlot(JSSLOT_CALLEE);
48470:     if (v.isUndefined()) {
15588:         /* Newborn or prototype object. */
15588:         return NULL;
15588:     }
48470:     JS_ASSERT(v.isObject());
48470:     return GET_FUNCTION_PRIVATE(cx, &v.toObject());
15588: }
    1: 
37694: inline static void
48470: CopyValuesToCallObject(JSObject *callobj, int nargs, Value *argv, int nvars, Value *slots)
37694: {
48470:     memcpy(callobj->dslots, argv, nargs * sizeof(Value));
48470:     memcpy(callobj->dslots + nargs, slots, nvars * sizeof(Value));
37694: }
37694: 
31823: void
    1: js_PutCallObject(JSContext *cx, JSStackFrame *fp)
    1: {
50510:     JSObject *callobj = fp->getCallObj();
31447: 
31823:     /* Get the arguments object to snapshot fp's actual argument values. */
50510:     if (fp->hasArgsObj()) {
31823:         if (!(fp->flags & JSFRAME_OVERRIDE_ARGS))
50510:             callobj->setSlot(JSSLOT_CALL_ARGUMENTS, ObjectOrNullValue(fp->getArgsObj()));
31823:         js_PutArgsObject(cx, fp);
31447:     }
31447: 
51056:     JSFunction *fun = fp->getFunction();
32589:     JS_ASSERT(fun == js_GetCallObjectFunction(callobj));
31447:     uintN n = fun->countArgsAndVars();
    1: 
    1:     /*
15588:      * Since for a call object all fixed slots happen to be taken, we can copy
15588:      * arguments and variables straight into JSObject.dslots.
    1:      */
15588:     JS_STATIC_ASSERT(JS_INITIAL_NSLOTS - JSSLOT_PRIVATE ==
15588:                      1 + CALL_CLASS_FIXED_RESERVED_SLOTS);
15588:     if (n != 0) {
40410:         JS_ASSERT(callobj->numSlots() >= JS_INITIAL_NSLOTS + n);
30732:         n += JS_INITIAL_NSLOTS;
53520: 
53520:         JSScript *script = fun->u.i.script;
53520:         uint32 nargs = fun->nargs;
53520:         uint32 nvars = fun->u.i.nvars;
53520: 
53520: #ifdef JS_METHODJIT
53520:         memcpy(callobj->dslots, fp->argv, nargs * sizeof(Value));
53520:         if (!script->jit || script->usesEval) {
53520:             memcpy(callobj->dslots + nargs, fp->slots(), nvars * sizeof(Value));
53520:         } else if (script->jit) {
53520:             for (uint32 i = 0; i < script->jit->nescaping; i++) {
53520:                 uint32 e = script->jit->escaping[i];
53520:                 callobj->dslots[nargs + e] = fp->slots()[e];
53520:             }
53520:         }
53520: #else
53520:         CopyValuesToCallObject(callobj, nargs, fp->argv, nvars, fp->slots());
53520: #endif
15588:     }
30732: 
30732:     /* Clear private pointers to fp, which is about to go away (js_Invoke). */
37694:     if (js_IsNamedLambda(fun)) {
39930:         JSObject *env = callobj->getParent();
28952: 
40410:         JS_ASSERT(env->getClass() == &js_DeclEnvClass);
32684:         JS_ASSERT(env->getPrivate() == fp);
31452:         env->setPrivate(NULL);
28952:     }
28952: 
31452:     callobj->setPrivate(NULL);
50510:     fp->setCallObj(NULL);
    1: }
    1: 
37694: JSBool JS_FASTCALL
48470: js_PutCallObjectOnTrace(JSContext *cx, JSObject *scopeChain, uint32 nargs, Value *argv,
48470:                         uint32 nvars, Value *slots)
37694: {
37694:     JS_ASSERT(scopeChain->hasClass(&js_CallClass));
37694:     JS_ASSERT(!scopeChain->getPrivate());
37694: 
37694:     uintN n = nargs + nvars;
37694:     if (n != 0)
37694:         CopyValuesToCallObject(scopeChain, nargs, argv, nvars, slots);
37694: 
37694:     return true;
37694: }
37694: 
48470: JS_DEFINE_CALLINFO_6(extern, BOOL, js_PutCallObjectOnTrace, CONTEXT, OBJECT, UINT32, VALUEPTR,
48613:                      UINT32, VALUEPTR, 0, nanojit::ACCSET_STORE_ANY)
37694: 
    1: static JSBool
    1: call_enumerate(JSContext *cx, JSObject *obj)
    1: {
13702:     JSFunction *fun;
15588:     uintN n, i;
 8367:     void *mark;
11435:     jsuword *names;
11435:     JSBool ok;
11435:     JSAtom *name;
 8367:     JSObject *pobj;
    1:     JSProperty *prop;
    1: 
32589:     fun = js_GetCallObjectFunction(obj);
28832:     n = fun ? fun->countArgsAndVars() : 0;
 8367:     if (n == 0)
 8367:         return JS_TRUE;
 8367: 
47609:     mark = JS_ARENA_MARK(&cx->tempPool);
11435: 
18989:     MUST_FLOW_THROUGH("out");
11435:     names = js_GetLocalNameArray(cx, fun, &cx->tempPool);
11435:     if (!names) {
11435:         ok = JS_FALSE;
 8367:         goto out;
11435:     }
 8367: 
 8367:     for (i = 0; i != n; ++i) {
11435:         name = JS_LOCAL_NAME_TO_ATOM(names[i]);
 8367:         if (!name)
    1:             continue;
    1: 
 3624:         /*
 8367:          * Trigger reflection by looking up the name of the argument or
 8367:          * variable.
 3624:          */
11435:         ok = js_LookupProperty(cx, obj, ATOM_TO_JSID(name), &pobj, &prop);
11435:         if (!ok)
 8367:             goto out;
    1: 
    1:         /*
28832:          * The call object will always have a property corresponding to the
28832:          * argument or variable name because call_resolve creates the property
28832:          * using JSPROP_PERMANENT.
    1:          */
28832:         JS_ASSERT(prop);
27341:         JS_ASSERT(pobj == obj);
31501:         pobj->dropProperty(cx, prop);
    1:     }
11435:     ok = JS_TRUE;
 8367: 
 8367:   out:
47609:     JS_ARENA_RELEASE(&cx->tempPool, mark);
11435:     return ok;
    1: }
    1: 
39916: enum JSCallPropertyKind {
13706:     JSCPK_ARGUMENTS,
13706:     JSCPK_ARG,
39916:     JSCPK_VAR,
39916:     JSCPK_UPVAR
39916: };
13706: 
13706: static JSBool
48470: CallPropertyOp(JSContext *cx, JSObject *obj, jsid id, Value *vp,
39916:                JSCallPropertyKind kind, JSBool setter = false)
13706: {
39916:     JS_ASSERT(obj->getClass() == &js_CallClass);
39919: 
39919:     uintN i = 0;
39919:     if (kind != JSCPK_ARGUMENTS) {
48470:         JS_ASSERT((int16) JSID_TO_INT(id) == JSID_TO_INT(id));
48470:         i = (uint16) JSID_TO_INT(id);
39919:     }
39916: 
48470:     Value *array;
39916:     if (kind == JSCPK_UPVAR) {
48470:         JSObject *callee = &obj->getSlot(JSSLOT_CALLEE).toObject();
39916: 
39916: #ifdef DEBUG
39916:         JSFunction *callee_fun = (JSFunction *) callee->getPrivate();
39916:         JS_ASSERT(FUN_FLAT_CLOSURE(callee_fun));
39916:         JS_ASSERT(i < callee_fun->u.i.nupvars);
39916: #endif
39916: 
39916:         array = callee->dslots;
39916:     } else {
39916:         JSFunction *fun = js_GetCallObjectFunction(obj);
39916:         JS_ASSERT_IF(kind == JSCPK_ARG, i < fun->nargs);
39916:         JS_ASSERT_IF(kind == JSCPK_VAR, i < fun->u.i.nvars);
39916: 
39916:         JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
13706: 
13706:         if (kind == JSCPK_ARGUMENTS) {
13706:             if (setter) {
15588:                 if (fp)
31823:                     fp->flags |= JSFRAME_OVERRIDE_ARGS;
40410:                 obj->setSlot(JSSLOT_CALL_ARGUMENTS, *vp);
15588:             } else {
31823:                 if (fp && !(fp->flags & JSFRAME_OVERRIDE_ARGS)) {
13706:                     JSObject *argsobj;
13706: 
13706:                     argsobj = js_GetArgsObject(cx, fp);
13706:                     if (!argsobj)
39916:                         return false;
48470:                     vp->setObject(*argsobj);
15588:                 } else {
40410:                     *vp = obj->getSlot(JSSLOT_CALL_ARGUMENTS);
15588:                 }
13706:             }
39916:             return true;
13706:         }
13706: 
15588:         if (!fp) {
15588:             i += CALL_CLASS_FIXED_RESERVED_SLOTS;
15588:             if (kind == JSCPK_VAR)
15588:                 i += fun->nargs;
15588:             else
15588:                 JS_ASSERT(kind == JSCPK_ARG);
15588:             return setter
48470:                    ? JS_SetReservedSlot(cx, obj, i, Jsvalify(*vp))
48470:                    : JS_GetReservedSlot(cx, obj, i, Jsvalify(vp));
15588:         }
15588: 
13706:         if (kind == JSCPK_ARG) {
13706:             array = fp->argv;
13706:         } else {
13706:             JS_ASSERT(kind == JSCPK_VAR);
42714:             array = fp->slots();
13706:         }
39916:     }
39916: 
25514:     if (setter) {
25514:         GC_POKE(cx, array[i]);
13706:         array[i] = *vp;
25514:     } else {
13706:         *vp = array[i];
25514:     }
39916:     return true;
    1: }
    1: 
    1: static JSBool
48470: GetCallArguments(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARGUMENTS);
13706: }
13706: 
13706: static JSBool
48470: SetCallArguments(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARGUMENTS, true);
13706: }
13706: 
13706: JSBool
48470: js_GetCallArg(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARG);
13706: }
13706: 
30848: JSBool
48470: SetCallArg(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARG, true);
39916: }
39916: 
39916: JSBool
48470: GetFlatUpvar(JSContext *cx, JSObject *obj, jsid id, Value *vp)
39916: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_UPVAR);
39916: }
39916: 
39916: JSBool
48470: SetFlatUpvar(JSContext *cx, JSObject *obj, jsid id, Value *vp)
39916: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_UPVAR, true);
13706: }
13706: 
13706: JSBool
48470: js_GetCallVar(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_VAR);
29009: }
29009: 
29009: JSBool
48470: js_GetCallVarChecked(JSContext *cx, JSObject *obj, jsid id, Value *vp)
29009: {
39916:     if (!CallPropertyOp(cx, obj, id, vp, JSCPK_VAR))
39916:         return false;
28952: 
28952:     return CheckForEscapingClosure(cx, obj, vp);
13706: }
13706: 
30848: JSBool
48470: SetCallVar(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_VAR, true);
13706: }
13706: 
48470: #if JS_TRACER
30848: JSBool JS_FASTCALL
48470: js_SetCallArg(JSContext *cx, JSObject *obj, jsid slotid, ValueArgType arg)
30848: {
48470:     Value argcopy = ValueArgToConstRef(arg);
48470:     return CallPropertyOp(cx, obj, slotid, &argcopy, JSCPK_ARG, true);
30848: }
48470: JS_DEFINE_CALLINFO_4(extern, BOOL, js_SetCallArg, CONTEXT, OBJECT, JSID, VALUE, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
30848: 
30848: JSBool JS_FASTCALL
48470: js_SetCallVar(JSContext *cx, JSObject *obj, jsid slotid, ValueArgType arg)
30848: {
48470:     Value argcopy = ValueArgToConstRef(arg);
48470:     return CallPropertyOp(cx, obj, slotid, &argcopy, JSCPK_VAR, true);
30848: }
48470: JS_DEFINE_CALLINFO_4(extern, BOOL, js_SetCallVar, CONTEXT, OBJECT, JSID, VALUE, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
48470: #endif
30848: 
 3624: static JSBool
48470: call_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:              JSObject **objp)
    1: {
13706:     JSFunction *fun;
 8179:     JSLocalKind localKind;
48470:     PropertyOp getter, setter;
 8179:     uintN slot, attrs;
    1: 
40410:     JS_ASSERT(obj->getClass() == &js_CallClass);
39928:     JS_ASSERT(!obj->getProto());
28397: 
48470:     if (!JSID_IS_ATOM(id))
    1:         return JS_TRUE;
    1: 
48470:     const Value &callee = obj->getSlot(JSSLOT_CALLEE);
48470:     if (callee.isUndefined())
15588:         return JS_TRUE;
48470:     fun = GET_FUNCTION_PRIVATE(cx, &callee.toObject());
15588: 
28397:     /*
28397:      * Check whether the id refers to a formal parameter, local variable or
28397:      * the arguments special name.
28397:      *
28397:      * We define all such names using JSDNP_DONT_PURGE to avoid an expensive
28397:      * shape invalidation in js_DefineNativeProperty. If such an id happens to
28397:      * shadow a global or upvar of the same name, any inner functions can
28397:      * never access the outer binding. Thus it cannot invalidate any property
28397:      * cache entries or derived trace guards for the outer binding. See also
28397:      * comments in js_PurgeScopeChainHelper from jsobj.cpp.
28397:      */
13427:     localKind = js_LookupLocal(cx, fun, JSID_TO_ATOM(id), &slot);
39916:     if (localKind != JSLOCAL_NONE) {
13706:         JS_ASSERT((uint16) slot == slot);
24849: 
24849:         /*
24849:          * We follow 10.2.3 of ECMA 262 v3 and make argument and variable
24849:          * properties of the Call objects enumerable.
24849:          */
24849:         attrs = JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_SHARED;
 8179:         if (localKind == JSLOCAL_ARG) {
13427:             JS_ASSERT(slot < fun->nargs);
13706:             getter = js_GetCallArg;
13706:             setter = SetCallArg;
 3624:         } else {
39916:             JSCallPropertyKind cpkind;
39916:             if (localKind == JSLOCAL_UPVAR) {
39916:                 if (!FUN_FLAT_CLOSURE(fun))
39916:                     return JS_TRUE;
39916:                 getter = GetFlatUpvar;
39916:                 setter = SetFlatUpvar;
39916:                 cpkind = JSCPK_UPVAR;
39916:             } else {
 8179:                 JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
13706:                 JS_ASSERT(slot < fun->u.i.nvars);
13706:                 getter = js_GetCallVar;
13706:                 setter = SetCallVar;
39916:                 cpkind = JSCPK_VAR;
15588:                 if (localKind == JSLOCAL_CONST)
15588:                     attrs |= JSPROP_READONLY;
39916:             }
29009: 
29009:             /*
29009:              * Use js_GetCallVarChecked if the local's value is a null closure.
29009:              * This way we penalize performance only slightly on first use of a
29009:              * null closure, not on every use.
29009:              */
48470:             Value v;
39916:             if (!CallPropertyOp(cx, obj, INT_TO_JSID((int16)slot), &v, cpkind))
29009:                 return JS_FALSE;
48470:             JSObject *funobj;
48470:             if (IsFunctionObject(v, &funobj) &&
48470:                 GET_FUNCTION_PRIVATE(cx, funobj)->needsWrapper()) {
29009:                 getter = js_GetCallVarChecked;
29009:             }
    1:         }
48470:         if (!js_DefineNativeProperty(cx, obj, id, UndefinedValue(), getter, setter,
38562:                                      attrs, JSScopeProperty::HAS_SHORTID, (int16) slot,
28397:                                      NULL, JSDNP_DONT_PURGE)) {
 2464:             return JS_FALSE;
 2464:         }
 2464:         *objp = obj;
 2464:         return JS_TRUE;
 2464:     }
 3624: 
 3624:     /*
 3624:      * Resolve arguments so that we never store a particular Call object's
 3624:      * arguments object reference in a Call prototype's |arguments| slot.
 3624:      */
48470:     if (JSID_IS_ATOM(id, cx->runtime->atomState.argumentsAtom)) {
48470:         if (!js_DefineNativeProperty(cx, obj, id, UndefinedValue(),
13706:                                      GetCallArguments, SetCallArguments,
15588:                                      JSPROP_PERMANENT | JSPROP_SHARED,
28397:                                      0, 0, NULL, JSDNP_DONT_PURGE)) {
 3624:             return JS_FALSE;
 3624:         }
 3624:         *objp = obj;
 3624:         return JS_TRUE;
 2464:     }
27012: 
27012:     /* Control flow reaches here only if id was not resolved. */
    1:     return JS_TRUE;
    1: }
    1: 
48470: JS_PUBLIC_DATA(Class) js_CallClass = {
27539:     "Call",
15588:     JSCLASS_HAS_PRIVATE |
15588:     JSCLASS_HAS_RESERVED_SLOTS(CALL_CLASS_FIXED_RESERVED_SLOTS) |
27539:     JSCLASS_NEW_RESOLVE | JSCLASS_IS_ANONYMOUS | JSCLASS_MARK_IS_TRACE,
48622:     PropertyStub,   /* addProperty */
48622:     PropertyStub,   /* delProperty */
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
48622:     call_enumerate,
48622:     (JSResolveOp)call_resolve,
48622:     NULL,           /* convert */
48622:     NULL,           /* finalize */
48622:     NULL,           /* reserved0   */
48622:     NULL,           /* checkAccess */
48622:     NULL,           /* call        */
48622:     NULL,           /* construct   */
48622:     NULL,           /* xdrObject   */
48622:     NULL,           /* hasInstance */
48622:     JS_CLASS_TRACE(args_or_call_trace)
    1: };
    1: 
48676: bool
48676: JSStackFrame::getValidCalleeObject(JSContext *cx, Value *vp)
48676: {
51056:     if (!hasFunction()) {
48676:         *vp = argv ? argv[-2] : UndefinedValue();
48676:         return true;
48676:     }
48676: 
51056:     JSFunction *fun = getFunction();
51056: 
48676:     /*
48676:      * See the equivalent condition in args_getProperty for ARGS_CALLEE, but
48676:      * note that here we do not want to throw, since this escape can happen via
48676:      * a foo.caller reference alone, without any debugger or indirect eval. And
48676:      * alas, it seems foo.caller is still used on the Web.
48676:      */
48676:     if (fun->needsWrapper()) {
50500:         JSObject *wrapper = WrapEscapingClosure(cx, this, fun);
48676:         if (!wrapper)
48676:             return false;
48676:         vp->setObject(*wrapper);
48676:         return true;
48676:     }
48676: 
48676:     JSObject *funobj = &calleeObject();
48676:     vp->setObject(*funobj);
48676: 
48676:     /*
48676:      * Check for an escape attempt by a joined function object, which must go
48676:      * through the frame's |this| object's method read barrier for the method
48676:      * atom by which it was uniquely associated with a property.
48676:      */
51056:     if (getThisValue().isObject()) {
48676:         JS_ASSERT(GET_FUNCTION_PRIVATE(cx, funobj) == fun);
48676: 
48676:         if (fun == funobj && fun->methodAtom()) {
51056:             JSObject *thisp = &getThisValue().toObject();
48676:             JS_ASSERT(thisp->canHaveMethodBarrier());
48676: 
48676:             JSScope *scope = thisp->scope();
48676:             if (scope->hasMethodBarrier()) {
48676:                 JSScopeProperty *sprop = scope->lookup(ATOM_TO_JSID(fun->methodAtom()));
48676: 
48676:                 /*
48676:                  * The method property might have been deleted while the method
48676:                  * barrier scope flag stuck, so we must lookup and test here.
48676:                  *
48676:                  * Two cases follow: the method barrier was not crossed yet, so
48676:                  * we cross it here; the method barrier *was* crossed, in which
48676:                  * case we must fetch and validate the cloned (unjoined) funobj
48676:                  * in the method property's slot.
48676:                  *
48676:                  * In either case we must allow for the method property to have
48676:                  * been replaced, or its value to have been overwritten.
48676:                  */
48676:                 if (sprop) {
48676:                     if (sprop->isMethod() && &sprop->methodObject() == funobj) {
48676:                         if (!scope->methodReadBarrier(cx, sprop, vp))
48676:                             return false;
48676:                         setCalleeObject(vp->toObject());
48676:                         return true;
48676:                     }
48676:                     if (sprop->hasSlot()) {
48676:                         Value v = thisp->getSlot(sprop->slot);
48676:                         JSObject *clone;
48676: 
48676:                         if (IsFunctionObject(v, &clone) &&
48676:                             GET_FUNCTION_PRIVATE(cx, clone) == fun &&
48676:                             clone->hasMethodObj(*thisp)) {
48676:                             JS_ASSERT(clone != funobj);
48676:                             *vp = v;
48676:                             setCalleeObject(*clone);
48676:                             return true;
48676:                         }
48676:                     }
48676:                 }
48676: 
48676:                 /*
48676:                  * If control flows here, we can't find an already-existing
48676:                  * clone (or force to exist a fresh clone) created via thisp's
48676:                  * method read barrier, so we must clone fun and store it in
48676:                  * fp's callee to avoid re-cloning upon repeated foo.caller
48676:                  * access. It seems that there are no longer any properties
48676:                  * referring to fun.
48676:                  */
48676:                 funobj = CloneFunctionObject(cx, fun, fun->getParent());
48676:                 if (!funobj)
48676:                     return false;
48676:                 funobj->setMethodObj(*thisp);
48676:                 setCalleeObject(*funobj);
48676:                 return true;
48676:             }
48676:         }
48676:     }
48676: 
48676:     return true;
48676: }
48676: 
31823: /* Generic function tinyids. */
31823: enum {
31823:     FUN_ARGUMENTS   = -1,       /* predefined arguments local variable */
31823:     FUN_LENGTH      = -2,       /* number of actual args, arity if inactive */
31823:     FUN_ARITY       = -3,       /* number of formal parameters; desired argc */
31823:     FUN_NAME        = -4,       /* function name, "" if anonymous */
31823:     FUN_CALLER      = -5        /* Function.prototype.caller, backward compat */
31823: };
31823: 
    1: static JSBool
48470: fun_getProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
48470:     if (!JSID_IS_INT(id))
48676:         return true;
43287: 
48470:     jsint slot = JSID_TO_INT(id);
    1: 
    1:     /*
    1:      * Loop because getter and setter can be delegated from another class,
31823:      * but loop only for FUN_LENGTH because we must pretend that f.length
    1:      * is in each function instance f, per ECMA-262, instead of only in the
    1:      * Function.prototype object (we use JSPROP_PERMANENT with JSPROP_SHARED
    1:      * to make it appear so).
    1:      *
51090:      * This code couples tightly to the attributes for lazyFunctionDataProps[]
51090:      * and poisonPillProps[] initializers below, and to js_SetProperty and
51090:      * js_HasOwnProperty.
    1:      *
    1:      * It's important to allow delegating objects, even though they inherit
    1:      * this getter (fun_getProperty), to override arguments, arity, caller,
31823:      * and name.  If we didn't return early for slot != FUN_LENGTH, we would
    1:      * clobber *vp with the native property value, instead of letting script
    1:      * override that value in delegating objects.
    1:      *
    1:      * Note how that clobbering is what simulates JSPROP_READONLY for all of
    1:      * the non-standard properties when the directly addressed object (obj)
    1:      * is a function object (i.e., when this loop does not iterate).
    1:      */
43287:     JSFunction *fun;
    1:     while (!(fun = (JSFunction *)
48470:                    GetInstancePrivate(cx, obj, &js_FunctionClass, NULL))) {
31823:         if (slot != FUN_LENGTH)
48676:             return true;
39928:         obj = obj->getProto();
    1:         if (!obj)
48676:             return true;
    1:     }
    1: 
    1:     /* Find fun's top-most activation record. */
43287:     JSStackFrame *fp;
22652:     for (fp = js_GetTopStackFrame(cx);
51056:          fp && (fp->maybeFunction() != fun || (fp->flags & JSFRAME_SPECIAL));
    1:          fp = fp->down) {
    1:         continue;
    1:     }
    1: 
    1:     switch (slot) {
31823:       case FUN_ARGUMENTS:
    1:         /* Warn if strict about f.arguments or equivalent unqualified uses. */
    1:         if (!JS_ReportErrorFlagsAndNumber(cx,
    1:                                           JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                           js_GetErrorMessage, NULL,
    1:                                           JSMSG_DEPRECATED_USAGE,
    1:                                           js_arguments_str)) {
48676:             return false;
    1:         }
    1:         if (fp) {
    1:             if (!js_GetArgsValue(cx, fp, vp))
48676:                 return false;
    1:         } else {
48470:             vp->setNull();
    1:         }
    1:         break;
    1: 
31823:       case FUN_LENGTH:
    1:       case FUN_ARITY:
48470:         vp->setInt32(fun->nargs);
    1:         break;
    1: 
    1:       case FUN_NAME:
48470:         vp->setString(fun->atom ? ATOM_TO_STRING(fun->atom)
48470:                                 : cx->runtime->emptyString);
    1:         break;
    1: 
    1:       case FUN_CALLER:
48470:         vp->setNull();
48676:         if (fp && fp->down && !fp->down->getValidCalleeObject(cx, vp))
48676:             return false;
48676: 
48676:         if (vp->isObject()) {
48656:             /* Censor the caller if it is from another compartment. */
48470:             if (vp->toObject().getCompartment(cx) != cx->compartment)
48470:                 vp->setNull();
18870:         }
    1:         break;
    1: 
    1:       default:
    1:         /* XXX fun[0] and fun.arguments[0] are equivalent. */
51056:         if (fp && fp->hasFunction() && (uintN)slot < fp->getFunction()->nargs)
    1:             *vp = fp->argv[slot];
    1:         break;
    1:     }
    1: 
48676:     return true;
    1: }
    1: 
51090: namespace {
51090: 
51090: struct LazyFunctionDataProp {
18830:     uint16      atomOffset;
18830:     int8        tinyid;
18830:     uint8       attrs;
43287: };
18830: 
51090: struct PoisonPillProp {
51090:     uint16       atomOffset;
51090:     int8         tinyid;
51090: };
51090: 
51090: /* NB: no sentinels at ends -- use JS_ARRAY_LENGTH to bound loops. */
51090: 
51090: const LazyFunctionDataProp lazyFunctionDataProps[] = {
18830:     {ATOM_OFFSET(arity),     FUN_ARITY,      JSPROP_PERMANENT},
18830:     {ATOM_OFFSET(name),      FUN_NAME,       JSPROP_PERMANENT},
18830: };
18830: 
51090: /* Properties censored into [[ThrowTypeError]] in strict mode. */
51090: const PoisonPillProp poisonPillProps[] = {
51090:     {ATOM_OFFSET(arguments), FUN_ARGUMENTS },
51090:     {ATOM_OFFSET(caller),    FUN_CALLER    },
51090: };
51090: 
51090: }
51090: 
    1: static JSBool
47569: fun_enumerate(JSContext *cx, JSObject *obj)
47569: {
47569:     JS_ASSERT(obj->isFunction());
47569: 
47569:     jsval v;
51682:     jsid id;
51682: 
51682:     if (!obj->getFunctionPrivate()->isBound()) {
51682:         id = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
47569:         if (!JS_LookupPropertyById(cx, obj, id, &v))
47569:             return false;
51682:     }
51682: 
47569:     id = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
47569:     if (!JS_LookupPropertyById(cx, obj, id, &v))
47569:         return false;
47569: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(lazyFunctionDataProps); i++) {
51090:         const LazyFunctionDataProp &lfp = lazyFunctionDataProps[i];
47569:         id = ATOM_TO_JSID(OFFSET_TO_ATOM(cx->runtime, lfp.atomOffset));
47569:         if (!JS_LookupPropertyById(cx, obj, id, &v))
47569:             return false;
47569:     }
47569: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(poisonPillProps); i++) {
51090:         const PoisonPillProp &p = poisonPillProps[i];
51090:         id = ATOM_TO_JSID(OFFSET_TO_ATOM(cx->runtime, p.atomOffset));
51090:         if (!JS_LookupPropertyById(cx, obj, id, &v))
51090:             return false;
51090:     }
51090: 
47569:     return true;
47569: }
47569: 
47569: static JSBool
48470: fun_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:             JSObject **objp)
    1: {
48470:     if (!JSID_IS_ATOM(id))
    1:         return JS_TRUE;
    1: 
51682:     JSFunction *fun = obj->getFunctionPrivate();
 2803: 
 2803:     /*
33604:      * No need to reflect fun.prototype in 'fun.prototype = ... '. Assert that
33604:      * fun is not a compiler-created function object, which must never leak to
33604:      * script or embedding code and then be mutated.
 2803:      */
48470:     if ((flags & JSRESOLVE_ASSIGNING) && !JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
40405:         JS_ASSERT(!IsInternalFunctionObject(obj));
    1:         return JS_TRUE;
33604:     }
    1: 
    1:     /*
    1:      * Ok, check whether id is 'prototype' and bootstrap the function object's
    1:      * prototype property.
    1:      */
43287:     JSAtom *atom = cx->runtime->atomState.classPrototypeAtom;
43287:     if (id == ATOM_TO_JSID(atom)) {
40405:         JS_ASSERT(!IsInternalFunctionObject(obj));
    1: 
    1:         /*
    1:          * Beware of the wacky case of a user function named Object -- trying
    1:          * to find a prototype for that will recur back here _ad perniciem_.
    1:          */
13702:         if (fun->atom == CLASS_ATOM(cx, Object))
    1:             return JS_TRUE;
    1: 
51682:         /* ES5 15.3.4.5: bound functions don't have a prototype property. */
51682:         if (fun->isBound())
51682:             return JS_TRUE;
51682: 
    1:         /*
47497:          * Make the prototype object an instance of Object with the same parent
47497:          * as the function object itself.
    1:          */
47497:         JSObject *parent = obj->getParent();
47497:         JSObject *proto;
47497:         if (!js_GetClassPrototype(cx, parent, JSProto_Object, &proto))
47497:             return JS_FALSE;
47497:         proto = NewNativeClassInstance(cx, &js_ObjectClass, proto, parent);
    1:         if (!proto)
    1:             return JS_FALSE;
    1: 
    1:         /*
    1:          * ECMA (15.3.5.2) says that constructor.prototype is DontDelete for
    1:          * user-defined functions, but DontEnum | ReadOnly | DontDelete for
    1:          * native "system" constructors such as Object or Function.  So lazily
    1:          * set the former here in fun_resolve, but eagerly define the latter
    1:          * in JS_InitClass, with the right attributes.
    1:          */
32671:         if (!js_SetClassPrototype(cx, obj, proto, JSPROP_PERMANENT))
    1:             return JS_FALSE;
32671: 
    1:         *objp = obj;
 2803:         return JS_TRUE;
 2803:     }
 2803: 
43287:     atom = cx->runtime->atomState.lengthAtom;
43287:     if (id == ATOM_TO_JSID(atom)) {
43287:         JS_ASSERT(!IsInternalFunctionObject(obj));
48470:         if (!js_DefineNativeProperty(cx, obj, ATOM_TO_JSID(atom), Int32Value(fun->nargs),
48470:                                      PropertyStub, PropertyStub,
43287:                                      JSPROP_PERMANENT | JSPROP_READONLY, 0, 0, NULL)) {
43287:             return JS_FALSE;
43287:         }
43287:         *objp = obj;
43287:         return JS_TRUE;
43287:     }
43287: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(lazyFunctionDataProps); i++) {
51090:         const LazyFunctionDataProp *lfp = &lazyFunctionDataProps[i];
 2803: 
 2803:         atom = OFFSET_TO_ATOM(cx->runtime, lfp->atomOffset);
48470:         if (id == ATOM_TO_JSID(atom)) {
40405:             JS_ASSERT(!IsInternalFunctionObject(obj));
33604: 
 2803:             if (!js_DefineNativeProperty(cx, obj,
48470:                                          ATOM_TO_JSID(atom), UndefinedValue(),
48470:                                          fun_getProperty, PropertyStub,
38562:                                          lfp->attrs, JSScopeProperty::HAS_SHORTID,
18830:                                          lfp->tinyid, NULL)) {
 2803:                 return JS_FALSE;
 2803:             }
 2803:             *objp = obj;
 2803:             return JS_TRUE;
 2803:         }
    1:     }
    1: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(poisonPillProps); i++) {
51090:         const PoisonPillProp &p = poisonPillProps[i];
51090: 
51090:         atom = OFFSET_TO_ATOM(cx->runtime, p.atomOffset);
51090:         if (id == ATOM_TO_JSID(atom)) {
51090:             JS_ASSERT(!IsInternalFunctionObject(obj));
51090: 
51090:             PropertyOp getter, setter;
51090:             uintN attrs = JSPROP_PERMANENT;
51682:             if (fun->inStrictMode() || fun->isBound()) {
51090:                 JSObject *throwTypeError = obj->getThrowTypeError();
51090: 
51090:                 getter = CastAsPropertyOp(throwTypeError);
51090:                 setter = CastAsPropertyOp(throwTypeError);
51090:                 attrs |= JSPROP_GETTER | JSPROP_SETTER;
51090:             } else {
51090:                 getter = fun_getProperty;
51090:                 setter = PropertyStub;
51090:             }
51090: 
51090:             if (!js_DefineNativeProperty(cx, obj, ATOM_TO_JSID(atom), UndefinedValue(),
51090:                                          getter, setter,
51090:                                          attrs, JSScopeProperty::HAS_SHORTID,
51090:                                          p.tinyid, NULL)) {
51090:                 return JS_FALSE;
51090:             }
51090:             *objp = obj;
51090:             return JS_TRUE;
51090:         }
51090:     }
51090: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: /* XXX store parent and proto, if defined */
28093: JSBool
28093: js_XDRFunctionObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
    1:     JSFunction *fun;
28952:     uint32 firstword;           /* flag telling whether fun->atom is non-null,
28952:                                    plus for fun->u.i.skipmin, fun->u.i.wrapper,
28952:                                    and 14 bits reserved for future use */
27012:     uintN nargs, nvars, nupvars, n;
28952:     uint32 localsword;          /* word for argument and variable counts */
28952:     uint32 flagsword;           /* word for fun->u.i.nupvars and fun->flags */
    1: 
    1:     cx = xdr->cx;
    1:     if (xdr->mode == JSXDR_ENCODE) {
13702:         fun = GET_FUNCTION_PRIVATE(cx, *objp);
    1:         if (!FUN_INTERPRETED(fun)) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_NOT_SCRIPTED_FUNCTION,
    1:                                  JS_GetFunctionName(fun));
40389:             return false;
    1:         }
28952:         if (fun->u.i.wrapper) {
28952:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28952:                                  JSMSG_XDR_CLOSURE_WRAPPER,
28952:                                  JS_GetFunctionName(fun));
40389:             return false;
28952:         }
28952:         JS_ASSERT((fun->u.i.wrapper & ~1U) == 0);
28952:         firstword = (fun->u.i.skipmin << 2) | (fun->u.i.wrapper << 1) | !!fun->atom;
13691:         nargs = fun->nargs;
13702:         nvars = fun->u.i.nvars;
27012:         nupvars = fun->u.i.nupvars;
 8179:         localsword = (nargs << 16) | nvars;
27012:         flagsword = (nupvars << 16) | fun->flags;
    1:     } else {
13702:         fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED, NULL, NULL);
    1:         if (!fun)
40389:             return false;
39930:         FUN_OBJECT(fun)->clearParent();
39928:         FUN_OBJECT(fun)->clearProto();
 8179: #ifdef __GNUC__
27012:         nvars = nargs = nupvars = 0;    /* quell GCC uninitialized warning */
 8179: #endif
    1:     }
    1: 
48470:     AutoObjectRooter tvr(cx, FUN_OBJECT(fun));
    1: 
28952:     if (!JS_XDRUint32(xdr, &firstword))
40389:         return false;
48480:     if ((firstword & 1U) && !js_XDRAtom(xdr, &fun->atom))
40389:         return false;
 8179:     if (!JS_XDRUint32(xdr, &localsword) ||
    1:         !JS_XDRUint32(xdr, &flagsword)) {
40389:         return false;
    1:     }
    1: 
 8179:     if (xdr->mode == JSXDR_DECODE) {
 8179:         nargs = localsword >> 16;
27012:         nvars = uint16(localsword);
27012:         JS_ASSERT((flagsword & JSFUN_KINDMASK) >= JSFUN_INTERPRETED);
27012:         nupvars = flagsword >> 16;
27012:         fun->flags = uint16(flagsword);
28952:         fun->u.i.skipmin = uint16(firstword >> 2);
33166:         fun->u.i.wrapper = JSPackedBool((firstword >> 1) & 1);
 8179:     }
    1: 
    1:     /* do arguments and local vars */
27012:     n = nargs + nvars + nupvars;
13824:     if (n != 0) {
47609:         void *mark;
 8179:         uintN i;
47609:         uintN bitmapLength;
47609:         uint32 *bitmap;
11435:         jsuword *names;
11435:         JSAtom *name;
 8337:         JSLocalKind localKind;
47609: 
40389:         bool ok = true;
47609:         mark = JS_ARENA_MARK(&xdr->cx->tempPool);
 8179: 
11435:         /*
11435:          * From this point the control must flow via the label release_mark.
11435:          *
11435:          * To xdr the names we prefix the names with a bitmap descriptor and
11435:          * then xdr the names as strings. For argument names (indexes below
11435:          * nargs) the corresponding bit in the bitmap is unset when the name
11435:          * is null. Such null names are not encoded or decoded. For variable
11435:          * names (indexes starting from nargs) bitmap's bit is set when the
11435:          * name is declared as const, not as ordinary var.
11435:          * */
27012:         MUST_FLOW_THROUGH("release_mark");
47609:         bitmapLength = JS_HOWMANY(n, JS_BITS_PER_UINT32);
47609:         JS_ARENA_ALLOCATE_CAST(bitmap, uint32 *, &xdr->cx->tempPool,
47609:                                bitmapLength * sizeof *bitmap);
 8179:         if (!bitmap) {
 8296:             js_ReportOutOfScriptQuota(xdr->cx);
40389:             ok = false;
 8179:             goto release_mark;
 8179:         }
    1:         if (xdr->mode == JSXDR_ENCODE) {
47609:             names = js_GetLocalNameArray(xdr->cx, fun, &xdr->cx->tempPool);
11435:             if (!names) {
40389:                 ok = false;
11435:                 goto release_mark;
 8179:             }
40229:             PodZero(bitmap, bitmapLength);
11435:             for (i = 0; i != n; ++i) {
13691:                 if (i < fun->nargs
11435:                     ? JS_LOCAL_NAME_TO_ATOM(names[i]) != NULL
11435:                     : JS_LOCAL_NAME_IS_CONST(names[i])) {
11435:                     bitmap[i >> JS_BITS_PER_UINT32_LOG2] |=
11435:                         JS_BIT(i & (JS_BITS_PER_UINT32 - 1));
11435:                 }
11435:             }
11435:         }
11435: #ifdef __GNUC__
11435:         else {
11435:             names = NULL;   /* quell GCC uninitialized warning */
11435:         }
11435: #endif
 8179:         for (i = 0; i != bitmapLength; ++i) {
40439:             ok = !!JS_XDRUint32(xdr, &bitmap[i]);
 8179:             if (!ok)
 8179:                 goto release_mark;
 8179:         }
 8179:         for (i = 0; i != n; ++i) {
 8179:             if (i < nargs &&
11435:                 !(bitmap[i >> JS_BITS_PER_UINT32_LOG2] &
 8179:                   JS_BIT(i & (JS_BITS_PER_UINT32 - 1)))) {
 8179:                 if (xdr->mode == JSXDR_DECODE) {
40439:                     ok = !!js_AddLocal(xdr->cx, fun, NULL, JSLOCAL_ARG);
 8179:                     if (!ok)
 8179:                         goto release_mark;
 8179:                 } else {
11435:                     JS_ASSERT(!JS_LOCAL_NAME_TO_ATOM(names[i]));
 8179:                 }
 8179:                 continue;
 8179:             }
 8179:             if (xdr->mode == JSXDR_ENCODE)
11435:                 name = JS_LOCAL_NAME_TO_ATOM(names[i]);
48480:             ok = !!js_XDRAtom(xdr, &name);
 8179:             if (!ok)
 8179:                 goto release_mark;
 8179:             if (xdr->mode == JSXDR_DECODE) {
 8179:                 localKind = (i < nargs)
 8179:                             ? JSLOCAL_ARG
27012:                             : (i < nargs + nvars)
27012:                             ? (bitmap[i >> JS_BITS_PER_UINT32_LOG2] &
 8179:                                JS_BIT(i & (JS_BITS_PER_UINT32 - 1))
 8179:                                ? JSLOCAL_CONST
27012:                                : JSLOCAL_VAR)
27012:                             : JSLOCAL_UPVAR;
40439:                 ok = !!js_AddLocal(xdr->cx, fun, name, localKind);
 8179:                 if (!ok)
 8179:                     goto release_mark;
 8179:             }
 8179:         }
    1: 
 8179:       release_mark:
47609:         JS_ARENA_RELEASE(&xdr->cx->tempPool, mark);
 8179:         if (!ok)
40389:             return false;
    1: 
 8367:         if (xdr->mode == JSXDR_DECODE)
13691:             js_FreezeLocalNames(cx, fun);
    1:     }
    1: 
34290:     if (!js_XDRScript(xdr, &fun->u.i.script, false, NULL))
40389:         return false;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
13824:         *objp = FUN_OBJECT(fun);
34290:         if (fun->u.i.script != JSScript::emptyScript()) {
11377: #ifdef CHECK_SCRIPT_OWNER
13702:             fun->u.i.script->owner = NULL;
11377: #endif
    1:             js_CallNewScriptHook(cx, fun->u.i.script, fun);
    1:         }
34290:     }
    1: 
40389:     return true;
    1: }
    1: 
    1: #else  /* !JS_HAS_XDR */
    1: 
28093: #define js_XDRFunctionObject NULL
    1: 
    1: #endif /* !JS_HAS_XDR */
    1: 
    1: /*
    1:  * [[HasInstance]] internal method for Function objects: fetch the .prototype
    1:  * property of its 'this' parameter, and walks the prototype chain of v (only
    1:  * if v is an object) returning true if .prototype is found.
    1:  */
    1: static JSBool
48470: fun_hasInstance(JSContext *cx, JSObject *obj, const Value *v, JSBool *bp)
    1: {
51682:     while (obj->isFunction()) {
51682:         if (!obj->getFunctionPrivate()->isBound())
51682:             break;
51682:         obj = obj->getBoundFunctionTarget();
51682:     }
51682: 
31823:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
48470:     Value pval;
31823:     if (!obj->getProperty(cx, id, &pval))
    1:         return JS_FALSE;
    1: 
48470:     if (pval.isPrimitive()) {
    1:         /*
    1:          * Throw a runtime error if instanceof is called on a function that
    1:          * has a non-object as its .prototype value.
    1:          */
48470:         js_ReportValueError(cx, JSMSG_BAD_PROTOTYPE, -1, ObjectValue(*obj), NULL);
    1:         return JS_FALSE;
    1:     }
    1: 
48470:     *bp = js_IsDelegate(cx, &pval.toObject(), *v);
48470:     return JS_TRUE;
    1: }
    1: 
  583: static void
13824: TraceLocalNames(JSTracer *trc, JSFunction *fun);
13824: 
13824: static void
13824: DestroyLocalNames(JSContext *cx, JSFunction *fun);
13824: 
13824: static void
  583: fun_trace(JSTracer *trc, JSObject *obj)
    1: {
13691:     /* A newborn function object may have a not yet initialized private slot. */
31452:     JSFunction *fun = (JSFunction *) obj->getPrivate();
13824:     if (!fun)
13824:         return;
13824: 
13824:     if (FUN_OBJECT(fun) != obj) {
13824:         /* obj is cloned function object, trace the original. */
13824:         JS_CALL_TRACER(trc, FUN_OBJECT(fun), JSTRACE_OBJECT, "private");
13824:         return;
13824:     }
  254:     if (fun->atom)
13824:         JS_CALL_STRING_TRACER(trc, ATOM_TO_STRING(fun->atom), "atom");
13824:     if (FUN_INTERPRETED(fun)) {
13824:         if (fun->u.i.script)
  583:             js_TraceScript(trc, fun->u.i.script);
13824:         TraceLocalNames(trc, fun);
13824:     }
13824: }
13824: 
13824: static void
13824: fun_finalize(JSContext *cx, JSObject *obj)
13824: {
13824:     /* Ignore newborn and cloned function objects. */
31823:     JSFunction *fun = (JSFunction *) obj->getPrivate();
13824:     if (!fun || FUN_OBJECT(fun) != obj)
13824:         return;
13824: 
13824:     /*
13824:      * Null-check of u.i.script is required since the parser sets interpreted
13824:      * very early.
13824:      */
13824:     if (FUN_INTERPRETED(fun)) {
13824:         if (fun->u.i.script)
13824:             js_DestroyScript(cx, fun->u.i.script);
13824:         DestroyLocalNames(cx, fun);
  254:     }
    1: }
    1: 
32729: int
32729: JSFunction::sharpSlotBase(JSContext *cx)
32729: {
32729: #if JS_HAS_SHARP_VARS
32729:     JSAtom *name = js_Atomize(cx, "#array", 6, 0);
32729:     if (name) {
32771:         uintN index = uintN(-1);
32757: #ifdef DEBUG
32757:         JSLocalKind kind =
32757: #endif
32757:             js_LookupLocal(cx, this, name, &index);
32757:         JS_ASSERT(kind == JSLOCAL_VAR);
32729:         return int(index);
32729:     }
32729: #endif
32729:     return -1;
32729: }
32729: 
30732: uint32
30737: JSFunction::countInterpretedReservedSlots() const
30732: {
30732:     JS_ASSERT(FUN_INTERPRETED(this));
30732: 
37029:     return (u.i.nupvars == 0) ? 0 : u.i.script->upvars()->length;
30732: }
30732: 
    1: /*
    1:  * Reserve two slots in all function objects for XPConnect.  Note that this
    1:  * does not bloat every instance, only those on which reserved slots are set,
    1:  * and those on which ad-hoc properties are defined.
    1:  */
48470: JS_PUBLIC_DATA(Class) js_FunctionClass = {
    1:     js_Function_str,
48676:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE |
48676:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::FUN_FIXED_RESERVED_SLOTS) |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Function),
48622:     PropertyStub,   /* addProperty */
48622:     PropertyStub,   /* delProperty */
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
48622:     fun_enumerate,
48622:     (JSResolveOp)fun_resolve,
48622:     ConvertStub,
48622:     fun_finalize,
48622:     NULL,           /* reserved0   */
48622:     NULL,           /* checkAccess */
48622:     NULL,           /* call        */
48622:     NULL,           /* construct   */
48622:     js_XDRFunctionObject,
48622:     fun_hasInstance,
48622:     JS_CLASS_TRACE(fun_trace)
    1: };
    1: 
47498: namespace js {
47498: 
47498: JSString *
47498: fun_toStringHelper(JSContext *cx, JSObject *obj, uintN indent)
    1: {
47498:     if (!obj->isFunction()) {
47514:         if (obj->isFunctionProxy())
47498:             return JSProxy::fun_toString(cx, obj, indent);
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_INCOMPATIBLE_PROTO,
    1:                              js_Function_str, js_toString_str,
47498:                              "object");
47498:         return NULL;
    1:     }
    1: 
47498:     JSFunction *fun = GET_FUNCTION_PRIVATE(cx, obj);
47498:     if (!fun)
47498:         return NULL;
47498:     return JS_DecompileFunction(cx, fun, indent);
    1: }
    1: 
48470: }  /* namespace js */
    1: 
    1: static JSBool
48470: fun_toString(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     JS_ASSERT(IsFunctionObject(vp[0]));
47498:     uint32_t indent = 0;
47498: 
47498:     if (argc != 0 && !ValueToECMAUint32(cx, vp[2], &indent))
47498:         return false;
47498: 
48470:     JSObject *obj = ComputeThisFromVp(cx, vp);
47498:     if (!obj)
47498:         return false;
47498: 
47498:     JSString *str = fun_toStringHelper(cx, obj, indent);
47498:     if (!str)
47498:         return false;
47498: 
48470:     vp->setString(str);
47498:     return true;
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
    1: static JSBool
48470: fun_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     JS_ASSERT(IsFunctionObject(vp[0]));
48470: 
48470:     JSObject *obj = ComputeThisFromVp(cx, vp);
47498:     if (!obj)
47498:         return false;
47498: 
47498:     JSString *str = fun_toStringHelper(cx, obj, JS_DONT_PRETTY_PRINT);
47498:     if (!str)
47498:         return false;
47498: 
48470:     vp->setString(str);
47498:     return true;
    1: }
    1: #endif
    1: 
29887: JSBool
48470: js_fun_call(JSContext *cx, uintN argc, Value *vp)
    1: {
37741:     LeaveTrace(cx);
29887: 
48470:     JSObject *obj = ComputeThisFromVp(cx, vp);
40867:     if (!obj)
    1:         return JS_FALSE;
48470:     Value fval = vp[1];
    1: 
38638:     if (!js_IsCallable(fval)) {
48470:         JSString *str = js_ValueToString(cx, fval);
    1:         if (str) {
    1:             const char *bytes = js_GetStringBytes(cx, str);
    1: 
    1:             if (bytes) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_INCOMPATIBLE_PROTO,
21473:                                      js_Function_str, js_call_str,
    1:                                      bytes);
    1:             }
    1:         }
    1:         return JS_FALSE;
    1:     }
    1: 
48470:     Value *argv = vp + 2;
    1:     if (argc == 0) {
    1:         /* Call fun with its global object as the 'this' param if no args. */
    1:         obj = NULL;
    1:     } else {
    1:         /* Otherwise convert the first arg to 'this' and skip over it. */
48470:         if (argv[0].isObject())
48470:             obj = &argv[0].toObject();
48470:         else if (!js_ValueToObjectOrNull(cx, argv[0], &obj))
    1:             return JS_FALSE;
    1:         argc--;
    1:         argv++;
    1:     }
    1: 
    1:     /* Allocate stack space for fval, obj, and the args. */
42714:     InvokeArgsGuard args;
42714:     if (!cx->stack().pushInvokeArgs(cx, argc, args))
    1:         return JS_FALSE;
    1: 
    1:     /* Push fval, obj, and the args. */
50468:     args.callee() = fval;
50468:     args.thisv().setObjectOrNull(obj);
50468:     memcpy(args.argv(), argv, argc * sizeof *argv);
42714: 
48470:     bool ok = Invoke(cx, args, 0);
50468:     *vp = args.rval();
    1:     return ok;
    1: }
    1: 
48590: /* ES5 15.3.4.3 */
29887: JSBool
48470: js_fun_apply(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     JSObject *obj = ComputeThisFromVp(cx, vp);
40867:     if (!obj)
48590:         return false;
48590: 
48590:     /* Step 1. */
48470:     Value fval = vp[1];
38638:     if (!js_IsCallable(fval)) {
48590:         if (JSString *str = js_ValueToString(cx, fval)) {
48590:             if (const char *bytes = js_GetStringBytes(cx, str)) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_INCOMPATIBLE_PROTO,
21473:                                      js_Function_str, js_apply_str,
    1:                                      bytes);
    1:             }
    1:         }
48590:         return false;
    1:     }
    1: 
48590:     /* Step 2. */
48590:     if (argc < 2 || vp[3].isNullOrUndefined())
48590:         return js_fun_call(cx, (argc > 0) ? 1 : 0, vp);
48590: 
48590:     /* Step 3. */
48590:     if (!vp[3].isObject()) {
48590:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_APPLY_ARGS, js_apply_str);
48590:         return false;
48590:     }
48590: 
48590:     /*
48590:      * Steps 4-5 (note erratum removing steps originally numbered 5 and 7 in
48590:      * original version of ES5).
48590:      */
48590:     JSObject *aobj = vp[3].toObject().wrappedObject(cx);
48590:     jsuint length;
48590:     if (aobj->isArray()) {
48590:         length = aobj->getArrayLength();
48590:     } else if (aobj->isArguments() && !aobj->isArgsLengthOverridden()) {
51091:         length = aobj->getArgsInitialLength();
    1:     } else {
48590:         Value &lenval = vp[0];
48590:         if (!aobj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom), &lenval))
48590:             return false;
48590: 
48590:         if (lenval.isInt32()) {
48590:             length = jsuint(lenval.toInt32()); /* jsuint cast does ToUint32 */
48590:         } else {
48590:             JS_STATIC_ASSERT(sizeof(jsuint) == sizeof(uint32_t));
48590:             if (!ValueToECMAUint32(cx, lenval, (uint32_t *)&length))
48590:                 return false;
    1:         }
    1:     }
    1: 
    1:     /* Convert the first arg to 'this' and skip over it. */
48470:     if (vp[2].isObject())
48470:         obj = &vp[2].toObject();
48470:     else if (!js_ValueToObjectOrNull(cx, vp[2], &obj))
    1:         return JS_FALSE;
    1: 
48590:     LeaveTrace(cx);
48590: 
48590:     /* Step 6. */
48590:     uintN n = uintN(JS_MIN(length, JS_ARGS_LENGTH_MAX));
42714: 
42714:     InvokeArgsGuard args;
48590:     if (!cx->stack().pushInvokeArgs(cx, n, args))
48590:         return false;
    1: 
    1:     /* Push fval, obj, and aobj's elements as args. */
50468:     args.callee() = fval;
50468:     args.thisv().setObjectOrNull(obj);
48590: 
48590:     /* Steps 7-8. */
40864:     if (aobj && aobj->isArguments() && !aobj->isArgsLengthOverridden()) {
40405:         /*
40405:          * Two cases, two loops: note how in the case of an active stack frame
40405:          * backing aobj, even though we copy from fp->argv, we still must check
41871:          * aobj->getArgsElement(i) for a hole, to handle a delete on the
41871:          * corresponding arguments element. See args_delProperty.
40405:          */
40405:         JSStackFrame *fp = (JSStackFrame *) aobj->getPrivate();
50468:         Value *argv = args.argv();
40405:         if (fp) {
50468:             memcpy(argv, fp->argv, n * sizeof(Value));
48590:             for (uintN i = 0; i < n; i++) {
48470:                 if (aobj->getArgsElement(i).isMagic(JS_ARGS_HOLE)) // suppress deleted element
50468:                     argv[i].setUndefined();
40405:             }
40405:         } else {
48590:             for (uintN i = 0; i < n; i++) {
50468:                 argv[i] = aobj->getArgsElement(i);
50468:                 if (argv[i].isMagic(JS_ARGS_HOLE))
50468:                     argv[i].setUndefined();
40405:             }
40405:         }
40405:     } else {
50468:         Value *argv = args.argv();
48590:         for (uintN i = 0; i < n; i++) {
50468:             if (!aobj->getProperty(cx, INT_TO_JSID(jsint(i)), &argv[i]))
42714:                 return JS_FALSE;
    1:         }
40405:     }
    1: 
48590:     /* Step 9. */
48590:     if (!Invoke(cx, args, 0))
48590:         return false;
50468:     *vp = args.rval();
48590:     return true;
    1: }
    1: 
51682: namespace {
51682: Native
51682: FastNativeToNative(FastNative fn)
51682: {
51682:     return reinterpret_cast<Native>(fn);
51682: }
51682: 
51682: JSBool
51682: CallOrConstructBoundFunction(JSContext *cx, uintN argc, Value *vp);
51682: }
51682: 
51682: inline bool
51682: JSFunction::isBound() const
51682: {
51682:     return isFastNative() && u.n.native == FastNativeToNative(CallOrConstructBoundFunction);
51682: }
51682: 
51682: inline bool
51682: JSObject::initBoundFunction(JSContext *cx, const Value &thisArg,
51682:                             const Value *args, uintN argslen)
51682: {
51682:     JS_ASSERT(isFunction());
51682:     JS_ASSERT(getFunctionPrivate()->isBound());
51682: 
51682:     fslots[JSSLOT_BOUND_FUNCTION_THIS] = thisArg;
51682:     fslots[JSSLOT_BOUND_FUNCTION_ARGS_COUNT].setPrivateUint32(argslen);
51682:     if (argslen != 0) {
51682:         if (!js_EnsureReservedSlots(cx, this, argslen))
51682:             return false;
51682: 
51682:         JS_ASSERT(dslots);
51682:         JS_ASSERT(dslots[-1].toPrivateUint32() >= argslen);
51682:         memcpy(&dslots[0], args, argslen * sizeof(Value));
51682:     }
51682:     return true;
51682: }
51682: 
51682: inline JSObject *
51682: JSObject::getBoundFunctionTarget() const
51682: {
51682:     JS_ASSERT(isFunction());
51682:     JS_ASSERT(getFunctionPrivate()->isBound());
51682: 
51682:     /* Bound functions abuse |parent| to store their target function. */
51682:     return getParent();
51682: }
51682: 
51682: inline const js::Value &
51682: JSObject::getBoundFunctionThis() const
51682: {
51682:     JS_ASSERT(isFunction());
51682:     JS_ASSERT(getFunctionPrivate()->isBound());
51682: 
51682:     return fslots[JSSLOT_BOUND_FUNCTION_THIS];
51682: }
51682: 
51682: inline const js::Value *
51682: JSObject::getBoundFunctionArguments(uintN &argslen) const
51682: {
51682:     JS_ASSERT(isFunction());
51682:     JS_ASSERT(getFunctionPrivate()->isBound());
51682: 
51682:     argslen = fslots[JSSLOT_BOUND_FUNCTION_ARGS_COUNT].toPrivateUint32();
51682:     JS_ASSERT_IF(argslen > 0, dslots);
51682:     JS_ASSERT_IF(argslen > 0, dslots[-1].toPrivateUint32() >= argslen);
51682:     return &dslots[0];
51682: }
51682: 
51682: namespace {
51682: 
51682: /* ES5 15.3.4.5.1 and 15.3.4.5.2. */
51682: JSBool
51682: CallOrConstructBoundFunction(JSContext *cx, uintN argc, Value *vp)
51682: {
51682:     JSObject *obj = &vp[0].toObject();
51682:     JS_ASSERT(obj->isFunction());
51682:     JS_ASSERT(obj->getFunctionPrivate()->isBound());
51682: 
51682:     LeaveTrace(cx);
51682: 
51682:     bool constructing = vp[1].isMagic(JS_FAST_CONSTRUCTOR);
51682: 
51682:     /* 15.3.4.5.1 step 1, 15.3.4.5.2 step 3. */
51682:     uintN argslen;
51682:     const Value *boundArgs = obj->getBoundFunctionArguments(argslen);
51682: 
51682:     if (argc + argslen > JS_ARGS_LENGTH_MAX) {
51682:         js_ReportAllocationOverflow(cx);
51682:         return false;
51682:     }
51682: 
51682:     /* 15.3.4.5.1 step 3, 15.3.4.5.2 step 1. */
51682:     JSObject *target = obj->getBoundFunctionTarget();
51682: 
51682:     /* 15.3.4.5.1 step 2. */
51682:     const Value &boundThis = obj->getBoundFunctionThis();
51682: 
51682:     InvokeArgsGuard args;
51682:     if (!cx->stack().pushInvokeArgs(cx, argc + argslen, args))
51682:         return false;
51682: 
51682:     /* 15.3.4.5.1, 15.3.4.5.2 step 4. */
51682:     memcpy(args.argv(), boundArgs, argslen * sizeof(Value));
51682:     memcpy(args.argv() + argslen, vp + 2, argc * sizeof(Value));
51682: 
51682:     /* 15.3.4.5.1, 15.3.4.5.2 step 5. */
51682:     args.callee().setObject(*target);
51682: 
51682:     if (!constructing) {
51682:         /*
51682:          * FIXME Pass boundThis directly without boxing!  This will go away
51682:          *       very shortly when this-boxing only occurs for non-strict
51682:          *       functions, callee-side, in bug 514570.
51682:          */
51682:         JSObject *boundThisObj;
51682:         if (boundThis.isObjectOrNull()) {
51682:             boundThisObj = boundThis.toObjectOrNull();
51682:         } else {
51682:             if (!js_ValueToObjectOrNull(cx, boundThis, &boundThisObj))
51682:                 return false;
51682:         }
51682: 
51682:         args.thisv() = ObjectOrNullValue(boundThisObj);
51682:     }
51682: 
51682:     if (constructing ? !InvokeConstructor(cx, args) : !Invoke(cx, args, 0))
51682:         return false;
51682: 
51682:     *vp = args.rval();
51682:     return true;
51682: }
51682: 
51682: /* ES5 15.3.4.5. */
51682: JSBool
51682: fun_bind(JSContext *cx, uintN argc, Value *vp)
51682: {
51682:     /* Step 1. */
51682:     JSObject *target = ComputeThisFromVp(cx, vp);
51682:     if (!target)
51682:         return false;
51682: 
51682:     /* Step 2. */
51684:     if (!target->wrappedObject(cx)->isCallable()) {
51682:         if (JSString *str = js_ValueToString(cx, vp[1])) {
51682:             if (const char *bytes = js_GetStringBytes(cx, str)) {
51682:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
51682:                                      JSMSG_INCOMPATIBLE_PROTO,
51682:                                      js_Function_str, "bind", bytes);
51682:             }
51682:         }
51682:         return false;
51682:     }
51682: 
51682:     /* Step 3. */
51682:     Value *args = NULL;
51682:     uintN argslen = 0;
51682:     if (argc > 1) {
51682:         args = vp + 3;
51682:         argslen = argc - 1;
51682:     }
51682: 
51682:     /* Steps 15-16. */
51682:     uintN length = 0;
51682:     if (target->isFunction()) {
51682:         uintN nargs = target->getFunctionPrivate()->nargs;
51682:         if (nargs > argslen)
51682:             length = nargs - argslen;
51682:     }
51682: 
51682:     /* Step 4-6, 10-11. */
51682:     JSAtom *name = target->isFunction() ? target->getFunctionPrivate()->atom : NULL;
51682: 
51682:     /* NB: Bound functions abuse |parent| to store their target. */
51682:     JSObject *funobj =
51682:         js_NewFunction(cx, NULL, FastNativeToNative(CallOrConstructBoundFunction), length,
51682:                        JSFUN_FAST_NATIVE | JSFUN_FAST_NATIVE_CTOR, target, name);
51682:     if (!funobj)
51682:         return false;
51682: 
51682:     /* Steps 7-9. */
51682:     Value thisArg = argc >= 1 ? vp[2] : UndefinedValue();
51682:     if (!funobj->initBoundFunction(cx, thisArg, args, argslen))
51682:         return false;
51682: 
51682:     /* Steps 17, 19-21 are handled by fun_resolve. */
51682:     /* Step 18 is the default for new functions. */
51682: 
51682:     /* Step 22. */
51682:     vp->setObject(*funobj);
51682:     return true;
51682: }
51682: 
51682: }
51682: 
    1: static JSFunctionSpec function_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,   fun_toSource,   0,0),
    1: #endif
16519:     JS_FN(js_toString_str,   fun_toString,   0,0),
21473:     JS_FN(js_apply_str,      js_fun_apply,   2,0),
21473:     JS_FN(js_call_str,       js_fun_call,    1,0),
51682:     JS_FN("bind",            fun_bind,       1,0),
 4127:     JS_FS_END
    1: };
    1: 
    1: static JSBool
48470: Function(JSContext *cx, JSObject *obj, uintN argc, Value *argv, Value *rval)
    1: {
    1:     JSFunction *fun;
    1:     JSObject *parent;
22652:     JSStackFrame *fp, *caller;
 8179:     uintN i, n, lineno;
    1:     JSAtom *atom;
    1:     const char *filename;
 8179:     JSBool ok;
    1:     JSString *str, *arg;
40320:     TokenStream ts(cx);
    1:     JSPrincipals *principals;
    1:     jschar *collected_args, *cp;
 6561:     void *mark;
    1:     size_t arg_length, args_length, old_args_length;
40320:     TokenKind tt;
    1: 
22652:     if (!JS_IsConstructing(cx)) {
50500:         obj = NewFunction(cx, NULL);
    1:         if (!obj)
    1:             return JS_FALSE;
48470:         rval->setObject(*obj);
13824:     } else {
13824:         /*
13824:          * The constructor is called before the private slot is initialized so
31452:          * we must use getPrivate, not GET_FUNCTION_PRIVATE here.
13824:          */
31452:         if (obj->getPrivate())
13482:             return JS_TRUE;
    1:     }
    1: 
    1:     /*
    1:      * NB: (new Function) is not lexically closed by its caller, it's just an
    1:      * anonymous function in the top-level scope that its constructor inhabits.
    1:      * Thus 'var x = 42; f = new Function("return x"); print(f())' prints 42,
    1:      * and so would a call to f from another top-level's script or function.
    1:      *
    1:      * In older versions, before call objects, a new Function was adopted by
    1:      * its running context's globalObject, which might be different from the
    1:      * top-level reachable from scopeChain (in HTML frames, e.g.).
    1:      */
48470:     parent = argv[-2].toObject().getParent();
    1: 
13702:     fun = js_NewFunction(cx, obj, NULL, 0, JSFUN_LAMBDA | JSFUN_INTERPRETED,
13702:                          parent, cx->runtime->atomState.anonymousAtom);
    1: 
    1:     if (!fun)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * Function is static and not called directly by other functions in this
    1:      * file, therefore it is callable only as a native function by js_Invoke.
    1:      * Find the scripted caller, possibly skipping other native frames such as
    1:      * are built for Function.prototype.call or .apply activations that invoke
    1:      * Function indirectly from a script.
    1:      */
22652:     fp = js_GetTopStackFrame(cx);
51056:     JS_ASSERT(!fp->hasScript() && fp->hasFunction() &&
51056:               fp->getFunction()->u.n.native == Function);
22652:     caller = js_GetScriptedCaller(cx, fp);
    1:     if (caller) {
    1:         principals = JS_EvalFramePrincipals(cx, fp, caller);
12690:         filename = js_ComputeFilename(cx, caller, principals, &lineno);
    1:     } else {
    1:         filename = NULL;
    1:         lineno = 0;
    1:         principals = NULL;
    1:     }
    1: 
    1:     /* Belt-and-braces: check that the caller has access to parent. */
    1:     if (!js_CheckPrincipalsAccess(cx, parent, principals,
    1:                                   CLASS_ATOM(cx, Function))) {
    1:         return JS_FALSE;
    1:     }
    1: 
39061:     /*
39061:      * CSP check: whether new Function() is allowed at all.
39061:      * Report errors via CSP is done in the script security manager.
39061:      * js_CheckContentSecurityPolicy is defined in jsobj.cpp
39061:      */
39061:     if (!js_CheckContentSecurityPolicy(cx)) {
48676:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CSP_BLOCKED_FUNCTION);
39061:         return JS_FALSE;
39061:     }
39061: 
    1:     n = argc ? argc - 1 : 0;
    1:     if (n > 0) {
 6561:         enum { OK, BAD, BAD_FORMAL } state;
 6561: 
    1:         /*
    1:          * Collect the function-argument arguments into one string, separated
    1:          * by commas, then make a tokenstream from that string, and scan it to
    1:          * get the arguments.  We need to throw the full scanner at the
    1:          * problem, because the argument string can legitimately contain
    1:          * comments and linefeeds.  XXX It might be better to concatenate
    1:          * everything up into a function definition and pass it to the
    1:          * compiler, but doing it this way is less of a delta from the old
    1:          * code.  See ECMA 15.3.2.1.
    1:          */
 6561:         state = BAD_FORMAL;
    1:         args_length = 0;
    1:         for (i = 0; i < n; i++) {
    1:             /* Collect the lengths for all the function-argument arguments. */
    1:             arg = js_ValueToString(cx, argv[i]);
    1:             if (!arg)
    1:                 return JS_FALSE;
48470:             argv[i].setString(arg);
    1: 
    1:             /*
    1:              * Check for overflow.  The < test works because the maximum
    1:              * JSString length fits in 2 fewer bits than size_t has.
    1:              */
    1:             old_args_length = args_length;
29366:             args_length = old_args_length + arg->length();
    1:             if (args_length < old_args_length) {
12983:                 js_ReportAllocationOverflow(cx);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1: 
    1:         /* Add 1 for each joining comma and check for overflow (two ways). */
    1:         old_args_length = args_length;
    1:         args_length = old_args_length + n - 1;
    1:         if (args_length < old_args_length ||
    1:             args_length >= ~(size_t)0 / sizeof(jschar)) {
12983:             js_ReportAllocationOverflow(cx);
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /*
    1:          * Allocate a string to hold the concatenated arguments, including room
    1:          * for a terminating 0.  Mark cx->tempPool for later release, to free
    1:          * collected_args and its tokenstream in one swoop.
    1:          */
47609:         mark = JS_ARENA_MARK(&cx->tempPool);
47609:         JS_ARENA_ALLOCATE_CAST(cp, jschar *, &cx->tempPool,
47609:                                (args_length+1) * sizeof(jschar));
    1:         if (!cp) {
 8296:             js_ReportOutOfScriptQuota(cx);
    1:             return JS_FALSE;
    1:         }
    1:         collected_args = cp;
    1: 
    1:         /*
    1:          * Concatenate the arguments into the new string, separated by commas.
    1:          */
    1:         for (i = 0; i < n; i++) {
48470:             arg = argv[i].toString();
29366:             arg_length = arg->length();
29366:             (void) js_strncpy(cp, arg->chars(), arg_length);
    1:             cp += arg_length;
    1: 
    1:             /* Add separating comma or terminating 0. */
    1:             *cp++ = (i + 1 < n) ? ',' : 0;
    1:         }
    1: 
 6561:         /* Initialize a tokenstream that reads from the given string. */
40270:         if (!ts.init(collected_args, args_length, NULL, filename, lineno)) {
47609:             JS_ARENA_RELEASE(&cx->tempPool, mark);
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /* The argument string may be empty or contain no tokens. */
40354:         tt = ts.getToken();
    1:         if (tt != TOK_EOF) {
    1:             for (;;) {
    1:                 /*
    1:                  * Check that it's a name.  This also implicitly guards against
    1:                  * TOK_ERROR, which was already reported.
    1:                  */
    1:                 if (tt != TOK_NAME)
 6561:                     goto after_args;
    1: 
    1:                 /*
 8444:                  * Get the atom corresponding to the name from the token
 8444:                  * stream; we're assured at this point that it's a valid
 8444:                  * identifier.
    1:                  */
40270:                 atom = ts.currentToken().t_atom;
    1: 
 8179:                 /* Check for a duplicate parameter name. */
13691:                 if (js_LookupLocal(cx, fun, atom, NULL) != JSLOCAL_NONE) {
 8179:                     const char *name;
 8179: 
 8179:                     name = js_AtomToPrintableString(cx, atom);
40320:                     ok = name && ReportCompileErrorNumber(cx, &ts, NULL,
40320:                                                           JSREPORT_WARNING | JSREPORT_STRICT,
40320:                                                           JSMSG_DUPLICATE_FORMAL, name);
 3624:                     if (!ok)
 6561:                         goto after_args;
    1:                 }
13691:                 if (!js_AddLocal(cx, fun, atom, JSLOCAL_ARG))
 6561:                     goto after_args;
    1: 
    1:                 /*
    1:                  * Get the next token.  Stop on end of stream.  Otherwise
    1:                  * insist on a comma, get another name, and iterate.
    1:                  */
40354:                 tt = ts.getToken();
    1:                 if (tt == TOK_EOF)
    1:                     break;
    1:                 if (tt != TOK_COMMA)
 6561:                     goto after_args;
40354:                 tt = ts.getToken();
    1:             }
    1:         }
    1: 
 6561:         state = OK;
 6561:       after_args:
40854:         if (state == BAD_FORMAL && !ts.isError()) {
 6561:             /*
 6561:              * Report "malformed formal parameter" iff no illegal char or
 6561:              * similar scanner error was already reported.
 6561:              */
 6561:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 6561:                                  JSMSG_BAD_FORMAL);
 6561:         }
40270:         ts.close();
47609:         JS_ARENA_RELEASE(&cx->tempPool, mark);
 6561:         if (state != OK)
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     if (argc) {
    1:         str = js_ValueToString(cx, argv[argc-1]);
    1:         if (!str)
    1:             return JS_FALSE;
48470:         argv[argc-1].setString(str);
 4076:     } else {
 4076:         str = cx->runtime->emptyString;
    1:     }
    1: 
40860:     return Compiler::compileFunctionBody(cx, fun, principals,
29366:                                          str->chars(), str->length(),
 8444:                                          filename, lineno);
    1: }
    1: 
51090: namespace {
51090: 
51090: JSBool
51090: ThrowTypeError(JSContext *cx, uintN argc, Value *vp)
51090: {
51090:     JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL,
51090:                                  JSMSG_THROW_TYPE_ERROR);
51090:     return false;
51090: }
51090: 
51090: }
51090: 
    1: JSObject *
    1: js_InitFunctionClass(JSContext *cx, JSObject *obj)
    1: {
51090:     JSObject *proto = js_InitClass(cx, obj, NULL, &js_FunctionClass, Function, 1,
43287:                                    NULL, function_methods, NULL, NULL);
    1:     if (!proto)
    1:         return NULL;
51090: 
51090:     JSFunction *fun = js_NewFunction(cx, proto, NULL, 0, JSFUN_INTERPRETED, obj, NULL);
    1:     if (!fun)
33178:         return NULL;
34290:     fun->u.i.script = JSScript::emptyScript();
51090: 
51090:     if (obj->getClass()->flags & JSCLASS_IS_GLOBAL) {
51090:         /* ES5 13.2.3: Construct the unique [[ThrowTypeError]] function object. */
51090:         JSObject *throwTypeError =
51090:             js_NewFunction(cx, NULL, reinterpret_cast<Native>(ThrowTypeError), 0,
51090:                            JSFUN_FAST_NATIVE, obj, NULL);
51090:         if (!throwTypeError)
51090:             return NULL;
51090: 
51090:         JS_ALWAYS_TRUE(js_SetReservedSlot(cx, obj, JSRESERVED_GLOBAL_THROWTYPEERROR,
51090:                                           ObjectValue(*throwTypeError)));
51090:     }
51090: 
    1:     return proto;
    1: }
    1: 
    1: JSFunction *
48470: js_NewFunction(JSContext *cx, JSObject *funobj, Native native, uintN nargs,
    1:                uintN flags, JSObject *parent, JSAtom *atom)
    1: {
    1:     JSFunction *fun;
    1: 
    1:     if (funobj) {
40430:         JS_ASSERT(funobj->isFunction());
39930:         funobj->setParent(parent);
    1:     } else {
50500:         funobj = NewFunction(cx, parent);
    1:         if (!funobj)
    1:             return NULL;
    1:     }
31452:     JS_ASSERT(!funobj->getPrivate());
13824:     fun = (JSFunction *) funobj;
    1: 
    1:     /* Initialize all function members. */
39928:     fun->nargs = uint16(nargs);
50489:     fun->flags = flags & (JSFUN_FLAGS_MASK | JSFUN_KINDMASK |
50489:                           JSFUN_TRCINFO | JSFUN_FAST_NATIVE_CTOR);
27012:     if ((flags & JSFUN_KINDMASK) >= JSFUN_INTERPRETED) {
13702:         JS_ASSERT(!native);
13702:         JS_ASSERT(nargs == 0);
13702:         fun->u.i.nvars = 0;
18308:         fun->u.i.nupvars = 0;
28952:         fun->u.i.skipmin = 0;
28952:         fun->u.i.wrapper = false;
13702:         fun->u.i.script = NULL;
13482: #ifdef DEBUG
13702:         fun->u.i.names.taggedAtom = 0;
13482: #endif
13702:     } else {
    1:         fun->u.n.extra = 0;
16519:         fun->u.n.spare = 0;
25887:         fun->u.n.clasp = NULL;
32669:         if (flags & JSFUN_TRCINFO) {
20408: #ifdef JS_TRACER
32669:             JSNativeTraceInfo *trcinfo =
32669:                 JS_FUNC_TO_DATA_PTR(JSNativeTraceInfo *, native);
48470:             fun->u.n.native = (js::Native) trcinfo->native;
25887:             fun->u.n.trcinfo = trcinfo;
20408: #else
25887:             fun->u.n.trcinfo = NULL;
20408: #endif
20408:         } else {
20408:             fun->u.n.native = native;
25887:             fun->u.n.trcinfo = NULL;
20408:         }
28086:         JS_ASSERT(fun->u.n.native);
13702:     }
    1:     fun->atom = atom;
    1: 
13824:     /* Set private to self to indicate non-cloned fully initialized function. */
31452:     FUN_OBJECT(fun)->setPrivate(fun);
    1:     return fun;
    1: }
    1: 
37694: JSObject * JS_FASTCALL
38604: js_CloneFunctionObject(JSContext *cx, JSFunction *fun, JSObject *parent,
38604:                        JSObject *proto)
    1: {
38604:     JS_ASSERT(parent);
38604:     JS_ASSERT(proto);
38604: 
13482:     /*
27012:      * The cloned function object does not need the extra JSFunction members
27012:      * beyond JSObject as it points to fun via the private slot.
13482:      */
47497:     JSObject *clone = NewNativeClassInstance(cx, &js_FunctionClass, proto, parent);
13824:     if (!clone)
    1:         return NULL;
31452:     clone->setPrivate(fun);
13824:     return clone;
    1: }
    1: 
38604: #ifdef JS_TRACER
39910: JS_DEFINE_CALLINFO_4(extern, OBJECT, js_CloneFunctionObject, CONTEXT, FUNCTION, OBJECT, OBJECT, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
38604: #endif
37694: 
28923: /*
28923:  * Create a new flat closure, but don't initialize the imported upvar
28923:  * values. The tracer calls this function and then initializes the upvar
28923:  * slots on trace.
28923:  */
28923: JSObject * JS_FASTCALL
28923: js_AllocFlatClosure(JSContext *cx, JSFunction *fun, JSObject *scopeChain)
27012: {
27012:     JS_ASSERT(FUN_FLAT_CLOSURE(fun));
28994:     JS_ASSERT((fun->u.i.script->upvarsOffset
32723:                ? fun->u.i.script->upvars()->length
28994:                : 0) == fun->u.i.nupvars);
27012: 
38604:     JSObject *closure = CloneFunctionObject(cx, fun, scopeChain);
31073:     if (!closure)
27012:         return closure;
31073: 
31073:     uint32 nslots = fun->countInterpretedReservedSlots();
47497:     if (nslots == 0)
31073:         return closure;
31073:     if (!js_EnsureReservedSlots(cx, closure, nslots))
27012:         return NULL;
27012: 
28923:     return closure;
28923: }
28923: 
28923: JS_DEFINE_CALLINFO_3(extern, OBJECT, js_AllocFlatClosure,
48613:                      CONTEXT, FUNCTION, OBJECT, 0, nanojit::ACCSET_STORE_ANY)
28923: 
38563: JS_REQUIRES_STACK JSObject *
28923: js_NewFlatClosure(JSContext *cx, JSFunction *fun)
28923: {
38563:     /*
38563:      * Flat closures can be partial, they may need to search enclosing scope
38563:      * objects via JSOP_NAME, etc.
38563:      */
51446:     JSObject *scopeChain = js_GetScopeChain(cx, cx->fp());
38563:     if (!scopeChain)
38563:         return NULL;
38563: 
38563:     JSObject *closure = js_AllocFlatClosure(cx, fun, scopeChain);
28994:     if (!closure || fun->u.i.nupvars == 0)
28994:         return closure;
28923: 
32723:     JSUpvarArray *uva = fun->u.i.script->upvars();
48470:     JS_ASSERT(uva->length <= closure->dslots[-1].toPrivateUint32());
27012: 
27168:     uintN level = fun->u.i.script->staticLevel;
27168:     for (uint32 i = 0, n = uva->length; i < n; i++)
48582:         closure->dslots[i] = GetUpvar(cx, level, uva->vector[i]);
27012: 
27012:     return closure;
27012: }
27012: 
28952: JSObject *
28952: js_NewDebuggableFlatClosure(JSContext *cx, JSFunction *fun)
28952: {
51446:     JS_ASSERT(cx->fp()->getFunction()->flags & JSFUN_HEAVYWEIGHT);
51446:     JS_ASSERT(!cx->fp()->getFunction()->optimizedClosure());
39916:     JS_ASSERT(FUN_FLAT_CLOSURE(fun));
28952: 
51446:     return WrapEscapingClosure(cx, cx->fp(), fun);
28952: }
28952: 
    1: JSFunction *
48470: js_DefineFunction(JSContext *cx, JSObject *obj, JSAtom *atom, Native native,
    1:                   uintN nargs, uintN attrs)
    1: {
48470:     PropertyOp gsop;
26970:     JSFunction *fun;
    1: 
27012:     if (attrs & JSFUN_STUB_GSOPS) {
27012:         /*
27012:          * JSFUN_STUB_GSOPS is a request flag only, not stored in fun->flags or
27012:          * the defined property's attributes. This allows us to encode another,
27012:          * internal flag using the same bit, JSFUN_EXPR_CLOSURE -- see jsfun.h
27012:          * for more on this.
27012:          */
27012:         attrs &= ~JSFUN_STUB_GSOPS;
48470:         gsop = PropertyStub;
27012:     } else {
27012:         gsop = NULL;
27012:     }
50489:     fun = js_NewFunction(cx, NULL, native, nargs,
50489:                          attrs & (JSFUN_FLAGS_MASK | JSFUN_TRCINFO), obj, atom);
    1:     if (!fun)
    1:         return NULL;
48470:     if (!obj->defineProperty(cx, ATOM_TO_JSID(atom), ObjectValue(*fun),
32573:                              gsop, gsop, attrs & ~JSFUN_FLAGS_MASK)) {
    1:         return NULL;
    1:     }
    1:     return fun;
    1: }
    1: 
    1: #if (JSV2F_CONSTRUCT & JSV2F_SEARCH_STACK)
    1: # error "JSINVOKE_CONSTRUCT and JSV2F_SEARCH_STACK are not disjoint!"
    1: #endif
    1: 
    1: JSFunction *
48470: js_ValueToFunction(JSContext *cx, const Value *vp, uintN flags)
    1: {
48470:     JSObject *funobj;
48470:     if (!IsFunctionObject(*vp, &funobj)) {
    1:         js_ReportIsNotFunction(cx, vp, flags);
    1:         return NULL;
    1:     }
48470:     return GET_FUNCTION_PRIVATE(cx, funobj);
    1: }
    1: 
    1: JSObject *
48470: js_ValueToFunctionObject(JSContext *cx, Value *vp, uintN flags)
    1: {
48470:     JSObject *funobj;
51075:     if (!IsFunctionObject(*vp, &funobj)) {
51075:         js_ReportIsNotFunction(cx, vp, flags);
    1:         return NULL;
    1:     }
51075: 
51075:     return funobj;
    1: }
    1: 
    1: JSObject *
48470: js_ValueToCallableObject(JSContext *cx, Value *vp, uintN flags)
    1: {
48470:     if (vp->isObject()) {
48470:         JSObject *callable = &vp->toObject();
48470:         if (callable->isCallable())
26059:             return callable;
    1:     }
51075: 
51075:     js_ReportIsNotFunction(cx, vp, flags);
51075:     return NULL;
    1: }
    1: 
    1: void
48470: js_ReportIsNotFunction(JSContext *cx, const Value *vp, uintN flags)
    1: {
42717:     const char *name = NULL, *source = NULL;
40389:     AutoValueRooter tvr(cx);
43211:     uintN error = (flags & JSV2F_CONSTRUCT) ? JSMSG_NOT_CONSTRUCTOR : JSMSG_NOT_FUNCTION;
42717:     LeaveTrace(cx);
50464: 
50464:     /*
50464:      * We try to the print the code that produced vp if vp is a value in the
50464:      * most recent interpreted stack frame. Note that additional values, not
50464:      * directly produced by the script, may have been pushed onto the frame's
50464:      * expression stack (e.g. by InvokeFromEngine) thereby incrementing sp past
50464:      * the depth simulated by ReconstructPCStack. Since we must pass an offset
50464:      * from the top of the simulated stack to js_ReportValueError3, it is
50464:      * important to do bounds checking using the simulated, rather than actual,
50464:      * stack depth.
50464:      */
50464:     ptrdiff_t spindex = 0;
50464: 
42717:     FrameRegsIter i(cx);
42717:     while (!i.done() && !i.pc())
42717:         ++i;
42717: 
50464:     if (!i.done()) {
51056:         uintN depth = js_ReconstructStackDepth(cx, i.fp()->getScript(), i.pc());
50464:         Value *simsp = i.fp()->base() + depth;
50464:         JS_ASSERT(simsp <= i.sp());
50464:         if (i.fp()->base() <= vp && vp < simsp)
50464:             spindex = vp - simsp;
50464:     }
50464: 
50464:     if (!spindex)
50464:         spindex = ((flags & JSV2F_SEARCH_STACK) ? JSDVG_SEARCH_STACK : JSDVG_IGNORE_STACK);
42717: 
42717:     js_ReportValueError3(cx, error, spindex, *vp, NULL, name, source);
    1: }
 8179: 
 8367: /*
 8367:  * When a function has between 2 and MAX_ARRAY_LOCALS arguments and variables,
 8367:  * their name are stored as the JSLocalNames.array.
 8367:  */
 8367: #define MAX_ARRAY_LOCALS 8
 8367: 
 8367: JS_STATIC_ASSERT(2 <= MAX_ARRAY_LOCALS);
 8367: JS_STATIC_ASSERT(MAX_ARRAY_LOCALS < JS_BITMASK(16));
 8367: 
 8367: /*
 8367:  * When we use a hash table to store the local names, we use a singly linked
 8367:  * list to record the indexes of duplicated parameter names to preserve the
 8367:  * duplicates for the decompiler.
 8367:  */
 8367: typedef struct JSNameIndexPair JSNameIndexPair;
 8367: 
 8367: struct JSNameIndexPair {
 8367:     JSAtom          *name;
 8367:     uint16          index;
 8367:     JSNameIndexPair *link;
 8367: };
 8367: 
 8367: struct JSLocalNameMap {
 8367:     JSDHashTable    names;
 8367:     JSNameIndexPair *lastdup;
 8367: };
 8367: 
 8367: typedef struct JSLocalNameHashEntry {
 8367:     JSDHashEntryHdr hdr;
 8367:     JSAtom          *name;
 8367:     uint16          index;
 8367:     uint8           localKind;
 8367: } JSLocalNameHashEntry;
 8367: 
 8367: static void
 8367: FreeLocalNameHash(JSContext *cx, JSLocalNameMap *map)
 8367: {
 8367:     JSNameIndexPair *dup, *next;
 8367: 
 8367:     for (dup = map->lastdup; dup; dup = next) {
 8367:         next = dup->link;
30851:         cx->free(dup);
 8367:     }
 8367:     JS_DHashTableFinish(&map->names);
30851:     cx->free(map);
 8367: }
 8367: 
 8367: static JSBool
 8367: HashLocalName(JSContext *cx, JSLocalNameMap *map, JSAtom *name,
 8367:               JSLocalKind localKind, uintN index)
 8367: {
 8367:     JSLocalNameHashEntry *entry;
 8367:     JSNameIndexPair *dup;
 8367: 
 8367:     JS_ASSERT(index <= JS_BITMASK(16));
 8367: #if JS_HAS_DESTRUCTURING
 8367:     if (!name) {
 8367:         /* A destructuring pattern does not need a hash entry. */
 8367:         JS_ASSERT(localKind == JSLOCAL_ARG);
 8367:         return JS_TRUE;
 8367:     }
 8367: #endif
 8367:     entry = (JSLocalNameHashEntry *)
 8367:             JS_DHashTableOperate(&map->names, name, JS_DHASH_ADD);
 8367:     if (!entry) {
 8367:         JS_ReportOutOfMemory(cx);
 8367:         return JS_FALSE;
 8367:     }
 8367:     if (entry->name) {
 8367:         JS_ASSERT(entry->name == name);
35376:         JS_ASSERT(entry->localKind == JSLOCAL_ARG && localKind == JSLOCAL_ARG);
30851:         dup = (JSNameIndexPair *) cx->malloc(sizeof *dup);
 8367:         if (!dup)
 8367:             return JS_FALSE;
 8367:         dup->name = entry->name;
 8367:         dup->index = entry->index;
 8367:         dup->link = map->lastdup;
 8367:         map->lastdup = dup;
 8367:     }
 8367:     entry->name = name;
 8367:     entry->index = (uint16) index;
 8367:     entry->localKind = (uint8) localKind;
 8367:     return JS_TRUE;
 8367: }
 8367: 
 8179: JSBool
13702: js_AddLocal(JSContext *cx, JSFunction *fun, JSAtom *atom, JSLocalKind kind)
 8179: {
 8367:     jsuword taggedAtom;
 8179:     uint16 *indexp;
 8367:     uintN n, i;
 8367:     jsuword *array;
 8367:     JSLocalNameMap *map;
 8179: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
13702:     JS_ASSERT(!fun->u.i.script);
 8367:     JS_ASSERT(((jsuword) atom & 1) == 0);
 8367:     taggedAtom = (jsuword) atom;
 8179:     if (kind == JSLOCAL_ARG) {
 8367:         indexp = &fun->nargs;
18308:     } else if (kind == JSLOCAL_UPVAR) {
18308:         indexp = &fun->u.i.nupvars;
 8367:     } else {
13702:         indexp = &fun->u.i.nvars;
 8367:         if (kind == JSLOCAL_CONST)
 8367:             taggedAtom |= 1;
 8367:         else
 8367:             JS_ASSERT(kind == JSLOCAL_VAR);
 8367:     }
28832:     n = fun->countLocalNames();
 8367:     if (n == 0) {
13702:         JS_ASSERT(fun->u.i.names.taggedAtom == 0);
13702:         fun->u.i.names.taggedAtom = taggedAtom;
 8367:     } else if (n < MAX_ARRAY_LOCALS) {
 8367:         if (n > 1) {
13702:             array = fun->u.i.names.array;
 8367:         } else {
30851:             array = (jsuword *) cx->malloc(MAX_ARRAY_LOCALS * sizeof *array);
 8367:             if (!array)
 8367:                 return JS_FALSE;
13702:             array[0] = fun->u.i.names.taggedAtom;
13702:             fun->u.i.names.array = array;
 8367:         }
 8367:         if (kind == JSLOCAL_ARG) {
 8367:             /*
 8367:              * A destructuring argument pattern adds variables, not arguments,
 8367:              * so for the following arguments nvars != 0.
 8367:              */
 8179: #if JS_HAS_DESTRUCTURING
13702:             if (fun->u.i.nvars != 0) {
 8367:                 memmove(array + fun->nargs + 1, array + fun->nargs,
13702:                         fun->u.i.nvars * sizeof *array);
 8179:             }
 8367: #else
13702:             JS_ASSERT(fun->u.i.nvars == 0);
 8179: #endif
 8367:             array[fun->nargs] = taggedAtom;
 8179:         } else {
 8367:             array[n] = taggedAtom;
 8367:         }
 8367:     } else if (n == MAX_ARRAY_LOCALS) {
13702:         array = fun->u.i.names.array;
30851:         map = (JSLocalNameMap *) cx->malloc(sizeof *map);
 8367:         if (!map)
 8367:             return JS_FALSE;
 8367:         if (!JS_DHashTableInit(&map->names, JS_DHashGetStubOps(),
 8367:                                NULL, sizeof(JSLocalNameHashEntry),
 8367:                                JS_DHASH_DEFAULT_CAPACITY(MAX_ARRAY_LOCALS
 8367:                                                          * 2))) {
 8367:             JS_ReportOutOfMemory(cx);
30851:             cx->free(map);
 8367:             return JS_FALSE;
 8179:         }
 8179: 
 8367:         map->lastdup = NULL;
 8367:         for (i = 0; i != MAX_ARRAY_LOCALS; ++i) {
 8367:             taggedAtom = array[i];
27012:             uintN j = i;
27012:             JSLocalKind k = JSLOCAL_ARG;
27012:             if (j >= fun->nargs) {
27012:                 j -= fun->nargs;
27012:                 if (j < fun->u.i.nvars) {
27012:                     k = (taggedAtom & 1) ? JSLOCAL_CONST : JSLOCAL_VAR;
27012:                 } else {
27012:                     j -= fun->u.i.nvars;
27012:                     k = JSLOCAL_UPVAR;
27012:                 }
27012:             }
27012:             if (!HashLocalName(cx, map, (JSAtom *) (taggedAtom & ~1), k, j)) {
 8367:                 FreeLocalNameHash(cx, map);
 8367:                 return JS_FALSE;
 8367:             }
 8367:         }
 8367:         if (!HashLocalName(cx, map, atom, kind, *indexp)) {
 8367:             FreeLocalNameHash(cx, map);
 8367:             return JS_FALSE;
 8367:         }
 8367: 
 8367:         /*
 8367:          * At this point the entry is added and we cannot fail. It is time
 8367:          * to replace fun->u.i.names with the built map.
 8367:          */
13702:         fun->u.i.names.map = map;
30851:         cx->free(array);
 8367:     } else {
 8179:         if (*indexp == JS_BITMASK(16)) {
 8179:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 8179:                                  (kind == JSLOCAL_ARG)
 8179:                                  ? JSMSG_TOO_MANY_FUN_ARGS
16072:                                  : JSMSG_TOO_MANY_LOCALS);
 8179:             return JS_FALSE;
 8179:         }
13702:         if (!HashLocalName(cx, fun->u.i.names.map, atom, kind, *indexp))
 8179:             return JS_FALSE;
 8179:     }
 8179: 
 8367:     /* Update the argument or variable counter. */
 8179:     ++*indexp;
 8179:     return JS_TRUE;
 8179: }
 8179: 
 8179: JSLocalKind
13702: js_LookupLocal(JSContext *cx, JSFunction *fun, JSAtom *atom, uintN *indexp)
 8179: {
18308:     uintN n, i, upvar_base;
 8367:     jsuword *array;
 8367:     JSLocalNameHashEntry *entry;
 8179: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
28832:     n = fun->countLocalNames();
 8367:     if (n == 0)
 8367:         return JSLOCAL_NONE;
 8367:     if (n <= MAX_ARRAY_LOCALS) {
13702:         array = (n == 1) ? &fun->u.i.names.taggedAtom : fun->u.i.names.array;
 8179: 
 8367:         /* Search from the tail to pick up the last duplicated name. */
 8367:         i = n;
28832:         upvar_base = fun->countArgsAndVars();
 8367:         do {
 8367:             --i;
11435:             if (atom == JS_LOCAL_NAME_TO_ATOM(array[i])) {
 8367:                 if (i < fun->nargs) {
 8367:                     if (indexp)
 8367:                         *indexp = i;
 8367:                     return JSLOCAL_ARG;
 8179:                 }
18308:                 if (i >= upvar_base) {
18308:                     if (indexp)
18308:                         *indexp = i - upvar_base;
18308:                     return JSLOCAL_UPVAR;
18308:                 }
 8179:                 if (indexp)
 8367:                     *indexp = i - fun->nargs;
11435:                 return JS_LOCAL_NAME_IS_CONST(array[i])
11435:                        ? JSLOCAL_CONST
11435:                        : JSLOCAL_VAR;
 8179:             }
 8367:         } while (i != 0);
 8367:     } else {
 8367:         entry = (JSLocalNameHashEntry *)
13702:                 JS_DHashTableOperate(&fun->u.i.names.map->names, atom,
 8367:                                      JS_DHASH_LOOKUP);
 8367:         if (JS_DHASH_ENTRY_IS_BUSY(&entry->hdr)) {
 8367:             JS_ASSERT(entry->localKind != JSLOCAL_NONE);
 8367:             if (indexp)
 8367:                 *indexp = entry->index;
 8367:             return (JSLocalKind) entry->localKind;
 8179:         }
 8367:     }
 8367:     return JSLOCAL_NONE;
 8367: }
 8367: 
11435: typedef struct JSLocalNameEnumeratorArgs {
13702:     JSFunction      *fun;
11435:     jsuword         *names;
 8367: #ifdef DEBUG
 8367:     uintN           nCopiedArgs;
 8367:     uintN           nCopiedVars;
 8367: #endif
11435: } JSLocalNameEnumeratorArgs;
 8367: 
18907: static JSDHashOperator
 8367: get_local_names_enumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
 8367:                            uint32 number, void *arg)
 8367: {
 8367:     JSLocalNameHashEntry *entry;
11435:     JSLocalNameEnumeratorArgs *args;
 8367:     uint i;
11435:     jsuword constFlag;
 8367: 
 8367:     entry = (JSLocalNameHashEntry *) hdr;
11435:     args = (JSLocalNameEnumeratorArgs *) arg;
 8367:     JS_ASSERT(entry->name);
 8367:     if (entry->localKind == JSLOCAL_ARG) {
 8367:         JS_ASSERT(entry->index < args->fun->nargs);
 8367:         JS_ASSERT(args->nCopiedArgs++ < args->fun->nargs);
 8367:         i = entry->index;
11435:         constFlag = 0;
 8367:     } else {
 8367:         JS_ASSERT(entry->localKind == JSLOCAL_VAR ||
27012:                   entry->localKind == JSLOCAL_CONST ||
27012:                   entry->localKind == JSLOCAL_UPVAR);
27012:         JS_ASSERT(entry->index < args->fun->u.i.nvars + args->fun->u.i.nupvars);
33166:         JS_ASSERT(args->nCopiedVars++ < unsigned(args->fun->u.i.nvars + args->fun->u.i.nupvars));
27012:         i = args->fun->nargs;
27012:         if (entry->localKind == JSLOCAL_UPVAR)
27012:            i += args->fun->u.i.nvars;
27012:         i += entry->index;
11435:         constFlag = (entry->localKind == JSLOCAL_CONST);
 8367:     }
11435:     args->names[i] = (jsuword) entry->name | constFlag;
 8367:     return JS_DHASH_NEXT;
 8179: }
 8179: 
48470: jsuword *
13702: js_GetLocalNameArray(JSContext *cx, JSFunction *fun, JSArenaPool *pool)
 8179: {
11435:     uintN n;
11435:     jsuword *names;
 8367:     JSLocalNameMap *map;
11435:     JSLocalNameEnumeratorArgs args;
 8367:     JSNameIndexPair *dup;
 8179: 
28832:     JS_ASSERT(fun->hasLocalNames());
28832:     n = fun->countLocalNames();
11435: 
11435:     if (n <= MAX_ARRAY_LOCALS)
13702:         return (n == 1) ? &fun->u.i.names.taggedAtom : fun->u.i.names.array;
11435: 
11435:     /*
11435:      * No need to check for overflow of the allocation size as we are making a
11435:      * copy of already allocated data. As such it must fit size_t.
11435:      */
47609:     JS_ARENA_ALLOCATE_CAST(names, jsuword *, pool, (size_t) n * sizeof *names);
 8179:     if (!names) {
 8296:         js_ReportOutOfScriptQuota(cx);
 8179:         return NULL;
 8179:     }
 8179: 
 8179: #if JS_HAS_DESTRUCTURING
 8179:     /* Some parameter names can be NULL due to destructuring patterns. */
40229:     PodZero(names, fun->nargs);
 8179: #endif
13702:     map = fun->u.i.names.map;
 8367:     args.fun = fun;
 8367:     args.names = names;
 8367: #ifdef DEBUG
 8367:     args.nCopiedArgs = 0;
 8367:     args.nCopiedVars = 0;
 8367: #endif
 8367:     JS_DHashTableEnumerate(&map->names, get_local_names_enumerator, &args);
 8367:     for (dup = map->lastdup; dup; dup = dup->link) {
 8367:         JS_ASSERT(dup->index < fun->nargs);
 8367:         JS_ASSERT(args.nCopiedArgs++ < fun->nargs);
11435:         names[dup->index] = (jsuword) dup->name;
 8179:     }
 8179: #if !JS_HAS_DESTRUCTURING
 8367:     JS_ASSERT(args.nCopiedArgs == fun->nargs);
 8179: #endif
27012:     JS_ASSERT(args.nCopiedVars == fun->u.i.nvars + fun->u.i.nupvars);
 8367: 
 8179:     return names;
 8179: }
 8179: 
18907: static JSDHashOperator
 8367: trace_local_names_enumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
 8367:                              uint32 number, void *arg)
 8367: {
 8367:     JSLocalNameHashEntry *entry;
 8367:     JSTracer *trc;
 8367: 
 8367:     entry = (JSLocalNameHashEntry *) hdr;
 8367:     JS_ASSERT(entry->name);
 8367:     trc = (JSTracer *) arg;
 8367:     JS_SET_TRACING_INDEX(trc,
 8367:                          entry->localKind == JSLOCAL_ARG ? "arg" : "var",
 8367:                          entry->index);
48470:     Mark(trc, ATOM_TO_STRING(entry->name), JSTRACE_STRING);
 8367:     return JS_DHASH_NEXT;
 8367: }
 8367: 
 8367: static void
13702: TraceLocalNames(JSTracer *trc, JSFunction *fun)
 8367: {
 8367:     uintN n, i;
 8367:     JSAtom *atom;
 8367:     jsuword *array;
 8367: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
28832:     n = fun->countLocalNames();
 8367:     if (n == 0)
 8367:         return;
 8367:     if (n <= MAX_ARRAY_LOCALS) {
13702:         array = (n == 1) ? &fun->u.i.names.taggedAtom : fun->u.i.names.array;
 8367:         i = n;
 8367:         do {
 8367:             --i;
 8367:             atom = (JSAtom *) (array[i] & ~1);
 8367:             if (atom) {
 8367:                 JS_SET_TRACING_INDEX(trc,
 8367:                                      i < fun->nargs ? "arg" : "var",
 8367:                                      i < fun->nargs ? i : i - fun->nargs);
48470:                 Mark(trc, ATOM_TO_STRING(atom), JSTRACE_STRING);
 8367:             }
 8367:         } while (i != 0);
 8367:     } else {
13702:         JS_DHashTableEnumerate(&fun->u.i.names.map->names,
 8367:                                trace_local_names_enumerator, trc);
 8367: 
 8367:         /*
 8367:          * No need to trace the list of duplicates in map->lastdup as the
 8367:          * names there are traced when enumerating the hash table.
 8367:          */
 8367:     }
 8367: }
 8367: 
 8367: void
13702: DestroyLocalNames(JSContext *cx, JSFunction *fun)
 8367: {
 8367:     uintN n;
 8367: 
28832:     n = fun->countLocalNames();
 8367:     if (n <= 1)
 8367:         return;
 8367:     if (n <= MAX_ARRAY_LOCALS)
30851:         cx->free(fun->u.i.names.array);
 8367:     else
13702:         FreeLocalNameHash(cx, fun->u.i.names.map);
 8367: }
 8367: 
 8367: void
13702: js_FreezeLocalNames(JSContext *cx, JSFunction *fun)
 8367: {
 8367:     uintN n;
 8367:     jsuword *array;
 8367: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
13702:     JS_ASSERT(!fun->u.i.script);
18308:     n = fun->nargs + fun->u.i.nvars + fun->u.i.nupvars;
 8367:     if (2 <= n && n < MAX_ARRAY_LOCALS) {
 8367:         /* Shrink over-allocated array ignoring realloc failures. */
30851:         array = (jsuword *) cx->realloc(fun->u.i.names.array,
13702:                                         n * sizeof *array);
 8367:         if (array)
13702:             fun->u.i.names.array = array;
 8367:     }
26569: #ifdef DEBUG
26569:     if (n > MAX_ARRAY_LOCALS)
26569:         JS_DHashMarkTableImmutable(&fun->u.i.names.map->names);
26569: #endif
 8367: }
35323: 
35409: JSAtom *
35409: JSFunction::findDuplicateFormal() const
35323: {
51095:     JS_ASSERT(isInterpreted());
51095: 
35323:     if (nargs <= 1)
35323:         return NULL;
35323: 
35323:     /* Function with two to MAX_ARRAY_LOCALS parameters use an aray. */
35409:     unsigned n = nargs + u.i.nvars + u.i.nupvars;
35409:     if (n <= MAX_ARRAY_LOCALS) {
35409:         jsuword *array = u.i.names.array;
35409: 
35323:         /* Quadratic, but MAX_ARRAY_LOCALS is 8, so at most 28 comparisons. */
35323:         for (unsigned i = 0; i < nargs; i++) {
35323:             for (unsigned j = i + 1; j < nargs; j++) {
35323:                 if (array[i] == array[j])
35323:                     return JS_LOCAL_NAME_TO_ATOM(array[i]);
35323:             }
35323:         }
35323:         return NULL;
35323:     }
35323: 
35323:     /*
35323:      * Functions with more than MAX_ARRAY_LOCALS parameters use a hash
35323:      * table. Hashed local name maps have already made a list of any
35323:      * duplicate argument names for us.
35323:      */
35409:     JSNameIndexPair *dup = u.i.names.map->lastdup;
35323:     return dup ? dup->name : NULL;
35323: }
