40289: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
11809:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsapi_h___
    1: #define jsapi_h___
    1: /*
    1:  * JavaScript API.
    1:  */
    1: #include <stddef.h>
    1: #include <stdio.h>
21063: #include "js-config.h"
    1: #include "jspubtd.h"
  583: #include "jsutil.h"
    1: 
    1: JS_BEGIN_EXTERN_C
    1: 
    1: /*
48470:  * In release builds, jsval and jsid are defined to be integral types. This
48470:  * prevents many bugs from being caught at compile time. E.g.:
48470:  *
48470:  *  jsval v = ...
48470:  *  if (v == JS_TRUE)  // error
48470:  *    ...
48470:  *
48470:  *  jsid id = v;       // error
48470:  *
48470:  * To catch more errors, jsval and jsid are given struct types in debug builds.
48470:  * Struct assignment and (in C++) operator== allow correct code to be mostly
48470:  * oblivious to the change. This feature can be explicitly disabled in debug
48470:  * builds by defining JS_NO_JSVAL_JSID_STRUCT_TYPES.
    1:  */
48470: #ifdef JS_USE_JSVAL_JSID_STRUCT_TYPES
48470: 
48470: /* Well-known JS values. N.B. These constants are initialized at startup. */
48470: extern JS_PUBLIC_DATA(jsval) JSVAL_NULL;
48470: extern JS_PUBLIC_DATA(jsval) JSVAL_ZERO;
48470: extern JS_PUBLIC_DATA(jsval) JSVAL_ONE;
48470: extern JS_PUBLIC_DATA(jsval) JSVAL_FALSE;
48470: extern JS_PUBLIC_DATA(jsval) JSVAL_TRUE;
48470: extern JS_PUBLIC_DATA(jsval) JSVAL_VOID;
48470: 
48470: #else
48470: 
48470: /* Well-known JS values. */
48470: #define JSVAL_NULL   BUILD_JSVAL(JSVAL_TAG_NULL,      0)
48470: #define JSVAL_ZERO   BUILD_JSVAL(JSVAL_TAG_INT32,     0)
48470: #define JSVAL_ONE    BUILD_JSVAL(JSVAL_TAG_INT32,     1)
48470: #define JSVAL_FALSE  BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   JS_FALSE)
48470: #define JSVAL_TRUE   BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   JS_TRUE)
48470: #define JSVAL_VOID   BUILD_JSVAL(JSVAL_TAG_UNDEFINED, 0)
48470: 
48470: #endif
48470: 
48470: /************************************************************************/
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_NULL(jsval v)
48470: {
48470:     jsval_layout l;
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_IS_NULL_IMPL(l);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_VOID(jsval v)
48470: {
48470:     jsval_layout l;
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_IS_UNDEFINED_IMPL(l);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_INT(jsval v)
48470: {
48470:     jsval_layout l;
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_IS_INT32_IMPL(l);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsint
48470: JSVAL_TO_INT(jsval v)
48470: {
48470:     jsval_layout l;
48470:     JS_ASSERT(JSVAL_IS_INT(v));
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_TO_INT32_IMPL(l);
48470: }
48470: 
48470: #define JSVAL_INT_BITS          32
48470: #define JSVAL_INT_MIN           ((jsint)0x80000000)
48470: #define JSVAL_INT_MAX           ((jsint)0x7fffffff)
30844: 
30844: static JS_ALWAYS_INLINE jsval
48470: INT_TO_JSVAL(int32 i)
24846: {
48470:     return IMPL_TO_JSVAL(INT32_TO_JSVAL_IMPL(i));
24846: }
24846: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_DOUBLE(jsval v)
48470: {
48470:     jsval_layout l;
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_IS_DOUBLE_IMPL(l);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsdouble
48470: JSVAL_TO_DOUBLE(jsval v)
48470: {
48470:     jsval_layout l;
48470:     JS_ASSERT(JSVAL_IS_DOUBLE(v));
48470:     l.asBits = JSVAL_BITS(v);
48470:     return l.asDouble;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval
48470: DOUBLE_TO_JSVAL(jsdouble d)
48470: {
49081:     d = JS_CANONICALIZE_NAN(d);
48470:     return IMPL_TO_JSVAL(DOUBLE_TO_JSVAL_IMPL(d));
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval
48470: UINT_TO_JSVAL(uint32 i)
48470: {
48470:     if (i <= JSVAL_INT_MAX)
48470:         return INT_TO_JSVAL((int32)i);
48470:     return DOUBLE_TO_JSVAL((jsdouble)i);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_NUMBER(jsval v)
48470: {
48470:     jsval_layout l;
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_IS_NUMBER_IMPL(l);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_STRING(jsval v)
48470: {
48470:     jsval_layout l;
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_IS_STRING_IMPL(l);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSString *
48470: JSVAL_TO_STRING(jsval v)
48470: {
48470:     jsval_layout l;
48470:     JS_ASSERT(JSVAL_IS_STRING(v));
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_TO_STRING_IMPL(l);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval
48470: STRING_TO_JSVAL(JSString *str)
48470: {
48470:     return IMPL_TO_JSVAL(STRING_TO_JSVAL_IMPL(str));
48470: }
48470: 
30844: static JS_ALWAYS_INLINE JSBool
30844: JSVAL_IS_OBJECT(jsval v)
30844: {
48470:     jsval_layout l;
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_IS_OBJECT_OR_NULL_IMPL(l);
30844: }
30844: 
48470: static JS_ALWAYS_INLINE JSObject *
48470: JSVAL_TO_OBJECT(jsval v)
30844: {
48470:     jsval_layout l;
48470:     JS_ASSERT(JSVAL_IS_OBJECT(v));
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_TO_OBJECT_IMPL(l);
30844: }
30844: 
48470: static JS_ALWAYS_INLINE jsval
48470: OBJECT_TO_JSVAL(JSObject *obj)
30844: {
48470:     if (obj)
48470:         return IMPL_TO_JSVAL(OBJECT_TO_JSVAL_IMPL(obj));
48470:     return JSVAL_NULL;
31521: }
31521: 
31521: static JS_ALWAYS_INLINE JSBool
30844: JSVAL_IS_BOOLEAN(jsval v)
30844: {
48470:     jsval_layout l;
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_IS_BOOLEAN_IMPL(l);
30844: }
30844: 
30844: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_TO_BOOLEAN(jsval v)
30844: {
48470:     jsval_layout l;
48470:     JS_ASSERT(JSVAL_IS_BOOLEAN(v));
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_TO_BOOLEAN_IMPL(l);
30844: }
30844: 
48470: static JS_ALWAYS_INLINE jsval
48470: BOOLEAN_TO_JSVAL(JSBool b)
30844: {
48470:     return IMPL_TO_JSVAL(BOOLEAN_TO_JSVAL_IMPL(b));
30844: }
30844: 
30844: static JS_ALWAYS_INLINE JSBool
30844: JSVAL_IS_PRIMITIVE(jsval v)
30844: {
48470:     jsval_layout l;
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_IS_PRIMITIVE_IMPL(l);
30844: }
30844: 
30844: static JS_ALWAYS_INLINE JSBool
30844: JSVAL_IS_GCTHING(jsval v)
30844: {
48470:     jsval_layout l;
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_IS_GCTHING_IMPL(l);
30844: }
30844: 
30844: static JS_ALWAYS_INLINE void *
30844: JSVAL_TO_GCTHING(jsval v)
30844: {
48470:     jsval_layout l;
30844:     JS_ASSERT(JSVAL_IS_GCTHING(v));
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_TO_GCTHING_IMPL(l);
30844: }
30844: 
48470: /* To be GC-safe, privates are tagged as doubles. */
48470: 
48470: static JS_ALWAYS_INLINE jsval
48470: PRIVATE_TO_JSVAL(void *ptr)
48470: {
48470:     return IMPL_TO_JSVAL(PRIVATE_PTR_TO_JSVAL_IMPL(ptr));
48470: }
48470: 
48470: static JS_ALWAYS_INLINE void *
48470: JSVAL_TO_PRIVATE(jsval v)
48470: {
48470:     jsval_layout l;
48470:     JS_ASSERT(JSVAL_IS_DOUBLE(v));
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_TO_PRIVATE_PTR_IMPL(l);
48470: }
48470: 
48470: /************************************************************************/
48470: 
48470: /*
48470:  * A jsid is an identifier for a property or method of an object which is
48470:  * either a 31-bit signed integer, interned string or object. If XML is
48470:  * enabled, there is an additional singleton jsid value; see
48470:  * JS_DEFAULT_XML_NAMESPACE_ID below. Finally, there is an additional jsid
48470:  * value, JSID_VOID, which does not occur in JS scripts but may be used to
48470:  * indicate the absence of a valid jsid.
48470:  *
48470:  * A jsid is not implicitly convertible to or from a jsval; JS_ValueToId or
48470:  * JS_IdToValue must be used instead.
48470:  */
48470: 
48470: #define JSID_TYPE_STRING                 0x0
48470: #define JSID_TYPE_INT                    0x1
48470: #define JSID_TYPE_VOID                   0x2
48470: #define JSID_TYPE_OBJECT                 0x4
48470: #define JSID_TYPE_DEFAULT_XML_NAMESPACE  0x6
48470: #define JSID_TYPE_MASK                   0x7
48470: 
48470: /*
52503:  * Avoid using canonical 'id' for jsid parameters since this is a magic word in
48470:  * Objective-C++ which, apparently, wants to be able to #include jsapi.h.
48470:  */
52503: #define id iden
48470: 
48470: static JS_ALWAYS_INLINE JSBool
52503: JSID_IS_STRING(jsid id)
48470: {
52503:     return (JSID_BITS(id) & JSID_TYPE_MASK) == 0;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSString *
52503: JSID_TO_STRING(jsid id)
48470: {
52503:     JS_ASSERT(JSID_IS_STRING(id));
52503:     return (JSString *)(JSID_BITS(id));
48470: }
48470: 
57133: static JS_ALWAYS_INLINE JSBool
57133: JSID_IS_ZERO(jsid id)
57133: {
57133:     return JSID_BITS(id) == NULL;
57133: }
57133: 
48470: JS_PUBLIC_API(JSBool)
48470: JS_StringHasBeenInterned(JSString *str);
48470: 
48470: /* A jsid may only hold an interned JSString. */
48470: static JS_ALWAYS_INLINE jsid
48470: INTERNED_STRING_TO_JSID(JSString *str)
48470: {
52503:     jsid id;
55713:     JS_ASSERT(str);
48470:     JS_ASSERT(JS_StringHasBeenInterned(str));
48470:     JS_ASSERT(((size_t)str & JSID_TYPE_MASK) == 0);
52503:     JSID_BITS(id) = (size_t)str;
52503:     return id;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
52503: JSID_IS_INT(jsid id)
48470: {
52503:     return !!(JSID_BITS(id) & JSID_TYPE_INT);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE int32
52503: JSID_TO_INT(jsid id)
48470: {
52503:     JS_ASSERT(JSID_IS_INT(id));
52503:     return ((int32)JSID_BITS(id)) >> 1;
48470: }
48470: 
48470: #define JSID_INT_MIN  (-(1 << 30))
48470: #define JSID_INT_MAX  ((1 << 30) - 1)
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: INT_FITS_IN_JSID(int32 i)
48470: {
48470:     return ((jsuint)(i) - (jsuint)JSID_INT_MIN <=
48470:             (jsuint)(JSID_INT_MAX - JSID_INT_MIN));
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsid
48470: INT_TO_JSID(int32 i)
48470: {
52503:     jsid id;
48470:     JS_ASSERT(INT_FITS_IN_JSID(i));
52503:     JSID_BITS(id) = ((i << 1) | JSID_TYPE_INT);
52503:     return id;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
52503: JSID_IS_OBJECT(jsid id)
48470: {
52503:     return (JSID_BITS(id) & JSID_TYPE_MASK) == JSID_TYPE_OBJECT &&
52503:            (size_t)JSID_BITS(id) != JSID_TYPE_OBJECT;
48470: }
48470: 
30844: static JS_ALWAYS_INLINE JSObject *
52503: JSID_TO_OBJECT(jsid id)
30844: {
52503:     JS_ASSERT(JSID_IS_OBJECT(id));
52503:     return (JSObject *)(JSID_BITS(id) & ~(size_t)JSID_TYPE_MASK);
30844: }
30844: 
48470: static JS_ALWAYS_INLINE jsid
48470: OBJECT_TO_JSID(JSObject *obj)
30844: {
52503:     jsid id;
48470:     JS_ASSERT(obj != NULL);
48470:     JS_ASSERT(((size_t)obj & JSID_TYPE_MASK) == 0);
52503:     JSID_BITS(id) = ((size_t)obj | JSID_TYPE_OBJECT);
52503:     return id;
30844: }
30844: 
48470: static JS_ALWAYS_INLINE JSBool
52503: JSID_IS_GCTHING(jsid id)
30844: {
52503:     return JSID_IS_STRING(id) || JSID_IS_OBJECT(id);
30844: }
30844: 
48470: static JS_ALWAYS_INLINE void *
52503: JSID_TO_GCTHING(jsid id)
30844: {
52503:     return (void *)(JSID_BITS(id) & ~(size_t)JSID_TYPE_MASK);
30844: }
30844: 
48470: /*
48470:  * The magic XML namespace id is not a valid jsid. Global object classes in
48470:  * embeddings that enable JS_HAS_XML_SUPPORT (E4X) should handle this id.
48470:  */
48470: 
48470: static JS_ALWAYS_INLINE JSBool
52503: JSID_IS_DEFAULT_XML_NAMESPACE(jsid id)
30844: {
52503:     JS_ASSERT_IF(((size_t)JSID_BITS(id) & JSID_TYPE_MASK) == JSID_TYPE_DEFAULT_XML_NAMESPACE,
52503:                  JSID_BITS(id) == JSID_TYPE_DEFAULT_XML_NAMESPACE);
52503:     return ((size_t)JSID_BITS(id) == JSID_TYPE_DEFAULT_XML_NAMESPACE);
30844: }
30844: 
48470: #ifdef JS_USE_JSVAL_JSID_STRUCT_TYPES
48470: extern JS_PUBLIC_DATA(jsid) JS_DEFAULT_XML_NAMESPACE_ID;
48470: #else
48470: #define JS_DEFAULT_XML_NAMESPACE_ID ((jsid)JSID_TYPE_DEFAULT_XML_NAMESPACE)
48470: #endif
48470: 
48470: /*
48470:  * A void jsid is not a valid id and only arises as an exceptional API return
48470:  * value, such as in JS_NextProperty. Embeddings must not pass JSID_VOID into
48470:  * JSAPI entry points expecting a jsid and do not need to handle JSID_VOID in
48470:  * hooks receiving a jsid except when explicitly noted in the API contract.
48470:  */
48470: 
48470: static JS_ALWAYS_INLINE JSBool
52503: JSID_IS_VOID(jsid id)
30844: {
52503:     JS_ASSERT_IF(((size_t)JSID_BITS(id) & JSID_TYPE_MASK) == JSID_TYPE_VOID,
52503:                  JSID_BITS(id) == JSID_TYPE_VOID);
52503:     return ((size_t)JSID_BITS(id) == JSID_TYPE_VOID);
30844: }
30844: 
52503: static JS_ALWAYS_INLINE JSBool
52503: JSID_IS_EMPTY(jsid id)
52503: {
52503:     return ((size_t)JSID_BITS(id) == JSID_TYPE_OBJECT);
52503: }
52503: 
52503: #undef id
52503: 
48470: #ifdef JS_USE_JSVAL_JSID_STRUCT_TYPES
48470: extern JS_PUBLIC_DATA(jsid) JSID_VOID;
52503: extern JS_PUBLIC_DATA(jsid) JSID_EMPTY;
48470: #else
48470: # define JSID_VOID      ((jsid)JSID_TYPE_VOID)
52503: # define JSID_EMPTY     ((jsid)JSID_TYPE_OBJECT)
48470: #endif
48470: 
48470: /************************************************************************/
48470: 
30844: /* Lock and unlock the GC thing held by a jsval. */
30844: #define JSVAL_LOCK(cx,v)        (JSVAL_IS_GCTHING(v)                          \
30844:                                  ? JS_LockGCThing(cx, JSVAL_TO_GCTHING(v))    \
30844:                                  : JS_TRUE)
30844: #define JSVAL_UNLOCK(cx,v)      (JSVAL_IS_GCTHING(v)                          \
30844:                                  ? JS_UnlockGCThing(cx, JSVAL_TO_GCTHING(v))  \
30844:                                  : JS_TRUE)
30844: 
    1: /* Property attributes, set in JSPropertySpec and passed to API functions. */
    1: #define JSPROP_ENUMERATE        0x01    /* property is visible to for/in loop */
    1: #define JSPROP_READONLY         0x02    /* not settable: assignment is no-op */
    1: #define JSPROP_PERMANENT        0x04    /* property cannot be deleted */
    1: #define JSPROP_GETTER           0x10    /* property holds getter function */
    1: #define JSPROP_SETTER           0x20    /* property holds setter function */
    1: #define JSPROP_SHARED           0x40    /* don't allocate a value slot for this
    1:                                            property; don't copy the property on
    1:                                            set of the same-named property in an
    1:                                            object that delegates to a prototype
    1:                                            containing this property */
    1: #define JSPROP_INDEX            0x80    /* name is actually (jsint) index */
42733: #define JSPROP_SHORTID          0x100   /* set in JSPropertyDescriptor.attrs
42733:                                            if getters/setters use a shortid */
    1: 
    1: /* Function flags, set in JSFunctionSpec and passed to JS_NewFunction etc. */
53557: #define JSFUN_CONSTRUCTOR       0x02    /* native that can be called as a ctor
53557:                                            without creating a this object */
    1: #define JSFUN_LAMBDA            0x08    /* expressed, not declared, function */
    1: #define JSFUN_HEAVYWEIGHT       0x80    /* activation requires a Call object */
    1: 
    1: #define JSFUN_HEAVYWEIGHT_TEST(f)  ((f) & JSFUN_HEAVYWEIGHT)
    1: 
55711: #define JSFUN_PRIMITIVE_THIS  0x0100    /* |this| may be a primitive value */
    1: 
53557: #define JSFUN_FLAGS_MASK      0x07fa    /* overlay JSFUN_* attributes --
27012:                                            bits 12-15 are used internally to
27012:                                            flag interpreted functions */
    1: 
11377: #define JSFUN_STUB_GSOPS      0x1000    /* use JS_PropertyStub getter/setter
11377:                                            instead of defaulting to class gsops
11377:                                            for property holding function */
11377: 
    1: /*
    1:  * Re-use JSFUN_LAMBDA, which applies only to scripted functions, for use in
    1:  * JSFunctionSpec arrays that specify generic native prototype methods, i.e.,
    1:  * methods of a class prototype that are exposed as static methods taking an
    1:  * extra leading argument: the generic |this| parameter.
    1:  *
    1:  * If you set this flag in a JSFunctionSpec struct's flags initializer, then
    1:  * that struct must live at least as long as the native static method object
    1:  * created due to this flag by JS_DefineFunctions or JS_InitClass.  Typically
    1:  * JSFunctionSpec structs are allocated in static arrays.
    1:  */
    1: #define JSFUN_GENERIC_NATIVE    JSFUN_LAMBDA
    1: 
    1: /*
    1:  * Microseconds since the epoch, midnight, January 1, 1970 UTC.  See the
    1:  * comment in jstypes.h regarding safe int64 usage.
    1:  */
    1: extern JS_PUBLIC_API(int64)
 7647: JS_Now(void);
    1: 
    1: /* Don't want to export data, so provide accessors for non-inline jsvals. */
    1: extern JS_PUBLIC_API(jsval)
    1: JS_GetNaNValue(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(jsval)
    1: JS_GetNegativeInfinityValue(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(jsval)
    1: JS_GetPositiveInfinityValue(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(jsval)
    1: JS_GetEmptyStringValue(JSContext *cx);
    1: 
    1: /*
    1:  * Format is a string of the following characters (spaces are insignificant),
    1:  * specifying the tabulated type conversions:
    1:  *
    1:  *   b      JSBool          Boolean
    1:  *   c      uint16/jschar   ECMA uint16, Unicode char
    1:  *   i      int32           ECMA int32
    1:  *   u      uint32          ECMA uint32
    1:  *   j      int32           Rounded int32 (coordinate)
    1:  *   d      jsdouble        IEEE double
    1:  *   I      jsdouble        Integral IEEE double
    1:  *   s      char *          C string
    1:  *   S      JSString *      Unicode string, accessed by a JSString pointer
    1:  *   W      jschar *        Unicode character vector, 0-terminated (W for wide)
    1:  *   o      JSObject *      Object reference
    1:  *   f      JSFunction *    Function private
    1:  *   v      jsval           Argument value (no conversion)
    1:  *   *      N/A             Skip this argument (no vararg)
    1:  *   /      N/A             End of required arguments
    1:  *
    1:  * The variable argument list after format must consist of &b, &c, &s, e.g.,
    1:  * where those variables have the types given above.  For the pointer types
    1:  * char *, JSString *, and JSObject *, the pointed-at memory returned belongs
    1:  * to the JS runtime, not to the calling native code.  The runtime promises
    1:  * to keep this memory valid so long as argv refers to allocated stack space
    1:  * (so long as the native function is active).
    1:  *
    1:  * Fewer arguments than format specifies may be passed only if there is a /
    1:  * in format after the last required argument specifier and argc is at least
    1:  * the number of required arguments.  More arguments than format specifies
    1:  * may be passed without error; it is up to the caller to deal with trailing
    1:  * unconverted arguments.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ConvertArguments(JSContext *cx, uintN argc, jsval *argv, const char *format,
    1:                     ...);
    1: 
    1: #ifdef va_start
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ConvertArgumentsVA(JSContext *cx, uintN argc, jsval *argv,
    1:                       const char *format, va_list ap);
    1: #endif
    1: 
    1: #ifdef JS_ARGUMENT_FORMATTER_DEFINED
    1: 
    1: /*
    1:  * Add and remove a format string handler for JS_{Convert,Push}Arguments{,VA}.
    1:  * The handler function has this signature (see jspubtd.h):
    1:  *
    1:  *   JSBool MyArgumentFormatter(JSContext *cx, const char *format,
    1:  *                              JSBool fromJS, jsval **vpp, va_list *app);
    1:  *
    1:  * It should return true on success, and return false after reporting an error
    1:  * or detecting an already-reported error.
    1:  *
    1:  * For a given format string, for example "AA", the formatter is called from
    1:  * JS_ConvertArgumentsVA like so:
    1:  *
    1:  *   formatter(cx, "AA...", JS_TRUE, &sp, &ap);
    1:  *
    1:  * sp points into the arguments array on the JS stack, while ap points into
    1:  * the stdarg.h va_list on the C stack.  The JS_TRUE passed for fromJS tells
    1:  * the formatter to convert zero or more jsvals at sp to zero or more C values
    1:  * accessed via pointers-to-values at ap, updating both sp (via *vpp) and ap
    1:  * (via *app) to point past the converted arguments and their result pointers
    1:  * on the C stack.
    1:  *
    1:  * When called from JS_PushArgumentsVA, the formatter is invoked thus:
    1:  *
    1:  *   formatter(cx, "AA...", JS_FALSE, &sp, &ap);
    1:  *
    1:  * where JS_FALSE for fromJS means to wrap the C values at ap according to the
    1:  * format specifier and store them at sp, updating ap and sp appropriately.
    1:  *
    1:  * The "..." after "AA" is the rest of the format string that was passed into
    1:  * JS_{Convert,Push}Arguments{,VA}.  The actual format trailing substring used
    1:  * in each Convert or PushArguments call is passed to the formatter, so that
    1:  * one such function may implement several formats, in order to share code.
    1:  *
    1:  * Remove just forgets about any handler associated with format.  Add does not
    1:  * copy format, it points at the string storage allocated by the caller, which
    1:  * is typically a string constant.  If format is in dynamic storage, it is up
    1:  * to the caller to keep the string alive until Remove is called.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_AddArgumentFormatter(JSContext *cx, const char *format,
    1:                         JSArgumentFormatter formatter);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_RemoveArgumentFormatter(JSContext *cx, const char *format);
    1: 
    1: #endif /* JS_ARGUMENT_FORMATTER_DEFINED */
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ConvertValue(JSContext *cx, jsval v, JSType type, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ValueToObject(JSContext *cx, jsval v, JSObject **objp);
    1: 
    1: extern JS_PUBLIC_API(JSFunction *)
    1: JS_ValueToFunction(JSContext *cx, jsval v);
    1: 
    1: extern JS_PUBLIC_API(JSFunction *)
    1: JS_ValueToConstructor(JSContext *cx, jsval v);
    1: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_ValueToString(JSContext *cx, jsval v);
    1: 
21482: extern JS_PUBLIC_API(JSString *)
21482: JS_ValueToSource(JSContext *cx, jsval v);
21482: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ValueToNumber(JSContext *cx, jsval v, jsdouble *dp);
    1: 
39905: extern JS_PUBLIC_API(JSBool)
39905: JS_DoubleIsInt32(jsdouble d, jsint *ip);
39905: 
    1: /*
    1:  * Convert a value to a number, then to an int32, according to the ECMA rules
    1:  * for ToInt32.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ValueToECMAInt32(JSContext *cx, jsval v, int32 *ip);
    1: 
    1: /*
    1:  * Convert a value to a number, then to a uint32, according to the ECMA rules
    1:  * for ToUint32.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ValueToECMAUint32(JSContext *cx, jsval v, uint32 *ip);
    1: 
    1: /*
    1:  * Convert a value to a number, then to an int32 if it fits by rounding to
    1:  * nearest; but failing with an error report if the double is out of range
    1:  * or unordered.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ValueToInt32(JSContext *cx, jsval v, int32 *ip);
    1: 
    1: /*
    1:  * ECMA ToUint16, for mapping a jsval to a Unicode point.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ValueToUint16(JSContext *cx, jsval v, uint16 *ip);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ValueToBoolean(JSContext *cx, jsval v, JSBool *bp);
    1: 
    1: extern JS_PUBLIC_API(JSType)
    1: JS_TypeOfValue(JSContext *cx, jsval v);
    1: 
    1: extern JS_PUBLIC_API(const char *)
    1: JS_GetTypeName(JSContext *cx, JSType type);
    1: 
28408: extern JS_PUBLIC_API(JSBool)
28408: JS_StrictlyEqual(JSContext *cx, jsval v1, jsval v2);
28408: 
32760: extern JS_PUBLIC_API(JSBool)
32760: JS_SameValue(JSContext *cx, jsval v1, jsval v2);
32760: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Initialization, locking, contexts, and memory allocation.
    1:  *
    1:  * It is important that the first runtime and first context be created in a
    1:  * single-threaded fashion, otherwise the behavior of the library is undefined.
    1:  * See: http://developer.mozilla.org/en/docs/Category:JSAPI_Reference
    1:  */
    1: #define JS_NewRuntime       JS_Init
    1: #define JS_DestroyRuntime   JS_Finish
    1: #define JS_LockRuntime      JS_Lock
    1: #define JS_UnlockRuntime    JS_Unlock
    1: 
    1: extern JS_PUBLIC_API(JSRuntime *)
    1: JS_NewRuntime(uint32 maxbytes);
    1: 
54718: /* Deprecated. */
54718: #define JS_CommenceRuntimeShutDown(rt) ((void) 0) 
31885: 
31885: extern JS_PUBLIC_API(void)
    1: JS_DestroyRuntime(JSRuntime *rt);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_ShutDown(void);
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetRuntimePrivate(JSRuntime *rt);
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetRuntimePrivate(JSRuntime *rt, void *data);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_BeginRequest(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_EndRequest(JSContext *cx);
    1: 
    1: /* Yield to pending GC operations, regardless of request depth */
    1: extern JS_PUBLIC_API(void)
    1: JS_YieldRequest(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(jsrefcount)
    1: JS_SuspendRequest(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_ResumeRequest(JSContext *cx, jsrefcount saveDepth);
    1: 
    1: #ifdef __cplusplus
    1: JS_END_EXTERN_C
    1: 
    1: class JSAutoRequest {
    1:   public:
33538:     JSAutoRequest(JSContext *cx JS_GUARD_OBJECT_NOTIFIER_PARAM)
33538:         : mContext(cx), mSaveDepth(0) {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
    1:         JS_BeginRequest(mContext);
    1:     }
    1:     ~JSAutoRequest() {
    1:         JS_EndRequest(mContext);
    1:     }
    1: 
    1:     void suspend() {
    1:         mSaveDepth = JS_SuspendRequest(mContext);
    1:     }
    1:     void resume() {
    1:         JS_ResumeRequest(mContext, mSaveDepth);
    1:     }
    1: 
    1:   protected:
    1:     JSContext *mContext;
    1:     jsrefcount mSaveDepth;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
    1: 
    1: #if 0
    1:   private:
    1:     static void *operator new(size_t) CPP_THROW_NEW { return 0; };
    1:     static void operator delete(void *, size_t) { };
    1: #endif
    1: };
    1: 
16018: class JSAutoSuspendRequest {
16018:   public:
33538:     JSAutoSuspendRequest(JSContext *cx JS_GUARD_OBJECT_NOTIFIER_PARAM)
33538:         : mContext(cx), mSaveDepth(0) {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
16018:         if (mContext) {
16018:             mSaveDepth = JS_SuspendRequest(mContext);
16018:         }
16018:     }
16018:     ~JSAutoSuspendRequest() {
16018:         resume();
16018:     }
16018: 
16018:     void resume() {
16018:         if (mContext) {
16018:             JS_ResumeRequest(mContext, mSaveDepth);
16018:             mContext = 0;
16018:         }
16018:     }
16018: 
16018:   protected:
16018:     JSContext *mContext;
16018:     jsrefcount mSaveDepth;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
16018: 
16018: #if 0
16018:   private:
16018:     static void *operator new(size_t) CPP_THROW_NEW { return 0; };
16018:     static void operator delete(void *, size_t) { };
16018: #endif
16018: };
16018: 
    1: JS_BEGIN_EXTERN_C
    1: #endif
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_Lock(JSRuntime *rt);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_Unlock(JSRuntime *rt);
    1: 
    1: extern JS_PUBLIC_API(JSContextCallback)
    1: JS_SetContextCallback(JSRuntime *rt, JSContextCallback cxCallback);
    1: 
    1: extern JS_PUBLIC_API(JSContext *)
    1: JS_NewContext(JSRuntime *rt, size_t stackChunkSize);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_DestroyContext(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_DestroyContextNoGC(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_DestroyContextMaybeGC(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(void *)
    1: JS_GetContextPrivate(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetContextPrivate(JSContext *cx, void *data);
    1: 
    1: extern JS_PUBLIC_API(JSRuntime *)
    1: JS_GetRuntime(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(JSContext *)
    1: JS_ContextIterator(JSRuntime *rt, JSContext **iterp);
    1: 
    1: extern JS_PUBLIC_API(JSVersion)
    1: JS_GetVersion(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(JSVersion)
    1: JS_SetVersion(JSContext *cx, JSVersion version);
    1: 
    1: extern JS_PUBLIC_API(const char *)
    1: JS_VersionToString(JSVersion version);
    1: 
    1: extern JS_PUBLIC_API(JSVersion)
    1: JS_StringToVersion(const char *string);
    1: 
    1: /*
    1:  * JS options are orthogonal to version, and may be freely composed with one
    1:  * another as well as with version.
    1:  *
    1:  * JSOPTION_VAROBJFIX is recommended -- see the comments associated with the
    1:  * prototypes for JS_ExecuteScript, JS_EvaluateScript, etc.
    1:  */
    1: #define JSOPTION_STRICT         JS_BIT(0)       /* warn on dubious practice */
    1: #define JSOPTION_WERROR         JS_BIT(1)       /* convert warning to error */
    1: #define JSOPTION_VAROBJFIX      JS_BIT(2)       /* make JS_EvaluateScript use
    1:                                                    the last object on its 'obj'
    1:                                                    param's scope chain as the
    1:                                                    ECMA 'variables object' */
    1: #define JSOPTION_PRIVATE_IS_NSISUPPORTS \
    1:                                 JS_BIT(3)       /* context private data points
    1:                                                    to an nsISupports subclass */
    1: #define JSOPTION_COMPILE_N_GO   JS_BIT(4)       /* caller of JS_Compile*Script
    1:                                                    promises to execute compiled
    1:                                                    script once only; enables
    1:                                                    compile-time scope chain
    1:                                                    resolution of consts. */
    1: #define JSOPTION_ATLINE         JS_BIT(5)       /* //@line number ["filename"]
    1:                                                    option supported for the
    1:                                                    XUL preprocessor and kindred
    1:                                                    beasts. */
    1: #define JSOPTION_XML            JS_BIT(6)       /* EMCAScript for XML support:
    1:                                                    parse <!-- --> as a token,
    1:                                                    not backward compatible with
    1:                                                    the comment-hiding hack used
    1:                                                    in HTML script tags. */
    1: #define JSOPTION_DONT_REPORT_UNCAUGHT \
    1:                                 JS_BIT(8)       /* When returning from the
    1:                                                    outermost API call, prevent
    1:                                                    uncaught exceptions from
    1:                                                    being converted to error
    1:                                                    reports */
    1: 
    1: #define JSOPTION_RELIMIT        JS_BIT(9)       /* Throw exception on any
    1:                                                    regular expression which
    1:                                                    backtracks more than n^3
    1:                                                    times, where n is length
    1:                                                    of the input string */
  399: #define JSOPTION_ANONFUNFIX     JS_BIT(10)      /* Disallow function () {} in
  399:                                                    statement context per
  399:                                                    ECMA-262 Edition 3. */
    1: 
17325: #define JSOPTION_JIT            JS_BIT(11)      /* Enable JIT compilation. */
17325: 
17828: #define JSOPTION_NO_SCRIPT_RVAL JS_BIT(12)      /* A promise to the compiler
17828:                                                    that a null rval out-param
17828:                                                    will be passed to each call
17828:                                                    to JS_ExecuteScript. */
22795: #define JSOPTION_UNROOTED_GLOBAL JS_BIT(13)     /* The GC will not root the
24375:                                                    contexts' global objects
24375:                                                    (see JS_GetGlobalObject),
24375:                                                    leaving that up to the
24375:                                                    embedding. */
17828: 
52557: #define JSOPTION_METHODJIT      JS_BIT(14)      /* Whole-method JIT. */
56551: #define JSOPTION_PROFILING      JS_BIT(15)      /* Profiler to make tracer/methodjit choices. */
52557: 
    1: extern JS_PUBLIC_API(uint32)
    1: JS_GetOptions(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(uint32)
    1: JS_SetOptions(JSContext *cx, uint32 options);
    1: 
    1: extern JS_PUBLIC_API(uint32)
    1: JS_ToggleOptions(JSContext *cx, uint32 options);
    1: 
    1: extern JS_PUBLIC_API(const char *)
    1: JS_GetImplementationVersion(void);
    1: 
48503: extern JS_PUBLIC_API(JSCompartmentCallback)
48503: JS_SetCompartmentCallback(JSRuntime *rt, JSCompartmentCallback callback);
48503: 
47516: extern JS_PUBLIC_API(JSWrapObjectCallback)
55628: JS_SetWrapObjectCallbacks(JSRuntime *rt,
55628:                           JSWrapObjectCallback callback,
55628:                           JSPreWrapCallback precallback);
47516: 
47498: extern JS_PUBLIC_API(JSCrossCompartmentCall *)
47498: JS_EnterCrossCompartmentCall(JSContext *cx, JSObject *target);
47498: 
47498: extern JS_PUBLIC_API(void)
47498: JS_LeaveCrossCompartmentCall(JSCrossCompartmentCall *call);
47498: 
48503: extern JS_PUBLIC_API(void *)
48503: JS_SetCompartmentPrivate(JSContext *cx, JSCompartment *compartment, void *data);
48503: 
48503: extern JS_PUBLIC_API(void *)
48503: JS_GetCompartmentPrivate(JSContext *cx, JSCompartment *compartment);
48503: 
51450: extern JS_PUBLIC_API(JSBool)
54399: JS_WrapObject(JSContext *cx, JSObject **objp);
51450: 
51450: extern JS_PUBLIC_API(JSBool)
54399: JS_WrapValue(JSContext *cx, jsval *vp);
51450: 
55574: extern JS_PUBLIC_API(JSObject *)
55574: JS_TransplantWrapper(JSContext *cx, JSObject *wrapper, JSObject *target);
55574: 
47517: #ifdef __cplusplus
47517: JS_END_EXTERN_C
47517: 
54733: class JS_PUBLIC_API(JSAutoEnterCompartment)
47517: {
47517:     JSCrossCompartmentCall *call;
54733: 
47517:   public:
54733:     JSAutoEnterCompartment() : call(NULL) {}
47517: 
48503:     bool enter(JSContext *cx, JSObject *target);
47517: 
54733:     void enterAndIgnoreErrors(JSContext *cx, JSObject *target);
54733: 
53623:     bool entered() const { return call != NULL; }
53623: 
54733:     ~JSAutoEnterCompartment() {
55631:         if (call && call != reinterpret_cast<JSCrossCompartmentCall*>(1))
47517:             JS_LeaveCrossCompartmentCall(call);
47517:     }
53623: 
54733:     void swap(JSAutoEnterCompartment &other) {
53623:         JSCrossCompartmentCall *tmp = call;
53623:         call = other.call;
53623:         other.call = tmp;
53623:     }
47517: };
47517: 
47517: JS_BEGIN_EXTERN_C
47517: #endif
47517: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetGlobalObject(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetGlobalObject(JSContext *cx, JSObject *obj);
    1: 
    1: /*
    1:  * Initialize standard JS class constructors, prototypes, and any top-level
    1:  * functions and constants associated with the standard classes (e.g. isNaN
    1:  * for Number).
    1:  *
    1:  * NB: This sets cx's global object to obj if it was null.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_InitStandardClasses(JSContext *cx, JSObject *obj);
    1: 
    1: /*
    1:  * Resolve id, which must contain either a string or an int, to a standard
    1:  * class name in obj if possible, defining the class's constructor and/or
    1:  * prototype and storing true in *resolved.  If id does not name a standard
    1:  * class or a top-level property induced by initializing a standard class,
    1:  * store false in *resolved and just return true.  Return false on error,
    1:  * as usual for JSBool result-typed API entry points.
    1:  *
    1:  * This API can be called directly from a global object class's resolve op,
    1:  * to define standard classes lazily.  The class's enumerate op should call
    1:  * JS_EnumerateStandardClasses(cx, obj), to define eagerly during for..in
    1:  * loops any classes not yet resolved lazily.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
48470: JS_ResolveStandardClass(JSContext *cx, JSObject *obj, jsid id,
    1:                         JSBool *resolved);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_EnumerateStandardClasses(JSContext *cx, JSObject *obj);
    1: 
    1: /*
    1:  * Enumerate any already-resolved standard class ids into ida, or into a new
    1:  * JSIdArray if ida is null.  Return the augmented array on success, null on
    1:  * failure with ida (if it was non-null on entry) destroyed.
    1:  */
    1: extern JS_PUBLIC_API(JSIdArray *)
    1: JS_EnumerateResolvedStandardClasses(JSContext *cx, JSObject *obj,
    1:                                     JSIdArray *ida);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key,
    1:                   JSObject **objp);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetScopeChain(JSContext *cx);
    1: 
 4427: extern JS_PUBLIC_API(JSObject *)
 4427: JS_GetGlobalForObject(JSContext *cx, JSObject *obj);
 4427: 
42766: extern JS_PUBLIC_API(JSObject *)
42766: JS_GetGlobalForScopeChain(JSContext *cx);
42766: 
40447: #ifdef JS_HAS_CTYPES
40447: /*
40447:  * Initialize the 'ctypes' object on a global variable 'obj'. The 'ctypes'
40447:  * object will be sealed.
40447:  */
40447: extern JS_PUBLIC_API(JSBool)
40447: JS_InitCTypesClass(JSContext *cx, JSObject *global);
53704: 
53704: /*
53704:  * Convert a unicode string 'source' of length 'slen' to the platform native
53704:  * charset, returning a null-terminated string allocated with JS_malloc. On
53704:  * failure, this function should report an error.
53704:  */
53704: typedef char *
53704: (* JSCTypesUnicodeToNativeFun)(JSContext *cx, const jschar *source, size_t slen);
53704: 
53704: /*
53704:  * Set of function pointers that ctypes can use for various internal functions.
53704:  * See JS_SetCTypesCallbacks below. Providing NULL for a function is safe,
53704:  * and will result in the applicable ctypes functionality not being available.
53704:  */
53704: struct JSCTypesCallbacks {
53704:     JSCTypesUnicodeToNativeFun unicodeToNative;
53704: };
53704: 
53704: typedef struct JSCTypesCallbacks JSCTypesCallbacks;
53704: 
53704: /*
53704:  * Set the callbacks on the provided 'ctypesObj' object. 'callbacks' should be a
53704:  * pointer to static data that exists for the lifetime of 'ctypesObj', but it
53704:  * may safely be altered after calling this function and without having
53704:  * to call this function again.
53704:  */
53704: extern JS_PUBLIC_API(JSBool)
53704: JS_SetCTypesCallbacks(JSContext *cx, JSObject *ctypesObj, JSCTypesCallbacks *callbacks);
40447: #endif
40447: 
 4127: /*
 4127:  * Macros to hide interpreter stack layout details from a JSFastNative using
 4127:  * its jsval *vp parameter. The stack layout underlying invocation can't change
 4127:  * without breaking source and binary compatibility (argv[-2] is well-known to
 4127:  * be the callee jsval, and argv[-1] is as well known to be |this|).
 4127:  *
11809:  * Note well: However, argv[-1] may be JSVAL_NULL where with slow natives it
11809:  * is the global object, so embeddings implementing fast natives *must* call
11809:  * JS_THIS or JS_THIS_OBJECT and test for failure indicated by a null return,
11809:  * which should propagate as a false return from native functions and hooks.
11809:  *
11809:  * To reduce boilerplace checks, JS_InstanceOf and JS_GetInstancePrivate now
11809:  * handle a null obj parameter by returning false (throwing a TypeError if
11809:  * given non-null argv), so most native functions that type-check their |this|
11809:  * parameter need not add null checking.
11809:  *
 4127:  * NB: there is an anti-dependency between JS_CALLEE and JS_SET_RVAL: native
 4127:  * methods that may inspect their callee must defer setting their return value
 4127:  * until after any such possible inspection. Otherwise the return value will be
 4127:  * inspected instead of the callee function object.
 4127:  *
 4127:  * WARNING: These are not (yet) mandatory macros, but new code outside of the
 4127:  * engine should use them. In the Mozilla 2.0 milestone their definitions may
 4127:  * change incompatibly.
53557:  *
53557:  * N.B. constructors must not use JS_THIS, as no 'this' object has been created.
 4127:  */
53557: 
 4127: #define JS_CALLEE(cx,vp)        ((vp)[0])
43288: #define JS_THIS(cx,vp)          JS_ComputeThis(cx, vp)
48470: #define JS_THIS_OBJECT(cx,vp)   (JSVAL_TO_OBJECT(JS_THIS(cx,vp)))
 4127: #define JS_ARGV(cx,vp)          ((vp) + 2)
 4127: #define JS_RVAL(cx,vp)          (*(vp))
 4127: #define JS_SET_RVAL(cx,vp,v)    (*(vp) = (v))
 4127: 
11809: extern JS_PUBLIC_API(jsval)
11809: JS_ComputeThis(JSContext *cx, jsval *vp);
11809: 
53018: #ifdef __cplusplus
53051: #undef JS_THIS
53004: static inline jsval
53004: JS_THIS(JSContext *cx, jsval *vp)
53004: {
53004:     return JSVAL_IS_PRIMITIVE(vp[1]) ? JS_ComputeThis(cx, vp) : vp[1];
53004: }
53018: #endif
53004: 
    1: extern JS_PUBLIC_API(void *)
    1: JS_malloc(JSContext *cx, size_t nbytes);
    1: 
    1: extern JS_PUBLIC_API(void *)
    1: JS_realloc(JSContext *cx, void *p, size_t nbytes);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_free(JSContext *cx, void *p);
    1: 
34383: extern JS_PUBLIC_API(void)
34383: JS_updateMallocCounter(JSContext *cx, size_t nbytes);
34383: 
    1: extern JS_PUBLIC_API(char *)
    1: JS_strdup(JSContext *cx, const char *s);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_NewNumberValue(JSContext *cx, jsdouble d, jsval *rval);
    1: 
    1: /*
47403:  * A GC root is a pointer to a jsval, JSObject * or JSString * that itself
47403:  * points into the GC heap. JS_AddValueRoot takes a pointer to a jsval and
47403:  * JS_AddGCThingRoot takes a pointer to a JSObject * or JString *.
    1:  *
47403:  * Note that, since JS_Add*Root stores the address of a variable (of type
47403:  * jsval, JSString *, or JSObject *), that variable must live until
47403:  * JS_Remove*Root is called to remove that variable. For example, after:
    1:  *
47403:  *   void some_function() {
47403:  *     jsval v;
47403:  *     JS_AddNamedRootedValue(cx, &v, "name");
47403:  *
47403:  * the caller must perform
47403:  *
47403:  *     JS_RemoveRootedValue(cx, &v);
47403:  *
47403:  * before some_function() returns.
47403:  *
47403:  * Also, use JS_AddNamed*Root(cx, &structPtr->memberObj, "structPtr->memberObj")
47403:  * in preference to JS_Add*Root(cx, &structPtr->memberObj), in order to identify
    1:  * roots by their source callsites.  This way, you can find the callsite while
47403:  * debugging if you should fail to do JS_Remove*Root(cx, &structPtr->memberObj)
    1:  * before freeing structPtr's memory.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
47403: JS_AddValueRoot(JSContext *cx, jsval *vp);
47403: 
47403: extern JS_PUBLIC_API(JSBool)
47403: JS_AddStringRoot(JSContext *cx, JSString **rp);
47403: 
47403: extern JS_PUBLIC_API(JSBool)
47403: JS_AddObjectRoot(JSContext *cx, JSObject **rp);
47403: 
47403: extern JS_PUBLIC_API(JSBool)
47403: JS_AddGCThingRoot(JSContext *cx, void **rp);
    1: 
    1: #ifdef NAME_ALL_GC_ROOTS
    1: #define JS_DEFINE_TO_TOKEN(def) #def
    1: #define JS_DEFINE_TO_STRING(def) JS_DEFINE_TO_TOKEN(def)
47403: #define JS_AddValueRoot(cx,vp) JS_AddNamedValueRoot((cx), (vp), (__FILE__ ":" JS_TOKEN_TO_STRING(__LINE__))
47403: #define JS_AddStringRoot(cx,rp) JS_AddNamedStringRoot((cx), (rp), (__FILE__ ":" JS_TOKEN_TO_STRING(__LINE__))
47403: #define JS_AddObjectRoot(cx,rp) JS_AddNamedObjectRoot((cx), (rp), (__FILE__ ":" JS_TOKEN_TO_STRING(__LINE__))
47403: #define JS_AddGCThingRoot(cx,rp) JS_AddNamedGCThingRoot((cx), (rp), (__FILE__ ":" JS_TOKEN_TO_STRING(__LINE__))
    1: #endif
    1: 
    1: extern JS_PUBLIC_API(JSBool)
47403: JS_AddNamedValueRoot(JSContext *cx, jsval *vp, const char *name);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
47403: JS_AddNamedStringRoot(JSContext *cx, JSString **rp, const char *name);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
47403: JS_AddNamedObjectRoot(JSContext *cx, JSObject **rp, const char *name);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
47403: JS_AddNamedGCThingRoot(JSContext *cx, void **rp, const char *name);
47403: 
47403: extern JS_PUBLIC_API(JSBool)
47403: JS_RemoveValueRoot(JSContext *cx, jsval *vp);
47403: 
47403: extern JS_PUBLIC_API(JSBool)
47403: JS_RemoveStringRoot(JSContext *cx, JSString **rp);
47403: 
47403: extern JS_PUBLIC_API(JSBool)
47403: JS_RemoveObjectRoot(JSContext *cx, JSObject **rp);
47403: 
47403: extern JS_PUBLIC_API(JSBool)
47403: JS_RemoveGCThingRoot(JSContext *cx, void **rp);
47403: 
47403: /* TODO: remove these APIs */
47403: 
47403: extern JS_FRIEND_API(JSBool)
47403: js_AddRootRT(JSRuntime *rt, jsval *vp, const char *name);
47403: 
47403: extern JS_FRIEND_API(JSBool)
47403: js_AddGCThingRootRT(JSRuntime *rt, void **rp, const char *name);
47403: 
47403: extern JS_FRIEND_API(JSBool)
47403: js_RemoveRoot(JSRuntime *rt, void *rp);
    1: 
    1: /*
47403:  * This symbol may be used by embedders to detect the change from the old
47403:  * JS_AddRoot(JSContext *, void *) APIs to the new ones above.
    1:  */
47403: #define JS_TYPED_ROOTING_API
43289: 
47494: /* Obsolete rooting APIs. */
51109: #define JS_ClearNewbornRoots(cx) ((void) 0)
47532: #define JS_EnterLocalRootScope(cx) (JS_TRUE)
47494: #define JS_LeaveLocalRootScope(cx) ((void) 0)
47494: #define JS_LeaveLocalRootScopeWithResult(cx, rval) ((void) 0)
47494: #define JS_ForgetLocalRoot(cx, thing) ((void) 0)
    1: 
48470: typedef enum JSGCRootType {
48470:     JS_GC_ROOT_VALUE_PTR,
48470:     JS_GC_ROOT_GCTHING_PTR
48470: } JSGCRootType;
48470: 
    1: #ifdef DEBUG
    1: extern JS_PUBLIC_API(void)
    1: JS_DumpNamedRoots(JSRuntime *rt,
48470:                   void (*dump)(const char *name, void *rp, JSGCRootType type, void *data),
    1:                   void *data);
    1: #endif
    1: 
    1: /*
    1:  * Call JS_MapGCRoots to map the GC's roots table using map(rp, name, data).
    1:  * The root is pointed at by rp; if the root is unnamed, name is null; data is
    1:  * supplied from the third parameter to JS_MapGCRoots.
    1:  *
    1:  * The map function should return JS_MAP_GCROOT_REMOVE to cause the currently
    1:  * enumerated root to be removed.  To stop enumeration, set JS_MAP_GCROOT_STOP
    1:  * in the return value.  To keep on mapping, return JS_MAP_GCROOT_NEXT.  These
    1:  * constants are flags; you can OR them together.
    1:  *
    1:  * This function acquires and releases rt's GC lock around the mapping of the
    1:  * roots table, so the map function should run to completion in as few cycles
    1:  * as possible.  Of course, map cannot call JS_GC, JS_MaybeGC, JS_BeginRequest,
    1:  * or any JS API entry point that acquires locks, without double-tripping or
    1:  * deadlocking on the GC lock.
    1:  *
48470:  * The JSGCRootType parameter indicates whether rp is a pointer to a Value
48470:  * (which is obtained by '(Value *)rp') or a pointer to a GC-thing pointer
48470:  * (which is obtained by '(void **)rp').
48470:  *
    1:  * JS_MapGCRoots returns the count of roots that were successfully mapped.
    1:  */
    1: #define JS_MAP_GCROOT_NEXT      0       /* continue mapping entries */
    1: #define JS_MAP_GCROOT_STOP      1       /* stop mapping entries */
    1: #define JS_MAP_GCROOT_REMOVE    2       /* remove and free the current entry */
    1: 
    1: typedef intN
48470: (* JSGCRootMapFun)(void *rp, JSGCRootType type, const char *name, void *data);
    1: 
    1: extern JS_PUBLIC_API(uint32)
    1: JS_MapGCRoots(JSRuntime *rt, JSGCRootMapFun map, void *data);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_LockGCThing(JSContext *cx, void *thing);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_LockGCThingRT(JSRuntime *rt, void *thing);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_UnlockGCThing(JSContext *cx, void *thing);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_UnlockGCThingRT(JSRuntime *rt, void *thing);
    1: 
    1: /*
  958:  * Register externally maintained GC roots.
  958:  *
  958:  * traceOp: the trace operation. For each root the implementation should call
  958:  *          JS_CallTracer whenever the root contains a traceable thing.
  958:  * data:    the data argument to pass to each invocation of traceOp.
  958:  */
  958: extern JS_PUBLIC_API(void)
  958: JS_SetExtraGCRoots(JSRuntime *rt, JSTraceDataOp traceOp, void *data);
  958: 
  958: /*
  583:  * For implementors of JSMarkOp. All new code should implement JSTraceOp
  583:  * instead.
    1:  */
    1: extern JS_PUBLIC_API(void)
48470: JS_MarkGCThing(JSContext *cx, jsval v, const char *name, void *arg);
    1: 
  583: /*
  583:  * JS_CallTracer API and related macros for implementors of JSTraceOp, to
  583:  * enumerate all references to traceable things reachable via a property or
  583:  * other strong ref identified for debugging purposes by name or index or
 2228:  * a naming callback.
  583:  *
  583:  * By definition references to traceable things include non-null pointers
  583:  * to JSObject, JSString and jsdouble and corresponding jsvals.
  583:  *
  583:  * See the JSTraceOp typedef in jspubtd.h.
  583:  */
  583: 
  583: /* Trace kinds to pass to JS_Tracing. */
  583: #define JSTRACE_OBJECT  0
48470: #define JSTRACE_STRING  1
  583: 
  583: /*
  583:  * Use the following macros to check if a particular jsval is a traceable
  583:  * thing and to extract the thing and its kind to pass to JS_CallTracer.
  583:  */
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_TRACEABLE(jsval v)
48470: {
48470:     jsval_layout l;
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_IS_TRACEABLE_IMPL(l);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE void *
48470: JSVAL_TO_TRACEABLE(jsval v)
48470: {
48470:     return JSVAL_TO_GCTHING(v);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE uint32
48470: JSVAL_TRACE_KIND(jsval v)
48470: {
48470:     jsval_layout l;
48470:     JS_ASSERT(JSVAL_IS_GCTHING(v));
48470:     l.asBits = JSVAL_BITS(v);
48470:     return JSVAL_TRACE_KIND_IMPL(l);
48470: }
  583: 
  583: struct JSTracer {
  583:     JSContext           *context;
  583:     JSTraceCallback     callback;
  583:     JSTraceNamePrinter  debugPrinter;
  583:     const void          *debugPrintArg;
  583:     size_t              debugPrintIndex;
  583: };
  583: 
  583: /*
 2228:  * The method to call on each reference to a traceable thing stored in a
  583:  * particular JSObject or other runtime structure. With DEBUG defined the
  583:  * caller before calling JS_CallTracer must initialize JSTracer fields
  602:  * describing the reference using the macros below.
  583:  */
  583: extern JS_PUBLIC_API(void)
  583: JS_CallTracer(JSTracer *trc, void *thing, uint32 kind);
  583: 
  583: /*
  583:  * Set debugging information about a reference to a traceable thing to prepare
  583:  * for the following call to JS_CallTracer.
  583:  *
  583:  * When printer is null, arg must be const char * or char * C string naming
  583:  * the reference and index must be either (size_t)-1 indicating that the name
  583:  * alone describes the reference or it must be an index into some array vector
  583:  * that stores the reference.
  583:  *
  583:  * When printer callback is not null, the arg and index arguments are
  583:  * available to the callback as debugPrinterArg and debugPrintIndex fields
  583:  * of JSTracer.
  583:  *
  583:  * The storage for name or callback's arguments needs to live only until
  583:  * the following call to JS_CallTracer returns.
  583:  */
  583: #ifdef DEBUG
  583: # define JS_SET_TRACING_DETAILS(trc, printer, arg, index)                     \
  583:     JS_BEGIN_MACRO                                                            \
  583:         (trc)->debugPrinter = (printer);                                      \
  583:         (trc)->debugPrintArg = (arg);                                         \
  583:         (trc)->debugPrintIndex = (index);                                     \
  583:     JS_END_MACRO
  583: #else
  583: # define JS_SET_TRACING_DETAILS(trc, printer, arg, index)                     \
  583:     JS_BEGIN_MACRO                                                            \
  583:     JS_END_MACRO
  583: #endif
  583: 
  583: /*
  583:  * Convenience macro to describe the argument of JS_CallTracer using C string
  583:  * and index.
  583:  */
  583: # define JS_SET_TRACING_INDEX(trc, name, index)                               \
  583:     JS_SET_TRACING_DETAILS(trc, NULL, name, index)
  583: 
  583: /*
  583:  * Convenience macro to describe the argument of JS_CallTracer using C string.
  583:  */
  583: # define JS_SET_TRACING_NAME(trc, name)                                       \
  583:     JS_SET_TRACING_DETAILS(trc, NULL, name, (size_t)-1)
  583: 
  583: /*
  583:  * Convenience macro to invoke JS_CallTracer using C string as the name for
  583:  * the reference to a traceable thing.
  583:  */
  583: # define JS_CALL_TRACER(trc, thing, kind, name)                               \
  583:     JS_BEGIN_MACRO                                                            \
  583:         JS_SET_TRACING_NAME(trc, name);                                       \
  583:         JS_CallTracer((trc), (thing), (kind));                                \
  583:     JS_END_MACRO
  583: 
  583: /*
  583:  * Convenience macros to invoke JS_CallTracer when jsval represents a
  583:  * reference to a traceable thing.
  583:  */
  583: #define JS_CALL_VALUE_TRACER(trc, val, name)                                  \
  583:     JS_BEGIN_MACRO                                                            \
  583:         if (JSVAL_IS_TRACEABLE(val)) {                                        \
  583:             JS_CALL_TRACER((trc), JSVAL_TO_GCTHING(val),                      \
  583:                            JSVAL_TRACE_KIND(val), name);                      \
  583:         }                                                                     \
  583:     JS_END_MACRO
  583: 
  583: #define JS_CALL_OBJECT_TRACER(trc, object, name)                              \
  583:     JS_BEGIN_MACRO                                                            \
  583:         JSObject *obj_ = (object);                                            \
 1091:         JS_ASSERT(obj_);                                                      \
  583:         JS_CALL_TRACER((trc), obj_, JSTRACE_OBJECT, name);                    \
  583:     JS_END_MACRO
  583: 
  583: #define JS_CALL_STRING_TRACER(trc, string, name)                              \
  583:     JS_BEGIN_MACRO                                                            \
  583:         JSString *str_ = (string);                                            \
 1091:         JS_ASSERT(str_);                                                      \
  583:         JS_CALL_TRACER((trc), str_, JSTRACE_STRING, name);                    \
  583:     JS_END_MACRO
  583: 
  583: /*
  583:  * API for JSTraceCallback implementations.
  583:  */
  583: # define JS_TRACER_INIT(trc, cx_, callback_)                                  \
  583:     JS_BEGIN_MACRO                                                            \
  583:         (trc)->context = (cx_);                                               \
  583:         (trc)->callback = (callback_);                                        \
34558:         (trc)->debugPrinter = NULL;                                           \
34558:         (trc)->debugPrintArg = NULL;                                          \
34558:         (trc)->debugPrintIndex = (size_t)-1;                                  \
  583:     JS_END_MACRO
  583: 
  583: extern JS_PUBLIC_API(void)
  615: JS_TraceChildren(JSTracer *trc, void *thing, uint32 kind);
  583: 
  786: extern JS_PUBLIC_API(void)
  786: JS_TraceRuntime(JSTracer *trc);
  786: 
  583: #ifdef DEBUG
  786: 
  583: extern JS_PUBLIC_API(void)
  583: JS_PrintTraceThingInfo(char *buf, size_t bufsize, JSTracer *trc,
  583:                        void *thing, uint32 kind, JSBool includeDetails);
  917: 
  786: /*
  917:  * DEBUG-only method to dump the object graph of heap-allocated things.
  786:  *
  917:  * fp:              file for the dump output.
  917:  * start:           when non-null, dump only things reachable from start
  917:  *                  thing. Otherwise dump all things reachable from the
  917:  *                  runtime roots.
  917:  * startKind:       trace kind of start if start is not null. Must be 0 when
  917:  *                  start is null.
  786:  * thingToFind:     dump only paths in the object graph leading to thingToFind
  786:  *                  when non-null.
  917:  * maxDepth:        the upper bound on the number of edges to descend from the
  917:  *                  graph roots.
  917:  * thingToIgnore:   thing to ignore during the graph traversal when non-null.
  786:  */
  786: extern JS_PUBLIC_API(JSBool)
  917: JS_DumpHeap(JSContext *cx, FILE *fp, void* startThing, uint32 startKind,
  917:             void *thingToFind, size_t maxDepth, void *thingToIgnore);
  917: 
  583: #endif
  583: 
  583: /*
  583:  * Garbage collector API.
  583:  */
    1: extern JS_PUBLIC_API(void)
    1: JS_GC(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_MaybeGC(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(JSGCCallback)
    1: JS_SetGCCallback(JSContext *cx, JSGCCallback cb);
    1: 
    1: extern JS_PUBLIC_API(JSGCCallback)
    1: JS_SetGCCallbackRT(JSRuntime *rt, JSGCCallback cb);
    1: 
  583: extern JS_PUBLIC_API(JSBool)
  583: JS_IsGCMarkingTracer(JSTracer *trc);
  583: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IsAboutToBeFinalized(JSContext *cx, void *thing);
    1: 
    1: typedef enum JSGCParamKey {
10985:     /* Maximum nominal heap before last ditch GC. */
10985:     JSGC_MAX_BYTES          = 0,
10985: 
32553:     /* Number of JS_malloc bytes before last ditch GC. */
32553:     JSGC_MAX_MALLOC_BYTES   = 1,
32553: 
10985:     /* Hoard stackPools for this long, in ms, default is 30 seconds. */
32553:     JSGC_STACKPOOL_LIFESPAN = 2,
32553: 
32553:     /*
32553:      * The factor that defines when the GC is invoked. The factor is a
32553:      * percent of the memory allocated by the GC after the last run of
32553:      * the GC. When the current memory allocated by the GC is more than
32553:      * this percent then the GC is invoked. The factor cannot be less
32553:      * than 100 since the current memory allocated by the GC cannot be less
32553:      * than the memory allocated after the last run of the GC.
32553:      */
32553:     JSGC_TRIGGER_FACTOR = 3,
24313: 
24313:     /* Amount of bytes allocated by the GC. */
32553:     JSGC_BYTES = 4,
24313: 
24313:     /* Number of times when GC was invoked. */
32553:     JSGC_NUMBER = 5,
27884: 
27884:     /* Max size of the code cache in bytes. */
32553:     JSGC_MAX_CODE_CACHE_BYTES = 6
    1: } JSGCParamKey;
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetGCParameter(JSRuntime *rt, JSGCParamKey key, uint32 value);
    1: 
24313: extern JS_PUBLIC_API(uint32)
24313: JS_GetGCParameter(JSRuntime *rt, JSGCParamKey key);
24313: 
27884: extern JS_PUBLIC_API(void)
27884: JS_SetGCParameterForThread(JSContext *cx, JSGCParamKey key, uint32 value);
27884: 
27884: extern JS_PUBLIC_API(uint32)
27884: JS_GetGCParameterForThread(JSContext *cx, JSGCParamKey key);
27884: 
    1: /*
36712:  * Flush the code cache for the current thread. The operation might be
36712:  * delayed if the cache cannot be flushed currently because native
36712:  * code is currently executing.
36712:  */
36712: 
36712: extern JS_PUBLIC_API(void)
36712: JS_FlushCaches(JSContext *cx);
36712: 
36712: /*
    1:  * Add a finalizer for external strings created by JS_NewExternalString (see
    1:  * below) using a type-code returned from this function, and that understands
    1:  * how to free or release the memory pointed at by JS_GetStringChars(str).
    1:  *
    1:  * Return a nonnegative type index if there is room for finalizer in the
    1:  * global GC finalizers table, else return -1.  If the engine is compiled
    1:  * JS_THREADSAFE and used in a multi-threaded environment, this function must
    1:  * be invoked on the primordial thread only, at startup -- or else the entire
    1:  * program must single-thread itself while loading a module that calls this
    1:  * function.
    1:  */
    1: extern JS_PUBLIC_API(intN)
    1: JS_AddExternalStringFinalizer(JSStringFinalizeOp finalizer);
    1: 
    1: /*
    1:  * Remove finalizer from the global GC finalizers table, returning its type
    1:  * code if found, -1 if not found.
    1:  *
    1:  * As with JS_AddExternalStringFinalizer, there is a threading restriction
    1:  * if you compile the engine JS_THREADSAFE: this function may be called for a
    1:  * given finalizer pointer on only one thread; different threads may call to
    1:  * remove distinct finalizers safely.
    1:  *
    1:  * You must ensure that all strings with finalizer's type have been collected
    1:  * before calling this function.  Otherwise, string data will be leaked by the
    1:  * GC, for want of a finalizer to call.
    1:  */
    1: extern JS_PUBLIC_API(intN)
    1: JS_RemoveExternalStringFinalizer(JSStringFinalizeOp finalizer);
    1: 
    1: /*
    1:  * Create a new JSString whose chars member refers to external memory, i.e.,
48470:  * memory requiring spe, type-specific finalization.  The type code must
    1:  * be a nonnegative return value from JS_AddExternalStringFinalizer.
    1:  */
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_NewExternalString(JSContext *cx, jschar *chars, size_t length, intN type);
    1: 
    1: /*
    1:  * Returns the external-string finalizer index for this string, or -1 if it is
    1:  * an "internal" (native to JS engine) string.
    1:  */
    1: extern JS_PUBLIC_API(intN)
    1: JS_GetExternalStringGCType(JSRuntime *rt, JSString *str);
    1: 
    1: /*
42740:  * Deprecated. Use JS_SetNativeStackQuoata instead.
    1:  */
    1: extern JS_PUBLIC_API(void)
    1: JS_SetThreadStackLimit(JSContext *cx, jsuword limitAddr);
    1: 
 5344: /*
42740:  * Set the size of the native stack that should not be exceed. To disable
42740:  * stack size checking pass 0.
42740:  */
42740: extern JS_PUBLIC_API(void)
42740: JS_SetNativeStackQuota(JSContext *cx, size_t stackSize);
42740: 
42740: 
42740: /*
 5344:  * Set the quota on the number of bytes that stack-like data structures can
 5344:  * use when the runtime compiles and executes scripts. These structures
 5344:  * consume heap space, so JS_SetThreadStackLimit does not bound their size.
 5344:  * The default quota is 32MB which is quite generous.
 5344:  *
 5344:  * The function must be called before any script compilation or execution API
 5344:  * calls, i.e. either immediately after JS_NewContext or from JSCONTEXT_NEW
 5344:  * context callback.
 5344:  */
 5344: extern JS_PUBLIC_API(void)
 5344: JS_SetScriptStackQuota(JSContext *cx, size_t quota);
 5344: 
 5344: #define JS_DEFAULT_SCRIPT_STACK_QUOTA   ((size_t) 0x2000000)
 5344: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Classes, objects, and properties.
    1:  */
48622: typedef void (*JSClassInternal)();
    1: 
    1: /* For detailed comments on the function pointer types, see jspubtd.h. */
    1: struct JSClass {
48623:     const char          *name;
48623:     uint32              flags;
48623: 
48623:     /* Mandatory non-null function pointer members. */
48623:     JSPropertyOp        addProperty;
48623:     JSPropertyOp        delProperty;
48623:     JSPropertyOp        getProperty;
48623:     JSPropertyOp        setProperty;
48623:     JSEnumerateOp       enumerate;
48623:     JSResolveOp         resolve;
48623:     JSConvertOp         convert;
48623:     JSFinalizeOp        finalize;
48623: 
48623:     /* Optionally non-null members start here. */
48623:     JSClassInternal     reserved0;
48623:     JSCheckAccessOp     checkAccess;
48623:     JSNative            call;
48623:     JSNative            construct;
48623:     JSXDRObjectOp       xdrObject;
48623:     JSHasInstanceOp     hasInstance;
    1:     JSMarkOp            mark;
48622: 
48622:     JSClassInternal     reserved1;
48622:     void                *reserved[19];
    1: };
    1: 
    1: #define JSCLASS_HAS_PRIVATE             (1<<0)  /* objects have private slot */
    1: #define JSCLASS_NEW_ENUMERATE           (1<<1)  /* has JSNewEnumerateOp hook */
    1: #define JSCLASS_NEW_RESOLVE             (1<<2)  /* has JSNewResolveOp hook */
    1: #define JSCLASS_PRIVATE_IS_NSISUPPORTS  (1<<3)  /* private is (nsISupports *) */
    1: #define JSCLASS_NEW_RESOLVE_GETS_START  (1<<5)  /* JSNewResolveOp gets starting
    1:                                                    object in prototype chain
    1:                                                    passed in via *objp in/out
    1:                                                    parameter */
    1: #define JSCLASS_CONSTRUCT_PROTOTYPE     (1<<6)  /* call constructor on class
    1:                                                    prototype */
    1: #define JSCLASS_DOCUMENT_OBSERVER       (1<<7)  /* DOM document observer */
    1: 
    1: /*
    1:  * To reserve slots fetched and stored via JS_Get/SetReservedSlot, bitwise-or
    1:  * JSCLASS_HAS_RESERVED_SLOTS(n) into the initializer for JSClass.flags, where
    1:  * n is a constant in [1, 255].  Reserved slots are indexed from 0 to n-1.
    1:  */
    1: #define JSCLASS_RESERVED_SLOTS_SHIFT    8       /* room for 8 flags below */
    1: #define JSCLASS_RESERVED_SLOTS_WIDTH    8       /* and 16 above this field */
    1: #define JSCLASS_RESERVED_SLOTS_MASK     JS_BITMASK(JSCLASS_RESERVED_SLOTS_WIDTH)
    1: #define JSCLASS_HAS_RESERVED_SLOTS(n)   (((n) & JSCLASS_RESERVED_SLOTS_MASK)  \
    1:                                          << JSCLASS_RESERVED_SLOTS_SHIFT)
    1: #define JSCLASS_RESERVED_SLOTS(clasp)   (((clasp)->flags                      \
    1:                                           >> JSCLASS_RESERVED_SLOTS_SHIFT)    \
    1:                                          & JSCLASS_RESERVED_SLOTS_MASK)
    1: 
    1: #define JSCLASS_HIGH_FLAGS_SHIFT        (JSCLASS_RESERVED_SLOTS_SHIFT +       \
    1:                                          JSCLASS_RESERVED_SLOTS_WIDTH)
    1: 
48622: #define JSCLASS_INTERNAL_FLAG1          (1<<(JSCLASS_HIGH_FLAGS_SHIFT+0))
    1: #define JSCLASS_IS_ANONYMOUS            (1<<(JSCLASS_HIGH_FLAGS_SHIFT+1))
    1: #define JSCLASS_IS_GLOBAL               (1<<(JSCLASS_HIGH_FLAGS_SHIFT+2))
    1: 
  602: /* Indicates that JSClass.mark is a tracer with JSTraceOp type. */
  583: #define JSCLASS_MARK_IS_TRACE           (1<<(JSCLASS_HIGH_FLAGS_SHIFT+3))
48622: #define JSCLASS_INTERNAL_FLAG2          (1<<(JSCLASS_HIGH_FLAGS_SHIFT+4))
48529: 
56574: /* Indicate whether the proto or ctor should be frozen. */
56574: #define JSCLASS_FREEZE_PROTO            (1<<(JSCLASS_HIGH_FLAGS_SHIFT+5))
56574: #define JSCLASS_FREEZE_CTOR             (1<<(JSCLASS_HIGH_FLAGS_SHIFT+6))
56574: 
51090: /* Additional global reserved slots, beyond those for standard prototypes. */
55606: #define JSRESERVED_GLOBAL_SLOTS_COUNT     3
55606: #define JSRESERVED_GLOBAL_THIS            (JSProto_LIMIT * 3)
51090: #define JSRESERVED_GLOBAL_THROWTYPEERROR  (JSRESERVED_GLOBAL_THIS + 1)
53858: #define JSRESERVED_GLOBAL_REGEXP_STATICS  (JSRESERVED_GLOBAL_THROWTYPEERROR + 1)
51090: 
    1: /*
    1:  * ECMA-262 requires that most constructors used internally create objects
    1:  * with "the original Foo.prototype value" as their [[Prototype]] (__proto__)
    1:  * member initial value.  The "original ... value" verbiage is there because
    1:  * in ECMA-262, global properties naming class objects are read/write and
    1:  * deleteable, for the most part.
    1:  *
    1:  * Implementing this efficiently requires that global objects have classes
42772:  * with the following flags. Failure to use JSCLASS_GLOBAL_FLAGS was
42772:  * prevously allowed, but is now an ES5 violation and thus unsupported.
    1:  */
    1: #define JSCLASS_GLOBAL_FLAGS                                                  \
51090:     (JSCLASS_IS_GLOBAL |                                                      \
51090:      JSCLASS_HAS_RESERVED_SLOTS(JSProto_LIMIT * 3 + JSRESERVED_GLOBAL_SLOTS_COUNT))
    1: 
    1: /* Fast access to the original value of each standard class's prototype. */
    1: #define JSCLASS_CACHED_PROTO_SHIFT      (JSCLASS_HIGH_FLAGS_SHIFT + 8)
    1: #define JSCLASS_CACHED_PROTO_WIDTH      8
    1: #define JSCLASS_CACHED_PROTO_MASK       JS_BITMASK(JSCLASS_CACHED_PROTO_WIDTH)
    1: #define JSCLASS_HAS_CACHED_PROTO(key)   ((key) << JSCLASS_CACHED_PROTO_SHIFT)
 3164: #define JSCLASS_CACHED_PROTO_KEY(clasp) ((JSProtoKey)                         \
 3164:                                          (((clasp)->flags                     \
    1:                                            >> JSCLASS_CACHED_PROTO_SHIFT)     \
 3164:                                           & JSCLASS_CACHED_PROTO_MASK))
    1: 
    1: /* Initializer for unused members of statically initialized JSClass structs. */
48622: #define JSCLASS_NO_INTERNAL_MEMBERS     0,{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
48622: #define JSCLASS_NO_OPTIONAL_MEMBERS     0,0,0,0,0,0,0,JSCLASS_NO_INTERNAL_MEMBERS
    1: 
    1: struct JSIdArray {
    1:     jsint length;
    1:     jsid  vector[1];    /* actually, length jsid words */
    1: };
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_DestroyIdArray(JSContext *cx, JSIdArray *ida);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ValueToId(JSContext *cx, jsval v, jsid *idp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IdToValue(JSContext *cx, jsid id, jsval *vp);
    1: 
    1: /*
    1:  * JSNewResolveOp flag bits.
    1:  */
    1: #define JSRESOLVE_QUALIFIED     0x01    /* resolve a qualified property id */
    1: #define JSRESOLVE_ASSIGNING     0x02    /* resolve on the left of assignment */
    1: #define JSRESOLVE_DETECTING     0x04    /* 'if (o.p)...' or '(o.p) ?...:...' */
    1: #define JSRESOLVE_DECLARING     0x08    /* var, const, or function prolog op */
    1: #define JSRESOLVE_CLASSNAME     0x10    /* class name used when constructing */
23435: #define JSRESOLVE_WITH          0x20    /* resolve inside a with statement */
    1: 
    1: extern JS_PUBLIC_API(JSBool)
48470: JS_PropertyStub(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_EnumerateStub(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
48470: JS_ResolveStub(JSContext *cx, JSObject *obj, jsid id);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ConvertStub(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_FinalizeStub(JSContext *cx, JSObject *obj);
    1: 
    1: struct JSConstDoubleSpec {
    1:     jsdouble        dval;
    1:     const char      *name;
    1:     uint8           flags;
    1:     uint8           spare[3];
    1: };
    1: 
    1: /*
    1:  * To define an array element rather than a named property member, cast the
    1:  * element's index to (const char *) and initialize name with it, and set the
    1:  * JSPROP_INDEX bit in flags.
    1:  */
    1: struct JSPropertySpec {
    1:     const char      *name;
    1:     int8            tinyid;
    1:     uint8           flags;
    1:     JSPropertyOp    getter;
    1:     JSPropertyOp    setter;
    1: };
    1: 
    1: struct JSFunctionSpec {
    1:     const char      *name;
    1:     JSNative        call;
    1:     uint16          nargs;
    1:     uint16          flags;
    1: };
    1: 
 4127: /*
 4127:  * Terminating sentinel initializer to put at the end of a JSFunctionSpec array
 4127:  * that's passed to JS_DefineFunctions or JS_InitClass.
 4127:  */
53557: #define JS_FS_END JS_FS(NULL,NULL,0,0)
 4127: 
 4127: /*
53557:  * Initializer macros for a JSFunctionSpec array element. JS_FN (whose name
53557:  * pays homage to the old JSNative/JSFastNative split) simply adds the flag
53557:  * JSFUN_STUB_GSOPS.
 4127:  */
53557: #define JS_FS(name,call,nargs,flags)                                          \
53557:     {name, call, nargs, flags}
53557: #define JS_FN(name,call,nargs,flags)                                          \
53557:     {name, call, nargs, (flags) | JSFUN_STUB_GSOPS}
 4127: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_InitClass(JSContext *cx, JSObject *obj, JSObject *parent_proto,
    1:              JSClass *clasp, JSNative constructor, uintN nargs,
    1:              JSPropertySpec *ps, JSFunctionSpec *fs,
    1:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs);
    1: 
    1: #ifdef JS_THREADSAFE
    1: extern JS_PUBLIC_API(JSClass *)
    1: JS_GetClass(JSContext *cx, JSObject *obj);
    1: 
    1: #define JS_GET_CLASS(cx,obj) JS_GetClass(cx, obj)
    1: #else
    1: extern JS_PUBLIC_API(JSClass *)
    1: JS_GetClass(JSObject *obj);
    1: 
    1: #define JS_GET_CLASS(cx,obj) JS_GetClass(obj)
    1: #endif
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_InstanceOf(JSContext *cx, JSObject *obj, JSClass *clasp, jsval *argv);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
    1: 
    1: extern JS_PUBLIC_API(void *)
    1: JS_GetPrivate(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetPrivate(JSContext *cx, JSObject *obj, void *data);
    1: 
    1: extern JS_PUBLIC_API(void *)
    1: JS_GetInstancePrivate(JSContext *cx, JSObject *obj, JSClass *clasp,
    1:                       jsval *argv);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetPrototype(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetPrototype(JSContext *cx, JSObject *obj, JSObject *proto);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetParent(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetParent(JSContext *cx, JSObject *obj, JSObject *parent);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetConstructor(JSContext *cx, JSObject *proto);
    1: 
    1: /*
    1:  * Get a unique identifier for obj, good for the lifetime of obj (even if it
    1:  * is moved by a copying GC).  Return false on failure (likely out of memory),
    1:  * and true with *idp containing the unique id on success.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetObjectId(JSContext *cx, JSObject *obj, jsid *idp);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
43286: JS_NewGlobalObject(JSContext *cx, JSClass *clasp);
43286: 
43286: extern JS_PUBLIC_API(JSObject *)
47516: JS_NewCompartmentAndGlobalObject(JSContext *cx, JSClass *clasp, JSPrincipals *principals);
47498: 
47498: extern JS_PUBLIC_API(JSObject *)
    1: JS_NewObject(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent);
    1: 
54565: /* Queries the [[Extensible]] property of the object. */
54565: extern JS_PUBLIC_API(JSBool)
54565: JS_IsExtensible(JSObject *obj);
54565: 
11700: /*
11700:  * Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default
11700:  * proto if proto's actual parameter value is null.
11700:  */
11700: extern JS_PUBLIC_API(JSObject *)
11700: JS_NewObjectWithGivenProto(JSContext *cx, JSClass *clasp, JSObject *proto,
11700:                            JSObject *parent);
11700: 
54563: /*
54563:  * Freeze obj, and all objects it refers to, recursively. This will not recurse
54563:  * through non-extensible objects, on the assumption that those are already
54563:  * deep-frozen.
54563:  */
    1: extern JS_PUBLIC_API(JSBool)
54563: JS_DeepFreezeObject(JSContext *cx, JSObject *obj);
54563: 
54563: /*
54563:  * Freezes an object; see ES5's Object.freeze(obj) method.
54563:  */
54563: extern JS_PUBLIC_API(JSBool)
54563: JS_FreezeObject(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_ConstructObject(JSContext *cx, JSClass *clasp, JSObject *proto,
    1:                    JSObject *parent);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_ConstructObjectWithArguments(JSContext *cx, JSClass *clasp, JSObject *proto,
    1:                                 JSObject *parent, uintN argc, jsval *argv);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
40293: JS_New(JSContext *cx, JSObject *ctor, uintN argc, jsval *argv);
40293: 
40293: extern JS_PUBLIC_API(JSObject *)
    1: JS_DefineObject(JSContext *cx, JSObject *obj, const char *name, JSClass *clasp,
    1:                 JSObject *proto, uintN attrs);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_DefineConstDoubles(JSContext *cx, JSObject *obj, JSConstDoubleSpec *cds);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_DefineProperties(JSContext *cx, JSObject *obj, JSPropertySpec *ps);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_DefineProperty(JSContext *cx, JSObject *obj, const char *name, jsval value,
    1:                   JSPropertyOp getter, JSPropertyOp setter, uintN attrs);
    1: 
20964: extern JS_PUBLIC_API(JSBool)
20964: JS_DefinePropertyById(JSContext *cx, JSObject *obj, jsid id, jsval value,
20964:                       JSPropertyOp getter, JSPropertyOp setter, uintN attrs);
20964: 
40356: extern JS_PUBLIC_API(JSBool)
40356: JS_DefineOwnProperty(JSContext *cx, JSObject *obj, jsid id, jsval descriptor, JSBool *bp);
40356: 
    1: /*
    1:  * Determine the attributes (JSPROP_* flags) of a property on a given object.
    1:  *
    1:  * If the object does not have a property by that name, *foundp will be
    1:  * JS_FALSE and the value of *attrsp is undefined.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyAttributes(JSContext *cx, JSObject *obj, const char *name,
    1:                          uintN *attrsp, JSBool *foundp);
    1: 
    1: /*
    1:  * The same, but if the property is native, return its getter and setter via
    1:  * *getterp and *setterp, respectively (and only if the out parameter pointer
    1:  * is not null).
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj,
    1:                                    const char *name,
    1:                                    uintN *attrsp, JSBool *foundp,
    1:                                    JSPropertyOp *getterp,
    1:                                    JSPropertyOp *setterp);
    1: 
24145: extern JS_PUBLIC_API(JSBool)
24145: JS_GetPropertyAttrsGetterAndSetterById(JSContext *cx, JSObject *obj,
24145:                                        jsid id,
24145:                                        uintN *attrsp, JSBool *foundp,
24145:                                        JSPropertyOp *getterp,
24145:                                        JSPropertyOp *setterp);
24145: 
    1: /*
    1:  * Set the attributes of a property on a given object.
    1:  *
    1:  * If the object does not have a property by that name, *foundp will be
    1:  * JS_FALSE and nothing will be altered.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetPropertyAttributes(JSContext *cx, JSObject *obj, const char *name,
    1:                          uintN attrs, JSBool *foundp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_DefinePropertyWithTinyId(JSContext *cx, JSObject *obj, const char *name,
    1:                             int8 tinyid, jsval value,
    1:                             JSPropertyOp getter, JSPropertyOp setter,
    1:                             uintN attrs);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_AliasProperty(JSContext *cx, JSObject *obj, const char *name,
    1:                  const char *alias);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
 7927: JS_AlreadyHasOwnProperty(JSContext *cx, JSObject *obj, const char *name,
 7927:                          JSBool *foundp);
 7927: 
 7927: extern JS_PUBLIC_API(JSBool)
20964: JS_AlreadyHasOwnPropertyById(JSContext *cx, JSObject *obj, jsid id,
20964:                              JSBool *foundp);
20964: 
20964: extern JS_PUBLIC_API(JSBool)
    1: JS_HasProperty(JSContext *cx, JSObject *obj, const char *name, JSBool *foundp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
20964: JS_HasPropertyById(JSContext *cx, JSObject *obj, jsid id, JSBool *foundp);
20964: 
20964: extern JS_PUBLIC_API(JSBool)
    1: JS_LookupProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
20964: JS_LookupPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
20964: 
20964: extern JS_PUBLIC_API(JSBool)
    1: JS_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, const char *name,
    1:                            uintN flags, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
20964: JS_LookupPropertyWithFlagsById(JSContext *cx, JSObject *obj, jsid id,
19712:                                uintN flags, JSObject **objp, jsval *vp);
19712: 
26022: struct JSPropertyDescriptor {
26022:     JSObject     *obj;
26022:     uintN        attrs;
26022:     JSPropertyOp getter;
26022:     JSPropertyOp setter;
48470:     jsval        value;
42733:     uintN        shortid;
26022: };
26022: 
26022: /*
26022:  * Like JS_GetPropertyAttrsGetterAndSetterById but will return a property on
26022:  * an object on the prototype chain (returned in objp). If data->obj is null,
26022:  * then this property was not found on the prototype chain.
26022:  */
26022: extern JS_PUBLIC_API(JSBool)
26022: JS_GetPropertyDescriptorById(JSContext *cx, JSObject *obj, jsid id, uintN flags,
26022:                              JSPropertyDescriptor *desc);
26022: 
19712: extern JS_PUBLIC_API(JSBool)
40356: JS_GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
40356: 
40356: extern JS_PUBLIC_API(JSBool)
    1: JS_GetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
56211: JS_GetPropertyDefault(JSContext *cx, JSObject *obj, const char *name, jsval def, jsval *vp);
56211: 
56211: extern JS_PUBLIC_API(JSBool)
20964: JS_GetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
20964: 
20964: extern JS_PUBLIC_API(JSBool)
56211: JS_GetPropertyByIdDefault(JSContext *cx, JSObject *obj, jsid id, jsval def, jsval *vp);
56211: 
56211: extern JS_PUBLIC_API(JSBool)
    1: JS_GetMethodById(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                  jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetMethod(JSContext *cx, JSObject *obj, const char *name, JSObject **objp,
    1:              jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
20964: JS_SetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
20964: 
20964: extern JS_PUBLIC_API(JSBool)
    1: JS_DeleteProperty(JSContext *cx, JSObject *obj, const char *name);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_DeleteProperty2(JSContext *cx, JSObject *obj, const char *name,
    1:                    jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
20964: JS_DeletePropertyById(JSContext *cx, JSObject *obj, jsid id);
20964: 
20964: extern JS_PUBLIC_API(JSBool)
20964: JS_DeletePropertyById2(JSContext *cx, JSObject *obj, jsid id, jsval *rval);
20964: 
20964: extern JS_PUBLIC_API(JSBool)
    1: JS_DefineUCProperty(JSContext *cx, JSObject *obj,
    1:                     const jschar *name, size_t namelen, jsval value,
    1:                     JSPropertyOp getter, JSPropertyOp setter,
    1:                     uintN attrs);
    1: 
    1: /*
    1:  * Determine the attributes (JSPROP_* flags) of a property on a given object.
    1:  *
    1:  * If the object does not have a property by that name, *foundp will be
    1:  * JS_FALSE and the value of *attrsp is undefined.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetUCPropertyAttributes(JSContext *cx, JSObject *obj,
    1:                            const jschar *name, size_t namelen,
    1:                            uintN *attrsp, JSBool *foundp);
    1: 
    1: /*
    1:  * The same, but if the property is native, return its getter and setter via
    1:  * *getterp and *setterp, respectively (and only if the out parameter pointer
    1:  * is not null).
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetUCPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj,
    1:                                      const jschar *name, size_t namelen,
    1:                                      uintN *attrsp, JSBool *foundp,
    1:                                      JSPropertyOp *getterp,
    1:                                      JSPropertyOp *setterp);
    1: 
    1: /*
    1:  * Set the attributes of a property on a given object.
    1:  *
    1:  * If the object does not have a property by that name, *foundp will be
    1:  * JS_FALSE and nothing will be altered.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetUCPropertyAttributes(JSContext *cx, JSObject *obj,
    1:                            const jschar *name, size_t namelen,
    1:                            uintN attrs, JSBool *foundp);
    1: 
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_DefineUCPropertyWithTinyId(JSContext *cx, JSObject *obj,
    1:                               const jschar *name, size_t namelen,
    1:                               int8 tinyid, jsval value,
    1:                               JSPropertyOp getter, JSPropertyOp setter,
    1:                               uintN attrs);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
 7927: JS_AlreadyHasOwnUCProperty(JSContext *cx, JSObject *obj, const jschar *name,
 7927:                            size_t namelen, JSBool *foundp);
 7927: 
 7927: extern JS_PUBLIC_API(JSBool)
    1: JS_HasUCProperty(JSContext *cx, JSObject *obj,
    1:                  const jschar *name, size_t namelen,
    1:                  JSBool *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_LookupUCProperty(JSContext *cx, JSObject *obj,
    1:                     const jschar *name, size_t namelen,
    1:                     jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetUCProperty(JSContext *cx, JSObject *obj,
    1:                  const jschar *name, size_t namelen,
    1:                  jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetUCProperty(JSContext *cx, JSObject *obj,
    1:                  const jschar *name, size_t namelen,
    1:                  jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_DeleteUCProperty2(JSContext *cx, JSObject *obj,
    1:                      const jschar *name, size_t namelen,
    1:                      jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_NewArrayObject(JSContext *cx, jsint length, jsval *vector);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IsArrayObject(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetArrayLength(JSContext *cx, JSObject *obj, jsuint *lengthp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetArrayLength(JSContext *cx, JSObject *obj, jsuint length);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_HasArrayLength(JSContext *cx, JSObject *obj, jsuint *lengthp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_DefineElement(JSContext *cx, JSObject *obj, jsint index, jsval value,
    1:                  JSPropertyOp getter, JSPropertyOp setter, uintN attrs);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_AliasElement(JSContext *cx, JSObject *obj, const char *name, jsint alias);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
 7927: JS_AlreadyHasOwnElement(JSContext *cx, JSObject *obj, jsint index,
 7927:                         JSBool *foundp);
 7927: 
 7927: extern JS_PUBLIC_API(JSBool)
    1: JS_HasElement(JSContext *cx, JSObject *obj, jsint index, JSBool *foundp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_LookupElement(JSContext *cx, JSObject *obj, jsint index, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetElement(JSContext *cx, JSObject *obj, jsint index, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetElement(JSContext *cx, JSObject *obj, jsint index, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_DeleteElement(JSContext *cx, JSObject *obj, jsint index);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_DeleteElement2(JSContext *cx, JSObject *obj, jsint index, jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_ClearScope(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(JSIdArray *)
    1: JS_Enumerate(JSContext *cx, JSObject *obj);
    1: 
    1: /*
    1:  * Create an object to iterate over enumerable properties of obj, in arbitrary
    1:  * property definition order.  NB: This differs from longstanding for..in loop
    1:  * order, which uses order of property definition in obj.
    1:  */
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_NewPropertyIterator(JSContext *cx, JSObject *obj);
    1: 
    1: /*
    1:  * Return true on success with *idp containing the id of the next enumerable
48470:  * property to visit using iterobj, or JSID_IS_VOID if there is no such property
    1:  * left to visit.  Return false on error.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_NextProperty(JSContext *cx, JSObject *iterobj, jsid *idp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
    1:                jsval *vp, uintN *attrsp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval v);
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Security protocol.
    1:  */
    1: struct JSPrincipals {
    1:     char *codebase;
    1: 
    1:     /* XXX unspecified and unused by Mozilla code -- can we remove these? */
18907:     void * (* getPrincipalArray)(JSContext *cx, JSPrincipals *);
18907:     JSBool (* globalPrivilegesEnabled)(JSContext *cx, JSPrincipals *);
    1: 
    1:     /* Don't call "destroy"; use reference counting macros below. */
    1:     jsrefcount refcount;
    1: 
18907:     void   (* destroy)(JSContext *cx, JSPrincipals *);
18907:     JSBool (* subsume)(JSPrincipals *, JSPrincipals *);
    1: };
    1: 
    1: #ifdef JS_THREADSAFE
    1: #define JSPRINCIPALS_HOLD(cx, principals)   JS_HoldPrincipals(cx,principals)
    1: #define JSPRINCIPALS_DROP(cx, principals)   JS_DropPrincipals(cx,principals)
    1: 
    1: extern JS_PUBLIC_API(jsrefcount)
    1: JS_HoldPrincipals(JSContext *cx, JSPrincipals *principals);
    1: 
    1: extern JS_PUBLIC_API(jsrefcount)
    1: JS_DropPrincipals(JSContext *cx, JSPrincipals *principals);
    1: 
    1: #else
    1: #define JSPRINCIPALS_HOLD(cx, principals)   (++(principals)->refcount)
    1: #define JSPRINCIPALS_DROP(cx, principals)                                     \
    1:     ((--(principals)->refcount == 0)                                          \
    1:      ? ((*(principals)->destroy)((cx), (principals)), 0)                      \
    1:      : (principals)->refcount)
    1: #endif
    1: 
18870: 
18870: struct JSSecurityCallbacks {
18870:     JSCheckAccessOp            checkObjectAccess;
18870:     JSPrincipalsTranscoder     principalsTranscoder;
18870:     JSObjectPrincipalsFinder   findObjectPrincipals;
39061:     JSCSPEvalChecker           contentSecurityPolicyAllows;
18870: };
18870: 
18870: extern JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_SetRuntimeSecurityCallbacks(JSRuntime *rt, JSSecurityCallbacks *callbacks);
18870: 
18870: extern JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_GetRuntimeSecurityCallbacks(JSRuntime *rt);
18870: 
18870: extern JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_SetContextSecurityCallbacks(JSContext *cx, JSSecurityCallbacks *callbacks);
18870: 
18870: extern JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_GetSecurityCallbacks(JSContext *cx);
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Functions and scripts.
    1:  */
    1: extern JS_PUBLIC_API(JSFunction *)
    1: JS_NewFunction(JSContext *cx, JSNative call, uintN nargs, uintN flags,
    1:                JSObject *parent, const char *name);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetFunctionObject(JSFunction *fun);
    1: 
    1: /*
    1:  * Deprecated, useful only for diagnostics.  Use JS_GetFunctionId instead for
    1:  * anonymous vs. "anonymous" disambiguation and Unicode fidelity.
    1:  */
    1: extern JS_PUBLIC_API(const char *)
    1: JS_GetFunctionName(JSFunction *fun);
    1: 
    1: /*
    1:  * Return the function's identifier as a JSString, or null if fun is unnamed.
    1:  * The returned string lives as long as fun, so you don't need to root a saved
    1:  * reference to it if fun is well-connected or rooted, and provided you bound
    1:  * the use of the saved reference by fun's lifetime.
    1:  *
    1:  * Prefer JS_GetFunctionId over JS_GetFunctionName because it returns null for
    1:  * truly anonymous functions, and because it doesn't chop to ISO-Latin-1 chars
    1:  * from UTF-16-ish jschars.
    1:  */
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_GetFunctionId(JSFunction *fun);
    1: 
    1: /*
    1:  * Return JSFUN_* flags for fun.
    1:  */
    1: extern JS_PUBLIC_API(uintN)
    1: JS_GetFunctionFlags(JSFunction *fun);
    1: 
    1: /*
    1:  * Return the arity (length) of fun.
    1:  */
    1: extern JS_PUBLIC_API(uint16)
    1: JS_GetFunctionArity(JSFunction *fun);
    1: 
    1: /*
    1:  * Infallible predicate to test whether obj is a function object (faster than
    1:  * comparing obj's class name to "Function", but equivalent unless someone has
    1:  * overwritten the "Function" identifier with a different constructor and then
    1:  * created instances using that constructor that might be passed in as obj).
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ObjectIsFunction(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_DefineFunctions(JSContext *cx, JSObject *obj, JSFunctionSpec *fs);
    1: 
    1: extern JS_PUBLIC_API(JSFunction *)
    1: JS_DefineFunction(JSContext *cx, JSObject *obj, const char *name, JSNative call,
    1:                   uintN nargs, uintN attrs);
    1: 
    1: extern JS_PUBLIC_API(JSFunction *)
    1: JS_DefineUCFunction(JSContext *cx, JSObject *obj,
    1:                     const jschar *name, size_t namelen, JSNative call,
    1:                     uintN nargs, uintN attrs);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_CloneFunctionObject(JSContext *cx, JSObject *funobj, JSObject *parent);
    1: 
    1: /*
    1:  * Given a buffer, return JS_FALSE if the buffer might become a valid
    1:  * javascript statement with the addition of more lines.  Otherwise return
    1:  * JS_TRUE.  The intent is to support interactive compilation - accumulate
    1:  * lines in a buffer until JS_BufferIsCompilableUnit is true, then pass it to
    1:  * the compiler.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_BufferIsCompilableUnit(JSContext *cx, JSObject *obj,
    1:                           const char *bytes, size_t length);
    1: 
    1: /*
    1:  * The JSScript objects returned by the following functions refer to string and
    1:  * other kinds of literals, including doubles and RegExp objects.  These
    1:  * literals are vulnerable to garbage collection; to root script objects and
    1:  * prevent literals from being collected, create a rootable object using
    1:  * JS_NewScriptObject, and root the resulting object using JS_Add[Named]Root.
    1:  */
    1: extern JS_PUBLIC_API(JSScript *)
    1: JS_CompileScript(JSContext *cx, JSObject *obj,
    1:                  const char *bytes, size_t length,
    1:                  const char *filename, uintN lineno);
    1: 
    1: extern JS_PUBLIC_API(JSScript *)
    1: JS_CompileScriptForPrincipals(JSContext *cx, JSObject *obj,
    1:                               JSPrincipals *principals,
    1:                               const char *bytes, size_t length,
    1:                               const char *filename, uintN lineno);
    1: 
    1: extern JS_PUBLIC_API(JSScript *)
    1: JS_CompileUCScript(JSContext *cx, JSObject *obj,
    1:                    const jschar *chars, size_t length,
    1:                    const char *filename, uintN lineno);
    1: 
    1: extern JS_PUBLIC_API(JSScript *)
    1: JS_CompileUCScriptForPrincipals(JSContext *cx, JSObject *obj,
    1:                                 JSPrincipals *principals,
    1:                                 const jschar *chars, size_t length,
    1:                                 const char *filename, uintN lineno);
    1: 
    1: extern JS_PUBLIC_API(JSScript *)
53848: JS_CompileUCScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
53848:                                        JSPrincipals *principals,
53848:                                        const jschar *chars, size_t length,
53848:                                        const char *filename, uintN lineno,
53848:                                        JSVersion version);
53848: 
53848: extern JS_PUBLIC_API(JSScript *)
    1: JS_CompileFile(JSContext *cx, JSObject *obj, const char *filename);
    1: 
    1: extern JS_PUBLIC_API(JSScript *)
    1: JS_CompileFileHandle(JSContext *cx, JSObject *obj, const char *filename,
    1:                      FILE *fh);
    1: 
    1: extern JS_PUBLIC_API(JSScript *)
    1: JS_CompileFileHandleForPrincipals(JSContext *cx, JSObject *obj,
    1:                                   const char *filename, FILE *fh,
    1:                                   JSPrincipals *principals);
    1: 
    1: /*
    1:  * NB: you must use JS_NewScriptObject and root a pointer to its return value
    1:  * in order to keep a JSScript and its atoms safe from garbage collection after
    1:  * creating the script via JS_Compile* and before a JS_ExecuteScript* call.
    1:  * E.g., and without error checks:
    1:  *
    1:  *    JSScript *script = JS_CompileFile(cx, global, filename);
    1:  *    JSObject *scrobj = JS_NewScriptObject(cx, script);
47403:  *    JS_AddNamedObjectRoot(cx, &scrobj, "scrobj");
    1:  *    do {
    1:  *        jsval result;
    1:  *        JS_ExecuteScript(cx, global, script, &result);
    1:  *        JS_GC();
    1:  *    } while (!JSVAL_IS_BOOLEAN(result) || JSVAL_TO_BOOLEAN(result));
47403:  *    JS_RemoveObjectRoot(cx, &scrobj);
    1:  */
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_NewScriptObject(JSContext *cx, JSScript *script);
    1: 
    1: /*
    1:  * Infallible getter for a script's object.  If JS_NewScriptObject has not been
    1:  * called on script yet, the return value will be null.
    1:  */
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetScriptObject(JSScript *script);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_DestroyScript(JSContext *cx, JSScript *script);
    1: 
    1: extern JS_PUBLIC_API(JSFunction *)
    1: JS_CompileFunction(JSContext *cx, JSObject *obj, const char *name,
    1:                    uintN nargs, const char **argnames,
    1:                    const char *bytes, size_t length,
    1:                    const char *filename, uintN lineno);
    1: 
    1: extern JS_PUBLIC_API(JSFunction *)
    1: JS_CompileFunctionForPrincipals(JSContext *cx, JSObject *obj,
    1:                                 JSPrincipals *principals, const char *name,
    1:                                 uintN nargs, const char **argnames,
    1:                                 const char *bytes, size_t length,
    1:                                 const char *filename, uintN lineno);
    1: 
    1: extern JS_PUBLIC_API(JSFunction *)
    1: JS_CompileUCFunction(JSContext *cx, JSObject *obj, const char *name,
    1:                      uintN nargs, const char **argnames,
    1:                      const jschar *chars, size_t length,
    1:                      const char *filename, uintN lineno);
    1: 
    1: extern JS_PUBLIC_API(JSFunction *)
    1: JS_CompileUCFunctionForPrincipals(JSContext *cx, JSObject *obj,
    1:                                   JSPrincipals *principals, const char *name,
    1:                                   uintN nargs, const char **argnames,
    1:                                   const jschar *chars, size_t length,
    1:                                   const char *filename, uintN lineno);
    1: 
53848: extern JS_PUBLIC_API(JSFunction *)
53848: JS_CompileUCFunctionForPrincipalsVersion(JSContext *cx, JSObject *obj,
53848:                                          JSPrincipals *principals, const char *name,
53848:                                          uintN nargs, const char **argnames,
53848:                                          const jschar *chars, size_t length,
53848:                                          const char *filename, uintN lineno,
53848:                                          JSVersion version);
53848: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_DecompileScript(JSContext *cx, JSScript *script, const char *name,
    1:                    uintN indent);
    1: 
    1: /*
    1:  * API extension: OR this into indent to avoid pretty-printing the decompiled
    1:  * source resulting from JS_DecompileFunction{,Body}.
    1:  */
    1: #define JS_DONT_PRETTY_PRINT    ((uintN)0x8000)
    1: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_DecompileFunction(JSContext *cx, JSFunction *fun, uintN indent);
    1: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_DecompileFunctionBody(JSContext *cx, JSFunction *fun, uintN indent);
    1: 
    1: /*
40377:  * NB: JS_ExecuteScript and the JS_Evaluate*Script* quadruplets use the obj
40377:  * parameter as the initial scope chain header, the 'this' keyword value, and
40377:  * the variables object (ECMA parlance for where 'var' and 'function' bind
40377:  * names) of the execution context for script.
    1:  *
    1:  * Using obj as the variables object is problematic if obj's parent (which is
    1:  * the scope chain link; see JS_SetParent and JS_NewObject) is not null: in
    1:  * this case, variables created by 'var x = 0', e.g., go in obj, but variables
    1:  * created by assignment to an unbound id, 'x = 0', go in the last object on
    1:  * the scope chain linked by parent.
    1:  *
    1:  * ECMA calls that last scoping object the "global object", but note that many
    1:  * embeddings have several such objects.  ECMA requires that "global code" be
    1:  * executed with the variables object equal to this global object.  But these
    1:  * JS API entry points provide freedom to execute code against a "sub-global",
    1:  * i.e., a parented or scoped object, in which case the variables object will
    1:  * differ from the last object on the scope chain, resulting in confusing and
    1:  * non-ECMA explicit vs. implicit variable creation.
    1:  *
    1:  * Caveat embedders: unless you already depend on this buggy variables object
    1:  * binding behavior, you should call JS_SetOptions(cx, JSOPTION_VAROBJFIX) or
    1:  * JS_SetOptions(cx, JS_GetOptions(cx) | JSOPTION_VAROBJFIX) -- the latter if
    1:  * someone may have set other options on cx already -- for each context in the
    1:  * application, if you pass parented objects as the obj parameter, or may ever
    1:  * pass such objects in the future.
    1:  *
    1:  * Why a runtime option?  The alternative is to add six or so new API entry
    1:  * points with signatures matching the following six, and that doesn't seem
    1:  * worth the code bloat cost.  Such new entry points would probably have less
    1:  * obvious names, too, so would not tend to be used.  The JS_SetOption call,
    1:  * OTOH, can be more easily hacked into existing code that does not depend on
    1:  * the bug; such code can continue to use the familiar JS_EvaluateScript,
    1:  * etc., entry points.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ExecuteScript(JSContext *cx, JSObject *obj, JSScript *script, jsval *rval);
    1: 
    1: /*
    1:  * Execute either the function-defining prolog of a script, or the script's
    1:  * main body, but not both.
    1:  */
    1: typedef enum JSExecPart { JSEXEC_PROLOG, JSEXEC_MAIN } JSExecPart;
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_EvaluateScript(JSContext *cx, JSObject *obj,
    1:                   const char *bytes, uintN length,
    1:                   const char *filename, uintN lineno,
    1:                   jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_EvaluateScriptForPrincipals(JSContext *cx, JSObject *obj,
    1:                                JSPrincipals *principals,
    1:                                const char *bytes, uintN length,
    1:                                const char *filename, uintN lineno,
    1:                                jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_EvaluateUCScript(JSContext *cx, JSObject *obj,
    1:                     const jschar *chars, uintN length,
    1:                     const char *filename, uintN lineno,
    1:                     jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
53848: JS_EvaluateUCScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
53848:                                         JSPrincipals *principals,
53848:                                         const jschar *chars, uintN length,
53848:                                         const char *filename, uintN lineno,
53848:                                         jsval *rval, JSVersion version);
53848: 
53848: extern JS_PUBLIC_API(JSBool)
    1: JS_EvaluateUCScriptForPrincipals(JSContext *cx, JSObject *obj,
    1:                                  JSPrincipals *principals,
    1:                                  const jschar *chars, uintN length,
    1:                                  const char *filename, uintN lineno,
    1:                                  jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_CallFunction(JSContext *cx, JSObject *obj, JSFunction *fun, uintN argc,
    1:                 jsval *argv, jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_CallFunctionName(JSContext *cx, JSObject *obj, const char *name, uintN argc,
    1:                     jsval *argv, jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_CallFunctionValue(JSContext *cx, JSObject *obj, jsval fval, uintN argc,
    1:                      jsval *argv, jsval *rval);
    1: 
55717: #ifdef __cplusplus
55717: JS_END_EXTERN_C
55717: 
55717: namespace JS {
55717: 
55717: static inline bool
55717: Call(JSContext *cx, JSObject *thisObj, JSFunction *fun, uintN argc, jsval *argv, jsval *rval) {
55717:     return !!JS_CallFunction(cx, thisObj, fun, argc, argv, rval);
55717: }
55717: 
55717: static inline bool
55717: Call(JSContext *cx, JSObject *thisObj, const char *name, uintN argc, jsval *argv, jsval *rval) {
55717:     return !!JS_CallFunctionName(cx, thisObj, name, argc, argv, rval);
55717: }
55717: 
55717: static inline bool
55717: Call(JSContext *cx, JSObject *thisObj, jsval fun, uintN argc, jsval *argv, jsval *rval) {
55717:     return !!JS_CallFunctionValue(cx, thisObj, fun, argc, argv, rval);
55717: }
55717: 
55717: extern JS_PUBLIC_API(bool)
55717: Call(JSContext *cx, jsval thisv, jsval fun, uintN argc, jsval *argv, jsval *rval);
55717: 
55717: static inline bool
55717: Call(JSContext *cx, jsval thisv, JSObject *funObj, uintN argc, jsval *argv, jsval *rval) {
55717:     return Call(cx, thisv, OBJECT_TO_JSVAL(funObj), argc, argv, rval);
55717: }
55717: 
56723: } /* namespace JS */
55717: 
55717: JS_BEGIN_EXTERN_C
56723: #endif /* __cplusplus */
55717: 
 9780: /*
25087:  * These functions allow setting an operation callback that will be called
25087:  * from the thread the context is associated with some time after any thread
25087:  * triggered the callback using JS_TriggerOperationCallback(cx).
25087:  *
25087:  * In a threadsafe build the engine internally triggers operation callbacks
25087:  * under certain circumstances (i.e. GC and title transfer) to force the
25087:  * context to yield its current request, which the engine always
25087:  * automatically does immediately prior to calling the callback function.
25087:  * The embedding should thus not rely on callbacks being triggered through
25087:  * the external API only.
25087:  *
25087:  * Important note: Additional callbacks can occur inside the callback handler
25087:  * if it re-enters the JS engine. The embedding must ensure that the callback
25087:  * is disconnected before attempting such re-entry.
 9780:  */
25087: 
25087: extern JS_PUBLIC_API(JSOperationCallback)
25087: JS_SetOperationCallback(JSContext *cx, JSOperationCallback callback);
23726: 
23726: extern JS_PUBLIC_API(JSOperationCallback)
23726: JS_GetOperationCallback(JSContext *cx);
23726: 
23726: extern JS_PUBLIC_API(void)
23726: JS_TriggerOperationCallback(JSContext *cx);
23726: 
25472: extern JS_PUBLIC_API(void)
25472: JS_TriggerAllOperationCallbacks(JSRuntime *rt);
25472: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IsRunning(JSContext *cx);
    1: 
    1: /*
  520:  * Saving and restoring frame chains.
  520:  *
 1091:  * These two functions are used to set aside cx's call stack while that stack
 1091:  * is inactive. After a call to JS_SaveFrameChain, it looks as if there is no
  520:  * code running on cx. Before calling JS_RestoreFrameChain, cx's call stack
  520:  * must be balanced and all nested calls to JS_SaveFrameChain must have had
  520:  * matching JS_RestoreFrameChain calls.
  520:  *
  520:  * JS_SaveFrameChain deals with cx not having any code running on it. A null
 1091:  * return does not signify an error, and JS_RestoreFrameChain handles a null
 1091:  * frame pointer argument safely.
  520:  */
  520: extern JS_PUBLIC_API(JSStackFrame *)
  520: JS_SaveFrameChain(JSContext *cx);
  520: 
  520: extern JS_PUBLIC_API(void)
  520: JS_RestoreFrameChain(JSContext *cx, JSStackFrame *fp);
  520: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Strings.
    1:  *
    1:  * NB: JS_NewString takes ownership of bytes on success, avoiding a copy; but
    1:  * on error (signified by null return), it leaves bytes owned by the caller.
    1:  * So the caller must free bytes in the error case, if it has no use for them.
    1:  * In contrast, all the JS_New*StringCopy* functions do not take ownership of
    1:  * the character memory passed to them -- they copy it.
    1:  */
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_NewString(JSContext *cx, char *bytes, size_t length);
    1: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_NewStringCopyN(JSContext *cx, const char *s, size_t n);
    1: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_NewStringCopyZ(JSContext *cx, const char *s);
    1: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_InternString(JSContext *cx, const char *s);
    1: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_NewUCString(JSContext *cx, jschar *chars, size_t length);
    1: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_NewUCStringCopyN(JSContext *cx, const jschar *s, size_t n);
    1: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_NewUCStringCopyZ(JSContext *cx, const jschar *s);
    1: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_InternUCStringN(JSContext *cx, const jschar *s, size_t length);
    1: 
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_InternUCString(JSContext *cx, const jschar *s);
    1: 
    1: extern JS_PUBLIC_API(char *)
    1: JS_GetStringBytes(JSString *str);
    1: 
    1: extern JS_PUBLIC_API(jschar *)
    1: JS_GetStringChars(JSString *str);
    1: 
    1: extern JS_PUBLIC_API(size_t)
    1: JS_GetStringLength(JSString *str);
    1: 
33583: extern JS_PUBLIC_API(const char *)
33583: JS_GetStringBytesZ(JSContext *cx, JSString *str);
33583: 
33583: extern JS_PUBLIC_API(const jschar *)
33583: JS_GetStringCharsZ(JSContext *cx, JSString *str);
33583: 
    1: extern JS_PUBLIC_API(intN)
    1: JS_CompareStrings(JSString *str1, JSString *str2);
    1: 
    1: /*
48491:  * This function is now obsolete and behaves the same as JS_NewUCString.  Use
48491:  * JS_NewUCString instead.
48491:  */
48491: extern JS_PUBLIC_API(JSString *)
48491: JS_NewGrowableString(JSContext *cx, jschar *chars, size_t length);
48491: 
48491: /*
    1:  * Mutable string support.  A string's characters are never mutable in this JS
48491:  * implementation, but a dependent string is a substring of another dependent
48491:  * or immutable string, and a rope is a lazily concatenated string that creates
48491:  * its underlying buffer the first time it is accessed.  Even after a rope
48491:  * creates its underlying buffer, it still considered mutable.  The direct data
48491:  * members of the (opaque to API clients) JSString struct may be changed in a
48491:  * single-threaded way for dependent strings and ropes.
    1:  *
48491:  * Therefore mutable strings (ropes and dependent strings) cannot be used by
48491:  * more than one thread at a time.  You may call JS_MakeStringImmutable to
48491:  * convert the string from a mutable string to an immutable (and therefore
48491:  * thread-safe) string.  The engine takes care of converting ropes and dependent
48491:  * strings to immutable for you if you store strings in multi-threaded objects
48491:  * using JS_SetProperty or kindred API entry points.
    1:  *
    1:  * If you store a JSString pointer in a native data structure that is (safely)
    1:  * accessible to multiple threads, you must call JS_MakeStringImmutable before
    1:  * retiring the store.
    1:  */
    1: 
    1: /*
    1:  * Create a dependent string, i.e., a string that owns no character storage,
    1:  * but that refers to a slice of another string's chars.  Dependent strings
    1:  * are mutable by definition, so the thread safety comments above apply.
    1:  */
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_NewDependentString(JSContext *cx, JSString *str, size_t start,
    1:                       size_t length);
    1: 
    1: /*
48491:  * Concatenate two strings, possibly resulting in a rope.
48491:  * See above for thread safety comments.
    1:  */
    1: extern JS_PUBLIC_API(JSString *)
    1: JS_ConcatStrings(JSContext *cx, JSString *left, JSString *right);
    1: 
    1: /*
    1:  * Convert a dependent string into an independent one.  This function does not
    1:  * change the string's mutability, so the thread safety comments above apply.
    1:  */
    1: extern JS_PUBLIC_API(const jschar *)
    1: JS_UndependString(JSContext *cx, JSString *str);
    1: 
    1: /*
48491:  * Convert a mutable string (either rope or dependent) into an immutable,
    1:  * thread-safe one.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_MakeStringImmutable(JSContext *cx, JSString *str);
    1: 
    1: /*
    1:  * Return JS_TRUE if C (char []) strings passed via the API and internally
 8893:  * are UTF-8.
    1:  */
    1: JS_PUBLIC_API(JSBool)
 7647: JS_CStringsAreUTF8(void);
    1: 
    1: /*
 9780:  * Update the value to be returned by JS_CStringsAreUTF8(). Once set, it
 9780:  * can never be changed. This API must be called before the first call to
 8893:  * JS_NewRuntime.
 8893:  */
 8893: JS_PUBLIC_API(void)
 9780: JS_SetCStringsAreUTF8(void);
 8893: 
 8893: /*
    1:  * Character encoding support.
    1:  *
    1:  * For both JS_EncodeCharacters and JS_DecodeBytes, set *dstlenp to the size
    1:  * of the destination buffer before the call; on return, *dstlenp contains the
    1:  * number of bytes (JS_EncodeCharacters) or jschars (JS_DecodeBytes) actually
    1:  * stored.  To determine the necessary destination buffer size, make a sizing
    1:  * call that passes NULL for dst.
    1:  *
    1:  * On errors, the functions report the error. In that case, *dstlenp contains
    1:  * the number of characters or bytes transferred so far.  If cx is NULL, no
    1:  * error is reported on failure, and the functions simply return JS_FALSE.
    1:  *
    1:  * NB: Neither function stores an additional zero byte or jschar after the
    1:  * transcoded string.
    1:  *
 8893:  * If JS_CStringsAreUTF8() is true then JS_EncodeCharacters encodes to
 8893:  * UTF-8, and JS_DecodeBytes decodes from UTF-8, which may create additional
 8893:  * errors if the character sequence is malformed.  If UTF-8 support is
 8893:  * disabled, the functions deflate and inflate, respectively.
    1:  */
    1: JS_PUBLIC_API(JSBool)
    1: JS_EncodeCharacters(JSContext *cx, const jschar *src, size_t srclen, char *dst,
    1:                     size_t *dstlenp);
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DecodeBytes(JSContext *cx, const char *src, size_t srclen, jschar *dst,
    1:                size_t *dstlenp);
    1: 
 8893: /*
 8893:  * A variation on JS_EncodeCharacters where a null terminated string is
 8893:  * returned that you are expected to call JS_free on when done.
 8893:  */
 8893: JS_PUBLIC_API(char *)
 8893: JS_EncodeString(JSContext *cx, JSString *str);
 8893: 
    1: /************************************************************************/
20092: /*
20092:  * JSON functions
20092:  */
20092: typedef JSBool (* JSONWriteCallback)(const jschar *buf, uint32 len, void *data);
20092: 
20092: /*
26059:  * JSON.stringify as specified by ES3.1 (draft)
20092:  */
20092: JS_PUBLIC_API(JSBool)
28100: JS_Stringify(JSContext *cx, jsval *vp, JSObject *replacer, jsval space,
20092:              JSONWriteCallback callback, void *data);
20092: 
20092: /*
20092:  * Retrieve a toJSON function. If found, set vp to its result.
20092:  */
20092: JS_PUBLIC_API(JSBool)
20092: JS_TryJSON(JSContext *cx, jsval *vp);
20092: 
20092: /*
26059:  * JSON.parse as specified by ES3.1 (draft)
20092:  */
20092: JS_PUBLIC_API(JSONParser *)
20092: JS_BeginJSONParse(JSContext *cx, jsval *vp);
20092: 
20092: JS_PUBLIC_API(JSBool)
20092: JS_ConsumeJSONText(JSContext *cx, JSONParser *jp, const jschar *data, uint32 len);
20092: 
20092: JS_PUBLIC_API(JSBool)
25718: JS_FinishJSONParse(JSContext *cx, JSONParser *jp, jsval reviver);
20092: 
20092: /************************************************************************/
    1: 
54863: /* API for the HTML5 internal structured cloning algorithm. */
54863: 
54863: /* The maximum supported structured-clone serialization format version. */
54863: #define JS_STRUCTURED_CLONE_VERSION 1
54863: 
54863: JS_PUBLIC_API(JSBool)
54863: JS_ReadStructuredClone(JSContext *cx, const uint64 *data, size_t nbytes, jsval *vp);
54863: 
54863: /* Note: On success, the caller is responsible for calling js_free(*datap). */
54863: JS_PUBLIC_API(JSBool)
54863: JS_WriteStructuredClone(JSContext *cx, jsval v, uint64 **datap, size_t *nbytesp);
54863: 
54863: JS_PUBLIC_API(JSBool)
54863: JS_StructuredClone(JSContext *cx, jsval v, jsval *vp);
54863: 
54863: #ifdef __cplusplus
54863: /* RAII sugar for JS_WriteStructuredClone. */
54863: class JSAutoStructuredCloneBuffer {
54863:     JSContext *cx;
54863:     uint64 *data_;
54863:     size_t nbytes_;
54863: 
54863:   public:
54863:     explicit JSAutoStructuredCloneBuffer(JSContext *cx) : cx(cx), data_(NULL), nbytes_(0) {}
54863:     ~JSAutoStructuredCloneBuffer() { clear(); }
54863: 
54863:     uint64 *data() const { return data_; }
54863:     size_t nbytes() const { return nbytes_; }
54863: 
54863:     void clear() {
54863:         if (data_) {
54863:             JS_free(cx, data_);
54863:             data_ = NULL;
54863:             nbytes_ = 0;
54863:         }
54863:     }
54863: 
54863:     /*
54863:      * Adopt some memory. It will be automatically freed by the destructor.
54863:      * data must have been allocated using JS_malloc.
54863:      */
54863:     void adopt(uint64 *data, size_t nbytes) {
54863:         clear();
54863:         data_ = data;
54863:         nbytes_ = nbytes;
54863:     }
54863: 
54863:     /*
54863:      * Remove the buffer so that it will not be automatically freed.
54863:      * After this, the caller is responsible for calling JS_free(*datap).
54863:      */
54863:     void steal(uint64 **datap, size_t *nbytesp) {
54863:         *datap = data_;
54863:         *nbytesp = nbytes_;
54863:         data_ = NULL;
54863:         nbytes_ = 0;
54863:     }
54863: 
54863:     bool read(jsval *vp) const {
54863:         JS_ASSERT(data_);
54863:         return !!JS_ReadStructuredClone(cx, data_, nbytes_, vp);
54863:     }
54863: 
54863:     bool write(jsval v) {
54863:         clear();
54863:         bool ok = !!JS_WriteStructuredClone(cx, v, &data_, &nbytes_);
54863:         if (!ok) {
54863:             data_ = NULL;
54863:             nbytes_ = 0;
54863:         }
54863:         return ok;
54863:     }
54863: };
54863: #endif
54863: 
54863: /* API for implementing custom serialization behavior (for ImageData, File, etc.) */
54863: 
54863: /* The range of tag values the application may use for its own custom object types. */
54863: #define JS_SCTAG_USER_MIN  ((uint32) 0xFFFF8000)
54863: #define JS_SCTAG_USER_MAX  ((uint32) 0xFFFFFFFF)
54863: 
54863: #define JS_SCERR_RECURSION 0
54863: 
54863: struct JSStructuredCloneCallbacks {
54863:     ReadStructuredCloneOp read;
54863:     WriteStructuredCloneOp write;
54863:     StructuredCloneErrorOp reportError;
54863: };
54863: 
54863: JS_PUBLIC_API(void)
54863: JS_SetStructuredCloneCallbacks(JSRuntime *rt, const JSStructuredCloneCallbacks *callbacks);
54863: 
54863: JS_PUBLIC_API(JSBool)
55480: JS_ReadUint32Pair(JSStructuredCloneReader *r, uint32 *p1, uint32 *p2);
54863: 
54863: JS_PUBLIC_API(JSBool)
54863: JS_ReadBytes(JSStructuredCloneReader *r, void *p, size_t len);
54863: 
54863: JS_PUBLIC_API(JSBool)
55480: JS_WriteUint32Pair(JSStructuredCloneWriter *w, uint32 tag, uint32 data);
54863: 
54863: JS_PUBLIC_API(JSBool)
54863: JS_WriteBytes(JSStructuredCloneWriter *w, const void *p, size_t len);
54863: 
54863: /************************************************************************/
54863: 
    1: /*
    1:  * Locale specific string conversion and error message callbacks.
    1:  */
    1: struct JSLocaleCallbacks {
    1:     JSLocaleToUpperCase     localeToUpperCase;
    1:     JSLocaleToLowerCase     localeToLowerCase;
    1:     JSLocaleCompare         localeCompare;
    1:     JSLocaleToUnicode       localeToUnicode;
    1:     JSErrorCallback         localeGetErrorMessage;
    1: };
    1: 
    1: /*
    1:  * Establish locale callbacks. The pointer must persist as long as the
    1:  * JSContext.  Passing NULL restores the default behaviour.
    1:  */
    1: extern JS_PUBLIC_API(void)
    1: JS_SetLocaleCallbacks(JSContext *cx, JSLocaleCallbacks *callbacks);
    1: 
    1: /*
    1:  * Return the address of the current locale callbacks struct, which may
    1:  * be NULL.
    1:  */
    1: extern JS_PUBLIC_API(JSLocaleCallbacks *)
    1: JS_GetLocaleCallbacks(JSContext *cx);
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Error reporting.
    1:  */
    1: 
    1: /*
    1:  * Report an exception represented by the sprintf-like conversion of format
    1:  * and its arguments.  This exception message string is passed to a pre-set
    1:  * JSErrorReporter function (set by JS_SetErrorReporter; see jspubtd.h for
    1:  * the JSErrorReporter typedef).
    1:  */
    1: extern JS_PUBLIC_API(void)
    1: JS_ReportError(JSContext *cx, const char *format, ...);
    1: 
    1: /*
    1:  * Use an errorNumber to retrieve the format string, args are char *
    1:  */
    1: extern JS_PUBLIC_API(void)
    1: JS_ReportErrorNumber(JSContext *cx, JSErrorCallback errorCallback,
    1:                      void *userRef, const uintN errorNumber, ...);
    1: 
    1: /*
    1:  * Use an errorNumber to retrieve the format string, args are jschar *
    1:  */
    1: extern JS_PUBLIC_API(void)
    1: JS_ReportErrorNumberUC(JSContext *cx, JSErrorCallback errorCallback,
    1:                      void *userRef, const uintN errorNumber, ...);
    1: 
    1: /*
    1:  * As above, but report a warning instead (JSREPORT_IS_WARNING(report.flags)).
    1:  * Return true if there was no error trying to issue the warning, and if the
    1:  * warning was not converted into an error due to the JSOPTION_WERROR option
    1:  * being set, false otherwise.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ReportWarning(JSContext *cx, const char *format, ...);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ReportErrorFlagsAndNumber(JSContext *cx, uintN flags,
    1:                              JSErrorCallback errorCallback, void *userRef,
    1:                              const uintN errorNumber, ...);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ReportErrorFlagsAndNumberUC(JSContext *cx, uintN flags,
    1:                                JSErrorCallback errorCallback, void *userRef,
    1:                                const uintN errorNumber, ...);
    1: 
    1: /*
    1:  * Complain when out of memory.
    1:  */
    1: extern JS_PUBLIC_API(void)
    1: JS_ReportOutOfMemory(JSContext *cx);
    1: 
12983: /*
12983:  * Complain when an allocation size overflows the maximum supported limit.
12983:  */
12983: extern JS_PUBLIC_API(void)
12983: JS_ReportAllocationOverflow(JSContext *cx);
12983: 
    1: struct JSErrorReport {
    1:     const char      *filename;      /* source file name, URL, etc., or null */
    1:     uintN           lineno;         /* source line number */
    1:     const char      *linebuf;       /* offending source line without final \n */
    1:     const char      *tokenptr;      /* pointer to error token in linebuf */
    1:     const jschar    *uclinebuf;     /* unicode (original) line buffer */
    1:     const jschar    *uctokenptr;    /* unicode (original) token pointer */
    1:     uintN           flags;          /* error/warning, etc. */
    1:     uintN           errorNumber;    /* the error number, e.g. see js.msg */
    1:     const jschar    *ucmessage;     /* the (default) error message */
    1:     const jschar    **messageArgs;  /* arguments for the error message */
    1: };
    1: 
    1: /*
    1:  * JSErrorReport flag values.  These may be freely composed.
    1:  */
    1: #define JSREPORT_ERROR      0x0     /* pseudo-flag for default case */
    1: #define JSREPORT_WARNING    0x1     /* reported via JS_ReportWarning */
    1: #define JSREPORT_EXCEPTION  0x2     /* exception was thrown */
    1: #define JSREPORT_STRICT     0x4     /* error or warning due to strict option */
    1: 
    1: /*
35302:  * This condition is an error in strict mode code, a warning if
35302:  * JS_HAS_STRICT_OPTION(cx), and otherwise should not be reported at
35302:  * all.  We check the strictness of the context's top frame's script;
35302:  * where that isn't appropriate, the caller should do the right checks
35302:  * itself instead of using this flag.
35302:  */
35302: #define JSREPORT_STRICT_MODE_ERROR 0x8
35302: 
35302: /*
    1:  * If JSREPORT_EXCEPTION is set, then a JavaScript-catchable exception
    1:  * has been thrown for this runtime error, and the host should ignore it.
    1:  * Exception-aware hosts should also check for JS_IsExceptionPending if
    1:  * JS_ExecuteScript returns failure, and signal or propagate the exception, as
    1:  * appropriate.
    1:  */
    1: #define JSREPORT_IS_WARNING(flags)      (((flags) & JSREPORT_WARNING) != 0)
    1: #define JSREPORT_IS_EXCEPTION(flags)    (((flags) & JSREPORT_EXCEPTION) != 0)
    1: #define JSREPORT_IS_STRICT(flags)       (((flags) & JSREPORT_STRICT) != 0)
35302: #define JSREPORT_IS_STRICT_MODE_ERROR(flags) (((flags) &                      \
35302:                                               JSREPORT_STRICT_MODE_ERROR) != 0)
    1: 
    1: extern JS_PUBLIC_API(JSErrorReporter)
    1: JS_SetErrorReporter(JSContext *cx, JSErrorReporter er);
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Regular Expressions.
    1:  */
    1: #define JSREG_FOLD      0x01    /* fold uppercase to lowercase */
    1: #define JSREG_GLOB      0x02    /* global exec, creates array of matches */
    1: #define JSREG_MULTILINE 0x04    /* treat ^ and $ as begin and end of line */
    1: #define JSREG_STICKY    0x08    /* only match starting at lastIndex */
22611: #define JSREG_FLAT      0x10    /* parse as a flat regexp */
30038: #define JSREG_NOCOMPILE 0x20    /* do not try to compile to native code */
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
53858: JS_NewRegExpObject(JSContext *cx, JSObject *obj, char *bytes, size_t length, uintN flags);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
53858: JS_NewUCRegExpObject(JSContext *cx, JSObject *obj, jschar *chars, size_t length, uintN flags);
    1: 
    1: extern JS_PUBLIC_API(void)
53858: JS_SetRegExpInput(JSContext *cx, JSObject *obj, JSString *input, JSBool multiline);
    1: 
    1: extern JS_PUBLIC_API(void)
53858: JS_ClearRegExpStatics(JSContext *cx, JSObject *obj);
    1: 
50911: extern JS_PUBLIC_API(JSBool)
53858: JS_ExecuteRegExp(JSContext *cx, JSObject *obj, JSObject *reobj, jschar *chars, size_t length,
50911:                  size_t *indexp, JSBool test, jsval *rval);
50911: 
53858: /* RegExp interface for clients without a global object. */
53858: 
53858: extern JS_PUBLIC_API(JSObject *)
53858: JS_NewRegExpObjectNoStatics(JSContext *cx, char *bytes, size_t length, uintN flags);
53858: 
53858: extern JS_PUBLIC_API(JSObject *)
53858: JS_NewUCRegExpObjectNoStatics(JSContext *cx, jschar *chars, size_t length, uintN flags);
53858: 
53858: extern JS_PUBLIC_API(JSBool)
53858: JS_ExecuteRegExpNoStatics(JSContext *cx, JSObject *reobj, jschar *chars, size_t length,
53858:                           size_t *indexp, JSBool test, jsval *rval);
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IsExceptionPending(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetPendingException(JSContext *cx, jsval *vp);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetPendingException(JSContext *cx, jsval v);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_ClearPendingException(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ReportPendingException(JSContext *cx);
    1: 
    1: /*
    1:  * Save the current exception state.  This takes a snapshot of cx's current
    1:  * exception state without making any change to that state.
    1:  *
    1:  * The returned state pointer MUST be passed later to JS_RestoreExceptionState
    1:  * (to restore that saved state, overriding any more recent state) or else to
    1:  * JS_DropExceptionState (to free the state struct in case it is not correct
    1:  * or desirable to restore it).  Both Restore and Drop free the state struct,
    1:  * so callers must stop using the pointer returned from Save after calling the
    1:  * Release or Drop API.
    1:  */
    1: extern JS_PUBLIC_API(JSExceptionState *)
    1: JS_SaveExceptionState(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_RestoreExceptionState(JSContext *cx, JSExceptionState *state);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_DropExceptionState(JSContext *cx, JSExceptionState *state);
    1: 
    1: /*
    1:  * If the given value is an exception object that originated from an error,
    1:  * the exception will contain an error report struct, and this API will return
    1:  * the address of that struct.  Otherwise, it returns NULL.  The lifetime of
    1:  * the error report struct that might be returned is the same as the lifetime
    1:  * of the exception object.
    1:  */
    1: extern JS_PUBLIC_API(JSErrorReport *)
    1: JS_ErrorFromException(JSContext *cx, jsval v);
    1: 
    1: /*
    1:  * Given a reported error's message and JSErrorReport struct pointer, throw
    1:  * the corresponding exception on cx.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ThrowReportedError(JSContext *cx, const char *message,
    1:                       JSErrorReport *reportp);
    1: 
 6464: /*
 6464:  * Throws a StopIteration exception on cx.
 6464:  */
 6464: extern JS_PUBLIC_API(JSBool)
 6464: JS_ThrowStopIteration(JSContext *cx);
 6464: 
    1: /*
    1:  * Associate the current thread with the given context.  This is done
    1:  * implicitly by JS_NewContext.
    1:  *
    1:  * Returns the old thread id for this context, which should be treated as
    1:  * an opaque value.  This value is provided for comparison to 0, which
    1:  * indicates that ClearContextThread has been called on this context
    1:  * since the last SetContextThread, or non-0, which indicates the opposite.
    1:  */
    1: extern JS_PUBLIC_API(jsword)
    1: JS_GetContextThread(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(jsword)
    1: JS_SetContextThread(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(jsword)
    1: JS_ClearContextThread(JSContext *cx);
    1: 
50455: #ifdef MOZ_TRACE_JSCALLS
50455: typedef void (*JSFunctionCallback)(const JSFunction *fun,
50455:                                    const JSScript *scr,
50455:                                    const JSContext *cx,
50455:                                    JSBool entering);
50455: 
50455: extern JS_PUBLIC_API(void)
50455: JS_SetFunctionCallback(JSContext *cx, JSFunctionCallback fcb);
50455: 
50455: extern JS_PUBLIC_API(JSFunctionCallback)
50455: JS_GetFunctionCallback(JSContext *cx);
50455: #endif
50455: 
    1: /************************************************************************/
    1: 
53557: /*
53557:  * JS_IsConstructing must be called from within a native given the
53557:  * native's original cx and vp arguments. If JS_IsConstructing is true,
53557:  * JS_THIS must not be used; the constructor should construct and return a
53557:  * new object. Otherwise, the native is called as an ordinary function and
53557:  * JS_THIS may be used.
53557:  */
53557: static JS_ALWAYS_INLINE JSBool
53557: JS_IsConstructing(JSContext *cx, const jsval *vp)
53557: {
53557:     jsval_layout l;
53557: 
53557: #ifdef DEBUG
53557:     JSObject *callee = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));
53557:     if (JS_ObjectIsFunction(cx, callee)) {
53557:         JSFunction *fun = JS_ValueToFunction(cx, JS_CALLEE(cx, vp));
53557:         JS_ASSERT((JS_GetFunctionFlags(fun) & JSFUN_CONSTRUCTOR) != 0);
53557:     } else {
53557:         JS_ASSERT(JS_GET_CLASS(cx, callee)->construct != NULL);
53557:     }
53557: #endif
53557: 
53557:     l.asBits = JSVAL_BITS(vp[1]);
53557:     return JSVAL_IS_MAGIC_IMPL(l);
53557: }
53557: 
53557: /*
53557:  * In the case of a constructor called from JS_ConstructObject and
53557:  * JS_InitClass where the class has the JSCLASS_CONSTRUCT_PROTOTYPE flag set,
53557:  * the JS engine passes the constructor a non-standard 'this' object. In such
53557:  * cases, the following query provides the additional information of whether a
53557:  * special 'this' was supplied. E.g.:
53557:  *
53557:  *   JSBool foo_native(JSContext *cx, uintN argc, jsval *vp) {
53557:  *     JSObject *maybeThis;
53557:  *     if (JS_IsConstructing_PossiblyWithGivenThisObject(cx, vp, &maybeThis)) {
53557:  *       // native called as a constructor
53557:  *       if (maybeThis)
53557:  *         // native called as a constructor with maybeThis as 'this'
53557:  *     } else {
53557:  *       // native called as function, maybeThis is still uninitialized
53557:  *     }
53557:  *   }
53557:  *
53557:  * Note that embeddings do not need to use this query unless they use the
53557:  * aforementioned API/flags.
53557:  */
53557: static JS_ALWAYS_INLINE JSBool
53557: JS_IsConstructing_PossiblyWithGivenThisObject(JSContext *cx, const jsval *vp,
53557:                                               JSObject **maybeThis)
53557: {
53557:     jsval_layout l;
53557:     JSBool isCtor;
53557: 
53557: #ifdef DEBUG
53557:     JSObject *callee = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));
53557:     if (JS_ObjectIsFunction(cx, callee)) {
53557:         JSFunction *fun = JS_ValueToFunction(cx, JS_CALLEE(cx, vp));
53557:         JS_ASSERT((JS_GetFunctionFlags(fun) & JSFUN_CONSTRUCTOR) != 0);
53557:     } else {
53557:         JS_ASSERT(JS_GET_CLASS(cx, callee)->construct != NULL);
53557:     }
53557: #endif
53557: 
53557:     l.asBits = JSVAL_BITS(vp[1]);
53557:     isCtor = JSVAL_IS_MAGIC_IMPL(l);
53557:     if (isCtor)
53557:         *maybeThis = MAGIC_JSVAL_TO_OBJECT_OR_NULL_IMPL(l);
53557:     return isCtor;
53557: }
53557: 
53557: /*
53557:  * If a constructor does not have any static knowledge about the type of
53557:  * object to create, it can request that the JS engine create a default new
53557:  * 'this' object, as is done for non-constructor natives when called with new.
53557:  */
53557: extern JS_PUBLIC_API(JSObject *)
53557: JS_NewObjectForConstructor(JSContext *cx, const jsval *vp);
53557: 
53557: /************************************************************************/
53557: 
 1492: #ifdef DEBUG
 1492: #define JS_GC_ZEAL 1
 1492: #endif
 1492: 
 1492: #ifdef JS_GC_ZEAL
 1492: extern JS_PUBLIC_API(void)
 1492: JS_SetGCZeal(JSContext *cx, uint8 zeal);
 1492: #endif
 1492: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jsapi_h___ */
