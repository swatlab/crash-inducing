    1: /* -*- Mode: ObjC; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: BSD
    1:  *
31590:  * Copyright (C) 2006-2009 Mozilla Corporation.  All rights reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
 9699:  *   John Daggett <jdaggett@mozilla.com>
22982:  *   Jonathan Kew <jfkthame@gmail.com>
    1:  *
    1:  * Copyright (C) 2006 Apple Computer, Inc.  All rights reserved.
    1:  *
    1:  * Redistribution and use in source and binary forms, with or without
    1:  * modification, are permitted provided that the following conditions
    1:  * are met:
    1:  *
    1:  * 1.  Redistributions of source code must retain the above copyright
    1:  *     notice, this list of conditions and the following disclaimer.
    1:  * 2.  Redistributions in binary form must reproduce the above copyright
    1:  *     notice, this list of conditions and the following disclaimer in the
    1:  *     documentation and/or other materials provided with the distribution.
    1:  * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
    1:  *     its contributors may be used to endorse or promote products derived
    1:  *     from this software without specific prior written permission.
    1:  *
    1:  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
    1:  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    1:  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    1:  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
    1:  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    1:  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    1:  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    1:  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    1:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    1:  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
61084: #ifdef MOZ_LOGGING
61084: #define FORCE_PR_LOG /* Allow logging in the release build */
61084: #endif
61084: #include "prlog.h"
61084: 
26366: #include <Carbon/Carbon.h>
    1: 
    1: #import <AppKit/AppKit.h>
    1: 
    1: #include "gfxPlatformMac.h"
31590: #include "gfxMacPlatformFontList.h"
39206: #include "gfxMacFont.h"
19962: #include "gfxUserFontSet.h"
    1: 
11086: #include "nsServiceManagerUtils.h"
23904: #include "nsTArray.h"
11086: 
19962: #include "nsDirectoryServiceUtils.h"
19962: #include "nsDirectoryServiceDefs.h"
19962: #include "nsISimpleEnumerator.h"
19962: 
19962: #include <unistd.h>
19962: #include <time.h>
19962: 
39159: class nsAutoreleasePool {
39159: public:
39159:     nsAutoreleasePool()
39159:     {
39159:         mLocalPool = [[NSAutoreleasePool alloc] init];
39159:     }
39159:     ~nsAutoreleasePool()
39159:     {
39159:         [mLocalPool release];
39159:     }
39159: private:
39159:     NSAutoreleasePool *mLocalPool;
39159: };
39159: 
13877: // font info loader constants
13877: static const PRUint32 kDelayBeforeLoadingCmaps = 8 * 1000; // 8secs
13877: static const PRUint32 kIntervalBetweenLoadingCmaps = 150; // 150ms
13877: static const PRUint32 kNumFontsPerSlice = 10; // read in info 10 fonts at a time
13877: 
31590: // indexes into the NSArray objects that the Cocoa font manager returns
31590: // as the available members of a family
    1: #define INDEX_FONT_POSTSCRIPT_NAME 0
10880: #define INDEX_FONT_FACE_NAME 1
    1: #define INDEX_FONT_WEIGHT 2
    1: #define INDEX_FONT_TRAITS 3
    1: 
10880: static const int kAppleMaxWeight = 14;
25394: static const int kAppleExtraLightWeight = 3;
25394: static const int kAppleUltraLightWeight = 2;
    1: 
10880: static const int gAppleWeightToCSSWeight[] = {
    1:     0,
    1:     1, // 1.
    1:     1, // 2.  W1, ultralight
    1:     2, // 3.  W2, extralight
    1:     3, // 4.  W3, light
    1:     4, // 5.  W4, semilight
    1:     5, // 6.  W5, medium
    1:     6, // 7.
    1:     6, // 8.  W6, semibold
    1:     7, // 9.  W7, bold
    1:     8, // 10. W8, extrabold
    1:     8, // 11.
    1:     9, // 12. W9, ultrabold
    1:     9, // 13
    1:     9  // 14
    1: };
    1: 
35525: // cache Cocoa's "shared font manager" for performance
35525: static NSFontManager *sFontManager;
10880: 
10880: static void GetStringForNSString(const NSString *aSrc, nsAString& aDist)
10880: {
10880:     aDist.SetLength([aSrc length]);
10880:     [aSrc getCharacters:aDist.BeginWriting()];
10880: }
10880: 
10880: static NSString* GetNSStringForString(const nsAString& aSrc)
10880: {
10880:     return [NSString stringWithCharacters:aSrc.BeginReading()
10880:                      length:aSrc.Length()];
10880: }
10880: 
36949: #ifdef PR_LOGGING
36949: 
61084: #define LOG_FONTLIST(args) PR_LOG(gfxPlatform::GetLog(eGfxLog_fontlist), \
61084:                                PR_LOG_DEBUG, args)
61084: #define LOG_FONTLIST_ENABLED() PR_LOG_TEST( \
61084:                                    gfxPlatform::GetLog(eGfxLog_fontlist), \
61084:                                    PR_LOG_DEBUG)
61084: 
61084: #endif // PR_LOGGING
10880: 
70582: /* MacOSFontEntry - abstract superclass for ATS and CG font entries */
11086: #pragma mark-
10880: 
10880: MacOSFontEntry::MacOSFontEntry(const nsAString& aPostscriptName,
31590:                                PRInt32 aWeight,
31590:                                gfxFontFamily *aFamily,
23553:                                PRBool aIsStandardFace)
31590:     : gfxFontEntry(aPostscriptName, aFamily, aIsStandardFace),
70582:       mFontRef(NULL),
70582:       mFontRefInitialized(PR_FALSE),
55074:       mRequiresAAT(PR_FALSE),
55074:       mIsCFF(PR_FALSE),
55074:       mIsCFFInitialized(PR_FALSE)
10880: {
25394:     mWeight = aWeight;
10880: }
10880: 
11580: // ATSUI requires AAT-enabled fonts to render complex scripts correctly.
11580: // For now, simple clear out the cmap codepoints for fonts that have
11580: // codepoints for complex scripts. (Bug 361986)
31590: // Core Text is similar, but can render Arabic using OpenType fonts as well.
11580: 
11580: enum eComplexScript {
11580:     eComplexScriptArabic,
11580:     eComplexScriptIndic,
11580:     eComplexScriptTibetan
11580: };
11580: 
11580: struct ScriptRange {
11580:     eComplexScript   script;
11580:     PRUint32         rangeStart;
11580:     PRUint32         rangeEnd;
11580: };
11580: 
11580: const ScriptRange gScriptsThatRequireShaping[] = {
57948:     { eComplexScriptArabic, 0x0600, 0x077F },   // Basic Arabic, Syriac, Arabic Supplement
11580:     { eComplexScriptIndic, 0x0900, 0x0D7F },     // Indic scripts - Devanagari, Bengali, ..., Malayalam
11580:     { eComplexScriptTibetan, 0x0F00, 0x0FFF }     // Tibetan
11580:     // Thai seems to be "renderable" without AAT morphing tables
11580:     // xxx - Lao, Khmer?
11580: };
11580: 
10880: nsresult
10880: MacOSFontEntry::ReadCMAP()
10880: {
10880:     // attempt this once, if errors occur leave a blank cmap
70582:     if (mCmapInitialized) {
31590:         return NS_OK;
70582:     }
10880:     mCmapInitialized = PR_TRUE;
10880: 
26852:     PRUint32 kCMAP = TRUETYPE_TAG('c','m','a','p');
26852: 
60098:     AutoFallibleTArray<PRUint8,16384> cmap;
70582:     if (GetFontTable(kCMAP, cmap) != NS_OK) {
31590:         return NS_ERROR_FAILURE;
70582:     }
10880: 
10880:     PRPackedBool  unicodeFont, symbolFont; // currently ignored
35526:     nsresult rv = gfxFontUtils::ReadCMAP(cmap.Elements(), cmap.Length(),
48069:                                          mCharacterMap, mUVSOffset,
48069:                                          unicodeFont, symbolFont);
32826:     if (NS_FAILED(rv)) {
32826:         mCharacterMap.reset();
32826:         return rv;
32826:     }
43527:     mHasCmapTable = PR_TRUE;
32826: 
70582:     CGFontRef fontRef = GetFontRef();
70582:     if (!fontRef) {
70582:         return NS_ERROR_FAILURE;
70582:     }
11580: 
58652:     // for layout support, check for the presence of mort/morx and/or
58652:     // opentype layout tables
70582:     PRBool hasAATLayout = HasFontTable(TRUETYPE_TAG('m','o','r','x')) ||
70582:                           HasFontTable(TRUETYPE_TAG('m','o','r','t'));
70582:     PRBool hasGSUB = HasFontTable(TRUETYPE_TAG('G','S','U','B'));
70582:     PRBool hasGPOS = HasFontTable(TRUETYPE_TAG('G','P','O','S'));
48069: 
58652:     if (hasAATLayout && !(hasGSUB || hasGPOS)) {
58652:         mRequiresAAT = PR_TRUE; // prefer CoreText if font has no OTL tables
48069:     }
48069: 
48069:     PRUint32 numScripts =
48069:         sizeof(gScriptsThatRequireShaping) / sizeof(ScriptRange);
48069: 
48069:     for (PRUint32 s = 0; s < numScripts; s++) {
11580:         eComplexScript  whichScript = gScriptsThatRequireShaping[s].script;
11580: 
11580:         // check to see if the cmap includes complex script codepoints
31590:         if (mCharacterMap.TestRange(gScriptsThatRequireShaping[s].rangeStart,
31590:                                     gScriptsThatRequireShaping[s].rangeEnd)) {
31590:             PRBool omitRange = PR_TRUE;
11580: 
48069:             if (hasAATLayout) {
31590:                 omitRange = PR_FALSE;
58652:                 // prefer CoreText for Apple's complex-script fonts,
58652:                 // even if they also have some OpenType tables
58652:                 // (e.g. Geeza Pro Bold on 10.6; see bug 614903)
58652:                 mRequiresAAT = PR_TRUE;
48069:             } else if (whichScript == eComplexScriptArabic) {
48069:                 // special-case for Arabic:
38748:                 // even if there's no morph table, CoreText can shape Arabic
57948:                 // using OpenType layout; or if it's a downloaded font,
57948:                 // assume the site knows what it's doing (as harfbuzz will
58652:                 // be able to shape even though the font itself lacks tables
58652:                 // stripped during sanitization).
58652:                 // We check for GSUB here, as GPOS alone would not be ok
58652:                 // for Arabic shaping.
58652:                 if (hasGSUB || (mIsUserFont && !mIsLocalUserFont)) {
48069:                     // TODO: to be really thorough, we could check that the
48069:                     // GSUB table actually supports the 'arab' script tag.
31590:                     omitRange = PR_FALSE;
31590:                 }
11580:             }
11580: 
31590:             if (omitRange) {
31590:                 mCharacterMap.ClearRange(gScriptsThatRequireShaping[s].rangeStart,
31590:                                          gScriptsThatRequireShaping[s].rangeEnd);
11580:             }
11580:         }
11580:     }
11580: 
61084: #ifdef PR_LOGGING
61084:     LOG_FONTLIST(("(fontlist-cmap) name: %s, size: %d\n",
48069:                   NS_ConvertUTF16toUTF8(mName).get(),
48069:                   mCharacterMap.GetSize()));
61084: #endif
13877: 
10880:     return rv;
10880: }
10880: 
70582: gfxFont*
70582: MacOSFontEntry::CreateFontInstance(const gfxFontStyle *aFontStyle, PRBool aNeedsBold)
70582: {
70582:     return new gfxMacFont(this, aFontStyle, aNeedsBold);
70582: }
70582: 
70582: PRBool
70582: MacOSFontEntry::IsCFF()
70582: {
70582:     if (!mIsCFFInitialized) {
70582:         mIsCFFInitialized = PR_TRUE;
70582:         mIsCFF = HasFontTable(TRUETYPE_TAG('C','F','F',' '));
70582:     }
70582: 
70582:     return mIsCFF;
70582: }
70582: 
70582: /* ATSFontEntry - used on Mac OS X 10.5.x */
70582: #pragma mark-
70582: 
70582: ATSFontEntry::ATSFontEntry(const nsAString& aPostscriptName,
70582:                            PRInt32 aWeight,
70582:                            gfxFontFamily *aFamily,
70582:                            PRBool aIsStandardFace)
70582:     : MacOSFontEntry(aPostscriptName, aWeight, aFamily, aIsStandardFace),
70582:       mATSFontRef(kInvalidFont),
70582:       mATSFontRefInitialized(PR_FALSE)
70582: {
70582: }
70582: 
70582: ATSFontEntry::ATSFontEntry(const nsAString& aPostscriptName,
70582:                            ATSFontRef aFontRef,
70582:                            PRUint16 aWeight, PRUint16 aStretch,
70582:                            PRUint32 aItalicStyle,
70582:                            gfxUserFontData *aUserFontData,
70582:                            PRBool aIsLocal)
70582:     : MacOSFontEntry(aPostscriptName, aWeight, nsnull, PR_FALSE)
70582: {
70582:     mATSFontRef = aFontRef;
70582:     mATSFontRefInitialized = PR_TRUE;
70582: 
70582:     mWeight = aWeight;
70582:     mStretch = aStretch;
70582:     mFixedPitch = PR_FALSE; // xxx - do we need this for downloaded fonts?
70582:     mItalic = (aItalicStyle & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) != 0;
70582:     mUserFontData = aUserFontData;
70582:     mIsUserFont = (aUserFontData != nsnull) || aIsLocal;
70582:     mIsLocalUserFont = aIsLocal;
70582: }
70582: 
70582: ATSFontRef
70582: ATSFontEntry::GetATSFontRef()
70582: {
70582:     if (!mATSFontRefInitialized) {
70582:         mATSFontRefInitialized = PR_TRUE;
70582:         NSString *psname = GetNSStringForString(mName);
70582:         mATSFontRef = ::ATSFontFindFromPostScriptName(CFStringRef(psname),
70582:                                                       kATSOptionFlagsDefault);
70582:     }
70582:     return mATSFontRef;
70582: }
70582: 
70582: CGFontRef
70582: ATSFontEntry::GetFontRef()
70582: {
70582:     if (mFontRefInitialized) {
70582:         return mFontRef;
70582:     }
70582: 
70582:     // GetATSFontRef will initialize mATSFontRef
70582:     if (GetATSFontRef() == kInvalidFont) {
70582:         return nsnull;
70582:     }
70582:     
70582:     mFontRef = ::CGFontCreateWithPlatformFont(&mATSFontRef);
70582:     mFontRefInitialized = PR_TRUE;
70582: 
70582:     return mFontRef;
70582: }
70582: 
31590: nsresult
70582: ATSFontEntry::GetFontTable(PRUint32 aTableTag, FallibleTArray<PRUint8>& aBuffer)
31590: {
39159:     nsAutoreleasePool localPool;
39159: 
70582:     ATSFontRef fontRef = GetATSFontRef();
70582:     if (fontRef == kInvalidFont) {
31590:         return NS_ERROR_FAILURE;
43526:     }
10880: 
31590:     ByteCount dataLength;
31590:     OSStatus status = ::ATSFontGetTable(fontRef, aTableTag, 0, 0, 0, &dataLength);
43526:     if (status != noErr) {
43526:         return NS_ERROR_FAILURE;
43526:     }
31590: 
43526:     if (!aBuffer.AppendElements(dataLength)) {
31590:         return NS_ERROR_OUT_OF_MEMORY;
43526:     }
31590:     PRUint8 *dataPtr = aBuffer.Elements();
31590: 
31590:     status = ::ATSFontGetTable(fontRef, aTableTag, 0, dataLength, dataPtr, &dataLength);
31590:     NS_ENSURE_TRUE(status == noErr, NS_ERROR_FAILURE);
31590: 
31590:     return NS_OK;
31590: }
31590:  
70582: PRBool
70582: ATSFontEntry::HasFontTable(PRUint32 aTableTag)
37211: {
70582:     ATSFontRef fontRef = GetATSFontRef();
70582:     ByteCount size;
70582:     return fontRef != kInvalidFont &&
70582:         (::ATSFontGetTable(fontRef, aTableTag, 0, 0, 0, &size) == noErr);
70582: }
70582: 
70582: /* CGFontEntry - used on Mac OS X 10.6+ */
70582: #pragma mark-
70582: 
70582: CGFontEntry::CGFontEntry(const nsAString& aPostscriptName,
70582:                          PRInt32 aWeight,
70582:                          gfxFontFamily *aFamily,
70582:                          PRBool aIsStandardFace)
70582:     : MacOSFontEntry(aPostscriptName, aWeight, aFamily, aIsStandardFace)
70582: {
70582: }
70582: 
70582: CGFontEntry::CGFontEntry(const nsAString& aPostscriptName,
70582:                          CGFontRef aFontRef,
70582:                          PRUint16 aWeight, PRUint16 aStretch,
70582:                          PRUint32 aItalicStyle,
70582:                          PRBool aIsUserFont, PRBool aIsLocal)
70582:     : MacOSFontEntry(aPostscriptName, aWeight, nsnull, PR_FALSE)
70582: {
70582:     mFontRef = aFontRef;
70582:     mFontRefInitialized = PR_TRUE;
70582:     ::CFRetain(mFontRef);
70582: 
70582:     mWeight = aWeight;
70582:     mStretch = aStretch;
70582:     mFixedPitch = PR_FALSE; // xxx - do we need this for downloaded fonts?
70582:     mItalic = (aItalicStyle & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) != 0;
70582:     mIsUserFont = aIsUserFont;
70582:     mIsLocalUserFont = aIsLocal;
70582: }
70582: 
70582: CGFontRef
70582: CGFontEntry::GetFontRef()
70582: {
70582:     if (!mFontRefInitialized) {
70582:         mFontRefInitialized = PR_TRUE;
70582:         NSString *psname = GetNSStringForString(mName);
70582:         mFontRef = ::CGFontCreateWithFontName(CFStringRef(psname));
70582:     }
70582:     return mFontRef;
70582: }
70582: 
70582: nsresult
70582: CGFontEntry::GetFontTable(PRUint32 aTableTag, FallibleTArray<PRUint8>& aBuffer)
70582: {
70582:     nsAutoreleasePool localPool;
70582: 
70582:     CGFontRef fontRef = GetFontRef();
70582:     if (!fontRef) {
70582:         return NS_ERROR_FAILURE;
70582:     }
70582: 
70582:     CFDataRef tableData = ::CGFontCopyTableForTag(fontRef, aTableTag);
70582:     if (!tableData) {
70582:         return NS_ERROR_FAILURE;
70582:     }
70582: 
70582:     nsresult rval = NS_OK;
70582:     CFIndex dataLength = ::CFDataGetLength(tableData);
70582:     if (aBuffer.AppendElements(dataLength)) {
70582:         ::CFDataGetBytes(tableData, ::CFRangeMake(0, dataLength),
70582:                          aBuffer.Elements());
70582:     } else {
70582:         rval = NS_ERROR_OUT_OF_MEMORY;
70582:     }
70582:     ::CFRelease(tableData);
70582: 
70582:     return rval;
37211: }
37211: 
55074: PRBool
70582: CGFontEntry::HasFontTable(PRUint32 aTableTag)
55074: {
70582:     nsAutoreleasePool localPool;
70582: 
70582:     CGFontRef fontRef = GetFontRef();
70582:     if (!fontRef) {
70582:         return PR_FALSE;
55074:     }
55074: 
70582:     CFDataRef tableData = ::CGFontCopyTableForTag(fontRef, aTableTag);
70582:     if (!tableData) {
70582:         return PR_FALSE;
55074:     }
55074: 
70582:     ::CFRelease(tableData);
70582:     return PR_TRUE;
70582: }
31590: 
33382: /* gfxMacFontFamily */
33382: #pragma mark-
33382: 
33382: class gfxMacFontFamily : public gfxFontFamily
33382: {
33382: public:
33382:     gfxMacFontFamily(nsAString& aName) :
33382:         gfxFontFamily(aName)
33382:     {}
33382: 
33382:     virtual ~gfxMacFontFamily() {}
33382: 
33382:     virtual void LocalizedName(nsAString& aLocalizedName);
35525: 
35525:     virtual void FindStyleVariations();
33382: };
33382: 
33382: void
33382: gfxMacFontFamily::LocalizedName(nsAString& aLocalizedName)
33382: {
39159:     nsAutoreleasePool localPool;
39159: 
33382:     if (!HasOtherFamilyNames()) {
33382:         aLocalizedName = mName;
33382:         return;
33382:     }
33382: 
33382:     NSString *family = GetNSStringForString(mName);
35525:     NSString *localized = [sFontManager
33382:                            localizedNameForFamily:family
33382:                                              face:nil];
33382: 
33382:     if (localized) {
33382:         GetStringForNSString(localized, aLocalizedName);
33382:         return;
33382:     }
33382: 
33382:     // failed to get localized name, just use the canonical one
33382:     aLocalizedName = mName;
33382: }
33382: 
35525: void
35525: gfxMacFontFamily::FindStyleVariations()
35525: {
35525:     if (mHasStyles)
35525:         return;
35525: 
39159:     nsAutoreleasePool localPool;
39159: 
35525:     NSString *family = GetNSStringForString(mName);
35525: 
35525:     // create a font entry for each face
35525:     NSArray *fontfaces = [sFontManager
35525:                           availableMembersOfFontFamily:family];  // returns an array of [psname, style name, weight, traits] elements, goofy api
35525:     int faceCount = [fontfaces count];
35525:     int faceIndex;
35525: 
35525:     // Bug 420981 - under 10.5, UltraLight and Light have the same weight value
35525:     PRBool needToCheckLightFaces =
35525:         (gfxPlatformMac::GetPlatform()->OSXVersion() >= MAC_OS_X_VERSION_10_5_HEX);
35525: 
35525:     for (faceIndex = 0; faceIndex < faceCount; faceIndex++) {
35525:         NSArray *face = [fontfaces objectAtIndex:faceIndex];
35525:         NSString *psname = [face objectAtIndex:INDEX_FONT_POSTSCRIPT_NAME];
35525:         PRInt32 appKitWeight = [[face objectAtIndex:INDEX_FONT_WEIGHT] unsignedIntValue];
35525:         PRUint32 macTraits = [[face objectAtIndex:INDEX_FONT_TRAITS] unsignedIntValue];
35525:         NSString *facename = [face objectAtIndex:INDEX_FONT_FACE_NAME];
35525:         PRBool isStandardFace = PR_FALSE;
35525: 
35525:         if (needToCheckLightFaces && appKitWeight == kAppleExtraLightWeight) {
35525:             // if the facename contains UltraLight, set the weight to the ultralight weight value
35525:             NSRange range = [facename rangeOfString:@"ultralight" options:NSCaseInsensitiveSearch];
35525:             if (range.location != NSNotFound) {
35525:                 appKitWeight = kAppleUltraLightWeight;
35525:             }
35525:         }
35525: 
35525:         PRInt32 cssWeight = gfxMacPlatformFontList::AppleWeightToCSSWeight(appKitWeight) * 100;
35525: 
35525:         // make a nsString
35525:         nsAutoString postscriptFontName;
35525:         GetStringForNSString(psname, postscriptFontName);
35525: 
35525:         if ([facename isEqualToString:@"Regular"] ||
35525:             [facename isEqualToString:@"Bold"] ||
35525:             [facename isEqualToString:@"Italic"] ||
35525:             [facename isEqualToString:@"Oblique"] ||
35525:             [facename isEqualToString:@"Bold Italic"] ||
35525:             [facename isEqualToString:@"Bold Oblique"])
35525:         {
35525:             isStandardFace = PR_TRUE;
35525:         }
35525: 
35525:         // create a font entry
70582:         MacOSFontEntry *fontEntry;
70582:         if (gfxMacPlatformFontList::UseATSFontEntry()) {
70582:             fontEntry = new ATSFontEntry(postscriptFontName,
35525:                                          cssWeight, this, isStandardFace);
70582:         } else {
70582:             fontEntry = new CGFontEntry(postscriptFontName,
70582:                                         cssWeight, this, isStandardFace);
70582:         }
70582:         if (!fontEntry) {
70582:             break;
70582:         }
35525: 
35525:         // set additional properties based on the traits reported by Cocoa
35525:         if (macTraits & (NSCondensedFontMask | NSNarrowFontMask | NSCompressedFontMask)) {
35525:             fontEntry->mStretch = NS_FONT_STRETCH_CONDENSED;
35525:         } else if (macTraits & NSExpandedFontMask) {
35525:             fontEntry->mStretch = NS_FONT_STRETCH_EXPANDED;
35525:         }
57566:         // Cocoa fails to set the Italic traits bit for HelveticaLightItalic,
57566:         // at least (see bug 611855), so check for style name endings as well
57566:         if ((macTraits & NSItalicFontMask) ||
57566:             [facename hasSuffix:@"Italic"] ||
57566:             [facename hasSuffix:@"Oblique"])
57566:         {
35525:             fontEntry->mItalic = PR_TRUE;
35525:         }
35525:         if (macTraits & NSFixedPitchFontMask) {
35525:             fontEntry->mFixedPitch = PR_TRUE;
35525:         }
35525: 
36949: #ifdef PR_LOGGING
61084:         if (LOG_FONTLIST_ENABLED()) {
61084:             LOG_FONTLIST(("(fontlist) added (%s) to family (%s)"
36949:                  " with style: %s weight: %d stretch: %d"
36949:                  " (apple-weight: %d macTraits: %8.8x)",
36949:                  NS_ConvertUTF16toUTF8(fontEntry->Name()).get(), 
36949:                  NS_ConvertUTF16toUTF8(Name()).get(), 
36949:                  fontEntry->IsItalic() ? "italic" : "normal",
36949:                  cssWeight, fontEntry->Stretch(),
36949:                  appKitWeight, macTraits));
36949:         }
36949: #endif
36949: 
35525:         // insert into font entry array of family
35525:         AddFontEntry(fontEntry);
35525:     }
35525: 
35525:     SortAvailableFonts();
35525:     SetHasStyles(PR_TRUE);
35525: 
35525:     if (mIsBadUnderlineFamily) {
35525:         SetBadUnderlineFonts();
35525:     }
35525: }
35525: 
33382: 
33382: /* gfxSingleFaceMacFontFamily */
33382: #pragma mark-
33382: 
33382: class gfxSingleFaceMacFontFamily : public gfxFontFamily
33382: {
33382: public:
33382:     gfxSingleFaceMacFontFamily(nsAString& aName) :
33382:         gfxFontFamily(aName)
33382:     {}
33382: 
33382:     virtual ~gfxSingleFaceMacFontFamily() {}
33382: 
33382:     virtual void LocalizedName(nsAString& aLocalizedName);
33382: 
37618:     virtual void ReadOtherFamilyNames(gfxPlatformFontList *aPlatformFontList);
33382: };
33382: 
33382: void
33382: gfxSingleFaceMacFontFamily::LocalizedName(nsAString& aLocalizedName)
33382: {
39159:     nsAutoreleasePool localPool;
39159: 
33382:     if (!HasOtherFamilyNames()) {
33382:         aLocalizedName = mName;
33382:         return;
33382:     }
33382: 
33382:     gfxFontEntry *fe = mAvailableFonts[0];
33382:     NSFont *font = [NSFont fontWithName:GetNSStringForString(fe->Name())
33382:                                    size:0.0];
33382:     if (font) {
33382:         NSString *localized = [font displayName];
33382:         if (localized) {
33382:             GetStringForNSString(localized, aLocalizedName);
33382:             return;
33382:         }
33382:     }
33382: 
33382:     // failed to get localized name, just use the canonical one
33382:     aLocalizedName = mName;
33382: }
33382: 
33382: void
37618: gfxSingleFaceMacFontFamily::ReadOtherFamilyNames(gfxPlatformFontList *aPlatformFontList)
33382: {
33382:     if (mOtherFamilyNamesInitialized)
33382:         return;
33382: 
37618:     gfxFontEntry *fe = mAvailableFonts[0];
37618:     if (!fe)
37618:         return;
37618: 
37618:     const PRUint32 kNAME = TRUETYPE_TAG('n','a','m','e');
60098:     AutoFallibleTArray<PRUint8,8192> buffer;
37618: 
37618:     if (fe->GetFontTable(kNAME, buffer) != NS_OK)
37618:         return;
37618: 
37618:     mHasOtherFamilyNames = ReadOtherFamilyNamesForFace(aPlatformFontList,
37618:                                                        buffer,
33382:                                                        PR_TRUE);
33382:     mOtherFamilyNamesInitialized = PR_TRUE;
33382: }
33382: 
33382: 
31590: /* gfxMacPlatformFontList */
11086: #pragma mark-
10880: 
35525: gfxMacPlatformFontList::gfxMacPlatformFontList() :
37618:     gfxPlatformFontList(PR_FALSE), mATSGeneration(PRUint32(kATSGenerationInitial))
11991: {
11991:     ::ATSFontNotificationSubscribe(ATSNotification,
11991:                                    kATSFontNotifyOptionDefault,
11991:                                    (void*)this, nsnull);
11991: 
31590:     // this should always be available (though we won't actually fail if it's missing,
31590:     // we'll just end up doing a search and then caching the new result instead)
31590:     mReplacementCharFallbackFamily = NS_LITERAL_STRING("Lucida Grande");
35525: 
35525:     // cache this in a static variable so that MacOSFontFamily objects
35525:     // don't have to repeatedly look it up
35525:     sFontManager = [NSFontManager sharedFontManager];
11991: }
11991: 
57104: nsresult
31590: gfxMacPlatformFontList::InitFontList()
    1: {
39159:     nsAutoreleasePool localPool;
39159: 
31590:     ATSGeneration currentGeneration = ::ATSGetGeneration();
19962: 
19962:     // need to ignore notifications after adding each font
19962:     if (mATSGeneration == currentGeneration)
57104:         return NS_OK;
19962: 
19962:     mATSGeneration = currentGeneration;
61084: #ifdef PR_LOGGING
61084:     LOG_FONTLIST(("(fontlist) updating to generation: %d", mATSGeneration));
61084: #endif
19962: 
37618:     // reset font lists
37618:     gfxPlatformFontList::InitFontList();
    1:     
10880:     // iterate over available families
35525:     NSEnumerator *families = [[sFontManager availableFontFamilies]
35525:                               objectEnumerator];  // returns "canonical", non-localized family name
    1: 
35525:     nsAutoString availableFamilyName;
    1: 
10880:     NSString *availableFamily = nil;
10880:     while ((availableFamily = [families nextObject])) {
10880: 
10880:         // make a nsString
10880:         GetStringForNSString(availableFamily, availableFamilyName);
10880: 
10880:         // create a family entry
33382:         gfxFontFamily *familyEntry = new gfxMacFontFamily(availableFamilyName);
10880:         if (!familyEntry) break;
10880: 
10880:         // add the family entry to the hash table
10880:         ToLowerCase(availableFamilyName);
10880:         mFontFamilies.Put(availableFamilyName, familyEntry);
37599: 
37599:         // check the bad underline blacklist
38060:         if (mBadUnderlineFamilyNames.Contains(availableFamilyName))
37599:             familyEntry->SetBadUnderlineFamily();
    1:     }
    1: 
12239:     InitSingleFaceList();
12239: 
11991:     // to avoid full search of font name tables, seed the other names table with localized names from
11991:     // some of the prefs fonts which are accessed via their localized names.  changes in the pref fonts will only cause
11991:     // a font lookup miss earlier. this is a simple optimization, it's not required for correctness
12239:     PreloadNamesList();
10880: 
13877:     // start the delayed cmap loader
13877:     StartLoader(kDelayBeforeLoadingCmaps, kIntervalBetweenLoadingCmaps);
57104: 
57104: 	return NS_OK;
11991: }
11991: 
11991: void
31590: gfxMacPlatformFontList::InitSingleFaceList()
12239: {
14457:     nsAutoTArray<nsString, 10> singleFaceFonts;
12239:     gfxFontUtils::GetPrefsFontList("font.single-face-list", singleFaceFonts);
12239: 
12239:     PRUint32 numFonts = singleFaceFonts.Length();
12239:     for (PRUint32 i = 0; i < numFonts; i++) {
61084: #ifdef PR_LOGGING
61084:         LOG_FONTLIST(("(fontlist-singleface) face name: %s\n",
31590:                       NS_ConvertUTF16toUTF8(singleFaceFonts[i]).get()));
61084: #endif
31590:         gfxFontEntry *fontEntry = LookupLocalFont(nsnull, singleFaceFonts[i]);
12239:         if (fontEntry) {
31590:             nsAutoString familyName, key;
31590:             familyName = singleFaceFonts[i];
31590:             GenerateFontListKey(familyName, key);
61084: #ifdef PR_LOGGING
61084:             LOG_FONTLIST(("(fontlist-singleface) family name: %s, key: %s\n",
61084:                           NS_ConvertUTF16toUTF8(familyName).get(),
61084:                           NS_ConvertUTF16toUTF8(key).get()));
61084: #endif
12239: 
12239:             // add only if doesn't exist already
31590:             PRBool found;
31590:             gfxFontFamily *familyEntry;
12989:             if (!(familyEntry = mFontFamilies.GetWeak(key, &found))) {
33382:                 familyEntry = new gfxSingleFaceMacFontFamily(familyName);
12239:                 familyEntry->AddFontEntry(fontEntry);
31590:                 familyEntry->SetHasStyles(PR_TRUE);
12239:                 mFontFamilies.Put(key, familyEntry);
31590:                 fontEntry->mFamily = familyEntry;
61084: #ifdef PR_LOGGING
61084:                 LOG_FONTLIST(("(fontlist-singleface) added new family\n",
61084:                               NS_ConvertUTF16toUTF8(familyName).get(),
61084:                               NS_ConvertUTF16toUTF8(key).get()));
61084: #endif
12239:             }
12239:         }
12239:     }
12239: }
12239: 
31590: PRBool
31590: gfxMacPlatformFontList::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
14465: {
31590:     gfxFontFamily *family = FindFamily(aFontName);
11991:     if (family) {
33382:         family->LocalizedName(aFamilyName);
13003:         return PR_TRUE;
13003:     }
13003: 
13003:     // Gecko 1.8 used Quickdraw font api's which produce a slightly different set of "family"
13003:     // names.  Try to resolve based on these names, in case this is stored in an old profile
31590:     // 1.8: "Futura", "Futura Condensed" ==> 1.9: "Futura"
13003: 
31590:     // convert the name to a Pascal-style Str255 to try as Quickdraw name
31590:     Str255 qdname;
31590:     NS_ConvertUTF16toUTF8 utf8name(aFontName);
31590:     qdname[0] = PR_MAX(255, strlen(utf8name.get()));
31590:     memcpy(&qdname[1], utf8name.get(), qdname[0]);
13003: 
31590:     // look up the Quickdraw name
31590:     ATSFontFamilyRef atsFamily = ::ATSFontFamilyFindFromQuickDrawName(qdname);
31590:     if (atsFamily == (ATSFontFamilyRef)kInvalidFontFamily) {
13003:         return PR_FALSE;
31590:     }
13003: 
31590:     // if we found a family, get its ATS name
31590:     CFStringRef cfName;
31590:     OSStatus status = ::ATSFontFamilyGetName(atsFamily, kATSOptionFlagsDefault, &cfName);
31590:     if (status != noErr) {
13003:         return PR_FALSE;
31590:     }
13003: 
31590:     // then use this to locate the family entry and retrieve its localized name
31590:     nsAutoString familyName;
31590:     GetStringForNSString((const NSString*)cfName, familyName);
31590:     ::CFRelease(cfName);
13003: 
13003:     family = FindFamily(familyName);
13003:     if (family) {
33382:         family->LocalizedName(aFamilyName);
13003:         return PR_TRUE;
13003:     }
13003: 
13003:     return PR_FALSE;
13003: }
13003: 
10880: void
31590: gfxMacPlatformFontList::ATSNotification(ATSFontNotificationInfoRef aInfo,
10880:                                     void* aUserArg)
10880: {
10880:     // xxx - should be carefully pruning the list of fonts, not rebuilding it from scratch
31590:     gfxMacPlatformFontList *qfc = (gfxMacPlatformFontList*)aUserArg;
10880:     qfc->UpdateFontList();
10880: }
10880: 
31590: gfxFontEntry*
31590: gfxMacPlatformFontList::GetDefaultFont(const gfxFontStyle* aStyle, PRBool& aNeedsBold)
10880: {
39159:     nsAutoreleasePool localPool;
39159: 
10880:     NSString *defaultFamily = [[NSFont userFontOfSize:aStyle->size] familyName];
10880:     nsAutoString familyName;
10880: 
10880:     GetStringForNSString(defaultFamily, familyName);
13339:     return FindFontForFamily(familyName, aStyle, aNeedsBold);
    1: }
    1: 
10880: PRInt32
31590: gfxMacPlatformFontList::AppleWeightToCSSWeight(PRInt32 aAppleWeight)
10880: {
10880:     if (aAppleWeight < 1)
10880:         aAppleWeight = 1;
10880:     else if (aAppleWeight > kAppleMaxWeight)
10880:         aAppleWeight = kAppleMaxWeight;
10880:     return gAppleWeightToCSSWeight[aAppleWeight];
 9699: }
 9699: 
19962: gfxFontEntry*
31590: gfxMacPlatformFontList::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
24932:                                         const nsAString& aFontName)
19962: {
39159:     nsAutoreleasePool localPool;
39159: 
19962:     NSString *faceName = GetNSStringForString(aFontName);
70582:     MacOSFontEntry *newFontEntry;
19962: 
70582:     if (UseATSFontEntry()) {
24932:         // first lookup a single face based on postscript name
31590:         ATSFontRef fontRef = ::ATSFontFindFromPostScriptName(CFStringRef(faceName),
24932:                                                              kATSOptionFlagsDefault);
19962: 
24932:         // if not found, lookup using full font name
70582:         if (fontRef == kInvalidFont) {
31590:             fontRef = ::ATSFontFindFromName(CFStringRef(faceName),
24932:                                             kATSOptionFlagsDefault);
70582:             if (fontRef == kInvalidFont) {
70582:                 return nsnull;
70582:             }
70582:         }
19962: 
31590:         if (aProxyEntry) {
24932:             PRUint16 w = aProxyEntry->mWeight;
24932:             NS_ASSERTION(w >= 100 && w <= 900, "bogus font weight value!");
24932:  
31590:             newFontEntry =
70582:                 new ATSFontEntry(aFontName, fontRef,
24932:                                  w, aProxyEntry->mStretch,
31590:                                  aProxyEntry->mItalic ?
31590:                                      FONT_STYLE_ITALIC : FONT_STYLE_NORMAL,
70582:                                  nsnull, PR_TRUE);
31590:         } else {
31590:             newFontEntry =
70582:                 new ATSFontEntry(aFontName, fontRef,
70582:                                  400, 0, FONT_STYLE_NORMAL, nsnull, PR_FALSE);
70582:         }
70582:     } else {
70582:         // lookup face based on postscript or full name
70582:         CGFontRef fontRef = ::CGFontCreateWithFontName(CFStringRef(faceName));
70582:         if (!fontRef) {
70582:             return nsnull;
70582:         }
70582: 
70582:         if (aProxyEntry) {
70582:             PRUint16 w = aProxyEntry->mWeight;
70582:             NS_ASSERTION(w >= 100 && w <= 900, "bogus font weight value!");
70582: 
70582:             newFontEntry =
70582:                 new CGFontEntry(aFontName, fontRef,
70582:                                 w, aProxyEntry->mStretch,
70582:                                 aProxyEntry->mItalic ?
70582:                                     FONT_STYLE_ITALIC : FONT_STYLE_NORMAL,
70582:                                 PR_TRUE, PR_TRUE);
70582:         } else {
70582:             newFontEntry =
70582:                 new CGFontEntry(aFontName, fontRef,
70582:                                 400, 0, FONT_STYLE_NORMAL,
70582:                                 PR_FALSE, PR_FALSE);
70582:         }
70582:         ::CFRelease(fontRef);
31590:     }
24932: 
24932:     return newFontEntry;
19962: }
19962: 
70582: gfxFontEntry*
70582: gfxMacPlatformFontList::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
70582:                                          const PRUint8 *aFontData,
70582:                                          PRUint32 aLength)
70582: {
70582:     return UseATSFontEntry()
70582:         ? MakePlatformFontATS(aProxyEntry, aFontData, aLength)
70582:         : MakePlatformFontCG(aProxyEntry, aFontData, aLength);
70582: }
70582: 
70582: static void ReleaseData(void *info, const void *data, size_t size)
70582: {
70582:     NS_Free((void*)data);
70582: }
70582: 
70582: gfxFontEntry*
70582: gfxMacPlatformFontList::MakePlatformFontCG(const gfxProxyFontEntry *aProxyEntry,
70582:                                            const PRUint8 *aFontData,
70582:                                            PRUint32 aLength)
70582: {
70582:     NS_ASSERTION(aFontData, "MakePlatformFont called with null data");
70582: 
70582:     PRUint16 w = aProxyEntry->mWeight;
70582:     NS_ASSERTION(w >= 100 && w <= 900, "bogus font weight value!");
70582: 
70582:     // create the font entry
70582:     nsAutoString uniqueName;
70582: 
70582:     nsresult rv = gfxFontUtils::MakeUniqueUserFontName(uniqueName);
70582:     if (NS_FAILED(rv)) {
70582:         return nsnull;
70582:     }
70582: 
70582:     CGDataProviderRef provider =
70582:         ::CGDataProviderCreateWithData(nsnull, aFontData, aLength,
70582:                                        &ReleaseData);
70582:     CGFontRef fontRef = ::CGFontCreateWithDataProvider(provider);
70582:     ::CGDataProviderRelease(provider);
70582: 
70582:     if (!fontRef) {
70582:         return nsnull;
70582:     }
70582: 
70582:     nsAutoPtr<CGFontEntry>
70582:         newFontEntry(new CGFontEntry(uniqueName, fontRef, w,
70582:                                      aProxyEntry->mStretch,
70582:                                      aProxyEntry->mItalic ?
70582:                                          FONT_STYLE_ITALIC : FONT_STYLE_NORMAL,
70582:                                      PR_TRUE, PR_FALSE));
70582: 
70582:     // if succeeded and font cmap is good, return the new font
70582:     if (newFontEntry->mIsValid && NS_SUCCEEDED(newFontEntry->ReadCMAP())) {
70582:         return newFontEntry.forget();
70582:     }
70582: 
70582:     // if something is funky about this font, delete immediately
70582: #if DEBUG
70582:     char warnBuf[1024];
70582:     sprintf(warnBuf, "downloaded font not loaded properly, removed face for (%s)",
70582:             NS_ConvertUTF16toUTF8(aProxyEntry->mFamily->Name()).get());
70582:     NS_WARNING(warnBuf);
70582: #endif
70582: 
70582:     return nsnull;
70582: }
70582: 
19962: // grumble, another non-publised Apple API dependency (found in Webkit code)
19962: // activated with this value, font will not be found via system lookup routines
26688: // it can only be used via the created ATSFontRef
19962: // needed to prevent one doc from finding a font used in a separate doc
19962: 
19962: enum {
19962:     kPrivateATSFontContextPrivate = 3
19962: };
19962: 
70582: class ATSUserFontData : public gfxUserFontData {
19962: public:
70582:     ATSUserFontData(ATSFontContainerRef aContainerRef)
21067:         : mContainerRef(aContainerRef)
19962:     { }
19962: 
70582:     virtual ~ATSUserFontData()
19962:     {
19962:         // deactivate font
70582:         if (mContainerRef) {
31590:             ::ATSFontDeactivate(mContainerRef, NULL, kATSOptionFlagsDefault);
19962:         }
70582:     }
19962: 
19962:     ATSFontContainerRef     mContainerRef;
19962: };
19962: 
19962: gfxFontEntry*
70582: gfxMacPlatformFontList::MakePlatformFontATS(const gfxProxyFontEntry *aProxyEntry,
32808:                                             const PRUint8 *aFontData,
32808:                                             PRUint32 aLength)
19962: {
19962:     OSStatus err;
19962: 
32808:     NS_ASSERTION(aFontData, "MakePlatformFont called with null data");
19962: 
36949:     // MakePlatformFont is responsible for deleting the font data with NS_Free
36949:     // so we set up a stack object to ensure it is freed even if we take an
36949:     // early exit
36949:     struct FontDataDeleter {
36949:         FontDataDeleter(const PRUint8 *aFontData)
36949:             : mFontData(aFontData) { }
36949:         ~FontDataDeleter() { NS_Free((void*)mFontData); }
36949:         const PRUint8 *mFontData;
36949:     };
36949:     FontDataDeleter autoDelete(aFontData);
36949: 
22982:     ATSFontRef fontRef;
19962:     ATSFontContainerRef containerRef;
19962: 
22982:     // we get occasional failures when multiple fonts are activated in quick succession
22982:     // if the ATS font cache is damaged; to work around this, we can retry the activation
22982:     const PRUint32 kMaxRetries = 3;
22982:     PRUint32 retryCount = 0;
22982:     while (retryCount++ < kMaxRetries) {
31590:         err = ::ATSFontActivateFromMemory(const_cast<PRUint8*>(aFontData), aLength,
19962:                                           kPrivateATSFontContextPrivate,
19962:                                           kATSFontFormatUnspecified,
19962:                                           NULL,
19962:                                           kATSOptionFlagsDoNotNotify,
19962:                                           &containerRef);
31590:         mATSGeneration = ::ATSGetGeneration();
21067: 
21067:         if (err != noErr) {
21067: #if DEBUG
21067:             char warnBuf[1024];
21067:             sprintf(warnBuf, "downloaded font error, ATSFontActivateFromMemory err: %d for (%s)",
21067:                     PRInt32(err),
36949:                     NS_ConvertUTF16toUTF8(aProxyEntry->mFamily->Name()).get());
21067:             NS_WARNING(warnBuf);
21067: #endif
19962:             return nsnull;
21067:         }
19962: 
19962:         // ignoring containers with multiple fonts, use the first face only for now
31590:         err = ::ATSFontFindFromContainer(containerRef, kATSOptionFlagsDefault, 1,
22982:                                          &fontRef, NULL);
21067:         if (err != noErr) {
21067: #if DEBUG
21067:             char warnBuf[1024];
21067:             sprintf(warnBuf, "downloaded font error, ATSFontFindFromContainer err: %d for (%s)",
21067:                     PRInt32(err),
36949:                     NS_ConvertUTF16toUTF8(aProxyEntry->mFamily->Name()).get());
21067:             NS_WARNING(warnBuf);
21067: #endif
31590:             ::ATSFontDeactivate(containerRef, NULL, kATSOptionFlagsDefault);
19962:             return nsnull;
21067:         }
19962: 
22982:         // now lookup the Postscript name; this may fail if the font cache is bad
22982:         OSStatus err;
22982:         NSString *psname = NULL;
31590:         err = ::ATSFontGetPostScriptName(fontRef, kATSOptionFlagsDefault, (CFStringRef*) (&psname));
22982:         if (err == noErr) {
22982:             [psname release];
22982:         } else {
22982: #ifdef DEBUG
22982:             char warnBuf[1024];
22982:             sprintf(warnBuf, "ATSFontGetPostScriptName err = %d for (%s), retries = %d", (PRInt32)err,
36949:                     NS_ConvertUTF16toUTF8(aProxyEntry->mFamily->Name()).get(), retryCount);
22982:             NS_WARNING(warnBuf);
22982: #endif
31590:             ::ATSFontDeactivate(containerRef, NULL, kATSOptionFlagsDefault);
22982:             // retry the activation a couple of times if this fails
22982:             // (may be a transient failure due to ATS font cache issues)
22982:             continue;
22982:         }
22982: 
70582:         PRUint16 w = aProxyEntry->mWeight;
70582:         NS_ASSERTION(w >= 100 && w <= 900, "bogus font weight value!");
21067: 
70582:         nsAutoString uniqueName;
70582:         nsresult rv = gfxFontUtils::MakeUniqueUserFontName(uniqueName);
70582:         if (NS_FAILED(rv)) {
19962:             return nsnull;
21067:         }
19962: 
70582:         // font entry will own this
70582:         ATSUserFontData *userFontData = new ATSUserFontData(containerRef);
19962: 
70582:         ATSFontEntry *newFontEntry =
70582:             new ATSFontEntry(uniqueName,
31590:                              fontRef,
22982:                              w, aProxyEntry->mStretch,
31590:                              aProxyEntry->mItalic ?
31590:                                  FONT_STYLE_ITALIC : FONT_STYLE_NORMAL,
70582:                              userFontData, PR_FALSE);
21067: 
32826:         // if succeeded and font cmap is good, return the new font
70582:         if (newFontEntry->mIsValid && NS_SUCCEEDED(newFontEntry->ReadCMAP())) {
22982:             return newFontEntry;
70582:         }
22982: 
19962:         // if something is funky about this font, delete immediately
19962: #if DEBUG
19962:         char warnBuf[1024];
21067:         sprintf(warnBuf, "downloaded font not loaded properly, removed face for (%s)",
36949:                 NS_ConvertUTF16toUTF8(aProxyEntry->mFamily->Name()).get());
19962:         NS_WARNING(warnBuf);
19962: #endif
19962:         delete newFontEntry;
22982: 
22982:         // We don't retry from here; the ATS font cache issue would have caused failure earlier
22982:         // so if we get here, there's something else bad going on within our font data structures.
22982:         // Currently, there should be no way to reach here, as fontentry creation cannot fail
22982:         // except by memory allocation failure.
22982:         NS_WARNING("invalid font entry for a newly activated font");
22982:         break;
19962:     }
19962: 
22982:     // if we get here, the activation failed (even with possible retries); can't use this font
22982:     return nsnull;
19962: }
