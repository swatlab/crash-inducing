42791: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
42791: /* ***** BEGIN LICENSE BLOCK *****
39997:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
39997:  *
39997:  * The contents of this file are subject to the Mozilla Public License Version
39997:  * 1.1 (the "License"); you may not use this file except in compliance with
39997:  * the License. You may obtain a copy of the License at
39997:  * http://www.mozilla.org/MPL/
39997:  *
39997:  * Software distributed under the License is distributed on an "AS IS" basis,
39997:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
39997:  * for the specific language governing rights and limitations under the
39997:  * License.
39997:  *
39997:  * The Original Code is Mozilla Corporation code.
39997:  *
39997:  * The Initial Developer of the Original Code is Mozilla Foundation.
39997:  * Portions created by the Initial Developer are Copyright (C) 2009
39997:  * the Initial Developer. All Rights Reserved.
39997:  *
39997:  * Contributor(s):
39997:  *   Bas Schouten <bschouten@mozilla.org>
42791:  *   Frederic Plourde <frederic.plourde@collabora.co.uk>
42791:  *   Vladimir Vukicevic <vladimir@pobox.com>
39997:  *
39997:  * Alternatively, the contents of this file may be used under the terms of
39997:  * either the GNU General Public License Version 2 or later (the "GPL"), or
39997:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
39997:  * in which case the provisions of the GPL or the LGPL are applicable instead
39997:  * of those above. If you wish to allow use of your version of this file only
39997:  * under the terms of either the GPL or the LGPL, and not to allow others to
39997:  * use your version of this file under the terms of the MPL, indicate your
39997:  * decision by deleting the provisions above and replace them with the notice
39997:  * and other provisions required by the GPL or the LGPL. If you do not delete
39997:  * the provisions above, a recipient may use your version of this file under
39997:  * the terms of any one of the MPL, the GPL or the LGPL.
39997:  *
39997:  * ***** END LICENSE BLOCK ***** */
39997: 
55452: #include "mozilla/layers/PLayers.h"
55452: 
80467: /* This must occur *after* layers/PLayers.h to avoid typedefs conflicts. */
80467: #include "mozilla/Util.h"
80467: 
39997: #include "LayerManagerOGL.h"
39997: #include "ThebesLayerOGL.h"
39997: #include "ContainerLayerOGL.h"
39997: #include "ImageLayerOGL.h"
42249: #include "ColorLayerOGL.h"
42402: #include "CanvasLayerOGL.h"
69696: #include "mozilla/TimeStamp.h"
77670: #include "mozilla/Preferences.h"
42402: 
39997: #include "LayerManagerOGLShaders.h"
39997: 
39997: #include "gfxContext.h"
39997: #include "nsIWidget.h"
39997: 
41370: #include "GLContext.h"
41370: #include "GLContextProvider.h"
39997: 
40577: #include "nsIServiceManager.h"
40577: #include "nsIConsoleService.h"
40577: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
39997: namespace mozilla {
39997: namespace layers {
39997: 
41370: using namespace mozilla::gl;
41370: 
60224: #ifdef CHECK_CURRENT_PROGRAM
42791: int LayerManagerOGLProgram::sCurrentProgramKey = 0;
60224: #endif
42791: 
39997: /**
39997:  * LayerManagerOGL
39997:  */
39997: LayerManagerOGL::LayerManagerOGL(nsIWidget *aWidget)
39997:   : mWidget(aWidget)
55451:   , mWidgetSize(-1, -1)
42791:   , mBackBufferFBO(0)
42791:   , mBackBufferTexture(0)
44202:   , mBackBufferSize(-1, -1)
42791:   , mHasBGRA(0)
39997: {
39997: }
39997: 
39997: LayerManagerOGL::~LayerManagerOGL()
39997: {
49072:   Destroy();
49072: }
49072: 
49072: void
49072: LayerManagerOGL::Destroy()
49072: {
49072:   if (!mDestroyed) {
49072:     if (mRoot) {
49072:       RootLayer()->Destroy();
49072:     }
47908:     mRoot = nsnull;
49072: 
49072:     // Make a copy, since SetLayerManager will cause mImageContainers
49072:     // to get mutated.
49072:     nsTArray<ImageContainer*> imageContainers(mImageContainers);
49072:     for (PRUint32 i = 0; i < imageContainers.Length(); ++i) {
49072:       ImageContainer *c = imageContainers[i];
49072:       c->SetLayerManager(nsnull);
49072:     }
49072: 
47908:     CleanupResources();
49072: 
80486:     mDestroyed = true;
49072:   }
47908: }
47908: 
47908: void
47908: LayerManagerOGL::CleanupResources()
47908: {
47908:   if (!mGLContext)
47908:     return;
47908: 
47967:   nsRefPtr<GLContext> ctx = mGLContext->GetSharedContext();
47967:   if (!ctx) {
47967:     ctx = mGLContext;
47967:   }
47967: 
47967:   ctx->MakeCurrent();
42791: 
42791:   for (unsigned int i = 0; i < mPrograms.Length(); ++i)
42791:     delete mPrograms[i];
47908:   mPrograms.Clear();
42791: 
47967:   ctx->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, 0);
47908: 
47908:   if (mBackBufferFBO) {
47967:     ctx->fDeleteFramebuffers(1, &mBackBufferFBO);
47908:     mBackBufferFBO = 0;
47908:   }
47908: 
47908:   if (mBackBufferTexture) {
47967:     ctx->fDeleteTextures(1, &mBackBufferTexture);
47908:     mBackBufferTexture = 0;
47908:   }
47908: 
47908:   if (mQuadVBO) {
47967:     ctx->fDeleteBuffers(1, &mQuadVBO);
47908:     mQuadVBO = 0;
47908:   }
47908: 
47908:   mGLContext = nsnull;
39997: }
39997: 
60832: already_AddRefed<mozilla::gl::GLContext>
60832: LayerManagerOGL::CreateContext()
39997: {
60832:   nsRefPtr<GLContext> context;
54214: 
53687: #ifdef XP_WIN
53687:   if (PR_GetEnv("MOZ_LAYERS_PREFER_EGL")) {
53687:     printf_stderr("Trying GL layers...\n");
60832:     context = gl::GLContextProviderEGL::CreateForWindow(mWidget);
53687:   }
53687: #endif
53687: 
60832:   if (!context)
60832:     context = gl::GLContextProvider::CreateForWindow(mWidget);
39997: 
60832:   if (!context) {
42791:     NS_WARNING("Failed to create LayerManagerOGL context");
60832:   }
60832:   return context.forget();
60832: }
60832: 
79445: bool
60832: LayerManagerOGL::Initialize(nsRefPtr<GLContext> aContext)
60832: {
63285:   ScopedGfxFeatureReporter reporter("GL Layers");
63285: 
60832:   // Do not allow double intiailization
60832:   NS_ABORT_IF_FALSE(mGLContext == nsnull, "Don't reiniailize layer managers");
60832: 
60832:   if (!aContext)
80486:     return false;
60832: 
60832:   mGLContext = aContext;
80486:   mGLContext->SetFlipped(true);
39997: 
39997:   MakeCurrent();
39997: 
49077:   mHasBGRA =
49077:     mGLContext->IsExtensionSupported(gl::GLContext::EXT_texture_format_BGRA8888) ||
49077:     mGLContext->IsExtensionSupported(gl::GLContext::EXT_bgra);
42791: 
42791:   mGLContext->fBlendFuncSeparate(LOCAL_GL_ONE, LOCAL_GL_ONE_MINUS_SRC_ALPHA,
42791:                                  LOCAL_GL_ONE, LOCAL_GL_ONE);
41370:   mGLContext->fEnable(LOCAL_GL_BLEND);
39997: 
42791:   // We unfortunately can't do generic initialization here, since the
42791:   // concrete type actually matters.  This macro generates the
42791:   // initialization using a concrete type and index.
42791: #define SHADER_PROGRAM(penum, ptype, vsstr, fsstr) do {                           \
42791:     NS_ASSERTION(programIndex++ == penum, "out of order shader initialization!"); \
42791:     ptype *p = new ptype(mGLContext);                                             \
47260:     if (!p->Initialize(vsstr, fsstr)) {                                           \
47260:       delete p;                                                                   \
80486:       return false;                                                            \
47260:     }                                                                             \
42791:     mPrograms.AppendElement(p);                                                   \
42791:   } while (0)
39997: 
39997: 
42791:   // NOTE: Order matters here, and should be in the same order as the
42791:   // ProgramType enum!
58638: #ifdef DEBUG
42791:   GLint programIndex = 0;
58638: #endif
39997: 
42791:   /* Layer programs */
42791:   SHADER_PROGRAM(RGBALayerProgramType, ColorTextureLayerProgram,
42791:                  sLayerVS, sRGBATextureLayerFS);
42791:   SHADER_PROGRAM(BGRALayerProgramType, ColorTextureLayerProgram,
42791:                  sLayerVS, sBGRATextureLayerFS);
42791:   SHADER_PROGRAM(RGBXLayerProgramType, ColorTextureLayerProgram,
42791:                  sLayerVS, sRGBXTextureLayerFS);
42791:   SHADER_PROGRAM(BGRXLayerProgramType, ColorTextureLayerProgram,
42791:                  sLayerVS, sBGRXTextureLayerFS);
42791:   SHADER_PROGRAM(RGBARectLayerProgramType, ColorTextureLayerProgram,
42791:                  sLayerVS, sRGBARectTextureLayerFS);
42791:   SHADER_PROGRAM(ColorLayerProgramType, SolidColorLayerProgram,
42791:                  sLayerVS, sSolidColorLayerFS);
42791:   SHADER_PROGRAM(YCbCrLayerProgramType, YCbCrTextureLayerProgram,
42791:                  sLayerVS, sYCbCrTextureLayerFS);
60740:   SHADER_PROGRAM(ComponentAlphaPass1ProgramType, ComponentAlphaTextureLayerProgram,
60740:                  sLayerVS, sComponentPass1FS);
60740:   SHADER_PROGRAM(ComponentAlphaPass2ProgramType, ComponentAlphaTextureLayerProgram,
60740:                  sLayerVS, sComponentPass2FS);
42791:   /* Copy programs (used for final framebuffer blit) */
42791:   SHADER_PROGRAM(Copy2DProgramType, CopyProgram,
42791:                  sCopyVS, sCopy2DFS);
42791:   SHADER_PROGRAM(Copy2DRectProgramType, CopyProgram,
42791:                  sCopyVS, sCopy2DRectFS);
39997: 
42791: #undef SHADER_PROGRAM
39997: 
42791:   NS_ASSERTION(programIndex == NumProgramTypes,
42791:                "not all programs were initialized!");
39997: 
42209:   /**
42209:    * We'll test the ability here to bind NPOT textures to a framebuffer, if
42791:    * this fails we'll try ARB_texture_rectangle.
42209:    */
42791:   mGLContext->fGenFramebuffers(1, &mBackBufferFBO);
42209: 
42791:   GLenum textureTargets[] = {
42791:     LOCAL_GL_TEXTURE_2D,
42791: #ifndef USE_GLES2
42791:     LOCAL_GL_TEXTURE_RECTANGLE_ARB
42791: #endif
42791:   };
42791: 
42791:   mFBOTextureTarget = LOCAL_GL_NONE;
42209: 
80467:   for (PRUint32 i = 0; i < ArrayLength(textureTargets); i++) {
42791:     GLenum target = textureTargets[i];
42791:     mGLContext->fGenTextures(1, &mBackBufferTexture);
42791:     mGLContext->fBindTexture(target, mBackBufferTexture);
42791:     mGLContext->fTexParameteri(target,
42209:                                LOCAL_GL_TEXTURE_MIN_FILTER,
42209:                                LOCAL_GL_NEAREST);
42791:     mGLContext->fTexParameteri(target,
42209:                                LOCAL_GL_TEXTURE_MAG_FILTER,
42209:                                LOCAL_GL_NEAREST);
42791:     mGLContext->fTexImage2D(target,
42209:                             0,
42209:                             LOCAL_GL_RGBA,
42791:                             5, 3, /* sufficiently NPOT */
42209:                             0,
42209:                             LOCAL_GL_RGBA,
42209:                             LOCAL_GL_UNSIGNED_BYTE,
42209:                             NULL);
42209: 
42791:     // unbind this texture, in preparation for binding it to the FBO
42791:     mGLContext->fBindTexture(target, 0);
42791: 
42791:     mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, mBackBufferFBO);
42209:     mGLContext->fFramebufferTexture2D(LOCAL_GL_FRAMEBUFFER,
42209:                                       LOCAL_GL_COLOR_ATTACHMENT0,
42791:                                       target,
42791:                                       mBackBufferTexture,
42209:                                       0);
42209: 
42209:     if (mGLContext->fCheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER) ==
42791:         LOCAL_GL_FRAMEBUFFER_COMPLETE)
42791:     {
42791:       mFBOTextureTarget = target;
42209:       break;
42209:     }
42209: 
42791:     // We weren't succesful with this texture, so we don't need it
42791:     // any more.
42791:     mGLContext->fDeleteTextures(1, &mBackBufferTexture);
42209:   }
42791: 
42791:   if (mFBOTextureTarget == LOCAL_GL_NONE) {
42209:     /* Unable to find a texture target that works with FBOs and NPOT textures */
42209:     return false;
42209:   }
42209: 
43628:   mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, 0);
43628: 
42791:   if (mFBOTextureTarget == LOCAL_GL_TEXTURE_RECTANGLE_ARB) {
42791:     /* If we're using TEXTURE_RECTANGLE, then we must have the ARB
42791:      * extension -- the EXT variant does not provide support for
42791:      * texture rectangle access inside GLSL (sampler2DRect,
42791:      * texture2DRect).
42791:      */
49077:     if (!mGLContext->IsExtensionSupported(gl::GLContext::ARB_texture_rectangle))
39997:       return false;
39997:   }
39997: 
42791:   // back to default framebuffer, to avoid confusion
42791:   mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, 0);
39997: 
42791:   /* Create a simple quad VBO */
42791: 
42791:   mGLContext->fGenBuffers(1, &mQuadVBO);
42791:   mGLContext->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, mQuadVBO);
42791: 
42791:   GLfloat vertices[] = {
42791:     /* First quad vertices */
42791:     0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
42791:     /* Then quad texcoords */
42791:     0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
42791:     /* Then flipped quad texcoords */
42791:     0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
42791:   };
41370:   mGLContext->fBufferData(LOCAL_GL_ARRAY_BUFFER, sizeof(vertices), vertices, LOCAL_GL_STATIC_DRAW);
82455:   mGLContext->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, 0);
39997: 
40577:   nsCOMPtr<nsIConsoleService>
40577:     console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
40577: 
40577:   if (console) {
40577:     nsString msg;
40577:     msg +=
40577:       NS_LITERAL_STRING("OpenGL LayerManager Initialized Succesfully.\nVersion: ");
40577:     msg += NS_ConvertUTF8toUTF16(
41370:       nsDependentCString((const char*)mGLContext->fGetString(LOCAL_GL_VERSION)));
40577:     msg += NS_LITERAL_STRING("\nVendor: ");
40577:     msg += NS_ConvertUTF8toUTF16(
41370:       nsDependentCString((const char*)mGLContext->fGetString(LOCAL_GL_VENDOR)));
40577:     msg += NS_LITERAL_STRING("\nRenderer: ");
40577:     msg += NS_ConvertUTF8toUTF16(
41370:       nsDependentCString((const char*)mGLContext->fGetString(LOCAL_GL_RENDERER)));
42791:     msg += NS_LITERAL_STRING("\nFBO Texture Target: ");
42791:     if (mFBOTextureTarget == LOCAL_GL_TEXTURE_2D)
42791:       msg += NS_LITERAL_STRING("TEXTURE_2D");
42791:     else
42791:       msg += NS_LITERAL_STRING("TEXTURE_RECTANGLE");
40577:     console->LogStringMessage(msg.get());
40577:   }
40577: 
77670:   Preferences::AddBoolVarCache(&sDrawFPS, "layers.acceleration.draw-fps");
77670: 
63285:   reporter.SetSuccessful();
39997:   return true;
39997: }
39997: 
39997: void
39997: LayerManagerOGL::SetClippingRegion(const nsIntRegion& aClippingRegion)
39997: {
39997:   mClippingRegion = aClippingRegion;
39997: }
39997: 
39997: void
39997: LayerManagerOGL::BeginTransaction()
39997: {
39997: }
39997: 
39997: void
39997: LayerManagerOGL::BeginTransactionWithTarget(gfxContext *aTarget)
39997: {
55450: #ifdef MOZ_LAYERS_HAVE_LOG
55450:   MOZ_LAYERS_LOG(("[----- BeginTransaction"));
55450:   Log();
55450: #endif
55450: 
49072:   if (mDestroyed) {
49072:     NS_WARNING("Call on destroyed layer manager");
49072:     return;
49072:   }
49072: 
39997:   mTarget = aTarget;
39997: }
39997: 
61836: bool
61836: LayerManagerOGL::EndEmptyTransaction()
61836: {
61836:   if (!mRoot)
61836:     return false;
61836: 
61836:   EndTransaction(nsnull, nsnull);
61836:   return true;
61836: }
61836: 
59171: void
42593: LayerManagerOGL::EndTransaction(DrawThebesLayerCallback aCallback,
78887:                                 void* aCallbackData,
78887:                                 EndTransactionFlags aFlags)
39997: {
55450: #ifdef MOZ_LAYERS_HAVE_LOG
55450:   MOZ_LAYERS_LOG(("  ----- (beginning paint)"));
55450:   Log();
55450: #endif
55450: 
49072:   if (mDestroyed) {
49072:     NS_WARNING("Call on destroyed layer manager");
59171:     return;
49072:   }
49072: 
78887:   if (mRoot && !(aFlags & END_NO_IMMEDIATE_REDRAW)) {
57097:     // The results of our drawing always go directly into a pixel buffer,
57097:     // so we don't need to pass any global transform here.
57097:     mRoot->ComputeEffectiveTransforms(gfx3DMatrix());
57097: 
42791:     mThebesLayerCallback = aCallback;
42791:     mThebesLayerCallbackData = aCallbackData;
42791: 
42791:     Render();
42791: 
42791:     mThebesLayerCallback = nsnull;
42791:     mThebesLayerCallbackData = nsnull;
62292:   }
42791: 
39997:   mTarget = NULL;
55450: 
55450: #ifdef MOZ_LAYERS_HAVE_LOG
55450:   Log();
55450:   MOZ_LAYERS_LOG(("]----- EndTransaction"));
55450: #endif
39997: }
39997: 
39997: already_AddRefed<ThebesLayer>
39997: LayerManagerOGL::CreateThebesLayer()
39997: {
49072:   if (mDestroyed) {
49072:     NS_WARNING("Call on destroyed layer manager");
49072:     return nsnull;
49072:   }
49072: 
39997:   nsRefPtr<ThebesLayer> layer = new ThebesLayerOGL(this);
39997:   return layer.forget();
39997: }
39997: 
39997: already_AddRefed<ContainerLayer>
39997: LayerManagerOGL::CreateContainerLayer()
39997: {
49072:   if (mDestroyed) {
49072:     NS_WARNING("Call on destroyed layer manager");
49072:     return nsnull;
49072:   }
49072: 
39997:   nsRefPtr<ContainerLayer> layer = new ContainerLayerOGL(this);
39997:   return layer.forget();
39997: }
39997: 
39997: already_AddRefed<ImageContainer>
39997: LayerManagerOGL::CreateImageContainer()
39997: {
49072:   if (mDestroyed) {
49072:     NS_WARNING("Call on destroyed layer manager");
49072:     return nsnull;
49072:   }
49072: 
39997:   nsRefPtr<ImageContainer> container = new ImageContainerOGL(this);
49072:   RememberImageContainer(container);
39997:   return container.forget();
39997: }
39997: 
39997: already_AddRefed<ImageLayer>
39997: LayerManagerOGL::CreateImageLayer()
39997: {
49072:   if (mDestroyed) {
49072:     NS_WARNING("Call on destroyed layer manager");
49072:     return nsnull;
49072:   }
49072: 
39997:   nsRefPtr<ImageLayer> layer = new ImageLayerOGL(this);
39997:   return layer.forget();
39997: }
39997: 
42249: already_AddRefed<ColorLayer>
42249: LayerManagerOGL::CreateColorLayer()
42249: {
49072:   if (mDestroyed) {
49072:     NS_WARNING("Call on destroyed layer manager");
49072:     return nsnull;
49072:   }
49072: 
42249:   nsRefPtr<ColorLayer> layer = new ColorLayerOGL(this);
42249:   return layer.forget();
42249: }
42249: 
42402: already_AddRefed<CanvasLayer>
42402: LayerManagerOGL::CreateCanvasLayer()
42402: {
49072:   if (mDestroyed) {
49072:     NS_WARNING("Call on destroyed layer manager");
49072:     return nsnull;
49072:   }
49072: 
42402:   nsRefPtr<CanvasLayer> layer = new CanvasLayerOGL(this);
42402:   return layer.forget();
42402: }
42402: 
39997: void
49072: LayerManagerOGL::ForgetImageContainer(ImageContainer *aContainer)
49072: {
49072:   NS_ASSERTION(aContainer->Manager() == this,
49072:                "ForgetImageContainer called on non-owned container!");
49072: 
49072:   if (!mImageContainers.RemoveElement(aContainer)) {
49072:     NS_WARNING("ForgetImageContainer couldn't find container it was supposed to forget!");
49072:     return;
49072:   }
49072: }
49072: 
49072: void
49072: LayerManagerOGL::RememberImageContainer(ImageContainer *aContainer)
49072: {
49072:   NS_ASSERTION(aContainer->Manager() == this,
49072:                "RememberImageContainer called on non-owned container!");
49072:   mImageContainers.AppendElement(aContainer);
49072: }
49072: 
44202: LayerOGL*
44202: LayerManagerOGL::RootLayer() const
44202: {
49072:   if (mDestroyed) {
49072:     NS_WARNING("Call on destroyed layer manager");
49072:     return nsnull;
49072:   }
49072: 
44202:   return static_cast<LayerOGL*>(mRoot->ImplData());
44202: }
44202: 
79445: bool LayerManagerOGL::sDrawFPS = false;
77670: 
72306: /* This function tries to stick to portable C89 as much as possible
72306:  * so that it can be easily copied into other applications */
39997: void
69696: LayerManagerOGL::FPSState::DrawFPS(GLContext* context, CopyProgram* copyprog)
69696: {
69696:   fcount++;
69696: 
69696:   int rate = 30;
69696:   if (fcount >= rate) {
69696:     TimeStamp now = TimeStamp::Now();
69696:     TimeDuration duration = now - last;
69696:     last = now;
69696:     fps = rate / duration.ToSeconds() + .5;
69696:     fcount = 0;
69696:   }
69696: 
69696:   GLint viewport[4];
69696:   context->fGetIntegerv(LOCAL_GL_VIEWPORT, viewport);
69696: 
69696:   static GLuint texture;
69696:   if (!initialized) {
69696:     // Bind the number of textures we need, in this case one.
69696:     context->fGenTextures(1, &texture);
69696:     context->fBindTexture(LOCAL_GL_TEXTURE_2D, texture);
69696:     context->fTexParameteri(LOCAL_GL_TEXTURE_2D,LOCAL_GL_TEXTURE_MIN_FILTER,LOCAL_GL_NEAREST);
69696:     context->fTexParameteri(LOCAL_GL_TEXTURE_2D,LOCAL_GL_TEXTURE_MAG_FILTER,LOCAL_GL_NEAREST);
69696: 
69696:     unsigned char text[] = {
69696:       0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
69696:       0, 255, 255, 255,   0, 255, 255,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0, 255,   0, 255,   0, 255, 255, 255,   0, 255, 255, 255,   0, 255, 255, 255,   0, 255, 255, 255,   0, 255, 255, 255,   0,
69696:       0, 255,   0, 255,   0,   0, 255,   0,   0,   0,   0, 255,   0,   0,   0, 255,   0, 255,   0, 255,   0, 255,   0,   0,   0, 255,   0,   0,   0,   0,   0, 255,   0, 255,   0, 255,   0, 255,   0, 255,   0,
69696:       0, 255,   0, 255,   0,   0, 255,   0,   0, 255, 255, 255,   0, 255, 255, 255,   0, 255, 255, 255,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0, 255,   0, 255, 255, 255,   0, 255, 255, 255,   0,
69696:       0, 255,   0, 255,   0,   0, 255,   0,   0, 255,   0,   0,   0,   0,   0, 255,   0,   0,   0, 255,   0,   0,   0, 255,   0, 255,   0, 255,   0,   0,   0, 255,   0, 255,   0, 255,   0,   0,   0, 255,   0,
69696:       0, 255, 255, 255,   0, 255, 255, 255,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0, 255,   0, 255, 255, 255,   0, 255, 255, 255,   0,   0,   0, 255,   0, 255, 255, 255,   0,   0,   0, 255,   0,
69696:       0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
69696:     };
69696: 
72307:     // convert from 8 bit to 32 bit so that don't have to write the text above out in 32 bit format
72305:     // we rely on int being 32 bits
72305:     unsigned int* buf = (unsigned int*)malloc(64 * 8 * 4);
69696:     for (int i = 0; i < 7; i++) {
69696:       for (int j = 0; j < 41; j++) {
72307:         unsigned int purple = 0xfff000ff;
72307:         unsigned int white  = 0xffffffff;
72307:         buf[i * 64 + j] = (text[i * 41 + j] == 0) ? purple : white;
69696:       }
69696:     }
69696:     context->fTexImage2D(LOCAL_GL_TEXTURE_2D, 0, LOCAL_GL_RGBA, 64, 8, 0, LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE, buf);
72304:     free(buf);
69696:     initialized = true;
69696:   }
69696: 
69696:   struct Vertex2D {
69696:     float x,y;
69696:   };
69696:   const Vertex2D vertices[] = {
69696:     { -1.0f, 1.0f - 42.f / viewport[3] },
69696:     { -1.0f, 1.0f},
69696:     { -1.0f + 22.f / viewport[2], 1.0f - 42.f / viewport[3] },
69696:     { -1.0f + 22.f / viewport[2], 1.0f },
69696: 
69696:     {  -1.0f + 22.f / viewport[2], 1.0f - 42.f / viewport[3] },
69696:     {  -1.0f + 22.f / viewport[2], 1.0f },
69696:     {  -1.0f + 44.f / viewport[2], 1.0f - 42.f / viewport[3] },
69696:     {  -1.0f + 44.f / viewport[2], 1.0f },
69696: 
69696:     { -1.0f + 44.f / viewport[2], 1.0f - 42.f / viewport[3] },
69696:     { -1.0f + 44.f / viewport[2], 1.0f },
69696:     { -1.0f + 66.f / viewport[2], 1.0f - 42.f / viewport[3] },
69696:     { -1.0f + 66.f / viewport[2], 1.0f }
69696:   };
69696: 
69696:   int v1   = fps % 10;
69696:   int v10  = (fps % 100) / 10;
69696:   int v100 = (fps % 1000) / 100;
69696: 
69696:   // Feel free to comment these texture coordinates out and use one
69696:   // of the ones below instead, or play around with your own values.
69696:   const GLfloat texCoords[] = {
69696:     (v100 * 4.f) / 64, 7.f / 8,
69696:     (v100 * 4.f) / 64, 0.0f,
69696:     (v100 * 4.f + 4) / 64, 7.f / 8,
69696:     (v100 * 4.f + 4) / 64, 0.0f,
69696: 
69696:     (v10 * 4.f) / 64, 7.f / 8,
69696:     (v10 * 4.f) / 64, 0.0f,
69696:     (v10 * 4.f + 4) / 64, 7.f / 8,
69696:     (v10 * 4.f + 4) / 64, 0.0f,
69696: 
69696:     (v1 * 4.f) / 64, 7.f / 8,
69696:     (v1 * 4.f) / 64, 0.0f,
69696:     (v1 * 4.f + 4) / 64, 7.f / 8,
69696:     (v1 * 4.f + 4) / 64, 0.0f,
69696:   };
69696: 
69696:   // Turn necessary features on
69696:   context->fEnable(LOCAL_GL_BLEND);
69696:   context->fBlendFunc(LOCAL_GL_ONE, LOCAL_GL_SRC_COLOR);
69696: 
81124:   context->fActiveTexture(LOCAL_GL_TEXTURE0);
69696:   context->fBindTexture(LOCAL_GL_TEXTURE_2D, texture);
69696: 
69696:   copyprog->Activate();
69696:   copyprog->SetTextureUnit(0);
69696: 
69696:   // we're going to use client-side vertex arrays for this.
69696:   context->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, 0);
69696: 
69696:   // "COPY"
69696:   context->fBlendFuncSeparate(LOCAL_GL_ONE, LOCAL_GL_ZERO,
69696:                               LOCAL_GL_ONE, LOCAL_GL_ZERO);
69696: 
69696:   // enable our vertex attribs; we'll call glVertexPointer below
69696:   // to fill with the correct data.
69696:   GLint vcattr = copyprog->AttribLocation(CopyProgram::VertexCoordAttrib);
69696:   GLint tcattr = copyprog->AttribLocation(CopyProgram::TexCoordAttrib);
69696: 
69696:   context->fEnableVertexAttribArray(vcattr);
69696:   context->fEnableVertexAttribArray(tcattr);
69696: 
69696:   context->fVertexAttribPointer(vcattr,
69696:                                 2, LOCAL_GL_FLOAT,
69696:                                 LOCAL_GL_FALSE,
69696:                                 0, vertices);
69696: 
69696:   context->fVertexAttribPointer(tcattr,
69696:                                 2, LOCAL_GL_FLOAT,
69696:                                 LOCAL_GL_FALSE,
69696:                                 0, texCoords);
69696: 
69696:   context->fDrawArrays(LOCAL_GL_TRIANGLE_STRIP, 0, 12);
69696: }
69696: 
73013: // |aTexCoordRect| is the rectangle from the texture that we want to
73013: // draw using the given program.  The program already has a necessary
73013: // offset and scale, so the geometry that needs to be drawn is a unit
73013: // square from 0,0 to 1,1.
73013: //
73013: // |aTexSize| is the actual size of the texture, as it can be larger
73013: // than the rectangle given by |aTexCoordRect|.
73013: void 
73013: LayerManagerOGL::BindAndDrawQuadWithTextureRect(LayerProgram *aProg,
73013:                                                 const nsIntRect& aTexCoordRect,
73013:                                                 const nsIntSize& aTexSize,
73013:                                                 GLenum aWrapMode)
73013: {
73013:   GLuint vertAttribIndex =
73013:     aProg->AttribLocation(LayerProgram::VertexAttrib);
73013:   GLuint texCoordAttribIndex =
73013:     aProg->AttribLocation(LayerProgram::TexCoordAttrib);
73013:   NS_ASSERTION(texCoordAttribIndex != GLuint(-1), "no texture coords?");
73013: 
73013:   // clear any bound VBO so that glVertexAttribPointer() goes back to
73013:   // "pointer mode"
73013:   mGLContext->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, 0);
73013: 
73013:   // Given what we know about these textures and coordinates, we can
73013:   // compute fmod(t, 1.0f) to get the same texture coordinate out.  If
73013:   // the texCoordRect dimension is < 0 or > width/height, then we have
73013:   // wraparound that we need to deal with by drawing multiple quads,
73013:   // because we can't rely on full non-power-of-two texture support
73013:   // (which is required for the REPEAT wrap mode).
73013: 
73013:   GLContext::RectTriangles rects;
73013: 
73013:   if (aWrapMode == LOCAL_GL_REPEAT) {
73013:     rects.addRect(/* dest rectangle */
73013:                   0.0f, 0.0f, 1.0f, 1.0f,
73013:                   /* tex coords */
73013:                   aTexCoordRect.x / GLfloat(aTexSize.width),
73013:                   aTexCoordRect.y / GLfloat(aTexSize.height),
73013:                   aTexCoordRect.XMost() / GLfloat(aTexSize.width),
73013:                   aTexCoordRect.YMost() / GLfloat(aTexSize.height));
73013:   } else {
73013:     GLContext::DecomposeIntoNoRepeatTriangles(aTexCoordRect, aTexSize, rects);
73013:   }
73013: 
73013:   mGLContext->fVertexAttribPointer(vertAttribIndex, 2,
73013:                                    LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0,
73013:                                    rects.vertexPointer());
73013: 
73013:   mGLContext->fVertexAttribPointer(texCoordAttribIndex, 2,
73013:                                    LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0,
73013:                                    rects.texCoordPointer());
73013: 
73013:   {
73013:     mGLContext->fEnableVertexAttribArray(texCoordAttribIndex);
73013:     {
73013:       mGLContext->fEnableVertexAttribArray(vertAttribIndex);
73013: 
73013:       mGLContext->fDrawArrays(LOCAL_GL_TRIANGLES, 0, rects.elements());
73013: 
73013:       mGLContext->fDisableVertexAttribArray(vertAttribIndex);
73013:     }
73013:     mGLContext->fDisableVertexAttribArray(texCoordAttribIndex);
73013:   }
73013: }
73013: 
69696: void
42791: LayerManagerOGL::Render()
39997: {
49072:   if (mDestroyed) {
49072:     NS_WARNING("Call on destroyed layer manager");
49072:     return;
49072:   }
49072: 
39997:   nsIntRect rect;
50603:   mWidget->GetClientBounds(rect);
61971:   WorldTransformRect(rect);
53685: 
39997:   GLint width = rect.width;
39997:   GLint height = rect.height;
39997: 
53689:   // We can't draw anything to something with no area
53689:   // so just return
53689:   if (width == 0 || height == 0)
53689:     return;
53689: 
53689:   // If the widget size changed, we have to force a MakeCurrent
53689:   // to make sure that GL sees the updated widget size.
53689:   if (mWidgetSize.width != width ||
53689:       mWidgetSize.height != height)
53689:   {
80486:     MakeCurrent(true);
54505: 
53689:     mWidgetSize.width = width;
53689:     mWidgetSize.height = height;
53689:   } else {
39997:     MakeCurrent();
53689:   }
39997: 
42791:   SetupBackBuffer(width, height);
61971:   SetupPipeline(width, height, ApplyWorldTransform);
39997: 
42791:   // Default blend function implements "OVER"
42791:   mGLContext->fBlendFuncSeparate(LOCAL_GL_ONE, LOCAL_GL_ONE_MINUS_SRC_ALPHA,
42791:                                  LOCAL_GL_ONE, LOCAL_GL_ONE);
52407:   mGLContext->fEnable(LOCAL_GL_BLEND);
42791: 
44202:   const nsIntRect *clipRect = mRoot->GetClipRect();
42791: 
39997:   if (clipRect) {
54505:     nsIntRect r = *clipRect;
61971:     WorldTransformRect(r);
54505:     mGLContext->fScissor(r.x, r.y, r.width, r.height);
39997:   } else {
41370:     mGLContext->fScissor(0, 0, width, height);
39997:   }
39997: 
42791:   mGLContext->fEnable(LOCAL_GL_SCISSOR_TEST);
42791: 
53683:   mGLContext->fClearColor(0.0, 0.0, 0.0, 0.0);
53683:   mGLContext->fClear(LOCAL_GL_COLOR_BUFFER_BIT | LOCAL_GL_DEPTH_BUFFER_BIT);
53683: 
42791:   // Render our layers.
63847:   RootLayer()->RenderLayer(mGLContext->IsDoubleBuffered() ? 0 : mBackBufferFBO,
57097:                            nsIntPoint(0, 0));
42791:                            
63893:   mWidget->DrawOver(this, rect);
60224: 
39997:   if (mTarget) {
39997:     CopyToTarget();
82511:     mGLContext->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, 0);
42791:     return;
42791:   }
42791: 
77670:   if (sDrawFPS) {
69696:     mFPS.DrawFPS(mGLContext, GetCopy2DProgram());
69696:   }
69696: 
47909:   if (mGLContext->IsDoubleBuffered()) {
47909:     mGLContext->SwapBuffers();
82511:     mGLContext->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, 0);
47909:     return;
47909:   }
47909: 
41370:   mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, 0);
42791: 
42791:   mGLContext->fActiveTexture(LOCAL_GL_TEXTURE0);
42791: 
42791:   CopyProgram *copyprog = GetCopy2DProgram();
42791: 
42791:   if (mFBOTextureTarget == LOCAL_GL_TEXTURE_RECTANGLE_ARB) {
42791:     copyprog = GetCopy2DRectProgram();
42209:   }
42791: 
42791:   mGLContext->fBindTexture(mFBOTextureTarget, mBackBufferTexture);
42791: 
42791:   copyprog->Activate();
42791:   copyprog->SetTextureUnit(0);
42791: 
42791:   if (copyprog->GetTexCoordMultiplierUniformLocation() != -1) {
42791:     float f[] = { float(width), float(height) };
42791:     copyprog->SetUniform(copyprog->GetTexCoordMultiplierUniformLocation(),
42791:                          2, f);
42791:   }
42791: 
42791:   // we're going to use client-side vertex arrays for this.
41370:   mGLContext->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, 0);
42791: 
42791:   // "COPY"
42791:   mGLContext->fBlendFuncSeparate(LOCAL_GL_ONE, LOCAL_GL_ZERO,
42791:                                  LOCAL_GL_ONE, LOCAL_GL_ZERO);
42791: 
42791:   // enable our vertex attribs; we'll call glVertexPointer below
42791:   // to fill with the correct data.
42791:   GLint vcattr = copyprog->AttribLocation(CopyProgram::VertexCoordAttrib);
42791:   GLint tcattr = copyprog->AttribLocation(CopyProgram::TexCoordAttrib);
42791: 
42791:   mGLContext->fEnableVertexAttribArray(vcattr);
42791:   mGLContext->fEnableVertexAttribArray(tcattr);
39997: 
39997:   const nsIntRect *r;
42791:   nsIntRegionRectIterator iter(mClippingRegion);
42791: 
42791:   while ((r = iter.Next()) != nsnull) {
61971:     nsIntRect cRect = *r; r = &cRect;
61971:     WorldTransformRect(cRect);
39997:     float left = (GLfloat)r->x / width;
39997:     float right = (GLfloat)r->XMost() / width;
39997:     float top = (GLfloat)r->y / height;
39997:     float bottom = (GLfloat)r->YMost() / height;
39997: 
39997:     float vertices[] = { left * 2.0f - 1.0f,
39997:                          -(top * 2.0f - 1.0f),
39997:                          right * 2.0f - 1.0f,
39997:                          -(top * 2.0f - 1.0f),
39997:                          left * 2.0f - 1.0f,
39997:                          -(bottom * 2.0f - 1.0f),
39997:                          right * 2.0f - 1.0f,
39997:                          -(bottom * 2.0f - 1.0f) };
42209: 
69484:     // Use flipped texture coordinates since our
69484:     // projection matrix also has a flip and we
69484:     // need to cancel that out.
69484:     float coords[] = { left, bottom,
69484:                        right, bottom,
69484:                        left, top,
69484:                        right, top };
42791: 
42791:     mGLContext->fVertexAttribPointer(vcattr,
42791:                                      2, LOCAL_GL_FLOAT,
42791:                                      LOCAL_GL_FALSE,
42791:                                      0, vertices);
42791: 
42791:     mGLContext->fVertexAttribPointer(tcattr,
42791:                                      2, LOCAL_GL_FLOAT,
42791:                                      LOCAL_GL_FALSE,
42791:                                      0, coords);
42791: 
42791:     mGLContext->fDrawArrays(LOCAL_GL_TRIANGLE_STRIP, 0, 4);
42209:   }
39997: 
42791:   mGLContext->fDisableVertexAttribArray(vcattr);
42791:   mGLContext->fDisableVertexAttribArray(tcattr);
42791: 
44139:   mGLContext->fFlush();
82455:   mGLContext->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, 0);
39997: }
39997: 
39997: void
61971: LayerManagerOGL::SetWorldTransform(const gfxMatrix& aMatrix)
61971: {
61971:   NS_ASSERTION(aMatrix.PreservesAxisAlignedRectangles(),
61971:                "SetWorldTransform only accepts matrices that satisfy PreservesAxisAlignedRectangles");
61971:   NS_ASSERTION(!aMatrix.HasNonIntegerScale(),
61971:                "SetWorldTransform only accepts matrices with integer scale");
61971: 
61971:   mWorldMatrix = aMatrix;
61971: }
61971: 
61971: gfxMatrix&
61971: LayerManagerOGL::GetWorldTransform(void)
61971: {
61971:   return mWorldMatrix;
61971: }
61971: 
61971: void
61971: LayerManagerOGL::WorldTransformRect(nsIntRect& aRect)
61971: {
61971:   gfxRect grect(aRect.x, aRect.y, aRect.width, aRect.height);
61971:   grect = mWorldMatrix.TransformBounds(grect);
68632:   aRect.SetRect(grect.X(), grect.Y(), grect.Width(), grect.Height());
61971: }
61971: 
61971: void
61971: LayerManagerOGL::SetupPipeline(int aWidth, int aHeight, WorldTransforPolicy aTransformPolicy)
39997: {
54778:   // Set the viewport correctly. 
42791:   mGLContext->fViewport(0, 0, aWidth, aHeight);
39997: 
63845:   // We flip the view matrix around so that everything is right-side up; we're
63845:   // drawing directly into the window's back buffer, so this keeps things
63845:   // looking correct.
54505:   //
63845:   // XXX: We keep track of whether the window size changed, so we could skip
63845:   // this update if it hadn't changed since the last call. We will need to
63845:   // track changes to aTransformPolicy and mWorldMatrix for this to work
63845:   // though.
63845: 
63845:   // Matrix to transform (0, 0, aWidth, aHeight) to viewport space (-1.0, 1.0,
63845:   // 2, 2) and flip the contents.
63845:   gfxMatrix viewMatrix; 
63845:   viewMatrix.Translate(-gfxPoint(1.0, -1.0));
63845:   viewMatrix.Scale(2.0f / float(aWidth), 2.0f / float(aHeight));
63845:   viewMatrix.Scale(1.0f, -1.0f);
63845: 
63845:   if (aTransformPolicy == ApplyWorldTransform) {
63845:     viewMatrix = mWorldMatrix * viewMatrix;
47909:   }
39997: 
74750:   gfx3DMatrix matrix3d = gfx3DMatrix::From2D(viewMatrix);
74750:   matrix3d._33 = 0.0f;
74750: 
74750:   SetLayerProgramProjectionMatrix(matrix3d);
39997: }
39997: 
42791: void
42791: LayerManagerOGL::SetupBackBuffer(int aWidth, int aHeight)
39997: {
63847:   if (mGLContext->IsDoubleBuffered()) {
47909:     mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, 0);
47973:     return;
47909:   }
47909: 
42791:   // Do we have a FBO of the right size already?
42791:   if (mBackBufferSize.width == aWidth &&
42791:       mBackBufferSize.height == aHeight)
42791:   {
42791:     mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, mBackBufferFBO);
42791:     return;
39997:   }
39997: 
42791:   // we already have a FBO, but we need to resize its texture.
42791:   mGLContext->fActiveTexture(LOCAL_GL_TEXTURE0);
42791:   mGLContext->fBindTexture(mFBOTextureTarget, mBackBufferTexture);
42209:   mGLContext->fTexImage2D(mFBOTextureTarget,
39997:                           0,
39997:                           LOCAL_GL_RGBA,
42791:                           aWidth, aHeight,
39997:                           0,
39997:                           LOCAL_GL_RGBA,
39997:                           LOCAL_GL_UNSIGNED_BYTE,
39997:                           NULL);
42791:   mGLContext->fBindTexture(mFBOTextureTarget, 0);
39997: 
42791:   mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, mBackBufferFBO);
41370:   mGLContext->fFramebufferTexture2D(LOCAL_GL_FRAMEBUFFER,
41370:                                     LOCAL_GL_COLOR_ATTACHMENT0,
42209:                                     mFBOTextureTarget,
42791:                                     mBackBufferTexture,
39997:                                     0);
39997: 
83160:   GLenum result = mGLContext->fCheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER);
83160:   if (result != LOCAL_GL_FRAMEBUFFER_COMPLETE) {
83160:     nsCAutoString msg;
83160:     msg.Append("Framebuffer not complete -- error 0x");
83160:     msg.AppendInt(result, 16);
83160:     NS_RUNTIMEABORT(msg.get());
81261:   }
53685: 
42791:   mBackBufferSize.width = aWidth;
42791:   mBackBufferSize.height = aHeight;
39997: }
39997: 
39997: void
39997: LayerManagerOGL::CopyToTarget()
39997: {
39997:   nsIntRect rect;
39997:   mWidget->GetBounds(rect);
39997:   GLint width = rect.width;
39997:   GLint height = rect.height;
39997: 
42791:   if ((PRInt64(width) * PRInt64(height) * PRInt64(4)) > PR_INT32_MAX) {
39997:     NS_ERROR("Widget size too big - integer overflow!");
39997:     return;
39997:   }
39997: 
39997:   nsRefPtr<gfxImageSurface> imageSurface =
39997:     new gfxImageSurface(gfxIntSize(width, height),
39997:                         gfxASurface::ImageFormatARGB32);
39997: 
57545:   mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER,
63847:                                mGLContext->IsDoubleBuffered() ? 0 : mBackBufferFBO);
63847: 
78099: #ifndef USE_GLES2
78099:   // GLES2 promises that binding to any custom FBO will attach
78099:   // to GL_COLOR_ATTACHMENT0 attachment point.
63847:   if (mGLContext->IsDoubleBuffered()) {
63847:     mGLContext->fReadBuffer(LOCAL_GL_BACK);
63847:   }
63847:   else {
41370:     mGLContext->fReadBuffer(LOCAL_GL_COLOR_ATTACHMENT0);
63847:   }
42791: #endif
39997: 
42791:   GLenum format = LOCAL_GL_RGBA;
42791:   if (mHasBGRA)
42791:     format = LOCAL_GL_BGRA;
39997: 
42791:   NS_ASSERTION(imageSurface->Stride() == width * 4,
42791:                "Image Surfaces being created with weird stride!");
39997: 
49077:   PRUint32 currentPackAlignment = 0;
49077:   mGLContext->fGetIntegerv(LOCAL_GL_PACK_ALIGNMENT, (GLint*)&currentPackAlignment);
49077:   if (currentPackAlignment != 4) {
49077:     mGLContext->fPixelStorei(LOCAL_GL_PACK_ALIGNMENT, 4);
49077:   }
49077: 
42791:   mGLContext->fReadPixels(0, 0,
42791:                           width, height,
42791:                           format,
39997:                           LOCAL_GL_UNSIGNED_BYTE,
39997:                           imageSurface->Data());
42791: 
49077:   if (currentPackAlignment != 4) {
49077:     mGLContext->fPixelStorei(LOCAL_GL_PACK_ALIGNMENT, currentPackAlignment);
49077:   }
49077: 
42791:   if (!mHasBGRA) {
42791:     // need to swap B and R bytes
42791:     for (int j = 0; j < height; ++j) {
42791:       PRUint32 *row = (PRUint32*) (imageSurface->Data() + imageSurface->Stride() * j);
42791:       for (int i = 0; i < width; ++i) {
42791:         *row = (*row & 0xff00ff00) | ((*row & 0xff) << 16) | ((*row & 0xff0000) >> 16);
42791:         row++;
42791:       }
42791:     }
39997:   }
39997: 
63845:   mTarget->SetOperator(gfxContext::OPERATOR_SOURCE);
63845:   mTarget->Scale(1.0, -1.0);
63845:   mTarget->Translate(-gfxPoint(0.0, height));
39997:   mTarget->SetSource(imageSurface);
39997:   mTarget->Paint();
39997: }
39997: 
42791: LayerManagerOGL::ProgramType LayerManagerOGL::sLayerProgramTypes[] = {
59436:   gl::RGBALayerProgramType,
59436:   gl::BGRALayerProgramType,
59436:   gl::RGBXLayerProgramType,
59436:   gl::BGRXLayerProgramType,
59436:   gl::RGBARectLayerProgramType,
59436:   gl::ColorLayerProgramType,
60740:   gl::YCbCrLayerProgramType,
60740:   gl::ComponentAlphaPass1ProgramType,
60740:   gl::ComponentAlphaPass2ProgramType
42791: };
42791: 
42791: #define FOR_EACH_LAYER_PROGRAM(vname)                       \
43777:   for (size_t lpindex = 0;                                  \
80467:        lpindex < ArrayLength(sLayerProgramTypes);           \
42791:        ++lpindex)                                           \
42791:   {                                                         \
42791:     LayerProgram *vname = static_cast<LayerProgram*>        \
42791:       (mPrograms[sLayerProgramTypes[lpindex]]);             \
42791:     do
42791: 
42791: #define FOR_EACH_LAYER_PROGRAM_END              \
42791:     while (0);                                  \
42791:   }                                             \
42791: 
42791: void
42791: LayerManagerOGL::SetLayerProgramProjectionMatrix(const gfx3DMatrix& aMatrix)
39997: {
42791:   FOR_EACH_LAYER_PROGRAM(lp) {
42791:     lp->Activate();
42791:     lp->SetProjectionMatrix(aMatrix);
42791:   } FOR_EACH_LAYER_PROGRAM_END
39997: }
39997: 
39997: void
60740: LayerManagerOGL::CreateFBOWithTexture(const nsIntRect& aRect, InitMode aInit,
42791:                                       GLuint *aFBO, GLuint *aTexture)
39997: {
42791:   GLuint tex, fbo;
42791: 
42791:   mGLContext->fActiveTexture(LOCAL_GL_TEXTURE0);
42791:   mGLContext->fGenTextures(1, &tex);
42791:   mGLContext->fBindTexture(mFBOTextureTarget, tex);
60740:   if (aInit == InitModeCopy) {
60740:     mGLContext->fCopyTexImage2D(mFBOTextureTarget,
60740:                                 0,
60740:                                 LOCAL_GL_RGBA,
60740:                                 aRect.x, aRect.y,
60740:                                 aRect.width, aRect.height,
60740:                                 0);
60740:   } else {
42791:     mGLContext->fTexImage2D(mFBOTextureTarget,
42791:                             0,
42791:                             LOCAL_GL_RGBA,
60740:                             aRect.width, aRect.height,
42791:                             0,
42791:                             LOCAL_GL_RGBA,
42791:                             LOCAL_GL_UNSIGNED_BYTE,
42791:                             NULL);
60740:   }
42791:   mGLContext->fTexParameteri(mFBOTextureTarget, LOCAL_GL_TEXTURE_MIN_FILTER,
42791:                              LOCAL_GL_LINEAR);
42791:   mGLContext->fTexParameteri(mFBOTextureTarget, LOCAL_GL_TEXTURE_MAG_FILTER,
42791:                              LOCAL_GL_LINEAR);
62636:   mGLContext->fTexParameteri(mFBOTextureTarget, LOCAL_GL_TEXTURE_WRAP_S, 
62636:                              LOCAL_GL_CLAMP_TO_EDGE);
62636:   mGLContext->fTexParameteri(mFBOTextureTarget, LOCAL_GL_TEXTURE_WRAP_T, 
62636:                              LOCAL_GL_CLAMP_TO_EDGE);
42791:   mGLContext->fBindTexture(mFBOTextureTarget, 0);
42791: 
42791:   mGLContext->fGenFramebuffers(1, &fbo);
42791:   mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, fbo);
42791:   mGLContext->fFramebufferTexture2D(LOCAL_GL_FRAMEBUFFER,
42791:                                     LOCAL_GL_COLOR_ATTACHMENT0,
42791:                                     mFBOTextureTarget,
42791:                                     tex,
42791:                                     0);
42791: 
81261:   // Making this call to fCheckFramebufferStatus prevents a crash on
81261:   // PowerVR. See bug 695246.
83160:   GLenum result = mGLContext->fCheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER);
83160:   if (result != LOCAL_GL_FRAMEBUFFER_COMPLETE) {
83160:     nsCAutoString msg;
83160:     msg.Append("Framebuffer not complete -- error 0x");
83160:     msg.AppendInt(result, 16);
83160:     NS_RUNTIMEABORT(msg.get());
81261:   }
42791: 
63845:   SetupPipeline(aRect.width, aRect.height, DontApplyWorldTransform);
63845:   mGLContext->fScissor(0, 0, aRect.width, aRect.height);
63845: 
60740:   if (aInit == InitModeClear) {
60740:     mGLContext->fClearColor(0.0, 0.0, 0.0, 0.0);
60740:     mGLContext->fClear(LOCAL_GL_COLOR_BUFFER_BIT);
60740:   }
60740: 
42791:   *aFBO = fbo;
42791:   *aTexture = tex;
39997: }
39997: 
55451: already_AddRefed<ShadowThebesLayer>
55451: LayerManagerOGL::CreateShadowThebesLayer()
55451: {
55457:   if (LayerManagerOGL::mDestroyed) {
55457:     NS_WARNING("Call on destroyed layer manager");
55451:     return nsnull;
55451:   }
55457:   return nsRefPtr<ShadowThebesLayerOGL>(new ShadowThebesLayerOGL(this)).forget();
55457: }
55451: 
55451: already_AddRefed<ShadowContainerLayer>
55451: LayerManagerOGL::CreateShadowContainerLayer()
55451: {
55457:   if (LayerManagerOGL::mDestroyed) {
55457:     NS_WARNING("Call on destroyed layer manager");
55451:     return nsnull;
55451:   }
55457:   return nsRefPtr<ShadowContainerLayerOGL>(new ShadowContainerLayerOGL(this)).forget();
55457: }
55451: 
55451: already_AddRefed<ShadowImageLayer>
55451: LayerManagerOGL::CreateShadowImageLayer()
55451: {
55457:   if (LayerManagerOGL::mDestroyed) {
55457:     NS_WARNING("Call on destroyed layer manager");
55451:     return nsnull;
55451:   }
55457:   return nsRefPtr<ShadowImageLayerOGL>(new ShadowImageLayerOGL(this)).forget();
55457: }
55451: 
55451: already_AddRefed<ShadowColorLayer>
55451: LayerManagerOGL::CreateShadowColorLayer()
55451: {
55457:   if (LayerManagerOGL::mDestroyed) {
55457:     NS_WARNING("Call on destroyed layer manager");
55451:     return nsnull;
55451:   }
55457:   return nsRefPtr<ShadowColorLayerOGL>(new ShadowColorLayerOGL(this)).forget();
55457: }
55451: 
55451: already_AddRefed<ShadowCanvasLayer>
55451: LayerManagerOGL::CreateShadowCanvasLayer()
55451: {
55457:   if (LayerManagerOGL::mDestroyed) {
55457:     NS_WARNING("Call on destroyed layer manager");
55451:     return nsnull;
55451:   }
55457:   return nsRefPtr<ShadowCanvasLayerOGL>(new ShadowCanvasLayerOGL(this)).forget();
55457: }
55451: 
55451: 
39997: } /* layers */
39997: } /* mozilla */
