    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsGenericElement.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsXMLProcessingInstruction.h"
    1: #include "nsParserUtils.h"
    1: #include "nsContentCreatorFunctions.h"
    1: 
    1: nsresult
    1: NS_NewXMLProcessingInstruction(nsIContent** aInstancePtrResult,
    1:                                nsNodeInfoManager *aNodeInfoManager,
    1:                                const nsAString& aTarget,
    1:                                const nsAString& aData)
    1: {
    1:   NS_PRECONDITION(aNodeInfoManager, "Missing nodeinfo manager");
    1: 
    1:   if (aTarget.EqualsLiteral("xml-stylesheet")) {
    1:     return NS_NewXMLStylesheetProcessingInstruction(aInstancePtrResult,
    1:                                                     aNodeInfoManager, aData);
    1:   }
    1: 
    1:   *aInstancePtrResult = nsnull;
    1: 
    1:   nsCOMPtr<nsINodeInfo> ni;
    1:   nsresult rv =
    1:     aNodeInfoManager->GetNodeInfo(nsGkAtoms::processingInstructionTagName,
    1:                                   nsnull, kNameSpaceID_None,
    1:                                   getter_AddRefs(ni));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsXMLProcessingInstruction *instance =
11169:     new nsXMLProcessingInstruction(ni, aTarget, aData);
    1:   if (!instance) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   NS_ADDREF(*aInstancePtrResult = instance);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsXMLProcessingInstruction::nsXMLProcessingInstruction(nsINodeInfo *aNodeInfo,
    1:                                                        const nsAString& aTarget,
    1:                                                        const nsAString& aData)
    1:   : nsGenericDOMDataNode(aNodeInfo),
    1:     mTarget(aTarget)
    1: {
12591:   SetTextInternal(0, mText.GetLength(),
12591:                   aData.BeginReading(), aData.Length(),
12591:                   PR_FALSE);  // Don't notify (bug 420429).
    1: }
    1: 
    1: nsXMLProcessingInstruction::~nsXMLProcessingInstruction()
    1: {
    1: }
    1: 
    1: 
    1: // QueryInterface implementation for nsXMLProcessingInstruction
    1: NS_INTERFACE_MAP_BEGIN(nsXMLProcessingInstruction)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMProcessingInstruction)
    1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(ProcessingInstruction)
    1: NS_INTERFACE_MAP_END_INHERITING(nsGenericDOMDataNode)
    1: 
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsXMLProcessingInstruction, nsGenericDOMDataNode)
    1: NS_IMPL_RELEASE_INHERITED(nsXMLProcessingInstruction, nsGenericDOMDataNode)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXMLProcessingInstruction::GetTarget(nsAString& aTarget)
    1: {
    1:   aTarget.Assign(mTarget);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLProcessingInstruction::SetData(const nsAString& aData)
    1: {
    1:   return SetNodeValue(aData);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLProcessingInstruction::GetData(nsAString& aData)
    1: {
    1:   return nsGenericDOMDataNode::GetData(aData);
    1: }
    1: 
    1: PRBool
    1: nsXMLProcessingInstruction::GetAttrValue(nsIAtom *aName, nsAString& aValue)
    1: {
    1:   nsAutoString data;
    1: 
    1:   GetData(data);
    1:   return nsParserUtils::GetQuotedAttributeValue(data, aName, aValue);
    1: }
    1: 
    1: PRBool
    1: nsXMLProcessingInstruction::IsNodeOfType(PRUint32 aFlags) const
    1: {
    1:   return !(aFlags & ~(eCONTENT | ePROCESSING_INSTRUCTION | eDATA_NODE));
    1: }
    1: 
    1: // virtual
    1: PRBool
    1: nsXMLProcessingInstruction::MayHaveFrame() const
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLProcessingInstruction::GetNodeName(nsAString& aNodeName)
    1: {
    1:   aNodeName.Assign(mTarget);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLProcessingInstruction::GetNodeValue(nsAString& aNodeValue)
    1: {
    1:   return nsGenericDOMDataNode::GetNodeValue(aNodeValue);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLProcessingInstruction::SetNodeValue(const nsAString& aNodeValue)
    1: {
    1:   return nsGenericDOMDataNode::SetNodeValue(aNodeValue);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLProcessingInstruction::GetNodeType(PRUint16* aNodeType)
    1: {
    1:   *aNodeType = (PRUint16)nsIDOMNode::PROCESSING_INSTRUCTION_NODE;
    1:   return NS_OK;
    1: }
    1: 
    1: nsGenericDOMDataNode*
    1: nsXMLProcessingInstruction::CloneDataNode(nsINodeInfo *aNodeInfo,
    1:                                           PRBool aCloneText) const
    1: {
    1:   nsAutoString data;
    1:   nsGenericDOMDataNode::GetData(data);
    1: 
11169:   return new nsXMLProcessingInstruction(aNodeInfo, mTarget, data);
    1: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsXMLProcessingInstruction::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   PRInt32 index;
    1:   for (index = aIndent; --index >= 0; ) fputs("  ", out);
    1: 
    1:   fprintf(out, "Processing instruction refcount=%d<", mRefCnt.get());
    1: 
    1:   nsAutoString tmp;
    1:   ToCString(tmp, 0, mText.GetLength());
    1:   tmp.Insert(mTarget.get(), 0);
    1:   fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);
    1: 
    1:   fputs(">\n", out);
    1: }
    1: 
    1: void
    1: nsXMLProcessingInstruction::DumpContent(FILE* out, PRInt32 aIndent,
    1:                                         PRBool aDumpAll) const
    1: {
    1: }
    1: #endif
