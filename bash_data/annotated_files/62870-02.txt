    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Josh Aas <josh@mozilla.com>
 7242:  *   Colin Barrett <cbarrett@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsCocoaWindow_h_
    1: #define nsCocoaWindow_h_
    1: 
    1: #undef DARWIN
    1: 
    1: #import <Cocoa/Cocoa.h>
    1: 
    1: #include "nsBaseWidget.h"
    1: #include "nsPIWidgetCocoa.h"
15578: #include "nsAutoPtr.h"
31548: #include "nsCocoaUtils.h"
    1: 
    1: class nsCocoaWindow;
    1: class nsChildView;
15578: class nsMenuBarX;
    1: 
13491: typedef struct _nsCocoaWindowList {
13491:   _nsCocoaWindowList() : prev(NULL), window(NULL) {}
13491:   struct _nsCocoaWindowList *prev;
13491:   nsCocoaWindow *window; // Weak
13491: } nsCocoaWindowList;
    1: 
34487: // NSWindow subclass that is the base class for all of our own window classes.
35620: // Among other things, this class handles the storage of those settings that
35620: // need to be persisted across window destruction and reconstruction, i.e. when
35620: // switching to and from fullscreen mode.
34487: // We don't save shadow, transparency mode or background color because it's not
34487: // worth the hassle - Gecko will reset them anyway as soon as the window is
34487: // resized.
34487: @interface BaseWindow : NSWindow
34487: {
35620:   // Data Storage
34487:   NSMutableDictionary* mState;
34487:   BOOL mDrawsIntoWindowFrame;
34487:   NSColor* mActiveTitlebarColor;
34487:   NSColor* mInactiveTitlebarColor;
35620: 
35620:   // Shadow
35620:   BOOL mScheduledShadowInvalidation;
50873: 
50873:   // DPI cache. Getting the physical screen size (CGDisplayScreenSize)
50873:   // is ridiculously slow, so we cache it in the toplevel window for all
50873:   // descendants to use.
50873:   float mDPI;
34487: }
34487: 
34487: - (void)importState:(NSDictionary*)aState;
34487: - (NSMutableDictionary*)exportState;
34487: - (void)setDrawsContentsIntoWindowFrame:(BOOL)aState;
34487: - (BOOL)drawsContentsIntoWindowFrame;
34487: - (void)setTitlebarColor:(NSColor*)aColor forActiveWindow:(BOOL)aActive;
34487: - (NSColor*)titlebarColorForActiveWindow:(BOOL)aActive;
34487: 
35620: - (void)deferredInvalidateShadow;
35620: - (void)invalidateShadow;
50873: - (float)getDPI;
35620: 
34487: @end
34487: 
 3574: @interface NSWindow (Undocumented)
 3574: 
 3574: // If a window has been explicitly removed from the "window cache" (to
 3574: // deactivate it), it's sometimes necessary to "reset" it to reactivate it
 3574: // (and put it back in the "window cache").  One way to do this, which Apple
 3574: // often uses, is to set the "window number" to '-1' and then back to its
 3574: // original value.
33037: - (void)_setWindowNumber:(NSInteger)aNumber;
 3574: 
 7242: // If we set the window's stylemask to be textured, the corners on the bottom of
 7242: // the window are rounded by default. We use this private method to make
 7242: // the corners square again, a la Safari.
 7242: - (void)setBottomCornerRounded:(BOOL)rounded;
 7242: 
 3574: @end
 3574: 
34487: @interface PopupWindow : BaseWindow
 3574: {
 3574: @private
 3574:   BOOL mIsContextMenu;
 3574: }
 3574: 
31548: - (id)initWithContentRect:(NSRect)contentRect styleMask:(NSUInteger)styleMask
 3574:       backing:(NSBackingStoreType)bufferingType defer:(BOOL)deferCreation;
 3574: - (BOOL)isContextMenu;
 3574: - (void)setIsContextMenu:(BOOL)flag;
48256: - (BOOL)canBecomeMainWindow;
 3574: 
 3574: @end
 3574: 
34487: @interface BorderlessWindow : BaseWindow
 7042: {
 7042: }
 7042: 
 7042: - (BOOL)canBecomeKeyWindow;
 7042: - (BOOL)canBecomeMainWindow;
 7042: 
 7042: @end
 7042: 
57862: #if defined( MAC_OS_X_VERSION_10_6 ) && ( MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6 )
57862: @interface WindowDelegate : NSObject <NSWindowDelegate>
57862: #else
    1: @interface WindowDelegate : NSObject
57862: #endif
    1: {
  384:   nsCocoaWindow* mGeckoWindow; // [WEAK] (we are owned by the window)
29018:   // Used to avoid duplication when we send NS_ACTIVATE and
29018:   // NS_DEACTIVATE to Gecko for toplevel widgets.  Starts out
14885:   // PR_FALSE.
14885:   PRBool mToplevelActiveState;
31533:   BOOL mHasEverBeenZoomed;
    1: }
13608: + (void)paintMenubarForWindow:(NSWindow*)aWindow;
    1: - (id)initWithGeckoWindow:(nsCocoaWindow*)geckoWind;
    1: - (void)windowDidResize:(NSNotification*)aNotification;
 4208: - (void)sendFocusEvent:(PRUint32)eventType;
    1: - (nsCocoaWindow*)geckoWidget;
14885: - (PRBool)toplevelActiveState;
14885: - (void)sendToplevelActivateEvents;
14885: - (void)sendToplevelDeactivateEvents;
    1: @end
    1: 
19295: struct UnifiedGradientInfo {
19295:   float titlebarHeight;
19295:   float toolbarHeight;
19295:   BOOL windowIsMain;
19295:   BOOL drawTitlebar; // NO for toolbar, YES for titlebar
19295: };
19295: 
34054: @class ToolbarWindow;
34054: 
 7242: // NSColor subclass that allows us to draw separate colors both in the titlebar 
 7242: // and for background of the window.
 7242: @interface TitlebarAndBackgroundColor : NSColor
 7242: {
34054:   ToolbarWindow *mWindow; // [WEAK] (we are owned by the window)
 7242: }
 7242: 
34487: - (id)initWithWindow:(ToolbarWindow*)aWindow;
 7242: 
 7242: @end
 7242: 
 7242: // NSWindow subclass for handling windows with toolbars.
34487: @interface ToolbarWindow : BaseWindow
 2029: {
 7242:   TitlebarAndBackgroundColor *mColor;
19295:   float mUnifiedToolbarHeight;
34487:   NSColor *mBackgroundColor;
 2029: }
34487: // Pass nil here to get the default appearance.
14886: - (void)setTitlebarColor:(NSColor*)aColor forActiveWindow:(BOOL)aActive;
60289: - (void)setUnifiedToolbarHeight:(float)aHeight;
19295: - (float)unifiedToolbarHeight;
19295: - (float)titlebarHeight;
34054: - (NSRect)titlebarRect;
34054: - (void)setTitlebarNeedsDisplayInRect:(NSRect)aRect sync:(BOOL)aSync;
34054: - (void)setTitlebarNeedsDisplayInRect:(NSRect)aRect;
34054: - (void)setDrawsContentsIntoWindowFrame:(BOOL)aState;
 2029: @end
    1: 
    1: class nsCocoaWindow : public nsBaseWidget, public nsPIWidgetCocoa
    1: {
    1: private:
    1:   
    1:   typedef nsBaseWidget Inherited;
    1: 
    1: public:
    1: 
    1:     nsCocoaWindow();
    1:     virtual ~nsCocoaWindow();
    1: 
    1:     NS_DECL_ISUPPORTS_INHERITED
    1:     NS_DECL_NSPIWIDGETCOCOA
    1:       
    1:     NS_IMETHOD              Create(nsIWidget* aParent,
33013:                                    nsNativeWidget aNativeParent,
23738:                                    const nsIntRect &aRect,
    1:                                    EVENT_CALLBACK aHandleEventFunction,
    1:                                    nsIDeviceContext *aContext,
    1:                                    nsIAppShell *aAppShell = nsnull,
    1:                                    nsIToolkit *aToolkit = nsnull,
    1:                                    nsWidgetInitData *aInitData = nsnull);
    1: 
    1:     NS_IMETHOD              Destroy();
    1: 
    1:     NS_IMETHOD              Show(PRBool aState);
14886:     virtual nsIWidget*      GetSheetWindowParent(void);
    1:     NS_IMETHOD              Enable(PRBool aState);
    1:     NS_IMETHOD              IsEnabled(PRBool *aState);
 6111:     NS_IMETHOD              SetModal(PRBool aState);
    1:     NS_IMETHOD              IsVisible(PRBool & aState);
    1:     NS_IMETHOD              SetFocus(PRBool aState=PR_FALSE);
25183:     virtual nsIntPoint WidgetToScreenOffset();
48256:     virtual nsIntPoint GetClientOffset();
48256:     virtual nsIntSize ClientToWindowSize(const nsIntSize& aClientSize);
    1: 
    1:     virtual void* GetNativeData(PRUint32 aDataType) ;
    1: 
    1:     NS_IMETHOD              ConstrainPosition(PRBool aAllowSlop,
    1:                                               PRInt32 *aX, PRInt32 *aY);
    1:     NS_IMETHOD              Move(PRInt32 aX, PRInt32 aY);
    1:     NS_IMETHOD              PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
    1:                                         nsIWidget *aWidget, PRBool aActivate);
    1:     NS_IMETHOD              SetSizeMode(PRInt32 aMode);
30549:     NS_IMETHOD              HideWindowChrome(PRBool aShouldHide);
30550:     NS_IMETHOD              MakeFullScreen(PRBool aFullScreen);
    1:     NS_IMETHOD              Resize(PRInt32 aWidth,PRInt32 aHeight, PRBool aRepaint);
    1:     NS_IMETHOD              Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint);
59551:     NS_IMETHOD              GetClientBounds(nsIntRect &aRect);
23738:     NS_IMETHOD              GetScreenBounds(nsIntRect &aRect);
48258:     void                    ReportMoveEvent();
59551:     void                    ReportSizeEvent();
33232:     NS_IMETHOD              SetCursor(nsCursor aCursor);
33232:     NS_IMETHOD              SetCursor(imgIContainer* aCursor, PRUint32 aHotspotX, PRUint32 aHotspotY);
    1: 
    1:     NS_IMETHOD              SetTitle(const nsAString& aTitle);
    1: 
23738:     NS_IMETHOD Invalidate(const nsIntRect &aRect, PRBool aIsSynchronous);
    1:     NS_IMETHOD Update();
30515:     virtual nsresult ConfigureChildren(const nsTArray<Configuration>& aConfigurations);
58812:     virtual LayerManager* GetLayerManager(LayerManagerPersistence aPersistence = LAYER_MANAGER_CURRENT,
58812:                                           bool* aAllowRetaining = nsnull);
    1:     NS_IMETHOD DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus) ;
36806:     NS_IMETHOD CaptureRollupEvents(nsIRollupListener * aListener, nsIMenuRollup * aMenuRollup,
36806:                                    PRBool aDoCapture, PRBool aConsumeRollupEvent);
    1:     NS_IMETHOD GetAttention(PRInt32 aCycleCount);
27993:     virtual PRBool HasPendingInputEvent();
16601:     virtual nsTransparencyMode GetTransparencyMode();
16601:     virtual void SetTransparencyMode(nsTransparencyMode aMode);
20467:     NS_IMETHOD SetWindowShadowStyle(PRInt32 aStyle);
31160:     virtual void SetShowsToolbarButton(PRBool aShow);
14886:     NS_IMETHOD SetWindowTitlebarColor(nscolor aColor, PRBool aActive);
34054:     virtual void SetDrawsInTitlebar(PRBool aState);
32976:     virtual nsresult SynthesizeNativeMouseEvent(nsIntPoint aPoint,
32976:                                                 PRUint32 aNativeMessage,
32976:                                                 PRUint32 aModifierFlags);
    1: 
31533:     void DispatchSizeModeEvent();
19112: 
 4174:     virtual gfxASurface* GetThebesSurface();
 4174: 
    1:     // be notified that a some form of drag event needs to go into Gecko
    1:     virtual PRBool DragEvent(unsigned int aMessage, Point aMouseGlobal, UInt16 aKeyModifiers);
    1: 
13491:     PRBool HasModalDescendents() { return mNumModalDescendents > 0; }
13491:     NSWindow *GetCocoaWindow() { return mWindow; }
13491: 
27089:     void SetMenuBar(nsMenuBarX* aMenuBar);
27089:     nsMenuBarX *GetMenuBar();
27089: 
    1:     // nsIKBStateControl interface
    1:     NS_IMETHOD ResetInputState();
    1:     
 6348:     NS_IMETHOD BeginSecureKeyboardInput();
 6348:     NS_IMETHOD EndSecureKeyboardInput();
 6348: 
31548:     static void UnifiedShading(void* aInfo, const CGFloat* aIn, CGFloat* aOut);
20506: 
48254:     void SetPopupWindowLevel();
48254: 
57526:     PRBool IsChildInFailingLeftClickThrough(NSView *aChild);
57526:     PRBool ShouldFocusPlugin();
57526: 
54312:     NS_IMETHOD         ReparentNativeWidget(nsIWidget* aNewParent);
    1: protected:
    1: 
30549:   nsresult             CreateNativeWindow(const NSRect &aRect,
30549:                                           nsBorderStyle aBorderStyle,
30549:                                           PRBool aRectIsFrameRect);
29540:   nsresult             CreatePopupContentView(const nsIntRect &aRect,
29540:                                               EVENT_CALLBACK aHandleEventFunction,
29540:                                               nsIDeviceContext *aContext,
29540:                                               nsIAppShell *aAppShell,
29540:                                               nsIToolkit *aToolkit);
29540:   void                 DestroyNativeWindow();
36750:   void                 AdjustWindowShadow();
37144:   void                 SetUpWindowFilter();
37144:   void                 CleanUpWindowFilter();
59551:   void                 UpdateBounds();
29540: 
51049:   virtual already_AddRefed<nsIWidget>
51049:   AllocateChildPopupWidget()
51049:   {
51049:     static NS_DEFINE_IID(kCPopUpCID, NS_POPUP_CID);
51049:     nsCOMPtr<nsIWidget> widget = do_CreateInstance(kCPopUpCID);
51049:     return widget.forget();
51049:   }
51049: 
    1:   nsIWidget*           mParent;         // if we're a popup, this is our parent [WEAK]
34487:   BaseWindow*          mWindow;         // our cocoa window [STRONG]
    1:   WindowDelegate*      mDelegate;       // our delegate for processing window msgs [STRONG]
15578:   nsRefPtr<nsMenuBarX> mMenuBar;
    1:   NSWindow*            mSheetWindowParent; // if this is a sheet, this is the NSWindow it's attached to
    1:   nsChildView*         mPopupContentView; // if this is a popup, this is its content widget
36750:   PRInt32              mShadowStyle;
37144:   NSUInteger           mWindowFilter;
    1: 
    1:   PRPackedBool         mWindowMadeHere; // true if we created the window, false for embedding
    1:   PRPackedBool         mSheetNeedsShow; // if this is a sheet, are we waiting to be shown?
11899:                                         // this is used for sibling sheet contention only
30550:   PRPackedBool         mFullScreen;
 6111:   PRPackedBool         mModal;
13491: 
13491:   PRInt32              mNumModalDescendents;
    1: };
    1: 
    1: #endif // nsCocoaWindow_h_
