81174: /* -*- Mode: javascript; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
81174: /* vim: set ts=2 et sw=2 tw=80: */
81174: /* ***** BEGIN LICENSE BLOCK *****
81174:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
81174:  *
81174:  * The contents of this file are subject to the Mozilla Public License Version
81174:  * 1.1 (the "License"); you may not use this file except in compliance with
81174:  * the License. You may obtain a copy of the License at
81174:  * http://www.mozilla.org/MPL/
81174:  *
81174:  * Software distributed under the License is distributed on an "AS IS" basis,
81174:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
81174:  * for the specific language governing rights and limitations under the
81174:  * License.
81174:  *
86305:  * The Original Code is the Mozilla CSS Rule View.
81174:  *
81174:  * The Initial Developer of the Original Code is
81174:  * The Mozilla Foundation.
81174:  * Portions created by the Initial Developer are Copyright (C) 2011
81174:  * the Initial Developer. All Rights Reserved.
81174:  *
81174:  * Contributor(s):
86305:  *   Dave Camp <dcamp@mozilla.com> (Original Author)
86305:  *   Rob Campbell <rcampbell@mozilla.com>
81174:  *
81174:  * Alternatively, the contents of this file may be used under the terms of
81174:  * either the GNU General Public License Version 2 or later (the "GPL"), or
81174:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
81174:  * in which case the provisions of the GPL or the LGPL are applicable instead
81174:  * of those above. If you wish to allow use of your version of this file only
81174:  * under the terms of either the GPL or the LGPL, and not to allow others to
81174:  * use your version of this file under the terms of the MPL, indicate your
81174:  * decision by deleting the provisions above and replace them with the notice
81174:  * and other provisions required by the GPL or the LGPL. If you do not delete
81174:  * the provisions above, a recipient may use your version of this file under
81174:  * the terms of any one of the MPL, the GPL or the LGPL.
81174:  *
81174:  * ***** END LICENSE BLOCK ***** */
81174: 
81174: "use strict"
81174: 
81174: const Cc = Components.classes;
81174: const Ci = Components.interfaces;
81174: const Cu = Components.utils;
81174: 
81174: const HTML_NS = "http://www.w3.org/1999/xhtml";
81174: const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
81174: 
81174: const FOCUS_FORWARD = Ci.nsIFocusManager.MOVEFOCUS_FORWARD;
81174: const FOCUS_BACKWARD = Ci.nsIFocusManager.MOVEFOCUS_BACKWARD;
81174: 
81174: /**
81174:  * These regular expressions are adapted from firebug's css.js, and are
81174:  * used to parse CSSStyleDeclaration's cssText attribute.
81174:  */
81174: 
81174: // Used to split on css line separators
81174: const CSS_LINE_RE = /(?:[^;\(]*(?:\([^\)]*?\))?[^;\(]*)*;?/g;
81174: 
81174: // Used to parse a single property line.
81174: const CSS_PROP_RE = /\s*([^:\s]*)\s*:\s*(.*?)\s*(?:! (important))?;?$/;
81174: 
81174: Cu.import("resource://gre/modules/Services.jsm");
81174: Cu.import("resource:///modules/devtools/CssLogic.jsm");
81174: 
81174: var EXPORTED_SYMBOLS = ["CssRuleView",
81174:                         "_ElementStyle",
81174:                         "_editableField"];
81174: 
81174: /**
81174:  * Our model looks like this:
81174:  *
81174:  * ElementStyle:
81174:  *   Responsible for keeping track of which properties are overridden.
81174:  *   Maintains a list of Rule objects that apply to the element.
81174:  * Rule:
81174:  *   Manages a single style declaration or rule.
81174:  *   Responsible for applying changes to the properties in a rule.
81174:  *   Maintains a list of TextProperty objects.
81174:  * TextProperty:
81174:  *   Manages a single property from the cssText attribute of the
81174:  *     relevant declaration.
81174:  *   Maintains a list of computed properties that come from this
81174:  *     property declaration.
81174:  *   Changes to the TextProperty are sent to its related Rule for
81174:  *     application.
81174:  */
81174: 
81174: /**
81174:  * ElementStyle maintains a list of Rule objects for a given element.
81174:  *
81543:  * @param Element aElement
81543:  *        The element whose style we are viewing.
81543:  * @param object aStore
81543:  *        The ElementStyle can use this object to store metadata
81543:  *        that might outlast the rule view, particularly the current
81543:  *        set of disabled properties.
81543:  *
81174:  * @constructor
81174:  */
81543: function ElementStyle(aElement, aStore)
81174: {
81174:   this.element = aElement;
81543:   this.store = aStore || {};
81543:   if (this.store.disabled) {
81543:     this.store.disabled = aStore.disabled;
81543:   } else {
81543:     this.store.disabled = WeakMap();
81543:   }
81543: 
81174:   let doc = aElement.ownerDocument;
81174: 
81174:   // To figure out how shorthand properties are interpreted by the
81174:   // engine, we will set properties on a dummy element and observe
81174:   // how their .style attribute reflects them as computed values.
81174:   this.dummyElement = doc.createElementNS(this.element.namespaceURI,
81174:                                           this.element.tagName);
81174:   this._populate();
81174: }
81174: // We're exporting _ElementStyle for unit tests.
81174: var _ElementStyle = ElementStyle;
81174: 
81174: ElementStyle.prototype = {
81174: 
81174:   // The element we're looking at.
81174:   element: null,
81174: 
81174:   // Empty, unconnected element of the same type as this node, used
81174:   // to figure out how shorthand properties will be parsed.
81174:   dummyElement: null,
81174: 
81174:   domUtils: Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils),
81174: 
81174:   /**
81531:    * Called by the Rule object when it has been changed through the
81531:    * setProperty* methods.
81531:    */
81531:   _changed: function ElementStyle_changed()
81531:   {
81531:     if (this.onChanged) {
81531:       this.onChanged();
81531:     }
81531:   },
81531: 
81531:   /**
81174:    * Refresh the list of rules to be displayed for the active element.
81174:    * Upon completion, this.rules[] will hold a list of Rule objects.
81174:    */
81174:   _populate: function ElementStyle_populate()
81174:   {
81174:     this.rules = [];
81174: 
81475:     let element = this.element;
81475:     do {
81475:       this._addElementRules(element);
81475:     } while ((element = element.parentNode) &&
81475:              element.nodeType === Ci.nsIDOMNode.ELEMENT_NODE);
81475: 
81475:     // Mark overridden computed styles.
81475:     this.markOverridden();
81475:   },
81475: 
81475:   _addElementRules: function ElementStyle_addElementRules(aElement)
81475:   {
81475:     let inherited = aElement !== this.element ? aElement : null;
81475: 
81174:     // Include the element's style first.
81475:     this._maybeAddRule({
81475:       style: aElement.style,
81475:       selectorText: CssLogic.l10n("rule.sourceElement"),
81475:       inherited: inherited
81475:     });
81174: 
81174:     // Get the styles that apply to the element.
81475:     var domRules = this.domUtils.getCSSStyleRules(aElement);
81174: 
81174:     // getCSStyleRules returns ordered from least-specific to
81174:     // most-specific.
81174:     for (let i = domRules.Count() - 1; i >= 0; i--) {
81174:       let domRule = domRules.GetElementAt(i);
81174: 
81174:       // XXX: Optionally provide access to system sheets.
81174:       let systemSheet = CssLogic.isSystemStyleSheet(domRule.parentStyleSheet);
81174:       if (systemSheet) {
81174:         continue;
81174:       }
81174: 
81475:       if (domRule.type !== Ci.nsIDOMCSSRule.STYLE_RULE) {
81475:         continue;
81174:       }
81174: 
81475:       this._maybeAddRule({
81475:         domRule: domRule,
81475:         inherited: inherited
81475:       });
81475:     }
81475:   },
81475: 
81475:   /**
81475:    * Add a rule if it's one we care about.  Filters out duplicates and
81475:    * inherited styles with no inherited properties.
81475:    *
81475:    * @param {object} aOptions
81475:    *        Options for creating the Rule, see the Rule constructor.
81475:    *
81475:    * @return true if we added the rule.
81475:    */
81475:   _maybeAddRule: function ElementStyle_maybeAddRule(aOptions)
81475:   {
81475:     // If we've already included this domRule (for example, when a
81475:     // common selector is inherited), ignore it.
81475:     if (aOptions.domRule &&
81475:         this.rules.some(function(rule) rule.domRule === aOptions.domRule)) {
81475:       return false;
81475:     }
81475: 
81475:     let rule = new Rule(this, aOptions);
81475: 
81475:     // Ignore inherited rules with no properties.
81475:     if (aOptions.inherited && rule.textProps.length == 0) {
81475:       return false;
81475:     }
81475: 
81475:     this.rules.push(rule);
81174:   },
81174: 
81174:   /**
81174:    * Mark the properties listed in this.rules with an overridden flag
81174:    * if an earlier property overrides it.
81174:    */
81174:   markOverridden: function ElementStyle_markOverridden()
81174:   {
81174:     // Gather all the text properties applied by these rules, ordered
81174:     // from more- to less-specific.
81174:     let textProps = [];
81174:     for each (let rule in this.rules) {
81174:       textProps = textProps.concat(rule.textProps.slice(0).reverse());
81174:     }
81174: 
81174:     // Gather all the computed properties applied by those text
81174:     // properties.
81174:     let computedProps = [];
81174:     for each (let textProp in textProps) {
81174:       computedProps = computedProps.concat(textProp.computed);
81475:     }
81174: 
81174:     // Walk over the computed properties.  As we see a property name
81174:     // for the first time, mark that property's name as taken by this
81174:     // property.
81174:     //
81174:     // If we come across a property whose name is already taken, check
81174:     // its priority against the property that was found first:
81174:     //
81174:     //   If the new property is a higher priority, mark the old
81174:     //   property overridden and mark the property name as taken by
81174:     //   the new property.
81174:     //
81174:     //   If the new property is a lower or equal priority, mark it as
81174:     //   overridden.
81174:     //
81174:     // _overriddenDirty will be set on each prop, indicating whether its
81174:     // dirty status changed during this pass.
81174:     let taken = {};
81174:     for each (let computedProp in computedProps) {
81174:       let earlier = taken[computedProp.name];
81174:       let overridden;
81174:       if (earlier
81174:           && computedProp.priority === "important"
81174:           && earlier.priority !== "important") {
81174:         // New property is higher priority.  Mark the earlier property
81174:         // overridden (which will reverse its dirty state).
81174:         earlier._overriddenDirty = !earlier._overriddenDirty;
81174:         earlier.overridden = true;
81174:         overridden = false;
81174:       } else {
81174:         overridden = !!earlier;
81174:       }
81174: 
81174:       computedProp._overriddenDirty = (!!computedProp.overridden != overridden);
81174:       computedProp.overridden = overridden;
81463:       if (!computedProp.overridden && computedProp.textProp.enabled) {
81174:         taken[computedProp.name] = computedProp;
81174:       }
81174:     }
81174: 
81174:     // For each TextProperty, mark it overridden if all of its
81174:     // computed properties are marked overridden.  Update the text
81174:     // property's associated editor, if any.  This will clear the
81174:     // _overriddenDirty state on all computed properties.
81174:     for each (let textProp in textProps) {
81174:       // _updatePropertyOverridden will return true if the
81174:       // overridden state has changed for the text property.
81174:       if (this._updatePropertyOverridden(textProp)) {
81174:         textProp.updateEditor();
81174:       }
81174:     }
81174:   },
81174: 
81174:   /**
81174:    * Mark a given TextProperty as overridden or not depending on the
81174:    * state of its computed properties.  Clears the _overriddenDirty state
81174:    * on all computed properties.
81174:    *
81174:    * @param {TextProperty} aProp
81174:    *        The text property to update.
81174:    *
81174:    * @return True if the TextProperty's overridden state (or any of its
81174:    *         computed properties overridden state) changed.
81174:    */
81174:   _updatePropertyOverridden: function ElementStyle_updatePropertyOverridden(aProp)
81174:   {
81174:     let overridden = true;
81174:     let dirty = false;
81174:     for each (let computedProp in aProp.computed) {
81174:       if (!computedProp.overridden) {
81174:         overridden = false;
81174:       }
81174:       dirty = computedProp._overriddenDirty || dirty;
81174:       delete computedProp._overriddenDirty;
81174:     }
81174: 
81174:     dirty = (!!aProp.overridden != overridden) || dirty;
81174:     aProp.overridden = overridden;
81174:     return dirty;
81174:   }
81174: }
81174: 
81174: /**
81174:  * A single style rule or declaration.
81174:  *
81174:  * @param {ElementStyle} aElementStyle
81174:  *        The ElementStyle to which this rule belongs.
81174:  * @param {object} aOptions
81174:  *        The information used to construct this rule.  Properties include:
81174:  *          domRule: the nsIDOMCSSStyleRule to view, if any.
81174:  *          style: the nsIDOMCSSStyleDeclaration to view.  If omitted,
81174:  *            the domRule's style will be used.
81174:  *          selectorText: selector text to display.  If omitted, the domRule's
81174:  *            selectorText will be used.
81475:  *          inherited: An element this rule was inherited from.  If omitted,
81475:  *            the rule applies directly to the current element.
81174:  * @constructor
81174:  */
81174: function Rule(aElementStyle, aOptions)
81174: {
81174:   this.elementStyle = aElementStyle;
81174:   this.domRule = aOptions.domRule || null;
81174:   this.style = aOptions.style || this.domRule.style;
81174:   this.selectorText = aOptions.selectorText || this.domRule.selectorText;
81475:   this.inherited = aOptions.inherited || null;
81174:   this._getTextProperties();
81174: }
81174: 
81174: Rule.prototype = {
81174:   get title()
81174:   {
81174:     if (this._title) {
81174:       return this._title;
81174:     }
81174:     let sheet = this.domRule ? this.domRule.parentStyleSheet : null;
81174:     this._title = CssLogic.shortSource(sheet);
81174:     if (this.domRule) {
81174:       let line = this.elementStyle.domUtils.getRuleLine(this.domRule);
81174:       this._title += ":" + line;
81174:     }
81475: 
81475:     if (this.inherited) {
81475:       let eltText = this.inherited.tagName.toLowerCase();
81475:       if (this.inherited.id) {
81475:         eltText += "#" + this.inherited.id;
81475:       }
81475:       let args = [eltText, this._title];
81475:       this._title = CssLogic._strings.formatStringFromName("rule.inheritedSource",
81475:                                                            args, args.length);
81475:     }
81475: 
81174:     return this._title;
81174:   },
81174: 
81174:   /**
81174:    * Create a new TextProperty to include in the rule.
81174:    *
81174:    * @param {string} aName
81174:    *        The text property name (such as "background" or "border-top").
81174:    * @param {string} aValue
81174:    *        The property's value (not including priority).
81174:    * @param {string} aPriority
81174:    *        The property's priority (either "important" or an empty string).
81174:    */
81174:   createProperty: function Rule_createProperty(aName, aValue, aPriority)
81174:   {
81174:     let prop = new TextProperty(this, aName, aValue, aPriority);
81174:     this.textProps.push(prop);
81174:     this.applyProperties();
81174:     return prop;
81174:   },
81174: 
81174:   /**
81174:    * Reapply all the properties in this rule, and update their
81543:    * computed styles.  Store disabled properties in the element
81543:    * style's store.  Will re-mark overridden properties.
81174:    */
81174:   applyProperties: function Rule_applyProperties()
81174:   {
81543:     let disabledProps = [];
81543: 
81174:     for each (let prop in this.textProps) {
81174:       if (!prop.enabled) {
81543:         disabledProps.push({
81543:           name: prop.name,
81543:           value: prop.value,
81543:           priority: prop.priority
81543:         });
81174:         continue;
81174:       }
81174: 
81174:       this.style.setProperty(prop.name, prop.value, prop.priority);
81174:       // Refresh the property's value from the style, to reflect
81174:       // any changes made during parsing.
81174:       prop.value = this.style.getPropertyValue(prop.name);
81174:       prop.priority = this.style.getPropertyPriority(prop.name);
81174:       prop.updateComputed();
81174:     }
81531:     this.elementStyle._changed();
81174: 
81543:     // Store disabled properties in the disabled store.
81543:     let disabled = this.elementStyle.store.disabled;
81543:     disabled.set(this.style, disabledProps);
81543: 
81174:     this.elementStyle.markOverridden();
81174:   },
81174: 
81174:   /**
81174:    * Renames a property.
81174:    *
81174:    * @param {TextProperty} aProperty
81174:    *        The property to rename.
81174:    * @param {string} aName
81174:    *        The new property name (such as "background" or "border-top").
81174:    */
81174:   setPropertyName: function Rule_setPropertyName(aProperty, aName)
81174:   {
81174:     if (aName === aProperty.name) {
81174:       return;
81174:     }
81174:     this.style.removeProperty(aProperty.name);
81174:     aProperty.name = aName;
81174:     this.applyProperties();
81174:   },
81174: 
81174:   /**
81174:    * Sets the value and priority of a property.
81174:    *
81174:    * @param {TextProperty} aProperty
81174:    *        The property to manipulate.
81174:    * @param {string} aValue
81174:    *        The property's value (not including priority).
81174:    * @param {string} aPriority
81174:    *        The property's priority (either "important" or an empty string).
81174:    */
81174:   setPropertyValue: function Rule_setPropertyValue(aProperty, aValue, aPriority)
81174:   {
81174:     if (aValue === aProperty.value && aPriority === aProperty.priority) {
81174:       return;
81174:     }
81174:     aProperty.value = aValue;
81174:     aProperty.priority = aPriority;
81174:     this.applyProperties();
81174:   },
81174: 
81174:   /**
81174:    * Disables or enables given TextProperty.
81174:    */
81174:   setPropertyEnabled: function Rule_enableProperty(aProperty, aValue)
81174:   {
81174:     aProperty.enabled = !!aValue;
81174:     if (!aProperty.enabled) {
81174:       this.style.removeProperty(aProperty.name);
81174:     }
81174:     this.applyProperties();
81174:   },
81174: 
81174:   /**
81174:    * Remove a given TextProperty from the rule and update the rule
81174:    * accordingly.
81174:    */
81174:   removeProperty: function Rule_removeProperty(aProperty)
81174:   {
81174:     this.textProps = this.textProps.filter(function(prop) prop != aProperty);
81174:     this.style.removeProperty(aProperty);
81174:     // Need to re-apply properties in case removing this TextProperty
81174:     // exposes another one.
81174:     this.applyProperties();
81174:   },
81174: 
81174:   /**
81174:    * Get the list of TextProperties from the style.  Needs
81174:    * to parse the style's cssText.
81174:    */
81174:   _getTextProperties: function Rule_getTextProperties()
81174:   {
81174:     this.textProps = [];
81174:     let lines = this.style.cssText.match(CSS_LINE_RE);
81174:     for each (let line in lines) {
81174:       let matches = CSS_PROP_RE.exec(line);
81174:       if(!matches || !matches[2])
81174:         continue;
81174: 
81475:       let name = matches[1];
81475:       if (this.inherited &&
81475:           !this.elementStyle.domUtils.isInheritedProperty(name)) {
81475:         continue;
81475:       }
81475: 
81475:       let prop = new TextProperty(this, name, matches[2], matches[3] || "");
81174:       this.textProps.push(prop);
81174:     }
81543: 
81543:     // Include properties from the disabled property store, if any.
81543:     let disabledProps = this.elementStyle.store.disabled.get(this.style);
81543:     if (!disabledProps) {
81543:       return;
81543:     }
81543: 
81543:     for each (let prop in disabledProps) {
81543:       let textProp = new TextProperty(this, prop.name,
81543:                                       prop.value, prop.priority);
81543:       textProp.enabled = false;
81543:       this.textProps.push(textProp);
81543:     }
81174:   },
81174: }
81174: 
81174: /**
81174:  * A single property in a rule's cssText.
81174:  *
81174:  * @param {Rule} aRule
81174:  *        The rule this TextProperty came from.
81174:  * @param {string} aName
81174:  *        The text property name (such as "background" or "border-top").
81174:  * @param {string} aValue
81174:  *        The property's value (not including priority).
81174:  * @param {string} aPriority
81174:  *        The property's priority (either "important" or an empty string).
81174:  *
81174:  */
81174: function TextProperty(aRule, aName, aValue, aPriority)
81174: {
81174:   this.rule = aRule;
81174:   this.name = aName;
81174:   this.value = aValue;
81174:   this.priority = aPriority;
81174:   this.enabled = true;
81174:   this.updateComputed();
81174: }
81174: 
81174: TextProperty.prototype = {
81174:   /**
81174:    * Update the editor associated with this text property,
81174:    * if any.
81174:    */
81174:   updateEditor: function TextProperty_updateEditor()
81174:   {
81174:     if (this.editor) {
81174:       this.editor.update();
81174:     }
81174:   },
81174: 
81174:   /**
81174:    * Update the list of computed properties for this text property.
81174:    */
81174:   updateComputed: function TextProperty_updateComputed()
81174:   {
81174:     if (!this.name) {
81174:       return;
81174:     }
81174: 
81174:     // This is a bit funky.  To get the list of computed properties
81174:     // for this text property, we'll set the property on a dummy element
81174:     // and see what the computed style looks like.
81174:     let dummyElement = this.rule.elementStyle.dummyElement;
81174:     let dummyStyle = dummyElement.style;
81174:     dummyStyle.cssText = "";
81174:     dummyStyle.setProperty(this.name, this.value, this.priority);
81174: 
81174:     this.computed = [];
81174:     for (let i = 0, n = dummyStyle.length; i < n; i++) {
81174:       let prop = dummyStyle.item(i);
81174:       this.computed.push({
81463:         textProp: this,
81174:         name: prop,
81174:         value: dummyStyle.getPropertyValue(prop),
81174:         priority: dummyStyle.getPropertyPriority(prop),
81174:       });
81174:     }
81174:   },
81174: 
81174:   setValue: function TextProperty_setValue(aValue, aPriority)
81174:   {
81174:     this.rule.setPropertyValue(this, aValue, aPriority);
81174:     this.updateEditor();
81174:   },
81174: 
81174:   setName: function TextProperty_setName(aName)
81174:   {
81174:     this.rule.setPropertyName(this, aName);
81174:     this.updateEditor();
81174:   },
81174: 
81174:   setEnabled: function TextProperty_setEnabled(aValue)
81174:   {
81174:     this.rule.setPropertyEnabled(this, aValue);
81174:     this.updateEditor();
81174:   },
81174: 
81174:   remove: function TextProperty_remove()
81174:   {
81174:     this.rule.removeProperty(this);
81174:   }
81174: }
81174: 
81174: 
81174: /**
81174:  * View hierarchy mostly follows the model hierarchy.
81174:  *
81174:  * CssRuleView:
81174:  *   Owns an ElementStyle and creates a list of RuleEditors for its
81174:  *    Rules.
81174:  * RuleEditor:
81174:  *   Owns a Rule object and creates a list of TextPropertyEditors
81174:  *     for its TextProperties.
81174:  *   Manages creation of new text properties.
81174:  * TextPropertyEditor:
81174:  *   Owns a TextProperty object.
81174:  *   Manages changes to the TextProperty.
81174:  *   Can be expanded to display computed properties.
81174:  *   Can mark a property disabled or enabled.
81174:  */
81174: 
81174: /**
81174:  * CssRuleView is a view of the style rules and declarations that
81174:  * apply to a given element.  After construction, the 'element'
81174:  * property will be available with the user interface.
81174:  *
81174:  * @param Document aDocument
81174:  *        The document that will contain the rule view.
81543:  * @param object aStore
81543:  *        The CSS rule view can use this object to store metadata
81543:  *        that might outlast the rule view, particularly the current
81543:  *        set of disabled properties.
81174:  * @constructor
81174:  */
81543: function CssRuleView(aDoc, aStore)
81174: {
81174:   this.doc = aDoc;
81543:   this.store = aStore;
81174: 
82365:   this.element = this.doc.createElementNS(XUL_NS, "vbox");
81174:   this.element.setAttribute("tabindex", "0");
81174:   this.element.classList.add("ruleview");
82365:   this.element.flex = 1;
81174: }
81174: 
81174: CssRuleView.prototype = {
81174:   // The element that we're inspecting.
81174:   _viewedElement: null,
81174: 
81174:   /**
81174:    * Update the highlighted element.
81174:    *
81174:    * @param {nsIDOMElement} aElement
81174:    *        The node whose style rules we'll inspect.
81174:    */
81174:   highlight: function CssRuleView_highlight(aElement)
81174:   {
81174:     if (this._viewedElement === aElement) {
81174:       return;
81174:     }
81174: 
81174:     this.clear();
81174: 
81174:     this._viewedElement = aElement;
81174:     if (!this._viewedElement) {
81174:       return;
81174:     }
81174: 
81531:     if (this._elementStyle) {
81531:       delete this._elementStyle.onChanged;
81531:     }
81531: 
81543:     this._elementStyle = new ElementStyle(aElement, this.store);
81531:     this._elementStyle.onChanged = function() {
81531:       this._changed();
81531:     }.bind(this);
81531: 
81174:     this._createEditors();
81174:   },
81174: 
81174:   /**
81174:    * Clear the rule view.
81174:    */
81174:   clear: function CssRuleView_clear()
81174:   {
81174:     while (this.element.hasChildNodes()) {
81174:       this.element.removeChild(this.element.lastChild);
81174:     }
81174:     this._viewedElement = null;
81174:     this._elementStyle = null;
81174:   },
81174: 
81174:   /**
81531:    * Called when the user has made changes to the ElementStyle.
81531:    * Emits an event that clients can listen to.
81531:    */
81531:   _changed: function CssRuleView_changed()
81531:   {
81531:     var evt = this.doc.createEvent("Events");
81531:     evt.initEvent("CssRuleViewChanged", true, false);
81531:     this.element.dispatchEvent(evt);
81531:   },
81531: 
81531:   /**
81174:    * Creates editor UI for each of the rules in _elementStyle.
81174:    */
81174:   _createEditors: function CssRuleView_createEditors()
81174:   {
81174:     for each (let rule in this._elementStyle.rules) {
81174:       // Don't hold a reference to this editor beyond the one held
81174:       // by the node.
81174:       let editor = new RuleEditor(this.doc, rule);
81174:       this.element.appendChild(editor.element);
81174:     }
81174:   },
81174: };
81174: 
81174: /**
81174:  * Create a RuleEditor.
81174:  *
81174:  * @param object aDoc
81174:  *        The document holding this rule editor.
81174:  * @param Rule aRule
81174:  *        The Rule object we're editing.
81174:  * @constructor
81174:  */
81174: function RuleEditor(aDoc, aRule)
81174: {
81174:   this.doc = aDoc;
81174:   this.rule = aRule;
81174: 
81174:   this._onNewProperty = this._onNewProperty.bind(this);
81174: 
81174:   this._create();
81174: }
81174: 
81174: RuleEditor.prototype = {
81174:   _create: function RuleEditor_create()
81174:   {
81174:     this.element = this.doc.createElementNS(HTML_NS, "div");
81174:     this.element._ruleEditor = this;
81174: 
82366:     // Give a relative position for the inplace editor's measurement
82366:     // span to be placed absolutely against.
82366:     this.element.style.position = "relative";
82366: 
81174:     // Add the source link.
81174:     let source = createChild(this.element, "div", {
81174:       class: "ruleview-rule-source",
81174:       textContent: this.rule.title
81174:     });
81174: 
81174:     let code = createChild(this.element, "div", {
81174:       class: "ruleview-code"
81174:     });
81174: 
81174:     let header = createChild(code, "div", {});
81174: 
81174:     let selectors = createChild(header, "span", {
81174:       class: "ruleview-selector",
81174:       textContent: this.rule.selectorText
81174:     });
86305: 
86305:     this.openBrace = createChild(header, "span", {
86305:       class: "ruleview-ruleopen",
86305:       tabindex: "0",
86305:       textContent: " {"
86305:     });
86305: 
86305:     this.openBrace.addEventListener("click", function() {
86305:       this.newProperty();
86305:     }.bind(this), true);
81174: 
81174:     this.propertyList = createChild(code, "ul", {
81174:       class: "ruleview-propertylist"
81174:     });
81174: 
81174:     for each (let prop in this.rule.textProps) {
81174:       let propEditor = new TextPropertyEditor(this, prop);
81174:       this.propertyList.appendChild(propEditor.element);
81174:     }
81174: 
81174:     this.closeBrace = createChild(code, "div", {
81174:       class: "ruleview-ruleclose",
81174:       tabindex: "0",
81174:       textContent: "}"
81174:     });
81174: 
81174:     // We made the close brace focusable, tabbing to it
81174:     // or clicking on it should start the new property editor.
81174:     this.closeBrace.addEventListener("focus", function() {
81174:       this.newProperty();
81174:     }.bind(this), true);
81174:   },
81174: 
81174:   /**
81174:    * Create a text input for a property name.  If a non-empty property
81174:    * name is given, we'll create a real TextProperty and add it to the
81174:    * rule.
81174:    */
81174:   newProperty: function RuleEditor_newProperty()
81174:   {
81174:     // While we're editing a new property, it doesn't make sense to
81174:     // start a second new property editor, so disable focusing the
81174:     // close brace for now.
81174:     this.closeBrace.removeAttribute("tabindex");
81174: 
81174:     this.newPropItem = createChild(this.propertyList, "li", {
81174:       class: "ruleview-property ruleview-newproperty",
81174:     });
81174: 
81174:     this.newPropSpan = createChild(this.newPropItem, "span", {
81174:       class: "ruleview-propertyname"
81174:     });
81174: 
81174:     new InplaceEditor({
81174:       element: this.newPropSpan,
81174:       done: this._onNewProperty,
81174:       advanceChars: ":"
81174:     });
81174:   },
81174: 
81174:   _onNewProperty: function RuleEditor_onNewProperty(aValue, aCommit)
81174:   {
81174:     // We're done, make the close brace focusable again.
81174:     this.closeBrace.setAttribute("tabindex", "0");
81174: 
81174:     this.propertyList.removeChild(this.newPropItem);
81174:     delete this.newPropItem;
81174:     delete this.newPropSpan;
81174: 
81174:     if (!aValue || !aCommit) {
81174:       return;
81174:     }
81174: 
81174:     // Create an empty-valued property and start editing it.
81174:     let prop = this.rule.createProperty(aValue, "", "");
81174:     let editor = new TextPropertyEditor(this, prop);
81174:     this.propertyList.appendChild(editor.element);
81174:     editor.valueSpan.focus();
81174:   },
81174: };
81174: 
81174: /**
81174:  * Create a TextPropertyEditor.
81174:  *
81174:  * @param {RuleEditor} aRuleEditor
81174:  *        The rule editor that owns this TextPropertyEditor.
81174:  * @param {TextProperty} aProperty
81174:  *        The text property to edit.
81174:  * @constructor
81174:  */
81174: function TextPropertyEditor(aRuleEditor, aProperty)
81174: {
81174:   this.doc = aRuleEditor.doc;
81174:   this.prop = aProperty;
81174:   this.prop.editor = this;
81174: 
81174:   this._onEnableClicked = this._onEnableClicked.bind(this);
81174:   this._onExpandClicked = this._onExpandClicked.bind(this);
81174:   this._onStartEditing = this._onStartEditing.bind(this);
81174:   this._onNameDone = this._onNameDone.bind(this);
81174:   this._onValueDone = this._onValueDone.bind(this);
81174: 
81174:   this._create();
81174:   this.update();
81174: }
81174: 
81174: TextPropertyEditor.prototype = {
81174:   get editing() {
81174:     return !!(this.nameSpan.inplaceEditor || this.valueSpan.inplaceEditor);
81174:   },
81174: 
81174:   /**
81174:    * Create the property editor's DOM.
81174:    */
81174:   _create: function TextPropertyEditor_create()
81174:   {
81174:     this.element = this.doc.createElementNS(HTML_NS, "li");
81174:     this.element.classList.add("ruleview-property");
81174: 
81174:     // The enable checkbox will disable or enable the rule.
81174:     this.enable = createChild(this.element, "input", {
81174:       class: "ruleview-enableproperty",
81174:       type: "checkbox",
81174:       tabindex: "-1"
81174:     });
81174:     this.enable.addEventListener("click", this._onEnableClicked, true);
81174: 
81174:     // Click to expand the computed properties of the text property.
81174:     this.expander = createChild(this.element, "span", {
81174:       class: "ruleview-expander"
81174:     });
81174:     this.expander.addEventListener("click", this._onExpandClicked, true);
81174: 
81174:     // Property name, editable when focused.  Property name
81174:     // is committed when the editor is unfocused.
81174:     this.nameSpan = createChild(this.element, "span", {
81174:       class: "ruleview-propertyname",
81174:       tabindex: "0",
81174:     });
81174:     editableField({
81174:       start: this._onStartEditing,
81174:       element: this.nameSpan,
81174:       done: this._onNameDone,
81174:       advanceChars: ':'
81174:     });
81174: 
81174:     appendText(this.element, ": ");
81174: 
81174:     // Property value, editable when focused.  Changes to the
81174:     // property value are applied as they are typed, and reverted
81174:     // if the user presses escape.
81174:     this.valueSpan = createChild(this.element, "span", {
81174:       class: "ruleview-propertyvalue",
81174:       tabindex: "0",
81174:     });
81174: 
81174:     editableField({
81174:       start: this._onStartEditing,
81174:       element: this.valueSpan,
81174:       done: this._onValueDone,
81174:       advanceChars: ';'
81174:     });
81174: 
81174:     // Save the initial value as the last committed value,
81174:     // for restoring after pressing escape.
81174:     this.committed = { name: this.prop.name,
81174:                        value: this.prop.value,
81174:                        priority: this.prop.priority };
81174: 
81174:     appendText(this.element, ";");
81174: 
81174:     // Holds the viewers for the computed properties.
81174:     // will be populated in |_updateComputed|.
81174:     this.computed = createChild(this.element, "ul", {
81174:       class: "ruleview-computedlist",
81174:     });
81174:   },
81174: 
81174:   /**
81174:    * Populate the span based on changes to the TextProperty.
81174:    */
81174:   update: function TextPropertyEditor_update()
81174:   {
81174:     if (this.prop.enabled) {
81174:       this.enable.style.removeProperty("visibility");
81174:       this.enable.setAttribute("checked", "");
81174:     } else {
81174:       this.enable.style.visibility = "visible";
81174:       this.enable.removeAttribute("checked");
81174:     }
81174: 
81174:     if (this.prop.overridden && !this.editing) {
81174:       this.element.classList.add("ruleview-overridden");
81174:     } else {
81174:       this.element.classList.remove("ruleview-overridden");
81174:     }
81174: 
81174:     this.nameSpan.textContent = this.prop.name;
81174: 
81174:     // Combine the property's value and priority into one string for
81174:     // the value.
81174:     let val = this.prop.value;
81174:     if (this.prop.priority) {
81174:       val += " !" + this.prop.priority;
81174:     }
81174:     this.valueSpan.textContent = val;
81174: 
81174:     // Populate the computed styles.
81174:     this._updateComputed();
81174:   },
81174: 
81174:   _onStartEditing: function TextPropertyEditor_onStartEditing()
81174:   {
81174:     this.element.classList.remove("ruleview-overridden");
81174:   },
81174: 
81174:   /**
81174:    * Populate the list of computed styles.
81174:    */
81174:   _updateComputed: function TextPropertyEditor_updateComputed()
81174:   {
81174:     // Clear out existing viewers.
81174:     while (this.computed.hasChildNodes()) {
81174:       this.computed.removeChild(this.computed.lastChild);
81174:     }
81174: 
81174:     let showExpander = false;
81174:     for each (let computed in this.prop.computed) {
81174:       // Don't bother to duplicate information already
81174:       // shown in the text property.
81174:       if (computed.name === this.prop.name) {
81174:         continue;
81174:       }
81174: 
81174:       showExpander = true;
81174: 
81174:       let li = createChild(this.computed, "li", {
81174:         class: "ruleview-computed"
81174:       });
81174: 
81174:       if (computed.overridden) {
81174:         li.classList.add("ruleview-overridden");
81174:       }
81174: 
81174:       createChild(li, "span", {
81174:         class: "ruleview-propertyname",
81174:         textContent: computed.name
81174:       });
81174:       appendText(li, ": ");
81174:       createChild(li, "span", {
81174:         class: "ruleview-propertyvalue",
81174:         textContent: computed.value
81174:       });
81174:       appendText(li, ";");
81174:     }
81174: 
81174:     // Show or hide the expander as needed.
81174:     if (showExpander) {
81174:       this.expander.style.visibility = "visible";
81174:     } else {
81174:       this.expander.style.visibility = "hidden";
81174:     }
81174:   },
81174: 
81174:   /**
81174:    * Handles clicks on the disabled property.
81174:    */
81174:   _onEnableClicked: function TextPropertyEditor_onEnableClicked()
81174:   {
81174:     this.prop.setEnabled(this.enable.checked);
81174:   },
81174: 
81174:   /**
81174:    * Handles clicks on the computed property expander.
81174:    */
81174:   _onExpandClicked: function TextPropertyEditor_onExpandClicked()
81174:   {
81174:     this.expander.classList.toggle("styleinspector-open");
81174:     this.computed.classList.toggle("styleinspector-open");
81174:   },
81174: 
81174:   /**
81174:    * Called when the property name's inplace editor is closed.
81174:    * Ignores the change if the user pressed escape, otherwise
81174:    * commits it.
81174:    *
81174:    * @param {string} aValue
81174:    *        The value contained in the editor.
81174:    * @param {boolean} aCommit
81174:    *        True if the change should be applied.
81174:    */
81174:   _onNameDone: function TextPropertyEditor_onNameDone(aValue, aCommit)
81174:   {
81174:     if (!aCommit) {
81174:       return;
81174:     }
81174:     if (!aValue) {
81174:       this.prop.remove();
81174:       this.element.parentNode.removeChild(this.element);
81174:       return;
81174:     }
81174:     this.prop.setName(aValue);
81174:   },
81174: 
81174:   /**
81174:    * Pull priority (!important) out of the value provided by a
81174:    * value editor.
81174:    *
81174:    * @param {string} aValue
81174:    *        The value from the text editor.
81174:    * @return an object with 'value' and 'priority' properties.
81174:    */
81174:   _parseValue: function TextPropertyEditor_parseValue(aValue)
81174:   {
81531:     let pieces = aValue.split("!", 2);
81531:     let value = pieces[0];
81531:     let priority = pieces.length > 1 ? pieces[1] : "";
81174:     return {
81531:       value: pieces[0].trim(),
81531:       priority: (pieces.length > 1 ? pieces[1].trim() : "")
81174:     };
81174:   },
81174: 
81174:   /**
81174:    * Called when a value editor closes.  If the user pressed escape,
81174:    * revert to the value this property had before editing.
81174:    *
81174:    * @param {string} aValue
81174:    *        The value contained in the editor.
81174:    * @param {boolean} aCommit
81174:    *        True if the change should be applied.
81174:    */
81174:    _onValueDone: function PropertyEditor_onValueDone(aValue, aCommit)
81174:   {
81174:     if (aCommit) {
81174:       let val = this._parseValue(aValue);
81174:       this.prop.setValue(val.value, val.priority);
81174:       this.committed.value = this.prop.value;
81174:       this.committed.priority = this.prop.priority;
81174:     } else {
81174:       this.prop.setValue(this.committed.value, this.committed.priority);
81174:     }
81174:   },
81174: };
81174: 
81174: /**
81174:  * Mark a span editable.  |editableField| will listen for the span to
81174:  * be focused and create an InlineEditor to handle text input.
81174:  * Changes will be committed when the InlineEditor's input is blurred
81174:  * or dropped when the user presses escape.
81174:  *
81174:  * @param {object} aOptions
81174:  *    Options for the editable field, including:
81174:  *    {Element} element:
81174:  *      (required) The span to be edited on focus.
81174:  *    {function} start:
81174:  *       Will be called when the inplace editor is initialized.
81174:  *    {function} change:
81174:  *       Will be called when the text input changes.  Will be called
81174:  *       with the current value of the text input.
81174:  *    {function} done:
81174:  *       Called when input is committed or blurred.  Called with
81174:  *       current value and a boolean telling the caller whether to
87369:  *       commit the change.  This function is called after the editor
87369:  *       has been torn down.
81174:  *    {string} advanceChars:
81174:  *       If any characters in advanceChars are typed, focus will advance
81174:  *       to the next element.
81174:  */
81174: function editableField(aOptions)
81174: {
81174:   aOptions.element.addEventListener("focus", function() {
81174:     new InplaceEditor(aOptions);
81174:   }, false);
81174: }
81174: var _editableField = editableField;
81174: 
81174: function InplaceEditor(aOptions)
81174: {
81174:   this.elt = aOptions.element;
81174:   this.elt.inplaceEditor = this;
81174: 
81174:   this.change = aOptions.change;
81174:   this.done = aOptions.done;
81174:   this.initial = aOptions.initial ? aOptions.initial : this.elt.textContent;
81174:   this.doc = this.elt.ownerDocument;
81174: 
81174:   this._onBlur = this._onBlur.bind(this);
81174:   this._onKeyPress = this._onKeyPress.bind(this);
81174:   this._onInput = this._onInput.bind(this);
81174: 
81174:   this._createInput();
81174:   this._autosize();
81174: 
81174:   // Pull out character codes for advanceChars, listing the
81174:   // characters that should trigger a blur.
81174:   this._advanceCharCodes = {};
81174:   let advanceChars = aOptions.advanceChars || '';
81174:   for (let i = 0; i < advanceChars.length; i++) {
81174:     this._advanceCharCodes[advanceChars.charCodeAt(i)] = true;
81174:   }
81174: 
81174:   // Hide the provided element and add our editor.
81174:   this.originalDisplay = this.elt.style.display;
81174:   this.elt.style.display = "none";
81174:   this.elt.parentNode.insertBefore(this.input, this.elt);
81174: 
81174:   this.input.select();
81174:   this.input.focus();
81174: 
81174:   this.input.addEventListener("blur", this._onBlur, false);
81174:   this.input.addEventListener("keypress", this._onKeyPress, false);
81174:   this.input.addEventListener("input", this._onInput, false);
81174: 
81174:   if (aOptions.start) {
81174:     aOptions.start();
81174:   }
81174: }
81174: 
81174: InplaceEditor.prototype = {
81174:   _createInput: function InplaceEditor_createEditor()
81174:   {
81174:     this.input = this.doc.createElementNS(HTML_NS, "input");
81174:     this.input.inplaceEditor = this;
81174:     this.input.classList.add("styleinspector-propertyeditor");
81174:     this.input.value = this.initial;
81174: 
81174:     copyTextStyles(this.elt, this.input);
81174:   },
81174: 
81174:   /**
81174:    * Get rid of the editor.
81174:    */
81174:   _clear: function InplaceEditor_clear()
81174:   {
81174:     this.input.removeEventListener("blur", this._onBlur, false);
81174:     this.input.removeEventListener("keypress", this._onKeyPress, false);
81174:     this.input.removeEventListener("oninput", this._onInput, false);
81174:     this._stopAutosize();
81174: 
81174:     this.elt.parentNode.removeChild(this.input);
81174:     this.elt.style.display = this.originalDisplay;
81174:     this.input = null;
81174: 
81174:     delete this.elt.inplaceEditor;
81174:     delete this.elt;
81174:   },
81174: 
81174:   /**
81174:    * Keeps the editor close to the size of its input string.  This is pretty
81174:    * crappy, suggestions for improvement welcome.
81174:    */
81174:   _autosize: function InplaceEditor_autosize()
81174:   {
81174:     // Create a hidden, absolutely-positioned span to measure the text
81174:     // in the input.  Boo.
81174: 
81174:     // We can't just measure the original element because a) we don't
81174:     // change the underlying element's text ourselves (we leave that
81174:     // up to the client), and b) without tweaking the style of the
81174:     // original element, it might wrap differently or something.
81174:     this._measurement = this.doc.createElementNS(HTML_NS, "span");
81174:     this.elt.parentNode.appendChild(this._measurement);
81174:     let style = this._measurement.style;
81174:     style.visibility = "hidden";
81174:     style.position = "absolute";
81174:     style.top = "0";
81174:     style.left = "0";
81174:     copyTextStyles(this.input, this._measurement);
81174:     this._updateSize();
81174:   },
81174: 
81174:   /**
81174:    * Clean up the mess created by _autosize().
81174:    */
81174:   _stopAutosize: function InplaceEditor_stopAutosize()
81174:   {
81174:     if (!this._measurement) {
81174:       return;
81174:     }
81174:     this._measurement.parentNode.removeChild(this._measurement);
81174:     delete this._measurement;
81174:   },
81174: 
81174:   /**
81174:    * Size the editor to fit its current contents.
81174:    */
81174:   _updateSize: function InplaceEditor_updateSize()
81174:   {
81174:     // Replace spaces with non-breaking spaces.  Otherwise setting
81174:     // the span's textContent will collapse spaces and the measurement
81174:     // will be wrong.
87639:     this._measurement.textContent = this.input.value.replace(/ /g, '\u00a0');
81174: 
81174:     // We add a bit of padding to the end.  Should be enough to fit
81174:     // any letter that could be typed, otherwise we'll scroll before
81174:     // we get a chance to resize.  Yuck.
81174:     let width = this._measurement.offsetWidth + 10;
81174: 
81174:     this.input.style.width = width + "px";
81174:   },
81174: 
81174:   /**
81174:    * Handle loss of focus by calling the client's done handler and
81174:    * clearing out.
81174:    */
81174:   _onBlur: function InplaceEditor_onBlur(aEvent)
81174:   {
87369:     let val = this.input.value.trim();
87369:     this._clear();
81174:     if (this.done) {
87369:       this.done(this.cancelled ? this.initial : val, !this.cancelled);
81174:     }
81174:   },
81174: 
81174:   _onKeyPress: function InplaceEditor_onKeyPress(aEvent)
81174:   {
81174:     let prevent = false;
81174:     if (aEvent.charCode in this._advanceCharCodes
81174:        || aEvent.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_RETURN) {
81174:       // Focus the next element, triggering a blur which
81174:       // will eventually shut us down (making return roughly equal
81174:       // tab).
81174:       prevent = true;
81174:       moveFocus(this.input.ownerDocument.defaultView, FOCUS_FORWARD);
81174:     } else if (aEvent.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_ESCAPE) {
81174:       // Cancel and blur ourselves.  |_onBlur| will call the user's
81174:       // done handler for us.
81174:       prevent = true;
81174:       this.cancelled = true;
81174:       this.input.blur();
81174:     } else if (aEvent.keyCode === Ci.nsIDOMKeyEvent.DOM_VK_SPACE) {
81174:       // No need for leading spaces here.  This is particularly
81174:       // noticable when adding a property: it's very natural to type
81174:       // <name>: (which advances to the next property) then spacebar.
81174:       prevent = !this.input.value;
81174:     }
81174: 
81174:     if (prevent) {
81174:       aEvent.preventDefault();
81174:     }
81174:   },
81174: 
81174:   /**
81174:    * Handle changes the input text.
81174:    */
81174:   _onInput: function InplaceEditor_onInput(aEvent)
81174:   {
81174:     // Update size if we're autosizing.
81174:     if (this._measurement) {
81174:       this._updateSize();
81174:     }
81174: 
81174:     // Call the user's change handler if available.
81174:     if (this.change) {
81174:       this.change(this.input.value.trim());
81174:     }
81174:   }
81174: };
81174: 
81174: /**
81174:  * Helper functions
81174:  */
81174: 
81174: /**
81174:  * Create a child element with a set of attributes.
81174:  *
81174:  * @param {Element} aParent
81174:  *        The parent node.
81174:  * @param {string} aTag
81174:  *        The tag name.
81174:  * @param {object} aAttributes
81174:  *        A set of attributes to set on the node.
81174:  */
81174: function createChild(aParent, aTag, aAttributes)
81174: {
81174:   let elt = aParent.ownerDocument.createElementNS(HTML_NS, aTag);
81174:   for (let attr in aAttributes) {
81174:     if (aAttributes.hasOwnProperty(attr)) {
81174:       if (attr === "textContent") {
81174:         elt.textContent = aAttributes[attr];
81174:       } else {
81174:         elt.setAttribute(attr, aAttributes[attr]);
81174:       }
81174:     }
81174:   }
81174:   aParent.appendChild(elt);
81174:   return elt;
81174: }
81174: 
81174: /**
81174:  * Append a text node to an element.
81174:  */
81174: function appendText(aParent, aText)
81174: {
81174:   aParent.appendChild(aParent.ownerDocument.createTextNode(aText));
81174: }
81174: 
81174: /**
81174:  * Copy text-related styles from one element to another.
81174:  */
81174: function copyTextStyles(aFrom, aTo)
81174: {
81174:   let win = aFrom.ownerDocument.defaultView;
81174:   let style = win.getComputedStyle(aFrom);
81174:   aTo.style.fontFamily = style.getPropertyCSSValue("font-family").cssText;
81174:   aTo.style.fontSize = style.getPropertyCSSValue("font-size").cssText;
81174:   aTo.style.fontWeight = style.getPropertyCSSValue("font-weight").cssText;
81174:   aTo.style.fontStyle = style.getPropertyCSSValue("font-style").cssText;
81174: }
81174: 
81174: /**
81174:  * Trigger a focus change similar to pressing tab/shift-tab.
81174:  */
81174: function moveFocus(aWin, aDirection)
81174: {
81174:   let fm = Cc["@mozilla.org/focus-manager;1"].getService(Ci.nsIFocusManager);
81174:   fm.moveFocus(aWin, null, aDirection, 0);
81174: }
