 72423: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 72423: 
 72423: #ifndef _MOZILLA_GFX_2D_H
 72423: #define _MOZILLA_GFX_2D_H
 72423: 
108474: #include "Types.h"
 72423: #include "Point.h"
 72423: #include "Rect.h"
 72423: #include "Matrix.h"
 87514: #include "UserData.h"
 72423: // This RefPtr class isn't ideal for usage in Azure, as it doesn't allow T**
 72423: // outparams using the &-operator. But it will have to do as there's no easy
 72423: // solution.
 72423: #include "mozilla/RefPtr.h"
 72423: 
 99162: #ifdef MOZ_ENABLE_FREETYPE
 99162: #include <string>
 99162: #endif
 99162: 
 72423: struct _cairo_surface;
 72423: typedef _cairo_surface cairo_surface_t;
 72423: 
 88426: struct _cairo_scaled_font;
 88426: typedef _cairo_scaled_font cairo_scaled_font_t;
 88426: 
 72423: struct ID3D10Device1;
 72423: struct ID3D10Texture2D;
 93507: struct IDWriteRenderingParams;
 72423: 
 72423: namespace mozilla {
 72423: namespace gfx {
 72423: 
 72423: class SourceSurface;
 72423: class DataSourceSurface;
 72423: class DrawTarget;
114782: class DrawEventRecorder;
 72423: 
 72423: struct NativeSurface {
 72423:   NativeSurfaceType mType;
 72423:   SurfaceFormat mFormat;
 72423:   void *mSurface;
 72423: };
 72423: 
 72423: struct NativeFont {
 72423:   NativeFontType mType;
 72423:   void *mFont;
 72423: };
 72423: 
 72423: /*
 72423:  * This structure is used to send draw options that are universal to all drawing
 72423:  * operations. It consists of the following:
 72423:  *
 72423:  * mAlpha         - Alpha value by which the mask generated by this operation is
 72423:  *                  multiplied.
 72423:  * mCompositionOp - The operator that indicates how the source and destination
 72423:  *                  patterns are blended.
 72423:  * mAntiAliasMode - The AntiAlias mode used for this drawing operation.
 72423:  * mSnapping      - Whether this operation is snapped to pixel boundaries.
 72423:  */
 72423: struct DrawOptions {
 72423:   DrawOptions(Float aAlpha = 1.0f,
 72423:               CompositionOp aCompositionOp = OP_OVER,
 72423:               AntialiasMode aAntialiasMode = AA_GRAY,
 72423:               Snapping aSnapping = SNAP_NONE)
 72423:     : mAlpha(aAlpha)
 72423:     , mCompositionOp(aCompositionOp)
 72423:     , mAntialiasMode(aAntialiasMode)
 72423:     , mSnapping(aSnapping)
 72423:   {}
 72423: 
 72423:   Float mAlpha;
 72423:   CompositionOp mCompositionOp : 8;
123912:   AntialiasMode mAntialiasMode : 3;
 72423:   Snapping mSnapping : 1;
 72423: };
 72423: 
 72423: /*
 72423:  * This structure is used to send stroke options that are used in stroking
 72423:  * operations. It consists of the following:
 72423:  *
 72423:  * mLineWidth    - Width of the stroke in userspace.
 72423:  * mLineJoin     - Join style used for joining lines.
 72423:  * mLineCap      - Cap style used for capping lines.
 72423:  * mMiterLimit   - Miter limit in units of linewidth
 72742:  * mDashPattern  - Series of on/off userspace lengths defining dash.
 72742:  *                 Owned by the caller; must live at least as long as
 72742:  *                 this StrokeOptions.
 72742:  *                 mDashPattern != null <=> mDashLength > 0.
 72742:  * mDashLength   - Number of on/off lengths in mDashPattern.
 72742:  * mDashOffset   - Userspace offset within mDashPattern at which stroking
 72742:  *                 begins.
 72423:  */
 72423: struct StrokeOptions {
 72423:   StrokeOptions(Float aLineWidth = 1.0f,
 72423:                 JoinStyle aLineJoin = JOIN_MITER_OR_BEVEL,
 72423:                 CapStyle aLineCap = CAP_BUTT,
 72742:                 Float aMiterLimit = 10.0f,
 72742:                 size_t aDashLength = 0,
 72742:                 const Float* aDashPattern = 0,
 72742:                 Float aDashOffset = 0.f)
 72423:     : mLineWidth(aLineWidth)
 72423:     , mMiterLimit(aMiterLimit)
 72742:     , mDashPattern(aDashLength > 0 ? aDashPattern : 0)
 72742:     , mDashLength(aDashLength)
 72742:     , mDashOffset(aDashOffset)
 72423:     , mLineJoin(aLineJoin)
 72423:     , mLineCap(aLineCap)
 72742:   {
 72742:     MOZ_ASSERT(aDashLength == 0 || aDashPattern);
 72742:   }
 72423: 
 72423:   Float mLineWidth;
 72423:   Float mMiterLimit;
 72742:   const Float* mDashPattern;
 72742:   size_t mDashLength;
 72742:   Float mDashOffset;
 72423:   JoinStyle mLineJoin : 4;
 72423:   CapStyle mLineCap : 3;
 72423: };
 72423: 
 72423: /*
 72423:  * This structure supplies additional options for calls to DrawSurface.
 72423:  *
 72423:  * mFilter - Filter used when resampling source surface region to the
 72423:  *           destination region.
 86250:  * aSamplingBounds - This indicates whether the implementation is allowed
 86250:  *                   to sample pixels outside the source rectangle as
 86250:  *                   specified in DrawSurface on the surface.
 72423:  */
 72423: struct DrawSurfaceOptions {
 86250:   DrawSurfaceOptions(Filter aFilter = FILTER_LINEAR,
 86250:                      SamplingBounds aSamplingBounds = SAMPLING_UNBOUNDED)
 72423:     : mFilter(aFilter)
 86250:     , mSamplingBounds(aSamplingBounds)
 72423:   { }
 72423: 
 72423:   Filter mFilter : 3;
 86250:   SamplingBounds mSamplingBounds : 1;
 72423: };
 72423: 
 72423: /*
 72423:  * This class is used to store gradient stops, it can only be used with a
 72423:  * matching DrawTarget. Not adhering to this condition will make a draw call
 72423:  * fail.
 72423:  */
 72423: class GradientStops : public RefCounted<GradientStops>
 72423: {
 72423: public:
 72423:   virtual ~GradientStops() {}
 72423: 
 72423:   virtual BackendType GetBackendType() const = 0;
 72423: 
 72423: protected:
 72423:   GradientStops() {}
 72423: };
 72423: 
 72423: /*
 72423:  * This is the base class for 'patterns'. Patterns describe the pixels used as
 72423:  * the source for a masked composition operation that is done by the different
 72423:  * drawing commands. These objects are not backend specific, however for
 72423:  * example the gradient stops on a gradient pattern can be backend specific.
 72423:  */
 72423: class Pattern
 72423: {
 72423: public:
 72423:   virtual ~Pattern() {}
 72423: 
 72423:   virtual PatternType GetType() const = 0;
 72423: 
 72423: protected:
 72423:   Pattern() {}
 72423: };
 72423: 
 72423: class ColorPattern : public Pattern
 72423: {
 72423: public:
 72423:   ColorPattern(const Color &aColor)
 72423:     : mColor(aColor)
 72423:   {}
 72423: 
 72423:   virtual PatternType GetType() const { return PATTERN_COLOR; }
 72423: 
 72423:   Color mColor;
 72423: };
 72423: 
 72423: /*
 72423:  * This class is used for Linear Gradient Patterns, the gradient stops are
 72423:  * stored in a separate object and are backend dependent. This class itself
 72423:  * may be used on the stack.
 72423:  */
 72423: class LinearGradientPattern : public Pattern
 72423: {
 72423: public:
 72423:   /*
 72423:    * aBegin Start of the linear gradient
 86250:    * aEnd End of the linear gradient - NOTE: In the case of a zero length
 86250:    *      gradient it will act as the color of the last stop.
 72423:    * aStops GradientStops object for this gradient, this should match the
 72423:    *        backend type of the draw target this pattern will be used with.
 86250:    * aMatrix A matrix that transforms the pattern into user space
 72423:    */
 72423:   LinearGradientPattern(const Point &aBegin,
 72423:                         const Point &aEnd,
 86250:                         GradientStops *aStops,
 86250:                         const Matrix &aMatrix = Matrix())
 72423:     : mBegin(aBegin)
 72423:     , mEnd(aEnd)
 72423:     , mStops(aStops)
 86250:     , mMatrix(aMatrix)
 72423:   {
 72423:   }
 72423: 
 72423:   virtual PatternType GetType() const { return PATTERN_LINEAR_GRADIENT; }
 72423: 
 72423:   Point mBegin;
 72423:   Point mEnd;
 72423:   RefPtr<GradientStops> mStops;
 86250:   Matrix mMatrix;
 72423: };
 72423: 
 72423: /*
 72423:  * This class is used for Radial Gradient Patterns, the gradient stops are
 72423:  * stored in a separate object and are backend dependent. This class itself
 72423:  * may be used on the stack.
 72423:  */
 72423: class RadialGradientPattern : public Pattern
 72423: {
 72423: public:
 72423:   /*
 72423:    * aBegin Start of the linear gradient
 72423:    * aEnd End of the linear gradient
 72423:    * aStops GradientStops object for this gradient, this should match the
 72423:    *        backend type of the draw target this pattern will be used with.
 86250:    * aMatrix A matrix that transforms the pattern into user space
 72423:    */
 73619:   RadialGradientPattern(const Point &aCenter1,
 73619:                         const Point &aCenter2,
 73619:                         Float aRadius1,
 73619:                         Float aRadius2,
 86250:                         GradientStops *aStops,
 86250:                         const Matrix &aMatrix = Matrix())
 73619:     : mCenter1(aCenter1)
 73619:     , mCenter2(aCenter2)
 73619:     , mRadius1(aRadius1)
 73619:     , mRadius2(aRadius2)
 72423:     , mStops(aStops)
 86250:     , mMatrix(aMatrix)
 72423:   {
 72423:   }
 72423: 
 72423:   virtual PatternType GetType() const { return PATTERN_RADIAL_GRADIENT; }
 72423: 
 73619:   Point mCenter1;
 73619:   Point mCenter2;
 73619:   Float mRadius1;
 73619:   Float mRadius2;
 72423:   RefPtr<GradientStops> mStops;
 86250:   Matrix mMatrix;
 72423: };
 72423: 
 72423: /*
 72423:  * This class is used for Surface Patterns, they wrap a surface and a
 72423:  * repetition mode for the surface. This may be used on the stack.
 72423:  */
 72423: class SurfacePattern : public Pattern
 72423: {
 72423: public:
 86250:   /*
 86250:    * aSourceSurface Surface to use for drawing
 86250:    * aExtendMode This determines how the image is extended outside the bounds
 86250:    *             of the image.
 86250:    * aMatrix A matrix that transforms the pattern into user space
 86250:    * aFilter Resampling filter used for resampling the image.
 86250:    */
 86250:   SurfacePattern(SourceSurface *aSourceSurface, ExtendMode aExtendMode,
 86250:                  const Matrix &aMatrix = Matrix(), Filter aFilter = FILTER_LINEAR)
 72423:     : mSurface(aSourceSurface)
 72423:     , mExtendMode(aExtendMode)
 86250:     , mFilter(aFilter)
 86250:     , mMatrix(aMatrix)
 72423:   {}
 72423: 
 72423:   virtual PatternType GetType() const { return PATTERN_SURFACE; }
 72423: 
 72423:   RefPtr<SourceSurface> mSurface;
 72423:   ExtendMode mExtendMode;
 72423:   Filter mFilter;
 86250:   Matrix mMatrix;
 72423: };
 72423: 
 72423: /*
 72423:  * This is the base class for source surfaces. These objects are surfaces
 72423:  * which may be used as a source in a SurfacePattern of a DrawSurface call.
 72423:  * They cannot be drawn to directly.
 72423:  */
 72423: class SourceSurface : public RefCounted<SourceSurface>
 72423: {
 72423: public:
 72423:   virtual ~SourceSurface() {}
 72423: 
 72423:   virtual SurfaceType GetType() const = 0;
 72423:   virtual IntSize GetSize() const = 0;
 72423:   virtual SurfaceFormat GetFormat() const = 0;
 72423: 
106821:   /* This returns false if some event has made this source surface invalid for
106821:    * usage with current DrawTargets. For example in the case of Direct2D this
106821:    * could return false if we have switched devices since this surface was
106821:    * created.
106821:    */
106821:   virtual bool IsValid() const { return true; }
106821: 
 72423:   /*
 72423:    * This function will get a DataSourceSurface for this surface, a
 72423:    * DataSourceSurface's data can be accessed directly.
 72423:    */
 72423:   virtual TemporaryRef<DataSourceSurface> GetDataSurface() = 0;
 72423: };
 72423: 
 72423: class DataSourceSurface : public SourceSurface
 72423: {
 72423: public:
 86250:   virtual SurfaceType GetType() const { return SURFACE_DATA; }
128350:   /*
128350:    * Get the raw bitmap data of the surface.
128350:    * Can return null if there was OOM allocating surface data.
128350:    */
 99076:   virtual uint8_t *GetData() = 0;
128350: 
 72423:   /*
 72423:    * Stride of the surface, distance in bytes between the start of the image
 72423:    * data belonging to row y and row y+1. This may be negative.
128350:    * Can return 0 if there was OOM allocating surface data.
 72423:    */
 72423:   virtual int32_t Stride() = 0;
 72423: 
 86250:   /*
 86250:    * This function is called after modifying the data on the source surface
 86250:    * directly through the data pointer.
 86250:    */
 86250:   virtual void MarkDirty() {}
 86250: 
 72423:   virtual TemporaryRef<DataSourceSurface> GetDataSurface() { RefPtr<DataSourceSurface> temp = this; return temp.forget(); }
 72423: };
 72423: 
 72423: /* This is an abstract object that accepts path segments. */
 72423: class PathSink : public RefCounted<PathSink>
 72423: {
 72423: public:
 72423:   virtual ~PathSink() {}
 72423: 
 72423:   /* Move the current point in the path, any figure currently being drawn will
 72423:    * be considered closed during fill operations, however when stroking the
 72423:    * closing line segment will not be drawn.
 72423:    */
 72423:   virtual void MoveTo(const Point &aPoint) = 0;
 72423:   /* Add a linesegment to the current figure */
 72423:   virtual void LineTo(const Point &aPoint) = 0;
 72423:   /* Add a cubic bezier curve to the current figure */
 72423:   virtual void BezierTo(const Point &aCP1,
 72423:                         const Point &aCP2,
 72423:                         const Point &aCP3) = 0;
 72423:   /* Add a quadratic bezier curve to the current figure */
 72423:   virtual void QuadraticBezierTo(const Point &aCP1,
 72423:                                  const Point &aCP2) = 0;
 72423:   /* Close the current figure, this will essentially generate a line segment
 72423:    * from the current point to the starting point for the current figure
 72423:    */
 72423:   virtual void Close() = 0;
 72423:   /* Add an arc to the current figure */
 72423:   virtual void Arc(const Point &aOrigin, float aRadius, float aStartAngle,
 72423:                    float aEndAngle, bool aAntiClockwise = false) = 0;
 72423:   /* Point the current subpath is at - or where the next subpath will start
 72423:    * if there is no active subpath.
 72423:    */
 72423:   virtual Point CurrentPoint() const = 0;
 72423: };
 72423: 
 72423: class PathBuilder;
 72423: 
 72423: /* The path class is used to create (sets of) figures of any shape that can be
 72423:  * filled or stroked to a DrawTarget
 72423:  */
 72423: class Path : public RefCounted<Path>
 72423: {
 72423: public:
 72423:   virtual ~Path() {}
 72423:   
 72423:   virtual BackendType GetBackendType() const = 0;
 72423: 
 72423:   /* This returns a PathBuilder object that contains a copy of the contents of
 72423:    * this path and is still writable.
 72423:    */
 72423:   virtual TemporaryRef<PathBuilder> CopyToBuilder(FillRule aFillRule = FILL_WINDING) const = 0;
 72423:   virtual TemporaryRef<PathBuilder> TransformedCopyToBuilder(const Matrix &aTransform,
 72423:                                                              FillRule aFillRule = FILL_WINDING) const = 0;
 72423: 
 72423:   /* This function checks if a point lies within a path. It allows passing a
 72423:    * transform that will transform the path to the coordinate space in which
 72423:    * aPoint is given.
 72423:    */
 72423:   virtual bool ContainsPoint(const Point &aPoint, const Matrix &aTransform) const = 0;
 72423: 
121145: 
121145:   /* This function checks if a point lies within the stroke of a path using the
121145:    * specified strokeoptions. It allows passing a transform that will transform
121145:    * the path to the coordinate space in which aPoint is given.
121145:    */
121145:   virtual bool StrokeContainsPoint(const StrokeOptions &aStrokeOptions,
121145:                                    const Point &aPoint,
121145:                                    const Matrix &aTransform) const = 0;
121145: 
 73775:   /* This functions gets the bounds of this path. These bounds are not
 73775:    * guaranteed to be tight. A transform may be specified that gives the bounds
 73775:    * after application of the transform.
 73775:    */
 73775:   virtual Rect GetBounds(const Matrix &aTransform = Matrix()) const = 0;
 73775: 
 73775:   /* This function gets the bounds of the stroke of this path using the
 73775:    * specified strokeoptions. These bounds are not guaranteed to be tight.
 73775:    * A transform may be specified that gives the bounds after application of
 73775:    * the transform.
 73775:    */
 73775:   virtual Rect GetStrokedBounds(const StrokeOptions &aStrokeOptions,
 73775:                                 const Matrix &aTransform = Matrix()) const = 0;
 73775: 
 72423:   /* This gets the fillrule this path's builder was created with. This is not
 72423:    * mutable.
 72423:    */
 72423:   virtual FillRule GetFillRule() const = 0;
 72423: };
 72423: 
 72423: /* The PathBuilder class allows path creation. Once finish is called on the
 72423:  * pathbuilder it may no longer be written to.
 72423:  */
 72423: class PathBuilder : public PathSink
 72423: {
 72423: public:
 72423:   /* Finish writing to the path and return a Path object that can be used for
 72423:    * drawing. Future use of the builder results in a crash!
 72423:    */
 72423:   virtual TemporaryRef<Path> Finish() = 0;
 72423: };
 72423: 
 72423: struct Glyph
 72423: {
 72423:   uint32_t mIndex;
 72423:   Point mPosition;
 72423: };
 72423: 
 72423: /* This class functions as a glyph buffer that can be drawn to a DrawTarget.
 72423:  * XXX - This should probably contain the guts of gfxTextRun in the future as
 72423:  * roc suggested. But for now it's a simple container for a glyph vector.
 72423:  */
 72423: struct GlyphBuffer
 72423: {
 72423:   // A pointer to a buffer of glyphs. Managed by the caller.
 72423:   const Glyph *mGlyphs;
 72423:   // Number of glyphs mGlyphs points to.
 72423:   uint32_t mNumGlyphs;
 72423: };
 72423: 
 72423: /* This class is an abstraction of a backend/platform specific font object
 72423:  * at a particular size. It is passed into text drawing calls to describe
 72423:  * the font used for the drawing call.
 72423:  */
 72423: class ScaledFont : public RefCounted<ScaledFont>
 72423: {
 72423: public:
 72423:   virtual ~ScaledFont() {}
 72423: 
114779:   typedef void (*FontFileDataOutput)(const uint8_t *aData, uint32_t aLength, uint32_t aIndex, Float aGlyphSize, void *aBaton);
114779: 
 72423:   virtual FontType GetType() const = 0;
 72423: 
 72423:   /* This allows getting a path that describes the outline of a set of glyphs.
 72423:    * A target is passed in so that the guarantee is made the returned path
 72423:    * can be used with any DrawTarget that has the same backend as the one
 72423:    * passed in.
 72423:    */
 72423:   virtual TemporaryRef<Path> GetPathForGlyphs(const GlyphBuffer &aBuffer, const DrawTarget *aTarget) = 0;
 72423: 
 94392:   /* This copies the path describing the glyphs into a PathBuilder. We use this
 94392:    * API rather than a generic API to append paths because it allows easier
 94392:    * implementation in some backends, and more efficient implementation in
 94392:    * others.
 94392:    */
 94392:   virtual void CopyGlyphsToBuilder(const GlyphBuffer &aBuffer, PathBuilder *aBuilder) = 0;
 94392: 
114779:   virtual bool GetFontFileData(FontFileDataOutput, void *) { return false; }
114779: 
114780:   void AddUserData(UserDataKey *key, void *userData, void (*destroy)(void*)) {
114780:     mUserData.Add(key, userData, destroy);
114780:   }
114780:   void *GetUserData(UserDataKey *key) {
114780:     return mUserData.Get(key);
114780:   }
114780: 
 72423: protected:
 72423:   ScaledFont() {}
114780: 
114780:   UserData mUserData;
 72423: };
 72423: 
 99162: #ifdef MOZ_ENABLE_FREETYPE
 99162: /**
 99162:  * Describes a font
 99162:  * Used to pass the key informatin from a gfxFont into Azure
 99162:  * XXX Should be replaced by a more long term solution, perhaps Bug 738014
 99162:  */
 99162: struct FontOptions
 99162: {
 99162:   std::string mName;
 99162:   FontStyle mStyle;
 99162: };
 99162: #endif
 99162: 
 99162: 
 93507: /* This class is designed to allow passing additional glyph rendering
 93507:  * parameters to the glyph drawing functions. This is an empty wrapper class
 93507:  * merely used to allow holding on to and passing around platform specific
 93507:  * parameters. This is because different platforms have unique rendering
 93507:  * parameters.
 93507:  */
 93507: class GlyphRenderingOptions : public RefCounted<GlyphRenderingOptions>
 93507: {
 93507: public:
 93507:   virtual ~GlyphRenderingOptions() {}
 93507: 
 93507:   virtual FontType GetType() const = 0;
 93507: 
 93507: protected:
 93507:   GlyphRenderingOptions() {}
 93507: };
 93507: 
 72423: /* This is the main class used for all the drawing. It is created through the
 72423:  * factory and accepts drawing commands. The results of drawing to a target
 72423:  * may be used either through a Snapshot or by flushing the target and directly
 72423:  * accessing the backing store a DrawTarget was created with.
 72423:  */
 72423: class DrawTarget : public RefCounted<DrawTarget>
 72423: {
 72423: public:
 98581:   DrawTarget() : mTransformDirty(false), mPermitSubpixelAA(false) {}
 72423:   virtual ~DrawTarget() {}
 72423: 
 72423:   virtual BackendType GetType() const = 0;
 84361:   /**
 84361:    * Returns a SourceSurface which is a snapshot of the current contents of the DrawTarget.
 84361:    * Multiple calls to Snapshot() without any drawing operations in between will
 84361:    * normally return the same SourceSurface object.
 84361:    */
 72423:   virtual TemporaryRef<SourceSurface> Snapshot() = 0;
 72423:   virtual IntSize GetSize() = 0;
 72423: 
 72423:   /* Ensure that the DrawTarget backend has flushed all drawing operations to
 72423:    * this draw target. This must be called before using the backing surface of
 72423:    * this draw target outside of GFX 2D code.
 72423:    */
 72423:   virtual void Flush() = 0;
 72423: 
 72423:   /*
 72423:    * Draw a surface to the draw target. Possibly doing partial drawing or
 72423:    * applying scaling. No sampling happens outside the source.
 72423:    *
 72423:    * aSurface Source surface to draw
 72423:    * aDest Destination rectangle that this drawing operation should draw to
 72423:    * aSource Source rectangle in aSurface coordinates, this area of aSurface
 72423:    *         will be stretched to the size of aDest.
 72423:    * aOptions General draw options that are applied to the operation
 72423:    * aSurfOptions DrawSurface options that are applied
 72423:    */
 72423:   virtual void DrawSurface(SourceSurface *aSurface,
 72423:                            const Rect &aDest,
 72423:                            const Rect &aSource,
 72423:                            const DrawSurfaceOptions &aSurfOptions = DrawSurfaceOptions(),
 72423:                            const DrawOptions &aOptions = DrawOptions()) = 0;
 72423: 
 72423:   /*
 72423:    * Blend a surface to the draw target with a shadow. The shadow is drawn as a
 73777:    * gaussian blur using a specified sigma. The shadow is clipped to the size
 73777:    * of the input surface, so the input surface should contain a transparent
 73777:    * border the size of the approximate coverage of the blur (3 * aSigma).
 72423:    * NOTE: This function works in device space!
 72423:    *
 72423:    * aSurface Source surface to draw.
 72423:    * aDest Destination point that this drawing operation should draw to.
 72423:    * aColor Color of the drawn shadow
 72423:    * aOffset Offset of the shadow
 72423:    * aSigma Sigma used for the guassian filter kernel
 73032:    * aOperator Composition operator used
 72423:    */
 72423:   virtual void DrawSurfaceWithShadow(SourceSurface *aSurface,
 72423:                                      const Point &aDest,
 72423:                                      const Color &aColor,
 72423:                                      const Point &aOffset,
 73032:                                      Float aSigma,
 73032:                                      CompositionOp aOperator) = 0;
 72423: 
 72423:   /* 
 72423:    * Clear a rectangle on the draw target to transparent black. This will
 72423:    * respect the clipping region and transform.
 72423:    *
 72423:    * aRect Rectangle to clear
 72423:    */
 72423:   virtual void ClearRect(const Rect &aRect) = 0;
 72423: 
 72423:   /*
 72423:    * This is essentially a 'memcpy' between two surfaces. It moves a pixel
 72423:    * aligned area from the source surface unscaled directly onto the
 72423:    * drawtarget. This ignores both transform and clip.
 72423:    *
 72423:    * aSurface Surface to copy from
 72423:    * aSourceRect Source rectangle to be copied
 72423:    * aDest Destination point to copy the surface to
 72423:    */
 72423:   virtual void CopySurface(SourceSurface *aSurface,
 72423:                            const IntRect &aSourceRect,
 72423:                            const IntPoint &aDestination) = 0;
 72423: 
 72423:   /*
 72423:    * Fill a rectangle on the DrawTarget with a certain source pattern.
 72423:    *
 72423:    * aRect Rectangle that forms the mask of this filling operation
 72423:    * aPattern Pattern that forms the source of this filling operation
 72423:    * aOptions Options that are applied to this operation
 72423:    */
 72423:   virtual void FillRect(const Rect &aRect,
 72423:                         const Pattern &aPattern,
 72423:                         const DrawOptions &aOptions = DrawOptions()) = 0;
 72423: 
 72423:   /*
 72423:    * Stroke a rectangle on the DrawTarget with a certain source pattern.
 72423:    *
 72423:    * aRect Rectangle that forms the mask of this stroking operation
 72423:    * aPattern Pattern that forms the source of this stroking operation
 72423:    * aOptions Options that are applied to this operation
 72423:    */
 72423:   virtual void StrokeRect(const Rect &aRect,
 72423:                           const Pattern &aPattern,
 72423:                           const StrokeOptions &aStrokeOptions = StrokeOptions(),
 72423:                           const DrawOptions &aOptions = DrawOptions()) = 0;
 72423: 
 72423:   /*
 72423:    * Stroke a line on the DrawTarget with a certain source pattern.
 72423:    *
 72423:    * aStart Starting point of the line
 72423:    * aEnd End point of the line
 72423:    * aPattern Pattern that forms the source of this stroking operation
 72423:    * aOptions Options that are applied to this operation
 72423:    */
 72423:   virtual void StrokeLine(const Point &aStart,
 72423:                           const Point &aEnd,
 72423:                           const Pattern &aPattern,
 72423:                           const StrokeOptions &aStrokeOptions = StrokeOptions(),
 72423:                           const DrawOptions &aOptions = DrawOptions()) = 0;
 72423: 
 72423:   /*
 72423:    * Stroke a path on the draw target with a certain source pattern.
 72423:    *
 72423:    * aPath Path that is to be stroked
 72423:    * aPattern Pattern that should be used for the stroke
 72423:    * aStrokeOptions Stroke options used for this operation
 72423:    * aOptions Draw options used for this operation
 72423:    */
 72423:   virtual void Stroke(const Path *aPath,
 72423:                       const Pattern &aPattern,
 72423:                       const StrokeOptions &aStrokeOptions = StrokeOptions(),
 72423:                       const DrawOptions &aOptions = DrawOptions()) = 0;
 72423:   
 72423:   /*
 72423:    * Fill a path on the draw target with a certain source pattern.
 72423:    *
 72423:    * aPath Path that is to be filled
 72423:    * aPattern Pattern that should be used for the fill
 72423:    * aOptions Draw options used for this operation
 72423:    */
 72423:   virtual void Fill(const Path *aPath,
 72423:                     const Pattern &aPattern,
 72423:                     const DrawOptions &aOptions = DrawOptions()) = 0;
 72423: 
 72423:   /*
 72423:    * Fill a series of clyphs on the draw target with a certain source pattern.
 72423:    */
 72423:   virtual void FillGlyphs(ScaledFont *aFont,
 72423:                           const GlyphBuffer &aBuffer,
 72423:                           const Pattern &aPattern,
 93507:                           const DrawOptions &aOptions = DrawOptions(),
 93507:                           const GlyphRenderingOptions *aRenderingOptions = NULL) = 0;
 72423: 
 72423:   /*
 86250:    * This takes a source pattern and a mask, and composites the source pattern
 86250:    * onto the destination surface using the alpha channel of the mask pattern
 86250:    * as a mask for the operation.
 86250:    *
 86250:    * aSource Source pattern
 86250:    * aMask Mask pattern
 86250:    * aOptions Drawing options
 86250:    */
 86250:   virtual void Mask(const Pattern &aSource,
 86250:                     const Pattern &aMask,
 86250:                     const DrawOptions &aOptions = DrawOptions()) = 0;
 86250: 
 86250:   /*
 72423:    * Push a clip to the DrawTarget.
 72423:    *
 72423:    * aPath The path to clip to
 72423:    */
 72423:   virtual void PushClip(const Path *aPath) = 0;
 72423: 
 86250:   /*
 86250:    * Push an axis-aligned rectangular clip to the DrawTarget. This rectangle
 86250:    * is specified in user space.
 86250:    *
 86250:    * aRect The rect to clip to
 86250:    */
 86250:   virtual void PushClipRect(const Rect &aRect) = 0;
 86250: 
 72423:   /* Pop a clip from the DrawTarget. A pop without a corresponding push will
 72423:    * be ignored.
 72423:    */
 72423:   virtual void PopClip() = 0;
 72423: 
 72423:   /*
 81281:    * Create a SourceSurface optimized for use with this DrawTarget from
 72423:    * existing bitmap data in memory.
 81281:    *
 81281:    * The SourceSurface does not take ownership of aData, and may be freed at any time.
 72423:    */
 72423:   virtual TemporaryRef<SourceSurface> CreateSourceSurfaceFromData(unsigned char *aData,
 72423:                                                                   const IntSize &aSize,
 72423:                                                                   int32_t aStride,
 72423:                                                                   SurfaceFormat aFormat) const = 0;
 72423: 
 72423:   /*
 72423:    * Create a SourceSurface optimized for use with this DrawTarget from
 72423:    * an arbitrary other SourceSurface. This may return aSourceSurface or some
 72423:    * other existing surface.
 72423:    */
 72423:   virtual TemporaryRef<SourceSurface> OptimizeSourceSurface(SourceSurface *aSurface) const = 0;
 72423: 
 72423:   /*
 72423:    * Create a SourceSurface for a type of NativeSurface. This may fail if the
 72423:    * draw target does not know how to deal with the type of NativeSurface passed
 72423:    * in.
 72423:    */
 72423:   virtual TemporaryRef<SourceSurface>
 72423:     CreateSourceSurfaceFromNativeSurface(const NativeSurface &aSurface) const = 0;
 72423: 
 72423:   /*
 72423:    * Create a DrawTarget whose snapshot is optimized for use with this DrawTarget.
 72423:    */
 72423:   virtual TemporaryRef<DrawTarget>
 72423:     CreateSimilarDrawTarget(const IntSize &aSize, SurfaceFormat aFormat) const = 0;
 72423: 
 72423:   /*
110998:    * Create a draw target optimized for drawing a shadow.
111000:    *
111000:    * Note that aSigma is the blur radius that must be used when we draw the
111000:    * shadow. Also note that this doesn't affect the size of the allocated
111000:    * surface, the caller is still responsible for including the shadow area in
111000:    * its size.
110998:    */
110998:   virtual TemporaryRef<DrawTarget>
111000:     CreateShadowDrawTarget(const IntSize &aSize, SurfaceFormat aFormat,
111000:                            float aSigma) const
110998:   {
110998:     return CreateSimilarDrawTarget(aSize, aFormat);
110998:   }
110998: 
110998:   /*
 72423:    * Create a path builder with the specified fillmode.
 73510:    *
 73510:    * We need the fill mode up front because of Direct2D.
 73510:    * ID2D1SimplifiedGeometrySink requires the fill mode
 73510:    * to be set before calling BeginFigure().
 72423:    */
 72423:   virtual TemporaryRef<PathBuilder> CreatePathBuilder(FillRule aFillRule = FILL_WINDING) const = 0;
 72423: 
 72423:   /*
 72423:    * Create a GradientStops object that holds information about a set of
 72423:    * gradient stops, this object is required for linear or radial gradient
 72423:    * patterns to represent the color stops in the gradient.
 72423:    *
 72423:    * aStops An array of gradient stops
 72423:    * aNumStops Number of stops in the array aStops
 86250:    * aExtendNone This describes how to extend the stop color outside of the
 86250:    *             gradient area.
 72423:    */
 86250:   virtual TemporaryRef<GradientStops>
 86250:     CreateGradientStops(GradientStop *aStops,
 86250:                         uint32_t aNumStops,
 86250:                         ExtendMode aExtendMode = EXTEND_CLAMP) const = 0;
 72423: 
 72423:   const Matrix &GetTransform() const { return mTransform; }
 72423: 
 72423:   /*
 72423:    * Set a transform on the surface, this transform is applied at drawing time
 72423:    * to both the mask and source of the operation.
 72423:    */
 72423:   virtual void SetTransform(const Matrix &aTransform)
 72423:     { mTransform = aTransform; mTransformDirty = true; }
 72423: 
 72423:   SurfaceFormat GetFormat() { return mFormat; }
 72423: 
 72423:   /* Tries to get a native surface for a DrawTarget, this may fail if the
 72423:    * draw target cannot convert to this surface type.
 72423:    */
 81281:   virtual void *GetNativeSurface(NativeSurfaceType aType) { return NULL; }
 72423: 
 87514:   void AddUserData(UserDataKey *key, void *userData, void (*destroy)(void*)) {
 87514:     mUserData.Add(key, userData, destroy);
 87514:   }
 87514:   void *GetUserData(UserDataKey *key) {
 87514:     return mUserData.Get(key);
 87514:   }
 97551: 
 97551:   /* Within this rectangle all pixels will be opaque by the time the result of
 97551:    * this DrawTarget is first used for drawing. Either by the underlying surface
 97551:    * being used as an input to external drawing, or Snapshot() being called.
 97551:    * This rectangle is specified in device space.
 97551:    */
 97551:   void SetOpaqueRect(const IntRect &aRect) {
 97551:     mOpaqueRect = aRect;
 97551:   }
 97551: 
 97551:   const IntRect &GetOpaqueRect() const {
 97551:     return mOpaqueRect;
 97551:   }
 98513: 
 98513:   void SetPermitSubpixelAA(bool aPermitSubpixelAA) {
 98513:     mPermitSubpixelAA = aPermitSubpixelAA;
 98513:   }
 98513: 
 98513:   bool GetPermitSubpixelAA() {
 98513:     return mPermitSubpixelAA;
 98513:   }
 98513: 
 72423: protected:
 87514:   UserData mUserData;
 72423:   Matrix mTransform;
 97551:   IntRect mOpaqueRect;
 72423:   bool mTransformDirty : 1;
 98513:   bool mPermitSubpixelAA : 1;
 72423: 
 72423:   SurfaceFormat mFormat;
 72423: };
 72423: 
114781: class DrawEventRecorder : public RefCounted<DrawEventRecorder>
114781: {
114781: public:
114781:   virtual ~DrawEventRecorder() { }
114781: };
114781: 
 97521: class GFX2D_API Factory
 72423: {
 72423: public:
 98187:   static bool HasSSE2();
 98187: 
106600:   static TemporaryRef<DrawTarget> CreateDrawTargetForCairoSurface(cairo_surface_t* aSurface, const IntSize& aSize);
 72423: 
 86250:   static TemporaryRef<DrawTarget>
 86250:     CreateDrawTarget(BackendType aBackend, const IntSize &aSize, SurfaceFormat aFormat);
 86250: 
 86250:   static TemporaryRef<DrawTarget>
114782:     CreateRecordingDrawTarget(DrawEventRecorder *aRecorder, DrawTarget *aDT);
114782:      
114782:   static TemporaryRef<DrawTarget>
 86250:     CreateDrawTargetForData(BackendType aBackend, unsigned char* aData, const IntSize &aSize, int32_t aStride, SurfaceFormat aFormat);
 86250: 
 86250:   static TemporaryRef<ScaledFont>
 86250:     CreateScaledFontForNativeFont(const NativeFont &aNativeFont, Float aSize);
 86250: 
114779:   /**
114779:    * This creates a ScaledFont from TrueType data.
114779:    *
114779:    * aData - Pointer to the data
114779:    * aSize - Size of the TrueType data
114779:    * aFaceIndex - Index of the font face in the truetype data this ScaledFont needs to represent.
114779:    * aGlyphSize - Size of the glyphs in this ScaledFont
114779:    * aType - Type of ScaledFont that should be created.
114779:    */
114779:   static TemporaryRef<ScaledFont>
114779:     CreateScaledFontForTrueTypeData(uint8_t *aData, uint32_t aSize, uint32_t aFaceIndex, Float aGlyphSize, FontType aType);
114779: 
 86250:   /*
 88426:    * This creates a scaled font with an associated cairo_scaled_font_t, and
 88426:    * must be used when using the Cairo backend. The NativeFont and
 88426:    * cairo_scaled_font_t* parameters must correspond to the same font.
 88426:    */
 88426:   static TemporaryRef<ScaledFont>
 88426:     CreateScaledFontWithCairo(const NativeFont &aNativeFont, Float aSize, cairo_scaled_font_t* aScaledFont);
 88426: 
 88426:   /*
 86250:    * This creates a simple data source surface for a certain size. It allocates
 86250:    * new memory for the surface. This memory is freed when the surface is
 86250:    * destroyed.
 86250:    */
 86250:   static TemporaryRef<DataSourceSurface>
 86250:     CreateDataSourceSurface(const IntSize &aSize, SurfaceFormat aFormat);
 86250: 
 86250:   /*
 86250:    * This creates a simple data source surface for some existing data. It will
 86250:    * wrap this data and the data for this source surface. The caller is
 86250:    * responsible for deallocating the memory only after destruction of the
 86250:    * surface.
 86250:    */
 86250:   static TemporaryRef<DataSourceSurface>
 99076:     CreateWrappingDataSourceSurface(uint8_t *aData, int32_t aStride,
 86250:                                     const IntSize &aSize, SurfaceFormat aFormat);
 72423: 
114782:   static TemporaryRef<DrawEventRecorder>
114782:     CreateEventRecorderForFile(const char *aFilename);
114782: 
114782:   static void SetGlobalEventRecorder(DrawEventRecorder *aRecorder);
114782: 
 72423: #ifdef WIN32
 72423:   static TemporaryRef<DrawTarget> CreateDrawTargetForD3D10Texture(ID3D10Texture2D *aTexture, SurfaceFormat aFormat);
 94665:   static TemporaryRef<DrawTarget>
 94665:     CreateDualDrawTargetForD3D10Textures(ID3D10Texture2D *aTextureA,
 94665:                                          ID3D10Texture2D *aTextureB,
 94665:                                          SurfaceFormat aFormat);
 94665: 
 72423:   static void SetDirect3D10Device(ID3D10Device1 *aDevice);
 72423:   static ID3D10Device1 *GetDirect3D10Device();
 72423: 
 93507:   static TemporaryRef<GlyphRenderingOptions>
 93507:     CreateDWriteGlyphRenderingOptions(IDWriteRenderingParams *aParams);
 93507: 
102492:   static uint64_t GetD2DVRAMUsageDrawTarget();
102492:   static uint64_t GetD2DVRAMUsageSourceSurface();
123963:   static void D2DCleanup();
102492: 
 72423: private:
 72423:   static ID3D10Device1 *mD3D10Device;
 72423: #endif
114782: 
114782:   static DrawEventRecorder *mRecorder;
 72423: };
 72423: 
 72423: }
 72423: }
 72423: 
 72423: #endif // _MOZILLA_GFX_2D_H
