 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 18084:  * vim: set ts=8 sw=4 et tw=99:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS parser.
     1:  *
     1:  * This is a recursive-descent parser for the JavaScript language specified by
     1:  * "The JavaScript 1.5 Language Specification".  It uses lexical and semantic
     1:  * feedback to disambiguate non-LL(1) structures.  It generates trees of nodes
 80634:  * induced by the recursive parsing (not precise syntax trees, see Parser.h).
     1:  * After tree construction, it rewrites trees to fold constants and evaluate
 98175:  * compile-time expressions.
     1:  *
     1:  * This parser attempts no error recovery.
     1:  */
 80507: 
 80507: #include "frontend/Parser.h"
 80507: 
     1: #include <stdlib.h>
     1: #include <string.h>
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
     1: #include "jsapi.h"
     1: #include "jsarray.h"
     1: #include "jsatom.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsfun.h"
 68933: #include "jsgc.h"
     1: #include "jsinterp.h"
 15613: #include "jsiter.h"
     1: #include "jslock.h"
     1: #include "jsnum.h"
     1: #include "jsobj.h"
     1: #include "jsopcode.h"
     1: #include "jsscope.h"
     1: #include "jsscript.h"
     1: #include "jsstr.h"
 80507: 
 80507: #include "frontend/FoldConstants.h"
 80507: #include "frontend/ParseMaps.h"
 98180: #include "frontend/Parser.h"
 80506: #include "frontend/TokenStream.h"
 97569: #include "gc/Marking.h"
 80506: 
     1: #if JS_HAS_XML_SUPPORT
     1: #include "jsxml.h"
     1: #endif
     1: 
 48470: #include "jsatominlines.h"
 59968: #include "jsscriptinlines.h"
 50491: 
 72579: #include "frontend/ParseMaps-inl.h"
 80507: #include "frontend/ParseNode-inl.h"
108849: #include "frontend/Parser-inl.h"
108850: #include "frontend/SharedContext-inl.h"
106027: 
106027: #include "vm/NumericConversions.h"
 79981: #include "vm/RegExpObject-inl.h"
 48470: 
 40221: using namespace js;
 54707: using namespace js::gc;
 80632: using namespace js::frontend;
 40221: 
     1: /*
     1:  * Insist that the next token be of type tt, or report errno and return null.
     1:  * NB: this macro uses cx and ts from its lexical environment.
     1:  */
 40854: #define MUST_MATCH_TOKEN_WITH_FLAGS(tt, errno, __flags)                                     \
     1:     JS_BEGIN_MACRO                                                                          \
 40854:         if (tokenStream.getToken((__flags)) != tt) {                                        \
102849:             reportError(NULL, errno);                                                       \
     1:             return NULL;                                                                    \
     1:         }                                                                                   \
     1:     JS_END_MACRO
 40854: #define MUST_MATCH_TOKEN(tt, errno) MUST_MATCH_TOKEN_WITH_FLAGS(tt, errno, 0)
     1: 
104093: StrictMode::StrictModeState
 99779: StrictModeGetter::get() const
 99779: {
108876:     return parser->pc->sc->strictModeState;
104093: }
104093: 
104093: CompileError *
104093: StrictModeGetter::queuedStrictModeError() const
104093: {
108876:     return parser->pc->queuedStrictModeError;
104093: }
104093: 
104093: void
104093: StrictModeGetter::setQueuedStrictModeError(CompileError *e)
104093: {
108876:     parser->pc->setQueuedStrictModeError(e);
 99779: }
 99779: 
108849: bool
108876: frontend::GenerateBlockId(ParseContext *pc, uint32_t &blockid)
108876: {
108876:     if (pc->blockidGen == JS_BIT(20)) {
108876:         JS_ReportErrorNumber(pc->sc->context, js_GetErrorMessage, NULL, JSMSG_NEED_DIET, "program");
108849:         return false;
108849:     }
108876:     JS_ASSERT(pc->blockidGen < JS_BIT(20));
108876:     blockid = pc->blockidGen++;
108849:     return true;
108849: }
108849: 
103227: static void
108876: PushStatementPC(ParseContext *pc, StmtInfoPC *stmt, StmtType type)
108876: {
108876:     stmt->blockid = pc->blockid();
108876:     PushStatement(pc, stmt, type);
103857:     stmt->isFunctionBodyBlock = false;
103227: }
103227: 
108849: // See comment on member function declaration.
108849: bool
108876: ParseContext::define(JSContext *cx, PropertyName *name, ParseNode *pn, Definition::Kind kind)
108849: {
108849:     JS_ASSERT(!pn->isUsed());
108849:     JS_ASSERT_IF(pn->isDefn(), pn->isPlaceholder());
108849: 
108849:     Definition *prevDef = NULL;
108849:     if (kind == Definition::LET)
108849:         prevDef = decls_.lookupFirst(name);
108849:     else
108849:         JS_ASSERT(!decls_.lookupFirst(name));
108849: 
108849:     if (!prevDef)
108849:         prevDef = lexdeps.lookupDefn(name);
108849: 
108849:     if (prevDef) {
108849:         ParseNode **pnup = &prevDef->dn_uses;
108849:         ParseNode *pnu;
108849:         unsigned start = (kind == Definition::LET) ? pn->pn_blockid : bodyid;
108849: 
108849:         while ((pnu = *pnup) != NULL && pnu->pn_blockid >= start) {
108849:             JS_ASSERT(pnu->pn_blockid >= bodyid);
108849:             JS_ASSERT(pnu->isUsed());
108849:             pnu->pn_lexdef = (Definition *) pn;
108849:             pn->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
108849:             pnup = &pnu->pn_link;
108849:         }
108849: 
108849:         if (!pnu || pnu != prevDef->dn_uses) {
108849:             *pnup = pn->dn_uses;
108849:             pn->dn_uses = prevDef->dn_uses;
108849:             prevDef->dn_uses = pnu;
108849: 
108849:             if (!pnu && prevDef->isPlaceholder())
108849:                 lexdeps->remove(name);
108849:         }
108849: 
108849:         pn->pn_dflags |= prevDef->pn_dflags & PND_CLOSED;
108849:     }
108849: 
108849:     JS_ASSERT_IF(kind != Definition::LET, !lexdeps->lookup(name));
108849:     pn->setDefn(true);
108849:     pn->pn_dflags &= ~PND_PLACEHOLDER;
108849:     if (kind == Definition::CONST)
108849:         pn->pn_dflags |= PND_CONST;
108849: 
108849:     Definition *dn = (Definition *)pn;
108849:     switch (kind) {
108849:       case Definition::ARG:
108849:         JS_ASSERT(sc->inFunction());
108849:         dn->setOp(JSOP_GETARG);
108849:         dn->pn_dflags |= PND_BOUND;
108849:         if (!dn->pn_cookie.set(cx, staticLevel, args_.length()))
108849:             return false;
108849:         if (!args_.append(dn))
108849:             return false;
108849:         if (name == cx->runtime->atomState.emptyAtom)
108849:             break;
108849:         if (!decls_.addUnique(name, dn))
108849:             return false;
108849:         break;
108849: 
108849:       case Definition::CONST:
108849:       case Definition::VAR:
108849:         if (sc->inFunction()) {
108849:             dn->setOp(JSOP_GETLOCAL);
108849:             dn->pn_dflags |= PND_BOUND;
108849:             if (!dn->pn_cookie.set(cx, staticLevel, vars_.length()))
108849:                 return false;
108849:             if (!vars_.append(dn))
108849:                 return false;
108849:         }
108849:         if (!decls_.addUnique(name, dn))
108849:             return false;
108849:         break;
108849: 
108849:       case Definition::LET:
108849:         dn->setOp(JSOP_GETLOCAL);
108849:         dn->pn_dflags |= (PND_LET | PND_BOUND);
108849:         JS_ASSERT(dn->pn_cookie.level() == staticLevel); /* see BindLet */
108849:         if (!decls_.addShadow(name, dn))
108849:             return false;
108849:         break;
108849: 
108849:       case Definition::PLACEHOLDER:
108849:       case Definition::NAMED_LAMBDA:
108849:         JS_NOT_REACHED("unexpected kind");
108849:         break;
108849:     }
108849: 
108849:     return true;
108849: }
108849: 
108849: void
108876: ParseContext::prepareToAddDuplicateArg(Definition *prevDecl)
108849: {
108849:     JS_ASSERT(prevDecl->kind() == Definition::ARG);
108849:     JS_ASSERT(decls_.lookupFirst(prevDecl->name()) == prevDecl);
108849:     JS_ASSERT(!prevDecl->isClosed());
108849:     decls_.remove(prevDecl->name());
108849: }
108849: 
108849: void
108876: ParseContext::updateDecl(JSAtom *atom, ParseNode *pn)
108849: {
108849:     Definition *oldDecl = decls_.lookupFirst(atom);
108849: 
108849:     pn->setDefn(true);
108849:     Definition *newDecl = (Definition *)pn;
108849:     decls_.updateFirst(atom, newDecl);
108849: 
108849:     if (!sc->inFunction()) {
108849:         JS_ASSERT(newDecl->isFreeVar());
108849:         return;
108849:     }
108849: 
108849:     JS_ASSERT(oldDecl->isBound());
108849:     JS_ASSERT(!oldDecl->pn_cookie.isFree());
108849:     newDecl->pn_cookie = oldDecl->pn_cookie;
108849:     newDecl->pn_dflags |= PND_BOUND;
108849:     if (JOF_OPTYPE(oldDecl->getOp()) == JOF_QARG) {
108849:         newDecl->setOp(JSOP_GETARG);
108849:         JS_ASSERT(args_[oldDecl->pn_cookie.slot()] == oldDecl);
108849:         args_[oldDecl->pn_cookie.slot()] = newDecl;
108849:     } else {
108849:         JS_ASSERT(JOF_OPTYPE(oldDecl->getOp()) == JOF_LOCAL);
108849:         newDecl->setOp(JSOP_GETLOCAL);
108849:         JS_ASSERT(vars_[oldDecl->pn_cookie.slot()] == oldDecl);
108849:         vars_[oldDecl->pn_cookie.slot()] = newDecl;
108849:     }
108849: }
108849: 
108849: void
108876: ParseContext::popLetDecl(JSAtom *atom)
108849: {
108849:     JS_ASSERT(decls_.lookupFirst(atom)->isLet());
108849:     decls_.remove(atom);
108849: }
108849: 
108849: static void
108876: AppendPackedBindings(const ParseContext *pc, const DeclVector &vec, Binding *dst)
108849: {
108849:     for (unsigned i = 0; i < vec.length(); ++i, ++dst) {
108849:         Definition *dn = vec[i];
108849:         PropertyName *name = dn->name();
108849: 
108849:         BindingKind kind;
108849:         switch (dn->kind()) {
108849:           case Definition::VAR:
108849:             kind = VARIABLE;
108849:             break;
108849:           case Definition::CONST:
108849:             kind = CONSTANT;
108849:             break;
108849:           case Definition::ARG:
108849:             kind = ARGUMENT;
108849:             break;
108849:           case Definition::LET:
108849:           case Definition::NAMED_LAMBDA:
108849:           case Definition::PLACEHOLDER:
108849:             JS_NOT_REACHED("unexpected dn->kind");
108849:         }
108849: 
108849:         /*
108849:          * Bindings::init does not check for duplicates so we must ensure that
108876:          * only one binding with a given name is marked aliased. pc->decls
108849:          * maintains the canonical definition for each name, so use that.
108849:          */
108876:         JS_ASSERT_IF(dn->isClosed(), pc->decls().lookupFirst(name) == dn);
108849:         bool aliased = dn->isClosed() ||
108876:                        (pc->sc->bindingsAccessedDynamically() &&
108876:                         pc->decls().lookupFirst(name) == dn);
108849: 
108849:         *dst = Binding(name, kind, aliased);
108849:     }
108849: }
108849: 
108849: bool
108876: ParseContext::generateFunctionBindings(JSContext *cx, Bindings *bindings) const
108849: {
108849:     JS_ASSERT(sc->inFunction());
108849: 
108849:     unsigned count = args_.length() + vars_.length();
108849:     Binding *packedBindings = cx->tempLifoAlloc().newArrayUninitialized<Binding>(count);
108849:     if (!packedBindings) {
108849:         js_ReportOutOfMemory(cx);
108849:         return false;
108849:     }
108849: 
108849:     AppendPackedBindings(this, args_, packedBindings);
108849:     AppendPackedBindings(this, vars_, packedBindings + args_.length());
108849: 
108849:     if (!bindings->initWithTemporaryStorage(cx, args_.length(), vars_.length(), packedBindings))
108849:         return false;
108849: 
108849:     if (bindings->hasAnyAliasedBindings() || sc->funHasExtensibleScope())
108849:         sc->fun()->flags |= JSFUN_HEAVYWEIGHT;
108849: 
108849:     return true;
108849: }
108849: 
106508: Parser::Parser(JSContext *cx, const CompileOptions &options,
106508:                const jschar *chars, size_t length, bool foldConstants)
 80748:   : AutoGCRooter(cx, PARSER),
 53840:     context(cx),
106783:     strictModeGetter(thisForCtor()),
106508:     tokenStream(cx, options, chars, length, &strictModeGetter),
 99261:     tempPoolMark(NULL),
 80641:     allocator(cx),
 53840:     traceListHead(NULL),
108876:     pc(NULL),
106917:     sct(NULL),
 72098:     keepAtoms(cx->runtime),
 98464:     foldConstants(foldConstants),
107038:     compileAndGo(options.compileAndGo),
108585:     selfHostingMode(options.selfHostingMode)
 53840: {
 72579:     cx->activeCompilations++;
 53840: }
 53840: 
 27012: bool
 99261: Parser::init()
 99261: {
 99261:     if (!context->ensureParseMapPool())
 72579:         return false;
 99779: 
 99261:     tempPoolMark = context->tempLifoAlloc().mark();
 27012:     return true;
 27012: }
 27012: 
 40860: Parser::~Parser()
 27012: {
 27012:     JSContext *cx = context;
 79410:     cx->tempLifoAlloc().release(tempPoolMark);
 72579:     cx->activeCompilations--;
 26970: }
 26970: 
 98708: ObjectBox::ObjectBox(ObjectBox* traceLink, JSObject *obj)
 98708:   : traceLink(traceLink),
 98708:     emitLink(NULL),
 98708:     object(obj),
 98708:     isFunctionBox(false)
 98708: {
 98708: }
 98708: 
 80631: ObjectBox *
 40860: Parser::newObjectBox(JSObject *obj)
 27012: {
 95355:     JS_ASSERT(obj && !IsPoisonedPtr(obj));
 95355: 
  3235:     /*
 80743:      * We use JSContext.tempLifoAlloc to allocate parsed objects and place them
 80743:      * on a list in this Parser to ensure GC safety. Thus the tempLifoAlloc
 80743:      * arenas containing the entries must be alive until we are done with
 80743:      * scanning, parsing and code generation for the whole script or top-level
 80743:      * function.
  3235:      */
 98708: 
 98708:     ObjectBox *objbox = context->tempLifoAlloc().new_<ObjectBox>(traceListHead, obj);
 27012:     if (!objbox) {
 71371:         js_ReportOutOfMemory(context);
 27012:         return NULL;
 27012:     }
 98708: 
 27012:     traceListHead = objbox;
 98708: 
 27012:     return objbox;
 27012: }
 27012: 
109502: FunctionBox::FunctionBox(ObjectBox* traceListHead, JSObject *obj, ParseContext *outerpc,
104093:                          StrictMode::StrictModeState sms)
 98708:   : ObjectBox(traceListHead, obj),
109502:     siblings(outerpc->functionList),
 98708:     kids(NULL),
109602:     parent(outerpc->sc->inFunction() ? outerpc->sc->funbox() : NULL),
102615:     bindings(),
105944:     bufStart(0),
105944:     bufEnd(0),
100154:     ndefaults(0),
104093:     strictModeState(sms),
109603:     inWith(!!outerpc->innermostWith),
 98708:     inGenexpLambda(false),
109502:     cxFlags(outerpc->sc->context)     // the cxFlags are set in LeaveFunction
 98708: {
 98708:     isFunctionBox = true;
109502:     if (!outerpc->sc->inFunction()) {
109502:         JSObject *scope = outerpc->sc->scopeChain();
 98708:         while (scope) {
 98708:             if (scope->isWith())
 98708:                 inWith = true;
 98708:             scope = scope->enclosingScope();
 98708:         }
 98708:     }
 98708: }
 98708: 
 80631: FunctionBox *
109502: Parser::newFunctionBox(JSObject *obj, ParseContext *outerpc, StrictMode::StrictModeState sms)
 27012: {
 95355:     JS_ASSERT(obj && !IsPoisonedPtr(obj));
 40430:     JS_ASSERT(obj->isFunction());
 27012: 
 27012:     /*
 80743:      * We use JSContext.tempLifoAlloc to allocate parsed objects and place them
 80743:      * on a list in this Parser to ensure GC safety. Thus the tempLifoAlloc
 80743:      * arenas containing the entries must be alive until we are done with
 80743:      * scanning, parsing and code generation for the whole script or top-level
 80743:      * function.
 27012:      */
108876:     FunctionBox *funbox =
109502:         context->tempLifoAlloc().new_<FunctionBox>(traceListHead, obj, outerpc, sms);
 27012:     if (!funbox) {
 71371:         js_ReportOutOfMemory(context);
 27012:         return NULL;
 27012:     }
 98708: 
109502:     traceListHead = outerpc->functionList = funbox;
 98687: 
 27012:     return funbox;
 27012: }
 26970: 
 26970: void
 40860: Parser::trace(JSTracer *trc)
 27012: {
 80631:     ObjectBox *objbox = traceListHead;
 27012:     while (objbox) {
 90409:         MarkObjectRoot(trc, &objbox->object, "parser.object");
 59968:         if (objbox->isFunctionBox)
 80631:             static_cast<FunctionBox *>(objbox)->bindings.trace(trc);
 27012:         objbox = objbox->traceLink;
 27012:     }
 27012: }
 27012: 
 27012: static bool
108876: GenerateBlockIdForStmtNode(ParseNode *pn, ParseContext *pc)
108876: {
108876:     JS_ASSERT(pc->topStmt);
108876:     JS_ASSERT(pc->topStmt->maybeScope());
 82873:     JS_ASSERT(pn->isKind(PNK_STATEMENTLIST) || pn->isKind(PNK_LEXICALSCOPE));
108876:     if (!GenerateBlockId(pc, pc->topStmt->blockid))
 27012:         return false;
108876:     pn->pn_blockid = pc->topStmt->blockid;
 27012:     return true;
 27012: }
 27012: 
     1: /*
     1:  * Parse a top-level JS script.
     1:  */
 80631: ParseNode *
 40860: Parser::parse(JSObject *chain)
 27012: {
     1:     /*
     1:      * Protect atoms from being collected by a GC activation, which might
     1:      * - nest on this thread due to out of memory (the so-called "last ditch"
     1:      *   GC attempted within js_NewGCThing), or
     1:      * - run for any reason on another thread if this thread is suspended on
     1:      *   an object lock before it finishes generating bytecode into a script
     1:      *   protected from the GC by a root or a stack frame reference.
     1:      */
104093:     SharedContext globalsc(context, chain, /* fun = */ NULL, /* funbox = */ NULL,
104093:                            StrictModeFromContext(context));
108876:     ParseContext globalpc(this, &globalsc, /* staticLevel = */ 0, /* bodyid = */ 0);
108876:     if (!globalpc.init())
 72579:         return NULL;
 40263: 
 80631:     ParseNode *pn = statements();
     1:     if (pn) {
 40354:         if (!tokenStream.matchToken(TOK_EOF)) {
102849:             reportError(NULL, JSMSG_SYNTAX_ERROR);
     1:             pn = NULL;
 72098:         } else if (foldConstants) {
 98181:             if (!FoldConstants(context, pn, this))
     1:                 pn = NULL;
     1:         }
     1:     }
     1:     return pn;
     1: }
     1: 
     1: /*
     1:  * Insist on a final return before control flows out of pn.  Try to be a bit
     1:  * smart about loops: do {...; return e2;} while(0) at the end of a function
     1:  * that contains an early return e1 will get a strict warning.  Similarly for
     1:  * iloops: while (true){...} is treated as though ... returns.
     1:  */
     1: #define ENDS_IN_OTHER   0
     1: #define ENDS_IN_RETURN  1
     1: #define ENDS_IN_BREAK   2
     1: 
     1: static int
 80631: HasFinalReturn(ParseNode *pn)
 80631: {
 80631:     ParseNode *pn2, *pn3;
 91237:     unsigned rv, rv2, hasDefault;
     1: 
 78294:     switch (pn->getKind()) {
 82873:       case PNK_STATEMENTLIST:
     1:         if (!pn->pn_head)
     1:             return ENDS_IN_OTHER;
 27012:         return HasFinalReturn(pn->last());
     1: 
 82024:       case PNK_IF:
     1:         if (!pn->pn_kid3)
     1:             return ENDS_IN_OTHER;
     1:         return HasFinalReturn(pn->pn_kid2) & HasFinalReturn(pn->pn_kid3);
     1: 
 82024:       case PNK_WHILE:
     1:         pn2 = pn->pn_left;
 82024:         if (pn2->isKind(PNK_TRUE))
     1:             return ENDS_IN_RETURN;
 82024:         if (pn2->isKind(PNK_NUMBER) && pn2->pn_dval)
     1:             return ENDS_IN_RETURN;
     1:         return ENDS_IN_OTHER;
     1: 
 82872:       case PNK_DOWHILE:
     1:         pn2 = pn->pn_right;
 82024:         if (pn2->isKind(PNK_FALSE))
     1:             return HasFinalReturn(pn->pn_left);
 82024:         if (pn2->isKind(PNK_TRUE))
     1:             return ENDS_IN_RETURN;
 82024:         if (pn2->isKind(PNK_NUMBER)) {
     1:             if (pn2->pn_dval == 0)
     1:                 return HasFinalReturn(pn->pn_left);
     1:             return ENDS_IN_RETURN;
     1:         }
     1:         return ENDS_IN_OTHER;
     1: 
 82024:       case PNK_FOR:
     1:         pn2 = pn->pn_left;
 78294:         if (pn2->isArity(PN_TERNARY) && !pn2->pn_kid2)
     1:             return ENDS_IN_RETURN;
     1:         return ENDS_IN_OTHER;
     1: 
 82024:       case PNK_SWITCH:
     1:         rv = ENDS_IN_RETURN;
     1:         hasDefault = ENDS_IN_OTHER;
     1:         pn2 = pn->pn_right;
 82024:         if (pn2->isKind(PNK_LEXICALSCOPE))
 27012:             pn2 = pn2->expr();
     1:         for (pn2 = pn2->pn_head; rv && pn2; pn2 = pn2->pn_next) {
 82024:             if (pn2->isKind(PNK_DEFAULT))
     1:                 hasDefault = ENDS_IN_RETURN;
     1:             pn3 = pn2->pn_right;
 82873:             JS_ASSERT(pn3->isKind(PNK_STATEMENTLIST));
     1:             if (pn3->pn_head) {
 27012:                 rv2 = HasFinalReturn(pn3->last());
     1:                 if (rv2 == ENDS_IN_OTHER && pn2->pn_next)
     1:                     /* Falling through to next case or default. */;
     1:                 else
     1:                     rv &= rv2;
     1:             }
     1:         }
     1:         /* If a final switch has no default case, we judge it harshly. */
     1:         rv &= hasDefault;
     1:         return rv;
     1: 
 82024:       case PNK_BREAK:
     1:         return ENDS_IN_BREAK;
     1: 
 82024:       case PNK_WITH:
     1:         return HasFinalReturn(pn->pn_right);
     1: 
 82024:       case PNK_RETURN:
     1:         return ENDS_IN_RETURN;
     1: 
 82024:       case PNK_COLON:
 82024:       case PNK_LEXICALSCOPE:
 27012:         return HasFinalReturn(pn->expr());
     1: 
 82024:       case PNK_THROW:
     1:         return ENDS_IN_RETURN;
     1: 
 82024:       case PNK_TRY:
     1:         /* If we have a finally block that returns, we are done. */
     1:         if (pn->pn_kid3) {
     1:             rv = HasFinalReturn(pn->pn_kid3);
     1:             if (rv == ENDS_IN_RETURN)
     1:                 return rv;
     1:         }
     1: 
     1:         /* Else check the try block and any and all catch statements. */
     1:         rv = HasFinalReturn(pn->pn_kid1);
     1:         if (pn->pn_kid2) {
 78294:             JS_ASSERT(pn->pn_kid2->isArity(PN_LIST));
     1:             for (pn2 = pn->pn_kid2->pn_head; pn2; pn2 = pn2->pn_next)
     1:                 rv &= HasFinalReturn(pn2);
     1:         }
     1:         return rv;
     1: 
 82024:       case PNK_CATCH:
     1:         /* Check this catch block's body. */
     1:         return HasFinalReturn(pn->pn_kid3);
     1: 
 82024:       case PNK_LET:
     1:         /* Non-binary let statements are let declarations. */
 78294:         if (!pn->isArity(PN_BINARY))
     1:             return ENDS_IN_OTHER;
     1:         return HasFinalReturn(pn->pn_right);
     1: 
     1:       default:
     1:         return ENDS_IN_OTHER;
     1:     }
     1: }
     1: 
103824: static bool
102849: ReportBadReturn(JSContext *cx, Parser *parser, ParseNode *pn, Parser::Reporter reporter,
102849:                 unsigned errnum, unsigned anonerrnum)
     1: {
 57812:     JSAutoByteString name;
109108:     if (parser->pc->sc->fun()->atom()) {
109108:         if (!js_AtomToPrintableString(cx, parser->pc->sc->fun()->atom(), &name))
 57812:             return false;
     1:     } else {
     1:         errnum = anonerrnum;
 57812:     }
102849:     return (parser->*reporter)(pn, errnum, name.ptr());
     1: }
     1: 
103824: static bool
 98181: CheckFinalReturn(JSContext *cx, Parser *parser, ParseNode *pn)
 98181: {
108876:     JS_ASSERT(parser->pc->sc->inFunction());
     1:     return HasFinalReturn(pn) == ENDS_IN_RETURN ||
102849:            ReportBadReturn(cx, parser, pn, &Parser::reportStrictWarning,
     1:                            JSMSG_NO_RETURN_VALUE, JSMSG_ANON_NO_RETURN_VALUE);
     1: }
     1: 
 35323: /*
 35324:  * Check that it is permitted to assign to lhs.  Strict mode code may not
 35324:  * assign to 'eval' or 'arguments'.
 35324:  */
 80507: static bool
 98181: CheckStrictAssignment(JSContext *cx, Parser *parser, ParseNode *lhs)
 98181: {
108876:     if (parser->pc->sc->needStrictChecks() && lhs->isKind(PNK_NAME)) {
 35324:         JSAtom *atom = lhs->pn_atom;
 35324:         JSAtomState *atomState = &cx->runtime->atomState;
 35324:         if (atom == atomState->evalAtom || atom == atomState->argumentsAtom) {
 57812:             JSAutoByteString name;
 57812:             if (!js_AtomToPrintableString(cx, atom, &name) ||
102849:                 !parser->reportStrictModeError(lhs, JSMSG_DEPRECATED_ASSIGN, name.ptr()))
 99779:             {
 35324:                 return false;
 35324:             }
 35324:         }
 35324:     }
 35324:     return true;
 35324: }
 35324: 
 35324: /*
 62048:  * Check that it is permitted to introduce a binding for atom.  Strict mode
 62048:  * forbids introducing new definitions for 'eval', 'arguments', or for any
 62048:  * strict mode reserved keyword.  Use pn for reporting error locations, or use
108876:  * pc's token stream if pn is NULL.
 35325:  */
 35325: bool
108174: CheckStrictBinding(JSContext *cx, Parser *parser, HandlePropertyName name, ParseNode *pn)
 98181: {
108876:     if (!parser->pc->sc->needStrictChecks())
 35325:         return true;
 35325: 
 35325:     JSAtomState *atomState = &cx->runtime->atomState;
 80442:     if (name == atomState->evalAtom ||
 80442:         name == atomState->argumentsAtom ||
 80442:         FindKeyword(name->charsZ(), name->length()))
 80442:     {
 80442:         JSAutoByteString bytes;
 80442:         if (!js_AtomToPrintableString(cx, name, &bytes))
 35325:             return false;
102849:         return parser->reportStrictModeError(pn, JSMSG_BAD_BINDING, bytes.ptr());
 35325:     }
 62048: 
 35325:     return true;
 35325: }
 35325: 
 80631: ParseNode *
 82875: Parser::functionBody(FunctionBodyType type)
     1: {
108876:     JS_ASSERT(pc->sc->inFunction());
108876: 
108876:     StmtInfoPC stmtInfo(context);
108876:     PushStatementPC(pc, &stmtInfo, STMT_BLOCK);
103855:     stmtInfo.isFunctionBodyBlock = true;
     1: 
109503:     JS_ASSERT(!pc->funHasReturnExpr && !pc->funHasReturnVoid);
     1: 
 80631:     ParseNode *pn;
 82875:     if (type == StatementListBody) {
 40263:         pn = statements();
  1967:     } else {
 82875:         JS_ASSERT(type == ExpressionBody);
 82875:         JS_ASSERT(JS_HAS_EXPR_CLOSURES);
104093: 
104093:         // There are no directives to parse, so indicate we're done finding
104093:         // strict mode directives.
104093:         if (!setStrictMode(false))
104093:             return NULL;
 98181:         pn = UnaryNode::create(PNK_RETURN, this);
  1967:         if (pn) {
 40263:             pn->pn_kid = assignExpr();
  1967:             if (!pn->pn_kid) {
  1967:                 pn = NULL;
  1967:             } else {
108876:                 if (pc->sc->funIsGenerator()) {
102849:                     ReportBadReturn(context, this, pn, &Parser::reportError,
  1967:                                     JSMSG_BAD_GENERATOR_RETURN,
  1967:                                     JSMSG_BAD_ANON_GENERATOR_RETURN);
  1967:                     pn = NULL;
  1967:                 } else {
 78294:                     pn->setOp(JSOP_RETURN);
  1967:                     pn->pn_pos.end = pn->pn_kid->pn_pos.end;
  1967:                 }
  1967:             }
  1967:         }
  1967:     }
     1: 
108505:     if (!pn)
108505:         return NULL;
108505: 
108876:     JS_ASSERT(!pc->topStmt->isBlockScope);
108876:     FinishPopStatement(pc);
     1: 
     1:     /* Check for falling off the end of a function that returns a value. */
109503:     if (context->hasStrictOption() && pc->funHasReturnExpr &&
 98451:         !CheckFinalReturn(context, this, pn))
 98451:     {
     1:         pn = NULL;
     1:     }
108505: 
108505:     /* Time to implement the odd semantics of 'arguments'. */
102586:     Rooted<PropertyName*> arguments(context, context->runtime->atomState.argumentsAtom);
 95100: 
 95100:     /*
 95100:      * Non-top-level functions use JSOP_DEFFUN which is a dynamic scope
 95100:      * operation which means it aliases any bindings with the same name.
 95100:      * Due to the implicit declaration mechanism (below), 'arguments' will not
 95100:      * have decls and, even if it did, they will not be noted as closed in the
 95100:      * emitter. Thus, in the corner case of function-statement-overridding-
 95100:      * arguments, flag the whole scope as dynamic.
 95100:      */
108876:     if (FuncStmtSet *set = pc->funcStmts) {
 95100:         for (FuncStmtSet::Range r = set->all(); !r.empty(); r.popFront()) {
 95100:             PropertyName *name = r.front()->asPropertyName();
 95100:             if (name == arguments)
108876:                 pc->sc->setBindingsAccessedDynamically();
108876:             else if (Definition *dn = pc->decls().lookupFirst(name))
 95100:                 dn->pn_dflags |= PND_CLOSED;
 95100:         }
 95100:     }
 95100: 
 95100:     /*
 98687:      * As explained by the ContextFlags::funArgumentsHasLocalBinding comment,
108505:      * create a declaration for 'arguments' if there are any unbound uses in
108505:      * the function body.
 95100:      */
108876:     for (AtomDefnRange r = pc->lexdeps->all(); !r.empty(); r.popFront()) {
108505:         if (r.front().key() == arguments) {
 95100:             Definition *dn = r.front().value();
108876:             pc->lexdeps->remove(arguments);
108505:             dn->pn_dflags |= PND_IMPLICITARGUMENTS;
108876:             if (!pc->define(context, arguments, dn, Definition::VAR))
108505:                 return NULL;
108505:             break;
108505:         }
108505:     }
108505: 
 95100:     /*
108505:      * Report error if both rest parameters and 'arguments' are used. Do this
108505:      * check before adding artificial 'arguments' below.
 95100:      */
108876:     Definition *maybeArgDef = pc->decls().lookupFirst(arguments);
108505:     bool argumentsHasBinding = !!maybeArgDef;
108505:     bool argumentsHasLocalBinding = maybeArgDef && maybeArgDef->kind() != Definition::ARG;
108876:     bool hasRest = pc->sc->fun()->hasRest();
108505:     if (hasRest && argumentsHasLocalBinding) {
105580:         reportError(NULL, JSMSG_ARGUMENTS_AND_REST);
105580:         return NULL;
105580:     }
 99225: 
 95100:     /*
 95100:      * Even if 'arguments' isn't explicitly mentioned, dynamic name lookup
105580:      * forces an 'arguments' binding. The exception is that functions with rest
105580:      * parameters are free from 'arguments'.
105580:      */
108876:     if (!argumentsHasBinding && pc->sc->bindingsAccessedDynamically() && !hasRest) {
108876:         ParseNode *pn = NameNode::create(PNK_NAME, arguments, this, pc);
108505:         if (!pn)
108505:             return NULL;
108876:         if (!pc->define(context, arguments, pn, Definition::VAR))
108505:             return NULL;
108505:         argumentsHasBinding = true;
108505:         argumentsHasLocalBinding = true;
 95100:     }
 95100: 
 95100:     /*
 95100:      * Now that all possible 'arguments' bindings have been added, note whether
 95100:      * 'arguments' has a local binding and whether it unconditionally needs an
105580:      * arguments object. (Also see the flags' comments in ContextFlags.)
105580:      */
108505:     if (argumentsHasLocalBinding) {
108876:         pc->sc->setFunArgumentsHasLocalBinding();
 95100: 
 95100:         /* Dynamic scope access destroys all hope of optimization. */
108876:         if (pc->sc->bindingsAccessedDynamically())
108876:             pc->sc->setFunDefinitelyNeedsArgsObj();
 95100: 
 95100:         /*
 95100:          * Check whether any parameters have been assigned within this
 95100:          * function. In strict mode parameters do not alias arguments[i], and
 95100:          * to make the arguments object reflect initial parameter values prior
 95100:          * to any mutation we create it eagerly whenever parameters are (or
 95100:          * might, in the case of calls to eval) be assigned.
 95100:          */
108876:         if (pc->sc->needStrictChecks()) {
108876:             for (AtomDefnListMap::Range r = pc->decls().all(); !r.empty(); r.popFront()) {
103859:                 DefinitionList &dlist = r.front().value();
103859:                 for (DefinitionList::Range dr = dlist.all(); !dr.empty(); dr.popFront()) {
103859:                     Definition *dn = dr.front();
 95099:                     if (dn->kind() == Definition::ARG && dn->isAssigned()) {
108876:                         pc->sc->setFunDefinitelyNeedsArgsObj();
103859:                         goto exitLoop;
103859:                     }
103859:                 }
103859:             }
103859:           exitLoop: ;
 95099:         }
 95099:     }
 95099: 
     1:     return pn;
     1: }
     1: 
 98181: // Create a placeholder Definition node for |atom|.
 98181: // Nb: unlike most functions that are passed a Parser, this one gets a
108876: // SharedContext passed in separately, because in this case |pc| may not equal
108876: // |parser->pc|.
 80631: static Definition *
108876: MakePlaceholder(ParseNode *pn, Parser *parser, ParseContext *pc)
108876: {
108876:     Definition *dn = (Definition *) NameNode::create(PNK_NAME, pn->pn_atom, parser, pc);
 27012:     if (!dn)
 27012:         return NULL;
 27012: 
 78294:     dn->setOp(JSOP_NOP);
 78294:     dn->setDefn(true);
 28557:     dn->pn_dflags |= PND_PLACEHOLDER;
 72579:     return dn;
 27012: }
 27012: 
 27012: static void
 80631: ForgetUse(ParseNode *pn)
 27012: {
 78294:     if (!pn->isUsed()) {
 78294:         JS_ASSERT(!pn->isDefn());
 27012:         return;
 27012:     }
 27012: 
 80631:     ParseNode **pnup = &pn->lexdef()->dn_uses;
 80631:     ParseNode *pnu;
 27012:     while ((pnu = *pnup) != pn)
 27012:         pnup = &pnu->pn_link;
 27012:     *pnup = pn->pn_link;
 78294:     pn->setUsed(false);
 27012: }
 27012: 
 80631: static ParseNode *
 98181: MakeAssignment(ParseNode *pn, ParseNode *rhs, Parser *parser)
 98181: {
 98181:     ParseNode *lhs = parser->cloneNode(*pn);
 27012:     if (!lhs)
 27012:         return NULL;
 27012: 
 78294:     if (pn->isUsed()) {
 80631:         Definition *dn = pn->pn_lexdef;
 80631:         ParseNode **pnup = &dn->dn_uses;
 27012: 
 27012:         while (*pnup != pn)
 27012:             pnup = &(*pnup)->pn_link;
 27012:         *pnup = lhs;
 27012:         lhs->pn_link = pn->pn_link;
 27012:         pn->pn_link = NULL;
 27012:     }
 27012: 
 82024:     pn->setKind(PNK_ASSIGN);
 78294:     pn->setOp(JSOP_NOP);
 78294:     pn->setArity(PN_BINARY);
 78294:     pn->setInParens(false);
 78294:     pn->setUsed(false);
 78294:     pn->setDefn(false);
 27012:     pn->pn_left = lhs;
 27012:     pn->pn_right = rhs;
109047:     pn->pn_pos.end = rhs->pn_pos.end;
 27012:     return lhs;
 27012: }
 27012: 
107867: /* See comment for use in Parser::functionDef. */
107867: static bool
 98181: MakeDefIntoUse(Definition *dn, ParseNode *pn, JSAtom *atom, Parser *parser)
 27012: {
107867:     /* Turn pn into a definition. */
108876:     parser->pc->updateDecl(atom, pn);
107867: 
107867:     /* Change all uses of dn to be uses of pn. */
 80631:     for (ParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
 78294:         JS_ASSERT(pnu->isUsed());
 78294:         JS_ASSERT(!pnu->isDefn());
 80631:         pnu->pn_lexdef = (Definition *) pn;
 30457:         pn->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
 30457:     }
 30457:     pn->pn_dflags |= dn->pn_dflags & PND_USE2DEF_FLAGS;
 27012:     pn->dn_uses = dn;
 27012: 
107867:     /*
107867:      * A PNK_FUNCTION node must be a definition, so convert shadowed function
107867:      * statements into nops. This is valid since all body-level function
107867:      * statement initialization happens at the beginning of the function
107867:      * (thus, only the last statement's effect is visible). E.g., in
107867:      *
107867:      *   function outer() {
107867:      *     function g() { return 1 }
107867:      *     assertEq(g(), 2);
107867:      *     function g() { return 2 }
107867:      *     assertEq(g(), 2);
107867:      *   }
107867:      *
107867:      * both asserts are valid.
107867:      */
107869:     if (dn->getKind() == PNK_FUNCTION) {
107869:         JS_ASSERT(dn->functionIsHoisted());
107867:         pn->dn_uses = dn->pn_link;
107867:         parser->prepareNodeForMutation(dn);
107867:         dn->setKind(PNK_NOP);
107867:         dn->setArity(PN_NULLARY);
107867:         return true;
107867:     }
107867: 
107867:     /*
107867:      * If dn is arg, or in [var, const, let] and has an initializer, then we
107867:      * must rewrite it to be an assignment node, whose freshly allocated
107867:      * left-hand side becomes a use of pn.
107867:      */
107867:     if (dn->canHaveInitializer()) {
107867:         if (ParseNode *rhs = dn->expr()) {
107867:             ParseNode *lhs = MakeAssignment(dn, rhs, parser);
107867:             if (!lhs)
107867:                 return false;
107867:             pn->dn_uses = lhs;
107867:             dn->pn_link = NULL;
107867:             dn = (Definition *) lhs;
107867:         }
107867:     }
107867: 
107867:     /* Turn dn into a use of pn. */
107867:     JS_ASSERT(dn->isKind(PNK_NAME));
107867:     JS_ASSERT(dn->isArity(PN_NAME));
107867:     JS_ASSERT(dn->pn_atom == atom);
107867:     dn->setOp((js_CodeSpec[dn->getOp()].format & JOF_SET) ? JSOP_SETNAME : JSOP_NAME);
 78294:     dn->setDefn(false);
 78294:     dn->setUsed(true);
 80631:     dn->pn_lexdef = (Definition *) pn;
 47573:     dn->pn_cookie.makeFree();
 27012:     dn->pn_dflags &= ~PND_BOUND;
107867:     return true;
 27012: }
 27012: 
     1: /*
     1:  * Parameter block types for the several Binder functions.  We use a common
     1:  * helper function signature in order to share code among destructuring and
     1:  * simple variable declaration parsers.  In the destructuring case, the binder
     1:  * function is called indirectly from the variable declaration parser by way
     1:  * of CheckDestructuring and its friends.
     1:  */
103824: typedef bool
108174: (*Binder)(JSContext *cx, BindData *data, HandlePropertyName name, Parser *parser);
     1: 
103824: static bool
108174: BindLet(JSContext *cx, BindData *data, HandlePropertyName name, Parser *parser);
 86078: 
103824: static bool
108174: BindVarOrConst(JSContext *cx, BindData *data, HandlePropertyName name, Parser *parser);
 86078: 
105835: struct frontend::BindData {
106176:     BindData(JSContext *cx) : let(cx) {}
 29379: 
 80631:     ParseNode       *pn;        /* name node for definition processing and
 27012:                                    error source coordinates */
     1:     JSOp            op;         /* prolog bytecode or nop */
     1:     Binder          binder;     /* binder, discriminates u */
 97353: 
 97353:     struct LetData {
 97353:         LetData(JSContext *cx) : blockObj(cx) {}
 86078:         VarContext varContext;
 99421:         Rooted<StaticBlockObject*> blockObj;
 91237:         unsigned   overflow;
     1:     } let;
 97353: 
 91237:     void initLet(VarContext varContext, StaticBlockObject &blockObj, unsigned overflow) {
 86078:         this->pn = NULL;
 86078:         this->op = JSOP_NOP;
 86078:         this->binder = BindLet;
 86078:         this->let.varContext = varContext;
 86483:         this->let.blockObj = &blockObj;
 86078:         this->let.overflow = overflow;
 86078:     }
 86078: 
 86078:     void initVarOrConst(JSOp op) {
 86078:         this->op = op;
 86078:         this->binder = BindVarOrConst;
 86078:     }
     1: };
     1: 
 27012: JSFunction *
108876: Parser::newFunction(ParseContext *pc, JSAtom *atom, FunctionSyntaxKind kind)
 72567: {
 72567:     JS_ASSERT_IF(kind == Statement, atom != NULL);
 27012: 
 27012:     /*
 27012:      * Find the global compilation context in order to pre-set the newborn
108876:      * function's parent slot to pc->sc->scopeChain. If the global context is a
 27012:      * compile-and-go one, we leave the pre-set parent intact; otherwise we
 27012:      * clear parent and proto.
 27012:      */
108876:     while (pc->parent)
108876:         pc = pc->parent;
 86437: 
 99421:     RootedObject parent(context);
108876:     parent = pc->sc->inFunction() ? NULL : pc->sc->scopeChain();
 72567: 
 99421:     RootedFunction fun(context);
108585:     uint32_t flags = JSFUN_INTERPRETED | (kind == Expression ? JSFUN_LAMBDA : 0);
108585:     if (selfHostingMode)
108585:         flags |= JSFUN_SELF_HOSTED;
108585:     fun = js_NewFunction(context, NULL, NULL, 0, flags, parent, atom);
 98464:     if (fun && !compileAndGo) {
104205:         if (!JSObject::clearParent(context, fun))
104205:             return NULL;
104205:         if (!JSObject::clearType(context, fun))
 83230:             return NULL;
 83283:         fun->setEnvironment(NULL);
 13691:     }
 13691:     return fun;
  8444: }
  8444: 
103824: static bool
 40320: MatchOrInsertSemicolon(JSContext *cx, TokenStream *ts)
 40320: {
 40854:     TokenKind tt = ts->peekTokenSameLine(TSF_OPERAND);
 25110:     if (tt == TOK_ERROR)
103823:         return false;
 25110:     if (tt != TOK_EOF && tt != TOK_EOL && tt != TOK_SEMI && tt != TOK_RC) {
 54158:         /* Advance the scanner for proper error location reporting. */
 54158:         ts->getToken(TSF_OPERAND);
102849:         ts->reportError(JSMSG_SEMI_BEFORE_STMNT);
103823:         return false;
 25110:     }
 40354:     (void) ts->matchToken(TOK_SEMI);
103823:     return true;
 25110: }
 25110: 
100230: static bool
 80989: DeoptimizeUsesWithin(Definition *dn, const TokenPos &pos)
 80989: {
 91237:     unsigned ndeoptimized = 0;
 80989: 
 80989:     for (ParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
 80989:         JS_ASSERT(pnu->isUsed());
 80989:         JS_ASSERT(!pnu->isDefn());
 80989:         if (pnu->pn_pos.begin >= pos.begin && pnu->pn_pos.end <= pos.end) {
 80989:             pnu->pn_dflags |= PND_DEOPTIMIZED;
 80989:             ++ndeoptimized;
 80989:         }
 80989:     }
 80989: 
 80989:     return ndeoptimized != 0;
 80989: }
 80989: 
 95099: /*
 95099:  * Beware: this function is called for functions nested in other functions or
 95099:  * global scripts but not for functions compiled through the Function
 95099:  * constructor or JSAPI. To always execute code when a function has finished
 95099:  * parsing, use Parser::functionBody.
 95099:  */
 80989: static bool
 98181: LeaveFunction(ParseNode *fn, Parser *parser, PropertyName *funName = NULL,
 72567:               FunctionSyntaxKind kind = Expression)
 40263: {
108505:     JSContext *cx = parser->context;
108876:     ParseContext *funpc = parser->pc;
108876:     ParseContext *pc = funpc->parent;
108876:     pc->blockidGen = funpc->blockidGen;
 27012: 
 80631:     FunctionBox *funbox = fn->pn_funbox;
108876:     funbox->cxFlags = funpc->sc->cxFlags;   // copy all the flags
108876:     funbox->kids = funpc->functionList;
108876: 
108876:     if (!pc->topStmt || pc->topStmt->type == STMT_BLOCK)
 27012:         fn->pn_dflags |= PND_BLOCKCHILD;
 27012: 
108876:     /* Propagate unresolved lexical names up to pc->lexdeps. */
108876:     if (funpc->lexdeps->count()) {
108876:         for (AtomDefnRange r = funpc->lexdeps->all(); !r.empty(); r.popFront()) {
 72579:             JSAtom *atom = r.front().key();
 80631:             Definition *dn = r.front().value();
 27012:             JS_ASSERT(dn->isPlaceholder());
 27012: 
 80442:             if (atom == funName && kind == Expression) {
 78294:                 dn->setOp(JSOP_CALLEE);
108876:                 if (!dn->pn_cookie.set(cx, funpc->staticLevel,
101616:                                        UpvarCookie::CALLEE_SLOT))
101616:                     return false;
 27012:                 dn->pn_dflags |= PND_BOUND;
107869:                 JS_ASSERT(dn->kind() == Definition::NAMED_LAMBDA);
109030: 
109030:                 /*
109030:                  * Since 'dn' is a placeholder, it has not been defined in the
109030:                  * ParseContext and hence we must manually flag a closed-over
109030:                  * callee name as needing a dynamic scope (this is done for all
109030:                  * definitions in the ParseContext by generateFunctionBindings).
109030:                  *
109030:                  * If 'dn' has been assigned to, then we also flag the function
109030:                  * scope has needing a dynamic scope so that dynamic scope
109030:                  * setter can either ignore the set (in non-strict mode) or
109030:                  * produce an error (in strict mode).
109030:                  */
109030:                 if (dn->isClosed() || dn->isAssigned())
108876:                     funpc->sc->fun()->flags |= JSFUN_HEAVYWEIGHT;
 27012:                 continue;
 27012:             }
 27012: 
108876:             Definition *outer_dn = pc->decls().lookupFirst(atom);
 52554: 
 52554:             /*
 52554:              * Make sure to deoptimize lexical dependencies that are polluted
105526:              * by eval and function statements (which both flag the function as
105526:              * having an extensible scope) or any enclosing 'with'.
105526:              */
109603:             if (funpc->sc->funHasExtensibleScope() || pc->innermostWith)
 52554:                 DeoptimizeUsesWithin(dn, fn->pn_pos);
 52554: 
 72579:             if (!outer_dn) {
108876:                 AtomDefnAddPtr p = pc->lexdeps->lookupForAdd(atom);
 72579:                 if (p) {
 72579:                     outer_dn = p.value();
 72579:                 } else {
 72579:                     /*
 72579:                      * Create a new placeholder for our outer lexdep. We could
 72579:                      * simply re-use the inner placeholder, but that introduces
 72579:                      * subtleties in the case where we find a later definition
 72579:                      * that captures an existing lexdep. For example:
 57762:                      *
 57762:                      *   function f() { function g() { x; } let x; }
 57762:                      *
 72579:                      * Here, g's TOK_UPVARS node lists the placeholder for x,
 72579:                      * which must be captured by the 'let' declaration later,
 72579:                      * since 'let's are hoisted.  Taking g's placeholder as our
 72579:                      * own would work fine. But consider:
 57762:                      *
 57762:                      *   function f() { x; { function g() { x; } let x; } }
 57762:                      *
 72579:                      * Here, the 'let' must not capture all the uses of f's
 72579:                      * lexdep entry for x, but it must capture the x node
 72579:                      * referred to from g's TOK_UPVARS node.  Always turning
 72579:                      * inherited lexdeps into uses of a new outer definition
 57762:                      * allows us to handle both these cases in a natural way.
 57762:                      */
108876:                     outer_dn = MakePlaceholder(dn, parser, pc);
108876:                     if (!outer_dn || !pc->lexdeps->add(p, atom, outer_dn))
 71687:                         return false;
 71687:                 }
 72579:             }
 57762: 
 27012:             /*
 27012:              * Insert dn's uses list at the front of outer_dn's list.
 27012:              *
 27012:              * Without loss of generality or correctness, we allow a dn to
 27012:              * be in inner and outer lexdeps, since the purpose of lexdeps
 27012:              * is one-pass coordination of name use and definition across
 27012:              * functions, and if different dn's are used we'll merge lists
 27012:              * when leaving the inner function.
 27012:              *
 27012:              * The dn == outer_dn case arises with generator expressions
 27012:              * (see CompExprTransplanter::transplant, the PN_FUNC/PN_NAME
 27012:              * case), and nowhere else, currently.
 27012:              */
 27012:             if (dn != outer_dn) {
108506:                 if (ParseNode *pnu = dn->dn_uses) {
108506:                     while (true) {
 27012:                         pnu->pn_lexdef = outer_dn;
108506:                         if (!pnu->pn_link)
108506:                             break;
108506:                         pnu = pnu->pn_link;
108506:                     }
108506:                     pnu->pn_link = outer_dn->dn_uses;
108506:                     outer_dn->dn_uses = dn->dn_uses;
108506:                     dn->dn_uses = NULL;
108506:                 }
108506: 
 28557:                 outer_dn->pn_dflags |= dn->pn_dflags & ~PND_PLACEHOLDER;
 57762:             }
 52878: 
 52878:             /* Mark the outer dn as escaping. */
 52878:             outer_dn->pn_dflags |= PND_CLOSED;
 27012:         }
108505:     }
108505: 
108876:     if (!funpc->generateFunctionBindings(cx, &funbox->bindings))
 27012:         return false;
 27371: 
108876:     funpc->lexdeps.releaseMap(cx);
 27012:     return true;
 27012: }
 27012: 
107871: /*
108505:  * DefineArg is called for both the arguments of a regular function definition
108505:  * and the arguments specified by the Function constructor.
108505:  *
108936:  * The 'disallowDuplicateArgs' bool indicates whether the use of another
108936:  * feature (destructuring or default arguments) disables duplicate arguments.
108936:  * (ECMA-262 requires us to support duplicate parameter names, but, for newer
108936:  * features, we consider the code to have "opted in" to higher standards and
108936:  * forbid duplicates.)
108505:  *
108505:  * If 'duplicatedArg' is non-null, then DefineArg assigns to it any previous
108936:  * argument with the same name. The caller may use this to report an error when
108936:  * one of the abovementioned features occurs after a duplicate.
107871:  */
107871: bool
108936: frontend::DefineArg(Parser *parser, ParseNode *funcpn, HandlePropertyName name,
108936:                     bool disallowDuplicateArgs, Definition **duplicatedArg)
107871: {
107873:     JSContext *cx = parser->context;
108876:     ParseContext *pc = parser->pc;
108876:     SharedContext *sc = pc->sc;
107873: 
108505:     /* Handle duplicate argument names. */
108876:     if (Definition *prevDecl = pc->decls().lookupFirst(name)) {
107871:         /*
108505:          * Strict-mode disallows duplicate args. We may not know whether we are
108505:          * in strict mode or not (since the function body hasn't been parsed).
108505:          * In such cases, reportStrictModeError will queue up the potential
108505:          * error and return 'true'.
107871:          */
108505:         if (sc->needStrictChecks()) {
108505:             JSAutoByteString bytes;
108505:             if (!js_AtomToPrintableString(cx, name, &bytes))
108505:                 return false;
108505:             if (!parser->reportStrictModeError(prevDecl, JSMSG_DUPLICATE_FORMAL, bytes.ptr()))
108505:                 return false;
108505:         }
108505: 
108936:         if (disallowDuplicateArgs) {
108936:             parser->reportError(prevDecl, JSMSG_BAD_DUP_ARGS);
108505:             return false;
108505:         }
108505: 
108505:         if (duplicatedArg)
108505:             *duplicatedArg = prevDecl;
108505: 
108876:         /* ParseContext::define assumes and asserts prevDecl is not in decls. */
108876:         pc->prepareToAddDuplicateArg(prevDecl);
108876:     }
108876: 
108876:     ParseNode *argpn = NameNode::create(PNK_NAME, name, parser, parser->pc);
107871:     if (!argpn)
107871:         return false;
108505: 
108505:     if (!CheckStrictBinding(parser->context, parser, name, argpn))
107872:         return false;
108505: 
108505:     funcpn->pn_body->append(argpn);
108876:     return parser->pc->define(parser->context, name, argpn, Definition::ARG);
107871: }
107871: 
107871: #if JS_HAS_DESTRUCTURING
107871: static bool
108174: BindDestructuringArg(JSContext *cx, BindData *data, HandlePropertyName name, Parser *parser)
107871: {
108876:     ParseContext *pc = parser->pc;
108876:     JS_ASSERT(pc->sc->inFunction());
108876: 
108876:     if (pc->decls().lookupFirst(name)) {
108936:         parser->reportError(NULL, JSMSG_BAD_DUP_ARGS);
107871:         return false;
107871:     }
107871: 
108505:     if (!CheckStrictBinding(cx, parser, name, data->pn))
107872:         return false;
107871: 
108876:     return pc->define(cx, name, data->pn, Definition::VAR);
107871: }
107871: #endif /* JS_HAS_DESTRUCTURING */
107871: 
 51088: bool
109500: Parser::functionArguments(ParseNode **listp, ParseNode* funcpn, bool &hasRest)
 51088: {
 51088:     if (tokenStream.getToken() != TOK_LP) {
102849:         reportError(NULL, JSMSG_PAREN_BEFORE_FORMAL);
 51088:         return false;
 51088:     }
 51088: 
108876:     FunctionBox *funbox = pc->sc->funbox();
108505:     funbox->bufStart = tokenStream.offsetOfToken(tokenStream.currentToken());
105944: 
 99225:     hasRest = false;
 99225: 
100154:     ParseNode *argsbody = ListNode::create(PNK_ARGSBODY, this);
100154:     if (!argsbody)
100154:         return false;
100154:     argsbody->setOp(JSOP_NOP);
100154:     argsbody->makeEmpty();
108505: 
108505:     funcpn->pn_body = argsbody;
100154: 
 51088:     if (!tokenStream.matchToken(TOK_RP)) {
100154:         bool hasDefaults = false;
108505:         Definition *duplicatedArg = NULL;
108505:         bool destructuringArg = false;
 51088: #if JS_HAS_DESTRUCTURING
 80631:         ParseNode *list = NULL;
 51088: #endif
 52503: 
 51088:         do {
 99225:             if (hasRest) {
102849:                 reportError(NULL, JSMSG_PARAMETER_AFTER_REST);
 99225:                 return false;
 99225:             }
 51088:             switch (TokenKind tt = tokenStream.getToken()) {
 51088: #if JS_HAS_DESTRUCTURING
 51088:               case TOK_LB:
 51088:               case TOK_LC:
 51088:               {
 51088:                 /* See comment below in the TOK_NAME case. */
108505:                 if (duplicatedArg) {
108936:                     reportError(duplicatedArg, JSMSG_BAD_DUP_ARGS);
108505:                     return false;
108505:                 }
108505: 
 99552:                 if (hasDefaults) {
102849:                     reportError(NULL, JSMSG_NONDEFAULT_FORMAL_AFTER_DEFAULT);
 99552:                     return false;
 99552:                 }
 99552: 
 51088:                 destructuringArg = true;
 51088: 
 51088:                 /*
 51088:                  * A destructuring formal parameter turns into one or more
 51088:                  * local variables initialized from properties of a single
 51088:                  * anonymous positional parameter, so here we must tweak our
 51088:                  * binder and its data.
 51088:                  */
 97353:                 BindData data(context);
 51088:                 data.pn = NULL;
 51088:                 data.op = JSOP_DEFVAR;
 51088:                 data.binder = BindDestructuringArg;
 80631:                 ParseNode *lhs = destructuringExpr(&data, tt);
 51088:                 if (!lhs)
 51088:                     return false;
 51088: 
 51088:                 /*
 51088:                  * Synthesize a destructuring assignment from the single
 51088:                  * anonymous positional parameter into the destructuring
 51088:                  * left-hand-side expression and accumulate it in list.
 51088:                  */
108505:                 PropertyName *name = context->runtime->atomState.emptyAtom;
108876:                 ParseNode *rhs = NameNode::create(PNK_NAME, name, this, this->pc);
 51088:                 if (!rhs)
 51088:                     return false;
108505: 
108876:                 if (!pc->define(context, name, rhs, Definition::ARG))
101616:                     return false;
 51088: 
 89334:                 ParseNode *item = new_<BinaryNode>(PNK_ASSIGN, JSOP_NOP, lhs->pn_pos, lhs, rhs);
 51088:                 if (!item)
 51088:                     return false;
109047:                 if (list) {
109047:                     list->append(item);
109047:                 } else {
 98181:                     list = ListNode::create(PNK_VAR, this);
 51088:                     if (!list)
 51088:                         return false;
109047:                     list->initList(item);
 51088:                     *listp = list;
 51088:                 }
 51088:                 break;
 51088:               }
 51088: #endif /* JS_HAS_DESTRUCTURING */
 51088: 
 99225:               case TOK_TRIPLEDOT:
 99225:               {
 99225:                 hasRest = true;
 99225:                 tt = tokenStream.getToken();
 99225:                 if (tt != TOK_NAME) {
 99225:                     if (tt != TOK_ERROR)
102849:                         reportError(NULL, JSMSG_NO_REST_NAME);
 99225:                     return false;
 99225:                 }
 99225:                 /* Fall through */
 99225:               }
 99225: 
 51088:               case TOK_NAME:
 51088:               {
108505:                 RootedPropertyName name(context, tokenStream.currentToken().name());
108936:                 bool disallowDuplicateArgs = destructuringArg || hasDefaults;
108936:                 if (!DefineArg(this, funcpn, name, disallowDuplicateArgs, &duplicatedArg))
 51088:                     return false;
 99552: 
 99552:                 if (tokenStream.matchToken(TOK_ASSIGN)) {
 99552:                     if (hasRest) {
102849:                         reportError(NULL, JSMSG_REST_WITH_DEFAULT);
 99552:                         return false;
 99552:                     }
108936:                     if (duplicatedArg) {
108936:                         reportError(duplicatedArg, JSMSG_BAD_DUP_ARGS);
108936:                         return false;
108936:                     }
 99552:                     hasDefaults = true;
 99552:                     ParseNode *def_expr = assignExprWithoutYield(JSMSG_YIELD_IN_DEFAULT);
 99552:                     if (!def_expr)
 99552:                         return false;
108505:                     ParseNode *arg = funcpn->pn_body->last();
100154:                     arg->pn_dflags |= PND_DEFAULT;
100154:                     arg->pn_expr = def_expr;
108505:                     funbox->ndefaults++;
 99552:                 } else if (!hasRest && hasDefaults) {
102849:                     reportError(NULL, JSMSG_NONDEFAULT_FORMAL_AFTER_DEFAULT);
 99552:                     return false;
 99552:                 }
 99552: 
 51088:                 break;
 51088:               }
 51088: 
 51088:               default:
102849:                 reportError(NULL, JSMSG_MISSING_FORMAL);
 51088:                 /* FALL THROUGH */
 51088:               case TOK_ERROR:
 51088:                 return false;
 51088:             }
 51088:         } while (tokenStream.matchToken(TOK_COMMA));
 51088: 
 51088:         if (tokenStream.getToken() != TOK_RP) {
102849:             reportError(NULL, JSMSG_PAREN_AFTER_FORMAL);
 51088:             return false;
 51088:         }
 51088:     }
 51088: 
 51088:     return true;
 51088: }
 51088: 
 80631: ParseNode *
 95355: Parser::functionDef(HandlePropertyName funName, FunctionType type, FunctionSyntaxKind kind)
 80442: {
 80442:     JS_ASSERT_IF(kind == Statement, funName);
 72567: 
     1:     /* Make a TOK_FUNCTION node. */
 98181:     ParseNode *pn = FunctionNode::create(PNK_FUNCTION, this);
     1:     if (!pn)
     1:         return NULL;
 27012:     pn->pn_body = NULL;
 47573:     pn->pn_cookie.makeFree();
 94151:     pn->pn_dflags = 0;
     1: 
107869:     /* Function statements add a binding to the enclosing scope. */
108876:     bool bodyLevel = pc->atBodyLevel();
 72567:     if (kind == Statement) {
107869:         /*
107869:          * Handle redeclaration and optimize cases where we can statically bind the
107869:          * function (thereby avoiding JSOP_DEFFUN and dynamic name lookup).
107869:          */
108876:         if (Definition *dn = pc->decls().lookupFirst(funName)) {
 78294:             JS_ASSERT(!dn->isUsed());
 78294:             JS_ASSERT(dn->isDefn());
 27012: 
107869:             if (context->hasStrictOption() || dn->kind() == Definition::CONST) {
 57812:                 JSAutoByteString name;
107869:                 Reporter reporter = (dn->kind() != Definition::CONST)
102849:                                     ? &Parser::reportStrictWarning
102849:                                     : &Parser::reportError;
 80442:                 if (!js_AtomToPrintableString(context, funName, &name) ||
107869:                     !(this->*reporter)(NULL, JSMSG_REDECLARED_VAR, Definition::kindString(dn->kind()),
102849:                                        name.ptr()))
102849:                 {
     1:                     return NULL;
     1:                 }
     1:             }
 27012: 
107867:             /*
107867:              * Body-level function statements are effectively variable
107867:              * declarations where the initialization is hoisted to the
107867:              * beginning of the block. This means that any other variable
107867:              * declaration with the same name is really just an assignment to
107867:              * the function's binding (which is mutable), so turn any existing
107867:              * declaration into a use.
107867:              */
107867:             if (bodyLevel && !MakeDefIntoUse(dn, pn, funName, this))
107867:                 return NULL;
 59229:         } else if (bodyLevel) {
 27012:             /*
 27012:              * If this function was used before it was defined, claim the
 40239:              * pre-created definition node for this function that primaryExpr
108876:              * put in pc->lexdeps on first forward reference, and recycle pn.
108876:              */
108876:             if (Definition *fn = pc->lexdeps.lookupDefn(funName)) {
 78294:                 JS_ASSERT(fn->isDefn());
 82024:                 fn->setKind(PNK_FUNCTION);
 78294:                 fn->setArity(PN_FUNC);
 27012:                 fn->pn_pos.begin = pn->pn_pos.begin;
 64260:                 fn->pn_pos.end = pn->pn_pos.end;
 64260: 
 27012:                 fn->pn_body = NULL;
 47573:                 fn->pn_cookie.makeFree();
 27012: 
108876:                 pc->lexdeps->remove(funName);
 80641:                 freeTree(pn);
 27012:                 pn = fn;
 27012:             }
 27012: 
108876:             if (!pc->define(context, funName, pn, Definition::VAR))
108505:                 return NULL;
107869:         }
107869: 
107869:         /*
107869:          * As a SpiderMonkey-specific extension, non-body-level function
107869:          * statements (e.g., functions in an "if" or "while" block) are
107869:          * dynamically bound when control flow reaches the statement. The
107869:          * emitter normally emits functions in two passes (see PNK_ARGSBODY).
107869:          * To distinguish
107869:          */
107869:         if (bodyLevel) {
107869:             JS_ASSERT(pn->functionIsHoisted());
108876:             JS_ASSERT_IF(pc->sc->inFunction(), !pn->pn_cookie.isFree());
108876:             JS_ASSERT_IF(!pc->sc->inFunction(), pn->pn_cookie.isFree());
105580:         } else {
108876:             JS_ASSERT(pc->sc->strictModeState != StrictMode::STRICT);
107869:             JS_ASSERT(pn->pn_cookie.isFree());
108876:             pc->sc->setFunMightAliasLocals();
108876:             pc->sc->setFunHasExtensibleScope();
107869:             pn->setOp(JSOP_DEFFUN);
107869: 
107869:             /*
107869:              * Instead of setting bindingsAccessedDynamically, which would be
107869:              * overly conservative, remember the names of all function
107869:              * statements and mark any bindings with the same as aliased at the
107869:              * end of functionBody.
107869:              */
108876:             if (!pc->funcStmts) {
108876:                 pc->funcStmts = context->new_<FuncStmtSet>(context);
108876:                 if (!pc->funcStmts || !pc->funcStmts->init())
108876:                     return NULL;
108876:             }
108876:             if (!pc->funcStmts->put(funName))
107869:                 return NULL;
107869:         }
107869: 
107869:         /* No further binding (in BindNameToSlot) is needed for functions. */
 27012:         pn->pn_dflags |= PND_BOUND;
107869:     } else {
107869:         /* A function expression does not introduce any binding. */
107869:         pn->setOp(JSOP_LAMBDA);
 27012:     }
 27012: 
108876:     ParseContext *outerpc = pc;
108876: 
108876:     RootedFunction fun(context, newFunction(outerpc, funName, kind));
100230:     if (!fun)
100230:         return NULL;
100230: 
104093:     // Inherit strictness if neeeded.
108876:     StrictMode::StrictModeState sms = (outerpc->sc->strictModeState == StrictMode::STRICT) ?
104093:         StrictMode::STRICT : StrictMode::UNKNOWN;
104093: 
104093:     // Create box for fun->object early to protect against last-ditch GC.
109500:     FunctionBox *funbox = newFunctionBox(fun, outerpc, sms);
100230:     if (!funbox)
100230:         return NULL;
100230: 
 40239:     /* Initialize early for possible flags mutation via destructuringExpr. */
104093:     SharedContext funsc(context, /* scopeChain = */ NULL, fun, funbox, sms);
108876:     ParseContext funpc(this, &funsc, outerpc->staticLevel + 1, outerpc->blockidGen);
108876:     if (!funpc.init())
104045:         return NULL;
104045: 
     1:     /* Now parse formal argument list and compute fun->nargs. */
 80631:     ParseNode *prelude = NULL;
100154:     bool hasRest;
109500:     if (!functionArguments(&prelude, pn, hasRest))
 59968:         return NULL;
 59968: 
108876:     fun->setArgCount(funpc.numArgs());
100154:     if (funbox->ndefaults)
 99552:         fun->setHasDefaults();
 99225:     if (hasRest)
 99225:         fun->setHasRest();
 59952: 
 72581:     if (type == Getter && fun->nargs > 0) {
102849:         reportError(NULL, JSMSG_ACCESSOR_WRONG_ARGS, "getter", "no", "s");
 51089:         return NULL;
 51089:     }
 72581:     if (type == Setter && fun->nargs != 1) {
102849:         reportError(NULL, JSMSG_ACCESSOR_WRONG_ARGS, "setter", "one", "");
 51089:         return NULL;
 51089:     }
 51089: 
 82875:     FunctionBodyType bodyType = StatementListBody;
  1967: #if JS_HAS_EXPR_CLOSURES
 82875:     if (tokenStream.getToken(TSF_OPERAND) != TOK_LC) {
 40354:         tokenStream.ungetToken();
  1967:         fun->flags |= JSFUN_EXPR_CLOSURE;
 82875:         bodyType = ExpressionBody;
  1967:     }
  1967: #else
     1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_BODY);
  1967: #endif
     1: 
 82875:     ParseNode *body = functionBody(bodyType);
     1:     if (!body)
     1:         return NULL;
     1: 
 98181:     if (funName && !CheckStrictBinding(context, this, funName, pn))
 62048:         return NULL;
 62048: 
  1967: #if JS_HAS_EXPR_CLOSURES
105944:     if (bodyType == StatementListBody) {
105944: #endif
     1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
105944:         funbox->bufEnd = tokenStream.offsetOfToken(tokenStream.currentToken()) + 1;
105944: #if JS_HAS_EXPR_CLOSURES
105944:     } else {
106996:         // We shouldn't call endOffset if the tokenizer got an error.
106996:         if (tokenStream.hadError())
106996:             return NULL;
105944:         funbox->bufEnd = tokenStream.endOffset(tokenStream.currentToken());
105944:         if (kind == Statement && !MatchOrInsertSemicolon(context, &tokenStream))
105944:             return NULL;
105944:     }
  1967: #endif
 40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
     1: 
 51097:     /*
 95099:      * Fruit of the poisonous tree: if a closure contains a dynamic name access
104045:      * (eval, with, etc), we consider the parent to do the same. The reason is
 95099:      * that the deoptimizing effects of dynamic name access apply equally to
 95099:      * parents: any local can be read at runtime.
 95099:      */
 98445:     if (funsc.bindingsAccessedDynamically())
108876:         outerpc->sc->setBindingsAccessedDynamically();
 51097: 
     1: #if JS_HAS_DESTRUCTURING
     1:     /*
     1:      * If there were destructuring formal parameters, prepend the initializing
 51110:      * comma expression that we synthesized to body. If the body is a return
 82024:      * node, we must make a special PNK_SEQ node, to prepend the destructuring
 51110:      * code without bracing the decompilation of the function body.
     1:      */
 59952:     if (prelude) {
 78294:         if (!body->isArity(PN_LIST)) {
 80631:             ParseNode *block;
     1: 
 98181:             block = ListNode::create(PNK_SEQ, this);
     1:             if (!block)
     1:                 return NULL;
     1:             block->pn_pos = body->pn_pos;
 27012:             block->initList(body);
     1: 
     1:             body = block;
     1:         }
     1: 
 98181:         ParseNode *item = UnaryNode::create(PNK_SEMI, this);
     1:         if (!item)
     1:             return NULL;
     1: 
     1:         item->pn_pos.begin = item->pn_pos.end = body->pn_pos.begin;
 59952:         item->pn_kid = prelude;
     1:         item->pn_next = body->pn_head;
     1:         body->pn_head = item;
     1:         if (body->pn_tail == &body->pn_head)
     1:             body->pn_tail = &item->pn_next;
     1:         ++body->pn_count;
 27012:         body->pn_xflags |= PNX_DESTRUCT;
     1:     }
     1: #endif
     1: 
     1:     /*
108505:      * If any nested function scope does a dynamic scope access, all enclosing
108505:      * scopes may be accessed dynamically.
     1:      */
108505:     if (funsc.bindingsAccessedDynamically())
108876:         outerpc->sc->setBindingsAccessedDynamically();
     1: 
104045: 
 27012:     pn->pn_funbox = funbox;
 27012:     pn->pn_body->append(body);
 28816:     pn->pn_body->pn_pos = body->pn_pos;
108876:     pn->pn_blockid = outerpc->blockid();
 40263: 
 98181:     if (!LeaveFunction(pn, this, funName, kind))
 27012:         return NULL;
 27012: 
 72567:     return pn;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::functionStmt()
 40263: {
105944:     JS_ASSERT(tokenStream.currentToken().type == TOK_FUNCTION);
 99421:     RootedPropertyName name(context);
 51087:     if (tokenStream.getToken(TSF_KEYWORD_IS_NAME) == TOK_NAME) {
 80443:         name = tokenStream.currentToken().name();
 51087:     } else {
 72567:         /* Unnamed function expressions are forbidden in statement context. */
102849:         reportError(NULL, JSMSG_UNNAMED_FUNCTION_STMT);
 72567:         return NULL;
 51087:     }
 60253: 
 60253:     /* We forbid function statements in strict mode code. */
108876:     if (!pc->atBodyLevel() && pc->sc->needStrictChecks() &&
104093:         !reportStrictModeError(NULL, JSMSG_STRICT_FUNCTION_STATEMENT))
104093:         return NULL;
 60253: 
 72581:     return functionDef(name, Normal, Statement);
 40239: }
 40239: 
 80631: ParseNode *
 40860: Parser::functionExpr()
 40263: {
 99421:     RootedPropertyName name(context);
105944:     JS_ASSERT(tokenStream.currentToken().type == TOK_FUNCTION);
 51087:     if (tokenStream.getToken(TSF_KEYWORD_IS_NAME) == TOK_NAME)
 80443:         name = tokenStream.currentToken().name();
 51087:     else
 51087:         tokenStream.ungetToken();
 72581:     return functionDef(name, Normal, Expression);
     1: }
     1: 
104093: void
104093: FunctionBox::recursivelySetStrictMode(StrictMode::StrictModeState strictness)
104093: {
104093:     if (strictModeState == StrictMode::UNKNOWN) {
104093:         strictModeState = strictness;
104093:         for (FunctionBox *kid = kids; kid; kid = kid->siblings)
104093:             kid->recursivelySetStrictMode(strictness);
104093:     }
104093: }
104093: 
104093: /*
104093:  * Indicate that the current scope can't switch to strict mode with a body-level
104093:  * "use strict" directive anymore. Return false on error.
104093:  */
104093: bool
104093: Parser::setStrictMode(bool strictMode)
104093: {
108876:     if (pc->sc->strictModeState != StrictMode::UNKNOWN) {
104093:         // Strict mode was inherited.
108876:         JS_ASSERT(pc->sc->strictModeState == StrictMode::STRICT);
108876:         if (pc->sc->inFunction() && pc->sc->funbox()) {
108876:             JS_ASSERT(pc->sc->funbox()->strictModeState == pc->sc->strictModeState);
108876:             JS_ASSERT(pc->parent->sc->strictModeState == StrictMode::STRICT);
104093:         } else {
108876:             JS_ASSERT(StrictModeFromContext(context) == StrictMode::STRICT || pc->staticLevel);
104093:         }
104093:         return true;
104093:     }
104093:     if (strictMode) {
108876:         if (pc->queuedStrictModeError) {
104093:             // There was a strict mode error in this scope before we knew it was
104093:             // strict. Throw it.
108876:             JS_ASSERT(!(pc->queuedStrictModeError->report.flags & JSREPORT_WARNING));
108876:             pc->queuedStrictModeError->throwError();
104093:             return false;
104093:         }
108876:         pc->sc->strictModeState = StrictMode::STRICT;
108876:     } else if (!pc->parent || pc->parent->sc->strictModeState == StrictMode::NOTSTRICT) {
104093:         // This scope will not be strict.
108876:         pc->sc->strictModeState = StrictMode::NOTSTRICT;
108876:         if (pc->queuedStrictModeError && context->hasStrictOption() &&
108876:             pc->queuedStrictModeError->report.errorNumber != JSMSG_STRICT_CODE_WITH) {
104093:             // Convert queued strict mode error to a warning.
108876:             pc->queuedStrictModeError->report.flags |= JSREPORT_WARNING;
108876:             pc->queuedStrictModeError->throwError();
108876:         }
108876:     }
108876:     JS_ASSERT_IF(!pc->sc->inFunction(), !pc->functionList);
108876:     if (pc->sc->strictModeState != StrictMode::UNKNOWN && pc->sc->inFunction()) {
104093:         // We changed the strict mode state. Retroactively recursively set
104093:         // strict mode status on all the function children we've seen so far
104093:         // children (That is, functions in default expressions).
108876:         if (pc->sc->funbox())
108876:             pc->sc->funbox()->strictModeState = pc->sc->strictModeState;
108876:         for (FunctionBox *kid = pc->functionList; kid; kid = kid->siblings)
108876:             kid->recursivelySetStrictMode(pc->sc->strictModeState);
104093:     }
104093:     return true;
104093: }
104093: 
104093: /*
104093:  * Return true if this token, known to be an unparenthesized string literal,
104093:  * could be the string of a directive in a Directive Prologue. Directive
104093:  * strings never contain escape sequences or line continuations.
104093:  */
104093: static bool
104093: IsEscapeFreeStringLiteral(const Token &tok)
104093: {
104093:     /*
104093:      * If the string's length in the source code is its length as a value,
104093:      * accounting for the quotes, then it must not contain any escape
104093:      * sequences or line continuations.
104093:      */
104093:     return (tok.pos.begin.lineno == tok.pos.end.lineno &&
104093:             tok.pos.begin.index + tok.atom()->length() + 2 == tok.pos.end.index);
104093: }
104093: 
     1: /*
 60792:  * Recognize Directive Prologue members and directives. Assuming |pn| is a
 60792:  * candidate for membership in a directive prologue, recognize directives and
108876:  * set |pc|'s flags accordingly. If |pn| is indeed part of a prologue, set its
 60792:  * |pn_prologue| flag.
 35113:  *
 35113:  * Note that the following is a strict mode function:
 35113:  *
 35113:  * function foo() {
 35113:  *   "blah" // inserted semi colon
 35113:  *        "blurgh"
 35113:  *   "use\x20loose"
 35113:  *   "use strict"
 35113:  * }
 35113:  *
 60792:  * That is, even though "use\x20loose" can never be a directive, now or in the
 60792:  * future (because of the hex escape), the Directive Prologue extends through it
 60792:  * to the "use strict" statement, which is indeed a directive.
 35113:  */
 40239: bool
104093: Parser::processDirectives(ParseNode *stmts)
104093: {
104093:     bool gotStrictMode = false;
104093:     for (TokenKind tt = tokenStream.getToken(TSF_OPERAND); tt == TOK_STRING; tt = tokenStream.getToken(TSF_OPERAND)) {
104093:         ParseNode *stringNode = atomNode(PNK_STRING, JSOP_STRING);
104093:         if (!stringNode)
 59219:             return false;
104093:         const Token directive = tokenStream.currentToken();
104093:         bool isDirective = IsEscapeFreeStringLiteral(directive);
104093:         JSAtom *atom = directive.atom();
104338:         TokenKind next = tokenStream.peekTokenSameLine();
104093:         if (next != TOK_EOF && next != TOK_EOL && next != TOK_SEMI && next != TOK_RC) {
104093:             freeTree(stringNode);
104093:             if (next == TOK_ERROR)
104093:                 return false;
104093:             break;
104093:         }
104093:         tokenStream.matchToken(TOK_SEMI);
104093:         if (isDirective) {
104093:             // It's a directive. Is it one we know?
104093:             if (atom == context->runtime->atomState.useStrictAtom && !gotStrictMode) {
108876:                 pc->sc->setExplicitUseStrict();
104093:                 if (!setStrictMode(true))
104093:                     return false;
104093:                 gotStrictMode = true;
104093:             }
104093:         }
104093:         ParseNode *stmt = UnaryNode::create(PNK_SEMI, this);
104093:         if (!stmt) {
104093:             freeTree(stringNode);
104093:             return false;
104093:         }
104093:         stmt->pn_pos = stringNode->pn_pos;
104093:         stmt->pn_kid = stringNode;
104093:         stmt->pn_prologue = isDirective;
104093:         stmts->append(stmt);
104093:     }
104093:     tokenStream.ungetToken();
104093:     if (!gotStrictMode && !setStrictMode(false))
104093:         return false;
 35113:     return true;
 35113: }
 35113: 
 35113: /*
     1:  * Parse the statements in a block, creating a TOK_LC node that lists the
     1:  * statements' trees.  If called from block-parsing code, the caller must
     1:  * match { before and } after.
     1:  */
 80631: ParseNode *
 98452: Parser::statements(bool *hasFunctionStmt)
     1: {
 40239:     JS_CHECK_RECURSION(context, return NULL);
 98452:     if (hasFunctionStmt)
 98452:         *hasFunctionStmt = false;
 40221: 
 98181:     ParseNode *pn = ListNode::create(PNK_STATEMENTLIST, this);
     1:     if (!pn)
     1:         return NULL;
 27012:     pn->makeEmpty();
108876:     pn->pn_blockid = pc->blockid();
108876:     ParseNode *saveBlock = pc->blockNode;
108876:     pc->blockNode = pn;
108876: 
108876:     if (pc->atBodyLevel() && !processDirectives(pn))
104093:         return NULL;
  9604:     for (;;) {
 82875:         TokenKind tt = tokenStream.peekToken(TSF_OPERAND);
 10466:         if (tt <= TOK_EOF || tt == TOK_RC) {
 24241:             if (tt == TOK_ERROR) {
 40854:                 if (tokenStream.isEOF())
 40854:                     tokenStream.setUnexpectedEOF();
 40239:                 return NULL;
 40239:             }
 40239:             break;
 40239:         }
 82875:         ParseNode *next = statement();
 82875:         if (!next) {
 40854:             if (tokenStream.isEOF())
 40854:                 tokenStream.setUnexpectedEOF();
     1:             return NULL;
     1:         }
     1: 
 82875:         if (next->isKind(PNK_FUNCTION)) {
 10466:             /*
 59229:              * PNX_FUNCDEFS notifies the emitter that the block contains body-
 10466:              * level function definitions that should be processed before the
 10466:              * rest of nodes.
 10466:              *
 98452:              * |hasFunctionStmt| is for the TOK_LC case in Statement. It
 59229:              * is relevant only for function definitions not at body-level,
 10466:              * which we call function statements.
 10466:              */
108876:             if (pc->atBodyLevel()) {
 27012:                 pn->pn_xflags |= PNX_FUNCDEFS;
 74286:             } else {
 94150:                 /*
 94150:                  * General deoptimization was done in functionDef, here we just
 94150:                  * need to tell TOK_LC in Parser::statement to add braces.
 94150:                  */
108876:                 JS_ASSERT(pc->sc->funHasExtensibleScope());
 98452:                 if (hasFunctionStmt)
 98452:                     *hasFunctionStmt = true;
 64296:             }
 10466:         }
 82875:         pn->append(next);
     1:     }
     1: 
     1:     /*
     1:      * Handle the case where there was a let declaration under this block.  If
108876:      * it replaced pc->blockNode with a new block node then we must refresh pn
108876:      * and then restore pc->blockNode.
108876:      */
108876:     if (pc->blockNode != pn)
108876:         pn = pc->blockNode;
108876:     pc->blockNode = saveBlock;
     1: 
 40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
 89621:     JS_ASSERT(pn->pn_pos.begin <= pn->pn_pos.end);
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::condition()
     1: {
     1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_COND);
 84700:     ParseNode *pn = parenExpr();
     1:     if (!pn)
     1:         return NULL;
     1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_COND);
     1: 
 31479:     /* Check for (a = b) and warn about possible (a == b) mistype. */
 82024:     JS_ASSERT_IF(pn->isKind(PNK_ASSIGN), pn->isOp(JSOP_NOP));
 82024:     if (pn->isKind(PNK_ASSIGN) &&
 78294:         !pn->isInParens() &&
102849:         !reportStrictWarning(NULL, JSMSG_EQUAL_AS_ASSIGN))
 82023:     {
     1:         return NULL;
     1:     }
     1:     return pn;
     1: }
     1: 
 80443: static bool
 84666: MatchLabel(JSContext *cx, TokenStream *ts, PropertyName **label)
     1: {
 80443:     TokenKind tt = ts->peekTokenSameLine(TSF_OPERAND);
     1:     if (tt == TOK_ERROR)
 80443:         return false;
     1:     if (tt == TOK_NAME) {
 40354:         (void) ts->getToken();
 84666:         *label = ts->currentToken().name();
     1:     } else {
 84666:         *label = NULL;
 84666:     }
 80443:     return true;
     1: }
     1: 
 86078: static bool
 98181: ReportRedeclaration(JSContext *cx, Parser *parser, ParseNode *pn, bool isConst, JSAtom *atom)
 86078: {
 86078:     JSAutoByteString name;
102849:     if (js_AtomToPrintableString(cx, atom, &name))
102849:         parser->reportError(pn, JSMSG_REDECLARED_VAR, isConst ? "const" : "variable", name.ptr());
 86078:     return false;
 86078: }
 86078: 
 74052: /*
108876:  * Define a let-variable in a block, let-expression, or comprehension scope. pc
 74052:  * must already be in such a scope.
 74052:  *
 74052:  * Throw a SyntaxError if 'atom' is an invalid name. Otherwise create a
108876:  * property for the new variable on the block object, pc->blockChain;
 74052:  * populate data->pn->pn_{op,cookie,defn,dflags}; and stash a pointer to
 74052:  * data->pn in a slot of the block object.
 74052:  */
103824: static bool
108174: BindLet(JSContext *cx, BindData *data, HandlePropertyName name, Parser *parser)
 98181: {
108876:     ParseContext *pc = parser->pc;
 86078:     ParseNode *pn = data->pn;
108174:     if (!CheckStrictBinding(cx, parser, name, pn))
 35325:         return false;
 35325: 
 99421:     Rooted<StaticBlockObject *> blockObj(cx, data->let.blockObj);
 95355:     unsigned blockCount = blockObj->slotCount();
 86078:     if (blockCount == JS_BIT(16)) {
102849:         parser->reportError(pn, data->let.overflow);
 47497:         return false;
     1:     }
     1: 
 27012:     /*
 27012:      * Assign block-local index to pn->pn_cookie right away, encoding it as an
 27012:      * upvar cookie whose skip tells the current static level. The emitter will
 27012:      * adjust the node's slot based on its stack depth model -- and, for global
 80991:      * and eval code, js::frontend::CompileScript will adjust the slot
 80634:      * again to include script->nfixed.
 27012:      */
108876:     if (!pn->pn_cookie.set(parser->context, pc->staticLevel, uint16_t(blockCount)))
101616:         return false;
108505: 
108505:     /*
108505:      * For bindings that are hoisted to the beginning of the block/function,
108505:      * define() right now. Otherwise, delay define until PushLetScope.
108505:      */
108505:     if (data->let.varContext == HoistVars) {
108876:         JS_ASSERT(!pc->atBodyLevel());
108876:         Definition *dn = pc->decls().lookupFirst(name);
108876:         if (dn && dn->pn_blockid == pc->blockid())
108505:             return ReportRedeclaration(cx, parser, pn, dn->isConst(), name);
108876:         if (!pc->define(cx, name, pn, Definition::LET))
108505:             return false;
108505:     }
 27012: 
 27012:     /*
 53650:      * Define the let binding's property before storing pn in the the binding's
 86078:      * slot indexed by blockCount off the class-reserved slot base.
 86078:      */
 86078:     bool redeclared;
108174:     RootedId id(cx, NameToId(name));
104205:     Shape *shape = StaticBlockObject::addVar(cx, blockObj, id, blockCount, &redeclared);
 86078:     if (!shape) {
 86078:         if (redeclared)
108174:             ReportRedeclaration(cx, parser, pn, false, name);
 47497:         return false;
 86078:     }
 86078: 
 86483:     /* Store pn in the static block object. */
 95355:     blockObj->setDefinitionParseNode(blockCount, reinterpret_cast<Definition *>(pn));
 47497:     return true;
 27012: }
 27012: 
 86078: template <class Op>
 86078: static inline bool
108876: ForEachLetDef(JSContext *cx, ParseContext *pc, StaticBlockObject &blockObj, Op op)
 86483: {
 86483:     for (Shape::Range r = blockObj.lastProperty()->all(); !r.empty(); r.popFront()) {
103639:         Shape &shape = r.front();
 86078: 
 86078:         /* Beware the destructuring dummy slots. */
 86078:         if (JSID_IS_INT(shape.propid()))
 86078:             continue;
 86078: 
108876:         if (!op(cx, pc, blockObj, shape, JSID_TO_ATOM(shape.propid())))
 86078:             return false;
 86078:     }
 86078:     return true;
 86078: }
 86078: 
108505: struct PopLetDecl {
108876:     bool operator()(JSContext *, ParseContext *pc, StaticBlockObject &, const Shape &, JSAtom *atom) {
108876:         pc->popLetDecl(atom);
 86078:         return true;
 86078:     }
 86078: };
 86078: 
 27012: static void
108876: PopStatementPC(JSContext *cx, ParseContext *pc)
108876: {
108876:     StaticBlockObject *blockObj = pc->topStmt->blockObj;
108876:     JS_ASSERT(!!blockObj == (pc->topStmt->isBlockScope));
108876: 
108876:     FinishPopStatement(pc);
104378: 
104378:     if (blockObj) {
104378:         JS_ASSERT(!blockObj->inDictionaryMode());
108876:         ForEachLetDef(cx, pc, *blockObj, PopLetDecl());
104378:         blockObj->resetPrevBlockChainFromParser();
104378:     }
     1: }
     1: 
 27112: static inline bool
108876: OuterLet(ParseContext *pc, StmtInfoPC *stmt, HandleAtom atom)
 27112: {
 27112:     while (stmt->downScope) {
108876:         stmt = LexicalLookup(pc, atom, NULL, stmt->downScope);
 27112:         if (!stmt)
 27112:             return false;
 27112:         if (stmt->type == STMT_BLOCK)
 27112:             return true;
 27112:     }
 27112:     return false;
 27112: }
 27112: 
 60145: static bool
108174: BindVarOrConst(JSContext *cx, BindData *data, HandlePropertyName name, Parser *parser)
108174: {
108876:     ParseContext *pc = parser->pc;
 80631:     ParseNode *pn = data->pn;
108505:     bool isConstDecl = data->op == JSOP_DEFCONST;
 35325: 
 41817:     /* Default best op for pn is JSOP_NAME; we'll try to improve below. */
 78294:     pn->setOp(JSOP_NAME);
 41817: 
108174:     if (!CheckStrictBinding(cx, parser, name, pn))
 35325:         return false;
 35325: 
108876:     StmtInfoPC *stmt = LexicalLookup(pc, name, NULL, (StmtInfoPC *)NULL);
 64237: 
 64237:     if (stmt && stmt->type == STMT_WITH) {
 54755:         pn->pn_dflags |= PND_DEOPTIMIZED;
108876:         pc->sc->setFunMightAliasLocals();
 52825:         return true;
 27012:     }
 27012: 
108876:     DefinitionList::Range defs = pc->decls().lookupMulti(name);
105538:     JS_ASSERT_IF(stmt, !defs.empty());
106175: 
108505:     if (defs.empty())
108876:         return pc->define(cx, name, pn, isConstDecl ? Definition::CONST : Definition::VAR);
106503: 
106503:     /*
106503:      * There was a previous declaration with the same name. The standard
106503:      * disallows several forms of redeclaration. Critically,
106503:      *   let (x) { var x; } // error
106503:      * is not allowed which allows us to turn any non-error redeclaration
106503:      * into a use of the initial declaration.
106503:      */
105538:     Definition *dn = defs.front();
105538:     Definition::Kind dn_kind = dn->kind();
 80631:     if (dn_kind == Definition::ARG) {
108174:         JSAutoByteString bytes;
108174:         if (!js_AtomToPrintableString(cx, name, &bytes))
103823:             return false;
  8179: 
108505:         if (isConstDecl) {
108174:             parser->reportError(pn, JSMSG_REDECLARED_PARAM, bytes.ptr());
103823:             return false;
  8179:         }
108174:         if (!parser->reportStrictWarning(pn, JSMSG_VAR_HIDES_ARG, bytes.ptr()))
103823:             return false;
  8179:     } else {
108505:         bool error = (isConstDecl ||
 80631:                       dn_kind == Definition::CONST ||
 80631:                       (dn_kind == Definition::LET &&
108876:                        (stmt->type != STMT_CATCH || OuterLet(pc, stmt, name))));
 28167: 
 61450:         if (cx->hasStrictOption()
106175:             ? data->op != JSOP_DEFVAR || dn_kind != Definition::VAR
102849:             : error)
102849:         {
108174:             JSAutoByteString bytes;
102849:             Parser::Reporter reporter =
102849:                 error ? &Parser::reportError : &Parser::reportStrictWarning;
108174:             if (!js_AtomToPrintableString(cx, name, &bytes) ||
102849:                 !(parser->*reporter)(pn, JSMSG_REDECLARED_VAR,
108174:                                      Definition::kindString(dn_kind), bytes.ptr()))
102849:             {
103823:                 return false;
 27012:             }
 27012:         }
 27012:     }
106175: 
106503:     LinkUseToDef(pn, dn);
 98173:     return true;
     1: }
     1: 
 57742: static bool
 98181: MakeSetCall(JSContext *cx, ParseNode *pn, Parser *parser, unsigned msg)
 20908: {
 78294:     JS_ASSERT(pn->isArity(PN_LIST));
 78294:     JS_ASSERT(pn->isOp(JSOP_CALL) || pn->isOp(JSOP_EVAL) ||
 78294:               pn->isOp(JSOP_FUNCALL) || pn->isOp(JSOP_FUNAPPLY));
102849:     if (!parser->reportStrictModeError(pn, msg))
 57742:         return false;
 57742: 
 80631:     ParseNode *pn2 = pn->pn_head;
 98481:     if (pn2->isKind(PNK_FUNCTION) && (pn2->pn_funbox->inGenexpLambda)) {
102849:         parser->reportError(pn, msg);
 57742:         return false;
 57742:     }
 57742:     pn->pn_xflags |= PNX_SETCALL;
 57742:     return true;
 20908: }
 20908: 
 27012: static void
106176: NoteLValue(JSContext *cx, ParseNode *pn, SharedContext *sc)
106176: {
106176:     if (pn->isUsed())
106176:         pn->pn_lexdef->pn_dflags |= PND_ASSIGNED;
106176: 
106176:     pn->pn_dflags |= PND_ASSIGNED;
 59940: }
 27012: 
 97594: static bool
 98181: NoteNameUse(ParseNode *pn, Parser *parser)
 97594: {
104205:     RootedPropertyName name(parser->context, pn->pn_atom->asPropertyName());
108876:     StmtInfoPC *stmt = LexicalLookup(parser->pc, name, NULL, (StmtInfoPC *)NULL);
108876: 
108876:     DefinitionList::Range defs = parser->pc->decls().lookupMulti(name);
 97594: 
 97594:     Definition *dn;
103859:     if (!defs.empty()) {
103859:         dn = defs.front();
 97594:     } else {
108876:         if (AtomDefnAddPtr p = parser->pc->lexdeps->lookupForAdd(name)) {
 97594:             dn = p.value();
 97594:         } else {
 97594:             /*
 97594:              * No definition before this use in any lexical scope.
 97594:              * Create a placeholder definition node to either:
 97594:              * - Be adopted when we parse the real defining
 97594:              *   declaration, or
 97594:              * - Be left as a free variable definition if we never
 97594:              *   see the real definition.
 97594:              */
108876:             dn = MakePlaceholder(pn, parser, parser->pc);
108876:             if (!dn || !parser->pc->lexdeps->add(p, name, dn))
 97594:                 return false;
 97594:         }
 97594:     }
 97594: 
 97594:     JS_ASSERT(dn->isDefn());
 98181:     LinkUseToDef(pn, dn);
 97594: 
 97594:     if (stmt && stmt->type == STMT_WITH)
 97594:         pn->pn_dflags |= PND_DEOPTIMIZED;
 97594: 
 97594:     return true;
 97594: }
 97594: 
     1: #if JS_HAS_DESTRUCTURING
     1: 
103824: static bool
 98181: BindDestructuringVar(JSContext *cx, BindData *data, ParseNode *pn, Parser *parser)
     1: {
 82024:     JS_ASSERT(pn->isKind(PNK_NAME));
     1: 
108174:     RootedPropertyName name(cx, pn->pn_atom->asPropertyName());
108174: 
     1:     data->pn = pn;
108174:     if (!data->binder(cx, data, name, parser))
103823:         return false;
 27012: 
 27012:     /*
 27012:      * Select the appropriate name-setting opcode, respecting eager selection
 27012:      * done by the data->binder function.
 27012:      */
 98173:     if (pn->pn_dflags & PND_BOUND)
 95100:         pn->setOp(JSOP_SETLOCAL);
 98173:     else if (data->op == JSOP_DEFCONST)
 98173:         pn->setOp(JSOP_SETCONST);
 98173:     else
 98173:         pn->setOp(JSOP_SETNAME);
 27012: 
 27012:     if (data->op == JSOP_DEFCONST)
 27012:         pn->pn_dflags |= PND_CONST;
 27012: 
108876:     NoteLValue(cx, pn, parser->pc->sc);
103823:     return true;
     1: }
     1: 
     1: /*
     1:  * Here, we are destructuring {... P: Q, ...} = R, where P is any id, Q is any
     1:  * LHS expression except a destructuring initialiser, and R is on the stack.
     1:  * Because R is already evaluated, the usual LHS-specialized bytecodes won't
     1:  * work.  After pushing R[P] we need to evaluate Q's "reference base" QB and
     1:  * then push its property name QN.  At this point the stack looks like
     1:  *
     1:  *   [... R, R[P], QB, QN]
     1:  *
     1:  * We need to set QB[QN] = R[P].  This is a job for JSOP_ENUMELEM, which takes
     1:  * its operands with left-hand side above right-hand side:
     1:  *
     1:  *   [rval, lval, xval]
     1:  *
     1:  * and pops all three values, setting lval[xval] = rval.  But we cannot select
     1:  * JSOP_ENUMELEM yet, because the LHS may turn out to be an arg or local var,
     1:  * which can be optimized further.  So we select JSOP_SETNAME.
     1:  */
103824: static bool
 98181: BindDestructuringLHS(JSContext *cx, ParseNode *pn, Parser *parser)
     1: {
 78294:     switch (pn->getKind()) {
 82024:       case PNK_NAME:
108876:         NoteLValue(cx, pn, parser->pc->sc);
     1:         /* FALL THROUGH */
 27012: 
 82024:       case PNK_DOT:
 82024:       case PNK_LB:
 42747:         /*
 42747:          * We may be called on a name node that has already been specialized,
 42747:          * in the very weird and ECMA-262-required "for (var [x] = i in o) ..."
 42747:          * case. See bug 558633.
 42747:          */
 78294:         if (!(js_CodeSpec[pn->getOp()].format & JOF_SET))
 78294:             pn->setOp(JSOP_SETNAME);
     1:         break;
     1: 
 82024:       case PNK_LP:
 98181:         if (!MakeSetCall(cx, pn, parser, JSMSG_BAD_LEFTSIDE_OF_ASS))
103823:             return false;
     1:         break;
     1: 
     1: #if JS_HAS_XML_SUPPORT
 82114:       case PNK_XMLUNARY:
 82018:         JS_ASSERT(pn->isOp(JSOP_XMLNAME));
 78294:         pn->setOp(JSOP_BINDXMLNAME);
     1:         break;
     1: #endif
     1: 
     1:       default:
102849:         parser->reportError(pn, JSMSG_BAD_LEFTSIDE_OF_ASS);
103823:         return false;
103823:     }
103823: 
103823:     return true;
     1: }
     1: 
     1: /*
 33753:  * Destructuring patterns can appear in two kinds of contexts:
 28995:  *
 33753:  * - assignment-like: assignment expressions and |for| loop heads.  In
 33753:  *   these cases, the patterns' property value positions can be
 33753:  *   arbitrary lvalue expressions; the destructuring is just a fancy
 33753:  *   assignment.
 33753:  *
 33753:  * - declaration-like: |var| and |let| declarations, functions' formal
 33753:  *   parameter lists, |catch| clauses, and comprehension tails.  In
 33753:  *   these cases, the patterns' property value positions must be
 33753:  *   simple names; the destructuring defines them as new variables.
 33753:  *
 33753:  * In both cases, other code parses the pattern as an arbitrary
 40239:  * primaryExpr, and then, here in CheckDestructuring, verify that the
 33753:  * tree is a valid destructuring expression.
 33753:  *
 98453:  * In assignment-like contexts, we parse the pattern with
108876:  * pc->inDeclDestructuring clear, so the lvalue expressions in the
 40239:  * pattern are parsed normally.  primaryExpr links variable references
 33753:  * into the appropriate use chains; creates placeholder definitions;
 33753:  * and so on.  CheckDestructuring is called with |data| NULL (since we
 33753:  * won't be binding any new names), and we specialize lvalues as
 68922:  * appropriate.
 33753:  *
 33753:  * In declaration-like contexts, the normal variable reference
 33753:  * processing would just be an obstruction, because we're going to
 33753:  * define the names that appear in the property value positions as new
 33753:  * variables anyway.  In this case, we parse the pattern with
108876:  * pc->inDeclDestructuring set, which directs primaryExpr to leave
 33753:  * whatever name nodes it creates unconnected.  Then, here in
 33753:  * CheckDestructuring, we require the pattern's property value
 33753:  * positions to be simple names, and define them as appropriate to the
 33753:  * context.  For these calls, |data| points to the right sort of
 33753:  * BindData.
 33753:  *
 86078:  * The 'toplevel' is a private detail of the recursive strategy used by
 86078:  * CheckDestructuring and callers should use the default value.
     1:  */
 68922: static bool
 98181: CheckDestructuring(JSContext *cx, BindData *data, ParseNode *left, Parser *parser,
 86078:                    bool toplevel = true)
 68922: {
 68922:     bool ok;
     1: 
 82024:     if (left->isKind(PNK_ARRAYCOMP)) {
102849:         parser->reportError(left, JSMSG_ARRAY_COMP_LEFTSIDE);
 68922:         return false;
 68922:     }
 68922: 
 99421:     Rooted<StaticBlockObject *> blockObj(cx);
103637:     blockObj = data && data->binder == BindLet ? data->let.blockObj.get() : NULL;
 86483:     uint32_t blockCountBefore = blockObj ? blockObj->slotCount() : 0;
 86078: 
 82024:     if (left->isKind(PNK_RB)) {
 80631:         for (ParseNode *pn = left->pn_head; pn; pn = pn->pn_next) {
     1:             /* Nullary comma is an elision; binary comma is an expression.*/
 86078:             if (!pn->isArrayHole()) {
 82024:                 if (pn->isKind(PNK_RB) || pn->isKind(PNK_RC)) {
 98181:                     ok = CheckDestructuring(cx, data, pn, parser, false);
     1:                 } else {
     1:                     if (data) {
 82024:                         if (!pn->isKind(PNK_NAME)) {
102849:                             parser->reportError(pn, JSMSG_NO_VARIABLE_NAME);
 68922:                             return false;
 68922:                         }
 98181:                         ok = BindDestructuringVar(cx, data, pn, parser);
     1:                     } else {
 98181:                         ok = BindDestructuringLHS(cx, pn, parser);
     1:                     }
     1:                 }
     1:                 if (!ok)
 68922:                     return false;
 68922:             }
     1:         }
     1:     } else {
 82024:         JS_ASSERT(left->isKind(PNK_RC));
 80631:         for (ParseNode *pair = left->pn_head; pair; pair = pair->pn_next) {
 82024:             JS_ASSERT(pair->isKind(PNK_COLON));
 80631:             ParseNode *pn = pair->pn_right;
     1: 
 82024:             if (pn->isKind(PNK_RB) || pn->isKind(PNK_RC)) {
 98181:                 ok = CheckDestructuring(cx, data, pn, parser, false);
     1:             } else if (data) {
 82024:                 if (!pn->isKind(PNK_NAME)) {
102849:                     parser->reportError(pn, JSMSG_NO_VARIABLE_NAME);
 68922:                     return false;
 68922:                 }
 98181:                 ok = BindDestructuringVar(cx, data, pn, parser);
     1:             } else {
 97594:                 /*
 97594:                  * If right and left point to the same node, then this is
 97594:                  * destructuring shorthand ({x} = ...). In that case,
 97594:                  * identifierName was not used to parse 'x' so 'x' has not been
 97594:                  * officially linked to its def or registered in lexdeps. Do
 97594:                  * that now.
 97594:                  */
 98181:                 if (pair->pn_right == pair->pn_left && !NoteNameUse(pn, parser))
 97594:                     return false;
 98181:                 ok = BindDestructuringLHS(cx, pn, parser);
     1:             }
     1:             if (!ok)
 68922:                 return false;
     1:         }
     1:     }
     1: 
 14688:     /*
 14688:      * The catch/finally handler implementation in the interpreter assumes
 14688:      * that any operation that introduces a new scope (like a "let" or "with"
 14688:      * block) increases the stack depth. This way, it is possible to restore
 14688:      * the scope chain based on stack depth of the handler alone. "let" with
 14688:      * an empty destructuring pattern like in
 14688:      *
 14688:      *   let [] = 1;
 14688:      *
 14688:      * would violate this assumption as the there would be no let locals to
 86078:      * store on the stack.
 14688:      *
 86078:      * Furthermore, the decompiler needs an abstract stack location to store
 86078:      * the decompilation of each let block/expr initializer. E.g., given:
 86078:      *
 86078:      *   let (x = 1, [[]] = b, y = 3, {a:[]} = c) { ... }
 86078:      *
 86078:      * four slots are needed.
 86078:      *
 86078:      * To satisfy both constraints, we push a dummy slot (and add a
 86078:      * corresponding dummy property to the block object) for each initializer
 86078:      * that doesn't introduce at least one binding.
 86078:      */
 86483:     if (toplevel && blockObj && blockCountBefore == blockObj->slotCount()) {
 86534:         bool redeclared;
104205:         RootedId id(cx, INT_TO_JSID(blockCountBefore));
104205:         if (!StaticBlockObject::addVar(cx, blockObj, id, blockCountBefore, &redeclared))
 68922:             return false;
 86534:         JS_ASSERT(!redeclared);
 86483:         JS_ASSERT(blockObj->slotCount() == blockCountBefore + 1);
 86078:     }
 68922: 
 68922:     return true;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::destructuringExpr(BindData *data, TokenKind tt)
 40239: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(tt));
 82024: 
108876:     pc->inDeclDestructuring = true;
103823:     ParseNode *pn = primaryExpr(tt, false);
108876:     pc->inDeclDestructuring = false;
     1:     if (!pn)
     1:         return NULL;
 98181:     if (!CheckDestructuring(context, data, pn, this))
     1:         return NULL;
     1:     return pn;
     1: }
     1: 
     1: #endif /* JS_HAS_DESTRUCTURING */
     1: 
 80631: ParseNode *
 40860: Parser::returnOrYield(bool useAssignExpr)
 40221: {
 82024:     TokenKind tt = tokenStream.currentToken().type;
108876:     if (!pc->sc->inFunction()) {
102849:         reportError(NULL, JSMSG_BAD_RETURN_OR_YIELD,
 72073:                     (tt == TOK_RETURN) ? js_return_str : js_yield_str);
     1:         return NULL;
     1:     }
     1: 
 98181:     ParseNode *pn = UnaryNode::create((tt == TOK_RETURN) ? PNK_RETURN : PNK_YIELD, this);
     1:     if (!pn)
     1:         return NULL;
     1: 
     1: #if JS_HAS_GENERATORS
 72073:     if (tt == TOK_YIELD) {
 72073:         /*
 72073:          * If we're within parens, we won't know if this is a generator expression until we see
 72073:          * a |for| token, so we have to delay flagging the current function.
 72073:          */
108876:         if (pc->parenDepth == 0) {
108876:             pc->sc->setFunIsGenerator();
 72073:         } else {
108876:             pc->yieldCount++;
108876:             pc->yieldNode = pn;
 72073:         }
 72073:     }
     1: #endif
     1: 
     1:     /* This is ugly, but we don't want to require a semicolon. */
 82024:     TokenKind tt2 = tokenStream.peekTokenSameLine(TSF_OPERAND);
     1:     if (tt2 == TOK_ERROR)
     1:         return NULL;
     1: 
     1:     if (tt2 != TOK_EOF && tt2 != TOK_EOL && tt2 != TOK_SEMI && tt2 != TOK_RC
     1: #if JS_HAS_GENERATORS
   339:         && (tt != TOK_YIELD ||
 11844:             (tt2 != tt && tt2 != TOK_RB && tt2 != TOK_RP &&
 11844:              tt2 != TOK_COLON && tt2 != TOK_COMMA))
     1: #endif
 82024:         )
 82024:     {
 82024:         ParseNode *pn2 = useAssignExpr ? assignExpr() : expr();
     1:         if (!pn2)
     1:             return NULL;
     1: #if JS_HAS_GENERATORS
     1:         if (tt == TOK_RETURN)
     1: #endif
109503:             pc->funHasReturnExpr = true;
     1:         pn->pn_pos.end = pn2->pn_pos.end;
     1:         pn->pn_kid = pn2;
     1:     } else {
     1: #if JS_HAS_GENERATORS
     1:         if (tt == TOK_RETURN)
     1: #endif
109503:             pc->funHasReturnVoid = true;
109503:     }
109503: 
109503:     if (pc->funHasReturnExpr && pc->sc->funIsGenerator()) {
     1:         /* As in Python (see PEP-255), disallow return v; in generators. */
102849:         ReportBadReturn(context, this, pn, &Parser::reportError, JSMSG_BAD_GENERATOR_RETURN,
     1:                         JSMSG_BAD_ANON_GENERATOR_RETURN);
     1:         return NULL;
     1:     }
     1: 
109503:     if (context->hasStrictOption() && pc->funHasReturnExpr && pc->funHasReturnVoid &&
102849:         !ReportBadReturn(context, this, pn, &Parser::reportStrictWarning,
102849:                          JSMSG_NO_RETURN_VALUE, JSMSG_ANON_NO_RETURN_VALUE))
102849:     {
     1:         return NULL;
     1:     }
     1: 
     1:     return pn;
     1: }
     1: 
 80631: static ParseNode *
108876: PushLexicalScope(JSContext *cx, Parser *parser, StaticBlockObject &blockObj, StmtInfoPC *stmt)
 98181: {
 98181:     ParseNode *pn = LexicalScopeNode::create(PNK_LEXICALSCOPE, parser);
     1:     if (!pn)
     1:         return NULL;
     1: 
104378:     ObjectBox *blockbox = parser->newObjectBox(&blockObj);
 27012:     if (!blockbox)
 27012:         return NULL;
 27012: 
108876:     ParseContext *pc = parser->pc;
108876: 
108876:     PushStatementPC(pc, stmt, STMT_BLOCK);
108876:     blockObj.initPrevBlockChainFromParser(pc->blockChain);
108876:     FinishPushBlockScope(pc, stmt, blockObj);
104378: 
 78294:     pn->setOp(JSOP_LEAVEBLOCK);
 27012:     pn->pn_objbox = blockbox;
 47573:     pn->pn_cookie.makeFree();
 27012:     pn->pn_dflags = 0;
108876:     if (!GenerateBlockId(pc, stmt->blockid))
 27012:         return NULL;
 27012:     pn->pn_blockid = stmt->blockid;
     1:     return pn;
     1: }
     1: 
 86078: static ParseNode *
108876: PushLexicalScope(JSContext *cx, Parser *parser, StmtInfoPC *stmt)
 86078: {
 86483:     StaticBlockObject *blockObj = StaticBlockObject::create(cx);
 86483:     if (!blockObj)
 86483:         return NULL;
 86483: 
 98181:     return PushLexicalScope(cx, parser, *blockObj, stmt);
 86078: }
 86078: 
     1: #if JS_HAS_BLOCK_SCOPE
     1: 
108505: struct AddLetDecl
 86078: {
 86078:     uint32_t blockid;
 86078: 
108505:     AddLetDecl(uint32_t blockid) : blockid(blockid) {}
108505: 
108876:     bool operator()(JSContext *cx, ParseContext *pc, StaticBlockObject &blockObj, const Shape &shape, JSAtom *)
 86483:     {
 86483:         ParseNode *def = (ParseNode *) blockObj.getSlot(shape.slot()).toPrivate();
 86078:         def->pn_blockid = blockid;
108876:         return pc->define(cx, def->name(), def, Definition::LET);
 86078:     }
 86078: };
 86078: 
 86078: static ParseNode *
108876: PushLetScope(JSContext *cx, Parser *parser, StaticBlockObject &blockObj, StmtInfoPC *stmt)
 98181: {
 98181:     ParseNode *pn = PushLexicalScope(cx, parser, blockObj, stmt);
 86078:     if (!pn)
 86078:         return NULL;
 86078: 
 86078:     /* Tell codegen to emit JSOP_ENTERLETx (not JSOP_ENTERBLOCK). */
 86078:     pn->pn_dflags |= PND_LET;
 86078: 
 86078:     /* Populate the new scope with decls found in the head with updated blockid. */
108876:     if (!ForEachLetDef(cx, parser->pc, blockObj, AddLetDecl(stmt->blockid)))
 86078:         return NULL;
 86078: 
 86078:     return pn;
 86078: }
 86078: 
 86078: /*
 86078:  * Parse a let block statement or let expression (determined by 'letContext').
 86078:  * In both cases, bindings are not hoisted to the top of the enclosing block
 86078:  * and thus must be carefully injected between variables() and the let body.
 86078:  */
 80631: ParseNode *
 86078: Parser::letBlock(LetContext letContext)
     1: {
 82024:     JS_ASSERT(tokenStream.currentToken().type == TOK_LET);
 82024: 
 98181:     ParseNode *pnlet = BinaryNode::create(PNK_LET, this);
 82024:     if (!pnlet)
 82024:         return NULL;
 82024: 
 99421:     Rooted<StaticBlockObject*> blockObj(context, StaticBlockObject::create(context));
 86078:     if (!blockObj)
 86078:         return NULL;
 86078: 
 82024:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_LET);
 82024: 
 86078:     ParseNode *vars = variables(PNK_LET, blockObj, DontHoistVars);
 86078:     if (!vars)
 86078:         return NULL;
 86078: 
 86078:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_LET);
 86078: 
108876:     StmtInfoPC stmtInfo(context);
 98181:     ParseNode *block = PushLetScope(context, this, *blockObj, &stmtInfo);
 86078:     if (!block)
 86078:         return NULL;
 86078: 
 86078:     pnlet->pn_left = vars;
 86078:     pnlet->pn_right = block;
 86078: 
 86078:     ParseNode *ret;
 86078:     if (letContext == LetStatement && !tokenStream.matchToken(TOK_LC, TSF_OPERAND)) {
     1:         /*
 54158:          * Strict mode eliminates a grammar ambiguity with unparenthesized
 54158:          * LetExpressions in an ExpressionStatement. If followed immediately
 54158:          * by an arguments list, it's ambiguous whether the let expression
 54158:          * is the callee or the call is inside the let expression body.
 54158:          *
 54158:          * See bug 569464.
 54158:          */
102849:         if (!reportStrictModeError(pnlet, JSMSG_STRICT_CODE_LET_EXPR_STMT))
 99779:             return NULL;
 54158: 
 54158:         /*
     1:          * If this is really an expression in let statement guise, then we
     1:          * need to wrap the TOK_LET node in a TOK_SEMI node so that we pop
     1:          * the return value of the expression.
     1:          */
 98181:         ParseNode *semi = UnaryNode::create(PNK_SEMI, this);
 86078:         if (!semi)
 86078:             return NULL;
 86078: 
 86078:         semi->pn_kid = pnlet;
109047:         semi->pn_pos = pnlet->pn_pos;
 86078: 
 86078:         letContext = LetExpresion;
 86078:         ret = semi;
 86078:     } else {
 86078:         ret = pnlet;
 86078:     }
 86078: 
 86078:     if (letContext == LetStatement) {
 86078:         JS_ASSERT(block->getOp() == JSOP_LEAVEBLOCK);
 86078:         block->pn_expr = statements();
 86078:         if (!block->pn_expr)
     1:             return NULL;
     1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_LET);
     1:     } else {
 86078:         JS_ASSERT(letContext == LetExpresion);
 86078:         block->setOp(JSOP_LEAVEBLOCKEXPR);
 86078:         block->pn_expr = assignExpr();
 86078:         if (!block->pn_expr)
     1:             return NULL;
     1:     }
     1: 
109047:     ret->pn_pos.begin = pnlet->pn_pos.begin = pnlet->pn_left->pn_pos.begin;
109047:     ret->pn_pos.end = pnlet->pn_pos.end = pnlet->pn_right->pn_pos.end;
109047: 
108876:     PopStatementPC(context, pc);
 86078:     return ret;
     1: }
     1: 
     1: #endif /* JS_HAS_BLOCK_SCOPE */
     1: 
 27012: static bool
108876: PushBlocklikeStatement(StmtInfoPC *stmt, StmtType type, ParseContext *pc)
108876: {
108876:     PushStatementPC(pc, stmt, type);
108876:     return GenerateBlockId(pc, stmt->blockid);
 27012: }
 27012: 
 80631: static ParseNode *
106504: NewBindingNode(JSAtom *atom, Parser *parser, VarContext varContext = HoistVars)
 86078: {
108876:     ParseContext *pc = parser->pc;
 98181: 
 86078:     /*
 86078:      * If this name is being injected into an existing block/function, see if
 86078:      * it has already been declared or if it resolves an outstanding lexdep.
 86078:      * Otherwise, this is a let block/expr that introduces a new scope and thus
 86078:      * shadows existing decls and doesn't resolve existing lexdeps. Duplicate
 86078:      * names are caught by BindLet.
 86078:      */
106504:     if (varContext == HoistVars) {
108876:         if (AtomDefnPtr p = pc->lexdeps->lookup(atom)) {
106504:             ParseNode *lexdep = p.value();
106504:             JS_ASSERT(lexdep->isPlaceholder());
108876:             if (lexdep->pn_blockid >= pc->blockid()) {
108876:                 lexdep->pn_blockid = pc->blockid();
108876:                 pc->lexdeps->remove(p);
109047:                 lexdep->pn_pos = parser->tokenStream.currentToken().pos;
106504:                 return lexdep;
 27012:             }
 27012:         }
 86078:     }
 27012: 
 27012:     /* Make a new node for this declarator name (or destructuring pattern). */
 98181:     JS_ASSERT(parser->tokenStream.currentToken().type == TOK_NAME);
108876:     return NameNode::create(PNK_NAME, atom, parser, parser->pc);
 27012: }
 27012: 
 80631: ParseNode *
 57728: Parser::switchStatement()
     1: {
 98181:     JS_ASSERT(tokenStream.currentToken().type == TOK_SWITCH);
 98181:     ParseNode *pn = BinaryNode::create(PNK_SWITCH, this);
     1:     if (!pn)
     1:         return NULL;
     1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_SWITCH);
     1: 
     1:     /* pn1 points to the switch's discriminant. */
 80631:     ParseNode *pn1 = parenExpr();
     1:     if (!pn1)
     1:         return NULL;
     1: 
     1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_SWITCH);
     1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_SWITCH);
     1: 
 27012:     /*
 27012:      * NB: we must push stmtInfo before calling GenerateBlockIdForStmtNode
108876:      * because that function states pc->topStmt->blockid.
108876:      */
108876:     StmtInfoPC stmtInfo(context);
108876:     PushStatementPC(pc, &stmtInfo, STMT_SWITCH);
 27012: 
     1:     /* pn2 is a list of case nodes. The default case has pn_left == NULL */
 98181:     ParseNode *pn2 = ListNode::create(PNK_STATEMENTLIST, this);
     1:     if (!pn2)
     1:         return NULL;
 27012:     pn2->makeEmpty();
108876:     if (!GenerateBlockIdForStmtNode(pn2, pc))
108876:         return NULL;
108876:     ParseNode *saveBlock = pc->blockNode;
108876:     pc->blockNode = pn2;
     1: 
 82024:     bool seenDefault = false;
 57728:     TokenKind tt;
 40354:     while ((tt = tokenStream.getToken()) != TOK_RC) {
 80631:         ParseNode *pn3;
     1:         switch (tt) {
     1:           case TOK_DEFAULT:
     1:             if (seenDefault) {
102849:                 reportError(NULL, JSMSG_TOO_MANY_DEFAULTS);
     1:                 return NULL;
     1:             }
 82024:             seenDefault = true;
 98181:             pn3 = BinaryNode::create(PNK_DEFAULT, this);
 82024:             if (!pn3)
 82024:                 return NULL;
 82024:             break;
     1: 
     1:           case TOK_CASE:
 57728:           {
 98181:             pn3 = BinaryNode::create(PNK_CASE, this);
     1:             if (!pn3)
     1:                 return NULL;
 40263:             pn3->pn_left = expr();
     1:             if (!pn3->pn_left)
     1:                 return NULL;
 82024:             break;
 82024:           }
 82024: 
 82024:           case TOK_ERROR:
 82024:             return NULL;
 82024: 
 82024:           default:
102849:             reportError(NULL, JSMSG_BAD_SWITCH);
 82024:             return NULL;
 82024:         }
 82024: 
 27012:         pn2->append(pn3);
     1:         if (pn2->pn_count == JS_BIT(16)) {
102849:             reportError(NULL, JSMSG_TOO_MANY_CASES);
     1:             return NULL;
     1:         }
 82024: 
     1:         MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_AFTER_CASE);
     1: 
 98181:         ParseNode *pn4 = ListNode::create(PNK_STATEMENTLIST, this);
     1:         if (!pn4)
     1:             return NULL;
 27012:         pn4->makeEmpty();
 40854:         while ((tt = tokenStream.peekToken(TSF_OPERAND)) != TOK_RC &&
     1:                tt != TOK_CASE && tt != TOK_DEFAULT) {
     1:             if (tt == TOK_ERROR)
     1:                 return NULL;
 82024:             ParseNode *pn5 = statement();
     1:             if (!pn5)
     1:                 return NULL;
     1:             pn4->pn_pos.end = pn5->pn_pos.end;
 27012:             pn4->append(pn5);
 40854:         }
     1: 
     1:         /* Fix the PN_LIST so it doesn't begin at the TOK_COLON. */
     1:         if (pn4->pn_head)
     1:             pn4->pn_pos.begin = pn4->pn_head->pn_pos.begin;
     1:         pn3->pn_pos.end = pn4->pn_pos.end;
     1:         pn3->pn_right = pn4;
     1:     }
     1: 
     1:     /*
     1:      * Handle the case where there was a let declaration in any case in
     1:      * the switch body, but not within an inner block.  If it replaced
108876:      * pc->blockNode with a new block node then we must refresh pn2 and
108876:      * then restore pc->blockNode.
108876:      */
108876:     if (pc->blockNode != pn2)
108876:         pn2 = pc->blockNode;
108876:     pc->blockNode = saveBlock;
108876:     PopStatementPC(context, pc);
     1: 
 40270:     pn->pn_pos.end = pn2->pn_pos.end = tokenStream.currentToken().pos.end;
     1:     pn->pn_left = pn1;
     1:     pn->pn_right = pn2;
     1:     return pn;
     1: }
     1: 
 89621: bool
 89621: Parser::matchInOrOf(bool *isForOfp)
 89621: {
 89621:     if (tokenStream.matchToken(TOK_IN)) {
 89621:         *isForOfp = false;
 89621:         return true;
 89621:     }
 89621:     if (tokenStream.matchToken(TOK_NAME)) {
 89621:         if (tokenStream.currentToken().name() == context->runtime->atomState.ofAtom) {
 89621:             *isForOfp = true;
 89621:             return true;
 89621:         }
 89621:         tokenStream.ungetToken();
 89621:     }
 89621:     return false;
 89621: }
 89621: 
 80631: ParseNode *
 57728: Parser::forStatement()
     1: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_FOR));
 82024: 
     1:     /* A FOR node is binary, left is loop control and right is the body. */
 98181:     ParseNode *pn = BinaryNode::create(PNK_FOR, this);
     1:     if (!pn)
     1:         return NULL;
 86078: 
108876:     StmtInfoPC forStmt(context);
108876:     PushStatementPC(pc, &forStmt, STMT_FOR_LOOP);
     1: 
 78294:     pn->setOp(JSOP_ITER);
 15613:     pn->pn_iflags = 0;
 40354:     if (tokenStream.matchToken(TOK_NAME)) {
 80443:         if (tokenStream.currentToken().name() == context->runtime->atomState.eachAtom)
 15613:             pn->pn_iflags = JSITER_FOREACH;
     1:         else
 40354:             tokenStream.ungetToken();
     1:     }
     1: 
109047:     TokenPos lp_pos = tokenStream.currentToken().pos;
     1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
 81587: 
 81587:     /*
 81587:      * True if we have 'for (var/let/const ...)', except in the oddball case
 81587:      * where 'let' begins a let-expression in 'for (let (...) ...)'.
 81587:      */
 81587:     bool forDecl = false;
 81587: 
 86078:     /* Non-null when forDecl is true for a 'for (let ...)' statement. */
 99421:     Rooted<StaticBlockObject*> blockObj(context);
 86078: 
 81587:     /* Set to 'x' in 'for (x ;... ;...)' or 'for (x in ...)'. */
 80631:     ParseNode *pn1;
 81587: 
 81587:     {
 81587:         TokenKind tt = tokenStream.peekToken(TSF_OPERAND);
     1:         if (tt == TOK_SEMI) {
 74052:             if (pn->pn_iflags & JSITER_FOREACH) {
102849:                 reportError(pn, JSMSG_BAD_FOR_EACH_LOOP);
 74052:                 return NULL;
 74052:             }
     1: 
     1:             pn1 = NULL;
     1:         } else {
     1:             /*
     1:              * Set pn1 to a var list or an initializing expression.
     1:              *
109503:              * Set the parsingForInit flag during parsing of the first clause
     1:              * of the for statement.  This flag will be used by the RelExpr
     1:              * production; if it is set, then the 'in' keyword will not be
     1:              * recognized as an operator, leaving it available to be parsed as
     1:              * part of a for/in loop.
     1:              *
     1:              * A side effect of this restriction is that (unparenthesized)
     1:              * expressions involving an 'in' operator are illegal in the init
     1:              * clause of an ordinary for loop.
     1:              */
109503:             pc->parsingForInit = true;
 82874:             if (tt == TOK_VAR || tt == TOK_CONST) {
 81587:                 forDecl = true;
 82874:                 tokenStream.consumeKnownToken(tt);
 86078:                 pn1 = variables(tt == TOK_VAR ? PNK_VAR : PNK_CONST);
 82874:             }
     1: #if JS_HAS_BLOCK_SCOPE
 82874:             else if (tt == TOK_LET) {
 40354:                 (void) tokenStream.getToken();
 40354:                 if (tokenStream.peekToken() == TOK_LP) {
 86078:                     pn1 = letBlock(LetExpresion);
     1:                 } else {
 81587:                     forDecl = true;
 86483:                     blockObj = StaticBlockObject::create(context);
 86078:                     if (!blockObj)
 86078:                         return NULL;
 86078:                     pn1 = variables(PNK_LET, blockObj, DontHoistVars);
 82874:                 }
     1:             }
     1: #endif
 82874:             else {
 40263:                 pn1 = expr();
     1:             }
109503:             pc->parsingForInit = false;
     1:             if (!pn1)
     1:                 return NULL;
     1:         }
 81587:     }
     1: 
 86078:     JS_ASSERT_IF(forDecl, pn1->isArity(PN_LIST));
 86078:     JS_ASSERT(!!blockObj == (forDecl && pn1->isOp(JSOP_NOP)));
 86078: 
 86078:     const TokenPos pos = tokenStream.currentToken().pos;
 86078: 
 86078:     /* If non-null, the parent that should be returned instead of forHead. */
 86078:     ParseNode *forParent = NULL;
 86078: 
     1:     /*
     1:      * We can be sure that it's a for/in loop if there's still an 'in'
     1:      * keyword here, even if JavaScript recognizes 'in' as an operator,
     1:      * as we've excluded 'in' from being parsed in RelExpr by setting
109503:      * pc->parsingForInit.
 80631:      */
 86078:     ParseNode *forHead;        /* initialized by both branches. */
108876:     StmtInfoPC letStmt(context); /* used if blockObj != NULL. */
 86078:     ParseNode *pn2, *pn3;      /* forHead->pn_kid1 and pn_kid2. */
 89621:     bool forOf;
 89621:     if (pn1 && matchInOrOf(&forOf)) {
 89621:         /*
 89621:          * Parse the rest of the for/in or for/of head.
 74052:          *
 89621:          * Here pn1 is everything to the left of 'in' or 'of'. At the end of
 89621:          * this block, pn1 is a decl or NULL, pn2 is the assignment target that
 89621:          * receives the enumeration value each iteration, and pn3 is the rhs of
 89621:          * 'in'.
 89621:          */
 86078:         forStmt.type = STMT_FOR_IN_LOOP;
     1: 
 89621:         /* Set pn_iflags and rule out invalid combinations. */
 89621:         if (forOf && pn->pn_iflags != 0) {
 89621:             JS_ASSERT(pn->pn_iflags == JSITER_FOREACH);
102849:             reportError(NULL, JSMSG_BAD_FOR_EACH_LOOP);
 89621:             return NULL;
 89621:         }
 89621:         pn->pn_iflags |= (forOf ? JSITER_FOR_OF : JSITER_ENUMERATE);
 89621: 
 89621:         /* Check that the left side of the 'in' or 'of' is valid. */
 81587:         if (forDecl
 78294:             ? (pn1->pn_count > 1 || pn1->isOp(JSOP_DEFCONST)
     1: #if JS_HAS_DESTRUCTURING
 61450:                || (versionNumber() == JSVERSION_1_7 &&
 78294:                    pn->isOp(JSOP_ITER) &&
 15613:                    !(pn->pn_iflags & JSITER_FOREACH) &&
 82024:                    (pn1->pn_head->isKind(PNK_RC) ||
 82024:                     (pn1->pn_head->isKind(PNK_RB) &&
     1:                      pn1->pn_head->pn_count != 2) ||
 82024:                     (pn1->pn_head->isKind(PNK_ASSIGN) &&
 82024:                      (!pn1->pn_head->pn_left->isKind(PNK_RB) ||
     1:                       pn1->pn_head->pn_left->pn_count != 2))))
     1: #endif
     1:               )
 82024:             : (!pn1->isKind(PNK_NAME) &&
 82024:                !pn1->isKind(PNK_DOT) &&
     1: #if JS_HAS_DESTRUCTURING
 61450:                ((versionNumber() == JSVERSION_1_7 &&
 78294:                  pn->isOp(JSOP_ITER) &&
 15613:                  !(pn->pn_iflags & JSITER_FOREACH))
 82024:                 ? (!pn1->isKind(PNK_RB) || pn1->pn_count != 2)
 82024:                 : (!pn1->isKind(PNK_RB) && !pn1->isKind(PNK_RC))) &&
     1: #endif
 82024:                !pn1->isKind(PNK_LP) &&
     1: #if JS_HAS_XML_SUPPORT
 82114:                !pn1->isKind(PNK_XMLUNARY) &&
     1: #endif
 82024:                !pn1->isKind(PNK_LB)))
 82024:         {
102849:             reportError(pn1, JSMSG_BAD_FOR_LEFTSIDE);
     1:             return NULL;
     1:         }
     1: 
 74052:         /*
 74052:          * After the following if-else, pn2 will point to the name or
 74052:          * destructuring pattern on in's left. pn1 will point to the decl, if
 74052:          * any, else NULL. Note that the "declaration with initializer" case
 74052:          * rewrites the loop-head, moving the decl and setting pn1 to NULL.
 74052:          */
 74052:         pn2 = NULL;
 81587:         if (forDecl) {
 74052:             /* Tell EmitVariables that pn1 is part of a for/in. */
 27012:             pn1->pn_xflags |= PNX_FORINVAR;
     1: 
     1:             pn2 = pn1->pn_head;
 82024:             if ((pn2->isKind(PNK_NAME) && pn2->maybeExpr())
 20413: #if JS_HAS_DESTRUCTURING
 82024:                 || pn2->isKind(PNK_ASSIGN)
 20413: #endif
 82024:                 )
 82024:             {
 74052:                 /*
 74052:                  * Declaration with initializer.
 74052:                  *
 74052:                  * Rewrite 'for (<decl> x = i in o)' where <decl> is 'var' or
 74052:                  * 'const' to hoist the initializer or the entire decl out of
 81587:                  * the loop head.
 74052:                  */
 60541: #if JS_HAS_BLOCK_SCOPE
 86078:                 if (blockObj) {
102849:                     reportError(pn2, JSMSG_INVALID_FOR_IN_INIT);
 60541:                     return NULL;
 60541:                 }
 60541: #endif /* JS_HAS_BLOCK_SCOPE */
 60541: 
 98181:                 ParseNode *pnseq = ListNode::create(PNK_SEQ, this);
 20413:                 if (!pnseq)
 20413:                     return NULL;
 27012: 
 20413:                 /*
 20413:                  * All of 'var x = i' is hoisted above 'for (x in o)',
 20413:                  * so clear PNX_FORINVAR.
 20413:                  *
 20413:                  * Request JSOP_POP here since the var is for a simple
 20413:                  * name (it is not a destructuring binding's left-hand
 20413:                  * side) and it has an initializer.
 20413:                  */
 27012:                 pn1->pn_xflags &= ~PNX_FORINVAR;
 27012:                 pn1->pn_xflags |= PNX_POPVAR;
 27012:                 pnseq->initList(pn1);
 86078:                 pn1 = NULL;
 20413: 
 20413: #if JS_HAS_DESTRUCTURING
 82024:                 if (pn2->isKind(PNK_ASSIGN)) {
 74052:                     pn2 = pn2->pn_left;
 82024:                     JS_ASSERT(pn2->isKind(PNK_RB) || pn2->isKind(PNK_RC) ||
 82024:                               pn2->isKind(PNK_NAME));
 74052:                 }
 20413: #endif
109047:                 pnseq->pn_pos.begin = pn->pn_pos.begin;
 86078:                 pnseq->append(pn);
 86078:                 forParent = pnseq;
 86078:             }
 86078:         } else {
 86078:             /* Not a declaration. */
 86078:             JS_ASSERT(!blockObj);
 86078:             pn2 = pn1;
 74052:             pn1 = NULL;
 86078: 
 86078:             if (!setAssignmentLhsOps(pn2, JSOP_NOP))
 86078:                 return NULL;
 86078:         }
 86078: 
 86078:         pn3 = expr();
 86078:         if (!pn3)
 86078:             return NULL;
 86078: 
 86078:         if (blockObj) {
 86078:             /*
 86078:              * Now that the pn3 has been parsed, push the let scope. To hold
 86078:              * the blockObj for the emitter, wrap the TOK_LEXICALSCOPE node
 86078:              * created by PushLetScope around the for's initializer. This also
 86078:              * serves to indicate the let-decl to the emitter.
 86078:              */
 98181:             ParseNode *block = PushLetScope(context, this, *blockObj, &letStmt);
 86078:             if (!block)
 86078:                 return NULL;
103855:             letStmt.isForLetBlock = true;
 86078:             block->pn_expr = pn1;
109047:             block->pn_pos = pn1->pn_pos;
 86078:             pn1 = block;
 86078:         }
 86078: 
 86078:         if (forDecl) {
 74052:             /*
 74052:              * pn2 is part of a declaration. Make a copy that can be passed to
108505:              * EmitAssignment. Take care to do this after PushLetScope.
 74052:              */
 98181:             pn2 = CloneLeftHandSide(pn2, this);
 74052:             if (!pn2)
 74052:                 return NULL;
     1:         }
     1: 
 78294:         switch (pn2->getKind()) {
 82024:           case PNK_NAME:
     1:             /* Beware 'for (arguments in ...)' with or without a 'var'. */
108876:             NoteLValue(context, pn2, pc->sc);
     1:             break;
     1: 
     1: #if JS_HAS_DESTRUCTURING
 82024:           case PNK_ASSIGN:
 74052:             JS_NOT_REACHED("forStatement TOK_ASSIGN");
 74052:             break;
 74052: 
 82024:           case PNK_RB:
 82024:           case PNK_RC:
 61450:             if (versionNumber() == JSVERSION_1_7) {
  1599:                 /*
  1599:                  * Destructuring for-in requires [key, value] enumeration
  1599:                  * in JS1.7.
  1599:                  */
 78294:                 JS_ASSERT(pn->isOp(JSOP_ITER));
 15613:                 if (!(pn->pn_iflags & JSITER_FOREACH))
 15613:                     pn->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
  1599:             }
     1:             break;
     1: #endif
     1: 
     1:           default:;
     1:         }
     1: 
 98181:         forHead = TernaryNode::create(PNK_FORIN, this);
 86078:         if (!forHead)
 82024:             return NULL;
     1:     } else {
 86078:         if (blockObj) {
 86078:             /*
 86078:              * Desugar 'for (let A; B; C) D' into 'let (A) { for (; B; C) D }'
 86078:              * to induce the correct scoping for A.
 86078:              */
 98181:             ParseNode *block = PushLetScope(context, this, *blockObj, &letStmt);
 86078:             if (!block)
 86078:                 return NULL;
103855:             letStmt.isForLetBlock = true;
 86078: 
 86078:             ParseNode *let = new_<BinaryNode>(PNK_LET, JSOP_NOP, pos, pn1, block);
 86078:             if (!let)
 86078:                 return NULL;
 86078: 
 86078:             pn1 = NULL;
 86078:             block->pn_expr = pn;
 86078:             forParent = let;
 86078:         }
 86078: 
 74052:         if (pn->pn_iflags & JSITER_FOREACH) {
102849:             reportError(pn, JSMSG_BAD_FOR_EACH_LOOP);
 74052:             return NULL;
 74052:         }
 78294:         pn->setOp(JSOP_NOP);
     1: 
     1:         /* Parse the loop condition or null into pn2. */
     1:         MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_INIT);
 86078:         if (tokenStream.peekToken(TSF_OPERAND) == TOK_SEMI) {
     1:             pn2 = NULL;
     1:         } else {
 40263:             pn2 = expr();
     1:             if (!pn2)
     1:                 return NULL;
     1:         }
     1: 
     1:         /* Parse the update expression or null into pn3. */
     1:         MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_COND);
 86078:         if (tokenStream.peekToken(TSF_OPERAND) == TOK_RP) {
     1:             pn3 = NULL;
     1:         } else {
 40263:             pn3 = expr();
     1:             if (!pn3)
     1:                 return NULL;
     1:         }
     1: 
 98181:         forHead = TernaryNode::create(PNK_FORHEAD, this);
 86078:         if (!forHead)
 86078:             return NULL;
 86078:     }
 86078: 
 86078:     forHead->pn_pos = pos;
 86078:     forHead->setOp(JSOP_NOP);
 86078:     forHead->pn_kid1 = pn1;
 86078:     forHead->pn_kid2 = pn2;
 86078:     forHead->pn_kid3 = pn3;
109047:     forHead->pn_pos.begin = lp_pos.begin;
109047:     forHead->pn_pos.end   = tokenStream.currentToken().pos.end;
 86078:     pn->pn_left = forHead;
     1: 
     1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
     1: 
 86078:     /* Parse the loop body. */
 86078:     ParseNode *body = statement();
 86078:     if (!body)
 86078:         return NULL;
     1: 
     1:     /* Record the absolute line number for source note emission. */
 86078:     pn->pn_pos.end = body->pn_pos.end;
 86078:     pn->pn_right = body;
 86078: 
 86078:     if (forParent) {
 86078:         forParent->pn_pos.begin = pn->pn_pos.begin;
 86078:         forParent->pn_pos.end = pn->pn_pos.end;
 86078:     }
     1: 
     1: #if JS_HAS_BLOCK_SCOPE
 86078:     if (blockObj)
108876:         PopStatementPC(context, pc);
     1: #endif
108876:     PopStatementPC(context, pc);
 86078:     return forParent ? forParent : pn;
     1: }
     1: 
 80631: ParseNode *
 57728: Parser::tryStatement()
 57728: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_TRY));
     1: 
     1:     /*
     1:      * try nodes are ternary.
 40239:      * kid1 is the try statement
     1:      * kid2 is the catch node list or null
 40239:      * kid3 is the finally statement
     1:      *
     1:      * catch nodes are ternary.
     1:      * kid1 is the lvalue (TOK_NAME, TOK_LB, or TOK_LC)
     1:      * kid2 is the catch guard or null if no guard
     1:      * kid3 is the catch block
     1:      *
     1:      * catch lvalue nodes are either:
     1:      *   TOK_NAME for a single identifier
     1:      *   TOK_RB or TOK_RC for a destructuring left-hand side
     1:      *
 40239:      * finally nodes are TOK_LC statement lists.
 40221:      */
 98181:     ParseNode *pn = TernaryNode::create(PNK_TRY, this);
     1:     if (!pn)
     1:         return NULL;
 78294:     pn->setOp(JSOP_NOP);
     1: 
     1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_TRY);
108876:     StmtInfoPC stmtInfo(context);
108876:     if (!PushBlocklikeStatement(&stmtInfo, STMT_TRY, pc))
 27012:         return NULL;
 40263:     pn->pn_kid1 = statements();
     1:     if (!pn->pn_kid1)
     1:         return NULL;
     1:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_TRY);
108876:     PopStatementPC(context, pc);
     1: 
 82024:     ParseNode *lastCatch;
 82024:     ParseNode *catchList = NULL;
 57728:     TokenKind tt = tokenStream.getToken();
     1:     if (tt == TOK_CATCH) {
 98181:         catchList = ListNode::create(PNK_CATCHLIST, this);
     1:         if (!catchList)
     1:             return NULL;
 27012:         catchList->makeEmpty();
     1:         lastCatch = NULL;
     1: 
     1:         do {
 80631:             ParseNode *pnblock;
 97353:             BindData data(context);
     1: 
     1:             /* Check for another catch after unconditional catch. */
     1:             if (lastCatch && !lastCatch->pn_kid2) {
102849:                 reportError(NULL, JSMSG_CATCH_AFTER_GENERAL);
     1:                 return NULL;
     1:             }
     1: 
     1:             /*
     1:              * Create a lexical scope node around the whole catch clause,
     1:              * including the head.
     1:              */
 98181:             pnblock = PushLexicalScope(context, this, &stmtInfo);
     1:             if (!pnblock)
     1:                 return NULL;
     1:             stmtInfo.type = STMT_CATCH;
     1: 
     1:             /*
     1:              * Legal catch forms are:
     1:              *   catch (lhs)
     1:              *   catch (lhs if <boolean_expression>)
     1:              * where lhs is a name or a destructuring left-hand side.
     1:              * (the latter is legal only #ifdef JS_HAS_CATCH_GUARD)
     1:              */
 98181:             ParseNode *pn2 = TernaryNode::create(PNK_CATCH, this);
     1:             if (!pn2)
     1:                 return NULL;
     1:             pnblock->pn_expr = pn2;
     1:             MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_CATCH);
     1: 
     1:             /*
     1:              * Contrary to ECMA Ed. 3, the catch variable is lexically
     1:              * scoped, not a property of a new Object instance.  This is
     1:              * an intentional change that anticipates ECMA Ed. 4.
     1:              */
108876:             data.initLet(HoistVars, *pc->blockChain, JSMSG_TOO_MANY_CATCH_VARS);
 86078:             JS_ASSERT(data.let.blockObj && data.let.blockObj == pnblock->pn_objbox->object);
     1: 
 40354:             tt = tokenStream.getToken();
 80631:             ParseNode *pn3;
     1:             switch (tt) {
     1: #if JS_HAS_DESTRUCTURING
     1:               case TOK_LB:
     1:               case TOK_LC:
 40263:                 pn3 = destructuringExpr(&data, tt);
     1:                 if (!pn3)
     1:                     return NULL;
     1:                 break;
     1: #endif
     1: 
     1:               case TOK_NAME:
 57728:               {
108174:                 RootedPropertyName label(context, tokenStream.currentToken().name());
 98181:                 pn3 = NewBindingNode(label, this);
 27012:                 if (!pn3)
 27012:                     return NULL;
 27012:                 data.pn = pn3;
 98181:                 if (!data.binder(context, &data, label, this))
 26970:                     return NULL;
     1:                 break;
 57728:               }
     1: 
     1:               default:
102849:                 reportError(NULL, JSMSG_CATCH_IDENTIFIER);
     1:                 return NULL;
     1:             }
     1: 
     1:             pn2->pn_kid1 = pn3;
     1: #if JS_HAS_CATCH_GUARD
     1:             /*
     1:              * We use 'catch (x if x === 5)' (not 'catch (x : x === 5)')
     1:              * to avoid conflicting with the JS2/ECMAv4 type annotation
     1:              * catchguard syntax.
     1:              */
 40354:             if (tokenStream.matchToken(TOK_IF)) {
 40263:                 pn2->pn_kid2 = expr();
     1:                 if (!pn2->pn_kid2)
     1:                     return NULL;
     1:             }
     1: #endif
     1:             MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_CATCH);
     1: 
     1:             MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_CATCH);
 40263:             pn2->pn_kid3 = statements();
     1:             if (!pn2->pn_kid3)
     1:                 return NULL;
     1:             MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_CATCH);
108876:             PopStatementPC(context, pc);
 27012: 
109047:             pnblock->pn_pos.end = pn2->pn_pos.end = tokenStream.currentToken().pos.end;
109047: 
 27012:             catchList->append(pnblock);
     1:             lastCatch = pn2;
 40854:             tt = tokenStream.getToken(TSF_OPERAND);
     1:         } while (tt == TOK_CATCH);
     1:     }
     1:     pn->pn_kid2 = catchList;
     1: 
     1:     if (tt == TOK_FINALLY) {
     1:         MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_FINALLY);
108876:         if (!PushBlocklikeStatement(&stmtInfo, STMT_FINALLY, pc))
 27012:             return NULL;
 40263:         pn->pn_kid3 = statements();
     1:         if (!pn->pn_kid3)
     1:             return NULL;
     1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_FINALLY);
108876:         PopStatementPC(context, pc);
     1:     } else {
 40354:         tokenStream.ungetToken();
     1:     }
     1:     if (!catchList && !pn->pn_kid3) {
102849:         reportError(NULL, JSMSG_CATCH_OR_FINALLY);
     1:         return NULL;
     1:     }
109047:     pn->pn_pos.end = (pn->pn_kid3 ? pn->pn_kid3 : catchList)->pn_pos.end;
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
 57728: Parser::withStatement()
 52554: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_WITH));
 82024: 
104093:     // In most cases, we want the constructs forbidden in strict mode code to be
104093:     // a subset of those that JSOPTION_STRICT warns about, and we should use
104093:     // reportStrictModeError.  However, 'with' is the sole instance of a
104093:     // construct that is forbidden in strict mode code, but doesn't even merit a
104093:     // warning under JSOPTION_STRICT.  See
104093:     // https://bugzilla.mozilla.org/show_bug.cgi?id=514576#c1. The actual
104093:     // supression of the with code warning is in
104093:     // TokenStream::reportCompileErrorNumberVA.
104093:     if (!reportStrictModeError(NULL, JSMSG_STRICT_CODE_WITH))
104093:         return NULL;
 35305: 
 98181:     ParseNode *pn = BinaryNode::create(PNK_WITH, this);
     1:     if (!pn)
     1:         return NULL;
     1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_WITH);
 80631:     ParseNode *pn2 = parenExpr();
     1:     if (!pn2)
     1:         return NULL;
     1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_WITH);
     1:     pn->pn_left = pn2;
     1: 
109603:     ParseNode *oldWith = pc->innermostWith;
109603:     pc->innermostWith = pn;
108876: 
108876:     StmtInfoPC stmtInfo(context);
108876:     PushStatementPC(pc, &stmtInfo, STMT_WITH);
 40263:     pn2 = statement();
     1:     if (!pn2)
     1:         return NULL;
108876:     PopStatementPC(context, pc);
     1: 
     1:     pn->pn_pos.end = pn2->pn_pos.end;
     1:     pn->pn_right = pn2;
 95099: 
108876:     pc->sc->setBindingsAccessedDynamically();
109603:     pc->innermostWith = oldWith;
 52554: 
 52554:     /*
 52554:      * Make sure to deoptimize lexical dependencies inside the |with|
 52554:      * to safely optimize binding globals (see bug 561923).
 52554:      */
108876:     for (AtomDefnRange r = pc->lexdeps->all(); !r.empty(); r.popFront()) {
 80631:         Definition *defn = r.front().value();
 80631:         Definition *lexdep = defn->resolve();
 52554:         DeoptimizeUsesWithin(lexdep, pn->pn_pos);
 52554:     }
 52554: 
     1:     return pn;
 52554: }
     1: 
     1: #if JS_HAS_BLOCK_SCOPE
 80631: ParseNode *
 57728: Parser::letStatement()
     1: {
 80631:     ParseNode *pn;
 57728:     do {
     1:         /* Check for a let statement or let expression. */
 40354:         if (tokenStream.peekToken() == TOK_LP) {
 86078:             pn = letBlock(LetStatement);
 86078:             if (!pn)
 86078:                 return NULL;
 86078: 
 86078:             JS_ASSERT(pn->isKind(PNK_LET) || pn->isKind(PNK_SEMI));
 86078:             if (pn->isKind(PNK_LET) && pn->pn_expr->getOp() == JSOP_LEAVEBLOCK)
     1:                 return pn;
     1: 
     1:             /* Let expressions require automatic semicolon insertion. */
 86078:             JS_ASSERT(pn->isKind(PNK_SEMI) || pn->isOp(JSOP_NOP));
     1:             break;
     1:         }
     1: 
     1:         /*
 80631:          * This is a let declaration. We must be directly under a block per the
 80631:          * proposed ES4 specs, but not an implicit block created due to
  9976:          * 'for (let ...)'. If we pass this error test, make the enclosing
108876:          * StmtInfoPC be our scope. Further let declarations in this block will
 80631:          * find this scope statement and use the same block object.
  9976:          *
  9976:          * If we are the first let declaration in this block (i.e., when the
108876:          * enclosing maybe-scope StmtInfoPC isn't yet a scope statement) then
108876:          * we also need to set pc->blockNode to be our TOK_LEXICALSCOPE.
108876:          */
108876:         StmtInfoPC *stmt = pc->topStmt;
103855:         if (stmt && (!stmt->maybeScope() || stmt->isForLetBlock)) {
102849:             reportError(NULL, JSMSG_LET_DECL_NOT_IN_BLOCK);
  9832:             return NULL;
     1:         }
     1: 
103855:         if (stmt && stmt->isBlockScope) {
108876:             JS_ASSERT(pc->blockChain == stmt->blockObj);
     1:         } else {
103855:             if (!stmt || stmt->isFunctionBodyBlock) {
     1:                 /*
 16379:                  * ES4 specifies that let at top level and at body-block scope
 16379:                  * does not shadow var, so convert back to var.
     1:                  */
 86078:                 pn = variables(PNK_VAR);
     1:                 if (!pn)
     1:                     return NULL;
 27012:                 pn->pn_xflags |= PNX_POPVAR;
     1:                 break;
     1:             }
     1: 
 18084:             /*
 18084:              * Some obvious assertions here, but they may help clarify the
 18084:              * situation. This stmt is not yet a scope, so it must not be a
 27012:              * catch block (catch is a lexical scope by definition).
 18084:              */
103855:             JS_ASSERT(!stmt->isBlockScope);
108876:             JS_ASSERT(stmt != pc->topScopeStmt);
 18084:             JS_ASSERT(stmt->type == STMT_BLOCK ||
 18084:                       stmt->type == STMT_SWITCH ||
 18084:                       stmt->type == STMT_TRY ||
 18084:                       stmt->type == STMT_FINALLY);
 18084:             JS_ASSERT(!stmt->downScope);
 18084: 
     1:             /* Convert the block statement into a scope statement. */
 98181:             StaticBlockObject *blockObj = StaticBlockObject::create(context);
 86483:             if (!blockObj)
 86483:                 return NULL;
 86483: 
 98181:             ObjectBox *blockbox = newObjectBox(blockObj);
 27012:             if (!blockbox)
     1:                 return NULL;
     1: 
     1:             /*
108876:              * Insert stmt on the pc->topScopeStmt/stmtInfo.downScope linked
     1:              * list stack, if it isn't already there.  If it is there, but it
     1:              * lacks the SIF_SCOPE flag, it must be a try, catch, or finally
     1:              * block.
     1:              */
103855:             stmt->isBlockScope = true;
108876:             stmt->downScope = pc->topScopeStmt;
108876:             pc->topScopeStmt = stmt;
108876: 
108876:             blockObj->initPrevBlockChainFromParser(pc->blockChain);
108876:             pc->blockChain = blockObj;
 86483:             stmt->blockObj = blockObj;
     1: 
     1: #ifdef DEBUG
108876:             ParseNode *tmp = pc->blockNode;
 82024:             JS_ASSERT(!tmp || !tmp->isKind(PNK_LEXICALSCOPE));
     1: #endif
     1: 
     1:             /* Create a new lexical scope node for these statements. */
 98181:             ParseNode *pn1 = LexicalScopeNode::create(PNK_LEXICALSCOPE, this);
     1:             if (!pn1)
     1:                 return NULL;
     1: 
 78294:             pn1->setOp(JSOP_LEAVEBLOCK);
108876:             pn1->pn_pos = pc->blockNode->pn_pos;
 27012:             pn1->pn_objbox = blockbox;
108876:             pn1->pn_expr = pc->blockNode;
108876:             pn1->pn_blockid = pc->blockNode->pn_blockid;
108876:             pc->blockNode = pn1;
108876:         }
108876: 
108876:         pn = variables(PNK_LET, pc->blockChain, HoistVars);
     1:         if (!pn)
     1:             return NULL;
 27012:         pn->pn_xflags = PNX_POPVAR;
 57728:     } while (0);
 57728: 
 57728:     /* Check termination of this primitive statement. */
 57728:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
 57728: }
     1: #endif
     1: 
 80631: ParseNode *
 57728: Parser::expressionStatement()
 57728: {
 40354:     tokenStream.ungetToken();
 80631:     ParseNode *pn2 = expr();
     1:     if (!pn2)
     1:         return NULL;
     1: 
 40354:     if (tokenStream.peekToken() == TOK_COLON) {
 82024:         if (!pn2->isKind(PNK_NAME)) {
102849:             reportError(NULL, JSMSG_BAD_LABEL);
     1:             return NULL;
     1:         }
 57728:         JSAtom *label = pn2->pn_atom;
108876:         for (StmtInfoPC *stmt = pc->topStmt; stmt; stmt = stmt->down) {
 27012:             if (stmt->type == STMT_LABEL && stmt->label == label) {
102849:                 reportError(NULL, JSMSG_DUPLICATE_LABEL);
     1:                 return NULL;
     1:             }
     1:         }
 27012:         ForgetUse(pn2);
 27012: 
 40354:         (void) tokenStream.getToken();
     1: 
     1:         /* Push a label struct and parse the statement. */
108876:         StmtInfoPC stmtInfo(context);
108876:         PushStatementPC(pc, &stmtInfo, STMT_LABEL);
 27012:         stmtInfo.label = label;
 80631:         ParseNode *pn = statement();
     1:         if (!pn)
     1:             return NULL;
     1: 
     1:         /* Normalize empty statement to empty block for the decompiler. */
 82024:         if (pn->isKind(PNK_SEMI) && !pn->pn_kid) {
 82873:             pn->setKind(PNK_STATEMENTLIST);
 78294:             pn->setArity(PN_LIST);
 27012:             pn->makeEmpty();
     1:         }
     1: 
     1:         /* Pop the label, set pn_expr, and return early. */
108876:         PopStatementPC(context, pc);
 82024:         pn2->setKind(PNK_COLON);
     1:         pn2->pn_pos.end = pn->pn_pos.end;
     1:         pn2->pn_expr = pn;
     1:         return pn2;
     1:     }
     1: 
 98181:     ParseNode *pn = UnaryNode::create(PNK_SEMI, this);
     1:     if (!pn)
     1:         return NULL;
     1:     pn->pn_pos = pn2->pn_pos;
     1:     pn->pn_kid = pn2;
 32658: 
 57728:     /* Check termination of this primitive statement. */
 57728:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
 57728: }
 57728: 
 80631: ParseNode *
 57728: Parser::statement()
 57728: {
 80631:     ParseNode *pn;
 57728: 
 57728:     JS_CHECK_RECURSION(context, return NULL);
 57728: 
 57728:     switch (tokenStream.getToken(TSF_OPERAND)) {
 57728:       case TOK_FUNCTION:
 57728:       {
 57728: #if JS_HAS_XML_SUPPORT
 99820:         if (allowsXML()) {
 57728:             TokenKind tt = tokenStream.peekToken(TSF_KEYWORD_IS_NAME);
 57728:             if (tt == TOK_DBLCOLON)
 80780:                 return expressionStatement();
 80780:         }
 57728: #endif
 57728:         return functionStmt();
 57728:       }
 57728: 
 57728:       case TOK_IF:
 57728:       {
 57728:         /* An IF node has three kids: condition, then, and optional else. */
 98181:         pn = TernaryNode::create(PNK_IF, this);
 57728:         if (!pn)
 57728:             return NULL;
 80631:         ParseNode *pn1 = condition();
 57728:         if (!pn1)
 57728:             return NULL;
 84700: 
108876:         StmtInfoPC stmtInfo(context);
108876:         PushStatementPC(pc, &stmtInfo, STMT_IF);
 80631:         ParseNode *pn2 = statement();
 57728:         if (!pn2)
 57728:             return NULL;
 84700: 
 84700:         if (pn2->isKind(PNK_SEMI) &&
 84700:             !pn2->pn_kid &&
102849:             !reportStrictWarning(NULL, JSMSG_EMPTY_CONSEQUENT))
 84700:         {
 84700:             return NULL;
 84700:         }
 84700: 
 80631:         ParseNode *pn3;
 57728:         if (tokenStream.matchToken(TOK_ELSE, TSF_OPERAND)) {
 57728:             stmtInfo.type = STMT_ELSE;
 57728:             pn3 = statement();
 57728:             if (!pn3)
 57728:                 return NULL;
 57728:             pn->pn_pos.end = pn3->pn_pos.end;
 57728:         } else {
 57728:             pn3 = NULL;
 57728:             pn->pn_pos.end = pn2->pn_pos.end;
 57728:         }
108876:         PopStatementPC(context, pc);
 57728:         pn->pn_kid1 = pn1;
 57728:         pn->pn_kid2 = pn2;
 57728:         pn->pn_kid3 = pn3;
 57728:         return pn;
 57728:       }
 57728: 
 57728:       case TOK_SWITCH:
 57728:         return switchStatement();
 57728: 
 57728:       case TOK_WHILE:
 57728:       {
 98181:         pn = BinaryNode::create(PNK_WHILE, this);
 57728:         if (!pn)
 57728:             return NULL;
108876:         StmtInfoPC stmtInfo(context);
108876:         PushStatementPC(pc, &stmtInfo, STMT_WHILE_LOOP);
 80631:         ParseNode *pn2 = condition();
 57728:         if (!pn2)
 57728:             return NULL;
 57728:         pn->pn_left = pn2;
 80631:         ParseNode *pn3 = statement();
 57728:         if (!pn3)
 57728:             return NULL;
108876:         PopStatementPC(context, pc);
 57728:         pn->pn_pos.end = pn3->pn_pos.end;
 57728:         pn->pn_right = pn3;
 57728:         return pn;
 57728:       }
 57728: 
 57728:       case TOK_DO:
 57728:       {
 98181:         pn = BinaryNode::create(PNK_DOWHILE, this);
 57728:         if (!pn)
 57728:             return NULL;
108876:         StmtInfoPC stmtInfo(context);
108876:         PushStatementPC(pc, &stmtInfo, STMT_DO_LOOP);
 80631:         ParseNode *pn2 = statement();
 57728:         if (!pn2)
 57728:             return NULL;
 57728:         pn->pn_left = pn2;
 57728:         MUST_MATCH_TOKEN(TOK_WHILE, JSMSG_WHILE_AFTER_DO);
 80631:         ParseNode *pn3 = condition();
 57728:         if (!pn3)
 57728:             return NULL;
108876:         PopStatementPC(context, pc);
 57728:         pn->pn_pos.end = pn3->pn_pos.end;
 57728:         pn->pn_right = pn3;
 61450:         if (versionNumber() != JSVERSION_ECMA_3) {
 57728:             /*
 57728:              * All legacy and extended versions must do automatic semicolon
 57728:              * insertion after do-while.  See the testcase and discussion in
 57728:              * http://bugzilla.mozilla.org/show_bug.cgi?id=238945.
 57728:              */
 57728:             (void) tokenStream.matchToken(TOK_SEMI);
 57728:             return pn;
 57728:         }
 57728:         break;
 57728:       }
 57728: 
 57728:       case TOK_FOR:
 57728:         return forStatement();
 57728: 
 57728:       case TOK_TRY:
 57728:         return tryStatement();
 57728: 
 57728:       case TOK_THROW:
 57728:       {
 98181:         pn = UnaryNode::create(PNK_THROW, this);
 57728:         if (!pn)
 57728:             return NULL;
 57728: 
 57728:         /* ECMA-262 Edition 3 says 'throw [no LineTerminator here] Expr'. */
 57728:         TokenKind tt = tokenStream.peekTokenSameLine(TSF_OPERAND);
 57728:         if (tt == TOK_ERROR)
 57728:             return NULL;
 57728:         if (tt == TOK_EOF || tt == TOK_EOL || tt == TOK_SEMI || tt == TOK_RC) {
102849:             reportError(NULL, JSMSG_SYNTAX_ERROR);
 57728:             return NULL;
 57728:         }
 57728: 
 80631:         ParseNode *pn2 = expr();
 57728:         if (!pn2)
 57728:             return NULL;
 57728:         pn->pn_pos.end = pn2->pn_pos.end;
 78294:         pn->setOp(JSOP_THROW);
 57728:         pn->pn_kid = pn2;
 57728:         break;
 57728:       }
 57728: 
 57728:       /* TOK_CATCH and TOK_FINALLY are both handled in the TOK_TRY case */
 57728:       case TOK_CATCH:
102849:         reportError(NULL, JSMSG_CATCH_WITHOUT_TRY);
 57728:         return NULL;
 57728: 
 57728:       case TOK_FINALLY:
102849:         reportError(NULL, JSMSG_FINALLY_WITHOUT_TRY);
 57728:         return NULL;
 57728: 
 57728:       case TOK_BREAK:
 57728:       {
 84666:         TokenPtr begin = tokenStream.currentToken().pos.begin;
 84666:         PropertyName *label;
 84666:         if (!MatchLabel(context, &tokenStream, &label))
 84666:             return NULL;
 84666:         TokenPtr end = tokenStream.currentToken().pos.end;
 84666:         pn = new_<BreakStatement>(label, begin, end);
 57728:         if (!pn)
 57728:             return NULL;
108876:         StmtInfoPC *stmt = pc->topStmt;
 57728:         if (label) {
 57728:             for (; ; stmt = stmt->down) {
 57728:                 if (!stmt) {
102849:                     reportError(NULL, JSMSG_LABEL_NOT_FOUND);
 57728:                     return NULL;
 57728:                 }
 57728:                 if (stmt->type == STMT_LABEL && stmt->label == label)
 57728:                     break;
 57728:             }
 57728:         } else {
 57728:             for (; ; stmt = stmt->down) {
 57728:                 if (!stmt) {
102849:                     reportError(NULL, JSMSG_TOUGH_BREAK);
 57728:                     return NULL;
 57728:                 }
103854:                 if (stmt->isLoop() || stmt->type == STMT_SWITCH)
 57728:                     break;
 57728:             }
 57728:         }
 57728:         break;
 57728:       }
 57728: 
 57728:       case TOK_CONTINUE:
 57728:       {
 84666:         TokenPtr begin = tokenStream.currentToken().pos.begin;
 84666:         PropertyName *label;
 84666:         if (!MatchLabel(context, &tokenStream, &label))
 84666:             return NULL;
 84666:         TokenPtr end = tokenStream.currentToken().pos.begin;
 84666:         pn = new_<ContinueStatement>(label, begin, end);
 57728:         if (!pn)
 57728:             return NULL;
108876:         StmtInfoPC *stmt = pc->topStmt;
 57728:         if (label) {
108876:             for (StmtInfoPC *stmt2 = NULL; ; stmt = stmt->down) {
 57728:                 if (!stmt) {
102849:                     reportError(NULL, JSMSG_LABEL_NOT_FOUND);
 57728:                     return NULL;
 57728:                 }
 57728:                 if (stmt->type == STMT_LABEL) {
 57728:                     if (stmt->label == label) {
103854:                         if (!stmt2 || !stmt2->isLoop()) {
102849:                             reportError(NULL, JSMSG_BAD_CONTINUE);
 57728:                             return NULL;
 57728:                         }
 57728:                         break;
 57728:                     }
 57728:                 } else {
 57728:                     stmt2 = stmt;
 57728:                 }
 57728:             }
 57728:         } else {
 57728:             for (; ; stmt = stmt->down) {
 57728:                 if (!stmt) {
102849:                     reportError(NULL, JSMSG_BAD_CONTINUE);
 57728:                     return NULL;
 57728:                 }
103854:                 if (stmt->isLoop())
 57728:                     break;
 57728:             }
 57728:         }
 57728:         break;
 57728:       }
 57728: 
 57728:       case TOK_WITH:
 57728:         return withStatement();
 57728: 
 57728:       case TOK_VAR:
 86078:         pn = variables(PNK_VAR);
 82874:         if (!pn)
 82874:             return NULL;
 82874: 
 82874:         /* Tell js_EmitTree to generate a final POP. */
 82874:         pn->pn_xflags |= PNX_POPVAR;
 82874:         break;
 82874: 
 82874:       case TOK_CONST:
 86078:         pn = variables(PNK_CONST);
 57728:         if (!pn)
 57728:             return NULL;
 57728: 
 57728:         /* Tell js_EmitTree to generate a final POP. */
 57728:         pn->pn_xflags |= PNX_POPVAR;
 57728:         break;
 57728: 
 57728: #if JS_HAS_BLOCK_SCOPE
 57728:       case TOK_LET:
 57728:         return letStatement();
 57728: #endif /* JS_HAS_BLOCK_SCOPE */
 57728: 
 57728:       case TOK_RETURN:
 57728:         pn = returnOrYield(false);
 57728:         if (!pn)
 57728:             return NULL;
 57728:         break;
 57728: 
 57728:       case TOK_LC:
 57728:       {
108876:         StmtInfoPC stmtInfo(context);
108876:         if (!PushBlocklikeStatement(&stmtInfo, STMT_BLOCK, pc))
 57728:             return NULL;
 98452:         bool hasFunctionStmt;
 98452:         pn = statements(&hasFunctionStmt);
 57728:         if (!pn)
 57728:             return NULL;
 57728: 
 57728:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_COMPOUND);
108876:         PopStatementPC(context, pc);
 57728: 
 57728:         /*
 57728:          * If we contain a function statement and our container is top-level
 57728:          * or another block, flag pn to preserve braces when decompiling.
 57728:          */
108876:         if (hasFunctionStmt && (!pc->topStmt || pc->topStmt->type == STMT_BLOCK))
 57728:             pn->pn_xflags |= PNX_NEEDBRACES;
 98452: 
 57728:         return pn;
 57728:       }
 57728: 
 57728:       case TOK_SEMI:
 98181:         pn = UnaryNode::create(PNK_SEMI, this);
 57728:         if (!pn)
 57728:             return NULL;
 57728:         return pn;
 57728: 
 57728:       case TOK_DEBUGGER:
 98181:         pn = new_<DebuggerStatement>(tokenStream.currentToken().pos);
 57728:         if (!pn)
 57728:             return NULL;
108876:         pc->sc->setBindingsAccessedDynamically();
 57728:         break;
 57728: 
 57728: #if JS_HAS_XML_SUPPORT
 57728:       case TOK_DEFAULT:
 57728:       {
 99820:         if (!allowsXML())
 80780:             return expressionStatement();
 80780: 
 98181:         pn = UnaryNode::create(PNK_DEFXMLNS, this);
 57728:         if (!pn)
 57728:             return NULL;
 57728:         if (!tokenStream.matchToken(TOK_NAME) ||
 80443:             tokenStream.currentToken().name() != context->runtime->atomState.xmlAtom ||
 57728:             !tokenStream.matchToken(TOK_NAME) ||
 80443:             tokenStream.currentToken().name() != context->runtime->atomState.namespaceAtom ||
 82023:             !tokenStream.matchToken(TOK_ASSIGN))
 82023:         {
102849:             reportError(NULL, JSMSG_BAD_DEFAULT_XML_NAMESPACE);
 57728:             return NULL;
 57728:         }
 57728: 
 82023:         JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NOP);
 82023: 
 57728:         /* Is this an E4X dagger I see before me? */
108876:         pc->sc->setBindingsAccessedDynamically();
 80631:         ParseNode *pn2 = expr();
 57728:         if (!pn2)
 57728:             return NULL;
 78294:         pn->setOp(JSOP_DEFXMLNS);
 57728:         pn->pn_pos.end = pn2->pn_pos.end;
 57728:         pn->pn_kid = pn2;
 57728:         break;
 57728:       }
 57728: #endif
 57728: 
 57728:       case TOK_ERROR:
 57728:         return NULL;
 57728: 
 57728:       default:
 57728:         return expressionStatement();
     1:     }
     1: 
     1:     /* Check termination of this primitive statement. */
 40239:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
     1: }
     1: 
 86078: /*
 86078:  * The 'blockObj' parameter is non-null when parsing the 'vars' in a let
 86078:  * expression, block statement, non-top-level let declaration in statement
 86078:  * context, and the let-initializer of a for-statement.
 86078:  */
 80631: ParseNode *
 86483: Parser::variables(ParseNodeKind kind, StaticBlockObject *blockObj, VarContext varContext)
 82874: {
 82874:     /*
 82874:      * The four options here are:
 82874:      * - PNK_VAR:   We're parsing var declarations.
 82874:      * - PNK_CONST: We're parsing const declarations.
 82874:      * - PNK_LET:   We are parsing a let declaration.
 82874:      * - PNK_LP:    We are parsing the head of a let block.
 82874:      */
 82874:     JS_ASSERT(kind == PNK_VAR || kind == PNK_CONST || kind == PNK_LET || kind == PNK_LP);
 82874: 
 98181:     ParseNode *pn = ListNode::create(kind, this);
     1:     if (!pn)
     1:         return NULL;
 86078: 
 86078:     pn->setOp(blockObj ? JSOP_NOP : kind == PNK_VAR ? JSOP_DEFVAR : JSOP_DEFCONST);
 27012:     pn->makeEmpty();
 27012: 
 27012:     /*
 27012:      * SpiderMonkey const is really "write once per initialization evaluation"
 27012:      * var, whereas let is block scoped. ES-Harmony wants block-scoped const so
 27012:      * this code will change soon.
     1:      */
 97353:     BindData data(context);
 86078:     if (blockObj)
 86483:         data.initLet(varContext, *blockObj, JSMSG_TOO_MANY_LOCALS);
 86078:     else
 86078:         data.initVarOrConst(pn->getOp());
     1: 
 82024:     ParseNode *pn2;
     1:     do {
 82874:         TokenKind tt = tokenStream.getToken();
     1: #if JS_HAS_DESTRUCTURING
     1:         if (tt == TOK_LB || tt == TOK_LC) {
108876:             pc->inDeclDestructuring = true;
103823:             pn2 = primaryExpr(tt, false);
108876:             pc->inDeclDestructuring = false;
     1:             if (!pn2)
     1:                 return NULL;
     1: 
 98181:             if (!CheckDestructuring(context, &data, pn2, this))
 28995:                 return NULL;
 89621:             bool ignored;
109503:             if (pc->parsingForInit && matchInOrOf(&ignored)) {
 89621:                 tokenStream.ungetToken();
 27012:                 pn->append(pn2);
     1:                 continue;
     1:             }
     1: 
     1:             MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_BAD_DESTRUCT_DECL);
 82023:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NOP);
     1: 
 80631:             ParseNode *init = assignExpr();
 68923:             if (!init)
 68923:                 return NULL;
 28995: 
 98181:             pn2 = ParseNode::newBinaryOrAppend(PNK_ASSIGN, JSOP_NOP, pn2, init, this);
 28995:             if (!pn2)
 28995:                 return NULL;
 27012:             pn->append(pn2);
     1:             continue;
     1:         }
 27012: #endif /* JS_HAS_DESTRUCTURING */
     1: 
     1:         if (tt != TOK_NAME) {
 74052:             if (tt != TOK_ERROR)
102849:                 reportError(NULL, JSMSG_NO_VARIABLE_NAME);
 27012:             return NULL;
 27012:         }
 27012: 
108174:         RootedPropertyName name(context, tokenStream.currentToken().name());
106504:         pn2 = NewBindingNode(name, this, varContext);
 27012:         if (!pn2)
 27012:             return NULL;
 27012:         if (data.op == JSOP_DEFCONST)
 27012:             pn2->pn_dflags |= PND_CONST;
 27012:         data.pn = pn2;
 98181:         if (!data.binder(context, &data, name, this))
 26970:             return NULL;
 27012:         pn->append(pn2);
     1: 
 40354:         if (tokenStream.matchToken(TOK_ASSIGN)) {
 82023:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NOP);
     1: 
 80631:             ParseNode *init = assignExpr();
 27012:             if (!init)
 27012:                 return NULL;
 27012: 
 78294:             if (pn2->isUsed()) {
 98181:                 pn2 = MakeAssignment(pn2, init, this);
 27012:                 if (!pn2)
 27012:                     return NULL;
 27012:             } else {
 27012:                 pn2->pn_expr = init;
 27012:             }
 27012: 
 95100:             pn2->setOp((pn2->pn_dflags & PND_BOUND)
 27012:                        ? JSOP_SETLOCAL
 27012:                        : (data.op == JSOP_DEFCONST)
     1:                        ? JSOP_SETCONST
 78294:                        : JSOP_SETNAME);
 27012: 
108876:             NoteLValue(context, pn2, pc->sc);
 27012: 
 27012:             /* The declarator's position must include the initializer. */
 27012:             pn2->pn_pos.end = init->pn_pos.end;
 27012:         }
 40354:     } while (tokenStream.matchToken(TOK_COMMA));
     1: 
 27012:     pn->pn_pos.end = pn->last()->pn_pos.end;
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::expr()
     1: {
 80631:     ParseNode *pn = assignExpr();
 40354:     if (pn && tokenStream.matchToken(TOK_COMMA)) {
 98181:         ParseNode *pn2 = ListNode::create(PNK_COMMA, this);
     1:         if (!pn2)
     1:             return NULL;
     1:         pn2->pn_pos.begin = pn->pn_pos.begin;
 27012:         pn2->initList(pn);
     1:         pn = pn2;
     1:         do {
     1: #if JS_HAS_GENERATORS
 27012:             pn2 = pn->last();
 82024:             if (pn2->isKind(PNK_YIELD) && !pn2->isInParens()) {
102849:                 reportError(pn2, JSMSG_BAD_GENERATOR_SYNTAX, js_yield_str);
     1:                 return NULL;
     1:             }
     1: #endif
 40263:             pn2 = assignExpr();
     1:             if (!pn2)
     1:                 return NULL;
 27012:             pn->append(pn2);
 40354:         } while (tokenStream.matchToken(TOK_COMMA));
 27012:         pn->pn_pos.end = pn->last()->pn_pos.end;
     1:     }
     1:     return pn;
     1: }
     1: 
 64367: /*
 64367:  * For a number of the expression parsers we define an always-inlined version
 64367:  * and a never-inlined version (which just calls the always-inlined version).
 64367:  * Using the always-inlined version in the hot call-sites givs a ~5% parsing
 64367:  * speedup.  These macros help avoid some boilerplate code.
 64367:  */
 64367: #define BEGIN_EXPR_PARSER(name)                                               \
 80631:     JS_ALWAYS_INLINE ParseNode *                                              \
 64367:     Parser::name##i()
 64367: 
 64367: #define END_EXPR_PARSER(name)                                                 \
 80631:     JS_NEVER_INLINE ParseNode *                                               \
 64367:     Parser::name##n() {                                                       \
 64367:         return name##i();                                                     \
 64367:     }
 64367: 
 64367: BEGIN_EXPR_PARSER(mulExpr1)
 64367: {
 80631:     ParseNode *pn = unaryExpr();
 64367: 
 64367:     /*
 64367:      * Note: unlike addExpr1() et al, we use getToken() here instead of
 64367:      * isCurrentTokenType() because unaryExpr() doesn't leave the TokenStream
 64367:      * state one past the end of the unary expression.
 64367:      */
 82024:     TokenKind tt;
 82021:     while (pn && ((tt = tokenStream.getToken()) == TOK_STAR || tt == TOK_DIV || tt == TOK_MOD)) {
 82024:         ParseNodeKind kind = (tt == TOK_STAR)
 82024:                              ? PNK_STAR
 82024:                              : (tt == TOK_DIV)
 82024:                              ? PNK_DIV
 82024:                              : PNK_MOD;
 64367:         JSOp op = tokenStream.currentToken().t_op;
 98181:         pn = ParseNode::newBinaryOrAppend(kind, op, pn, unaryExpr(), this);
 64367:     }
     1:     return pn;
     1: }
 64367: END_EXPR_PARSER(mulExpr1)
 64367: 
 64367: BEGIN_EXPR_PARSER(addExpr1)
 64367: {
 80631:     ParseNode *pn = mulExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_PLUS, TOK_MINUS)) {
 64367:         TokenKind tt = tokenStream.currentToken().type;
 64367:         JSOp op = (tt == TOK_PLUS) ? JSOP_ADD : JSOP_SUB;
 82870:         ParseNodeKind kind = (tt == TOK_PLUS) ? PNK_ADD : PNK_SUB;
 98181:         pn = ParseNode::newBinaryOrAppend(kind, op, pn, mulExpr1n(), this);
 64367:     }
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(addExpr1)
 64367: 
 82024: inline ParseNodeKind
 82024: ShiftTokenToParseNodeKind(const Token &token)
 82024: {
 82024:     switch (token.type) {
 82024:       case TOK_LSH:
 82024:         return PNK_LSH;
 82024:       case TOK_RSH:
 82024:         return PNK_RSH;
 82024:       default:
 82024:         JS_ASSERT(token.type == TOK_URSH);
 82024:         return PNK_URSH;
 82024:     }
 82024: }
 82024: 
 64367: BEGIN_EXPR_PARSER(shiftExpr1)
 64367: {
 82020:     ParseNode *left = addExpr1i();
 82020:     while (left && tokenStream.isCurrentTokenShift()) {
 82024:         ParseNodeKind kind = ShiftTokenToParseNodeKind(tokenStream.currentToken());
 42671:         JSOp op = tokenStream.currentToken().t_op;
 82020:         ParseNode *right = addExpr1n();
 82020:         if (!right)
 82020:             return NULL;
 98181:         left = new_<BinaryNode>(kind, op, left, right);
 82020:     }
 82020:     return left;
 64367: }
 64367: END_EXPR_PARSER(shiftExpr1)
 64367: 
 82024: inline ParseNodeKind
 82024: RelationalTokenToParseNodeKind(const Token &token)
 82024: {
 82024:     switch (token.type) {
 82024:       case TOK_IN:
 82024:         return PNK_IN;
 82024:       case TOK_INSTANCEOF:
 82024:         return PNK_INSTANCEOF;
 82024:       case TOK_LT:
 82024:         return PNK_LT;
 82024:       case TOK_LE:
 82024:         return PNK_LE;
 82024:       case TOK_GT:
 82024:         return PNK_GT;
 82024:       default:
 82024:         JS_ASSERT(token.type == TOK_GE);
 82024:         return PNK_GE;
 82024:     }
 82024: }
 82024: 
 64367: BEGIN_EXPR_PARSER(relExpr1)
 64367: {
 64367:     /*
 64367:      * Uses of the in operator in shiftExprs are always unambiguous,
 64367:      * so unset the flag that prohibits recognizing it.
 64367:      */
109503:     bool oldParsingForInit = pc->parsingForInit;
109503:     pc->parsingForInit = false;
 64367: 
 80631:     ParseNode *pn = shiftExpr1i();
 64367:     while (pn &&
 82019:            (tokenStream.isCurrentTokenRelational() ||
 64367:             /*
 64367:              * Recognize the 'in' token as an operator only if we're not
 64367:              * currently in the init expr of a for loop.
 64367:              */
109503:             (oldParsingForInit == 0 && tokenStream.isCurrentTokenType(TOK_IN)) ||
 64367:             tokenStream.isCurrentTokenType(TOK_INSTANCEOF))) {
 82024:         ParseNodeKind kind = RelationalTokenToParseNodeKind(tokenStream.currentToken());
 64367:         JSOp op = tokenStream.currentToken().t_op;
 98181:         pn = ParseNode::newBinaryOrAppend(kind, op, pn, shiftExpr1n(), this);
 64367:     }
109503:     /* Restore previous state of parsingForInit flag. */
109503:     pc->parsingForInit |= oldParsingForInit;
 64367: 
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(relExpr1)
 64367: 
 82024: inline ParseNodeKind
 82024: EqualityTokenToParseNodeKind(const Token &token)
 82024: {
 82024:     switch (token.type) {
 82024:       case TOK_STRICTEQ:
 82024:         return PNK_STRICTEQ;
 82024:       case TOK_EQ:
 82024:         return PNK_EQ;
 82024:       case TOK_STRICTNE:
 82024:         return PNK_STRICTNE;
 82024:       default:
 82024:         JS_ASSERT(token.type == TOK_NE);
 82024:         return PNK_NE;
 82024:     }
 82024: }
 82024: 
 64367: BEGIN_EXPR_PARSER(eqExpr1)
 64367: {
 82015:     ParseNode *left = relExpr1i();
 82015:     while (left && tokenStream.isCurrentTokenEquality()) {
 82024:         ParseNodeKind kind = EqualityTokenToParseNodeKind(tokenStream.currentToken());
 64367:         JSOp op = tokenStream.currentToken().t_op;
 82015:         ParseNode *right = relExpr1n();
 82015:         if (!right)
 82015:             return NULL;
 98181:         left = new_<BinaryNode>(kind, op, left, right);
 82015:     }
 82015:     return left;
 64367: }
 64367: END_EXPR_PARSER(eqExpr1)
 64367: 
 64367: BEGIN_EXPR_PARSER(bitAndExpr1)
 64367: {
 80631:     ParseNode *pn = eqExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITAND))
 98181:         pn = ParseNode::newBinaryOrAppend(PNK_BITAND, JSOP_BITAND, pn, eqExpr1n(), this);
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(bitAndExpr1)
 64367: 
 64367: BEGIN_EXPR_PARSER(bitXorExpr1)
 64367: {
 80631:     ParseNode *pn = bitAndExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITXOR))
 98181:         pn = ParseNode::newBinaryOrAppend(PNK_BITXOR, JSOP_BITXOR, pn, bitAndExpr1n(), this);
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(bitXorExpr1)
 64367: 
 64367: BEGIN_EXPR_PARSER(bitOrExpr1)
 64367: {
 80631:     ParseNode *pn = bitXorExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITOR))
 98181:         pn = ParseNode::newBinaryOrAppend(PNK_BITOR, JSOP_BITOR, pn, bitXorExpr1n(), this);
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(bitOrExpr1)
 64367: 
 64367: BEGIN_EXPR_PARSER(andExpr1)
 64367: {
 80631:     ParseNode *pn = bitOrExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_AND))
 98181:         pn = ParseNode::newBinaryOrAppend(PNK_AND, JSOP_AND, pn, bitOrExpr1n(), this);
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(andExpr1)
 64367: 
 80631: JS_ALWAYS_INLINE ParseNode *
 64367: Parser::orExpr1()
 64367: {
 80631:     ParseNode *pn = andExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_OR))
 98181:         pn = ParseNode::newBinaryOrAppend(PNK_OR, JSOP_OR, pn, andExpr1n(), this);
 64367:     return pn;
 64367: }
 64367: 
 80631: JS_ALWAYS_INLINE ParseNode *
 64366: Parser::condExpr1()
 64366: {
 86379:     ParseNode *condition = orExpr1();
 86379:     if (!condition || !tokenStream.isCurrentTokenType(TOK_HOOK))
 86379:         return condition;
 40327: 
     1:     /*
     1:      * Always accept the 'in' operator in the middle clause of a ternary,
     1:      * where it's unambiguous, even if we might be parsing the init of a
     1:      * for statement.
     1:      */
109503:     bool oldParsingForInit = pc->parsingForInit;
109503:     pc->parsingForInit = false;
 86379:     ParseNode *thenExpr = assignExpr();
109503:     pc->parsingForInit = oldParsingForInit;
 86379:     if (!thenExpr)
 86379:         return NULL;
 86379: 
     1:     MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_IN_COND);
 86379: 
 86379:     ParseNode *elseExpr = assignExpr();
 86379:     if (!elseExpr)
 86379:         return NULL;
 86379: 
 86379:     tokenStream.getToken(); /* read one token past the end */
 86379:     return new_<ConditionalExpression>(condition, thenExpr, elseExpr);
     1: }
     1: 
 74052: bool
 80631: Parser::setAssignmentLhsOps(ParseNode *pn, JSOp op)
 74052: {
 78294:     switch (pn->getKind()) {
 82024:       case PNK_NAME:
 98181:         if (!CheckStrictAssignment(context, this, pn))
 74052:             return false;
 78294:         pn->setOp(pn->isOp(JSOP_GETLOCAL) ? JSOP_SETLOCAL : JSOP_SETNAME);
108876:         NoteLValue(context, pn, pc->sc);
 74052:         break;
 82024:       case PNK_DOT:
 78294:         pn->setOp(JSOP_SETPROP);
 74052:         break;
 82024:       case PNK_LB:
 78294:         pn->setOp(JSOP_SETELEM);
 74052:         break;
 74052: #if JS_HAS_DESTRUCTURING
 82024:       case PNK_RB:
 82024:       case PNK_RC:
 74052:         if (op != JSOP_NOP) {
102849:             reportError(NULL, JSMSG_BAD_DESTRUCT_ASS);
 74052:             return false;
 74052:         }
 98181:         if (!CheckDestructuring(context, NULL, pn, this))
 74052:             return false;
 74052:         break;
 74052: #endif
 82024:       case PNK_LP:
 98181:         if (!MakeSetCall(context, pn, this, JSMSG_BAD_LEFTSIDE_OF_ASS))
 74052:             return false;
 74052:         break;
 74052: #if JS_HAS_XML_SUPPORT
 82114:       case PNK_XMLUNARY:
 82018:         JS_ASSERT(pn->isOp(JSOP_XMLNAME));
 78294:         pn->setOp(JSOP_SETXMLNAME);
 74052:         break;
 74052: #endif
 74052:       default:
102849:         reportError(NULL, JSMSG_BAD_LEFTSIDE_OF_ASS);
 74052:         return false;
 74052:     }
 74052:     return true;
 74052: }
 74052: 
 80631: ParseNode *
 64367: Parser::assignExpr()
 64367: {
 64367:     JS_CHECK_RECURSION(context, return NULL);
 64367: 
 64367: #if JS_HAS_GENERATORS
 64367:     if (tokenStream.matchToken(TOK_YIELD, TSF_OPERAND))
 64367:         return returnOrYield(true);
 64367: #endif
 64367: 
 82024:     ParseNode *lhs = condExpr1();
 82024:     if (!lhs)
 82024:         return NULL;
 82024: 
 82024:     ParseNodeKind kind;
 82024:     switch (tokenStream.currentToken().type) {
 82024:       case TOK_ASSIGN:       kind = PNK_ASSIGN;       break;
 82024:       case TOK_ADDASSIGN:    kind = PNK_ADDASSIGN;    break;
 82024:       case TOK_SUBASSIGN:    kind = PNK_SUBASSIGN;    break;
 82024:       case TOK_BITORASSIGN:  kind = PNK_BITORASSIGN;  break;
 82024:       case TOK_BITXORASSIGN: kind = PNK_BITXORASSIGN; break;
 82024:       case TOK_BITANDASSIGN: kind = PNK_BITANDASSIGN; break;
 82024:       case TOK_LSHASSIGN:    kind = PNK_LSHASSIGN;    break;
 82024:       case TOK_RSHASSIGN:    kind = PNK_RSHASSIGN;    break;
 82024:       case TOK_URSHASSIGN:   kind = PNK_URSHASSIGN;   break;
 82024:       case TOK_MULASSIGN:    kind = PNK_MULASSIGN;    break;
 82024:       case TOK_DIVASSIGN:    kind = PNK_DIVASSIGN;    break;
 82024:       case TOK_MODASSIGN:    kind = PNK_MODASSIGN;    break;
 82024:       default:
 82024:         JS_ASSERT(!tokenStream.isCurrentTokenAssignment());
 64367:         tokenStream.ungetToken();
 82024:         return lhs;
 82024:     }
 82024: 
 42671:     JSOp op = tokenStream.currentToken().t_op;
 82024:     if (!setAssignmentLhsOps(lhs, op))
 74052:         return NULL;
 74052: 
 80631:     ParseNode *rhs = assignExpr();
 74052:     if (!rhs)
 74052:         return NULL;
 64367: 
 98181:     return ParseNode::newBinaryOrAppend(kind, op, lhs, rhs, this);
 80631: }
 80631: 
 86266: static bool
 98181: SetLvalKid(JSContext *cx, Parser *parser, ParseNode *pn, ParseNode *kid,
 80631:            const char *name)
     1: {
 82024:     if (!kid->isKind(PNK_NAME) &&
 82024:         !kid->isKind(PNK_DOT) &&
 82024:         (!kid->isKind(PNK_LP) ||
 78294:          (!kid->isOp(JSOP_CALL) && !kid->isOp(JSOP_EVAL) &&
 78294:           !kid->isOp(JSOP_FUNCALL) && !kid->isOp(JSOP_FUNAPPLY))) &&
     1: #if JS_HAS_XML_SUPPORT
 82114:         !kid->isKind(PNK_XMLUNARY) &&
     1: #endif
 82024:         !kid->isKind(PNK_LB))
 82018:     {
102849:         parser->reportError(NULL, JSMSG_BAD_OPERAND, name);
 86266:         return false;
     1:     }
 98181:     if (!CheckStrictAssignment(cx, parser, kid))
 86266:         return false;
     1:     pn->pn_kid = kid;
 86266:     return true;
     1: }
     1: 
     1: static const char incop_name_str[][10] = {"increment", "decrement"};
     1: 
103824: static bool
 98181: SetIncOpKid(JSContext *cx, Parser *parser, ParseNode *pn, ParseNode *kid,
 86266:             TokenKind tt, bool preorder)
     1: {
     1:     JSOp op;
     1: 
 98181:     if (!SetLvalKid(cx, parser, pn, kid, incop_name_str[tt == TOK_DEC]))
 86266:         return false;
 78294:     switch (kid->getKind()) {
 82024:       case PNK_NAME:
     1:         op = (tt == TOK_INC)
     1:              ? (preorder ? JSOP_INCNAME : JSOP_NAMEINC)
     1:              : (preorder ? JSOP_DECNAME : JSOP_NAMEDEC);
108876:         NoteLValue(cx, kid, parser->pc->sc);
     1:         break;
     1: 
 82024:       case PNK_DOT:
     1:         op = (tt == TOK_INC)
     1:              ? (preorder ? JSOP_INCPROP : JSOP_PROPINC)
     1:              : (preorder ? JSOP_DECPROP : JSOP_PROPDEC);
     1:         break;
     1: 
 82024:       case PNK_LP:
 98181:         if (!MakeSetCall(cx, kid, parser, JSMSG_BAD_INCOP_OPERAND))
103823:             return false;
     1:         /* FALL THROUGH */
     1: #if JS_HAS_XML_SUPPORT
 82114:       case PNK_XMLUNARY:
 78294:         if (kid->isOp(JSOP_XMLNAME))
 78294:             kid->setOp(JSOP_SETXMLNAME);
     1:         /* FALL THROUGH */
     1: #endif
 82024:       case PNK_LB:
     1:         op = (tt == TOK_INC)
     1:              ? (preorder ? JSOP_INCELEM : JSOP_ELEMINC)
     1:              : (preorder ? JSOP_DECELEM : JSOP_ELEMDEC);
     1:         break;
     1: 
     1:       default:
     1:         JS_ASSERT(0);
     1:         op = JSOP_NOP;
     1:     }
 78294:     pn->setOp(op);
103823:     return true;
     1: }
     1: 
 80631: ParseNode *
 82024: Parser::unaryOpExpr(ParseNodeKind kind, JSOp op)
 82024: {
 82024:     TokenPtr begin = tokenStream.currentToken().pos.begin;
 82024:     ParseNode *kid = unaryExpr();
 82024:     if (!kid)
 82024:         return NULL;
 82024:     return new_<UnaryNode>(kind, op, TokenPos::make(begin, kid->pn_pos.end), kid);
 82024: }
 82024: 
 82024: ParseNode *
 40860: Parser::unaryExpr()
 40221: {
 80631:     ParseNode *pn, *pn2;
     1: 
 40239:     JS_CHECK_RECURSION(context, return NULL);
 40239: 
 82024:     switch (TokenKind tt = tokenStream.getToken(TSF_OPERAND)) {
 82018:       case TOK_TYPEOF:
 82024:         return unaryOpExpr(PNK_TYPEOF, JSOP_TYPEOF);
 82018:       case TOK_VOID:
 82024:         return unaryOpExpr(PNK_VOID, JSOP_VOID);
 82018:       case TOK_NOT:
 82024:         return unaryOpExpr(PNK_NOT, JSOP_NOT);
 82018:       case TOK_BITNOT:
 82024:         return unaryOpExpr(PNK_BITNOT, JSOP_BITNOT);
     1:       case TOK_PLUS:
 82870:         return unaryOpExpr(PNK_POS, JSOP_POS);
     1:       case TOK_MINUS:
 82870:         return unaryOpExpr(PNK_NEG, JSOP_NEG);
     1: 
     1:       case TOK_INC:
     1:       case TOK_DEC:
 98181:         pn = UnaryNode::create((tt == TOK_INC) ? PNK_PREINCREMENT : PNK_PREDECREMENT, this);
     1:         if (!pn)
     1:             return NULL;
103823:         pn2 = memberExpr(true);
     1:         if (!pn2)
     1:             return NULL;
 98181:         if (!SetIncOpKid(context, this, pn, pn2, tt, true))
     1:             return NULL;
     1:         pn->pn_pos.end = pn2->pn_pos.end;
     1:         break;
     1: 
     1:       case TOK_DELETE:
 41983:       {
 98181:         pn = UnaryNode::create(PNK_DELETE, this);
     1:         if (!pn)
     1:             return NULL;
 40263:         pn2 = unaryExpr();
     1:         if (!pn2)
     1:             return NULL;
     1:         pn->pn_pos.end = pn2->pn_pos.end;
     1: 
     1:         /*
     1:          * Under ECMA3, deleting any unary expression is valid -- it simply
 31479:          * returns true. Here we fold constants before checking for a call
 31479:          * expression, in order to rule out delete of a generator expression.
 31479:          */
 98181:         if (foldConstants && !FoldConstants(context, pn2, this))
  1962:             return NULL;
 78294:         switch (pn2->getKind()) {
 82024:           case PNK_LP:
 57742:             if (!(pn2->pn_xflags & PNX_SETCALL)) {
 57742:                 /*
 57742:                  * Call MakeSetCall to check for errors, but clear PNX_SETCALL
 57742:                  * because the optimizer will eliminate the useless delete.
 57742:                  */
 98181:                 if (!MakeSetCall(context, pn2, this, JSMSG_BAD_DELETE_OPERAND))
 57742:                     return NULL;
 57742:                 pn2->pn_xflags &= ~PNX_SETCALL;
  1577:             }
 27012:             break;
 82024:           case PNK_NAME:
102849:             if (!reportStrictModeError(pn, JSMSG_DEPRECATED_DELETE_OPERAND))
102849:                 return NULL;
108876:             pc->sc->setBindingsAccessedDynamically();
106177:             pn2->pn_dflags |= PND_DEOPTIMIZED;
 78294:             pn2->setOp(JSOP_DELNAME);
 27012:             break;
 27012:           default:;
 27012:         }
     1:         pn->pn_kid = pn2;
     1:         break;
 41983:       }
     1:       case TOK_ERROR:
     1:         return NULL;
     1: 
     1:       default:
 40354:         tokenStream.ungetToken();
103823:         pn = memberExpr(true);
     1:         if (!pn)
     1:             return NULL;
     1: 
     1:         /* Don't look across a newline boundary for a postfix incop. */
 40270:         if (tokenStream.onCurrentLine(pn->pn_pos)) {
 40854:             tt = tokenStream.peekTokenSameLine(TSF_OPERAND);
     1:             if (tt == TOK_INC || tt == TOK_DEC) {
 86266:                 tokenStream.consumeKnownToken(tt);
 98181:                 pn2 = UnaryNode::create((tt == TOK_INC) ? PNK_POSTINCREMENT : PNK_POSTDECREMENT, this);
     1:                 if (!pn2)
     1:                     return NULL;
 98181:                 if (!SetIncOpKid(context, this, pn2, pn, tt, false))
     1:                     return NULL;
     1:                 pn2->pn_pos.begin = pn->pn_pos.begin;
     1:                 pn = pn2;
     1:             }
     1:         }
     1:         break;
     1:     }
     1:     return pn;
     1: }
     1: 
  1577: #if JS_HAS_GENERATORS
  1577: 
  1577: /*
 27012:  * A dedicated helper for transplanting the comprehension expression E in
 27012:  *
 27012:  *   [E for (V in I)]   // array comprehension
 27012:  *   (E for (V in I))   // generator expression
 27012:  *
 27012:  * from its initial location in the AST, on the left of the 'for', to its final
 27012:  * position on the right. To avoid a separate pass we do this by adjusting the
 27012:  * blockids and name binding links that were established when E was parsed.
 27012:  *
 27012:  * A generator expression desugars like so:
 27012:  *
 27012:  *   (E for (V in I)) => (function () { for (var V in I) yield E; })()
 27012:  *
 27012:  * so the transplanter must adjust static level as well as blockid. E's source
 27012:  * coordinates in root->pn_pos are critical to deciding which binding links to
 27012:  * preserve and which to cut.
 27012:  *
 27012:  * NB: This is not a general tree transplanter -- it knows in particular that
 27012:  * the one or more bindings induced by V have not yet been created.
 27012:  */
 27012: class CompExprTransplanter {
 80631:     ParseNode       *root;
 98181:     Parser          *parser;
 27012:     bool            genexp;
 91237:     unsigned        adjust;
 91237:     unsigned        funcLevel;
104373:     HashSet<Definition *> visitedImplicitArguments;
 27012: 
 27012:   public:
 98181:     CompExprTransplanter(ParseNode *pn, Parser *parser, bool ge, unsigned adj)
104373:       : root(pn), parser(parser), genexp(ge), adjust(adj), funcLevel(0),
104373:         visitedImplicitArguments(parser->context)
104373:     {}
104373: 
104373:     bool init() {
104373:         return visitedImplicitArguments.init();
 27012:     }
 27012: 
 80631:     bool transplant(ParseNode *pn);
 27012: };
 27012: 
 27012: /*
 72073:  * A helper for lazily checking for the presence of illegal |yield| or |arguments|
 73053:  * tokens inside of generator expressions. This must be done lazily since we don't
 73053:  * know whether we're in a generator expression until we see the "for" token after
 73053:  * we've already parsed the body expression.
 73053:  *
 73053:  * Use in any context which may turn out to be inside a generator expression. This
 73053:  * includes parenthesized expressions and argument lists, and it includes the tail
 73053:  * of generator expressions.
 73053:  *
 73053:  * The guard will keep track of any |yield| or |arguments| tokens that occur while
 73053:  * parsing the body. As soon as the parser reaches the end of the body expression,
 73053:  * call endBody() to reset the context's state, and then immediately call:
 73053:  *
 73057:  * - checkValidBody() if this *did* turn out to be a generator expression
 73057:  * - maybeNoteGenerator() if this *did not* turn out to be a generator expression
 72073:  */
 72073: class GenexpGuard {
 98181:     Parser          *parser;
 84755:     uint32_t        startYieldCount;
 72073: 
 72073:   public:
 98181:     explicit GenexpGuard(Parser *parser)
 98181:       : parser(parser)
 98181:     {
108876:         ParseContext *pc = parser->pc;
108876:         if (pc->parenDepth == 0) {
108876:             pc->yieldCount = 0;
108876:             pc->yieldNode = NULL;
108876:         }
108876:         startYieldCount = pc->yieldCount;
108876:         pc->parenDepth++;
 72073:     }
 72073: 
 72073:     void endBody();
 99552:     bool checkValidBody(ParseNode *pn, unsigned err);
 80631:     bool maybeNoteGenerator(ParseNode *pn);
 72073: };
 72073: 
 72073: void
 72073: GenexpGuard::endBody()
 72073: {
108876:     parser->pc->parenDepth--;
 72073: }
 72073: 
 73053: /*
 73053:  * Check whether a |yield| or |arguments| token has been encountered in the
 73053:  * body expression, and if so, report an error.
 73053:  *
 73053:  * Call this after endBody() when determining that the body *was* in a
 73053:  * generator expression.
 73053:  */
 72073: bool
 99552: GenexpGuard::checkValidBody(ParseNode *pn, unsigned err = JSMSG_BAD_GENEXP_BODY)
 72073: {
108876:     ParseContext *pc = parser->pc;
108876:     if (pc->yieldCount > startYieldCount) {
108876:         ParseNode *errorNode = pc->yieldNode;
 72073:         if (!errorNode)
 72073:             errorNode = pn;
102849:         parser->reportError(errorNode, err, js_yield_str);
 72073:         return false;
 72073:     }
 72073: 
 72073:     return true;
 72073: }
 72073: 
 72073: /*
 73053:  * Check whether a |yield| token has been encountered in the body expression,
 73053:  * and if so, note that the current function is a generator function.
 73053:  *
 73053:  * Call this after endBody() when determining that the body *was not* in a
 73053:  * generator expression.
 73053:  */
 73053: bool
 80631: GenexpGuard::maybeNoteGenerator(ParseNode *pn)
 73053: {
108876:     ParseContext *pc = parser->pc;
108876:     if (pc->yieldCount > 0) {
108876:         pc->sc->setFunIsGenerator();
108876:         if (!pc->sc->inFunction()) {
102849:             parser->reportError(NULL, JSMSG_BAD_RETURN_OR_YIELD, js_yield_str);
 73053:             return false;
 73053:         }
109503:         if (pc->funHasReturnExpr) {
 98687:             /* At the time we saw the yield, we might not have set funIsGenerator yet. */
108876:             ReportBadReturn(pc->sc->context, parser, pn, &Parser::reportError,
102849:                             JSMSG_BAD_GENERATOR_RETURN, JSMSG_BAD_ANON_GENERATOR_RETURN);
 78006:             return false;
 78006:         }
 73053:     }
 73053:     return true;
 73053: }
 73053: 
 73053: /*
 27012:  * Any definitions nested within the comprehension expression of a generator
 27012:  * expression must move "down" one static level, which of course increases the
 27012:  * upvar-frame-skip count.
 27012:  */
 28814: static bool
108876: BumpStaticLevel(ParseNode *pn, ParseContext *pc)
 27012: {
101616:     if (pn->pn_cookie.isFree())
101616:         return true;
101616: 
101616:     unsigned level = unsigned(pn->pn_cookie.level()) + 1;
108876:     JS_ASSERT(level >= pc->staticLevel);
108876:     return pn->pn_cookie.set(pc->sc->context, level, pn->pn_cookie.slot());
 27012: }
 27012: 
104408: static bool
108876: AdjustBlockId(ParseNode *pn, unsigned adjust, ParseContext *pc)
 28122: {
 78294:     JS_ASSERT(pn->isArity(PN_LIST) || pn->isArity(PN_FUNC) || pn->isArity(PN_NAME));
104408:     if (JS_BIT(20) - pn->pn_blockid <= adjust + 1) {
108876:         JS_ReportErrorNumber(pc->sc->context, js_GetErrorMessage, NULL, JSMSG_NEED_DIET, "program");
104408:         return false;
104408:     }
 28122:     pn->pn_blockid += adjust;
108876:     if (pn->pn_blockid >= pc->blockidGen)
108876:         pc->blockidGen = pn->pn_blockid + 1;
104408:     return true;
 28122: }
 28122: 
 27012: bool
 80631: CompExprTransplanter::transplant(ParseNode *pn)
 27012: {
108876:     ParseContext *pc = parser->pc;
 98181: 
 27012:     if (!pn)
 27012:         return true;
 27012: 
 78294:     switch (pn->getArity()) {
 27012:       case PN_LIST:
 80631:         for (ParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
 61059:             if (!transplant(pn2))
 61059:                 return false;
 61059:         }
104408:         if (pn->pn_pos >= root->pn_pos) {
108876:             if (!AdjustBlockId(pn, adjust, pc))
104408:                 return false;
104408:         }
 27012:         break;
 27012: 
 27012:       case PN_TERNARY:
 61059:         if (!transplant(pn->pn_kid1) ||
 61059:             !transplant(pn->pn_kid2) ||
 61059:             !transplant(pn->pn_kid3))
 61059:             return false;
 27012:         break;
 27012: 
 27012:       case PN_BINARY:
 61059:         if (!transplant(pn->pn_left))
 61059:             return false;
 28354: 
 28354:         /* Binary TOK_COLON nodes can have left == right. See bug 492714. */
 61059:         if (pn->pn_right != pn->pn_left) {
 61059:             if (!transplant(pn->pn_right))
 61059:                 return false;
 61059:         }
 27012:         break;
 27012: 
 27012:       case PN_UNARY:
 61059:         if (!transplant(pn->pn_kid))
 61059:             return false;
 27012:         break;
 27012: 
 27012:       case PN_FUNC:
 27012:       {
 27012:         /*
 27012:          * Only the first level of transplant recursion through functions needs
 27012:          * to reparent the funbox, since all descendant functions are correctly
109499:          * linked under the top-most funbox.
 27012:          */
 80631:         FunctionBox *funbox = pn->pn_funbox;
 27012: 
 27012:         if (++funcLevel == 1 && genexp) {
108876:             FunctionBox *parent = pc->sc->funbox();
108876: 
108876:             FunctionBox **funboxp = &pc->parent->functionList;
 27012:             while (*funboxp != funbox)
 27012:                 funboxp = &(*funboxp)->siblings;
 27012:             *funboxp = funbox->siblings;
 27012: 
109602:             funbox->parent = parent;
 27012:             funbox->siblings = parent->kids;
 27012:             parent->kids = funbox;
 27012:         }
 27012:         /* FALL THROUGH */
 27012:       }
 27012: 
 27012:       case PN_NAME:
 61059:         if (!transplant(pn->maybeExpr()))
 61059:             return false;
 78294:         if (pn->isArity(PN_FUNC))
 27012:             --funcLevel;
 27012: 
 78294:         if (pn->isDefn()) {
108876:             if (genexp && !BumpStaticLevel(pn, pc))
 28814:                 return false;
 78294:         } else if (pn->isUsed()) {
 47573:             JS_ASSERT(pn->pn_cookie.isFree());
 27012: 
 80631:             Definition *dn = pn->pn_lexdef;
 78294:             JS_ASSERT(dn->isDefn());
 27012: 
 27012:             /*
 27012:              * Adjust the definition's block id only if it is a placeholder not
 27012:              * to the left of the root node, and if pn is the last use visited
 27012:              * in the comprehension expression (to avoid adjusting the blockid
 27012:              * multiple times).
 27012:              *
 27012:              * Non-placeholder definitions within the comprehension expression
 27012:              * will be visited further below.
 27012:              */
 27012:             if (dn->isPlaceholder() && dn->pn_pos >= root->pn_pos && dn->dn_uses == pn) {
108876:                 if (genexp && !BumpStaticLevel(dn, pc))
 28814:                     return false;
108876:                 if (!AdjustBlockId(dn, adjust, pc))
104408:                     return false;
 27012:             }
 27012: 
104205:             RootedAtom atom(parser->context, pn->pn_atom);
 27012: #ifdef DEBUG
108876:             StmtInfoPC *stmt = LexicalLookup(pc, atom, NULL, (StmtInfoPC *)NULL);
108876:             JS_ASSERT(!stmt || stmt != pc->topStmt);
 27012: #endif
 78294:             if (genexp && !dn->isOp(JSOP_CALLEE)) {
108876:                 JS_ASSERT(!pc->decls().lookupFirst(atom));
 27012: 
 73066:                 if (dn->pn_pos < root->pn_pos) {
 73066:                     /*
 73066:                      * The variable originally appeared to be a use of a
 73066:                      * definition or placeholder outside the generator, but now
 73066:                      * we know it is scoped within the comprehension tail's
 73066:                      * clauses. Make it (along with any other uses within the
 73066:                      * generator) a use of a new placeholder in the generator's
 73066:                      * lexdeps.
 73066:                      */
108876:                     Definition *dn2 = MakePlaceholder(pn, parser, parser->pc);
 27371:                     if (!dn2)
 28814:                         return false;
 61060:                     dn2->pn_pos = root->pn_pos;
 27371: 
 73066:                     /*
 73066:                      * Change all uses of |dn| that lie within the generator's
 73066:                      * |yield| expression into uses of dn2.
 73066:                      */
 80631:                     ParseNode **pnup = &dn->dn_uses;
 80631:                     ParseNode *pnu;
 27371:                     while ((pnu = *pnup) != NULL && pnu->pn_pos >= root->pn_pos) {
 27371:                         pnu->pn_lexdef = dn2;
 30457:                         dn2->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
 27371:                         pnup = &pnu->pn_link;
 27371:                     }
 27371:                     dn2->dn_uses = dn->dn_uses;
 27371:                     dn->dn_uses = *pnup;
 27371:                     *pnup = NULL;
108876:                     if (!pc->lexdeps->put(atom, dn2))
 73941:                         return false;
105488:                     if (dn->isClosed())
105488:                         dn2->pn_dflags |= PND_CLOSED;
 73066:                 } else if (dn->isPlaceholder()) {
 73066:                     /*
 73066:                      * The variable first occurs free in the 'yield' expression;
 73066:                      * move the existing placeholder node (and all its uses)
 73066:                      * from the parent's lexdeps into the generator's lexdeps.
 73066:                      */
108876:                     pc->parent->lexdeps->remove(atom);
108876:                     if (!pc->lexdeps->put(atom, dn))
 72579:                         return false;
104373:                 } else if (dn->isImplicitArguments()) {
104373:                     /*
104373:                      * Implicit 'arguments' Definition nodes (see
104373:                      * PND_IMPLICITARGUMENTS in Parser::functionBody) are only
104373:                      * reachable via the lexdefs of their uses. Unfortunately,
104373:                      * there may be multiple uses, so we need to maintain a set
104373:                      * to only bump the definition once.
104373:                      */
104373:                     if (genexp && !visitedImplicitArguments.has(dn)) {
108876:                         if (!BumpStaticLevel(dn, pc))
104373:                             return false;
108876:                         if (!AdjustBlockId(dn, adjust, pc))
104408:                             return false;
104373:                         if (!visitedImplicitArguments.put(dn))
104373:                             return false;
104373:                     }
 27012:                 }
 27012:             }
 27012:         }
 27012: 
104408:         if (pn->pn_pos >= root->pn_pos) {
108876:             if (!AdjustBlockId(pn, adjust, pc))
104408:                 return false;
104408:         }
 27012:         break;
 27012: 
 78296:       case PN_NULLARY:
 78296:         /* Nothing. */
 78296:         break;
 27012:     }
 27012:     return true;
 27012: }
 27012: 
 27012: /*
  1577:  * Starting from a |for| keyword after the first array initialiser element or
  1577:  * an expression in an open parenthesis, parse the tail of the comprehension
  1577:  * or generator expression signified by this |for| keyword in context.
  1577:  *
  1577:  * Return null on failure, else return the top-most parse node for the array
  1577:  * comprehension or generator expression, with a unary node as the body of the
 82024:  * (possibly nested) for-loop, initialized by |kind, op, kid|.
  1577:  */
 80631: ParseNode *
 91237: Parser::comprehensionTail(ParseNode *kid, unsigned blockid, bool isGenexp,
 82024:                           ParseNodeKind kind, JSOp op)
 40239: {
 91237:     unsigned adjust;
 80631:     ParseNode *pn, *pn2, *pn3, **pnp;
108876:     StmtInfoPC stmtInfo(context);
 97353:     BindData data(context);
 40320:     TokenKind tt;
  1577: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_FOR);
  1577: 
 82024:     if (kind == PNK_SEMI) {
 27012:         /*
 27012:          * Generator expression desugars to an immediately applied lambda that
 27012:          * yields the next value from a for-in loop (possibly nested, and with
 27012:          * optional if guard). Make pn be the TOK_LC body node.
  1577:          */
 98181:         pn = PushLexicalScope(context, this, &stmtInfo);
  1577:         if (!pn)
  1577:             return NULL;
 27012:         adjust = pn->pn_blockid - blockid;
 27012:     } else {
 82024:         JS_ASSERT(kind == PNK_ARRAYPUSH);
 27012: 
 27012:         /*
 27012:          * Make a parse-node and literal object representing the block scope of
 40239:          * this array comprehension. Our caller in primaryExpr, the TOK_LB case
 27012:          * aka the array initialiser case, has passed the blockid to claim for
 27012:          * the comprehension's block scope. We allocate that id or one above it
 80632:          * here, by calling PushLexicalScope.
 27012:          *
 27012:          * In the case of a comprehension expression that has nested blocks
 27012:          * (e.g., let expressions), we will allocate a higher blockid but then
 27012:          * slide all blocks "to the right" to make room for the comprehension's
 27012:          * block scope.
 27012:          */
108876:         adjust = pc->blockid();
 98181:         pn = PushLexicalScope(context, this, &stmtInfo);
 27012:         if (!pn)
 27012:             return NULL;
 27012: 
 27012:         JS_ASSERT(blockid <= pn->pn_blockid);
108876:         JS_ASSERT(blockid < pc->blockidGen);
108876:         JS_ASSERT(pc->bodyid < blockid);
 27012:         pn->pn_blockid = stmtInfo.blockid = blockid;
 27012:         JS_ASSERT(adjust < blockid);
 27012:         adjust = blockid - adjust;
 27012:     }
 27012: 
  1577:     pnp = &pn->pn_expr;
  1577: 
 98181:     CompExprTransplanter transplanter(kid, this, kind == PNK_SEMI, adjust);
104373:     if (!transplanter.init())
104373:         return NULL;
104373: 
104408:     if (!transplanter.transplant(kid))
105468:         return NULL;
 27012: 
108876:     JS_ASSERT(pc->blockChain && pc->blockChain == pn->pn_objbox->object);
108876:     data.initLet(HoistVars, *pc->blockChain, JSMSG_ARRAY_INIT_TOO_BIG);
 27012: 
  1577:     do {
  1577:         /*
  1577:          * FOR node is binary, left is loop control and right is body.  Use
  1577:          * index to count each block-local let-variable on the left-hand side
 89621:          * of the in/of.
  1577:          */
 98181:         pn2 = BinaryNode::create(PNK_FOR, this);
  1577:         if (!pn2)
  1577:             return NULL;
  1577: 
 78294:         pn2->setOp(JSOP_ITER);
 15613:         pn2->pn_iflags = JSITER_ENUMERATE;
 40354:         if (tokenStream.matchToken(TOK_NAME)) {
 80443:             if (tokenStream.currentToken().name() == context->runtime->atomState.eachAtom)
 15613:                 pn2->pn_iflags |= JSITER_FOREACH;
  1577:             else
 40354:                 tokenStream.ungetToken();
  1577:         }
  1577:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
  1577: 
 98181:         GenexpGuard guard(this);
 72073: 
 99421:         RootedPropertyName name(context);
 40354:         tt = tokenStream.getToken();
  1577:         switch (tt) {
  1577: #if JS_HAS_DESTRUCTURING
  1577:           case TOK_LB:
  1577:           case TOK_LC:
108876:             pc->inDeclDestructuring = true;
103823:             pn3 = primaryExpr(tt, false);
108876:             pc->inDeclDestructuring = false;
  1577:             if (!pn3)
  1577:                 return NULL;
  1577:             break;
  1577: #endif
  1577: 
  1577:           case TOK_NAME:
 80443:             name = tokenStream.currentToken().name();
  1577: 
  1577:             /*
  1577:              * Create a name node with pn_op JSOP_NAME.  We can't set pn_op to
  1577:              * JSOP_GETLOCAL here, because we don't yet know the block's depth
  1577:              * in the operand stack frame.  The code generator computes that,
  1577:              * and it tries to bind all names to slots, so we must let it do
  1577:              * the deed.
  1577:              */
 98181:             pn3 = NewBindingNode(name, this);
  1577:             if (!pn3)
  1577:                 return NULL;
  1577:             break;
  1577: 
  1577:           default:
102849:             reportError(NULL, JSMSG_NO_VARIABLE_NAME);
  1607: 
  1607:           case TOK_ERROR:
  1577:             return NULL;
  1577:         }
  1577: 
 89621:         bool forOf;
 89621:         if (!matchInOrOf(&forOf)) {
102849:             reportError(NULL, JSMSG_IN_AFTER_FOR_NAME);
 89621:             return NULL;
 89621:         }
 89621:         if (forOf) {
 89621:             if (pn2->pn_iflags != JSITER_ENUMERATE) {
 89621:                 JS_ASSERT(pn2->pn_iflags == (JSITER_FOREACH | JSITER_ENUMERATE));
102849:                 reportError(NULL, JSMSG_BAD_FOR_EACH_LOOP);
 89621:                 return NULL;
 89621:             }
 89621:             pn2->pn_iflags = JSITER_FOR_OF;
 89621:         }
 89621: 
 80631:         ParseNode *pn4 = expr();
 27012:         if (!pn4)
 27012:             return NULL;
  1577:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
 27012: 
 72073:         guard.endBody();
 72073: 
 73053:         if (isGenexp) {
 73053:             if (!guard.checkValidBody(pn2))
 73053:                 return NULL;
 74093:         } else {
 78006:             if (!guard.maybeNoteGenerator(pn2))
 73053:                 return NULL;
 73053:         }
 72073: 
 27012:         switch (tt) {
 27012: #if JS_HAS_DESTRUCTURING
 27012:           case TOK_LB:
 27012:           case TOK_LC:
 98181:             if (!CheckDestructuring(context, &data, pn3, this))
 40239:                 return NULL;
 40239: 
 61450:             if (versionNumber() == JSVERSION_1_7) {
 27012:                 /* Destructuring requires [key, value] enumeration in JS1.7. */
 82024:                 if (!pn3->isKind(PNK_RB) || pn3->pn_count != 2) {
102849:                     reportError(NULL, JSMSG_BAD_FOR_LEFTSIDE);
 27012:                     return NULL;
 27012:                 }
 27012: 
 78294:                 JS_ASSERT(pn2->isOp(JSOP_ITER));
 27012:                 JS_ASSERT(pn2->pn_iflags & JSITER_ENUMERATE);
 27012:                 if (!(pn2->pn_iflags & JSITER_FOREACH))
 27012:                     pn2->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
 27012:             }
 27012:             break;
 27012: #endif
 27012: 
 27012:           case TOK_NAME:
 27012:             data.pn = pn3;
 98181:             if (!data.binder(context, &data, name, this))
 27012:                 return NULL;
 27012:             break;
 27012: 
 27012:           default:;
 27012:         }
 27012: 
 74052:         /*
 74052:          * Synthesize a declaration. Every definition must appear in the parse
 74052:          * tree in order for ComprehensionTranslator to work.
 74052:          */
 98181:         ParseNode *vars = ListNode::create(PNK_VAR, this);
 74052:         if (!vars)
 74052:             return NULL;
 78294:         vars->setOp(JSOP_NOP);
 74052:         vars->pn_pos = pn3->pn_pos;
 74052:         vars->makeEmpty();
 74052:         vars->append(pn3);
 74052:         vars->pn_xflags |= PNX_FORINVAR;
 74052: 
 74052:         /* Definitions can't be passed directly to EmitAssignment as lhs. */
 98181:         pn3 = CloneLeftHandSide(pn3, this);
 74052:         if (!pn3)
 74052:             return NULL;
 74052: 
 82871:         pn2->pn_left = new_<TernaryNode>(PNK_FORIN, JSOP_NOP, vars, pn3, pn4);
 27012:         if (!pn2->pn_left)
 27012:             return NULL;
  1577:         *pnp = pn2;
  1577:         pnp = &pn2->pn_right;
 40354:     } while (tokenStream.matchToken(TOK_FOR));
 40354: 
 40354:     if (tokenStream.matchToken(TOK_IF)) {
 98181:         pn2 = TernaryNode::create(PNK_IF, this);
  1577:         if (!pn2)
  1577:             return NULL;
 40263:         pn2->pn_kid1 = condition();
  1577:         if (!pn2->pn_kid1)
  1577:             return NULL;
  1577:         *pnp = pn2;
  1577:         pnp = &pn2->pn_kid2;
  1577:     }
  1577: 
 98181:     pn2 = UnaryNode::create(kind, this);
  1577:     if (!pn2)
  1577:         return NULL;
 78294:     pn2->setOp(op);
  1577:     pn2->pn_kid = kid;
  1577:     *pnp = pn2;
  1577: 
108876:     PopStatementPC(context, pc);
  1577:     return pn;
  1577: }
  1577: 
  1577: #if JS_HAS_GENERATOR_EXPRS
  1577: 
  1577: /*
  1577:  * Starting from a |for| keyword after an expression, parse the comprehension
  1577:  * tail completing this generator expression. Wrap the expression at kid in a
  1577:  * generator function that is immediately called to evaluate to the generator
  1577:  * iterator that is the value of this generator expression.
  1577:  *
 61058:  * |kid| must be the expression before the |for| keyword; we return an
 61058:  * application of a generator function that includes the |for| loops and
 61058:  * |if| guards, with |kid| as the operand of a |yield| expression as the
 61058:  * innermost loop body.
  1577:  *
  1577:  * Note how unlike Python, we do not evaluate the expression to the right of
  1577:  * the first |in| in the chain of |for| heads. Instead, a generator expression
  1577:  * is merely sugar for a generator function expression and its application.
  1577:  */
 80631: ParseNode *
 80631: Parser::generatorExpr(ParseNode *kid)
 61058: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_FOR));
 82024: 
 61058:     /* Create a |yield| node for |kid|. */
 98181:     ParseNode *pn = UnaryNode::create(PNK_YIELD, this);
 61058:     if (!pn)
 61058:         return NULL;
 78294:     pn->setOp(JSOP_YIELD);
 78294:     pn->setInParens(true);
  1577:     pn->pn_pos = kid->pn_pos;
  1577:     pn->pn_kid = kid;
 31479:     pn->pn_hidden = true;
  1577: 
 27012:     /* Make a new node for the desugared generator function. */
 98181:     ParseNode *genfn = FunctionNode::create(PNK_FUNCTION, this);
 27012:     if (!genfn)
 27012:         return NULL;
 78294:     genfn->setOp(JSOP_LAMBDA);
 27012:     JS_ASSERT(!genfn->pn_body);
 94151:     genfn->pn_dflags = 0;
 27012: 
 27012:     {
108876:         ParseContext *outerpc = pc;
108876: 
108876:         RootedFunction fun(context, newFunction(outerpc, /* atom = */ NULL, Expression));
100230:         if (!fun)
100230:             return NULL;
100230: 
100230:         /* Create box for fun->object early to protect against last-ditch GC. */
109500:         FunctionBox *funbox = newFunctionBox(fun, outerpc, outerpc->sc->strictModeState);
100230:         if (!funbox)
100230:             return NULL;
100230: 
108876:         SharedContext gensc(context, /* scopeChain = */ NULL, fun, funbox, outerpc->sc->strictModeState);
108876:         ParseContext genpc(this, &gensc, outerpc->staticLevel + 1, outerpc->blockidGen);
108876:         if (!genpc.init())
108876:             return NULL;
108876: 
108876:         /*
108876:          * We assume conservatively that any deoptimization flags in pc->sc
 95100:          * come from the kid. So we propagate these flags into genfn. For code
 95100:          * simplicity we also do not detect if the flags were only set in the
108876:          * kid and could be removed from pc->sc.
108876:          */
108876:         gensc.cxFlags = outerpc->sc->cxFlags;
 98687:         gensc.setFunIsGenerator();
 98687: 
 98481:         funbox->inGenexpLambda = true;
 27012:         genfn->pn_funbox = funbox;
108876:         genfn->pn_blockid = genpc.bodyid;
108876: 
108876:         ParseNode *body = comprehensionTail(pn, outerpc->blockid(), true);
  1577:         if (!body)
  1577:             return NULL;
 27012:         JS_ASSERT(!genfn->pn_body);
 27012:         genfn->pn_body = body;
 27012:         genfn->pn_pos.begin = body->pn_pos.begin = kid->pn_pos.begin;
 40270:         genfn->pn_pos.end = body->pn_pos.end = tokenStream.currentToken().pos.end;
 40221: 
 98445:         JSAtom *arguments = gensc.context->runtime->atomState.argumentsAtom;
108876:         if (AtomDefnPtr p = genpc.lexdeps->lookup(arguments)) {
 95100:             Definition *dn = p.value();
 95100:             ParseNode *errorNode = dn->dn_uses ? dn->dn_uses : body;
102849:             reportError(errorNode, JSMSG_BAD_GENEXP_BODY, js_arguments_str);
 98181:             return NULL;
 98181:         }
 98181: 
 98181:         if (!LeaveFunction(genfn, this))
 27012:             return NULL;
 27012:     }
 27012: 
 27012:     /*
 27012:      * Our result is a call expression that invokes the anonymous generator
 27012:      * function object.
 27012:      */
 98181:     ParseNode *result = ListNode::create(PNK_LP, this);
 27012:     if (!result)
 27012:         return NULL;
 78294:     result->setOp(JSOP_CALL);
 27012:     result->pn_pos.begin = genfn->pn_pos.begin;
 27012:     result->initList(genfn);
 27012:     return result;
  1577: }
  1577: 
  1577: static const char js_generator_str[] = "generator";
  1577: 
  1577: #endif /* JS_HAS_GENERATOR_EXPRS */
  1577: #endif /* JS_HAS_GENERATORS */
  1577: 
 99552: ParseNode *
 99552: Parser::assignExprWithoutYield(unsigned msg)
 99552: {
 99552: #ifdef JS_HAS_GENERATORS
 99552:     GenexpGuard yieldGuard(this);
 99552: #endif
 99552:     ParseNode *res = assignExpr();
 99918:     yieldGuard.endBody();
 99552:     if (res) {
 99552: #ifdef JS_HAS_GENERATORS
 99552:         if (!yieldGuard.checkValidBody(res, msg)) {
 99552:             freeTree(res);
 99552:             res = NULL;
 99552:         }
 99552: #endif
 99552:     }
 99552:     return res;
 99552: }
 99552: 
103824: bool
 80631: Parser::argumentList(ParseNode *listNode)
     1: {
 40854:     if (tokenStream.matchToken(TOK_RP, TSF_OPERAND))
103823:         return true;
 40854: 
 98181:     GenexpGuard guard(this);
 72565:     bool arg0 = true;
 72073: 
     1:     do {
 80631:         ParseNode *argNode = assignExpr();
     1:         if (!argNode)
103823:             return false;
 73053:         if (arg0)
 72565:             guard.endBody();
 72565: 
     1: #if JS_HAS_GENERATORS
 82024:         if (argNode->isKind(PNK_YIELD) &&
 78294:             !argNode->isInParens() &&
 40354:             tokenStream.peekToken() == TOK_COMMA) {
102849:             reportError(argNode, JSMSG_BAD_GENERATOR_SYNTAX, js_yield_str);
103823:             return false;
     1:         }
     1: #endif
  1577: #if JS_HAS_GENERATOR_EXPRS
 40354:         if (tokenStream.matchToken(TOK_FOR)) {
 72073:             if (!guard.checkValidBody(argNode))
103823:                 return false;
 61058:             argNode = generatorExpr(argNode);
  1577:             if (!argNode)
103823:                 return false;
  1577:             if (listNode->pn_count > 1 ||
 40354:                 tokenStream.peekToken() == TOK_COMMA) {
102849:                 reportError(argNode, JSMSG_BAD_GENERATOR_SYNTAX, js_generator_str);
103823:                 return false;
  1577:             }
 73053:         } else
  1577: #endif
 78006:         if (arg0 && !guard.maybeNoteGenerator(argNode))
103823:             return false;
 73053: 
 73053:         arg0 = false;
 73053: 
 27012:         listNode->append(argNode);
 40354:     } while (tokenStream.matchToken(TOK_COMMA));
 40354: 
 40354:     if (tokenStream.getToken() != TOK_RP) {
102849:         reportError(NULL, JSMSG_PAREN_AFTER_ARGS);
103823:         return false;
103823:     }
103823:     return true;
     1: }
     1: 
 80631: ParseNode *
103824: Parser::memberExpr(bool allowCallSyntax)
     1: {
 86539:     ParseNode *lhs;
 40221: 
 40239:     JS_CHECK_RECURSION(context, return NULL);
     1: 
     1:     /* Check for new expression first. */
 40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
     1:     if (tt == TOK_NEW) {
 98181:         lhs = ListNode::create(PNK_NEW, this);
 86539:         if (!lhs)
 86539:             return NULL;
103823:         ParseNode *ctorExpr = memberExpr(false);
 86539:         if (!ctorExpr)
 86539:             return NULL;
 86539:         lhs->setOp(JSOP_NEW);
 86539:         lhs->initList(ctorExpr);
 86539:         lhs->pn_pos.begin = ctorExpr->pn_pos.begin;
 86539: 
 86539:         if (tokenStream.matchToken(TOK_LP) && !argumentList(lhs))
 86539:             return NULL;
 86539:         if (lhs->pn_count > ARGC_LIMIT) {
 40239:             JS_ReportErrorNumber(context, js_GetErrorMessage, NULL,
     1:                                  JSMSG_TOO_MANY_CON_ARGS);
     1:             return NULL;
     1:         }
 86539:         lhs->pn_pos.end = lhs->last()->pn_pos.end;
     1:     } else {
103823:         lhs = primaryExpr(tt, false);
 86539:         if (!lhs)
 86539:             return NULL;
 86539: 
 86539:         if (lhs->isXMLNameOp()) {
 86539:             lhs = new_<UnaryNode>(PNK_XMLUNARY, JSOP_XMLNAME, lhs->pn_pos, lhs);
 86539:             if (!lhs)
 80640:                 return NULL;
     1:         }
     1:     }
     1: 
 40354:     while ((tt = tokenStream.getToken()) > TOK_EOF) {
 86540:         ParseNode *nextMember;
     1:         if (tt == TOK_DOT) {
 86538:             tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
 86538:             if (tt == TOK_ERROR)
 86538:                 return NULL;
 86538:             if (tt == TOK_NAME) {
     1: #if JS_HAS_XML_SUPPORT
 99820:                 if (allowsXML() && tokenStream.peekToken() == TOK_DBLCOLON) {
 86540:                     ParseNode *propertyId = propertyQualifiedIdentifier();
 86540:                     if (!propertyId)
 86540:                         return NULL;
 86540: 
 86540:                     nextMember = new_<XMLDoubleColonProperty>(lhs, propertyId,
 86540:                                                               lhs->pn_pos.begin,
 86540:                                                               tokenStream.currentToken().pos.end);
 86540:                     if (!nextMember)
 86540:                         return NULL;
 86538:                 } else
 86538: #endif
 86538:                 {
 88610:                     PropertyName *field = tokenStream.currentToken().name();
 88610:                     nextMember = new_<PropertyAccess>(lhs, field,
 86540:                                                       lhs->pn_pos.begin,
 86540:                                                       tokenStream.currentToken().pos.end);
 86540:                     if (!nextMember)
 86540:                         return NULL;
 86538:                 }
 86538:             }
 86538: #if JS_HAS_XML_SUPPORT
 99820:             else if (allowsXML()) {
 86540:                 TokenPtr begin = lhs->pn_pos.begin;
 86538:                 if (tt == TOK_LP) {
 86538:                     /* Filters are effectively 'with', so deoptimize names. */
108876:                     pc->sc->setBindingsAccessedDynamically();
108876: 
108876:                     StmtInfoPC stmtInfo(context);
109603:                     ParseNode *oldWith = pc->innermostWith;
109603:                     pc->innermostWith = lhs;
108876:                     PushStatementPC(pc, &stmtInfo, STMT_WITH);
 86538: 
 86540:                     ParseNode *filter = bracketedExpr();
 86540:                     if (!filter)
 86540:                         return NULL;
 86540:                     filter->setInParens(true);
 86538:                     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_IN_PAREN);
 86538: 
109603:                     pc->innermostWith = oldWith;
108876:                     PopStatementPC(context, pc);
 86538: 
 86540:                     nextMember =
 86540:                         new_<XMLFilterExpression>(lhs, filter,
 86540:                                                   begin, tokenStream.currentToken().pos.end);
 86540:                     if (!nextMember)
 86540:                         return NULL;
 86538:                 } else if (tt == TOK_AT || tt == TOK_STAR) {
 86540:                     ParseNode *propertyId = starOrAtPropertyIdentifier(tt);
 86540:                     if (!propertyId)
 86540:                         return NULL;
 86540:                     nextMember = new_<XMLProperty>(lhs, propertyId,
 86540:                                                    begin, tokenStream.currentToken().pos.end);
 86540:                     if (!nextMember)
 86540:                         return NULL;
     1:                 } else {
102849:                     reportError(NULL, JSMSG_NAME_AFTER_DOT);
     1:                     return NULL;
     1:                 }
     1:             }
     1: #endif
 86538:             else {
102849:                 reportError(NULL, JSMSG_NAME_AFTER_DOT);
 86538:                 return NULL;
 86538:             }
 86541:         }
     1: #if JS_HAS_XML_SUPPORT
 86541:         else if (tt == TOK_DBLDOT) {
 99820:             if (!allowsXML()) {
102849:                 reportError(NULL, JSMSG_NAME_AFTER_DOT);
 80780:                 return NULL;
 80780:             }
 80780: 
 98181:             nextMember = BinaryNode::create(PNK_DBLDOT, this);
 86540:             if (!nextMember)
     1:                 return NULL;
 40854:             tt = tokenStream.getToken(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
103823:             ParseNode *pn3 = primaryExpr(tt, true);
     1:             if (!pn3)
     1:                 return NULL;
 82024:             if (pn3->isKind(PNK_NAME) && !pn3->isInParens()) {
 82024:                 pn3->setKind(PNK_STRING);
 78294:                 pn3->setArity(PN_NULLARY);
 78294:                 pn3->setOp(JSOP_QNAMEPART);
 82024:             } else if (!pn3->isXMLPropertyIdentifier()) {
102849:                 reportError(NULL, JSMSG_NAME_AFTER_DOT);
     1:                 return NULL;
     1:             }
 86540:             nextMember->setOp(JSOP_DESCENDANTS);
 86540:             nextMember->pn_left = lhs;
 86540:             nextMember->pn_right = pn3;
 86540:             nextMember->pn_pos.begin = lhs->pn_pos.begin;
 86540:             nextMember->pn_pos.end = tokenStream.currentToken().pos.end;
 86541:         }
     1: #endif
 86541:         else if (tt == TOK_LB) {
 86541:             ParseNode *propExpr = expr();
 86541:             if (!propExpr)
 86541:                 return NULL;
 86541: 
 86541:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_IN_INDEX);
 86541:             TokenPtr begin = lhs->pn_pos.begin, end = tokenStream.currentToken().pos.end;
 86541: 
 86541:             /*
106027:              * Do folding so we don't have roundtrip changes for cases like:
106027:              * function (obj) { return obj["a" + "b"] }
106027:              */
106027:             if (foldConstants && !FoldConstants(context, propExpr, this))
106027:                 return NULL;
106027: 
106027:             /*
 86541:              * Optimize property name lookups. If the name is a PropertyName,
 86541:              * then make a name-based node so the emitter will use a name-based
 86541:              * bytecode. Otherwise make a node using the property expression
 86541:              * by value. If the node is a string containing an index, convert
 86541:              * it to a number to save work later.
 86541:              */
 86541:             uint32_t index;
 86541:             PropertyName *name = NULL;
 86541:             if (propExpr->isKind(PNK_STRING)) {
 86541:                 JSAtom *atom = propExpr->pn_atom;
 86541:                 if (atom->isIndex(&index)) {
 86541:                     propExpr->setKind(PNK_NUMBER);
 86541:                     propExpr->setOp(JSOP_DOUBLE);
 86541:                     propExpr->pn_dval = index;
 86541:                 } else {
 86541:                     name = atom->asPropertyName();
 86541:                 }
 86541:             } else if (propExpr->isKind(PNK_NUMBER)) {
106027:                 double number = propExpr->pn_dval;
106027:                 if (number != ToUint32(number)) {
106027:                     JSAtom *atom = ToAtom(context, DoubleValue(number));
102387:                     if (!atom)
 86541:                         return NULL;
 86541:                     name = atom->asPropertyName();
 86541:                 }
106027:             }
 86541: 
 86541:             if (name)
 86541:                 nextMember = new_<PropertyAccess>(lhs, name, begin, end);
 86541:             else
 86541:                 nextMember = new_<PropertyByValue>(lhs, propExpr, begin, end);
 86540:             if (!nextMember)
     1:                 return NULL;
     1:         } else if (allowCallSyntax && tt == TOK_LP) {
 98181:             nextMember = ListNode::create(PNK_LP, this);
 86540:             if (!nextMember)
 86540:                 return NULL;
 86540:             nextMember->setOp(JSOP_CALL);
 27012: 
 86539:             if (lhs->isOp(JSOP_NAME)) {
 86539:                 if (lhs->pn_atom == context->runtime->atomState.evalAtom) {
108876:                     /* Select JSOP_EVAL and flag pc as heavyweight. */
 86540:                     nextMember->setOp(JSOP_EVAL);
108876:                     pc->sc->setBindingsAccessedDynamically();
108505: 
 64296:                     /*
 64296:                      * In non-strict mode code, direct calls to eval can add
 64296:                      * variables to the call object.
 64296:                      */
108876:                     if (pc->sc->strictModeState != StrictMode::STRICT)
108876:                         pc->sc->setFunHasExtensibleScope();
 27012:                 }
 86539:             } else if (lhs->isOp(JSOP_GETPROP)) {
 57712:                 /* Select JSOP_FUNAPPLY given foo.apply(...). */
 86539:                 if (lhs->pn_atom == context->runtime->atomState.applyAtom)
 86540:                     nextMember->setOp(JSOP_FUNAPPLY);
 86539:                 else if (lhs->pn_atom == context->runtime->atomState.callAtom)
 86540:                     nextMember->setOp(JSOP_FUNCALL);
 86540:             }
 86540: 
 86540:             nextMember->initList(lhs);
 86540:             nextMember->pn_pos.begin = lhs->pn_pos.begin;
 86540: 
 86540:             if (!argumentList(nextMember))
 86540:                 return NULL;
 86540:             if (nextMember->pn_count > ARGC_LIMIT) {
 40239:                 JS_ReportErrorNumber(context, js_GetErrorMessage, NULL,
     1:                                      JSMSG_TOO_MANY_FUN_ARGS);
     1:                 return NULL;
     1:             }
 86540:             nextMember->pn_pos.end = tokenStream.currentToken().pos.end;
     1:         } else {
 40354:             tokenStream.ungetToken();
 86539:             return lhs;
 86539:         }
 86539: 
 86540:         lhs = nextMember;
     1:     }
     1:     if (tt == TOK_ERROR)
     1:         return NULL;
 86539:     return lhs;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::bracketedExpr()
     1: {
     1:     /*
     1:      * Always accept the 'in' operator in a parenthesized expression,
     1:      * where it's unambiguous, even if we might be parsing the init of a
     1:      * for statement.
     1:      */
109503:     bool oldParsingForInit = pc->parsingForInit;
109503:     pc->parsingForInit = false;
 98477:     ParseNode *pn = expr();
109503:     pc->parsingForInit = oldParsingForInit;
     1:     return pn;
     1: }
     1: 
     1: #if JS_HAS_XML_SUPPORT
     1: 
 80631: ParseNode *
 40860: Parser::endBracketedExpr()
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 80631:     ParseNode *pn = bracketedExpr();
     1:     if (!pn)
     1:         return NULL;
     1: 
     1:     MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_ATTR_EXPR);
     1:     return pn;
     1: }
     1: 
     1: /*
     1:  * From the ECMA-357 grammar in 11.1.1 and 11.1.2:
     1:  *
     1:  *      AttributeIdentifier:
     1:  *              @ PropertySelector
     1:  *              @ QualifiedIdentifier
     1:  *              @ [ Expression ]
     1:  *
     1:  *      PropertySelector:
     1:  *              Identifier
     1:  *              *
     1:  *
     1:  *      QualifiedIdentifier:
     1:  *              PropertySelector :: PropertySelector
     1:  *              PropertySelector :: [ Expression ]
     1:  *
     1:  * We adapt AttributeIdentifier and QualifiedIdentier to be LL(1), like so:
     1:  *
     1:  *      AttributeIdentifier:
     1:  *              @ QualifiedIdentifier
     1:  *              @ [ Expression ]
     1:  *
     1:  *      PropertySelector:
     1:  *              Identifier
     1:  *              *
     1:  *
     1:  *      QualifiedIdentifier:
     1:  *              PropertySelector :: PropertySelector
     1:  *              PropertySelector :: [ Expression ]
     1:  *              PropertySelector
     1:  *
     1:  * As PrimaryExpression: Identifier is in ECMA-262 and we want the semantics
     1:  * for that rule to result in a name node, but ECMA-357 extends the grammar
     1:  * to include PrimaryExpression: QualifiedIdentifier, we must factor further:
     1:  *
     1:  *      QualifiedIdentifier:
     1:  *              PropertySelector QualifiedSuffix
     1:  *
     1:  *      QualifiedSuffix:
     1:  *              :: PropertySelector
     1:  *              :: [ Expression ]
     1:  *              /nothing/
     1:  *
     1:  * And use this production instead of PrimaryExpression: QualifiedIdentifier:
     1:  *
     1:  *      PrimaryExpression:
     1:  *              Identifier QualifiedSuffix
     1:  *
     1:  * We hoist the :: match into callers of QualifiedSuffix, in order to tweak
     1:  * PropertySelector vs. Identifier pn_arity, pn_op, and other members.
     1:  */
 80631: ParseNode *
 40860: Parser::propertySelector()
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 82024:     ParseNode *selector;
 82024:     if (tokenStream.isCurrentTokenType(TOK_STAR)) {
 98181:         selector = NullaryNode::create(PNK_ANYNAME, this);
 82024:         if (!selector)
 82024:             return NULL;
 82024:         selector->setOp(JSOP_ANYNAME);
 82024:         selector->pn_atom = context->runtime->atomState.starAtom;
     1:     } else {
 82024:         JS_ASSERT(tokenStream.isCurrentTokenType(TOK_NAME));
 98181:         selector = NullaryNode::create(PNK_NAME, this);
 82024:         if (!selector)
 82024:             return NULL;
 82024:         selector->setOp(JSOP_QNAMEPART);
 82024:         selector->setArity(PN_NAME);
 82024:         selector->pn_atom = tokenStream.currentToken().name();
 82024:         selector->pn_cookie.makeFree();
 82024:     }
 82024:     return selector;
     1: }
     1: 
 80631: ParseNode *
 80631: Parser::qualifiedSuffix(ParseNode *pn)
 80631: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_DBLCOLON);
108876:     ParseNode *pn2 = NameNode::create(PNK_DBLCOLON, NULL, this, this->pc);
     1:     if (!pn2)
     1:         return NULL;
     1: 
108876:     pc->sc->setBindingsAccessedDynamically();
 91455: 
     1:     /* Left operand of :: must be evaluated if it is an identifier. */
 78294:     if (pn->isOp(JSOP_QNAMEPART))
 78294:         pn->setOp(JSOP_NAME);
     1: 
 82024:     TokenKind tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
     1:     if (tt == TOK_STAR || tt == TOK_NAME) {
 40239:         /* Inline and specialize propertySelector for JSOP_QNAMECONST. */
 78294:         pn2->setOp(JSOP_QNAMECONST);
 27012:         pn2->pn_pos.begin = pn->pn_pos.begin;
     1:         pn2->pn_atom = (tt == TOK_STAR)
 40239:                        ? context->runtime->atomState.starAtom
 80443:                        : tokenStream.currentToken().name();
     1:         pn2->pn_expr = pn;
 47573:         pn2->pn_cookie.makeFree();
     1:         return pn2;
     1:     }
     1: 
     1:     if (tt != TOK_LB) {
102849:         reportError(NULL, JSMSG_SYNTAX_ERROR);
     1:         return NULL;
     1:     }
 82024:     ParseNode *pn3 = endBracketedExpr();
     1:     if (!pn3)
     1:         return NULL;
     1: 
 78294:     pn2->setOp(JSOP_QNAME);
 78294:     pn2->setArity(PN_BINARY);
 27012:     pn2->pn_pos.begin = pn->pn_pos.begin;
 27012:     pn2->pn_pos.end = pn3->pn_pos.end;
     1:     pn2->pn_left = pn;
     1:     pn2->pn_right = pn3;
     1:     return pn2;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::qualifiedIdentifier()
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 80631:     ParseNode *pn = propertySelector();
     1:     if (!pn)
     1:         return NULL;
 40354:     if (tokenStream.matchToken(TOK_DBLCOLON)) {
 28948:         /* Hack for bug 496316. Slowing down E4X won't make it go away, alas. */
108876:         pc->sc->setBindingsAccessedDynamically();
 40263:         pn = qualifiedSuffix(pn);
 28948:     }
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::attributeIdentifier()
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_AT);
 98181:     ParseNode *pn = UnaryNode::create(PNK_AT, this);
     1:     if (!pn)
     1:         return NULL;
 78294:     pn->setOp(JSOP_TOATTRNAME);
 82024: 
 82024:     ParseNode *pn2;
 82024:     TokenKind tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
     1:     if (tt == TOK_STAR || tt == TOK_NAME) {
 40263:         pn2 = qualifiedIdentifier();
     1:     } else if (tt == TOK_LB) {
 40263:         pn2 = endBracketedExpr();
     1:     } else {
102849:         reportError(NULL, JSMSG_SYNTAX_ERROR);
     1:         return NULL;
     1:     }
     1:     if (!pn2)
     1:         return NULL;
     1:     pn->pn_kid = pn2;
109047:     pn->pn_pos.end = pn2->pn_pos.end;
     1:     return pn;
     1: }
     1: 
     1: /*
     1:  * Make a TOK_LC unary node whose pn_kid is an expression.
     1:  */
 80631: ParseNode *
103824: Parser::xmlExpr(bool inTag)
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LC);
 98181:     ParseNode *pn = UnaryNode::create(PNK_XMLCURLYEXPR, this);
     1:     if (!pn)
     1:         return NULL;
     1: 
     1:     /*
 38596:      * Turn off XML tag mode. We save the old value of the flag because it may
 38596:      * already be off: XMLExpr is called both from within a tag, and from
 38596:      * within text contained in an element, but outside of any start, end, or
 38596:      * point tag.
 38596:      */
 40854:     bool oldflag = tokenStream.isXMLTagMode();
 40854:     tokenStream.setXMLTagMode(false);
 82024:     ParseNode *pn2 = expr();
     1:     if (!pn2)
     1:         return NULL;
     1: 
     1:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_XML_EXPR);
 40854:     tokenStream.setXMLTagMode(oldflag);
     1:     pn->pn_kid = pn2;
 78294:     pn->setOp(inTag ? JSOP_XMLTAGEXPR : JSOP_XMLELTEXPR);
109047:     pn->pn_pos.end = pn2->pn_pos.end;
     1:     return pn;
     1: }
     1: 
     1: /*
     1:  * Parse the productions:
     1:  *
     1:  *      XMLNameExpr:
     1:  *              XMLName XMLNameExpr?
     1:  *              { Expr } XMLNameExpr?
     1:  *
     1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according as XMLNameExpr produces
     1:  * a list of names and/or expressions, a single expression, or a single name.
 82024:  * If PN_LIST or PN_NULLARY, getKind() will be PNK_XMLNAME.  Otherwise if
 82873:  * PN_UNARY, getKind() will be PNK_XMLCURLYEXPR.
     1:  */
 80631: ParseNode *
 40860: Parser::xmlNameExpr()
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 80631:     ParseNode *pn, *pn2, *list;
 40320:     TokenKind tt;
     1: 
     1:     pn = list = NULL;
     1:     do {
 40270:         tt = tokenStream.currentToken().type;
     1:         if (tt == TOK_LC) {
103823:             pn2 = xmlExpr(true);
     1:             if (!pn2)
     1:                 return NULL;
     1:         } else {
     1:             JS_ASSERT(tt == TOK_XMLNAME);
 82024:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_STRING);
 82024:             pn2 = atomNode(PNK_XMLNAME, JSOP_STRING);
     1:             if (!pn2)
     1:                 return NULL;
     1:         }
     1: 
     1:         if (!pn) {
     1:             pn = pn2;
     1:         } else {
     1:             if (!list) {
 98181:                 list = ListNode::create(PNK_XMLNAME, this);
     1:                 if (!list)
     1:                     return NULL;
     1:                 list->pn_pos.begin = pn->pn_pos.begin;
 27012:                 list->initList(pn);
 27012:                 list->pn_xflags = PNX_CANTFOLD;
     1:                 pn = list;
     1:             }
     1:             pn->pn_pos.end = pn2->pn_pos.end;
 27012:             pn->append(pn2);
     1:         }
 40354:     } while ((tt = tokenStream.getToken()) == TOK_XMLNAME || tt == TOK_LC);
 40354: 
 40354:     tokenStream.ungetToken();
     1:     return pn;
     1: }
     1: 
     1: /*
     1:  * Macro to test whether an XMLNameExpr or XMLTagContent node can be folded
     1:  * at compile time into a JSXML tree.
     1:  */
 78294: #define XML_FOLDABLE(pn)        ((pn)->isArity(PN_LIST)                     \
 27012:                                  ? ((pn)->pn_xflags & PNX_CANTFOLD) == 0    \
 82873:                                  : !(pn)->isKind(PNK_XMLCURLYEXPR))
     1: 
     1: /*
     1:  * Parse the productions:
     1:  *
     1:  *      XMLTagContent:
     1:  *              XMLNameExpr
     1:  *              XMLTagContent S XMLNameExpr S? = S? XMLAttr
     1:  *              XMLTagContent S XMLNameExpr S? = S? { Expr }
     1:  *
     1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according to how XMLTagContent
     1:  * produces a list of name and attribute values and/or braced expressions, a
     1:  * single expression, or a single name.
     1:  *
 82024:  * If PN_LIST or PN_NULLARY, getKind() will be PNK_XMLNAME for the case where
 82024:  * XMLTagContent: XMLNameExpr.  If getKind() is not PNK_XMLNAME but getArity()
 82024:  * is PN_LIST, getKind() will be tagkind.  If PN_UNARY, getKind() will be
 82873:  * PNK_XMLCURLYEXPR and we parsed exactly one expression.
     1:  */
 80631: ParseNode *
 82024: Parser::xmlTagContent(ParseNodeKind tagkind, JSAtom **namep)
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 80631:     ParseNode *pn, *pn2, *list;
 40320:     TokenKind tt;
 40221: 
 40263:     pn = xmlNameExpr();
     1:     if (!pn)
     1:         return NULL;
 78294:     *namep = (pn->isArity(PN_NULLARY)) ? pn->pn_atom : NULL;
     1:     list = NULL;
     1: 
 40354:     while (tokenStream.matchToken(TOK_XMLSPACE)) {
 40354:         tt = tokenStream.getToken();
     1:         if (tt != TOK_XMLNAME && tt != TOK_LC) {
 40354:             tokenStream.ungetToken();
 40239:             break;
 40239:         }
 40239: 
 40263:         pn2 = xmlNameExpr();
     1:         if (!pn2)
     1:             return NULL;
     1:         if (!list) {
 98181:             list = ListNode::create(tagkind, this);
     1:             if (!list)
     1:                 return NULL;
     1:             list->pn_pos.begin = pn->pn_pos.begin;
 27012:             list->initList(pn);
     1:             pn = list;
     1:         }
 27012:         pn->append(pn2);
     1:         if (!XML_FOLDABLE(pn2))
 27012:             pn->pn_xflags |= PNX_CANTFOLD;
     1: 
 40354:         tokenStream.matchToken(TOK_XMLSPACE);
     1:         MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_NO_ASSIGN_IN_XML_ATTR);
 40354:         tokenStream.matchToken(TOK_XMLSPACE);
 40354: 
 40354:         tt = tokenStream.getToken();
     1:         if (tt == TOK_XMLATTR) {
 82024:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_STRING);
 82024:             pn2 = atomNode(PNK_XMLATTR, JSOP_STRING);
     1:         } else if (tt == TOK_LC) {
103823:             pn2 = xmlExpr(true);
 27012:             pn->pn_xflags |= PNX_CANTFOLD;
     1:         } else {
102849:             reportError(NULL, JSMSG_BAD_XML_ATTR_VALUE);
     1:             return NULL;
     1:         }
     1:         if (!pn2)
     1:             return NULL;
 27012:         pn->append(pn2);
     1:     }
     1: 
     1:     return pn;
     1: }
     1: 
     1: #define XML_CHECK_FOR_ERROR_AND_EOF(tt,result)                                              \
     1:     JS_BEGIN_MACRO                                                                          \
     1:         if ((tt) <= TOK_EOF) {                                                              \
     1:             if ((tt) == TOK_EOF) {                                                          \
102849:                 reportError(NULL, JSMSG_END_OF_XML_SOURCE);                                 \
     1:             }                                                                               \
     1:             return result;                                                                  \
     1:         }                                                                                   \
     1:     JS_END_MACRO
     1: 
     1: /*
     1:  * Consume XML element tag content, including the TOK_XMLETAGO (</) sequence
     1:  * that opens the end tag for the container.
     1:  */
103824: bool
 80631: Parser::xmlElementContent(ParseNode *pn)
 40221: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 40854:     tokenStream.setXMLTagMode(false);
     1:     for (;;) {
 40854:         TokenKind tt = tokenStream.getToken(TSF_XMLTEXTMODE);
103823:         XML_CHECK_FOR_ERROR_AND_EOF(tt, false);
     1: 
     1:         JS_ASSERT(tt == TOK_XMLSPACE || tt == TOK_XMLTEXT);
 80443:         JSAtom *textAtom = tokenStream.currentToken().atom();
     1:         if (textAtom) {
     1:             /* Non-zero-length XML text scanned. */
 82024:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_STRING);
 82024:             ParseNode *pn2 = atomNode(tt == TOK_XMLSPACE ? PNK_XMLSPACE : PNK_XMLTEXT,
 82024:                                       JSOP_STRING);
     1:             if (!pn2)
 82024:                 return false;
 27012:             pn->append(pn2);
     1:         }
     1: 
 40854:         tt = tokenStream.getToken(TSF_OPERAND);
103823:         XML_CHECK_FOR_ERROR_AND_EOF(tt, false);
     1:         if (tt == TOK_XMLETAGO)
     1:             break;
     1: 
 80631:         ParseNode *pn2;
     1:         if (tt == TOK_LC) {
103823:             pn2 = xmlExpr(false);
 82024:             if (!pn2)
 82024:                 return false;
 27012:             pn->pn_xflags |= PNX_CANTFOLD;
     1:         } else if (tt == TOK_XMLSTAGO) {
103823:             pn2 = xmlElementOrList(false);
 82024:             if (!pn2)
 82024:                 return false;
 27012:             pn2->pn_xflags &= ~PNX_XMLROOT;
 27012:             pn->pn_xflags |= pn2->pn_xflags;
 82024:         } else if (tt == TOK_XMLPI) {
 86378:             const Token &tok = tokenStream.currentToken();
 86378:             pn2 = new_<XMLProcessingInstruction>(tok.xmlPITarget(), tok.xmlPIData(), tok.pos);
 82024:             if (!pn2)
 82024:                 return false;
     1:         } else {
 82024:             JS_ASSERT(tt == TOK_XMLCDATA || tt == TOK_XMLCOMMENT);
 82024:             pn2 = atomNode(tt == TOK_XMLCDATA ? PNK_XMLCDATA : PNK_XMLCOMMENT,
 82024:                            tokenStream.currentToken().t_op);
     1:             if (!pn2)
 82024:                 return false;
 82024:         }
 27012:         pn->append(pn2);
     1:     }
 40854:     tokenStream.setXMLTagMode(true);
     1: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_XMLETAGO);
103823:     return true;
     1: }
     1: 
     1: /*
     1:  * Return a PN_LIST node containing an XML or XMLList Initialiser.
     1:  */
 80631: ParseNode *
103824: Parser::xmlElementOrList(bool allowList)
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 80631:     ParseNode *pn, *pn2, *list;
 40320:     TokenKind tt;
 99421:     RootedAtom startAtom(context), endAtom(context);
     1: 
 40239:     JS_CHECK_RECURSION(context, return NULL);
 40239: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_XMLSTAGO);
 98181:     pn = ListNode::create(PNK_XMLSTAGO, this);
     1:     if (!pn)
     1:         return NULL;
     1: 
 40854:     tokenStream.setXMLTagMode(true);
 40354:     tt = tokenStream.getToken();
     1:     if (tt == TOK_ERROR)
     1:         return NULL;
     1: 
     1:     if (tt == TOK_XMLNAME || tt == TOK_LC) {
     1:         /*
     1:          * XMLElement.  Append the tag and its contents, if any, to pn.
     1:          */
 97353:         pn2 = xmlTagContent(PNK_XMLSTAGO, startAtom.address());
     1:         if (!pn2)
     1:             return NULL;
 40354:         tokenStream.matchToken(TOK_XMLSPACE);
 40354: 
 40354:         tt = tokenStream.getToken();
     1:         if (tt == TOK_XMLPTAGC) {
     1:             /* Point tag (/>): recycle pn if pn2 is a list of tag contents. */
 82024:             if (pn2->isKind(PNK_XMLSTAGO)) {
 27012:                 pn->makeEmpty();
 80641:                 freeTree(pn);
     1:                 pn = pn2;
     1:             } else {
 82873:                 JS_ASSERT(pn2->isKind(PNK_XMLNAME) || pn2->isKind(PNK_XMLCURLYEXPR));
 27012:                 pn->initList(pn2);
     1:                 if (!XML_FOLDABLE(pn2))
 27012:                     pn->pn_xflags |= PNX_CANTFOLD;
     1:             }
 82024:             pn->setKind(PNK_XMLPTAGC);
 27012:             pn->pn_xflags |= PNX_XMLROOT;
     1:         } else {
     1:             /* We had better have a tag-close (>) at this point. */
     1:             if (tt != TOK_XMLTAGC) {
102849:                 reportError(NULL, JSMSG_BAD_XML_TAG_SYNTAX);
     1:                 return NULL;
     1:             }
 40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
     1: 
     1:             /* Make sure pn2 is a TOK_XMLSTAGO list containing tag contents. */
 82024:             if (!pn2->isKind(PNK_XMLSTAGO)) {
 27012:                 pn->initList(pn2);
     1:                 if (!XML_FOLDABLE(pn2))
 27012:                     pn->pn_xflags |= PNX_CANTFOLD;
     1:                 pn2 = pn;
 98181:                 pn = ListNode::create(PNK_XMLTAGC, this);
     1:                 if (!pn)
     1:                     return NULL;
109047:                 pn->pn_pos = pn2->pn_pos;
     1:             }
     1: 
     1:             /* Now make pn a nominal-root TOK_XMLELEM list containing pn2. */
 82024:             pn->setKind(PNK_XMLELEM);
 27012:             pn->pn_pos.begin = pn2->pn_pos.begin;
 27012:             pn->initList(pn2);
     1:             if (!XML_FOLDABLE(pn2))
 27012:                 pn->pn_xflags |= PNX_CANTFOLD;
 27012:             pn->pn_xflags |= PNX_XMLROOT;
     1: 
     1:             /* Get element contents and delimiting end-tag-open sequence. */
 40263:             if (!xmlElementContent(pn))
 40239:                 return NULL;
 40239: 
 40354:             tt = tokenStream.getToken();
     1:             XML_CHECK_FOR_ERROR_AND_EOF(tt, NULL);
     1:             if (tt != TOK_XMLNAME && tt != TOK_LC) {
102849:                 reportError(NULL, JSMSG_BAD_XML_TAG_SYNTAX);
     1:                 return NULL;
     1:             }
     1: 
     1:             /* Parse end tag; check mismatch at compile-time if we can. */
 97353:             pn2 = xmlTagContent(PNK_XMLETAGO, endAtom.address());
     1:             if (!pn2)
     1:                 return NULL;
 82024:             if (pn2->isKind(PNK_XMLETAGO)) {
     1:                 /* Oops, end tag has attributes! */
102849:                 reportError(NULL, JSMSG_BAD_XML_TAG_SYNTAX);
     1:                 return NULL;
     1:             }
     1:             if (endAtom && startAtom && endAtom != startAtom) {
     1:                 /* End vs. start tag name mismatch: point to the tag name. */
102849:                 reportUcError(pn2, JSMSG_XML_TAG_NAME_MISMATCH, startAtom->chars());
     1:                 return NULL;
     1:             }
     1: 
     1:             /* Make a TOK_XMLETAGO list with pn2 as its single child. */
 82873:             JS_ASSERT(pn2->isKind(PNK_XMLNAME) || pn2->isKind(PNK_XMLCURLYEXPR));
 98181:             list = ListNode::create(PNK_XMLETAGO, this);
     1:             if (!list)
     1:                 return NULL;
 27012:             list->initList(pn2);
 27012:             pn->append(list);
     1:             if (!XML_FOLDABLE(pn2)) {
 27012:                 list->pn_xflags |= PNX_CANTFOLD;
 27012:                 pn->pn_xflags |= PNX_CANTFOLD;
     1:             }
     1: 
 40354:             tokenStream.matchToken(TOK_XMLSPACE);
     1:             MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_TAG_SYNTAX);
     1:         }
     1: 
     1:         /* Set pn_op now that pn has been updated to its final value. */
 78294:         pn->setOp(JSOP_TOXML);
     1:     } else if (allowList && tt == TOK_XMLTAGC) {
     1:         /* XMLList Initialiser. */
 82024:         pn->setKind(PNK_XMLLIST);
 78294:         pn->setOp(JSOP_TOXMLLIST);
 27012:         pn->makeEmpty();
 27012:         pn->pn_xflags |= PNX_XMLROOT;
 40263:         if (!xmlElementContent(pn))
     1:             return NULL;
     1: 
     1:         MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_LIST_SYNTAX);
     1:     } else {
102849:         reportError(NULL, JSMSG_BAD_XML_NAME_SYNTAX);
     1:         return NULL;
     1:     }
 40854:     tokenStream.setXMLTagMode(false);
     1: 
 40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
103824: Parser::xmlElementOrListRoot(bool allowList)
     1: {
 99820:     JS_ASSERT(allowsXML());
 99820: 
 99820:     /*
 99820:      * Turn on "moar XML" so that comments and CDATA literals are recognized,
 99820:      * instead of <! followed by -- starting an HTML comment to end of line
 99820:      * (used in script tags to hide content from old browsers that don't
 99820:      * recognize <script>).
 99820:      */
 99820:     bool hadMoarXML = tokenStream.hasMoarXML();
 99820:     tokenStream.setMoarXML(true);
 80631:     ParseNode *pn = xmlElementOrList(allowList);
 99820:     tokenStream.setMoarXML(hadMoarXML);
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::parseXMLText(JSObject *chain, bool allowList)
 27012: {
     1:     /*
     1:      * Push a compiler frame if we have no frames, or if the top frame is a
     1:      * lightweight function activation, or if its scope chain doesn't match
     1:      * the one passed to us.
     1:      */
104093:     SharedContext xmlsc(context, chain, /* fun = */ NULL, /* funbox = */ NULL, StrictMode::NOTSTRICT);
108876:     ParseContext xmlpc(this, &xmlsc, /* staticLevel = */ 0, /* bodyid = */ 0);
108876:     if (!xmlpc.init())
 72579:         return NULL;
     1: 
     1:     /* Set XML-only mode to turn off special treatment of {expr} in XML. */
 40854:     tokenStream.setXMLOnlyMode();
 40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
 27012: 
 80631:     ParseNode *pn;
     1:     if (tt != TOK_XMLSTAGO) {
102849:         reportError(NULL, JSMSG_BAD_XML_MARKUP);
     1:         pn = NULL;
     1:     } else {
 40263:         pn = xmlElementOrListRoot(allowList);
 40239:     }
 40854:     tokenStream.setXMLOnlyMode(false);
 40854: 
     1:     return pn;
     1: }
     1: 
     1: #endif /* JS_HAS_XMLSUPPORT */
     1: 
 86538: bool
 86538: Parser::checkForFunctionNode(PropertyName *name, ParseNode *node)
 86538: {
 86538:     /*
 86538:      * In |a.ns::name|, |ns| refers to an in-scope variable, so |ns| can't be a
 86538:      * keyword.  (Exception: |function::name| is the actual name property, not
 86538:      * what E4X would expose.)  We parsed |ns| accepting a keyword as a name,
 86538:      * so we must implement the keyword restriction manually in this case.
 86538:      */
 86538:     if (const KeywordInfo *ki = FindKeyword(name->charsZ(), name->length())) {
 86538:         if (ki->tokentype != TOK_FUNCTION) {
102849:             reportError(NULL, JSMSG_KEYWORD_NOT_NS);
 86538:             return false;
 86538:         }
 86538: 
 86538:         node->setArity(PN_NULLARY);
 86538:         node->setKind(PNK_FUNCTION);
 86538:     }
 86538: 
 86538:     return true;
 86538: }
 86538: 
 86538: #if JS_HAS_XML_SUPPORT
 86538: ParseNode *
 86538: Parser::propertyQualifiedIdentifier()
 86538: {
 99820:     JS_ASSERT(allowsXML());
 86538:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_NAME));
 86538:     JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NAME);
 86538:     JS_ASSERT(tokenStream.peekToken() == TOK_DBLCOLON);
 86538: 
 86538:     /* Deoptimize QualifiedIdentifier properties to avoid tricky analysis. */
108876:     pc->sc->setBindingsAccessedDynamically();
 86538: 
 86538:     PropertyName *name = tokenStream.currentToken().name();
108876:     ParseNode *node = NameNode::create(PNK_NAME, name, this, this->pc);
 86538:     if (!node)
 86538:         return NULL;
 86538:     node->setOp(JSOP_NAME);
 86538:     node->pn_dflags |= PND_DEOPTIMIZED;
 86538: 
 86538:     if (!checkForFunctionNode(name, node))
 86538:         return NULL;
 86538: 
 86538:     tokenStream.consumeKnownToken(TOK_DBLCOLON);
 86538:     return qualifiedSuffix(node);
 86538: }
 86538: #endif
 86538: 
 86538: ParseNode *
 88610: Parser::identifierName(bool afterDoubleDot)
 86538: {
 86538:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_NAME));
 86538: 
 86538:     PropertyName *name = tokenStream.currentToken().name();
108876:     ParseNode *node = NameNode::create(PNK_NAME, name, this, this->pc);
 86538:     if (!node)
 86538:         return NULL;
 86538:     JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NAME);
 86538:     node->setOp(JSOP_NAME);
 86538: 
 95100:     if ((!afterDoubleDot
 86538: #if JS_HAS_XML_SUPPORT
 99820:                 || (allowsXML() && tokenStream.peekToken() == TOK_DBLCOLON)
 86538: #endif
108876:                ) && !pc->inDeclDestructuring)
 86538:     {
 98181:         if (!NoteNameUse(node, this))
 97594:             return NULL;
 86538:     }
 86538: 
 86538: #if JS_HAS_XML_SUPPORT
 99820:     if (allowsXML() && tokenStream.matchToken(TOK_DBLCOLON)) {
 88610:         if (afterDoubleDot) {
 86538:             if (!checkForFunctionNode(name, node))
 86538:                 return NULL;
 86538:         }
 86538:         node = qualifiedSuffix(node);
 86538:         if (!node)
 86538:             return NULL;
 86538:     }
 86538: #endif
 86538: 
 86538:     return node;
 86538: }
 86538: 
107038: ParseNode *
107038: Parser::intrinsicName()
107038: {
107038:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_MOD));
107038:     if (tokenStream.getToken() != TOK_NAME) {
107038:         reportError(NULL, JSMSG_SYNTAX_ERROR);
107038:         return NULL;
107038:     }
107038: 
107038:     PropertyName *name = tokenStream.currentToken().name();
107038:     if (!(name == context->runtime->atomState._CallFunctionAtom ||
107038:           context->global()->hasIntrinsicFunction(context, name)))
107038:     {
107038:         reportError(NULL, JSMSG_INTRINSIC_NOT_DEFINED, JS_EncodeString(context, name));
107038:         return NULL;
107038:     }
108876:     ParseNode *node = NameNode::create(PNK_INTRINSICNAME, name, this, this->pc);
107038:     if (!node)
107038:         return NULL;
107038:     JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NAME);
107038:     node->setOp(JSOP_INTRINSICNAME);
107038:     return node;
107038: }
107038: 
 86538: #if JS_HAS_XML_SUPPORT
 86538: ParseNode *
 86538: Parser::starOrAtPropertyIdentifier(TokenKind tt)
 86538: {
 86538:     JS_ASSERT(tt == TOK_AT || tt == TOK_STAR);
 99820:     if (allowsXML())
 99820:         return (tt == TOK_AT) ? attributeIdentifier() : qualifiedIdentifier();
102849:     reportError(NULL, JSMSG_SYNTAX_ERROR);
 86538:     return NULL;
 86538: }
 86538: #endif
 86538: 
 80631: ParseNode *
 98644: Parser::atomNode(ParseNodeKind kind, JSOp op)
 98644: {
 98644:     ParseNode *node = NullaryNode::create(kind, this);
 98644:     if (!node)
 98644:         return NULL;
 98644:     node->setOp(op);
 98644:     const Token &tok = tokenStream.currentToken();
 98644:     node->pn_atom = tok.atom();
106917: 
106917:     // Large strings are fast to parse but slow to compress. Stop compression on
106917:     // them, so we don't wait for a long time for compression to finish at the
106917:     // end of compilation.
106917:     const size_t HUGE_STRING = 50000;
110381:     if (sct && sct->active() && kind == PNK_STRING && node->pn_atom->length() >= HUGE_STRING)
106917:         sct->abort();
106917: 
 98644:     return node;
 98644: }
 98644: 
 98644: ParseNode *
 88610: Parser::primaryExpr(TokenKind tt, bool afterDoubleDot)
     1: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(tt));
 82024: 
 80631:     ParseNode *pn, *pn2, *pn3;
     1:     JSOp op;
 11139: 
 40239:     JS_CHECK_RECURSION(context, return NULL);
 11139: 
     1:     switch (tt) {
     1:       case TOK_FUNCTION:
     1: #if JS_HAS_XML_SUPPORT
 99820:         if (allowsXML() && tokenStream.matchToken(TOK_DBLCOLON, TSF_KEYWORD_IS_NAME)) {
 98181:             pn2 = NullaryNode::create(PNK_FUNCTION, this);
     1:             if (!pn2)
     1:                 return NULL;
 40263:             pn = qualifiedSuffix(pn2);
     1:             if (!pn)
     1:                 return NULL;
     1:             break;
     1:         }
     1: #endif
 40263:         pn = functionExpr();
     1:         if (!pn)
     1:             return NULL;
     1:         break;
     1: 
     1:       case TOK_LB:
     1:       {
 98181:         pn = ListNode::create(PNK_RB, this);
     1:         if (!pn)
     1:             return NULL;
 78294:         pn->setOp(JSOP_NEWINIT);
 27012:         pn->makeEmpty();
 27012: 
 27012: #if JS_HAS_GENERATORS
108876:         pn->pn_blockid = pc->blockidGen;
 27012: #endif
102219:         if (tokenStream.matchToken(TOK_RB, TSF_OPERAND)) {
102219:             /*
102219:              * Mark empty arrays as non-constant, since we cannot easily
102219:              * determine their type.
102219:              */
102219:             pn->pn_xflags |= PNX_NONCONST;
102219:         } else {
101314:             bool spread = false;
102219:             unsigned index = 0;
102219:             for (; ; index++) {
 73495:                 if (index == StackSpace::ARGS_LENGTH_MAX) {
102849:                     reportError(NULL, JSMSG_ARRAY_INIT_TOO_BIG);
     1:                     return NULL;
     1:                 }
     1: 
 40854:                 tt = tokenStream.peekToken(TSF_OPERAND);
     1:                 if (tt == TOK_RB) {
 27012:                     pn->pn_xflags |= PNX_ENDCOMMA;
     1:                     break;
     1:                 }
     1: 
     1:                 if (tt == TOK_COMMA) {
     1:                     /* So CURRENT_TOKEN gets TOK_COMMA and not TOK_LB. */
 40354:                     tokenStream.matchToken(TOK_COMMA);
 98181:                     pn2 = NullaryNode::create(PNK_COMMA, this);
 59962:                     pn->pn_xflags |= PNX_HOLEY | PNX_NONCONST;
     1:                 } else {
101314:                     ParseNode *spreadNode = NULL;
101314:                     if (tt == TOK_TRIPLEDOT) {
101314:                         spread = true;
101314:                         spreadNode = UnaryNode::create(PNK_SPREAD, this);
101314:                         if (!spreadNode)
101314:                             return NULL;
101314:                         tokenStream.getToken();
101314:                     }
 40263:                     pn2 = assignExpr();
 97664:                     if (pn2) {
 98181:                         if (foldConstants && !FoldConstants(context, pn2, this))
 97664:                             return NULL;
101314:                         if (!pn2->isConstant() || spreadNode)
 59962:                             pn->pn_xflags |= PNX_NONCONST;
101314:                         if (spreadNode) {
101314:                             spreadNode->pn_kid = pn2;
101314:                             pn2 = spreadNode;
101314:                         }
     1:                     }
 97664:                 }
     1:                 if (!pn2)
     1:                     return NULL;
 27012:                 pn->append(pn2);
     1: 
     1:                 if (tt != TOK_COMMA) {
     1:                     /* If we didn't already match TOK_COMMA in above case. */
 40354:                     if (!tokenStream.matchToken(TOK_COMMA))
     1:                         break;
     1:                 }
     1:             }
     1: 
     1: #if JS_HAS_GENERATORS
     1:             /*
     1:              * At this point, (index == 0 && pn->pn_count != 0) implies one
 26959:              * element initialiser was parsed.
     1:              *
     1:              * An array comprehension of the form:
     1:              *
     1:              *   [i * j for (i in o) for (j in p) if (i != j)]
     1:              *
     1:              * translates to roughly the following let expression:
     1:              *
     1:              *   let (array = new Array, i, j) {
     1:              *     for (i in o) let {
     1:              *       for (j in p)
     1:              *         if (i != j)
     1:              *           array.push(i * j)
     1:              *     }
     1:              *     array
     1:              *   }
     1:              *
     1:              * where array is a nameless block-local variable. The "roughly"
     1:              * means that an implementation may optimize away the array.push.
     1:              * An array comprehension opens exactly one block scope, no matter
     1:              * how many for heads it contains.
     1:              *
     1:              * Each let () {...} or for (let ...) ... compiles to:
     1:              *
     1:              *   JSOP_ENTERBLOCK <o> ... JSOP_LEAVEBLOCK <n>
     1:              *
     1:              * where <o> is a literal object representing the block scope,
     1:              * with <n> properties, naming each var declared in the block.
     1:              *
     1:              * Each var declaration in a let-block binds a name in <o> at
     1:              * compile time, and allocates a slot on the operand stack at
 74052:              * runtime via JSOP_ENTERBLOCK. A block-local var is accessed by
 74052:              * the JSOP_GETLOCAL and JSOP_SETLOCAL ops. These ops have an
 74052:              * immediate operand, the local slot's stack index from fp->spbase.
     1:              *
     1:              * The array comprehension iteration step, array.push(i * j) in
101314:              * the example above, is done by <i * j>; JSOP_ARRAYPUSH <array>,
     1:              * where <array> is the index of array's stack slot.
     1:              */
101314:             if (index == 0 && !spread && pn->pn_count != 0 && tokenStream.matchToken(TOK_FOR)) {
 80631:                 ParseNode *pnexp, *pntop;
     1: 
     1:                 /* Relabel pn as an array comprehension node. */
 82024:                 pn->setKind(PNK_ARRAYCOMP);
     1: 
     1:                 /*
     1:                  * Remove the comprehension expression from pn's linked list
     1:                  * and save it via pnexp.  We'll re-install it underneath the
     1:                  * ARRAYPUSH node after we parse the rest of the comprehension.
     1:                  */
 27012:                 pnexp = pn->last();
 51110:                 JS_ASSERT(pn->pn_count == 1);
 51110:                 pn->pn_count = 0;
 51110:                 pn->pn_tail = &pn->pn_head;
     1:                 *pn->pn_tail = NULL;
     1: 
 72073:                 pntop = comprehensionTail(pnexp, pn->pn_blockid, false,
 82024:                                           PNK_ARRAYPUSH, JSOP_ARRAYPUSH);
     1:                 if (!pntop)
     1:                     return NULL;
 27012:                 pn->append(pntop);
     1:             }
     1: #endif /* JS_HAS_GENERATORS */
     1: 
     1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_LIST);
     1:         }
 40270:         pn->pn_pos.end = tokenStream.currentToken().pos.end;
     1:         return pn;
     1:       }
     1: 
     1:       case TOK_LC:
     1:       {
 80631:         ParseNode *pnval;
     1: 
 35310:         /*
 60213:          * A map from property names we've seen thus far to a mask of property
 60213:          * assignment types, stored and retrieved with ALE_SET_INDEX/ALE_INDEX.
 35310:          */
 72579:         AtomIndexMap seen(context);
 72579: 
 60213:         enum AssignmentType {
 60213:             GET     = 0x1,
 60213:             SET     = 0x2,
 60213:             VALUE   = 0x4 | GET | SET
 60213:         };
 35310: 
 98181:         pn = ListNode::create(PNK_RC, this);
     1:         if (!pn)
     1:             return NULL;
 78294:         pn->setOp(JSOP_NEWINIT);
 27012:         pn->makeEmpty();
     1: 
     1:         for (;;) {
 35310:             JSAtom *atom;
 82469:             TokenKind ltok = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
 89334:             TokenPtr begin = tokenStream.currentToken().pos.begin;
 82469:             switch (ltok) {
     1:               case TOK_NUMBER:
 98181:                 pn3 = NullaryNode::create(PNK_NUMBER, this);
 33749:                 if (!pn3)
 33749:                     return NULL;
 80817:                 pn3->pn_dval = tokenStream.currentToken().number();
102387:                 atom = ToAtom(context, DoubleValue(pn3->pn_dval));
102387:                 if (!atom)
 40794:                     return NULL;
     1:                 break;
     1:               case TOK_NAME:
     1:                 {
 80443:                     atom = tokenStream.currentToken().name();
 82024:                     if (atom == context->runtime->atomState.getAtom) {
  1478:                         op = JSOP_GETTER;
 82024:                     } else if (atom == context->runtime->atomState.setAtom) {
  1478:                         op = JSOP_SETTER;
 82024:                     } else {
 98181:                         pn3 = NullaryNode::create(PNK_NAME, this);
 82024:                         if (!pn3)
 82024:                             return NULL;
 82024:                         pn3->pn_atom = atom;
 82024:                         break;
 82024:                     }
  1478: 
 40854:                     tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
 82024:                     if (tt == TOK_NAME) {
 82024:                         atom = tokenStream.currentToken().name();
108876:                         pn3 = NameNode::create(PNK_NAME, atom, this, this->pc);
     1:                         if (!pn3)
     1:                             return NULL;
 82024:                     } else if (tt == TOK_STRING) {
 82024:                         atom = tokenStream.currentToken().atom();
 86788: 
 86788:                         uint32_t index;
 86788:                         if (atom->isIndex(&index)) {
 98181:                             pn3 = NullaryNode::create(PNK_NUMBER, this);
 86788:                             if (!pn3)
 86788:                                 return NULL;
 86788:                             pn3->pn_dval = index;
102387:                             atom = ToAtom(context, DoubleValue(pn3->pn_dval));
102387:                             if (!atom)
 86788:                                 return NULL;
 86788:                         } else {
108876:                             pn3 = NameNode::create(PNK_STRING, atom, this, this->pc);
 82024:                             if (!pn3)
 82024:                                 return NULL;
 86788:                         }
 40794:                     } else if (tt == TOK_NUMBER) {
 98181:                         pn3 = NullaryNode::create(PNK_NUMBER, this);
 40794:                         if (!pn3)
 40794:                             return NULL;
 80817:                         pn3->pn_dval = tokenStream.currentToken().number();
102387:                         atom = ToAtom(context, DoubleValue(pn3->pn_dval));
102387:                         if (!atom)
 40794:                             return NULL;
 40794:                     } else {
 40794:                         tokenStream.ungetToken();
 98181:                         pn3 = NullaryNode::create(PNK_NAME, this);
 82024:                         if (!pn3)
 82024:                             return NULL;
 82024:                         pn3->pn_atom = atom;
 82024:                         break;
 40794:                     }
     1: 
 59962:                     pn->pn_xflags |= PNX_NONCONST;
 59962: 
 51087:                     /* NB: Getter function in { get x(){} } is unnamed. */
102586:                     Rooted<PropertyName*> funName(context, NULL);
102586:                     pn2 = functionDef(funName, op == JSOP_GETTER ? Getter : Setter, Expression);
 89334:                     if (!pn2)
 89334:                         return NULL;
 89334:                     TokenPos pos = {begin, pn2->pn_pos.end};
 89334:                     pn2 = new_<BinaryNode>(PNK_COLON, op, pos, pn3, pn2);
     1:                     goto skip;
     1:                 }
 86267:               case TOK_STRING: {
 80443:                 atom = tokenStream.currentToken().atom();
 86267:                 uint32_t index;
 86267:                 if (atom->isIndex(&index)) {
 98181:                     pn3 = NullaryNode::create(PNK_NUMBER, this);
 86267:                     if (!pn3)
 86267:                         return NULL;
 86267:                     pn3->pn_dval = index;
 86267:                 } else {
 98181:                     pn3 = NullaryNode::create(PNK_STRING, this);
 33749:                     if (!pn3)
 33749:                         return NULL;
 35310:                     pn3->pn_atom = atom;
 86267:                 }
     1:                 break;
 86267:               }
     1:               case TOK_RC:
     1:                 goto end_obj_init;
     1:               default:
102849:                 reportError(NULL, JSMSG_BAD_PROP_ID);
     1:                 return NULL;
     1:             }
     1: 
 40855:             op = JSOP_INITPROP;
 40354:             tt = tokenStream.getToken();
 37685:             if (tt == TOK_COLON) {
 40263:                 pnval = assignExpr();
 89334:                 if (!pnval)
 89334:                     return NULL;
 77448: 
 98181:                 if (foldConstants && !FoldConstants(context, pnval, this))
 97664:                     return NULL;
 97664: 
 77448:                 /*
 77448:                  * Treat initializers which mutate __proto__ as non-constant,
 77448:                  * so that we can later assume singleton objects delegate to
 77448:                  * the default Object.prototype.
 77448:                  */
 89334:                 if (!pnval->isConstant() || atom == context->runtime->atomState.protoAtom)
 59962:                     pn->pn_xflags |= PNX_NONCONST;
 77448:             }
 11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
 82469:             else if (ltok == TOK_NAME && (tt == TOK_COMMA || tt == TOK_RC)) {
 11039:                 /*
 11039:                  * Support, e.g., |var {x, y} = o| as destructuring shorthand
 11039:                  * for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.
 11039:                  */
 40354:                 tokenStream.ungetToken();
 81279:                 if (!tokenStream.checkForKeyword(atom->charsZ(), atom->length(), NULL, NULL))
 81279:                     return NULL;
 59962:                 pn->pn_xflags |= PNX_DESTRUCT | PNX_NONCONST;
 11039:                 pnval = pn3;
 82469:                 JS_ASSERT(pnval->isKind(PNK_NAME));
 78294:                 pnval->setArity(PN_NAME);
108876:                 ((NameNode *)pnval)->initCommon(pc);
 11039:             }
 11039: #endif
 82469:             else {
102849:                 reportError(NULL, JSMSG_COLON_AFTER_ID);
 82469:                 return NULL;
 11039:             }
 11039: 
 89334:             {
 89334:                 TokenPos pos = {begin, pnval->pn_pos.end};
 89334:                 pn2 = new_<BinaryNode>(PNK_COLON, op, pos, pn3, pnval);
 89334:             }
     1:           skip:
     1:             if (!pn2)
     1:                 return NULL;
 27012:             pn->append(pn2);
     1: 
 35310:             /*
 60213:              * Check for duplicate property names.  Duplicate data properties
 60213:              * only conflict in strict mode.  Duplicate getter or duplicate
 60213:              * setter halves always conflict.  A data property conflicts with
 60213:              * any part of an accessor property.
 60213:              */
 60213:             AssignmentType assignType;
 37685:             if (op == JSOP_INITPROP) {
 60213:                 assignType = VALUE;
 37685:             } else if (op == JSOP_GETTER) {
 60213:                 assignType = GET;
 37685:             } else if (op == JSOP_SETTER) {
 60213:                 assignType = SET;
 37685:             } else {
 35310:                 JS_NOT_REACHED("bad opcode in object initializer");
 60213:                 assignType = VALUE; /* try to error early */
 60213:             }
 60213: 
 72579:             AtomIndexAddPtr p = seen.lookupForAdd(atom);
 72579:             if (p) {
 72579:                 jsatomid index = p.value();
 72579:                 AssignmentType oldAssignType = AssignmentType(index);
 60213:                 if ((oldAssignType & assignType) &&
108876:                     (oldAssignType != VALUE || assignType != VALUE || pc->sc->needStrictChecks()))
 60213:                 {
 57812:                     JSAutoByteString name;
 60213:                     if (!js_AtomToPrintableString(context, atom, &name))
 60213:                         return NULL;
 60213: 
102849:                     Reporter reporter =
108876:                         (oldAssignType == VALUE && assignType == VALUE && !pc->sc->needStrictChecks())
102849:                         ? &Parser::reportWarning
108876:                         : (pc->sc->needStrictChecks() ? &Parser::reportStrictModeError : &Parser::reportError);
102849:                     if (!(this->*reporter)(NULL, JSMSG_DUPLICATE_PROPERTY, name.ptr()))
102849:                         return NULL;
 60213:                 }
 72579:                 p.value() = assignType | oldAssignType;
 35310:             } else {
 72579:                 if (!seen.add(p, atom, assignType))
 72579:                     return NULL;
 35310:             }
 35310: 
 40354:             tt = tokenStream.getToken();
     1:             if (tt == TOK_RC)
     1:                 goto end_obj_init;
     1:             if (tt != TOK_COMMA) {
102849:                 reportError(NULL, JSMSG_CURLY_AFTER_LIST);
     1:                 return NULL;
     1:             }
     1:         }
  1967: 
     1:       end_obj_init:
 40270:         pn->pn_pos.end = tokenStream.currentToken().pos.end;
     1:         return pn;
     1:       }
     1: 
  1967: #if JS_HAS_BLOCK_SCOPE
  1967:       case TOK_LET:
 86078:         pn = letBlock(LetExpresion);
  1967:         if (!pn)
  1967:             return NULL;
  1967:         break;
  1967: #endif
  1967: 
     1:       case TOK_LP:
  1577:       {
103824:         bool genexp;
  1577: 
 61058:         pn = parenExpr(&genexp);
     1:         if (!pn)
     1:             return NULL;
 78294:         pn->setInParens(true);
 31479:         if (!genexp)
     1:             MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_IN_PAREN);
     1:         break;
  1577:       }
     1: 
 86538:       case TOK_STRING:
 86538:         pn = atomNode(PNK_STRING, JSOP_STRING);
 86538:         if (!pn)
 86538:             return NULL;
 86538:         break;
 86538: 
     1: #if JS_HAS_XML_SUPPORT
 86538:       case TOK_AT:
     1:       case TOK_STAR:
104208:         if (!allowsXML())
104208:             goto syntaxerror;
 86538:         pn = starOrAtPropertyIdentifier(tt);
     1:         break;
     1: 
     1:       case TOK_XMLSTAGO:
104208:         if (!allowsXML())
104208:             goto syntaxerror;
103823:         pn = xmlElementOrListRoot(true);
     1:         if (!pn)
     1:             return NULL;
     1:         break;
 86538: 
     1:       case TOK_XMLCDATA:
104208:         if (!allowsXML())
104208:             goto syntaxerror;
 82024:         pn = atomNode(PNK_XMLCDATA, JSOP_XMLCDATA);
 82024:         if (!pn)
 82024:             return NULL;
 82024:         break;
 82024: 
     1:       case TOK_XMLCOMMENT:
104208:         if (!allowsXML())
104208:             goto syntaxerror;
 82024:         pn = atomNode(PNK_XMLCOMMENT, JSOP_XMLCOMMENT);
 82024:         if (!pn)
 82024:             return NULL;
 82024:         break;
 86538: 
 86378:       case TOK_XMLPI: {
104208:         if (!allowsXML())
104208:             goto syntaxerror;
 86378:         const Token &tok = tokenStream.currentToken();
 86378:         pn = new_<XMLProcessingInstruction>(tok.xmlPITarget(), tok.xmlPIData(), tok.pos);
 80443:         if (!pn)
 80443:             return NULL;
 80443:         break;
 86378:       }
 80291: #endif
 80286: 
 27012:       case TOK_NAME:
 88610:         pn = identifierName(afterDoubleDot);
     1:         break;
     1: 
  6561:       case TOK_REGEXP:
  6561:       {
 98181:         pn = NullaryNode::create(PNK_REGEXP, this);
  6561:         if (!pn)
  6561:             return NULL;
  6561: 
 79981:         const jschar *chars = tokenStream.getTokenbuf().begin();
 79981:         size_t length = tokenStream.getTokenbuf().length();
 80816:         RegExpFlag flags = tokenStream.currentToken().regExpFlags();
 79981:         RegExpStatics *res = context->regExpStatics();
 79981: 
 99421:         Rooted<RegExpObject*> reobj(context);
 79981:         if (context->hasfp())
 79981:             reobj = RegExpObject::create(context, res, chars, length, flags, &tokenStream);
 79981:         else
 79981:             reobj = RegExpObject::createNoStatics(context, chars, length, flags, &tokenStream);
 79981: 
 79981:         if (!reobj)
 79981:             return NULL;
 79981: 
 98464:         if (!compileAndGo) {
104205:             if (!JSObject::clearParent(context, reobj))
104205:                 return NULL;
104205:             if (!JSObject::clearType(context, reobj))
 83252:                 return NULL;
 79981:         }
 79981: 
 98181:         pn->pn_objbox = newObjectBox(reobj);
 27012:         if (!pn->pn_objbox)
  6561:             return NULL;
  6561: 
 78294:         pn->setOp(JSOP_REGEXP);
  6561:         break;
  6561:       }
  6561: 
     1:       case TOK_NUMBER:
 98181:         pn = NullaryNode::create(PNK_NUMBER, this);
     1:         if (!pn)
     1:             return NULL;
 78294:         pn->setOp(JSOP_DOUBLE);
 80817:         pn->pn_dval = tokenStream.currentToken().number();
     1:         break;
     1: 
 82022:       case TOK_TRUE:
 86381:         return new_<BooleanLiteral>(true, tokenStream.currentToken().pos);
 82022:       case TOK_FALSE:
 86381:         return new_<BooleanLiteral>(false, tokenStream.currentToken().pos);
 82022:       case TOK_THIS:
 86381:         return new_<ThisLiteral>(tokenStream.currentToken().pos);
 82022:       case TOK_NULL:
 86381:         return new_<NullLiteral>(tokenStream.currentToken().pos);
     1: 
107038:       case TOK_MOD:
108585:         if (selfHostingMode)
107038:             return intrinsicName();
107038:         else
107038:             goto syntaxerror;
107038: 
     1:       case TOK_ERROR:
     1:         /* The scanner or one of its subroutines reported the error. */
     1:         return NULL;
     1: 
104208:     syntaxerror:
     1:       default:
102849:         reportError(NULL, JSMSG_SYNTAX_ERROR);
     1:         return NULL;
     1:     }
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
103824: Parser::parenExpr(bool *genexp)
 40221: {
 40320:     TokenPtr begin;
 80631:     ParseNode *pn;
  1577: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LP);
 40270:     begin = tokenStream.currentToken().pos.begin;
  1577: 
  1577:     if (genexp)
103823:         *genexp = false;
 72073: 
 98181:     GenexpGuard guard(this);
 72073: 
 40263:     pn = bracketedExpr();
  1577:     if (!pn)
  1577:         return NULL;
 72073:     guard.endBody();
  1577: 
  1577: #if JS_HAS_GENERATOR_EXPRS
 40354:     if (tokenStream.matchToken(TOK_FOR)) {
 72073:         if (!guard.checkValidBody(pn))
 72073:             return NULL;
 82024:         JS_ASSERT(!pn->isKind(PNK_YIELD));
 82024:         if (pn->isKind(PNK_COMMA) && !pn->isInParens()) {
102849:             reportError(pn->last(), JSMSG_BAD_GENERATOR_SYNTAX, js_generator_str);
  1577:             return NULL;
  1577:         }
 61058:         pn = generatorExpr(pn);
 27012:         if (!pn)
 27012:             return NULL;
 26970:         pn->pn_pos.begin = begin;
  1577:         if (genexp) {
 40354:             if (tokenStream.getToken() != TOK_RP) {
102849:                 reportError(NULL, JSMSG_BAD_GENERATOR_SYNTAX, js_generator_str);
 40221:                 return NULL;
 40221:             }
 40270:             pn->pn_pos.end = tokenStream.currentToken().pos.end;
103823:             *genexp = true;
  1577:         }
 73053:     } else
  1577: #endif /* JS_HAS_GENERATOR_EXPRS */
  1577: 
 78006:     if (!guard.maybeNoteGenerator(pn))
 72565:         return NULL;
 72073: 
  1577:     return pn;
  1577: }
 98180: 
