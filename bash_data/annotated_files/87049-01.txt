54102: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
54102:  * vim: sw=2 ts=8 et :
54102:  */
54102: /* ***** BEGIN LICENSE BLOCK *****
54102:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54102:  *
54102:  * The contents of this file are subject to the Mozilla Public License Version
54102:  * 1.1 (the "License"); you may not use this file except in compliance with
54102:  * the License. You may obtain a copy of the License at:
54102:  * http://www.mozilla.org/MPL/
54102:  *
54102:  * Software distributed under the License is distributed on an "AS IS" basis,
54102:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54102:  * for the specific language governing rights and limitations under the
54102:  * License.
54102:  *
54102:  * The Original Code is Mozilla Code.
54102:  *
54102:  * The Initial Developer of the Original Code is
54102:  *   The Mozilla Foundation
54102:  * Portions created by the Initial Developer are Copyright (C) 2010
54102:  * the Initial Developer. All Rights Reserved.
54102:  *
54102:  * Contributor(s):
54102:  *   Chris Jones <jones.chris.g@gmail.com>
54102:  *
54102:  * Alternatively, the contents of this file may be used under the terms of
54102:  * either the GNU General Public License Version 2 or later (the "GPL"), or
54102:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54102:  * in which case the provisions of the GPL or the LGPL are applicable instead
54102:  * of those above. If you wish to allow use of your version of this file only
54102:  * under the terms of either the GPL or the LGPL, and not to allow others to
54102:  * use your version of this file under the terms of the MPL, indicate your
54102:  * decision by deleting the provisions above and replace them with the notice
54102:  * and other provisions required by the GPL or the LGPL. If you do not delete
54102:  * the provisions above, a recipient may use your version of this file under
54102:  * the terms of any one of the MPL, the GPL or the LGPL.
54102:  *
54102:  * ***** END LICENSE BLOCK ***** */
54102: 
54108: #include "mozilla/layers/PLayers.h"
54108: #include "mozilla/layers/ShadowLayers.h"
54108:  
54108: #include "gfxPlatform.h"
54102: 
54102: #include "gfxXlibSurface.h"
54102: #include "mozilla/X11Util.h"
87049: #include "cairo-xlib.h"
54102: 
54102: namespace mozilla {
54102: namespace layers {
54102: 
54593: // Return true if we're likely compositing using X and so should use
54593: // Xlib surfaces in shadow layers.
79445: static bool
54593: UsingXCompositing()
54593: {
54593:   return (gfxASurface::SurfaceTypeXlib ==
54593:           gfxPlatform::GetPlatform()->ScreenReferenceSurface()->GetType());
54593: }
54593: 
54102: // LookReturn a pointer to |aFormat| that lives in the Xrender library.
54102: // All code using render formats assumes it doesn't need to copy.
54102: static XRenderPictFormat*
54102: GetXRenderPictFormatFromId(Display* aDisplay, PictFormat aFormatId)
54102: {
54102:   XRenderPictFormat tmplate;
54102:   tmplate.id = aFormatId;
54102:   return XRenderFindFormat(aDisplay, PictFormatID, &tmplate, 0);
54102: }
54102: 
79445: static bool
54108: TakeAndDestroyXlibSurface(SurfaceDescriptor* aSurface)
54108: {
54108:   nsRefPtr<gfxXlibSurface> surf =
54108:     aSurface->get_SurfaceDescriptorX11().OpenForeign();
54108:   surf->TakePixmap();
54108:   *aSurface = SurfaceDescriptor();
54108:   // the Pixmap is destroyed when |surf| goes out of scope
80486:   return true;
54108: }
54108: 
54102: SurfaceDescriptorX11::SurfaceDescriptorX11(gfxXlibSurface* aSurf)
54102:   : mId(aSurf->XDrawable())
54102:   , mSize(aSurf->GetSize())
87049: {
87049:   const XRenderPictFormat *pictFormat = aSurf->XRenderFormat();
87049:   if (pictFormat) {
87049:     mFormat = pictFormat->id;
87049:   } else {
87049:     mFormat = cairo_xlib_surface_get_visual(aSurf->CairoSurface())->visualid;
87049:   }
87049: }
54102: 
87049: SurfaceDescriptorX11::SurfaceDescriptorX11(Drawable aDrawable, XID aFormatID,
87049:                                            const gfxIntSize& aSize)
87049:   : mId(aDrawable)
87049:   , mFormat(aFormatID)
78514:   , mSize(aSize)
78514: { }
78514: 
54102: already_AddRefed<gfxXlibSurface>
54102: SurfaceDescriptorX11::OpenForeign() const
54102: {
54102:   Display* display = DefaultXDisplay();
54102:   Screen* screen = DefaultScreenOfDisplay(display);
54102: 
87049:   nsRefPtr<gfxXlibSurface> surf;
87049:   XRenderPictFormat* pictFormat = GetXRenderPictFormatFromId(display, mFormat);
87049:   if (pictFormat) {
87049:     surf = new gfxXlibSurface(screen, mId, pictFormat, mSize);
87049:   } else {
87049:     Visual* visual = NULL;
87049:     unsigned int depth;
87049:     XVisualIDToInfo(display, mFormat, &visual, &depth);
87049:     if (!visual)
87049:       return nsnull;
87049: 
87049:     surf = new gfxXlibSurface(display, mId, visual, mSize);
87049:   }
54102:   return surf->CairoStatus() ? nsnull : surf.forget();
54102: }
54102: 
79445: bool
54108: ShadowLayerForwarder::PlatformAllocDoubleBuffer(const gfxIntSize& aSize,
54108:                                                 gfxASurface::gfxContentType aContent,
54108:                                                 SurfaceDescriptor* aFrontBuffer,
54108:                                                 SurfaceDescriptor* aBackBuffer)
54108: {
59744:   return (PlatformAllocBuffer(aSize, aContent, aFrontBuffer) &&
59744:           PlatformAllocBuffer(aSize, aContent, aBackBuffer));
59744: }
59744: 
79445: bool
59744: ShadowLayerForwarder::PlatformAllocBuffer(const gfxIntSize& aSize,
59744:                                           gfxASurface::gfxContentType aContent,
59744:                                           SurfaceDescriptor* aBuffer)
59744: {
54593:   if (!UsingXCompositing()) {
54593:     // If we're not using X compositing, we're probably compositing on
54593:     // the client side, in which case X surfaces would just slow
54593:     // things down.  Use Shmem instead.
80486:     return false;
54593:   }
54593: 
54287:   gfxPlatform* platform = gfxPlatform::GetPlatform();
59744:   nsRefPtr<gfxASurface> buffer = platform->CreateOffscreenSurface(aSize, aContent);
59744:   if (!buffer ||
59744:       buffer->GetType() != gfxASurface::SurfaceTypeXlib) {
54108:     NS_ERROR("creating Xlib front/back surfaces failed!");
80486:     return false;
54108:   }
54108: 
59744:   gfxXlibSurface* bufferX = static_cast<gfxXlibSurface*>(buffer.get());
54108:   // Release Pixmap ownership to the layers model
59744:   bufferX->ReleasePixmap();
54108: 
59744:   *aBuffer = SurfaceDescriptorX11(bufferX);
80486:   return true;
54108: }
54108: 
54108: /*static*/ already_AddRefed<gfxASurface>
54108: ShadowLayerForwarder::PlatformOpenDescriptor(const SurfaceDescriptor& aSurface)
54108: {
54108:   if (SurfaceDescriptor::TSurfaceDescriptorX11 != aSurface.type()) {
54108:     return nsnull;
54108:   }
54108:   return aSurface.get_SurfaceDescriptorX11().OpenForeign();
54108: }
54108: 
79445: bool
54108: ShadowLayerForwarder::PlatformDestroySharedSurface(SurfaceDescriptor* aSurface)
54108: {
54108:   if (SurfaceDescriptor::TSurfaceDescriptorX11 != aSurface->type()) {
80486:     return false;
54108:   }
54108:   return TakeAndDestroyXlibSurface(aSurface);
54108: }
54108: 
54108: /*static*/ void
54108: ShadowLayerForwarder::PlatformSyncBeforeUpdate()
54108: {
54593:   if (UsingXCompositing()) {
54593:     // If we're using X surfaces, then we need to finish all pending
54593:     // operations on the back buffers before handing them to the
54593:     // parent, otherwise the surface might be used by the parent's
54593:     // Display in between two operations queued by our Display.
54108:     XSync(DefaultXDisplay(), False);
54108:   }
54593: }
54108: 
54108: /*static*/ void
54108: ShadowLayerManager::PlatformSyncBeforeReplyUpdate()
54108: {
54593:   if (UsingXCompositing()) {
54593:     // If we're using X surfaces, we need to finish all pending
54593:     // operations on the *front buffers* before handing them back to
54593:     // the child, even though they will be read operations.
54593:     // Otherwise, the child might start scribbling on new back buffers
54593:     // that are still participating in requests as old front buffers.
54108:     XSync(DefaultXDisplay(), False);
54108:   }
54593: }
54108: 
79445: bool
54108: ShadowLayerManager::PlatformDestroySharedSurface(SurfaceDescriptor* aSurface)
54108: {
54108:   if (SurfaceDescriptor::TSurfaceDescriptorX11 != aSurface->type()) {
80486:     return false;
54108:   }
54108:   return TakeAndDestroyXlibSurface(aSurface);
54108: }
54108: 
54102: } // namespace layers
54102: } // namespace mozilla
