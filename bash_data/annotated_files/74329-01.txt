57812: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
23126:  * vim: set ts=8 sw=4 et tw=99:
23126:  *
23126:  * ***** BEGIN LICENSE BLOCK *****
23126:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
23126:  *
23126:  * The contents of this file are subject to the Mozilla Public License Version
23126:  * 1.1 (the "License"); you may not use this file except in compliance with
23126:  * the License. You may obtain a copy of the License at
23126:  * http://www.mozilla.org/MPL/
23126:  *
23126:  * Software distributed under the License is distributed on an "AS IS" basis,
23126:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
23126:  * for the specific language governing rights and limitations under the
23126:  * License.
23126:  *
23126:  * The Original Code is Mozilla Communicator client code, released
23126:  * March 31, 1998.
23126:  *
23126:  * The Initial Developer of the Original Code is
23126:  * Netscape Communications Corporation.
23126:  * Portions created by the Initial Developer are Copyright (C) 1998
23126:  * the Initial Developer. All Rights Reserved.
23126:  *
23126:  * Contributor(s):
23126:  *
23126:  * Alternatively, the contents of this file may be used under the terms of
23126:  * either of the GNU General Public License Version 2 or later (the "GPL"),
23126:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
23126:  * in which case the provisions of the GPL or the LGPL are applicable instead
23126:  * of those above. If you wish to allow use of your version of this file only
23126:  * under the terms of either the GPL or the LGPL, and not to allow others to
23126:  * use your version of this file under the terms of the MPL, indicate your
23126:  * decision by deleting the provisions above and replace them with the notice
23126:  * and other provisions required by the GPL or the LGPL. If you do not delete
23126:  * the provisions above, a recipient may use your version of this file under
23126:  * the terms of any one of the MPL, the GPL or the LGPL.
23126:  *
23126:  * ***** END LICENSE BLOCK ***** */
23126: 
48470: #define __STDC_LIMIT_MACROS
48470: 
23126: /*
23126:  * JS shell.
23126:  */
23126: #include <errno.h>
25472: #include <math.h>
23126: #include <stdio.h>
23126: #include <stdlib.h>
23126: #include <string.h>
25098: #include <signal.h>
23126: #include <locale.h>
23126: #include "jstypes.h"
40828: #include "jsstdint.h"
23126: #include "jsarena.h"
23126: #include "jsutil.h"
23126: #include "jsprf.h"
43264: #include "jswrapper.h"
23126: #include "jsapi.h"
23126: #include "jsarray.h"
23126: #include "jsatom.h"
23126: #include "jsbuiltins.h"
23126: #include "jscntxt.h"
25087: #include "jsdate.h"
23126: #include "jsdbgapi.h"
23126: #include "jsemit.h"
23126: #include "jsfun.h"
23126: #include "jsgc.h"
27012: #include "jsiter.h"
23126: #include "jslock.h"
23126: #include "jsnum.h"
23126: #include "jsobj.h"
67934: #include "json.h"
23126: #include "jsparse.h"
51110: #include "jsreflect.h"
23126: #include "jsscope.h"
23126: #include "jsscript.h"
54863: #include "jstypedarray.h"
42742: #include "jsxml.h"
48637: #include "jsperf.h"
23126: 
25087: #include "prmjtime.h"
25087: 
23126: #ifdef JSDEBUGGER
23126: #include "jsdebug.h"
23126: #ifdef JSDEBUGGER_JAVA_UI
23126: #include "jsdjava.h"
23126: #endif /* JSDEBUGGER_JAVA_UI */
23126: #ifdef JSDEBUGGER_C_UI
23126: #include "jsdb.h"
23126: #endif /* JSDEBUGGER_C_UI */
23126: #endif /* JSDEBUGGER */
23126: 
74072: #include "jsoptparse.h"
40801: #include "jsworkers.h"
40801: 
53840: #include "jsinterpinlines.h"
42733: #include "jsobjinlines.h"
48470: #include "jsscriptinlines.h"
69852: #include "methodjit/MethodJIT.h"
42733: 
23126: #ifdef XP_UNIX
23126: #include <unistd.h>
23126: #include <sys/types.h>
23126: #include <sys/wait.h>
23126: #endif
23126: 
23126: #if defined(XP_WIN) || defined(XP_OS2)
23126: #include <io.h>     /* for isatty() */
23126: #endif
23126: 
26053: #ifdef XP_WIN
52897: #include "jswin.h"
26053: #endif
26053: 
38585: using namespace js;
74072: using namespace js::cli;
38585: 
23126: typedef enum JSShellExitCode {
23126:     EXITCODE_RUNTIME_ERROR      = 3,
23126:     EXITCODE_FILE_NOT_FOUND     = 4,
25472:     EXITCODE_OUT_OF_MEMORY      = 5,
25472:     EXITCODE_TIMEOUT            = 6
23126: } JSShellExitCode;
23126: 
23126: size_t gStackChunkSize = 8192;
23126: 
23126: /* Assume that we can not use more than 5e5 bytes of C stack by default. */
57726: #if (defined(DEBUG) && defined(__SUNPRO_CC))  || defined(JS_CPU_SPARC)
39974: /* Sun compiler uses larger stack space for js_Interpret() with debug
39974:    Use a bigger gMaxStackSize to make "make check" happy. */
56544: #define DEFAULT_MAX_STACK_SIZE 5000000
39974: #else
56544: #define DEFAULT_MAX_STACK_SIZE 500000
39974: #endif
39974: 
56544: size_t gMaxStackSize = DEFAULT_MAX_STACK_SIZE;
56544: 
26673: 
26673: #ifdef JS_THREADSAFE
26673: static PRUintn gStackBaseThreadIndex;
26673: #else
23126: static jsuword gStackBase;
26673: #endif
23126: 
25472: /*
25472:  * Limit the timeout to 30 minutes to prevent an overflow on platfoms
25472:  * that represent the time internally in microseconds using 32-bit int.
25472:  */
25472: static jsdouble MAX_TIMEOUT_INTERVAL = 1800.0;
25472: static jsdouble gTimeoutInterval = -1.0;
25472: static volatile bool gCanceled = false;
25087: 
52557: static bool enableTraceJit = false;
52557: static bool enableMethodJit = false;
56551: static bool enableProfiling = false;
71701: static bool enableDisassemblyDumps = false;
33747: 
56181: static bool printTiming = false;
56181: 
25087: static JSBool
25087: SetTimeoutValue(JSContext *cx, jsdouble t);
25087: 
25472: static bool
25472: InitWatchdog(JSRuntime *rt);
25087: 
25087: static void
25472: KillWatchdog();
25472: 
25472: static bool
25472: ScheduleWatchdog(JSRuntime *rt, jsdouble t);
25472: 
25472: static void
25472: CancelExecution(JSRuntime *rt);
23126: 
23726: /*
23726:  * Watchdog thread state.
23726:  */
23726: #ifdef JS_THREADSAFE
25472: 
25472: static PRLock *gWatchdogLock = NULL;
25087: static PRCondVar *gWatchdogWakeup = NULL;
25087: static PRThread *gWatchdogThread = NULL;
25472: static bool gWatchdogHasTimeout = false;
25472: static PRIntervalTime gWatchdogTimeout = 0;
25472: 
25472: static PRCondVar *gSleepWakeup = NULL;
25087: 
25087: #else
25472: 
25087: static JSRuntime *gRuntime = NULL;
25087: 
23726: #endif
23726: 
23126: int gExitCode = 0;
23126: JSBool gQuitting = JS_FALSE;
23126: FILE *gErrFile = NULL;
23126: FILE *gOutFile = NULL;
40801: #ifdef JS_THREADSAFE
40801: JSObject *gWorkers = NULL;
55619: js::workers::ThreadPool *gWorkerThreadPool = NULL;
40801: #endif
23126: 
23126: static JSBool reportWarnings = JS_TRUE;
23126: static JSBool compileOnly = JS_FALSE;
23126: 
64328: #ifdef DEBUG
64323: static JSBool OOM_printAllocationCount = JS_FALSE;
64328: #endif
64323: 
23126: typedef enum JSShellErrNum {
23126: #define MSG_DEF(name, number, count, exception, format) \
23126:     name = number,
23126: #include "jsshell.msg"
23126: #undef MSG_DEF
23126:     JSShellErr_Limit
23126: #undef MSGDEF
23126: } JSShellErrNum;
23126: 
40801: static JSContext *
40801: NewContext(JSRuntime *rt);
40801: 
40801: static void
40801: DestroyContext(JSContext *cx, bool withGC);
40801: 
23126: static const JSErrorFormatString *
23126: my_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber);
35108: 
23126: static JSObject *
35108: split_setup(JSContext *cx, JSBool evalcx);
23126: 
23126: #ifdef EDITLINE
23126: JS_BEGIN_EXTERN_C
23908: JS_EXTERN_API(char)    *readline(const char *prompt);
23908: JS_EXTERN_API(void)     add_history(char *line);
23126: JS_END_EXTERN_C
23126: #endif
23126: 
47498: static void
47498: ReportException(JSContext *cx)
47498: {
47498:     if (JS_IsExceptionPending(cx)) {
47498:         if (!JS_ReportPendingException(cx))
47498:             JS_ClearPendingException(cx);
47498:     }
47498: }
47498: 
31366: class ToString {
31366:   public:
31366:     ToString(JSContext *aCx, jsval v, JSBool aThrow = JS_FALSE)
57812:       : cx(aCx), mThrow(aThrow)
31366:     {
31366:         mStr = JS_ValueToString(cx, v);
47498:         if (!aThrow && !mStr)
47498:             ReportException(cx);
47403:         JS_AddNamedStringRoot(cx, &mStr, "Value ToString helper");
31366:     }
31366:     ~ToString() {
47403:         JS_RemoveStringRoot(cx, &mStr);
31366:     }
31366:     JSBool threw() { return !mStr; }
31366:     jsval getJSVal() { return STRING_TO_JSVAL(mStr); }
31366:     const char *getBytes() {
57812:         if (mStr && (mBytes.ptr() || mBytes.encode(cx, mStr)))
57812:             return mBytes.ptr();
57812:         return "(error converting value)";
31366:     }
31366:   private:
31366:     JSContext *cx;
31366:     JSString *mStr;
31366:     JSBool mThrow;
57812:     JSAutoByteString mBytes;
31366: };
31366: 
67930: class IdStringifier : public ToString {
48470: public:
67930:     IdStringifier(JSContext *cx, jsid id, JSBool aThrow = JS_FALSE)
48470:     : ToString(cx, IdToJsval(id), aThrow)
48470:     { }
48470: };
48470: 
23723: static char *
23723: GetLine(FILE *file, const char * prompt)
23723: {
23723:     size_t size;
23723:     char *buffer;
23126: #ifdef EDITLINE
23126:     /*
23126:      * Use readline only if file is stdin, because there's no way to specify
23126:      * another handle.  Are other filehandles interactive?
23126:      */
23126:     if (file == stdin) {
23126:         char *linep = readline(prompt);
23723:         /*
23723:          * We set it to zero to avoid complaining about inappropriate ioctl
23723:          * for device in the case of EOF. Looks like errno == 251 if line is
25486:          * finished with EOF and errno == 25 (EINVAL on Mac) if there is
25486:          * nothing left to read.
23723:          */
25486:         if (errno == 251 || errno == 25 || errno == EINVAL)
23723:             errno = 0;
23126:         if (!linep)
23723:             return NULL;
23126:         if (linep[0] != '\0')
23126:             add_history(linep);
23723:         return linep;
23723:     }
23126: #endif
23723:     size_t len = 0;
23723:     if (*prompt != '\0') {
25469:         fprintf(gOutFile, "%s", prompt);
23126:         fflush(gOutFile);
23723:     }
23723:     size = 80;
23723:     buffer = (char *) malloc(size);
23723:     if (!buffer)
23723:         return NULL;
23723:     char *current = buffer;
23723:     while (fgets(current, size - len, file)) {
23723:         len += strlen(current);
23723:         char *t = buffer + len - 1;
23723:         if (*t == '\n') {
23723:             /* Line was read. We remove '\n' and exit. */
23723:             *t = '\0';
23723:             return buffer;
23723:         }
23723:         if (len + 1 == size) {
23723:             size = size * 2;
23723:             char *tmp = (char *) realloc(buffer, size);
23723:             if (!tmp) {
23723:                 free(buffer);
23723:                 return NULL;
23723:             }
23723:             buffer = tmp;
23723:         }
23723:         current = buffer + len;
23723:     }
23723:     if (len && !ferror(file))
23723:         return buffer;
23723:     free(buffer);
23723:     return NULL;
23457: }
23457: 
23726: /*
23726:  * State to store as JSContext private.
23726:  *
25087:  * We declare such timestamp as volatile as they are updated in the operation
23726:  * callback without taking any locks. Any possible race can only lead to more
23726:  * frequent callback calls. This is safe as the callback does everything based
23726:  * on timing.
23726:  */
23457: struct JSShellContextData {
25087:     volatile JSIntervalTime startTime;
23457: };
23457: 
23457: static JSShellContextData *
23457: NewContextData()
23457: {
25472:     /* Prevent creation of new contexts after we have been canceled. */
25472:     if (gCanceled)
25472:         return NULL;
25472: 
23457:     JSShellContextData *data = (JSShellContextData *)
25087:                                calloc(sizeof(JSShellContextData), 1);
23457:     if (!data)
23457:         return NULL;
25087:     data->startTime = js_IntervalNow();
23457:     return data;
23457: }
23457: 
23457: static inline JSShellContextData *
23457: GetContextData(JSContext *cx)
23457: {
23457:     JSShellContextData *data = (JSShellContextData *) JS_GetContextPrivate(cx);
23457: 
23457:     JS_ASSERT(data);
23457:     return data;
23457: }
23457: 
23126: static JSBool
23457: ShellOperationCallback(JSContext *cx)
23126: {
25709:     if (!gCanceled)
25709:         return JS_TRUE;
25709: 
25709:     JS_ClearPendingException(cx);
25709:     return JS_FALSE;
23126: }
23126: 
23126: static void
26673: SetContextOptions(JSContext *cx)
26673: {
42740:     JS_SetNativeStackQuota(cx, gMaxStackSize);
25087:     JS_SetOperationCallback(cx, ShellOperationCallback);
23126: }
23126: 
73992: /*
73992:  * Some UTF-8 files, notably those written using Notepad, have a Unicode
73992:  * Byte-Order-Mark (BOM) as their first character. This is useless (byte-order
73992:  * is meaningless for UTF-8) but causes a syntax error unless we skip it.
73992:  */
73992: static void
73993: SkipUTF8BOM(FILE* file)
73992: {
73992:     if (!js_CStringsAreUTF8)
73992:         return;
73992: 
73992:     int ch1 = fgetc(file);
73992:     int ch2 = fgetc(file);
73992:     int ch3 = fgetc(file);
73992: 
73992:     // Skip the BOM
73992:     if (ch1 == 0xEF && ch2 == 0xBB && ch3 == 0xBF)
73992:         return;
73992: 
73992:     // No BOM - revert
73992:     if (ch3 != EOF)
73992:         ungetc(ch3, file);
73992:     if (ch2 != EOF)
73992:         ungetc(ch2, file);
73992:     if (ch1 != EOF)
73992:         ungetc(ch1, file);
73992: }
73992: 
23126: static void
74072: Process(JSContext *cx, JSObject *obj, const char *filename, bool forceTTY)
23126: {
23126:     JSBool ok, hitEOF;
64190:     JSObject *scriptObj;
23126:     jsval result;
23126:     JSString *str;
23723:     char *buffer;
24199:     size_t size;
68907:     jschar *uc_buffer;
68907:     size_t uc_len;
23126:     int lineno;
23126:     int startline;
23126:     FILE *file;
23126:     uint32 oldopts;
23126: 
23126:     if (forceTTY || !filename || strcmp(filename, "-") == 0) {
23126:         file = stdin;
23126:     } else {
23126:         file = fopen(filename, "r");
23126:         if (!file) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_CANT_OPEN, filename, strerror(errno));
23126:             gExitCode = EXITCODE_FILE_NOT_FOUND;
23126:             return;
23126:         }
23126:     }
23126: 
23126:     SetContextOptions(cx);
23126: 
37620:     if (!forceTTY && !isatty(fileno(file)))
37620:     {
73993:         SkipUTF8BOM(file);
73992: 
23126:         /*
23126:          * It's not interactive - just execute it.
23126:          *
23126:          * Support the UNIX #! shell hack; gobble the first line if it starts
23126:          * with '#'.  TODO - this isn't quite compatible with sharp variables,
23126:          * as a legal js program (using sharp variables) might start with '#'.
23126:          * But that would require multi-character lookahead.
23126:          */
23126:         int ch = fgetc(file);
23126:         if (ch == '#') {
23126:             while((ch = fgetc(file)) != EOF) {
23126:                 if (ch == '\n' || ch == '\r')
23126:                     break;
23126:             }
23126:         }
23126:         ungetc(ch, file);
23126: 
56181:         int64 t1 = PRMJ_Now();
23126:         oldopts = JS_GetOptions(cx);
23126:         JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
64190:         scriptObj = JS_CompileFileHandle(cx, obj, filename, file);
23126:         JS_SetOptions(cx, oldopts);
64190:         if (scriptObj && !compileOnly) {
64190:             (void) JS_ExecuteScript(cx, obj, scriptObj, NULL);
56181:             int64 t2 = PRMJ_Now() - t1;
56181:             if (printTiming)
56181:                 printf("runtime = %.3f ms\n", double(t2) / PRMJ_USEC_PER_MSEC);
56181:         }
23126: 
58984:         goto cleanup;
23126:     }
23126: 
23126:     /* It's an interactive filehandle; drop into read-eval-print loop. */
23126:     lineno = 1;
23126:     hitEOF = JS_FALSE;
23723:     buffer = NULL;
24199:     size = 0;           /* assign here to avoid warnings */
23126:     do {
23126:         /*
23126:          * Accumulate lines until we get a 'compilable unit' - one that either
23126:          * generates an error (before running out of source) or that compiles
23126:          * cleanly.  This should be whenever we get a complete statement that
23126:          * coincides with the end of a line.
23126:          */
23126:         startline = lineno;
25472:         size_t len = 0; /* initialize to avoid warnings */
23126:         do {
25472:             ScheduleWatchdog(cx->runtime, -1);
25472:             gCanceled = false;
23723:             errno = 0;
40289: 
40289:             char *line;
40289:             {
40289:                 JSAutoSuspendRequest suspended(cx);
40289:                 line = GetLine(file, startline == lineno ? "js> " : "");
40289:             }
23723:             if (!line) {
23723:                 if (errno) {
23723:                     JS_ReportError(cx, strerror(errno));
23723:                     free(buffer);
58984:                     goto cleanup;
23723:                 }
23126:                 hitEOF = JS_TRUE;
23126:                 break;
23126:             }
23723:             if (!buffer) {
23723:                 buffer = line;
23723:                 len = strlen(buffer);
23723:                 size = len + 1;
23723:             } else {
24198:                 /*
24198:                  * len + 1 is required to store '\n' in the end of line.
23723:                  */
23723:                 size_t newlen = strlen(line) + (len ? len + 1 : 0);
23723:                 if (newlen + 1 > size) {
23723:                     size = newlen + 1 > size * 2 ? newlen + 1 : size * 2;
23723:                     char *newBuf = (char *) realloc(buffer, size);
23723:                     if (!newBuf) {
23723:                         free(buffer);
23723:                         free(line);
23723:                         JS_ReportOutOfMemory(cx);
58984:                         goto cleanup;
23723:                     }
23723:                     buffer = newBuf;
23723:                 }
23723:                 char *current = buffer + len;
23723:                 if (startline != lineno)
23723:                     *current++ = '\n';
23723:                 strcpy(current, line);
23723:                 len = newlen;
23723:                 free(line);
23723:             }
23126:             lineno++;
25472:             if (!ScheduleWatchdog(cx->runtime, gTimeoutInterval)) {
25472:                 hitEOF = JS_TRUE;
25472:                 break;
25472:             }
68907:         } while (!JS_BufferIsCompilableUnit(cx, JS_TRUE, obj, buffer, len));
23126: 
24239:         if (hitEOF && !buffer)
23733:             break;
23733: 
68907:         if (!JS_DecodeUTF8(cx, buffer, len, NULL, &uc_len)) {
68907:             JS_ReportError(cx, "Invalid UTF-8 in input");
68907:             gExitCode = EXITCODE_RUNTIME_ERROR;
68907:             return;
68907:         }
68907: 
68907:         uc_buffer = (jschar*)malloc(uc_len * sizeof(jschar));
68907:         JS_DecodeUTF8(cx, buffer, len, uc_buffer, &uc_len);
68907: 
23126:         /* Clear any pending exception from previous failed compiles. */
23126:         JS_ClearPendingException(cx);
24148: 
24148:         /* Even though we're interactive, we have a compile-n-go opportunity. */
24148:         oldopts = JS_GetOptions(cx);
24148:         if (!compileOnly)
24148:             JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO);
68907:         scriptObj = JS_CompileUCScript(cx, obj, uc_buffer, uc_len, "typein",
23126:                                        startline);
24148:         if (!compileOnly)
24148:             JS_SetOptions(cx, oldopts);
24148: 
64190:         if (scriptObj && !compileOnly) {
64190:             ok = JS_ExecuteScript(cx, obj, scriptObj, &result);
23126:             if (ok && !JSVAL_IS_VOID(result)) {
32781:                 str = JS_ValueToSource(cx, result);
57812:                 ok = !!str;
57812:                 if (ok) {
57812:                     JSAutoByteString bytes(cx, str);
57812:                     ok = !!bytes;
57812:                     if (ok)
57812:                         fprintf(gOutFile, "%s\n", bytes.ptr());
57812:                 }
23126:             }
23126:         }
23723:         *buffer = '\0';
68907:         free(uc_buffer);
24304:     } while (!hitEOF && !gQuitting);
23733: 
23723:     free(buffer);
23126:     fprintf(gOutFile, "\n");
58984: cleanup:
23126:     if (file != stdin)
23126:         fclose(file);
23126:     return;
23126: }
23126: 
23126: /*
23126:  * JSContext option name to flag map. The option names are in alphabetical
23126:  * order for better reporting.
23126:  */
23126: static const struct {
23126:     const char  *name;
23126:     uint32      flag;
23126: } js_options[] = {
23126:     {"atline",          JSOPTION_ATLINE},
62574:     {"jitprofiling",    JSOPTION_PROFILING},
52557:     {"tracejit",        JSOPTION_JIT},
52557:     {"methodjit",       JSOPTION_METHODJIT},
62574:     {"methodjit_always",JSOPTION_METHODJIT_ALWAYS},
23126:     {"relimit",         JSOPTION_RELIMIT},
23126:     {"strict",          JSOPTION_STRICT},
23126:     {"werror",          JSOPTION_WERROR},
23126:     {"xml",             JSOPTION_XML},
23126: };
23126: 
23126: static uint32
23126: MapContextOptionNameToFlag(JSContext* cx, const char* name)
23126: {
23126:     for (size_t i = 0; i != JS_ARRAY_LENGTH(js_options); ++i) {
23126:         if (strcmp(name, js_options[i].name) == 0)
23126:             return js_options[i].flag;
23126:     }
23126: 
23126:     char* msg = JS_sprintf_append(NULL,
23126:                                   "unknown option name '%s'."
23126:                                   " The valid names are ", name);
23126:     for (size_t i = 0; i != JS_ARRAY_LENGTH(js_options); ++i) {
23126:         if (!msg)
23126:             break;
23126:         msg = JS_sprintf_append(msg, "%s%s", js_options[i].name,
23126:                                 (i + 2 < JS_ARRAY_LENGTH(js_options)
23126:                                  ? ", "
23126:                                  : i + 2 == JS_ARRAY_LENGTH(js_options)
23126:                                  ? " and "
23126:                                  : "."));
23126:     }
23126:     if (!msg) {
23126:         JS_ReportOutOfMemory(cx);
23126:     } else {
23126:         JS_ReportError(cx, msg);
23126:         free(msg);
23126:     }
23126:     return 0;
23126: }
23126: 
23126: extern JSClass global_class;
23126: 
37741: #if defined(JS_TRACER) && defined(DEBUG)
37741: namespace js {
37741:     extern struct JSClass jitstats_class;
37741:     void InitJITStatsClass(JSContext *cx, JSObject *glob);
37741: }
37741: #endif
37741: 
71353: #ifdef JS_GC_ZEAL
71353: static void
71353: ParseZealArg(JSContext *cx, const char *arg)
71353: {
71353:     int zeal, freq = 1, compartment = 0;
71353:     const char *p = strchr(arg, ',');
71353: 
71353:     zeal = atoi(arg);
71353:     if (p) {
71353:         freq = atoi(p + 1);
71353:         p = strchr(p + 1, ',');
71353:         if (p)
71353:             compartment = atoi(p + 1);
71353:     }
71353: 
71705:     JS_SetGCZeal(cx, (uint8)zeal, freq, !!compartment);
71353: }
71353: #endif
71353: 
23126: static JSBool
53557: Version(JSContext *cx, uintN argc, jsval *vp)
23126: {
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     if (argc > 0 && JSVAL_IS_INT(argv[0]))
53557:         *vp = INT_TO_JSVAL(JS_SetVersion(cx, (JSVersion) JSVAL_TO_INT(argv[0])));
23126:     else
53557:         *vp = INT_TO_JSVAL(JS_GetVersion(cx));
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53848: RevertVersion(JSContext *cx, uintN argc, jsval *vp)
53848: {
53848:     js_RevertVersion(cx);
53848:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53848:     return JS_TRUE;
53848: }
53848: 
53848: static JSBool
53557: Options(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     uint32 optset, flag;
23126:     JSString *str;
23126:     char *names;
23126:     JSBool found;
23126: 
23126:     optset = 0;
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     for (uintN i = 0; i < argc; i++) {
23126:         str = JS_ValueToString(cx, argv[i]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         argv[i] = STRING_TO_JSVAL(str);
57812:         JSAutoByteString opt(cx, str);
23126:         if (!opt)
23126:             return JS_FALSE;
57812:         flag = MapContextOptionNameToFlag(cx, opt.ptr());
23126:         if (!flag)
23126:             return JS_FALSE;
23126:         optset |= flag;
23126:     }
23126:     optset = JS_ToggleOptions(cx, optset);
23126: 
23126:     names = NULL;
23126:     found = JS_FALSE;
23126:     for (size_t i = 0; i != JS_ARRAY_LENGTH(js_options); i++) {
23126:         if (js_options[i].flag & optset) {
23126:             found = JS_TRUE;
23126:             names = JS_sprintf_append(names, "%s%s",
23126:                                       names ? "," : "", js_options[i].name);
23126:             if (!names)
23126:                 break;
23126:         }
23126:     }
23126:     if (!found)
23126:         names = strdup("");
23126:     if (!names) {
23126:         JS_ReportOutOfMemory(cx);
23126:         return JS_FALSE;
23126:     }
59008:     str = JS_NewStringCopyZ(cx, names);
23126:     free(names);
59008:     if (!str)
23126:         return JS_FALSE;
53557:     *vp = STRING_TO_JSVAL(str);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53557: Load(JSContext *cx, uintN argc, jsval *vp)
23126: {
53557:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
53557:     if (!thisobj)
53557:         return JS_FALSE;
53557: 
53557:     jsval *argv = JS_ARGV(cx, vp);
64190:     for (uintN i = 0; i < argc; i++) {
64190:         JSString *str = JS_ValueToString(cx, argv[i]);
23126:         if (!str)
64190:             return false;
23126:         argv[i] = STRING_TO_JSVAL(str);
57812:         JSAutoByteString filename(cx, str);
57812:         if (!filename)
57812:             return JS_FALSE;
23126:         errno = 0;
64190:         uint32 oldopts = JS_GetOptions(cx);
23126:         JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
64190:         JSObject *scriptObj = JS_CompileFile(cx, thisobj, filename.ptr());
23126:         JS_SetOptions(cx, oldopts);
64190:         if (!scriptObj)
64190:             return false;
64190: 
64190:         if (!compileOnly && !JS_ExecuteScript(cx, thisobj, scriptObj, NULL))
64190:             return false;
64190:     }
64190: 
64190:     return true;
23126: }
23126: 
61216: static JSBool
61216: Evaluate(JSContext *cx, uintN argc, jsval *vp)
61216: {
61216:     if (argc != 1 || !JSVAL_IS_STRING(JS_ARGV(cx, vp)[0])) {
61216:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
61216:                              (argc != 1) ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_INVALID_ARGS,
61216:                              "evaluate");
61216:         return false;
61216:     }
61216: 
61216:     JSString *code = JSVAL_TO_STRING(JS_ARGV(cx, vp)[0]);
61216: 
61216:     size_t codeLength;
61216:     const jschar *codeChars = JS_GetStringCharsAndLength(cx, code, &codeLength);
61216:     if (!codeChars)
61216:         return false;
61216: 
61216:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
61216:     if (!thisobj)
61216:         return false;
61216: 
61216:     if ((JS_GET_CLASS(cx, thisobj)->flags & JSCLASS_IS_GLOBAL) != JSCLASS_IS_GLOBAL) {
61216:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
61216:                              "this-value passed to evaluate()", "not a global object");
61216:         return false;
61216:     }
61216: 
61216:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
61216:     return JS_EvaluateUCScript(cx, thisobj, codeChars, codeLength, "@evaluate", 0, NULL);
61216: }
61216: 
62030: static JSString *
62030: FileAsString(JSContext *cx, const char *pathname)
62030: {
62030:     FILE *file;
62030:     JSString *str = NULL;
62030:     size_t len, cc;
62030:     char *buf;
62030: 
62030:     file = fopen(pathname, "rb");
62030:     if (!file) {
62030:         JS_ReportError(cx, "can't open %s: %s", pathname, strerror(errno));
62030:         return NULL;
62030:     }
62030: 
69649:     if (fseek(file, 0, SEEK_END) != 0) {
62030:         JS_ReportError(cx, "can't seek end of %s", pathname);
62030:     } else {
62030:         len = ftell(file);
69649:         if (fseek(file, 0, SEEK_SET) != 0) {
62030:             JS_ReportError(cx, "can't seek start of %s", pathname);
62030:         } else {
62030:             buf = (char*) JS_malloc(cx, len + 1);
62030:             if (buf) {
62030:                 cc = fread(buf, 1, len, file);
62030:                 if (cc != len) {
62030:                     JS_ReportError(cx, "can't read %s: %s", pathname,
62030:                                    (ptrdiff_t(cc) < 0) ? strerror(errno) : "short read");
62030:                 } else {
68907:                     jschar *ucbuf;
68907:                     size_t uclen;
68907: 
62030:                     len = (size_t)cc;
68907: 
68907:                     if (!JS_DecodeUTF8(cx, buf, len, NULL, &uclen)) {
68907:                         JS_ReportError(cx, "Invalid UTF-8 in file '%s'", pathname);
68907:                         gExitCode = EXITCODE_RUNTIME_ERROR;
68907:                         return NULL;
68907:                     }
68907: 
68907:                     ucbuf = (jschar*)malloc(uclen * sizeof(jschar));
68907:                     JS_DecodeUTF8(cx, buf, len, ucbuf, &uclen);
68907:                     str = JS_NewUCStringCopyN(cx, ucbuf, uclen);
68907:                     free(ucbuf);
62030:                 }
62030:                 JS_free(cx, buf);
62030:             }
62030:         }
62030:     }
62030:     fclose(file);
62030: 
62030:     return str;
62030: }
62030: 
69649: static JSObject *
69649: FileAsTypedArray(JSContext *cx, const char *pathname)
69649: {
69649:     FILE *file = fopen(pathname, "rb");
69649:     if (!file) {
69649:         JS_ReportError(cx, "can't open %s: %s", pathname, strerror(errno));
69649:         return NULL;
69649:     }
69649: 
69649:     JSObject *obj = NULL;
69649:     if (fseek(file, 0, SEEK_END) != 0) {
69649:         JS_ReportError(cx, "can't seek end of %s", pathname);
69649:     } else {
69649:         size_t len = ftell(file);
69649:         if (fseek(file, 0, SEEK_SET) != 0) {
69649:             JS_ReportError(cx, "can't seek start of %s", pathname);
69649:         } else {
69649:             obj = js_CreateTypedArray(cx, TypedArray::TYPE_UINT8, len);
69649:             if (!obj)
69649:                 return NULL;
69649:             char *buf = (char *) TypedArray::fromJSObject(obj)->data;
69649:             size_t cc = fread(buf, 1, len, file);
69649:             if (cc != len) {
69649:                 JS_ReportError(cx, "can't read %s: %s", pathname,
69649:                                (ptrdiff_t(cc) < 0) ? strerror(errno) : "short read");
69649:                 obj = NULL;
69649:             }
69649:         }
69649:     }
69649:     fclose(file);
69649:     return obj;
69649: }
69649: 
62030: /*
62030:  * Function to run scripts and return compilation + execution time. Semantics
62030:  * are closely modelled after the equivalent function in WebKit, as this is used
62030:  * to produce benchmark timings by SunSpider.
62030:  */
62030: static JSBool
62030: Run(JSContext *cx, uintN argc, jsval *vp)
62030: {
62030:     if (argc != 1) {
62030:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "run");
62030:         return false;
62030:     }
62030: 
62030:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
62030:     if (!thisobj)
62030:         return false;
62030: 
62030:     jsval *argv = JS_ARGV(cx, vp);
62030:     JSString *str = JS_ValueToString(cx, argv[0]);
62030:     if (!str)
62030:         return false;
62030:     argv[0] = STRING_TO_JSVAL(str);
62030:     JSAutoByteString filename(cx, str);
62030:     if (!filename)
62030:         return false;
62030: 
62030:     const jschar *ucbuf = NULL;
62030:     size_t buflen;
62030:     str = FileAsString(cx, filename.ptr());
62030:     if (str)
62030:         ucbuf = JS_GetStringCharsAndLength(cx, str, &buflen);
62030:     if (!ucbuf)
62030:         return false;
62030: 
62030:     JS::Anchor<JSString *> a_str(str);
62030:     uint32 oldopts = JS_GetOptions(cx);
62030:     JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
62030: 
62030:     int64 startClock = PRMJ_Now();
64190:     JSObject *scriptObj = JS_CompileUCScript(cx, thisobj, ucbuf, buflen, filename.ptr(), 1);
62030:     JS_SetOptions(cx, oldopts);
64190:     if (!scriptObj || !JS_ExecuteScript(cx, thisobj, scriptObj, NULL))
62030:         return false;
62030: 
62030:     int64 endClock = PRMJ_Now();
62030:     JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL((endClock - startClock) / double(PRMJ_USEC_PER_MSEC)));
62030:     return true;
62030: }
62030: 
23126: /*
23126:  * function readline()
23126:  * Provides a hook for scripts to read a line from stdin.
23126:  */
23126: static JSBool
23126: ReadLine(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126: #define BUFSIZE 256
23126:     FILE *from;
23126:     char *buf, *tmp;
23126:     size_t bufsize, buflength, gotlength;
23126:     JSBool sawNewline;
23126:     JSString *str;
23126: 
23126:     from = stdin;
23126:     buflength = 0;
23126:     bufsize = BUFSIZE;
23126:     buf = (char *) JS_malloc(cx, bufsize);
23126:     if (!buf)
23126:         return JS_FALSE;
23126: 
23126:     sawNewline = JS_FALSE;
23126:     while ((gotlength =
23126:             js_fgets(buf + buflength, bufsize - buflength, from)) > 0) {
23126:         buflength += gotlength;
23126: 
23126:         /* Are we done? */
23126:         if (buf[buflength - 1] == '\n') {
23126:             buf[buflength - 1] = '\0';
23126:             sawNewline = JS_TRUE;
23126:             break;
23126:         } else if (buflength < bufsize - 1) {
23126:             break;
23126:         }
23126: 
23126:         /* Else, grow our buffer for another pass. */
23126:         bufsize *= 2;
23126:         if (bufsize > buflength) {
23126:             tmp = (char *) JS_realloc(cx, buf, bufsize);
23126:         } else {
23126:             JS_ReportOutOfMemory(cx);
23126:             tmp = NULL;
23126:         }
23126: 
23126:         if (!tmp) {
23126:             JS_free(cx, buf);
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         buf = tmp;
23126:     }
23126: 
23126:     /* Treat the empty string specially. */
23126:     if (buflength == 0) {
23126:         *vp = feof(from) ? JSVAL_NULL : JS_GetEmptyStringValue(cx);
23126:         JS_free(cx, buf);
23126:         return JS_TRUE;
23126:     }
23126: 
23126:     /* Shrink the buffer to the real size. */
23126:     tmp = (char *) JS_realloc(cx, buf, buflength);
23126:     if (!tmp) {
23126:         JS_free(cx, buf);
23126:         return JS_FALSE;
23126:     }
23126: 
23126:     buf = tmp;
23126: 
23126:     /*
23126:      * Turn buf into a JSString. Note that buflength includes the trailing null
23126:      * character.
23126:      */
59008:     str = JS_NewStringCopyN(cx, buf, sawNewline ? buflength - 1 : buflength);
23126:     JS_free(cx, buf);
59008:     if (!str)
23126:         return JS_FALSE;
23126: 
23126:     *vp = STRING_TO_JSVAL(str);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48808: PutStr(JSContext *cx, uintN argc, jsval *vp)
48808: {
48808:     jsval *argv;
48808:     JSString *str;
48808:     char *bytes;
48808: 
48808:     if (argc != 0) {
48808:         argv = JS_ARGV(cx, vp);
48808:         str = JS_ValueToString(cx, argv[0]);
48808:         if (!str)
48808:             return JS_FALSE;
48808:         bytes = JS_EncodeString(cx, str);
48808:         if (!bytes)
48808:             return JS_FALSE;
48808:         fputs(bytes, gOutFile);
48808:         JS_free(cx, bytes);
48808:         fflush(gOutFile);
48808:     }
48808: 
48808:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
48808:     return JS_TRUE;
48808: }
48808: 
48808: static JSBool
49114: Now(JSContext *cx, uintN argc, jsval *vp)
49114: {
49114:     jsdouble now = PRMJ_Now() / double(PRMJ_USEC_PER_MSEC);
49114:     JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(now));
49114:     return true;
49114: }
49114: 
49114: static JSBool
23126: Print(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     jsval *argv;
23126:     uintN i;
23126:     JSString *str;
23126:     char *bytes;
23126: 
23126:     argv = JS_ARGV(cx, vp);
23126:     for (i = 0; i < argc; i++) {
23126:         str = JS_ValueToString(cx, argv[i]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         bytes = JS_EncodeString(cx, str);
23126:         if (!bytes)
23126:             return JS_FALSE;
23126:         fprintf(gOutFile, "%s%s", i ? " " : "", bytes);
23126:         JS_free(cx, bytes);
23126:     }
23126: 
23126:     fputc('\n', gOutFile);
23126:     fflush(gOutFile);
23126: 
23126:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53557: Help(JSContext *cx, uintN argc, jsval *vp);
23126: 
23126: static JSBool
53557: Quit(JSContext *cx, uintN argc, jsval *vp)
23126: {
53557:     JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "/ i", &gExitCode);
23126: 
23126:     gQuitting = JS_TRUE;
40801: #ifdef JS_THREADSAFE
55619:     if (gWorkerThreadPool)
55619:         js::workers::terminateAll(JS_GetRuntime(cx), gWorkerThreadPool);
40801: #endif
23126:     return JS_FALSE;
23126: }
23126: 
25699: static const char *
57812: ToSource(JSContext *cx, jsval *vp, JSAutoByteString *bytes)
25699: {
25699:     JSString *str = JS_ValueToSource(cx, *vp);
25699:     if (str) {
25699:         *vp = STRING_TO_JSVAL(str);
57812:         if (bytes->encode(cx, str))
57812:             return bytes->ptr();
25699:     }
25699:     JS_ClearPendingException(cx);
25699:     return "<<error converting value to string>>";
25699: }
25699: 
25699: static JSBool
25699: AssertEq(JSContext *cx, uintN argc, jsval *vp)
25699: {
32760:     if (!(argc == 2 || (argc == 3 && JSVAL_IS_STRING(JS_ARGV(cx, vp)[2])))) {
25699:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
32760:                              (argc < 2)
32760:                              ? JSSMSG_NOT_ENOUGH_ARGS
32760:                              : (argc == 3)
32760:                              ? JSSMSG_INVALID_ARGS
32760:                              : JSSMSG_TOO_MANY_ARGS,
25699:                              "assertEq");
25699:         return JS_FALSE;
25699:     }
25699: 
25699:     jsval *argv = JS_ARGV(cx, vp);
59889:     JSBool same;
59889:     if (!JS_SameValue(cx, argv[0], argv[1], &same))
59889:         return JS_FALSE;
59889:     if (!same) {
57812:         JSAutoByteString bytes0, bytes1;
57812:         const char *actual = ToSource(cx, &argv[0], &bytes0);
57812:         const char *expected = ToSource(cx, &argv[1], &bytes1);
32760:         if (argc == 2) {
25699:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_ASSERT_EQ_FAILED,
25699:                                  actual, expected);
32760:         } else {
57812:             JSAutoByteString bytes2(cx, JSVAL_TO_STRING(argv[2]));
57812:             if (!bytes2)
57812:                 return JS_FALSE;
32760:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_ASSERT_EQ_FAILED_MSG,
57812:                                  actual, expected, bytes2.ptr());
32760:         }
25699:         return JS_FALSE;
25699:     }
25699:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
25699:     return JS_TRUE;
25699: }
25699: 
23126: static JSBool
53120: AssertJit(JSContext *cx, uintN argc, jsval *vp)
53120: {
53120: #ifdef JS_METHODJIT
53120:     if (JS_GetOptions(cx) & JSOPTION_METHODJIT) {
55503:         if (!cx->fp()->script()->getJIT(cx->fp()->isConstructing())) {
53120:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_ASSERT_JIT_FAILED);
53120:             return JS_FALSE;
53120:         }
53120:     }
53120: #endif
53120: 
53120:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53120:     return JS_TRUE;
53120: }
53120: 
53120: static JSBool
23126: GC(JSContext *cx, uintN argc, jsval *vp)
23126: {
71353:     JSCompartment *comp = NULL;
71353:     if (argc == 1) {
71353:         Value arg = Valueify(vp[2]);
71353:         if (arg.isObject())
71353:             comp = arg.toObject().unwrap()->compartment();
71353:     }
71353: 
36680:     size_t preBytes = cx->runtime->gcBytes;
71353:     JS_CompartmentGC(cx, comp);
23126: 
28179:     char buf[256];
28179:     JS_snprintf(buf, sizeof(buf), "before %lu, after %lu, break %08lx\n",
36680:                 (unsigned long)preBytes, (unsigned long)cx->runtime->gcBytes,
31119: #ifdef HAVE_SBRK
23126:                 (unsigned long)sbrk(0)
23126: #else
23126:                 0
23126: #endif
23126:                 );
36680:     *vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, buf));
36680:     return true;
36680: }
36680: 
23126: static JSBool
23126: GCParameter(JSContext *cx, uintN argc, jsval *vp)
23126: {
57721:     static const struct {
57721:         const char      *name;
57721:         JSGCParamKey    param;
57721:     } paramMap[] = {
57721:         {"maxBytes",            JSGC_MAX_BYTES },
57721:         {"maxMallocBytes",      JSGC_MAX_MALLOC_BYTES},
57721:         {"gcStackpoolLifespan", JSGC_STACKPOOL_LIFESPAN},
57721:         {"gcBytes",             JSGC_BYTES},
57721:         {"gcNumber",            JSGC_NUMBER},
57721:     };
57721: 
23126:     JSString *str;
23126:     if (argc == 0) {
23126:         str = JS_ValueToString(cx, JSVAL_VOID);
23126:         JS_ASSERT(str);
23126:     } else {
23126:         str = JS_ValueToString(cx, vp[2]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         vp[2] = STRING_TO_JSVAL(str);
23126:     }
57721: 
59889:     JSFlatString *flatStr = JS_FlattenString(cx, str);
59889:     if (!flatStr)
59889:         return JS_FALSE;
59889: 
57721:     size_t paramIndex = 0;
57721:     for (;; paramIndex++) {
57721:         if (paramIndex == JS_ARRAY_LENGTH(paramMap)) {
23126:             JS_ReportError(cx,
24313:                            "the first argument argument must be maxBytes, "
69836:                            "maxMallocBytes, gcStackpoolLifespan, gcBytes or "
69836:                            "gcNumber");
23126:             return JS_FALSE;
23126:         }
59889:         if (JS_FlatStringEqualsAscii(flatStr, paramMap[paramIndex].name))
57721:             break;
57721:     }
57721:     JSGCParamKey param = paramMap[paramIndex].param;
23126: 
24313:     if (argc == 1) {
57721:         uint32 value = JS_GetGCParameter(cx->runtime, param);
24313:         return JS_NewNumberValue(cx, value, &vp[0]);
24313:     }
24313: 
24313:     if (param == JSGC_NUMBER ||
24313:         param == JSGC_BYTES) {
24313:         JS_ReportError(cx, "Attempt to change read-only parameter %s",
57721:                        paramMap[paramIndex].name);
23126:         return JS_FALSE;
24313:     }
24313: 
57721:     uint32 value;
24313:     if (!JS_ValueToECMAUint32(cx, vp[3], &value)) {
23126:         JS_ReportError(cx,
24313:                        "the second argument must be convertable to uint32 "
24313:                        "with non-zero value");
24313:         return JS_FALSE;
24313:     }
23126:     JS_SetGCParameter(cx->runtime, param, value);
23126:     *vp = JSVAL_VOID;
23126:     return JS_TRUE;
23126: }
23126: 
71354: static JSBool
71354: InternalConst(JSContext *cx, uintN argc, jsval *vp)
71354: {
71354:     if (argc != 1) {
71354:         JS_ReportError(cx, "the function takes exactly one argument");
71354:         return false;
71354:     }
71354: 
71354:     JSString *str = JS_ValueToString(cx, vp[2]);
71354:     if (!str)
71354:         return false;
71354:     JSFlatString *flat = JS_FlattenString(cx, str);
71354:     if (!flat)
71354:         return false;
71354: 
71354:     if (JS_FlatStringEqualsAscii(flat, "OBJECT_MARK_STACK_LENGTH")) {
71354:         vp[0] = UINT_TO_JSVAL(js::OBJECT_MARK_STACK_SIZE / sizeof(JSObject *));
71354:     } else {
71354:         JS_ReportError(cx, "unknown const name");
71354:         return false;
71354:     }
71354:     return true;
71354: }
71354: 
23126: #ifdef JS_GC_ZEAL
23126: static JSBool
23126: GCZeal(JSContext *cx, uintN argc, jsval *vp)
23126: {
71353:     uint32 zeal, frequency = JS_DEFAULT_ZEAL_FREQ;
71353:     JSBool compartment = JS_FALSE;
71353: 
71353:     if (argc > 3) {
71353:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_TOO_MANY_ARGS, "gczeal");
23126:         return JS_FALSE;
71353:     }
71353:     if (!JS_ValueToECMAUint32(cx, argc < 1 ? JSVAL_VOID : vp[2], &zeal))
71353:         return JS_FALSE;
71353:     if (argc >= 2)
71353:         if (!JS_ValueToECMAUint32(cx, vp[3], &frequency))
71353:             return JS_FALSE;
71353:     if (argc >= 3)
71353:         compartment = js_ValueToBoolean(Valueify(vp[3]));
71353: 
71353:     JS_SetGCZeal(cx, (uint8)zeal, frequency, compartment);
71353:     *vp = JSVAL_VOID;
71353:     return JS_TRUE;
71353: }
71353: 
71353: static JSBool
71353: ScheduleGC(JSContext *cx, uintN argc, jsval *vp)
71353: {
71353:     uint32 count;
71353:     bool compartment = false;
71353: 
71353:     if (argc != 1 && argc != 2) {
71353:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
71353:                              (argc < 1)
71353:                              ? JSSMSG_NOT_ENOUGH_ARGS
71353:                              : JSSMSG_TOO_MANY_ARGS,
71353:                              "schedulegc");
71353:         return JS_FALSE;
71353:     }
71353:     if (!JS_ValueToECMAUint32(cx, vp[2], &count))
71353:         return JS_FALSE;
71353:     if (argc == 2)
71353:         compartment = js_ValueToBoolean(Valueify(vp[3]));
71353: 
71353:     JS_ScheduleGC(cx, count, compartment);
23126:     *vp = JSVAL_VOID;
23126:     return JS_TRUE;
23126: }
23126: #endif /* JS_GC_ZEAL */
23126: 
23126: typedef struct JSCountHeapNode JSCountHeapNode;
23126: 
23126: struct JSCountHeapNode {
23126:     void                *thing;
23126:     int32               kind;
23126:     JSCountHeapNode     *next;
23126: };
23126: 
23126: typedef struct JSCountHeapTracer {
23126:     JSTracer            base;
23126:     JSDHashTable        visited;
23126:     JSBool              ok;
23126:     JSCountHeapNode     *traceList;
23126:     JSCountHeapNode     *recycleList;
23126: } JSCountHeapTracer;
23126: 
23126: static void
23126: CountHeapNotify(JSTracer *trc, void *thing, uint32 kind)
23126: {
23126:     JSCountHeapTracer *countTracer;
23126:     JSDHashEntryStub *entry;
23126:     JSCountHeapNode *node;
23126: 
23126:     JS_ASSERT(trc->callback == CountHeapNotify);
23126:     countTracer = (JSCountHeapTracer *)trc;
23126:     if (!countTracer->ok)
23126:         return;
23126: 
23126:     entry = (JSDHashEntryStub *)
23126:             JS_DHashTableOperate(&countTracer->visited, thing, JS_DHASH_ADD);
23126:     if (!entry) {
23126:         JS_ReportOutOfMemory(trc->context);
23126:         countTracer->ok = JS_FALSE;
23126:         return;
23126:     }
23126:     if (entry->key)
23126:         return;
23126:     entry->key = thing;
23126: 
23126:     node = countTracer->recycleList;
23126:     if (node) {
23126:         countTracer->recycleList = node->next;
23126:     } else {
23126:         node = (JSCountHeapNode *) JS_malloc(trc->context, sizeof *node);
23126:         if (!node) {
23126:             countTracer->ok = JS_FALSE;
23126:             return;
23126:         }
23126:     }
23126:     node->thing = thing;
23126:     node->kind = kind;
23126:     node->next = countTracer->traceList;
23126:     countTracer->traceList = node;
23126: }
23126: 
23126: static JSBool
23126: CountHeap(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     void* startThing;
23126:     int32 startTraceKind;
23126:     jsval v;
23126:     int32 traceKind, i;
23126:     JSString *str;
23126:     JSCountHeapTracer countTracer;
23126:     JSCountHeapNode *node;
23126:     size_t counter;
23126: 
23126:     static const struct {
23126:         const char       *name;
23126:         int32             kind;
23126:     } traceKindNames[] = {
23126:         { "all",        -1                  },
23126:         { "object",     JSTRACE_OBJECT      },
23126:         { "string",     JSTRACE_STRING      },
23126: #if JS_HAS_XML_SUPPORT
23126:         { "xml",        JSTRACE_XML         },
23126: #endif
23126:     };
23126: 
23126:     startThing = NULL;
23126:     startTraceKind = 0;
23126:     if (argc > 0) {
23126:         v = JS_ARGV(cx, vp)[0];
23126:         if (JSVAL_IS_TRACEABLE(v)) {
23126:             startThing = JSVAL_TO_TRACEABLE(v);
23126:             startTraceKind = JSVAL_TRACE_KIND(v);
48470:         } else if (!JSVAL_IS_NULL(v)) {
23126:             JS_ReportError(cx,
23126:                            "the first argument is not null or a heap-allocated "
23126:                            "thing");
23126:             return JS_FALSE;
23126:         }
23126:     }
23126: 
23126:     traceKind = -1;
23126:     if (argc > 1) {
23126:         str = JS_ValueToString(cx, JS_ARGV(cx, vp)[1]);
23126:         if (!str)
23126:             return JS_FALSE;
59889:         JSFlatString *flatStr = JS_FlattenString(cx, str);
59889:         if (!flatStr)
59889:             return JS_FALSE;
23126:         for (i = 0; ;) {
59889:             if (JS_FlatStringEqualsAscii(flatStr, traceKindNames[i].name)) {
23126:                 traceKind = traceKindNames[i].kind;
23126:                 break;
23126:             }
23126:             if (++i == JS_ARRAY_LENGTH(traceKindNames)) {
57812:                 JSAutoByteString bytes(cx, str);
57812:                 if (!!bytes)
57812:                     JS_ReportError(cx, "trace kind name '%s' is unknown", bytes.ptr());
23126:                 return JS_FALSE;
23126:             }
23126:         }
23126:     }
23126: 
23126:     JS_TRACER_INIT(&countTracer.base, cx, CountHeapNotify);
23126:     if (!JS_DHashTableInit(&countTracer.visited, JS_DHashGetStubOps(),
23126:                            NULL, sizeof(JSDHashEntryStub),
23126:                            JS_DHASH_DEFAULT_CAPACITY(100))) {
23126:         JS_ReportOutOfMemory(cx);
23126:         return JS_FALSE;
23126:     }
23126:     countTracer.ok = JS_TRUE;
23126:     countTracer.traceList = NULL;
23126:     countTracer.recycleList = NULL;
23126: 
23126:     if (!startThing) {
23126:         JS_TraceRuntime(&countTracer.base);
23126:     } else {
23126:         JS_SET_TRACING_NAME(&countTracer.base, "root");
23126:         JS_CallTracer(&countTracer.base, startThing, startTraceKind);
23126:     }
23126: 
23126:     counter = 0;
23126:     while ((node = countTracer.traceList) != NULL) {
23126:         if (traceKind == -1 || node->kind == traceKind)
23126:             counter++;
23126:         countTracer.traceList = node->next;
23126:         node->next = countTracer.recycleList;
23126:         countTracer.recycleList = node;
23126:         JS_TraceChildren(&countTracer.base, node->thing, node->kind);
23126:     }
23126:     while ((node = countTracer.recycleList) != NULL) {
23126:         countTracer.recycleList = node->next;
23126:         JS_free(cx, node);
23126:     }
23126:     JS_DHashTableFinish(&countTracer.visited);
23126: 
23126:     return countTracer.ok && JS_NewNumberValue(cx, (jsdouble) counter, vp);
23126: }
23126: 
54561: static jsrefcount finalizeCount = 0;
54561: 
54561: static void
54561: finalize_counter_finalize(JSContext *cx, JSObject *obj)
54561: {
54561:     JS_ATOMIC_INCREMENT(&finalizeCount);
54561: }
54561: 
54561: static JSClass FinalizeCounterClass = {
54561:     "FinalizeCounter", JSCLASS_IS_ANONYMOUS,
54561:     JS_PropertyStub,       /* addProperty */
54561:     JS_PropertyStub,       /* delProperty */
54561:     JS_PropertyStub,       /* getProperty */
62395:     JS_StrictPropertyStub, /* setProperty */
54561:     JS_EnumerateStub,
54561:     JS_ResolveStub,
54561:     JS_ConvertStub,
54561:     finalize_counter_finalize
54561: };
54561: 
54561: static JSBool
54561: MakeFinalizeObserver(JSContext *cx, uintN argc, jsval *vp)
54561: {
54561:     JSObject *obj = JS_NewObjectWithGivenProto(cx, &FinalizeCounterClass, NULL,
54561:                                                JS_GetGlobalObject(cx));
54561:     if (!obj)
54561:         return false;
54561:     *vp = OBJECT_TO_JSVAL(obj);
54561:     return true;
54561: }
54561: 
54561: static JSBool
54561: FinalizeCount(JSContext *cx, uintN argc, jsval *vp)
54561: {
54561:     *vp = INT_TO_JSVAL(finalizeCount);
54561:     return true;
54561: }
54561: 
23126: static JSScript *
23126: ValueToScript(JSContext *cx, jsval v)
23126: {
27012:     JSScript *script = NULL;
23126:     JSFunction *fun;
23126: 
27012:     if (!JSVAL_IS_PRIMITIVE(v)) {
27012:         JSObject *obj = JSVAL_TO_OBJECT(v);
27012:         JSClass *clasp = JS_GET_CLASS(cx, obj);
27012: 
48470:         if (clasp == Jsvalify(&js_ScriptClass)) {
27012:             script = (JSScript *) JS_GetPrivate(cx, obj);
48622:         } else if (clasp == Jsvalify(&js_GeneratorClass)) {
27012:             JSGenerator *gen = (JSGenerator *) JS_GetPrivate(cx, obj);
53840:             fun = gen->floatingFrame()->fun();
27012:             script = FUN_SCRIPT(fun);
27012:         }
27012:     }
27012: 
27012:     if (!script) {
23126:         fun = JS_ValueToFunction(cx, v);
23126:         if (!fun)
23126:             return NULL;
23126:         script = FUN_SCRIPT(fun);
23126:         if (!script) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_SCRIPTS_ONLY);
23126:         }
27012:     }
23126: 
23126:     return script;
23126: }
23126: 
23126: static JSBool
53557: SetDebug(JSContext *cx, uintN argc, jsval *vp)
53391: {
53557:     jsval *argv = JS_ARGV(cx, vp);
53391:     if (argc == 0 || !JSVAL_IS_BOOLEAN(argv[0])) {
53391:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
53391:                              JSSMSG_NOT_ENOUGH_ARGS, "setDebug");
53391:         return JS_FALSE;
53391:     }
53391: 
62780:     /*
62780:      * Debug mode can only be set when there is no JS code executing on the
62780:      * stack. Unfortunately, that currently means that this call will fail
62780:      * unless debug mode is already set to what you're trying to set it to.
62780:      * In the future, this restriction may be lifted.
62780:      */
62780: 
62780:     JSBool rv = JS_SetDebugMode(cx, JSVAL_TO_BOOLEAN(argv[0]));
62780:     JS_SET_RVAL(cx, vp, rv ? JSVAL_TRUE : JSVAL_FALSE);
53391:     return JS_TRUE;
53391: }
53391: 
53391: static JSBool
23126: GetTrapArgs(JSContext *cx, uintN argc, jsval *argv, JSScript **scriptp,
23126:             int32 *ip)
23126: {
23126:     jsval v;
23126:     uintN intarg;
23126:     JSScript *script;
23126: 
69223:     *scriptp = JS_GetFrameScript(cx, JS_GetScriptedCaller(cx, NULL));
23126:     *ip = 0;
23126:     if (argc != 0) {
23126:         v = argv[0];
23126:         intarg = 0;
23126:         if (!JSVAL_IS_PRIMITIVE(v) &&
48470:             (JS_GET_CLASS(cx, JSVAL_TO_OBJECT(v)) == Jsvalify(&js_FunctionClass) ||
48470:              JS_GET_CLASS(cx, JSVAL_TO_OBJECT(v)) == Jsvalify(&js_ScriptClass))) {
23126:             script = ValueToScript(cx, v);
23126:             if (!script)
23126:                 return JS_FALSE;
23126:             *scriptp = script;
23126:             intarg++;
23126:         }
23126:         if (argc > intarg) {
23126:             if (!JS_ValueToInt32(cx, argv[intarg], ip))
23126:                 return JS_FALSE;
23126:         }
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSTrapStatus
69223: TrapHandler(JSContext *cx, JSScript *, jsbytecode *pc, jsval *rval,
41863:             jsval closure)
23126: {
48582:     JSString *str = JSVAL_TO_STRING(closure);
48582:     JSStackFrame *caller = JS_GetScriptedCaller(cx, NULL);
69223:     JSScript *script = JS_GetFrameScript(cx, caller);
59889: 
59889:     size_t length;
59889:     const jschar *chars = JS_GetStringCharsAndLength(cx, str, &length);
59889:     if (!chars)
59889:         return JSTRAP_ERROR;
59889: 
59889:     if (!JS_EvaluateUCInStackFrame(cx, caller, chars, length,
69223:                                    script->filename,
69223:                                    script->lineno,
23126:                                    rval)) {
23126:         return JSTRAP_ERROR;
23126:     }
23126:     if (!JSVAL_IS_VOID(*rval))
23126:         return JSTRAP_RETURN;
23126:     return JSTRAP_CONTINUE;
23126: }
23126: 
23126: static JSBool
53557: Trap(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSString *str;
23126:     JSScript *script;
23126:     int32 i;
23126: 
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     if (argc == 0) {
23126:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_TRAP_USAGE);
23126:         return JS_FALSE;
23126:     }
23126:     argc--;
23126:     str = JS_ValueToString(cx, argv[argc]);
23126:     if (!str)
23126:         return JS_FALSE;
23126:     argv[argc] = STRING_TO_JSVAL(str);
23126:     if (!GetTrapArgs(cx, argc, argv, &script, &i))
23126:         return JS_FALSE;
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
41863:     return JS_SetTrap(cx, script, script->code + i, TrapHandler, STRING_TO_JSVAL(str));
23126: }
23126: 
23126: static JSBool
53557: Untrap(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSScript *script;
23126:     int32 i;
23126: 
53557:     if (!GetTrapArgs(cx, argc, JS_ARGV(cx, vp), &script, &i))
23126:         return JS_FALSE;
23126:     JS_ClearTrap(cx, script, script->code + i, NULL, NULL);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
53395: static JSTrapStatus
53410: DebuggerAndThrowHandler(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
53395:                         void *closure)
53395: {
53395:     return TrapHandler(cx, script, pc, rval, STRING_TO_JSVAL((JSString *)closure));
53395: }
53395: 
53395: static JSBool
53557: SetDebuggerHandler(JSContext *cx, uintN argc, jsval *vp)
53395: {
53395:     JSString *str;
53395:     if (argc == 0) {
53395:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
53395:                              JSSMSG_NOT_ENOUGH_ARGS, "setDebuggerHandler");
53395:         return JS_FALSE;
53395:     }
53395: 
53557:     str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
53395:     if (!str)
53395:         return JS_FALSE;
53395: 
53410:     JS_SetDebuggerHandler(cx->runtime, DebuggerAndThrowHandler, str);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53410:     return JS_TRUE;
53410: }
53410: 
53410: static JSBool
53557: SetThrowHook(JSContext *cx, uintN argc, jsval *vp)
53410: {
53410:     JSString *str;
53410:     if (argc == 0) {
53410:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
53410:                              JSSMSG_NOT_ENOUGH_ARGS, "setThrowHook");
53410:         return JS_FALSE;
53410:     }
53410: 
53557:     str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
53410:     if (!str)
53410:         return JS_FALSE;
53410: 
53410:     JS_SetThrowHook(cx->runtime, DebuggerAndThrowHandler, str);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53395:     return JS_TRUE;
53395: }
53395: 
23126: static JSBool
53557: LineToPC(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSScript *script;
23126:     int32 i;
23126:     uintN lineno;
23126:     jsbytecode *pc;
23126: 
23126:     if (argc == 0) {
23126:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_LINE2PC_USAGE);
23126:         return JS_FALSE;
23126:     }
69223:     script = JS_GetFrameScript(cx, JS_GetScriptedCaller(cx, NULL));
53557:     if (!GetTrapArgs(cx, argc, JS_ARGV(cx, vp), &script, &i))
23126:         return JS_FALSE;
23126:     lineno = (i == 0) ? script->lineno : (uintN)i;
23126:     pc = JS_LineNumberToPC(cx, script, lineno);
23126:     if (!pc)
23126:         return JS_FALSE;
53557:     *vp = INT_TO_JSVAL(pc - script->code);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53557: PCToLine(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSScript *script;
23126:     int32 i;
23126:     uintN lineno;
23126: 
53557:     if (!GetTrapArgs(cx, argc, JS_ARGV(cx, vp), &script, &i))
23126:         return JS_FALSE;
23126:     lineno = JS_PCToLineNumber(cx, script, script->code + i);
23126:     if (!lineno)
23126:         return JS_FALSE;
53557:     *vp = INT_TO_JSVAL(lineno);
23126:     return JS_TRUE;
23126: }
23126: 
23126: #ifdef DEBUG
23126: 
23126: static void
25216: UpdateSwitchTableBounds(JSContext *cx, JSScript *script, uintN offset,
23126:                         uintN *start, uintN *end)
23126: {
23126:     jsbytecode *pc;
23126:     JSOp op;
23126:     ptrdiff_t jmplen;
23126:     jsint low, high, n;
23126: 
23126:     pc = script->code + offset;
25216:     op = js_GetOpcode(cx, script, pc);
23126:     switch (op) {
23126:       case JSOP_TABLESWITCHX:
23126:         jmplen = JUMPX_OFFSET_LEN;
23126:         goto jump_table;
23126:       case JSOP_TABLESWITCH:
23126:         jmplen = JUMP_OFFSET_LEN;
23126:       jump_table:
23126:         pc += jmplen;
23126:         low = GET_JUMP_OFFSET(pc);
23126:         pc += JUMP_OFFSET_LEN;
23126:         high = GET_JUMP_OFFSET(pc);
23126:         pc += JUMP_OFFSET_LEN;
23126:         n = high - low + 1;
23126:         break;
23126: 
23126:       case JSOP_LOOKUPSWITCHX:
23126:         jmplen = JUMPX_OFFSET_LEN;
23126:         goto lookup_table;
23126:       case JSOP_LOOKUPSWITCH:
23126:         jmplen = JUMP_OFFSET_LEN;
23126:       lookup_table:
23126:         pc += jmplen;
23126:         n = GET_INDEX(pc);
23126:         pc += INDEX_LEN;
23126:         jmplen += JUMP_OFFSET_LEN;
23126:         break;
23126: 
23126:       default:
23126:         /* [condswitch] switch does not have any jump or lookup tables. */
23126:         JS_ASSERT(op == JSOP_CONDSWITCH);
23126:         return;
23126:     }
23126: 
23126:     *start = (uintN)(pc - script->code);
23126:     *end = *start + (uintN)(n * jmplen);
23126: }
23126: 
23126: static void
64374: SrcNotes(JSContext *cx, JSScript *script, Sprinter *sp)
23126: {
64196:     uintN offset, lineno, delta, caseOff, switchTableStart, switchTableEnd;
23126:     jssrcnote *notes, *sn;
23126:     JSSrcNoteType type;
23126:     const char *name;
23126:     uint32 index;
23126:     JSAtom *atom;
23126:     JSString *str;
23126: 
64374:     Sprint(sp, "\nSource notes:\n");
64374:     Sprint(sp, "%4s  %4s %5s %6s %-8s %s\n",
64196:            "ofs", "line", "pc", "delta", "desc", "args");
64374:     Sprint(sp, "---- ---- ----- ------ -------- ------\n");
23126:     offset = 0;
64196:     lineno = script->lineno;
32723:     notes = script->notes();
23126:     switchTableEnd = switchTableStart = 0;
23126:     for (sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
23126:         delta = SN_DELTA(sn);
23126:         offset += delta;
23126:         type = (JSSrcNoteType) SN_TYPE(sn);
23126:         name = js_SrcNoteSpec[type].name;
23126:         if (type == SRC_LABEL) {
23126:             /* Check if the source note is for a switch case. */
23126:             if (switchTableStart <= offset && offset < switchTableEnd) {
23126:                 name = "case";
23126:             } else {
25216:                 JS_ASSERT(js_GetOpcode(cx, script, script->code + offset) == JSOP_NOP);
23126:             }
23126:         }
64374:         Sprint(sp, "%3u: %4u %5u [%4u] %-8s", uintN(sn - notes), lineno, offset, delta, name);
23126:         switch (type) {
23126:           case SRC_SETLINE:
64196:             lineno = js_GetSrcNoteOffset(sn, 0);
64374:             Sprint(sp, " lineno %u", lineno);
64196:             break;
64196:           case SRC_NEWLINE:
64196:             ++lineno;
23126:             break;
23126:           case SRC_FOR:
64374:             Sprint(sp, " cond %u update %u tail %u",
64374:                    uintN(js_GetSrcNoteOffset(sn, 0)),
64374:                    uintN(js_GetSrcNoteOffset(sn, 1)),
64374:                    uintN(js_GetSrcNoteOffset(sn, 2)));
23126:             break;
23126:           case SRC_IF_ELSE:
64374:             Sprint(sp, " else %u elseif %u",
64374:                    uintN(js_GetSrcNoteOffset(sn, 0)),
64374:                    uintN(js_GetSrcNoteOffset(sn, 1)));
23126:             break;
23126:           case SRC_COND:
23126:           case SRC_WHILE:
23126:           case SRC_PCBASE:
23126:           case SRC_PCDELTA:
23126:           case SRC_DECL:
23126:           case SRC_BRACE:
64374:             Sprint(sp, " offset %u", uintN(js_GetSrcNoteOffset(sn, 0)));
23126:             break;
23126:           case SRC_LABEL:
23126:           case SRC_LABELBRACE:
23126:           case SRC_BREAK2LABEL:
23126:           case SRC_CONT2LABEL:
23126:             index = js_GetSrcNoteOffset(sn, 0);
64374:             atom = script->getAtom(index);
64374:             Sprint(sp, " atom %u (", index);
64374:             {
64374:                 size_t len = PutEscapedString(NULL, 0, atom, '\0');
64374:                 if (char *buf = SprintReserveAmount(sp, len)) {
64374:                     PutEscapedString(buf, len, atom, 0);
64374:                     buf[len] = '\0';
64374:                 }
64374:             }
64374:             Sprint(sp, ")");
23126:             break;
23126:           case SRC_FUNCDEF: {
23126:             index = js_GetSrcNoteOffset(sn, 0);
57812:             JSObject *obj = script->getObject(index);
57812:             JSFunction *fun = (JSFunction *) JS_GetPrivate(cx, obj);
23126:             str = JS_DecompileFunction(cx, fun, JS_DONT_PRETTY_PRINT);
57812:             JSAutoByteString bytes;
57812:             if (!str || !bytes.encode(cx, str))
47498:                 ReportException(cx);
64374:             Sprint(sp, " function %u (%s)", index, !!bytes ? bytes.ptr() : "N/A");
23126:             break;
23126:           }
23126:           case SRC_SWITCH:
73877:             if (js_GetOpcode(cx, script, script->code + offset) == JSOP_GOTO)
73877:                 break;
64374:             Sprint(sp, " length %u", uintN(js_GetSrcNoteOffset(sn, 0)));
23126:             caseOff = (uintN) js_GetSrcNoteOffset(sn, 1);
23126:             if (caseOff)
64374:                 Sprint(sp, " first case offset %u", caseOff);
25216:             UpdateSwitchTableBounds(cx, script, offset,
23126:                                     &switchTableStart, &switchTableEnd);
23126:             break;
23126:           case SRC_CATCH:
23126:             delta = (uintN) js_GetSrcNoteOffset(sn, 0);
23126:             if (delta) {
23126:                 if (script->main[offset] == JSOP_LEAVEBLOCK)
64374:                     Sprint(sp, " stack depth %u", delta);
23126:                 else
64374:                     Sprint(sp, " guard delta %u", delta);
23126:             }
23126:             break;
23126:           default:;
23126:         }
64374:         Sprint(sp, "\n");
23126:     }
23126: }
23126: 
23126: static JSBool
53557: Notes(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     uintN i;
23126:     JSScript *script;
23126: 
64374:     void *mark = JS_ARENA_MARK(&cx->tempPool);
64374:     Sprinter sprinter;
64374:     INIT_SPRINTER(cx, &sprinter, &cx->tempPool, 0);
64374: 
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     for (i = 0; i < argc; i++) {
23126:         script = ValueToScript(cx, argv[i]);
23126:         if (!script)
23126:             continue;
23126: 
64374:         SrcNotes(cx, script, &sprinter);
64374:     }
64374: 
64374:     JSString *str = JS_NewStringCopyZ(cx, sprinter.base);
64374:     JS_ARENA_RELEASE(&cx->tempPool, mark);
64374:     if (!str)
64374:         return JS_FALSE;
64374:     JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(str));
23126:     return JS_TRUE;
23126: }
23126: 
23126: JS_STATIC_ASSERT(JSTRY_CATCH == 0);
23126: JS_STATIC_ASSERT(JSTRY_FINALLY == 1);
23126: JS_STATIC_ASSERT(JSTRY_ITER == 2);
23126: 
23126: static const char* const TryNoteNames[] = { "catch", "finally", "iter" };
23126: 
23126: static JSBool
64374: TryNotes(JSContext *cx, JSScript *script, Sprinter *sp)
23126: {
23126:     JSTryNote *tn, *tnlimit;
23126: 
59221:     if (!JSScript::isValidOffset(script->trynotesOffset))
23126:         return JS_TRUE;
23126: 
32723:     tn = script->trynotes()->vector;
32723:     tnlimit = tn + script->trynotes()->length;
64374:     Sprint(sp, "\nException table:\nkind      stack    start      end\n");
23126:     do {
23126:         JS_ASSERT(tn->kind < JS_ARRAY_LENGTH(TryNoteNames));
64374:         Sprint(sp, " %-7s %6u %8u %8u\n",
23126:                TryNoteNames[tn->kind], tn->stackDepth,
23126:                tn->start, tn->start + tn->length);
23126:     } while (++tn != tnlimit);
23126:     return JS_TRUE;
23126: }
23126: 
28924: static bool
64374: DisassembleValue(JSContext *cx, jsval v, bool lines, bool recursive, Sprinter *sp)
23126: {
28924:     JSScript *script = ValueToScript(cx, v);
23126:     if (!script)
28924:         return false;
28924:     if (VALUE_IS_FUNCTION(cx, v)) {
28924:         JSFunction *fun = JS_ValueToFunction(cx, v);
27012:         if (fun && (fun->flags & ~7U)) {
23126:             uint16 flags = fun->flags;
64374:             Sprint(sp, "flags:");
64374: 
64374: #define SHOW_FLAG(flag) if (flags & JSFUN_##flag) Sprint(sp, " " #flag);
23126: 
23126:             SHOW_FLAG(LAMBDA);
23126:             SHOW_FLAG(HEAVYWEIGHT);
23126:             SHOW_FLAG(EXPR_CLOSURE);
32669:             SHOW_FLAG(TRCINFO);
23126: 
23126: #undef SHOW_FLAG
27012: 
37014:             if (FUN_INTERPRETED(fun)) {
27012:                 if (FUN_NULL_CLOSURE(fun))
64374:                     Sprint(sp, " NULL_CLOSURE");
27012:                 else if (FUN_FLAT_CLOSURE(fun))
64374:                     Sprint(sp, " FLAT_CLOSURE");
37014: 
59968:                 JSScript *script = fun->script();
59968:                 if (script->bindings.hasUpvars()) {
64374:                     Sprint(sp, "\nupvars: {\n");
37014: 
73058:                     Vector<JSAtom *> localNames(cx);
73058:                     if (!script->bindings.getLocalNameArray(cx, &localNames))
37014:                         return false;
37014: 
59968:                     JSUpvarArray *uva = script->upvars();
59968:                     uintN upvar_base = script->bindings.countArgsAndVars();
37014: 
37014:                     for (uint32 i = 0, n = uva->length; i < n; i++) {
73058:                         JSAtom *atom = localNames[upvar_base + i];
47573:                         UpvarCookie cookie = uva->vector[i];
57812:                         JSAutoByteString printable;
57812:                         if (js_AtomToPrintableString(cx, atom, &printable)) {
64374:                             Sprint(sp, "  %s: {skip:%u, slot:%u},\n",
57812:                                    printable.ptr(), cookie.level(), cookie.slot());
57812:                         }
37014:                     }
37014: 
64374:                     Sprint(sp, "}");
64374:                 }
64374:             }
64374:             Sprint(sp, "\n");
64374:         }
64374:     }
64374: 
64374:     if (!js_Disassemble(cx, script, lines, sp))
28924:         return false;
64374:     SrcNotes(cx, script, sp);
64374:     TryNotes(cx, script, sp);
28924: 
59221:     if (recursive && JSScript::isValidOffset(script->objectsOffset)) {
32723:         JSObjectArray *objects = script->objects();
28924:         for (uintN i = 0; i != objects->length; ++i) {
28924:             JSObject *obj = objects->vector[i];
40430:             if (obj->isFunction()) {
64374:                 Sprint(sp, "\n");
64374:                 if (!DisassembleValue(cx, OBJECT_TO_JSVAL(obj), lines, recursive, sp))
28924:                     return false;
28924:             }
28924:         }
28924:     }
28924:     return true;
28924: }
28924: 
28924: static JSBool
64374: DisassembleToString(JSContext *cx, uintN argc, jsval *vp)
28924: {
58045:     jsval *argv = JS_ARGV(cx, vp);
58045: 
58045:     /* Read options off early arguments */
28924:     bool lines = false, recursive = false;
28924:     while (argc > 0 && JSVAL_IS_STRING(argv[0])) {
57721:         JSString *str = JSVAL_TO_STRING(argv[0]);
59889:         JSFlatString *flatStr = JS_FlattenString(cx, str);
59889:         if (!flatStr)
59889:             return JS_FALSE;
59908:         lines |= !!JS_FlatStringEqualsAscii(flatStr, "-l");
59908:         recursive |= !!JS_FlatStringEqualsAscii(flatStr, "-r");
28924:         if (!lines && !recursive)
28924:             break;
28924:         argv++, argc--;
28924:     }
28924: 
64374:     void *mark = JS_ARENA_MARK(&cx->tempPool);
64374:     Sprinter sprinter;
64374:     INIT_SPRINTER(cx, &sprinter, &cx->tempPool, 0);
64374:     Sprinter *sp = &sprinter;
64374: 
64374:     bool ok = true;
58720:     if (argc == 0) {
58720:         /* Without arguments, disassemble the current script. */
58720:         if (JSStackFrame *frame = JS_GetScriptedCaller(cx, NULL)) {
58720:             JSScript *script = JS_GetFrameScript(cx, frame);
64374:             if (js_Disassemble(cx, script, lines, sp)) {
64374:                 SrcNotes(cx, script, sp);
64374:                 TryNotes(cx, script, sp);
64374:             } else {
64374:                 ok = false;
64374:             }
64374:         }
64374:     } else {
64374:         for (uintN i = 0; i < argc; i++)
64374:             ok = ok && DisassembleValue(cx, argv[i], lines, recursive, sp);
64374:     }
64374: 
64374:     JSString *str = ok ? JS_NewStringCopyZ(cx, sprinter.base) : NULL;
64374:     JS_ARENA_RELEASE(&cx->tempPool, mark);
64374:     if (!str)
58720:         return false;
64374:     JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(str));
64374:     return true;
64374: }
64374: 
64374: static JSBool
64374: Disassemble(JSContext *cx, uintN argc, jsval *vp)
64374: {
64374:     jsval *argv = JS_ARGV(cx, vp);
64374: 
64374:     /* Read options off early arguments */
64374:     bool lines = false, recursive = false;
64374:     while (argc > 0 && JSVAL_IS_STRING(argv[0])) {
64374:         JSString *str = JSVAL_TO_STRING(argv[0]);
64374:         JSFlatString *flatStr = JS_FlattenString(cx, str);
64374:         if (!flatStr)
64374:             return JS_FALSE;
64374:         lines |= !!JS_FlatStringEqualsAscii(flatStr, "-l");
64374:         recursive |= !!JS_FlatStringEqualsAscii(flatStr, "-r");
64374:         if (!lines && !recursive)
64374:             break;
64374:         argv++, argc--;
64374:     }
64374: 
64374:     void *mark = JS_ARENA_MARK(&cx->tempPool);
64374:     Sprinter sprinter;
64374:     INIT_SPRINTER(cx, &sprinter, &cx->tempPool, 0);
64374:     Sprinter *sp = &sprinter;
64374: 
64374:     bool ok = true;
64374:     if (argc == 0) {
64374:         /* Without arguments, disassemble the current script. */
64374:         if (JSStackFrame *frame = JS_GetScriptedCaller(cx, NULL)) {
64374:             JSScript *script = JS_GetFrameScript(cx, frame);
64374:             if (js_Disassemble(cx, script, lines, sp)) {
64374:                 SrcNotes(cx, script, sp);
64374:                 TryNotes(cx, script, sp);
58720:             } else {
64374:                 ok = false;
64374:             }
64374:         }
64374:     } else {
64374:         for (uintN i = 0; i < argc; i++)
64374:             ok = ok && DisassembleValue(cx, argv[i], lines, recursive, sp);
64374:     }
64374: 
64374:     if (ok)
64374:         fprintf(stdout, "%s\n", sprinter.base);
64374:     JS_ARENA_RELEASE(&cx->tempPool, mark);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
64374:     return ok;
23126: }
23126: 
23126: static JSBool
53557: DisassFile(JSContext *cx, uintN argc, jsval *vp)
23126: {
53637:     jsval *argv = JS_ARGV(cx, vp);
23126: 
53639:     if (!argc) {
53639:         JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:         return JS_TRUE;
53639:     }
23126: 
58045:     /* Support extra options at the start, just like Dissassemble. */
58045:     uintN _argc = argc;
58045:     argv += argc-1;
58045:     argc = 1;
58045: 
53557:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
53557:     if (!thisobj)
53557:         return JS_FALSE;
53557: 
57812:     JSString *str = JS_ValueToString(cx, argv[0]);
23126:     if (!str)
23126:         return JS_FALSE;
57812:     JSAutoByteString filename(cx, str);
57812:     if (!filename)
57812:         return JS_FALSE;
57812: 
57812:     uint32 oldopts = JS_GetOptions(cx);
23126:     JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
64190:     JSObject *scriptObj = JS_CompileFile(cx, thisobj, filename.ptr());
23126:     JS_SetOptions(cx, oldopts);
64190:     if (!scriptObj)
64190:         return false;
64190: 
64190:     argv[0] = OBJECT_TO_JSVAL(scriptObj);
58045:     JSBool ok = Disassemble(cx, _argc, vp); /* gross, but works! */
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return ok;
23126: }
23126: 
23126: static JSBool
53557: DisassWithSrc(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126: #define LINE_BUF_LEN 512
23126:     uintN i, len, line1, line2, bupline;
23126:     JSScript *script;
23126:     FILE *file;
23126:     char linebuf[LINE_BUF_LEN];
23126:     jsbytecode *pc, *end;
23126:     JSBool ok;
23126:     static char sep[] = ";-------------------------";
23126: 
23126:     ok = JS_TRUE;
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     for (i = 0; ok && i < argc; i++) {
23126:         script = ValueToScript(cx, argv[i]);
23126:         if (!script)
23126:            return JS_FALSE;
23126: 
23126:         if (!script->filename) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_FILE_SCRIPTS_ONLY);
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         file = fopen(script->filename, "r");
23126:         if (!file) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_CANT_OPEN, script->filename,
23126:                                  strerror(errno));
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         pc = script->code;
23126:         end = pc + script->length;
23126: 
64374:         void *mark = JS_ARENA_MARK(&cx->tempPool);
64374:         Sprinter sprinter;
64374:         Sprinter *sp = &sprinter;
64374:         INIT_SPRINTER(cx, sp, &cx->tempPool, 0);
64374: 
23126:         /* burn the leading lines */
23126:         line2 = JS_PCToLineNumber(cx, script, pc);
40289:         for (line1 = 0; line1 < line2 - 1; line1++) {
40289:             char *tmp = fgets(linebuf, LINE_BUF_LEN, file);
40289:             if (!tmp) {
40289:                 JS_ReportError(cx, "failed to read %s fully",
40289:                                script->filename);
40289:                 ok = JS_FALSE;
40289:                 goto bail;
40289:             }
40289:         }
23126: 
23126:         bupline = 0;
23126:         while (pc < end) {
23126:             line2 = JS_PCToLineNumber(cx, script, pc);
23126: 
23126:             if (line2 < line1) {
23126:                 if (bupline != line2) {
23126:                     bupline = line2;
64374:                     Sprint(sp, "%s %3u: BACKUP\n", sep, line2);
23126:                 }
23126:             } else {
23126:                 if (bupline && line1 == line2)
64374:                     Sprint(sp, "%s %3u: RESTORE\n", sep, line2);
23126:                 bupline = 0;
23126:                 while (line1 < line2) {
23126:                     if (!fgets(linebuf, LINE_BUF_LEN, file)) {
23126:                         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                              JSSMSG_UNEXPECTED_EOF,
23126:                                              script->filename);
23126:                         ok = JS_FALSE;
23126:                         goto bail;
23126:                     }
23126:                     line1++;
64374:                     Sprint(sp, "%s %3u: %s", sep, line1, linebuf);
64374:                 }
64374:             }
64374: 
64374:             len = js_Disassemble1(cx, script, pc, pc - script->code, JS_TRUE, sp);
23126:             if (!len) {
23126:                 ok = JS_FALSE;
23126:                 goto bail;
23126:             }
23126:             pc += len;
23126:         }
23126: 
23126:       bail:
64374:         JS_ARENA_RELEASE(&cx->tempPool, mark);
23126:         fclose(file);
23126:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return ok;
23126: #undef LINE_BUF_LEN
23126: }
23126: 
23126: static void
23126: DumpScope(JSContext *cx, JSObject *obj, FILE *fp)
23126: {
38562:     uintN i = 0;
38562:     for (JSScopeProperty *sprop = NULL; JS_PropertyIterator(obj, &sprop);) {
38562:         fprintf(fp, "%3u %p ", i++, (void *) sprop);
52503:         ((Shape *) sprop)->dump(cx, fp);
23126:     }
23126: }
23126: 
23126: static JSBool
53557: DumpStats(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     uintN i;
23126:     JSString *str;
23126:     jsid id;
23126:     JSObject *obj2;
23126:     JSProperty *prop;
48470:     Value value;
23126: 
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     for (i = 0; i < argc; i++) {
23126:         str = JS_ValueToString(cx, argv[i]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         argv[i] = STRING_TO_JSVAL(str);
59889:         JSFlatString *flatStr = JS_FlattenString(cx, str);
59889:         if (!flatStr)
59889:             return JS_FALSE;
72559:         if (JS_FlatStringEqualsAscii(flatStr, "atom")) {
23126:             js_DumpAtoms(cx, gOutFile);
59889:         } else if (JS_FlatStringEqualsAscii(flatStr, "global")) {
23126:             DumpScope(cx, cx->globalObject, stdout);
23126:         } else {
23126:             if (!JS_ValueToId(cx, STRING_TO_JSVAL(str), &id))
23126:                 return JS_FALSE;
53557:             JSObject *obj;
23126:             if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
23126:                 return JS_FALSE;
23126:             if (prop) {
31501:                 if (!obj->getProperty(cx, id, &value))
23126:                     return JS_FALSE;
23126:             }
48470:             if (!prop || !value.isObjectOrNull()) {
57721:                 fputs("js: invalid stats argument ", gErrFile);
57721:                 JS_FileEscapedString(gErrFile, str, 0);
57721:                 putc('\n', gErrFile);
23126:                 continue;
23126:             }
48470:             obj = value.toObjectOrNull();
23126:             if (obj)
23126:                 DumpScope(cx, obj, stdout);
23126:         }
23126:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: DumpHeap(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     jsval v;
23126:     void* startThing;
23126:     uint32 startTraceKind;
23126:     const char *badTraceArg;
23126:     void *thingToFind;
23126:     size_t maxDepth;
23126:     void *thingToIgnore;
23126:     FILE *dumpFile;
23126:     JSBool ok;
23126: 
57812:     const char *fileName = NULL;
57812:     JSAutoByteString fileNameBytes;
23126:     if (argc > 0) {
23126:         v = JS_ARGV(cx, vp)[0];
48470:         if (!JSVAL_IS_NULL(v)) {
23126:             JSString *str;
23126: 
23126:             str = JS_ValueToString(cx, v);
23126:             if (!str)
23126:                 return JS_FALSE;
23126:             JS_ARGV(cx, vp)[0] = STRING_TO_JSVAL(str);
57812:             if (!fileNameBytes.encode(cx, str))
57812:                 return JS_FALSE;
57812:             fileName = fileNameBytes.ptr();
23126:         }
23126:     }
23126: 
23126:     startThing = NULL;
23126:     startTraceKind = 0;
23126:     if (argc > 1) {
23126:         v = JS_ARGV(cx, vp)[1];
23126:         if (JSVAL_IS_TRACEABLE(v)) {
23126:             startThing = JSVAL_TO_TRACEABLE(v);
23126:             startTraceKind = JSVAL_TRACE_KIND(v);
48470:         } else if (!JSVAL_IS_NULL(v)) {
23126:             badTraceArg = "start";
23126:             goto not_traceable_arg;
23126:         }
23126:     }
23126: 
23126:     thingToFind = NULL;
23126:     if (argc > 2) {
23126:         v = JS_ARGV(cx, vp)[2];
23126:         if (JSVAL_IS_TRACEABLE(v)) {
23126:             thingToFind = JSVAL_TO_TRACEABLE(v);
48470:         } else if (!JSVAL_IS_NULL(v)) {
23126:             badTraceArg = "toFind";
23126:             goto not_traceable_arg;
23126:         }
23126:     }
23126: 
23126:     maxDepth = (size_t)-1;
23126:     if (argc > 3) {
23126:         v = JS_ARGV(cx, vp)[3];
48470:         if (!JSVAL_IS_NULL(v)) {
23126:             uint32 depth;
23126: 
23126:             if (!JS_ValueToECMAUint32(cx, v, &depth))
23126:                 return JS_FALSE;
23126:             maxDepth = depth;
23126:         }
23126:     }
23126: 
23126:     thingToIgnore = NULL;
23126:     if (argc > 4) {
23126:         v = JS_ARGV(cx, vp)[4];
23126:         if (JSVAL_IS_TRACEABLE(v)) {
23126:             thingToIgnore = JSVAL_TO_TRACEABLE(v);
48470:         } else if (!JSVAL_IS_NULL(v)) {
23126:             badTraceArg = "toIgnore";
23126:             goto not_traceable_arg;
23126:         }
23126:     }
23126: 
23126:     if (!fileName) {
23126:         dumpFile = stdout;
23126:     } else {
23126:         dumpFile = fopen(fileName, "w");
23126:         if (!dumpFile) {
23126:             JS_ReportError(cx, "can't open %s: %s", fileName, strerror(errno));
23126:             return JS_FALSE;
23126:         }
23126:     }
23126: 
23126:     ok = JS_DumpHeap(cx, dumpFile, startThing, startTraceKind, thingToFind,
23126:                      maxDepth, thingToIgnore);
23126:     if (dumpFile != stdout)
23126:         fclose(dumpFile);
23126:     return ok;
23126: 
23126:   not_traceable_arg:
23126:     JS_ReportError(cx, "argument '%s' is not null or a heap-allocated thing",
23126:                    badTraceArg);
23126:     return JS_FALSE;
23126: }
23126: 
49117: JSBool
53557: DumpObject(JSContext *cx, uintN argc, jsval *vp)
49117: {
49117:     JSObject *arg0 = NULL;
53557:     if (!JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "o", &arg0))
49117:         return JS_FALSE;
49117: 
49117:     js_DumpObject(arg0);
49117: 
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
49117:     return JS_TRUE;
49117: }
49117: 
23126: #endif /* DEBUG */
23126: 
71697: /*
71697:  * This shell function is temporary (used by testStackIter.js) and should be
71697:  * removed once JSD2 lands wholly subsumes the functionality here.
71697:  */
71697: JSBool
71697: DumpStack(JSContext *cx, uintN argc, Value *vp)
71697: {
71697:     JSObject *arr = JS_NewArrayObject(cx, 0, NULL);
71697:     if (!arr)
71697:         return false;
71697: 
71697:     JSString *evalStr = JS_NewStringCopyZ(cx, "eval-code");
71697:     if (!evalStr)
71697:         return false;
71697: 
71697:     JSString *globalStr = JS_NewStringCopyZ(cx, "global-code");
71697:     if (!globalStr)
71697:         return false;
71697: 
71697:     StackIter iter(cx);
71697:     JS_ASSERT(iter.nativeArgs().callee().getFunctionPrivate()->native() == DumpStack);
71697:     ++iter;
71697: 
71697:     jsint index = 0;
71697:     for (; !iter.done(); ++index, ++iter) {
71697:         Value v;
71697:         if (iter.isScript()) {
71697:             if (iter.fp()->isNonEvalFunctionFrame()) {
71697:                 if (!iter.fp()->getValidCalleeObject(cx, &v))
71697:                     return false;
71697:             } else if (iter.fp()->isEvalFrame()) {
71697:                 v = StringValue(evalStr);
71697:             } else {
71697:                 v = StringValue(globalStr);
71697:             }
71697:         } else {
71697:             v = iter.nativeArgs().calleev();
71697:         }
71697:         if (!JS_SetElement(cx, arr, index, Jsvalify(&v)))
71697:             return false;
71697:     }
71697: 
71697:     JS_SET_RVAL(cx, vp, ObjectValue(*arr));
71697:     return true;
71697: }
71697: 
23126: #ifdef TEST_CVTARGS
23126: #include <ctype.h>
23126: 
23126: static const char *
23126: EscapeWideString(jschar *w)
23126: {
23126:     static char enuf[80];
23126:     static char hex[] = "0123456789abcdef";
23126:     jschar u;
23126:     unsigned char b, c;
23126:     int i, j;
23126: 
23126:     if (!w)
23126:         return "";
23126:     for (i = j = 0; i < sizeof enuf - 1; i++, j++) {
23126:         u = w[j];
23126:         if (u == 0)
23126:             break;
23126:         b = (unsigned char)(u >> 8);
23126:         c = (unsigned char)(u);
23126:         if (b) {
23126:             if (i >= sizeof enuf - 6)
23126:                 break;
23126:             enuf[i++] = '\\';
23126:             enuf[i++] = 'u';
23126:             enuf[i++] = hex[b >> 4];
23126:             enuf[i++] = hex[b & 15];
23126:             enuf[i++] = hex[c >> 4];
23126:             enuf[i] = hex[c & 15];
23126:         } else if (!isprint(c)) {
23126:             if (i >= sizeof enuf - 4)
23126:                 break;
23126:             enuf[i++] = '\\';
23126:             enuf[i++] = 'x';
23126:             enuf[i++] = hex[c >> 4];
23126:             enuf[i] = hex[c & 15];
23126:         } else {
23126:             enuf[i] = (char)c;
23126:         }
23126:     }
23126:     enuf[i] = 0;
23126:     return enuf;
23126: }
23126: 
23126: #include <stdarg.h>
23126: 
23126: static JSBool
23126: ZZ_formatter(JSContext *cx, const char *format, JSBool fromJS, jsval **vpp,
23126:              va_list *app)
23126: {
23126:     jsval *vp;
23126:     va_list ap;
23126:     jsdouble re, im;
23126: 
23126:     printf("entering ZZ_formatter");
23126:     vp = *vpp;
23126:     ap = *app;
23126:     if (fromJS) {
23126:         if (!JS_ValueToNumber(cx, vp[0], &re))
23126:             return JS_FALSE;
23126:         if (!JS_ValueToNumber(cx, vp[1], &im))
23126:             return JS_FALSE;
23126:         *va_arg(ap, jsdouble *) = re;
23126:         *va_arg(ap, jsdouble *) = im;
23126:     } else {
23126:         re = va_arg(ap, jsdouble);
23126:         im = va_arg(ap, jsdouble);
23126:         if (!JS_NewNumberValue(cx, re, &vp[0]))
23126:             return JS_FALSE;
23126:         if (!JS_NewNumberValue(cx, im, &vp[1]))
23126:             return JS_FALSE;
23126:     }
23126:     *vpp = vp + 2;
23126:     *app = ap;
23126:     printf("leaving ZZ_formatter");
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53557: ConvertArgs(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSBool b = JS_FALSE;
23126:     jschar c = 0;
23126:     int32 i = 0, j = 0;
23126:     uint32 u = 0;
23126:     jsdouble d = 0, I = 0, re = 0, im = 0;
23126:     JSString *str = NULL;
23126:     jschar *w = NULL;
23126:     JSObject *obj2 = NULL;
23126:     JSFunction *fun = NULL;
23126:     jsval v = JSVAL_VOID;
23126:     JSBool ok;
23126: 
23126:     if (!JS_AddArgumentFormatter(cx, "ZZ", ZZ_formatter))
31366:         return JS_FALSE;
57812:     ok = JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "b/ciujdISWofvZZ*",
57812:                              &b, &c, &i, &u, &j, &d, &I, &str, &w, &obj2,
23126:                              &fun, &v, &re, &im);
23126:     JS_RemoveArgumentFormatter(cx, "ZZ");
23126:     if (!ok)
23126:         return JS_FALSE;
23126:     fprintf(gOutFile,
23126:             "b %u, c %x (%c), i %ld, u %lu, j %ld\n",
23126:             b, c, (char)c, i, u, j);
31366:     ToString obj2string(cx, obj2);
31366:     ToString valueString(cx, v);
57812:     JSAutoByteString strBytes;
57812:     if (str)
57812:         strBytes.encode(cx, str);
31366:     JSString *tmpstr = JS_DecompileFunction(cx, fun, 4);
57812:     JSAutoByteString func;
57812:     if (!tmpstr || !func.encode(cx, tmpstr));
47498:         ReportException(cx);
23126:     fprintf(gOutFile,
57812:             "d %g, I %g, S %s, W %s, obj %s, fun %s\n"
23126:             "v %s, re %g, im %g\n",
57812:             d, I, !!strBytes ? strBytes.ptr() : "", EscapeWideString(w),
31366:             obj2string.getBytes(),
57812:             fun ? (!!func ? func.ptr() : "error decompiling fun") : "",
31366:             valueString.getBytes(), re, im);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: #endif
23126: 
23126: static JSBool
23126: BuildDate(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     char version[20] = "\n";
23126: #if JS_VERSION < 150
23126:     sprintf(version, " for version %d\n", JS_VERSION);
23126: #endif
23126:     fprintf(gOutFile, "built on %s at %s%s", __DATE__, __TIME__, version);
23126:     *vp = JSVAL_VOID;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53557: Clear(JSContext *cx, uintN argc, jsval *vp)
23126: {
53557:     JSObject *obj;
53557:     if (argc != 0 && !JS_ValueToObject(cx, JS_ARGV(cx, vp)[0], &obj))
23126:         return JS_FALSE;
23126:     JS_ClearScope(cx, obj);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: Intern(JSContext *cx, uintN argc, jsval *vp)
23126: {
59889:     JSString *str = JS_ValueToString(cx, argc == 0 ? JSVAL_VOID : vp[2]);
23126:     if (!str)
59889:         return false;
59889: 
59889:     size_t length;
59889:     const jschar *chars = JS_GetStringCharsAndLength(cx, str, &length);
59889:     if (!chars)
59889:         return false;
59889: 
59889:     if (!JS_InternUCStringN(cx, chars, length))
59889:         return false;
59889: 
59889:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
59889:     return true;
23126: }
23126: 
23126: static JSBool
53557: Clone(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSObject *funobj, *parent, *clone;
23126: 
53557:     if (!argc)
53557:         return JS_FALSE;
53557: 
53557:     jsval *argv = JS_ARGV(cx, vp);
27012:     if (VALUE_IS_FUNCTION(cx, argv[0])) {
27012:         funobj = JSVAL_TO_OBJECT(argv[0]);
27012:     } else {
27012:         JSFunction *fun = JS_ValueToFunction(cx, argv[0]);
23126:         if (!fun)
23126:             return JS_FALSE;
23126:         funobj = JS_GetFunctionObject(fun);
27012:     }
23126:     if (argc > 1) {
23126:         if (!JS_ValueToObject(cx, argv[1], &parent))
23126:             return JS_FALSE;
23126:     } else {
23126:         parent = JS_GetParent(cx, funobj);
23126:     }
23126:     clone = JS_CloneFunctionObject(cx, funobj, parent);
23126:     if (!clone)
23126:         return JS_FALSE;
53557:     *vp = OBJECT_TO_JSVAL(clone);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: GetPDA(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSObject *vobj, *aobj, *pdobj;
23126:     JSBool ok;
23126:     JSPropertyDescArray pda;
23126:     JSPropertyDesc *pd;
23126:     uint32 i;
23126:     jsval v;
23126: 
23126:     if (!JS_ValueToObject(cx, argc == 0 ? JSVAL_VOID : vp[2], &vobj))
23126:         return JS_FALSE;
24303:     if (!vobj) {
24303:         *vp = JSVAL_VOID;
23126:         return JS_TRUE;
24303:     }
23126: 
23126:     aobj = JS_NewArrayObject(cx, 0, NULL);
23126:     if (!aobj)
23126:         return JS_FALSE;
23126:     *vp = OBJECT_TO_JSVAL(aobj);
23126: 
23126:     ok = JS_GetPropertyDescArray(cx, vobj, &pda);
23126:     if (!ok)
23126:         return JS_FALSE;
23126:     pd = pda.array;
24303:     for (i = 0; i < pda.length; i++, pd++) {
23126:         pdobj = JS_NewObject(cx, NULL, NULL, NULL);
23126:         if (!pdobj) {
23126:             ok = JS_FALSE;
23126:             break;
23126:         }
23126: 
23126:         /* Protect pdobj from GC by setting it as an element of aobj now */
23126:         v = OBJECT_TO_JSVAL(pdobj);
23126:         ok = JS_SetElement(cx, aobj, i, &v);
23126:         if (!ok)
23126:             break;
23126: 
23126:         ok = JS_SetProperty(cx, pdobj, "id", &pd->id) &&
23126:              JS_SetProperty(cx, pdobj, "value", &pd->value) &&
23126:              (v = INT_TO_JSVAL(pd->flags),
23126:               JS_SetProperty(cx, pdobj, "flags", &v)) &&
23126:              (v = INT_TO_JSVAL(pd->slot),
23126:               JS_SetProperty(cx, pdobj, "slot", &v)) &&
23126:              JS_SetProperty(cx, pdobj, "alias", &pd->alias);
23126:         if (!ok)
23126:             break;
23126:     }
23126:     JS_PutPropertyDescArray(cx, &pda);
23126:     return ok;
23126: }
23126: 
23126: static JSBool
23126: GetSLX(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSScript *script;
23126: 
23126:     script = ValueToScript(cx, argc == 0 ? JSVAL_VOID : vp[2]);
23126:     if (!script)
23126:         return JS_FALSE;
23126:     *vp = INT_TO_JSVAL(js_GetScriptLineExtent(script));
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: ToInt32(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     int32 i;
23126: 
23126:     if (!JS_ValueToInt32(cx, argc == 0 ? JSVAL_VOID : vp[2], &i))
23126:         return JS_FALSE;
23126:     return JS_NewNumberValue(cx, i, vp);
23126: }
23126: 
23126: static JSBool
53557: StringsAreUTF8(JSContext *cx, uintN argc, jsval *vp)
23126: {
53557:     *vp = JS_CStringsAreUTF8() ? JSVAL_TRUE : JSVAL_FALSE;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static const char* badUTF8 = "...\xC0...";
23126: static const char* bigUTF8 = "...\xFB\xBF\xBF\xBF\xBF...";
23126: static const jschar badSurrogate[] = { 'A', 'B', 'C', 0xDEEE, 'D', 'E', 0 };
23126: 
23126: static JSBool
53557: TestUTF8(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     int32 mode = 1;
23126:     jschar chars[20];
23126:     size_t charsLength = 5;
23126:     char bytes[20];
23126:     size_t bytesLength = 20;
53557:     if (argc && !JS_ValueToInt32(cx, *JS_ARGV(cx, vp), &mode))
23126:         return JS_FALSE;
23126: 
23126:     /* The following throw errors if compiled with UTF-8. */
23126:     switch (mode) {
23126:       /* mode 1: malformed UTF-8 string. */
23126:       case 1:
23126:         JS_NewStringCopyZ(cx, badUTF8);
23126:         break;
23126:       /* mode 2: big UTF-8 character. */
23126:       case 2:
23126:         JS_NewStringCopyZ(cx, bigUTF8);
23126:         break;
23126:       /* mode 3: bad surrogate character. */
23126:       case 3:
23126:         JS_EncodeCharacters(cx, badSurrogate, 6, bytes, &bytesLength);
23126:         break;
23126:       /* mode 4: use a too small buffer. */
23126:       case 4:
23126:         JS_DecodeBytes(cx, "1234567890", 10, chars, &charsLength);
23126:         break;
23126:       default:
23126:         JS_ReportError(cx, "invalid mode parameter");
23126:         return JS_FALSE;
23126:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return !JS_IsExceptionPending (cx);
23126: }
23126: 
23126: static JSBool
53557: ThrowError(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JS_ReportError(cx, "This is an error");
23126:     return JS_FALSE;
23126: }
23126: 
23126: #define LAZY_STANDARD_CLASSES
23126: 
23126: /* A class for easily testing the inner/outer object callbacks. */
23126: typedef struct ComplexObject {
23126:     JSBool isInner;
23126:     JSBool frozen;
23126:     JSObject *inner;
23126:     JSObject *outer;
23126: } ComplexObject;
23126: 
23126: static JSObject *
23126: split_create_outer(JSContext *cx);
23126: 
23126: static JSObject *
23126: split_create_inner(JSContext *cx, JSObject *outer);
23126: 
23126: static ComplexObject *
23126: split_get_private(JSContext *cx, JSObject *obj);
23126: 
23126: static JSBool
48470: split_addProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
23126:     ComplexObject *cpx;
23126: 
23126:     cpx = split_get_private(cx, obj);
23126:     if (!cpx)
23126:         return JS_TRUE;
23126:     if (!cpx->isInner && cpx->inner) {
23126:         /* Make sure to define this property on the inner object. */
48470:         return JS_DefinePropertyById(cx, cpx->inner, id, *vp, NULL, NULL, JSPROP_ENUMERATE);
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: split_getProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
23126:     ComplexObject *cpx;
23126: 
23126:     cpx = split_get_private(cx, obj);
23126:     if (!cpx)
23126:         return JS_TRUE;
32785: 
59889:     if (JSID_IS_ATOM(id) && JS_FlatStringEqualsAscii(JSID_TO_FLAT_STRING(id), "isInner")) {
32785:         *vp = BOOLEAN_TO_JSVAL(cpx->isInner);
32785:         return JS_TRUE;
32785:     }
32785: 
23126:     if (!cpx->isInner && cpx->inner) {
48470:         if (JSID_IS_ATOM(id)) {
59889:             JSString *str = JSID_TO_STRING(id);
59889: 
59889:             size_t length;
59889:             const jschar *chars = JS_GetStringCharsAndLength(cx, str, &length);
59889:             if (!chars)
59889:                 return false;
59889: 
59889:             return JS_GetUCProperty(cx, cpx->inner, chars, length, vp);
23126:         }
48470:         if (JSID_IS_INT(id))
48470:             return JS_GetElement(cx, cpx->inner, JSID_TO_INT(id), vp);
23126:         return JS_TRUE;
23126:     }
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
62395: split_setProperty(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
23126: {
23126:     ComplexObject *cpx;
23126: 
23126:     cpx = split_get_private(cx, obj);
23126:     if (!cpx)
59889:         return true;
23126:     if (!cpx->isInner && cpx->inner) {
48470:         if (JSID_IS_ATOM(id)) {
59889:             JSString *str = JSID_TO_STRING(id);
59889: 
59889:             size_t length;
59889:             const jschar *chars = JS_GetStringCharsAndLength(cx, str, &length);
59889:             if (!chars)
59889:                 return false;
59889: 
59889:             return JS_SetUCProperty(cx, cpx->inner, chars, length, vp);
23126:         }
48470:         if (JSID_IS_INT(id))
48470:             return JS_SetElement(cx, cpx->inner, JSID_TO_INT(id), vp);
59889:         return true;
59889:     }
59889: 
59889:     return true;
23126: }
23126: 
23126: static JSBool
48470: split_delProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
23126:     ComplexObject *cpx;
23126:     jsid asId;
23126: 
23126:     cpx = split_get_private(cx, obj);
23126:     if (!cpx)
23126:         return JS_TRUE;
23126:     if (!cpx->isInner && cpx->inner) {
23126:         /* Make sure to define this property on the inner object. */
23126:         if (!JS_ValueToId(cx, *vp, &asId))
23126:             return JS_FALSE;
54169:         return cpx->inner->deleteProperty(cx, asId, Valueify(vp), true);
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: split_enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
23126:                 jsval *statep, jsid *idp)
23126: {
23126:     ComplexObject *cpx;
23126:     JSObject *iterator;
23126: 
23126:     switch (enum_op) {
23126:       case JSENUMERATE_INIT:
47569:       case JSENUMERATE_INIT_ALL:
23126:         cpx = (ComplexObject *) JS_GetPrivate(cx, obj);
23126: 
23126:         if (!cpx->isInner && cpx->inner)
23126:             obj = cpx->inner;
23126: 
23126:         iterator = JS_NewPropertyIterator(cx, obj);
23126:         if (!iterator)
23126:             return JS_FALSE;
23126: 
23126:         *statep = OBJECT_TO_JSVAL(iterator);
23126:         if (idp)
48470:             *idp = INT_TO_JSID(0);
23126:         break;
23126: 
23126:       case JSENUMERATE_NEXT:
23126:         iterator = (JSObject*)JSVAL_TO_OBJECT(*statep);
23126:         if (!JS_NextProperty(cx, iterator, idp))
23126:             return JS_FALSE;
23126: 
48470:         if (!JSID_IS_VOID(*idp))
23126:             break;
23126:         /* Fall through. */
23126: 
23126:       case JSENUMERATE_DESTROY:
23126:         /* Let GC at our iterator object. */
23126:         *statep = JSVAL_NULL;
23126:         break;
23126:     }
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: split_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags, JSObject **objp)
23126: {
23126:     ComplexObject *cpx;
23126: 
59889:     if (JSID_IS_ATOM(id) && JS_FlatStringEqualsAscii(JSID_TO_FLAT_STRING(id), "isInner")) {
32785:         *objp = obj;
57721:         return JS_DefinePropertyById(cx, obj, id, JSVAL_VOID, NULL, NULL, JSPROP_SHARED);
32785:     }
32785: 
23126:     cpx = split_get_private(cx, obj);
23126:     if (!cpx)
23126:         return JS_TRUE;
23126:     if (!cpx->isInner && cpx->inner) {
23126:         JSProperty *prop;
56567:         return cpx->inner->lookupProperty(cx, id, objp, &prop);
23126:     }
23126: 
23126: #ifdef LAZY_STANDARD_CLASSES
23126:     if (!(flags & JSRESOLVE_ASSIGNING)) {
23126:         JSBool resolved;
23126: 
73063:         if (!JS_ResolveStandardClass(cx, obj, id, &resolved))
23126:             return JS_FALSE;
23126: 
23126:         if (resolved) {
23126:             *objp = obj;
23126:             return JS_TRUE;
23126:         }
23126:     }
23126: #endif
23126: 
23126:     /* XXX For additional realism, let's resolve some random property here. */
23126:     return JS_TRUE;
23126: }
23126: 
23126: static void
23126: split_finalize(JSContext *cx, JSObject *obj)
23126: {
23126:     JS_free(cx, JS_GetPrivate(cx, obj));
23126: }
23126: 
64218: static void
64218: split_trace(JSTracer *trc, JSObject *obj)
23126: {
23126:     ComplexObject *cpx;
23126: 
64218:     cpx = (ComplexObject *) JS_GetPrivate(trc->context, obj);
23126: 
64357:     if (!cpx)
64357:         return; /* The object is not fully constructed. */
64357: 
23126:     if (!cpx->isInner && cpx->inner) {
23126:         /* Mark the inner object. */
64218:         JS_CALL_TRACER(trc, cpx->inner, JSTRACE_OBJECT, "ComplexObject.inner");
23126:     }
23126: 
60533:     if (cpx->isInner && cpx->outer) {
60533:         /* Mark the inner object. */
64218:         JS_CALL_TRACER(trc, cpx->outer, JSTRACE_OBJECT, "ComplexObject.outer");
64218:     }
23126: }
23126: 
23126: static JSObject *
23126: split_outerObject(JSContext *cx, JSObject *obj)
23126: {
23126:     ComplexObject *cpx;
23126: 
23126:     cpx = (ComplexObject *) JS_GetPrivate(cx, obj);
23126:     return cpx->isInner ? cpx->outer : obj;
23126: }
23126: 
32785: static JSObject *
42679: split_thisObject(JSContext *cx, JSObject *obj)
32785: {
32785:     OBJ_TO_OUTER_OBJECT(cx, obj);
32785:     if (!obj)
32785:         return NULL;
32785:     return obj;
32785: }
32785: 
32785: 
23126: static JSBool
48470: split_equality(JSContext *cx, JSObject *obj, const jsval *v, JSBool *bp);
23126: 
23126: static JSObject *
23126: split_innerObject(JSContext *cx, JSObject *obj)
23126: {
23126:     ComplexObject *cpx;
23126: 
23126:     cpx = (ComplexObject *) JS_GetPrivate(cx, obj);
23126:     if (cpx->frozen) {
23126:         JS_ASSERT(!cpx->isInner);
23126:         return obj;
23126:     }
23126:     return !cpx->isInner ? cpx->inner : obj;
23126: }
23126: 
48622: static Class split_global_class = {
48622:     "split_global",
48622:     JSCLASS_NEW_RESOLVE | JSCLASS_NEW_ENUMERATE | JSCLASS_HAS_PRIVATE | JSCLASS_GLOBAL_FLAGS,
48622:     Valueify(split_addProperty),
48622:     Valueify(split_delProperty),
48622:     Valueify(split_getProperty),
48622:     Valueify(split_setProperty),
23126:     (JSEnumerateOp)split_enumerate,
23126:     (JSResolveOp)split_resolve,
48622:     ConvertStub,
48622:     split_finalize,
48622:     NULL,           /* reserved0   */
48622:     NULL,           /* checkAccess */
48622:     NULL,           /* call        */
48622:     NULL,           /* construct   */
48622:     NULL,           /* xdrObject   */
48622:     NULL,           /* hasInstance */
64218:     split_trace,
48622:     {
48622:         Valueify(split_equality),
48622:         split_outerObject,
48622:         split_innerObject,
48622:         NULL, /* iteratorObject */
48622:         NULL, /* wrappedObject  */
48622:     },
48622:     {
48622:         NULL, /* lookupProperty */
48622:         NULL, /* defineProperty */
48622:         NULL, /* getProperty    */
48622:         NULL, /* setProperty    */
48622:         NULL, /* getAttributes  */
48622:         NULL, /* setAttributes  */
48622:         NULL, /* deleteProperty */
48622:         NULL, /* enumerate      */
48622:         NULL, /* typeOf         */
54563:         NULL, /* fix            */
48622:         split_thisObject,
48622:         NULL, /* clear          */
48622:     },
23126: };
23126: 
23126: static JSBool
48470: split_equality(JSContext *cx, JSObject *obj, const jsval *v, JSBool *bp)
23126: {
23126:     *bp = JS_FALSE;
48470:     if (JSVAL_IS_PRIMITIVE(*v))
23126:         return JS_TRUE;
23126: 
48470:     JSObject *obj2 = JSVAL_TO_OBJECT(*v);
48622:     if (obj2->getClass() != &split_global_class)
23126:         return JS_TRUE;
23126: 
23126:     ComplexObject *cpx = (ComplexObject *) JS_GetPrivate(cx, obj2);
23126:     JS_ASSERT(!cpx->isInner);
23126: 
23126:     ComplexObject *ourCpx = (ComplexObject *) JS_GetPrivate(cx, obj);
23126:     JS_ASSERT(!ourCpx->isInner);
23126: 
23126:     *bp = (cpx == ourCpx);
23126:     return JS_TRUE;
23126: }
23126: 
23126: JSObject *
23126: split_create_outer(JSContext *cx)
23126: {
23126:     ComplexObject *cpx;
23126:     JSObject *obj;
23126: 
23126:     cpx = (ComplexObject *) JS_malloc(cx, sizeof *obj);
23126:     if (!cpx)
23126:         return NULL;
23126:     cpx->isInner = JS_FALSE;
23126:     cpx->frozen = JS_TRUE;
23126:     cpx->inner = NULL;
23126:     cpx->outer = NULL;
23126: 
48622:     obj = JS_NewGlobalObject(cx, Jsvalify(&split_global_class));
50472:     if (!obj) {
23126:         JS_free(cx, cpx);
23126:         return NULL;
23126:     }
23126: 
23126:     if (!JS_SetPrivate(cx, obj, cpx)) {
23126:         JS_free(cx, cpx);
23126:         return NULL;
23126:     }
23126: 
23126:     return obj;
23126: }
23126: 
23126: static JSObject *
23126: split_create_inner(JSContext *cx, JSObject *outer)
23126: {
23126:     ComplexObject *cpx, *outercpx;
23126:     JSObject *obj;
23126: 
48622:     JS_ASSERT(outer->getClass() == &split_global_class);
23126: 
23126:     cpx = (ComplexObject *) JS_malloc(cx, sizeof *cpx);
23126:     if (!cpx)
23126:         return NULL;
23126:     cpx->isInner = JS_TRUE;
23126:     cpx->frozen = JS_FALSE;
23126:     cpx->inner = NULL;
23126:     cpx->outer = outer;
23126: 
48622:     obj = JS_NewGlobalObject(cx, Jsvalify(&split_global_class));
50486:     if (!obj || !JS_SetPrivate(cx, obj, cpx)) {
23126:         JS_free(cx, cpx);
23126:         return NULL;
23126:     }
23126: 
23126:     outercpx = (ComplexObject *) JS_GetPrivate(cx, outer);
23126:     outercpx->inner = obj;
23126:     outercpx->frozen = JS_FALSE;
23126: 
23126:     return obj;
23126: }
23126: 
23126: static ComplexObject *
23126: split_get_private(JSContext *cx, JSObject *obj)
23126: {
23126:     do {
48622:         if (obj->getClass() == &split_global_class)
23126:             return (ComplexObject *) JS_GetPrivate(cx, obj);
23126:         obj = JS_GetParent(cx, obj);
23126:     } while (obj);
23126: 
23126:     return NULL;
23126: }
23126: 
23126: static JSBool
23126: sandbox_enumerate(JSContext *cx, JSObject *obj)
23126: {
23126:     jsval v;
23126:     JSBool b;
23126: 
30581:     if (!JS_GetProperty(cx, obj, "lazy", &v))
23126:         return JS_FALSE;
30581: 
30581:     JS_ValueToBoolean(cx, v, &b);
23126:     return !b || JS_EnumerateStandardClasses(cx, obj);
23126: }
23126: 
23126: static JSBool
48470: sandbox_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
23126:                 JSObject **objp)
23126: {
23126:     jsval v;
23126:     JSBool b, resolved;
23126: 
30581:     if (!JS_GetProperty(cx, obj, "lazy", &v))
23126:         return JS_FALSE;
30581: 
30581:     JS_ValueToBoolean(cx, v, &b);
23126:     if (b && (flags & JSRESOLVE_ASSIGNING) == 0) {
73063:         if (!JS_ResolveStandardClass(cx, obj, id, &resolved))
23126:             return JS_FALSE;
23126:         if (resolved) {
23126:             *objp = obj;
23126:             return JS_TRUE;
23126:         }
23126:     }
23126:     *objp = NULL;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSClass sandbox_class = {
23126:     "sandbox",
38533:     JSCLASS_NEW_RESOLVE | JSCLASS_GLOBAL_FLAGS,
23126:     JS_PropertyStub,   JS_PropertyStub,
62395:     JS_PropertyStub,   JS_StrictPropertyStub,
23126:     sandbox_enumerate, (JSResolveOp)sandbox_resolve,
30654:     JS_ConvertStub,    NULL,
23126:     JSCLASS_NO_OPTIONAL_MEMBERS
23126: };
23126: 
47498: static JSObject *
47498: NewSandbox(JSContext *cx, bool lazy, bool split)
47498: {
47516:     JSObject *obj = JS_NewCompartmentAndGlobalObject(cx, &sandbox_class, NULL);
47498:     if (!obj)
47498:         return NULL;
47498: 
47504:     {
54733:         JSAutoEnterCompartment ac;
47517:         if (!ac.enter(cx, obj))
47498:             return NULL;
47498: 
47498:         if (split) {
47498:             obj = split_setup(cx, JS_TRUE);
47504:             if (!obj)
47504:                 return NULL;
47504:         }
47504:         if (!lazy && !JS_InitStandardClasses(cx, obj))
47504:             return NULL;
47498: 
48470:         AutoValueRooter root(cx, BooleanValue(lazy));
48470:         if (!JS_SetProperty(cx, obj, "lazy", root.jsval_addr()))
47504:             return NULL;
47504: 
47504:         if (split)
47498:             obj = split_outerObject(cx, obj);
47504:     }
47498: 
47498:     AutoObjectRooter objroot(cx, obj);
47498:     if (!cx->compartment->wrap(cx, objroot.addr()))
47498:         return NULL;
47498:     return objroot.object();
47498: }
47498: 
23126: static JSBool
53557: EvalInContext(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSString *str;
47498:     JSObject *sobj = NULL;
53557:     if (!JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "S / o", &str, &sobj))
47498:         return false;
47498: 
59889:     size_t srclen;
59889:     const jschar *src = JS_GetStringCharsAndLength(cx, str, &srclen);
59889:     if (!src)
59889:         return false;
59889: 
47498:     bool split = false, lazy = false;
35108:     if (srclen == 4) {
35108:         if (src[0] == 'l' && src[1] == 'a' && src[2] == 'z' && src[3] == 'y') {
47498:             lazy = true;
23126:             srclen = 0;
23126:         }
35108:     } else if (srclen == 5) {
35108:         if (src[0] == 's' && src[1] == 'p' && src[2] == 'l' && src[3] == 'i' && src[4] == 't') {
47498:             split = lazy = true;
35108:             srclen = 0;
35108:         }
35108:     }
23126: 
23126:     if (!sobj) {
47498:         sobj = NewSandbox(cx, lazy, split);
47498:         if (!sobj)
47498:             return false;
47498:     }
47498: 
73070:     if (srclen == 0) {
73070:         JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(sobj));
47498:         return true;
73070:     }
47498: 
47498:     JSStackFrame *fp = JS_GetScriptedCaller(cx, NULL);
69223:     JSScript *script = JS_GetFrameScript(cx, fp);
69223:     jsbytecode *pc = JS_GetFramePC(cx, fp);
73070:     jsval rval;
47522:     {
54733:         JSAutoEnterCompartment ac;
62594:         uintN flags;
62594:         JSObject *unwrapped = sobj->unwrap(&flags);
62594:         if (flags & JSWrapper::CROSS_COMPARTMENT) {
62594:             sobj = unwrapped;
47517:             if (!ac.enter(cx, sobj))
47498:                 return false;
47498:         }
47498: 
47498:         OBJ_TO_INNER_OBJECT(cx, sobj);
47517:         if (!sobj)
47517:             return false;
47517:         if (!(sobj->getClass()->flags & JSCLASS_IS_GLOBAL)) {
42742:             JS_ReportError(cx, "Invalid scope argument to evalcx");
47517:             return false;
47517:         }
47517:         if (!JS_EvaluateUCScript(cx, sobj, src, srclen,
69223:                                  script->filename,
69223:                                  JS_PCToLineNumber(cx, script, pc),
73070:                                  &rval)) {
47517:             return false;
47517:         }
47522:     }
73070: 
73070:     if (!cx->compartment->wrap(cx, Valueify(&rval)))
73070:         return false;
73070: 
73070:     JS_SET_RVAL(cx, vp, rval);
73070:     return true;
23126: }
23126: 
23126: static JSBool
40276: EvalInFrame(JSContext *cx, uintN argc, jsval *vp)
40276: {
40276:     jsval *argv = JS_ARGV(cx, vp);
40276:     if (argc < 2 ||
40276:         !JSVAL_IS_INT(argv[0]) ||
40276:         !JSVAL_IS_STRING(argv[1])) {
40276:         JS_ReportError(cx, "Invalid arguments to evalInFrame");
40276:         return JS_FALSE;
40276:     }
40276: 
40276:     uint32 upCount = JSVAL_TO_INT(argv[0]);
40276:     JSString *str = JSVAL_TO_STRING(argv[1]);
40276: 
40279:     bool saveCurrent = (argc >= 3 && JSVAL_IS_BOOLEAN(argv[2]))
48470:                         ? !!(JSVAL_TO_BOOLEAN(argv[2]))
40276:                         : false;
40276: 
71696:     JS_ASSERT(cx->hasfp());
40276: 
42717:     FrameRegsIter fi(cx);
42717:     for (uint32 i = 0; i < upCount; ++i, ++fi) {
53840:         if (!fi.fp()->prev())
40276:             break;
42717:     }
42717: 
69223:     StackFrame *const fp = fi.fp();
69223:     if (!fp->isScriptFrame()) {
40276:         JS_ReportError(cx, "cannot eval in non-script frame");
40276:         return JS_FALSE;
40276:     }
40276: 
71697:     JSBool saved = JS_FALSE;;
40276:     if (saveCurrent)
71697:         saved = JS_SaveFrameChain(cx);
40276: 
59890:     size_t length;
59890:     const jschar *chars = JS_GetStringCharsAndLength(cx, str, &length);
59890:     if (!chars)
59890:         return JS_FALSE;
59890: 
69223:     JSBool ok = JS_EvaluateUCInStackFrame(cx, Jsvalify(fp), chars, length,
53840:                                           fp->script()->filename,
53840:                                           JS_PCToLineNumber(cx, fp->script(),
42717:                                                             fi.pc()),
40276:                                           vp);
40276: 
71697:     if (saved)
71697:         JS_RestoreFrameChain(cx);
40276: 
40276:     return ok;
40276: }
40276: 
40276: static JSBool
23126: ShapeOf(JSContext *cx, uintN argc, jsval *vp)
23126: {
58981:     jsval v;
58981:     if (argc < 1 || !JSVAL_IS_OBJECT(v = JS_ARGV(cx, vp)[0])) {
23126:         JS_ReportError(cx, "shapeOf: object expected");
23126:         return JS_FALSE;
23126:     }
27165:     JSObject *obj = JSVAL_TO_OBJECT(v);
27165:     if (!obj) {
27165:         *vp = JSVAL_ZERO;
27165:         return JS_TRUE;
27165:     }
40430:     if (!obj->isNative()) {
27165:         *vp = INT_TO_JSVAL(-1);
27165:         return JS_TRUE;
27165:     }
40847:     return JS_NewNumberValue(cx, obj->shape(), vp);
23126: }
23126: 
62970: /*
62970:  * If referent has an own property named id, copy that property to obj[id].
62970:  * Since obj is native, this isn't totally transparent; properties of a
62970:  * non-native referent may be simplified to data properties.
62970:  */
62970: static JSBool
62970: CopyProperty(JSContext *cx, JSObject *obj, JSObject *referent, jsid id,
62970:              uintN lookupFlags, JSObject **objp)
62970: {
62970:     JSProperty *prop;
62970:     PropertyDescriptor desc;
62970:     uintN propFlags = 0;
62970:     JSObject *obj2;
62970: 
62970:     *objp = NULL;
62970:     if (referent->isNative()) {
69855:         if (!LookupPropertyWithFlags(cx, referent, id, lookupFlags, &obj2, &prop))
62970:             return false;
62970:         if (obj2 != referent)
62970:             return true;
62970: 
62970:         const Shape *shape = (Shape *) prop;
62970:         if (shape->isMethod()) {
62970:             shape = referent->methodReadBarrier(cx, *shape, &desc.value);
62970:             if (!shape)
62970:                 return false;
62970:         } else if (shape->hasSlot()) {
62970:             desc.value = referent->nativeGetSlot(shape->slot);
62970:         } else {
62970:             desc.value.setUndefined();
62970:         }
62970: 
62970:         desc.attrs = shape->attributes();
62970:         desc.getter = shape->getter();
62970:         if (!desc.getter && !(desc.attrs & JSPROP_GETTER))
62970:             desc.getter = PropertyStub;
62970:         desc.setter = shape->setter();
62970:         if (!desc.setter && !(desc.attrs & JSPROP_SETTER))
62970:             desc.setter = StrictPropertyStub;
62970:         desc.shortid = shape->shortid;
62970:         propFlags = shape->getFlags();
62970:    } else if (referent->isProxy()) {
62970:         PropertyDescriptor desc;
62970:         if (!JSProxy::getOwnPropertyDescriptor(cx, referent, id, false, &desc))
62970:             return false;
62970:         if (!desc.obj)
62970:             return true;
62970:     } else {
62970:         if (!referent->lookupProperty(cx, id, objp, &prop))
62970:             return false;
62970:         if (*objp != referent)
62970:             return true;
62970:         if (!referent->getProperty(cx, id, &desc.value) ||
62970:             !referent->getAttributes(cx, id, &desc.attrs)) {
62970:             return false;
62970:         }
62970:         desc.attrs &= JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT;
62970:         desc.getter = PropertyStub;
62970:         desc.setter = StrictPropertyStub;
62970:         desc.shortid = 0;
62970:     }
62970: 
62970:     *objp = obj;
69855:     return !!DefineNativeProperty(cx, obj, id, desc.value, desc.getter, desc.setter,
69855:                                   desc.attrs, propFlags, desc.shortid);
62970: }
62970: 
62970: static JSBool
62970: resolver_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags, JSObject **objp)
62970: {
62970:     jsval v;
62970:     JS_ALWAYS_TRUE(JS_GetReservedSlot(cx, obj, 0, &v));
62970:     return CopyProperty(cx, obj, JSVAL_TO_OBJECT(v), id, flags, objp);
62970: }
62970: 
62970: static JSBool
62970: resolver_enumerate(JSContext *cx, JSObject *obj)
62970: {
62970:     jsval v;
62970:     JS_ALWAYS_TRUE(JS_GetReservedSlot(cx, obj, 0, &v));
62970:     JSObject *referent = JSVAL_TO_OBJECT(v);
62970: 
62970:     AutoIdArray ida(cx, JS_Enumerate(cx, referent));
62970:     bool ok = !!ida;
62970:     JSObject *ignore;
62970:     for (size_t i = 0; ok && i < ida.length(); i++)
62970:         ok = CopyProperty(cx, obj, referent, ida[i], JSRESOLVE_QUALIFIED, &ignore);
62970:     return ok;
62970: }
62970: 
62970: static JSClass resolver_class = {
62970:     "resolver",
62970:     JSCLASS_NEW_RESOLVE | JSCLASS_HAS_RESERVED_SLOTS(1),
62970:     JS_PropertyStub,   JS_PropertyStub,
62970:     JS_PropertyStub,   JS_StrictPropertyStub,
62970:     resolver_enumerate, (JSResolveOp)resolver_resolve,
62970:     JS_ConvertStub,    NULL,
62970:     JSCLASS_NO_OPTIONAL_MEMBERS
62970: };
62970: 
62970: 
62970: static JSBool
62970: Resolver(JSContext *cx, uintN argc, jsval *vp)
62970: {
62970:     JSObject *referent, *proto = NULL;
62970:     if (!JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "o/o", &referent, &proto))
62970:         return false;
62970: 
62970:     JSObject *result = (argc > 1
62970:                         ? JS_NewObjectWithGivenProto
62970:                         : JS_NewObject)(cx, &resolver_class, proto, JS_GetParent(cx, referent));
62970:     if (!result)
62970:         return false;
62970: 
62970:     JS_ALWAYS_TRUE(JS_SetReservedSlot(cx, result, 0, OBJECT_TO_JSVAL(referent)));
62970:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(result));
62970:     return true;
62970: }
62970: 
23126: #ifdef JS_THREADSAFE
23126: 
25472: /*
25472:  * Check that t1 comes strictly before t2. The function correctly deals with
25472:  * PRIntervalTime wrap-around between t2 and t1 assuming that t2 and t1 stays
25472:  * within INT32_MAX from each other. We use MAX_TIMEOUT_INTERVAL to enforce
25472:  * this restriction.
25472:  */
25472: static bool
25472: IsBefore(PRIntervalTime t1, PRIntervalTime t2)
25472: {
25472:     return int32(t1 - t2) < 0;
25472: }
25472: 
23126: static JSBool
23126: Sleep_fn(JSContext *cx, uintN argc, jsval *vp)
23126: {
25472:     PRIntervalTime t_ticks;
25472: 
25472:     if (argc == 0) {
25472:         t_ticks = 0;
25472:     } else {
23126:         jsdouble t_secs;
23126: 
23126:         if (!JS_ValueToNumber(cx, argc == 0 ? JSVAL_VOID : vp[2], &t_secs))
23126:             return JS_FALSE;
23126: 
25472:         /* NB: The next condition also filter out NaNs. */
25472:         if (!(t_secs <= MAX_TIMEOUT_INTERVAL)) {
25472:             JS_ReportError(cx, "Excessive sleep interval");
25472:             return JS_FALSE;
25472:         }
25472:         t_ticks = (t_secs <= 0.0)
25472:                   ? 0
25472:                   : PRIntervalTime(PR_TicksPerSecond() * t_secs);
25472:     }
25472:     if (t_ticks == 0) {
25472:         JS_YieldRequest(cx);
25472:     } else {
40289:         JSAutoSuspendRequest suspended(cx);
25472:         PR_Lock(gWatchdogLock);
25472:         PRIntervalTime to_wakeup = PR_IntervalNow() + t_ticks;
25472:         for (;;) {
25472:             PR_WaitCondVar(gSleepWakeup, t_ticks);
25472:             if (gCanceled)
25472:                 break;
25472:             PRIntervalTime now = PR_IntervalNow();
25472:             if (!IsBefore(now, to_wakeup))
25472:                 break;
25472:             t_ticks = to_wakeup - now;
25472:         }
25472:         PR_Unlock(gWatchdogLock);
25472:     }
25472:     return !gCanceled;
23126: }
23126: 
23126: typedef struct ScatterThreadData ScatterThreadData;
23126: typedef struct ScatterData ScatterData;
23126: 
23126: typedef enum ScatterStatus {
23126:     SCATTER_WAIT,
23126:     SCATTER_GO,
23126:     SCATTER_CANCEL
23126: } ScatterStatus;
23126: 
23126: struct ScatterData {
23126:     ScatterThreadData   *threads;
23126:     jsval               *results;
23126:     PRLock              *lock;
23126:     PRCondVar           *cvar;
23126:     ScatterStatus       status;
23126: };
23126: 
23126: struct ScatterThreadData {
23126:     jsint               index;
23126:     ScatterData         *shared;
23126:     PRThread            *thr;
23126:     JSContext           *cx;
23126:     jsval               fn;
23126: };
23126: 
23126: static void
23126: DoScatteredWork(JSContext *cx, ScatterThreadData *td)
23126: {
23126:     jsval *rval = &td->shared->results[td->index];
23126: 
25087:     if (!JS_CallFunctionValue(cx, NULL, td->fn, 0, NULL, rval)) {
23126:         *rval = JSVAL_VOID;
23126:         JS_GetPendingException(cx, rval);
23126:         JS_ClearPendingException(cx);
23126:     }
23126: }
23126: 
23126: static void
23126: RunScatterThread(void *arg)
23126: {
26673:     int stackDummy;
23126:     ScatterThreadData *td;
23126:     ScatterStatus st;
23126:     JSContext *cx;
23126: 
26673:     if (PR_FAILURE == PR_SetThreadPrivate(gStackBaseThreadIndex, &stackDummy))
26673:         return;
26673: 
23126:     td = (ScatterThreadData *)arg;
23126:     cx = td->cx;
23126: 
25087:     /* Wait for our signal. */
23126:     PR_Lock(td->shared->lock);
23126:     while ((st = td->shared->status) == SCATTER_WAIT)
23126:         PR_WaitCondVar(td->shared->cvar, PR_INTERVAL_NO_TIMEOUT);
23126:     PR_Unlock(td->shared->lock);
23126: 
23126:     if (st == SCATTER_CANCEL)
23126:         return;
23126: 
25087:     /* We are good to go. */
23126:     JS_SetContextThread(cx);
42740:     JS_SetNativeStackQuota(cx, gMaxStackSize);
23126:     JS_BeginRequest(cx);
23126:     DoScatteredWork(cx, td);
23126:     JS_EndRequest(cx);
23126:     JS_ClearContextThread(cx);
23126: }
23126: 
23126: /*
23126:  * scatter(fnArray) - Call each function in `fnArray` without arguments, each
23126:  * in a different thread. When all threads have finished, return an array: the
23126:  * return values. Errors are not propagated; if any of the function calls
23126:  * fails, the corresponding element in the results array gets the exception
23126:  * object, if any, else (undefined).
23126:  */
23126: static JSBool
23126: Scatter(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     jsuint i;
23126:     jsuint n;  /* number of threads */
23126:     JSObject *inArr;
23126:     JSObject *arr;
40289:     JSObject *global;
23126:     ScatterData sd;
23126:     JSBool ok;
23126: 
23126:     sd.lock = NULL;
23126:     sd.cvar = NULL;
23126:     sd.results = NULL;
23126:     sd.threads = NULL;
23126:     sd.status = SCATTER_WAIT;
23126: 
23126:     if (argc == 0 || JSVAL_IS_PRIMITIVE(JS_ARGV(cx, vp)[0])) {
23126:         JS_ReportError(cx, "the first argument must be an object");
23126:         goto fail;
23126:     }
23126: 
23126:     inArr = JSVAL_TO_OBJECT(JS_ARGV(cx, vp)[0]);
23126:     ok = JS_GetArrayLength(cx, inArr, &n);
23126:     if (!ok)
23126:         goto out;
23126:     if (n == 0)
23126:         goto success;
23126: 
23126:     sd.lock = PR_NewLock();
23126:     if (!sd.lock)
23126:         goto fail;
23126: 
23126:     sd.cvar = PR_NewCondVar(sd.lock);
23126:     if (!sd.cvar)
23126:         goto fail;
23126: 
23126:     sd.results = (jsval *) malloc(n * sizeof(jsval));
23126:     if (!sd.results)
23126:         goto fail;
23126:     for (i = 0; i < n; i++) {
23126:         sd.results[i] = JSVAL_VOID;
47403:         ok = JS_AddValueRoot(cx, &sd.results[i]);
23126:         if (!ok) {
23126:             while (i-- > 0)
47403:                 JS_RemoveValueRoot(cx, &sd.results[i]);
23126:             free(sd.results);
23126:             sd.results = NULL;
23126:             goto fail;
23126:         }
23126:     }
23126: 
23126:     sd.threads = (ScatterThreadData *) malloc(n * sizeof(ScatterThreadData));
23126:     if (!sd.threads)
23126:         goto fail;
23126:     for (i = 0; i < n; i++) {
23126:         sd.threads[i].index = i;
23126:         sd.threads[i].shared = &sd;
23126:         sd.threads[i].thr = NULL;
23126:         sd.threads[i].cx = NULL;
23126:         sd.threads[i].fn = JSVAL_NULL;
23126: 
47403:         ok = JS_AddValueRoot(cx, &sd.threads[i].fn);
23126:         if (ok && !JS_GetElement(cx, inArr, (jsint) i, &sd.threads[i].fn)) {
47403:             JS_RemoveValueRoot(cx, &sd.threads[i].fn);
23126:             ok = JS_FALSE;
23126:         }
23126:         if (!ok) {
23126:             while (i-- > 0)
47403:                 JS_RemoveValueRoot(cx, &sd.threads[i].fn);
23126:             free(sd.threads);
23126:             sd.threads = NULL;
23126:             goto fail;
23126:         }
23126:     }
23126: 
40289:     global = JS_GetGlobalObject(cx);
23126:     for (i = 1; i < n; i++) {
40801:         JSContext *newcx = NewContext(JS_GetRuntime(cx));
23126:         if (!newcx)
23126:             goto fail;
40289: 
40289:         {
48481:             JSAutoRequest req(newcx);
40289:             JS_SetGlobalObject(newcx, global);
40289:         }
23126:         JS_ClearContextThread(newcx);
23126:         sd.threads[i].cx = newcx;
23126:     }
23126: 
23126:     for (i = 1; i < n; i++) {
23126:         PRThread *t = PR_CreateThread(PR_USER_THREAD,
23126:                                       RunScatterThread,
23126:                                       &sd.threads[i],
23126:                                       PR_PRIORITY_NORMAL,
23126:                                       PR_GLOBAL_THREAD,
23126:                                       PR_JOINABLE_THREAD,
23126:                                       0);
23126:         if (!t) {
23126:             /* Failed to start thread. */
23126:             PR_Lock(sd.lock);
23126:             sd.status = SCATTER_CANCEL;
23126:             PR_NotifyAllCondVar(sd.cvar);
23126:             PR_Unlock(sd.lock);
23126:             while (i-- > 1)
23126:                 PR_JoinThread(sd.threads[i].thr);
23126:             goto fail;
23126:         }
23126: 
23126:         sd.threads[i].thr = t;
23126:     }
23126:     PR_Lock(sd.lock);
23126:     sd.status = SCATTER_GO;
23126:     PR_NotifyAllCondVar(sd.cvar);
23126:     PR_Unlock(sd.lock);
23126: 
23126:     DoScatteredWork(cx, &sd.threads[0]);
23126: 
40289:     {
40289:         JSAutoSuspendRequest suspended(cx);
23126:         for (i = 1; i < n; i++) {
23126:             PR_JoinThread(sd.threads[i].thr);
23126:         }
40289:     }
23126: 
23126: success:
23126:     arr = JS_NewArrayObject(cx, n, sd.results);
23126:     if (!arr)
23126:         goto fail;
23126:     *vp = OBJECT_TO_JSVAL(arr);
23126:     ok = JS_TRUE;
23126: 
23126: out:
23126:     if (sd.threads) {
23126:         JSContext *acx;
23126: 
23126:         for (i = 0; i < n; i++) {
47403:             JS_RemoveValueRoot(cx, &sd.threads[i].fn);
23126:             acx = sd.threads[i].cx;
23126:             if (acx) {
23126:                 JS_SetContextThread(acx);
40801:                 DestroyContext(acx, true);
23126:             }
23126:         }
23126:         free(sd.threads);
23126:     }
23126:     if (sd.results) {
23126:         for (i = 0; i < n; i++)
47403:             JS_RemoveValueRoot(cx, &sd.results[i]);
23126:         free(sd.results);
23126:     }
23126:     if (sd.cvar)
23126:         PR_DestroyCondVar(sd.cvar);
23126:     if (sd.lock)
23126:         PR_DestroyLock(sd.lock);
23126: 
23126:     return ok;
23126: 
23126: fail:
23126:     ok = JS_FALSE;
23126:     goto out;
23126: }
23726: 
25472: static bool
25472: InitWatchdog(JSRuntime *rt)
25472: {
25472:     JS_ASSERT(!gWatchdogThread);
25472:     gWatchdogLock = PR_NewLock();
25472:     if (gWatchdogLock) {
25472:         gWatchdogWakeup = PR_NewCondVar(gWatchdogLock);
25472:         if (gWatchdogWakeup) {
25472:             gSleepWakeup = PR_NewCondVar(gWatchdogLock);
25472:             if (gSleepWakeup)
25472:                 return true;
25472:             PR_DestroyCondVar(gWatchdogWakeup);
25472:         }
25472:         PR_DestroyLock(gWatchdogLock);
25472:     }
25472:     return false;
25472: }
25472: 
25472: static void
25472: KillWatchdog()
25472: {
25472:     PRThread *thread;
25472: 
25472:     PR_Lock(gWatchdogLock);
25472:     thread = gWatchdogThread;
25472:     if (thread) {
25472:         /*
25472:          * The watchdog thread is running, tell it to terminate waking it up
25472:          * if necessary.
25472:          */
25472:         gWatchdogThread = NULL;
25472:         PR_NotifyCondVar(gWatchdogWakeup);
25472:     }
25472:     PR_Unlock(gWatchdogLock);
25472:     if (thread)
25472:         PR_JoinThread(thread);
25472:     PR_DestroyCondVar(gSleepWakeup);
25472:     PR_DestroyCondVar(gWatchdogWakeup);
25472:     PR_DestroyLock(gWatchdogLock);
25472: }
25472: 
23726: static void
23726: WatchdogMain(void *arg)
23726: {
23726:     JSRuntime *rt = (JSRuntime *) arg;
23726: 
25472:     PR_Lock(gWatchdogLock);
23726:     while (gWatchdogThread) {
25472:         PRIntervalTime now = PR_IntervalNow();
25472:          if (gWatchdogHasTimeout && !IsBefore(now, gWatchdogTimeout)) {
25472:             /*
25472:              * The timeout has just expired. Trigger the operation callback
25472:              * outside the lock.
25472:              */
25472:             gWatchdogHasTimeout = false;
25472:             PR_Unlock(gWatchdogLock);
25472:             CancelExecution(rt);
25472:             PR_Lock(gWatchdogLock);
25472: 
25472:             /* Wake up any threads doing sleep. */
25472:             PR_NotifyAllCondVar(gSleepWakeup);
25472:         } else {
25472:             PRIntervalTime sleepDuration = gWatchdogHasTimeout
25472:                                            ? gWatchdogTimeout - now
25472:                                            : PR_INTERVAL_NO_TIMEOUT;
68941:             DebugOnly<PRStatus> status =
25472:                 PR_WaitCondVar(gWatchdogWakeup, sleepDuration);
23726:             JS_ASSERT(status == PR_SUCCESS);
23726:         }
25472:     }
25472:     PR_Unlock(gWatchdogLock);
25472: }
25472: 
25472: static bool
25472: ScheduleWatchdog(JSRuntime *rt, jsdouble t)
23726: {
25472:     if (t <= 0) {
25472:         PR_Lock(gWatchdogLock);
25472:         gWatchdogHasTimeout = false;
25472:         PR_Unlock(gWatchdogLock);
25472:         return true;
25472:     }
25472: 
25472:     PRIntervalTime interval = PRIntervalTime(ceil(t * PR_TicksPerSecond()));
25472:     PRIntervalTime timeout = PR_IntervalNow() + interval;
25472:     PR_Lock(gWatchdogLock);
25472:     if (!gWatchdogThread) {
25472:         JS_ASSERT(!gWatchdogHasTimeout);
23726:         gWatchdogThread = PR_CreateThread(PR_USER_THREAD,
23726:                                           WatchdogMain,
25087:                                           rt,
23726:                                           PR_PRIORITY_NORMAL,
23726:                                           PR_LOCAL_THREAD,
25472:                                           PR_JOINABLE_THREAD,
23726:                                           0);
23726:         if (!gWatchdogThread) {
25472:             PR_Unlock(gWatchdogLock);
25472:             return false;
25472:         }
25472:     } else if (!gWatchdogHasTimeout || IsBefore(timeout, gWatchdogTimeout)) {
25087:          PR_NotifyCondVar(gWatchdogWakeup);
25472:     }
25472:     gWatchdogHasTimeout = true;
25472:     gWatchdogTimeout = timeout;
25472:     PR_Unlock(gWatchdogLock);
25472:     return true;
25472: }
25472: 
25472: #else /* !JS_THREADSAFE */
25087: 
25087: #ifdef XP_WIN
25087: static HANDLE gTimerHandle = 0;
25087: 
25472: VOID CALLBACK
25472: TimerCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
25087: {
25479:     CancelExecution((JSRuntime *) lpParameter);
25472: }
25472: 
25472: #else
25472: 
25472: static void
25472: AlarmHandler(int sig)
25472: {
25472:     CancelExecution(gRuntime);
25472: }
25472: 
25087: #endif
25087: 
25472: static bool
25472: InitWatchdog(JSRuntime *rt)
25087: {
25472:     gRuntime = rt;
25472:     return true;
25472: }
25472: 
25472: static void
25472: KillWatchdog()
25472: {
25472:     ScheduleWatchdog(gRuntime, -1);
25472: }
25472: 
25472: static bool
25472: ScheduleWatchdog(JSRuntime *rt, jsdouble t)
25472: {
25087: #ifdef XP_WIN
25472:     if (gTimerHandle) {
25472:         DeleteTimerQueueTimer(NULL, gTimerHandle, NULL);
25472:         gTimerHandle = 0;
25472:     }
25472:     if (t > 0 &&
25472:         !CreateTimerQueueTimer(&gTimerHandle,
25087:                                NULL,
25087:                                (WAITORTIMERCALLBACK)TimerCallback,
25472:                                rt,
25472:                                DWORD(ceil(t * 1000.0)),
25472:                                0,
25472:                                WT_EXECUTEINTIMERTHREAD | WT_EXECUTEONLYONCE)) {
25472:         gTimerHandle = 0;
25472:         return false;
25472:     }
25087: #else
25472:     /* FIXME: use setitimer when available for sub-second resolution. */
25472:     if (t <= 0) {
25087:         alarm(0);
25087:         signal(SIGALRM, NULL);
25472:     } else {
25472:         signal(SIGALRM, AlarmHandler); /* set the Alarm signal capture */
25472:         alarm(ceil(t));
25472:     }
25087: #endif
25472:     return true;
25472: }
25472: 
25472: #endif /* !JS_THREADSAFE */
25472: 
25472: static void
25472: CancelExecution(JSRuntime *rt)
25472: {
25472:     gCanceled = true;
25472:     if (gExitCode == 0)
25472:         gExitCode = EXITCODE_TIMEOUT;
40801: #ifdef JS_THREADSAFE
55619:     if (gWorkerThreadPool)
55619:         js::workers::terminateAll(rt, gWorkerThreadPool);
40801: #endif
25472:     JS_TriggerAllOperationCallbacks(rt);
25472: 
25472:     static const char msg[] = "Script runs for too long, terminating.\n";
25472: #if defined(XP_UNIX) && !defined(JS_THREADSAFE)
25472:     /* It is not safe to call fputs from signals. */
40249:     /* Dummy assignment avoids GCC warning on "attribute warn_unused_result" */
40249:     ssize_t dummy = write(2, msg, sizeof(msg) - 1);
40249:     (void)dummy;
25472: #else
25472:     fputs(msg, stderr);
25472: #endif
25472: }
23457: 
23457: static JSBool
23457: SetTimeoutValue(JSContext *cx, jsdouble t)
23457: {
23457:     /* NB: The next condition also filter out NaNs. */
25472:     if (!(t <= MAX_TIMEOUT_INTERVAL)) {
23726:         JS_ReportError(cx, "Excessive timeout value");
23457:         return JS_FALSE;
23457:     }
25472:     gTimeoutInterval = t;
25472:     if (!ScheduleWatchdog(cx->runtime, t)) {
25472:         JS_ReportError(cx, "Failed to create the watchdog");
23726:         return JS_FALSE;
23726:     }
23457:     return JS_TRUE;
23457: }
23457: 
23457: static JSBool
23457: Timeout(JSContext *cx, uintN argc, jsval *vp)
23457: {
25087:     if (argc == 0)
25472:         return JS_NewNumberValue(cx, gTimeoutInterval, vp);
23457: 
23457:     if (argc > 1) {
23457:         JS_ReportError(cx, "Wrong number of arguments");
23457:         return JS_FALSE;
23457:     }
23457: 
23457:     jsdouble t;
23457:     if (!JS_ValueToNumber(cx, JS_ARGV(cx, vp)[0], &t))
23457:         return JS_FALSE;
23457: 
23457:     *vp = JSVAL_VOID;
23457:     return SetTimeoutValue(cx, t);
23457: }
23126: 
25087: static JSBool
25087: Elapsed(JSContext *cx, uintN argc, jsval *vp)
25087: {
25087:     if (argc == 0) {
25087:         double d = 0.0;
25087:         JSShellContextData *data = GetContextData(cx);
25087:         if (data)
25087:             d = js_IntervalNow() - data->startTime;
25087:         return JS_NewNumberValue(cx, d, vp);
25087:     }
25087:     JS_ReportError(cx, "Wrong number of arguments");
25087:     return JS_FALSE;
25087: }
25087: 
41968: static JSBool
41968: Parent(JSContext *cx, uintN argc, jsval *vp)
41968: {
41968:     if (argc != 1) {
41968:         JS_ReportError(cx, "Wrong number of arguments");
41968:         return JS_FALSE;
41968:     }
41968: 
41968:     jsval v = JS_ARGV(cx, vp)[0];
41968:     if (JSVAL_IS_PRIMITIVE(v)) {
41968:         JS_ReportError(cx, "Only objects have parents!");
41968:         return JS_FALSE;
41968:     }
41968: 
41973:     JSObject *parent = JS_GetParent(cx, JSVAL_TO_OBJECT(v));
41974:     *vp = OBJECT_TO_JSVAL(parent);
41973: 
41973:     /* Outerize if necessary.  Embrace the ugliness! */
42728:     if (parent) {
48622:         if (JSObjectOp op = parent->getClass()->ext.outerObject)
48622:             *vp = OBJECT_TO_JSVAL(op(cx, parent));
42728:     }
41973: 
41968:     return JS_TRUE;
41968: }
41968: 
24148: #ifdef XP_UNIX
24148: 
24148: #include <fcntl.h>
24148: #include <sys/stat.h>
24148: 
24148: /*
24148:  * Returns a JS_malloc'd string (that the caller needs to JS_free)
24148:  * containing the directory (non-leaf) part of |from| prepended to |leaf|.
24148:  * If |from| is empty or a leaf, MakeAbsolutePathname returns a copy of leaf.
24148:  * Returns NULL to indicate an error.
24148:  */
24148: static char *
24148: MakeAbsolutePathname(JSContext *cx, const char *from, const char *leaf)
24148: {
24148:     size_t dirlen;
24148:     char *dir;
24148:     const char *slash = NULL, *cp;
24148: 
24148:     cp = from;
24148:     while (*cp) {
24148:         if (*cp == '/') {
24148:             slash = cp;
24148:         }
24148: 
24148:         ++cp;
24148:     }
24148: 
24148:     if (!slash) {
24148:         /* We were given a leaf or |from| was empty. */
24148:         return JS_strdup(cx, leaf);
24148:     }
24148: 
24148:     /* Else, we were given a real pathname, return that + the leaf. */
24148:     dirlen = slash - from + 1;
24148:     dir = (char*) JS_malloc(cx, dirlen + strlen(leaf) + 1);
24148:     if (!dir)
24148:         return NULL;
24148: 
24148:     strncpy(dir, from, dirlen);
24148:     strcpy(dir + dirlen, leaf); /* Note: we can't use strcat here. */
24148: 
24148:     return dir;
24148: }
24148: 
24148: #endif // XP_UNIX
24148: 
24148: static JSBool
39934: Compile(JSContext *cx, uintN argc, jsval *vp)
39934: {
39934:     if (argc < 1) {
39934:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
39934:                              "compile", "0", "s");
39934:         return JS_FALSE;
39934:     }
39934:     jsval arg0 = JS_ARGV(cx, vp)[0];
39934:     if (!JSVAL_IS_STRING(arg0)) {
39934:         const char *typeName = JS_GetTypeName(cx, JS_TypeOfValue(cx, arg0));
39934:         JS_ReportError(cx, "expected string to compile, got %s", typeName);
39934:         return JS_FALSE;
39934:     }
39934: 
71368:     static JSClass dummy_class = {
71368:         "jdummy",
71368:         JSCLASS_GLOBAL_FLAGS,
71368:         JS_PropertyStub,  JS_PropertyStub,
71368:         JS_PropertyStub,  JS_StrictPropertyStub,
71368:         JS_EnumerateStub, JS_ResolveStub,
71368:         JS_ConvertStub,   NULL,
71368:         JSCLASS_NO_OPTIONAL_MEMBERS
71368:     };
71368: 
71368:     JSObject *fakeGlobal = JS_NewGlobalObject(cx, &dummy_class);
71368:     if (!fakeGlobal)
71368:         return JS_FALSE;
71368: 
39934:     JSString *scriptContents = JSVAL_TO_STRING(arg0);
71368: 
71368:     uintN oldopts = JS_GetOptions(cx);
71368:     JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
71368:     bool ok = JS_CompileUCScript(cx, fakeGlobal, JS_GetStringCharsZ(cx, scriptContents),
71368:                                  JS_GetStringLength(scriptContents), "<string>", 0);
71368:     JS_SetOptions(cx, oldopts);
39934: 
39934:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
71368:     return ok;
39934: }
39934: 
39934: static JSBool
41091: Parse(JSContext *cx, uintN argc, jsval *vp)
41091: {
41091:     if (argc < 1) {
41091:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
41091:                              "compile", "0", "s");
41091:         return JS_FALSE;
41091:     }
41091:     jsval arg0 = JS_ARGV(cx, vp)[0];
41091:     if (!JSVAL_IS_STRING(arg0)) {
41091:         const char *typeName = JS_GetTypeName(cx, JS_TypeOfValue(cx, arg0));
41091:         JS_ReportError(cx, "expected string to parse, got %s", typeName);
41091:         return JS_FALSE;
41091:     }
41091: 
41091:     JSString *scriptContents = JSVAL_TO_STRING(arg0);
41091:     js::Parser parser(cx);
41091:     parser.init(JS_GetStringCharsZ(cx, scriptContents), JS_GetStringLength(scriptContents),
61450:                 "<string>", 0, cx->findVersion());
41869:     if (!parser.parse(NULL))
41869:         return JS_FALSE;
41091:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
41091:     return JS_TRUE;
41091: }
41091: 
69649: struct FreeOnReturn {
69649:     JSContext *cx;
69649:     const char *ptr;
69649:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
69649: 
69649:     FreeOnReturn(JSContext *cx, const char *ptr JS_GUARD_OBJECT_NOTIFIER_PARAM)
69649:       : cx(cx), ptr(ptr) {
69649:         JS_GUARD_OBJECT_NOTIFIER_INIT;
69649:     }
69649: 
69649:     ~FreeOnReturn() {
69649:         JS_free(cx, (void*)ptr);
69649:     }
69649: };
69649: 
41091: static JSBool
53557: Snarf(JSContext *cx, uintN argc, jsval *vp)
24148: {
24148:     JSString *str;
24148:     const char *pathname;
24148: 
53557:     if (!argc)
53557:         return JS_FALSE;
53557: 
53557:     str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
24148:     if (!str)
24148:         return JS_FALSE;
57812:     JSAutoByteString filename(cx, str);
57812:     if (!filename)
57812:         return JS_FALSE;
24148: 
24148:     /* Get the currently executing script's name. */
69223:     JSStackFrame *fp = JS_GetScriptedCaller(cx, NULL);
69223:     JSScript *script = JS_GetFrameScript(cx, fp);
69223:     JS_ASSERT(fp && script->filename);
24148: #ifdef XP_UNIX
69223:     pathname = MakeAbsolutePathname(cx, script->filename, filename.ptr());
24148:     if (!pathname)
24148:         return JS_FALSE;
69649:     FreeOnReturn pnGuard(cx, pathname);
24148: #else
57812:     pathname = filename.ptr();
24148: #endif
24148: 
69649:     if (argc > 1) {
69649:         JSString *opt = JS_ValueToString(cx, JS_ARGV(cx, vp)[1]);
69649:         if (!opt)
24148:             return JS_FALSE;
69649:         JSBool match;
69649:         if (!JS_StringEqualsAscii(cx, opt, "binary", &match))
69649:             return JS_FALSE;
69649:         if (match) {
69649:             JSObject *obj;
69649:             if (!(obj = FileAsTypedArray(cx, pathname)))
69649:                 return JS_FALSE;
69649:             *vp = OBJECT_TO_JSVAL(obj);
69649:             return JS_TRUE;
69649:         }
69649:     }
69649: 
69649:     if (!(str = FileAsString(cx, pathname)))
69649:         return JS_FALSE;
53557:     *vp = STRING_TO_JSVAL(str);
24148:     return JS_TRUE;
24148: }
24148: 
42733: JSBool
42733: Wrap(JSContext *cx, uintN argc, jsval *vp)
42733: {
42733:     jsval v = argc > 0 ? JS_ARGV(cx, vp)[0] : JSVAL_VOID;
42733:     if (JSVAL_IS_PRIMITIVE(v)) {
42733:         JS_SET_RVAL(cx, vp, v);
42733:         return true;
42733:     }
42733: 
47498:     JSObject *obj = JSVAL_TO_OBJECT(v);
58346:     JSObject *wrapped = JSWrapper::New(cx, obj, obj->getProto(), obj->getGlobal(),
47498:                                        &JSWrapper::singleton);
42733:     if (!wrapped)
42733:         return false;
42733: 
42733:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(wrapped));
42733:     return true;
42733: }
42733: 
54863: JSBool
54863: Serialize(JSContext *cx, uintN argc, jsval *vp)
54863: {
54863:     jsval v = argc > 0 ? JS_ARGV(cx, vp)[0] : JSVAL_VOID;
54863:     uint64 *datap;
54863:     size_t nbytes;
60105:     if (!JS_WriteStructuredClone(cx, v, &datap, &nbytes, NULL, NULL))
54863:         return false;
54863: 
54863:     JSObject *arrayobj = js_CreateTypedArray(cx, TypedArray::TYPE_UINT8, nbytes);
54863:     if (!arrayobj) {
54863:         JS_free(cx, datap);
54863:         return false;
54863:     }
54863:     TypedArray *array = TypedArray::fromJSObject(arrayobj);
54863:     JS_ASSERT((uintptr_t(array->data) & 7) == 0);
54863:     memcpy(array->data, datap, nbytes);
54863:     JS_free(cx, datap);
54863:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(arrayobj));
54863:     return true;
54863: }
54863: 
54863: JSBool
54863: Deserialize(JSContext *cx, uintN argc, jsval *vp)
54863: {
54863:     jsval v = argc > 0 ? JS_ARGV(cx, vp)[0] : JSVAL_VOID;
54863:     JSObject *obj;
60538:     if (JSVAL_IS_PRIMITIVE(v) || !js_IsTypedArray((obj = JSVAL_TO_OBJECT(v)))) {
54863:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "deserialize");
54863:         return false;
54863:     }
54863:     TypedArray *array = TypedArray::fromJSObject(obj);
60538:     if ((array->byteLength & 7) != 0) {
60538:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "deserialize");
60538:         return false;
60538:     }
54863:     if ((uintptr_t(array->data) & 7) != 0) {
54863:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_BAD_ALIGNMENT);
54863:         return false;
54863:     }
54863: 
58294:     if (!JS_ReadStructuredClone(cx, (uint64 *) array->data, array->byteLength,
60105:                                 JS_STRUCTURED_CLONE_VERSION, &v, NULL, NULL)) {
54863:         return false;
58294:     }
54863:     JS_SET_RVAL(cx, vp, v);
54863:     return true;
54863: }
54863: 
59878: JSBool
69289: MJitCodeStats(JSContext *cx, uintN argc, jsval *vp)
60207: {
60794: #ifdef JS_METHODJIT
69289:     JSRuntime *rt = cx->runtime;
69289:     AutoLockGC lock(rt);
69289:     size_t n = 0;
69289:     for (JSCompartment **c = rt->compartments.begin(); c != rt->compartments.end(); ++c)
69289:         n += (*c)->getMjitCodeSize();
69289:     JS_SET_RVAL(cx, vp, INT_TO_JSVAL(n));
69289: #else
69289:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
69289: #endif
69289:     return true;
69289: }
69289: 
69289: JSBool
69289: MJitDataStats(JSContext *cx, uintN argc, jsval *vp)
69289: {
69289: #ifdef JS_METHODJIT
72779:     JSRuntime *rt = cx->runtime;
72779:     AutoLockGC lock(rt);
72779:     size_t n = 0;
72779:     for (JSCompartment **c = rt->compartments.begin(); c != rt->compartments.end(); ++c) {
72779:         for (JSScript *script = (JSScript *)(*c)->scripts.next;
72779:              &script->links != &(*c)->scripts;
72779:              script = (JSScript *)script->links.next)
72779:         {
72779:             n += script->jitDataSize(); 
72779:         }
72779:     }
72779:     JS_SET_RVAL(cx, vp, INT_TO_JSVAL(n));
60794: #else
60794:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
60794: #endif
60207:     return true;
60207: }
60207: 
60215: JSBool
60215: StringStats(JSContext *cx, uintN argc, jsval *vp)
60215: {
69722:     // XXX: should report something meaningful;  bug 625305 will probably fix
69722:     // this.
69722:     JS_SET_RVAL(cx, vp, INT_TO_JSVAL(0));
60215:     return true;
60215: }
60215: 
63096: enum CompartmentKind { SAME_COMPARTMENT, NEW_COMPARTMENT };
63096: 
63096: static JSObject *
63096: NewGlobalObject(JSContext *cx, CompartmentKind compartment);
63096: 
63096: JSBool
63096: NewGlobal(JSContext *cx, uintN argc, jsval *vp)
63096: {
63096:     if (argc != 1 || !JSVAL_IS_STRING(JS_ARGV(cx, vp)[0])) {
63096:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "newGlobal");
63096:         return false;
63096:     }
63096: 
63096:     JSString *str = JSVAL_TO_STRING(JS_ARGV(cx, vp)[0]);
63096: 
63096:     JSBool equalSame = JS_FALSE, equalNew = JS_FALSE;
63096:     if (!JS_StringEqualsAscii(cx, str, "same-compartment", &equalSame) ||
63096:         !JS_StringEqualsAscii(cx, str, "new-compartment", &equalNew)) {
63096:         return false;
63096:     }
63096: 
63096:     if (!equalSame && !equalNew) {
63096:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "newGlobal");
63096:         return false;
63096:     }
63096: 
63096:     JSObject *global = NewGlobalObject(cx, equalSame ? SAME_COMPARTMENT : NEW_COMPARTMENT);
63096:     if (!global)
63096:         return false;
63096: 
63096:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(global));
63096:     return true;
63096: }
63096: 
67934: static JSBool
67934: ParseLegacyJSON(JSContext *cx, uintN argc, jsval *vp)
67934: {
67934:     if (argc != 1 || !JSVAL_IS_STRING(JS_ARGV(cx, vp)[0])) {
67934:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "parseLegacyJSON");
67934:         return false;
67934:     }
67934: 
67934:     JSString *str = JSVAL_TO_STRING(JS_ARGV(cx, vp)[0]);
67934: 
67934:     size_t length;
67934:     const jschar *chars = JS_GetStringCharsAndLength(cx, str, &length);
67934:     if (!chars)
67934:         return false;
67934:     return js::ParseJSONWithReviver(cx, chars, length, js::NullValue(), js::Valueify(vp), LEGACY);
67934: }
67934: 
72074: static JSBool
72074: EnableStackWalkingAssertion(JSContext *cx, uintN argc, jsval *vp)
72074: {
72074:     if (argc == 0 || !JSVAL_IS_BOOLEAN(JS_ARGV(cx, vp)[0])) {
72074:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS,
72074:                              "enableStackWalkingAssertion");
72074:         return false;
72074:     }
72074: 
72074: #ifdef DEBUG
72074:     cx->stackIterAssertionEnabled = JSVAL_TO_BOOLEAN(JS_ARGV(cx, vp)[0]);
72074: #endif
72074: 
72074:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
72074:     return true;
72074: }
72074: 
73495: static JSBool
73495: GetMaxArgs(JSContext *cx, uintN arg, jsval *vp)
73495: {
73495:     JS_SET_RVAL(cx, vp, INT_TO_JSVAL(StackSpace::ARGS_LENGTH_MAX));
73495:     return JS_TRUE;
73495: }
73495: 
23126: static JSFunctionSpec shell_functions[] = {
53557:     JS_FN("version",        Version,        0,0),
53848:     JS_FN("revertVersion",  RevertVersion,  0,0),
53557:     JS_FN("options",        Options,        0,0),
53557:     JS_FN("load",           Load,           1,0),
61216:     JS_FN("evaluate",       Evaluate,       1,0),
62030:     JS_FN("run",            Run,            1,0),
23126:     JS_FN("readline",       ReadLine,       0,0),
27165:     JS_FN("print",          Print,          0,0),
48808:     JS_FN("putstr",         PutStr,         0,0),
50450:     JS_FN("dateNow",        Now,            0,0),
53557:     JS_FN("help",           Help,           0,0),
53557:     JS_FN("quit",           Quit,           0,0),
27165:     JS_FN("assertEq",       AssertEq,       2,0),
53120:     JS_FN("assertJit",      AssertJit,      0,0),
30450:     JS_FN("gc",             ::GC,           0,0),
23126:     JS_FN("gcparam",        GCParameter,    2,0),
23126:     JS_FN("countHeap",      CountHeap,      0,0),
54561:     JS_FN("makeFinalizeObserver", MakeFinalizeObserver, 0,0),
54561:     JS_FN("finalizeCount",  FinalizeCount, 0,0),
23126: #ifdef JS_GC_ZEAL
71353:     JS_FN("gczeal",         GCZeal,         2,0),
71353:     JS_FN("schedulegc",     ScheduleGC,     1,0),
23126: #endif
71354:     JS_FN("internalConst",  InternalConst,  1,0),
53557:     JS_FN("setDebug",       SetDebug,       1,0),
53557:     JS_FN("setDebuggerHandler", SetDebuggerHandler, 1,0),
53557:     JS_FN("setThrowHook",   SetThrowHook,   1,0),
53557:     JS_FN("trap",           Trap,           3,0),
53557:     JS_FN("untrap",         Untrap,         2,0),
53557:     JS_FN("line2pc",        LineToPC,       0,0),
53557:     JS_FN("pc2line",        PCToLine,       0,0),
53557:     JS_FN("stringsAreUTF8", StringsAreUTF8, 0,0),
53557:     JS_FN("testUTF8",       TestUTF8,       1,0),
53557:     JS_FN("throwError",     ThrowError,     0,0),
23126: #ifdef DEBUG
64374:     JS_FN("disassemble",    DisassembleToString, 1,0),
53557:     JS_FN("dis",            Disassemble,    1,0),
53557:     JS_FN("disfile",        DisassFile,     1,0),
53557:     JS_FN("dissrc",         DisassWithSrc,  1,0),
23126:     JS_FN("dumpHeap",       DumpHeap,       0,0),
53557:     JS_FN("dumpObject",     DumpObject,     1,0),
53557:     JS_FN("notes",          Notes,          1,0),
53557:     JS_FN("stats",          DumpStats,      1,0),
23126: #endif
71697:     JS_FN("dumpStack",      DumpStack,      1,0),
23126: #ifdef TEST_CVTARGS
53557:     JS_FN("cvtargs",        ConvertArgs,    0,0),
23126: #endif
23126:     JS_FN("build",          BuildDate,      0,0),
53557:     JS_FN("clear",          Clear,          0,0),
23126:     JS_FN("intern",         Intern,         1,0),
53557:     JS_FN("clone",          Clone,          1,0),
23126:     JS_FN("getpda",         GetPDA,         1,0),
23126:     JS_FN("getslx",         GetSLX,         1,0),
23126:     JS_FN("toint32",        ToInt32,        1,0),
53557:     JS_FN("evalcx",         EvalInContext,  1,0),
40276:     JS_FN("evalInFrame",    EvalInFrame,    2,0),
27165:     JS_FN("shapeOf",        ShapeOf,        1,0),
62970:     JS_FN("resolver",       Resolver,       1,0),
73747:     JS_FN("pauseProfilers", js_PauseProfilers, 0,0),
73747:     JS_FN("resumeProfilers", js_ResumeProfilers, 0,0),
23126: #ifdef MOZ_CALLGRIND
53557:     JS_FN("startCallgrind", js_StartCallgrind,  0,0),
53557:     JS_FN("stopCallgrind",  js_StopCallgrind,   0,0),
53557:     JS_FN("dumpCallgrind",  js_DumpCallgrind,   1,0),
23126: #endif
23126: #ifdef MOZ_VTUNE
53557:     JS_FN("startVtune",     js_StartVtune,    1,0),
53557:     JS_FN("stopVtune",      js_StopVtune,     0,0),
53557:     JS_FN("pauseVtune",     js_PauseVtune,    0,0),
53557:     JS_FN("resumeVtune",    js_ResumeVtune,   0,0),
23126: #endif
29368: #ifdef MOZ_TRACEVIS
53557:     JS_FN("startTraceVis",  StartTraceVisNative, 1,0),
53557:     JS_FN("stopTraceVis",   StopTraceVisNative,  0,0),
29368: #endif
59233: #ifdef DEBUG
53557:     JS_FN("arrayInfo",      js_ArrayInfo,   1,0),
23126: #endif
23126: #ifdef JS_THREADSAFE
23126:     JS_FN("sleep",          Sleep_fn,       1,0),
23126:     JS_FN("scatter",        Scatter,        1,0),
23126: #endif
53557:     JS_FN("snarf",          Snarf,          0,0),
53557:     JS_FN("read",           Snarf,          0,0),
39934:     JS_FN("compile",        Compile,        1,0),
41091:     JS_FN("parse",          Parse,          1,0),
23457:     JS_FN("timeout",        Timeout,        1,0),
25087:     JS_FN("elapsed",        Elapsed,        0,0),
41968:     JS_FN("parent",         Parent,         1,0),
42733:     JS_FN("wrap",           Wrap,           1,0),
54863:     JS_FN("serialize",      Serialize,      1,0),
54863:     JS_FN("deserialize",    Deserialize,    1,0),
60207: #ifdef JS_METHODJIT
69289:     JS_FN("mjitcodestats",  MJitCodeStats,  0,0),
69289:     JS_FN("mjitdatastats",  MJitDataStats,  0,0),
60207: #endif
60215:     JS_FN("stringstats",    StringStats,    0,0),
63096:     JS_FN("newGlobal",      NewGlobal,      1,0),
67934:     JS_FN("parseLegacyJSON",ParseLegacyJSON,1,0),
72074:     JS_FN("enableStackWalkingAssertion",EnableStackWalkingAssertion,1,0),
73495:     JS_FN("getMaxArgs",     GetMaxArgs,     0,0),
23126:     JS_FS_END
23126: };
23126: 
23126: static const char shell_help_header[] =
23126: "Command                  Description\n"
23126: "=======                  ===========\n";
23126: 
23126: static const char *const shell_help_messages[] = {
53848: "version([number])        Get or force a script compilation version number",
53848: "revertVersion()          Revert previously set version number",
23126: "options([option ...])    Get or toggle JavaScript options",
23126: "load(['foo.js' ...])     Load files named by string arguments",
61216: "evaluate(code)           Evaluate code as though it were the contents of a file",
62030: "run('foo.js')\n"
62030: "  Run the file named by the first argument, returning the number of\n"
62030: "  of milliseconds spent compiling and executing it",
23126: "readline()               Read a single line from stdin",
23126: "print([exp ...])         Evaluate and print expressions",
48808: "putstr([exp])            Evaluate and print expression without newline",
50450: "dateNow()                    Return the current time with sub-ms precision",
23126: "help([name ...])         Display usage and help messages",
23126: "quit()                   Quit the shell",
32760: "assertEq(actual, expected[, msg])\n"
32760: "  Throw if the first two arguments are not the same (both +0 or both -0,\n"
32760: "  both NaN, or non-zero and ===)",
63096: "assertJit()              Throw if the calling function failed to JIT",
71353: "gc([obj])                Run the garbage collector\n"
71353: "                         When obj is given, GC only the compartment it's in",
23126: "gcparam(name, value)\n"
23126: "  Wrapper for JS_SetGCParameter. The name must be either 'maxBytes' or\n"
23126: "  'maxMallocBytes' and the value must be convertable to a positive uint32",
23126: "countHeap([start[, kind]])\n"
23126: "  Count the number of live GC things in the heap or things reachable from\n"
23126: "  start when it is given and is not null. kind is either 'all' (default) to\n"
23126: "  count all things or one of 'object', 'double', 'string', 'function',\n"
23126: "  'qname', 'namespace', 'xml' to count only things of that kind",
54561: "makeFinalizeObserver()\n"
54561: "  get a special object whose finalization increases the counter returned\n"
54561: "  by the finalizeCount function",
54561: "finalizeCount()\n"
54561: "  return the current value of the finalization counter that is incremented\n"
54561: "  each time an object returned by the makeFinalizeObserver is finalized",
23126: #ifdef JS_GC_ZEAL
71353: "gczeal(level, [freq], [compartmentGC?])\n"
71353: "                         How zealous the garbage collector should be",
71353: "schedulegc(num, [compartmentGC?])\n"
71353: "                         Schedule a GC to happen after num allocations",
23126: #endif
71354: "internalConst(name)\n"
71354: "  Query an internal constant for the engine. See InternalConst source for the\n"
71354: "  list of constant names",
53391: "setDebug(debug)          Set debug mode",
53395: "setDebuggerHandler(f)    Set handler for debugger keyword to f",
53410: "setThrowHook(f)          Set throw hook to f",
23126: "trap([fun, [pc,]] exp)   Trap bytecode execution",
23126: "untrap(fun[, pc])        Remove a trap",
23126: "line2pc([fun,] line)     Map line number to PC",
23126: "pc2line(fun[, pc])       Map PC to line number",
23126: "stringsAreUTF8()         Check if strings are UTF-8 encoded",
23126: "testUTF8(mode)           Perform UTF-8 tests (modes are 1 to 4)",
23126: "throwError()             Throw an error from JS_ReportError",
23126: #ifdef DEBUG
64374: "disassemble([fun])       Return the disassembly for the given function",
58045: "dis([fun])               Disassemble functions into bytecodes",
58045: "disfile('foo.js')        Disassemble script file into bytecodes\n"
58045: "  dis and disfile take these options as preceeding string arguments\n"
58045: "    \"-r\" (disassemble recursively)\n"
58045: "    \"-l\" (show line numbers)",
23126: "dissrc([fun])            Disassemble functions with source lines",
23126: "dumpHeap([fileName[, start[, toFind[, maxDepth[, toIgnore]]]]])\n"
23126: "  Interface to JS_DumpHeap with output sent to file",
49117: "dumpObject()             Dump an internal representation of an object",
23126: "notes([fun])             Show source notes for functions",
23126: "stats([string ...])      Dump 'arena', 'atom', 'global' stats",
23126: #endif
71697: "dumpStack()              Dump the stack as an array of callees (youngest first)",
23126: #ifdef TEST_CVTARGS
23126: "cvtargs(arg1..., arg12)  Test argument formatter",
23126: #endif
23126: "build()                  Show build date and time",
23126: "clear([obj])             Clear properties of object",
23126: "intern(str)              Internalize str in the atom table",
23126: "clone(fun[, scope])      Clone function object",
23126: "getpda(obj)              Get the property descriptors for obj",
23126: "getslx(obj)              Get script line extent",
23126: "toint32(n)               Testing hook for JS_ValueToInt32",
23126: "evalcx(s[, o])\n"
23126: "  Evaluate s in optional sandbox object o\n"
23126: "  if (s == '' && !o) return new o with eager standard classes\n"
35108: "  if (s == 'lazy' && !o) return new o with lazy standard classes\n"
35108: "  if (s == 'split' && !o) return new split-object o with lazy standard classes",
40276: "evalInFrame(n,str,save)  Evaluate 'str' in the nth up frame.\n"
40276: "                         If 'save' (default false), save the frame chain",
23126: "shapeOf(obj)             Get the shape of obj (an implementation detail)",
62970: "resolver(src[, proto])   Create object with resolve hook that copies properties\n"
62970: "                         from src. If proto is omitted, use Object.prototype.",
73747: "pauseProfilers()         Pause all profilers that can be paused",
73747: "resumeProfilers()        Resume profilers if they are paused",
23126: #ifdef MOZ_CALLGRIND
23457: "startCallgrind()         Start callgrind instrumentation",
23457: "stopCallgrind()          Stop callgrind instrumentation",
23457: "dumpCallgrind([name])    Dump callgrind counters",
23126: #endif
23126: #ifdef MOZ_VTUNE
23457: "startVtune([filename])   Start vtune instrumentation",
23457: "stopVtune()              Stop vtune instrumentation",
23457: "pauseVtune()             Pause vtune collection",
23457: "resumeVtune()            Resume vtune collection",
23126: #endif
29368: #ifdef MOZ_TRACEVIS
29368: "startTraceVis(filename)  Start TraceVis recording (stops any current recording)",
29368: "stopTraceVis()           Stop TraceVis recording",
29368: #endif
59233: #ifdef DEBUG
23457: "arrayInfo(a1, a2, ...)   Report statistics about arrays",
23126: #endif
23126: #ifdef JS_THREADSAFE
23126: "sleep(dt)                Sleep for dt seconds",
23126: "scatter(fns)             Call functions concurrently (ignoring errors)",
23126: #endif
24148: "snarf(filename)          Read filename into returned string",
50450: "read(filename)           Synonym for snarf",
41091: "compile(code)            Compiles a string to bytecode, potentially throwing",
41091: "parse(code)              Parses a string, potentially throwing",
23457: "timeout([seconds])\n"
23457: "  Get/Set the limit in seconds for the execution time for the current context.\n"
23457: "  A negative value (default) means that the execution time is unlimited.",
41968: "elapsed()                Execution time elapsed for the current context.",
63096: "parent(obj)              Returns the parent of obj.",
63096: "wrap(obj)                Wrap an object into a noop wrapper.",
63096: "serialize(sd)            Serialize sd using JS_WriteStructuredClone. Returns a TypedArray.",
63096: "deserialize(a)           Deserialize data generated by serialize.",
60207: #ifdef JS_METHODJIT
69289: "mjitcodestats()          Return stats on mjit code memory usage.",
69289: "mjitdatastats()          Return stats on mjit data memory usage.",
60207: #endif
63096: "stringstats()            Return stats on string memory usage.",
63096: "newGlobal(kind)          Return a new global object, in the current\n"
63096: "                         compartment if kind === 'same-compartment' or in a\n"
63096: "                         new compartment if kind === 'new-compartment'",
67934: "parseLegacyJSON(str)     Parse str as legacy JSON, returning the result if the\n"
67934: "                         parse succeeded and throwing a SyntaxError if not.",
72074: "enableStackWalkingAssertion(enabled)\n"
72074: "  Enables or disables a particularly expensive assertion in stack-walking\n"
72074: "  code.  If your test isn't ridiculously thorough, such that performing this\n"
72074: "  assertion increases test duration by an order of magnitude, you shouldn't\n"
72074: "  use this.",
73508: "getMaxArgs()             Return the maximum number of supported args for a call.",
63096: 
63096: /* Keep these last: see the static assertion below. */
60787: #ifdef MOZ_PROFILING
60787: "startProfiling()         Start a profiling session.\n"
63096: "                         Profiler must be running with programatic sampling",
63096: "stopProfiling()          Stop a running profiling session\n"
60787: #endif
23126: };
23126: 
63096: #ifdef MOZ_PROFILING
63096: #define PROFILING_FUNCTION_COUNT 2
63096: #else
63096: #define PROFILING_FUNCTION_COUNT 0
63096: #endif
63096: 
23126: /* Help messages must match shell functions. */
63096: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(shell_help_messages) - PROFILING_FUNCTION_COUNT ==
63096:                  JS_ARRAY_LENGTH(shell_functions) - 1 /* JS_FS_END */);
63096: 
23126: #ifdef DEBUG
23126: static void
23126: CheckHelpMessages()
23126: {
23126:     const char *const *m;
23126:     const char *lp;
23126: 
63096:     /* Messages begin with "function_name(" prefix and don't end with \n. */
64263:     for (m = shell_help_messages; m != JS_ARRAY_END(shell_help_messages) - PROFILING_FUNCTION_COUNT; ++m) {
23126:         lp = strchr(*m, '(');
23126:         JS_ASSERT(lp);
23126:         JS_ASSERT(memcmp(shell_functions[m - shell_help_messages].name,
23126:                          *m, lp - *m) == 0);
63096:         JS_ASSERT((*m)[strlen(*m) - 1] != '\n');
23126:     }
23126: }
23126: #else
23126: # define CheckHelpMessages() ((void) 0)
23126: #endif
23126: 
64263: #undef PROFILING_FUNCTION_COUNT
64263: 
23126: static JSBool
53557: Help(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     uintN i, j;
23126:     int did_header, did_something;
23126:     JSType type;
23126:     JSFunction *fun;
23126:     JSString *str;
23126: 
23126:     fprintf(gOutFile, "%s\n", JS_GetImplementationVersion());
23126:     if (argc == 0) {
23126:         fputs(shell_help_header, gOutFile);
23126:         for (i = 0; shell_functions[i].name; i++)
23126:             fprintf(gOutFile, "%s\n", shell_help_messages[i]);
23126:     } else {
23126:         did_header = 0;
53557:         jsval *argv = JS_ARGV(cx, vp);
23126:         for (i = 0; i < argc; i++) {
23126:             did_something = 0;
23126:             type = JS_TypeOfValue(cx, argv[i]);
23126:             if (type == JSTYPE_FUNCTION) {
23126:                 fun = JS_ValueToFunction(cx, argv[i]);
64345:                 str = fun->atom;
23126:             } else if (type == JSTYPE_STRING) {
23126:                 str = JSVAL_TO_STRING(argv[i]);
23126:             } else {
23126:                 str = NULL;
23126:             }
23126:             if (str) {
59889:                 JSFlatString *flatStr = JS_FlattenString(cx, str);
59889:                 if (!flatStr)
59889:                     return JS_FALSE;
23126:                 for (j = 0; shell_functions[j].name; j++) {
59889:                     if (JS_FlatStringEqualsAscii(flatStr, shell_functions[j].name)) {
23126:                         if (!did_header) {
23126:                             did_header = 1;
23126:                             fputs(shell_help_header, gOutFile);
23126:                         }
23126:                         did_something = 1;
23126:                         fprintf(gOutFile, "%s\n", shell_help_messages[j]);
23126:                         break;
23126:                     }
23126:                 }
23126:             }
23126:             if (!did_something) {
23126:                 str = JS_ValueToString(cx, argv[i]);
23126:                 if (!str)
23126:                     return JS_FALSE;
57721:                 fputs("Sorry, no help for ", gErrFile);
57721:                 JS_FileEscapedString(gErrFile, str, 0);
57721:                 putc('\n', gErrFile);
23126:             }
23126:         }
23126:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSObject *
35108: split_setup(JSContext *cx, JSBool evalcx)
23126: {
23126:     JSObject *outer, *inner, *arguments;
23126: 
23126:     outer = split_create_outer(cx);
23126:     if (!outer)
23126:         return NULL;
47517:     AutoObjectRooter root(cx, outer);
47517:     if (!evalcx)
23126:         JS_SetGlobalObject(cx, outer);
23126: 
23126:     inner = split_create_inner(cx, outer);
23126:     if (!inner)
23126:         return NULL;
23126: 
35108:     if (!evalcx) {
60787:         if (!JS_DefineFunctions(cx, inner, shell_functions) ||
60787:             !JS_DefineProfilingFunctions(cx, inner)) {
23126:             return NULL;
60787:         }
23126: 
23126:         /* Create a dummy arguments object. */
23126:         arguments = JS_NewArrayObject(cx, 0, NULL);
23126:         if (!arguments ||
23126:             !JS_DefineProperty(cx, inner, "arguments", OBJECT_TO_JSVAL(arguments),
23126:                                NULL, NULL, 0)) {
23126:             return NULL;
23126:         }
35108:     }
35108: 
35108:     JS_ClearScope(cx, outer);
23126: 
23126: #ifndef LAZY_STANDARD_CLASSES
23126:     if (!JS_InitStandardClasses(cx, inner))
23126:         return NULL;
23126: #endif
23126: 
23126:     return inner;
23126: }
23126: 
23126: /*
23126:  * Define a JS object called "it".  Give it class operations that printf why
23126:  * they're being called for tutorial purposes.
23126:  */
23126: enum its_tinyid {
26666:     ITS_COLOR, ITS_HEIGHT, ITS_WIDTH, ITS_FUNNY, ITS_ARRAY, ITS_RDONLY,
26666:     ITS_CUSTOM, ITS_CUSTOMRDONLY
23126: };
23126: 
26666: static JSBool
48470: its_getter(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
26666: {
26666:   jsval *val = (jsval *) JS_GetPrivate(cx, obj);
26666:   *vp = val ? *val : JSVAL_VOID;
26666:   return JS_TRUE;
26666: }
26666: 
26666: static JSBool
62395: its_setter(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
26666: {
26666:   jsval *val = (jsval *) JS_GetPrivate(cx, obj);
26666:   if (val) {
26666:       *val = *vp;
26666:       return JS_TRUE;
26666:   }
26666: 
26666:   val = new jsval;
26666:   if (!val) {
26666:       JS_ReportOutOfMemory(cx);
26666:       return JS_FALSE;
26666:   }
26666: 
47403:   if (!JS_AddValueRoot(cx, val)) {
26666:       delete val;
26666:       return JS_FALSE;
26666:   }
26666: 
26666:   if (!JS_SetPrivate(cx, obj, (void*)val)) {
47403:       JS_RemoveValueRoot(cx, val);
26666:       delete val;
26666:       return JS_FALSE;
26666:   }
26666: 
26666:   *val = *vp;
26666:   return JS_TRUE;
26666: }
26666: 
23126: static JSPropertySpec its_props[] = {
23126:     {"color",           ITS_COLOR,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"height",          ITS_HEIGHT,     JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"width",           ITS_WIDTH,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"funny",           ITS_FUNNY,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"array",           ITS_ARRAY,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"rdonly",          ITS_RDONLY,     JSPROP_READONLY,        NULL, NULL},
26666:     {"custom",          ITS_CUSTOM,     JSPROP_ENUMERATE,
26666:                         its_getter,     its_setter},
26666:     {"customRdOnly",    ITS_CUSTOMRDONLY, JSPROP_ENUMERATE | JSPROP_READONLY,
26666:                         its_getter,     its_setter},
23126:     {NULL,0,0,NULL,NULL}
23126: };
23126: 
23126: static JSBool
53557: its_bindMethod(JSContext *cx, uintN argc, jsval *vp)
23126: {
57812:     JSString *name;
23126:     JSObject *method;
23126: 
53557:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
53557: 
57812:     if (!JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "So", &name, &method))
23126:         return JS_FALSE;
23126: 
53557:     *vp = OBJECT_TO_JSVAL(method);
53557: 
53557:     if (JS_TypeOfValue(cx, *vp) != JSTYPE_FUNCTION) {
57812:         JSAutoByteString nameBytes(cx, name);
57812:         if (!!nameBytes) {
53557:             JSString *valstr = JS_ValueToString(cx, *vp);
23126:             if (valstr) {
57812:                 JSAutoByteString valBytes(cx, valstr);
57812:                 if (!!valBytes) {
23126:                     JS_ReportError(cx, "can't bind method %s to non-callable object %s",
57812:                                    nameBytes.ptr(), valBytes.ptr());
57812:                 }
57812:             }
23126:         }
23126:         return JS_FALSE;
23126:     }
23126: 
57812:     jsid id;
57812:     if (!JS_ValueToId(cx, STRING_TO_JSVAL(name), &id))
57812:         return JS_FALSE;
57812: 
57812:     if (!JS_DefinePropertyById(cx, thisobj, id, *vp, NULL, NULL, JSPROP_ENUMERATE))
23126:         return JS_FALSE;
23126: 
53557:     return JS_SetParent(cx, method, thisobj);
23126: }
23126: 
23126: static JSFunctionSpec its_methods[] = {
53557:     {"bindMethod",      its_bindMethod, 2,0},
53557:     {NULL,NULL,0,0}
23126: };
23126: 
23126: #ifdef JSD_LOWLEVEL_SOURCE
23126: /*
23126:  * This facilitates sending source to JSD (the debugger system) in the shell
23126:  * where the source is loaded using the JSFILE hack in jsscan. The function
23126:  * below is used as a callback for the jsdbgapi JS_SetSourceHandler hook.
23126:  * A more normal embedding (e.g. mozilla) loads source itself and can send
23126:  * source directly to JSD without using this hook scheme.
23126:  */
23126: static void
23126: SendSourceToJSDebugger(const char *filename, uintN lineno,
23126:                        jschar *str, size_t length,
23126:                        void **listenerTSData, JSDContext* jsdc)
23126: {
23126:     JSDSourceText *jsdsrc = (JSDSourceText *) *listenerTSData;
23126: 
23126:     if (!jsdsrc) {
23126:         if (!filename)
23126:             filename = "typein";
23126:         if (1 == lineno) {
23126:             jsdsrc = JSD_NewSourceText(jsdc, filename);
23126:         } else {
23126:             jsdsrc = JSD_FindSourceForURL(jsdc, filename);
23126:             if (jsdsrc && JSD_SOURCE_PARTIAL !=
23126:                 JSD_GetSourceStatus(jsdc, jsdsrc)) {
23126:                 jsdsrc = NULL;
23126:             }
23126:         }
23126:     }
23126:     if (jsdsrc) {
23126:         jsdsrc = JSD_AppendUCSourceText(jsdc,jsdsrc, str, length,
23126:                                         JSD_SOURCE_PARTIAL);
23126:     }
23126:     *listenerTSData = jsdsrc;
23126: }
23126: #endif /* JSD_LOWLEVEL_SOURCE */
23126: 
23126: static JSBool its_noisy;    /* whether to be noisy when finalizing it */
23126: static JSBool its_enum_fail;/* whether to fail when enumerating it */
23126: 
23126: static JSBool
48470: its_addProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
31366:     if (!its_noisy)
31366:         return JS_TRUE;
31366: 
67930:     IdStringifier idString(cx, id);
31366:     fprintf(gOutFile, "adding its property %s,", idString.getBytes());
31366:     ToString valueString(cx, *vp);
31366:     fprintf(gOutFile, " initial value %s\n", valueString.getBytes());
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: its_delProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
31366:     if (!its_noisy)
31366:         return JS_TRUE;
31366: 
67930:     IdStringifier idString(cx, id);
31366:     fprintf(gOutFile, "deleting its property %s,", idString.getBytes());
31366:     ToString valueString(cx, *vp);
31366:     fprintf(gOutFile, " initial value %s\n", valueString.getBytes());
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: its_getProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
31366:     if (!its_noisy)
31366:         return JS_TRUE;
31366: 
67930:     IdStringifier idString(cx, id);
31366:     fprintf(gOutFile, "getting its property %s,", idString.getBytes());
31366:     ToString valueString(cx, *vp);
31366:     fprintf(gOutFile, " initial value %s\n", valueString.getBytes());
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
62395: its_setProperty(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
23126: {
67930:     IdStringifier idString(cx, id);
23126:     if (its_noisy) {
31366:         fprintf(gOutFile, "setting its property %s,", idString.getBytes());
31366:         ToString valueString(cx, *vp);
31366:         fprintf(gOutFile, " new value %s\n", valueString.getBytes());
23126:     }
23126: 
48470:     if (!JSID_IS_ATOM(id))
23126:         return JS_TRUE;
23126: 
31366:     if (!strcmp(idString.getBytes(), "noisy"))
30581:         JS_ValueToBoolean(cx, *vp, &its_noisy);
31366:     else if (!strcmp(idString.getBytes(), "enum_fail"))
30581:         JS_ValueToBoolean(cx, *vp, &its_enum_fail);
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: /*
23126:  * Its enumerator, implemented using the "new" enumerate API,
23126:  * see class flags.
23126:  */
23126: static JSBool
23126: its_enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
23126:               jsval *statep, jsid *idp)
23126: {
23126:     JSObject *iterator;
23126: 
23126:     switch (enum_op) {
23126:       case JSENUMERATE_INIT:
47569:       case JSENUMERATE_INIT_ALL:
23126:         if (its_noisy)
23126:             fprintf(gOutFile, "enumerate its properties\n");
23126: 
23126:         iterator = JS_NewPropertyIterator(cx, obj);
23126:         if (!iterator)
23126:             return JS_FALSE;
23126: 
23126:         *statep = OBJECT_TO_JSVAL(iterator);
23126:         if (idp)
48470:             *idp = INT_TO_JSID(0);
23126:         break;
23126: 
23126:       case JSENUMERATE_NEXT:
23126:         if (its_enum_fail) {
23126:             JS_ReportError(cx, "its enumeration failed");
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         iterator = (JSObject *) JSVAL_TO_OBJECT(*statep);
23126:         if (!JS_NextProperty(cx, iterator, idp))
23126:             return JS_FALSE;
23126: 
48470:         if (!JSID_IS_VOID(*idp))
23126:             break;
23126:         /* Fall through. */
23126: 
23126:       case JSENUMERATE_DESTROY:
23126:         /* Allow our iterator object to be GC'd. */
23126:         *statep = JSVAL_NULL;
23126:         break;
23126:     }
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: its_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
23126:             JSObject **objp)
23126: {
23126:     if (its_noisy) {
67930:         IdStringifier idString(cx, id);
23126:         fprintf(gOutFile, "resolving its property %s, flags {%s,%s,%s}\n",
31366:                idString.getBytes(),
23126:                (flags & JSRESOLVE_QUALIFIED) ? "qualified" : "",
23126:                (flags & JSRESOLVE_ASSIGNING) ? "assigning" : "",
23126:                (flags & JSRESOLVE_DETECTING) ? "detecting" : "");
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: its_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
23126: {
23126:     if (its_noisy)
23126:         fprintf(gOutFile, "converting it to %s type\n", JS_GetTypeName(cx, type));
23126:     return JS_TRUE;
23126: }
23126: 
23126: static void
23126: its_finalize(JSContext *cx, JSObject *obj)
23126: {
26666:     jsval *rootedVal;
23126:     if (its_noisy)
23126:         fprintf(gOutFile, "finalizing it\n");
26666:     rootedVal = (jsval *) JS_GetPrivate(cx, obj);
26666:     if (rootedVal) {
47403:       JS_RemoveValueRoot(cx, rootedVal);
26666:       JS_SetPrivate(cx, obj, NULL);
26666:       delete rootedVal;
26666:     }
23126: }
23126: 
23126: static JSClass its_class = {
26666:     "It", JSCLASS_NEW_RESOLVE | JSCLASS_NEW_ENUMERATE | JSCLASS_HAS_PRIVATE,
23126:     its_addProperty,  its_delProperty,  its_getProperty,  its_setProperty,
23126:     (JSEnumerateOp)its_enumerate, (JSResolveOp)its_resolve,
23126:     its_convert,      its_finalize,
23126:     JSCLASS_NO_OPTIONAL_MEMBERS
23126: };
23126: 
23126: JSErrorFormatString jsShell_ErrorFormatString[JSErr_Limit] = {
23126: #define MSG_DEF(name, number, count, exception, format) \
23126:     { format, count, JSEXN_ERR } ,
23126: #include "jsshell.msg"
23126: #undef MSG_DEF
23126: };
23126: 
23126: static const JSErrorFormatString *
23126: my_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber)
23126: {
23126:     if ((errorNumber > 0) && (errorNumber < JSShellErr_Limit))
23126:         return &jsShell_ErrorFormatString[errorNumber];
23126:     return NULL;
23126: }
23126: 
23126: static void
23126: my_ErrorReporter(JSContext *cx, const char *message, JSErrorReport *report)
23126: {
23126:     int i, j, k, n;
23126:     char *prefix, *tmp;
23126:     const char *ctmp;
23126: 
23126:     if (!report) {
23126:         fprintf(gErrFile, "%s\n", message);
23126:         return;
23126:     }
23126: 
23126:     /* Conditionally ignore reported warnings. */
23126:     if (JSREPORT_IS_WARNING(report->flags) && !reportWarnings)
23126:         return;
23126: 
23126:     prefix = NULL;
23126:     if (report->filename)
23126:         prefix = JS_smprintf("%s:", report->filename);
23126:     if (report->lineno) {
23126:         tmp = prefix;
23126:         prefix = JS_smprintf("%s%u: ", tmp ? tmp : "", report->lineno);
23126:         JS_free(cx, tmp);
23126:     }
23126:     if (JSREPORT_IS_WARNING(report->flags)) {
23126:         tmp = prefix;
23126:         prefix = JS_smprintf("%s%swarning: ",
23126:                              tmp ? tmp : "",
23126:                              JSREPORT_IS_STRICT(report->flags) ? "strict " : "");
23126:         JS_free(cx, tmp);
23126:     }
23126: 
23126:     /* embedded newlines -- argh! */
23126:     while ((ctmp = strchr(message, '\n')) != 0) {
23126:         ctmp++;
23126:         if (prefix)
23126:             fputs(prefix, gErrFile);
23126:         fwrite(message, 1, ctmp - message, gErrFile);
23126:         message = ctmp;
23126:     }
23126: 
23126:     /* If there were no filename or lineno, the prefix might be empty */
23126:     if (prefix)
23126:         fputs(prefix, gErrFile);
23126:     fputs(message, gErrFile);
23126: 
23126:     if (!report->linebuf) {
23126:         fputc('\n', gErrFile);
23126:         goto out;
23126:     }
23126: 
23126:     /* report->linebuf usually ends with a newline. */
23126:     n = strlen(report->linebuf);
23126:     fprintf(gErrFile, ":\n%s%s%s%s",
23126:             prefix,
23126:             report->linebuf,
23126:             (n > 0 && report->linebuf[n-1] == '\n') ? "" : "\n",
23126:             prefix);
25144:     n = report->tokenptr - report->linebuf;
23126:     for (i = j = 0; i < n; i++) {
23126:         if (report->linebuf[i] == '\t') {
23126:             for (k = (j + 8) & ~7; j < k; j++) {
23126:                 fputc('.', gErrFile);
23126:             }
23126:             continue;
23126:         }
23126:         fputc('.', gErrFile);
23126:         j++;
23126:     }
23126:     fputs("^\n", gErrFile);
23126:  out:
23126:     if (!JSREPORT_IS_WARNING(report->flags)) {
23126:         if (report->errorNumber == JSMSG_OUT_OF_MEMORY) {
23126:             gExitCode = EXITCODE_OUT_OF_MEMORY;
23126:         } else {
23126:             gExitCode = EXITCODE_RUNTIME_ERROR;
23126:         }
23126:     }
23126:     JS_free(cx, prefix);
23126: }
23126: 
23126: #if defined(SHELL_HACK) && defined(DEBUG) && defined(XP_UNIX)
23126: static JSBool
53557: Exec(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSFunction *fun;
23126:     const char *name, **nargv;
23126:     uintN i, nargc;
23126:     JSString *str;
57812:     bool ok;
23126:     pid_t pid;
23126:     int status;
23126: 
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53557: 
53557:     fun = JS_ValueToFunction(cx, vp[0]);
23126:     if (!fun)
23126:         return JS_FALSE;
23126:     if (!fun->atom)
23126:         return JS_TRUE;
57812: 
23126:     nargc = 1 + argc;
57812: 
57812:     /* nargc + 1 accounts for the terminating NULL. */
57812:     nargv = new (char *)[nargc + 1];
23126:     if (!nargv)
23126:         return JS_FALSE;
57812:     memset(nargv, 0, sizeof(nargv[0]) * (nargc + 1));
23126:     nargv[0] = name;
53557:     jsval *argv = JS_ARGV(cx, vp);
57812:     for (i = 0; i < nargc; i++) {
64345:         str = (i == 0) ? fun->atom : JS_ValueToString(cx, argv[i-1]);
23126:         if (!str) {
57812:             ok = false;
57812:             goto done;
57812:         }
57812:         nargv[i] = JS_EncodeString(cx, str);
57812:         if (!nargv[i]) {
57812:             ok = false;
57812:             goto done;
57812:         }
57812:     }
23126:     pid = fork();
23126:     switch (pid) {
23126:       case -1:
23126:         perror("js");
23126:         break;
23126:       case 0:
23126:         (void) execvp(name, (char **)nargv);
23126:         perror("js");
23126:         exit(127);
23126:       default:
23126:         while (waitpid(pid, &status, 0) < 0 && errno == EINTR)
23126:             continue;
23126:         break;
23126:     }
57812:     ok = true;
57812: 
57812:   done:
57812:     for (i = 0; i < nargc; i++)
57812:         JS_free(cx, nargv[i]);
57812:     delete[] nargv;
57812:     return ok;
23126: }
23126: #endif
23126: 
23126: static JSBool
23126: global_enumerate(JSContext *cx, JSObject *obj)
23126: {
23126: #ifdef LAZY_STANDARD_CLASSES
23126:     return JS_EnumerateStandardClasses(cx, obj);
23126: #else
23126:     return JS_TRUE;
23126: #endif
23126: }
23126: 
23126: static JSBool
48470: global_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
23126:                JSObject **objp)
23126: {
23126: #ifdef LAZY_STANDARD_CLASSES
23126:     JSBool resolved;
23126: 
73063:     if (!JS_ResolveStandardClass(cx, obj, id, &resolved))
23126:         return JS_FALSE;
23126:     if (resolved) {
23126:         *objp = obj;
23126:         return JS_TRUE;
23126:     }
23126: #endif
23126: 
23126: #if defined(SHELL_HACK) && defined(DEBUG) && defined(XP_UNIX)
43210:     if (!(flags & JSRESOLVE_QUALIFIED)) {
23126:         /*
23126:          * Do this expensive hack only for unoptimized Unix builds, which are
23126:          * not used for benchmarking.
23126:          */
23126:         char *path, *comp, *full;
23126:         const char *name;
23126:         JSBool ok, found;
23126:         JSFunction *fun;
23126: 
23126:         if (!JSVAL_IS_STRING(id))
23126:             return JS_TRUE;
23126:         path = getenv("PATH");
23126:         if (!path)
23126:             return JS_TRUE;
23126:         path = JS_strdup(cx, path);
23126:         if (!path)
23126:             return JS_FALSE;
57812:         JSAutoByteString name(cx, JSVAL_TO_STRING(id));
57812:         if (!name)
57812:             return JS_FALSE;
23126:         ok = JS_TRUE;
23126:         for (comp = strtok(path, ":"); comp; comp = strtok(NULL, ":")) {
23126:             if (*comp != '\0') {
57812:                 full = JS_smprintf("%s/%s", comp, name.ptr());
23126:                 if (!full) {
23126:                     JS_ReportOutOfMemory(cx);
23126:                     ok = JS_FALSE;
23126:                     break;
23126:                 }
23126:             } else {
23126:                 full = (char *)name;
23126:             }
23126:             found = (access(full, X_OK) == 0);
23126:             if (*comp != '\0')
23126:                 free(full);
23126:             if (found) {
23126:                 fun = JS_DefineFunction(cx, obj, name, Exec, 0,
23126:                                         JSPROP_ENUMERATE);
23126:                 ok = (fun != NULL);
23126:                 if (ok)
23126:                     *objp = obj;
23126:                 break;
23126:             }
23126:         }
23126:         JS_free(cx, path);
23126:         return ok;
23126:     }
23126: #else
23126:     return JS_TRUE;
23126: #endif
23126: }
23126: 
23126: JSClass global_class = {
26666:     "global", JSCLASS_NEW_RESOLVE | JSCLASS_GLOBAL_FLAGS | JSCLASS_HAS_PRIVATE,
23126:     JS_PropertyStub,  JS_PropertyStub,
62395:     JS_PropertyStub,  JS_StrictPropertyStub,
23126:     global_enumerate, (JSResolveOp) global_resolve,
26666:     JS_ConvertStub,   its_finalize,
23126:     JSCLASS_NO_OPTIONAL_MEMBERS
23126: };
23126: 
23126: static JSBool
62395: env_setProperty(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
23126: {
23126: /* XXX porting may be easy, but these don't seem to supply setenv by default */
63458: #if !defined XP_OS2 && !defined SOLARIS
23126:     int rv;
23126: 
67930:     IdStringifier idstr(cx, id, JS_TRUE);
31366:     if (idstr.threw())
23126:         return JS_FALSE;
31366:     ToString valstr(cx, *vp, JS_TRUE);
31366:     if (valstr.threw())
31366:         return JS_FALSE;
23126: #if defined XP_WIN || defined HPUX || defined OSF1 || defined IRIX
23126:     {
31366:         char *waste = JS_smprintf("%s=%s", idstr.getBytes(), valstr.getBytes());
23126:         if (!waste) {
23126:             JS_ReportOutOfMemory(cx);
23126:             return JS_FALSE;
23126:         }
23126:         rv = putenv(waste);
23126: #ifdef XP_WIN
23126:         /*
23126:          * HPUX9 at least still has the bad old non-copying putenv.
23126:          *
23126:          * Per mail from <s.shanmuganathan@digital.com>, OSF1 also has a putenv
23126:          * that will crash if you pass it an auto char array (so it must place
23126:          * its argument directly in the char *environ[] array).
23126:          */
31366:         JS_smprintf_free(waste);
23126: #endif
23126:     }
23126: #else
31366:     rv = setenv(idstr.getBytes(), valstr.getBytes(), 1);
23126: #endif
23126:     if (rv < 0) {
31366:         JS_ReportError(cx, "can't set env variable %s to %s", idstr.getBytes(), valstr.getBytes());
23126:         return JS_FALSE;
23126:     }
31366:     *vp = valstr.getJSVal();
63458: #endif /* !defined XP_OS2 && !defined SOLARIS */
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: env_enumerate(JSContext *cx, JSObject *obj)
23126: {
23126:     static JSBool reflected;
23126:     char **evp, *name, *value;
23126:     JSString *valstr;
23126:     JSBool ok;
23126: 
23126:     if (reflected)
23126:         return JS_TRUE;
23126: 
23126:     for (evp = (char **)JS_GetPrivate(cx, obj); (name = *evp) != NULL; evp++) {
23126:         value = strchr(name, '=');
23126:         if (!value)
23126:             continue;
23126:         *value++ = '\0';
23126:         valstr = JS_NewStringCopyZ(cx, value);
23126:         if (!valstr) {
23126:             ok = JS_FALSE;
23126:         } else {
23126:             ok = JS_DefineProperty(cx, obj, name, STRING_TO_JSVAL(valstr),
23126:                                    NULL, NULL, JSPROP_ENUMERATE);
23126:         }
23126:         value[-1] = '=';
23126:         if (!ok)
23126:             return JS_FALSE;
23126:     }
23126: 
23126:     reflected = JS_TRUE;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: env_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
23126:             JSObject **objp)
23126: {
31366:     JSString *valstr;
23126:     const char *name, *value;
23126: 
23126:     if (flags & JSRESOLVE_ASSIGNING)
23126:         return JS_TRUE;
23126: 
67930:     IdStringifier idstr(cx, id, JS_TRUE);
31366:     if (idstr.threw())
23126:         return JS_FALSE;
31366: 
31366:     name = idstr.getBytes();
23126:     value = getenv(name);
23126:     if (value) {
23126:         valstr = JS_NewStringCopyZ(cx, value);
23126:         if (!valstr)
23126:             return JS_FALSE;
23126:         if (!JS_DefineProperty(cx, obj, name, STRING_TO_JSVAL(valstr),
23126:                                NULL, NULL, JSPROP_ENUMERATE)) {
23126:             return JS_FALSE;
23126:         }
23126:         *objp = obj;
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSClass env_class = {
23126:     "environment", JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE,
23126:     JS_PropertyStub,  JS_PropertyStub,
23126:     JS_PropertyStub,  env_setProperty,
23126:     env_enumerate, (JSResolveOp) env_resolve,
30654:     JS_ConvertStub,   NULL,
23126:     JSCLASS_NO_OPTIONAL_MEMBERS
23126: };
23126: 
40801: /*
40801:  * Avoid a reentrancy hazard.
40801:  *
40801:  * The non-JS_THREADSAFE shell uses a signal handler to implement timeout().
40801:  * The JS engine is not really reentrant, but JS_TriggerAllOperationCallbacks
40801:  * is mostly safe--the only danger is that we might interrupt JS_NewContext or
40801:  * JS_DestroyContext while the context list is being modified. Therefore we
40801:  * disable the signal handler around calls to those functions.
40801:  */
40801: #ifdef JS_THREADSAFE
40801: # define WITH_SIGNALS_DISABLED(x)  x
40801: #else
40801: # define WITH_SIGNALS_DISABLED(x)                                               \
40801:     JS_BEGIN_MACRO                                                              \
40801:         ScheduleWatchdog(gRuntime, -1);                                         \
40801:         x;                                                                      \
40801:         ScheduleWatchdog(gRuntime, gTimeoutInterval);                           \
40801:     JS_END_MACRO
40801: #endif
40801: 
40801: static JSContext *
40801: NewContext(JSRuntime *rt)
23126: {
40801:     JSContext *cx;
40801:     WITH_SIGNALS_DISABLED(cx = JS_NewContext(rt, gStackChunkSize));
40801:     if (!cx)
40801:         return NULL;
40801: 
40801:     JSShellContextData *data = NewContextData();
40801:     if (!data) {
40801:         DestroyContext(cx, false);
40801:         return NULL;
40801:     }
40801: 
23457:     JS_SetContextPrivate(cx, data);
23126:     JS_SetErrorReporter(cx, my_ErrorReporter);
23126:     JS_SetVersion(cx, JSVERSION_LATEST);
23126:     SetContextOptions(cx);
52557:     if (enableTraceJit)
33747:         JS_ToggleOptions(cx, JSOPTION_JIT);
52557:     if (enableMethodJit)
52557:         JS_ToggleOptions(cx, JSOPTION_METHODJIT);
40801:     return cx;
40801: }
40801: 
40801: static void
40801: DestroyContext(JSContext *cx, bool withGC)
40801: {
40801:     JSShellContextData *data = GetContextData(cx);
23457:     JS_SetContextPrivate(cx, NULL);
23457:     free(data);
40801:     WITH_SIGNALS_DISABLED(withGC ? JS_DestroyContext(cx) : JS_DestroyContextNoGC(cx));
40801: }
40801: 
40801: static JSObject *
63096: NewGlobalObject(JSContext *cx, CompartmentKind compartment)
40801: {
63096:     JSObject *glob = (compartment == NEW_COMPARTMENT)
63096:                      ? JS_NewCompartmentAndGlobalObject(cx, &global_class, NULL)
63096:                      : JS_NewGlobalObject(cx, &global_class);
47498:     if (!glob)
47498:         return NULL;
54733: 
63096:     {
54733:         JSAutoEnterCompartment ac;
54733:         if (!ac.enter(cx, glob))
47498:             return NULL;
47498: 
63096: #ifndef LAZY_STANDARD_CLASSES
40801:         if (!JS_InitStandardClasses(cx, glob))
47517:             return NULL;
40801: #endif
63096: 
40801: #ifdef JS_HAS_CTYPES
40801:         if (!JS_InitCTypesClass(cx, glob))
47517:             return NULL;
40801: #endif
73063:         if (!JS_InitReflect(cx, glob))
73063:             return NULL;
48637:         if (!JS::RegisterPerfMeasurement(cx, glob))
48637:             return NULL;
60787:         if (!JS_DefineFunctions(cx, glob, shell_functions) ||
60787:             !JS_DefineProfilingFunctions(cx, glob)) {
47517:             return NULL;
60787:         }
47517: 
40801:         JSObject *it = JS_DefineObject(cx, glob, "it", &its_class, NULL, 0);
40801:         if (!it)
47517:             return NULL;
40801:         if (!JS_DefineProperties(cx, it, its_props))
47517:             return NULL;
40801:         if (!JS_DefineFunctions(cx, it, its_methods))
47517:             return NULL;
40801: 
40801:         if (!JS_DefineProperty(cx, glob, "custom", JSVAL_VOID, its_getter,
40801:                                its_setter, 0))
47517:             return NULL;
40801:         if (!JS_DefineProperty(cx, glob, "customRdOnly", JSVAL_VOID, its_getter,
40801:                                its_setter, JSPROP_READONLY))
47517:             return NULL;
63096:     }
63096: 
63096:     if (compartment == NEW_COMPARTMENT && !JS_WrapObject(cx, &glob))
63096:         return NULL;
40801: 
47498:     return glob;
40801: }
23126: 
74072: static bool
74072: BindScriptArgs(JSContext *cx, JSObject *obj, OptionParser *op)
74072: {
74072:     MultiStringRange msr = op->getMultiStringArg("scriptArgs");
74072:     JSObject *scriptArgs = JS_NewArrayObject(cx, 0, NULL);
74072:     if (!scriptArgs)
74072:         return false;
74072:     if (!JS_DefineProperty(cx, obj, "scriptArgs", OBJECT_TO_JSVAL(scriptArgs), NULL, NULL, 0))
74072:         return false;
74072: 
74072:     for (size_t i = 0; !msr.empty(); msr.popFront(), ++i) {
74072:         const char *scriptArg = msr.front();
74072:         JSString *str = JS_NewStringCopyZ(cx, scriptArg);
74072:         if (!str ||
74072:             !JS_DefineElement(cx, scriptArgs, i, STRING_TO_JSVAL(str), NULL, NULL,
74072:                               JSPROP_ENUMERATE)) {
74072:             return false;
74072:         }
74072:     }
74072: 
74072:     return true;
74072: }
74072: 
74072: static int
74072: ProcessArgs(JSContext *cx, JSObject *obj, OptionParser *op)
74072: {
74072:     if (op->getBoolOption('a'))
74072:         JS_ToggleOptions(cx, JSOPTION_METHODJIT_ALWAYS);
74072: 
74072:     if (op->getBoolOption('m')) {
74072:         enableMethodJit = true;
74072:         JS_ToggleOptions(cx, JSOPTION_METHODJIT);
74072:     }
74072: 
74072: #ifdef JS_GC_ZEAL
74072:     if (const char *zeal = op->getStringOption('Z'))
74072:         ParseZealArg(cx, zeal);
74072: #endif
74072: 
74072:     if (op->getBoolOption('j')) {
74072:         enableTraceJit = true;
74072:         JS_ToggleOptions(cx, JSOPTION_JIT);
74072: #if defined(JS_TRACER) && defined(DEBUG)
74072:         js::InitJITStatsClass(cx, JS_GetGlobalObject(cx));
74072:         JS_DefineObject(cx, JS_GetGlobalObject(cx), "tracemonkey",
74072:                         &js::jitstats_class, NULL, 0);
74072: #endif
74072:     }
74072:     
74072:     if (op->getBoolOption('p')) {
74072:         enableProfiling = true;
74072:         JS_ToggleOptions(cx, JSOPTION_PROFILING);
74072:     }
74072: 
74072:     if (op->getBoolOption('d')) {
74072:         JS_SetRuntimeDebugMode(JS_GetRuntime(cx), true);
74072:         JS_SetDebugMode(cx, true);
74072:     }
74072: 
74072:     if (op->getBoolOption('b'))
74072:         printTiming = true;
74072: 
74072:     if (op->getBoolOption('D')) {
74072:         enableDisassemblyDumps = true;
74072:         JS_ToggleOptions(cx, JSOPTION_PCCOUNT);
74072:     }
74072: 
74072:     /* |scriptArgs| gets bound on the global before any code is run. */
74072:     if (!BindScriptArgs(cx, obj, op))
74072:         return EXIT_FAILURE;
74072: 
74072:     MultiStringRange filePaths = op->getMultiStringOption('f');
74072:     MultiStringRange codeChunks = op->getMultiStringOption('e');
74072: 
74072:     if (filePaths.empty() && codeChunks.empty() && !op->getStringArg("script")) {
74072:         Process(cx, obj, NULL, true); /* Interactive. */
74072:         return gExitCode;
74072:     }
74072: 
74072:     while (!filePaths.empty() || !codeChunks.empty()) {
74072:         size_t fpArgno = filePaths.empty() ? -1 : filePaths.argno();
74072:         size_t ccArgno = codeChunks.empty() ? -1 : codeChunks.argno();
74072:         if (fpArgno < ccArgno) {
74072:             char *path = filePaths.front();
74072:             Process(cx, obj, path, false);
74072:             if (gExitCode)
74072:                 return gExitCode;
74072:             filePaths.popFront();
74072:         } else {
74072:             const char *code = codeChunks.front();
74072:             jsval rval;
74072:             if (!JS_EvaluateScript(cx, obj, code, strlen(code), "-e", 1, &rval))
74072:                 return EXIT_FAILURE;
74072:             codeChunks.popFront();
74072:         }
74072:     }
74072: 
74072:     /* The |script| argument is processed after all options. */
74072:     if (const char *path = op->getStringArg("script")) {
74072:         Process(cx, obj, path, false);
74072:         if (gExitCode)
74072:             return gExitCode;
74072:     }
74072: 
74072:     if (op->getBoolOption('i'))
74072:         Process(cx, obj, NULL, true);
74072: 
74072:     return gExitCode ? gExitCode : EXIT_SUCCESS;
74072: }
74072: 
23126: int
74072: Shell(JSContext *cx, OptionParser *op, char **envp)
23126: {
47504:     JSAutoRequest ar(cx);
54733: 
63096:     JSObject *glob = NewGlobalObject(cx, NEW_COMPARTMENT);
23126:     if (!glob)
23126:         return 1;
40801: 
54733:     JSAutoEnterCompartment ac;
54733:     if (!ac.enter(cx, glob))
54733:         return 1;
54733: 
63096:     JS_SetGlobalObject(cx, glob);
63096: 
40801:     JSObject *envobj = JS_DefineObject(cx, glob, "environment", &env_class, NULL, 0);
40801:     if (!envobj || !JS_SetPrivate(cx, envobj, envp))
47504:         return 1;
26666: 
23126: #ifdef JSDEBUGGER
23126:     /*
23126:     * XXX A command line option to enable debugging (or not) would be good
23126:     */
23126:     jsdc = JSD_DebuggerOnForUser(rt, NULL, NULL);
23126:     if (!jsdc)
47504:         return 1;
23126:     JSD_JSContextInUse(jsdc, cx);
23126: #ifdef JSD_LOWLEVEL_SOURCE
23126:     JS_SetSourceHandler(rt, SendSourceToJSDebugger, jsdc);
23126: #endif /* JSD_LOWLEVEL_SOURCE */
23126: #ifdef JSDEBUGGER_JAVA_UI
23126:     jsdjc = JSDJ_CreateContext();
23126:     if (! jsdjc)
47504:         return 1;
23126:     JSDJ_SetJSDContext(jsdjc, jsdc);
23126:     java_env = JSDJ_CreateJavaVMAndStartDebugger(jsdjc);
23126:     /*
23126:     * XXX This would be the place to wait for the debugger to start.
23126:     * Waiting would be nice in general, but especially when a js file
23126:     * is passed on the cmd line.
23126:     */
23126: #endif /* JSDEBUGGER_JAVA_UI */
23126: #ifdef JSDEBUGGER_C_UI
23126:     jsdbc = JSDB_InitDebugger(rt, jsdc, 0);
23126: #endif /* JSDEBUGGER_C_UI */
23126: #endif /* JSDEBUGGER */
23126: 
40801: #ifdef JS_THREADSAFE
40801:     class ShellWorkerHooks : public js::workers::WorkerHooks {
40801:     public:
47517:         JSObject *newGlobalObject(JSContext *cx) {
63096:             return NewGlobalObject(cx, NEW_COMPARTMENT);
47517:         }
40801:     };
40801:     ShellWorkerHooks hooks;
47403:     if (!JS_AddNamedObjectRoot(cx, &gWorkers, "Workers") ||
55619:         (gWorkerThreadPool = js::workers::init(cx, &hooks, glob, &gWorkers)) == NULL) {
47504:         return 1;
23126:     }
23126: #endif
23126: 
74072:     int result = ProcessArgs(cx, glob, op);
23126: 
40801: #ifdef JS_THREADSAFE
55619:     js::workers::finish(cx, gWorkerThreadPool);
47403:     JS_RemoveObjectRoot(cx, &gWorkers);
40801:     if (result == 0)
40801:         result = gExitCode;
40801: #endif
40801: 
23126: #ifdef JSDEBUGGER
23126:     if (jsdc) {
23126: #ifdef JSDEBUGGER_C_UI
23126:         if (jsdbc)
23126:             JSDB_TermDebugger(jsdc);
23126: #endif /* JSDEBUGGER_C_UI */
23126:         JSD_DebuggerOff(jsdc);
23126:     }
23126: #endif  /* JSDEBUGGER */
23126: 
71701:     if (enableDisassemblyDumps)
71701:         JS_DumpAllProfiles(cx);
71701:  
43286:     return result;
43286: }
43286: 
55469: static void
55469: MaybeOverrideOutFileFromEnv(const char* const envVar,
55469:                             FILE* defaultOut,
55469:                             FILE** outFile)
55469: {
55474:     const char* outPath = getenv(envVar);
55469:     if (!outPath || !*outPath || !(*outFile = fopen(outPath, "w"))) {
55469:         *outFile = defaultOut;
55469:     }
55469: }
55469: 
73495: JSBool
73495: ShellPrincipalsSubsume(JSPrincipals *, JSPrincipals *)
73495: {
73495:     return JS_TRUE;
73495: }
73495: 
73495: JSPrincipals shellTrustedPrincipals = {
73495:     (char *)"[shell trusted principals]",
73495:     NULL,
73495:     NULL,
73495:     1,
73495:     NULL, /* nobody should be destroying this */
73495:     ShellPrincipalsSubsume
73495: };
73495: 
74329: JSBool
74329: CheckObjectAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
74329:                   jsval *vp)
74329: {
74329:     LeaveTrace(cx);
74329:     return true;
74329: }
74329: 
74329: JSSecurityCallbacks securityCallbacks = {
74329:     CheckObjectAccess,
74329:     NULL,
74329:     NULL,
74329:     NULL
74329: };
74329: 
43286: int
43286: main(int argc, char **argv, char **envp)
43286: {
43286:     int stackDummy;
43286:     JSRuntime *rt;
43286:     JSContext *cx;
43286:     int result;
43286: #ifdef JSDEBUGGER
43286:     JSDContext *jsdc;
43286: #ifdef JSDEBUGGER_JAVA_UI
43286:     JNIEnv *java_env;
43286:     JSDJContext *jsdjc;
43286: #endif
43286: #ifdef JSDEBUGGER_C_UI
43286:     JSBool jsdbc;
43286: #endif /* JSDEBUGGER_C_UI */
43286: #endif /* JSDEBUGGER */
52897: #ifdef XP_WIN
53132:     {
53132:         const char *crash_option = getenv("XRE_NO_WINDOWS_CRASH_DIALOG");
53132:         if (crash_option && strncmp(crash_option, "1", 1)) {
52897:             DWORD oldmode = SetErrorMode(SEM_NOGPFAULTERRORBOX);
52897:             SetErrorMode(oldmode | SEM_NOGPFAULTERRORBOX);
53132:         }
53132:     }
52897: #endif
43286: 
43286:     CheckHelpMessages();
43286: #ifdef HAVE_SETLOCALE
43286:     setlocale(LC_ALL, "");
43286: #endif
43286: 
43286: #ifdef JS_THREADSAFE
43286:     if (PR_FAILURE == PR_NewThreadPrivateIndex(&gStackBaseThreadIndex, NULL) ||
43286:         PR_FAILURE == PR_SetThreadPrivate(gStackBaseThreadIndex, &stackDummy)) {
43286:         return 1;
43286:     }
43286: #else
43286:     gStackBase = (jsuword) &stackDummy;
43286: #endif
43286: 
43286: #ifdef XP_OS2
43286:    /* these streams are normally line buffered on OS/2 and need a \n, *
43286:     * so we need to unbuffer then to get a reasonable prompt          */
43286:     setbuf(stdout,0);
43286:     setbuf(stderr,0);
43286: #endif
43286: 
55469:     MaybeOverrideOutFileFromEnv("JS_STDERR", stderr, &gErrFile);
55469:     MaybeOverrideOutFileFromEnv("JS_STDOUT", stdout, &gOutFile);
43286: 
74072:     OptionParser op("Usage: {progname} [options] [[script] scriptArgs*]");
74072: 
74072:     op.setDescription("The SpiderMonkey shell provides a command line interface to the "
74072:         "JavaScript engine. Code and file options provided via the command line are "
74072:         "run left to right. If provided, the optional script argument is run after "
74072:         "all options have been processed. Just-In-Time compilation modes may be enabled via "
74072:         "command line options.");
74072:     op.setDescriptionWidth(72);
74072:     op.setHelpWidth(80);
74072:     op.setVersion(JS_GetImplementationVersion());
74072: 
74072:     if (!op.addMultiStringOption('f', "file", "PATH", "File path to run")
74072:         || !op.addMultiStringOption('e', "execute", "CODE", "Inline code to run")
74072:         || !op.addBoolOption('i', "shell", "Enter prompt after running code")
74072:         || !op.addBoolOption('m', "methodjit", "Enable the JaegerMonkey method JIT")
74072:         || !op.addBoolOption('j', "tracejit", "Enable the JaegerMonkey trace JIT")
74072:         || !op.addBoolOption('p', "profiling", "Enable runtime profiling select JIT mode")
74072:         || !op.addBoolOption('d', "debugjit", "Enable runtime debug mode for method JIT code")
74072:         || !op.addBoolOption('a', "always-mjit",
74072:                              "Do not try to run in the interpreter before "
74072:                              "method jitting. Note that this has no particular effect on the "
74072:                              "tracer; it still kicks in if enabled.")
74072:         || !op.addBoolOption('D', "dump-bytecode", "Dump bytecode with exec count for all scripts")
74072:         || !op.addBoolOption('b', "print-timing", "Print sub-ms runtime for each file that's run")
74072: #ifdef DEBUG
74072:         || !op.addIntOption('A', "oom-after", "COUNT", "Trigger OOM after COUNT allocations", -1)
74072:         || !op.addBoolOption('O', "print-alloc", "Print the number of allocations at exit")
74072: #endif
74072:         || !op.addBoolOption('U', "utf8", "C strings passed to the JSAPI are UTF-8 encoded")
74072: #ifdef JS_GC_ZEAL
74072:         || !op.addStringOption('Z', "gc-zeal", "N[,F[,C]]",
74072:                                "N indicates \"zealousness\":\n"
74072:                                "  0: no additional GCs\n"
74072:                                "  1: additional GCs at common danger points\n"
74072:                                "  2: GC every F allocations (default: 100)\n"
74072:                                "If C is 1, compartmental GCs are performed; otherwise, full")
74072: #endif
74072:         || !op.addOptionalStringArg("script", "A script to execute (after all options)")
74072:         || !op.addOptionalMultiStringArg("scriptArgs",
74072:                                          "String arguments to bind as |scriptArgs| in the "
74072:                                          "shell's global")) {
74072:         return EXIT_FAILURE;
74072:     }
74072: 
74072:     switch (op.parseArgs(argc, argv)) {
74072:       case OptionParser::ParseHelp:
74072:         return EXIT_SUCCESS;
74072:       case OptionParser::ParseError:
74072:         op.printHelp(argv[0]);
74072:         return EXIT_FAILURE;
74072:       case OptionParser::Fail:
74072:         return EXIT_FAILURE;
74072:       case OptionParser::Okay:
74072:         break;
74072:     }
74072: 
74072:     if (op.getHelpOption())
74072:         return EXIT_SUCCESS;
74072: 
74072: #ifdef DEBUG
74072:     /* 
74072:      * Process OOM options as early as possible so that we can observe as many
74072:      * allocations as possible.
74072:      */
74072:     if (op.getIntOption('A') >= 0)
74072:         OOM_maxAllocations = op.getIntOption('A');
74072:     if (op.getBoolOption('O'))
74072:         OOM_printAllocationCount = true;
74072: #endif
74072: 
74072:     /* Must be done before we create the JSRuntime. */
74072:     if (op.getBoolOption('U'))
68906:         JS_SetCStringsAreUTF8();
68906: 
43286: #ifdef XP_WIN
43286:     // Set the timer calibration delay count to 0 so we get high
43286:     // resolution right away, which we need for precise benchmarking.
43286:     extern int CALIBRATION_DELAY_COUNT;
43286:     CALIBRATION_DELAY_COUNT = 0;
43286: #endif
43286: 
55746:     rt = JS_NewRuntime(160L * 1024L * 1024L);
43286:     if (!rt)
43286:         return 1;
43286: 
73495:     JS_SetTrustedPrincipals(rt, &shellTrustedPrincipals);
74329:     JS_SetRuntimeSecurityCallbacks(rt, &securityCallbacks);
73495: 
43286:     if (!InitWatchdog(rt))
43286:         return 1;
43286: 
43286:     cx = NewContext(rt);
43286:     if (!cx)
43286:         return 1;
43286: 
71353:     JS_SetGCParameter(rt, JSGC_MODE, JSGC_MODE_COMPARTMENT);
43286:     JS_SetGCParameterForThread(cx, JSGC_MAX_CODE_CACHE_BYTES, 16 * 1024 * 1024);
43286: 
74072:     result = Shell(cx, &op, envp);
43286: 
64323: #ifdef DEBUG
64323:     if (OOM_printAllocationCount)
64323:         printf("OOM max count: %u\n", OOM_counter);
64323: #endif
64323: 
40801:     DestroyContext(cx, true);
25087: 
25472:     KillWatchdog();
23726: 
23126:     JS_DestroyRuntime(rt);
23126:     JS_ShutDown();
23126:     return result;
23126: }
