29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   IBM Corp.
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS number type and wrapper class.
    1:  */
26750: #ifdef XP_OS2
26750: #define _PC_53  PC_53
26750: #define _MCW_EM MCW_EM
26750: #define _MCW_PC MCW_PC
26750: #endif
    1: #include <locale.h>
    1: #include <limits.h>
    1: #include <math.h>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsatom.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdtoa.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsprf.h"
12581: #include "jsscope.h"
    1: #include "jsstr.h"
32686: #include "jsstrinlines.h"
30023: #include "jsvector.h"
    1: 
    1: static JSBool
 4127: num_isNaN(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsdouble x;
    1: 
16519:     if (argc == 0) {
16519:         *vp = JSVAL_TRUE;
16519:         return JS_TRUE;
16519:     }
12694:     x = js_ValueToNumber(cx, &vp[2]);
12694:     if (JSVAL_IS_NULL(vp[2]))
    1:         return JS_FALSE;
 4127:     *vp = BOOLEAN_TO_JSVAL(JSDOUBLE_IS_NaN(x));
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: num_isFinite(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsdouble x;
    1: 
16519:     if (argc == 0) {
16519:         *vp = JSVAL_FALSE;
16519:         return JS_TRUE;
16519:     }
12694:     x = js_ValueToNumber(cx, &vp[2]);
12694:     if (JSVAL_IS_NULL(vp[2]))
    1:         return JS_FALSE;
 4127:     *vp = BOOLEAN_TO_JSVAL(JSDOUBLE_IS_FINITE(x));
    1:     return JS_TRUE;
    1: }
    1: 
20408: static JSBool
20408: num_parseFloat(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSString *str;
    1:     jsdouble d;
 4718:     const jschar *bp, *end, *ep;
    1: 
16519:     if (argc == 0) {
16519:         *vp = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
16519:         return JS_TRUE;
16519:     }
 4127:     str = js_ValueToString(cx, vp[2]);
    1:     if (!str)
    1:         return JS_FALSE;
29366:     str->getCharsAndEnd(bp, end);
 4718:     if (!js_strtod(cx, bp, end, &ep, &d))
    1:         return JS_FALSE;
    1:     if (ep == bp) {
 4127:         *vp = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
    1:         return JS_TRUE;
    1:     }
12850:     return js_NewNumberInRootedValue(cx, d, vp);
    1: }
    1: 
20408: #ifdef JS_TRACER
20915: static jsdouble FASTCALL
20915: ParseFloat(JSContext* cx, JSString* str)
20408: {
20408:     const jschar* bp;
20408:     const jschar* end;
20408:     const jschar* ep;
20408:     jsdouble d;
20408: 
29366:     str->getCharsAndEnd(bp, end);
20408:     if (!js_strtod(cx, bp, end, &ep, &d) || ep == bp)
20408:         return js_NaN;
20408:     return d;
20408: }
20408: #endif
20408: 
    1: /* See ECMA 15.1.2.2. */
20408: static JSBool
20408: num_parseInt(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsint radix;
    1:     JSString *str;
    1:     jsdouble d;
 4718:     const jschar *bp, *end, *ep;
    1: 
16519:     if (argc == 0) {
16519:         *vp = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
16519:         return JS_TRUE;
16519:     }
    1:     if (argc > 1) {
12681:         radix = js_ValueToECMAInt32(cx, &vp[3]);
12694:         if (JSVAL_IS_NULL(vp[3]))
    1:             return JS_FALSE;
    1:     } else {
    1:         radix = 0;
    1:     }
    1:     if (radix != 0 && (radix < 2 || radix > 36)) {
 4127:         *vp = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
    1:         return JS_TRUE;
    1:     }
    1: 
12605:     if (JSVAL_IS_INT(vp[2]) && (radix == 0 || radix == 10)) {
12605:         *vp = vp[2];
12605:         return JS_TRUE;
12605:     }
12605: 
 4127:     str = js_ValueToString(cx, vp[2]);
    1:     if (!str)
    1:         return JS_FALSE;
29366:     str->getCharsAndEnd(bp, end);
 4718:     if (!js_strtointeger(cx, bp, end, &ep, radix, &d))
    1:         return JS_FALSE;
    1:     if (ep == bp) {
 4127:         *vp = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
    1:         return JS_TRUE;
    1:     }
12850:     return js_NewNumberInRootedValue(cx, d, vp);
    1: }
    1: 
20408: #ifdef JS_TRACER
20915: static jsdouble FASTCALL
20915: ParseInt(JSContext* cx, JSString* str)
20408: {
20408:     const jschar* bp;
20408:     const jschar* end;
20408:     const jschar* ep;
20408:     jsdouble d;
20408: 
29366:     str->getCharsAndEnd(bp, end);
20408:     if (!js_strtointeger(cx, bp, end, &ep, 0, &d) || ep == bp)
20408:         return js_NaN;
20408:     return d;
20408: }
20408: 
20915: static jsdouble FASTCALL
20915: ParseIntDouble(jsdouble d)
20408: {
20408:     if (!JSDOUBLE_IS_FINITE(d))
20408:         return js_NaN;
31493:     if (d > 0)
20408:         return floor(d);
31500:     if (d < 0)
31500:     	return -floor(-d);
31500:     return 0;
20408: }
20408: #endif
20408: 
    1: const char js_Infinity_str[]   = "Infinity";
    1: const char js_NaN_str[]        = "NaN";
    1: const char js_isNaN_str[]      = "isNaN";
    1: const char js_isFinite_str[]   = "isFinite";
    1: const char js_parseFloat_str[] = "parseFloat";
    1: const char js_parseInt_str[]   = "parseInt";
    1: 
20408: #ifdef JS_TRACER
20408: 
20930: JS_DEFINE_TRCINFO_2(num_parseInt,
20930:     (2, (static, DOUBLE, ParseInt, CONTEXT, STRING,     1, 1)),
20930:     (1, (static, DOUBLE, ParseIntDouble, DOUBLE,        1, 1)))
20408: 
20930: JS_DEFINE_TRCINFO_1(num_parseFloat,
20930:     (2, (static, DOUBLE, ParseFloat, CONTEXT, STRING,   1, 1)))
20408: 
20408: #endif /* JS_TRACER */
20408: 
    1: static JSFunctionSpec number_functions[] = {
16519:     JS_FN(js_isNaN_str,         num_isNaN,           1,0),
16519:     JS_FN(js_isFinite_str,      num_isFinite,        1,0),
32669:     JS_TN(js_parseFloat_str,    num_parseFloat,      1,0, &num_parseFloat_trcinfo),
32669:     JS_TN(js_parseInt_str,      num_parseInt,        2,0, &num_parseInt_trcinfo),
 4127:     JS_FS_END
    1: };
    1: 
    1: JSClass js_NumberClass = {
    1:     js_Number_str,
31452:     JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_HAS_CACHED_PROTO(JSProto_Number),
    1:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
30654:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   NULL,
    1:     JSCLASS_NO_OPTIONAL_MEMBERS
    1: };
    1: 
    1: static JSBool
    1: Number(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
12850:     jsval v;
    1:     jsdouble d;
    1: 
    1:     if (argc != 0) {
12694:         d = js_ValueToNumber(cx, &argv[0]);
12850:         v = argv[0];
12850:         if (JSVAL_IS_NULL(v))
    1:             return JS_FALSE;
12850:         if (v != JSVAL_TRUE) {
12850:             JS_ASSERT(JSVAL_IS_INT(v) || JSVAL_IS_DOUBLE(v));
    1:         } else {
12850:             if (!js_NewNumberInRootedValue(cx, d, &argv[0]))
12850:                 return JS_FALSE;
12850:             v = argv[0];
    1:         }
12850:     } else {
12850:         v = JSVAL_ZERO;
12850:     }
31452:     if (!JS_IsConstructing(cx))
    1:         *rval = v;
31452:     else
32684:         obj->fslots[JSSLOT_PRIMITIVE_THIS] = v;
31452:     return true;
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
    1: static JSBool
 4127: num_toSource(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsval v;
    1:     jsdouble d;
    1:     char numBuf[DTOSTR_STANDARD_BUFFER_SIZE], *numStr;
    1:     char buf[64];
    1:     JSString *str;
    1: 
 4127:     if (!js_GetPrimitiveThis(cx, vp, &js_NumberClass, &v))
    1:         return JS_FALSE;
    1:     JS_ASSERT(JSVAL_IS_NUMBER(v));
    1:     d = JSVAL_IS_INT(v) ? (jsdouble)JSVAL_TO_INT(v) : *JSVAL_TO_DOUBLE(v);
    1:     numStr = JS_dtostr(numBuf, sizeof numBuf, DTOSTR_STANDARD, 0, d);
    1:     if (!numStr) {
    1:         JS_ReportOutOfMemory(cx);
    1:         return JS_FALSE;
    1:     }
    1:     JS_snprintf(buf, sizeof buf, "(new %s(%s))", js_NumberClass.name, numStr);
    1:     str = JS_NewStringCopyZ(cx, buf);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: #endif
    1: 
    1: /* The buf must be big enough for MIN_INT to fit including '-' and '\0'. */
23700: static char *
23700: IntToCString(jsint i, jsint base, char *buf, size_t bufSize)
    1: {
    1:     char *cp;
    1:     jsuint u;
    1: 
    1:     u = (i < 0) ? -i : i;
    1: 
    1:     cp = buf + bufSize; /* one past last buffer cell */
    1:     *--cp = '\0';       /* null terminate the string to be */
    1: 
    1:     /*
    1:      * Build the string from behind. We use multiply and subtraction
    1:      * instead of modulus because that's much faster.
    1:      */
20898:     switch (base) {
20898:     case 10:
    1:       do {
    1:           jsuint newu = u / 10;
    1:           *--cp = (char)(u - newu * 10) + '0';
    1:           u = newu;
    1:       } while (u != 0);
20898:       break;
20898:     case 16:
20898:       do {
20898:           jsuint newu = u / 16;
20898:           *--cp = "0123456789abcdef"[u - newu * 16];
20898:           u = newu;
20898:       } while (u != 0);
20898:       break;
20898:     default:
20898:       JS_ASSERT(base >= 2 && base <= 36);
20898:       do {
20898:           jsuint newu = u / base;
20898:           *--cp = "0123456789abcdefghijklmnopqrstuvwxyz"[u - newu * base];
20898:           u = newu;
20898:       } while (u != 0);
20898:       break;
20898:     }
    1:     if (i < 0)
    1:         *--cp = '-';
    1: 
 8439:     JS_ASSERT(cp >= buf);
    1:     return cp;
    1: }
    1: 
20408: static JSBool
20408: num_toString(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsval v;
    1:     jsdouble d;
    1:     jsint base;
    1:     JSString *str;
    1: 
 4127:     if (!js_GetPrimitiveThis(cx, vp, &js_NumberClass, &v))
    1:         return JS_FALSE;
    1:     JS_ASSERT(JSVAL_IS_NUMBER(v));
    1:     d = JSVAL_IS_INT(v) ? (jsdouble)JSVAL_TO_INT(v) : *JSVAL_TO_DOUBLE(v);
    1:     base = 10;
10275:     if (argc != 0 && !JSVAL_IS_VOID(vp[2])) {
12681:         base = js_ValueToECMAInt32(cx, &vp[2]);
12694:         if (JSVAL_IS_NULL(vp[2]))
    1:             return JS_FALSE;
    1:         if (base < 2 || base > 36) {
    1:             char numBuf[12];
23700:             char *numStr = IntToCString(base, 10, numBuf, sizeof numBuf);
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_RADIX,
    1:                                  numStr);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     if (base == 10) {
    1:         str = js_NumberToString(cx, d);
    1:     } else {
    1:         char *dStr = JS_dtobasestr(base, d);
    1:         if (!dStr) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return JS_FALSE;
    1:         }
    1:         str = JS_NewStringCopyZ(cx, dStr);
30851:         js_free(dStr);
    1:     }
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: num_toLocaleString(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     char thousandsLength, decimalLength;
    1:     const char *numGrouping, *tmpGroup;
    1:     JSRuntime *rt;
    1:     JSString *numStr, *str;
    1:     const char *num, *end, *tmpSrc;
 6152:     char *buf, *tmpDest;
16181:     const char *nint;
    1:     int digits, size, remainder, nrepeat;
    1: 
    1:     /*
    1:      * Create the string, move back to bytes to make string twiddling
    1:      * a bit easier and so we can insert platform charset seperators.
    1:      */
20408:     if (!num_toString(cx, 0, vp))
    1:         return JS_FALSE;
 4127:     JS_ASSERT(JSVAL_IS_STRING(*vp));
 4127:     numStr = JSVAL_TO_STRING(*vp);
    1:     num = js_GetStringBytes(cx, numStr);
    1:     if (!num)
    1:         return JS_FALSE;
    1: 
16181:     /*
16181:      * Find the first non-integer value, whether it be a letter as in
16183:      * 'Infinity', a decimal point, or an 'e' from exponential notation.
16181:      */
16181:     nint = num;
16181:     if (*nint == '-')
16181:         nint++;
16181:     while (*nint >= '0' && *nint <= '9')
16181:         nint++;
16181:     digits = nint - num;
    1:     end = num + digits;
16181:     if (!digits)
16181:         return JS_TRUE;
    1: 
    1:     rt = cx->runtime;
    1:     thousandsLength = strlen(rt->thousandsSeparator);
    1:     decimalLength = strlen(rt->decimalSeparator);
    1: 
    1:     /* Figure out how long resulting string will be. */
16181:     size = digits + (*nint ? strlen(nint + 1) + 1 : 0);
16181:     if (*nint == '.')
16181:         size += decimalLength;
    1: 
    1:     numGrouping = tmpGroup = rt->numGrouping;
    1:     remainder = digits;
    1:     if (*num == '-')
    1:         remainder--;
    1: 
    1:     while (*tmpGroup != CHAR_MAX && *tmpGroup != '\0') {
    1:         if (*tmpGroup >= remainder)
    1:             break;
    1:         size += thousandsLength;
    1:         remainder -= *tmpGroup;
    1:         tmpGroup++;
    1:     }
    1:     if (*tmpGroup == '\0' && *numGrouping != '\0') {
    1:         nrepeat = (remainder - 1) / tmpGroup[-1];
    1:         size += thousandsLength * nrepeat;
    1:         remainder -= nrepeat * tmpGroup[-1];
    1:     } else {
    1:         nrepeat = 0;
    1:     }
    1:     tmpGroup--;
    1: 
30851:     buf = (char *)cx->malloc(size + 1);
    1:     if (!buf)
    1:         return JS_FALSE;
    1: 
    1:     tmpDest = buf;
    1:     tmpSrc = num;
    1: 
    1:     while (*tmpSrc == '-' || remainder--)
    1:         *tmpDest++ = *tmpSrc++;
    1:     while (tmpSrc < end) {
    1:         strcpy(tmpDest, rt->thousandsSeparator);
    1:         tmpDest += thousandsLength;
    1:         memcpy(tmpDest, tmpSrc, *tmpGroup);
    1:         tmpDest += *tmpGroup;
    1:         tmpSrc += *tmpGroup;
    1:         if (--nrepeat < 0)
    1:             tmpGroup--;
    1:     }
    1: 
16181:     if (*nint == '.') {
    1:         strcpy(tmpDest, rt->decimalSeparator);
    1:         tmpDest += decimalLength;
16181:         strcpy(tmpDest, nint + 1);
    1:     } else {
16181:         strcpy(tmpDest, nint);
    1:     }
    1: 
    1:     if (cx->localeCallbacks && cx->localeCallbacks->localeToUnicode)
 4127:         return cx->localeCallbacks->localeToUnicode(cx, buf, vp);
    1: 
    1:     str = JS_NewString(cx, buf, size);
    1:     if (!str) {
30851:         cx->free(buf);
    1:         return JS_FALSE;
    1:     }
    1: 
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: num_valueOf(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     jsval v;
 4127:     JSObject *obj;
 4127: 
 4127:     v = vp[1];
 4127:     if (JSVAL_IS_NUMBER(v)) {
 4127:         *vp = v;
    1:         return JS_TRUE;
    1:     }
12470:     obj = JS_THIS_OBJECT(cx, vp);
 4127:     if (!JS_InstanceOf(cx, obj, &js_NumberClass, vp + 2))
    1:         return JS_FALSE;
32684:     *vp = obj->fslots[JSSLOT_PRIMITIVE_THIS];
    1:     return JS_TRUE;
    1: }
    1: 
    1: 
    1: #define MAX_PRECISION 100
    1: 
    1: static JSBool
 4127: num_to(JSContext *cx, JSDToStrMode zeroArgMode, JSDToStrMode oneArgMode,
 4127:        jsint precisionMin, jsint precisionMax, jsint precisionOffset,
 4127:        uintN argc, jsval *vp)
    1: {
    1:     jsval v;
    1:     jsdouble d, precision;
    1:     JSString *str;
    1: 
 4127:     /* Use MAX_PRECISION+1 because precisionOffset can be 1. */
 4127:     char buf[DTOSTR_VARIABLE_BUFFER_SIZE(MAX_PRECISION+1)];
 4127:     char *numStr;
 4127: 
 4127:     if (!js_GetPrimitiveThis(cx, vp, &js_NumberClass, &v))
    1:         return JS_FALSE;
    1:     JS_ASSERT(JSVAL_IS_NUMBER(v));
    1:     d = JSVAL_IS_INT(v) ? (jsdouble)JSVAL_TO_INT(v) : *JSVAL_TO_DOUBLE(v);
    1: 
 4127:     if (argc == 0) {
    1:         precision = 0.0;
    1:         oneArgMode = zeroArgMode;
    1:     } else {
12694:         precision = js_ValueToNumber(cx, &vp[2]);
12694:         if (JSVAL_IS_NULL(vp[2]))
    1:             return JS_FALSE;
    1:         precision = js_DoubleToInteger(precision);
    1:         if (precision < precisionMin || precision > precisionMax) {
    1:             numStr = JS_dtostr(buf, sizeof buf, DTOSTR_STANDARD, 0, precision);
    1:             if (!numStr)
    1:                 JS_ReportOutOfMemory(cx);
    1:             else
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_PRECISION_RANGE, numStr);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     numStr = JS_dtostr(buf, sizeof buf, oneArgMode, (jsint)precision + precisionOffset, d);
    1:     if (!numStr) {
    1:         JS_ReportOutOfMemory(cx);
    1:         return JS_FALSE;
    1:     }
    1:     str = JS_NewStringCopyZ(cx, numStr);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
 4127: /*
 4127:  * In the following three implementations, we allow a larger range of precision
 4127:  * than ECMA requires; this is permitted by ECMA-262.
 4127:  */
    1: static JSBool
 4127: num_toFixed(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return num_to(cx, DTOSTR_FIXED, DTOSTR_FIXED, -20, MAX_PRECISION, 0,
 4127:                   argc, vp);
    1: }
    1: 
    1: static JSBool
 4127: num_toExponential(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return num_to(cx, DTOSTR_STANDARD_EXPONENTIAL, DTOSTR_EXPONENTIAL, 0,
 4127:                   MAX_PRECISION, 1, argc, vp);
    1: }
    1: 
    1: static JSBool
 4127: num_toPrecision(JSContext *cx, uintN argc, jsval *vp)
    1: {
16519:     if (argc == 0 || JSVAL_IS_VOID(vp[2]))
20408:         return num_toString(cx, 0, vp);
 4127:     return num_to(cx, DTOSTR_STANDARD, DTOSTR_PRECISION, 1, MAX_PRECISION, 0,
 4127:                   argc, vp);
    1: }
    1: 
20408: #ifdef JS_TRACER
20408: 
32685: JS_DEFINE_TRCINFO_1(num_toString,
20930:     (2, (extern, STRING, js_NumberToString,      CONTEXT, THIS_DOUBLE,        1, 1)))
20408: 
20408: #endif /* JS_TRACER */
20408: 
    1: static JSFunctionSpec number_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,       num_toSource,          0,JSFUN_THISP_NUMBER),
    1: #endif
32669:     JS_TN(js_toString_str,       num_toString,          1,JSFUN_THISP_NUMBER, &num_toString_trcinfo),
16519:     JS_FN(js_toLocaleString_str, num_toLocaleString,    0,JSFUN_THISP_NUMBER),
16519:     JS_FN(js_valueOf_str,        num_valueOf,           0,JSFUN_THISP_NUMBER),
20587:     JS_FN(js_toJSON_str,         num_valueOf,           0,JSFUN_THISP_NUMBER),
16519:     JS_FN("toFixed",             num_toFixed,           1,JSFUN_THISP_NUMBER),
16519:     JS_FN("toExponential",       num_toExponential,     1,JSFUN_THISP_NUMBER),
16519:     JS_FN("toPrecision",         num_toPrecision,       1,JSFUN_THISP_NUMBER),
 4127:     JS_FS_END
    1: };
    1: 
    1: /* NB: Keep this in synch with number_constants[]. */
    1: enum nc_slot {
    1:     NC_NaN,
    1:     NC_POSITIVE_INFINITY,
    1:     NC_NEGATIVE_INFINITY,
    1:     NC_MAX_VALUE,
    1:     NC_MIN_VALUE,
    1:     NC_LIMIT
    1: };
    1: 
    1: /*
    1:  * Some to most C compilers forbid spelling these at compile time, or barf
    1:  * if you try, so all but MAX_VALUE are set up by js_InitRuntimeNumberState
    1:  * using union jsdpun.
    1:  */
    1: static JSConstDoubleSpec number_constants[] = {
    1:     {0,                         js_NaN_str,          0,{0,0,0}},
    1:     {0,                         "POSITIVE_INFINITY", 0,{0,0,0}},
    1:     {0,                         "NEGATIVE_INFINITY", 0,{0,0,0}},
    1:     {1.7976931348623157E+308,   "MAX_VALUE",         0,{0,0,0}},
    1:     {0,                         "MIN_VALUE",         0,{0,0,0}},
    1:     {0,0,0,{0,0,0}}
    1: };
    1: 
18295: jsdouble js_NaN;
    1: 
32599: 
32599: #if (defined __GNUC__ && defined __i486__)
    1: 
    1: /*
    1:  * Set the exception mask to mask all exceptions and set the FPU precision
32599:  * to 53 bit mantissa (64 bit doubles).
    1:  */
32599: inline void FIX_FPU() {
32599:     short control;
32599:     asm("fstcw %0" : "=m" (control) : );
32599:     control &= ~0x300; // Lower bits 8 and 9 (precision control).
32599:     control |= 0x2f3;  // Raise bits 0-5 (exception masks) and 9 (64-bit precision).
32599:     asm("fldcw %0" : : "m" (control) );
32599: }
    1: 
    1: #else
    1: 
    1: #define FIX_FPU() ((void)0)
    1: 
    1: #endif
    1: 
    1: JSBool
    1: js_InitRuntimeNumberState(JSContext *cx)
    1: {
    1:     JSRuntime *rt;
    1:     jsdpun u;
    1:     struct lconv *locale;
    1: 
    1:     rt = cx->runtime;
    1:     JS_ASSERT(!rt->jsNaN);
    1: 
    1:     FIX_FPU();
    1: 
    1:     u.s.hi = JSDOUBLE_HI32_EXPMASK | JSDOUBLE_HI32_MANTMASK;
    1:     u.s.lo = 0xffffffff;
18295:     number_constants[NC_NaN].dval = js_NaN = u.d;
18295:     rt->jsNaN = js_NewWeaklyRootedDouble(cx, js_NaN);
    1:     if (!rt->jsNaN)
    1:         return JS_FALSE;
    1: 
    1:     u.s.hi = JSDOUBLE_HI32_EXPMASK;
    1:     u.s.lo = 0x00000000;
    1:     number_constants[NC_POSITIVE_INFINITY].dval = u.d;
12850:     rt->jsPositiveInfinity = js_NewWeaklyRootedDouble(cx, u.d);
    1:     if (!rt->jsPositiveInfinity)
    1:         return JS_FALSE;
    1: 
    1:     u.s.hi = JSDOUBLE_HI32_SIGNBIT | JSDOUBLE_HI32_EXPMASK;
    1:     u.s.lo = 0x00000000;
    1:     number_constants[NC_NEGATIVE_INFINITY].dval = u.d;
12850:     rt->jsNegativeInfinity = js_NewWeaklyRootedDouble(cx, u.d);
    1:     if (!rt->jsNegativeInfinity)
    1:         return JS_FALSE;
    1: 
    1:     u.s.hi = 0;
    1:     u.s.lo = 1;
    1:     number_constants[NC_MIN_VALUE].dval = u.d;
    1: 
    1:     locale = localeconv();
    1:     rt->thousandsSeparator =
    1:         JS_strdup(cx, locale->thousands_sep ? locale->thousands_sep : "'");
    1:     rt->decimalSeparator =
    1:         JS_strdup(cx, locale->decimal_point ? locale->decimal_point : ".");
    1:     rt->numGrouping =
    1:         JS_strdup(cx, locale->grouping ? locale->grouping : "\3\0");
    1: 
    1:     return rt->thousandsSeparator && rt->decimalSeparator && rt->numGrouping;
    1: }
    1: 
    1: void
12282: js_TraceRuntimeNumberState(JSTracer *trc)
12282: {
12282:     JSRuntime *rt;
12282: 
12282:     rt = trc->context->runtime;
12282:     if (rt->jsNaN)
12282:         JS_CALL_DOUBLE_TRACER(trc, rt->jsNaN, "NaN");
12282:     if (rt->jsPositiveInfinity)
12282:         JS_CALL_DOUBLE_TRACER(trc, rt->jsPositiveInfinity, "+Infinity");
12282:     if (rt->jsNegativeInfinity)
12282:         JS_CALL_DOUBLE_TRACER(trc, rt->jsNegativeInfinity, "-Infinity");
12282: }
12282: 
12282: void
    1: js_FinishRuntimeNumberState(JSContext *cx)
    1: {
    1:     JSRuntime *rt = cx->runtime;
    1: 
    1:     js_UnlockGCThingRT(rt, rt->jsNaN);
    1:     js_UnlockGCThingRT(rt, rt->jsNegativeInfinity);
    1:     js_UnlockGCThingRT(rt, rt->jsPositiveInfinity);
    1: 
    1:     rt->jsNaN = NULL;
    1:     rt->jsNegativeInfinity = NULL;
    1:     rt->jsPositiveInfinity = NULL;
    1: 
30851:     cx->free((void *)rt->thousandsSeparator);
30851:     cx->free((void *)rt->decimalSeparator);
30851:     cx->free((void *)rt->numGrouping);
    1:     rt->thousandsSeparator = rt->decimalSeparator = rt->numGrouping = NULL;
    1: }
    1: 
    1: JSObject *
    1: js_InitNumberClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto, *ctor;
    1:     JSRuntime *rt;
    1: 
    1:     /* XXX must do at least once per new thread, so do it per JSContext... */
    1:     FIX_FPU();
    1: 
    1:     if (!JS_DefineFunctions(cx, obj, number_functions))
    1:         return NULL;
    1: 
    1:     proto = JS_InitClass(cx, obj, NULL, &js_NumberClass, Number, 1,
    1:                          NULL, number_methods, NULL, NULL);
    1:     if (!proto || !(ctor = JS_GetConstructor(cx, proto)))
    1:         return NULL;
32684:     proto->fslots[JSSLOT_PRIMITIVE_THIS] = JSVAL_ZERO;
    1:     if (!JS_DefineConstDoubles(cx, ctor, number_constants))
    1:         return NULL;
    1: 
    1:     /* ECMA 15.1.1.1 */
    1:     rt = cx->runtime;
    1:     if (!JS_DefineProperty(cx, obj, js_NaN_str, DOUBLE_TO_JSVAL(rt->jsNaN),
    1:                            NULL, NULL, JSPROP_PERMANENT)) {
    1:         return NULL;
    1:     }
    1: 
    1:     /* ECMA 15.1.1.2 */
    1:     if (!JS_DefineProperty(cx, obj, js_Infinity_str,
    1:                            DOUBLE_TO_JSVAL(rt->jsPositiveInfinity),
    1:                            NULL, NULL, JSPROP_PERMANENT)) {
    1:         return NULL;
    1:     }
    1:     return proto;
    1: }
    1: 
    1: JSBool
12850: js_NewNumberInRootedValue(JSContext *cx, jsdouble d, jsval *vp)
    1: {
    1:     jsint i;
    1: 
    1:     if (JSDOUBLE_IS_INT(d, i) && INT_FITS_IN_JSVAL(i)) {
12850:         *vp = INT_TO_JSVAL(i);
12850:         return JS_TRUE;
    1:     }
12850:     return js_NewDoubleInRootedValue(cx, d, vp);
    1: }
    1: 
26564: JSBool
26564: js_NewWeaklyRootedNumber(JSContext *cx, jsdouble d, jsval *rval)
26564: {
26564:     jsint i;
26564:     if (JSDOUBLE_IS_INT(d, i) && INT_FITS_IN_JSVAL(i)) {
26564:         *rval = INT_TO_JSVAL(i);
26564:         return JS_TRUE;
26564:     }
26564:     return JS_NewDoubleValue(cx, d, rval);
26564: }
26564: 
23700: /*
23700:  * Convert a number to C string. The buf must be large enough to accommodate
23700:  * the result, including '-' and '\0', if base == 10 or d is an integer that
23700:  * fits in 32 bits. The caller must free the resulting pointer if it does not
23700:  * point into buf.
23700:  */
23700: static char *
23700: NumberToCString(JSContext *cx, jsdouble d, jsint base, char *buf, size_t bufSize)
    1: {
    1:     jsint i;
    1:     char *numStr;
    1: 
 8439:     JS_ASSERT(bufSize >= DTOSTR_STANDARD_BUFFER_SIZE);
    1:     if (JSDOUBLE_IS_INT(d, i)) {
23700:         numStr = IntToCString(i, base, buf, bufSize);
    1:     } else {
20898:         if (base == 10)
 8439:             numStr = JS_dtostr(buf, bufSize, DTOSTR_STANDARD, 0, d);
20898:         else
20898:             numStr = JS_dtobasestr(base, d);
    1:         if (!numStr) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1:     }
 8439:     return numStr;
    1: }
    1: 
32685: static JSString *
20915: NumberToStringWithBase(JSContext *cx, jsdouble d, jsint base)
20409: {
23700:     /*
23700:      * The longest possible result here that would need to fit in buf is
23700:      * (-0x80000000).toString(2), which has length 33.  (This can produce
23700:      * longer results, but in those cases buf is not used; see comment at
23700:      * NumberToCString.)
23700:      */
23700:     char buf[34];
20409:     char *numStr;
23700:     JSString *s;
20409: 
20898:     if (base < 2 || base > 36)
20898:         return NULL;
23700:     numStr = NumberToCString(cx, d, base, buf, sizeof buf);
20409:     if (!numStr)
20409:         return NULL;
23700:     s = JS_NewStringCopyZ(cx, numStr);
23700:     if (!(numStr >= buf && numStr < buf + sizeof buf))
30851:         js_free(numStr);
23700:     return s;
20409: }
20409: 
18078: JSString * JS_FASTCALL
    1: js_NumberToString(JSContext *cx, jsdouble d)
    1: {
32674:     jsint i;
32674: 
32686:     if (JSDOUBLE_IS_INT(d, i) && jsuint(i) < INT_STRING_LIMIT)
32686:         return JSString::intString(i);
20915:     return NumberToStringWithBase(cx, d, 10);
    1: }
    1: 
30023: JSBool JS_FASTCALL
31890: js_NumberValueToCharBuffer(JSContext *cx, jsval v, JSCharBuffer &cb)
30023: {
30023:     /* Convert to C-string. */
30023:     static const size_t arrSize = DTOSTR_STANDARD_BUFFER_SIZE;
30023:     char arr[arrSize];
30023:     const char *cstr;
30023:     if (JSVAL_IS_INT(v)) {
30023:         cstr = IntToCString(JSVAL_TO_INT(v), 10, arr, arrSize);
30023:     } else {
30023:         JS_ASSERT(JSVAL_IS_DOUBLE(v));
30023:         cstr = JS_dtostr(arr, arrSize, DTOSTR_STANDARD, 0, *JSVAL_TO_DOUBLE(v));
30023:     }
30023:     if (!cstr)
30023:         return JS_FALSE;
30023: 
30023:     /*
30023:      * Inflate to jschar string.  The input C-string characters are < 127, so
30023:      * even if jschars are UTF-8, all chars should map to one jschar.
30023:      */
30023:     size_t cstrlen = strlen(cstr);
30023:     JS_ASSERT(cstrlen < arrSize);
31925:     size_t sizeBefore = cb.length();
31890:     if (!cb.growBy(cstrlen))
30023:         return JS_FALSE;
31890:     jschar *appendBegin = cb.begin() + sizeBefore;
30023: #ifdef DEBUG
30023:     size_t oldcstrlen = cstrlen;
30023:     JSBool ok =
30023: #endif
30023:         js_InflateStringToBuffer(cx, cstr, cstrlen, appendBegin, &cstrlen);
30023:     JS_ASSERT(ok && cstrlen == oldcstrlen);
30023:     return JS_TRUE;
30023: }
30023: 
12694: jsdouble
12694: js_ValueToNumber(JSContext *cx, jsval *vp)
    1: {
12694:     jsval v;
    1:     JSString *str;
 4281:     const jschar *bp, *end, *ep;
12850:     jsdouble d, *dp;
    1:     JSObject *obj;
12694:     JSTempValueRooter tvr;
    1: 
12694:     v = *vp;
12694:     for (;;) {
12694:         if (JSVAL_IS_INT(v))
12694:             return (jsdouble) JSVAL_TO_INT(v);
12694:         if (JSVAL_IS_DOUBLE(v))
12694:             return *JSVAL_TO_DOUBLE(v);
12694:         if (JSVAL_IS_STRING(v)) {
    1:             str = JSVAL_TO_STRING(v);
 4281: 
    1:             /*
12694:              * Note that ECMA doesn't treat a string beginning with a '0' as
12694:              * an octal number here. This works because all such numbers will
12694:              * be interpreted as decimal by js_strtod and will never get
12694:              * passed to js_strtointeger (which would interpret them as
12694:              * octal).
    1:              */
29366:             str->getCharsAndEnd(bp, end);
31827: 
31827:             /* ECMA doesn't allow signed hex numbers (bug 273467). */
31827:             bp = js_SkipWhiteSpace(bp, end);
31827:             if (bp + 2 < end && (*bp == '-' || *bp == '+') &&
31827:                 bp[1] == '0' && (bp[2] == 'X' || bp[2] == 'x')) {
31827:                 break;
31827:             }
31827: 
12694:             if ((!js_strtod(cx, bp, end, &ep, &d) ||
 4281:                  js_SkipWhiteSpace(ep, end) != end) &&
12694:                 (!js_strtointeger(cx, bp, end, &ep, 0, &d) ||
 4281:                  js_SkipWhiteSpace(ep, end) != end)) {
12694:                 break;
    1:             }
    1: 
12850:             /*
12850:              * JSVAL_TRUE indicates that double jsval was never constructed
12850:              * for the result.
12850:              */
12850:             *vp = JSVAL_TRUE;
12694:             return d;
12581:         }
12850:         if (JSVAL_IS_BOOLEAN(v)) {
12850:             if (JSVAL_TO_BOOLEAN(v)) {
12850:                 *vp = JSVAL_ONE;
12850:                 return 1.0;
12850:             } else {
12850:                 *vp = JSVAL_ZERO;
12850:                 return 0.0;
12850:             }
12850:         }
12694:         if (JSVAL_IS_NULL(v)) {
12694:             *vp = JSVAL_ZERO;
12694:             return 0.0;
12694:         }
12694:         if (JSVAL_IS_VOID(v))
12694:             break;
12694: 
12694:         JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));
12694:         obj = JSVAL_TO_OBJECT(v);
12694: 
12694:         /*
12694:          * vp roots obj so we cannot use it as an extra root for
31501:          * obj->defaultValue result when calling the hook.
12694:          */
12694:         JS_PUSH_SINGLE_TEMP_ROOT(cx, v, &tvr);
31501:         if (!obj->defaultValue(cx, JSTYPE_NUMBER, &tvr.u.value))
12694:             obj = NULL;
12694:         else
12694:             v = *vp = tvr.u.value;
12694:         JS_POP_TEMP_ROOT(cx, &tvr);
12694:         if (!obj) {
12694:             *vp = JSVAL_NULL;
12694:             return 0.0;
12694:         }
12694:         if (!JSVAL_IS_PRIMITIVE(v))
12694:             break;
12694:     }
12694: 
12850:     dp = cx->runtime->jsNaN;
12850:     *vp = DOUBLE_TO_JSVAL(dp);
12850:     return *dp;
12581: }
12581: 
12681: int32
12681: js_ValueToECMAInt32(JSContext *cx, jsval *vp)
    1: {
12681:     jsval v;
    1:     jsdouble d;
    1: 
12681:     v = *vp;
12681:     if (JSVAL_IS_INT(v))
12681:         return JSVAL_TO_INT(v);
12681:     if (JSVAL_IS_DOUBLE(v)) {
12681:         d = *JSVAL_TO_DOUBLE(v);
12850:         *vp = JSVAL_TRUE;
12681:     } else {
12694:         d = js_ValueToNumber(cx, vp);
12694:         if (JSVAL_IS_NULL(*vp))
12681:             return 0;
12850:         *vp = JSVAL_TRUE;
12681:     }
12681:     return js_DoubleToECMAInt32(d);
    1: }
    1: 
12681: uint32
12681: js_ValueToECMAUint32(JSContext *cx, jsval *vp)
    1: {
12681:     jsval v;
12850:     jsint i;
    1:     jsdouble d;
    1: 
12681:     v = *vp;
12850:     if (JSVAL_IS_INT(v)) {
12850:         i = JSVAL_TO_INT(v);
12850:         if (i < 0)
12850:             *vp = JSVAL_TRUE;
12850:         return (uint32) i;
12850:     }
12681:     if (JSVAL_IS_DOUBLE(v)) {
12681:         d = *JSVAL_TO_DOUBLE(v);
12850:         *vp = JSVAL_TRUE;
12681:     } else {
12694:         d = js_ValueToNumber(cx, vp);
12694:         if (JSVAL_IS_NULL(*vp))
12681:             return 0;
12850:         *vp = JSVAL_TRUE;
12681:     }
12681:     return js_DoubleToECMAUint32(d);
    1: }
    1: 
 9613: uint32
 9613: js_DoubleToECMAUint32(jsdouble d)
    1: {
12681:     int32 i;
    1:     JSBool neg;
12681:     jsdouble two32;
    1: 
12681:     if (!JSDOUBLE_IS_FINITE(d))
 9613:         return 0;
    1: 
12681:     /*
12681:      * We check whether d fits int32, not uint32, as all but the ">>>" bit
12681:      * manipulation bytecode stores the result as int, not uint. When the
12681:      * result does not fit int jsval, it will be stored as a negative double.
12681:      */
12681:     i = (int32) d;
12681:     if ((jsdouble) i == d)
12681:         return (int32)i;
    1: 
    1:     neg = (d < 0);
    1:     d = floor(neg ? -d : d);
    1:     d = neg ? -d : d;
    1: 
12681:     two32 = 4294967296.0;
    1:     d = fmod(d, two32);
    1: 
11278:     return (uint32) (d >= 0 ? d : d + two32);
    1: }
    1: 
12694: int32
12694: js_ValueToInt32(JSContext *cx, jsval *vp)
    1: {
12694:     jsval v;
    1:     jsdouble d;
    1: 
12694:     v = *vp;
12694:     if (JSVAL_IS_INT(v))
12694:         return JSVAL_TO_INT(v);
12694:     d = js_ValueToNumber(cx, vp);
12694:     if (JSVAL_IS_NULL(*vp))
12694:         return 0;
12850:     if (JSVAL_IS_INT(*vp))
12850:         return JSVAL_TO_INT(*vp);
12850: 
12850:     *vp = JSVAL_TRUE;
    1:     if (JSDOUBLE_IS_NaN(d) || d <= -2147483649.0 || 2147483648.0 <= d) {
    1:         js_ReportValueError(cx, JSMSG_CANT_CONVERT,
    1:                             JSDVG_SEARCH_STACK, v, NULL);
12694:         *vp = JSVAL_NULL;
12694:         return 0;
    1:     }
12694:     return (int32) floor(d + 0.5);  /* Round to nearest */
    1: }
    1: 
12694: uint16
12694: js_ValueToUint16(JSContext *cx, jsval *vp)
    1: {
    1:     jsdouble d;
12850:     uint16 u;
12850:     jsuint m;
    1:     JSBool neg;
    1: 
12694:     d = js_ValueToNumber(cx, vp);
12694:     if (JSVAL_IS_NULL(*vp))
12694:         return 0;
12850: 
12850:     if (JSVAL_IS_INT(*vp)) {
12850:         u = (uint16) JSVAL_TO_INT(*vp);
12850:     } else if (d == 0 || !JSDOUBLE_IS_FINITE(d)) {
12850:         u = (uint16) 0;
12850:     } else {
12850:         u = (uint16) d;
12850:         if ((jsdouble) u != d) {
    1:             neg = (d < 0);
    1:             d = floor(neg ? -d : d);
    1:             d = neg ? -d : d;
    1:             m = JS_BIT(16);
    1:             d = fmod(d, (double) m);
    1:             if (d < 0)
    1:                 d += m;
12850:             u = (uint16) d;
12850:         }
12850:     }
12850:     *vp = INT_TO_JSVAL(u);
12850:     return u;
    1: }
    1: 
    1: JSBool
 4281: js_strtod(JSContext *cx, const jschar *s, const jschar *send,
 4281:           const jschar **ep, jsdouble *dp)
    1: {
 4281:     const jschar *s1;
 4281:     size_t length, i;
    1:     char cbuf[32];
    1:     char *cstr, *istr, *estr;
    1:     JSBool negative;
    1:     jsdouble d;
 4281: 
 4281:     s1 = js_SkipWhiteSpace(s, send);
 4281:     length = send - s1;
    1: 
    1:     /* Use cbuf to avoid malloc */
    1:     if (length >= sizeof cbuf) {
30851:         cstr = (char *) cx->malloc(length + 1);
    1:         if (!cstr)
    1:            return JS_FALSE;
    1:     } else {
    1:         cstr = cbuf;
    1:     }
    1: 
 4281:     for (i = 0; i != length; i++) {
 4281:         if (s1[i] >> 8)
    1:             break;
    1:         cstr[i] = (char)s1[i];
    1:     }
 4281:     cstr[i] = 0;
    1: 
    1:     istr = cstr;
    1:     if ((negative = (*istr == '-')) != 0 || *istr == '+')
    1:         istr++;
32609:     if (*istr == 'I' && !strncmp(istr, js_Infinity_str, sizeof js_Infinity_str - 1)) {
    1:         d = *(negative ? cx->runtime->jsNegativeInfinity : cx->runtime->jsPositiveInfinity);
    1:         estr = istr + 8;
    1:     } else {
    1:         int err;
    1:         d = JS_strtod(cstr, &estr, &err);
    1:         if (d == HUGE_VAL)
    1:             d = *cx->runtime->jsPositiveInfinity;
    1:         else if (d == -HUGE_VAL)
    1:             d = *cx->runtime->jsNegativeInfinity;
    1:     }
    1: 
    1:     i = estr - cstr;
    1:     if (cstr != cbuf)
30851:         cx->free(cstr);
    1:     *ep = i ? s1 + i : s;
    1:     *dp = d;
    1:     return JS_TRUE;
    1: }
    1: 
    1: struct BinaryDigitReader
    1: {
    1:     uintN base;                 /* Base of number; must be a power of 2 */
    1:     uintN digit;                /* Current digit value in radix given by base */
    1:     uintN digitMask;            /* Mask to extract the next bit from digit */
    1:     const jschar *digits;       /* Pointer to the remaining digits */
    1:     const jschar *end;          /* Pointer to first non-digit */
    1: };
    1: 
    1: /* Return the next binary digit from the number or -1 if done */
    1: static intN GetNextBinaryDigit(struct BinaryDigitReader *bdr)
    1: {
    1:     intN bit;
    1: 
    1:     if (bdr->digitMask == 0) {
    1:         uintN c;
    1: 
    1:         if (bdr->digits == bdr->end)
    1:             return -1;
    1: 
    1:         c = *bdr->digits++;
    1:         if ('0' <= c && c <= '9')
    1:             bdr->digit = c - '0';
    1:         else if ('a' <= c && c <= 'z')
    1:             bdr->digit = c - 'a' + 10;
29366:         else
29366:             bdr->digit = c - 'A' + 10;
    1:         bdr->digitMask = bdr->base >> 1;
    1:     }
    1:     bit = (bdr->digit & bdr->digitMask) != 0;
    1:     bdr->digitMask >>= 1;
    1:     return bit;
    1: }
    1: 
    1: JSBool
 4281: js_strtointeger(JSContext *cx, const jschar *s, const jschar *send,
 4281:                 const jschar **ep, jsint base, jsdouble *dp)
    1: {
 4281:     const jschar *s1, *start;
    1:     JSBool negative;
    1:     jsdouble value;
    1: 
 4281:     s1 = js_SkipWhiteSpace(s, send);
 4281:     if (s1 == send)
 4281:         goto no_digits;
 4281:     if ((negative = (*s1 == '-')) != 0 || *s1 == '+') {
    1:         s1++;
 4281:         if (s1 == send)
 4281:             goto no_digits;
 4281:     }
    1: 
    1:     if (base == 0) {
    1:         /* No base supplied, or some base that evaluated to 0. */
    1:         if (*s1 == '0') {
    1:             /* It's either hex or octal; only increment char if str isn't '0' */
 4281:             if (s1 + 1 != send && (s1[1] == 'X' || s1[1] == 'x')) {
 4281:                 base = 16;
    1:                 s1 += 2;
 4281:                 if (s1 == send)
 4281:                     goto no_digits;
 4281:             } else {
    1:                 base = 8;
    1:             }
    1:         } else {
    1:             base = 10; /* Default to decimal. */
    1:         }
 4281:     } else if (base == 16) {
    1:         /* If base is 16, ignore hex prefix. */
 4281:         if (*s1 == '0' && s1 + 1 != send && (s1[1] == 'X' || s1[1] == 'x')) {
    1:             s1 += 2;
 4281:             if (s1 == send)
 4281:                 goto no_digits;
 4281:         }
    1:     }
    1: 
    1:     /*
    1:      * Done with the preliminaries; find some prefix of the string that's
    1:      * a number in the given base.
    1:      */
 4281:     JS_ASSERT(s1 < send);
 4281:     start = s1;
    1:     value = 0.0;
 4281:     do {
    1:         uintN digit;
    1:         jschar c = *s1;
    1:         if ('0' <= c && c <= '9')
    1:             digit = c - '0';
    1:         else if ('a' <= c && c <= 'z')
    1:             digit = c - 'a' + 10;
    1:         else if ('A' <= c && c <= 'Z')
    1:             digit = c - 'A' + 10;
    1:         else
    1:             break;
    1:         if (digit >= (uintN)base)
    1:             break;
    1:         value = value * base + digit;
 4281:     } while (++s1 != send);
    1: 
    1:     if (value >= 9007199254740992.0) {
    1:         if (base == 10) {
    1:             /*
    1:              * If we're accumulating a decimal number and the number is >=
    1:              * 2^53, then the result from the repeated multiply-add above may
    1:              * be inaccurate.  Call JS_strtod to get the correct answer.
    1:              */
    1:             size_t i;
    1:             size_t length = s1 - start;
30851:             char *cstr = (char *) cx->malloc(length + 1);
    1:             char *estr;
    1:             int err=0;
    1: 
    1:             if (!cstr)
    1:                 return JS_FALSE;
    1:             for (i = 0; i != length; i++)
    1:                 cstr[i] = (char)start[i];
    1:             cstr[length] = 0;
    1: 
    1:             value = JS_strtod(cstr, &estr, &err);
    1:             if (err == JS_DTOA_ENOMEM) {
    1:                 JS_ReportOutOfMemory(cx);
30851:                 cx->free(cstr);
    1:                 return JS_FALSE;
    1:             }
    1:             if (err == JS_DTOA_ERANGE && value == HUGE_VAL)
    1:                 value = *cx->runtime->jsPositiveInfinity;
30851:             cx->free(cstr);
    1:         } else if ((base & (base - 1)) == 0) {
    1:             /*
    1:              * The number may also be inaccurate for power-of-two bases.  This
    1:              * happens if the addition in value * base + digit causes a round-
    1:              * down to an even least significant mantissa bit when the first
    1:              * dropped bit is a one.  If any of the following digits in the
    1:              * number (which haven't been added in yet) are nonzero, then the
    1:              * correct action would have been to round up instead of down.  An
    1:              * example occurs when reading the number 0x1000000000000081, which
    1:              * rounds to 0x1000000000000000 instead of 0x1000000000000100.
    1:              */
    1:             struct BinaryDigitReader bdr;
    1:             intN bit, bit2;
    1:             intN j;
    1: 
    1:             bdr.base = base;
    1:             bdr.digitMask = 0;
    1:             bdr.digits = start;
    1:             bdr.end = s1;
    1:             value = 0.0;
    1: 
    1:             /* Skip leading zeros. */
    1:             do {
    1:                 bit = GetNextBinaryDigit(&bdr);
    1:             } while (bit == 0);
    1: 
    1:             if (bit == 1) {
    1:                 /* Gather the 53 significant bits (including the leading 1) */
    1:                 value = 1.0;
    1:                 for (j = 52; j; j--) {
    1:                     bit = GetNextBinaryDigit(&bdr);
    1:                     if (bit < 0)
    1:                         goto done;
    1:                     value = value*2 + bit;
    1:                 }
    1:                 /* bit2 is the 54th bit (the first dropped from the mantissa) */
    1:                 bit2 = GetNextBinaryDigit(&bdr);
    1:                 if (bit2 >= 0) {
    1:                     jsdouble factor = 2.0;
    1:                     intN sticky = 0;  /* sticky is 1 if any bit beyond the 54th is 1 */
    1:                     intN bit3;
    1: 
    1:                     while ((bit3 = GetNextBinaryDigit(&bdr)) >= 0) {
    1:                         sticky |= bit3;
    1:                         factor *= 2;
    1:                     }
    1:                     value += bit2 & (bit | sticky);
    1:                     value *= factor;
    1:                 }
    1:               done:;
    1:             }
    1:         }
    1:     }
    1:     /* We don't worry about inaccurate numbers for any other base. */
    1: 
    1:     if (s1 == start) {
 4281:       no_digits:
    1:         *dp = 0.0;
    1:         *ep = s;
    1:     } else {
    1:         *dp = negative ? -value : value;
    1:         *ep = s1;
    1:     }
    1:     return JS_TRUE;
    1: }
