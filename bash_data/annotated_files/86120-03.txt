43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
43113:  *
43113:  * ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is nsDiskCacheDevice.cpp, released
43113:  * February 22, 2001.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications Corporation.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Gordon Sheridan <gordon@netscape.com>
43113:  *   Patrick C. Beard <beard@netscape.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #include <limits.h>
43113: 
43113: // include files for ftruncate (or equivalent)
63458: #if defined(XP_UNIX)
43113: #include <unistd.h>
43113: #elif defined(XP_WIN)
43113: #include <windows.h>
43113: #elif defined(XP_OS2)
43113: #define INCL_DOSERRORS
43113: #include <os2.h>
43113: #else
43113: // XXX add necessary include file for ftruncate (or equivalent)
43113: #endif
43113: 
43113: #include "prtypes.h"
43113: #include "prthread.h"
43113: #include "prbit.h"
43113: 
43113: #include "private/pprio.h"
43113: 
43113: #include "nsDiskCacheDevice.h"
43113: #include "nsDiskCacheEntry.h"
43113: #include "nsDiskCacheMap.h"
43113: #include "nsDiskCacheStreams.h"
43113: 
43113: #include "nsDiskCache.h"
43113: 
43113: #include "nsCacheService.h"
43113: #include "nsCache.h"
43113: 
43113: #include "nsDeleteDir.h"
43113: 
43113: #include "nsICacheVisitor.h"
43113: #include "nsReadableUtils.h"
43113: #include "nsIInputStream.h"
43113: #include "nsIOutputStream.h"
43113: #include "nsCRT.h"
43113: #include "nsCOMArray.h"
43113: #include "nsISimpleEnumerator.h"
43113: 
43113: #include "mozilla/FunctionTimer.h"
68582: #include "nsThreadUtils.h"
74147: #include "mozilla/Telemetry.h"
43113: 
43113: static const char DISK_CACHE_DEVICE_ID[] = { "disk" };
74147: using namespace mozilla;
43113: 
77915: class nsDiskCacheDeviceDeactivateEntryEvent : public nsRunnable {
77915: public:
77915:     nsDiskCacheDeviceDeactivateEntryEvent(nsDiskCacheDevice *device,
77915:                                           nsCacheEntry * entry,
77915:                                           nsDiskCacheBinding * binding)
80486:         : mCanceled(false),
77915:           mEntry(entry),
77915:           mDevice(device),
77915:           mBinding(binding)
77915:     {
77915:     }
77915: 
77915:     NS_IMETHOD Run()
77915:     {
77915:         nsCacheServiceAutoLock lock;
77915: #ifdef PR_LOGGING
77915:         CACHE_LOG_DEBUG(("nsDiskCacheDeviceDeactivateEntryEvent[%p]\n", this));
77915: #endif
77915:         if (!mCanceled) {
77915:             (void) mDevice->DeactivateEntry_Private(mEntry, mBinding);
77915:         }
77915:         return NS_OK;
77915:     }
77915: 
80486:     void CancelEvent() { mCanceled = true; }
77915: private:
79445:     bool mCanceled;
77915:     nsCacheEntry *mEntry;
77915:     nsDiskCacheDevice *mDevice;
77915:     nsDiskCacheBinding *mBinding;
77915: };
77915: 
86120: class nsEvictDiskCacheEntriesEvent : public nsRunnable {
86120: public:
86120:     nsEvictDiskCacheEntriesEvent(nsDiskCacheDevice *device)
86120:         : mDevice(device) {}
86120: 
86120:     NS_IMETHOD Run()
86120:     {
86120:         nsCacheServiceAutoLock lock;
86120:         mDevice->EvictDiskCacheEntries(mDevice->mCacheCapacity);
86120:         return NS_OK;
86120:     }
86120: 
86120: private:
86120:     nsDiskCacheDevice *mDevice;
86120: };
86120: 
43113: /******************************************************************************
43113:  *  nsDiskCacheEvictor
43113:  *
43113:  *  Helper class for nsDiskCacheDevice.
43113:  *
43113:  *****************************************************************************/
43113: 
43113: class nsDiskCacheEvictor : public nsDiskCacheRecordVisitor
43113: {
43113: public:
43113:     nsDiskCacheEvictor( nsDiskCacheMap *      cacheMap,
43113:                         nsDiskCacheBindery *  cacheBindery,
43113:                         PRUint32              targetSize,
43113:                         const char *          clientID)
43113:         : mCacheMap(cacheMap)
43113:         , mBindery(cacheBindery)
43113:         , mTargetSize(targetSize)
43113:         , mClientID(clientID)
43113:     { 
43113:         mClientIDSize = clientID ? strlen(clientID) : 0;
43113:     }
43113:     
43113:     virtual PRInt32  VisitRecord(nsDiskCacheRecord *  mapRecord);
43113:  
43113: private:
43113:         nsDiskCacheMap *     mCacheMap;
43113:         nsDiskCacheBindery * mBindery;
43113:         PRUint32             mTargetSize;
43113:         const char *         mClientID;
43113:         PRUint32             mClientIDSize;
43113: };
43113: 
43113: 
43113: PRInt32
43113: nsDiskCacheEvictor::VisitRecord(nsDiskCacheRecord *  mapRecord)
43113: {
43113:     if (mCacheMap->TotalSize() < mTargetSize)
43113:         return kStopVisitingRecords;
43113:     
43113:     if (mClientID) {
43113:         // we're just evicting records for a specific client
43113:         nsDiskCacheEntry * diskEntry = mCacheMap->ReadDiskCacheEntry(mapRecord);
43113:         if (!diskEntry)
43113:             return kVisitNextRecord;  // XXX or delete record?
43113:     
43113:         // Compare clientID's without malloc
43113:         if ((diskEntry->mKeySize <= mClientIDSize) ||
43113:             (diskEntry->Key()[mClientIDSize] != ':') ||
43113:             (memcmp(diskEntry->Key(), mClientID, mClientIDSize) != 0)) {
43113:             return kVisitNextRecord;  // clientID doesn't match, skip it
43113:         }
43113:     }
43113:     
43113:     nsDiskCacheBinding * binding = mBindery->FindActiveBinding(mapRecord->HashNumber());
43113:     if (binding) {
77915:         // If the entry is pending deactivation, cancel deactivation and doom
77915:         // the entry
77915:         if (binding->mDeactivateEvent) {
77915:             binding->mDeactivateEvent->CancelEvent();
77915:             binding->mDeactivateEvent = nsnull;
77915:         }
43113:         // We are currently using this entry, so all we can do is doom it.
43113:         // Since we're enumerating the records, we don't want to call
43113:         // DeleteRecord when nsCacheService::DoomEntry() calls us back.
80486:         binding->mDoomed = true;         // mark binding record as 'deleted'
43113:         nsCacheService::DoomEntry(binding->mCacheEntry);
43113:     } else {
43113:         // entry not in use, just delete storage because we're enumerating the records
43113:         (void) mCacheMap->DeleteStorage(mapRecord);
43113:     }
43113: 
43113:     return kDeleteRecordAndContinue;  // this will REALLY delete the record
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  *  nsDiskCacheDeviceInfo
43113:  *****************************************************************************/
43113: 
43113: class nsDiskCacheDeviceInfo : public nsICacheDeviceInfo {
43113: public:
43113:     NS_DECL_ISUPPORTS
43113:     NS_DECL_NSICACHEDEVICEINFO
43113: 
43113:     nsDiskCacheDeviceInfo(nsDiskCacheDevice* device)
43113:         :   mDevice(device)
43113:     {
43113:     }
43113: 
43113:     virtual ~nsDiskCacheDeviceInfo() {}
43113:     
43113: private:
43113:     nsDiskCacheDevice* mDevice;
43113: };
43113: 
43113: NS_IMPL_ISUPPORTS1(nsDiskCacheDeviceInfo, nsICacheDeviceInfo)
43113: 
43113: /* readonly attribute string description; */
43113: NS_IMETHODIMP nsDiskCacheDeviceInfo::GetDescription(char ** aDescription)
43113: {
43113:     NS_ENSURE_ARG_POINTER(aDescription);
43113:     *aDescription = NS_strdup("Disk cache device");
43113:     return *aDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
43113: }
43113: 
43113: /* readonly attribute string usageReport; */
43113: NS_IMETHODIMP nsDiskCacheDeviceInfo::GetUsageReport(char ** usageReport)
43113: {
43113:     NS_ENSURE_ARG_POINTER(usageReport);
43113:     nsCString buffer;
43113:     
47157:     buffer.AssignLiteral("  <tr>\n"
47157:                          "    <th>Cache Directory:</th>\n"
47157:                          "    <td>");
43113:     nsCOMPtr<nsILocalFile> cacheDir;
43113:     nsAutoString           path;
43113:     mDevice->getCacheDirectory(getter_AddRefs(cacheDir)); 
43113:     nsresult rv = cacheDir->GetPath(path);
43113:     if (NS_SUCCEEDED(rv)) {
43113:         AppendUTF16toUTF8(path, buffer);
43113:     } else {
43113:         buffer.AppendLiteral("directory unavailable");
43113:     }
47157:     buffer.AppendLiteral("</td>\n"
47157:                          "  </tr>\n");
47157: 
43113:     *usageReport = ToNewCString(buffer);
43113:     if (!*usageReport) return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: /* readonly attribute unsigned long entryCount; */
43113: NS_IMETHODIMP nsDiskCacheDeviceInfo::GetEntryCount(PRUint32 *aEntryCount)
43113: {
43113:     NS_ENSURE_ARG_POINTER(aEntryCount);
43113:     *aEntryCount = mDevice->getEntryCount();
43113:     return NS_OK;
43113: }
43113: 
43113: /* readonly attribute unsigned long totalSize; */
43113: NS_IMETHODIMP nsDiskCacheDeviceInfo::GetTotalSize(PRUint32 *aTotalSize)
43113: {
43113:     NS_ENSURE_ARG_POINTER(aTotalSize);
43113:     // Returned unit's are in bytes
43113:     *aTotalSize = mDevice->getCacheSize() * 1024;
43113:     return NS_OK;
43113: }
43113: 
43113: /* readonly attribute unsigned long maximumSize; */
43113: NS_IMETHODIMP nsDiskCacheDeviceInfo::GetMaximumSize(PRUint32 *aMaximumSize)
43113: {
43113:     NS_ENSURE_ARG_POINTER(aMaximumSize);
43113:     // Returned unit's are in bytes
43113:     *aMaximumSize = mDevice->getCacheCapacity() * 1024;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  *  nsDiskCache
43113:  *****************************************************************************/
43113: 
43113: /**
43113:  *  nsDiskCache::Hash(const char * key, PLDHashNumber initval)
43113:  *
43113:  *  See http://burtleburtle.net/bob/hash/evahash.html for more information
43113:  *  about this hash function.
43113:  *
43113:  *  This algorithm of this method implies nsDiskCacheRecords will be stored
43113:  *  in a certain order on disk.  If the algorithm changes, existing cache
43113:  *  map files may become invalid, and therefore the kCurrentVersion needs
43113:  *  to be revised.
43113:  */
43113: 
43113: static inline void hashmix(PRUint32& a, PRUint32& b, PRUint32& c)
43113: {
43113:   a -= b; a -= c; a ^= (c>>13);
43113:   b -= c; b -= a; b ^= (a<<8);
43113:   c -= a; c -= b; c ^= (b>>13);
43113:   a -= b; a -= c; a ^= (c>>12); 
43113:   b -= c; b -= a; b ^= (a<<16);
43113:   c -= a; c -= b; c ^= (b>>5);
43113:   a -= b; a -= c; a ^= (c>>3);
43113:   b -= c; b -= a; b ^= (a<<10);
43113:   c -= a; c -= b; c ^= (b>>15);
43113: }
43113: 
43113: PLDHashNumber
43113: nsDiskCache::Hash(const char * key, PLDHashNumber initval)
43113: {
43113:   const PRUint8 *k = reinterpret_cast<const PRUint8*>(key);
43113:   PRUint32 a, b, c, len, length;
43113: 
43113:   length = PL_strlen(key);
43113:   /* Set up the internal state */
43113:   len = length;
43113:   a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */
43113:   c = initval;         /* variable initialization of internal state */
43113: 
43113:   /*---------------------------------------- handle most of the key */
43113:   while (len >= 12)
43113:   {
43113:     a += k[0] + (PRUint32(k[1])<<8) + (PRUint32(k[2])<<16) + (PRUint32(k[3])<<24);
43113:     b += k[4] + (PRUint32(k[5])<<8) + (PRUint32(k[6])<<16) + (PRUint32(k[7])<<24);
43113:     c += k[8] + (PRUint32(k[9])<<8) + (PRUint32(k[10])<<16) + (PRUint32(k[11])<<24);
43113:     hashmix(a, b, c);
43113:     k += 12; len -= 12;
43113:   }
43113: 
43113:   /*------------------------------------- handle the last 11 bytes */
43113:   c += length;
43113:   switch(len) {              /* all the case statements fall through */
43113:     case 11: c += (PRUint32(k[10])<<24);
43113:     case 10: c += (PRUint32(k[9])<<16);
43113:     case 9 : c += (PRUint32(k[8])<<8);
43113:     /* the low-order byte of c is reserved for the length */
43113:     case 8 : b += (PRUint32(k[7])<<24);
43113:     case 7 : b += (PRUint32(k[6])<<16);
43113:     case 6 : b += (PRUint32(k[5])<<8);
43113:     case 5 : b += k[4];
43113:     case 4 : a += (PRUint32(k[3])<<24);
43113:     case 3 : a += (PRUint32(k[2])<<16);
43113:     case 2 : a += (PRUint32(k[1])<<8);
43113:     case 1 : a += k[0];
43113:     /* case 0: nothing left to add */
43113:   }
43113:   hashmix(a, b, c);
43113: 
43113:   return c;
43113: }
43113: 
43113: nsresult
43113: nsDiskCache::Truncate(PRFileDesc *  fd, PRUint32  newEOF)
43113: {
43113:     // use modified SetEOF from nsFileStreams::SetEOF()
43113: 
63458: #if defined(XP_UNIX)
43113:     if (ftruncate(PR_FileDesc2NativeHandle(fd), newEOF) != 0) {
43113:         NS_ERROR("ftruncate failed");
43113:         return NS_ERROR_FAILURE;
43113:     }
43113: 
43113: #elif defined(XP_WIN)
43113:     PRInt32 cnt = PR_Seek(fd, newEOF, PR_SEEK_SET);
43113:     if (cnt == -1)  return NS_ERROR_FAILURE;
43113:     if (!SetEndOfFile((HANDLE) PR_FileDesc2NativeHandle(fd))) {
43113:         NS_ERROR("SetEndOfFile failed");
43113:         return NS_ERROR_FAILURE;
43113:     }
43113: 
43113: #elif defined(XP_OS2)
43113:     if (DosSetFileSize((HFILE) PR_FileDesc2NativeHandle(fd), newEOF) != NO_ERROR) {
43113:         NS_ERROR("DosSetFileSize failed");
43113:         return NS_ERROR_FAILURE;
43113:     }
43113: #else
43113:     // add implementations for other platforms here
43113: #endif
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  *  nsDiskCacheDevice
43113:  *****************************************************************************/
43113: 
43113: nsDiskCacheDevice::nsDiskCacheDevice()
43113:     : mCacheCapacity(0)
72584:     , mMaxEntrySize(-1) // -1 means "no limit"
80486:     , mInitialized(false)
43113: {
43113: }
43113: 
43113: nsDiskCacheDevice::~nsDiskCacheDevice()
43113: {
43113:     Shutdown();
43113: }
43113: 
43113: 
43113: /**
43113:  *  methods of nsCacheDevice
43113:  */
43113: nsresult
43113: nsDiskCacheDevice::Init()
43113: {
43113:     NS_TIME_FUNCTION;
43113: 
43113:     nsresult rv;
43113: 
54219:     if (Initialized()) {
54219:         NS_ERROR("Disk cache already initialized!");
54219:         return NS_ERROR_UNEXPECTED;
54219:     }
43113:        
43113:     if (!mCacheDirectory)
43113:         return NS_ERROR_FAILURE;
43113: 
43113:     rv = mBindery.Init();
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
83182:     nsDeleteDir::RemoveOldTrashes(mCacheDirectory);
83182: 
43113:     // Open Disk Cache
43113:     rv = OpenDiskCache();
43113:     if (NS_FAILED(rv)) {
80486:         (void) mCacheMap.Close(false);
43113:         return rv;
43113:     }
43113: 
80486:     mInitialized = true;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: /**
43113:  *  NOTE: called while holding the cache service lock
43113:  */
43113: nsresult
43113: nsDiskCacheDevice::Shutdown()
43113: {
64576:     nsCacheService::AssertOwnsLock();
64576: 
80486:     nsresult rv = Shutdown_Private(true);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: nsresult
79445: nsDiskCacheDevice::Shutdown_Private(bool    flush)
43113: {
43113:     CACHE_LOG_DEBUG(("CACHE: disk Shutdown_Private [%u]\n", flush));
43113: 
43113:     if (Initialized()) {
43113:         // check cache limits in case we need to evict.
43113:         EvictDiskCacheEntries(mCacheCapacity);
43113: 
61001:         // At this point there may be a number of pending cache-requests on the
61001:         // cache-io thread. Wait for all these to run before we wipe out our
61001:         // datastructures (see bug #620660)
61001:         (void) nsCacheService::SyncWithCacheIOThread();
61001: 
43113:         // write out persistent information about the cache.
43113:         (void) mCacheMap.Close(flush);
43113: 
43113:         mBindery.Reset();
43113: 
80486:         mInitialized = false;
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: const char *
43113: nsDiskCacheDevice::GetDeviceID()
43113: {
43113:     return DISK_CACHE_DEVICE_ID;
43113: }
43113: 
43113: /**
43113:  *  FindEntry -
43113:  *
43113:  *      cases:  key not in disk cache, hash number free
43113:  *              key not in disk cache, hash number used
43113:  *              key in disk cache
43113:  *
43113:  *  NOTE: called while holding the cache service lock
43113:  */
43113: nsCacheEntry *
79445: nsDiskCacheDevice::FindEntry(nsCString * key, bool *collision)
43113: {
81095:     Telemetry::AutoTimer<Telemetry::CACHE_DISK_SEARCH> timer;
43113:     if (!Initialized())  return nsnull;  // NS_ERROR_NOT_INITIALIZED
43113:     nsDiskCacheRecord       record;
43113:     nsDiskCacheBinding *    binding = nsnull;
43113:     PLDHashNumber           hashNumber = nsDiskCache::Hash(key->get());
43113: 
80486:     *collision = false;
43113: 
43113:     binding = mBindery.FindActiveBinding(hashNumber);
43113:     if (binding && !binding->mCacheEntry->Key()->Equals(*key)) {
80486:         *collision = true;
43113:         return nsnull;
68582:     } else if (binding && binding->mDeactivateEvent) {
68582:         binding->mDeactivateEvent->CancelEvent();
68582:         binding->mDeactivateEvent = nsnull;
68582:         CACHE_LOG_DEBUG(("CACHE: reusing deactivated entry %p " \
68582:                          "req-key=%s  entry-key=%s\n",
68582:                          binding->mCacheEntry, key, binding->mCacheEntry->Key()));
68582: 
68582:         return binding->mCacheEntry; // just return this one, observing that
68582:                                      // FindActiveBinding() does not return
68582:                                      // bindings to doomed entries
43113:     }
43113:     binding = nsnull;
43113: 
43113:     // lookup hash number in cache map
43113:     nsresult rv = mCacheMap.FindRecord(hashNumber, &record);
43113:     if (NS_FAILED(rv))  return nsnull;  // XXX log error?
43113:     
43113:     nsDiskCacheEntry * diskEntry = mCacheMap.ReadDiskCacheEntry(&record);
43113:     if (!diskEntry) return nsnull;
43113:     
43113:     // compare key to be sure
43113:     if (!key->Equals(diskEntry->Key())) {
80486:         *collision = true;
43113:         return nsnull;
43113:     }
43113:     
43113:     nsCacheEntry * entry = diskEntry->CreateCacheEntry(this);
43113:     if (!entry)  return nsnull;
43113:     
43113:     binding = mBindery.CreateBinding(entry, &record);
43113:     if (!binding) {
43113:         delete entry;
43113:         return nsnull;
43113:     }
43113:     
43113:     return entry;
43113: }
43113: 
43113: 
43113: /**
43113:  *  NOTE: called while holding the cache service lock
43113:  */
43113: nsresult
43113: nsDiskCacheDevice::DeactivateEntry(nsCacheEntry * entry)
43113: {
43113:     nsresult              rv = NS_OK;
43113:     nsDiskCacheBinding * binding = GetCacheEntryBinding(entry);
68582:     if (!IsValidBinding(binding))
68582:         return NS_ERROR_UNEXPECTED;
43113: 
43113:     CACHE_LOG_DEBUG(("CACHE: disk DeactivateEntry [%p %x]\n",
43113:         entry, binding->mRecord.HashNumber()));
43113: 
68582:     nsDiskCacheDeviceDeactivateEntryEvent *event =
68582:         new nsDiskCacheDeviceDeactivateEntryEvent(this, entry, binding);
68582: 
68582:     // ensure we can cancel the event via the binding later if necessary
68582:     binding->mDeactivateEvent = event;
68582: 
68582:     rv = nsCacheService::DispatchToCacheIOThread(event);
68582:     NS_ASSERTION(NS_SUCCEEDED(rv), "DeactivateEntry: Failed dispatching "
68582:                                    "deactivation event");
68582:     return NS_OK;
68582: }
68582: 
68582: /**
68582:  *  NOTE: called while holding the cache service lock
68582:  */
68582: nsresult
68582: nsDiskCacheDevice::DeactivateEntry_Private(nsCacheEntry * entry,
68582:                                            nsDiskCacheBinding * binding)
68582: {
68582:     nsresult rv = NS_OK;
43113:     if (entry->IsDoomed()) {
43113:         // delete data, entry, record from disk for entry
43113:         rv = mCacheMap.DeleteStorage(&binding->mRecord);
43113: 
43113:     } else {
43113:         // save stuff to disk for entry
43113:         rv = mCacheMap.WriteDiskCacheEntry(binding);
43113:         if (NS_FAILED(rv)) {
43113:             // clean up as best we can
43113:             (void) mCacheMap.DeleteStorage(&binding->mRecord);
43113:             (void) mCacheMap.DeleteRecord(&binding->mRecord);
80486:             binding->mDoomed = true; // record is no longer in cache map
43113:         }
43113:     }
43113: 
43113:     mBindery.RemoveBinding(binding); // extract binding from collision detection stuff
43113:     delete entry;   // which will release binding
43113:     return rv;
43113: }
43113: 
43113: 
43113: /**
43113:  * BindEntry()
43113:  *      no hash number collision -> no problem
43113:  *      collision
43113:  *          record not active -> evict, no problem
43113:  *          record is active
43113:  *              record is already doomed -> record shouldn't have been in map, no problem
43113:  *              record is not doomed -> doom, and replace record in map
43113:  *              
43113:  *              walk matching hashnumber list to find lowest generation number
43113:  *              take generation number from other (data/meta) location,
43113:  *                  or walk active list
43113:  *
43113:  *  NOTE: called while holding the cache service lock
43113:  */
43113: nsresult
43113: nsDiskCacheDevice::BindEntry(nsCacheEntry * entry)
43113: {
43113:     if (!Initialized())  return  NS_ERROR_NOT_INITIALIZED;
43113:     nsresult rv = NS_OK;
43113:     nsDiskCacheRecord record, oldRecord;
43113:     nsDiskCacheBinding *binding;
43113:     PLDHashNumber hashNumber = nsDiskCache::Hash(entry->Key()->get());
43113: 
43113:     // Find out if there is already an active binding for this hash. If yes it
43113:     // should have another key since BindEntry() shouldn't be called twice for
43113:     // the same entry. Doom the old entry, the new one will get another
43113:     // generation number so files won't collide.
43113:     binding = mBindery.FindActiveBinding(hashNumber);
43113:     if (binding) {
43113:         NS_ASSERTION(!binding->mCacheEntry->Key()->Equals(*entry->Key()),
43113:                      "BindEntry called for already bound entry!");
77915:         // If the entry is pending deactivation, cancel deactivation
77915:         if (binding->mDeactivateEvent) {
77915:             binding->mDeactivateEvent->CancelEvent();
77915:             binding->mDeactivateEvent = nsnull;
77915:         }
43113:         nsCacheService::DoomEntry(binding->mCacheEntry);
43113:         binding = nsnull;
43113:     }
43113: 
43113:     // Lookup hash number in cache map. There can be a colliding inactive entry.
43113:     // See bug #321361 comment 21 for the scenario. If there is such entry,
43113:     // delete it.
43113:     rv = mCacheMap.FindRecord(hashNumber, &record);
43113:     if (NS_SUCCEEDED(rv)) {
43113:         nsDiskCacheEntry * diskEntry = mCacheMap.ReadDiskCacheEntry(&record);
43113:         if (diskEntry) {
43113:             // compare key to be sure
43113:             if (!entry->Key()->Equals(diskEntry->Key())) {
43113:                 mCacheMap.DeleteStorage(&record);
43113:                 rv = mCacheMap.DeleteRecord(&record);
43113:                 if (NS_FAILED(rv))  return rv;
43113:             }
43113:         }
43113:         record = nsDiskCacheRecord();
43113:     }
43113: 
43113:     // create a new record for this entry
43113:     record.SetHashNumber(nsDiskCache::Hash(entry->Key()->get()));
43113:     record.SetEvictionRank(ULONG_MAX - SecondsFromPRTime(PR_Now()));
43113: 
43113:     CACHE_LOG_DEBUG(("CACHE: disk BindEntry [%p %x]\n",
43113:         entry, record.HashNumber()));
43113: 
43113:     if (!entry->IsDoomed()) {
43113:         // if entry isn't doomed, add it to the cache map
43113:         rv = mCacheMap.AddRecord(&record, &oldRecord); // deletes old record, if any
43113:         if (NS_FAILED(rv))  return rv;
43113:         
43113:         PRUint32    oldHashNumber = oldRecord.HashNumber();
43113:         if (oldHashNumber) {
43113:             // gotta evict this one first
43113:             nsDiskCacheBinding * oldBinding = mBindery.FindActiveBinding(oldHashNumber);
43113:             if (oldBinding) {
43113:                 // XXX if debug : compare keys for hashNumber collision
43113: 
43113:                 if (!oldBinding->mCacheEntry->IsDoomed()) {
77915:                     // If the old entry is pending deactivation, cancel deactivation
77915:                     if (oldBinding->mDeactivateEvent) {
77915:                         oldBinding->mDeactivateEvent->CancelEvent();
77915:                         oldBinding->mDeactivateEvent = nsnull;
77915:                     }
43113:                 // we've got a live one!
43113:                     nsCacheService::DoomEntry(oldBinding->mCacheEntry);
43113:                     // storage will be delete when oldBinding->mCacheEntry is Deactivated
43113:                 }
43113:             } else {
43113:                 // delete storage
43113:                 // XXX if debug : compare keys for hashNumber collision
43113:                 rv = mCacheMap.DeleteStorage(&oldRecord);
43113:                 if (NS_FAILED(rv))  return rv;  // XXX delete record we just added?
43113:             }
43113:         }
43113:     }
43113:     
43113:     // Make sure this entry has its associated nsDiskCacheBinding attached.
43113:     binding = mBindery.CreateBinding(entry, &record);
43113:     NS_ASSERTION(binding, "nsDiskCacheDevice::BindEntry");
43113:     if (!binding) return NS_ERROR_OUT_OF_MEMORY;
43113:     NS_ASSERTION(binding->mRecord.ValidRecord(), "bad cache map record");
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: /**
43113:  *  NOTE: called while holding the cache service lock
43113:  */
43113: void
43113: nsDiskCacheDevice::DoomEntry(nsCacheEntry * entry)
43113: {
43113:     CACHE_LOG_DEBUG(("CACHE: disk DoomEntry [%p]\n", entry));
43113: 
43113:     nsDiskCacheBinding * binding = GetCacheEntryBinding(entry);
43113:     NS_ASSERTION(binding, "DoomEntry: binding == nsnull");
68582:     if (!binding)
68582:         return;
43113: 
43113:     if (!binding->mDoomed) {
43113:         // so it can't be seen by FindEntry() ever again.
43113: #ifdef DEBUG
43113:         nsresult rv =
43113: #endif
43113:             mCacheMap.DeleteRecord(&binding->mRecord);
43113:         NS_ASSERTION(NS_SUCCEEDED(rv),"DeleteRecord failed.");
80486:         binding->mDoomed = true; // record in no longer in cache map
43113:     }
43113: }
43113: 
43113: 
43113: /**
43113:  *  NOTE: called while holding the cache service lock
43113:  */
43113: nsresult
43113: nsDiskCacheDevice::OpenInputStreamForEntry(nsCacheEntry *      entry,
43113:                                            nsCacheAccessMode   mode, 
43113:                                            PRUint32            offset,
43113:                                            nsIInputStream **   result)
43113: {
43113:     CACHE_LOG_DEBUG(("CACHE: disk OpenInputStreamForEntry [%p %x %u]\n",
43113:         entry, mode, offset));
43113: 
43113:     NS_ENSURE_ARG_POINTER(entry);
43113:     NS_ENSURE_ARG_POINTER(result);
43113: 
43113:     nsresult             rv;
43113:     nsDiskCacheBinding * binding = GetCacheEntryBinding(entry);
68582:     if (!IsValidBinding(binding))
68582:         return NS_ERROR_UNEXPECTED;
43113: 
43113:     NS_ASSERTION(binding->mCacheEntry == entry, "binding & entry don't point to each other");
43113: 
43113:     rv = binding->EnsureStreamIO();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return binding->mStreamIO->GetInputStream(offset, result);
43113: }
43113: 
43113: 
43113: /**
43113:  *  NOTE: called while holding the cache service lock
43113:  */
43113: nsresult
43113: nsDiskCacheDevice::OpenOutputStreamForEntry(nsCacheEntry *      entry,
43113:                                             nsCacheAccessMode   mode, 
43113:                                             PRUint32            offset,
43113:                                             nsIOutputStream **  result)
43113: {
43113:     CACHE_LOG_DEBUG(("CACHE: disk OpenOutputStreamForEntry [%p %x %u]\n",
43113:         entry, mode, offset));
43113:  
43113:     NS_ENSURE_ARG_POINTER(entry);
43113:     NS_ENSURE_ARG_POINTER(result);
43113: 
43113:     nsresult             rv;
43113:     nsDiskCacheBinding * binding = GetCacheEntryBinding(entry);
68582:     if (!IsValidBinding(binding))
68582:         return NS_ERROR_UNEXPECTED;
43113:     
43113:     NS_ASSERTION(binding->mCacheEntry == entry, "binding & entry don't point to each other");
43113: 
43113:     rv = binding->EnsureStreamIO();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return binding->mStreamIO->GetOutputStream(offset, result);
43113: }
43113: 
43113: 
43113: /**
43113:  *  NOTE: called while holding the cache service lock
43113:  */
43113: nsresult
43113: nsDiskCacheDevice::GetFileForEntry(nsCacheEntry *    entry,
43113:                                    nsIFile **        result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     *result = nsnull;
43113: 
43113:     nsresult             rv;
43113:         
43113:     nsDiskCacheBinding * binding = GetCacheEntryBinding(entry);
68582:     if (!IsValidBinding(binding))
43113:         return NS_ERROR_UNEXPECTED;
43113: 
43113:     // check/set binding->mRecord for separate file, sync w/mCacheMap
43113:     if (binding->mRecord.DataLocationInitialized()) {
43113:         if (binding->mRecord.DataFile() != 0)
43113:             return NS_ERROR_NOT_AVAILABLE;  // data not stored as separate file
43113: 
43113:         NS_ASSERTION(binding->mRecord.DataFileGeneration() == binding->mGeneration, "error generations out of sync");
43113:     } else {
43113:         binding->mRecord.SetDataFileGeneration(binding->mGeneration);
43113:         binding->mRecord.SetDataFileSize(0);    // 1k minimum
43113:         if (!binding->mDoomed) {
43113:             // record stored in cache map, so update it
43113:             rv = mCacheMap.UpdateRecord(&binding->mRecord);
43113:             if (NS_FAILED(rv))  return rv;
43113:         }
43113:     }
43113:     
43113:     nsCOMPtr<nsIFile>  file;
43113:     rv = mCacheMap.GetFileForDiskCacheRecord(&binding->mRecord,
43113:                                              nsDiskCache::kData,
80486:                                              false,
43113:                                              getter_AddRefs(file));
43113:     if (NS_FAILED(rv))  return rv;
43113:     
43113:     NS_IF_ADDREF(*result = file);
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: /**
43113:  *  This routine will get called every time an open descriptor is written to.
43113:  *
43113:  *  NOTE: called while holding the cache service lock
43113:  */
43113: nsresult
43113: nsDiskCacheDevice::OnDataSizeChange(nsCacheEntry * entry, PRInt32 deltaSize)
43113: {
43113:     CACHE_LOG_DEBUG(("CACHE: disk OnDataSizeChange [%p %d]\n",
43113:         entry, deltaSize));
43113: 
43113:     // If passed a negative value, then there's nothing to do.
43113:     if (deltaSize < 0)
43113:         return NS_OK;
43113: 
43113:     nsDiskCacheBinding * binding = GetCacheEntryBinding(entry);
68582:     if (!IsValidBinding(binding))
68582:         return NS_ERROR_UNEXPECTED;
43113: 
43113:     NS_ASSERTION(binding->mRecord.ValidRecord(), "bad record");
43113: 
43113:     PRUint32  newSize = entry->DataSize() + deltaSize;
43113:     PRUint32  newSizeK =  ((newSize + 0x3FF) >> 10);
43113: 
43113:     // If the new size is larger than max. file size or larger than
67725:     // 1/8 the cache capacity (which is in KiB's), and the entry has
67725:     // not been marked for file storage, doom the entry and abort.
67725:     if (EntryIsTooBig(newSize) &&
67725:         entry->StoragePolicy() != nsICache::STORE_ON_DISK_AS_FILE) {
43113: #ifdef DEBUG
43113:         nsresult rv =
43113: #endif
43113:             nsCacheService::DoomEntry(entry);
43113:         NS_ASSERTION(NS_SUCCEEDED(rv),"DoomEntry() failed.");
43113:         return NS_ERROR_ABORT;
43113:     }
43113: 
43113:     PRUint32  sizeK = ((entry->DataSize() + 0x03FF) >> 10); // round up to next 1k
43113: 
70385:     // In total count we ignore anything over kMaxDataSizeK (bug #651100), so
70385:     // the target capacity should be calculated the same way.
70385:     if (sizeK > kMaxDataSizeK) sizeK = kMaxDataSizeK;
70385:     if (newSizeK > kMaxDataSizeK) newSizeK = kMaxDataSizeK;
43113: 
43113:     // pre-evict entries to make space for new data
43113:     PRUint32  targetCapacity = mCacheCapacity > (newSizeK - sizeK)
43113:                              ? mCacheCapacity - (newSizeK - sizeK)
43113:                              : 0;
43113:     EvictDiskCacheEntries(targetCapacity);
43113:     
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  *  EntryInfoVisitor
43113:  *****************************************************************************/
43113: class EntryInfoVisitor : public nsDiskCacheRecordVisitor
43113: {
43113: public:
43113:     EntryInfoVisitor(nsDiskCacheMap *    cacheMap,
43113:                      nsICacheVisitor *   visitor)
43113:         : mCacheMap(cacheMap)
43113:         , mVisitor(visitor)
43113:     {}
43113:     
43113:     virtual PRInt32  VisitRecord(nsDiskCacheRecord *  mapRecord)
43113:     {
43113:         // XXX optimization: do we have this record in memory?
43113:         
43113:         // read in the entry (metadata)
43113:         nsDiskCacheEntry * diskEntry = mCacheMap->ReadDiskCacheEntry(mapRecord);
43113:         if (!diskEntry) {
43113:             return kVisitNextRecord;
43113:         }
43113: 
43113:         // create nsICacheEntryInfo
43113:         nsDiskCacheEntryInfo * entryInfo = new nsDiskCacheEntryInfo(DISK_CACHE_DEVICE_ID, diskEntry);
43113:         if (!entryInfo) {
43113:             return kStopVisitingRecords;
43113:         }
43113:         nsCOMPtr<nsICacheEntryInfo> ref(entryInfo);
43113:         
79445:         bool    keepGoing;
43113:         (void)mVisitor->VisitEntry(DISK_CACHE_DEVICE_ID, entryInfo, &keepGoing);
43113:         return keepGoing ? kVisitNextRecord : kStopVisitingRecords;
43113:     }
43113:  
43113: private:
43113:         nsDiskCacheMap *    mCacheMap;
43113:         nsICacheVisitor *   mVisitor;
43113: };
43113: 
43113: 
43113: nsresult
43113: nsDiskCacheDevice::Visit(nsICacheVisitor * visitor)
43113: {
43113:     if (!Initialized())  return NS_ERROR_NOT_INITIALIZED;
43113:     nsDiskCacheDeviceInfo* deviceInfo = new nsDiskCacheDeviceInfo(this);
43113:     nsCOMPtr<nsICacheDeviceInfo> ref(deviceInfo);
43113:     
79445:     bool keepGoing;
43113:     nsresult rv = visitor->VisitDevice(DISK_CACHE_DEVICE_ID, deviceInfo, &keepGoing);
43113:     if (NS_FAILED(rv)) return rv;
43113:     
43113:     if (keepGoing) {
43113:         EntryInfoVisitor  infoVisitor(&mCacheMap, visitor);
43113:         return mCacheMap.VisitRecords(&infoVisitor);
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
72584: // Max allowed size for an entry is currently MIN(mMaxEntrySize, 1/8 CacheCapacity)
52143: bool
52143: nsDiskCacheDevice::EntryIsTooBig(PRInt64 entrySize)
52143: {
72584:     if (mMaxEntrySize == -1) // no limit
72584:         return entrySize > (static_cast<PRInt64>(mCacheCapacity) * 1024 / 8);
72584:     else 
72584:         return entrySize > mMaxEntrySize ||
72584:                entrySize > (static_cast<PRInt64>(mCacheCapacity) * 1024 / 8);
52143: }
43113: 
43113: nsresult
43113: nsDiskCacheDevice::EvictEntries(const char * clientID)
43113: {
43113:     CACHE_LOG_DEBUG(("CACHE: disk EvictEntries [%s]\n", clientID));
43113: 
43113:     if (!Initialized())  return NS_ERROR_NOT_INITIALIZED;
43113:     nsresult  rv;
43113: 
43113:     if (clientID == nsnull) {
43113:         // we're clearing the entire disk cache
43113:         rv = ClearDiskCache();
43113:         if (rv != NS_ERROR_CACHE_IN_USE)
43113:             return rv;
43113:     }
43113: 
43113:     nsDiskCacheEvictor  evictor(&mCacheMap, &mBindery, 0, clientID);
43113:     rv = mCacheMap.VisitRecords(&evictor);
43113:     
43113:     if (clientID == nsnull)     // we tried to clear the entire cache
43113:         rv = mCacheMap.Trim(); // so trim cache block files (if possible)
43113:     return rv;
43113: }
43113: 
43113: 
43113: /**
43113:  *  private methods
43113:  */
43113: 
43113: nsresult
43113: nsDiskCacheDevice::OpenDiskCache()
43113: {
74147:     Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_OPEN> timer;
43113:     // if we don't have a cache directory, create one and open it
79445:     bool exists;
43113:     nsresult rv = mCacheDirectory->Exists(&exists);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     if (exists) {
43113:         // Try opening cache map file.
43113:         rv = mCacheMap.Open(mCacheDirectory);        
43113:         // move "corrupt" caches to trash
43113:         if (rv == NS_ERROR_FILE_CORRUPTED) {
74744:             // delay delete by 1 minute to avoid IO thrash at startup
83182:             rv = nsDeleteDir::DeleteDir(mCacheDirectory, true, 60000);
43113:             if (NS_FAILED(rv))
43113:                 return rv;
80486:             exists = false;
43113:         }
43113:         else if (NS_FAILED(rv))
43113:             return rv;
43113:     }
43113: 
43113:     // if we don't have a cache directory, create one and open it
43113:     if (!exists) {
43113:         rv = mCacheDirectory->Create(nsIFile::DIRECTORY_TYPE, 0777);
43113:         CACHE_LOG_PATH(PR_LOG_ALWAYS, "\ncreate cache directory: %s\n", mCacheDirectory);
43113:         CACHE_LOG_ALWAYS(("mCacheDirectory->Create() = %x\n", rv));
43113:         if (NS_FAILED(rv))
43113:             return rv;
43113:     
43113:         // reopen the cache map     
43113:         rv = mCacheMap.Open(mCacheDirectory);
43113:         if (NS_FAILED(rv))
43113:             return rv;
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsDiskCacheDevice::ClearDiskCache()
43113: {
43113:     if (mBindery.ActiveBindings())
43113:         return NS_ERROR_CACHE_IN_USE;
43113: 
80486:     nsresult rv = Shutdown_Private(false);  // false: don't bother flushing
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     // If the disk cache directory is already gone, then it's not an error if
43113:     // we fail to delete it ;-)
83182:     rv = nsDeleteDir::DeleteDir(mCacheDirectory, true);
43113:     if (NS_FAILED(rv) && rv != NS_ERROR_FILE_TARGET_DOES_NOT_EXIST)
43113:         return rv;
43113: 
43113:     return Init();
43113: }
43113: 
43113: 
43113: nsresult
43113: nsDiskCacheDevice::EvictDiskCacheEntries(PRUint32  targetCapacity)
43113: {
43113:     CACHE_LOG_DEBUG(("CACHE: disk EvictDiskCacheEntries [%u]\n",
43113:         targetCapacity));
43113: 
43113:     NS_ASSERTION(targetCapacity > 0, "oops");
43113: 
43113:     if (mCacheMap.TotalSize() < targetCapacity)
43113:         return NS_OK;
43113: 
43113:     // targetCapacity is in KiB's
43113:     nsDiskCacheEvictor  evictor(&mCacheMap, &mBindery, targetCapacity, nsnull);
43113:     return mCacheMap.EvictRecords(&evictor);
43113: }
43113: 
43113: 
43113: /**
43113:  *  methods for prefs
43113:  */
43113: 
43113: void
43113: nsDiskCacheDevice::SetCacheParentDirectory(nsILocalFile * parentDir)
43113: {
43113:     nsresult rv;
79445:     bool    exists;
43113: 
43113:     if (Initialized()) {
80486:         NS_ASSERTION(false, "Cannot switch cache directory when initialized");
43113:         return;
43113:     }
43113: 
43113:     if (!parentDir) {
43113:         mCacheDirectory = nsnull;
43113:         return;
43113:     }
43113: 
43113:     // ensure parent directory exists
43113:     rv = parentDir->Exists(&exists);
43113:     if (NS_SUCCEEDED(rv) && !exists)
43113:         rv = parentDir->Create(nsIFile::DIRECTORY_TYPE, 0700);
43113:     if (NS_FAILED(rv))  return;
43113: 
43113:     // ensure cache directory exists
43113:     nsCOMPtr<nsIFile> directory;
43113:     
43113:     rv = parentDir->Clone(getter_AddRefs(directory));
43113:     if (NS_FAILED(rv))  return;
43113:     rv = directory->AppendNative(NS_LITERAL_CSTRING("Cache"));
43113:     if (NS_FAILED(rv))  return;
43113:     
43113:     mCacheDirectory = do_QueryInterface(directory);
43113: }
43113: 
43113: 
43113: void
43113: nsDiskCacheDevice::getCacheDirectory(nsILocalFile ** result)
43113: {
43113:     *result = mCacheDirectory;
43113:     NS_IF_ADDREF(*result);
43113: }
43113: 
43113: 
43113: /**
43113:  *  NOTE: called while holding the cache service lock
43113:  */
43113: void
43113: nsDiskCacheDevice::SetCapacity(PRUint32  capacity)
43113: {
43113:     // Units are KiB's
43113:     mCacheCapacity = capacity;
43113:     if (Initialized()) {
86120:         if (NS_IsMainThread()) {
86120:             // Do not evict entries on the main thread
86120:             nsCacheService::DispatchToCacheIOThread(
86120:                 new nsEvictDiskCacheEntriesEvent(this));
86120:         } else {
43113:             // start evicting entries if the new size is smaller!
43113:             EvictDiskCacheEntries(mCacheCapacity);
43113:         }
86120:     }
43560:     // Let cache map know of the new capacity
43560:     mCacheMap.NotifyCapacityChange(capacity);
43113: }
43113: 
43113: 
43113: PRUint32 nsDiskCacheDevice::getCacheCapacity()
43113: {
43113:     return mCacheCapacity;
43113: }
43113: 
43113: 
43113: PRUint32 nsDiskCacheDevice::getCacheSize()
43113: {
43113:     return mCacheMap.TotalSize();
43113: }
43113: 
43113: 
43113: PRUint32 nsDiskCacheDevice::getEntryCount()
43113: {
43113:     return mCacheMap.EntryCount();
43113: }
72584: 
72584: void
72584: nsDiskCacheDevice::SetMaxEntrySize(PRInt32 maxSizeInKilobytes)
72584: {
72584:     // Internal units are bytes. Changing this only takes effect *after* the
72584:     // change and has no consequences for existing cache-entries
72584:     if (maxSizeInKilobytes >= 0)
72584:         mMaxEntrySize = maxSizeInKilobytes * 1024;
72584:     else
72584:         mMaxEntrySize = -1;
72584: }
