    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Boris Zbarsky <bzbarsky@mit.edu>.
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Boris Zbarsky <bzbarsky@mit.edu> (original author)
    1:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
 3113:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsLayoutUtils_h__
    1: #define nsLayoutUtils_h__
    1: 
    1: class nsIFormControlFrame;
    1: class nsPresContext;
    1: class nsIContent;
    1: class nsIAtom;
    1: class nsIScrollableView;
    1: class nsIScrollableFrame;
    1: class nsIDOMEvent;
    1: class nsRegion;
    1: class nsDisplayListBuilder;
    1: class nsIFontMetrics;
    1: 
    1: #include "prtypes.h"
    1: #include "nsStyleContext.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsStyleSet.h"
    1: #include "nsIView.h"
 5256: #include "nsIFrame.h"
14319: #include "nsThreadUtils.h"
23933: #include "nsIPresShell.h"
    1: 
    1: class nsBlockFrame;
26295: class nsTextFragment;
    1: 
    1: /**
    1:  * nsLayoutUtils is a namespace class used for various helper
    1:  * functions that are useful in multiple places in layout.  The goal
    1:  * is not to define multiple copies of the same static helper.
    1:  */
    1: class nsLayoutUtils
    1: {
    1: public:
    1:   /**
16976:    * GetBeforeFrame returns the outermost :before frame of the given frame, if
    1:    * one exists.  This is typically O(1).  The frame passed in must be
    1:    * the first-in-flow.   
    1:    *
    1:    * @param aFrame the frame whose :before is wanted
    1:    * @return the :before frame or nsnull if there isn't one
    1:    */
    1:   static nsIFrame* GetBeforeFrame(nsIFrame* aFrame);
    1: 
    1:   /**
16976:    * GetAfterFrame returns the outermost :after frame of the given frame, if one
    1:    * exists.  This will walk the in-flow chain to the last-in-flow if
    1:    * needed.  This function is typically O(N) in the number of child
    1:    * frames, following in-flows, etc.
    1:    *
    1:    * @param aFrame the frame whose :after is wanted
    1:    * @return the :after frame or nsnull if there isn't one
    1:    */
    1:   static nsIFrame* GetAfterFrame(nsIFrame* aFrame);
    1: 
    1:   /** 
    1:    * Given a frame, search up the frame tree until we find an
 3113:    * ancestor that (or the frame itself) is of type aFrameType, if any.
    1:    *
 3113:    * @param aFrame the frame to start at
 3113:    * @param aFrameType the frame type to look for
 3113:    * @return a frame of the given type or nsnull if no
 3113:    *         such ancestor exists
 3113:    */
 3113:   static nsIFrame* GetClosestFrameOfType(nsIFrame* aFrame, nsIAtom* aFrameType);
 3113: 
 3113:   /** 
 3113:    * Given a frame, search up the frame tree until we find an
 3113:    * ancestor that (or the frame itself) is a "Page" frame, if any.
 3113:    *
 3113:    * @param aFrame the frame to start at
    1:    * @return a frame of type nsGkAtoms::pageFrame or nsnull if no
    1:    *         such ancestor exists
    1:    */
 3113:   static nsIFrame* GetPageFrame(nsIFrame* aFrame)
 3113:   {
 3113:     return GetClosestFrameOfType(aFrame, nsGkAtoms::pageFrame);
 3113:   }
    1: 
    1:   /**
16976:    * IsGeneratedContentFor returns PR_TRUE if aFrame is the outermost
16976:    * frame for generated content of type aPseudoElement for aContent.
16976:    * aFrame *might not* have the aPseudoElement pseudo-style! For example
16976:    * it might be a table outer frame and the inner table frame might
16976:    * have the pseudo-style.
    1:    *
    1:    * @param aContent the content node we're looking at.  If this is
    1:    *        null, then we just assume that aFrame has the right content
    1:    *        pointer.
    1:    * @param aFrame the frame we're looking at
    1:    * @param aPseudoElement the pseudo type we're interested in
    1:    * @return whether aFrame is the generated aPseudoElement frame for aContent
    1:    */
    1:   static PRBool IsGeneratedContentFor(nsIContent* aContent, nsIFrame* aFrame,
    1:                                       nsIAtom* aPseudoElement);
    1: 
    1:   /**
    1:    * CompareTreePosition determines whether aContent1 comes before or
    1:    * after aContent2 in a preorder traversal of the content tree.
    1:    * 
    1:    * @param aCommonAncestor either null, or a common ancestor of
    1:    *                        aContent1 and aContent2.  Actually this is
    1:    *                        only a hint; if it's not an ancestor of
    1:    *                        aContent1 or aContent2, this function will
    1:    *                        still work, but it will be slower than
    1:    *                        normal.
    1:    * @return < 0 if aContent1 is before aContent2
    1:    *         > 0 if aContent1 is after aContent2,
    1:    *         0 otherwise (meaning they're the same, or they're in
    1:    *           different documents)
    1:    */
    1:   static PRInt32 CompareTreePosition(nsIContent* aContent1,
    1:                                      nsIContent* aContent2,
    1:                                      nsIContent* aCommonAncestor = nsnull)
    1:   {
    1:     return DoCompareTreePosition(aContent1, aContent2, -1, 1, aCommonAncestor);
    1:   }
    1: 
    1:   /*
    1:    * More generic version of |CompareTreePosition|.  |aIf1Ancestor|
    1:    * gives the value to return when 1 is an ancestor of 2, and likewise
    1:    * for |aIf2Ancestor|.  Passing (-1, 1) gives preorder traversal
    1:    * order, and (1, -1) gives postorder traversal order.
    1:    */
    1:   static PRInt32 DoCompareTreePosition(nsIContent* aContent1,
    1:                                        nsIContent* aContent2,
    1:                                        PRInt32 aIf1Ancestor,
    1:                                        PRInt32 aIf2Ancestor,
    1:                                        nsIContent* aCommonAncestor = nsnull);
    1: 
    1:   /**
    1:    * CompareTreePosition determines whether aFrame1 comes before or
    1:    * after aFrame2 in a preorder traversal of the frame tree, where out
    1:    * of flow frames are treated as children of their placeholders. This is
    1:    * basically the same ordering as DoCompareTreePosition(nsIContent*) except
    1:    * that it handles anonymous content properly and there are subtleties with
    1:    * continuations.
    1:    * 
    1:    * @param aCommonAncestor either null, or a common ancestor of
    1:    *                        aContent1 and aContent2.  Actually this is
    1:    *                        only a hint; if it's not an ancestor of
    1:    *                        aContent1 or aContent2, this function will
    1:    *                        still work, but it will be slower than
    1:    *                        normal.
    1:    * @return < 0 if aContent1 is before aContent2
    1:    *         > 0 if aContent1 is after aContent2,
    1:    *         0 otherwise (meaning they're the same, or they're in
    1:    *           different frame trees)
    1:    */
    1:   static PRInt32 CompareTreePosition(nsIFrame* aFrame1,
    1:                                      nsIFrame* aFrame2,
    1:                                      nsIFrame* aCommonAncestor = nsnull)
    1:   {
    1:     return DoCompareTreePosition(aFrame1, aFrame2, -1, 1, aCommonAncestor);
    1:   }
    1: 
    1:   /*
    1:    * More generic version of |CompareTreePosition|.  |aIf1Ancestor|
    1:    * gives the value to return when 1 is an ancestor of 2, and likewise
    1:    * for |aIf2Ancestor|.  Passing (-1, 1) gives preorder traversal
    1:    * order, and (1, -1) gives postorder traversal order.
    1:    */
    1:   static PRInt32 DoCompareTreePosition(nsIFrame* aFrame1,
    1:                                        nsIFrame* aFrame2,
    1:                                        PRInt32 aIf1Ancestor,
    1:                                        PRInt32 aIf2Ancestor,
    1:                                        nsIFrame* aCommonAncestor = nsnull);
    1: 
    1:   /**
10780:    * GetLastContinuationWithChild gets the last continuation in aFrame's chain
10780:    * that has a child, or the first continuation if the frame has no children.
10780:    */
10780:   static nsIFrame* GetLastContinuationWithChild(nsIFrame* aFrame);
10780: 
10780:   /**
    1:    * GetLastSibling simply finds the last sibling of aFrame, or returns nsnull if
    1:    * aFrame is null.
    1:    */
    1:   static nsIFrame* GetLastSibling(nsIFrame* aFrame);
    1: 
    1:   /**
    1:    * FindSiblingViewFor locates the child of aParentView that aFrame's
    1:    * view should be inserted 'above' (i.e., before in sibling view
    1:    * order).  This is the first child view of aParentView whose
    1:    * corresponding content is before aFrame's content (view siblings
    1:    * are in reverse content order).
    1:    */
    1:   static nsIView* FindSiblingViewFor(nsIView* aParentView, nsIFrame* aFrame);
    1: 
    1:   /**
    1:    * Get the parent of aFrame. If aFrame is the root frame for a document,
    1:    * and the document has a parent document in the same view hierarchy, then
    1:    * we try to return the subdocumentframe in the parent document.
18884:    * @param aExtraOffset [in/out] if non-null, then as we cross documents
18884:    * an extra offset may be required and it will be added to aCrossDocOffset
    1:    */
18884:   static nsIFrame* GetCrossDocParentFrame(const nsIFrame* aFrame,
18884:                                           nsPoint* aCrossDocOffset = nsnull);
    1:   
    1:   /**
    1:    * IsProperAncestorFrame checks whether aAncestorFrame is an ancestor
    1:    * of aFrame and not equal to aFrame.
    1:    * @param aCommonAncestor nsnull, or a common ancestor of aFrame and
    1:    * aAncestorFrame. If non-null, this can bound the search and speed up
    1:    * the function
    1:    */
    1:   static PRBool IsProperAncestorFrame(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
    1:                                       nsIFrame* aCommonAncestor = nsnull);
    1: 
    1:   /**
    1:    * Like IsProperAncestorFrame, but looks across document boundaries.
    1:    */
    1:   static PRBool IsProperAncestorFrameCrossDoc(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
    1:                                               nsIFrame* aCommonAncestor = nsnull);
    1: 
    1:   /**
    1:     * GetFrameFor returns the root frame for a view
    1:     * @param aView is the view to return the root frame for
    1:     * @return the root frame for the view
    1:     */
    1:   static nsIFrame* GetFrameFor(nsIView *aView)
 3233:   { return static_cast<nsIFrame*>(aView->GetClientData()); }
    1:   
    1:   /**
    1:     * GetScrollableFrameFor returns the scrollable frame for a scrollable view
    1:     * @param aScrollableView is the scrollable view to return the 
    1:     *        scrollable frame for.
    1:     * @return the scrollable frame for the scrollable view
    1:     */
    1:   static nsIScrollableFrame* GetScrollableFrameFor(nsIScrollableView *aScrollableView);
    1: 
    1:   /**
    1:     * GetScrollableFrameFor returns the scrollable frame for a scrolled frame
    1:     */
    1:   static nsIScrollableFrame* GetScrollableFrameFor(nsIFrame *aScrolledFrame);
    1: 
    1:   static nsPresContext::ScrollbarStyles
    1:     ScrollbarStylesOfView(nsIScrollableView *aScrollableView);
    1: 
    1:   /**
    1:    * GetNearestScrollingView locates the first ancestor of aView (or
    1:    * aView itself) that is scrollable.  It does *not* count an
    1:    * 'overflow' style of 'hidden' as scrollable, even though a scrolling
    1:    * view is present.  Thus, the direction of the scroll is needed as
    1:    * an argument.
    1:    *
    1:    * @param  aView the view we're looking at
    1:    * @param  aDirection Whether it's for horizontal or vertical scrolling.
    1:    * @return the nearest scrollable view or nsnull if not found
    1:    */
    1:   enum Direction { eHorizontal, eVertical, eEither };
    1:   static nsIScrollableView* GetNearestScrollingView(nsIView* aView,
    1:                                                     Direction aDirection);
    1: 
    1:   /**
    1:    * HasPseudoStyle returns PR_TRUE if aContent (whose primary style
    1:    * context is aStyleContext) has the aPseudoElement pseudo-style
    1:    * attached to it; returns PR_FALSE otherwise.
    1:    *
    1:    * @param aContent the content node we're looking at
    1:    * @param aStyleContext aContent's style context
    1:    * @param aPseudoElement the name of the pseudo style we care about
    1:    * @param aPresContext the presentation context
    1:    * @return whether aContent has aPseudoElement style attached to it
    1:    */
    1:   static PRBool HasPseudoStyle(nsIContent* aContent,
    1:                                nsStyleContext* aStyleContext,
    1:                                nsIAtom* aPseudoElement,
    1:                                nsPresContext* aPresContext)
    1:   {
    1:     NS_PRECONDITION(aPresContext, "Must have a prescontext");
    1:     NS_PRECONDITION(aPseudoElement, "Must have a pseudo name");
    1: 
    1:     nsRefPtr<nsStyleContext> pseudoContext;
    1:     if (aContent) {
    1:       pseudoContext = aPresContext->StyleSet()->
    1:         ProbePseudoStyleFor(aContent, aPseudoElement, aStyleContext);
    1:     }
    1:     return pseudoContext != nsnull;
    1:   }
    1: 
    1:   /**
    1:    * If this frame is a placeholder for a float, then return the float,
    1:    * otherwise return nsnull.
    1:    */
    1:   static nsIFrame* GetFloatFromPlaceholder(nsIFrame* aPossiblePlaceholder);
    1: 
    1:   // Combine aNewBreakType with aOrigBreakType, but limit the break types
    1:   // to NS_STYLE_CLEAR_LEFT, RIGHT, LEFT_AND_RIGHT.
    1:   static PRUint8 CombineBreakType(PRUint8 aOrigBreakType, PRUint8 aNewBreakType);
    1: 
    1:   /**
24659:    * @return PR_TRUE if aFrame is the root element frame for
    1:    * its pres-shell
    1:    */
24659:   static PRBool IsRootElementFrame(nsIFrame* aFrame);
    1: 
    1:   /**
    1:    * Get the coordinates of a given DOM mouse event, relative to a given
    1:    * frame. Works only for DOM events generated by nsGUIEvents.
    1:    * @param aDOMEvent the event
    1:    * @param aFrame the frame to make coordinates relative to
    1:    * @return the point, or (NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE) if
    1:    * for some reason the coordinates for the mouse are not known (e.g.,
    1:    * the event is not a GUI event).
    1:    */
    1:   static nsPoint GetDOMEventCoordinatesRelativeTo(nsIDOMEvent* aDOMEvent,
    1:                                                   nsIFrame* aFrame);
    1: 
    1:   /**
    1:    * Get the coordinates of a given native mouse event, relative to a given
    1:    * frame.
    1:    * @param aEvent the event
    1:    * @param aFrame the frame to make coordinates relative to
    1:    * @return the point, or (NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE) if
    1:    * for some reason the coordinates for the mouse are not known (e.g.,
    1:    * the event is not a GUI event).
    1:    */
 2817:   static nsPoint GetEventCoordinatesRelativeTo(const nsEvent* aEvent,
    1:                                                nsIFrame* aFrame);
    1: 
    1: /**
    1:    * Get the coordinates of a given native mouse event, relative to the nearest 
    1:    * view for a given frame.
    1:    * The "nearest view" is the view returned by nsFrame::GetOffsetFromView.
    1:    * XXX this is extremely BOGUS because "nearest view" is a mess; every
    1:    * use of this method is really a bug!
    1:    * @param aEvent the event
    1:    * @param aFrame the frame to make coordinates relative to
    1:    * @param aView  view to which returned coordinates are relative 
    1:    * @return the point, or (NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE) if
    1:    * for some reason the coordinates for the mouse are not known (e.g.,
    1:    * the event is not a GUI event).
    1:    */
    1:   static nsPoint GetEventCoordinatesForNearestView(nsEvent* aEvent,
    1:                                                    nsIFrame* aFrame,
    1:                                                    nsIView** aView = nsnull);
    1: 
    1: /**
    1:    * Translate from widget coordinates to the view's coordinates
    1:    * @param aPresContext the PresContext for the view
    1:    * @param aWidget the widget
    1:    * @param aPt the point relative to the widget
    1:    * @param aView  view to which returned coordinates are relative
    1:    * @return the point in the view's coordinates
    1:    */
    1:   static nsPoint TranslateWidgetToView(nsPresContext* aPresContext, 
    1:                                        nsIWidget* aWidget, nsIntPoint aPt,
    1:                                        nsIView* aView);
    1: 
    1:   /**
19214:    * Given a matrix and a point, let T be the transformation matrix translating points
19214:    * in the coordinate space with origin aOrigin to the coordinate space used by the
19214:    * matrix.  If M is the stored matrix, this function returns (T-1)MT, the matrix
19214:    * that's equivalent to aMatrix but in the coordinate space that treats aOrigin
19214:    * as the origin.
19214:    *
19214:    * @param aOrigin The origin to translate to.
19214:    * @param aMatrix The matrix to change the basis of.
19214:    * @return A matrix equivalent to aMatrix, but operating in the coordinate system with
19214:    *         origin aOrigin.
19214:    */
19214:   static gfxMatrix ChangeMatrixBasis(const gfxPoint &aOrigin, const gfxMatrix &aMatrix);
19214: 
19214:   /**
    1:    * Given aFrame, the root frame of a stacking context, find its descendant
    1:    * frame under the point aPt that receives a mouse event at that location,
    1:    * or nsnull if there is no such frame.
    1:    * @param aPt the point, relative to the frame origin
 5440:    * @param aShouldIgnoreSuppression a boolean to control if the display
 5440:    * list builder should ignore paint suppression or not
22095:    * @param aIgnoreRootScrollFrame whether or not the display list builder
22095:    * should ignore the root scroll frame.
    1:    */
 5440:   static nsIFrame* GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt,
20863:                                     PRBool aShouldIgnoreSuppression = PR_FALSE,
22095:                                     PRBool aIgnoreRootScrollFrame = PR_FALSE);
    1: 
    1:   /**
19214:    * Given a point in the global coordinate space, returns that point expressed
19214:    * in the coordinate system of aFrame.  This effectively inverts all transforms
19214:    * between this point and the root frame.
19214:    *
19214:    * @param aFrame The frame that acts as the coordinate space container.
19214:    * @param aPoint The point, in the global space, to get in the frame-local space.
19214:    * @return aPoint, expressed in aFrame's canonical coordinate space.
19214:    */
19214:   static nsPoint InvertTransformsToRoot(nsIFrame* aFrame,
19214:                                         const nsPoint &aPt);
19214: 
19214: 
19214:   /**
19214:    * Helper function that, given a rectangle and a matrix, returns the smallest
19214:    * rectangle containing the image of the source rectangle.
19214:    *
19214:    * @param aBounds The rectangle to transform.
19214:    * @param aMatrix The matrix to transform it with.
19214:    * @param aFactor The number of app units per graphics unit.
19214:    * @return The smallest rect that contains the image of aBounds.
19214:    */
19214:   static nsRect MatrixTransformRect(const nsRect &aBounds,
19214:                                     const gfxMatrix &aMatrix, float aFactor);
19214: 
19214:   /**
19214:    * Helper function that, given a point and a matrix, returns the image
19214:    * of that point under the matrix transform.
19214:    *
19214:    * @param aPoint The point to transform.
19214:    * @param aMatrix The matrix to transform it with.
19214:    * @param aFactor The number of app units per graphics unit.
19214:    * @return The image of the point under the transform.
19214:    */
19214:   static nsPoint MatrixTransformPoint(const nsPoint &aPoint,
19214:                                       const gfxMatrix &aMatrix, float aFactor);
19214: 
19214:   /**
19214:    * Given a graphics rectangle in graphics space, return a rectangle in
19214:    * app space that contains the graphics rectangle, rounding out as necessary.
19214:    *
19214:    * @param aRect The graphics rect to round outward.
19214:    * @param aFactor The number of app units per graphics unit.
19214:    * @return The smallest rectangle in app space that contains aRect.
19214:    */
19214:   static nsRect RoundGfxRectToAppRect(const gfxRect &aRect, float aFactor);
19214: 
19214: 
19214:   /**
    1:    * Given aFrame, the root frame of a stacking context, paint it and its
    1:    * descendants to aRenderingContext. 
    1:    * @param aRenderingContext a rendering context translated so that (0,0)
12189:    * is the origin of aFrame; for best results, (0,0) should transform
12189:    * to pixel-aligned coordinates
    1:    * @param aDirtyRegion the region that must be painted, in the coordinates
    1:    * of aFrame
    1:    * @param aBackground paint the dirty area with this color before drawing
    1:    * the actual content; pass NS_RGBA(0,0,0,0) to draw no background
    1:    */
    1:   static nsresult PaintFrame(nsIRenderingContext* aRenderingContext, nsIFrame* aFrame,
    1:                              const nsRegion& aDirtyRegion, nscolor aBackground);
    1: 
    1:   /**
    1:    * @param aRootFrame the root frame of the tree to be displayed
    1:    * @param aMovingFrame a frame that has moved
    1:    * @param aPt the amount by which aMovingFrame has moved and the rect will
    1:    * be copied
    1:    * @param aCopyRect a rectangle that will be copied, relative to aRootFrame
    1:    * @param aRepaintRegion a subregion of aCopyRect+aDelta that must be repainted
    1:    * after doing the bitblt
    1:    * 
    1:    * Ideally this function would actually have the rect-to-copy as an output
    1:    * rather than an input, but for now, scroll bitblitting is limited to
    1:    * the whole of a single widget, so we cannot choose the rect.
    1:    * 
    1:    * This function assumes that the caller will do a bitblt copy of aCopyRect
    1:    * to aCopyRect+aPt. It computes a region that must be repainted in order
14202:    * for the resulting rendering to be correct. Frame geometry must have
14202:    * already been adjusted for the scroll/copy operation.
    1:    * 
14202:    * Conceptually it works by computing a display list in the before-state
14202:    * and a display list in the after-state and analyzing them to find the
14202:    * differences. In practice it is only feasible to build a display list
14202:    * in the after-state (plus building two display lists would be less
14202:    * efficient), so we use some unfortunately tricky techniques to get by
14202:    * with just the after-list.
14202:    * 
14202:    * The output region consists of:
    1:    * a) any visible background-attachment:fixed areas in the after-move display
    1:    * list
    1:    * b) any visible areas of the before-move display list corresponding to
    1:    * frames that will not move (translated by aDelta)
    1:    * c) any visible areas of the after-move display list corresponding to
    1:    * frames that did not move
    1:    * d) except that if the same display list element is visible in b) and c)
    1:    * for a frame that did not move and paints a uniform color within its
    1:    * bounds, then the intersection of its old and new bounds can be excluded
    1:    * when it is processed by b) and c).
    1:    * 
    1:    * We may return a larger region if computing the above region precisely is
    1:    * too expensive.
    1:    */
    1:   static nsresult ComputeRepaintRegionForCopy(nsIFrame* aRootFrame,
    1:                                               nsIFrame* aMovingFrame,
    1:                                               nsPoint aDelta,
    1:                                               const nsRect& aCopyRect,
    1:                                               nsRegion* aRepaintRegion);
    1: 
    1:   /**
    1:    * Compute the used z-index of aFrame; returns zero for elements to which
    1:    * z-index does not apply, and for z-index:auto
    1:    */
    1:   static PRInt32 GetZIndex(nsIFrame* aFrame);
    1: 
    1:   /**
    1:    * Uses a binary search for find where the cursor falls in the line of text
    1:    * It also keeps track of the part of the string that has already been measured
    1:    * so it doesn't have to keep measuring the same text over and over
    1:    *
    1:    * @param "aBaseWidth" contains the width in twips of the portion 
    1:    * of the text that has already been measured, and aBaseInx contains
    1:    * the index of the text that has already been measured.
    1:    *
    1:    * @param aTextWidth returns the (in twips) the length of the text that falls
    1:    * before the cursor aIndex contains the index of the text where the cursor falls
    1:    */
    1:   static PRBool
    1:   BinarySearchForPosition(nsIRenderingContext* acx, 
    1:                           const PRUnichar* aText,
    1:                           PRInt32    aBaseWidth,
    1:                           PRInt32    aBaseInx,
    1:                           PRInt32    aStartInx, 
    1:                           PRInt32    aEndInx, 
    1:                           PRInt32    aCursorPos, 
    1:                           PRInt32&   aIndex,
    1:                           PRInt32&   aTextWidth);
    1: 
19125:   class BoxCallback {
19125:   public:
19125:     virtual void AddBox(nsIFrame* aFrame) = 0;
19125:   };
19125:   /**
19125:    * Collect all CSS boxes associated with aFrame and its
19125:    * continuations, "drilling down" through outer table frames and
19125:    * some anonymous blocks since they're not real CSS boxes.
19125:    * If aFrame is null, no boxes are returned.
19125:    * SVG frames return a single box, themselves.
19125:    */
19125:   static void GetAllInFlowBoxes(nsIFrame* aFrame, BoxCallback* aCallback);
19125: 
12349:   class RectCallback {
12349:   public:
12349:     virtual void AddRect(const nsRect& aRect) = 0;
12349:   };
    1:   /**
12349:    * Collect all CSS border-boxes associated with aFrame and its
12349:    * continuations, "drilling down" through outer table frames and
12349:    * some anonymous blocks since they're not real CSS boxes.
12349:    * The boxes are positioned relative to aRelativeTo (taking scrolling
12349:    * into account) and passed to the callback in frame-tree order.
12349:    * If aFrame is null, no boxes are returned.
12349:    * For SVG frames, returns one rectangle, the bounding box.
    1:    */
12349:   static void GetAllInFlowRects(nsIFrame* aFrame, nsIFrame* aRelativeTo,
12349:                                 RectCallback* aCallback);
12349: 
12349:   /**
12349:    * Computes the union of all rects returned by GetAllInFlowRects. If
12349:    * the union is empty, returns the first rect.
12349:    */
12349:   static nsRect GetAllInFlowRectsUnion(nsIFrame* aFrame, nsIFrame* aRelativeTo);
    1: 
    1:   /**
15339:    * Takes a text-shadow array from the style properties of a given nsIFrame and
15339:    * computes the union of those shadows along with the given initial rect.
15339:    * If there are no shadows, the initial rect is returned.
15339:    */
15339:   static nsRect GetTextShadowRectsUnion(const nsRect& aTextAndDecorationsRect,
15339:                                         nsIFrame* aFrame);
15339: 
15339:   /**
    1:    * Get the font metrics corresponding to the frame's style data.
    1:    * @param aFrame the frame
    1:    * @param aFontMetrics the font metrics result
    1:    * @return success or failure code
    1:    */
    1:   static nsresult GetFontMetricsForFrame(nsIFrame* aFrame,
    1:                                          nsIFontMetrics** aFontMetrics);
    1: 
    1:   /**
 4353:    * Get the font metrics corresponding to the given style data.
 4353:    * @param aStyleContext the style data
 4353:    * @param aFontMetrics the font metrics result
 4353:    * @return success or failure code
 4353:    */
 4353:   static nsresult GetFontMetricsForStyleContext(nsStyleContext* aStyleContext,
 4353:                                                 nsIFontMetrics** aFontMetrics);
 4353: 
 4353:   /**
    1:    * Find the immediate child of aParent whose frame subtree contains
    1:    * aDescendantFrame. Returns null if aDescendantFrame is not a descendant
    1:    * of aParent.
    1:    */
    1:   static nsIFrame* FindChildContainingDescendant(nsIFrame* aParent, nsIFrame* aDescendantFrame);
    1:   
    1:   /**
    1:    * Find the nearest ancestor that's a block
    1:    */
    1:   static nsBlockFrame* FindNearestBlockAncestor(nsIFrame* aFrame);
    1: 
    1:   /**
21943:    * Find the nearest ancestor that's not for generated content. Will return
21943:    * aFrame if aFrame is not for generated content.
21943:    */
21943:   static nsIFrame* GetNonGeneratedAncestor(nsIFrame* aFrame);
21943: 
21943:   /**
 9572:    * Cast aFrame to an nsBlockFrame* or return null if it's not
 9572:    * an nsBlockFrame.
 9572:    */
 9572:   static nsBlockFrame* GetAsBlock(nsIFrame* aFrame);
 9572:   
 9572:   /**
    1:    * If aFrame is an out of flow frame, return its placeholder, otherwise
    1:    * return its parent.
    1:    */
    1:   static nsIFrame* GetParentOrPlaceholderFor(nsFrameManager* aFrameManager,
    1:                                              nsIFrame* aFrame);
    1: 
    1:   /**
    1:    * Find the closest common ancestor of aFrame1 and aFrame2, following
    1:    * out of flow frames to their placeholders instead of their parents. Returns
    1:    * nsnull if the frames are in different frame trees.
    1:    * 
    1:    * @param aKnownCommonAncestorHint a frame that is believed to be on the
    1:    * ancestor chain of both aFrame1 and aFrame2. If null, or a frame that is
    1:    * not in fact on both ancestor chains, then this function will still return
    1:    * the correct result, but it will be slower.
    1:    */
    1:   static nsIFrame*
    1:   GetClosestCommonAncestorViaPlaceholders(nsIFrame* aFrame1, nsIFrame* aFrame2,
    1:                                           nsIFrame* aKnownCommonAncestorHint);
    1: 
    1:   /**
   94:    * Get a frame's next-in-flow, or, if it doesn't have one, its special sibling.
   94:    */
   94:   static nsIFrame*
   94:   GetNextContinuationOrSpecialSibling(nsIFrame *aFrame);
   94: 
   94:   /**
19125:    * Get the first frame in the continuation-plus-special-sibling chain
19125:    * containing aFrame.
19125:    */
19125:   static nsIFrame*
19125:   GetFirstContinuationOrSpecialSibling(nsIFrame *aFrame);
19125:   
19125:   /**
    1:    * Check whether aFrame is a part of the scrollbar or scrollcorner of
    1:    * the root content.
    1:    * @param aFrame the checking frame
    1:    * @return if TRUE, the frame is a part of the scrollbar or scrollcorner of
    1:    *         the root content.
    1:    */
    1:   static PRBool IsViewportScrollbarFrame(nsIFrame* aFrame);
    1: 
    1:   /**
    1:    * Get the contribution of aFrame to its containing block's intrinsic
    1:    * width.  This considers the child's intrinsic width, its 'width',
    1:    * 'min-width', and 'max-width' properties, and its padding, border,
    1:    * and margin.
    1:    */
    1:   enum IntrinsicWidthType { MIN_WIDTH, PREF_WIDTH };
    1:   static nscoord IntrinsicForContainer(nsIRenderingContext* aRenderingContext,
    1:                                        nsIFrame* aFrame,
    1:                                        IntrinsicWidthType aType);
    1: 
 1068:   /*
 1068:    * Convert nsStyleCoord to nscoord when percentages depend on the
 1068:    * containing block width.
 1068:    */
    1:   static nscoord ComputeWidthDependentValue(
    1:                    nscoord              aContainingBlockWidth,
    1:                    const nsStyleCoord&  aCoord);
    1: 
 1068:   /*
 1068:    * Convert nsStyleCoord to nscoord when percentages depend on the
 1068:    * containing block width, and enumerated values are for width,
 1068:    * min-width, or max-width.  Returns the content-box width value based
 1068:    * on aContentEdgeToBoxSizing and aBoxSizingToMarginEdge (which are
 1068:    * also used for the enumerated values for width.  This function does
 1068:    * not handle 'auto'.  It ensures that the result is nonnegative.
 1068:    *
 1068:    * @param aRenderingContext Rendering context for font measurement/metrics.
 1068:    * @param aFrame Frame whose (min-/max-/)width is being computed
 1068:    * @param aContainingBlockWidth Width of aFrame's containing block.
 1068:    * @param aContentEdgeToBoxSizing The sum of any left/right padding and
 1068:    *          border that goes inside the rect chosen by -moz-box-sizing.
 1068:    * @param aBoxSizingToMarginEdge The sum of any left/right padding, border,
 1068:    *          and margin that goes outside the rect chosen by -moz-box-sizing.
 1068:    * @param aCoord The width value to compute.
 1068:    */
 1068:   static nscoord ComputeWidthValue(
 1068:                    nsIRenderingContext* aRenderingContext,
 1068:                    nsIFrame*            aFrame,
 1068:                    nscoord              aContainingBlockWidth,
 1068:                    nscoord              aContentEdgeToBoxSizing,
 1068:                    nscoord              aBoxSizingToMarginEdge,
 1068:                    const nsStyleCoord&  aCoord);
 1068: 
 1068:   /*
 1068:    * Convert nsStyleCoord to nscoord when percentages depend on the
 1068:    * containing block height.
 1068:    */
    1:   static nscoord ComputeHeightDependentValue(
    1:                    nscoord              aContainingBlockHeight,
    1:                    const nsStyleCoord&  aCoord);
    1: 
 8142:   /*
 8142:    * Calculate the used values for 'width' and 'height' for a replaced element.
 8142:    *
 8142:    *   http://www.w3.org/TR/CSS21/visudet.html#min-max-widths
 8142:    */
    1:   static nsSize ComputeSizeWithIntrinsicDimensions(
 8142:                     nsIRenderingContext* aRenderingContext, nsIFrame* aFrame,
 8147:                     const nsIFrame::IntrinsicSize& aIntrinsicSize,
 8142:                     nsSize aIntrinsicRatio, nsSize aCBSize,
 1068:                     nsSize aMargin, nsSize aBorder, nsSize aPadding);
    1: 
    1:   // Implement nsIFrame::GetPrefWidth in terms of nsIFrame::AddInlinePrefWidth
    1:   static nscoord PrefWidthFromInline(nsIFrame* aFrame,
    1:                                      nsIRenderingContext* aRenderingContext);
    1: 
    1:   // Implement nsIFrame::GetMinWidth in terms of nsIFrame::AddInlineMinWidth
    1:   static nscoord MinWidthFromInline(nsIFrame* aFrame,
    1:                                     nsIRenderingContext* aRenderingContext);
    1: 
    1:   static void DrawString(const nsIFrame*      aFrame,
    1:                          nsIRenderingContext* aContext,
    1:                          const PRUnichar*     aString,
    1:                          PRInt32              aLength,
24995:                          nsPoint              aPoint,
24995:                          PRUint8              aDirection = NS_STYLE_DIRECTION_INHERIT);
    1: 
    1:   static nscoord GetStringWidth(const nsIFrame*      aFrame,
    1:                                 nsIRenderingContext* aContext,
    1:                                 const PRUnichar*     aString,
    1:                                 PRInt32              aLength);
    1: 
    1:   /**
    1:    * Derive a baseline of |aFrame| (measured from its top border edge)
    1:    * from its first in-flow line box (not descending into anything with
    1:    * 'overflow' not 'visible', potentially including aFrame itself).
    1:    *
    1:    * Returns true if a baseline was found (and fills in aResult).
    1:    * Otherwise returns false.
    1:    */
    1:   static PRBool GetFirstLineBaseline(const nsIFrame* aFrame, nscoord* aResult);
    1: 
    1:   /**
    1:    * Derive a baseline of |aFrame| (measured from its top border edge)
    1:    * from its last in-flow line box (not descending into anything with
    1:    * 'overflow' not 'visible', potentially including aFrame itself).
    1:    *
    1:    * Returns true if a baseline was found (and fills in aResult).
    1:    * Otherwise returns false.
    1:    */
    1:   static PRBool GetLastLineBaseline(const nsIFrame* aFrame, nscoord* aResult);
    1: 
    1:   /**
14460:    * Returns a y coordinate relative to this frame's origin that represents
14460:    * the logical bottom of the frame or its visible content, whichever is lower.
14460:    * Relative positioning is ignored and margins and glyph bounds are not
14460:    * considered.
14460:    * This value will be >= mRect.height() and <= overflowRect.YMost() unless
14460:    * relative positioning is applied.
14460:    */
14460:   static nscoord CalculateContentBottom(nsIFrame* aFrame);
14460: 
14460:   /**
    1:    * Gets the closest frame (the frame passed in or one of its parents) that
    1:    * qualifies as a "layer"; used in DOM0 methods that depends upon that
    1:    * definition. This is the nearest frame that is either positioned or scrolled
    1:    * (the child of a scroll frame). In Gecko terms, it's approximately
    1:    * equivalent to having a view, at least for simple HTML. However, views are
    1:    * going away, so this is a cleaner definition.
    1:    */
    1:   static nsIFrame* GetClosestLayer(nsIFrame* aFrame);
    1: 
24452:   /* N.B. The only difference between variants of the Draw*Image
24452:    * functions below is the type of the aImage argument.
24452:    */
24452: 
    1:   /**
21323:    * Draw an image.
21323:    * See https://wiki.mozilla.org/Gecko:Image_Snapping_and_Rendering
    1:    *   @param aRenderingContext Where to draw the image, set up with an
    1:    *                            appropriate scale and transform for drawing in
21323:    *                            app units.
 5147:    *   @param aImage            The image.
21323:    *   @param aDest             Where one copy of the image should mapped to.
21323:    *   @param aFill             The area to be filled with copies of the
21323:    *                            image.
21323:    *   @param aAnchor           A point in aFill which we will ensure is
21323:    *                            pixel-aligned in the output.
21323:    *   @param aDirty            Pixels outside this area may be skipped.
    1:    */
    1:   static nsresult DrawImage(nsIRenderingContext* aRenderingContext,
    1:                             imgIContainer*       aImage,
21323:                             const nsRect&        aDest,
21323:                             const nsRect&        aFill,
21323:                             const nsPoint&       aAnchor,
21323:                             const nsRect&        aDirty);
21323: 
24452:   static nsresult DrawImage(nsIRenderingContext* aRenderingContext,
24452:                             nsIImage*            aImage,
24452:                             const nsRect&        aDest,
24452:                             const nsRect&        aFill,
24452:                             const nsPoint&       aAnchor,
24452:                             const nsRect&        aDirty);
24452: 
21323:   /**
21323:    * Draw a whole image without scaling or tiling.
21323:    *
21323:    *   @param aRenderingContext Where to draw the image, set up with an
21323:    *                            appropriate scale and transform for drawing in
21323:    *                            app units.
21323:    *   @param aImage            The image.
21323:    *   @param aDest             The top-left where the image should be drawn
21323:    *   @param aDirty            Pixels outside this area may be skipped.
21323:    *   @param aSourceArea       If non-null, this area is extracted from
21323:    *                            the image and drawn at aDest. It's
21323:    *                            in appunits. For best results it should
21323:    *                            be aligned with image pixels.
21323:    */
21323:   static nsresult DrawSingleUnscaledImage(nsIRenderingContext* aRenderingContext,
21323:                                           imgIContainer*       aImage,
21323:                                           const nsPoint&       aDest,
21323:                                           const nsRect&        aDirty,
21323:                                           const nsRect*        aSourceArea = nsnull);
21323: 
21323:   /**
21323:    * Draw a whole image without tiling.
21323:    *
21323:    *   @param aRenderingContext Where to draw the image, set up with an
21323:    *                            appropriate scale and transform for drawing in
21323:    *                            app units.
21323:    *   @param aImage            The image.
21323:    *   @param aDest             The area that the image should fill
21323:    *   @param aDirty            Pixels outside this area may be skipped.
21323:    *   @param aSourceArea       If non-null, this area is extracted from
21323:    *                            the image and drawn in aDest. It's
21323:    *                            in appunits. For best results it should
21323:    *                            be aligned with image pixels.
21323:    */
21323:   static nsresult DrawSingleImage(nsIRenderingContext* aRenderingContext,
21323:                                   imgIContainer*       aImage,
21323:                                   const nsRect&        aDest,
21323:                                   const nsRect&        aDirty,
21323:                                   const nsRect*        aSourceArea = nsnull);
21323: 
24452:   static nsresult DrawSingleImage(nsIRenderingContext* aRenderingContext,
24452:                                   nsIImage*            aImage,
24452:                                   const nsRect&        aDest,
24452:                                   const nsRect&        aDirty,
24452:                                   const nsRect*        aSourceArea = nsnull);
24452: 
21323:   /**
21323:    * Given a source area of an image (in appunits) and a destination area
21323:    * that we want to map that source area too, computes the area that
21323:    * would be covered by the whole image. This is useful for passing to
21323:    * the aDest parameter of DrawImage, when we want to draw a subimage
21323:    * of an overall image.
21323:    */
21323:   static nsRect GetWholeImageDestination(const nsIntSize& aWholeImageSize,
21323:                                          const nsRect& aImageSourceArea,
21323:                                          const nsRect& aDestArea);
 1105: 
 1105:   /**
 1105:    * Set the font on aRC based on the style in aSC
 1105:    */
 1105:   static void SetFontFromStyle(nsIRenderingContext* aRC, nsStyleContext* aSC);
 1105: 
 1105:   /**
20039:    * Determine if any corner radius is of nonzero size
20039:    *   @param aCorners the |nsStyleCorners| object to check
 1345:    *   @return PR_TRUE unless all the coordinates are 0%, 0 or null.
20039:    *
20039:    * A corner radius with one dimension zero and one nonzero is
20039:    * treated as a nonzero-radius corner, even though it will end up
20039:    * being rendered like a zero-radius corner.  This is because such
20039:    * corners are not expected to appear outside of test cases, and it's
20039:    * simpler to implement the test this way.
 1345:    */
20039:   static PRBool HasNonZeroCorner(const nsStyleCorners& aCorners);
 1345: 
 1345:   /**
 1345:    * Determine if a widget is likely to require transparency or translucency.
 1345:    *   @param aFrame the frame of a <window>, <popup> or <menupopup> element.
 1345:    *   @return a value suitable for passing to SetWindowTranslucency
 1345:    */
16601:   static nsTransparencyMode GetFrameTransparency(nsIFrame* aFrame);
 4032: 
 4032:   /**
 4032:    * Get textrun construction flags determined by a given style; in particular
 4032:    * some combination of:
 4032:    * -- TEXT_DISABLE_OPTIONAL_LIGATURES if letter-spacing is in use
 4032:    * -- TEXT_OPTIMIZE_SPEED if the text-rendering CSS property and font size
 4032:    * and prefs indicate we should be optimizing for speed over quality
 4032:    */
 4032:   static PRUint32 GetTextRunFlagsForStyle(nsStyleContext* aStyleContext,
 4032:                                           const nsStyleText* aStyleText,
 4032:                                           const nsStyleFont* aStyleFont);
11016: 
11016:   /**
11384:    * Takes two rectangles whose origins must be the same, and computes
11384:    * the difference between their union and their intersection as two
11384:    * rectangles. (This difference is a superset of the difference
11384:    * between the two rectangles.)
11384:    */
11384:   static void GetRectDifferenceStrips(const nsRect& aR1, const nsRect& aR2,
11384:                                       nsRect* aHStrip, nsRect* aVStrip);
11384: 
11384:   /**
16228:    * Get a device context that can be used to get up-to-date device
16228:    * dimensions for the given docshell.  For some reason, this is more
16228:    * complicated than it ought to be in multi-monitor situations.
16228:    */
16228:   static nsIDeviceContext*
16228:   GetDeviceContextForScreenInfo(nsIDocShell* aDocShell);
16228: 
16228:   /**
21903:    * Some frames with 'position: fixed' (nsStylePosition::mDisplay ==
21903:    * NS_STYLE_POSITION_FIXED) are not really fixed positioned, since
21903:    * they're inside an element with -moz-transform.  This function says
21903:    * whether such an element is a real fixed-pos element.
21903:    */
21903:   static PRBool IsReallyFixedPos(nsIFrame* aFrame);
21903: 
21903:   /**
11016:    * Indicates if the nsIFrame::GetUsedXXX assertions in nsFrame.cpp should
11016:    * disabled.
11016:    */
11016:   static PRBool sDisableGetUsedXAssertions;
25840: 
25840:   /**
26295:    * Returns the text fragment, which aFrame should use for printing.
26295:    * @param aFrame The nsIFrame object, which uses text fragment data.
25840:    */
26295:   static nsTextFragment* GetTextFragmentForPrinting(const nsIFrame* aFrame);
11016: };
11016: 
11016: class nsAutoDisableGetUsedXAssertions
11016: {
11016: public:
11016:   nsAutoDisableGetUsedXAssertions()
11016:     : mOldValue(nsLayoutUtils::sDisableGetUsedXAssertions)
11016:   {
11016:     nsLayoutUtils::sDisableGetUsedXAssertions = PR_TRUE;
11016:   }
11016:   ~nsAutoDisableGetUsedXAssertions()
11016:   {
11016:     nsLayoutUtils::sDisableGetUsedXAssertions = mOldValue;
11016:   }
11016: 
11016: private:
11016:   PRBool mOldValue;
    1: };
    1: 
14319: class nsSetAttrRunnable : public nsRunnable
14319: {
14319: public:
14319:   nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
14319:                     const nsAString& aValue);
14319: 
14319:   NS_DECL_NSIRUNNABLE
14319: 
14319:   nsCOMPtr<nsIContent> mContent;
14319:   nsCOMPtr<nsIAtom> mAttrName;
14319:   nsAutoString mValue;
14319: };
14319: 
14319: class nsUnsetAttrRunnable : public nsRunnable
14319: {
14319: public:
14319:   nsUnsetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName);
14319: 
14319:   NS_DECL_NSIRUNNABLE
14319: 
14319:   nsCOMPtr<nsIContent> mContent;
14319:   nsCOMPtr<nsIAtom> mAttrName;
14319: };
14319: 
23933: class nsReflowFrameRunnable : public nsRunnable
23933: {
23933: public:
23933:   nsReflowFrameRunnable(nsIFrame* aFrame,
23933:                         nsIPresShell::IntrinsicDirty aIntrinsicDirty,
23933:                         nsFrameState aBitToAdd);
23933: 
23933:   NS_DECL_NSIRUNNABLE
23933: 
23933:   nsWeakFrame mWeakFrame;
23933:   nsIPresShell::IntrinsicDirty mIntrinsicDirty;
23933:   nsFrameState mBitToAdd;
23933: };
23933: 
    1: #endif // nsLayoutUtils_h__
