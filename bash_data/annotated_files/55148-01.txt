29805: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
29805: /* vim: set sw=2 ts=2 et tw=79: */
29805: /* ***** BEGIN LICENSE BLOCK *****
29805:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
29805:  *
29805:  * The contents of this file are subject to the Mozilla Public License Version
29805:  * 1.1 (the "License"); you may not use this file except in compliance with
29805:  * the License. You may obtain a copy of the License at
29805:  * http://www.mozilla.org/MPL/
29805:  *
29805:  * Software distributed under the License is distributed on an "AS IS" basis,
29805:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
29805:  * for the specific language governing rights and limitations under the
29805:  * License.
29805:  *
29805:  * The Original Code is mozilla.org code.
29805:  *
29805:  * The Initial Developer of the Original Code is
29805:  * Netscape Communications Corporation.
29805:  * Portions created by the Initial Developer are Copyright (C) 1998
29805:  * the Initial Developer. All Rights Reserved.
29805:  *
29805:  * Contributor(s):
29805:  *   Pierre Phaneuf <pp@ludusdesign.com>
29805:  *   Henri Sivonen <hsivonen@iki.fi>
29805:  *
29805:  * Alternatively, the contents of this file may be used under the terms of
29805:  * either of the GNU General Public License Version 2 or later (the "GPL"),
29805:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
29805:  * in which case the provisions of the GPL or the LGPL are applicable instead
29805:  * of those above. If you wish to allow use of your version of this file only
29805:  * under the terms of either the GPL or the LGPL, and not to allow others to
29805:  * use your version of this file under the terms of the MPL, indicate your
29805:  * decision by deleting the provisions above and replace them with the notice
29805:  * and other provisions required by the GPL or the LGPL. If you do not delete
29805:  * the provisions above, a recipient may use your version of this file under
29805:  * the terms of any one of the MPL, the GPL or the LGPL.
29805:  *
29805:  * ***** END LICENSE BLOCK ***** */
29805: 
29805: #include "nsCompatibility.h"
29805: #include "nsScriptLoader.h"
29805: #include "nsNetUtil.h"
29805: #include "nsIStyleSheetLinkingElement.h"
29805: #include "nsICharsetAlias.h"
29805: #include "nsIWebShellServices.h"
29805: #include "nsIDocShell.h"
29805: #include "nsEncoderDecoderUtils.h"
29805: #include "nsContentUtils.h"
29805: #include "nsICharsetDetector.h"
29805: #include "nsIScriptElement.h"
29805: #include "nsIMarkupDocumentViewer.h"
29805: #include "nsIDocShellTreeItem.h"
29805: #include "nsIContentViewer.h"
29805: #include "nsIScriptGlobalObjectOwner.h"
29805: #include "nsIScriptSecurityManager.h"
29805: #include "nsHtml5DocumentMode.h"
29805: #include "nsHtml5Tokenizer.h"
29805: #include "nsHtml5UTF16Buffer.h"
29805: #include "nsHtml5TreeBuilder.h"
29805: #include "nsHtml5Parser.h"
34978: #include "nsHtml5AtomTable.h"
29805: 
32917: NS_INTERFACE_TABLE_HEAD(nsHtml5Parser)
34983:   NS_INTERFACE_TABLE2(nsHtml5Parser, nsIParser, nsISupportsWeakReference)
32917:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsHtml5Parser)
32917: NS_INTERFACE_MAP_END
32917: 
32917: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsHtml5Parser)
32917: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsHtml5Parser)
32917: 
29805: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHtml5Parser)
29805: 
32917: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsHtml5Parser)
40983:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mExecutor,
40983:                                                        nsIContentSink)
40983:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mStreamParser,
40983:                                                        nsIStreamListener)
29805: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
29805: 
32917: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsHtml5Parser)
32917:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mExecutor)
41396:   tmp->DropStreamParser();
29805: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
29805: 
29805: nsHtml5Parser::nsHtml5Parser()
32917:   : mFirstBuffer(new nsHtml5UTF16Buffer(0))
32917:   , mLastBuffer(mFirstBuffer)
32917:   , mExecutor(new nsHtml5TreeOpExecutor())
38132:   , mTreeBuilder(new nsHtml5TreeBuilder(mExecutor, nsnull))
32917:   , mTokenizer(new nsHtml5Tokenizer(mTreeBuilder))
35294:   , mRootContextLineNumber(1)
29805: {
34979:   mAtomTable.Init(); // we aren't checking for OOM anyway...
34979:   mTokenizer->setInterner(&mAtomTable);
29805:   // There's a zeroing operator new for everything else
29805: }
29805: 
29805: nsHtml5Parser::~nsHtml5Parser()
29805: {
34979:   mTokenizer->end();
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::SetContentSink(nsIContentSink* aSink)
29805: {
32917:   NS_ASSERTION(aSink == static_cast<nsIContentSink*> (mExecutor), 
30334:                "Attempt to set a foreign sink.");
29805: }
29805: 
29805: NS_IMETHODIMP_(nsIContentSink*)
40983: nsHtml5Parser::GetContentSink()
29805: {
32917:   return static_cast<nsIContentSink*> (mExecutor);
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::GetCommand(nsCString& aCommand)
29805: {
29805:   aCommand.Assign("view");
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::SetCommand(const char* aCommand)
29805: {
29805:   NS_ASSERTION(!strcmp(aCommand, "view"), "Parser command was not view");
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::SetCommand(eParserCommands aParserCommand)
29805: {
30334:   NS_ASSERTION(aParserCommand == eViewNormal, 
30334:                "Parser command was not eViewNormal.");
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
40983: nsHtml5Parser::SetDocumentCharset(const nsACString& aCharset,
40983:                                   PRInt32 aCharsetSource)
29805: {
34981:   NS_PRECONDITION(!mExecutor->HasStarted(),
32917:                   "Document charset set too late.");
40983:   NS_PRECONDITION(mStreamParser, "Setting charset on a script-only parser.");
32917:   mStreamParser->SetDocumentCharset(aCharset, aCharsetSource);
40983:   mExecutor->SetDocumentCharsetAndSource((nsACString&)aCharset,
40983:                                          aCharsetSource);
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::SetParserFilter(nsIParserFilter* aFilter)
29805: {
29805:   NS_ERROR("Attempt to set a parser filter on HTML5 parser.");
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::GetChannel(nsIChannel** aChannel)
29805: {
32917:   if (mStreamParser) {
32917:     return mStreamParser->GetChannel(aChannel);
32917:   } else {
32917:     return NS_ERROR_NOT_AVAILABLE;
32917:   }
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::GetDTD(nsIDTD** aDTD)
29805: {
29805:   *aDTD = nsnull;
29805:   return NS_OK;
29805: }
29805: 
29805: NS_IMETHODIMP
32917: nsHtml5Parser::GetStreamListener(nsIStreamListener** aListener)
32917: {
34983:   NS_IF_ADDREF(*aListener = mStreamParser);
32917:   return NS_OK;
32917: }
32917: 
32917: NS_IMETHODIMP
29805: nsHtml5Parser::ContinueInterruptedParsing()
29805: {
39737:   NS_NOTREACHED("Don't call. For interface compat only.");
39737:   return NS_ERROR_NOT_IMPLEMENTED;
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::BlockParser()
29805: {
32917:   mBlocked = PR_TRUE;
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::UnblockParser()
29805: {
29805:   mBlocked = PR_FALSE;
29805: }
29805: 
29805: NS_IMETHODIMP_(PRBool)
29805: nsHtml5Parser::IsParserEnabled()
29805: {
29805:   return !mBlocked;
29805: }
29805: 
29805: NS_IMETHODIMP_(PRBool)
29805: nsHtml5Parser::IsComplete()
29805: {
32917:   return mExecutor->IsComplete();
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::Parse(nsIURI* aURL, // legacy parameter; ignored
29805:                      nsIRequestObserver* aObserver,
29805:                      void* aKey,
29805:                      nsDTDMode aMode) // legacy; ignored
29805: {
32917:   /*
32917:    * Do NOT cause WillBuildModel to be called synchronously from here!
32917:    * The document won't be ready for it until OnStartRequest!
32917:    */
34981:   NS_PRECONDITION(!mExecutor->HasStarted(), 
40983:                   "Tried to start parse without initializing the parser.");
34983:   NS_PRECONDITION(mStreamParser, 
40983:                   "Can't call this Parse() variant on script-created parser");
32917:   mStreamParser->SetObserver(aObserver);
32917:   mExecutor->SetStreamParser(mStreamParser);
32917:   mExecutor->SetParser(this);
29805:   mRootContextKey = aKey;
29805:   return NS_OK;
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::Parse(const nsAString& aSourceBuffer,
29805:                      void* aKey,
29805:                      const nsACString& aContentType, // ignored
29805:                      PRBool aLastCall,
29805:                      nsDTDMode aMode) // ignored
29805: {
40983:   NS_PRECONDITION(!mExecutor->IsFragmentMode(),
40983:                   "Document.write called in fragment mode!");
32917: 
32917:   // Maintain a reference to ourselves so we don't go away
32917:   // till we're completely done. The old parser grips itself in this method.
32917:   nsCOMPtr<nsIParser> kungFuDeathGrip(this);
32917:   
32917:   // Gripping the other objects just in case, since the other old grip
32917:   // required grips to these, too.
32917:   nsRefPtr<nsHtml5StreamParser> streamKungFuDeathGrip(mStreamParser);
32917:   nsRefPtr<nsHtml5TreeOpExecutor> treeOpKungFuDeathGrip(mExecutor);
32917: 
34981:   if (!mExecutor->HasStarted()) {
34979:     NS_ASSERTION(!mStreamParser,
34979:                  "Had stream parser but document.write started life cycle.");
39511:     // This is the first document.write() on a document.open()ed document
32917:     mExecutor->SetParser(this);
32917:     mTreeBuilder->setScriptingEnabled(mExecutor->IsScriptEnabled());
29805:     mTokenizer->start();
34979:     mExecutor->Start();
34979:     /*
34979:      * If you move the following line, be very careful not to cause 
34979:      * WillBuildModel to be called before the document has had its 
34979:      * script global object set.
34979:      */
34979:     mExecutor->WillBuildModel(eDTDMode_unknown);
29805:   }
40983: 
40983:   // Return early if the parser has processed EOF
34981:   if (mExecutor->IsComplete()) {
34981:     return NS_OK;
34981:   }
40983: 
29805:   if (aLastCall && aSourceBuffer.IsEmpty() && aKey == GetRootContextKey()) {
29805:     // document.close()
34979:     NS_ASSERTION(!mStreamParser,
34979:                  "Had stream parser but got document.close().");
34979:     mDocumentClosed = PR_TRUE;
34992:     if (!mBlocked) {
34992:       ParseUntilBlocked();
34992:     }
29805:     return NS_OK;
29805:   }
29805: 
40983:   NS_ASSERTION(IsInsertionPointDefined(),
40983:                "Doc.write reached parser with undefined insertion point.");
34983: 
40983:   NS_ASSERTION(!(mStreamParser && !aKey),
40983:                "Got a null key in a non-script-created parser");
35294: 
34983:   if (aSourceBuffer.IsEmpty()) {
34983:     return NS_OK;
34983:   }
34983: 
40983:   nsRefPtr<nsHtml5UTF16Buffer> buffer =
40983:     new nsHtml5UTF16Buffer(aSourceBuffer.Length());
40983:   memcpy(buffer->getBuffer(),
40983:          aSourceBuffer.BeginReading(),
40983:          aSourceBuffer.Length() * sizeof(PRUnichar));
29805:   buffer->setEnd(aSourceBuffer.Length());
29805: 
34983:   // The buffer is inserted to the stream here in case it won't be parsed
34983:   // to completion.
29805:   // The script is identified by aKey. If there's nothing in the buffer
29805:   // chain for that key, we'll insert at the head of the queue.
29805:   // When the script leaves something in the queue, a zero-length
29805:   // key-holder "buffer" is inserted in the queue. If the same script
29805:   // leaves something in the chain again, it will be inserted immediately
29805:   // before the old key holder belonging to the same script.
29805:   nsHtml5UTF16Buffer* prevSearchBuf = nsnull;
29805:   nsHtml5UTF16Buffer* searchBuf = mFirstBuffer;
40983: 
40983:   // after document.open, the first level of document.write has null key
40983:   if (aKey) {
29805:     while (searchBuf != mLastBuffer) {
29805:       if (searchBuf->key == aKey) {
29805:         // found a key holder
29805:         // now insert the new buffer between the previous buffer
29805:         // and the key holder.
29805:         buffer->next = searchBuf;
29805:         if (prevSearchBuf) {
29805:           prevSearchBuf->next = buffer;
29805:         } else {
29805:           mFirstBuffer = buffer;
29805:         }
29805:         break;
29805:       }
29805:       prevSearchBuf = searchBuf;
29805:       searchBuf = searchBuf->next;
29805:     }
37403:     if (searchBuf == mLastBuffer) {
37403:       // key was not found
29805:       nsHtml5UTF16Buffer* keyHolder = new nsHtml5UTF16Buffer(aKey);
29805:       keyHolder->next = mFirstBuffer;
29805:       buffer->next = keyHolder;
29805:       mFirstBuffer = buffer;
29805:     }
37403:   } else {
37403:     // we have a first level document.write after document.open()
37403:     // insert immediately before mLastBuffer
37403:     while (searchBuf != mLastBuffer) {
37403:       prevSearchBuf = searchBuf;
37403:       searchBuf = searchBuf->next;
37403:     }
37403:     buffer->next = mLastBuffer;
37403:     if (prevSearchBuf) {
37403:       prevSearchBuf->next = buffer;
37403:     } else {
37403:       mFirstBuffer = buffer;
37403:     }
37403:   }
34983: 
40983:   while (!mBlocked && buffer->hasMore()) {
34983:     buffer->adjust(mLastWasCR);
34983:     mLastWasCR = PR_FALSE;
34983:     if (buffer->hasMore()) {
35294:       PRInt32 lineNumberSave;
35294:       PRBool inRootContext = (!mStreamParser && (aKey == mRootContextKey));
35294:       if (inRootContext) {
35294:         mTokenizer->setLineNumber(mRootContextLineNumber);
35294:       } else {
35294:         // we aren't the root context, so save the line number on the
35294:         // *stack* so that we can restore it.
35294:         lineNumberSave = mTokenizer->getLineNumber();
35294:       }
35294: 
34983:       mLastWasCR = mTokenizer->tokenizeBuffer(buffer);
35294: 
35294:       if (inRootContext) {
35294:         mRootContextLineNumber = mTokenizer->getLineNumber();
35294:       } else {
35294:         mTokenizer->setLineNumber(lineNumberSave);
35294:       }
35294: 
34983:       if (mTreeBuilder->HasScript()) {
34983:         mTreeBuilder->Flush(); // Move ops to the executor
39737:         mExecutor->FlushDocumentWrite(); // run the ops
34981:       }
34983:       // Ignore suspension requests
34983:     }
34983:   }
34983: 
34983:   if (!mBlocked) { // buffer was tokenized to completion
35294:     NS_ASSERTION(!buffer->hasMore(), "Buffer wasn't tokenized to completion?");  
34981:     // Scripting semantics require a forced tree builder flush here
34981:     mTreeBuilder->Flush(); // Move ops to the executor
39737:     mExecutor->FlushDocumentWrite(); // run the ops    
29805:   }
29805: 
29805:   return NS_OK;
29805: }
29805: 
29805: /**
29805:  * This magic value is passed to the previous method on document.close()
29805:  */
29805: NS_IMETHODIMP_(void *)
29805: nsHtml5Parser::GetRootContextKey()
29805: {
29805:   return mRootContextKey;
29805: }
29805: 
29805: NS_IMETHODIMP
40983: nsHtml5Parser::Terminate()
29805: {
29805:   // We should only call DidBuildModel once, so don't do anything if this is
29805:   // the second time that Terminate has been called.
34981:   if (mExecutor->IsComplete()) {
29805:     return NS_OK;
29805:   }
29805:   // XXX - [ until we figure out a way to break parser-sink circularity ]
29805:   // Hack - Hold a reference until we are completely done...
29805:   nsCOMPtr<nsIParser> kungFuDeathGrip(this);
32917:   nsRefPtr<nsHtml5StreamParser> streamKungFuDeathGrip(mStreamParser);
32917:   nsRefPtr<nsHtml5TreeOpExecutor> treeOpKungFuDeathGrip(mExecutor);
34979:   if (mStreamParser) {
34979:     mStreamParser->Terminate();
34979:   }
33527:   return mExecutor->DidBuildModel(PR_TRUE);
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::ParseFragment(const nsAString& aSourceBuffer,
29805:                              void* aKey,
29805:                              nsTArray<nsString>& aTagStack,
29805:                              PRBool aXMLMode,
29805:                              const nsACString& aContentType,
29805:                              nsDTDMode aMode)
29805: {
29805:   return NS_ERROR_NOT_IMPLEMENTED;
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::ParseFragment(const nsAString& aSourceBuffer,
48066:                              nsIContent* aTargetNode,
29805:                              nsIAtom* aContextLocalName,
29805:                              PRInt32 aContextNamespace,
29805:                              PRBool aQuirks)
29805: {
48066:   nsIDocument* doc = aTargetNode->GetOwnerDoc();
30333:   NS_ENSURE_TRUE(doc, NS_ERROR_NOT_AVAILABLE);
30333:   
30333:   nsIURI* uri = doc->GetDocumentURI();
30333:   NS_ENSURE_TRUE(uri, NS_ERROR_NOT_AVAILABLE);
30333: 
40983:   Initialize(doc, uri, nsnull, nsnull);
30333: 
32917:   mExecutor->SetParser(this);
40983:   mExecutor->SetNodeInfoManager(doc->NodeInfoManager());
30333: 
48066:   nsIContent* target = aTargetNode;
40983:   mTreeBuilder->setFragmentContext(aContextLocalName,
40983:                                    aContextNamespace,
48066:                                    &target,
40983:                                    aQuirks);
35590:   mExecutor->EnableFragmentMode();
32917:   
40983:   NS_PRECONDITION(!mExecutor->HasStarted(),
40983:                   "Tried to start parse without initializing the parser.");
32917:   mTreeBuilder->setScriptingEnabled(mExecutor->IsScriptEnabled());
29805:   mTokenizer->start();
34979:   mExecutor->Start(); // Don't call WillBuildModel in fragment case
29805:   if (!aSourceBuffer.IsEmpty()) {
29805:     PRBool lastWasCR = PR_FALSE;
29805:     nsHtml5UTF16Buffer buffer(aSourceBuffer.Length());
40983:     memcpy(buffer.getBuffer(),
40983:            aSourceBuffer.BeginReading(),
40983:            aSourceBuffer.Length() * sizeof(PRUnichar));
29805:     buffer.setEnd(aSourceBuffer.Length());
29805:     while (buffer.hasMore()) {
29805:       buffer.adjust(lastWasCR);
29805:       lastWasCR = PR_FALSE;
29805:       if (buffer.hasMore()) {
29805:         lastWasCR = mTokenizer->tokenizeBuffer(&buffer);
29805:       }
29805:     }
29805:   }
29805:   mTokenizer->eof();
34979:   mTreeBuilder->StreamEnded();
34979:   mTreeBuilder->Flush();
39737:   mExecutor->FlushDocumentWrite();
29805:   mTokenizer->end();
32917:   mExecutor->DropParserAndPerfHint();
41067:   mExecutor->DropHeldElements();
34979:   mAtomTable.Clear();
29805:   return NS_OK;
29805: }
29805: 
29805: NS_IMETHODIMP
40983: nsHtml5Parser::BuildModel()
29805: {
34979:   NS_NOTREACHED("Don't call this!");
34979:   return NS_ERROR_NOT_IMPLEMENTED;
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::CancelParsingEvents()
29805: {
35293:   NS_NOTREACHED("Don't call this!");
35293:   return NS_ERROR_NOT_IMPLEMENTED;
29805: }
29805: 
29805: void
29805: nsHtml5Parser::Reset()
29805: {
32917:   mExecutor->Reset();
29805:   mLastWasCR = PR_FALSE;
32917:   UnblockParser();
34979:   mDocumentClosed = PR_FALSE;
32917:   mStreamParser = nsnull;
35294:   mRootContextLineNumber = 1;
34983:   mParserInsertedScriptsBeingEvaluated = 0;
29805:   mRootContextKey = nsnull;
34979:   mAtomTable.Clear(); // should be already cleared in the fragment case anyway
29805:   // Portable parser objects
34981:   mFirstBuffer->next = nsnull;
29805:   mFirstBuffer->setStart(0);
29805:   mFirstBuffer->setEnd(0);
55148:   mLastBuffer = mFirstBuffer;
29805: }
29805: 
29805: PRBool
29805: nsHtml5Parser::CanInterrupt()
29805: {
40983:   // nsContentSink needs this to let nsContentSink::DidProcessATokenImpl
40983:   // interrupt.
40983:   return PR_TRUE;
29805: }
29805: 
34983: PRBool
34983: nsHtml5Parser::IsInsertionPointDefined()
34983: {
34983:   return !mExecutor->IsFlushing() &&
34983:     (!mStreamParser || mParserInsertedScriptsBeingEvaluated);
34983: }
34983: 
34983: void
34983: nsHtml5Parser::BeginEvaluatingParserInsertedScript()
34983: {
34983:   ++mParserInsertedScriptsBeingEvaluated;
34983: }
34983: 
34983: void
34983: nsHtml5Parser::EndEvaluatingParserInsertedScript()
34983: {
34983:   --mParserInsertedScriptsBeingEvaluated;
34983: }
34983: 
34983: void
34983: nsHtml5Parser::MarkAsNotScriptCreated()
34983: {
34983:   NS_PRECONDITION(!mStreamParser, "Must not call this twice.");
34983:   mStreamParser = new nsHtml5StreamParser(mExecutor, this);
34983: }
34983: 
34983: PRBool
34983: nsHtml5Parser::IsScriptCreated()
34983: {
34983:   return !mStreamParser;
34983: }
34983: 
29805: /* End nsIParser  */
29805: 
29805: // not from interface
29805: void
34992: nsHtml5Parser::ParseUntilBlocked()
29805: {
40983:   NS_PRECONDITION(!mExecutor->IsFragmentMode(),
40983:                   "ParseUntilBlocked called in fragment mode.");
29805: 
29805:   if (mBlocked) {
29805:     return;
29805:   }
29805: 
34981:   if (mExecutor->IsComplete()) {
29805:     return;
29805:   }
34981:   NS_ASSERTION(mExecutor->HasStarted(), "Bad life cycle.");
29805: 
29805:   for (;;) {
29805:     if (!mFirstBuffer->hasMore()) {
29805:       if (mFirstBuffer == mLastBuffer) {
34981:         if (mExecutor->IsComplete()) {
29805:           // something like cache manisfests stopped the parse in mid-flight
29805:           return;
34981:         }
34979:         if (mDocumentClosed) {
34979:           NS_ASSERTION(!mStreamParser,
34979:                        "This should only happen with script-created parser.");
34979:           mTokenizer->eof();
34979:           mTreeBuilder->StreamEnded();
34979:           mTreeBuilder->Flush();
39737:           mExecutor->FlushDocumentWrite();
34979:           mTokenizer->end();
34979:           return;            
40983:         }
34981:         // never release the last buffer.
40983:         NS_ASSERTION(!mLastBuffer->getStart() && !mLastBuffer->getEnd(),
34981:                      "Sentinel buffer had its indeces changed.");
40983:         if (mStreamParser && mReturnToStreamParserPermitted
40983:             && !mExecutor->IsScriptExecuting()) {
35295:           mTreeBuilder->Flush();
34981:           mReturnToStreamParserPermitted = PR_FALSE;
34979:           mStreamParser->ContinueAfterScripts(mTokenizer,
34979:                                               mTreeBuilder,
34979:                                               mLastWasCR);
32917:         }
29805:         return; // no more data for now but expecting more
29805:       }
29805:       mFirstBuffer = mFirstBuffer->next;
29805:       continue;
29805:     }
29805: 
34981:     if (mBlocked || mExecutor->IsComplete()) {
29805:       return;
29805:     }
29805: 
29805:     // now we have a non-empty buffer
29805:     mFirstBuffer->adjust(mLastWasCR);
29805:     mLastWasCR = PR_FALSE;
29805:     if (mFirstBuffer->hasMore()) {
40983:       PRBool inRootContext = (!mStreamParser &&
40983:                               (mFirstBuffer->key == mRootContextKey));
35294:       if (inRootContext) {
35294:         mTokenizer->setLineNumber(mRootContextLineNumber);
35294:       }
29805:       mLastWasCR = mTokenizer->tokenizeBuffer(mFirstBuffer);
35294:       if (inRootContext) {
35294:         mRootContextLineNumber = mTokenizer->getLineNumber();
35294:       }
34979:       if (mTreeBuilder->HasScript()) {
34979:         mTreeBuilder->Flush();
39737:         mExecutor->FlushDocumentWrite();
34979:       }
29805:       if (mBlocked) {
29805:         return;
29805:       }
30334:     }
29805:     continue;
29805:   }
29805: }
29805: 
29805: nsresult
29805: nsHtml5Parser::Initialize(nsIDocument* aDoc,
29805:                           nsIURI* aURI,
29805:                           nsISupports* aContainer,
29805:                           nsIChannel* aChannel)
29805: {
32917:   return mExecutor->Init(aDoc, aURI, aContainer, aChannel);
29805: }
29805: 
34979: void
34979: nsHtml5Parser::StartTokenizer(PRBool aScriptingEnabled) {
34979:   mTreeBuilder->setScriptingEnabled(aScriptingEnabled);
34979:   mTokenizer->start();
34979: }
34979: 
34979: void
40983: nsHtml5Parser::InitializeDocWriteParserState(nsAHtml5TreeBuilderState* aState,
40983:                                              PRInt32 aLine)
34979: {
34979:   mTokenizer->resetToDataState();
35294:   mTokenizer->setLineNumber(aLine);
34979:   mTreeBuilder->loadState(aState, &mAtomTable);
34979:   mLastWasCR = PR_FALSE;
34981:   mReturnToStreamParserPermitted = PR_TRUE;
34979: }
34986: 
34986: void
34986: nsHtml5Parser::ContinueAfterFailedCharsetSwitch()
34986: {
34986:   NS_PRECONDITION(mStreamParser, 
34986:     "Tried to continue after failed charset switch without a stream parser");
34986:   mStreamParser->ContinueAfterFailedCharsetSwitch();
34986: }
