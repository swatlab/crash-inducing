 1662: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
11789:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: //#define FORCE_UNISCRIBE 1
    1: #define FORCE_PR_LOG
    1: 
    1: #include "prtypes.h"
    1: #include "gfxTypes.h"
    1: 
    1: #include "gfxContext.h"
    1: #include "gfxWindowsFonts.h"
    1: #include "gfxWindowsSurface.h"
    1: #include "gfxWindowsPlatform.h"
    1: 
    1: #ifdef MOZ_ENABLE_GLITZ
    1: #include "gfxGlitzSurface.h"
    1: #endif
    1: 
    1: #include "gfxFontTest.h"
    1: 
    1: #include "cairo.h"
    1: #include "cairo-win32.h"
    1: 
    1: #include <windows.h>
    1: 
 6076: #include "nsTArray.h"
    1: #include "nsUnicodeRange.h"
    1: #include "nsUnicharUtils.h"
    1: 
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
11466: #include "nsIPrefLocalizedString.h"
    1: #include "nsServiceManagerUtils.h"
    1: 
    1: #include "nsCRT.h"
    1: 
    1: #include <math.h>
    1: 
    1: #include "prlog.h"
    1: static PRLogModuleInfo *gFontLog = PR_NewLogModule("winfonts");
    1: 
    1: #define ROUND(x) floor((x) + 0.5)
    1: 
 4363: 
 4363: struct DCFromContext {
 4363:     DCFromContext(gfxContext *aContext) {
 4621:         dc = NULL;
 4363:         nsRefPtr<gfxASurface> aSurface = aContext->CurrentSurface();
 4619:         NS_ASSERTION(aSurface, "DCFromContext: null surface");
 6274:         if (aSurface &&
 6274:             (aSurface->GetType() == gfxASurface::SurfaceTypeWin32 ||
 6274:              aSurface->GetType() == gfxASurface::SurfaceTypeWin32Printing))
 6274:         {
 4363:             dc = static_cast<gfxWindowsSurface*>(aSurface.get())->GetDC();
 4363:             needsRelease = PR_FALSE;
 4619:         }
 4619:         if (!dc) {
 4363:             dc = GetDC(NULL);
 4363:             needsRelease = PR_TRUE;
    1:         }
    1:     }
    1: 
 4363:     ~DCFromContext() {
 4363:         if (needsRelease)
 4363:             ReleaseDC(NULL, dc);
 4363:     }
 4363: 
 4363:     operator HDC () {
 4363:         return dc;
 4363:     }
 4363: 
 4363:     HDC dc;
 4363:     PRBool needsRelease;
 4363: };
 4363: 
    1: /**********************************************************************
    1:  *
    1:  * class gfxWindowsFont
    1:  *
    1:  **********************************************************************/
    1: 
13340: gfxWindowsFont::gfxWindowsFont(const nsAString& aName, const gfxFontStyle *aFontStyle, FontEntry *aFontEntry)
    1:     : gfxFont(aName, aFontStyle),
 9503:       mFont(nsnull), mAdjustedSize(0.0), mScriptCache(nsnull),
    1:       mFontFace(nsnull), mScaledFont(nsnull),
13340:       mMetrics(nsnull), mFontEntry(aFontEntry)
    1: {
 1959:     NS_ASSERTION(mFontEntry, "Unable to find font entry for font.  Something is whack.");
 2369: 
 2369:     mFont = MakeHFONT(); // create the HFONT, compute metrics, etc
 2369:     NS_ASSERTION(mFont, "Failed to make HFONT");
    1: }
    1: 
    1: gfxWindowsFont::~gfxWindowsFont()
    1: {
    1:     if (mFontFace)
    1:         cairo_font_face_destroy(mFontFace);
    1: 
    1:     if (mScaledFont)
    1:         cairo_scaled_font_destroy(mScaledFont);
    1: 
    1:     if (mFont)
    1:         DeleteObject(mFont);
    1: 
    1:     ScriptFreeCache(&mScriptCache);
    1: 
    1:     delete mMetrics;
    1: }
    1: 
    1: const gfxFont::Metrics&
    1: gfxWindowsFont::GetMetrics()
    1: {
    1:     if (!mMetrics)
    1:         ComputeMetrics();
    1: 
    1:     return *mMetrics;
    1: }
    1: 
    1: cairo_font_face_t *
    1: gfxWindowsFont::CairoFontFace()
    1: {
    1:     if (!mFontFace)
 2369:         mFontFace = cairo_win32_font_face_create_for_logfontw_hfont(&mLogFont, mFont);
    1: 
    1:     NS_ASSERTION(mFontFace, "Failed to make font face");
    1: 
    1:     return mFontFace;
    1: }
    1: 
    1: cairo_scaled_font_t *
    1: gfxWindowsFont::CairoScaledFont()
    1: {
 2369:     if (!mScaledFont) {
 2369:         cairo_matrix_t sizeMatrix;
 2369:         cairo_matrix_t identityMatrix;
 2369: 
 2369:         cairo_matrix_init_scale(&sizeMatrix, mAdjustedSize, mAdjustedSize);
 2369:         cairo_matrix_init_identity(&identityMatrix);
 2369: 
 2369:         cairo_font_options_t *fontOptions = cairo_font_options_create();
 2369:         mScaledFont = cairo_scaled_font_create(CairoFontFace(), &sizeMatrix,
 2369:                                                &identityMatrix, fontOptions);
 2369:         cairo_font_options_destroy(fontOptions);
 2369:     }
    1: 
 5274:     NS_ASSERTION(mAdjustedSize == 0.0 ||
 5274:                  cairo_scaled_font_status(mScaledFont) == CAIRO_STATUS_SUCCESS,
 4304:                  "Failed to make scaled font");
    1: 
    1:     return mScaledFont;
    1: }
    1: 
    1: HFONT
    1: gfxWindowsFont::MakeHFONT()
    1: {
    1:     if (mFont)
    1:         return mFont;
    1: 
  323:     mAdjustedSize = GetStyle()->size;
 9504:     if (GetStyle()->sizeAdjust > 0.0) {
    1:         if (!mFont) {
13280:             FillLogFont(mAdjustedSize);
    1:             mFont = CreateFontIndirectW(&mLogFont);
    1:         }
    1: 
    1:         Metrics *oldMetrics = mMetrics;
    1:         ComputeMetrics();
    1:         gfxFloat aspect = mMetrics->xHeight / mMetrics->emHeight;
 2210:         mAdjustedSize = GetStyle()->GetAdjustedSize(aspect);
    1: 
    1:         if (mMetrics != oldMetrics) {
    1:             delete mMetrics;
    1:             mMetrics = oldMetrics;
    1:         }
    1:         DeleteObject(mFont);
    1:         mFont = nsnull;
    1:     }
    1: 
    1:     if (!mFont) {
13280:         FillLogFont(mAdjustedSize);
    1:         mFont = CreateFontIndirectW(&mLogFont);
    1:     }
    1: 
    1:     return mFont;
    1: }
    1: 
    1: void
    1: gfxWindowsFont::ComputeMetrics()
    1: {
    1:     if (!mMetrics)
    1:         mMetrics = new gfxFont::Metrics;
 2369:     else
 2369:         NS_WARNING("Calling ComputeMetrics multiple times");
    1: 
    1:     HDC dc = GetDC((HWND)nsnull);
    1: 
 2369:     HGDIOBJ oldFont = SelectObject(dc, mFont);
    1: 
    1:     // Get font metrics
    1:     OUTLINETEXTMETRIC oMetrics;
    1:     TEXTMETRIC& metrics = oMetrics.otmTextMetrics;
    1: 
    1:     if (0 < GetOutlineTextMetrics(dc, sizeof(oMetrics), &oMetrics)) {
    1:         mMetrics->superscriptOffset = (double)oMetrics.otmptSuperscriptOffset.y;
11789:         // Some fonts have wrong sign on their subscript offset, bug 410917.
11789:         mMetrics->subscriptOffset = fabs((double)oMetrics.otmptSubscriptOffset.y);
11765:         mMetrics->strikeoutSize = (double)oMetrics.otmsStrikeoutSize;
    1:         mMetrics->strikeoutOffset = (double)oMetrics.otmsStrikeoutPosition;
11765:         mMetrics->underlineSize = (double)oMetrics.otmsUnderscoreSize;
    1:         mMetrics->underlineOffset = (double)oMetrics.otmsUnderscorePosition;
    1: 
    1:         const MAT2 kIdentityMatrix = { {0, 1}, {0, 0}, {0, 0}, {0, 1} };
    1:         GLYPHMETRICS gm;
    1:         DWORD len = GetGlyphOutlineW(dc, PRUnichar('x'), GGO_METRICS, &gm, 0, nsnull, &kIdentityMatrix);
    1:         if (len == GDI_ERROR || gm.gmptGlyphOrigin.y <= 0) {
    1:             // 56% of ascent, best guess for true type
    1:             mMetrics->xHeight = ROUND((double)metrics.tmAscent * 0.56);
    1:         } else {
    1:             mMetrics->xHeight = gm.gmptGlyphOrigin.y;
    1:         }
11765:         mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
11765:         gfxFloat typEmHeight = (double)oMetrics.otmAscent - (double)oMetrics.otmDescent;
11765:         mMetrics->emAscent = ROUND(mMetrics->emHeight * (double)oMetrics.otmAscent / typEmHeight);
11765:         mMetrics->emDescent = mMetrics->emHeight - mMetrics->emAscent;
    1:     } else {
    1:         // Make a best-effort guess at extended metrics
    1:         // this is based on general typographic guidelines
    1:         GetTextMetrics(dc, &metrics);
    1: 
    1:         mMetrics->xHeight = ROUND((float)metrics.tmAscent * 0.56f); // 56% of ascent, best guess for non-true type
    1:         mMetrics->superscriptOffset = mMetrics->xHeight;
    1:         mMetrics->subscriptOffset = mMetrics->xHeight;
    1:         mMetrics->strikeoutSize = 1;
    1:         mMetrics->strikeoutOffset = ROUND(mMetrics->xHeight / 2.0f); // 50% of xHeight
    1:         mMetrics->underlineSize = 1;
    1:         mMetrics->underlineOffset = -ROUND((float)metrics.tmDescent * 0.30f); // 30% of descent
11765:         mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
11765:         mMetrics->emAscent = metrics.tmAscent - metrics.tmInternalLeading;
11765:         mMetrics->emDescent = metrics.tmDescent;
    1:     }
    1: 
    1:     mMetrics->internalLeading = metrics.tmInternalLeading;
    1:     mMetrics->externalLeading = metrics.tmExternalLeading;
    1:     mMetrics->maxHeight = metrics.tmHeight;
    1:     mMetrics->maxAscent = metrics.tmAscent;
    1:     mMetrics->maxDescent = metrics.tmDescent;
    1:     mMetrics->maxAdvance = metrics.tmMaxCharWidth;
    1:     mMetrics->aveCharWidth = PR_MAX(1, metrics.tmAveCharWidth);
    1: 
    1:     // Cache the width of a single space.
    1:     SIZE size;
12902:     GetTextExtentPoint32(dc, " ", 1, &size);
    1:     mMetrics->spaceWidth = ROUND(size.cx);
    1: 
 1295:     mSpaceGlyph = 0;
 1295:     if (metrics.tmPitchAndFamily & TMPF_TRUETYPE) {
 1295:         WORD glyph;
12902:         DWORD ret = GetGlyphIndicesA(dc, " ", 1, &glyph,
 1295:                                      GGI_MARK_NONEXISTING_GLYPHS);
 1295:         if (ret != GDI_ERROR && glyph != 0xFFFF) {
 1295:             mSpaceGlyph = glyph;
 1295:         }
 1295:     }
 1295: 
    1:     SelectObject(dc, oldFont);
    1: 
    1:     ReleaseDC((HWND)nsnull, dc);
11765: 
12989:     SanitizeMetrics(mMetrics, mFontEntry->IsBadUnderlineFont());
    1: }
    1: 
    1: void
13280: gfxWindowsFont::FillLogFont(gfxFloat aSize)
    1: {
    1: #define CLIP_TURNOFF_FONTASSOCIATION 0x40
    1:     
  687:     mLogFont.lfHeight = (LONG)-ROUND(aSize);
    1: 
    1:     if (mLogFont.lfHeight == 0)
    1:         mLogFont.lfHeight = -1;
    1: 
    1:     // Fill in logFont structure
    1:     mLogFont.lfWidth          = 0;
    1:     mLogFont.lfEscapement     = 0;
    1:     mLogFont.lfOrientation    = 0;
 1663:     mLogFont.lfUnderline      = FALSE;
 1663:     mLogFont.lfStrikeOut      = FALSE;
    1:     mLogFont.lfCharSet        = DEFAULT_CHARSET;
    1: #ifndef WINCE
    1:     mLogFont.lfOutPrecision   = OUT_TT_PRECIS;
    1: #else
    1:     mLogFont.lfOutPrecision   = OUT_DEFAULT_PRECIS;
    1: #endif
    1:     mLogFont.lfClipPrecision  = CLIP_TURNOFF_FONTASSOCIATION;
    1:     mLogFont.lfQuality        = DEFAULT_QUALITY;
    1:     mLogFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
13280:     // always force lfItalic if we want it.  Font selection code will
13280:     // do its best to give us an italic font entry, but if no face exists
13280:     // it may give us a regular one based on weight.  Windows should
13280:     // do fake italic for us in that case.
  323:     mLogFont.lfItalic         = (GetStyle()->style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) ? TRUE : FALSE;
13280:     mLogFont.lfWeight         = mFontEntry->mWeight;
    1: 
    1:     int len = PR_MIN(mName.Length(), LF_FACESIZE - 1);
    1:     memcpy(mLogFont.lfFaceName, nsPromiseFlatString(mName).get(), len * 2);
    1:     mLogFont.lfFaceName[len] = '\0';
    1: }
    1: 
    1: 
    1: nsString
    1: gfxWindowsFont::GetUniqueName()
    1: {
    1:     nsString uniqueName;
    1: 
    1:     // start with the family name
    1:     uniqueName.Assign(mName);
    1: 
    1:     // append the weight code
    1:     if (mLogFont.lfWeight != 400) {
    1:         uniqueName.AppendLiteral(":");
    1:         uniqueName.AppendInt((PRInt32)mLogFont.lfWeight);
    1:     }
    1: 
    1:     // append italic?
    1:     if (mLogFont.lfItalic)
    1:         uniqueName.AppendLiteral(":Italic");
    1: 
    1:     if (mLogFont.lfUnderline)
    1:         uniqueName.AppendLiteral(":Underline");
    1: 
    1:     if (mLogFont.lfStrikeOut)
    1:         uniqueName.AppendLiteral(":StrikeOut");
    1: 
    1:     return uniqueName;
    1: }
    1: 
    1: void
    1: gfxWindowsFont::Draw(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,
    1:                      gfxContext *aContext, PRBool aDrawToPath, gfxPoint *aBaselineOrigin,
    1:                      Spacing *aSpacing)
    1: {
    1:     // XXX stuart may want us to do something faster here
    1:     gfxFont::Draw(aTextRun, aStart, aEnd, aContext, aDrawToPath, aBaselineOrigin,
    1:                   aSpacing);
    1: }
    1: 
 4304: PRBool
 6247: gfxWindowsFont::SetupCairoFont(gfxContext *aContext)
    1: {
 4304:     cairo_scaled_font_t *scaledFont = CairoScaledFont();
 5274:     if (cairo_scaled_font_status(scaledFont) != CAIRO_STATUS_SUCCESS) {
 5274:         // Don't cairo_set_scaled_font as that would propagate the error to
 5274:         // the cairo_t, precluding any further drawing.
 5274:         return PR_FALSE;
 5274:     }
 6247:     cairo_set_scaled_font(aContext->GetCairo(), scaledFont);
 4304:     return PR_TRUE;
 4304: }
    1: 
    1: /**********************************************************************
    1:  *
    1:  * class gfxWindowsFontGroup
    1:  *
    1:  **********************************************************************/
    1: 
  323: /**
  323:  * Look up the font in the gfxFont cache. If we don't find it, create one.
  323:  * In either case, add a ref, append it to the aFonts array, and return it ---
  323:  * except for OOM in which case we do nothing and return null.
  323:  */
  323: static already_AddRefed<gfxWindowsFont>
 2252: GetOrMakeFont(FontEntry *aFontEntry, const gfxFontStyle *aStyle)
  323: {
13280:     nsRefPtr<gfxFont> font = gfxFontCache::GetCache()->Lookup(aFontEntry->GetName(), aStyle);
  323:     if (!font) {
13340:         font = new gfxWindowsFont(aFontEntry->GetName(), aStyle, aFontEntry);
  323:         if (!font)
  323:             return nsnull;
  323:         gfxFontCache::GetCache()->AddNew(font);
  323:     }
  323:     gfxFont *f = nsnull;
  323:     font.swap(f);
  323:     return static_cast<gfxWindowsFont *>(f);
  323: }
  323: 
 2252: static PRBool
13280: AddFontNameToArray(const nsAString& aName,
    1:                    const nsACString& aGenericName,
    1:                    void *closure)
    1: {
    1:     if (!aName.IsEmpty()) {
13280:         nsTArray<nsAutoString> *list = static_cast<nsTArray<nsAutoString> *>(closure);
    1: 
13280:         if (list->IndexOf(aName) == list->NoIndex)
13280:             list->AppendElement(aName);
    1:     }
    1: 
    1:     return PR_TRUE;
    1: }
    1: 
13280: void
13280: gfxWindowsFontGroup::GroupFamilyListToArrayList(nsTArray<nsRefPtr<FontEntry> > *list)
13280: {
13280:     nsAutoTArray<nsAutoString, 15> fonts;
13280:     ForEachFont(AddFontNameToArray, &fonts);
13280: 
13280:     PRUint32 len = fonts.Length();
13280:     for (PRUint32 i = 0; i < len; ++i) {
13280:         nsRefPtr<FontEntry> fe = gfxWindowsPlatform::GetPlatform()->FindFontEntry(fonts[i], &mStyle);
13280:         list->AppendElement(fe);
13280:     }
13280: }
13280: 
13280: void
13280: gfxWindowsFontGroup::FamilyListToArrayList(const nsString& aFamilies,
13280:                                            const nsCString& aLangGroup,
13280:                                            nsTArray<nsRefPtr<FontEntry> > *list)
13280: {
13280:     nsAutoTArray<nsAutoString, 15> fonts;
13280:     ForEachFont(aFamilies, aLangGroup, AddFontNameToArray, &fonts);
13280: 
13280:     PRUint32 len = fonts.Length();
13280:     for (PRUint32 i = 0; i < len; ++i) {
13280:         const nsAutoString& str = fonts[i];
13280:         nsRefPtr<FontEntry> fe = gfxWindowsPlatform::GetPlatform()->FindFontEntry(str, &mStyle);
13280:         list->AppendElement(fe);
13280:     }
13280: }
13280: 
    1: gfxWindowsFontGroup::gfxWindowsFontGroup(const nsAString& aFamilies, const gfxFontStyle *aStyle)
    1:     : gfxFontGroup(aFamilies, aStyle)
    1: {
13280:     GroupFamilyListToArrayList(&mFontEntries);
    1: 
 5257:     if (mFontEntries.Length() == 0) {
    1:         // Should append default GUI font if there are no available fonts.
    1:         HGDIOBJ hGDI = ::GetStockObject(DEFAULT_GUI_FONT);
    1:         LOGFONTW logFont;
    1:         if (!hGDI ||
    1:             !::GetObjectW(hGDI, sizeof(logFont), &logFont)) {
    1:             NS_ERROR("Failed to create font group");
    1:             return;
    1:         }
13280:         nsRefPtr<FontEntry> fe = gfxWindowsPlatform::GetPlatform()->FindFontEntry(nsDependentString(logFont.lfFaceName), aStyle);
 2252:         mFontEntries.AppendElement(fe);
    1:     }
 2252: 
 2252:     mFonts.AppendElements(mFontEntries.Length());
12989: 
12989:     for (PRUint32 i = 0; i < mFontEntries.Length(); ++i) {
12989:         if (mFontEntries[i]->IsBadUnderlineFont()) {
12989:             gfxFloat first = GetFontAt(0)->GetMetrics().underlineOffset;
12989:             gfxFloat bad = GetFontAt(i)->GetMetrics().underlineOffset;
12989:             mUnderlineOffset = PR_MIN(first, bad);
12989:             break;
12989:         }
12989:     }
    1: }
    1: 
    1: gfxWindowsFontGroup::~gfxWindowsFontGroup()
    1: {
    1: }
    1: 
 2252: gfxWindowsFont *
 2252: gfxWindowsFontGroup::GetFontAt(PRInt32 i)
 2252: {
 2252:     if (!mFonts[i]) {
 2254:         nsRefPtr<gfxWindowsFont> font = GetOrMakeFont(mFontEntries[i], &mStyle);
 2254:         mFonts[i] = font;
 2252:     }
 2252: 
 3233:     return static_cast<gfxWindowsFont*>(mFonts[i].get());
 2252: }
 2252: 
    6: gfxFontGroup *
    6: gfxWindowsFontGroup::Copy(const gfxFontStyle *aStyle)
    6: {
    6:     return new gfxWindowsFontGroup(mFamilies, aStyle);
    6: }
    6: 
 4032: static PRBool
 4032: CanTakeFastPath(PRUint32 aFlags)
 4032: {
 4032:     // Can take fast path only if OPTIMIZE_SPEED is set and IS_RTL isn't
 4032:     // We need to always use Uniscribe for RTL text, in case glyph mirroring is required
 4032:     return (aFlags &
 4032:             (gfxTextRunFactory::TEXT_OPTIMIZE_SPEED | gfxTextRunFactory::TEXT_IS_RTL)) ==
 4032:         gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
 4032: }
 4032: 
    1: gfxTextRun *
    1: gfxWindowsFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,
 1295:                                  const Parameters *aParams, PRUint32 aFlags)
    1: {
  642:     // XXX comment out the assertion for now since it fires too much
 1295:     //    NS_ASSERTION(!(mFlags & TEXT_NEED_BOUNDING_BOX),
  642:     //                 "Glyph extents not yet supported");
    1: 
 8084:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
    1:     if (!textRun)
    1:         return nsnull;
 1153:     NS_ASSERTION(aParams->mContext, "MakeTextRun called without a gfxContext");
    1: 
    1:     textRun->RecordSurrogates(aString);
    1:     
    1: #ifdef FORCE_UNISCRIBE
    1:     const PRBool isComplex = PR_TRUE;
    1: #else
 4032:     const PRBool isComplex = !CanTakeFastPath(aFlags) ||
 4032:                              ScriptIsComplex(aString, aLength, SIC_COMPLEX) == S_OK;
    1: #endif
    1:     if (isComplex)
    1:         InitTextRunUniscribe(aParams->mContext, textRun, aString, aLength);
    1:     else
    1:         InitTextRunGDI(aParams->mContext, textRun, aString, aLength);
    1: 
 6247:     textRun->FetchGlyphExtents(aParams->mContext);
 6247: 
    1:     return textRun;
    1: }
    1: 
    1: gfxTextRun *
    1: gfxWindowsFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,
 1295:                                  const Parameters *aParams, PRUint32 aFlags)
    1: {
 1295:     NS_ASSERTION(aFlags & TEXT_IS_8BIT, "should be marked 8bit");
 1295:  
 8084:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
    1:     if (!textRun)
    1:         return nsnull;
 1153:     NS_ASSERTION(aParams->mContext, "MakeTextRun called without a gfxContext");
    1: 
    1: #ifdef FORCE_UNISCRIBE
    1:     const PRBool isComplex = PR_TRUE;
    1: #else
 4032:     const PRBool isComplex = !CanTakeFastPath(aFlags);
    1: #endif
    1: 
  837:     /* We can only call GDI "A" functions if this is a true 7bit ASCII string,
  837:        because they interpret code points from 0x80-0xFF as if they were
  837:        in the system code page. */
 1295:     if (!isComplex && (aFlags & TEXT_IS_ASCII)) {
  837:         InitTextRunGDI(aParams->mContext, textRun,
  837:                        reinterpret_cast<const char*>(aString), aLength);
  837:     }
  837:     else {
    1:         nsDependentCSubstring cString(reinterpret_cast<const char*>(aString),
    1:                                   reinterpret_cast<const char*>(aString + aLength));
    1:         nsAutoString utf16;
    1:         AppendASCIItoUTF16(cString, utf16);
  837:         if (isComplex) {
    1:             InitTextRunUniscribe(aParams->mContext, textRun, utf16.get(), aLength);
    1:         } else {
  837:             InitTextRunGDI(aParams->mContext, textRun, utf16.get(), aLength);
  837:         }
    1:     }
    1: 
 6247:     textRun->FetchGlyphExtents(aParams->mContext);
 6247: 
    1:     return textRun;
    1: }
    1: 
  127: /**
 4363:  * Set the font in the given DC.  If something goes wrong or if the
 4363:  * font is not a Truetype font (hence GetGlyphIndices may be buggy)
 4363:  * then we're not successful and return PR_FALSE, otherwise PR_TRUE.
  127:  */
 4363: static PRBool
 4363: SetupDCFont(HDC dc, gfxWindowsFont *aFont)
    1: {
  127:     HFONT hfont = aFont->GetHFONT();
  127:     if (!hfont)
 4363:         return PR_FALSE;
  127:     SelectObject(dc, hfont);
    1: 
  127:     /* GetGlyphIndices is buggy for bitmap and vector fonts,
  127:        so send them to uniscribe */
13340:     if (!aFont->GetFontEntry()->mTrueType)
 4363:         return PR_FALSE;
  127: 
 4363:     return PR_TRUE;
    1: }
    1: 
  127: static PRBool
  127: IsAnyGlyphMissing(WCHAR *aGlyphs, PRUint32 aLength)
    1: {
  127:     PRUint32 i;
  127:     for (i = 0; i < aLength; ++i) {
  127:         if (aGlyphs[i] == 0xFFFF)
  127:             return PR_TRUE;
  127:     }
  127:     return PR_FALSE;
  127: }
  127: 
  127: static PRBool
  127: SetupTextRunFromGlyphs(gfxTextRun *aRun, WCHAR *aGlyphs, HDC aDC,
  127:                        gfxWindowsFont *aFont)
  127: {
  127:     PRUint32 length = aRun->GetLength();
  127:     if (IsAnyGlyphMissing(aGlyphs, length))
  127:         return PR_FALSE;
  127: 
  127:     SIZE size;
 6076:     nsAutoTArray<int,500> partialWidthArray;
 6076:     if (!partialWidthArray.SetLength(length))
  127:         return PR_FALSE;
  127:     BOOL success = GetTextExtentExPointI(aDC,
  341:                                          (WORD*) aGlyphs,
  127:                                          length,
  127:                                          INT_MAX,
  127:                                          NULL,
 6076:                                          partialWidthArray.Elements(),
  127:                                          &size);
  127:     if (!success)
  127:         return PR_FALSE;
  127: 
  127:     aRun->AddGlyphRun(aFont, 0);
  127: 
    1:     gfxTextRun::CompressedGlyph g;
    1:     PRUint32 i;
  127:     PRInt32 lastWidth = 0;
  127:     PRUint32 appUnitsPerDevPixel = aRun->GetAppUnitsPerDevUnit();
    1:     for (i = 0; i < length; ++i) {
  127:         PRInt32 advancePixels = partialWidthArray[i] - lastWidth;
  127:         lastWidth = partialWidthArray[i];
  127:         PRInt32 advanceAppUnits = advancePixels*appUnitsPerDevPixel;
    1:         WCHAR glyph = aGlyphs[i];
 3118:         NS_ASSERTION(!gfxFontGroup::IsInvalidChar(aRun->GetChar(i)),
 3118:                      "Invalid character detected!");
 3118:         if (advanceAppUnits >= 0 &&
    1:             gfxTextRun::CompressedGlyph::IsSimpleAdvance(advanceAppUnits) &&
    1:             gfxTextRun::CompressedGlyph::IsSimpleGlyphID(glyph)) {
 7715:             aRun->SetSimpleGlyph(i, g.SetSimpleGlyph(advanceAppUnits, glyph));
    1:         } else {
    1:             gfxTextRun::DetailedGlyph details;
    1:             details.mGlyphID = glyph;
    1:             details.mAdvance = advanceAppUnits;
    1:             details.mXOffset = 0;
    1:             details.mYOffset = 0;
 7715:             aRun->SetGlyphs(i, g.SetComplex(PR_TRUE, PR_TRUE, 1), &details);
    1:         }
    1:     }
    1:     return PR_TRUE;
    1: }
    1: 
    1: void
    1: gfxWindowsFontGroup::InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun,
    1:                                     const char *aString, PRUint32 aLength)
    1: {
 2252:     nsRefPtr<gfxWindowsFont> font = GetFontAt(0);
 4363:     DCFromContext dc(aContext);
 4363:     if (SetupDCFont(dc, font)) {
 6076:         nsAutoTArray<WCHAR,500> glyphArray;
 6076:         if (!glyphArray.SetLength(aLength))
    1:             return;
    1: 
 6076:         DWORD ret = GetGlyphIndicesA(dc, aString, aLength, (WORD*) glyphArray.Elements(),
  127:                                      GGI_MARK_NONEXISTING_GLYPHS);
  127:         if (ret != GDI_ERROR &&
 6076:             SetupTextRunFromGlyphs(aRun, glyphArray.Elements(), dc, font))
  127:             return;
  127:     }
  127: 
    1:     nsDependentCSubstring cString(aString, aString + aLength);
    1:     nsAutoString utf16;
    1:     AppendASCIItoUTF16(cString, utf16);
    1:     InitTextRunUniscribe(aContext, aRun, utf16.get(), aLength);
    1: }
    1: 
    1: void
    1: gfxWindowsFontGroup::InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun,
    1:                                     const PRUnichar *aString, PRUint32 aLength)
    1: {
 2252:     nsRefPtr<gfxWindowsFont> font = GetFontAt(0);
 4363:     DCFromContext dc(aContext);
 4363:     if (SetupDCFont(dc, font)) {
 6076:         nsAutoTArray<WCHAR,500> glyphArray;
 6076:         if (!glyphArray.SetLength(aLength))
    1:             return;
    1: 
 6076:         DWORD ret = GetGlyphIndicesW(dc, aString, aLength, (WORD*) glyphArray.Elements(),
  127:                                      GGI_MARK_NONEXISTING_GLYPHS);
  127:         if (ret != GDI_ERROR &&
 6076:             SetupTextRunFromGlyphs(aRun, glyphArray.Elements(), dc, font))
    1:             return;
    1:     }
    1: 
  127:     InitTextRunUniscribe(aContext, aRun, aString, aLength);
    1: }
    1: 
    1: /*******************
    1:  * Uniscribe
    1:  *******************/
    1: 
    1: /* we map primary language id's to this to look up language codes */
    1: struct ScriptPropertyEntry {
    1:     const char *value;
    1:     const char *langCode;
    1: };
    1: 
    1: static const struct ScriptPropertyEntry gScriptToText[] =
    1: {
    1:     { nsnull, nsnull },
    1:     { "LANG_ARABIC",     "ara" },
    1:     { "LANG_BULGARIAN",  "bul" },
    1:     { "LANG_CATALAN",    "cat" },
    1:     { "LANG_CHINESE",    "zh-CN" }, //XXX right lang code?
    1:     { "LANG_CZECH",      "cze" }, // cze/ces
    1:     { "LANG_DANISH",     "dan" },
    1:     { "LANG_GERMAN",     "ger" }, // ger/deu
    1:     { "LANG_GREEK",      "el" }, // gre/ell
    1:     { "LANG_ENGLISH",    "x-western" },
    1:     { "LANG_SPANISH",    "spa" },
    1:     { "LANG_FINNISH",    "fin" },
    1:     { "LANG_FRENCH",     "fre" }, // fre/fra
    1:     { "LANG_HEBREW",     "he" }, // heb
    1:     { "LANG_HUNGARIAN",  "hun" },
    1:     { "LANG_ICELANDIC",  "ice" }, // ice/isl
    1:     { "LANG_ITALIAN",    "ita" },
    1:     { "LANG_JAPANESE",   "ja" }, // jpn
    1:     { "LANG_KOREAN",     "ko" }, // kor
    1:     { "LANG_DUTCH",      "dut" }, // dut/nld
    1:     { "LANG_NORWEGIAN",  "nor" },
    1:     { "LANG_POLISH",     "pol" },
    1:     { "LANG_PORTUGUESE", "por" },
    1:     { nsnull, nsnull },
    1:     { "LANG_ROMANIAN",   "rum" }, // rum/ron
    1:     { "LANG_RUSSIAN",    "rus" },
    1:     { "LANG_SERBIAN",    "scc" }, // scc/srp
    1:     { "LANG_SLOVAK",     "slo" }, // slo/slk
    1:     { "LANG_ALBANIAN",   "alb" }, // alb/sqi
    1:     { "LANG_SWEDISH",    "swe" },
    1:     { "LANG_THAI",       "th" }, // tha
    1:     { "LANG_TURKISH",    "tr" }, // tur
    1:     { "LANG_URDU",       "urd" },
    1:     { "LANG_INDONESIAN", "ind" },
    1:     { "LANG_UKRAINIAN",  "ukr" },
    1:     { "LANG_BELARUSIAN", "bel" },
    1:     { "LANG_SLOVENIAN",  "slv" },
    1:     { "LANG_ESTONIAN",   "est" },
    1:     { "LANG_LATVIAN",    "lav" },
    1:     { "LANG_LITHUANIAN", "lit" },
    1:     { nsnull, nsnull },
    1:     { "LANG_FARSI",      "per" }, // per/fas
    1:     { "LANG_VIETNAMESE", "vie" },
    1:     { "LANG_ARMENIAN",   "x-armn" }, // arm/hye
    1:     { "LANG_AZERI",      "aze" },
    1:     { "LANG_BASQUE",     "baq" }, // baq/eus
    1:     { nsnull, nsnull },
    1:     { "LANG_MACEDONIAN", "mac" }, // mac/mkd
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { "LANG_AFRIKAANS",  "afr" },
    1:     { "LANG_GEORGIAN",   "x-geor" }, // geo
    1:     { "LANG_FAEROESE",   "fao" },
    1:     { "LANG_HINDI",      "x-devanagari" }, // hin
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { "LANG_MALAY",      "may" }, // may/msa
    1:     { "LANG_KAZAK",      "kaz" }, // listed as kazakh?
    1:     { "LANG_KYRGYZ",     "kis" },
    1:     { "LANG_SWAHILI",    "swa" },
    1:     { nsnull, nsnull },
    1:     { "LANG_UZBEK",      "uzb" },
    1:     { "LANG_TATAR",      "tat" },
    1:     { "LANG_BENGALI",    "x-beng" }, // ben
    1:     { "LANG_PUNJABI",    "x-guru" }, // pan -- XXX x-guru is for Gurmukhi which isn't just Punjabi
    1:     { "LANG_GUJARATI",   "x-gujr" }, // guj
    1:     { "LANG_ORIYA",      "ori" },
    1:     { "LANG_TAMIL",      "x-tamil" }, // tam
    1:     { "LANG_TELUGU",     "tel" },
    1:     { "LANG_KANNADA",    "kan" },
    1:     { "LANG_MALAYALAM",  "x-mlym" }, // mal
    1:     { "LANG_ASSAMESE",   "asm" },
    1:     { "LANG_MARATHI",    "mar" },
    1:     { "LANG_SANSKRIT",   "san" },
    1:     { "LANG_MONGOLIAN",  "mon" },
    1:     { "TIBETAN",         "tib" }, // tib/bod
    1:     { nsnull, nsnull },
    1:     { "KHMER",           "x-khmr" }, // khm
    1:     { "LAO",             "lao" },
    1:     { "MYANMAR",         "bur" }, // bur/mya
    1:     { "LANG_GALICIAN",   "glg" },
    1:     { "LANG_KONKANI",    "kok" },
    1:     { "LANG_MANIPURI",   "mni" },
    1:     { "LANG_SINDHI",     "x-devanagari" }, // snd
    1:     { "LANG_SYRIAC",     "syr" },
    1:     { "SINHALESE",       "sin" },
    1:     { "CHEROKEE",        "chr" },
    1:     { "INUKTITUT",       "x-cans" }, // iku
    1:     { "ETHIOPIC",        "x-ethi" }, // amh -- this is both Amharic and Tigrinya
    1:     { nsnull, nsnull },
    1:     { "LANG_KASHMIRI",   "x-devanagari" }, // kas
    1:     { "LANG_NEPALI",     "x-devanagari" }, // nep
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { "LANG_DIVEHI",     "div" }
    1: };
    1: 
    1: static const char *sCJKLangGroup[] = {
    1:     "ja",
    1:     "ko",
    1:     "zh-CN",
    1:     "zh-HK",
    1:     "zh-TW"
    1: };
    1: 
    1: #define COUNT_OF_CJK_LANG_GROUP 5
    1: #define CJK_LANG_JA    sCJKLangGroup[0]
    1: #define CJK_LANG_KO    sCJKLangGroup[1]
    1: #define CJK_LANG_ZH_CN sCJKLangGroup[2]
    1: #define CJK_LANG_ZH_HK sCJKLangGroup[3]
    1: #define CJK_LANG_ZH_TW sCJKLangGroup[4]
    1: 
    1: #define STATIC_STRING_LENGTH 100
    1: 
 7625: #define ESTIMATE_MAX_GLYPHS(L) (((3 * (L)) >> 1) + 16)
 7625: 
    1: class UniscribeItem
    1: {
    1: public:
    1:     UniscribeItem(gfxContext *aContext, HDC aDC,
    1:                   const PRUnichar *aString, PRUint32 aLength,
    1:                   SCRIPT_ITEM *aItem,
    1:                   gfxWindowsFontGroup *aGroup) :
 2252:         mContext(aContext), mDC(aDC), mRangeString(nsnull), mRangeLength(0),
 2252:         mItemString(aString), mItemLength(aLength), 
 2252:         mAlternativeString(nsnull), mScriptItem(aItem),
    1:         mScript(aItem->a.eScript), mGroup(aGroup),
 7625:         mNumGlyphs(0), mMaxGlyphs(ESTIMATE_MAX_GLYPHS(aLength)),
    1:         mFontSelected(PR_FALSE)
    1:     {
 7625:         NS_ASSERTION(mMaxGlyphs < 65535, "UniscribeItem is too big, ScriptShape() will fail!");
 6076:         mGlyphs.SetLength(mMaxGlyphs);
 6076:         mClusters.SetLength(mItemLength + 1);
 6076:         mAttr.SetLength(mMaxGlyphs);
    1:     }
    1: 
    1:     ~UniscribeItem() {
    1:         free(mAlternativeString);
    1:     }
    1: 
    1:     /* possible return values:
 1959:      * S_OK - things succeeded
 1959:      * GDI_ERROR - things failed to shape.  Might want to try again after calling DisableShaping()
    1:      */
12992: 
12992:     HRESULT ShapeUniscribe() {
    1:         HRESULT rv;
    1:         HDC shapeDC = nsnull;
    1: 
 2252:         const PRUnichar *str = mAlternativeString ? mAlternativeString : mRangeString;
 1959: 
 6299:         mScriptItem->a.fLogicalOrder = PR_TRUE; 
 5308:         SCRIPT_ANALYSIS sa = mScriptItem->a;
 5308:         /*
 5308:           fLinkBefore and fLinkAfter in the SCRIPT_ANALYSIS structure refer to
 5308:           the whole item, so if the current range begins after the beginning
 5308:           of the item or ends before the end of the item, we need to override
 5308:           them here.
 5308:           This assumes that we won't split an item into ranges between two
 5308:           characters that need to be shaped together.
 5308:         */
 5308:         if (mRangeString > mItemString)
 5308:             sa.fLinkBefore = PR_FALSE;
 5308:         if (mRangeString + mRangeLength < mItemString + mItemLength)
 5308:             sa.fLinkAfter = PR_FALSE;
 5308: 
    1:         while (PR_TRUE) {
  282: 
    1:             rv = ScriptShape(shapeDC, mCurrentFont->ScriptCache(),
 2252:                              str, mRangeLength,
 5308:                              mMaxGlyphs, &sa,
 6076:                              mGlyphs.Elements(), mClusters.Elements(),
 6076:                              mAttr.Elements(), &mNumGlyphs);
    1: 
    1:             if (rv == E_OUTOFMEMORY) {
 6076:                 mGlyphs.SetLength(mMaxGlyphs);
 6076:                 mAttr.SetLength(mMaxGlyphs);
    1:                 mMaxGlyphs *= 2;
    1:                 continue;
    1:             }
    1: 
    1:             if (rv == E_PENDING) {
 4363:                 if (shapeDC == mDC) {
 4363:                     // we already tried this once, something failed, give up
 4363:                     return GDI_ERROR;
 4363:                 }
 4363: 
    1:                 SelectFont();
    1: 
    1:                 shapeDC = mDC;
    1:                 continue;
    1:             }
12992: 
    1:             return rv;
    1:         }
    1:     }
    1: 
12992:     HRESULT ShapeGDI() {
12992:         SelectFont();
12992: 
12992:         mNumGlyphs = mRangeLength;
12992:         GetGlyphIndicesW(mDC, mRangeString, mRangeLength,
12992:                          (WORD*) mGlyphs.Elements(),
12992:                          GGI_MARK_NONEXISTING_GLYPHS);
12992: 
13439:         for (PRUint32 i = 0; i < mRangeLength; ++i)
12992:             mClusters[i] = i;
12992: 
12992:         return S_OK;
12992:     }
12992: 
12992:     HRESULT Shape() {
13439:         // Skip Uniscribe for fonts that need GDI
13439:         if (mCurrentFont->GetFontEntry()->mForceGDI)
12992:             return ShapeGDI();
12992: 
12992:         return ShapeUniscribe();
12992:     }
12992: 
    1:     PRBool ShapingEnabled() {
    1:         return (mScriptItem->a.eScript != SCRIPT_UNDEFINED);
    1:     }
    1:     void DisableShaping() {
    1:         mScriptItem->a.eScript = SCRIPT_UNDEFINED;
    1:         // Note: If we disable the shaping by using SCRIPT_UNDEFINED and
    1:         // the string has the surrogate pair, ScriptShape API is
    1:         // *sometimes* crashed. Therefore, we should replace the surrogate
    1:         // pair to U+FFFD. See bug 341500.
    1:         GenerateAlternativeString();
    1:     }
 2252:     void EnableShaping() {
 2252:         mScriptItem->a.eScript = mScript;
 2252:         if (mAlternativeString) {
 2252:             free(mAlternativeString);
 2252:             mAlternativeString = nsnull;
 1959:         }
  282:     }
  282: 
  282:     PRBool IsGlyphMissing(SCRIPT_FONTPROPERTIES *aSFP, PRUint32 aGlyphIndex) {
13097:         PRBool missing = PR_FALSE;
13439:         if (GetCurrentFont()->GetFontEntry()->mForceGDI) {
13439:             // Our GDI path marks missing glyphs as 0xFFFF. So just look for that.
13097:             if (mGlyphs[aGlyphIndex] == 0xFFFF)
13097:                 missing = PR_TRUE;
13097:         } else if (mGlyphs[aGlyphIndex] == aSFP->wgDefault) {
13097:             missing = PR_TRUE;
13097:         }
13097:         return missing;
    1:     }
    1: 
11748: 
11748:     HRESULT PlaceUniscribe() {
    1:         HRESULT rv;
    1:         HDC placeDC = nsnull;
    1: 
    1:         while (PR_TRUE) {
    1:             rv = ScriptPlace(placeDC, mCurrentFont->ScriptCache(),
 6076:                              mGlyphs.Elements(), mNumGlyphs,
 6076:                              mAttr.Elements(), &mScriptItem->a,
 6076:                              mAdvances.Elements(), mOffsets.Elements(), NULL);
    1: 
    1:             if (rv == E_PENDING) {
    1:                 SelectFont();
    1:                 placeDC = mDC;
    1:                 continue;
    1:             }
    1: 
    1:             break;
    1:         }
    1: 
    1:         return rv;
    1:     }
    1: 
11748:     HRESULT PlaceGDI() {
11748:         SelectFont();
11748: 
11748:         nsAutoTArray<int,500> partialWidthArray;
11748:         if (!partialWidthArray.SetLength(mNumGlyphs))
11748:             return GDI_ERROR;
11748:         SIZE size;
11748: 
11748:         GetTextExtentExPointI(mDC,
11748:                               (WORD*) mGlyphs.Elements(),
11748:                               mNumGlyphs,
11748:                               INT_MAX,
11748:                               NULL,
11748:                               partialWidthArray.Elements(),
11748:                               &size);
11748: 
11748:         PRInt32 lastWidth = 0;
11748: 
11748:         for (PRUint32 i = 0; i < mNumGlyphs; i++) {
11748:             mAdvances[i] = partialWidthArray[i] - lastWidth;
11748:             lastWidth = partialWidthArray[i];
11748:             mOffsets[i].du = mOffsets[i].dv = 0;
11748:         }
11748:         return 0;
11748:     }
11748: 
11748:     HRESULT Place() {
11748:         mOffsets.SetLength(mNumGlyphs);
11748:         mAdvances.SetLength(mNumGlyphs);
11748: 
11748:         PRBool allCJK = PR_TRUE;
12992: 
13439:         // Some fonts don't get along with Uniscribe so we'll use GDI to
13439:         // render them.
13439:         if (!mCurrentFont->GetFontEntry()->mForceGDI) {
11748:             for (PRUint32 i = 0; i < mRangeLength; i++) {
11748:                 const PRUnichar ch = mRangeString[i];
11748:                 if (ch == ' ' || FindCharUnicodeRange(ch) == kRangeSetCJK)
11748:                     continue;
11748: 
11748:                 allCJK = PR_FALSE;
11748:                 break;
11748:             }
12992:         }
11748: 
13439:         if (allCJK || mCurrentFont->GetFontEntry()->mForceGDI)
11748:             return PlaceGDI();
11748: 
11748:         return PlaceUniscribe();
11748:     }
11748: 
    1:     const SCRIPT_PROPERTIES *ScriptProperties() {
    1:         /* we can use this to figure out in some cases the language of the item */
    1:         static const SCRIPT_PROPERTIES **gScriptProperties;
    1:         static int gMaxScript = -1;
    1: 
    1:         if (gMaxScript == -1) {
    1:             ScriptGetProperties(&gScriptProperties, &gMaxScript);
    1:         }
    1:         return gScriptProperties[mScript];
    1:     }
    1: 
    1:     void ScriptFontProperties(SCRIPT_FONTPROPERTIES *sfp) {
    1:         HRESULT rv;
    1: 
    1:         memset(sfp, 0, sizeof(SCRIPT_FONTPROPERTIES));
    1:         sfp->cBytes = sizeof(SCRIPT_FONTPROPERTIES);
    1:         rv = ScriptGetFontProperties(NULL, mCurrentFont->ScriptCache(),
    1:                                      sfp);
    1:         if (rv == E_PENDING) {
    1:             SelectFont();
    1:             rv = ScriptGetFontProperties(mDC, mCurrentFont->ScriptCache(),
    1:                                          sfp);
    1:         }
    1:     }
    1: 
    1:     void SetupClusterBoundaries(gfxTextRun *aRun, PRUint32 aOffsetInRun) {
    1:         if (aRun->GetFlags() & gfxTextRunFactory::TEXT_IS_8BIT)
    1:             return;
    1: 
    1:         nsAutoTArray<SCRIPT_LOGATTR,STATIC_STRING_LENGTH> logAttr;
 2252:         if (!logAttr.AppendElements(mRangeLength))
    1:             return;
 2252:         HRESULT rv = ScriptBreak(mRangeString, mRangeLength,
 2252:                                  &mScriptItem->a, logAttr.Elements());
    1:         if (FAILED(rv))
    1:             return;
    1:         gfxTextRun::CompressedGlyph g;
  277:         // The first character is never inside a cluster. Windows might tell us
  277:         // that it should be, but we have no before-character to cluster
  277:         // it with so we just can't cluster it. So skip it here.
 2252:         for (PRUint32 i = 1; i < mRangeLength; ++i) {
    1:             if (!logAttr[i].fCharStop) {
 7715:                 aRun->SetGlyphs(i + aOffsetInRun, g.SetComplex(PR_FALSE, PR_TRUE, 0), nsnull);
    1:             }
    1:         }
    1:     }
    1: 
    1:     void SaveGlyphs(gfxTextRun *aRun) {
 2252:         PRUint32 offsetInRun = mScriptItem->iCharPos + (mRangeString - mItemString);
    1:         SetupClusterBoundaries(aRun, offsetInRun);
    1: 
  132:         aRun->AddGlyphRun(GetCurrentFont(), offsetInRun);
  132: 
    1:         // XXX We should store this in the item and only fetch it once
    1:         SCRIPT_FONTPROPERTIES sfp;
    1:         ScriptFontProperties(&sfp);
    1: 
    1:         PRUint32 offset = 0;
    1:         nsAutoTArray<gfxTextRun::DetailedGlyph,1> detailedGlyphs;
    1:         gfxTextRun::CompressedGlyph g;
    1:         const PRUint32 appUnitsPerDevUnit = aRun->GetAppUnitsPerDevUnit();
 2252:         while (offset < mRangeLength) {
    1:             PRUint32 runOffset = offsetInRun + offset;
    1:             if (offset > 0 && mClusters[offset] == mClusters[offset - 1]) {
 7715:                 g.SetComplex(aRun->IsClusterStart(runOffset), PR_FALSE, 0);
 7715:                 aRun->SetGlyphs(runOffset, g, nsnull);
    1:             } else {
    1:                 // Count glyphs for this character
    1:                 PRUint32 k = mClusters[offset];
    1:                 PRUint32 glyphCount = mNumGlyphs - k;
    1:                 PRUint32 nextClusterOffset;
  282:                 PRBool missing = IsGlyphMissing(&sfp, k);
 2252:                 for (nextClusterOffset = offset + 1; nextClusterOffset < mRangeLength; ++nextClusterOffset) {
    1:                     if (mClusters[nextClusterOffset] > k) {
    1:                         glyphCount = mClusters[nextClusterOffset] - k;
    1:                         break;
    1:                     }
    1:                 }
    1:                 PRUint32 j;
    1:                 for (j = 1; j < glyphCount; ++j) {
  282:                     if (IsGlyphMissing(&sfp, k + j)) {
    1:                         missing = PR_TRUE;
    1:                     }
    1:                 }
    1:                 PRInt32 advance = mAdvances[k]*appUnitsPerDevUnit;
    1:                 WORD glyph = mGlyphs[k];
 3119:                 NS_ASSERTION(!gfxFontGroup::IsInvalidChar(mRangeString[offset]),
 3119:                 		     "invalid character detected");
 3119:                 if (missing) {
 6135:                     if (NS_IS_HIGH_SURROGATE(mRangeString[offset]) &&
 6135:                         offset + 1 < mRangeLength &&
 6135:                         NS_IS_LOW_SURROGATE(mRangeString[offset + 1])) {
 6135:                         aRun->SetMissingGlyph(runOffset,
 6135:                                               SURROGATE_TO_UCS4(mRangeString[offset],
 6135:                                                                 mRangeString[offset + 1]));
 6135:                     } else {
 2252:                         aRun->SetMissingGlyph(runOffset, mRangeString[offset]);
 6135:                     }
    1:                 } else if (glyphCount == 1 && advance >= 0 &&
    1:                     mOffsets[k].dv == 0 && mOffsets[k].du == 0 &&
    1:                     gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&
    1:                     gfxTextRun::CompressedGlyph::IsSimpleGlyphID(glyph)) {
 7715:                     aRun->SetSimpleGlyph(runOffset, g.SetSimpleGlyph(advance, glyph));
    1:                 } else {
    1:                     if (detailedGlyphs.Length() < glyphCount) {
    1:                         if (!detailedGlyphs.AppendElements(glyphCount - detailedGlyphs.Length()))
    1:                             return;
    1:                     }
    1:                     PRUint32 i;
    1:                     for (i = 0; i < glyphCount; ++i) {
    1:                         gfxTextRun::DetailedGlyph *details = &detailedGlyphs[i];
    1:                         details->mGlyphID = mGlyphs[k + i];
    1:                         details->mAdvance = mAdvances[k + i]*appUnitsPerDevUnit;
  780:                         details->mXOffset = float(mOffsets[k + i].du)*appUnitsPerDevUnit*aRun->GetDirection();
    1:                         details->mYOffset = float(mOffsets[k + i].dv)*appUnitsPerDevUnit;
    1:                     }
 7715:                     aRun->SetGlyphs(runOffset,
 7715:                         g.SetComplex(PR_TRUE, PR_TRUE, glyphCount), detailedGlyphs.Elements());
    1:                 }
    1:             }
    1:             ++offset;
    1:         }
    1:     }
    1: 
    1:     void SetCurrentFont(gfxWindowsFont *aFont) {
    1:         if (mCurrentFont != aFont) {
    1:             mCurrentFont = aFont;
 4304:             cairo_scaled_font_t *scaledFont = mCurrentFont->CairoScaledFont();
 4304:             cairo_win32_scaled_font_done_font(scaledFont);
    1:             mFontSelected = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     gfxWindowsFont *GetCurrentFont() {
    1:         return mCurrentFont;
    1:     }
    1: 
    1:     void SelectFont() {
    1:         if (mFontSelected)
    1:             return;
    1: 
    1:         cairo_t *cr = mContext->GetCairo();
    1: 
    1:         cairo_set_font_face(cr, mCurrentFont->CairoFontFace());
    1:         cairo_set_font_size(cr, mCurrentFont->GetAdjustedSize());
 4304:         cairo_scaled_font_t *scaledFont = mCurrentFont->CairoScaledFont();
 4304:         cairo_win32_scaled_font_select_font(scaledFont, mDC);
    1: 
    1:         mFontSelected = PR_TRUE;
    1:     }
    1: 
 2252:     struct TextRange {
 2252:         TextRange(PRUint32 aStart,  PRUint32 aEnd) : start(aStart), end(aEnd) { }
 2252:         PRUint32 Length() const { return end - start; }
 2252:         nsRefPtr<FontEntry> font;
 2252:         PRUint32 start, end;
 2252:     };
 2252: 
 2252:     void SetRange(PRUint32 i) {
 2252:         nsRefPtr<FontEntry> fe;
 2252:         if (mRanges[i].font)
 2252:             fe = mRanges[i].font;
 2252:         else
 2252:             fe = mGroup->GetFontEntryAt(0);
 2252: 
 2252:         nsRefPtr<gfxWindowsFont> font = GetOrMakeFont(fe, mGroup->GetStyle());
 2252:         SetCurrentFont(font);
 2252: 
 2252:         mRangeString = mItemString + mRanges[i].start;
 2252:         mRangeLength = mRanges[i].Length();
 2252:     }
 2252: 
13097:     PRBool HasCharacter(FontEntry *aFontEntry, PRUint32 ch) {
13097:         if (aFontEntry->mCharacterMap.test(ch))
13097:             return PR_TRUE;
13097: 
13439:         if (aFontEntry->mForceGDI) {
13097:             if (ch > 0xFFFF)
13097:                 return PR_FALSE;
13097: 
13097:             nsRefPtr<gfxWindowsFont> font = GetOrMakeFont(aFontEntry, mGroup->GetStyle());
13097: 
13097:             HDC dc = GetDC((HWND)nsnull);
13097:             HFONT hfont = font->GetHFONT();
13097:             SelectObject(dc, hfont);
13097: 
13097:             PRUnichar str[1] = { (PRUnichar)ch };
13097:             WORD glyph[1];
13097: 
13097:             DWORD ret = GetGlyphIndicesW(dc, str, 1, glyph, GGI_MARK_NONEXISTING_GLYPHS);
13097: 
13097:             ReleaseDC(NULL, dc);
13097:             if (ret != GDI_ERROR && glyph[0] != 0xFFFF) {
13097:                 aFontEntry->mCharacterMap.set(ch);
13097:                 return PR_TRUE;
13097:             }
13097:         }
13097: 
13097:         return PR_FALSE;
13097:     }
13097: 
13097:     inline FontEntry *WhichFontSupportsChar(const nsTArray<nsRefPtr<FontEntry> >& fonts, PRUint32 ch) {
 2252:         for (PRUint32 i = 0; i < fonts.Length(); i++) {
 2252:             nsRefPtr<FontEntry> fe = fonts[i];
13097:             if (HasCharacter(fe, ch))
 2252:                 return fe;
 2252:         }
 2252:         return nsnull;
 2252:     }
 2252: 
 2252: 
 2307:     static inline bool IsJoiner(PRUint32 ch) {
 2307:         return (ch == 0x200C ||
 2307:                 ch == 0x200D ||
 2307:                 ch == 0x2060);
 2307:     }
 2307: 
 2307:     inline FontEntry *FindFontForChar(PRUint32 ch, PRUint32 prevCh, PRUint32 nextCh, FontEntry *aFont) {
 2252:         nsRefPtr<FontEntry> selectedFont;
 2252: 
 2307:         // if this character or the next one is a joiner use the
 2307:         // same font as the previous range if we can
 2307:         if (IsJoiner(ch) || IsJoiner(prevCh) || IsJoiner(nextCh)) {
13097:             if (aFont && HasCharacter(aFont, ch))
 2307:                 return aFont;
 2307:         }
 2307: 
 2252:         // check the list of fonts
 2252:         selectedFont = WhichFontSupportsChar(mGroup->GetFontList(), ch);
 2252: 
 7375:         // don't look in other fonts if the character is in a Private Use Area
 7375:         if ((ch >= 0xE000  && ch <= 0xF8FF) || 
 7375:             (ch >= 0xF0000 && ch <= 0x10FFFD))
 7375:             return selectedFont;
 7375: 
 2252:         // otherwise search prefs
 2252:         if (!selectedFont) {
 2252:             /* first check with the script properties to see what they think */
 2252:             const SCRIPT_PROPERTIES *sp = ScriptProperties();
 2252:             if (!sp->fAmbiguousCharSet) {
 2252:                 WORD primaryId = PRIMARYLANGID(sp->langid);
 2252:                 const char *langGroup = gScriptToText[primaryId].langCode;
 2252:                 if (langGroup) {
 2252:                     PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Trying to find fonts for: %s (%s)", langGroup, gScriptToText[primaryId].value));
 2252: 
 5254:                     nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
 2252:                     this->GetPrefFonts(langGroup, fonts);
 2252:                     selectedFont = WhichFontSupportsChar(fonts, ch);
 2252:                 }
 2773:             } else if (ch <= 0xFFFF) {
 2252:                 PRUint32 unicodeRange = FindCharUnicodeRange(ch);
 2252: 
 2252:                 /* special case CJK */
 2252:                 if (unicodeRange == kRangeSetCJK) {
 2252:                     if (PR_LOG_TEST(gFontLog, PR_LOG_DEBUG))
 2252:                         PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Trying to find fonts for: CJK"));
 2252: 
 5254:                     nsAutoTArray<nsRefPtr<FontEntry>, 15> fonts;
 2252:                     this->GetCJKPrefFonts(fonts);
 2252:                     selectedFont = WhichFontSupportsChar(fonts, ch);
 2252:                 } else {
 2252:                     const char *langGroup = LangGroupFromUnicodeRange(unicodeRange);
 2252:                     if (langGroup) {
 2252:                         PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Trying to find fonts for: %s", langGroup));
 2252: 
 5254:                         nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
 2252:                         this->GetPrefFonts(langGroup, fonts);
 2252:                         selectedFont = WhichFontSupportsChar(fonts, ch);
 2252:                     }
 2252:                 }
 2252:             }
 2773:         }
 2252: 
 2252:         // before searching for something else check the font used for the previous character
13097:         if (!selectedFont && aFont && HasCharacter(aFont, ch))
 2252:             selectedFont = aFont;
 2252: 
 2252:         // otherwise look for other stuff
 2252:         if (!selectedFont) {
 2252:             PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Looking for best match"));
 2252: 
 2252:             nsRefPtr<gfxWindowsFont> refFont = mGroup->GetFontAt(0);
 2252:             gfxWindowsPlatform *platform = gfxWindowsPlatform::GetPlatform();
12526:             selectedFont = platform->FindFontForChar(ch, refFont);
 2252:         }
 2252: 
 2252:         return selectedFont;
 2252:     }
 2252: 
 2252:     PRUint32 ComputeRanges() {
 2252:         if (mItemLength == 0)
 2252:             return 0;
 2252: 
 2773:         /* disable font fallback when using symbol fonts */
 2773:         if (mGroup->GetFontEntryAt(0)->mSymbolFont) {
 2773:             TextRange r(0,mItemLength);
 2773:             mRanges.AppendElement(r);
 2773:             return 1;
 2773:         }
 2773: 
 2252:         PR_LOG(gFontLog, PR_LOG_DEBUG, ("Computing ranges for string: (len = %d)", mItemLength));
 2307: 
 2307:         PRUint32 prevCh = 0;
 2252:         for (PRUint32 i = 0; i < mItemLength; i++) {
 2252:             const PRUint32 origI = i; // save off incase we increase for surrogate
 2252:             PRUint32 ch = mItemString[i];
 2252:             if ((i+1 < mItemLength) && NS_IS_HIGH_SURROGATE(ch) && NS_IS_LOW_SURROGATE(mItemString[i+1])) {
 2252:                 i++;
 2252:                 ch = SURROGATE_TO_UCS4(ch, mItemString[i]);
 2252:             }
 2252: 
 2252:             PR_LOG(gFontLog, PR_LOG_DEBUG, (" 0x%04x - ", ch));
 2307:             PRUint32 nextCh = 0;
 2307:             if (i+1 < mItemLength) {
 2307:                 nextCh = mItemString[i+1];
 2307:                 if ((i+2 < mItemLength) && NS_IS_HIGH_SURROGATE(ch) && NS_IS_LOW_SURROGATE(mItemString[i+2]))
 2307:                     nextCh = SURROGATE_TO_UCS4(nextCh, mItemString[i+2]);
 2307:             }
 2307:             nsRefPtr<FontEntry> fe = FindFontForChar(ch,
 2307:                                                      prevCh,
 2307:                                                      nextCh,
 2307:                                                      (mRanges.Length() == 0) ? nsnull : mRanges[mRanges.Length() - 1].font);
 2307: 
 2307:             prevCh = ch;
 2252: 
 2252:             if (mRanges.Length() == 0) {
 2252:                 TextRange r(0,1);
 2252:                 r.font = fe;
 2252:                 mRanges.AppendElement(r);
 2252:             } else {
 2252:                 TextRange& prevRange = mRanges[mRanges.Length() - 1];
 2252:                 if (prevRange.font != fe) {
 2252:                     // close out the previous range
 2252:                     prevRange.end = origI;
 2252: 
10830:                     TextRange r(origI, i+1);
 2252:                     r.font = fe;
 2252:                     mRanges.AppendElement(r);
 2252:                 }
 2252:             }
 2307:             if (PR_LOG_TEST(gFontLog, PR_LOG_DEBUG)) {
 2307:                 if (fe)
13280:                     PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Using %s", NS_LossyConvertUTF16toASCII(fe->GetName()).get()));
 2307:                 else
 2307:                     PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Unable to find font"));
 2307:             }
 2252:         }
 2252:         mRanges[mRanges.Length()-1].end = mItemLength;
 2252: 
 2252:         PRUint32 nranges = mRanges.Length();
 2252:         PR_LOG(gFontLog, PR_LOG_DEBUG, (" Found %d ranges", nranges));
 2252:         return nranges;
 2252:     }
 2252: 
    1: private:
    1:     static PRInt32 GetCJKLangGroupIndex(const char *aLangGroup) {
    1:         PRInt32 i;
    1:         for (i = 0; i < COUNT_OF_CJK_LANG_GROUP; i++) {
    1:             if (!PL_strcasecmp(aLangGroup, sCJKLangGroup[i]))
    1:                 return i;
    1:         }
    1:         return -1;
    1:     }
    1: 
 5259:     // this function appends to the array passed in.
 2252:     void GetPrefFonts(const char *aLangGroup, nsTArray<nsRefPtr<FontEntry> >& array) {
    1:         NS_ASSERTION(aLangGroup, "aLangGroup is null");
 5254:         gfxWindowsPlatform *platform = gfxWindowsPlatform::GetPlatform();
 5254:         nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
13280:         /* this lookup has to depend on weight and style */
13280:         nsCAutoString key(aLangGroup);
13280:         key.Append("-");
13280:         key.AppendInt(mGroup->GetStyle()->style);
13280:         key.Append("-");
13280:         key.AppendInt(mGroup->GetStyle()->weight);
13280:         if (!platform->GetPrefFontEntries(key, &fonts)) {
 5254:             nsString fontString;
 5254:             platform->GetPrefFonts(aLangGroup, fontString);
 5254:             if (fontString.IsEmpty())
    1:                 return;
 5254: 
13280:             mGroup->FamilyListToArrayList(fontString, nsDependentCString(aLangGroup),
13280:                                           &fonts);
13280: 
13280:             platform->SetPrefFontEntries(key, fonts);
 5254:         }
 5254:         array.AppendElements(fonts);
    1:     }
    1: 
 5259:     // this function assigns to the array passed in.
 2252:     void GetCJKPrefFonts(nsTArray<nsRefPtr<FontEntry> >& array) {
 5259:         gfxWindowsPlatform *platform = gfxWindowsPlatform::GetPlatform();
13280: 
13280:         nsCAutoString key("x-internal-cjk-");
13280:         key.AppendInt(mGroup->GetStyle()->style);
13280:         key.Append("-");
13280:         key.AppendInt(mGroup->GetStyle()->weight);
13280: 
13280:         if (!platform->GetPrefFontEntries(key, &array)) {
    1:             nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:             if (!prefs)
    1:                 return;
    1: 
    1:             nsCOMPtr<nsIPrefBranch> prefBranch;
    1:             prefs->GetBranch(0, getter_AddRefs(prefBranch));
    1:             if (!prefBranch)
    1:                 return;
    1: 
11466:             // Add the CJK pref fonts from accept languages, the order should be same order
11466:             nsCAutoString list;
11466:             nsCOMPtr<nsIPrefLocalizedString> val;
11466:             nsresult rv = prefBranch->GetComplexValue("intl.accept_languages", NS_GET_IID(nsIPrefLocalizedString),
11466:                                                       getter_AddRefs(val));
11466:             if (NS_SUCCEEDED(rv) && val) {
11466:                 nsAutoString temp;
11466:                 val->ToString(getter_Copies(temp));
11466:                 LossyCopyUTF16toASCII(temp, list);
11466:             }
11466:             if (!list.IsEmpty()) {
    1:                 const char kComma = ',';
    1:                 const char *p, *p_end;
    1:                 list.BeginReading(p);
    1:                 list.EndReading(p_end);
    1:                 while (p < p_end) {
    1:                     while (nsCRT::IsAsciiSpace(*p)) {
    1:                         if (++p == p_end)
    1:                             break;
    1:                     }
    1:                     if (p == p_end)
    1:                         break;
    1:                     const char *start = p;
    1:                     while (++p != p_end && *p != kComma)
    1:                         /* nothing */ ;
    1:                     nsCAutoString lang(Substring(start, p));
    1:                     lang.CompressWhitespace(PR_FALSE, PR_TRUE);
    1:                     PRInt32 index = GetCJKLangGroupIndex(lang.get());
    1:                     if (index >= 0)
 2252:                         GetPrefFonts(sCJKLangGroup[index], array);
    1:                     p++;
    1:                 }
    1:             }
    1: 
    1:             // Add the system locale
    1:             switch (::GetACP()) {
 2252:                 case 932: GetPrefFonts(CJK_LANG_JA, array); break;
 2252:                 case 936: GetPrefFonts(CJK_LANG_ZH_CN, array); break;
 2252:                 case 949: GetPrefFonts(CJK_LANG_KO, array); break;
    1:                 // XXX Don't we need to append CJK_LANG_ZH_HK if the codepage is 950?
 2252:                 case 950: GetPrefFonts(CJK_LANG_ZH_TW, array); break;
    1:             }
    1: 
    1:             // last resort...
 2252:             GetPrefFonts(CJK_LANG_JA, array);
 2252:             GetPrefFonts(CJK_LANG_KO, array);
 2252:             GetPrefFonts(CJK_LANG_ZH_CN, array);
 2252:             GetPrefFonts(CJK_LANG_ZH_HK, array);
 2252:             GetPrefFonts(CJK_LANG_ZH_TW, array);
 5259: 
13280:             platform->SetPrefFontEntries(key, array);
 5259:         }
    1:     }
    1: 
    1:     void GenerateAlternativeString() {
    1:         if (mAlternativeString)
    1:             free(mAlternativeString);
 2252:         mAlternativeString = (PRUnichar *)malloc(mRangeLength * sizeof(PRUnichar));
 7030:         if (!mAlternativeString)
 7030:             return;
 2252:         memcpy((void *)mAlternativeString, (const void *)mRangeString,
 2252:                mRangeLength * sizeof(PRUnichar));
 2308:         for (PRUint32 i = 0; i < mRangeLength; i++) {
 2252:             if (NS_IS_HIGH_SURROGATE(mRangeString[i]) || NS_IS_LOW_SURROGATE(mRangeString[i]))
    1:                 mAlternativeString[i] = PRUnichar(0xFFFD);
    1:         }
    1:     }
 1959: 
    1: private:
    1:     nsRefPtr<gfxContext> mContext;
    1:     HDC mDC;
    1: 
    1:     SCRIPT_ITEM *mScriptItem;
    1:     WORD mScript;
    1: 
 2252:     // these point to the current range
 2252:     const PRUnichar *mRangeString;
 2252:     PRUint32 mRangeLength;
 2252: 
 2252:     // these point to the full string/length of the item
 2252:     const PRUnichar *mItemString;
 2252:     const PRUint32 mItemLength;
    1: 
    1:     PRUnichar *mAlternativeString;
    1: 
    1:     gfxWindowsFontGroup *mGroup;
    1: 
 5393: #define AVERAGE_ITEM_LENGTH 40
 5393: 
 7625:     nsAutoTArray<WORD, PRUint32(ESTIMATE_MAX_GLYPHS(AVERAGE_ITEM_LENGTH))> mGlyphs;
 6076:     nsAutoTArray<WORD, AVERAGE_ITEM_LENGTH + 1> mClusters;
 7625:     nsAutoTArray<SCRIPT_VISATTR, PRUint32(ESTIMATE_MAX_GLYPHS(AVERAGE_ITEM_LENGTH))> mAttr;
 5393:  
 6076:     nsAutoTArray<GOFFSET, 2 * AVERAGE_ITEM_LENGTH> mOffsets;
 6076:     nsAutoTArray<int, 2 * AVERAGE_ITEM_LENGTH> mAdvances;
 5393: 
 5393: #undef AVERAGE_ITEM_LENGTH
    1: 
    1:     int mMaxGlyphs;
    1:     int mNumGlyphs;
    1: 
    1:     nsRefPtr<gfxWindowsFont> mCurrentFont;
    1: 
    1:     PRPackedBool mFontSelected;
 2252: 
 2252:     nsTArray<TextRange> mRanges;
    1: };
    1: 
 7625: 
 7625: #define MAX_ITEM_LENGTH 32768
 7625: 
 7625: 
 7625: 
 7625: static PRUint32 FindNextItemStart(int aOffset, int aLimit,
 7625:                                   nsTArray<SCRIPT_LOGATTR> &aLogAttr,
 7625:                                   const PRUnichar *aString)
 7625: {
 7625:     if (aOffset + MAX_ITEM_LENGTH >= aLimit) {
 7625:         // The item starting at aOffset can't be longer than the max length,
 7625:         // so starting the next item at aLimit won't cause ScriptShape() to fail.
 7625:         return aLimit;
 7625:     }
 7625: 
 7625:     // Try to start the next item before or after a space, since spaces
 7625:     // don't kern or ligate.
 7625:     PRUint32 off;
 7625:     int boundary = -1;
 7625:     for (off = MAX_ITEM_LENGTH; off > 1; --off) {
 7625:       if (aLogAttr[off].fCharStop) {
 7625:           if (off > boundary) {
 7625:               boundary = off;
 7625:           }
 7625:           if (aString[aOffset+off] == ' ' || aString[aOffset+off - 1] == ' ')
 7625:             return aOffset+off;
 7625:       }
 7625:     }
 7625: 
 7625:     // Try to start the next item at the last cluster boundary in the range.
 7625:     if (boundary > 0) {
 7625:       return aOffset+boundary;
 7625:     }
 7625: 
 7625:     // No nice cluster boundaries inside MAX_ITEM_LENGTH characters, break
 7625:     // on the size limit. It won't be visually plesaing, but at least it
 7625:     // won't cause ScriptShape() to fail.
 7625:     return aOffset + MAX_ITEM_LENGTH;
 7625: }
 7625: 
    1: class Uniscribe
    1: {
    1: public:
    1:     Uniscribe(gfxContext *aContext, HDC aDC, const PRUnichar *aString, PRUint32 aLength, PRBool aIsRTL) :
    1:         mContext(aContext), mDC(aDC), mString(aString), mLength(aLength), mIsRTL(aIsRTL),
    1:         mItems(nsnull) {
    1:     }
  282:     ~Uniscribe() {
  282:     }
    1: 
    1:     void Init() {
    1:         memset(&mControl, 0, sizeof(SCRIPT_CONTROL));
    1:         memset(&mState, 0, sizeof(SCRIPT_STATE));
    1:         // Lock the direction. Don't allow the itemizer to change directions
    1:         // based on character type.
    1:         mState.uBidiLevel = mIsRTL;
    1:         mState.fOverrideDirection = PR_TRUE;
    1:     }
    1: 
 7625: private:
 7625: 
 7625:     // Append mItems[aIndex] to aDest, adding extra items to aDest to ensure
 7625:     // that no item is too long for ScriptShape() to handle. See bug 366643.
 7625:     nsresult CopyItemSplitOversize(int aIndex, nsTArray<SCRIPT_ITEM> &aDest) {
 7625:         aDest.AppendElement(mItems[aIndex]);
 7625:         const int itemLength = mItems[aIndex+1].iCharPos - mItems[aIndex].iCharPos;
 7625:         if (ESTIMATE_MAX_GLYPHS(itemLength) > 65535) {
 7625:             // This items length would cause ScriptShape() to fail. We need to
 7625:             // add extra items here so that no item's length could cause the fail.
 7625: 
 7625:             // Get cluster boundaries, so we can break cleanly if possible.
 7625:             nsTArray<SCRIPT_LOGATTR> logAttr;
 7625:             if (!logAttr.SetLength(itemLength))
 7625:                 return NS_ERROR_FAILURE;
 7625:             HRESULT rv= ScriptBreak(mString+mItems[aIndex].iCharPos, itemLength,
 7625:                                     &mItems[aIndex].a, logAttr.Elements());
 7625:             if (FAILED(rv))
 7625:                 return NS_ERROR_FAILURE;
 7625: 
 7625:             const int nextItemStart = mItems[aIndex+1].iCharPos;
 7625:             int start = FindNextItemStart(mItems[aIndex].iCharPos,
 7625:                                           nextItemStart, logAttr, mString);
 7625: 
 7625:             while (start < nextItemStart) {
 7625:                 SCRIPT_ITEM item = mItems[aIndex];
 7625:                 item.iCharPos = start;
 7625:                 aDest.AppendElement(item);
 7625:                 start = FindNextItemStart(start, nextItemStart, logAttr, mString);
 7625:             }
 7625:         } 
 7625:         return NS_OK;
 7625:     }
 7625: 
 7625: public:
 7625: 
    1:     int Itemize() {
    1:         HRESULT rv;
    1: 
    1:         int maxItems = 5;
    1: 
    1:         Init();
 7625: 
  808:         // Allocate space for one more item than expected, to handle a rare
  808:         // overflow in ScriptItemize (pre XP SP2). See bug 366643.
 7625:         if (!mItems.SetLength(maxItems + 1)) {
 7625:             return 0;
 7625:         }
    1:         while ((rv = ScriptItemize(mString, mLength, maxItems, &mControl, &mState,
 7625:                                    mItems.Elements(), &mNumItems)) == E_OUTOFMEMORY) {
    1:             maxItems *= 2;
 7625:             if (!mItems.SetLength(maxItems + 1)) {
 7625:                 return 0;
 7625:             }
    1:             Init();
    1:         }
    1: 
 7625:         if (ESTIMATE_MAX_GLYPHS(mLength) > 65535) {
 7625:             // Any item of length > 43680 will cause ScriptShape() to fail, as its
 7625:             // mMaxGlyphs value will be greater than 65535 (43680*1.5+16>65535). So we
 7625:             // need to break up items which are longer than that upon cluster boundaries.
 7625:             // See bug 394751 for details.
 7625:             nsTArray<SCRIPT_ITEM> items;
 7625:             for (int i=0; i<mNumItems; i++) {
 7625:                 nsresult nrs = CopyItemSplitOversize(i, items);
 7625:                 NS_ASSERTION(NS_SUCCEEDED(nrs), "CopyItemSplitOversize() failed");
 7625:             }
 7625:             items.AppendElement(mItems[mNumItems]); // copy terminator.
 7625: 
 7625:             mItems = items;
 7625:             mNumItems = items.Length() - 1; // Don't count the terminator.
 7625:         }
    1:         return mNumItems;
    1:     }
    1: 
    1:     PRUint32 ItemsLength() {
    1:         return mNumItems;
    1:     }
    1: 
    1:     // XXX Why do we dynamically allocate this? We could just fill in an object
    1:     // on the stack.
    1:     UniscribeItem *GetItem(PRUint32 i, gfxWindowsFontGroup *aGroup) {
    1:         NS_ASSERTION(i < (PRUint32)mNumItems, "Trying to get out of bounds item");
    1: 
    1:         UniscribeItem *item = new UniscribeItem(mContext, mDC,
    1:                                                 mString + mItems[i].iCharPos,
    1:                                                 mItems[i+1].iCharPos - mItems[i].iCharPos,
    1:                                                 &mItems[i],
    1:                                                 aGroup);
    1: 
    1:         return item;
    1:     }
    1: 
    1: private:
    1:     nsRefPtr<gfxContext> mContext;
    1:     HDC mDC;
    1:     const PRUnichar *mString;
    1:     const PRUint32 mLength;
    1:     const PRBool mIsRTL;
    1: 
    1:     SCRIPT_CONTROL mControl;
    1:     SCRIPT_STATE   mState;
 7625:     nsTArray<SCRIPT_ITEM> mItems;
    1:     int mNumItems;
    1: };
    1: 
    1: void
    1: gfxWindowsFontGroup::InitTextRunUniscribe(gfxContext *aContext, gfxTextRun *aRun, const PRUnichar *aString,
    1:                                           PRUint32 aLength)
    1: {
 4363:     DCFromContext aDC(aContext);
    1:  
    1:     const PRBool isRTL = aRun->IsRightToLeft();
    1: 
    1:     HRESULT rv;
    1: 
    1:     Uniscribe us(aContext, aDC, aString, aLength, isRTL);
    1: 
    1:     /* itemize the string */
    1:     int numItems = us.Itemize();
    1: 
    1:     for (int i = 0; i < numItems; ++i) {
    1:         SaveDC(aDC);
    1: 
13439:         nsAutoPtr<UniscribeItem> item = us.GetItem(i, this);
    1: 
 2252:         PRUint32 nranges = item->ComputeRanges();
    1: 
 2252:         for (PRUint32 j = 0; j < nranges; ++j) {
    1: 
 2252:             item->SetRange(j);
    1: 
 2252:             if (!item->ShapingEnabled())
 2252:                 item->EnableShaping();
    1: 
 7625:             rv = item->Shape();
 7625:             if (FAILED(rv)) {
 2252:                 PR_LOG(gFontLog, PR_LOG_DEBUG, ("shaping failed"));
 1959:                 // we know we have the glyphs to display this font already
 1959:                 // so Uniscribe just doesn't know how to shape the script.
 1959:                 // Render the glyphs without shaping.
 1959:                 item->DisableShaping();
 7625:                 rv = item->Shape();
 1959:             }
  282: 
    1:             NS_ASSERTION(SUCCEEDED(rv), "Failed to shape -- we should never hit this");
    1: 
    1:             rv = item->Place();
 2252:             NS_ASSERTION(SUCCEEDED(rv), "Failed to place -- this is pretty bad.");
    1: 
13439:             if (FAILED(rv)) {
13439:                 aRun->ResetGlyphRuns();
13439: 
13439:                 /* Uniscribe doesn't like this font, use GDI instead */
13439:                 item->GetCurrentFont()->GetFontEntry()->mForceGDI = PR_TRUE;
13439:                 break;
13439:             }
13439: 
    1:             item->SaveGlyphs(aRun);
 2252:         }
 1959: 
13439:         RestoreDC(aDC, -1);
    1: 
13439:         if (FAILED(rv)) {
13439:             i = -1;
    1:         }
    1:     }
13439: }
