 54855: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 54855:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 54855: 
 54855: #include "jsautooplen.h"
 54855: 
 84803: #include "frontend/BytecodeEmitter.h"
 84803: 
 57755: namespace js {
 57755: 
 87171: static inline PropertyName *
103195: GetNameFromBytecode(JSContext *cx, JSScript *script, jsbytecode *pc, JSOp op)
 87171: {
 87171:     if (op == JSOP_LENGTH)
 87171:         return cx->runtime->atomState.lengthAtom;
 87171: 
 87171:     // The method JIT's implementation of instanceof contains an internal lookup
 87171:     // of the prototype property.
 87171:     if (op == JSOP_INSTANCEOF)
 87171:         return cx->runtime->atomState.classPrototypeAtom;
 87171: 
 87171:     PropertyName *name;
 87975:     GET_NAME_FROM_BYTECODE(script, pc, 0, name);
 87171:     return name;
 87171: }
 87171: 
 75501: class BytecodeRange {
 75501:   public:
 84195:     BytecodeRange(JSScript *script)
 84195:       : script(script), pc(script->code), end(pc + script->length) {}
 75501:     bool empty() const { return pc == end; }
 75501:     jsbytecode *frontPC() const { return pc; }
 84195:     JSOp frontOpcode() const { return JSOp(*pc); }
 75501:     size_t frontOffset() const { return pc - script->code; }
 84195:     void popFront() { pc += GetBytecodeLength(pc); }
 75501: 
 75501:   private:
 75501:     JSScript *script;
 75501:     jsbytecode *pc, *end;
 75501: };
 75501: 
 84803: class SrcNoteLineScanner
 84803: {
 84803:     /* offset of the current JSOp in the bytecode */
 84803:     ptrdiff_t offset;
 84803: 
 84803:     /* next src note to process */
 84803:     jssrcnote *sn;
 84803: 
 84803:     /* line number of the current JSOp */
 84803:     uint32_t lineno;
 84803: 
 84803:     /*
 84803:      * Is the current op the first one after a line change directive? Note that
 84803:      * multiple ops may be "first" if a line directive is used to return to a
 84803:      * previous line (eg, with a for loop increment expression.)
 84803:      */
 84803:     bool lineHeader;
 84803: 
 84803: public:
 84803:     SrcNoteLineScanner(jssrcnote *sn, uint32_t lineno)
 84803:         : offset(0), sn(sn), lineno(lineno)
 84803:     {
 57755:     }
 84803: 
 84803:     /*
 84803:      * This is called repeatedly with always-advancing relpc values. The src
 84803:      * notes are tuples of <PC offset from prev src note, type, args>. Scan
 84803:      * through, updating the lineno, until the next src note is for a later
 84803:      * bytecode.
 84803:      *
 84803:      * When looking at the desired PC offset ('relpc'), the op is first in that
 84803:      * line iff there is a SRC_SETLINE or SRC_NEWLINE src note for that exact
 84803:      * bytecode.
 84803:      *
 84803:      * Note that a single bytecode may have multiple line-modifying notes (even
 84803:      * though only one should ever be needed.)
 84803:      */
 84803:     void advanceTo(ptrdiff_t relpc) {
 84803:         // Must always advance! If the same or an earlier PC is erroneously
 84803:         // passed in, we will already be past the relevant src notes
 84803:         JS_ASSERT_IF(offset > 0, relpc > offset);
 84803: 
 84803:         // Next src note should be for after the current offset
 84803:         JS_ASSERT_IF(offset > 0, SN_IS_TERMINATOR(sn) || SN_DELTA(sn) > 0);
 84803: 
 84803:         // The first PC requested is always considered to be a line header
 84803:         lineHeader = (offset == 0);
 84803: 
 84803:         if (SN_IS_TERMINATOR(sn))
 84803:             return;
 84803: 
 84803:         ptrdiff_t nextOffset;
 84803:         while ((nextOffset = offset + SN_DELTA(sn)) <= relpc && !SN_IS_TERMINATOR(sn)) {
 84803:             offset = nextOffset;
 84803:             SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
 84803:             if (type == SRC_SETLINE || type == SRC_NEWLINE) {
 84803:                 if (type == SRC_SETLINE)
 84803:                     lineno = js_GetSrcNoteOffset(sn, 0);
 84803:                 else
 84803:                     lineno++;
 84803: 
 84803:                 if (offset == relpc)
 84803:                     lineHeader = true;
 84803:             }
 84803: 
 84803:             sn = SN_NEXT(sn);
 84803:         }
 84803:     }
 84803: 
 84803:     bool isLineHeader() const {
 84803:         return lineHeader;
 84803:     }
 84803: 
 84803:     uint32_t getLine() const { return lineno; }
 84803: };
 84803: 
 84803: }
