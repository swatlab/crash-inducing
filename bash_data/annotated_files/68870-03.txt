    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developers of the Original Code are
    1:  * Sun Microsystems and IBM Corporation
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Ginn Chen (ginn.chen@sun.com)
    1:  *   Aaron Leventhal (aleventh@us.ibm.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsHyperTextAccessible.h"
41384: 
67790: #include "States.h"
    1: #include "nsAccessibilityAtoms.h"
    1: #include "nsAccessibilityService.h"
41384: #include "nsAccUtils.h"
24999: #include "nsTextAttrs.h"
16001: 
    1: #include "nsIClipboard.h"
    1: #include "nsContentCID.h"
68870: #include "nsIDOMAbstractView.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsIDOMDocument.h"
 4625: #include "nsPIDOMWindow.h"        
68870: #include "nsIDOMDocumentView.h"
    1: #include "nsIDOMRange.h"
16001: #include "nsIDOMNSRange.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIDOMXULDocument.h"
 4625: #include "nsIEditingSession.h"
 4625: #include "nsIEditor.h"
    1: #include "nsIFrame.h"
 8755: #include "nsFrameSelection.h"
 8901: #include "nsILineIterator.h"
 4625: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIPlaintextEditor.h"
 8901: #include "nsIScrollableFrame.h"
 6072: #include "nsISelection2.h"
 8755: #include "nsISelectionPrivate.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsTextFragment.h"
 4261: #include "gfxSkipChars.h"
    1: 
    1: static NS_DEFINE_IID(kRangeCID, NS_RANGE_CID);
    1: 
43504: ////////////////////////////////////////////////////////////////////////////////
    1: // nsHyperTextAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
43504: 
43504: nsHyperTextAccessible::
43504:   nsHyperTextAccessible(nsIContent *aNode, nsIWeakReference *aShell) :
61468:   nsAccessibleWrap(aNode, aShell)
43504: {
61468:   mFlags |= eHyperTextAccessible;
43504: }
    1: 
 4625: NS_IMPL_ADDREF_INHERITED(nsHyperTextAccessible, nsAccessibleWrap)
 4625: NS_IMPL_RELEASE_INHERITED(nsHyperTextAccessible, nsAccessibleWrap)
    1: 
    1: nsresult nsHyperTextAccessible::QueryInterface(REFNSIID aIID, void** aInstancePtr)
    1: {
    1:   *aInstancePtr = nsnull;
    1: 
 4751:   if (aIID.Equals(NS_GET_IID(nsHyperTextAccessible))) {
 4751:     *aInstancePtr = static_cast<nsHyperTextAccessible*>(this);
 4751:     NS_ADDREF_THIS();
 4751:     return NS_OK;
 4751:   }
 4751: 
 7766:   if (mRoleMapEntry &&
 7766:       (mRoleMapEntry->role == nsIAccessibleRole::ROLE_GRAPHIC ||
10667:        mRoleMapEntry->role == nsIAccessibleRole::ROLE_IMAGE_MAP ||
10667:        mRoleMapEntry->role == nsIAccessibleRole::ROLE_SLIDER ||
10667:        mRoleMapEntry->role == nsIAccessibleRole::ROLE_PROGRESSBAR ||
10667:        mRoleMapEntry->role == nsIAccessibleRole::ROLE_SEPARATOR)) {
 7766:     // ARIA roles that these interfaces are not appropriate for
 4847:     return nsAccessible::QueryInterface(aIID, aInstancePtr);
 4847:   }
 4847: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleText))) {
 3233:     *aInstancePtr = static_cast<nsIAccessibleText*>(this);
    1:     NS_ADDREF_THIS();
    1:     return NS_OK;
    1:   }
 4341: 
 4341:   if (aIID.Equals(NS_GET_IID(nsIAccessibleHyperText))) {
 3233:     *aInstancePtr = static_cast<nsIAccessibleHyperText*>(this);
    1:     NS_ADDREF_THIS();
    1:     return NS_OK;
    1:   }
 4341: 
 4341:   if (aIID.Equals(NS_GET_IID(nsIAccessibleEditableText))) {
 3233:     *aInstancePtr = static_cast<nsIAccessibleEditableText*>(this);
    1:     NS_ADDREF_THIS();
    1:     return NS_OK;
    1:   }
    1: 
    1:   return nsAccessible::QueryInterface(aIID, aInstancePtr);
    1: }
    1: 
52027: PRUint32
52027: nsHyperTextAccessible::NativeRole()
    1: {
43504:   nsIAtom *tag = mContent->Tag();
    1: 
52027:   if (tag == nsAccessibilityAtoms::form)
52027:     return nsIAccessibleRole::ROLE_FORM;
52027: 
58338:   if (tag == nsAccessibilityAtoms::blockquote ||
57107:       tag == nsAccessibilityAtoms::div ||
57107:       tag == nsAccessibilityAtoms::nav)
52027:     return nsIAccessibleRole::ROLE_SECTION;
52027: 
52027:   if (tag == nsAccessibilityAtoms::h1 ||
    1:       tag == nsAccessibilityAtoms::h2 ||
    1:       tag == nsAccessibilityAtoms::h3 ||
    1:       tag == nsAccessibilityAtoms::h4 ||
    1:       tag == nsAccessibilityAtoms::h5 ||
52027:       tag == nsAccessibilityAtoms::h6)
52027:     return nsIAccessibleRole::ROLE_HEADING;
52027: 
58338:   if (tag == nsAccessibilityAtoms::article)
58338:     return nsIAccessibleRole::ROLE_DOCUMENT;
58338:         
57107:   // Deal with html landmark elements
57107:   if (tag == nsAccessibilityAtoms::header)
57107:     return nsIAccessibleRole::ROLE_HEADER;
57107: 
57107:   if (tag == nsAccessibilityAtoms::footer)
57107:     return nsIAccessibleRole::ROLE_FOOTER;
57107: 
57522:   if (tag == nsAccessibilityAtoms::aside)
57522:     return nsIAccessibleRole::ROLE_NOTE;
57522: 
57107:   // Treat block frames as paragraphs
    1:   nsIFrame *frame = GetFrame();
23749:   if (frame && frame->GetType() == nsAccessibilityAtoms::blockFrame &&
23749:       frame->GetContent()->Tag() != nsAccessibilityAtoms::input) {
23749:     // An html:input @type="file" is the only input that is exposed as a
23749:     // blockframe. It must be exposed as ROLE_TEXT_CONTAINER for JAWS.
52027:     return nsIAccessibleRole::ROLE_PARAGRAPH;
    1:   }
52027: 
52027:   return nsIAccessibleRole::ROLE_TEXT_CONTAINER; // In ATK this works
    1: }
    1: 
67790: PRUint64
67790: nsHyperTextAccessible::NativeState()
    1: {
67790:   PRUint64 states = nsAccessibleWrap::NativeState();
  262: 
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
    1:   if (editor) {
    1:     PRUint32 flags;
    1:     editor->GetFlags(&flags);
    1:     if (0 == (flags & nsIPlaintextEditor::eEditorReadonlyMask)) {
67790:       states |= states::EDITABLE;
    1:     }
58338:   } else if (mContent->Tag() == nsAccessibilityAtoms::article) {
58338:     // We want <article> to behave like a document in terms of readonly state.
67790:     states |= states::READONLY;
    1:   }
    1: 
64130:   if (GetChildCount() > 0)
67790:     states |= states::SELECTABLE_TEXT;
  262: 
67790:   return states;
    1: }
    1: 
    1: // Substring must be entirely within the same text node
 4468: nsIntRect nsHyperTextAccessible::GetBoundsForString(nsIFrame *aFrame, PRUint32 aStartRenderedOffset,
 4468:                                                     PRUint32 aEndRenderedOffset)
    1: {
    1:   nsIntRect screenRect;
 4261:   NS_ENSURE_TRUE(aFrame, screenRect);
 5693:   if (aFrame->GetType() != nsAccessibilityAtoms::textFrame) {
 5693:     // XXX fallback for non-text frames, happens for bullets right now
 5693:     // but in the future bullets will have proper text frames
 5693:     return aFrame->GetScreenRectExternal();
 5693:   }
 4261: 
 4468:   PRInt32 startContentOffset, endContentOffset;
 4468:   nsresult rv = RenderedToContentOffset(aFrame, aStartRenderedOffset, &startContentOffset);
 4261:   NS_ENSURE_SUCCESS(rv, screenRect);
 4468:   rv = RenderedToContentOffset(aFrame, aEndRenderedOffset, &endContentOffset);
 4261:   NS_ENSURE_SUCCESS(rv, screenRect);
 4261: 
    1:   nsIFrame *frame;
 4468:   PRInt32 startContentOffsetInFrame;
 4261:   // Get the right frame continuation -- not really a child, but a sibling of
 4261:   // the primary frame passed in
 4468:   rv = aFrame->GetChildFrameContainingOffset(startContentOffset, PR_FALSE,
 4468:                                              &startContentOffsetInFrame, &frame);
    1:   NS_ENSURE_SUCCESS(rv, screenRect);
    1: 
    1:   nsCOMPtr<nsIPresShell> shell = GetPresShell();
    1:   NS_ENSURE_TRUE(shell, screenRect);
    1: 
    1:   nsPresContext *context = shell->GetPresContext();
    1: 
 4468:   while (frame && startContentOffset < endContentOffset) {
    1:     // Start with this frame's screen rect, which we will 
    1:     // shrink based on the substring we care about within it.
    1:     // We will then add that frame to the total screenRect we
    1:     // are returning.
    1:     nsIntRect frameScreenRect = frame->GetScreenRectExternal();
    1: 
    1:     // Get the length of the substring in this frame that we want the bounds for
    1:     PRInt32 startFrameTextOffset, endFrameTextOffset;
    1:     frame->GetOffsets(startFrameTextOffset, endFrameTextOffset);
    1:     PRInt32 frameTotalTextLength = endFrameTextOffset - startFrameTextOffset;
 4468:     PRInt32 seekLength = endContentOffset - startContentOffset;
35668:     PRInt32 frameSubStringLength = NS_MIN(frameTotalTextLength - startContentOffsetInFrame, seekLength);
    1: 
    1:     // Add the point where the string starts to the frameScreenRect
    1:     nsPoint frameTextStartPoint;
 4741:     rv = frame->GetPointFromOffset(startContentOffset, &frameTextStartPoint);
23738:     NS_ENSURE_SUCCESS(rv, nsIntRect());
    1:     frameScreenRect.x += context->AppUnitsToDevPixels(frameTextStartPoint.x);
    1: 
    1:     // Use the point for the end offset to calculate the width
    1:     nsPoint frameTextEndPoint;
 4741:     rv = frame->GetPointFromOffset(startContentOffset + frameSubStringLength, &frameTextEndPoint);
23738:     NS_ENSURE_SUCCESS(rv, nsIntRect());
    1:     frameScreenRect.width = context->AppUnitsToDevPixels(frameTextEndPoint.x - frameTextStartPoint.x);
    1: 
    1:     screenRect.UnionRect(frameScreenRect, screenRect);
    1: 
    1:     // Get ready to loop back for next frame continuation
 4468:     startContentOffset += frameSubStringLength;
 4468:     startContentOffsetInFrame = 0;
    1:     frame = frame->GetNextContinuation();
    1:   }
    1: 
    1:   return screenRect;
    1: }
    1: 
    1: /*
    1:  * Gets the specified text.
    1:  */
 4616: nsIFrame*
 4616: nsHyperTextAccessible::GetPosAndText(PRInt32& aStartOffset, PRInt32& aEndOffset,
 4616:                                      nsAString *aText, nsIFrame **aEndFrame,
 5245:                                      nsIntRect *aBoundsRect,
42797:                                      nsAccessible **aStartAcc,
42797:                                      nsAccessible **aEndAcc)
    1: {
 8755:   if (aStartOffset == nsIAccessibleText::TEXT_OFFSET_END_OF_TEXT) {
61202:     aStartOffset = CharacterCount();
 6073:   }
 8755:   if (aStartOffset == nsIAccessibleText::TEXT_OFFSET_CARET) {
 8755:     GetCaretOffset(&aStartOffset);
 8755:   }
 8755:   if (aEndOffset == nsIAccessibleText::TEXT_OFFSET_END_OF_TEXT) {
61202:     aEndOffset = CharacterCount();
 6073:   }
 8755:   if (aEndOffset == nsIAccessibleText::TEXT_OFFSET_CARET) {
 8755:     GetCaretOffset(&aEndOffset);
 8755:   }
 6073: 
    1:   PRInt32 startOffset = aStartOffset;
    1:   PRInt32 endOffset = aEndOffset;
11543:   // XXX this prevents text interface usage on <input type="password">
52089:   PRBool isPassword = (Role() == nsIAccessibleRole::ROLE_PASSWORD_TEXT);
    1: 
    1:   // Clear out parameters and set up loop
    1:   if (aText) {
    1:     aText->Truncate();
    1:   }
    1:   if (endOffset < 0) {
    1:     const PRInt32 kMaxTextLength = 32767;
    1:     endOffset = kMaxTextLength; // Max end offset
    1:   }
    1:   else if (startOffset > endOffset) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsIFrame *startFrame = nsnull;
    1:   if (aEndFrame) {
    1:     *aEndFrame = nsnull;
    1:   }
    1:   if (aBoundsRect) {
68639:     aBoundsRect->SetEmpty();
    1:   }
 5245:   if (aStartAcc)
 5245:     *aStartAcc = nsnull;
 5245:   if (aEndAcc)
 5245:     *aEndAcc = nsnull;
    1: 
    1:   nsIntRect unionRect;
40990:   nsAccessible *lastAccessible = nsnull;
    1: 
 4261:   gfxSkipChars skipChars;
 4261:   gfxSkipCharsIterator iter;
 4261: 
    1:   // Loop through children and collect valid offsets, text and bounds
40990:   // depending on what we need for out parameters.
40990:   PRInt32 childCount = GetChildCount();
40990:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
40990:     nsAccessible *childAcc = mChildren[childIdx];
40990:     lastAccessible = childAcc;
21169: 
40990:     nsIFrame *frame = childAcc->GetFrame();
    1:     if (!frame) {
    1:       continue;
    1:     }
 4616:     nsIFrame *primaryFrame = frame;
40990:     if (nsAccUtils::IsText(childAcc)) {
 4616:       // We only need info up to rendered offset -- that is what we're
 4616:       // converting to content offset
 5693:       PRInt32 substringEndOffset = -1;
 5693:       PRUint32 ourRenderedStart = 0;
 5693:       PRInt32 ourContentStart = 0;
 5693:       if (frame->GetType() == nsAccessibilityAtoms::textFrame) {
 4261:         nsresult rv = frame->GetRenderedText(nsnull, &skipChars, &iter);
 4261:         if (NS_SUCCEEDED(rv)) {
 5693:           ourRenderedStart = iter.GetSkippedOffset();
 5693:           ourContentStart = iter.GetOriginalOffset();
 4616:           substringEndOffset =
 4616:             iter.ConvertOriginalToSkipped(skipChars.GetOriginalCharCount() +
 5693:                                           ourContentStart) - ourRenderedStart;
 4261:         }
 5693:       }
 5693:       if (substringEndOffset < 0) {
 4616:         // XXX for non-textframe text like list bullets,
 4616:         // should go away after list bullet rewrite
40990:         substringEndOffset = nsAccUtils::TextLength(childAcc);
 4261:       }
    1:       if (startOffset < substringEndOffset) {
    1:         // Our start is within this substring
    1:         if (startOffset > 0 || endOffset < substringEndOffset) {
 4261:           // We don't want the whole string for this accessible
 4261:           // Get out the continuing text frame with this offset
    1:           PRInt32 outStartLineUnused;
 5693:           PRInt32 contentOffset;
 5693:           if (frame->GetType() == nsAccessibilityAtoms::textFrame) {
 5699:             contentOffset = iter.ConvertSkippedToOriginal(startOffset) +
 5699:                             ourRenderedStart - ourContentStart;
 5693:           }
 5693:           else {
 5693:             contentOffset = startOffset;
 5693:           }
 4616:           frame->GetChildFrameContainingOffset(contentOffset, PR_TRUE,
 4616:                                                &outStartLineUnused, &frame);
    1:           if (aEndFrame) {
    1:             *aEndFrame = frame; // We ended in the current frame
 5245:             if (aEndAcc)
40990:               NS_ADDREF(*aEndAcc = childAcc);
    1:           }
 4261:           if (substringEndOffset > endOffset) {
 4261:             // Need to stop before the end of the available text
 4261:             substringEndOffset = endOffset;
 4261:           }
    1:           aEndOffset = endOffset;
    1:         }
    1:         if (aText) {
11543:           if (isPassword) {
11543:             for (PRInt32 count = startOffset; count < substringEndOffset; count ++)
11543:               *aText += '*'; // Show *'s only for password text
11543:           }
11543:           else {
40990:             childAcc->AppendTextTo(*aText, startOffset,
 4616:                                    substringEndOffset - startOffset);
    1:           }
11543:         }
 4261:         if (aBoundsRect) {    // Caller wants the bounds of the text
 4616:           aBoundsRect->UnionRect(*aBoundsRect,
 4616:                                  GetBoundsForString(primaryFrame, startOffset,
 4261:                                                     substringEndOffset));
    1:         }
    1:         if (!startFrame) {
    1:           startFrame = frame;
    1:           aStartOffset = startOffset;
 5245:           if (aStartAcc)
40990:             NS_ADDREF(*aStartAcc = childAcc);
    1:         }
 4261:         // We already started copying in this accessible's string,
 4261:         // for the next accessible we'll start at offset 0
    1:         startOffset = 0;
    1:       }
    1:       else {
 4261:         // We have not found the start position yet, get the new startOffset
 4261:         // that is relative to next accessible
    1:         startOffset -= substringEndOffset;
    1:       }
 4261:       // The endOffset needs to be relative to the new startOffset
    1:       endOffset -= substringEndOffset;
    1:     }
    1:     else {
    1:       // Embedded object, append marker
    1:       // XXX Append \n for <br>'s
    1:       if (startOffset >= 1) {
    1:         -- startOffset;
    1:       }
    1:       else {
    1:         if (endOffset > 0) {
    1:           if (aText) {
43441:             // XXX: should use nsIAccessible::AppendTextTo.
 8105:             if (frame->GetType() == nsAccessibilityAtoms::brFrame) {
 8105:               *aText += kForcedNewLineChar;
20566:             } else if (nsAccUtils::MustPrune(this)) {
 8105:               *aText += kImaginaryEmbeddedObjectChar;
 8105:               // Expose imaginary embedded object character if the accessible
 8105:               // hans't children.
 8105:             } else {
 8105:               *aText += kEmbeddedObjectChar;
 8105:             }
    1:           }
    1:           if (aBoundsRect) {
 4616:             aBoundsRect->UnionRect(*aBoundsRect,
 4616:                                    frame->GetScreenRectExternal());
    1:           }
    1:         }
    1:         if (!startFrame) {
    1:           startFrame = frame;
    1:           aStartOffset = 0;
 5245:           if (aStartAcc)
40990:             NS_ADDREF(*aStartAcc = childAcc);
    1:         }
    1:       }
    1:       -- endOffset;
    1:     }
    1:     if (endOffset <= 0 && startFrame) {
    1:       break; // If we don't have startFrame yet, get that in next loop iteration
    1:     }
    1:   }
    1: 
 6073:   if (aStartAcc && !*aStartAcc) {
 6073:     NS_IF_ADDREF(*aStartAcc = lastAccessible);
 6073:   }
    1:   if (aEndFrame && !*aEndFrame) {
    1:     *aEndFrame = startFrame;
 5245:     if (aStartAcc && aEndAcc)
 6073:       NS_IF_ADDREF(*aEndAcc = *aStartAcc);
    1:   }
    1: 
    1:   return startFrame;
    1: }
    1: 
61730: NS_IMETHODIMP
61730: nsHyperTextAccessible::GetText(PRInt32 aStartOffset, PRInt32 aEndOffset,
61730:                                nsAString &aText)
    1: {
61730:   aText.Truncate();
61730: 
43504:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
43504: 
61843:   PRInt32 startOffset = ConvertMagicOffset(aStartOffset);
61843:   PRInt32 startChildIdx = GetChildIndexAtOffset(startOffset);
61730:   if (startChildIdx == -1)
61730:     return NS_ERROR_INVALID_ARG;
61730: 
61843:   PRInt32 endOffset = ConvertMagicOffset(aEndOffset);
61843:   PRInt32 endChildIdx = GetChildIndexAtOffset(endOffset);
61730:   if (endChildIdx == -1)
61730:     return NS_ERROR_INVALID_ARG;
61730: 
61730:   if (startChildIdx == endChildIdx) {
61730:     PRInt32 childOffset =  GetChildOffset(startChildIdx);
61730:     NS_ENSURE_STATE(childOffset != -1);
61730: 
61730:     nsAccessible* child = GetChildAt(startChildIdx);
61843:     child->AppendTextTo(aText, startOffset - childOffset,
61843:                         endOffset - startOffset);
61730: 
61730:     return NS_OK;
61730:   }
61730: 
61730:   PRInt32 startChildOffset =  GetChildOffset(startChildIdx);
61730:   NS_ENSURE_STATE(startChildOffset != -1);
61730: 
61730:   nsAccessible* startChild = GetChildAt(startChildIdx);
61843:   startChild->AppendTextTo(aText, startOffset - startChildOffset);
61730: 
61730:   for (PRInt32 childIdx = startChildIdx + 1; childIdx < endChildIdx; childIdx++) {
61730:     nsAccessible* child = GetChildAt(childIdx);
61730:     child->AppendTextTo(aText);
61730:   }
61730: 
61730:   PRInt32 endChildOffset =  GetChildOffset(endChildIdx);
61730:   NS_ENSURE_STATE(endChildOffset != -1);
61730: 
61730:   nsAccessible* endChild = GetChildAt(endChildIdx);
61843:   endChild->AppendTextTo(aText, 0, endOffset - endChildOffset);
61730: 
61730:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Gets the character count.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetCharacterCount(PRInt32 *aCharacterCount)
    1: {
40990:   NS_ENSURE_ARG_POINTER(aCharacterCount);
    1:   *aCharacterCount = 0;
40990: 
40990:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
    1: 
61202:   *aCharacterCount = CharacterCount();
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Gets the specified character.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetCharacterAtOffset(PRInt32 aOffset, PRUnichar *aCharacter)
    1: {
61843:   NS_ENSURE_ARG_POINTER(aCharacter);
61843:   *aCharacter = nsnull;
61843: 
43504:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
43504: 
61843:   nsAutoString character;
61843:   if (GetCharAt(aOffset, eGetAt, character)) {
61843:     *aCharacter = character.First();
61843:     return NS_OK;
 4341:   }
 4341: 
61843:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
42377: nsAccessible*
43504: nsHyperTextAccessible::DOMPointToHypertextOffset(nsINode *aNode,
42377:                                                  PRInt32 aNodeOffset,
 4261:                                                  PRInt32 *aHyperTextOffset,
 6072:                                                  PRBool aIsEndOffset)
    1: {
42377:   if (!aHyperTextOffset)
42377:     return nsnull;
 4261:   *aHyperTextOffset = 0;
10667: 
42377:   if (!aNode)
42377:     return nsnull;
    1: 
 4261:   PRUint32 addTextOffset = 0;
43504:   nsINode* findNode = nsnull;
    1: 
 5395:   if (aNodeOffset == -1) {
 5395:     findNode = aNode;
43504: 
43504:   } else if (aNode->IsNodeOfType(nsINode::eTEXT)) {
    1:     // For text nodes, aNodeOffset comes in as a character offset
    1:     // Text offset will be added at the end, if we find the offset in this hypertext
 4261:     // We want the "skipped" offset into the text (rendered text without the extra whitespace)
 4261:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 4261:     NS_ASSERTION(content, "No nsIContent for dom node");
36654:     nsIFrame *frame = content->GetPrimaryFrame();
42377:     NS_ENSURE_TRUE(frame, nsnull);
 4261:     nsresult rv = ContentToRenderedOffset(frame, aNodeOffset, &addTextOffset);
42377:     NS_ENSURE_SUCCESS(rv, nsnull);
    1:     // Get the child node and 
    1:     findNode = aNode;
  648: 
43504:   } else {
43504:     // findNode could be null if aNodeOffset == # of child nodes, which means
43504:     // one of two things:
43504:     // 1) we're at the end of the children, keep findNode = null, so that we get
43504:     //    the last possible offset
43504:     // 2) there are no children and the passed-in node is mContent, which means
43504:     //    we're an aempty nsIAccessibleText
43504:     // 3) there are no children, and the passed-in node is not mContent -- use
43504:     //    parentContent for the node to find
43504: 
43504:     findNode = aNode->GetChildAt(aNodeOffset);
  648:     if (!findNode && !aNodeOffset) {
43504:       if (aNode == GetNode()) {
 4516:         // There are no children, which means this is an empty nsIAccessibleText, in which
 4516:         // case we can only be at hypertext offset 0
 4516:         *aHyperTextOffset = 0;
42377:         return nsnull;
 4516:       }
43504:       findNode = aNode; // Case #2: there are no children
  648:     }
    1:   }
    1: 
    1:   // Get accessible for this findNode, or if that node isn't accessible, use the
    1:   // accessible for the next DOM node which has one (based on forward depth first search)
42795:   nsAccessible *descendantAcc = nsnull;
    1:   if (findNode) {
43504:     nsCOMPtr<nsIContent> findContent(do_QueryInterface(findNode));
43504:     if (findContent && findContent->IsHTML() &&
37988:         findContent->NodeInfo()->Equals(nsAccessibilityAtoms::br) &&
37988:         findContent->AttrValueIs(kNameSpaceID_None,
37988:                                  nsAccessibilityAtoms::mozeditorbogusnode,
37988:                                  nsAccessibilityAtoms::_true,
37988:                                  eIgnoreCase)) {
37988:       // This <br> is the hacky "bogus node" used when there is no text in a control
10510:       *aHyperTextOffset = 0;
42377:       return nsnull;
10510:     }
41227:     descendantAcc = GetFirstAvailableAccessible(findNode);
    1:   }
40990: 
    1:   // From the descendant, go up and get the immediate child of this hypertext
42795:   nsAccessible *childAccAtOffset = nsnull;
40990:   while (descendantAcc) {
42795:     nsAccessible *parentAcc = descendantAcc->GetParent();
40990:     if (parentAcc == this) {
40990:       childAccAtOffset = descendantAcc;
    1:       break;
    1:     }
40990: 
    1:     // This offset no longer applies because the passed-in text object is not a child
    1:     // of the hypertext. This happens when there are nested hypertexts, e.g.
    1:     // <div>abc<h1>def</h1>ghi</div>
    1:     // If the passed-in DOM point was not on a direct child of the hypertext, we will
    1:     // return the offset for that entire hypertext
 6072:     if (aIsEndOffset) {
 6072:       // Not inclusive, the indicated char comes at index before this offset
 6072:       // If the end offset is after the first character of the passed in object, use 1 for
 1318:     // addTextOffset, to put us after the embedded object char. We'll only treat the offset as
 1318:     // before the embedded object char if we end at the very beginning of the child.
 1318:     addTextOffset = addTextOffset > 0;
 6072:     }
 6072:     else {
 6072:       // Start offset, inclusive
 6072:       // Make sure the offset lands on the embedded object character in order to indicate
 6072:       // the true inner offset is inside the subtree for that link
20566:       addTextOffset =
42801:         (nsAccUtils::TextLength(descendantAcc) == addTextOffset) ? 1 : 0;
 6072:     }
40990: 
42795:     descendantAcc = parentAcc;
    1:   }
    1: 
    1:   // Loop through, adding offsets until we reach childAccessible
    1:   // If childAccessible is null we will end up adding up the entire length of
    1:   // the hypertext, which is good -- it just means our offset node
    1:   // came after the last accessible child's node
40990:   PRInt32 childCount = GetChildCount();
40990: 
40990:   PRInt32 childIdx = 0;
40990:   nsAccessible *childAcc = nsnull;
40990:   for (; childIdx < childCount; childIdx++) {
40990:     childAcc = mChildren[childIdx];
40990:     if (childAcc == childAccAtOffset)
40990:       break;
40990: 
42801:     *aHyperTextOffset += nsAccUtils::TextLength(childAcc);
    1:   }
40990: 
40990:   if (childIdx < childCount) {
 4261:     *aHyperTextOffset += addTextOffset;
40990:     NS_ASSERTION(childAcc == childAccAtOffset,
40990:                  "These should be equal whenever we exit loop and childAcc != nsnull");
40990: 
42377:     if (childIdx < childCount - 1 ||
42801:         addTextOffset < nsAccUtils::TextLength(childAccAtOffset)) {
    1:       // If not at end of last text node, we will return the accessible we were in
42377:       return childAccAtOffset;
    1:     }
    1:   }
 5395: 
42377:   return nsnull;
    1: }
    1: 
 6286: nsresult
16001: nsHyperTextAccessible::HypertextOffsetToDOMPoint(PRInt32 aHTOffset,
16001:                                                  nsIDOMNode **aNode,
16001:                                                  PRInt32 *aOffset)
16001: {
16001:   nsCOMPtr<nsIDOMNode> endNode;
16001:   PRInt32 endOffset;
16001: 
16001:   return HypertextOffsetsToDOMRange(aHTOffset, aHTOffset, aNode, aOffset,
16001:                                     getter_AddRefs(endNode), &endOffset);
16001: }
16001: 
16001: nsresult
 6286: nsHyperTextAccessible::HypertextOffsetsToDOMRange(PRInt32 aStartHTOffset,
 6286:                                                   PRInt32 aEndHTOffset,
 6286:                                                   nsIDOMNode **aStartNode,
 6286:                                                   PRInt32 *aStartOffset,
 6286:                                                   nsIDOMNode **aEndNode,
 6286:                                                   PRInt32 *aEndOffset)
 6286: {
 6286:   NS_ENSURE_ARG_POINTER(aStartNode);
 6286:   *aStartNode = nsnull;
 6286: 
 6286:   NS_ENSURE_ARG_POINTER(aStartOffset);
 6286:   *aStartOffset = -1;
 6286: 
 6286:   NS_ENSURE_ARG_POINTER(aEndNode);
 6286:   *aEndNode = nsnull;
 6286: 
 6286:   NS_ENSURE_ARG_POINTER(aEndOffset);
 6286:   *aEndOffset = -1;
 6286: 
18505:   // If the given offsets are 0 and associated editor is empty then return
18505:   // collapsed range with editor root element as range container.
18505:   if (aStartHTOffset == 0 && aEndHTOffset == 0) {
18505:     nsCOMPtr<nsIEditor> editor;
18505:     GetAssociatedEditor(getter_AddRefs(editor));
18505:     if (editor) {
18505:       PRBool isEmpty = PR_FALSE;
18505:       editor->GetDocumentIsEmpty(&isEmpty);
18505:       if (isEmpty) {
18505:         nsCOMPtr<nsIDOMElement> editorRootElm;
18505:         editor->GetRootElement(getter_AddRefs(editorRootElm));
18505: 
18505:         nsCOMPtr<nsIDOMNode> editorRoot(do_QueryInterface(editorRootElm));
18505:         if (editorRoot) {
18505:           *aStartOffset = *aEndOffset = 0;
18505:           NS_ADDREF(*aStartNode = editorRoot);
18505:           NS_ADDREF(*aEndNode = editorRoot);
18505: 
18505:           return NS_OK;
18505:         }
18505:       }
18505:     }
18505:   }
18505: 
42797:   nsRefPtr<nsAccessible> startAcc, endAcc;
 6286:   PRInt32 startOffset = aStartHTOffset, endOffset = aEndHTOffset;
 6286:   nsIFrame *startFrame = nsnull, *endFrame = nsnull;
 6286: 
 6286:   startFrame = GetPosAndText(startOffset, endOffset, nsnull, &endFrame, nsnull,
 6286:                              getter_AddRefs(startAcc), getter_AddRefs(endAcc));
 6286:   if (!startAcc || !endAcc)
 6286:     return NS_ERROR_FAILURE;
 6286: 
 6286:   nsCOMPtr<nsIDOMNode> startNode, endNode;
 6286:   nsresult rv = GetDOMPointByFrameOffset(startFrame, startOffset, startAcc,
 6286:                                          getter_AddRefs(startNode),
 6286:                                          &startOffset);
 6286:   NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:   if (aStartHTOffset != aEndHTOffset) {
 6286:     rv = GetDOMPointByFrameOffset(endFrame, endOffset, endAcc,
 6286:                                   getter_AddRefs(endNode), &endOffset);
 6286:     NS_ENSURE_SUCCESS(rv, rv);
 6286:   } else {
 6286:     endNode = startNode;
 6286:     endOffset = startOffset;
 6286:   }
 6286: 
 6286:   NS_ADDREF(*aStartNode = startNode);
 6286:   *aStartOffset = startOffset;
 6286: 
 6286:   NS_ADDREF(*aEndNode = endNode);
 6286:   *aEndOffset = endOffset;
 6286: 
 6286:   return NS_OK;
 6286: }
 6286: 
 5418: PRInt32
 5418: nsHyperTextAccessible::GetRelativeOffset(nsIPresShell *aPresShell,
 5418:                                          nsIFrame *aFromFrame,
 5418:                                          PRInt32 aFromOffset,
43539:                                          nsAccessible *aFromAccessible,
 5418:                                          nsSelectionAmount aAmount,
 5418:                                          nsDirection aDirection,
 5418:                                          PRBool aNeedsStart)
    1: {
    1:   const PRBool kIsJumpLinesOk = PR_TRUE;          // okay to jump lines
    1:   const PRBool kIsScrollViewAStop = PR_FALSE;     // do not stop at scroll views
    1:   const PRBool kIsKeyboardSelect = PR_TRUE;       // is keyboard selection
    1:   const PRBool kIsVisualBidi = PR_FALSE;          // use visual order for bidi text
    1: 
    1:   EWordMovementType wordMovementType = aNeedsStart ? eStartWord : eEndWord;
    1:   if (aAmount == eSelectLine) {
    1:     aAmount = (aDirection == eDirNext) ? eSelectEndLine : eSelectBeginLine;
    1:   }
    1: 
    1:   // Ask layout for the new node and offset, after moving the appropriate amount
    1:   nsPeekOffsetStruct pos;
 4261: 
 5418:   nsresult rv;
 5418:   PRInt32 contentOffset = aFromOffset;
20566:   if (nsAccUtils::IsText(aFromAccessible)) {
43539:     nsIFrame *frame = aFromAccessible->GetFrame();
 5418:     NS_ENSURE_TRUE(frame, -1);
21169: 
 5693:     if (frame->GetType() == nsAccessibilityAtoms::textFrame) {
 5418:       rv = RenderedToContentOffset(frame, aFromOffset, &contentOffset);
 4261:       NS_ENSURE_SUCCESS(rv, -1);
 5418:     }
 5693:   }
 4261: 
 4261:   pos.SetData(aAmount, aDirection, contentOffset,
 4261:               0, kIsJumpLinesOk, kIsScrollViewAStop, kIsKeyboardSelect, kIsVisualBidi,
    1:               wordMovementType);
 4261:   rv = aFromFrame->PeekOffset(&pos);
    1:   if (NS_FAILED(rv)) {
    1:     if (aDirection == eDirPrevious) {
    1:       // Use passed-in frame as starting point in failure case for now,
    1:       // this is a hack to deal with starting on a list bullet frame,
    1:       // which fails in PeekOffset() because the line iterator doesn't see it.
    1:       // XXX Need to look at our overall handling of list bullets, which are an odd case
    1:       pos.mResultContent = aFromFrame->GetContent();
    1:       PRInt32 endOffsetUnused;
    1:       aFromFrame->GetOffsets(pos.mContentOffset, endOffsetUnused);
    1:     }
    1:     else {
 4261:       return -1;
    1:     }
    1:   }
    1: 
    1:   // Turn the resulting node and offset into a hyperTextOffset
    1:   PRInt32 hyperTextOffset;
43504:   if (!pos.mResultContent)
43504:     return -1;
    1: 
42377:   // If finalAccessible is nsnull, then DOMPointToHypertextOffset() searched
42377:   // through the hypertext children without finding the node/offset position.
42377:   nsAccessible *finalAccessible =
43504:     DOMPointToHypertextOffset(pos.mResultContent, pos.mContentOffset,
43504:                               &hyperTextOffset, aDirection == eDirNext);
    1: 
    1:   if (!finalAccessible && aDirection == eDirPrevious) {
    1:     // If we reached the end during search, this means we didn't find the DOM point
    1:     // and we're actually at the start of the paragraph
    1:     hyperTextOffset = 0;
    1:   }  
    1:   else if (aAmount == eSelectBeginLine) {
36989:     nsAccessible *firstChild = mChildren.SafeElementAt(0, nsnull);
    1:     // For line selection with needsStart, set start of line exactly to line break
35523:     if (pos.mContentOffset == 0 && firstChild &&
52089:         firstChild->Role() == nsIAccessibleRole::ROLE_STATICTEXT &&
47804:         static_cast<PRInt32>(nsAccUtils::TextLength(firstChild)) == hyperTextOffset) {
  764:       // XXX Bullet hack -- we should remove this once list bullets use anonymous content
  764:       hyperTextOffset = 0;
  764:     }
    1:     if (!aNeedsStart && hyperTextOffset > 0) {
    1:       -- hyperTextOffset;
    1:     }
    1:   }
    1:   else if (aAmount == eSelectEndLine && finalAccessible) { 
    1:     // If not at very end of hypertext, we may need change the end of line offset by 1, 
    1:     // to make sure we are in the right place relative to the line ending
52089:     if (finalAccessible->Role() == nsIAccessibleRole::ROLE_WHITESPACE) {  // Landed on <br> hard line break
    1:       // if aNeedsStart, set end of line exactly 1 character past line break
    1:       // XXX It would be cleaner if we did not have to have the hard line break check,
    1:       // and just got the correct results from PeekOffset() for the <br> case -- the returned offset should
    1:       // come after the new line, as it does in other cases.
    1:       ++ hyperTextOffset;  // Get past hard line break
    1:     }
    1:     // We are now 1 character past the line break
    1:     if (!aNeedsStart) {
    1:       -- hyperTextOffset;
    1:     }
    1:   }
    1: 
    1:   return hyperTextOffset;
    1: }
    1: 
    1: /*
    1: Gets the specified text relative to aBoundaryType, which means:
    1: BOUNDARY_CHAR             The character before/at/after the offset is returned.
    1: BOUNDARY_WORD_START       From the word start before/at/after the offset to the next word start.
    1: BOUNDARY_WORD_END         From the word end before/at/after the offset to the next work end.
    1: BOUNDARY_LINE_START       From the line start before/at/after the offset to the next line start.
    1: BOUNDARY_LINE_END         From the line end before/at/after the offset to the next line start.
    1: */
    1: 
    1: nsresult nsHyperTextAccessible::GetTextHelper(EGetTextType aType, nsAccessibleTextBoundary aBoundaryType,
    1:                                               PRInt32 aOffset, PRInt32 *aStartOffset, PRInt32 *aEndOffset,
    1:                                               nsAString &aText)
    1: {
    1:   aText.Truncate();
16173: 
16173:   NS_ENSURE_ARG_POINTER(aStartOffset);
16173:   NS_ENSURE_ARG_POINTER(aEndOffset);
    1:   *aStartOffset = *aEndOffset = 0;
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
    1:   if (!presShell) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
 8755:   if (aOffset == nsIAccessibleText::TEXT_OFFSET_END_OF_TEXT) {
61202:     aOffset = CharacterCount();
 8755:   }
 8755:   if (aOffset == nsIAccessibleText::TEXT_OFFSET_CARET) {
 8755:     GetCaretOffset(&aOffset);
 8755:     if (aOffset > 0 && (aBoundaryType == BOUNDARY_LINE_START ||
 8755:                         aBoundaryType == BOUNDARY_LINE_END)) {
 8755:       // It is the same character offset when the caret is visually at the very end of a line
 8755:       // or the start of a new line. Getting text at the line should provide the line with the visual caret,
 8755:       // otherwise screen readers will announce the wrong line as the user presses up or down arrow and land
 8755:       // at the end of a line.
 8755:       nsCOMPtr<nsISelection> domSel;
16001:       nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                                   nsnull, getter_AddRefs(domSel));
16001:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
 8755:       nsCOMPtr<nsISelectionPrivate> privateSelection(do_QueryInterface(domSel));
 8755:       nsCOMPtr<nsFrameSelection> frameSelection;
 8755:       rv = privateSelection->GetFrameSelection(getter_AddRefs(frameSelection));
 8755:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
 8755:       if (frameSelection->GetHint() == nsFrameSelection::HINTLEFT) {
 8755:         -- aOffset;  // We are at the start of a line
 8755:       }
 8755:     }
 8755:   }
 8755:   else if (aOffset < 0) {
 8755:     return NS_ERROR_FAILURE;
 8755:   }
    1: 
16173:   nsSelectionAmount amount;
16173:   PRBool needsStart = PR_FALSE;
16173:   switch (aBoundaryType) {
16173:     case BOUNDARY_CHAR:
59604:       amount = eSelectCluster;
16173:       if (aType == eGetAt)
16173:         aType = eGetAfter; // Avoid returning 2 characters
16173:       break;
16173: 
16173:     case BOUNDARY_WORD_START:
16173:       needsStart = PR_TRUE;
16173:       amount = eSelectWord;
16173:       break;
16173: 
16173:     case BOUNDARY_WORD_END:
16173:       amount = eSelectWord;
16173:       break;
16173: 
16173:     case BOUNDARY_LINE_START:
16173:       // Newlines are considered at the end of a line. Since getting
16173:       // the BOUNDARY_LINE_START gets the text from the line-start to the next
16173:       // line-start, the newline is included at the end of the string.
16173:       needsStart = PR_TRUE;
16173:       amount = eSelectLine;
16173:       break;
16173: 
16173:     case BOUNDARY_LINE_END:
16173:       // Newlines are considered at the end of a line. Since getting
16173:       // the BOUNDARY_END_START gets the text from the line-end to the next
16173:       //line-end, the newline is included at the beginning of the string.
16173:       amount = eSelectLine;
16173:       break;
16173: 
16173:     case BOUNDARY_ATTRIBUTE_RANGE:
16173:     {
16173:       nsresult rv = GetTextAttributes(PR_FALSE, aOffset,
16173:                                       aStartOffset, aEndOffset, nsnull);
16173:       NS_ENSURE_SUCCESS(rv, rv);
16173:       
16173:       return GetText(*aStartOffset, *aEndOffset, aText);
16173:     }
16173: 
16173:     default:  // Note, sentence support is deprecated and falls through to here
16173:       return NS_ERROR_INVALID_ARG;
16173:   }
16173: 
 8755:   PRInt32 startOffset = aOffset + (aBoundaryType == BOUNDARY_LINE_END);  // Avoid getting the previous line
 8755:   PRInt32 endOffset = startOffset;
 8755: 
    1:   // Convert offsets to frame-relative
42797:   nsRefPtr<nsAccessible> startAcc;
 5418:   nsIFrame *startFrame = GetPosAndText(startOffset, endOffset, nsnull, nsnull,
 5418:                                        nsnull, getter_AddRefs(startAcc));
 5418: 
    1:   if (!startFrame) {
61202:     PRInt32 textLength = CharacterCount();
 6074:     if (aBoundaryType == BOUNDARY_LINE_START && aOffset > 0 && aOffset == textLength) {
 6074:       // Asking for start of line, while on last character
43539:       if (startAcc)
43539:         startFrame = startAcc->GetFrame();
 6074:     }
 6074:     if (!startFrame) {
 8755:       return aOffset > textLength ? NS_ERROR_FAILURE : NS_OK;
    1:     }
 8744:     else {
 8744:       // We're on the last continuation since we're on the last character
 8744:       startFrame = startFrame->GetLastContinuation();
 8744:     }
 6074:   }
    1: 
    1:   PRInt32 finalStartOffset, finalEndOffset;
    1: 
    1:   // If aType == eGetAt we'll change both the start and end offset from
    1:   // the original offset
    1:   if (aType == eGetAfter) {
    1:     finalStartOffset = aOffset;
    1:   }
    1:   else {
    1:     finalStartOffset = GetRelativeOffset(presShell, startFrame, startOffset,
 5418:                                          startAcc, amount, eDirPrevious,
 5418:                                          needsStart);
    1:     NS_ENSURE_TRUE(finalStartOffset >= 0, NS_ERROR_FAILURE);
    1:   }
    1: 
    1:   if (aType == eGetBefore) {
    1:     endOffset = aOffset;
    1:   }
    1:   else {
    1:     // Start moving forward from the start so that we don't get 
42263:     // 2 words/lines if the offset occurred on whitespace boundary
    1:     // Careful, startOffset and endOffset are passed by reference to GetPosAndText() and changed
 8755:     // For BOUNDARY_LINE_END, make sure we start of this line
 8755:     startOffset = endOffset = finalStartOffset + (aBoundaryType == BOUNDARY_LINE_END);
42797:     nsRefPtr<nsAccessible> endAcc;
 5418:     nsIFrame *endFrame = GetPosAndText(startOffset, endOffset, nsnull, nsnull,
 5418:                                        nsnull, getter_AddRefs(endAcc));
52089:     if (endAcc && endAcc->Role() == nsIAccessibleRole::ROLE_STATICTEXT) {
10509:       // Static text like list bullets will ruin our forward calculation,
10509:       // since the caret cannot be in the static text. Start just after the static text.
20566:       startOffset = endOffset = finalStartOffset +
20566:                                 (aBoundaryType == BOUNDARY_LINE_END) +
20566:                                 nsAccUtils::TextLength(endAcc);
20566: 
10509:       endFrame = GetPosAndText(startOffset, endOffset, nsnull, nsnull,
10509:                                nsnull, getter_AddRefs(endAcc));
10509:     }
10870:     if (!endFrame) {
10870:       return NS_ERROR_FAILURE;
10870:     }
 5418:     finalEndOffset = GetRelativeOffset(presShell, endFrame, endOffset, endAcc,
 5418:                                        amount, eDirNext, needsStart);
    1:     NS_ENSURE_TRUE(endOffset >= 0, NS_ERROR_FAILURE);
    1:     if (finalEndOffset == aOffset) {
 6065:       if (aType == eGetAt && amount == eSelectWord) { 
 6065:         // Fix word error for the first character in word: PeekOffset() will return the previous word when 
 6065:         // aOffset points to the first character of the word, but accessibility APIs want the current word 
 6065:         // that the first character is in
 6065:         return GetTextHelper(eGetAfter, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
 6065:       }
61202:       PRInt32 textLength = CharacterCount();
 6074:       if (finalEndOffset < textLength) {
    1:         // This happens sometimes when current character at finalStartOffset 
    1:         // is an embedded object character representing another hypertext, that
    1:         // the AT really needs to dig into separately
    1:         ++ finalEndOffset;
    1:       }
    1:     }
 6074:   }
    1: 
    1:   *aStartOffset = finalStartOffset;
    1:   *aEndOffset = finalEndOffset;
    1: 
    1:   NS_ASSERTION((finalStartOffset < aOffset && finalEndOffset >= aOffset) || aType != eGetBefore, "Incorrect results for GetTextHelper");
    1:   NS_ASSERTION((finalStartOffset <= aOffset && finalEndOffset > aOffset) || aType == eGetBefore, "Incorrect results for GetTextHelper");
    1: 
 6074:   GetPosAndText(finalStartOffset, finalEndOffset, &aText);
 6074:   return NS_OK;
    1: }
    1: 
    1: /**
    1:   * nsIAccessibleText impl.
    1:   */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetTextBeforeOffset(PRInt32 aOffset, nsAccessibleTextBoundary aBoundaryType,
    1:                                                          PRInt32 *aStartOffset, PRInt32 *aEndOffset, nsAString & aText)
    1: {
61843:   if (aBoundaryType == BOUNDARY_CHAR) {
61843:     GetCharAt(aOffset, eGetBefore, aText, aStartOffset, aEndOffset);
61843:     return NS_OK;
61843:   }
61843: 
    1:   return GetTextHelper(eGetBefore, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::GetTextAtOffset(PRInt32 aOffset, nsAccessibleTextBoundary aBoundaryType,
    1:                                                      PRInt32 *aStartOffset, PRInt32 *aEndOffset, nsAString & aText)
    1: {
61843:   if (aBoundaryType == BOUNDARY_CHAR) {
61843:     GetCharAt(aOffset, eGetAt, aText, aStartOffset, aEndOffset);
61843:     return NS_OK;
61843:   }
61843: 
    1:   return GetTextHelper(eGetAt, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::GetTextAfterOffset(PRInt32 aOffset, nsAccessibleTextBoundary aBoundaryType,
    1:                                                         PRInt32 *aStartOffset, PRInt32 *aEndOffset, nsAString & aText)
    1: {
61843:   if (aBoundaryType == BOUNDARY_CHAR) {
61843:     GetCharAt(aOffset, eGetAfter, aText, aStartOffset, aEndOffset);
61843:     return NS_OK;
61843:   }
61843: 
    1:   return GetTextHelper(eGetAfter, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
    1: }
    1: 
16001: // nsIPersistentProperties
16001: // nsIAccessibleText::getTextAttributes(in boolean includeDefAttrs,
16001: //                                      in long offset,
16001: //                                      out long rangeStartOffset,
16001: //                                      out long rangeEndOffset);
16001: NS_IMETHODIMP
16001: nsHyperTextAccessible::GetTextAttributes(PRBool aIncludeDefAttrs,
16001:                                          PRInt32 aOffset,
16001:                                          PRInt32 *aStartOffset,
16001:                                          PRInt32 *aEndOffset,
16001:                                          nsIPersistentProperties **aAttributes)
    1: {
42799:   // 1. Get each attribute and its ranges one after another.
16001:   // 2. As we get each new attribute, we pass the current start and end offsets
16001:   //    as in/out parameters. In other words, as attributes are collected,
16001:   //    the attribute range itself can only stay the same or get smaller.
    1: 
16001:   NS_ENSURE_ARG_POINTER(aStartOffset);
16001:   *aStartOffset = 0;
16001: 
16001:   NS_ENSURE_ARG_POINTER(aEndOffset);
42799:   *aEndOffset = 0;
16001: 
42530:   if (IsDefunct())
42530:     return NS_ERROR_FAILURE;
42530: 
16173:   if (aAttributes) {
16001:     *aAttributes = nsnull;
16001: 
16001:     nsCOMPtr<nsIPersistentProperties> attributes =
16001:       do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);
16001:     NS_ENSURE_TRUE(attributes, NS_ERROR_OUT_OF_MEMORY);
16001: 
16001:     NS_ADDREF(*aAttributes = attributes);
16173:   }
16001: 
50622:   nsAccessible* accAtOffset = GetChildAtOffset(aOffset);
50622:   if (!accAtOffset) {
42530:     // Offset 0 is correct offset when accessible has empty text. Include
42530:     // default attributes if they were requested, otherwise return empty set.
42530:     if (aOffset == 0) {
42799:       if (aIncludeDefAttrs) {
42799:         nsTextAttrsMgr textAttrsMgr(this, PR_TRUE, nsnull, -1);
42799:         return textAttrsMgr.GetAttributes(*aAttributes);
42530:       }
42799:       return NS_OK;
42799:     }
42799:     return NS_ERROR_INVALID_ARG;
42530:   }
42530: 
50622:   PRInt32 accAtOffsetIdx = accAtOffset->GetIndexInParent();
50622:   PRInt32 startOffset = GetChildOffset(accAtOffsetIdx);
50622:   PRInt32 endOffset = GetChildOffset(accAtOffsetIdx + 1);
42799:   PRInt32 offsetInAcc = aOffset - startOffset;
42530: 
50622:   nsTextAttrsMgr textAttrsMgr(this, aIncludeDefAttrs, accAtOffset,
50622:                               accAtOffsetIdx);
42799:   nsresult rv = textAttrsMgr.GetAttributes(*aAttributes, &startOffset,
42799:                                            &endOffset);
42799:   NS_ENSURE_SUCCESS(rv, rv);
42530: 
42799:   // Compute spelling attributes on text accessible only.
50622:   nsIFrame *offsetFrame = accAtOffset->GetFrame();
42799:   if (offsetFrame && offsetFrame->GetType() == nsAccessibilityAtoms::textFrame) {
50622:     nsCOMPtr<nsIDOMNode> node = accAtOffset->GetDOMNode();
42530: 
16001:     PRInt32 nodeOffset = 0;
42799:     nsresult rv = RenderedToContentOffset(offsetFrame, offsetInAcc,
42799:                                           &nodeOffset);
16001:     NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:     // Set 'misspelled' text attribute.
42799:     rv = GetSpellTextAttribute(node, nodeOffset, &startOffset, &endOffset,
16173:                                aAttributes ? *aAttributes : nsnull);
16001:     NS_ENSURE_SUCCESS(rv, rv);
42799:   }
16001: 
42799:   *aStartOffset = startOffset;
42799:   *aEndOffset = endOffset;
16001:   return NS_OK;
    1: }
    1: 
16001: // nsIPersistentProperties
16001: // nsIAccessibleText::defaultTextAttributes
16001: NS_IMETHODIMP
16001: nsHyperTextAccessible::GetDefaultTextAttributes(nsIPersistentProperties **aAttributes)
16001: {
16001:   NS_ENSURE_ARG_POINTER(aAttributes);
16001:   *aAttributes = nsnull;
    1: 
42799:   if (IsDefunct())
42799:     return NS_ERROR_FAILURE;
42799: 
16001:   nsCOMPtr<nsIPersistentProperties> attributes =
16001:     do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);
16001:   NS_ENSURE_TRUE(attributes, NS_ERROR_OUT_OF_MEMORY);
16001: 
16001:   NS_ADDREF(*aAttributes = attributes);
16001: 
42799:   nsTextAttrsMgr textAttrsMgr(this, PR_TRUE);
24999:   return textAttrsMgr.GetAttributes(*aAttributes);
    1: }
    1: 
36879: PRInt32
36879: nsHyperTextAccessible::GetLevelInternal()
36879: {
43504:   nsIAtom *tag = mContent->Tag();
36879:   if (tag == nsAccessibilityAtoms::h1)
36879:     return 1;
36879:   if (tag == nsAccessibilityAtoms::h2)
36879:     return 2;
36879:   if (tag == nsAccessibilityAtoms::h3)
36879:     return 3;
36879:   if (tag == nsAccessibilityAtoms::h4)
36879:     return 4;
36879:   if (tag == nsAccessibilityAtoms::h5)
36879:     return 5;
36879:   if (tag == nsAccessibilityAtoms::h6)
36879:     return 6;
36879: 
36879:   return nsAccessibleWrap::GetLevelInternal();
36879: }
36879: 
  401: nsresult
  401: nsHyperTextAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
    1: {
  401:   nsresult rv = nsAccessibleWrap::GetAttributesInternal(aAttributes);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6792:   // Indicate when the current object uses block-level formatting
 6792:   // via formatting: block
15645:   // XXX: 'formatting' attribute is deprecated and will be removed in Mozilla2,
15645:   // use 'display' attribute instead.
 6792:   nsIFrame *frame = GetFrame();
 6792:   if (frame && frame->GetType() == nsAccessibilityAtoms::blockFrame) {
 6792:     nsAutoString oldValueUnused;
 6792:     aAttributes->SetStringProperty(NS_LITERAL_CSTRING("formatting"), NS_LITERAL_STRING("block"),
 6792:                                    oldValueUnused);
 6792:   }
 6792: 
43504:   if (gLastFocusedNode == GetNode()) {
 8901:     PRInt32 lineNumber = GetCaretLineNumber();
 8901:     if (lineNumber >= 1) {
 8901:       nsAutoString strLineNumber;
 8901:       strLineNumber.AppendInt(lineNumber);
20536:       nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::lineNumber,
 8901:                              strLineNumber);
 8901:     }
 8901:   }
 8901: 
57107:   // For the html landmark elements we expose them like we do aria landmarks to
57107:   // make AT navigation schemes "just work".
57107:   if (mContent->Tag() == nsAccessibilityAtoms::nav)
57107:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::xmlroles,
57107:                            NS_LITERAL_STRING("navigation"));
57107:   else if (mContent->Tag() == nsAccessibilityAtoms::header) 
57107:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::xmlroles,
57107:                            NS_LITERAL_STRING("banner"));
57107:   else if (mContent->Tag() == nsAccessibilityAtoms::footer) 
57107:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::xmlroles,
57107:                            NS_LITERAL_STRING("contentinfo"));
57522:   else if (mContent->Tag() == nsAccessibilityAtoms::aside) 
57522:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::xmlroles,
57522:                            NS_LITERAL_STRING("note"));
57107: 
    1:   return  NS_OK;
    1: }
    1: 
    1: /*
    1:  * Given an offset, the x, y, width, and height values are filled appropriately.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetCharacterExtents(PRInt32 aOffset, PRInt32 *aX, PRInt32 *aY,
    1:                                                          PRInt32 *aWidth, PRInt32 *aHeight,
  728:                                                          PRUint32 aCoordType)
    1: {
    1:   return GetRangeExtents(aOffset, aOffset + 1, aX, aY, aWidth, aHeight, aCoordType);
    1: }
    1: 
    1: /*
    1:  * Given a start & end offset, the x, y, width, and height values are filled appropriately.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetRangeExtents(PRInt32 aStartOffset, PRInt32 aEndOffset,
    1:                                                      PRInt32 *aX, PRInt32 *aY,
    1:                                                      PRInt32 *aWidth, PRInt32 *aHeight,
  728:                                                      PRUint32 aCoordType)
    1: {
    1:   nsIntRect boundsRect;
    1:   nsIFrame *endFrameUnused;
 2395:   if (!GetPosAndText(aStartOffset, aEndOffset, nsnull, &endFrameUnused, &boundsRect) ||
 2395:       boundsRect.IsEmpty()) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   *aX = boundsRect.x;
    1:   *aY = boundsRect.y;
    1:   *aWidth = boundsRect.width;
    1:   *aHeight = boundsRect.height;
    1: 
20536:   return nsAccUtils::ConvertScreenCoordsTo(aX, aY, aCoordType, this);
    1: }
    1: 
    1: /*
    1:  * Gets the offset of the character located at coordinates x and y. x and y are interpreted as being relative to
    1:  * the screen or this widget's window depending on coords.
    1:  */
  728: NS_IMETHODIMP
  728: nsHyperTextAccessible::GetOffsetAtPoint(PRInt32 aX, PRInt32 aY,
  728:                                         PRUint32 aCoordType, PRInt32 *aOffset)
    1: {
    1:   *aOffset = -1;
    1:   nsCOMPtr<nsIPresShell> shell = GetPresShell();
    1:   if (!shell) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   nsIFrame *hyperFrame = GetFrame();
    1:   if (!hyperFrame) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   nsIntRect frameScreenRect = hyperFrame->GetScreenRectExternal();
    1: 
 8525:   nsIntPoint coords;
20536:   nsresult rv = nsAccUtils::ConvertToScreenCoords(aX, aY, aCoordType,
 8525:                                                   this, &coords);
 8525:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 8525:   // coords are currently screen coordinates, and we need to turn them into
    1:   // frame coordinates relative to the current accessible
 8525:   if (!frameScreenRect.Contains(coords.x, coords.y)) {
    1:     return NS_OK;   // Not found, will return -1
    1:   }
23738:   nsIntPoint pxInHyperText(coords.x - frameScreenRect.x,
 8525:                            coords.y - frameScreenRect.y);
    1:   nsPresContext *context = GetPresContext();
    1:   NS_ENSURE_TRUE(context, NS_ERROR_FAILURE);
23738:   nsPoint pointInHyperText(context->DevPixelsToAppUnits(pxInHyperText.x),
23738:                            context->DevPixelsToAppUnits(pxInHyperText.y));
    1: 
    1:   // Go through the frames to check if each one has the point.
    1:   // When one does, add up the character offsets until we have a match
    1: 
    1:   // We have an point in an accessible child of this, now we need to add up the
    1:   // offsets before it to what we already have
    1:   PRInt32 offset = 0;
40990:   PRInt32 childCount = GetChildCount();
40990:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
40990:     nsAccessible *childAcc = mChildren[childIdx];
    1: 
40990:     nsIFrame *primaryFrame = childAcc->GetFrame();
 4852:     NS_ENSURE_TRUE(primaryFrame, NS_ERROR_FAILURE);
 4852: 
 4852:     nsIFrame *frame = primaryFrame;
    1:     while (frame) {
    1:       nsIContent *content = frame->GetContent();
    1:       NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
    1:       nsPoint pointInFrame = pointInHyperText - frame->GetOffsetToExternal(hyperFrame);
    1:       nsSize frameSize = frame->GetSize();
    1:       if (pointInFrame.x < frameSize.width && pointInFrame.y < frameSize.height) {
    1:         // Finished
 5693:         if (frame->GetType() == nsAccessibilityAtoms::textFrame) {
    1:           nsIFrame::ContentOffsets contentOffsets = frame->GetContentOffsetsFromPointExternal(pointInFrame, PR_TRUE);
    1:           if (contentOffsets.IsNull() || contentOffsets.content != content) {
    1:             return NS_OK; // Not found, will return -1
    1:           }
 4261:           PRUint32 addToOffset;
 4852:           nsresult rv = ContentToRenderedOffset(primaryFrame,
 4852:                                                 contentOffsets.offset,
 4852:                                                 &addToOffset);
 4261:           NS_ENSURE_SUCCESS(rv, rv);
 4261:           offset += addToOffset;
    1:         }
    1:         *aOffset = offset;
    1:         return NS_OK;
    1:       }
    1:       frame = frame->GetNextContinuation();
    1:     }
42801: 
42801:     offset += nsAccUtils::TextLength(childAcc);
    1:   }
    1: 
    1:   return NS_OK; // Not found, will return -1
    1: }
    1: 
43888: 
43888: ////////////////////////////////////////////////////////////////////////////////
43888: // nsIAccessibleHyperText
43888: 
14209: NS_IMETHODIMP
14209: nsHyperTextAccessible::GetLinkCount(PRInt32 *aLinkCount)
    1: {
14209:   NS_ENSURE_ARG_POINTER(aLinkCount);
14209:   *aLinkCount = 0;
43888: 
40990:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
    1: 
43888:   *aLinkCount = GetLinkCount();
    1:   return NS_OK;
    1: }
    1: 
13730: NS_IMETHODIMP
43888: nsHyperTextAccessible::GetLinkAt(PRInt32 aIndex, nsIAccessibleHyperLink** aLink)
    1: {
13730:   NS_ENSURE_ARG_POINTER(aLink);
    1:   *aLink = nsnull;
13730: 
13730:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
13730: 
43888:   nsAccessible* link = GetLinkAt(aIndex);
43888:   if (link)
43888:     CallQueryInterface(link, aLink);
40990: 
43888:   return NS_OK;
    1: }
    1: 
14209: NS_IMETHODIMP
43888: nsHyperTextAccessible::GetLinkIndex(nsIAccessibleHyperLink* aLink,
43888:                                     PRInt32* aIndex)
43888: {
43888:   NS_ENSURE_ARG_POINTER(aLink);
43888: 
43888:   if (IsDefunct())
43888:     return NS_ERROR_FAILURE;
43888: 
43888:   nsRefPtr<nsAccessible> link(do_QueryObject(aLink));
43888:   *aIndex = GetLinkIndex(link);
43888:   return NS_OK;
43888: }
43888: 
43888: NS_IMETHODIMP
50622: nsHyperTextAccessible::GetLinkIndexAtOffset(PRInt32 aOffset,
43888:                                             PRInt32* aLinkIndex)
    1: {
14209:   NS_ENSURE_ARG_POINTER(aLinkIndex);
    1:   *aLinkIndex = -1; // API says this magic value means 'not found'
    1: 
40990:   if (IsDefunct())
40990:     return NS_ERROR_FAILURE;
40990: 
50622:   *aLinkIndex = GetLinkIndexAtOffset(aOffset);
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:   * nsIAccessibleEditableText impl.
    1:   */
    1: NS_IMETHODIMP nsHyperTextAccessible::SetAttributes(PRInt32 aStartPos, PRInt32 aEndPos,
    1:                                                    nsISupports *aAttributes)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::SetTextContents(const nsAString &aText)
    1: {
61202:   PRInt32 numChars = CharacterCount();
    1:   if (numChars == 0 || NS_SUCCEEDED(DeleteText(0, numChars))) {
    1:     return InsertText(aText, 0);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
38356: NS_IMETHODIMP
38356: nsHyperTextAccessible::InsertText(const nsAString &aText, PRInt32 aPosition)
    1: {
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
    1: 
38356:   nsCOMPtr<nsIPlaintextEditor> peditor(do_QueryInterface(editor));
38356:   NS_ENSURE_STATE(peditor);
38356: 
38356:   nsresult rv = SetSelectionRange(aPosition, aPosition);
38356:   NS_ENSURE_SUCCESS(rv, rv);
38356: 
38356:   return peditor->InsertText(aText);
    1: }
    1: 
38356: NS_IMETHODIMP
38356: nsHyperTextAccessible::CopyText(PRInt32 aStartPos, PRInt32 aEndPos)
    1: {
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
38356:   NS_ENSURE_STATE(editor);
    1: 
38356:   nsresult rv = SetSelectionRange(aStartPos, aEndPos);
38356:   NS_ENSURE_SUCCESS(rv, rv);
38356: 
38356:   return editor->Copy();
    1: }
    1: 
38356: NS_IMETHODIMP
38356: nsHyperTextAccessible::CutText(PRInt32 aStartPos, PRInt32 aEndPos)
    1: {
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
38356:   NS_ENSURE_STATE(editor);
    1: 
38356:   nsresult rv = SetSelectionRange(aStartPos, aEndPos);
38356:   NS_ENSURE_SUCCESS(rv, rv);
38356: 
38356:   return editor->Cut();
    1: }
    1: 
38356: NS_IMETHODIMP
38356: nsHyperTextAccessible::DeleteText(PRInt32 aStartPos, PRInt32 aEndPos)
    1: {
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
38356:   NS_ENSURE_STATE(editor);
38356: 
38356:   nsresult rv = SetSelectionRange(aStartPos, aEndPos);
38356:   NS_ENSURE_SUCCESS(rv, rv);
38356: 
38356:   return editor->DeleteSelection(nsIEditor::eNone);
38356: }
38356: 
38356: NS_IMETHODIMP
38356: nsHyperTextAccessible::PasteText(PRInt32 aPosition)
38356: {
38356:   nsCOMPtr<nsIEditor> editor;
38356:   GetAssociatedEditor(getter_AddRefs(editor));
38356:   NS_ENSURE_STATE(editor);
38356: 
38356:   nsresult rv = SetSelectionRange(aPosition, aPosition);
38356:   NS_ENSURE_SUCCESS(rv, rv);
38356: 
    1:   return editor->Paste(nsIClipboard::kGlobalClipboard);
    1: }
    1: 
 3155: NS_IMETHODIMP
 3381: nsHyperTextAccessible::GetAssociatedEditor(nsIEditor **aEditor)
 3155: {
 3155:   NS_ENSURE_ARG_POINTER(aEditor);
43504:   *aEditor = nsnull;
 3155: 
43504:   if (IsDefunct())
43504:     return NS_ERROR_FAILURE;
 3155: 
43504:   if (!mContent->HasFlag(NODE_IS_EDITABLE)) {
 5750:     // If we're inside an editable container, then return that container's editor
 5750:     nsCOMPtr<nsIAccessible> ancestor, current = this;
 5750:     while (NS_SUCCEEDED(current->GetParent(getter_AddRefs(ancestor))) && ancestor) {
 5750:       nsRefPtr<nsHyperTextAccessible> ancestorTextAccessible;
 5750:       ancestor->QueryInterface(NS_GET_IID(nsHyperTextAccessible),
 5750:                                getter_AddRefs(ancestorTextAccessible));
 5750:       if (ancestorTextAccessible) {
 5750:         // Recursion will stop at container doc because it has its own impl
 5750:         // of GetAssociatedEditor()
 5750:         return ancestorTextAccessible->GetAssociatedEditor(aEditor);
 5750:       }
 5750:       current = ancestor;
 5750:     }
 3155:     return NS_OK;
 3155:   }
 3155: 
 5679:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
43504:     nsCoreUtils::GetDocShellTreeItemFor(mContent);
 4625:   nsCOMPtr<nsIEditingSession> editingSession(do_GetInterface(docShellTreeItem));
 4625:   if (!editingSession)
 4625:     return NS_OK; // No editing session interface
 4625: 
 4625:   nsCOMPtr<nsIPresShell> shell = GetPresShell();
 4625:   NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
 4625: 
 4625:   nsCOMPtr<nsIDocument> doc = shell->GetDocument();
 4625:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
 4625: 
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   return editingSession->GetEditorForWindow(doc->GetWindow(), aEditor);
 4625: }
 4625: 
    1: /**
    1:   * =================== Caret & Selection ======================
    1:   */
    1: 
38356: nsresult
38356: nsHyperTextAccessible::SetSelectionRange(PRInt32 aStartPos, PRInt32 aEndPos)
    1: {
38356:   nsresult rv = TakeFocus();
38356:   NS_ENSURE_SUCCESS(rv, rv);
38356: 
    1:   // Set the selection
38356:   SetSelectionBounds(0, aStartPos, aEndPos);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // If range 0 was successfully set, clear any additional selection 
    1:   // ranges remaining from previous selection
    1:   nsCOMPtr<nsISelection> domSel;
    1:   nsCOMPtr<nsISelectionController> selCon;
16001:   GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                 getter_AddRefs(selCon), getter_AddRefs(domSel));
    1:   if (domSel) {
    1:     PRInt32 numRanges;
    1:     domSel->GetRangeCount(&numRanges);
    1: 
    1:     for (PRInt32 count = 0; count < numRanges - 1; count ++) {
    1:       nsCOMPtr<nsIDOMRange> range;
    1:       domSel->GetRangeAt(1, getter_AddRefs(range));
    1:       domSel->RemoveRange(range);
    1:     }
    1:   }
    1:   
    1:   if (selCon) {
12392:     // XXX I'm not sure this can do synchronous scrolling. If the last param is
12392:     // set to true, this calling might flush the pending reflow. See bug 418470.
    1:     selCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
56442:       nsISelectionController::SELECTION_FOCUS_REGION, 0);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
38356: NS_IMETHODIMP
38356: nsHyperTextAccessible::SetCaretOffset(PRInt32 aCaretOffset)
    1: {
    1:   return SetSelectionRange(aCaretOffset, aCaretOffset);
    1: }
    1: 
    1: /*
    1:  * Gets the offset position of the caret (cursor).
    1:  */
22834: NS_IMETHODIMP
22834: nsHyperTextAccessible::GetCaretOffset(PRInt32 *aCaretOffset)
    1: {
22834:   *aCaretOffset = -1;
    1: 
22834:   // No caret if the focused node is not inside this DOM node and this DOM node
22834:   // is not inside of focused node.
43504: 
43504:   nsINode* thisNode = GetNode();
22834:   PRBool isInsideOfFocusedNode =
43504:     nsCoreUtils::IsAncestorOf(gLastFocusedNode, thisNode);
22834: 
43504:   if (!isInsideOfFocusedNode && thisNode != gLastFocusedNode &&
43504:       !nsCoreUtils::IsAncestorOf(thisNode, gLastFocusedNode))
22834:     return NS_OK;
22834: 
22834:   // Turn the focus node and offset of the selection into caret hypretext
22834:   // offset.
    1:   nsCOMPtr<nsISelection> domSel;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, getter_AddRefs(domSel));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
42796:   nsCOMPtr<nsIDOMNode> focusDOMNode;
42796:   rv = domSel->GetFocusNode(getter_AddRefs(focusDOMNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
22834:   PRInt32 focusOffset;
22834:   rv = domSel->GetFocusOffset(&focusOffset);
22834:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
22834:   // No caret if this DOM node is inside of focused node but the selection's
22834:   // focus point is not inside of this DOM node.
43504:   nsCOMPtr<nsINode> focusNode(do_QueryInterface(focusDOMNode));
22834:   if (isInsideOfFocusedNode) {
42796:     nsINode *resultNode =
22834:       nsCoreUtils::GetDOMNodeFromDOMPoint(focusNode, focusOffset);
37539: 
37539:     if (resultNode != thisNode &&
37539:         !nsCoreUtils::IsAncestorOf(thisNode, resultNode))
22834:       return NS_OK;
22834:   }
22834: 
43504:   DOMPointToHypertextOffset(focusNode, focusOffset, aCaretOffset);
42377:   return NS_OK;
    1: }
    1: 
 8901: PRInt32 nsHyperTextAccessible::GetCaretLineNumber()
 8901: {
 8901:   // Provide the line number for the caret, relative to the
 8901:   // currently focused node. Use a 1-based index
 8901:   nsCOMPtr<nsISelection> domSel;
16001:   GetSelections(nsISelectionController::SELECTION_NORMAL, nsnull,
16001:                 getter_AddRefs(domSel));
 8901:   nsCOMPtr<nsISelectionPrivate> privateSelection(do_QueryInterface(domSel));
 8901:   NS_ENSURE_TRUE(privateSelection, -1);
 8901:   nsCOMPtr<nsFrameSelection> frameSelection;
 8901:   privateSelection->GetFrameSelection(getter_AddRefs(frameSelection));
 8901:   NS_ENSURE_TRUE(frameSelection, -1);
 8901: 
 8901:   nsCOMPtr<nsIDOMNode> caretNode;
 8901:   domSel->GetFocusNode(getter_AddRefs(caretNode));
 8901:   nsCOMPtr<nsIContent> caretContent = do_QueryInterface(caretNode);
43504:   if (!caretContent || !nsCoreUtils::IsAncestorOf(GetNode(), caretContent))
 8901:     return -1;
 8901: 
 8901:   PRInt32 caretOffset, returnOffsetUnused;
 8901:   domSel->GetFocusOffset(&caretOffset);
 8901:   nsFrameSelection::HINT hint = frameSelection->GetHint();
 8901:   nsIFrame *caretFrame = frameSelection->GetFrameForNodeOffset(caretContent, caretOffset,
 8901:                                                                hint, &returnOffsetUnused);
 8901:   NS_ENSURE_TRUE(caretFrame, -1);
 8901: 
 8901:   PRInt32 lineNumber = 1;
21112:   nsAutoLineIterator lineIterForCaret;
43505:   nsIContent *hyperTextContent = IsContent() ? mContent.get() : nsnull;
 8901:   while (caretFrame) {
 8901:     if (hyperTextContent == caretFrame->GetContent()) {
 8901:       return lineNumber; // Must be in a single line hyper text, there is no line iterator
 8901:     }
 8901:     nsIFrame *parentFrame = caretFrame->GetParent();
 8901:     if (!parentFrame)
 8901:       break;
 8901: 
 8901:     // Add lines for the sibling frames before the caret
 8901:     nsIFrame *sibling = parentFrame->GetFirstChild(nsnull);
 8901:     while (sibling && sibling != caretFrame) {
21112:       nsAutoLineIterator lineIterForSibling = sibling->GetLineIterator();
 8901:       if (lineIterForSibling) {
 8901:         // For the frames before that grab all the lines
21112:         PRInt32 addLines = lineIterForSibling->GetNumLines();
 8901:         lineNumber += addLines;
 8901:       }
 8901:       sibling = sibling->GetNextSibling();
 8901:     }
 8901: 
 8901:     // Get the line number relative to the container with lines
 8901:     if (!lineIterForCaret) {   // Add the caret line just once
21112:       lineIterForCaret = parentFrame->GetLineIterator();
 8901:       if (lineIterForCaret) {
 8901:         // Ancestor of caret
21112:         PRInt32 addLines = lineIterForCaret->FindLineContaining(caretFrame);
 8901:         lineNumber += addLines;
 8901:       }
 8901:     }
 8901: 
 8901:     caretFrame = parentFrame;
 8901:   }
 8901: 
 8901:   NS_NOTREACHED("DOM ancestry had this hypertext but frame ancestry didn't");
 8901:   return lineNumber;
 8901: }
 8901: 
16001: nsresult
16001: nsHyperTextAccessible::GetSelections(PRInt16 aType,
16001:                                      nsISelectionController **aSelCon,
 6072:                                      nsISelection **aDomSel,
 6072:                                      nsCOMArray<nsIDOMRange>* aRanges)
    1: {
43504:   if (IsDefunct())
 6072:     return NS_ERROR_FAILURE;
43504: 
    1:   if (aSelCon) {
    1:     *aSelCon = nsnull;
    1:   }
    1:   if (aDomSel) {
    1:     *aDomSel = nsnull;
    1:   }
 6072:   if (aRanges) {
 6072:     aRanges->Clear();
 6072:   }
 6072:   
 6072:   nsCOMPtr<nsISelection> domSel;
 6072:   nsCOMPtr<nsISelectionController> selCon;
    1: 
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
 6072:   nsCOMPtr<nsIPlaintextEditor> peditor(do_QueryInterface(editor));
 6072:   if (peditor) {
 6072:     // Case 1: plain text editor
 6072:     // This is for form controls which have their own
 6072:     // selection controller separate from the document, for example
 6072:     // HTML:input, HTML:textarea, XUL:textbox, etc.
 6072:     editor->GetSelectionController(getter_AddRefs(selCon));
    1:   }
 6072:   else {
 6072:     // Case 2: rich content subtree (can be rich editor)
 6072:     // This uses the selection controller from the entire document
    1:     nsIFrame *frame = GetFrame();
    1:     NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
    1: 
    1:     // Get the selection and selection controller
    1:     frame->GetSelectionController(GetPresContext(),
    1:                                   getter_AddRefs(selCon));
16001:   }
    1:   NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
16001: 
16001:   selCon->GetSelection(aType, getter_AddRefs(domSel));
 6072:   NS_ENSURE_TRUE(domSel, NS_ERROR_FAILURE);
10870: 
    1:   if (aSelCon) {
    1:     NS_ADDREF(*aSelCon = selCon);
    1:   }
 6072:   if (aDomSel) {
 6072:     NS_ADDREF(*aDomSel = domSel);
 6072:   }
16001: 
 6072:   if (aRanges) {
 6072:     nsCOMPtr<nsISelection2> selection2(do_QueryInterface(domSel));
 6072:     NS_ENSURE_TRUE(selection2, NS_ERROR_FAILURE);
    1: 
43504:     nsCOMPtr<nsINode> startNode = GetNode();
16001:     if (peditor) {
16001:       nsCOMPtr<nsIDOMElement> editorRoot;
16001:       editor->GetRootElement(getter_AddRefs(editorRoot));
16001:       startNode = do_QueryInterface(editorRoot);
16001:     }
16001:     NS_ENSURE_STATE(startNode);
16001: 
43504:     PRUint32 childCount = startNode->GetChildCount();
43504:     nsCOMPtr<nsIDOMNode> startDOMNode(do_QueryInterface(startNode));
43504:     nsresult rv = selection2->
43504:       GetRangesForIntervalCOMArray(startDOMNode, 0, startDOMNode, childCount,
 6072:                                    PR_TRUE, aRanges);
 6072:     NS_ENSURE_SUCCESS(rv, rv);
 6072:     // Remove collapsed ranges
 6072:     PRInt32 numRanges = aRanges->Count();
 6072:     for (PRInt32 count = 0; count < numRanges; count ++) {
 6072:       PRBool isCollapsed;
 6072:       (*aRanges)[count]->GetCollapsed(&isCollapsed);
 6072:       if (isCollapsed) {
 6072:         aRanges->RemoveObjectAt(count);
 6072:         -- numRanges;
 6072:         -- count;
 6072:       }
 6072:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Gets the number of selected regions.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetSelectionCount(PRInt32 *aSelectionCount)
    1: {
    1:   nsCOMPtr<nsISelection> domSel;
 6072:   nsCOMArray<nsIDOMRange> ranges;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, nsnull, &ranges);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6072:   *aSelectionCount = ranges.Count();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Gets the start and end offset of the specified selection.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetSelectionBounds(PRInt32 aSelectionNum, PRInt32 *aStartOffset, PRInt32 *aEndOffset)
    1: {
    1:   *aStartOffset = *aEndOffset = 0;
    1: 
    1:   nsCOMPtr<nsISelection> domSel;
 6072:   nsCOMArray<nsIDOMRange> ranges;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, getter_AddRefs(domSel), &ranges);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6072:   PRInt32 rangeCount = ranges.Count();
    1:   if (aSelectionNum < 0 || aSelectionNum >= rangeCount)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
 6072:   nsCOMPtr<nsIDOMRange> range = ranges[aSelectionNum];
    1: 
 6072:   // Get start point
43504:   nsCOMPtr<nsIDOMNode> startDOMNode;
43504:   range->GetStartContainer(getter_AddRefs(startDOMNode));
43504:   nsCOMPtr<nsINode> startNode(do_QueryInterface(startDOMNode));
    1:   PRInt32 startOffset;
    1:   range->GetStartOffset(&startOffset);
    1: 
 6072:   // Get end point
43504:   nsCOMPtr<nsIDOMNode> endDOMNode;
43504:   range->GetEndContainer(getter_AddRefs(endDOMNode));
43504:   nsCOMPtr<nsINode> endNode(do_QueryInterface(endDOMNode));
    1:   PRInt32 endOffset;
    1:   range->GetEndOffset(&endOffset);
 6072: 
 6072:   PRInt16 rangeCompareResult;
 6072:   rv = range->CompareBoundaryPoints(nsIDOMRange::START_TO_END, range, &rangeCompareResult);
 6072:   NS_ENSURE_SUCCESS(rv, rv);
 6072: 
 6072:   if (rangeCompareResult < 0) {
 6072:     // Make sure start is before end, by swapping offsets
 6072:     // This occurs when the user selects backwards in the text
 6072:     startNode.swap(endNode);
 6072:     PRInt32 tempOffset = startOffset;
 6072:     startOffset = endOffset;
 6072:     endOffset = tempOffset;
    1:   }
 6072: 
42377:   nsAccessible *startAccessible =
42377:     DOMPointToHypertextOffset(startNode, startOffset, aStartOffset);
 6072:   if (!startAccessible) {
 6072:     *aStartOffset = 0; // Could not find start point within this hypertext, so starts before
 6072:   }
 6072: 
42377:   DOMPointToHypertextOffset(endNode, endOffset, aEndOffset, PR_TRUE);
42377:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Changes the start and end offset of the specified selection.
    1:  */
 6286: NS_IMETHODIMP
 6286: nsHyperTextAccessible::SetSelectionBounds(PRInt32 aSelectionNum,
 6286:                                           PRInt32 aStartOffset,
 6286:                                           PRInt32 aEndOffset)
    1: {
    1:   nsCOMPtr<nsISelection> domSel;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, getter_AddRefs(domSel));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6286:   // Caret is a collapsed selection
 6286:   PRBool isOnlyCaret = (aStartOffset == aEndOffset);
    1: 
    1:   PRInt32 rangeCount;
    1:   domSel->GetRangeCount(&rangeCount);
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   if (aSelectionNum == rangeCount) { // Add a range
    1:     range = do_CreateInstance(kRangeCID);
    1:     NS_ENSURE_TRUE(range, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1:   else if (aSelectionNum < 0 || aSelectionNum > rangeCount) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1:   else {
    1:     domSel->GetRangeAt(aSelectionNum, getter_AddRefs(range));
    1:     NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
    1:   }
    1: 
 6286:   PRInt32 startOffset, endOffset;
 6286:   nsCOMPtr<nsIDOMNode> startNode, endNode;
    1: 
 6286:   rv = HypertextOffsetsToDOMRange(aStartOffset, aEndOffset,
 6286:                                   getter_AddRefs(startNode), &startOffset,
 6286:                                   getter_AddRefs(endNode), &endOffset);
 6286:   NS_ENSURE_SUCCESS(rv, rv);
 5706: 
 6286:   rv = range->SetStart(startNode, startOffset);
 6073:   NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:   rv = isOnlyCaret ? range->Collapse(PR_TRUE) :
 6286:                      range->SetEnd(endNode, endOffset);
 5706:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aSelectionNum == rangeCount) { // Add successfully created new range
    1:     return domSel->AddRange(range);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Adds a selection bounded by the specified offsets.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::AddSelection(PRInt32 aStartOffset, PRInt32 aEndOffset)
    1: {
    1:   nsCOMPtr<nsISelection> domSel;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, getter_AddRefs(domSel));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRInt32 rangeCount;
    1:   domSel->GetRangeCount(&rangeCount);
    1: 
    1:   return SetSelectionBounds(rangeCount, aStartOffset, aEndOffset);
    1: }
    1: 
    1: /*
    1:  * Removes the specified selection.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::RemoveSelection(PRInt32 aSelectionNum)
    1: {
    1:   nsCOMPtr<nsISelection> domSel;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, getter_AddRefs(domSel));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRInt32 rangeCount;
    1:   domSel->GetRangeCount(&rangeCount);
    1:   if (aSelectionNum < 0 || aSelectionNum >= rangeCount)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   domSel->GetRangeAt(aSelectionNum, getter_AddRefs(range));
    1:   return domSel->RemoveRange(range);
    1: }
    1: 
 6286: // void nsIAccessibleText::
 6286: //   scrollSubstringTo(in long startIndex, in long endIndex,
 6286: //                     in unsigned long scrollType);
 5245: NS_IMETHODIMP
 5245: nsHyperTextAccessible::ScrollSubstringTo(PRInt32 aStartIndex, PRInt32 aEndIndex,
 5245:                                          PRUint32 aScrollType)
 5245: {
 6286:   PRInt32 startOffset, endOffset;
 6286:   nsCOMPtr<nsIDOMNode> startNode, endNode;
 5245: 
 6286:   nsresult rv = HypertextOffsetsToDOMRange(aStartIndex, aEndIndex,
 6286:                                            getter_AddRefs(startNode),
 6286:                                            &startOffset,
 6286:                                            getter_AddRefs(endNode),
 5245:                                            &endOffset);
 5245:   NS_ENSURE_SUCCESS(rv, rv);
 5245: 
20521:   return nsCoreUtils::ScrollSubstringTo(GetFrame(), startNode, startOffset,
 5245:                                         endNode, endOffset, aScrollType);
 5245: }
 5245: 
 6286: // void nsIAccessibleText::
 6286: //   scrollSubstringToPoint(in long startIndex, in long endIndex,
 6286: //                          in unsigned long coordinateType,
 6286: //                          in long x, in long y);
 6286: NS_IMETHODIMP
 6286: nsHyperTextAccessible::ScrollSubstringToPoint(PRInt32 aStartIndex,
 6286:                                               PRInt32 aEndIndex,
 6286:                                               PRUint32 aCoordinateType,
 6286:                                               PRInt32 aX, PRInt32 aY)
 6286: {
 6286:   nsIFrame *frame = GetFrame();
 6286:   if (!frame)
 6286:     return NS_ERROR_FAILURE;
 6286: 
 6286:   nsIntPoint coords;
20536:   nsresult rv = nsAccUtils::ConvertToScreenCoords(aX, aY, aCoordinateType,
 6286:                                                   this, &coords);
 6286:   NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:   PRInt32 startOffset, endOffset;
 6286:   nsCOMPtr<nsIDOMNode> startNode, endNode;
 6286: 
 6286:   rv = HypertextOffsetsToDOMRange(aStartIndex, aEndIndex,
 6286:                                   getter_AddRefs(startNode), &startOffset,
 6286:                                   getter_AddRefs(endNode), &endOffset);
 6286:   NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:   nsPresContext *presContext = frame->PresContext();
 6286: 
 6286:   PRBool initialScrolled = PR_FALSE;
 6286:   nsIFrame *parentFrame = frame;
11383:   while ((parentFrame = parentFrame->GetParent())) {
23554:     nsIScrollableFrame *scrollableFrame = do_QueryFrame(parentFrame);
 6286:     if (scrollableFrame) {
 6286:       if (!initialScrolled) {
 6286:         // Scroll substring to the given point. Turn the point into percents
20521:         // relative scrollable area to use nsCoreUtils::ScrollSubstringTo.
 6286:         nsIntRect frameRect = parentFrame->GetScreenRectExternal();
 6286:         PRInt32 devOffsetX = coords.x - frameRect.x;
 6286:         PRInt32 devOffsetY = coords.y - frameRect.y;
 6286: 
 6286:         nsPoint offsetPoint(presContext->DevPixelsToAppUnits(devOffsetX),
 6286:                             presContext->DevPixelsToAppUnits(devOffsetY));
 6286: 
 6286:         nsSize size(parentFrame->GetSize());
34727: 
34727:         // avoid divide by zero
34727:         size.width = size.width ? size.width : 1;
34727:         size.height = size.height ? size.height : 1;
34727: 
 6286:         PRInt16 hPercent = offsetPoint.x * 100 / size.width;
 6286:         PRInt16 vPercent = offsetPoint.y * 100 / size.height;
 6286: 
20521:         rv = nsCoreUtils::ScrollSubstringTo(GetFrame(), startNode, startOffset,
 6286:                                             endNode, endOffset,
 6286:                                             vPercent, hPercent);
 6286:         NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:         initialScrolled = PR_TRUE;
 6286:       } else {
 6286:         // Substring was scrolled to the given point already inside its closest
 6286:         // scrollable area. If there are nested scrollable areas then make
 6286:         // sure we scroll lower areas to the given point inside currently
 6286:         // traversed scrollable area.
20521:         nsCoreUtils::ScrollFrameToPoint(parentFrame, frame, coords);
 6286:       }
 6286:     }
 6286:     frame = parentFrame;
 6286:   }
 6286: 
 6286:   return NS_OK;
 6286: }
 6286: 
43888: ////////////////////////////////////////////////////////////////////////////////
43888: // nsAccessible public
43888: 
43888: void
43888: nsHyperTextAccessible::InvalidateChildren()
43888: {
47107:   mOffsets.Clear();
47107: 
43888:   nsAccessibleWrap::InvalidateChildren();
43888: }
43888: 
61784: PRBool
61784: nsHyperTextAccessible::RemoveChild(nsAccessible* aAccessible)
61784: {
61784:   PRInt32 childIndex = aAccessible->GetIndexInParent();
61784:   PRInt32 count = mOffsets.Length() - childIndex;
61784:   if (count > 0)
61784:     mOffsets.RemoveElementsAt(childIndex, count);
61784: 
61784:   return nsAccessible::RemoveChild(aAccessible);
61784: }
61784: 
43888: ////////////////////////////////////////////////////////////////////////////////
43888: // nsHyperTextAccessible public static
43888: 
 4261: nsresult nsHyperTextAccessible::ContentToRenderedOffset(nsIFrame *aFrame, PRInt32 aContentOffset,
 4261:                                                         PRUint32 *aRenderedOffset)
 4261: {
 8374:   if (!aFrame) {
 8374:     // Current frame not rendered -- this can happen if text is set on
 8374:     // something with display: none
 8374:     *aRenderedOffset = 0;
 8374:     return NS_OK;
 8374:   }
 5693:   NS_ASSERTION(aFrame->GetType() == nsAccessibilityAtoms::textFrame,
 5693:                "Need text frame for offset conversion");
 5693:   NS_ASSERTION(aFrame->GetPrevContinuation() == nsnull,
 5693:                "Call on primary frame only");
 5693: 
 4261:   gfxSkipChars skipChars;
 4261:   gfxSkipCharsIterator iter;
23536:   // Only get info up to original offset, we know that will be larger than skipped offset
 4261:   nsresult rv = aFrame->GetRenderedText(nsnull, &skipChars, &iter, 0, aContentOffset);
 4261:   NS_ENSURE_SUCCESS(rv, rv);
 4261: 
 4261:   PRUint32 ourRenderedStart = iter.GetSkippedOffset();
 4261:   PRInt32 ourContentStart = iter.GetOriginalOffset();
 4261: 
 4261:   *aRenderedOffset = iter.ConvertOriginalToSkipped(aContentOffset + ourContentStart) -
 4261:                     ourRenderedStart;
 4261: 
 4261:   return NS_OK;
 4261: }
 4261: 
 4261: nsresult nsHyperTextAccessible::RenderedToContentOffset(nsIFrame *aFrame, PRUint32 aRenderedOffset,
 4261:                                                         PRInt32 *aContentOffset)
 4261: {
 8374:   *aContentOffset = 0;
 8374:   NS_ENSURE_TRUE(aFrame, NS_ERROR_FAILURE);
 8374: 
 5693:   NS_ASSERTION(aFrame->GetType() == nsAccessibilityAtoms::textFrame,
 5693:                "Need text frame for offset conversion");
 5693:   NS_ASSERTION(aFrame->GetPrevContinuation() == nsnull,
 5693:                "Call on primary frame only");
 5693: 
 4261:   gfxSkipChars skipChars;
 4261:   gfxSkipCharsIterator iter;
 4261:   // We only need info up to skipped offset -- that is what we're converting to original offset
 4261:   nsresult rv = aFrame->GetRenderedText(nsnull, &skipChars, &iter, 0, aRenderedOffset);
 4261:   NS_ENSURE_SUCCESS(rv, rv);
 4261: 
 4261:   PRUint32 ourRenderedStart = iter.GetSkippedOffset();
 4261:   PRInt32 ourContentStart = iter.GetOriginalOffset();
 4261: 
 4261:   *aContentOffset = iter.ConvertSkippedToOriginal(aRenderedOffset + ourRenderedStart) - ourContentStart;
 4261: 
 4261:   return NS_OK;
 4261: }
 4261: 
42799: ////////////////////////////////////////////////////////////////////////////////
47107: // nsHyperTextAccessible public
47107: 
61843: bool
61843: nsHyperTextAccessible::GetCharAt(PRInt32 aOffset, EGetTextType aShift,
61843:                                  nsAString& aChar, PRInt32* aStartOffset,
61843:                                  PRInt32* aEndOffset)
61843: {
61843:   aChar.Truncate();
61843: 
61843:   PRInt32 offset = ConvertMagicOffset(aOffset) + static_cast<PRInt32>(aShift);
61843:   PRInt32 childIdx = GetChildIndexAtOffset(offset);
61843:   if (childIdx == -1)
61843:     return false;
61843: 
61843:   nsAccessible* child = GetChildAt(childIdx);
61843:   child->AppendTextTo(aChar, offset - GetChildOffset(childIdx), 1);
61843: 
61843:   if (aStartOffset)
61843:     *aStartOffset = offset;
61843:   if (aEndOffset)
61843:     *aEndOffset = aChar.IsEmpty() ? offset : offset + 1;
61843: 
61843:   return true;
61843: }
61843: 
47107: PRInt32
50622: nsHyperTextAccessible::GetChildOffset(PRUint32 aChildIndex,
47107:                                       PRBool aInvalidateAfter)
47107: {
60922:   if (aChildIndex == 0) {
60922:     if (aInvalidateAfter)
60922:       mOffsets.Clear();
60922: 
50622:     return aChildIndex;
60922:   }
47107: 
50622:   PRInt32 count = mOffsets.Length() - aChildIndex;
47107:   if (count > 0) {
47107:     if (aInvalidateAfter)
50622:       mOffsets.RemoveElementsAt(aChildIndex, count);
47107: 
50622:     return mOffsets[aChildIndex - 1];
47107:   }
47107: 
47107:   PRUint32 lastOffset = mOffsets.IsEmpty() ?
47107:     0 : mOffsets[mOffsets.Length() - 1];
47107: 
50622:   while (mOffsets.Length() < aChildIndex) {
47107:     nsAccessible* child = mChildren[mOffsets.Length()];
47107:     lastOffset += nsAccUtils::TextLength(child);
47107:     mOffsets.AppendElement(lastOffset);
47107:   }
47107: 
50622:   return mOffsets[aChildIndex - 1];
48923: }
50622: 
50622: PRInt32
50622: nsHyperTextAccessible::GetChildIndexAtOffset(PRUint32 aOffset)
50622: {
50622:   PRUint32 lastOffset = 0;
50622:   PRUint32 offsetCount = mOffsets.Length();
50622:   if (offsetCount > 0) {
50622:     lastOffset = mOffsets[offsetCount - 1];
50622:     if (aOffset < lastOffset) {
50622:       PRUint32 low = 0, high = offsetCount;
50622:       while (high > low) {
50622:         PRUint32 mid = (high + low) >> 1;
50622:         if (mOffsets[mid] == aOffset)
50622:           return mid < offsetCount - 1 ? mid + 1 : mid;
50622: 
50622:         if (mOffsets[mid] < aOffset)
50622:           low = mid + 1;
50622:         else
50622:           high = mid;
50622:       }
50622:       if (high == offsetCount)
50622:         return -1;
50622: 
50860:       return low;
50622:     }
50622:   }
50622: 
50622:   PRUint32 childCount = GetChildCount();
50622:   while (mOffsets.Length() < childCount) {
50622:     nsAccessible* child = GetChildAt(mOffsets.Length());
50622:     lastOffset += nsAccUtils::TextLength(child);
50622:     mOffsets.AppendElement(lastOffset);
50622:     if (aOffset < lastOffset)
50622:       return mOffsets.Length() - 1;
50622:   }
50622: 
50622:   if (aOffset == lastOffset)
50622:     return mOffsets.Length() - 1;
50622: 
50622:   return -1;
50622: }
50622: 
48923: ////////////////////////////////////////////////////////////////////////////////
48923: // nsHyperTextAccessible protected
48923: 
 6286: nsresult
 6286: nsHyperTextAccessible::GetDOMPointByFrameOffset(nsIFrame *aFrame,
 6286:                                                 PRInt32 aOffset,
 6286:                                                 nsIAccessible *aAccessible,
 6286:                                                 nsIDOMNode **aNode,
 6286:                                                 PRInt32 *aNodeOffset)
 6286: {
 6286:   NS_ENSURE_ARG(aAccessible);
 4261: 
 6286:   nsCOMPtr<nsIDOMNode> node;
 6286: 
 6286:   if (!aFrame) {
 6286:     // If the given frame is null then set offset after the DOM node of the
 6286:     // given accessible.
 6286:     nsCOMPtr<nsIAccessNode> accessNode(do_QueryInterface(aAccessible));
 6286: 
 6286:     nsCOMPtr<nsIDOMNode> DOMNode;
 6286:     accessNode->GetDOMNode(getter_AddRefs(DOMNode));
 6286:     nsCOMPtr<nsIContent> content(do_QueryInterface(DOMNode));
 6286:     NS_ENSURE_STATE(content);
 6286: 
 6286:     nsCOMPtr<nsIContent> parent(content->GetParent());
 6286:     NS_ENSURE_STATE(parent);
 6286: 
 6286:     *aNodeOffset = parent->IndexOf(content) + 1;
 6286:     node = do_QueryInterface(parent);
 6286: 
 6286:   } else if (aFrame->GetType() == nsAccessibilityAtoms::textFrame) {
 6286:     nsCOMPtr<nsIContent> content(aFrame->GetContent());
 6286:     NS_ENSURE_STATE(content);
 6286: 
36654:     nsIFrame *primaryFrame = content->GetPrimaryFrame();
 6286:     nsresult rv = RenderedToContentOffset(primaryFrame, aOffset, aNodeOffset);
 6286:     NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:     node = do_QueryInterface(content);
 6286: 
 6286:   } else {
 6286:     nsCOMPtr<nsIContent> content(aFrame->GetContent());
 6286:     NS_ENSURE_STATE(content);
 6286: 
 6286:     nsCOMPtr<nsIContent> parent(content->GetParent());
 6286:     NS_ENSURE_STATE(parent);
 6286: 
 6286:     *aNodeOffset = parent->IndexOf(content);
 6286:     node = do_QueryInterface(parent);
 6286:   }
 6286: 
 6286:   NS_IF_ADDREF(*aNode = node);
 6286:   return NS_OK;
 6286: }
 6286: 
16001: // nsHyperTextAccessible
16001: nsresult
16001: nsHyperTextAccessible::DOMRangeBoundToHypertextOffset(nsIDOMRange *aRange,
16001:                                                       PRBool aIsStartBound,
16001:                                                       PRBool aIsStartHTOffset,
16001:                                                       PRInt32 *aHTOffset)
16001: {
43504:   nsCOMPtr<nsIDOMNode> DOMNode;
16001:   PRInt32 nodeOffset = 0;
16001: 
16001:   nsresult rv;
16001:   if (aIsStartBound) {
43504:     rv = aRange->GetStartContainer(getter_AddRefs(DOMNode));
16001:     NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:     rv = aRange->GetStartOffset(&nodeOffset);
16001:     NS_ENSURE_SUCCESS(rv, rv);
16001:   } else {
43504:     rv = aRange->GetEndContainer(getter_AddRefs(DOMNode));
16001:     NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:     rv = aRange->GetEndOffset(&nodeOffset);
16001:     NS_ENSURE_SUCCESS(rv, rv);
16001:   }
16001: 
43504:   nsCOMPtr<nsINode> node(do_QueryInterface(DOMNode));
42377:   nsAccessible *startAcc =
42377:     DOMPointToHypertextOffset(node, nodeOffset, aHTOffset);
16001: 
16001:   if (aIsStartHTOffset && !startAcc)
16001:     *aHTOffset = 0;
16001: 
16001:   return NS_OK;
16001: }
16001: 
16001: // nsHyperTextAccessible
16001: nsresult
16001: nsHyperTextAccessible::GetSpellTextAttribute(nsIDOMNode *aNode,
16001:                                              PRInt32 aNodeOffset,
16001:                                              PRInt32 *aHTStartOffset,
16001:                                              PRInt32 *aHTEndOffset,
16001:                                              nsIPersistentProperties *aAttributes)
16001: {
16001:   nsCOMArray<nsIDOMRange> ranges;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_SPELLCHECK,
16001:                               nsnull, nsnull, &ranges);
16001:   NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:   PRInt32 rangeCount = ranges.Count();
16001:   if (!rangeCount)
16001:     return NS_OK;
16001: 
16001:   for (PRInt32 index = 0; index < rangeCount; index++) {
16001:     nsCOMPtr<nsIDOMRange> range = ranges[index];
16001:     nsCOMPtr<nsIDOMNSRange> nsrange(do_QueryInterface(range));
16001:     NS_ENSURE_STATE(nsrange);
16001: 
16001:     PRInt16 result;
16001:     rv = nsrange->ComparePoint(aNode, aNodeOffset, &result);
16001:     NS_ENSURE_SUCCESS(rv, rv);
20634:     // ComparePoint checks boundary points, but we need to check that
20634:     // text at aNodeOffset is inside the range.
20634:     // See also bug 460690.
20634:     if (result == 0) {
20634:       nsCOMPtr<nsIDOMNode> end;
20634:       rv = range->GetEndContainer(getter_AddRefs(end));
20634:       NS_ENSURE_SUCCESS(rv, rv);
20634:       PRInt32 endOffset;
20634:       rv = range->GetEndOffset(&endOffset);
20634:       NS_ENSURE_SUCCESS(rv, rv);
20634:       if (aNode == end && aNodeOffset == endOffset) {
20634:         result = 1;
20634:       }
20634:     }
16001: 
16001:     if (result == 1) { // range is before point
16001:       PRInt32 startHTOffset = 0;
16001:       rv = DOMRangeBoundToHypertextOffset(range, PR_FALSE, PR_TRUE,
16001:                                           &startHTOffset);
16001:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:       if (startHTOffset > *aHTStartOffset)
16001:         *aHTStartOffset = startHTOffset;
16001: 
16001:     } else if (result == -1) { // range is after point
16001:       PRInt32 endHTOffset = 0;
16001:       rv = DOMRangeBoundToHypertextOffset(range, PR_TRUE, PR_FALSE,
16001:                                           &endHTOffset);
16001:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:       if (endHTOffset < *aHTEndOffset)
16001:         *aHTEndOffset = endHTOffset;
16001: 
16001:     } else { // point is in range
16001:       PRInt32 startHTOffset = 0;
16001:       rv = DOMRangeBoundToHypertextOffset(range, PR_TRUE, PR_TRUE,
16001:                                           &startHTOffset);
16001:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:       PRInt32 endHTOffset = 0;
16001:       rv = DOMRangeBoundToHypertextOffset(range, PR_FALSE, PR_FALSE,
16001:                                           &endHTOffset);
16001:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:       if (startHTOffset > *aHTStartOffset)
16001:         *aHTStartOffset = startHTOffset;
16001:       if (endHTOffset < *aHTEndOffset)
16001:         *aHTEndOffset = endHTOffset;
16001: 
16173:       if (aAttributes) {
20536:         nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::invalid,
16001:                                NS_LITERAL_STRING("spelling"));
16173:       }
16001: 
16001:       return NS_OK;
16001:     }
16001:   }
16001: 
16001:   return NS_OK;
16001: }
