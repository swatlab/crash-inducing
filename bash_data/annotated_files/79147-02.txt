    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:set ts=2 sts=2 sw=2 et cin:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Jacek Piskozub <piskozub@iopan.gda.pl>
    1:  *   Leon Sha <leon.sha@sun.com>
    1:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   Christian Biesinger <cbiesinger@web.de>
  130:  *   Josh Aas <josh@mozilla.com>
54309:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering objects for replaced elements implemented by a plugin */
    1: 
50668: #include "mozilla/plugins/PluginMessageUtils.h"
50668: 
    1: #include "nscore.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
75045: #include "nsIDOMEventListener.h"
20592: #include "nsIDOMDragEvent.h"
69092: #include "nsPluginHost.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "prmem.h"
    1: #include "nsGkAtoms.h"
    4: #include "nsIAppShell.h"
    1: #include "nsIDocument.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIURL.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIPluginInstanceOwner.h"
67677: #include "nsNPAPIPluginInstance.h"
29840: #include "nsIPluginTagInfo.h"
    1: #include "plstr.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIScrollPositionListener.h"
    1: #include "nsITimer.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeOwner.h"
    1: #include "nsDocShellCID.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMHTMLObjectElement.h"
    1: #include "nsIDOMHTMLEmbedElement.h"
    1: #include "nsIDOMHTMLAppletElement.h"
    1: #include "nsIDOMWindow.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMNSEvent.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDocumentEncoder.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIPluginWidget.h"
    1: #include "nsGUIEvent.h"
68481: #include "nsRenderingContext.h"
    1: #include "npapi.h"
    1: #include "nsTransform2D.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsIObjectLoadingContent.h"
    1: #include "nsPIDOMWindow.h"
35171: #include "nsIDOMElement.h"
    1: #include "nsContentUtils.h"
    1: #include "nsDisplayList.h"
    1: #include "nsAttrName.h"
    1: #include "nsDataHashtable.h"
13098: #include "nsDOMClassInfo.h"
29018: #include "nsFocusManager.h"
30519: #include "nsLayoutUtils.h"
30522: #include "nsFrameManager.h"
30522: #include "nsComponentManagerUtils.h"
35180: #include "nsIObserverService.h"
37067: #include "nsIScrollableFrame.h"
70842: #include "mozilla/Preferences.h"
    1: 
    1: // headers for plugin scriptability
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIXPCScriptable.h"
    1: #include "nsIClassInfo.h"
35171: #include "nsIDOMClientRect.h"
    1: 
    1: #include "nsObjectFrame.h"
    1: #include "nsIObjectFrame.h"
    1: #include "nsPluginNativeWindow.h"
    1: #include "nsIPluginDocument.h"
62646: #include "FrameLayerBuilder.h"
    1: 
 4577: #include "nsThreadUtils.h"
 4577: 
    1: #include "gfxContext.h"
54223: #include "gfxPlatform.h"
    1: 
11703: #ifdef XP_WIN
11703: #include "gfxWindowsNativeDrawing.h"
21080: #include "gfxWindowsSurface.h"
11703: #endif
11703: 
34217: #include "gfxImageSurface.h"
54223: #include "gfxUtils.h"
54223: #include "Layers.h"
62699: #include "ReadbackLayer.h"
34217: 
    1: // accessibility support
    1: #ifdef ACCESSIBILITY
61464: #include "nsAccessibilityService.h"
    1: #endif
    1: 
    1: #ifdef MOZ_LOGGING
    1: #define FORCE_PR_LOG 1 /* Allow logging in the release build */
    1: #endif /* MOZ_LOGGING */
    1: #include "prlog.h"
    1: 
    1: #include <errno.h>
    1: 
    1: #include "nsContentCID.h"
13537: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
    1: 
11944: #ifdef XP_MACOSX
11944: #include "gfxQuartzNativeDrawing.h"
32019: #include "nsPluginUtilsOSX.h"
41029: #include "nsCoreAnimationSupport.h"
11944: #endif
11944: 
 3059: #ifdef MOZ_WIDGET_GTK2
23281: #include <gdk/gdk.h>
 3059: #include <gdk/gdkx.h>
25500: #include <gtk/gtk.h>
47118: #include "gfxXlibNativeRenderer.h"
 3059: #endif
    1: 
41059: #ifdef MOZ_X11
43912: #include "mozilla/X11Util.h"
43912: using mozilla::DefaultXDisplay;
16959: #endif
16959: 
    1: #ifdef XP_WIN
    1: #include <wtypes.h>
    1: #include <winuser.h>
    1: #endif
    1: 
32955: #ifdef XP_OS2
32955: #define INCL_PM
32955: #define INCL_GPI
32955: #include <os2.h>
68865: #include "gfxOS2Surface.h"
32955: #endif
32955: 
    1: #ifdef CreateEvent // Thank you MS.
    1: #undef CreateEvent
    1: #endif
    1: 
    1: #ifdef PR_LOGGING 
    1: static PRLogModuleInfo *nsObjectFrameLM = PR_NewLogModule("nsObjectFrame");
    1: #endif /* PR_LOGGING */
    1: 
36227: #if defined(XP_MACOSX) && !defined(NP_NO_CARBON)
71609: 
36227: #define MAC_CARBON_PLUGINS
71609: 
71609: // The header files QuickdrawAPI.h and QDOffscreen.h are missing on OS X 10.7
71609: // and up (though the QuickDraw APIs defined in them are still present) -- so
71609: // we need to supply the relevant parts of their contents here.  It's likely
71609: // that Apple will eventually remove the APIs themselves (probably in OS X
71609: // 10.8), so we need to make them weak imports, and test for their presence
71609: // before using them.
71609: extern "C" {
71609:   #if !defined(__QUICKDRAWAPI__)
71609:   extern void SetRect(
71609:     Rect * r,
71609:     short  left,
71609:     short  top,
71609:     short  right,
71609:     short  bottom)
71609:     __attribute__((weak_import));
71609:   #endif /* __QUICKDRAWAPI__ */
71609: 
71609:   #if !defined(__QDOFFSCREEN__)
71609:   extern QDErr NewGWorldFromPtr(
71609:     GWorldPtr *   offscreenGWorld,
71609:     UInt32        PixelFormat,
71609:     const Rect *  boundsRect,
71609:     CTabHandle    cTable,                /* can be NULL */
71609:     GDHandle      aGDevice,              /* can be NULL */
71609:     GWorldFlags   flags,
71609:     Ptr           newBuffer,
71609:     SInt32        rowBytes)
71609:     __attribute__((weak_import));
71609:   extern void DisposeGWorld(GWorldPtr offscreenGWorld)
71609:     __attribute__((weak_import));
71609:   #endif /* __QDOFFSCREEN__ */
71609: }
71609: 
71609: #endif /* #if defined(XP_MACOSX) && !defined(NP_NO_CARBON) */
    1: 
62699: using namespace mozilla;
62699: using namespace mozilla::plugins;
54223: using namespace mozilla::layers;
54223: 
62699: class PluginBackgroundSink : public ReadbackSink {
62699: public:
62699:   PluginBackgroundSink(nsObjectFrame* aFrame, PRUint64 aStartSequenceNumber)
62699:     : mLastSequenceNumber(aStartSequenceNumber), mFrame(aFrame) {}
62699:   ~PluginBackgroundSink()
62699:   {
62699:     if (mFrame) {
62699:       mFrame->mBackgroundSink = nsnull;
62699:     }
62699:   }
62699: 
62699:   virtual void SetUnknown(PRUint64 aSequenceNumber)
62699:   {
62699:     if (!AcceptUpdate(aSequenceNumber))
62699:       return;
62699:     mFrame->mInstanceOwner->SetBackgroundUnknown();
62699:   }
62699: 
62699:   virtual already_AddRefed<gfxContext>
62699:       BeginUpdate(const nsIntRect& aRect, PRUint64 aSequenceNumber)
62699:   {
62699:     if (!AcceptUpdate(aSequenceNumber))
62699:       return nsnull;
62699:     return mFrame->mInstanceOwner->BeginUpdateBackground(aRect);
62699:   }
62699: 
62699:   virtual void EndUpdate(gfxContext* aContext, const nsIntRect& aRect)
62699:   {
62699:     return mFrame->mInstanceOwner->EndUpdateBackground(aContext, aRect);
62699:   }
62699: 
62699:   void Destroy() { mFrame = nsnull; }
62699: 
62699: protected:
62699:   PRBool AcceptUpdate(PRUint64 aSequenceNumber) {
62699:     if (aSequenceNumber > mLastSequenceNumber && mFrame &&
62699:         mFrame->mInstanceOwner) {
62699:       mLastSequenceNumber = aSequenceNumber;
62699:       return PR_TRUE;
62699:     }
62699:     return PR_FALSE;
62699:   }
62699: 
62699:   PRUint64 mLastSequenceNumber;
62699:   nsObjectFrame* mFrame;
62699: };
62699: 
12417: nsObjectFrame::nsObjectFrame(nsStyleContext* aContext)
12417:   : nsObjectFrameSuper(aContext)
52186:   , mReflowCallbackPosted(PR_FALSE)
12417: {
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("Created new nsObjectFrame %p\n", this));
12417: }
12417: 
    1: nsObjectFrame::~nsObjectFrame()
    1: {
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("nsObjectFrame %p deleted\n", this));
    1: }
    1: 
23554: NS_QUERYFRAME_HEAD(nsObjectFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIObjectFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsObjectFrameSuper)
    1: 
    1: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsObjectFrame::CreateAccessible()
    1: {
61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
46338:   return accService ?
46338:     accService->CreateHTMLObjectFrameAccessible(this, mContent,
46338:                                                 PresContext()->PresShell()) :
46338:     nsnull;
    1: }
    1: 
    1: #ifdef XP_WIN
    1: NS_IMETHODIMP nsObjectFrame::GetPluginPort(HWND *aPort)
    1: {
37446:   *aPort = (HWND) mInstanceOwner->GetPluginPortFromWidget();
    1:   return NS_OK;
    1: }
    1: #endif
    1: #endif
    1: 
77476: static NS_DEFINE_CID(kWidgetCID, NS_CHILD_CID);
77476: 
    1: NS_IMETHODIMP 
    1: nsObjectFrame::Init(nsIContent*      aContent,
    1:                     nsIFrame*        aParent,
    1:                     nsIFrame*        aPrevInFlow)
    1: {
77476:   NS_PRECONDITION(aContent, "How did that happen?");
77476:   mPreventInstantiation =
77476:     (aContent->GetCurrentDoc()->GetDisplayDocument() != nsnull);
77476: 
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("Initializing nsObjectFrame %p for content %p\n", this, aContent));
12417: 
35180:   nsresult rv = nsObjectFrameSuper::Init(aContent, aParent, aPrevInFlow);
35180: 
35180:   return rv;
    1: }
    1: 
    1: void
36647: nsObjectFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
77476:   NS_ASSERTION(!mPreventInstantiation ||
77476:                (mContent && mContent->GetCurrentDoc()->GetDisplayDocument()),
77476:                "about to crash due to bug 136927");
77476: 
77476:   // we need to finish with the plugin before native window is destroyed
77476:   // doing this in the destructor is too late.
77476:   StopPluginInternal(PR_TRUE);
77476: 
77476:   // StopPluginInternal might have disowned the widget; if it has,
77476:   // mWidget will be null.
77476:   if (mWidget) {
77476:     mInnerView->DetachWidgetEventHandler(mWidget);
77476:     mWidget->Destroy();
77476:   }
30522: 
62699:   if (mBackgroundSink) {
62699:     mBackgroundSink->Destroy();
62699:   }
62699: 
36647:   nsObjectFrameSuper::DestroyFrom(aDestructRoot);
    1: }
    1: 
20441: /* virtual */ void
20836: nsObjectFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 7015: {
 7015:   if (HasView()) {
 7015:     nsIView* view = GetView();
 7015:     nsIViewManager* vm = view->GetViewManager();
 7015:     if (vm) {
 7015:       nsViewVisibility visibility = 
 7015:         IsHidden() ? nsViewVisibility_kHide : nsViewVisibility_kShow;
 7015:       vm->SetViewVisibility(view, visibility);
 7015:     }
 7015:   }
 7015: 
20836:   nsObjectFrameSuper::DidSetStyleContext(aOldStyleContext);
 7015: }
 7015: 
    1: nsIAtom*
    1: nsObjectFrame::GetType() const
    1: {
    1:   return nsGkAtoms::objectFrame; 
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsObjectFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("ObjectFrame"), aResult);
    1: }
    1: #endif
    1: 
    1: nsresult
77476: nsObjectFrame::CreateWidget(nscoord aWidth,
77476:                             nscoord aHeight,
77476:                             PRBool  aViewOnly)
    1: {
    1:   nsIView* view = GetView();
    1:   NS_ASSERTION(view, "Object frames must have views");  
    1:   if (!view) {
77476:     return NS_OK;       //XXX why OK? MMP
77476:   }
77476: 
77476:   PRBool needsWidget = !aViewOnly;
77476:   PRBool canCreateWidget = !nsIWidget::UsePuppetWidgets();
77476:   if (needsWidget && !canCreateWidget) {
77476:     NS_WARNING("Can't use native widgets, and can't hand a plugins a PuppetWidget");
62617:   }
62617: 
    1:   nsIViewManager* viewMan = view->GetViewManager();
    1:   // mark the view as hidden since we don't know the (x,y) until Paint
    1:   // XXX is the above comment correct?
    1:   viewMan->SetViewVisibility(view, nsViewVisibility_kHide);
    1: 
77476:   nsRefPtr<nsDeviceContext> dx;
77476:   viewMan->GetDeviceContext(*getter_AddRefs(dx));
77476: 
    1:   //this is ugly. it was ripped off from didreflow(). MMP
    1:   // Position and size view relative to its parent, not relative to our
    1:   // parent frame (our parent frame may not have a view).
    1:   
    1:   nsIView* parentWithView;
    1:   nsPoint origin;
    1:   nsRect r(0, 0, mRect.width, mRect.height);
    1: 
    1:   GetOffsetFromView(origin, &parentWithView);
    1:   viewMan->ResizeView(view, r);
    1:   viewMan->MoveViewTo(view, origin.x, origin.y);
    1: 
37615:   nsRootPresContext* rpc = PresContext()->GetRootPresContext();
37615:   if (!rpc) {
37615:     return NS_ERROR_FAILURE;
37615:   }
37615: 
77476:   if (needsWidget && !mWidget && canCreateWidget) {
59654:     // XXX this breaks plugins in popups ... do we care?
77476:     nsIWidget* parentWidget =
77476:       rpc->PresShell()->FrameManager()->GetRootFrame()->GetNearestWidget();
77476:     if (!parentWidget)
59654:       return NS_ERROR_FAILURE;
59654: 
68635:     mInnerView = viewMan->CreateView(GetContentRectRelativeToSelf(), view);
33369:     if (!mInnerView) {
33369:       NS_ERROR("Could not create inner view");
33369:       return NS_ERROR_OUT_OF_MEMORY;
33369:     }
33369:     viewMan->InsertChild(view, mInnerView, nsnull, PR_TRUE);
33369: 
77476:     nsresult rv;
77476:     mWidget = do_CreateInstance(kWidgetCID, &rv);
77476:     if (NS_FAILED(rv))
77476:       return rv;
77476: 
77476:     nsWidgetInitData initData;
77476:     initData.mWindowType = eWindowType_plugin;
77476:     initData.mUnicode = PR_FALSE;
77476:     initData.clipChildren = PR_TRUE;
77476:     initData.clipSiblings = PR_TRUE;
77476:     // We want mWidget to be able to deliver events to us, especially on
77476:     // Mac where events to the plugin are routed through Gecko. So we
77476:     // allow the view to attach its event handler to mWidget even though
77476:     // mWidget isn't the view's designated widget.
33369:     EVENT_CALLBACK eventHandler = mInnerView->AttachWidgetEventHandler(mWidget);
77476:     rv = mWidget->Create(parentWidget, nsnull, nsIntRect(0,0,0,0),
77476:                          eventHandler, dx, nsnull, nsnull, &initData);
77476:     if (NS_FAILED(rv)) {
77476:       mWidget->Destroy();
77476:       mWidget = nsnull;
77476:       return rv;
77476:     }
77476: 
77476:     mWidget->EnableDragDrop(PR_TRUE);
30522: 
33373:     // If this frame has an ancestor with a widget which is not
33373:     // the root prescontext's widget, then this plugin should not be
33373:     // displayed, so don't show the widget. If we show the widget, the
33373:     // plugin may appear in the main window. In Web content this would
33373:     // only happen with a plugin in a XUL popup.
47148:     if (parentWidget == GetNearestWidget()) {
30522:       mWidget->Show(PR_TRUE);
42961: #ifdef XP_MACOSX
42961:       // On Mac, we need to invalidate ourselves since even windowed
42961:       // plugins are painted through Thebes and we need to ensure
42961:       // the Thebes layer containing the plugin is updated.
68635:       Invalidate(GetContentRectRelativeToSelf());
42961: #endif
30522:     }
77476:   }
77476: 
77476:   if (mWidget) {
37615:     rpc->RegisterPluginForGeometryUpdates(this);
47756:     rpc->RequestUpdatePluginGeometry(this);
37615: 
    1:     // Here we set the background color for this widget because some plugins will use 
    1:     // the child window background color when painting. If it's not set, it may default to gray
    1:     // Sometimes, a frame doesn't have a background color or is transparent. In this
    1:     // case, walk up the frame tree until we do find a frame with a background color
    1:     for (nsIFrame* frame = this; frame; frame = frame->GetParent()) {
40178:       nscolor bgcolor =
40178:         frame->GetVisitedDependentColor(eCSSProperty_background_color);
40178:       if (NS_GET_A(bgcolor) > 0) {  // make sure we got an actual color
40178:         mWidget->SetBackgroundColor(bgcolor);
    1:         break;
    1:       }
    1:     }
34717: 
34717: #ifdef XP_MACOSX
34717:     // Now that we have a widget we want to set the event model before
34717:     // any events are processed.
34717:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
77476:     if (!pluginWidget)
34717:       return NS_ERROR_FAILURE;
34717:     pluginWidget->SetPluginEventModel(mInstanceOwner->GetEventModel());
54248:     pluginWidget->SetPluginDrawingModel(mInstanceOwner->GetDrawingModel());
39757: 
39757:     if (mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreAnimation) {
42504:       mInstanceOwner->SetupCARefresh();
39757:     }
34717: #endif
57224:   } else {
57224: #ifndef XP_MACOSX
57224:     rpc->RegisterPluginForGeometryUpdates(this);
69788:     rpc->RequestUpdatePluginGeometry(this);
57224: #endif
    1:   }
    1: 
 7015:   if (!IsHidden()) {
    1:     viewMan->SetViewVisibility(view, nsViewVisibility_kShow);
 7015:   }
    1: 
77476:   return (needsWidget && !canCreateWidget) ? NS_ERROR_NOT_AVAILABLE : NS_OK;
    1: }
    1: 
    1: #define EMBED_DEF_WIDTH 240
    1: #define EMBED_DEF_HEIGHT 200
    1: 
    1: /* virtual */ nscoord
68481: nsObjectFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
    1: {
    1:   nscoord result = 0;
    1: 
    1:   if (!IsHidden(PR_FALSE)) {
    1:     nsIAtom *atom = mContent->Tag();
    1:     if (atom == nsGkAtoms::applet || atom == nsGkAtoms::embed) {
    1:       result = nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_WIDTH);
    1:     }
    1:   }
    1: 
    1:   DISPLAY_MIN_WIDTH(this, result);
    1:   return result;
    1: }
    1: 
    1: /* virtual */ nscoord
68481: nsObjectFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
    1: {
    1:   return nsObjectFrame::GetMinWidth(aRenderingContext);
    1: }
    1: 
    1: void
    1: nsObjectFrame::GetDesiredSize(nsPresContext* aPresContext,
    1:                               const nsHTMLReflowState& aReflowState,
    1:                               nsHTMLReflowMetrics& aMetrics)
    1: {
    1:   // By default, we have no area
    1:   aMetrics.width = 0;
    1:   aMetrics.height = 0;
    1: 
    1:   if (IsHidden(PR_FALSE)) {
    1:     return;
    1:   }
    1:   
    1:   aMetrics.width = aReflowState.ComputedWidth();
 4166:   aMetrics.height = aReflowState.ComputedHeight();
    1: 
    1:   // for EMBED and APPLET, default to 240x200 for compatibility
    1:   nsIAtom *atom = mContent->Tag();
    1:   if (atom == nsGkAtoms::applet || atom == nsGkAtoms::embed) {
    1:     if (aMetrics.width == NS_UNCONSTRAINEDSIZE) {
32531:       aMetrics.width = NS_MIN(NS_MAX(nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_WIDTH),
    1:                                      aReflowState.mComputedMinWidth),
    1:                               aReflowState.mComputedMaxWidth);
    1:     }
    1:     if (aMetrics.height == NS_UNCONSTRAINEDSIZE) {
32531:       aMetrics.height = NS_MIN(NS_MAX(nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_HEIGHT),
    1:                                       aReflowState.mComputedMinHeight),
    1:                                aReflowState.mComputedMaxHeight);
    1:     }
    1: 
  944: #if defined (MOZ_WIDGET_GTK2)
    1:     // We need to make sure that the size of the object frame does not
    1:     // exceed the maximum size of X coordinates.  See bug #225357 for
    1:     // more information.  In theory Gtk2 can handle large coordinates,
    1:     // but underlying plugins can't.
32531:     aMetrics.height = NS_MIN(aPresContext->DevPixelsToAppUnits(PR_INT16_MAX), aMetrics.height);
32531:     aMetrics.width = NS_MIN(aPresContext->DevPixelsToAppUnits(PR_INT16_MAX), aMetrics.width);
    1: #endif
    1:   }
    1: 
    1:   // At this point, the width has an unconstrained value only if we have
    1:   // nothing to go on (no width set, no information from the plugin, nothing).
    1:   // Make up a number.
    1:   if (aMetrics.width == NS_UNCONSTRAINEDSIZE) {
    1:     aMetrics.width =
    1:       (aReflowState.mComputedMinWidth != NS_UNCONSTRAINEDSIZE) ?
    1:         aReflowState.mComputedMinWidth : 0;
    1:   }
    1: 
    1:   // At this point, the height has an unconstrained value only in two cases:
    1:   // a) We are in standards mode with percent heights and parent is auto-height
    1:   // b) We have no height information at all.
    1:   // In either case, we have to make up a number.
    1:   if (aMetrics.height == NS_UNCONSTRAINEDSIZE) {
    1:     aMetrics.height =
    1:       (aReflowState.mComputedMinHeight != NS_UNCONSTRAINEDSIZE) ?
    1:         aReflowState.mComputedMinHeight : 0;
    1:   }
    1: 
    1:   // XXXbz don't add in the border and padding, because we screw up our
    1:   // plugin's size and positioning if we do...  Eventually we _do_ want to
    1:   // paint borders, though!  At that point, we will need to adjust the desired
    1:   // size either here or in Reflow....  Further, we will need to fix Paint() to
    1:   // call the superclass in all cases.
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectFrame::Reflow(nsPresContext*           aPresContext,
    1:                       nsHTMLReflowMetrics&     aMetrics,
    1:                       const nsHTMLReflowState& aReflowState,
    1:                       nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsObjectFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
    1: 
    1:   // Get our desired size
    1:   GetDesiredSize(aPresContext, aReflowState, aMetrics);
55039:   aMetrics.SetOverflowAreasToDesiredBounds();
24440:   FinishAndStoreOverflow(&aMetrics);
    1: 
    1:   // delay plugin instantiation until all children have
    1:   // arrived. Otherwise there may be PARAMs or other stuff that the
    1:   // plugin needs to see that haven't arrived yet.
    1:   if (!GetContent()->IsDoneAddingChildren()) {
    1:     aStatus = NS_FRAME_COMPLETE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // if we are printing or print previewing, bail for now
    1:   if (aPresContext->Medium() == nsGkAtoms::print) {
    1:     aStatus = NS_FRAME_COMPLETE;
    1:     return NS_OK;
    1:   }
    1: 
33369:   nsRect r(0, 0, aMetrics.width, aMetrics.height);
33369:   r.Deflate(aReflowState.mComputedBorderPadding);
33369: 
33369:   if (mInnerView) {
33369:     nsIViewManager* vm = mInnerView->GetViewManager();
33369:     vm->MoveViewTo(mInnerView, r.x, r.y);
33369:     vm->ResizeView(mInnerView, nsRect(nsPoint(0, 0), r.Size()), PR_TRUE);
33369:   }
33369: 
33369:   FixupWindow(r.Size());
52186:   if (!mReflowCallbackPosted) {
52186:     mReflowCallbackPosted = PR_TRUE;
52186:     aPresContext->PresShell()->PostReflowCallback(this);
52186:   }
    1: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1: 
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
    1:   return NS_OK;
    1: }
    1: 
52186: ///////////// nsIReflowCallback ///////////////
52186: 
52186: PRBool
52186: nsObjectFrame::ReflowFinished()
52186: {
52186:   mReflowCallbackPosted = PR_FALSE;
52186:   CallSetWindow();
52186:   return PR_TRUE;
52186: }
52186: 
52186: void
52186: nsObjectFrame::ReflowCallbackCanceled()
52186: {
52186:   mReflowCallbackPosted = PR_FALSE;
52186: }
52186: 
77476: nsresult
77476: nsObjectFrame::InstantiatePlugin(nsPluginHost* aPluginHost, 
77476:                                  const char* aMimeType,
77476:                                  nsIURI* aURI)
77476: {
77476:   NS_ASSERTION(mPreventInstantiation,
77476:                "Instantiation should be prevented here!");
77476: 
77476:   // If you add early return(s), be sure to balance this call to
77476:   // appShell->SuspendNative() with additional call(s) to
77476:   // appShell->ReturnNative().
77476:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
77476:   if (appShell) {
77476:     appShell->SuspendNative();
77476:   }
77476: 
77476:   NS_ASSERTION(mContent, "We should have a content node.");
77476: 
77476:   nsIDocument* doc = mContent->GetOwnerDoc();
77476:   nsCOMPtr<nsIPluginDocument> pDoc (do_QueryInterface(doc));
77476:   PRBool fullPageMode = PR_FALSE;
77476:   if (pDoc) {
77476:     pDoc->GetWillHandleInstantiation(&fullPageMode);
77476:   }
77476: 
77476:   nsresult rv;
77476:   if (fullPageMode) {  /* full-page mode */
77476:     nsCOMPtr<nsIStreamListener> stream;
77476:     rv = aPluginHost->InstantiateFullPagePlugin(aMimeType, aURI, mInstanceOwner, getter_AddRefs(stream));
77476:     if (NS_SUCCEEDED(rv))
77476:       pDoc->SetStreamListener(stream);
77476:   } else {   /* embedded mode */
77476:     rv = aPluginHost->InstantiateEmbeddedPlugin(aMimeType, aURI, mInstanceOwner);
77476:   }
77476: 
77476:   // Note that |this| may very well be destroyed already!
77476: 
77476:   if (appShell) {
77476:     appShell->ResumeNative();
77476:   }
77476: 
77476:   return rv;
77476: }
77476: 
    1: void
    1: nsObjectFrame::FixupWindow(const nsSize& aSize)
    1: {
  238:   nsPresContext* presContext = PresContext();
    1: 
    1:   if (!mInstanceOwner)
    1:     return;
    1: 
32799:   NPWindow *window;
    1:   mInstanceOwner->GetWindow(window);
    1: 
    1:   NS_ENSURE_TRUE(window, /**/);
    1: 
 4329: #ifdef XP_MACOSX
79147:   nsWeakFrame weakFrame(this);
71095:   mInstanceOwner->FixUpPluginWindow(nsPluginInstanceOwner::ePluginPaintDisable);
79147:   if (!weakFrame.IsAlive()) {
79147:     return;
79147:   }
 4329: #endif
 4329: 
32799:   PRBool windowless = (window->type == NPWindowTypeDrawable);
 4329: 
23738:   nsIntPoint origin = GetWindowOriginInPixels(windowless);
 4329: 
 4329:   window->x = origin.x;
 4329:   window->y = origin.y;
 4329: 
    1:   window->width = presContext->AppUnitsToDevPixels(aSize.width);
    1:   window->height = presContext->AppUnitsToDevPixels(aSize.height);
    1: 
    1:   // on the Mac we need to set the clipRect to { 0, 0, 0, 0 } for now. This will keep
    1:   // us from drawing on screen until the widget is properly positioned, which will not
    1:   // happen until we have finished the reflow process.
57224: #ifdef XP_MACOSX
    1:   window->clipRect.top = 0;
    1:   window->clipRect.left = 0;
    1:   window->clipRect.bottom = 0;
    1:   window->clipRect.right = 0;
    1: #else
57514:   mInstanceOwner->UpdateWindowPositionAndClipRect(PR_FALSE);
56619: #endif
57224: 
37372:   NotifyPluginReflowObservers();
    1: }
    1: 
58796: nsresult
59526: nsObjectFrame::CallSetWindow(PRBool aCheckIsHidden)
    1: {
32799:   NPWindow *win = nsnull;
    1:  
58796:   nsresult rv = NS_ERROR_FAILURE;
70007:   nsRefPtr<nsNPAPIPluginInstance> pi;
    1:   if (!mInstanceOwner ||
70007:       NS_FAILED(rv = mInstanceOwner->GetInstance(getter_AddRefs(pi))) ||
    1:       !pi ||
    1:       NS_FAILED(rv = mInstanceOwner->GetWindow(win)) || 
    1:       !win)
58796:     return rv;
    1: 
    1:   nsPluginNativeWindow *window = (nsPluginNativeWindow *)win;
    1: #ifdef XP_MACOSX
79147:   nsWeakFrame weakFrame(this);
71095:   mInstanceOwner->FixUpPluginWindow(nsPluginInstanceOwner::ePluginPaintDisable);
79147:   if (!weakFrame.IsAlive()) {
79147:     return NS_ERROR_NOT_AVAILABLE;
79147:   }
    1: #endif
    1: 
59526:   if (aCheckIsHidden && IsHidden())
58796:     return NS_ERROR_FAILURE;
    1: 
    1:   // refresh the plugin port as well
37446:   window->window = mInstanceOwner->GetPluginPortFromWidget();
    1: 
52187:   // Adjust plugin dimensions according to pixel snap results
52187:   // and reduce amount of SetWindow calls
52187:   nsPresContext* presContext = PresContext();
52187:   nsRootPresContext* rootPC = presContext->GetRootPresContext();
52187:   if (!rootPC)
58796:     return NS_ERROR_FAILURE;
52187:   PRInt32 appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
52187:   nsIFrame* rootFrame = rootPC->PresShell()->FrameManager()->GetRootFrame();
68635:   nsRect bounds = GetContentRectRelativeToSelf() + GetOffsetToCrossDoc(rootFrame);
52187:   nsIntRect intBounds = bounds.ToNearestPixels(appUnitsPerDevPixel);
52187:   window->x = intBounds.x;
52187:   window->y = intBounds.y;
52187:   window->width = intBounds.width;
52187:   window->height = intBounds.height;
52187: 
    1:   // this will call pi->SetWindow and take care of window subclassing
 4164:   // if needed, see bug 132759.
62474:   if (mInstanceOwner->UseAsyncRendering()) {
58796:     rv = pi->AsyncSetWindow(window);
54223:   }
54223:   else {
58796:     rv = window->CallSetWindow(pi);
54223:   }
    1: 
32799:   mInstanceOwner->ReleasePluginPort(window->window);
58796:   return rv;
 4825: }
 4825: 
 4825: PRBool
 4825: nsObjectFrame::IsFocusable(PRInt32 *aTabIndex, PRBool aWithMouse)
 4825: {
 4825:   if (aTabIndex)
 4825:     *aTabIndex = -1;
 4825:   return nsObjectFrameSuper::IsFocusable(aTabIndex, aWithMouse);
 4825: }
 4825: 
 4825: PRBool
 4825: nsObjectFrame::IsHidden(PRBool aCheckVisibilityStyle) const
 4825: {
 4825:   if (aCheckVisibilityStyle) {
 4825:     if (!GetStyleVisibility()->IsVisibleOrCollapsed())
 4825:       return PR_TRUE;    
 4825:   }
 4825: 
 4825:   // only <embed> tags support the HIDDEN attribute
 4825:   if (mContent->Tag() == nsGkAtoms::embed) {
 4825:     // Yes, these are really the kooky ways that you could tell 4.x
 4825:     // not to hide the <embed> once you'd put the 'hidden' attribute
 4825:     // on the tag...
 4825: 
 4825:     // HIDDEN w/ no attributes gets translated as we are hidden for
 4825:     // compatibility w/ 4.x and IE so we don't create a non-painting
 4825:     // widget in layout. See bug 188959.
 4825:     nsAutoString hidden;
 4825:     if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::hidden, hidden) &&
 4825:        (hidden.IsEmpty() ||
19264:         (!hidden.LowerCaseEqualsLiteral("false") &&
 4825:          !hidden.LowerCaseEqualsLiteral("no") &&
19264:          !hidden.LowerCaseEqualsLiteral("off")))) {
 4825:       return PR_TRUE;
 4825:     }
 4825:   }
 4825: 
 4825:   return PR_FALSE;
 4825: }
 4825: 
23738: nsIntPoint nsObjectFrame::GetWindowOriginInPixels(PRBool aWindowless)
 4825: {
 4825:   nsIView * parentWithView;
 4825:   nsPoint origin(0,0);
 4825: 
 4825:   GetOffsetFromView(origin, &parentWithView);
 4825: 
 4825:   // if it's windowless, let's make sure we have our origin set right
 4825:   // it may need to be corrected, like after scrolling
 4825:   if (aWindowless && parentWithView) {
30878:     nsPoint offsetToWidget;
30878:     parentWithView->GetNearestWidget(&offsetToWidget);
30878:     origin += offsetToWidget;
 4825:   }
68635:   origin += GetContentRectRelativeToSelf().TopLeft();
 4825: 
23738:   return nsIntPoint(PresContext()->AppUnitsToDevPixels(origin.x),
23738:                     PresContext()->AppUnitsToDevPixels(origin.y));
 4825: }
 4825: 
 4825: NS_IMETHODIMP
 4825: nsObjectFrame::DidReflow(nsPresContext*            aPresContext,
 4825:                          const nsHTMLReflowState*  aReflowState,
 4825:                          nsDidReflowStatus         aStatus)
 4825: {
 4825:   // Do this check before calling the superclass, as that clears
 4825:   // NS_FRAME_FIRST_REFLOW
 4825:   if (aStatus == NS_FRAME_REFLOW_FINISHED &&
 4825:       (GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
 4825:     nsCOMPtr<nsIObjectLoadingContent> objContent(do_QueryInterface(mContent));
 4825:     NS_ASSERTION(objContent, "Why not an object loading content?");
 4825:     objContent->HasNewFrame(this);
 4825:   }
 4825: 
 4825:   nsresult rv = nsObjectFrameSuper::DidReflow(aPresContext, aReflowState, aStatus);
 4825: 
 4825:   // The view is created hidden; once we have reflowed it and it has been
 4825:   // positioned then we show it.
 4825:   if (aStatus != NS_FRAME_REFLOW_FINISHED) 
 4825:     return rv;
 4825: 
 4825:   if (HasView()) {
 4825:     nsIView* view = GetView();
 4825:     nsIViewManager* vm = view->GetViewManager();
 4825:     if (vm)
 4825:       vm->SetViewVisibility(view, IsHidden() ? nsViewVisibility_kHide : nsViewVisibility_kShow);
 4825:   }
 4825: 
    1:   return rv;
    1: }
    1: 
15688: /* static */ void
68481: nsObjectFrame::PaintPrintPlugin(nsIFrame* aFrame, nsRenderingContext* aCtx,
    1:                                 const nsRect& aDirtyRect, nsPoint aPt)
    1: {
68635:   nsPoint pt = aPt + aFrame->GetContentRectRelativeToSelf().TopLeft();
68481:   nsRenderingContext::AutoPushTranslation translate(aCtx, pt);
15688:   // FIXME - Bug 385435: Doesn't aDirtyRect need translating too?
 3233:   static_cast<nsObjectFrame*>(aFrame)->PrintPlugin(*aCtx, aDirtyRect);
    1: }
    1: 
62699: class nsDisplayPluginReadback : public nsDisplayItem {
62699: public:
62699:   nsDisplayPluginReadback(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
62699:     : nsDisplayItem(aBuilder, aFrame)
62699:   {
62699:     MOZ_COUNT_CTOR(nsDisplayPluginReadback);
62699:   }
62699: #ifdef NS_BUILD_REFCNT_LOGGING
62699:   virtual ~nsDisplayPluginReadback() {
62699:     MOZ_COUNT_DTOR(nsDisplayPluginReadback);
62699:   }
62699: #endif
62699: 
62699:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
62699:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
62699:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
62699: 
62699:   NS_DISPLAY_DECL_NAME("PluginReadback", TYPE_PLUGIN_READBACK)
62699: 
62699:   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
72230:                                              LayerManager* aManager,
72230:                                              const ContainerParameters& aContainerParameters)
62699:   {
62699:     return static_cast<nsObjectFrame*>(mFrame)->BuildLayer(aBuilder, aManager, this);
62699:   }
62699: 
62699:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
62699:                                    LayerManager* aManager)
62699:   {
62699:     return LAYER_ACTIVE;
62699:   }
62699: };
62699: 
62699: static nsRect
62982: GetDisplayItemBounds(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem, nsIFrame* aFrame)
62982: {
62982:   // XXX For slightly more accurate region computations we should pixel-snap this
68635:   return aFrame->GetContentRectRelativeToSelf() + aItem->ToReferenceFrame();
30522: }
30522: 
62699: nsRect
62699: nsDisplayPluginReadback::GetBounds(nsDisplayListBuilder* aBuilder)
62699: {
62982:   return GetDisplayItemBounds(aBuilder, this, mFrame);
62699: }
62699: 
62699: PRBool
62699: nsDisplayPluginReadback::ComputeVisibility(nsDisplayListBuilder* aBuilder,
62699:                                            nsRegion* aVisibleRegion,
69802:                                            const nsRect& aAllowVisibleRegionExpansion)
62699: {
62700:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
69802:                                         aAllowVisibleRegionExpansion))
62699:     return PR_FALSE;
62700: 
62700:   nsRect expand;
62700:   expand.IntersectRect(aAllowVisibleRegionExpansion, GetBounds(aBuilder));
62699:   // *Add* our bounds to the visible region so that stuff underneath us is
62699:   // likely to be made visible, so we can use it for a background! This is
62699:   // a bit crazy since we normally only subtract from the visible region.
62700:   aVisibleRegion->Or(*aVisibleRegion, expand);
62699:   return PR_TRUE;
62699: }
62699: 
62699: nsRect
62699: nsDisplayPlugin::GetBounds(nsDisplayListBuilder* aBuilder)
62699: {
62982:   return GetDisplayItemBounds(aBuilder, this, mFrame);
62699: }
62699: 
30522: void
30522: nsDisplayPlugin::Paint(nsDisplayListBuilder* aBuilder,
68481:                        nsRenderingContext* aCtx)
30522: {
30522:   nsObjectFrame* f = static_cast<nsObjectFrame*>(mFrame);
56434:   f->PaintPlugin(aBuilder, *aCtx, mVisibleRect, GetBounds(aBuilder));
30522: }
30522: 
30522: PRBool
33368: nsDisplayPlugin::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion)
50393: {
30522:   mVisibleRegion.And(*aVisibleRegion, GetBounds(aBuilder));  
61411:   return nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
69802:                                           aAllowVisibleRegionExpansion);
30522: }
30522: 
59779: nsRegion
59779: nsDisplayPlugin::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
56101:                                  PRBool* aForceTransparentSurface)
56101: {
56101:   if (aForceTransparentSurface) {
56101:     *aForceTransparentSurface = PR_FALSE;
56101:   }
59779:   nsRegion result;
30522:   nsObjectFrame* f = static_cast<nsObjectFrame*>(mFrame);
57094:   if (!aBuilder->IsForPluginGeometry()) {
57094:     nsIWidget* widget = f->GetWidget();
57094:     if (widget) {
57094:       nsTArray<nsIntRect> clip;
57094:       widget->GetWindowClipRegion(&clip);
57094:       nsTArray<nsIWidget::Configuration> configuration;
57094:       GetWidgetConfiguration(aBuilder, &configuration);
57094:       NS_ASSERTION(configuration.Length() == 1, "No configuration found");
57094:       if (clip != configuration[0].mClipRegion) {
57094:         // Something has clipped us unexpectedly. Perhaps there is a translucent
57094:         // chrome element overlaying us that forced us to be clipped away. Treat
57094:         // us as non-opaque since we may have holes.
59779:     	return result;
59779:       }
59779:     }
59779:   }
62982:   if (f->IsOpaque() &&
62982:       (aBuilder->IsForPluginGeometry() ||
62982:        (f->GetPaintedRect(this) + ToReferenceFrame()).Contains(GetBounds(aBuilder)))) {
62982:     // We can treat this as opaque
59779:     result = GetBounds(aBuilder);
59779:   }
59779:   return result;
30522: }
30522: 
30522: void
30522: nsDisplayPlugin::GetWidgetConfiguration(nsDisplayListBuilder* aBuilder,
30522:                                         nsTArray<nsIWidget::Configuration>* aConfigurations)
30522: {
30522:   nsObjectFrame* f = static_cast<nsObjectFrame*>(mFrame);
68635:   nsPoint pluginOrigin = mFrame->GetContentRectRelativeToSelf().TopLeft() +
51261:     ToReferenceFrame();
33369:   f->ComputeWidgetGeometry(mVisibleRegion, pluginOrigin, aConfigurations);
30522: }
30522: 
30522: void
30522: nsObjectFrame::ComputeWidgetGeometry(const nsRegion& aRegion,
30522:                                      const nsPoint& aPluginOrigin,
30522:                                      nsTArray<nsIWidget::Configuration>* aConfigurations)
30522: {
57224:   if (!mWidget) {
57224: #ifndef XP_MACOSX
57224:     if (mInstanceOwner) {
57514:       // UpdateWindowVisibility will notify the plugin of position changes
57514:       // by updating the NPWindow and calling NPP_SetWindow/AsyncSetWindow.
57224:       mInstanceOwner->UpdateWindowVisibility(!aRegion.IsEmpty());
57224:     }
57224: #endif
30522:     return;
57224:   }
30522: 
37502:   nsPresContext* presContext = PresContext();
37502:   nsRootPresContext* rootPC = presContext->GetRootPresContext();
37502:   if (!rootPC)
37502:     return;
37502: 
37502:   nsIWidget::Configuration* configuration = aConfigurations->AppendElement();
30522:   if (!configuration)
30522:     return;
30522:   configuration->mChild = mWidget;
30522: 
30522:   PRInt32 appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
37502:   nsIFrame* rootFrame = rootPC->PresShell()->FrameManager()->GetRootFrame();
68635:   nsRect bounds = GetContentRectRelativeToSelf() + GetOffsetToCrossDoc(rootFrame);
30522:   configuration->mBounds = bounds.ToNearestPixels(appUnitsPerDevPixel);
30522: 
39430:   // This should produce basically the same rectangle (but not relative
39430:   // to the root frame). We only call this here for the side-effect of
39430:   // setting mViewToWidgetOffset on the view.
39430:   mInnerView->CalcWidgetBounds(eWindowType_plugin);
39430: 
30522:   nsRegionRectIterator iter(aRegion);
30522:   nsIntPoint pluginOrigin = aPluginOrigin.ToNearestPixels(appUnitsPerDevPixel);
30522:   for (const nsRect* r = iter.Next(); r; r = iter.Next()) {
30522:     // Snap *r to pixels while it's relative to the painted widget, to
30522:     // improve consistency with rectangle and image drawing
30522:     nsIntRect pixRect =
30522:       r->ToNearestPixels(appUnitsPerDevPixel) - pluginOrigin;
30522:     if (!pixRect.IsEmpty()) {
30522:       configuration->mClipRegion.AppendElement(pixRect);
30522:     }
30522:   }
30522: }
30522: 
35171: nsresult
37372: nsObjectFrame::PluginEventNotifier::Run() {
41540:   nsCOMPtr<nsIObserverService> obsSvc =
41540:     mozilla::services::GetObserverService();
37372:   obsSvc->NotifyObservers(nsnull, "plugin-changed-event", mEventType.get());
37372:   return NS_OK;
37372: }
37372: 
30524: void
37372: nsObjectFrame::NotifyPluginReflowObservers()
37372: {
37372:   nsContentUtils::AddScriptRunner(new PluginEventNotifier(NS_LITERAL_STRING("reflow")));
35180: }
35180: 
35180: void
30524: nsObjectFrame::DidSetWidgetGeometry()
30524: {
30524: #if defined(XP_MACOSX)
30524:   if (mInstanceOwner) {
71095:     mInstanceOwner->FixUpPluginWindow(nsPluginInstanceOwner::ePluginPaintEnable);
30524:   }
30524: #endif
30524: }
30524: 
30522: PRBool
30522: nsObjectFrame::IsOpaque() const
30522: {
30522: #if defined(XP_MACOSX)
62699:   // ???
62699:   return PR_FALSE;
62699: #else
62699:   return !IsTransparentMode();
62699: #endif
62699: }
62699: 
62699: PRBool
62699: nsObjectFrame::IsTransparentMode() const
62699: {
62699: #if defined(XP_MACOSX)
62699:   // ???
30522:   return PR_FALSE;
30522: #else
36333:   if (!mInstanceOwner)
36333:     return PR_FALSE;
36333: 
32799:   NPWindow *window;
30522:   mInstanceOwner->GetWindow(window);
36333:   if (window->type != NPWindowTypeDrawable)
62699:     return PR_FALSE;
36333: 
34441:   nsresult rv;
70007:   nsRefPtr<nsNPAPIPluginInstance> pi;
70007:   rv = mInstanceOwner->GetInstance(getter_AddRefs(pi));
36333:   if (NS_FAILED(rv) || !pi)
36333:     return PR_FALSE;
36333: 
34441:   PRBool transparent = PR_FALSE;
34441:   pi->IsTransparent(&transparent);
62699:   return transparent;
30522: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                 const nsRect&           aDirtyRect,
    1:                                 const nsDisplayListSet& aLists)
    1: {
    1:   // XXX why are we painting collapsed object frames?
    1:   if (!IsVisibleOrCollapsedForPainting(aBuilder))
    1:     return NS_OK;
    1: 
    1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
  238:   nsPresContext::nsPresContextType type = PresContext()->Type();
    1: 
    1:   // If we are painting in Print Preview do nothing....
    1:   if (type == nsPresContext::eContext_PrintPreview)
    1:     return NS_OK;
    1: 
    1:   DO_GLOBAL_REFLOW_COUNT_DSP("nsObjectFrame");
    1: 
30541: #ifndef XP_MACOSX
30541:   if (mWidget && aBuilder->IsInTransform()) {
30541:     // Windowed plugins should not be rendered inside a transform.
30541:     return NS_OK;
30541:   }
30541: #endif
30541: 
52294:   nsDisplayList replacedContent;
52294: 
62474:   if (aBuilder->IsForPainting() && mInstanceOwner && mInstanceOwner->UseAsyncRendering()) {
59491:     NPWindow* window = nsnull;
59491:     mInstanceOwner->GetWindow(window);
59491:     PRBool isVisible = window && window->width > 0 && window->height > 0;
60439:     if (isVisible && aBuilder->ShouldSyncDecodeImages()) {
59491:   #ifndef XP_MACOSX
59491:       mInstanceOwner->UpdateWindowVisibility(PR_TRUE);
59491:   #endif
59491:     }
59491: 
63255:     nsRefPtr<ImageContainer> container = GetImageContainer();
59491:     nsRefPtr<Image> currentImage = container ? container->GetCurrentImage() : nsnull;
59491:     if (!currentImage || !isVisible ||
59491:         container->GetCurrentSize() != gfxIntSize(window->width, window->height)) {
59491:       mInstanceOwner->NotifyPaintWaiter(aBuilder);
59491:     }
59491:   }
59491: 
    1:   // determine if we are printing
52294:   if (type == nsPresContext::eContext_Print) {
52294:     rv = replacedContent.AppendNewToTop(new (aBuilder)
51260:         nsDisplayGeneric(aBuilder, this, PaintPrintPlugin, "PrintPlugin",
47732:                          nsDisplayItem::TYPE_PRINT_PLUGIN));
52294:   } else {
62699:     if (aBuilder->IsPaintingToWindow() &&
62699:         GetLayerState(aBuilder, nsnull) == LAYER_ACTIVE &&
62699:         IsTransparentMode()) {
62699:       rv = replacedContent.AppendNewToTop(new (aBuilder)
62699:           nsDisplayPluginReadback(aBuilder, this));
62699:       NS_ENSURE_SUCCESS(rv, rv);
62699:     }
62699: 
52294:     rv = replacedContent.AppendNewToTop(new (aBuilder)
51260:         nsDisplayPlugin(aBuilder, this));
    1:   }
52294:   NS_ENSURE_SUCCESS(rv, rv);
52294: 
52294:   WrapReplacedContentForBorderRadius(aBuilder, &replacedContent, aLists);
52294: 
52294:   return NS_OK;
52294: }
    1: 
68482: #ifdef XP_OS2
68482: static void *
68865: GetPSFromRC(nsRenderingContext& aRenderingContext)
68482: {
68482:   nsRefPtr<gfxASurface>
68482:     surf = aRenderingContext.ThebesContext()->CurrentSurface();
68482:   if (!surf || surf->CairoStatus())
68482:     return nsnull;
68482:   return (void *)(static_cast<gfxOS2Surface*>
68482:                   (static_cast<gfxASurface*>(surf.get()))->GetPS());
68482: }
68482: #endif
68482: 
    1: void
68481: nsObjectFrame::PrintPlugin(nsRenderingContext& aRenderingContext,
    1:                            const nsRect& aDirtyRect)
    1: {
35581:   nsCOMPtr<nsIObjectLoadingContent> obj(do_QueryInterface(mContent));
35581:   if (!obj)
    1:     return;
    1: 
35581:   nsIFrame* frame = nsnull;
35581:   obj->GetPrintFrame(&frame);
    1:   if (!frame)
    1:     return;
    1: 
  238:   nsPresContext* presContext = PresContext();
    1:   // make sure this is REALLY an nsIObjectFrame
    1:   // we may need to go through the children to get it
23554:   nsIObjectFrame* objectFrame = do_QueryFrame(frame);
    1:   if (!objectFrame)
    1:     objectFrame = GetNextObjectFrame(presContext,frame);
    1:   if (!objectFrame)
    1:     return;
    1: 
    1:   // finally we can get our plugin instance
70007:   nsRefPtr<nsNPAPIPluginInstance> pi;
70007:   if (NS_FAILED(objectFrame->GetPluginInstance(getter_AddRefs(pi))) || !pi)
    1:     return;
    1: 
    1:   // now we need to setup the correct location for printing
32799:   NPWindow window;
    1:   window.window = nsnull;
    1: 
    1:   // prepare embedded mode printing struct
32799:   NPPrint npprint;
32799:   npprint.mode = NP_EMBED;
    1: 
    1:   // we need to find out if we are windowless or not
    1:   PRBool windowless = PR_FALSE;
32799:   pi->IsWindowless(&windowless);
32799:   window.type = windowless ? NPWindowTypeDrawable : NPWindowTypeWindow;
    1: 
    1:   window.clipRect.bottom = 0; window.clipRect.top = 0;
    1:   window.clipRect.left = 0; window.clipRect.right = 0;
    1:   
30472: // platform specific printing code
36227: #ifdef MAC_CARBON_PLUGINS
71609:   // Don't use this code if any of the QuickDraw APIs it currently requires
71609:   // are missing (as they probably will be on OS X 10.8 and up).
71609:   if (!::SetRect || !::NewGWorldFromPtr || !::DisposeGWorld) {
71609:     NS_WARNING("Cannot print plugin -- required QuickDraw APIs are missing!");
71609:     return;
71609:   }
71609: 
68635:   nsSize contentSize = GetContentRectRelativeToSelf().Size();
30472:   window.x = 0;
30472:   window.y = 0;
33371:   window.width = presContext->AppUnitsToDevPixels(contentSize.width);
33371:   window.height = presContext->AppUnitsToDevPixels(contentSize.height);
30472: 
30472:   gfxContext *ctx = aRenderingContext.ThebesContext();
30472:   if (!ctx)
30472:     return;
30472:   gfxContextAutoSaveRestore save(ctx);
30472: 
30472:   ctx->NewPath();
30472: 
30472:   gfxRect rect(window.x, window.y, window.width, window.height);
30472: 
30472:   ctx->Rectangle(rect);
30472:   ctx->Clip();
30472: 
30472:   gfxQuartzNativeDrawing nativeDraw(ctx, rect);
30472:   CGContextRef cgContext = nativeDraw.BeginNativeDrawing();
30472:   if (!cgContext) {
30472:     nativeDraw.EndNativeDrawing();
30472:     return;
30472:   }
30472: 
30472:   window.clipRect.right = window.width;
30472:   window.clipRect.bottom = window.height;
32799:   window.type = NPWindowTypeDrawable;
30472: 
68640:   ::Rect gwBounds;
30472:   ::SetRect(&gwBounds, 0, 0, window.width, window.height);
30472: 
30472:   nsTArray<char> buffer(window.width * window.height * 4);
30472:   CGColorSpaceRef cspace = ::CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
30472:   if (!cspace) {
30472:     nativeDraw.EndNativeDrawing();
30472:     return;
30472:   }
30472:   CGContextRef cgBuffer =
30472:     ::CGBitmapContextCreate(buffer.Elements(), 
30472:                             window.width, window.height, 8, window.width * 4,
30472:                             cspace, kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedFirst);
30472:   ::CGColorSpaceRelease(cspace);
30472:   if (!cgBuffer) {
30472:     nativeDraw.EndNativeDrawing();
30472:     return;
30472:   }
30472:   GWorldPtr gWorld;
30472:   if (::NewGWorldFromPtr(&gWorld, k32ARGBPixelFormat, &gwBounds, NULL, NULL, 0,
30472:                          buffer.Elements(), window.width * 4) != noErr) {
30472:     ::CGContextRelease(cgBuffer);
30472:     nativeDraw.EndNativeDrawing();
30472:     return;
30472:   }
30472: 
30472:   window.clipRect.right = window.width;
30472:   window.clipRect.bottom = window.height;
32799:   window.type = NPWindowTypeDrawable;
30472:   // Setting nsPluginPrint/NPPrint.print.embedPrint.window.window to
30472:   // &GWorldPtr and nsPluginPrint/NPPrint.print.embedPrint.platformPrint to
30472:   // GWorldPtr isn't any kind of standard (it's not documented anywhere).
30472:   // But that's what WebKit does.  And it's what the Flash plugin (apparently
30472:   // the only NPAPI plugin on OS X to support printing) seems to expect.  So
30472:   // we do the same.  The Flash plugin uses the CoreGraphics drawing mode.
30472:   // But a GWorldPtr should be usable in either CoreGraphics or QuickDraw
30472:   // drawing mode.  See bug 191046.
32799:   window.window = &gWorld;
30472:   npprint.print.embedPrint.platformPrint = gWorld;
30472:   npprint.print.embedPrint.window = window;
72149:   pi->Print(&npprint);
30472: 
30472:   ::CGContextTranslateCTM(cgContext, 0.0f, float(window.height));
30472:   ::CGContextScaleCTM(cgContext, 1.0f, -1.0f);
30472:   CGImageRef image = ::CGBitmapContextCreateImage(cgBuffer);
30472:   if (!image) {
30472:     ::CGContextRestoreGState(cgContext);
30472:     ::CGContextRelease(cgBuffer);
30472:     ::DisposeGWorld(gWorld);
30472:     nativeDraw.EndNativeDrawing();
30472:     return;
30472:   }
30472:   ::CGContextDrawImage(cgContext,
30472:                        ::CGRectMake(0, 0, window.width, window.height),
30472:                        image);
30472:   ::CGImageRelease(image);
30472:   ::CGContextRelease(cgBuffer);
30472: 
30472:   ::DisposeGWorld(gWorld);
30472: 
30472:   nativeDraw.EndNativeDrawing();
30472: #elif defined(XP_UNIX)
12653: 
12653:   /* XXX this just flat-out doesn't work in a thebes world --
12653:    * RenderEPS is a no-op.  So don't bother to do any work here.
12653:    */
    1: 
12859: #elif defined(XP_OS2)
68482:   void *hps = GetPSFromRC(aRenderingContext);
12859:   if (!hps)
12859:     return;
12859: 
12859:   npprint.print.embedPrint.platformPrint = hps;
12859:   npprint.print.embedPrint.window = window;
12859:   // send off print info to plugin
19448:   pi->Print(&npprint);
11703: #elif defined(XP_WIN)
11703: 
11703:   /* On Windows, we use the win32 printing surface to print.  This, in
11703:    * turn, uses the Cairo paginated surface, which in turn uses the
11703:    * meta surface to record all operations and then play them back.
11703:    * This doesn't work too well for plugins, because if plugins render
11703:    * directly into the DC, the meta surface won't have any knowledge
11703:    * of them, and so at the end when it actually does the replay step,
11703:    * it'll fill the background with white and draw over whatever was
11703:    * rendered before.
11703:    *
11703:    * So, to avoid this, we use PushGroup, which creates a new windows
11703:    * surface, the plugin renders to that, and then we use normal
11703:    * cairo methods to composite that in such that it's recorded using the
11703:    * meta surface.
11703:    */
11703: 
12653:   /* we'll already be translated into the right spot by gfxWindowsNativeDrawing */
68635:   nsSize contentSize = GetContentRectRelativeToSelf().Size();
12653:   window.x = 0;
12653:   window.y = 0;
33371:   window.width = presContext->AppUnitsToDevPixels(contentSize.width);
33371:   window.height = presContext->AppUnitsToDevPixels(contentSize.height);
12653: 
11703:   gfxContext *ctx = aRenderingContext.ThebesContext();
11703: 
11703:   ctx->Save();
11703: 
12653:   /* Make sure plugins don't do any damage outside of where they're supposed to */
11703:   ctx->NewPath();
21080:   gfxRect r(window.x, window.y, window.width, window.height);
21080:   ctx->Rectangle(r);
11703:   ctx->Clip();
12653: 
21080:   gfxWindowsNativeDrawing nativeDraw(ctx, r);
11703:   do {
11703:     HDC dc = nativeDraw.BeginNativeDrawing();
11703:     if (!dc)
11703:       return;
11703: 
21080:     // XXX don't we need to call nativeDraw.TransformToNativeRect here?
11703:     npprint.print.embedPrint.platformPrint = dc;
11703:     npprint.print.embedPrint.window = window;
11703:     // send off print info to plugin
19448:     pi->Print(&npprint);
11703: 
11703:     nativeDraw.EndNativeDrawing();
11703:   } while (nativeDraw.ShouldRenderAgain());
11703:   nativeDraw.PaintToContext();
11703: 
11703:   ctx->Restore();
    1: #endif
    1: 
    1:   // XXX Nav 4.x always sent a SetWindow call after print. Should we do the same?
33371:   // XXX Calling DidReflow here makes no sense!!!
    1:   nsDidReflowStatus status = NS_FRAME_REFLOW_FINISHED; // should we use a special status?
    1:   frame->DidReflow(presContext,
    1:                    nsnull, status);  // DidReflow will take care of it
    1: }
    1: 
63255: already_AddRefed<ImageContainer>
60712: nsObjectFrame::GetImageContainer(LayerManager* aManager)
60712: {
60712:   nsRefPtr<LayerManager> manager = aManager;
63255:   bool retain = false;
60712: 
60712:   if (!manager) {
63255:     manager = nsContentUtils::LayerManagerForDocument(mContent->GetOwnerDoc(), &retain);
60712:   }
58485:   if (!manager) {
54223:     return nsnull;
58485:   }
58485: 
63255:   nsRefPtr<ImageContainer> container;
63255: 
59717:   // XXX - in the future image containers will be manager independent and
59717:   // we can remove the manager equals check and only check the backend type.
62984:   if (mImageContainer) {
62984:     if ((!mImageContainer->Manager() || mImageContainer->Manager() == manager) &&
63255:         mImageContainer->GetBackendType() == manager->GetBackendType()) {
63255:       container = mImageContainer;
63255:       return container.forget();
63255:     }
63255:   }
63255: 
63255:   container = manager->CreateImageContainer();
63255: 
63255:   if (retain) {
62984:     // Clear current image before we reset mImageContainer. Only mImageContainer
62984:     // is allowed to contain the image for this plugin.
63255:     if (mImageContainer) {
62984:       mImageContainer->SetCurrentImage(nsnull);
58485:     }
63255:     mImageContainer = container;
63255:   }
63255: 
63255:   return container.forget();
54223: }
54223: 
62982: nsRect
62982: nsObjectFrame::GetPaintedRect(nsDisplayPlugin* aItem)
62982: {
62982:   if (!mInstanceOwner)
62982:     return nsRect();
68635:   nsRect r = GetContentRectRelativeToSelf();
62982:   if (!mInstanceOwner->UseAsyncRendering())
62982:     return r;
62982: 
62982:   nsIntSize size = mInstanceOwner->GetCurrentImageSize();
62982:   nsPresContext* pc = PresContext();
62982:   r.IntersectRect(r, nsRect(0, 0, pc->DevPixelsToAppUnits(size.width),
62982:                                   pc->DevPixelsToAppUnits(size.height)));
62982:   return r;
62982: }
62982: 
62724: void
62724: nsObjectFrame::UpdateImageLayer(ImageContainer* aContainer, const gfxRect& aRect)
62724: {
63222:   if (!mInstanceOwner) {
63222:     return;
63222:   }
63222: 
62724: #ifdef XP_MACOSX
71284:   if (!mInstanceOwner->UseAsyncRendering()) {
62724:     mInstanceOwner->DoCocoaEventDrawRect(aRect, nsnull);
71284:   }
62724: #endif
62724: 
62724:   mInstanceOwner->SetCurrentImage(aContainer);
62724: }
62724: 
62982: LayerState
62224: nsObjectFrame::GetLayerState(nsDisplayListBuilder* aBuilder,
62224:                              LayerManager* aManager)
62224: {
62474:   if (!mInstanceOwner)
62982:     return LAYER_NONE;
62474: 
62474: #ifdef XP_MACOSX
73761:   // Layer painting not supported without OpenGL
73761:   if (aManager && aManager->GetBackendType() !=
73761:       LayerManager::LAYERS_OPENGL) {
73761:     return LAYER_NONE;
73761:   }
73761: 
73761:   // Synchronous painting, but with (gecko) layers.
73761:   if (!mInstanceOwner->UseAsyncRendering() &&
72866:       mInstanceOwner->IsRemoteDrawingCoreAnimation() &&
72866:       mInstanceOwner->GetEventModel() == NPEventModelCocoa) {
72866:     return LAYER_ACTIVE;
72866:   }
72866: #endif
72866: 
72866:   if (!mInstanceOwner->UseAsyncRendering()) {
72865:     return LAYER_NONE;
62474:   }
62982: 
62982:   return LAYER_ACTIVE;
54223: }
54223: 
54223: already_AddRefed<Layer>
54223: nsObjectFrame::BuildLayer(nsDisplayListBuilder* aBuilder,
54223:                           LayerManager* aManager,
54223:                           nsDisplayItem* aItem)
54223: {
54223:   if (!mInstanceOwner)
54223:     return nsnull;
54223: 
54223:   NPWindow* window = nsnull;
54223:   mInstanceOwner->GetWindow(window);
54223:   if (!window)
54223:     return nsnull;
54223: 
54223:   if (window->width <= 0 || window->height <= 0)
54223:     return nsnull;
54223: 
62699:   // Create image
62699:   nsRefPtr<ImageContainer> container = GetImageContainer(aManager);
62699:   if (!container)
62699:     return nsnull;
62984: 
62984:   {
62984:     nsRefPtr<Image> current = container->GetCurrentImage();
62984:     if (!current) {
62984:       // Only set the current image if there isn't already one. If there is
62984:       // already one, InvalidateRect() will be keeping it up to date.
62984:       if (!mInstanceOwner->SetCurrentImage(container))
62699:         return nsnull;
62699:     }
62699:   }
62984: 
62699:   gfxIntSize size = container->GetCurrentSize();
62699: 
68635:   nsRect area = GetContentRectRelativeToSelf() + aItem->ToReferenceFrame();
54223:   gfxRect r = nsLayoutUtils::RectToGfxRect(area, PresContext()->AppUnitsPerDevPixel());
54223:   // to provide crisper and faster drawing.
54223:   r.Round();
54223:   nsRefPtr<Layer> layer =
54223:     (aBuilder->LayerBuilder()->GetLeafLayerFor(aBuilder, aManager, aItem));
54223: 
62699:   if (aItem->GetType() == nsDisplayItem::TYPE_PLUGIN) {
54223:     if (!layer) {
58634:       mInstanceOwner->NotifyPaintWaiter(aBuilder);
54223:       // Initialize ImageLayer
54223:       layer = aManager->CreateImageLayer();
54223:       if (!layer)
54223:         return nsnull;
62699:     }
62224: 
62699:     NS_ASSERTION(layer->GetType() == Layer::TYPE_IMAGE, "Bad layer type");
54223: 
54223:     ImageLayer* imglayer = static_cast<ImageLayer*>(layer.get());
62724:     UpdateImageLayer(container, r);
62724: 
54223:     imglayer->SetContainer(container);
78441:     gfxPattern::GraphicsFilter filter =
78441:       nsLayoutUtils::GetGraphicsFilterForFrame(this);
78441: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
78441:     if (!aManager->IsCompositingCheap()) {
78441:       // Pixman just horrible with bilinear filter scaling
78441:       filter = gfxPattern::FILTER_NEAREST;
78441:     }
78441: #endif
78441:     imglayer->SetFilter(filter);
54223: 
54223:     layer->SetContentFlags(IsOpaque() ? Layer::CONTENT_OPAQUE : 0);
62699:   } else {
62699:     NS_ASSERTION(aItem->GetType() == nsDisplayItem::TYPE_PLUGIN_READBACK,
62699:                  "Unknown item type");
62699:     NS_ABORT_IF_FALSE(!IsOpaque(), "Opaque plugins don't use backgrounds");
62699: 
62699:     if (!layer) {
62699:       layer = aManager->CreateReadbackLayer();
62699:       if (!layer)
62699:         return nsnull;
62699:     }
62699:     NS_ASSERTION(layer->GetType() == Layer::TYPE_READBACK, "Bad layer type");
62699: 
62699:     ReadbackLayer* readback = static_cast<ReadbackLayer*>(layer.get());
62699:     if (readback->GetSize() != nsIntSize(size.width, size.height)) {
62699:       // This will destroy any old background sink and notify us that the
62699:       // background is now unknown
62699:       readback->SetSink(nsnull);
62699:       readback->SetSize(nsIntSize(size.width, size.height));
62699: 
63204:       if (mBackgroundSink) {
63204:         // Maybe we still have a background sink associated with another
63204:         // readback layer that wasn't recycled for some reason? Unhook it
63204:         // now so that if this frame goes away, it doesn't have a dangling
63204:         // reference to us.
63204:         mBackgroundSink->Destroy();
63204:       }
62699:       mBackgroundSink =
62699:         new PluginBackgroundSink(this,
62699:                                  readback->AllocateSequenceNumber());
62699:       readback->SetSink(mBackgroundSink);
62699:       // The layer has taken ownership of our sink. When either the sink dies
62699:       // or the frame dies, the connection from the surviving object is nulled out.
62699:     }
62699:   }
54223: 
54223:   // Set a transform on the layer to draw the plugin in the right place
54223:   gfxMatrix transform;
68632:   transform.Translate(r.TopLeft());
54223: 
54223:   layer->SetTransform(gfx3DMatrix::From2D(transform));
62985:   layer->SetVisibleRegion(nsIntRect(0, 0, size.width, size.height));
62699:   return layer.forget();
54223: }
54223: 
    1: void
56434: nsObjectFrame::PaintPlugin(nsDisplayListBuilder* aBuilder,
68481:                            nsRenderingContext& aRenderingContext,
33369:                            const nsRect& aDirtyRect, const nsRect& aPluginRect)
    1: {
78424: #if defined(ANDROID)
78424:   if (mInstanceOwner) {
78424:     NPWindow *window;
78424:     mInstanceOwner->GetWindow(window);
78424: 
78424:     gfxRect frameGfxRect =
78424:       PresContext()->AppUnitsToGfxUnits(aPluginRect);
78424:     gfxRect dirtyGfxRect =
78424:       PresContext()->AppUnitsToGfxUnits(aDirtyRect);
78424:     gfxContext* ctx = aRenderingContext.ThebesContext();
78424: 
78424:     mInstanceOwner->Paint(ctx, frameGfxRect, dirtyGfxRect);
78424:     return;
78424:   }
78424: #endif
78424: 
    1:   // Screen painting code
    1: #if defined(XP_MACOSX)
    1:   // delegate all painting to the plugin instance.
11944:   if (mInstanceOwner) {
39757:     if (mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreGraphics ||
43370:         mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreAnimation ||
43370:         mInstanceOwner->GetDrawingModel() == 
43370:                                   NPDrawingModelInvalidatingCoreAnimation) {
29811:       PRInt32 appUnitsPerDevPixel = PresContext()->AppUnitsPerDevPixel();
29811:       // Clip to the content area where the plugin should be drawn. If
29811:       // we don't do this, the plugin can draw outside its bounds.
33369:       nsIntRect contentPixels = aPluginRect.ToNearestPixels(appUnitsPerDevPixel);
29811:       nsIntRect dirtyPixels = aDirtyRect.ToOutsidePixels(appUnitsPerDevPixel);
29811:       nsIntRect clipPixels;
29811:       clipPixels.IntersectRect(contentPixels, dirtyPixels);
43369: 
43369:       // Don't invoke the drawing code if the clip is empty.
43369:       if (clipPixels.IsEmpty())
43369:         return;
43369: 
29811:       gfxRect nativeClipRect(clipPixels.x, clipPixels.y,
29811:                              clipPixels.width, clipPixels.height);
11944:       gfxContext* ctx = aRenderingContext.ThebesContext();
29811: 
29811:       gfxContextAutoSaveRestore save(ctx);
29811:       ctx->NewPath();
29811:       ctx->Rectangle(nativeClipRect);
29811:       ctx->Clip();
29811:       gfxPoint offset(contentPixels.x, contentPixels.y);
29811:       ctx->Translate(offset);
29811: 
29811:       gfxQuartzNativeDrawing nativeDrawing(ctx, nativeClipRect - offset);
11944: 
11944:       CGContextRef cgContext = nativeDrawing.BeginNativeDrawing();
11944:       if (!cgContext) {
11944:         NS_WARNING("null CGContextRef during PaintPlugin");
11944:         return;
11944:       }
11944: 
70007:       nsRefPtr<nsNPAPIPluginInstance> inst;
70007:       GetPluginInstance(getter_AddRefs(inst));
12241:       if (!inst) {
12241:         NS_WARNING("null plugin instance during PaintPlugin");
21108:         nativeDrawing.EndNativeDrawing();
12241:         return;
12241:       }
32799:       NPWindow* window;
12241:       mInstanceOwner->GetWindow(window);
12241:       if (!window) {
12241:         NS_WARNING("null plugin window during PaintPlugin");
21108:         nativeDrawing.EndNativeDrawing();
12241:         return;
12241:       }
32799:       NP_CGContext* cgPluginPortCopy =
32799:                 static_cast<NP_CGContext*>(mInstanceOwner->GetPluginPortCopy());
32799:       if (!cgPluginPortCopy) {
21108:         NS_WARNING("null plugin port copy during PaintPlugin");
21108:         nativeDrawing.EndNativeDrawing();
21108:         return;
21108:       }
37446: #ifndef NP_NO_CARBON
37446:       if (mInstanceOwner->GetEventModel() == NPEventModelCarbon &&
37446:           !mInstanceOwner->SetPluginPortAndDetectChange()) {
21108:         NS_WARNING("null plugin port during PaintPlugin");
21108:         nativeDrawing.EndNativeDrawing();
21108:         return;
21108:       }
34737: 
34717:       // In the Carbon event model...
21108:       // If gfxQuartzNativeDrawing hands out a CGContext different from the
21108:       // one set by SetPluginPortAndDetectChange(), we need to pass it to the
21108:       // plugin via SetWindow().  This will happen in nsPluginInstanceOwner::
21108:       // FixUpPluginWindow(), called from nsPluginInstanceOwner::Paint().
21108:       // (If SetPluginPortAndDetectChange() made any changes itself, this has
21108:       // already been detected in that method, and will likewise result in a
21108:       // call to SetWindow() from FixUpPluginWindow().)
32799:       NP_CGContext* windowContext = static_cast<NP_CGContext*>(window->window);
34717:       if (mInstanceOwner->GetEventModel() == NPEventModelCarbon &&
34717:           windowContext->context != cgContext) {
32799:         windowContext->context = cgContext;
32799:         cgPluginPortCopy->context = cgContext;
21108:         mInstanceOwner->SetPluginPortChanged(PR_TRUE);
21108:       }
34737: #endif
21108: 
21108:       mInstanceOwner->BeginCGPaint();
43370:       if (mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreAnimation ||
43370:           mInstanceOwner->GetDrawingModel() == 
43370:                                    NPDrawingModelInvalidatingCoreAnimation) {
39757:         // CoreAnimation is updated, render the layer and perform a readback.
39757:         mInstanceOwner->RenderCoreAnimation(cgContext, window->width, window->height);
39757:       } else {
34717:         mInstanceOwner->Paint(nativeClipRect - offset, cgContext);
39757:       }
21108:       mInstanceOwner->EndCGPaint();
11944: 
11944:       nativeDrawing.EndNativeDrawing();
11944:     } else {
29811:       // FIXME - Bug 385435: Doesn't aDirtyRect need translating too?
68481:       nsRenderingContext::AutoPushTranslation
68479:         translate(&aRenderingContext, aPluginRect.TopLeft());
29811: 
32019:       // this rect is used only in the CoreGraphics drawing model
32019:       gfxRect tmpRect(0, 0, 0, 0);
34717:       mInstanceOwner->Paint(tmpRect, NULL);
11944:     }
11944:   }
47118: #elif defined(MOZ_X11)
21080:   if (mInstanceOwner) {
32799:     NPWindow *window;
 3059:     mInstanceOwner->GetWindow(window);
32799:     if (window->type == NPWindowTypeDrawable) {
15688:       gfxRect frameGfxRect =
33369:         PresContext()->AppUnitsToGfxUnits(aPluginRect);
15688:       gfxRect dirtyGfxRect =
15688:         PresContext()->AppUnitsToGfxUnits(aDirtyRect);
15688:       gfxContext* ctx = aRenderingContext.ThebesContext();
15688: 
15688:       mInstanceOwner->Paint(ctx, frameGfxRect, dirtyGfxRect);
15688:     }
 3059:   }
21080: #elif defined(XP_WIN)
70007:   nsRefPtr<nsNPAPIPluginInstance> inst;
70007:   GetPluginInstance(getter_AddRefs(inst));
    1:   if (inst) {
21080:     gfxRect frameGfxRect =
33369:       PresContext()->AppUnitsToGfxUnits(aPluginRect);
21080:     gfxRect dirtyGfxRect =
21080:       PresContext()->AppUnitsToGfxUnits(aDirtyRect);
21080:     gfxContext *ctx = aRenderingContext.ThebesContext();
21080:     gfxMatrix currentMatrix = ctx->CurrentMatrix();
21080: 
21080:     if (ctx->UserToDevicePixelSnapped(frameGfxRect, PR_FALSE)) {
21080:       dirtyGfxRect = ctx->UserToDevice(dirtyGfxRect);
21080:       ctx->IdentityMatrix();
21080:     }
21080:     dirtyGfxRect.RoundOut();
21080: 
    1:     // Look if it's windowless
32799:     NPWindow *window;
    1:     mInstanceOwner->GetWindow(window);
    1: 
32799:     if (window->type == NPWindowTypeDrawable) {
    1:       // the offset of the DC
19835:       nsPoint origin;
    1: 
21080:       gfxWindowsNativeDrawing nativeDraw(ctx, frameGfxRect);
36270:       if (nativeDraw.IsDoublePass()) {
36270:         // OOP plugin specific: let the shim know before we paint if we are doing a
36270:         // double pass render. If this plugin isn't oop, the register window message
36270:         // will be ignored.
36270:         NPEvent pluginEvent;
62699:         pluginEvent.event = DoublePassRenderingEvent();
36270:         pluginEvent.wParam = 0;
36270:         pluginEvent.lParam = 0;
50668:         if (pluginEvent.event)
43436:           inst->HandleEvent(&pluginEvent, nsnull);
36270:       }
21080:       do {
21080:         HDC hdc = nativeDraw.BeginNativeDrawing();
21080:         if (!hdc)
    1:           return;
21080: 
21080:         RECT dest;
21080:         nativeDraw.TransformToNativeRect(frameGfxRect, dest);
21080:         RECT dirty;
21080:         nativeDraw.TransformToNativeRect(dirtyGfxRect, dirty);
21080: 
32799:         window->window = hdc;
21080:         window->x = dest.left;
21080:         window->y = dest.top;
57225:         window->clipRect.left = 0;
57225:         window->clipRect.top = 0;
57225:         // if we're painting, we're visible.
57225:         window->clipRect.right = window->width;
57225:         window->clipRect.bottom = window->height;
21080: 
36271:         // Windowless plugins on windows need a special event to update their location,
36271:         // see bug 135737.
36271:         //
    1:         // bug 271442: note, the rectangle we send is now purely the bounds of the plugin
36271:         // relative to the window it is contained in, which is useful for the plugin to
36271:         // correctly translate mouse coordinates.
    1:         //
    1:         // this does not mesh with the comments for bug 135737 which imply that the rectangle
36271:         // must be clipped in some way to prevent the plugin attempting to paint over areas
36271:         // it shouldn't.
    1:         //
36271:         // since the two uses of the rectangle are mutually exclusive in some cases, and
36271:         // since I don't see any incorrect painting (at least with Flash and ViewPoint -
36271:         // the originator of bug 135737), it seems that windowless plugins are not relying
36271:         // on information here for clipping their drawing, and we can safely use this message
36271:         // to tell the plugin exactly where it is in all cases.
    1: 
21080:         nsIntPoint origin = GetWindowOriginInPixels(PR_TRUE);
23738:         nsIntRect winlessRect = nsIntRect(origin, nsIntSize(window->width, window->height));
57232: 
68638:         if (!mWindowlessRect.IsEqualEdges(winlessRect)) {
    1:           mWindowlessRect = winlessRect;
    1: 
    1:           WINDOWPOS winpos;
    1:           memset(&winpos, 0, sizeof(winpos));
    1:           winpos.x = mWindowlessRect.x;
    1:           winpos.y = mWindowlessRect.y;
    1:           winpos.cx = mWindowlessRect.width;
    1:           winpos.cy = mWindowlessRect.height;
    1: 
    1:           // finally, update the plugin by sending it a WM_WINDOWPOSCHANGED event
32799:           NPEvent pluginEvent;
    1:           pluginEvent.event = WM_WINDOWPOSCHANGED;
    1:           pluginEvent.wParam = 0;
43548:           pluginEvent.lParam = (LPARAM)&winpos;
43436:           inst->HandleEvent(&pluginEvent, nsnull);
57234:         }
    1: 
    1:         inst->SetWindow(window);
57234: 
21080:         mInstanceOwner->Paint(dirty, hdc);
21080:         nativeDraw.EndNativeDrawing();
36270:       } while (nativeDraw.ShouldRenderAgain());
21080:       nativeDraw.PaintToContext();
21080:     }
21080: 
21080:     ctx->SetMatrix(currentMatrix);
21080:   }
21080: #elif defined(XP_OS2)
70007:   nsRefPtr<nsNPAPIPluginInstance> inst;
70007:   GetPluginInstance(getter_AddRefs(inst));
21080:   if (inst) {
21080:     // Look if it's windowless
32799:     NPWindow *window;
21080:     mInstanceOwner->GetWindow(window);
21080: 
32799:     if (window->type == NPWindowTypeDrawable) {
21080:       // FIXME - Bug 385435: Doesn't aDirtyRect need translating too?
68481:       nsRenderingContext::AutoPushTranslation
68479:         translate(&aRenderingContext, aPluginRect.TopLeft());
21080: 
21080:       // check if we need to call SetWindow with updated parameters
21080:       PRBool doupdatewindow = PR_FALSE;
21080:       // the offset of the DC
23738:       nsIntPoint origin;
21080: 
21080:       /*
21080:        * Layout now has an optimized way of painting. Now we always get
21080:        * a new drawing surface, sized to be just what's needed. Windowless
21080:        * plugins need a transform applied to their origin so they paint
21080:        * in the right place. Since |SetWindow| is no longer being used
21080:        * to tell the plugin where it is, we dispatch a NPWindow through
21080:        * |HandleEvent| to tell the plugin when its window moved
21080:        */
21080:       gfxContext *ctx = aRenderingContext.ThebesContext();
21080: 
21080:       gfxMatrix ctxMatrix = ctx->CurrentMatrix();
21080:       if (ctxMatrix.HasNonTranslation()) {
21080:         // soo; in the future, we should be able to render
21080:         // the object content to an offscreen DC, and then
21080:         // composite it in with the right transforms.
21080: 
21080:         // But, we don't bother doing that, because we don't
21080:         // have the event handling story figured out yet.
21080:         // Instead, let's just bail.
21080: 
21080:         return;
21080:       }
21080: 
21080:       origin.x = NSToIntRound(float(ctxMatrix.GetTranslation().x));
21080:       origin.y = NSToIntRound(float(ctxMatrix.GetTranslation().y));
21080: 
21080:       /* Need to force the clip to be set */
21080:       ctx->UpdateSurfaceClip();
21080: 
21080:       /* Set the device offsets as appropriate, for whatever our current group offsets might be */
21080:       gfxFloat xoff, yoff;
21080:       nsRefPtr<gfxASurface> surf = ctx->CurrentSurface(&xoff, &yoff);
21080: 
21080:       if (surf->CairoStatus() != 0) {
21080:         NS_WARNING("Plugin is being asked to render to a surface that's in error!");
21080:         return;
21080:       }
21080: 
21080:       // check if we need to update the PS
68482:       HPS hps = (HPS)GetPSFromRC(aRenderingContext);
21080:       if (reinterpret_cast<HPS>(window->window) != hps) {
32955:         window->window = reinterpret_cast<void*>(hps);
21080:         doupdatewindow = PR_TRUE;
21080:       }
21080:       LONG lPSid = GpiSavePS(hps);
21080:       RECTL rclViewport;
21080:       if (GpiQueryDevice(hps) != NULLHANDLE) { // ensure that we have an associated HDC
21080:         if (GpiQueryPageViewport(hps, &rclViewport)) {
21080:           rclViewport.xLeft += (LONG)xoff;
21080:           rclViewport.xRight += (LONG)xoff;
21080:           rclViewport.yBottom += (LONG)yoff;
21080:           rclViewport.yTop += (LONG)yoff;
21080:           GpiSetPageViewport(hps, &rclViewport);
21080:         }
21080:       }
21080: 
21080:       if ((window->x != origin.x) || (window->y != origin.y)) {
21080:         window->x = origin.x;
21080:         window->y = origin.y;
21080:         doupdatewindow = PR_TRUE;
21080:       }
21080: 
21080:       // if our location or visible area has changed, we need to tell the plugin
21080:       if (doupdatewindow) {
21080:         inst->SetWindow(window);        
21080:       }
21080: 
12859:       mInstanceOwner->Paint(aDirtyRect, hps);
12859:       if (lPSid >= 1) {
12859:         GpiRestorePS(hps, lPSid);
12859:       }
    1:       surf->MarkDirty();
    1:     }
    1:   }
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectFrame::HandleEvent(nsPresContext* aPresContext,
    1:                            nsGUIEvent*     anEvent,
    1:                            nsEventStatus*  anEventStatus)
    1: {
32019:   NS_ENSURE_ARG_POINTER(anEvent);
    1:   NS_ENSURE_ARG_POINTER(anEventStatus);
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (!mInstanceOwner)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
13537:   mInstanceOwner->ConsiderNewEventloopNestingLevel();
13537: 
    1:   if (anEvent->message == NS_PLUGIN_ACTIVATE) {
29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:     nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(GetContent());
29018:     if (fm && elem)
29018:       return fm->SetFocus(elem, 0);
    1:   }
57526:   else if (anEvent->message == NS_PLUGIN_FOCUS) {
63883:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
57526:     if (fm)
57526:       return fm->FocusPlugin(GetContent());
57526:   }
    1: 
41061:   if (mInstanceOwner->SendNativeEvents() &&
69670:       NS_IS_PLUGIN_EVENT(anEvent)) {
22788:     *anEventStatus = mInstanceOwner->ProcessEvent(*anEvent);
22788:     return rv;
22788:   }
22788: 
    1: #ifdef XP_WIN
    1:   rv = nsObjectFrameSuper::HandleEvent(aPresContext, anEvent, anEventStatus);
    1:   return rv;
    1: #endif
    1: 
32019: #ifdef XP_MACOSX
34678:   // we want to process some native mouse events in the cocoa event model
34678:   if ((anEvent->message == NS_MOUSE_ENTER || anEvent->message == NS_MOUSE_SCROLL) &&
34678:       mInstanceOwner->GetEventModel() == NPEventModelCocoa) {
32019:     *anEventStatus = mInstanceOwner->ProcessEvent(*anEvent);
32019:     return rv;
32019:   }
32019: #endif
32019: 
34742:   if (anEvent->message == NS_DESTROY) {
36227: #ifdef MAC_CARBON_PLUGINS
    1:     mInstanceOwner->CancelTimer();
36227: #endif
    1:     return rv;
    1:   }
    1: 
34742:   return nsObjectFrameSuper::HandleEvent(aPresContext, anEvent, anEventStatus);
34742: }
34742: 
37413: #ifdef XP_MACOSX
37413: // Needed to make the routing of mouse events while dragging conform to
37413: // standard OS X practice, and to the Cocoa NPAPI spec.  See bug 525078.
37413: NS_IMETHODIMP
37413: nsObjectFrame::HandlePress(nsPresContext* aPresContext,
37413:                            nsGUIEvent*    anEvent,
37413:                            nsEventStatus* anEventStatus)
37413: {
37413:   nsIPresShell::SetCapturingContent(GetContent(), CAPTURE_IGNOREALLOWED);
37413:   return nsObjectFrameSuper::HandlePress(aPresContext, anEvent, anEventStatus);
37413: }
37413: #endif
37413: 
15569: nsresult
70007: nsObjectFrame::GetPluginInstance(nsNPAPIPluginInstance** aPluginInstance)
70007: {
70007:   *aPluginInstance = nsnull;
    1: 
77476:   if (!mInstanceOwner)
77476:     return NS_OK;
77476:   
77476:   return mInstanceOwner->GetInstance(aPluginInstance);
77476: }
77476: 
77476: nsresult
77476: nsObjectFrame::PrepareInstanceOwner()
77476: {
77476:   nsWeakFrame weakFrame(this);
77476: 
77476:   // First, have to stop any possibly running plugins.
77476:   StopPluginInternal(PR_FALSE);
77476: 
77476:   if (!weakFrame.IsAlive()) {
77476:     return NS_ERROR_NOT_AVAILABLE;
77476:   }
77476: 
77476:   NS_ASSERTION(!mInstanceOwner, "Must not have an instance owner here");
77476: 
77476:   mInstanceOwner = new nsPluginInstanceOwner();
77476: 
77476:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
77476:          ("Created new instance owner %p for frame %p\n", mInstanceOwner.get(),
77476:           this));
77476: 
77476:   // Note, |this| may very well be gone after this call.
77476:   return mInstanceOwner->Init(PresContext(), this, GetContent());
77476: }
77476: 
77476: nsresult
77476: nsObjectFrame::Instantiate(nsIChannel* aChannel, nsIStreamListener** aStreamListener)
77476: {
77476:   if (mPreventInstantiation) {
 8609:     return NS_OK;
 8609:   }
 8609:   
77476:   // Note: If PrepareInstanceOwner() returns an error, |this| may very
77476:   // well be deleted already.
77476:   nsresult rv = PrepareInstanceOwner();
77476:   NS_ENSURE_SUCCESS(rv, rv);
77476: 
77476:   nsCOMPtr<nsIPluginHost> pluginHostCOM(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID, &rv));
77476:   nsPluginHost *pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
77476:   if (NS_FAILED(rv)) {
77476:     return rv;
77476:   }
77476: 
77476:   mInstanceOwner->SetPluginHost(pluginHostCOM);
77476: 
77476:   // This must be done before instantiating the plugin
77476:   FixupWindow(GetContentRectRelativeToSelf().Size());
77476: 
77476:   // Ensure we redraw when a plugin is instantiated
77476:   Invalidate(GetContentRectRelativeToSelf());
77476: 
77476:   nsWeakFrame weakFrame(this);
77476: 
77476:   NS_ASSERTION(!mPreventInstantiation, "Say what?");
77476:   mPreventInstantiation = PR_TRUE;
77476:   rv = pluginHost->InstantiatePluginForChannel(aChannel, mInstanceOwner, aStreamListener);
77476: 
77476:   if (!weakFrame.IsAlive()) {
77476:     return NS_ERROR_NOT_AVAILABLE;
77476:   }
77476: 
77476:   NS_ASSERTION(mPreventInstantiation,
77476:                "Instantiation should still be prevented!");
77476:   mPreventInstantiation = PR_FALSE;
77476: 
77476: #ifdef ACCESSIBILITY
77476:   nsAccessibilityService* accService = nsIPresShell::AccService();
77476:   if (accService) {
77476:     accService->RecreateAccessible(PresContext()->PresShell(), mContent);
77476:   }
77476: #endif
77476: 
77476:   return rv;
77476: }
77476: 
77476: nsresult
77476: nsObjectFrame::Instantiate(const char* aMimeType, nsIURI* aURI)
77476: {
77476:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
77476:          ("nsObjectFrame::Instantiate(%s) called on frame %p\n", aMimeType,
77476:           this));
77476: 
77476:   if (mPreventInstantiation) {
77476:     return NS_OK;
77476:   }
77476: 
77476:   // XXXbz can aMimeType ever actually be null here?  If not, either
77476:   // the callers are wrong (and passing "" instead of null) or we can
77476:   // remove the codepaths dealing with null aMimeType in
77476:   // InstantiateEmbeddedPlugin.
77476:   NS_ASSERTION(aMimeType || aURI, "Need a type or a URI!");
77476: 
77476:   // Note: If PrepareInstanceOwner() returns an error, |this| may very
77476:   // well be deleted already.
77476:   nsresult rv = PrepareInstanceOwner();
77476:   NS_ENSURE_SUCCESS(rv, rv);
77476: 
77476:   nsWeakFrame weakFrame(this);
77476: 
77476:   // This must be done before instantiating the plugin
77476:   FixupWindow(GetContentRectRelativeToSelf().Size());
77476: 
77476:   // Ensure we redraw when a plugin is instantiated
77476:   Invalidate(GetContentRectRelativeToSelf());
77476: 
77476:   // get the nsIPluginHost service
77476:   nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID, &rv));
77476:   if (NS_FAILED(rv))
77476:     return rv;
77476:   mInstanceOwner->SetPluginHost(pluginHost);
77476: 
77476:   NS_ASSERTION(!mPreventInstantiation, "Say what?");
77476:   mPreventInstantiation = PR_TRUE;
77476: 
77476:   rv = InstantiatePlugin(static_cast<nsPluginHost*>(pluginHost.get()), aMimeType, aURI);
77476: 
77476:   if (!weakFrame.IsAlive()) {
77476:     return NS_ERROR_NOT_AVAILABLE;
77476:   }
77476: 
77476:   // finish up
77476:   if (NS_SUCCEEDED(rv)) {
77476:     TryNotifyContentObjectWrapper();
77476: 
77476:     if (!weakFrame.IsAlive()) {
77476:       return NS_ERROR_NOT_AVAILABLE;
77476:     }
77476: 
77476:     CallSetWindow();
77476:   }
77476: 
77476:   NS_ASSERTION(mPreventInstantiation,
77476:                "Instantiation should still be prevented!");
77476: 
77476: #ifdef ACCESSIBILITY
77476:   nsAccessibilityService* accService = nsIPresShell::AccService();
77476:   if (accService) {
77476:     accService->RecreateAccessible(PresContext()->PresShell(), mContent);
77476:   }
77476: #endif
77476: 
77476:   mPreventInstantiation = PR_FALSE;
77476: 
77476:   return rv;
77476: }
77476: 
77476: void
77476: nsObjectFrame::TryNotifyContentObjectWrapper()
77476: {
77476:   nsRefPtr<nsNPAPIPluginInstance> inst;
77476:   mInstanceOwner->GetInstance(getter_AddRefs(inst));
77476:   if (inst) {
77476:     // The plugin may have set up new interfaces; we need to mess with our JS
77476:     // wrapper.  Note that we DO NOT want to call this if there is no plugin
77476:     // instance!  That would just reenter Instantiate(), trying to create
77476:     // said plugin instance.
77476:     NotifyContentObjectWrapper();
77476:   }
77476: }
77476: 
77476: class nsStopPluginRunnable : public nsRunnable, public nsITimerCallback
77476: {
77476: public:
77476:   NS_DECL_ISUPPORTS_INHERITED
77476: 
77476:   nsStopPluginRunnable(nsPluginInstanceOwner *aInstanceOwner)
77476:     : mInstanceOwner(aInstanceOwner)
77476:   {
77476:     NS_ASSERTION(aInstanceOwner, "need an owner");
77476:   }
77476: 
77476:   // nsRunnable
77476:   NS_IMETHOD Run();
77476: 
77476:   // nsITimerCallback
77476:   NS_IMETHOD Notify(nsITimer *timer);
77476: 
77476: private:  
77476:   nsCOMPtr<nsITimer> mTimer;
77476:   nsRefPtr<nsPluginInstanceOwner> mInstanceOwner;
77476: };
77476: 
77476: NS_IMPL_ISUPPORTS_INHERITED1(nsStopPluginRunnable, nsRunnable, nsITimerCallback)
77476: 
77476: #if defined(XP_WIN)
77476: static const char*
77476: GetMIMEType(nsNPAPIPluginInstance *aPluginInstance)
77476: {
77476:   if (aPluginInstance) {
77476:     const char* mime = nsnull;
77476:     if (NS_SUCCEEDED(aPluginInstance->GetMIMEType(&mime)) && mime)
77476:       return mime;
77476:   }
77476:   return "";
77476: }
77476: #endif // XP_WIN
77476: 
77476: static PRBool
77476: DoDelayedStop(nsPluginInstanceOwner *aInstanceOwner, PRBool aDelayedStop)
77476: {
77476: #if (MOZ_PLATFORM_MAEMO==5)
77476:   // Don't delay stop on Maemo/Hildon (bug 530739).
77476:   if (aDelayedStop && aInstanceOwner->MatchPluginName("Shockwave Flash"))
77476:     return PR_FALSE;
77476: #endif
77476: 
77476:   // Don't delay stopping QuickTime (bug 425157), Flip4Mac (bug 426524),
77476:   // XStandard (bug 430219), CMISS Zinc (bug 429604).
77476:   if (aDelayedStop
77476: #if !(defined XP_WIN || defined MOZ_X11)
77476:       && !aInstanceOwner->MatchPluginName("QuickTime")
77476:       && !aInstanceOwner->MatchPluginName("Flip4Mac")
77476:       && !aInstanceOwner->MatchPluginName("XStandard plugin")
77476:       && !aInstanceOwner->MatchPluginName("CMISS Zinc Plugin")
77476: #endif
77476:       ) {
77476:     nsCOMPtr<nsIRunnable> evt = new nsStopPluginRunnable(aInstanceOwner);
77476:     NS_DispatchToCurrentThread(evt);
77476:     return PR_TRUE;
77476:   }
77476:   return PR_FALSE;
77476: }
77476: 
77476: static void
77476: DoStopPlugin(nsPluginInstanceOwner *aInstanceOwner, PRBool aDelayedStop)
77476: {
77476:   nsRefPtr<nsNPAPIPluginInstance> inst;
77476:   aInstanceOwner->GetInstance(getter_AddRefs(inst));
77476:   if (inst) {
77476:     NPWindow *win;
77476:     aInstanceOwner->GetWindow(win);
77476:     nsPluginNativeWindow *window = (nsPluginNativeWindow *)win;
77476:     nsRefPtr<nsNPAPIPluginInstance> nullinst;
77476: 
77476:     if (window) 
77476:       window->CallSetWindow(nullinst);
77476:     else 
77476:       inst->SetWindow(nsnull);
77476:     
77476:     if (DoDelayedStop(aInstanceOwner, aDelayedStop))
77476:       return;
77476: 
77476: #if defined(XP_MACOSX)
77476:     aInstanceOwner->HidePluginWindow();
77476: #endif
77476: 
77476:     nsCOMPtr<nsIPluginHost> pluginHost = do_GetService(MOZ_PLUGIN_HOST_CONTRACTID);
77476:     NS_ASSERTION(pluginHost, "Without a pluginHost, how can we have an instance to destroy?");
77476:     static_cast<nsPluginHost*>(pluginHost.get())->StopPluginInstance(inst);
77476: 
77476:     // the frame is going away along with its widget so tell the
77476:     // window to forget its widget too
77476:     if (window)
77476:       window->SetPluginWidget(nsnull);
77476:   }
77476: 
77476:   aInstanceOwner->Destroy();
77476: }
77476: 
77476: NS_IMETHODIMP
77476: nsStopPluginRunnable::Notify(nsITimer *aTimer)
77476: {
77476:   return Run();
77476: }
77476: 
77476: NS_IMETHODIMP
77476: nsStopPluginRunnable::Run()
77476: {
77476:   // InitWithCallback calls Release before AddRef so we need to hold a
77476:   // strong ref on 'this' since we fall through to this scope if it fails.
77476:   nsCOMPtr<nsITimerCallback> kungFuDeathGrip = this;
77476:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
77476:   if (appShell) {
77476:     PRUint32 currentLevel = 0;
77476:     appShell->GetEventloopNestingLevel(&currentLevel);
77476:     if (currentLevel > mInstanceOwner->GetLastEventloopNestingLevel()) {
77476:       if (!mTimer)
77476:         mTimer = do_CreateInstance("@mozilla.org/timer;1");
77476:       if (mTimer) {
77476:         // Fire 100ms timer to try to tear down this plugin as quickly as
77476:         // possible once the nesting level comes back down.
77476:         nsresult rv = mTimer->InitWithCallback(this, 100, nsITimer::TYPE_ONE_SHOT);
77476:         if (NS_SUCCEEDED(rv)) {
77476:           return rv;
77476:         }
77476:       }
77476:       NS_ERROR("Failed to setup a timer to stop the plugin later (at a safe "
77476:                "time). Stopping the plugin now, this might crash.");
77476:     }
77476:   }
77476: 
77476:   mTimer = nsnull;
77476: 
77476:   DoStopPlugin(mInstanceOwner, PR_FALSE);
77476: 
77476:   return NS_OK;
77476: }
77476: 
77476: void
77476: nsObjectFrame::StopPlugin()
77476: {
77476:   PRBool delayedStop = PR_FALSE;
77476: #ifdef XP_WIN
77476:   nsRefPtr<nsNPAPIPluginInstance> inst;
77476:   if (mInstanceOwner)
77476:     mInstanceOwner->GetInstance(getter_AddRefs(inst));
77476:   if (inst) {
77476:     // Delayed stop for Real plugin only; see bug 420886, 426852.
77476:     const char* pluginType = ::GetMIMEType(inst);
77476:     delayedStop = strcmp(pluginType, "audio/x-pn-realaudio-plugin") == 0;
77476:   }
77476: #endif
77476:   StopPluginInternal(delayedStop);
77476: }
77476: 
77476: void
77476: nsObjectFrame::StopPluginInternal(PRBool aDelayedStop)
77476: {
77476:   if (!mInstanceOwner) {
77476:     return;
77476:   }
77476: 
77476:   nsRootPresContext* rpc = PresContext()->GetRootPresContext();
77476:   if (!rpc) {
77476:     NS_ASSERTION(PresContext()->PresShell()->IsFrozen(),
77476:                  "unable to unregister the plugin frame");
77476:   }
77476:   else if (mWidget) {
77476:     rpc->UnregisterPluginForGeometryUpdates(this);
77476: 
77476:     // Make sure the plugin is hidden in case an update of plugin geometry
77476:     // hasn't happened since this plugin became hidden.
77476:     nsIWidget* parent = mWidget->GetParent();
77476:     if (parent) {
77476:       nsTArray<nsIWidget::Configuration> configurations;
77476:       GetEmptyClipConfiguration(&configurations);
77476:       parent->ConfigureChildren(configurations);
77476:     }
77476:   }
77476:   else {
77476: #ifndef XP_MACOSX
77476:     rpc->UnregisterPluginForGeometryUpdates(this);
77476: #endif
77476:   }
77476: 
77476:   // Transfer the reference to the instance owner onto the stack so
77476:   // that if we do end up re-entering this code, or if we unwind back
77476:   // here witha deleted frame (this), we can still continue to stop
77476:   // the plugin. Note that due to that, the ordering of the code in
77476:   // this function is extremely important.
77476: 
77476:   nsRefPtr<nsPluginInstanceOwner> owner;
77476:   owner.swap(mInstanceOwner);
77476: 
77476:   // Make sure that our windowless rect has been zeroed out, so if we
77476:   // get reinstantiated we'll send the right messages to the plug-in.
77476:   mWindowlessRect.SetEmpty();
77476: 
77476:   PRBool oldVal = mPreventInstantiation;
77476:   mPreventInstantiation = PR_TRUE;
77476: 
77476:   nsWeakFrame weakFrame(this);
77476: 
77476: #if defined(XP_WIN) || defined(MOZ_X11)
77476:   if (aDelayedStop && mWidget) {
77476:     // If we're asked to do a delayed stop it means we're stopping the
77476:     // plugin because we're destroying the frame. In that case, disown
77476:     // the widget.
77476:     mInnerView->DetachWidgetEventHandler(mWidget);
77476:     mWidget = nsnull;
77476:   }
77476: #endif
77476: 
77476:   // From this point on, |this| could have been deleted, so don't
77476:   // touch it!
77476:   owner->PrepareToStop(aDelayedStop);
77476: 
77476:   DoStopPlugin(owner, aDelayedStop);
77476: 
77476:   // If |this| is still alive, reset mPreventInstantiation.
77476:   if (weakFrame.IsAlive()) {
77476:     NS_ASSERTION(mPreventInstantiation,
77476:                  "Instantiation should still be prevented!");
77476: 
77476:     mPreventInstantiation = oldVal;
77476:   }
77476: 
77476:   // Break relationship between frame and plugin instance owner
77476:   owner->SetOwner(nsnull);
    1: }
    1: 
67677: NS_IMETHODIMP
67677: nsObjectFrame::GetCursor(const nsPoint& aPoint, nsIFrame::Cursor& aCursor)
67677: {
67677:   if (!mInstanceOwner) {
67677:     return NS_ERROR_FAILURE;
67677:   }
67677: 
70007:   nsRefPtr<nsNPAPIPluginInstance> inst;
70007:   mInstanceOwner->GetInstance(getter_AddRefs(inst));
67677:   if (!inst) {
67677:     return NS_ERROR_FAILURE;
67677:   }
67677: 
67677:   PRBool useDOMCursor = static_cast<nsNPAPIPluginInstance*>(inst.get())->UsesDOMForCursor();
67677:   if (!useDOMCursor) {
67677:     return NS_ERROR_FAILURE;
67677:   }
67677: 
67677:   return nsObjectFrameSuper::GetCursor(aPoint, aCursor);
67677: }
67677: 
    1: void
76815: nsObjectFrame::SetIsDocumentActive(PRBool aIsActive)
76815: {
76815: #ifndef XP_MACOSX
76815:   if (mInstanceOwner) {
76815:     mInstanceOwner->UpdateDocumentActiveState(aIsActive);
76815:   }
76815: #endif
76815: }
76815: 
77476: void
77476: nsObjectFrame::NotifyContentObjectWrapper()
77476: {
77476:   nsCOMPtr<nsIDocument> doc = mContent->GetDocument();
77476:   if (!doc)
77476:     return;
77476: 
77476:   nsIScriptGlobalObject *sgo = doc->GetScriptGlobalObject();
77476:   if (!sgo)
77476:     return;
77476: 
77476:   nsIScriptContext *scx = sgo->GetContext();
77476:   if (!scx)
77476:     return;
77476: 
78415:   JSContext *cx = scx->GetNativeContext();
77476: 
77476:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
77476:   nsContentUtils::XPConnect()->
77476:     GetWrappedNativeOfNativeObject(cx, sgo->GetGlobalJSObject(), mContent,
77476:                                    NS_GET_IID(nsISupports),
77476:                                    getter_AddRefs(wrapper));
77476: 
77476:   if (!wrapper) {
77476:     // Nothing to do here if there's no wrapper for mContent. The proto
77476:     // chain will be fixed appropriately when the wrapper is created.
77476:     return;
77476:   }
77476: 
77476:   JSObject *obj = nsnull;
77476:   nsresult rv = wrapper->GetJSObject(&obj);
77476:   if (NS_FAILED(rv))
77476:     return;
77476: 
77476:   nsHTMLPluginObjElementSH::SetupProtoChain(wrapper, cx, obj);
77476: }
77476: 
    1: // static
    1: nsIObjectFrame *
    1: nsObjectFrame::GetNextObjectFrame(nsPresContext* aPresContext, nsIFrame* aRoot)
    1: {
77154:   nsIFrame* child = aRoot->GetFirstPrincipalChild();
    1: 
    1:   while (child) {
23554:     nsIObjectFrame* outFrame = do_QueryFrame(child);
    1:     if (outFrame) {
70007:       nsRefPtr<nsNPAPIPluginInstance> pi;
70007:       outFrame->GetPluginInstance(getter_AddRefs(pi));  // make sure we have a REAL plugin
    1:       if (pi)
    1:         return outFrame;
    1:     }
    1: 
    1:     outFrame = GetNextObjectFrame(aPresContext, child);
    1:     if (outFrame)
    1:       return outFrame;
    1:     child = child->GetNextSibling();
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
54309: /*static*/ void
54309: nsObjectFrame::BeginSwapDocShells(nsIContent* aContent, void*)
54309: {
54309:   NS_PRECONDITION(aContent, "");
54309: 
54309:   // This function is called from a document content enumerator so we need
54309:   // to filter out the nsObjectFrames and ignore the rest.
54309:   nsIObjectFrame* obj = do_QueryFrame(aContent->GetPrimaryFrame());
54309:   if (!obj)
54309:     return;
54309: 
54309:   nsObjectFrame* objectFrame = static_cast<nsObjectFrame*>(obj);
54309:   NS_ASSERTION(!objectFrame->mWidget || objectFrame->mWidget->GetParent(),
54309:                "Plugin windows must not be toplevel");
54309:   nsRootPresContext* rootPC = objectFrame->PresContext()->GetRootPresContext();
54309:   NS_ASSERTION(rootPC, "unable to unregister the plugin frame");
54309:   rootPC->UnregisterPluginForGeometryUpdates(objectFrame);
54309: }
54309: 
54309: /*static*/ void
54309: nsObjectFrame::EndSwapDocShells(nsIContent* aContent, void*)
54309: {
54309:   NS_PRECONDITION(aContent, "");
54309: 
54309:   // This function is called from a document content enumerator so we need
54309:   // to filter out the nsObjectFrames and ignore the rest.
54309:   nsIObjectFrame* obj = do_QueryFrame(aContent->GetPrimaryFrame());
54309:   if (!obj)
54309:     return;
54309: 
54309:   nsObjectFrame* objectFrame = static_cast<nsObjectFrame*>(obj);
54309:   nsRootPresContext* rootPC = objectFrame->PresContext()->GetRootPresContext();
54309:   NS_ASSERTION(rootPC, "unable to register the plugin frame");
54309:   nsIWidget* widget = objectFrame->GetWidget();
54309:   if (widget) {
54309:     // Reparent the widget.
54309:     nsIWidget* parent =
54309:       rootPC->PresShell()->GetRootFrame()->GetNearestWidget();
54309:     widget->SetParent(parent);
54309:     objectFrame->CallSetWindow();
54309: 
54309:     // Register for geometry updates and make a request.
54309:     rootPC->RegisterPluginForGeometryUpdates(objectFrame);
54309:     rootPC->RequestUpdatePluginGeometry(objectFrame);
54309:   }
54309: }
54309: 
    1: nsIFrame*
    1: NS_NewObjectFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsObjectFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsObjectFrame)
