69069: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
69069: /* ***** BEGIN LICENSE BLOCK *****
69069:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
69069:  *
69069:  * The contents of this file are subject to the Mozilla Public License Version
69069:  * 1.1 (the "License"); you may not use this file except in compliance with
69069:  * the License. You may obtain a copy of the License at
69069:  * http://www.mozilla.org/MPL/
69069:  *
69069:  * Software distributed under the License is distributed on an "AS IS" basis,
69069:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
69069:  * for the specific language governing rights and limitations under the
69069:  * License.
69069:  *
69069:  * The Original Code is Mozilla code.
69069:  *
69069:  * The Initial Developer of the Original Code is
69069:  * Mozilla Corporation.
69069:  * Portions created by the Initial Developer are Copyright (C) 2011
69069:  * the Initial Developer. All Rights Reserved.
69069:  *
69069:  * Contributor(s):
69069:  *   Taras Glek <tglek@mozilla.com>
84578:  *   Vladan Djeric <vdjeric@mozilla.com>
69069:  *
69069:  * Alternatively, the contents of this file may be used under the terms of
69069:  * either the GNU General Public License Version 2 or later (the "GPL"), or
69069:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
69069:  * in which case the provisions of the GPL or the LGPL are applicable instead
69069:  * of those above. If you wish to allow use of your version of this file only
69069:  * under the terms of either the GPL or the LGPL, and not to allow others to
69069:  * use your version of this file under the terms of the MPL, indicate your
69069:  * decision by deleting the provisions above and replace them with the notice
69069:  * and other provisions required by the GPL or the LGPL. If you do not delete
69069:  * the provisions above, a recipient may use your version of this file under
69069:  * the terms of any one of the MPL, the GPL or the LGPL.
69069:  *
69069:  * ***** END LICENSE BLOCK ***** */
69069: 
69069: #include "base/histogram.h"
91189: #include "base/pickle.h"
69069: #include "nsIComponentManager.h"
69069: #include "nsIServiceManager.h"
69069: #include "nsCOMPtr.h"
69069: #include "mozilla/ModuleUtils.h"
69069: #include "nsIXPConnect.h"
69069: #include "mozilla/Services.h"
69069: #include "jsapi.h" 
69069: #include "nsStringGlue.h"
69069: #include "nsITelemetry.h"
91189: #include "nsIFile.h"
91189: #include "nsILocalFile.h"
72124: #include "Telemetry.h" 
72126: #include "nsTHashtable.h"
72126: #include "nsHashKeys.h"
72126: #include "nsBaseHashtable.h"
72212: #include "nsXULAppAPI.h"
84105: #include "nsThreadUtils.h"
84105: #include "mozilla/Mutex.h"
91189: #include "mozilla/FileUtils.h"
69069: 
70091: namespace {
70091: 
69069: using namespace base;
72124: using namespace mozilla;
72124: 
90012: template<class EntryType>
90012: class AutoHashtable : public nsTHashtable<EntryType>
90012: {
90012: public:
90012:   AutoHashtable(PRUint32 initSize = PL_DHASH_MIN_SIZE);
90012:   ~AutoHashtable();
90012:   typedef bool (*ReflectEntryFunc)(EntryType *entry, JSContext *cx, JSObject *obj);
90012:   bool ReflectHashtable(ReflectEntryFunc entryFunc, JSContext *cx, JSObject *obj);
90012: private:
90012:   struct EnumeratorArgs {
90012:     JSContext *cx;
90012:     JSObject *obj;
90012:     ReflectEntryFunc entryFunc;
90012:   };
90012:   static PLDHashOperator ReflectEntryStub(EntryType *entry, void *arg);
90012: };
90012: 
90012: template<class EntryType>
90012: AutoHashtable<EntryType>::AutoHashtable(PRUint32 initSize)
90012: {
90012:   this->Init(initSize);
90012: }
90012: 
90012: template<class EntryType>
90012: AutoHashtable<EntryType>::~AutoHashtable()
90012: {
90012:   this->Clear();
90012: }
90012: 
90012: template<typename EntryType>
90012: PLDHashOperator
90012: AutoHashtable<EntryType>::ReflectEntryStub(EntryType *entry, void *arg)
90012: {
90012:   EnumeratorArgs *args = static_cast<EnumeratorArgs *>(arg);
90012:   if (!args->entryFunc(entry, args->cx, args->obj)) {
90012:     return PL_DHASH_STOP;
90012:   }
90012:   return PL_DHASH_NEXT;
90012: }
90012: 
90012: /**
90012:  * Reflect the individual entries of table into JS, usually by defining
90012:  * some property and value of obj.  entryFunc is called for each entry.
90012:  */
90012: template<typename EntryType>
90012: bool
90012: AutoHashtable<EntryType>::ReflectHashtable(ReflectEntryFunc entryFunc,
90012:                                            JSContext *cx, JSObject *obj)
90012: {
90012:   EnumeratorArgs args = { cx, obj, entryFunc };
90099:   PRUint32 num = this->EnumerateEntries(ReflectEntryStub, static_cast<void*>(&args));
90012:   return num == this->Count();
90012: }
90012: 
72124: class TelemetryImpl : public nsITelemetry
69069: {
69069:   NS_DECL_ISUPPORTS
69069:   NS_DECL_NSITELEMETRY
69069: 
69069: public:
72126:   TelemetryImpl();
72126:   ~TelemetryImpl();
72124:   
72661:   static bool CanRecord();
72661:   static already_AddRefed<nsITelemetry> CreateTelemetryInstance();
72661:   static void ShutdownTelemetry();
84105:   static void RecordSlowStatement(const nsACString &statement,
84105:                                   const nsACString &dbName,
84105:                                   PRUint32 delay);
87400:   static nsresult GetHistogramEnumId(const char *name, Telemetry::ID *id);
84105:   struct StmtStats {
84105:     PRUint32 hitCount;
84105:     PRUint32 totalTime;
84105:   };
84105:   typedef nsBaseHashtableET<nsCStringHashKey, StmtStats> SlowSQLEntryType;
72661: 
72124: private:
90012:   static bool StatementReflector(SlowSQLEntryType *entry, JSContext *cx,
90012:                                  JSObject *obj);
84578:   bool AddSQLInfo(JSContext *cx, JSObject *rootObj, bool mainThread);
84105: 
86778:   // Like GetHistogramById, but returns the underlying C++ object, not the JS one.
86778:   nsresult GetHistogramByName(const nsACString &name, Histogram **ret);
87400:   bool ShouldReflectHistogram(Histogram *h);
87400:   void IdentifyCorruptHistograms(StatisticsRecorder::Histograms &hs);
87400:   typedef StatisticsRecorder::Histograms::iterator HistogramIterator;
90274: 
90274:   struct AddonHistogramInfo {
90274:     PRUint32 min;
90274:     PRUint32 max;
90274:     PRUint32 bucketCount;
90274:     PRUint32 histogramType;
90274:     Histogram *h;
90274:   };
90274:   typedef nsBaseHashtableET<nsCStringHashKey, AddonHistogramInfo> AddonHistogramEntryType;
90274:   typedef AutoHashtable<AddonHistogramEntryType> AddonHistogramMapType;
90274:   typedef nsBaseHashtableET<nsCStringHashKey, AddonHistogramMapType *> AddonEntryType;
90274:   typedef AutoHashtable<AddonEntryType> AddonMapType;
90274:   static bool AddonHistogramReflector(AddonHistogramEntryType *entry,
90274:                                       JSContext *cx, JSObject *obj);
90274:   static bool AddonReflector(AddonEntryType *entry, JSContext *cx, JSObject *obj);
91744:   static bool CreateHistogramForAddon(const nsACString &name,
91744:                                       AddonHistogramInfo &info);
90274:   AddonMapType mAddonMap;
90274: 
87400:   // This is used for speedy string->Telemetry::ID conversions
72126:   typedef nsBaseHashtableET<nsCharPtrHashKey, Telemetry::ID> CharPtrEntryType;
90012:   typedef AutoHashtable<CharPtrEntryType> HistogramMapType;
72126:   HistogramMapType mHistogramMap;
72661:   bool mCanRecord;
72661:   static TelemetryImpl *sTelemetry;
90012:   AutoHashtable<SlowSQLEntryType> mSlowSQLOnMainThread;
90012:   AutoHashtable<SlowSQLEntryType> mSlowSQLOnOtherThread;
90012:   // This gets marked immutable in debug builds, so we can't use
90012:   // AutoHashtable here.
84105:   nsTHashtable<nsCStringHashKey> mTrackedDBs;
84105:   Mutex mHashMutex;
69069: };
69069: 
72661: TelemetryImpl*  TelemetryImpl::sTelemetry = NULL;
72661: 
70091: // A initializer to initialize histogram collection
70091: StatisticsRecorder gStatisticsRecorder;
69069: 
72124: // Hardcoded probes
72124: struct TelemetryHistogram {
72124:   const char *id;
72124:   PRUint32 min;
72124:   PRUint32 max;
72124:   PRUint32 bucketCount;
72124:   PRUint32 histogramType;
86780:   const char *comment;
72124: };
72124: 
84790: // Perform the checks at the beginning of HistogramGet at compile time, so
84790: // that if people add incorrect histogram definitions, they get compiler
84790: // errors.
84790: #define HISTOGRAM(id, min, max, bucket_count, histogram_type, b) \
84790:   PR_STATIC_ASSERT(nsITelemetry::HISTOGRAM_ ## histogram_type == nsITelemetry::HISTOGRAM_BOOLEAN || \
91744:                    nsITelemetry::HISTOGRAM_ ## histogram_type == nsITelemetry::HISTOGRAM_FLAG || \
84790:                    (min < max && bucket_count > 2 && min >= 1));
84790: 
84790: #include "TelemetryHistograms.h"
84790: 
84790: #undef HISTOGRAM
84790: 
72124: const TelemetryHistogram gHistograms[] = {
86780: #define HISTOGRAM(id, min, max, bucket_count, histogram_type, comment) \
87086:   { NS_STRINGIFY(id), min, max, bucket_count, \
86780:     nsITelemetry::HISTOGRAM_ ## histogram_type, comment },
72124: 
72124: #include "TelemetryHistograms.h"
72124: 
72124: #undef HISTOGRAM
72124: };
87400: bool gCorruptHistograms[Telemetry::HistogramCount];
72124: 
86779: bool
86779: TelemetryHistogramType(Histogram *h, PRUint32 *result)
86779: {
86779:   switch (h->histogram_type()) {
86779:   case Histogram::HISTOGRAM:
86779:     *result = nsITelemetry::HISTOGRAM_EXPONENTIAL;
86779:     break;
86779:   case Histogram::LINEAR_HISTOGRAM:
86779:     *result = nsITelemetry::HISTOGRAM_LINEAR;
86779:     break;
86779:   case Histogram::BOOLEAN_HISTOGRAM:
86779:     *result = nsITelemetry::HISTOGRAM_BOOLEAN;
86779:     break;
91744:   case Histogram::FLAG_HISTOGRAM:
91744:     *result = nsITelemetry::HISTOGRAM_FLAG;
86779:   default:
86779:     return false;
86779:   }
86779:   return true;
86779: }
86779: 
72124: nsresult
72124: HistogramGet(const char *name, PRUint32 min, PRUint32 max, PRUint32 bucketCount,
72124:              PRUint32 histogramType, Histogram **result)
72124: {
91744:   if (histogramType != nsITelemetry::HISTOGRAM_BOOLEAN
91744:       && histogramType != nsITelemetry::HISTOGRAM_FLAG) {
72124:     // Sanity checks for histogram parameters.
72124:     if (min >= max)
72124:       return NS_ERROR_ILLEGAL_VALUE;
72124: 
72124:     if (bucketCount <= 2)
72124:       return NS_ERROR_ILLEGAL_VALUE;
72124: 
72124:     if (min < 1)
72124:       return NS_ERROR_ILLEGAL_VALUE;
72124:   }
72124: 
72124:   switch (histogramType) {
72124:   case nsITelemetry::HISTOGRAM_EXPONENTIAL:
72874:     *result = Histogram::FactoryGet(name, min, max, bucketCount, Histogram::kUmaTargetedHistogramFlag);
72124:     break;
72124:   case nsITelemetry::HISTOGRAM_LINEAR:
72874:     *result = LinearHistogram::FactoryGet(name, min, max, bucketCount, Histogram::kUmaTargetedHistogramFlag);
72124:     break;
72124:   case nsITelemetry::HISTOGRAM_BOOLEAN:
72874:     *result = BooleanHistogram::FactoryGet(name, Histogram::kUmaTargetedHistogramFlag);
72124:     break;
91744:   case nsITelemetry::HISTOGRAM_FLAG:
91744:     *result = FlagHistogram::FactoryGet(name, Histogram::kUmaTargetedHistogramFlag);
91744:     break;
72124:   default:
72124:     return NS_ERROR_INVALID_ARG;
72124:   }
72124:   return NS_OK;
72124: }
72124: 
72124: // O(1) histogram lookup by numeric id
72124: nsresult
72124: GetHistogramByEnumId(Telemetry::ID id, Histogram **ret)
72124: {
72124:   static Histogram* knownHistograms[Telemetry::HistogramCount] = {0};
72124:   Histogram *h = knownHistograms[id];
72124:   if (h) {
72124:     *ret = h;
72124:     return NS_OK;
72124:   }
72124: 
72124:   const TelemetryHistogram &p = gHistograms[id];
72125:   nsresult rv = HistogramGet(p.id, p.min, p.max, p.bucketCount, p.histogramType, &h);
72124:   if (NS_FAILED(rv))
78066:     return rv;
72124: 
72124:   *ret = knownHistograms[id] = h;
72124:   return NS_OK;
72124: }
72124: 
70091: bool
69069: FillRanges(JSContext *cx, JSObject *array, Histogram *h)
69069: {
69069:   for (size_t i = 0; i < h->bucket_count(); i++) {
69069:     if (!JS_DefineElement(cx, array, i, INT_TO_JSVAL(h->ranges(i)), NULL, NULL, JSPROP_ENUMERATE))
69069:       return false;
69069:   }
69069:   return true;
69069: }
69069: 
87400: enum reflectStatus {
87400:   REFLECT_OK,
87400:   REFLECT_CORRUPT,
87400:   REFLECT_FAILURE
87400: };
87400: 
87400: enum reflectStatus
91188: ReflectHistogramAndSamples(JSContext *cx, JSObject *obj, Histogram *h,
91188:                            const Histogram::SampleSet &ss)
69069: {
87400:   // We don't want to reflect corrupt histograms.
87400:   if (h->FindCorruption(ss) != Histogram::NO_INCONSISTENCIES) {
87400:     return REFLECT_CORRUPT;
87400:   }
87400: 
91402:   if (!(JS_DefineProperty(cx, obj, "min", INT_TO_JSVAL(h->declared_min()), NULL, NULL, JSPROP_ENUMERATE)
69069:         && JS_DefineProperty(cx, obj, "max", INT_TO_JSVAL(h->declared_max()), NULL, NULL, JSPROP_ENUMERATE)
69069:         && JS_DefineProperty(cx, obj, "histogram_type", INT_TO_JSVAL(h->histogram_type()), NULL, NULL, JSPROP_ENUMERATE)
91449:         && JS_DefineProperty(cx, obj, "sum", DOUBLE_TO_JSVAL(ss.sum()), NULL, NULL, JSPROP_ENUMERATE))) {
91449:     return REFLECT_FAILURE;
91449:   }
91449: 
91449:   const size_t count = h->bucket_count();
91449:   JSObject *rarray = JS_NewArrayObject(cx, count, nsnull);
91449:   if (!rarray) {
91449:     return REFLECT_FAILURE;
91449:   }
91449:   JS::AutoObjectRooter aroot(cx, rarray);
91449:   if (!(FillRanges(cx, rarray, h)
91449:         && JS_DefineProperty(cx, obj, "ranges", OBJECT_TO_JSVAL(rarray),
91449:                              NULL, NULL, JSPROP_ENUMERATE))) {
91449:     return REFLECT_FAILURE;
91449:   }
91449: 
91449:   JSObject *counts_array = JS_NewArrayObject(cx, count, NULL);
91449:   if (!counts_array) {
91449:     return REFLECT_FAILURE;
91449:   }
91449:   JS::AutoObjectRooter croot(cx, counts_array);
91449:   if (!JS_DefineProperty(cx, obj, "counts", OBJECT_TO_JSVAL(counts_array),
91449:                          NULL, NULL, JSPROP_ENUMERATE)) {
87400:     return REFLECT_FAILURE;
69069:   }
69069:   for (size_t i = 0; i < count; i++) {
91449:     if (!JS_DefineElement(cx, counts_array, i, INT_TO_JSVAL(ss.counts(i)),
91449:                           NULL, NULL, JSPROP_ENUMERATE)) {
87400:       return REFLECT_FAILURE;
69069:     }
69069:   }
91449:  
87400:   return REFLECT_OK;
69069: }
69069: 
91188: enum reflectStatus
91188: ReflectHistogramSnapshot(JSContext *cx, JSObject *obj, Histogram *h)
91188: {
91188:   Histogram::SampleSet ss;
91188:   h->SnapshotSample(&ss);
91188:   return ReflectHistogramAndSamples(cx, obj, h, ss);
91188: }
91188: 
70091: JSBool
91237: JSHistogram_Add(JSContext *cx, unsigned argc, jsval *vp)
69069: {
72659:   if (!argc) {
72659:     JS_ReportError(cx, "Expected one argument");
69069:     return JS_FALSE;
72659:   }
72659: 
72659:   jsval v = JS_ARGV(cx, vp)[0];
72659:   int32 value;
72659: 
72659:   if (!(JSVAL_IS_NUMBER(v) || JSVAL_IS_BOOLEAN(v))) {
72659:     JS_ReportError(cx, "Not a number");
69069:     return JS_FALSE;
72659:   }
72659: 
72659:   if (!JS_ValueToECMAInt32(cx, v, &value)) {
72659:     return JS_FALSE;
72659:   }
72659: 
72661:   if (TelemetryImpl::CanRecord()) {
69069:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
83114:     if (!obj) {
83114:       return JS_FALSE;
83114:     }
83114: 
89826:     Histogram *h = static_cast<Histogram*>(JS_GetPrivate(obj));
72124:     if (h->histogram_type() == Histogram::BOOLEAN_HISTOGRAM)
72124:       h->Add(!!value);
72124:     else
72124:       h->Add(value);
72661:   }
69069:   return JS_TRUE;
69069: }
69069: 
70091: JSBool
91237: JSHistogram_Snapshot(JSContext *cx, unsigned argc, jsval *vp)
69069: {
69069:   JSObject *obj = JS_THIS_OBJECT(cx, vp);
83114:   if (!obj) {
83114:     return JS_FALSE;
83114:   }
83114: 
89826:   Histogram *h = static_cast<Histogram*>(JS_GetPrivate(obj));
91449:   JSObject *snapshot = JS_NewObject(cx, nsnull, nsnull, nsnull);
69069:   if (!snapshot)
74342:     return JS_FALSE;
91449:   JS::AutoObjectRooter sroot(cx, snapshot);
87400: 
87400:   switch (ReflectHistogramSnapshot(cx, snapshot, h)) {
87400:   case REFLECT_FAILURE:
87400:     return JS_FALSE;
87400:   case REFLECT_CORRUPT:
87400:     JS_ReportError(cx, "Histogram is corrupt");
87400:     return JS_FALSE;
87400:   case REFLECT_OK:
69069:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(snapshot));
87400:     return JS_TRUE;
87400:   default:
87400:     MOZ_NOT_REACHED("unhandled reflection status");
87400:     return JS_FALSE;
87400:   }
69069: }
69069: 
70091: nsresult 
69069: WrapAndReturnHistogram(Histogram *h, JSContext *cx, jsval *ret)
69069: {
69069:   static JSClass JSHistogram_class = {
69069:     "JSHistogram",  /* name */
69069:     JSCLASS_HAS_PRIVATE, /* flags */
69069:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
69069:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, JS_FinalizeStub,
69069:     JSCLASS_NO_OPTIONAL_MEMBERS
69069:   };
69069: 
69069:   JSObject *obj = JS_NewObject(cx, &JSHistogram_class, NULL, NULL);
69069:   if (!obj)
69069:     return NS_ERROR_FAILURE;
91449:   JS::AutoObjectRooter root(cx, obj);
91449:   if (!(JS_DefineFunction (cx, obj, "add", JSHistogram_Add, 1, 0)
91449:         && JS_DefineFunction (cx, obj, "snapshot", JSHistogram_Snapshot, 1, 0))) {
91449:     return NS_ERROR_FAILURE;
91449:   }
69069:   *ret = OBJECT_TO_JSVAL(obj);
89826:   JS_SetPrivate(obj, h);
91449:   return NS_OK;
69069: }
69069: 
72661: TelemetryImpl::TelemetryImpl():
90012: mHistogramMap(Telemetry::HistogramCount),
84105: mCanRecord(XRE_GetProcessType() == GeckoProcessType_Default),
84105: mHashMutex("Telemetry::mHashMutex")
72661: {
84105:   // A whitelist to prevent Telemetry reporting on Addon & Thunderbird DBs
84105:   const char *trackedDBs[] = {
84105:     "addons.sqlite", "chromeappsstore.sqlite", "content-prefs.sqlite",
84105:     "cookies.sqlite", "downloads.sqlite", "extensions.sqlite",
84105:     "formhistory.sqlite", "index.sqlite", "permissions.sqlite", "places.sqlite",
84105:     "search.sqlite", "signons.sqlite", "urlclassifier3.sqlite",
84105:     "webappsstore.sqlite"
84105:   };
84105: 
84105:   mTrackedDBs.Init();
87070:   for (size_t i = 0; i < ArrayLength(trackedDBs); i++)
84105:     mTrackedDBs.PutEntry(nsDependentCString(trackedDBs[i]));
84105: 
86968: #ifdef DEBUG
86968:   // Mark immutable to prevent asserts on simultaneous access from multiple threads
86968:   mTrackedDBs.MarkImmutable();
86968: #endif
72126: }
72126: 
72126: TelemetryImpl::~TelemetryImpl() {
72126: }
72126: 
70239: NS_IMETHODIMP
72124: TelemetryImpl::NewHistogram(const nsACString &name, PRUint32 min, PRUint32 max, PRUint32 bucketCount, PRUint32 histogramType, JSContext *cx, jsval *ret)
69069: {
70239:   Histogram *h;
72124:   nsresult rv = HistogramGet(PromiseFlatCString(name).get(), min, max, bucketCount, histogramType, &h);
72124:   if (NS_FAILED(rv))
72124:     return rv;
72874:   h->ClearFlags(Histogram::kUmaTargetedHistogramFlag);
69069:   return WrapAndReturnHistogram(h, cx, ret);
69069: }
69069: 
90012: bool
90012: TelemetryImpl::StatementReflector(SlowSQLEntryType *entry, JSContext *cx,
90012:                                   JSObject *obj)
84105: {
84578:   const nsACString &sql = entry->GetKey();
84105:   jsval hitCount = UINT_TO_JSVAL(entry->mData.hitCount);
84105:   jsval totalTime = UINT_TO_JSVAL(entry->mData.totalTime);
84105: 
90012:   JSObject *arrayObj = JS_NewArrayObject(cx, 2, nsnull);
91449:   if (!arrayObj) {
91449:     return false;
91449:   }
91449:   JS::AutoObjectRooter root(cx, arrayObj);
91449:   return (JS_SetElement(cx, arrayObj, 0, &hitCount)
90012:           && JS_SetElement(cx, arrayObj, 1, &totalTime)
90012:           && JS_DefineProperty(cx, obj,
84578:                                sql.BeginReading(),
84578:                                OBJECT_TO_JSVAL(arrayObj),
90012:                                NULL, NULL, JSPROP_ENUMERATE));
84105: }
84105: 
84105: bool
84578: TelemetryImpl::AddSQLInfo(JSContext *cx, JSObject *rootObj, bool mainThread)
84105: {
84105:   JSObject *statsObj = JS_NewObject(cx, NULL, NULL, NULL);
84578:   if (!statsObj)
84105:     return false;
91449:   JS::AutoObjectRooter root(cx, statsObj);
84105: 
90012:   AutoHashtable<SlowSQLEntryType> &sqlMap = (mainThread
90012:                                              ? mSlowSQLOnMainThread
90012:                                              : mSlowSQLOnOtherThread);
91449:   if (!sqlMap.ReflectHashtable(StatementReflector, cx, statsObj)) {
91449:     return false;
91449:   }
91449: 
91449:   return JS_DefineProperty(cx, rootObj,
91449:                            mainThread ? "mainThread" : "otherThreads",
91449:                            OBJECT_TO_JSVAL(statsObj),
91449:                            NULL, NULL, JSPROP_ENUMERATE);
84105: }
84105: 
87399: nsresult
87399: TelemetryImpl::GetHistogramEnumId(const char *name, Telemetry::ID *id)
87399: {
87399:   if (!sTelemetry) {
87399:     return NS_ERROR_FAILURE;
87399:   }
87399: 
87399:   // Cache names
87399:   // Note the histogram names are statically allocated
87399:   TelemetryImpl::HistogramMapType *map = &sTelemetry->mHistogramMap;
87399:   if (!map->Count()) {
87399:     for (PRUint32 i = 0; i < Telemetry::HistogramCount; i++) {
87399:       CharPtrEntryType *entry = map->PutEntry(gHistograms[i].id);
87399:       if (NS_UNLIKELY(!entry)) {
87399:         map->Clear();
87399:         return NS_ERROR_OUT_OF_MEMORY;
87399:       }
87399:       entry->mData = (Telemetry::ID) i;
87399:     }
87399:   }
87399: 
87399:   CharPtrEntryType *entry = map->GetEntry(name);
87399:   if (!entry) {
87399:     return NS_ERROR_INVALID_ARG;
87399:   }
87399:   *id = entry->mData;
87399:   return NS_OK;
87399: }
87249: 
87243: nsresult
87249: TelemetryImpl::GetHistogramByName(const nsACString &name, Histogram **ret)
87243: {
87399:   Telemetry::ID id;
87399:   nsresult rv = GetHistogramEnumId(PromiseFlatCString(name).get(), &id);
87399:   if (NS_FAILED(rv)) {
87399:     return rv;
87243:   }
87243: 
87399:   rv = GetHistogramByEnumId(id, ret);
86778:   if (NS_FAILED(rv))
86778:     return rv;
86778: 
86778:   return NS_OK;
86778: }
86778: 
84135: NS_IMETHODIMP
86779: TelemetryImpl::HistogramFrom(const nsACString &name, const nsACString &existing_name,
86779:                              JSContext *cx, jsval *ret)
86779: {
86779:   Histogram *existing;
86779:   nsresult rv = GetHistogramByName(existing_name, &existing);
86779:   if (NS_FAILED(rv))
86779:     return rv;
86779: 
86779:   PRUint32 histogramType;
86779:   bool success = TelemetryHistogramType(existing, &histogramType);
86779:   if (!success)
86779:     return NS_ERROR_INVALID_ARG;
86779: 
86779:   Histogram *clone;
86779:   rv = HistogramGet(PromiseFlatCString(name).get(), existing->declared_min(),
86779:                     existing->declared_max(), existing->bucket_count(),
86779:                     histogramType, &clone);
86779:   if (NS_FAILED(rv))
86779:     return rv;
86779: 
86779:   Histogram::SampleSet ss;
86779:   existing->SnapshotSample(&ss);
86779:   clone->AddSampleSet(ss);
86779:   return WrapAndReturnHistogram(clone, cx, ret);
86779: }
86779: 
87400: void
87400: TelemetryImpl::IdentifyCorruptHistograms(StatisticsRecorder::Histograms &hs)
87400: {
87400:   for (HistogramIterator it = hs.begin(); it != hs.end(); ++it) {
87400:     Histogram *h = *it;
87400: 
87400:     Telemetry::ID id;
87400:     nsresult rv = GetHistogramEnumId(h->histogram_name().c_str(), &id);
87400:     // This histogram isn't a static histogram, just ignore it.
87400:     if (NS_FAILED(rv)) {
87400:       continue;
87400:     }
87400: 
87400:     if (gCorruptHistograms[id]) {
87400:       continue;
87400:     }
87400: 
87400:     Histogram::SampleSet ss;
87400:     h->SnapshotSample(&ss);
87400:     Histogram::Inconsistencies check = h->FindCorruption(ss);
87400:     bool corrupt = (check != Histogram::NO_INCONSISTENCIES);
87400: 
87400:     if (corrupt) {
87400:       Telemetry::ID corruptID = Telemetry::HistogramCount;
87400:       if (check & Histogram::RANGE_CHECKSUM_ERROR) {
87400:         corruptID = Telemetry::RANGE_CHECKSUM_ERRORS;
87400:       } else if (check & Histogram::BUCKET_ORDER_ERROR) {
87400:         corruptID = Telemetry::BUCKET_ORDER_ERRORS;
87400:       } else if (check & Histogram::COUNT_HIGH_ERROR) {
87400:         corruptID = Telemetry::TOTAL_COUNT_HIGH_ERRORS;
87400:       } else if (check & Histogram::COUNT_LOW_ERROR) {
87400:         corruptID = Telemetry::TOTAL_COUNT_LOW_ERRORS;
87400:       }
87400:       Telemetry::Accumulate(corruptID, 1);
87400:     }
87400: 
87400:     gCorruptHistograms[id] = corrupt;
87400:   }
87400: }
87400: 
87400: bool
87400: TelemetryImpl::ShouldReflectHistogram(Histogram *h)
87400: {
87400:   const char *name = h->histogram_name().c_str();
87400:   Telemetry::ID id;
87400:   nsresult rv = GetHistogramEnumId(name, &id);
87400:   if (NS_FAILED(rv)) {
87400:     // GetHistogramEnumId generally should not fail.  But a lookup
87400:     // failure shouldn't prevent us from reflecting histograms into JS.
87400:     //
87400:     // However, these two histograms are created by Histogram itself for
87400:     // tracking corruption.  We have our own histograms for that, so
87400:     // ignore these two.
87400:     if (strcmp(name, "Histogram.InconsistentCountHigh") == 0
87400:         || strcmp(name, "Histogram.InconsistentCountLow") == 0) {
87400:       return false;
87400:     }
87400:     return true;
87400:   } else {
87400:     return !gCorruptHistograms[id];
87400:   }
87400: }
87400: 
90274: // Compute the name to pass into Histogram for the addon histogram
90274: // 'name' from the addon 'id'.  We can't use 'name' directly because it
90274: // might conflict with other histograms in other addons or even with our
90274: // own.
90274: void
90274: AddonHistogramName(const nsACString &id, const nsACString &name,
90274:                    nsACString &ret)
90274: {
90274:   ret.Append(id);
90274:   ret.Append(NS_LITERAL_CSTRING(":"));
90274:   ret.Append(name);
90274: }
90274: 
90274: NS_IMETHODIMP
90274: TelemetryImpl::RegisterAddonHistogram(const nsACString &id,
90274:                                       const nsACString &name,
90274:                                       PRUint32 min, PRUint32 max,
90274:                                       PRUint32 bucketCount,
90274:                                       PRUint32 histogramType)
90274: {
90274:   AddonEntryType *addonEntry = mAddonMap.GetEntry(id);
90274:   if (!addonEntry) {
90274:     addonEntry = mAddonMap.PutEntry(id);
90274:     if (NS_UNLIKELY(!addonEntry)) {
90274:       return NS_ERROR_OUT_OF_MEMORY;
90274:     }
90274:     addonEntry->mData = new AddonHistogramMapType();
90274:   }
90274: 
90274:   AddonHistogramMapType *histogramMap = addonEntry->mData;
90274:   AddonHistogramEntryType *histogramEntry = histogramMap->GetEntry(name);
90274:   // Can't re-register the same histogram.
90274:   if (histogramEntry) {
90274:     return NS_ERROR_FAILURE;
90274:   }
90274: 
90274:   histogramEntry = histogramMap->PutEntry(name);
90274:   if (NS_UNLIKELY(!histogramEntry)) {
90274:     return NS_ERROR_OUT_OF_MEMORY;
90274:   }
90274: 
90274:   AddonHistogramInfo &info = histogramEntry->mData;
90274:   info.min = min;
90274:   info.max = max;
90274:   info.bucketCount = bucketCount;
90274:   info.histogramType = histogramType;
90274: 
90274:   return NS_OK;
90274: }
90274: 
90274: NS_IMETHODIMP
90274: TelemetryImpl::GetAddonHistogram(const nsACString &id, const nsACString &name,
90274:                                  JSContext *cx, jsval *ret)
90274: {
90274:   AddonEntryType *addonEntry = mAddonMap.GetEntry(id);
90274:   // The given id has not been registered.
90274:   if (!addonEntry) {
90274:     return NS_ERROR_INVALID_ARG;
90274:   }
90274: 
90274:   AddonHistogramMapType *histogramMap = addonEntry->mData;
90274:   AddonHistogramEntryType *histogramEntry = histogramMap->GetEntry(name);
90274:   // The given histogram name has not been registered.
90274:   if (!histogramEntry) {
90274:     return NS_ERROR_INVALID_ARG;
90274:   }
90274: 
90274:   AddonHistogramInfo &info = histogramEntry->mData;
91744:   if (!info.h) {
90274:     nsCAutoString actualName;
90274:     AddonHistogramName(id, name, actualName);
91744:     if (!CreateHistogramForAddon(actualName, info)) {
91744:       return NS_ERROR_FAILURE;
90274:     }
90274:   }
91744:   return WrapAndReturnHistogram(info.h, cx, ret);
90274: }
90274: 
90274: NS_IMETHODIMP
90274: TelemetryImpl::UnregisterAddonHistograms(const nsACString &id)
90274: {
90274:   AddonEntryType *addonEntry = mAddonMap.GetEntry(id);
90274:   if (addonEntry) {
90274:     // Histogram's destructor is private, so this is the best we can do.
90274:     // The histograms the addon created *will* stick around, but they
90274:     // will be deleted if and when the addon registers histograms with
90274:     // the same names.
90274:     delete addonEntry->mData;
90274:     mAddonMap.RemoveEntry(id);
90274:   }
90274: 
90274:   return NS_OK;
90274: }
90274: 
86779: NS_IMETHODIMP
72124: TelemetryImpl::GetHistogramSnapshots(JSContext *cx, jsval *ret)
69069: {
69069:   JSObject *root_obj = JS_NewObject(cx, NULL, NULL, NULL);
69069:   if (!root_obj)
69069:     return NS_ERROR_FAILURE;
69069:   *ret = OBJECT_TO_JSVAL(root_obj);
69069: 
91744:   // Ensure that all the HISTOGRAM_FLAG histograms have been created, so
91744:   // that their values are snapshotted.
91744:   for (size_t i = 0; i < Telemetry::HistogramCount; ++i) {
91744:     if (gHistograms[i].histogramType == nsITelemetry::HISTOGRAM_FLAG) {
91744:       Histogram *h;
91744:       DebugOnly<nsresult> rv = GetHistogramByEnumId(Telemetry::ID(i), &h);
91744:       MOZ_ASSERT(NS_SUCCEEDED(rv));
91744:     }
91744:   };
91744: 
87400:   StatisticsRecorder::Histograms hs;
87400:   StatisticsRecorder::GetHistograms(&hs);
87400: 
87400:   // We identify corrupt histograms first, rather than interspersing it
87400:   // in the loop below, to ensure that our corruption statistics don't
87400:   // depend on histogram enumeration order.
87400:   //
87400:   // Of course, we hope that all of these corruption-statistics
87400:   // histograms are not themselves corrupt...
87400:   IdentifyCorruptHistograms(hs);
87400: 
87400:   // OK, now we can actually reflect things.
87400:   for (HistogramIterator it = hs.begin(); it != hs.end(); ++it) {
69069:     Histogram *h = *it;
87400:     if (!ShouldReflectHistogram(h)) {
87400:       continue;
87400:     }
87400: 
69069:     JSObject *hobj = JS_NewObject(cx, NULL, NULL, NULL);
87400:     if (!hobj) {
69069:       return NS_ERROR_FAILURE;
69069:     }
91449:     JS::AutoObjectRooter root(cx, hobj);
87400:     switch (ReflectHistogramSnapshot(cx, hobj, h)) {
87400:     case REFLECT_CORRUPT:
87400:       // We can still hit this case even if ShouldReflectHistograms
87400:       // returns true.  The histogram lies outside of our control
87400:       // somehow; just skip it.
87400:       continue;
87400:     case REFLECT_FAILURE:
87400:       return NS_ERROR_FAILURE;
87400:     case REFLECT_OK:
87400:       if (!JS_DefineProperty(cx, root_obj, h->histogram_name().c_str(),
87400:                              OBJECT_TO_JSVAL(hobj), NULL, NULL, JSPROP_ENUMERATE)) {
87400:         return NS_ERROR_FAILURE;
87400:       }
87400:     }
69069:   }
84578:   return NS_OK;
84578: }
84578: 
90274: bool
91744: TelemetryImpl::CreateHistogramForAddon(const nsACString &name,
91744:                                        AddonHistogramInfo &info)
91744: {
91744:   Histogram *h;
91744:   nsresult rv = HistogramGet(PromiseFlatCString(name).get(),
91744:                              info.min, info.max, info.bucketCount,
91744:                              info.histogramType, &h);
91744:   if (NS_FAILED(rv)) {
91744:     return false;
91744:   }
91744:   // Don't let this histogram be reported via the normal means
91744:   // (e.g. Telemetry.registeredHistograms); we'll make it available in
91744:   // other ways.
91744:   h->ClearFlags(Histogram::kUmaTargetedHistogramFlag);
91744:   info.h = h;
91744:   return true;
91744: }
91744: 
91744: bool
90274: TelemetryImpl::AddonHistogramReflector(AddonHistogramEntryType *entry,
90274:                                        JSContext *cx, JSObject *obj)
90274: {
91744:   AddonHistogramInfo &info = entry->mData;
91744: 
90274:   // Never even accessed the histogram.
91744:   if (!info.h) {
91744:     // Have to force creation of HISTOGRAM_FLAG histograms.
91744:     if (info.histogramType != nsITelemetry::HISTOGRAM_FLAG) 
90274:       return true;
91744: 
91744:     if (!CreateHistogramForAddon(entry->GetKey(), info)) {
91744:       return false;
91744:     }
90274:   }
90274: 
90274:   JSObject *snapshot = JS_NewObject(cx, NULL, NULL, NULL);
91449:   if (!snapshot) {
91449:     // Just consider this to be skippable.
91449:     return true;
91449:   }
91449:   JS::AutoObjectRooter r(cx, snapshot);
91744:   switch (ReflectHistogramSnapshot(cx, snapshot, info.h)) {
90274:   case REFLECT_FAILURE:
90274:   case REFLECT_CORRUPT:
90274:     return false;
90274:   case REFLECT_OK:
90274:     const nsACString &histogramName = entry->GetKey();
90274:     if (!JS_DefineProperty(cx, obj,
90274:                            PromiseFlatCString(histogramName).get(),
90274:                            OBJECT_TO_JSVAL(snapshot), NULL, NULL,
90274:                            JSPROP_ENUMERATE)) {
90274:       return false;
90274:     }
90274:     break;
90274:   }
90274:   return true;
90274: }
90274: 
90274: bool
90274: TelemetryImpl::AddonReflector(AddonEntryType *entry,
90274:                               JSContext *cx, JSObject *obj)
90274: {
90274:   const nsACString &addonId = entry->GetKey();
90274:   JSObject *subobj = JS_NewObject(cx, NULL, NULL, NULL);
90274:   if (!subobj) {
90274:     return false;
90274:   }
91449:   JS::AutoObjectRooter r(cx, subobj);
90274: 
90274:   AddonHistogramMapType *map = entry->mData;
90274:   if (!(map->ReflectHashtable(AddonHistogramReflector, cx, subobj)
90274:         && JS_DefineProperty(cx, obj,
90274:                              PromiseFlatCString(addonId).get(),
90274:                              OBJECT_TO_JSVAL(subobj), NULL, NULL,
90274:                              JSPROP_ENUMERATE))) {
90274:     return false;
90274:   }
90274:   return true;
90274: }
90274: 
90274: NS_IMETHODIMP
90274: TelemetryImpl::GetAddonHistogramSnapshots(JSContext *cx, jsval *ret)
90274: {
90274:   *ret = JSVAL_VOID;
90274:   JSObject *obj = JS_NewObject(cx, NULL, NULL, NULL);
90274:   if (!obj) {
90274:     return NS_ERROR_FAILURE;
90274:   }
91449:   JS::AutoObjectRooter r(cx, obj);
90274: 
90274:   if (!mAddonMap.ReflectHashtable(AddonReflector, cx, obj)) {
90274:     return NS_ERROR_FAILURE;
90274:   }
90274:   *ret = OBJECT_TO_JSVAL(obj);
90274:   return NS_OK;
90274: }
90274: 
84578: NS_IMETHODIMP
84578: TelemetryImpl::GetSlowSQL(JSContext *cx, jsval *ret)
84578: {
84578:   JSObject *root_obj = JS_NewObject(cx, NULL, NULL, NULL);
84578:   if (!root_obj)
84578:     return NS_ERROR_FAILURE;
84578:   *ret = OBJECT_TO_JSVAL(root_obj);
84105: 
84105:   MutexAutoLock hashMutex(mHashMutex);
84105:   // Add info about slow SQL queries on the main thread
84578:   if (!AddSQLInfo(cx, root_obj, true))
84105:     return NS_ERROR_FAILURE;
84105:   // Add info about slow SQL queries on other threads
84578:   if (!AddSQLInfo(cx, root_obj, false))
84105:     return NS_ERROR_FAILURE;
84105: 
69069:   return NS_OK;
69069: }
69069: 
72124: NS_IMETHODIMP
86780: TelemetryImpl::GetRegisteredHistograms(JSContext *cx, jsval *ret)
86780: {
86780:   size_t count = ArrayLength(gHistograms);
86780:   JSObject *info = JS_NewObject(cx, NULL, NULL, NULL);
86780:   if (!info)
86780:     return NS_ERROR_FAILURE;
91449:   JS::AutoObjectRooter root(cx, info);
86780: 
86780:   for (size_t i = 0; i < count; ++i) {
86780:     JSString *comment = JS_InternString(cx, gHistograms[i].comment);
86780:     
86780:     if (!(comment
86780:           && JS_DefineProperty(cx, info, gHistograms[i].id,
86780:                                STRING_TO_JSVAL(comment), NULL, NULL,
86780:                                JSPROP_ENUMERATE))) {
86780:       return NS_ERROR_FAILURE;
86780:     }
86780:   }
86780: 
86780:   *ret = OBJECT_TO_JSVAL(info);
86780:   return NS_OK;
86780: }
86780: 
86780: NS_IMETHODIMP
72124: TelemetryImpl::GetHistogramById(const nsACString &name, JSContext *cx, jsval *ret)
69069: {
72124:   Histogram *h;
86778:   nsresult rv = GetHistogramByName(name, &h);
72124:   if (NS_FAILED(rv))
72124:     return rv;
72124: 
72124:   return WrapAndReturnHistogram(h, cx, ret);
69069: }
69069: 
91189: class TelemetrySessionData : public nsITelemetrySessionData
91189: {
91189:   NS_DECL_ISUPPORTS
91189:   NS_DECL_NSITELEMETRYSESSIONDATA
91189: 
91189: public:
91189:   static nsresult LoadFromDisk(nsIFile *, TelemetrySessionData **ptr);
91189:   static nsresult SaveToDisk(nsIFile *, const nsACString &uuid);
91189: 
91189:   TelemetrySessionData(const char *uuid);
91189:   ~TelemetrySessionData();
91189: 
91189: private:
91189:   typedef nsBaseHashtableET<nsUint32HashKey, Histogram::SampleSet> EntryType;
91189:   typedef AutoHashtable<EntryType> SessionMapType;
91189:   static bool SampleReflector(EntryType *entry, JSContext *cx, JSObject *obj);
91189:   SessionMapType mSampleSetMap;
91189:   nsCString mUUID;
91189: 
91189:   bool DeserializeHistogramData(Pickle &pickle, void **iter);
91189:   static bool SerializeHistogramData(Pickle &pickle);
91189: 
91189:   // The file format version.  Should be incremented whenever we change
91189:   // how individual SampleSets are stored in the file.
91189:   static const unsigned int sVersion = 1;
91189: };
91189: 
91189: NS_IMPL_THREADSAFE_ISUPPORTS1(TelemetrySessionData, nsITelemetrySessionData)
91189: 
91189: TelemetrySessionData::TelemetrySessionData(const char *uuid)
91189:   : mUUID(uuid)
91189: {
91189: }
91189: 
91189: TelemetrySessionData::~TelemetrySessionData()
91189: {
91189: }
91189: 
91189: NS_IMETHODIMP
91189: TelemetrySessionData::GetUuid(nsACString &uuid)
91189: {
91189:   uuid = mUUID;
91189:   return NS_OK;
91189: }
91189: 
91189: bool
91189: TelemetrySessionData::SampleReflector(EntryType *entry, JSContext *cx,
91189:                                       JSObject *snapshots)
91189: {
91189:   // Don't reflect histograms with no data associated with them.
91189:   if (entry->mData.sum() == 0) {
91189:     return true;
91189:   }
91189: 
91189:   // This has the undesirable effect of creating a histogram for the
91189:   // current session with the given ID.  But there's no good way to
91189:   // compute the ranges and buckets from scratch.
91189:   Histogram *h = nsnull;
91189:   nsresult rv = GetHistogramByEnumId(Telemetry::ID(entry->GetKey()), &h);
91189:   if (NS_FAILED(rv)) {
91189:     return true;
91189:   }
91189: 
91189:   JSObject *snapshot = JS_NewObject(cx, NULL, NULL, NULL);
91189:   if (!snapshot) {
91189:     return false;
91189:   }
91449:   JS::AutoObjectRooter root(cx, snapshot);
91189:   return (ReflectHistogramAndSamples(cx, snapshot, h, entry->mData)
91189:           && JS_DefineProperty(cx, snapshots,
91189:                                h->histogram_name().c_str(),
91189:                                OBJECT_TO_JSVAL(snapshot), NULL, NULL,
91189:                                JSPROP_ENUMERATE));
91189: }
91189: 
91189: NS_IMETHODIMP
91189: TelemetrySessionData::GetSnapshots(JSContext *cx, jsval *ret)
91189: {
91189:   JSObject *snapshots = JS_NewObject(cx, NULL, NULL, NULL);
91189:   if (!snapshots) {
91189:     return NS_ERROR_FAILURE;
91189:   }
91449:   JS::AutoObjectRooter root(cx, snapshots);
91189: 
91189:   if (!mSampleSetMap.ReflectHashtable(SampleReflector, cx, snapshots)) {
91189:     return NS_ERROR_FAILURE;
91189:   }
91189: 
91189:   *ret = OBJECT_TO_JSVAL(snapshots);
91189:   return NS_OK;
91189: }
91189: 
91189: bool
91189: TelemetrySessionData::DeserializeHistogramData(Pickle &pickle, void **iter)
91189: {
91189:   PRUint32 count = 0;
91189:   if (!pickle.ReadUInt32(iter, &count)) {
91189:     return false;
91189:   }
91189: 
91189:   for (size_t i = 0; i < count; ++i) {
91189:     int stored_length;
91189:     const char *name;
91189:     if (!pickle.ReadData(iter, &name, &stored_length)) {
91189:       return false;
91189:     }
91189: 
91189:     Telemetry::ID id;
91189:     nsresult rv = TelemetryImpl::GetHistogramEnumId(name, &id);
91189:     if (NS_FAILED(rv)) {
91189:       // We serialized a non-static histogram or we serialized a
91189:       // histogram that is no longer defined in TelemetryHistograms.h.
91189:       // Just drop its data on the floor.  If we can't deserialize the
91189:       // data, though, we're in trouble.
91189:       Histogram::SampleSet ss;
91189:       if (!ss.Deserialize(iter, pickle)) {
91189:         return false;
91189:       }
91189:     } else {
91189:       EntryType *entry = mSampleSetMap.GetEntry(id);
91189:       if (!entry) {
91189:         entry = mSampleSetMap.PutEntry(id);
91189:         if (NS_UNLIKELY(!entry)) {
91189:           return false;
91189:         }
91189:         if (!entry->mData.Deserialize(iter, pickle)) {
91189:           return false;
91189:         }
91189:       }
91189:     }
91189:   }
91189: 
91189:   return true;
91189: }
91189: 
91189: nsresult
91189: TelemetrySessionData::LoadFromDisk(nsIFile *file, TelemetrySessionData **ptr)
91189: {
91189:   *ptr = nsnull;
91189:   nsresult rv;
91189:   nsCOMPtr<nsILocalFile> f(do_QueryInterface(file, &rv));
91189:   if (NS_FAILED(rv)) {
91189:     return rv;
91189:   }
91189: 
91189:   AutoFDClose fd;
91189:   rv = f->OpenNSPRFileDesc(PR_RDONLY, 0, &fd);
91189:   if (NS_FAILED(rv)) {
91189:     return NS_ERROR_FAILURE;
91189:   }
91189: 
91993:   // If there's not even enough data to read the header for the pickle,
91993:   // don't bother.  Conveniently, this handles the error case as well.
91189:   PRInt32 size = PR_Available(fd);
91993:   if (size < static_cast<PRInt32>(sizeof(Pickle::Header))) {
91189:     return NS_ERROR_FAILURE;
91189:   }
91189: 
91189:   nsAutoArrayPtr<char> data(new char[size]);
91189:   PRInt32 amount = PR_Read(fd, data, size);
91189:   if (amount != size) {
91189:     return NS_ERROR_FAILURE;
91189:   }
91189: 
91189:   Pickle pickle(data, size);
91189:   void *iter = NULL;
91189: 
91993:   // Make sure that how much data the pickle thinks it has corresponds
91993:   // with how much data we actually read.
91993:   const Pickle::Header *header = pickle.headerT<Pickle::Header>();
91993:   if (header->payload_size != static_cast<PRUint32>(amount) - sizeof(*header)) {
91993:     return NS_ERROR_FAILURE;
91993:   }
91993: 
91189:   unsigned int storedVersion;
91189:   if (!(pickle.ReadUInt32(&iter, &storedVersion)
91189:         && storedVersion == sVersion)) {
91189:     return NS_ERROR_FAILURE;
91189:   }
91189: 
91189:   const char *uuid;
91189:   int uuidLength;
91189:   if (!pickle.ReadData(&iter, &uuid, &uuidLength)) {
91189:     return NS_ERROR_FAILURE;
91189:   }
91189: 
91189:   nsAutoPtr<TelemetrySessionData> sessionData(new TelemetrySessionData(uuid));
91189:   if (!sessionData->DeserializeHistogramData(pickle, &iter)) {
91189:     return NS_ERROR_FAILURE;
91189:   }
91189: 
91189:   *ptr = sessionData.forget();
91189:   return NS_OK;
91189: }
91189: 
91189: bool
91189: TelemetrySessionData::SerializeHistogramData(Pickle &pickle)
91189: {
91189:   StatisticsRecorder::Histograms hs;
91189:   StatisticsRecorder::GetHistograms(&hs);
91189: 
91189:   if (!pickle.WriteUInt32(hs.size())) {
91189:     return false;
91189:   }
91189: 
91189:   for (StatisticsRecorder::Histograms::const_iterator it = hs.begin();
91189:        it != hs.end();
91189:        ++it) {
91189:     const Histogram *h = *it;
91189:     const char *name = h->histogram_name().c_str();
91189: 
91189:     Histogram::SampleSet ss;
91189:     h->SnapshotSample(&ss);
91189: 
91189:     if (!(pickle.WriteData(name, strlen(name)+1)
91189:           && ss.Serialize(&pickle))) {
91189:       return false;
91189:     }
91189:   }
91189: 
91189:   return true;
91189: }
91189: 
91189: nsresult
91189: TelemetrySessionData::SaveToDisk(nsIFile *file, const nsACString &uuid)
91189: {
91189:   nsresult rv;
91189:   nsCOMPtr<nsILocalFile> f(do_QueryInterface(file, &rv));
91189:   if (NS_FAILED(rv)) {
91189:     return rv;
91189:   }
91189: 
91189:   AutoFDClose fd;
91189:   rv = f->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE, 0600, &fd);
91189:   if (NS_FAILED(rv)) {
91189:     return rv;
91189:   }
91189: 
91189:   Pickle pickle;
91189:   if (!pickle.WriteUInt32(sVersion)) {
91189:     return NS_ERROR_FAILURE;
91189:   }
91189: 
91189:   // Include the trailing NULL for the UUID to make reading easier.
91189:   const char *data;
91189:   size_t length = uuid.GetData(&data);
91189:   if (!(pickle.WriteData(data, length+1)
91189:         && SerializeHistogramData(pickle))) {
91189:     return NS_ERROR_FAILURE;
91189:   }
91189: 
91189:   PRInt32 amount = PR_Write(fd, static_cast<const char*>(pickle.data()),
91189:                             pickle.size());
91189:   if (amount != pickle.size()) {
91189:     return NS_ERROR_FAILURE;
91189:   }
91189: 
91189:   return NS_OK;
91189: }
91189: 
91189: class SaveHistogramEvent : public nsRunnable
91189: {
91189: public:
91189:   SaveHistogramEvent(nsIFile *file, const nsACString &uuid,
91189:                      nsITelemetrySaveSessionDataCallback *callback)
91189:     : mFile(file), mUUID(uuid), mCallback(callback)
91189:   {}
91189: 
91189:   NS_IMETHOD Run()
91189:   {
91189:     nsresult rv = TelemetrySessionData::SaveToDisk(mFile, mUUID);
91189:     mCallback->Handle(!!NS_SUCCEEDED(rv));
91189:     return rv;
91189:   }
91189: 
91189: private:
91189:   nsCOMPtr<nsIFile> mFile;
91189:   nsCString mUUID;
91189:   nsCOMPtr<nsITelemetrySaveSessionDataCallback> mCallback;
91189: };
91189: 
91189: NS_IMETHODIMP
91189: TelemetryImpl::SaveHistograms(nsIFile *file, const nsACString &uuid,
91189:                               nsITelemetrySaveSessionDataCallback *callback,
91189:                               bool isSynchronous)
91189: {
91189:   nsCOMPtr<nsIRunnable> event = new SaveHistogramEvent(file, uuid, callback);
91189:   if (isSynchronous) {
91189:     return event ? event->Run() : NS_ERROR_FAILURE;
91189:   } else {
91189:     return NS_DispatchToCurrentThread(event);
91189:   }
91189: }
91189: 
91189: class LoadHistogramEvent : public nsRunnable
91189: {
91189: public:
91189:   LoadHistogramEvent(nsIFile *file,
91189:                      nsITelemetryLoadSessionDataCallback *callback)
91189:     : mFile(file), mCallback(callback)
91189:   {}
91189: 
91189:   NS_IMETHOD Run()
91189:   {
91189:     TelemetrySessionData *sessionData = nsnull;
91189:     nsresult rv = TelemetrySessionData::LoadFromDisk(mFile, &sessionData);
91189:     if (NS_FAILED(rv)) {
91189:       mCallback->Handle(nsnull);
91189:     } else {
91189:       nsCOMPtr<nsITelemetrySessionData> data(sessionData);
91189:       mCallback->Handle(data);
91189:     }
91189:     return rv;
91189:   }
91189: 
91189: private:
91189:   nsCOMPtr<nsIFile> mFile;
91189:   nsCOMPtr<nsITelemetryLoadSessionDataCallback> mCallback;
91189: };
91189: 
91189: NS_IMETHODIMP
91189: TelemetryImpl::LoadHistograms(nsIFile *file,
91189:                               nsITelemetryLoadSessionDataCallback *callback)
91189: {
91189:   nsCOMPtr<nsIRunnable> event = new LoadHistogramEvent(file, callback);
91189:   return NS_DispatchToCurrentThread(event);
91189: }
91189: 
72661: NS_IMETHODIMP
79445: TelemetryImpl::GetCanRecord(bool *ret) {
72661:   *ret = mCanRecord;
72661:   return NS_OK;
72661: }
72661: 
72661: NS_IMETHODIMP
79445: TelemetryImpl::SetCanRecord(bool canRecord) {
72661:   mCanRecord = !!canRecord;
72661:   return NS_OK;
72661: }
72661: 
72661: bool
72661: TelemetryImpl::CanRecord() {
72661:   return !sTelemetry || sTelemetry->mCanRecord;
72661: }
72124: 
89811: NS_IMETHODIMP
89811: TelemetryImpl::GetCanSend(bool *ret) {
89811: #if defined(MOZILLA_OFFICIAL) && defined(MOZ_TELEMETRY_REPORTING)
89811:   *ret = true;
89811: #else
89811:   *ret = false;
89811: #endif
89811:   return NS_OK;
89811: }
89811: 
72124: already_AddRefed<nsITelemetry>
72661: TelemetryImpl::CreateTelemetryInstance()
72124: {
72661:   NS_ABORT_IF_FALSE(sTelemetry == NULL, "CreateTelemetryInstance may only be called once, via GetService()");
72661:   sTelemetry = new TelemetryImpl(); 
72661:   // AddRef for the local reference
72661:   NS_ADDREF(sTelemetry);
72661:   // AddRef for the caller
72661:   NS_ADDREF(sTelemetry);
72661:   return sTelemetry;
72124: }
72124: 
72661: void
72661: TelemetryImpl::ShutdownTelemetry()
72661: {
72661:   NS_IF_RELEASE(sTelemetry);
72661: }
72661: 
84105: void
84105: TelemetryImpl::RecordSlowStatement(const nsACString &statement,
84105:                                    const nsACString &dbName,
84105:                                    PRUint32 delay)
84105: {
86967:   MOZ_ASSERT(sTelemetry);
84105:   if (!sTelemetry->mCanRecord || !sTelemetry->mTrackedDBs.GetEntry(dbName))
84105:     return;
84105: 
90012:   AutoHashtable<SlowSQLEntryType> *slowSQLMap = NULL;
84105:   if (NS_IsMainThread())
84105:     slowSQLMap = &(sTelemetry->mSlowSQLOnMainThread);
84105:   else
84105:     slowSQLMap = &(sTelemetry->mSlowSQLOnOtherThread);
84105: 
84105:   MutexAutoLock hashMutex(sTelemetry->mHashMutex);
84105:   SlowSQLEntryType *entry = slowSQLMap->GetEntry(statement);
84105:   if (!entry) {
84105:     entry = slowSQLMap->PutEntry(statement);
84105:     if (NS_UNLIKELY(!entry))
84105:       return;
84105:     entry->mData.hitCount = 0;
84105:     entry->mData.totalTime = 0;
84105:   }
84105:   entry->mData.hitCount++;
84105:   entry->mData.totalTime += delay;
84105: }
84105: 
72661: NS_IMPL_THREADSAFE_ISUPPORTS1(TelemetryImpl, nsITelemetry)
72661: NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(nsITelemetry, TelemetryImpl::CreateTelemetryInstance)
69069: 
69069: #define NS_TELEMETRY_CID \
70091:   {0xaea477f2, 0xb3a2, 0x469c, {0xaa, 0x29, 0x0a, 0x82, 0xd1, 0x32, 0xb8, 0x29}}
69069: NS_DEFINE_NAMED_CID(NS_TELEMETRY_CID);
69069: 
72124: const Module::CIDEntry kTelemetryCIDs[] = {
72124:   { &kNS_TELEMETRY_CID, false, NULL, nsITelemetryConstructor },
69069:   { NULL }
69069: };
69069: 
72124: const Module::ContractIDEntry kTelemetryContracts[] = {
69069:   { "@mozilla.org/base/telemetry;1", &kNS_TELEMETRY_CID },
69069:   { NULL }
69069: };
69069: 
72124: const Module kTelemetryModule = {
72124:   Module::kVersion,
69069:   kTelemetryCIDs,
69069:   kTelemetryContracts,
69069:   NULL,
69069:   NULL,
69069:   NULL,
72661:   TelemetryImpl::ShutdownTelemetry
69069: };
69069: 
70091: } // anonymous namespace
70091: 
72124: namespace mozilla {
72124: namespace Telemetry {
72124: 
72124: void
72124: Accumulate(ID aHistogram, PRUint32 aSample)
72124: {
72661:   if (!TelemetryImpl::CanRecord()) {
72661:     return;
72661:   }
72124:   Histogram *h;
72124:   nsresult rv = GetHistogramByEnumId(aHistogram, &h);
72124:   if (NS_SUCCEEDED(rv))
72124:     h->Add(aSample);
72124: }
72124: 
80424: void
80424: AccumulateTimeDelta(ID aHistogram, TimeStamp start, TimeStamp end)
80424: {
80424:   Accumulate(aHistogram,
80424:              static_cast<PRUint32>((end - start).ToMilliseconds()));
80424: }
80424: 
88566: bool
88566: CanRecord()
88566: {
88566:   return TelemetryImpl::CanRecord();
88566: }
88566: 
78066: base::Histogram*
78066: GetHistogramById(ID id)
78066: {
78066:   Histogram *h = NULL;
78066:   GetHistogramByEnumId(id, &h);
78066:   return h;
78066: }
78066: 
84105: void
84105: RecordSlowSQLStatement(const nsACString &statement,
84105:                        const nsACString &dbName,
84105:                        PRUint32 delay)
84105: {
84105:   TelemetryImpl::RecordSlowStatement(statement, dbName, delay);
84105: }
84105: 
86967: void Init()
86967: {
86967:   // Make the service manager hold a long-lived reference to the service
86967:   nsCOMPtr<nsITelemetry> telemetryService =
86967:     do_GetService("@mozilla.org/base/telemetry;1");
86967:   MOZ_ASSERT(telemetryService);
86967: }
86967: 
72124: } // namespace Telemetry
72124: } // namespace mozilla
72124: 
69069: NSMODULE_DEFN(nsTelemetryModule) = &kTelemetryModule;
72212: 
72212: /**
72212:  * The XRE_TelemetryAdd function is to be used by embedding applications
72212:  * that can't use mozilla::Telemetry::Accumulate() directly.
72212:  */
72212: void
72212: XRE_TelemetryAccumulate(int aID, PRUint32 aSample)
72212: {
72212:   mozilla::Telemetry::Accumulate((mozilla::Telemetry::ID) aID, aSample);
72212: }
