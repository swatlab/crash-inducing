59934: #!/usr/bin/env python
59934: 
56539: # jit_test.py -- Python harness for JavaScript trace tests.
56536: 
56536: import datetime, os, re, sys, tempfile, traceback
56536: import subprocess
56536: from subprocess import *
56536: 
56536: DEBUGGER_INFO = {
56536:   "gdb": {
56536:     "interactive": True,
56536:     "args": "-q --args"
56536:   },
56536: 
56536:   "valgrind": {
56536:     "interactive": False,
56536:     "args": "--leak-check=full"
56536:   }
56536: }
56536: 
56536: # Backported from Python 3.1 posixpath.py
56536: def _relpath(path, start=None):
56536:     """Return a relative version of a path"""
56536: 
56536:     if not path:
56536:         raise ValueError("no path specified")
56536: 
56536:     if start is None:
56536:         start = os.curdir
56536: 
56536:     start_list = os.path.abspath(start).split(os.sep)
56536:     path_list = os.path.abspath(path).split(os.sep)
56536: 
56536:     # Work out how much of the filepath is shared by start and path.
56536:     i = len(os.path.commonprefix([start_list, path_list]))
56536: 
56536:     rel_list = [os.pardir] * (len(start_list)-i) + path_list[i:]
56536:     if not rel_list:
56536:         return os.curdir
56536:     return os.path.join(*rel_list)
56536: 
56536: os.path.relpath = _relpath
56536: 
56536: class Test:
56536:     def __init__(self, path):
56536:         self.path = path       # path to test file
56536:         
56536:         self.jitflags = []     # jit flags to enable
56536:         self.slow = False      # True means the test is slow-running
56536:         self.allow_oom = False # True means that OOM is not considered a failure
56536:         self.valgrind = False  # True means run under valgrind
56536:         self.tmflags = ''      # Value of TMFLAGS env var to pass
56536:         self.error = ''        # Errors to expect and consider passing
56536: 
56536:     def copy(self):
56536:         t = Test(self.path)
62583:         t.jitflags = self.jitflags[:]
56536:         t.slow = self.slow
56536:         t.allow_oom = self.allow_oom
56536:         t.valgrind = self.valgrind
56536:         t.tmflags = self.tmflags
56536:         t.error = self.error
56536:         return t
56536: 
56539:     COOKIE = '|jit-test|'
56536: 
56536:     @classmethod
56536:     def from_file(cls, path, options):
56536:         test = cls(path)
56536: 
56536:         line = open(path).readline()
56536:         i = line.find(cls.COOKIE)
56536:         if i != -1:
56536:             meta = line[i + len(cls.COOKIE):].strip('\n')
56536:             parts = meta.split(';')
56536:             for part in parts:
56536:                 part = part.strip()
56536:                 if not part:
56536:                     continue
56536:                 name, _, value = part.partition(':')
56536:                 if value:
56536:                     value = value.strip()
56536:                     if name == 'TMFLAGS':
56536:                         test.tmflags = value
56536:                     elif name == 'error':
56536:                         test.error = value
56536:                     else:
56539:                         print('warning: unrecognized |jit-test| attribute %s'%part)
56536:                 else:
56536:                     if name == 'slow':
56536:                         test.slow = True
56536:                     elif name == 'allow-oom':
56536:                         test.allow_oom = True
56536:                     elif name == 'valgrind':
56536:                         test.valgrind = options.valgrind
62574:                     elif name == 'mjitalways':
62574:                         test.jitflags.append('-a')
62780:                     elif name == 'debug':
62780:                         test.jitflags.append('-d')
56536:                     else:
56539:                         print('warning: unrecognized |jit-test| attribute %s'%part)
56536: 
56536:         if options.valgrind_all:
56536:             test.valgrind = True
56536: 
56536:         return test
56536: 
56536: def find_tests(dir, substring = None):
56536:     ans = []
56536:     for dirpath, dirnames, filenames in os.walk(dir):
56536:         dirnames.sort()
56536:         filenames.sort()
56536:         if dirpath == '.':
56536:             continue
56536:         for filename in filenames:
56536:             if not filename.endswith('.js'):
56536:                 continue
56536:             if filename in ('shell.js', 'browser.js', 'jsref.js'):
56536:                 continue
56536:             test = os.path.join(dirpath, filename)
56536:             if substring is None or substring in os.path.relpath(test, dir):
56536:                 ans.append(test)
56536:     return ans
56536: 
56536: def get_test_cmd(path, jitflags, lib_dir):
56536:     libdir_var = lib_dir
56536:     if not libdir_var.endswith('/'):
56536:         libdir_var += '/'
56536:     expr = "const platform=%r; const libdir=%r;"%(sys.platform, libdir_var)
56536:     return [ JS ] + jitflags + [ '-e', expr, '-f', os.path.join(lib_dir, 'prolog.js'),
56536:              '-f', path ]
56536: 
56536: def run_cmd(cmdline, env):
56536:     # close_fds is not supported on Windows and will cause a ValueError.
56536:     close_fds = sys.platform != 'win32'
56536:     p = Popen(cmdline, stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=close_fds, env=env)
56536:     out, err = p.communicate()
56536:     return out.decode(), err.decode(), p.returncode
56536: 
56536: def tmppath(token):
56536:     fd, path = tempfile.mkstemp(prefix=token)
56536:     os.close(fd)
56536:     return path
56536: 
56536: def read_and_unlink(path):
56536:     f = open(path)
56536:     d = f.read()
56536:     f.close()
56536:     os.unlink(path)
56536:     return d
56536: 
56536: def run_cmd_avoid_stdio(cmdline, env):
56536:     stdoutPath, stderrPath = tmppath('jsstdout'), tmppath('jsstderr')
56536:     env['JS_STDOUT'] = stdoutPath
56536:     env['JS_STDERR'] = stderrPath       
56536:     # close_fds is not supported on Windows and will cause a ValueError.
56536:     close_fds = sys.platform != 'win32'
56536:     p = Popen(cmdline, stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=close_fds, env=env)
56536:     _, __ = p.communicate()
56536:     return read_and_unlink(stdoutPath), read_and_unlink(stderrPath), p.returncode
56536: 
56536: def run_test(test, lib_dir):
56536:     env = os.environ.copy()
56536:     if test.tmflags:
56536:         env['TMFLAGS'] = test.tmflags
56536:     cmd = get_test_cmd(test.path, test.jitflags, lib_dir)
56536: 
56536:     if (test.valgrind and
56536:         any([os.path.exists(os.path.join(d, 'valgrind'))
56536:              for d in os.environ['PATH'].split(os.pathsep)])):
56536:         valgrind_prefix = [ 'valgrind',
56536:                             '-q',
56536:                             '--smc-check=all',
56536:                             '--error-exitcode=1',
56536:                             '--leak-check=full']
56536:         if os.uname()[0] == 'Darwin':
56536:             valgrind_prefix += ['--dsymutil=yes']
56536:         cmd = valgrind_prefix + cmd
56536: 
56536:     if OPTIONS.show_cmd:
56536:         print(subprocess.list2cmdline(cmd))
56536: 
56536:     if OPTIONS.avoid_stdio:
56536:         out, err, code = run_cmd_avoid_stdio(cmd, env)
56536:     else:
56536:         out, err, code = run_cmd(cmd, env)
56536: 
56536:     if OPTIONS.show_output:
56536:         sys.stdout.write(out)
56536:         sys.stdout.write(err)
56536:         sys.stdout.write('Exit code: %s\n' % code)
56536:     if test.valgrind:
56536:         sys.stdout.write(err)
56536:     return (check_output(out, err, code, test.allow_oom, test.error), 
56536:             out, err, code)
56536: 
56536: def check_output(out, err, rc, allow_oom, expectedError):
56536:     if expectedError:
56536:         return expectedError in err
56536: 
56536:     for line in out.split('\n'):
56536:         if line.startswith('Trace stats check failed'):
56536:             return False
56536: 
56536:     for line in err.split('\n'):
56536:         if 'Assertion failed:' in line:
56536:             return False
56536: 
56536:     if rc != 0:
56536:         # Allow a non-zero exit code if we want to allow OOM, but only if we
56536:         # actually got OOM.
56536:         return allow_oom and ': out of memory' in err
56536: 
56536:     return True
56536: 
56536: def run_tests(tests, test_dir, lib_dir):
56536:     pb = None
56536:     if not OPTIONS.hide_progress and not OPTIONS.show_cmd:
56536:         try:
56536:             from progressbar import ProgressBar
56536:             pb = ProgressBar('', len(tests), 16)
56536:         except ImportError:
56536:             pass
56536: 
56536:     failures = []
56536:     complete = False
56536:     doing = 'before starting'
56536:     try:
56536:         for i, test in enumerate(tests):
56536:             doing = 'on %s'%test.path
56536:             ok, out, err, code = run_test(test, lib_dir)
56536:             doing = 'after %s'%test.path
56536: 
56536:             if not ok:
56536:                 failures.append([ test, out, err, code ])
56536: 
56536:             if OPTIONS.tinderbox:
56536:                 if ok:
56539:                     print('TEST-PASS | jit_test.py | %s'%test.path)
56536:                 else:
56536:                     lines = [ _ for _ in out.split('\n') + err.split('\n')
56536:                               if _ != '' ]
56536:                     if len(lines) >= 1:
56536:                         msg = lines[-1]
56536:                     else:
56536:                         msg = ''
56539:                     print('TEST-UNEXPECTED-FAIL | jit_test.py | %s: %s'%
56536:                           (test.path, msg))
56536: 
56536:             n = i + 1
56536:             if pb:
56536:                 pb.label = '[%4d|%4d|%4d]'%(n - len(failures), len(failures), n)
56536:                 pb.update(n)
56536:         complete = True
56536:     except KeyboardInterrupt:
56539:         print('TEST-UNEXPECTED_FAIL | jit_test.py | %s'%test.path)
56536: 
56536:     if pb:
56536:         pb.finish()
56536: 
56536:     if failures:
56536:         if OPTIONS.write_failures:
56536:             try:
56536:                 out = open(OPTIONS.write_failures, 'w')
56536:                 # Don't write duplicate entries when we are doing multiple failures per job.
56536:                 written = set()
56536:                 for test, fout, ferr, fcode in failures:
56536:                     if test.path not in written:
56536:                         out.write(os.path.relpath(test.path, test_dir) + '\n')
56536:                         if OPTIONS.write_failure_output:
56536:                             out.write(fout)
56536:                             out.write(ferr)
56536:                             out.write('Exit code: ' + str(fcode) + "\n")
56536:                         written.add(test.path)
56536:                 out.close()
56536:             except IOError:
56536:                 sys.stderr.write("Exception thrown trying to write failure file '%s'\n"%
56536:                                  OPTIONS.write_failures)
56536:                 traceback.print_exc()
56536:                 sys.stderr.write('---\n')
56536: 
56536:         print('FAILURES:')
56536:         for test, _, __, ___ in failures:
56536:             if OPTIONS.show_failed:
56536:                 print('    ' + subprocess.list2cmdline(get_test_cmd(test.path, test.jitflags, lib_dir)))
56536:             else:
56536:                 print('    ' + ' '.join(test.jitflags + [ test.path ]))
56536:         return False
56536:     else:
56536:         print('PASSED ALL' + ('' if complete else ' (partial run -- interrupted by user %s)'%doing))
56536:         return True
56536: 
56536: def parse_jitflags():
56536:     jitflags = [ [ '-' + flag for flag in flags ] 
56536:                  for flags in OPTIONS.jitflags.split(',') ]
56536:     for flags in jitflags:
56536:         for flag in flags:
56551:             if flag not in ('-j', '-m', '-p', '-d'):
56536:                 print('Invalid jit flag: "%s"'%flag)
56536:                 sys.exit(1)
56536:     return jitflags
56536: 
56536: def platform_might_be_android():
56536:     try:
56536:         # The python package for SL4A provides an |android| module.
56536:         # If that module is present, we're likely in SL4A-python on
56536:         # device.  False positives and negatives are possible,
56536:         # however.
56536:         import android
56536:         return True
56536:     except ImportError:
56536:         return False
56536: 
56536: def stdio_might_be_broken():
56536:     return platform_might_be_android()
56536: 
56536: JS = None
56536: OPTIONS = None
56536: def main(argv):
56536:     global JS, OPTIONS
56536: 
56536:     script_path = os.path.abspath(__file__)
56536:     script_dir = os.path.dirname(script_path)
56536:     test_dir = os.path.join(script_dir, 'tests')
56536:     lib_dir = os.path.join(script_dir, 'lib')
56536: 
56536:     # The [TESTS] optional arguments are paths of test files relative
56539:     # to the jit-test/tests directory.
56536: 
56536:     from optparse import OptionParser
56536:     op = OptionParser(usage='%prog [options] JS_SHELL [TESTS]')
56536:     op.add_option('-s', '--show-cmd', dest='show_cmd', action='store_true',
56536:                   help='show js shell command run')
56536:     op.add_option('-f', '--show-failed-cmd', dest='show_failed', 
56536:                   action='store_true', help='show command lines of failed tests')
56536:     op.add_option('-o', '--show-output', dest='show_output', action='store_true',
56536:                   help='show output from js shell')
56536:     op.add_option('-x', '--exclude', dest='exclude', action='append',
56536:                   help='exclude given test dir or path')
56536:     op.add_option('--no-slow', dest='run_slow', action='store_false',
56536:                   help='do not run tests marked as slow')
56536:     op.add_option('--no-progress', dest='hide_progress', action='store_true',
56536:                   help='hide progress bar')
56536:     op.add_option('--tinderbox', dest='tinderbox', action='store_true',
56536:                   help='Tinderbox-parseable output format')
56536:     op.add_option('-w', '--write-failures', dest='write_failures', metavar='FILE',
56536:                   help='Write a list of failed tests to [FILE]')
56536:     op.add_option('-r', '--read-tests', dest='read_tests', metavar='FILE',
56536:                   help='Run test files listed in [FILE]')
56536:     op.add_option('-R', '--retest', dest='retest', metavar='FILE',
56536:                   help='Retest using test list file [FILE]')
56536:     op.add_option('-g', '--debug', dest='debug', action='store_true',
56536:                   help='Run test in gdb')
56536:     op.add_option('--valgrind', dest='valgrind', action='store_true',
56536:                   help='Enable the |valgrind| flag, if valgrind is in $PATH.')
56536:     op.add_option('--valgrind-all', dest='valgrind_all', action='store_true',
56536:                   help='Run all tests with valgrind, if valgrind is in $PATH.')
59935:     op.add_option('--jitflags', dest='jitflags', default='mjp',
59935:                   help='Example: --jitflags=j,mj,mjp to run each test with -j, -m -j, -m -j -p [default=%default]')
56536:     op.add_option('--avoid-stdio', dest='avoid_stdio', action='store_true',
56536:                   help='Use js-shell file indirection instead of piping stdio.')
56536:     op.add_option('--write-failure-output', dest='write_failure_output', action='store_true',
56536:                   help='With --write-failures=FILE, additionally write the output of failed tests to [FILE]')
56536:     (OPTIONS, args) = op.parse_args(argv)
56536:     if len(args) < 1:
56536:         op.error('missing JS_SHELL argument')
56536:     # We need to make sure we are using backslashes on Windows.
56536:     JS, test_args = os.path.normpath(args[0]), args[1:]
56536:     JS = os.path.realpath(JS) # Burst through the symlinks!
56536: 
56536:     if stdio_might_be_broken():
56536:         # Prefer erring on the side of caution and not using stdio if
56536:         # it might be broken on this platform.  The file-redirect
56536:         # fallback should work on any platform, so at worst by
56536:         # guessing wrong we might have slowed down the tests a bit.
56536:         #
56536:         # XXX technically we could check for broken stdio, but it
56536:         # really seems like overkill.
56536:         OPTIONS.avoid_stdio = True
56536: 
56536:     if OPTIONS.retest:
56536:         OPTIONS.read_tests = OPTIONS.retest
56536:         OPTIONS.write_failures = OPTIONS.retest
56536: 
56536:     test_list = []
56536:     read_all = True
56536: 
56536:     if test_args:
56536:         read_all = False
56536:         for arg in test_args:
56536:             test_list += find_tests(test_dir, arg)
56536: 
56536:     if OPTIONS.read_tests:
56536:         read_all = False
56536:         try:
56536:             f = open(OPTIONS.read_tests)
56536:             for line in f:
56536:                 test_list.append(os.path.join(test_dir, line.strip('\n')))
56536:             f.close()
56536:         except IOError:
56536:             if OPTIONS.retest:
56536:                 read_all = True
56536:             else:
56536:                 sys.stderr.write("Exception thrown trying to read test file '%s'\n"%
56536:                                  OPTIONS.read_tests)
56536:                 traceback.print_exc()
56536:                 sys.stderr.write('---\n')
56536: 
56536:     if read_all:
56536:         test_list = find_tests(test_dir)
56536: 
56536:     if OPTIONS.exclude:
56536:         exclude_list = []
56536:         for exclude in OPTIONS.exclude:
56536:             exclude_list += find_tests(test_dir, exclude)
56536:         test_list = [ test for test in test_list if test not in set(exclude_list) ]
56536: 
56536:     if not test_list:
56536:         print >> sys.stderr, "No tests found matching command line arguments."
56536:         sys.exit(0)
56536: 
56536:     test_list = [ Test.from_file(_, OPTIONS) for _ in test_list ]
56536: 
56536:     if not OPTIONS.run_slow:
56536:         test_list = [ _ for _ in test_list if not _.slow ]
56536: 
56536:     # The full test list is ready. Now create copies for each JIT configuration.
56536:     job_list = []
56536:     jitflags_list = parse_jitflags()
56536:     for test in test_list:
56536:         for jitflags in jitflags_list:
56536:             new_test = test.copy()
62574:             new_test.jitflags.extend(jitflags)
56536:             job_list.append(new_test)
56536:     
56536: 
56536:     if OPTIONS.debug:
56536:         if len(job_list) > 1:
56536:             print('Multiple tests match command line arguments, debugger can only run one')
56536:             for tc in job_list:
56536:                 print('    %s'%tc.path)
56536:             sys.exit(1)
56536: 
56536:         tc = job_list[0]
56536:         cmd = [ 'gdb', '--args' ] + get_test_cmd(tc.path, tc.jitflags, lib_dir)
56536:         call(cmd)
56536:         sys.exit()
56536: 
56536:     try:
56536:         ok = run_tests(job_list, test_dir, lib_dir)
56536:         if not ok:
56536:             sys.exit(2)
56536:     except OSError:
56536:         if not os.path.exists(JS):
56536:             print >> sys.stderr, "JS shell argument: file does not exist: '%s'"%JS
56536:             sys.exit(1)
56536:         else:
56536:             raise
56536: 
56536: if __name__ == '__main__':
56536:     main(sys.argv[1:])
