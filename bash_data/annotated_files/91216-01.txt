    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * mozilla.org.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@pavlov.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
68492: #include "nsFontMetrics.h"
68487: #include "nsBoundingMetrics.h"
68492: #include "nsRenderingContext.h"
68667: #include "nsDeviceContext.h"
69311: #include "nsStyleConsts.h"
    1: 
68495: namespace {
68495: 
86690: class AutoTextRun {
68492: public:
68492:     AutoTextRun(nsFontMetrics* aMetrics, nsRenderingContext* aRC,
68495:                 const char* aString, PRInt32 aLength)
86690:     {
86690:         mTextRun = aMetrics->GetThebesFontGroup()->MakeTextRun(
68492:             reinterpret_cast<const PRUint8*>(aString), aLength,
86690:             aRC->ThebesContext(),
68492:             aMetrics->AppUnitsPerDevPixel(),
86690:             ComputeFlags(aMetrics));
86690:     }
68495: 
68492:     AutoTextRun(nsFontMetrics* aMetrics, nsRenderingContext* aRC,
68495:                 const PRUnichar* aString, PRInt32 aLength)
86690:     {
86690:         mTextRun = aMetrics->GetThebesFontGroup()->MakeTextRun(
86690:             aString, aLength,
68492:             aRC->ThebesContext(),
68492:             aMetrics->AppUnitsPerDevPixel(),
86690:             ComputeFlags(aMetrics));
86690:     }
86690: 
86690:     gfxTextRun *get() { return mTextRun; }
86690:     gfxTextRun *operator->() { return mTextRun; }
    1: 
68492: private:
68492:     static PRUint32 ComputeFlags(nsFontMetrics* aMetrics) {
68492:         PRUint32 flags = 0;
68496:         if (aMetrics->GetTextRunRTL()) {
68492:             flags |= gfxTextRunFactory::TEXT_IS_RTL;
68492:         }
68492:         return flags;
68492:     }
86690: 
86690:     nsAutoPtr<gfxTextRun> mTextRun;
68492: };
    1: 
68495: class StubPropertyProvider : public gfxTextRun::PropertyProvider {
68495: public:
68495:     virtual void GetHyphenationBreaks(PRUint32 aStart, PRUint32 aLength,
79445:                                       bool* aBreakBefore) {
68495:         NS_ERROR("This shouldn't be called because we never call BreakAndMeasureText");
68495:     }
69311:     virtual PRInt8 GetHyphensOption() {
69311:         NS_ERROR("This shouldn't be called because we never call BreakAndMeasureText");
69311:         return NS_STYLE_HYPHENS_NONE;
69311:     }
68495:     virtual gfxFloat GetHyphenWidth() {
68495:         NS_ERROR("This shouldn't be called because we never enable hyphens");
68495:         return 0;
68495:     }
68495:     virtual void GetSpacing(PRUint32 aStart, PRUint32 aLength,
68495:                             Spacing* aSpacing) {
68495:         NS_ERROR("This shouldn't be called because we never enable spacing");
68495:     }
68495: };
68495: 
68495: } // anon namespace
68495: 
68492: nsFontMetrics::nsFontMetrics()
80486:     : mDeviceContext(nsnull), mP2A(0), mTextRunRTL(false)
    1: {
    1: }
    1: 
68492: nsFontMetrics::~nsFontMetrics()
    1: {
31569:     if (mDeviceContext)
31569:         mDeviceContext->FontMetricsDeleted(this);
    1: }
    1: 
68492: nsresult
68492: nsFontMetrics::Init(const nsFont& aFont, nsIAtom* aLanguage,
68667:                     nsDeviceContext *aContext,
19962:                     gfxUserFontSet *aUserFontSet)
    1: {
75306:     NS_ABORT_IF_FALSE(mP2A == 0, "already initialized");
68496: 
    1:     mFont = aFont;
38492:     mLanguage = aLanguage;
68667:     mDeviceContext = aContext;
    1:     mP2A = mDeviceContext->AppUnitsPerDevPixel();
    1: 
68496:     gfxFontStyle style(aFont.style,
68496:                        aFont.weight,
68496:                        aFont.stretch,
68496:                        gfxFloat(aFont.size) / mP2A,
68496:                        aLanguage,
68496:                        aFont.sizeAdjust,
68496:                        aFont.systemFont,
68496:                        mDeviceContext->IsPrinterSurface(),
47359:                        aFont.featureSettings,
47359:                        aFont.languageOverride);
    1: 
68496:     mFontGroup = gfxPlatform::GetPlatform()->
68496:         CreateFontGroup(aFont.name, &style, aUserFontSet);
24104:     if (mFontGroup->FontListLength() < 1)
24104:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     return NS_OK;
    1: }
    1: 
68495: void
68492: nsFontMetrics::Destroy()
    1: {
31569:     mDeviceContext = nsnull;
    1: }
    1: 
    1: // XXXTODO get rid of this macro
    1: #define ROUND_TO_TWIPS(x) (nscoord)floor(((x) * mP2A) + 0.5)
75359: #define CEIL_TO_TWIPS(x) (nscoord)ceil((x) * mP2A)
    1: 
68492: const gfxFont::Metrics& nsFontMetrics::GetMetrics() const
    1: {
    1:     return mFontGroup->GetFontAt(0)->GetMetrics();
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::XHeight()
    1: {
68495:     return ROUND_TO_TWIPS(GetMetrics().xHeight);
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::SuperscriptOffset()
    1: {
68495:     return ROUND_TO_TWIPS(GetMetrics().superscriptOffset);
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::SubscriptOffset()
    1: {
68495:     return ROUND_TO_TWIPS(GetMetrics().subscriptOffset);
    1: }
    1: 
68495: void
68492: nsFontMetrics::GetStrikeout(nscoord& aOffset, nscoord& aSize)
    1: {
    1:     aOffset = ROUND_TO_TWIPS(GetMetrics().strikeoutOffset);
    1:     aSize = ROUND_TO_TWIPS(GetMetrics().strikeoutSize);
    1: }
    1: 
68495: void
68492: nsFontMetrics::GetUnderline(nscoord& aOffset, nscoord& aSize)
    1: {
13714:     aOffset = ROUND_TO_TWIPS(mFontGroup->GetUnderlineOffset());
    1:     aSize = ROUND_TO_TWIPS(GetMetrics().underlineSize);
    1: }
    1: 
68494: // GetMaxAscent/GetMaxDescent/GetMaxHeight must contain the
13714: // text-decoration lines drawable area. See bug 421353.
13714: // BE CAREFUL for rounding each values. The logic MUST be same as
13714: // nsCSSRendering::GetTextDecorationRectInternal's.
13714: 
13714: static gfxFloat ComputeMaxDescent(const gfxFont::Metrics& aMetrics,
13714:                                   gfxFontGroup* aFontGroup)
13714: {
75359:     gfxFloat offset = floor(-aFontGroup->GetUnderlineOffset() + 0.5);
13714:     gfxFloat size = NS_round(aMetrics.underlineSize);
75359:     gfxFloat minDescent = floor(offset + size + 0.5);
72496:     return NS_MAX(minDescent, aMetrics.maxDescent);
13714: }
13714: 
13714: static gfxFloat ComputeMaxAscent(const gfxFont::Metrics& aMetrics)
13714: {
75359:     return floor(aMetrics.maxAscent + 0.5);
13714: }
13714: 
68495: nscoord
68495: nsFontMetrics::InternalLeading()
    1: {
68495:     return ROUND_TO_TWIPS(GetMetrics().internalLeading);
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::ExternalLeading()
    1: {
68495:     return ROUND_TO_TWIPS(GetMetrics().externalLeading);
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::EmHeight()
    1: {
68495:     return ROUND_TO_TWIPS(GetMetrics().emHeight);
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::EmAscent()
    1: {
68495:     return ROUND_TO_TWIPS(GetMetrics().emAscent);
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::EmDescent()
    1: {
68495:     return ROUND_TO_TWIPS(GetMetrics().emDescent);
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::MaxHeight()
    1: {
68495:     return CEIL_TO_TWIPS(ComputeMaxAscent(GetMetrics())) +
13714:         CEIL_TO_TWIPS(ComputeMaxDescent(GetMetrics(), mFontGroup));
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::MaxAscent()
    1: {
68495:     return CEIL_TO_TWIPS(ComputeMaxAscent(GetMetrics()));
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::MaxDescent()
    1: {
68495:     return CEIL_TO_TWIPS(ComputeMaxDescent(GetMetrics(), mFontGroup));
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::MaxAdvance()
    1: {
68495:     return CEIL_TO_TWIPS(GetMetrics().maxAdvance);
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::AveCharWidth()
    1: {
68495:     // Use CEIL instead of ROUND for consistency with GetMaxAdvance
68495:     return CEIL_TO_TWIPS(GetMetrics().aveCharWidth);
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::SpaceWidth()
    1: {
68495:     return CEIL_TO_TWIPS(GetMetrics().spaceWidth);
    1: }
    1: 
    1: PRInt32
68492: nsFontMetrics::GetMaxStringLength()
    1: {
    1:     const gfxFont::Metrics& m = GetMetrics();
    1:     const double x = 32767.0 / m.maxAdvance;
    1:     PRInt32 len = (PRInt32)floor(x);
72496:     return NS_MAX(1, len);
    1: }
    1: 
68495: nscoord
68495: nsFontMetrics::GetWidth(const char* aString, PRUint32 aLength,
68481:                         nsRenderingContext *aContext)
    1: {
68495:     if (aLength == 0)
68495:         return 0;
    1: 
68495:     if (aLength == 1 && aString[0] == ' ')
68495:         return SpaceWidth();
    1: 
    1:     StubPropertyProvider provider;
 7715:     AutoTextRun textRun(this, aContext, aString, aLength);
91216:     return textRun.get() ?
91216:         NSToCoordRound(textRun->GetAdvanceWidth(0, aLength, &provider)) : 0;
    1: }
    1: 
68495: nscoord
68492: nsFontMetrics::GetWidth(const PRUnichar* aString, PRUint32 aLength,
68481:                         nsRenderingContext *aContext)
    1: {
68495:     if (aLength == 0)
68495:         return 0;
    1: 
68495:     if (aLength == 1 && aString[0] == ' ')
68495:         return SpaceWidth();
    1: 
    1:     StubPropertyProvider provider;
 7715:     AutoTextRun textRun(this, aContext, aString, aLength);
91216:     return textRun.get() ?
91216:         NSToCoordRound(textRun->GetAdvanceWidth(0, aLength, &provider)) : 0;
    1: }
    1: 
    1: // Draw a string using this font handle on the surface passed in.
68495: void
68492: nsFontMetrics::DrawString(const char *aString, PRUint32 aLength,
    1:                           nscoord aX, nscoord aY,
68481:                           nsRenderingContext *aContext)
    1: {
    1:     if (aLength == 0)
68495:         return;
    1: 
 7715:     StubPropertyProvider provider;
 7715:     AutoTextRun textRun(this, aContext, aString, aLength);
91216:     if (!textRun.get()) {
91216:         return;
91216:     }
    1:     gfxPoint pt(aX, aY);
    1:     if (mTextRunRTL) {
    1:         pt.x += textRun->GetAdvanceWidth(0, aLength, &provider);
    1:     }
89450:     textRun->Draw(aContext->ThebesContext(), pt, gfxFont::GLYPH_FILL, 0, aLength,
89450:                   &provider, nsnull, nsnull);
    1: }
    1: 
68495: void
68492: nsFontMetrics::DrawString(const PRUnichar* aString, PRUint32 aLength,
    1:                           nscoord aX, nscoord aY,
68481:                           nsRenderingContext *aContext,
68481:                           nsRenderingContext *aTextRunConstructionContext)
    1: {
    1:     if (aLength == 0)
68495:         return;
    1: 
 7715:     StubPropertyProvider provider;
60677:     AutoTextRun textRun(this, aTextRunConstructionContext, aString, aLength);
91216:     if (!textRun.get()) {
91216:         return;
91216:     }
    1:     gfxPoint pt(aX, aY);
    1:     if (mTextRunRTL) {
    1:         pt.x += textRun->GetAdvanceWidth(0, aLength, &provider);
    1:     }
89450:     textRun->Draw(aContext->ThebesContext(), pt, gfxFont::GLYPH_FILL, 0, aLength,
89450:                   &provider, nsnull, nsnull);
    1: }
    1: 
68495: nsBoundingMetrics
68492: nsFontMetrics::GetBoundingMetrics(const PRUnichar *aString, PRUint32 aLength,
68495:                                   nsRenderingContext *aContext)
    1: {
68495:     if (aLength == 0)
68495:         return nsBoundingMetrics();
 7835: 
68495:     StubPropertyProvider provider;
 7835:     AutoTextRun textRun(this, aContext, aString, aLength);
91216:     nsBoundingMetrics m;
91216:     if (textRun.get()) {
68494:         gfxTextRun::Metrics theMetrics =
68494:             textRun->MeasureText(0, aLength,
68494:                                  gfxFont::TIGHT_HINTED_OUTLINE_EXTENTS,
68494:                                  aContext->ThebesContext(), &provider);
68494: 
68495:         m.leftBearing  = NSToCoordFloor( theMetrics.mBoundingBox.X());
68495:         m.rightBearing = NSToCoordCeil(  theMetrics.mBoundingBox.XMost());
68495:         m.ascent       = NSToCoordCeil( -theMetrics.mBoundingBox.Y());
68495:         m.descent      = NSToCoordCeil(  theMetrics.mBoundingBox.YMost());
68495:         m.width        = NSToCoordRound( theMetrics.mAdvanceWidth);
91216:     }
68495:     return m;
    1: }
