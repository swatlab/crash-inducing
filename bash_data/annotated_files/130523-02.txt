     1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * Infrastructure for sharing DOMString data with JSStrings.
     1:  *
     1:  * Importing an nsAString into JS:
     1:  * If possible (GetSharedBufferHandle works) use the external string support in
     1:  * JS to create a JSString that points to the readable's buffer.  We keep a
     1:  * reference to the buffer handle until the JSString is finalized.
     1:  *
     1:  * Exporting a JSString as an nsAReadable:
     1:  * Wrap the JSString with a root-holding XPCJSReadableStringWrapper, which roots
     1:  * the string and exposes its buffer via the nsAString interface, as
     1:  * well as providing refcounting support.
     1:  */
     1: 
     1: #include "xpcprivate.h"
     1: #include "nsStringBuffer.h"
     1: 
110548: // One-slot cache, because it turns out it's common for web pages to
110548: // get the same string a few times in a row.  We get about a 40% cache
110548: // hit rate on this cache last it was measured.  We'd get about 70%
110548: // hit rate with a hashtable with removal on finalization, but that
110548: // would take a lot more machinery.
110548: static nsStringBuffer* sCachedBuffer = nullptr;
110548: static JSString* sCachedString = nullptr;
110548: 
130523: // Called from GC finalize callback to make sure we don't hand out a pointer to
130523: // a JSString that's about to be finalized by incremental sweeping.
130523: // static
130523: void
130523: XPCStringConvert::ClearCache()
130523: {
130523:     sCachedBuffer = nullptr;
130523:     sCachedString = nullptr;
130523: }
130523: 
 18907: static void
 89632: FinalizeDOMString(const JSStringFinalizer *fin, jschar *chars)
     1: {
110548:     nsStringBuffer* buf = nsStringBuffer::FromData(chars);
110548:     buf->Release();
     1: }
     1: 
 89632: static const JSStringFinalizer sDOMStringFinalizer = { FinalizeDOMString };
     1: 
     1: // convert a readable to a JSString, copying string data
     1: // static
 30306: jsval
 30306: XPCStringConvert::ReadableToJSVal(JSContext *cx,
 47921:                                   const nsAString &readable,
 49065:                                   nsStringBuffer** sharedBuffer)
     1: {
     1:     JSString *str;
106838:     *sharedBuffer = nullptr;
     1: 
108991:     uint32_t length = readable.Length();
     1: 
 87273:     if (length == 0)
 87273:         return JS_GetEmptyStringValue(cx);
 30306: 
     1:     nsStringBuffer *buf = nsStringBuffer::FromString(readable);
 80389:     if (buf) {
110548:         if (buf == sCachedBuffer &&
110548:             js::GetGCThingCompartment(sCachedString) == js::GetContextCompartment(cx)) {
110548:             // We're done.  Just return our existing string.
110548:             return JS::StringValue(sCachedString);
110548:         }
110548: 
     1:         // yay, we can share the string's buffer!
     1: 
     1:         str = JS_NewExternalString(cx,
  3233:                                    reinterpret_cast<jschar *>(buf->Data()),
 89632:                                    length, &sDOMStringFinalizer);
     1: 
 80389:         if (str) {
 49065:             *sharedBuffer = buf;
110548:             sCachedString = str;
110548:             sCachedBuffer = buf;
 47921:         }
 80390:     } else {
     1:         // blech, have to copy.
     1: 
  3233:         jschar *chars = reinterpret_cast<jschar *>
  3233:                                         (JS_malloc(cx, (length + 1) *
     1:                                                    sizeof(jschar)));
     1:         if (!chars)
 30306:             return JSVAL_NULL;
     1: 
     1:         if (length && !CopyUnicodeTo(readable, 0,
  3233:                                      reinterpret_cast<PRUnichar *>(chars),
 80389:                                      length)) {
     1:             JS_free(cx, chars);
 30306:             return JSVAL_NULL;
     1:         }
     1: 
     1:         chars[length] = 0;
     1: 
     1:         str = JS_NewUCString(cx, chars, length);
     1:         if (!str)
     1:             JS_free(cx, chars);
     1:     }
 80033:     return str ? STRING_TO_JSVAL(str) : JSVAL_NULL;
     1: }
