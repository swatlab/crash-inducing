 38166: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 38166:  * vim: sw=2 ts=2 et lcs=trail\:.,tab\:>~ :
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 38166: 
 48297: #include "mozilla/dom/ContentChild.h"
 48297: #include "mozilla/dom/ContentParent.h"
 48297: #include "nsXULAppAPI.h"
 48297: 
 38166: #include "History.h"
 38166: #include "nsNavHistory.h"
 47715: #include "nsNavBookmarks.h"
 87813: #include "nsAnnotationService.h"
 41398: #include "Helpers.h"
 60970: #include "PlaceInfo.h"
 60970: #include "VisitInfo.h"
 38166: 
 38166: #include "mozilla/storage.h"
 38166: #include "mozilla/dom/Link.h"
 38166: #include "nsDocShellCID.h"
 41398: #include "mozilla/Services.h"
 59333: #include "nsThreadUtils.h"
 59395: #include "nsNetUtil.h"
 61557: #include "nsIXPConnect.h"
 76840: #include "mozilla/unused.h"
 69685: #include "mozilla/Util.h"
 73972: #include "nsContentUtils.h"
 80308: #include "nsIMemoryReporter.h"
104136: #include "mozilla/Attributes.h"
109209: #include "mozilla/ipc/URIUtils.h"
 59333: 
 59333: // Initial size for the cache holding visited status observers.
 59333: #define VISIT_OBSERVERS_INITIAL_CACHE_SIZE 128
 38166: 
 38166: using namespace mozilla::dom;
109209: using namespace mozilla::ipc;
 76840: using mozilla::unused;
 38166: 
 38166: namespace mozilla {
 38166: namespace places {
 38166: 
 38166: ////////////////////////////////////////////////////////////////////////////////
 38477: //// Global Defines
 38477: 
 38477: #define URI_VISITED "visited"
 38477: #define URI_NOT_VISITED "not visited"
 38477: #define URI_VISITED_RESOLUTION_TOPIC "visited-status-resolution"
 47715: // Observer event fired after a visit has been registered in the DB.
 47715: #define URI_VISIT_SAVED "uri-visit-saved"
 47715: 
 87813: #define DESTINATIONFILEURI_ANNO \
 87813:         NS_LITERAL_CSTRING("downloads/destinationFileURI")
 87813: #define DESTINATIONFILENAME_ANNO \
 87813:         NS_LITERAL_CSTRING("downloads/destinationFileName")
 87813: 
 47715: ////////////////////////////////////////////////////////////////////////////////
 60950: //// VisitData
 60950: 
 60950: struct VisitData {
 60950:   VisitData()
 60950:   : placeId(0)
 60950:   , visitId(0)
 60950:   , sessionId(0)
 60950:   , hidden(true)
 60950:   , typed(false)
115367:   , transitionType(UINT32_MAX)
 60950:   , visitTime(0)
 94946:   , frecency(-1)
 61392:   , titleChanged(false)
 60950:   {
 80486:     guid.SetIsVoid(true);
 80486:     title.SetIsVoid(true);
 60950:   }
 60950: 
 60952:   VisitData(nsIURI* aURI,
 60952:             nsIURI* aReferrer = NULL)
 60950:   : placeId(0)
 60950:   , visitId(0)
 60950:   , sessionId(0)
 60950:   , hidden(true)
 60950:   , typed(false)
115367:   , transitionType(UINT32_MAX)
 60950:   , visitTime(0)
 94946:   , frecency(-1)
 61392:   , titleChanged(false)
 60950:   {
 60950:     (void)aURI->GetSpec(spec);
 60950:     (void)GetReversedHostname(aURI, revHost);
 60952:     if (aReferrer) {
 60952:       (void)aReferrer->GetSpec(referrerSpec);
 60952:     }
 80486:     guid.SetIsVoid(true);
 80486:     title.SetIsVoid(true);
 60950:   }
 60950: 
 60950:   /**
 94946:    * Sets the transition type of the visit, as well as if it was typed.
 60950:    *
 60950:    * @param aTransitionType
 60950:    *        The transition type constant to set.  Must be one of the
 60950:    *        TRANSITION_ constants on nsINavHistoryService.
 60950:    */
108991:   void SetTransitionType(uint32_t aTransitionType)
 60950:   {
 60950:     typed = aTransitionType == nsINavHistoryService::TRANSITION_TYPED;
 60950:     transitionType = aTransitionType;
 60950:   }
 60950: 
 60954:   /**
 60956:    * Determines if this refers to the same url as aOther, and updates aOther
 60956:    * with missing information if so.
 60954:    *
 60954:    * @param aOther
 60954:    *        The other place to check against.
 60954:    * @return true if this is a visit for the same place as aOther, false
 60954:    *         otherwise.
 60954:    */
 60956:   bool IsSamePlaceAs(VisitData& aOther)
 60954:   {
 60956:     if (!spec.Equals(aOther.spec)) {
 60956:       return false;
 60956:     }
 60956: 
 60956:     aOther.placeId = placeId;
 60956:     aOther.guid = guid;
 60956:     return true;
 60954:   }
 60954: 
108991:   int64_t placeId;
 60952:   nsCString guid;
108991:   int64_t visitId;
108991:   int64_t sessionId;
 60950:   nsCString spec;
 60950:   nsString revHost;
 60950:   bool hidden;
 60950:   bool typed;
108991:   uint32_t transitionType;
 60950:   PRTime visitTime;
108991:   int32_t frecency;
 61393: 
 61393:   /**
 61393:    * Stores the title.  If this is empty (IsEmpty() returns true), then the
 61393:    * title should be removed from the Place.  If the title is void (IsVoid()
 61393:    * returns true), then no title has been set on this object, and titleChanged
 61393:    * should remain false.
 61393:    */
 60951:   nsString title;
 61393: 
 60952:   nsCString referrerSpec;
 61392: 
 61392:   // TODO bug 626836 hook up hidden and typed change tracking too!
 61392:   bool titleChanged;
 60950: };
 60950: 
 60950: ////////////////////////////////////////////////////////////////////////////////
 38166: //// Anonymous Helpers
 38166: 
 38166: namespace {
 38166: 
 61385: /**
 61385:  * Obtains an nsIURI from the "uri" property of a JSObject.
 61385:  *
 61385:  * @param aCtx
 61385:  *        The JSContext for aObject.
 61385:  * @param aObject
 61385:  *        The JSObject to get the URI from.
 61385:  * @param aProperty
 61385:  *        The name of the property to get the URI from.
 61385:  * @return the URI if it exists.
 61385:  */
 61385: already_AddRefed<nsIURI>
 61385: GetURIFromJSObject(JSContext* aCtx,
 61385:                    JSObject* aObject,
 61385:                    const char* aProperty)
 61385: {
 61385:   jsval uriVal;
 61385:   JSBool rc = JS_GetProperty(aCtx, aObject, aProperty, &uriVal);
106838:   NS_ENSURE_TRUE(rc, nullptr);
 61557: 
 61385:   if (!JSVAL_IS_PRIMITIVE(uriVal)) {
 61844:     nsCOMPtr<nsIXPConnect> xpc = mozilla::services::GetXPConnect();
 61557: 
 61385:     nsCOMPtr<nsIXPConnectWrappedNative> wrappedObj;
 61557:     nsresult rv = xpc->GetWrappedNativeOfJSObject(aCtx, JSVAL_TO_OBJECT(uriVal),
 61557:                                                   getter_AddRefs(wrappedObj));
106838:     NS_ENSURE_SUCCESS(rv, nullptr);
 61385:     nsCOMPtr<nsIURI> uri = do_QueryWrappedNative(wrappedObj);
 61385:     return uri.forget();
 61385:   }
106838:   return nullptr;
 61385: }
 61385: 
 61385: /**
 61385:  * Obtains the specified property of a JSObject.
 61385:  *
 61385:  * @param aCtx
 61385:  *        The JSContext for aObject.
 61385:  * @param aObject
 61385:  *        The JSObject to get the string from.
 61385:  * @param aProperty
 61385:  *        The property to get the value from.
 61385:  * @param _string
 61385:  *        The string to populate with the value, or set it to void.
 61385:  */
 61385: void
 61385: GetStringFromJSObject(JSContext* aCtx,
 61385:                       JSObject* aObject,
 61385:                       const char* aProperty,
 61385:                       nsString& _string)
 61385: {
 61385:   jsval val;
 61385:   JSBool rc = JS_GetProperty(aCtx, aObject, aProperty, &val);
 61392:   if (!rc || JSVAL_IS_VOID(val) ||
 61392:       !(JSVAL_IS_NULL(val) || JSVAL_IS_STRING(val))) {
 80486:     _string.SetIsVoid(true);
 61385:     return;
 61385:   }
 61392:   // |null| in JS maps to the empty string.
 61392:   if (JSVAL_IS_NULL(val)) {
 61392:     _string.Truncate();
 61392:     return;
 61392:   }
 61385:   size_t length;
 61385:   const jschar* chars =
 61385:     JS_GetStringCharsZAndLength(aCtx, JSVAL_TO_STRING(val), &length);
 61385:   if (!chars) {
 80486:     _string.SetIsVoid(true);
 61385:     return;
 61385:   }
 61385:   _string.Assign(static_cast<const PRUnichar*>(chars), length);
 61385: }
 61385: 
 61385: /**
 61385:  * Obtains the specified property of a JSObject.
 61385:  *
 61385:  * @param aCtx
 61385:  *        The JSContext for aObject.
 61385:  * @param aObject
 61385:  *        The JSObject to get the int from.
 61385:  * @param aProperty
 61385:  *        The property to get the value from.
 61385:  * @param _int
 61385:  *        The integer to populate with the value on success.
 61385:  */
 61385: template <typename IntType>
 61385: nsresult
 61385: GetIntFromJSObject(JSContext* aCtx,
 61385:                    JSObject* aObject,
 61385:                    const char* aProperty,
 61385:                    IntType* _int)
 61385: {
 61385:   jsval value;
 61385:   JSBool rc = JS_GetProperty(aCtx, aObject, aProperty, &value);
 61385:   NS_ENSURE_TRUE(rc, NS_ERROR_UNEXPECTED);
 61385:   if (JSVAL_IS_VOID(value)) {
 61385:     return NS_ERROR_INVALID_ARG;
 61385:   }
 61385:   NS_ENSURE_ARG(JSVAL_IS_PRIMITIVE(value));
 61385:   NS_ENSURE_ARG(JSVAL_IS_NUMBER(value));
 61385: 
 90955:   double num;
 61385:   rc = JS_ValueToNumber(aCtx, value, &num);
 61385:   NS_ENSURE_TRUE(rc, NS_ERROR_UNEXPECTED);
 61385:   NS_ENSURE_ARG(IntType(num) == num);
 61385: 
 61385:   *_int = IntType(num);
 61385:   return NS_OK;
 61385: }
 61385: 
 61385: /**
 61385:  * Obtains the specified property of a JSObject.
 61385:  *
 61385:  * @pre aArray must be an Array object.
 61385:  *
 61385:  * @param aCtx
 61385:  *        The JSContext for aArray.
 61385:  * @param aArray
 61385:  *        The JSObject to get the object from.
 61385:  * @param aIndex
 61385:  *        The index to get the object from.
 61385:  * @param _object
 61385:  *        The JSObject pointer on success.
 61385:  */
 61385: nsresult
 61385: GetJSObjectFromArray(JSContext* aCtx,
 61385:                      JSObject* aArray,
 91688:                      uint32_t aIndex,
 61385:                      JSObject** _rooter)
 61385: {
 61385:   NS_PRECONDITION(JS_IsArrayObject(aCtx, aArray),
 61385:                   "Must provide an object that is an array!");
 61385: 
 61385:   jsval value;
 61385:   JSBool rc = JS_GetElement(aCtx, aArray, aIndex, &value);
 61385:   NS_ENSURE_TRUE(rc, NS_ERROR_UNEXPECTED);
 61385:   NS_ENSURE_ARG(!JSVAL_IS_PRIMITIVE(value));
 61385:   *_rooter = JSVAL_TO_OBJECT(value);
 61385:   return NS_OK;
 61385: }
 61385: 
 59300: class VisitedQuery : public AsyncStatementCallback
 38166: {
 38166: public:
 82965:   static nsresult Start(nsIURI* aURI,
106838:                         mozIVisitedStatusCallback* aCallback=nullptr)
 38166:   {
 47715:     NS_PRECONDITION(aURI, "Null URI");
 38166: 
 48297:   // If we are a content process, always remote the request to the
 48297:   // parent process.
 48297:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
109209:     URIParams uri;
109209:     SerializeURI(aURI, uri);
109209: 
 48297:     mozilla::dom::ContentChild* cpc =
 48297:       mozilla::dom::ContentChild::GetSingleton();
 48297:     NS_ASSERTION(cpc, "Content Protocol is NULL!");
109209:     (void)cpc->SendStartVisitedQuery(uri);
 48297:     return NS_OK;
 48297:   }
 48297: 
 59333:     nsNavHistory* navHistory = nsNavHistory::GetHistoryService();
 59333:     NS_ENSURE_STATE(navHistory);
 59333:     if (navHistory->hasEmbedVisit(aURI)) {
 82965:       nsRefPtr<VisitedQuery> callback = new VisitedQuery(aURI, aCallback, true);
 59333:       NS_ENSURE_TRUE(callback, NS_ERROR_OUT_OF_MEMORY);
 59333:       // As per IHistory contract, we must notify asynchronously.
 59333:       nsCOMPtr<nsIRunnable> event =
 59333:         NS_NewRunnableMethod(callback, &VisitedQuery::NotifyVisitedStatus);
 59333:       NS_DispatchToMainThread(event);
 59333: 
 59333:       return NS_OK;
 59333:     }
 59333: 
 82165:     History* history = History::GetService();
 82165:     NS_ENSURE_STATE(history);
 82165:     mozIStorageAsyncStatement* stmt = history->GetIsVisitedStatement();
 38166:     NS_ENSURE_STATE(stmt);
 38166: 
 41398:     // Bind by index for performance.
 41398:     nsresult rv = URIBinder::Bind(stmt, 0, aURI);
 38166:     NS_ENSURE_SUCCESS(rv, rv);
 38166: 
 82965:     nsRefPtr<VisitedQuery> callback = new VisitedQuery(aURI, aCallback);
 38166:     NS_ENSURE_TRUE(callback, NS_ERROR_OUT_OF_MEMORY);
 38166: 
 38166:     nsCOMPtr<mozIStoragePendingStatement> handle;
 38166:     return stmt->ExecuteAsync(callback, getter_AddRefs(handle));
 38166:   }
 38166: 
 38166:   NS_IMETHOD HandleResult(mozIStorageResultSet* aResults)
 38166:   {
 38166:     // If this method is called, we've gotten results, which means we have a
 38166:     // visit.
 38166:     mIsVisited = true;
 38166:     return NS_OK;
 38166:   }
 38166: 
 38166:   NS_IMETHOD HandleError(mozIStorageError* aError)
 38166:   {
 38166:     // mIsVisited is already set to false, and that's the assumption we will
 38166:     // make if an error occurred.
 38166:     return NS_OK;
 38166:   }
 38166: 
108991:   NS_IMETHOD HandleCompletion(uint16_t aReason)
 38166:   {
 49687:     if (aReason != mozIStorageStatementCallback::REASON_FINISHED) {
 49687:       return NS_OK;
 49687:     }
 49687: 
 59333:     nsresult rv = NotifyVisitedStatus();
 59333:     NS_ENSURE_SUCCESS(rv, rv);
 59333:     return NS_OK;
 59333:   }
 59333: 
 59333:   nsresult NotifyVisitedStatus()
 59333:   {
 82965:     // If an external handling callback is provided, just notify through it.
 82965:     if (mCallback) {
 82965:       mCallback->IsVisited(mURI, mIsVisited);
 82965:       return NS_OK;
 82965:     }
 82965: 
 46955:     if (mIsVisited) {
 82165:       History* history = History::GetService();
 82165:       NS_ENSURE_STATE(history);
 82165:       history->NotifyVisited(mURI);
 46955:     }
 46955: 
 46955:     nsCOMPtr<nsIObserverService> observerService =
 41398:       mozilla::services::GetObserverService();
 46955:     if (observerService) {
 46955:       nsAutoString status;
 46955:       if (mIsVisited) {
 46955:         status.AssignLiteral(URI_VISITED);
 46955:       }
 46955:       else {
 46955:         status.AssignLiteral(URI_NOT_VISITED);
 46955:       }
 46955:       (void)observerService->NotifyObservers(mURI,
 46955:                                              URI_VISITED_RESOLUTION_TOPIC,
 46955:                                              status.get());
 46955:     }
 46955: 
 38166:     return NS_OK;
 38166:   }
 59333: 
 38166: private:
 82965:   VisitedQuery(nsIURI* aURI,
106838:                mozIVisitedStatusCallback *aCallback=nullptr,
 82965:                bool aIsVisited=false)
 38166:   : mURI(aURI)
 82965:   , mCallback(aCallback)
 59333:   , mIsVisited(aIsVisited)
 38166:   {
 38166:   }
 38166: 
 38166:   nsCOMPtr<nsIURI> mURI;
 82965:   nsCOMPtr<mozIVisitedStatusCallback> mCallback;
 38166:   bool mIsVisited;
 38166: };
 38166: 
 59320: /**
 59320:  * Notifies observers about a visit.
 59320:  */
 59320: class NotifyVisitObservers : public nsRunnable
 59320: {
 59320: public:
 59320:   NotifyVisitObservers(VisitData& aPlace,
 59320:                        VisitData& aReferrer)
 59320:   : mPlace(aPlace)
 59320:   , mReferrer(aReferrer)
 89225:   , mHistory(History::GetService())
 59320:   {
 59320:   }
 59320: 
 59320:   NS_IMETHOD Run()
 59320:   {
 59333:     NS_PRECONDITION(NS_IsMainThread(),
 59333:                     "This should be called on the main thread");
 89225:     // We are in the main thread, no need to lock.
 89225:     if (mHistory->IsShuttingDown()) {
 89225:       // If we are shutting down, we cannot notify the observers.
 89225:       return NS_OK;
 89225:     }
 59333: 
 59333:     nsNavHistory* navHistory = nsNavHistory::GetHistoryService();
 59333:     if (!navHistory) {
 59320:       NS_WARNING("Trying to notify about a visit but cannot get the history service!");
 59320:       return NS_OK;
 59320:     }
 59320: 
 59342:     nsCOMPtr<nsIURI> uri;
 59342:     (void)NS_NewURI(getter_AddRefs(uri), mPlace.spec);
 59342: 
 59320:     // Notify nsNavHistory observers of visit, but only for certain types of
 59320:     // visits to maintain consistency with nsNavHistory::GetQueryResults.
 59320:     if (!mPlace.hidden &&
 59320:         mPlace.transitionType != nsINavHistoryService::TRANSITION_EMBED &&
 59320:         mPlace.transitionType != nsINavHistoryService::TRANSITION_FRAMED_LINK) {
 59342:       navHistory->NotifyOnVisit(uri, mPlace.visitId, mPlace.visitTime,
 59320:                                 mPlace.sessionId, mReferrer.visitId,
 71492:                                 mPlace.transitionType, mPlace.guid);
 59320:     }
 59320: 
 59320:     nsCOMPtr<nsIObserverService> obsService =
 59320:       mozilla::services::GetObserverService();
 59320:     if (obsService) {
 69685:       DebugOnly<nsresult> rv =
106838:         obsService->NotifyObservers(uri, URI_VISIT_SAVED, nullptr);
 59320:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not notify observers");
 59320:     }
 59320: 
 82165:     History* history = History::GetService();
 82165:     NS_ENSURE_STATE(history);
 94298:     history->AppendToRecentlyVisitedURIs(uri);
 82165:     history->NotifyVisited(uri);
 59324: 
 59320:     return NS_OK;
 59320:   }
 59320: private:
 59324:   VisitData mPlace;
 59324:   VisitData mReferrer;
 89225:   nsRefPtr<History> mHistory;
 59320: };
 59320: 
 59320: /**
 61392:  * Notifies observers about a pages title changing.
 61392:  */
 61392: class NotifyTitleObservers : public nsRunnable
 61392: {
 61392: public:
 61392:   /**
 61392:    * Notifies observers on the main thread.
 61392:    *
 61392:    * @param aSpec
 61392:    *        The spec of the URI to notify about.
 61392:    * @param aTitle
 61392:    *        The new title to notify about.
 61392:    */
 61392:   NotifyTitleObservers(const nsCString& aSpec,
 72844:                        const nsString& aTitle,
 72844:                        const nsCString& aGUID)
 61392:   : mSpec(aSpec)
 61392:   , mTitle(aTitle)
 72844:   , mGUID(aGUID)
 61392:   {
 61392:   }
 61392: 
 61392:   NS_IMETHOD Run()
 61392:   {
 61392:     NS_PRECONDITION(NS_IsMainThread(),
 61392:                     "This should be called on the main thread");
 61392: 
 61392:     nsNavHistory* navHistory = nsNavHistory::GetHistoryService();
 61392:     NS_ENSURE_TRUE(navHistory, NS_ERROR_OUT_OF_MEMORY);
 61392:     nsCOMPtr<nsIURI> uri;
 61392:     (void)NS_NewURI(getter_AddRefs(uri), mSpec);
 72844:     navHistory->NotifyTitleChange(uri, mTitle, mGUID);
 61392: 
 61392:     return NS_OK;
 61392:   }
 61392: private:
 61392:   const nsCString mSpec;
 61392:   const nsString mTitle;
 72844:   const nsCString mGUID;
 61392: };
 61392: 
 61392: /**
 77030:  * Notifies a callback object when a visit has been handled.
 60966:  */
 77030: class NotifyVisitInfoCallback : public nsRunnable
 60966: {
 60966: public:
 77030:   NotifyVisitInfoCallback(mozIVisitInfoCallback* aCallback,
 60966:                           const VisitData& aPlace,
 60966:                           nsresult aResult)
 60966:   : mCallback(aCallback)
 60966:   , mPlace(aPlace)
 60966:   , mResult(aResult)
 60966:   {
 60966:     NS_PRECONDITION(aCallback, "Must pass a non-null callback!");
 60966:   }
 60966: 
 60966:   NS_IMETHOD Run()
 60966:   {
 60966:     NS_PRECONDITION(NS_IsMainThread(),
 60966:                     "This should be called on the main thread");
 60966: 
 60970:     nsCOMPtr<nsIURI> referrerURI;
 60970:     if (!mPlace.referrerSpec.IsEmpty()) {
 60970:       (void)NS_NewURI(getter_AddRefs(referrerURI), mPlace.referrerSpec);
 60970:     }
 60970: 
 60970:     nsCOMPtr<mozIVisitInfo> visit =
 60970:       new VisitInfo(mPlace.visitId, mPlace.visitTime, mPlace.transitionType,
 60970:                     referrerURI.forget(), mPlace.sessionId);
 60970:     PlaceInfo::VisitsArray visits;
 60970:     (void)visits.AppendElement(visit);
 60970: 
 60970:     nsCOMPtr<nsIURI> uri;
 60970:     (void)NS_NewURI(getter_AddRefs(uri), mPlace.spec);
 60970: 
 60970:     // We do not notify about the frecency of the place.
 60970:     nsCOMPtr<mozIPlaceInfo> place =
 60970:       new PlaceInfo(mPlace.placeId, mPlace.guid, uri.forget(), mPlace.title,
 60970:                     -1, visits);
 75087:     if (NS_SUCCEEDED(mResult)) {
 75087:       (void)mCallback->HandleResult(place);
 75087:     }
 75087:     else {
 75087:       (void)mCallback->HandleError(mResult, place);
 75087:     }
 60970: 
 60966:     return NS_OK;
 60966:   }
 60966: 
 60966: private:
 60966:   /**
 60967:    * Callers MUST hold a strong reference to this that outlives us because we
 60967:    * may be created off of the main thread, and therefore cannot call AddRef on
 60967:    * this object (and therefore cannot hold a strong reference to it).
 60966:    */
 60966:   mozIVisitInfoCallback* mCallback;
 60966:   VisitData mPlace;
 60966:   const nsresult mResult;
 60966: };
 60966: 
 60966: /**
 77033:  * Notifies a callback object when the operation is complete.
 77033:  */
 77033: class NotifyCompletion : public nsRunnable
 77033: {
 77033: public:
 77033:   NotifyCompletion(mozIVisitInfoCallback* aCallback)
 77033:   : mCallback(aCallback)
 77033:   {
 77033:     NS_PRECONDITION(aCallback, "Must pass a non-null callback!");
 77033:   }
 77033: 
 77033:   NS_IMETHOD Run()
 77033:   {
 77033:     if (NS_IsMainThread()) {
 77033:       (void)mCallback->HandleCompletion();
 77033:     }
 77033:     else {
 77033:       (void)NS_DispatchToMainThread(this);
 77033: 
 77033:       // Also dispatch an event to release the reference to the callback after
 77033:       // we have run.
 77033:       nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
 80486:       (void)NS_ProxyRelease(mainThread, mCallback, true);
 77033:     }
 77033:     return NS_OK;
 77033:   }
 77033: 
 77033: private:
 77033:   /**
 77033:    * Callers MUST hold a strong reference to this because we may be created
 77033:    * off of the main thread, and therefore cannot call AddRef on this object
 77033:    * (and therefore cannot hold a strong reference to it). If invoked from a
 77033:    * background thread, NotifyCompletion will release the reference to this.
 77033:    */
 77033:   mozIVisitInfoCallback* mCallback;
 77033: };
 77033: 
 77033: /**
 61387:  * Checks to see if we can add aURI to history, and dispatches an error to
 61387:  * aCallback (if provided) if we cannot.
 61387:  *
 61387:  * @param aURI
 61387:  *        The URI to check.
 61387:  * @param [optional] aGUID
 61387:  *        The guid of the URI to check.  This is passed back to the callback.
 61387:  * @param [optional] aCallback
 61387:  *        The callback to notify if the URI cannot be added to history.
 61387:  * @return true if the URI can be added to history, false otherwise.
 61387:  */
 61387: bool
 61387: CanAddURI(nsIURI* aURI,
 61387:           const nsCString& aGUID = EmptyCString(),
 61387:           mozIVisitInfoCallback* aCallback = NULL)
 61387: {
 61387:   nsNavHistory* navHistory = nsNavHistory::GetHistoryService();
 61387:   NS_ENSURE_TRUE(navHistory, false);
 61387: 
 79445:   bool canAdd;
 61387:   nsresult rv = navHistory->CanAddURI(aURI, &canAdd);
 61387:   if (NS_SUCCEEDED(rv) && canAdd) {
 61387:     return true;
 61387:   };
 61387: 
 61387:   // We cannot add the URI.  Notify the callback, if we were given one.
 61387:   if (aCallback) {
 77030:     // NotifyVisitInfoCallback does not hold a strong reference to the callback, so we
 61387:     // have to manage it by AddRefing now and then releasing it after the event
 61387:     // has run.
 61387:     NS_ADDREF(aCallback);
 61387: 
 61387:     VisitData place(aURI);
 61387:     place.guid = aGUID;
 61387:     nsCOMPtr<nsIRunnable> event =
 77030:       new NotifyVisitInfoCallback(aCallback, place, NS_ERROR_INVALID_ARG);
 61387:     (void)NS_DispatchToMainThread(event);
 61387: 
 61387:     // Also dispatch an event to release our reference to the callback after
 77030:     // NotifyVisitInfoCallback has run.
 61387:     nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
 80486:     (void)NS_ProxyRelease(mainThread, aCallback, true);
 61387:   }
 61387: 
 61387:   return false;
 61387: }
 61387: 
 61387: /**
 59320:  * Adds a visit to the database.
 59320:  */
 60954: class InsertVisitedURIs : public nsRunnable
 59320: {
 59320: public:
 59320:   /**
 59320:    * Adds a visit to the database asynchronously.
 59320:    *
 59322:    * @param aConnection
 59322:    *        The database connection to use for these operations.
 60954:    * @param aPlaces
 60954:    *        The locations to record visits.
 60966:    * @param [optional] aCallback
 60966:    *        The callback to notify about the visit.
 59320:    */
 59322:   static nsresult Start(mozIStorageConnection* aConnection,
 60966:                         nsTArray<VisitData>& aPlaces,
 60966:                         mozIVisitInfoCallback* aCallback = NULL)
 59320:   {
 59320:     NS_PRECONDITION(NS_IsMainThread(),
 59320:                     "This should be called on the main thread");
 60954:     NS_PRECONDITION(aPlaces.Length() > 0, "Must pass a non-empty array!");
 59320: 
 60954:     nsRefPtr<InsertVisitedURIs> event =
 60966:       new InsertVisitedURIs(aConnection, aPlaces, aCallback);
 59320: 
 59320:     // Get the target thread, and then start the work!
 59322:     nsCOMPtr<nsIEventTarget> target = do_GetInterface(aConnection);
 59322:     NS_ENSURE_TRUE(target, NS_ERROR_UNEXPECTED);
 59322:     nsresult rv = target->Dispatch(event, NS_DISPATCH_NORMAL);
 59320:     NS_ENSURE_SUCCESS(rv, rv);
 59320: 
 59320:     return NS_OK;
 59320:   }
 59320: 
 59320:   NS_IMETHOD Run()
 59320:   {
 59320:     NS_PRECONDITION(!NS_IsMainThread(),
 59320:                     "This should not be called on the main thread");
 59320: 
 89225:     // Prevent the main thread from shutting down while this is running.
 89225:     MutexAutoLock lockedScope(mHistory->GetShutdownMutex());
 89225:     if(mHistory->IsShuttingDown()) {
 89225:       // If we were already shutting down, we cannot insert the URIs.
 89225:       return NS_OK;
 89225:     }
 89225: 
 80486:     mozStorageTransaction transaction(mDBConn, false,
 59338:                                       mozIStorageConnection::TRANSACTION_IMMEDIATE);
 60954: 
 60966:     VisitData* lastPlace = NULL;
 60954:     for (nsTArray<VisitData>::size_type i = 0; i < mPlaces.Length(); i++) {
 60954:       VisitData& place = mPlaces.ElementAt(i);
 60954:       VisitData& referrer = mReferrers.ElementAt(i);
 60954: 
 60954:       // We can avoid a database lookup if it's the same place as the last
 60954:       // visit we added.
 60954:       bool known = (lastPlace && lastPlace->IsSamePlaceAs(place)) ||
 60954:                    mHistory->FetchPageInfo(place);
 60954: 
 60954:       FetchReferrerInfo(referrer, place);
 60954: 
 60966:       nsresult rv = DoDatabaseInserts(known, place, referrer);
 60966:       if (mCallback) {
 60966:         nsCOMPtr<nsIRunnable> event =
 77030:           new NotifyVisitInfoCallback(mCallback, place, rv);
 60966:         nsresult rv2 = NS_DispatchToMainThread(event);
 60966:         NS_ENSURE_SUCCESS(rv2, rv2);
 59338:       }
 59320:       NS_ENSURE_SUCCESS(rv, rv);
 59320: 
 60954:       nsCOMPtr<nsIRunnable> event = new NotifyVisitObservers(place, referrer);
 60954:       rv = NS_DispatchToMainThread(event);
 59320:       NS_ENSURE_SUCCESS(rv, rv);
 59320: 
 61392:       // Notify about title change if needed.
 61392:       if ((!known && !place.title.IsVoid()) || place.titleChanged) {
 72844:         event = new NotifyTitleObservers(place.spec, place.title, place.guid);
 61392:         rv = NS_DispatchToMainThread(event);
 61392:         NS_ENSURE_SUCCESS(rv, rv);
 61392:       }
 61392: 
 60954:       lastPlace = &mPlaces.ElementAt(i);
 60954:     }
 60954: 
 60966:     nsresult rv = transaction.Commit();
 59320:     NS_ENSURE_SUCCESS(rv, rv);
 59320: 
 59320:     return NS_OK;
 59320:   }
 59320: private:
 60954:   InsertVisitedURIs(mozIStorageConnection* aConnection,
 60966:                     nsTArray<VisitData>& aPlaces,
 60966:                     mozIVisitInfoCallback* aCallback)
 59322:   : mDBConn(aConnection)
 60966:   , mCallback(aCallback)
 59322:   , mHistory(History::GetService())
 59320:   {
 60954:     NS_PRECONDITION(NS_IsMainThread(),
 60954:                     "This should be called on the main thread");
 60954: 
 60954:     (void)mPlaces.SwapElements(aPlaces);
 60954:     (void)mReferrers.SetLength(mPlaces.Length());
 60954: 
 60954:     nsNavHistory* navHistory = nsNavHistory::GetHistoryService();
 60954:     NS_ABORT_IF_FALSE(navHistory, "Could not get nsNavHistory?!");
 60954: 
 60954:     for (nsTArray<VisitData>::size_type i = 0; i < mPlaces.Length(); i++) {
 60954:       mReferrers[i].spec = mPlaces[i].referrerSpec;
 60954: 
 62168:       // If we are inserting a place into an empty mPlaces array, we need to
 62168:       // check to make sure we do not store a bogus session id that is higher
 62168:       // than the current maximum session id.
 62168:       if (i == 0) {
108991:         int64_t newSessionId = navHistory->GetNewSessionID();
 62168:         if (mPlaces[0].sessionId > newSessionId) {
 62168:           mPlaces[0].sessionId = newSessionId;
 62168:         }
 62168:       }
 62168: 
 60963:       // Speculatively get a new session id for our visit if the current session
 62168:       // id is non-valid or if it is larger than the current largest session id.
 62168:       // While it is true that we will use the session id from the referrer if
 62168:       // the visit was "recent" enough, we cannot call this method off of the
 62168:       // main thread, so we have to consume an id now.
 62168:       if (mPlaces[i].sessionId <= 0 ||
 62168:           (i > 0 && mPlaces[i].sessionId >= mPlaces[0].sessionId)) {
 60954:         mPlaces[i].sessionId = navHistory->GetNewSessionID();
 60954:       }
 61387: 
 61387: #ifdef DEBUG
 61387:       nsCOMPtr<nsIURI> uri;
 61387:       (void)NS_NewURI(getter_AddRefs(uri), mPlaces[i].spec);
 61387:       NS_ASSERTION(CanAddURI(uri),
 61387:                    "Passed a VisitData with a URI we cannot add to history!");
 61387: #endif
 59320:     }
 60966: 
 60966:     // We AddRef on the main thread, and release it when we are destroyed.
 60966:     NS_IF_ADDREF(mCallback);
 60966:   }
 60966: 
 60966:   virtual ~InsertVisitedURIs()
 60966:   {
 60966:     if (mCallback) {
 60966:       nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
 80486:       (void)NS_ProxyRelease(mainThread, mCallback, true);
 60966:     }
 60966:   }
 60966: 
 60966:   /**
 60966:    * Inserts or updates the entry in moz_places for this visit, adds the visit,
 60966:    * and updates the frecency of the place.
 60966:    *
 60966:    * @param aKnown
 60966:    *        True if we already have an entry for this place in moz_places, false
 60966:    *        otherwise.
 60966:    * @param aPlace
 60966:    *        The place we are adding a visit for.
 60966:    * @param aReferrer
 60966:    *        The referrer for aPlace.
 60966:    */
 60966:   nsresult DoDatabaseInserts(bool aKnown,
 60966:                              VisitData& aPlace,
 60966:                              VisitData& aReferrer)
 60966:   {
 60966:     NS_PRECONDITION(!NS_IsMainThread(),
 60966:                     "This should not be called on the main thread");
 60966: 
 60966:     // If the page was in moz_places, we need to update the entry.
 60966:     nsresult rv;
 60966:     if (aKnown) {
 60966:       rv = mHistory->UpdatePlace(aPlace);
 60966:       NS_ENSURE_SUCCESS(rv, rv);
 60966:     }
 60966:     // Otherwise, the page was not in moz_places, so now we have to add it.
 60966:     else {
 60966:       rv = mHistory->InsertPlace(aPlace);
 60966:       NS_ENSURE_SUCCESS(rv, rv);
 60986: 
 60986:       // We need the place id and guid of the page we just inserted when we
 71492:       // have a callback or when the GUID isn't known.  No point in doing the
 71492:       // disk I/O if we do not need it.
 71492:       if (mCallback || aPlace.guid.IsEmpty()) {
 60986:         bool exists = mHistory->FetchPageInfo(aPlace);
 60986:         if (!exists) {
 60986:           NS_NOTREACHED("should have an entry in moz_places");
 60986:         }
 60986:       }
 60966:     }
 60966: 
 60966:     rv = AddVisit(aPlace, aReferrer);
 60966:     NS_ENSURE_SUCCESS(rv, rv);
 60966: 
 60966:     // TODO (bug 623969) we shouldn't update this after each visit, but
 60966:     // rather only for each unique place to save disk I/O.
 60966:     rv = UpdateFrecency(aPlace);
 60966:     NS_ENSURE_SUCCESS(rv, rv);
 60966: 
 60966:     return NS_OK;
 60963:   }
 59320: 
 59320:   /**
 59320:    * Loads visit information about the page into _place.
 59320:    *
 59320:    * @param _place
 59320:    *        The VisitData for the place we need to know visit information about.
 59320:    * @param [optional] aThresholdStart
 59320:    *        The timestamp of a new visit (not represented by _place) used to
 59320:    *        determine if the page was recently visited or not.
 59320:    * @return true if the page was recently (determined with aThresholdStart)
 59320:    *         visited, false otherwise.
 59320:    */
 59320:   bool FetchVisitInfo(VisitData& _place,
 59320:                       PRTime aThresholdStart = 0)
 59320:   {
 59342:     NS_PRECONDITION(!_place.spec.IsEmpty(), "must have a non-empty spec!");
 59320: 
 60986:     nsCOMPtr<mozIStorageStatement> stmt;
 60986:     // If we have a visitTime, we want information on that specific visit.
 60986:     if (_place.visitTime) {
 80946:       stmt = mHistory->GetStatement(
 60986:         "SELECT id, session, visit_date "
 60986:         "FROM moz_historyvisits "
 60986:         "WHERE place_id = (SELECT id FROM moz_places WHERE url = :page_url) "
 60986:         "AND visit_date = :visit_date "
 60986:       );
 60986:       NS_ENSURE_TRUE(stmt, false);
 60986: 
 60986:       mozStorageStatementScoper scoper(stmt);
 60986:       nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("visit_date"),
 60986:                                           _place.visitTime);
111019:       NS_ENSURE_SUCCESS(rv, false);
 60986: 
 60986:       scoper.Abandon();
 60986:     }
 60986:     // Otherwise, we want information about the most recent visit.
 60986:     else {
 80946:       stmt = mHistory->GetStatement(
 59320:         "SELECT id, session, visit_date "
 59320:         "FROM moz_historyvisits "
 59320:         "WHERE place_id = (SELECT id FROM moz_places WHERE url = :page_url) "
 59320:         "ORDER BY visit_date DESC "
 59322:       );
 59322:       NS_ENSURE_TRUE(stmt, false);
 60986:     }
 59322:     mozStorageStatementScoper scoper(stmt);
 59320: 
 59322:     nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"),
 59342:                                   _place.spec);
 59320:     NS_ENSURE_SUCCESS(rv, false);
 59320: 
 79445:     bool hasResult;
 59320:     rv = stmt->ExecuteStep(&hasResult);
 59320:     NS_ENSURE_SUCCESS(rv, false);
 59320:     if (!hasResult) {
 59320:       return false;
 59320:     }
 59320: 
 59320:     rv = stmt->GetInt64(0, &_place.visitId);
 59320:     NS_ENSURE_SUCCESS(rv, false);
 59320:     rv = stmt->GetInt64(1, &_place.sessionId);
 59320:     NS_ENSURE_SUCCESS(rv, false);
110765:     rv = stmt->GetInt64(2, reinterpret_cast<int64_t*>(&_place.visitTime));
 59320:     NS_ENSURE_SUCCESS(rv, false);
 59320: 
 59320:     // If we have been given a visit threshold start time, go ahead and
 59320:     // calculate if we have been recently visited.
 59320:     if (aThresholdStart &&
 59320:         aThresholdStart - _place.visitTime <= RECENT_EVENT_THRESHOLD) {
 59320:       return true;
 59320:     }
 59320: 
 59320:     return false;
 59320:   }
 59320: 
 59320:   /**
 60953:    * Fetches information about a referrer and sets the session id for aPlace if
 60953:    * it was a recent visit or not.
 60953:    *
 60953:    * @param aReferrer
 60953:    *        The VisitData for the referrer.  This will be populated with
 60953:    *        FetchVisitInfo.
 60953:    * @param aPlace
 60953:    *        The VisitData for the visit we will eventually add.
 60953:    *
 60953:    */
 60953:   void FetchReferrerInfo(VisitData& aReferrer,
 60953:                          VisitData& aPlace)
 60953:   {
 60953:     if (aReferrer.spec.IsEmpty()) {
 60953:       return;
 60953:     }
 60953: 
 60953:     // If we had a referrer, we want to know about its last visit to put this
 60953:     // new visit into the same session.
 60953:     bool recentVisit = FetchVisitInfo(aReferrer, aPlace.visitTime);
 60953:     // At this point, we know the referrer's session id, which this new visit
 60953:     // should also share.
 60953:     if (recentVisit) {
 60953:       aPlace.sessionId = aReferrer.sessionId;
 60953:     }
 60953:     // However, if it isn't recent enough, we don't care to log anything about
 60953:     // the referrer and we'll start a new session.
 60953:     else {
 62682:       // We must change both the place and referrer to indicate that we will
 62682:       // not be using the referrer's data. This behavior has test coverage, so
 62682:       // if this invariant changes, we'll know.
 62682:       aPlace.referrerSpec.Truncate();
 60953:       aReferrer.visitId = 0;
 60953:     }
 60953:   }
 60953: 
 60953:   /**
 59320:    * Adds a visit for _place and updates it with the right visit id.
 59320:    *
 59320:    * @param _place
 59320:    *        The VisitData for the place we need to know visit information about.
 59320:    * @param aReferrer
 59320:    *        A reference to the referrer's visit data.
 59320:    */
 59320:   nsresult AddVisit(VisitData& _place,
 59320:                     const VisitData& aReferrer)
 59320:   {
 59338:     nsresult rv;
 59338:     nsCOMPtr<mozIStorageStatement> stmt;
 59338:     if (_place.placeId) {
 80946:       stmt = mHistory->GetStatement(
 59320:         "INSERT INTO moz_historyvisits "
 59320:           "(from_visit, place_id, visit_date, visit_type, session) "
 59320:         "VALUES (:from_visit, :page_id, :visit_date, :visit_type, :session) "
 59322:       );
 59322:       NS_ENSURE_STATE(stmt);
 60954:       rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), _place.placeId);
 59338:       NS_ENSURE_SUCCESS(rv, rv);
 59338:     }
 59338:     else {
 80946:       stmt = mHistory->GetStatement(
 59338:         "INSERT INTO moz_historyvisits "
 59338:           "(from_visit, place_id, visit_date, visit_type, session) "
 59338:         "VALUES (:from_visit, (SELECT id FROM moz_places WHERE url = :page_url), :visit_date, :visit_type, :session) "
 59338:       );
 59338:       NS_ENSURE_STATE(stmt);
 59342:       rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), _place.spec);
 59338:       NS_ENSURE_SUCCESS(rv, rv);
 59338:     }
 59338:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("from_visit"),
 59320:                                aReferrer.visitId);
 59320:     NS_ENSURE_SUCCESS(rv, rv);
 59320:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("visit_date"),
 59320:                                _place.visitTime);
 59320:     NS_ENSURE_SUCCESS(rv, rv);
108991:     uint32_t transitionType = _place.transitionType;
 59320:     NS_ASSERTION(transitionType >= nsINavHistoryService::TRANSITION_LINK &&
 59320:                  transitionType <= nsINavHistoryService::TRANSITION_FRAMED_LINK,
 59320:                  "Invalid transition type!");
 59320:     rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("visit_type"),
 59320:                                transitionType);
 59320:     NS_ENSURE_SUCCESS(rv, rv);
 59320:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("session"),
 59320:                                _place.sessionId);
 59320:     NS_ENSURE_SUCCESS(rv, rv);
 59320: 
 59338:     mozStorageStatementScoper scoper(stmt);
 59320:     rv = stmt->Execute();
 59320:     NS_ENSURE_SUCCESS(rv, rv);
 59320: 
 59320:     // Now that it should be in the database, we need to obtain the id of the
 60986:     // visit we just added.
 60986:     (void)FetchVisitInfo(_place);
 59320: 
 59320:     return NS_OK;
 59320:   }
 59320: 
 59320:   /**
 59320:    * Updates the frecency, and possibly the hidden-ness of aPlace.
 59320:    *
 59320:    * @param aPlace
 59320:    *        The VisitData for the place we want to update.
 59320:    */
 59320:   nsresult UpdateFrecency(const VisitData& aPlace)
 59320:   {
 94946:     // Don't update frecency if the page should not appear in autocomplete.
 94946:     if (aPlace.frecency == 0) {
 94946:       return NS_OK;
 94946:     }
 94946: 
 59338:     nsresult rv;
 59322:     { // First, set our frecency to the proper value.
 59338:       nsCOMPtr<mozIStorageStatement> stmt;
 59338:       if (aPlace.placeId) {
 80946:         stmt = mHistory->GetStatement(
 59320:           "UPDATE moz_places "
 59320:           "SET frecency = CALCULATE_FRECENCY(:page_id) "
 59320:           "WHERE id = :page_id"
 59322:         );
 59322:         NS_ENSURE_STATE(stmt);
 60954:         rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), aPlace.placeId);
 59338:         NS_ENSURE_SUCCESS(rv, rv);
 59338:       }
 59338:       else {
 80946:         stmt = mHistory->GetStatement(
 59338:           "UPDATE moz_places "
 59338:           "SET frecency = CALCULATE_FRECENCY(id) "
 59338:           "WHERE url = :page_url"
 59338:         );
 59338:         NS_ENSURE_STATE(stmt);
 59342:         rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), aPlace.spec);
 59338:         NS_ENSURE_SUCCESS(rv, rv);
 59338:       }
 59322:       mozStorageStatementScoper scoper(stmt);
 59320: 
 59320:       rv = stmt->Execute();
 59320:       NS_ENSURE_SUCCESS(rv, rv);
 59322:     }
 59320: 
 94946:     if (!aPlace.hidden) {
 94947:       // Mark the page as not hidden if the frecency is now nonzero.
 59338:       nsCOMPtr<mozIStorageStatement> stmt;
 59338:       if (aPlace.placeId) {
 80946:         stmt = mHistory->GetStatement(
 59320:           "UPDATE moz_places "
 59320:           "SET hidden = 0 "
 59320:           "WHERE id = :page_id AND frecency <> 0"
 59322:         );
 59322:         NS_ENSURE_STATE(stmt);
 60954:         rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), aPlace.placeId);
 59338:         NS_ENSURE_SUCCESS(rv, rv);
 59338:       }
 59338:       else {
 80946:         stmt = mHistory->GetStatement(
 59338:           "UPDATE moz_places "
 59338:           "SET hidden = 0 "
 59338:           "WHERE url = :page_url AND frecency <> 0"
 59338:         );
 59338:         NS_ENSURE_STATE(stmt);
 59342:         rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), aPlace.spec);
 59338:         NS_ENSURE_SUCCESS(rv, rv);
 59338:       }
 59338: 
 59322:       mozStorageStatementScoper scoper(stmt);
 59320:       rv = stmt->Execute();
 59320:       NS_ENSURE_SUCCESS(rv, rv);
 59322:     }
 59320: 
 59320:     return NS_OK;
 59320:   }
 59320: 
 59322:   mozIStorageConnection* mDBConn;
 59320: 
 60954:   nsTArray<VisitData> mPlaces;
 60954:   nsTArray<VisitData> mReferrers;
 59322: 
 59322:   /**
 60966:    * We own a strong reference to this, but in an indirect way.  We call AddRef
 60966:    * in our constructor, which happens on the main thread, and proxy the relase
 60966:    * of the object to the main thread in our destructor.
 60966:    */
 60966:   mozIVisitInfoCallback* mCallback;
 60966: 
 60966:   /**
 59322:    * Strong reference to the History object because we do not want it to
 59322:    * disappear out from under us.
 59322:    */
 59322:   nsRefPtr<History> mHistory;
 59320: };
 59320: 
 47715: /**
 59323:  * Sets the page title for a page in moz_places (if necessary).
 47716:  */
 59323: class SetPageTitle : public nsRunnable
 47716: {
 47716: public:
 59323:   /**
 59323:    * Sets a pages title in the database asynchronously.
 59323:    *
 59323:    * @param aConnection
 59323:    *        The database connection to use for this operation.
 59323:    * @param aURI
 59323:    *        The URI to set the page title on.
 59323:    * @param aTitle
 59323:    *        The title to set for the page, if the page exists.
 59323:    */
 59323:   static nsresult Start(mozIStorageConnection* aConnection,
 59323:                         nsIURI* aURI,
 61392:                         const nsAString& aTitle)
 47716:   {
 59323:     NS_PRECONDITION(NS_IsMainThread(),
 59323:                     "This should be called on the main thread");
 59342:     NS_PRECONDITION(aURI, "Must pass a non-null URI object!");
 47716: 
 59342:     nsCString spec;
 59342:     nsresult rv = aURI->GetSpec(spec);
 59342:     NS_ENSURE_SUCCESS(rv, rv);
 59342: 
 59342:     nsRefPtr<SetPageTitle> event = new SetPageTitle(spec, aTitle);
 47716: 
 59323:     // Get the target thread, and then start the work!
 59323:     nsCOMPtr<nsIEventTarget> target = do_GetInterface(aConnection);
 59323:     NS_ENSURE_TRUE(target, NS_ERROR_UNEXPECTED);
 59342:     rv = target->Dispatch(event, NS_DISPATCH_NORMAL);
 47716:     NS_ENSURE_SUCCESS(rv, rv);
 47716: 
 47716:     return NS_OK;
 47716:   }
 47716: 
 59323:   NS_IMETHOD Run()
 59323:   {
 59323:     NS_PRECONDITION(!NS_IsMainThread(),
 59323:                     "This should not be called on the main thread");
 47716: 
 59323:     // First, see if the page exists in the database (we'll need its id later).
 60951:     bool exists = mHistory->FetchPageInfo(mPlace);
 61392:     if (!exists || !mPlace.titleChanged) {
 61392:       // We have no record of this page, or we have no title change, so there
 61392:       // is no need to do any further work.
 59342:       return NS_OK;
 47716:     }
 47716: 
 60951:     NS_ASSERTION(mPlace.placeId > 0,
 60951:                  "We somehow have an invalid place id here!");
 59323: 
 59323:     // Now we can update our database record.
 60951:     nsCOMPtr<mozIStorageStatement> stmt =
 80946:       mHistory->GetStatement(
 59323:         "UPDATE moz_places "
 59323:         "SET title = :page_title "
 59323:         "WHERE id = :page_id "
 59323:       );
 47716:     NS_ENSURE_STATE(stmt);
 47716: 
 59323:     {
 59323:       mozStorageStatementScoper scoper(stmt);
 59323:       nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"),
 60951:                                           mPlace.placeId);
 47716:       NS_ENSURE_SUCCESS(rv, rv);
 61392:       // Empty strings should clear the title, just like
 61392:       // nsNavHistory::SetPageTitle.
 61392:       if (mPlace.title.IsEmpty()) {
 59323:         rv = stmt->BindNullByName(NS_LITERAL_CSTRING("page_title"));
 59323:       }
 59323:       else {
 59323:         rv = stmt->BindStringByName(NS_LITERAL_CSTRING("page_title"),
 61392:                                     StringHead(mPlace.title, TITLE_LENGTH_MAX));
 59323:       }
 59323:       NS_ENSURE_SUCCESS(rv, rv);
 59323:       rv = stmt->Execute();
 59323:       NS_ENSURE_SUCCESS(rv, rv);
 59323:     }
 47716: 
 61392:     nsCOMPtr<nsIRunnable> event =
 72844:       new NotifyTitleObservers(mPlace.spec, mPlace.title, mPlace.guid);
 59342:     nsresult rv = NS_DispatchToMainThread(event);
 47716:     NS_ENSURE_SUCCESS(rv, rv);
 47716: 
 47716:     return NS_OK;
 47716:   }
 47716: 
 59323: private:
 59342:   SetPageTitle(const nsCString& aSpec,
 61392:                const nsAString& aTitle)
 61392:   : mHistory(History::GetService())
 59323:   {
 60951:     mPlace.spec = aSpec;
 61392:     mPlace.title = aTitle;
 59323:   }
 59323: 
 60951:   VisitData mPlace;
 59323: 
 59323:   /**
 59323:    * Strong reference to the History object because we do not want it to
 59323:    * disappear out from under us.
 59323:    */
 59323:   nsRefPtr<History> mHistory;
 47716: };
 47716: 
 60955: /**
 87813:  * Adds download-specific annotations to a download page.
 87813:  */
104136: class SetDownloadAnnotations MOZ_FINAL : public mozIVisitInfoCallback
 87813: {
 87813: public:
 87813:   NS_DECL_ISUPPORTS
 87813: 
 87813:   SetDownloadAnnotations(nsIURI* aDestination)
 87813:   : mDestination(aDestination)
 87813:   , mHistory(History::GetService())
 87813:   {
 87813:     MOZ_ASSERT(mDestination);
 87813:     MOZ_ASSERT(NS_IsMainThread());
 87813:   }
 87813: 
 87813:   NS_IMETHOD HandleError(nsresult aResultCode, mozIPlaceInfo *aPlaceInfo)
 87813:   {
 87813:     // Just don't add the annotations in case the visit isn't added.
 87813:     return NS_OK;
 87813:   }
 87813: 
 87813:   NS_IMETHOD HandleResult(mozIPlaceInfo *aPlaceInfo)
 87813:   {
 87813:     // Exit silently if the download destination is not a local file.
 87813:     nsCOMPtr<nsIFileURL> destinationFileURL = do_QueryInterface(mDestination);
 87813:     if (!destinationFileURL) {
 87813:       return NS_OK;
 87813:     }
 87813: 
 87813:     nsCOMPtr<nsIURI> source;
 87813:     nsresult rv = aPlaceInfo->GetUri(getter_AddRefs(source));
 87813:     NS_ENSURE_SUCCESS(rv, rv);
 87813: 
 87813:     nsCOMPtr<nsIFile> destinationFile;
 87813:     rv = destinationFileURL->GetFile(getter_AddRefs(destinationFile));
 87813:     NS_ENSURE_SUCCESS(rv, rv);
 87813: 
 87813:     nsAutoString destinationFileName;
 87813:     rv = destinationFile->GetLeafName(destinationFileName);
 87813:     NS_ENSURE_SUCCESS(rv, rv);
 87813: 
110974:     nsAutoCString destinationURISpec;
 87813:     rv = destinationFileURL->GetSpec(destinationURISpec);
 87813:     NS_ENSURE_SUCCESS(rv, rv);
 87813: 
 87813:     // Use annotations for storing the additional download metadata.
 87813:     nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 87813:     NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
 87813: 
 87813:     rv = annosvc->SetPageAnnotationString(
 87813:       source,
 87813:       DESTINATIONFILEURI_ANNO,
 87813:       NS_ConvertUTF8toUTF16(destinationURISpec),
 87813:       0,
 87813:       nsIAnnotationService::EXPIRE_WITH_HISTORY
 87813:     );
 87813:     NS_ENSURE_SUCCESS(rv, rv);
 87813: 
 87813:     rv = annosvc->SetPageAnnotationString(
 87813:       source,
 87813:       DESTINATIONFILENAME_ANNO,
 87813:       destinationFileName,
 87813:       0,
 87813:       nsIAnnotationService::EXPIRE_WITH_HISTORY
 87813:     );
 87813:     NS_ENSURE_SUCCESS(rv, rv);
 87813: 
 87813:     nsAutoString title;
 87813:     rv = aPlaceInfo->GetTitle(title);
 87813:     NS_ENSURE_SUCCESS(rv, rv);
 87813: 
 87813:     // In case we are downloading a file that does not correspond to a web
 87813:     // page for which the title is present, we populate the otherwise empty
 87813:     // history title with the name of the destination file, to allow it to be
 87813:     // visible and searchable in history results.
 87813:     if (title.IsEmpty()) {
 87813:       rv = mHistory->SetURITitle(source, destinationFileName);
 87813:       NS_ENSURE_SUCCESS(rv, rv);
 87813:     }
 87813: 
 87813:     return NS_OK;
 87813:   }
 87813: 
 87813:   NS_IMETHOD HandleCompletion()
 87813:   {
 87813:     return NS_OK;
 87813:   }
 87813: 
 87813: private:
 87813:   nsCOMPtr<nsIURI> mDestination;
 87813: 
 87813:   /**
 87813:    * Strong reference to the History object because we do not want it to
 87813:    * disappear out from under us.
 87813:    */
 87813:   nsRefPtr<History> mHistory;
 87813: };
 87813: NS_IMPL_ISUPPORTS1(
 87813:   SetDownloadAnnotations,
 87813:   mozIVisitInfoCallback
 87813: )
 87813: 
 87813: /**
 60955:  * Stores an embed visit, and notifies observers.
 60955:  *
 60955:  * @param aPlace
 60955:  *        The VisitData of the visit to store as an embed visit.
 60966:  * @param [optional] aCallback
 60966:  *        The mozIVisitInfoCallback to notify, if provided.
 60955:  */
 60955: void
 60966: StoreAndNotifyEmbedVisit(VisitData& aPlace,
 60966:                          mozIVisitInfoCallback* aCallback = NULL)
 60955: {
 60955:   NS_PRECONDITION(aPlace.transitionType == nsINavHistoryService::TRANSITION_EMBED,
 60955:                   "Must only pass TRANSITION_EMBED visits to this!");
 60955:   NS_PRECONDITION(NS_IsMainThread(), "Must be called on the main thread!");
 60955: 
 60955:   nsCOMPtr<nsIURI> uri;
 60955:   (void)NS_NewURI(getter_AddRefs(uri), aPlace.spec);
 60955: 
 60955:   nsNavHistory* navHistory = nsNavHistory::GetHistoryService();
 60955:   if (!navHistory || !uri) {
 60955:     return;
 60955:   }
 60955: 
 60955:   navHistory->registerEmbedVisit(uri, aPlace.visitTime);
 60966: 
 60966:   if (aCallback) {
 77030:     // NotifyVisitInfoCallback does not hold a strong reference to the callback,
 77030:     // so we have to manage it by AddRefing now and then releasing it after the
 77030:     // event has run.
 60966:     NS_ADDREF(aCallback);
 60966:     nsCOMPtr<nsIRunnable> event =
 77030:       new NotifyVisitInfoCallback(aCallback, aPlace, NS_OK);
 60966:     (void)NS_DispatchToMainThread(event);
 60966: 
 60966:     // Also dispatch an event to release our reference to the callback after
 77030:     // NotifyVisitInfoCallback has run.
 60966:     nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
 80486:     (void)NS_ProxyRelease(mainThread, aCallback, true);
 60966:   }
 60966: 
 60955:   VisitData noReferrer;
 60955:   nsCOMPtr<nsIRunnable> event = new NotifyVisitObservers(aPlace, noReferrer);
 60955:   (void)NS_DispatchToMainThread(event);
 60955: }
 60955: 
 84340: NS_MEMORY_REPORTER_MALLOC_SIZEOF_FUN(HistoryLinksHashtableMallocSizeOf,
 84340:                                      "history-links-hashtable")
 84340: 
108991: int64_t GetHistoryObserversSize()
 80308: {
 80308:   History* history = History::GetService();
 96983:   return history ?
 96983:          history->SizeOfIncludingThis(HistoryLinksHashtableMallocSizeOf) : 0;
 80308: }
 80308: 
 80308: NS_MEMORY_REPORTER_IMPLEMENT(HistoryService,
 80308:   "explicit/history-links-hashtable",
 80308:   KIND_HEAP,
 80308:   UNITS_BYTES,
 80308:   GetHistoryObserversSize,
 80308:   "Memory used by the hashtable of observers Places uses to notify objects of "
 80308:   "changes to links' visited state.")
 80308: 
 38166: } // anonymous namespace
 38166: 
 38166: ////////////////////////////////////////////////////////////////////////////////
 38166: //// History
 38166: 
 47167: History* History::gService = NULL;
 38166: 
 38166: History::History()
 80946:   : mShuttingDown(false)
 89225:   , mShutdownMutex("History::mShutdownMutex")
 94298:   , mRecentlyVisitedURIsNextIndex(0)
 38166: {
 38166:   NS_ASSERTION(!gService, "Ruh-roh!  This service has already been created!");
 38166:   gService = this;
 47715: 
 59580:   nsCOMPtr<nsIObserverService> os = services::GetObserverService();
 47715:   NS_WARN_IF_FALSE(os, "Observer service was not found!");
 47715:   if (os) {
 80486:     (void)os->AddObserver(this, TOPIC_PLACES_SHUTDOWN, false);
 47715:   }
 80308: 
 80308:   NS_RegisterMemoryReporter(new NS_MEMORY_REPORTER_NAME(HistoryService));
 38166: }
 38166: 
 38166: History::~History()
 38166: {
 47167:   gService = NULL;
 47715: 
 38900: #ifdef DEBUG
 38900:   if (mObservers.IsInitialized()) {
 38900:     NS_ASSERTION(mObservers.Count() == 0,
 38900:                  "Not all Links were removed before we disappear!");
 38900:   }
 38900: #endif
 47715: }
 47715: 
 47715: void
 46955: History::NotifyVisited(nsIURI* aURI)
 38166: {
 38166:   NS_ASSERTION(aURI, "Ruh-roh!  A NULL URI was passed to us!");
 38166: 
 73972:   nsAutoScriptBlocker scriptBlocker;
 73972: 
 48297:   if (XRE_GetProcessType() == GeckoProcessType_Default) {
116213:     nsTArray<ContentParent*> cplist;
116213:     ContentParent::GetAll(cplist);
116213: 
116213:     if (!cplist.IsEmpty()) {
109209:       URIParams uri;
109209:       SerializeURI(aURI, uri);
108991:       for (uint32_t i = 0; i < cplist.Length(); ++i) {
109209:         unused << cplist[i]->SendNotifyVisited(uri);
 76840:       }
 48297:     }
116213:   }
 48297: 
 38166:   // If the hash table has not been initialized, then we have nothing to notify
 38166:   // about.
 38166:   if (!mObservers.IsInitialized()) {
 38166:     return;
 38166:   }
 38166: 
 38166:   // Additionally, if we have no observers for this URI, we have nothing to
 38166:   // notify about.
 38166:   KeyClass* key = mObservers.GetEntry(aURI);
 38166:   if (!key) {
 38166:     return;
 38166:   }
 38166: 
 73972:   // Update status of each Link node.
 73972:   {
 73972:     // RemoveEntry will destroy the array, this iterator should not survive it.
 73972:     ObserverArray::ForwardIterator iter(key->array);
 73972:     while (iter.HasMore()) {
 73972:       Link* link = iter.GetNext();
 38166:       link->SetLinkState(eLinkState_Visited);
 73972:       // Verify that the observers hash doesn't mutate while looping through
 73972:       // the links associated with this URI.
 73972:       NS_ABORT_IF_FALSE(key == mObservers.GetEntry(aURI),
 73972:                         "The URIs hash mutated!");
 73972:     }
 38166:   }
 38166: 
 38166:   // All the registered nodes can now be removed for this URI.
 38166:   mObservers.RemoveEntry(aURI);
 38166: }
 38166: 
 59302: mozIStorageAsyncStatement*
 59302: History::GetIsVisitedStatement()
 59302: {
 59302:   if (mIsVisitedStatement) {
 59302:     return mIsVisitedStatement;
 59302:   }
 59302: 
 59302:   // If we don't yet have a database connection, go ahead and clone it now.
 59302:   if (!mReadOnlyDBConn) {
 59322:     mozIStorageConnection* dbConn = GetDBConn();
106838:     NS_ENSURE_TRUE(dbConn, nullptr);
 59302: 
 80486:     (void)dbConn->Clone(true, getter_AddRefs(mReadOnlyDBConn));
106838:     NS_ENSURE_TRUE(mReadOnlyDBConn, nullptr);
 59302:   }
 59302: 
 59302:   // Now we can create our cached statement.
 59302:   nsresult rv = mReadOnlyDBConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
 82965:     "SELECT 1 "
 59302:     "FROM moz_places h "
 59302:     "WHERE url = ?1 "
 82965:       "AND last_visit_date NOTNULL "
 59302:   ),  getter_AddRefs(mIsVisitedStatement));
106838:   NS_ENSURE_SUCCESS(rv, nullptr);
 59302:   return mIsVisitedStatement;
 59302: }
 59302: 
 60950: nsresult
 60950: History::InsertPlace(const VisitData& aPlace)
 60950: {
 60950:   NS_PRECONDITION(aPlace.placeId == 0, "should not have a valid place id!");
 60950:   NS_PRECONDITION(!NS_IsMainThread(), "must be called off of the main thread!");
 60950: 
 80946:   nsCOMPtr<mozIStorageStatement> stmt = GetStatement(
 60950:       "INSERT INTO moz_places "
 94946:         "(url, title, rev_host, hidden, typed, frecency, guid) "
 94946:       "VALUES (:url, :title, :rev_host, :hidden, :typed, :frecency, :guid) "
 60950:     );
 60950:   NS_ENSURE_STATE(stmt);
 60950:   mozStorageStatementScoper scoper(stmt);
 60950: 
 60950:   nsresult rv = stmt->BindStringByName(NS_LITERAL_CSTRING("rev_host"),
 60950:                                        aPlace.revHost);
 60950:   NS_ENSURE_SUCCESS(rv, rv);
 60961:   rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("url"), aPlace.spec);
 60961:   NS_ENSURE_SUCCESS(rv, rv);
 61392:   // Empty strings should have no title, just like nsNavHistory::SetPageTitle.
 61392:   if (aPlace.title.IsEmpty()) {
 60961:     rv = stmt->BindNullByName(NS_LITERAL_CSTRING("title"));
 60961:   }
 60961:   else {
 60961:     rv = stmt->BindStringByName(NS_LITERAL_CSTRING("title"),
 60961:                                 StringHead(aPlace.title, TITLE_LENGTH_MAX));
 60961:   }
 60950:   NS_ENSURE_SUCCESS(rv, rv);
 60950:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("typed"), aPlace.typed);
 60950:   NS_ENSURE_SUCCESS(rv, rv);
 94946:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("frecency"), aPlace.frecency);
 94946:   NS_ENSURE_SUCCESS(rv, rv);
 60950:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("hidden"), aPlace.hidden);
 60950:   NS_ENSURE_SUCCESS(rv, rv);
110974:   nsAutoCString guid(aPlace.guid);
 60962:   if (aPlace.guid.IsVoid()) {
 60962:     rv = GenerateGUID(guid);
 60962:     NS_ENSURE_SUCCESS(rv, rv);
 60962:   }
 60962:   rv = stmt->BindUTF8StringByName(NS_LITERAL_CSTRING("guid"), guid);
 60962:   NS_ENSURE_SUCCESS(rv, rv);
 60950:   rv = stmt->Execute();
 60950:   NS_ENSURE_SUCCESS(rv, rv);
 60950: 
 60950:   return NS_OK;
 60950: }
 60950: 
 60950: nsresult
 60950: History::UpdatePlace(const VisitData& aPlace)
 60950: {
 60985:   NS_PRECONDITION(!NS_IsMainThread(), "must be called off of the main thread!");
 60979:   NS_PRECONDITION(aPlace.placeId > 0, "must have a valid place id!");
 60985:   NS_PRECONDITION(!aPlace.guid.IsVoid(), "must have a guid!");
 60950: 
 80946:   nsCOMPtr<mozIStorageStatement> stmt = GetStatement(
 60950:       "UPDATE moz_places "
 60985:       "SET title = :title, "
 60985:           "hidden = :hidden, "
 60985:           "typed = :typed, "
 60985:           "guid = :guid "
 60950:       "WHERE id = :page_id "
 60950:     );
 60950:   NS_ENSURE_STATE(stmt);
 60950:   mozStorageStatementScoper scoper(stmt);
 60950: 
 60985:   nsresult rv;
 61392:   // Empty strings should clear the title, just like nsNavHistory::SetPageTitle.
 61392:   if (aPlace.title.IsEmpty()) {
 61392:     rv = stmt->BindNullByName(NS_LITERAL_CSTRING("title"));
 61392:   }
 61392:   else {
 60985:     rv = stmt->BindStringByName(NS_LITERAL_CSTRING("title"),
 60985:                                 StringHead(aPlace.title, TITLE_LENGTH_MAX));
 61392:   }
 61390:   NS_ENSURE_SUCCESS(rv, rv);
 60950:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("typed"), aPlace.typed);
 60950:   NS_ENSURE_SUCCESS(rv, rv);
 60950:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("hidden"), aPlace.hidden);
 60950:   NS_ENSURE_SUCCESS(rv, rv);
 60985:   rv = stmt->BindUTF8StringByName(NS_LITERAL_CSTRING("guid"), aPlace.guid);
 60985:   NS_ENSURE_SUCCESS(rv, rv);
 60985:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"),
 60985:                              aPlace.placeId);
 60985:   NS_ENSURE_SUCCESS(rv, rv);
 60950:   rv = stmt->Execute();
 60950:   NS_ENSURE_SUCCESS(rv, rv);
 60950: 
 60950:   return NS_OK;
 60950: }
 60950: 
 60951: bool
 60951: History::FetchPageInfo(VisitData& _place)
 60951: {
 60951:   NS_PRECONDITION(!_place.spec.IsEmpty(), "must have a non-empty spec!");
 60951:   NS_PRECONDITION(!NS_IsMainThread(), "must be called off of the main thread!");
 60951: 
 80946:   nsCOMPtr<mozIStorageStatement> stmt = GetStatement(
 60985:       "SELECT id, title, hidden, typed, guid "
 60951:       "FROM moz_places "
 60951:       "WHERE url = :page_url "
 60951:     );
 60951:   NS_ENSURE_TRUE(stmt, false);
 60951:   mozStorageStatementScoper scoper(stmt);
 60951: 
 60951:   nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"),
 60951:                                 _place.spec);
 60951:   NS_ENSURE_SUCCESS(rv, false);
 60951: 
 79445:   bool hasResult;
 60951:   rv = stmt->ExecuteStep(&hasResult);
 60951:   NS_ENSURE_SUCCESS(rv, false);
 60951:   if (!hasResult) {
 60951:     return false;
 60951:   }
 60951: 
 60951:   rv = stmt->GetInt64(0, &_place.placeId);
 60951:   NS_ENSURE_SUCCESS(rv, false);
 60951: 
 61392:   nsAutoString title;
 61392:   rv = stmt->GetString(1, title);
 61392:   NS_ENSURE_SUCCESS(rv, true);
 61392: 
 61393:   // If the title we were given was void, that means we did not bother to set
 61393:   // it to anything.  As a result, ignore the fact that we may have changed the
 61393:   // title (because we don't want to, that would be empty), and set the title
 61393:   // to what is currently stored in the datbase.
 61390:   if (_place.title.IsVoid()) {
 61392:     _place.title = title;
 60951:   }
 61393:   // Otherwise, just indicate if the title has changed.
 61393:   else {
 61393:     _place.titleChanged = !(_place.title.Equals(title) ||
 61393:                             (_place.title.IsEmpty() && title.IsVoid()));
 61393:   }
 60951: 
 60951:   if (_place.hidden) {
 60951:     // If this transition was hidden, it is possible that others were not.
 60951:     // Any one visible transition makes this location visible. If database
 60951:     // has location as visible, reflect that in our data structure.
108991:     int32_t hidden;
 60951:     rv = stmt->GetInt32(2, &hidden);
 60951:     _place.hidden = !!hidden;
 60951:     NS_ENSURE_SUCCESS(rv, true);
 60951:   }
 60951: 
 60985:   if (!_place.typed) {
 60985:     // If this transition wasn't typed, others might have been. If database
 60985:     // has location as typed, reflect that in our data structure.
108991:     int32_t typed;
 60985:     rv = stmt->GetInt32(3, &typed);
 60985:     _place.typed = !!typed;
 60951:     NS_ENSURE_SUCCESS(rv, true);
 60985:   }
 60985: 
 60985:   if (_place.guid.IsVoid()) {
 60985:     rv = stmt->GetUTF8String(4, _place.guid);
 60985:     NS_ENSURE_SUCCESS(rv, true);
 60985:   }
 60951: 
 60951:   return true;
 60951: }
 60951: 
 84923: /* static */ size_t
 84923: History::SizeOfEntryExcludingThis(KeyClass* aEntry, nsMallocSizeOfFun aMallocSizeOf, void *)
 80308: {
 84923:   return aEntry->array.SizeOfExcludingThis(aMallocSizeOf);
 80308: }
 80308: 
 84923: size_t
 82849: History::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOfThis)
 80308: {
 88300:   return aMallocSizeOfThis(this) +
 84923:          mObservers.SizeOfExcludingThis(SizeOfEntryExcludingThis, aMallocSizeOfThis);
 80308: }
 80308: 
 38166: /* static */
 38166: History*
 38166: History::GetService()
 38166: {
 38166:   if (gService) {
 38166:     return gService;
 38166:   }
 38166: 
 38166:   nsCOMPtr<IHistory> service(do_GetService(NS_IHISTORY_CONTRACTID));
 38166:   NS_ABORT_IF_FALSE(service, "Cannot obtain IHistory service!");
 38166:   NS_ASSERTION(gService, "Our constructor was not run?!");
 38166: 
 38166:   return gService;
 38166: }
 38166: 
 38166: /* static */
 38166: History*
 38166: History::GetSingleton()
 38166: {
 38166:   if (!gService) {
 38166:     gService = new History();
106838:     NS_ENSURE_TRUE(gService, nullptr);
 38166:   }
 38166: 
 38166:   NS_ADDREF(gService);
 38166:   return gService;
 38166: }
 38166: 
 59322: mozIStorageConnection*
 59322: History::GetDBConn()
 59322: {
 80946:   if (!mDB) {
 80946:     mDB = Database::GetDatabase();
106838:     NS_ENSURE_TRUE(mDB, nullptr);
 59322:   }
 80946:   return mDB->MainConn();
 59322: }
 59322: 
 47715: void
 47715: History::Shutdown()
 47715: {
 88046:   MOZ_ASSERT(NS_IsMainThread());
 89225: 
 89225:   // Prevent other threads from scheduling uses of the DB while we mark
 89225:   // ourselves as shutting down.
 89225:   MutexAutoLock lockedScope(mShutdownMutex);
 88046:   MOZ_ASSERT(!mShuttingDown && "Shutdown was called more than once!");
 59344: 
 47715:   mShuttingDown = true;
 47715: 
 59302:   if (mReadOnlyDBConn) {
 59303:     if (mIsVisitedStatement) {
 59303:       (void)mIsVisitedStatement->Finalize();
 59303:     }
106838:     (void)mReadOnlyDBConn->AsyncClose(nullptr);
 59302:   }
 47715: }
 47715: 
 94298: void
 94298: History::AppendToRecentlyVisitedURIs(nsIURI* aURI) {
 94298:   if (mRecentlyVisitedURIs.Length() < RECENTLY_VISITED_URI_SIZE) {
 94298:     // Append a new element while the array is not full.
 94298:     mRecentlyVisitedURIs.AppendElement(aURI);
 94298:   } else {
 94298:     // Otherwise, replace the oldest member.
 94298:     mRecentlyVisitedURIsNextIndex %= RECENTLY_VISITED_URI_SIZE;
 94298:     mRecentlyVisitedURIs.ElementAt(mRecentlyVisitedURIsNextIndex) = aURI;
 94298:     mRecentlyVisitedURIsNextIndex++;
 94298:   }
 94298: }
 94298: 
 94298: inline bool
 94298: History::IsRecentlyVisitedURI(nsIURI* aURI) {
 94298:   bool equals = false;
 94298:   RecentlyVisitedArray::index_type i;
 94298:   for (i = 0; i < mRecentlyVisitedURIs.Length() && !equals; ++i) {
 94298:     aURI->Equals(mRecentlyVisitedURIs.ElementAt(i), &equals);
 94298:   }
 94298:   return equals;
 94298: }
 94298: 
 38166: ////////////////////////////////////////////////////////////////////////////////
 38166: //// IHistory
 38166: 
 38166: NS_IMETHODIMP
 47715: History::VisitURI(nsIURI* aURI,
 47715:                   nsIURI* aLastVisitedURI,
108991:                   uint32_t aFlags)
 47715: {
 47715:   NS_PRECONDITION(aURI, "URI should not be NULL.");
 47715:   if (mShuttingDown) {
 47715:     return NS_OK;
 47715:   }
 47715: 
 48298:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
109209:     URIParams uri;
109209:     SerializeURI(aURI, uri);
109209: 
109209:     OptionalURIParams lastVisitedURI;
109209:     SerializeURI(aLastVisitedURI, lastVisitedURI);
109209: 
 48298:     mozilla::dom::ContentChild* cpc =
 48298:       mozilla::dom::ContentChild::GetSingleton();
 48298:     NS_ASSERTION(cpc, "Content Protocol is NULL!");
109209:     (void)cpc->SendVisitURI(uri, lastVisitedURI, aFlags);
 48298:     return NS_OK;
 48298:   } 
 48298: 
 59333:   nsNavHistory* navHistory = nsNavHistory::GetHistoryService();
 59333:   NS_ENSURE_TRUE(navHistory, NS_ERROR_OUT_OF_MEMORY);
 47715: 
 47715:   // Silently return if URI is something we shouldn't add to DB.
 79445:   bool canAdd;
 59333:   nsresult rv = navHistory->CanAddURI(aURI, &canAdd);
 47715:   NS_ENSURE_SUCCESS(rv, rv);
 47715:   if (!canAdd) {
 47715:     return NS_OK;
 47715:   }
 47715: 
 59320:   if (aLastVisitedURI) {
 79445:     bool same;
 59320:     rv = aURI->Equals(aLastVisitedURI, &same);
 47715:     NS_ENSURE_SUCCESS(rv, rv);
 94298:     if (same && IsRecentlyVisitedURI(aURI)) {
 94298:       // Do not save refresh visits if we have visited this URI recently.
 47715:       return NS_OK;
 47715:     }
 59320:   }
 59320: 
 60954:   nsTArray<VisitData> placeArray(1);
 60954:   NS_ENSURE_TRUE(placeArray.AppendElement(VisitData(aURI, aLastVisitedURI)),
 60954:                  NS_ERROR_OUT_OF_MEMORY);
 60954:   VisitData& place = placeArray.ElementAt(0);
 60949:   NS_ENSURE_FALSE(place.spec.IsEmpty(), NS_ERROR_INVALID_ARG);
 60949: 
 60949:   place.visitTime = PR_Now();
 47715: 
 47715:   // Assigns a type to the edge in the visit linked list. Each type will be
 47715:   // considered differently when weighting the frecency of a location.
108991:   uint32_t recentFlags = navHistory->GetRecentFlags(aURI);
 59333:   bool isFollowedLink = recentFlags & nsNavHistory::RECENT_ACTIVATED;
 59333: 
 59333:   // Embed visits should never be added to the database, and the same is valid
 59333:   // for redirects across frames.
 59333:   // For the above reasoning non-toplevel transitions are handled at first.
 59333:   // if the visit is toplevel or a non-toplevel followed link, then it can be
 59333:   // handled as usual and stored on disk.
 59333: 
108991:   uint32_t transitionType = nsINavHistoryService::TRANSITION_LINK;
 94946: 
 59333:   if (!(aFlags & IHistory::TOP_LEVEL) && !isFollowedLink) {
 59333:     // A frame redirected to a new site without user interaction.
 94946:     transitionType = nsINavHistoryService::TRANSITION_EMBED;
 59333:   }
 59333:   else if (aFlags & IHistory::REDIRECT_TEMPORARY) {
 94946:     transitionType = nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY;
 47715:   }
 47715:   else if (aFlags & IHistory::REDIRECT_PERMANENT) {
 94946:     transitionType = nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT;
 47715:   }
 47715:   else if (recentFlags & nsNavHistory::RECENT_TYPED) {
 94946:     transitionType = nsINavHistoryService::TRANSITION_TYPED;
 47715:   }
 47715:   else if (recentFlags & nsNavHistory::RECENT_BOOKMARKED) {
 94946:     transitionType = nsINavHistoryService::TRANSITION_BOOKMARK;
 47715:   }
 59333:   else if (!(aFlags & IHistory::TOP_LEVEL) && isFollowedLink) {
 47715:     // User activated a link in a frame.
 94946:     transitionType = nsINavHistoryService::TRANSITION_FRAMED_LINK;
 47715:   }
 94946: 
 94946:   place.SetTransitionType(transitionType);
 94946:   place.hidden = GetHiddenState(aFlags & IHistory::REDIRECT_SOURCE,
 94946:                                 transitionType);
 94946: 
 94946:   // Error pages should never be autocompleted.
 94946:   if (aFlags & IHistory::UNRECOVERABLE_ERROR) {
 94946:     place.frecency = 0;
 47715:   }
 47715: 
 59333:   // EMBED visits are session-persistent and should not go through the database.
 59333:   // They exist only to keep track of isVisited status during the session.
 59333:   if (place.transitionType == nsINavHistoryService::TRANSITION_EMBED) {
 60955:     StoreAndNotifyEmbedVisit(place);
 59333:   }
 59333:   else {
 59322:     mozIStorageConnection* dbConn = GetDBConn();
 59322:     NS_ENSURE_STATE(dbConn);
 59322: 
 60954:     rv = InsertVisitedURIs::Start(dbConn, placeArray);
 59320:     NS_ENSURE_SUCCESS(rv, rv);
 59333:   }
 47715: 
 59320:   // Finally, notify that we've been visited.
 47715:   nsCOMPtr<nsIObserverService> obsService =
 47715:     mozilla::services::GetObserverService();
 47715:   if (obsService) {
106838:     obsService->NotifyObservers(aURI, NS_LINK_VISITED_EVENT_TOPIC, nullptr);
 47715:   }
 47715: 
 47715:   return NS_OK;
 47715: }
 47715: 
 47715: NS_IMETHODIMP
 38166: History::RegisterVisitedCallback(nsIURI* aURI,
 38166:                                  Link* aLink)
 38166: {
 38166:   NS_ASSERTION(aURI, "Must pass a non-null URI!");
 48297:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
 48703:     NS_PRECONDITION(aLink, "Must pass a non-null Link!");
 48297:   }
 48297: 
 38166:   // First, ensure that our hash table is setup.
 38166:   if (!mObservers.IsInitialized()) {
 98908:     mObservers.Init(VISIT_OBSERVERS_INITIAL_CACHE_SIZE);
 38166:   }
 38166: 
 38166:   // Obtain our array of observers for this URI.
 38900: #ifdef DEBUG
 38900:   bool keyAlreadyExists = !!mObservers.GetEntry(aURI);
 38900: #endif
 38166:   KeyClass* key = mObservers.PutEntry(aURI);
 38166:   NS_ENSURE_TRUE(key, NS_ERROR_OUT_OF_MEMORY);
 38166:   ObserverArray& observers = key->array;
 38166: 
 38166:   if (observers.IsEmpty()) {
 38900:     NS_ASSERTION(!keyAlreadyExists,
 38900:                  "An empty key was kept around in our hashtable!");
 38900: 
 38166:     // We are the first Link node to ask about this URI, or there are no pending
 38166:     // Links wanting to know about this URI.  Therefore, we should query the
 38166:     // database now.
 46955:     nsresult rv = VisitedQuery::Start(aURI);
 56630: 
 56630:     // In IPC builds, we are passed a NULL Link from
 56630:     // ContentParent::RecvStartVisitedQuery.  Since we won't be adding a NULL
 56630:     // entry to our list of observers, and the code after this point assumes
 56630:     // that aLink is non-NULL, we will need to return now.
 48297:     if (NS_FAILED(rv) || !aLink) {
 38900:       // Remove our array from the hashtable so we don't keep it around.
 38900:       mObservers.RemoveEntry(aURI);
 38166:       return rv;
 38166:     }
 38166:   }
 56630:   // In IPC builds, we are passed a NULL Link from
 56630:   // ContentParent::RecvStartVisitedQuery.  All of our code after this point
 56630:   // assumes aLink is non-NULL, so we have to return now.
 56630:   else if (!aLink) {
 56630:     NS_ASSERTION(XRE_GetProcessType() == GeckoProcessType_Default,
 56630:                  "We should only ever get a null Link in the default process!");
 56630:     return NS_OK;
 56630:   }
 38166: 
 38166:   // Sanity check that Links are not registered more than once for a given URI.
 38166:   // This will not catch a case where it is registered for two different URIs.
 38166:   NS_ASSERTION(!observers.Contains(aLink),
 38166:                "Already tracking this Link object!");
 38166: 
 38166:   // Start tracking our Link.
 38166:   if (!observers.AppendElement(aLink)) {
 38166:     // Curses - unregister and return failure.
 38166:     (void)UnregisterVisitedCallback(aURI, aLink);
 38166:     return NS_ERROR_OUT_OF_MEMORY;
 38166:   }
 38166: 
 38166:   return NS_OK;
 38166: }
 38166: 
 38166: NS_IMETHODIMP
 38166: History::UnregisterVisitedCallback(nsIURI* aURI,
 38166:                                    Link* aLink)
 38166: {
 38166:   NS_ASSERTION(aURI, "Must pass a non-null URI!");
 38166:   NS_ASSERTION(aLink, "Must pass a non-null Link object!");
 38166: 
 38166:   // Get the array, and remove the item from it.
 38166:   KeyClass* key = mObservers.GetEntry(aURI);
 38166:   if (!key) {
 38166:     NS_ERROR("Trying to unregister for a URI that wasn't registered!");
 38166:     return NS_ERROR_UNEXPECTED;
 38166:   }
 38166:   ObserverArray& observers = key->array;
 38166:   if (!observers.RemoveElement(aLink)) {
 38166:     NS_ERROR("Trying to unregister a node that wasn't registered!");
 38166:     return NS_ERROR_UNEXPECTED;
 38166:   }
 38166: 
 38166:   // If the array is now empty, we should remove it from the hashtable.
 38166:   if (observers.IsEmpty()) {
 38166:     mObservers.RemoveEntry(aURI);
 38166:   }
 38166: 
 38166:   return NS_OK;
 38166: }
 38166: 
 47716: NS_IMETHODIMP
 47716: History::SetURITitle(nsIURI* aURI, const nsAString& aTitle)
 47716: {
 47716:   NS_PRECONDITION(aURI, "Must pass a non-null URI!");
 47716:   if (mShuttingDown) {
 47716:     return NS_OK;
 47716:   }
 47716: 
 48342:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
109209:     URIParams uri;
109209:     SerializeURI(aURI, uri);
109209: 
 48342:     mozilla::dom::ContentChild * cpc = 
 48342:       mozilla::dom::ContentChild::GetSingleton();
 48342:     NS_ASSERTION(cpc, "Content Protocol is NULL!");
109209:     (void)cpc->SendSetURITitle(uri, nsString(aTitle));
 48342:     return NS_OK;
 48342:   } 
 48342: 
 59333:   nsNavHistory* navHistory = nsNavHistory::GetHistoryService();
 47716: 
 47716:   // At first, it seems like nav history should always be available here, no
 47716:   // matter what.
 47716:   //
 47716:   // nsNavHistory fails to register as a service if there is no profile in
 47716:   // place (for instance, if user is choosing a profile).
 47716:   //
 47716:   // Maybe the correct thing to do is to not register this service if no
 47716:   // profile has been selected?
 47716:   //
 59333:   NS_ENSURE_TRUE(navHistory, NS_ERROR_FAILURE);
 47716: 
 79445:   bool canAdd;
 59333:   nsresult rv = navHistory->CanAddURI(aURI, &canAdd);
 47716:   NS_ENSURE_SUCCESS(rv, rv);
 47716:   if (!canAdd) {
 47716:     return NS_OK;
 47716:   }
 47716: 
 59333:   // Embed visits don't have a database entry, thus don't set a title on them.
 59333:   if (navHistory->hasEmbedVisit(aURI)) {
 59333:     return NS_OK;
 59333:   }
 59333: 
 59323:   mozIStorageConnection* dbConn = GetDBConn();
 59323:   NS_ENSURE_STATE(dbConn);
 59323: 
 61392:   rv = SetPageTitle::Start(dbConn, aURI, aTitle);
 59323:   NS_ENSURE_SUCCESS(rv, rv);
 47716: 
 47716:   return NS_OK;
 47716: }
 47716: 
 38166: ////////////////////////////////////////////////////////////////////////////////
 87813: //// nsIDownloadHistory
 87813: 
 87813: NS_IMETHODIMP
 87813: History::AddDownload(nsIURI* aSource, nsIURI* aReferrer,
 87813:                      PRTime aStartTime, nsIURI* aDestination)
 87813: {
 87813:   MOZ_ASSERT(NS_IsMainThread());
 87813:   NS_ENSURE_ARG(aSource);
 87813: 
 87813:   if (mShuttingDown) {
 87813:     return NS_OK;
 87813:   }
 87813: 
 87813:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
 87813:     NS_ERROR("Cannot add downloads to history from content process!");
 87813:     return NS_ERROR_NOT_AVAILABLE;
 87813:   }
 87813: 
 87813:   nsNavHistory* navHistory = nsNavHistory::GetHistoryService();
 87813:   NS_ENSURE_TRUE(navHistory, NS_ERROR_OUT_OF_MEMORY);
 87813: 
 87813:   // Silently return if URI is something we shouldn't add to DB.
 87813:   bool canAdd;
 87813:   nsresult rv = navHistory->CanAddURI(aSource, &canAdd);
 87813:   NS_ENSURE_SUCCESS(rv, rv);
 87813:   if (!canAdd) {
 87813:     return NS_OK;
 87813:   }
 87813: 
 87813:   nsTArray<VisitData> placeArray(1);
 87813:   NS_ENSURE_TRUE(placeArray.AppendElement(VisitData(aSource, aReferrer)),
 87813:                  NS_ERROR_OUT_OF_MEMORY);
 87813:   VisitData& place = placeArray.ElementAt(0);
 87813:   NS_ENSURE_FALSE(place.spec.IsEmpty(), NS_ERROR_INVALID_ARG);
 87813: 
 87813:   place.visitTime = aStartTime;
 87813:   place.SetTransitionType(nsINavHistoryService::TRANSITION_DOWNLOAD);
 94946:   place.hidden = false;
 87813: 
 87813:   mozIStorageConnection* dbConn = GetDBConn();
 87813:   NS_ENSURE_STATE(dbConn);
 87813: 
 87813:   nsCOMPtr<mozIVisitInfoCallback> callback = aDestination
 87813:                                   ? new SetDownloadAnnotations(aDestination)
106838:                                   : nullptr;
 87813: 
 87813:   rv = InsertVisitedURIs::Start(dbConn, placeArray, callback);
 87813:   NS_ENSURE_SUCCESS(rv, rv);
 87813: 
 87813:   // Finally, notify that we've been visited.
 87813:   nsCOMPtr<nsIObserverService> obsService =
 87813:     mozilla::services::GetObserverService();
 87813:   if (obsService) {
106838:     obsService->NotifyObservers(aSource, NS_LINK_VISITED_EVENT_TOPIC, nullptr);
 87813:   }
 87813: 
 87813:   return NS_OK;
 87813: }
 87813: 
 87813: ////////////////////////////////////////////////////////////////////////////////
 60958: //// mozIAsyncHistory
 60958: 
 60958: NS_IMETHODIMP
 60958: History::UpdatePlaces(const jsval& aPlaceInfos,
 60958:                       mozIVisitInfoCallback* aCallback,
 60958:                       JSContext* aCtx)
 60958: {
 60958:   NS_ENSURE_TRUE(NS_IsMainThread(), NS_ERROR_UNEXPECTED);
 61385:   NS_ENSURE_TRUE(!JSVAL_IS_PRIMITIVE(aPlaceInfos), NS_ERROR_INVALID_ARG);
 60958: 
 91688:   uint32_t infosLength = 1;
 61385:   JSObject* infos;
 61385:   if (JS_IsArrayObject(aCtx, JSVAL_TO_OBJECT(aPlaceInfos))) {
 61385:     infos = JSVAL_TO_OBJECT(aPlaceInfos);
 61385:     (void)JS_GetArrayLength(aCtx, infos, &infosLength);
 61385:     NS_ENSURE_ARG(infosLength > 0);
 61385:   }
 61385:   else {
 61385:     // Build a temporary array to store this one item so the code below can
 61385:     // just loop.
 61385:     infos = JS_NewArrayObject(aCtx, 0, NULL);
 61385:     NS_ENSURE_TRUE(infos, NS_ERROR_OUT_OF_MEMORY);
 61385: 
 61385:     JSBool rc = JS_DefineElement(aCtx, infos, 0, aPlaceInfos, NULL, NULL, 0);
 61385:     NS_ENSURE_TRUE(rc, NS_ERROR_UNEXPECTED);
 61385:   }
 61385: 
 61385:   nsTArray<VisitData> visitData;
 91688:   for (uint32_t i = 0; i < infosLength; i++) {
 61385:     JSObject* info;
 61385:     nsresult rv = GetJSObjectFromArray(aCtx, infos, i, &info);
 61385:     NS_ENSURE_SUCCESS(rv, rv);
 61385: 
 61385:     nsCOMPtr<nsIURI> uri = GetURIFromJSObject(aCtx, info, "uri");
 61385:     nsCString guid;
 61385:     {
 61385:       nsString fatGUID;
 61385:       GetStringFromJSObject(aCtx, info, "guid", fatGUID);
 61385:       if (fatGUID.IsVoid()) {
 80486:         guid.SetIsVoid(true);
 61385:       }
 61385:       else {
 61385:         guid = NS_ConvertUTF16toUTF8(fatGUID);
 61385:       }
 61385:     }
 61385: 
 61387:     // Make sure that any uri we are given can be added to history, and if not,
 61387:     // skip it (CanAddURI will notify our callback for us).
 61908:     if (uri && !CanAddURI(uri, guid, aCallback)) {
 61387:       continue;
 61387:     }
 61387: 
 61908:     // We must have at least one of uri or guid.
 61908:     NS_ENSURE_ARG(uri || !guid.IsVoid());
 61385: 
 61385:     // If we were given a guid, make sure it is valid.
 61385:     bool isValidGUID = IsValidGUID(guid);
 61385:     NS_ENSURE_ARG(guid.IsVoid() || isValidGUID);
 61385: 
 61385:     nsString title;
 61385:     GetStringFromJSObject(aCtx, info, "title", title);
 61385: 
 61385:     JSObject* visits = NULL;
 61385:     {
 61385:       jsval visitsVal;
 61385:       JSBool rc = JS_GetProperty(aCtx, info, "visits", &visitsVal);
 61385:       NS_ENSURE_TRUE(rc, NS_ERROR_UNEXPECTED);
 61385:       if (!JSVAL_IS_PRIMITIVE(visitsVal)) {
 61385:         visits = JSVAL_TO_OBJECT(visitsVal);
 61385:         NS_ENSURE_ARG(JS_IsArrayObject(aCtx, visits));
 61385:       }
 61385:     }
 61391:     NS_ENSURE_ARG(visits);
 61385: 
 91688:     uint32_t visitsLength = 0;
 61385:     if (visits) {
 61385:       (void)JS_GetArrayLength(aCtx, visits, &visitsLength);
 61385:     }
 61385:     NS_ENSURE_ARG(visitsLength > 0);
 61385: 
 61385:     // Check each visit, and build our array of VisitData objects.
 61385:     visitData.SetCapacity(visitData.Length() + visitsLength);
 91688:     for (uint32_t j = 0; j < visitsLength; j++) {
 61385:       JSObject* visit;
 61385:       rv = GetJSObjectFromArray(aCtx, visits, j, &visit);
 61385:       NS_ENSURE_SUCCESS(rv, rv);
 61385: 
 61385:       VisitData& data = *visitData.AppendElement(VisitData(uri));
 61385:       data.title = title;
 61385:       data.guid = guid;
 61385: 
 61385:       // We must have a date and a transaction type!
 61385:       rv = GetIntFromJSObject(aCtx, visit, "visitDate", &data.visitTime);
 61385:       NS_ENSURE_SUCCESS(rv, rv);
108991:       uint32_t transitionType = 0;
 61385:       rv = GetIntFromJSObject(aCtx, visit, "transitionType", &transitionType);
 61385:       NS_ENSURE_SUCCESS(rv, rv);
 61385:       NS_ENSURE_ARG_RANGE(transitionType,
 61385:                           nsINavHistoryService::TRANSITION_LINK,
 61385:                           nsINavHistoryService::TRANSITION_FRAMED_LINK);
 61385:       data.SetTransitionType(transitionType);
 94946:       data.hidden = GetHiddenState(false, transitionType);
 61385: 
 61385:       // If the visit is an embed visit, we do not actually add it to the
 61385:       // database.
 61385:       if (transitionType == nsINavHistoryService::TRANSITION_EMBED) {
 61385:         StoreAndNotifyEmbedVisit(data, aCallback);
 61385:         visitData.RemoveElementAt(visitData.Length() - 1);
 61385:         continue;
 61385:       }
 61385: 
 61385:       // The session id is optional.
 61385:       rv = GetIntFromJSObject(aCtx, visit, "sessionId", &data.sessionId);
 61385:       if (rv == NS_ERROR_INVALID_ARG) {
 61385:         data.sessionId = 0;
 61385:       }
 61385:       else {
 61385:         NS_ENSURE_SUCCESS(rv, rv);
 61385:       }
 61385: 
 61385:       // The referrer is optional.
 61385:       nsCOMPtr<nsIURI> referrer = GetURIFromJSObject(aCtx, visit,
 61385:                                                      "referrerURI");
 61385:       if (referrer) {
 61385:         (void)referrer->GetSpec(data.referrerSpec);
 61385:       }
 61385:     }
 61385:   }
 61385: 
 61389:   mozIStorageConnection* dbConn = GetDBConn();
 61389:   NS_ENSURE_STATE(dbConn);
 61389: 
 61387:   // It is possible that all of the visits we were passed were dissallowed by
 61387:   // CanAddURI, which isn't an error.  If we have no visits to add, however,
 61387:   // we should not call InsertVisitedURIs::Start.
 61387:   if (visitData.Length()) {
 61385:     nsresult rv = InsertVisitedURIs::Start(dbConn, visitData, aCallback);
 61385:     NS_ENSURE_SUCCESS(rv, rv);
 61387:   }
 61385: 
 77033:   // Be sure to notify that all of our operations are complete.  This
 77033:   // is dispatched to the background thread first and redirected to the
 77033:   // main thread from there to make sure that all database notifications
 77033:   // and all embed or canAddURI notifications have finished.
 77033:   if (aCallback) {
 77033:     // NotifyCompletion does not hold a strong reference to the callback,
 77033:     // so we have to manage it by AddRefing now. NotifyCompletion will
 77033:     // release it for us once it has dispatched the callback to the main
 77033:     // thread.
 77033:     NS_ADDREF(aCallback);
 77033: 
 61389:     nsCOMPtr<nsIEventTarget> backgroundThread = do_GetInterface(dbConn);
 61389:     NS_ENSURE_TRUE(backgroundThread, NS_ERROR_UNEXPECTED);
 77033:     nsCOMPtr<nsIRunnable> event = new NotifyCompletion(aCallback);
 77033:     (void)backgroundThread->Dispatch(event, NS_DISPATCH_NORMAL);
 77033:   }
 61389: 
 61385:   return NS_OK;
 60958: }
 60958: 
 82965: NS_IMETHODIMP
 82965: History::IsURIVisited(nsIURI* aURI,
 82965:                       mozIVisitedStatusCallback* aCallback)
 82965: {
 82965:   NS_ENSURE_STATE(NS_IsMainThread());
 82965:   NS_ENSURE_ARG(aURI);
 82965:   NS_ENSURE_ARG(aCallback);
 82965: 
 82965:   nsresult rv = VisitedQuery::Start(aURI, aCallback);
 82965:   NS_ENSURE_SUCCESS(rv, rv);
 82965: 
 82965:   return NS_OK;
 82965: }
 82965: 
 60958: ////////////////////////////////////////////////////////////////////////////////
 47715: //// nsIObserver
 47715: 
 47715: NS_IMETHODIMP
 47715: History::Observe(nsISupports* aSubject, const char* aTopic,
 47715:                  const PRUnichar* aData)
 47715: {
 47715:   if (strcmp(aTopic, TOPIC_PLACES_SHUTDOWN) == 0) {
 47715:     Shutdown();
 47715: 
 47715:     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
 47715:     if (os) {
 47715:       (void)os->RemoveObserver(this, TOPIC_PLACES_SHUTDOWN);
 47715:     }
 47715:   }
 47715: 
 47715:   return NS_OK;
 47715: }
 47715: 
 47715: ////////////////////////////////////////////////////////////////////////////////
 38166: //// nsISupports
 38166: 
 87813: NS_IMPL_THREADSAFE_ISUPPORTS4(
 47715:   History
 47715: , IHistory
 87813: , nsIDownloadHistory
 60958: , mozIAsyncHistory
 47715: , nsIObserver
 38166: )
 38166: 
 38166: } // namespace places
 38166: } // namespace mozilla
