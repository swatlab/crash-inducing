35778: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35778:  * vim: sw=4 ts=4 et :
35778:  */
35778: /* ***** BEGIN LICENSE BLOCK *****
35778:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35778:  *
35778:  * The contents of this file are subject to the Mozilla Public License Version
35778:  * 1.1 (the "License"); you may not use this file except in compliance with
35778:  * the License. You may obtain a copy of the License at
35778:  * http://www.mozilla.org/MPL/
35778:  *
35778:  * Software distributed under the License is distributed on an "AS IS" basis,
35778:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35778:  * for the specific language governing rights and limitations under the
35778:  * License.
35778:  *
35778:  * The Original Code is Mozilla Plugin App.
35778:  *
35778:  * The Initial Developer of the Original Code is
35778:  *   Chris Jones <jones.chris.g@gmail.com>
35778:  * Portions created by the Initial Developer are Copyright (C) 2009
35778:  * the Initial Developer. All Rights Reserved.
35778:  *
35778:  * Contributor(s):
35778:  *
35778:  * Alternatively, the contents of this file may be used under the terms of
35778:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35778:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35778:  * in which case the provisions of the GPL or the LGPL are applicable instead
35778:  * of those above. If you wish to allow use of your version of this file only
35778:  * under the terms of either the GPL or the LGPL, and not to allow others to
35778:  * use your version of this file under the terms of the MPL, indicate your
35778:  * decision by deleting the provisions above and replace them with the notice
35778:  * and other provisions required by the GPL or the LGPL. If you do not delete
35778:  * the provisions above, a recipient may use your version of this file under
35778:  * the terms of any one of the MPL, the GPL or the LGPL.
35778:  *
35778:  * ***** END LICENSE BLOCK ***** */
35778: 
35778: #include "mozilla/ipc/AsyncChannel.h"
37884: #include "mozilla/ipc/BrowserProcessSubThread.h"
36140: #include "mozilla/ipc/ProtocolUtils.h"
35778: 
35778: #include "nsDebug.h"
36081: #include "nsTraceRefcnt.h"
35869: #include "nsXULAppAPI.h"
35778: 
35882: using mozilla::MutexAutoLock;
35882: 
35778: template<>
35778: struct RunnableMethodTraits<mozilla::ipc::AsyncChannel>
35778: {
35778:     static void RetainCallee(mozilla::ipc::AsyncChannel* obj) { }
35778:     static void ReleaseCallee(mozilla::ipc::AsyncChannel* obj) { }
35778: };
35778: 
38099: namespace {
38099: 
38099: // This is an async message
38099: class GoodbyeMessage : public IPC::Message
38099: {
38099: public:
38099:     enum { ID = GOODBYE_MESSAGE_TYPE };
38099:     GoodbyeMessage() :
38099:         IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL)
38099:     {
38099:     }
38099:     // XXX not much point in implementing this; maybe could help with
38099:     // debugging?
38099:     static bool Read(const Message* msg)
38099:     {
38099:         return true;
38099:     }
38099:     void Log(const std::string& aPrefix,
38099:              FILE* aOutf) const
38099:     {
38099:         fputs("(special `Goodbye' message)", aOutf);
38099:     }
38099: };
38099: 
38099: } // namespace <anon>
38099: 
35778: namespace mozilla {
35778: namespace ipc {
35778: 
36078: AsyncChannel::AsyncChannel(AsyncListener* aListener)
36078:   : mTransport(0),
36078:     mListener(aListener),
36078:     mChannelState(ChannelClosed),
36078:     mMutex("mozilla.ipc.AsyncChannel.mMutex"),
36078:     mCvar(mMutex, "mozilla.ipc.AsyncChannel.mCvar"),
36078:     mIOLoop(),
36607:     mWorkerLoop(),
38102:     mChild(false),
36607:     mChannelErrorTask(NULL)
36078: {
36078:     MOZ_COUNT_CTOR(AsyncChannel);
36078: }
36078: 
36078: AsyncChannel::~AsyncChannel()
36078: {
36078:     MOZ_COUNT_DTOR(AsyncChannel);
36140:     Clear();
36078: }
36078: 
35778: bool
35778: AsyncChannel::Open(Transport* aTransport, MessageLoop* aIOLoop)
35778: {
35778:     NS_PRECONDITION(!mTransport, "Open() called > once");
35778:     NS_PRECONDITION(aTransport, "need transport layer");
35778: 
35778:     // FIXME need to check for valid channel
35778: 
35778:     mTransport = aTransport;
35778:     mTransport->set_listener(this);
35778: 
35779:     // FIXME figure out whether we're in parent or child, grab IO loop
35779:     // appropriately
35778:     bool needOpen = true;
35778:     if(!aIOLoop) {
35779:         // parent
35778:         needOpen = false;
35778:         aIOLoop = BrowserProcessSubThread
35778:                   ::GetMessageLoop(BrowserProcessSubThread::IO);
35779:         // FIXME assuming that the parent waits for the OnConnected event.
35779:         // FIXME see GeckoChildProcessHost.cpp.  bad assumption!
35859:         mChannelState = ChannelConnected;
35778:     }
35778: 
35974:     mChild = needOpen;
35974: 
35778:     mIOLoop = aIOLoop;
35778:     mWorkerLoop = MessageLoop::current();
35778: 
35778:     NS_ASSERTION(mIOLoop, "need an IO loop");
35778:     NS_ASSERTION(mWorkerLoop, "need a worker loop");
35778: 
35882:     if (needOpen) {             // child process
35882:         MutexAutoLock lock(mMutex);
35882: 
35778:         mIOLoop->PostTask(FROM_HERE, 
35778:                           NewRunnableMethod(this,
35778:                                             &AsyncChannel::OnChannelOpened));
35882: 
35882:         // FIXME/cjones: handle errors
35882:         while (mChannelState != ChannelConnected) {
35882:             mCvar.Wait();
35882:         }
35778:     }
35778: 
35778:     return true;
35778: }
35778: 
35778: void
35778: AsyncChannel::Close()
35778: {
38106:     AssertWorkerThread();
38106: 
36140:     {
36070:         MutexAutoLock lock(mMutex);
36063: 
38106:         if (ChannelError == mChannelState ||
38106:             ChannelTimeout == mChannelState) {
37198:             // See bug 538586: if the listener gets deleted while the
37198:             // IO thread's NotifyChannelError event is still enqueued
37198:             // and subsequently deletes us, then the error event will
37198:             // also be deleted and the listener will never be notified
37198:             // of the channel error.
37198:             if (mListener) {
38299:                 MutexAutoUnlock unlock(mMutex);
37198:                 NotifyMaybeChannelError();
37198:             }
36607:             return;
37198:         }
36607: 
36140:         if (ChannelConnected != mChannelState)
36140:             // XXX be strict about this until there's a compelling reason
36140:             // to relax
36140:             NS_RUNTIMEABORT("Close() called on closed channel!");
36140: 
36063:         AssertWorkerThread();
36063: 
36140:         // notify the other side that we're about to close our socket
38099:         SendSpecialMessage(new GoodbyeMessage());
36140: 
38106:         SynchronouslyClose();
38106:     }
36140: 
38299:     NotifyChannelClosed();
38106: }
38106: 
38106: void 
38106: AsyncChannel::SynchronouslyClose()
38106: {
38106:     AssertWorkerThread();
38106:     mMutex.AssertCurrentThreadOwns();
38106: 
36063:     mIOLoop->PostTask(
36140:         FROM_HERE, NewRunnableMethod(this, &AsyncChannel::OnCloseChannel));
36063: 
38106:     while (ChannelClosed != mChannelState)
36063:         mCvar.Wait();
35778: }
35778: 
35778: bool
35778: AsyncChannel::Send(Message* msg)
35778: {
35971:     AssertWorkerThread();
35977:     mMutex.AssertNotCurrentThreadOwns();
35940:     NS_ABORT_IF_FALSE(MSG_ROUTING_NONE != msg->routing_id(), "need a route");
35940: 
35977:     {
35977:         MutexAutoLock lock(mMutex);
35977: 
36015:         if (!Connected()) {
36015:             ReportConnectionError("AsyncChannel");
35940:             return false;
36015:         }
35779: 
35778:         mIOLoop->PostTask(FROM_HERE,
35778:                           NewRunnableMethod(this, &AsyncChannel::OnSend, msg));
35977:     }
35977: 
35778:     return true;
35778: }
35778: 
35778: void
35778: AsyncChannel::OnDispatchMessage(const Message& msg)
35778: {
35971:     AssertWorkerThread();
35778:     NS_ASSERTION(!msg.is_reply(), "can't process replies here");
35778:     NS_ASSERTION(!(msg.is_sync() || msg.is_rpc()), "async dispatch only");
35778: 
38099:     if (MSG_ROUTING_NONE == msg.routing_id()) {
38099:         if (!OnSpecialMessage(msg.type(), msg))
38099:             // XXX real error handling
38099:             NS_RUNTIMEABORT("unhandled special message!");
36140:         return;
38099:     }
36140: 
36140:     // it's OK to dispatch messages if the channel is closed/error'd,
36140:     // since we don't have a reply to send back
36140: 
36015:     (void)MaybeHandleError(mListener->OnMessageReceived(msg), "AsyncChannel");
36015: }
35778: 
38099: bool
38099: AsyncChannel::OnSpecialMessage(uint16 id, const Message& msg)
36140: {
38099:     switch (id) {
38099:     case GOODBYE_MESSAGE_TYPE:
38099:         return ProcessGoodbyeMessage();
38099: 
38099:     default:
38099:         return false;
36140:     }
36140: }
36140: 
36140: void
38099: AsyncChannel::SendSpecialMessage(Message* msg)
36140: {
36140:     AssertWorkerThread();
36140: 
36140:     mIOLoop->PostTask(
36140:         FROM_HERE,
38099:         NewRunnableMethod(this, &AsyncChannel::OnSend, msg));
36140: }
36140: 
36140: bool
38099: AsyncChannel::ProcessGoodbyeMessage()
36140: {
36140:     MutexAutoLock lock(mMutex);
36140:     // TODO sort out Close() on this side racing with Close() on the
36140:     // other side
36140:     mChannelState = ChannelClosing;
36140: 
36140:     printf("NOTE: %s process received `Goodbye', closing down\n",
36140:            mChild ? "child" : "parent");
36140: 
36140:     return true;
36140: }
36140: 
36140: void
36140: AsyncChannel::NotifyChannelClosed()
36140: {
38299:     mMutex.AssertNotCurrentThreadOwns();
38299: 
36140:     if (ChannelClosed != mChannelState)
36140:         NS_RUNTIMEABORT("channel should have been closed!");
36140: 
36140:     // OK, the IO thread just closed the channel normally.  Let the
36140:     // listener know about it.
36140:     mListener->OnChannelClose();
38299: 
36140:     Clear();
36140: }
36140: 
36140: void
36140: AsyncChannel::NotifyMaybeChannelError()
36140: {
38299:     mMutex.AssertNotCurrentThreadOwns();
38299: 
38299:     // OnChannelError holds mMutex when it posts this task and this task cannot
38299:     // be allowed to run until OnChannelError has exited. We enforce that order
38299:     // by grabbing the mutex here which should only continue once OnChannelError
38299:     // has completed.
38299:     {
38299:         MutexAutoLock lock(mMutex);
38299:         // Nothing to do here!
38299:     }
38299: 
36140:     // TODO sort out Close() on this side racing with Close() on the
36140:     // other side
36140:     if (ChannelClosing == mChannelState) {
36140:         // the channel closed, but we received a "Goodbye" message
36140:         // warning us about it. no worries
36140:         mChannelState = ChannelClosed;
38299:         NotifyChannelClosed();
38299:         return;
36140:     }
36140: 
36140:     // Oops, error!  Let the listener know about it.
36140:     mChannelState = ChannelError;
36140:     mListener->OnChannelError();
36140: 
36140:     Clear();
36140: }
36140: 
36140: void
36140: AsyncChannel::Clear()
36140: {
36140:     mListener = 0;
36140:     mIOLoop = 0;
36140:     mWorkerLoop = 0;
36140: 
36140:     if (mTransport) {
36140:         mTransport->set_listener(0);
36140: 
36140:         // we only hold a weak ref to the transport, which is "owned"
36140:         // by GeckoChildProcess/GeckoThread
36140:         mTransport = 0;
36140:     }
36607:     if (mChannelErrorTask) {
36607:         mChannelErrorTask->Cancel();
36607:         mChannelErrorTask = NULL;
36607:     }
36140: }
36140: 
36015: bool
36015: AsyncChannel::MaybeHandleError(Result code, const char* channelName)
36015: {
36015:     if (MsgProcessed == code)
36015:         return true;
36015: 
36015:     const char* errorMsg;
36015:     switch (code) {
35786:     case MsgNotKnown:
36015:         errorMsg = "Unknown message: not processed";
36015:         break;
35786:     case MsgNotAllowed:
36015:         errorMsg = "Message not allowed: cannot be sent/recvd in this state";
36015:         break;
35786:     case MsgPayloadError:
36015:         errorMsg = "Payload error: message could not be deserialized";
36015:         break;
35786:     case MsgRouteError:
36015:         errorMsg = "Route error: message sent to unknown actor ID";
36015:         break;
35786:     case MsgValueError:
36015:         errorMsg = "Value error: message was deserialized, but contained an illegal value";
36015:         break;
35778: 
35778:     default:
36140:         NS_RUNTIMEABORT("unknown Result code");
36015:         return false;
35778:     }
36015: 
36015:     PrintErrorMessage(channelName, errorMsg);
36015:     return false;
36015: }
36015: 
36015: void
36015: AsyncChannel::ReportConnectionError(const char* channelName)
36015: {
36015:     const char* errorMsg;
36015:     switch (mChannelState) {
36015:     case ChannelClosed:
36015:         errorMsg = "Closed channel: cannot send/recv";
36015:         break;
36015:     case ChannelOpening:
36015:         errorMsg = "Opening channel: not yet ready for send/recv";
36015:         break;
38106:     case ChannelTimeout:
38106:         errorMsg = "Channel timeout: cannot send/recv";
36015:     case ChannelError:
36015:         errorMsg = "Channel error: cannot send/recv";
36015:         break;
36015: 
36015:     default:
36015:         NOTREACHED();
36015:     }
36015: 
36015:     PrintErrorMessage(channelName, errorMsg);
35778: }
35778: 
35778: //
36140: // The methods below run in the context of the IO thread
35778: //
35778: 
35778: void
35778: AsyncChannel::OnMessageReceived(const Message& msg)
35778: {
35971:     AssertIOThread();
35869:     NS_ASSERTION(mChannelState != ChannelError, "Shouldn't get here!");
35869: 
35778:     // wake up the worker, there's work to do
35977:     mWorkerLoop->PostTask(
35977:         FROM_HERE,
35977:         NewRunnableMethod(this, &AsyncChannel::OnDispatchMessage, msg));
35778: }
35778: 
35778: void
36140: AsyncChannel::OnChannelOpened()
36140: {
36140:     AssertIOThread();
36140:     mChannelState = ChannelOpening;
36140:     /*assert*/mTransport->Connect();
36140: }
36140: 
36140: void
35778: AsyncChannel::OnChannelConnected(int32 peer_pid)
35778: {
35971:     AssertIOThread();
35977: 
35882:     MutexAutoLock lock(mMutex);
35859:     mChannelState = ChannelConnected;
35882:     mCvar.Notify();
35778: }
35778: 
35778: void
35778: AsyncChannel::OnChannelError()
35778: {
35971:     AssertIOThread();
35977: 
35977:     MutexAutoLock lock(mMutex);
36140: 
36140:     // NB: this can race with the `Goodbye' event being processed by
36140:     // the worker thread
36140:     if (ChannelClosing != mChannelState)
35778:         mChannelState = ChannelError;
35869: 
36607:     NS_ASSERTION(!mChannelErrorTask, "OnChannelError called twice?");
36607: 
38316:     // This must be the last code that runs on this thread!
36607:     mChannelErrorTask =
36607:         NewRunnableMethod(this, &AsyncChannel::NotifyMaybeChannelError);
36607:     mWorkerLoop->PostTask(FROM_HERE, mChannelErrorTask);
35778: }
35778: 
35778: void
35778: AsyncChannel::OnSend(Message* aMsg)
35778: {
35971:     AssertIOThread();
35778:     mTransport->Send(aMsg);
36140:     // mTransport assumes ownership of aMsg
35778: }
35778: 
36063: void
36140: AsyncChannel::OnCloseChannel()
36063: {
36063:     AssertIOThread();
36063: 
36063:     mTransport->Close();
36063: 
36140:     MutexAutoLock lock(mMutex);
36063:     mChannelState = ChannelClosed;
36063:     mCvar.Notify();
36063: }
36063: 
35778: 
35778: } // namespace ipc
35778: } // namespace mozilla
