 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 18084:  * vim: set ts=8 sw=4 et tw=99:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS parser.
     1:  *
     1:  * This is a recursive-descent parser for the JavaScript language specified by
     1:  * "The JavaScript 1.5 Language Specification".  It uses lexical and semantic
     1:  * feedback to disambiguate non-LL(1) structures.  It generates trees of nodes
 80634:  * induced by the recursive parsing (not precise syntax trees, see Parser.h).
     1:  * After tree construction, it rewrites trees to fold constants and evaluate
 98175:  * compile-time expressions.
     1:  *
     1:  * This parser attempts no error recovery.
     1:  */
 80507: 
 80507: #include "frontend/Parser.h"
 80507: 
     1: #include <stdlib.h>
     1: #include <string.h>
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
     1: #include "jsapi.h"
     1: #include "jsarray.h"
     1: #include "jsatom.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsfun.h"
 68933: #include "jsgc.h"
     1: #include "jsinterp.h"
 15613: #include "jsiter.h"
     1: #include "jslock.h"
     1: #include "jsnum.h"
     1: #include "jsobj.h"
     1: #include "jsopcode.h"
     1: #include "jsscope.h"
     1: #include "jsscript.h"
     1: #include "jsstr.h"
 80507: 
 80507: #include "frontend/FoldConstants.h"
 80507: #include "frontend/ParseMaps.h"
 98180: #include "frontend/Parser.h"
 80506: #include "frontend/TokenStream.h"
 97569: #include "gc/Marking.h"
 80506: 
     1: #if JS_HAS_XML_SUPPORT
     1: #include "jsxml.h"
     1: #endif
     1: 
 48470: #include "jsatominlines.h"
 59968: #include "jsscriptinlines.h"
 50491: 
 72579: #include "frontend/ParseMaps-inl.h"
 80507: #include "frontend/ParseNode-inl.h"
104045: #include "frontend/TreeContext-inl.h"
 79981: #include "vm/RegExpObject-inl.h"
 48470: 
 40221: using namespace js;
 54707: using namespace js::gc;
 80632: using namespace js::frontend;
 40221: 
     1: /*
     1:  * Insist that the next token be of type tt, or report errno and return null.
     1:  * NB: this macro uses cx and ts from its lexical environment.
     1:  */
 40854: #define MUST_MATCH_TOKEN_WITH_FLAGS(tt, errno, __flags)                                     \
     1:     JS_BEGIN_MACRO                                                                          \
 40854:         if (tokenStream.getToken((__flags)) != tt) {                                        \
102849:             reportError(NULL, errno);                                                       \
     1:             return NULL;                                                                    \
     1:         }                                                                                   \
     1:     JS_END_MACRO
 40854: #define MUST_MATCH_TOKEN(tt, errno) MUST_MATCH_TOKEN_WITH_FLAGS(tt, errno, 0)
     1: 
104093: StrictMode::StrictModeState
 99779: StrictModeGetter::get() const
 99779: {
104093:     return parser->tc->sc->strictModeState;
104093: }
104093: 
104093: CompileError *
104093: StrictModeGetter::queuedStrictModeError() const
104093: {
104093:     return parser->tc->queuedStrictModeError;
104093: }
104093: 
104093: void
104093: StrictModeGetter::setQueuedStrictModeError(CompileError *e)
104093: {
104093:     parser->tc->setQueuedStrictModeError(e);
 99779: }
 99779: 
103227: static void
104045: PushStatementTC(TreeContext *tc, StmtInfoTC *stmt, StmtType type)
104045: {
104045:     stmt->blockid = tc->blockid();
104045:     PushStatement(tc, stmt, type);
103857:     stmt->isFunctionBodyBlock = false;
103227: }
103227: 
 84691: Parser::Parser(JSContext *cx, JSPrincipals *prin, JSPrincipals *originPrin,
 99261:                const jschar *chars, size_t length, const char *fn, unsigned ln, JSVersion v,
102617:                bool foldConstants, bool compileAndGo)
 80748:   : AutoGCRooter(cx, PARSER),
 53840:     context(cx),
 99779:     strictModeGetter(this),
 99779:     tokenStream(cx, prin, originPrin, chars, length, fn, ln, v, &strictModeGetter),
 99261:     tempPoolMark(NULL),
 80641:     allocator(cx),
 53840:     traceListHead(NULL),
104045:     tc(NULL),
 72098:     keepAtoms(cx->runtime),
 98464:     foldConstants(foldConstants),
 98464:     compileAndGo(compileAndGo)
 53840: {
 72579:     cx->activeCompilations++;
 53840: }
 53840: 
 27012: bool
 99261: Parser::init()
 99261: {
 99261:     if (!context->ensureParseMapPool())
 72579:         return false;
 99779: 
 99261:     tempPoolMark = context->tempLifoAlloc().mark();
 27012:     return true;
 27012: }
 27012: 
 40860: Parser::~Parser()
 27012: {
 27012:     JSContext *cx = context;
 79410:     cx->tempLifoAlloc().release(tempPoolMark);
 72579:     cx->activeCompilations--;
 26970: }
 26970: 
 98708: ObjectBox::ObjectBox(ObjectBox* traceLink, JSObject *obj)
 98708:   : traceLink(traceLink),
 98708:     emitLink(NULL),
 98708:     object(obj),
 98708:     isFunctionBox(false)
 98708: {
 98708: }
 98708: 
 80631: ObjectBox *
 40860: Parser::newObjectBox(JSObject *obj)
 27012: {
 95355:     JS_ASSERT(obj && !IsPoisonedPtr(obj));
 95355: 
  3235:     /*
 80743:      * We use JSContext.tempLifoAlloc to allocate parsed objects and place them
 80743:      * on a list in this Parser to ensure GC safety. Thus the tempLifoAlloc
 80743:      * arenas containing the entries must be alive until we are done with
 80743:      * scanning, parsing and code generation for the whole script or top-level
 80743:      * function.
  3235:      */
 98708: 
 98708:     ObjectBox *objbox = context->tempLifoAlloc().new_<ObjectBox>(traceListHead, obj);
 27012:     if (!objbox) {
 71371:         js_ReportOutOfMemory(context);
 27012:         return NULL;
 27012:     }
 98708: 
 27012:     traceListHead = objbox;
 98708: 
 27012:     return objbox;
 27012: }
 27012: 
104093: FunctionBox::FunctionBox(ObjectBox* traceListHead, JSObject *obj, ParseNode *fn, TreeContext *tc,
104093:                          StrictMode::StrictModeState sms)
 98708:   : ObjectBox(traceListHead, obj),
 98708:     node(fn),
104045:     siblings(tc->functionList),
 98708:     kids(NULL),
104045:     parent(tc->sc->inFunction() ? tc->sc->funbox() : NULL),
102615:     bindings(),
104045:     level(tc->staticLevel),
100154:     ndefaults(0),
104093:     strictModeState(sms),
 98708:     inLoop(false),
104045:     inWith(!!tc->innermostWith),
 98708:     inGenexpLambda(false),
104045:     cxFlags(tc->sc->context)     // the cxFlags are set in LeaveFunction
 98708: {
 98708:     isFunctionBox = true;
104045:     for (StmtInfoTC *stmt = tc->topStmt; stmt; stmt = stmt->down) {
103854:         if (stmt->isLoop()) {
 98708:             inLoop = true;
 98708:             break;
 98708:         }
 98708:     }
104045:     if (!tc->sc->inFunction()) {
104045:         JSObject *scope = tc->sc->scopeChain();
 98708:         while (scope) {
 98708:             if (scope->isWith())
 98708:                 inWith = true;
 98708:             scope = scope->enclosingScope();
 98708:         }
 98708:     }
 98708: }
 98708: 
 80631: FunctionBox *
104093: Parser::newFunctionBox(JSObject *obj, ParseNode *fn, TreeContext *tc,
104093:                        StrictMode::StrictModeState sms)
 27012: {
 95355:     JS_ASSERT(obj && !IsPoisonedPtr(obj));
 40430:     JS_ASSERT(obj->isFunction());
 27012: 
 27012:     /*
 80743:      * We use JSContext.tempLifoAlloc to allocate parsed objects and place them
 80743:      * on a list in this Parser to ensure GC safety. Thus the tempLifoAlloc
 80743:      * arenas containing the entries must be alive until we are done with
 80743:      * scanning, parsing and code generation for the whole script or top-level
 80743:      * function.
 27012:      */
104093:     FunctionBox *funbox = context->tempLifoAlloc().new_<FunctionBox>(traceListHead, obj, fn, tc, sms);
 27012:     if (!funbox) {
 71371:         js_ReportOutOfMemory(context);
 27012:         return NULL;
 27012:     }
 98708: 
104045:     traceListHead = tc->functionList = funbox;
 98687: 
 27012:     return funbox;
 27012: }
 26970: 
 26970: void
 40860: Parser::trace(JSTracer *trc)
 27012: {
 80631:     ObjectBox *objbox = traceListHead;
 27012:     while (objbox) {
 90409:         MarkObjectRoot(trc, &objbox->object, "parser.object");
 59968:         if (objbox->isFunctionBox)
 80631:             static_cast<FunctionBox *>(objbox)->bindings.trace(trc);
 27012:         objbox = objbox->traceLink;
 27012:     }
 59968: 
104045:     for (TreeContext *tc = this->tc; tc; tc = tc->parent)
104045:         tc->trace(trc);
 27012: }
 27012: 
 27012: static bool
104045: GenerateBlockIdForStmtNode(ParseNode *pn, TreeContext *tc)
104045: {
104045:     JS_ASSERT(tc->topStmt);
104045:     JS_ASSERT(tc->topStmt->maybeScope());
 82873:     JS_ASSERT(pn->isKind(PNK_STATEMENTLIST) || pn->isKind(PNK_LEXICALSCOPE));
104045:     if (!GenerateBlockId(tc, tc->topStmt->blockid))
 27012:         return false;
104045:     pn->pn_blockid = tc->topStmt->blockid;
 27012:     return true;
 27012: }
 27012: 
     1: /*
     1:  * Parse a top-level JS script.
     1:  */
 80631: ParseNode *
 40860: Parser::parse(JSObject *chain)
 27012: {
     1:     /*
     1:      * Protect atoms from being collected by a GC activation, which might
     1:      * - nest on this thread due to out of memory (the so-called "last ditch"
     1:      *   GC attempted within js_NewGCThing), or
     1:      * - run for any reason on another thread if this thread is suspended on
     1:      *   an object lock before it finishes generating bytecode into a script
     1:      *   protected from the GC by a root or a stack frame reference.
     1:      */
104093:     SharedContext globalsc(context, chain, /* fun = */ NULL, /* funbox = */ NULL,
104093:                            StrictModeFromContext(context));
104045:     TreeContext globaltc(this, &globalsc, /* staticLevel = */ 0, /* bodyid = */ 0);
104045:     if (!globaltc.init())
 72579:         return NULL;
 40263: 
 80631:     ParseNode *pn = statements();
     1:     if (pn) {
 40354:         if (!tokenStream.matchToken(TOK_EOF)) {
102849:             reportError(NULL, JSMSG_SYNTAX_ERROR);
     1:             pn = NULL;
 72098:         } else if (foldConstants) {
 98181:             if (!FoldConstants(context, pn, this))
     1:                 pn = NULL;
     1:         }
     1:     }
     1:     return pn;
     1: }
     1: 
     1: /*
     1:  * Insist on a final return before control flows out of pn.  Try to be a bit
     1:  * smart about loops: do {...; return e2;} while(0) at the end of a function
     1:  * that contains an early return e1 will get a strict warning.  Similarly for
     1:  * iloops: while (true){...} is treated as though ... returns.
     1:  */
     1: #define ENDS_IN_OTHER   0
     1: #define ENDS_IN_RETURN  1
     1: #define ENDS_IN_BREAK   2
     1: 
     1: static int
 80631: HasFinalReturn(ParseNode *pn)
 80631: {
 80631:     ParseNode *pn2, *pn3;
 91237:     unsigned rv, rv2, hasDefault;
     1: 
 78294:     switch (pn->getKind()) {
 82873:       case PNK_STATEMENTLIST:
     1:         if (!pn->pn_head)
     1:             return ENDS_IN_OTHER;
 27012:         return HasFinalReturn(pn->last());
     1: 
 82024:       case PNK_IF:
     1:         if (!pn->pn_kid3)
     1:             return ENDS_IN_OTHER;
     1:         return HasFinalReturn(pn->pn_kid2) & HasFinalReturn(pn->pn_kid3);
     1: 
 82024:       case PNK_WHILE:
     1:         pn2 = pn->pn_left;
 82024:         if (pn2->isKind(PNK_TRUE))
     1:             return ENDS_IN_RETURN;
 82024:         if (pn2->isKind(PNK_NUMBER) && pn2->pn_dval)
     1:             return ENDS_IN_RETURN;
     1:         return ENDS_IN_OTHER;
     1: 
 82872:       case PNK_DOWHILE:
     1:         pn2 = pn->pn_right;
 82024:         if (pn2->isKind(PNK_FALSE))
     1:             return HasFinalReturn(pn->pn_left);
 82024:         if (pn2->isKind(PNK_TRUE))
     1:             return ENDS_IN_RETURN;
 82024:         if (pn2->isKind(PNK_NUMBER)) {
     1:             if (pn2->pn_dval == 0)
     1:                 return HasFinalReturn(pn->pn_left);
     1:             return ENDS_IN_RETURN;
     1:         }
     1:         return ENDS_IN_OTHER;
     1: 
 82024:       case PNK_FOR:
     1:         pn2 = pn->pn_left;
 78294:         if (pn2->isArity(PN_TERNARY) && !pn2->pn_kid2)
     1:             return ENDS_IN_RETURN;
     1:         return ENDS_IN_OTHER;
     1: 
 82024:       case PNK_SWITCH:
     1:         rv = ENDS_IN_RETURN;
     1:         hasDefault = ENDS_IN_OTHER;
     1:         pn2 = pn->pn_right;
 82024:         if (pn2->isKind(PNK_LEXICALSCOPE))
 27012:             pn2 = pn2->expr();
     1:         for (pn2 = pn2->pn_head; rv && pn2; pn2 = pn2->pn_next) {
 82024:             if (pn2->isKind(PNK_DEFAULT))
     1:                 hasDefault = ENDS_IN_RETURN;
     1:             pn3 = pn2->pn_right;
 82873:             JS_ASSERT(pn3->isKind(PNK_STATEMENTLIST));
     1:             if (pn3->pn_head) {
 27012:                 rv2 = HasFinalReturn(pn3->last());
     1:                 if (rv2 == ENDS_IN_OTHER && pn2->pn_next)
     1:                     /* Falling through to next case or default. */;
     1:                 else
     1:                     rv &= rv2;
     1:             }
     1:         }
     1:         /* If a final switch has no default case, we judge it harshly. */
     1:         rv &= hasDefault;
     1:         return rv;
     1: 
 82024:       case PNK_BREAK:
     1:         return ENDS_IN_BREAK;
     1: 
 82024:       case PNK_WITH:
     1:         return HasFinalReturn(pn->pn_right);
     1: 
 82024:       case PNK_RETURN:
     1:         return ENDS_IN_RETURN;
     1: 
 82024:       case PNK_COLON:
 82024:       case PNK_LEXICALSCOPE:
 27012:         return HasFinalReturn(pn->expr());
     1: 
 82024:       case PNK_THROW:
     1:         return ENDS_IN_RETURN;
     1: 
 82024:       case PNK_TRY:
     1:         /* If we have a finally block that returns, we are done. */
     1:         if (pn->pn_kid3) {
     1:             rv = HasFinalReturn(pn->pn_kid3);
     1:             if (rv == ENDS_IN_RETURN)
     1:                 return rv;
     1:         }
     1: 
     1:         /* Else check the try block and any and all catch statements. */
     1:         rv = HasFinalReturn(pn->pn_kid1);
     1:         if (pn->pn_kid2) {
 78294:             JS_ASSERT(pn->pn_kid2->isArity(PN_LIST));
     1:             for (pn2 = pn->pn_kid2->pn_head; pn2; pn2 = pn2->pn_next)
     1:                 rv &= HasFinalReturn(pn2);
     1:         }
     1:         return rv;
     1: 
 82024:       case PNK_CATCH:
     1:         /* Check this catch block's body. */
     1:         return HasFinalReturn(pn->pn_kid3);
     1: 
 82024:       case PNK_LET:
     1:         /* Non-binary let statements are let declarations. */
 78294:         if (!pn->isArity(PN_BINARY))
     1:             return ENDS_IN_OTHER;
     1:         return HasFinalReturn(pn->pn_right);
     1: 
     1:       default:
     1:         return ENDS_IN_OTHER;
     1:     }
     1: }
     1: 
103824: static bool
102849: ReportBadReturn(JSContext *cx, Parser *parser, ParseNode *pn, Parser::Reporter reporter,
102849:                 unsigned errnum, unsigned anonerrnum)
     1: {
 57812:     JSAutoByteString name;
104045:     if (parser->tc->sc->fun()->atom) {
104045:         if (!js_AtomToPrintableString(cx, parser->tc->sc->fun()->atom, &name))
 57812:             return false;
     1:     } else {
     1:         errnum = anonerrnum;
 57812:     }
102849:     return (parser->*reporter)(pn, errnum, name.ptr());
     1: }
     1: 
103824: static bool
 98181: CheckFinalReturn(JSContext *cx, Parser *parser, ParseNode *pn)
 98181: {
104045:     JS_ASSERT(parser->tc->sc->inFunction());
     1:     return HasFinalReturn(pn) == ENDS_IN_RETURN ||
102849:            ReportBadReturn(cx, parser, pn, &Parser::reportStrictWarning,
     1:                            JSMSG_NO_RETURN_VALUE, JSMSG_ANON_NO_RETURN_VALUE);
     1: }
     1: 
 35323: /*
 35324:  * Check that it is permitted to assign to lhs.  Strict mode code may not
 35324:  * assign to 'eval' or 'arguments'.
 35324:  */
 80507: static bool
 98181: CheckStrictAssignment(JSContext *cx, Parser *parser, ParseNode *lhs)
 98181: {
104045:     if (parser->tc->sc->needStrictChecks() && lhs->isKind(PNK_NAME)) {
 35324:         JSAtom *atom = lhs->pn_atom;
 35324:         JSAtomState *atomState = &cx->runtime->atomState;
 35324:         if (atom == atomState->evalAtom || atom == atomState->argumentsAtom) {
 57812:             JSAutoByteString name;
 57812:             if (!js_AtomToPrintableString(cx, atom, &name) ||
102849:                 !parser->reportStrictModeError(lhs, JSMSG_DEPRECATED_ASSIGN, name.ptr()))
 99779:             {
 35324:                 return false;
 35324:             }
 35324:         }
 35324:     }
 35324:     return true;
 35324: }
 35324: 
 35324: /*
 62048:  * Check that it is permitted to introduce a binding for atom.  Strict mode
 62048:  * forbids introducing new definitions for 'eval', 'arguments', or for any
 62048:  * strict mode reserved keyword.  Use pn for reporting error locations, or use
104045:  * tc's token stream if pn is NULL.
 35325:  */
 35325: bool
 98181: CheckStrictBinding(JSContext *cx, Parser *parser, PropertyName *name, ParseNode *pn)
 98181: {
104045:     if (!parser->tc->sc->needStrictChecks())
 35325:         return true;
 35325: 
 35325:     JSAtomState *atomState = &cx->runtime->atomState;
 80442:     if (name == atomState->evalAtom ||
 80442:         name == atomState->argumentsAtom ||
 80442:         FindKeyword(name->charsZ(), name->length()))
 80442:     {
 80442:         JSAutoByteString bytes;
 80442:         if (!js_AtomToPrintableString(cx, name, &bytes))
 35325:             return false;
102849:         return parser->reportStrictModeError(pn, JSMSG_BAD_BINDING, bytes.ptr());
 35325:     }
 62048: 
 35325:     return true;
 35325: }
 35325: 
 35323: static bool
 98181: ReportBadParameter(JSContext *cx, Parser *parser, JSAtom *name, unsigned errorNumber)
 98181: {
104045:     Definition *dn = parser->tc->decls.lookupFirst(name);
 62048:     JSAutoByteString bytes;
 62048:     return js_AtomToPrintableString(cx, name, &bytes) &&
102849:            parser->reportStrictModeError(dn, errorNumber, bytes.ptr());
 62048: }
 62048: 
 62048: /*
 62048:  * In strict mode code, all parameter names must be distinct, must not be
 62048:  * strict mode reserved keywords, and must not be 'eval' or 'arguments'.  We
 62048:  * must perform these checks here, and not eagerly during parsing, because a
 62048:  * function's body may turn on strict mode for the function head.
 62048:  */
 95100: static bool
 98181: CheckStrictParameters(JSContext *cx, Parser *parser)
 98181: {
104045:     SharedContext *sc = parser->tc->sc;
100230:     JS_ASSERT(sc->inFunction());
 98445: 
 98445:     if (!sc->needStrictChecks() || sc->bindings.numArgs() == 0)
 35323:         return true;
 35323: 
 62048:     JSAtom *argumentsAtom = cx->runtime->atomState.argumentsAtom;
 62048:     JSAtom *evalAtom = cx->runtime->atomState.evalAtom;
 62048: 
 62063:     /* name => whether we've warned about the name already */
 62063:     HashMap<JSAtom *, bool> parameters(cx);
 98445:     if (!parameters.init(sc->bindings.numArgs()))
 35323:         return false;
 62048: 
102615:     // Start with lastVariable(), not the last argument, for destructuring.
104384:     Shape::Range r = sc->bindings.lastVariable();
104384:     Shape::Range::AutoRooter root(cx, &r);
104384: 
104384:     for (; !r.empty(); r.popFront()) {
 83221:         jsid id = r.front().propid();
 62048:         if (!JSID_IS_ATOM(id))
 62048:             continue;
 62048: 
 62048:         JSAtom *name = JSID_TO_ATOM(id);
 62048: 
 62048:         if (name == argumentsAtom || name == evalAtom) {
 98181:             if (!ReportBadParameter(cx, parser, name, JSMSG_BAD_BINDING))
 35325:                 return false;
 35325:         }
 62048: 
104093:         if (sc->needStrictChecks() && FindKeyword(name->charsZ(), name->length())) {
 62048:             /*
 62048:              * JSOPTION_STRICT is supposed to warn about future keywords, too,
 62048:              * but we took care of that in the scanner.
 62048:              */
104093:             if (!ReportBadParameter(cx, parser, name, JSMSG_RESERVED_ID))
 62048:                 return false;
 62048:         }
 62048: 
 62063:         /*
 62063:          * Check for a duplicate parameter: warn or report an error exactly
 62063:          * once for each duplicated parameter.
 62063:          */
 62063:         if (HashMap<JSAtom *, bool>::AddPtr p = parameters.lookupForAdd(name)) {
 98181:             if (!p->value && !ReportBadParameter(cx, parser, name, JSMSG_DUPLICATE_FORMAL))
 62048:                 return false;
 62063:             p->value = true;
 62063:         } else {
 62063:             if (!parameters.add(p, name, false))
 62048:                 return false;
 35325:         }
 62063:     }
 35323: 
 35323:     return true;
 35323: }
 35323: 
 95100: static bool
104045: BindLocalVariable(JSContext *cx, TreeContext *tc, ParseNode *pn, BindingKind kind)
 95100: {
 95100:     JS_ASSERT(kind == VARIABLE || kind == CONSTANT);
 95100: 
104045:     unsigned index = tc->sc->bindings.numVars();
102586:     Rooted<JSAtom*> atom(cx, pn->pn_atom);
104045:     if (!tc->sc->bindings.add(cx, atom, kind))
 95100:         return false;
 95100: 
104045:     if (!pn->pn_cookie.set(cx, tc->staticLevel, index))
101616:         return false;
 95100:     pn->pn_dflags |= PND_BOUND;
 95100:     return true;
 95100: }
 95100: 
 80631: ParseNode *
 82875: Parser::functionBody(FunctionBodyType type)
     1: {
104045:     JS_ASSERT(tc->sc->inFunction());
104045: 
104045:     StmtInfoTC stmtInfo(context);
104045:     PushStatementTC(tc, &stmtInfo, STMT_BLOCK);
103855:     stmtInfo.isFunctionBodyBlock = true;
     1: 
104045:     JS_ASSERT(!tc->hasReturnExpr && !tc->hasReturnVoid);
     1: 
 80631:     ParseNode *pn;
 82875:     if (type == StatementListBody) {
 40263:         pn = statements();
  1967:     } else {
 82875:         JS_ASSERT(type == ExpressionBody);
 82875:         JS_ASSERT(JS_HAS_EXPR_CLOSURES);
104093: 
104093:         // There are no directives to parse, so indicate we're done finding
104093:         // strict mode directives.
104093:         if (!setStrictMode(false))
104093:             return NULL;
 98181:         pn = UnaryNode::create(PNK_RETURN, this);
  1967:         if (pn) {
 40263:             pn->pn_kid = assignExpr();
  1967:             if (!pn->pn_kid) {
  1967:                 pn = NULL;
  1967:             } else {
104045:                 if (tc->sc->funIsGenerator()) {
102849:                     ReportBadReturn(context, this, pn, &Parser::reportError,
  1967:                                     JSMSG_BAD_GENERATOR_RETURN,
  1967:                                     JSMSG_BAD_ANON_GENERATOR_RETURN);
  1967:                     pn = NULL;
  1967:                 } else {
 78294:                     pn->setOp(JSOP_RETURN);
  1967:                     pn->pn_pos.end = pn->pn_kid->pn_pos.end;
  1967:                 }
  1967:             }
  1967:         }
  1967:     }
     1: 
 10299:     if (pn) {
104045:         JS_ASSERT(!tc->topStmt->isBlockScope);
104045:         FinishPopStatement(tc);
     1: 
     1:         /* Check for falling off the end of a function that returns a value. */
104045:         if (context->hasStrictOption() && tc->hasReturnExpr &&
 98451:             !CheckFinalReturn(context, this, pn))
 98451:         {
     1:             pn = NULL;
     1:         }
 10299:     }
  8444: 
 95099:     /*
 95100:      * Check CheckStrictParameters before arguments logic below adds
 95100:      * 'arguments' to bindings.
 95100:      */
 98181:     if (!CheckStrictParameters(context, this))
 95100:         return NULL;
 95100: 
102586:     Rooted<PropertyName*> arguments(context, context->runtime->atomState.argumentsAtom);
 95100: 
 95100:     /*
 95100:      * Non-top-level functions use JSOP_DEFFUN which is a dynamic scope
 95100:      * operation which means it aliases any bindings with the same name.
 95100:      * Due to the implicit declaration mechanism (below), 'arguments' will not
 95100:      * have decls and, even if it did, they will not be noted as closed in the
 95100:      * emitter. Thus, in the corner case of function-statement-overridding-
 95100:      * arguments, flag the whole scope as dynamic.
 95100:      */
104045:     if (FuncStmtSet *set = tc->funcStmts) {
 95100:         for (FuncStmtSet::Range r = set->all(); !r.empty(); r.popFront()) {
 95100:             PropertyName *name = r.front()->asPropertyName();
 95100:             if (name == arguments)
104045:                 tc->sc->setBindingsAccessedDynamically();
104045:             else if (Definition *dn = tc->decls.lookupFirst(name))
 95100:                 dn->pn_dflags |= PND_CLOSED;
 95100:         }
 95100:     }
 95100: 
 95100:     /*
 98687:      * As explained by the ContextFlags::funArgumentsHasLocalBinding comment,
 98687:      * turn uses of 'arguments' into bindings. Use of 'arguments' should never
 98687:      * escape a nested function as an upvar.
 95100:      */
104045:     for (AtomDefnRange r = tc->lexdeps->all(); !r.empty(); r.popFront()) {
 95100:         JSAtom *atom = r.front().key();
 95100:         Definition *dn = r.front().value();
 95100:         JS_ASSERT(dn->isPlaceholder());
 95100:         if (atom == arguments) {
 95100:             /*
 95100:              * Turn 'dn' into a proper definition so uses will be bound as
104373:              * GETLOCAL in the emitter. The PND_IMPLICITARGUMENTS flag informs
104373:              * CompExprTransplanter (and anyone else) that this definition node
104373:              * has no proper declaration in the parse tree.
 95100:              */
104045:             if (!BindLocalVariable(context, tc, dn, VARIABLE))
 95100:                 return NULL;
 95100:             dn->setOp(JSOP_GETLOCAL);
 95100:             dn->pn_dflags &= ~PND_PLACEHOLDER;
104373:             dn->pn_dflags |= PND_IMPLICITARGUMENTS;
 95100: 
 95100:             /* NB: this leaves r invalid so we must break immediately. */
104045:             tc->lexdeps->remove(arguments);
 95100:             break;
 95100:         }
 95100:     }
 95100: 
104045:     bool hasRest = tc->sc->fun()->hasRest();
104045:     BindingKind bindKind = tc->sc->bindings.lookup(context, arguments, NULL);
 99225:     switch (bindKind) {
 99225:       case NONE:
 99225:         /* Functions with rest parameters are free from arguments. */
 99225:         if (hasRest)
 99225:             break;
 99225: 
 95100:         /*
 95100:          * Even if 'arguments' isn't explicitly mentioned, dynamic name lookup
 95100:          * forces an 'arguments' binding.
 95100:          */
104045:         if (!tc->sc->bindingsAccessedDynamically())
 99225:             break;
104045:         if (!tc->sc->bindings.addVariable(context, arguments))
 95100:             return NULL;
 99225: 
 99225:         /* 'arguments' is now bound, so fall through. */
 99225:       case VARIABLE:
 99225:       case CONSTANT:
 99225:         if (hasRest) {
102849:             reportError(NULL, JSMSG_ARGUMENTS_AND_REST);
 99225:             return NULL;
 95100:         }
 95100: 
 95100:         /*
 95100:          * Now that all possible 'arguments' bindings have been added, note whether
 95100:          * 'arguments' has a local binding and whether it unconditionally needs an
 95100:          * arguments object.
 95100:          */
104045:         tc->sc->setFunArgumentsHasLocalBinding();
 95100: 
 95100:         /* Dynamic scope access destroys all hope of optimization. */
104045:         if (tc->sc->bindingsAccessedDynamically())
104045:             tc->sc->setFunDefinitelyNeedsArgsObj();
 95100: 
 95100:         /*
 95100:          * Check whether any parameters have been assigned within this
 95100:          * function. In strict mode parameters do not alias arguments[i], and
 95100:          * to make the arguments object reflect initial parameter values prior
 95100:          * to any mutation we create it eagerly whenever parameters are (or
 95100:          * might, in the case of calls to eval) be assigned.
 95100:          */
104093:         if (tc->sc->needStrictChecks()) {
104045:             for (AtomDefnListMap::Range r = tc->decls.all(); !r.empty(); r.popFront()) {
103859:                 DefinitionList &dlist = r.front().value();
103859:                 for (DefinitionList::Range dr = dlist.all(); !dr.empty(); dr.popFront()) {
103859:                     Definition *dn = dr.front();
 95099:                     if (dn->kind() == Definition::ARG && dn->isAssigned()) {
104045:                         tc->sc->setFunDefinitelyNeedsArgsObj();
103859:                         goto exitLoop;
103859:                     }
103859:                 }
103859:             }
103859:           exitLoop: ;
 95099:         }
 99225:         break;
 99225:       case ARGUMENT:
 99225:         break;
 95099:     }
 95099: 
     1:     return pn;
     1: }
     1: 
 98181: // Create a placeholder Definition node for |atom|.
 98181: // Nb: unlike most functions that are passed a Parser, this one gets a
104045: // SharedContext passed in separately, because in this case |tc| may not equal
104045: // |parser->tc|.
 80631: static Definition *
104045: MakePlaceholder(ParseNode *pn, Parser *parser, TreeContext *tc)
104045: {
104045:     Definition *dn = (Definition *) NameNode::create(PNK_NAME, pn->pn_atom, parser, tc);
 27012:     if (!dn)
 27012:         return NULL;
 27012: 
 78294:     dn->setOp(JSOP_NOP);
 78294:     dn->setDefn(true);
 28557:     dn->pn_dflags |= PND_PLACEHOLDER;
 72579:     return dn;
 27012: }
 27012: 
 27012: static bool
104045: Define(ParseNode *pn, JSAtom *atom, TreeContext *tc, bool let = false)
 27012: {
 78294:     JS_ASSERT(!pn->isUsed());
 78294:     JS_ASSERT_IF(pn->isDefn(), pn->isPlaceholder());
 27012: 
 72579:     bool foundLexdep = false;
 80631:     Definition *dn = NULL;
 27012: 
 27012:     if (let)
104045:         dn = tc->decls.lookupFirst(atom);
 72579: 
 72579:     if (!dn) {
104045:         dn = tc->lexdeps.lookupDefn(atom);
 72579:         foundLexdep = !!dn;
 72579:     }
 72579: 
 72579:     if (dn && dn != pn) {
 80631:         ParseNode **pnup = &dn->dn_uses;
 80631:         ParseNode *pnu;
104045:         unsigned start = let ? pn->pn_blockid : tc->bodyid;
 27012: 
 27012:         while ((pnu = *pnup) != NULL && pnu->pn_blockid >= start) {
 78294:             JS_ASSERT(pnu->isUsed());
 80631:             pnu->pn_lexdef = (Definition *) pn;
 30457:             pn->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
 27012:             pnup = &pnu->pn_link;
 27012:         }
 27012: 
 27012:         if (pnu != dn->dn_uses) {
 27012:             *pnup = pn->dn_uses;
 27012:             pn->dn_uses = dn->dn_uses;
 27012:             dn->dn_uses = pnu;
 27012: 
104045:             if ((!pnu || pnu->pn_blockid < tc->bodyid) && foundLexdep)
104045:                 tc->lexdeps->remove(atom);
 72579:         }
 82878: 
 82878:         pn->pn_dflags |= dn->pn_dflags & PND_CLOSED;
 72579:     }
 72579: 
 80631:     Definition *toAdd = (Definition *) pn;
104045:     bool ok = let ? tc->decls.addShadow(atom, toAdd) : tc->decls.addUnique(atom, toAdd);
 72579:     if (!ok)
 27012:         return false;
 78294:     pn->setDefn(true);
 27012:     pn->pn_dflags &= ~PND_PLACEHOLDER;
104045:     if (!tc->parent)
 59228:         pn->pn_dflags |= PND_TOPLEVEL;
 27012:     return true;
 27012: }
 27012: 
 27012: static void
 80631: ForgetUse(ParseNode *pn)
 27012: {
 78294:     if (!pn->isUsed()) {
 78294:         JS_ASSERT(!pn->isDefn());
 27012:         return;
 27012:     }
 27012: 
 80631:     ParseNode **pnup = &pn->lexdef()->dn_uses;
 80631:     ParseNode *pnu;
 27012:     while ((pnu = *pnup) != pn)
 27012:         pnup = &pnu->pn_link;
 27012:     *pnup = pn->pn_link;
 78294:     pn->setUsed(false);
 27012: }
 27012: 
 80631: static ParseNode *
 98181: MakeAssignment(ParseNode *pn, ParseNode *rhs, Parser *parser)
 98181: {
 98181:     ParseNode *lhs = parser->cloneNode(*pn);
 27012:     if (!lhs)
 27012:         return NULL;
 27012: 
 78294:     if (pn->isUsed()) {
 80631:         Definition *dn = pn->pn_lexdef;
 80631:         ParseNode **pnup = &dn->dn_uses;
 27012: 
 27012:         while (*pnup != pn)
 27012:             pnup = &(*pnup)->pn_link;
 27012:         *pnup = lhs;
 27012:         lhs->pn_link = pn->pn_link;
 27012:         pn->pn_link = NULL;
 27012:     }
 27012: 
 82024:     pn->setKind(PNK_ASSIGN);
 78294:     pn->setOp(JSOP_NOP);
 78294:     pn->setArity(PN_BINARY);
 78294:     pn->setInParens(false);
 78294:     pn->setUsed(false);
 78294:     pn->setDefn(false);
 27012:     pn->pn_left = lhs;
 27012:     pn->pn_right = rhs;
 27012:     return lhs;
 27012: }
 27012: 
 80631: static ParseNode *
 98181: MakeDefIntoUse(Definition *dn, ParseNode *pn, JSAtom *atom, Parser *parser)
 27012: {
 27012:     /*
 54840:      * If dn is arg, or in [var, const, let] and has an initializer, then we
 54840:      * must rewrite it to be an assignment node, whose freshly allocated
 54840:      * left-hand side becomes a use of pn.
 27012:      */
100154:     if (dn->canHaveInitializer()) {
 80631:         ParseNode *rhs = dn->expr();
 27012:         if (rhs) {
 98181:             ParseNode *lhs = MakeAssignment(dn, rhs, parser);
 27012:             if (!lhs)
 27012:                 return NULL;
 27012:             //pn->dn_uses = lhs;
 80631:             dn = (Definition *) lhs;
 27012:         }
 27012: 
 78294:         dn->setOp((js_CodeSpec[dn->getOp()].format & JOF_SET) ? JSOP_SETNAME : JSOP_NAME);
 80631:     } else if (dn->kind() == Definition::FUNCTION) {
 78294:         JS_ASSERT(dn->isOp(JSOP_NOP));
 98181:         parser->prepareNodeForMutation(dn);
 82024:         dn->setKind(PNK_NAME);
 78294:         dn->setArity(PN_NAME);
 27012:         dn->pn_atom = atom;
 27012:     }
 27012: 
 27012:     /* Now make dn no longer a definition, rather a use of pn. */
 82024:     JS_ASSERT(dn->isKind(PNK_NAME));
 78294:     JS_ASSERT(dn->isArity(PN_NAME));
 27012:     JS_ASSERT(dn->pn_atom == atom);
 27012: 
 80631:     for (ParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
 78294:         JS_ASSERT(pnu->isUsed());
 78294:         JS_ASSERT(!pnu->isDefn());
 80631:         pnu->pn_lexdef = (Definition *) pn;
 30457:         pn->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
 30457:     }
 30457:     pn->pn_dflags |= dn->pn_dflags & PND_USE2DEF_FLAGS;
 27012:     pn->dn_uses = dn;
 27012: 
 78294:     dn->setDefn(false);
 78294:     dn->setUsed(true);
 80631:     dn->pn_lexdef = (Definition *) pn;
 47573:     dn->pn_cookie.makeFree();
 27012:     dn->pn_dflags &= ~PND_BOUND;
 27012:     return dn;
 27012: }
 27012: 
 80507: bool
104046: js::DefineArg(ParseNode *pn, JSAtom *atom, unsigned i, Parser *parser)
 98181: {
 98181:     /*
 98181:      * Make an argument definition node, distinguished by being in
104045:      * parser->tc->decls but having PNK_NAME kind and JSOP_NOP op. Insert it in
 98181:      * a PNK_ARGSBODY list node returned via pn->pn_body.
 98181:      */
104045:     ParseNode *argpn = NameNode::create(PNK_NAME, atom, parser, parser->tc);
 27012:     if (!argpn)
 27012:         return false;
 82024:     JS_ASSERT(argpn->isKind(PNK_NAME) && argpn->isOp(JSOP_NOP));
 27012: 
 27012:     /* Arguments are initialized by definition. */
 27012:     argpn->pn_dflags |= PND_INITIALIZED;
104045:     if (!Define(argpn, atom, parser->tc))
 27012:         return false;
 27012: 
 82024:     ParseNode *argsbody = pn->pn_body;
 27012:     argsbody->append(argpn);
 27012: 
 78294:     argpn->setOp(JSOP_GETARG);
104045:     if (!argpn->pn_cookie.set(parser->context, parser->tc->staticLevel, i))
101616:         return false;
 27012:     argpn->pn_dflags |= PND_BOUND;
 27012:     return true;
 27012: }
 27012: 
     1: /*
     1:  * Parameter block types for the several Binder functions.  We use a common
     1:  * helper function signature in order to share code among destructuring and
     1:  * simple variable declaration parsers.  In the destructuring case, the binder
     1:  * function is called indirectly from the variable declaration parser by way
     1:  * of CheckDestructuring and its friends.
     1:  */
103824: typedef bool
 98181: (*Binder)(JSContext *cx, BindData *data, JSAtom *atom, Parser *parser);
     1: 
103824: static bool
 98181: BindLet(JSContext *cx, BindData *data, JSAtom *atom, Parser *parser);
 86078: 
103824: static bool
 98181: BindVarOrConst(JSContext *cx, BindData *data, JSAtom *atom, Parser *parser);
 86078: 
104046: struct BindData {
 97353:     BindData(JSContext *cx) : let(cx), fresh(true) {}
 29379: 
 80631:     ParseNode       *pn;        /* name node for definition processing and
 27012:                                    error source coordinates */
     1:     JSOp            op;         /* prolog bytecode or nop */
     1:     Binder          binder;     /* binder, discriminates u */
 97353: 
 97353:     struct LetData {
 97353:         LetData(JSContext *cx) : blockObj(cx) {}
 86078:         VarContext varContext;
 99421:         Rooted<StaticBlockObject*> blockObj;
 91237:         unsigned   overflow;
     1:     } let;
 97353: 
 29379:     bool fresh;
 86078: 
 91237:     void initLet(VarContext varContext, StaticBlockObject &blockObj, unsigned overflow) {
 86078:         this->pn = NULL;
 86078:         this->op = JSOP_NOP;
 86078:         this->binder = BindLet;
 86078:         this->let.varContext = varContext;
 86483:         this->let.blockObj = &blockObj;
 86078:         this->let.overflow = overflow;
 86078:     }
 86078: 
 86078:     void initVarOrConst(JSOp op) {
 86078:         this->op = op;
 86078:         this->binder = BindVarOrConst;
 86078:     }
     1: };
     1: 
     1: #if JS_HAS_DESTRUCTURING
103824: static bool
 98181: BindDestructuringArg(JSContext *cx, BindData *data, JSAtom *atom, Parser *parser)
 98181: {
104045:     TreeContext *tc = parser->tc;
104045:     JS_ASSERT(tc->sc->inFunction());
104045: 
104045:     /*
104045:      * NB: Check tc->decls rather than tc->sc->bindings, because destructuring
104045:      *     bindings aren't added to tc->sc->bindings until after all arguments have
 59968:      *     been parsed.
 59968:      */
104045:     if (tc->decls.lookupFirst(atom)) {
102849:         parser->reportError(NULL, JSMSG_DESTRUCT_DUP_ARG);
103823:         return false;
     1:     }
 59952: 
 80631:     ParseNode *pn = data->pn;
 59955: 
 59952:     /*
 59952:      * Distinguish destructured-to binding nodes as vars, not args, by setting
 59952:      * pn_op to JSOP_SETLOCAL. Parser::functionDef checks for this pn_op value
 59952:      * when processing the destructuring-assignment AST prelude induced by such
 59952:      * destructuring args in Parser::functionArguments.
 59955:      *
 59955:      * We must set the PND_BOUND flag too to prevent pn_op from being reset to
 59955:      * JSOP_SETNAME by BindDestructuringVar. The only field not initialized is
 59955:      * pn_cookie; it gets set in functionDef in the first "if (prelude)" block.
 59957:      * We have to wait to set the cookie until we can call JSFunction::addLocal
 59957:      * with kind = JSLOCAL_VAR, after all JSLOCAL_ARG locals have been added.
 59957:      *
 59957:      * Thus a destructuring formal parameter binds an ARG (as in arguments[i]
 59957:      * element) with a null atom name for the object or array passed in to be
 59957:      * destructured, and zero or more VARs (as in named local variables) for
 59957:      * the destructured-to identifiers in the property value positions within
 59957:      * the object or array destructuring pattern, and all ARGs for the formal
 59957:      * parameter list bound as locals before any VAR for a destructured name.
 59955:      */
 78294:     pn->setOp(JSOP_SETLOCAL);
 59955:     pn->pn_dflags |= PND_BOUND;
 59955: 
104045:     return Define(pn, atom, tc);
     1: }
     1: #endif /* JS_HAS_DESTRUCTURING */
     1: 
 27012: JSFunction *
104045: Parser::newFunction(TreeContext *tc, JSAtom *atom, FunctionSyntaxKind kind)
 72567: {
 72567:     JS_ASSERT_IF(kind == Statement, atom != NULL);
 27012: 
 27012:     /*
 27012:      * Find the global compilation context in order to pre-set the newborn
104045:      * function's parent slot to tc->sc->scopeChain. If the global context is a
 27012:      * compile-and-go one, we leave the pre-set parent intact; otherwise we
 27012:      * clear parent and proto.
 27012:      */
104045:     while (tc->parent)
104045:         tc = tc->parent;
 86437: 
 99421:     RootedObject parent(context);
104045:     parent = tc->sc->inFunction() ? NULL : tc->sc->scopeChain();
 72567: 
 99421:     RootedFunction fun(context);
 97353:     fun = js_NewFunction(context, NULL, NULL, 0,
 72567:                          JSFUN_INTERPRETED | (kind == Expression ? JSFUN_LAMBDA : 0),
 72567:                          parent, atom);
 98464:     if (fun && !compileAndGo) {
104205:         if (!JSObject::clearParent(context, fun))
104205:             return NULL;
104205:         if (!JSObject::clearType(context, fun))
 83230:             return NULL;
 83283:         fun->setEnvironment(NULL);
 13691:     }
 13691:     return fun;
  8444: }
  8444: 
103824: static bool
 40320: MatchOrInsertSemicolon(JSContext *cx, TokenStream *ts)
 40320: {
 40854:     TokenKind tt = ts->peekTokenSameLine(TSF_OPERAND);
 25110:     if (tt == TOK_ERROR)
103823:         return false;
 25110:     if (tt != TOK_EOF && tt != TOK_EOL && tt != TOK_SEMI && tt != TOK_RC) {
 54158:         /* Advance the scanner for proper error location reporting. */
 54158:         ts->getToken(TSF_OPERAND);
102849:         ts->reportError(JSMSG_SEMI_BEFORE_STMNT);
103823:         return false;
 25110:     }
 40354:     (void) ts->matchToken(TOK_SEMI);
103823:     return true;
 25110: }
 25110: 
100230: static bool
 80989: DeoptimizeUsesWithin(Definition *dn, const TokenPos &pos)
 80989: {
 91237:     unsigned ndeoptimized = 0;
 80989: 
 80989:     for (ParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
 80989:         JS_ASSERT(pnu->isUsed());
 80989:         JS_ASSERT(!pnu->isDefn());
 80989:         if (pnu->pn_pos.begin >= pos.begin && pnu->pn_pos.end <= pos.end) {
 80989:             pnu->pn_dflags |= PND_DEOPTIMIZED;
 80989:             ++ndeoptimized;
 80989:         }
 80989:     }
 80989: 
 80989:     return ndeoptimized != 0;
 80989: }
 80989: 
 95099: /*
 95099:  * Beware: this function is called for functions nested in other functions or
 95099:  * global scripts but not for functions compiled through the Function
 95099:  * constructor or JSAPI. To always execute code when a function has finished
 95099:  * parsing, use Parser::functionBody.
 95099:  */
 80989: static bool
 98181: LeaveFunction(ParseNode *fn, Parser *parser, PropertyName *funName = NULL,
 72567:               FunctionSyntaxKind kind = Expression)
 40263: {
104045:     TreeContext *funtc = parser->tc;
104045:     TreeContext *tc = funtc->parent;
104045:     tc->blockidGen = funtc->blockidGen;
 27012: 
 80631:     FunctionBox *funbox = fn->pn_funbox;
104045:     funbox->cxFlags = funtc->sc->cxFlags;   // copy all the flags
 27012: 
 27012:     fn->pn_dflags |= PND_INITIALIZED;
104045:     if (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)
 27012:         fn->pn_dflags |= PND_BLOCKCHILD;
 27012: 
 27012:     /*
104045:      * Propagate unresolved lexical names up to tc->lexdeps, and save a copy
104045:      * of funtc->lexdeps in a TOK_UPVARS node wrapping the function's formal
 27371:      * params and body. We do this only if there are lexical dependencies not
 27371:      * satisfied by the function's declarations, to avoid penalizing functions
 27371:      * that use only their arguments and other local bindings.
 27012:      */
104045:     if (funtc->lexdeps->count()) {
 27371:         int foundCallee = 0;
 27012: 
104045:         for (AtomDefnRange r = funtc->lexdeps->all(); !r.empty(); r.popFront()) {
 72579:             JSAtom *atom = r.front().key();
 80631:             Definition *dn = r.front().value();
 27012:             JS_ASSERT(dn->isPlaceholder());
 27012: 
 80442:             if (atom == funName && kind == Expression) {
 78294:                 dn->setOp(JSOP_CALLEE);
104045:                 if (!dn->pn_cookie.set(parser->context, funtc->staticLevel,
101616:                                        UpvarCookie::CALLEE_SLOT))
101616:                     return false;
 27012:                 dn->pn_dflags |= PND_BOUND;
 27371:                 foundCallee = 1;
 27012:                 continue;
 27012:             }
 27012: 
104045:             Definition *outer_dn = tc->decls.lookupFirst(atom);
 52554: 
 52554:             /*
 52554:              * Make sure to deoptimize lexical dependencies that are polluted
 95099:              * by eval (approximated by bindingsAccessedDynamically) or with, to
 95099:              * safely bind globals (see bug 561923).
 95099:              */
104045:             if (funtc->sc->bindingsAccessedDynamically() ||
104045:                 (outer_dn && tc->innermostWith &&
104045:                  outer_dn->pn_pos < tc->innermostWith->pn_pos)) {
 52554:                 DeoptimizeUsesWithin(dn, fn->pn_pos);
 52554:             }
 52554: 
 72579:             if (!outer_dn) {
104045:                 AtomDefnAddPtr p = tc->lexdeps->lookupForAdd(atom);
 72579:                 if (p) {
 72579:                     outer_dn = p.value();
 72579:                 } else {
 72579:                     /*
 72579:                      * Create a new placeholder for our outer lexdep. We could
 72579:                      * simply re-use the inner placeholder, but that introduces
 72579:                      * subtleties in the case where we find a later definition
 72579:                      * that captures an existing lexdep. For example:
 57762:                      *
 57762:                      *   function f() { function g() { x; } let x; }
 57762:                      *
 72579:                      * Here, g's TOK_UPVARS node lists the placeholder for x,
 72579:                      * which must be captured by the 'let' declaration later,
 72579:                      * since 'let's are hoisted.  Taking g's placeholder as our
 72579:                      * own would work fine. But consider:
 57762:                      *
 57762:                      *   function f() { x; { function g() { x; } let x; } }
 57762:                      *
 72579:                      * Here, the 'let' must not capture all the uses of f's
 72579:                      * lexdep entry for x, but it must capture the x node
 72579:                      * referred to from g's TOK_UPVARS node.  Always turning
 72579:                      * inherited lexdeps into uses of a new outer definition
 57762:                      * allows us to handle both these cases in a natural way.
 57762:                      */
104045:                     outer_dn = MakePlaceholder(dn, parser, tc);
104045:                     if (!outer_dn || !tc->lexdeps->add(p, atom, outer_dn))
 71687:                         return false;
 71687:                 }
 72579:             }
 57762: 
 27012:             /*
 27012:              * Insert dn's uses list at the front of outer_dn's list.
 27012:              *
 27012:              * Without loss of generality or correctness, we allow a dn to
 27012:              * be in inner and outer lexdeps, since the purpose of lexdeps
 27012:              * is one-pass coordination of name use and definition across
 27012:              * functions, and if different dn's are used we'll merge lists
 27012:              * when leaving the inner function.
 27012:              *
 27012:              * The dn == outer_dn case arises with generator expressions
 27012:              * (see CompExprTransplanter::transplant, the PN_FUNC/PN_NAME
 27012:              * case), and nowhere else, currently.
 27012:              */
 27012:             if (dn != outer_dn) {
 80631:                 ParseNode **pnup = &dn->dn_uses;
 80631:                 ParseNode *pnu;
 27012: 
 27012:                 while ((pnu = *pnup) != NULL) {
 27012:                     pnu->pn_lexdef = outer_dn;
 27012:                     pnup = &pnu->pn_link;
 27012:                 }
 27012: 
 27012:                 /*
 27012:                  * Make dn be a use that redirects to outer_dn, because we
 27012:                  * can't replace dn with outer_dn in all the pn_namesets in
 27012:                  * the AST where it may be. Instead we make it forward to
 80631:                  * outer_dn. See Definition::resolve.
 27012:                  */
 27012:                 *pnup = outer_dn->dn_uses;
 27012:                 outer_dn->dn_uses = dn;
 28557:                 outer_dn->pn_dflags |= dn->pn_dflags & ~PND_PLACEHOLDER;
 78294:                 dn->setDefn(false);
 78294:                 dn->setUsed(true);
 27012:                 dn->pn_lexdef = outer_dn;
 57762:             }
 52878: 
 52878:             /* Mark the outer dn as escaping. */
 52878:             outer_dn->pn_dflags |= PND_CLOSED;
 27012:         }
 27012: 
104045:         if (funtc->lexdeps->count() - foundCallee != 0) {
 80631:             ParseNode *body = fn->pn_body;
 27012: 
 98181:             fn->pn_body = NameSetNode::create(PNK_UPVARS, parser);
 27012:             if (!fn->pn_body)
 27012:                 return false;
 27371: 
 27109:             fn->pn_body->pn_pos = body->pn_pos;
 27371:             if (foundCallee)
104045:                 funtc->lexdeps->remove(funName);
 72579:             /* Transfer ownership of the lexdep map to the parse node. */
104045:             fn->pn_body->pn_names = funtc->lexdeps;
104045:             funtc->lexdeps.clearMap();
 27012:             fn->pn_body->pn_tree = body;
 72579:         } else {
104045:             funtc->lexdeps.releaseMap(funtc->sc->context);
104045:         }
104045: 
104045:     }
104045: 
104045:     funbox->bindings.transfer(&funtc->sc->bindings);
 59968: 
 27012:     return true;
 27012: }
 27012: 
 51088: bool
100154: Parser::functionArguments(ParseNode **listp, bool &hasRest)
 51088: {
 51088:     if (tokenStream.getToken() != TOK_LP) {
102849:         reportError(NULL, JSMSG_PAREN_BEFORE_FORMAL);
 51088:         return false;
 51088:     }
 51088: 
 99225:     hasRest = false;
 99225: 
100154:     ParseNode *argsbody = ListNode::create(PNK_ARGSBODY, this);
100154:     if (!argsbody)
100154:         return false;
100154:     argsbody->setOp(JSOP_NOP);
100154:     argsbody->makeEmpty();
104045:     tc->sc->funbox()->node->pn_body = argsbody;
100154: 
 51088:     if (!tokenStream.matchToken(TOK_RP)) {
100154:         bool hasDefaults = false;
 51088: #if JS_HAS_DESTRUCTURING
 51088:         JSAtom *duplicatedArg = NULL;
 51088:         bool destructuringArg = false;
 80631:         ParseNode *list = NULL;
 51088: #endif
 52503: 
 51088:         do {
 99225:             if (hasRest) {
102849:                 reportError(NULL, JSMSG_PARAMETER_AFTER_REST);
 99225:                 return false;
 99225:             }
 51088:             switch (TokenKind tt = tokenStream.getToken()) {
 51088: #if JS_HAS_DESTRUCTURING
 51088:               case TOK_LB:
 51088:               case TOK_LC:
 51088:               {
 51088:                 /* See comment below in the TOK_NAME case. */
 51088:                 if (duplicatedArg)
 51088:                     goto report_dup_and_destructuring;
 99552:                 if (hasDefaults) {
102849:                     reportError(NULL, JSMSG_NONDEFAULT_FORMAL_AFTER_DEFAULT);
 99552:                     return false;
 99552:                 }
 99552: 
 51088:                 destructuringArg = true;
 51088: 
 51088:                 /*
 51088:                  * A destructuring formal parameter turns into one or more
 51088:                  * local variables initialized from properties of a single
 51088:                  * anonymous positional parameter, so here we must tweak our
 51088:                  * binder and its data.
 51088:                  */
 97353:                 BindData data(context);
 51088:                 data.pn = NULL;
 51088:                 data.op = JSOP_DEFVAR;
 51088:                 data.binder = BindDestructuringArg;
 80631:                 ParseNode *lhs = destructuringExpr(&data, tt);
 51088:                 if (!lhs)
 51088:                     return false;
 51088: 
 51088:                 /*
 51088:                  * Adjust fun->nargs to count the single anonymous positional
 51088:                  * parameter that is to be destructured.
 51088:                  */
 84755:                 uint16_t slot;
104045:                 if (!tc->sc->bindings.addDestructuring(context, &slot))
 51088:                     return false;
 51088: 
 51088:                 /*
 51088:                  * Synthesize a destructuring assignment from the single
 51088:                  * anonymous positional parameter into the destructuring
 51088:                  * left-hand-side expression and accumulate it in list.
 51088:                  */
 98181:                 ParseNode *rhs = NameNode::create(PNK_NAME, context->runtime->atomState.emptyAtom,
104045:                                                   this, this->tc);
 51088:                 if (!rhs)
 51088:                     return false;
 78294:                 rhs->setOp(JSOP_GETARG);
104045:                 if (!rhs->pn_cookie.set(context, tc->staticLevel, slot))
101616:                     return false;
 51088:                 rhs->pn_dflags |= PND_BOUND;
 95101:                 rhs->setDefn(true);
 51088: 
 89334:                 ParseNode *item = new_<BinaryNode>(PNK_ASSIGN, JSOP_NOP, lhs->pn_pos, lhs, rhs);
 51088:                 if (!item)
 51088:                     return false;
 51088:                 if (!list) {
 98181:                     list = ListNode::create(PNK_VAR, this);
 51088:                     if (!list)
 51088:                         return false;
 51088:                     list->makeEmpty();
 51088:                     *listp = list;
 51088:                 }
 51088:                 list->append(item);
 51088:                 break;
 51088:               }
 51088: #endif /* JS_HAS_DESTRUCTURING */
 51088: 
 99225:               case TOK_TRIPLEDOT:
 99225:               {
 99225:                 hasRest = true;
 99225:                 tt = tokenStream.getToken();
 99225:                 if (tt != TOK_NAME) {
 99225:                     if (tt != TOK_ERROR)
102849:                         reportError(NULL, JSMSG_NO_REST_NAME);
 99225:                     return false;
 99225:                 }
 99225:                 /* Fall through */
 99225:               }
 99225: 
 51088:               case TOK_NAME:
 51088:               {
 99421:                 Rooted<PropertyName*> name(context, tokenStream.currentToken().name());
 59952: 
 51088: #ifdef JS_HAS_DESTRUCTURING
 51088:                 /*
 59968:                  * ECMA-262 requires us to support duplicate parameter names,
 59968:                  * but if the parameter list includes destructuring, we
 59968:                  * consider the code to have "opted in" to higher standards and
 59968:                  * forbid duplicates. We may see a destructuring parameter
 59968:                  * later, so always note duplicates now.
 59968:                  *
 59968:                  * Duplicates are warned about (strict option) or cause errors
 59968:                  * (strict mode code), but we do those tests in one place
 59968:                  * below, after having parsed the body in case it begins with a
 59968:                  * "use strict"; directive.
 59968:                  *
104045:                  * NB: Check tc->decls rather than tc->sc->bindings, because
104045:                  *     destructuring bindings aren't added to tc->sc->bindings
 59968:                  *     until after all arguments have been parsed.
 52503:                  */
104045:                 if (tc->decls.lookupFirst(name)) {
104045:                     tc->sc->bindings.noteDup();
 80443:                     duplicatedArg = name;
 51088:                     if (destructuringArg)
 51088:                         goto report_dup_and_destructuring;
 51088:                 }
 51088: #endif
 59952: 
 84755:                 uint16_t slot;
104045:                 if (!tc->sc->bindings.addArgument(context, name, &slot))
 59952:                     return false;
104045:                 if (!DefineArg(tc->sc->funbox()->node, name, slot, this))
 51088:                     return false;
 99552: 
 99552:                 if (tokenStream.matchToken(TOK_ASSIGN)) {
 99552:                     if (hasRest) {
102849:                         reportError(NULL, JSMSG_REST_WITH_DEFAULT);
 99552:                         return false;
 99552:                     }
 99552:                     hasDefaults = true;
 99552:                     ParseNode *def_expr = assignExprWithoutYield(JSMSG_YIELD_IN_DEFAULT);
 99552:                     if (!def_expr)
 99552:                         return false;
104045:                     ParseNode *arg = tc->sc->funbox()->node->pn_body->last();
100154:                     arg->pn_dflags |= PND_DEFAULT;
100154:                     arg->pn_expr = def_expr;
104045:                     tc->sc->funbox()->ndefaults++;
 99552:                 } else if (!hasRest && hasDefaults) {
102849:                     reportError(NULL, JSMSG_NONDEFAULT_FORMAL_AFTER_DEFAULT);
 99552:                     return false;
 99552:                 }
 99552: 
 51088:                 break;
 51088:               }
 51088: 
 51088:               default:
102849:                 reportError(NULL, JSMSG_MISSING_FORMAL);
 51088:                 /* FALL THROUGH */
 51088:               case TOK_ERROR:
 51088:                 return false;
 51088: 
 51088: #if JS_HAS_DESTRUCTURING
 51088:               report_dup_and_destructuring:
104045:                 Definition *dn = tc->decls.lookupFirst(duplicatedArg);
102849:                 reportError(dn, JSMSG_DESTRUCT_DUP_ARG);
 51088:                 return false;
 51088: #endif
 51088:             }
 51088:         } while (tokenStream.matchToken(TOK_COMMA));
 51088: 
 51088:         if (tokenStream.getToken() != TOK_RP) {
102849:             reportError(NULL, JSMSG_PAREN_AFTER_FORMAL);
 51088:             return false;
 51088:         }
 51088:     }
 51088: 
 51088:     return true;
 51088: }
 51088: 
 80631: ParseNode *
 95355: Parser::functionDef(HandlePropertyName funName, FunctionType type, FunctionSyntaxKind kind)
 80442: {
 80442:     JS_ASSERT_IF(kind == Statement, funName);
 72567: 
     1:     /* Make a TOK_FUNCTION node. */
 98181:     ParseNode *pn = FunctionNode::create(PNK_FUNCTION, this);
     1:     if (!pn)
     1:         return NULL;
 27012:     pn->pn_body = NULL;
 47573:     pn->pn_cookie.makeFree();
 94151:     pn->pn_dflags = 0;
     1: 
     1:     /*
104045:      * Record names for function statements in tc->decls so we know when to
     1:      * avoid optimizing variable references that might name a function.
     1:      */
104045:     bool bodyLevel = tc->atBodyLevel();
 72567:     if (kind == Statement) {
104045:         if (Definition *dn = tc->decls.lookupFirst(funName)) {
 80631:             Definition::Kind dn_kind = dn->kind();
 27012: 
 78294:             JS_ASSERT(!dn->isUsed());
 78294:             JS_ASSERT(dn->isDefn());
 27012: 
 80631:             if (context->hasStrictOption() || dn_kind == Definition::CONST) {
 57812:                 JSAutoByteString name;
102849:                 Reporter reporter = (dn_kind != Definition::CONST)
102849:                                     ? &Parser::reportStrictWarning
102849:                                     : &Parser::reportError;
 80442:                 if (!js_AtomToPrintableString(context, funName, &name) ||
102849:                     !(this->*reporter)(NULL, JSMSG_REDECLARED_VAR, Definition::kindString(dn_kind),
102849:                                        name.ptr()))
102849:                 {
     1:                     return NULL;
     1:                 }
     1:             }
 27012: 
 59229:             if (bodyLevel) {
104045:                 tc->decls.updateFirst(funName, (Definition *) pn);
 78294:                 pn->setDefn(true);
 27012:                 pn->dn_uses = dn; /* dn->dn_uses is now pn_link */
 27012: 
 98181:                 if (!MakeDefIntoUse(dn, pn, funName, this))
 27012:                     return NULL;
 27012:             }
 59229:         } else if (bodyLevel) {
 27012:             /*
 27012:              * If this function was used before it was defined, claim the
 40239:              * pre-created definition node for this function that primaryExpr
104045:              * put in tc->lexdeps on first forward reference, and recycle pn.
104045:              */
104045: 
104045:             if (Definition *fn = tc->lexdeps.lookupDefn(funName)) {
 78294:                 JS_ASSERT(fn->isDefn());
 82024:                 fn->setKind(PNK_FUNCTION);
 78294:                 fn->setArity(PN_FUNC);
 27012:                 fn->pn_pos.begin = pn->pn_pos.begin;
 64260: 
 64260:                 /*
 64260:                  * Set fn->pn_pos.end too, in case of error before we parse the
 64260:                  * closing brace.  See bug 640075.
 64260:                  */
 64260:                 fn->pn_pos.end = pn->pn_pos.end;
 64260: 
 27012:                 fn->pn_body = NULL;
 47573:                 fn->pn_cookie.makeFree();
 27012: 
104045:                 tc->lexdeps->remove(funName);
 80641:                 freeTree(pn);
 27012:                 pn = fn;
 27012:             }
 27012: 
104045:             if (!Define(pn, funName, tc))
 27012:                 return NULL;
 27012:         }
     1: 
     1:         /*
 59228:          * A function directly inside another's body needs only a local
 59228:          * variable to bind its name to its value, and not an activation object
 59228:          * property (it might also need the activation property, if the outer
 59228:          * function contains with statements, e.g., but the stack slot wins
 80964:          * when BytecodeEmitter.cpp's BindNameToSlot can optimize a JSOP_NAME
 80634:          * into a JSOP_GETLOCAL bytecode).
     1:          */
104045:         if (bodyLevel && tc->sc->inFunction()) {
 27012:             /*
 27012:              * Define a local in the outer function so that BindNameToSlot
 27012:              * can properly optimize accesses. Note that we need a local
 27012:              * variable, not an argument, for the function statement. Thus
 27012:              * we add a variable even if a parameter with the given name
 27012:              * already exists.
 27012:              */
 91237:             unsigned index;
104045:             switch (tc->sc->bindings.lookup(context, funName, &index)) {
 59968:               case NONE:
 59968:               case ARGUMENT:
104045:                 index = tc->sc->bindings.numVars();
104045:                 if (!tc->sc->bindings.addVariable(context, funName))
 27012:                     return NULL;
 27012:                 /* FALL THROUGH */
 27012: 
 59968:               case VARIABLE:
104045:                 if (!pn->pn_cookie.set(context, tc->staticLevel, index))
101616:                     return NULL;
 27012:                 pn->pn_dflags |= PND_BOUND;
 27012:                 break;
 27012: 
 27012:               default:;
 27012:             }
 27012:         }
 27012:     }
 27012: 
104045:     TreeContext *outertc = tc;
104045: 
104045:     RootedFunction fun(context, newFunction(outertc, funName, kind));
100230:     if (!fun)
100230:         return NULL;
100230: 
104093:     // Inherit strictness if neeeded.
104093:     StrictMode::StrictModeState sms = (outertc->sc->strictModeState == StrictMode::STRICT) ?
104093:         StrictMode::STRICT : StrictMode::UNKNOWN;
104093: 
104093:     // Create box for fun->object early to protect against last-ditch GC.
104093:     FunctionBox *funbox = newFunctionBox(fun, pn, outertc, sms);
100230:     if (!funbox)
100230:         return NULL;
100230: 
 40239:     /* Initialize early for possible flags mutation via destructuringExpr. */
104093:     SharedContext funsc(context, /* scopeChain = */ NULL, fun, funbox, sms);
104045:     TreeContext funtc(this, &funsc, outertc->staticLevel + 1, outertc->blockidGen);
104045:     if (!funtc.init())
104045:         return NULL;
104045: 
     1:     /* Now parse formal argument list and compute fun->nargs. */
 80631:     ParseNode *prelude = NULL;
100154:     bool hasRest;
100154:     if (!functionArguments(&prelude, hasRest))
 59968:         return NULL;
 59968: 
 98445:     fun->setArgCount(funsc.bindings.numArgs());
100154:     if (funbox->ndefaults)
 99552:         fun->setHasDefaults();
 99225:     if (hasRest)
 99225:         fun->setHasRest();
 59952: 
 59952: #if JS_HAS_DESTRUCTURING
 59952:     /*
 59952:      * If there were destructuring formal parameters, bind the destructured-to
 59952:      * local variables now that we've parsed all the regular and destructuring
 59968:      * formal parameters. Because js::Bindings::add must be called first for
 59968:      * all ARGUMENTs, then all VARIABLEs and CONSTANTs, and finally all UPVARs,
 59968:      * we can't bind vars induced by formal parameter destructuring until after
 59968:      * Parser::functionArguments has returned.
 59952:      */
 59952:     if (prelude) {
104045:         for (AtomDefnListMap::Range r = tc->decls.all(); !r.empty(); r.popFront()) {
103859:             DefinitionList &dlist = r.front().value();
103859:             for (DefinitionList::Range dr = dlist.all(); !dr.empty(); dr.popFront()) {
103859:                 Definition *apn = dr.front();
103859: 
 59952:                 /* Filter based on pn_op -- see BindDestructuringArg, above. */
 78294:                 if (!apn->isOp(JSOP_SETLOCAL))
 59952:                     continue;
 59952: 
104045:                 if (!BindLocalVariable(context, &funtc, apn, VARIABLE))
 74093:                     return NULL;
 59952:             }
 59952:         }
103859:     }
 59952: #endif
     1: 
 72581:     if (type == Getter && fun->nargs > 0) {
102849:         reportError(NULL, JSMSG_ACCESSOR_WRONG_ARGS, "getter", "no", "s");
 51089:         return NULL;
 51089:     }
 72581:     if (type == Setter && fun->nargs != 1) {
102849:         reportError(NULL, JSMSG_ACCESSOR_WRONG_ARGS, "setter", "one", "");
 51089:         return NULL;
 51089:     }
 51089: 
 82875:     FunctionBodyType bodyType = StatementListBody;
  1967: #if JS_HAS_EXPR_CLOSURES
 82875:     if (tokenStream.getToken(TSF_OPERAND) != TOK_LC) {
 40354:         tokenStream.ungetToken();
  1967:         fun->flags |= JSFUN_EXPR_CLOSURE;
 82875:         bodyType = ExpressionBody;
  1967:     }
  1967: #else
     1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_BODY);
  1967: #endif
     1: 
 82875:     ParseNode *body = functionBody(bodyType);
     1:     if (!body)
     1:         return NULL;
     1: 
 98181:     if (funName && !CheckStrictBinding(context, this, funName, pn))
 62048:         return NULL;
 62048: 
  1967: #if JS_HAS_EXPR_CLOSURES
 82875:     if (bodyType == StatementListBody)
     1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
 72567:     else if (kind == Statement && !MatchOrInsertSemicolon(context, &tokenStream))
 25110:         return NULL;
  1967: #else
  1967:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
  1967: #endif
 40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
     1: 
 51097:     /*
 95099:      * Fruit of the poisonous tree: if a closure contains a dynamic name access
104045:      * (eval, with, etc), we consider the parent to do the same. The reason is
 95099:      * that the deoptimizing effects of dynamic name access apply equally to
 95099:      * parents: any local can be read at runtime.
 95099:      */
 98445:     if (funsc.bindingsAccessedDynamically())
104045:         outertc->sc->setBindingsAccessedDynamically();
 51097: 
     1: #if JS_HAS_DESTRUCTURING
     1:     /*
     1:      * If there were destructuring formal parameters, prepend the initializing
 51110:      * comma expression that we synthesized to body. If the body is a return
 82024:      * node, we must make a special PNK_SEQ node, to prepend the destructuring
 51110:      * code without bracing the decompilation of the function body.
     1:      */
 59952:     if (prelude) {
 78294:         if (!body->isArity(PN_LIST)) {
 80631:             ParseNode *block;
     1: 
 98181:             block = ListNode::create(PNK_SEQ, this);
     1:             if (!block)
     1:                 return NULL;
     1:             block->pn_pos = body->pn_pos;
 27012:             block->initList(body);
     1: 
     1:             body = block;
     1:         }
     1: 
 98181:         ParseNode *item = UnaryNode::create(PNK_SEMI, this);
     1:         if (!item)
     1:             return NULL;
     1: 
     1:         item->pn_pos.begin = item->pn_pos.end = body->pn_pos.begin;
 59952:         item->pn_kid = prelude;
     1:         item->pn_next = body->pn_head;
     1:         body->pn_head = item;
     1:         if (body->pn_tail == &body->pn_head)
     1:             body->pn_tail = &item->pn_next;
     1:         ++body->pn_count;
 27012:         body->pn_xflags |= PNX_DESTRUCT;
     1:     }
     1: #endif
     1: 
     1:     /*
     1:      * If we collected flags that indicate nested heavyweight functions, or
 27012:      * this function contains heavyweight-making statements (with statement,
 27012:      * visible eval call, or assignment to 'arguments'), flag the function as
 27012:      * heavyweight (requiring a call object per invocation).
     1:      */
 98687:     if (funsc.funIsHeavyweight()) {
     1:         fun->flags |= JSFUN_HEAVYWEIGHT;
104045:         outertc->sc->setFunIsHeavyweight();
     1:     }
     1: 
 51086:     JSOp op = JSOP_NOP;
 72567:     if (kind == Expression) {
 27012:         op = JSOP_LAMBDA;
 72567:     } else {
 72567:         if (!bodyLevel) {
 72567:             /*
 72567:              * Extension: in non-strict mode code, a function statement not at
 72567:              * the top level of a function body or whole program, e.g., in a
 72567:              * compound statement such as the "then" part of an "if" statement,
 72567:              * binds a closure only if control reaches that sub-statement.
 72567:              */
104093:             JS_ASSERT(outertc->sc->strictModeState != StrictMode::STRICT);
 18965:             op = JSOP_DEFFUN;
104045:             outertc->sc->setFunMightAliasLocals();
104045:             outertc->sc->setFunHasExtensibleScope();
104045:             outertc->sc->setFunIsHeavyweight();
 98687: 
 98687:             /*
 98687:              * Instead of setting bindingsAccessedDynamically, which would be
 95099:              * overly conservative, remember the names of all function
 95099:              * statements and mark any bindings with the same as aliased at the
 95099:              * end of functionBody.
 95099:              */
104045:             if (!outertc->funcStmts) {
104045:                 outertc->funcStmts = context->new_<FuncStmtSet>(context);
104045:                 if (!outertc->funcStmts || !outertc->funcStmts->init())
104045:                     return NULL;
104045:             }
104045:             if (!outertc->funcStmts->put(funName))
104045:                 return NULL;
104045:         }
104045:     }
104045: 
104045:     funbox->kids = funtc.functionList;
 27012: 
 27012:     pn->pn_funbox = funbox;
 78294:     pn->setOp(op);
 27012:     pn->pn_body->append(body);
 28816:     pn->pn_body->pn_pos = body->pn_pos;
 27012: 
104045:     JS_ASSERT_IF(!outertc->sc->inFunction() && bodyLevel && kind == Statement,
 98445:                  pn->pn_cookie.isFree());
 98445: 
104045:     pn->pn_blockid = outertc->blockid();
 40263: 
 98181:     if (!LeaveFunction(pn, this, funName, kind))
 27012:         return NULL;
 27012: 
 72567:     return pn;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::functionStmt()
 40263: {
 99421:     RootedPropertyName name(context);
 51087:     if (tokenStream.getToken(TSF_KEYWORD_IS_NAME) == TOK_NAME) {
 80443:         name = tokenStream.currentToken().name();
 51087:     } else {
 72567:         /* Unnamed function expressions are forbidden in statement context. */
102849:         reportError(NULL, JSMSG_UNNAMED_FUNCTION_STMT);
 72567:         return NULL;
 51087:     }
 60253: 
 60253:     /* We forbid function statements in strict mode code. */
104093:     if (!tc->atBodyLevel() && tc->sc->needStrictChecks() &&
104093:         !reportStrictModeError(NULL, JSMSG_STRICT_FUNCTION_STATEMENT))
104093:         return NULL;
 60253: 
 72581:     return functionDef(name, Normal, Statement);
 40239: }
 40239: 
 80631: ParseNode *
 40860: Parser::functionExpr()
 40263: {
 99421:     RootedPropertyName name(context);
 51087:     if (tokenStream.getToken(TSF_KEYWORD_IS_NAME) == TOK_NAME)
 80443:         name = tokenStream.currentToken().name();
 51087:     else
 51087:         tokenStream.ungetToken();
 72581:     return functionDef(name, Normal, Expression);
     1: }
     1: 
104093: void
104093: FunctionBox::recursivelySetStrictMode(StrictMode::StrictModeState strictness)
104093: {
104093:     if (strictModeState == StrictMode::UNKNOWN) {
104093:         strictModeState = strictness;
104093:         for (FunctionBox *kid = kids; kid; kid = kid->siblings)
104093:             kid->recursivelySetStrictMode(strictness);
104093:     }
104093: }
104093: 
104093: /*
104093:  * Indicate that the current scope can't switch to strict mode with a body-level
104093:  * "use strict" directive anymore. Return false on error.
104093:  */
104093: bool
104093: Parser::setStrictMode(bool strictMode)
104093: {
104093:     if (tc->sc->strictModeState != StrictMode::UNKNOWN) {
104093:         // Strict mode was inherited.
104093:         JS_ASSERT(tc->sc->strictModeState == StrictMode::STRICT);
104093:         if (tc->sc->inFunction() && tc->sc->funbox()) {
104093:             JS_ASSERT(tc->sc->funbox()->strictModeState == tc->sc->strictModeState);
104093:             JS_ASSERT(tc->parent->sc->strictModeState == StrictMode::STRICT);
104093:         } else {
104093:             JS_ASSERT(StrictModeFromContext(context) == StrictMode::STRICT || tc->staticLevel);
104093:         }
104093:         return true;
104093:     }
104093:     if (strictMode) {
104093:         if (tc->queuedStrictModeError) {
104093:             // There was a strict mode error in this scope before we knew it was
104093:             // strict. Throw it.
104093:             JS_ASSERT(!(tc->queuedStrictModeError->report.flags & JSREPORT_WARNING));
104093:             tc->queuedStrictModeError->throwError();
104093:             return false;
104093:         }
104093:         tc->sc->strictModeState = StrictMode::STRICT;
104093:     } else if (!tc->parent || tc->parent->sc->strictModeState == StrictMode::NOTSTRICT) {
104093:         // This scope will not be strict.
104093:         tc->sc->strictModeState = StrictMode::NOTSTRICT;
104093:         if (tc->queuedStrictModeError && context->hasStrictOption() &&
104093:             tc->queuedStrictModeError->report.errorNumber != JSMSG_STRICT_CODE_WITH) {
104093:             // Convert queued strict mode error to a warning.
104093:             tc->queuedStrictModeError->report.flags |= JSREPORT_WARNING;
104093:             tc->queuedStrictModeError->throwError();
104093:         }
104093:     }
104093:     JS_ASSERT_IF(!tc->sc->inFunction(), !tc->functionList);
104093:     if (tc->sc->strictModeState != StrictMode::UNKNOWN && tc->sc->inFunction()) {
104093:         // We changed the strict mode state. Retroactively recursively set
104093:         // strict mode status on all the function children we've seen so far
104093:         // children (That is, functions in default expressions).
104093:         if (tc->sc->funbox())
104093:             tc->sc->funbox()->strictModeState = tc->sc->strictModeState;
104093:         for (FunctionBox *kid = tc->functionList; kid; kid = kid->siblings)
104093:             kid->recursivelySetStrictMode(tc->sc->strictModeState);
104093:     }
104093:     return true;
104093: }
104093: 
104093: /*
104093:  * Return true if this token, known to be an unparenthesized string literal,
104093:  * could be the string of a directive in a Directive Prologue. Directive
104093:  * strings never contain escape sequences or line continuations.
104093:  */
104093: static bool
104093: IsEscapeFreeStringLiteral(const Token &tok)
104093: {
104093:     /*
104093:      * If the string's length in the source code is its length as a value,
104093:      * accounting for the quotes, then it must not contain any escape
104093:      * sequences or line continuations.
104093:      */
104093:     return (tok.pos.begin.lineno == tok.pos.end.lineno &&
104093:             tok.pos.begin.index + tok.atom()->length() + 2 == tok.pos.end.index);
104093: }
104093: 
     1: /*
 60792:  * Recognize Directive Prologue members and directives. Assuming |pn| is a
 60792:  * candidate for membership in a directive prologue, recognize directives and
104045:  * set |tc|'s flags accordingly. If |pn| is indeed part of a prologue, set its
 60792:  * |pn_prologue| flag.
 35113:  *
 35113:  * Note that the following is a strict mode function:
 35113:  *
 35113:  * function foo() {
 35113:  *   "blah" // inserted semi colon
 35113:  *        "blurgh"
 35113:  *   "use\x20loose"
 35113:  *   "use strict"
 35113:  * }
 35113:  *
 60792:  * That is, even though "use\x20loose" can never be a directive, now or in the
 60792:  * future (because of the hex escape), the Directive Prologue extends through it
 60792:  * to the "use strict" statement, which is indeed a directive.
 35113:  */
 40239: bool
104093: Parser::processDirectives(ParseNode *stmts)
104093: {
104093:     bool gotStrictMode = false;
104093:     for (TokenKind tt = tokenStream.getToken(TSF_OPERAND); tt == TOK_STRING; tt = tokenStream.getToken(TSF_OPERAND)) {
104093:         ParseNode *stringNode = atomNode(PNK_STRING, JSOP_STRING);
104093:         if (!stringNode)
 59219:             return false;
104093:         const Token directive = tokenStream.currentToken();
104093:         bool isDirective = IsEscapeFreeStringLiteral(directive);
104093:         JSAtom *atom = directive.atom();
104338:         TokenKind next = tokenStream.peekTokenSameLine();
104093:         if (next != TOK_EOF && next != TOK_EOL && next != TOK_SEMI && next != TOK_RC) {
104093:             freeTree(stringNode);
104093:             if (next == TOK_ERROR)
104093:                 return false;
104093:             break;
104093:         }
104093:         tokenStream.matchToken(TOK_SEMI);
104093:         if (isDirective) {
104093:             // It's a directive. Is it one we know?
104093:             if (atom == context->runtime->atomState.useStrictAtom && !gotStrictMode) {
104093:                 if (!setStrictMode(true))
104093:                     return false;
104093:                 gotStrictMode = true;
104093:             }
104093:         }
104093:         ParseNode *stmt = UnaryNode::create(PNK_SEMI, this);
104093:         if (!stmt) {
104093:             freeTree(stringNode);
104093:             return false;
104093:         }
104093:         stmt->pn_pos = stringNode->pn_pos;
104093:         stmt->pn_kid = stringNode;
104093:         stmt->pn_prologue = isDirective;
104093:         stmts->append(stmt);
104093:     }
104093:     tokenStream.ungetToken();
104093:     if (!gotStrictMode && !setStrictMode(false))
104093:         return false;
 35113:     return true;
 35113: }
 35113: 
 35113: /*
     1:  * Parse the statements in a block, creating a TOK_LC node that lists the
     1:  * statements' trees.  If called from block-parsing code, the caller must
     1:  * match { before and } after.
     1:  */
 80631: ParseNode *
 98452: Parser::statements(bool *hasFunctionStmt)
     1: {
 40239:     JS_CHECK_RECURSION(context, return NULL);
 98452:     if (hasFunctionStmt)
 98452:         *hasFunctionStmt = false;
 40221: 
 98181:     ParseNode *pn = ListNode::create(PNK_STATEMENTLIST, this);
     1:     if (!pn)
     1:         return NULL;
 27012:     pn->makeEmpty();
104045:     pn->pn_blockid = tc->blockid();
104045:     ParseNode *saveBlock = tc->blockNode;
104045:     tc->blockNode = pn;
104045: 
104093:     if (tc->atBodyLevel() && !processDirectives(pn))
104093:         return NULL;
  9604:     for (;;) {
 82875:         TokenKind tt = tokenStream.peekToken(TSF_OPERAND);
 10466:         if (tt <= TOK_EOF || tt == TOK_RC) {
 24241:             if (tt == TOK_ERROR) {
 40854:                 if (tokenStream.isEOF())
 40854:                     tokenStream.setUnexpectedEOF();
 40239:                 return NULL;
 40239:             }
 40239:             break;
 40239:         }
 82875:         ParseNode *next = statement();
 82875:         if (!next) {
 40854:             if (tokenStream.isEOF())
 40854:                 tokenStream.setUnexpectedEOF();
     1:             return NULL;
     1:         }
     1: 
 82875:         if (next->isKind(PNK_FUNCTION)) {
 10466:             /*
 59229:              * PNX_FUNCDEFS notifies the emitter that the block contains body-
 10466:              * level function definitions that should be processed before the
 10466:              * rest of nodes.
 10466:              *
 98452:              * |hasFunctionStmt| is for the TOK_LC case in Statement. It
 59229:              * is relevant only for function definitions not at body-level,
 10466:              * which we call function statements.
 10466:              */
104045:             if (tc->atBodyLevel()) {
 27012:                 pn->pn_xflags |= PNX_FUNCDEFS;
 74286:             } else {
 94150:                 /*
 94150:                  * General deoptimization was done in functionDef, here we just
 94150:                  * need to tell TOK_LC in Parser::statement to add braces.
 94150:                  */
104045:                 JS_ASSERT(tc->sc->funHasExtensibleScope());
 98452:                 if (hasFunctionStmt)
 98452:                     *hasFunctionStmt = true;
 64296:             }
 10466:         }
 82875:         pn->append(next);
     1:     }
     1: 
     1:     /*
     1:      * Handle the case where there was a let declaration under this block.  If
104045:      * it replaced tc->blockNode with a new block node then we must refresh pn
104045:      * and then restore tc->blockNode.
104045:      */
104045:     if (tc->blockNode != pn)
104045:         pn = tc->blockNode;
104045:     tc->blockNode = saveBlock;
     1: 
 40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
 89621:     JS_ASSERT(pn->pn_pos.begin <= pn->pn_pos.end);
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::condition()
     1: {
     1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_COND);
 84700:     ParseNode *pn = parenExpr();
     1:     if (!pn)
     1:         return NULL;
     1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_COND);
     1: 
 31479:     /* Check for (a = b) and warn about possible (a == b) mistype. */
 82024:     JS_ASSERT_IF(pn->isKind(PNK_ASSIGN), pn->isOp(JSOP_NOP));
 82024:     if (pn->isKind(PNK_ASSIGN) &&
 78294:         !pn->isInParens() &&
102849:         !reportStrictWarning(NULL, JSMSG_EQUAL_AS_ASSIGN))
 82023:     {
     1:         return NULL;
     1:     }
     1:     return pn;
     1: }
     1: 
 80443: static bool
 84666: MatchLabel(JSContext *cx, TokenStream *ts, PropertyName **label)
     1: {
 80443:     TokenKind tt = ts->peekTokenSameLine(TSF_OPERAND);
     1:     if (tt == TOK_ERROR)
 80443:         return false;
     1:     if (tt == TOK_NAME) {
 40354:         (void) ts->getToken();
 84666:         *label = ts->currentToken().name();
     1:     } else {
 84666:         *label = NULL;
 84666:     }
 80443:     return true;
     1: }
     1: 
 86078: static bool
 98181: ReportRedeclaration(JSContext *cx, Parser *parser, ParseNode *pn, bool isConst, JSAtom *atom)
 86078: {
 86078:     JSAutoByteString name;
102849:     if (js_AtomToPrintableString(cx, atom, &name))
102849:         parser->reportError(pn, JSMSG_REDECLARED_VAR, isConst ? "const" : "variable", name.ptr());
 86078:     return false;
 86078: }
 86078: 
 74052: /*
104045:  * Define a let-variable in a block, let-expression, or comprehension scope. tc
 74052:  * must already be in such a scope.
 74052:  *
 74052:  * Throw a SyntaxError if 'atom' is an invalid name. Otherwise create a
104045:  * property for the new variable on the block object, tc->blockChain;
 74052:  * populate data->pn->pn_{op,cookie,defn,dflags}; and stash a pointer to
 74052:  * data->pn in a slot of the block object.
 74052:  */
103824: static bool
 98181: BindLet(JSContext *cx, BindData *data, JSAtom *atom, Parser *parser)
 98181: {
104045:     TreeContext *tc = parser->tc;
 86078:     ParseNode *pn = data->pn;
 98181:     if (!CheckStrictBinding(cx, parser, atom->asPropertyName(), pn))
 35325:         return false;
 35325: 
 99421:     Rooted<StaticBlockObject *> blockObj(cx, data->let.blockObj);
 95355:     unsigned blockCount = blockObj->slotCount();
 86078:     if (blockCount == JS_BIT(16)) {
102849:         parser->reportError(pn, data->let.overflow);
 47497:         return false;
     1:     }
     1: 
 27012:     /*
 86078:      * For bindings that are hoisted to the beginning of the block/function,
 86078:      * Define() right now. For the rest, delay Define() until PushLetScope.
 86078:      */
 86078:     if (data->let.varContext == HoistVars) {
104045:         JS_ASSERT(!tc->atBodyLevel());
104045:         Definition *dn = tc->decls.lookupFirst(atom);
104045:         if (dn && dn->pn_blockid == tc->blockid())
 98181:             return ReportRedeclaration(cx, parser, pn, dn->isConst(), atom);
104045:         if (!Define(pn, atom, tc, true))
 47497:             return false;
 86078:     }
 27012: 
 27012:     /*
 27012:      * Assign block-local index to pn->pn_cookie right away, encoding it as an
 27012:      * upvar cookie whose skip tells the current static level. The emitter will
 27012:      * adjust the node's slot based on its stack depth model -- and, for global
 80991:      * and eval code, js::frontend::CompileScript will adjust the slot
 80634:      * again to include script->nfixed.
 27012:      */
 78294:     pn->setOp(JSOP_GETLOCAL);
104045:     if (!pn->pn_cookie.set(parser->context, tc->staticLevel, uint16_t(blockCount)))
101616:         return false;
 27012:     pn->pn_dflags |= PND_LET | PND_BOUND;
 27012: 
 27012:     /*
 53650:      * Define the let binding's property before storing pn in the the binding's
 86078:      * slot indexed by blockCount off the class-reserved slot base.
 86078:      */
 86078:     bool redeclared;
104205:     RootedId id(cx, AtomToId(atom));
104205:     Shape *shape = StaticBlockObject::addVar(cx, blockObj, id, blockCount, &redeclared);
 86078:     if (!shape) {
 86078:         if (redeclared)
 98181:             ReportRedeclaration(cx, parser, pn, false, atom);
 47497:         return false;
 86078:     }
 86078: 
 86483:     /* Store pn in the static block object. */
 95355:     blockObj->setDefinitionParseNode(blockCount, reinterpret_cast<Definition *>(pn));
 47497:     return true;
 27012: }
 27012: 
 86078: template <class Op>
 86078: static inline bool
104045: ForEachLetDef(TreeContext *tc, StaticBlockObject &blockObj, Op op)
 86483: {
 86483:     for (Shape::Range r = blockObj.lastProperty()->all(); !r.empty(); r.popFront()) {
103639:         Shape &shape = r.front();
 86078: 
 86078:         /* Beware the destructuring dummy slots. */
 86078:         if (JSID_IS_INT(shape.propid()))
 86078:             continue;
 86078: 
104045:         if (!op(tc, blockObj, shape, JSID_TO_ATOM(shape.propid())))
 86078:             return false;
 86078:     }
 86078:     return true;
 86078: }
 86078: 
 86078: struct RemoveDecl {
104045:     bool operator()(TreeContext *tc, StaticBlockObject &, const Shape &, JSAtom *atom) {
104045:         tc->decls.remove(atom);
 86078:         return true;
 86078:     }
 86078: };
 86078: 
 27012: static void
104045: PopStatementTC(TreeContext *tc)
104045: {
104378:     StaticBlockObject *blockObj = tc->topStmt->blockObj;
104378:     JS_ASSERT(!!blockObj == (tc->topStmt->isBlockScope));
104378: 
104045:     FinishPopStatement(tc);
104378: 
104378:     if (blockObj) {
104378:         JS_ASSERT(!blockObj->inDictionaryMode());
104378:         ForEachLetDef(tc, *blockObj, RemoveDecl());
104378:         blockObj->resetPrevBlockChainFromParser();
104378:     }
     1: }
     1: 
 27112: static inline bool
104205: OuterLet(TreeContext *tc, StmtInfoTC *stmt, HandleAtom atom)
 27112: {
 27112:     while (stmt->downScope) {
104045:         stmt = LexicalLookup(tc, atom, NULL, stmt->downScope);
 27112:         if (!stmt)
 27112:             return false;
 27112:         if (stmt->type == STMT_BLOCK)
 27112:             return true;
 27112:     }
 27112:     return false;
 27112: }
 27112: 
 60145: static bool
104045: BindFunctionLocal(JSContext *cx, BindData *data, DefinitionList::Range &defs, TreeContext *tc)
104045: {
104045:     JS_ASSERT(tc->sc->inFunction());
 60145: 
 80631:     ParseNode *pn = data->pn;
 74093:     JSAtom *name = pn->pn_atom;
 74093: 
104045:     BindingKind kind = tc->sc->bindings.lookup(cx, name, NULL);
 60145:     if (kind == NONE) {
 60145:         /*
 60145:          * Property not found in current variable scope: we have not seen this
 60145:          * variable before, so bind a new local variable for it. Any locals
 60145:          * declared in a with statement body are handled at runtime, by script
 60145:          * prolog JSOP_DEFVAR opcodes generated for global and heavyweight-
 60145:          * function-local vars.
 60145:          */
 60145:         kind = (data->op == JSOP_DEFCONST) ? CONSTANT : VARIABLE;
 60145: 
104045:         if (!BindLocalVariable(cx, tc, pn, kind))
 60145:             return false;
 78294:         pn->setOp(JSOP_GETLOCAL);
 60145:         return true;
 60145:     }
 60145: 
 60145:     if (kind == ARGUMENT) {
104045:         JS_ASSERT(tc->sc->inFunction());
103859:         JS_ASSERT(!defs.empty() && defs.front()->kind() == Definition::ARG);
 60145:     } else {
 60145:         JS_ASSERT(kind == VARIABLE || kind == CONSTANT);
 60145:     }
 60145: 
 60145:     return true;
 41817: }
 41817: 
103824: static bool
104205: BindVarOrConst(JSContext *cx, BindData *data, JSAtom *atom_, Parser *parser)
104205: {
104205:     RootedAtom atom(cx, atom_);
104205: 
104045:     TreeContext *tc = parser->tc;
 80631:     ParseNode *pn = data->pn;
 35325: 
 41817:     /* Default best op for pn is JSOP_NAME; we'll try to improve below. */
 78294:     pn->setOp(JSOP_NAME);
 41817: 
 98181:     if (!CheckStrictBinding(cx, parser, atom->asPropertyName(), pn))
 35325:         return false;
 35325: 
104045:     StmtInfoTC *stmt = LexicalLookup(tc, atom, NULL, (StmtInfoTC *)NULL);
 64237: 
 64237:     if (stmt && stmt->type == STMT_WITH) {
 29379:         data->fresh = false;
 54755:         pn->pn_dflags |= PND_DEOPTIMIZED;
104045:         tc->sc->setFunMightAliasLocals();
 52825:         return true;
 27012:     }
 27012: 
104045:     DefinitionList::Range defs = tc->decls.lookupMulti(atom);
 27012:     JSOp op = data->op;
 27012: 
103859:     if (stmt || !defs.empty()) {
103859:         Definition *dn = defs.empty() ? NULL : defs.front();
 80631:         Definition::Kind dn_kind = dn ? dn->kind() : Definition::VAR;
 80631: 
 80631:         if (dn_kind == Definition::ARG) {
 57812:             JSAutoByteString name;
 57812:             if (!js_AtomToPrintableString(cx, atom, &name))
103823:                 return false;
  8179: 
  8179:             if (op == JSOP_DEFCONST) {
102849:                 parser->reportError(pn, JSMSG_REDECLARED_PARAM, name.ptr());
103823:                 return false;
  8179:             }
102849:             if (!parser->reportStrictWarning(pn, JSMSG_VAR_HIDES_ARG, name.ptr()))
103823:                 return false;
  8179:         } else {
 28167:             bool error = (op == JSOP_DEFCONST ||
 80631:                           dn_kind == Definition::CONST ||
 80631:                           (dn_kind == Definition::LET &&
104045:                            (stmt->type != STMT_CATCH || OuterLet(tc, stmt, atom))));
 28167: 
 61450:             if (cx->hasStrictOption()
 80631:                 ? op != JSOP_DEFVAR || dn_kind != Definition::VAR
102849:                 : error)
102849:             {
 57812:                 JSAutoByteString name;
102849:                 Parser::Reporter reporter =
102849:                     error ? &Parser::reportError : &Parser::reportStrictWarning;
 57812:                 if (!js_AtomToPrintableString(cx, atom, &name) ||
102849:                     !(parser->*reporter)(pn, JSMSG_REDECLARED_VAR,
102849:                                          Definition::kindString(dn_kind), name.ptr()))
102849:                 {
103823:                     return false;
 27012:                 }
 27012:             }
 27012:         }
 27012:     }
 27012: 
103859:     if (defs.empty()) {
104045:         if (!Define(pn, atom, tc))
103823:             return false;
 27012:     } else {
 27012:         /*
 27012:          * A var declaration never recreates an existing binding, it restates
 27012:          * it and possibly reinitializes its value. Beware that if pn becomes a
103859:          * use of |defs.defn()|, and if we have an initializer for this var or
 27012:          * const (typically a const would ;-), then pn must be rewritten into a
 82024:          * PNK_ASSIGN node. See js::Parser::variables, further below.
 27012:          *
 27012:          * A case such as let (x = 1) { var x = 2; print(x); } is even harder.
 27012:          * There the x definition is hoisted but the x = 2 assignment mutates
 27012:          * the block-local binding of x.
 27012:          */
103859:         Definition *dn = defs.front();
 27012: 
 29379:         data->fresh = false;
 29379: 
 78294:         if (!pn->isUsed()) {
 27012:             /* Make pnu be a fresh name node that uses dn. */
 80631:             ParseNode *pnu = pn;
 27012: 
 78294:             if (pn->isDefn()) {
104045:                 pnu = NameNode::create(PNK_NAME, atom, parser, parser->tc);
 27012:                 if (!pnu)
103823:                     return false;
 27012:             }
 27012: 
 98181:             LinkUseToDef(pnu, dn);
 78294:             pnu->setOp(JSOP_NAME);
 27012:         }
 27012: 
 72579:         /* Find the first non-let binding of this atom. */
 80631:         while (dn->kind() == Definition::LET) {
103859:             defs.popFront();
103859:             if (defs.empty())
 72579:                 break;
103859:             dn = defs.front();
 72579:         }
 72579: 
 72579:         if (dn) {
 27012:             JS_ASSERT_IF(data->op == JSOP_DEFCONST,
 80631:                          dn->kind() == Definition::CONST);
103823:             return true;
 27012:         }
 27012: 
 27012:         /*
 27012:          * A var or const that is shadowed by one or more let bindings of the
 27012:          * same name, but that has not been declared until this point, must be
 27012:          * hoisted above the let bindings.
 27012:          */
 78294:         if (!pn->isDefn()) {
104045:             if (tc->lexdeps->lookup(atom)) {
104045:                 tc->lexdeps->remove(atom);
 27012:             } else {
104045:                 ParseNode *pn2 = NameNode::create(PNK_NAME, atom, parser, parser->tc);
 27012:                 if (!pn2)
103823:                     return false;
 27012: 
 27012:                 /* The token stream may be past the location for pn. */
 27012:                 pn2->pn_pos = pn->pn_pos;
 27012:                 pn = pn2;
 27012:             }
 78294:             pn->setOp(JSOP_NAME);
 27012:         }
 27012: 
104045:         if (!tc->decls.addHoist(atom, (Definition *) pn))
103823:             return false;
 78294:         pn->setDefn(true);
 27012:         pn->pn_dflags &= ~PND_PLACEHOLDER;
 27012:     }
 27012: 
 27012:     if (data->op == JSOP_DEFCONST)
 27012:         pn->pn_dflags |= PND_CONST;
 27012: 
104045:     if (tc->sc->inFunction())
104045:         return BindFunctionLocal(cx, data, defs, tc);
 74093: 
 98173:     return true;
     1: }
     1: 
 57742: static bool
 98181: MakeSetCall(JSContext *cx, ParseNode *pn, Parser *parser, unsigned msg)
 20908: {
 78294:     JS_ASSERT(pn->isArity(PN_LIST));
 78294:     JS_ASSERT(pn->isOp(JSOP_CALL) || pn->isOp(JSOP_EVAL) ||
 78294:               pn->isOp(JSOP_FUNCALL) || pn->isOp(JSOP_FUNAPPLY));
102849:     if (!parser->reportStrictModeError(pn, msg))
 57742:         return false;
 57742: 
 80631:     ParseNode *pn2 = pn->pn_head;
 98481:     if (pn2->isKind(PNK_FUNCTION) && (pn2->pn_funbox->inGenexpLambda)) {
102849:         parser->reportError(pn, msg);
 57742:         return false;
 57742:     }
 57742:     pn->pn_xflags |= PNX_SETCALL;
 57742:     return true;
 20908: }
 20908: 
 27012: static void
 98445: NoteLValue(JSContext *cx, ParseNode *pn, SharedContext *sc, unsigned dflag = PND_ASSIGNED)
 27012: {
 78294:     if (pn->isUsed()) {
 80631:         Definition *dn = pn->pn_lexdef;
 27012: 
 27012:         /*
 27012:          * Save the win of PND_INITIALIZED if we can prove 'var x;' and 'x = y'
 27012:          * occur as direct kids of the same block with no forward refs to x.
 27012:          */
 28920:         if (!(dn->pn_dflags & (PND_INITIALIZED | PND_CONST | PND_PLACEHOLDER)) &&
 28557:             dn->isBlockChild() &&
 27012:             pn->isBlockChild() &&
 27012:             dn->pn_blockid == pn->pn_blockid &&
 28557:             dn->pn_pos.end <= pn->pn_pos.begin &&
 27012:             dn->dn_uses == pn) {
 27012:             dflag = PND_INITIALIZED;
 27012:         }
 27012: 
 27012:         dn->pn_dflags |= dflag;
 27012:     }
 27012: 
 27012:     pn->pn_dflags |= dflag;
 27012: 
 59940:     /*
 95100:      * An enclosing function's name is an immutable binding in ES5, so
 95100:      * assignments to them must do nothing or throw a TypeError depending on
 95100:      * code strictness. Outside strict mode, we optimize away assignment to
 95100:      * the function name. For assignment to function name to fail in strict
 95100:      * mode, we must have a binding for it in the scope chain; we ensure this
 95100:      * happens by making such functions heavyweight.
 95100:      */
100230:     if (sc->inFunction() && pn->pn_atom == sc->fun()->atom)
 98687:         sc->setFunIsHeavyweight();
 59940: }
 27012: 
 97594: static bool
 98181: NoteNameUse(ParseNode *pn, Parser *parser)
 97594: {
104205:     RootedPropertyName name(parser->context, pn->pn_atom->asPropertyName());
104045:     StmtInfoTC *stmt = LexicalLookup(parser->tc, name, NULL, (StmtInfoTC *)NULL);
104045: 
104045:     DefinitionList::Range defs = parser->tc->decls.lookupMulti(name);
 97594: 
 97594:     Definition *dn;
103859:     if (!defs.empty()) {
103859:         dn = defs.front();
 97594:     } else {
104045:         if (AtomDefnAddPtr p = parser->tc->lexdeps->lookupForAdd(name)) {
 97594:             dn = p.value();
 97594:         } else {
 97594:             /*
 97594:              * No definition before this use in any lexical scope.
 97594:              * Create a placeholder definition node to either:
 97594:              * - Be adopted when we parse the real defining
 97594:              *   declaration, or
 97594:              * - Be left as a free variable definition if we never
 97594:              *   see the real definition.
 97594:              */
104045:             dn = MakePlaceholder(pn, parser, parser->tc);
104045:             if (!dn || !parser->tc->lexdeps->add(p, name, dn))
 97594:                 return false;
 97594:         }
 97594:     }
 97594: 
 97594:     JS_ASSERT(dn->isDefn());
 98181:     LinkUseToDef(pn, dn);
 97594: 
 97594:     if (stmt && stmt->type == STMT_WITH)
 97594:         pn->pn_dflags |= PND_DEOPTIMIZED;
 97594: 
 97594:     return true;
 97594: }
 97594: 
     1: #if JS_HAS_DESTRUCTURING
     1: 
103824: static bool
 98181: BindDestructuringVar(JSContext *cx, BindData *data, ParseNode *pn, Parser *parser)
     1: {
 82024:     JS_ASSERT(pn->isKind(PNK_NAME));
     1: 
     1:     data->pn = pn;
 98181:     if (!data->binder(cx, data, pn->pn_atom, parser))
103823:         return false;
 27012: 
 27012:     /*
 27012:      * Select the appropriate name-setting opcode, respecting eager selection
 27012:      * done by the data->binder function.
 27012:      */
 98173:     if (pn->pn_dflags & PND_BOUND)
 95100:         pn->setOp(JSOP_SETLOCAL);
 98173:     else if (data->op == JSOP_DEFCONST)
 98173:         pn->setOp(JSOP_SETCONST);
 98173:     else
 98173:         pn->setOp(JSOP_SETNAME);
 27012: 
 27012:     if (data->op == JSOP_DEFCONST)
 27012:         pn->pn_dflags |= PND_CONST;
 27012: 
104045:     NoteLValue(cx, pn, parser->tc->sc, PND_INITIALIZED);
103823:     return true;
     1: }
     1: 
     1: /*
     1:  * Here, we are destructuring {... P: Q, ...} = R, where P is any id, Q is any
     1:  * LHS expression except a destructuring initialiser, and R is on the stack.
     1:  * Because R is already evaluated, the usual LHS-specialized bytecodes won't
     1:  * work.  After pushing R[P] we need to evaluate Q's "reference base" QB and
     1:  * then push its property name QN.  At this point the stack looks like
     1:  *
     1:  *   [... R, R[P], QB, QN]
     1:  *
     1:  * We need to set QB[QN] = R[P].  This is a job for JSOP_ENUMELEM, which takes
     1:  * its operands with left-hand side above right-hand side:
     1:  *
     1:  *   [rval, lval, xval]
     1:  *
     1:  * and pops all three values, setting lval[xval] = rval.  But we cannot select
     1:  * JSOP_ENUMELEM yet, because the LHS may turn out to be an arg or local var,
     1:  * which can be optimized further.  So we select JSOP_SETNAME.
     1:  */
103824: static bool
 98181: BindDestructuringLHS(JSContext *cx, ParseNode *pn, Parser *parser)
     1: {
 78294:     switch (pn->getKind()) {
 82024:       case PNK_NAME:
104045:         NoteLValue(cx, pn, parser->tc->sc);
     1:         /* FALL THROUGH */
 27012: 
 82024:       case PNK_DOT:
 82024:       case PNK_LB:
 42747:         /*
 42747:          * We may be called on a name node that has already been specialized,
 42747:          * in the very weird and ECMA-262-required "for (var [x] = i in o) ..."
 42747:          * case. See bug 558633.
 42747:          */
 78294:         if (!(js_CodeSpec[pn->getOp()].format & JOF_SET))
 78294:             pn->setOp(JSOP_SETNAME);
     1:         break;
     1: 
 82024:       case PNK_LP:
 98181:         if (!MakeSetCall(cx, pn, parser, JSMSG_BAD_LEFTSIDE_OF_ASS))
103823:             return false;
     1:         break;
     1: 
     1: #if JS_HAS_XML_SUPPORT
 82114:       case PNK_XMLUNARY:
 82018:         JS_ASSERT(pn->isOp(JSOP_XMLNAME));
 78294:         pn->setOp(JSOP_BINDXMLNAME);
     1:         break;
     1: #endif
     1: 
     1:       default:
102849:         parser->reportError(pn, JSMSG_BAD_LEFTSIDE_OF_ASS);
103823:         return false;
103823:     }
103823: 
103823:     return true;
     1: }
     1: 
     1: /*
 33753:  * Destructuring patterns can appear in two kinds of contexts:
 28995:  *
 33753:  * - assignment-like: assignment expressions and |for| loop heads.  In
 33753:  *   these cases, the patterns' property value positions can be
 33753:  *   arbitrary lvalue expressions; the destructuring is just a fancy
 33753:  *   assignment.
 33753:  *
 33753:  * - declaration-like: |var| and |let| declarations, functions' formal
 33753:  *   parameter lists, |catch| clauses, and comprehension tails.  In
 33753:  *   these cases, the patterns' property value positions must be
 33753:  *   simple names; the destructuring defines them as new variables.
 33753:  *
 33753:  * In both cases, other code parses the pattern as an arbitrary
 40239:  * primaryExpr, and then, here in CheckDestructuring, verify that the
 33753:  * tree is a valid destructuring expression.
 33753:  *
 98453:  * In assignment-like contexts, we parse the pattern with
104045:  * tc->inDeclDestructuring clear, so the lvalue expressions in the
 40239:  * pattern are parsed normally.  primaryExpr links variable references
 33753:  * into the appropriate use chains; creates placeholder definitions;
 33753:  * and so on.  CheckDestructuring is called with |data| NULL (since we
 33753:  * won't be binding any new names), and we specialize lvalues as
 68922:  * appropriate.
 33753:  *
 33753:  * In declaration-like contexts, the normal variable reference
 33753:  * processing would just be an obstruction, because we're going to
 33753:  * define the names that appear in the property value positions as new
 33753:  * variables anyway.  In this case, we parse the pattern with
104045:  * tc->inDeclDestructuring set, which directs primaryExpr to leave
 33753:  * whatever name nodes it creates unconnected.  Then, here in
 33753:  * CheckDestructuring, we require the pattern's property value
 33753:  * positions to be simple names, and define them as appropriate to the
 33753:  * context.  For these calls, |data| points to the right sort of
 33753:  * BindData.
 33753:  *
 86078:  * The 'toplevel' is a private detail of the recursive strategy used by
 86078:  * CheckDestructuring and callers should use the default value.
     1:  */
 68922: static bool
 98181: CheckDestructuring(JSContext *cx, BindData *data, ParseNode *left, Parser *parser,
 86078:                    bool toplevel = true)
 68922: {
 68922:     bool ok;
     1: 
 82024:     if (left->isKind(PNK_ARRAYCOMP)) {
102849:         parser->reportError(left, JSMSG_ARRAY_COMP_LEFTSIDE);
 68922:         return false;
 68922:     }
 68922: 
 99421:     Rooted<StaticBlockObject *> blockObj(cx);
103637:     blockObj = data && data->binder == BindLet ? data->let.blockObj.get() : NULL;
 86483:     uint32_t blockCountBefore = blockObj ? blockObj->slotCount() : 0;
 86078: 
 82024:     if (left->isKind(PNK_RB)) {
 80631:         for (ParseNode *pn = left->pn_head; pn; pn = pn->pn_next) {
     1:             /* Nullary comma is an elision; binary comma is an expression.*/
 86078:             if (!pn->isArrayHole()) {
 82024:                 if (pn->isKind(PNK_RB) || pn->isKind(PNK_RC)) {
 98181:                     ok = CheckDestructuring(cx, data, pn, parser, false);
     1:                 } else {
     1:                     if (data) {
 82024:                         if (!pn->isKind(PNK_NAME)) {
102849:                             parser->reportError(pn, JSMSG_NO_VARIABLE_NAME);
 68922:                             return false;
 68922:                         }
 98181:                         ok = BindDestructuringVar(cx, data, pn, parser);
     1:                     } else {
 98181:                         ok = BindDestructuringLHS(cx, pn, parser);
     1:                     }
     1:                 }
     1:                 if (!ok)
 68922:                     return false;
 68922:             }
     1:         }
     1:     } else {
 82024:         JS_ASSERT(left->isKind(PNK_RC));
 80631:         for (ParseNode *pair = left->pn_head; pair; pair = pair->pn_next) {
 82024:             JS_ASSERT(pair->isKind(PNK_COLON));
 80631:             ParseNode *pn = pair->pn_right;
     1: 
 82024:             if (pn->isKind(PNK_RB) || pn->isKind(PNK_RC)) {
 98181:                 ok = CheckDestructuring(cx, data, pn, parser, false);
     1:             } else if (data) {
 82024:                 if (!pn->isKind(PNK_NAME)) {
102849:                     parser->reportError(pn, JSMSG_NO_VARIABLE_NAME);
 68922:                     return false;
 68922:                 }
 98181:                 ok = BindDestructuringVar(cx, data, pn, parser);
     1:             } else {
 97594:                 /*
 97594:                  * If right and left point to the same node, then this is
 97594:                  * destructuring shorthand ({x} = ...). In that case,
 97594:                  * identifierName was not used to parse 'x' so 'x' has not been
 97594:                  * officially linked to its def or registered in lexdeps. Do
 97594:                  * that now.
 97594:                  */
 98181:                 if (pair->pn_right == pair->pn_left && !NoteNameUse(pn, parser))
 97594:                     return false;
 98181:                 ok = BindDestructuringLHS(cx, pn, parser);
     1:             }
     1:             if (!ok)
 68922:                 return false;
     1:         }
     1:     }
     1: 
 14688:     /*
 14688:      * The catch/finally handler implementation in the interpreter assumes
 14688:      * that any operation that introduces a new scope (like a "let" or "with"
 14688:      * block) increases the stack depth. This way, it is possible to restore
 14688:      * the scope chain based on stack depth of the handler alone. "let" with
 14688:      * an empty destructuring pattern like in
 14688:      *
 14688:      *   let [] = 1;
 14688:      *
 14688:      * would violate this assumption as the there would be no let locals to
 86078:      * store on the stack.
 14688:      *
 86078:      * Furthermore, the decompiler needs an abstract stack location to store
 86078:      * the decompilation of each let block/expr initializer. E.g., given:
 86078:      *
 86078:      *   let (x = 1, [[]] = b, y = 3, {a:[]} = c) { ... }
 86078:      *
 86078:      * four slots are needed.
 86078:      *
 86078:      * To satisfy both constraints, we push a dummy slot (and add a
 86078:      * corresponding dummy property to the block object) for each initializer
 86078:      * that doesn't introduce at least one binding.
 86078:      */
 86483:     if (toplevel && blockObj && blockCountBefore == blockObj->slotCount()) {
 86534:         bool redeclared;
104205:         RootedId id(cx, INT_TO_JSID(blockCountBefore));
104205:         if (!StaticBlockObject::addVar(cx, blockObj, id, blockCountBefore, &redeclared))
 68922:             return false;
 86534:         JS_ASSERT(!redeclared);
 86483:         JS_ASSERT(blockObj->slotCount() == blockCountBefore + 1);
 86078:     }
 68922: 
 68922:     return true;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::destructuringExpr(BindData *data, TokenKind tt)
 40239: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(tt));
 82024: 
104045:     tc->inDeclDestructuring = true;
103823:     ParseNode *pn = primaryExpr(tt, false);
104045:     tc->inDeclDestructuring = false;
     1:     if (!pn)
     1:         return NULL;
 98181:     if (!CheckDestructuring(context, data, pn, this))
     1:         return NULL;
     1:     return pn;
     1: }
     1: 
     1: #endif /* JS_HAS_DESTRUCTURING */
     1: 
 80631: ParseNode *
 40860: Parser::returnOrYield(bool useAssignExpr)
 40221: {
 82024:     TokenKind tt = tokenStream.currentToken().type;
104045:     if (!tc->sc->inFunction()) {
102849:         reportError(NULL, JSMSG_BAD_RETURN_OR_YIELD,
 72073:                     (tt == TOK_RETURN) ? js_return_str : js_yield_str);
     1:         return NULL;
     1:     }
     1: 
 98181:     ParseNode *pn = UnaryNode::create((tt == TOK_RETURN) ? PNK_RETURN : PNK_YIELD, this);
     1:     if (!pn)
     1:         return NULL;
     1: 
     1: #if JS_HAS_GENERATORS
 72073:     if (tt == TOK_YIELD) {
 72073:         /*
 72073:          * If we're within parens, we won't know if this is a generator expression until we see
 72073:          * a |for| token, so we have to delay flagging the current function.
 72073:          */
104045:         if (tc->parenDepth == 0) {
104045:             tc->sc->setFunIsGenerator();
 72073:         } else {
104045:             tc->yieldCount++;
104045:             tc->yieldNode = pn;
 72073:         }
 72073:     }
     1: #endif
     1: 
     1:     /* This is ugly, but we don't want to require a semicolon. */
 82024:     TokenKind tt2 = tokenStream.peekTokenSameLine(TSF_OPERAND);
     1:     if (tt2 == TOK_ERROR)
     1:         return NULL;
     1: 
     1:     if (tt2 != TOK_EOF && tt2 != TOK_EOL && tt2 != TOK_SEMI && tt2 != TOK_RC
     1: #if JS_HAS_GENERATORS
   339:         && (tt != TOK_YIELD ||
 11844:             (tt2 != tt && tt2 != TOK_RB && tt2 != TOK_RP &&
 11844:              tt2 != TOK_COLON && tt2 != TOK_COMMA))
     1: #endif
 82024:         )
 82024:     {
 82024:         ParseNode *pn2 = useAssignExpr ? assignExpr() : expr();
     1:         if (!pn2)
     1:             return NULL;
     1: #if JS_HAS_GENERATORS
     1:         if (tt == TOK_RETURN)
     1: #endif
104045:             tc->hasReturnExpr = true;
     1:         pn->pn_pos.end = pn2->pn_pos.end;
     1:         pn->pn_kid = pn2;
     1:     } else {
     1: #if JS_HAS_GENERATORS
     1:         if (tt == TOK_RETURN)
     1: #endif
104045:             tc->hasReturnVoid = true;
104045:     }
104045: 
104045:     if (tc->hasReturnExpr && tc->sc->funIsGenerator()) {
     1:         /* As in Python (see PEP-255), disallow return v; in generators. */
102849:         ReportBadReturn(context, this, pn, &Parser::reportError, JSMSG_BAD_GENERATOR_RETURN,
     1:                         JSMSG_BAD_ANON_GENERATOR_RETURN);
     1:         return NULL;
     1:     }
     1: 
104045:     if (context->hasStrictOption() && tc->hasReturnExpr && tc->hasReturnVoid &&
102849:         !ReportBadReturn(context, this, pn, &Parser::reportStrictWarning,
102849:                          JSMSG_NO_RETURN_VALUE, JSMSG_ANON_NO_RETURN_VALUE))
102849:     {
     1:         return NULL;
     1:     }
     1: 
     1:     return pn;
     1: }
     1: 
 80631: static ParseNode *
104378: PushLexicalScope(JSContext *cx, Parser *parser, StaticBlockObject &blockObj, StmtInfoTC *stmt)
 98181: {
 98181:     ParseNode *pn = LexicalScopeNode::create(PNK_LEXICALSCOPE, parser);
     1:     if (!pn)
     1:         return NULL;
     1: 
104378:     ObjectBox *blockbox = parser->newObjectBox(&blockObj);
 27012:     if (!blockbox)
 27012:         return NULL;
 27012: 
104378:     TreeContext *tc = parser->tc;
104378: 
104378:     PushStatementTC(tc, stmt, STMT_BLOCK);
104378:     blockObj.initPrevBlockChainFromParser(tc->blockChain);
104378:     FinishPushBlockScope(tc, stmt, blockObj);
104378: 
 78294:     pn->setOp(JSOP_LEAVEBLOCK);
 27012:     pn->pn_objbox = blockbox;
 47573:     pn->pn_cookie.makeFree();
 27012:     pn->pn_dflags = 0;
104378:     if (!GenerateBlockId(tc, stmt->blockid))
 27012:         return NULL;
 27012:     pn->pn_blockid = stmt->blockid;
     1:     return pn;
     1: }
     1: 
 86078: static ParseNode *
104045: PushLexicalScope(JSContext *cx, Parser *parser, StmtInfoTC *stmt)
 86078: {
 86483:     StaticBlockObject *blockObj = StaticBlockObject::create(cx);
 86483:     if (!blockObj)
 86483:         return NULL;
 86483: 
 98181:     return PushLexicalScope(cx, parser, *blockObj, stmt);
 86078: }
 86078: 
     1: #if JS_HAS_BLOCK_SCOPE
     1: 
 86078: struct AddDecl
 86078: {
 86078:     uint32_t blockid;
 86078: 
 86078:     AddDecl(uint32_t blockid) : blockid(blockid) {}
 86078: 
104045:     bool operator()(TreeContext *tc, StaticBlockObject &blockObj, const Shape &shape, JSAtom *atom)
 86483:     {
 86483:         ParseNode *def = (ParseNode *) blockObj.getSlot(shape.slot()).toPrivate();
 86078:         def->pn_blockid = blockid;
104045:         return Define(def, atom, tc, true);
 86078:     }
 86078: };
 86078: 
 86078: static ParseNode *
104045: PushLetScope(JSContext *cx, Parser *parser, StaticBlockObject &blockObj, StmtInfoTC *stmt)
 98181: {
 98181:     ParseNode *pn = PushLexicalScope(cx, parser, blockObj, stmt);
 86078:     if (!pn)
 86078:         return NULL;
 86078: 
 86078:     /* Tell codegen to emit JSOP_ENTERLETx (not JSOP_ENTERBLOCK). */
 86078:     pn->pn_dflags |= PND_LET;
 86078: 
 86078:     /* Populate the new scope with decls found in the head with updated blockid. */
104045:     if (!ForEachLetDef(parser->tc, blockObj, AddDecl(stmt->blockid)))
 86078:         return NULL;
 86078: 
 86078:     return pn;
 86078: }
 86078: 
 86078: /*
 86078:  * Parse a let block statement or let expression (determined by 'letContext').
 86078:  * In both cases, bindings are not hoisted to the top of the enclosing block
 86078:  * and thus must be carefully injected between variables() and the let body.
 86078:  */
 80631: ParseNode *
 86078: Parser::letBlock(LetContext letContext)
     1: {
 82024:     JS_ASSERT(tokenStream.currentToken().type == TOK_LET);
 82024: 
 98181:     ParseNode *pnlet = BinaryNode::create(PNK_LET, this);
 82024:     if (!pnlet)
 82024:         return NULL;
 82024: 
 99421:     Rooted<StaticBlockObject*> blockObj(context, StaticBlockObject::create(context));
 86078:     if (!blockObj)
 86078:         return NULL;
 86078: 
 82024:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_LET);
 82024: 
 86078:     ParseNode *vars = variables(PNK_LET, blockObj, DontHoistVars);
 86078:     if (!vars)
 86078:         return NULL;
 86078: 
 86078:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_LET);
 86078: 
104045:     StmtInfoTC stmtInfo(context);
 98181:     ParseNode *block = PushLetScope(context, this, *blockObj, &stmtInfo);
 86078:     if (!block)
 86078:         return NULL;
 86078: 
 86078:     pnlet->pn_left = vars;
 86078:     pnlet->pn_right = block;
 86078: 
 86078:     ParseNode *ret;
 86078:     if (letContext == LetStatement && !tokenStream.matchToken(TOK_LC, TSF_OPERAND)) {
     1:         /*
 54158:          * Strict mode eliminates a grammar ambiguity with unparenthesized
 54158:          * LetExpressions in an ExpressionStatement. If followed immediately
 54158:          * by an arguments list, it's ambiguous whether the let expression
 54158:          * is the callee or the call is inside the let expression body.
 54158:          *
 54158:          * See bug 569464.
 54158:          */
102849:         if (!reportStrictModeError(pnlet, JSMSG_STRICT_CODE_LET_EXPR_STMT))
 99779:             return NULL;
 54158: 
 54158:         /*
     1:          * If this is really an expression in let statement guise, then we
     1:          * need to wrap the TOK_LET node in a TOK_SEMI node so that we pop
     1:          * the return value of the expression.
     1:          */
 98181:         ParseNode *semi = UnaryNode::create(PNK_SEMI, this);
 86078:         if (!semi)
 86078:             return NULL;
 86078: 
 86078:         semi->pn_kid = pnlet;
 86078: 
 86078:         letContext = LetExpresion;
 86078:         ret = semi;
 86078:     } else {
 86078:         ret = pnlet;
 86078:     }
 86078: 
 86078:     if (letContext == LetStatement) {
 86078:         JS_ASSERT(block->getOp() == JSOP_LEAVEBLOCK);
 86078:         block->pn_expr = statements();
 86078:         if (!block->pn_expr)
     1:             return NULL;
     1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_LET);
     1:     } else {
 86078:         JS_ASSERT(letContext == LetExpresion);
 86078:         block->setOp(JSOP_LEAVEBLOCKEXPR);
 86078:         block->pn_expr = assignExpr();
 86078:         if (!block->pn_expr)
     1:             return NULL;
     1:     }
     1: 
104045:     PopStatementTC(tc);
 86078:     return ret;
     1: }
     1: 
     1: #endif /* JS_HAS_BLOCK_SCOPE */
     1: 
 27012: static bool
104045: PushBlocklikeStatement(StmtInfoTC *stmt, StmtType type, TreeContext *tc)
104045: {
104045:     PushStatementTC(tc, stmt, type);
104045:     return GenerateBlockId(tc, stmt->blockid);
 27012: }
 27012: 
 80631: static ParseNode *
 98181: NewBindingNode(JSAtom *atom, Parser *parser, StaticBlockObject *blockObj = NULL,
 86078:                VarContext varContext = HoistVars)
 86078: {
104045:     TreeContext *tc = parser->tc;
 98181: 
 86078:     /*
 86078:      * If this name is being injected into an existing block/function, see if
 86078:      * it has already been declared or if it resolves an outstanding lexdep.
 86078:      * Otherwise, this is a let block/expr that introduces a new scope and thus
 86078:      * shadows existing decls and doesn't resolve existing lexdeps. Duplicate
 86078:      * names are caught by BindLet.
 86078:      */
 86078:     if (!blockObj || varContext == HoistVars) {
104045:         ParseNode *pn = tc->decls.lookupFirst(atom);
 72579:         AtomDefnPtr removal;
 86078:         if (pn) {
 27012:             JS_ASSERT(!pn->isPlaceholder());
 27012:         } else {
104045:             removal = tc->lexdeps->lookup(atom);
 72579:             pn = removal ? removal.value() : NULL;
 72579:             JS_ASSERT_IF(pn, pn->isPlaceholder());
 27012:         }
 27012: 
 27012:         if (pn) {
 78294:             JS_ASSERT(pn->isDefn());
 27012: 
 27012:             /*
 27012:              * A let binding at top level becomes a var before we get here, so if
104045:              * pn and tc have the same blockid then that id must not be the bodyid.
 27012:              * If pn is a forward placeholder definition from the same or a higher
 27012:              * block then we claim it.
 27012:              */
104045:             JS_ASSERT_IF(blockObj && pn->pn_blockid == tc->blockid(),
104045:                          pn->pn_blockid != tc->bodyid);
104045: 
104045:             if (pn->isPlaceholder() && pn->pn_blockid >= tc->blockid()) {
104045:                 pn->pn_blockid = tc->blockid();
104045:                 tc->lexdeps->remove(removal);
 27012:                 return pn;
 27012:             }
 27012:         }
 86078:     }
 27012: 
 27012:     /* Make a new node for this declarator name (or destructuring pattern). */
 98181:     JS_ASSERT(parser->tokenStream.currentToken().type == TOK_NAME);
104045:     return NameNode::create(PNK_NAME, atom, parser, parser->tc);
 27012: }
 27012: 
 80631: ParseNode *
 57728: Parser::switchStatement()
     1: {
 98181:     JS_ASSERT(tokenStream.currentToken().type == TOK_SWITCH);
 98181:     ParseNode *pn = BinaryNode::create(PNK_SWITCH, this);
     1:     if (!pn)
     1:         return NULL;
     1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_SWITCH);
     1: 
     1:     /* pn1 points to the switch's discriminant. */
 80631:     ParseNode *pn1 = parenExpr();
     1:     if (!pn1)
     1:         return NULL;
     1: 
     1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_SWITCH);
     1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_SWITCH);
     1: 
 27012:     /*
 27012:      * NB: we must push stmtInfo before calling GenerateBlockIdForStmtNode
104045:      * because that function states tc->topStmt->blockid.
104045:      */
104045:     StmtInfoTC stmtInfo(context);
104045:     PushStatementTC(tc, &stmtInfo, STMT_SWITCH);
 27012: 
     1:     /* pn2 is a list of case nodes. The default case has pn_left == NULL */
 98181:     ParseNode *pn2 = ListNode::create(PNK_STATEMENTLIST, this);
     1:     if (!pn2)
     1:         return NULL;
 27012:     pn2->makeEmpty();
104045:     if (!GenerateBlockIdForStmtNode(pn2, tc))
104045:         return NULL;
104045:     ParseNode *saveBlock = tc->blockNode;
104045:     tc->blockNode = pn2;
     1: 
 82024:     bool seenDefault = false;
 57728:     TokenKind tt;
 40354:     while ((tt = tokenStream.getToken()) != TOK_RC) {
 80631:         ParseNode *pn3;
     1:         switch (tt) {
     1:           case TOK_DEFAULT:
     1:             if (seenDefault) {
102849:                 reportError(NULL, JSMSG_TOO_MANY_DEFAULTS);
     1:                 return NULL;
     1:             }
 82024:             seenDefault = true;
 98181:             pn3 = BinaryNode::create(PNK_DEFAULT, this);
 82024:             if (!pn3)
 82024:                 return NULL;
 82024:             break;
     1: 
     1:           case TOK_CASE:
 57728:           {
 98181:             pn3 = BinaryNode::create(PNK_CASE, this);
     1:             if (!pn3)
     1:                 return NULL;
 40263:             pn3->pn_left = expr();
     1:             if (!pn3->pn_left)
     1:                 return NULL;
 82024:             break;
 82024:           }
 82024: 
 82024:           case TOK_ERROR:
 82024:             return NULL;
 82024: 
 82024:           default:
102849:             reportError(NULL, JSMSG_BAD_SWITCH);
 82024:             return NULL;
 82024:         }
 82024: 
 27012:         pn2->append(pn3);
     1:         if (pn2->pn_count == JS_BIT(16)) {
102849:             reportError(NULL, JSMSG_TOO_MANY_CASES);
     1:             return NULL;
     1:         }
 82024: 
     1:         MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_AFTER_CASE);
     1: 
 98181:         ParseNode *pn4 = ListNode::create(PNK_STATEMENTLIST, this);
     1:         if (!pn4)
     1:             return NULL;
 27012:         pn4->makeEmpty();
 40854:         while ((tt = tokenStream.peekToken(TSF_OPERAND)) != TOK_RC &&
     1:                tt != TOK_CASE && tt != TOK_DEFAULT) {
     1:             if (tt == TOK_ERROR)
     1:                 return NULL;
 82024:             ParseNode *pn5 = statement();
     1:             if (!pn5)
     1:                 return NULL;
     1:             pn4->pn_pos.end = pn5->pn_pos.end;
 27012:             pn4->append(pn5);
 40854:         }
     1: 
     1:         /* Fix the PN_LIST so it doesn't begin at the TOK_COLON. */
     1:         if (pn4->pn_head)
     1:             pn4->pn_pos.begin = pn4->pn_head->pn_pos.begin;
     1:         pn3->pn_pos.end = pn4->pn_pos.end;
     1:         pn3->pn_right = pn4;
     1:     }
     1: 
     1:     /*
     1:      * Handle the case where there was a let declaration in any case in
     1:      * the switch body, but not within an inner block.  If it replaced
104045:      * tc->blockNode with a new block node then we must refresh pn2 and
104045:      * then restore tc->blockNode.
104045:      */
104045:     if (tc->blockNode != pn2)
104045:         pn2 = tc->blockNode;
104045:     tc->blockNode = saveBlock;
104045:     PopStatementTC(tc);
     1: 
 40270:     pn->pn_pos.end = pn2->pn_pos.end = tokenStream.currentToken().pos.end;
     1:     pn->pn_left = pn1;
     1:     pn->pn_right = pn2;
     1:     return pn;
     1: }
     1: 
 89621: bool
 89621: Parser::matchInOrOf(bool *isForOfp)
 89621: {
 89621:     if (tokenStream.matchToken(TOK_IN)) {
 89621:         *isForOfp = false;
 89621:         return true;
 89621:     }
 89621:     if (tokenStream.matchToken(TOK_NAME)) {
 89621:         if (tokenStream.currentToken().name() == context->runtime->atomState.ofAtom) {
 89621:             *isForOfp = true;
 89621:             return true;
 89621:         }
 89621:         tokenStream.ungetToken();
 89621:     }
 89621:     return false;
 89621: }
 89621: 
 80631: ParseNode *
 57728: Parser::forStatement()
     1: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_FOR));
 82024: 
     1:     /* A FOR node is binary, left is loop control and right is the body. */
 98181:     ParseNode *pn = BinaryNode::create(PNK_FOR, this);
     1:     if (!pn)
     1:         return NULL;
 86078: 
104045:     StmtInfoTC forStmt(context);
104045:     PushStatementTC(tc, &forStmt, STMT_FOR_LOOP);
     1: 
 78294:     pn->setOp(JSOP_ITER);
 15613:     pn->pn_iflags = 0;
 40354:     if (tokenStream.matchToken(TOK_NAME)) {
 80443:         if (tokenStream.currentToken().name() == context->runtime->atomState.eachAtom)
 15613:             pn->pn_iflags = JSITER_FOREACH;
     1:         else
 40354:             tokenStream.ungetToken();
     1:     }
     1: 
     1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
 81587: 
 81587:     /*
 81587:      * True if we have 'for (var/let/const ...)', except in the oddball case
 81587:      * where 'let' begins a let-expression in 'for (let (...) ...)'.
 81587:      */
 81587:     bool forDecl = false;
 81587: 
 86078:     /* Non-null when forDecl is true for a 'for (let ...)' statement. */
 99421:     Rooted<StaticBlockObject*> blockObj(context);
 86078: 
 81587:     /* Set to 'x' in 'for (x ;... ;...)' or 'for (x in ...)'. */
 80631:     ParseNode *pn1;
 81587: 
 81587:     {
 81587:         TokenKind tt = tokenStream.peekToken(TSF_OPERAND);
     1:         if (tt == TOK_SEMI) {
 74052:             if (pn->pn_iflags & JSITER_FOREACH) {
102849:                 reportError(pn, JSMSG_BAD_FOR_EACH_LOOP);
 74052:                 return NULL;
 74052:             }
     1: 
     1:             pn1 = NULL;
     1:         } else {
     1:             /*
     1:              * Set pn1 to a var list or an initializing expression.
     1:              *
 98477:              * Set the inForInit flag during parsing of the first clause
     1:              * of the for statement.  This flag will be used by the RelExpr
     1:              * production; if it is set, then the 'in' keyword will not be
     1:              * recognized as an operator, leaving it available to be parsed as
     1:              * part of a for/in loop.
     1:              *
     1:              * A side effect of this restriction is that (unparenthesized)
     1:              * expressions involving an 'in' operator are illegal in the init
     1:              * clause of an ordinary for loop.
     1:              */
104045:             tc->inForInit = true;
 82874:             if (tt == TOK_VAR || tt == TOK_CONST) {
 81587:                 forDecl = true;
 82874:                 tokenStream.consumeKnownToken(tt);
 86078:                 pn1 = variables(tt == TOK_VAR ? PNK_VAR : PNK_CONST);
 82874:             }
     1: #if JS_HAS_BLOCK_SCOPE
 82874:             else if (tt == TOK_LET) {
 40354:                 (void) tokenStream.getToken();
 40354:                 if (tokenStream.peekToken() == TOK_LP) {
 86078:                     pn1 = letBlock(LetExpresion);
     1:                 } else {
 81587:                     forDecl = true;
 86483:                     blockObj = StaticBlockObject::create(context);
 86078:                     if (!blockObj)
 86078:                         return NULL;
 86078:                     pn1 = variables(PNK_LET, blockObj, DontHoistVars);
 82874:                 }
     1:             }
     1: #endif
 82874:             else {
 40263:                 pn1 = expr();
     1:             }
104045:             tc->inForInit = false;
     1:             if (!pn1)
     1:                 return NULL;
     1:         }
 81587:     }
     1: 
 86078:     JS_ASSERT_IF(forDecl, pn1->isArity(PN_LIST));
 86078:     JS_ASSERT(!!blockObj == (forDecl && pn1->isOp(JSOP_NOP)));
 86078: 
 86078:     const TokenPos pos = tokenStream.currentToken().pos;
 86078: 
 86078:     /* If non-null, the parent that should be returned instead of forHead. */
 86078:     ParseNode *forParent = NULL;
 86078: 
     1:     /*
     1:      * We can be sure that it's a for/in loop if there's still an 'in'
     1:      * keyword here, even if JavaScript recognizes 'in' as an operator,
     1:      * as we've excluded 'in' from being parsed in RelExpr by setting
104045:      * tc->inForInit.
 80631:      */
 86078:     ParseNode *forHead;        /* initialized by both branches. */
104045:     StmtInfoTC letStmt(context); /* used if blockObj != NULL. */
 86078:     ParseNode *pn2, *pn3;      /* forHead->pn_kid1 and pn_kid2. */
 89621:     bool forOf;
 89621:     if (pn1 && matchInOrOf(&forOf)) {
 89621:         /*
 89621:          * Parse the rest of the for/in or for/of head.
 74052:          *
 89621:          * Here pn1 is everything to the left of 'in' or 'of'. At the end of
 89621:          * this block, pn1 is a decl or NULL, pn2 is the assignment target that
 89621:          * receives the enumeration value each iteration, and pn3 is the rhs of
 89621:          * 'in'.
 89621:          */
 86078:         forStmt.type = STMT_FOR_IN_LOOP;
     1: 
 89621:         /* Set pn_iflags and rule out invalid combinations. */
 89621:         if (forOf && pn->pn_iflags != 0) {
 89621:             JS_ASSERT(pn->pn_iflags == JSITER_FOREACH);
102849:             reportError(NULL, JSMSG_BAD_FOR_EACH_LOOP);
 89621:             return NULL;
 89621:         }
 89621:         pn->pn_iflags |= (forOf ? JSITER_FOR_OF : JSITER_ENUMERATE);
 89621: 
 89621:         /* Check that the left side of the 'in' or 'of' is valid. */
 81587:         if (forDecl
 78294:             ? (pn1->pn_count > 1 || pn1->isOp(JSOP_DEFCONST)
     1: #if JS_HAS_DESTRUCTURING
 61450:                || (versionNumber() == JSVERSION_1_7 &&
 78294:                    pn->isOp(JSOP_ITER) &&
 15613:                    !(pn->pn_iflags & JSITER_FOREACH) &&
 82024:                    (pn1->pn_head->isKind(PNK_RC) ||
 82024:                     (pn1->pn_head->isKind(PNK_RB) &&
     1:                      pn1->pn_head->pn_count != 2) ||
 82024:                     (pn1->pn_head->isKind(PNK_ASSIGN) &&
 82024:                      (!pn1->pn_head->pn_left->isKind(PNK_RB) ||
     1:                       pn1->pn_head->pn_left->pn_count != 2))))
     1: #endif
     1:               )
 82024:             : (!pn1->isKind(PNK_NAME) &&
 82024:                !pn1->isKind(PNK_DOT) &&
     1: #if JS_HAS_DESTRUCTURING
 61450:                ((versionNumber() == JSVERSION_1_7 &&
 78294:                  pn->isOp(JSOP_ITER) &&
 15613:                  !(pn->pn_iflags & JSITER_FOREACH))
 82024:                 ? (!pn1->isKind(PNK_RB) || pn1->pn_count != 2)
 82024:                 : (!pn1->isKind(PNK_RB) && !pn1->isKind(PNK_RC))) &&
     1: #endif
 82024:                !pn1->isKind(PNK_LP) &&
     1: #if JS_HAS_XML_SUPPORT
 82114:                !pn1->isKind(PNK_XMLUNARY) &&
     1: #endif
 82024:                !pn1->isKind(PNK_LB)))
 82024:         {
102849:             reportError(pn1, JSMSG_BAD_FOR_LEFTSIDE);
     1:             return NULL;
     1:         }
     1: 
 74052:         /*
 74052:          * After the following if-else, pn2 will point to the name or
 74052:          * destructuring pattern on in's left. pn1 will point to the decl, if
 74052:          * any, else NULL. Note that the "declaration with initializer" case
 74052:          * rewrites the loop-head, moving the decl and setting pn1 to NULL.
 74052:          */
 74052:         pn2 = NULL;
 91237:         unsigned dflag = PND_ASSIGNED;
 81587:         if (forDecl) {
 74052:             /* Tell EmitVariables that pn1 is part of a for/in. */
 27012:             pn1->pn_xflags |= PNX_FORINVAR;
     1: 
     1:             pn2 = pn1->pn_head;
 82024:             if ((pn2->isKind(PNK_NAME) && pn2->maybeExpr())
 20413: #if JS_HAS_DESTRUCTURING
 82024:                 || pn2->isKind(PNK_ASSIGN)
 20413: #endif
 82024:                 )
 82024:             {
 74052:                 /*
 74052:                  * Declaration with initializer.
 74052:                  *
 74052:                  * Rewrite 'for (<decl> x = i in o)' where <decl> is 'var' or
 74052:                  * 'const' to hoist the initializer or the entire decl out of
 81587:                  * the loop head.
 74052:                  */
 60541: #if JS_HAS_BLOCK_SCOPE
 86078:                 if (blockObj) {
102849:                     reportError(pn2, JSMSG_INVALID_FOR_IN_INIT);
 60541:                     return NULL;
 60541:                 }
 60541: #endif /* JS_HAS_BLOCK_SCOPE */
 60541: 
 98181:                 ParseNode *pnseq = ListNode::create(PNK_SEQ, this);
 20413:                 if (!pnseq)
 20413:                     return NULL;
 27012: 
 27012:                 dflag = PND_INITIALIZED;
 27012: 
 20413:                 /*
 20413:                  * All of 'var x = i' is hoisted above 'for (x in o)',
 20413:                  * so clear PNX_FORINVAR.
 20413:                  *
 20413:                  * Request JSOP_POP here since the var is for a simple
 20413:                  * name (it is not a destructuring binding's left-hand
 20413:                  * side) and it has an initializer.
 20413:                  */
 27012:                 pn1->pn_xflags &= ~PNX_FORINVAR;
 27012:                 pn1->pn_xflags |= PNX_POPVAR;
 27012:                 pnseq->initList(pn1);
 86078:                 pn1 = NULL;
 20413: 
 20413: #if JS_HAS_DESTRUCTURING
 82024:                 if (pn2->isKind(PNK_ASSIGN)) {
 74052:                     pn2 = pn2->pn_left;
 82024:                     JS_ASSERT(pn2->isKind(PNK_RB) || pn2->isKind(PNK_RC) ||
 82024:                               pn2->isKind(PNK_NAME));
 74052:                 }
 20413: #endif
 86078:                 pnseq->append(pn);
 86078:                 forParent = pnseq;
 86078:             }
 86078:         } else {
 86078:             /* Not a declaration. */
 86078:             JS_ASSERT(!blockObj);
 86078:             pn2 = pn1;
 74052:             pn1 = NULL;
 86078: 
 86078:             if (!setAssignmentLhsOps(pn2, JSOP_NOP))
 86078:                 return NULL;
 86078:         }
 86078: 
 86078:         pn3 = expr();
 86078:         if (!pn3)
 86078:             return NULL;
 86078: 
 86078:         if (blockObj) {
 86078:             /*
 86078:              * Now that the pn3 has been parsed, push the let scope. To hold
 86078:              * the blockObj for the emitter, wrap the TOK_LEXICALSCOPE node
 86078:              * created by PushLetScope around the for's initializer. This also
 86078:              * serves to indicate the let-decl to the emitter.
 86078:              */
 98181:             ParseNode *block = PushLetScope(context, this, *blockObj, &letStmt);
 86078:             if (!block)
 86078:                 return NULL;
103855:             letStmt.isForLetBlock = true;
 86078:             block->pn_expr = pn1;
 86078:             pn1 = block;
 86078:         }
 86078: 
 86078:         if (forDecl) {
 74052:             /*
 74052:              * pn2 is part of a declaration. Make a copy that can be passed to
 86078:              * EmitAssignment. Take care to do this after PushLetScope has
 86078:              * Define's the new binding since this pn2->isDefn() which tells
 86078:              * CloneLeftHandSide to make the new pn2 a use.
 74052:              */
 98181:             pn2 = CloneLeftHandSide(pn2, this);
 74052:             if (!pn2)
 74052:                 return NULL;
     1:         }
     1: 
 78294:         switch (pn2->getKind()) {
 82024:           case PNK_NAME:
     1:             /* Beware 'for (arguments in ...)' with or without a 'var'. */
104045:             NoteLValue(context, pn2, tc->sc, dflag);
     1:             break;
     1: 
     1: #if JS_HAS_DESTRUCTURING
 82024:           case PNK_ASSIGN:
 74052:             JS_NOT_REACHED("forStatement TOK_ASSIGN");
 74052:             break;
 74052: 
 82024:           case PNK_RB:
 82024:           case PNK_RC:
 61450:             if (versionNumber() == JSVERSION_1_7) {
  1599:                 /*
  1599:                  * Destructuring for-in requires [key, value] enumeration
  1599:                  * in JS1.7.
  1599:                  */
 78294:                 JS_ASSERT(pn->isOp(JSOP_ITER));
 15613:                 if (!(pn->pn_iflags & JSITER_FOREACH))
 15613:                     pn->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
  1599:             }
     1:             break;
     1: #endif
     1: 
     1:           default:;
     1:         }
     1: 
 98181:         forHead = TernaryNode::create(PNK_FORIN, this);
 86078:         if (!forHead)
 82024:             return NULL;
     1:     } else {
 86078:         if (blockObj) {
 86078:             /*
 86078:              * Desugar 'for (let A; B; C) D' into 'let (A) { for (; B; C) D }'
 86078:              * to induce the correct scoping for A.
 86078:              */
 98181:             ParseNode *block = PushLetScope(context, this, *blockObj, &letStmt);
 86078:             if (!block)
 86078:                 return NULL;
103855:             letStmt.isForLetBlock = true;
 86078: 
 86078:             ParseNode *let = new_<BinaryNode>(PNK_LET, JSOP_NOP, pos, pn1, block);
 86078:             if (!let)
 86078:                 return NULL;
 86078: 
 86078:             pn1 = NULL;
 86078:             block->pn_expr = pn;
 86078:             forParent = let;
 86078:         }
 86078: 
 74052:         if (pn->pn_iflags & JSITER_FOREACH) {
102849:             reportError(pn, JSMSG_BAD_FOR_EACH_LOOP);
 74052:             return NULL;
 74052:         }
 78294:         pn->setOp(JSOP_NOP);
     1: 
     1:         /* Parse the loop condition or null into pn2. */
     1:         MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_INIT);
 86078:         if (tokenStream.peekToken(TSF_OPERAND) == TOK_SEMI) {
     1:             pn2 = NULL;
     1:         } else {
 40263:             pn2 = expr();
     1:             if (!pn2)
     1:                 return NULL;
     1:         }
     1: 
     1:         /* Parse the update expression or null into pn3. */
     1:         MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_COND);
 86078:         if (tokenStream.peekToken(TSF_OPERAND) == TOK_RP) {
     1:             pn3 = NULL;
     1:         } else {
 40263:             pn3 = expr();
     1:             if (!pn3)
     1:                 return NULL;
     1:         }
     1: 
 98181:         forHead = TernaryNode::create(PNK_FORHEAD, this);
 86078:         if (!forHead)
 86078:             return NULL;
 86078:     }
 86078: 
 86078:     forHead->pn_pos = pos;
 86078:     forHead->setOp(JSOP_NOP);
 86078:     forHead->pn_kid1 = pn1;
 86078:     forHead->pn_kid2 = pn2;
 86078:     forHead->pn_kid3 = pn3;
 86078:     pn->pn_left = forHead;
     1: 
     1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
     1: 
 86078:     /* Parse the loop body. */
 86078:     ParseNode *body = statement();
 86078:     if (!body)
 86078:         return NULL;
     1: 
     1:     /* Record the absolute line number for source note emission. */
 86078:     pn->pn_pos.end = body->pn_pos.end;
 86078:     pn->pn_right = body;
 86078: 
 86078:     if (forParent) {
 86078:         forParent->pn_pos.begin = pn->pn_pos.begin;
 86078:         forParent->pn_pos.end = pn->pn_pos.end;
 86078:     }
     1: 
     1: #if JS_HAS_BLOCK_SCOPE
 86078:     if (blockObj)
104045:         PopStatementTC(tc);
     1: #endif
104045:     PopStatementTC(tc);
 86078:     return forParent ? forParent : pn;
     1: }
     1: 
 80631: ParseNode *
 57728: Parser::tryStatement()
 57728: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_TRY));
     1: 
     1:     /*
     1:      * try nodes are ternary.
 40239:      * kid1 is the try statement
     1:      * kid2 is the catch node list or null
 40239:      * kid3 is the finally statement
     1:      *
     1:      * catch nodes are ternary.
     1:      * kid1 is the lvalue (TOK_NAME, TOK_LB, or TOK_LC)
     1:      * kid2 is the catch guard or null if no guard
     1:      * kid3 is the catch block
     1:      *
     1:      * catch lvalue nodes are either:
     1:      *   TOK_NAME for a single identifier
     1:      *   TOK_RB or TOK_RC for a destructuring left-hand side
     1:      *
 40239:      * finally nodes are TOK_LC statement lists.
 40221:      */
 98181:     ParseNode *pn = TernaryNode::create(PNK_TRY, this);
     1:     if (!pn)
     1:         return NULL;
 78294:     pn->setOp(JSOP_NOP);
     1: 
     1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_TRY);
104045:     StmtInfoTC stmtInfo(context);
104045:     if (!PushBlocklikeStatement(&stmtInfo, STMT_TRY, tc))
 27012:         return NULL;
 40263:     pn->pn_kid1 = statements();
     1:     if (!pn->pn_kid1)
     1:         return NULL;
     1:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_TRY);
104045:     PopStatementTC(tc);
     1: 
 82024:     ParseNode *lastCatch;
 82024:     ParseNode *catchList = NULL;
 57728:     TokenKind tt = tokenStream.getToken();
     1:     if (tt == TOK_CATCH) {
 98181:         catchList = ListNode::create(PNK_CATCHLIST, this);
     1:         if (!catchList)
     1:             return NULL;
 27012:         catchList->makeEmpty();
     1:         lastCatch = NULL;
     1: 
     1:         do {
 80631:             ParseNode *pnblock;
 97353:             BindData data(context);
     1: 
     1:             /* Check for another catch after unconditional catch. */
     1:             if (lastCatch && !lastCatch->pn_kid2) {
102849:                 reportError(NULL, JSMSG_CATCH_AFTER_GENERAL);
     1:                 return NULL;
     1:             }
     1: 
     1:             /*
     1:              * Create a lexical scope node around the whole catch clause,
     1:              * including the head.
     1:              */
 98181:             pnblock = PushLexicalScope(context, this, &stmtInfo);
     1:             if (!pnblock)
     1:                 return NULL;
     1:             stmtInfo.type = STMT_CATCH;
     1: 
     1:             /*
     1:              * Legal catch forms are:
     1:              *   catch (lhs)
     1:              *   catch (lhs if <boolean_expression>)
     1:              * where lhs is a name or a destructuring left-hand side.
     1:              * (the latter is legal only #ifdef JS_HAS_CATCH_GUARD)
     1:              */
 98181:             ParseNode *pn2 = TernaryNode::create(PNK_CATCH, this);
     1:             if (!pn2)
     1:                 return NULL;
     1:             pnblock->pn_expr = pn2;
     1:             MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_CATCH);
     1: 
     1:             /*
     1:              * Contrary to ECMA Ed. 3, the catch variable is lexically
     1:              * scoped, not a property of a new Object instance.  This is
     1:              * an intentional change that anticipates ECMA Ed. 4.
     1:              */
104045:             data.initLet(HoistVars, *tc->blockChain, JSMSG_TOO_MANY_CATCH_VARS);
 86078:             JS_ASSERT(data.let.blockObj && data.let.blockObj == pnblock->pn_objbox->object);
     1: 
 40354:             tt = tokenStream.getToken();
 80631:             ParseNode *pn3;
     1:             switch (tt) {
     1: #if JS_HAS_DESTRUCTURING
     1:               case TOK_LB:
     1:               case TOK_LC:
 40263:                 pn3 = destructuringExpr(&data, tt);
     1:                 if (!pn3)
     1:                     return NULL;
     1:                 break;
     1: #endif
     1: 
     1:               case TOK_NAME:
 57728:               {
 80443:                 JSAtom *label = tokenStream.currentToken().name();
 98181:                 pn3 = NewBindingNode(label, this);
 27012:                 if (!pn3)
 27012:                     return NULL;
 27012:                 data.pn = pn3;
 98181:                 if (!data.binder(context, &data, label, this))
 26970:                     return NULL;
     1:                 break;
 57728:               }
     1: 
     1:               default:
102849:                 reportError(NULL, JSMSG_CATCH_IDENTIFIER);
     1:                 return NULL;
     1:             }
     1: 
     1:             pn2->pn_kid1 = pn3;
     1: #if JS_HAS_CATCH_GUARD
     1:             /*
     1:              * We use 'catch (x if x === 5)' (not 'catch (x : x === 5)')
     1:              * to avoid conflicting with the JS2/ECMAv4 type annotation
     1:              * catchguard syntax.
     1:              */
 40354:             if (tokenStream.matchToken(TOK_IF)) {
 40263:                 pn2->pn_kid2 = expr();
     1:                 if (!pn2->pn_kid2)
     1:                     return NULL;
     1:             }
     1: #endif
     1:             MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_CATCH);
     1: 
     1:             MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_CATCH);
 40263:             pn2->pn_kid3 = statements();
     1:             if (!pn2->pn_kid3)
     1:                 return NULL;
     1:             MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_CATCH);
104045:             PopStatementTC(tc);
 27012: 
 27012:             catchList->append(pnblock);
     1:             lastCatch = pn2;
 40854:             tt = tokenStream.getToken(TSF_OPERAND);
     1:         } while (tt == TOK_CATCH);
     1:     }
     1:     pn->pn_kid2 = catchList;
     1: 
     1:     if (tt == TOK_FINALLY) {
     1:         MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_FINALLY);
104045:         if (!PushBlocklikeStatement(&stmtInfo, STMT_FINALLY, tc))
 27012:             return NULL;
 40263:         pn->pn_kid3 = statements();
     1:         if (!pn->pn_kid3)
     1:             return NULL;
     1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_FINALLY);
104045:         PopStatementTC(tc);
     1:     } else {
 40354:         tokenStream.ungetToken();
     1:     }
     1:     if (!catchList && !pn->pn_kid3) {
102849:         reportError(NULL, JSMSG_CATCH_OR_FINALLY);
     1:         return NULL;
     1:     }
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
 57728: Parser::withStatement()
 52554: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_WITH));
 82024: 
104093:     // In most cases, we want the constructs forbidden in strict mode code to be
104093:     // a subset of those that JSOPTION_STRICT warns about, and we should use
104093:     // reportStrictModeError.  However, 'with' is the sole instance of a
104093:     // construct that is forbidden in strict mode code, but doesn't even merit a
104093:     // warning under JSOPTION_STRICT.  See
104093:     // https://bugzilla.mozilla.org/show_bug.cgi?id=514576#c1. The actual
104093:     // supression of the with code warning is in
104093:     // TokenStream::reportCompileErrorNumberVA.
104093:     if (!reportStrictModeError(NULL, JSMSG_STRICT_CODE_WITH))
104093:         return NULL;
 35305: 
 98181:     ParseNode *pn = BinaryNode::create(PNK_WITH, this);
     1:     if (!pn)
     1:         return NULL;
     1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_WITH);
 80631:     ParseNode *pn2 = parenExpr();
     1:     if (!pn2)
     1:         return NULL;
     1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_WITH);
     1:     pn->pn_left = pn2;
     1: 
104045:     ParseNode *oldWith = tc->innermostWith;
104045:     tc->innermostWith = pn;
104045: 
104045:     StmtInfoTC stmtInfo(context);
104045:     PushStatementTC(tc, &stmtInfo, STMT_WITH);
 40263:     pn2 = statement();
     1:     if (!pn2)
     1:         return NULL;
104045:     PopStatementTC(tc);
     1: 
     1:     pn->pn_pos.end = pn2->pn_pos.end;
     1:     pn->pn_right = pn2;
 95099: 
104045:     tc->sc->setBindingsAccessedDynamically();
104045:     tc->sc->setFunIsHeavyweight();
104045:     tc->innermostWith = oldWith;
 52554: 
 52554:     /*
 52554:      * Make sure to deoptimize lexical dependencies inside the |with|
 52554:      * to safely optimize binding globals (see bug 561923).
 52554:      */
104045:     for (AtomDefnRange r = tc->lexdeps->all(); !r.empty(); r.popFront()) {
 80631:         Definition *defn = r.front().value();
 80631:         Definition *lexdep = defn->resolve();
 52554:         DeoptimizeUsesWithin(lexdep, pn->pn_pos);
 52554:     }
 52554: 
     1:     return pn;
 52554: }
     1: 
     1: #if JS_HAS_BLOCK_SCOPE
 80631: ParseNode *
 57728: Parser::letStatement()
     1: {
 80631:     ParseNode *pn;
 57728:     do {
     1:         /* Check for a let statement or let expression. */
 40354:         if (tokenStream.peekToken() == TOK_LP) {
 86078:             pn = letBlock(LetStatement);
 86078:             if (!pn)
 86078:                 return NULL;
 86078: 
 86078:             JS_ASSERT(pn->isKind(PNK_LET) || pn->isKind(PNK_SEMI));
 86078:             if (pn->isKind(PNK_LET) && pn->pn_expr->getOp() == JSOP_LEAVEBLOCK)
     1:                 return pn;
     1: 
     1:             /* Let expressions require automatic semicolon insertion. */
 86078:             JS_ASSERT(pn->isKind(PNK_SEMI) || pn->isOp(JSOP_NOP));
     1:             break;
     1:         }
     1: 
     1:         /*
 80631:          * This is a let declaration. We must be directly under a block per the
 80631:          * proposed ES4 specs, but not an implicit block created due to
  9976:          * 'for (let ...)'. If we pass this error test, make the enclosing
104045:          * StmtInfoTC be our scope. Further let declarations in this block will
 80631:          * find this scope statement and use the same block object.
  9976:          *
  9976:          * If we are the first let declaration in this block (i.e., when the
104045:          * enclosing maybe-scope StmtInfoTC isn't yet a scope statement) then
104045:          * we also need to set tc->blockNode to be our TOK_LEXICALSCOPE.
104045:          */
104045:         StmtInfoTC *stmt = tc->topStmt;
103855:         if (stmt && (!stmt->maybeScope() || stmt->isForLetBlock)) {
102849:             reportError(NULL, JSMSG_LET_DECL_NOT_IN_BLOCK);
  9832:             return NULL;
     1:         }
     1: 
103855:         if (stmt && stmt->isBlockScope) {
104045:             JS_ASSERT(tc->blockChain == stmt->blockObj);
     1:         } else {
103855:             if (!stmt || stmt->isFunctionBodyBlock) {
     1:                 /*
 16379:                  * ES4 specifies that let at top level and at body-block scope
 16379:                  * does not shadow var, so convert back to var.
     1:                  */
 86078:                 pn = variables(PNK_VAR);
     1:                 if (!pn)
     1:                     return NULL;
 27012:                 pn->pn_xflags |= PNX_POPVAR;
     1:                 break;
     1:             }
     1: 
 18084:             /*
 18084:              * Some obvious assertions here, but they may help clarify the
 18084:              * situation. This stmt is not yet a scope, so it must not be a
 27012:              * catch block (catch is a lexical scope by definition).
 18084:              */
103855:             JS_ASSERT(!stmt->isBlockScope);
104045:             JS_ASSERT(stmt != tc->topScopeStmt);
 18084:             JS_ASSERT(stmt->type == STMT_BLOCK ||
 18084:                       stmt->type == STMT_SWITCH ||
 18084:                       stmt->type == STMT_TRY ||
 18084:                       stmt->type == STMT_FINALLY);
 18084:             JS_ASSERT(!stmt->downScope);
 18084: 
     1:             /* Convert the block statement into a scope statement. */
 98181:             StaticBlockObject *blockObj = StaticBlockObject::create(context);
 86483:             if (!blockObj)
 86483:                 return NULL;
 86483: 
 98181:             ObjectBox *blockbox = newObjectBox(blockObj);
 27012:             if (!blockbox)
     1:                 return NULL;
     1: 
     1:             /*
104045:              * Insert stmt on the tc->topScopeStmt/stmtInfo.downScope linked
     1:              * list stack, if it isn't already there.  If it is there, but it
     1:              * lacks the SIF_SCOPE flag, it must be a try, catch, or finally
     1:              * block.
     1:              */
103855:             stmt->isBlockScope = true;
104045:             stmt->downScope = tc->topScopeStmt;
104045:             tc->topScopeStmt = stmt;
104045: 
104378:             blockObj->initPrevBlockChainFromParser(tc->blockChain);
104045:             tc->blockChain = blockObj;
 86483:             stmt->blockObj = blockObj;
     1: 
     1: #ifdef DEBUG
104045:             ParseNode *tmp = tc->blockNode;
 82024:             JS_ASSERT(!tmp || !tmp->isKind(PNK_LEXICALSCOPE));
     1: #endif
     1: 
     1:             /* Create a new lexical scope node for these statements. */
 98181:             ParseNode *pn1 = LexicalScopeNode::create(PNK_LEXICALSCOPE, this);
     1:             if (!pn1)
     1:                 return NULL;
     1: 
 78294:             pn1->setOp(JSOP_LEAVEBLOCK);
104045:             pn1->pn_pos = tc->blockNode->pn_pos;
 27012:             pn1->pn_objbox = blockbox;
104045:             pn1->pn_expr = tc->blockNode;
104045:             pn1->pn_blockid = tc->blockNode->pn_blockid;
104045:             tc->blockNode = pn1;
104045:         }
104045: 
104045:         pn = variables(PNK_LET, tc->blockChain, HoistVars);
     1:         if (!pn)
     1:             return NULL;
 27012:         pn->pn_xflags = PNX_POPVAR;
 57728:     } while (0);
 57728: 
 57728:     /* Check termination of this primitive statement. */
 57728:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
 57728: }
     1: #endif
     1: 
 80631: ParseNode *
 57728: Parser::expressionStatement()
 57728: {
 40354:     tokenStream.ungetToken();
 80631:     ParseNode *pn2 = expr();
     1:     if (!pn2)
     1:         return NULL;
     1: 
 40354:     if (tokenStream.peekToken() == TOK_COLON) {
 82024:         if (!pn2->isKind(PNK_NAME)) {
102849:             reportError(NULL, JSMSG_BAD_LABEL);
     1:             return NULL;
     1:         }
 57728:         JSAtom *label = pn2->pn_atom;
104045:         for (StmtInfoTC *stmt = tc->topStmt; stmt; stmt = stmt->down) {
 27012:             if (stmt->type == STMT_LABEL && stmt->label == label) {
102849:                 reportError(NULL, JSMSG_DUPLICATE_LABEL);
     1:                 return NULL;
     1:             }
     1:         }
 27012:         ForgetUse(pn2);
 27012: 
 40354:         (void) tokenStream.getToken();
     1: 
     1:         /* Push a label struct and parse the statement. */
104045:         StmtInfoTC stmtInfo(context);
104045:         PushStatementTC(tc, &stmtInfo, STMT_LABEL);
 27012:         stmtInfo.label = label;
 80631:         ParseNode *pn = statement();
     1:         if (!pn)
     1:             return NULL;
     1: 
     1:         /* Normalize empty statement to empty block for the decompiler. */
 82024:         if (pn->isKind(PNK_SEMI) && !pn->pn_kid) {
 82873:             pn->setKind(PNK_STATEMENTLIST);
 78294:             pn->setArity(PN_LIST);
 27012:             pn->makeEmpty();
     1:         }
     1: 
     1:         /* Pop the label, set pn_expr, and return early. */
104045:         PopStatementTC(tc);
 82024:         pn2->setKind(PNK_COLON);
     1:         pn2->pn_pos.end = pn->pn_pos.end;
     1:         pn2->pn_expr = pn;
     1:         return pn2;
     1:     }
     1: 
 98181:     ParseNode *pn = UnaryNode::create(PNK_SEMI, this);
     1:     if (!pn)
     1:         return NULL;
     1:     pn->pn_pos = pn2->pn_pos;
     1:     pn->pn_kid = pn2;
 32658: 
 57728:     /* Check termination of this primitive statement. */
 57728:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
 57728: }
 57728: 
 80631: ParseNode *
 57728: Parser::statement()
 57728: {
 80631:     ParseNode *pn;
 57728: 
 57728:     JS_CHECK_RECURSION(context, return NULL);
 57728: 
 57728:     switch (tokenStream.getToken(TSF_OPERAND)) {
 57728:       case TOK_FUNCTION:
 57728:       {
 57728: #if JS_HAS_XML_SUPPORT
 99820:         if (allowsXML()) {
 57728:             TokenKind tt = tokenStream.peekToken(TSF_KEYWORD_IS_NAME);
 57728:             if (tt == TOK_DBLCOLON)
 80780:                 return expressionStatement();
 80780:         }
 57728: #endif
 57728:         return functionStmt();
 57728:       }
 57728: 
 57728:       case TOK_IF:
 57728:       {
 57728:         /* An IF node has three kids: condition, then, and optional else. */
 98181:         pn = TernaryNode::create(PNK_IF, this);
 57728:         if (!pn)
 57728:             return NULL;
 80631:         ParseNode *pn1 = condition();
 57728:         if (!pn1)
 57728:             return NULL;
 84700: 
104045:         StmtInfoTC stmtInfo(context);
104045:         PushStatementTC(tc, &stmtInfo, STMT_IF);
 80631:         ParseNode *pn2 = statement();
 57728:         if (!pn2)
 57728:             return NULL;
 84700: 
 84700:         if (pn2->isKind(PNK_SEMI) &&
 84700:             !pn2->pn_kid &&
102849:             !reportStrictWarning(NULL, JSMSG_EMPTY_CONSEQUENT))
 84700:         {
 84700:             return NULL;
 84700:         }
 84700: 
 80631:         ParseNode *pn3;
 57728:         if (tokenStream.matchToken(TOK_ELSE, TSF_OPERAND)) {
 57728:             stmtInfo.type = STMT_ELSE;
 57728:             pn3 = statement();
 57728:             if (!pn3)
 57728:                 return NULL;
 57728:             pn->pn_pos.end = pn3->pn_pos.end;
 57728:         } else {
 57728:             pn3 = NULL;
 57728:             pn->pn_pos.end = pn2->pn_pos.end;
 57728:         }
104045:         PopStatementTC(tc);
 57728:         pn->pn_kid1 = pn1;
 57728:         pn->pn_kid2 = pn2;
 57728:         pn->pn_kid3 = pn3;
 57728:         return pn;
 57728:       }
 57728: 
 57728:       case TOK_SWITCH:
 57728:         return switchStatement();
 57728: 
 57728:       case TOK_WHILE:
 57728:       {
 98181:         pn = BinaryNode::create(PNK_WHILE, this);
 57728:         if (!pn)
 57728:             return NULL;
104045:         StmtInfoTC stmtInfo(context);
104045:         PushStatementTC(tc, &stmtInfo, STMT_WHILE_LOOP);
 80631:         ParseNode *pn2 = condition();
 57728:         if (!pn2)
 57728:             return NULL;
 57728:         pn->pn_left = pn2;
 80631:         ParseNode *pn3 = statement();
 57728:         if (!pn3)
 57728:             return NULL;
104045:         PopStatementTC(tc);
 57728:         pn->pn_pos.end = pn3->pn_pos.end;
 57728:         pn->pn_right = pn3;
 57728:         return pn;
 57728:       }
 57728: 
 57728:       case TOK_DO:
 57728:       {
 98181:         pn = BinaryNode::create(PNK_DOWHILE, this);
 57728:         if (!pn)
 57728:             return NULL;
104045:         StmtInfoTC stmtInfo(context);
104045:         PushStatementTC(tc, &stmtInfo, STMT_DO_LOOP);
 80631:         ParseNode *pn2 = statement();
 57728:         if (!pn2)
 57728:             return NULL;
 57728:         pn->pn_left = pn2;
 57728:         MUST_MATCH_TOKEN(TOK_WHILE, JSMSG_WHILE_AFTER_DO);
 80631:         ParseNode *pn3 = condition();
 57728:         if (!pn3)
 57728:             return NULL;
104045:         PopStatementTC(tc);
 57728:         pn->pn_pos.end = pn3->pn_pos.end;
 57728:         pn->pn_right = pn3;
 61450:         if (versionNumber() != JSVERSION_ECMA_3) {
 57728:             /*
 57728:              * All legacy and extended versions must do automatic semicolon
 57728:              * insertion after do-while.  See the testcase and discussion in
 57728:              * http://bugzilla.mozilla.org/show_bug.cgi?id=238945.
 57728:              */
 57728:             (void) tokenStream.matchToken(TOK_SEMI);
 57728:             return pn;
 57728:         }
 57728:         break;
 57728:       }
 57728: 
 57728:       case TOK_FOR:
 57728:         return forStatement();
 57728: 
 57728:       case TOK_TRY:
 57728:         return tryStatement();
 57728: 
 57728:       case TOK_THROW:
 57728:       {
 98181:         pn = UnaryNode::create(PNK_THROW, this);
 57728:         if (!pn)
 57728:             return NULL;
 57728: 
 57728:         /* ECMA-262 Edition 3 says 'throw [no LineTerminator here] Expr'. */
 57728:         TokenKind tt = tokenStream.peekTokenSameLine(TSF_OPERAND);
 57728:         if (tt == TOK_ERROR)
 57728:             return NULL;
 57728:         if (tt == TOK_EOF || tt == TOK_EOL || tt == TOK_SEMI || tt == TOK_RC) {
102849:             reportError(NULL, JSMSG_SYNTAX_ERROR);
 57728:             return NULL;
 57728:         }
 57728: 
 80631:         ParseNode *pn2 = expr();
 57728:         if (!pn2)
 57728:             return NULL;
 57728:         pn->pn_pos.end = pn2->pn_pos.end;
 78294:         pn->setOp(JSOP_THROW);
 57728:         pn->pn_kid = pn2;
 57728:         break;
 57728:       }
 57728: 
 57728:       /* TOK_CATCH and TOK_FINALLY are both handled in the TOK_TRY case */
 57728:       case TOK_CATCH:
102849:         reportError(NULL, JSMSG_CATCH_WITHOUT_TRY);
 57728:         return NULL;
 57728: 
 57728:       case TOK_FINALLY:
102849:         reportError(NULL, JSMSG_FINALLY_WITHOUT_TRY);
 57728:         return NULL;
 57728: 
 57728:       case TOK_BREAK:
 57728:       {
 84666:         TokenPtr begin = tokenStream.currentToken().pos.begin;
 84666:         PropertyName *label;
 84666:         if (!MatchLabel(context, &tokenStream, &label))
 84666:             return NULL;
 84666:         TokenPtr end = tokenStream.currentToken().pos.end;
 84666:         pn = new_<BreakStatement>(label, begin, end);
 57728:         if (!pn)
 57728:             return NULL;
104045:         StmtInfoTC *stmt = tc->topStmt;
 57728:         if (label) {
 57728:             for (; ; stmt = stmt->down) {
 57728:                 if (!stmt) {
102849:                     reportError(NULL, JSMSG_LABEL_NOT_FOUND);
 57728:                     return NULL;
 57728:                 }
 57728:                 if (stmt->type == STMT_LABEL && stmt->label == label)
 57728:                     break;
 57728:             }
 57728:         } else {
 57728:             for (; ; stmt = stmt->down) {
 57728:                 if (!stmt) {
102849:                     reportError(NULL, JSMSG_TOUGH_BREAK);
 57728:                     return NULL;
 57728:                 }
103854:                 if (stmt->isLoop() || stmt->type == STMT_SWITCH)
 57728:                     break;
 57728:             }
 57728:         }
 57728:         break;
 57728:       }
 57728: 
 57728:       case TOK_CONTINUE:
 57728:       {
 84666:         TokenPtr begin = tokenStream.currentToken().pos.begin;
 84666:         PropertyName *label;
 84666:         if (!MatchLabel(context, &tokenStream, &label))
 84666:             return NULL;
 84666:         TokenPtr end = tokenStream.currentToken().pos.begin;
 84666:         pn = new_<ContinueStatement>(label, begin, end);
 57728:         if (!pn)
 57728:             return NULL;
104045:         StmtInfoTC *stmt = tc->topStmt;
 57728:         if (label) {
104045:             for (StmtInfoTC *stmt2 = NULL; ; stmt = stmt->down) {
 57728:                 if (!stmt) {
102849:                     reportError(NULL, JSMSG_LABEL_NOT_FOUND);
 57728:                     return NULL;
 57728:                 }
 57728:                 if (stmt->type == STMT_LABEL) {
 57728:                     if (stmt->label == label) {
103854:                         if (!stmt2 || !stmt2->isLoop()) {
102849:                             reportError(NULL, JSMSG_BAD_CONTINUE);
 57728:                             return NULL;
 57728:                         }
 57728:                         break;
 57728:                     }
 57728:                 } else {
 57728:                     stmt2 = stmt;
 57728:                 }
 57728:             }
 57728:         } else {
 57728:             for (; ; stmt = stmt->down) {
 57728:                 if (!stmt) {
102849:                     reportError(NULL, JSMSG_BAD_CONTINUE);
 57728:                     return NULL;
 57728:                 }
103854:                 if (stmt->isLoop())
 57728:                     break;
 57728:             }
 57728:         }
 57728:         break;
 57728:       }
 57728: 
 57728:       case TOK_WITH:
 57728:         return withStatement();
 57728: 
 57728:       case TOK_VAR:
 86078:         pn = variables(PNK_VAR);
 82874:         if (!pn)
 82874:             return NULL;
 82874: 
 82874:         /* Tell js_EmitTree to generate a final POP. */
 82874:         pn->pn_xflags |= PNX_POPVAR;
 82874:         break;
 82874: 
 82874:       case TOK_CONST:
 86078:         pn = variables(PNK_CONST);
 57728:         if (!pn)
 57728:             return NULL;
 57728: 
 57728:         /* Tell js_EmitTree to generate a final POP. */
 57728:         pn->pn_xflags |= PNX_POPVAR;
 57728:         break;
 57728: 
 57728: #if JS_HAS_BLOCK_SCOPE
 57728:       case TOK_LET:
 57728:         return letStatement();
 57728: #endif /* JS_HAS_BLOCK_SCOPE */
 57728: 
 57728:       case TOK_RETURN:
 57728:         pn = returnOrYield(false);
 57728:         if (!pn)
 57728:             return NULL;
 57728:         break;
 57728: 
 57728:       case TOK_LC:
 57728:       {
104045:         StmtInfoTC stmtInfo(context);
104045:         if (!PushBlocklikeStatement(&stmtInfo, STMT_BLOCK, tc))
 57728:             return NULL;
 98452:         bool hasFunctionStmt;
 98452:         pn = statements(&hasFunctionStmt);
 57728:         if (!pn)
 57728:             return NULL;
 57728: 
 57728:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_COMPOUND);
104045:         PopStatementTC(tc);
 57728: 
 57728:         /*
 57728:          * If we contain a function statement and our container is top-level
 57728:          * or another block, flag pn to preserve braces when decompiling.
 57728:          */
104045:         if (hasFunctionStmt && (!tc->topStmt || tc->topStmt->type == STMT_BLOCK))
 57728:             pn->pn_xflags |= PNX_NEEDBRACES;
 98452: 
 57728:         return pn;
 57728:       }
 57728: 
 57728:       case TOK_SEMI:
 98181:         pn = UnaryNode::create(PNK_SEMI, this);
 57728:         if (!pn)
 57728:             return NULL;
 57728:         return pn;
 57728: 
 57728:       case TOK_DEBUGGER:
 98181:         pn = new_<DebuggerStatement>(tokenStream.currentToken().pos);
 57728:         if (!pn)
 57728:             return NULL;
104045:         tc->sc->setFunIsHeavyweight();
104045:         tc->sc->setBindingsAccessedDynamically();
 57728:         break;
 57728: 
 57728: #if JS_HAS_XML_SUPPORT
 57728:       case TOK_DEFAULT:
 57728:       {
 99820:         if (!allowsXML())
 80780:             return expressionStatement();
 80780: 
 98181:         pn = UnaryNode::create(PNK_DEFXMLNS, this);
 57728:         if (!pn)
 57728:             return NULL;
 57728:         if (!tokenStream.matchToken(TOK_NAME) ||
 80443:             tokenStream.currentToken().name() != context->runtime->atomState.xmlAtom ||
 57728:             !tokenStream.matchToken(TOK_NAME) ||
 80443:             tokenStream.currentToken().name() != context->runtime->atomState.namespaceAtom ||
 82023:             !tokenStream.matchToken(TOK_ASSIGN))
 82023:         {
102849:             reportError(NULL, JSMSG_BAD_DEFAULT_XML_NAMESPACE);
 57728:             return NULL;
 57728:         }
 57728: 
 82023:         JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NOP);
 82023: 
 57728:         /* Is this an E4X dagger I see before me? */
104045:         tc->sc->setFunIsHeavyweight();
 80631:         ParseNode *pn2 = expr();
 57728:         if (!pn2)
 57728:             return NULL;
 78294:         pn->setOp(JSOP_DEFXMLNS);
 57728:         pn->pn_pos.end = pn2->pn_pos.end;
 57728:         pn->pn_kid = pn2;
 57728:         break;
 57728:       }
 57728: #endif
 57728: 
 57728:       case TOK_ERROR:
 57728:         return NULL;
 57728: 
 57728:       default:
 57728:         return expressionStatement();
     1:     }
     1: 
     1:     /* Check termination of this primitive statement. */
 40239:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
     1: }
     1: 
 86078: /*
 86078:  * The 'blockObj' parameter is non-null when parsing the 'vars' in a let
 86078:  * expression, block statement, non-top-level let declaration in statement
 86078:  * context, and the let-initializer of a for-statement.
 86078:  */
 80631: ParseNode *
 86483: Parser::variables(ParseNodeKind kind, StaticBlockObject *blockObj, VarContext varContext)
 82874: {
 82874:     /*
 82874:      * The four options here are:
 82874:      * - PNK_VAR:   We're parsing var declarations.
 82874:      * - PNK_CONST: We're parsing const declarations.
 82874:      * - PNK_LET:   We are parsing a let declaration.
 82874:      * - PNK_LP:    We are parsing the head of a let block.
 82874:      */
 82874:     JS_ASSERT(kind == PNK_VAR || kind == PNK_CONST || kind == PNK_LET || kind == PNK_LP);
 82874: 
 98181:     ParseNode *pn = ListNode::create(kind, this);
     1:     if (!pn)
     1:         return NULL;
 86078: 
 86078:     pn->setOp(blockObj ? JSOP_NOP : kind == PNK_VAR ? JSOP_DEFVAR : JSOP_DEFCONST);
 27012:     pn->makeEmpty();
 27012: 
 27012:     /*
 27012:      * SpiderMonkey const is really "write once per initialization evaluation"
 27012:      * var, whereas let is block scoped. ES-Harmony wants block-scoped const so
 27012:      * this code will change soon.
     1:      */
 97353:     BindData data(context);
 86078:     if (blockObj)
 86483:         data.initLet(varContext, *blockObj, JSMSG_TOO_MANY_LOCALS);
 86078:     else
 86078:         data.initVarOrConst(pn->getOp());
     1: 
 82024:     ParseNode *pn2;
     1:     do {
 82874:         TokenKind tt = tokenStream.getToken();
     1: #if JS_HAS_DESTRUCTURING
     1:         if (tt == TOK_LB || tt == TOK_LC) {
104045:             tc->inDeclDestructuring = true;
103823:             pn2 = primaryExpr(tt, false);
104045:             tc->inDeclDestructuring = false;
     1:             if (!pn2)
     1:                 return NULL;
     1: 
 98181:             if (!CheckDestructuring(context, &data, pn2, this))
 28995:                 return NULL;
 89621:             bool ignored;
104045:             if (tc->inForInit && matchInOrOf(&ignored)) {
 89621:                 tokenStream.ungetToken();
 27012:                 pn->append(pn2);
     1:                 continue;
     1:             }
     1: 
     1:             MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_BAD_DESTRUCT_DECL);
 82023:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NOP);
     1: 
 80631:             ParseNode *init = assignExpr();
 68923:             if (!init)
 68923:                 return NULL;
 28995: 
 98181:             pn2 = ParseNode::newBinaryOrAppend(PNK_ASSIGN, JSOP_NOP, pn2, init, this);
 28995:             if (!pn2)
 28995:                 return NULL;
 27012:             pn->append(pn2);
     1:             continue;
     1:         }
 27012: #endif /* JS_HAS_DESTRUCTURING */
     1: 
     1:         if (tt != TOK_NAME) {
 74052:             if (tt != TOK_ERROR)
102849:                 reportError(NULL, JSMSG_NO_VARIABLE_NAME);
 27012:             return NULL;
 27012:         }
 27012: 
 80443:         PropertyName *name = tokenStream.currentToken().name();
 98181:         pn2 = NewBindingNode(name, this, blockObj, varContext);
 27012:         if (!pn2)
 27012:             return NULL;
 27012:         if (data.op == JSOP_DEFCONST)
 27012:             pn2->pn_dflags |= PND_CONST;
 27012:         data.pn = pn2;
 98181:         if (!data.binder(context, &data, name, this))
 26970:             return NULL;
 27012:         pn->append(pn2);
     1: 
 40354:         if (tokenStream.matchToken(TOK_ASSIGN)) {
 82023:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NOP);
     1: 
 80631:             ParseNode *init = assignExpr();
 27012:             if (!init)
 27012:                 return NULL;
 27012: 
 78294:             if (pn2->isUsed()) {
 98181:                 pn2 = MakeAssignment(pn2, init, this);
 27012:                 if (!pn2)
 27012:                     return NULL;
 27012:             } else {
 27012:                 pn2->pn_expr = init;
 27012:             }
 27012: 
 95100:             pn2->setOp((pn2->pn_dflags & PND_BOUND)
 27012:                        ? JSOP_SETLOCAL
 27012:                        : (data.op == JSOP_DEFCONST)
     1:                        ? JSOP_SETCONST
 78294:                        : JSOP_SETNAME);
 27012: 
104045:             NoteLValue(context, pn2, tc->sc, data.fresh ? PND_INITIALIZED : PND_ASSIGNED);
 27012: 
 27012:             /* The declarator's position must include the initializer. */
 27012:             pn2->pn_pos.end = init->pn_pos.end;
 27012:         }
 40354:     } while (tokenStream.matchToken(TOK_COMMA));
     1: 
 27012:     pn->pn_pos.end = pn->last()->pn_pos.end;
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::expr()
     1: {
 80631:     ParseNode *pn = assignExpr();
 40354:     if (pn && tokenStream.matchToken(TOK_COMMA)) {
 98181:         ParseNode *pn2 = ListNode::create(PNK_COMMA, this);
     1:         if (!pn2)
     1:             return NULL;
     1:         pn2->pn_pos.begin = pn->pn_pos.begin;
 27012:         pn2->initList(pn);
     1:         pn = pn2;
     1:         do {
     1: #if JS_HAS_GENERATORS
 27012:             pn2 = pn->last();
 82024:             if (pn2->isKind(PNK_YIELD) && !pn2->isInParens()) {
102849:                 reportError(pn2, JSMSG_BAD_GENERATOR_SYNTAX, js_yield_str);
     1:                 return NULL;
     1:             }
     1: #endif
 40263:             pn2 = assignExpr();
     1:             if (!pn2)
     1:                 return NULL;
 27012:             pn->append(pn2);
 40354:         } while (tokenStream.matchToken(TOK_COMMA));
 27012:         pn->pn_pos.end = pn->last()->pn_pos.end;
     1:     }
     1:     return pn;
     1: }
     1: 
 64367: /*
 64367:  * For a number of the expression parsers we define an always-inlined version
 64367:  * and a never-inlined version (which just calls the always-inlined version).
 64367:  * Using the always-inlined version in the hot call-sites givs a ~5% parsing
 64367:  * speedup.  These macros help avoid some boilerplate code.
 64367:  */
 64367: #define BEGIN_EXPR_PARSER(name)                                               \
 80631:     JS_ALWAYS_INLINE ParseNode *                                              \
 64367:     Parser::name##i()
 64367: 
 64367: #define END_EXPR_PARSER(name)                                                 \
 80631:     JS_NEVER_INLINE ParseNode *                                               \
 64367:     Parser::name##n() {                                                       \
 64367:         return name##i();                                                     \
 64367:     }
 64367: 
 64367: BEGIN_EXPR_PARSER(mulExpr1)
 64367: {
 80631:     ParseNode *pn = unaryExpr();
 64367: 
 64367:     /*
 64367:      * Note: unlike addExpr1() et al, we use getToken() here instead of
 64367:      * isCurrentTokenType() because unaryExpr() doesn't leave the TokenStream
 64367:      * state one past the end of the unary expression.
 64367:      */
 82024:     TokenKind tt;
 82021:     while (pn && ((tt = tokenStream.getToken()) == TOK_STAR || tt == TOK_DIV || tt == TOK_MOD)) {
 82024:         ParseNodeKind kind = (tt == TOK_STAR)
 82024:                              ? PNK_STAR
 82024:                              : (tt == TOK_DIV)
 82024:                              ? PNK_DIV
 82024:                              : PNK_MOD;
 64367:         JSOp op = tokenStream.currentToken().t_op;
 98181:         pn = ParseNode::newBinaryOrAppend(kind, op, pn, unaryExpr(), this);
 64367:     }
     1:     return pn;
     1: }
 64367: END_EXPR_PARSER(mulExpr1)
 64367: 
 64367: BEGIN_EXPR_PARSER(addExpr1)
 64367: {
 80631:     ParseNode *pn = mulExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_PLUS, TOK_MINUS)) {
 64367:         TokenKind tt = tokenStream.currentToken().type;
 64367:         JSOp op = (tt == TOK_PLUS) ? JSOP_ADD : JSOP_SUB;
 82870:         ParseNodeKind kind = (tt == TOK_PLUS) ? PNK_ADD : PNK_SUB;
 98181:         pn = ParseNode::newBinaryOrAppend(kind, op, pn, mulExpr1n(), this);
 64367:     }
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(addExpr1)
 64367: 
 82024: inline ParseNodeKind
 82024: ShiftTokenToParseNodeKind(const Token &token)
 82024: {
 82024:     switch (token.type) {
 82024:       case TOK_LSH:
 82024:         return PNK_LSH;
 82024:       case TOK_RSH:
 82024:         return PNK_RSH;
 82024:       default:
 82024:         JS_ASSERT(token.type == TOK_URSH);
 82024:         return PNK_URSH;
 82024:     }
 82024: }
 82024: 
 64367: BEGIN_EXPR_PARSER(shiftExpr1)
 64367: {
 82020:     ParseNode *left = addExpr1i();
 82020:     while (left && tokenStream.isCurrentTokenShift()) {
 82024:         ParseNodeKind kind = ShiftTokenToParseNodeKind(tokenStream.currentToken());
 42671:         JSOp op = tokenStream.currentToken().t_op;
 82020:         ParseNode *right = addExpr1n();
 82020:         if (!right)
 82020:             return NULL;
 98181:         left = new_<BinaryNode>(kind, op, left, right);
 82020:     }
 82020:     return left;
 64367: }
 64367: END_EXPR_PARSER(shiftExpr1)
 64367: 
 82024: inline ParseNodeKind
 82024: RelationalTokenToParseNodeKind(const Token &token)
 82024: {
 82024:     switch (token.type) {
 82024:       case TOK_IN:
 82024:         return PNK_IN;
 82024:       case TOK_INSTANCEOF:
 82024:         return PNK_INSTANCEOF;
 82024:       case TOK_LT:
 82024:         return PNK_LT;
 82024:       case TOK_LE:
 82024:         return PNK_LE;
 82024:       case TOK_GT:
 82024:         return PNK_GT;
 82024:       default:
 82024:         JS_ASSERT(token.type == TOK_GE);
 82024:         return PNK_GE;
 82024:     }
 82024: }
 82024: 
 64367: BEGIN_EXPR_PARSER(relExpr1)
 64367: {
 64367:     /*
 64367:      * Uses of the in operator in shiftExprs are always unambiguous,
 64367:      * so unset the flag that prohibits recognizing it.
 64367:      */
104045:     bool oldInForInit = tc->inForInit;
104045:     tc->inForInit = false;
 64367: 
 80631:     ParseNode *pn = shiftExpr1i();
 64367:     while (pn &&
 82019:            (tokenStream.isCurrentTokenRelational() ||
 64367:             /*
 64367:              * Recognize the 'in' token as an operator only if we're not
 64367:              * currently in the init expr of a for loop.
 64367:              */
 98477:             (oldInForInit == 0 && tokenStream.isCurrentTokenType(TOK_IN)) ||
 64367:             tokenStream.isCurrentTokenType(TOK_INSTANCEOF))) {
 82024:         ParseNodeKind kind = RelationalTokenToParseNodeKind(tokenStream.currentToken());
 64367:         JSOp op = tokenStream.currentToken().t_op;
 98181:         pn = ParseNode::newBinaryOrAppend(kind, op, pn, shiftExpr1n(), this);
 64367:     }
 64367:     /* Restore previous state of inForInit flag. */
104045:     tc->inForInit |= oldInForInit;
 64367: 
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(relExpr1)
 64367: 
 82024: inline ParseNodeKind
 82024: EqualityTokenToParseNodeKind(const Token &token)
 82024: {
 82024:     switch (token.type) {
 82024:       case TOK_STRICTEQ:
 82024:         return PNK_STRICTEQ;
 82024:       case TOK_EQ:
 82024:         return PNK_EQ;
 82024:       case TOK_STRICTNE:
 82024:         return PNK_STRICTNE;
 82024:       default:
 82024:         JS_ASSERT(token.type == TOK_NE);
 82024:         return PNK_NE;
 82024:     }
 82024: }
 82024: 
 64367: BEGIN_EXPR_PARSER(eqExpr1)
 64367: {
 82015:     ParseNode *left = relExpr1i();
 82015:     while (left && tokenStream.isCurrentTokenEquality()) {
 82024:         ParseNodeKind kind = EqualityTokenToParseNodeKind(tokenStream.currentToken());
 64367:         JSOp op = tokenStream.currentToken().t_op;
 82015:         ParseNode *right = relExpr1n();
 82015:         if (!right)
 82015:             return NULL;
 98181:         left = new_<BinaryNode>(kind, op, left, right);
 82015:     }
 82015:     return left;
 64367: }
 64367: END_EXPR_PARSER(eqExpr1)
 64367: 
 64367: BEGIN_EXPR_PARSER(bitAndExpr1)
 64367: {
 80631:     ParseNode *pn = eqExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITAND))
 98181:         pn = ParseNode::newBinaryOrAppend(PNK_BITAND, JSOP_BITAND, pn, eqExpr1n(), this);
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(bitAndExpr1)
 64367: 
 64367: BEGIN_EXPR_PARSER(bitXorExpr1)
 64367: {
 80631:     ParseNode *pn = bitAndExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITXOR))
 98181:         pn = ParseNode::newBinaryOrAppend(PNK_BITXOR, JSOP_BITXOR, pn, bitAndExpr1n(), this);
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(bitXorExpr1)
 64367: 
 64367: BEGIN_EXPR_PARSER(bitOrExpr1)
 64367: {
 80631:     ParseNode *pn = bitXorExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITOR))
 98181:         pn = ParseNode::newBinaryOrAppend(PNK_BITOR, JSOP_BITOR, pn, bitXorExpr1n(), this);
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(bitOrExpr1)
 64367: 
 64367: BEGIN_EXPR_PARSER(andExpr1)
 64367: {
 80631:     ParseNode *pn = bitOrExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_AND))
 98181:         pn = ParseNode::newBinaryOrAppend(PNK_AND, JSOP_AND, pn, bitOrExpr1n(), this);
 64367:     return pn;
 64367: }
 64367: END_EXPR_PARSER(andExpr1)
 64367: 
 80631: JS_ALWAYS_INLINE ParseNode *
 64367: Parser::orExpr1()
 64367: {
 80631:     ParseNode *pn = andExpr1i();
 64367:     while (pn && tokenStream.isCurrentTokenType(TOK_OR))
 98181:         pn = ParseNode::newBinaryOrAppend(PNK_OR, JSOP_OR, pn, andExpr1n(), this);
 64367:     return pn;
 64367: }
 64367: 
 80631: JS_ALWAYS_INLINE ParseNode *
 64366: Parser::condExpr1()
 64366: {
 86379:     ParseNode *condition = orExpr1();
 86379:     if (!condition || !tokenStream.isCurrentTokenType(TOK_HOOK))
 86379:         return condition;
 40327: 
     1:     /*
     1:      * Always accept the 'in' operator in the middle clause of a ternary,
     1:      * where it's unambiguous, even if we might be parsing the init of a
     1:      * for statement.
     1:      */
104045:     bool oldInForInit = tc->inForInit;
104045:     tc->inForInit = false;
 86379:     ParseNode *thenExpr = assignExpr();
104045:     tc->inForInit = oldInForInit;
 86379:     if (!thenExpr)
 86379:         return NULL;
 86379: 
     1:     MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_IN_COND);
 86379: 
 86379:     ParseNode *elseExpr = assignExpr();
 86379:     if (!elseExpr)
 86379:         return NULL;
 86379: 
 86379:     tokenStream.getToken(); /* read one token past the end */
 86379:     return new_<ConditionalExpression>(condition, thenExpr, elseExpr);
     1: }
     1: 
 74052: bool
 80631: Parser::setAssignmentLhsOps(ParseNode *pn, JSOp op)
 74052: {
 78294:     switch (pn->getKind()) {
 82024:       case PNK_NAME:
 98181:         if (!CheckStrictAssignment(context, this, pn))
 74052:             return false;
 78294:         pn->setOp(pn->isOp(JSOP_GETLOCAL) ? JSOP_SETLOCAL : JSOP_SETNAME);
104045:         NoteLValue(context, pn, tc->sc);
 74052:         break;
 82024:       case PNK_DOT:
 78294:         pn->setOp(JSOP_SETPROP);
 74052:         break;
 82024:       case PNK_LB:
 78294:         pn->setOp(JSOP_SETELEM);
 74052:         break;
 74052: #if JS_HAS_DESTRUCTURING
 82024:       case PNK_RB:
 82024:       case PNK_RC:
 74052:         if (op != JSOP_NOP) {
102849:             reportError(NULL, JSMSG_BAD_DESTRUCT_ASS);
 74052:             return false;
 74052:         }
 98181:         if (!CheckDestructuring(context, NULL, pn, this))
 74052:             return false;
 74052:         break;
 74052: #endif
 82024:       case PNK_LP:
 98181:         if (!MakeSetCall(context, pn, this, JSMSG_BAD_LEFTSIDE_OF_ASS))
 74052:             return false;
 74052:         break;
 74052: #if JS_HAS_XML_SUPPORT
 82114:       case PNK_XMLUNARY:
 82018:         JS_ASSERT(pn->isOp(JSOP_XMLNAME));
 78294:         pn->setOp(JSOP_SETXMLNAME);
 74052:         break;
 74052: #endif
 74052:       default:
102849:         reportError(NULL, JSMSG_BAD_LEFTSIDE_OF_ASS);
 74052:         return false;
 74052:     }
 74052:     return true;
 74052: }
 74052: 
 80631: ParseNode *
 64367: Parser::assignExpr()
 64367: {
 64367:     JS_CHECK_RECURSION(context, return NULL);
 64367: 
 64367: #if JS_HAS_GENERATORS
 64367:     if (tokenStream.matchToken(TOK_YIELD, TSF_OPERAND))
 64367:         return returnOrYield(true);
 64367: #endif
 64367: 
 82024:     ParseNode *lhs = condExpr1();
 82024:     if (!lhs)
 82024:         return NULL;
 82024: 
 82024:     ParseNodeKind kind;
 82024:     switch (tokenStream.currentToken().type) {
 82024:       case TOK_ASSIGN:       kind = PNK_ASSIGN;       break;
 82024:       case TOK_ADDASSIGN:    kind = PNK_ADDASSIGN;    break;
 82024:       case TOK_SUBASSIGN:    kind = PNK_SUBASSIGN;    break;
 82024:       case TOK_BITORASSIGN:  kind = PNK_BITORASSIGN;  break;
 82024:       case TOK_BITXORASSIGN: kind = PNK_BITXORASSIGN; break;
 82024:       case TOK_BITANDASSIGN: kind = PNK_BITANDASSIGN; break;
 82024:       case TOK_LSHASSIGN:    kind = PNK_LSHASSIGN;    break;
 82024:       case TOK_RSHASSIGN:    kind = PNK_RSHASSIGN;    break;
 82024:       case TOK_URSHASSIGN:   kind = PNK_URSHASSIGN;   break;
 82024:       case TOK_MULASSIGN:    kind = PNK_MULASSIGN;    break;
 82024:       case TOK_DIVASSIGN:    kind = PNK_DIVASSIGN;    break;
 82024:       case TOK_MODASSIGN:    kind = PNK_MODASSIGN;    break;
 82024:       default:
 82024:         JS_ASSERT(!tokenStream.isCurrentTokenAssignment());
 64367:         tokenStream.ungetToken();
 82024:         return lhs;
 82024:     }
 82024: 
 42671:     JSOp op = tokenStream.currentToken().t_op;
 82024:     if (!setAssignmentLhsOps(lhs, op))
 74052:         return NULL;
 74052: 
 80631:     ParseNode *rhs = assignExpr();
 74052:     if (!rhs)
 74052:         return NULL;
 82024:     if (lhs->isKind(PNK_NAME) && lhs->isUsed()) {
 82024:         Definition *dn = lhs->pn_lexdef;
 64367: 
 64367:         /*
 64367:          * If the definition is not flagged as assigned, we must have imputed
 64367:          * the initialized flag to it, to optimize for flat closures. But that
 64367:          * optimization uses source coordinates to check dominance relations,
 64367:          * so we must extend the end of the definition to cover the right-hand
 64367:          * side of this assignment, i.e., the initializer.
 64367:          */
 64367:         if (!dn->isAssigned()) {
 64367:             JS_ASSERT(dn->isInitialized());
 64367:             dn->pn_pos.end = rhs->pn_pos.end;
 64367:         }
 64367:     }
 64367: 
 98181:     return ParseNode::newBinaryOrAppend(kind, op, lhs, rhs, this);
 80631: }
 80631: 
 86266: static bool
 98181: SetLvalKid(JSContext *cx, Parser *parser, ParseNode *pn, ParseNode *kid,
 80631:            const char *name)
     1: {
 82024:     if (!kid->isKind(PNK_NAME) &&
 82024:         !kid->isKind(PNK_DOT) &&
 82024:         (!kid->isKind(PNK_LP) ||
 78294:          (!kid->isOp(JSOP_CALL) && !kid->isOp(JSOP_EVAL) &&
 78294:           !kid->isOp(JSOP_FUNCALL) && !kid->isOp(JSOP_FUNAPPLY))) &&
     1: #if JS_HAS_XML_SUPPORT
 82114:         !kid->isKind(PNK_XMLUNARY) &&
     1: #endif
 82024:         !kid->isKind(PNK_LB))
 82018:     {
102849:         parser->reportError(NULL, JSMSG_BAD_OPERAND, name);
 86266:         return false;
     1:     }
 98181:     if (!CheckStrictAssignment(cx, parser, kid))
 86266:         return false;
     1:     pn->pn_kid = kid;
 86266:     return true;
     1: }
     1: 
     1: static const char incop_name_str[][10] = {"increment", "decrement"};
     1: 
103824: static bool
 98181: SetIncOpKid(JSContext *cx, Parser *parser, ParseNode *pn, ParseNode *kid,
 86266:             TokenKind tt, bool preorder)
     1: {
     1:     JSOp op;
     1: 
 98181:     if (!SetLvalKid(cx, parser, pn, kid, incop_name_str[tt == TOK_DEC]))
 86266:         return false;
 78294:     switch (kid->getKind()) {
 82024:       case PNK_NAME:
     1:         op = (tt == TOK_INC)
     1:              ? (preorder ? JSOP_INCNAME : JSOP_NAMEINC)
     1:              : (preorder ? JSOP_DECNAME : JSOP_NAMEDEC);
104045:         NoteLValue(cx, kid, parser->tc->sc);
     1:         break;
     1: 
 82024:       case PNK_DOT:
     1:         op = (tt == TOK_INC)
     1:              ? (preorder ? JSOP_INCPROP : JSOP_PROPINC)
     1:              : (preorder ? JSOP_DECPROP : JSOP_PROPDEC);
     1:         break;
     1: 
 82024:       case PNK_LP:
 98181:         if (!MakeSetCall(cx, kid, parser, JSMSG_BAD_INCOP_OPERAND))
103823:             return false;
     1:         /* FALL THROUGH */
     1: #if JS_HAS_XML_SUPPORT
 82114:       case PNK_XMLUNARY:
 78294:         if (kid->isOp(JSOP_XMLNAME))
 78294:             kid->setOp(JSOP_SETXMLNAME);
     1:         /* FALL THROUGH */
     1: #endif
 82024:       case PNK_LB:
     1:         op = (tt == TOK_INC)
     1:              ? (preorder ? JSOP_INCELEM : JSOP_ELEMINC)
     1:              : (preorder ? JSOP_DECELEM : JSOP_ELEMDEC);
     1:         break;
     1: 
     1:       default:
     1:         JS_ASSERT(0);
     1:         op = JSOP_NOP;
     1:     }
 78294:     pn->setOp(op);
103823:     return true;
     1: }
     1: 
 80631: ParseNode *
 82024: Parser::unaryOpExpr(ParseNodeKind kind, JSOp op)
 82024: {
 82024:     TokenPtr begin = tokenStream.currentToken().pos.begin;
 82024:     ParseNode *kid = unaryExpr();
 82024:     if (!kid)
 82024:         return NULL;
 82024:     return new_<UnaryNode>(kind, op, TokenPos::make(begin, kid->pn_pos.end), kid);
 82024: }
 82024: 
 82024: ParseNode *
 40860: Parser::unaryExpr()
 40221: {
 80631:     ParseNode *pn, *pn2;
     1: 
 40239:     JS_CHECK_RECURSION(context, return NULL);
 40239: 
 82024:     switch (TokenKind tt = tokenStream.getToken(TSF_OPERAND)) {
 82018:       case TOK_TYPEOF:
 82024:         return unaryOpExpr(PNK_TYPEOF, JSOP_TYPEOF);
 82018:       case TOK_VOID:
 82024:         return unaryOpExpr(PNK_VOID, JSOP_VOID);
 82018:       case TOK_NOT:
 82024:         return unaryOpExpr(PNK_NOT, JSOP_NOT);
 82018:       case TOK_BITNOT:
 82024:         return unaryOpExpr(PNK_BITNOT, JSOP_BITNOT);
     1:       case TOK_PLUS:
 82870:         return unaryOpExpr(PNK_POS, JSOP_POS);
     1:       case TOK_MINUS:
 82870:         return unaryOpExpr(PNK_NEG, JSOP_NEG);
     1: 
     1:       case TOK_INC:
     1:       case TOK_DEC:
 98181:         pn = UnaryNode::create((tt == TOK_INC) ? PNK_PREINCREMENT : PNK_PREDECREMENT, this);
     1:         if (!pn)
     1:             return NULL;
103823:         pn2 = memberExpr(true);
     1:         if (!pn2)
     1:             return NULL;
 98181:         if (!SetIncOpKid(context, this, pn, pn2, tt, true))
     1:             return NULL;
     1:         pn->pn_pos.end = pn2->pn_pos.end;
     1:         break;
     1: 
     1:       case TOK_DELETE:
 41983:       {
 98181:         pn = UnaryNode::create(PNK_DELETE, this);
     1:         if (!pn)
     1:             return NULL;
 40263:         pn2 = unaryExpr();
     1:         if (!pn2)
     1:             return NULL;
     1:         pn->pn_pos.end = pn2->pn_pos.end;
     1: 
     1:         /*
     1:          * Under ECMA3, deleting any unary expression is valid -- it simply
 31479:          * returns true. Here we fold constants before checking for a call
 31479:          * expression, in order to rule out delete of a generator expression.
 31479:          */
 98181:         if (foldConstants && !FoldConstants(context, pn2, this))
  1962:             return NULL;
 78294:         switch (pn2->getKind()) {
 82024:           case PNK_LP:
 57742:             if (!(pn2->pn_xflags & PNX_SETCALL)) {
 57742:                 /*
 57742:                  * Call MakeSetCall to check for errors, but clear PNX_SETCALL
 57742:                  * because the optimizer will eliminate the useless delete.
 57742:                  */
 98181:                 if (!MakeSetCall(context, pn2, this, JSMSG_BAD_DELETE_OPERAND))
 57742:                     return NULL;
 57742:                 pn2->pn_xflags &= ~PNX_SETCALL;
  1577:             }
 27012:             break;
 82024:           case PNK_NAME:
102849:             if (!reportStrictModeError(pn, JSMSG_DEPRECATED_DELETE_OPERAND))
102849:                 return NULL;
 78294:             pn2->setOp(JSOP_DELNAME);
 27012:             break;
 27012:           default:;
 27012:         }
     1:         pn->pn_kid = pn2;
     1:         break;
 41983:       }
     1:       case TOK_ERROR:
     1:         return NULL;
     1: 
     1:       default:
 40354:         tokenStream.ungetToken();
103823:         pn = memberExpr(true);
     1:         if (!pn)
     1:             return NULL;
     1: 
     1:         /* Don't look across a newline boundary for a postfix incop. */
 40270:         if (tokenStream.onCurrentLine(pn->pn_pos)) {
 40854:             tt = tokenStream.peekTokenSameLine(TSF_OPERAND);
     1:             if (tt == TOK_INC || tt == TOK_DEC) {
 86266:                 tokenStream.consumeKnownToken(tt);
 98181:                 pn2 = UnaryNode::create((tt == TOK_INC) ? PNK_POSTINCREMENT : PNK_POSTDECREMENT, this);
     1:                 if (!pn2)
     1:                     return NULL;
 98181:                 if (!SetIncOpKid(context, this, pn2, pn, tt, false))
     1:                     return NULL;
     1:                 pn2->pn_pos.begin = pn->pn_pos.begin;
     1:                 pn = pn2;
     1:             }
     1:         }
     1:         break;
     1:     }
     1:     return pn;
     1: }
     1: 
  1577: #if JS_HAS_GENERATORS
  1577: 
  1577: /*
 27012:  * A dedicated helper for transplanting the comprehension expression E in
 27012:  *
 27012:  *   [E for (V in I)]   // array comprehension
 27012:  *   (E for (V in I))   // generator expression
 27012:  *
 27012:  * from its initial location in the AST, on the left of the 'for', to its final
 27012:  * position on the right. To avoid a separate pass we do this by adjusting the
 27012:  * blockids and name binding links that were established when E was parsed.
 27012:  *
 27012:  * A generator expression desugars like so:
 27012:  *
 27012:  *   (E for (V in I)) => (function () { for (var V in I) yield E; })()
 27012:  *
 27012:  * so the transplanter must adjust static level as well as blockid. E's source
 27012:  * coordinates in root->pn_pos are critical to deciding which binding links to
 27012:  * preserve and which to cut.
 27012:  *
 27012:  * NB: This is not a general tree transplanter -- it knows in particular that
 27012:  * the one or more bindings induced by V have not yet been created.
 27012:  */
 27012: class CompExprTransplanter {
 80631:     ParseNode       *root;
 98181:     Parser          *parser;
 27012:     bool            genexp;
 91237:     unsigned        adjust;
 91237:     unsigned        funcLevel;
104373:     HashSet<Definition *> visitedImplicitArguments;
 27012: 
 27012:   public:
 98181:     CompExprTransplanter(ParseNode *pn, Parser *parser, bool ge, unsigned adj)
104373:       : root(pn), parser(parser), genexp(ge), adjust(adj), funcLevel(0),
104373:         visitedImplicitArguments(parser->context)
104373:     {}
104373: 
104373:     bool init() {
104373:         return visitedImplicitArguments.init();
 27012:     }
 27012: 
 80631:     bool transplant(ParseNode *pn);
 27012: };
 27012: 
 27012: /*
 72073:  * A helper for lazily checking for the presence of illegal |yield| or |arguments|
 73053:  * tokens inside of generator expressions. This must be done lazily since we don't
 73053:  * know whether we're in a generator expression until we see the "for" token after
 73053:  * we've already parsed the body expression.
 73053:  *
 73053:  * Use in any context which may turn out to be inside a generator expression. This
 73053:  * includes parenthesized expressions and argument lists, and it includes the tail
 73053:  * of generator expressions.
 73053:  *
 73053:  * The guard will keep track of any |yield| or |arguments| tokens that occur while
 73053:  * parsing the body. As soon as the parser reaches the end of the body expression,
 73053:  * call endBody() to reset the context's state, and then immediately call:
 73053:  *
 73057:  * - checkValidBody() if this *did* turn out to be a generator expression
 73057:  * - maybeNoteGenerator() if this *did not* turn out to be a generator expression
 72073:  */
 72073: class GenexpGuard {
 98181:     Parser          *parser;
 84755:     uint32_t        startYieldCount;
 72073: 
 72073:   public:
 98181:     explicit GenexpGuard(Parser *parser)
 98181:       : parser(parser)
 98181:     {
104045:         TreeContext *tc = parser->tc;
104045:         if (tc->parenDepth == 0) {
104045:             tc->yieldCount = 0;
104045:             tc->yieldNode = NULL;
104045:         }
104045:         startYieldCount = tc->yieldCount;
104045:         tc->parenDepth++;
 72073:     }
 72073: 
 72073:     void endBody();
 99552:     bool checkValidBody(ParseNode *pn, unsigned err);
 80631:     bool maybeNoteGenerator(ParseNode *pn);
 72073: };
 72073: 
 72073: void
 72073: GenexpGuard::endBody()
 72073: {
104045:     parser->tc->parenDepth--;
 72073: }
 72073: 
 73053: /*
 73053:  * Check whether a |yield| or |arguments| token has been encountered in the
 73053:  * body expression, and if so, report an error.
 73053:  *
 73053:  * Call this after endBody() when determining that the body *was* in a
 73053:  * generator expression.
 73053:  */
 72073: bool
 99552: GenexpGuard::checkValidBody(ParseNode *pn, unsigned err = JSMSG_BAD_GENEXP_BODY)
 72073: {
104045:     TreeContext *tc = parser->tc;
104045:     if (tc->yieldCount > startYieldCount) {
104045:         ParseNode *errorNode = tc->yieldNode;
 72073:         if (!errorNode)
 72073:             errorNode = pn;
102849:         parser->reportError(errorNode, err, js_yield_str);
 72073:         return false;
 72073:     }
 72073: 
 72073:     return true;
 72073: }
 72073: 
 72073: /*
 73053:  * Check whether a |yield| token has been encountered in the body expression,
 73053:  * and if so, note that the current function is a generator function.
 73053:  *
 73053:  * Call this after endBody() when determining that the body *was not* in a
 73053:  * generator expression.
 73053:  */
 73053: bool
 80631: GenexpGuard::maybeNoteGenerator(ParseNode *pn)
 73053: {
104045:     TreeContext *tc = parser->tc;
104045:     if (tc->yieldCount > 0) {
104045:         tc->sc->setFunIsGenerator();
104045:         if (!tc->sc->inFunction()) {
102849:             parser->reportError(NULL, JSMSG_BAD_RETURN_OR_YIELD, js_yield_str);
 73053:             return false;
 73053:         }
104045:         if (tc->hasReturnExpr) {
 98687:             /* At the time we saw the yield, we might not have set funIsGenerator yet. */
104045:             ReportBadReturn(tc->sc->context, parser, pn, &Parser::reportError,
102849:                             JSMSG_BAD_GENERATOR_RETURN, JSMSG_BAD_ANON_GENERATOR_RETURN);
 78006:             return false;
 78006:         }
 73053:     }
 73053:     return true;
 73053: }
 73053: 
 73053: /*
 27012:  * Any definitions nested within the comprehension expression of a generator
 27012:  * expression must move "down" one static level, which of course increases the
 27012:  * upvar-frame-skip count.
 27012:  */
 28814: static bool
104045: BumpStaticLevel(ParseNode *pn, TreeContext *tc)
 27012: {
101616:     if (pn->pn_cookie.isFree())
101616:         return true;
101616: 
101616:     unsigned level = unsigned(pn->pn_cookie.level()) + 1;
104045:     JS_ASSERT(level >= tc->staticLevel);
104045:     return pn->pn_cookie.set(tc->sc->context, level, pn->pn_cookie.slot());
 27012: }
 27012: 
104408: static bool
104045: AdjustBlockId(ParseNode *pn, unsigned adjust, TreeContext *tc)
 28122: {
 78294:     JS_ASSERT(pn->isArity(PN_LIST) || pn->isArity(PN_FUNC) || pn->isArity(PN_NAME));
104408:     if (JS_BIT(20) - pn->pn_blockid <= adjust + 1) {
104408:         JS_ReportErrorNumber(tc->sc->context, js_GetErrorMessage, NULL, JSMSG_NEED_DIET, "program");
104408:         return false;
104408:     }
 28122:     pn->pn_blockid += adjust;
104045:     if (pn->pn_blockid >= tc->blockidGen)
104045:         tc->blockidGen = pn->pn_blockid + 1;
104408:     return true;
 28122: }
 28122: 
 27012: bool
 80631: CompExprTransplanter::transplant(ParseNode *pn)
 27012: {
104045:     TreeContext *tc = parser->tc;
 98181: 
 27012:     if (!pn)
 27012:         return true;
 27012: 
 78294:     switch (pn->getArity()) {
 27012:       case PN_LIST:
 80631:         for (ParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
 61059:             if (!transplant(pn2))
 61059:                 return false;
 61059:         }
104408:         if (pn->pn_pos >= root->pn_pos) {
104408:             if (!AdjustBlockId(pn, adjust, tc))
104408:                 return false;
104408:         }
 27012:         break;
 27012: 
 27012:       case PN_TERNARY:
 61059:         if (!transplant(pn->pn_kid1) ||
 61059:             !transplant(pn->pn_kid2) ||
 61059:             !transplant(pn->pn_kid3))
 61059:             return false;
 27012:         break;
 27012: 
 27012:       case PN_BINARY:
 61059:         if (!transplant(pn->pn_left))
 61059:             return false;
 28354: 
 28354:         /* Binary TOK_COLON nodes can have left == right. See bug 492714. */
 61059:         if (pn->pn_right != pn->pn_left) {
 61059:             if (!transplant(pn->pn_right))
 61059:                 return false;
 61059:         }
 27012:         break;
 27012: 
 27012:       case PN_UNARY:
 61059:         if (!transplant(pn->pn_kid))
 61059:             return false;
 27012:         break;
 27012: 
 27012:       case PN_FUNC:
 27012:       {
 27012:         /*
 27012:          * Only the first level of transplant recursion through functions needs
 27012:          * to reparent the funbox, since all descendant functions are correctly
 27012:          * linked under the top-most funbox. But every visit to this case needs
 27012:          * to update funbox->level.
 27012:          *
 27012:          * Recall that funbox->level is the static level of the code containing
 27012:          * the definition or expression of the function and not the static level
 27012:          * of the function's body.
 27012:          */
 80631:         FunctionBox *funbox = pn->pn_funbox;
 27012: 
104045:         funbox->level = tc->staticLevel + funcLevel;
 27012:         if (++funcLevel == 1 && genexp) {
104045:             FunctionBox *parent = tc->sc->funbox();
104045: 
104045:             FunctionBox **funboxp = &tc->parent->functionList;
 27012:             while (*funboxp != funbox)
 27012:                 funboxp = &(*funboxp)->siblings;
 27012:             *funboxp = funbox->siblings;
 27012: 
 27012:             funbox->parent = parent;
 27012:             funbox->siblings = parent->kids;
 27012:             parent->kids = funbox;
104045:             funbox->level = tc->staticLevel;
 27012:         }
 27012:         /* FALL THROUGH */
 27012:       }
 27012: 
 27012:       case PN_NAME:
 61059:         if (!transplant(pn->maybeExpr()))
 61059:             return false;
 78294:         if (pn->isArity(PN_FUNC))
 27012:             --funcLevel;
 27012: 
 78294:         if (pn->isDefn()) {
104045:             if (genexp && !BumpStaticLevel(pn, tc))
 28814:                 return false;
 78294:         } else if (pn->isUsed()) {
 78294:             JS_ASSERT(!pn->isOp(JSOP_NOP));
 47573:             JS_ASSERT(pn->pn_cookie.isFree());
 27012: 
 80631:             Definition *dn = pn->pn_lexdef;
 78294:             JS_ASSERT(dn->isDefn());
 27012: 
 27012:             /*
 27012:              * Adjust the definition's block id only if it is a placeholder not
 27012:              * to the left of the root node, and if pn is the last use visited
 27012:              * in the comprehension expression (to avoid adjusting the blockid
 27012:              * multiple times).
 27012:              *
 27012:              * Non-placeholder definitions within the comprehension expression
 27012:              * will be visited further below.
 27012:              */
 27012:             if (dn->isPlaceholder() && dn->pn_pos >= root->pn_pos && dn->dn_uses == pn) {
104045:                 if (genexp && !BumpStaticLevel(dn, tc))
 28814:                     return false;
104408:                 if (!AdjustBlockId(dn, adjust, tc))
104408:                     return false;
 27012:             }
 27012: 
104205:             RootedAtom atom(parser->context, pn->pn_atom);
 27012: #ifdef DEBUG
104045:             StmtInfoTC *stmt = LexicalLookup(tc, atom, NULL, (StmtInfoTC *)NULL);
104045:             JS_ASSERT(!stmt || stmt != tc->topStmt);
 27012: #endif
 78294:             if (genexp && !dn->isOp(JSOP_CALLEE)) {
104045:                 JS_ASSERT(!tc->decls.lookupFirst(atom));
 27012: 
 73066:                 if (dn->pn_pos < root->pn_pos) {
 73066:                     /*
 73066:                      * The variable originally appeared to be a use of a
 73066:                      * definition or placeholder outside the generator, but now
 73066:                      * we know it is scoped within the comprehension tail's
 73066:                      * clauses. Make it (along with any other uses within the
 73066:                      * generator) a use of a new placeholder in the generator's
 73066:                      * lexdeps.
 73066:                      */
104045:                     Definition *dn2 = MakePlaceholder(pn, parser, parser->tc);
 27371:                     if (!dn2)
 28814:                         return false;
 61060:                     dn2->pn_pos = root->pn_pos;
 27371: 
 73066:                     /*
 73066:                      * Change all uses of |dn| that lie within the generator's
 73066:                      * |yield| expression into uses of dn2.
 73066:                      */
 80631:                     ParseNode **pnup = &dn->dn_uses;
 80631:                     ParseNode *pnu;
 27371:                     while ((pnu = *pnup) != NULL && pnu->pn_pos >= root->pn_pos) {
 27371:                         pnu->pn_lexdef = dn2;
 30457:                         dn2->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
 27371:                         pnup = &pnu->pn_link;
 27371:                     }
 27371:                     dn2->dn_uses = dn->dn_uses;
 27371:                     dn->dn_uses = *pnup;
 27371:                     *pnup = NULL;
104045:                     if (!tc->lexdeps->put(atom, dn2))
 73941:                         return false;
 73066:                 } else if (dn->isPlaceholder()) {
 73066:                     /*
 73066:                      * The variable first occurs free in the 'yield' expression;
 73066:                      * move the existing placeholder node (and all its uses)
 73066:                      * from the parent's lexdeps into the generator's lexdeps.
 73066:                      */
104045:                     tc->parent->lexdeps->remove(atom);
104045:                     if (!tc->lexdeps->put(atom, dn))
 72579:                         return false;
104373:                 } else if (dn->isImplicitArguments()) {
104373:                     /*
104373:                      * Implicit 'arguments' Definition nodes (see
104373:                      * PND_IMPLICITARGUMENTS in Parser::functionBody) are only
104373:                      * reachable via the lexdefs of their uses. Unfortunately,
104373:                      * there may be multiple uses, so we need to maintain a set
104373:                      * to only bump the definition once.
104373:                      */
104373:                     if (genexp && !visitedImplicitArguments.has(dn)) {
104373:                         if (!BumpStaticLevel(dn, tc))
104373:                             return false;
104408:                         if (!AdjustBlockId(dn, adjust, tc))
104408:                             return false;
104373:                         if (!visitedImplicitArguments.put(dn))
104373:                             return false;
104373:                     }
 27012:                 }
 27012:             }
 27012:         }
 27012: 
104408:         if (pn->pn_pos >= root->pn_pos) {
104408:             if (!AdjustBlockId(pn, adjust, tc))
104408:                 return false;
104408:         }
 27012:         break;
 27012: 
 27012:       case PN_NAMESET:
 61059:         if (!transplant(pn->pn_tree))
 61059:             return false;
 27012:         break;
 78296: 
 78296:       case PN_NULLARY:
 78296:         /* Nothing. */
 78296:         break;
 27012:     }
 27012:     return true;
 27012: }
 27012: 
 27012: /*
  1577:  * Starting from a |for| keyword after the first array initialiser element or
  1577:  * an expression in an open parenthesis, parse the tail of the comprehension
  1577:  * or generator expression signified by this |for| keyword in context.
  1577:  *
  1577:  * Return null on failure, else return the top-most parse node for the array
  1577:  * comprehension or generator expression, with a unary node as the body of the
 82024:  * (possibly nested) for-loop, initialized by |kind, op, kid|.
  1577:  */
 80631: ParseNode *
 91237: Parser::comprehensionTail(ParseNode *kid, unsigned blockid, bool isGenexp,
 82024:                           ParseNodeKind kind, JSOp op)
 40239: {
 91237:     unsigned adjust;
 80631:     ParseNode *pn, *pn2, *pn3, **pnp;
104045:     StmtInfoTC stmtInfo(context);
 97353:     BindData data(context);
 40320:     TokenKind tt;
  1577: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_FOR);
  1577: 
 82024:     if (kind == PNK_SEMI) {
 27012:         /*
 27012:          * Generator expression desugars to an immediately applied lambda that
 27012:          * yields the next value from a for-in loop (possibly nested, and with
 27012:          * optional if guard). Make pn be the TOK_LC body node.
  1577:          */
 98181:         pn = PushLexicalScope(context, this, &stmtInfo);
  1577:         if (!pn)
  1577:             return NULL;
 27012:         adjust = pn->pn_blockid - blockid;
 27012:     } else {
 82024:         JS_ASSERT(kind == PNK_ARRAYPUSH);
 27012: 
 27012:         /*
 27012:          * Make a parse-node and literal object representing the block scope of
 40239:          * this array comprehension. Our caller in primaryExpr, the TOK_LB case
 27012:          * aka the array initialiser case, has passed the blockid to claim for
 27012:          * the comprehension's block scope. We allocate that id or one above it
 80632:          * here, by calling PushLexicalScope.
 27012:          *
 27012:          * In the case of a comprehension expression that has nested blocks
 27012:          * (e.g., let expressions), we will allocate a higher blockid but then
 27012:          * slide all blocks "to the right" to make room for the comprehension's
 27012:          * block scope.
 27012:          */
104045:         adjust = tc->blockid();
 98181:         pn = PushLexicalScope(context, this, &stmtInfo);
 27012:         if (!pn)
 27012:             return NULL;
 27012: 
 27012:         JS_ASSERT(blockid <= pn->pn_blockid);
104045:         JS_ASSERT(blockid < tc->blockidGen);
104045:         JS_ASSERT(tc->bodyid < blockid);
 27012:         pn->pn_blockid = stmtInfo.blockid = blockid;
 27012:         JS_ASSERT(adjust < blockid);
 27012:         adjust = blockid - adjust;
 27012:     }
 27012: 
  1577:     pnp = &pn->pn_expr;
  1577: 
 98181:     CompExprTransplanter transplanter(kid, this, kind == PNK_SEMI, adjust);
104373:     if (!transplanter.init())
104373:         return NULL;
104373: 
104408:     if (!transplanter.transplant(kid))
104408:         return false;
 27012: 
104045:     JS_ASSERT(tc->blockChain && tc->blockChain == pn->pn_objbox->object);
104045:     data.initLet(HoistVars, *tc->blockChain, JSMSG_ARRAY_INIT_TOO_BIG);
 27012: 
  1577:     do {
  1577:         /*
  1577:          * FOR node is binary, left is loop control and right is body.  Use
  1577:          * index to count each block-local let-variable on the left-hand side
 89621:          * of the in/of.
  1577:          */
 98181:         pn2 = BinaryNode::create(PNK_FOR, this);
  1577:         if (!pn2)
  1577:             return NULL;
  1577: 
 78294:         pn2->setOp(JSOP_ITER);
 15613:         pn2->pn_iflags = JSITER_ENUMERATE;
 40354:         if (tokenStream.matchToken(TOK_NAME)) {
 80443:             if (tokenStream.currentToken().name() == context->runtime->atomState.eachAtom)
 15613:                 pn2->pn_iflags |= JSITER_FOREACH;
  1577:             else
 40354:                 tokenStream.ungetToken();
  1577:         }
  1577:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
  1577: 
 98181:         GenexpGuard guard(this);
 72073: 
 99421:         RootedPropertyName name(context);
 40354:         tt = tokenStream.getToken();
  1577:         switch (tt) {
  1577: #if JS_HAS_DESTRUCTURING
  1577:           case TOK_LB:
  1577:           case TOK_LC:
104045:             tc->inDeclDestructuring = true;
103823:             pn3 = primaryExpr(tt, false);
104045:             tc->inDeclDestructuring = false;
  1577:             if (!pn3)
  1577:                 return NULL;
  1577:             break;
  1577: #endif
  1577: 
  1577:           case TOK_NAME:
 80443:             name = tokenStream.currentToken().name();
  1577: 
  1577:             /*
  1577:              * Create a name node with pn_op JSOP_NAME.  We can't set pn_op to
  1577:              * JSOP_GETLOCAL here, because we don't yet know the block's depth
  1577:              * in the operand stack frame.  The code generator computes that,
  1577:              * and it tries to bind all names to slots, so we must let it do
  1577:              * the deed.
  1577:              */
 98181:             pn3 = NewBindingNode(name, this);
  1577:             if (!pn3)
  1577:                 return NULL;
  1577:             break;
  1577: 
  1577:           default:
102849:             reportError(NULL, JSMSG_NO_VARIABLE_NAME);
  1607: 
  1607:           case TOK_ERROR:
  1577:             return NULL;
  1577:         }
  1577: 
 89621:         bool forOf;
 89621:         if (!matchInOrOf(&forOf)) {
102849:             reportError(NULL, JSMSG_IN_AFTER_FOR_NAME);
 89621:             return NULL;
 89621:         }
 89621:         if (forOf) {
 89621:             if (pn2->pn_iflags != JSITER_ENUMERATE) {
 89621:                 JS_ASSERT(pn2->pn_iflags == (JSITER_FOREACH | JSITER_ENUMERATE));
102849:                 reportError(NULL, JSMSG_BAD_FOR_EACH_LOOP);
 89621:                 return NULL;
 89621:             }
 89621:             pn2->pn_iflags = JSITER_FOR_OF;
 89621:         }
 89621: 
 80631:         ParseNode *pn4 = expr();
 27012:         if (!pn4)
 27012:             return NULL;
  1577:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
 27012: 
 72073:         guard.endBody();
 72073: 
 73053:         if (isGenexp) {
 73053:             if (!guard.checkValidBody(pn2))
 73053:                 return NULL;
 74093:         } else {
 78006:             if (!guard.maybeNoteGenerator(pn2))
 73053:                 return NULL;
 73053:         }
 72073: 
 27012:         switch (tt) {
 27012: #if JS_HAS_DESTRUCTURING
 27012:           case TOK_LB:
 27012:           case TOK_LC:
 98181:             if (!CheckDestructuring(context, &data, pn3, this))
 40239:                 return NULL;
 40239: 
 61450:             if (versionNumber() == JSVERSION_1_7) {
 27012:                 /* Destructuring requires [key, value] enumeration in JS1.7. */
 82024:                 if (!pn3->isKind(PNK_RB) || pn3->pn_count != 2) {
102849:                     reportError(NULL, JSMSG_BAD_FOR_LEFTSIDE);
 27012:                     return NULL;
 27012:                 }
 27012: 
 78294:                 JS_ASSERT(pn2->isOp(JSOP_ITER));
 27012:                 JS_ASSERT(pn2->pn_iflags & JSITER_ENUMERATE);
 27012:                 if (!(pn2->pn_iflags & JSITER_FOREACH))
 27012:                     pn2->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
 27012:             }
 27012:             break;
 27012: #endif
 27012: 
 27012:           case TOK_NAME:
 27012:             data.pn = pn3;
 98181:             if (!data.binder(context, &data, name, this))
 27012:                 return NULL;
 27012:             break;
 27012: 
 27012:           default:;
 27012:         }
 27012: 
 74052:         /*
 74052:          * Synthesize a declaration. Every definition must appear in the parse
 74052:          * tree in order for ComprehensionTranslator to work.
 74052:          */
 98181:         ParseNode *vars = ListNode::create(PNK_VAR, this);
 74052:         if (!vars)
 74052:             return NULL;
 78294:         vars->setOp(JSOP_NOP);
 74052:         vars->pn_pos = pn3->pn_pos;
 74052:         vars->makeEmpty();
 74052:         vars->append(pn3);
 74052:         vars->pn_xflags |= PNX_FORINVAR;
 74052: 
 74052:         /* Definitions can't be passed directly to EmitAssignment as lhs. */
 98181:         pn3 = CloneLeftHandSide(pn3, this);
 74052:         if (!pn3)
 74052:             return NULL;
 74052: 
 82871:         pn2->pn_left = new_<TernaryNode>(PNK_FORIN, JSOP_NOP, vars, pn3, pn4);
 27012:         if (!pn2->pn_left)
 27012:             return NULL;
  1577:         *pnp = pn2;
  1577:         pnp = &pn2->pn_right;
 40354:     } while (tokenStream.matchToken(TOK_FOR));
 40354: 
 40354:     if (tokenStream.matchToken(TOK_IF)) {
 98181:         pn2 = TernaryNode::create(PNK_IF, this);
  1577:         if (!pn2)
  1577:             return NULL;
 40263:         pn2->pn_kid1 = condition();
  1577:         if (!pn2->pn_kid1)
  1577:             return NULL;
  1577:         *pnp = pn2;
  1577:         pnp = &pn2->pn_kid2;
  1577:     }
  1577: 
 98181:     pn2 = UnaryNode::create(kind, this);
  1577:     if (!pn2)
  1577:         return NULL;
 78294:     pn2->setOp(op);
  1577:     pn2->pn_kid = kid;
  1577:     *pnp = pn2;
  1577: 
104045:     PopStatementTC(tc);
  1577:     return pn;
  1577: }
  1577: 
  1577: #if JS_HAS_GENERATOR_EXPRS
  1577: 
  1577: /*
  1577:  * Starting from a |for| keyword after an expression, parse the comprehension
  1577:  * tail completing this generator expression. Wrap the expression at kid in a
  1577:  * generator function that is immediately called to evaluate to the generator
  1577:  * iterator that is the value of this generator expression.
  1577:  *
 61058:  * |kid| must be the expression before the |for| keyword; we return an
 61058:  * application of a generator function that includes the |for| loops and
 61058:  * |if| guards, with |kid| as the operand of a |yield| expression as the
 61058:  * innermost loop body.
  1577:  *
  1577:  * Note how unlike Python, we do not evaluate the expression to the right of
  1577:  * the first |in| in the chain of |for| heads. Instead, a generator expression
  1577:  * is merely sugar for a generator function expression and its application.
  1577:  */
 80631: ParseNode *
 80631: Parser::generatorExpr(ParseNode *kid)
 61058: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_FOR));
 82024: 
 61058:     /* Create a |yield| node for |kid|. */
 98181:     ParseNode *pn = UnaryNode::create(PNK_YIELD, this);
 61058:     if (!pn)
 61058:         return NULL;
 78294:     pn->setOp(JSOP_YIELD);
 78294:     pn->setInParens(true);
  1577:     pn->pn_pos = kid->pn_pos;
  1577:     pn->pn_kid = kid;
 31479:     pn->pn_hidden = true;
  1577: 
 27012:     /* Make a new node for the desugared generator function. */
 98181:     ParseNode *genfn = FunctionNode::create(PNK_FUNCTION, this);
 27012:     if (!genfn)
 27012:         return NULL;
 78294:     genfn->setOp(JSOP_LAMBDA);
 27012:     JS_ASSERT(!genfn->pn_body);
 94151:     genfn->pn_dflags = 0;
 27012: 
 27012:     {
104045:         TreeContext *outertc = tc;
104045: 
104045:         RootedFunction fun(context, newFunction(outertc, /* atom = */ NULL, Expression));
100230:         if (!fun)
100230:             return NULL;
100230: 
100230:         /* Create box for fun->object early to protect against last-ditch GC. */
104093:         FunctionBox *funbox = newFunctionBox(fun, genfn, outertc, outertc->sc->strictModeState);
100230:         if (!funbox)
100230:             return NULL;
100230: 
104093:         SharedContext gensc(context, /* scopeChain = */ NULL, fun, funbox, outertc->sc->strictModeState);
104045:         TreeContext gentc(this, &gensc, outertc->staticLevel + 1, outertc->blockidGen);
104045:         if (!gentc.init())
104045:             return NULL;
104045: 
104045:         /*
104045:          * We assume conservatively that any deoptimization flags in tc->sc
 95100:          * come from the kid. So we propagate these flags into genfn. For code
 95100:          * simplicity we also do not detect if the flags were only set in the
104045:          * kid and could be removed from tc->sc.
104045:          */
104045:         gensc.cxFlags = outertc->sc->cxFlags;
 98687:         gensc.setFunIsGenerator();
 98687: 
 98481:         funbox->inGenexpLambda = true;
 27012:         genfn->pn_funbox = funbox;
104045:         genfn->pn_blockid = gentc.bodyid;
104045: 
104045:         ParseNode *body = comprehensionTail(pn, outertc->blockid(), true);
  1577:         if (!body)
  1577:             return NULL;
 27012:         JS_ASSERT(!genfn->pn_body);
 27012:         genfn->pn_body = body;
 27012:         genfn->pn_pos.begin = body->pn_pos.begin = kid->pn_pos.begin;
 40270:         genfn->pn_pos.end = body->pn_pos.end = tokenStream.currentToken().pos.end;
 40221: 
 98445:         JSAtom *arguments = gensc.context->runtime->atomState.argumentsAtom;
104045:         if (AtomDefnPtr p = gentc.lexdeps->lookup(arguments)) {
 95100:             Definition *dn = p.value();
 95100:             ParseNode *errorNode = dn->dn_uses ? dn->dn_uses : body;
102849:             reportError(errorNode, JSMSG_BAD_GENEXP_BODY, js_arguments_str);
 98181:             return NULL;
 98181:         }
 98181: 
 98181:         if (!LeaveFunction(genfn, this))
 27012:             return NULL;
 27012:     }
 27012: 
 27012:     /*
 27012:      * Our result is a call expression that invokes the anonymous generator
 27012:      * function object.
 27012:      */
 98181:     ParseNode *result = ListNode::create(PNK_LP, this);
 27012:     if (!result)
 27012:         return NULL;
 78294:     result->setOp(JSOP_CALL);
 27012:     result->pn_pos.begin = genfn->pn_pos.begin;
 27012:     result->initList(genfn);
 27012:     return result;
  1577: }
  1577: 
  1577: static const char js_generator_str[] = "generator";
  1577: 
  1577: #endif /* JS_HAS_GENERATOR_EXPRS */
  1577: #endif /* JS_HAS_GENERATORS */
  1577: 
 99552: ParseNode *
 99552: Parser::assignExprWithoutYield(unsigned msg)
 99552: {
 99552: #ifdef JS_HAS_GENERATORS
 99552:     GenexpGuard yieldGuard(this);
 99552: #endif
 99552:     ParseNode *res = assignExpr();
 99918:     yieldGuard.endBody();
 99552:     if (res) {
 99552: #ifdef JS_HAS_GENERATORS
 99552:         if (!yieldGuard.checkValidBody(res, msg)) {
 99552:             freeTree(res);
 99552:             res = NULL;
 99552:         }
 99552: #endif
 99552:     }
 99552:     return res;
 99552: }
 99552: 
103824: bool
 80631: Parser::argumentList(ParseNode *listNode)
     1: {
 40854:     if (tokenStream.matchToken(TOK_RP, TSF_OPERAND))
103823:         return true;
 40854: 
 98181:     GenexpGuard guard(this);
 72565:     bool arg0 = true;
 72073: 
     1:     do {
 80631:         ParseNode *argNode = assignExpr();
     1:         if (!argNode)
103823:             return false;
 73053:         if (arg0)
 72565:             guard.endBody();
 72565: 
     1: #if JS_HAS_GENERATORS
 82024:         if (argNode->isKind(PNK_YIELD) &&
 78294:             !argNode->isInParens() &&
 40354:             tokenStream.peekToken() == TOK_COMMA) {
102849:             reportError(argNode, JSMSG_BAD_GENERATOR_SYNTAX, js_yield_str);
103823:             return false;
     1:         }
     1: #endif
  1577: #if JS_HAS_GENERATOR_EXPRS
 40354:         if (tokenStream.matchToken(TOK_FOR)) {
 72073:             if (!guard.checkValidBody(argNode))
103823:                 return false;
 61058:             argNode = generatorExpr(argNode);
  1577:             if (!argNode)
103823:                 return false;
  1577:             if (listNode->pn_count > 1 ||
 40354:                 tokenStream.peekToken() == TOK_COMMA) {
102849:                 reportError(argNode, JSMSG_BAD_GENERATOR_SYNTAX, js_generator_str);
103823:                 return false;
  1577:             }
 73053:         } else
  1577: #endif
 78006:         if (arg0 && !guard.maybeNoteGenerator(argNode))
103823:             return false;
 73053: 
 73053:         arg0 = false;
 73053: 
 27012:         listNode->append(argNode);
 40354:     } while (tokenStream.matchToken(TOK_COMMA));
 40354: 
 40354:     if (tokenStream.getToken() != TOK_RP) {
102849:         reportError(NULL, JSMSG_PAREN_AFTER_ARGS);
103823:         return false;
103823:     }
103823:     return true;
     1: }
     1: 
 80631: ParseNode *
103824: Parser::memberExpr(bool allowCallSyntax)
     1: {
 86539:     ParseNode *lhs;
 40221: 
 40239:     JS_CHECK_RECURSION(context, return NULL);
     1: 
     1:     /* Check for new expression first. */
 40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
     1:     if (tt == TOK_NEW) {
 98181:         lhs = ListNode::create(PNK_NEW, this);
 86539:         if (!lhs)
 86539:             return NULL;
103823:         ParseNode *ctorExpr = memberExpr(false);
 86539:         if (!ctorExpr)
 86539:             return NULL;
 86539:         lhs->setOp(JSOP_NEW);
 86539:         lhs->initList(ctorExpr);
 86539:         lhs->pn_pos.begin = ctorExpr->pn_pos.begin;
 86539: 
 86539:         if (tokenStream.matchToken(TOK_LP) && !argumentList(lhs))
 86539:             return NULL;
 86539:         if (lhs->pn_count > ARGC_LIMIT) {
 40239:             JS_ReportErrorNumber(context, js_GetErrorMessage, NULL,
     1:                                  JSMSG_TOO_MANY_CON_ARGS);
     1:             return NULL;
     1:         }
 86539:         lhs->pn_pos.end = lhs->last()->pn_pos.end;
     1:     } else {
103823:         lhs = primaryExpr(tt, false);
 86539:         if (!lhs)
 86539:             return NULL;
 86539: 
 86539:         if (lhs->isXMLNameOp()) {
 86539:             lhs = new_<UnaryNode>(PNK_XMLUNARY, JSOP_XMLNAME, lhs->pn_pos, lhs);
 86539:             if (!lhs)
 80640:                 return NULL;
     1:         }
     1:     }
     1: 
 40354:     while ((tt = tokenStream.getToken()) > TOK_EOF) {
 86540:         ParseNode *nextMember;
     1:         if (tt == TOK_DOT) {
 86538:             tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
 86538:             if (tt == TOK_ERROR)
 86538:                 return NULL;
 86538:             if (tt == TOK_NAME) {
     1: #if JS_HAS_XML_SUPPORT
 99820:                 if (allowsXML() && tokenStream.peekToken() == TOK_DBLCOLON) {
 86540:                     ParseNode *propertyId = propertyQualifiedIdentifier();
 86540:                     if (!propertyId)
 86540:                         return NULL;
 86540: 
 86540:                     nextMember = new_<XMLDoubleColonProperty>(lhs, propertyId,
 86540:                                                               lhs->pn_pos.begin,
 86540:                                                               tokenStream.currentToken().pos.end);
 86540:                     if (!nextMember)
 86540:                         return NULL;
 86538:                 } else
 86538: #endif
 86538:                 {
 88610:                     PropertyName *field = tokenStream.currentToken().name();
 88610:                     nextMember = new_<PropertyAccess>(lhs, field,
 86540:                                                       lhs->pn_pos.begin,
 86540:                                                       tokenStream.currentToken().pos.end);
 86540:                     if (!nextMember)
 86540:                         return NULL;
 86538:                 }
 86538:             }
 86538: #if JS_HAS_XML_SUPPORT
 99820:             else if (allowsXML()) {
 86540:                 TokenPtr begin = lhs->pn_pos.begin;
 86538:                 if (tt == TOK_LP) {
 86538:                     /* Filters are effectively 'with', so deoptimize names. */
104045:                     tc->sc->setFunIsHeavyweight();
104045:                     tc->sc->setBindingsAccessedDynamically();
104045: 
104045:                     StmtInfoTC stmtInfo(context);
104045:                     ParseNode *oldWith = tc->innermostWith;
104045:                     tc->innermostWith = lhs;
104045:                     PushStatementTC(tc, &stmtInfo, STMT_WITH);
 86538: 
 86540:                     ParseNode *filter = bracketedExpr();
 86540:                     if (!filter)
 86540:                         return NULL;
 86540:                     filter->setInParens(true);
 86538:                     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_IN_PAREN);
 86538: 
104045:                     tc->innermostWith = oldWith;
104045:                     PopStatementTC(tc);
 86538: 
 86540:                     nextMember =
 86540:                         new_<XMLFilterExpression>(lhs, filter,
 86540:                                                   begin, tokenStream.currentToken().pos.end);
 86540:                     if (!nextMember)
 86540:                         return NULL;
 86538:                 } else if (tt == TOK_AT || tt == TOK_STAR) {
 86540:                     ParseNode *propertyId = starOrAtPropertyIdentifier(tt);
 86540:                     if (!propertyId)
 86540:                         return NULL;
 86540:                     nextMember = new_<XMLProperty>(lhs, propertyId,
 86540:                                                    begin, tokenStream.currentToken().pos.end);
 86540:                     if (!nextMember)
 86540:                         return NULL;
     1:                 } else {
102849:                     reportError(NULL, JSMSG_NAME_AFTER_DOT);
     1:                     return NULL;
     1:                 }
     1:             }
     1: #endif
 86538:             else {
102849:                 reportError(NULL, JSMSG_NAME_AFTER_DOT);
 86538:                 return NULL;
 86538:             }
 86541:         }
     1: #if JS_HAS_XML_SUPPORT
 86541:         else if (tt == TOK_DBLDOT) {
 99820:             if (!allowsXML()) {
102849:                 reportError(NULL, JSMSG_NAME_AFTER_DOT);
 80780:                 return NULL;
 80780:             }
 80780: 
 98181:             nextMember = BinaryNode::create(PNK_DBLDOT, this);
 86540:             if (!nextMember)
     1:                 return NULL;
 40854:             tt = tokenStream.getToken(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
103823:             ParseNode *pn3 = primaryExpr(tt, true);
     1:             if (!pn3)
     1:                 return NULL;
 82024:             if (pn3->isKind(PNK_NAME) && !pn3->isInParens()) {
 82024:                 pn3->setKind(PNK_STRING);
 78294:                 pn3->setArity(PN_NULLARY);
 78294:                 pn3->setOp(JSOP_QNAMEPART);
 82024:             } else if (!pn3->isXMLPropertyIdentifier()) {
102849:                 reportError(NULL, JSMSG_NAME_AFTER_DOT);
     1:                 return NULL;
     1:             }
 86540:             nextMember->setOp(JSOP_DESCENDANTS);
 86540:             nextMember->pn_left = lhs;
 86540:             nextMember->pn_right = pn3;
 86540:             nextMember->pn_pos.begin = lhs->pn_pos.begin;
 86540:             nextMember->pn_pos.end = tokenStream.currentToken().pos.end;
 86541:         }
     1: #endif
 86541:         else if (tt == TOK_LB) {
 86541:             ParseNode *propExpr = expr();
 86541:             if (!propExpr)
 86541:                 return NULL;
 86541: 
 86541:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_IN_INDEX);
 86541:             TokenPtr begin = lhs->pn_pos.begin, end = tokenStream.currentToken().pos.end;
 86541: 
 86541:             /*
 86541:              * Optimize property name lookups.  If the name is a PropertyName,
 86541:              * then make a name-based node so the emitter will use a name-based
 86541:              * bytecode.  Otherwise make a node using the property expression
 86541:              * by value.  If the node is a string containing an index, convert
 86541:              * it to a number to save work later.
 86541:              */
 86541:             uint32_t index;
 86541:             PropertyName *name = NULL;
 86541:             if (propExpr->isKind(PNK_STRING)) {
 86541:                 JSAtom *atom = propExpr->pn_atom;
 86541:                 if (atom->isIndex(&index)) {
 86541:                     propExpr->setKind(PNK_NUMBER);
 86541:                     propExpr->setOp(JSOP_DOUBLE);
 86541:                     propExpr->pn_dval = index;
 86541:                 } else {
 86541:                     name = atom->asPropertyName();
 86541:                 }
 86541:             } else if (propExpr->isKind(PNK_NUMBER)) {
102387:                 JSAtom *atom = ToAtom(context, NumberValue(propExpr->pn_dval));
102387:                 if (!atom)
 86541:                     return NULL;
 86541:                 if (!atom->isIndex(&index))
 86541:                     name = atom->asPropertyName();
 86541:             }
 86541: 
 86541:             if (name)
 86541:                 nextMember = new_<PropertyAccess>(lhs, name, begin, end);
 86541:             else
 86541:                 nextMember = new_<PropertyByValue>(lhs, propExpr, begin, end);
 86540:             if (!nextMember)
     1:                 return NULL;
     1:         } else if (allowCallSyntax && tt == TOK_LP) {
 98181:             nextMember = ListNode::create(PNK_LP, this);
 86540:             if (!nextMember)
 86540:                 return NULL;
 86540:             nextMember->setOp(JSOP_CALL);
 27012: 
 86539:             if (lhs->isOp(JSOP_NAME)) {
 86539:                 if (lhs->pn_atom == context->runtime->atomState.evalAtom) {
104045:                     /* Select JSOP_EVAL and flag tc as heavyweight. */
 86540:                     nextMember->setOp(JSOP_EVAL);
104045:                     tc->sc->setBindingsAccessedDynamically();
104045:                     tc->sc->setFunIsHeavyweight();
 64296:                     /*
 64296:                      * In non-strict mode code, direct calls to eval can add
 64296:                      * variables to the call object.
 64296:                      */
104093:                     if (tc->sc->strictModeState != StrictMode::STRICT)
104045:                         tc->sc->setFunHasExtensibleScope();
 27012:                 }
 86539:             } else if (lhs->isOp(JSOP_GETPROP)) {
 57712:                 /* Select JSOP_FUNAPPLY given foo.apply(...). */
 86539:                 if (lhs->pn_atom == context->runtime->atomState.applyAtom)
 86540:                     nextMember->setOp(JSOP_FUNAPPLY);
 86539:                 else if (lhs->pn_atom == context->runtime->atomState.callAtom)
 86540:                     nextMember->setOp(JSOP_FUNCALL);
 86540:             }
 86540: 
 86540:             nextMember->initList(lhs);
 86540:             nextMember->pn_pos.begin = lhs->pn_pos.begin;
 86540: 
 86540:             if (!argumentList(nextMember))
 86540:                 return NULL;
 86540:             if (nextMember->pn_count > ARGC_LIMIT) {
 40239:                 JS_ReportErrorNumber(context, js_GetErrorMessage, NULL,
     1:                                      JSMSG_TOO_MANY_FUN_ARGS);
     1:                 return NULL;
     1:             }
 86540:             nextMember->pn_pos.end = tokenStream.currentToken().pos.end;
     1:         } else {
 40354:             tokenStream.ungetToken();
 86539:             return lhs;
 86539:         }
 86539: 
 86540:         lhs = nextMember;
     1:     }
     1:     if (tt == TOK_ERROR)
     1:         return NULL;
 86539:     return lhs;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::bracketedExpr()
     1: {
     1:     /*
     1:      * Always accept the 'in' operator in a parenthesized expression,
     1:      * where it's unambiguous, even if we might be parsing the init of a
     1:      * for statement.
     1:      */
104045:     bool oldInForInit = tc->inForInit;
104045:     tc->inForInit = false;
 98477:     ParseNode *pn = expr();
104045:     tc->inForInit = oldInForInit;
     1:     return pn;
     1: }
     1: 
     1: #if JS_HAS_XML_SUPPORT
     1: 
 80631: ParseNode *
 40860: Parser::endBracketedExpr()
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 80631:     ParseNode *pn = bracketedExpr();
     1:     if (!pn)
     1:         return NULL;
     1: 
     1:     MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_ATTR_EXPR);
     1:     return pn;
     1: }
     1: 
     1: /*
     1:  * From the ECMA-357 grammar in 11.1.1 and 11.1.2:
     1:  *
     1:  *      AttributeIdentifier:
     1:  *              @ PropertySelector
     1:  *              @ QualifiedIdentifier
     1:  *              @ [ Expression ]
     1:  *
     1:  *      PropertySelector:
     1:  *              Identifier
     1:  *              *
     1:  *
     1:  *      QualifiedIdentifier:
     1:  *              PropertySelector :: PropertySelector
     1:  *              PropertySelector :: [ Expression ]
     1:  *
     1:  * We adapt AttributeIdentifier and QualifiedIdentier to be LL(1), like so:
     1:  *
     1:  *      AttributeIdentifier:
     1:  *              @ QualifiedIdentifier
     1:  *              @ [ Expression ]
     1:  *
     1:  *      PropertySelector:
     1:  *              Identifier
     1:  *              *
     1:  *
     1:  *      QualifiedIdentifier:
     1:  *              PropertySelector :: PropertySelector
     1:  *              PropertySelector :: [ Expression ]
     1:  *              PropertySelector
     1:  *
     1:  * As PrimaryExpression: Identifier is in ECMA-262 and we want the semantics
     1:  * for that rule to result in a name node, but ECMA-357 extends the grammar
     1:  * to include PrimaryExpression: QualifiedIdentifier, we must factor further:
     1:  *
     1:  *      QualifiedIdentifier:
     1:  *              PropertySelector QualifiedSuffix
     1:  *
     1:  *      QualifiedSuffix:
     1:  *              :: PropertySelector
     1:  *              :: [ Expression ]
     1:  *              /nothing/
     1:  *
     1:  * And use this production instead of PrimaryExpression: QualifiedIdentifier:
     1:  *
     1:  *      PrimaryExpression:
     1:  *              Identifier QualifiedSuffix
     1:  *
     1:  * We hoist the :: match into callers of QualifiedSuffix, in order to tweak
     1:  * PropertySelector vs. Identifier pn_arity, pn_op, and other members.
     1:  */
 80631: ParseNode *
 40860: Parser::propertySelector()
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 82024:     ParseNode *selector;
 82024:     if (tokenStream.isCurrentTokenType(TOK_STAR)) {
 98181:         selector = NullaryNode::create(PNK_ANYNAME, this);
 82024:         if (!selector)
 82024:             return NULL;
 82024:         selector->setOp(JSOP_ANYNAME);
 82024:         selector->pn_atom = context->runtime->atomState.starAtom;
     1:     } else {
 82024:         JS_ASSERT(tokenStream.isCurrentTokenType(TOK_NAME));
 98181:         selector = NullaryNode::create(PNK_NAME, this);
 82024:         if (!selector)
 82024:             return NULL;
 82024:         selector->setOp(JSOP_QNAMEPART);
 82024:         selector->setArity(PN_NAME);
 82024:         selector->pn_atom = tokenStream.currentToken().name();
 82024:         selector->pn_cookie.makeFree();
 82024:     }
 82024:     return selector;
     1: }
     1: 
 80631: ParseNode *
 80631: Parser::qualifiedSuffix(ParseNode *pn)
 80631: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_DBLCOLON);
104045:     ParseNode *pn2 = NameNode::create(PNK_DBLCOLON, NULL, this, this->tc);
     1:     if (!pn2)
     1:         return NULL;
     1: 
104045:     tc->sc->setFunIsHeavyweight();
104045:     tc->sc->setBindingsAccessedDynamically();
 91455: 
     1:     /* Left operand of :: must be evaluated if it is an identifier. */
 78294:     if (pn->isOp(JSOP_QNAMEPART))
 78294:         pn->setOp(JSOP_NAME);
     1: 
 82024:     TokenKind tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
     1:     if (tt == TOK_STAR || tt == TOK_NAME) {
 40239:         /* Inline and specialize propertySelector for JSOP_QNAMECONST. */
 78294:         pn2->setOp(JSOP_QNAMECONST);
 27012:         pn2->pn_pos.begin = pn->pn_pos.begin;
     1:         pn2->pn_atom = (tt == TOK_STAR)
 40239:                        ? context->runtime->atomState.starAtom
 80443:                        : tokenStream.currentToken().name();
     1:         pn2->pn_expr = pn;
 47573:         pn2->pn_cookie.makeFree();
     1:         return pn2;
     1:     }
     1: 
     1:     if (tt != TOK_LB) {
102849:         reportError(NULL, JSMSG_SYNTAX_ERROR);
     1:         return NULL;
     1:     }
 82024:     ParseNode *pn3 = endBracketedExpr();
     1:     if (!pn3)
     1:         return NULL;
     1: 
 78294:     pn2->setOp(JSOP_QNAME);
 78294:     pn2->setArity(PN_BINARY);
 27012:     pn2->pn_pos.begin = pn->pn_pos.begin;
 27012:     pn2->pn_pos.end = pn3->pn_pos.end;
     1:     pn2->pn_left = pn;
     1:     pn2->pn_right = pn3;
     1:     return pn2;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::qualifiedIdentifier()
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 80631:     ParseNode *pn = propertySelector();
     1:     if (!pn)
     1:         return NULL;
 40354:     if (tokenStream.matchToken(TOK_DBLCOLON)) {
 28948:         /* Hack for bug 496316. Slowing down E4X won't make it go away, alas. */
104045:         tc->sc->setFunIsHeavyweight();
104045:         tc->sc->setBindingsAccessedDynamically();
 40263:         pn = qualifiedSuffix(pn);
 28948:     }
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::attributeIdentifier()
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_AT);
 98181:     ParseNode *pn = UnaryNode::create(PNK_AT, this);
     1:     if (!pn)
     1:         return NULL;
 78294:     pn->setOp(JSOP_TOATTRNAME);
 82024: 
 82024:     ParseNode *pn2;
 82024:     TokenKind tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
     1:     if (tt == TOK_STAR || tt == TOK_NAME) {
 40263:         pn2 = qualifiedIdentifier();
     1:     } else if (tt == TOK_LB) {
 40263:         pn2 = endBracketedExpr();
     1:     } else {
102849:         reportError(NULL, JSMSG_SYNTAX_ERROR);
     1:         return NULL;
     1:     }
     1:     if (!pn2)
     1:         return NULL;
     1:     pn->pn_kid = pn2;
     1:     return pn;
     1: }
     1: 
     1: /*
     1:  * Make a TOK_LC unary node whose pn_kid is an expression.
     1:  */
 80631: ParseNode *
103824: Parser::xmlExpr(bool inTag)
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LC);
 98181:     ParseNode *pn = UnaryNode::create(PNK_XMLCURLYEXPR, this);
     1:     if (!pn)
     1:         return NULL;
     1: 
     1:     /*
 38596:      * Turn off XML tag mode. We save the old value of the flag because it may
 38596:      * already be off: XMLExpr is called both from within a tag, and from
 38596:      * within text contained in an element, but outside of any start, end, or
 38596:      * point tag.
 38596:      */
 40854:     bool oldflag = tokenStream.isXMLTagMode();
 40854:     tokenStream.setXMLTagMode(false);
 82024:     ParseNode *pn2 = expr();
     1:     if (!pn2)
     1:         return NULL;
     1: 
     1:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_XML_EXPR);
 40854:     tokenStream.setXMLTagMode(oldflag);
     1:     pn->pn_kid = pn2;
 78294:     pn->setOp(inTag ? JSOP_XMLTAGEXPR : JSOP_XMLELTEXPR);
     1:     return pn;
     1: }
     1: 
     1: /*
     1:  * Parse the productions:
     1:  *
     1:  *      XMLNameExpr:
     1:  *              XMLName XMLNameExpr?
     1:  *              { Expr } XMLNameExpr?
     1:  *
     1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according as XMLNameExpr produces
     1:  * a list of names and/or expressions, a single expression, or a single name.
 82024:  * If PN_LIST or PN_NULLARY, getKind() will be PNK_XMLNAME.  Otherwise if
 82873:  * PN_UNARY, getKind() will be PNK_XMLCURLYEXPR.
     1:  */
 80631: ParseNode *
 40860: Parser::xmlNameExpr()
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 80631:     ParseNode *pn, *pn2, *list;
 40320:     TokenKind tt;
     1: 
     1:     pn = list = NULL;
     1:     do {
 40270:         tt = tokenStream.currentToken().type;
     1:         if (tt == TOK_LC) {
103823:             pn2 = xmlExpr(true);
     1:             if (!pn2)
     1:                 return NULL;
     1:         } else {
     1:             JS_ASSERT(tt == TOK_XMLNAME);
 82024:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_STRING);
 82024:             pn2 = atomNode(PNK_XMLNAME, JSOP_STRING);
     1:             if (!pn2)
     1:                 return NULL;
     1:         }
     1: 
     1:         if (!pn) {
     1:             pn = pn2;
     1:         } else {
     1:             if (!list) {
 98181:                 list = ListNode::create(PNK_XMLNAME, this);
     1:                 if (!list)
     1:                     return NULL;
     1:                 list->pn_pos.begin = pn->pn_pos.begin;
 27012:                 list->initList(pn);
 27012:                 list->pn_xflags = PNX_CANTFOLD;
     1:                 pn = list;
     1:             }
     1:             pn->pn_pos.end = pn2->pn_pos.end;
 27012:             pn->append(pn2);
     1:         }
 40354:     } while ((tt = tokenStream.getToken()) == TOK_XMLNAME || tt == TOK_LC);
 40354: 
 40354:     tokenStream.ungetToken();
     1:     return pn;
     1: }
     1: 
     1: /*
     1:  * Macro to test whether an XMLNameExpr or XMLTagContent node can be folded
     1:  * at compile time into a JSXML tree.
     1:  */
 78294: #define XML_FOLDABLE(pn)        ((pn)->isArity(PN_LIST)                     \
 27012:                                  ? ((pn)->pn_xflags & PNX_CANTFOLD) == 0    \
 82873:                                  : !(pn)->isKind(PNK_XMLCURLYEXPR))
     1: 
     1: /*
     1:  * Parse the productions:
     1:  *
     1:  *      XMLTagContent:
     1:  *              XMLNameExpr
     1:  *              XMLTagContent S XMLNameExpr S? = S? XMLAttr
     1:  *              XMLTagContent S XMLNameExpr S? = S? { Expr }
     1:  *
     1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according to how XMLTagContent
     1:  * produces a list of name and attribute values and/or braced expressions, a
     1:  * single expression, or a single name.
     1:  *
 82024:  * If PN_LIST or PN_NULLARY, getKind() will be PNK_XMLNAME for the case where
 82024:  * XMLTagContent: XMLNameExpr.  If getKind() is not PNK_XMLNAME but getArity()
 82024:  * is PN_LIST, getKind() will be tagkind.  If PN_UNARY, getKind() will be
 82873:  * PNK_XMLCURLYEXPR and we parsed exactly one expression.
     1:  */
 80631: ParseNode *
 82024: Parser::xmlTagContent(ParseNodeKind tagkind, JSAtom **namep)
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 80631:     ParseNode *pn, *pn2, *list;
 40320:     TokenKind tt;
 40221: 
 40263:     pn = xmlNameExpr();
     1:     if (!pn)
     1:         return NULL;
 78294:     *namep = (pn->isArity(PN_NULLARY)) ? pn->pn_atom : NULL;
     1:     list = NULL;
     1: 
 40354:     while (tokenStream.matchToken(TOK_XMLSPACE)) {
 40354:         tt = tokenStream.getToken();
     1:         if (tt != TOK_XMLNAME && tt != TOK_LC) {
 40354:             tokenStream.ungetToken();
 40239:             break;
 40239:         }
 40239: 
 40263:         pn2 = xmlNameExpr();
     1:         if (!pn2)
     1:             return NULL;
     1:         if (!list) {
 98181:             list = ListNode::create(tagkind, this);
     1:             if (!list)
     1:                 return NULL;
     1:             list->pn_pos.begin = pn->pn_pos.begin;
 27012:             list->initList(pn);
     1:             pn = list;
     1:         }
 27012:         pn->append(pn2);
     1:         if (!XML_FOLDABLE(pn2))
 27012:             pn->pn_xflags |= PNX_CANTFOLD;
     1: 
 40354:         tokenStream.matchToken(TOK_XMLSPACE);
     1:         MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_NO_ASSIGN_IN_XML_ATTR);
 40354:         tokenStream.matchToken(TOK_XMLSPACE);
 40354: 
 40354:         tt = tokenStream.getToken();
     1:         if (tt == TOK_XMLATTR) {
 82024:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_STRING);
 82024:             pn2 = atomNode(PNK_XMLATTR, JSOP_STRING);
     1:         } else if (tt == TOK_LC) {
103823:             pn2 = xmlExpr(true);
 27012:             pn->pn_xflags |= PNX_CANTFOLD;
     1:         } else {
102849:             reportError(NULL, JSMSG_BAD_XML_ATTR_VALUE);
     1:             return NULL;
     1:         }
     1:         if (!pn2)
     1:             return NULL;
     1:         pn->pn_pos.end = pn2->pn_pos.end;
 27012:         pn->append(pn2);
     1:     }
     1: 
     1:     return pn;
     1: }
     1: 
     1: #define XML_CHECK_FOR_ERROR_AND_EOF(tt,result)                                              \
     1:     JS_BEGIN_MACRO                                                                          \
     1:         if ((tt) <= TOK_EOF) {                                                              \
     1:             if ((tt) == TOK_EOF) {                                                          \
102849:                 reportError(NULL, JSMSG_END_OF_XML_SOURCE);                                 \
     1:             }                                                                               \
     1:             return result;                                                                  \
     1:         }                                                                                   \
     1:     JS_END_MACRO
     1: 
     1: /*
     1:  * Consume XML element tag content, including the TOK_XMLETAGO (</) sequence
     1:  * that opens the end tag for the container.
     1:  */
103824: bool
 80631: Parser::xmlElementContent(ParseNode *pn)
 40221: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 40854:     tokenStream.setXMLTagMode(false);
     1:     for (;;) {
 40854:         TokenKind tt = tokenStream.getToken(TSF_XMLTEXTMODE);
103823:         XML_CHECK_FOR_ERROR_AND_EOF(tt, false);
     1: 
     1:         JS_ASSERT(tt == TOK_XMLSPACE || tt == TOK_XMLTEXT);
 80443:         JSAtom *textAtom = tokenStream.currentToken().atom();
     1:         if (textAtom) {
     1:             /* Non-zero-length XML text scanned. */
 82024:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_STRING);
 82024:             ParseNode *pn2 = atomNode(tt == TOK_XMLSPACE ? PNK_XMLSPACE : PNK_XMLTEXT,
 82024:                                       JSOP_STRING);
     1:             if (!pn2)
 82024:                 return false;
     1:             pn->pn_pos.end = pn2->pn_pos.end;
 27012:             pn->append(pn2);
     1:         }
     1: 
 40854:         tt = tokenStream.getToken(TSF_OPERAND);
103823:         XML_CHECK_FOR_ERROR_AND_EOF(tt, false);
     1:         if (tt == TOK_XMLETAGO)
     1:             break;
     1: 
 80631:         ParseNode *pn2;
     1:         if (tt == TOK_LC) {
103823:             pn2 = xmlExpr(false);
 82024:             if (!pn2)
 82024:                 return false;
 27012:             pn->pn_xflags |= PNX_CANTFOLD;
     1:         } else if (tt == TOK_XMLSTAGO) {
103823:             pn2 = xmlElementOrList(false);
 82024:             if (!pn2)
 82024:                 return false;
 27012:             pn2->pn_xflags &= ~PNX_XMLROOT;
 27012:             pn->pn_xflags |= pn2->pn_xflags;
 82024:         } else if (tt == TOK_XMLPI) {
 86378:             const Token &tok = tokenStream.currentToken();
 86378:             pn2 = new_<XMLProcessingInstruction>(tok.xmlPITarget(), tok.xmlPIData(), tok.pos);
 82024:             if (!pn2)
 82024:                 return false;
     1:         } else {
 82024:             JS_ASSERT(tt == TOK_XMLCDATA || tt == TOK_XMLCOMMENT);
 82024:             pn2 = atomNode(tt == TOK_XMLCDATA ? PNK_XMLCDATA : PNK_XMLCOMMENT,
 82024:                            tokenStream.currentToken().t_op);
     1:             if (!pn2)
 82024:                 return false;
 82024:         }
     1:         pn->pn_pos.end = pn2->pn_pos.end;
 27012:         pn->append(pn2);
     1:     }
 40854:     tokenStream.setXMLTagMode(true);
     1: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_XMLETAGO);
103823:     return true;
     1: }
     1: 
     1: /*
     1:  * Return a PN_LIST node containing an XML or XMLList Initialiser.
     1:  */
 80631: ParseNode *
103824: Parser::xmlElementOrList(bool allowList)
     1: {
 99820:     JS_ASSERT(allowsXML());
 80780: 
 80631:     ParseNode *pn, *pn2, *list;
 40320:     TokenKind tt;
 99421:     RootedAtom startAtom(context), endAtom(context);
     1: 
 40239:     JS_CHECK_RECURSION(context, return NULL);
 40239: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_XMLSTAGO);
 98181:     pn = ListNode::create(PNK_XMLSTAGO, this);
     1:     if (!pn)
     1:         return NULL;
     1: 
 40854:     tokenStream.setXMLTagMode(true);
 40354:     tt = tokenStream.getToken();
     1:     if (tt == TOK_ERROR)
     1:         return NULL;
     1: 
     1:     if (tt == TOK_XMLNAME || tt == TOK_LC) {
     1:         /*
     1:          * XMLElement.  Append the tag and its contents, if any, to pn.
     1:          */
 97353:         pn2 = xmlTagContent(PNK_XMLSTAGO, startAtom.address());
     1:         if (!pn2)
     1:             return NULL;
 40354:         tokenStream.matchToken(TOK_XMLSPACE);
 40354: 
 40354:         tt = tokenStream.getToken();
     1:         if (tt == TOK_XMLPTAGC) {
     1:             /* Point tag (/>): recycle pn if pn2 is a list of tag contents. */
 82024:             if (pn2->isKind(PNK_XMLSTAGO)) {
 27012:                 pn->makeEmpty();
 80641:                 freeTree(pn);
     1:                 pn = pn2;
     1:             } else {
 82873:                 JS_ASSERT(pn2->isKind(PNK_XMLNAME) || pn2->isKind(PNK_XMLCURLYEXPR));
 27012:                 pn->initList(pn2);
     1:                 if (!XML_FOLDABLE(pn2))
 27012:                     pn->pn_xflags |= PNX_CANTFOLD;
     1:             }
 82024:             pn->setKind(PNK_XMLPTAGC);
 27012:             pn->pn_xflags |= PNX_XMLROOT;
     1:         } else {
     1:             /* We had better have a tag-close (>) at this point. */
     1:             if (tt != TOK_XMLTAGC) {
102849:                 reportError(NULL, JSMSG_BAD_XML_TAG_SYNTAX);
     1:                 return NULL;
     1:             }
 40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
     1: 
     1:             /* Make sure pn2 is a TOK_XMLSTAGO list containing tag contents. */
 82024:             if (!pn2->isKind(PNK_XMLSTAGO)) {
 27012:                 pn->initList(pn2);
     1:                 if (!XML_FOLDABLE(pn2))
 27012:                     pn->pn_xflags |= PNX_CANTFOLD;
     1:                 pn2 = pn;
 98181:                 pn = ListNode::create(PNK_XMLTAGC, this);
     1:                 if (!pn)
     1:                     return NULL;
     1:             }
     1: 
     1:             /* Now make pn a nominal-root TOK_XMLELEM list containing pn2. */
 82024:             pn->setKind(PNK_XMLELEM);
 27012:             pn->pn_pos.begin = pn2->pn_pos.begin;
 27012:             pn->initList(pn2);
     1:             if (!XML_FOLDABLE(pn2))
 27012:                 pn->pn_xflags |= PNX_CANTFOLD;
 27012:             pn->pn_xflags |= PNX_XMLROOT;
     1: 
     1:             /* Get element contents and delimiting end-tag-open sequence. */
 40263:             if (!xmlElementContent(pn))
 40239:                 return NULL;
 40239: 
 40354:             tt = tokenStream.getToken();
     1:             XML_CHECK_FOR_ERROR_AND_EOF(tt, NULL);
     1:             if (tt != TOK_XMLNAME && tt != TOK_LC) {
102849:                 reportError(NULL, JSMSG_BAD_XML_TAG_SYNTAX);
     1:                 return NULL;
     1:             }
     1: 
     1:             /* Parse end tag; check mismatch at compile-time if we can. */
 97353:             pn2 = xmlTagContent(PNK_XMLETAGO, endAtom.address());
     1:             if (!pn2)
     1:                 return NULL;
 82024:             if (pn2->isKind(PNK_XMLETAGO)) {
     1:                 /* Oops, end tag has attributes! */
102849:                 reportError(NULL, JSMSG_BAD_XML_TAG_SYNTAX);
     1:                 return NULL;
     1:             }
     1:             if (endAtom && startAtom && endAtom != startAtom) {
     1:                 /* End vs. start tag name mismatch: point to the tag name. */
102849:                 reportUcError(pn2, JSMSG_XML_TAG_NAME_MISMATCH, startAtom->chars());
     1:                 return NULL;
     1:             }
     1: 
     1:             /* Make a TOK_XMLETAGO list with pn2 as its single child. */
 82873:             JS_ASSERT(pn2->isKind(PNK_XMLNAME) || pn2->isKind(PNK_XMLCURLYEXPR));
 98181:             list = ListNode::create(PNK_XMLETAGO, this);
     1:             if (!list)
     1:                 return NULL;
 27012:             list->initList(pn2);
 27012:             pn->append(list);
     1:             if (!XML_FOLDABLE(pn2)) {
 27012:                 list->pn_xflags |= PNX_CANTFOLD;
 27012:                 pn->pn_xflags |= PNX_CANTFOLD;
     1:             }
     1: 
 40354:             tokenStream.matchToken(TOK_XMLSPACE);
     1:             MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_TAG_SYNTAX);
     1:         }
     1: 
     1:         /* Set pn_op now that pn has been updated to its final value. */
 78294:         pn->setOp(JSOP_TOXML);
     1:     } else if (allowList && tt == TOK_XMLTAGC) {
     1:         /* XMLList Initialiser. */
 82024:         pn->setKind(PNK_XMLLIST);
 78294:         pn->setOp(JSOP_TOXMLLIST);
 27012:         pn->makeEmpty();
 27012:         pn->pn_xflags |= PNX_XMLROOT;
 40263:         if (!xmlElementContent(pn))
     1:             return NULL;
     1: 
     1:         MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_LIST_SYNTAX);
     1:     } else {
102849:         reportError(NULL, JSMSG_BAD_XML_NAME_SYNTAX);
     1:         return NULL;
     1:     }
 40854:     tokenStream.setXMLTagMode(false);
     1: 
 40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
103824: Parser::xmlElementOrListRoot(bool allowList)
     1: {
 99820:     JS_ASSERT(allowsXML());
 99820: 
 99820:     /*
 99820:      * Turn on "moar XML" so that comments and CDATA literals are recognized,
 99820:      * instead of <! followed by -- starting an HTML comment to end of line
 99820:      * (used in script tags to hide content from old browsers that don't
 99820:      * recognize <script>).
 99820:      */
 99820:     bool hadMoarXML = tokenStream.hasMoarXML();
 99820:     tokenStream.setMoarXML(true);
 80631:     ParseNode *pn = xmlElementOrList(allowList);
 99820:     tokenStream.setMoarXML(hadMoarXML);
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
 40860: Parser::parseXMLText(JSObject *chain, bool allowList)
 27012: {
     1:     /*
     1:      * Push a compiler frame if we have no frames, or if the top frame is a
     1:      * lightweight function activation, or if its scope chain doesn't match
     1:      * the one passed to us.
     1:      */
104093:     SharedContext xmlsc(context, chain, /* fun = */ NULL, /* funbox = */ NULL, StrictMode::NOTSTRICT);
104045:     TreeContext xmltc(this, &xmlsc, /* staticLevel = */ 0, /* bodyid = */ 0);
104045:     if (!xmltc.init())
 72579:         return NULL;
     1: 
     1:     /* Set XML-only mode to turn off special treatment of {expr} in XML. */
 40854:     tokenStream.setXMLOnlyMode();
 40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
 27012: 
 80631:     ParseNode *pn;
     1:     if (tt != TOK_XMLSTAGO) {
102849:         reportError(NULL, JSMSG_BAD_XML_MARKUP);
     1:         pn = NULL;
     1:     } else {
 40263:         pn = xmlElementOrListRoot(allowList);
 40239:     }
 40854:     tokenStream.setXMLOnlyMode(false);
 40854: 
     1:     return pn;
     1: }
     1: 
     1: #endif /* JS_HAS_XMLSUPPORT */
     1: 
 86538: bool
 86538: Parser::checkForFunctionNode(PropertyName *name, ParseNode *node)
 86538: {
 86538:     /*
 86538:      * In |a.ns::name|, |ns| refers to an in-scope variable, so |ns| can't be a
 86538:      * keyword.  (Exception: |function::name| is the actual name property, not
 86538:      * what E4X would expose.)  We parsed |ns| accepting a keyword as a name,
 86538:      * so we must implement the keyword restriction manually in this case.
 86538:      */
 86538:     if (const KeywordInfo *ki = FindKeyword(name->charsZ(), name->length())) {
 86538:         if (ki->tokentype != TOK_FUNCTION) {
102849:             reportError(NULL, JSMSG_KEYWORD_NOT_NS);
 86538:             return false;
 86538:         }
 86538: 
 86538:         node->setArity(PN_NULLARY);
 86538:         node->setKind(PNK_FUNCTION);
 86538:     }
 86538: 
 86538:     return true;
 86538: }
 86538: 
 86538: #if JS_HAS_XML_SUPPORT
 86538: ParseNode *
 86538: Parser::propertyQualifiedIdentifier()
 86538: {
 99820:     JS_ASSERT(allowsXML());
 86538:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_NAME));
 86538:     JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NAME);
 86538:     JS_ASSERT(tokenStream.peekToken() == TOK_DBLCOLON);
 86538: 
 86538:     /* Deoptimize QualifiedIdentifier properties to avoid tricky analysis. */
104045:     tc->sc->setFunIsHeavyweight();
104045:     tc->sc->setBindingsAccessedDynamically();
 86538: 
 86538:     PropertyName *name = tokenStream.currentToken().name();
104045:     ParseNode *node = NameNode::create(PNK_NAME, name, this, this->tc);
 86538:     if (!node)
 86538:         return NULL;
 86538:     node->setOp(JSOP_NAME);
 86538:     node->pn_dflags |= PND_DEOPTIMIZED;
 86538: 
 86538:     if (!checkForFunctionNode(name, node))
 86538:         return NULL;
 86538: 
 86538:     tokenStream.consumeKnownToken(TOK_DBLCOLON);
 86538:     return qualifiedSuffix(node);
 86538: }
 86538: #endif
 86538: 
 86538: ParseNode *
 88610: Parser::identifierName(bool afterDoubleDot)
 86538: {
 86538:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_NAME));
 86538: 
 86538:     PropertyName *name = tokenStream.currentToken().name();
104045:     ParseNode *node = NameNode::create(PNK_NAME, name, this, this->tc);
 86538:     if (!node)
 86538:         return NULL;
 86538:     JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NAME);
 86538:     node->setOp(JSOP_NAME);
 86538: 
 95100:     if ((!afterDoubleDot
 86538: #if JS_HAS_XML_SUPPORT
 99820:                 || (allowsXML() && tokenStream.peekToken() == TOK_DBLCOLON)
 86538: #endif
104045:                ) && !tc->inDeclDestructuring)
 86538:     {
 98181:         if (!NoteNameUse(node, this))
 97594:             return NULL;
 86538:     }
 86538: 
 86538: #if JS_HAS_XML_SUPPORT
 99820:     if (allowsXML() && tokenStream.matchToken(TOK_DBLCOLON)) {
 88610:         if (afterDoubleDot) {
 86538:             if (!checkForFunctionNode(name, node))
 86538:                 return NULL;
 86538:         }
 86538:         node = qualifiedSuffix(node);
 86538:         if (!node)
 86538:             return NULL;
 86538:     }
 86538: #endif
 86538: 
 86538:     return node;
 86538: }
 86538: 
 86538: #if JS_HAS_XML_SUPPORT
 86538: ParseNode *
 86538: Parser::starOrAtPropertyIdentifier(TokenKind tt)
 86538: {
 86538:     JS_ASSERT(tt == TOK_AT || tt == TOK_STAR);
 99820:     if (allowsXML())
 99820:         return (tt == TOK_AT) ? attributeIdentifier() : qualifiedIdentifier();
102849:     reportError(NULL, JSMSG_SYNTAX_ERROR);
 86538:     return NULL;
 86538: }
 86538: #endif
 86538: 
 80631: ParseNode *
 98644: Parser::atomNode(ParseNodeKind kind, JSOp op)
 98644: {
 98644:     ParseNode *node = NullaryNode::create(kind, this);
 98644:     if (!node)
 98644:         return NULL;
 98644:     node->setOp(op);
 98644:     const Token &tok = tokenStream.currentToken();
 98644:     node->pn_atom = tok.atom();
 98644:     return node;
 98644: }
 98644: 
 98644: ParseNode *
 88610: Parser::primaryExpr(TokenKind tt, bool afterDoubleDot)
     1: {
 82024:     JS_ASSERT(tokenStream.isCurrentTokenType(tt));
 82024: 
 80631:     ParseNode *pn, *pn2, *pn3;
     1:     JSOp op;
 11139: 
 40239:     JS_CHECK_RECURSION(context, return NULL);
 11139: 
     1:     switch (tt) {
     1:       case TOK_FUNCTION:
     1: #if JS_HAS_XML_SUPPORT
 99820:         if (allowsXML() && tokenStream.matchToken(TOK_DBLCOLON, TSF_KEYWORD_IS_NAME)) {
 98181:             pn2 = NullaryNode::create(PNK_FUNCTION, this);
     1:             if (!pn2)
     1:                 return NULL;
 40263:             pn = qualifiedSuffix(pn2);
     1:             if (!pn)
     1:                 return NULL;
     1:             break;
     1:         }
     1: #endif
 40263:         pn = functionExpr();
     1:         if (!pn)
     1:             return NULL;
     1:         break;
     1: 
     1:       case TOK_LB:
     1:       {
 98181:         pn = ListNode::create(PNK_RB, this);
     1:         if (!pn)
     1:             return NULL;
 78294:         pn->setOp(JSOP_NEWINIT);
 27012:         pn->makeEmpty();
 27012: 
 27012: #if JS_HAS_GENERATORS
104045:         pn->pn_blockid = tc->blockidGen;
 27012: #endif
102219:         if (tokenStream.matchToken(TOK_RB, TSF_OPERAND)) {
102219:             /*
102219:              * Mark empty arrays as non-constant, since we cannot easily
102219:              * determine their type.
102219:              */
102219:             pn->pn_xflags |= PNX_NONCONST;
102219:         } else {
101314:             bool spread = false;
102219:             unsigned index = 0;
102219:             for (; ; index++) {
 73495:                 if (index == StackSpace::ARGS_LENGTH_MAX) {
102849:                     reportError(NULL, JSMSG_ARRAY_INIT_TOO_BIG);
     1:                     return NULL;
     1:                 }
     1: 
 40854:                 tt = tokenStream.peekToken(TSF_OPERAND);
     1:                 if (tt == TOK_RB) {
 27012:                     pn->pn_xflags |= PNX_ENDCOMMA;
     1:                     break;
     1:                 }
     1: 
     1:                 if (tt == TOK_COMMA) {
     1:                     /* So CURRENT_TOKEN gets TOK_COMMA and not TOK_LB. */
 40354:                     tokenStream.matchToken(TOK_COMMA);
 98181:                     pn2 = NullaryNode::create(PNK_COMMA, this);
 59962:                     pn->pn_xflags |= PNX_HOLEY | PNX_NONCONST;
     1:                 } else {
101314:                     ParseNode *spreadNode = NULL;
101314:                     if (tt == TOK_TRIPLEDOT) {
101314:                         spread = true;
101314:                         spreadNode = UnaryNode::create(PNK_SPREAD, this);
101314:                         if (!spreadNode)
101314:                             return NULL;
101314:                         tokenStream.getToken();
101314:                     }
 40263:                     pn2 = assignExpr();
 97664:                     if (pn2) {
 98181:                         if (foldConstants && !FoldConstants(context, pn2, this))
 97664:                             return NULL;
101314:                         if (!pn2->isConstant() || spreadNode)
 59962:                             pn->pn_xflags |= PNX_NONCONST;
101314:                         if (spreadNode) {
101314:                             spreadNode->pn_kid = pn2;
101314:                             pn2 = spreadNode;
101314:                         }
     1:                     }
 97664:                 }
     1:                 if (!pn2)
     1:                     return NULL;
 27012:                 pn->append(pn2);
     1: 
     1:                 if (tt != TOK_COMMA) {
     1:                     /* If we didn't already match TOK_COMMA in above case. */
 40354:                     if (!tokenStream.matchToken(TOK_COMMA))
     1:                         break;
     1:                 }
     1:             }
     1: 
     1: #if JS_HAS_GENERATORS
     1:             /*
     1:              * At this point, (index == 0 && pn->pn_count != 0) implies one
 26959:              * element initialiser was parsed.
     1:              *
     1:              * An array comprehension of the form:
     1:              *
     1:              *   [i * j for (i in o) for (j in p) if (i != j)]
     1:              *
     1:              * translates to roughly the following let expression:
     1:              *
     1:              *   let (array = new Array, i, j) {
     1:              *     for (i in o) let {
     1:              *       for (j in p)
     1:              *         if (i != j)
     1:              *           array.push(i * j)
     1:              *     }
     1:              *     array
     1:              *   }
     1:              *
     1:              * where array is a nameless block-local variable. The "roughly"
     1:              * means that an implementation may optimize away the array.push.
     1:              * An array comprehension opens exactly one block scope, no matter
     1:              * how many for heads it contains.
     1:              *
     1:              * Each let () {...} or for (let ...) ... compiles to:
     1:              *
     1:              *   JSOP_ENTERBLOCK <o> ... JSOP_LEAVEBLOCK <n>
     1:              *
     1:              * where <o> is a literal object representing the block scope,
     1:              * with <n> properties, naming each var declared in the block.
     1:              *
     1:              * Each var declaration in a let-block binds a name in <o> at
     1:              * compile time, and allocates a slot on the operand stack at
 74052:              * runtime via JSOP_ENTERBLOCK. A block-local var is accessed by
 74052:              * the JSOP_GETLOCAL and JSOP_SETLOCAL ops. These ops have an
 74052:              * immediate operand, the local slot's stack index from fp->spbase.
     1:              *
     1:              * The array comprehension iteration step, array.push(i * j) in
101314:              * the example above, is done by <i * j>; JSOP_ARRAYPUSH <array>,
     1:              * where <array> is the index of array's stack slot.
     1:              */
101314:             if (index == 0 && !spread && pn->pn_count != 0 && tokenStream.matchToken(TOK_FOR)) {
 80631:                 ParseNode *pnexp, *pntop;
     1: 
     1:                 /* Relabel pn as an array comprehension node. */
 82024:                 pn->setKind(PNK_ARRAYCOMP);
     1: 
     1:                 /*
     1:                  * Remove the comprehension expression from pn's linked list
     1:                  * and save it via pnexp.  We'll re-install it underneath the
     1:                  * ARRAYPUSH node after we parse the rest of the comprehension.
     1:                  */
 27012:                 pnexp = pn->last();
 51110:                 JS_ASSERT(pn->pn_count == 1);
 51110:                 pn->pn_count = 0;
 51110:                 pn->pn_tail = &pn->pn_head;
     1:                 *pn->pn_tail = NULL;
     1: 
 72073:                 pntop = comprehensionTail(pnexp, pn->pn_blockid, false,
 82024:                                           PNK_ARRAYPUSH, JSOP_ARRAYPUSH);
     1:                 if (!pntop)
     1:                     return NULL;
 27012:                 pn->append(pntop);
     1:             }
     1: #endif /* JS_HAS_GENERATORS */
     1: 
     1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_LIST);
     1:         }
 40270:         pn->pn_pos.end = tokenStream.currentToken().pos.end;
     1:         return pn;
     1:       }
     1: 
     1:       case TOK_LC:
     1:       {
 80631:         ParseNode *pnval;
     1: 
 35310:         /*
 60213:          * A map from property names we've seen thus far to a mask of property
 60213:          * assignment types, stored and retrieved with ALE_SET_INDEX/ALE_INDEX.
 35310:          */
 72579:         AtomIndexMap seen(context);
 72579: 
 60213:         enum AssignmentType {
 60213:             GET     = 0x1,
 60213:             SET     = 0x2,
 60213:             VALUE   = 0x4 | GET | SET
 60213:         };
 35310: 
 98181:         pn = ListNode::create(PNK_RC, this);
     1:         if (!pn)
     1:             return NULL;
 78294:         pn->setOp(JSOP_NEWINIT);
 27012:         pn->makeEmpty();
     1: 
     1:         for (;;) {
 35310:             JSAtom *atom;
 82469:             TokenKind ltok = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
 89334:             TokenPtr begin = tokenStream.currentToken().pos.begin;
 82469:             switch (ltok) {
     1:               case TOK_NUMBER:
 98181:                 pn3 = NullaryNode::create(PNK_NUMBER, this);
 33749:                 if (!pn3)
 33749:                     return NULL;
 80817:                 pn3->pn_dval = tokenStream.currentToken().number();
102387:                 atom = ToAtom(context, DoubleValue(pn3->pn_dval));
102387:                 if (!atom)
 40794:                     return NULL;
     1:                 break;
     1:               case TOK_NAME:
     1:                 {
 80443:                     atom = tokenStream.currentToken().name();
 82024:                     if (atom == context->runtime->atomState.getAtom) {
  1478:                         op = JSOP_GETTER;
 82024:                     } else if (atom == context->runtime->atomState.setAtom) {
  1478:                         op = JSOP_SETTER;
 82024:                     } else {
 98181:                         pn3 = NullaryNode::create(PNK_NAME, this);
 82024:                         if (!pn3)
 82024:                             return NULL;
 82024:                         pn3->pn_atom = atom;
 82024:                         break;
 82024:                     }
  1478: 
 40854:                     tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
 82024:                     if (tt == TOK_NAME) {
 82024:                         atom = tokenStream.currentToken().name();
104045:                         pn3 = NameNode::create(PNK_NAME, atom, this, this->tc);
     1:                         if (!pn3)
     1:                             return NULL;
 82024:                     } else if (tt == TOK_STRING) {
 82024:                         atom = tokenStream.currentToken().atom();
 86788: 
 86788:                         uint32_t index;
 86788:                         if (atom->isIndex(&index)) {
 98181:                             pn3 = NullaryNode::create(PNK_NUMBER, this);
 86788:                             if (!pn3)
 86788:                                 return NULL;
 86788:                             pn3->pn_dval = index;
102387:                             atom = ToAtom(context, DoubleValue(pn3->pn_dval));
102387:                             if (!atom)
 86788:                                 return NULL;
 86788:                         } else {
104045:                             pn3 = NameNode::create(PNK_STRING, atom, this, this->tc);
 82024:                             if (!pn3)
 82024:                                 return NULL;
 86788:                         }
 40794:                     } else if (tt == TOK_NUMBER) {
 98181:                         pn3 = NullaryNode::create(PNK_NUMBER, this);
 40794:                         if (!pn3)
 40794:                             return NULL;
 80817:                         pn3->pn_dval = tokenStream.currentToken().number();
102387:                         atom = ToAtom(context, DoubleValue(pn3->pn_dval));
102387:                         if (!atom)
 40794:                             return NULL;
 40794:                     } else {
 40794:                         tokenStream.ungetToken();
 98181:                         pn3 = NullaryNode::create(PNK_NAME, this);
 82024:                         if (!pn3)
 82024:                             return NULL;
 82024:                         pn3->pn_atom = atom;
 82024:                         break;
 40794:                     }
     1: 
 59962:                     pn->pn_xflags |= PNX_NONCONST;
 59962: 
 51087:                     /* NB: Getter function in { get x(){} } is unnamed. */
102586:                     Rooted<PropertyName*> funName(context, NULL);
102586:                     pn2 = functionDef(funName, op == JSOP_GETTER ? Getter : Setter, Expression);
 89334:                     if (!pn2)
 89334:                         return NULL;
 89334:                     TokenPos pos = {begin, pn2->pn_pos.end};
 89334:                     pn2 = new_<BinaryNode>(PNK_COLON, op, pos, pn3, pn2);
     1:                     goto skip;
     1:                 }
 86267:               case TOK_STRING: {
 80443:                 atom = tokenStream.currentToken().atom();
 86267:                 uint32_t index;
 86267:                 if (atom->isIndex(&index)) {
 98181:                     pn3 = NullaryNode::create(PNK_NUMBER, this);
 86267:                     if (!pn3)
 86267:                         return NULL;
 86267:                     pn3->pn_dval = index;
 86267:                 } else {
 98181:                     pn3 = NullaryNode::create(PNK_STRING, this);
 33749:                     if (!pn3)
 33749:                         return NULL;
 35310:                     pn3->pn_atom = atom;
 86267:                 }
     1:                 break;
 86267:               }
     1:               case TOK_RC:
     1:                 goto end_obj_init;
     1:               default:
102849:                 reportError(NULL, JSMSG_BAD_PROP_ID);
     1:                 return NULL;
     1:             }
     1: 
 40855:             op = JSOP_INITPROP;
 40354:             tt = tokenStream.getToken();
 37685:             if (tt == TOK_COLON) {
 40263:                 pnval = assignExpr();
 89334:                 if (!pnval)
 89334:                     return NULL;
 77448: 
 98181:                 if (foldConstants && !FoldConstants(context, pnval, this))
 97664:                     return NULL;
 97664: 
 77448:                 /*
 77448:                  * Treat initializers which mutate __proto__ as non-constant,
 77448:                  * so that we can later assume singleton objects delegate to
 77448:                  * the default Object.prototype.
 77448:                  */
 89334:                 if (!pnval->isConstant() || atom == context->runtime->atomState.protoAtom)
 59962:                     pn->pn_xflags |= PNX_NONCONST;
 77448:             }
 11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
 82469:             else if (ltok == TOK_NAME && (tt == TOK_COMMA || tt == TOK_RC)) {
 11039:                 /*
 11039:                  * Support, e.g., |var {x, y} = o| as destructuring shorthand
 11039:                  * for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.
 11039:                  */
 40354:                 tokenStream.ungetToken();
 81279:                 if (!tokenStream.checkForKeyword(atom->charsZ(), atom->length(), NULL, NULL))
 81279:                     return NULL;
 59962:                 pn->pn_xflags |= PNX_DESTRUCT | PNX_NONCONST;
 11039:                 pnval = pn3;
 82469:                 JS_ASSERT(pnval->isKind(PNK_NAME));
 78294:                 pnval->setArity(PN_NAME);
104045:                 ((NameNode *)pnval)->initCommon(tc);
 11039:             }
 11039: #endif
 82469:             else {
102849:                 reportError(NULL, JSMSG_COLON_AFTER_ID);
 82469:                 return NULL;
 11039:             }
 11039: 
 89334:             {
 89334:                 TokenPos pos = {begin, pnval->pn_pos.end};
 89334:                 pn2 = new_<BinaryNode>(PNK_COLON, op, pos, pn3, pnval);
 89334:             }
     1:           skip:
     1:             if (!pn2)
     1:                 return NULL;
 27012:             pn->append(pn2);
     1: 
 35310:             /*
 60213:              * Check for duplicate property names.  Duplicate data properties
 60213:              * only conflict in strict mode.  Duplicate getter or duplicate
 60213:              * setter halves always conflict.  A data property conflicts with
 60213:              * any part of an accessor property.
 60213:              */
 60213:             AssignmentType assignType;
 37685:             if (op == JSOP_INITPROP) {
 60213:                 assignType = VALUE;
 37685:             } else if (op == JSOP_GETTER) {
 60213:                 assignType = GET;
 37685:             } else if (op == JSOP_SETTER) {
 60213:                 assignType = SET;
 37685:             } else {
 35310:                 JS_NOT_REACHED("bad opcode in object initializer");
 60213:                 assignType = VALUE; /* try to error early */
 60213:             }
 60213: 
 72579:             AtomIndexAddPtr p = seen.lookupForAdd(atom);
 72579:             if (p) {
 72579:                 jsatomid index = p.value();
 72579:                 AssignmentType oldAssignType = AssignmentType(index);
 60213:                 if ((oldAssignType & assignType) &&
104045:                     (oldAssignType != VALUE || assignType != VALUE || tc->sc->needStrictChecks()))
 60213:                 {
 57812:                     JSAutoByteString name;
 60213:                     if (!js_AtomToPrintableString(context, atom, &name))
 60213:                         return NULL;
 60213: 
102849:                     Reporter reporter = 
104093:                         (oldAssignType == VALUE && assignType == VALUE && !tc->sc->needStrictChecks())
102849:                         ? &Parser::reportWarning
104093:                         : (tc->sc->needStrictChecks() ? &Parser::reportStrictModeError : &Parser::reportError);
102849:                     if (!(this->*reporter)(NULL, JSMSG_DUPLICATE_PROPERTY, name.ptr()))
102849:                         return NULL;
 60213:                 }
 72579:                 p.value() = assignType | oldAssignType;
 35310:             } else {
 72579:                 if (!seen.add(p, atom, assignType))
 72579:                     return NULL;
 35310:             }
 35310: 
 40354:             tt = tokenStream.getToken();
     1:             if (tt == TOK_RC)
     1:                 goto end_obj_init;
     1:             if (tt != TOK_COMMA) {
102849:                 reportError(NULL, JSMSG_CURLY_AFTER_LIST);
     1:                 return NULL;
     1:             }
     1:         }
  1967: 
     1:       end_obj_init:
 40270:         pn->pn_pos.end = tokenStream.currentToken().pos.end;
     1:         return pn;
     1:       }
     1: 
  1967: #if JS_HAS_BLOCK_SCOPE
  1967:       case TOK_LET:
 86078:         pn = letBlock(LetExpresion);
  1967:         if (!pn)
  1967:             return NULL;
  1967:         break;
  1967: #endif
  1967: 
     1:       case TOK_LP:
  1577:       {
103824:         bool genexp;
  1577: 
 61058:         pn = parenExpr(&genexp);
     1:         if (!pn)
     1:             return NULL;
 78294:         pn->setInParens(true);
 31479:         if (!genexp)
     1:             MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_IN_PAREN);
     1:         break;
  1577:       }
     1: 
 86538:       case TOK_STRING:
 86538:         pn = atomNode(PNK_STRING, JSOP_STRING);
 86538:         if (!pn)
 86538:             return NULL;
 86538:         break;
 86538: 
     1: #if JS_HAS_XML_SUPPORT
 86538:       case TOK_AT:
     1:       case TOK_STAR:
104208:         if (!allowsXML())
104208:             goto syntaxerror;
 86538:         pn = starOrAtPropertyIdentifier(tt);
     1:         break;
     1: 
     1:       case TOK_XMLSTAGO:
104208:         if (!allowsXML())
104208:             goto syntaxerror;
103823:         pn = xmlElementOrListRoot(true);
     1:         if (!pn)
     1:             return NULL;
     1:         break;
 86538: 
     1:       case TOK_XMLCDATA:
104208:         if (!allowsXML())
104208:             goto syntaxerror;
 82024:         pn = atomNode(PNK_XMLCDATA, JSOP_XMLCDATA);
 82024:         if (!pn)
 82024:             return NULL;
 82024:         break;
 82024: 
     1:       case TOK_XMLCOMMENT:
104208:         if (!allowsXML())
104208:             goto syntaxerror;
 82024:         pn = atomNode(PNK_XMLCOMMENT, JSOP_XMLCOMMENT);
 82024:         if (!pn)
 82024:             return NULL;
 82024:         break;
 86538: 
 86378:       case TOK_XMLPI: {
104208:         if (!allowsXML())
104208:             goto syntaxerror;
 86378:         const Token &tok = tokenStream.currentToken();
 86378:         pn = new_<XMLProcessingInstruction>(tok.xmlPITarget(), tok.xmlPIData(), tok.pos);
 80443:         if (!pn)
 80443:             return NULL;
 80443:         break;
 86378:       }
 80291: #endif
 80286: 
 27012:       case TOK_NAME:
 88610:         pn = identifierName(afterDoubleDot);
     1:         break;
     1: 
  6561:       case TOK_REGEXP:
  6561:       {
 98181:         pn = NullaryNode::create(PNK_REGEXP, this);
  6561:         if (!pn)
  6561:             return NULL;
  6561: 
 79981:         const jschar *chars = tokenStream.getTokenbuf().begin();
 79981:         size_t length = tokenStream.getTokenbuf().length();
 80816:         RegExpFlag flags = tokenStream.currentToken().regExpFlags();
 79981:         RegExpStatics *res = context->regExpStatics();
 79981: 
 99421:         Rooted<RegExpObject*> reobj(context);
 79981:         if (context->hasfp())
 79981:             reobj = RegExpObject::create(context, res, chars, length, flags, &tokenStream);
 79981:         else
 79981:             reobj = RegExpObject::createNoStatics(context, chars, length, flags, &tokenStream);
 79981: 
 79981:         if (!reobj)
 79981:             return NULL;
 79981: 
 98464:         if (!compileAndGo) {
104205:             if (!JSObject::clearParent(context, reobj))
104205:                 return NULL;
104205:             if (!JSObject::clearType(context, reobj))
 83252:                 return NULL;
 79981:         }
 79981: 
 98181:         pn->pn_objbox = newObjectBox(reobj);
 27012:         if (!pn->pn_objbox)
  6561:             return NULL;
  6561: 
 78294:         pn->setOp(JSOP_REGEXP);
  6561:         break;
  6561:       }
  6561: 
     1:       case TOK_NUMBER:
 98181:         pn = NullaryNode::create(PNK_NUMBER, this);
     1:         if (!pn)
     1:             return NULL;
 78294:         pn->setOp(JSOP_DOUBLE);
 80817:         pn->pn_dval = tokenStream.currentToken().number();
     1:         break;
     1: 
 82022:       case TOK_TRUE:
 86381:         return new_<BooleanLiteral>(true, tokenStream.currentToken().pos);
 82022:       case TOK_FALSE:
 86381:         return new_<BooleanLiteral>(false, tokenStream.currentToken().pos);
 82022:       case TOK_THIS:
 86381:         return new_<ThisLiteral>(tokenStream.currentToken().pos);
 82022:       case TOK_NULL:
 86381:         return new_<NullLiteral>(tokenStream.currentToken().pos);
     1: 
     1:       case TOK_ERROR:
     1:         /* The scanner or one of its subroutines reported the error. */
     1:         return NULL;
     1: 
104208:     syntaxerror:
     1:       default:
102849:         reportError(NULL, JSMSG_SYNTAX_ERROR);
     1:         return NULL;
     1:     }
     1:     return pn;
     1: }
     1: 
 80631: ParseNode *
103824: Parser::parenExpr(bool *genexp)
 40221: {
 40320:     TokenPtr begin;
 80631:     ParseNode *pn;
  1577: 
 40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LP);
 40270:     begin = tokenStream.currentToken().pos.begin;
  1577: 
  1577:     if (genexp)
103823:         *genexp = false;
 72073: 
 98181:     GenexpGuard guard(this);
 72073: 
 40263:     pn = bracketedExpr();
  1577:     if (!pn)
  1577:         return NULL;
 72073:     guard.endBody();
  1577: 
  1577: #if JS_HAS_GENERATOR_EXPRS
 40354:     if (tokenStream.matchToken(TOK_FOR)) {
 72073:         if (!guard.checkValidBody(pn))
 72073:             return NULL;
 82024:         JS_ASSERT(!pn->isKind(PNK_YIELD));
 82024:         if (pn->isKind(PNK_COMMA) && !pn->isInParens()) {
102849:             reportError(pn->last(), JSMSG_BAD_GENERATOR_SYNTAX, js_generator_str);
  1577:             return NULL;
  1577:         }
 61058:         pn = generatorExpr(pn);
 27012:         if (!pn)
 27012:             return NULL;
 26970:         pn->pn_pos.begin = begin;
  1577:         if (genexp) {
 40354:             if (tokenStream.getToken() != TOK_RP) {
102849:                 reportError(NULL, JSMSG_BAD_GENERATOR_SYNTAX, js_generator_str);
 40221:                 return NULL;
 40221:             }
 40270:             pn->pn_pos.end = tokenStream.currentToken().pos.end;
103823:             *genexp = true;
  1577:         }
 73053:     } else
  1577: #endif /* JS_HAS_GENERATOR_EXPRS */
  1577: 
 78006:     if (!guard.maybeNoteGenerator(pn))
 72565:         return NULL;
 72073: 
  1577:     return pn;
  1577: }
 98180: 
