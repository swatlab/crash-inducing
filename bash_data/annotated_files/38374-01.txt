    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla browser.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications, Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Travis Bogard <travis@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: // Local Includes
    1: #include "nsWebBrowser.h"
    1: 
    1: // Helper Classes
    1: #include "nsGfxCIID.h"
    1: #include "nsWidgetsCID.h"
    1: 
    1: //Interfaces Needed
    1: #include "nsReadableUtils.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMDocument.h"
34604: #include "nsIDOM3Document.h"
    1: #include "nsIDOMXULDocument.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIWebProgress.h"
    1: #include "nsIWebProgressListener.h"
    1: #include "nsIWebBrowserFocus.h"
    1: #include "nsIWebBrowserStream.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIGlobalHistory.h"
    1: #include "nsIDocShellHistory.h"
    1: #include "nsIURIContentListener.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsISHistoryListener.h"
    1: #include "nsIURI.h"
    1: #include "nsIWebBrowserPersist.h"
    1: #include "nsCWebBrowserPersist.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsAutoPtr.h"
29018: #include "nsFocusManager.h"
    1: 
    1: // for painting the background window
    1: #include "nsIRenderingContext.h"
 8626: #include "nsIDeviceContext.h"
    1: #include "nsIRegion.h"
    1: #include "nsILookAndFeel.h"
    1: 
    1: // Printing Includes
    1: #ifdef NS_PRINTING
    1: #include "nsIWebBrowserPrint.h"
    1: #include "nsIContentViewer.h"
    1: #endif
    1: 
    1: // PSM2 includes
    1: #include "nsISecureBrowserUI.h"
    1: 
    1: static NS_DEFINE_IID(kWindowCID, NS_WINDOW_CID);
    1: static NS_DEFINE_CID(kChildCID, NS_CHILD_CID);
    1: static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
    1: 
    1: 
    1: //*****************************************************************************
    1: //***    nsWebBrowser: Object Management
    1: //*****************************************************************************
    1: 
    1: nsWebBrowser::nsWebBrowser() : mDocShellTreeOwner(nsnull), 
    1:    mInitInfo(nsnull),
    1:    mContentType(typeContentWrapper),
    1:    mActivating(PR_FALSE),
    1:    mShouldEnableHistory(PR_TRUE),
    1:    mParentNativeWindow(nsnull),
    1:    mProgressListener(nsnull),
    1:    mBackgroundColor(0),
    1:    mPersistCurrentState(nsIWebBrowserPersist::PERSIST_STATE_READY),
    1:    mPersistResult(NS_OK),
    1:    mPersistFlags(nsIWebBrowserPersist::PERSIST_FLAGS_NONE),
    1:    mStream(nsnull),
    1:    mParentWidget(nsnull),
    1:    mListenerArray(nsnull)
    1: {
    1:     mInitInfo = new nsWebBrowserInitInfo();
    1:     mWWatch = do_GetService(NS_WINDOWWATCHER_CONTRACTID);
    1:     NS_ASSERTION(mWWatch, "failed to get WindowWatcher");
    1: }
    1: 
    1: nsWebBrowser::~nsWebBrowser()
    1: {
    1:    InternalDestroy();
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::InternalDestroy()
    1: {
    1: 
16037:    if (mInternalWidget) {
    1:      mInternalWidget->SetClientData(0);
16037:      mInternalWidget->Destroy();
16037:      mInternalWidget = nsnull; // Force release here.
16037:    }
    1: 
    1:    SetDocShell(nsnull);
    1: 
    1:    if(mDocShellTreeOwner)
    1:       {
    1:       mDocShellTreeOwner->WebBrowser(nsnull);
    1:       NS_RELEASE(mDocShellTreeOwner);
    1:       }
    1:    if(mInitInfo)
    1:       {
    1:       delete mInitInfo;
    1:       mInitInfo = nsnull;
    1:       }
    1: 
    1:    if (mListenerArray) {
25498:       for (PRUint32 i = 0, end = mListenerArray->Length(); i < end; i++) {
25498:          nsWebBrowserListenerState *state = mListenerArray->ElementAt(i);
25498:          NS_DELETEXPCOM(state);
25498:       }
    1:       delete mListenerArray;
    1:       mListenerArray = nsnull;
    1:    }
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: 
    1: //*****************************************************************************
    1: // nsWebBrowser::nsISupports
    1: //*****************************************************************************   
    1: 
    1: NS_IMPL_ADDREF(nsWebBrowser)
    1: NS_IMPL_RELEASE(nsWebBrowser)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsWebBrowser)
    1:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebBrowser)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebBrowser)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebNavigation)
    1:     NS_INTERFACE_MAP_ENTRY(nsIBaseWindow)
    1:     NS_INTERFACE_MAP_ENTRY(nsIScrollable)
    1:     NS_INTERFACE_MAP_ENTRY(nsITextScroll)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocShellTreeItem)
13964:     NS_INTERFACE_MAP_ENTRY(nsIDocShellTreeNode)
    1:     NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebBrowserSetup)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebBrowserPersist)
    1:     NS_INTERFACE_MAP_ENTRY(nsICancelable)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebBrowserFocus)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebBrowserStream)
    1:     NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1: NS_INTERFACE_MAP_END
    1: 
    1: ///*****************************************************************************
    1: // nsWebBrowser::nsIInterfaceRequestor
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetInterface(const nsIID& aIID, void** aSink)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aSink);
    1: 
    1:    if(NS_SUCCEEDED(QueryInterface(aIID, aSink)))
    1:       return NS_OK;
    1: 
    1:    if (mDocShell) {
    1: #ifdef NS_PRINTING
    1:        if (aIID.Equals(NS_GET_IID(nsIWebBrowserPrint))) {
    1:            nsCOMPtr<nsIContentViewer> viewer;
    1:            mDocShell->GetContentViewer(getter_AddRefs(viewer));
    1:            if (!viewer)
    1:                return NS_NOINTERFACE;
    1: 
    1:            nsCOMPtr<nsIWebBrowserPrint> webBrowserPrint(do_QueryInterface(viewer));
    1:            nsIWebBrowserPrint* print = (nsIWebBrowserPrint*)webBrowserPrint.get();
    1:            NS_ASSERTION(print, "This MUST support this interface!");
    1:            NS_ADDREF(print);
    1:            *aSink = print;
    1:            return NS_OK;
    1:        }
    1: #endif
    1:        return mDocShellAsReq->GetInterface(aIID, aSink);
    1:    }
    1: 
    1:    return NS_NOINTERFACE;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsWebBrowser::nsIWebBrowser
    1: //*****************************************************************************   
    1: 
    1: // listeners that currently support registration through AddWebBrowserListener:
    1: //  - nsIWebProgressListener
    1: NS_IMETHODIMP nsWebBrowser::AddWebBrowserListener(nsIWeakReference *aListener, const nsIID& aIID)
    1: {           
    1:     NS_ENSURE_ARG_POINTER(aListener);
    1: 
    1:     nsresult rv = NS_OK;
    1:     if (!mWebProgress) {
    1:         // The window hasn't been created yet, so queue up the listener. They'll be
    1:         // registered when the window gets created.
    1:         nsAutoPtr<nsWebBrowserListenerState> state;
    1:         NS_NEWXPCOM(state, nsWebBrowserListenerState);
    1:         if (!state) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         state->mWeakPtr = aListener;
    1:         state->mID = aIID;
    1: 
    1:         if (!mListenerArray) {
25498:             NS_NEWXPCOM(mListenerArray, nsTArray<nsWebBrowserListenerState*>);
    1:             if (!mListenerArray) {
    1:                 return NS_ERROR_OUT_OF_MEMORY;
    1:             }
    1:         }
    1: 
    1:         if (!mListenerArray->AppendElement(state)) {
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1: 
    1:         // We're all set now; don't delete |state| after this point
    1:         state.forget();
    1:     } else {
    1:         nsCOMPtr<nsISupports> supports(do_QueryReferent(aListener));
    1:         if (!supports) return NS_ERROR_INVALID_ARG;
    1:         rv = BindListener(supports, aIID);
    1:     }
    1:     
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::BindListener(nsISupports *aListener, const nsIID& aIID) {
30579:     NS_ENSURE_ARG_POINTER(aListener);
    1:     NS_ASSERTION(mWebProgress, "this should only be called after we've retrieved a progress iface");
    1:     nsresult rv = NS_OK;
    1: 
    1:     // register this listener for the specified interface id
    1:     if (aIID.Equals(NS_GET_IID(nsIWebProgressListener))) {
    1:         nsCOMPtr<nsIWebProgressListener> listener = do_QueryInterface(aListener, &rv);
    1:         if (NS_FAILED(rv)) return rv;
30579:         NS_ENSURE_STATE(mWebProgress);
    1:         rv = mWebProgress->AddProgressListener(listener, nsIWebProgress::NOTIFY_ALL);
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsISHistoryListener))) {      
    1:       nsCOMPtr<nsISHistory> shistory(do_GetInterface(mDocShell, &rv));
    1:       if (NS_FAILED(rv)) return rv;
    1:       nsCOMPtr<nsISHistoryListener> listener(do_QueryInterface(aListener, &rv));
    1:       if (NS_FAILED(rv)) return rv;
    1:       rv = shistory->AddSHistoryListener(listener);
    1:     }
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::RemoveWebBrowserListener(nsIWeakReference *aListener, const nsIID& aIID)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aListener);
    1: 
    1:     nsresult rv = NS_OK;
    1:     if (!mWebProgress) {
    1:         // if there's no-one to register the listener w/, and we don't have a queue going,
    1:         // the the called is calling Remove before an Add which doesn't make sense.
    1:         if (!mListenerArray) return NS_ERROR_FAILURE;
    1: 
    1:         // iterate the array and remove the queued listener
25498:         PRInt32 count = mListenerArray->Length();
    1:         while (count > 0) {
25498:             nsWebBrowserListenerState *state = mListenerArray->ElementAt(count);
    1:             NS_ASSERTION(state, "list construction problem");
    1: 
    1:             if (state->Equals(aListener, aIID)) {
    1:                 // this is the one, pull it out.
    1:                 mListenerArray->RemoveElementAt(count);
    1:                 break;
    1:             }
    1:             count--; 
    1:         }
    1: 
    1:         // if we've emptied the array, get rid of it.
25498:         if (0 >= mListenerArray->Length()) {
25498:             for (PRUint32 i = 0, end = mListenerArray->Length(); i < end; i++) {
25498:                nsWebBrowserListenerState *state = mListenerArray->ElementAt(i);
25498:                NS_DELETEXPCOM(state);
25498:             }
    1:             NS_DELETEXPCOM(mListenerArray);
    1:             mListenerArray = nsnull;
    1:         }
    1: 
    1:     } else {
    1:         nsCOMPtr<nsISupports> supports(do_QueryReferent(aListener));
    1:         if (!supports) return NS_ERROR_INVALID_ARG;
    1:         rv = UnBindListener(supports, aIID);
    1:     }
    1:     
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::UnBindListener(nsISupports *aListener, const nsIID& aIID) {
30579:     NS_ENSURE_ARG_POINTER(aListener);
    1:     NS_ASSERTION(mWebProgress, "this should only be called after we've retrieved a progress iface");
    1:     nsresult rv = NS_OK;
    1: 
    1:     // remove the listener for the specified interface id
    1:     if (aIID.Equals(NS_GET_IID(nsIWebProgressListener))) {
    1:         nsCOMPtr<nsIWebProgressListener> listener = do_QueryInterface(aListener, &rv);
    1:         if (NS_FAILED(rv)) return rv;
30579:         NS_ENSURE_STATE(mWebProgress);
    1:         rv = mWebProgress->RemoveProgressListener(listener);
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsISHistoryListener))) {
    1:       nsCOMPtr<nsISHistory> shistory(do_GetInterface(mDocShell, &rv));
    1:       if (NS_FAILED(rv)) return rv;
    1:       nsCOMPtr<nsISHistoryListener> listener(do_QueryInterface(aListener, &rv));
    1:       if (NS_FAILED(rv)) return rv;
    1:       rv = shistory->RemoveSHistoryListener(listener);
    1:     }
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::EnableGlobalHistory(PRBool aEnable)
    1: {
    1:     nsresult rv;
    1:     
    1:     NS_ENSURE_STATE(mDocShell);
    1:     nsCOMPtr<nsIDocShellHistory> dsHistory(do_QueryInterface(mDocShell, &rv));
    1:     if (NS_FAILED(rv)) return rv;
    1:     
30579:     return dsHistory->SetUseGlobalHistory(aEnable);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetContainerWindow(nsIWebBrowserChrome** aTopWindow)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aTopWindow);
    1: 
    1:    if(mDocShellTreeOwner) {
    1:       *aTopWindow = mDocShellTreeOwner->GetWebBrowserChrome().get();
    1:    } else {
    1:       *aTopWindow = nsnull;
    1:    }
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetContainerWindow(nsIWebBrowserChrome* aTopWindow)
    1: {
    1:    NS_ENSURE_SUCCESS(EnsureDocShellTreeOwner(), NS_ERROR_FAILURE);
    1:    return mDocShellTreeOwner->SetWebBrowserChrome(aTopWindow);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetParentURIContentListener(nsIURIContentListener**
    1:    aParentContentListener)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aParentContentListener);
    1:    *aParentContentListener = nsnull;
    1: 
    1:    // get the interface from the docshell
    1:    nsCOMPtr<nsIURIContentListener> listener(do_GetInterface(mDocShell));
    1: 
    1:    if (listener)
    1:        return listener->GetParentContentListener(aParentContentListener);
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetParentURIContentListener(nsIURIContentListener*
    1:    aParentContentListener)
    1: {
    1:    // get the interface from the docshell
    1:    nsCOMPtr<nsIURIContentListener> listener(do_GetInterface(mDocShell));
    1: 
    1:    if (listener)
    1:        return listener->SetParentContentListener(aParentContentListener);
    1:    return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetContentDOMWindow(nsIDOMWindow **_retval)
    1: {
    1:     NS_ENSURE_STATE(mDocShell);
    1:     nsresult rv = NS_OK;
    1:     nsCOMPtr<nsIDOMWindow> retval = do_GetInterface(mDocShell, &rv);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     *_retval = retval;
    1:     NS_ADDREF(*_retval);
    1:     return rv;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsWebBrowser::nsIDocShellTreeItem
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetName(PRUnichar** aName)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aName);
    1: 
    1:    if(mDocShell)  
    1:       mDocShellAsItem->GetName(aName);
    1:    else
    1:       *aName = ToNewUnicode(mInitInfo->name);
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetName(const PRUnichar* aName)
    1: {
    1:    if(mDocShell)
    1:       {
    1:       nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:       NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
    1: 
    1:       return docShellAsItem->SetName(aName);
    1:       }
    1:    else
    1:       mInitInfo->name = aName;
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::NameEquals(const PRUnichar *aName, PRBool *_retval)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aName);
    1:     NS_ENSURE_ARG_POINTER(_retval);
    1:     if(mDocShell)
    1:     {
    1:         nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:         NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
    1:         return docShellAsItem->NameEquals(aName, _retval);
    1:     }
    1:     else
    1:         *_retval = mInitInfo->name.Equals(aName);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetItemType(PRInt32* aItemType)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aItemType);
    1: 
    1:    *aItemType = mContentType;
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetItemType(PRInt32 aItemType)
    1: {
    1:     NS_ENSURE_TRUE((aItemType == typeContentWrapper || aItemType == typeChromeWrapper), NS_ERROR_FAILURE);
    1:     mContentType = aItemType;
    1:     if (mDocShellAsItem)
    1:         mDocShellAsItem->SetItemType(mContentType == typeChromeWrapper ? typeChrome : typeContent);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetParent(nsIDocShellTreeItem** aParent)
    1: {
    1:    *aParent = nsnull;
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetSameTypeParent(nsIDocShellTreeItem** aParent)
    1: {
    1:    *aParent = nsnull;
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetRootTreeItem(nsIDocShellTreeItem** aRootTreeItem)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aRootTreeItem);
 3233:    *aRootTreeItem = static_cast<nsIDocShellTreeItem*>(this);
    1: 
    1:    nsCOMPtr<nsIDocShellTreeItem> parent;
    1:    NS_ENSURE_SUCCESS(GetParent(getter_AddRefs(parent)), NS_ERROR_FAILURE);
    1:    while(parent)
    1:       {
    1:       *aRootTreeItem = parent;
    1:       NS_ENSURE_SUCCESS((*aRootTreeItem)->GetParent(getter_AddRefs(parent)), NS_ERROR_FAILURE);
    1:       }
    1:    NS_ADDREF(*aRootTreeItem);
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetSameTypeRootTreeItem(nsIDocShellTreeItem** aRootTreeItem)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aRootTreeItem);
 3233:    *aRootTreeItem = static_cast<nsIDocShellTreeItem*>(this);
    1: 
    1:    nsCOMPtr<nsIDocShellTreeItem> parent;
    1:    NS_ENSURE_SUCCESS(GetSameTypeParent(getter_AddRefs(parent)), NS_ERROR_FAILURE);
    1:    while(parent)
    1:       {
    1:       *aRootTreeItem = parent;
    1:       NS_ENSURE_SUCCESS((*aRootTreeItem)->GetSameTypeParent(getter_AddRefs(parent)), 
    1:          NS_ERROR_FAILURE);
    1:       }
    1:    NS_ADDREF(*aRootTreeItem);
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::FindItemWithName(const PRUnichar *aName, 
    1:    nsISupports* aRequestor, nsIDocShellTreeItem* aOriginalRequestor,
    1:    nsIDocShellTreeItem **_retval)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1:    NS_ASSERTION(mDocShellTreeOwner, "This should always be set when in this situation");
    1: 
    1:    return mDocShellAsItem->FindItemWithName(aName, 
 3233:       static_cast<nsIDocShellTreeOwner*>(mDocShellTreeOwner),
    1:       aOriginalRequestor, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetTreeOwner(nsIDocShellTreeOwner** aTreeOwner)
    1: {  
    1:     NS_ENSURE_ARG_POINTER(aTreeOwner);
    1:     *aTreeOwner = nsnull;
    1:     if(mDocShellTreeOwner)
    1:     {
    1:         if (mDocShellTreeOwner->mTreeOwner)
    1:         {
    1:             *aTreeOwner = mDocShellTreeOwner->mTreeOwner;
    1:         }
    1:         else
    1:         {
    1:             *aTreeOwner = mDocShellTreeOwner;
    1:         }
    1:     }
    1:     NS_IF_ADDREF(*aTreeOwner);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetTreeOwner(nsIDocShellTreeOwner* aTreeOwner)
    1: {
    1:    NS_ENSURE_SUCCESS(EnsureDocShellTreeOwner(), NS_ERROR_FAILURE);
    1:    return mDocShellTreeOwner->SetTreeOwner(aTreeOwner);
    1: }
    1: 
    1: //*****************************************************************************
 1160: // nsWebBrowser::nsIDocShellTreeItem
 1160: //*****************************************************************************
 1160: 
 1160: NS_IMETHODIMP nsWebBrowser::GetChildCount(PRInt32 * aChildCount)
 1160: {
 1160:     NS_ENSURE_ARG_POINTER(aChildCount);
 1160:     *aChildCount = 0;
 1160:     return NS_OK;
 1160: }
 1160: 
 1160: NS_IMETHODIMP nsWebBrowser::AddChild(nsIDocShellTreeItem * aChild)
 1160: {
 1160:     return NS_ERROR_UNEXPECTED;
 1160: }
 1160: 
 1160: NS_IMETHODIMP nsWebBrowser::RemoveChild(nsIDocShellTreeItem * aChild)
 1160: {
 1160:     return NS_ERROR_UNEXPECTED;
 1160: }
 1160: 
 1160: NS_IMETHODIMP nsWebBrowser::GetChildAt(PRInt32 aIndex,
 1160:                                        nsIDocShellTreeItem ** aChild)
 1160: {
 1160:     return NS_ERROR_UNEXPECTED;
 1160: }
 1160: 
 1160: NS_IMETHODIMP nsWebBrowser::FindChildWithName(
 1160:                                        const PRUnichar * aName,
 1160:                                        PRBool aRecurse, PRBool aSameType,
 1160:                                        nsIDocShellTreeItem * aRequestor,
 1160:                                        nsIDocShellTreeItem * aOriginalRequestor,
 1160:                                        nsIDocShellTreeItem ** _retval)
 1160: {
 1160:     NS_ENSURE_ARG_POINTER(_retval);
 1160: 
 1160:     *_retval = nsnull;
 1160:     return NS_OK;
 1160: }
 1160: 
 1160: //*****************************************************************************
    1: // nsWebBrowser::nsIWebNavigation
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetCanGoBack(PRBool* aCanGoBack)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsNav->GetCanGoBack(aCanGoBack);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetCanGoForward(PRBool* aCanGoForward)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsNav->GetCanGoForward(aCanGoForward);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GoBack()
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsNav->GoBack();
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GoForward()
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsNav->GoForward();
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::LoadURI(const PRUnichar* aURI,
    1:                                     PRUint32 aLoadFlags,
    1:                                     nsIURI* aReferringURI,
    1:                                     nsIInputStream* aPostDataStream,
    1:                                     nsIInputStream* aExtraHeaderStream)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsNav->LoadURI(aURI,
    1:                                   aLoadFlags,
    1:                                   aReferringURI,
    1:                                   aPostDataStream,
    1:                                   aExtraHeaderStream);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::Reload(PRUint32 aReloadFlags)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsNav->Reload(aReloadFlags);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GotoIndex(PRInt32 aIndex)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsNav->GotoIndex(aIndex);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::Stop(PRUint32 aStopFlags)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsNav->Stop(aStopFlags);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetCurrentURI(nsIURI** aURI)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsNav->GetCurrentURI(aURI);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetReferringURI(nsIURI** aURI)
    1: {
    1:     NS_ENSURE_STATE(mDocShell);
    1: 
    1:     return mDocShellAsNav->GetReferringURI(aURI);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetSessionHistory(nsISHistory* aSessionHistory)
    1: {
    1:    if(mDocShell)
    1:       return mDocShellAsNav->SetSessionHistory(aSessionHistory);
    1:    else
    1:       mInitInfo->sessionHistory = aSessionHistory;
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetSessionHistory(nsISHistory** aSessionHistory)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aSessionHistory);
    1:    if(mDocShell)
    1:       return mDocShellAsNav->GetSessionHistory(aSessionHistory);
    1:    else
    1:       *aSessionHistory = mInitInfo->sessionHistory;
    1: 
    1:    NS_IF_ADDREF(*aSessionHistory);
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetDocument(nsIDOMDocument** aDocument)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsNav->GetDocument(aDocument);
    1: }
    1: 
    1: 
    1: //*****************************************************************************
    1: // nsWebBrowser::nsIWebBrowserSetup
    1: //*****************************************************************************
    1: 
    1: /* void setProperty (in unsigned long aId, in unsigned long aValue); */
    1: NS_IMETHODIMP nsWebBrowser::SetProperty(PRUint32 aId, PRUint32 aValue)
    1: {
    1:     nsresult rv = NS_OK;
    1:     
    1:     switch (aId)
    1:     {
    1:     case nsIWebBrowserSetup::SETUP_ALLOW_PLUGINS:
    1:         {
    1:            NS_ENSURE_STATE(mDocShell);
    1:            NS_ENSURE_TRUE((aValue == PR_TRUE || aValue == PR_FALSE), NS_ERROR_INVALID_ARG);
 6895:            mDocShell->SetAllowPlugins(!!aValue);
    1:         }
    1:         break;
    1:     case nsIWebBrowserSetup::SETUP_ALLOW_JAVASCRIPT:
    1:         {
    1:            NS_ENSURE_STATE(mDocShell);
    1:            NS_ENSURE_TRUE((aValue == PR_TRUE || aValue == PR_FALSE), NS_ERROR_INVALID_ARG);
 6895:            mDocShell->SetAllowJavascript(!!aValue);
    1:         }
    1:         break;
    1:     case nsIWebBrowserSetup::SETUP_ALLOW_META_REDIRECTS:
    1:         {
    1:            NS_ENSURE_STATE(mDocShell);
    1:            NS_ENSURE_TRUE((aValue == PR_TRUE || aValue == PR_FALSE), NS_ERROR_INVALID_ARG);
 6895:            mDocShell->SetAllowMetaRedirects(!!aValue);
    1:         }
    1:         break;
    1:     case nsIWebBrowserSetup::SETUP_ALLOW_SUBFRAMES:
    1:         {
    1:            NS_ENSURE_STATE(mDocShell);
    1:            NS_ENSURE_TRUE((aValue == PR_TRUE || aValue == PR_FALSE), NS_ERROR_INVALID_ARG);
 6895:            mDocShell->SetAllowSubframes(!!aValue);
    1:         }
    1:         break;
    1:     case nsIWebBrowserSetup::SETUP_ALLOW_IMAGES:
    1:         {
    1:            NS_ENSURE_STATE(mDocShell);
    1:            NS_ENSURE_TRUE((aValue == PR_TRUE || aValue == PR_FALSE), NS_ERROR_INVALID_ARG);
 6895:            mDocShell->SetAllowImages(!!aValue);
    1:         }
    1:         break;
28460:     case nsIWebBrowserSetup::SETUP_ALLOW_DNS_PREFETCH:
28460:         {
28460:             NS_ENSURE_STATE(mDocShell);
28460:             NS_ENSURE_TRUE((aValue == PR_TRUE || aValue == PR_FALSE), NS_ERROR_INVALID_ARG);
28460:             mDocShell->SetAllowDNSPrefetch(!!aValue);
28460:         }
    1:     case nsIWebBrowserSetup::SETUP_USE_GLOBAL_HISTORY:
    1:         {
    1:            NS_ENSURE_STATE(mDocShell);
    1:            NS_ENSURE_TRUE((aValue == PR_TRUE || aValue == PR_FALSE), NS_ERROR_INVALID_ARG);
 6895:            rv = EnableGlobalHistory(!!aValue);
    1:            mShouldEnableHistory = aValue;
    1:         }
    1:         break;
    1:     case nsIWebBrowserSetup::SETUP_FOCUS_DOC_BEFORE_CONTENT:
    1:         {
    1:             // obsolete
    1:         }
    1:         break;
    1:     case nsIWebBrowserSetup::SETUP_IS_CHROME_WRAPPER:
    1:         {
    1:            NS_ENSURE_TRUE((aValue == PR_TRUE || aValue == PR_FALSE), NS_ERROR_INVALID_ARG);
    1:            SetItemType(aValue ? typeChromeWrapper : typeContentWrapper);
    1:         }
    1:         break;
    1:     default:
    1:         rv = NS_ERROR_INVALID_ARG;
    1:   
    1:     }
    1:     return rv;
    1: }
    1: 
    1: 
    1: //*****************************************************************************
    1: // nsWebBrowser::nsIWebProgressListener
    1: //*****************************************************************************
    1: 
    1: /* void onStateChange (in nsIWebProgress aWebProgress, in nsIRequest aRequest, in unsigned long aStateFlags, in nsresult aStatus); */
    1: NS_IMETHODIMP nsWebBrowser::OnStateChange(nsIWebProgress *aWebProgress, nsIRequest *aRequest, PRUint32 aStateFlags, nsresult aStatus)
    1: {
    1:     if (mPersist)
    1:     {
    1:         mPersist->GetCurrentState(&mPersistCurrentState);
    1:     }
    1:     if (aStateFlags & STATE_IS_NETWORK && aStateFlags & STATE_STOP)
    1:     {
    1:         mPersist = nsnull;
    1:     }
    1:     if (mProgressListener)
    1:     {
    1:         return mProgressListener->OnStateChange(aWebProgress, aRequest, aStateFlags, aStatus);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: /* void onProgressChange (in nsIWebProgress aWebProgress, in nsIRequest aRequest, in long aCurSelfProgress, in long aMaxSelfProgress, in long aCurTotalProgress, in long aMaxTotalProgress); */
    1: NS_IMETHODIMP nsWebBrowser::OnProgressChange(nsIWebProgress *aWebProgress, nsIRequest *aRequest, PRInt32 aCurSelfProgress, PRInt32 aMaxSelfProgress, PRInt32 aCurTotalProgress, PRInt32 aMaxTotalProgress)
    1: {
    1:     if (mPersist)
    1:     {
    1:         mPersist->GetCurrentState(&mPersistCurrentState);
    1:     }
    1:     if (mProgressListener)
    1:     {
    1:         return mProgressListener->OnProgressChange(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: /* void onLocationChange (in nsIWebProgress aWebProgress, in nsIRequest aRequest, in nsIURI location); */
    1: NS_IMETHODIMP nsWebBrowser::OnLocationChange(nsIWebProgress *aWebProgress, nsIRequest *aRequest, nsIURI *location)
    1: {
    1:     if (mProgressListener)
    1:     {
    1:         return mProgressListener->OnLocationChange(aWebProgress, aRequest, location);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: /* void onStatusChange (in nsIWebProgress aWebProgress, in nsIRequest aRequest, in nsresult aStatus, in wstring aMessage); */
    1: NS_IMETHODIMP nsWebBrowser::OnStatusChange(nsIWebProgress *aWebProgress, nsIRequest *aRequest, nsresult aStatus, const PRUnichar *aMessage)
    1: {
    1:     if (mProgressListener)
    1:     {
    1:         return mProgressListener->OnStatusChange(aWebProgress, aRequest, aStatus, aMessage);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: /* void onSecurityChange (in nsIWebProgress aWebProgress, in nsIRequest aRequest, in unsigned long state); */
    1: NS_IMETHODIMP nsWebBrowser::OnSecurityChange(nsIWebProgress *aWebProgress, nsIRequest *aRequest, PRUint32 state)
    1: {
    1:     if (mProgressListener)
    1:     {
    1:         return mProgressListener->OnSecurityChange(aWebProgress, aRequest, state);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsWebBrowser::nsIWebBrowserPersist
    1: //*****************************************************************************
    1: 
    1: /* attribute unsigned long persistFlags; */
    1: NS_IMETHODIMP nsWebBrowser::GetPersistFlags(PRUint32 *aPersistFlags)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aPersistFlags);
    1:     nsresult rv = NS_OK;
    1:     if (mPersist)
    1:     {
    1:         rv = mPersist->GetPersistFlags(&mPersistFlags);
    1:     }
    1:     *aPersistFlags = mPersistFlags;
    1:     return rv;
    1: }
    1: NS_IMETHODIMP nsWebBrowser::SetPersistFlags(PRUint32 aPersistFlags)
    1: {
    1:     nsresult rv = NS_OK;
    1:     mPersistFlags = aPersistFlags;
    1:     if (mPersist)
    1:     {
    1:         rv = mPersist->SetPersistFlags(mPersistFlags);
    1:         mPersist->GetPersistFlags(&mPersistFlags);
    1:     }
    1:     return rv;
    1: }
    1: 
    1: 
    1: /* readonly attribute unsigned long currentState; */
    1: NS_IMETHODIMP nsWebBrowser::GetCurrentState(PRUint32 *aCurrentState)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCurrentState);
    1:     if (mPersist)
    1:     {
    1:         mPersist->GetCurrentState(&mPersistCurrentState);
    1:     }
    1:     *aCurrentState = mPersistCurrentState;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute unsigned long result; */
    1: NS_IMETHODIMP nsWebBrowser::GetResult(PRUint32 *aResult)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aResult);
    1:     if (mPersist)
    1:     {
    1:         mPersist->GetResult(&mPersistResult);
    1:     }
    1:     *aResult = mPersistResult;
    1:     return NS_OK;
    1: }
    1: 
    1: /* attribute nsIWebBrowserPersistProgress progressListener; */
    1: NS_IMETHODIMP nsWebBrowser::GetProgressListener(nsIWebProgressListener * *aProgressListener)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aProgressListener);
    1:     *aProgressListener = mProgressListener;
    1:     NS_IF_ADDREF(*aProgressListener);
    1:     return NS_OK;
    1: }
    1:   
    1: NS_IMETHODIMP nsWebBrowser::SetProgressListener(nsIWebProgressListener * aProgressListener)
    1: {
    1:     mProgressListener = aProgressListener;
    1:     return NS_OK;
    1: }
    1: 
    1: /* void saveURI (in nsIURI aURI, in nsIURI aReferrer,
    1:    in nsISupports aCacheKey, in nsIInputStream aPostData, in wstring aExtraHeaders,
    1:    in nsISupports aFile); */
    1: NS_IMETHODIMP nsWebBrowser::SaveURI(
    1:     nsIURI *aURI, nsISupports *aCacheKey, nsIURI *aReferrer, nsIInputStream *aPostData,
    1:     const char *aExtraHeaders, nsISupports *aFile)
    1: {
    1:     if (mPersist)
    1:     {
    1:         PRUint32 currentState;
    1:         mPersist->GetCurrentState(&currentState);
    1:         if (currentState == PERSIST_STATE_FINISHED)
    1:         {
    1:             mPersist = nsnull;
    1:         }
    1:         else
    1:         {
    1:             // You can't save again until the last save has completed
    1:             return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1: 
    1:     nsCOMPtr<nsIURI> uri;
    1:     if (aURI)
    1:     {
    1:         uri = aURI;
    1:     }
    1:     else
    1:     {
    1:         nsresult rv = GetCurrentURI(getter_AddRefs(uri));
    1:         if (NS_FAILED(rv))
    1:         {
    1:             return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1: 
    1:     // Create a throwaway persistence object to do the work
    1:     nsresult rv;
    1:     mPersist = do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID, &rv);
30579:     NS_ENSURE_SUCCESS(rv, rv);
    1:     mPersist->SetProgressListener(this);
    1:     mPersist->SetPersistFlags(mPersistFlags);
    1:     mPersist->GetCurrentState(&mPersistCurrentState);
    1:     rv = mPersist->SaveURI(uri, aCacheKey, aReferrer, aPostData, aExtraHeaders, aFile);
    1:     if (NS_FAILED(rv))
    1:     {
    1:         mPersist = nsnull;
    1:     }
    1:     return rv;
    1: }
    1: 
    1: /* void saveChannel (in nsIChannel aChannel, in nsISupports aFile); */
    1: NS_IMETHODIMP nsWebBrowser::SaveChannel(
    1:     nsIChannel* aChannel, nsISupports *aFile)
    1: {
    1:     if (mPersist)
    1:     {
    1:         PRUint32 currentState;
    1:         mPersist->GetCurrentState(&currentState);
    1:         if (currentState == PERSIST_STATE_FINISHED)
    1:         {
    1:             mPersist = nsnull;
    1:         }
    1:         else
    1:         {
    1:             // You can't save again until the last save has completed
    1:             return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1: 
    1:     // Create a throwaway persistence object to do the work
    1:     nsresult rv;
    1:     mPersist = do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID, &rv);
30579:     NS_ENSURE_SUCCESS(rv, rv);
    1:     mPersist->SetProgressListener(this);
    1:     mPersist->SetPersistFlags(mPersistFlags);
    1:     mPersist->GetCurrentState(&mPersistCurrentState);
    1:     rv = mPersist->SaveChannel(aChannel, aFile);
    1:     if (NS_FAILED(rv))
    1:     {
    1:         mPersist = nsnull;
    1:     }
    1:     return rv;
    1: }
    1: 
    1: /* void saveDocument (in nsIDOMDocument document, in nsISupports aFile, in nsISupports aDataPath); */
    1: NS_IMETHODIMP nsWebBrowser::SaveDocument(
    1:     nsIDOMDocument *aDocument, nsISupports *aFile, nsISupports *aDataPath,
    1:     const char *aOutputContentType, PRUint32 aEncodingFlags, PRUint32 aWrapColumn)
    1: {
    1:     if (mPersist)
    1:     {
    1:         PRUint32 currentState;
    1:         mPersist->GetCurrentState(&currentState);
    1:         if (currentState == PERSIST_STATE_FINISHED)
    1:         {
    1:             mPersist = nsnull;
    1:         }
    1:         else
    1:         {
    1:             // You can't save again until the last save has completed
    1:             return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1: 
    1:     // Use the specified DOM document, or if none is specified, the one
    1:     // attached to the web browser.
    1: 
    1:     nsCOMPtr<nsIDOMDocument> doc;
    1:     if (aDocument)
    1:     {
    1:         doc = do_QueryInterface(aDocument);
    1:     }
    1:     else
    1:     {
    1:         GetDocument(getter_AddRefs(doc));
    1:     }
    1:     if (!doc)
    1:     {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // Create a throwaway persistence object to do the work
    1:     nsresult rv;
    1:     mPersist = do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID, &rv);
30579:     NS_ENSURE_SUCCESS(rv, rv);
    1:     mPersist->SetProgressListener(this);
    1:     mPersist->SetPersistFlags(mPersistFlags);
    1:     mPersist->GetCurrentState(&mPersistCurrentState);
    1:     rv = mPersist->SaveDocument(doc, aFile, aDataPath, aOutputContentType, aEncodingFlags, aWrapColumn);
    1:     if (NS_FAILED(rv))
    1:     {
    1:         mPersist = nsnull;
    1:     }
    1:     return rv;
    1: }
    1: 
    1: /* void cancelSave(); */
    1: NS_IMETHODIMP nsWebBrowser::CancelSave()
    1: {
    1:     if (mPersist)
    1:     {
    1:         return mPersist->CancelSave();
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: /* void cancel(nsresult aReason); */
    1: NS_IMETHODIMP nsWebBrowser::Cancel(nsresult aReason)
    1: {
    1:     if (mPersist)
    1:     {
    1:         return mPersist->Cancel(aReason);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: 
    1: //*****************************************************************************
    1: // nsWebBrowser::nsIBaseWindow
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP nsWebBrowser::InitWindow(nativeWindow aParentNativeWindow,
    1:    nsIWidget* aParentWidget, PRInt32 aX, PRInt32 aY, PRInt32 aCX, PRInt32 aCY)   
    1: {
    1:    NS_ENSURE_ARG(aParentNativeWindow || aParentWidget);
    1:    NS_ENSURE_STATE(!mDocShell || mInitInfo);
    1: 
    1:    if(aParentWidget)
    1:       NS_ENSURE_SUCCESS(SetParentWidget(aParentWidget), NS_ERROR_FAILURE);
    1:    else
    1:       NS_ENSURE_SUCCESS(SetParentNativeWindow(aParentNativeWindow),
    1:          NS_ERROR_FAILURE);
    1: 
    1:    NS_ENSURE_SUCCESS(SetPositionAndSize(aX, aY, aCX, aCY, PR_FALSE),
    1:       NS_ERROR_FAILURE);
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::Create()
    1: {
    1:    NS_ENSURE_STATE(!mDocShell && (mParentNativeWindow || mParentWidget));
    1: 
30579:     nsresult rv = EnsureDocShellTreeOwner();
30579:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:    nsCOMPtr<nsIWidget> docShellParentWidget(mParentWidget);
    1:    if(!mParentWidget) // We need to create a widget
    1:       {
    1:       // Create the widget
30579:         mInternalWidget = do_CreateInstance(kChildCID, &rv);
30579:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       docShellParentWidget = mInternalWidget;
    1:       nsWidgetInitData  widgetInit;
    1: 
    1:       widgetInit.clipChildren = PR_TRUE;
    1:       widgetInit.mContentType = (mContentType == typeChrome || 
    1:         mContentType == typeChromeWrapper)? eContentTypeUI: eContentTypeContent;
    1: 
    1:       widgetInit.mWindowType = eWindowType_child;
23738:       nsIntRect bounds(mInitInfo->x, mInitInfo->y, mInitInfo->cx, mInitInfo->cy);
    1:       
 3233:       mInternalWidget->SetClientData(static_cast<nsWebBrowser *>(this));
33013:       mInternalWidget->Create(nsnull, mParentNativeWindow, bounds, nsWebBrowser::HandleEvent,
    1:                               nsnull, nsnull, nsnull, &widgetInit);  
    1:       }
    1: 
30579:     nsCOMPtr<nsIDocShell> docShell(do_CreateInstance("@mozilla.org/docshell;1", &rv));
30579:     NS_ENSURE_SUCCESS(rv, rv);
30579:     rv = SetDocShell(docShell);
30579:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:    // get the system default window background colour
    1:    {
    1:       nsCOMPtr<nsILookAndFeel> laf = do_GetService(kLookAndFeelCID);
30579:         if (laf)
    1:       laf->GetColor(nsILookAndFeel::eColor_WindowBackground, mBackgroundColor);
    1:    }
    1: 
    1:    // the docshell has been set so we now have our listener registrars.
    1:    if (mListenerArray) {
    1:       // we had queued up some listeners, let's register them now.
25498:       PRUint32 count = mListenerArray->Length();
25498:       PRUint32 i = 0;
    1:       NS_ASSERTION(count > 0, "array construction problem");
    1:       while (i < count) {
25498:           nsWebBrowserListenerState *state = mListenerArray->ElementAt(i);
    1:           NS_ASSERTION(state, "array construction problem");
    1:           nsCOMPtr<nsISupports> listener = do_QueryReferent(state->mWeakPtr);
    1:           NS_ASSERTION(listener, "bad listener");
    1:           (void)BindListener(listener, state->mID);
    1:           i++;
    1:       }
25498:       for (PRUint32 i = 0, end = mListenerArray->Length(); i < end; i++) {
25498:          nsWebBrowserListenerState *state = mListenerArray->ElementAt(i);
25498:          NS_DELETEXPCOM(state);
25498:       }
    1:       NS_DELETEXPCOM(mListenerArray);
    1:       mListenerArray = nsnull;
    1:    }
    1: 
    1:    // HACK ALERT - this registration registers the nsDocShellTreeOwner as a 
24693:    // nsIWebBrowserListener so it can setup its MouseListener in one of the 
    1:    // progress callbacks. If we can register the MouseListener another way, this 
    1:    // registration can go away, and nsDocShellTreeOwner can stop implementing
    1:    // nsIWebProgressListener.
    1:    nsCOMPtr<nsISupports> supports = nsnull;
    1:    (void)mDocShellTreeOwner->QueryInterface(NS_GET_IID(nsIWebProgressListener),
 3233:                              static_cast<void**>(getter_AddRefs(supports)));
    1:    (void)BindListener(supports, NS_GET_IID(nsIWebProgressListener));
    1: 
    1:    NS_ENSURE_SUCCESS(mDocShellAsWin->InitWindow(nsnull,
    1:       docShellParentWidget, mInitInfo->x, mInitInfo->y, mInitInfo->cx,
    1:       mInitInfo->cy), NS_ERROR_FAILURE);
    1: 
    1:    mDocShellAsItem->SetName(mInitInfo->name.get());
    1:    if (mContentType == typeChromeWrapper)
    1:    {
    1:        mDocShellAsItem->SetItemType(nsIDocShellTreeItem::typeChrome);
    1:    }
    1:    else
    1:    {
    1:        mDocShellAsItem->SetItemType(nsIDocShellTreeItem::typeContent);
    1:    }
    1:    mDocShellAsItem->SetTreeOwner(mDocShellTreeOwner);
    1:    
    1:    // If the webbrowser is a content docshell item then we won't hear any
    1:    // events from subframes. To solve that we install our own chrome event handler
    1:    // that always gets called (even for subframes) for any bubbling event.
    1: 
30579:     if (!mInitInfo->sessionHistory) {
30579:         mInitInfo->sessionHistory = do_CreateInstance(NS_SHISTORY_CONTRACTID, &rv);
30579:         NS_ENSURE_SUCCESS(rv, rv);
30579:     }
    1:    mDocShellAsNav->SetSessionHistory(mInitInfo->sessionHistory);
    1:    
    1:    // Hook up global history. Do not fail if we can't - just warn.
30579:     rv = EnableGlobalHistory(mShouldEnableHistory);
    1:    NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "EnableGlobalHistory() failed");
    1: 
    1:    NS_ENSURE_SUCCESS(mDocShellAsWin->Create(), NS_ERROR_FAILURE);
    1: 
30579:     // Hook into the OnSecurityChange() notification for lock/unlock icon
    1:    // updates
    1:    nsCOMPtr<nsIDOMWindow> domWindow;
    1:    rv = GetContentDOMWindow(getter_AddRefs(domWindow));
    1:    if (NS_SUCCEEDED(rv))
    1:    {
    1:        // this works because the implementation of nsISecureBrowserUI
    1:        // (nsSecureBrowserUIImpl) gets a docShell from the domWindow,
    1:        // and calls docShell->SetSecurityUI(this);
    1:        nsCOMPtr<nsISecureBrowserUI> securityUI =
    1:            do_CreateInstance(NS_SECURE_BROWSER_UI_CONTRACTID, &rv);
30579:         if (NS_SUCCEEDED(rv))
30579:             securityUI->Init(domWindow);
    1:    }
    1: 
    1:    mDocShellTreeOwner->AddToWatcher(); // evil twin of Remove in SetDocShell(0)
    1:    mDocShellTreeOwner->AddChromeListeners();
    1: 
    1:    delete mInitInfo;
    1:    mInitInfo = nsnull;
    1: 
    1:    return NS_OK; 
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::Destroy()
    1: {
    1:    InternalDestroy();
    1: 
    1:    if(!mInitInfo)
    1:       mInitInfo = new nsWebBrowserInitInfo();
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetPosition(PRInt32 aX, PRInt32 aY)
    1: {
    1:    PRInt32 cx = 0;
    1:    PRInt32 cy = 0;
    1: 
    1:    GetSize(&cx, &cy);
    1: 
    1:    return SetPositionAndSize(aX, aY, cx, cy, PR_FALSE);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetPosition(PRInt32* aX, PRInt32* aY)
    1: {
    1:    return GetPositionAndSize(aX, aY, nsnull, nsnull);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetSize(PRInt32 aCX, PRInt32 aCY, PRBool aRepaint)
    1: {
    1:    PRInt32 x = 0;
    1:    PRInt32 y = 0;
    1: 
    1:    GetPosition(&x, &y);
    1: 
    1:    return SetPositionAndSize(x, y, aCX, aCY, aRepaint);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetSize(PRInt32* aCX, PRInt32* aCY)
    1: {
    1:    return GetPositionAndSize(nsnull, nsnull, aCX, aCY);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetPositionAndSize(PRInt32 aX, PRInt32 aY,
    1:    PRInt32 aCX, PRInt32 aCY, PRBool aRepaint)
    1: {
    1:    if(!mDocShell)
    1:       {
    1:       mInitInfo->x = aX;
    1:       mInitInfo->y = aY;
    1:       mInitInfo->cx = aCX;
    1:       mInitInfo->cy = aCY;
    1:       }
    1:    else
    1:       {
    1:       PRInt32 doc_x = aX;
    1:       PRInt32 doc_y = aY;
    1: 
    1:       // If there is an internal widget we need to make the docShell coordinates
    1:       // relative to the internal widget rather than the calling app's parent.
    1:       // We also need to resize our widget then.
    1:       if(mInternalWidget)
    1:          {
    1:          doc_x = doc_y = 0;
    1:          NS_ENSURE_SUCCESS(mInternalWidget->Resize(aX, aY, aCX, aCY, aRepaint),
    1:             NS_ERROR_FAILURE);
    1:          }
    1:       // Now reposition/ resize the doc
    1:       NS_ENSURE_SUCCESS(mDocShellAsWin->SetPositionAndSize(doc_x, doc_y, aCX, aCY, 
    1:          aRepaint), NS_ERROR_FAILURE);
    1:       }
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetPositionAndSize(PRInt32* aX, PRInt32* aY, 
    1:    PRInt32* aCX, PRInt32* aCY)
    1: {
    1:    if(!mDocShell)
    1:       {
    1:       if(aX)
    1:          *aX = mInitInfo->x;
    1:       if(aY)
    1:          *aY = mInitInfo->y;
    1:       if(aCX)
    1:          *aCX = mInitInfo->cx;
    1:       if(aCY)
    1:          *aCY = mInitInfo->cy;
    1:       }
    1:    else
    1:       {
    1:       if(mInternalWidget)
    1:          {
23738:          nsIntRect bounds;
    1:          NS_ENSURE_SUCCESS(mInternalWidget->GetBounds(bounds), NS_ERROR_FAILURE);
    1: 
    1:          if(aX)
    1:             *aX = bounds.x;
    1:          if(aY)
    1:             *aY = bounds.y;
    1:          if(aCX)
    1:             *aCX = bounds.width;
    1:          if(aCY)
    1:             *aCY = bounds.height;
    1:          return NS_OK;
    1:          }
    1:       else
    1:          return mDocShellAsWin->GetPositionAndSize(aX, aY, aCX, aCY); // Can directly return this as it is the
    1:       }
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::Repaint(PRBool aForce)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1:    return mDocShellAsWin->Repaint(aForce); // Can directly return this as it is the
    1: }                                     // same interface, thus same returns.
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetParentWidget(nsIWidget** aParentWidget)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aParentWidget);
    1: 
    1:    *aParentWidget = mParentWidget;
    1: 
    1:    NS_IF_ADDREF(*aParentWidget);
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetParentWidget(nsIWidget* aParentWidget)
    1: {
    1:    NS_ENSURE_STATE(!mDocShell);
    1: 
    1:    mParentWidget = aParentWidget;
    1:    if(mParentWidget)
    1:       mParentNativeWindow = mParentWidget->GetNativeData(NS_NATIVE_WIDGET);
    1:    else
    1:       mParentNativeWindow = nsnull;
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetParentNativeWindow(nativeWindow* aParentNativeWindow)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aParentNativeWindow);
    1:    
    1:    *aParentNativeWindow = mParentNativeWindow;
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetParentNativeWindow(nativeWindow aParentNativeWindow)
    1: {
    1:    NS_ENSURE_STATE(!mDocShell);
    1: 
    1:    mParentNativeWindow = aParentNativeWindow;
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetVisibility(PRBool* visibility)
    1: {
    1:    NS_ENSURE_ARG_POINTER(visibility);
    1: 
    1:    if(!mDocShell)
    1:       *visibility = mInitInfo->visible;
    1:    else
    1:       NS_ENSURE_SUCCESS(mDocShellAsWin->GetVisibility(visibility), NS_ERROR_FAILURE);
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetVisibility(PRBool aVisibility)
    1: {
    1:    if(!mDocShell)
    1:       mInitInfo->visible = aVisibility;
    1:    else
    1:       {
    1:       NS_ENSURE_SUCCESS(mDocShellAsWin->SetVisibility(aVisibility), NS_ERROR_FAILURE);
    1:       if(mInternalWidget)
    1:          mInternalWidget->Show(aVisibility);
    1:       }
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetEnabled(PRBool *aEnabled)
    1: {
    1:   if (mInternalWidget)
    1:     return mInternalWidget->IsEnabled(aEnabled);
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetEnabled(PRBool aEnabled)
    1: {
    1:   if (mInternalWidget)
    1:     return mInternalWidget->Enable(aEnabled);
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebBrowser::GetBlurSuppression(PRBool *aBlurSuppression)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aBlurSuppression);
    1:   *aBlurSuppression = PR_FALSE;
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebBrowser::SetBlurSuppression(PRBool aBlurSuppression)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetMainWidget(nsIWidget** mainWidget)
    1: {
    1:    NS_ENSURE_ARG_POINTER(mainWidget);
    1: 
    1:    if(mInternalWidget)
    1:       *mainWidget = mInternalWidget;
    1:    else
    1:       *mainWidget = mParentWidget;
    1: 
    1:    NS_IF_ADDREF(*mainWidget);
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetFocus()
    1: {
29018:   nsCOMPtr<nsIDOMWindow> window = do_GetInterface(mDocShell);
29018:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
    1: 
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   return fm ? fm->SetFocusedWindow(window) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetTitle(PRUnichar** aTitle)
    1: {
    1:    NS_ENSURE_ARG_POINTER(aTitle);
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    NS_ENSURE_SUCCESS(mDocShellAsWin->GetTitle(aTitle), NS_ERROR_FAILURE);
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetTitle(const PRUnichar* aTitle)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    NS_ENSURE_SUCCESS(mDocShellAsWin->SetTitle(aTitle), NS_ERROR_FAILURE);
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsWebBrowser::nsIScrollable
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetCurScrollPos(PRInt32 aScrollOrientation, 
    1:    PRInt32* aCurPos)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsScrollable->GetCurScrollPos(aScrollOrientation, aCurPos);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetCurScrollPos(PRInt32 aScrollOrientation, 
    1:    PRInt32 aCurPos)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsScrollable->SetCurScrollPos(aScrollOrientation, aCurPos);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetCurScrollPosEx(PRInt32 aCurHorizontalPos, 
    1:    PRInt32 aCurVerticalPos)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsScrollable->SetCurScrollPosEx(aCurHorizontalPos, 
    1:       aCurVerticalPos);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetScrollRange(PRInt32 aScrollOrientation,
    1:    PRInt32* aMinPos, PRInt32* aMaxPos)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsScrollable->GetScrollRange(aScrollOrientation, aMinPos,
    1:       aMaxPos);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetScrollRange(PRInt32 aScrollOrientation,
    1:    PRInt32 aMinPos, PRInt32 aMaxPos)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsScrollable->SetScrollRange(aScrollOrientation, aMinPos,
    1:       aMaxPos);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetScrollRangeEx(PRInt32 aMinHorizontalPos,
    1:    PRInt32 aMaxHorizontalPos, PRInt32 aMinVerticalPos, PRInt32 aMaxVerticalPos)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsScrollable->SetScrollRangeEx(aMinHorizontalPos,
    1:       aMaxHorizontalPos, aMinVerticalPos, aMaxVerticalPos);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetDefaultScrollbarPreferences(PRInt32 aScrollOrientation,
    1:    PRInt32* aScrollbarPref)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsScrollable->GetDefaultScrollbarPreferences(aScrollOrientation,
    1:       aScrollbarPref);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetDefaultScrollbarPreferences(PRInt32 aScrollOrientation,
    1:    PRInt32 aScrollbarPref)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsScrollable->SetDefaultScrollbarPreferences(aScrollOrientation,
    1:       aScrollbarPref);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetScrollbarVisibility(PRBool* aVerticalVisible,
    1:    PRBool* aHorizontalVisible)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsScrollable->GetScrollbarVisibility(aVerticalVisible,
    1:       aHorizontalVisible);
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsWebBrowser::nsITextScroll
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP nsWebBrowser::ScrollByLines(PRInt32 aNumLines)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsTextScroll->ScrollByLines(aNumLines);
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::ScrollByPages(PRInt32 aNumPages)
    1: {
    1:    NS_ENSURE_STATE(mDocShell);
    1: 
    1:    return mDocShellAsTextScroll->ScrollByPages(aNumPages);
    1: }
    1: 
    1: 
    1: //*****************************************************************************
    1: // nsWebBrowser: Listener Helpers
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetDocShell(nsIDocShell* aDocShell)
    1: {
38374:      nsCOMPtr<nsIDocShell> kungFuDeathGrip(mDocShell);
    1:      if(aDocShell)
    1:      {
    1:          NS_ENSURE_TRUE(!mDocShell, NS_ERROR_FAILURE);
    1:  
    1:          nsCOMPtr<nsIInterfaceRequestor> req(do_QueryInterface(aDocShell));
    1:          nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(aDocShell));
    1:          nsCOMPtr<nsIDocShellTreeItem> item(do_QueryInterface(aDocShell));
    1:          nsCOMPtr<nsIWebNavigation> nav(do_QueryInterface(aDocShell));
    1:          nsCOMPtr<nsIScrollable> scrollable(do_QueryInterface(aDocShell));
    1:          nsCOMPtr<nsITextScroll> textScroll(do_QueryInterface(aDocShell));
    1:          nsCOMPtr<nsIWebProgress> progress(do_GetInterface(aDocShell));
    1:          NS_ENSURE_TRUE(req && baseWin && item && nav && scrollable && textScroll && progress,
    1:              NS_ERROR_FAILURE);
    1:  
    1:          mDocShell = aDocShell;
    1:          mDocShellAsReq = req;
    1:          mDocShellAsWin = baseWin;
    1:          mDocShellAsItem = item;
    1:          mDocShellAsNav = nav;
    1:          mDocShellAsScrollable = scrollable;
    1:          mDocShellAsTextScroll = textScroll;
    1:          mWebProgress = progress;
28460: 
28460:          // By default, do not allow DNS prefetch, so we don't break our frozen
28460:          // API.  Embeddors who decide to enable it should do so manually.
28460:          mDocShell->SetAllowDNSPrefetch(PR_FALSE);
    1:      }
    1:      else
    1:      {
    1:          if (mDocShellTreeOwner)
    1:            mDocShellTreeOwner->RemoveFromWatcher(); // evil twin of Add in Create()
    1:          if (mDocShellAsWin)
    1:            mDocShellAsWin->Destroy();
    1: 
    1:          mDocShell = nsnull;
    1:          mDocShellAsReq = nsnull;
    1:          mDocShellAsWin = nsnull;
    1:          mDocShellAsItem = nsnull;
    1:          mDocShellAsNav = nsnull;
    1:          mDocShellAsScrollable = nsnull;
    1:          mDocShellAsTextScroll = nsnull;
    1:          mWebProgress = nsnull;
    1:      }
    1: 
    1:      return NS_OK; 
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::EnsureDocShellTreeOwner()
    1: {
    1:    if(mDocShellTreeOwner)
    1:       return NS_OK;
    1: 
    1:    mDocShellTreeOwner = new nsDocShellTreeOwner();
    1:    NS_ENSURE_TRUE(mDocShellTreeOwner, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:    NS_ADDREF(mDocShellTreeOwner);
    1:    mDocShellTreeOwner->WebBrowser(this);
    1:    
    1:    return NS_OK;
    1: }
    1: 
    1: /* static */
20261: nsEventStatus nsWebBrowser::HandleEvent(nsGUIEvent *aEvent)
    1: {
    1:   nsWebBrowser  *browser = nsnull;
    1:   void          *data = nsnull;
    1: 
    1:   if (!aEvent->widget)
13807:     return nsEventStatus_eIgnore;
    1: 
    1:   aEvent->widget->GetClientData(data);
    1:   if (!data)
13807:     return nsEventStatus_eIgnore;
    1: 
 3233:   browser = static_cast<nsWebBrowser *>(data);
    1: 
    1:   switch(aEvent->message) {
    1: 
    1:   case NS_PAINT: {
 3233:       nsPaintEvent *paintEvent = static_cast<nsPaintEvent *>(aEvent);
    1:       nsIRenderingContext *rc = paintEvent->renderingContext;
    1:       nscolor oldColor;
    1:       rc->GetColor(oldColor);
    1:       rc->SetColor(browser->mBackgroundColor);
    1:       
 8626:       nsCOMPtr<nsIDeviceContext> dx;
 8626:       rc->GetDeviceContext(*getter_AddRefs(dx));
 8626:       PRInt32 appUnitsPerDevPixel = dx->AppUnitsPerDevPixel();
 8626: 
    1:       nsIRegion *region = paintEvent->region;
    1:       if (region) {
    1:           nsRegionRectSet *rects = nsnull;
    1:           region->GetRects(&rects);
    1:           if (rects) {
    1:               for (PRUint32 i = 0; i < rects->mNumRects; ++i) {
 8626:                   nsRect r(rects->mRects[i].x*appUnitsPerDevPixel,
 8626:                            rects->mRects[i].y*appUnitsPerDevPixel,
 8626:                            rects->mRects[i].width*appUnitsPerDevPixel,
 8626:                            rects->mRects[i].height*appUnitsPerDevPixel);
    1:                   rc->FillRect(r);
    1:               }
    1: 
    1:               region->FreeRects(rects);
    1:           }
    1:       } else if (paintEvent->rect) {
 8626:           nsRect r(paintEvent->rect->x*appUnitsPerDevPixel,
 8626:                    paintEvent->rect->y*appUnitsPerDevPixel,
 8626:                    paintEvent->rect->width*appUnitsPerDevPixel,
 8626:                    paintEvent->rect->height*appUnitsPerDevPixel);
 8626:           rc->FillRect(r);
    1:       }
    1:       rc->SetColor(oldColor);
13807:       return nsEventStatus_eConsumeDoDefault;
    1:     }
    1: 
34604:   case NS_ACTIVATE: {
34604: #if defined(DEBUG_smaug)
34604:     nsCOMPtr<nsIDOMDocument> domDocument = do_GetInterface(browser->mDocShell);
34604:     nsAutoString documentURI;
34604:     if (domDocument) {
34604:       nsCOMPtr<nsIDOM3Document> d3 = do_QueryInterface(domDocument);
34604:       d3->GetDocumentURI(documentURI);
34604:     }
34604:     printf("nsWebBrowser::NS_ACTIVATE %p %s\n", (void*)browser,
34604:            NS_ConvertUTF16toUTF8(documentURI).get());
34604: #endif
34604:     browser->Activate();
34604:     break;
34604:   }
34604: 
34604:   case NS_DEACTIVATE: {
34604: #if defined(DEBUG_smaug)
34604:     nsCOMPtr<nsIDOMDocument> domDocument = do_GetInterface(browser->mDocShell);
34604:     nsAutoString documentURI;
34604:     if (domDocument) {
34604:       nsCOMPtr<nsIDOM3Document> d3 = do_QueryInterface(domDocument);
34604:       d3->GetDocumentURI(documentURI);
34604:     }
34604:     printf("nsWebBrowser::NS_DEACTIVATE %p %s\n", (void*)browser,
34604:            NS_ConvertUTF16toUTF8(documentURI).get());
34604: #endif
34604:     browser->Deactivate();
34604:     break;
34604:   }
34604: 
    1:   default:
    1:     break;
    1:   }
    1: 
13807:   return nsEventStatus_eIgnore;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::GetPrimaryContentWindow(nsIDOMWindowInternal **aDOMWindow)
    1: {
    1:   *aDOMWindow = 0;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> item;
    1:   NS_ENSURE_TRUE(mDocShellTreeOwner, NS_ERROR_FAILURE);
    1:   mDocShellTreeOwner->GetPrimaryContentShell(getter_AddRefs(item));
    1:   NS_ENSURE_TRUE(item, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDocShell> docShell;
    1:   docShell = do_QueryInterface(item);
    1:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
    1:   
    1:   nsCOMPtr<nsIDOMWindowInternal> domWindow;
    1:   domWindow = do_GetInterface(docShell);
    1:   NS_ENSURE_TRUE(domWindow, NS_ERROR_FAILURE);
    1: 
    1:   *aDOMWindow = domWindow;
    1:   NS_ADDREF(*aDOMWindow);
    1:   return NS_OK;
    1:   
    1: }
    1: //*****************************************************************************
    1: // nsWebBrowser::nsIWebBrowserFocus
    1: //*****************************************************************************   
    1: 
    1: /* void activate (); */
    1: NS_IMETHODIMP nsWebBrowser::Activate(void)
    1: {
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   nsCOMPtr<nsIDOMWindow> window = do_GetInterface(mDocShell);
29018:   if (fm && window)
29018:     return fm->WindowRaised(window);
    1:   return NS_OK;
    1: }
    1: 
    1: /* void deactivate (); */
    1: NS_IMETHODIMP nsWebBrowser::Deactivate(void)
    1: {
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   nsCOMPtr<nsIDOMWindow> window = do_GetInterface(mDocShell);
29018:   if (fm && window)
29018:     return fm->WindowLowered(window);
    1:   return NS_OK;
    1: }
    1: 
    1: /* void setFocusAtFirstElement (); */
    1: NS_IMETHODIMP nsWebBrowser::SetFocusAtFirstElement(void)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: /* void setFocusAtLastElement (); */
    1: NS_IMETHODIMP nsWebBrowser::SetFocusAtLastElement(void)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: /* attribute nsIDOMWindow focusedWindow; */
    1: NS_IMETHODIMP nsWebBrowser::GetFocusedWindow(nsIDOMWindow * *aFocusedWindow)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aFocusedWindow);
    1:   *aFocusedWindow = nsnull;
    1: 
29018:   nsCOMPtr<nsIDOMWindow> window = do_GetInterface(mDocShell);
29018:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
    1: 
29018:   nsCOMPtr<nsIDOMElement> focusedElement;
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   return fm ? fm->GetFocusedElementForWindow(window, PR_TRUE, aFocusedWindow,
29018:                                              getter_AddRefs(focusedElement)) : NS_OK;
29018: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetFocusedWindow(nsIDOMWindow * aFocusedWindow)
    1: {
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   return fm ? fm->SetFocusedWindow(aFocusedWindow) : NS_OK;
    1: }
    1: 
    1: /* attribute nsIDOMElement focusedElement; */
    1: NS_IMETHODIMP nsWebBrowser::GetFocusedElement(nsIDOMElement * *aFocusedElement)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aFocusedElement);
    1: 
29018:   nsCOMPtr<nsIDOMWindow> window = do_GetInterface(mDocShell);
29018:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
    1: 
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   return fm ? fm->GetFocusedElementForWindow(window, PR_TRUE, nsnull, aFocusedElement) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWebBrowser::SetFocusedElement(nsIDOMElement * aFocusedElement)
    1: {
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   return fm ? fm->SetFocus(aFocusedElement, 0) : NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsWebBrowser::nsIWebBrowserStream
    1: //*****************************************************************************   
    1: 
    1: /* void openStream(in nsIURI aBaseURI, in ACString aContentType); */
    1: NS_IMETHODIMP nsWebBrowser::OpenStream(nsIURI *aBaseURI, const nsACString& aContentType)
    1: {
    1:   nsresult rv;
    1: 
    1:   if (!mStream) {
    1:     mStream = new nsEmbedStream();
30579:         if (!mStream)
30579:              return NS_ERROR_OUT_OF_MEMORY;
30579: 
    1:     mStreamGuard = do_QueryInterface(mStream);
    1:     mStream->InitOwner(this);
    1:     rv = mStream->Init();
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:   }
    1: 
    1:   return mStream->OpenStream(aBaseURI, aContentType);
    1: }
    1: 
    1: /* void appendToStream([const, array, size_is(aLen)] in octet aData,
    1:  * in unsigned long aLen); */
    1: NS_IMETHODIMP nsWebBrowser::AppendToStream(const PRUint8 *aData, PRUint32 aLen)
    1: {
    1:   if (!mStream)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mStream->AppendToStream(aData, aLen);
    1: }
    1: 
    1: /* void closeStream (); */
    1: NS_IMETHODIMP nsWebBrowser::CloseStream()
    1: {
    1:   nsresult rv;
    1: 
    1:   if (!mStream)
    1:     return NS_ERROR_FAILURE;
    1:   rv = mStream->CloseStream();
    1: 
    1:   // release
    1:   mStream = 0;
    1:   mStreamGuard = 0;
    1: 
    1:   return rv;
    1: }
