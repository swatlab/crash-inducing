39206: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
39206:  * ***** BEGIN LICENSE BLOCK *****
39206:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
39206:  *
39206:  * The contents of this file are subject to the Mozilla Public License Version
39206:  * 1.1 (the "License"); you may not use this file except in compliance with
39206:  * the License. You may obtain a copy of the License at
39206:  * http://www.mozilla.org/MPL/
39206:  *
39206:  * Software distributed under the License is distributed on an "AS IS" basis,
39206:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
39206:  * for the specific language governing rights and limitations under the
39206:  * License.
39206:  *
39206:  * The Original Code is Mozilla Corporation code.
39206:  *
39206:  * The Initial Developer of the Original Code is Mozilla Foundation.
39206:  * Portions created by the Initial Developer are Copyright (C) 2006-2010
39206:  * the Initial Developer. All Rights Reserved.
39206:  *
39206:  * Contributor(s):
39206:  *   Vladimir Vukicevic <vladimir@pobox.com>
39206:  *   Masayuki Nakano <masayuki@d-toybox.com>
39206:  *   John Daggett <jdaggett@mozilla.com>
39206:  *   Jonathan Kew <jfkthame@gmail.com>
39206:  *
39206:  * Alternatively, the contents of this file may be used under the terms of
39206:  * either the GNU General Public License Version 2 or later (the "GPL"), or
39206:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
39206:  * in which case the provisions of the GPL or the LGPL are applicable instead
39206:  * of those above. If you wish to allow use of your version of this file only
39206:  * under the terms of either the GPL or the LGPL, and not to allow others to
39206:  * use your version of this file under the terms of the MPL, indicate your
39206:  * decision by deleting the provisions above and replace them with the notice
39206:  * and other provisions required by the GPL or the LGPL. If you do not delete
39206:  * the provisions above, a recipient may use your version of this file under
39206:  * the terms of any one of the MPL, the GPL or the LGPL.
39206:  *
39206:  * ***** END LICENSE BLOCK ***** */
39206: 
39206: #include "gfxMacFont.h"
39206: #include "gfxCoreTextShaper.h"
43527: #include "gfxHarfBuzzShaper.h"
39206: #include "gfxPlatformMac.h"
39206: #include "gfxContext.h"
48069: #include "gfxUnicodeProperties.h"
48915: #include "gfxFontUtils.h"
39206: 
39206: #include "cairo-quartz.h"
39206: 
48915: using namespace mozilla;
48915: 
39206: gfxMacFont::gfxMacFont(MacOSFontEntry *aFontEntry, const gfxFontStyle *aFontStyle,
39206:                        PRBool aNeedsBold)
39206:     : gfxFont(aFontEntry, aFontStyle),
43526:       mCGFont(nsnull),
39206:       mFontFace(nsnull),
43527:       mScaledFont(nsnull)
39206: {
39307:     if (aNeedsBold) {
39206:         mSyntheticBoldOffset = 1;  // devunit offset when double-striking text to fake boldness
39206:     }
39206: 
72435:     mCGFont = aFontEntry->GetFontRef();
43526:     if (!mCGFont) {
43526:         mIsValid = PR_FALSE;
43526:         return;
43526:     }
43526: 
39206:     // InitMetrics will handle the sizeAdjust factor and set mAdjustedSize
39206:     InitMetrics();
43526:     if (!mIsValid) {
39206:         return;
43526:     }
39206: 
43526:     mFontFace = cairo_quartz_font_face_create_for_cgfont(mCGFont);
39206: 
39206:     cairo_status_t cairoerr = cairo_font_face_status(mFontFace);
39206:     if (cairoerr != CAIRO_STATUS_SUCCESS) {
39206:         mIsValid = PR_FALSE;
39206: #ifdef DEBUG
39206:         char warnBuf[1024];
39206:         sprintf(warnBuf, "Failed to create Cairo font face: %s status: %d",
39206:                 NS_ConvertUTF16toUTF8(GetName()).get(), cairoerr);
39206:         NS_WARNING(warnBuf);
39206: #endif
39206:         return;
39206:     }
39206: 
39206:     cairo_matrix_t sizeMatrix, ctm;
39206:     cairo_matrix_init_identity(&ctm);
39206:     cairo_matrix_init_scale(&sizeMatrix, mAdjustedSize, mAdjustedSize);
39206: 
39206:     // synthetic oblique by skewing via the font matrix
39206:     PRBool needsOblique =
39206:         (mFontEntry != NULL) &&
47309:         (!mFontEntry->IsItalic() &&
47309:          (mStyle.style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)));
39206: 
39206:     if (needsOblique) {
39206:         double skewfactor = (needsOblique ? Fix2X(kATSItalicQDSkew) : 0);
39206: 
39206:         cairo_matrix_t style;
39206:         cairo_matrix_init(&style,
39206:                           1,                //xx
39206:                           0,                //yx
39206:                           -1 * skewfactor,   //xy
39206:                           1,                //yy
39206:                           0,                //x0
39206:                           0);               //y0
39206:         cairo_matrix_multiply(&sizeMatrix, &sizeMatrix, &style);
39206:     }
39206: 
39206:     cairo_font_options_t *fontOptions = cairo_font_options_create();
39206: 
39206:     // turn off font anti-aliasing based on user pref setting
47309:     if (mAdjustedSize <=
47309:         (gfxFloat)gfxPlatformMac::GetPlatform()->GetAntiAliasingThreshold()) {
39206:         cairo_font_options_set_antialias(fontOptions, CAIRO_ANTIALIAS_NONE);
39206:     }
39206: 
47309:     mScaledFont = cairo_scaled_font_create(mFontFace, &sizeMatrix, &ctm,
47309:                                            fontOptions);
39206:     cairo_font_options_destroy(fontOptions);
39206: 
39206:     cairoerr = cairo_scaled_font_status(mScaledFont);
39206:     if (cairoerr != CAIRO_STATUS_SUCCESS) {
39206:         mIsValid = PR_FALSE;
39206: #ifdef DEBUG
39206:         char warnBuf[1024];
39206:         sprintf(warnBuf, "Failed to create scaled font: %s status: %d",
39206:                 NS_ConvertUTF16toUTF8(GetName()).get(), cairoerr);
39206:         NS_WARNING(warnBuf);
39206: #endif
39206:     }
39206: 
43527:     if (FontCanSupportHarfBuzz()) {
43527:         mHarfBuzzShaper = new gfxHarfBuzzShaper(this);
43527:     }
39206: }
39206: 
39206: gfxMacFont::~gfxMacFont()
39206: {
39206:     if (mScaledFont) {
39206:         cairo_scaled_font_destroy(mScaledFont);
39206:     }
39206:     if (mFontFace) {
39206:         cairo_font_face_destroy(mFontFace);
39206:     }
39206: }
39206: 
48069: PRBool
48069: gfxMacFont::InitTextRun(gfxContext *aContext,
48069:                         gfxTextRun *aTextRun,
48069:                         const PRUnichar *aString,
48069:                         PRUint32 aRunStart,
48069:                         PRUint32 aRunLength,
57397:                         PRInt32 aRunScript,
57397:                         PRBool aPreferPlatformShaping)
48069: {
48069:     if (!mIsValid) {
48069:         NS_WARNING("invalid font! expect incorrect text rendering");
48069:         return PR_FALSE;
48069:     }
48069: 
57397:     PRBool ok = gfxFont::InitTextRun(aContext, aTextRun, aString,
57397:                                      aRunStart, aRunLength, aRunScript,
57397:         static_cast<MacOSFontEntry*>(GetFontEntry())->RequiresAATLayout());
48069: 
54182:     aTextRun->AdjustAdvancesForSyntheticBold(aRunStart, aRunLength);
54182: 
48069:     return ok;
48069: }
48069: 
43527: void
43527: gfxMacFont::CreatePlatformShaper()
43527: {
43527:     mPlatformShaper = new gfxCoreTextShaper(this);
43527: }
43527: 
39206: PRBool
39206: gfxMacFont::SetupCairoFont(gfxContext *aContext)
39206: {
39206:     if (cairo_scaled_font_status(mScaledFont) != CAIRO_STATUS_SUCCESS) {
39206:         // Don't cairo_set_scaled_font as that would propagate the error to
39206:         // the cairo_t, precluding any further drawing.
39206:         return PR_FALSE;
39206:     }
39206:     cairo_set_scaled_font(aContext->GetCairo(), mScaledFont);
39206:     return PR_TRUE;
39206: }
39206: 
72201: gfxFont::RunMetrics
72201: gfxMacFont::Measure(gfxTextRun *aTextRun,
72201:                     PRUint32 aStart, PRUint32 aEnd,
72201:                     BoundingBoxType aBoundingBoxType,
72201:                     gfxContext *aRefContext,
72201:                     Spacing *aSpacing)
72201: {
72201:     gfxFont::RunMetrics metrics =
72201:         gfxFont::Measure(aTextRun, aStart, aEnd,
72201:                          aBoundingBoxType, aRefContext, aSpacing);
72201: 
72201:     // if aBoundingBoxType is not TIGHT_HINTED_OUTLINE_EXTENTS then we need to add
72201:     // a pixel column each side of the bounding box in case of antialiasing "bleed"
72201:     if (aBoundingBoxType != TIGHT_HINTED_OUTLINE_EXTENTS &&
72201:         metrics.mBoundingBox.width > 0) {
72201:         metrics.mBoundingBox.x -= aTextRun->GetAppUnitsPerDevUnit();
72201:         metrics.mBoundingBox.width += aTextRun->GetAppUnitsPerDevUnit() * 2;
72201:     }
72201: 
72201:     return metrics;
72201: }
72201: 
39206: void
39206: gfxMacFont::InitMetrics()
39206: {
47309:     mIsValid = PR_FALSE;
47309:     ::memset(&mMetrics, 0, sizeof(mMetrics));
47309: 
48915:     PRUint32 upem = 0;
48915: 
48915:     // try to get unitsPerEm from sfnt head table, to avoid calling CGFont
48915:     // if possible (bug 574368) and because CGFontGetUnitsPerEm does not
48915:     // return the true value for OpenType/CFF fonts (it normalizes to 1000,
48915:     // which then leads to metrics errors when we read the 'hmtx' table to
48915:     // get glyph advances for HarfBuzz, see bug 580863)
48915:     const PRUint32 kHeadTableTag = TRUETYPE_TAG('h','e','a','d');
60098:     AutoFallibleTArray<PRUint8,sizeof(HeadTable)> headData;
48915:     if (NS_SUCCEEDED(mFontEntry->GetFontTable(kHeadTableTag, headData)) &&
48915:         headData.Length() >= sizeof(HeadTable)) {
48915:         HeadTable *head = reinterpret_cast<HeadTable*>(headData.Elements());
48915:         upem = head->unitsPerEm;
48915:     } else {
48915:         upem = ::CGFontGetUnitsPerEm(mCGFont);
48915:     }
48915: 
48915:     if (upem < 16 || upem > 16384) {
48915:         // See http://www.microsoft.com/typography/otspec/head.htm
43526: #ifdef DEBUG
43526:         char warnBuf[1024];
48915:         sprintf(warnBuf, "Bad font metrics for: %s (invalid unitsPerEm value)",
43526:                 NS_ConvertUTF16toUTF8(mFontEntry->Name()).get());
43526:         NS_WARNING(warnBuf);
43526: #endif
43526:         return;
43526:     }
39206: 
71173:     mAdjustedSize = NS_MAX(mStyle.size, 1.0);
47309:     mFUnitsConvFactor = mAdjustedSize / upem;
39206: 
55074:     // For CFF fonts, when scaling values read from CGFont* APIs, we need to
55074:     // use CG's idea of unitsPerEm, which may differ from the "true" value in
55074:     // the head table of the font (see bug 580863)
55074:     gfxFloat cgConvFactor;
55074:     if (static_cast<MacOSFontEntry*>(mFontEntry.get())->IsCFF()) {
55074:         cgConvFactor = mAdjustedSize / ::CGFontGetUnitsPerEm(mCGFont);
55074:     } else {
55074:         cgConvFactor = mFUnitsConvFactor;
55074:     }
55074: 
47309:     // Try to read 'sfnt' metrics; for local, non-sfnt fonts ONLY, fall back to
47309:     // platform APIs. The InitMetrics...() functions will set mIsValid on success.
47309:     if (!InitMetricsFromSfntTables(mMetrics) &&
47309:         (!mFontEntry->IsUserFont() || mFontEntry->IsLocalUserFont())) {
72435:         InitMetricsFromPlatform();
47309:     }
47309:     if (!mIsValid) {
39206:         return;
39206:     }
39206: 
47309:     if (mMetrics.xHeight == 0.0) {
55074:         mMetrics.xHeight = ::CGFontGetXHeight(mCGFont) * cgConvFactor;
47309:     }
39206: 
47309:     if (mStyle.sizeAdjust != 0.0 && mStyle.size > 0.0 &&
47309:         mMetrics.xHeight > 0.0) {
47309:         // apply font-size-adjust, and recalculate metrics
47309:         gfxFloat aspect = mMetrics.xHeight / mStyle.size;
39206:         mAdjustedSize = mStyle.GetAdjustedSize(aspect);
47309:         mFUnitsConvFactor = mAdjustedSize / upem;
55074:         if (static_cast<MacOSFontEntry*>(mFontEntry.get())->IsCFF()) {
55074:             cgConvFactor = mAdjustedSize / ::CGFontGetUnitsPerEm(mCGFont);
55074:         } else {
55074:             cgConvFactor = mFUnitsConvFactor;
55074:         }
47309:         mMetrics.xHeight = 0.0;
47309:         if (!InitMetricsFromSfntTables(mMetrics) &&
47309:             (!mFontEntry->IsUserFont() || mFontEntry->IsLocalUserFont())) {
72435:             InitMetricsFromPlatform();
47309:         }
47309:         if (!mIsValid) {
47309:             // this shouldn't happen, as we succeeded earlier before applying
47309:             // the size-adjust factor! But check anyway, for paranoia's sake.
39206:             return;
39206:         }
47309:         if (mMetrics.xHeight == 0.0) {
55074:             mMetrics.xHeight = ::CGFontGetXHeight(mCGFont) * cgConvFactor;
47309:         }
39206:     }
39206: 
47309:     // Once we reach here, we've got basic metrics and set mIsValid = TRUE;
47309:     // there should be no further points of actual failure in InitMetrics().
47309:     // (If one is introduced, be sure to reset mIsValid to FALSE!)
39206: 
47309:     mMetrics.emHeight = mAdjustedSize;
39206: 
47309:     // Measure/calculate additional metrics, independent of whether we used
47309:     // the tables directly or ATS metrics APIs
39206: 
43526:     CFDataRef cmap =
43526:         ::CGFontCopyTableForTag(mCGFont, TRUETYPE_TAG('c','m','a','p'));
43526: 
39206:     PRUint32 glyphID;
47309:     if (mMetrics.aveCharWidth <= 0) {
55074:         mMetrics.aveCharWidth = GetCharWidth(cmap, 'x', &glyphID,
55074:                                              cgConvFactor);
47309:         if (glyphID == 0) {
47309:             // we didn't find 'x', so use maxAdvance rather than zero
39206:             mMetrics.aveCharWidth = mMetrics.maxAdvance;
47309:         }
47309:     }
39206:     mMetrics.aveCharWidth += mSyntheticBoldOffset;
47309:     mMetrics.maxAdvance += mSyntheticBoldOffset;
39206: 
55074:     mMetrics.spaceWidth = GetCharWidth(cmap, ' ', &glyphID, cgConvFactor);
47309:     if (glyphID == 0) {
47309:         // no space glyph?!
47309:         mMetrics.spaceWidth = mMetrics.aveCharWidth;
39206:     }
39206:     mSpaceGlyph = glyphID;
39206: 
55074:     mMetrics.zeroOrAveCharWidth = GetCharWidth(cmap, '0', &glyphID,
55074:                                                cgConvFactor);
47309:     if (glyphID == 0) {
39206:         mMetrics.zeroOrAveCharWidth = mMetrics.aveCharWidth;
47309:     }
39206: 
43526:     if (cmap) {
43526:         ::CFRelease(cmap);
43526:     }
39206: 
47309:     CalculateDerivedMetrics(mMetrics);
43527: 
39206:     SanitizeMetrics(&mMetrics, mFontEntry->mIsBadUnderlineFont);
39206: 
39206: #if 0
39206:     fprintf (stderr, "Font: %p (%s) size: %f\n", this,
39206:              NS_ConvertUTF16toUTF8(GetName()).get(), mStyle.size);
39206: //    fprintf (stderr, "    fbounds.origin.x %f y %f size.width %f height %f\n", fbounds.origin.x, fbounds.origin.y, fbounds.size.width, fbounds.size.height);
39206:     fprintf (stderr, "    emHeight: %f emAscent: %f emDescent: %f\n", mMetrics.emHeight, mMetrics.emAscent, mMetrics.emDescent);
39206:     fprintf (stderr, "    maxAscent: %f maxDescent: %f maxAdvance: %f\n", mMetrics.maxAscent, mMetrics.maxDescent, mMetrics.maxAdvance);
39206:     fprintf (stderr, "    internalLeading: %f externalLeading: %f\n", mMetrics.internalLeading, mMetrics.externalLeading);
39206:     fprintf (stderr, "    spaceWidth: %f aveCharWidth: %f xHeight: %f\n", mMetrics.spaceWidth, mMetrics.aveCharWidth, mMetrics.xHeight);
43527:     fprintf (stderr, "    uOff: %f uSize: %f stOff: %f stSize: %f supOff: %f subOff: %f\n", mMetrics.underlineOffset, mMetrics.underlineSize, mMetrics.strikeoutOffset, mMetrics.strikeoutSize, mMetrics.superscriptOffset, mMetrics.subscriptOffset);
39206: #endif
39206: }
39206: 
43526: gfxFloat
47309: gfxMacFont::GetCharWidth(CFDataRef aCmap, PRUnichar aUniChar,
55074:                          PRUint32 *aGlyphID, gfxFloat aConvFactor)
39206: {
43526:     CGGlyph glyph = 0;
43526:     
43526:     if (aCmap) {
43526:         glyph = gfxFontUtils::MapCharToGlyph(::CFDataGetBytePtr(aCmap),
43526:                                              ::CFDataGetLength(aCmap),
43526:                                              aUniChar);
39206:     }
39206: 
43526:     if (aGlyphID) {
43526:         *aGlyphID = glyph;
39206:     }
39206: 
43526:     if (glyph) {
43526:         int advance;
43526:         if (::CGFontGetGlyphAdvances(mCGFont, &glyph, 1, &advance)) {
55074:             return advance * aConvFactor;
43526:         }
39206:     }
39206: 
39206:     return 0;
39206: }
43526: 
43526: /*static*/ void
43526: gfxMacFont::DestroyBlobFunc(void* aUserData)
43526: {
43526:     ::CFRelease((CFDataRef)aUserData);
43526: }
43526: 
43526: hb_blob_t *
43526: gfxMacFont::GetFontTable(PRUint32 aTag)
43526: {
43526:     CFDataRef dataRef = ::CGFontCopyTableForTag(mCGFont, aTag);
43526:     if (dataRef) {
43526:         return hb_blob_create((const char*)::CFDataGetBytePtr(dataRef),
43526:                               ::CFDataGetLength(dataRef),
43526:                               HB_MEMORY_MODE_READONLY,
43526:                               DestroyBlobFunc, (void*)dataRef);
43526:     }
43526: 
55084:     if (mFontEntry->IsUserFont() && !mFontEntry->IsLocalUserFont()) {
55084:         // for downloaded fonts, there may be layout tables cached in the entry
55084:         // even though they're absent from the sanitized platform font
58944:         hb_blob_t *blob;
58944:         if (mFontEntry->GetExistingFontTable(aTag, &blob)) {
58944:             return blob;
58944:         }
55084:     }
55084: 
43526:     return nsnull;
43526: }
47309: 
72435: // Try to initialize font metrics via platform APIs (CG/CT),
47309: // and set mIsValid = TRUE on success.
47309: // We ONLY call this for local (platform) fonts that are not sfnt format;
72435: // for sfnts, including ALL downloadable fonts, we prefer to use
72435: // InitMetricsFromSfntTables and avoid platform APIs.
47309: void
72435: gfxMacFont::InitMetricsFromPlatform()
72435: {
72435:     if (gfxMacPlatformFontList::UseATSFontEntry()) {
72435:         ATSFontEntry *fe = static_cast<ATSFontEntry*>(GetFontEntry());
72435:         InitMetricsFromATSMetrics(fe->GetATSFontRef());
72435:         return;
72435:     }
72435: 
72435:     CTFontRef ctFont = ::CTFontCreateWithGraphicsFont(mCGFont,
72435:                                                       mAdjustedSize,
72435:                                                       NULL, NULL);
72435:     if (!ctFont) {
72435:         return;
72435:     }
72435: 
72435:     mMetrics.underlineOffset = ::CTFontGetUnderlinePosition(ctFont);
72435:     mMetrics.underlineSize = ::CTFontGetUnderlineThickness(ctFont);
72435: 
72435:     mMetrics.externalLeading = ::CTFontGetLeading(ctFont);
72435: 
72435:     mMetrics.maxAscent = ::CTFontGetAscent(ctFont);
72435:     mMetrics.maxDescent = ::CTFontGetDescent(ctFont);
72435: 
72435:     // this is not strictly correct, but neither CTFont nor CGFont seems to
72435:     // provide maxAdvance, unless we were to iterate over all the glyphs
72435:     // (which isn't worth the cost here)
72435:     CGRect r = ::CTFontGetBoundingBox(ctFont);
72435:     mMetrics.maxAdvance = r.size.width;
72435: 
72435:     // aveCharWidth is also not provided, so leave it at zero
72435:     // (fallback code in gfxMacFont::InitMetrics will then try measuring 'x');
72435:     // this could lead to less-than-"perfect" text field sizing when width is
72435:     // specified as a number of characters, and the font in use is a non-sfnt
72435:     // legacy font, but that's a sufficiently obscure edge case that we can
72435:     // ignore the potential discrepancy.
72435:     mMetrics.aveCharWidth = 0;
72435: 
72435:     mMetrics.xHeight = ::CTFontGetXHeight(ctFont);
72435: 
72435:     ::CFRelease(ctFont);
72435: 
72435:     mIsValid = PR_TRUE;
72435: }
72435: 
72435: // For OS X 10.5, try to initialize font metrics via ATS font metrics APIs,
72435: // and set mIsValid = TRUE on success.
72435: void
72435: gfxMacFont::InitMetricsFromATSMetrics(ATSFontRef aFontRef)
47309: {
47309:     ATSFontMetrics atsMetrics;
47309:     OSStatus err;
47309: 
72435:     err = ::ATSFontGetHorizontalMetrics(aFontRef, kATSOptionFlagsDefault,
47309:                                         &atsMetrics);
47309:     if (err != noErr) {
47309: #ifdef DEBUG
47309:         char warnBuf[1024];
47309:         sprintf(warnBuf, "Bad font metrics for: %s err: %8.8x",
47309:                 NS_ConvertUTF16toUTF8(mFontEntry->Name()).get(), PRUint32(err));
47309:         NS_WARNING(warnBuf);
47309: #endif
47309:         return;
47309:     }
47309: 
47309:     mMetrics.underlineOffset = atsMetrics.underlinePosition * mAdjustedSize;
47309:     mMetrics.underlineSize = atsMetrics.underlineThickness * mAdjustedSize;
47309: 
47309:     mMetrics.externalLeading = atsMetrics.leading * mAdjustedSize;
47309: 
47309:     mMetrics.maxAscent = atsMetrics.ascent * mAdjustedSize;
47309:     mMetrics.maxDescent = -atsMetrics.descent * mAdjustedSize;
47309: 
47309:     mMetrics.maxAdvance = atsMetrics.maxAdvanceWidth * mAdjustedSize;
47309:     mMetrics.aveCharWidth = atsMetrics.avgAdvanceWidth * mAdjustedSize;
47309:     mMetrics.xHeight = atsMetrics.xHeight * mAdjustedSize;
47309: 
47309:     mIsValid = PR_TRUE;
47309: }
