16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:  function: single-block PCM synthesis
31034:  last mod: $Id: synthesis.c 16227 2009-07-08 06:58:46Z xiphmont $
16295: 
16295:  ********************************************************************/
16295: 
16295: #include <stdio.h>
16295: #include <ogg/ogg.h>
16295: #include "vorbis/codec.h"
16295: #include "codec_internal.h"
16295: #include "registry.h"
16295: #include "misc.h"
16295: #include "os.h"
16295: 
16295: int vorbis_synthesis(vorbis_block *vb,ogg_packet *op){
29346:   vorbis_dsp_state     *vd= vb ? vb->vd : 0;
29346:   private_state        *b= vd ? vd->backend_state : 0;
29346:   vorbis_info          *vi= vd ? vd->vi : 0;
29346:   codec_setup_info     *ci= vi ? vi->codec_setup : 0;
29346:   oggpack_buffer       *opb=vb ? &vb->opb : 0;
16295:   int                   type,mode,i;
16295: 
29346:   if (!vd || !b || !vi || !ci || !opb) {
29346:     return OV_EBADPACKET;
29346:   }
29346: 
16295:   /* first things first.  Make sure decode is ready */
16295:   _vorbis_block_ripcord(vb);
16295:   oggpack_readinit(opb,op->packet,op->bytes);
16295: 
16295:   /* Check the packet type */
16295:   if(oggpack_read(opb,1)!=0){
16295:     /* Oops.  This is not an audio data packet */
16295:     return(OV_ENOTAUDIO);
16295:   }
16295: 
16295:   /* read our mode and pre/post windowsize */
16295:   mode=oggpack_read(opb,b->modebits);
28870:   if(mode==-1) {
28870:     return(OV_EBADPACKET);
28870:   }
16295: 
16295:   vb->mode=mode;
28870:   if(!ci->mode_param[mode]) {
28870:     return(OV_EBADPACKET); 
28870:   }
16295:   vb->W=ci->mode_param[mode]->blockflag;
16295:   if(vb->W){
16295: 
16295:     /* this doesn;t get mapped through mode selection as it's used
16295:        only for window selection */
16295:     vb->lW=oggpack_read(opb,1);
16295:     vb->nW=oggpack_read(opb,1);
16295:     if(vb->nW==-1)   return(OV_EBADPACKET);
16295:   }else{
16295:     vb->lW=0;
16295:     vb->nW=0;
16295:   }
16295: 
16295:   /* more setup */
16295:   vb->granulepos=op->granulepos;
16295:   vb->sequence=op->packetno;
16295:   vb->eofflag=op->e_o_s;
16295: 
16295:   /* alloc pcm passback storage */
16295:   vb->pcmend=ci->blocksizes[vb->W];
16295:   vb->pcm=_vorbis_block_alloc(vb,sizeof(*vb->pcm)*vi->channels);
16295:   for(i=0;i<vi->channels;i++)
16295:     vb->pcm[i]=_vorbis_block_alloc(vb,vb->pcmend*sizeof(*vb->pcm[i]));
16295: 
16295:   /* unpack_header enforces range checking */
16295:   type=ci->map_type[ci->mode_param[mode]->mapping];
16295: 
16295:   return(_mapping_P[type]->inverse(vb,ci->map_param[ci->mode_param[mode]->
16295:                                                    mapping]));
16295: }
16295: 
16295: /* used to track pcm position without actually performing decode.
16295:    Useful for sequential 'fast forward' */
16295: int vorbis_synthesis_trackonly(vorbis_block *vb,ogg_packet *op){
16295:   vorbis_dsp_state     *vd=vb->vd;
16295:   private_state        *b=vd->backend_state;
16295:   vorbis_info          *vi=vd->vi;
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   oggpack_buffer       *opb=&vb->opb;
16295:   int                   mode;
16295: 
16295:   /* first things first.  Make sure decode is ready */
16295:   _vorbis_block_ripcord(vb);
16295:   oggpack_readinit(opb,op->packet,op->bytes);
16295: 
16295:   /* Check the packet type */
16295:   if(oggpack_read(opb,1)!=0){
16295:     /* Oops.  This is not an audio data packet */
16295:     return(OV_ENOTAUDIO);
16295:   }
16295: 
16295:   /* read our mode and pre/post windowsize */
16295:   mode=oggpack_read(opb,b->modebits);
16295:   if(mode==-1)return(OV_EBADPACKET);
16295: 
16295:   vb->mode=mode;
16295:   vb->W=ci->mode_param[mode]->blockflag;
16295:   if(vb->W){
16295:     vb->lW=oggpack_read(opb,1);
16295:     vb->nW=oggpack_read(opb,1);
16295:     if(vb->nW==-1)   return(OV_EBADPACKET);
16295:   }else{
16295:     vb->lW=0;
16295:     vb->nW=0;
16295:   }
16295: 
16295:   /* more setup */
16295:   vb->granulepos=op->granulepos;
16295:   vb->sequence=op->packetno;
16295:   vb->eofflag=op->e_o_s;
16295: 
16295:   /* no pcm */
16295:   vb->pcmend=0;
16295:   vb->pcm=NULL;
16295: 
16295:   return(0);
16295: }
16295: 
16295: long vorbis_packet_blocksize(vorbis_info *vi,ogg_packet *op){
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   oggpack_buffer       opb;
16295:   int                  mode;
16295: 
16295:   oggpack_readinit(&opb,op->packet,op->bytes);
16295: 
16295:   /* Check the packet type */
16295:   if(oggpack_read(&opb,1)!=0){
16295:     /* Oops.  This is not an audio data packet */
16295:     return(OV_ENOTAUDIO);
16295:   }
16295: 
16295:   {
16295:     int modebits=0;
16295:     int v=ci->modes;
16295:     while(v>1){
16295:       modebits++;
16295:       v>>=1;
16295:     }
16295: 
16295:     /* read our mode and pre/post windowsize */
16295:     mode=oggpack_read(&opb,modebits);
16295:   }
16295:   if(mode==-1)return(OV_EBADPACKET);
16295:   return(ci->blocksizes[ci->mode_param[mode]->blockflag]);
16295: }
16295: 
16295: int vorbis_synthesis_halfrate(vorbis_info *vi,int flag){
16295:   /* set / clear half-sample-rate mode */
16295:   codec_setup_info     *ci=vi->codec_setup;
16295: 
16295:   /* right now, our MDCT can't handle < 64 sample windows. */
16295:   if(ci->blocksizes[0]<=64 && flag)return -1;
16295:   ci->halfrate_flag=(flag?1:0);
16295:   return 0;
16295: }
16295: 
16295: int vorbis_synthesis_halfrate_p(vorbis_info *vi){
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   return ci->halfrate_flag;
16295: }
