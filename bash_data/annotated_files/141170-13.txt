  6597: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
  6597:  *
 99778:  * This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  6597: 
  6597: #include "nsSSLStatus.h"
  6597: #include "plstr.h"
  8463: #include "nsIClassInfoImpl.h"
  8463: #include "nsIProgrammingLanguage.h"
  8463: #include "nsIObjectOutputStream.h"
  8463: #include "nsIObjectInputStream.h"
  6597: 
  6597: NS_IMETHODIMP
  6597: nsSSLStatus::GetServerCert(nsIX509Cert** _result)
  6597: {
  6597:   NS_ASSERTION(_result, "non-NULL destination required");
  6597: 
  6597:   *_result = mServerCert;
  6597:   NS_IF_ADDREF(*_result);
  6597: 
  6597:   return NS_OK;
  6597: }
  6597: 
  6597: NS_IMETHODIMP
108991: nsSSLStatus::GetKeyLength(uint32_t* _result)
  6597: {
  6597:   NS_ASSERTION(_result, "non-NULL destination required");
  6597:   if (!mHaveKeyLengthAndCipher)
  6597:     return NS_ERROR_NOT_AVAILABLE;
  6597: 
  6597:   *_result = mKeyLength;
  6597: 
  6597:   return NS_OK;
  6597: }
  6597: 
  6597: NS_IMETHODIMP
108991: nsSSLStatus::GetSecretKeyLength(uint32_t* _result)
  6597: {
  6597:   NS_ASSERTION(_result, "non-NULL destination required");
  6597:   if (!mHaveKeyLengthAndCipher)
  6597:     return NS_ERROR_NOT_AVAILABLE;
  6597: 
  6597:   *_result = mSecretKeyLength;
  6597: 
  6597:   return NS_OK;
  6597: }
  6597: 
  6597: NS_IMETHODIMP
  6597: nsSSLStatus::GetCipherName(char** _result)
  6597: {
  6597:   NS_ASSERTION(_result, "non-NULL destination required");
  6597:   if (!mHaveKeyLengthAndCipher)
  6597:     return NS_ERROR_NOT_AVAILABLE;
  6597: 
 27356:   *_result = ToNewCString(mCipherName);
  6597: 
  6597:   return NS_OK;
  6597: }
  6597: 
  6597: NS_IMETHODIMP
 79445: nsSSLStatus::GetIsDomainMismatch(bool* _result)
  6597: {
  6597:   NS_ASSERTION(_result, "non-NULL destination required");
  6597: 
 10546:   *_result = mHaveCertErrorBits && mIsDomainMismatch;
  6597: 
  6597:   return NS_OK;
  6597: }
  6597: 
  6597: NS_IMETHODIMP
 79445: nsSSLStatus::GetIsNotValidAtThisTime(bool* _result)
  6597: {
  6597:   NS_ASSERTION(_result, "non-NULL destination required");
  6597: 
 10546:   *_result = mHaveCertErrorBits && mIsNotValidAtThisTime;
  6597: 
  6597:   return NS_OK;
  6597: }
  6597: 
  6597: NS_IMETHODIMP
 79445: nsSSLStatus::GetIsUntrusted(bool* _result)
  6597: {
  6597:   NS_ASSERTION(_result, "non-NULL destination required");
  6597: 
 10546:   *_result = mHaveCertErrorBits && mIsUntrusted;
  6597: 
  6597:   return NS_OK;
  6597: }
  6597: 
  8463: NS_IMETHODIMP
  8463: nsSSLStatus::Read(nsIObjectInputStream* stream)
  8463: {
  8463:   nsCOMPtr<nsISupports> cert;
 80486:   nsresult rv = stream->ReadObject(true, getter_AddRefs(cert));
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463: 
  8463:   mServerCert = do_QueryInterface(cert);
  8463:   if (!mServerCert)
  8463:     return NS_NOINTERFACE;
  8463: 
  8463:   rv = stream->Read32(&mKeyLength);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463:   rv = stream->Read32(&mSecretKeyLength);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463:   rv = stream->ReadCString(mCipherName);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463: 
  8463:   rv = stream->ReadBoolean(&mIsDomainMismatch);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463:   rv = stream->ReadBoolean(&mIsNotValidAtThisTime);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463:   rv = stream->ReadBoolean(&mIsUntrusted);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463: 
  8463:   rv = stream->ReadBoolean(&mHaveKeyLengthAndCipher);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
 10546:   rv = stream->ReadBoolean(&mHaveCertErrorBits);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463: 
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
  8463: nsSSLStatus::Write(nsIObjectOutputStream* stream)
  8463: {
  8463:   nsresult rv = stream->WriteCompoundObject(mServerCert,
  8463:                                             NS_GET_IID(nsIX509Cert),
 80486:                                             true);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463: 
  8463:   rv = stream->Write32(mKeyLength);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463:   rv = stream->Write32(mSecretKeyLength);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463:   rv = stream->WriteStringZ(mCipherName.get());
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463: 
  8463:   rv = stream->WriteBoolean(mIsDomainMismatch);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463:   rv = stream->WriteBoolean(mIsNotValidAtThisTime);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463:   rv = stream->WriteBoolean(mIsUntrusted);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463: 
  8463:   rv = stream->WriteBoolean(mHaveKeyLengthAndCipher);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
 10546:   rv = stream->WriteBoolean(mHaveCertErrorBits);
  8463:   NS_ENSURE_SUCCESS(rv, rv);
  8463: 
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
108991: nsSSLStatus::GetInterfaces(uint32_t *count, nsIID * **array)
  8463: {
  8463:   *count = 0;
106838:   *array = nullptr;
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
108991: nsSSLStatus::GetHelperForLanguage(uint32_t language, nsISupports **_retval)
  8463: {
106838:   *_retval = nullptr;
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
  8463: nsSSLStatus::GetContractID(char * *aContractID)
  8463: {
106838:   *aContractID = nullptr;
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
  8463: nsSSLStatus::GetClassDescription(char * *aClassDescription)
  8463: {
106838:   *aClassDescription = nullptr;
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
  8463: nsSSLStatus::GetClassID(nsCID * *aClassID)
  8463: {
  8463:   *aClassID = (nsCID*) nsMemory::Alloc(sizeof(nsCID));
  8463:   if (!*aClassID)
  8463:     return NS_ERROR_OUT_OF_MEMORY;
  8463:   return GetClassIDNoAlloc(*aClassID);
  8463: }
  8463: 
  8463: NS_IMETHODIMP
108991: nsSSLStatus::GetImplementationLanguage(uint32_t *aImplementationLanguage)
  8463: {
  8463:   *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
108991: nsSSLStatus::GetFlags(uint32_t *aFlags)
  8463: {
  8463:   *aFlags = 0;
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: static NS_DEFINE_CID(kSSLStatusCID, NS_SSLSTATUS_CID);
  8463: 
  8463: NS_IMETHODIMP
  8463: nsSSLStatus::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
  8463: {
  8463:   *aClassIDNoAlloc = kSSLStatusCID;
  8463:   return NS_OK;
  8463: }
  8463: 
  6597: nsSSLStatus::nsSSLStatus()
  6597: : mKeyLength(0), mSecretKeyLength(0)
 80486: , mIsDomainMismatch(false)
 80486: , mIsNotValidAtThisTime(false)
 80486: , mIsUntrusted(false)
 80486: , mHaveKeyLengthAndCipher(false)
 80486: , mHaveCertErrorBits(false)
  6597: {
 50565:   mCipherName = "";
  6597: }
  6597: 
  8463: NS_IMPL_THREADSAFE_ISUPPORTS3(nsSSLStatus, nsISSLStatus, nsISerializable, nsIClassInfo)
  6597: 
  6597: nsSSLStatus::~nsSSLStatus()
  6597: {
  6597: }
