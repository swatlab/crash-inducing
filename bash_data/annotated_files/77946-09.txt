    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #ifndef nsTableRowGroupFrame_h__
    1: #define nsTableRowGroupFrame_h__
    1: 
    1: #include "nscore.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsIAtom.h"
    1: #include "nsILineIterator.h"
    1: #include "nsTablePainter.h"
    1: #include "nsTArray.h"
    1: 
    1: class nsTableFrame;
    1: class nsTableRowFrame;
    1: class nsTableCellFrame;
    1: 
    1: struct nsRowGroupReflowState {
    1:   const nsHTMLReflowState& reflowState;  // Our reflow state
    1: 
    1:   nsTableFrame* tableFrame;
    1: 
    1:   // The available size (computed from the parent)
    1:   nsSize availSize;
    1: 
    1:   // Running y-offset
    1:   nscoord y;
    1: 
    1:   nsRowGroupReflowState(const nsHTMLReflowState& aReflowState,
    1:                         nsTableFrame*            aTableFrame)
    1:       :reflowState(aReflowState), tableFrame(aTableFrame)
    1:   {
    1:     availSize.width  = reflowState.availableWidth;
    1:     availSize.height = reflowState.availableHeight;
    1:     y = 0;  
    1:   }
    1: 
    1:   ~nsRowGroupReflowState() {}
    1: };
    1: 
    1: // use the following bits from nsFrame's frame state 
    1: 
    1: // thead or tfoot should be repeated on every printed page
43376: #define NS_ROWGROUP_REPEATABLE           NS_FRAME_STATE_BIT(31)
43376: #define NS_ROWGROUP_HAS_STYLE_HEIGHT     NS_FRAME_STATE_BIT(30)
    1: // the next is also used on rows (see nsTableRowGroupFrame::InitRepeatedFrame)
43376: #define NS_REPEATED_ROW_OR_ROWGROUP      NS_FRAME_STATE_BIT(28)
43376: #define NS_ROWGROUP_HAS_ROW_CURSOR       NS_FRAME_STATE_BIT(27)
    1: 
    1: #define MIN_ROWS_NEEDING_CURSOR 20
    1: 
    1: /**
    1:  * nsTableRowGroupFrame is the frame that maps row groups 
    1:  * (HTML tags THEAD, TFOOT, and TBODY). This class cannot be reused
    1:  * outside of an nsTableFrame.  It assumes that its parent is an nsTableFrame, and 
    1:  * its children are nsTableRowFrames.
    1:  * 
    1:  * @see nsTableFrame
    1:  * @see nsTableRowFrame
    1:  */
21112: class nsTableRowGroupFrame
21112:   : public nsHTMLContainerFrame
21112:   , public nsILineIterator
    1: {
    1: public:
32423:   NS_DECL_QUERYFRAME_TARGET(nsTableRowGroupFrame)
23554:   NS_DECL_QUERYFRAME
32423:   NS_DECL_FRAMEARENA_HELPERS
    1: 
    1:   /** instantiate a new instance of nsTableRowFrame.
    1:     * @param aPresShell the pres shell for this frame
    1:     *
    1:     * @return           the frame that was created
    1:     */
    1:   friend nsIFrame* NS_NewTableRowGroupFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1:   virtual ~nsTableRowGroupFrame();
20836:   /** @see nsIFrame::DidSetStyleContext */
20836:   virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
    1:   
77154:   NS_IMETHOD AppendFrames(ChildListID     aListID,
30941:                           nsFrameList&    aFrameList);
    1:   
77154:   NS_IMETHOD InsertFrames(ChildListID     aListID,
    1:                           nsIFrame*       aPrevFrame,
30941:                           nsFrameList&    aFrameList);
    1: 
77154:   NS_IMETHOD RemoveFrame(ChildListID     aListID,
    1:                          nsIFrame*       aOldFrame);
    1: 
    1:   virtual nsMargin GetUsedMargin() const;
    1:   virtual nsMargin GetUsedBorder() const;
    1:   virtual nsMargin GetUsedPadding() const;
    1: 
    1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists);
    1: 
    1:    /** calls Reflow for all of its child rows.
    1:     * Rows are all set to the same width and stacked vertically.
    1:     * <P> rows are not split unless absolutely necessary.
    1:     *
    1:     * @param aDesiredSize width set to width of rows, height set to 
    1:     *                     sum of height of rows that fit in aMaxSize.height.
    1:     *
    1:     * @see nsIFrame::Reflow
    1:     */
    1:   NS_IMETHOD Reflow(nsPresContext*           aPresContext,
    1:                     nsHTMLReflowMetrics&     aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus&          aStatus);
    1: 
    1:   /**
    1:    * Get the "type" of the frame
    1:    *
    1:    * @see nsGkAtoms::tableRowGroupFrame
    1:    */
    1:   virtual nsIAtom* GetType() const;
    1: 
    1:   virtual PRBool IsContainingBlock() const;
    1: 
    1:   nsTableRowFrame* GetFirstRow();
    1: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const;
    1: #endif
    1: 
    1:   /** return the number of child rows (not necessarily == number of child frames) */
    1:   PRInt32 GetRowCount();
    1: 
    1:   /** return the table-relative row index of the first row in this rowgroup.
    1:     * if there are no rows, -1 is returned.
    1:     */
    1:   PRInt32 GetStartRowIndex();
    1: 
    1:   /** Adjust the row indices of all rows  whose index is >= aRowIndex.  
    1:     * @param aRowIndex   - start adjusting with this index
    1:     * @param aAdjustment - shift the row index by this amount
    1:     */
    1:   void AdjustRowIndices(PRInt32   aRowIndex,
    1:                         PRInt32   anAdjustment);
    1: 
    1:   /**
    1:    * Used for header and footer row group frames that are repeated when
    1:    * splitting a table frame.
    1:    *
    1:    * Performs any table specific initialization
    1:    *
    1:    * @param aHeaderFooterFrame the original header or footer row group frame
    1:    * that was repeated
    1:    */
    1:   nsresult  InitRepeatedFrame(nsPresContext*        aPresContext,
    1:                               nsTableRowGroupFrame* aHeaderFooterFrame);
    1: 
    1:   
    1:   /**
    1:    * Get the total height of all the row rects
    1:    */
    1:   nscoord GetHeightBasis(const nsHTMLReflowState& aReflowState);
    1:   
    1:   nsMargin* GetBCBorderWidth(nsMargin& aBorder);
    1: 
    1:   /**
    1:    * Gets inner border widths before collapsing with cell borders
    1:    * Caller must get top border from previous row group or from table
    1:    * GetContinuousBCBorderWidth will not overwrite aBorder.top
    1:    * see nsTablePainter about continuous borders
    1:    */
    1:   void GetContinuousBCBorderWidth(nsMargin& aBorder);
    1:   /**
    1:    * Sets full border widths before collapsing with cell borders
    1:    * @param aForSide - side to set; only right, left, and bottom valid
    1:    */
    1:   void SetContinuousBCBorderWidth(PRUint8     aForSide,
    1:                                   BCPixelSize aPixelValue);
    1:   /**
    1:     * Adjust to the effect of visibibility:collapse on the row group and
    1:     * its children
    1:     * @return              additional shift upward that should be applied to
    1:     *                      subsequent rowgroups due to rows and this rowgroup
    1:     *                      being collapsed
    1:     * @param aYTotalOffset the total amount that the rowgroup is shifted up
    1:     * @param aWidth        new width of the rowgroup
    1:     */
    1:   nscoord CollapseRowGroupIfNecessary(nscoord aYTotalOffset,
    1:                                       nscoord aWidth);
    1: 
    1: // nsILineIterator methods
    1: public:
21112:   virtual void DisposeLineIterator() { }
21112: 
11464:   // The table row is the equivalent to a line in block layout. 
11464:   // The nsILineIterator assumes that a line resides in a block, this role is
11464:   // fullfilled by the row group. Rows in table are counted relative to the
11464:   // table. The row index of row corresponds to the cellmap coordinates. The
11963:   // line index with respect to a row group can be computed by substracting the
11963:   // row index of the first row in the row group.
11464:    
11963:   /** Get the number of rows in a row group
21112:     * @return the number of lines in a row group
11464:     */
21112:   virtual PRInt32 GetNumLines();
11464: 
11464:   /** @see nsILineIterator.h GetDirection
21112:     * @return true if the table is rtl
11464:     */
21112:   virtual PRBool GetDirection();
    1:   
11464:   /** Return structural information about a line. 
11963:     * @param aLineNumber       - the index of the row relative to the row group
11464:     *                            If the line-number is invalid then
11464:     *                            aFirstFrameOnLine will be nsnull and 
11464:     *                            aNumFramesOnLine will be zero.
11464:     * @param aFirstFrameOnLine - the first cell frame that originates in row
11464:     *                            with a rowindex that matches a line number
11464:     * @param aNumFramesOnLine  - return the numbers of cells originating in
11464:     *                            this row
11464:     * @param aLineBounds       - rect of the row
11464:     * @param aLineFlags        - unused set to 0
11464:     */
    1:   NS_IMETHOD GetLine(PRInt32 aLineNumber,
    1:                      nsIFrame** aFirstFrameOnLine,
    1:                      PRInt32* aNumFramesOnLine,
    1:                      nsRect& aLineBounds,
    1:                      PRUint32* aLineFlags);
    1:   
11464:   /** Given a frame that's a child of the rowgroup, find which line its on.
11464:     * @param aFrame       - frame, should be a row
21112:     * @return               row index relative to the row group if this a row
77946:     *                       frame. -1 if the frame cannot be found.
11464:     */
77946:   virtual PRInt32 FindLineContaining(nsIFrame* aFrame);
11464: 
11464:   /** Find the orginating cell frame on a row that is the nearest to the
11464:     * coordinate X.
11963:     * @param aLineNumber          - the index of the row relative to the row group
11464:     * @param aX                   - X coordinate in twips relative to the
11464:     *                               origin of the row group
11464:     * @param aFrameFound          - pointer to the cellframe
11464:     * @param aXIsBeforeFirstFrame - the point is before the first originating
11464:     *                               cellframe
11464:     * @param aXIsAfterLastFrame   - the point is after the last originating
11464:     *                               cellframe
11464:     */
    1:   NS_IMETHOD FindFrameAt(PRInt32 aLineNumber,
    1:                          nscoord aX,
    1:                          nsIFrame** aFrameFound,
    1:                          PRBool* aXIsBeforeFirstFrame,
    1:                          PRBool* aXIsAfterLastFrame);
    1: 
    1: #ifdef IBMBIDI
11464:    /** Check whether visual and logical order of cell frames within a line are
11464:      * identical. As the layout will reorder them this is always the case
11464:      * @param aLine        - the index of the row relative to the table
11464:      * @param aIsReordered - returns false
11464:      * @param aFirstVisual - if the table is rtl first originating cell frame
11464:      * @param aLastVisual  - if the table is rtl last originating cell frame
11464:      */
11464: 
    1:   NS_IMETHOD CheckLineOrder(PRInt32                  aLine,
    1:                             PRBool                   *aIsReordered,
    1:                             nsIFrame                 **aFirstVisual,
    1:                             nsIFrame                 **aLastVisual);
    1: #endif
11464: 
11464:   /** Find the next originating cell frame that originates in the row.    
11464:     * @param aFrame      - cell frame to start with, will return the next cell
11464:     *                      originating in a row
11464:     * @param aLineNumber - the index of the row relative to the table
11464:     */  
    1:   NS_IMETHOD GetNextSiblingOnLine(nsIFrame*& aFrame, PRInt32 aLineNumber);
    1: 
    1:   // row cursor methods to speed up searching for the row(s)
    1:   // containing a point. The basic idea is that we set the cursor
    1:   // property if the rows' y and yMosts are non-decreasing (considering only
    1:   // rows with nonempty overflowAreas --- empty overflowAreas never participate
    1:   // in event handling or painting), and the rowgroup has sufficient number of
    1:   // rows. The cursor property points to a "recently used" row. If we get a
    1:   // series of requests that work on rows "near" the cursor, then we can find
    1:   // those nearby rows quickly by starting our search at the cursor.
    1:   // This code is based on the line cursor code in nsBlockFrame. It's more general
    1:   // though, and could be extracted and used elsewhere.
    1:   struct FrameCursorData {
    1:     nsTArray<nsIFrame*> mFrames;
    1:     PRUint32            mCursorIndex;
    1:     nscoord             mOverflowAbove;
    1:     nscoord             mOverflowBelow;
    1:     
    1:     FrameCursorData()
    1:       : mFrames(MIN_ROWS_NEEDING_CURSOR), mCursorIndex(0), mOverflowAbove(0),
    1:         mOverflowBelow(0) {}
    1: 
    1:     PRBool AppendFrame(nsIFrame* aFrame);
    1:     
    1:     void FinishBuildingCursor() {
    1:       mFrames.Compact();
    1:     }
    1:   };
    1: 
    1:   // Clear out row cursor because we're disturbing the rows (e.g., Reflow)
    1:   void ClearRowCursor();
    1: 
    1:   /**
    1:    * Get the first row that might contain y-coord 'aY', or nsnull if you must search
    1:    * all rows.
    1:    * The actual row returned might not contain 'aY', but if not, it is guaranteed
    1:    * to be before any row which does contain 'aY'.
    1:    * aOverflowAbove is the maximum over all rows of -row.GetOverflowRect().y.
    1:    * To find all rows that intersect the vertical interval aY/aYMost, call
    1:    * GetFirstRowContaining(aY, &overflowAbove), and then iterate through all
    1:    * rows until reaching a row where row->GetRect().y - overflowAbove >= aYMost.
    1:    * That row and all subsequent rows cannot intersect the interval.
    1:    */
    1:   nsIFrame* GetFirstRowContaining(nscoord aY, nscoord* aOverflowAbove);
    1: 
    1:   /**
    1:    * Set up the row cursor. After this, call AppendFrame for every
    1:    * child frame in sibling order. Ensure that the child frame y and YMost values
    1:    * form non-decreasing sequences (should always be true for table rows);
    1:    * if this is violated, call ClearRowCursor(). If we return nsnull, then we
    1:    * decided not to use a cursor or we already have one set up.
    1:    */
    1:   FrameCursorData* SetupRowCursor();
    1: 
21112:   virtual nsILineIterator* GetLineIterator() { return this; }
21112: 
    1: protected:
    1:   nsTableRowGroupFrame(nsStyleContext* aContext);
    1: 
    1:   void InitChildReflowState(nsPresContext&     aPresContext, 
    1:                             PRBool             aBorderCollapse,
    1:                             nsHTMLReflowState& aReflowState);
    1:   
    1:   /** implement abstract method on nsHTMLContainerFrame */
    1:   virtual PRIntn GetSkipSides() const;
    1: 
    1:   void PlaceChild(nsPresContext*         aPresContext,
    1:                   nsRowGroupReflowState& aReflowState,
    1:                   nsIFrame*              aKidFrame,
11384:                   nsHTMLReflowMetrics&   aDesiredSize,
13144:                   const nsRect&          aOriginalKidRect,
55037:                   const nsRect&          aOriginalKidVisualOverflow);
    1: 
    1:   void CalculateRowHeights(nsPresContext*           aPresContext, 
    1:                            nsHTMLReflowMetrics&     aDesiredSize,
    1:                            const nsHTMLReflowState& aReflowState);
    1: 
    1:   void DidResizeRows(nsHTMLReflowMetrics& aDesiredSize);
    1: 
    1:   void SlideChild(nsRowGroupReflowState& aReflowState,
    1:                   nsIFrame*              aKidFrame);
    1:   
    1:   /**
    1:    * Reflow the frames we've already created
    1:    *
    1:    * @param   aPresContext presentation context to use
    1:    * @param   aReflowState current inline state
    1:    * @return  true if we successfully reflowed all the mapped children and false
    1:    *            otherwise, e.g. we pushed children to the next in flow
    1:    */
55038:   nsresult ReflowChildren(nsPresContext*         aPresContext,
    1:                           nsHTMLReflowMetrics&   aDesiredSize,
    1:                           nsRowGroupReflowState& aReflowState,
    1:                           nsReflowStatus&        aStatus,
    1:                           PRBool*                aPageBreakBeforeEnd = nsnull);
    1: 
    1:   nsresult SplitRowGroup(nsPresContext*           aPresContext,
    1:                          nsHTMLReflowMetrics&     aDesiredSize,
    1:                          const nsHTMLReflowState& aReflowState,
    1:                          nsTableFrame*            aTableFrame,
    1:                          nsReflowStatus&          aStatus);
    1: 
    1:   void SplitSpanningCells(nsPresContext&           aPresContext,
    1:                           const nsHTMLReflowState& aReflowState,
    1:                           nsTableFrame&            aTableFrame,
    1:                           nsTableRowFrame&         aFirstRow, 
    1:                           nsTableRowFrame&         aLastRow,  
    1:                           PRBool                   aFirstRowIsTopOfPage,
 8536:                           nscoord                  aSpanningRowBottom,
    1:                           nsTableRowFrame*&        aContRowFrame,
    1:                           nsTableRowFrame*&        aFirstTruncatedRow,
    1:                           nscoord&                 aDesiredHeight);
    1: 
    1:   void CreateContinuingRowFrame(nsPresContext& aPresContext,
    1:                                 nsIFrame&      aRowFrame,
    1:                                 nsIFrame**     aContRowFrame);
    1: 
    1:   PRBool IsSimpleRowFrame(nsTableFrame* aTableFrame, 
    1:                           nsIFrame*     aFrame);
    1: 
    1:   void GetNextRowSibling(nsIFrame** aRowFrame);
    1: 
    1:   void UndoContinuedRow(nsPresContext*   aPresContext,
    1:                         nsTableRowFrame* aRow);
    1:                         
    1: private:
    1:   // border widths in pixels in the collapsing border model
    1:   BCPixelSize mRightContBorderWidth;
    1:   BCPixelSize mBottomContBorderWidth;
    1:   BCPixelSize mLeftContBorderWidth;
    1: 
    1: public:
    1:   PRBool IsRepeatable() const;
    1:   void   SetRepeatable(PRBool aRepeatable);
    1:   PRBool HasStyleHeight() const;
    1:   void   SetHasStyleHeight(PRBool aValue);
42270:   PRBool HasInternalBreakBefore() const;
42270:   PRBool HasInternalBreakAfter() const;
    1: };
    1: 
    1: 
    1: inline PRBool nsTableRowGroupFrame::IsRepeatable() const
    1: {
    1:   return (mState & NS_ROWGROUP_REPEATABLE) == NS_ROWGROUP_REPEATABLE;
    1: }
    1: 
    1: inline void nsTableRowGroupFrame::SetRepeatable(PRBool aRepeatable)
    1: {
    1:   if (aRepeatable) {
    1:     mState |= NS_ROWGROUP_REPEATABLE;
    1:   } else {
    1:     mState &= ~NS_ROWGROUP_REPEATABLE;
    1:   }
    1: }
    1: 
    1: inline PRBool nsTableRowGroupFrame::HasStyleHeight() const
    1: {
    1:   return (mState & NS_ROWGROUP_HAS_STYLE_HEIGHT) == NS_ROWGROUP_HAS_STYLE_HEIGHT;
    1: }
    1: 
    1: inline void nsTableRowGroupFrame::SetHasStyleHeight(PRBool aValue)
    1: {
    1:   if (aValue) {
    1:     mState |= NS_ROWGROUP_HAS_STYLE_HEIGHT;
    1:   } else {
    1:     mState &= ~NS_ROWGROUP_HAS_STYLE_HEIGHT;
    1:   }
    1: }
    1: 
    1: inline void
    1: nsTableRowGroupFrame::GetContinuousBCBorderWidth(nsMargin& aBorder)
    1: {
    1:   PRInt32 aPixelsToTwips = nsPresContext::AppUnitsPerCSSPixel();
    1:   aBorder.right = BC_BORDER_LEFT_HALF_COORD(aPixelsToTwips,
    1:                                             mRightContBorderWidth);
    1:   aBorder.bottom = BC_BORDER_TOP_HALF_COORD(aPixelsToTwips,
    1:                                             mBottomContBorderWidth);
    1:   aBorder.left = BC_BORDER_RIGHT_HALF_COORD(aPixelsToTwips,
    1:                                             mLeftContBorderWidth);
    1:   return;
    1: }
    1: #endif
