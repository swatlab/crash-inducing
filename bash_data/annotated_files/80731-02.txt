37612: /* ***** BEGIN LICENSE BLOCK *****
37612:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
37612:  *
37612:  * The contents of this file are subject to the Mozilla Public License Version
37612:  * 1.1 (the "License"); you may not use this file except in compliance with
37612:  * the License. You may obtain a copy of the License at
37612:  * http://www.mozilla.org/MPL/
37612:  *
37612:  * Software distributed under the License is distributed on an "AS IS" basis,
37612:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
37612:  * for the specific language governing rights and limitations under the
37612:  * License.
37612:  *
37612:  * The Original Code is sessionstore test code.
37612:  *
37612:  * The Initial Developer of the Original Code is
37612:  *  Justin Lebar <justin.lebar@gmail.com>
37612:  * Portions created by the Initial Developer are Copyright (C) 2009
37612:  * the Initial Developer. All Rights Reserved.
37612:  *
37612:  * Contributor(s):
37612:  *
37612:  * Alternatively, the contents of this file may be used under the terms of
37612:  * either the GNU General Public License Version 2 or later (the "GPL"), or
37612:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
37612:  * in which case the provisions of the GPL or the LGPL are applicable instead
37612:  * of those above. If you wish to allow use of your version of this file only
37612:  * under the terms of either the GPL or the LGPL, and not to allow others to
37612:  * use your version of this file under the terms of the MPL, indicate your
37612:  * decision by deleting the provisions above and replace them with the notice
37612:  * and other provisions required by the GPL or the LGPL. If you do not delete
37612:  * the provisions above, a recipient may use your version of this file under
37612:  * the terms of any one of the MPL, the GPL or the LGPL.
37612:  *
37612:  * ***** END LICENSE BLOCK ***** */
37612: 
37612: function checkState(tab) {
37612:   // Go back and then forward, and make sure that the state objects received
37612:   // from the popState event are as we expect them to be.
37612:   //
37612:   // We also add a node to the document's body when after going back and make
37612:   // sure it's still there after we go forward -- this is to test that the two
37612:   // history entries correspond to the same document.
37612: 
37612:   let popStateCount = 0;
37612: 
68731:   tab.linkedBrowser.addEventListener('popstate', function(aEvent) {
37612:     let contentWindow = tab.linkedBrowser.contentWindow;
37612:     if (popStateCount == 0) {
37612:       popStateCount++;
68731: 
68731:       is(tab.linkedBrowser.contentWindow.testState, 'foo',
68731:          'testState after going back');
68731: 
68731:       ok(aEvent.state, "Event should have a state property.");
63196:       is(JSON.stringify(tab.linkedBrowser.contentWindow.history.state), JSON.stringify({obj1:1}),
37612:          "first popstate object.");
37612: 
37612:       // Add a node with id "new-elem" to the document.
37612:       let doc = contentWindow.document;
37612:       ok(!doc.getElementById("new-elem"),
37612:          "doc shouldn't contain new-elem before we add it.");
37612:       let elem = doc.createElement("div");
37612:       elem.id = "new-elem";
37612:       doc.body.appendChild(elem);
37612: 
37612:       contentWindow.history.forward();
37612:     }
37612:     else if (popStateCount == 1) {
37612:       popStateCount++;
69563:       is(aEvent.state.obj3.toString(), '/^a$/', "second popstate object.");
37612: 
37612:       // Make sure that the new-elem node is present in the document.  If it's
37612:       // not, then this history entry has a different doc identifier than the
37612:       // previous entry, which is bad.
37612:       let doc = contentWindow.document;
37612:       let newElem = doc.getElementById("new-elem");
37612:       ok(newElem, "doc should contain new-elem.");
37612:       newElem.parentNode.removeChild(newElem);
37612:       ok(!doc.getElementById("new-elem"), "new-elem should be removed.");
37612: 
37612:       // Clean up after ourselves and finish the test.
63411:       tab.linkedBrowser.removeEventListener("popstate", arguments.callee, true);
37612:       gBrowser.removeTab(tab);
37612:       finish();
37612:     }
68731:   }, true);
63196: 
68731:   // Set some state in the page's window.  When we go back(), the page should
68731:   // be retrieved from bfcache, and this state should still be there.
68731:   tab.linkedBrowser.contentWindow.testState = 'foo';
37612: 
68731:   // Now go back.  This should trigger the popstate event handler above.
37612:   tab.linkedBrowser.contentWindow.history.back();
37612: }
37612: 
37612: function test() {
37612:   // Tests session restore functionality of history.pushState and
37612:   // history.replaceState().  (Bug 500328)
37612: 
37612:   waitForExplicitFinish();
37612: 
37612:   // We open a new blank window, let it load, and then load in
37612:   // http://example.com.  We need to load the blank window first, otherwise the
37612:   // docshell gets confused and doesn't have a current history entry.
37612:   let tab = gBrowser.addTab("about:blank");
37612:   let tabBrowser = tab.linkedBrowser;
37612: 
37612:   tabBrowser.addEventListener("load", function(aEvent) {
37612:     tabBrowser.removeEventListener("load", arguments.callee, true);
37612: 
37612:     tabBrowser.loadURI("http://example.com", null, null);
37612: 
37612:     tabBrowser.addEventListener("load", function(aEvent) {
37612:       tabBrowser.removeEventListener("load", arguments.callee, true);
37612: 
37612:       // After these push/replaceState calls, the window should have three
37612:       // history entries:
37612:       //   testURL        (state object: null)          <-- oldest
37612:       //   testURL        (state object: {obj1:1})
80731:       //   testURL?page2  (state object: {obj3:/^a$/})  <-- newest
37612:       let contentWindow = tab.linkedBrowser.contentWindow;
37612:       let history = contentWindow.history;
37612:       history.pushState({obj1:1}, "title-obj1");
80731:       history.pushState({obj2:2}, "title-obj2", "?page2");
69563:       history.replaceState({obj3:/^a$/}, "title-obj3");
37612: 
37612:       let state = ss.getTabState(tab);
68731:       gBrowser.removeTab(tab);
37612: 
68731:       // Restore the state into a new tab.  Things don't work well when we
68731:       // restore into the old tab, but that's not a real use case anyway.
68731:       let tab2 = gBrowser.addTab("about:blank");
68731:       ss.setTabState(tab2, state, true);
37612: 
68731:       // Run checkState() once the tab finishes loading its restored state.
68731:       tab2.linkedBrowser.addEventListener("load", function() {
68731:         tab2.linkedBrowser.removeEventListener("load", arguments.callee, true);
68731:         SimpleTest.executeSoon(function() {
68731:           checkState(tab2);
68731:         });
68731:       }, true);
37612: 
37612:     }, true);
37612:   }, true);
37612: }
