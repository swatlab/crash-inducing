113445: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
113445:  * vim: set ts=4 sw=4 et tw=99:
111800:  *
113445:  * This Source Code Form is subject to the terms of the Mozilla Public
113445:  * License, v. 2.0. If a copy of the MPL was not distributed with this
113445:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
111800: 
111800: #include "TypePolicy.h"
111800: #include "MIR.h"
111800: #include "MIRGraph.h"
111800: 
111800: using namespace js;
111800: using namespace js::ion;
111800: 
111994: MDefinition *
111994: BoxInputsPolicy::boxAt(MInstruction *at, MDefinition *operand)
111994: {
112120:     if (operand->isUnbox())
112120:         return operand->toUnbox()->input();
111994:     MBox *box = MBox::New(operand);
111994:     at->block()->insertBefore(at, box);
111994:     return box;
111994: }
111994: 
111800: bool
111802: BoxInputsPolicy::adjustInputs(MInstruction *ins)
111800: {
111800:     for (size_t i = 0; i < ins->numOperands(); i++) {
111800:         MDefinition *in = ins->getOperand(i);
111800:         if (in->type() == MIRType_Value)
111806:             continue;
111994:         ins->replaceOperand(i, boxAt(ins, in));
111800:     }
111800:     return true;
111800: }
111800: 
111800: bool
112684: ArithPolicy::adjustInputs(MInstruction *ins)
111800: {
111800:     if (specialization_ == MIRType_None)
111802:         return BoxInputsPolicy::adjustInputs(ins);
111802: 
111802:     JS_ASSERT(ins->type() == MIRType_Double || ins->type() == MIRType_Int32);
111800: 
112684:     for (size_t i = 0; i < ins->numOperands(); i++) {
111815:         MDefinition *in = ins->getOperand(i);
111800:         if (in->type() == ins->type())
111800:             continue;
111800: 
111800:         MInstruction *replace;
111994: 
111994:         // If the input is a string or an object, the conversion is not
112830:         // possible, at least, we can't specialize. So box the input.
112830:         if (in->type() == MIRType_Object || in->type() == MIRType_String ||
112830:             (in->type() == MIRType_Undefined && specialization_ == MIRType_Int32))
112830:         {
111994:             in = boxAt(ins, in);
112830:         }
111994: 
111994:         if (ins->type() == MIRType_Double)
111802:             replace = MToDouble::New(in);
111800:         else
111802:             replace = MToInt32::New(in);
111800: 
111800:         ins->block()->insertBefore(ins, replace);
111800:         ins->replaceOperand(i, replace);
111800:     }
111800: 
111800:     return true;
111800: }
111800: 
111800: bool
112429: BinaryStringPolicy::adjustInputs(MInstruction *ins)
112429: {
112429:     for (size_t i = 0; i < 2; i++) {
112429:         MDefinition *in = ins->getOperand(i);
112429:         if (in->type() == MIRType_String)
112429:             continue;
112429: 
112429:         MInstruction *replace = NULL;
112429:         if (in->type() == MIRType_Int32) {
112429:             replace = MToString::New(in);
112429:         } else {
112429:             if (in->type() != MIRType_Value)
112429:                 in = boxAt(ins, in);
112429:             replace = MUnbox::New(in, MIRType_String, MUnbox::Fallible);
112429:         }
112429: 
112429:         ins->block()->insertBefore(ins, replace);
112429:         ins->replaceOperand(i, replace);
112429:     }
112429: 
112429:     return true;
112429: }
112429: 
112429: bool
111996: ComparePolicy::adjustInputs(MInstruction *def)
111996: {
111996:     if (specialization_ == MIRType_None)
111996:         return BoxInputsPolicy::adjustInputs(def);
111996: 
112737:     if (IsNullOrUndefined(specialization_)) {
113328:         // Nothing to do, lowering handles all types.
112737:         return true;
112737:     }
112737: 
113356:     if (specialization_ == MIRType_Boolean) {
113356:         // The RHS is boolean, unbox if needed.
113356:         MDefinition *rhs = def->getOperand(1);
113356: 
113356:         if (rhs->type() == MIRType_Value) {
113356:             MInstruction *unbox = MUnbox::New(rhs, MIRType_Boolean, MUnbox::Infallible);
113356:             def->block()->insertBefore(def, unbox);
113356:             def->replaceOperand(1, unbox);
113356:         }
113356: 
113356:         JS_ASSERT(def->getOperand(1)->type() == MIRType_Boolean);
113356: 
113437:         // Allow the LHS to have any type other than boolean. Value === boolean
113437:         // is handled by LCompareB, comparisons with other non-boolean types are
113437:         // folded.
113437:         if (def->getOperand(0)->type() != MIRType_Boolean)
113437:             return true;
113437: 
113437:         // If the LHS is boolean, we set the specialization to int32 and
113437:         // fall-through. This matches other comparisons of the form
113437:         // bool === bool and allows us to use LCompare, which is much more
113437:         // efficient than LCompareB.
113356:         specialization_ = MIRType_Int32;
113356:     }
113356: 
111996:     for (size_t i = 0; i < 2; i++) {
111996:         MDefinition *in = def->getOperand(i);
111996:         if (in->type() == specialization_)
111996:             continue;
111996: 
111996:         MInstruction *replace;
111996: 
111996:         // See BinaryArithPolicy::adjustInputs for an explanation of the following
111996:         if (in->type() == MIRType_Object || in->type() == MIRType_String)
111996:             in = boxAt(def, in);
111996: 
112752:         switch (specialization_) {
112752:           case MIRType_Double:
111996:             replace = MToDouble::New(in);
112752:             break;
112752:           case MIRType_Int32:
112752:           case MIRType_Boolean:
111996:             replace = MToInt32::New(in);
112752:             break;
112752:           case MIRType_Object:
112752:             replace = MUnbox::New(in, MIRType_Object, MUnbox::Infallible);
112752:             break;
113209:           case MIRType_String:
113209:             replace = MUnbox::New(in, MIRType_String, MUnbox::Infallible);
113209:             break;
112752:           default:
112752:             JS_NOT_REACHED("Unknown compare specialization");
112752:             return false;
112752:         }
111996: 
111996:         def->block()->insertBefore(def, replace);
111996:         def->replaceOperand(i, replace);
111996:     }
111996: 
111996:     return true;
111996: }
111996: 
111802: bool
112714: TestPolicy::adjustInputs(MInstruction *ins)
112714: {
112714:     MDefinition *op = ins->getOperand(0);
112714:     switch (op->type()) {
112714:       case MIRType_Value:
112714:       case MIRType_Null:
112714:       case MIRType_Undefined:
112714:       case MIRType_Boolean:
112714:       case MIRType_Int32:
112714:       case MIRType_Double:
112714:       case MIRType_Object:
112714:         break;
112714: 
112714:       case MIRType_String:
112714:       {
112714:         MStringLength *length = MStringLength::New(op);
112714:         ins->block()->insertBefore(ins, length);
112714:         ins->replaceOperand(0, length);
112714:         break;
112714:       }
112714: 
112714:       default:
112714:         ins->replaceOperand(0, boxAt(ins, op));
112714:         break;
112714:     }
112714:     return true;
112714: }
112714: 
112714: bool
111802: BitwisePolicy::adjustInputs(MInstruction *ins)
111802: {
111802:     if (specialization_ == MIRType_None)
111802:         return BoxInputsPolicy::adjustInputs(ins);
111802: 
113629:     JS_ASSERT(ins->type() == specialization_);
113629:     JS_ASSERT(specialization_ == MIRType_Int32 || specialization_ == MIRType_Double);
113629: 
111802:     // This policy works for both unary and binary bitwise operations.
111802:     for (size_t i = 0; i < ins->numOperands(); i++) {
111802:         MDefinition *in = ins->getOperand(i);
113629:         if (in->type() == MIRType_Int32)
111802:             continue;
111802: 
112044:         // See BinaryArithPolicy::adjustInputs for an explanation of the following
112044:         if (in->type() == MIRType_Object || in->type() == MIRType_String)
112044:             in = boxAt(ins, in);
111802: 
112044:         MInstruction *replace = MTruncateToInt32::New(in);
111802:         ins->block()->insertBefore(ins, replace);
111802:         ins->replaceOperand(i, replace);
111802:     }
111802: 
111802:     return true;
111802: }
111802: 
111929: bool
113476: PowPolicy::adjustInputs(MInstruction *ins)
113476: {
113476:     JS_ASSERT(specialization_ == MIRType_Int32 || specialization_ == MIRType_Double);
113476: 
113476:     // Input must be a double.
116162:     if (!DoublePolicy<0>::staticAdjustInputs(ins))
116162:         return false;
113476: 
113476:     // Power may be an int32 or a double. Integers receive a faster path.
116162:     if (specialization_ == MIRType_Double)
116162:         return DoublePolicy<1>::staticAdjustInputs(ins);
116162:     return IntPolicy<1>::staticAdjustInputs(ins);
113476: }
113476: 
113476: bool
112728: StringPolicy::staticAdjustInputs(MInstruction *def)
112309: {
112309:     MDefinition *in = def->getOperand(0);
112309:     if (in->type() == MIRType_String)
112309:         return true;
112309: 
115132:     MInstruction *replace;
115132:     if (in->type() == MIRType_Int32) {
115132:         replace = MToString::New(in);
115132:     } else {
115132:         if (in->type() != MIRType_Value)
115132:             in = boxAt(def, in);
115132:         replace = MUnbox::New(in, MIRType_String, MUnbox::Fallible);
115132:     }
115132: 
112309:     def->block()->insertBefore(def, replace);
112309:     def->replaceOperand(0, replace);
112309:     return true;
112309: }
112309: 
112728: template <unsigned Op>
112728: bool
112728: IntPolicy<Op>::staticAdjustInputs(MInstruction *def)
112728: {
112728:     MDefinition *in = def->getOperand(Op);
112728:     if (in->type() == MIRType_Int32)
112728:         return true;
112728: 
112728:     MUnbox *replace = MUnbox::New(in, MIRType_Int32, MUnbox::Fallible);
112728:     def->block()->insertBefore(def, replace);
112728:     def->replaceOperand(Op, replace);
112728:     return true;
112728: }
112728: 
112733: template bool IntPolicy<0>::staticAdjustInputs(MInstruction *def);
112733: template bool IntPolicy<1>::staticAdjustInputs(MInstruction *def);
112733: 
112750: template <unsigned Op>
112750: bool
112750: DoublePolicy<Op>::staticAdjustInputs(MInstruction *def)
112750: {
112750:     MDefinition *in = def->getOperand(Op);
112750:     if (in->type() == MIRType_Double)
112750:         return true;
112750: 
116162:     // Force a bailout. Objects may be effectful; strings are currently unhandled.
116162:     if (in->type() == MIRType_Object || in->type() == MIRType_String) {
116162:         MBox *box = MBox::New(in);
116162:         def->block()->insertBefore(def, box);
116162: 
116162:         MUnbox *unbox = MUnbox::New(box, MIRType_Double, MUnbox::Fallible);
116162:         def->block()->insertBefore(def, unbox);
116162:         def->replaceOperand(Op, unbox);
116162:         return true;
116162:     }
116162: 
112750:     MToDouble *replace = MToDouble::New(in);
112750:     def->block()->insertBefore(def, replace);
112750:     def->replaceOperand(Op, replace);
112750:     return true;
112750: }
112750: 
112750: template bool DoublePolicy<0>::staticAdjustInputs(MInstruction *def);
112750: 
112859: template <unsigned Op>
112859: bool
112859: BoxPolicy<Op>::staticAdjustInputs(MInstruction *ins)
112859: {
112859:     MDefinition *in = ins->getOperand(Op);
112859:     if (in->type() == MIRType_Value)
112859:         return true;
112859: 
112859:     ins->replaceOperand(Op, boxAt(ins, in));
112859:     return true;
112859: }
112859: 
112859: template bool BoxPolicy<0>::staticAdjustInputs(MInstruction *ins);
112859: template bool BoxPolicy<1>::staticAdjustInputs(MInstruction *ins);
113388: template bool BoxPolicy<2>::staticAdjustInputs(MInstruction *ins);
112859: 
112859: template <unsigned Op>
112859: bool
112859: ObjectPolicy<Op>::staticAdjustInputs(MInstruction *ins)
112859: {
112859:     MDefinition *in = ins->getOperand(Op);
112859:     if (in->type() == MIRType_Object || in->type() == MIRType_Slots ||
113544:         in->type() == MIRType_Elements)
112859:     {
112859:         return true;
112859:     }
112859: 
112859:     if (in->type() != MIRType_Value)
112859:         in = boxAt(ins, in);
112859: 
112859:     MUnbox *replace = MUnbox::New(in, MIRType_Object, MUnbox::Fallible);
112859:     ins->block()->insertBefore(ins, replace);
112859:     ins->replaceOperand(Op, replace);
112859:     return true;
112859: }
112859: 
112859: template bool ObjectPolicy<0>::staticAdjustInputs(MInstruction *ins);
112859: template bool ObjectPolicy<1>::staticAdjustInputs(MInstruction *ins);
112859: 
112064: bool
112064: CallPolicy::adjustInputs(MInstruction *ins)
112064: {
112064:     MCall *call = ins->toCall();
112064: 
112064:     MDefinition *func = call->getFunction();
112064:     if (func->type() == MIRType_Object)
112064:         return true;
112064: 
112064:     // If the function is impossible to call,
112064:     // bail out by causing a subsequent unbox to fail.
112064:     if (func->type() != MIRType_Value)
112064:         func = boxAt(call, func);
112064: 
112118:     MInstruction *unbox = MUnbox::New(func, MIRType_Object, MUnbox::Fallible);
112064:     call->block()->insertBefore(call, unbox);
112064:     call->replaceFunction(unbox);
112064: 
112064:     return true;
112064: }
112064: 
112487: bool
112487: CallSetElementPolicy::adjustInputs(MInstruction *ins)
112487: {
112487:     // The first operand should be an object.
112691:     SingleObjectPolicy::adjustInputs(ins);
112487: 
112487:     // Box the index and value operands.
112487:     for (size_t i = 1; i < ins->numOperands(); i++) {
112487:         MDefinition *in = ins->getOperand(i);
112487:         if (in->type() == MIRType_Value)
112487:             continue;
112487:         ins->replaceOperand(i, boxAt(ins, in));
112487:     }
112487:     return true;
112487: }
112936: 
112936: bool
113170: InstanceOfPolicy::adjustInputs(MInstruction *def)
113170: {
113170:     // Box first operand if it isn't object
113170:     if (def->getOperand(0)->type() != MIRType_Object) {
113170:        BoxPolicy<0>::staticAdjustInputs(def);
113170:     }
113170: 
113170:     return true;
113170: }
113170: 
113170: bool
112936: StoreTypedArrayPolicy::adjustInputs(MInstruction *ins)
112936: {
112936:     MStoreTypedArrayElement *store = ins->toStoreTypedArrayElement();
112936:     JS_ASSERT(store->elements()->type() == MIRType_Elements);
112936:     JS_ASSERT(store->index()->type() == MIRType_Int32);
112936: 
112936:     int arrayType = store->arrayType();
112936:     MDefinition *value = store->value();
112936: 
112936:     // First, ensure the value is int32, boolean, double or Value.
112936:     // The conversion is based on TypedArrayTemplate::setElementTail.
112936:     switch (value->type()) {
112936:       case MIRType_Int32:
112936:       case MIRType_Double:
112936:       case MIRType_Boolean:
112936:       case MIRType_Value:
112936:         break;
112936:       case MIRType_Null:
125403:         value->setFoldedUnchecked();
112936:         value = MConstant::New(Int32Value(0));
112936:         ins->block()->insertBefore(ins, value->toInstruction());
112936:         break;
112936:       case MIRType_Object:
112936:       case MIRType_Undefined:
125403:         value->setFoldedUnchecked();
112936:         value = MConstant::New(DoubleValue(js_NaN));
112936:         ins->block()->insertBefore(ins, value->toInstruction());
112936:         break;
112936:       case MIRType_String:
112936:         value = boxAt(ins, value);
112936:         break;
112936:       default:
112936:         JS_NOT_REACHED("Unexpected type");
112936:         break;
112936:     }
112936: 
112936:     if (value != store->value())
112936:         ins->replaceOperand(2, value);
112936: 
112936:     JS_ASSERT(value->type() == MIRType_Int32 ||
112936:               value->type() == MIRType_Boolean ||
112936:               value->type() == MIRType_Double ||
112936:               value->type() == MIRType_Value);
112936: 
112936:     switch (arrayType) {
112936:       case TypedArray::TYPE_INT8:
112936:       case TypedArray::TYPE_UINT8:
112936:       case TypedArray::TYPE_INT16:
112936:       case TypedArray::TYPE_UINT16:
112936:       case TypedArray::TYPE_INT32:
112936:       case TypedArray::TYPE_UINT32:
112936:         if (value->type() != MIRType_Int32) {
112936:             value = MTruncateToInt32::New(value);
112936:             ins->block()->insertBefore(ins, value->toInstruction());
112936:         }
112936:         break;
112936:       case TypedArray::TYPE_UINT8_CLAMPED:
112936:         // IonBuilder should have inserted ClampToUint8.
112936:         JS_ASSERT(value->type() == MIRType_Int32);
112936:         break;
112936:       case TypedArray::TYPE_FLOAT32:
112936:       case TypedArray::TYPE_FLOAT64:
112936:         if (value->type() != MIRType_Double) {
112936:             value = MToDouble::New(value);
112936:             ins->block()->insertBefore(ins, value->toInstruction());
112936:         }
112936:         break;
112936:       default:
112936:         JS_NOT_REACHED("Invalid array type");
112936:         break;
112936:     }
112936: 
112936:     if (value != store->value())
112936:         ins->replaceOperand(2, value);
112936:     return true;
112936: }
112936: 
112936: bool
112936: ClampPolicy::adjustInputs(MInstruction *ins)
112936: {
112936:     MDefinition *in = ins->toClampToUint8()->input();
112936: 
112936:     switch (in->type()) {
112936:       case MIRType_Int32:
112936:       case MIRType_Double:
112936:       case MIRType_Value:
112936:         break;
112936:       default:
112936:         ins->replaceOperand(0, boxAt(ins, in));
112936:         break;
112936:     }
112936: 
112936:     return true;
112936: }
