49073: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
42611:  * ***** BEGIN LICENSE BLOCK *****
42611:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42611:  *
42611:  * The contents of this file are subject to the Mozilla Public License Version
42611:  * 1.1 (the "License"); you may not use this file except in compliance with
42611:  * the License. You may obtain a copy of the License at
42611:  * http://www.mozilla.org/MPL/
42611:  *
42611:  * Software distributed under the License is distributed on an "AS IS" basis,
42611:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42611:  * for the specific language governing rights and limitations under the
42611:  * License.
42611:  *
42611:  * The Original Code is Mozilla Corporation code.
42611:  *
42611:  * The Initial Developer of the Original Code is Mozilla Foundation.
42611:  * Portions created by the Initial Developer are Copyright (C) 2009
42611:  * the Initial Developer. All Rights Reserved.
42611:  *
42611:  * Contributor(s):
42611:  *   Bas Schouten <bschouten@mozilla.org>
42611:  *
42611:  * Alternatively, the contents of this file may be used under the terms of
42611:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42611:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42611:  * in which case the provisions of the GPL or the LGPL are applicable instead
42611:  * of those above. If you wish to allow use of your version of this file only
42611:  * under the terms of either the GPL or the LGPL, and not to allow others to
42611:  * use your version of this file under the terms of the MPL, indicate your
42611:  * decision by deleting the provisions above and replace them with the notice
42611:  * and other provisions required by the GPL or the LGPL. If you do not delete
42611:  * the provisions above, a recipient may use your version of this file under
42611:  * the terms of any one of the MPL, the GPL or the LGPL.
42611:  *
42611:  * ***** END LICENSE BLOCK ***** */
42611: 
72995: #include "mozilla/layers/PLayers.h"
72995: #include "mozilla/layers/ShadowLayers.h"
72995: #include "ShadowBufferD3D9.h"
72995: #include "gfxSharedImageSurface.h"
72995: 
42611: #include "ImageLayerD3D9.h"
72995: #include "ThebesLayerD3D9.h"
72995: #include "gfxPlatform.h"
42611: #include "gfxImageSurface.h"
42611: #include "yuv_convert.h"
51527: #include "nsIServiceManager.h" 
51527: #include "nsIConsoleService.h" 
51527: #include "Nv3DVUtils.h"
42611: 
42611: namespace mozilla {
42611: namespace layers {
42611: 
59531: static already_AddRefed<IDirect3DTexture9>
59531: SurfaceToTexture(IDirect3DDevice9 *aDevice,
59531:                  gfxASurface *aSurface,
59531:                  const gfxIntSize &aSize)
59531: {
62536: 
62536:   nsRefPtr<gfxImageSurface> imageSurface = aSurface->GetAsImageSurface();
62536: 
62536:   if (!imageSurface) {
62536:     imageSurface = new gfxImageSurface(aSize,
62536:                                        gfxASurface::ImageFormatARGB32);
59531:     
59531:     nsRefPtr<gfxContext> context = new gfxContext(imageSurface);
59531:     context->SetSource(aSurface);
62536:     context->SetOperator(gfxContext::OPERATOR_SOURCE);
59531:     context->Paint();
62536:   }
59531: 
59531:   nsRefPtr<IDirect3DTexture9> texture;
59531:   nsRefPtr<IDirect3DDevice9Ex> deviceEx;
59598:   aDevice->QueryInterface(IID_IDirect3DDevice9Ex,
59531:                           (void**)getter_AddRefs(deviceEx));
59531: 
59531:   if (deviceEx) {
59531:     // D3D9Ex doesn't support managed textures. We could use dynamic textures
59531:     // here but since Images are immutable that probably isn't such a great
59531:     // idea.
59531:     if (FAILED(aDevice->
59531:                CreateTexture(aSize.width, aSize.height,
59531:                              1, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT,
59531:                              getter_AddRefs(texture), NULL)))
59531:     {
59531:       return NULL;
59531:     }
59531: 
59531:     nsRefPtr<IDirect3DSurface9> surface;
59531:     if (FAILED(aDevice->
59531:                CreateOffscreenPlainSurface(aSize.width,
59531:                                            aSize.height,
59531:                                            D3DFMT_A8R8G8B8,
59531:                                            D3DPOOL_SYSTEMMEM,
59531:                                            getter_AddRefs(surface),
59531:                                            NULL)))
59531:     {
59531:       return NULL;
59531:     }
59531: 
59531:     D3DLOCKED_RECT lockedRect;
59531:     surface->LockRect(&lockedRect, NULL, 0);
59531:     for (int y = 0; y < aSize.height; y++) {
59531:       memcpy((char*)lockedRect.pBits + lockedRect.Pitch * y,
59531:              imageSurface->Data() + imageSurface->Stride() * y,
59531:              aSize.width * 4);
59531:     }
59531:     surface->UnlockRect();
59531:     nsRefPtr<IDirect3DSurface9> dstSurface;
59531:     texture->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
59531:     aDevice->UpdateSurface(surface, NULL, dstSurface, NULL);
59531:   } else {
59531:     if (FAILED(aDevice->
59531:                CreateTexture(aSize.width, aSize.height,
59531:                              1, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED,
59531:                              getter_AddRefs(texture), NULL)))
59531:     {
59531:       return NULL;
59531:     }
59531: 
59531:     D3DLOCKED_RECT lockrect;
59531:     /* lock the entire texture */
59531:     texture->LockRect(0, &lockrect, NULL, 0);
59531: 
59531:     // copy over data. If we don't need to do any swaping we can
59531:     // use memcpy
59531:     for (int y = 0; y < aSize.height; y++) {
59531:       memcpy((char*)lockrect.pBits + lockrect.Pitch * y,
59531:              imageSurface->Data() + imageSurface->Stride() * y,
59531:              aSize.width * 4);
59531:     }
59531: 
59531:     texture->UnlockRect(0);
59531:   }
59531: 
59531:   return texture.forget();
59531: }
59531: 
59719: ImageContainerD3D9::ImageContainerD3D9(IDirect3DDevice9 *aDevice)
59719:   : ImageContainer(nsnull)
59719:   , mDevice(aDevice)
42611: {
42611: }
42611: 
42611: already_AddRefed<Image>
42611: ImageContainerD3D9::CreateImage(const Image::Format *aFormats,
42611:                                PRUint32 aNumFormats)
42611: {
42611:   if (!aNumFormats) {
42611:     return nsnull;
42611:   }
42611:   nsRefPtr<Image> img;
42611:   if (aFormats[0] == Image::PLANAR_YCBCR) {
59535:     img = new PlanarYCbCrImageD3D9();
42611:   } else if (aFormats[0] == Image::CAIRO_SURFACE) {
59719:     img = new CairoImageD3D9(mDevice);
42611:   }
42611:   return img.forget();
42611: }
42611: 
42611: void
42611: ImageContainerD3D9::SetCurrentImage(Image *aImage)
42611: {
69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
42611: 
42611:   mActiveImage = aImage;
63615:   CurrentImageChanged();
42611: }
42611: 
42611: already_AddRefed<Image>
42611: ImageContainerD3D9::GetCurrentImage()
42611: {
69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
42611: 
42611:   nsRefPtr<Image> retval = mActiveImage;
42611:   return retval.forget();
42611: }
42611: 
42611: already_AddRefed<gfxASurface>
42611: ImageContainerD3D9::GetCurrentAsSurface(gfxIntSize *aSize)
42611: {
69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
42611:   if (!mActiveImage) {
42611:     return nsnull;
42611:   }
42611: 
42611:   if (mActiveImage->GetFormat() == Image::PLANAR_YCBCR) {
42611:     PlanarYCbCrImageD3D9 *yuvImage =
42611:       static_cast<PlanarYCbCrImageD3D9*>(mActiveImage.get());
42611:     if (yuvImage->HasData()) {
42611:       *aSize = yuvImage->mSize;
42611:     }
42611:   } else if (mActiveImage->GetFormat() == Image::CAIRO_SURFACE) {
42611:     CairoImageD3D9 *cairoImage =
42611:       static_cast<CairoImageD3D9*>(mActiveImage.get());
57896:     *aSize = cairoImage->GetSize();
42611:   }
42611: 
42611:   return static_cast<ImageD3D9*>(mActiveImage->GetImplData())->GetAsSurface();
42611: }
42611: 
42611: gfxIntSize
42611: ImageContainerD3D9::GetCurrentSize()
42611: {
69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
42611:   if (!mActiveImage) {
42611:     return gfxIntSize(0,0);
42611:   }
42611:   if (mActiveImage->GetFormat() == Image::PLANAR_YCBCR) {
42611:     PlanarYCbCrImageD3D9 *yuvImage =
42611:       static_cast<PlanarYCbCrImageD3D9*>(mActiveImage.get());
42611:     if (!yuvImage->HasData()) {
42611:       return gfxIntSize(0,0);
42611:     }
42611:     return yuvImage->mSize;
42611: 
42611:   } else if (mActiveImage->GetFormat() == Image::CAIRO_SURFACE) {
42611:     CairoImageD3D9 *cairoImage =
42611:       static_cast<CairoImageD3D9*>(mActiveImage.get());
57896:     return cairoImage->GetSize();
42611:   }
42611: 
42611:   return gfxIntSize(0,0);
42611: }
42611: 
79445: bool
49073: ImageContainerD3D9::SetLayerManager(LayerManager *aManager)
49073: {
59536:   if (aManager->GetBackendType() == LayerManager::LAYERS_D3D9) {
80486:     return true;
59536:   }
59536: 
80486:   return false;
49073: }
49073: 
42611: Layer*
42611: ImageLayerD3D9::GetLayer()
42611: {
42611:   return this;
42611: }
42611: 
42611: void
57097: ImageLayerD3D9::RenderLayer()
42611: {
42611:   if (!GetContainer()) {
42611:     return;
42611:   }
42611: 
42611:   nsRefPtr<Image> image = GetContainer()->GetCurrentImage();
60860:   if (!image) {
60860:     return;
60860:   }
42611: 
59536:   SetShaderTransformAndOpacity();
59536: 
59719:   if (GetContainer()->GetBackendType() != LayerManager::LAYERS_D3D9)
59715:   {
59536:     gfxIntSize size;
59536:     nsRefPtr<gfxASurface> surface =
59536:       GetContainer()->GetCurrentAsSurface(&size);
59536:     nsRefPtr<IDirect3DTexture9> texture =
59536:       SurfaceToTexture(device(), surface, size);
59536: 
59536:     device()->SetVertexShaderConstantF(CBvLayerQuad,
59536:                                        ShaderConstantRect(0,
59536:                                                           0,
59536:                                                           size.width,
59536:                                                           size.height),
59536:                                        1);
59536: 
59536:     if (surface->GetContentType() == gfxASurface::CONTENT_COLOR_ALPHA) {
59536:       mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBALAYER);
59536:     } else {
59536:       mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBLAYER);
59536:     }
59536: 
59536:     device()->SetTexture(0, texture);
59536:     device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
59536:   } else if (image->GetFormat() == Image::PLANAR_YCBCR) {
42611:     PlanarYCbCrImageD3D9 *yuvImage =
42611:       static_cast<PlanarYCbCrImageD3D9*>(image.get());
42611: 
42611:     if (!yuvImage->HasData()) {
42611:       return;
42611:     }
59535:     yuvImage->AllocateTextures(device());
42611: 
54880:     device()->SetVertexShaderConstantF(CBvLayerQuad,
54880:                                        ShaderConstantRect(0,
54880:                                                           0,
54880:                                                           yuvImage->mSize.width,
54880:                                                           yuvImage->mSize.height),
54880:                                        1);
42611: 
73015:     device()->SetVertexShaderConstantF(CBvTextureCoords,
73015:       ShaderConstantRect(
73015:         (float)yuvImage->mData.mPicX / yuvImage->mData.mYSize.width,
73015:         (float)yuvImage->mData.mPicY / yuvImage->mData.mYSize.height,
73015:         (float)yuvImage->mData.mPicSize.width / yuvImage->mData.mYSize.width,
73015:         (float)yuvImage->mData.mPicSize.height / yuvImage->mData.mYSize.height
73015:       ),
73015:       1);
73015: 
49316:     mD3DManager->SetShaderMode(DeviceManagerD3D9::YCBCRLAYER);
42611: 
60419:     /*
60419:      * Send 3d control data and metadata
60419:      */
60419:     if (mD3DManager->GetNv3DVUtils()) {
59431:       Nv_Stereo_Mode mode;
59431:       switch (yuvImage->mData.mStereoMode) {
59431:       case STEREO_MODE_LEFT_RIGHT:
59431:         mode = NV_STEREO_MODE_LEFT_RIGHT;
59431:         break;
59431:       case STEREO_MODE_RIGHT_LEFT:
59431:         mode = NV_STEREO_MODE_RIGHT_LEFT;
59431:         break;
59431:       case STEREO_MODE_BOTTOM_TOP:
59431:         mode = NV_STEREO_MODE_BOTTOM_TOP;
59431:         break;
59431:       case STEREO_MODE_TOP_BOTTOM:
59431:         mode = NV_STEREO_MODE_TOP_BOTTOM;
59431:         break;
60419:       case STEREO_MODE_MONO:
60419:         mode = NV_STEREO_MODE_MONO;
60419:         break;
59431:       }
59431: 
60419:       // Send control data even in mono case so driver knows to leave stereo mode.
60419:       mD3DManager->GetNv3DVUtils()->SendNv3DVControl(mode, true, FIREFOX_3DV_APP_HANDLE);
60419: 
60419:       if (yuvImage->mData.mStereoMode != STEREO_MODE_MONO) {
59431:         mD3DManager->GetNv3DVUtils()->SendNv3DVControl(mode, true, FIREFOX_3DV_APP_HANDLE);
51527: 
51527:         nsRefPtr<IDirect3DSurface9> renderTarget;
51527:         device()->GetRenderTarget(0, getter_AddRefs(renderTarget));
51527:         mD3DManager->GetNv3DVUtils()->SendNv3DVMetaData((unsigned int)yuvImage->mSize.width,
51527:                                                         (unsigned int)yuvImage->mSize.height, (HANDLE)(yuvImage->mYTexture), (HANDLE)(renderTarget));
51527:       }
59431:     }
51527: 
59728:     // Linear scaling is default here, adhering to mFilter is difficult since
59728:     // presumably even with point filtering we'll still want chroma upsampling
59728:     // to be linear. In the current approach we can't.
42611:     device()->SetTexture(0, yuvImage->mYTexture);
42611:     device()->SetTexture(1, yuvImage->mCbTexture);
42611:     device()->SetTexture(2, yuvImage->mCrTexture);
42611: 
42611:     device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
42611: 
73015:     device()->SetVertexShaderConstantF(CBvTextureCoords,
73015:       ShaderConstantRect(0, 0, 1.0f, 1.0f), 1);
73015: 
42611:   } else if (image->GetFormat() == Image::CAIRO_SURFACE) {
42611:     CairoImageD3D9 *cairoImage =
42611:       static_cast<CairoImageD3D9*>(image.get());
59719:     ImageContainerD3D9 *container =
59719:       static_cast<ImageContainerD3D9*>(GetContainer());
59719: 
59719:     if (container->device() != device()) {
59719:       // Ensure future images get created with the right device.
59719:       container->SetDevice(device());
59719:     }
42611: 
59532:     if (cairoImage->device() != device()) {
59532:       cairoImage->SetDevice(device());
59532:     }
42611: 
54880:     device()->SetVertexShaderConstantF(CBvLayerQuad,
54880:                                        ShaderConstantRect(0,
54880:                                                           0,
57896:                                                           cairoImage->GetSize().width,
57896:                                                           cairoImage->GetSize().height),
54880:                                        1);
42611: 
59533:     if (cairoImage->HasAlpha()) {
51963:       mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBALAYER);
59533:     } else {
59533:       mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBLAYER);
59533:     }
42611: 
59728:     if (mFilter == gfxPattern::FILTER_NEAREST) {
59728:       device()->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);
59728:       device()->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);
59728:     }
57896:     device()->SetTexture(0, cairoImage->GetOrCreateTexture());
42611:     device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
59728:     if (mFilter == gfxPattern::FILTER_NEAREST) {
59728:       device()->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
59728:       device()->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
59728:     }
42611:   }
63615: 
63615:   GetContainer()->NotifyPaintedImage(image);
42611: }
42611: 
59535: PlanarYCbCrImageD3D9::PlanarYCbCrImageD3D9()
42611:   : PlanarYCbCrImage(static_cast<ImageD3D9*>(this))
74548:   , mBufferSize(0)
80486:   , mHasData(false)
42611: {
42611: }
42611: 
42611: void
42611: PlanarYCbCrImageD3D9::SetData(const PlanarYCbCrImage::Data &aData)
42611: {
74548:   mBuffer = CopyData(mData, mSize, mBufferSize, aData);
42611: 
80486:   mHasData = true;
42611: }
42611: 
42611: void
59535: PlanarYCbCrImageD3D9::AllocateTextures(IDirect3DDevice9 *aDevice)
42611: {
49317:   D3DLOCKED_RECT lockrectY;
49317:   D3DLOCKED_RECT lockrectCb;
49317:   D3DLOCKED_RECT lockrectCr;
42611:   PRUint8* src;
42611:   PRUint8* dest;
49317: 
49317:   nsRefPtr<IDirect3DSurface9> tmpSurfaceY;
49317:   nsRefPtr<IDirect3DSurface9> tmpSurfaceCb;
49317:   nsRefPtr<IDirect3DSurface9> tmpSurfaceCr;
49317: 
59535:   nsRefPtr<IDirect3DDevice9Ex> deviceEx;
59598:   aDevice->QueryInterface(IID_IDirect3DDevice9Ex,
59535:                           getter_AddRefs(deviceEx));
59535: 
59535:   bool isD3D9Ex = deviceEx;
59535: 
59535:   if (isD3D9Ex) {
49705:     nsRefPtr<IDirect3DTexture9> tmpYTexture;
49705:     nsRefPtr<IDirect3DTexture9> tmpCbTexture;
49705:     nsRefPtr<IDirect3DTexture9> tmpCrTexture;
49317:     // D3D9Ex does not support the managed pool, could use dynamic textures
49317:     // here. But since an Image is immutable static textures are probably a
49317:     // better idea.
81355: 
81355:     HRESULT hr;
81355:     hr = aDevice->CreateTexture(mData.mYSize.width, mData.mYSize.height,
49317:                                 1, 0, D3DFMT_L8, D3DPOOL_DEFAULT,
49317:                                 getter_AddRefs(mYTexture), NULL);
81355:     if (!FAILED(hr)) {
81355:       hr = aDevice->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49317:                                   1, 0, D3DFMT_L8, D3DPOOL_DEFAULT,
49317:                                   getter_AddRefs(mCbTexture), NULL);
81355:     }
81355:     if (!FAILED(hr)) {
81355:       hr = aDevice->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49317:                                   1, 0, D3DFMT_L8, D3DPOOL_DEFAULT,
49317:                                   getter_AddRefs(mCrTexture), NULL);
81355:     }
81355:     if (!FAILED(hr)) {
81355:       hr = aDevice->CreateTexture(mData.mYSize.width, mData.mYSize.height,
49705:                                   1, 0, D3DFMT_L8, D3DPOOL_SYSTEMMEM,
49705:                                   getter_AddRefs(tmpYTexture), NULL);
81355:     }
81355:     if (!FAILED(hr)) {
81355:       hr = aDevice->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49705:                                   1, 0, D3DFMT_L8, D3DPOOL_SYSTEMMEM,
49705:                                   getter_AddRefs(tmpCbTexture), NULL);
81355:     }
81355:     if (!FAILED(hr)) {
81355:       hr = aDevice->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49705:                                   1, 0, D3DFMT_L8, D3DPOOL_SYSTEMMEM,
49705:                                   getter_AddRefs(tmpCrTexture), NULL);
81355:     }
81355: 
81355:     if (FAILED(hr)) {
81355:       mManager->ReportFailure(NS_LITERAL_CSTRING("PlanarYCbCrImageD3D9::AllocateTextures(): Failed to create texture (isD3D9Ex)"),
81355:                               hr);
81355:       return;
81355:     }
81355: 
49705:     tmpYTexture->GetSurfaceLevel(0, getter_AddRefs(tmpSurfaceY));
49705:     tmpCbTexture->GetSurfaceLevel(0, getter_AddRefs(tmpSurfaceCb));
49705:     tmpCrTexture->GetSurfaceLevel(0, getter_AddRefs(tmpSurfaceCr));
49317:     tmpSurfaceY->LockRect(&lockrectY, NULL, 0);
49317:     tmpSurfaceCb->LockRect(&lockrectCb, NULL, 0);
49317:     tmpSurfaceCr->LockRect(&lockrectCr, NULL, 0);
49317:   } else {
81355:     HRESULT hr;
81355:     hr = aDevice->CreateTexture(mData.mYSize.width, mData.mYSize.height,
42611:                                 1, 0, D3DFMT_L8, D3DPOOL_MANAGED,
42611:                                 getter_AddRefs(mYTexture), NULL);
81355:     if (!FAILED(hr)) {
59535:       aDevice->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49317:                              1, 0, D3DFMT_L8, D3DPOOL_MANAGED,
49317:                              getter_AddRefs(mCbTexture), NULL);
81355:     }
81355:     if (!FAILED(hr)) {
59535:       aDevice->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49317:                              1, 0, D3DFMT_L8, D3DPOOL_MANAGED,
49317:                              getter_AddRefs(mCrTexture), NULL);
81355:     }
81355: 
81355:     if (FAILED(hr)) {
81355:       mManager->ReportFailure(NS_LITERAL_CSTRING("PlanarYCbCrImageD3D9::AllocateTextures(): Failed to create texture (!isD3D9Ex)"),
81355:                               hr);
81355:       return;
81355:     }
42611: 
42611:     /* lock the entire texture */
49317:     mYTexture->LockRect(0, &lockrectY, NULL, 0);
49317:     mCbTexture->LockRect(0, &lockrectCb, NULL, 0);
49317:     mCrTexture->LockRect(0, &lockrectCr, NULL, 0);
49317:   }
42611: 
42611:   src  = mData.mYChannel;
42611:   //FIX cast
49317:   dest = (PRUint8*)lockrectY.pBits;
42611: 
42611:   // copy over data
42611:   for (int h=0; h<mData.mYSize.height; h++) {
42611:     memcpy(dest, src, mData.mYSize.width);
49317:     dest += lockrectY.Pitch;
42611:     src += mData.mYStride;
42611:   }
42611: 
42611:   src  = mData.mCbChannel;
42611:   //FIX cast
49317:   dest = (PRUint8*)lockrectCb.pBits;
42611: 
42611:   // copy over data
42611:   for (int h=0; h<mData.mCbCrSize.height; h++) {
42611:     memcpy(dest, src, mData.mCbCrSize.width);
49317:     dest += lockrectCb.Pitch;
42611:     src += mData.mCbCrStride;
42611:   }
42611: 
42611:   src  = mData.mCrChannel;
42611:   //FIX cast
49317:   dest = (PRUint8*)lockrectCr.pBits;
42611: 
42611:   // copy over data
42611:   for (int h=0; h<mData.mCbCrSize.height; h++) {
42611:     memcpy(dest, src, mData.mCbCrSize.width);
49317:     dest += lockrectCr.Pitch;
42611:     src += mData.mCbCrStride;
42611:   }
42611: 
59535:   if (isD3D9Ex) {
49317:     tmpSurfaceY->UnlockRect();
49317:     tmpSurfaceCb->UnlockRect();
49317:     tmpSurfaceCr->UnlockRect();
49317:     nsRefPtr<IDirect3DSurface9> dstSurface;
49317:     mYTexture->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
59535:     aDevice->UpdateSurface(tmpSurfaceY, NULL, dstSurface, NULL);
49317:     mCbTexture->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
59535:     aDevice->UpdateSurface(tmpSurfaceCb, NULL, dstSurface, NULL);
49317:     mCrTexture->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
59535:     aDevice->UpdateSurface(tmpSurfaceCr, NULL, dstSurface, NULL);
49317:   } else {
49317:     mYTexture->UnlockRect(0);
49317:     mCbTexture->UnlockRect(0);
42611:     mCrTexture->UnlockRect(0);
49317:   }
42611: }
42611: 
42611: void
42611: PlanarYCbCrImageD3D9::FreeTextures()
42611: {
42611: }
42611: 
42611: already_AddRefed<gfxASurface>
42611: PlanarYCbCrImageD3D9::GetAsSurface()
42611: {
42611:   nsRefPtr<gfxImageSurface> imageSurface =
42611:     new gfxImageSurface(mSize, gfxASurface::ImageFormatRGB24);
42611:   
73015:   gfx::YUVType type = 
73015:     gfx::TypeFromSize(mData.mYSize.width,
73015:                       mData.mYSize.height,
73015:                       mData.mCbCrSize.width,
73015:                       mData.mCbCrSize.height);
73015: 
42611:   // Convert from YCbCr to RGB now
42611:   gfx::ConvertYCbCrToRGB32(mData.mYChannel,
42611:                            mData.mCbChannel,
42611:                            mData.mCrChannel,
42611:                            imageSurface->Data(),
73015:                            mData.mPicX,
73015:                            mData.mPicY,
73015:                            mData.mPicSize.width,
73015:                            mData.mPicSize.height,
42611:                            mData.mYStride,
42611:                            mData.mCbCrStride,
42611:                            imageSurface->Stride(),
73015:                            type);
42611: 
42611:   return imageSurface.forget().get();
42611: }
42611: 
42611: CairoImageD3D9::~CairoImageD3D9()
42611: {
42611: }
42611: 
42611: void
59532: CairoImageD3D9::SetDevice(IDirect3DDevice9 *aDevice)
59532: {
59532:   mTexture = NULL;
59532:   mDevice = aDevice;
59532: }
59532: 
59532: void
42611: CairoImageD3D9::SetData(const CairoImage::Data &aData)
42611: {
42611:   mSize = aData.mSize;
57896:   mCachedSurface = aData.mSurface;
57896:   mTexture = NULL;
57896: }
57896: 
57896: IDirect3DTexture9*
57896: CairoImageD3D9::GetOrCreateTexture()
57896: {
57896:   if (mTexture)
57896:     return mTexture;
42611: 
59531:   mTexture = SurfaceToTexture(mDevice, mCachedSurface, mSize);
42611: 
59532:   // We need to keep our cached surface around in case the device changes.
57896:   return mTexture;
49317: }
42611: 
42611: already_AddRefed<gfxASurface>
42611: CairoImageD3D9::GetAsSurface()
42611: {
59534:   nsRefPtr<gfxASurface> surface = mCachedSurface;
59534:   return surface.forget();
42611: }
42611: 
72995: ShadowImageLayerD3D9::ShadowImageLayerD3D9(LayerManagerD3D9* aManager)
72995:   : ShadowImageLayer(aManager, nsnull)
72995:   , LayerD3D9(aManager)
72995: {
72995:   mImplData = static_cast<LayerD3D9*>(this);
72995: }  
72995: 
72995: ShadowImageLayerD3D9::~ShadowImageLayerD3D9()
72995: {}
72995: 
79425: void
79425: ShadowImageLayerD3D9::Swap(const SharedImage& aNewFront,
79425:                            SharedImage* aNewBack)
72995: {
79425:   if (aNewFront.type() == SharedImage::TSurfaceDescriptor) {
72995:     if (!mBuffer) {
72995:       mBuffer = new ShadowBufferD3D9(this);
72995:     }
72995:     nsRefPtr<gfxASurface> surf =
72995:       ShadowLayerForwarder::OpenDescriptor(aNewFront.get_SurfaceDescriptor());
72995: 
72995:     mBuffer->Upload(surf, GetVisibleRegion().GetBounds());
72995:   } else {
72995:     const YUVImage& yuv = aNewFront.get_YUVImage();
72995: 
72995:     nsRefPtr<gfxSharedImageSurface> surfY =
72995:       gfxSharedImageSurface::Open(yuv.Ydata());
72995:     nsRefPtr<gfxSharedImageSurface> surfU =
72995:       gfxSharedImageSurface::Open(yuv.Udata());
72995:     nsRefPtr<gfxSharedImageSurface> surfV =
72995:       gfxSharedImageSurface::Open(yuv.Vdata());
72995: 
72995:     PlanarYCbCrImage::Data data;
72995:     data.mYChannel = surfY->Data();
72995:     data.mYStride = surfY->Stride();
72995:     data.mYSize = surfY->GetSize();
72995:     data.mCbChannel = surfU->Data();
72995:     data.mCrChannel = surfV->Data();
72995:     data.mCbCrStride = surfU->Stride();
72995:     data.mCbCrSize = surfU->GetSize();
72995:     data.mPicSize = surfY->GetSize();
72995:     data.mPicX = 0;
72995:     data.mPicY = 0;
72995: 
79425:     if (!mYCbCrImage) {
79425:       mYCbCrImage = new PlanarYCbCrImageD3D9();
79425:     }
79425: 
72995:     mYCbCrImage->SetData(data);
72995: 
72995:   }
72995:   
72995:   *aNewBack = aNewFront;
72995: }
72995: 
72995: void
72995: ShadowImageLayerD3D9::Disconnect()
72995: {
72995:   Destroy();
72995: }
72995: 
72995: void
72995: ShadowImageLayerD3D9::Destroy()
72995: {
72995:   mBuffer = nsnull;
72995:   mYCbCrImage = nsnull;
72995: }
72995: 
72995: Layer*
72995: ShadowImageLayerD3D9::GetLayer()
72995: {
72995:   return this;
72995: }
72995: 
72995: void
72995: ShadowImageLayerD3D9::RenderLayer()
72995: {
72995:   if (mBuffer) {
72995:     mBuffer->RenderTo(mD3DManager, GetEffectiveVisibleRegion());
72995:   } else if (mYCbCrImage) {
72995:     if (!mYCbCrImage->HasData()) {
72995:       return;
72995:     }
72995:     
72995:     mYCbCrImage->AllocateTextures(device());
72995: 
72995:     SetShaderTransformAndOpacity();
72995: 
72995:     device()->SetVertexShaderConstantF(CBvLayerQuad,
72995:                                        ShaderConstantRect(0,
72995:                                                           0,
72995:                                                           mYCbCrImage->mSize.width,
72995:                                                           mYCbCrImage->mSize.height),
72995:                                        1);
72995: 
72995:     mD3DManager->SetShaderMode(DeviceManagerD3D9::YCBCRLAYER);
72995: 
72995:     /*
72995:      * Send 3d control data and metadata
72995:      */
72995:     if (mD3DManager->GetNv3DVUtils()) {
72995:       // TODO Add 3D support
72995:     }
72995: 
72995:     // Linear scaling is default here, adhering to mFilter is difficult since
72995:     // presumably even with point filtering we'll still want chroma upsampling
72995:     // to be linear. In the current approach we can't.
72995:     device()->SetTexture(0, mYCbCrImage->mYTexture);
72995:     device()->SetTexture(1, mYCbCrImage->mCbTexture);
72995:     device()->SetTexture(2, mYCbCrImage->mCrTexture);
72995: 
72995:     device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
72995:   } else {
72995:     NS_ERROR("Unexpected image format.");
72995:   }
72995: 
72995: }
72995: 
72995: 
42611: } /* layers */
42611: } /* mozilla */
