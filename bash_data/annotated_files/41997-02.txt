35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
35893: #ifndef dom_plugins_PluginInstanceChild_h
35893: #define dom_plugins_PluginInstanceChild_h 1
35740: 
35898: #include "mozilla/plugins/PPluginInstanceChild.h"
35893: #include "mozilla/plugins/PluginScriptableObjectChild.h"
36138: #include "mozilla/plugins/StreamNotifyChild.h"
36124: #if defined(OS_WIN)
36124: #include "mozilla/gfx/SharedDIBWin.h"
41029: #elif defined(OS_MACOSX)
41029: #include "nsCoreAnimationSupport.h"
41029: #include "base/timer.h"
36124: #endif
35740: 
35740: #include "npfunctions.h"
35925: #include "nsAutoPtr.h"
35925: #include "nsTArray.h"
37348: #include "ChildAsyncCall.h"
37348: #include "ChildTimer.h"
38281: #include "nsRect.h"
38669: #include "nsTHashtable.h"
35740: 
35740: namespace mozilla {
35740: namespace plugins {
35740: 
35898: class PBrowserStreamChild;
35898: class BrowserStreamChild;
39283: class StreamNotifyChild;
35897: 
35898: class PluginInstanceChild : public PPluginInstanceChild
35740: {
35938:     friend class BrowserStreamChild;
35938:     friend class PluginStreamChild;
39283:     friend class StreamNotifyChild; 
35938: 
35747: #ifdef OS_WIN
35747:     friend LRESULT CALLBACK PluginWindowProc(HWND hWnd,
35747:                                              UINT message,
35747:                                              WPARAM wParam,
35747:                                              LPARAM lParam);
35747: #endif
35747: 
35746: protected:
39279:     virtual bool AnswerNPP_SetWindow(const NPRemoteWindow& window);
35746: 
35951:     virtual bool
35951:     AnswerNPP_GetValue_NPPVpluginNeedsXEmbed(bool* needs, NPError* rv);
35926:     virtual bool
35925:     AnswerNPP_GetValue_NPPVpluginScriptableNPObject(PPluginScriptableObjectChild** value,
35925:                                                     NPError* result);
35740: 
35933:     virtual bool
37350:     AnswerNPP_SetValue_NPNVprivateModeBool(const bool& value, NPError* result);
37350: 
37350:     virtual bool
36011:     AnswerNPP_HandleEvent(const NPRemoteEvent& event, int16_t* handled);
39883:     virtual bool
39883:     AnswerNPP_HandleEvent_Shmem(const NPRemoteEvent& event, Shmem& mem, int16_t* handled, Shmem* rtnmem);
41029:     virtual bool
41029:     AnswerNPP_HandleEvent_IOSurface(const NPRemoteEvent& event, const uint32_t& surface, int16_t* handled);
35933: 
39265:     NS_OVERRIDE
39265:     virtual bool
39265:     AnswerPaint(const NPRemoteEvent& event, int16_t* handled)
39265:     {
39265:         return AnswerNPP_HandleEvent(event, handled);
39265:     }
39265: 
39720:     NS_OVERRIDE
39720:     virtual bool
39720:     RecvWindowPosChanged(const NPRemoteEvent& event);
39720: 
37311:     virtual bool
37311:     AnswerNPP_Destroy(NPError* result);
37311: 
35898:     virtual PPluginScriptableObjectChild*
35943:     AllocPPluginScriptableObject();
35835: 
35926:     virtual bool
35943:     DeallocPPluginScriptableObject(PPluginScriptableObjectChild* aObject);
35835: 
38994:     NS_OVERRIDE virtual bool
38994:     RecvPPluginScriptableObjectConstructor(PPluginScriptableObjectChild* aActor);
35965: 
35898:     virtual PBrowserStreamChild*
35943:     AllocPBrowserStream(const nsCString& url,
35893:                         const uint32_t& length,
35890:                         const uint32_t& lastmodified,
35990:                         PStreamNotifyChild* notifyData,
35890:                         const nsCString& headers,
35893:                         const nsCString& mimeType,
35893:                         const bool& seekable,
35893:                         NPError* rv,
35893:                         uint16_t *stype);
35890: 
35926:     virtual bool
37126:     AnswerPBrowserStreamConstructor(
37126:             PBrowserStreamChild* aActor,
37126:             const nsCString& url,
37126:             const uint32_t& length,
37126:             const uint32_t& lastmodified,
37126:             PStreamNotifyChild* notifyData,
37126:             const nsCString& headers,
37126:             const nsCString& mimeType,
37126:             const bool& seekable,
37126:             NPError* rv,
37126:             uint16_t* stype);
37126:         
37126:     virtual bool
36138:     DeallocPBrowserStream(PBrowserStreamChild* stream);
35890: 
35938:     virtual PPluginStreamChild*
35943:     AllocPPluginStream(const nsCString& mimeType,
35938:                        const nsCString& target,
35938:                        NPError* result);
35938: 
35938:     virtual bool
36138:     DeallocPPluginStream(PPluginStreamChild* stream);
35938: 
35904:     virtual PStreamNotifyChild*
35943:     AllocPStreamNotify(const nsCString& url, const nsCString& target,
35904:                        const bool& post, const nsCString& buffer,
35904:                        const bool& file,
35904:                        NPError* result);
35904: 
36110:     NS_OVERRIDE virtual bool
36138:     DeallocPStreamNotify(PStreamNotifyChild* notifyData);
35904: 
37550:     virtual bool
37550:     AnswerSetPluginFocus();
37550: 
37554:     virtual bool
37554:     AnswerUpdateWindow();
37554: 
35740: public:
38660:     PluginInstanceChild(const NPPluginFuncs* aPluginIface, const nsCString& aMimeType);
35740: 
35893:     virtual ~PluginInstanceChild();
35740: 
35747:     bool Initialize();
35740: 
35740:     NPP GetNPP()
35740:     {
35740:         return &mData;
35740:     }
35740: 
35893:     NPError
35951:     NPN_GetValue(NPNVariable aVariable, void* aValue);
35951: 
35951:     NPError
35951:     NPN_SetValue(NPPVariable aVariable, void* aValue);
35740: 
35925:     PluginScriptableObjectChild*
35945:     GetActorForNPObject(NPObject* aObject);
35925: 
35938:     NPError
35938:     NPN_NewStream(NPMIMEType aMIMEType, const char* aWindow,
35938:                   NPStream** aStream);
35938: 
36835:     void InvalidateRect(NPRect* aInvalidRect);
36082: 
37348:     uint32_t ScheduleTimer(uint32_t interval, bool repeat, TimerFunc func);
37348:     void UnscheduleTimer(uint32_t id);
37348: 
39979:     void AsyncCall(PluginThreadCallback aFunc, void* aUserData);
39979: 
35740: private:
38669:     friend class PluginModuleChild;
38669: 
38660:     // Quirks mode support for various plugin mime types
38660:     enum PluginQuirks {
39729:         // Win32: Translate mouse input based on WM_WINDOWPOSCHANGED
39729:         // windowing events due to winless shared dib rendering. See
39729:         // WinlessHandleEvent for details.
41342:         QUIRK_SILVERLIGHT_WINLESS_INPUT_TRANSLATION     = 1 << 0,
39729:         // Win32: Hook TrackPopupMenu api so that we can swap out parent
39729:         // hwnds. The api will fail with parents not associated with our
39729:         // child ui thread. See WinlessHandleEvent for details.
41342:         QUIRK_WINLESS_TRACKPOPUP_HOOK                   = 1 << 1,
41342:         // Win32: Throttle flash WM_USER+1 heart beat messages to prevent
41342:         // flooding chromium's dispatch loop, which can cause ipc traffic
41342:         // processing lag.
41342:         QUIRK_FLASH_THROTTLE_WMUSER_EVENTS              = 1 << 2,
38660:     };
38660: 
38660:     void InitQuirksModes(const nsCString& aMimeType);
35747: 
38354:     NPError
38354:     InternalGetNPObjectForValue(NPNVariable aValue,
38354:                                 NPObject** aObject);
38354: 
35747: #if defined(OS_WIN)
35747:     static bool RegisterWindowClass();
35747:     bool CreatePluginWindow();
35747:     void DestroyPluginWindow();
35747:     void ReparentPluginWindow(HWND hWndParent);
35747:     void SizePluginWindow(int width, int height);
38103:     int16_t WinlessHandleEvent(NPEvent& event);
39729:     void CreateWinlessPopupSurrogate();
39729:     void DestroyWinlessPopupSurrogate();
39729:     void InitPopupMenuHook();
41342:     void SetupFlashMsgThrottle();
41997:     void UnhookWinlessFlashThrottle();
41342:     void FlashThrottleMessage(HWND, UINT, WPARAM, LPARAM, bool);
35747:     static LRESULT CALLBACK DummyWindowProc(HWND hWnd,
35747:                                             UINT message,
35747:                                             WPARAM wParam,
35747:                                             LPARAM lParam);
35747:     static LRESULT CALLBACK PluginWindowProc(HWND hWnd,
35747:                                              UINT message,
35747:                                              WPARAM wParam,
35747:                                              LPARAM lParam);
39729:     static BOOL WINAPI TrackPopupHookProc(HMENU hMenu,
39729:                                           UINT uFlags,
39729:                                           int x,
39729:                                           int y,
39729:                                           int nReserved,
39729:                                           HWND hWnd,
39729:                                           CONST RECT *prcRect);
41342:     static BOOL CALLBACK EnumThreadWindowsCallback(HWND hWnd,
41342:                                                    LPARAM aParam);
41342:     static LRESULT CALLBACK WinlessHiddenFlashWndProc(HWND hWnd,
41342:                                                       UINT message,
41342:                                                       WPARAM wParam,
41342:                                                       LPARAM lParam);
41342: 
41342:     class FlashThrottleAsyncMsg : public ChildAsyncCall
41342:     {
41342:       public:
41342:         FlashThrottleAsyncMsg();
41342:         FlashThrottleAsyncMsg(PluginInstanceChild* aInst, 
41342:                               HWND aWnd, UINT aMsg,
41342:                               WPARAM aWParam, LPARAM aLParam,
41342:                               bool isWindowed)
41342:           : ChildAsyncCall(aInst, nsnull, nsnull),
41342:           mWnd(aWnd),
41342:           mMsg(aMsg),
41342:           mWParam(aWParam),
41342:           mLParam(aLParam),
41342:           mWindowed(isWindowed)
41342:         {}
41342: 
41342:         NS_OVERRIDE void Run();
41342: 
41342:         WNDPROC GetProc();
41342:         HWND GetWnd() { return mWnd; }
41342:         UINT GetMsg() { return mMsg; }
41342:         WPARAM GetWParam() { return mWParam; }
41342:         LPARAM GetLParam() { return mLParam; }
41342: 
41342:       private:
41342:         HWND                 mWnd;
41342:         UINT                 mMsg;
41342:         WPARAM               mWParam;
41342:         LPARAM               mLParam;
41342:         bool                 mWindowed;
41342:     };
41342: 
35747: #endif
35747: 
35740:     const NPPluginFuncs* mPluginIface;
35740:     NPP_t mData;
35740:     NPWindow mWindow;
38660:     int mQuirks;
37311: 
38354:     // Cached scriptable actors to avoid IPC churn
38354:     PluginScriptableObjectChild* mCachedWindowActor;
38354:     PluginScriptableObjectChild* mCachedElementActor;
38354: 
35980: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35740:     NPSetWindowCallbackStruct mWsInfo;
35747: #elif defined(OS_WIN)
35747:     HWND mPluginWindowHWND;
35747:     WNDPROC mPluginWndProc;
35747:     HWND mPluginParentHWND;
38103:     int mNestedEventLevelDepth;
38103:     HWND mCachedWinlessPluginHWND;
39729:     HWND mWinlessPopupSurrogateHWND;
38281:     nsIntPoint mPluginSize;
38660:     nsIntPoint mPluginOffset;
41342:     WNDPROC mWinlessThrottleOldWndProc;
41997:     HWND mWinlessHiddenMsgHWND;
35746: #endif
35925: 
37348:     friend class ChildAsyncCall;
39979: 
39979:     Mutex mAsyncCallMutex;
37348:     nsTArray<ChildAsyncCall*> mPendingAsyncCalls;
37884:     nsTArray<nsAutoPtr<ChildTimer> > mTimers;
37348: 
38669:     /**
38669:      * During destruction we enumerate all remaining scriptable objects and
38669:      * invalidate/delete them. Enumeration can re-enter, so maintain a
38669:      * hash separate from PluginModuleChild.mObjectMap.
38669:      */
38669:     nsAutoPtr< nsTHashtable<DeletingObjectEntry> > mDeletingHash;
38669: 
36124: #if defined(OS_WIN)
36124: private:
36124:     // Shared dib rendering management for windowless plugins.
39279:     bool SharedSurfaceSetWindow(const NPRemoteWindow& aWindow);
36270:     int16_t SharedSurfacePaint(NPEvent& evcopy);
36124:     void SharedSurfaceRelease();
36270:     bool AlphaExtractCacheSetup();
36270:     void AlphaExtractCacheRelease();
36270:     void UpdatePaintClipRect(RECT* aRect);
36124: 
36124: private:
36270:     enum {
36270:       RENDER_NATIVE,
36270:       RENDER_BACK_ONE,
36270:       RENDER_BACK_TWO 
36270:     };
36124:     gfx::SharedDIBWin mSharedSurfaceDib;
36270:     struct {
36270:       PRUint32        doublePassEvent;
36270:       PRUint16        doublePass;
36270:       HDC             hdc;
36270:       HBITMAP         bmp;
36270:     } mAlphaExtract;
36124: #endif // defined(OS_WIN)
40120: #if defined(OS_MACOSX)
40120: private:
40120:     CGColorSpaceRef mShColorSpace;
40120:     CGContextRef    mShContext;
41029:     int16_t         mDrawingModel;
41029:     nsCARenderer    mCARenderer;
40120: #endif
35740: };
35740: 
35740: } // namespace plugins
35740: } // namespace mozilla
35740: 
35893: #endif // ifndef dom_plugins_PluginInstanceChild_h
