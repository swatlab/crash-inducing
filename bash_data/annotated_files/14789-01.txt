    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS function support.
    1:  */
    1: #include "jsstddef.h"
    1: #include <string.h>
    1: #include "jstypes.h"
    1: #include "jsbit.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
    1: #include "jsconfig.h"
    1: #include "jsdbgapi.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
    1: #include "jsexn.h"
    1: 
    1: #if JS_HAS_GENERATORS
    1: # include "jsiter.h"
    1: #endif
    1: 
11435: #if JS_HAS_XDR
11435: # include "jsxdrapi.h"
11435: #endif
11435: 
    1: /* Generic function/call/arguments tinyids -- also reflected bit numbers. */
    1: enum {
    1:     CALL_ARGUMENTS  = -1,       /* predefined arguments local variable */
 2514:     ARGS_LENGTH     = -2,       /* number of actual args, arity if inactive */
 2514:     ARGS_CALLEE     = -3,       /* reference from arguments to active funobj */
 2514:     FUN_ARITY       = -4,       /* number of formal parameters; desired argc */
 2514:     FUN_NAME        = -5,       /* function name, "" if anonymous */
 2514:     FUN_CALLER      = -6        /* Function.prototype.caller, backward compat */
    1: };
    1: 
    1: #if JSFRAME_OVERRIDE_BITS < 8
    1: # error "not enough override bits in JSStackFrame.flags!"
    1: #endif
    1: 
    1: #define TEST_OVERRIDE_BIT(fp, tinyid) \
    1:     ((fp)->flags & JS_BIT(JSFRAME_OVERRIDE_SHIFT - ((tinyid) + 1)))
    1: 
    1: #define SET_OVERRIDE_BIT(fp, tinyid) \
    1:     ((fp)->flags |= JS_BIT(JSFRAME_OVERRIDE_SHIFT - ((tinyid) + 1)))
    1: 
    1: JSBool
    1: js_GetArgsValue(JSContext *cx, JSStackFrame *fp, jsval *vp)
    1: {
    1:     JSObject *argsobj;
    1: 
    1:     if (TEST_OVERRIDE_BIT(fp, CALL_ARGUMENTS)) {
    1:         JS_ASSERT(fp->callobj);
    1:         return OBJ_GET_PROPERTY(cx, fp->callobj,
    1:                                 ATOM_TO_JSID(cx->runtime->atomState
    1:                                              .argumentsAtom),
    1:                                 vp);
    1:     }
    1:     argsobj = js_GetArgsObject(cx, fp);
    1:     if (!argsobj)
    1:         return JS_FALSE;
    1:     *vp = OBJECT_TO_JSVAL(argsobj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: MarkArgDeleted(JSContext *cx, JSStackFrame *fp, uintN slot)
    1: {
    1:     JSObject *argsobj;
    1:     jsval bmapval, bmapint;
    1:     size_t nbits, nbytes;
    1:     jsbitmap *bitmap;
    1: 
    1:     argsobj = fp->argsobj;
    1:     (void) JS_GetReservedSlot(cx, argsobj, 0, &bmapval);
    1:     nbits = fp->argc;
    1:     JS_ASSERT(slot < nbits);
    1:     if (JSVAL_IS_VOID(bmapval)) {
    1:         if (nbits <= JSVAL_INT_BITS) {
    1:             bmapint = 0;
    1:             bitmap = (jsbitmap *) &bmapint;
    1:         } else {
    1:             nbytes = JS_HOWMANY(nbits, JS_BITS_PER_WORD) * sizeof(jsbitmap);
    1:             bitmap = (jsbitmap *) JS_malloc(cx, nbytes);
    1:             if (!bitmap)
    1:                 return JS_FALSE;
    1:             memset(bitmap, 0, nbytes);
    1:             bmapval = PRIVATE_TO_JSVAL(bitmap);
    1:             JS_SetReservedSlot(cx, argsobj, 0, bmapval);
    1:         }
    1:     } else {
    1:         if (nbits <= JSVAL_INT_BITS) {
    1:             bmapint = JSVAL_TO_INT(bmapval);
    1:             bitmap = (jsbitmap *) &bmapint;
    1:         } else {
    1:             bitmap = (jsbitmap *) JSVAL_TO_PRIVATE(bmapval);
    1:         }
    1:     }
    1:     JS_SET_BIT(bitmap, slot);
    1:     if (bitmap == (jsbitmap *) &bmapint) {
    1:         bmapval = INT_TO_JSVAL(bmapint);
    1:         JS_SetReservedSlot(cx, argsobj, 0, bmapval);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* NB: Infallible predicate, false does not mean error/exception. */
    1: static JSBool
    1: ArgWasDeleted(JSContext *cx, JSStackFrame *fp, uintN slot)
    1: {
    1:     JSObject *argsobj;
    1:     jsval bmapval, bmapint;
    1:     jsbitmap *bitmap;
    1: 
    1:     argsobj = fp->argsobj;
    1:     (void) JS_GetReservedSlot(cx, argsobj, 0, &bmapval);
    1:     if (JSVAL_IS_VOID(bmapval))
    1:         return JS_FALSE;
    1:     if (fp->argc <= JSVAL_INT_BITS) {
    1:         bmapint = JSVAL_TO_INT(bmapval);
    1:         bitmap = (jsbitmap *) &bmapint;
    1:     } else {
    1:         bitmap = (jsbitmap *) JSVAL_TO_PRIVATE(bmapval);
    1:     }
    1:     return JS_TEST_BIT(bitmap, slot) != 0;
    1: }
    1: 
    1: JSBool
 2383: js_GetArgsProperty(JSContext *cx, JSStackFrame *fp, jsid id, jsval *vp)
    1: {
    1:     jsval val;
    1:     JSObject *obj;
    1:     uintN slot;
    1: 
    1:     if (TEST_OVERRIDE_BIT(fp, CALL_ARGUMENTS)) {
    1:         JS_ASSERT(fp->callobj);
    1:         if (!OBJ_GET_PROPERTY(cx, fp->callobj,
    1:                               ATOM_TO_JSID(cx->runtime->atomState
    1:                                            .argumentsAtom),
    1:                               &val)) {
    1:             return JS_FALSE;
    1:         }
    1:         if (JSVAL_IS_PRIMITIVE(val)) {
    1:             obj = js_ValueToNonNullObject(cx, val);
    1:             if (!obj)
    1:                 return JS_FALSE;
    1:         } else {
    1:             obj = JSVAL_TO_OBJECT(val);
    1:         }
    1:         return OBJ_GET_PROPERTY(cx, obj, id, vp);
    1:     }
    1: 
    1:     *vp = JSVAL_VOID;
    1:     if (JSID_IS_INT(id)) {
    1:         slot = (uintN) JSID_TO_INT(id);
    1:         if (slot < fp->argc) {
    1:             if (fp->argsobj && ArgWasDeleted(cx, fp, slot))
    1:                 return OBJ_GET_PROPERTY(cx, fp->argsobj, id, vp);
    1:             *vp = fp->argv[slot];
    1:         } else {
    1:             /*
    1:              * Per ECMA-262 Ed. 3, 10.1.8, last bulleted item, do not share
    1:              * storage between the formal parameter and arguments[k] for all
 4127:              * fp->argc <= k && k < fp->fun->nargs.  For example, in
    1:              *
    1:              *   function f(x) { x = 42; return arguments[0]; }
    1:              *   f();
    1:              *
    1:              * the call to f should return undefined, not 42.  If fp->argsobj
    1:              * is null at this point, as it would be in the example, return
    1:              * undefined in *vp.
    1:              */
    1:             if (fp->argsobj)
    1:                 return OBJ_GET_PROPERTY(cx, fp->argsobj, id, vp);
    1:         }
    1:     } else {
    1:         if (id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)) {
    1:             if (fp->argsobj && TEST_OVERRIDE_BIT(fp, ARGS_LENGTH))
    1:                 return OBJ_GET_PROPERTY(cx, fp->argsobj, id, vp);
    1:             *vp = INT_TO_JSVAL((jsint) fp->argc);
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
    1: js_GetArgsObject(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     JSObject *argsobj, *global, *parent;
    1: 
    1:     /*
    1:      * We must be in a function activation; the function must be lightweight
    1:      * or else fp must have a variable object.
    1:      */
13702:     JS_ASSERT(fp->fun && (!(fp->fun->flags & JSFUN_HEAVYWEIGHT) || fp->varobj));
    1: 
    1:     /* Skip eval and debugger frames. */
    1:     while (fp->flags & JSFRAME_SPECIAL)
    1:         fp = fp->down;
    1: 
    1:     /* Create an arguments object for fp only if it lacks one. */
    1:     argsobj = fp->argsobj;
    1:     if (argsobj)
    1:         return argsobj;
    1: 
    1:     /* Link the new object to fp so it can get actual argument values. */
13824:     argsobj = js_NewObject(cx, &js_ArgumentsClass, NULL, NULL, 0);
    1:     if (!argsobj || !JS_SetPrivate(cx, argsobj, fp)) {
    1:         cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:         return NULL;
    1:     }
    1: 
    1:     /*
    1:      * Give arguments an intrinsic scope chain link to fp's global object.
    1:      * Since the arguments object lacks a prototype because js_ArgumentsClass
    1:      * is not initialized, js_NewObject won't assign a default parent to it.
    1:      *
    1:      * Therefore if arguments is used as the head of an eval scope chain (via
    1:      * a direct or indirect call to eval(program, arguments)), any reference
    1:      * to a standard class object in the program will fail to resolve due to
    1:      * js_GetClassPrototype not being able to find a global object containing
    1:      * the standard prototype by starting from arguments and following parent.
    1:      */
    1:     global = fp->scopeChain;
    1:     while ((parent = OBJ_GET_PARENT(cx, global)) != NULL)
    1:         global = parent;
    1:     STOBJ_SET_PARENT(argsobj, global);
    1:     fp->argsobj = argsobj;
    1:     return argsobj;
    1: }
    1: 
    1: static JSBool
    1: args_enumerate(JSContext *cx, JSObject *obj);
    1: 
10855: JS_FRIEND_API(JSBool)
    1: js_PutArgsObject(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     JSObject *argsobj;
    1:     jsval bmapval, rval;
    1:     JSBool ok;
    1:     JSRuntime *rt;
    1: 
    1:     /*
    1:      * Reuse args_enumerate here to reflect fp's actual arguments as indexed
    1:      * elements of argsobj.  Do this first, before clearing and freeing the
    1:      * deleted argument slot bitmap, because args_enumerate depends on that.
    1:      */
    1:     argsobj = fp->argsobj;
    1:     ok = args_enumerate(cx, argsobj);
    1: 
    1:     /*
    1:      * Now clear the deleted argument number bitmap slot and free the bitmap,
    1:      * if one was actually created due to 'delete arguments[0]' or similar.
    1:      */
    1:     (void) JS_GetReservedSlot(cx, argsobj, 0, &bmapval);
    1:     if (!JSVAL_IS_VOID(bmapval)) {
    1:         JS_SetReservedSlot(cx, argsobj, 0, JSVAL_VOID);
    1:         if (fp->argc > JSVAL_INT_BITS)
    1:             JS_free(cx, JSVAL_TO_PRIVATE(bmapval));
    1:     }
    1: 
    1:     /*
    1:      * Now get the prototype properties so we snapshot fp->fun and fp->argc
    1:      * before fp goes away.
    1:      */
    1:     rt = cx->runtime;
    1:     ok &= js_GetProperty(cx, argsobj, ATOM_TO_JSID(rt->atomState.calleeAtom),
    1:                          &rval);
    1:     ok &= js_SetProperty(cx, argsobj, ATOM_TO_JSID(rt->atomState.calleeAtom),
    1:                          &rval);
    1:     ok &= js_GetProperty(cx, argsobj, ATOM_TO_JSID(rt->atomState.lengthAtom),
    1:                          &rval);
    1:     ok &= js_SetProperty(cx, argsobj, ATOM_TO_JSID(rt->atomState.lengthAtom),
    1:                          &rval);
    1: 
    1:     /*
    1:      * Clear the private pointer to fp, which is about to go away (js_Invoke).
    1:      * Do this last because the args_enumerate and js_GetProperty calls above
    1:      * need to follow the private slot to find fp.
    1:      */
    1:     ok &= JS_SetPrivate(cx, argsobj, NULL);
    1:     fp->argsobj = NULL;
    1:     return ok;
    1: }
    1: 
    1: static JSBool
    1: args_delProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     jsint slot;
    1:     JSStackFrame *fp;
    1: 
    1:     if (!JSVAL_IS_INT(id))
    1:         return JS_TRUE;
    1:     fp = (JSStackFrame *)
    1:          JS_GetInstancePrivate(cx, obj, &js_ArgumentsClass, NULL);
    1:     if (!fp)
    1:         return JS_TRUE;
    1:     JS_ASSERT(fp->argsobj);
    1: 
    1:     slot = JSVAL_TO_INT(id);
    1:     switch (slot) {
    1:       case ARGS_CALLEE:
    1:       case ARGS_LENGTH:
    1:         SET_OVERRIDE_BIT(fp, slot);
    1:         break;
    1: 
    1:       default:
    1:         if ((uintN)slot < fp->argc && !MarkArgDeleted(cx, fp, slot))
    1:             return JS_FALSE;
    1:         break;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: args_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     jsint slot;
    1:     JSStackFrame *fp;
    1: 
    1:     if (!JSVAL_IS_INT(id))
    1:         return JS_TRUE;
    1:     fp = (JSStackFrame *)
    1:          JS_GetInstancePrivate(cx, obj, &js_ArgumentsClass, NULL);
    1:     if (!fp)
    1:         return JS_TRUE;
    1:     JS_ASSERT(fp->argsobj);
    1: 
    1:     slot = JSVAL_TO_INT(id);
    1:     switch (slot) {
    1:       case ARGS_CALLEE:
    1:         if (!TEST_OVERRIDE_BIT(fp, slot))
 4127:             *vp = OBJECT_TO_JSVAL(fp->callee);
    1:         break;
    1: 
    1:       case ARGS_LENGTH:
    1:         if (!TEST_OVERRIDE_BIT(fp, slot))
    1:             *vp = INT_TO_JSVAL((jsint)fp->argc);
    1:         break;
    1: 
    1:       default:
    1:         if ((uintN)slot < fp->argc && !ArgWasDeleted(cx, fp, slot))
    1:             *vp = fp->argv[slot];
    1:         break;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: args_setProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSStackFrame *fp;
    1:     jsint slot;
    1: 
    1:     if (!JSVAL_IS_INT(id))
    1:         return JS_TRUE;
    1:     fp = (JSStackFrame *)
    1:          JS_GetInstancePrivate(cx, obj, &js_ArgumentsClass, NULL);
    1:     if (!fp)
    1:         return JS_TRUE;
    1:     JS_ASSERT(fp->argsobj);
    1: 
    1:     slot = JSVAL_TO_INT(id);
    1:     switch (slot) {
    1:       case ARGS_CALLEE:
    1:       case ARGS_LENGTH:
    1:         SET_OVERRIDE_BIT(fp, slot);
    1:         break;
    1: 
    1:       default:
13702:         if (FUN_INTERPRETED(fp->fun) &&
    1:             (uintN)slot < fp->argc &&
    1:             !ArgWasDeleted(cx, fp, slot)) {
    1:             fp->argv[slot] = *vp;
    1:         }
    1:         break;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: args_resolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
    1:              JSObject **objp)
    1: {
    1:     JSStackFrame *fp;
    1:     uintN slot;
    1:     JSString *str;
    1:     JSAtom *atom;
    1:     intN tinyid;
    1:     jsval value;
    1: 
    1:     *objp = NULL;
    1:     fp = (JSStackFrame *)
    1:          JS_GetInstancePrivate(cx, obj, &js_ArgumentsClass, NULL);
    1:     if (!fp)
    1:         return JS_TRUE;
    1:     JS_ASSERT(fp->argsobj);
    1: 
    1:     if (JSVAL_IS_INT(id)) {
    1:         slot = JSVAL_TO_INT(id);
    1:         if (slot < fp->argc && !ArgWasDeleted(cx, fp, slot)) {
    1:             /* XXX ECMA specs DontEnum, contrary to other array-like objects */
    1:             if (!js_DefineProperty(cx, obj, INT_JSVAL_TO_JSID(id),
    1:                                    fp->argv[slot],
    1:                                    args_getProperty, args_setProperty,
    1:                                    0, NULL)) {
    1:                 return JS_FALSE;
    1:             }
    1:             *objp = obj;
    1:         }
    1:     } else {
    1:         str = JSVAL_TO_STRING(id);
    1:         atom = cx->runtime->atomState.lengthAtom;
    1:         if (str == ATOM_TO_STRING(atom)) {
    1:             tinyid = ARGS_LENGTH;
    1:             value = INT_TO_JSVAL(fp->argc);
    1:         } else {
    1:             atom = cx->runtime->atomState.calleeAtom;
    1:             if (str == ATOM_TO_STRING(atom)) {
    1:                 tinyid = ARGS_CALLEE;
 4127:                 value = OBJECT_TO_JSVAL(fp->callee);
    1:             } else {
    1:                 atom = NULL;
    1: 
    1:                 /* Quell GCC overwarnings. */
    1:                 tinyid = 0;
    1:                 value = JSVAL_NULL;
    1:             }
    1:         }
    1: 
    1:         if (atom && !TEST_OVERRIDE_BIT(fp, tinyid)) {
    1:             if (!js_DefineNativeProperty(cx, obj, ATOM_TO_JSID(atom), value,
    1:                                          args_getProperty, args_setProperty, 0,
    1:                                          SPROP_HAS_SHORTID, tinyid, NULL)) {
    1:                 return JS_FALSE;
    1:             }
    1:             *objp = obj;
    1:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: args_enumerate(JSContext *cx, JSObject *obj)
    1: {
    1:     JSStackFrame *fp;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
    1:     uintN slot, argc;
    1: 
    1:     fp = (JSStackFrame *)
    1:          JS_GetInstancePrivate(cx, obj, &js_ArgumentsClass, NULL);
    1:     if (!fp)
    1:         return JS_TRUE;
    1:     JS_ASSERT(fp->argsobj);
    1: 
    1:     /*
    1:      * Trigger reflection with value snapshot in args_resolve using a series
    1:      * of js_LookupProperty calls.  We handle length, callee, and the indexed
    1:      * argument properties.  We know that args_resolve covers all these cases
    1:      * and creates direct properties of obj, but that it may fail to resolve
    1:      * length or callee if overridden.
    1:      */
    1:     if (!js_LookupProperty(cx, obj,
    1:                            ATOM_TO_JSID(cx->runtime->atomState.lengthAtom),
    1:                            &pobj, &prop)) {
    1:         return JS_FALSE;
    1:     }
    1:     if (prop)
    1:         OBJ_DROP_PROPERTY(cx, pobj, prop);
    1: 
    1:     if (!js_LookupProperty(cx, obj,
    1:                            ATOM_TO_JSID(cx->runtime->atomState.calleeAtom),
    1:                            &pobj, &prop)) {
    1:         return JS_FALSE;
    1:     }
    1:     if (prop)
    1:         OBJ_DROP_PROPERTY(cx, pobj, prop);
    1: 
    1:     argc = fp->argc;
    1:     for (slot = 0; slot < argc; slot++) {
    1:         if (!js_LookupProperty(cx, obj, INT_TO_JSID((jsint)slot), &pobj, &prop))
    1:             return JS_FALSE;
    1:         if (prop)
    1:             OBJ_DROP_PROPERTY(cx, pobj, prop);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_GENERATORS
    1: /*
    1:  * If a generator-iterator's arguments or call object escapes, it needs to
    1:  * mark its generator object.
    1:  */
  583: static void
  583: args_or_call_trace(JSTracer *trc, JSObject *obj)
    1: {
    1:     JSStackFrame *fp;
    1: 
 3164:     fp = (JSStackFrame *) JS_GetPrivate(trc->context, obj);
 3526:     if (fp && (fp->flags & JSFRAME_GENERATOR)) {
 3526:         JS_CALL_OBJECT_TRACER(trc, FRAME_TO_GENERATOR(fp)->obj,
 3526:                               "FRAME_TO_GENERATOR(fp)->obj");
 3526:     }
    1: }
    1: #else
  583: # define args_or_call_trace NULL
    1: #endif
    1: 
    1: /*
    1:  * The Arguments class is not initialized via JS_InitClass, and must not be,
    1:  * because its name is "Object".  Per ECMA, that causes instances of it to
    1:  * delegate to the object named by Object.prototype.  It also ensures that
    1:  * arguments.toString() returns "[object Object]".
    1:  *
    1:  * The JSClass functions below collaborate to lazily reflect and synchronize
    1:  * actual argument values, argument count, and callee function object stored
    1:  * in a JSStackFrame with their corresponding property values in the frame's
    1:  * arguments object.
    1:  */
    1: JSClass js_ArgumentsClass = {
    1:     js_Object_str,
    1:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE | JSCLASS_HAS_RESERVED_SLOTS(1) |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
    1:     JS_PropertyStub,    args_delProperty,
    1:     args_getProperty,   args_setProperty,
    1:     args_enumerate,     (JSResolveOp) args_resolve,
    1:     JS_ConvertStub,     JS_FinalizeStub,
    1:     NULL,               NULL,
    1:     NULL,               NULL,
    1:     NULL,               NULL,
  583:     JS_CLASS_TRACE(args_or_call_trace), NULL
    1: };
    1: 
    1: JSObject *
    1: js_GetCallObject(JSContext *cx, JSStackFrame *fp, JSObject *parent)
    1: {
    1:     JSObject *callobj, *funobj;
    1: 
    1:     /* Create a call object for fp only if it lacks one. */
    1:     JS_ASSERT(fp->fun);
    1:     callobj = fp->callobj;
    1:     if (callobj)
    1:         return callobj;
    1: 
    1:     /* The default call parent is its function's parent (static link). */
    1:     if (!parent) {
 4127:         funobj = fp->callee;
    1:         if (funobj)
    1:             parent = OBJ_GET_PARENT(cx, funobj);
    1:     }
    1: 
    1:     /* Create the call object and link it to its stack frame. */
13824:     callobj = js_NewObject(cx, &js_CallClass, NULL, parent, 0);
    1:     if (!callobj || !JS_SetPrivate(cx, callobj, fp)) {
    1:         cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:         return NULL;
    1:     }
    1:     fp->callobj = callobj;
    1: 
    1:     /* Make callobj be the scope chain and the variables object. */
    1:     JS_ASSERT(fp->scopeChain == parent);
    1:     fp->scopeChain = callobj;
    1:     fp->varobj = callobj;
    1:     return callobj;
    1: }
    1: 
    1: static JSBool
    1: call_enumerate(JSContext *cx, JSObject *obj);
    1: 
10855: JS_FRIEND_API(JSBool)
    1: js_PutCallObject(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     JSObject *callobj;
    1:     JSBool ok;
    1:     jsid argsid;
    1:     jsval aval;
    1: 
    1:     /*
    1:      * Reuse call_enumerate here to reflect all actual args and vars into the
    1:      * call object from fp.
    1:      */
    1:     callobj = fp->callobj;
    1:     if (!callobj)
    1:         return JS_TRUE;
    1:     ok = call_enumerate(cx, callobj);
    1: 
    1:     /*
    1:      * Get the arguments object to snapshot fp's actual argument values.
    1:      */
    1:     if (fp->argsobj) {
 2384:         if (!TEST_OVERRIDE_BIT(fp, CALL_ARGUMENTS)) {
    1:             argsid = ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom);
 2384:             aval = OBJECT_TO_JSVAL(fp->argsobj);
    1:             ok &= js_SetProperty(cx, callobj, argsid, &aval);
 2384:         }
    1:         ok &= js_PutArgsObject(cx, fp);
    1:     }
    1: 
    1:     /*
    1:      * Clear the private pointer to fp, which is about to go away (js_Invoke).
    1:      * Do this last because the call_enumerate and js_GetProperty calls above
    1:      * need to follow the private slot to find fp.
    1:      */
    1:     ok &= JS_SetPrivate(cx, callobj, NULL);
    1:     fp->callobj = NULL;
    1:     return ok;
    1: }
    1: 
    1: static JSBool
    1: call_enumerate(JSContext *cx, JSObject *obj)
    1: {
    1:     JSStackFrame *fp;
13702:     JSFunction *fun;
 8367:     uintN n, i, slot;
10476:     void *mark;
11435:     jsuword *names;
11435:     JSBool ok;
11435:     JSAtom *name;
 8367:     JSObject *pobj;
    1:     JSProperty *prop;
 8367:     jsval v;
    1: 
    1:     fp = (JSStackFrame *) JS_GetPrivate(cx, obj);
    1:     if (!fp)
    1:         return JS_TRUE;
13691:     JS_ASSERT(GET_FUNCTION_PRIVATE(cx, fp->callee) == fp->fun);
    1: 
    1:     /*
    1:      * Reflect actual args from fp->argv for formal parameters, and local vars
    1:      * and functions in fp->vars for declared variables and nested-at-top-level
    1:      * local functions.
    1:      */
13702:     fun = fp->fun;
11435:     n = JS_GET_LOCAL_NAME_COUNT(fun);
 8367:     if (n == 0)
 8367:         return JS_TRUE;
 8367: 
10476:     mark = JS_ARENA_MARK(&cx->tempPool);
11435: 
11435:     /* From this point the control must flow through the label out. */
11435:     names = js_GetLocalNameArray(cx, fun, &cx->tempPool);
11435:     if (!names) {
11435:         ok = JS_FALSE;
10476:         goto out;
11435:     }
 8367: 
 8367:     for (i = 0; i != n; ++i) {
11435:         name = JS_LOCAL_NAME_TO_ATOM(names[i]);
 8367:         if (!name)
    1:             continue;
    1: 
    1:         /*
 8367:          * Trigger reflection by looking up the name of the argument or
 8367:          * variable.
    1:          */
11435:         ok = js_LookupProperty(cx, obj, ATOM_TO_JSID(name), &pobj, &prop);
11435:         if (!ok)
 8367:             goto out;
    1: 
 8367:         /*
 8367:          * At this point the call object always has a property corresponding
 8367:          * to the local name because call_resolve creates the property using
 8367:          * JSPROP_PERMANENT.
 8367:          */
 8367:         JS_ASSERT(prop && pobj == obj);
 8367:         slot = ((JSScopeProperty *) prop)->slot;
 8367:         OBJ_DROP_PROPERTY(cx, pobj, prop);
 8367: 
 8367:         v = (i < fun->nargs) ? fp->argv[i] : fp->vars[i - fun->nargs];
 8367:         LOCKED_OBJ_SET_SLOT(obj, slot, v);
 8367:     }
11435:     ok = JS_TRUE;
 8367: 
 8367:   out:
10476:     JS_ARENA_RELEASE(&cx->tempPool, mark);
11435:     return ok;
    1: }
    1: 
13706: typedef enum JSCallPropertyKind {
13706:     JSCPK_ARGUMENTS,
13706:     JSCPK_ARG,
13706:     JSCPK_VAR
13706: } JSCallPropertyKind;
13706: 
13706: static JSBool
13706: CallPropertyOp(JSContext *cx, JSObject *obj, jsid id, jsval *vp,
13706:                JSCallPropertyKind kind, JSBool setter)
13706: {
13706:     JSStackFrame *fp;
13706:     JSFunction *fun;
13706:     uintN i;
13706:     jsval *array;
13706: 
13706:     fp = (JSStackFrame *) JS_GetPrivate(cx, obj);
13706:     if (!fp)
13706:         return JS_TRUE;
13706:     fun = fp->fun;
13706:     JS_ASSERT(fun && FUN_INTERPRETED(fun));
13706: 
13706:     if (kind == JSCPK_ARGUMENTS) {
13706:         if (setter) {
13706:             SET_OVERRIDE_BIT(fp, CALL_ARGUMENTS);
13706:         } else if (!TEST_OVERRIDE_BIT(fp, CALL_ARGUMENTS)) {
13706:             JSObject *argsobj;
13706: 
13706:             argsobj = js_GetArgsObject(cx, fp);
13706:             if (!argsobj)
13706:                 return JS_FALSE;
13706:             *vp = OBJECT_TO_JSVAL(argsobj);
13706:         }
13706:         return JS_TRUE;
13706:     }
13706: 
13706:     JS_ASSERT((int16) JSVAL_TO_INT(id) == JSVAL_TO_INT(id));
13706:     i = (uint16) JSVAL_TO_INT(id);
13706:     JS_ASSERT_IF(kind == JSCPK_ARG, i < fun->nargs);
13706:     JS_ASSERT_IF(kind == JSCPK_VAR, i < fun->u.i.nvars);
13706: 
13706:     JS_ASSERT(fun->u.i.nvars == fp->nvars);
13706:     if (kind == JSCPK_ARG) {
13706:         array = fp->argv;
13706:     } else {
13706:         JS_ASSERT(kind == JSCPK_VAR);
13706:         array = fp->vars;
13706:     }
13706:     if (setter)
13706:         array[i] = *vp;
13706:     else
13706:         *vp = array[i];
13706:     return JS_TRUE;
13706: }
13706: 
13706: static JSBool
13706: GetCallArguments(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
13706:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARGUMENTS, JS_FALSE);
13706: }
13706: 
13706: static JSBool
13706: SetCallArguments(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
13706:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARGUMENTS, JS_TRUE);
13706: }
13706: 
13706: JSBool
13706: js_GetCallArg(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
13706:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARG, JS_FALSE);
13706: }
13706: 
13706: static JSBool
13706: SetCallArg(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
13706:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARG, JS_TRUE);
13706: }
13706: 
13706: JSBool
13706: js_GetCallVar(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
13706:     return CallPropertyOp(cx, obj, id, vp, JSCPK_VAR, JS_FALSE);
13706: }
13706: 
13706: static JSBool
13706: SetCallVar(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
13706:     return CallPropertyOp(cx, obj, id, vp, JSCPK_VAR, JS_TRUE);
13706: }
13706: 
    1: static JSBool
10573: call_resolve(JSContext *cx, JSObject *obj, jsval idval, uintN flags,
    1:              JSObject **objp)
    1: {
    1:     JSStackFrame *fp;
13706:     JSFunction *fun;
10573:     jsid id;
 8179:     JSLocalKind localKind;
    1:     JSPropertyOp getter, setter;
 8179:     uintN slot, attrs;
 8179:     jsval *vp;
    1: 
    1:     fp = (JSStackFrame *) JS_GetPrivate(cx, obj);
    1:     if (!fp)
    1:         return JS_TRUE;
13706:     fun = fp->fun;
13706:     JS_ASSERT(fun);
13706:     JS_ASSERT(GET_FUNCTION_PRIVATE(cx, fp->callee) == fun);
    1: 
10573:     if (!JSVAL_IS_STRING(idval))
    1:         return JS_TRUE;
    1: 
10573:     if (!js_ValueToStringId(cx, idval, &id))
    1:         return JS_FALSE;
    1: 
13706:     localKind = js_LookupLocal(cx, fun, JSID_TO_ATOM(id), &slot);
 8179:     if (localKind != JSLOCAL_NONE) {
13706:         JS_ASSERT((uint16) slot == slot);
 8179:         if (localKind == JSLOCAL_ARG) {
13706:             JS_ASSERT(slot < fun->nargs);
 7959:             vp = fp->argv;
13706:             getter = js_GetCallArg;
13706:             setter = SetCallArg;
 8179:             attrs = JSPROP_PERMANENT;
 8158:         } else {
 8179:             JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
13706:             JS_ASSERT(fun->u.i.nvars == fp->nvars);
13706:             JS_ASSERT(slot < fun->u.i.nvars);
 8158:             vp = fp->vars;
13706:             getter = js_GetCallVar;
13706:             setter = SetCallVar;
 8179:             attrs = (localKind == JSLOCAL_CONST)
 8179:                     ? JSPROP_PERMANENT | JSPROP_READONLY
 8179:                     : JSPROP_PERMANENT;
 8158:         }
10573:         if (!js_DefineNativeProperty(cx, obj, id, vp[slot], getter, setter,
13706:                                      attrs, SPROP_HAS_SHORTID, (int16) slot,
10573:                                      NULL)) {
    1:             return JS_FALSE;
    1:         }
    1:         *objp = obj;
 2464:         return JS_TRUE;
    1:     }
    1: 
 2464:     /*
 2464:      * Resolve arguments so that we never store a particular Call object's
 2464:      * arguments object reference in a Call prototype's |arguments| slot.
 2464:      */
10573:     if (id == ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom)) {
10573:         if (!js_DefineNativeProperty(cx, obj, id, JSVAL_VOID,
13706:                                      GetCallArguments, SetCallArguments,
13706:                                      JSPROP_PERMANENT, 0, 0, NULL)) {
 2464:             return JS_FALSE;
 2464:         }
 2464:         *objp = obj;
 2464:         return JS_TRUE;
 2464:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: call_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
    1: {
    1:     JSStackFrame *fp;
    1: 
    1:     if (type == JSTYPE_FUNCTION) {
    1:         fp = (JSStackFrame *) JS_GetPrivate(cx, obj);
    1:         if (fp) {
    1:             JS_ASSERT(fp->fun);
 4127:             *vp = OBJECT_TO_JSVAL(fp->callee);
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
 9018: JS_FRIEND_DATA(JSClass) js_CallClass = {
    1:     js_Call_str,
    1:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE | JSCLASS_IS_ANONYMOUS |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Call),
    1:     JS_PropertyStub,    JS_PropertyStub,
13706:     JS_PropertyStub,    JS_PropertyStub,
    1:     call_enumerate,     (JSResolveOp)call_resolve,
    1:     call_convert,       JS_FinalizeStub,
    1:     NULL,               NULL,
    1:     NULL,               NULL,
    1:     NULL,               NULL,
  583:     JS_CLASS_TRACE(args_or_call_trace), NULL,
    1: };
    1: 
    1: /*
    1:  * ECMA-262 specifies that length is a property of function object instances,
    1:  * but we can avoid that space cost by delegating to a prototype property that
    1:  * is JSPROP_PERMANENT and JSPROP_SHARED.  Each fun_getProperty call computes
    1:  * a fresh length value based on the arity of the individual function object's
    1:  * private data.
    1:  *
    1:  * The extensions below other than length, i.e., the ones not in ECMA-262,
    1:  * are neither JSPROP_READONLY nor JSPROP_SHARED, because for compatibility
 2803:  * with ECMA we must allow a delegating object to override them. Therefore to
 2803:  * avoid entraining garbage in Function.prototype slots, they must be resolved
 2803:  * in non-prototype function objects, wherefore the lazy_function_props table
 2803:  * and fun_resolve's use of it.
    1:  */
    1: #define LENGTH_PROP_ATTRS (JSPROP_READONLY|JSPROP_PERMANENT|JSPROP_SHARED)
    1: 
    1: static JSPropertySpec function_props[] = {
    1:     {js_length_str,    ARGS_LENGTH,    LENGTH_PROP_ATTRS, 0,0},
    1:     {0,0,0,0,0}
    1: };
    1: 
 2803: typedef struct LazyFunctionProp {
 2803:     uint16      atomOffset;
 2803:     int8        tinyid;
 2803:     uint8       attrs;
 2803: } LazyFunctionProp;
 2803: 
 2803: /* NB: no sentinel at the end -- use JS_ARRAY_LENGTH to bound loops. */
 2803: static LazyFunctionProp lazy_function_props[] = {
 2803:     {ATOM_OFFSET(arguments), CALL_ARGUMENTS, JSPROP_PERMANENT},
 2803:     {ATOM_OFFSET(arity),     FUN_ARITY,      JSPROP_PERMANENT},
 2803:     {ATOM_OFFSET(caller),    FUN_CALLER,     JSPROP_PERMANENT},
 2803:     {ATOM_OFFSET(name),      FUN_NAME,       JSPROP_PERMANENT},
 2803: };
 2803: 
    1: static JSBool
    1: fun_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     jsint slot;
    1:     JSFunction *fun;
    1:     JSStackFrame *fp;
    1: 
    1:     if (!JSVAL_IS_INT(id))
    1:         return JS_TRUE;
    1:     slot = JSVAL_TO_INT(id);
    1: 
    1:     /*
    1:      * Loop because getter and setter can be delegated from another class,
    1:      * but loop only for ARGS_LENGTH because we must pretend that f.length
    1:      * is in each function instance f, per ECMA-262, instead of only in the
    1:      * Function.prototype object (we use JSPROP_PERMANENT with JSPROP_SHARED
    1:      * to make it appear so).
    1:      *
    1:      * This code couples tightly to the attributes for the function_props[]
    1:      * initializers above, and to js_SetProperty and js_HasOwnPropertyHelper.
    1:      *
    1:      * It's important to allow delegating objects, even though they inherit
    1:      * this getter (fun_getProperty), to override arguments, arity, caller,
    1:      * and name.  If we didn't return early for slot != ARGS_LENGTH, we would
    1:      * clobber *vp with the native property value, instead of letting script
    1:      * override that value in delegating objects.
    1:      *
    1:      * Note how that clobbering is what simulates JSPROP_READONLY for all of
    1:      * the non-standard properties when the directly addressed object (obj)
    1:      * is a function object (i.e., when this loop does not iterate).
    1:      */
    1:     while (!(fun = (JSFunction *)
    1:                    JS_GetInstancePrivate(cx, obj, &js_FunctionClass, NULL))) {
    1:         if (slot != ARGS_LENGTH)
    1:             return JS_TRUE;
    1:         obj = OBJ_GET_PROTO(cx, obj);
    1:         if (!obj)
    1:             return JS_TRUE;
    1:     }
    1: 
    1:     /* Find fun's top-most activation record. */
    1:     for (fp = cx->fp; fp && (fp->fun != fun || (fp->flags & JSFRAME_SPECIAL));
    1:          fp = fp->down) {
    1:         continue;
    1:     }
    1: 
    1:     switch (slot) {
    1:       case CALL_ARGUMENTS:
    1:         /* Warn if strict about f.arguments or equivalent unqualified uses. */
    1:         if (!JS_ReportErrorFlagsAndNumber(cx,
    1:                                           JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                           js_GetErrorMessage, NULL,
    1:                                           JSMSG_DEPRECATED_USAGE,
    1:                                           js_arguments_str)) {
    1:             return JS_FALSE;
    1:         }
    1:         if (fp) {
    1:             if (!js_GetArgsValue(cx, fp, vp))
    1:                 return JS_FALSE;
    1:         } else {
    1:             *vp = JSVAL_NULL;
    1:         }
    1:         break;
    1: 
    1:       case ARGS_LENGTH:
    1:       case FUN_ARITY:
13702:             *vp = INT_TO_JSVAL((jsint)fun->nargs);
    1:         break;
    1: 
13702:       case FUN_NAME:
13702:         *vp = fun->atom
13702:               ? ATOM_KEY(fun->atom)
13702:               : STRING_TO_JSVAL(cx->runtime->emptyString);
    1:         break;
    1: 
    1:       case FUN_CALLER:
 4127:         if (fp && fp->down && fp->down->fun)
 4127:             *vp = OBJECT_TO_JSVAL(fp->down->callee);
    1:         else
    1:             *vp = JSVAL_NULL;
    1:         if (!JSVAL_IS_PRIMITIVE(*vp) && cx->runtime->checkObjectAccess) {
    1:             id = ATOM_KEY(cx->runtime->atomState.callerAtom);
    1:             if (!cx->runtime->checkObjectAccess(cx, obj, id, JSACC_READ, vp))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
    1: 
    1:       default:
    1:         /* XXX fun[0] and fun.arguments[0] are equivalent. */
13702:         if (fp && fp->fun && (uintN)slot < fp->fun->nargs)
    1:             *vp = fp->argv[slot];
    1:         break;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: fun_enumerate(JSContext *cx, JSObject *obj)
    1: {
    1:     jsid prototypeId;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
    1: 
    1:     prototypeId = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
    1:     if (!OBJ_LOOKUP_PROPERTY(cx, obj, prototypeId, &pobj, &prop))
    1:         return JS_FALSE;
    1:     if (prop)
    1:         OBJ_DROP_PROPERTY(cx, pobj, prop);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: fun_resolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
    1:             JSObject **objp)
    1: {
    1:     JSFunction *fun;
 2803:     JSAtom *atom;
 2803:     uintN i;
 2102: 
    1:     if (!JSVAL_IS_STRING(id))
    1:         return JS_TRUE;
    1: 
13691:     fun = GET_FUNCTION_PRIVATE(cx, obj);
 2803: 
 2803:     /*
 8179:      * No need to reflect fun.prototype in 'fun.prototype = ... '.
 8179:      *
 8179:      * This is not just an optimization, because we must not resolve when
 8179:      * defining hidden properties during compilation. The setup code for the
 8179:      * prototype and the lazy properties below eventually calls the property
 8179:      * hooks for the function object. That in turn calls fun_reserveSlots to
 8179:      * get the number of the reserved slots which is just the number of
 8179:      * regular expressions literals in the function. When compiling, that
 8179:      * number is not yet ready so we must make sure that fun_resolve does
 8179:      * nothing until the code for the function is generated.
 2803:      */
 2803:     if (flags & JSRESOLVE_ASSIGNING)
    1:         return JS_TRUE;
    1: 
    1:     /*
    1:      * Ok, check whether id is 'prototype' and bootstrap the function object's
    1:      * prototype property.
    1:      */
 2803:     atom = cx->runtime->atomState.classPrototypeAtom;
 2803:     if (id == ATOM_KEY(atom)) {
 9481:         JSObject *proto;
    1: 
    1:         /*
    1:          * Beware of the wacky case of a user function named Object -- trying
    1:          * to find a prototype for that will recur back here _ad perniciem_.
    1:          */
13702:         if (fun->atom == CLASS_ATOM(cx, Object))
    1:             return JS_TRUE;
    1: 
    1:         /*
 9481:          * Make the prototype object to have the same parent as the function
 9481:          * object itself.
    1:          */
13824:         proto = js_NewObject(cx, &js_ObjectClass, NULL, OBJ_GET_PARENT(cx, obj),
13824:                              0);
    1:         if (!proto)
    1:             return JS_FALSE;
    1: 
    1:         /*
    1:          * ECMA (15.3.5.2) says that constructor.prototype is DontDelete for
    1:          * user-defined functions, but DontEnum | ReadOnly | DontDelete for
    1:          * native "system" constructors such as Object or Function.  So lazily
    1:          * set the former here in fun_resolve, but eagerly define the latter
    1:          * in JS_InitClass, with the right attributes.
    1:          */
    1:         if (!js_SetClassPrototype(cx, obj, proto,
    1:                                   JSPROP_ENUMERATE | JSPROP_PERMANENT)) {
    1:             cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:             return JS_FALSE;
    1:         }
    1:         *objp = obj;
 2803:         return JS_TRUE;
 2803:     }
 2803: 
 2803:     for (i = 0; i < JS_ARRAY_LENGTH(lazy_function_props); i++) {
 2803:         LazyFunctionProp *lfp = &lazy_function_props[i];
 2803: 
 2803:         atom = OFFSET_TO_ATOM(cx->runtime, lfp->atomOffset);
 2803:         if (id == ATOM_KEY(atom)) {
 2803:             if (!js_DefineNativeProperty(cx, obj,
 2803:                                          ATOM_TO_JSID(atom), JSVAL_VOID,
 2803:                                          NULL, NULL, lfp->attrs,
 2803:                                          SPROP_HAS_SHORTID, lfp->tinyid,
 2803:                                          NULL)) {
 2803:                 return JS_FALSE;
 2803:             }
 2803:             *objp = obj;
 2803:             return JS_TRUE;
 2803:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: fun_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
    1: {
    1:     switch (type) {
    1:       case JSTYPE_FUNCTION:
    1:         *vp = OBJECT_TO_JSVAL(obj);
    1:         return JS_TRUE;
    1:       default:
    1:         return js_TryValueOf(cx, obj, type, vp);
    1:     }
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: /* XXX store parent and proto, if defined */
    1: static JSBool
    1: fun_xdrObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
13702:     JSFunction *fun;
    1:     uint32 nullAtom;            /* flag to indicate if fun->atom is NULL */
10571:     uintN nargs, nvars, n;
 8179:     uint32 localsword;          /* word to xdr argument and variable counts */
 8179:     uint32 flagsword;           /* originally only flags was JS_XDRUint8'd */
 8158:     JSTempValueRooter tvr;
    1:     JSBool ok;
    1: 
    1:     cx = xdr->cx;
    1:     if (xdr->mode == JSXDR_ENCODE) {
13702:         fun = GET_FUNCTION_PRIVATE(cx, *objp);
13702:         if (!FUN_INTERPRETED(fun)) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_NOT_SCRIPTED_FUNCTION,
13702:                                  JS_GetFunctionName(fun));
    1:             return JS_FALSE;
    1:         }
13691:         nullAtom = !fun->atom;
13691:         nargs = fun->nargs;
13702:         nvars = fun->u.i.nvars;
 8179:         localsword = (nargs << 16) | nvars;
13691:         flagsword = fun->flags;
    1:     } else {
13702:         fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED, NULL, NULL);
13691:         if (!fun)
    1:             return JS_FALSE;
13824:         STOBJ_SET_PARENT(FUN_OBJECT(fun), NULL);
13824:         STOBJ_SET_PROTO(FUN_OBJECT(fun), NULL);
 8179: #ifdef __GNUC__
 8179:         nvars = nargs = 0;   /* quell GCC uninitialized warning */
 8179: #endif
    1:     }
    1: 
    1:     /* From here on, control flow must flow through label out. */
13824:     JS_PUSH_TEMP_ROOT_OBJECT(cx, FUN_OBJECT(fun), &tvr);
    1:     ok = JS_TRUE;
    1: 
    1:     if (!JS_XDRUint32(xdr, &nullAtom))
    1:         goto bad;
13691:     if (!nullAtom && !js_XDRStringAtom(xdr, &fun->atom))
    1:         goto bad;
 8179:     if (!JS_XDRUint32(xdr, &localsword) ||
    1:         !JS_XDRUint32(xdr, &flagsword)) {
    1:         goto bad;
    1:     }
    1: 
 8179:     if (xdr->mode == JSXDR_DECODE) {
 8179:         nargs = localsword >> 16;
 8179:         nvars = localsword & JS_BITMASK(16);
13702:         JS_ASSERT(flagsword | JSFUN_INTERPRETED);
13691:         fun->flags = (uint16) flagsword;
 8179:     }
 8158: 
 8158:     /* do arguments and local vars */
13824:     n = nargs + nvars;
13824:     if (n != 0) {
10571:         void *mark;
10571:         uintN i;
10571:         uintN bitmapLength;
10571:         uint32 *bitmap;
11435:         jsuword *names;
11435:         JSAtom *name;
10571:         JSLocalKind localKind;
10571: 
10571:         mark = JS_ARENA_MARK(&xdr->cx->tempPool);
10571: 
11435:         /*
11435:          * From this point the control must flow via the label release_mark.
11435:          *
11435:          * To xdr the names we prefix the names with a bitmap descriptor and
11435:          * then xdr the names as strings. For argument names (indexes below
11435:          * nargs) the corresponding bit in the bitmap is unset when the name
11435:          * is null. Such null names are not encoded or decoded. For variable
11435:          * names (indexes starting from nargs) bitmap's bit is set when the
11435:          * name is declared as const, not as ordinary var.
11435:          * */
10571:         bitmapLength = JS_HOWMANY(n, JS_BITS_PER_UINT32);
10571:         JS_ARENA_ALLOCATE_CAST(bitmap, uint32 *, &xdr->cx->tempPool,
10571:                                bitmapLength * sizeof *bitmap);
10571:         if (!bitmap) {
10571:             js_ReportOutOfScriptQuota(xdr->cx);
10571:             ok = JS_FALSE;
10571:             goto release_mark;
10571:         }
11435:         if (xdr->mode == JSXDR_ENCODE) {
13691:             names = js_GetLocalNameArray(xdr->cx, fun, &xdr->cx->tempPool);
11435:             if (!names) {
11435:                 ok = JS_FALSE;
11435:                 goto release_mark;
10571:             }
11435:             memset(bitmap, 0, bitmapLength * sizeof *bitmap);
11435:             for (i = 0; i != n; ++i) {
13691:                 if (i < fun->nargs
11435:                     ? JS_LOCAL_NAME_TO_ATOM(names[i]) != NULL
11435:                     : JS_LOCAL_NAME_IS_CONST(names[i])) {
11435:                     bitmap[i >> JS_BITS_PER_UINT32_LOG2] |=
11435:                         JS_BIT(i & (JS_BITS_PER_UINT32 - 1));
11435:                 }
11435:             }
11435:         }
11435: #ifdef __GNUC__
11435:         else {
11435:             names = NULL;   /* quell GCC uninitialized warning */
11435:         }
11435: #endif
10571:         for (i = 0; i != bitmapLength; ++i) {
10571:             ok = JS_XDRUint32(xdr, &bitmap[i]);
10571:             if (!ok)
10571:                 goto release_mark;
10571:         }
10571:         for (i = 0; i != n; ++i) {
10571:             if (i < nargs &&
11435:                 !(bitmap[i >> JS_BITS_PER_UINT32_LOG2] &
10571:                   JS_BIT(i & (JS_BITS_PER_UINT32 - 1)))) {
10571:                 if (xdr->mode == JSXDR_DECODE) {
13691:                     ok = js_AddLocal(xdr->cx, fun, NULL, JSLOCAL_ARG);
10571:                     if (!ok)
10571:                         goto release_mark;
10571:                 } else {
11435:                     JS_ASSERT(!JS_LOCAL_NAME_TO_ATOM(names[i]));
10571:                 }
10571:                 continue;
10571:             }
10571:             if (xdr->mode == JSXDR_ENCODE)
11435:                 name = JS_LOCAL_NAME_TO_ATOM(names[i]);
10571:             ok = js_XDRStringAtom(xdr, &name);
10571:             if (!ok)
10571:                 goto release_mark;
10571:             if (xdr->mode == JSXDR_DECODE) {
10571:                 localKind = (i < nargs)
10571:                             ? JSLOCAL_ARG
11435:                             : bitmap[i >> JS_BITS_PER_UINT32_LOG2] &
10571:                               JS_BIT(i & (JS_BITS_PER_UINT32 - 1))
10571:                             ? JSLOCAL_CONST
10571:                             : JSLOCAL_VAR;
13691:                 ok = js_AddLocal(xdr->cx, fun, name, localKind);
10571:                 if (!ok)
10571:                     goto release_mark;
10571:             }
10571:         }
10571:         ok = JS_TRUE;
10571: 
10571:       release_mark:
10571:         JS_ARENA_RELEASE(&xdr->cx->tempPool, mark);
10571:         if (!ok)
10571:             goto out;
10571: 
10571:         if (xdr->mode == JSXDR_DECODE)
13691:             js_FreezeLocalNames(cx, fun);
10571:     }
    1: 
13702:     if (!js_XDRScript(xdr, &fun->u.i.script, NULL))
    1:         goto bad;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
13824:         *objp = FUN_OBJECT(fun);
11377: #ifdef CHECK_SCRIPT_OWNER
13702:         fun->u.i.script->owner = NULL;
11377: #endif
13702:         js_CallNewScriptHook(cx, fun->u.i.script, fun);
    1:     }
    1: 
    1: out:
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1:     return ok;
    1: 
    1: bad:
    1:     ok = JS_FALSE;
    1:     goto out;
    1: }
    1: 
    1: #else  /* !JS_HAS_XDR */
    1: 
    1: #define fun_xdrObject NULL
    1: 
    1: #endif /* !JS_HAS_XDR */
    1: 
    1: /*
    1:  * [[HasInstance]] internal method for Function objects: fetch the .prototype
    1:  * property of its 'this' parameter, and walks the prototype chain of v (only
    1:  * if v is an object) returning true if .prototype is found.
    1:  */
    1: static JSBool
    1: fun_hasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
    1:     jsval pval;
    1: 
    1:     if (!OBJ_GET_PROPERTY(cx, obj,
    1:                           ATOM_TO_JSID(cx->runtime->atomState
    1:                                        .classPrototypeAtom),
    1:                           &pval)) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(pval)) {
    1:         /*
    1:          * Throw a runtime error if instanceof is called on a function that
    1:          * has a non-object as its .prototype value.
    1:          */
    1:         js_ReportValueError(cx, JSMSG_BAD_PROTOTYPE,
    1:                             -1, OBJECT_TO_JSVAL(obj), NULL);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     return js_IsDelegate(cx, JSVAL_TO_OBJECT(pval), v, bp);
    1: }
    1: 
  583: static void
13824: TraceLocalNames(JSTracer *trc, JSFunction *fun);
13824: 
13824: static void
13824: DestroyLocalNames(JSContext *cx, JSFunction *fun);
13824: 
13824: static void
  583: fun_trace(JSTracer *trc, JSObject *obj)
    1: {
    1:     JSFunction *fun;
    1: 
13691:     /* A newborn function object may have a not yet initialized private slot. */
13691:     fun = (JSFunction *) JS_GetPrivate(trc->context, obj);
13824:     if (!fun)
13824:         return;
13824: 
13824:     if (FUN_OBJECT(fun) != obj) {
13824:         /* obj is cloned function object, trace the original. */
13824:         JS_CALL_TRACER(trc, FUN_OBJECT(fun), JSTRACE_OBJECT, "private");
13824:         return;
13824:     }
13824:     if (fun->atom)
13824:         JS_CALL_STRING_TRACER(trc, ATOM_TO_STRING(fun->atom), "atom");
13824:     if (FUN_INTERPRETED(fun)) {
13824:         if (fun->u.i.script)
13824:             js_TraceScript(trc, fun->u.i.script);
13824:         TraceLocalNames(trc, fun);
13824:     }
13824: }
13824: 
13824: static void
13824: fun_finalize(JSContext *cx, JSObject *obj)
13824: {
13824:     JSFunction *fun;
13824: 
13824:     /* Ignore newborn and cloned function objects. */
13824:     fun = (JSFunction *) JS_GetPrivate(cx, obj);
13824:     if (!fun || FUN_OBJECT(fun) != obj)
13824:         return;
13824: 
13824:     /*
13824:      * Null-check of u.i.script is required since the parser sets interpreted
13824:      * very early.
13824:      */
13824:     if (FUN_INTERPRETED(fun)) {
13824:         if (fun->u.i.script)
13824:             js_DestroyScript(cx, fun->u.i.script);
13824:         DestroyLocalNames(cx, fun);
13824:     }
    1: }
    1: 
    1: static uint32
    1: fun_reserveSlots(JSContext *cx, JSObject *obj)
    1: {
13691:     JSFunction *fun;
13482: 
13691:     /*
13691:      * We use JS_GetPrivate and not GET_FUNCTION_PRIVATE because during
13691:      * js_InitFunctionClass invocation the function is called before the
13691:      * private slot of the function object is set.
13691:      */
13691:     fun = (JSFunction *) JS_GetPrivate(cx, obj);
13702:     return (fun && FUN_INTERPRETED(fun) &&
13702:             fun->u.i.script && fun->u.i.script->regexpsOffset != 0)
13702:            ? JS_SCRIPT_REGEXPS(fun->u.i.script)->length
 3235:            : 0;
    1: }
    1: 
    1: /*
    1:  * Reserve two slots in all function objects for XPConnect.  Note that this
    1:  * does not bloat every instance, only those on which reserved slots are set,
    1:  * and those on which ad-hoc properties are defined.
    1:  */
    1: JS_FRIEND_DATA(JSClass) js_FunctionClass = {
    1:     js_Function_str,
    1:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE | JSCLASS_HAS_RESERVED_SLOTS(2) |
 9561:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Function),
    1:     JS_PropertyStub,  JS_PropertyStub,
    1:     fun_getProperty,  JS_PropertyStub,
    1:     fun_enumerate,    (JSResolveOp)fun_resolve,
13824:     fun_convert,      fun_finalize,
    1:     NULL,             NULL,
    1:     NULL,             NULL,
    1:     fun_xdrObject,    fun_hasInstance,
  583:     JS_CLASS_TRACE(fun_trace), fun_reserveSlots
    1: };
    1: 
 4127: static JSBool
 4127: fun_toStringHelper(JSContext *cx, uint32 indent, uintN argc, jsval *vp)
    1: {
    1:     jsval fval;
 4127:     JSObject *obj;
    1:     JSFunction *fun;
    1:     JSString *str;
    1: 
11809:     fval = JS_THIS(cx, vp);
11809:     if (JSVAL_IS_NULL(fval))
11809:         return JS_FALSE;
11809: 
    1:     if (!VALUE_IS_FUNCTION(cx, fval)) {
    1:         /*
 4127:          * If we don't have a function to start off with, try converting the
 4127:          * object to a function. If that doesn't work, complain.
    1:          */
 4127:         if (!JSVAL_IS_PRIMITIVE(fval)) {
    1:             obj = JSVAL_TO_OBJECT(fval);
    1:             if (!OBJ_GET_CLASS(cx, obj)->convert(cx, obj, JSTYPE_FUNCTION,
    1:                                                  &fval)) {
    1:                 return JS_FALSE;
    1:             }
 4127:             vp[1] = fval;
    1:         }
    1:         if (!VALUE_IS_FUNCTION(cx, fval)) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_INCOMPATIBLE_PROTO,
    1:                                  js_Function_str, js_toString_str,
 4127:                                  JS_GetTypeName(cx, JS_TypeOfValue(cx, fval)));
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     obj = JSVAL_TO_OBJECT(fval);
12681:     if (argc != 0) {
12681:         indent = js_ValueToECMAUint32(cx, &vp[2]);
12694:         if (JSVAL_IS_NULL(vp[2]))
 4127:             return JS_FALSE;
12681:     }
    1: 
 4127:     JS_ASSERT(JS_ObjectIsFunction(cx, obj));
13691:     fun = GET_FUNCTION_PRIVATE(cx, obj);
    1:     if (!fun)
    1:         return JS_TRUE;
    1:     str = JS_DecompileFunction(cx, fun, (uintN)indent);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: fun_toString(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return fun_toStringHelper(cx, 0, argc,  vp);
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
    1: static JSBool
 4127: fun_toSource(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return fun_toStringHelper(cx, JS_DONT_PRETTY_PRINT, argc, vp);
    1: }
    1: #endif
    1: 
    1: static const char call_str[] = "call";
    1: 
    1: static JSBool
 4127: fun_call(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 6040:     jsval fval, *argv, *invokevp;
    1:     JSString *str;
    1:     void *mark;
    1:     JSBool ok;
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !OBJ_DEFAULT_VALUE(cx, obj, JSTYPE_FUNCTION, &vp[1]))
    1:         return JS_FALSE;
 4127:     fval = vp[1];
    1: 
    1:     if (!VALUE_IS_FUNCTION(cx, fval)) {
    1:         str = JS_ValueToString(cx, fval);
    1:         if (str) {
    1:             const char *bytes = js_GetStringBytes(cx, str);
    1: 
    1:             if (bytes) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_INCOMPATIBLE_PROTO,
    1:                                      js_Function_str, call_str,
    1:                                      bytes);
    1:             }
    1:         }
    1:         return JS_FALSE;
    1:     }
    1: 
 4127:     argv = vp + 2;
    1:     if (argc == 0) {
    1:         /* Call fun with its global object as the 'this' param if no args. */
    1:         obj = NULL;
    1:     } else {
    1:         /* Otherwise convert the first arg to 'this' and skip over it. */
    1:         if (!JSVAL_IS_PRIMITIVE(argv[0]))
    1:             obj = JSVAL_TO_OBJECT(argv[0]);
    1:         else if (!js_ValueToObject(cx, argv[0], &obj))
    1:             return JS_FALSE;
    1:         argc--;
    1:         argv++;
    1:     }
    1: 
    1:     /* Allocate stack space for fval, obj, and the args. */
 6040:     invokevp = js_AllocStack(cx, 2 + argc, &mark);
 6040:     if (!invokevp)
    1:         return JS_FALSE;
    1: 
    1:     /* Push fval, obj, and the args. */
 6040:     invokevp[0] = fval;
 6040:     invokevp[1] = OBJECT_TO_JSVAL(obj);
 6040:     memcpy(invokevp + 2, argv, argc * sizeof *argv);
    1: 
14721:     ok = js_Invoke(cx, argc, invokevp, 0);
 6040:     *vp = *invokevp;
    1:     js_FreeStack(cx, mark);
    1:     return ok;
    1: }
    1: 
    1: static JSBool
 4127: fun_apply(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj, *aobj;
 6040:     jsval fval, *invokevp, *sp;
    1:     JSString *str;
    1:     jsuint length;
    1:     JSBool arraylike, ok;
    1:     void *mark;
    1:     uintN i;
    1: 
    1:     if (argc == 0) {
    1:         /* Will get globalObject as 'this' and no other arguments. */
 4127:         return fun_call(cx, argc, vp);
    1:     }
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !OBJ_DEFAULT_VALUE(cx, obj, JSTYPE_FUNCTION, &vp[1]))
    1:         return JS_FALSE;
 4127:     fval = vp[1];
    1: 
    1:     if (!VALUE_IS_FUNCTION(cx, fval)) {
    1:         str = JS_ValueToString(cx, fval);
    1:         if (str) {
    1:             const char *bytes = js_GetStringBytes(cx, str);
    1: 
    1:             if (bytes) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_INCOMPATIBLE_PROTO,
    1:                                      js_Function_str, "apply",
    1:                                      bytes);
    1:             }
    1:         }
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Quell GCC overwarnings. */
    1:     aobj = NULL;
    1:     length = 0;
    1: 
    1:     if (argc >= 2) {
    1:         /* If the 2nd arg is null or void, call the function with 0 args. */
 4127:         if (JSVAL_IS_NULL(vp[3]) || JSVAL_IS_VOID(vp[3])) {
    1:             argc = 0;
    1:         } else {
    1:             /* The second arg must be an array (or arguments object). */
    1:             arraylike = JS_FALSE;
 4127:             if (!JSVAL_IS_PRIMITIVE(vp[3])) {
 4127:                 aobj = JSVAL_TO_OBJECT(vp[3]);
    1:                 if (!js_IsArrayLike(cx, aobj, &arraylike, &length))
    1:                     return JS_FALSE;
    1:             }
    1:             if (!arraylike) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_BAD_APPLY_ARGS, "apply");
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     /* Convert the first arg to 'this' and skip over it. */
 4127:     if (!JSVAL_IS_PRIMITIVE(vp[2]))
 4127:         obj = JSVAL_TO_OBJECT(vp[2]);
 4127:     else if (!js_ValueToObject(cx, vp[2], &obj))
    1:         return JS_FALSE;
    1: 
    1:     /* Allocate stack space for fval, obj, and the args. */
    1:     argc = (uintN)JS_MIN(length, ARRAY_INIT_LIMIT - 1);
 6040:     invokevp = js_AllocStack(cx, 2 + argc, &mark);
 6040:     if (!invokevp)
    1:         return JS_FALSE;
    1: 
    1:     /* Push fval, obj, and aobj's elements as args. */
 6040:     sp = invokevp;
    1:     *sp++ = fval;
    1:     *sp++ = OBJECT_TO_JSVAL(obj);
    1:     for (i = 0; i < argc; i++) {
    1:         ok = JS_GetElement(cx, aobj, (jsint)i, sp);
    1:         if (!ok)
    1:             goto out;
    1:         sp++;
    1:     }
    1: 
14721:     ok = js_Invoke(cx, argc, invokevp, 0);
 6040:     *vp = *invokevp;
    1: out:
    1:     js_FreeStack(cx, mark);
    1:     return ok;
    1: }
    1: 
    1: #ifdef NARCISSUS
    1: static JSBool
 4127: fun_applyConstructor(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSObject *aobj;
    1:     uintN length, i;
    1:     void *mark;
 6040:     jsval *invokevp, *sp;
    1:     JSBool ok;
    1: 
 4127:     if (JSVAL_IS_PRIMITIVE(vp[2]) ||
 4127:         (aobj = JSVAL_TO_OBJECT(vp[2]),
    1:          OBJ_GET_CLASS(cx, aobj) != &js_ArrayClass &&
    1:          OBJ_GET_CLASS(cx, aobj) != &js_ArgumentsClass)) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_APPLY_ARGS, "__applyConstruct__");
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     if (!js_GetLengthProperty(cx, aobj, &length))
    1:         return JS_FALSE;
    1: 
    1:     if (length >= ARRAY_INIT_LIMIT)
    1:         length = ARRAY_INIT_LIMIT - 1;
 6040:     invokevp = js_AllocStack(cx, 2 + length, &mark);
 6040:     if (!invokevp)
    1:         return JS_FALSE;
    1: 
 6040:     sp = invokevp;
 4127:     *sp++ = vp[1];
11809:     *sp++ = JSVAL_NULL; /* this is filled automagically */
    1:     for (i = 0; i < length; i++) {
    1:         ok = JS_GetElement(cx, aobj, (jsint)i, sp);
    1:         if (!ok)
    1:             goto out;
    1:         sp++;
    1:     }
    1: 
14789:     ok = js_InvokeConstructor(cx, length, invokevp);
 6040:     *vp = *invokevp;
    1: out:
    1:     js_FreeStack(cx, mark);
    1:     return ok;
    1: }
    1: #endif
    1: 
    1: static JSFunctionSpec function_methods[] = {
    1: #if JS_HAS_TOSOURCE
 6917:     JS_FN(js_toSource_str,   fun_toSource,   0,0,0),
    1: #endif
 6917:     JS_FN(js_toString_str,   fun_toString,   0,0,0),
 6917:     JS_FN("apply",           fun_apply,      0,2,0),
 6917:     JS_FN(call_str,          fun_call,       0,1,0),
    1: #ifdef NARCISSUS
 6917:     JS_FN("__applyConstructor__", fun_applyConstructor, 0,1,0),
    1: #endif
 4127:     JS_FS_END
    1: };
    1: 
    1: static JSBool
    1: Function(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSStackFrame *fp, *caller;
13702:     JSFunction *fun;
    1:     JSObject *parent;
 8179:     uintN i, n, lineno;
    1:     JSAtom *atom;
    1:     const char *filename;
 8179:     JSBool ok;
    1:     JSString *str, *arg;
 8444:     JSTokenStream ts;
    1:     JSPrincipals *principals;
    1:     jschar *collected_args, *cp;
 6561:     void *mark;
    1:     size_t arg_length, args_length, old_args_length;
    1:     JSTokenType tt;
    1: 
    1:     fp = cx->fp;
13691:     if (!(fp->flags & JSFRAME_CONSTRUCTING)) {
13824:         obj = js_NewObject(cx, &js_FunctionClass, NULL, NULL, 0);
13691:         if (!obj)
13691:             return JS_FALSE;
13691:         *rval = OBJECT_TO_JSVAL(obj);
13824:     } else {
13824:         /*
13824:          * The constructor is called before the private slot is initialized so
13824:          * we must use JS_GetPrivate, not GET_FUNCTION_PRIVATE here.
13824:          */
13824:         if (JS_GetPrivate(cx, obj))
13824:             return JS_TRUE;
13691:     }
13691: 
13691:     /*
    1:      * NB: (new Function) is not lexically closed by its caller, it's just an
    1:      * anonymous function in the top-level scope that its constructor inhabits.
    1:      * Thus 'var x = 42; f = new Function("return x"); print(f())' prints 42,
    1:      * and so would a call to f from another top-level's script or function.
    1:      *
    1:      * In older versions, before call objects, a new Function was adopted by
    1:      * its running context's globalObject, which might be different from the
    1:      * top-level reachable from scopeChain (in HTML frames, e.g.).
    1:      */
    1:     parent = OBJ_GET_PARENT(cx, JSVAL_TO_OBJECT(argv[-2]));
    1: 
13702:     fun = js_NewFunction(cx, obj, NULL, 0, JSFUN_LAMBDA | JSFUN_INTERPRETED,
13702:                          parent, cx->runtime->atomState.anonymousAtom);
    1: 
13691:     if (!fun)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * Function is static and not called directly by other functions in this
    1:      * file, therefore it is callable only as a native function by js_Invoke.
    1:      * Find the scripted caller, possibly skipping other native frames such as
    1:      * are built for Function.prototype.call or .apply activations that invoke
    1:      * Function indirectly from a script.
    1:      */
13702:     JS_ASSERT(!fp->script && fp->fun && fp->fun->u.n.native == Function);
    1:     caller = JS_GetScriptedCaller(cx, fp);
    1:     if (caller) {
10697:         principals = JS_EvalFramePrincipals(cx, fp, caller);
12690:         filename = js_ComputeFilename(cx, caller, principals, &lineno);
    1:     } else {
    1:         filename = NULL;
    1:         lineno = 0;
    1:         principals = NULL;
    1:     }
    1: 
    1:     /* Belt-and-braces: check that the caller has access to parent. */
    1:     if (!js_CheckPrincipalsAccess(cx, parent, principals,
    1:                                   CLASS_ATOM(cx, Function))) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     n = argc ? argc - 1 : 0;
    1:     if (n > 0) {
 6561:         enum { OK, BAD, BAD_FORMAL } state;
 6561: 
    1:         /*
    1:          * Collect the function-argument arguments into one string, separated
    1:          * by commas, then make a tokenstream from that string, and scan it to
    1:          * get the arguments.  We need to throw the full scanner at the
    1:          * problem, because the argument string can legitimately contain
    1:          * comments and linefeeds.  XXX It might be better to concatenate
    1:          * everything up into a function definition and pass it to the
    1:          * compiler, but doing it this way is less of a delta from the old
    1:          * code.  See ECMA 15.3.2.1.
    1:          */
 6561:         state = BAD_FORMAL;
    1:         args_length = 0;
    1:         for (i = 0; i < n; i++) {
    1:             /* Collect the lengths for all the function-argument arguments. */
    1:             arg = js_ValueToString(cx, argv[i]);
    1:             if (!arg)
    1:                 return JS_FALSE;
    1:             argv[i] = STRING_TO_JSVAL(arg);
    1: 
    1:             /*
    1:              * Check for overflow.  The < test works because the maximum
    1:              * JSString length fits in 2 fewer bits than size_t has.
    1:              */
    1:             old_args_length = args_length;
    1:             args_length = old_args_length + JSSTRING_LENGTH(arg);
    1:             if (args_length < old_args_length) {
12983:                 js_ReportAllocationOverflow(cx);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1: 
    1:         /* Add 1 for each joining comma and check for overflow (two ways). */
    1:         old_args_length = args_length;
    1:         args_length = old_args_length + n - 1;
    1:         if (args_length < old_args_length ||
    1:             args_length >= ~(size_t)0 / sizeof(jschar)) {
12983:             js_ReportAllocationOverflow(cx);
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /*
    1:          * Allocate a string to hold the concatenated arguments, including room
    1:          * for a terminating 0.  Mark cx->tempPool for later release, to free
    1:          * collected_args and its tokenstream in one swoop.
    1:          */
    1:         mark = JS_ARENA_MARK(&cx->tempPool);
    1:         JS_ARENA_ALLOCATE_CAST(cp, jschar *, &cx->tempPool,
    1:                                (args_length+1) * sizeof(jschar));
    1:         if (!cp) {
 8296:             js_ReportOutOfScriptQuota(cx);
    1:             return JS_FALSE;
    1:         }
    1:         collected_args = cp;
    1: 
    1:         /*
    1:          * Concatenate the arguments into the new string, separated by commas.
    1:          */
    1:         for (i = 0; i < n; i++) {
    1:             arg = JSVAL_TO_STRING(argv[i]);
    1:             arg_length = JSSTRING_LENGTH(arg);
    1:             (void) js_strncpy(cp, JSSTRING_CHARS(arg), arg_length);
    1:             cp += arg_length;
    1: 
    1:             /* Add separating comma or terminating 0. */
    1:             *cp++ = (i + 1 < n) ? ',' : 0;
    1:         }
    1: 
 6561:         /* Initialize a tokenstream that reads from the given string. */
 8444:         if (!js_InitTokenStream(cx, &ts, collected_args, args_length,
 8444:                                 NULL, filename, lineno)) {
    1:             JS_ARENA_RELEASE(&cx->tempPool, mark);
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /* The argument string may be empty or contain no tokens. */
 8444:         tt = js_GetToken(cx, &ts);
    1:         if (tt != TOK_EOF) {
    1:             for (;;) {
    1:                 /*
    1:                  * Check that it's a name.  This also implicitly guards against
    1:                  * TOK_ERROR, which was already reported.
    1:                  */
    1:                 if (tt != TOK_NAME)
 6561:                     goto after_args;
    1: 
    1:                 /*
 8444:                  * Get the atom corresponding to the name from the token
 8444:                  * stream; we're assured at this point that it's a valid
 8444:                  * identifier.
    1:                  */
 8444:                 atom = CURRENT_TOKEN(&ts).t_atom;
    1: 
 8179:                 /* Check for a duplicate parameter name. */
13691:                 if (js_LookupLocal(cx, fun, atom, NULL) != JSLOCAL_NONE) {
 8179:                     const char *name;
 8179: 
 8179:                     name = js_AtomToPrintableString(cx, atom);
    1:                     ok = name &&
 8444:                          js_ReportCompileErrorNumber(cx, &ts, NULL,
    1:                                                      JSREPORT_WARNING |
    1:                                                      JSREPORT_STRICT,
    1:                                                      JSMSG_DUPLICATE_FORMAL,
    1:                                                      name);
    1:                     if (!ok)
 6561:                         goto after_args;
    1:                 }
13691:                 if (!js_AddLocal(cx, fun, atom, JSLOCAL_ARG))
 6561:                     goto after_args;
    1: 
    1:                 /*
    1:                  * Get the next token.  Stop on end of stream.  Otherwise
    1:                  * insist on a comma, get another name, and iterate.
    1:                  */
 8444:                 tt = js_GetToken(cx, &ts);
    1:                 if (tt == TOK_EOF)
    1:                     break;
    1:                 if (tt != TOK_COMMA)
 6561:                     goto after_args;
 8444:                 tt = js_GetToken(cx, &ts);
    1:             }
    1:         }
    1: 
 6561:         state = OK;
 6561:       after_args:
 8444:         if (state == BAD_FORMAL && !(ts.flags & TSF_ERROR)) {
 6561:             /*
 6561:              * Report "malformed formal parameter" iff no illegal char or
 6561:              * similar scanner error was already reported.
 6561:              */
 6561:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 6561:                                  JSMSG_BAD_FORMAL);
 6561:         }
 8444:         js_CloseTokenStream(cx, &ts);
    1:         JS_ARENA_RELEASE(&cx->tempPool, mark);
 6561:         if (state != OK)
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     if (argc) {
    1:         str = js_ValueToString(cx, argv[argc-1]);
    1:         if (!str)
    1:             return JS_FALSE;
 4076:         argv[argc-1] = STRING_TO_JSVAL(str);
 4076:     } else {
 4076:         str = cx->runtime->emptyString;
    1:     }
    1: 
13691:     return js_CompileFunctionBody(cx, fun, principals,
 8444:                                   JSSTRING_CHARS(str), JSSTRING_LENGTH(str),
 8444:                                   filename, lineno);
    1: }
    1: 
    1: JSObject *
    1: js_InitFunctionClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto;
13702:     JSFunction *fun;
    1: 
    1:     proto = JS_InitClass(cx, obj, NULL, &js_FunctionClass, Function, 1,
    1:                          function_props, function_methods, NULL, NULL);
    1:     if (!proto)
    1:         return NULL;
13702:     fun = js_NewFunction(cx, proto, NULL, 0, JSFUN_INTERPRETED, obj, NULL);
13691:     if (!fun)
    1:         goto bad;
13702:     fun->u.i.script = js_NewScript(cx, 1, 0, 0, 0, 0, 0);
13702:     if (!fun->u.i.script)
    1:         goto bad;
13702:     fun->u.i.script->code[0] = JSOP_STOP;
11377: #ifdef CHECK_SCRIPT_OWNER
13702:     fun->u.i.script->owner = NULL;
11377: #endif
    1:     return proto;
    1: 
    1: bad:
    1:     cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:     return NULL;
    1: }
    1: 
    1: JSObject *
    1: js_InitCallClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto;
    1: 
    1:     proto = JS_InitClass(cx, obj, NULL, &js_CallClass, NULL, 0,
 2514:                          NULL, NULL, NULL, NULL);
    1:     if (!proto)
    1:         return NULL;
    1: 
    1:     /*
    1:      * Null Call.prototype's proto slot so that Object.prototype.* does not
    1:      * pollute the scope of heavyweight functions.
    1:      */
    1:     OBJ_SET_PROTO(cx, proto, NULL);
    1:     return proto;
    1: }
    1: 
13702: JSFunction *
13702: js_NewFunction(JSContext *cx, JSObject *funobj, JSNative native, uintN nargs,
13702:                uintN flags, JSObject *parent, JSAtom *atom)
    1: {
13702:     JSFunction *fun;
    1: 
    1:     if (funobj) {
13824:         JS_ASSERT(HAS_FUNCTION_CLASS(funobj));
13691:         OBJ_SET_PARENT(cx, funobj, parent);
    1:     } else {
13824:         funobj = js_NewObject(cx, &js_FunctionClass, NULL, parent, 0);
    1:         if (!funobj)
    1:             return NULL;
    1:     }
13824:     JS_ASSERT(funobj->fslots[JSSLOT_PRIVATE] == JSVAL_VOID);
13824:     fun = (JSFunction *) funobj;
    1: 
    1:     /* Initialize all function members. */
13702:     fun->nargs = nargs;
13702:     fun->flags = flags & (JSFUN_FLAGS_MASK | JSFUN_INTERPRETED);
13702:     if (flags & JSFUN_INTERPRETED) {
13702:         JS_ASSERT(!native);
13702:         JS_ASSERT(nargs == 0);
13702:         fun->u.i.nvars = 0;
13702:         fun->u.i.spare = 0;
13702:         fun->u.i.script = NULL;
 8367: #ifdef DEBUG
13702:         fun->u.i.names.taggedAtom = 0;
 8367: #endif
13702:     } else {
13702:         fun->u.n.native = native;
13702:         fun->u.n.extra = 0;
13702:         fun->u.n.minargs = 0;
13702:         fun->u.n.clasp = NULL;
13702:     }
13702:     fun->atom = atom;
    1: 
13824:     /* Set private to self to indicate non-cloned fully initialized function. */
13824:     FUN_OBJECT(fun)->fslots[JSSLOT_PRIVATE] = PRIVATE_TO_JSVAL(fun);
13702:     return fun;
    1: }
    1: 
13824: JSObject *
13824: js_CloneFunctionObject(JSContext *cx, JSFunction *fun, JSObject *parent)
13824: {
13824:     JSObject *clone;
 8367: 
 4275:     /*
13824:      * The cloned function object does not need the extra fields beyond
13824:      * JSObject as it points to fun via the private slot.
 4275:      */
13824:     clone = js_NewObject(cx, &js_FunctionClass, NULL, parent,
13824:                          sizeof(JSObject));
13824:     if (!clone)
    1:         return NULL;
13824:     clone->fslots[JSSLOT_PRIVATE] = PRIVATE_TO_JSVAL(fun);
13824:     return clone;
13702: }
13702: 
13702: JSFunction *
    1: js_DefineFunction(JSContext *cx, JSObject *obj, JSAtom *atom, JSNative native,
    1:                   uintN nargs, uintN attrs)
    1: {
13702:     JSFunction *fun;
11377:     JSPropertyOp gsop;
    1: 
13702:     fun = js_NewFunction(cx, NULL, native, nargs, attrs, obj, atom);
    1:     if (!fun)
    1:         return NULL;
11377:     gsop = (attrs & JSFUN_STUB_GSOPS) ? JS_PropertyStub : NULL;
    1:     if (!OBJ_DEFINE_PROPERTY(cx, obj, ATOM_TO_JSID(atom),
13824:                              OBJECT_TO_JSVAL(FUN_OBJECT(fun)),
11377:                              gsop, gsop,
    1:                              attrs & ~JSFUN_FLAGS_MASK, NULL)) {
    1:         return NULL;
    1:     }
    1:     return fun;
    1: }
    1: 
    1: #if (JSV2F_CONSTRUCT & JSV2F_SEARCH_STACK)
    1: # error "JSINVOKE_CONSTRUCT and JSV2F_SEARCH_STACK are not disjoint!"
    1: #endif
    1: 
    1: JSFunction *
    1: js_ValueToFunction(JSContext *cx, jsval *vp, uintN flags)
    1: {
    1:     jsval v;
    1:     JSObject *obj;
    1: 
    1:     v = *vp;
    1:     obj = NULL;
    1:     if (JSVAL_IS_OBJECT(v)) {
    1:         obj = JSVAL_TO_OBJECT(v);
13691:         if (obj && OBJ_GET_CLASS(cx, obj) != &js_FunctionClass) {
    1:             if (!OBJ_DEFAULT_VALUE(cx, obj, JSTYPE_FUNCTION, &v))
    1:                 return NULL;
    1:             obj = VALUE_IS_FUNCTION(cx, v) ? JSVAL_TO_OBJECT(v) : NULL;
    1:         }
    1:     }
    1:     if (!obj) {
    1:         js_ReportIsNotFunction(cx, vp, flags);
    1:         return NULL;
    1:     }
13691:     return GET_FUNCTION_PRIVATE(cx, obj);
    1: }
    1: 
    1: JSObject *
    1: js_ValueToFunctionObject(JSContext *cx, jsval *vp, uintN flags)
    1: {
    1:     JSFunction *fun;
    1:     JSStackFrame *caller;
    1:     JSPrincipals *principals;
    1: 
    1:     if (VALUE_IS_FUNCTION(cx, *vp))
    1:         return JSVAL_TO_OBJECT(*vp);
    1: 
    1:     fun = js_ValueToFunction(cx, vp, flags);
    1:     if (!fun)
    1:         return NULL;
13824:     *vp = OBJECT_TO_JSVAL(FUN_OBJECT(fun));
    1: 
    1:     caller = JS_GetScriptedCaller(cx, cx->fp);
    1:     if (caller) {
11126:         principals = JS_StackFramePrincipals(cx, caller);
    1:     } else {
    1:         /* No scripted caller, don't allow access. */
    1:         principals = NULL;
    1:     }
    1: 
13824:     if (!js_CheckPrincipalsAccess(cx, FUN_OBJECT(fun), principals,
13702:                                   fun->atom
13702:                                   ? fun->atom
    1:                                   : cx->runtime->atomState.anonymousAtom)) {
    1:         return NULL;
    1:     }
13824:     return FUN_OBJECT(fun);
    1: }
    1: 
    1: JSObject *
    1: js_ValueToCallableObject(JSContext *cx, jsval *vp, uintN flags)
    1: {
    1:     JSObject *callable;
    1: 
    1:     callable = JSVAL_IS_PRIMITIVE(*vp) ? NULL : JSVAL_TO_OBJECT(*vp);
    1:     if (callable &&
    1:         ((callable->map->ops == &js_ObjectOps)
    1:          ? OBJ_GET_CLASS(cx, callable)->call
    1:          : callable->map->ops->call)) {
    1:         *vp = OBJECT_TO_JSVAL(callable);
    1:     } else {
    1:         callable = js_ValueToFunctionObject(cx, vp, flags);
    1:     }
    1:     return callable;
    1: }
    1: 
    1: void
    1: js_ReportIsNotFunction(JSContext *cx, jsval *vp, uintN flags)
    1: {
    1:     JSStackFrame *fp;
    1:     uintN error;
    1:     const char *name, *source;
14218:     JSTempValueRooter tvr;
    1: 
13168:     for (fp = cx->fp; fp && !fp->regs; fp = fp->down)
    1:         continue;
14218:     name = source = NULL;
14218:     JS_PUSH_TEMP_ROOT_STRING(cx, NULL, &tvr);
    1:     if (flags & JSV2F_ITERATOR) {
    1:         error = JSMSG_BAD_ITERATOR;
    1:         name = js_iterator_str;
14218:         tvr.u.string = js_ValueToSource(cx, *vp);
14218:         if (!tvr.u.string)
14218:             goto out;
14218:         tvr.u.string = js_QuoteString(cx, tvr.u.string, 0);
14218:         if (!tvr.u.string)
14218:             goto out;
14218:         source = js_GetStringBytes(cx, tvr.u.string);
    1:         if (!source)
14218:             goto out;
    1:     } else if (flags & JSV2F_CONSTRUCT) {
    1:         error = JSMSG_NOT_CONSTRUCTOR;
    1:     } else {
    1:         error = JSMSG_NOT_FUNCTION;
    1:     }
    1: 
    1:     js_ReportValueError3(cx, error,
13168:                          (fp && fp->regs &&
13168:                           fp->spbase <= vp && vp < fp->regs->sp)
13168:                          ? vp - fp->regs->sp
    1:                          : (flags & JSV2F_SEARCH_STACK)
    1:                          ? JSDVG_SEARCH_STACK
    1:                          : JSDVG_IGNORE_STACK,
    1:                          *vp, NULL,
    1:                          name, source);
14218: 
14218:   out:
14218:     JS_POP_TEMP_ROOT(cx, &tvr);
    1: }
 8179: 
 8367: /*
 8367:  * When a function has between 2 and MAX_ARRAY_LOCALS arguments and variables,
 8367:  * their name are stored as the JSLocalNames.array.
 8367:  */
 8367: #define MAX_ARRAY_LOCALS 8
 8367: 
 8367: JS_STATIC_ASSERT(2 <= MAX_ARRAY_LOCALS);
 8367: JS_STATIC_ASSERT(MAX_ARRAY_LOCALS < JS_BITMASK(16));
 8367: 
 8367: /*
 8367:  * We use the lowest bit of the string atom to distinguish const from var
 8367:  * name when there is only single name or when names are stored as an array.
 8367:  */
 8367: JS_STATIC_ASSERT((JSVAL_STRING & 1) == 0);
 8367: 
 8367: /*
 8367:  * When we use a hash table to store the local names, we use a singly linked
 8367:  * list to record the indexes of duplicated parameter names to preserve the
 8367:  * duplicates for the decompiler.
 8367:  */
 8367: typedef struct JSNameIndexPair JSNameIndexPair;
 8367: 
 8367: struct JSNameIndexPair {
 8367:     JSAtom          *name;
 8367:     uint16          index;
 8367:     JSNameIndexPair *link;
 8367: };
 8367: 
 8367: struct JSLocalNameMap {
 8367:     JSDHashTable    names;
 8367:     JSNameIndexPair *lastdup;
 8367: };
 8367: 
 8367: typedef struct JSLocalNameHashEntry {
 8367:     JSDHashEntryHdr hdr;
 8367:     JSAtom          *name;
 8367:     uint16          index;
 8367:     uint8           localKind;
 8367: } JSLocalNameHashEntry;
 8367: 
 8367: static void
 8367: FreeLocalNameHash(JSContext *cx, JSLocalNameMap *map)
 8367: {
 8367:     JSNameIndexPair *dup, *next;
 8367: 
 8367:     for (dup = map->lastdup; dup; dup = next) {
 8367:         next = dup->link;
 8367:         JS_free(cx, dup);
 8367:     }
 8367:     JS_DHashTableFinish(&map->names);
 8367:     JS_free(cx, map);
 8367: }
 8367: 
 8367: static JSBool
 8367: HashLocalName(JSContext *cx, JSLocalNameMap *map, JSAtom *name,
 8367:               JSLocalKind localKind, uintN index)
 8367: {
 8367:     JSLocalNameHashEntry *entry;
 8367:     JSNameIndexPair *dup;
 8367: 
 8367:     JS_ASSERT(index <= JS_BITMASK(16));
 8367: #if JS_HAS_DESTRUCTURING
 8367:     if (!name) {
 8367:         /* A destructuring pattern does not need a hash entry. */
 8367:         JS_ASSERT(localKind == JSLOCAL_ARG);
 8367:         return JS_TRUE;
 8367:     }
 8367: #endif
 8367:     JS_ASSERT(ATOM_IS_STRING(name));
 8367:     entry = (JSLocalNameHashEntry *)
 8367:             JS_DHashTableOperate(&map->names, name, JS_DHASH_ADD);
 8367:     if (!entry) {
 8367:         JS_ReportOutOfMemory(cx);
 8367:         return JS_FALSE;
 8367:     }
 8367:     if (entry->name) {
 8367:         JS_ASSERT(entry->name == name);
 8367:         JS_ASSERT(entry->localKind == JSLOCAL_ARG);
 8367:         dup = (JSNameIndexPair *) JS_malloc(cx, sizeof *dup);
 8367:         if (!dup)
 8367:             return JS_FALSE;
 8367:         dup->name = entry->name;
 8367:         dup->index = entry->index;
 8367:         dup->link = map->lastdup;
 8367:         map->lastdup = dup;
 8367:     }
 8367:     entry->name = name;
 8367:     entry->index = (uint16) index;
 8367:     entry->localKind = (uint8) localKind;
 8367:     return JS_TRUE;
 8367: }
 8367: 
 8179: JSBool
13702: js_AddLocal(JSContext *cx, JSFunction *fun, JSAtom *atom, JSLocalKind kind)
 8179: {
 8367:     jsuword taggedAtom;
 8179:     uint16 *indexp;
 8367:     uintN n, i;
 8367:     jsuword *array;
 8367:     JSLocalNameMap *map;
 8179: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
13702:     JS_ASSERT(!fun->u.i.script);
 8367:     JS_ASSERT(((jsuword) atom & 1) == 0);
 8367:     taggedAtom = (jsuword) atom;
 8179:     if (kind == JSLOCAL_ARG) {
 8367:         indexp = &fun->nargs;
 8367:     } else {
13702:         indexp = &fun->u.i.nvars;
 8367:         if (kind == JSLOCAL_CONST)
 8367:             taggedAtom |= 1;
 8367:         else
 8367:             JS_ASSERT(kind == JSLOCAL_VAR);
 8367:     }
11435:     n = JS_GET_LOCAL_NAME_COUNT(fun);
 8367:     if (n == 0) {
13702:         JS_ASSERT(fun->u.i.names.taggedAtom == 0);
13702:         fun->u.i.names.taggedAtom = taggedAtom;
 8367:     } else if (n < MAX_ARRAY_LOCALS) {
 8367:         if (n > 1) {
13702:             array = fun->u.i.names.array;
 8367:         } else {
 8367:             array = (jsuword *) JS_malloc(cx, MAX_ARRAY_LOCALS * sizeof *array);
 8367:             if (!array)
 8367:                 return JS_FALSE;
13702:             array[0] = fun->u.i.names.taggedAtom;
13702:             fun->u.i.names.array = array;
 8367:         }
 8367:         if (kind == JSLOCAL_ARG) {
 8367:             /*
 8367:              * A destructuring argument pattern adds variables, not arguments,
 8367:              * so for the following arguments nvars != 0.
 8367:              */
 8179: #if JS_HAS_DESTRUCTURING
13702:             if (fun->u.i.nvars != 0) {
 8367:                 memmove(array + fun->nargs + 1, array + fun->nargs,
13702:                         fun->u.i.nvars * sizeof *array);
 8179:             }
 8367: #else
13702:             JS_ASSERT(fun->u.i.nvars == 0);
 8179: #endif
 8367:             array[fun->nargs] = taggedAtom;
 8179:         } else {
 8367:             array[n] = taggedAtom;
 8367:         }
 8367:     } else if (n == MAX_ARRAY_LOCALS) {
13702:         array = fun->u.i.names.array;
 8367:         map = (JSLocalNameMap *) JS_malloc(cx, sizeof *map);
 8367:         if (!map)
 8367:             return JS_FALSE;
 8367:         if (!JS_DHashTableInit(&map->names, JS_DHashGetStubOps(),
 8367:                                NULL, sizeof(JSLocalNameHashEntry),
 8367:                                JS_DHASH_DEFAULT_CAPACITY(MAX_ARRAY_LOCALS
 8367:                                                          * 2))) {
 8367:             JS_ReportOutOfMemory(cx);
 8367:             JS_free(cx, map);
 8367:             return JS_FALSE;
 8179:         }
 8179: 
 8367:         map->lastdup = NULL;
 8367:         for (i = 0; i != MAX_ARRAY_LOCALS; ++i) {
 8367:             taggedAtom = array[i];
 8367:             if (!HashLocalName(cx, map, (JSAtom *) (taggedAtom & ~1),
 8367:                                (i < fun->nargs)
 8367:                                ? JSLOCAL_ARG
 8367:                                : (taggedAtom & 1) ? JSLOCAL_CONST : JSLOCAL_VAR,
 8367:                                (i < fun->nargs) ? i : i - fun->nargs)) {
 8367:                 FreeLocalNameHash(cx, map);
 8367:                 return JS_FALSE;
 8367:             }
 8367:         }
 8367:         if (!HashLocalName(cx, map, atom, kind, *indexp)) {
 8367:             FreeLocalNameHash(cx, map);
 8367:             return JS_FALSE;
 8367:         }
 8367: 
 8367:         /*
 8367:          * At this point the entry is added and we cannot fail. It is time
 8367:          * to replace fun->u.i.names with the built map.
 8367:          */
13702:         fun->u.i.names.map = map;
 8367:         JS_free(cx, array);
 8367:     } else {
 8179:         if (*indexp == JS_BITMASK(16)) {
 8179:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 8179:                                  (kind == JSLOCAL_ARG)
 8179:                                  ? JSMSG_TOO_MANY_FUN_ARGS
 8179:                                  : JSMSG_TOO_MANY_FUN_VARS);
 8179:             return JS_FALSE;
 8179:         }
13702:         if (!HashLocalName(cx, fun->u.i.names.map, atom, kind, *indexp))
 8179:             return JS_FALSE;
 8179:     }
 8179: 
 8367:     /* Update the argument or variable counter. */
 8179:     ++*indexp;
 8179:     return JS_TRUE;
 8179: }
 8179: 
 8179: JSLocalKind
13702: js_LookupLocal(JSContext *cx, JSFunction *fun, JSAtom *atom, uintN *indexp)
 8179: {
 8367:     uintN n, i;
 8367:     jsuword *array;
 8367:     JSLocalNameHashEntry *entry;
 8179: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
11435:     n = JS_GET_LOCAL_NAME_COUNT(fun);
 8367:     if (n == 0)
 8367:         return JSLOCAL_NONE;
 8367:     if (n <= MAX_ARRAY_LOCALS) {
13702:         array = (n == 1) ? &fun->u.i.names.taggedAtom : fun->u.i.names.array;
 8179: 
 8367:         /* Search from the tail to pick up the last duplicated name. */
 8367:         i = n;
 8367:         do {
 8367:             --i;
11435:             if (atom == JS_LOCAL_NAME_TO_ATOM(array[i])) {
 8367:                 if (i < fun->nargs) {
 8367:                     if (indexp)
 8367:                         *indexp = i;
 8367:                     return JSLOCAL_ARG;
 8179:                 }
 8179:                 if (indexp)
 8367:                     *indexp = i - fun->nargs;
11435:                 return JS_LOCAL_NAME_IS_CONST(array[i])
11435:                        ? JSLOCAL_CONST
11435:                        : JSLOCAL_VAR;
 8179:             }
 8367:         } while (i != 0);
 8367:     } else {
 8367:         entry = (JSLocalNameHashEntry *)
13702:                 JS_DHashTableOperate(&fun->u.i.names.map->names, atom,
 8367:                                      JS_DHASH_LOOKUP);
 8367:         if (JS_DHASH_ENTRY_IS_BUSY(&entry->hdr)) {
 8367:             JS_ASSERT(entry->localKind != JSLOCAL_NONE);
 8367:             if (indexp)
 8367:                 *indexp = entry->index;
 8367:             return (JSLocalKind) entry->localKind;
 8179:         }
 8367:     }
 8367:     return JSLOCAL_NONE;
 8367: }
 8367: 
11435: typedef struct JSLocalNameEnumeratorArgs {
13702:     JSFunction      *fun;
11435:     jsuword         *names;
 8367: #ifdef DEBUG
 8367:     uintN           nCopiedArgs;
 8367:     uintN           nCopiedVars;
 8367: #endif
11435: } JSLocalNameEnumeratorArgs;
 8367: 
 8367: JS_STATIC_DLL_CALLBACK(JSDHashOperator)
 8367: get_local_names_enumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
 8367:                            uint32 number, void *arg)
 8367: {
 8367:     JSLocalNameHashEntry *entry;
11435:     JSLocalNameEnumeratorArgs *args;
 8367:     uint i;
11435:     jsuword constFlag;
 8367: 
 8367:     entry = (JSLocalNameHashEntry *) hdr;
11435:     args = (JSLocalNameEnumeratorArgs *) arg;
 8367:     JS_ASSERT(entry->name);
 8367:     if (entry->localKind == JSLOCAL_ARG) {
 8367:         JS_ASSERT(entry->index < args->fun->nargs);
 8367:         JS_ASSERT(args->nCopiedArgs++ < args->fun->nargs);
 8367:         i = entry->index;
11435:         constFlag = 0;
 8367:     } else {
 8367:         JS_ASSERT(entry->localKind == JSLOCAL_VAR ||
 8367:                   entry->localKind == JSLOCAL_CONST);
13702:         JS_ASSERT(entry->index < args->fun->u.i.nvars);
13702:         JS_ASSERT(args->nCopiedVars++ < args->fun->u.i.nvars);
 8367:         i = args->fun->nargs + entry->index;
11435:         constFlag = (entry->localKind == JSLOCAL_CONST);
 8367:     }
11435:     args->names[i] = (jsuword) entry->name | constFlag;
 8367:     return JS_DHASH_NEXT;
 8179: }
 8179: 
11435: jsuword *
13702: js_GetLocalNameArray(JSContext *cx, JSFunction *fun, JSArenaPool *pool)
 8179: {
11435:     uintN n;
11435:     jsuword *names;
 8367:     JSLocalNameMap *map;
11435:     JSLocalNameEnumeratorArgs args;
 8367:     JSNameIndexPair *dup;
 8179: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
11435:     n = JS_GET_LOCAL_NAME_COUNT(fun);
 8179:     JS_ASSERT(n != 0);
11435: 
11435:     if (n <= MAX_ARRAY_LOCALS)
13702:         return (n == 1) ? &fun->u.i.names.taggedAtom : fun->u.i.names.array;
11435: 
11435:     /*
11435:      * No need to check for overflow of the allocation size as we are making a
11435:      * copy of already allocated data. As such it must fit size_t.
11435:      */
11435:     JS_ARENA_ALLOCATE_CAST(names, jsuword *, pool, (size_t) n * sizeof *names);
10476:     if (!names) {
10476:         js_ReportOutOfScriptQuota(cx);
 8179:         return NULL;
10476:     }
 8179: 
 8179: #if JS_HAS_DESTRUCTURING
 8179:     /* Some parameter names can be NULL due to destructuring patterns. */
 8179:     memset(names, 0, fun->nargs * sizeof *names);
 8179: #endif
13702:     map = fun->u.i.names.map;
 8367:     args.fun = fun;
 8367:     args.names = names;
 8367: #ifdef DEBUG
 8367:     args.nCopiedArgs = 0;
 8367:     args.nCopiedVars = 0;
 8367: #endif
 8367:     JS_DHashTableEnumerate(&map->names, get_local_names_enumerator, &args);
 8367:     for (dup = map->lastdup; dup; dup = dup->link) {
 8367:         JS_ASSERT(dup->index < fun->nargs);
 8367:         JS_ASSERT(args.nCopiedArgs++ < fun->nargs);
11435:         names[dup->index] = (jsuword) dup->name;
 8179:     }
 8179: #if !JS_HAS_DESTRUCTURING
 8367:     JS_ASSERT(args.nCopiedArgs == fun->nargs);
 8179: #endif
13702:     JS_ASSERT(args.nCopiedVars == fun->u.i.nvars);
10472: 
10472:     return names;
 8367: }
 8367: 
 8367: JS_STATIC_DLL_CALLBACK(JSDHashOperator)
 8367: trace_local_names_enumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
 8367:                              uint32 number, void *arg)
 8367: {
 8367:     JSLocalNameHashEntry *entry;
 8367:     JSTracer *trc;
 8367: 
 8367:     entry = (JSLocalNameHashEntry *) hdr;
 8367:     JS_ASSERT(entry->name);
 8367:     trc = (JSTracer *) arg;
 8367:     JS_SET_TRACING_INDEX(trc,
 8367:                          entry->localKind == JSLOCAL_ARG ? "arg" : "var",
 8367:                          entry->index);
 8367:     JS_CallTracer(trc, ATOM_TO_STRING(entry->name), JSTRACE_STRING);
 8367:     return JS_DHASH_NEXT;
 8367: }
 8367: 
 8367: static void
13702: TraceLocalNames(JSTracer *trc, JSFunction *fun)
 8367: {
 8367:     uintN n, i;
 8367:     JSAtom *atom;
 8367:     jsuword *array;
 8367: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
11435:     n = JS_GET_LOCAL_NAME_COUNT(fun);
 8367:     if (n == 0)
 8367:         return;
 8367:     if (n <= MAX_ARRAY_LOCALS) {
13702:         array = (n == 1) ? &fun->u.i.names.taggedAtom : fun->u.i.names.array;
 8367:         i = n;
 8367:         do {
 8367:             --i;
 8367:             atom = (JSAtom *) (array[i] & ~1);
 8367:             if (atom) {
 8367:                 JS_SET_TRACING_INDEX(trc,
 8367:                                      i < fun->nargs ? "arg" : "var",
 8367:                                      i < fun->nargs ? i : i - fun->nargs);
 8367:                 JS_CallTracer(trc, ATOM_TO_STRING(atom), JSTRACE_STRING);
 8367:             }
 8367:         } while (i != 0);
 8367:     } else {
13702:         JS_DHashTableEnumerate(&fun->u.i.names.map->names,
 8367:                                trace_local_names_enumerator, trc);
 8367: 
 8367:         /*
 8367:          * No need to trace the list of duplicates in map->lastdup as the
 8367:          * names there are traced when enumerating the hash table.
 8367:          */
 8367:     }
 8367: }
 8367: 
 8367: void
13702: DestroyLocalNames(JSContext *cx, JSFunction *fun)
 8367: {
 8367:     uintN n;
 8367: 
13702:     n = fun->nargs + fun->u.i.nvars;
 8367:     if (n <= 1)
 8367:         return;
 8367:     if (n <= MAX_ARRAY_LOCALS)
13702:         JS_free(cx, fun->u.i.names.array);
 8367:     else
13702:         FreeLocalNameHash(cx, fun->u.i.names.map);
 8367: }
 8367: 
 8367: void
13702: js_FreezeLocalNames(JSContext *cx, JSFunction *fun)
 8367: {
 8367:     uintN n;
 8367:     jsuword *array;
 8367: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
13702:     JS_ASSERT(!fun->u.i.script);
13702:     n = fun->nargs + fun->u.i.nvars;
 8367:     if (2 <= n && n < MAX_ARRAY_LOCALS) {
 8367:         /* Shrink over-allocated array ignoring realloc failures. */
13702:         array = (jsuword *) JS_realloc(cx, fun->u.i.names.array,
13702:                                        n * sizeof *array);
 8367:         if (array)
13702:             fun->u.i.names.array = array;
 8367:     }
 8367: }
