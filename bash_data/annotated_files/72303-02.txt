  314: /* -*- Mode: c; c-basic-offset: 4; indent-tabs-mode: t; tab-width: 8; -*- */
  314: /*
    1:  * Copyright Â© 2005 Keith Packard
    1:  *
    1:  * This library is free software; you can redistribute it and/or
    1:  * modify it either under the terms of the GNU Lesser General Public
    1:  * License version 2.1 as published by the Free Software Foundation
    1:  * (the "LGPL") or, at your option, under the terms of the Mozilla
    1:  * Public License Version 1.1 (the "MPL"). If you do not alter this
    1:  * notice, a recipient may use your version of this file under either
    1:  * the MPL or the LGPL.
    1:  *
    1:  * You should have received a copy of the LGPL along with this library
    1:  * in the file COPYING-LGPL-2.1; if not, write to the Free Software
70960:  * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA
    1:  * You should have received a copy of the MPL along with this library
    1:  * in the file COPYING-MPL-1.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License
    1:  * Version 1.1 (the "License"); you may not use this file except in
    1:  * compliance with the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
    1:  * OF ANY KIND, either express or implied. See the LGPL or the MPL for
    1:  * the specific language governing rights and limitations.
    1:  *
    1:  * The Original Code is the cairo graphics library.
    1:  *
    1:  * The Initial Developer of the Original Code is Keith Packard
    1:  *
    1:  * Contributor(s):
    1:  *      Keith Packard <keithp@keithp.com>
    1:  *	Carl D. Worth <cworth@cworth.org>
    1:  *      Graydon Hoare <graydon@redhat.com>
    1:  *      Owen Taylor <otaylor@redhat.com>
 6154:  *      Behdad Esfahbod <behdad@behdad.org>
26419:  *      Chris Wilson <chris@chris-wilson.co.uk>
    1:  */
    1: 
    1: #include "cairoint.h"
70960: #include "cairo-error-private.h"
 4133: #include "cairo-scaled-font-private.h"
    1: 
26419: #if _XOPEN_SOURCE >= 600 || defined (_ISOC99_SOURCE)
26419: #define ISFINITE(x) isfinite (x)
26419: #else
26419: #define ISFINITE(x) ((x) * (x) >= 0.) /* check for NaNs */
26419: #endif
26419: 
70960: /**
70960:  * SECTION:cairo-scaled-font
70960:  * @Title: cairo_scaled_font_t
70960:  * @Short_Description: Font face at particular size and options
70960:  * @See_Also: #cairo_font_face_t, #cairo_matrix_t, #cairo_font_options_t
70960:  *
70960:  * #cairo_scaled_font_t represents a realization of a font face at a particular
70960:  * size and transformation and a certain set of font options.
70960:  */
70960: 
26419: /* Global Glyph Cache
26419:  *
26419:  * We maintain a global pool of glyphs split between all active fonts. This
26419:  * allows a heavily used individual font to cache more glyphs than we could
26419:  * manage if we used per-font glyph caches, but at the same time maintains
26419:  * fairness across all fonts and provides a cap on the maximum number of
26419:  * global glyphs.
26419:  *
26419:  * The glyphs are allocated in pages, which are capped in the global pool.
26419:  * Using pages means we can reduce the frequency at which we have to probe the
26419:  * global pool and ameliorates the memory allocation pressure.
26419:  */
26419: 
26419: /* XXX: This number is arbitrary---we've never done any measurement of this. */
26494: #define MAX_GLYPH_PAGES_CACHED 256
32473: static cairo_cache_t cairo_scaled_glyph_page_cache;
26419: 
26419: #define CAIRO_SCALED_GLYPH_PAGE_SIZE 32
26419: struct _cairo_scaled_glyph_page {
26419:     cairo_cache_entry_t cache_entry;
26419: 
70960:     cairo_list_t link;
26419: 
26419:     unsigned int num_glyphs;
26419:     cairo_scaled_glyph_t glyphs[CAIRO_SCALED_GLYPH_PAGE_SIZE];
26419: };
26419: 
 6154: /*
11708:  *  Notes:
 6154:  *
 6154:  *  To store rasterizations of glyphs, we use an image surface and the
 6154:  *  device offset to represent the glyph origin.
 6154:  *
 6154:  *  A device_transform converts from device space (a conceptual space) to
 6154:  *  surface space.  For simple cases of translation only, it's called a
11708:  *  device_offset and is public API (cairo_surface_[gs]et_device_offset()).
 6154:  *  A possibly better name for those functions could have been
11708:  *  cairo_surface_[gs]et_origin().  So, that's what they do: they set where
 6154:  *  the device-space origin (0,0) is in the surface.  If the origin is inside
 6154:  *  the surface, device_offset values are positive.  It may look like this:
 6154:  *
 6154:  *  Device space:
 6154:  *        (-x,-y) <-- negative numbers
 6154:  *           +----------------+
 6154:  *           |      .         |
 6154:  *           |      .         |
 6154:  *           |......(0,0) <---|-- device-space origin
 6154:  *           |                |
 6154:  *           |                |
 6154:  *           +----------------+
 6154:  *                    (width-x,height-y)
 6154:  *
 6154:  *  Surface space:
 6154:  *         (0,0) <-- surface-space origin
 6154:  *           +---------------+
 6154:  *           |      .        |
 6154:  *           |      .        |
 6154:  *           |......(x,y) <--|-- device_offset
 6154:  *           |               |
 6154:  *           |               |
 6154:  *           +---------------+
 6154:  *                     (width,height)
 6154:  *
 6154:  *  In other words: device_offset is the coordinates of the device-space
 6154:  *  origin relative to the top-left of the surface.
 6154:  *
 6154:  *  We use device offsets in a couple of places:
 6154:  *
 6154:  *    - Public API: To let toolkits like Gtk+ give user a surface that
 6154:  *      only represents part of the final destination (say, the expose
 6154:  *      area), but has the same device space as the destination.  In these
 6154:  *      cases device_offset is typically negative.  Example:
 6154:  *
 6154:  *           application window
 6154:  *           +---------------+
 6154:  *           |      .        |
 6154:  *           | (x,y).        |
 6154:  *           |......+---+    |
 6154:  *           |      |   | <--|-- expose area
 6154:  *           |      +---+    |
 6154:  *           +---------------+
 6154:  *
 6154:  *      In this case, the user of cairo API can set the device_space on
 6154:  *      the expose area to (-x,-y) to move the device space origin to that
 6154:  *      of the application window, such that drawing in the expose area
 6154:  *      surface and painting it in the application window has the same
 6154:  *      effect as drawing in the application window directly.  Gtk+ has
 6154:  *      been using this feature.
 6154:  *
 6154:  *    - Glyph surfaces: In most font rendering systems, glyph surfaces
 6154:  *      have an origin at (0,0) and a bounding box that is typically
 6154:  *      represented as (x_bearing,y_bearing,width,height).  Depending on
 6154:  *      which way y progresses in the system, y_bearing may typically be
 6154:  *      negative (for systems similar to cairo, with origin at top left),
 6154:  *      or be positive (in systems like PDF with origin at bottom left).
 6154:  *      No matter which is the case, it is important to note that
 6154:  *      (x_bearing,y_bearing) is the coordinates of top-left of the glyph
 6154:  *      relative to the glyph origin.  That is, for example:
 6154:  *
 6154:  *      Scaled-glyph space:
 6154:  *
 6154:  *        (x_bearing,y_bearing) <-- negative numbers
 6154:  *           +----------------+
 6154:  *           |      .         |
 6154:  *           |      .         |
 6154:  *           |......(0,0) <---|-- glyph origin
 6154:  *           |                |
 6154:  *           |                |
 6154:  *           +----------------+
 6154:  *                    (width+x_bearing,height+y_bearing)
 6154:  *
 6154:  *      Note the similarity of the origin to the device space.  That is
 6154:  *      exactly how we use the device_offset to represent scaled glyphs:
 6154:  *      to use the device-space origin as the glyph origin.
 6154:  *
 6154:  *  Now compare the scaled-glyph space to device-space and surface-space
 6154:  *  and convince yourself that:
 6154:  *
 6154:  *	(x_bearing,y_bearing) = (-x,-y) = - device_offset
 6154:  *
 6154:  *  That's right.  If you are not convinced yet, contrast the definition
 6154:  *  of the two:
 6154:  *
 6154:  *	"(x_bearing,y_bearing) is the coordinates of top-left of the
 6154:  *	 glyph relative to the glyph origin."
 6154:  *
 6154:  *	"In other words: device_offset is the coordinates of the
 6154:  *	 device-space origin relative to the top-left of the surface."
 6154:  *
 6154:  *  and note that glyph origin = device-space origin.
 6154:  */
 6154: 
21379: static void
21379: _cairo_scaled_font_fini_internal (cairo_scaled_font_t *scaled_font);
21379: 
26419: static void
26419: _cairo_scaled_glyph_fini (cairo_scaled_font_t *scaled_font,
26419: 			  cairo_scaled_glyph_t *scaled_glyph)
    1: {
    1:     const cairo_surface_backend_t *surface_backend = scaled_font->surface_backend;
    1: 
    1:     if (surface_backend != NULL && surface_backend->scaled_glyph_fini != NULL)
    1: 	surface_backend->scaled_glyph_fini (scaled_glyph, scaled_font);
26419: 
    1:     if (scaled_glyph->surface != NULL)
    1: 	cairo_surface_destroy (&scaled_glyph->surface->base);
26419: 
    1:     if (scaled_glyph->path != NULL)
    1: 	_cairo_path_fixed_destroy (scaled_glyph->path);
26419: 
70960:     if (scaled_glyph->recording_surface != NULL) {
70960: 	cairo_surface_finish (scaled_glyph->recording_surface);
41340: 	cairo_surface_destroy (scaled_glyph->recording_surface);
    1:     }
70960: }
    1: 
 8452: #define ZOMBIE 0
11886: static const cairo_scaled_font_t _cairo_scaled_font_nil = {
 8452:     { ZOMBIE },			/* hash_entry */
    1:     CAIRO_STATUS_NO_MEMORY,	/* status */
 8452:     CAIRO_REFERENCE_COUNT_INVALID,	/* ref_count */
  314:     { 0, 0, 0, NULL },		/* user_data */
26419:     NULL,			/* original_font_face */
    1:     NULL,			/* font_face */
    1:     { 1., 0., 0., 1., 0, 0},	/* font_matrix */
    1:     { 1., 0., 0., 1., 0, 0},	/* ctm */
    1:     { CAIRO_ANTIALIAS_DEFAULT,	/* options */
    1:       CAIRO_SUBPIXEL_ORDER_DEFAULT,
    1:       CAIRO_HINT_STYLE_DEFAULT,
    1:       CAIRO_HINT_METRICS_DEFAULT} ,
16122:     FALSE,			/* placeholder */
32473:     FALSE,			/* holdover */
16122:     TRUE,			/* finished */
    1:     { 1., 0., 0., 1., 0, 0},	/* scale */
10695:     { 1., 0., 0., 1., 0, 0},	/* scale_inverse */
16122:     1.,				/* max_scale */
    1:     { 0., 0., 0., 0., 0. },	/* extents */
26419:     { 0., 0., 0., 0., 0. },	/* fs_extents */
  314:     CAIRO_MUTEX_NIL_INITIALIZER,/* mutex */
    1:     NULL,			/* glyphs */
70960:     { NULL, NULL },		/* pages */
26419:     FALSE,			/* cache_frozen */
26419:     FALSE,			/* global_cache_frozen */
    1:     NULL,			/* surface_backend */
    1:     NULL,			/* surface_private */
26419:     NULL			/* backend */
    1: };
    1: 
    1: /**
    1:  * _cairo_scaled_font_set_error:
    1:  * @scaled_font: a scaled_font
16122:  * @status: a status value indicating an error
    1:  *
 8452:  * Atomically sets scaled_font->status to @status and calls _cairo_error;
16122:  * Does nothing if status is %CAIRO_STATUS_SUCCESS.
    1:  *
    1:  * All assignments of an error status to scaled_font->status should happen
 8452:  * through _cairo_scaled_font_set_error(). Note that due to the nature of
 8452:  * the atomic operation, it is not safe to call this function on the nil
 8452:  * objects.
    1:  *
    1:  * The purpose of this function is to allow the user to set a
    1:  * breakpoint in _cairo_error() to generate a stack trace for when the
    1:  * user causes cairo to detect an error.
 8452:  *
 8452:  * Return value: the error status.
    1:  **/
 8452: cairo_status_t
    1: _cairo_scaled_font_set_error (cairo_scaled_font_t *scaled_font,
    1: 			      cairo_status_t status)
    1: {
 8452:     if (status == CAIRO_STATUS_SUCCESS)
 8452: 	return status;
 8452: 
    1:     /* Don't overwrite an existing error. This preserves the first
 8452:      * error, which is the most significant. */
 8452:     _cairo_status_set_error (&scaled_font->status, status);
    1: 
 8452:     return _cairo_error (status);
    1: }
    1: 
    1: /**
    1:  * cairo_scaled_font_get_type:
    1:  * @scaled_font: a #cairo_scaled_font_t
    1:  *
    1:  * This function returns the type of the backend used to create
    1:  * a scaled font. See #cairo_font_type_t for available types.
26419:  * However, this function never returns %CAIRO_FONT_TYPE_TOY.
    1:  *
    1:  * Return value: The type of @scaled_font.
    1:  *
    1:  * Since: 1.2
    1:  **/
    1: cairo_font_type_t
    1: cairo_scaled_font_get_type (cairo_scaled_font_t *scaled_font)
    1: {
 8452:     if (CAIRO_REFERENCE_COUNT_IS_INVALID (&scaled_font->ref_count))
 4133: 	return CAIRO_FONT_TYPE_TOY;
 4133: 
    1:     return scaled_font->backend->type;
    1: }
    1: 
    1: /**
    1:  * cairo_scaled_font_status:
    1:  * @scaled_font: a #cairo_scaled_font_t
    1:  *
    1:  * Checks whether an error has previously occurred for this
    1:  * scaled_font.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS or another error such as
    1:  *   %CAIRO_STATUS_NO_MEMORY.
    1:  **/
    1: cairo_status_t
    1: cairo_scaled_font_status (cairo_scaled_font_t *scaled_font)
    1: {
    1:     return scaled_font->status;
    1: }
 4133: slim_hidden_def (cairo_scaled_font_status);
    1: 
    1: /* Here we keep a unique mapping from
11708:  * font_face/matrix/ctm/font_options => #cairo_scaled_font_t.
    1:  *
    1:  * Here are the things that we want to map:
    1:  *
11708:  *  a) All otherwise referenced #cairo_scaled_font_t's
11708:  *  b) Some number of not otherwise referenced #cairo_scaled_font_t's
    1:  *
    1:  * The implementation uses a hash table which covers (a)
    1:  * completely. Then, for (b) we have an array of otherwise
    1:  * unreferenced fonts (holdovers) which are expired in
    1:  * least-recently-used order.
    1:  *
11708:  * The cairo_scaled_font_create() code gets to treat this like a regular
    1:  * hash table. All of the magic for the little holdover cache is in
11708:  * cairo_scaled_font_reference() and cairo_scaled_font_destroy().
    1:  */
    1: 
    1: /* This defines the size of the holdover array ... that is, the number
    1:  * of scaled fonts we keep around even when not otherwise referenced
    1:  */
    1: #define CAIRO_SCALED_FONT_MAX_HOLDOVERS 256
    1: 
    1: typedef struct _cairo_scaled_font_map {
18904:     cairo_scaled_font_t *mru_scaled_font;
    1:     cairo_hash_table_t *hash_table;
    1:     cairo_scaled_font_t *holdovers[CAIRO_SCALED_FONT_MAX_HOLDOVERS];
    1:     int num_holdovers;
    1: } cairo_scaled_font_map_t;
    1: 
26419: static cairo_scaled_font_map_t *cairo_scaled_font_map;
    1: 
    1: static int
    1: _cairo_scaled_font_keys_equal (const void *abstract_key_a, const void *abstract_key_b);
    1: 
    1: static cairo_scaled_font_map_t *
    1: _cairo_scaled_font_map_lock (void)
    1: {
  314:     CAIRO_MUTEX_LOCK (_cairo_scaled_font_map_mutex);
    1: 
    1:     if (cairo_scaled_font_map == NULL) {
    1: 	cairo_scaled_font_map = malloc (sizeof (cairo_scaled_font_map_t));
26419: 	if (unlikely (cairo_scaled_font_map == NULL))
    1: 	    goto CLEANUP_MUTEX_LOCK;
    1: 
18904: 	cairo_scaled_font_map->mru_scaled_font = NULL;
    1: 	cairo_scaled_font_map->hash_table =
    1: 	    _cairo_hash_table_create (_cairo_scaled_font_keys_equal);
    1: 
26419: 	if (unlikely (cairo_scaled_font_map->hash_table == NULL))
    1: 	    goto CLEANUP_SCALED_FONT_MAP;
    1: 
    1: 	cairo_scaled_font_map->num_holdovers = 0;
    1:     }
    1: 
    1:     return cairo_scaled_font_map;
    1: 
    1:  CLEANUP_SCALED_FONT_MAP:
    1:     free (cairo_scaled_font_map);
 4133:     cairo_scaled_font_map = NULL;
    1:  CLEANUP_MUTEX_LOCK:
  314:     CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_map_mutex);
 8452:     _cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
    1:     return NULL;
    1: }
    1: 
    1: static void
    1: _cairo_scaled_font_map_unlock (void)
    1: {
  314:    CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_map_mutex);
    1: }
    1: 
    1: void
    1: _cairo_scaled_font_map_destroy (void)
    1: {
    1:     cairo_scaled_font_map_t *font_map;
    1:     cairo_scaled_font_t *scaled_font;
    1: 
  314:     CAIRO_MUTEX_LOCK (_cairo_scaled_font_map_mutex);
    1: 
    1:     font_map = cairo_scaled_font_map;
26419:     if (unlikely (font_map == NULL)) {
    1:         goto CLEANUP_MUTEX_LOCK;
    1:     }
    1: 
18904:     scaled_font = font_map->mru_scaled_font;
18904:     if (scaled_font != NULL) {
18904: 	CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_map_mutex);
18904: 	cairo_scaled_font_destroy (scaled_font);
18904: 	CAIRO_MUTEX_LOCK (_cairo_scaled_font_map_mutex);
18904:     }
18904: 
16122:     /* remove scaled_fonts starting from the end so that font_map->holdovers
16122:      * is always in a consistent state when we release the mutex. */
16122:     while (font_map->num_holdovers) {
16122: 	scaled_font = font_map->holdovers[font_map->num_holdovers-1];
 8452: 	assert (! CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&scaled_font->ref_count));
    1: 	_cairo_hash_table_remove (font_map->hash_table,
    1: 				  &scaled_font->hash_entry);
16122: 
16122: 	font_map->num_holdovers--;
16122: 
21379: 	/* This releases the font_map lock to avoid the possibility of a
21379: 	 * recursive deadlock when the scaled font destroy closure gets
21379: 	 * called
21379: 	 */
    1: 	_cairo_scaled_font_fini (scaled_font);
16122: 
    1: 	free (scaled_font);
    1:     }
    1: 
    1:     _cairo_hash_table_destroy (font_map->hash_table);
    1: 
    1:     free (cairo_scaled_font_map);
    1:     cairo_scaled_font_map = NULL;
    1: 
    1:  CLEANUP_MUTEX_LOCK:
  314:     CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_map_mutex);
    1: }
26419: static void
26419: _cairo_scaled_glyph_page_destroy (void *closure)
26419: {
26419:     cairo_scaled_glyph_page_t *page = closure;
26419:     cairo_scaled_font_t *scaled_font;
26419:     unsigned int n;
26419: 
26419:     scaled_font = (cairo_scaled_font_t *) page->cache_entry.hash;
26419:     for (n = 0; n < page->num_glyphs; n++) {
26419: 	_cairo_hash_table_remove (scaled_font->glyphs,
26419: 				  &page->glyphs[n].hash_entry);
26419: 	_cairo_scaled_glyph_fini (scaled_font, &page->glyphs[n]);
26419:     }
26419: 
70960:     cairo_list_del (&page->link);
26419: 
26419:     free (page);
26419: }
16122: 
16122: /* If a scaled font wants to unlock the font map while still being
16122:  * created (needed for user-fonts), we need to take extra care not
16122:  * ending up with multiple identical scaled fonts being created.
16122:  *
16122:  * What we do is, we create a fake identical scaled font, and mark
16122:  * it as placeholder, lock its mutex, and insert that in the fontmap
16122:  * hash table.  This makes other code trying to create an identical
16122:  * scaled font to just wait and retry.
16122:  *
16122:  * The reason we have to create a fake scaled font instead of just using
16122:  * scaled_font is for lifecycle management: we need to (or rather,
21379:  * other code needs to) reference the scaled_font in the hash table.
16122:  * We can't do that on the input scaled_font as it may be freed by
16122:  * font backend upon error.
16122:  */
16122: 
21379: cairo_status_t
16122: _cairo_scaled_font_register_placeholder_and_unlock_font_map (cairo_scaled_font_t *scaled_font)
16122: {
21379:     cairo_status_t status;
16122:     cairo_scaled_font_t *placeholder_scaled_font;
16122: 
21379:     assert (CAIRO_MUTEX_IS_LOCKED (_cairo_scaled_font_map_mutex));
21379: 
21379:     status = scaled_font->status;
26419:     if (unlikely (status))
21379: 	return status;
21379: 
16122:     placeholder_scaled_font = malloc (sizeof (cairo_scaled_font_t));
26419:     if (unlikely (placeholder_scaled_font == NULL))
21379: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
16122: 
16122:     /* full initialization is wasteful, but who cares... */
16122:     status = _cairo_scaled_font_init (placeholder_scaled_font,
16122: 				      scaled_font->font_face,
16122: 				      &scaled_font->font_matrix,
16122: 				      &scaled_font->ctm,
16122: 				      &scaled_font->options,
16122: 				      NULL);
26419:     if (unlikely (status))
21379: 	goto FREE_PLACEHOLDER;
16122: 
16122:     placeholder_scaled_font->placeholder = TRUE;
16122: 
16122:     status = _cairo_hash_table_insert (cairo_scaled_font_map->hash_table,
16122: 				       &placeholder_scaled_font->hash_entry);
26419:     if (unlikely (status))
21379: 	goto FINI_PLACEHOLDER;
16122: 
21379:     CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_map_mutex);
21379:     CAIRO_MUTEX_LOCK (placeholder_scaled_font->mutex);
16122: 
21379:     return CAIRO_STATUS_SUCCESS;
16122: 
21379:   FINI_PLACEHOLDER:
21379:     _cairo_scaled_font_fini_internal (placeholder_scaled_font);
21379:   FREE_PLACEHOLDER:
16122:     free (placeholder_scaled_font);
16122: 
21379:     return _cairo_scaled_font_set_error (scaled_font, status);
16122: }
16122: 
16122: void
16122: _cairo_scaled_font_unregister_placeholder_and_lock_font_map (cairo_scaled_font_t *scaled_font)
16122: {
16122:     cairo_scaled_font_t *placeholder_scaled_font;
16122: 
16122:     CAIRO_MUTEX_LOCK (_cairo_scaled_font_map_mutex);
16122: 
26419:     placeholder_scaled_font =
26419: 	_cairo_hash_table_lookup (cairo_scaled_font_map->hash_table,
26419: 				  &scaled_font->hash_entry);
26419:     assert (placeholder_scaled_font != NULL);
16122:     assert (placeholder_scaled_font->placeholder);
21379:     assert (CAIRO_MUTEX_IS_LOCKED (placeholder_scaled_font->mutex));
16122: 
16122:     _cairo_hash_table_remove (cairo_scaled_font_map->hash_table,
26419: 			      &placeholder_scaled_font->hash_entry);
16122: 
21379:     CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_map_mutex);
16122: 
21379:     CAIRO_MUTEX_UNLOCK (placeholder_scaled_font->mutex);
16122:     cairo_scaled_font_destroy (placeholder_scaled_font);
21379: 
16122:     CAIRO_MUTEX_LOCK (_cairo_scaled_font_map_mutex);
16122: }
16122: 
16122: static void
21379: _cairo_scaled_font_placeholder_wait_for_creation_to_finish (cairo_scaled_font_t *placeholder_scaled_font)
16122: {
16122:     /* reference the place holder so it doesn't go away */
21379:     cairo_scaled_font_reference (placeholder_scaled_font);
16122: 
16122:     /* now unlock the fontmap mutex so creation has a chance to finish */
16122:     CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_map_mutex);
16122: 
16122:     /* wait on placeholder mutex until we are awaken */
21379:     CAIRO_MUTEX_LOCK (placeholder_scaled_font->mutex);
16122: 
16122:     /* ok, creation done.  just clean up and back out */
21379:     CAIRO_MUTEX_UNLOCK (placeholder_scaled_font->mutex);
21379:     cairo_scaled_font_destroy (placeholder_scaled_font);
21379: 
16122:     CAIRO_MUTEX_LOCK (_cairo_scaled_font_map_mutex);
16122: }
16122: 
    1: /* Fowler / Noll / Vo (FNV) Hash (http://www.isthe.com/chongo/tech/comp/fnv/)
    1:  *
    1:  * Not necessarily better than a lot of other hashes, but should be OK, and
    1:  * well tested with binary data.
    1:  */
    1: 
    1: #define FNV_32_PRIME ((uint32_t)0x01000193)
    1: #define FNV1_32_INIT ((uint32_t)0x811c9dc5)
    1: 
    1: static uint32_t
26419: _hash_matrix_fnv (const cairo_matrix_t	*matrix,
    1: 		  uint32_t		 hval)
    1: {
26419:     const uint8_t *buffer = (const uint8_t *) matrix;
26419:     int len = sizeof (cairo_matrix_t);
26419:     do {
    1: 	hval *= FNV_32_PRIME;
    1: 	hval ^= *buffer++;
26419:     } while (--len);
26419: 
26419:     return hval;
    1: }
    1: 
26419: static uint32_t
26419: _hash_mix_bits (uint32_t hash)
26419: {
26419:     hash += hash << 12;
26419:     hash ^= hash >> 7;
26419:     hash += hash << 3;
26419:     hash ^= hash >> 17;
26419:     hash += hash << 5;
26419:     return hash;
    1: }
    1: 
    1: static void
    1: _cairo_scaled_font_init_key (cairo_scaled_font_t        *scaled_font,
    1: 			     cairo_font_face_t	        *font_face,
    1: 			     const cairo_matrix_t       *font_matrix,
    1: 			     const cairo_matrix_t       *ctm,
    1: 			     const cairo_font_options_t *options)
    1: {
    1:     uint32_t hash = FNV1_32_INIT;
    1: 
    1:     scaled_font->status = CAIRO_STATUS_SUCCESS;
16122:     scaled_font->placeholder = FALSE;
    1:     scaled_font->font_face = font_face;
    1:     scaled_font->font_matrix = *font_matrix;
    1:     scaled_font->ctm = *ctm;
 6154:     /* ignore translation values in the ctm */
 6154:     scaled_font->ctm.x0 = 0.;
 6154:     scaled_font->ctm.y0 = 0.;
10694:     _cairo_font_options_init_copy (&scaled_font->options, options);
    1: 
 6154:     /* We do a bytewise hash on the font matrices */
26419:     hash = _hash_matrix_fnv (&scaled_font->font_matrix, hash);
26419:     hash = _hash_matrix_fnv (&scaled_font->ctm, hash);
26419:     hash = _hash_mix_bits (hash);
    1: 
72303:     hash ^= (uintptr_t) scaled_font->font_face;
    1:     hash ^= cairo_font_options_hash (&scaled_font->options);
    1: 
26419:     /* final mixing of bits */
26419:     hash = _hash_mix_bits (hash);
26419: 
 8452:     assert (hash != ZOMBIE);
    1:     scaled_font->hash_entry.hash = hash;
    1: }
    1: 
    1: static cairo_bool_t
26419: _cairo_scaled_font_keys_equal (const void *abstract_key_a,
26419: 			       const void *abstract_key_b)
    1: {
    1:     const cairo_scaled_font_t *key_a = abstract_key_a;
    1:     const cairo_scaled_font_t *key_b = abstract_key_b;
    1: 
26419:     if (key_a->hash_entry.hash != key_b->hash_entry.hash)
26419: 	return FALSE;
26419: 
26419:     return key_a->font_face == key_b->font_face &&
    1: 	    memcmp ((unsigned char *)(&key_a->font_matrix.xx),
    1: 		    (unsigned char *)(&key_b->font_matrix.xx),
    1: 		    sizeof(cairo_matrix_t)) == 0 &&
    1: 	    memcmp ((unsigned char *)(&key_a->ctm.xx),
    1: 		    (unsigned char *)(&key_b->ctm.xx),
21379: 		    sizeof(cairo_matrix_t)) == 0 &&
26419: 	    cairo_font_options_equal (&key_a->options, &key_b->options);
    1: }
    1: 
26419: static cairo_bool_t
32473: _cairo_scaled_font_matches (const cairo_scaled_font_t *scaled_font,
32473: 	                    const cairo_font_face_t *font_face,
32473: 			    const cairo_matrix_t *font_matrix,
32473: 			    const cairo_matrix_t *ctm,
32473: 			    const cairo_font_options_t *options)
32473: {
32473:     return scaled_font->original_font_face == font_face &&
32473: 	    memcmp ((unsigned char *)(&scaled_font->font_matrix.xx),
32473: 		    (unsigned char *)(&font_matrix->xx),
32473: 		    sizeof(cairo_matrix_t)) == 0 &&
32473: 	    memcmp ((unsigned char *)(&scaled_font->ctm.xx),
32473: 		    (unsigned char *)(&ctm->xx),
32473: 		    sizeof(cairo_matrix_t)) == 0 &&
32473: 	    cairo_font_options_equal (&scaled_font->options, options);
32473: }
32473: 
32473: static cairo_bool_t
26419: _cairo_scaled_glyphs_equal (const void *abstract_a, const void *abstract_b)
26419: {
26419:     const cairo_scaled_glyph_t *a = abstract_a;
26419:     const cairo_scaled_glyph_t *b = abstract_b;
26419: 
26419:     return a->hash_entry.hash == b->hash_entry.hash;
26419: }
    1: 
    1: /*
11708:  * Basic #cairo_scaled_font_t object management
    1:  */
    1: 
    1: cairo_status_t
    1: _cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
    1: 			 cairo_font_face_t		   *font_face,
    1: 			 const cairo_matrix_t              *font_matrix,
    1: 			 const cairo_matrix_t              *ctm,
    1: 			 const cairo_font_options_t	   *options,
    1: 			 const cairo_scaled_font_backend_t *backend)
    1: {
 4133:     cairo_status_t status;
    1: 
 4133:     status = cairo_font_options_status ((cairo_font_options_t *) options);
26419:     if (unlikely (status))
 4133: 	return status;
  314: 
    1:     _cairo_scaled_font_init_key (scaled_font, font_face,
    1: 				 font_matrix, ctm, options);
    1: 
    1:     cairo_matrix_multiply (&scaled_font->scale,
    1: 			   &scaled_font->font_matrix,
    1: 			   &scaled_font->ctm);
    1: 
16122:     scaled_font->max_scale = MAX (fabs (scaled_font->scale.xx) + fabs (scaled_font->scale.xy),
16122: 				  fabs (scaled_font->scale.yx) + fabs (scaled_font->scale.yy));
10695:     scaled_font->scale_inverse = scaled_font->scale;
10695:     status = cairo_matrix_invert (&scaled_font->scale_inverse);
26419:     if (unlikely (status)) {
10695: 	/* If the font scale matrix is rank 0, just using an all-zero inverse matrix
10695: 	 * makes everything work correctly.  This make font size 0 work without
10695: 	 * producing an error.
10695: 	 *
10695: 	 * FIXME:  If the scale is rank 1, we still go into error mode.  But then
16122: 	 * again, that's what we do everywhere in cairo.
10695: 	 *
16122: 	 * Also, the check for == 0. below may be too harsh...
10695: 	 */
70960:         if (_cairo_matrix_is_scale_0 (&scaled_font->scale)) {
10695: 	    cairo_matrix_init (&scaled_font->scale_inverse,
10695: 			       0, 0, 0, 0,
10695: 			       -scaled_font->scale.x0,
10695: 			       -scaled_font->scale.y0);
70960: 	} else
 4133: 	    return status;
10695:     }
 4133: 
26419:     scaled_font->glyphs = _cairo_hash_table_create (_cairo_scaled_glyphs_equal);
26419:     if (unlikely (scaled_font->glyphs == NULL))
26419: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
26419: 
70960:     cairo_list_init (&scaled_font->glyph_pages);
26419:     scaled_font->cache_frozen = FALSE;
26419:     scaled_font->global_cache_frozen = FALSE;
26419: 
32473:     scaled_font->holdover = FALSE;
16122:     scaled_font->finished = FALSE;
16122: 
 8452:     CAIRO_REFERENCE_COUNT_INIT (&scaled_font->ref_count, 1);
 4133: 
 4133:     _cairo_user_data_array_init (&scaled_font->user_data);
 4133: 
 4133:     cairo_font_face_reference (font_face);
26419:     scaled_font->original_font_face = NULL;
 4133: 
 4133:     CAIRO_MUTEX_INIT (scaled_font->mutex);
    1: 
    1:     scaled_font->surface_backend = NULL;
    1:     scaled_font->surface_private = NULL;
    1: 
    1:     scaled_font->backend = backend;
70960:     cairo_list_init (&scaled_font->link);
    1: 
    1:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
    1: void
    1: _cairo_scaled_font_freeze_cache (cairo_scaled_font_t *scaled_font)
    1: {
21379:     /* ensure we do not modify an error object */
21379:     assert (scaled_font->status == CAIRO_STATUS_SUCCESS);
21379: 
21379:     CAIRO_MUTEX_LOCK (scaled_font->mutex);
26419:     scaled_font->cache_frozen = TRUE;
    1: }
    1: 
    1: void
    1: _cairo_scaled_font_thaw_cache (cairo_scaled_font_t *scaled_font)
    1: {
26419:     scaled_font->cache_frozen = FALSE;
26419: 
26419:     if (scaled_font->global_cache_frozen) {
26419: 	CAIRO_MUTEX_LOCK (_cairo_scaled_glyph_page_cache_mutex);
32473: 	_cairo_cache_thaw (&cairo_scaled_glyph_page_cache);
26419: 	CAIRO_MUTEX_UNLOCK (_cairo_scaled_glyph_page_cache_mutex);
26419: 
26419: 	scaled_font->global_cache_frozen = FALSE;
26419:     }
26419: 
21379:     CAIRO_MUTEX_UNLOCK (scaled_font->mutex);
    1: }
    1: 
    1: void
  314: _cairo_scaled_font_reset_cache (cairo_scaled_font_t *scaled_font)
  314: {
26419:     assert (! scaled_font->cache_frozen);
26419: 
26419:     CAIRO_MUTEX_LOCK (_cairo_scaled_glyph_page_cache_mutex);
70960:     while (! cairo_list_is_empty (&scaled_font->glyph_pages)) {
32473: 	_cairo_cache_remove (&cairo_scaled_glyph_page_cache,
70960:                              &cairo_list_first_entry (&scaled_font->glyph_pages,
70960:                                                       cairo_scaled_glyph_page_t,
70960:                                                       link)->cache_entry);
26419:     }
26419:     CAIRO_MUTEX_UNLOCK (_cairo_scaled_glyph_page_cache_mutex);
  314: }
  314: 
11708: cairo_status_t
    1: _cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
    1: 				cairo_font_extents_t	    *fs_metrics)
    1: {
11708:     cairo_status_t status;
    1:     double  font_scale_x, font_scale_y;
    1: 
26419:     scaled_font->fs_extents = *fs_metrics;
26419: 
18904:     status = _cairo_matrix_compute_basis_scale_factors (&scaled_font->font_matrix,
    1: 						  &font_scale_x, &font_scale_y,
16122: 						  1);
26419:     if (unlikely (status))
11708: 	return status;
    1: 
    1:     /*
    1:      * The font responded in unscaled units, scale by the font
    1:      * matrix scale factors to get to user space
    1:      */
    1: 
    1:     scaled_font->extents.ascent = fs_metrics->ascent * font_scale_y;
    1:     scaled_font->extents.descent = fs_metrics->descent * font_scale_y;
    1:     scaled_font->extents.height = fs_metrics->height * font_scale_y;
    1:     scaled_font->extents.max_x_advance = fs_metrics->max_x_advance * font_scale_x;
    1:     scaled_font->extents.max_y_advance = fs_metrics->max_y_advance * font_scale_y;
11708: 
11708:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
21379: static void
21379: _cairo_scaled_font_fini_internal (cairo_scaled_font_t *scaled_font)
    1: {
16122:     scaled_font->finished = TRUE;
16122: 
26419:     _cairo_scaled_font_reset_cache (scaled_font);
26419:     _cairo_hash_table_destroy (scaled_font->glyphs);
26419: 
    1:     cairo_font_face_destroy (scaled_font->font_face);
26419:     cairo_font_face_destroy (scaled_font->original_font_face);
    1: 
 4133:     CAIRO_MUTEX_FINI (scaled_font->mutex);
  314: 
    1:     if (scaled_font->surface_backend != NULL &&
    1: 	scaled_font->surface_backend->scaled_font_fini != NULL)
    1: 	scaled_font->surface_backend->scaled_font_fini (scaled_font);
    1: 
16122:     if (scaled_font->backend != NULL && scaled_font->backend->fini != NULL)
    1: 	scaled_font->backend->fini (scaled_font);
    1: 
  314:     _cairo_user_data_array_fini (&scaled_font->user_data);
    1: }
    1: 
41340: /* XXX: allow multiple backends to share the font */
41340: void
41340: _cairo_scaled_font_revoke_ownership (cairo_scaled_font_t *scaled_font)
41340: {
41340:     if (scaled_font->surface_backend == NULL)
41340: 	return;
41340: 
41340:     _cairo_scaled_font_reset_cache (scaled_font);
41340: 
41340:     if (scaled_font->surface_backend->scaled_font_fini != NULL)
41340: 	scaled_font->surface_backend->scaled_font_fini (scaled_font);
41340: 
41340:     scaled_font->surface_backend = NULL;
41340:     scaled_font->surface_private = NULL;
41340: }
41340: 
21379: void
21379: _cairo_scaled_font_fini (cairo_scaled_font_t *scaled_font)
21379: {
21379:     /* Release the lock to avoid the possibility of a recursive
21379:      * deadlock when the scaled font destroy closure gets called. */
21379:     CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_map_mutex);
21379:     _cairo_scaled_font_fini_internal (scaled_font);
21379:     CAIRO_MUTEX_LOCK (_cairo_scaled_font_map_mutex);
21379: }
21379: 
    1: /**
    1:  * cairo_scaled_font_create:
    1:  * @font_face: a #cairo_font_face_t
    1:  * @font_matrix: font space to user space transformation matrix for the
    1:  *       font. In the simplest case of a N point font, this matrix is
    1:  *       just a scale by N, but it can also be used to shear the font
    1:  *       or stretch it unequally along the two axes. See
    1:  *       cairo_set_font_matrix().
    1:  * @ctm: user to device transformation matrix with which the font will
    1:  *       be used.
    1:  * @options: options to use when getting metrics for the font and
21379:  *           rendering with it.
    1:  *
    1:  * Creates a #cairo_scaled_font_t object from a font face and matrices that
    1:  * describe the size of the font and the environment in which it will
    1:  * be used.
    1:  *
    1:  * Return value: a newly created #cairo_scaled_font_t. Destroy with
    1:  *  cairo_scaled_font_destroy()
    1:  **/
    1: cairo_scaled_font_t *
    1: cairo_scaled_font_create (cairo_font_face_t          *font_face,
    1: 			  const cairo_matrix_t       *font_matrix,
    1: 			  const cairo_matrix_t       *ctm,
    1: 			  const cairo_font_options_t *options)
    1: {
    1:     cairo_status_t status;
    1:     cairo_scaled_font_map_t *font_map;
26419:     cairo_font_face_t *original_font_face = font_face;
70960:     cairo_scaled_font_t key, *old = NULL, *scaled_font = NULL, *dead = NULL;
26419:     double det;
26419: 
26419:     status = font_face->status;
26419:     if (unlikely (status))
26419: 	return _cairo_scaled_font_create_in_error (status);
26419: 
26419:     det = _cairo_matrix_compute_determinant (font_matrix);
26419:     if (! ISFINITE (det))
26419: 	return _cairo_scaled_font_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_MATRIX));
26419: 
26419:     det = _cairo_matrix_compute_determinant (ctm);
26419:     if (! ISFINITE (det))
26419: 	return _cairo_scaled_font_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_MATRIX));
    1: 
11886:     status = cairo_font_options_status ((cairo_font_options_t *) options);
26419:     if (unlikely (status))
11886: 	return _cairo_scaled_font_create_in_error (status);
 4133: 
10695:     /* Note that degenerate ctm or font_matrix *are* allowed.
10695:      * We want to support a font size of 0. */
10414: 
    1:     font_map = _cairo_scaled_font_map_lock ();
26419:     if (unlikely (font_map == NULL))
11886: 	return _cairo_scaled_font_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
    1: 
18904:     scaled_font = font_map->mru_scaled_font;
18904:     if (scaled_font != NULL &&
32473: 	_cairo_scaled_font_matches (scaled_font,
32473: 	                            font_face, font_matrix, ctm, options))
18904:     {
70960: 	assert (scaled_font->hash_entry.hash != ZOMBIE);
18904: 	assert (! scaled_font->placeholder);
    1: 
32473: 	if (likely (scaled_font->status == CAIRO_STATUS_SUCCESS)) {
18904: 	    /* We increment the reference count manually here, (rather
18904: 	     * than calling into cairo_scaled_font_reference), since we
18904: 	     * must modify the reference count while our lock is still
18904: 	     * held. */
18904: 	    _cairo_reference_count_inc (&scaled_font->ref_count);
18904: 	    _cairo_scaled_font_map_unlock ();
18904: 	    return scaled_font;
18904: 	}
16122: 
18904: 	/* the font has been put into an error status - abandon the cache */
26419: 	_cairo_hash_table_remove (font_map->hash_table,
26419: 				  &scaled_font->hash_entry);
18904: 	scaled_font->hash_entry.hash = ZOMBIE;
70960: 	dead = scaled_font;
70960: 	font_map->mru_scaled_font = NULL;
32473: 
32473: 	if (font_face->backend->get_implementation != NULL) {
32473: 	    font_face = font_face->backend->get_implementation (font_face,
32473: 								font_matrix,
32473: 								ctm,
32473: 								options);
70960: 	    if (unlikely (font_face->status)) {
70960: 		_cairo_scaled_font_map_unlock ();
70960: 		cairo_scaled_font_destroy (scaled_font);
70960: 		return _cairo_scaled_font_create_in_error (font_face->status);
70960: 	    }
32473: 	}
41340: 
41340: 	_cairo_scaled_font_init_key (&key, font_face,
41340: 				     font_matrix, ctm, options);
18904:     }
18904:     else
18904:     {
32473: 	if (font_face->backend->get_implementation != NULL) {
32473: 	    font_face = font_face->backend->get_implementation (font_face,
32473: 								font_matrix,
32473: 								ctm,
32473: 								options);
70960: 	    if (unlikely (font_face->status)) {
70960: 		_cairo_scaled_font_map_unlock ();
70960: 		return _cairo_scaled_font_create_in_error (font_face->status);
70960: 	    }
32473: 	}
32473: 
32473: 	_cairo_scaled_font_init_key (&key, font_face,
32473: 				     font_matrix, ctm, options);
32473: 
26419: 	while ((scaled_font = _cairo_hash_table_lookup (font_map->hash_table,
26419: 							&key.hash_entry)))
16122: 	{
16122: 	    if (! scaled_font->placeholder)
16122: 		break;
16122: 
16122: 	    /* If the scaled font is being created (happens for user-font),
16122: 	     * just wait until it's done, then retry */
16122: 	    _cairo_scaled_font_placeholder_wait_for_creation_to_finish (scaled_font);
16122: 	}
16122: 
16077: 	/* Return existing scaled_font if it exists in the hash table. */
18904: 	if (scaled_font != NULL) {
    1: 	    /* If the original reference count is 0, then this font must have
    1: 	     * been found in font_map->holdovers, (which means this caching is
    1: 	     * actually working). So now we remove it from the holdovers
32473: 	     * array, unless we caught the font in the middle of destruction.
32473: 	     */
 8452: 	    if (! CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&scaled_font->ref_count)) {
32473: 		if (scaled_font->holdover) {
    1: 		    int i;
    1: 
32473: 		    for (i = 0; i < font_map->num_holdovers; i++) {
32473: 			if (font_map->holdovers[i] == scaled_font) {
    1: 			    font_map->num_holdovers--;
    1: 			    memmove (&font_map->holdovers[i],
    1: 				     &font_map->holdovers[i+1],
    1: 				     (font_map->num_holdovers - i) * sizeof (cairo_scaled_font_t*));
32473: 			    break;
32473: 			}
32473: 		    }
32473: 
32473: 		    scaled_font->holdover = FALSE;
32473: 		}
 4133: 
 4133: 		/* reset any error status */
 4133: 		scaled_font->status = CAIRO_STATUS_SUCCESS;
    1: 	    }
    1: 
32473: 	    if (likely (scaled_font->status == CAIRO_STATUS_SUCCESS)) {
  314: 		/* We increment the reference count manually here, (rather
  314: 		 * than calling into cairo_scaled_font_reference), since we
  314: 		 * must modify the reference count while our lock is still
  314: 		 * held. */
18904: 
18904: 		old = font_map->mru_scaled_font;
18904: 		font_map->mru_scaled_font = scaled_font;
18904: 		/* increment reference count for the mru cache */
18904: 		_cairo_reference_count_inc (&scaled_font->ref_count);
18904: 		/* and increment for the returned reference */
 8452: 		_cairo_reference_count_inc (&scaled_font->ref_count);
  314: 		_cairo_scaled_font_map_unlock ();
18904: 
18904: 		cairo_scaled_font_destroy (old);
41340: 		if (font_face != original_font_face)
41340: 		    cairo_font_face_destroy (font_face);
18904: 
 4133: 		return scaled_font;
 4133: 	    }
 4133: 
 4133: 	    /* the font has been put into an error status - abandon the cache */
26419: 	    _cairo_hash_table_remove (font_map->hash_table,
26419: 				      &scaled_font->hash_entry);
 8452: 	    scaled_font->hash_entry.hash = ZOMBIE;
 4133: 	}
18904:     }
 4133: 
  314:     /* Otherwise create it and insert it into the hash table. */
  314:     status = font_face->backend->scaled_font_create (font_face, font_matrix,
  314: 						     ctm, options, &scaled_font);
26419:     /* Did we leave the backend in an error state? */
26419:     if (unlikely (status)) {
  314: 	_cairo_scaled_font_map_unlock ();
41340: 	if (font_face != original_font_face)
41340: 	    cairo_font_face_destroy (font_face);
41340: 
70960: 	if (dead != NULL)
70960: 	    cairo_scaled_font_destroy (dead);
70960: 
 8452: 	status = _cairo_font_face_set_error (font_face, status);
11886: 	return _cairo_scaled_font_create_in_error (status);
  314:     }
26419:     /* Or did we encounter an error whilst constructing the scaled font? */
26419:     if (unlikely (scaled_font->status)) {
26419: 	_cairo_scaled_font_map_unlock ();
41340: 	if (font_face != original_font_face)
41340: 	    cairo_font_face_destroy (font_face);
41340: 
70960: 	if (dead != NULL)
70960: 	    cairo_scaled_font_destroy (dead);
70960: 
26419: 	return scaled_font;
26419:     }
26419: 
32473:     /* Our caching above is defeated if the backend switches fonts on us -
32473:      * e.g. old incarnations of toy-font-face and lazily resolved
32473:      * ft-font-faces
32473:      */
32473:     assert (scaled_font->font_face == font_face);
32473: 
26419:     scaled_font->original_font_face =
26419: 	cairo_font_face_reference (original_font_face);
26419: 
  314:     status = _cairo_hash_table_insert (font_map->hash_table,
  314: 				       &scaled_font->hash_entry);
26419:     if (likely (status == CAIRO_STATUS_SUCCESS)) {
18904: 	old = font_map->mru_scaled_font;
18904: 	font_map->mru_scaled_font = scaled_font;
18904: 	_cairo_reference_count_inc (&scaled_font->ref_count);
18904:     }
18904: 
  314:     _cairo_scaled_font_map_unlock ();
  314: 
41340:     cairo_scaled_font_destroy (old);
41340:     if (font_face != original_font_face)
41340: 	cairo_font_face_destroy (font_face);
41340: 
70960:     if (dead != NULL)
70960: 	cairo_scaled_font_destroy (dead);
70960: 
26419:     if (unlikely (status)) {
  314: 	/* We can't call _cairo_scaled_font_destroy here since it expects
  314: 	 * that the font has already been successfully inserted into the
  314: 	 * hash table. */
21379: 	_cairo_scaled_font_fini_internal (scaled_font);
  314: 	free (scaled_font);
11886: 	return _cairo_scaled_font_create_in_error (status);
  314:     }
  314: 
  314:     return scaled_font;
  314: }
  314: slim_hidden_def (cairo_scaled_font_create);
  314: 
11886: static cairo_scaled_font_t *_cairo_scaled_font_nil_objects[CAIRO_STATUS_LAST_STATUS + 1];
11886: 
11886: /* XXX This should disappear in favour of a common pool of error objects. */
11886: cairo_scaled_font_t *
11886: _cairo_scaled_font_create_in_error (cairo_status_t status)
11886: {
11886:     cairo_scaled_font_t *scaled_font;
11886: 
11886:     assert (status != CAIRO_STATUS_SUCCESS);
11886: 
11886:     if (status == CAIRO_STATUS_NO_MEMORY)
11886: 	return (cairo_scaled_font_t *) &_cairo_scaled_font_nil;
11886: 
11886:     CAIRO_MUTEX_LOCK (_cairo_scaled_font_error_mutex);
11886:     scaled_font = _cairo_scaled_font_nil_objects[status];
26419:     if (unlikely (scaled_font == NULL)) {
11886: 	scaled_font = malloc (sizeof (cairo_scaled_font_t));
26419: 	if (unlikely (scaled_font == NULL)) {
11886: 	    CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_error_mutex);
11886: 	    _cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
11886: 	    return (cairo_scaled_font_t *) &_cairo_scaled_font_nil;
11886: 	}
11886: 
11886: 	*scaled_font = _cairo_scaled_font_nil;
11886: 	scaled_font->status = status;
11886: 	_cairo_scaled_font_nil_objects[status] = scaled_font;
11886:     }
11886:     CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_error_mutex);
11886: 
11886:     return scaled_font;
11886: }
11886: 
11886: void
11886: _cairo_scaled_font_reset_static_data (void)
11886: {
11886:     int status;
11886: 
11886:     CAIRO_MUTEX_LOCK (_cairo_scaled_font_error_mutex);
11886:     for (status = CAIRO_STATUS_SUCCESS;
11886: 	 status <= CAIRO_STATUS_LAST_STATUS;
11886: 	 status++)
11886:     {
11886: 	if (_cairo_scaled_font_nil_objects[status] != NULL) {
11886: 	    free (_cairo_scaled_font_nil_objects[status]);
11886: 	    _cairo_scaled_font_nil_objects[status] = NULL;
11886: 	}
11886:     }
11886:     CAIRO_MUTEX_UNLOCK (_cairo_scaled_font_error_mutex);
26419: 
26419:     CAIRO_MUTEX_LOCK (_cairo_scaled_glyph_page_cache_mutex);
32473:     if (cairo_scaled_glyph_page_cache.hash_table != NULL) {
32473: 	_cairo_cache_fini (&cairo_scaled_glyph_page_cache);
32473: 	cairo_scaled_glyph_page_cache.hash_table = NULL;
26419:     }
26419:     CAIRO_MUTEX_UNLOCK (_cairo_scaled_glyph_page_cache_mutex);
11886: }
11886: 
  314: /**
  314:  * cairo_scaled_font_reference:
11708:  * @scaled_font: a #cairo_scaled_font_t, (may be %NULL in which case
  314:  * this function does nothing)
  314:  *
  314:  * Increases the reference count on @scaled_font by one. This prevents
  314:  * @scaled_font from being destroyed until a matching call to
  314:  * cairo_scaled_font_destroy() is made.
  314:  *
  314:  * The number of references to a #cairo_scaled_font_t can be get using
  314:  * cairo_scaled_font_get_reference_count().
  314:  *
  314:  * Returns: the referenced #cairo_scaled_font_t
  314:  **/
  314: cairo_scaled_font_t *
  314: cairo_scaled_font_reference (cairo_scaled_font_t *scaled_font)
  314: {
 8452:     if (scaled_font == NULL ||
 8452: 	    CAIRO_REFERENCE_COUNT_IS_INVALID (&scaled_font->ref_count))
  314: 	return scaled_font;
  314: 
 8452:     assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&scaled_font->ref_count));
  314: 
 8452:     _cairo_reference_count_inc (&scaled_font->ref_count);
    1: 
    1:     return scaled_font;
    1: }
    1: slim_hidden_def (cairo_scaled_font_reference);
    1: 
    1: /**
    1:  * cairo_scaled_font_destroy:
    1:  * @scaled_font: a #cairo_scaled_font_t
    1:  *
    1:  * Decreases the reference count on @font by one. If the result
    1:  * is zero, then @font and all associated resources are freed.
    1:  * See cairo_scaled_font_reference().
    1:  **/
    1: void
    1: cairo_scaled_font_destroy (cairo_scaled_font_t *scaled_font)
    1: {
16122:     cairo_scaled_font_t *lru = NULL;
16077:     cairo_scaled_font_map_t *font_map;
    1: 
21379:     assert (CAIRO_MUTEX_IS_UNLOCKED (_cairo_scaled_font_map_mutex));
21379: 
 8452:     if (scaled_font == NULL ||
 8452: 	    CAIRO_REFERENCE_COUNT_IS_INVALID (&scaled_font->ref_count))
    1: 	return;
    1: 
16122:     assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&scaled_font->ref_count));
16122: 
32473:     if (! _cairo_reference_count_dec_and_test (&scaled_font->ref_count))
32473: 	return;
32473: 
    1:     font_map = _cairo_scaled_font_map_lock ();
    1:     assert (font_map != NULL);
    1: 
32473:     /* Another thread may have resurrected the font whilst we waited */
32473:     if (! CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&scaled_font->ref_count)) {
26419: 	if (! scaled_font->placeholder &&
26419: 	    scaled_font->hash_entry.hash != ZOMBIE)
26419: 	{
32473: 	    /* Another thread may have already inserted us into the holdovers */
32473: 	    if (scaled_font->holdover)
32473: 		goto unlock;
32473: 
    1: 	    /* Rather than immediately destroying this object, we put it into
    1: 	     * the font_map->holdovers array in case it will get used again
 8452: 	     * soon (and is why we must hold the lock over the atomic op on
 8452: 	     * the reference count). To make room for it, we do actually
 8452: 	     * destroy the least-recently-used holdover.
    1: 	     */
16122: 
32473: 	    if (font_map->num_holdovers == CAIRO_SCALED_FONT_MAX_HOLDOVERS) {
    1: 		lru = font_map->holdovers[0];
 8452: 		assert (! CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&lru->ref_count));
    1: 
26419: 		_cairo_hash_table_remove (font_map->hash_table,
26419: 					  &lru->hash_entry);
    1: 
    1: 		font_map->num_holdovers--;
    1: 		memmove (&font_map->holdovers[0],
    1: 			 &font_map->holdovers[1],
    1: 			 font_map->num_holdovers * sizeof (cairo_scaled_font_t*));
    1: 	    }
    1: 
32473: 	    font_map->holdovers[font_map->num_holdovers++] = scaled_font;
32473: 	    scaled_font->holdover = TRUE;
 8452: 	} else
 8452: 	    lru = scaled_font;
    1:     }
16122: 
32473:   unlock:
21379:     _cairo_scaled_font_map_unlock ();
  314: 
  314:     /* If we pulled an item from the holdovers array, (while the font
  314:      * map lock was held, of course), then there is no way that anyone
  314:      * else could have acquired a reference to it. So we can now
  314:      * safely call fini on it without any lock held. This is desirable
  314:      * as we never want to call into any backend function with a lock
  314:      * held. */
32473:     if (lru != NULL) {
21379: 	_cairo_scaled_font_fini_internal (lru);
  314: 	free (lru);
  314:     }
    1: }
    1: slim_hidden_def (cairo_scaled_font_destroy);
    1: 
  314: /**
  314:  * cairo_scaled_font_get_reference_count:
  314:  * @scaled_font: a #cairo_scaled_font_t
  314:  *
  314:  * Returns the current reference count of @scaled_font.
  314:  *
  314:  * Return value: the current reference count of @scaled_font.  If the
  314:  * object is a nil object, 0 will be returned.
  314:  *
  314:  * Since: 1.4
  314:  **/
  314: unsigned int
  314: cairo_scaled_font_get_reference_count (cairo_scaled_font_t *scaled_font)
  314: {
 8452:     if (scaled_font == NULL ||
 8452: 	    CAIRO_REFERENCE_COUNT_IS_INVALID (&scaled_font->ref_count))
  314: 	return 0;
  314: 
 8452:     return CAIRO_REFERENCE_COUNT_GET_VALUE (&scaled_font->ref_count);
  314: }
  314: 
  314: /**
  314:  * cairo_scaled_font_get_user_data:
  314:  * @scaled_font: a #cairo_scaled_font_t
  314:  * @key: the address of the #cairo_user_data_key_t the user data was
  314:  * attached to
  314:  *
  314:  * Return user data previously attached to @scaled_font using the
  314:  * specified key.  If no user data has been attached with the given
  314:  * key this function returns %NULL.
  314:  *
  314:  * Return value: the user data previously attached or %NULL.
  314:  *
  314:  * Since: 1.4
  314:  **/
  314: void *
  314: cairo_scaled_font_get_user_data (cairo_scaled_font_t	     *scaled_font,
  314: 				 const cairo_user_data_key_t *key)
  314: {
  314:     return _cairo_user_data_array_get_data (&scaled_font->user_data,
  314: 					    key);
  314: }
26419: slim_hidden_def (cairo_scaled_font_get_user_data);
  314: 
  314: /**
  314:  * cairo_scaled_font_set_user_data:
  314:  * @scaled_font: a #cairo_scaled_font_t
  314:  * @key: the address of a #cairo_user_data_key_t to attach the user data to
  314:  * @user_data: the user data to attach to the #cairo_scaled_font_t
  314:  * @destroy: a #cairo_destroy_func_t which will be called when the
  314:  * #cairo_t is destroyed or when new user data is attached using the
  314:  * same key.
  314:  *
  314:  * Attach user data to @scaled_font.  To remove user data from a surface,
  314:  * call this function with the key that was used to set it and %NULL
  314:  * for @data.
  314:  *
  314:  * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
  314:  * slot could not be allocated for the user data.
  314:  *
  314:  * Since: 1.4
  314:  **/
  314: cairo_status_t
  314: cairo_scaled_font_set_user_data (cairo_scaled_font_t	     *scaled_font,
  314: 				 const cairo_user_data_key_t *key,
  314: 				 void			     *user_data,
  314: 				 cairo_destroy_func_t	      destroy)
  314: {
 8452:     if (CAIRO_REFERENCE_COUNT_IS_INVALID (&scaled_font->ref_count))
21379: 	return scaled_font->status;
  314: 
  314:     return _cairo_user_data_array_set_data (&scaled_font->user_data,
  314: 					    key, user_data, destroy);
  314: }
26419: slim_hidden_def (cairo_scaled_font_set_user_data);
21379: 
    1: /* Public font API follows. */
    1: 
    1: /**
    1:  * cairo_scaled_font_extents:
    1:  * @scaled_font: a #cairo_scaled_font_t
    1:  * @extents: a #cairo_font_extents_t which to store the retrieved extents.
    1:  *
    1:  * Gets the metrics for a #cairo_scaled_font_t.
    1:  **/
    1: void
    1: cairo_scaled_font_extents (cairo_scaled_font_t  *scaled_font,
    1: 			   cairo_font_extents_t *extents)
    1: {
21379:     if (scaled_font->status) {
21379: 	extents->ascent  = 0.0;
21379: 	extents->descent = 0.0;
21379: 	extents->height  = 0.0;
21379: 	extents->max_x_advance = 0.0;
21379: 	extents->max_y_advance = 0.0;
21379: 	return;
21379:     }
21379: 
    1:     *extents = scaled_font->extents;
    1: }
    1: slim_hidden_def (cairo_scaled_font_extents);
    1: 
    1: /**
    1:  * cairo_scaled_font_text_extents:
    1:  * @scaled_font: a #cairo_scaled_font_t
18904:  * @utf8: a NUL-terminated string of text, encoded in UTF-8
    1:  * @extents: a #cairo_text_extents_t which to store the retrieved extents.
    1:  *
    1:  * Gets the extents for a string of text. The extents describe a
    1:  * user-space rectangle that encloses the "inked" portion of the text
    1:  * drawn at the origin (0,0) (as it would be drawn by cairo_show_text()
    1:  * if the cairo graphics state were set to the same font_face,
    1:  * font_matrix, ctm, and font_options as @scaled_font).  Additionally,
    1:  * the x_advance and y_advance values indicate the amount by which the
    1:  * current point would be advanced by cairo_show_text().
    1:  *
    1:  * Note that whitespace characters do not directly contribute to the
    1:  * size of the rectangle (extents.width and extents.height). They do
    1:  * contribute indirectly by changing the position of non-whitespace
    1:  * characters. In particular, trailing whitespace characters are
    1:  * likely to not affect the size of the rectangle, though they will
    1:  * affect the x_advance and y_advance values.
    1:  *
    1:  * Since: 1.2
    1:  **/
    1: void
    1: cairo_scaled_font_text_extents (cairo_scaled_font_t   *scaled_font,
    1: 				const char            *utf8,
    1: 				cairo_text_extents_t  *extents)
    1: {
 4133:     cairo_status_t status;
18904:     cairo_glyph_t *glyphs = NULL;
    1:     int num_glyphs;
    1: 
 4133:     if (scaled_font->status)
10694: 	goto ZERO_EXTENTS;
10694: 
10694:     if (utf8 == NULL)
10694: 	goto ZERO_EXTENTS;
10694: 
18904:     status = cairo_scaled_font_text_to_glyphs (scaled_font, 0., 0.,
18904: 					       utf8, -1,
18904: 					       &glyphs, &num_glyphs,
18904: 					       NULL, NULL,
18904: 					       NULL);
26419:     if (unlikely (status)) {
21379: 	status = _cairo_scaled_font_set_error (scaled_font, status);
10694: 	goto ZERO_EXTENTS;
21379:     }
10694: 
10694:     cairo_scaled_font_glyph_extents (scaled_font, glyphs, num_glyphs, extents);
10694:     free (glyphs);
10694: 
 4133:     return;
 4133: 
10694: ZERO_EXTENTS:
10694:     extents->x_bearing = 0.0;
10694:     extents->y_bearing = 0.0;
10694:     extents->width  = 0.0;
10694:     extents->height = 0.0;
10694:     extents->x_advance = 0.0;
10694:     extents->y_advance = 0.0;
    1: }
    1: 
    1: /**
    1:  * cairo_scaled_font_glyph_extents:
    1:  * @scaled_font: a #cairo_scaled_font_t
    1:  * @glyphs: an array of glyph IDs with X and Y offsets.
    1:  * @num_glyphs: the number of glyphs in the @glyphs array
    1:  * @extents: a #cairo_text_extents_t which to store the retrieved extents.
    1:  *
    1:  * Gets the extents for an array of glyphs. The extents describe a
    1:  * user-space rectangle that encloses the "inked" portion of the
    1:  * glyphs, (as they would be drawn by cairo_show_glyphs() if the cairo
    1:  * graphics state were set to the same font_face, font_matrix, ctm,
    1:  * and font_options as @scaled_font).  Additionally, the x_advance and
    1:  * y_advance values indicate the amount by which the current point
 4133:  * would be advanced by cairo_show_glyphs().
    1:  *
    1:  * Note that whitespace glyphs do not contribute to the size of the
    1:  * rectangle (extents.width and extents.height).
    1:  **/
    1: void
    1: cairo_scaled_font_glyph_extents (cairo_scaled_font_t   *scaled_font,
    1: 				 const cairo_glyph_t   *glyphs,
    1: 				 int                    num_glyphs,
    1: 				 cairo_text_extents_t  *extents)
    1: {
 4133:     cairo_status_t status;
    1:     int i;
    1:     double min_x = 0.0, min_y = 0.0, max_x = 0.0, max_y = 0.0;
    1:     cairo_bool_t visible = FALSE;
    1:     cairo_scaled_glyph_t *scaled_glyph = NULL;
    1: 
 8452:     extents->x_bearing = 0.0;
 8452:     extents->y_bearing = 0.0;
 8452:     extents->width  = 0.0;
 8452:     extents->height = 0.0;
 8452:     extents->x_advance = 0.0;
 8452:     extents->y_advance = 0.0;
18904: 
41340:     if (unlikely (scaled_font->status))
41340: 	goto ZERO_EXTENTS;
    1: 
16122:     if (num_glyphs == 0)
41340: 	goto ZERO_EXTENTS;
41340: 
41340:     if (unlikely (num_glyphs < 0)) {
16122: 	_cairo_error_throw (CAIRO_STATUS_NEGATIVE_COUNT);
16122: 	/* XXX Can't propagate error */
41340: 	goto ZERO_EXTENTS;
16122:     }
16122: 
41340:     if (unlikely (glyphs == NULL)) {
16122: 	_cairo_error_throw (CAIRO_STATUS_NULL_POINTER);
16122: 	/* XXX Can't propagate error */
41340: 	goto ZERO_EXTENTS;
16122:     }
16122: 
 8452:     _cairo_scaled_font_freeze_cache (scaled_font);
  314: 
    1:     for (i = 0; i < num_glyphs; i++) {
    1: 	double			left, top, right, bottom;
    1: 
    1: 	status = _cairo_scaled_glyph_lookup (scaled_font,
    1: 					     glyphs[i].index,
    1: 					     CAIRO_SCALED_GLYPH_INFO_METRICS,
    1: 					     &scaled_glyph);
26419: 	if (unlikely (status)) {
 8452: 	    status = _cairo_scaled_font_set_error (scaled_font, status);
  314: 	    goto UNLOCK;
    1: 	}
    1: 
    1: 	/* "Ink" extents should skip "invisible" glyphs */
12588: 	if (scaled_glyph->metrics.width == 0 || scaled_glyph->metrics.height == 0)
    1: 	    continue;
    1: 
    1: 	left = scaled_glyph->metrics.x_bearing + glyphs[i].x;
    1: 	right = left + scaled_glyph->metrics.width;
    1: 	top = scaled_glyph->metrics.y_bearing + glyphs[i].y;
    1: 	bottom = top + scaled_glyph->metrics.height;
    1: 
    1: 	if (!visible) {
    1: 	    visible = TRUE;
    1: 	    min_x = left;
    1: 	    max_x = right;
    1: 	    min_y = top;
    1: 	    max_y = bottom;
    1: 	} else {
    1: 	    if (left < min_x) min_x = left;
    1: 	    if (right > max_x) max_x = right;
    1: 	    if (top < min_y) min_y = top;
    1: 	    if (bottom > max_y) max_y = bottom;
    1: 	}
    1:     }
    1: 
    1:     if (visible) {
    1: 	extents->x_bearing = min_x - glyphs[0].x;
    1: 	extents->y_bearing = min_y - glyphs[0].y;
    1: 	extents->width = max_x - min_x;
    1: 	extents->height = max_y - min_y;
    1:     } else {
    1: 	extents->x_bearing = 0.0;
    1: 	extents->y_bearing = 0.0;
    1: 	extents->width = 0.0;
    1: 	extents->height = 0.0;
    1:     }
    1: 
    1:     if (num_glyphs) {
    1:         double x0, y0, x1, y1;
    1: 
    1: 	x0 = glyphs[0].x;
    1: 	y0 = glyphs[0].y;
    1: 
12588: 	/* scaled_glyph contains the glyph for num_glyphs - 1 already. */
    1: 	x1 = glyphs[num_glyphs - 1].x + scaled_glyph->metrics.x_advance;
    1: 	y1 = glyphs[num_glyphs - 1].y + scaled_glyph->metrics.y_advance;
    1: 
    1: 	extents->x_advance = x1 - x0;
    1: 	extents->y_advance = y1 - y0;
    1:     } else {
    1: 	extents->x_advance = 0.0;
    1: 	extents->y_advance = 0.0;
    1:     }
  314: 
  314:  UNLOCK:
 8452:     _cairo_scaled_font_thaw_cache (scaled_font);
41340:     return;
41340: 
41340: ZERO_EXTENTS:
41340:     extents->x_bearing = 0.0;
41340:     extents->y_bearing = 0.0;
41340:     extents->width  = 0.0;
41340:     extents->height = 0.0;
41340:     extents->x_advance = 0.0;
41340:     extents->y_advance = 0.0;
    1: }
    1: slim_hidden_def (cairo_scaled_font_glyph_extents);
    1: 
70960: #define GLYPH_LUT_SIZE 64
70960: static cairo_status_t
70960: cairo_scaled_font_text_to_glyphs_internal_cached (cairo_scaled_font_t		 *scaled_font,
70960: 						    double			  x,
70960: 						    double			  y,
70960: 						    const char			 *utf8,
70960: 						    cairo_glyph_t		 *glyphs,
70960: 						    cairo_text_cluster_t	**clusters,
70960: 						    int				  num_chars)
70960: {
70960:     struct glyph_lut_elt {
70960: 	unsigned long index;
70960: 	double x_advance;
70960: 	double y_advance;
70960:     } glyph_lut[GLYPH_LUT_SIZE];
70960:     uint32_t glyph_lut_unicode[GLYPH_LUT_SIZE];
70960:     cairo_status_t status;
70960:     const char *p;
70960:     int i;
70960: 
70960:     for (i = 0; i < GLYPH_LUT_SIZE; i++)
70960: 	glyph_lut_unicode[i] = ~0U;
70960: 
70960:     p = utf8;
70960:     for (i = 0; i < num_chars; i++) {
70960: 	int idx, num_bytes;
70960: 	uint32_t unicode;
70960: 	cairo_scaled_glyph_t *scaled_glyph;
70960: 	struct glyph_lut_elt *glyph_slot;
70960: 
70960: 	num_bytes = _cairo_utf8_get_char_validated (p, &unicode);
70960: 	p += num_bytes;
70960: 
70960: 	glyphs[i].x = x;
70960: 	glyphs[i].y = y;
70960: 
70960: 	idx = unicode % ARRAY_LENGTH (glyph_lut);
70960: 	glyph_slot = &glyph_lut[idx];
70960: 	if (glyph_lut_unicode[idx] == unicode) {
70960: 	    glyphs[i].index = glyph_slot->index;
70960: 	    x += glyph_slot->x_advance;
70960: 	    y += glyph_slot->y_advance;
70960: 	} else {
70960: 	    unsigned long g;
70960: 
70960: 	    g = scaled_font->backend->ucs4_to_index (scaled_font, unicode);
70960: 	    status = _cairo_scaled_glyph_lookup (scaled_font,
70960: 						 g,
70960: 						 CAIRO_SCALED_GLYPH_INFO_METRICS,
70960: 						 &scaled_glyph);
70960: 	    if (unlikely (status))
70960: 		return status;
70960: 
70960: 	    x += scaled_glyph->metrics.x_advance;
70960: 	    y += scaled_glyph->metrics.y_advance;
70960: 
70960: 	    glyph_lut_unicode[idx] = unicode;
70960: 	    glyph_slot->index = g;
70960: 	    glyph_slot->x_advance = scaled_glyph->metrics.x_advance;
70960: 	    glyph_slot->y_advance = scaled_glyph->metrics.y_advance;
70960: 
70960: 	    glyphs[i].index = g;
70960: 	}
70960: 
70960: 	if (clusters) {
70960: 	    (*clusters)[i].num_bytes  = num_bytes;
70960: 	    (*clusters)[i].num_glyphs = 1;
70960: 	}
70960:     }
70960: 
70960:     return CAIRO_STATUS_SUCCESS;
70960: }
70960: 
70960: static cairo_status_t
70960: cairo_scaled_font_text_to_glyphs_internal_uncached (cairo_scaled_font_t	 *scaled_font,
70960: 						  double		  x,
70960: 						  double		  y,
70960: 						  const char		 *utf8,
70960: 						  cairo_glyph_t		 *glyphs,
70960: 						  cairo_text_cluster_t	**clusters,
70960: 						  int			  num_chars)
70960: {
70960:     const char *p;
70960:     int i;
70960: 
70960:     p = utf8;
70960:     for (i = 0; i < num_chars; i++) {
70960: 	unsigned long g;
70960: 	int num_bytes;
70960: 	uint32_t unicode;
70960: 	cairo_scaled_glyph_t *scaled_glyph;
70960: 	cairo_status_t status;
70960: 
70960: 	num_bytes = _cairo_utf8_get_char_validated (p, &unicode);
70960: 	p += num_bytes;
70960: 
70960: 	glyphs[i].x = x;
70960: 	glyphs[i].y = y;
70960: 
70960: 	g = scaled_font->backend->ucs4_to_index (scaled_font, unicode);
70960: 
70960: 	/*
70960: 	 * No advance needed for a single character string. So, let's speed up
70960: 	 * one-character strings by skipping glyph lookup.
70960: 	 */
70960: 	if (num_chars > 1) {
70960: 	    status = _cairo_scaled_glyph_lookup (scaled_font,
70960: 					     g,
70960: 					     CAIRO_SCALED_GLYPH_INFO_METRICS,
70960: 					     &scaled_glyph);
70960: 	    if (unlikely (status))
70960: 		return status;
70960: 
70960: 	    x += scaled_glyph->metrics.x_advance;
70960: 	    y += scaled_glyph->metrics.y_advance;
70960: 	}
70960: 
70960: 	glyphs[i].index = g;
70960: 
70960: 	if (clusters) {
70960: 	    (*clusters)[i].num_bytes  = num_bytes;
70960: 	    (*clusters)[i].num_glyphs = 1;
70960: 	}
70960:     }
70960: 
70960:     return CAIRO_STATUS_SUCCESS;
70960: }
70960: 
18904: /**
18904:  * cairo_scaled_font_text_to_glyphs:
18904:  * @x: X position to place first glyph
18904:  * @y: Y position to place first glyph
18904:  * @scaled_font: a #cairo_scaled_font_t
18904:  * @utf8: a string of text encoded in UTF-8
18904:  * @utf8_len: length of @utf8 in bytes, or -1 if it is NUL-terminated
18904:  * @glyphs: pointer to array of glyphs to fill
18904:  * @num_glyphs: pointer to number of glyphs
18904:  * @clusters: pointer to array of cluster mapping information to fill, or %NULL
18904:  * @num_clusters: pointer to number of clusters, or %NULL
21379:  * @cluster_flags: pointer to location to store cluster flags corresponding to the
21379:  *                 output @clusters, or %NULL
18904:  *
18904:  * Converts UTF-8 text to an array of glyphs, optionally with cluster
18904:  * mapping, that can be used to render later using @scaled_font.
18904:  *
18904:  * If @glyphs initially points to a non-%NULL value, that array is used
18904:  * as a glyph buffer, and @num_glyphs should point to the number of glyph
18904:  * entries available there.  If the provided glyph array is too short for
18904:  * the conversion, a new glyph array is allocated using cairo_glyph_allocate()
18904:  * and placed in @glyphs.  Upon return, @num_glyphs always contains the
21379:  * number of generated glyphs.  If the value @glyphs points to has changed
18904:  * after the call, the user is responsible for freeing the allocated glyph
21379:  * array using cairo_glyph_free().  This may happen even if the provided
21379:  * array was large enough.
18904:  *
21379:  * If @clusters is not %NULL, @num_clusters and @cluster_flags should not be %NULL,
18904:  * and cluster mapping will be computed.
18904:  * The semantics of how cluster array allocation works is similar to the glyph
18904:  * array.  That is,
18904:  * if @clusters initially points to a non-%NULL value, that array is used
18904:  * as a cluster buffer, and @num_clusters should point to the number of cluster
18904:  * entries available there.  If the provided cluster array is too short for
18904:  * the conversion, a new cluster array is allocated using cairo_text_cluster_allocate()
18904:  * and placed in @clusters.  Upon return, @num_clusters always contains the
18904:  * number of generated clusters.  If the value @clusters points at has changed
18904:  * after the call, the user is responsible for freeing the allocated cluster
21379:  * array using cairo_text_cluster_free().  This may happen even if the provided
21379:  * array was large enough.
18904:  *
18904:  * In the simplest case, @glyphs and @clusters can point to %NULL initially
18904:  * and a suitable array will be allocated.  In code:
18904:  * <informalexample><programlisting>
18904:  * cairo_status_t status;
18904:  *
18904:  * cairo_glyph_t *glyphs = NULL;
18904:  * int num_glyphs;
18904:  * cairo_text_cluster_t *clusters = NULL;
18904:  * int num_clusters;
21379:  * cairo_text_cluster_flags_t cluster_flags;
18904:  *
18904:  * status = cairo_scaled_font_text_to_glyphs (scaled_font,
18904:  *                                            x, y,
18904:  *                                            utf8, utf8_len,
18904:  *                                            &amp;glyphs, &amp;num_glyphs,
21379:  *                                            &amp;clusters, &amp;num_clusters, &amp;cluster_flags);
18904:  *
18904:  * if (status == CAIRO_STATUS_SUCCESS) {
18904:  *     cairo_show_text_glyphs (cr,
18904:  *                             utf8, utf8_len,
41340:  *                             glyphs, num_glyphs,
41340:  *                             clusters, num_clusters, cluster_flags);
18904:  *
41340:  *     cairo_glyph_free (glyphs);
41340:  *     cairo_text_cluster_free (clusters);
18904:  * }
18904:  * </programlisting></informalexample>
18904:  *
18904:  * If no cluster mapping is needed:
18904:  * <informalexample><programlisting>
18904:  * cairo_status_t status;
18904:  *
18904:  * cairo_glyph_t *glyphs = NULL;
18904:  * int num_glyphs;
18904:  *
18904:  * status = cairo_scaled_font_text_to_glyphs (scaled_font,
18904:  *                                            x, y,
18904:  *                                            utf8, utf8_len,
18904:  *                                            &amp;glyphs, &amp;num_glyphs,
18904:  *                                            NULL, NULL,
18904:  *                                            NULL);
18904:  *
18904:  * if (status == CAIRO_STATUS_SUCCESS) {
41340:  *     cairo_show_glyphs (cr, glyphs, num_glyphs);
41340:  *     cairo_glyph_free (glyphs);
18904:  * }
18904:  * </programlisting></informalexample>
18904:  *
18904:  * If stack-based glyph and cluster arrays are to be used for small
18904:  * arrays:
18904:  * <informalexample><programlisting>
18904:  * cairo_status_t status;
18904:  *
18904:  * cairo_glyph_t stack_glyphs[40];
18904:  * cairo_glyph_t *glyphs = stack_glyphs;
18904:  * int num_glyphs = sizeof (stack_glyphs) / sizeof (stack_glyphs[0]);
18904:  * cairo_text_cluster_t stack_clusters[40];
18904:  * cairo_text_cluster_t *clusters = stack_clusters;
18904:  * int num_clusters = sizeof (stack_clusters) / sizeof (stack_clusters[0]);
21379:  * cairo_text_cluster_flags_t cluster_flags;
18904:  *
18904:  * status = cairo_scaled_font_text_to_glyphs (scaled_font,
18904:  *                                            x, y,
18904:  *                                            utf8, utf8_len,
18904:  *                                            &amp;glyphs, &amp;num_glyphs,
21379:  *                                            &amp;clusters, &amp;num_clusters, &amp;cluster_flags);
18904:  *
18904:  * if (status == CAIRO_STATUS_SUCCESS) {
18904:  *     cairo_show_text_glyphs (cr,
18904:  *                             utf8, utf8_len,
41340:  *                             glyphs, num_glyphs,
41340:  *                             clusters, num_clusters, cluster_flags);
18904:  *
18904:  *     if (glyphs != stack_glyphs)
41340:  *         cairo_glyph_free (glyphs);
18904:  *     if (clusters != stack_clusters)
41340:  *         cairo_text_cluster_free (clusters);
18904:  * }
18904:  * </programlisting></informalexample>
18904:  *
21379:  * For details of how @clusters, @num_clusters, and @cluster_flags map input
18904:  * UTF-8 text to the output glyphs see cairo_show_text_glyphs().
18904:  *
18904:  * The output values can be readily passed to cairo_show_text_glyphs()
18904:  * cairo_show_glyphs(), or related functions, assuming that the exact
18904:  * same @scaled_font is used for the operation.
18904:  *
18904:  * Return value: %CAIRO_STATUS_SUCCESS upon success, or an error status
18904:  * if the input values are wrong or if conversion failed.  If the input
18904:  * values are correct but the conversion failed, the error status is also
18904:  * set on @scaled_font.
18904:  *
18904:  * Since: 1.8
18904:  **/
70960: #define CACHING_THRESHOLD 16
    1: cairo_status_t
18904: cairo_scaled_font_text_to_glyphs (cairo_scaled_font_t   *scaled_font,
    1: 				  double		 x,
    1: 				  double		 y,
    1: 				  const char	        *utf8,
18904: 				  int		         utf8_len,
    1: 				  cairo_glyph_t	       **glyphs,
18904: 				  int		        *num_glyphs,
18904: 				  cairo_text_cluster_t **clusters,
18904: 				  int		        *num_clusters,
21379: 				  cairo_text_cluster_flags_t *cluster_flags)
    1: {
18904:     int num_chars = 0;
 8452:     cairo_status_t status;
18904:     cairo_glyph_t *orig_glyphs;
18904:     cairo_text_cluster_t *orig_clusters;
16122: 
 8452:     status = scaled_font->status;
26419:     if (unlikely (status))
 8452: 	return status;
 8452: 
18904:     /* A slew of sanity checks */
18904: 
18904:     /* glyphs and num_glyphs can't be NULL */
18904:     if (glyphs     == NULL ||
18904: 	num_glyphs == NULL) {
26419: 	status = _cairo_error (CAIRO_STATUS_NULL_POINTER);
18904: 	goto BAIL;
18904:     }
18904: 
18904:     /* Special case for NULL and -1 */
18904:     if (utf8 == NULL && utf8_len == -1)
18904: 	utf8_len = 0;
18904: 
18904:     /* No NULLs for non-NULLs! */
18904:     if ((utf8_len && utf8          == NULL) ||
18904: 	(clusters && num_clusters  == NULL) ||
21379: 	(clusters && cluster_flags == NULL)) {
26419: 	status = _cairo_error (CAIRO_STATUS_NULL_POINTER);
18904: 	goto BAIL;
18904:     }
18904: 
18904:     /* A -1 for utf8_len means NUL-terminated */
18904:     if (utf8_len == -1)
18904: 	utf8_len = strlen (utf8);
18904: 
18904:     /* A NULL *glyphs means no prealloced glyphs array */
18904:     if (glyphs && *glyphs == NULL)
18904: 	*num_glyphs = 0;
18904: 
18904:     /* A NULL *clusters means no prealloced clusters array */
18904:     if (clusters && *clusters == NULL)
18904: 	*num_clusters = 0;
18904: 
18904:     if (!clusters && num_clusters) {
18904: 	num_clusters = NULL;
18904:     }
18904: 
21379:     if (cluster_flags) {
21379: 	*cluster_flags = FALSE;
18904:     }
18904: 
21379:     if (!clusters && cluster_flags) {
21379: 	cluster_flags = NULL;
18904:     }
18904: 
18904:     /* Apart from that, no negatives */
18904:     if (utf8_len < 0 ||
18904: 	*num_glyphs < 0 ||
18904: 	(num_clusters && *num_clusters < 0)) {
26419: 	status = _cairo_error (CAIRO_STATUS_NEGATIVE_COUNT);
18904: 	goto BAIL;
18904:     }
18904: 
18904:     if (utf8_len == 0) {
18904: 	status = CAIRO_STATUS_SUCCESS;
18904: 	goto BAIL;
18904:     }
18904: 
18904:     /* validate input so backend does not have to */
18904:     status = _cairo_utf8_to_ucs4 (utf8, utf8_len, NULL, &num_chars);
26419:     if (unlikely (status))
18904: 	goto BAIL;
    1: 
 8452:     _cairo_scaled_font_freeze_cache (scaled_font);
  314: 
18904:     orig_glyphs = *glyphs;
18904:     orig_clusters = clusters ? *clusters : NULL;
18904: 
    1:     if (scaled_font->backend->text_to_glyphs) {
18904: 	status = scaled_font->backend->text_to_glyphs (scaled_font, x, y,
18904: 						       utf8, utf8_len,
18904: 						       glyphs, num_glyphs,
18904: 						       clusters, num_clusters,
21379: 						       cluster_flags);
18904:         if (status != CAIRO_INT_STATUS_UNSUPPORTED) {
18904: 	    if (status == CAIRO_STATUS_SUCCESS) {
18904: 	        /* The checks here are crude; we only should do them in
18904: 		 * user-font backend, but they don't hurt here.  This stuff
18904: 		 * can be hard to get right. */
18904: 
18904: 	        if (*num_glyphs < 0) {
26419: 		    status = _cairo_error (CAIRO_STATUS_NEGATIVE_COUNT);
18831: 		    goto DONE;
18904: 		}
18904: 		if (num_glyphs && *glyphs == NULL) {
26419: 		    status = _cairo_error (CAIRO_STATUS_NULL_POINTER);
  314: 		    goto DONE;
    1: 		}
    1: 
18904: 		if (clusters) {
18904: 		    if (*num_clusters < 0) {
26419: 			status = _cairo_error (CAIRO_STATUS_NEGATIVE_COUNT);
18831: 			goto DONE;
18904: 		    }
18904: 		    if (num_clusters && *clusters == NULL) {
26419: 			status = _cairo_error (CAIRO_STATUS_NULL_POINTER);
18904: 			goto DONE;
18904: 		    }
18829: 
26419: 		    /* Don't trust the backend, validate clusters! */
26419: 		    status =
26419: 			_cairo_validate_text_clusters (utf8, utf8_len,
18904: 						       *glyphs, *num_glyphs,
18904: 						       *clusters, *num_clusters,
21379: 						       *cluster_flags);
18904: 		}
18904: 	    }
    1: 
18904:             goto DONE;
18904: 	}
18904:     }
18904: 
18904:     if (*num_glyphs < num_chars) {
18904: 	*glyphs = cairo_glyph_allocate (num_chars);
26419: 	if (unlikely (*glyphs == NULL)) {
 8452: 	    status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
  314: 	    goto DONE;
    1: 	}
18904:     }
18904:     *num_glyphs = num_chars;
    1: 
18904:     if (clusters) {
18904: 	if (*num_clusters < num_chars) {
18904: 	    *clusters = cairo_text_cluster_allocate (num_chars);
26419: 	    if (unlikely (*clusters == NULL)) {
18904: 		status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
18904: 		goto DONE;
18904: 	    }
18904: 	}
18904: 	*num_clusters = num_chars;
18904:     }
18904: 
70960:     if (num_chars > CACHING_THRESHOLD)
70960: 	status = cairo_scaled_font_text_to_glyphs_internal_cached (scaled_font,
70960: 								     x, y,
70960: 								     utf8,
70960: 								     *glyphs,
70960: 								     clusters,
70960: 								     num_chars);
70960:     else
70960: 	status = cairo_scaled_font_text_to_glyphs_internal_uncached (scaled_font,
70960: 								   x, y,
70960: 								   utf8,
70960: 								   *glyphs,
70960: 								   clusters,
70960: 								   num_chars);
    1: 
18904:  DONE: /* error that should be logged on scaled_font happened */
 8452:     _cairo_scaled_font_thaw_cache (scaled_font);
  314: 
26419:     if (unlikely (status)) {
18904: 	*num_glyphs = 0;
18904: 	if (*glyphs != orig_glyphs) {
18904: 	    cairo_glyph_free (*glyphs);
18904: 	    *glyphs = orig_glyphs;
18904: 	}
18904: 
18904: 	if (clusters) {
18904: 	    *num_clusters = 0;
18904: 	    if (*clusters != orig_clusters) {
18904: 		cairo_text_cluster_free (*clusters);
18904: 		*clusters = orig_clusters;
18904: 	    }
18904: 	}
18904:     }
    1: 
10694:     return _cairo_scaled_font_set_error (scaled_font, status);
18904: 
18904:  BAIL: /* error with input arguments */
18904: 
18904:     if (num_glyphs)
18904: 	*num_glyphs = 0;
18904: 
18904:     if (num_clusters)
18904: 	*num_clusters = 0;
18904: 
18904:     return status;
    1: }
18904: slim_hidden_def (cairo_scaled_font_text_to_glyphs);
    1: 
41340: static inline cairo_bool_t
70960: _range_contains_glyph (const cairo_box_t *extents,
70960: 		       cairo_fixed_t left,
70960: 		       cairo_fixed_t top,
70960: 		       cairo_fixed_t right,
70960: 		       cairo_fixed_t bottom)
41340: {
70960:     return right > extents->p1.x &&
70960: 	   left < extents->p2.x &&
70960: 	   bottom > extents->p1.y &&
70960: 	   top < extents->p2.y;
41340: }
41340: 
    1: /*
    1:  * Compute a device-space bounding box for the glyphs.
    1:  */
    1: cairo_status_t
    1: _cairo_scaled_font_glyph_device_extents (cairo_scaled_font_t	 *scaled_font,
    1: 					 const cairo_glyph_t	 *glyphs,
    1: 					 int                      num_glyphs,
41340: 					 cairo_rectangle_int_t   *extents,
41340: 					 cairo_bool_t *overlap_out)
    1: {
    1:     cairo_status_t status = CAIRO_STATUS_SUCCESS;
70960:     cairo_box_t box = { { INT_MAX, INT_MAX }, { INT_MIN, INT_MIN }};
32473:     cairo_scaled_glyph_t *glyph_cache[64];
41340:     cairo_bool_t overlap = overlap_out ? FALSE : TRUE;
70960:     cairo_round_glyph_positions_t round_glyph_positions = _cairo_font_options_get_round_glyph_positions (&scaled_font->options);
41340:     int i;
32473: 
32473:     if (unlikely (scaled_font->status))
    1: 	return scaled_font->status;
    1: 
21379:     _cairo_scaled_font_freeze_cache (scaled_font);
21379: 
32473:     memset (glyph_cache, 0, sizeof (glyph_cache));
32473: 
    1:     for (i = 0; i < num_glyphs; i++) {
    1: 	cairo_scaled_glyph_t	*scaled_glyph;
70960: 	cairo_fixed_t x, y, x1, y1, x2, y2;
32473: 	int cache_index = glyphs[i].index % ARRAY_LENGTH (glyph_cache);
32473: 
32473: 	scaled_glyph = glyph_cache[cache_index];
32473: 	if (scaled_glyph == NULL ||
32473: 	    _cairo_scaled_glyph_index (scaled_glyph) != glyphs[i].index)
32473: 	{
    1: 	    status = _cairo_scaled_glyph_lookup (scaled_font,
    1: 						 glyphs[i].index,
    1: 						 CAIRO_SCALED_GLYPH_INFO_METRICS,
    1: 						 &scaled_glyph);
26419: 	    if (unlikely (status))
21379: 		break;
    1: 
32473: 	    glyph_cache[cache_index] = scaled_glyph;
32473: 	}
32473: 
70960: 	if (round_glyph_positions == CAIRO_ROUND_GLYPH_POS_ON)
70960: 	    x = _cairo_fixed_from_int (_cairo_lround (glyphs[i].x));
70960: 	else
70960: 	    x = _cairo_fixed_from_double (glyphs[i].x);
70960: 	x1 = x + scaled_glyph->bbox.p1.x;
70960: 	x2 = x + scaled_glyph->bbox.p2.x;
70960: 
70960: 	if (round_glyph_positions == CAIRO_ROUND_GLYPH_POS_ON)
70960: 	    y = _cairo_fixed_from_int (_cairo_lround (glyphs[i].y));
70960: 	else
70960: 	    y = _cairo_fixed_from_double (glyphs[i].y);
70960: 	y1 = y + scaled_glyph->bbox.p1.y;
70960: 	y2 = y + scaled_glyph->bbox.p2.y;
70960: 
70960: 	if (overlap == FALSE)
70960: 	    overlap = _range_contains_glyph (&box, x1, y1, x2, y2);
70960: 
70960: 	if (x1 < box.p1.x) box.p1.x = x1;
70960: 	if (x2 > box.p2.x) box.p2.x = x2;
70960: 	if (y1 < box.p1.y) box.p1.y = y1;
70960: 	if (y2 > box.p2.y) box.p2.y = y2;
    1:     }
21379: 
21379:     _cairo_scaled_font_thaw_cache (scaled_font);
26419:     if (unlikely (status))
21379: 	return _cairo_scaled_font_set_error (scaled_font, status);
21379: 
70960:     if (box.p1.x < box.p2.x) {
70960: 	_cairo_box_round_to_rectangle (&box, extents);
    1:     } else {
    1: 	extents->x = extents->y = 0;
    1: 	extents->width = extents->height = 0;
    1:     }
21379: 
41340:     if (overlap_out != NULL)
41340: 	*overlap_out = overlap;
41340: 
    1:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
41340: void
41340: _cairo_scaled_font_glyph_approximate_extents (cairo_scaled_font_t	 *scaled_font,
41340: 					      const cairo_glyph_t	 *glyphs,
41340: 					      int                      num_glyphs,
41340: 					      cairo_rectangle_int_t   *extents)
41340: {
41340:     double x0 = HUGE_VAL, x1 = -HUGE_VAL;
41340:     double y0 = HUGE_VAL, y1 = -HUGE_VAL;
41340:     int i;
41340: 
41340:     for (i = 0; i < num_glyphs; i++) {
41340: 	double g;
41340: 
41340: 	g = glyphs[i].x;
41340: 	if (g < x0) x0 = g;
41340: 	if (g > x1) x1 = g;
41340: 
41340: 	g = glyphs[i].y;
41340: 	if (g < y0) y0 = g;
41340: 	if (g > y1) y1 = g;
41340:     }
41340: 
41340:     if (x0 <= x1 && y0 <= y1) {
41340: 	extents->x = floor (x0 - scaled_font->extents.max_x_advance);
41340: 	extents->width = ceil (x1 + scaled_font->extents.max_x_advance);
41340: 	extents->width -= extents->x;
41340: 
41340: 	extents->y = floor (y0 - scaled_font->extents.ascent);
41340: 	extents->height = ceil (y1 + scaled_font->extents.descent);
41340: 	extents->height -= extents->y;
41340:     } else {
41340: 	extents->x = extents->y = 0;
41340: 	extents->width = extents->height = 0;
41340:     }
41340: }
41340: 
    1: cairo_status_t
    1: _cairo_scaled_font_show_glyphs (cairo_scaled_font_t	*scaled_font,
    1: 				cairo_operator_t	 op,
26419: 				const cairo_pattern_t	*pattern,
    1: 				cairo_surface_t		*surface,
    1: 				int			 source_x,
    1: 				int			 source_y,
    1: 				int			 dest_x,
    1: 				int			 dest_y,
    1: 				unsigned int		 width,
    1: 				unsigned int		 height,
    1: 				cairo_glyph_t		*glyphs,
41340: 				int			 num_glyphs,
41340: 				cairo_region_t		*clip_region)
    1: {
    1:     cairo_status_t status;
    1:     cairo_surface_t *mask = NULL;
10414:     cairo_format_t mask_format = CAIRO_FORMAT_A1; /* shut gcc up */
 8452:     cairo_surface_pattern_t mask_pattern;
    1:     int i;
    1: 
    1:     /* These operators aren't interpreted the same way by the backends;
    1:      * they are implemented in terms of other operators in cairo-gstate.c
    1:      */
    1:     assert (op != CAIRO_OPERATOR_SOURCE && op != CAIRO_OPERATOR_CLEAR);
    1: 
    1:     if (scaled_font->status)
    1: 	return scaled_font->status;
    1: 
    1:     if (!num_glyphs)
    1: 	return CAIRO_STATUS_SUCCESS;
    1: 
    1:     if (scaled_font->backend->show_glyphs != NULL) {
16122: 	int remaining_glyphs = num_glyphs;
    1: 	status = scaled_font->backend->show_glyphs (scaled_font,
    1: 						    op, pattern,
    1: 						    surface,
    1: 						    source_x, source_y,
    1: 						    dest_x, dest_y,
    1: 						    width, height,
41340: 						    glyphs, num_glyphs,
41340: 						    clip_region,
41340: 						    &remaining_glyphs);
16122: 	glyphs += num_glyphs - remaining_glyphs;
16122: 	num_glyphs = remaining_glyphs;
16122: 	if (remaining_glyphs == 0)
16122: 	    status = CAIRO_STATUS_SUCCESS;
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 8452: 	    return _cairo_scaled_font_set_error (scaled_font, status);
    1:     }
    1: 
    1:     /* Font display routine either does not exist or failed. */
    1: 
21379:     _cairo_scaled_font_freeze_cache (scaled_font);
    1: 
    1:     for (i = 0; i < num_glyphs; i++) {
    1: 	int x, y;
    1: 	cairo_image_surface_t *glyph_surface;
    1: 	cairo_scaled_glyph_t *scaled_glyph;
    1: 
    1: 	status = _cairo_scaled_glyph_lookup (scaled_font,
    1: 					     glyphs[i].index,
    1: 					     CAIRO_SCALED_GLYPH_INFO_SURFACE,
    1: 					     &scaled_glyph);
    1: 
26419: 	if (unlikely (status))
    1: 	    goto CLEANUP_MASK;
    1: 
    1: 	glyph_surface = scaled_glyph->surface;
    1: 
10414: 	/* To start, create the mask using the format from the first
10414: 	 * glyph. Later we'll deal with different formats. */
    1: 	if (mask == NULL) {
10414: 	    mask_format = glyph_surface->format;
41340: 	    mask = cairo_image_surface_create (mask_format, width, height);
    1: 	    status = mask->status;
26419: 	    if (unlikely (status))
    1: 		goto CLEANUP_MASK;
    1: 	}
    1: 
10414: 	/* If we have glyphs of different formats, we "upgrade" the mask
10414: 	 * to the wider of the formats. */
10414: 	if (glyph_surface->format != mask_format &&
11708: 	    _cairo_format_bits_per_pixel (mask_format) <
11708: 	    _cairo_format_bits_per_pixel (glyph_surface->format) )
10414: 	{
10414: 	    cairo_surface_t *new_mask;
10414: 
10414: 	    switch (glyph_surface->format) {
10414: 	    case CAIRO_FORMAT_ARGB32:
10414: 	    case CAIRO_FORMAT_A8:
10414: 	    case CAIRO_FORMAT_A1:
10414: 		mask_format = glyph_surface->format;
10414: 		break;
70960: 	    case CAIRO_FORMAT_RGB16_565:
10414: 	    case CAIRO_FORMAT_RGB24:
70960: 	    case CAIRO_FORMAT_INVALID:
10414: 	    default:
10414: 		ASSERT_NOT_REACHED;
10414: 		mask_format = CAIRO_FORMAT_ARGB32;
10414: 		break;
10414: 	    }
10414: 
41340: 	    new_mask = cairo_image_surface_create (mask_format, width, height);
10414: 	    status = new_mask->status;
41340: 	    if (unlikely (status)) {
40590: 		cairo_surface_destroy (new_mask);
40590: 		goto CLEANUP_MASK;
40590: 	    }
40590: 
40590: 	    _cairo_pattern_init_for_surface (&mask_pattern, mask);
41340: 	    /* Note that we only upgrade masks, i.e. A1 -> A8 -> ARGB32, so there is
41340: 	     * never any component alpha here.
41340: 	     */
70960: 	    status = _cairo_surface_composite (CAIRO_OPERATOR_ADD,
70960: 					       &_cairo_pattern_white.base,
40590: 					       &mask_pattern.base,
40590: 					       new_mask,
40590: 					       0, 0,
40590: 					       0, 0,
40590: 					       0, 0,
41340: 					       width, height,
41340: 					       NULL);
40590: 
40590: 	    _cairo_pattern_fini (&mask_pattern.base);
40590: 
40574: 	    if (unlikely (status)) {
40466: 		cairo_surface_destroy (new_mask);
40466: 		goto CLEANUP_MASK;
40466: 	    }
40466: 
10414: 	    cairo_surface_destroy (mask);
10414: 	    mask = new_mask;
    1: 	}
    1: 
41340: 	if (glyph_surface->width && glyph_surface->height) {
41340: 	    cairo_surface_pattern_t glyph_pattern;
41340: 
    1: 	    /* round glyph locations to the nearest pixel */
    1: 	    /* XXX: FRAGILE: We're ignoring device_transform scaling here. A bug? */
41340: 	    x = _cairo_lround (glyphs[i].x -
41340: 			       glyph_surface->base.device_transform.x0);
41340: 	    y = _cairo_lround (glyphs[i].y -
41340: 			       glyph_surface->base.device_transform.y0);
41340: 
41340: 	    _cairo_pattern_init_for_surface (&glyph_pattern,
41340: 					     &glyph_surface->base);
41340: 	    if (mask_format == CAIRO_FORMAT_ARGB32)
41340: 		glyph_pattern.base.has_component_alpha = TRUE;
    1: 
    1: 	    status = _cairo_surface_composite (CAIRO_OPERATOR_ADD,
70960: 					       &_cairo_pattern_white.base,
    1: 					       &glyph_pattern.base,
    1: 					       mask,
    1: 					       0, 0,
    1: 					       0, 0,
10414: 					       x - dest_x, y - dest_y,
    1: 					       glyph_surface->width,
41340: 					       glyph_surface->height,
41340: 					       NULL);
    1: 
    1: 	    _cairo_pattern_fini (&glyph_pattern.base);
10414: 
26419: 	    if (unlikely (status))
 4133: 		goto CLEANUP_MASK;
    1: 	}
41340:     }
41340: 
41340:     _cairo_pattern_init_for_surface (&mask_pattern, mask);
40590:     if (mask_format == CAIRO_FORMAT_ARGB32)
41340: 	mask_pattern.base.has_component_alpha = TRUE;
    1: 
    1:     status = _cairo_surface_composite (op, pattern, &mask_pattern.base,
    1: 				       surface,
    1: 				       source_x, source_y,
    1: 				       0,        0,
    1: 				       dest_x,   dest_y,
41340: 				       width,    height,
41340: 				       clip_region);
    1: 
    1:     _cairo_pattern_fini (&mask_pattern.base);
    1: 
    1: CLEANUP_MASK:
21379:     _cairo_scaled_font_thaw_cache (scaled_font);
    1: 
    1:     if (mask != NULL)
    1: 	cairo_surface_destroy (mask);
 8452:     return _cairo_scaled_font_set_error (scaled_font, status);
    1: }
    1: 
 4133: /* Add a single-device-unit rectangle to a path. */
 4133: static cairo_status_t
41340: _add_unit_rectangle_to_path (cairo_path_fixed_t *path,
41340: 			     cairo_fixed_t x,
41340: 			     cairo_fixed_t y)
 4133: {
 4133:     cairo_status_t status;
 4133: 
41340:     status = _cairo_path_fixed_move_to (path, x, y);
26419:     if (unlikely (status))
 4133: 	return status;
 4133: 
 4133:     status = _cairo_path_fixed_rel_line_to (path,
 4133: 					    _cairo_fixed_from_int (1),
 4133: 					    _cairo_fixed_from_int (0));
26419:     if (unlikely (status))
 4133: 	return status;
 4133: 
 4133:     status = _cairo_path_fixed_rel_line_to (path,
 4133: 					    _cairo_fixed_from_int (0),
 4133: 					    _cairo_fixed_from_int (1));
26419:     if (unlikely (status))
 4133: 	return status;
 4133: 
 4133:     status = _cairo_path_fixed_rel_line_to (path,
 4133: 					    _cairo_fixed_from_int (-1),
 4133: 					    _cairo_fixed_from_int (0));
26419:     if (unlikely (status))
 4133: 	return status;
 4133: 
41340:     return _cairo_path_fixed_close_path (path);
 4133: }
    1: 
    1: /**
    1:  * _trace_mask_to_path:
11708:  * @bitmap: An alpha mask (either %CAIRO_FORMAT_A1 or %CAIRO_FORMAT_A8)
    1:  * @path: An initialized path to hold the result
    1:  *
    1:  * Given a mask surface, (an alpha image), fill out the provided path
    1:  * so that when filled it would result in something that approximates
    1:  * the mask.
    1:  *
    1:  * Note: The current tracing code here is extremely primitive. It
    1:  * operates only on an A1 surface, (converting an A8 surface to A1 if
    1:  * necessary), and performs the tracing by drawing a little square
    1:  * around each pixel that is on in the mask. We do not pretend that
    1:  * this is a high-quality result. But we are leaving it up to someone
    1:  * who cares enough about getting a better result to implement
    1:  * something more sophisticated.
    1:  **/
    1: static cairo_status_t
    1: _trace_mask_to_path (cairo_image_surface_t *mask,
41340: 		     cairo_path_fixed_t *path,
41340: 		     double tx, double ty)
    1: {
26419:     const uint8_t *row;
    1:     int rows, cols, bytes_per_row;
    1:     int x, y, bit;
    1:     double xoff, yoff;
41340:     cairo_fixed_t x0, y0;
41340:     cairo_fixed_t px, py;
26419:     cairo_status_t status;
26419: 
70960:     mask = _cairo_image_surface_coerce_to_format (mask, CAIRO_FORMAT_A1);
26419:     status = mask->base.status;
26419:     if (unlikely (status))
 8452: 	return status;
26419: 
26419:     cairo_surface_get_device_offset (&mask->base, &xoff, &yoff);
41340:     x0 = _cairo_fixed_from_double (tx - xoff);
41340:     y0 = _cairo_fixed_from_double (ty - yoff);
26419: 
26419:     bytes_per_row = (mask->width + 7) / 8;
26419:     row = mask->data;
26419:     for (y = 0, rows = mask->height; rows--; row += mask->stride, y++) {
26419: 	const uint8_t *byte_ptr = row;
26419: 	x = 0;
41340: 	py = _cairo_fixed_from_int (y);
26419: 	for (cols = bytes_per_row; cols--; ) {
26419: 	    uint8_t byte = *byte_ptr++;
26419: 	    if (byte == 0) {
26419: 		x += 8;
26419: 		continue;
 8452: 	    }
    1: 
26419: 	    byte = CAIRO_BITSWAP8_IF_LITTLE_ENDIAN (byte);
26419: 	    for (bit = 1 << 7; bit && x < mask->width; bit >>= 1, x++) {
26419: 		if (byte & bit) {
41340: 		    px = _cairo_fixed_from_int (x);
 4133: 		    status = _add_unit_rectangle_to_path (path,
41340: 							  px + x0,
41340: 							  py + y0);
26419: 		    if (unlikely (status))
 8452: 			goto BAIL;
    1: 		}
    1: 	    }
    1: 	}
    1:     }
    1: 
 8452: BAIL:
26419:     cairo_surface_destroy (&mask->base);
    1: 
 8452:     return status;
    1: }
    1: 
    1: cairo_status_t
    1: _cairo_scaled_font_glyph_path (cairo_scaled_font_t *scaled_font,
    1: 			       const cairo_glyph_t *glyphs,
    1: 			       int		    num_glyphs,
    1: 			       cairo_path_fixed_t  *path)
    1: {
    1:     cairo_status_t status;
    1:     int	i;
    1: 
 8452:     status = scaled_font->status;
26419:     if (unlikely (status))
 8452: 	return status;
    1: 
 8452:     _cairo_scaled_font_freeze_cache (scaled_font);
    1:     for (i = 0; i < num_glyphs; i++) {
    1: 	cairo_scaled_glyph_t *scaled_glyph;
    1: 
    1: 	status = _cairo_scaled_glyph_lookup (scaled_font,
    1: 					     glyphs[i].index,
    1: 					     CAIRO_SCALED_GLYPH_INFO_PATH,
    1: 					     &scaled_glyph);
41340: 	if (status == CAIRO_STATUS_SUCCESS) {
41340: 	    status = _cairo_path_fixed_append (path,
41340: 					       scaled_glyph->path, CAIRO_DIRECTION_FORWARD,
41340: 					       _cairo_fixed_from_double (glyphs[i].x),
41340: 					       _cairo_fixed_from_double (glyphs[i].y));
41340: 
41340: 	} else if (status == CAIRO_INT_STATUS_UNSUPPORTED) {
    1: 	    /* If the font is incapable of providing a path, then we'll
41340: 	     * have to trace our own from a surface.
41340: 	     */
    1: 	    status = _cairo_scaled_glyph_lookup (scaled_font,
    1: 						 glyphs[i].index,
    1: 						 CAIRO_SCALED_GLYPH_INFO_SURFACE,
    1: 						 &scaled_glyph);
26419: 	    if (unlikely (status))
 8452: 		goto BAIL;
    1: 
41340: 	    status = _trace_mask_to_path (scaled_glyph->surface, path,
41340: 					  glyphs[i].x, glyphs[i].y);
 8452: 	}
    1: 
26419: 	if (unlikely (status))
 8452: 	    goto BAIL;
    1:     }
 8452:   BAIL:
 8452:     _cairo_scaled_font_thaw_cache (scaled_font);
    1: 
 8452:     return _cairo_scaled_font_set_error (scaled_font, status);
    1: }
    1: 
    1: /**
16122:  * _cairo_scaled_glyph_set_metrics:
    1:  * @scaled_glyph: a #cairo_scaled_glyph_t
    1:  * @scaled_font: a #cairo_scaled_font_t
    1:  * @fs_metrics: a #cairo_text_extents_t in font space
    1:  *
    1:  * _cairo_scaled_glyph_set_metrics() stores user space metrics
    1:  * for the specified glyph given font space metrics. It is
    1:  * called by the font backend when initializing a glyph with
16122:  * %CAIRO_SCALED_GLYPH_INFO_METRICS.
    1:  **/
    1: void
    1: _cairo_scaled_glyph_set_metrics (cairo_scaled_glyph_t *scaled_glyph,
    1: 				 cairo_scaled_font_t *scaled_font,
    1: 				 cairo_text_extents_t *fs_metrics)
    1: {
    1:     cairo_bool_t first = TRUE;
    1:     double hm, wm;
    1:     double min_user_x = 0.0, max_user_x = 0.0, min_user_y = 0.0, max_user_y = 0.0;
    1:     double min_device_x = 0.0, max_device_x = 0.0, min_device_y = 0.0, max_device_y = 0.0;
    1:     double device_x_advance, device_y_advance;
    1: 
26419:     scaled_glyph->fs_metrics = *fs_metrics;
26419: 
    1:     for (hm = 0.0; hm <= 1.0; hm += 1.0)
    1: 	for (wm = 0.0; wm <= 1.0; wm += 1.0) {
    1: 	    double x, y;
    1: 
    1: 	    /* Transform this corner to user space */
    1: 	    x = fs_metrics->x_bearing + fs_metrics->width * wm;
    1: 	    y = fs_metrics->y_bearing + fs_metrics->height * hm;
    1: 	    cairo_matrix_transform_point (&scaled_font->font_matrix,
    1: 					  &x, &y);
    1: 	    if (first) {
    1: 		min_user_x = max_user_x = x;
    1: 		min_user_y = max_user_y = y;
    1: 	    } else {
    1: 		if (x < min_user_x) min_user_x = x;
    1: 		if (x > max_user_x) max_user_x = x;
    1: 		if (y < min_user_y) min_user_y = y;
    1: 		if (y > max_user_y) max_user_y = y;
    1: 	    }
    1: 
    1: 	    /* Transform this corner to device space from glyph origin */
    1: 	    x = fs_metrics->x_bearing + fs_metrics->width * wm;
    1: 	    y = fs_metrics->y_bearing + fs_metrics->height * hm;
    1: 	    cairo_matrix_transform_distance (&scaled_font->scale,
    1: 					     &x, &y);
    1: 
    1: 	    if (first) {
    1: 		min_device_x = max_device_x = x;
    1: 		min_device_y = max_device_y = y;
    1: 	    } else {
    1: 		if (x < min_device_x) min_device_x = x;
    1: 		if (x > max_device_x) max_device_x = x;
    1: 		if (y < min_device_y) min_device_y = y;
    1: 		if (y > max_device_y) max_device_y = y;
    1: 	    }
    1: 	    first = FALSE;
    1: 	}
    1:     scaled_glyph->metrics.x_bearing = min_user_x;
    1:     scaled_glyph->metrics.y_bearing = min_user_y;
    1:     scaled_glyph->metrics.width = max_user_x - min_user_x;
    1:     scaled_glyph->metrics.height = max_user_y - min_user_y;
    1: 
    1:     scaled_glyph->metrics.x_advance = fs_metrics->x_advance;
    1:     scaled_glyph->metrics.y_advance = fs_metrics->y_advance;
    1:     cairo_matrix_transform_distance (&scaled_font->font_matrix,
    1: 				     &scaled_glyph->metrics.x_advance,
    1: 				     &scaled_glyph->metrics.y_advance);
    1: 
    1:     device_x_advance = fs_metrics->x_advance;
    1:     device_y_advance = fs_metrics->y_advance;
    1:     cairo_matrix_transform_distance (&scaled_font->scale,
    1: 				     &device_x_advance,
    1: 				     &device_y_advance);
    1: 
    1:     scaled_glyph->bbox.p1.x = _cairo_fixed_from_double (min_device_x);
    1:     scaled_glyph->bbox.p1.y = _cairo_fixed_from_double (min_device_y);
    1:     scaled_glyph->bbox.p2.x = _cairo_fixed_from_double (max_device_x);
    1:     scaled_glyph->bbox.p2.y = _cairo_fixed_from_double (max_device_y);
    1: 
    1:     scaled_glyph->x_advance = _cairo_lround (device_x_advance);
    1:     scaled_glyph->y_advance = _cairo_lround (device_y_advance);
70960: 
70960:     scaled_glyph->has_info |= CAIRO_SCALED_GLYPH_INFO_METRICS;
    1: }
    1: 
    1: void
    1: _cairo_scaled_glyph_set_surface (cairo_scaled_glyph_t *scaled_glyph,
    1: 				 cairo_scaled_font_t *scaled_font,
    1: 				 cairo_image_surface_t *surface)
    1: {
    1:     if (scaled_glyph->surface != NULL)
    1: 	cairo_surface_destroy (&scaled_glyph->surface->base);
29608: 
29608:     /* sanity check the backend glyph contents */
29608:     _cairo_debug_check_image_surface_is_defined (&surface->base);
    1:     scaled_glyph->surface = surface;
70960: 
70960:     if (surface != NULL)
70960: 	scaled_glyph->has_info |= CAIRO_SCALED_GLYPH_INFO_SURFACE;
70960:     else
70960: 	scaled_glyph->has_info &= ~CAIRO_SCALED_GLYPH_INFO_SURFACE;
    1: }
    1: 
    1: void
    1: _cairo_scaled_glyph_set_path (cairo_scaled_glyph_t *scaled_glyph,
    1: 			      cairo_scaled_font_t *scaled_font,
    1: 			      cairo_path_fixed_t *path)
    1: {
    1:     if (scaled_glyph->path != NULL)
    1: 	_cairo_path_fixed_destroy (scaled_glyph->path);
70960: 
    1:     scaled_glyph->path = path;
70960: 
70960:     if (path != NULL)
70960: 	scaled_glyph->has_info |= CAIRO_SCALED_GLYPH_INFO_PATH;
70960:     else
70960: 	scaled_glyph->has_info &= ~CAIRO_SCALED_GLYPH_INFO_PATH;
    1: }
    1: 
16122: void
41340: _cairo_scaled_glyph_set_recording_surface (cairo_scaled_glyph_t *scaled_glyph,
16122: 					   cairo_scaled_font_t *scaled_font,
41340: 					   cairo_surface_t *recording_surface)
16122: {
70960:     if (scaled_glyph->recording_surface != NULL) {
70960: 	cairo_surface_finish (scaled_glyph->recording_surface);
70960: 	cairo_surface_destroy (scaled_glyph->recording_surface);
70960:     }
70960: 
41340:     scaled_glyph->recording_surface = recording_surface;
70960: 
70960:     if (recording_surface != NULL)
70960: 	scaled_glyph->has_info |= CAIRO_SCALED_GLYPH_INFO_RECORDING_SURFACE;
70960:     else
70960: 	scaled_glyph->has_info &= ~CAIRO_SCALED_GLYPH_INFO_RECORDING_SURFACE;
16122: }
16122: 
26419: static cairo_bool_t
26419: _cairo_scaled_glyph_page_can_remove (const void *closure)
26419: {
26419:     const cairo_scaled_glyph_page_t *page = closure;
26419:     const cairo_scaled_font_t *scaled_font;
26419: 
26419:     scaled_font = (cairo_scaled_font_t *) page->cache_entry.hash;
26419:     return scaled_font->cache_frozen == 0;
26419: }
26419: 
26419: static cairo_status_t
26419: _cairo_scaled_font_allocate_glyph (cairo_scaled_font_t *scaled_font,
26419: 				   cairo_scaled_glyph_t **scaled_glyph)
26419: {
26419:     cairo_scaled_glyph_page_t *page;
26419:     cairo_status_t status;
26419: 
26419:     /* only the first page in the list may contain available slots */
70960:     if (! cairo_list_is_empty (&scaled_font->glyph_pages)) {
70960:         page = cairo_list_last_entry (&scaled_font->glyph_pages,
70960:                                       cairo_scaled_glyph_page_t,
70960:                                       link);
70960:         if (page->num_glyphs < CAIRO_SCALED_GLYPH_PAGE_SIZE) {
26419:             *scaled_glyph = &page->glyphs[page->num_glyphs++];
26419:             return CAIRO_STATUS_SUCCESS;
26419:         }
70960:     }
26419: 
26419:     page = malloc (sizeof (cairo_scaled_glyph_page_t));
26419:     if (unlikely (page == NULL))
26419: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
26419: 
72303:     page->cache_entry.hash = (uintptr_t) scaled_font;
26419:     page->cache_entry.size = 1; /* XXX occupancy weighting? */
26419:     page->num_glyphs = 0;
26419: 
26419:     CAIRO_MUTEX_LOCK (_cairo_scaled_glyph_page_cache_mutex);
26419:     if (scaled_font->global_cache_frozen == FALSE) {
32473: 	if (unlikely (cairo_scaled_glyph_page_cache.hash_table == NULL)) {
32473: 	    status = _cairo_cache_init (&cairo_scaled_glyph_page_cache,
32473: 					NULL,
26419: 					_cairo_scaled_glyph_page_can_remove,
26419: 					_cairo_scaled_glyph_page_destroy,
26419: 					MAX_GLYPH_PAGES_CACHED);
32473: 	    if (unlikely (status)) {
26419: 		CAIRO_MUTEX_UNLOCK (_cairo_scaled_glyph_page_cache_mutex);
26419: 		free (page);
32473: 		return status;
26419: 	    }
26419: 	}
26419: 
32473: 	_cairo_cache_freeze (&cairo_scaled_glyph_page_cache);
26419: 	scaled_font->global_cache_frozen = TRUE;
26419:     }
26419: 
32473:     status = _cairo_cache_insert (&cairo_scaled_glyph_page_cache,
26419: 				  &page->cache_entry);
26419:     CAIRO_MUTEX_UNLOCK (_cairo_scaled_glyph_page_cache_mutex);
26419:     if (unlikely (status)) {
26419: 	free (page);
26419: 	return status;
26419:     }
26419: 
70960:     cairo_list_add_tail (&page->link, &scaled_font->glyph_pages);
26419: 
26419:     *scaled_glyph = &page->glyphs[page->num_glyphs++];
26419:     return CAIRO_STATUS_SUCCESS;
26419: }
26419: 
26419: static void
26419: _cairo_scaled_font_free_last_glyph (cairo_scaled_font_t *scaled_font,
26419: 			           cairo_scaled_glyph_t *scaled_glyph)
26419: {
26419:     cairo_scaled_glyph_page_t *page;
26419: 
70960:     assert (! cairo_list_is_empty (&scaled_font->glyph_pages));
70960:     page = cairo_list_last_entry (&scaled_font->glyph_pages,
70960:                                   cairo_scaled_glyph_page_t,
70960:                                   link);
70960:     assert (scaled_glyph == &page->glyphs[page->num_glyphs-1]);
26419: 
26419:     _cairo_scaled_glyph_fini (scaled_font, scaled_glyph);
26419: 
26419:     if (--page->num_glyphs == 0) {
32473: 	_cairo_cache_remove (&cairo_scaled_glyph_page_cache,
32473: 		             &page->cache_entry);
26419:     }
26419: }
26419: 
    1: /**
    1:  * _cairo_scaled_glyph_lookup:
    1:  * @scaled_font: a #cairo_scaled_font_t
    1:  * @index: the glyph to create
    1:  * @info: a #cairo_scaled_glyph_info_t marking which portions of
    1:  * the glyph should be filled in.
21379:  * @scaled_glyph_ret: a #cairo_scaled_glyph_t where the glyph
    1:  * is returned.
    1:  *
21379:  * If the desired info is not available, (for example, when trying to
21379:  * get INFO_PATH with a bitmapped font), this function will return
21379:  * %CAIRO_INT_STATUS_UNSUPPORTED.
21379:  *
21379:  * Note: This function must be called with the scaled font frozen, and it must
21379:  * remain frozen for as long as the @scaled_glyph_ret is alive. (If the scaled
21379:  * font was not frozen, then there is no guarantee that the glyph would not be
21379:  * evicted before you tried to access it.) See
21379:  * _cairo_scaled_font_freeze_cache() and _cairo_scaled_font_thaw_cache().
21379:  *
11708:  * Returns: a glyph with the requested portions filled in. Glyph
    1:  * lookup is cached and glyph will be automatically freed along
    1:  * with the scaled_font so no explicit free is required.
    1:  * @info can be one or more of:
    1:  *  %CAIRO_SCALED_GLYPH_INFO_METRICS - glyph metrics and bounding box
    1:  *  %CAIRO_SCALED_GLYPH_INFO_SURFACE - surface holding glyph image
    1:  *  %CAIRO_SCALED_GLYPH_INFO_PATH - path holding glyph outline in device space
    1:  **/
    1: cairo_int_status_t
    1: _cairo_scaled_glyph_lookup (cairo_scaled_font_t *scaled_font,
    1: 			    unsigned long index,
    1: 			    cairo_scaled_glyph_info_t info,
    1: 			    cairo_scaled_glyph_t **scaled_glyph_ret)
    1: {
    1:     cairo_status_t		 status = CAIRO_STATUS_SUCCESS;
    1:     cairo_scaled_glyph_t	*scaled_glyph;
    1:     cairo_scaled_glyph_info_t	 need_info;
    1: 
70960:     *scaled_glyph_ret = NULL;
70960: 
26419:     if (unlikely (scaled_font->status))
    1: 	return scaled_font->status;
    1: 
28364:     if (CAIRO_INJECT_FAULT ())
28364: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
28364: 
    1:     /*
    1:      * Check cache for glyph
    1:      */
26419:     scaled_glyph = _cairo_hash_table_lookup (scaled_font->glyphs,
26419: 					     (cairo_hash_entry_t *) &index);
    1:     if (scaled_glyph == NULL) {
26419: 	status = _cairo_scaled_font_allocate_glyph (scaled_font, &scaled_glyph);
26419: 	if (unlikely (status))
70960: 	    goto err;
26419: 
26419: 	memset (scaled_glyph, 0, sizeof (cairo_scaled_glyph_t));
26419: 	_cairo_scaled_glyph_set_index (scaled_glyph, index);
26419: 
26419: 	/* ask backend to initialize metrics and shape fields */
26419: 	status =
26419: 	    scaled_font->backend->scaled_glyph_init (scaled_font,
26419: 						     scaled_glyph,
26419: 						     info | CAIRO_SCALED_GLYPH_INFO_METRICS);
26419: 	if (unlikely (status)) {
26419: 	    _cairo_scaled_font_free_last_glyph (scaled_font, scaled_glyph);
70960: 	    goto err;
    1: 	}
    1: 
26419: 	status = _cairo_hash_table_insert (scaled_font->glyphs,
26419: 					   &scaled_glyph->hash_entry);
26419: 	if (unlikely (status)) {
26419: 	    _cairo_scaled_font_free_last_glyph (scaled_font, scaled_glyph);
70960: 	    goto err;
    1: 	}
    1:     }
26419: 
    1:     /*
    1:      * Check and see if the glyph, as provided,
26419:      * already has the requested data and amend it if not
    1:      */
70960:     need_info = info & ~scaled_glyph->has_info;
    1:     if (need_info) {
26419: 	status = scaled_font->backend->scaled_glyph_init (scaled_font,
26419: 							  scaled_glyph,
26419: 							  need_info);
26419: 	if (unlikely (status))
70960: 	    goto err;
16122: 
16122: 	/* Don't trust the scaled_glyph_init() return value, the font
16122: 	 * backend may not even know about some of the info.  For example,
41340: 	 * no backend other than the user-fonts knows about recording-surface
16122: 	 * glyph info. */
70960: 	if (info & ~scaled_glyph->has_info)
70960: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
16122:     }
16122: 
70960:     *scaled_glyph_ret = scaled_glyph;
70960:     return CAIRO_STATUS_SUCCESS;
70960: 
70960: err:
    1:     /* It's not an error for the backend to not support the info we want. */
    1:     if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 8452: 	status = _cairo_scaled_font_set_error (scaled_font, status);
    1:     return status;
    1: }
    1: 
16122: double
16122: _cairo_scaled_font_get_max_scale (cairo_scaled_font_t *scaled_font)
16122: {
16122:     return scaled_font->max_scale;
16122: }
16122: 
16122: 
    1: /**
    1:  * cairo_scaled_font_get_font_face:
    1:  * @scaled_font: a #cairo_scaled_font_t
    1:  *
26419:  * Gets the font face that this scaled font uses.  This is the
41340:  * font face passed to cairo_scaled_font_create().
    1:  *
    1:  * Return value: The #cairo_font_face_t with which @scaled_font was
    1:  * created.
    1:  *
    1:  * Since: 1.2
    1:  **/
    1: cairo_font_face_t *
    1: cairo_scaled_font_get_font_face (cairo_scaled_font_t *scaled_font)
    1: {
    1:     if (scaled_font->status)
    1: 	return (cairo_font_face_t*) &_cairo_font_face_nil;
    1: 
32473:     if (scaled_font->original_font_face != NULL)
32473: 	return scaled_font->original_font_face;
32473: 
    1:     return scaled_font->font_face;
    1: }
    1: slim_hidden_def (cairo_scaled_font_get_font_face);
    1: 
    1: /**
    1:  * cairo_scaled_font_get_font_matrix:
    1:  * @scaled_font: a #cairo_scaled_font_t
    1:  * @font_matrix: return value for the matrix
    1:  *
    1:  * Stores the font matrix with which @scaled_font was created into
    1:  * @matrix.
    1:  *
    1:  * Since: 1.2
    1:  **/
    1: void
    1: cairo_scaled_font_get_font_matrix (cairo_scaled_font_t	*scaled_font,
    1: 				   cairo_matrix_t	*font_matrix)
    1: {
    1:     if (scaled_font->status) {
    1: 	cairo_matrix_init_identity (font_matrix);
    1: 	return;
    1:     }
    1: 
    1:     *font_matrix = scaled_font->font_matrix;
    1: }
    1: slim_hidden_def (cairo_scaled_font_get_font_matrix);
    1: 
    1: /**
    1:  * cairo_scaled_font_get_ctm:
    1:  * @scaled_font: a #cairo_scaled_font_t
    1:  * @ctm: return value for the CTM
    1:  *
    1:  * Stores the CTM with which @scaled_font was created into @ctm.
26419:  * Note that the translation offsets (x0, y0) of the CTM are ignored
26419:  * by cairo_scaled_font_create().  So, the matrix this
26419:  * function returns always has 0,0 as x0,y0.
    1:  *
    1:  * Since: 1.2
    1:  **/
    1: void
    1: cairo_scaled_font_get_ctm (cairo_scaled_font_t	*scaled_font,
    1: 			   cairo_matrix_t	*ctm)
    1: {
    1:     if (scaled_font->status) {
    1: 	cairo_matrix_init_identity (ctm);
    1: 	return;
    1:     }
    1: 
    1:     *ctm = scaled_font->ctm;
    1: }
    1: slim_hidden_def (cairo_scaled_font_get_ctm);
    1: 
    1: /**
16122:  * cairo_scaled_font_get_scale_matrix:
16122:  * @scaled_font: a #cairo_scaled_font_t
16122:  * @scale_matrix: return value for the matrix
16122:  *
16122:  * Stores the scale matrix of @scaled_font into @matrix.
16122:  * The scale matrix is product of the font matrix and the ctm
16122:  * associated with the scaled font, and hence is the matrix mapping from
16122:  * font space to device space.
16122:  *
16122:  * Since: 1.8
16122:  **/
16122: void
16122: cairo_scaled_font_get_scale_matrix (cairo_scaled_font_t	*scaled_font,
16122: 				    cairo_matrix_t	*scale_matrix)
16122: {
16122:     if (scaled_font->status) {
16122: 	cairo_matrix_init_identity (scale_matrix);
16122: 	return;
16122:     }
16122: 
16122:     *scale_matrix = scaled_font->scale;
16122: }
16122: 
16122: /**
    1:  * cairo_scaled_font_get_font_options:
    1:  * @scaled_font: a #cairo_scaled_font_t
    1:  * @options: return value for the font options
    1:  *
    1:  * Stores the font options with which @scaled_font was created into
    1:  * @options.
    1:  *
    1:  * Since: 1.2
    1:  **/
    1: void
    1: cairo_scaled_font_get_font_options (cairo_scaled_font_t		*scaled_font,
    1: 				    cairo_font_options_t	*options)
    1: {
 4133:     if (cairo_font_options_status (options))
 4133: 	return;
 4133: 
    1:     if (scaled_font->status) {
    1: 	_cairo_font_options_init_default (options);
    1: 	return;
    1:     }
    1: 
    1:     _cairo_font_options_init_copy (options, &scaled_font->options);
    1: }
    1: slim_hidden_def (cairo_scaled_font_get_font_options);
