    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAccessNode.h"
    1: #include "nsIAccessible.h"
    1: #include "nsAccessibilityAtoms.h"
    1: #include "nsHashtable.h"
30820: #include "nsAccessibilityService.h"
    1: #include "nsIAccessibleDocument.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
 1509: #include "nsIDOMCSSPrimitiveValue.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMElement.h"
 1751: #include "nsIDOMHTMLDocument.h"
 1751: #include "nsIDOMHTMLElement.h"
 6067: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMNSHTMLElement.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIFrame.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsITimer.h"
    1: #include "nsRootAccessible.h"
29018: #include "nsFocusManager.h"
 1071: #include "nsIObserverService.h"
    1: 
 2063: #ifdef MOZ_ACCESSIBILITY_ATK
 2063: #include "nsAppRootAccessible.h"
 2063: #else
 2063: #include "nsApplicationAccessibleWrap.h"
 2063: #endif
 2063: 
    1: /* For documentation of the accessibility architecture, 
    1:  * see http://lxr.mozilla.org/seamonkey/source/accessible/accessible-docs.html
    1:  */
    1: 
    1: nsIStringBundle *nsAccessNode::gStringBundle = 0;
    1: nsIStringBundle *nsAccessNode::gKeyStringBundle = 0;
    1: nsITimer *nsAccessNode::gDoCommandTimer = 0;
    1: nsIDOMNode *nsAccessNode::gLastFocusedNode = 0;
30820: #ifdef DEBUG
    1: PRBool nsAccessNode::gIsAccessibilityActive = PR_FALSE;
30820: #endif
    1: PRBool nsAccessNode::gIsCacheDisabled = PR_FALSE;
    1: PRBool nsAccessNode::gIsFormFillEnabled = PR_FALSE;
 3466: nsAccessNodeHashtable nsAccessNode::gGlobalDocAccessibleCache;
    1: 
 2063: nsApplicationAccessibleWrap *nsAccessNode::gApplicationAccessible = nsnull;
 2063: 
30820: nsIAccessibilityService*
30820: nsAccessNode::GetAccService()
    1: {
30820:   return nsAccessibilityService::GetAccessibilityService();
    1: }
    1: 
    1: /*
    1:  * Class nsAccessNode
    1:  */
    1:  
16428: ////////////////////////////////////////////////////////////////////////////////
16428: // nsAccessible. nsISupports
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_0(nsAccessNode)
16428: 
16428: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsAccessNode)
16428:   NS_INTERFACE_MAP_ENTRY(nsIAccessNode)
21169:   NS_INTERFACE_MAP_ENTRY(nsAccessNode)
16428:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIAccessNode)
16428: NS_INTERFACE_MAP_END
16428:  
16428: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsAccessNode, nsIAccessNode)
16428: NS_IMPL_CYCLE_COLLECTING_RELEASE_FULL(nsAccessNode, nsIAccessNode,
16428:                                       LastRelease())
16428: 
16428: ////////////////////////////////////////////////////////////////////////////////
16428: // nsAccessible. Constructor
    1: 
    1: nsAccessNode::nsAccessNode(nsIDOMNode *aNode, nsIWeakReference* aShell): 
    1:   mDOMNode(aNode), mWeakShell(aShell)
    1: {
    1: #ifdef DEBUG_A11Y
    1:   mIsInitialized = PR_FALSE;
    1: #endif
    1: }
    1: 
    1: //-----------------------------------------------------
    1: // destruction
    1: //-----------------------------------------------------
    1: nsAccessNode::~nsAccessNode()
    1: {
  732:   NS_ASSERTION(!mWeakShell, "LastRelease was never called!?!");
  732: }
  732: 
  732: void nsAccessNode::LastRelease()
  732: {
  732:   // First cleanup if needed...
    1:   if (mWeakShell) {
  732:     Shutdown();
  732:     NS_ASSERTION(!mWeakShell, "A Shutdown() impl forgot to call its parent's Shutdown?");
    1:   }
  732:   // ... then die.
  732:   NS_DELETEXPCOM(this);
    1: }
    1: 
21169: nsresult
21169: nsAccessNode::Init()
    1: {
    1:   // We have to put this here, instead of constructor, otherwise
    1:   // we don't have the virtual GetUniqueID() method for the hash key.
    1:   // We need that for accessibles that don't have DOM nodes
    1: 
    1: #ifdef DEBUG_A11Y
    1:   NS_ASSERTION(!mIsInitialized, "Initialized twice!");
    1: #endif
    1:   nsCOMPtr<nsIAccessibleDocument> docAccessible(GetDocAccessible());
    1:   if (!docAccessible) {
    1:     // No doc accessible yet for this node's document. 
    1:     // There was probably an accessible event fired before the 
    1:     // current document was ever asked for by the assistive technology.
    1:     // Create a doc accessible so we can cache this node
    1:     nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
    1:     if (presShell) {
    1:       nsCOMPtr<nsIDOMNode> docNode(do_QueryInterface(presShell->GetDocument()));
    1:       if (docNode) {
    1:         nsIAccessibilityService *accService = GetAccService();
    1:         if (accService) {
    1:           nsCOMPtr<nsIAccessible> accessible;
    1:           accService->GetAccessibleInShell(docNode, presShell,
    1:                                            getter_AddRefs(accessible));
    1:           docAccessible = do_QueryInterface(accessible);
    1:         }
    1:       }
    1:     }
    1:     NS_ASSERTION(docAccessible, "Cannot cache new nsAccessNode");
    1:     if (!docAccessible) {
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
 8231: 
    1:   void* uniqueID;
    1:   GetUniqueID(&uniqueID);
29564:   nsRefPtr<nsDocAccessible> docAcc =
29564:     nsAccUtils::QueryAccessibleDocument(docAccessible);
29564:   NS_ASSERTION(docAcc, "No nsDocAccessible for document accessible!");
29564:   docAcc->CacheAccessNode(uniqueID, this);
 8231: 
 8231:   // Make sure an ancestor in real content is cached
 8231:   // so that nsDocAccessible::RefreshNodes() can find the anonymous subtree to release when
 8231:   // the root node goes away
 8231:   nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);
16126:   if (content && content->IsInAnonymousSubtree()) {
 8231:     // Specific examples of where this is used: <input type="file"> and <xul:findbar>
 8231:     nsCOMPtr<nsIAccessible> parentAccessible;
 8231:     docAccessible->GetAccessibleInParentChain(mDOMNode, PR_TRUE, getter_AddRefs(parentAccessible));
 8231:     if (parentAccessible) {
 8231:       PRInt32 childCountUnused;
 8231:       parentAccessible->GetChildCount(&childCountUnused);
 8231:     }
 8231:   }
 8231: 
    1: #ifdef DEBUG_A11Y
    1:   mIsInitialized = PR_TRUE;
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
21169: nsresult
21169: nsAccessNode::Shutdown()
    1: {
    1:   mDOMNode = nsnull;
    1:   mWeakShell = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessNode::GetUniqueID(void **aUniqueID)
    1: {
 3233:   *aUniqueID = static_cast<void*>(mDOMNode);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessNode::GetOwnerWindow(void **aWindow)
    1: {
12286:   *aWindow = nsnull;
    1:   nsCOMPtr<nsIAccessibleDocument> docAccessible(GetDocAccessible());
12286:   if (!docAccessible)
12286:     return NS_ERROR_FAILURE; // This node or doc accessible is shut down
    1:   return docAccessible->GetWindowHandle(aWindow);
    1: }
    1: 
 2063: already_AddRefed<nsApplicationAccessibleWrap>
 2063: nsAccessNode::GetApplicationAccessible()
 2063: {
30820:   NS_ASSERTION(gIsAccessibilityActive, "Accessibility wasn't initialized!");
 2122: 
 2122:   if (!gApplicationAccessible) {
 2063:     nsApplicationAccessibleWrap::PreCreate();
 2063: 
 2063:     gApplicationAccessible = new nsApplicationAccessibleWrap();
 2063:     if (!gApplicationAccessible)
 2063:       return nsnull;
 2063: 
 6794:     // Addref on create. Will Release in ShutdownXPAccessibility()
 2063:     NS_ADDREF(gApplicationAccessible);
 2063: 
 2063:     nsresult rv = gApplicationAccessible->Init();
 2063:     if (NS_FAILED(rv)) {
 2063:       NS_RELEASE(gApplicationAccessible);
 6794:       gApplicationAccessible = nsnull;
 2063:       return nsnull;
 2063:     }
 2063:   }
 2063: 
 6794:   NS_ADDREF(gApplicationAccessible);   // Addref because we're a getter
 2063:   return gApplicationAccessible;
 2063: }
 2063: 
    1: void nsAccessNode::InitXPAccessibility()
    1: {
30820:   NS_ASSERTION(!gIsAccessibilityActive,
30820:                "Accessibility was initialized already!");
    1: 
    1:   nsCOMPtr<nsIStringBundleService> stringBundleService =
    1:     do_GetService(NS_STRINGBUNDLE_CONTRACTID);
    1:   if (stringBundleService) {
    1:     // Static variables are released in ShutdownAllXPAccessibility();
    1:     stringBundleService->CreateBundle(ACCESSIBLE_BUNDLE_URL, 
    1:                                       &gStringBundle);
    1:     stringBundleService->CreateBundle(PLATFORM_KEYS_BUNDLE_URL, 
    1:                                       &gKeyStringBundle);
    1:   }
    1: 
    1:   nsAccessibilityAtoms::AddRefAtoms();
    1: 
    1:   gGlobalDocAccessibleCache.Init(4);
    1: 
    1:   nsCOMPtr<nsIPrefBranch> prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID));
    1:   if (prefBranch) {
    1:     prefBranch->GetBoolPref("accessibility.disablecache", &gIsCacheDisabled);
    1:     prefBranch->GetBoolPref("browser.formfill.enable", &gIsFormFillEnabled);
    1:   }
    1: 
30820: #ifdef DEBUG
    1:   gIsAccessibilityActive = PR_TRUE;
30820: #endif
30820:   NotifyA11yInitOrShutdown(PR_TRUE);
 1071: }
 1071: 
30820: void nsAccessNode::NotifyA11yInitOrShutdown(PRBool aIsInit)
 1071: {
 1071:   nsCOMPtr<nsIObserverService> obsService =
 1071:     do_GetService("@mozilla.org/observer-service;1");
 1071:   NS_ASSERTION(obsService, "No observer service to notify of a11y init/shutdown");
 1071:   if (obsService) {
 1071:     static const PRUnichar kInitIndicator[] = { '1', 0 };
 1071:     static const PRUnichar kShutdownIndicator[] = { '0', 0 }; 
 1071:     obsService->NotifyObservers(nsnull, "a11y-init-or-shutdown",
30820:                                 aIsInit ? kInitIndicator  : kShutdownIndicator);
 1071:   }
    1: }
    1: 
    1: void nsAccessNode::ShutdownXPAccessibility()
    1: {
    1:   // Called by nsAccessibilityService::Shutdown()
    1:   // which happens when xpcom is shutting down
    1:   // at exit of program
    1: 
30820:   NS_ASSERTION(gIsAccessibilityActive, "Accessibility was shutdown already!");
12438: 
    1:   NS_IF_RELEASE(gStringBundle);
    1:   NS_IF_RELEASE(gKeyStringBundle);
    1:   NS_IF_RELEASE(gDoCommandTimer);
    1:   NS_IF_RELEASE(gLastFocusedNode);
 3149: 
 3149:   nsApplicationAccessibleWrap::Unload();
12438:   ClearCache(gGlobalDocAccessibleCache);
 6794: 
 6794:   // Release gApplicationAccessible after everything else is shutdown
 6794:   // so we don't accidently create it again while tearing down root accessibles
 2063:   NS_IF_RELEASE(gApplicationAccessible);
 6794:   gApplicationAccessible = nsnull;  
    1: 
30820: #ifdef DEBUG
    1:   gIsAccessibilityActive = PR_FALSE;
30820: #endif
30820:   NotifyA11yInitOrShutdown(PR_FALSE);
    1: }
    1: 
26291: PRBool
26291: nsAccessNode::IsDefunct()
26291: {
26291:   if (!mDOMNode)
26291:     return PR_TRUE;
26291: 
26291:   // Call GetPresShell() since the accessible may be shut down in it.
26291:   nsCOMPtr<nsIPresShell> presShell(GetPresShell());
26291:   return !presShell;
26291: }
26291: 
    1: already_AddRefed<nsIPresShell> nsAccessNode::GetPresShell()
    1: {
    1:   nsIPresShell *presShell = nsnull;
    1:   if (mWeakShell)
    1:     CallQueryReferent(mWeakShell.get(), &presShell);
    1:   if (!presShell) {
    1:     if (mWeakShell) {
    1:       // If our pres shell has died, but we're still holding onto
    1:       // a weak reference, our accessibles are no longer relevant
    1:       // and should be shut down
    1:       Shutdown();
    1:     }
    1:     return nsnull;
    1:   }
    1:   return presShell;
    1: }
    1: 
    1: nsPresContext* nsAccessNode::GetPresContext()
    1: {
    1:   nsCOMPtr<nsIPresShell> presShell(GetPresShell());
    1:   if (!presShell) {
    1:     return nsnull;
    1:   }
    1:   return presShell->GetPresContext();
    1: }
    1: 
    1: already_AddRefed<nsIAccessibleDocument> nsAccessNode::GetDocAccessible()
    1: {
    1:   return GetDocAccessibleFor(mWeakShell); // Addref'd
    1: }
    1: 
    1: already_AddRefed<nsRootAccessible> nsAccessNode::GetRootAccessible()
    1: {
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
20521:     nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
    1:   NS_ASSERTION(docShellTreeItem, "No docshell tree item for mDOMNode");
    1:   if (!docShellTreeItem) {
    1:     return nsnull;
    1:   }
    1:   nsCOMPtr<nsIDocShellTreeItem> root;
    1:   docShellTreeItem->GetRootTreeItem(getter_AddRefs(root));
    1:   NS_ASSERTION(root, "No root content tree item");
    1:   if (!root) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAccessibleDocument> accDoc = GetDocAccessibleFor(root);
    1:   if (!accDoc) {
    1:     return nsnull;
    1:   }
    1: 
    1:   // nsRootAccessible has a special QI
    1:   // that let us get that concrete type directly.
 2395:   nsRootAccessible* rootAccessible;
 2395:   accDoc->QueryInterface(NS_GET_IID(nsRootAccessible), (void**)&rootAccessible); // addrefs
 2395:   return rootAccessible;
    1: }
    1: 
21169: nsIFrame*
21169: nsAccessNode::GetFrame()
    1: {
    1:   nsCOMPtr<nsIPresShell> shell(do_QueryReferent(mWeakShell));
    1:   if (!shell) 
    1:     return nsnull;  
    1: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
 4851:   return content ? shell->GetPrimaryFrameFor(content) : nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessNode::GetDOMNode(nsIDOMNode **aNode)
    1: {
    1:   NS_IF_ADDREF(*aNode = mDOMNode);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessNode::GetNumChildren(PRInt32 *aNumChildren)
    1: {
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
    1: 
    1:   if (!content) {
    1:     *aNumChildren = 0;
    1: 
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   *aNumChildren = content->GetChildCount();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessNode::GetAccessibleDocument(nsIAccessibleDocument **aDocAccessible)
    1: {
    1:   *aDocAccessible = GetDocAccessibleFor(mWeakShell).get();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessNode::GetInnerHTML(nsAString& aInnerHTML)
    1: {
    1:   aInnerHTML.Truncate();
    1: 
    1:   nsCOMPtr<nsIDOMNSHTMLElement> domNSElement(do_QueryInterface(mDOMNode));
    1:   NS_ENSURE_TRUE(domNSElement, NS_ERROR_NULL_POINTER);
    1: 
    1:   return domNSElement->GetInnerHTML(aInnerHTML);
    1: }
    1: 
    1: NS_IMETHODIMP
  497: nsAccessNode::ScrollTo(PRUint32 aScrollType)
    1: {
13730:   if (IsDefunct())
13730:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIPresShell> shell(GetPresShell());
    1:   NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
    1: 
    1:   nsIFrame *frame = GetFrame();
    1:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIContent> content = frame->GetContent();
    1:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
    1: 
 5245:   PRInt16 vPercent, hPercent;
20521:   nsCoreUtils::ConvertScrollTypeToPercents(aScrollType, &vPercent, &hPercent);
  497:   return shell->ScrollContentIntoView(content, vPercent, hPercent);
  497: }
  497: 
  497: NS_IMETHODIMP
  497: nsAccessNode::ScrollToPoint(PRUint32 aCoordinateType, PRInt32 aX, PRInt32 aY)
  497: {
 5679:   nsIFrame *frame = GetFrame();
 5679:   if (!frame)
 5679:     return NS_ERROR_FAILURE;
 5679: 
 6286:   nsIntPoint coords;
20536:   nsresult rv = nsAccUtils::ConvertToScreenCoords(aX, aY, aCoordinateType,
 6286:                                                   this, &coords);
 6286:   NS_ENSURE_SUCCESS(rv, rv);
 5679: 
 5679:   nsIFrame *parentFrame = frame;
11383:   while ((parentFrame = parentFrame->GetParent()))
20521:     nsCoreUtils::ScrollFrameToPoint(parentFrame, frame, coords);
 5679: 
 5679:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAccessNode::MakeAccessNode(nsIDOMNode *aNode, nsIAccessNode **aAccessNode)
    1: {
20256:   *aAccessNode = nsnull;
20256:   
20247:   nsIAccessibilityService *accService = GetAccService();
20256:   NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);
    1: 
20256:   nsCOMPtr<nsIAccessNode> accessNode;
20256:   accService->GetCachedAccessNode(aNode, mWeakShell, getter_AddRefs(accessNode));
20256: 
20256:   if (!accessNode) {
    1:     nsCOMPtr<nsIAccessible> accessible;
    1:     accService->GetAccessibleInWeakShell(aNode, mWeakShell,
    1:                                          getter_AddRefs(accessible));
    1: 
20256:     accessNode = do_QueryInterface(accessible);
20256:   }
20256: 
20256:   if (accessNode) {
20256:     NS_ADDREF(*aAccessNode = accessNode);
    1:     return NS_OK;
    1:   }
    1: 
20256:   nsAccessNode *newAccessNode = new nsAccessNode(aNode, mWeakShell);
20256:   if (!newAccessNode) {
20256:     return NS_ERROR_OUT_OF_MEMORY;
20256:   }
    1: 
    1:   NS_ADDREF(*aAccessNode = newAccessNode);
20256:   newAccessNode->Init();
20256: 
20256:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessNode::GetFirstChildNode(nsIAccessNode **aAccessNode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aAccessNode);
    1:   *aAccessNode = nsnull;
    1:   NS_ENSURE_TRUE(mDOMNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> domNode;
    1:   mDOMNode->GetFirstChild(getter_AddRefs(domNode));
    1: 
    1:   return domNode ? MakeAccessNode(domNode, aAccessNode) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessNode::GetLastChildNode(nsIAccessNode **aAccessNode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aAccessNode);
    1:   *aAccessNode = nsnull;
    1:   NS_ENSURE_TRUE(mDOMNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> domNode;
    1:   mDOMNode->GetLastChild(getter_AddRefs(domNode));
    1: 
    1:   return domNode ? MakeAccessNode(domNode, aAccessNode) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessNode::GetParentNode(nsIAccessNode **aAccessNode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aAccessNode);
    1:   *aAccessNode = nsnull;
    1:   NS_ENSURE_TRUE(mDOMNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> domNode;
    1:   mDOMNode->GetParentNode(getter_AddRefs(domNode));
    1: 
    1:   return domNode ? MakeAccessNode(domNode, aAccessNode) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessNode::GetPreviousSiblingNode(nsIAccessNode **aAccessNode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aAccessNode);
    1:   *aAccessNode = nsnull;
    1:   NS_ENSURE_TRUE(mDOMNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> domNode;
    1:   mDOMNode->GetPreviousSibling(getter_AddRefs(domNode));
    1: 
    1:   return domNode ? MakeAccessNode(domNode, aAccessNode) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessNode::GetNextSiblingNode(nsIAccessNode **aAccessNode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aAccessNode);
    1:   *aAccessNode = nsnull;
    1:   NS_ENSURE_TRUE(mDOMNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> domNode;
    1:   mDOMNode->GetNextSibling(getter_AddRefs(domNode));
    1: 
    1:   return domNode ? MakeAccessNode(domNode, aAccessNode) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessNode::GetChildNodeAt(PRInt32 aChildNum, nsIAccessNode **aAccessNode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aAccessNode);
    1:   *aAccessNode = nsnull;
    1: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
    1:   NS_ENSURE_TRUE(content, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> domNode =
    1:     do_QueryInterface(content->GetChildAt(aChildNum));
    1: 
    1:   return domNode ? MakeAccessNode(domNode, aAccessNode) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
19322: nsAccessNode::GetComputedStyleValue(const nsAString& aPseudoElt,
19322:                                     const nsAString& aPropertyName,
19322:                                     nsAString& aValue)
    1: {
19322:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
19322: 
    1:   nsCOMPtr<nsIDOMCSSStyleDeclaration> styleDecl;
20566:   nsCoreUtils::GetComputedStyleDeclaration(aPseudoElt, mDOMNode,
20566:                                            getter_AddRefs(styleDecl));
    1:   NS_ENSURE_TRUE(styleDecl, NS_ERROR_FAILURE);
    1: 
    1:   return styleDecl->GetPropertyValue(aPropertyName, aValue);
    1: }
    1: 
 1509: NS_IMETHODIMP
 1509: nsAccessNode::GetComputedStyleCSSValue(const nsAString& aPseudoElt,
 1509:                                        const nsAString& aPropertyName,
 1509:                                        nsIDOMCSSPrimitiveValue **aCSSValue)
 1509: {
 1509:   NS_ENSURE_ARG_POINTER(aCSSValue);
 1509:   *aCSSValue = nsnull;
 1509: 
19322:   if (IsDefunct())
 1509:     return NS_ERROR_FAILURE;
 1509: 
 1509:   nsCOMPtr<nsIDOMCSSStyleDeclaration> styleDecl;
20566:   nsCoreUtils::GetComputedStyleDeclaration(aPseudoElt, mDOMNode,
 1509:                                            getter_AddRefs(styleDecl));
 1509:   NS_ENSURE_STATE(styleDecl);
 1509: 
 1509:   nsCOMPtr<nsIDOMCSSValue> cssValue;
 1509:   styleDecl->GetPropertyCSSValue(aPropertyName, getter_AddRefs(cssValue));
 1509:   NS_ENSURE_TRUE(cssValue, NS_ERROR_FAILURE);
 1509: 
 1509:   return CallQueryInterface(cssValue, aCSSValue);
 1509: }
 1509: 
    1: /***************** Hashtable of nsIAccessNode's *****************/
    1: 
    1: already_AddRefed<nsIAccessibleDocument>
 8471: nsAccessNode::GetDocAccessibleFor(nsIDocument *aDocument)
    1: {
 8471:   if (!aDocument) {
 8471:     return nsnull;
 8471:   }
 8471: 
    1:   nsIAccessibleDocument *docAccessible = nsnull;
    1:   nsCOMPtr<nsIAccessNode> accessNode;
 8471:   gGlobalDocAccessibleCache.Get(static_cast<void*>(aDocument),
 8471:                                 getter_AddRefs(accessNode));
    1:   if (accessNode) {
    1:     CallQueryInterface(accessNode, &docAccessible);
    1:   }
    1:   return docAccessible;
    1: }
    1:  
    1: already_AddRefed<nsIAccessibleDocument>
 8471: nsAccessNode::GetDocAccessibleFor(nsIWeakReference *aWeakShell)
 8471: {
 8471:   nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(aWeakShell));
 8471:   if (!presShell) {
 8471:     return nsnull;
 8471:   }
 8471: 
 8471:   return nsAccessNode::GetDocAccessibleFor(presShell->GetDocument());
 8471: }
 8471: 
 8471: already_AddRefed<nsIAccessibleDocument>
 8471: nsAccessNode::GetDocAccessibleFor(nsIDocShellTreeItem *aContainer,
 8471:                                   PRBool aCanCreate)
    1: {
    1:   if (!aCanCreate) {
    1:     nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(aContainer));
    1:     NS_ASSERTION(docShell, "This method currently only supports docshells");
    1:     nsCOMPtr<nsIPresShell> presShell;
    1:     docShell->GetPresShell(getter_AddRefs(presShell));
 8471:     return presShell ? GetDocAccessibleFor(presShell->GetDocument()) : nsnull;
    1:   }
    1: 
20566:   nsCOMPtr<nsIDOMNode> node = nsCoreUtils::GetDOMNodeForContainer(aContainer);
    1:   if (!node) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAccessible> accessible;
    1:   GetAccService()->GetAccessibleFor(node, getter_AddRefs(accessible));
    1:   nsIAccessibleDocument *docAccessible = nsnull;
    1:   if (accessible) {
    1:     CallQueryInterface(accessible, &docAccessible);
    1:   }
    1:   return docAccessible;
    1: }
    1:  
    1: already_AddRefed<nsIAccessibleDocument>
    1: nsAccessNode::GetDocAccessibleFor(nsIDOMNode *aNode)
    1: {
20566:   nsCOMPtr<nsIPresShell> eventShell = nsCoreUtils::GetPresShellFor(aNode);
 8471:   if (eventShell) {
 8471:     return GetDocAccessibleFor(eventShell->GetDocument());
 8471:   }
 8471: 
 8471:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(aNode));
 8471:   if (doc) {
 8471:     return GetDocAccessibleFor(doc);
 8471:   }
 8471: 
 8471:   return nsnull;
    1: }
    1: 
 3466: void
 3466: nsAccessNode::PutCacheEntry(nsAccessNodeHashtable& aCache,
    1:                             void* aUniqueID,
    1:                             nsIAccessNode *aAccessNode)
    1: {
    1: #ifdef DEBUG_A11Y
    1:   nsCOMPtr<nsIAccessNode> oldAccessNode;
    1:   GetCacheEntry(aCache, aUniqueID, getter_AddRefs(oldAccessNode));
    1:   NS_ASSERTION(!oldAccessNode, "This cache entry shouldn't exist already");
    1: #endif
    1:   aCache.Put(aUniqueID, aAccessNode);
    1: }
    1: 
 3466: void
 3466: nsAccessNode::GetCacheEntry(nsAccessNodeHashtable& aCache,
    1:                             void* aUniqueID,
    1:                             nsIAccessNode **aAccessNode)
    1: {
    1:   aCache.Get(aUniqueID, aAccessNode);  // AddRefs for us
    1: }
    1: 
    1: PLDHashOperator nsAccessNode::ClearCacheEntry(const void* aKey, nsCOMPtr<nsIAccessNode>& aAccessNode, void* aUserArg)
    1: {
15104:   NS_ASSERTION(aAccessNode, "Calling ClearCacheEntry with a NULL pointer!");
14675:   if (aAccessNode) {
21169:     nsRefPtr<nsAccessNode> accessNode =
21169:       nsAccUtils::QueryAccessNode(aAccessNode);
21169:     accessNode->Shutdown();
14675:   }
    1: 
    1:   return PL_DHASH_REMOVE;
    1: }
    1: 
 3466: void
 3466: nsAccessNode::ClearCache(nsAccessNodeHashtable& aCache)
    1: {
    1:   aCache.Enumerate(ClearCacheEntry, nsnull);
    1: }
    1: 
    1: already_AddRefed<nsIDOMNode> nsAccessNode::GetCurrentFocus()
    1: {
20566:   nsCOMPtr<nsIPresShell> shell = nsCoreUtils::GetPresShellFor(mDOMNode);
    1:   NS_ENSURE_TRUE(shell, nsnull);
    1:   nsCOMPtr<nsIDocument> doc = shell->GetDocument();
    1:   NS_ENSURE_TRUE(doc, nsnull);
    1: 
29018:   nsIDOMWindow* win = doc->GetWindow();
29018: 
29018:   nsCOMPtr<nsIDOMWindow> focusedWindow;
29018:   nsCOMPtr<nsIDOMElement> focusedElement;
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   if (fm)
29018:     fm->GetFocusedElementForWindow(win, PR_TRUE, getter_AddRefs(focusedWindow),
29018:                                    getter_AddRefs(focusedElement));
29018: 
29018:   nsIDOMNode *focusedNode = nsnull;
29018:   if (focusedElement) {
29018:     CallQueryInterface(focusedElement, &focusedNode);
    1:   }
29018:   else if (focusedWindow) {
29018:     nsCOMPtr<nsIDOMDocument> doc;
29018:     focusedWindow->GetDocument(getter_AddRefs(doc));
29018:     if (doc)
29018:       CallQueryInterface(doc, &focusedNode);
  416:   }
  416: 
    1:   return focusedNode;
    1: }
 1751: 
 1751: NS_IMETHODIMP
 1751: nsAccessNode::GetLanguage(nsAString& aLanguage)
 1751: {
 1751:   aLanguage.Truncate();
 1751:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
 1751:   if (!content) {
 1751:     // For documents make sure we look for lang attribute on
 1751:     // document element
 1751:     nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(mDOMNode));
 1751:     if (domDoc) {
 1751:       nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(mDOMNode));
 1751:       if (htmlDoc) {
 1751:         // Make sure we look for lang attribute on HTML <body>
 1751:         nsCOMPtr<nsIDOMHTMLElement> bodyElement;
 1751:         htmlDoc->GetBody(getter_AddRefs(bodyElement));
 1751:         content = do_QueryInterface(bodyElement);
 1751:       }
 1751:       if (!content) {
 1751:         nsCOMPtr<nsIDOMElement> docElement;
 1751:         domDoc->GetDocumentElement(getter_AddRefs(docElement));
 1751:         content = do_QueryInterface(docElement);
 1751:       }
 1751:     }
 1751:     if (!content) {
 1751:       return NS_ERROR_FAILURE;
 1751:     }
 1751:   }
 1751: 
20521:   nsCoreUtils::GetLanguageFor(content, nsnull, aLanguage);
 1751: 
 1751:   if (aLanguage.IsEmpty()) { // Nothing found, so use document's language
 1751:     nsIDocument *doc = content->GetOwnerDoc();
 1751:     if (doc) {
 1751:       doc->GetHeaderData(nsAccessibilityAtoms::headerContentLanguage, aLanguage);
 1751:     }
 1751:   }
 1751:  
 1751:   return NS_OK;
 1751: }
 1751: 
