 69069: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 69069: 
108973: #include <algorithm>
 69069: #include "base/histogram.h"
 91189: #include "base/pickle.h"
 69069: #include "nsIComponentManager.h"
 69069: #include "nsIServiceManager.h"
 69069: #include "nsCOMPtr.h"
 69069: #include "mozilla/ModuleUtils.h"
 69069: #include "nsIXPConnect.h"
 69069: #include "mozilla/Services.h"
 69069: #include "jsapi.h"
102741: #include "jsfriendapi.h"
 69069: #include "nsStringGlue.h"
 69069: #include "nsITelemetry.h"
 91189: #include "nsIFile.h"
 72124: #include "Telemetry.h" 
 72126: #include "nsTHashtable.h"
 72126: #include "nsHashKeys.h"
 72126: #include "nsBaseHashtable.h"
 72212: #include "nsXULAppAPI.h"
 84105: #include "nsThreadUtils.h"
108973: #include "mozilla/ProcessedStack.h"
 84105: #include "mozilla/Mutex.h"
 91189: #include "mozilla/FileUtils.h"
 93683: #include "mozilla/Preferences.h"
105673: #include "mozilla/Attributes.h"
 69069: 
 70091: namespace {
 70091: 
 69069: using namespace base;
 72124: using namespace mozilla;
 72124: 
 90012: template<class EntryType>
 90012: class AutoHashtable : public nsTHashtable<EntryType>
 90012: {
 90012: public:
 98635:   AutoHashtable(uint32_t initSize = PL_DHASH_MIN_SIZE);
 90012:   ~AutoHashtable();
 90012:   typedef bool (*ReflectEntryFunc)(EntryType *entry, JSContext *cx, JSObject *obj);
102256:   bool ReflectIntoJS(ReflectEntryFunc entryFunc, JSContext *cx, JSObject *obj);
 90012: private:
 90012:   struct EnumeratorArgs {
 90012:     JSContext *cx;
 90012:     JSObject *obj;
 90012:     ReflectEntryFunc entryFunc;
 90012:   };
 90012:   static PLDHashOperator ReflectEntryStub(EntryType *entry, void *arg);
 90012: };
 90012: 
 90012: template<class EntryType>
 98635: AutoHashtable<EntryType>::AutoHashtable(uint32_t initSize)
 90012: {
 90012:   this->Init(initSize);
 90012: }
 90012: 
 90012: template<class EntryType>
 90012: AutoHashtable<EntryType>::~AutoHashtable()
 90012: {
 90012:   this->Clear();
 90012: }
 90012: 
 90012: template<typename EntryType>
 90012: PLDHashOperator
 90012: AutoHashtable<EntryType>::ReflectEntryStub(EntryType *entry, void *arg)
 90012: {
 90012:   EnumeratorArgs *args = static_cast<EnumeratorArgs *>(arg);
 90012:   if (!args->entryFunc(entry, args->cx, args->obj)) {
 90012:     return PL_DHASH_STOP;
 90012:   }
 90012:   return PL_DHASH_NEXT;
 90012: }
 90012: 
 90012: /**
 90012:  * Reflect the individual entries of table into JS, usually by defining
 90012:  * some property and value of obj.  entryFunc is called for each entry.
 90012:  */
 90012: template<typename EntryType>
 90012: bool
102256: AutoHashtable<EntryType>::ReflectIntoJS(ReflectEntryFunc entryFunc,
 90012:                                         JSContext *cx, JSObject *obj)
 90012: {
 90012:   EnumeratorArgs args = { cx, obj, entryFunc };
 98635:   uint32_t num = this->EnumerateEntries(ReflectEntryStub, static_cast<void*>(&args));
 90012:   return num == this->Count();
 90012: }
 90012: 
105673: class TelemetryImpl MOZ_FINAL : public nsITelemetry
 69069: {
 69069:   NS_DECL_ISUPPORTS
 69069:   NS_DECL_NSITELEMETRY
 69069: 
 69069: public:
 72126:   TelemetryImpl();
 72126:   ~TelemetryImpl();
 72124:   
 72661:   static bool CanRecord();
 72661:   static already_AddRefed<nsITelemetry> CreateTelemetryInstance();
 72661:   static void ShutdownTelemetry();
 93683:   static void RecordSlowStatement(const nsACString &sql, const nsACString &dbName,
108952:                                   uint32_t delay);
 93170: #if defined(MOZ_ENABLE_PROFILER_SPS)
 98635:   static void RecordChromeHang(uint32_t duration,
108973:                                Telemetry::ProcessedStack &aStack);
 93170: #endif
 87400:   static nsresult GetHistogramEnumId(const char *name, Telemetry::ID *id);
108952:   struct Stat {
 98635:     uint32_t hitCount;
 98635:     uint32_t totalTime;
108952:   };
108952:   struct StmtStats {
108952:     struct Stat mainThread;
108952:     struct Stat otherThreads;
 84105:   };
 84105:   typedef nsBaseHashtableET<nsCStringHashKey, StmtStats> SlowSQLEntryType;
 92058:   struct HangReport {
 98635:     uint32_t duration;
108973:     Telemetry::ProcessedStack mStack;
 92058:   };
 72661: 
 72124: private:
108952:   static nsCString SanitizeSQL(const nsACString& sql);
108952: 
108952:   enum SanitizedState { Sanitized, Unsanitized };
108952: 
 98635:   static void StoreSlowSQL(const nsACString &offender, uint32_t delay,
108952:                            SanitizedState state);
 93683: 
108952:   static bool ReflectMainThreadSQL(SlowSQLEntryType *entry, JSContext *cx,
 90012:                                    JSObject *obj);
108952:   static bool ReflectOtherThreadsSQL(SlowSQLEntryType *entry, JSContext *cx,
 93683:                                      JSObject *obj);
108952:   static bool ReflectSQL(const SlowSQLEntryType *entry, const Stat *stat,
108952:                          JSContext *cx, JSObject *obj);
 93683: 
 93683:   bool AddSQLInfo(JSContext *cx, JSObject *rootObj, bool mainThread,
108952:                   bool privateSQL);
 93683:   bool GetSQLStats(JSContext *cx, jsval *ret, bool includePrivateSql);
 84105: 
 86778:   // Like GetHistogramById, but returns the underlying C++ object, not the JS one.
 86778:   nsresult GetHistogramByName(const nsACString &name, Histogram **ret);
 87400:   bool ShouldReflectHistogram(Histogram *h);
 87400:   void IdentifyCorruptHistograms(StatisticsRecorder::Histograms &hs);
 87400:   typedef StatisticsRecorder::Histograms::iterator HistogramIterator;
 90274: 
 90274:   struct AddonHistogramInfo {
 98635:     uint32_t min;
 98635:     uint32_t max;
 98635:     uint32_t bucketCount;
 98635:     uint32_t histogramType;
 90274:     Histogram *h;
 90274:   };
 90274:   typedef nsBaseHashtableET<nsCStringHashKey, AddonHistogramInfo> AddonHistogramEntryType;
 90274:   typedef AutoHashtable<AddonHistogramEntryType> AddonHistogramMapType;
 90274:   typedef nsBaseHashtableET<nsCStringHashKey, AddonHistogramMapType *> AddonEntryType;
 90274:   typedef AutoHashtable<AddonEntryType> AddonMapType;
 90274:   static bool AddonHistogramReflector(AddonHistogramEntryType *entry,
 90274:                                       JSContext *cx, JSObject *obj);
 90274:   static bool AddonReflector(AddonEntryType *entry, JSContext *cx, JSObject *obj);
 91744:   static bool CreateHistogramForAddon(const nsACString &name,
 91744:                                       AddonHistogramInfo &info);
 90274:   AddonMapType mAddonMap;
 90274: 
 87400:   // This is used for speedy string->Telemetry::ID conversions
 72126:   typedef nsBaseHashtableET<nsCharPtrHashKey, Telemetry::ID> CharPtrEntryType;
 90012:   typedef AutoHashtable<CharPtrEntryType> HistogramMapType;
 72126:   HistogramMapType mHistogramMap;
 72661:   bool mCanRecord;
 72661:   static TelemetryImpl *sTelemetry;
108952:   AutoHashtable<SlowSQLEntryType> mPrivateSQL;
108952:   AutoHashtable<SlowSQLEntryType> mSanitizedSQL;
 90012:   // This gets marked immutable in debug builds, so we can't use
 90012:   // AutoHashtable here.
 84105:   nsTHashtable<nsCStringHashKey> mTrackedDBs;
 84105:   Mutex mHashMutex;
 92058:   nsTArray<HangReport> mHangReports;
 92058:   Mutex mHangReportsMutex;
 69069: };
 69069: 
 72661: TelemetryImpl*  TelemetryImpl::sTelemetry = NULL;
 72661: 
 70091: // A initializer to initialize histogram collection
 70091: StatisticsRecorder gStatisticsRecorder;
 69069: 
 72124: // Hardcoded probes
 72124: struct TelemetryHistogram {
 98635:   uint32_t min;
 98635:   uint32_t max;
 98635:   uint32_t bucketCount;
 98635:   uint32_t histogramType;
110665:   uint16_t id_offset;
110665:   uint16_t comment_offset;
110665: 
110665:   const char *id() const;
110665:   const char *comment() const;
 72124: };
 72124: 
109326: #include "TelemetryHistogramData.inc"
 87400: bool gCorruptHistograms[Telemetry::HistogramCount];
 72124: 
110665: const char *
110665: TelemetryHistogram::id() const
110665: {
110665:   return &gHistogramStringTable[this->id_offset];
110665: }
110665: 
110665: const char *
110665: TelemetryHistogram::comment() const
110665: {
110665:   return &gHistogramStringTable[this->comment_offset];
110665: }
110665: 
 86779: bool
 98635: TelemetryHistogramType(Histogram *h, uint32_t *result)
 86779: {
 86779:   switch (h->histogram_type()) {
 86779:   case Histogram::HISTOGRAM:
 86779:     *result = nsITelemetry::HISTOGRAM_EXPONENTIAL;
 86779:     break;
 86779:   case Histogram::LINEAR_HISTOGRAM:
 86779:     *result = nsITelemetry::HISTOGRAM_LINEAR;
 86779:     break;
 86779:   case Histogram::BOOLEAN_HISTOGRAM:
 86779:     *result = nsITelemetry::HISTOGRAM_BOOLEAN;
 86779:     break;
 91744:   case Histogram::FLAG_HISTOGRAM:
 91744:     *result = nsITelemetry::HISTOGRAM_FLAG;
 97008:     break;
 86779:   default:
 86779:     return false;
 86779:   }
 86779:   return true;
 86779: }
 86779: 
 72124: nsresult
 98635: HistogramGet(const char *name, uint32_t min, uint32_t max, uint32_t bucketCount,
 98635:              uint32_t histogramType, Histogram **result)
 72124: {
 91744:   if (histogramType != nsITelemetry::HISTOGRAM_BOOLEAN
 91744:       && histogramType != nsITelemetry::HISTOGRAM_FLAG) {
 72124:     // Sanity checks for histogram parameters.
 72124:     if (min >= max)
 72124:       return NS_ERROR_ILLEGAL_VALUE;
 72124: 
 72124:     if (bucketCount <= 2)
 72124:       return NS_ERROR_ILLEGAL_VALUE;
 72124: 
 72124:     if (min < 1)
 72124:       return NS_ERROR_ILLEGAL_VALUE;
 72124:   }
 72124: 
 72124:   switch (histogramType) {
 72124:   case nsITelemetry::HISTOGRAM_EXPONENTIAL:
 72874:     *result = Histogram::FactoryGet(name, min, max, bucketCount, Histogram::kUmaTargetedHistogramFlag);
 72124:     break;
 72124:   case nsITelemetry::HISTOGRAM_LINEAR:
 72874:     *result = LinearHistogram::FactoryGet(name, min, max, bucketCount, Histogram::kUmaTargetedHistogramFlag);
 72124:     break;
 72124:   case nsITelemetry::HISTOGRAM_BOOLEAN:
 72874:     *result = BooleanHistogram::FactoryGet(name, Histogram::kUmaTargetedHistogramFlag);
 72124:     break;
 91744:   case nsITelemetry::HISTOGRAM_FLAG:
 91744:     *result = FlagHistogram::FactoryGet(name, Histogram::kUmaTargetedHistogramFlag);
 91744:     break;
 72124:   default:
 72124:     return NS_ERROR_INVALID_ARG;
 72124:   }
 72124:   return NS_OK;
 72124: }
 72124: 
 72124: // O(1) histogram lookup by numeric id
 72124: nsresult
 72124: GetHistogramByEnumId(Telemetry::ID id, Histogram **ret)
 72124: {
 72124:   static Histogram* knownHistograms[Telemetry::HistogramCount] = {0};
 72124:   Histogram *h = knownHistograms[id];
 72124:   if (h) {
 72124:     *ret = h;
 72124:     return NS_OK;
 72124:   }
 72124: 
 72124:   const TelemetryHistogram &p = gHistograms[id];
110665:   nsresult rv = HistogramGet(p.id(), p.min, p.max, p.bucketCount, p.histogramType, &h);
 72124:   if (NS_FAILED(rv))
 78066:     return rv;
 72124: 
110534: #ifdef DEBUG
110534:   // Check that the C++ Histogram code computes the same ranges as the
110534:   // Python histogram code.
110534:   const struct bounds &b = gBucketLowerBoundIndex[id];
110534:   if (b.length != 0) {
110534:     MOZ_ASSERT(size_t(b.length) == h->bucket_count(),
110534:                "C++/Python bucket # mismatch");
110534:     for (int i = 0; i < b.length; ++i) {
110534:       MOZ_ASSERT(gBucketLowerBounds[b.offset + i] == h->ranges(i),
110534:                  "C++/Python bucket mismatch");
110534:     }
110534:   }
110534: #endif
110534: 
 72124:   *ret = knownHistograms[id] = h;
 72124:   return NS_OK;
 72124: }
 72124: 
 70091: bool
 69069: FillRanges(JSContext *cx, JSObject *array, Histogram *h)
 69069: {
 69069:   for (size_t i = 0; i < h->bucket_count(); i++) {
 69069:     if (!JS_DefineElement(cx, array, i, INT_TO_JSVAL(h->ranges(i)), NULL, NULL, JSPROP_ENUMERATE))
 69069:       return false;
 69069:   }
 69069:   return true;
 69069: }
 69069: 
 87400: enum reflectStatus {
 87400:   REFLECT_OK,
 87400:   REFLECT_CORRUPT,
 87400:   REFLECT_FAILURE
 87400: };
 87400: 
 87400: enum reflectStatus
 91188: ReflectHistogramAndSamples(JSContext *cx, JSObject *obj, Histogram *h,
 91188:                            const Histogram::SampleSet &ss)
 69069: {
 87400:   // We don't want to reflect corrupt histograms.
 87400:   if (h->FindCorruption(ss) != Histogram::NO_INCONSISTENCIES) {
 87400:     return REFLECT_CORRUPT;
 87400:   }
 87400: 
 91402:   if (!(JS_DefineProperty(cx, obj, "min", INT_TO_JSVAL(h->declared_min()), NULL, NULL, JSPROP_ENUMERATE)
 69069:         && JS_DefineProperty(cx, obj, "max", INT_TO_JSVAL(h->declared_max()), NULL, NULL, JSPROP_ENUMERATE)
 69069:         && JS_DefineProperty(cx, obj, "histogram_type", INT_TO_JSVAL(h->histogram_type()), NULL, NULL, JSPROP_ENUMERATE)
 91449:         && JS_DefineProperty(cx, obj, "sum", DOUBLE_TO_JSVAL(ss.sum()), NULL, NULL, JSPROP_ENUMERATE))) {
 91449:     return REFLECT_FAILURE;
 91449:   }
 91449: 
 91449:   const size_t count = h->bucket_count();
106838:   JSObject *rarray = JS_NewArrayObject(cx, count, nullptr);
 91449:   if (!rarray) {
 91449:     return REFLECT_FAILURE;
 91449:   }
 91449:   JS::AutoObjectRooter aroot(cx, rarray);
 91449:   if (!(FillRanges(cx, rarray, h)
 91449:         && JS_DefineProperty(cx, obj, "ranges", OBJECT_TO_JSVAL(rarray),
 91449:                              NULL, NULL, JSPROP_ENUMERATE))) {
 91449:     return REFLECT_FAILURE;
 91449:   }
 91449: 
 91449:   JSObject *counts_array = JS_NewArrayObject(cx, count, NULL);
 91449:   if (!counts_array) {
 91449:     return REFLECT_FAILURE;
 91449:   }
 91449:   JS::AutoObjectRooter croot(cx, counts_array);
 91449:   if (!JS_DefineProperty(cx, obj, "counts", OBJECT_TO_JSVAL(counts_array),
 91449:                          NULL, NULL, JSPROP_ENUMERATE)) {
 87400:     return REFLECT_FAILURE;
 69069:   }
 69069:   for (size_t i = 0; i < count; i++) {
 91449:     if (!JS_DefineElement(cx, counts_array, i, INT_TO_JSVAL(ss.counts(i)),
 91449:                           NULL, NULL, JSPROP_ENUMERATE)) {
 87400:       return REFLECT_FAILURE;
 69069:     }
 69069:   }
 91449:  
 87400:   return REFLECT_OK;
 69069: }
 69069: 
 91188: enum reflectStatus
 91188: ReflectHistogramSnapshot(JSContext *cx, JSObject *obj, Histogram *h)
 91188: {
 91188:   Histogram::SampleSet ss;
 91188:   h->SnapshotSample(&ss);
 91188:   return ReflectHistogramAndSamples(cx, obj, h, ss);
 91188: }
 91188: 
 98132: bool
 98132: IsEmpty(const Histogram *h)
 98132: {
 98132:   Histogram::SampleSet ss;
 98132:   h->SnapshotSample(&ss);
 98132: 
 98132:   return ss.counts(0) == 0 && ss.sum() == 0;
 98132: }
 98132: 
 70091: JSBool
 91237: JSHistogram_Add(JSContext *cx, unsigned argc, jsval *vp)
 69069: {
 72659:   if (!argc) {
 72659:     JS_ReportError(cx, "Expected one argument");
 69069:     return JS_FALSE;
 72659:   }
 72659: 
 72659:   jsval v = JS_ARGV(cx, vp)[0];
 72659: 
 72659:   if (!(JSVAL_IS_NUMBER(v) || JSVAL_IS_BOOLEAN(v))) {
 72659:     JS_ReportError(cx, "Not a number");
 69069:     return JS_FALSE;
 72659:   }
 72659: 
101117:   int32_t value;
 72659:   if (!JS_ValueToECMAInt32(cx, v, &value)) {
 72659:     return JS_FALSE;
 72659:   }
 72659: 
 72661:   if (TelemetryImpl::CanRecord()) {
 69069:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
 83114:     if (!obj) {
 83114:       return JS_FALSE;
 83114:     }
 83114: 
 89826:     Histogram *h = static_cast<Histogram*>(JS_GetPrivate(obj));
 72124:     if (h->histogram_type() == Histogram::BOOLEAN_HISTOGRAM)
 72124:       h->Add(!!value);
 72124:     else
 72124:       h->Add(value);
 72661:   }
 69069:   return JS_TRUE;
 69069: }
 69069: 
 70091: JSBool
 91237: JSHistogram_Snapshot(JSContext *cx, unsigned argc, jsval *vp)
 69069: {
 69069:   JSObject *obj = JS_THIS_OBJECT(cx, vp);
 83114:   if (!obj) {
 83114:     return JS_FALSE;
 83114:   }
 83114: 
 89826:   Histogram *h = static_cast<Histogram*>(JS_GetPrivate(obj));
106838:   JSObject *snapshot = JS_NewObject(cx, nullptr, nullptr, nullptr);
 69069:   if (!snapshot)
 74342:     return JS_FALSE;
 91449:   JS::AutoObjectRooter sroot(cx, snapshot);
 87400: 
 87400:   switch (ReflectHistogramSnapshot(cx, snapshot, h)) {
 87400:   case REFLECT_FAILURE:
 87400:     return JS_FALSE;
 87400:   case REFLECT_CORRUPT:
 87400:     JS_ReportError(cx, "Histogram is corrupt");
 87400:     return JS_FALSE;
 87400:   case REFLECT_OK:
 69069:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(snapshot));
 87400:     return JS_TRUE;
 87400:   default:
 87400:     MOZ_NOT_REACHED("unhandled reflection status");
 87400:     return JS_FALSE;
 87400:   }
 69069: }
 69069: 
 98123: JSBool
 98123: JSHistogram_Clear(JSContext *cx, unsigned argc, jsval *vp)
 98123: {
 98123:   JSObject *obj = JS_THIS_OBJECT(cx, vp);
 98123:   if (!obj) {
 98123:     return JS_FALSE;
 98123:   }
 98123: 
 98123:   Histogram *h = static_cast<Histogram*>(JS_GetPrivate(obj));
 98123:   h->Clear();
 98123:   return JS_TRUE;
 98123: }
 98123: 
 70091: nsresult 
 69069: WrapAndReturnHistogram(Histogram *h, JSContext *cx, jsval *ret)
 69069: {
 69069:   static JSClass JSHistogram_class = {
 69069:     "JSHistogram",  /* name */
 69069:     JSCLASS_HAS_PRIVATE, /* flags */
 69069:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
 93519:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub
 69069:   };
 69069: 
 69069:   JSObject *obj = JS_NewObject(cx, &JSHistogram_class, NULL, NULL);
 69069:   if (!obj)
 69069:     return NS_ERROR_FAILURE;
 91449:   JS::AutoObjectRooter root(cx, obj);
 91449:   if (!(JS_DefineFunction(cx, obj, "add", JSHistogram_Add, 1, 0)
 98123:         && JS_DefineFunction(cx, obj, "snapshot", JSHistogram_Snapshot, 0, 0)
 98123:         && JS_DefineFunction(cx, obj, "clear", JSHistogram_Clear, 0, 0))) {
 91449:     return NS_ERROR_FAILURE;
 91449:   }
 69069:   *ret = OBJECT_TO_JSVAL(obj);
 89826:   JS_SetPrivate(obj, h);
 91449:   return NS_OK;
 69069: }
 69069: 
 72661: TelemetryImpl::TelemetryImpl():
 90012: mHistogramMap(Telemetry::HistogramCount),
 84105: mCanRecord(XRE_GetProcessType() == GeckoProcessType_Default),
 92058: mHashMutex("Telemetry::mHashMutex"),
 92058: mHangReportsMutex("Telemetry::mHangReportsMutex")
 72661: {
 84105:   // A whitelist to prevent Telemetry reporting on Addon & Thunderbird DBs
 84105:   const char *trackedDBs[] = {
 84105:     "addons.sqlite", "chromeappsstore.sqlite", "content-prefs.sqlite",
 84105:     "cookies.sqlite", "downloads.sqlite", "extensions.sqlite",
 84105:     "formhistory.sqlite", "index.sqlite", "permissions.sqlite", "places.sqlite",
 84105:     "search.sqlite", "signons.sqlite", "urlclassifier3.sqlite",
 84105:     "webappsstore.sqlite"
 84105:   };
 84105: 
 84105:   mTrackedDBs.Init();
 87070:   for (size_t i = 0; i < ArrayLength(trackedDBs); i++)
 84105:     mTrackedDBs.PutEntry(nsDependentCString(trackedDBs[i]));
 84105: 
 86968: #ifdef DEBUG
 86968:   // Mark immutable to prevent asserts on simultaneous access from multiple threads
 86968:   mTrackedDBs.MarkImmutable();
 86968: #endif
 72126: }
 72126: 
 72126: TelemetryImpl::~TelemetryImpl() {
 72126: }
 72126: 
 70239: NS_IMETHODIMP
 98635: TelemetryImpl::NewHistogram(const nsACString &name, uint32_t min, uint32_t max, uint32_t bucketCount, uint32_t histogramType, JSContext *cx, jsval *ret)
 69069: {
 70239:   Histogram *h;
 72124:   nsresult rv = HistogramGet(PromiseFlatCString(name).get(), min, max, bucketCount, histogramType, &h);
 72124:   if (NS_FAILED(rv))
 72124:     return rv;
 72874:   h->ClearFlags(Histogram::kUmaTargetedHistogramFlag);
 69069:   return WrapAndReturnHistogram(h, cx, ret);
 69069: }
 69069: 
 90012: bool
108952: TelemetryImpl::ReflectSQL(const SlowSQLEntryType *entry,
108952:                           const Stat *stat,
108952:                           JSContext *cx,
108952:                           JSObject *obj)
 84105: {
108952:   if (stat->hitCount == 0)
108952:     return true;
108952: 
 84578:   const nsACString &sql = entry->GetKey();
108952:   jsval hitCount = UINT_TO_JSVAL(stat->hitCount);
108952:   jsval totalTime = UINT_TO_JSVAL(stat->totalTime);
 84105: 
106838:   JSObject *arrayObj = JS_NewArrayObject(cx, 0, nullptr);
 91449:   if (!arrayObj) {
 91449:     return false;
 91449:   }
 91449:   JS::AutoObjectRooter root(cx, arrayObj);
 91449:   return (JS_SetElement(cx, arrayObj, 0, &hitCount)
 90012:           && JS_SetElement(cx, arrayObj, 1, &totalTime)
 90012:           && JS_DefineProperty(cx, obj,
 84578:                                sql.BeginReading(),
 84578:                                OBJECT_TO_JSVAL(arrayObj),
 90012:                                NULL, NULL, JSPROP_ENUMERATE));
 84105: }
 84105: 
 84105: bool
108952: TelemetryImpl::ReflectMainThreadSQL(SlowSQLEntryType *entry, JSContext *cx,
 93683:                                     JSObject *obj)
 93683: {
108952:   return ReflectSQL(entry, &entry->mData.mainThread, cx, obj);
 93683: }
 93683: 
 93683: bool
108952: TelemetryImpl::ReflectOtherThreadsSQL(SlowSQLEntryType *entry, JSContext *cx,
 93683:                                       JSObject *obj)
 93683: {
108952:   return ReflectSQL(entry, &entry->mData.otherThreads, cx, obj);
 93683: }
 93683: 
 93683: bool
 93683: TelemetryImpl::AddSQLInfo(JSContext *cx, JSObject *rootObj, bool mainThread,
108952:                           bool privateSQL)
 84105: {
 84105:   JSObject *statsObj = JS_NewObject(cx, NULL, NULL, NULL);
 84578:   if (!statsObj)
 84105:     return false;
 91449:   JS::AutoObjectRooter root(cx, statsObj);
 84105: 
 93683:   AutoHashtable<SlowSQLEntryType> &sqlMap =
108952:     (privateSQL ? mPrivateSQL : mSanitizedSQL);
 93683:   AutoHashtable<SlowSQLEntryType>::ReflectEntryFunc reflectFunction =
108952:     (mainThread ? ReflectMainThreadSQL : ReflectOtherThreadsSQL);
102256:   if(!sqlMap.ReflectIntoJS(reflectFunction, cx, statsObj)) {
 91449:     return false;
 91449:   }
 91449: 
 91449:   return JS_DefineProperty(cx, rootObj,
 91449:                            mainThread ? "mainThread" : "otherThreads",
 91449:                            OBJECT_TO_JSVAL(statsObj),
 91449:                            NULL, NULL, JSPROP_ENUMERATE);
 84105: }
 84105: 
 87399: nsresult
 87399: TelemetryImpl::GetHistogramEnumId(const char *name, Telemetry::ID *id)
 87399: {
 87399:   if (!sTelemetry) {
 87399:     return NS_ERROR_FAILURE;
 87399:   }
 87399: 
 87399:   // Cache names
 87399:   // Note the histogram names are statically allocated
 87399:   TelemetryImpl::HistogramMapType *map = &sTelemetry->mHistogramMap;
 87399:   if (!map->Count()) {
 98635:     for (uint32_t i = 0; i < Telemetry::HistogramCount; i++) {
110665:       CharPtrEntryType *entry = map->PutEntry(gHistograms[i].id());
 87399:       if (NS_UNLIKELY(!entry)) {
 87399:         map->Clear();
 87399:         return NS_ERROR_OUT_OF_MEMORY;
 87399:       }
 87399:       entry->mData = (Telemetry::ID) i;
 87399:     }
 87399:   }
 87399: 
 87399:   CharPtrEntryType *entry = map->GetEntry(name);
 87399:   if (!entry) {
 87399:     return NS_ERROR_INVALID_ARG;
 87399:   }
 87399:   *id = entry->mData;
 87399:   return NS_OK;
 87399: }
 87249: 
 87243: nsresult
 87249: TelemetryImpl::GetHistogramByName(const nsACString &name, Histogram **ret)
 87243: {
 87399:   Telemetry::ID id;
 87399:   nsresult rv = GetHistogramEnumId(PromiseFlatCString(name).get(), &id);
 87399:   if (NS_FAILED(rv)) {
 87399:     return rv;
 87243:   }
 87243: 
 87399:   rv = GetHistogramByEnumId(id, ret);
 86778:   if (NS_FAILED(rv))
 86778:     return rv;
 86778: 
 86778:   return NS_OK;
 86778: }
 86778: 
 84135: NS_IMETHODIMP
 86779: TelemetryImpl::HistogramFrom(const nsACString &name, const nsACString &existing_name,
 86779:                              JSContext *cx, jsval *ret)
 86779: {
 86779:   Histogram *existing;
 86779:   nsresult rv = GetHistogramByName(existing_name, &existing);
 86779:   if (NS_FAILED(rv))
 86779:     return rv;
 86779: 
 98635:   uint32_t histogramType;
 86779:   bool success = TelemetryHistogramType(existing, &histogramType);
 86779:   if (!success)
 86779:     return NS_ERROR_INVALID_ARG;
 86779: 
 86779:   Histogram *clone;
 86779:   rv = HistogramGet(PromiseFlatCString(name).get(), existing->declared_min(),
 86779:                     existing->declared_max(), existing->bucket_count(),
 86779:                     histogramType, &clone);
 86779:   if (NS_FAILED(rv))
 86779:     return rv;
 86779: 
 86779:   Histogram::SampleSet ss;
 86779:   existing->SnapshotSample(&ss);
 86779:   clone->AddSampleSet(ss);
 86779:   return WrapAndReturnHistogram(clone, cx, ret);
 86779: }
 86779: 
 87400: void
 87400: TelemetryImpl::IdentifyCorruptHistograms(StatisticsRecorder::Histograms &hs)
 87400: {
 87400:   for (HistogramIterator it = hs.begin(); it != hs.end(); ++it) {
 87400:     Histogram *h = *it;
 87400: 
 87400:     Telemetry::ID id;
 87400:     nsresult rv = GetHistogramEnumId(h->histogram_name().c_str(), &id);
 87400:     // This histogram isn't a static histogram, just ignore it.
 87400:     if (NS_FAILED(rv)) {
 87400:       continue;
 87400:     }
 87400: 
 87400:     if (gCorruptHistograms[id]) {
 87400:       continue;
 87400:     }
 87400: 
 87400:     Histogram::SampleSet ss;
 87400:     h->SnapshotSample(&ss);
 87400:     Histogram::Inconsistencies check = h->FindCorruption(ss);
 87400:     bool corrupt = (check != Histogram::NO_INCONSISTENCIES);
 87400: 
 87400:     if (corrupt) {
 87400:       Telemetry::ID corruptID = Telemetry::HistogramCount;
 87400:       if (check & Histogram::RANGE_CHECKSUM_ERROR) {
 87400:         corruptID = Telemetry::RANGE_CHECKSUM_ERRORS;
 87400:       } else if (check & Histogram::BUCKET_ORDER_ERROR) {
 87400:         corruptID = Telemetry::BUCKET_ORDER_ERRORS;
 87400:       } else if (check & Histogram::COUNT_HIGH_ERROR) {
 87400:         corruptID = Telemetry::TOTAL_COUNT_HIGH_ERRORS;
 87400:       } else if (check & Histogram::COUNT_LOW_ERROR) {
 87400:         corruptID = Telemetry::TOTAL_COUNT_LOW_ERRORS;
 87400:       }
 87400:       Telemetry::Accumulate(corruptID, 1);
 87400:     }
 87400: 
 87400:     gCorruptHistograms[id] = corrupt;
 87400:   }
 87400: }
 87400: 
 87400: bool
 87400: TelemetryImpl::ShouldReflectHistogram(Histogram *h)
 87400: {
 87400:   const char *name = h->histogram_name().c_str();
 87400:   Telemetry::ID id;
 87400:   nsresult rv = GetHistogramEnumId(name, &id);
 87400:   if (NS_FAILED(rv)) {
 87400:     // GetHistogramEnumId generally should not fail.  But a lookup
 87400:     // failure shouldn't prevent us from reflecting histograms into JS.
 87400:     //
 87400:     // However, these two histograms are created by Histogram itself for
 87400:     // tracking corruption.  We have our own histograms for that, so
 87400:     // ignore these two.
 87400:     if (strcmp(name, "Histogram.InconsistentCountHigh") == 0
 87400:         || strcmp(name, "Histogram.InconsistentCountLow") == 0) {
 87400:       return false;
 87400:     }
 87400:     return true;
 87400:   } else {
 87400:     return !gCorruptHistograms[id];
 87400:   }
 87400: }
 87400: 
 90274: // Compute the name to pass into Histogram for the addon histogram
 90274: // 'name' from the addon 'id'.  We can't use 'name' directly because it
 90274: // might conflict with other histograms in other addons or even with our
 90274: // own.
 90274: void
 90274: AddonHistogramName(const nsACString &id, const nsACString &name,
 90274:                    nsACString &ret)
 90274: {
 90274:   ret.Append(id);
 90274:   ret.Append(NS_LITERAL_CSTRING(":"));
 90274:   ret.Append(name);
 90274: }
 90274: 
 90274: NS_IMETHODIMP
 90274: TelemetryImpl::RegisterAddonHistogram(const nsACString &id,
 90274:                                       const nsACString &name,
 98635:                                       uint32_t min, uint32_t max,
 98635:                                       uint32_t bucketCount,
 98635:                                       uint32_t histogramType)
 90274: {
 90274:   AddonEntryType *addonEntry = mAddonMap.GetEntry(id);
 90274:   if (!addonEntry) {
 90274:     addonEntry = mAddonMap.PutEntry(id);
 90274:     if (NS_UNLIKELY(!addonEntry)) {
 90274:       return NS_ERROR_OUT_OF_MEMORY;
 90274:     }
 90274:     addonEntry->mData = new AddonHistogramMapType();
 90274:   }
 90274: 
 90274:   AddonHistogramMapType *histogramMap = addonEntry->mData;
 90274:   AddonHistogramEntryType *histogramEntry = histogramMap->GetEntry(name);
 90274:   // Can't re-register the same histogram.
 90274:   if (histogramEntry) {
 90274:     return NS_ERROR_FAILURE;
 90274:   }
 90274: 
 90274:   histogramEntry = histogramMap->PutEntry(name);
 90274:   if (NS_UNLIKELY(!histogramEntry)) {
 90274:     return NS_ERROR_OUT_OF_MEMORY;
 90274:   }
 90274: 
 90274:   AddonHistogramInfo &info = histogramEntry->mData;
 90274:   info.min = min;
 90274:   info.max = max;
 90274:   info.bucketCount = bucketCount;
 90274:   info.histogramType = histogramType;
 90274: 
 90274:   return NS_OK;
 90274: }
 90274: 
 90274: NS_IMETHODIMP
 90274: TelemetryImpl::GetAddonHistogram(const nsACString &id, const nsACString &name,
 90274:                                  JSContext *cx, jsval *ret)
 90274: {
 90274:   AddonEntryType *addonEntry = mAddonMap.GetEntry(id);
 90274:   // The given id has not been registered.
 90274:   if (!addonEntry) {
 90274:     return NS_ERROR_INVALID_ARG;
 90274:   }
 90274: 
 90274:   AddonHistogramMapType *histogramMap = addonEntry->mData;
 90274:   AddonHistogramEntryType *histogramEntry = histogramMap->GetEntry(name);
 90274:   // The given histogram name has not been registered.
 90274:   if (!histogramEntry) {
 90274:     return NS_ERROR_INVALID_ARG;
 90274:   }
 90274: 
 90274:   AddonHistogramInfo &info = histogramEntry->mData;
 91744:   if (!info.h) {
 90274:     nsCAutoString actualName;
 90274:     AddonHistogramName(id, name, actualName);
 91744:     if (!CreateHistogramForAddon(actualName, info)) {
 91744:       return NS_ERROR_FAILURE;
 90274:     }
 90274:   }
 91744:   return WrapAndReturnHistogram(info.h, cx, ret);
 90274: }
 90274: 
 90274: NS_IMETHODIMP
 90274: TelemetryImpl::UnregisterAddonHistograms(const nsACString &id)
 90274: {
 90274:   AddonEntryType *addonEntry = mAddonMap.GetEntry(id);
 90274:   if (addonEntry) {
 90274:     // Histogram's destructor is private, so this is the best we can do.
 90274:     // The histograms the addon created *will* stick around, but they
 90274:     // will be deleted if and when the addon registers histograms with
 90274:     // the same names.
 90274:     delete addonEntry->mData;
 90274:     mAddonMap.RemoveEntry(id);
 90274:   }
 90274: 
 90274:   return NS_OK;
 90274: }
 90274: 
 86779: NS_IMETHODIMP
 72124: TelemetryImpl::GetHistogramSnapshots(JSContext *cx, jsval *ret)
 69069: {
 69069:   JSObject *root_obj = JS_NewObject(cx, NULL, NULL, NULL);
 69069:   if (!root_obj)
 69069:     return NS_ERROR_FAILURE;
 69069:   *ret = OBJECT_TO_JSVAL(root_obj);
 69069: 
 91744:   // Ensure that all the HISTOGRAM_FLAG histograms have been created, so
 91744:   // that their values are snapshotted.
 91744:   for (size_t i = 0; i < Telemetry::HistogramCount; ++i) {
 91744:     if (gHistograms[i].histogramType == nsITelemetry::HISTOGRAM_FLAG) {
 91744:       Histogram *h;
 91744:       DebugOnly<nsresult> rv = GetHistogramByEnumId(Telemetry::ID(i), &h);
 91744:       MOZ_ASSERT(NS_SUCCEEDED(rv));
 91744:     }
 91744:   };
 91744: 
 87400:   StatisticsRecorder::Histograms hs;
 87400:   StatisticsRecorder::GetHistograms(&hs);
 87400: 
 87400:   // We identify corrupt histograms first, rather than interspersing it
 87400:   // in the loop below, to ensure that our corruption statistics don't
 87400:   // depend on histogram enumeration order.
 87400:   //
 87400:   // Of course, we hope that all of these corruption-statistics
 87400:   // histograms are not themselves corrupt...
 87400:   IdentifyCorruptHistograms(hs);
 87400: 
 87400:   // OK, now we can actually reflect things.
 87400:   for (HistogramIterator it = hs.begin(); it != hs.end(); ++it) {
 69069:     Histogram *h = *it;
 98132:     if (!ShouldReflectHistogram(h) || IsEmpty(h)) {
 87400:       continue;
 87400:     }
 87400: 
 69069:     JSObject *hobj = JS_NewObject(cx, NULL, NULL, NULL);
 87400:     if (!hobj) {
 69069:       return NS_ERROR_FAILURE;
 69069:     }
 91449:     JS::AutoObjectRooter root(cx, hobj);
 87400:     switch (ReflectHistogramSnapshot(cx, hobj, h)) {
 87400:     case REFLECT_CORRUPT:
 87400:       // We can still hit this case even if ShouldReflectHistograms
 87400:       // returns true.  The histogram lies outside of our control
 87400:       // somehow; just skip it.
 87400:       continue;
 87400:     case REFLECT_FAILURE:
 87400:       return NS_ERROR_FAILURE;
 87400:     case REFLECT_OK:
 87400:       if (!JS_DefineProperty(cx, root_obj, h->histogram_name().c_str(),
 87400:                              OBJECT_TO_JSVAL(hobj), NULL, NULL, JSPROP_ENUMERATE)) {
 87400:         return NS_ERROR_FAILURE;
 87400:       }
 87400:     }
 69069:   }
 84578:   return NS_OK;
 84578: }
 84578: 
 90274: bool
 91744: TelemetryImpl::CreateHistogramForAddon(const nsACString &name,
 91744:                                        AddonHistogramInfo &info)
 91744: {
 91744:   Histogram *h;
 91744:   nsresult rv = HistogramGet(PromiseFlatCString(name).get(),
 91744:                              info.min, info.max, info.bucketCount,
 91744:                              info.histogramType, &h);
 91744:   if (NS_FAILED(rv)) {
 91744:     return false;
 91744:   }
 91744:   // Don't let this histogram be reported via the normal means
 91744:   // (e.g. Telemetry.registeredHistograms); we'll make it available in
 91744:   // other ways.
 91744:   h->ClearFlags(Histogram::kUmaTargetedHistogramFlag);
 91744:   info.h = h;
 91744:   return true;
 91744: }
 91744: 
 91744: bool
 90274: TelemetryImpl::AddonHistogramReflector(AddonHistogramEntryType *entry,
 90274:                                        JSContext *cx, JSObject *obj)
 90274: {
 91744:   AddonHistogramInfo &info = entry->mData;
 91744: 
 90274:   // Never even accessed the histogram.
 91744:   if (!info.h) {
 91744:     // Have to force creation of HISTOGRAM_FLAG histograms.
 91744:     if (info.histogramType != nsITelemetry::HISTOGRAM_FLAG) 
 90274:       return true;
 91744: 
 91744:     if (!CreateHistogramForAddon(entry->GetKey(), info)) {
 91744:       return false;
 91744:     }
 90274:   }
 90274: 
 98132:   if (IsEmpty(info.h)) {
 98132:     return true;
 98132:   }
 98132: 
 90274:   JSObject *snapshot = JS_NewObject(cx, NULL, NULL, NULL);
 91449:   if (!snapshot) {
 91449:     // Just consider this to be skippable.
 91449:     return true;
 91449:   }
 91449:   JS::AutoObjectRooter r(cx, snapshot);
 91744:   switch (ReflectHistogramSnapshot(cx, snapshot, info.h)) {
 90274:   case REFLECT_FAILURE:
 90274:   case REFLECT_CORRUPT:
 90274:     return false;
 90274:   case REFLECT_OK:
 90274:     const nsACString &histogramName = entry->GetKey();
 90274:     if (!JS_DefineProperty(cx, obj,
 90274:                            PromiseFlatCString(histogramName).get(),
 90274:                            OBJECT_TO_JSVAL(snapshot), NULL, NULL,
 90274:                            JSPROP_ENUMERATE)) {
 90274:       return false;
 90274:     }
 90274:     break;
 90274:   }
 90274:   return true;
 90274: }
 90274: 
 90274: bool
 90274: TelemetryImpl::AddonReflector(AddonEntryType *entry,
 90274:                               JSContext *cx, JSObject *obj)
 90274: {
 90274:   const nsACString &addonId = entry->GetKey();
 90274:   JSObject *subobj = JS_NewObject(cx, NULL, NULL, NULL);
 90274:   if (!subobj) {
 90274:     return false;
 90274:   }
 91449:   JS::AutoObjectRooter r(cx, subobj);
 90274: 
 90274:   AddonHistogramMapType *map = entry->mData;
102256:   if (!(map->ReflectIntoJS(AddonHistogramReflector, cx, subobj)
 90274:         && JS_DefineProperty(cx, obj,
 90274:                              PromiseFlatCString(addonId).get(),
 90274:                              OBJECT_TO_JSVAL(subobj), NULL, NULL,
 90274:                              JSPROP_ENUMERATE))) {
 90274:     return false;
 90274:   }
 90274:   return true;
 90274: }
 90274: 
 90274: NS_IMETHODIMP
 90274: TelemetryImpl::GetAddonHistogramSnapshots(JSContext *cx, jsval *ret)
 90274: {
 90274:   *ret = JSVAL_VOID;
 90274:   JSObject *obj = JS_NewObject(cx, NULL, NULL, NULL);
 90274:   if (!obj) {
 90274:     return NS_ERROR_FAILURE;
 90274:   }
 91449:   JS::AutoObjectRooter r(cx, obj);
 90274: 
102256:   if (!mAddonMap.ReflectIntoJS(AddonReflector, cx, obj)) {
 90274:     return NS_ERROR_FAILURE;
 90274:   }
 90274:   *ret = OBJECT_TO_JSVAL(obj);
 90274:   return NS_OK;
 90274: }
 90274: 
 93683: bool
 93683: TelemetryImpl::GetSQLStats(JSContext *cx, jsval *ret, bool includePrivateSql)
 84578: {
 84578:   JSObject *root_obj = JS_NewObject(cx, NULL, NULL, NULL);
 84578:   if (!root_obj)
 93683:     return false;
 84578:   *ret = OBJECT_TO_JSVAL(root_obj);
 84105: 
 84105:   MutexAutoLock hashMutex(mHashMutex);
 84105:   // Add info about slow SQL queries on the main thread
 93683:   if (!AddSQLInfo(cx, root_obj, true, includePrivateSql))
 93683:     return false;
 93683:   // Add info about slow SQL queries on other threads
 93683:   if (!AddSQLInfo(cx, root_obj, false, includePrivateSql))
 93683:     return false;
 93683:   
 93683:   return true;
 93683: }
 93683: 
 93683: NS_IMETHODIMP
 93683: TelemetryImpl::GetSlowSQL(JSContext *cx, jsval *ret)
 93683: {
 93683:   if (GetSQLStats(cx, ret, false))
 93683:     return NS_OK;
 84105:   return NS_ERROR_FAILURE;
 93683: }
 93683: 
 93683: NS_IMETHODIMP
 93683: TelemetryImpl::GetDebugSlowSQL(JSContext *cx, jsval *ret)
 93683: {
 93683:   bool revealPrivateSql =
 93683:     Preferences::GetBool("toolkit.telemetry.debugSlowSql", false);
 93683:   if (GetSQLStats(cx, ret, revealPrivateSql))
 93683:     return NS_OK;
 84105:   return NS_ERROR_FAILURE;
 69069: }
 69069: 
 72124: NS_IMETHODIMP
 92058: TelemetryImpl::GetChromeHangs(JSContext *cx, jsval *ret)
 92058: {
 92058:   MutexAutoLock hangReportMutex(mHangReportsMutex);
106838:   JSObject *reportArray = JS_NewArrayObject(cx, 0, nullptr);
 92058:   if (!reportArray) {
 92058:     return NS_ERROR_FAILURE;
 92058:   }
 92058:   *ret = OBJECT_TO_JSVAL(reportArray);
 92058: 
 92058:   // Each hang report is an object in the 'chromeHangs' array
 92058:   for (size_t i = 0; i < mHangReports.Length(); ++i) {
108973:     Telemetry::ProcessedStack &stack = mHangReports[i].mStack;
 92058:     JSObject *reportObj = JS_NewObject(cx, NULL, NULL, NULL);
 92058:     if (!reportObj) {
 92058:       return NS_ERROR_FAILURE;
 92058:     }
 92058:     jsval reportObjVal = OBJECT_TO_JSVAL(reportObj);
 92058:     if (!JS_SetElement(cx, reportArray, i, &reportObjVal)) {
 92058:       return NS_ERROR_FAILURE;
 92058:     }
 92058: 
 92058:     // Record the hang duration (expressed in seconds)
 92058:     JSBool ok = JS_DefineProperty(cx, reportObj, "duration",
 92058:                                   INT_TO_JSVAL(mHangReports[i].duration),
 92058:                                   NULL, NULL, JSPROP_ENUMERATE);
 92058:     if (!ok) {
 92058:       return NS_ERROR_FAILURE;
 92058:     }
 92058: 
 92058:     // Represent call stack PCs as strings
 92058:     // (JS can't represent all 64-bit integer values)
106838:     JSObject *pcArray = JS_NewArrayObject(cx, 0, nullptr);
 92058:     if (!pcArray) {
 92058:       return NS_ERROR_FAILURE;
 92058:     }
 92058:     ok = JS_DefineProperty(cx, reportObj, "stack", OBJECT_TO_JSVAL(pcArray),
 92058:                            NULL, NULL, JSPROP_ENUMERATE);
 92058:     if (!ok) {
 92058:       return NS_ERROR_FAILURE;
 92058:     }
 92058: 
108973:     const uint32_t pcCount = stack.GetStackSize();
 92058:     for (size_t pcIndex = 0; pcIndex < pcCount; ++pcIndex) {
 92058:       nsCAutoString pcString;
108973:       const Telemetry::ProcessedStack::Frame &Frame = stack.GetFrame(pcIndex);
108973:       pcString.AppendPrintf("0x%p", Frame.mOffset);
 92058:       JSString *str = JS_NewStringCopyZ(cx, pcString.get());
 92058:       if (!str) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 92058:       jsval v = STRING_TO_JSVAL(str);
 92058:       if (!JS_SetElement(cx, pcArray, pcIndex, &v)) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 92058:     }
 92058: 
 92058:     // Record memory map info
106838:     JSObject *moduleArray = JS_NewArrayObject(cx, 0, nullptr);
 92058:     if (!moduleArray) {
 92058:       return NS_ERROR_FAILURE;
 92058:     }
 92058:     ok = JS_DefineProperty(cx, reportObj, "memoryMap",
 92058:                            OBJECT_TO_JSVAL(moduleArray),
 92058:                            NULL, NULL, JSPROP_ENUMERATE);
 92058:     if (!ok) {
 92058:       return NS_ERROR_FAILURE;
 92058:     }
 92058: 
108973:     const uint32_t moduleCount = stack.GetNumModules();
 92058:     for (size_t moduleIndex = 0; moduleIndex < moduleCount; ++moduleIndex) {
 92058:       // Current module
108973:       const Telemetry::ProcessedStack::Module &module =
108973:         stack.GetModule(moduleIndex);
 92058: 
106838:       JSObject *moduleInfoArray = JS_NewArrayObject(cx, 0, nullptr);
 92058:       if (!moduleInfoArray) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 92058:       jsval val = OBJECT_TO_JSVAL(moduleInfoArray);
 92058:       if (!JS_SetElement(cx, moduleArray, moduleIndex, &val)) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 92058: 
 92058:       // Start address
 92058:       nsCAutoString addressString;
108973:       addressString.AppendPrintf("0x%p", module.mStart);
 92058:       JSString *str = JS_NewStringCopyZ(cx, addressString.get());
 92058:       if (!str) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 92058:       val = STRING_TO_JSVAL(str);
 92058:       if (!JS_SetElement(cx, moduleInfoArray, 0, &val)) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 92058: 
 92058:       // Module name
108973:       str = JS_NewStringCopyZ(cx, module.mName.c_str());
 92058:       if (!str) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 92058:       val = STRING_TO_JSVAL(str);
 92058:       if (!JS_SetElement(cx, moduleInfoArray, 1, &val)) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 92058: 
 92058:       // Module size in memory
108973:       val = INT_TO_JSVAL(int32_t(module.mMappingSize));
 92058:       if (!JS_SetElement(cx, moduleInfoArray, 2, &val)) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 92058: 
 92058:       // "PDB Age" identifier
108973:       val = INT_TO_JSVAL(module.mPdbAge);
 92058:       if (!JS_SetElement(cx, moduleInfoArray, 3, &val)) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 92058: 
 92058:       // "PDB Signature" GUID
108973:       str = JS_NewStringCopyZ(cx, module.mPdbSignature.c_str());
 92058:       if (!str) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 92058:       val = STRING_TO_JSVAL(str);
 92058:       if (!JS_SetElement(cx, moduleInfoArray, 4, &val)) {
 92058:         return NS_ERROR_FAILURE;
 92058:       }
 93529: 
 93529:       // Name of associated PDB file
108973:       str = JS_NewStringCopyZ(cx, module.mPdbName.c_str());
 93529:       if (!str) {
 93529:         return NS_ERROR_FAILURE;
 93529:       }
 93529:       val = STRING_TO_JSVAL(str);
 93529:       if (!JS_SetElement(cx, moduleInfoArray, 5, &val)) {
 93529:         return NS_ERROR_FAILURE;
 93529:       }
 92058:     }
 92058:   }
 92058: 
 92058:   return NS_OK;
 92058: }
 92058: 
 92058: NS_IMETHODIMP
 86780: TelemetryImpl::GetRegisteredHistograms(JSContext *cx, jsval *ret)
 86780: {
 86780:   size_t count = ArrayLength(gHistograms);
 86780:   JSObject *info = JS_NewObject(cx, NULL, NULL, NULL);
 86780:   if (!info)
 86780:     return NS_ERROR_FAILURE;
 91449:   JS::AutoObjectRooter root(cx, info);
 86780: 
 86780:   for (size_t i = 0; i < count; ++i) {
110665:     JSString *comment = JS_InternString(cx, gHistograms[i].comment());
 86780:     
 86780:     if (!(comment
110665:           && JS_DefineProperty(cx, info, gHistograms[i].id(),
 86780:                                STRING_TO_JSVAL(comment), NULL, NULL,
 86780:                                JSPROP_ENUMERATE))) {
 86780:       return NS_ERROR_FAILURE;
 86780:     }
 86780:   }
 86780: 
 86780:   *ret = OBJECT_TO_JSVAL(info);
 86780:   return NS_OK;
 86780: }
 86780: 
 86780: NS_IMETHODIMP
 72124: TelemetryImpl::GetHistogramById(const nsACString &name, JSContext *cx, jsval *ret)
 69069: {
 72124:   Histogram *h;
 86778:   nsresult rv = GetHistogramByName(name, &h);
 72124:   if (NS_FAILED(rv))
 72124:     return rv;
 72124: 
 72124:   return WrapAndReturnHistogram(h, cx, ret);
 69069: }
 69069: 
 72661: NS_IMETHODIMP
 79445: TelemetryImpl::GetCanRecord(bool *ret) {
 72661:   *ret = mCanRecord;
 72661:   return NS_OK;
 72661: }
 72661: 
 72661: NS_IMETHODIMP
 79445: TelemetryImpl::SetCanRecord(bool canRecord) {
 72661:   mCanRecord = !!canRecord;
 72661:   return NS_OK;
 72661: }
 72661: 
 72661: bool
 72661: TelemetryImpl::CanRecord() {
 72661:   return !sTelemetry || sTelemetry->mCanRecord;
 72661: }
 72124: 
 89811: NS_IMETHODIMP
 89811: TelemetryImpl::GetCanSend(bool *ret) {
 89811: #if defined(MOZILLA_OFFICIAL) && defined(MOZ_TELEMETRY_REPORTING)
 89811:   *ret = true;
 89811: #else
 89811:   *ret = false;
 89811: #endif
 89811:   return NS_OK;
 89811: }
 89811: 
 72124: already_AddRefed<nsITelemetry>
 72661: TelemetryImpl::CreateTelemetryInstance()
 72124: {
 72661:   NS_ABORT_IF_FALSE(sTelemetry == NULL, "CreateTelemetryInstance may only be called once, via GetService()");
 72661:   sTelemetry = new TelemetryImpl(); 
 72661:   // AddRef for the local reference
 72661:   NS_ADDREF(sTelemetry);
 72661:   // AddRef for the caller
 72661:   NS_ADDREF(sTelemetry);
 72661:   return sTelemetry;
 72124: }
 72124: 
 72661: void
 72661: TelemetryImpl::ShutdownTelemetry()
 72661: {
 72661:   NS_IF_RELEASE(sTelemetry);
 72661: }
 72661: 
 84105: void
 98635: TelemetryImpl::StoreSlowSQL(const nsACString &sql, uint32_t delay,
108952:                             SanitizedState state)
 84105: {
 90012:   AutoHashtable<SlowSQLEntryType> *slowSQLMap = NULL;
108952:   if (state == Sanitized)
108952:     slowSQLMap = &(sTelemetry->mSanitizedSQL);
 84105:   else
108952:     slowSQLMap = &(sTelemetry->mPrivateSQL);
 84105: 
 84105:   MutexAutoLock hashMutex(sTelemetry->mHashMutex);
 93683: 
 93683:   SlowSQLEntryType *entry = slowSQLMap->GetEntry(sql);
 84105:   if (!entry) {
 93683:     entry = slowSQLMap->PutEntry(sql);
 84105:     if (NS_UNLIKELY(!entry))
 84105:       return;
108952:     entry->mData.mainThread.hitCount = 0;
108952:     entry->mData.mainThread.totalTime = 0;
108952:     entry->mData.otherThreads.hitCount = 0;
108952:     entry->mData.otherThreads.totalTime = 0;
 84105:   }
 93683: 
108952:   if (NS_IsMainThread()) {
108952:     entry->mData.mainThread.hitCount++;
108952:     entry->mData.mainThread.totalTime += delay;
108952:   } else {
108952:     entry->mData.otherThreads.hitCount++;
108952:     entry->mData.otherThreads.totalTime += delay;
108952:   }
108952: }
108952: 
108952: /**
108952:  * This method replaces string literals in SQL strings with the word :private
108952:  *
108952:  * States used in this state machine:
108952:  *
108952:  * NORMAL:
108952:  *  - This is the active state when not iterating over a string literal or
108952:  *  comment
108952:  *
108952:  * SINGLE_QUOTE:
108952:  *  - Defined here: http://www.sqlite.org/lang_expr.html
108952:  *  - This state represents iterating over a string literal opened with
108952:  *  a single quote.
108952:  *  - A single quote within the string can be encoded by putting 2 single quotes
108952:  *  in a row, e.g. 'This literal contains an escaped quote '''
108952:  *  - Any double quotes found within a single-quoted literal are ignored
108952:  *  - This state covers BLOB literals, e.g. X'ABC123'
108952:  *  - The string literal and the enclosing quotes will be replaced with
108952:  *  the text :private
108952:  *
108952:  * DOUBLE_QUOTE:
108952:  *  - Same rules as the SINGLE_QUOTE state.
108952:  *  - According to http://www.sqlite.org/lang_keywords.html,
108952:  *  SQLite interprets text in double quotes as an identifier unless it's used in
108952:  *  a context where it cannot be resolved to an identifier and a string literal
108952:  *  is allowed. This method removes text in double-quotes for safety.
108952:  *
108952:  *  DASH_COMMENT:
108952:  *  - http://www.sqlite.org/lang_comment.html
108952:  *  - A dash comment starts with two dashes in a row,
108952:  *  e.g. DROP TABLE foo -- a comment
108952:  *  - Any text following two dashes in a row is interpreted as a comment until
108952:  *  end of input or a newline character
108952:  *  - Any quotes found within the comment are ignored and no replacements made
108952:  *
108952:  *  C_STYLE_COMMENT:
108952:  *  - http://www.sqlite.org/lang_comment.html
108952:  *  - A C-style comment starts with a forward slash and an asterisk, and ends
108952:  *  with an asterisk and a forward slash
108952:  *  - Any text following comment start is interpreted as a comment up to end of
108952:  *  input or comment end
108952:  *  - Any quotes found within the comment are ignored and no replacements made
108952:  */
108952: nsCString
108952: TelemetryImpl::SanitizeSQL(const nsACString &sql) {
108952:   nsCString output;
108952:   int length = sql.Length();
108952: 
108952:   typedef enum {
108952:     NORMAL,
108952:     SINGLE_QUOTE,
108952:     DOUBLE_QUOTE,
108952:     DASH_COMMENT,
108952:     C_STYLE_COMMENT,
108952:   } State;
108952: 
108952:   State state = NORMAL;
108952:   int fragmentStart = 0;
108952:   for (int i = 0; i < length; i++) {
108952:     char character = sql[i];
108952:     char nextCharacter = (i + 1 < length) ? sql[i + 1] : '\0';
108952: 
108952:     switch (character) {
108952:       case '\'':
108952:       case '"':
108952:         if (state == NORMAL) {
108952:           state = (character == '\'') ? SINGLE_QUOTE : DOUBLE_QUOTE;
108952:           output += nsDependentCSubstring(sql, fragmentStart, i - fragmentStart);
108952:           output += ":private";
108952:           fragmentStart = -1;
108952:         } else if ((state == SINGLE_QUOTE && character == '\'') ||
108952:                    (state == DOUBLE_QUOTE && character == '"')) {
108952:           if (nextCharacter == character) {
108952:             // Two consecutive quotes within a string literal are a single escaped quote
108952:             i++;
108952:           } else {
108952:             state = NORMAL;
108952:             fragmentStart = i + 1;
108952:           }
108952:         }
108952:         break;
108952:       case '-':
108952:         if (state == NORMAL) {
108952:           if (nextCharacter == '-') {
108952:             state = DASH_COMMENT;
108952:             i++;
108952:           }
108952:         }
108952:         break;
108952:       case '\n':
108952:         if (state == DASH_COMMENT) {
108952:           state = NORMAL;
108952:         }
108952:         break;
108952:       case '/':
108952:         if (state == NORMAL) {
108952:           if (nextCharacter == '*') {
108952:             state = C_STYLE_COMMENT;
108952:             i++;
108952:           }
108952:         }
108952:         break;
108952:       case '*':
108952:         if (state == C_STYLE_COMMENT) {
108952:           if (nextCharacter == '/') {
108952:             state = NORMAL;
108952:           }
108952:         }
108952:         break;
108952:       default:
108952:         continue;
108952:     }
108952:   }
108952: 
108952:   if ((fragmentStart >= 0) && fragmentStart < length)
108952:     output += nsDependentCSubstring(sql, fragmentStart, length - fragmentStart);
108952: 
108952:   return output;
 84105: }
 84105: 
 93683: void
108952: TelemetryImpl::RecordSlowStatement(const nsACString &sql,
108952:                                    const nsACString &dbName,
108952:                                    uint32_t delay)
 93683: {
110922:   if (!sTelemetry || !sTelemetry->mCanRecord)
 93683:     return;
 93683: 
108952:   nsCAutoString fullSQL(sql);
108952:   fullSQL.AppendPrintf(" /* %s */", dbName.BeginReading());
108952: 
108952:   bool isFirefoxDB = sTelemetry->mTrackedDBs.Contains(dbName);
108952:   if (isFirefoxDB) {
108952:     nsCAutoString sanitizedSQL(SanitizeSQL(fullSQL));
108952:     StoreSlowSQL(sanitizedSQL, delay, Sanitized);
108952:   } else {
108952:     // Report aggregate DB-level statistics for addon DBs
 93683:     nsCAutoString aggregate;
 93683:     aggregate.AppendPrintf("Untracked SQL for %s", dbName.BeginReading());
108952:     StoreSlowSQL(aggregate, delay, Sanitized);
 93683:   }
 93683: 
108952:   StoreSlowSQL(fullSQL, delay, Unsanitized);
 93683: }
 93683: 
 93170: #if defined(MOZ_ENABLE_PROFILER_SPS)
 92058: void
 98635: TelemetryImpl::RecordChromeHang(uint32_t duration,
108973:                                 Telemetry::ProcessedStack &aStack)
 92058: {
110922:   if (!sTelemetry || !sTelemetry->mCanRecord)
 92058:     return;
 92058: 
 92058:   MutexAutoLock hangReportMutex(sTelemetry->mHangReportsMutex);
 92058: 
 92058:   // Only report the modules which changed since the first hang report
 92058:   if (sTelemetry->mHangReports.Length()) {
108973:     Telemetry::ProcessedStack &firstStack =
108973:       sTelemetry->mHangReports[0].mStack;
110922:     for (size_t i = 0; i < aStack.GetNumModules(); ++i) {
108973:       const Telemetry::ProcessedStack::Module &module = aStack.GetModule(i);
108973:       if (firstStack.HasModule(module)) {
108973:         aStack.RemoveModule(i);
 92058:         --i;
 92058:       }
 92058:     }
 92058:   }
 92058: 
108973:   HangReport newReport = { duration, aStack };
 92058:   sTelemetry->mHangReports.AppendElement(newReport);
 92058: }
 93170: #endif
 92058: 
 72661: NS_IMPL_THREADSAFE_ISUPPORTS1(TelemetryImpl, nsITelemetry)
 72661: NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(nsITelemetry, TelemetryImpl::CreateTelemetryInstance)
 69069: 
 69069: #define NS_TELEMETRY_CID \
 70091:   {0xaea477f2, 0xb3a2, 0x469c, {0xaa, 0x29, 0x0a, 0x82, 0xd1, 0x32, 0xb8, 0x29}}
 69069: NS_DEFINE_NAMED_CID(NS_TELEMETRY_CID);
 69069: 
 72124: const Module::CIDEntry kTelemetryCIDs[] = {
 72124:   { &kNS_TELEMETRY_CID, false, NULL, nsITelemetryConstructor },
 69069:   { NULL }
 69069: };
 69069: 
 72124: const Module::ContractIDEntry kTelemetryContracts[] = {
 69069:   { "@mozilla.org/base/telemetry;1", &kNS_TELEMETRY_CID },
 69069:   { NULL }
 69069: };
 69069: 
 72124: const Module kTelemetryModule = {
 72124:   Module::kVersion,
 69069:   kTelemetryCIDs,
 69069:   kTelemetryContracts,
 69069:   NULL,
 69069:   NULL,
 69069:   NULL,
 72661:   TelemetryImpl::ShutdownTelemetry
 69069: };
 69069: 
 70091: } // anonymous namespace
 70091: 
 72124: namespace mozilla {
 72124: namespace Telemetry {
 72124: 
 72124: void
 98635: Accumulate(ID aHistogram, uint32_t aSample)
 72124: {
 72661:   if (!TelemetryImpl::CanRecord()) {
 72661:     return;
 72661:   }
 72124:   Histogram *h;
 72124:   nsresult rv = GetHistogramByEnumId(aHistogram, &h);
 72124:   if (NS_SUCCEEDED(rv))
 72124:     h->Add(aSample);
 72124: }
 72124: 
 80424: void
 80424: AccumulateTimeDelta(ID aHistogram, TimeStamp start, TimeStamp end)
 80424: {
 80424:   Accumulate(aHistogram,
 98635:              static_cast<uint32_t>((end - start).ToMilliseconds()));
 80424: }
 80424: 
 88566: bool
 88566: CanRecord()
 88566: {
 88566:   return TelemetryImpl::CanRecord();
 88566: }
 88566: 
 78066: base::Histogram*
 78066: GetHistogramById(ID id)
 78066: {
 78066:   Histogram *h = NULL;
 78066:   GetHistogramByEnumId(id, &h);
 78066:   return h;
 78066: }
 78066: 
 84105: void
 84105: RecordSlowSQLStatement(const nsACString &statement,
 84105:                        const nsACString &dbName,
108952:                        uint32_t delay)
 84105: {
108952:   TelemetryImpl::RecordSlowStatement(statement, dbName, delay);
 84105: }
 84105: 
 86967: void Init()
 86967: {
 86967:   // Make the service manager hold a long-lived reference to the service
 86967:   nsCOMPtr<nsITelemetry> telemetryService =
 86967:     do_GetService("@mozilla.org/base/telemetry;1");
 86967:   MOZ_ASSERT(telemetryService);
 86967: }
 86967: 
 93170: #if defined(MOZ_ENABLE_PROFILER_SPS)
 98635: void RecordChromeHang(uint32_t duration,
108973:                       ProcessedStack &aStack)
 92058: {
108973:   TelemetryImpl::RecordChromeHang(duration, aStack);
 92058: }
 93170: #endif
 92058: 
108973: ProcessedStack::ProcessedStack()
108973: {
108973: }
108973: 
108973: size_t ProcessedStack::GetStackSize() const
108973: {
108973:   return mStack.size();
108973: }
108973: 
108973: const ProcessedStack::Frame &ProcessedStack::GetFrame(unsigned aIndex) const
108973: {
108973:   MOZ_ASSERT(aIndex < mStack.size());
108973:   return mStack[aIndex];
108973: }
108973: 
108973: void ProcessedStack::AddFrame(const Frame &aFrame)
108973: {
108973:   mStack.push_back(aFrame);
108973: }
108973: 
108973: size_t ProcessedStack::GetNumModules() const
108973: {
108973:   return mModules.size();
108973: }
108973: 
108973: const ProcessedStack::Module &ProcessedStack::GetModule(unsigned aIndex) const
108973: {
108973:   MOZ_ASSERT(aIndex < mModules.size());
108973:   return mModules[aIndex];
108973: }
108973: 
108973: bool ProcessedStack::HasModule(const Module &aModule) const {
108973:   return mModules.end() !=
108973:     std::find(mModules.begin(), mModules.end(), aModule);
108973: }
108973: 
108973: void ProcessedStack::RemoveModule(unsigned aIndex) {
108973:   mModules.erase(mModules.begin() + aIndex);
108973: }
108973: 
108973: void ProcessedStack::AddModule(const Module &aModule)
108973: {
108973:   mModules.push_back(aModule);
108973: }
108973: 
108973: void ProcessedStack::Clear() {
108973:   mModules.clear();
108973:   mStack.clear();
108973: }
108973: 
108973: bool ProcessedStack::Module::operator==(const Module& aOther) const {
108973:   return  mName == aOther.mName &&
108973:     mStart == aOther.mStart &&
108973:     mMappingSize == aOther.mMappingSize &&
108973:     mPdbAge == aOther.mPdbAge &&
108973:     mPdbSignature == aOther.mPdbSignature &&
108973:     mPdbName == aOther.mPdbName;
108973: }
108973: 
108973: struct StackFrame
108973: {
108973:   uintptr_t mPC;      // The program counter at this position in the call stack.
108973:   uint16_t mIndex;    // The number of this frame in the call stack.
108973:   uint16_t mModIndex; // The index of module that has this program counter.
108973: };
108973: 
108973: 
108973: #ifdef MOZ_ENABLE_PROFILER_SPS
108973: static bool CompareByPC(const StackFrame &a, const StackFrame &b)
108973: {
108973:   return a.mPC < b.mPC;
108973: }
108973: 
108973: static bool CompareByIndex(const StackFrame &a, const StackFrame &b)
108973: {
108973:   return a.mIndex < b.mIndex;
108973: }
108973: #endif
108973: 
108973: ProcessedStack GetStackAndModules(const std::vector<uintptr_t> &aPCs, bool aRelative)
108973: {
108973:   std::vector<StackFrame> rawStack;
108973:   for (std::vector<uintptr_t>::const_iterator i = aPCs.begin(),
108973:          e = aPCs.end(); i != e; ++i) {
108973:     uintptr_t aPC = *i;
108973:     StackFrame Frame = {aPC, static_cast<uint16_t>(rawStack.size()),
108973:                         std::numeric_limits<uint16_t>::max()};
108973:     rawStack.push_back(Frame);
108973:   }
108973: 
108973: #ifdef MOZ_ENABLE_PROFILER_SPS
108973:   // Remove all modules not referenced by a PC on the stack
108973:   std::sort(rawStack.begin(), rawStack.end(), CompareByPC);
108973: 
108973:   size_t moduleIndex = 0;
108973:   size_t stackIndex = 0;
108973:   size_t stackSize = rawStack.size();
108973: 
108973:   SharedLibraryInfo rawModules = SharedLibraryInfo::GetInfoForSelf();
108973:   rawModules.SortByAddress();
108973: 
108973:   while (moduleIndex < rawModules.GetSize()) {
108973:     const SharedLibrary& module = rawModules.GetEntry(moduleIndex);
108973:     uintptr_t moduleStart = module.GetStart();
108973:     uintptr_t moduleEnd = module.GetEnd() - 1;
108973:     // the interval is [moduleStart, moduleEnd)
108973: 
108973:     bool moduleReferenced = false;
108973:     for (;stackIndex < stackSize; ++stackIndex) {
108973:       uintptr_t pc = rawStack[stackIndex].mPC;
108973:       if (pc >= moduleEnd)
108973:         break;
108973: 
108973:       if (pc >= moduleStart) {
108973:         // If the current PC is within the current module, mark
108973:         // module as used
108973:         moduleReferenced = true;
108973:         if (aRelative)
108973:           rawStack[stackIndex].mPC -= moduleStart;
108973:         rawStack[stackIndex].mModIndex = moduleIndex;
108973:       } else {
108973:         // PC does not belong to any module. It is probably from
108973:         // the JIT. Use a fixed mPC so that we don't get different
108973:         // stacks on different runs.
108973:         rawStack[stackIndex].mPC =
108973:           std::numeric_limits<uintptr_t>::max();
108973:       }
108973:     }
108973: 
108973:     if (moduleReferenced) {
108973:       ++moduleIndex;
108973:     } else {
108973:       // Remove module if no PCs within its address range
108973:       rawModules.RemoveEntries(moduleIndex, moduleIndex + 1);
108973:     }
108973:   }
108973: 
108973:   for (;stackIndex < stackSize; ++stackIndex) {
108973:     // These PCs are past the last module.
108973:     rawStack[stackIndex].mPC = std::numeric_limits<uintptr_t>::max();
108973:   }
108973: 
108973:   std::sort(rawStack.begin(), rawStack.end(), CompareByIndex);
108973: #endif
108973: 
108973:   // Copy the information to the return value.
108973:   ProcessedStack Ret;
108973:   for (std::vector<StackFrame>::iterator i = rawStack.begin(),
108973:          e = rawStack.end(); i != e; ++i) {
108973:     const StackFrame &rawFrame = *i;
108973:     ProcessedStack::Frame frame = { rawFrame.mPC, rawFrame.mModIndex };
108973:     Ret.AddFrame(frame);
108973:   }
108973: 
108973: #ifdef MOZ_ENABLE_PROFILER_SPS
108973:   for (unsigned i = 0, n = rawModules.GetSize(); i != n; ++i) {
108973:     const SharedLibrary &info = rawModules.GetEntry(i);
108973:     ProcessedStack::Module module = {
108973:       info.GetName(),
108973:       info.GetStart(),
108973:       info.GetEnd() - info.GetStart(),
108973: #ifdef XP_WIN
108973:       info.GetPdbAge(),
108973:       "", // mPdbSignature
108973:       info.GetPdbName(),
108973: #else
108973:       0, // mPdbAge
108973:       "", // mPdbSignature
108973:       "" // mPdbName
108973: #endif
108973:     };
108973: #ifdef XP_WIN
108973:     char guidString[NSID_LENGTH] = { 0 };
108973:     info.GetPdbSignature().ToProvidedString(guidString);
108973:     module.mPdbSignature = guidString;
108973: #endif
108973:     Ret.AddModule(module);
108973:   }
108973: #endif
108973: 
108973:   return Ret;
108973: }
108973: 
 72124: } // namespace Telemetry
 72124: } // namespace mozilla
 72124: 
 69069: NSMODULE_DEFN(nsTelemetryModule) = &kTelemetryModule;
 72212: 
 72212: /**
 72212:  * The XRE_TelemetryAdd function is to be used by embedding applications
 72212:  * that can't use mozilla::Telemetry::Accumulate() directly.
 72212:  */
 72212: void
 98635: XRE_TelemetryAccumulate(int aID, uint32_t aSample)
 72212: {
 72212:   mozilla::Telemetry::Accumulate((mozilla::Telemetry::ID) aID, aSample);
 72212: }
