     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 86084: /* vim: set ts=2 et sw=2 tw=78: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * a node in the lexicographic tree of rules that match an element,
     1:  * responsible for converting the rules' information into computed style
     1:  */
     1: 
119484: #include <algorithm>
119484: 
     1: #include "nsRuleNode.h"
     1: #include "nscore.h"
     1: #include "nsIServiceManager.h"
 26846: #include "nsIWidget.h"
     1: #include "nsIPresShell.h"
 68493: #include "nsFontMetrics.h"
 15955: #include "gfxFont.h"
     1: #include "nsStyleUtil.h"
     1: #include "nsCSSPseudoElements.h"
     1: #include "nsThemeConstants.h"
     1: #include "nsITheme.h"
     1: #include "pldhash.h"
     1: #include "nsStyleContext.h"
     1: #include "nsStyleSet.h"
     1: #include "nsSize.h"
     1: #include "imgIRequest.h"
     1: #include "nsRuleData.h"
     1: #include "nsIStyleRule.h"
  3832: #include "nsBidiUtils.h"
 38492: #include "nsUnicharUtils.h"
 15992: #include "nsStyleStructInlines.h"
 19214: #include "nsStyleTransformMatrix.h"
 19214: #include "nsCSSKeywords.h"
 22737: #include "nsCSSProps.h"
 24551: #include "nsTArray.h"
 35581: #include "nsContentUtils.h"
 42142: #include "CSSCalc.h"
 50931: #include "nsPrintfCString.h"
101129: 
101129: #include "mozilla/Assertions.h"
101129: #include "mozilla/dom/Element.h"
120353: #include "mozilla/Likely.h"
101129: #include "mozilla/LookAndFeel.h"
 72285: #include "mozilla/Util.h"
 63759: 
 63759: #if defined(_MSC_VER) || defined(__MINGW32__)
 63759: #include <malloc.h>
 63759: #ifdef _MSC_VER
 63759: #define alloca _alloca
 63759: #endif
 63759: #endif
 63759: #ifdef SOLARIS
 63750: #include <alloca.h>
 63759: #endif
 41634: 
119484: using std::max;
119484: using std::min;
 78128: using namespace mozilla;
 41634: using namespace mozilla::dom;
 35581: 
 35581: #define NS_SET_IMAGE_REQUEST(method_, context_, request_)                   \
 35581:   if ((context_)->PresContext()->IsDynamic()) {                               \
 35581:     method_(request_);                                                      \
 35581:   } else {                                                                  \
 35581:     nsCOMPtr<imgIRequest> req = nsContentUtils::GetStaticRequest(request_); \
 35581:     method_(req);                                                           \
 35581:   }
     1: 
108323: #define NS_SET_IMAGE_REQUEST_WITH_DOC(method_, context_, requestgetter_)      \
108323:   {                                                                           \
108323:     nsIDocument* doc = (context_)->PresContext()->Document();                 \
108323:     NS_SET_IMAGE_REQUEST(method_, context_, requestgetter_(doc))              \
108323:   }
108323: 
     1: /*
     1:  * For storage of an |nsRuleNode|'s children in a PLDHashTable.
     1:  */
     1: 
     1: struct ChildrenHashEntry : public PLDHashEntryHdr {
  1539:   // key is |mRuleNode->GetKey()|
     1:   nsRuleNode *mRuleNode;
     1: };
     1: 
 20261: /* static */ PLDHashNumber
  1539: nsRuleNode::ChildrenHashHashKey(PLDHashTable *aTable, const void *aKey)
  1539: {
  1539:   const nsRuleNode::Key *key =
  3233:     static_cast<const nsRuleNode::Key*>(aKey);
  1539:   // Disagreement on importance and level for the same rule is extremely
  1539:   // rare, so hash just on the rule.
  1539:   return PL_DHashVoidPtrKeyStub(aTable, key->mRule);
  1539: }
  1539: 
 79445: /* static */ bool
  1539: nsRuleNode::ChildrenHashMatchEntry(PLDHashTable *aTable,
  1539:                                    const PLDHashEntryHdr *aHdr,
  1539:                                    const void *aKey)
     1: {
     1:   const ChildrenHashEntry *entry =
  3233:     static_cast<const ChildrenHashEntry*>(aHdr);
  1539:   const nsRuleNode::Key *key =
  3233:     static_cast<const nsRuleNode::Key*>(aKey);
  1539:   return entry->mRuleNode->GetKey() == *key;
  1539: }
  1539: 
  1539: /* static */ PLDHashTableOps
  1539: nsRuleNode::ChildrenHashOps = {
     1:   // It's probably better to allocate the table itself using malloc and
     1:   // free rather than the pres shell's arena because the table doesn't
     1:   // grow very often and the pres shell's arena doesn't recycle very
     1:   // large size allocations.
     1:   PL_DHashAllocTable,
     1:   PL_DHashFreeTable,
  1539:   ChildrenHashHashKey,
     1:   ChildrenHashMatchEntry,
     1:   PL_DHashMoveEntryStub,
     1:   PL_DHashClearEntryStub,
     1:   PL_DHashFinalizeStub,
     1:   NULL
     1: };
     1: 
     1: 
     1: // EnsureBlockDisplay:
     1: //  - if the display value (argument) is not a block-type
     1: //    then we set it to a valid block display value
     1: //  - For enforcing the floated/positioned element CSS2 rules
121232: /* static */
121232: void
121232: nsRuleNode::EnsureBlockDisplay(uint8_t& display)
     1: {
     1:   // see if the display value is already a block
     1:   switch (display) {
     1:   case NS_STYLE_DISPLAY_NONE :
     1:     // never change display:none *ever*
     1:   case NS_STYLE_DISPLAY_TABLE :
     1:   case NS_STYLE_DISPLAY_BLOCK :
     1:   case NS_STYLE_DISPLAY_LIST_ITEM :
103018: #ifdef MOZ_FLEXBOX
103018:   case NS_STYLE_DISPLAY_FLEX :
103018: #endif // MOZ_FLEXBOX
     1:     // do not muck with these at all - already blocks
  2829:     // This is equivalent to nsStyleDisplay::IsBlockOutside.  (XXX Maybe we
     1:     // should just call that?)
 38776:     // This needs to match the check done in
 38776:     // nsCSSFrameConstructor::FindMathMLData for <math>.
     1:     break;
     1: 
     1:   case NS_STYLE_DISPLAY_INLINE_TABLE :
     1:     // make inline tables into tables
     1:     display = NS_STYLE_DISPLAY_TABLE;
     1:     break;
     1: 
103018: #ifdef MOZ_FLEXBOX
103018:   case NS_STYLE_DISPLAY_INLINE_FLEX:
103018:     // make inline flex containers into flex containers
103018:     display = NS_STYLE_DISPLAY_FLEX;
103018:     break;
103018: #endif // MOZ_FLEXBOX
103018: 
     1:   default :
     1:     // make it a block
     1:     display = NS_STYLE_DISPLAY_BLOCK;
     1:   }
     1: }
     1: 
 42142: static nscoord CalcLengthWith(const nsCSSValue& aValue,
 42142:                               nscoord aFontSize,
 42142:                               const nsStyleFont* aStyleFont,
 42142:                               nsStyleContext* aStyleContext,
 42142:                               nsPresContext* aPresContext,
 79445:                               bool aUseProvidedRootEmSize,
 79445:                               bool aUseUserFontSet,
 79445:                               bool& aCanStoreInRuleTree);
 42142: 
 47180: struct CalcLengthCalcOps : public css::BasicCoordCalcOps,
 47180:                            public css::NumbersAlreadyNormalizedOps
 42142: {
 42142:   // All of the parameters to CalcLengthWith except aValue.
 42149:   const nscoord mFontSize;
 42149:   const nsStyleFont* const mStyleFont;
 42149:   nsStyleContext* const mStyleContext;
 42149:   nsPresContext* const mPresContext;
 79445:   const bool mUseProvidedRootEmSize;
 79445:   const bool mUseUserFontSet;
 79445:   bool& mCanStoreInRuleTree;
 42142: 
 42149:   CalcLengthCalcOps(nscoord aFontSize, const nsStyleFont* aStyleFont,
 42142:                     nsStyleContext* aStyleContext, nsPresContext* aPresContext,
 79445:                     bool aUseProvidedRootEmSize, bool aUseUserFontSet,
 79445:                     bool& aCanStoreInRuleTree)
 42142:     : mFontSize(aFontSize),
 42142:       mStyleFont(aStyleFont),
 42142:       mStyleContext(aStyleContext),
 42142:       mPresContext(aPresContext),
 42142:       mUseProvidedRootEmSize(aUseProvidedRootEmSize),
 42142:       mUseUserFontSet(aUseUserFontSet),
 42142:       mCanStoreInRuleTree(aCanStoreInRuleTree)
 42142:   {
 42142:   }
 42149: 
 42149:   result_type ComputeLeafValue(const nsCSSValue& aValue)
 42149:   {
 88039:     return CalcLengthWith(aValue, mFontSize, mStyleFont,
 76296:                           mStyleContext, mPresContext, mUseProvidedRootEmSize,
 42149:                           mUseUserFontSet, mCanStoreInRuleTree);
 42142:   }
 42142: };
 42142: 
 23981: static inline nscoord ScaleCoord(const nsCSSValue &aValue, float factor)
 23981: {
 23981:   return NSToCoordRoundWithClamp(aValue.GetFloatValue() * factor);
 23981: }
 23981: 
 76296: already_AddRefed<nsFontMetrics>
 76296: GetMetricsFor(nsPresContext* aPresContext,
 76296:               nsStyleContext* aStyleContext,
 76296:               const nsStyleFont* aStyleFont,
 76296:               nscoord aFontSize, // overrides value from aStyleFont
 79445:               bool aUseUserFontSet)
 76296: {
 76296:   nsFont font = aStyleFont->mFont;
 76296:   font.size = aFontSize;
106838:   gfxUserFontSet *fs = nullptr;
 76296:   if (aUseUserFontSet) {
 76296:     fs = aPresContext->GetUserFontSet();
 76296:   }
 76296:   nsRefPtr<nsFontMetrics> fm;
 76296:   aPresContext->DeviceContext()->GetMetricsFor(font,
 88039:                                                aStyleFont->mLanguage,
 76296:                                                fs, *getter_AddRefs(fm));
 76296:   return fm.forget();
 76296: }
 76296: 
 10073: static nscoord CalcLengthWith(const nsCSSValue& aValue,
 10073:                               nscoord aFontSize,
 10073:                               const nsStyleFont* aStyleFont,
     1:                               nsStyleContext* aStyleContext,
     1:                               nsPresContext* aPresContext,
 79445:                               bool aUseProvidedRootEmSize,
 80486:                               // aUseUserFontSet should always be true
 23846:                               // except when called from
 23846:                               // CalcLengthWithInitialFont.
 79445:                               bool aUseUserFontSet,
 79445:                               bool& aCanStoreInRuleTree)
     1: {
 42142:   NS_ASSERTION(aValue.IsLengthUnit() || aValue.IsCalcUnit(),
 42142:                "not a length or calc unit");
 88039:   NS_ASSERTION(aStyleFont || aStyleContext,
 76296:                "Must have style data");
 88039:   NS_ASSERTION(!aStyleFont || !aStyleContext,
 76296:                "Duplicate sources of data");
 10073:   NS_ASSERTION(aPresContext, "Must have prescontext");
 10073: 
     1:   if (aValue.IsFixedLengthUnit()) {
 50786:     return aValue.GetFixedLength(aPresContext);
 50786:   }
 50786:   if (aValue.IsPixelLengthUnit()) {
 50786:     return aValue.GetPixelLength();
 50786:   }
120180:   if (aValue.IsCalcUnit()) {
120180:     // For properties for which lengths are the *only* units accepted in
120180:     // calc(), we can handle calc() here and just compute a final
120180:     // result.  We ensure that we don't get to this code for other
120180:     // properties by not calling CalcLength in those cases:  SetCoord
120180:     // only calls CalcLength for a calc when it is appropriate to do so.
120180:     CalcLengthCalcOps ops(aFontSize, aStyleFont,
120180:                           aStyleContext, aPresContext,
120180:                           aUseProvidedRootEmSize, aUseUserFontSet,
120180:                           aCanStoreInRuleTree);
120180:     return css::ComputeCalc(aValue, ops);
120180:   }
120182:   switch (aValue.GetUnit()) {
120182:     // nsPresContext::SetVisibleArea and
120182:     // nsPresContext::MediaFeatureValuesChanged handle dynamic changes
120182:     // of the basis for viewport units by rebuilding the rule tree and
120182:     // style context tree.  Not caching them in the rule tree wouldn't
120182:     // be sufficient to handle these changes because we also need a way
120182:     // to get rid of cached values in the style context tree without any
120182:     // changes in specified style.  We can either do this by not caching
120182:     // in the rule tree and then throwing away the style context tree
120182:     // for dynamic viewport size changes, or by allowing caching in the
120182:     // rule tree and using the existing rebuild style data path that
120182:     // throws away the style context and the rule tree.
120182:     // Thus we do cache viewport units in the rule tree.  This allows us
120182:     // to benefit from the performance advantages of the rule tree
120182:     // (e.g., faster dynamic changes on other things, like transforms)
120182:     // and allows us not to need an additional code path, in exchange
120182:     // for an increased cost to dynamic changes to the viewport size
120182:     // when viewport units are in use.
120182:     case eCSSUnit_ViewportWidth: {
120182:       aPresContext->SetUsesViewportUnits(true);
120182:       return ScaleCoord(aValue, 0.01f * aPresContext->GetVisibleArea().width);
120182:     }
120182:     case eCSSUnit_ViewportHeight: {
120182:       aPresContext->SetUsesViewportUnits(true);
120182:       return ScaleCoord(aValue, 0.01f * aPresContext->GetVisibleArea().height);
120182:     }
120182:     case eCSSUnit_ViewportMin: {
120182:       aPresContext->SetUsesViewportUnits(true);
120182:       nsSize viewportSize = aPresContext->GetVisibleArea().Size();
120182:       return ScaleCoord(aValue, 0.01f * min(viewportSize.width, viewportSize.height));
120182:     }
120182:     case eCSSUnit_ViewportMax: {
120182:       aPresContext->SetUsesViewportUnits(true);
120182:       nsSize viewportSize = aPresContext->GetVisibleArea().Size();
120182:       return ScaleCoord(aValue, 0.01f * max(viewportSize.width, viewportSize.height));
120182:     }
120185:     // While we could deal with 'rem' units correctly by simply not
120185:     // caching any data that uses them in the rule tree, it's valuable
120185:     // to store them in the rule tree (for faster dynamic changes of
120185:     // other things).  And since the font size of the root element
120185:     // changes rarely, we instead handle dynamic changes to the root
120185:     // element's font size by rebuilding all style data in
120185:     // nsCSSFrameConstructor::RestyleElement.
 23981:     case eCSSUnit_RootEM: {
120184:       aPresContext->SetUsesRootEMUnits(true);
 23981:       nscoord rootFontSize;
 23981: 
 23981:       if (aUseProvidedRootEmSize) {
 23981:         // We should use the provided aFontSize as the reference length to
 30987:         // scale. This only happens when we are calculating font-size or
 30987:         // an equivalent (scriptminsize or CalcLengthWithInitialFont) on
 30987:         // the root element, in which case aFontSize is already the
 30987:         // value we want.
 23981:         rootFontSize = aFontSize;
 30987:       } else if (aStyleContext && !aStyleContext->GetParent()) {
 30987:         // This is the root element (XXX we don't really know this, but
 30987:         // nsRuleNode::SetFont makes the same assumption!), so we should
 30987:         // use GetStyleFont on this context to get the root element's
 30987:         // font size.
120185:         const nsStyleFont *styleFont =
120185:           aStyleFont ? aStyleFont : aStyleContext->GetStyleFont();
 42142:         rootFontSize = styleFont->mFont.size;
 23981:       } else {
 23981:         // This is not the root element or we are calculating something other
 23981:         // than font size, so rem is relative to the root element's font size.
 23981:         nsRefPtr<nsStyleContext> rootStyle;
120185:         const nsStyleFont *rootStyleFont =
120185:           aStyleFont ? aStyleFont : aStyleContext->GetStyleFont();
 41634:         Element* docElement = aPresContext->Document()->GetRootElement();
 23981: 
 48099:         if (docElement) {
 23981:           rootStyle = aPresContext->StyleSet()->ResolveStyleFor(docElement,
106838:                                                                 nullptr);
 23981:           if (rootStyle) {
 23981:             rootStyleFont = rootStyle->GetStyleFont();
 48099:           }
 48099:         }
 48099: 
 23981:         rootFontSize = rootStyleFont->mFont.size;
 23981:       }
 23981: 
 23981:       return ScaleCoord(aValue, float(rootFontSize));
 23981:     }
120185:     default:
120185:       // Fall through to the code for units that can't be stored in the
120185:       // rule tree because they depend on font data.
120185:       break;
120185:   }
120185:   // Common code for units that depend on the element's font data and
120185:   // thus can't be stored in the rule tree:
120185:   aCanStoreInRuleTree = false;
120185:   const nsStyleFont *styleFont =
120185:     aStyleFont ? aStyleFont : aStyleContext->GetStyleFont();
120185:   if (aFontSize == -1) {
120185:     // XXX Should this be styleFont->mSize instead to avoid taking minfontsize
120185:     // prefs into account?
120185:     aFontSize = styleFont->mFont.size;
120185:   }
120185:   switch (aValue.GetUnit()) {
 15955:     case eCSSUnit_EM: {
122244:       // CSS2.1 specifies that this unit scales to the computed font
122244:       // size, not the em-width in the font metrics, despite the name.
 23981:       return ScaleCoord(aValue, float(aFontSize));
     1:     }
     1:     case eCSSUnit_XHeight: {
 68493:       nsRefPtr<nsFontMetrics> fm =
 76296:         GetMetricsFor(aPresContext, aStyleContext, styleFont,
 88039:                       aFontSize, aUseUserFontSet);
 68495:       return ScaleCoord(aValue, float(fm->XHeight()));
     1:     }
 15955:     case eCSSUnit_Char: {
 68493:       nsRefPtr<nsFontMetrics> fm =
 76296:         GetMetricsFor(aPresContext, aStyleContext, styleFont,
 88039:                       aFontSize, aUseUserFontSet);
 68491:       gfxFloat zeroWidth = (fm->GetThebesFontGroup()->GetFontAt(0)
 15955:                             ->GetMetrics().zeroOrAveCharWidth);
 15955: 
 75359:       return ScaleCoord(aValue, ceil(aPresContext->AppUnitsPerDevPixel() *
 15955:                                      zeroWidth));
 15955:     }
     1:     default:
     1:       NS_NOTREACHED("unexpected unit");
     1:       break;
     1:   }
     1:   return 0;
     1: }
     1: 
 19214: /* static */ nscoord
 19214: nsRuleNode::CalcLength(const nsCSSValue& aValue,
 10073:                        nsStyleContext* aStyleContext,
 10073:                        nsPresContext* aPresContext,
 79445:                        bool& aCanStoreInRuleTree)
 10073: {
 10073:   NS_ASSERTION(aStyleContext, "Must have style data");
 10073: 
106838:   return CalcLengthWith(aValue, -1, nullptr,
 76296:                         aStyleContext, aPresContext,
 80486:                         false, true, aCanStoreInRuleTree);
 10073: }
 10073: 
 19214: /* Inline helper function to redirect requests to CalcLength. */
 19214: static inline nscoord CalcLength(const nsCSSValue& aValue,
 19214:                                  nsStyleContext* aStyleContext,
 19214:                                  nsPresContext* aPresContext,
 79445:                                  bool& aCanStoreInRuleTree)
 19214: {
 19214:   return nsRuleNode::CalcLength(aValue, aStyleContext,
 24636:                                 aPresContext, aCanStoreInRuleTree);
 19214: }
 19214: 
 16222: /* static */ nscoord
 16222: nsRuleNode::CalcLengthWithInitialFont(nsPresContext* aPresContext,
 16222:                                       const nsCSSValue& aValue)
 16222: {
 88039:   nsStyleFont defaultFont(aPresContext); // FIXME: best language?
 79445:   bool canStoreInRuleTree;
 88039:   return CalcLengthWith(aValue, -1, &defaultFont,
106838:                         nullptr, aPresContext,
 80486:                         true, false, canStoreInRuleTree);
 16222: }
 16222: 
 52481: struct LengthPercentPairCalcOps : public css::NumbersAlreadyNormalizedOps
 52481: {
 52481:   typedef nsRuleNode::ComputedCalc result_type;
 52481: 
 52481:   LengthPercentPairCalcOps(nsStyleContext* aContext,
 47182:                            nsPresContext* aPresContext,
 79445:                            bool& aCanStoreInRuleTree)
 52481:     : mContext(aContext),
 47182:       mPresContext(aPresContext),
 52481:       mCanStoreInRuleTree(aCanStoreInRuleTree),
 80486:       mHasPercent(false) {}
 52481: 
 52481:   nsStyleContext* mContext;
 52481:   nsPresContext* mPresContext;
 79445:   bool& mCanStoreInRuleTree;
 79445:   bool mHasPercent;
 52481: 
 52481:   result_type ComputeLeafValue(const nsCSSValue& aValue)
 52481:   {
 52481:     if (aValue.GetUnit() == eCSSUnit_Percent) {
 80486:       mHasPercent = true;
 52481:       return result_type(0, aValue.GetPercentValue());
 52481:     }
 52481:     return result_type(CalcLength(aValue, mContext, mPresContext,
 52481:                                   mCanStoreInRuleTree),
 52481:                        0.0f);
 47182:   }
 47182: 
 47182:   result_type
 47182:   MergeAdditive(nsCSSUnit aCalcFunction,
 47182:                 result_type aValue1, result_type aValue2)
 47182:   {
 52481:     if (aCalcFunction == eCSSUnit_Calc_Plus) {
 52481:       return result_type(NSCoordSaturatingAdd(aValue1.mLength,
 52481:                                               aValue2.mLength),
 52481:                          aValue1.mPercent + aValue2.mPercent);
 52481:     }
 52481:     NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Minus,
 52481:                       "min() and max() are not allowed in calc() on "
 52481:                       "transform");
 52481:     return result_type(NSCoordSaturatingSubtract(aValue1.mLength,
 52481:                                                  aValue2.mLength, 0),
 52481:                        aValue1.mPercent - aValue2.mPercent);
 47182:   }
 47182: 
 47182:   result_type
 47182:   MergeMultiplicativeL(nsCSSUnit aCalcFunction,
 47182:                        float aValue1, result_type aValue2)
 47182:   {
 52481:     NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Times_L,
 52481:                       "unexpected unit");
 52481:     return result_type(NSCoordSaturatingMultiply(aValue2.mLength, aValue1),
 52481:                        aValue1 * aValue2.mPercent);
 47182:   }
 47182: 
 47182:   result_type
 47182:   MergeMultiplicativeR(nsCSSUnit aCalcFunction,
 47182:                        result_type aValue1, float aValue2)
 47182:   {
 52481:     NS_ABORT_IF_FALSE(aCalcFunction == eCSSUnit_Calc_Times_R ||
 52481:                       aCalcFunction == eCSSUnit_Calc_Divided,
 52481:                       "unexpected unit");
 52481:     if (aCalcFunction == eCSSUnit_Calc_Divided) {
 52481:       aValue2 = 1.0f / aValue2;
 52481:     }
 52481:     return result_type(NSCoordSaturatingMultiply(aValue1.mLength, aValue2),
 52481:                        aValue1.mPercent * aValue2);
 52481:   }
 52481: 
 47182: };
 47182: 
 47182: static void
 47182: SpecifiedCalcToComputedCalc(const nsCSSValue& aValue, nsStyleCoord& aCoord, 
 47182:                             nsStyleContext* aStyleContext,
 79445:                             bool& aCanStoreInRuleTree)
 47182: {
 52481:   LengthPercentPairCalcOps ops(aStyleContext, aStyleContext->PresContext(),
 47182:                                aCanStoreInRuleTree);
 52481:   nsRuleNode::ComputedCalc vals = ComputeCalc(aValue, ops);
 52481: 
 52481:   nsStyleCoord::Calc *calcObj =
 52481:     new (aStyleContext->Alloc(sizeof(nsStyleCoord::Calc))) nsStyleCoord::Calc;
 52481:   // Because we use aStyleContext->Alloc(), we have to store the result
 52481:   // on the style context and not in the rule tree.
 80486:   aCanStoreInRuleTree = false;
 52481: 
 52481:   calcObj->mLength = vals.mLength;
 52481:   calcObj->mPercent = vals.mPercent;
 52481:   calcObj->mHasPercent = ops.mHasPercent;
 52481: 
 52481:   aCoord.SetCalcValue(calcObj);
 52481: }
 52481: 
 52481: /* static */ nsRuleNode::ComputedCalc
 52481: nsRuleNode::SpecifiedCalcToComputedCalc(const nsCSSValue& aValue,
 52481:                                         nsStyleContext* aStyleContext,
 52481:                                         nsPresContext* aPresContext,
 79445:                                         bool& aCanStoreInRuleTree)
 52481: {
 52481:   LengthPercentPairCalcOps ops(aStyleContext, aPresContext,
 52481:                                aCanStoreInRuleTree);
 52481:   return ComputeCalc(aValue, ops);
 52481: }
 47184: 
 47184: // This is our public API for handling calc() expressions that involve
 47184: // percentages.
 47184: /* static */ nscoord
 47184: nsRuleNode::ComputeComputedCalc(const nsStyleCoord& aValue,
 47184:                                 nscoord aPercentageBasis)
 47184: {
 52481:   nsStyleCoord::Calc *calc = aValue.GetCalcValue();
 52481:   return calc->mLength +
 52481:          NSToCoordFloorClamped(aPercentageBasis * calc->mPercent);
 52481: }
 52481: 
 52481: /* static */ nscoord
 52481: nsRuleNode::ComputeCoordPercentCalc(const nsStyleCoord& aCoord,
 52481:                                     nscoord aPercentageBasis)
 52481: {
 52481:   switch (aCoord.GetUnit()) {
 52481:     case eStyleUnit_Coord:
 52481:       return aCoord.GetCoordValue();
 52481:     case eStyleUnit_Percent:
 52481:       return NSToCoordFloorClamped(aPercentageBasis * aCoord.GetPercentValue());
 52481:     case eStyleUnit_Calc:
 52481:       return ComputeComputedCalc(aCoord, aPercentageBasis);
 52481:     default:
 80486:       NS_ABORT_IF_FALSE(false, "unexpected unit");
 52481:       return 0;
 52481:   }
 47184: }
 47184: 
 50928: /* Given an enumerated value that represents a box position, converts it to
 50928:  * a float representing the percentage of the box it corresponds to.  For
 50928:  * example, "center" becomes 0.5f.
 50928:  *
 50928:  * @param aEnumValue The enumerated value.
 50928:  * @return The float percent it corresponds to.
 50928:  */
 50928: static float
108991: GetFloatFromBoxPosition(int32_t aEnumValue)
 50928: {
 50928:   switch (aEnumValue) {
 50928:   case NS_STYLE_BG_POSITION_LEFT:
 50928:   case NS_STYLE_BG_POSITION_TOP:
 50928:     return 0.0f;
 50928:   case NS_STYLE_BG_POSITION_RIGHT:
 50928:   case NS_STYLE_BG_POSITION_BOTTOM:
 50928:     return 1.0f;
 50928:   default:
 50928:     NS_NOTREACHED("unexpected value");
 50928:     // fall through
 50928:   case NS_STYLE_BG_POSITION_CENTER:
 50928:     return 0.5f;
 50928:   }
 50928: }
 50928: 
     1: #define SETCOORD_NORMAL                 0x01   // N
     1: #define SETCOORD_AUTO                   0x02   // A
     1: #define SETCOORD_INHERIT                0x04   // H
     1: #define SETCOORD_PERCENT                0x08   // P
     1: #define SETCOORD_FACTOR                 0x10   // F
     1: #define SETCOORD_LENGTH                 0x20   // L
     1: #define SETCOORD_INTEGER                0x40   // I
     1: #define SETCOORD_ENUMERATED             0x80   // E
  1363: #define SETCOORD_NONE                   0x100  // O
  3832: #define SETCOORD_INITIAL_ZERO           0x200
  3832: #define SETCOORD_INITIAL_AUTO           0x400
  3832: #define SETCOORD_INITIAL_NONE           0x800
  3832: #define SETCOORD_INITIAL_NORMAL         0x1000
 19214: #define SETCOORD_INITIAL_HALF           0x2000
 86084: #define SETCOORD_INITIAL_HUNDRED_PCT    0x00004000
 86084: #define SETCOORD_INITIAL_FACTOR_ONE     0x00008000
 86084: #define SETCOORD_INITIAL_FACTOR_ZERO    0x00010000
 86084: #define SETCOORD_CALC_LENGTH_ONLY       0x00020000
 86084: #define SETCOORD_CALC_CLAMP_NONNEGATIVE 0x00040000 // modifier for CALC_LENGTH_ONLY
 86084: #define SETCOORD_STORE_CALC             0x00080000
 86084: #define SETCOORD_BOX_POSITION           0x00100000 // exclusive with _ENUMERATED
     1: 
     1: #define SETCOORD_LP     (SETCOORD_LENGTH | SETCOORD_PERCENT)
     1: #define SETCOORD_LH     (SETCOORD_LENGTH | SETCOORD_INHERIT)
     1: #define SETCOORD_AH     (SETCOORD_AUTO | SETCOORD_INHERIT)
     1: #define SETCOORD_LAH    (SETCOORD_AUTO | SETCOORD_LENGTH | SETCOORD_INHERIT)
     1: #define SETCOORD_LPH    (SETCOORD_LP | SETCOORD_INHERIT)
     1: #define SETCOORD_LPAH   (SETCOORD_LP | SETCOORD_AH)
     1: #define SETCOORD_LPEH   (SETCOORD_LP | SETCOORD_ENUMERATED | SETCOORD_INHERIT)
  1068: #define SETCOORD_LPAEH  (SETCOORD_LPAH | SETCOORD_ENUMERATED)
 34475: #define SETCOORD_LPO    (SETCOORD_LP | SETCOORD_NONE)
  1363: #define SETCOORD_LPOH   (SETCOORD_LPH | SETCOORD_NONE)
  1363: #define SETCOORD_LPOEH  (SETCOORD_LPOH | SETCOORD_ENUMERATED)
     1: #define SETCOORD_LE     (SETCOORD_LENGTH | SETCOORD_ENUMERATED)
     1: #define SETCOORD_LEH    (SETCOORD_LE | SETCOORD_INHERIT)
     1: #define SETCOORD_IA     (SETCOORD_INTEGER | SETCOORD_AUTO)
     1: #define SETCOORD_LAE    (SETCOORD_LENGTH | SETCOORD_AUTO | SETCOORD_ENUMERATED)
     1: 
 80486: // changes aCoord iff it returns true
 79445: static bool SetCoord(const nsCSSValue& aValue, nsStyleCoord& aCoord,
     1:                        const nsStyleCoord& aParentCoord,
108991:                        int32_t aMask, nsStyleContext* aStyleContext,
 24636:                        nsPresContext* aPresContext,
 79445:                        bool& aCanStoreInRuleTree)
     1: {
 79445:   bool result = true;
     1:   if (aValue.GetUnit() == eCSSUnit_Null) {
 80486:     result = false;
     1:   }
 42142:   else if ((((aMask & SETCOORD_LENGTH) != 0) &&
 42142:             aValue.IsLengthUnit()) ||
 42142:            (((aMask & SETCOORD_CALC_LENGTH_ONLY) != 0) &&
 42142:             aValue.IsCalcUnit())) {
 42143:     nscoord len = CalcLength(aValue, aStyleContext, aPresContext,
 42143:                              aCanStoreInRuleTree);
 42143:     if ((aMask & SETCOORD_CALC_CLAMP_NONNEGATIVE) && len < 0) {
 42143:       NS_ASSERTION(aValue.IsCalcUnit(),
 42143:                    "parser should have ensured no nonnegative lengths");
 42143:       len = 0;
 42143:     }
 42143:     aCoord.SetCoordValue(len);
     1:   }
     1:   else if (((aMask & SETCOORD_PERCENT) != 0) &&
     1:            (aValue.GetUnit() == eCSSUnit_Percent)) {
     1:     aCoord.SetPercentValue(aValue.GetPercentValue());
     1:   }
     1:   else if (((aMask & SETCOORD_INTEGER) != 0) &&
     1:            (aValue.GetUnit() == eCSSUnit_Integer)) {
     1:     aCoord.SetIntValue(aValue.GetIntValue(), eStyleUnit_Integer);
     1:   }
     1:   else if (((aMask & SETCOORD_ENUMERATED) != 0) &&
     1:            (aValue.GetUnit() == eCSSUnit_Enumerated)) {
     1:     aCoord.SetIntValue(aValue.GetIntValue(), eStyleUnit_Enumerated);
     1:   }
 50928:   else if (((aMask & SETCOORD_BOX_POSITION) != 0) &&
 50928:            (aValue.GetUnit() == eCSSUnit_Enumerated)) {
 50928:     aCoord.SetPercentValue(GetFloatFromBoxPosition(aValue.GetIntValue()));
 50928:   }
     1:   else if (((aMask & SETCOORD_AUTO) != 0) &&
     1:            (aValue.GetUnit() == eCSSUnit_Auto)) {
     1:     aCoord.SetAutoValue();
     1:   }
     1:   else if (((aMask & SETCOORD_INHERIT) != 0) &&
     1:            (aValue.GetUnit() == eCSSUnit_Inherit)) {
     1:     aCoord = aParentCoord;  // just inherit value from parent
 80486:     aCanStoreInRuleTree = false;
     1:   }
     1:   else if (((aMask & SETCOORD_NORMAL) != 0) &&
     1:            (aValue.GetUnit() == eCSSUnit_Normal)) {
     1:     aCoord.SetNormalValue();
     1:   }
  1363:   else if (((aMask & SETCOORD_NONE) != 0) &&
  1363:            (aValue.GetUnit() == eCSSUnit_None)) {
  1363:     aCoord.SetNoneValue();
  1363:   }
     1:   else if (((aMask & SETCOORD_FACTOR) != 0) &&
     1:            (aValue.GetUnit() == eCSSUnit_Number)) {
     1:     aCoord.SetFactorValue(aValue.GetFloatValue());
     1:   }
 47182:   else if (((aMask & SETCOORD_STORE_CALC) != 0) &&
 47182:            (aValue.IsCalcUnit())) {
 47182:     SpecifiedCalcToComputedCalc(aValue, aCoord, aStyleContext,
 47182:                                 aCanStoreInRuleTree);
 47182:   }
 86086:   else if (aValue.GetUnit() == eCSSUnit_Initial) {
 86086:     if ((aMask & SETCOORD_INITIAL_AUTO) != 0) {
 86086:       aCoord.SetAutoValue();
 86086:     }
 86086:     else if ((aMask & SETCOORD_INITIAL_ZERO) != 0) {
 86086:       aCoord.SetCoordValue(0);
 86086:     }
 86086:     else if ((aMask & SETCOORD_INITIAL_FACTOR_ZERO) != 0) {
 86086:       aCoord.SetFactorValue(0.0f);
 86086:     }
 86086:     else if ((aMask & SETCOORD_INITIAL_NONE) != 0) {
 86086:       aCoord.SetNoneValue();
 86086:     }
 86086:     else if ((aMask & SETCOORD_INITIAL_NORMAL) != 0) {
 86086:       aCoord.SetNormalValue();
 86086:     }
 86086:     else if ((aMask & SETCOORD_INITIAL_HALF) != 0) {
 86086:       aCoord.SetPercentValue(0.5f);
 86086:     }
 86086:     else if ((aMask & SETCOORD_INITIAL_HUNDRED_PCT) != 0) {
 86086:       aCoord.SetPercentValue(1.0f);
 86086:     }
 86086:     else if ((aMask & SETCOORD_INITIAL_FACTOR_ONE) != 0) {
 86086:       aCoord.SetFactorValue(1.0f);
 86086:     }
 86086:     else {
 86086:       result = false;  // didn't set anything
 86086:     }
 86086:   }
     1:   else {
 80486:     result = false;  // didn't set anything
     1:   }
     1:   return result;
     1: }
     1: 
 31749: // This inline function offers a shortcut for SetCoord() by refusing to accept
 31749: // SETCOORD_LENGTH and SETCOORD_INHERIT masks.
 79445: static inline bool SetAbsCoord(const nsCSSValue& aValue,
 31749:                                  nsStyleCoord& aCoord,
108991:                                  int32_t aMask)
 31749: {
 31749:   NS_ABORT_IF_FALSE((aMask & SETCOORD_LH) == 0,
 31749:                     "does not handle SETCOORD_LENGTH and SETCOORD_INHERIT");
 31749: 
 31749:   // The values of the following variables will never be used; so it does not
 31749:   // matter what to set.
 31749:   const nsStyleCoord dummyParentCoord;
106838:   nsStyleContext* dummyStyleContext = nullptr;
106838:   nsPresContext* dummyPresContext = nullptr;
 79445:   bool dummyCanStoreInRuleTree = true;
 79445: 
 79445:   bool rv = SetCoord(aValue, aCoord, dummyParentCoord, aMask,
 31749:                        dummyStyleContext, dummyPresContext,
 31749:                        dummyCanStoreInRuleTree);
 31749:   NS_ABORT_IF_FALSE(dummyCanStoreInRuleTree,
 31749:                     "SetCoord() should not modify dummyCanStoreInRuleTree.");
 31749: 
 31749:   return rv;
 31749: }
 31749: 
 50928: /* Given a specified value that might be a pair value, call SetCoord twice,
 50928:  * either using each member of the pair, or using the unpaired value twice.
 19214:  */
 79445: static bool
 50928: SetPairCoords(const nsCSSValue& aValue,
 50928:               nsStyleCoord& aCoordX, nsStyleCoord& aCoordY,
 50928:               const nsStyleCoord& aParentX, const nsStyleCoord& aParentY,
108991:               int32_t aMask, nsStyleContext* aStyleContext,
 79445:               nsPresContext* aPresContext, bool& aCanStoreInRuleTree)
 50928: {
 50928:   const nsCSSValue& valX =
 50928:     aValue.GetUnit() == eCSSUnit_Pair ? aValue.GetPairValue().mXValue : aValue;
 50928:   const nsCSSValue& valY =
 50928:     aValue.GetUnit() == eCSSUnit_Pair ? aValue.GetPairValue().mYValue : aValue;
 50928: 
 79445:   bool cX = SetCoord(valX, aCoordX, aParentX, aMask, aStyleContext,
 50928:                        aPresContext, aCanStoreInRuleTree);
 79445:   mozilla::DebugOnly<bool> cY = SetCoord(valY, aCoordY, aParentY, aMask, 
 72285:                        aStyleContext, aPresContext, aCanStoreInRuleTree);
 50928:   NS_ABORT_IF_FALSE(cX == cY, "changed one but not the other");
 50928:   return cX;
 19214: }
 19214: 
 79445: static bool SetColor(const nsCSSValue& aValue, const nscolor aParentColor,
     1:                        nsPresContext* aPresContext, nsStyleContext *aContext,
 79445:                        nscolor& aResult, bool& aCanStoreInRuleTree)
     1: {
 79445:   bool    result = false;
     1:   nsCSSUnit unit = aValue.GetUnit();
     1: 
     1:   if (eCSSUnit_Color == unit) {
     1:     aResult = aValue.GetColorValue();
 80486:     result = true;
     1:   }
 25796:   else if (eCSSUnit_Ident == unit) {
     1:     nsAutoString  value;
     1:     aValue.GetStringValue(value);
     1:     nscolor rgba;
     1:     if (NS_ColorNameToRGB(value, &rgba)) {
     1:       aResult = rgba;
 80486:       result = true;
     1:     }
     1:   }
 11408:   else if (eCSSUnit_EnumColor == unit) {
108991:     int32_t intValue = aValue.GetIntValue();
     1:     if (0 <= intValue) {
 78128:       LookAndFeel::ColorID colorID = (LookAndFeel::ColorID) intValue;
 78128:       if (NS_SUCCEEDED(LookAndFeel::GetColor(colorID, &aResult))) {
 80486:         result = true;
     1:       }
     1:     }
     1:     else {
101129:       aResult = NS_RGB(0, 0, 0);
101129:       result = false;
     1:       switch (intValue) {
     1:         case NS_COLOR_MOZ_HYPERLINKTEXT:
101129:           if (aPresContext) {
     1:             aResult = aPresContext->DefaultLinkColor();
101129:             result = true;
101129:           }
     1:           break;
     1:         case NS_COLOR_MOZ_VISITEDHYPERLINKTEXT:
101129:           if (aPresContext) {
     1:             aResult = aPresContext->DefaultVisitedLinkColor();
101129:             result = true;
101129:           }
     1:           break;
     1:         case NS_COLOR_MOZ_ACTIVEHYPERLINKTEXT:
101129:           if (aPresContext) {
     1:             aResult = aPresContext->DefaultActiveLinkColor();
101129:             result = true;
101129:           }
     1:           break;
     1:         case NS_COLOR_CURRENTCOLOR:
     1:           // The data computed from this can't be shared in the rule tree
     1:           // because they could be used on a node with a different color
 80486:           aCanStoreInRuleTree = false;
101129:           if (aContext) {
     1:             aResult = aContext->GetStyleColor()->mColor;
101129:             result = true;
101129:           }
     1:           break;
 64441:         case NS_COLOR_MOZ_DEFAULT_COLOR:
101129:           if (aPresContext) {
 64441:             aResult = aPresContext->DefaultColor();
101129:             result = true;
101129:           }
 64441:           break;
 64441:         case NS_COLOR_MOZ_DEFAULT_BACKGROUND_COLOR:
101129:           if (aPresContext) {
 64441:             aResult = aPresContext->DefaultBackgroundColor();
101129:             result = true;
101129:           }
 64441:           break;
     1:         default:
     1:           NS_NOTREACHED("Should never have an unknown negative colorID.");
     1:           break;
     1:       }
     1:     }
     1:   }
     1:   else if (eCSSUnit_Inherit == unit) {
     1:     aResult = aParentColor;
 80486:     result = true;
 80486:     aCanStoreInRuleTree = false;
     1:   }
 71160:   else if (eCSSUnit_Enumerated == unit &&
 71160:            aValue.GetIntValue() == NS_STYLE_COLOR_INHERIT_FROM_BODY) {
 71160:     NS_ASSERTION(aPresContext->CompatibilityMode() == eCompatibility_NavQuirks,
 71160:                  "Should only get this value in quirks mode");
 71160:     // We just grab the color from the prescontext, and rely on the fact that
 71160:     // if the body color ever changes all its descendants will get new style
 71160:     // contexts (but NOT necessarily new rulenodes).
 71160:     aResult = aPresContext->BodyTextColor();
 80486:     result = true;
 80486:     aCanStoreInRuleTree = false;
 71160:   }
     1:   return result;
     1: }
     1: 
 30993: static void SetGradientCoord(const nsCSSValue& aValue, nsPresContext* aPresContext,
 30993:                              nsStyleContext* aContext, nsStyleCoord& aResult,
 79445:                              bool& aCanStoreInRuleTree)
 30993: {
 30993:   // OK to pass bad aParentCoord since we're not passing SETCOORD_INHERIT
 50928:   if (!SetCoord(aValue, aResult, nsStyleCoord(),
 53920:                 SETCOORD_LPO | SETCOORD_BOX_POSITION | SETCOORD_STORE_CALC,
 34475:                 aContext, aPresContext, aCanStoreInRuleTree)) {
 34475:     NS_NOTREACHED("unexpected unit for gradient anchor point");
 34475:     aResult.SetNoneValue();
 34475:   }
 30993: }
 30993: 
 30993: static void SetGradient(const nsCSSValue& aValue, nsPresContext* aPresContext,
 30993:                         nsStyleContext* aContext, nsStyleGradient& aResult,
 79445:                         bool& aCanStoreInRuleTree)
 30993: {
 30993:   NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Gradient,
 30993:                     "The given data is not a gradient");
 30993: 
103902:   const nsCSSValueGradient* gradient = aValue.GetGradientValue();
 30993: 
103903:   if (gradient->mIsExplicitSize) {
103903:     SetCoord(gradient->GetRadiusX(), aResult.mRadiusX, nsStyleCoord(),
103903:              SETCOORD_LP | SETCOORD_STORE_CALC,
103903:              aContext, aPresContext, aCanStoreInRuleTree);
103903:     if (gradient->GetRadiusY().GetUnit() != eCSSUnit_None) {
103903:       SetCoord(gradient->GetRadiusY(), aResult.mRadiusY, nsStyleCoord(),
103903:                SETCOORD_LP | SETCOORD_STORE_CALC,
103903:                aContext, aPresContext, aCanStoreInRuleTree);
103903:       aResult.mShape = NS_STYLE_GRADIENT_SHAPE_ELLIPTICAL;
103903:     } else {
103903:       aResult.mRadiusY = aResult.mRadiusX;
103903:       aResult.mShape = NS_STYLE_GRADIENT_SHAPE_CIRCULAR;
103903:     }
103903:     aResult.mSize = NS_STYLE_GRADIENT_SIZE_EXPLICIT_SIZE;
103903:   } else if (gradient->mIsRadial) {
103902:     if (gradient->GetRadialShape().GetUnit() == eCSSUnit_Enumerated) {
103902:       aResult.mShape = gradient->GetRadialShape().GetIntValue();
 34475:     } else {
103902:       NS_ASSERTION(gradient->GetRadialShape().GetUnit() == eCSSUnit_None,
 34475:                    "bad unit for radial shape");
 34475:       aResult.mShape = NS_STYLE_GRADIENT_SHAPE_ELLIPTICAL;
 34475:     }
103902:     if (gradient->GetRadialSize().GetUnit() == eCSSUnit_Enumerated) {
103902:       aResult.mSize = gradient->GetRadialSize().GetIntValue();
 34475:     } else {
103902:       NS_ASSERTION(gradient->GetRadialSize().GetUnit() == eCSSUnit_None,
 34475:                    "bad unit for radial shape");
 34475:       aResult.mSize = NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER;
 34475:     }
 34475:   } else {
103902:     NS_ASSERTION(gradient->GetRadialShape().GetUnit() == eCSSUnit_None,
 34475:                  "bad unit for linear shape");
103902:     NS_ASSERTION(gradient->GetRadialSize().GetUnit() == eCSSUnit_None,
 34475:                  "bad unit for linear size");
 34475:     aResult.mShape = NS_STYLE_GRADIENT_SHAPE_LINEAR;
 34475:     aResult.mSize = NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER;
103903:   }
103903: 
103903:   aResult.mLegacySyntax = gradient->mIsLegacySyntax;
 34475: 
 34475:   // bg-position
 50927:   SetGradientCoord(gradient->mBgPos.mXValue, aPresContext, aContext,
 34475:                    aResult.mBgPosX, aCanStoreInRuleTree);
 34475: 
 50927:   SetGradientCoord(gradient->mBgPos.mYValue, aPresContext, aContext,
 34475:                    aResult.mBgPosY, aCanStoreInRuleTree);
 34475: 
 34475:   aResult.mRepeating = gradient->mIsRepeating;
 34475: 
 34475:   // angle
 34475:   if (gradient->mAngle.IsAngularUnit()) {
 34475:     nsStyleUnit unit;
 34475:     switch (gradient->mAngle.GetUnit()) {
 34475:     case eCSSUnit_Degree: unit = eStyleUnit_Degree; break;
 34475:     case eCSSUnit_Grad:   unit = eStyleUnit_Grad; break;
 34475:     case eCSSUnit_Radian: unit = eStyleUnit_Radian; break;
 89445:     case eCSSUnit_Turn:   unit = eStyleUnit_Turn; break;
 34475:     default: NS_NOTREACHED("unrecognized angular unit");
 34475:       unit = eStyleUnit_Degree;
 34475:     }
 34475:     aResult.mAngle.SetAngleValue(gradient->mAngle.GetAngleValue(), unit);
 34475:   } else {
 34475:     NS_ASSERTION(gradient->mAngle.GetUnit() == eCSSUnit_None,
 34475:                  "bad unit for gradient angle");
 34475:     aResult.mAngle.SetNoneValue();
 30993:   }
 30993: 
 30993:   // stops
108991:   for (uint32_t i = 0; i < gradient->mStops.Length(); i++) {
 30993:     nsStyleGradientStop stop;
103902:     const nsCSSValueGradientStop &valueStop = gradient->mStops[i];
 30993: 
 34475:     if (!SetCoord(valueStop.mLocation, stop.mLocation,
116076:                   nsStyleCoord(), SETCOORD_LPO | SETCOORD_STORE_CALC,
 34475:                   aContext, aPresContext, aCanStoreInRuleTree)) {
 34475:       NS_NOTREACHED("unexpected unit for gradient stop location");
 34475:     }
 30993: 
 30993:     // inherit is not a valid color for stops, so we pass in a dummy
 30993:     // parent color
 30993:     NS_ASSERTION(valueStop.mColor.GetUnit() != eCSSUnit_Inherit,
 30993:                  "inherit is not a valid color for gradient stops");
 30993:     SetColor(valueStop.mColor, NS_RGB(0, 0, 0), aPresContext,
 30993:              aContext, stop.mColor, aCanStoreInRuleTree);
 30993: 
 30993:     aResult.mStops.AppendElement(stop);
 30993:   }
 30993: }
 30993: 
 31749: // -moz-image-rect(<uri>, <top>, <right>, <bottom>, <left>)
 35581: static void SetStyleImageToImageRect(nsStyleContext* aStyleContext,
 35581:                                      const nsCSSValue& aValue,
 31749:                                      nsStyleImage& aResult)
 31749: {
 31749:   NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Function &&
 31749:                     aValue.EqualsFunction(eCSSKeyword__moz_image_rect),
 31749:                     "the value is not valid -moz-image-rect()");
 31749: 
 31749:   nsCSSValue::Array* arr = aValue.GetArrayValue();
 31749:   NS_ABORT_IF_FALSE(arr && arr->Count() == 6, "invalid number of arguments");
 31749: 
 31749:   // <uri>
 31749:   if (arr->Item(1).GetUnit() == eCSSUnit_Image) {
108323:     NS_SET_IMAGE_REQUEST_WITH_DOC(aResult.SetImageData,
 35581:                                   aStyleContext,
108323:                                   arr->Item(1).GetImageValue)
 31749:   } else {
 31749:     NS_WARNING("nsCSSValue::Image::Image() failed?");
 31749:   }
 31749: 
 31749:   // <top>, <right>, <bottom>, <left>
 31749:   nsStyleSides cropRect;
 31749:   NS_FOR_CSS_SIDES(side) {
 31749:     nsStyleCoord coord;
 31749:     const nsCSSValue& val = arr->Item(2 + side);
 64056: 
 64056: #ifdef DEBUG
 79445:     bool unitOk =
 64056: #endif
 64056:       SetAbsCoord(val, coord, SETCOORD_FACTOR | SETCOORD_PERCENT);
 31749:     NS_ABORT_IF_FALSE(unitOk, "Incorrect data structure created by CSS parser");
 31749:     cropRect.Set(side, coord);
 31749:   }
 31749:   aResult.SetCropRect(&cropRect);
 31749: }
 31749: 
 31749: static void SetStyleImage(nsStyleContext* aStyleContext,
 31749:                           const nsCSSValue& aValue,
 31749:                           nsStyleImage& aResult,
 79445:                           bool& aCanStoreInRuleTree)
 31749: {
 31749:   aResult.SetNull();
 31749: 
 31749:   switch (aValue.GetUnit()) {
 31749:     case eCSSUnit_Image:
108323:       NS_SET_IMAGE_REQUEST_WITH_DOC(aResult.SetImageData,
 35581:                                     aStyleContext,
108323:                                     aValue.GetImageValue)
 31749:       break;
 31749:     case eCSSUnit_Function:
 31749:       if (aValue.EqualsFunction(eCSSKeyword__moz_image_rect)) {
 35581:         SetStyleImageToImageRect(aStyleContext, aValue, aResult);
 31749:       } else {
 31749:         NS_NOTREACHED("-moz-image-rect() is the only expected function");
 31749:       }
 31749:       break;
 31749:     case eCSSUnit_Gradient:
 31749:     {
 31749:       nsStyleGradient* gradient = new nsStyleGradient();
 31749:       if (gradient) {
 31749:         SetGradient(aValue, aStyleContext->PresContext(), aStyleContext,
 31749:                     *gradient, aCanStoreInRuleTree);
 31749:         aResult.SetGradientData(gradient);
 31749:       }
 31749:       break;
 31749:     }
 50422:     case eCSSUnit_Element:
 50422:       aResult.SetElementId(aValue.GetStringBufferValue());
 50422:       break;
 31749:     case eCSSUnit_None:
 31749:       break;
 31749:     default:
 40498:       // We might have eCSSUnit_URL values for if-visited style
 40498:       // contexts, which we can safely treat like 'none'.  Otherwise
 40498:       // this is an unexpected unit.
 40498:       NS_ASSERTION(aStyleContext->IsStyleIfVisited() &&
 40498:                    aValue.GetUnit() == eCSSUnit_URL,
 40498:                    "unexpected unit; maybe nsCSSValue::Image::Image() failed?");
 31749:       break;
 31749:   }
 31749: }
 31749: 
 18889: // flags for SetDiscrete - align values with SETCOORD_* constants
 18889: // where possible
 18889: 
 18889: #define SETDSC_NORMAL                 0x01   // N
 18889: #define SETDSC_AUTO                   0x02   // A
 18889: #define SETDSC_INTEGER                0x40   // I
 18889: #define SETDSC_ENUMERATED             0x80   // E
 18889: #define SETDSC_NONE                   0x100  // O
 18889: #define SETDSC_SYSTEM_FONT            0x2000
 18889: 
 18889: // no caller cares whether aField was changed or not
 18889: template <typename FieldT,
 18889:           typename T1, typename T2, typename T3, typename T4, typename T5>
 18889: static void
 18889: SetDiscrete(const nsCSSValue& aValue, FieldT & aField,
108991:             bool& aCanStoreInRuleTree, uint32_t aMask,
 18889:             FieldT aParentValue,
 18889:             T1 aInitialValue,
 18889:             T2 aAutoValue,
 18889:             T3 aNoneValue,
 18889:             T4 aNormalValue,
 18889:             T5 aSystemFontValue)
 18889: {
 18889:   switch (aValue.GetUnit()) {
 18889:   case eCSSUnit_Null:
 18889:     return;
 18889: 
 18889:     // every caller of SetDiscrete provides inherit and initial
 18889:     // alternatives, so we don't require them to say so in the mask
 18889:   case eCSSUnit_Inherit:
 80486:     aCanStoreInRuleTree = false;
 18889:     aField = aParentValue;
 18889:     return;
 18889: 
 18889:   case eCSSUnit_Initial:
 18889:     aField = aInitialValue;
 18889:     return;
 18889: 
 18889:     // every caller provides one or other of these alternatives,
 18889:     // but they have to say which
 18889:   case eCSSUnit_Enumerated:
 18889:     if (aMask & SETDSC_ENUMERATED) {
 18889:       aField = aValue.GetIntValue();
 18889:       return;
 18889:     }
 18889:     break;
 18889: 
 18889:   case eCSSUnit_Integer:
 18889:     if (aMask & SETDSC_INTEGER) {
 18889:       aField = aValue.GetIntValue();
 18889:       return;
 18889:     }
 18889:     break;
 18889: 
 18889:     // remaining possibilities in descending order of frequency of use
 18889:   case eCSSUnit_Auto:
 18889:     if (aMask & SETDSC_AUTO) {
 18889:       aField = aAutoValue;
 18889:       return;
 18889:     }
 18889:     break;
 18889: 
 18889:   case eCSSUnit_None:
 18889:     if (aMask & SETDSC_NONE) {
 18889:       aField = aNoneValue;
 18889:       return;
 18889:     }
 18889:     break;
 18889: 
 18889:   case eCSSUnit_Normal:
 18889:     if (aMask & SETDSC_NORMAL) {
 18889:       aField = aNormalValue;
 18889:       return;
 18889:     }
 18889:     break;
 18889: 
 18889:   case eCSSUnit_System_Font:
 18889:     if (aMask & SETDSC_SYSTEM_FONT) {
 18889:       aField = aSystemFontValue;
 18889:       return;
 18889:     }
 18889:     break;
 18889: 
 18889:   default:
 18889:     break;
 18889:   }
 18889: 
 18889:   NS_NOTREACHED("SetDiscrete: inappropriate unit");
 18889: }
 18889: 
 18889: // flags for SetFactor
 18889: #define SETFCT_POSITIVE 0x01        // assert value is >= 0.0f
 18889: #define SETFCT_OPACITY  0x02        // clamp value to [0.0f .. 1.0f]
 18889: #define SETFCT_NONE     0x04        // allow _None (uses aInitialValue).
 18889: 
 18889: static void
 79445: SetFactor(const nsCSSValue& aValue, float& aField, bool& aCanStoreInRuleTree,
108991:           float aParentValue, float aInitialValue, uint32_t aFlags = 0)
 18889: {
 18889:   switch (aValue.GetUnit()) {
 18889:   case eCSSUnit_Null:
 18889:     return;
 18889: 
 18889:   case eCSSUnit_Number:
 18889:     aField = aValue.GetFloatValue();
 18889:     if (aFlags & SETFCT_POSITIVE) {
 18889:       NS_ASSERTION(aField >= 0.0f, "negative value for positive-only property");
 18889:       if (aField < 0.0f)
 18889:         aField = 0.0f;
 18889:     }
 18889:     if (aFlags & SETFCT_OPACITY) {
 18889:       if (aField < 0.0f)
 18889:         aField = 0.0f;
 18889:       if (aField > 1.0f)
 18889:         aField = 1.0f;
 18889:     }
 18889:     return;
 18889: 
 18889:   case eCSSUnit_Inherit:
 80486:     aCanStoreInRuleTree = false;
 18889:     aField = aParentValue;
 18889:     return;
 18889: 
 18889:   case eCSSUnit_Initial:
 18889:     aField = aInitialValue;
 18889:     return;
 18889: 
 18889:   case eCSSUnit_None:
 18889:     if (aFlags & SETFCT_NONE) {
 18889:       aField = aInitialValue;
 18889:       return;
 18889:     }
 18889:     break;
 18889: 
 18889:   default:
 18889:     break;
 18889:   }
 18889: 
 18889:   NS_NOTREACHED("SetFactor: inappropriate unit");
 18889: }
 18889: 
     1: // Overloaded new operator. Initializes the memory to 0 and relies on an arena
     1: // (which comes from the presShell) to perform the allocation.
     1: void*
     1: nsRuleNode::operator new(size_t sz, nsPresContext* aPresContext) CPP_THROW_NEW
     1: {
     1:   // Check the recycle list first.
101694:   return aPresContext->PresShell()->AllocateByObjectID(nsPresArena::nsRuleNode_id, sz);
     1: }
     1: 
 20261: /* static */ PLDHashOperator
 15904: nsRuleNode::EnqueueRuleNodeChildren(PLDHashTable *table, PLDHashEntryHdr *hdr,
108991:                                     uint32_t number, void *arg)
 15904: {
 15904:   ChildrenHashEntry *entry = static_cast<ChildrenHashEntry*>(hdr);
 15904:   nsRuleNode ***destroyQueueTail = static_cast<nsRuleNode***>(arg);
 15904:   **destroyQueueTail = entry->mRuleNode;
 15904:   *destroyQueueTail = &entry->mRuleNode->mNextSibling;
 15904:   return PL_DHASH_NEXT;
 15904: }
 15904: 
     1: // Overridden to prevent the global delete from being called, since the memory
     1: // came out of an nsIArena instead of the global delete operator's heap.
     1: void
 15904: nsRuleNode::DestroyInternal(nsRuleNode ***aDestroyQueueTail)
     1: {
 15904:   nsRuleNode *destroyQueue, **destroyQueueTail;
 15904:   if (aDestroyQueueTail) {
 15904:     destroyQueueTail = *aDestroyQueueTail;
 15904:   } else {
106838:     destroyQueue = nullptr;
 15904:     destroyQueueTail = &destroyQueue;
 15904:   }
 15904: 
 15904:   if (ChildrenAreHashed()) {
 15904:     PLDHashTable *children = ChildrenHash();
 15904:     PL_DHashTableEnumerate(children, EnqueueRuleNodeChildren,
 15904:                            &destroyQueueTail);
106838:     *destroyQueueTail = nullptr; // ensure null-termination
 15904:     PL_DHashTableDestroy(children);
 15904:   } else if (HaveChildren()) {
 15904:     *destroyQueueTail = ChildrenList();
 15904:     do {
 15904:       destroyQueueTail = &(*destroyQueueTail)->mNextSibling;
 15904:     } while (*destroyQueueTail);
 15904:   }
106838:   mChildren.asVoid = nullptr;
 15904: 
 15904:   if (aDestroyQueueTail) {
 15904:     // Our caller destroys the queue.
 15904:     *aDestroyQueueTail = destroyQueueTail;
 15904:   } else {
 15904:     // We have to do destroy the queue.  When we destroy each node, it
 15904:     // will add its children to the queue.
 15904:     while (destroyQueue) {
 15904:       nsRuleNode *cur = destroyQueue;
 15904:       destroyQueue = destroyQueue->mNextSibling;
 15904:       if (!destroyQueue) {
 15904:         NS_ASSERTION(destroyQueueTail == &cur->mNextSibling, "mangled list");
 15904:         destroyQueueTail = &destroyQueue;
 15904:       }
 15904:       cur->DestroyInternal(&destroyQueueTail);
 15904:     }
 15904:   }
 15904: 
     1:   // Destroy ourselves.
     1:   this->~nsRuleNode();
     1: 
     1:   // Don't let the memory be freed, since it will be recycled
     1:   // instead. Don't call the global operator delete.
101694:   mPresContext->PresShell()->FreeByObjectID(nsPresArena::nsRuleNode_id, this);
     1: }
     1: 
     1: nsRuleNode* nsRuleNode::CreateRootNode(nsPresContext* aPresContext)
     1: {
  1539:   return new (aPresContext)
106838:     nsRuleNode(aPresContext, nullptr, nullptr, 0xff, false);
     1: }
     1: 
  1539: nsRuleNode::nsRuleNode(nsPresContext* aContext, nsRuleNode* aParent,
108991:                        nsIStyleRule* aRule, uint8_t aLevel,
 79445:                        bool aIsImportant)
     1:   : mPresContext(aContext),
     1:     mParent(aParent),
     1:     mRule(aRule),
108991:     mDependentBits((uint32_t(aLevel) << NS_RULE_NODE_LEVEL_SHIFT) |
  1539:                    (aIsImportant ? NS_RULE_NODE_IS_IMPORTANT : 0)),
 33020:     mNoneBits(0),
 33020:     mRefCnt(0)
     1: {
123111:   NS_ABORT_IF_FALSE(IsRoot() == !aRule,
123111:                     "non-root rule nodes must have a rule");
123111: 
106838:   mChildren.asVoid = nullptr;
     1:   MOZ_COUNT_CTOR(nsRuleNode);
     1:   NS_IF_ADDREF(mRule);
  1539: 
  1539:   NS_ASSERTION(IsRoot() || GetLevel() == aLevel, "not enough bits");
  1539:   NS_ASSERTION(IsRoot() || IsImportantRule() == aIsImportant, "yikes");
 33020:   /* If IsRoot(), then aContext->StyleSet() is typically null at this
 33020:      point.  In any case, we don't want to treat the root rulenode as
 33020:      unused.  */
 33020:   if (!IsRoot()) {
 33020:     mParent->AddRef();
 33020:     aContext->StyleSet()->RuleNodeUnused();
 33020:   }
 69179: 
 69179:   // nsStyleSet::GetContext depends on there being only one animation
 69179:   // rule.
 69179:   NS_ABORT_IF_FALSE(IsRoot() || GetLevel() != nsStyleSet::eAnimationSheet ||
 69179:                     mParent->IsRoot() ||
 69179:                     mParent->GetLevel() != nsStyleSet::eAnimationSheet,
 69179:                     "must be only one rule at animation level");
     1: }
     1: 
     1: nsRuleNode::~nsRuleNode()
     1: {
     1:   MOZ_COUNT_DTOR(nsRuleNode);
     1:   if (mStyleData.mResetData || mStyleData.mInheritedData)
121241:     mStyleData.Destroy(mDependentBits, mPresContext);
     1:   NS_IF_RELEASE(mRule);
     1: }
     1: 
  1539: nsRuleNode*
108991: nsRuleNode::Transition(nsIStyleRule* aRule, uint8_t aLevel,
 79445:                        bool aIsImportantRule)
     1: {
106838:   nsRuleNode* next = nullptr;
  1539:   nsRuleNode::Key key(aRule, aLevel, aIsImportantRule);
     1: 
     1:   if (HaveChildren() && !ChildrenAreHashed()) {
108991:     int32_t numKids = 0;
 15903:     nsRuleNode* curr = ChildrenList();
 15903:     while (curr && curr->GetKey() != key) {
 15903:       curr = curr->mNextSibling;
     1:       ++numKids;
     1:     }
     1:     if (curr)
 15903:       next = curr;
     1:     else if (numKids >= kMaxChildrenInList)
     1:       ConvertChildrenToHash();
     1:   }
     1: 
     1:   if (ChildrenAreHashed()) {
  3233:     ChildrenHashEntry *entry = static_cast<ChildrenHashEntry*>
  3233:                                           (PL_DHashTableOperate(ChildrenHash(), &key, PL_DHASH_ADD));
     1:     if (!entry) {
 35613:       NS_WARNING("out of memory");
 35613:       return this;
     1:     }
     1:     if (entry->mRuleNode)
     1:       next = entry->mRuleNode;
     1:     else {
  1539:       next = entry->mRuleNode = new (mPresContext)
  1539:         nsRuleNode(mPresContext, this, aRule, aLevel, aIsImportantRule);
     1:       if (!next) {
     1:         PL_DHashTableRawRemove(ChildrenHash(), entry);
 35613:         NS_WARNING("out of memory");
 35613:         return this;
     1:       }
     1:     }
     1:   } else if (!next) {
     1:     // Create the new entry in our list.
  1539:     next = new (mPresContext)
  1539:       nsRuleNode(mPresContext, this, aRule, aLevel, aIsImportantRule);
     1:     if (!next) {
 35613:       NS_WARNING("out of memory");
 35613:       return this;
     1:     }
 15903:     next->mNextSibling = ChildrenList();
 15903:     SetChildrenList(next);
     1:   }
     1: 
  1539:   return next;
     1: }
     1: 
121242: void nsRuleNode::SetUsedDirectly()
121242: {
121242:   mDependentBits |= NS_RULE_NODE_USED_DIRECTLY;
121242: 
121242:   // Maintain the invariant that any rule node that is used directly has
121242:   // all structs that live in the rule tree cached (which
121242:   // nsRuleNode::GetStyleData depends on for speed).
121242:   if (mDependentBits & NS_STYLE_INHERIT_MASK) {
121242:     for (nsStyleStructID sid = nsStyleStructID(0); sid < nsStyleStructID_Length;
121242:          sid = nsStyleStructID(sid + 1)) {
121242:       uint32_t bit = nsCachedStyleData::GetBitForSID(sid);
121242:       if (mDependentBits & bit) {
121242:         nsRuleNode *source = mParent;
121242:         while ((source->mDependentBits & bit) && !source->IsUsedDirectly()) {
121242:           source = source->mParent;
121242:         }
121242:         void *data = source->mStyleData.GetStyleData(sid);
121242:         NS_ASSERTION(data, "unexpected null struct");
121242:         mStyleData.SetStyleData(sid, mPresContext, data);
121242:       }
121242:     }
121242:   }
121242: }
121242: 
     1: void
     1: nsRuleNode::ConvertChildrenToHash()
     1: {
     1:   NS_ASSERTION(!ChildrenAreHashed() && HaveChildren(),
     1:                "must have a non-empty list of children");
106838:   PLDHashTable *hash = PL_NewDHashTable(&ChildrenHashOps, nullptr,
     1:                                         sizeof(ChildrenHashEntry),
     1:                                         kMaxChildrenInList * 4);
     1:   if (!hash)
     1:     return;
 15903:   for (nsRuleNode* curr = ChildrenList(); curr; curr = curr->mNextSibling) {
     1:     // This will never fail because of the initial size we gave the table.
 15903:     ChildrenHashEntry *entry = static_cast<ChildrenHashEntry*>(
 15903:       PL_DHashTableOperate(hash, curr->mRule, PL_DHASH_ADD));
     1:     NS_ASSERTION(!entry->mRuleNode, "duplicate entries in list");
 15903:     entry->mRuleNode = curr;
     1:   }
     1:   SetChildrenHash(hash);
     1: }
     1: 
     1: inline void
108991: nsRuleNode::PropagateNoneBit(uint32_t aBit, nsRuleNode* aHighestNode)
     1: {
     1:   nsRuleNode* curr = this;
     1:   for (;;) {
     1:     NS_ASSERTION(!(curr->mNoneBits & aBit), "propagating too far");
     1:     curr->mNoneBits |= aBit;
     1:     if (curr == aHighestNode)
     1:       break;
     1:     curr = curr->mParent;
     1:   }
     1: }
     1: 
     1: inline void
121242: nsRuleNode::PropagateDependentBit(nsStyleStructID aSID, nsRuleNode* aHighestNode,
121242:                                   void* aStruct)
121242: {
121242:   NS_ASSERTION(aStruct, "expected struct");
121242: 
121242:   uint32_t bit = nsCachedStyleData::GetBitForSID(aSID);
     1:   for (nsRuleNode* curr = this; curr != aHighestNode; curr = curr->mParent) {
121242:     if (curr->mDependentBits & bit) {
     1: #ifdef DEBUG
     1:       while (curr != aHighestNode) {
121242:         NS_ASSERTION(curr->mDependentBits & bit, "bit not set");
     1:         curr = curr->mParent;
     1:       }
     1: #endif
     1:       break;
     1:     }
     1: 
121242:     curr->mDependentBits |= bit;
121242: 
121242:     if (curr->IsUsedDirectly()) {
121242:       curr->mStyleData.SetStyleData(aSID, mPresContext, aStruct);
121242:     }
     1:   }
     1: }
     1: 
     1: /*
     1:  * The following "Check" functions are used for determining what type of
     1:  * sharing can be used for the data on this rule node.  MORE HERE...
     1:  */
     1: 
     1: /*
     1:  * a callback function that that can revise the result of
     1:  * CheckSpecifiedProperties before finishing; aResult is the current
     1:  * result, and it returns the revised one.
     1:  */
     1: typedef nsRuleNode::RuleDetail
 63750:   (* CheckCallbackFn)(const nsRuleData* aRuleData,
     1:                       nsRuleNode::RuleDetail aResult);
     1: 
     1: /**
     1:  * @param aValue the value being examined
     1:  * @param aSpecifiedCount to be incremented by one if the value is specified
     1:  * @param aInherited to be incremented by one if the value is set to inherit
     1:  */
     1: inline void
     1: ExamineCSSValue(const nsCSSValue& aValue,
108991:                 uint32_t& aSpecifiedCount, uint32_t& aInheritedCount)
     1: {
     1:   if (aValue.GetUnit() != eCSSUnit_Null) {
     1:     ++aSpecifiedCount;
     1:     if (aValue.GetUnit() == eCSSUnit_Inherit) {
     1:       ++aInheritedCount;
     1:     }
     1:   }
     1: }
     1: 
 20261: static nsRuleNode::RuleDetail
 63750: CheckFontCallback(const nsRuleData* aRuleData,
     1:                   nsRuleNode::RuleDetail aResult)
     1: {
  3749:   // em, ex, percent, 'larger', and 'smaller' values on font-size depend
  3749:   // on the parent context's font-size
 24408:   // Likewise, 'lighter' and 'bolder' values of 'font-weight', and 'wider'
 24408:   // and 'narrower' values of 'font-stretch' depend on the parent.
 63750:   const nsCSSValue& size = *aRuleData->ValueForFontSize();
 63750:   const nsCSSValue& weight = *aRuleData->ValueForFontWeight();
121562:   if ((size.IsRelativeLengthUnit() && size.GetUnit() != eCSSUnit_RootEM) ||
  3749:       size.GetUnit() == eCSSUnit_Percent ||
  3749:       (size.GetUnit() == eCSSUnit_Enumerated &&
  3749:        (size.GetIntValue() == NS_STYLE_FONT_SIZE_SMALLER ||
  3824:         size.GetIntValue() == NS_STYLE_FONT_SIZE_LARGER)) ||
 63750:       aRuleData->ValueForScriptLevel()->GetUnit() == eCSSUnit_Integer ||
  3824:       (weight.GetUnit() == eCSSUnit_Enumerated &&
  3824:        (weight.GetIntValue() == NS_STYLE_FONT_WEIGHT_BOLDER ||
  3824:         weight.GetIntValue() == NS_STYLE_FONT_WEIGHT_LIGHTER))) {
     1:     NS_ASSERTION(aResult == nsRuleNode::eRulePartialReset ||
     1:                  aResult == nsRuleNode::eRuleFullReset ||
     1:                  aResult == nsRuleNode::eRulePartialMixed ||
     1:                  aResult == nsRuleNode::eRuleFullMixed,
     1:                  "we know we already have a reset-counted property");
  3824:     // Promote reset to mixed since we have something that depends on
  3824:     // the parent.  But never promote to inherited since that could
  3824:     // cause inheritance of the exact value.
     1:     if (aResult == nsRuleNode::eRulePartialReset)
     1:       aResult = nsRuleNode::eRulePartialMixed;
     1:     else if (aResult == nsRuleNode::eRuleFullReset)
     1:       aResult = nsRuleNode::eRuleFullMixed;
     1:   }
     1: 
     1:   return aResult;
     1: }
     1: 
 20261: static nsRuleNode::RuleDetail
 63750: CheckColorCallback(const nsRuleData* aRuleData,
     1:                    nsRuleNode::RuleDetail aResult)
     1: {
     1:   // currentColor values for color require inheritance
 63750:   const nsCSSValue* colorValue = aRuleData->ValueForColor();
 63750:   if (colorValue->GetUnit() == eCSSUnit_EnumColor &&
 63750:       colorValue->GetIntValue() == NS_COLOR_CURRENTCOLOR) {
     1:     NS_ASSERTION(aResult == nsRuleNode::eRuleFullReset,
     1:                  "we should already be counted as full-reset");
     1:     aResult = nsRuleNode::eRuleFullInherited;
     1:   }
     1: 
     1:   return aResult;
     1: }
     1: 
 24695: static nsRuleNode::RuleDetail
 63750: CheckTextCallback(const nsRuleData* aRuleData,
 24695:                   nsRuleNode::RuleDetail aResult)
 24695: {
 63750:   const nsCSSValue* textAlignValue = aRuleData->ValueForTextAlign();
 63750:   if (textAlignValue->GetUnit() == eCSSUnit_Enumerated &&
 63750:       textAlignValue->GetIntValue() ==
 24695:         NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT) {
 24695:     // Promote reset to mixed since we have something that depends on
 24695:     // the parent.
 24695:     if (aResult == nsRuleNode::eRulePartialReset)
 24695:       aResult = nsRuleNode::eRulePartialMixed;
 24695:     else if (aResult == nsRuleNode::eRuleFullReset)
 24695:       aResult = nsRuleNode::eRuleFullMixed;
 24695:   }
 24695: 
 24695:   return aResult;
 24695: }
     1: 
 98179: #define FLAG_DATA_FOR_PROPERTY(name_, id_, method_, flags_, pref_,          \
 98179:                                parsevariant_, kwtable_, stylestructoffset_, \
 98179:                                animtype_)                                   \
 63750:   flags_,
 63750: 
 63750: // The order here must match the enums in *CheckCounter in nsCSSProps.cpp.
 63750: 
108991: static const uint32_t gFontFlags[] = {
 63750: #define CSS_PROP_FONT FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_FONT
     1: };
     1: 
108991: static const uint32_t gDisplayFlags[] = {
 63750: #define CSS_PROP_DISPLAY FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_DISPLAY
     1: };
     1: 
108991: static const uint32_t gVisibilityFlags[] = {
 63750: #define CSS_PROP_VISIBILITY FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_VISIBILITY
     1: };
     1: 
108991: static const uint32_t gMarginFlags[] = {
 63750: #define CSS_PROP_MARGIN FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_MARGIN
     1: };
     1: 
108991: static const uint32_t gBorderFlags[] = {
 63750: #define CSS_PROP_BORDER FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_BORDER
     1: };
     1: 
108991: static const uint32_t gPaddingFlags[] = {
 63750: #define CSS_PROP_PADDING FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_PADDING
     1: };
     1: 
108991: static const uint32_t gOutlineFlags[] = {
 63750: #define CSS_PROP_OUTLINE FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_OUTLINE
     1: };
     1: 
108991: static const uint32_t gListFlags[] = {
 63750: #define CSS_PROP_LIST FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_LIST
     1: };
     1: 
108991: static const uint32_t gColorFlags[] = {
 63750: #define CSS_PROP_COLOR FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_COLOR
     1: };
     1: 
108991: static const uint32_t gBackgroundFlags[] = {
 63750: #define CSS_PROP_BACKGROUND FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_BACKGROUND
     1: };
     1: 
108991: static const uint32_t gPositionFlags[] = {
 63750: #define CSS_PROP_POSITION FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_POSITION
     1: };
     1: 
108991: static const uint32_t gTableFlags[] = {
 63750: #define CSS_PROP_TABLE FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_TABLE
     1: };
     1: 
108991: static const uint32_t gTableBorderFlags[] = {
 63750: #define CSS_PROP_TABLEBORDER FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_TABLEBORDER
     1: };
     1: 
108991: static const uint32_t gContentFlags[] = {
 63750: #define CSS_PROP_CONTENT FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_CONTENT
     1: };
     1: 
108991: static const uint32_t gQuotesFlags[] = {
 63750: #define CSS_PROP_QUOTES FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_QUOTES
     1: };
     1: 
108991: static const uint32_t gTextFlags[] = {
 63750: #define CSS_PROP_TEXT FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_TEXT
     1: };
     1: 
108991: static const uint32_t gTextResetFlags[] = {
 63750: #define CSS_PROP_TEXTRESET FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_TEXTRESET
     1: };
     1: 
108991: static const uint32_t gUserInterfaceFlags[] = {
 63750: #define CSS_PROP_USERINTERFACE FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_USERINTERFACE
     1: };
     1: 
108991: static const uint32_t gUIResetFlags[] = {
 63750: #define CSS_PROP_UIRESET FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_UIRESET
     1: };
     1: 
108991: static const uint32_t gXULFlags[] = {
 63750: #define CSS_PROP_XUL FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_XUL
     1: };
     1: 
108991: static const uint32_t gSVGFlags[] = {
 63750: #define CSS_PROP_SVG FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_SVG
     1: };
     1: 
108991: static const uint32_t gSVGResetFlags[] = {
 63750: #define CSS_PROP_SVGRESET FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_SVGRESET
     1: };
     1: 
108991: static const uint32_t gColumnFlags[] = {
 63750: #define CSS_PROP_COLUMN FLAG_DATA_FOR_PROPERTY
     1: #include "nsCSSPropList.h"
     1: #undef CSS_PROP_COLUMN
     1: };
     1: 
 63750: #undef FLAG_DATA_FOR_PROPERTY
 63750: 
108991: static const uint32_t* gFlagsByStruct[] = {
     1: 
     1: #define STYLE_STRUCT(name, checkdata_cb, ctor_args) \
 63750:   g##name##Flags,
     1: #include "nsStyleStructList.h"
     1: #undef STYLE_STRUCT
     1: 
     1: };
     1: 
 63750: static const CheckCallbackFn gCheckCallbacks[] = {
 63750: 
 63750: #define STYLE_STRUCT(name, checkdata_cb, ctor_args) \
 63750:   checkdata_cb,
 63750: #include "nsStyleStructList.h"
 63750: #undef STYLE_STRUCT
 63750: 
 63750: };
     1: 
 71203: #ifdef DEBUG
 79445: static bool
 63750: AreAllMathMLPropertiesUndefined(const nsRuleData* aRuleData)
 10073: {
 63750:   return
 63750:     aRuleData->ValueForScriptLevel()->GetUnit() == eCSSUnit_Null &&
 63750:     aRuleData->ValueForScriptSizeMultiplier()->GetUnit() == eCSSUnit_Null &&
 63750:     aRuleData->ValueForScriptMinSize()->GetUnit() == eCSSUnit_Null;
 10073: }
 10073: #endif
 10073: 
     1: inline nsRuleNode::RuleDetail
     1: nsRuleNode::CheckSpecifiedProperties(const nsStyleStructID aSID,
 63750:                                      const nsRuleData* aRuleData)
     1: {
     1:   // Build a count of the:
108991:   uint32_t total = 0,      // total number of props in the struct
     1:            specified = 0,  // number that were specified for this node
     1:            inherited = 0;  // number that were 'inherit' (and not
     1:                            //   eCSSUnit_Inherit) for this node
     1: 
 63750:   // See comment in nsRuleData.h above mValueOffsets.
 63750:   NS_ABORT_IF_FALSE(aRuleData->mValueOffsets[aSID] == 0,
 63750:                     "we assume the value offset is zero instead of adding it");
 63750:   for (nsCSSValue *values = aRuleData->mValueStorage,
 63750:               *values_end = values + nsCSSProps::PropertyCountInStruct(aSID);
 63750:        values != values_end; ++values) {
     1:     ++total;
 63750:     ExamineCSSValue(*values, specified, inherited);
     1:   }
     1: 
     1: #if 0
     1:   printf("CheckSpecifiedProperties: SID=%d total=%d spec=%d inh=%d.\n",
     1:          aSID, total, specified, inherited);
     1: #endif
     1: 
 10073:   NS_ASSERTION(aSID != eStyleStruct_Font ||
 10073:                mPresContext->Document()->GetMathMLEnabled() ||
 63750:                AreAllMathMLPropertiesUndefined(aRuleData),
 10073:                "MathML style property was defined even though MathML is disabled");
 10073: 
     1:   /*
     1:    * Return the most specific information we can: prefer None or Full
     1:    * over Partial, and Reset or Inherited over Mixed, since we can
     1:    * optimize based on the edge cases and not the in-between cases.
     1:    */
     1:   nsRuleNode::RuleDetail result;
     1:   if (inherited == total)
     1:     result = eRuleFullInherited;
 10073:   else if (specified == total
 10073:            // MathML defines 3 properties in Font that will never be set when
 10073:            // MathML is not in use. Therefore if all but three
 10073:            // properties have been set, and MathML is not enabled, we can treat
 10073:            // this as fully specified. Code in nsMathMLElementFactory will
 10073:            // rebuild the rule tree and style data when MathML is first enabled
 10073:            // (see nsMathMLElement::BindToTree).
 10073:            || (aSID == eStyleStruct_Font && specified + 3 == total &&
 10073:                !mPresContext->Document()->GetMathMLEnabled())
 10073:           ) {
     1:     if (inherited == 0)
     1:       result = eRuleFullReset;
     1:     else
     1:       result = eRuleFullMixed;
     1:   } else if (specified == 0)
     1:     result = eRuleNone;
     1:   else if (specified == inherited)
     1:     result = eRulePartialInherited;
     1:   else if (inherited == 0)
     1:     result = eRulePartialReset;
     1:   else
     1:     result = eRulePartialMixed;
     1: 
 63750:   CheckCallbackFn cb = gCheckCallbacks[aSID];
 63750:   if (cb) {
 63750:     result = (*cb)(aRuleData, result);
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
 22737: // If we need to restrict which properties apply to the style context,
 22737: // return the bit to check in nsCSSProp's flags table.  Otherwise,
 22737: // return 0.
108991: inline uint32_t
 22737: GetPseudoRestriction(nsStyleContext *aContext)
 22737: {
 22737:   // This needs to match nsStyleSet::WalkRestrictionRule.
108991:   uint32_t pseudoRestriction = 0;
 34387:   nsIAtom *pseudoType = aContext->GetPseudo();
 22737:   if (pseudoType) {
 22737:     if (pseudoType == nsCSSPseudoElements::firstLetter) {
 22737:       pseudoRestriction = CSS_PROPERTY_APPLIES_TO_FIRST_LETTER;
 22737:     } else if (pseudoType == nsCSSPseudoElements::firstLine) {
 22737:       pseudoRestriction = CSS_PROPERTY_APPLIES_TO_FIRST_LINE;
121456:     } else if (pseudoType == nsCSSPseudoElements::mozPlaceholder) {
121456:       pseudoRestriction = CSS_PROPERTY_APPLIES_TO_PLACEHOLDER;
 22737:     }
 22737:   }
 22737:   return pseudoRestriction;
 22737: }
 22737: 
 22737: static void
 22737: UnsetPropertiesWithoutFlags(const nsStyleStructID aSID,
 63750:                             nsRuleData* aRuleData,
108991:                             uint32_t aFlags)
 22737: {
 22737:   NS_ASSERTION(aFlags != 0, "aFlags must be nonzero");
 63750: 
108991:   const uint32_t *flagData = gFlagsByStruct[aSID];
 63750: 
 63750:   // See comment in nsRuleData.h above mValueOffsets.
 63750:   NS_ABORT_IF_FALSE(aRuleData->mValueOffsets[aSID] == 0,
 63750:                     "we assume the value offset is zero instead of adding it");
 63750:   nsCSSValue *values = aRuleData->mValueStorage;
 63750: 
 63750:   for (size_t i = 0, i_end = nsCSSProps::PropertyCountInStruct(aSID);
 63750:        i != i_end; ++i) {
 63750:     if ((flagData[i] & aFlags) != aFlags)
 63750:       values[i].Reset();
 63750:   }
 63750: }
 63750: 
 63750: /**
 63750:  * We allocate arrays of CSS values with alloca.  (These arrays are a
 63750:  * fixed size per style struct, but we don't want to waste the
 63750:  * allocation and construction/destruction costs of the big structs when
 63750:  * we're handling much smaller ones.)  Since the lifetime of an alloca
 63750:  * allocation is the life of the calling function, the caller must call
 63750:  * alloca.  However, to ensure that constructors and destructors are
 63750:  * balanced, we do the constructor and destructor calling from this RAII
 63750:  * class, AutoCSSValueArray.
 63750:  */
 63750: struct AutoCSSValueArray {
 63750:   /**
 63750:    * aStorage must be the result of alloca(aCount * sizeof(nsCSSValue))
 63750:    */
 63750:   AutoCSSValueArray(void* aStorage, size_t aCount) {
 63750:     NS_ABORT_IF_FALSE(size_t(aStorage) % NS_ALIGNMENT_OF(nsCSSValue) == 0,
 63750:                       "bad alignment from alloca");
 63750:     mCount = aCount;
 63762:     // Don't use placement new[], since it might store extra data
 63762:     // for the count (on Windows!).
 63762:     mArray = static_cast<nsCSSValue*>(aStorage);
 63762:     for (size_t i = 0; i < mCount; ++i) {
 63762:       new (mArray + i) nsCSSValue();
 63762:     }
 63750:   }
 63750: 
 63750:   ~AutoCSSValueArray() {
 63750:     for (size_t i = 0; i < mCount; ++i) {
 63750:       mArray[i].~nsCSSValue();
 63750:     }
 63750:   }
 63750: 
 63750:   nsCSSValue* get() { return mArray; }
 63750: 
 63750: private:
 63750:   nsCSSValue *mArray;
 63750:   size_t mCount;
 63750: };
 22737: 
 10152: const void*
     1: nsRuleNode::WalkRuleTree(const nsStyleStructID aSID,
 63750:                          nsStyleContext* aContext)
     1: {
 63750:   // use placement new[] on the result of alloca() to allocate a
 63750:   // variable-sized stack array, including execution of constructors,
 63750:   // and use an RAII class to run the destructors too.
 63750:   size_t nprops = nsCSSProps::PropertyCountInStruct(aSID);
 63750:   void* dataStorage = alloca(nprops * sizeof(nsCSSValue));
 63750:   AutoCSSValueArray dataArray(dataStorage, nprops);
 63754: 
 63754:   nsRuleData ruleData(nsCachedStyleData::GetBitForSID(aSID),
 63754:                       dataArray.get(), mPresContext, aContext);
 63750:   ruleData.mValueOffsets[aSID] = 0;
 63750: 
     1:   // We start at the most specific rule in the tree.
106838:   void* startStruct = nullptr;
     1: 
     1:   nsRuleNode* ruleNode = this;
106838:   nsRuleNode* highestNode = nullptr; // The highest node in the rule tree
     1:                                     // that has the same properties
     1:                                     // specified for struct |aSID| as
     1:                                     // |this| does.
     1:   nsRuleNode* rootNode = this; // After the loop below, this will be the
     1:                                // highest node that we've walked without
     1:                                // finding cached data on the rule tree.
     1:                                // If we don't find any cached data, it
     1:                                // will be the root.  (XXX misnamed)
     1:   RuleDetail detail = eRuleNone;
108991:   uint32_t bit = nsCachedStyleData::GetBitForSID(aSID);
     1: 
     1:   while (ruleNode) {
     1:     // See if this rule node has cached the fact that the remaining
     1:     // nodes along this path specify no data whatsoever.
     1:     if (ruleNode->mNoneBits & bit)
     1:       break;
     1: 
     1:     // If the dependent bit is set on a rule node for this struct, that
     1:     // means its rule won't have any information to add, so skip it.
121242:     // NOTE: If we exit the loop because of the !IsUsedDirectly() check,
121242:     // then we're guaranteed to break immediately afterwards due to a
121242:     // non-null startStruct.
121242:     while ((ruleNode->mDependentBits & bit) && !ruleNode->IsUsedDirectly()) {
106838:       NS_ASSERTION(ruleNode->mStyleData.GetStyleData(aSID) == nullptr,
     1:                    "dependent bit with cached data makes no sense");
     1:       // Climb up to the next rule in the tree (a less specific rule).
     1:       rootNode = ruleNode;
     1:       ruleNode = ruleNode->mParent;
     1:       NS_ASSERTION(!(ruleNode->mNoneBits & bit), "can't have both bits set");
     1:     }
     1: 
     1:     // Check for cached data after the inner loop above -- otherwise
     1:     // we'll miss it.
     1:     startStruct = ruleNode->mStyleData.GetStyleData(aSID);
     1:     if (startStruct)
     1:       break; // We found a rule with fully specified data.  We don't
     1:              // need to go up the tree any further, since the remainder
     1:              // of this branch has already been computed.
     1: 
     1:     // Ask the rule to fill in the properties that it specifies.
     1:     nsIStyleRule *rule = ruleNode->mRule;
  1540:     if (rule) {
 63750:       ruleData.mLevel = ruleNode->GetLevel();
 63750:       ruleData.mIsImportantRule = ruleNode->IsImportantRule();
 63750:       rule->MapRuleInfoInto(&ruleData);
  1540:     }
     1: 
     1:     // Now we check to see how many properties have been specified by
     1:     // the rules we've examined so far.
     1:     RuleDetail oldDetail = detail;
 63750:     detail = CheckSpecifiedProperties(aSID, &ruleData);
     1: 
     1:     if (oldDetail == eRuleNone && detail != eRuleNone)
     1:       highestNode = ruleNode;
     1: 
     1:     if (detail == eRuleFullReset ||
     1:         detail == eRuleFullMixed ||
     1:         detail == eRuleFullInherited)
     1:       break; // We don't need to examine any more rules.  All properties
     1:              // have been fully specified.
     1: 
     1:     // Climb up to the next rule in the tree (a less specific rule).
     1:     rootNode = ruleNode;
     1:     ruleNode = ruleNode->mParent;
     1:   }
     1: 
 22737:   // If needed, unset the properties that don't have a flag that allows
 22737:   // them to be set for this style context.  (For example, only some
 22737:   // properties apply to :first-line and :first-letter.)
108991:   uint32_t pseudoRestriction = GetPseudoRestriction(aContext);
 22737:   if (pseudoRestriction) {
 63750:     UnsetPropertiesWithoutFlags(aSID, &ruleData, pseudoRestriction);
 22737: 
 22737:     // Recompute |detail| based on the restrictions we just applied.
 22737:     // We can adjust |detail| arbitrarily because of the restriction
 22737:     // rule added in nsStyleSet::WalkRestrictionRule.
 63750:     detail = CheckSpecifiedProperties(aSID, &ruleData);
 22737:   }
 22737: 
  3824:   NS_ASSERTION(!startStruct || (detail != eRuleFullReset &&
  3824:                                 detail != eRuleFullMixed &&
  3824:                                 detail != eRuleFullInherited),
  3824:                "can't have start struct and be fully specified");
  3824: 
 79445:   bool isReset = nsCachedStyleData::IsReset(aSID);
     1:   if (!highestNode)
     1:     highestNode = rootNode;
     1: 
 63750:   if (!ruleData.mCanStoreInRuleTree)
     1:     detail = eRulePartialMixed; // Treat as though some data is specified to avoid
     1:                                 // the optimizations and force data computation.
     1: 
 63750:   if (detail == eRuleNone && startStruct && !ruleData.mPostResolveCallback) {
     1:     // We specified absolutely no rule information, but a parent rule in the tree
     1:     // specified all the rule information.  We set a bit along the branch from our
     1:     // node in the tree to the node that specified the data that tells nodes on that
     1:     // branch that they never need to examine their rules for this particular struct type
     1:     // ever again.
121242:     PropagateDependentBit(aSID, ruleNode, startStruct);
     1:     return startStruct;
     1:   }
 33659:   // FIXME Do we need to check for mPostResolveCallback?
  3824:   if ((!startStruct && !isReset &&
  3824:        (detail == eRuleNone || detail == eRulePartialInherited)) ||
  3824:       detail == eRuleFullInherited) {
     1:     // We specified no non-inherited information and neither did any of
     1:     // our parent rules.
     1: 
     1:     // We set a bit along the branch from the highest node (ruleNode)
     1:     // down to our node (this) indicating that no non-inherited data was
     1:     // specified.  This bit is guaranteed to be set already on the path
     1:     // from the highest node to the root node in the case where
     1:     // (detail == eRuleNone), which is the most common case here.
     1:     // We must check |!isReset| because the Compute*Data functions for
     1:     // reset structs wouldn't handle none bits correctly.
     1:     if (highestNode != this && !isReset)
     1:       PropagateNoneBit(bit, highestNode);
     1: 
     1:     // All information must necessarily be inherited from our parent style context.
     1:     // In the absence of any computed data in the rule tree and with
     1:     // no rules specified that didn't have values of 'inherit', we should check our parent.
     1:     nsStyleContext* parentContext = aContext->GetParent();
 20669:     if (isReset) {
 20669:       /* Reset structs don't inherit from first-line. */
 20669:       /* See similar code in COMPUTE_START_RESET */
 20669:       while (parentContext &&
 34387:              parentContext->GetPseudo() == nsCSSPseudoElements::firstLine) {
 20669:         parentContext = parentContext->GetParent();
 20669:       }
 20669:     }
     1:     if (parentContext) {
     1:       // We have a parent, and so we should just inherit from the parent.
     1:       // Set the inherit bits on our context.  These bits tell the style context that
     1:       // it never has to go back to the rule tree for data.  Instead the style context tree
     1:       // should be walked to find the data.
 10152:       const void* parentStruct = parentContext->GetStyleData(aSID);
     1:       aContext->AddStyleBit(bit); // makes const_cast OK.
 10152:       aContext->SetStyle(aSID, const_cast<void*>(parentStruct));
     1:       return parentStruct;
     1:     }
     1:     else
     1:       // We are the root.  In the case of fonts, the default values just
     1:       // come from the pres context.
     1:       return SetDefaultOnRoot(aSID, aContext);
     1:   }
     1: 
     1:   // We need to compute the data from the information that the rules specified.
 10152:   const void* res;
     1: #define STYLE_STRUCT_TEST aSID
     1: #define STYLE_STRUCT(name, checkdata_cb, ctor_args)                           \
 63750:   res = Compute##name##Data(startStruct, &ruleData, aContext,                 \
 63750:                             highestNode, detail, ruleData.mCanStoreInRuleTree);
     1: #include "nsStyleStructList.h"
     1: #undef STYLE_STRUCT
     1: #undef STYLE_STRUCT_TEST
     1: 
 33659:   // If we have a post-resolve callback, handle that now.
120353:   if (ruleData.mPostResolveCallback && (MOZ_LIKELY(res != nullptr)))
 63750:     (*ruleData.mPostResolveCallback)(const_cast<void*>(res), &ruleData);
     1: 
     1:   // Now return the result.
     1:   return res;
     1: }
     1: 
 10152: const void*
     1: nsRuleNode::SetDefaultOnRoot(const nsStyleStructID aSID, nsStyleContext* aContext)
     1: {
     1:   switch (aSID) {
     1:     case eStyleStruct_Font:
     1:     {
     1:       nsStyleFont* fontData = new (mPresContext) nsStyleFont(mPresContext);
 90439:       nscoord minimumFontSize = mPresContext->MinFontSize(fontData->mLanguage);
     1: 
  1540:       if (minimumFontSize > 0 && !mPresContext->IsChrome()) {
 32531:         fontData->mFont.size = NS_MAX(fontData->mSize, minimumFontSize);
     1:       }
     1:       else {
     1:         fontData->mFont.size = fontData->mSize;
     1:       }
     1:       aContext->SetStyle(eStyleStruct_Font, fontData);
     1:       return fontData;
     1:     }
     1:     case eStyleStruct_Display:
     1:     {
     1:       nsStyleDisplay* disp = new (mPresContext) nsStyleDisplay();
     1:       aContext->SetStyle(eStyleStruct_Display, disp);
     1:       return disp;
     1:     }
     1:     case eStyleStruct_Visibility:
     1:     {
     1:       nsStyleVisibility* vis = new (mPresContext) nsStyleVisibility(mPresContext);
     1:       aContext->SetStyle(eStyleStruct_Visibility, vis);
     1:       return vis;
     1:     }
     1:     case eStyleStruct_Text:
     1:     {
     1:       nsStyleText* text = new (mPresContext) nsStyleText();
     1:       aContext->SetStyle(eStyleStruct_Text, text);
     1:       return text;
     1:     }
     1:     case eStyleStruct_TextReset:
     1:     {
     1:       nsStyleTextReset* text = new (mPresContext) nsStyleTextReset();
     1:       aContext->SetStyle(eStyleStruct_TextReset, text);
     1:       return text;
     1:     }
     1:     case eStyleStruct_Color:
     1:     {
     1:       nsStyleColor* color = new (mPresContext) nsStyleColor(mPresContext);
     1:       aContext->SetStyle(eStyleStruct_Color, color);
     1:       return color;
     1:     }
     1:     case eStyleStruct_Background:
     1:     {
 19182:       nsStyleBackground* bg = new (mPresContext) nsStyleBackground();
     1:       aContext->SetStyle(eStyleStruct_Background, bg);
     1:       return bg;
     1:     }
     1:     case eStyleStruct_Margin:
     1:     {
     1:       nsStyleMargin* margin = new (mPresContext) nsStyleMargin();
     1:       aContext->SetStyle(eStyleStruct_Margin, margin);
     1:       return margin;
     1:     }
     1:     case eStyleStruct_Border:
     1:     {
     1:       nsStyleBorder* border = new (mPresContext) nsStyleBorder(mPresContext);
     1:       aContext->SetStyle(eStyleStruct_Border, border);
     1:       return border;
     1:     }
     1:     case eStyleStruct_Padding:
     1:     {
     1:       nsStylePadding* padding = new (mPresContext) nsStylePadding();
     1:       aContext->SetStyle(eStyleStruct_Padding, padding);
     1:       return padding;
     1:     }
     1:     case eStyleStruct_Outline:
     1:     {
     1:       nsStyleOutline* outline = new (mPresContext) nsStyleOutline(mPresContext);
     1:       aContext->SetStyle(eStyleStruct_Outline, outline);
     1:       return outline;
     1:     }
     1:     case eStyleStruct_List:
     1:     {
     1:       nsStyleList* list = new (mPresContext) nsStyleList();
     1:       aContext->SetStyle(eStyleStruct_List, list);
     1:       return list;
     1:     }
     1:     case eStyleStruct_Position:
     1:     {
     1:       nsStylePosition* pos = new (mPresContext) nsStylePosition();
     1:       aContext->SetStyle(eStyleStruct_Position, pos);
     1:       return pos;
     1:     }
     1:     case eStyleStruct_Table:
     1:     {
     1:       nsStyleTable* table = new (mPresContext) nsStyleTable();
     1:       aContext->SetStyle(eStyleStruct_Table, table);
     1:       return table;
     1:     }
     1:     case eStyleStruct_TableBorder:
     1:     {
     1:       nsStyleTableBorder* table = new (mPresContext) nsStyleTableBorder(mPresContext);
     1:       aContext->SetStyle(eStyleStruct_TableBorder, table);
     1:       return table;
     1:     }
     1:     case eStyleStruct_Content:
     1:     {
     1:       nsStyleContent* content = new (mPresContext) nsStyleContent();
     1:       aContext->SetStyle(eStyleStruct_Content, content);
     1:       return content;
     1:     }
     1:     case eStyleStruct_Quotes:
     1:     {
     1:       nsStyleQuotes* quotes = new (mPresContext) nsStyleQuotes();
     1:       aContext->SetStyle(eStyleStruct_Quotes, quotes);
     1:       return quotes;
     1:     }
     1:     case eStyleStruct_UserInterface:
     1:     {
     1:       nsStyleUserInterface* ui = new (mPresContext) nsStyleUserInterface();
     1:       aContext->SetStyle(eStyleStruct_UserInterface, ui);
     1:       return ui;
     1:     }
     1:     case eStyleStruct_UIReset:
     1:     {
     1:       nsStyleUIReset* ui = new (mPresContext) nsStyleUIReset();
     1:       aContext->SetStyle(eStyleStruct_UIReset, ui);
     1:       return ui;
     1:     }
     1: 
     1:     case eStyleStruct_XUL:
     1:     {
     1:       nsStyleXUL* xul = new (mPresContext) nsStyleXUL();
     1:       aContext->SetStyle(eStyleStruct_XUL, xul);
     1:       return xul;
     1:     }
     1: 
     1:     case eStyleStruct_Column:
     1:     {
 16055:       nsStyleColumn* column = new (mPresContext) nsStyleColumn(mPresContext);
     1:       aContext->SetStyle(eStyleStruct_Column, column);
     1:       return column;
     1:     }
     1: 
     1:     case eStyleStruct_SVG:
     1:     {
     1:       nsStyleSVG* svg = new (mPresContext) nsStyleSVG();
     1:       aContext->SetStyle(eStyleStruct_SVG, svg);
     1:       return svg;
     1:     }
     1: 
     1:     case eStyleStruct_SVGReset:
     1:     {
     1:       nsStyleSVGReset* svgReset = new (mPresContext) nsStyleSVGReset();
     1:       aContext->SetStyle(eStyleStruct_SVGReset, svgReset);
     1:       return svgReset;
     1:     }
 19300:     default:
 19300:       /*
 19300:        * unhandled case: nsStyleStructID_Length.
 19300:        * last item of nsStyleStructID, to know its length.
 19300:        */
121507:       NS_ABORT_IF_FALSE(false, "unexpected SID");
106838:       return nullptr;
106838:   }
106838:   return nullptr;
     1: }
     1: 
     1: /*
     1:  * This function handles cascading of *-left or *-right box properties
     1:  * against *-start (which is L for LTR and R for RTL) or *-end (which is
     1:  * R for LTR and L for RTL).
     1:  *
     1:  * Cascading these properties correctly is hard because we need to
     1:  * cascade two properties as one, but which two properties depends on a
     1:  * third property ('direction').  We solve this by treating each of
     1:  * these properties (say, 'margin-start') as a shorthand that sets a
     1:  * property containing the value of the property specified
     1:  * ('margin-start-value') and sets a pair of properties
     1:  * ('margin-left-ltr-source' and 'margin-right-rtl-source') saying which
     1:  * of the properties we use.  Thus, when we want to compute the value of
     1:  * 'margin-left' when 'direction' is 'ltr', we look at the value of
     1:  * 'margin-left-ltr-source', which tells us whether to use the highest
     1:  * 'margin-left' in the cascade or the highest 'margin-start'.
     1:  *
     1:  * Finally, since we can compute the normal (*-left and *-right)
  3133:  * properties in a loop, this function works by modifying the data we
  3133:  * will use in that loop (which the caller must copy from the const
  3133:  * input).
     1:  */
     1: void
     1: nsRuleNode::AdjustLogicalBoxProp(nsStyleContext* aContext,
     1:                                  const nsCSSValue& aLTRSource,
     1:                                  const nsCSSValue& aRTLSource,
     1:                                  const nsCSSValue& aLTRLogicalValue,
     1:                                  const nsCSSValue& aRTLLogicalValue,
 41419:                                  mozilla::css::Side aSide,
  3133:                                  nsCSSRect& aValueRect,
 79445:                                  bool& aCanStoreInRuleTree)
     1: {
 79445:   bool LTRlogical = aLTRSource.GetUnit() == eCSSUnit_Enumerated &&
     1:                       aLTRSource.GetIntValue() == NS_BOXPROP_SOURCE_LOGICAL;
 79445:   bool RTLlogical = aRTLSource.GetUnit() == eCSSUnit_Enumerated &&
     1:                       aRTLSource.GetIntValue() == NS_BOXPROP_SOURCE_LOGICAL;
     1:   if (LTRlogical || RTLlogical) {
     1:     // We can't cache anything on the rule tree if we use any data from
     1:     // the style context, since data cached in the rule tree could be
     1:     // used with a style context with a different value.
 80486:     aCanStoreInRuleTree = false;
108991:     uint8_t dir = aContext->GetStyleVisibility()->mDirection;
     1: 
     1:     if (dir == NS_STYLE_DIRECTION_LTR) {
  3133:       if (LTRlogical)
  3133:         aValueRect.*(nsCSSRect::sides[aSide]) = aLTRLogicalValue;
     1:     } else {
  3133:       if (RTLlogical)
  3133:         aValueRect.*(nsCSSRect::sides[aSide]) = aRTLLogicalValue;
     1:     }
 40124:   } else if (aLTRLogicalValue.GetUnit() == eCSSUnit_Inherit ||
 40124:              aRTLLogicalValue.GetUnit() == eCSSUnit_Inherit) {
 40124:     // It actually is valid to store this in the ruletree, since
 40124:     // LTRlogical and RTLlogical are both false, but doing that will
 40124:     // trigger asserts.  Silence those.
 80486:     aCanStoreInRuleTree = false;
     1:   }
     1: }
     1: 
     1: /**
     1:  * Begin an nsRuleNode::Compute*Data function for an inherited struct.
     1:  *
     1:  * @param type_ The nsStyle* type this function computes.
     1:  * @param ctorargs_ The arguments used for the default nsStyle* constructor.
     1:  * @param data_ Variable (declared here) holding the result of this
     1:  *              function.
     1:  * @param parentdata_ Variable (declared here) holding the parent style
     1:  *                    context's data for this struct.
     1:  */
 63747: #define COMPUTE_START_INHERITED(type_, ctorargs_, data_, parentdata_)         \
  3824:   NS_ASSERTION(aRuleDetail != eRuleFullInherited,                             \
  3824:                "should not have bothered calling Compute*Data");              \
  3824:                                                                               \
     1:   nsStyleContext* parentContext = aContext->GetParent();                      \
     1:                                                                               \
106838:   nsStyle##type_* data_ = nullptr;                                             \
106838:   const nsStyle##type_* parentdata_ = nullptr;                                 \
 79445:   bool canStoreInRuleTree = aCanStoreInRuleTree;                            \
     1:                                                                               \
 31217:   /* If |canStoreInRuleTree| might be true by the time we're done, we */      \
 24636:   /* can't call parentContext->GetStyle##type_() since it could recur into */ \
 24636:   /* setting the same struct on the same rule node, causing a leak. */        \
  3824:   if (parentContext && aRuleDetail != eRuleFullReset &&                       \
  3824:       (!aStartStruct || (aRuleDetail != eRulePartialReset &&                  \
  3824:                          aRuleDetail != eRuleNone)))                          \
     1:     parentdata_ = parentContext->GetStyle##type_();                           \
     1:   if (aStartStruct)                                                           \
     1:     /* We only need to compute the delta between this computed data and */    \
     1:     /* our computed data. */                                                  \
     1:     data_ = new (mPresContext)                                                \
  3233:             nsStyle##type_(*static_cast<nsStyle##type_*>(aStartStruct));      \
     1:   else {                                                                      \
     1:     if (aRuleDetail != eRuleFullMixed && aRuleDetail != eRuleFullReset) {     \
     1:       /* No question. We will have to inherit. Go ahead and init */           \
     1:       /* with inherited vals from parent. */                                  \
 80486:       canStoreInRuleTree = false;                                          \
     1:       if (parentdata_)                                                        \
     1:         data_ = new (mPresContext) nsStyle##type_(*parentdata_);              \
     1:       else                                                                    \
     1:         data_ = new (mPresContext) nsStyle##type_ ctorargs_;                  \
     1:     }                                                                         \
     1:     else                                                                      \
     1:       data_ = new (mPresContext) nsStyle##type_ ctorargs_;                    \
     1:   }                                                                           \
     1:                                                                               \
     1:   if (!parentdata_)                                                           \
     1:     parentdata_ = data_;
     1: 
     1: /**
     1:  * Begin an nsRuleNode::Compute*Data function for a reset struct.
     1:  *
     1:  * @param type_ The nsStyle* type this function computes.
     1:  * @param ctorargs_ The arguments used for the default nsStyle* constructor.
     1:  * @param data_ Variable (declared here) holding the result of this
     1:  *              function.
     1:  * @param parentdata_ Variable (declared here) holding the parent style
     1:  *                    context's data for this struct.
     1:  */
 63747: #define COMPUTE_START_RESET(type_, ctorargs_, data_, parentdata_)             \
  3824:   NS_ASSERTION(aRuleDetail != eRuleFullInherited,                             \
  3824:                "should not have bothered calling Compute*Data");              \
  3824:                                                                               \
     1:   nsStyleContext* parentContext = aContext->GetParent();                      \
 20669:   /* Reset structs don't inherit from first-line */                           \
 20669:   /* See similar code in WalkRuleTree */                                      \
 20669:   while (parentContext &&                                                     \
 34387:          parentContext->GetPseudo() == nsCSSPseudoElements::firstLine) {      \
  7656:     parentContext = parentContext->GetParent();                               \
  7656:   }                                                                           \
     1:                                                                               \
     1:   nsStyle##type_* data_;                                                      \
     1:   if (aStartStruct)                                                           \
     1:     /* We only need to compute the delta between this computed data and */    \
     1:     /* our computed data. */                                                  \
     1:     data_ = new (mPresContext)                                                \
  3233:             nsStyle##type_(*static_cast<nsStyle##type_*>(aStartStruct));      \
     1:   else                                                                        \
     1:     data_ = new (mPresContext) nsStyle##type_ ctorargs_;                      \
     1:                                                                               \
 31217:   /* If |canStoreInRuleTree| might be true by the time we're done, we */      \
 24636:   /* can't call parentContext->GetStyle##type_() since it could recur into */ \
 24636:   /* setting the same struct on the same rule node, causing a leak. */        \
     1:   const nsStyle##type_* parentdata_ = data_;                                  \
     1:   if (parentContext &&                                                        \
     1:       aRuleDetail != eRuleFullReset &&                                        \
     1:       aRuleDetail != eRulePartialReset &&                                     \
     1:       aRuleDetail != eRuleNone)                                               \
     1:     parentdata_ = parentContext->GetStyle##type_();                           \
 79445:   bool canStoreInRuleTree = aCanStoreInRuleTree;
     1: 
     1: /**
     1:  * Begin an nsRuleNode::Compute*Data function for an inherited struct.
     1:  *
     1:  * @param type_ The nsStyle* type this function computes.
     1:  * @param data_ Variable holding the result of this function.
     1:  */
     1: #define COMPUTE_END_INHERITED(type_, data_)                                   \
 31217:   NS_POSTCONDITION(!canStoreInRuleTree || aRuleDetail == eRuleFullReset ||    \
 31217:                    (aStartStruct && aRuleDetail == eRulePartialReset),        \
 31217:                    "canStoreInRuleTree must be false for inherited structs "  \
 31217:                    "unless all properties have been specified with values "   \
 31217:                    "other than inherit");                                     \
 38861:   if (canStoreInRuleTree) {                                                   \
     1:     /* We were fully specified and can therefore be cached right on the */    \
     1:     /* rule node. */                                                          \
     1:     if (!aHighestNode->mStyleData.mInheritedData) {                           \
     1:       aHighestNode->mStyleData.mInheritedData =                               \
     1:         new (mPresContext) nsInheritedStyleData;                              \
     1:     }                                                                         \
 63757:     NS_ASSERTION(!aHighestNode->mStyleData.mInheritedData->                   \
 63757:                    mStyleStructs[eStyleStruct_##type_],                       \
 31217:                  "Going to leak style data");                                 \
 63757:     aHighestNode->mStyleData.mInheritedData->                                 \
 63757:       mStyleStructs[eStyleStruct_##type_] = data_;                            \
     1:     /* Propagate the bit down. */                                             \
121242:     PropagateDependentBit(eStyleStruct_##type_, aHighestNode, data_);         \
 38861:     /* Tell the style context that it doesn't own the data */                 \
 38861:     aContext->                                                                \
 38861:       AddStyleBit(nsCachedStyleData::GetBitForSID(eStyleStruct_##type_));     \
     1:   }                                                                           \
 38861:   /* Always cache inherited data on the style context */                      \
 38861:   aContext->SetStyle##type_(data_);                                           \
     1:                                                                               \
     1:   return data_;
     1: 
     1: /**
     1:  * Begin an nsRuleNode::Compute*Data function for a reset struct.
     1:  *
     1:  * @param type_ The nsStyle* type this function computes.
     1:  * @param data_ Variable holding the result of this function.
     1:  */
     1: #define COMPUTE_END_RESET(type_, data_)                                       \
 31217:   NS_POSTCONDITION(!canStoreInRuleTree ||                                     \
 31217:                    aRuleDetail == eRuleNone ||                                \
 31217:                    aRuleDetail == eRulePartialReset ||                        \
 31217:                    aRuleDetail == eRuleFullReset,                             \
 31217:                    "canStoreInRuleTree must be false for reset structs "      \
 31217:                    "if any properties were specified as inherit");            \
 24636:   if (!canStoreInRuleTree)                                                    \
 24636:     /* We can't be cached in the rule node.  We have to be put right */       \
 24636:     /* on the style context. */                                               \
     1:     aContext->SetStyle(eStyleStruct_##type_, data_);                          \
     1:   else {                                                                      \
     1:     /* We were fully specified and can therefore be cached right on the */    \
     1:     /* rule node. */                                                          \
     1:     if (!aHighestNode->mStyleData.mResetData) {                               \
     1:       aHighestNode->mStyleData.mResetData =                                   \
     1:         new (mPresContext) nsResetStyleData;                                  \
     1:     }                                                                         \
 63757:     NS_ASSERTION(!aHighestNode->mStyleData.mResetData->                       \
 63757:                    mStyleStructs[eStyleStruct_##type_],                       \
 31217:                  "Going to leak style data");                                 \
 63757:     aHighestNode->mStyleData.mResetData->                                     \
 63757:       mStyleStructs[eStyleStruct_##type_] = data_;                            \
     1:     /* Propagate the bit down. */                                             \
121242:     PropagateDependentBit(eStyleStruct_##type_, aHighestNode, data_);         \
     1:   }                                                                           \
     1:                                                                               \
     1:   return data_;
     1: 
 10073: // This function figures out how much scaling should be suppressed to
 10073: // satisfy scriptminsize. This is our attempt to implement
 10073: // http://www.w3.org/TR/MathML2/chapter3.html#id.3.3.4.2.2
 10073: // This is called after mScriptLevel, mScriptMinSize and mScriptSizeMultiplier
 10073: // have been set in aFont.
 10073: //
 10073: // Here are the invariants we enforce:
 10073: // 1) A decrease in size must not reduce the size below minscriptsize.
 10073: // 2) An increase in size must not increase the size above the size we would
 10073: // have if minscriptsize had not been applied anywhere.
 10073: // 3) The scriptlevel-induced size change must between 1.0 and the parent's
 10073: // scriptsizemultiplier^(new script level - old script level), as close to the
 10073: // latter as possible subject to constraints 1 and 2.
 10073: static nscoord
 10073: ComputeScriptLevelSize(const nsStyleFont* aFont, const nsStyleFont* aParentFont,
 10073:                        nsPresContext* aPresContext, nscoord* aUnconstrainedSize)
 10073: {
108991:   int32_t scriptLevelChange =
 10073:     aFont->mScriptLevel - aParentFont->mScriptLevel;
 10073:   if (scriptLevelChange == 0) {
 10073:     *aUnconstrainedSize = aParentFont->mScriptUnconstrainedSize;
 10073:     // Constraint #3 says that we cannot change size, and #1 and #2 are always
 10073:     // satisfied with no change. It's important this be fast because it covers
 10073:     // all non-MathML content.
 10073:     return aParentFont->mSize;
 10073:   }
 10073: 
 10073:   // Compute actual value of minScriptSize
 10073:   nscoord minScriptSize =
 10073:     nsStyleFont::ZoomText(aPresContext, aParentFont->mScriptMinSize);
 10073: 
 10073:   double scriptLevelScale =
 10073:     pow(aParentFont->mScriptSizeMultiplier, scriptLevelChange);
 10744:   // Compute the size we would have had if minscriptsize had never been
 10744:   // applied, also prevent overflow (bug 413274)
 10073:   *aUnconstrainedSize =
 32531:     NSToCoordRound(NS_MIN(aParentFont->mScriptUnconstrainedSize*scriptLevelScale,
 32531:                           double(nscoord_MAX)));
 10073:   // Compute the size we could get via scriptlevel change
 10073:   nscoord scriptLevelSize =
 32531:     NSToCoordRound(NS_MIN(aParentFont->mSize*scriptLevelScale,
 32531:                           double(nscoord_MAX)));
 10073:   if (scriptLevelScale <= 1.0) {
 10073:     if (aParentFont->mSize <= minScriptSize) {
 10073:       // We can't decrease the font size at all, so just stick to no change
 10073:       // (authors are allowed to explicitly set the font size smaller than
 10073:       // minscriptsize)
 10073:       return aParentFont->mSize;
 10073:     }
 10073:     // We can decrease, so apply constraint #1
 32531:     return NS_MAX(minScriptSize, scriptLevelSize);
 10073:   } else {
 10073:     // scriptminsize can only make sizes larger than the unconstrained size
 10073:     NS_ASSERTION(*aUnconstrainedSize <= scriptLevelSize, "How can this ever happen?");
 10073:     // Apply constraint #2
 32531:     return NS_MIN(scriptLevelSize, NS_MAX(*aUnconstrainedSize, minScriptSize));
 10073:   }
 10073: }
 10073: 
 99858: 
 99858: /* static */ nscoord
108991: nsRuleNode::CalcFontPointSize(int32_t aHTMLSize, int32_t aBasePointSize,
 99858:                               nsPresContext* aPresContext,
 99858:                               nsFontSizeType aFontSizeType)
 99858: {
 99858: #define sFontSizeTableMin  9 
 99858: #define sFontSizeTableMax 16 
 99858: 
 99858: // This table seems to be the one used by MacIE5. We hope its adoption in Mozilla
 99858: // and eventually in WinIE5.5 will help to establish a standard rendering across
 99858: // platforms and browsers. For now, it is used only in Strict mode. More can be read
 99858: // in the document written by Todd Farhner at:
 99858: // http://style.verso.com/font_size_intervals/altintervals.html
 99858: //
108991:   static int32_t sStrictFontSizeTable[sFontSizeTableMax - sFontSizeTableMin + 1][8] =
 99858:   {
 99858:       { 9,    9,     9,     9,    11,    14,    18,    27},
 99858:       { 9,    9,     9,    10,    12,    15,    20,    30},
 99858:       { 9,    9,    10,    11,    13,    17,    22,    33},
 99858:       { 9,    9,    10,    12,    14,    18,    24,    36},
 99858:       { 9,   10,    12,    13,    16,    20,    26,    39},
 99858:       { 9,   10,    12,    14,    17,    21,    28,    42},
 99858:       { 9,   10,    13,    15,    18,    23,    30,    45},
 99858:       { 9,   10,    13,    16,    18,    24,    32,    48}
 99858:   };
 99858: // HTML       1      2      3      4      5      6      7
 99858: // CSS  xxs   xs     s      m      l     xl     xxl
 99858: //                          |
 99858: //                      user pref
 99858: //
 99858: //------------------------------------------------------------
 99858: //
 99858: // This table gives us compatibility with WinNav4 for the default fonts only.
 99858: // In WinNav4, the default fonts were:
 99858: //
 99858: //     Times/12pt ==   Times/16px at 96ppi
 99858: //   Courier/10pt == Courier/13px at 96ppi
 99858: //
 99858: // The 2 lines below marked "anchored" have the exact pixel sizes used by
 99858: // WinNav4 for Times/12pt and Courier/10pt at 96ppi. As you can see, the
 99858: // HTML size 3 (user pref) for those 2 anchored lines is 13px and 16px.
 99858: //
 99858: // All values other than the anchored values were filled in by hand, never
 99858: // going below 9px, and maintaining a "diagonal" relationship. See for
 99858: // example the 13s -- they follow a diagonal line through the table.
 99858: //
108991:   static int32_t sQuirksFontSizeTable[sFontSizeTableMax - sFontSizeTableMin + 1][8] =
 99858:   {
 99858:       { 9,    9,     9,     9,    11,    14,    18,    28 },
 99858:       { 9,    9,     9,    10,    12,    15,    20,    31 },
 99858:       { 9,    9,     9,    11,    13,    17,    22,    34 },
 99858:       { 9,    9,    10,    12,    14,    18,    24,    37 },
 99858:       { 9,    9,    10,    13,    16,    20,    26,    40 }, // anchored (13)
 99858:       { 9,    9,    11,    14,    17,    21,    28,    42 },
 99858:       { 9,   10,    12,    15,    17,    23,    30,    45 },
 99858:       { 9,   10,    13,    16,    18,    24,    32,    48 }  // anchored (16)
 99858:   };
 99858: // HTML       1      2      3      4      5      6      7
 99858: // CSS  xxs   xs     s      m      l     xl     xxl
 99858: //                          |
 99858: //                      user pref
 99858: 
 99858: #if 0
 99858: //
 99858: // These are the exact pixel values used by WinIE5 at 96ppi.
 99858: //
 99858:       { ?,    8,    11,    12,    13,    16,    21,    32 }, // smallest
 99858:       { ?,    9,    12,    13,    16,    21,    27,    40 }, // smaller
 99858:       { ?,   10,    13,    16,    18,    24,    32,    48 }, // medium
 99858:       { ?,   13,    16,    19,    21,    27,    37,    ?? }, // larger
 99858:       { ?,   16,    19,    21,    24,    32,    43,    ?? }  // largest
 99858: //
 99858: // HTML       1      2      3      4      5      6      7
 99858: // CSS  ?     ?      ?      ?      ?      ?      ?      ?
 99858: //
 99858: // (CSS not tested yet.)
 99858: //
 99858: #endif
 99858: 
108991:   static int32_t sFontSizeFactors[8] = { 60,75,89,100,120,150,200,300 };
108991: 
108991:   static int32_t sCSSColumns[7]  = {0, 1, 2, 3, 4, 5, 6}; // xxs...xxl
108991:   static int32_t sHTMLColumns[7] = {1, 2, 3, 4, 5, 6, 7}; // 1...7
 99858: 
 99858:   double dFontSize;
 99858: 
 99858:   if (aFontSizeType == eFontSize_HTML) {
 99858:     aHTMLSize--;    // input as 1-7
 99858:   }
 99858: 
 99858:   if (aHTMLSize < 0)
 99858:     aHTMLSize = 0;
 99858:   else if (aHTMLSize > 6)
 99858:     aHTMLSize = 6;
 99858: 
108991:   int32_t* column;
 99858:   switch (aFontSizeType)
 99858:   {
 99858:     case eFontSize_HTML: column = sHTMLColumns; break;
 99858:     case eFontSize_CSS:  column = sCSSColumns;  break;
 99858:   }
 99858: 
 99858:   // Make special call specifically for fonts (needed PrintPreview)
108991:   int32_t fontSize = nsPresContext::AppUnitsToIntCSSPixels(aBasePointSize);
 99858: 
 99858:   if ((fontSize >= sFontSizeTableMin) && (fontSize <= sFontSizeTableMax))
 99858:   {
108991:     int32_t row = fontSize - sFontSizeTableMin;
 99858: 
 99858:     if (aPresContext->CompatibilityMode() == eCompatibility_NavQuirks) {
 99858:       dFontSize = nsPresContext::CSSPixelsToAppUnits(sQuirksFontSizeTable[row][column[aHTMLSize]]);
 99858:     } else {
 99858:       dFontSize = nsPresContext::CSSPixelsToAppUnits(sStrictFontSizeTable[row][column[aHTMLSize]]);
 99858:     }
 99858:   }
 99858:   else
 99858:   {
108991:     int32_t factor = sFontSizeFactors[column[aHTMLSize]];
 99858:     dFontSize = (factor * aBasePointSize) / 100;
 99858:   }
 99858: 
 99858: 
 99858:   if (1.0 < dFontSize) {
 99858:     return (nscoord)dFontSize;
 99858:   }
 99858:   return (nscoord)1;
 99858: }
 99858: 
 99858: 
 99858: //------------------------------------------------------------------------------
 99858: //
 99858: //------------------------------------------------------------------------------
 99858: 
 99858: /* static */ nscoord
108991: nsRuleNode::FindNextSmallerFontSize(nscoord aFontSize, int32_t aBasePointSize, 
 99858:                                     nsPresContext* aPresContext,
 99858:                                     nsFontSizeType aFontSizeType)
 99858: {
108991:   int32_t index;
108991:   int32_t indexMin;
108991:   int32_t indexMax;
 99858:   float relativePosition;
 99858:   nscoord smallerSize;
 99858:   nscoord indexFontSize = aFontSize; // XXX initialize to quell a spurious gcc3.2 warning
 99858:   nscoord smallestIndexFontSize;
 99858:   nscoord largestIndexFontSize;
 99858:   nscoord smallerIndexFontSize;
 99858:   nscoord largerIndexFontSize;
 99858: 
 99858:   nscoord onePx = nsPresContext::CSSPixelsToAppUnits(1);
 99858: 
 99858:   if (aFontSizeType == eFontSize_HTML) {
 99858:     indexMin = 1;
 99858:     indexMax = 7;
 99858:   } else {
 99858:     indexMin = 0;
 99858:     indexMax = 6;
 99858:   }
 99858:   
 99858:   smallestIndexFontSize = CalcFontPointSize(indexMin, aBasePointSize, aPresContext, aFontSizeType);
 99858:   largestIndexFontSize = CalcFontPointSize(indexMax, aBasePointSize, aPresContext, aFontSizeType); 
 99858:   if (aFontSize > smallestIndexFontSize) {
 99858:     if (aFontSize < NSToCoordRound(float(largestIndexFontSize) * 1.5)) { // smaller will be in HTML table
 99858:       // find largest index smaller than current
 99858:       for (index = indexMax; index >= indexMin; index--) {
 99858:         indexFontSize = CalcFontPointSize(index, aBasePointSize, aPresContext, aFontSizeType);
 99858:         if (indexFontSize < aFontSize)
 99858:           break;
 99858:       } 
 99858:       // set up points beyond table for interpolation purposes
 99858:       if (indexFontSize == smallestIndexFontSize) {
 99858:         smallerIndexFontSize = indexFontSize - onePx;
 99858:         largerIndexFontSize = CalcFontPointSize(index+1, aBasePointSize, aPresContext, aFontSizeType);
 99858:       } else if (indexFontSize == largestIndexFontSize) {
 99858:         smallerIndexFontSize = CalcFontPointSize(index-1, aBasePointSize, aPresContext, aFontSizeType);
 99858:         largerIndexFontSize = NSToCoordRound(float(largestIndexFontSize) * 1.5);
 99858:       } else {
 99858:         smallerIndexFontSize = CalcFontPointSize(index-1, aBasePointSize, aPresContext, aFontSizeType);
 99858:         largerIndexFontSize = CalcFontPointSize(index+1, aBasePointSize, aPresContext, aFontSizeType);
 99858:       }
 99858:       // compute the relative position of the parent size between the two closest indexed sizes
 99858:       relativePosition = float(aFontSize - indexFontSize) / float(largerIndexFontSize - indexFontSize);            
 99858:       // set the new size to have the same relative position between the next smallest two indexed sizes
 99858:       smallerSize = smallerIndexFontSize + NSToCoordRound(relativePosition * (indexFontSize - smallerIndexFontSize));      
 99858:     }
 99858:     else {  // larger than HTML table, drop by 33%
 99858:       smallerSize = NSToCoordRound(float(aFontSize) / 1.5);
 99858:     }
 99858:   }
 99858:   else { // smaller than HTML table, drop by 1px
 99858:     smallerSize = NS_MAX(aFontSize - onePx, onePx);
 99858:   }
 99858:   return smallerSize;
 99858: }
 99858: 
 99858: //------------------------------------------------------------------------------
 99858: //
 99858: //------------------------------------------------------------------------------
 99858: 
 99858: /* static */ nscoord
108991: nsRuleNode::FindNextLargerFontSize(nscoord aFontSize, int32_t aBasePointSize, 
 99858:                                    nsPresContext* aPresContext,
 99858:                                    nsFontSizeType aFontSizeType)
 99858: {
108991:   int32_t index;
108991:   int32_t indexMin;
108991:   int32_t indexMax;
 99858:   float relativePosition;
 99858:   nscoord adjustment;
 99858:   nscoord largerSize;
 99858:   nscoord indexFontSize = aFontSize; // XXX initialize to quell a spurious gcc3.2 warning
 99858:   nscoord smallestIndexFontSize;
 99858:   nscoord largestIndexFontSize;
 99858:   nscoord smallerIndexFontSize;
 99858:   nscoord largerIndexFontSize;
 99858: 
 99858:   nscoord onePx = nsPresContext::CSSPixelsToAppUnits(1);
 99858: 
 99858:   if (aFontSizeType == eFontSize_HTML) {
 99858:     indexMin = 1;
 99858:     indexMax = 7;
 99858:   } else {
 99858:     indexMin = 0;
 99858:     indexMax = 6;
 99858:   }
 99858:   
 99858:   smallestIndexFontSize = CalcFontPointSize(indexMin, aBasePointSize, aPresContext, aFontSizeType);
 99858:   largestIndexFontSize = CalcFontPointSize(indexMax, aBasePointSize, aPresContext, aFontSizeType); 
 99858:   if (aFontSize > (smallestIndexFontSize - onePx)) {
 99858:     if (aFontSize < largestIndexFontSize) { // larger will be in HTML table
 99858:       // find smallest index larger than current
 99858:       for (index = indexMin; index <= indexMax; index++) { 
 99858:         indexFontSize = CalcFontPointSize(index, aBasePointSize, aPresContext, aFontSizeType);
 99858:         if (indexFontSize > aFontSize)
 99858:           break;
 99858:       }
 99858:       // set up points beyond table for interpolation purposes
 99858:       if (indexFontSize == smallestIndexFontSize) {
 99858:         smallerIndexFontSize = indexFontSize - onePx;
 99858:         largerIndexFontSize = CalcFontPointSize(index+1, aBasePointSize, aPresContext, aFontSizeType);
 99858:       } else if (indexFontSize == largestIndexFontSize) {
 99858:         smallerIndexFontSize = CalcFontPointSize(index-1, aBasePointSize, aPresContext, aFontSizeType);
 99858:         largerIndexFontSize = NSCoordSaturatingMultiply(largestIndexFontSize, 1.5);
 99858:       } else {
 99858:         smallerIndexFontSize = CalcFontPointSize(index-1, aBasePointSize, aPresContext, aFontSizeType);
 99858:         largerIndexFontSize = CalcFontPointSize(index+1, aBasePointSize, aPresContext, aFontSizeType);
 99858:       }
 99858:       // compute the relative position of the parent size between the two closest indexed sizes
 99858:       relativePosition = float(aFontSize - smallerIndexFontSize) / float(indexFontSize - smallerIndexFontSize);
 99858:       // set the new size to have the same relative position between the next largest two indexed sizes
 99858:       adjustment = NSCoordSaturatingNonnegativeMultiply(largerIndexFontSize - indexFontSize, relativePosition);
 99858:       largerSize = NSCoordSaturatingAdd(indexFontSize, adjustment);
 99858:     }
 99858:     else {  // larger than HTML table, increase by 50%
 99858:       largerSize = NSCoordSaturatingMultiply(aFontSize, 1.5);
 99858:     }
 99858:   }
 99858:   else { // smaller than HTML table, increase by 1px
 99858:     largerSize = NSCoordSaturatingAdd(aFontSize, onePx);
 99858:   }
 99858:   return largerSize;
 99858: }
 99858: 
 47180: struct SetFontSizeCalcOps : public css::BasicCoordCalcOps,
 47180:                             public css::NumbersAlreadyNormalizedOps
 42147: {
 42147:   // The parameters beyond aValue that we need for CalcLengthWith.
 42149:   const nscoord mParentSize;
 42149:   const nsStyleFont* const mParentFont;
 42149:   nsPresContext* const mPresContext;
 79445:   const bool mAtRoot;
 79445:   bool& mCanStoreInRuleTree;
 42147: 
 42149:   SetFontSizeCalcOps(nscoord aParentSize, const nsStyleFont* aParentFont,
 79445:                      nsPresContext* aPresContext, bool aAtRoot,
 79445:                      bool& aCanStoreInRuleTree)
 42147:     : mParentSize(aParentSize),
 42147:       mParentFont(aParentFont),
 42147:       mPresContext(aPresContext),
 42147:       mAtRoot(aAtRoot),
 42147:       mCanStoreInRuleTree(aCanStoreInRuleTree)
 42147:   {
 42147:   }
 42149: 
 42149:   result_type ComputeLeafValue(const nsCSSValue& aValue)
 42147:   {
 42147:     nscoord size;
 42147:     if (aValue.IsLengthUnit()) {
 42147:       // Note that font-based length units use the parent's size
 42147:       // unadjusted for scriptlevel changes. A scriptlevel change
 42147:       // between us and the parent is simply ignored.
 76296:       size = CalcLengthWith(aValue, mParentSize,
 88039:                             mParentFont,
106838:                             nullptr, mPresContext, mAtRoot,
 80486:                             true, mCanStoreInRuleTree);
 50786:       if (!aValue.IsRelativeLengthUnit()) {
 42149:         size = nsStyleFont::ZoomText(mPresContext, size);
 42147:       }
 42147:     }
 42147:     else if (eCSSUnit_Percent == aValue.GetUnit()) {
 80486:       mCanStoreInRuleTree = false;
 42147:       // Note that % units use the parent's size unadjusted for scriptlevel
 42147:       // changes. A scriptlevel change between us and the parent is simply
 42147:       // ignored.
 42305:       // aValue.GetPercentValue() may be negative for, e.g., calc(-50%)
 42305:       size = NSCoordSaturatingMultiply(mParentSize, aValue.GetPercentValue());
 42147:     } else {
 80486:       NS_ABORT_IF_FALSE(false, "unexpected value");
 42149:       size = mParentSize;
 42147:     }
 42147: 
 42147:     return size;
 42147:   }
 42147: };
 42147: 
 10073: /* static */ void
 10073: nsRuleNode::SetFontSize(nsPresContext* aPresContext,
 63746:                         const nsRuleData* aRuleData,
 10073:                         const nsStyleFont* aFont,
 10073:                         const nsStyleFont* aParentFont,
 10073:                         nscoord* aSize,
 10073:                         const nsFont& aSystemFont,
 10073:                         nscoord aParentSize,
 10073:                         nscoord aScriptLevelAdjustedParentSize,
 79445:                         bool aUsedStartStruct,
 79445:                         bool aAtRoot,
 79445:                         bool& aCanStoreInRuleTree)
 10073: {
 79445:   bool zoom = false;
108991:   int32_t baseSize = (int32_t) aPresContext->
 90439:     GetDefaultFont(aFont->mGenericID, aFont->mLanguage)->size;
 63746:   const nsCSSValue* sizeValue = aRuleData->ValueForFontSize();
 63746:   if (eCSSUnit_Enumerated == sizeValue->GetUnit()) {
108991:     int32_t value = sizeValue->GetIntValue();
 10073: 
 80486:     zoom = true;
 10073:     if ((NS_STYLE_FONT_SIZE_XXSMALL <= value) &&
 10073:         (value <= NS_STYLE_FONT_SIZE_XXLARGE)) {
 99858:       *aSize = CalcFontPointSize(value, baseSize,
 73678:                        aPresContext, eFontSize_CSS);
 10073:     }
 10073:     else if (NS_STYLE_FONT_SIZE_XXXLARGE == value) {
 10073:       // <font size="7"> is not specified in CSS, so we don't use eFontSize_CSS.
 99858:       *aSize = CalcFontPointSize(value, baseSize, aPresContext);
 10073:     }
 10073:     else if (NS_STYLE_FONT_SIZE_LARGER  == value ||
 10073:              NS_STYLE_FONT_SIZE_SMALLER == value) {
 80486:       aCanStoreInRuleTree = false;
 10073: 
 10073:       // Un-zoom so we use the tables correctly.  We'll then rezoom due
 80486:       // to the |zoom = true| above.
 10073:       // Note that relative units here use the parent's size unadjusted
 10073:       // for scriptlevel changes. A scriptlevel change between us and the parent
 10073:       // is simply ignored.
 10073:       nscoord parentSize =
 10073:         nsStyleFont::UnZoomText(aPresContext, aParentSize);
 10073: 
 10073:       if (NS_STYLE_FONT_SIZE_LARGER == value) {
 99858:         *aSize = FindNextLargerFontSize(parentSize,
 73678:                          baseSize, aPresContext, eFontSize_CSS);
 72988: 
 72988:         NS_ASSERTION(*aSize >= parentSize,
 10073:                      "FindNextLargerFontSize failed");
 10073:       }
 10073:       else {
 99858:         *aSize = FindNextSmallerFontSize(parentSize,
 73678:                          baseSize, aPresContext, eFontSize_CSS);
 10073:         NS_ASSERTION(*aSize < parentSize ||
 10073:                      parentSize <= nsPresContext::CSSPixelsToAppUnits(1),
 10073:                      "FindNextSmallerFontSize failed");
 10073:       }
 10073:     } else {
 10073:       NS_NOTREACHED("unexpected value");
 10073:     }
 10073:   }
 63746:   else if (sizeValue->IsLengthUnit() ||
 63746:            sizeValue->GetUnit() == eCSSUnit_Percent ||
 63746:            sizeValue->IsCalcUnit()) {
 88039:     SetFontSizeCalcOps ops(aParentSize, aParentFont,
 76296:                            aPresContext, aAtRoot, aCanStoreInRuleTree);
 63746:     *aSize = css::ComputeCalc(*sizeValue, ops);
 42147:     if (*aSize < 0) {
 63746:       NS_ABORT_IF_FALSE(sizeValue->IsCalcUnit(),
 42147:                         "negative lengths and percents should be rejected "
 42147:                         "by parser");
 42147:       *aSize = 0;
 42147:     }
 42147:     // Zoom is handled inside the calc ops when needed.
 80486:     zoom = false;
 10073:   }
 63746:   else if (eCSSUnit_System_Font == sizeValue->GetUnit()) {
 10073:     // this becomes our cascading size
 10073:     *aSize = aSystemFont.size;
 80486:     zoom = true;
 10073:   }
 63746:   else if (eCSSUnit_Inherit == sizeValue->GetUnit()) {
 80486:     aCanStoreInRuleTree = false;
 10073:     // We apply scriptlevel change for this case, because the default is
 10073:     // to inherit and we don't want explicit "inherit" to differ from the
 10073:     // default.
 10073:     *aSize = aScriptLevelAdjustedParentSize;
 80486:     zoom = false;
 10073:   }
 63746:   else if (eCSSUnit_Initial == sizeValue->GetUnit()) {
 10073:     // The initial value is 'medium', which has magical sizing based on
 10073:     // the generic font family, so do that here too.
 10073:     *aSize = baseSize;
 80486:     zoom = true;
 10073:   } else {
 63746:     NS_ASSERTION(eCSSUnit_Null == sizeValue->GetUnit(),
 10073:                  "What kind of font-size value is this?");
 10073:     // if aUsedStartStruct is true, then every single property in the
 10073:     // font struct is being set all at once. This means scriptlevel is not
 10073:     // going to have any influence on the font size; there is no need to
 10073:     // do anything here.
 10073:     if (!aUsedStartStruct && aParentSize != aScriptLevelAdjustedParentSize) {
 10073:       // There was no rule affecting the size but the size has been
 24636:       // affected by the parent's size via scriptlevel change. So we cannot
 24636:       // store the data in the rule tree.
 80486:       aCanStoreInRuleTree = false;
 10073:       *aSize = aScriptLevelAdjustedParentSize;
 10073:     }
 10073:   }
 10073: 
 10073:   // We want to zoom the cascaded size so that em-based measurements,
 10073:   // line-heights, etc., work.
 10073:   if (zoom) {
 10073:     *aSize = nsStyleFont::ZoomText(aPresContext, *aSize);
 10073:   }
 10073: }
 10073: 
108991: static int8_t ClampTo8Bit(int32_t aValue) {
 10073:   if (aValue < -128)
 10073:     return -128;
 10073:   if (aValue > 127)
 10073:     return 127;
108991:   return int8_t(aValue);
 10073: }
 10073: 
     1: /* static */ void
     1: nsRuleNode::SetFont(nsPresContext* aPresContext, nsStyleContext* aContext,
108991:                     uint8_t aGenericFontID, const nsRuleData* aRuleData,
  3987:                     const nsStyleFont* aParentFont,
 79445:                     nsStyleFont* aFont, bool aUsedStartStruct,
 79445:                     bool& aCanStoreInRuleTree)
     1: {
 88039:   bool atRoot = !aContext->GetParent();
 88039: 
 90439:   // mLanguage must be set before before any of the CalcLengthWith calls
 90439:   // (direct calls or calls via SetFontSize) for the cases where |aParentFont|
 90439:   // is the same as |aFont|.
 88039:   //
 88039:   // -x-lang: string, inherit
 90439:   // This is not a real CSS property, it is an HTML attribute mapped to CSS.
 88039:   const nsCSSValue* langValue = aRuleData->ValueForLang();
 88039:   if (eCSSUnit_Ident == langValue->GetUnit()) {
 88039:     nsAutoString lang;
 88039:     langValue->GetStringValue(lang);
 88039: 
 88039:     nsContentUtils::ASCIIToLower(lang);
 88039:     aFont->mLanguage = do_GetAtom(lang);
108870:     aFont->mExplicitLanguage = true;
 88039:   }
 88039: 
     1:   const nsFont* defaultVariableFont =
 90439:     aPresContext->GetDefaultFont(kPresContext_DefaultVariableFont_ID,
 90439:                                  aFont->mLanguage);
     1: 
  2302:   // -moz-system-font: enum (never inherit!)
 90821:   MOZ_STATIC_ASSERT(
 90537:     NS_STYLE_FONT_CAPTION        == LookAndFeel::eFont_Caption &&
 90537:     NS_STYLE_FONT_ICON           == LookAndFeel::eFont_Icon &&
 90537:     NS_STYLE_FONT_MENU           == LookAndFeel::eFont_Menu &&
 90537:     NS_STYLE_FONT_MESSAGE_BOX    == LookAndFeel::eFont_MessageBox &&
 90537:     NS_STYLE_FONT_SMALL_CAPTION  == LookAndFeel::eFont_SmallCaption &&
 90537:     NS_STYLE_FONT_STATUS_BAR     == LookAndFeel::eFont_StatusBar &&
 90537:     NS_STYLE_FONT_WINDOW         == LookAndFeel::eFont_Window &&
 90537:     NS_STYLE_FONT_DOCUMENT       == LookAndFeel::eFont_Document &&
 90537:     NS_STYLE_FONT_WORKSPACE      == LookAndFeel::eFont_Workspace &&
 90537:     NS_STYLE_FONT_DESKTOP        == LookAndFeel::eFont_Desktop &&
 90537:     NS_STYLE_FONT_INFO           == LookAndFeel::eFont_Info &&
 90537:     NS_STYLE_FONT_DIALOG         == LookAndFeel::eFont_Dialog &&
 90537:     NS_STYLE_FONT_BUTTON         == LookAndFeel::eFont_Button &&
 90537:     NS_STYLE_FONT_PULL_DOWN_MENU == LookAndFeel::eFont_PullDownMenu &&
 90537:     NS_STYLE_FONT_LIST           == LookAndFeel::eFont_List &&
 90821:     NS_STYLE_FONT_FIELD          == LookAndFeel::eFont_Field,
 90821:     "LookAndFeel.h system-font constants out of sync with nsStyleConsts.h");
 90537: 
 90537:   // Fall back to defaultVariableFont.
 90537:   nsFont systemFont = *defaultVariableFont;
 63746:   const nsCSSValue* systemFontValue = aRuleData->ValueForSystemFont();
 63746:   if (eCSSUnit_Enumerated == systemFontValue->GetUnit()) {
 90537:     gfxFontStyle fontStyle;
 90537:     LookAndFeel::FontID fontID =
 90537:       (LookAndFeel::FontID)systemFontValue->GetIntValue();
119825:     float devPerCSS =
119825:       (float)nsPresContext::AppUnitsPerCSSPixel() /
119825:       aPresContext->DeviceContext()->UnscaledAppUnitsPerDevPixel();
115493:     if (LookAndFeel::GetFont(fontID, systemFont.name, fontStyle, devPerCSS)) {
 90537:       systemFont.style = fontStyle.style;
 90537:       systemFont.systemFont = fontStyle.systemFont;
 90537:       systemFont.variant = NS_FONT_VARIANT_NORMAL;
 90537:       systemFont.weight = fontStyle.weight;
 90537:       systemFont.stretch = fontStyle.stretch;
 90537:       systemFont.decorations = NS_FONT_DECORATION_NONE;
 90537:       systemFont.size = NSFloatPixelsToAppUnits(fontStyle.size,
 90537:                                                 aPresContext->DeviceContext()->
 90537:                                                 UnscaledAppUnitsPerDevPixel());
 90537:       //systemFont.langGroup = fontStyle.langGroup;
 90537:       systemFont.sizeAdjust = fontStyle.sizeAdjust;
     1: 
     1: #ifdef XP_WIN
 90537:       // XXXldb This platform-specific stuff should be in the
 90537:       // LookAndFeel implementation, not here.
 90537:       // XXXzw Should we even still *have* this code?  It looks to be making
 90537:       // old, probably obsolete assumptions.
 90537: 
 90537:       // As far as I can tell the system default fonts and sizes
     1:       // on MS-Windows for Buttons, Listboxes/Comboxes and Text Fields are
     1:       // all pre-determined and cannot be changed by either the control panel
     1:       // or programmtically.
 90537:       switch (fontID) {
     1:         // Fields (text fields)
     1:         // Button and Selects (listboxes/comboboxes)
     1:         //    We use whatever font is defined by the system. Which it appears
     1:         //    (and the assumption is) it is always a proportional font. Then we
     1:         //    always use 2 points smaller than what the browser has defined as
     1:         //    the default proportional font.
 90537:       case LookAndFeel::eFont_Field:
 90537:       case LookAndFeel::eFont_Button:
 90537:       case LookAndFeel::eFont_List:
     1:         // Assumption: system defined font is proportional
  2302:         systemFont.size =
 90537:           NS_MAX(defaultVariableFont->size -
 90537:                  nsPresContext::CSSPointsToAppUnits(2), 0);
     1:         break;
     1:       }
     1: #endif
 90537:     }
 90537:   }
  2302: 
  2302:   // font-family: string list, enum, inherit
 63746:   const nsCSSValue* familyValue = aRuleData->ValueForFontFamily();
 63746:   NS_ASSERTION(eCSSUnit_Enumerated != familyValue->GetUnit(),
  2302:                "system fonts should not be in mFamily anymore");
 63746:   if (eCSSUnit_Families == familyValue->GetUnit()) {
  2302:     // set the correct font if we are using DocumentFonts OR we are overriding for XUL
  2302:     // MJA: bug 31816
  3987:     if (aGenericFontID == kGenericFont_NONE) {
  2302:       // only bother appending fallback fonts if this isn't a fallback generic font itself
  2302:       if (!aFont->mFont.name.IsEmpty())
  2302:         aFont->mFont.name.Append((PRUnichar)',');
  3987:       // defaultVariableFont.name should always be "serif" or "sans-serif".
  3987:       aFont->mFont.name.Append(defaultVariableFont->name);
  2302:     }
 80486:     aFont->mFont.systemFont = false;
  3987:     // Technically this is redundant with the code below, but it's good
  3987:     // to have since we'll still want it once we get rid of
  3987:     // SetGenericFont (bug 380915).
 20260:     aFont->mGenericID = aGenericFontID;
  2302:   }
 63746:   else if (eCSSUnit_System_Font == familyValue->GetUnit()) {
  2302:     aFont->mFont.name = systemFont.name;
 80486:     aFont->mFont.systemFont = true;
 20260:     aFont->mGenericID = kGenericFont_NONE;
     1:   }
 63746:   else if (eCSSUnit_Inherit == familyValue->GetUnit()) {
 80486:     aCanStoreInRuleTree = false;
     1:     aFont->mFont.name = aParentFont->mFont.name;
  2302:     aFont->mFont.systemFont = aParentFont->mFont.systemFont;
 20260:     aFont->mGenericID = aParentFont->mGenericID;
     1:   }
 63746:   else if (eCSSUnit_Initial == familyValue->GetUnit()) {
  1441:     aFont->mFont.name = defaultVariableFont->name;
  2302:     aFont->mFont.systemFont = defaultVariableFont->systemFont;
 20260:     aFont->mGenericID = kGenericFont_NONE;
  3987:   }
  3987: 
  3987:   // When we're in the loop in SetGenericFont, we must ensure that we
  3987:   // always keep aFont->mFlags set to the correct generic.  But we have
  3987:   // to be careful not to touch it when we're called directly from
  3987:   // ComputeFontData, because we could have a start struct.
  3987:   if (aGenericFontID != kGenericFont_NONE) {
 20260:     aFont->mGenericID = aGenericFontID;
     1:   }
     1: 
 34081:   // font-style: enum, inherit, initial, -moz-system-font
 63746:   SetDiscrete(*aRuleData->ValueForFontStyle(),
 63746:               aFont->mFont.style, aCanStoreInRuleTree,
 34081:               SETDSC_ENUMERATED | SETDSC_SYSTEM_FONT,
 18889:               aParentFont->mFont.style,
 18889:               defaultVariableFont->style,
 34081:               0, 0, 0, systemFont.style);
 34081: 
 34081:   // font-variant: enum, inherit, initial, -moz-system-font
 63746:   SetDiscrete(*aRuleData->ValueForFontVariant(),
 63746:               aFont->mFont.variant, aCanStoreInRuleTree,
 34081:               SETDSC_ENUMERATED | SETDSC_SYSTEM_FONT,
 18889:               aParentFont->mFont.variant,
 18889:               defaultVariableFont->variant,
 34081:               0, 0, 0, systemFont.variant);
 18889: 
 34871:   // font-weight: int, enum, inherit, initial, -moz-system-font
 18889:   // special handling for enum
 63746:   const nsCSSValue* weightValue = aRuleData->ValueForFontWeight();
 63746:   if (eCSSUnit_Enumerated == weightValue->GetUnit()) {
108991:     int32_t value = weightValue->GetIntValue();
     1:     switch (value) {
     1:       case NS_STYLE_FONT_WEIGHT_NORMAL:
     1:       case NS_STYLE_FONT_WEIGHT_BOLD:
     1:         aFont->mFont.weight = value;
     1:         break;
 57239:       case NS_STYLE_FONT_WEIGHT_BOLDER: {
 80486:         aCanStoreInRuleTree = false;
108991:         int32_t inheritedValue = aParentFont->mFont.weight;
 57239:         if (inheritedValue <= 300) {
 57239:           aFont->mFont.weight = 400;
 57239:         } else if (inheritedValue <= 500) {
 57239:           aFont->mFont.weight = 700;
 57239:         } else {
 57239:           aFont->mFont.weight = 900;
 57239:         }
     1:         break;
     1:       }
 57239:       case NS_STYLE_FONT_WEIGHT_LIGHTER: {
 80486:         aCanStoreInRuleTree = false;
108991:         int32_t inheritedValue = aParentFont->mFont.weight;
 57239:         if (inheritedValue < 600) {
 57239:           aFont->mFont.weight = 100;
 57239:         } else if (inheritedValue < 800) {
 57239:           aFont->mFont.weight = 400;
 57239:         } else {
 57239:           aFont->mFont.weight = 700;
 57239:         }
 57239:         break;
 57239:       }
 57239:     }
 18889:   } else
 63746:     SetDiscrete(*weightValue, aFont->mFont.weight, aCanStoreInRuleTree,
 34871:                 SETDSC_INTEGER | SETDSC_SYSTEM_FONT,
 18889:                 aParentFont->mFont.weight,
 18889:                 defaultVariableFont->weight,
 34871:                 0, 0, 0, systemFont.weight);
 34871: 
 57237:   // font-stretch: enum, inherit, initial, -moz-system-font
 63746:   SetDiscrete(*aRuleData->ValueForFontStretch(),
 63746:               aFont->mFont.stretch, aCanStoreInRuleTree,
 57237:               SETDSC_SYSTEM_FONT | SETDSC_ENUMERATED,
 24408:               aParentFont->mFont.stretch,
 24408:               defaultVariableFont->stretch,
 34871:               0, 0, 0, systemFont.stretch);
 24408: 
 10073:   // Compute scriptlevel, scriptminsize and scriptsizemultiplier now so
 10073:   // they're available for font-size computation.
 10073: 
 10073:   // -moz-script-min-size: length
 63746:   const nsCSSValue* scriptMinSizeValue = aRuleData->ValueForScriptMinSize();
 63746:   if (scriptMinSizeValue->IsLengthUnit()) {
 10234:     // scriptminsize in font units (em, ex) has to be interpreted relative
 10234:     // to the parent font, or the size definitions are circular and we
 10234:     //
 10073:     aFont->mScriptMinSize =
 76296:       CalcLengthWith(*scriptMinSizeValue, aParentFont->mSize,
 88039:                      aParentFont,
106838:                      nullptr, aPresContext, atRoot, true,
 24636:                      aCanStoreInRuleTree);
 10073:   }
 10073: 
 18889:   // -moz-script-size-multiplier: factor, inherit, initial
 63746:   SetFactor(*aRuleData->ValueForScriptSizeMultiplier(),
 63746:             aFont->mScriptSizeMultiplier,
 24636:             aCanStoreInRuleTree, aParentFont->mScriptSizeMultiplier,
 18889:             NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER,
 18889:             SETFCT_POSITIVE);
 10073: 
 10073:   // -moz-script-level: integer, number, inherit
 63746:   const nsCSSValue* scriptLevelValue = aRuleData->ValueForScriptLevel();
 63746:   if (eCSSUnit_Integer == scriptLevelValue->GetUnit()) {
 10073:     // "relative"
 63746:     aFont->mScriptLevel = ClampTo8Bit(aParentFont->mScriptLevel + scriptLevelValue->GetIntValue());
 63746:   }
 63746:   else if (eCSSUnit_Number == scriptLevelValue->GetUnit()) {
 10073:     // "absolute"
108991:     aFont->mScriptLevel = ClampTo8Bit(int32_t(scriptLevelValue->GetFloatValue()));
 63746:   }
 63746:   else if (eCSSUnit_Inherit == scriptLevelValue->GetUnit()) {
 80486:     aCanStoreInRuleTree = false;
 10073:     aFont->mScriptLevel = aParentFont->mScriptLevel;
 10073:   }
 63746:   else if (eCSSUnit_Initial == scriptLevelValue->GetUnit()) {
 10073:     aFont->mScriptLevel = 0;
 10073:   }
 10073: 
 47359:   // font-feature-settings
 63746:   const nsCSSValue* featureSettingsValue =
 63746:     aRuleData->ValueForFontFeatureSettings();
 96986: 
 96986:   switch (featureSettingsValue->GetUnit()) {
 96986:   case eCSSUnit_Null:
 96986:     break;
 96986: 
 96986:   case eCSSUnit_Normal:
 96986:   case eCSSUnit_Initial:
 96986:     aFont->mFont.fontFeatureSettings.Clear();
 96986:     break;
 96986: 
 96986:   case eCSSUnit_Inherit:
 80486:     aCanStoreInRuleTree = false;
 96986:     aFont->mFont.fontFeatureSettings = aParentFont->mFont.fontFeatureSettings;
 96986:     break;
 96986: 
 96986:   case eCSSUnit_System_Font:
 96986:     aFont->mFont.fontFeatureSettings = systemFont.fontFeatureSettings;
 96986:     break;
 96986: 
 96986:   case eCSSUnit_PairList:
 96986:   case eCSSUnit_PairListDep:
 96986:     ComputeFontFeatures(featureSettingsValue->GetPairListValue(),
 96986:                         aFont->mFont.fontFeatureSettings);
 96986:     break;
 96986: 
 96986:   default:
 96986:     NS_ABORT_IF_FALSE(false, "unexpected value unit");
 96986:     break;
 47359:   }
 47359: 
 47359:   // font-language-override
 63746:   const nsCSSValue* languageOverrideValue =
 63746:     aRuleData->ValueForFontLanguageOverride();
 63746:   if (eCSSUnit_Inherit == languageOverrideValue->GetUnit()) {
 80486:     aCanStoreInRuleTree = false;
 47359:     aFont->mFont.languageOverride = aParentFont->mFont.languageOverride;
 63746:   } else if (eCSSUnit_Normal == languageOverrideValue->GetUnit() ||
 63746:              eCSSUnit_Initial == languageOverrideValue->GetUnit()) {
 47359:     aFont->mFont.languageOverride.Truncate();
 63746:   } else if (eCSSUnit_System_Font == languageOverrideValue->GetUnit()) {
 47359:     aFont->mFont.languageOverride = systemFont.languageOverride;
 63746:   } else if (eCSSUnit_String == languageOverrideValue->GetUnit()) {
 63746:     languageOverrideValue->GetStringValue(aFont->mFont.languageOverride);
 47359:   }
 47359: 
 10028:   // font-size: enum, length, percent, inherit
 10073:   nscoord scriptLevelAdjustedParentSize = aParentFont->mSize;
 10073:   nscoord scriptLevelAdjustedUnconstrainedParentSize;
 10073:   scriptLevelAdjustedParentSize =
 10073:     ComputeScriptLevelSize(aFont, aParentFont, aPresContext,
 10073:                            &scriptLevelAdjustedUnconstrainedParentSize);
 10073:   NS_ASSERTION(!aUsedStartStruct || aFont->mScriptUnconstrainedSize == aFont->mSize,
 10073:                "If we have a start struct, we should have reset everything coming in here");
 76296:   SetFontSize(aPresContext, aRuleData, aFont, aParentFont,
 88039:               &aFont->mSize,
 10073:               systemFont, aParentFont->mSize, scriptLevelAdjustedParentSize,
 24636:               aUsedStartStruct, atRoot, aCanStoreInRuleTree);
 10073:   if (aParentFont->mSize == aParentFont->mScriptUnconstrainedSize &&
 10073:       scriptLevelAdjustedParentSize == scriptLevelAdjustedUnconstrainedParentSize) {
 10073:     // Fast path: we have not been affected by scriptminsize so we don't
 10073:     // need to call SetFontSize again to compute the
 10073:     // scriptminsize-unconstrained size. This is OK even if we have a
 10073:     // start struct, because if we have a start struct then 'font-size'
 10073:     // was specified and so scriptminsize has no effect.
 10073:     aFont->mScriptUnconstrainedSize = aFont->mSize;
 10028:   } else {
 63746:     SetFontSize(aPresContext, aRuleData, aFont, aParentFont,
 88039:                 &aFont->mScriptUnconstrainedSize,
 76296:                 systemFont, aParentFont->mScriptUnconstrainedSize,
 10073:                 scriptLevelAdjustedUnconstrainedParentSize,
 24636:                 aUsedStartStruct, atRoot, aCanStoreInRuleTree);
 10073:   }
 10073:   NS_ASSERTION(aFont->mScriptUnconstrainedSize <= aFont->mSize,
 10073:                "scriptminsize should never be making things bigger");
     1: 
 90439:   nscoord fontSize = aFont->mSize;
 90439: 
     1:   // enforce the user' specified minimum font-size on the value that we expose
 90439:   // (but don't change font-size:0, since that would unhide hidden text)
 90439:   if (fontSize > 0) {
 90439:     nscoord minFontSize = aPresContext->MinFontSize(aFont->mLanguage);
 90439:     if (minFontSize < 0) {
 90439:       minFontSize = 0;
 90439:     }
 90439:     if (fontSize < minFontSize && !aPresContext->IsChrome()) {
 90439:       // override the minimum font-size constraint
 90439:       fontSize = minFontSize;
 90439:     }
 90439:   }
 90439:   aFont->mFont.size = fontSize;
     1: 
 18889:   // font-size-adjust: number, none, inherit, initial, -moz-system-font
 63746:   const nsCSSValue* sizeAdjustValue = aRuleData->ValueForFontSizeAdjust();
 63746:   if (eCSSUnit_System_Font == sizeAdjustValue->GetUnit()) {
  2302:     aFont->mFont.sizeAdjust = systemFont.sizeAdjust;
 18889:   } else
 63746:     SetFactor(*sizeAdjustValue, aFont->mFont.sizeAdjust,
 24636:               aCanStoreInRuleTree, aParentFont->mFont.sizeAdjust, 0.0f,
 24636:               SETFCT_NONE);
     1: }
     1: 
 96986: /* static */ void
 96986: nsRuleNode::ComputeFontFeatures(const nsCSSValuePairList *aFeaturesList,
 96986:                                 nsTArray<gfxFontFeature>& aFeatureSettings)
 96986: {
 96986:   aFeatureSettings.Clear();
 96986:   for (const nsCSSValuePairList* p = aFeaturesList; p; p = p->mNext) {
 96986:     gfxFontFeature feat = {0, 0};
 96986: 
 96986:     NS_ABORT_IF_FALSE(aFeaturesList->mXValue.GetUnit() == eCSSUnit_String,
 96986:                       "unexpected value unit");
 96986: 
 96986:     // tag is a 4-byte ASCII sequence
 96986:     nsAutoString tag;
 96986:     p->mXValue.GetStringValue(tag);
 96986:     if (tag.Length() != 4) {
 96986:       continue;
 96986:     }
 96986:     // parsing validates that these are ASCII chars
 96986:     // tags are always big-endian
 96986:     feat.mTag = (tag[0] << 24) | (tag[1] << 16) | (tag[2] << 8)  | tag[3];
 96986: 
 96986:     // value
 96986:     NS_ASSERTION(p->mYValue.GetUnit() == eCSSUnit_Integer,
 96986:                  "should have found an integer unit");
 96986:     feat.mValue = p->mYValue.GetIntValue();
 96986: 
 96986:     aFeatureSettings.AppendElement(feat);
 96986:   }
 96986: }
 96986: 
 90439: // This should die (bug 380915).
 90439: //
     1: // SetGenericFont:
     1: //  - backtrack to an ancestor with the same generic font name (possibly
     1: //    up to the root where default values come from the presentation context)
     1: //  - re-apply cascading rules from there without caching intermediate values
     1: /* static */ void
     1: nsRuleNode::SetGenericFont(nsPresContext* aPresContext,
     1:                            nsStyleContext* aContext,
108991:                            uint8_t aGenericFontID,
     1:                            nsStyleFont* aFont)
     1: {
     1:   // walk up the contexts until a context with the desired generic font
 24551:   nsAutoTArray<nsStyleContext*, 8> contextPath;
  4022:   contextPath.AppendElement(aContext);
     1:   nsStyleContext* higherContext = aContext->GetParent();
     1:   while (higherContext) {
 20260:     if (higherContext->GetStyleFont()->mGenericID == aGenericFontID) {
     1:       // done walking up the higher contexts
     1:       break;
     1:     }
     1:     contextPath.AppendElement(higherContext);
     1:     higherContext = higherContext->GetParent();
     1:   }
     1: 
     1:   // re-apply the cascading rules, starting from the higher context
     1: 
     1:   // If we stopped earlier because we reached the root of the style tree,
     1:   // we will start with the default generic font from the presentation
     1:   // context. Otherwise we start with the higher context.
 90439:   const nsFont* defaultFont =
 90439:     aPresContext->GetDefaultFont(aGenericFontID, aFont->mLanguage);
 10073:   nsStyleFont parentFont(*defaultFont, aPresContext);
     1:   if (higherContext) {
     1:     const nsStyleFont* tmpFont = higherContext->GetStyleFont();
 10073:     parentFont = *tmpFont;
 10073:   }
 10073:   *aFont = parentFont;
     1: 
 79445:   bool dummy;
108991:   uint32_t fontBit = nsCachedStyleData::GetBitForSID(eStyleStruct_Font);
     1: 
 63750:   // use placement new[] on the result of alloca() to allocate a
 63750:   // variable-sized stack array, including execution of constructors,
 63750:   // and use an RAII class to run the destructors too.
 63750:   size_t nprops = nsCSSProps::PropertyCountInStruct(eStyleStruct_Font);
 63750:   void* dataStorage = alloca(nprops * sizeof(nsCSSValue));
 63750: 
108991:   for (int32_t i = contextPath.Length() - 1; i >= 0; --i) {
 24551:     nsStyleContext* context = contextPath[i];
 63750:     AutoCSSValueArray dataArray(dataStorage, nprops);
 63754: 
 63754:     nsRuleData ruleData(NS_STYLE_INHERIT_BIT(Font), dataArray.get(),
 63754:                         aPresContext, context);
 63750:     ruleData.mValueOffsets[eStyleStruct_Font] = 0;
     1: 
     1:     // Trimmed down version of ::WalkRuleTree() to re-apply the style rules
  4022:     // Note that we *do* need to do this for our own data, since what is
  4022:     // in |fontData| in ComputeFontData is only for the rules below
  4022:     // aStartStruct.
     1:     for (nsRuleNode* ruleNode = context->GetRuleNode(); ruleNode;
     1:          ruleNode = ruleNode->GetParent()) {
     1:       if (ruleNode->mNoneBits & fontBit)
     1:         // no more font rules on this branch, get out
     1:         break;
     1: 
     1:       nsIStyleRule *rule = ruleNode->GetRule();
  1540:       if (rule) {
  1540:         ruleData.mLevel = ruleNode->GetLevel();
  1540:         ruleData.mIsImportantRule = ruleNode->IsImportantRule();
     1:         rule->MapRuleInfoInto(&ruleData);
     1:       }
  1540:     }
     1: 
     1:     // Compute the delta from the information that the rules specified
  4022: 
  4022:     // Avoid unnecessary operations in SetFont().  But we care if it's
  4022:     // the final value that we're computing.
  4022:     if (i != 0)
 63746:       ruleData.ValueForFontFamily()->Reset();
     1: 
 90439:     nsRuleNode::SetFont(aPresContext, context,
 63746:                         aGenericFontID, &ruleData, &parentFont, aFont,
 80486:                         false, dummy);
     1: 
     1:     // XXX Not sure if we need to do this here
 33659:     // If we have a post-resolve callback, handle that now.
 33659:     if (ruleData.mPostResolveCallback)
 33659:       (ruleData.mPostResolveCallback)(aFont, &ruleData);
     1: 
 10073:     parentFont = *aFont;
     1:   }
     1: }
     1: 
 79445: static bool ExtractGeneric(const nsString& aFamily, bool aGeneric,
     1:                              void *aData)
     1: {
  3233:   nsAutoString *data = static_cast<nsAutoString*>(aData);
     1: 
     1:   if (aGeneric) {
     1:     *data = aFamily;
 80486:     return false; // stop enumeration
 80486:   }
 80486:   return true;
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeFontData(void* aStartStruct,
 63746:                             const nsRuleData* aRuleData,
     1:                             nsStyleContext* aContext,
     1:                             nsRuleNode* aHighestNode,
 24634:                             const RuleDetail aRuleDetail,
 79445:                             const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_INHERITED(Font, (mPresContext), font, parentFont)
     1: 
  4027:   // NOTE:  The |aRuleDetail| passed in is a little bit conservative due
  4027:   // to the -moz-system-font property.  We really don't need to consider
  4027:   // it here in determining whether to cache in the rule tree.  However,
  4027:   // we do need to consider it in WalkRuleTree when deciding whether to
  4027:   // walk further up the tree.  So this means that when the font struct
  4027:   // is fully specified using *longhand* properties (excluding
  4027:   // -moz-system-font), we won't cache in the rule tree even though we
  4027:   // could.  However, it's pretty unlikely authors will do that
  4027:   // (although there is a pretty good chance they'll fully specify it
  4027:   // using the 'font' shorthand).
  4027: 
 79445:   bool useDocumentFonts =
     1:     mPresContext->GetCachedBoolPref(kPresContext_UseDocumentFonts);
     1: 
     1:   // See if we are in the chrome
     1:   // We only need to know this to determine if we have to use the
 90439:   // document fonts (overriding the useDocumentFonts flag).
 90439:   if (!useDocumentFonts && mPresContext->IsChrome()) {
     1:     // if we are not using document fonts, but this is a XUL document,
     1:     // then we use the document fonts anyway
 80486:     useDocumentFonts = true;
     1:   }
     1: 
     1:   // Figure out if we are a generic font
108991:   uint8_t generic = kGenericFont_NONE;
  4022:   // XXXldb What if we would have had a string if we hadn't been doing
  4022:   // the optimization with a non-null aStartStruct?
 63746:   const nsCSSValue* familyValue = aRuleData->ValueForFontFamily();
 63746:   if (eCSSUnit_Families == familyValue->GetUnit()) {
 63746:     familyValue->GetStringValue(font->mFont.name);
     1:     // XXXldb Do we want to extract the generic for this if it's not only a
     1:     // generic?
     1:     nsFont::GetGenericID(font->mFont.name, &generic);
     1: 
     1:     // If we aren't allowed to use document fonts, then we are only entitled
     1:     // to use the user's default variable-width font and fixed-width font
     1:     if (!useDocumentFonts) {
     1:       // Extract the generic from the specified font family...
     1:       nsAutoString genericName;
     1:       if (!font->mFont.EnumerateFamilies(ExtractGeneric, &genericName)) {
     1:         // The specified font had a generic family.
     1:         font->mFont.name = genericName;
     1:         nsFont::GetGenericID(genericName, &generic);
     1: 
     1:         // ... and only use it if it's -moz-fixed or monospace
     1:         if (generic != kGenericFont_moz_fixed &&
     1:             generic != kGenericFont_monospace) {
     1:           font->mFont.name.Truncate();
     1:           generic = kGenericFont_NONE;
     1:         }
     1:       } else {
     1:         // The specified font did not have a generic family.
     1:         font->mFont.name.Truncate();
     1:         generic = kGenericFont_NONE;
     1:       }
     1:     }
     1:   }
     1: 
     1:   // Now compute our font struct
     1:   if (generic == kGenericFont_NONE) {
     1:     // continue the normal processing
 90439:     nsRuleNode::SetFont(mPresContext, aContext, generic,
 63746:                         aRuleData, parentFont, font,
106838:                         aStartStruct != nullptr, canStoreInRuleTree);
     1:   }
     1:   else {
     1:     // re-calculate the font as a generic font
 80486:     canStoreInRuleTree = false;
  4022:     nsRuleNode::SetGenericFont(mPresContext, aContext, generic,
 90439:                                font);
     1:   }
     1: 
     1:   COMPUTE_END_INHERITED(Font, font)
     1: }
     1: 
 50931: template <typename T>
108991: inline uint32_t ListLength(const T* aList)
108991: {
108991:   uint32_t len = 0;
 50931:   while (aList) {
 50931:     len++;
 50931:     aList = aList->mNext;
 50931:   }
 50931:   return len;
 50931: }
 50931: 
 50931: 
 50931: 
 15699: already_AddRefed<nsCSSShadowArray>
 50931: nsRuleNode::GetShadowData(const nsCSSValueList* aList,
 15699:                           nsStyleContext* aContext,
 79445:                           bool aIsBoxShadow,
 79445:                           bool& canStoreInRuleTree)
 15699: {
108991:   uint32_t arrayLength = ListLength(aList);
 50931: 
 50931:   NS_ABORT_IF_FALSE(arrayLength > 0,
 50931:                     "Non-null text-shadow list, yet we counted 0 items.");
 15699:   nsCSSShadowArray* shadowList = new(arrayLength) nsCSSShadowArray(arrayLength);
 15699: 
 15699:   if (!shadowList)
106838:     return nullptr;
 15699: 
 19207:   nsStyleCoord tempCoord;
 79445:   bool unitOK;
 15699:   for (nsCSSShadowItem* item = shadowList->ShadowAt(0);
 15699:        aList;
 15699:        aList = aList->mNext, ++item) {
 50931:     NS_ABORT_IF_FALSE(aList->mValue.GetUnit() == eCSSUnit_Array,
 50931:                       "expecting a plain array value");
 15699:     nsCSSValue::Array *arr = aList->mValue.GetArrayValue();
 15699:     // OK to pass bad aParentCoord since we're not passing SETCOORD_INHERIT
 19207:     unitOK = SetCoord(arr->Item(0), tempCoord, nsStyleCoord(),
 42146:                       SETCOORD_LENGTH | SETCOORD_CALC_LENGTH_ONLY,
 42146:                       aContext, mPresContext, canStoreInRuleTree);
 19207:     NS_ASSERTION(unitOK, "unexpected unit");
 19207:     item->mXOffset = tempCoord.GetCoordValue();
 19207: 
 19207:     unitOK = SetCoord(arr->Item(1), tempCoord, nsStyleCoord(),
 42146:                       SETCOORD_LENGTH | SETCOORD_CALC_LENGTH_ONLY,
 42146:                       aContext, mPresContext, canStoreInRuleTree);
 19207:     NS_ASSERTION(unitOK, "unexpected unit");
 19207:     item->mYOffset = tempCoord.GetCoordValue();
 15699: 
 15699:     // Blur radius is optional in the current box-shadow spec
 15699:     if (arr->Item(2).GetUnit() != eCSSUnit_Null) {
 19207:       unitOK = SetCoord(arr->Item(2), tempCoord, nsStyleCoord(),
 42146:                         SETCOORD_LENGTH | SETCOORD_CALC_LENGTH_ONLY |
 42146:                           SETCOORD_CALC_CLAMP_NONNEGATIVE,
 42146:                         aContext, mPresContext, canStoreInRuleTree);
 19207:       NS_ASSERTION(unitOK, "unexpected unit");
 19207:       item->mRadius = tempCoord.GetCoordValue();
 15699:     } else {
 19207:       item->mRadius = 0;
 15699:     }
 15699: 
 15699:     // Find the spread radius
 24818:     if (aIsBoxShadow && arr->Item(3).GetUnit() != eCSSUnit_Null) {
 19207:       unitOK = SetCoord(arr->Item(3), tempCoord, nsStyleCoord(),
 42146:                         SETCOORD_LENGTH | SETCOORD_CALC_LENGTH_ONLY,
 42146:                         aContext, mPresContext, canStoreInRuleTree);
 19207:       NS_ASSERTION(unitOK, "unexpected unit");
 19207:       item->mSpread = tempCoord.GetCoordValue();
 15699:     } else {
 19207:       item->mSpread = 0;
 15699:     }
 15699: 
 15699:     if (arr->Item(4).GetUnit() != eCSSUnit_Null) {
 80486:       item->mHasColor = true;
 15699:       // 2nd argument can be bogus since inherit is not a valid color
 19207:       unitOK = SetColor(arr->Item(4), 0, mPresContext, aContext, item->mColor,
 24636:                         canStoreInRuleTree);
 19207:       NS_ASSERTION(unitOK, "unexpected unit");
 15699:     }
 24818: 
 24818:     if (aIsBoxShadow && arr->Item(5).GetUnit() == eCSSUnit_Enumerated) {
 24818:       NS_ASSERTION(arr->Item(5).GetIntValue() == NS_STYLE_BOX_SHADOW_INSET,
 24818:                    "invalid keyword type for box shadow");
 80486:       item->mInset = true;
 24818:     } else {
 80486:       item->mInset = false;
 24818:     }
 15699:   }
 15699: 
 15699:   NS_ADDREF(shadowList);
 15699:   return shadowList;
 15699: }
 15699: 
 10152: const void*
 10152: nsRuleNode::ComputeTextData(void* aStartStruct,
 63746:                             const nsRuleData* aRuleData,
     1:                             nsStyleContext* aContext,
     1:                             nsRuleNode* aHighestNode,
 24634:                             const RuleDetail aRuleDetail,
 79445:                             const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_INHERITED(Text, (), text, parentText)
     1: 
 33208:   // tab-size: integer, inherit
 63746:   SetDiscrete(*aRuleData->ValueForTabSize(),
 63746:               text->mTabSize, canStoreInRuleTree,
 33208:               SETDSC_INTEGER, parentText->mTabSize,
 33208:               NS_STYLE_TABSIZE_INITIAL, 0, 0, 0, 0);
 33208: 
     1:   // letter-spacing: normal, length, inherit
 63746:   SetCoord(*aRuleData->ValueForLetterSpacing(),
 63746:            text->mLetterSpacing, parentText->mLetterSpacing,
 42145:            SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL |
 42145:              SETCOORD_CALC_LENGTH_ONLY,
 24636:            aContext, mPresContext, canStoreInRuleTree);
     1: 
 15268:   // text-shadow: none, list, inherit, initial
 63746:   const nsCSSValue* textShadowValue = aRuleData->ValueForTextShadow();
 63746:   if (textShadowValue->GetUnit() != eCSSUnit_Null) {
106838:     text->mTextShadow = nullptr;
 15268: 
 15268:     // Don't need to handle none/initial explicitly: The above assignment
 15268:     // takes care of that
 63746:     if (textShadowValue->GetUnit() == eCSSUnit_Inherit) {
 80486:       canStoreInRuleTree = false;
 15699:       text->mTextShadow = parentText->mTextShadow;
 63746:     } else if (textShadowValue->GetUnit() == eCSSUnit_List ||
 63746:                textShadowValue->GetUnit() == eCSSUnit_ListDep) {
 15268:       // List of arrays
 63746:       text->mTextShadow = GetShadowData(textShadowValue->GetListValue(),
 80486:                                         aContext, false, canStoreInRuleTree);
 15268:     }
 15268:   }
 15268: 
     1:   // line-height: normal, number, length, percent, inherit
 63746:   const nsCSSValue* lineHeightValue = aRuleData->ValueForLineHeight();
 63746:   if (eCSSUnit_Percent == lineHeightValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
     1:     // Use |mFont.size| to pick up minimum font size.
     1:     text->mLineHeight.SetCoordValue(
105832:         NSToCoordRound(float(aContext->GetStyleFont()->mFont.size) *
 63746:                        lineHeightValue->GetPercentValue()));
 63746:   }
 63746:   else if (eCSSUnit_Initial == lineHeightValue->GetUnit() ||
 63746:            eCSSUnit_System_Font == lineHeightValue->GetUnit()) {
  1441:     text->mLineHeight.SetNormalValue();
  1441:   }
  1441:   else {
 63746:     SetCoord(*lineHeightValue, text->mLineHeight, parentText->mLineHeight,
 28519:              SETCOORD_LEH | SETCOORD_FACTOR | SETCOORD_NORMAL,
 24636:              aContext, mPresContext, canStoreInRuleTree);
 63746:     if (lineHeightValue->IsLengthUnit() &&
 63746:         !lineHeightValue->IsRelativeLengthUnit()) {
     1:       nscoord lh = nsStyleFont::ZoomText(mPresContext,
     1:                                          text->mLineHeight.GetCoordValue());
 90439: 
 80486:       canStoreInRuleTree = false;
     1:       const nsStyleFont *font = aContext->GetStyleFont();
 90439:       nscoord minimumFontSize = mPresContext->MinFontSize(font->mLanguage);
 90439: 
 90439:       if (minimumFontSize > 0 && !mPresContext->IsChrome()) {
     1:         if (font->mSize != 0) {
     1:           lh = nscoord(float(lh) * float(font->mFont.size) / float(font->mSize));
     1:         } else {
     1:           lh = minimumFontSize;
     1:         }
     1:       }
     1:       text->mLineHeight.SetCoordValue(lh);
     1:     }
     1:   }
     1: 
     1: 
 18889:   // text-align: enum, string, inherit, initial
 63746:   const nsCSSValue* textAlignValue = aRuleData->ValueForTextAlign();
 63746:   if (eCSSUnit_String == textAlignValue->GetUnit()) {
     1:     NS_NOTYETIMPLEMENTED("align string");
 63746:   } else if (eCSSUnit_Enumerated == textAlignValue->GetUnit() &&
 24695:              NS_STYLE_TEXT_ALIGN_MOZ_CENTER_OR_INHERIT ==
 63746:                textAlignValue->GetIntValue()) {
 80486:     canStoreInRuleTree = false;
108991:     uint8_t parentAlign = parentText->mTextAlign;
 24695:     text->mTextAlign = (NS_STYLE_TEXT_ALIGN_DEFAULT == parentAlign) ?
 24695:       NS_STYLE_TEXT_ALIGN_CENTER : parentAlign;
 18889:   } else
 63746:     SetDiscrete(*textAlignValue, text->mTextAlign, canStoreInRuleTree,
 18889:                 SETDSC_ENUMERATED, parentText->mTextAlign,
 18889:                 NS_STYLE_TEXT_ALIGN_DEFAULT,
 18889:                 0, 0, 0, 0);
 18889: 
 87175:   // text-align-last: enum, inherit, initial
 87175:   SetDiscrete(*aRuleData->ValueForTextAlignLast(), text->mTextAlignLast,
 87175:               canStoreInRuleTree, SETDSC_ENUMERATED, parentText->mTextAlignLast,
 87175:               NS_STYLE_TEXT_ALIGN_AUTO, 0, 0, 0, 0);
 87175: 
 51778:   // text-indent: length, percent, calc, inherit, initial
 63746:   SetCoord(*aRuleData->ValueForTextIndent(), text->mTextIndent, parentText->mTextIndent,
 51778:            SETCOORD_LPH | SETCOORD_INITIAL_ZERO | SETCOORD_STORE_CALC,
 51778:            aContext, mPresContext, canStoreInRuleTree);
     1: 
 34082:   // text-transform: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForTextTransform(), text->mTextTransform, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentText->mTextTransform,
 34082:               NS_STYLE_TEXT_TRANSFORM_NONE, 0, 0, 0, 0);
 34082: 
 34082:   // white-space: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForWhiteSpace(), text->mWhiteSpace, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentText->mWhiteSpace,
 34082:               NS_STYLE_WHITESPACE_NORMAL, 0, 0, 0, 0);
     1: 
 97909:   // word-break: enum, inherit, initial
 97909:   SetDiscrete(*aRuleData->ValueForWordBreak(), text->mWordBreak, canStoreInRuleTree,
 97909:               SETDSC_ENUMERATED, parentText->mWordBreak,
 97909:               NS_STYLE_WORDBREAK_NORMAL, 0, 0, 0, 0);
 97909: 
     1:   // word-spacing: normal, length, inherit
 23137:   nsStyleCoord tempCoord;
 63746:   const nsCSSValue* wordSpacingValue = aRuleData->ValueForWordSpacing();
 63746:   if (SetCoord(*wordSpacingValue, tempCoord,
 33820:                nsStyleCoord(parentText->mWordSpacing,
 33820:                             nsStyleCoord::CoordConstructor),
 42145:                SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL |
 42145:                  SETCOORD_CALC_LENGTH_ONLY,
 24636:                aContext, mPresContext, canStoreInRuleTree)) {
 23137:     if (tempCoord.GetUnit() == eStyleUnit_Coord) {
 23137:       text->mWordSpacing = tempCoord.GetCoordValue();
 23137:     } else if (tempCoord.GetUnit() == eStyleUnit_Normal) {
 23137:       text->mWordSpacing = 0;
 23137:     } else {
 23137:       NS_NOTREACHED("unexpected unit");
 23137:     }
 23137:   } else {
 63746:     NS_ASSERTION(wordSpacingValue->GetUnit() == eCSSUnit_Null,
 23137:                  "unexpected unit");
 23137:   }
     1: 
 34082:   // word-wrap: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForWordWrap(), text->mWordWrap, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentText->mWordWrap,
 34082:               NS_STYLE_WORDWRAP_NORMAL, 0, 0, 0, 0);
 16166: 
 69305:   // hyphens: enum, inherit, initial
 69305:   SetDiscrete(*aRuleData->ValueForHyphens(), text->mHyphens, canStoreInRuleTree,
 69305:               SETDSC_ENUMERATED, parentText->mHyphens,
 69305:               NS_STYLE_HYPHENS_MANUAL, 0, 0, 0, 0);
 69305: 
 82665:   // text-size-adjust: none, auto, inherit, initial
 82665:   SetDiscrete(*aRuleData->ValueForTextSizeAdjust(), text->mTextSizeAdjust,
 82665:               canStoreInRuleTree, SETDSC_NONE | SETDSC_AUTO,
 82665:               parentText->mTextSizeAdjust,
 82665:               NS_STYLE_TEXT_SIZE_ADJUST_AUTO, // initial value
 82665:               NS_STYLE_TEXT_SIZE_ADJUST_AUTO, // auto value
 82665:               NS_STYLE_TEXT_SIZE_ADJUST_NONE, // none value
 82665:               0, 0);
 82665: 
     1:   COMPUTE_END_INHERITED(Text, text)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeTextResetData(void* aStartStruct,
 63746:                                  const nsRuleData* aRuleData,
     1:                                  nsStyleContext* aContext,
     1:                                  nsRuleNode* aHighestNode,
 24634:                                  const RuleDetail aRuleDetail,
 79445:                                  const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(TextReset, (), text, parentText)
     1: 
 51778:   // vertical-align: enum, length, percent, calc, inherit
 63746:   const nsCSSValue* verticalAlignValue = aRuleData->ValueForVerticalAlign();
 63746:   if (!SetCoord(*verticalAlignValue, text->mVerticalAlign,
 51778:                 parentText->mVerticalAlign,
 51778:                 SETCOORD_LPH | SETCOORD_ENUMERATED | SETCOORD_STORE_CALC,
 24636:                 aContext, mPresContext, canStoreInRuleTree)) {
 63746:     if (eCSSUnit_Initial == verticalAlignValue->GetUnit()) {
  3832:       text->mVerticalAlign.SetIntValue(NS_STYLE_VERTICAL_ALIGN_BASELINE,
  3832:                                        eStyleUnit_Enumerated);
  3832:     }
  3832:   }
     1: 
 68819:   // text-blink: enum, inherit, initial
 68819:   SetDiscrete(*aRuleData->ValueForTextBlink(), text->mTextBlink,
 68819:               canStoreInRuleTree, SETDSC_ENUMERATED, parentText->mTextBlink,
 68819:               NS_STYLE_TEXT_BLINK_NONE, 0, 0, 0, 0);
 68819: 
 68819:   // text-decoration-line: enum (bit field), inherit, initial
 68819:   const nsCSSValue* decorationLineValue =
 68819:     aRuleData->ValueForTextDecorationLine();
 68819:   if (eCSSUnit_Enumerated == decorationLineValue->GetUnit()) {
108991:     int32_t td = decorationLineValue->GetIntValue();
 68819:     text->mTextDecorationLine = td;
 68819:     if (td & NS_STYLE_TEXT_DECORATION_LINE_PREF_ANCHORS) {
 79445:       bool underlineLinks =
     1:         mPresContext->GetCachedBoolPref(kPresContext_UnderlineLinks);
     1:       if (underlineLinks) {
 68819:         text->mTextDecorationLine |= NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE;
     1:       }
     1:       else {
 68819:         text->mTextDecorationLine &= ~NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE;
 68819:       }
 68819:     }
 68819:   } else if (eCSSUnit_Inherit == decorationLineValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
 68819:     text->mTextDecorationLine = parentText->mTextDecorationLine;
 68819:   } else if (eCSSUnit_Initial == decorationLineValue->GetUnit()) {
 68819:     text->mTextDecorationLine = NS_STYLE_TEXT_DECORATION_LINE_NONE;
 34080:   }
 18889: 
 64456:   // text-decoration-color: color, string, enum, inherit, initial
 64456:   const nsCSSValue* decorationColorValue =
 64456:     aRuleData->ValueForTextDecorationColor();
 64456:   nscolor decorationColor;
 64456:   if (eCSSUnit_Inherit == decorationColorValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
 64456:     if (parentContext) {
 79445:       bool isForeground;
 64456:       parentText->GetDecorationColor(decorationColor, isForeground);
 64456:       if (isForeground) {
 64456:         text->SetDecorationColor(parentContext->GetStyleColor()->mColor);
 64456:       } else {
 64456:         text->SetDecorationColor(decorationColor);
 64456:       }
 64456:     } else {
 64456:       text->SetDecorationColorToForeground();
 64456:     }
 64456:   }
 70093:   else if (eCSSUnit_EnumColor == decorationColorValue->GetUnit() &&
 70093:            decorationColorValue->GetIntValue() == NS_COLOR_CURRENTCOLOR) {
 70093:     text->SetDecorationColorToForeground();
 70093:   }
 64456:   else if (SetColor(*decorationColorValue, 0, mPresContext, aContext,
 64456:                     decorationColor, canStoreInRuleTree)) {
 64456:     text->SetDecorationColor(decorationColor);
 64456:   }
 64456:   else if (eCSSUnit_Initial == decorationColorValue->GetUnit() ||
 64456:            eCSSUnit_Enumerated == decorationColorValue->GetUnit()) {
 64456:     NS_ABORT_IF_FALSE(eCSSUnit_Enumerated != decorationColorValue->GetUnit() ||
 64456:                       decorationColorValue->GetIntValue() ==
 64456:                         NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR,
 64456:                       "unexpected enumerated value");
 64456:     text->SetDecorationColorToForeground();
 64456:   }
 64456: 
 64456:   // text-decoration-style: enum, inherit, initial
 64456:   const nsCSSValue* decorationStyleValue =
 64456:     aRuleData->ValueForTextDecorationStyle();
 64456:   if (eCSSUnit_Enumerated == decorationStyleValue->GetUnit()) {
 64456:     text->SetDecorationStyle(decorationStyleValue->GetIntValue());
 64456:   } else if (eCSSUnit_Inherit == decorationStyleValue->GetUnit()) {
 64456:     text->SetDecorationStyle(parentText->GetDecorationStyle());
 80486:     canStoreInRuleTree = false;
 64456:   } else if (eCSSUnit_Initial == decorationStyleValue->GetUnit()) {
 64456:     text->SetDecorationStyle(NS_STYLE_TEXT_DECORATION_STYLE_SOLID);
 64456:   }
 64456: 
 80275:   // text-overflow: enum, string, pair(enum|string), inherit, initial
 72259:   const nsCSSValue* textOverflowValue =
 72259:     aRuleData->ValueForTextOverflow();
 76917:   if (eCSSUnit_Initial == textOverflowValue->GetUnit()) {
 76917:     text->mTextOverflow = nsStyleTextOverflow();
 72259:   } else if (eCSSUnit_Inherit == textOverflowValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
 72259:     text->mTextOverflow = parentText->mTextOverflow;
 80275:   } else if (eCSSUnit_Enumerated == textOverflowValue->GetUnit()) {
 80275:     // A single enumerated value.
 80275:     SetDiscrete(*textOverflowValue, text->mTextOverflow.mRight.mType,
 80275:                 canStoreInRuleTree,
 80275:                 SETDSC_ENUMERATED, parentText->mTextOverflow.mRight.mType,
 80275:                 NS_STYLE_TEXT_OVERFLOW_CLIP, 0, 0, 0, 0);
 80275:     text->mTextOverflow.mRight.mString.Truncate();
 80275:     text->mTextOverflow.mLeft.mType = NS_STYLE_TEXT_OVERFLOW_CLIP;
 80275:     text->mTextOverflow.mLeft.mString.Truncate();
 80275:     text->mTextOverflow.mLogicalDirections = true;
 80275:   } else if (eCSSUnit_String == textOverflowValue->GetUnit()) {
 80275:     // A single string value.
 80275:     text->mTextOverflow.mRight.mType = NS_STYLE_TEXT_OVERFLOW_STRING;
 80275:     textOverflowValue->GetStringValue(text->mTextOverflow.mRight.mString);
 80275:     text->mTextOverflow.mLeft.mType = NS_STYLE_TEXT_OVERFLOW_CLIP;
 80275:     text->mTextOverflow.mLeft.mString.Truncate();
 80275:     text->mTextOverflow.mLogicalDirections = true;
 76917:   } else if (eCSSUnit_Pair == textOverflowValue->GetUnit()) {
 80275:     // Two values were specified.
 80275:     text->mTextOverflow.mLogicalDirections = false;
 76917:     const nsCSSValuePair& textOverflowValue =
 76917:       aRuleData->ValueForTextOverflow()->GetPairValue();
 76917: 
 76917:     const nsCSSValue *textOverflowLeftValue = &textOverflowValue.mXValue;
 76917:     if (eCSSUnit_Enumerated == textOverflowLeftValue->GetUnit()) {
 76917:       SetDiscrete(*textOverflowLeftValue, text->mTextOverflow.mLeft.mType,
 76917:                   canStoreInRuleTree,
 76917:                   SETDSC_ENUMERATED, parentText->mTextOverflow.mLeft.mType,
 76917:                   NS_STYLE_TEXT_OVERFLOW_CLIP, 0, 0, 0, 0);
 76917:       text->mTextOverflow.mLeft.mString.Truncate();
 76917:     } else if (eCSSUnit_String == textOverflowLeftValue->GetUnit()) {
 76917:       textOverflowLeftValue->GetStringValue(text->mTextOverflow.mLeft.mString);
 76917:       text->mTextOverflow.mLeft.mType = NS_STYLE_TEXT_OVERFLOW_STRING;
 76917:     }
 76917: 
 76917:     const nsCSSValue *textOverflowRightValue = &textOverflowValue.mYValue;
 76917:     if (eCSSUnit_Enumerated == textOverflowRightValue->GetUnit()) {
 76917:       SetDiscrete(*textOverflowRightValue, text->mTextOverflow.mRight.mType,
 76917:                   canStoreInRuleTree,
 76917:                   SETDSC_ENUMERATED, parentText->mTextOverflow.mRight.mType,
 76917:                   NS_STYLE_TEXT_OVERFLOW_CLIP, 0, 0, 0, 0);
 76917:       text->mTextOverflow.mRight.mString.Truncate();
 76917:     } else if (eCSSUnit_String == textOverflowRightValue->GetUnit()) {
 76917:       textOverflowRightValue->GetStringValue(text->mTextOverflow.mRight.mString);
 76917:       text->mTextOverflow.mRight.mType = NS_STYLE_TEXT_OVERFLOW_STRING;
 76917:     }
 72259:   }
 72259: 
 34082:   // unicode-bidi: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForUnicodeBidi(), text->mUnicodeBidi, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentText->mUnicodeBidi,
 34082:               NS_STYLE_UNICODE_BIDI_NORMAL, 0, 0, 0, 0);
     1: 
     1:   COMPUTE_END_RESET(TextReset, text)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeUserInterfaceData(void* aStartStruct,
 63746:                                      const nsRuleData* aRuleData,
     1:                                      nsStyleContext* aContext,
     1:                                      nsRuleNode* aHighestNode,
  3748:                                      const RuleDetail aRuleDetail,
 79445:                                      const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_INHERITED(UserInterface, (), ui, parentUI)
     1: 
 34082:   // cursor: enum, url, inherit
 63746:   const nsCSSValue* cursorValue = aRuleData->ValueForCursor();
 63746:   nsCSSUnit cursorUnit = cursorValue->GetUnit();
 50931:   if (cursorUnit != eCSSUnit_Null) {
     1:     delete [] ui->mCursorArray;
106838:     ui->mCursorArray = nullptr;
     1:     ui->mCursorArrayLength = 0;
     1: 
 50931:     if (cursorUnit == eCSSUnit_Inherit) {
 80486:       canStoreInRuleTree = false;
     1:       ui->mCursor = parentUI->mCursor;
     1:       ui->CopyCursorArrayFrom(*parentUI);
     1:     }
 50931:     else if (cursorUnit == eCSSUnit_Initial) {
  1275:       ui->mCursor = NS_STYLE_CURSOR_AUTO;
  1275:     }
     1:     else {
     1:       // The parser will never create a list that is *all* URL values --
     1:       // that's invalid.
 50931:       NS_ABORT_IF_FALSE(cursorUnit == eCSSUnit_List ||
 50931:                         cursorUnit == eCSSUnit_ListDep,
 96873:                         nsPrintfCString("unrecognized cursor unit %d",
 50931:                                         cursorUnit).get());
 63746:       const nsCSSValueList* list = cursorValue->GetListValue();
 50931:       const nsCSSValueList* list2 = list;
108323:       nsIDocument* doc = aContext->PresContext()->Document();
108991:       uint32_t arrayLength = 0;
  1039:       for ( ; list->mValue.GetUnit() == eCSSUnit_Array; list = list->mNext)
108323:         if (list->mValue.GetArrayValue()->Item(0).GetImageValue(doc))
     1:           ++arrayLength;
     1: 
     1:       if (arrayLength != 0) {
     1:         ui->mCursorArray = new nsCursorImage[arrayLength];
     1:         if (ui->mCursorArray) {
     1:           ui->mCursorArrayLength = arrayLength;
     1: 
     1:           for (nsCursorImage *item = ui->mCursorArray;
  1039:                list2->mValue.GetUnit() == eCSSUnit_Array;
  1039:                list2 = list2->mNext) {
  1039:             nsCSSValue::Array *arr = list2->mValue.GetArrayValue();
108323:             imgIRequest *req = arr->Item(0).GetImageValue(doc);
     1:             if (req) {
 50819:               item->SetImage(req);
     1:               if (arr->Item(1).GetUnit() != eCSSUnit_Null) {
 80486:                 item->mHaveHotspot = true;
     1:                 item->mHotspotX = arr->Item(1).GetFloatValue(),
     1:                 item->mHotspotY = arr->Item(2).GetFloatValue();
     1:               }
     1:               ++item;
     1:             }
     1:           }
     1:         }
     1:       }
     1: 
  1039:       NS_ASSERTION(list, "Must have non-array value at the end");
 34082:       NS_ASSERTION(list->mValue.GetUnit() == eCSSUnit_Enumerated,
  1039:                    "Unexpected fallback value at end of cursor list");
     1:       ui->mCursor = list->mValue.GetIntValue();
     1:     }
 34082:   }
 34082: 
 34082:   // user-input: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForUserInput(),
 63746:               ui->mUserInput, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentUI->mUserInput,
 34082:               NS_STYLE_USER_INPUT_AUTO, 0, 0, 0, 0);
 18889: 
 18889:   // user-modify: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForUserModify(),
 63746:               ui->mUserModify, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentUI->mUserModify,
 18889:               NS_STYLE_USER_MODIFY_READ_ONLY,
 18889:               0, 0, 0, 0);
 18889: 
 34082:   // user-focus: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForUserFocus(),
 63746:               ui->mUserFocus, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentUI->mUserFocus,
 34082:               NS_STYLE_USER_FOCUS_NONE, 0, 0, 0, 0);
     1: 
     1:   COMPUTE_END_INHERITED(UserInterface, ui)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeUIResetData(void* aStartStruct,
 63746:                                const nsRuleData* aRuleData,
     1:                                nsStyleContext* aContext,
     1:                                nsRuleNode* aHighestNode,
 24634:                                const RuleDetail aRuleDetail,
 79445:                                const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(UIReset, (), ui, parentUI)
     1: 
 34082:   // user-select: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForUserSelect(),
 63746:               ui->mUserSelect, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentUI->mUserSelect,
 34082:               NS_STYLE_USER_SELECT_AUTO, 0, 0, 0, 0);
 34082: 
 34082:   // ime-mode: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForImeMode(),
 63746:               ui->mIMEMode, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentUI->mIMEMode,
 34082:               NS_STYLE_IME_MODE_AUTO, 0, 0, 0, 0);
 18889: 
 18889:   // force-broken-image-icons: integer, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForForceBrokenImageIcon(),
 63746:               ui->mForceBrokenImageIcon,
 24636:               canStoreInRuleTree,
 18889:               SETDSC_INTEGER,
 18889:               parentUI->mForceBrokenImageIcon,
 18889:               0, 0, 0, 0, 0);
 18889: 
 34082:   // -moz-window-shadow: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForWindowShadow(),
 63746:               ui->mWindowShadow, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentUI->mWindowShadow,
 34082:               NS_STYLE_WINDOW_SHADOW_DEFAULT, 0, 0, 0, 0);
 20464: 
     1:   COMPUTE_END_RESET(UIReset, ui)
     1: }
     1: 
 67975: // Information about each transition or animation property that is
 67975: // constant.
 31702: struct TransitionPropInfo {
 63746:   nsCSSProperty property;
 31702:   // Location of the count of the property's computed value.
108991:   uint32_t nsStyleDisplay::* sdCount;
 31702: };
 31702: 
 31702: // Each property's index in this array must match its index in the
 31702: // mutable array |transitionPropData| below.
 31702: static const TransitionPropInfo transitionPropInfo[4] = {
 63746:   { eCSSProperty_transition_delay,
 31702:     &nsStyleDisplay::mTransitionDelayCount },
 63746:   { eCSSProperty_transition_duration,
 31702:     &nsStyleDisplay::mTransitionDurationCount },
 63746:   { eCSSProperty_transition_property,
 31702:     &nsStyleDisplay::mTransitionPropertyCount },
 63746:   { eCSSProperty_transition_timing_function,
 31702:     &nsStyleDisplay::mTransitionTimingFunctionCount },
 31702: };
 31702: 
 67975: // Each property's index in this array must match its index in the
 67975: // mutable array |animationPropData| below.
 67975: static const TransitionPropInfo animationPropInfo[8] = {
 67975:   { eCSSProperty_animation_delay,
 67975:     &nsStyleDisplay::mAnimationDelayCount },
 67975:   { eCSSProperty_animation_duration,
 67975:     &nsStyleDisplay::mAnimationDurationCount },
 67975:   { eCSSProperty_animation_name,
 67975:     &nsStyleDisplay::mAnimationNameCount },
 67975:   { eCSSProperty_animation_timing_function,
 67975:     &nsStyleDisplay::mAnimationTimingFunctionCount },
 67975:   { eCSSProperty_animation_direction,
 67975:     &nsStyleDisplay::mAnimationDirectionCount },
 67975:   { eCSSProperty_animation_fill_mode,
 67975:     &nsStyleDisplay::mAnimationFillModeCount },
 67975:   { eCSSProperty_animation_play_state,
 67975:     &nsStyleDisplay::mAnimationPlayStateCount },
 67975:   { eCSSProperty_animation_iteration_count,
 67975:     &nsStyleDisplay::mAnimationIterationCountCount },
 67975: };
 67975: 
 67975: // Information about each transition or animation property that changes
 67975: // during ComputeDisplayData.
 31702: struct TransitionPropData {
 50931:   const nsCSSValueList *list;
 50931:   nsCSSUnit unit;
108991:   uint32_t num;
 31702: };
 31702: 
108991: static uint32_t
 68765: CountTransitionProps(const TransitionPropInfo* aInfo,
 68765:                      TransitionPropData* aData,
 68765:                      size_t aLength,
 68765:                      nsStyleDisplay* aDisplay,
 68765:                      const nsStyleDisplay* aParentDisplay,
 63746:                      const nsRuleData* aRuleData,
 79445:                      bool& aCanStoreInRuleTree)
     1: {
 68765:   // The four transition properties or eight animation properties are
 68765:   // stored in nsCSSDisplay in a single array for all properties.  The
 68765:   // number of transitions is equal to the number of items in the
 68765:   // longest property's value.  Properties that have fewer values than
 68765:   // the longest are filled in by repeating the list.  However, this
 68765:   // repetition does not extend the computed value of that particular
 68765:   // property (for purposes of inheritance, or, in our code, for when
 68765:   // other properties are overridden by a more specific rule).
 31702: 
 31702:   // But actually, since the spec isn't clear yet, we'll fully compute
 31702:   // all of them (so we can switch easily later), but only care about
 31702:   // the ones up to the number of items for 'transition-property', per
 31702:   // http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html .
 31702: 
 31702:   // Transitions are difficult to handle correctly because of this.  For
 31702:   // example, we need to handle scenarios such as:
 31702:   //  * a more general rule specifies transition-property: a, b, c;
 31702:   //  * a more specific rule overrides as transition-property: d;
 31702:   //
 31702:   // If only the general rule applied, we would fill in the extra
 31702:   // properties (duration, delay, etc) with initial values to create 3
 31702:   // fully-specified transitions.  But when the more specific rule
 31702:   // applies, we should only create a single transition.  In order to do
 31702:   // this we need to remember which properties were explicitly specified
 31702:   // and which ones were just filled in with initial values to get a
 31702:   // fully-specified transition, which we do by remembering the number
 31702:   // of values for each property.
 31702: 
108991:   uint32_t numTransitions = 0;
 68765:   for (size_t i = 0; i < aLength; ++i) {
 68765:     const TransitionPropInfo& info = aInfo[i];
 68765:     TransitionPropData& data = aData[i];
 31702: 
 31702:     // cache whether any of the properties are specified as 'inherit' so
 31702:     // we can use it below
 50931: 
 68765:     const nsCSSValue& value = *aRuleData->ValueFor(info.property);
 68765:     data.unit = value.GetUnit();
 68765:     data.list = (value.GetUnit() == eCSSUnit_List ||
 50931:                  value.GetUnit() == eCSSUnit_ListDep)
106838:                   ? value.GetListValue() : nullptr;
 31702: 
 31702:     // General algorithm to determine how many total transitions we need
 31702:     // to build.  For each property:
 31702:     //  - if there is no value specified in for the property in
 31702:     //    displayData, use the values from the start struct, but only if
 31702:     //    they were explicitly specified
 31702:     //  - if there is a value specified for the property in displayData:
 31702:     //    - if the value is 'inherit', count the number of values for
 31702:     //      that property are specified by the parent, but only those
 31702:     //      that were explicitly specified
 31702:     //    - otherwise, count the number of values specified in displayData
 31702: 
 31702: 
 31702:     // calculate number of elements
 68765:     if (data.unit == eCSSUnit_Inherit) {
 68765:       data.num = aParentDisplay->*(info.sdCount);
 80486:       aCanStoreInRuleTree = false;
 68765:     } else if (data.list) {
 68765:       data.num = ListLength(data.list);
 31702:     } else {
 68765:       data.num = aDisplay->*(info.sdCount);
 68765:     }
 68765:     if (data.num > numTransitions)
 68765:       numTransitions = data.num;
 68765:   }
 68765: 
 68765:   return numTransitions;
 68765: }
 68765: 
 68766: static void
 68766: ComputeTimingFunction(const nsCSSValue& aValue, nsTimingFunction& aResult)
 68766: {
 68766:   switch (aValue.GetUnit()) {
 68766:     case eCSSUnit_Enumerated:
 68766:       aResult = nsTimingFunction(aValue.GetIntValue());
 68766:       break;
 68766:     case eCSSUnit_Cubic_Bezier:
 68766:       {
 68766:         nsCSSValue::Array* array = aValue.GetArrayValue();
 68766:         NS_ASSERTION(array && array->Count() == 4,
 68766:                      "Need 4 control points");
 68766:         aResult = nsTimingFunction(array->Item(0).GetFloatValue(),
 68766:                                    array->Item(1).GetFloatValue(),
 68766:                                    array->Item(2).GetFloatValue(),
 68766:                                    array->Item(3).GetFloatValue());
 68766:       }
 68766:       break;
 68766:     case eCSSUnit_Steps:
 68766:       {
 68766:         nsCSSValue::Array* array = aValue.GetArrayValue();
 68766:         NS_ASSERTION(array && array->Count() == 2,
 68766:                      "Need 2 items");
 68766:         NS_ASSERTION(array->Item(0).GetUnit() == eCSSUnit_Integer,
 68766:                      "unexpected first value");
 68766:         NS_ASSERTION(array->Item(1).GetUnit() == eCSSUnit_Enumerated &&
 68766:                      (array->Item(1).GetIntValue() ==
 68766:                        NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_START ||
 68766:                       array->Item(1).GetIntValue() ==
 68766:                        NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_END),
 68766:                      "unexpected second value");
 68766:         nsTimingFunction::Type type =
 68766:           (array->Item(1).GetIntValue() ==
 68766:             NS_STYLE_TRANSITION_TIMING_FUNCTION_STEP_END)
 68766:             ? nsTimingFunction::StepEnd : nsTimingFunction::StepStart;
 68766:         aResult = nsTimingFunction(type, array->Item(0).GetIntValue());
 68766:       }
 68766:       break;
 68766:     default:
 68766:       NS_NOTREACHED("Invalid transition property unit");
 68766:   }
 68766: }
 68766: 
 68765: const void*
 68765: nsRuleNode::ComputeDisplayData(void* aStartStruct,
 68765:                                const nsRuleData* aRuleData,
 68765:                                nsStyleContext* aContext,
 68765:                                nsRuleNode* aHighestNode,
 68765:                                const RuleDetail aRuleDetail,
 79445:                                const bool aCanStoreInRuleTree)
 68765: {
 68765:   COMPUTE_START_RESET(Display, (), display, parentDisplay)
 68765: 
 81063:   // We may have ended up with aStartStruct's values of mDisplay and
 81063:   // mFloats, but those may not be correct if our style data overrides
 81063:   // its position or float properties.  Reset to mOriginalDisplay and
 81063:   // mOriginalFloats; it if turns out we still need the display/floats
 81063:   // adjustments we'll do them below.
 81063:   display->mDisplay = display->mOriginalDisplay;
 81063:   display->mFloats = display->mOriginalFloats;
 81063: 
 68765:   // Each property's index in this array must match its index in the
 68765:   // const array |transitionPropInfo| above.
 68765:   TransitionPropData transitionPropData[4];
 68765:   TransitionPropData& delay = transitionPropData[0];
 68765:   TransitionPropData& duration = transitionPropData[1];
 68765:   TransitionPropData& property = transitionPropData[2];
 68765:   TransitionPropData& timingFunction = transitionPropData[3];
 68765: 
 68765: #define FOR_ALL_TRANSITION_PROPS(var_) \
108991:                                       for (uint32_t var_ = 0; var_ < 4; ++var_)
 68765: 
 68765:   // CSS Transitions
108991:   uint32_t numTransitions =
 68765:     CountTransitionProps(transitionPropInfo, transitionPropData,
 80467:                          ArrayLength(transitionPropData),
 68765:                          display, parentDisplay, aRuleData,
 68765:                          canStoreInRuleTree);
 31702: 
 31702:   if (!display->mTransitions.SetLength(numTransitions)) {
 31702:     NS_WARNING("failed to allocate transitions array");
 31702:     display->mTransitions.SetLength(1);
 31702:     NS_ABORT_IF_FALSE(display->mTransitions.Length() == 1,
 31702:                       "could not allocate using auto array buffer");
 31702:     numTransitions = 1;
 31702:     FOR_ALL_TRANSITION_PROPS(p) {
 31702:       TransitionPropData& d = transitionPropData[p];
 31702: 
 31702:       d.num = 1;
 31702:     }
 31702:   }
 31702: 
 31702:   FOR_ALL_TRANSITION_PROPS(p) {
 31702:     const TransitionPropInfo& i = transitionPropInfo[p];
 31702:     TransitionPropData& d = transitionPropData[p];
 31702: 
 31702:     display->*(i.sdCount) = d.num;
 31702:   }
 31702: 
 31702:   // Fill in the transitions we just allocated with the appropriate values.
108991:   for (uint32_t i = 0; i < numTransitions; ++i) {
 31702:     nsTransition *transition = &display->mTransitions[i];
 31702: 
 31702:     if (i >= delay.num) {
 31702:       transition->SetDelay(display->mTransitions[i % delay.num].GetDelay());
 50931:     } else if (delay.unit == eCSSUnit_Inherit) {
 33896:       // FIXME (Bug 522599) (for all transition properties): write a test that
 31702:       // detects when this was wrong for i >= delay.num if parent had
 31702:       // count for this property not equal to length
 31702:       NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionDelayCount,
 31702:                         "delay.num computed incorrectly");
 31702:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 31702:                         "should have made canStoreInRuleTree false above");
 31702:       transition->SetDelay(parentDisplay->mTransitions[i].GetDelay());
 50931:     } else if (delay.unit == eCSSUnit_Initial) {
 50931:       transition->SetDelay(0.0);
 31702:     } else if (delay.list) {
 31702:       switch (delay.list->mValue.GetUnit()) {
 31702:         case eCSSUnit_Seconds:
 31702:           transition->SetDelay(PR_MSEC_PER_SEC *
 31702:                                delay.list->mValue.GetFloatValue());
 31702:           break;
 31702:         case eCSSUnit_Milliseconds:
 31702:           transition->SetDelay(delay.list->mValue.GetFloatValue());
 31702:           break;
 31702:         default:
 31702:           NS_NOTREACHED("Invalid delay unit");
 31702:       }
 31702:     }
 31702: 
 31702:     if (i >= duration.num) {
 31702:       transition->SetDuration(
 31702:         display->mTransitions[i % duration.num].GetDuration());
 50931:     } else if (duration.unit == eCSSUnit_Inherit) {
 31702:       NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionDurationCount,
 31702:                         "duration.num computed incorrectly");
 31702:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 31702:                         "should have made canStoreInRuleTree false above");
 31702:       transition->SetDuration(parentDisplay->mTransitions[i].GetDuration());
 50931:     } else if (duration.unit == eCSSUnit_Initial) {
 50931:       transition->SetDuration(0.0);
 31702:     } else if (duration.list) {
 31702:       switch (duration.list->mValue.GetUnit()) {
 31702:         case eCSSUnit_Seconds:
 31702:           transition->SetDuration(PR_MSEC_PER_SEC *
 31702:                                   duration.list->mValue.GetFloatValue());
 31702:           break;
 31702:         case eCSSUnit_Milliseconds:
 31702:           transition->SetDuration(duration.list->mValue.GetFloatValue());
 31702:           break;
 31702:         default:
 31702:           NS_NOTREACHED("Invalid duration unit");
 31702:       }
 31702:     }
 31702: 
 31702:     if (i >= property.num) {
 31702:       transition->CopyPropertyFrom(display->mTransitions[i % property.num]);
 50931:     } else if (property.unit == eCSSUnit_Inherit) {
 31702:       NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionPropertyCount,
 31702:                         "property.num computed incorrectly");
 31702:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 31702:                         "should have made canStoreInRuleTree false above");
 31702:       transition->CopyPropertyFrom(parentDisplay->mTransitions[i]);
 50931:     } else if (property.unit == eCSSUnit_Initial ||
 50931:                property.unit == eCSSUnit_All) {
 50931:       transition->SetProperty(eCSSPropertyExtra_all_properties);
 50931:     } else if (property.unit == eCSSUnit_None) {
 50931:       transition->SetProperty(eCSSPropertyExtra_no_properties);
 31702:     } else if (property.list) {
 50931:       NS_ABORT_IF_FALSE(property.list->mValue.GetUnit() == eCSSUnit_Ident,
 96873:                         nsPrintfCString("Invalid transition property unit %d",
 50931:                                         property.list->mValue.GetUnit()).get());
 50931: 
 31702:       nsDependentString
 31702:         propertyStr(property.list->mValue.GetStringBufferValue());
104540:       nsCSSProperty prop = nsCSSProps::LookupProperty(propertyStr,
104540:                                                       nsCSSProps::eEnabled);
 31702:       if (prop == eCSSProperty_UNKNOWN) {
 31702:         transition->SetUnknownProperty(propertyStr);
 31702:       } else {
 31702:         transition->SetProperty(prop);
 31702:       }
 31702:     }
 31702: 
 31702:     if (i >= timingFunction.num) {
 31702:       transition->SetTimingFunction(
 31702:         display->mTransitions[i % timingFunction.num].GetTimingFunction());
 50931:     } else if (timingFunction.unit == eCSSUnit_Inherit) {
 31702:       NS_ABORT_IF_FALSE(i < parentDisplay->mTransitionTimingFunctionCount,
 31702:                         "timingFunction.num computed incorrectly");
 31702:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 31702:                         "should have made canStoreInRuleTree false above");
 31702:       transition->SetTimingFunction(
 31702:         parentDisplay->mTransitions[i].GetTimingFunction());
 50931:     } else if (timingFunction.unit == eCSSUnit_Initial) {
 50931:       transition->SetTimingFunction(
 50931:         nsTimingFunction(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE));
 31702:     } else if (timingFunction.list) {
 68766:       ComputeTimingFunction(timingFunction.list->mValue,
 68766:                             transition->TimingFunctionSlot());
 31702:     }
 31702: 
 31702:     FOR_ALL_TRANSITION_PROPS(p) {
 31702:       const TransitionPropInfo& info = transitionPropInfo[p];
 31702:       TransitionPropData& d = transitionPropData[p];
 31702: 
 31702:       // if we're at the end of the list, start at the beginning and repeat
 31702:       // until we're out of transitions to populate
 50931:       if (d.list) {
 50931:         d.list = d.list->mNext ? d.list->mNext :
 63746:           aRuleData->ValueFor(info.property)->GetListValue();
 31702:       }
 31702:     }
 31702:   }
 31702: 
 67975:   // Each property's index in this array must match its index in the
 67975:   // const array |animationPropInfo| above.
 67975:   TransitionPropData animationPropData[8];
 67975:   TransitionPropData& animDelay = animationPropData[0];
 67975:   TransitionPropData& animDuration = animationPropData[1];
 67975:   TransitionPropData& animName = animationPropData[2];
 67975:   TransitionPropData& animTimingFunction = animationPropData[3];
 67975:   TransitionPropData& animDirection = animationPropData[4];
 67975:   TransitionPropData& animFillMode = animationPropData[5];
 67975:   TransitionPropData& animPlayState = animationPropData[6];
 67975:   TransitionPropData& animIterationCount = animationPropData[7];
 67975: 
 67975: #define FOR_ALL_ANIMATION_PROPS(var_) \
108991:     for (uint32_t var_ = 0; var_ < 8; ++var_)
 67975: 
 68765:   // CSS Animations.
 68765: 
108991:   uint32_t numAnimations =
 68765:     CountTransitionProps(animationPropInfo, animationPropData,
 80467:                          ArrayLength(animationPropData),
 68765:                          display, parentDisplay, aRuleData,
 68765:                          canStoreInRuleTree);
 67975: 
 67975:   if (!display->mAnimations.SetLength(numAnimations)) {
 67975:     NS_WARNING("failed to allocate animations array");
 67975:     display->mAnimations.SetLength(1);
 67975:     NS_ABORT_IF_FALSE(display->mAnimations.Length() == 1,
 67975:                       "could not allocate using auto array buffer");
 67975:     numAnimations = 1;
 67975:     FOR_ALL_ANIMATION_PROPS(p) {
 67975:       TransitionPropData& d = animationPropData[p];
 67975: 
 67975:       d.num = 1;
 67975:     }
 67975:   }
 67975: 
 67975:   FOR_ALL_ANIMATION_PROPS(p) {
 67975:     const TransitionPropInfo& i = animationPropInfo[p];
 67975:     TransitionPropData& d = animationPropData[p];
 67975: 
 67975:     display->*(i.sdCount) = d.num;
 67975:   }
 67975: 
 67975:   // Fill in the animations we just allocated with the appropriate values.
108991:   for (uint32_t i = 0; i < numAnimations; ++i) {
 67975:     nsAnimation *animation = &display->mAnimations[i];
 67975: 
 67975:     if (i >= animDelay.num) {
 67975:       animation->SetDelay(display->mAnimations[i % animDelay.num].GetDelay());
 67975:     } else if (animDelay.unit == eCSSUnit_Inherit) {
 67975:       // FIXME (Bug 522599) (for all animation properties): write a test that
 67975:       // detects when this was wrong for i >= animDelay.num if parent had
 67975:       // count for this property not equal to length
 67975:       NS_ABORT_IF_FALSE(i < parentDisplay->mAnimationDelayCount,
 67975:                         "animDelay.num computed incorrectly");
 67975:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 67975:                         "should have made canStoreInRuleTree false above");
 67975:       animation->SetDelay(parentDisplay->mAnimations[i].GetDelay());
 67975:     } else if (animDelay.unit == eCSSUnit_Initial) {
 67975:       animation->SetDelay(0.0);
 67975:     } else if (animDelay.list) {
 67975:       switch (animDelay.list->mValue.GetUnit()) {
 67975:         case eCSSUnit_Seconds:
 67975:           animation->SetDelay(PR_MSEC_PER_SEC *
 67975:                               animDelay.list->mValue.GetFloatValue());
 67975:           break;
 67975:         case eCSSUnit_Milliseconds:
 67975:           animation->SetDelay(animDelay.list->mValue.GetFloatValue());
 67975:           break;
 67975:         default:
 67975:           NS_NOTREACHED("Invalid delay unit");
 67975:       }
 67975:     }
 67975: 
 67975:     if (i >= animDuration.num) {
 67975:       animation->SetDuration(
 67975:         display->mAnimations[i % animDuration.num].GetDuration());
 67975:     } else if (animDuration.unit == eCSSUnit_Inherit) {
 67975:       NS_ABORT_IF_FALSE(i < parentDisplay->mAnimationDurationCount,
 67975:                         "animDuration.num computed incorrectly");
 67975:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 67975:                         "should have made canStoreInRuleTree false above");
 67975:       animation->SetDuration(parentDisplay->mAnimations[i].GetDuration());
 67975:     } else if (animDuration.unit == eCSSUnit_Initial) {
 67975:       animation->SetDuration(0.0);
 67975:     } else if (animDuration.list) {
 67975:       switch (animDuration.list->mValue.GetUnit()) {
 67975:         case eCSSUnit_Seconds:
 67975:           animation->SetDuration(PR_MSEC_PER_SEC *
 67975:                                  animDuration.list->mValue.GetFloatValue());
 67975:           break;
 67975:         case eCSSUnit_Milliseconds:
 67975:           animation->SetDuration(animDuration.list->mValue.GetFloatValue());
 67975:           break;
 67975:         default:
 67975:           NS_NOTREACHED("Invalid duration unit");
 67975:       }
 67975:     }
 67975: 
 67975:     if (i >= animName.num) {
 67975:       animation->SetName(display->mAnimations[i % animName.num].GetName());
 67975:     } else if (animName.unit == eCSSUnit_Inherit) {
 67975:       NS_ABORT_IF_FALSE(i < parentDisplay->mAnimationNameCount,
 67975:                         "animName.num computed incorrectly");
 67975:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 67975:                         "should have made canStoreInRuleTree false above");
 67975:       animation->SetName(parentDisplay->mAnimations[i].GetName());
 67975:     } else if (animName.unit == eCSSUnit_Initial) {
 67975:       animation->SetName(EmptyString());
 67975:     } else if (animName.list) {
 67975:       switch (animName.list->mValue.GetUnit()) {
 67975:         case eCSSUnit_Ident: {
 67975:           nsDependentString
 67975:             nameStr(animName.list->mValue.GetStringBufferValue());
 67975:           animation->SetName(nameStr);
 67975:           break;
 67975:         }
 67975:         case eCSSUnit_None: {
 67975:           animation->SetName(EmptyString());
 67975:           break;
 67975:         }
 67975:         default:
 80486:           NS_ABORT_IF_FALSE(false,
 96873:             nsPrintfCString("Invalid animation-name unit %d",
 67975:                                 animName.list->mValue.GetUnit()).get());
 67975:       }
 67975:     }
 67975: 
 67975:     if (i >= animTimingFunction.num) {
 67975:       animation->SetTimingFunction(
 67975:         display->mAnimations[i % animTimingFunction.num].GetTimingFunction());
 67975:     } else if (animTimingFunction.unit == eCSSUnit_Inherit) {
 67975:       NS_ABORT_IF_FALSE(i < parentDisplay->mAnimationTimingFunctionCount,
 67975:                         "animTimingFunction.num computed incorrectly");
 67975:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 67975:                         "should have made canStoreInRuleTree false above");
 67975:       animation->SetTimingFunction(
 67975:         parentDisplay->mAnimations[i].GetTimingFunction());
 67975:     } else if (animTimingFunction.unit == eCSSUnit_Initial) {
 67975:       animation->SetTimingFunction(
 67975:         nsTimingFunction(NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE));
 67975:     } else if (animTimingFunction.list) {
 68766:       ComputeTimingFunction(animTimingFunction.list->mValue,
 68766:                             animation->TimingFunctionSlot());
 67975:     }
 67975: 
 67975:     if (i >= animDirection.num) {
 67975:       animation->SetDirection(display->mAnimations[i % animDirection.num].GetDirection());
 67975:     } else if (animDirection.unit == eCSSUnit_Inherit) {
 67975:       NS_ABORT_IF_FALSE(i < parentDisplay->mAnimationDirectionCount,
 67975:                         "animDirection.num computed incorrectly");
 67975:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 67975:                         "should have made canStoreInRuleTree false above");
 67975:       animation->SetDirection(parentDisplay->mAnimations[i].GetDirection());
 67975:     } else if (animDirection.unit == eCSSUnit_Initial) {
 67975:       animation->SetDirection(NS_STYLE_ANIMATION_DIRECTION_NORMAL);
 67975:     } else if (animDirection.list) {
 67975:       NS_ABORT_IF_FALSE(animDirection.list->mValue.GetUnit() == eCSSUnit_Enumerated,
 96873:                         nsPrintfCString("Invalid animation-direction unit %d",
 67975:                                         animDirection.list->mValue.GetUnit()).get());
 67975: 
 67975:       animation->SetDirection(animDirection.list->mValue.GetIntValue());
 67975:     }
 67975: 
 67975:     if (i >= animFillMode.num) {
 67975:       animation->SetFillMode(display->mAnimations[i % animFillMode.num].GetFillMode());
 67975:     } else if (animFillMode.unit == eCSSUnit_Inherit) {
 67975:       NS_ABORT_IF_FALSE(i < parentDisplay->mAnimationFillModeCount,
 67975:                         "animFillMode.num computed incorrectly");
 67975:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 67975:                         "should have made canStoreInRuleTree false above");
 67975:       animation->SetFillMode(parentDisplay->mAnimations[i].GetFillMode());
 67975:     } else if (animFillMode.unit == eCSSUnit_Initial) {
 67975:       animation->SetFillMode(NS_STYLE_ANIMATION_FILL_MODE_NONE);
 67975:     } else if (animFillMode.list) {
 67975:       NS_ABORT_IF_FALSE(animFillMode.list->mValue.GetUnit() == eCSSUnit_Enumerated,
 96873:                         nsPrintfCString("Invalid animation-fill-mode unit %d",
 67975:                                         animFillMode.list->mValue.GetUnit()).get());
 67975: 
 67975:       animation->SetFillMode(animFillMode.list->mValue.GetIntValue());
 67975:     }
 67975: 
 67975:     if (i >= animPlayState.num) {
 67975:       animation->SetPlayState(display->mAnimations[i % animPlayState.num].GetPlayState());
 67975:     } else if (animPlayState.unit == eCSSUnit_Inherit) {
 67975:       NS_ABORT_IF_FALSE(i < parentDisplay->mAnimationPlayStateCount,
 67975:                         "animPlayState.num computed incorrectly");
 67975:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 67975:                         "should have made canStoreInRuleTree false above");
 67975:       animation->SetPlayState(parentDisplay->mAnimations[i].GetPlayState());
 67975:     } else if (animPlayState.unit == eCSSUnit_Initial) {
 67975:       animation->SetPlayState(NS_STYLE_ANIMATION_PLAY_STATE_RUNNING);
 67975:     } else if (animPlayState.list) {
 67975:       NS_ABORT_IF_FALSE(animPlayState.list->mValue.GetUnit() == eCSSUnit_Enumerated,
 96873:                         nsPrintfCString("Invalid animation-play-state unit %d",
 67975:                                         animPlayState.list->mValue.GetUnit()).get());
 67975: 
 67975:       animation->SetPlayState(animPlayState.list->mValue.GetIntValue());
 67975:     }
 67975: 
 67975:     if (i >= animIterationCount.num) {
 67975:       animation->SetIterationCount(display->mAnimations[i % animIterationCount.num].GetIterationCount());
 67975:     } else if (animIterationCount.unit == eCSSUnit_Inherit) {
 67975:       NS_ABORT_IF_FALSE(i < parentDisplay->mAnimationIterationCountCount,
 67975:                         "animIterationCount.num computed incorrectly");
 67975:       NS_ABORT_IF_FALSE(!canStoreInRuleTree,
 67975:                         "should have made canStoreInRuleTree false above");
 67975:       animation->SetIterationCount(parentDisplay->mAnimations[i].GetIterationCount());
 67975:     } else if (animIterationCount.unit == eCSSUnit_Initial) {
 67975:       animation->SetIterationCount(1.0f);
 67975:     } else if (animIterationCount.list) {
 67975:       switch(animIterationCount.list->mValue.GetUnit()) {
 67975:         case eCSSUnit_Enumerated:
 67975:           NS_ABORT_IF_FALSE(animIterationCount.list->mValue.GetIntValue() ==
 67975:                               NS_STYLE_ANIMATION_ITERATION_COUNT_INFINITE,
 67975:                             "unexpected value");
 67975:           animation->SetIterationCount(NS_IEEEPositiveInfinity());
 67975:           break;
 67975:         case eCSSUnit_Number:
 67975:           animation->SetIterationCount(
 67975:             animIterationCount.list->mValue.GetFloatValue());
 67975:           break;
 67975:         default:
 80486:           NS_ABORT_IF_FALSE(false,
 67975:                             "unexpected animation-iteration-count unit");
 67975:       }
 67975:     }
 67975: 
 67975:     FOR_ALL_ANIMATION_PROPS(p) {
 67975:       const TransitionPropInfo& info = animationPropInfo[p];
 67975:       TransitionPropData& d = animationPropData[p];
 67975: 
 67975:       // if we're at the end of the list, start at the beginning and repeat
 67975:       // until we're out of animations to populate
 67975:       if (d.list) {
 67975:         d.list = d.list->mNext ? d.list->mNext :
 67975:           aRuleData->ValueFor(info.property)->GetListValue();
 67975:       }
 67975:     }
 67975:   }
 67975: 
 18889:   // opacity: factor, inherit, initial
 63746:   SetFactor(*aRuleData->ValueForOpacity(), display->mOpacity, canStoreInRuleTree,
 18889:             parentDisplay->mOpacity, 1.0f, SETFCT_OPACITY);
 18889: 
 34080:   // display: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForDisplay(), display->mDisplay, canStoreInRuleTree,
 34080:               SETDSC_ENUMERATED, parentDisplay->mDisplay,
 34080:               NS_STYLE_DISPLAY_INLINE, 0, 0, 0, 0);
 81063:   // Backup original display value for calculation of a hypothetical
 81063:   // box (CSS2 10.6.4/10.6.5), in addition to getting our style data right later.
 81063:   // See nsHTMLReflowState::CalculateHypotheticalBox
 81063:   display->mOriginalDisplay = display->mDisplay;
 18889: 
 34082:   // appearance: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForAppearance(),
 63746:               display->mAppearance, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentDisplay->mAppearance,
 34082:               NS_THEME_NONE, 0, 0, 0, 0);
     1: 
     1:   // binding: url, none, inherit
 63746:   const nsCSSValue* bindingValue = aRuleData->ValueForBinding();
 63746:   if (eCSSUnit_URL == bindingValue->GetUnit()) {
109319:     mozilla::css::URLValue* url = bindingValue->GetURLStructValue();
  3645:     NS_ASSERTION(url, "What's going on here?");
  3645: 
120353:     if (MOZ_LIKELY(url->GetURI())) {
  3645:       display->mBinding = url;
  3645:     } else {
106838:       display->mBinding = nullptr;
  3645:     }
     1:   }
 63746:   else if (eCSSUnit_None == bindingValue->GetUnit() ||
 63746:            eCSSUnit_Initial == bindingValue->GetUnit()) {
106838:     display->mBinding = nullptr;
     1:   }
 63746:   else if (eCSSUnit_Inherit == bindingValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
     1:     display->mBinding = parentDisplay->mBinding;
     1:   }
     1: 
 18889:   // position: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForPosition(), display->mPosition, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentDisplay->mPosition,
 18889:               NS_STYLE_POSITION_STATIC, 0, 0, 0, 0);
 18889: 
 34082:   // clear: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForClear(), display->mBreakType, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentDisplay->mBreakType,
 34082:               NS_STYLE_CLEAR_NONE, 0, 0, 0, 0);
     1: 
     1:   // temp fix for bug 24000
 80486:   // Map 'auto' and 'avoid' to false, and 'always', 'left', and
 80486:   // 'right' to true.
  3750:   // "A conforming user agent may interpret the values 'left' and
  3750:   // 'right' as 'always'." - CSS2.1, section 13.3.1
 63746:   const nsCSSValue* breakBeforeValue = aRuleData->ValueForPageBreakBefore();
 63746:   if (eCSSUnit_Enumerated == breakBeforeValue->GetUnit()) {
 34082:     display->mBreakBefore =
 63746:       (NS_STYLE_PAGE_BREAK_AVOID != breakBeforeValue->GetIntValue() &&
 63746:        NS_STYLE_PAGE_BREAK_AUTO  != breakBeforeValue->GetIntValue());
 63746:   }
 63746:   else if (eCSSUnit_Initial == breakBeforeValue->GetUnit()) {
 80486:     display->mBreakBefore = false;
  3750:   }
 63746:   else if (eCSSUnit_Inherit == breakBeforeValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
  3750:     display->mBreakBefore = parentDisplay->mBreakBefore;
  3750:   }
  3750: 
 63746:   const nsCSSValue* breakAfterValue = aRuleData->ValueForPageBreakAfter();
 63746:   if (eCSSUnit_Enumerated == breakAfterValue->GetUnit()) {
 34082:     display->mBreakAfter =
 63746:       (NS_STYLE_PAGE_BREAK_AVOID != breakAfterValue->GetIntValue() &&
 63746:        NS_STYLE_PAGE_BREAK_AUTO  != breakAfterValue->GetIntValue());
 63746:   }
 63746:   else if (eCSSUnit_Initial == breakAfterValue->GetUnit()) {
 80486:     display->mBreakAfter = false;
  3750:   }
 63746:   else if (eCSSUnit_Inherit == breakAfterValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
  3750:     display->mBreakAfter = parentDisplay->mBreakAfter;
     1:   }
     1:   // end temp fix
     1: 
121349:   // page-break-inside: enum, inherit, initial
121349:   SetDiscrete(*aRuleData->ValueForPageBreakInside(),
121349:               display->mBreakInside, canStoreInRuleTree,
121349:               SETDSC_ENUMERATED, parentDisplay->mBreakInside,
121349:               NS_STYLE_PAGE_BREAK_AUTO, 0, 0, 0, 0);
121349: 
 34082:   // float: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForCssFloat(),
 63746:               display->mFloats, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentDisplay->mFloats,
 34082:               NS_STYLE_FLOAT_NONE, 0, 0, 0, 0);
 81063:   // Save mFloats in mOriginalFloats in case we need it later
 81063:   display->mOriginalFloats = display->mFloats;
 18889: 
 34081:   // overflow-x: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForOverflowX(),
 63746:               display->mOverflowX, canStoreInRuleTree,
 34081:               SETDSC_ENUMERATED, parentDisplay->mOverflowX,
 34081:               NS_STYLE_OVERFLOW_VISIBLE, 0, 0, 0, 0);
 34081: 
 34081:   // overflow-y: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForOverflowY(),
 63746:               display->mOverflowY, canStoreInRuleTree,
 34081:               SETDSC_ENUMERATED, parentDisplay->mOverflowY,
 34081:               NS_STYLE_OVERFLOW_VISIBLE, 0, 0, 0, 0);
     1: 
     1:   // CSS3 overflow-x and overflow-y require some fixup as well in some
     1:   // cases.  NS_STYLE_OVERFLOW_VISIBLE and NS_STYLE_OVERFLOW_CLIP are
     1:   // meaningful only when used in both dimensions.
     1:   if (display->mOverflowX != display->mOverflowY &&
     1:       (display->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE ||
     1:        display->mOverflowX == NS_STYLE_OVERFLOW_CLIP ||
     1:        display->mOverflowY == NS_STYLE_OVERFLOW_VISIBLE ||
     1:        display->mOverflowY == NS_STYLE_OVERFLOW_CLIP)) {
     1:     // We can't store in the rule tree since a more specific rule might
     1:     // change these conditions.
 80486:     canStoreInRuleTree = false;
     1: 
     1:     // NS_STYLE_OVERFLOW_CLIP is a deprecated value, so if it's specified
     1:     // in only one dimension, convert it to NS_STYLE_OVERFLOW_HIDDEN.
     1:     if (display->mOverflowX == NS_STYLE_OVERFLOW_CLIP)
     1:       display->mOverflowX = NS_STYLE_OVERFLOW_HIDDEN;
     1:     if (display->mOverflowY == NS_STYLE_OVERFLOW_CLIP)
     1:       display->mOverflowY = NS_STYLE_OVERFLOW_HIDDEN;
     1: 
     1:     // If 'visible' is specified but doesn't match the other dimension, it
     1:     // turns into 'auto'.
     1:     if (display->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
     1:       display->mOverflowX = NS_STYLE_OVERFLOW_AUTO;
     1:     if (display->mOverflowY == NS_STYLE_OVERFLOW_VISIBLE)
     1:       display->mOverflowY = NS_STYLE_OVERFLOW_AUTO;
     1:   }
     1: 
 63746:   SetDiscrete(*aRuleData->ValueForResize(), display->mResize, canStoreInRuleTree,
 39638:               SETDSC_ENUMERATED, parentDisplay->mResize,
 39638:               NS_STYLE_RESIZE_NONE, 0, 0, 0, 0);
 39638: 
     1:   // clip property: length, auto, inherit
 63746:   const nsCSSValue* clipValue = aRuleData->ValueForClip();
 63746:   switch (clipValue->GetUnit()) {
 50929:   case eCSSUnit_Inherit:
 80486:     canStoreInRuleTree = false;
     1:     display->mClipFlags = parentDisplay->mClipFlags;
     1:     display->mClip = parentDisplay->mClip;
 50929:     break;
 50929: 
 50929:   case eCSSUnit_Initial:
 50929:   case eCSSUnit_Auto:
  3832:     display->mClipFlags = NS_STYLE_CLIP_AUTO;
  3832:     display->mClip.SetRect(0,0,0,0);
 50929:     break;
 50929: 
 50929:   case eCSSUnit_Null:
 50929:     break;
 50929: 
 50929:   case eCSSUnit_Rect: {
 63746:     const nsCSSRect& clipRect = clipValue->GetRectValue();
 50929: 
 50929:     display->mClipFlags = NS_STYLE_CLIP_RECT;
 50929: 
 50929:     if (clipRect.mTop.GetUnit() == eCSSUnit_Auto) {
     1:       display->mClip.y = 0;
     1:       display->mClipFlags |= NS_STYLE_CLIP_TOP_AUTO;
     1:     }
 50929:     else if (clipRect.mTop.IsLengthUnit()) {
 50929:       display->mClip.y = CalcLength(clipRect.mTop, aContext,
 24636:                                     mPresContext, canStoreInRuleTree);
     1:     }
 50929: 
 50929:     if (clipRect.mBottom.GetUnit() == eCSSUnit_Auto) {
     1:       // Setting to NS_MAXSIZE for the 'auto' case ensures that
     1:       // the clip rect is nonempty. It is important that mClip be
     1:       // nonempty if the actual clip rect could be nonempty.
     1:       display->mClip.height = NS_MAXSIZE;
     1:       display->mClipFlags |= NS_STYLE_CLIP_BOTTOM_AUTO;
     1:     }
 50929:     else if (clipRect.mBottom.IsLengthUnit()) {
 50929:       display->mClip.height = CalcLength(clipRect.mBottom, aContext,
 24636:                                          mPresContext, canStoreInRuleTree) -
     1:                               display->mClip.y;
     1:     }
 50929: 
 50929:     if (clipRect.mLeft.GetUnit() == eCSSUnit_Auto) {
     1:       display->mClip.x = 0;
     1:       display->mClipFlags |= NS_STYLE_CLIP_LEFT_AUTO;
     1:     }
 50929:     else if (clipRect.mLeft.IsLengthUnit()) {
 50929:       display->mClip.x = CalcLength(clipRect.mLeft, aContext,
 24636:                                     mPresContext, canStoreInRuleTree);
     1:     }
 50929: 
 50929:     if (clipRect.mRight.GetUnit() == eCSSUnit_Auto) {
     1:       // Setting to NS_MAXSIZE for the 'auto' case ensures that
     1:       // the clip rect is nonempty. It is important that mClip be
     1:       // nonempty if the actual clip rect could be nonempty.
     1:       display->mClip.width = NS_MAXSIZE;
     1:       display->mClipFlags |= NS_STYLE_CLIP_RIGHT_AUTO;
     1:     }
 50929:     else if (clipRect.mRight.IsLengthUnit()) {
 50929:       display->mClip.width = CalcLength(clipRect.mRight, aContext,
 24636:                                         mPresContext, canStoreInRuleTree) -
     1:                              display->mClip.x;
     1:     }
 50931:     break;
 50931:   }
 50929: 
 50929:   default:
 50929:     NS_ABORT_IF_FALSE(false, "unrecognized clip unit");
     1:   }
     1: 
 16976:   if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
     1:     // CSS2 9.7 specifies display type corrections dealing with 'float'
     1:     // and 'position'.  Since generated content can't be floated or
     1:     // positioned, we can deal with it here.
     1: 
 34387:     if (nsCSSPseudoElements::firstLetter == aContext->GetPseudo()) {
     1:       // a non-floating first-letter must be inline
     1:       // XXX this fix can go away once bug 103189 is fixed correctly
 81063:       // Note that we reset mOriginalDisplay to enforce the invariant that it equals mDisplay if we're not positioned or floating.
 81063:       display->mOriginalDisplay = display->mDisplay = NS_STYLE_DISPLAY_INLINE;
     1: 
     1:       // We can't cache the data in the rule tree since if a more specific
     1:       // rule has 'float: left' we'll end up with the wrong 'display'
     1:       // property.
 80486:       canStoreInRuleTree = false;
     1:     }
     1: 
107225:     if (display->IsAbsolutelyPositionedStyle()) {
  1759:       // 1) if position is 'absolute' or 'fixed' then display must be
     1:       // block-level and float must be 'none'
     1:       EnsureBlockDisplay(display->mDisplay);
     1:       display->mFloats = NS_STYLE_FLOAT_NONE;
     1: 
 81063:       // Note that it's OK to cache this struct in the ruletree
 81063:       // because it's fine as-is for any style context that points to
 81063:       // it directly, and any use of it as aStartStruct (e.g. if a
 81063:       // more specific rule sets "position: static") will use
 81063:       // mOriginalDisplay and mOriginalFloats, which we have carefully
 81063:       // not changed.
  1759:     } else if (display->mFloats != NS_STYLE_FLOAT_NONE) {
  1759:       // 2) if float is not none, and display is not none, then we must
  1759:       // set a block-level 'display' type per CSS2.1 section 9.7.
  1759:       EnsureBlockDisplay(display->mDisplay);
  1759: 
 81063:       // Note that it's OK to cache this struct in the ruletree
 81063:       // because it's fine as-is for any style context that points to
 81063:       // it directly, and any use of it as aStartStruct (e.g. if a
 81063:       // more specific rule sets "float: none") will use
 81063:       // mOriginalDisplay, which we have carefully not changed.
  1759:     }
  1759: 
     1:   }
     1: 
 19214:   /* Convert the nsCSSValueList into an nsTArray<nsTransformFunction *>. */
 63746:   const nsCSSValue* transformValue = aRuleData->ValueForTransform();
 63746:   switch (transformValue->GetUnit()) {
 50931:   case eCSSUnit_Null:
 50931:     break;
 50931: 
 50931:   case eCSSUnit_Initial:
 50931:   case eCSSUnit_None:
106838:     display->mSpecifiedTransform = nullptr;
 50931:     break;
 50931: 
 50931:   case eCSSUnit_Inherit:
 47188:     display->mSpecifiedTransform = parentDisplay->mSpecifiedTransform;
 80486:     canStoreInRuleTree = false;
 50931:     break;
 50931: 
 50931:   case eCSSUnit_List:
 50931:   case eCSSUnit_ListDep: {
 63746:     const nsCSSValueList* head = transformValue->GetListValue();
 50931:     // can get a _None in here from transform animation
 50931:     if (head->mValue.GetUnit() == eCSSUnit_None) {
106838:       NS_ABORT_IF_FALSE(head->mNext == nullptr, "none must be alone");
106838:       display->mSpecifiedTransform = nullptr;
 50931:     } else {
 47188:       display->mSpecifiedTransform = head; // weak pointer, owned by rule
 19214:     }
 50931:     break;
 50931:   }
 50931: 
 50931:   default:
 50931:     NS_ABORT_IF_FALSE(false, "unrecognized transform unit");
 19214:   }
 19214: 
 19214:   /* Convert -moz-transform-origin. */
 63746:   const nsCSSValue* transformOriginValue =
 63746:     aRuleData->ValueForTransformOrigin();
 63746:   if (transformOriginValue->GetUnit() != eCSSUnit_Null) {
 74756:     const nsCSSValue& valX =
 74756:       transformOriginValue->GetUnit() == eCSSUnit_Triplet ?
 74756:         transformOriginValue->GetTripletValue().mXValue : *transformOriginValue;
 74756:     const nsCSSValue& valY =
 74756:       transformOriginValue->GetUnit() == eCSSUnit_Triplet ?
 74756:         transformOriginValue->GetTripletValue().mYValue : *transformOriginValue;
 74756:     const nsCSSValue& valZ =
 74756:       transformOriginValue->GetUnit() == eCSSUnit_Triplet ?
 74756:         transformOriginValue->GetTripletValue().mZValue : *transformOriginValue;
 74756: 
 79445:     mozilla::DebugOnly<bool> cX =
 74756:        SetCoord(valX, display->mTransformOrigin[0],
 19214:                 parentDisplay->mTransformOrigin[0],
 74756:                 SETCOORD_LPH | SETCOORD_INITIAL_HALF |
 74756:                   SETCOORD_BOX_POSITION | SETCOORD_STORE_CALC,
 74756:                 aContext, mPresContext, canStoreInRuleTree);
 74756: 
 79445:      mozilla::DebugOnly<bool> cY =
 74756:        SetCoord(valY, display->mTransformOrigin[1],
 50928:                 parentDisplay->mTransformOrigin[1],
 50928:                 SETCOORD_LPH | SETCOORD_INITIAL_HALF |
 53920:                   SETCOORD_BOX_POSITION | SETCOORD_STORE_CALC,
 24636:                 aContext, mPresContext, canStoreInRuleTree);
 74756: 
 74756:      if (valZ.GetUnit() == eCSSUnit_Null) {
 74756:        // Null for the z component means a 0 translation, not
 74756:        // unspecified, as we have already checked the triplet
 74756:        // value for Null.
 74756:        display->mTransformOrigin[2].SetCoordValue(0);
 74756:      } else {
 79445:        mozilla::DebugOnly<bool> cZ =
 74756:          SetCoord(valZ, display->mTransformOrigin[2],
 74756:                   parentDisplay->mTransformOrigin[2],
 74756:                   SETCOORD_LH | SETCOORD_INITIAL_ZERO | SETCOORD_STORE_CALC,
 74756:                   aContext, mPresContext, canStoreInRuleTree);
 74756:        NS_ABORT_IF_FALSE(cY == cZ, "changed one but not the other");
 74756:      }
 74756:      NS_ABORT_IF_FALSE(cX == cY, "changed one but not the other");
 74756:      NS_ASSERTION(cX, "Malformed -moz-transform-origin parse!");
 19214:   }
 19214: 
 74758:   const nsCSSValue* perspectiveOriginValue =
 74758:     aRuleData->ValueForPerspectiveOrigin();
 74758:   if (perspectiveOriginValue->GetUnit() != eCSSUnit_Null) {
 79445:     mozilla::DebugOnly<bool> result =
 74758:       SetPairCoords(*perspectiveOriginValue,
 74758:                     display->mPerspectiveOrigin[0],
 74758:                     display->mPerspectiveOrigin[1],
 74758:                     parentDisplay->mPerspectiveOrigin[0],
 74758:                     parentDisplay->mPerspectiveOrigin[1],
 74758:                     SETCOORD_LPH | SETCOORD_INITIAL_HALF |
 74758:                     SETCOORD_BOX_POSITION | SETCOORD_STORE_CALC,
 74758:                     aContext, mPresContext, canStoreInRuleTree);
 74758:     NS_ASSERTION(result, "Malformed -moz-perspective-origin parse!");
 74758:   }
 74758: 
 74754:   SetCoord(*aRuleData->ValueForPerspective(), 
 74754:            display->mChildPerspective, parentDisplay->mChildPerspective,
 74754:            SETCOORD_LAH | SETCOORD_INITIAL_ZERO | SETCOORD_NONE,
 74754:            aContext, mPresContext, canStoreInRuleTree);
 74754: 
 74755:   SetDiscrete(*aRuleData->ValueForBackfaceVisibility(),
 74755:               display->mBackfaceVisibility, canStoreInRuleTree,
 74755:               SETDSC_ENUMERATED, parentDisplay->mBackfaceVisibility,
 74755:               NS_STYLE_BACKFACE_VISIBILITY_VISIBLE, 0, 0, 0, 0);
 74755: 
 77285:   // transform-style: enum, inherit, initial
 77285:   SetDiscrete(*aRuleData->ValueForTransformStyle(),
 77285:               display->mTransformStyle, canStoreInRuleTree,
 77285:               SETDSC_ENUMERATED, parentDisplay->mTransformStyle,
 77285:               NS_STYLE_TRANSFORM_STYLE_FLAT, 0, 0, 0, 0);
 77285: 
 69956:   // orient: enum, inherit, initial
 69956:   SetDiscrete(*aRuleData->ValueForOrient(),
 69956:               display->mOrient, canStoreInRuleTree,
 69956:               SETDSC_ENUMERATED, parentDisplay->mOrient,
 69956:               NS_STYLE_ORIENT_HORIZONTAL, 0, 0, 0, 0);
 69956: 
     1:   COMPUTE_END_RESET(Display, display)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeVisibilityData(void* aStartStruct,
 63746:                                   const nsRuleData* aRuleData,
     1:                                   nsStyleContext* aContext,
     1:                                   nsRuleNode* aHighestNode,
 24634:                                   const RuleDetail aRuleDetail,
 79445:                                   const bool aCanStoreInRuleTree)
     1: {
     1:   COMPUTE_START_INHERITED(Visibility, (mPresContext),
 63747:                           visibility, parentVisibility)
     1: 
 76296:   // IMPORTANT: No properties in this struct have lengths in them.  We
 76296:   // depend on this since CalcLengthWith can call GetStyleVisibility()
 76296:   // to get the language for resolving fonts!
 76296: 
 18889:   // direction: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForDirection(), visibility->mDirection,
 24636:               canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentVisibility->mDirection,
 18889:               (GET_BIDI_OPTION_DIRECTION(mPresContext->GetBidi())
 18889:                == IBMBIDI_TEXTDIRECTION_RTL)
 18889:               ? NS_STYLE_DIRECTION_RTL : NS_STYLE_DIRECTION_LTR,
 18889:               0, 0, 0, 0);
 18889: 
 18889:   // visibility: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForVisibility(), visibility->mVisible,
 24636:               canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentVisibility->mVisible,
 18889:               NS_STYLE_VISIBILITY_VISIBLE, 0, 0, 0, 0);
     1: 
 34080:   // pointer-events: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForPointerEvents(), visibility->mPointerEvents,
 32021:               canStoreInRuleTree,
 34080:               SETDSC_ENUMERATED, parentVisibility->mPointerEvents,
 34080:               NS_STYLE_POINTER_EVENTS_AUTO, 0, 0, 0, 0);
 32021: 
     1:   COMPUTE_END_INHERITED(Visibility, visibility)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeColorData(void* aStartStruct,
 63746:                              const nsRuleData* aRuleData,
     1:                              nsStyleContext* aContext,
     1:                              nsRuleNode* aHighestNode,
 24634:                              const RuleDetail aRuleDetail,
 79445:                              const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_INHERITED(Color, (mPresContext), color, parentColor)
     1: 
     1:   // color: color, string, inherit
     1:   // Special case for currentColor.  According to CSS3, setting color to 'currentColor'
     1:   // should behave as if it is inherited
 63746:   const nsCSSValue* colorValue = aRuleData->ValueForColor();
 63746:   if (colorValue->GetUnit() == eCSSUnit_EnumColor &&
 63746:       colorValue->GetIntValue() == NS_COLOR_CURRENTCOLOR) {
     1:     color->mColor = parentColor->mColor;
 80486:     canStoreInRuleTree = false;
  3832:   }
 63746:   else if (colorValue->GetUnit() == eCSSUnit_Initial) {
  3832:     color->mColor = mPresContext->DefaultColor();
  3832:   }
  3832:   else {
 63746:     SetColor(*colorValue, parentColor->mColor, mPresContext, aContext,
 24636:              color->mColor, canStoreInRuleTree);
     1:   }
     1: 
     1:   COMPUTE_END_INHERITED(Color, color)
     1: }
     1: 
 25276: // information about how to compute values for background-* properties
 25276: template <class SpecifiedValueItem>
 25276: struct InitialInheritLocationFor {
 25276: };
 25276: 
 84477: template <>
 25276: struct InitialInheritLocationFor<nsCSSValueList> {
 25276:   static nsCSSValue nsCSSValueList::* Location() {
 25276:     return &nsCSSValueList::mValue;
 25276:   }
 25276: };
 25276: 
 84477: template <>
 25276: struct InitialInheritLocationFor<nsCSSValuePairList> {
 25276:   static nsCSSValue nsCSSValuePairList::* Location() {
 25276:     return &nsCSSValuePairList::mXValue;
 25276:   }
 25276: };
 25276: 
 25276: template <class SpecifiedValueItem, class ComputedValueItem>
 25276: struct BackgroundItemComputer {
 25276: };
 25276: 
 84477: template <>
108991: struct BackgroundItemComputer<nsCSSValueList, uint8_t>
 25276: {
 25276:   static void ComputeValue(nsStyleContext* aStyleContext,
 25276:                            const nsCSSValueList* aSpecifiedValue,
108991:                            uint8_t& aComputedValue,
 79445:                            bool& aCanStoreInRuleTree)
 25276:   {
 25276:     SetDiscrete(aSpecifiedValue->mValue, aComputedValue, aCanStoreInRuleTree,
108991:                 SETDSC_ENUMERATED, uint8_t(0), 0, 0, 0, 0, 0);
 25276:   }
 25276: };
 25276: 
 84477: template <>
 90982: struct BackgroundItemComputer<nsCSSValuePairList, nsStyleBackground::Repeat>
 90982: {
 90982:   static void ComputeValue(nsStyleContext* aStyleContext,
 90982:                            const nsCSSValuePairList* aSpecifiedValue,
 90982:                            nsStyleBackground::Repeat& aComputedValue,
 90982:                            bool& aCanStoreInRuleTree)
 90982:   {
 90982:     NS_ASSERTION(aSpecifiedValue->mXValue.GetUnit() == eCSSUnit_Enumerated &&
 90982:                  (aSpecifiedValue->mYValue.GetUnit() == eCSSUnit_Enumerated ||
 90982:                   aSpecifiedValue->mYValue.GetUnit() == eCSSUnit_Null),
 90982:                  "Invalid unit");
 90982:     
 90982:     bool hasContraction = true;
108991:     uint8_t value = aSpecifiedValue->mXValue.GetIntValue();
 90982:     switch (value) {
 90982:     case NS_STYLE_BG_REPEAT_REPEAT_X:
 90982:       aComputedValue.mXRepeat = NS_STYLE_BG_REPEAT_REPEAT;
 90982:       aComputedValue.mYRepeat = NS_STYLE_BG_REPEAT_NO_REPEAT;
 90982:       break;
 90982:     case NS_STYLE_BG_REPEAT_REPEAT_Y:
 90982:       aComputedValue.mXRepeat = NS_STYLE_BG_REPEAT_NO_REPEAT;
 90982:       aComputedValue.mYRepeat = NS_STYLE_BG_REPEAT_REPEAT;
 90982:       break;
 90982:     default:
 90982:       aComputedValue.mXRepeat = value;
 90982:       hasContraction = false;
 90982:       break;
 90982:     }
 90982:     
 90982:     if (hasContraction) {
 90982:       NS_ASSERTION(aSpecifiedValue->mYValue.GetUnit() == eCSSUnit_Null,
 90982:                    "Invalid unit.");
 90982:       return;
 90982:     }
 90982:     
 90982:     switch (aSpecifiedValue->mYValue.GetUnit()) {
 90982:     case eCSSUnit_Null:
 90982:       aComputedValue.mYRepeat = aComputedValue.mXRepeat;
 90982:       break;
 90982:     case eCSSUnit_Enumerated:
 90982:       value = aSpecifiedValue->mYValue.GetIntValue();
 90982:       NS_ASSERTION(value == NS_STYLE_BG_REPEAT_NO_REPEAT ||
 90982:                    value == NS_STYLE_BG_REPEAT_REPEAT, "Unexpected value");
 90982:       aComputedValue.mYRepeat = value;
 90982:       break;
 90982:     default:
 90982:       NS_NOTREACHED("Unexpected CSS value");
 90982:       break;
 90982:     }
 90982:   }
 90982: };
 90982: 
 90982: template <>
 31749: struct BackgroundItemComputer<nsCSSValueList, nsStyleImage>
 25276: {
 25276:   static void ComputeValue(nsStyleContext* aStyleContext,
 25276:                            const nsCSSValueList* aSpecifiedValue,
 31749:                            nsStyleImage& aComputedValue,
 79445:                            bool& aCanStoreInRuleTree)
 25276:   {
 31749:     SetStyleImage(aStyleContext, aSpecifiedValue->mValue, aComputedValue,
 31749:                   aCanStoreInRuleTree);
 25276:   }
 25276: };
 25276: 
 90524: /* Helper function for
 90524:  * BackgroundItemComputer<nsCSSValue, nsStyleBackground::Position>
 90524:  * It computes a single PositionCoord from an nsCSSValue object
 90524:  * (contained in a list).
 90524:  */
 90524: typedef nsStyleBackground::Position::PositionCoord PositionCoord;
 90524: static void
 90524: ComputeBackgroundPositionCoord(nsStyleContext* aStyleContext,
 90524:                                const nsCSSValue& aEdge,
 90524:                                const nsCSSValue& aOffset,
 90524:                                PositionCoord* aResult,
 79445:                                bool& aCanStoreInRuleTree)
 25276: {
 90524:   if (eCSSUnit_Percent == aOffset.GetUnit()) {
 90524:     aResult->mLength = 0;
 90524:     aResult->mPercent = aOffset.GetPercentValue();
 90524:     aResult->mHasPercent = true;
 90524:   } else if (aOffset.IsLengthUnit()) {
 90524:     aResult->mLength = CalcLength(aOffset, aStyleContext,
 90524:                                   aStyleContext->PresContext(),
 25276:                                   aCanStoreInRuleTree);
 90524:     aResult->mPercent = 0.0f;
 90524:     aResult->mHasPercent = false;
 90524:   } else if (aOffset.IsCalcUnit()) {
 53920:     LengthPercentPairCalcOps ops(aStyleContext,
 53920:                                  aStyleContext->PresContext(),
 53920:                                  aCanStoreInRuleTree);
 90524:     nsRuleNode::ComputedCalc vals = ComputeCalc(aOffset, ops);
 90524:     aResult->mLength = vals.mLength;
 90524:     aResult->mPercent = vals.mPercent;
 90524:     aResult->mHasPercent = ops.mHasPercent;
 25276:   } else {
 90524:     aResult->mLength = 0;
 90524:     aResult->mPercent = 0.0f;
 90524:     aResult->mHasPercent = false;
 90524:     NS_ASSERTION(aOffset.GetUnit() == eCSSUnit_Null, "unexpected unit");
 90524:   }
 90524: 
 90524:   if (eCSSUnit_Enumerated == aEdge.GetUnit()) {
 90524:     int sign;
 90524:     if (aEdge.GetIntValue() & (NS_STYLE_BG_POSITION_BOTTOM |
 90524:                                NS_STYLE_BG_POSITION_RIGHT)) {
 90524:       sign = -1;
 90524:     } else {
 90524:       sign = 1;
 90524:     }
 90524:     aResult->mPercent = GetFloatFromBoxPosition(aEdge.GetIntValue()) +
 90524:                         sign * aResult->mPercent;
 90524:     aResult->mLength = sign * aResult->mLength;
 90524:     aResult->mHasPercent = true;
 90524:   } else {
 90524:     NS_ASSERTION(eCSSUnit_Null == aEdge.GetUnit(), "unexpected unit");
 90524:   }
 90524: }
 90524: 
 90524: template <>
 90524: struct BackgroundItemComputer<nsCSSValueList, nsStyleBackground::Position>
 90524: {
 90524:   static void ComputeValue(nsStyleContext* aStyleContext,
 90524:                            const nsCSSValueList* aSpecifiedValue,
 90524:                            nsStyleBackground::Position& aComputedValue,
 90524:                            bool& aCanStoreInRuleTree)
 90524:   {
 90524:     NS_ASSERTION(aSpecifiedValue->mValue.GetUnit() == eCSSUnit_Array, "bg-position not an array");
 90524: 
 90524:     nsRefPtr<nsCSSValue::Array> bgPositionArray =
 90524:                                   aSpecifiedValue->mValue.GetArrayValue();
 90524:     const nsCSSValue &xEdge   = bgPositionArray->Item(0);
 90524:     const nsCSSValue &xOffset = bgPositionArray->Item(1);
 90524:     const nsCSSValue &yEdge   = bgPositionArray->Item(2);
 90524:     const nsCSSValue &yOffset = bgPositionArray->Item(3);
 90524: 
 90524:     NS_ASSERTION((eCSSUnit_Enumerated == xEdge.GetUnit()  ||
 90524:                   eCSSUnit_Null       == xEdge.GetUnit()) &&
 90524:                  (eCSSUnit_Enumerated == yEdge.GetUnit()  ||
 90524:                   eCSSUnit_Null       == yEdge.GetUnit()) &&
 90524:                   eCSSUnit_Enumerated != xOffset.GetUnit()  &&
 90524:                   eCSSUnit_Enumerated != yOffset.GetUnit(),
 90524:                   "Invalid background position");
 90524: 
 90524:     ComputeBackgroundPositionCoord(aStyleContext, xEdge, xOffset,
 90524:                                    &aComputedValue.mXPosition,
 90524:                                    aCanStoreInRuleTree);
 90524: 
 90524:     ComputeBackgroundPositionCoord(aStyleContext, yEdge, yOffset,
 90524:                                    &aComputedValue.mYPosition,
 90524:                                    aCanStoreInRuleTree);
 25276:   }
 25276: };
 25276: 
 25276: 
 30894: struct BackgroundSizeAxis {
 30894:   nsCSSValue nsCSSValuePairList::* specified;
 30894:   nsStyleBackground::Size::Dimension nsStyleBackground::Size::* result;
108991:   uint8_t nsStyleBackground::Size::* type;
 30894: };
 30894: 
 30894: static const BackgroundSizeAxis gBGSizeAxes[] = {
 30894:   { &nsCSSValuePairList::mXValue,
 30894:     &nsStyleBackground::Size::mWidth,
 30894:     &nsStyleBackground::Size::mWidthType },
 30894:   { &nsCSSValuePairList::mYValue,
 30894:     &nsStyleBackground::Size::mHeight,
 30894:     &nsStyleBackground::Size::mHeightType }
 30894: };
 30894: 
 84477: template <>
 30894: struct BackgroundItemComputer<nsCSSValuePairList, nsStyleBackground::Size>
 30894: {
 30894:   static void ComputeValue(nsStyleContext* aStyleContext,
 30894:                            const nsCSSValuePairList* aSpecifiedValue,
 30894:                            nsStyleBackground::Size& aComputedValue,
 79445:                            bool& aCanStoreInRuleTree)
 30894:   {
 30894:     nsStyleBackground::Size &size = aComputedValue;
 30894:     for (const BackgroundSizeAxis *axis = gBGSizeAxes,
 80467:                         *axis_end = ArrayEnd(gBGSizeAxes);
 80467:          axis < axis_end; ++axis) {
 30894:       const nsCSSValue &specified = aSpecifiedValue->*(axis->specified);
 30894:       if (eCSSUnit_Auto == specified.GetUnit()) {
 30894:         size.*(axis->type) = nsStyleBackground::Size::eAuto;
 30894:       }
 30894:       else if (eCSSUnit_Enumerated == specified.GetUnit()) {
 90821:         MOZ_STATIC_ASSERT(nsStyleBackground::Size::eContain ==
 90821:                           NS_STYLE_BG_SIZE_CONTAIN &&
 90821:                           nsStyleBackground::Size::eCover ==
 90821:                           NS_STYLE_BG_SIZE_COVER,
 90821:                           "background size constants out of sync");
 30894:         NS_ABORT_IF_FALSE(specified.GetIntValue() == NS_STYLE_BG_SIZE_CONTAIN ||
 30894:                           specified.GetIntValue() == NS_STYLE_BG_SIZE_COVER,
 30894:                           "invalid enumerated value for size coordinate");
 30894:         size.*(axis->type) = specified.GetIntValue();
 30894:       }
 30894:       else if (eCSSUnit_Null == specified.GetUnit()) {
 30894:         NS_ABORT_IF_FALSE(axis == gBGSizeAxes + 1,
 30894:                           "null allowed only as height value, and only "
 30894:                           "for contain/cover/initial/inherit");
 30894: #ifdef DEBUG
 30894:         {
 30894:           const nsCSSValue &widthValue = aSpecifiedValue->mXValue;
 30894:           NS_ABORT_IF_FALSE(widthValue.GetUnit() != eCSSUnit_Inherit &&
 30894:                             widthValue.GetUnit() != eCSSUnit_Initial,
 30894:                             "initial/inherit should already have been handled");
 30894:           NS_ABORT_IF_FALSE(widthValue.GetUnit() == eCSSUnit_Enumerated &&
 30894:                             (widthValue.GetIntValue() == NS_STYLE_BG_SIZE_CONTAIN ||
 30894:                              widthValue.GetIntValue() == NS_STYLE_BG_SIZE_COVER),
 30894:                             "null height value not corresponding to allowable "
 30894:                             "non-null width value");
 30894:         }
 30894: #endif
 30894:         size.*(axis->type) = size.mWidthType;
 30894:       }
 30894:       else if (eCSSUnit_Percent == specified.GetUnit()) {
 53919:         (size.*(axis->result)).mLength = 0;
 53919:         (size.*(axis->result)).mPercent = specified.GetPercentValue();
 80486:         (size.*(axis->result)).mHasPercent = true;
 53919:         size.*(axis->type) = nsStyleBackground::Size::eLengthPercentage;
 30894:       }
 53920:       else if (specified.IsLengthUnit()) {
 53919:         (size.*(axis->result)).mLength =
 30894:           CalcLength(specified, aStyleContext, aStyleContext->PresContext(),
 30894:                      aCanStoreInRuleTree);
 53919:         (size.*(axis->result)).mPercent = 0.0f;
 80486:         (size.*(axis->result)).mHasPercent = false;
 53919:         size.*(axis->type) = nsStyleBackground::Size::eLengthPercentage;
 53920:       } else {
 53920:         NS_ABORT_IF_FALSE(specified.IsCalcUnit(), "unexpected unit");
 53920:         LengthPercentPairCalcOps ops(aStyleContext,
 53920:                                      aStyleContext->PresContext(),
 53920:                                      aCanStoreInRuleTree);
 53920:         nsRuleNode::ComputedCalc vals = ComputeCalc(specified, ops);
 53920:         (size.*(axis->result)).mLength = vals.mLength;
 53920:         (size.*(axis->result)).mPercent = vals.mPercent;
 70429:         (size.*(axis->result)).mHasPercent = ops.mHasPercent;
 53920:         size.*(axis->type) = nsStyleBackground::Size::eLengthPercentage;
 30894:       }
 30894:     }
 30894: 
 30894:     NS_ABORT_IF_FALSE(size.mWidthType < nsStyleBackground::Size::eDimensionType_COUNT,
 30894:                       "bad width type");
 30894:     NS_ABORT_IF_FALSE(size.mHeightType < nsStyleBackground::Size::eDimensionType_COUNT,
 30894:                       "bad height type");
 30894:     NS_ABORT_IF_FALSE((size.mWidthType != nsStyleBackground::Size::eContain &&
 30894:                        size.mWidthType != nsStyleBackground::Size::eCover) ||
 30894:                       size.mWidthType == size.mHeightType,
 30894:                       "contain/cover apply to both dimensions or to neither");
 30894:   }
 30894: };
 30894: 
 50931: template <class ComputedValueItem>
 25276: static void
 25276: SetBackgroundList(nsStyleContext* aStyleContext,
 50931:                   const nsCSSValue& aValue,
 25276:                   nsAutoTArray< nsStyleBackground::Layer, 1> &aLayers,
 50931:                   const nsAutoTArray<nsStyleBackground::Layer, 1> &aParentLayers,
 25276:                   ComputedValueItem nsStyleBackground::Layer::* aResultLocation,
 25276:                   ComputedValueItem aInitialValue,
108991:                   uint32_t aParentItemCount,
108991:                   uint32_t& aItemCount,
108991:                   uint32_t& aMaxItemCount,
 79445:                   bool& aRebuild,
 79445:                   bool& aCanStoreInRuleTree)
 25276: {
 50931:   switch (aValue.GetUnit()) {
 50931:   case eCSSUnit_Null:
 50931:     break;
 50931: 
 50931:   case eCSSUnit_Inherit:
 80486:     aRebuild = true;
 80486:     aCanStoreInRuleTree = false;
 25276:     if (!aLayers.EnsureLengthAtLeast(aParentItemCount)) {
 25276:       NS_WARNING("out of memory");
 25276:       aParentItemCount = aLayers.Length();
 25276:     }
 25276:     aItemCount = aParentItemCount;
108991:     for (uint32_t i = 0; i < aParentItemCount; ++i) {
 25276:       aLayers[i].*aResultLocation = aParentLayers[i].*aResultLocation;
 25276:     }
 50931:     break;
 50931: 
 50931:   case eCSSUnit_Initial:
 80486:     aRebuild = true;
 25276:     aItemCount = 1;
 25276:     aLayers[0].*aResultLocation = aInitialValue;
 50931:     break;
 50931: 
 50931:   case eCSSUnit_List:
 50931:   case eCSSUnit_ListDep: {
 80486:     aRebuild = true;
 25276:     aItemCount = 0;
 50931:     const nsCSSValueList* item = aValue.GetListValue();
 25276:     do {
 50931:       NS_ASSERTION(item->mValue.GetUnit() != eCSSUnit_Null &&
 50931:                    item->mValue.GetUnit() != eCSSUnit_Inherit &&
 50931:                    item->mValue.GetUnit() != eCSSUnit_Initial,
 25276:                    "unexpected unit");
 25276:       ++aItemCount;
 25276:       if (!aLayers.EnsureLengthAtLeast(aItemCount)) {
 25276:         NS_WARNING("out of memory");
 25276:         --aItemCount;
 25276:         break;
 25276:       }
 50931:       BackgroundItemComputer<nsCSSValueList, ComputedValueItem>
 25276:         ::ComputeValue(aStyleContext, item,
 25276:                        aLayers[aItemCount-1].*aResultLocation,
 25276:                        aCanStoreInRuleTree);
 25276:       item = item->mNext;
 25276:     } while (item);
 50931:     break;
 50931:   }
 50931: 
 50931:   default:
 50931:     NS_ABORT_IF_FALSE(false,
 96873:                       nsPrintfCString("unexpected unit %d",
 50931:                                       aValue.GetUnit()).get());
 25276:   }
 25276: 
 25276:   if (aItemCount > aMaxItemCount)
 25276:     aMaxItemCount = aItemCount;
 25276: }
 25276: 
 25276: template <class ComputedValueItem>
 25276: static void
 50930: SetBackgroundPairList(nsStyleContext* aStyleContext,
 50930:                       const nsCSSValue& aValue,
 50930:                       nsAutoTArray< nsStyleBackground::Layer, 1> &aLayers,
 50930:                       const nsAutoTArray<nsStyleBackground::Layer, 1>
 50930:                                                                  &aParentLayers,
 50930:                       ComputedValueItem nsStyleBackground::Layer::*
 50930:                                                                 aResultLocation,
 50930:                       ComputedValueItem aInitialValue,
108991:                       uint32_t aParentItemCount,
108991:                       uint32_t& aItemCount,
108991:                       uint32_t& aMaxItemCount,
 79445:                       bool& aRebuild,
 79445:                       bool& aCanStoreInRuleTree)
 50930: {
 50930:   switch (aValue.GetUnit()) {
 50930:   case eCSSUnit_Null:
 50930:     break;
 50930: 
 50930:   case eCSSUnit_Inherit:
 80486:     aRebuild = true;
 80486:     aCanStoreInRuleTree = false;
 50930:     if (!aLayers.EnsureLengthAtLeast(aParentItemCount)) {
 50930:       NS_WARNING("out of memory");
 50930:       aParentItemCount = aLayers.Length();
 50930:     }
 50930:     aItemCount = aParentItemCount;
108991:     for (uint32_t i = 0; i < aParentItemCount; ++i) {
 50930:       aLayers[i].*aResultLocation = aParentLayers[i].*aResultLocation;
 50930:     }
 50930:     break;
 50930: 
 50930:   case eCSSUnit_Initial:
 80486:     aRebuild = true;
 50930:     aItemCount = 1;
 50930:     aLayers[0].*aResultLocation = aInitialValue;
 50930:     break;
 50930: 
 50930:   case eCSSUnit_PairList:
 50930:   case eCSSUnit_PairListDep: {
 80486:     aRebuild = true;
 50930:     aItemCount = 0;
 50930:     const nsCSSValuePairList* item = aValue.GetPairListValue();
 50930:     do {
 50930:       NS_ASSERTION(item->mXValue.GetUnit() != eCSSUnit_Inherit &&
 50930:                    item->mXValue.GetUnit() != eCSSUnit_Initial &&
 50930:                    item->mYValue.GetUnit() != eCSSUnit_Inherit &&
 50930:                    item->mYValue.GetUnit() != eCSSUnit_Initial,
 50930:                    "unexpected unit");
 50930:       ++aItemCount;
 50930:       if (!aLayers.EnsureLengthAtLeast(aItemCount)) {
 50930:         NS_WARNING("out of memory");
 50930:         --aItemCount;
 50930:         break;
 50930:       }
 50930:       BackgroundItemComputer<nsCSSValuePairList, ComputedValueItem>
 50930:         ::ComputeValue(aStyleContext, item,
 50930:                        aLayers[aItemCount-1].*aResultLocation,
 50930:                        aCanStoreInRuleTree);
 50930:       item = item->mNext;
 50930:     } while (item);
 50931:     break;
 50931:   }
 50930: 
 50930:   default:
 50931:     NS_ABORT_IF_FALSE(false,
 96873:                       nsPrintfCString("unexpected unit %d",
 50931:                                       aValue.GetUnit()).get());
 50930:   }
 50930: 
 50930:   if (aItemCount > aMaxItemCount)
 50930:     aMaxItemCount = aItemCount;
 50930: }
 50930: 
 50930: template <class ComputedValueItem>
 50930: static void
 25276: FillBackgroundList(nsAutoTArray< nsStyleBackground::Layer, 1> &aLayers,
 25276:     ComputedValueItem nsStyleBackground::Layer::* aResultLocation,
108991:     uint32_t aItemCount, uint32_t aFillCount)
 25276: {
 25276:   NS_PRECONDITION(aFillCount <= aLayers.Length(), "unexpected array length");
108991:   for (uint32_t sourceLayer = 0, destLayer = aItemCount;
 25276:        destLayer < aFillCount;
 25276:        ++sourceLayer, ++destLayer) {
 25276:     aLayers[destLayer].*aResultLocation =
 25276:       aLayers[sourceLayer].*aResultLocation;
 25276:   }
 25276: }
 25276: 
 10152: const void*
 10152: nsRuleNode::ComputeBackgroundData(void* aStartStruct,
 63746:                                   const nsRuleData* aRuleData,
     1:                                   nsStyleContext* aContext,
     1:                                   nsRuleNode* aHighestNode,
 19182:                                   const RuleDetail aRuleDetail,
 79445:                                   const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(Background, (), bg, parentBG)
     1: 
 29266:   // background-color: color, string, inherit
 63746:   const nsCSSValue* backColorValue = aRuleData->ValueForBackgroundColor();
 63746:   if (eCSSUnit_Initial == backColorValue->GetUnit()) {
 19182:     bg->mBackgroundColor = NS_RGBA(0, 0, 0, 0);
 63746:   } else if (!SetColor(*backColorValue, parentBG->mBackgroundColor,
 29266:                        mPresContext, aContext, bg->mBackgroundColor,
 25246:                        canStoreInRuleTree)) {
 63746:     NS_ASSERTION(eCSSUnit_Null == backColorValue->GetUnit(),
 25240:                  "unexpected color unit");
 25240:   }
 25240: 
108991:   uint32_t maxItemCount = 1;
 79445:   bool rebuild = false;
 25276: 
 25276:   // background-image: url (stored as image), none, inherit [list]
 31749:   nsStyleImage initialImage;
 63746:   SetBackgroundList(aContext, *aRuleData->ValueForBackgroundImage(),
 63746:                     bg->mLayers,
 25276:                     parentBG->mLayers, &nsStyleBackground::Layer::mImage,
 30993:                     initialImage, parentBG->mImageCount, bg->mImageCount,
 30993:                     maxItemCount, rebuild, canStoreInRuleTree);
 25276: 
 90982:   // background-repeat: enum, inherit, initial [pair list]
 90982:   nsStyleBackground::Repeat initialRepeat;
 90982:   initialRepeat.SetInitialValues();
 90982:   SetBackgroundPairList(aContext, *aRuleData->ValueForBackgroundRepeat(),
 63746:                         bg->mLayers,
 25276:                         parentBG->mLayers, &nsStyleBackground::Layer::mRepeat,
 90982:                         initialRepeat, parentBG->mRepeatCount,
 90982:                         bg->mRepeatCount, maxItemCount, rebuild, 
 90982:                         canStoreInRuleTree);
 25276: 
 25276:   // background-attachment: enum, inherit, initial [list]
 63746:   SetBackgroundList(aContext, *aRuleData->ValueForBackgroundAttachment(),
 63746:                     bg->mLayers, parentBG->mLayers,
 25276:                     &nsStyleBackground::Layer::mAttachment,
108991:                     uint8_t(NS_STYLE_BG_ATTACHMENT_SCROLL),
 25276:                     parentBG->mAttachmentCount,
 25276:                     bg->mAttachmentCount, maxItemCount, rebuild,
 25276:                     canStoreInRuleTree);
 25276: 
 25276:   // background-clip: enum, inherit, initial [list]
 63746:   SetBackgroundList(aContext, *aRuleData->ValueForBackgroundClip(),
 63746:                     bg->mLayers,
 25276:                     parentBG->mLayers, &nsStyleBackground::Layer::mClip,
108991:                     uint8_t(NS_STYLE_BG_CLIP_BORDER), parentBG->mClipCount,
 25276:                     bg->mClipCount, maxItemCount, rebuild, canStoreInRuleTree);
     1: 
     1:   // background-inline-policy: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForBackgroundInlinePolicy(),
 63746:               bg->mBackgroundInlinePolicy,
 24636:               canStoreInRuleTree, SETDSC_ENUMERATED,
 18889:               parentBG->mBackgroundInlinePolicy,
 18889:               NS_STYLE_BG_INLINE_POLICY_CONTINUOUS, 0, 0, 0, 0);
     1: 
 25276:   // background-origin: enum, inherit, initial [list]
 63746:   SetBackgroundList(aContext, *aRuleData->ValueForBackgroundOrigin(),
 63746:                     bg->mLayers,
 25276:                     parentBG->mLayers, &nsStyleBackground::Layer::mOrigin,
108991:                     uint8_t(NS_STYLE_BG_ORIGIN_PADDING), parentBG->mOriginCount,
 25276:                     bg->mOriginCount, maxItemCount, rebuild,
 25276:                     canStoreInRuleTree);
 25276: 
 25276:   // background-position: enum, length, percent (flags), inherit [pair list]
 25276:   nsStyleBackground::Position initialPosition;
 25276:   initialPosition.SetInitialValues();
 90524:   SetBackgroundList(aContext, *aRuleData->ValueForBackgroundPosition(),
 63746:                     bg->mLayers,
 25276:                     parentBG->mLayers, &nsStyleBackground::Layer::mPosition,
 25276:                     initialPosition, parentBG->mPositionCount,
 25276:                     bg->mPositionCount, maxItemCount, rebuild,
 25276:                     canStoreInRuleTree);
 25276: 
 30894:   // background-size: enum, length, auto, inherit, initial [pair list]
 30894:   nsStyleBackground::Size initialSize;
 30894:   initialSize.SetInitialValues();
 63746:   SetBackgroundPairList(aContext, *aRuleData->ValueForBackgroundSize(),
 63746:                         bg->mLayers,
 30894:                         parentBG->mLayers, &nsStyleBackground::Layer::mSize,
 30894:                         initialSize, parentBG->mSizeCount,
 30894:                         bg->mSizeCount, maxItemCount, rebuild,
 30894:                         canStoreInRuleTree);
 30894: 
 25276:   if (rebuild) {
 25276:     // Delete any extra items.  We need to keep layers in which any
 25276:     // property was specified.
 25276:     bg->mLayers.TruncateLength(maxItemCount);
 25276: 
108991:     uint32_t fillCount = bg->mImageCount;
 25276:     FillBackgroundList(bg->mLayers, &nsStyleBackground::Layer::mImage,
 25276:                        bg->mImageCount, fillCount);
 25276:     FillBackgroundList(bg->mLayers, &nsStyleBackground::Layer::mRepeat,
 25276:                        bg->mRepeatCount, fillCount);
 25276:     FillBackgroundList(bg->mLayers, &nsStyleBackground::Layer::mAttachment,
 25276:                        bg->mAttachmentCount, fillCount);
 25276:     FillBackgroundList(bg->mLayers, &nsStyleBackground::Layer::mClip,
 25276:                        bg->mClipCount, fillCount);
 25276:     FillBackgroundList(bg->mLayers, &nsStyleBackground::Layer::mOrigin,
 25276:                        bg->mOriginCount, fillCount);
 25276:     FillBackgroundList(bg->mLayers, &nsStyleBackground::Layer::mPosition,
 25276:                        bg->mPositionCount, fillCount);
 30894:     FillBackgroundList(bg->mLayers, &nsStyleBackground::Layer::mSize,
 30894:                        bg->mSizeCount, fillCount);
  1540:   }
     1: 
 50817:   // Now that the dust has settled, register the images with the document
108991:   for (uint32_t i = 0; i < bg->mImageCount; ++i)
 50817:     bg->mLayers[i].TrackImages(aContext->PresContext());
 50817: 
     1:   COMPUTE_END_RESET(Background, bg)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeMarginData(void* aStartStruct,
 63746:                               const nsRuleData* aRuleData,
     1:                               nsStyleContext* aContext,
     1:                               nsRuleNode* aHighestNode,
 24634:                               const RuleDetail aRuleDetail,
 79445:                               const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(Margin, (), margin, parentMargin)
     1: 
     1:   // margin: length, percent, auto, inherit
     1:   nsStyleCoord  coord;
 63746:   nsCSSRect ourMargin;
 63746:   ourMargin.mTop = *aRuleData->ValueForMarginTop();
 63746:   ourMargin.mRight = *aRuleData->ValueForMarginRightValue();
 63746:   ourMargin.mBottom = *aRuleData->ValueForMarginBottom();
 63746:   ourMargin.mLeft = *aRuleData->ValueForMarginLeftValue();
     1:   AdjustLogicalBoxProp(aContext,
 63746:                        *aRuleData->ValueForMarginLeftLTRSource(),
 63746:                        *aRuleData->ValueForMarginLeftRTLSource(),
 63746:                        *aRuleData->ValueForMarginStartValue(),
 63746:                        *aRuleData->ValueForMarginEndValue(),
 24636:                        NS_SIDE_LEFT, ourMargin, canStoreInRuleTree);
     1:   AdjustLogicalBoxProp(aContext,
 63746:                        *aRuleData->ValueForMarginRightLTRSource(),
 63746:                        *aRuleData->ValueForMarginRightRTLSource(),
 63746:                        *aRuleData->ValueForMarginEndValue(),
 63746:                        *aRuleData->ValueForMarginStartValue(),
 24636:                        NS_SIDE_RIGHT, ourMargin, canStoreInRuleTree);
  3133:   NS_FOR_CSS_SIDES(side) {
 12630:     nsStyleCoord parentCoord = parentMargin->mMargin.Get(side);
  3133:     if (SetCoord(ourMargin.*(nsCSSRect::sides[side]),
 51776:                  coord, parentCoord,
 51776:                  SETCOORD_LPAH | SETCOORD_INITIAL_ZERO | SETCOORD_STORE_CALC,
 24636:                  aContext, mPresContext, canStoreInRuleTree)) {
  3133:       margin->mMargin.Set(side, coord);
  3133:     }
  3133:   }
     1: 
     1:   margin->RecalcData();
     1:   COMPUTE_END_RESET(Margin, margin)
     1: }
     1: 
 86084: static void
 86084: SetBorderImageRect(const nsCSSValue& aValue,
 86084:                    /** outparam */ nsCSSRect& aRect)
 86084: {
 86084:   switch (aValue.GetUnit()) {
 86084:   case eCSSUnit_Null:
 86084:     aRect.Reset();
 86084:     break;
 86084:   case eCSSUnit_Rect:
 86084:     aRect = aValue.GetRectValue();
 86084:     break;
 86084:   case eCSSUnit_Inherit:
 86084:   case eCSSUnit_Initial:
 86084:     aRect.SetAllSidesTo(aValue);
 86084:     break;
 86084:   default:
 86084:     NS_ASSERTION(false, "Unexpected border image value for rect.");
 86084:   }
 86084: }
 86084: 
 86084: static void
 86084: SetBorderImagePair(const nsCSSValue& aValue,
 86084:                    /** outparam */ nsCSSValuePair& aPair)
 86084: {
 86084:   switch (aValue.GetUnit()) {
 86084:   case eCSSUnit_Null:
 86084:     aPair.Reset();
 86084:     break;
 86084:   case eCSSUnit_Pair:
 86084:     aPair = aValue.GetPairValue();
 86084:     break;
 86084:   case eCSSUnit_Inherit:
 86084:   case eCSSUnit_Initial:
 86084:     aPair.SetBothValuesTo(aValue);
 86084:     break;
 86084:   default:
 86084:     NS_ASSERTION(false, "Unexpected border image value for pair.");
 86084:   }
 86084: }
 86084: 
 86084: static void
 86084: SetBorderImageSlice(const nsCSSValue& aValue,
 86084:                     /** outparam */ nsCSSValue& aSlice,
 86084:                     /** outparam */ nsCSSValue& aFill)
 86084: {
 86084:   const nsCSSValueList* valueList;
 86084:   switch (aValue.GetUnit()) {
 86084:   case eCSSUnit_Null:
 86084:     aSlice.Reset();
 86084:     aFill.Reset();
 86084:     break;
 86084:   case eCSSUnit_List:
 86084:     // Get slice dimensions.
 86084:     valueList = aValue.GetListValue();
 86084:     aSlice = valueList->mValue;
 86084: 
 86084:     // Get "fill" keyword.
 86084:     valueList = valueList->mNext;
 86084:     if (valueList) {
 86084:       aFill = valueList->mValue;
 86084:     } else {
 86084:       aFill.SetInitialValue();
 86084:     }
 86084:     break;
 86084:   case eCSSUnit_Inherit:
 86084:   case eCSSUnit_Initial:
 86084:     aSlice = aValue;
 86084:     aFill = aValue;
 86084:     break;
 86084:   default:
 86084:     NS_ASSERTION(false, "Unexpected border image value for pair.");
 86084:   }
 86084: }
 86084: 
 10152: const void*
 10152: nsRuleNode::ComputeBorderData(void* aStartStruct,
 63746:                               const nsRuleData* aRuleData,
     1:                               nsStyleContext* aContext,
     1:                               nsRuleNode* aHighestNode,
 24634:                               const RuleDetail aRuleDetail,
 79445:                               const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(Border, (mPresContext), border, parentBorder)
     1: 
 52479:   // box-shadow: none, list, inherit, initial
 63746:   const nsCSSValue* boxShadowValue = aRuleData->ValueForBoxShadow();
 63746:   switch (boxShadowValue->GetUnit()) {
 50931:   case eCSSUnit_Null:
 50931:     break;
 50931: 
 50931:   case eCSSUnit_Initial:
 50931:   case eCSSUnit_None:
106838:     border->mBoxShadow = nullptr;
 50931:     break;
 50931: 
 50931:   case eCSSUnit_Inherit:
 50931:     border->mBoxShadow = parentBorder->mBoxShadow;
 80486:     canStoreInRuleTree = false;
 50931:     break;
 50931: 
 50931:   case eCSSUnit_List:
 50931:   case eCSSUnit_ListDep:
 63746:     border->mBoxShadow = GetShadowData(boxShadowValue->GetListValue(),
 80486:                                        aContext, true, canStoreInRuleTree);
 50931:     break;
 50931: 
 50931:   default:
 50931:     NS_ABORT_IF_FALSE(false,
 96873:                       nsPrintfCString("unrecognized shadow unit %d",
 63746:                                       boxShadowValue->GetUnit()).get());
 23017:   }
 15699: 
     1:   // border-width, border-*-width: length, enum, inherit
     1:   nsStyleCoord  coord;
 63746:   nsCSSRect ourBorderWidth;
 63746:   ourBorderWidth.mTop = *aRuleData->ValueForBorderTopWidth();
 63746:   ourBorderWidth.mRight = *aRuleData->ValueForBorderRightWidthValue();
 63746:   ourBorderWidth.mBottom = *aRuleData->ValueForBorderBottomWidth();
 63746:   ourBorderWidth.mLeft = *aRuleData->ValueForBorderLeftWidthValue();
  3133:   AdjustLogicalBoxProp(aContext,
 63746:                        *aRuleData->ValueForBorderLeftWidthLTRSource(),
 63746:                        *aRuleData->ValueForBorderLeftWidthRTLSource(),
 63746:                        *aRuleData->ValueForBorderStartWidthValue(),
 63746:                        *aRuleData->ValueForBorderEndWidthValue(),
 24636:                        NS_SIDE_LEFT, ourBorderWidth, canStoreInRuleTree);
  3133:   AdjustLogicalBoxProp(aContext,
 63746:                        *aRuleData->ValueForBorderRightWidthLTRSource(),
 63746:                        *aRuleData->ValueForBorderRightWidthRTLSource(),
 63746:                        *aRuleData->ValueForBorderEndWidthValue(),
 63746:                        *aRuleData->ValueForBorderStartWidthValue(),
 24636:                        NS_SIDE_RIGHT, ourBorderWidth, canStoreInRuleTree);
     1:   { // scope for compilers with broken |for| loop scoping
     1:     NS_FOR_CSS_SIDES(side) {
  3133:       const nsCSSValue &value = ourBorderWidth.*(nsCSSRect::sides[side]);
     1:       NS_ASSERTION(eCSSUnit_Percent != value.GetUnit(),
     1:                    "Percentage borders not implemented yet "
     1:                    "If implementing, make sure to fix all consumers of "
     1:                    "nsStyleBorder, the IsPercentageAwareChild method, "
     1:                    "the nsAbsoluteContainingBlock::FrameDependsOnContainer "
     1:                    "method, the "
     1:                    "nsLineLayout::IsPercentageAwareReplacedElement method "
     1:                    "and probably some other places");
     1:       if (eCSSUnit_Enumerated == value.GetUnit()) {
     1:         NS_ASSERTION(value.GetIntValue() == NS_STYLE_BORDER_WIDTH_THIN ||
     1:                      value.GetIntValue() == NS_STYLE_BORDER_WIDTH_MEDIUM ||
     1:                      value.GetIntValue() == NS_STYLE_BORDER_WIDTH_THICK,
     1:                      "Unexpected enum value");
     1:         border->SetBorderWidth(side,
     1:                                (mPresContext->GetBorderWidthTable())[value.GetIntValue()]);
     1:       }
 12630:       // OK to pass bad aParentCoord since we're not passing SETCOORD_INHERIT
 52286:       else if (SetCoord(value, coord, nsStyleCoord(),
 52286:                         SETCOORD_LENGTH | SETCOORD_CALC_LENGTH_ONLY,
 24636:                         aContext, mPresContext, canStoreInRuleTree)) {
 15956:         NS_ASSERTION(coord.GetUnit() == eStyleUnit_Coord, "unexpected unit");
 52286:         // clamp negative calc() to 0.
 52286:         border->SetBorderWidth(side, NS_MAX(coord.GetCoordValue(), 0));
     1:       }
     1:       else if (eCSSUnit_Inherit == value.GetUnit()) {
 80486:         canStoreInRuleTree = false;
 15992:         border->SetBorderWidth(side,
 68637:                                parentBorder->GetComputedBorder().Side(side));
     1:       }
     1:       else if (eCSSUnit_Initial == value.GetUnit()) {
     1:         border->SetBorderWidth(side,
     1:           (mPresContext->GetBorderWidthTable())[NS_STYLE_BORDER_WIDTH_MEDIUM]);
     1:       }
 15992:       else {
 15992:         NS_ASSERTION(eCSSUnit_Null == value.GetUnit(),
 15992:                      "missing case handling border width");
 15992:       }
     1:     }
     1:   }
     1: 
 34082:   // border-style, border-*-style: enum, inherit
 63746:   nsCSSRect ourBorderStyle;
 63746:   ourBorderStyle.mTop = *aRuleData->ValueForBorderTopStyle();
 63746:   ourBorderStyle.mRight = *aRuleData->ValueForBorderRightStyleValue();
 63746:   ourBorderStyle.mBottom = *aRuleData->ValueForBorderBottomStyle();
 63746:   ourBorderStyle.mLeft = *aRuleData->ValueForBorderLeftStyleValue();
  3133:   AdjustLogicalBoxProp(aContext,
 63746:                        *aRuleData->ValueForBorderLeftStyleLTRSource(),
 63746:                        *aRuleData->ValueForBorderLeftStyleRTLSource(),
 63746:                        *aRuleData->ValueForBorderStartStyleValue(),
 63746:                        *aRuleData->ValueForBorderEndStyleValue(),
 63746:                        NS_SIDE_LEFT, ourBorderStyle, canStoreInRuleTree);
  3133:   AdjustLogicalBoxProp(aContext,
 63746:                        *aRuleData->ValueForBorderRightStyleLTRSource(),
 63746:                        *aRuleData->ValueForBorderRightStyleRTLSource(),
 63746:                        *aRuleData->ValueForBorderEndStyleValue(),
 63746:                        *aRuleData->ValueForBorderStartStyleValue(),
 63746:                        NS_SIDE_RIGHT, ourBorderStyle, canStoreInRuleTree);
     1:   { // scope for compilers with broken |for| loop scoping
     1:     NS_FOR_CSS_SIDES(side) {
 63746:       const nsCSSValue &value = ourBorderStyle.*(nsCSSRect::sides[side]);
     1:       nsCSSUnit unit = value.GetUnit();
 34082:       NS_ABORT_IF_FALSE(eCSSUnit_None != unit,
 34082:                         "'none' should be handled as enumerated value");
     1:       if (eCSSUnit_Enumerated == unit) {
     1:         border->SetBorderStyle(side, value.GetIntValue());
     1:       }
 34082:       else if (eCSSUnit_Initial == unit) {
     1:         border->SetBorderStyle(side, NS_STYLE_BORDER_STYLE_NONE);
     1:       }
     1:       else if (eCSSUnit_Inherit == unit) {
 80486:         canStoreInRuleTree = false;
     1:         border->SetBorderStyle(side, parentBorder->GetBorderStyle(side));
     1:       }
     1:     }
     1:   }
     1: 
 23017:   // -moz-border-*-colors: color, string, enum, none, inherit/initial
     1:   nscolor borderColor;
     1:   nscolor unused = NS_RGB(0,0,0);
     1: 
 63746:   static const nsCSSProperty borderColorsProps[] = {
 63746:     eCSSProperty_border_top_colors,
 63746:     eCSSProperty_border_right_colors,
 63746:     eCSSProperty_border_bottom_colors,
 63746:     eCSSProperty_border_left_colors
 63746:   };
 63746: 
     1:   NS_FOR_CSS_SIDES(side) {
 63746:     const nsCSSValue& value = *aRuleData->ValueFor(borderColorsProps[side]);
 50931:     switch (value.GetUnit()) {
 50931:     case eCSSUnit_Null:
 50931:       break;
 50931: 
 50931:     case eCSSUnit_Initial:
 50931:     case eCSSUnit_None:
 23017:       border->ClearBorderColors(side);
 50931:       break;
 50931: 
 50931:     case eCSSUnit_Inherit: {
 80486:       canStoreInRuleTree = false;
 97167:       border->ClearBorderColors(side);
 97167:       if (parentContext) {
 23017:         nsBorderColors *parentColors;
 23017:         parentBorder->GetCompositeColors(side, &parentColors);
 23017:         if (parentColors) {
 23017:           border->EnsureBorderColors();
 23017:           border->mBorderColors[side] = parentColors->Clone();
 97167:         }
 23017:       }
 50931:       break;
 50931:     }
 50931: 
 50931:     case eCSSUnit_List:
 50931:     case eCSSUnit_ListDep: {
     1:       // Some composite border color information has been specified for this
     1:       // border side.
     1:       border->EnsureBorderColors();
     1:       border->ClearBorderColors(side);
 50931:       const nsCSSValueList* list = value.GetListValue();
     1:       while (list) {
 19182:         if (SetColor(list->mValue, unused, mPresContext,
 24636:                      aContext, borderColor, canStoreInRuleTree))
 19182:           border->AppendBorderColor(side, borderColor);
 23017:         else {
 23017:           NS_NOTREACHED("unexpected item in -moz-border-*-colors list");
 23017:         }
     1:         list = list->mNext;
     1:       }
 50931:       break;
 50931:     }
 50931: 
 50931:     default:
 50931:       NS_ABORT_IF_FALSE(false, "unrecognized border color unit");
     1:     }
 23017:   }
     1: 
     1:   // border-color, border-*-color: color, string, enum, inherit
 79445:   bool foreground;
 63746:   nsCSSRect ourBorderColor;
 63746:   ourBorderColor.mTop = *aRuleData->ValueForBorderTopColor();
 63746:   ourBorderColor.mRight = *aRuleData->ValueForBorderRightColorValue();
 63746:   ourBorderColor.mBottom = *aRuleData->ValueForBorderBottomColor();
 63746:   ourBorderColor.mLeft = *aRuleData->ValueForBorderLeftColorValue();
  3133:   AdjustLogicalBoxProp(aContext,
 63746:                        *aRuleData->ValueForBorderLeftColorLTRSource(),
 63746:                        *aRuleData->ValueForBorderLeftColorRTLSource(),
 63746:                        *aRuleData->ValueForBorderStartColorValue(),
 63746:                        *aRuleData->ValueForBorderEndColorValue(),
 24636:                        NS_SIDE_LEFT, ourBorderColor, canStoreInRuleTree);
  3133:   AdjustLogicalBoxProp(aContext,
 63746:                        *aRuleData->ValueForBorderRightColorLTRSource(),
 63746:                        *aRuleData->ValueForBorderRightColorRTLSource(),
 63746:                        *aRuleData->ValueForBorderEndColorValue(),
 63746:                        *aRuleData->ValueForBorderStartColorValue(),
 24636:                        NS_SIDE_RIGHT, ourBorderColor, canStoreInRuleTree);
     1:   { // scope for compilers with broken |for| loop scoping
     1:     NS_FOR_CSS_SIDES(side) {
     1:       const nsCSSValue &value = ourBorderColor.*(nsCSSRect::sides[side]);
     1:       if (eCSSUnit_Inherit == value.GetUnit()) {
 80486:         canStoreInRuleTree = false;
     1:         if (parentContext) {
 19182:           parentBorder->GetBorderColor(side, borderColor, foreground);
 19182:           if (foreground) {
     1:             // We want to inherit the color from the parent, not use the
     1:             // color on the element where this chunk of style data will be
     1:             // used.  We can ensure that the data for the parent are fully
     1:             // computed (unlike for the element where this will be used, for
     1:             // which the color could be specified on a more specific rule).
     1:             border->SetBorderColor(side, parentContext->GetStyleColor()->mColor);
     1:           } else
     1:             border->SetBorderColor(side, borderColor);
     1:         } else {
     1:           // We're the root
     1:           border->SetBorderToForeground(side);
     1:         }
     1:       }
 24636:       else if (SetColor(value, unused, mPresContext, aContext, borderColor,
 24636:                         canStoreInRuleTree)) {
     1:         border->SetBorderColor(side, borderColor);
     1:       }
     1:       else if (eCSSUnit_Enumerated == value.GetUnit()) {
     1:         switch (value.GetIntValue()) {
     1:           case NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR:
     1:             border->SetBorderToForeground(side);
     1:             break;
 71160:           default:
 71160:             NS_NOTREACHED("Unexpected enumerated color");
 71160:             break;
     1:         }
     1:       }
  3832:       else if (eCSSUnit_Initial == value.GetUnit()) {
  3832:         border->SetBorderToForeground(side);
  3832:       }
     1:     }
     1:   }
     1: 
 52297:   // border-radius: length, percent, inherit
 20039:   {
 63746:     const nsCSSProperty* subprops =
 63746:       nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_radius);
 50928:     NS_FOR_CSS_FULL_CORNERS(corner) {
 50928:       int cx = NS_FULL_TO_HALF_CORNER(corner, false);
 50928:       int cy = NS_FULL_TO_HALF_CORNER(corner, true);
 63746:       const nsCSSValue& radius = *aRuleData->ValueFor(subprops[corner]);
 50928:       nsStyleCoord parentX = parentBorder->mBorderRadius.Get(cx);
 50928:       nsStyleCoord parentY = parentBorder->mBorderRadius.Get(cy);
 50928:       nsStyleCoord coordX, coordY;
 50928: 
 50928:       if (SetPairCoords(radius, coordX, coordY, parentX, parentY,
 52281:                         SETCOORD_LPH | SETCOORD_INITIAL_ZERO |
 52281:                           SETCOORD_STORE_CALC,
 50928:                         aContext, mPresContext, canStoreInRuleTree)) {
 50928:         border->mBorderRadius.Set(cx, coordX);
 50928:         border->mBorderRadius.Set(cy, coordY);
 50928:       }
     1:     }
     1:   }
     1: 
 18889:   // float-edge: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForFloatEdge(),
 63746:               border->mFloatEdge, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentBorder->mFloatEdge,
 18889:               NS_STYLE_FLOAT_EDGE_CONTENT, 0, 0, 0, 0);
     1: 
 86084:   // border-image-source
 86084:   const nsCSSValue* borderImageSource = aRuleData->ValueForBorderImageSource();
 86084:   if (borderImageSource->GetUnit() == eCSSUnit_Image) {
108323:     NS_SET_IMAGE_REQUEST_WITH_DOC(border->SetBorderImage,
108323:                                   aContext,
108323:                                   borderImageSource->GetImageValue);
 86084:   } else if (borderImageSource->GetUnit() == eCSSUnit_Inherit) {
 86084:     canStoreInRuleTree = false;
 94919:     NS_SET_IMAGE_REQUEST(border->SetBorderImage, aContext,
 86084:                          parentBorder->GetBorderImage());
 86084:   } else if (borderImageSource->GetUnit() == eCSSUnit_Initial ||
 86084:              borderImageSource->GetUnit() == eCSSUnit_None) {
106838:     border->SetBorderImage(nullptr);
 86084:   }
 86084: 
 86084:   nsCSSValue borderImageSliceValue;
 86084:   nsCSSValue borderImageSliceFill;
 86084:   SetBorderImageSlice(*aRuleData->ValueForBorderImageSlice(),
 86084:                       borderImageSliceValue, borderImageSliceFill);
 86084: 
 86084:   // border-image-slice: fill
 86084:   SetDiscrete(borderImageSliceFill,
 86084:               border->mBorderImageFill,
 86084:               canStoreInRuleTree, SETDSC_ENUMERATED,
 86084:               parentBorder->mBorderImageFill,
 86084:               NS_STYLE_BORDER_IMAGE_SLICE_NOFILL, 0, 0, 0, 0);
 86084: 
 86084:   nsCSSRect borderImageSlice;
 86084:   SetBorderImageRect(borderImageSliceValue, borderImageSlice);
 86084: 
 86084:   nsCSSRect borderImageWidth;
 86084:   SetBorderImageRect(*aRuleData->ValueForBorderImageWidth(),
 86084:                      borderImageWidth);
 86084: 
 86084:   nsCSSRect borderImageOutset;
 86084:   SetBorderImageRect(*aRuleData->ValueForBorderImageOutset(),
 86084:                      borderImageOutset);
 86084: 
 15992:   NS_FOR_CSS_SIDES (side) {
 86084:     // border-image-slice
 86084:     if (SetCoord(borderImageSlice.*(nsCSSRect::sides[side]), coord,
 86084:                  parentBorder->mBorderImageSlice.Get(side),
 86084:                  SETCOORD_FACTOR | SETCOORD_PERCENT |
 86084:                  SETCOORD_INHERIT | SETCOORD_INITIAL_HUNDRED_PCT,
 86084:                  aContext, mPresContext, canStoreInRuleTree)) {
 86084:       border->mBorderImageSlice.Set(side, coord);
 86084:     }
 86084: 
 86084:     // border-image-width
 86084:     // 'auto' here means "same as slice"
 86084:     if (SetCoord(borderImageWidth.*(nsCSSRect::sides[side]), coord,
 86084:                  parentBorder->mBorderImageWidth.Get(side),
 86084:                  SETCOORD_LPAH | SETCOORD_FACTOR | SETCOORD_INITIAL_FACTOR_ONE,
 86084:                  aContext, mPresContext, canStoreInRuleTree)) {
 86084:       border->mBorderImageWidth.Set(side, coord);
 86084:     }
 86084: 
 86084:     // border-image-outset
 86084:     if (SetCoord(borderImageOutset.*(nsCSSRect::sides[side]), coord,
 86084:                  parentBorder->mBorderImageOutset.Get(side),
 86084:                  SETCOORD_LENGTH | SETCOORD_FACTOR |
 86084:                  SETCOORD_INHERIT | SETCOORD_INITIAL_FACTOR_ZERO,
 86084:                  aContext, mPresContext, canStoreInRuleTree)) {
 86084:       border->mBorderImageOutset.Set(side, coord);
 86084:     }
 86084:   }
 86084: 
 86084:   // border-image-repeat
 86084:   nsCSSValuePair borderImageRepeat;
 86084:   SetBorderImagePair(*aRuleData->ValueForBorderImageRepeat(),
 86084:                      borderImageRepeat);
 86084: 
 86084:   SetDiscrete(borderImageRepeat.mXValue,
 86084:               border->mBorderImageRepeatH,
 86084:               canStoreInRuleTree, SETDSC_ENUMERATED,
 86084:               parentBorder->mBorderImageRepeatH,
 86084:               NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH, 0, 0, 0, 0);
 86084: 
 86084:   SetDiscrete(borderImageRepeat.mYValue,
 86084:               border->mBorderImageRepeatV,
 86084:               canStoreInRuleTree, SETDSC_ENUMERATED,
 86084:               parentBorder->mBorderImageRepeatV,
 86084:               NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH, 0, 0, 0, 0);
 15992: 
 52148:   if (border->HasBorderImage())
 52148:     border->TrackImage(aContext->PresContext());
 52148: 
     1:   COMPUTE_END_RESET(Border, border)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputePaddingData(void* aStartStruct,
 63746:                                const nsRuleData* aRuleData,
     1:                                nsStyleContext* aContext,
     1:                                nsRuleNode* aHighestNode,
 24634:                                const RuleDetail aRuleDetail,
 79445:                                const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(Padding, (), padding, parentPadding)
     1: 
     1:   // padding: length, percent, inherit
     1:   nsStyleCoord  coord;
 63746:   nsCSSRect ourPadding;
 63746:   ourPadding.mTop = *aRuleData->ValueForPaddingTop();
 63746:   ourPadding.mRight = *aRuleData->ValueForPaddingRightValue();
 63746:   ourPadding.mBottom = *aRuleData->ValueForPaddingBottom();
 63746:   ourPadding.mLeft = *aRuleData->ValueForPaddingLeftValue();
     1:   AdjustLogicalBoxProp(aContext,
 63746:                        *aRuleData->ValueForPaddingLeftLTRSource(),
 63746:                        *aRuleData->ValueForPaddingLeftRTLSource(),
 63746:                        *aRuleData->ValueForPaddingStartValue(),
 63746:                        *aRuleData->ValueForPaddingEndValue(),
 24636:                        NS_SIDE_LEFT, ourPadding, canStoreInRuleTree);
     1:   AdjustLogicalBoxProp(aContext,
 63746:                        *aRuleData->ValueForPaddingRightLTRSource(),
 63746:                        *aRuleData->ValueForPaddingRightRTLSource(),
 63746:                        *aRuleData->ValueForPaddingEndValue(),
 63746:                        *aRuleData->ValueForPaddingStartValue(),
 24636:                        NS_SIDE_RIGHT, ourPadding, canStoreInRuleTree);
  3133:   NS_FOR_CSS_SIDES(side) {
 12630:     nsStyleCoord parentCoord = parentPadding->mPadding.Get(side);
  3133:     if (SetCoord(ourPadding.*(nsCSSRect::sides[side]),
 51776:                  coord, parentCoord,
 51776:                  SETCOORD_LPH | SETCOORD_INITIAL_ZERO | SETCOORD_STORE_CALC,
 24636:                  aContext, mPresContext, canStoreInRuleTree)) {
  3133:       padding->mPadding.Set(side, coord);
  3133:     }
  3133:   }
     1: 
     1:   padding->RecalcData();
     1:   COMPUTE_END_RESET(Padding, padding)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeOutlineData(void* aStartStruct,
 63746:                                const nsRuleData* aRuleData,
     1:                                nsStyleContext* aContext,
     1:                                nsRuleNode* aHighestNode,
 24634:                                const RuleDetail aRuleDetail,
 79445:                                const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(Outline, (mPresContext), outline, parentOutline)
     1: 
     1:   // outline-width: length, enum, inherit
 63746:   const nsCSSValue* outlineWidthValue = aRuleData->ValueForOutlineWidth();
 63746:   if (eCSSUnit_Initial == outlineWidthValue->GetUnit()) {
  3832:     outline->mOutlineWidth =
  3832:       nsStyleCoord(NS_STYLE_BORDER_WIDTH_MEDIUM, eStyleUnit_Enumerated);
  3832:   }
  3832:   else {
 63746:     SetCoord(*outlineWidthValue, outline->mOutlineWidth,
 52285:              parentOutline->mOutlineWidth,
 52285:              SETCOORD_LEH | SETCOORD_CALC_LENGTH_ONLY, aContext,
 24636:              mPresContext, canStoreInRuleTree);
  3832:   }
     1: 
     1:   // outline-offset: length, inherit
 19205:   nsStyleCoord tempCoord;
 63746:   const nsCSSValue* outlineOffsetValue = aRuleData->ValueForOutlineOffset();
 63746:   if (SetCoord(*outlineOffsetValue, tempCoord,
 33820:                nsStyleCoord(parentOutline->mOutlineOffset,
 33820:                             nsStyleCoord::CoordConstructor),
 42145:                SETCOORD_LH | SETCOORD_INITIAL_ZERO | SETCOORD_CALC_LENGTH_ONLY,
 42145:                aContext, mPresContext, canStoreInRuleTree)) {
 19205:     outline->mOutlineOffset = tempCoord.GetCoordValue();
 19205:   } else {
 63746:     NS_ASSERTION(outlineOffsetValue->GetUnit() == eCSSUnit_Null,
 19205:                  "unexpected unit");
 19205:   }
     1: 
     1:   // outline-color: color, string, enum, inherit
     1:   nscolor outlineColor;
     1:   nscolor unused = NS_RGB(0,0,0);
 63746:   const nsCSSValue* outlineColorValue = aRuleData->ValueForOutlineColor();
 63746:   if (eCSSUnit_Inherit == outlineColorValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
     1:     if (parentContext) {
     1:       if (parentOutline->GetOutlineColor(outlineColor))
     1:         outline->SetOutlineColor(outlineColor);
     1:       else {
     1:         // We want to inherit the color from the parent, not use the
     1:         // color on the element where this chunk of style data will be
     1:         // used.  We can ensure that the data for the parent are fully
     1:         // computed (unlike for the element where this will be used, for
     1:         // which the color could be specified on a more specific rule).
     1:         outline->SetOutlineColor(parentContext->GetStyleColor()->mColor);
     1:       }
     1:     } else {
     1:       outline->SetOutlineInitialColor();
     1:     }
     1:   }
 63746:   else if (SetColor(*outlineColorValue, unused, mPresContext,
 24636:                     aContext, outlineColor, canStoreInRuleTree))
     1:     outline->SetOutlineColor(outlineColor);
 63746:   else if (eCSSUnit_Enumerated == outlineColorValue->GetUnit() ||
 63746:            eCSSUnit_Initial == outlineColorValue->GetUnit()) {
     1:     outline->SetOutlineInitialColor();
  3832:   }
     1: 
     1:   // -moz-outline-radius: length, percent, inherit
 20039:   {
 63746:     const nsCSSProperty* subprops =
 63746:       nsCSSProps::SubpropertyEntryFor(eCSSProperty__moz_outline_radius);
 50928:     NS_FOR_CSS_FULL_CORNERS(corner) {
 50928:       int cx = NS_FULL_TO_HALF_CORNER(corner, false);
 50928:       int cy = NS_FULL_TO_HALF_CORNER(corner, true);
 63746:       const nsCSSValue& radius = *aRuleData->ValueFor(subprops[corner]);
 50928:       nsStyleCoord parentX = parentOutline->mOutlineRadius.Get(cx);
 50928:       nsStyleCoord parentY = parentOutline->mOutlineRadius.Get(cy);
 50928:       nsStyleCoord coordX, coordY;
 50928: 
 50928:       if (SetPairCoords(radius, coordX, coordY, parentX, parentY,
 52281:                         SETCOORD_LPH | SETCOORD_INITIAL_ZERO |
 52281:                           SETCOORD_STORE_CALC,
 50928:                         aContext, mPresContext, canStoreInRuleTree)) {
 50928:         outline->mOutlineRadius.Set(cx, coordX);
 50928:         outline->mOutlineRadius.Set(cy, coordY);
 50928:       }
     1:     }
     1:   }
     1: 
 34082:   // outline-style: enum, inherit, initial
 18889:   // cannot use SetDiscrete because of SetOutlineStyle
 63746:   const nsCSSValue* outlineStyleValue = aRuleData->ValueForOutlineStyle();
 63746:   nsCSSUnit unit = outlineStyleValue->GetUnit();
 34082:   NS_ABORT_IF_FALSE(eCSSUnit_None != unit && eCSSUnit_Auto != unit,
 34082:                     "'none' and 'auto' should be handled as enumerated values");
 34082:   if (eCSSUnit_Enumerated == unit) {
 63746:     outline->SetOutlineStyle(outlineStyleValue->GetIntValue());
 34082:   } else if (eCSSUnit_Initial == unit) {
     1:     outline->SetOutlineStyle(NS_STYLE_BORDER_STYLE_NONE);
 34082:   } else if (eCSSUnit_Inherit == unit) {
 80486:     canStoreInRuleTree = false;
     1:     outline->SetOutlineStyle(parentOutline->GetOutlineStyle());
     1:   }
     1: 
     1:   outline->RecalcData(mPresContext);
     1:   COMPUTE_END_RESET(Outline, outline)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeListData(void* aStartStruct,
 63746:                             const nsRuleData* aRuleData,
     1:                             nsStyleContext* aContext,
     1:                             nsRuleNode* aHighestNode,
 24634:                             const RuleDetail aRuleDetail,
 79445:                             const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_INHERITED(List, (), list, parentList)
     1: 
 34082:   // list-style-type: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForListStyleType(),
 63746:               list->mListStyleType, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentList->mListStyleType,
 34082:               NS_STYLE_LIST_STYLE_DISC, 0, 0, 0, 0);
     1: 
     1:   // list-style-image: url, none, inherit
 63746:   const nsCSSValue* imageValue = aRuleData->ValueForListStyleImage();
 63746:   if (eCSSUnit_Image == imageValue->GetUnit()) {
108323:     NS_SET_IMAGE_REQUEST_WITH_DOC(list->SetListStyleImage,
 35581:                                   aContext,
108323:                                   imageValue->GetImageValue)
 63746:   }
 63746:   else if (eCSSUnit_None == imageValue->GetUnit() ||
 63746:            eCSSUnit_Initial == imageValue->GetUnit()) {
106838:     list->SetListStyleImage(nullptr);
     1:   }
 63746:   else if (eCSSUnit_Inherit == imageValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
 35581:     NS_SET_IMAGE_REQUEST(list->SetListStyleImage,
 35581:                          aContext,
 35581:                          parentList->GetListStyleImage())
     1:   }
     1: 
 18889:   // list-style-position: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForListStylePosition(),
 63746:               list->mListStylePosition, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentList->mListStylePosition,
 18889:               NS_STYLE_LIST_STYLE_POSITION_OUTSIDE, 0, 0, 0, 0);
     1: 
     1:   // image region property: length, auto, inherit
 63746:   const nsCSSValue* imageRegionValue = aRuleData->ValueForImageRegion();
 63746:   switch (imageRegionValue->GetUnit()) {
 50929:   case eCSSUnit_Inherit:
 80486:     canStoreInRuleTree = false;
     1:     list->mImageRegion = parentList->mImageRegion;
 50929:     break;
 50929: 
 50929:   case eCSSUnit_Initial:
 50929:   case eCSSUnit_Auto:
 50929:     list->mImageRegion.SetRect(0,0,0,0);
 50929:     break;
 50929: 
 50929:   case eCSSUnit_Null:
 50929:     break;
 50929: 
 50929:   case eCSSUnit_Rect: {
 63746:     const nsCSSRect& rgnRect = imageRegionValue->GetRectValue();
 50929: 
 50929:     if (rgnRect.mTop.GetUnit() == eCSSUnit_Auto)
     1:       list->mImageRegion.y = 0;
 50929:     else if (rgnRect.mTop.IsLengthUnit())
 24636:       list->mImageRegion.y =
 50929:         CalcLength(rgnRect.mTop, aContext, mPresContext, canStoreInRuleTree);
 50929: 
 50929:     if (rgnRect.mBottom.GetUnit() == eCSSUnit_Auto)
     1:       list->mImageRegion.height = 0;
 50929:     else if (rgnRect.mBottom.IsLengthUnit())
 24636:       list->mImageRegion.height =
 50929:         CalcLength(rgnRect.mBottom, aContext, mPresContext,
 50929:                    canStoreInRuleTree) - list->mImageRegion.y;
 50929: 
 50929:     if (rgnRect.mLeft.GetUnit() == eCSSUnit_Auto)
     1:       list->mImageRegion.x = 0;
 50929:     else if (rgnRect.mLeft.IsLengthUnit())
 24636:       list->mImageRegion.x =
 50929:         CalcLength(rgnRect.mLeft, aContext, mPresContext, canStoreInRuleTree);
 50929: 
 50929:     if (rgnRect.mRight.GetUnit() == eCSSUnit_Auto)
     1:       list->mImageRegion.width = 0;
 50929:     else if (rgnRect.mRight.IsLengthUnit())
 24636:       list->mImageRegion.width =
 50929:         CalcLength(rgnRect.mRight, aContext, mPresContext,
 50929:                    canStoreInRuleTree) - list->mImageRegion.x;
 50931:     break;
 50931:   }
 50929: 
 50929:   default:
 50929:     NS_ABORT_IF_FALSE(false, "unrecognized image-region unit");
     1:   }
     1: 
     1:   COMPUTE_END_INHERITED(List, list)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputePositionData(void* aStartStruct,
 63746:                                 const nsRuleData* aRuleData,
     1:                                 nsStyleContext* aContext,
     1:                                 nsRuleNode* aHighestNode,
 24634:                                 const RuleDetail aRuleDetail,
 79445:                                 const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(Position, (), pos, parentPos)
     1: 
 51410:   // box offsets: length, percent, calc, auto, inherit
 63746:   static const nsCSSProperty offsetProps[] = {
 63746:     eCSSProperty_top,
 63746:     eCSSProperty_right,
 63746:     eCSSProperty_bottom,
 63746:     eCSSProperty_left
 63746:   };
     1:   nsStyleCoord  coord;
     1:   NS_FOR_CSS_SIDES(side) {
 12630:     nsStyleCoord parentCoord = parentPos->mOffset.Get(side);
 63746:     if (SetCoord(*aRuleData->ValueFor(offsetProps[side]),
 51410:                  coord, parentCoord,
 51410:                  SETCOORD_LPAH | SETCOORD_INITIAL_AUTO | SETCOORD_STORE_CALC,
 24636:                  aContext, mPresContext, canStoreInRuleTree)) {
     1:       pos->mOffset.Set(side, coord);
     1:     }
     1:   }
     1: 
 63746:   SetCoord(*aRuleData->ValueForWidth(), pos->mWidth, parentPos->mWidth,
 49566:            SETCOORD_LPAEH | SETCOORD_INITIAL_AUTO | SETCOORD_STORE_CALC,
 49566:            aContext, mPresContext, canStoreInRuleTree);
 63746:   SetCoord(*aRuleData->ValueForMinWidth(), pos->mMinWidth, parentPos->mMinWidth,
101738:            SETCOORD_LPAEH | SETCOORD_INITIAL_AUTO | SETCOORD_STORE_CALC,
 51407:            aContext, mPresContext, canStoreInRuleTree);
 63746:   SetCoord(*aRuleData->ValueForMaxWidth(), pos->mMaxWidth, parentPos->mMaxWidth,
 51407:            SETCOORD_LPOEH | SETCOORD_INITIAL_NONE | SETCOORD_STORE_CALC,
 51407:            aContext, mPresContext, canStoreInRuleTree);
     1: 
 63746:   SetCoord(*aRuleData->ValueForHeight(), pos->mHeight, parentPos->mHeight,
 51406:            SETCOORD_LPAH | SETCOORD_INITIAL_AUTO | SETCOORD_STORE_CALC,
 51406:            aContext, mPresContext, canStoreInRuleTree);
 63746:   SetCoord(*aRuleData->ValueForMinHeight(), pos->mMinHeight, parentPos->mMinHeight,
101738:            SETCOORD_LPAH | SETCOORD_INITIAL_AUTO | SETCOORD_STORE_CALC,
 51406:            aContext, mPresContext, canStoreInRuleTree);
 63746:   SetCoord(*aRuleData->ValueForMaxHeight(), pos->mMaxHeight, parentPos->mMaxHeight,
 51406:            SETCOORD_LPOH | SETCOORD_INITIAL_NONE | SETCOORD_STORE_CALC,
 51406:            aContext, mPresContext, canStoreInRuleTree);
     1: 
 18889:   // box-sizing: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForBoxSizing(),
 63746:               pos->mBoxSizing, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentPos->mBoxSizing,
 18889:               NS_STYLE_BOX_SIZING_CONTENT, 0, 0, 0, 0);
     1: 
103868: #ifdef MOZ_FLEXBOX
103871:   // align-items: enum, inherit, initial
103871:   SetDiscrete(*aRuleData->ValueForAlignItems(),
103871:               pos->mAlignItems, canStoreInRuleTree,
103871:               SETDSC_ENUMERATED, parentPos->mAlignItems,
103871:               NS_STYLE_ALIGN_ITEMS_INITIAL_VALUE, 0, 0, 0, 0);
103871: 
103872:   // align-self: enum, inherit, initial
103872:   // NOTE: align-self's initial value is the special keyword "auto", which is
103872:   // supposed to compute to our parent's computed value of "align-items".  So
103872:   // technically, "auto" itself is never a valid computed value for align-self,
103872:   // since it always computes to something else.  Despite that, we do actually
103872:   // store "auto" in nsStylePosition::mAlignSelf, as NS_STYLE_ALIGN_SELF_AUTO
103872:   // (and then resolve it as-necessary).  We do this because "auto" is the
103872:   // initial value for this property, so if we were to actually resolve it in
103872:   // nsStylePosition, we'd never be able to share any nsStylePosition structs
103872:   // in the rule tree, since their mAlignSelf values would depend on the parent
103872:   // style, by default.
103872:   if (aRuleData->ValueForAlignSelf()->GetUnit() == eCSSUnit_Inherit) {
103872:     // Special handling for "align-self: inherit", in case we're inheriting
103872:     // "align-self: auto", in which case we need to resolve the parent's "auto"
103872:     // and inherit that resolved value.
108991:     uint8_t inheritedAlignSelf = parentPos->mAlignSelf;
103872:     if (inheritedAlignSelf == NS_STYLE_ALIGN_SELF_AUTO) {
103872:       if (parentPos == pos) {
103872:         // We're the root node. (If we weren't, COMPUTE_START_RESET would've
103872:         // given us a distinct parentPos, since we've got an 'inherit' value.)
103872:         // Nothing to inherit from --> just use default value.
103872:         inheritedAlignSelf = NS_STYLE_ALIGN_ITEMS_INITIAL_VALUE;
103872:       } else {
103872:         // Our parent's "auto" value should resolve to our grandparent's value
103872:         // for "align-items".  So, that's what we're supposed to inherit.
103872:         NS_ABORT_IF_FALSE(aContext->GetParent(),
103872:                           "we've got a distinct parent style-struct already, "
103872:                           "so we should have a parent style-context");
103872:         nsStyleContext* grandparentContext = aContext->GetParent()->GetParent();
103872:         if (!grandparentContext) {
103872:           // No grandparent --> our parent is the root node, so its
103872:           // "align-self: auto" computes to the default "align-items" value:
103872:           inheritedAlignSelf = NS_STYLE_ALIGN_ITEMS_INITIAL_VALUE;
103872:         } else {
103872:           // Normal case -- we have a grandparent.
103872:           // Its "align-items" value is what we should end up inheriting.
103872:           const nsStylePosition* grandparentPos =
103872:             grandparentContext->GetStylePosition();
103872:           inheritedAlignSelf = grandparentPos->mAlignItems;
103872:         }
103872:       }
103872:     }
103872: 
103872:     pos->mAlignSelf = inheritedAlignSelf;
103872:     canStoreInRuleTree = false;
103872:   } else {
103872:     SetDiscrete(*aRuleData->ValueForAlignSelf(),
103872:                 pos->mAlignSelf, canStoreInRuleTree,
103872:                 SETDSC_ENUMERATED,
103872:                 parentPos->mAlignSelf, // (unused -- we handled inherit above)
103872:                 NS_STYLE_ALIGN_SELF_AUTO, // initial == auto
103872:                 0, 0, 0, 0);
103872:   }
103872: 
103874:   // flex-basis: auto, length, percent, enum, calc, inherit, initial
103874:   // (Note: The flags here should match those used for 'width' property above.)
103874:   SetCoord(*aRuleData->ValueForFlexBasis(), pos->mFlexBasis, parentPos->mFlexBasis,
103874:            SETCOORD_LPAEH | SETCOORD_INITIAL_AUTO | SETCOORD_STORE_CALC,
103874:            aContext, mPresContext, canStoreInRuleTree);
103874: 
103870:   // flex-direction: enum, inherit, initial
103870:   SetDiscrete(*aRuleData->ValueForFlexDirection(),
103870:               pos->mFlexDirection, canStoreInRuleTree,
103870:               SETDSC_ENUMERATED, parentPos->mFlexDirection,
103870:               NS_STYLE_FLEX_DIRECTION_ROW, 0, 0, 0, 0);
103870: 
103873:   // flex-grow: float, inherit, initial
103873:   SetFactor(*aRuleData->ValueForFlexGrow(),
103873:             pos->mFlexGrow, canStoreInRuleTree,
103873:             parentPos->mFlexGrow, 0.0f);
103873: 
103873:   // flex-shrink: float, inherit, initial
103873:   SetFactor(*aRuleData->ValueForFlexShrink(),
103873:             pos->mFlexShrink, canStoreInRuleTree,
103873:             parentPos->mFlexShrink, 1.0f);
103873: 
103869:   // order: integer, inherit, initial
103869:   SetDiscrete(*aRuleData->ValueForOrder(),
103869:               pos->mOrder, canStoreInRuleTree,
103869:               SETDSC_INTEGER, parentPos->mOrder,
103869:               NS_STYLE_ORDER_INITIAL, 0, 0, 0, 0);
103869: 
103868:   // justify-content: enum, inherit, initial
103868:   SetDiscrete(*aRuleData->ValueForJustifyContent(),
103868:               pos->mJustifyContent, canStoreInRuleTree,
103868:               SETDSC_ENUMERATED, parentPos->mJustifyContent,
103868:               NS_STYLE_JUSTIFY_CONTENT_FLEX_START, 0, 0, 0, 0);
103868: #endif // MOZ_FLEXBOX
103868: 
     1:   // z-index
 63746:   const nsCSSValue* zIndexValue = aRuleData->ValueForZIndex();
 63746:   if (! SetCoord(*zIndexValue, pos->mZIndex, parentPos->mZIndex,
  3832:                  SETCOORD_IA | SETCOORD_INITIAL_AUTO, aContext,
106838:                  nullptr, canStoreInRuleTree)) {
 63746:     if (eCSSUnit_Inherit == zIndexValue->GetUnit()) {
     1:       // handle inherit, because it's ok to inherit 'auto' here
 80486:       canStoreInRuleTree = false;
     1:       pos->mZIndex = parentPos->mZIndex;
     1:     }
     1:   }
     1: 
     1:   COMPUTE_END_RESET(Position, pos)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeTableData(void* aStartStruct,
 63746:                              const nsRuleData* aRuleData,
     1:                              nsStyleContext* aContext,
     1:                              nsRuleNode* aHighestNode,
 24634:                              const RuleDetail aRuleDetail,
 79445:                              const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(Table, (), table, parentTable)
     1: 
 34082:   // table-layout: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForTableLayout(),
 63746:               table->mLayoutStrategy, canStoreInRuleTree,
 34082:               SETDSC_ENUMERATED, parentTable->mLayoutStrategy,
 34082:               NS_STYLE_TABLE_LAYOUT_AUTO, 0, 0, 0, 0);
     1: 
     1:   // cols: enum, int (not a real CSS prop)
 63746:   const nsCSSValue* colsValue = aRuleData->ValueForCols();
 63746:   if (eCSSUnit_Enumerated == colsValue->GetUnit() ||
 63746:       eCSSUnit_Integer == colsValue->GetUnit())
 63746:     table->mCols = colsValue->GetIntValue();
     1: 
     1:   // span: pixels (not a real CSS prop)
 63746:   const nsCSSValue* spanValue = aRuleData->ValueForSpan();
 63746:   if (eCSSUnit_Enumerated == spanValue->GetUnit() ||
 63746:       eCSSUnit_Integer == spanValue->GetUnit())
 63746:     table->mSpan = spanValue->GetIntValue();
     1: 
     1:   COMPUTE_END_RESET(Table, table)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeTableBorderData(void* aStartStruct,
 63746:                                    const nsRuleData* aRuleData,
     1:                                    nsStyleContext* aContext,
     1:                                    nsRuleNode* aHighestNode,
 24634:                                    const RuleDetail aRuleDetail,
 79445:                                    const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_INHERITED(TableBorder, (mPresContext), table, parentTable)
     1: 
 18889:   // border-collapse: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForBorderCollapse(), table->mBorderCollapse,
 24636:               canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentTable->mBorderCollapse,
 18889:               NS_STYLE_BORDER_SEPARATE, 0, 0, 0, 0);
     1: 
 63746:   const nsCSSValue* borderSpacingValue = aRuleData->ValueForBorderSpacing();
 63746:   if (borderSpacingValue->GetUnit() != eCSSUnit_Null) {
 50928:     // border-spacing-x/y: length, inherit
 50928:     nsStyleCoord parentX(parentTable->mBorderSpacingX,
 50928:                          nsStyleCoord::CoordConstructor);
 50928:     nsStyleCoord parentY(parentTable->mBorderSpacingY,
 50928:                          nsStyleCoord::CoordConstructor);
 50928:     nsStyleCoord coordX, coordY;
 50928: 
 50928: #ifdef DEBUG
 79445:     bool result =
 50928: #endif
 63746:       SetPairCoords(*borderSpacingValue,
 50928:                     coordX, coordY, parentX, parentY,
 42145:                     SETCOORD_LH | SETCOORD_INITIAL_ZERO |
 50928:                     SETCOORD_CALC_LENGTH_ONLY |
 50928:                     SETCOORD_CALC_CLAMP_NONNEGATIVE,
 50928:                     aContext, mPresContext, canStoreInRuleTree);
 50928:     NS_ASSERTION(result, "malformed table border value");
 50928:     table->mBorderSpacingX = coordX.GetCoordValue();
 50928:     table->mBorderSpacingY = coordY.GetCoordValue();
 19206:   }
     1: 
 18889:   // caption-side: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForCaptionSide(),
 63746:               table->mCaptionSide, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentTable->mCaptionSide,
 18889:               NS_STYLE_CAPTION_SIDE_TOP, 0, 0, 0, 0);
 18889: 
 18889:   // empty-cells: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForEmptyCells(),
 63746:               table->mEmptyCells, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentTable->mEmptyCells,
  3832:               (mPresContext->CompatibilityMode() == eCompatibility_NavQuirks)
  3832:               ? NS_STYLE_TABLE_EMPTY_CELLS_SHOW_BACKGROUND
 18889:               : NS_STYLE_TABLE_EMPTY_CELLS_SHOW,
 18889:               0, 0, 0, 0);
     1: 
     1:   COMPUTE_END_INHERITED(TableBorder, table)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeContentData(void* aStartStruct,
 63746:                                const nsRuleData* aRuleData,
     1:                                nsStyleContext* aContext,
     1:                                nsRuleNode* aHighestNode,
 24634:                                const RuleDetail aRuleDetail,
 79445:                                const bool aCanStoreInRuleTree)
     1: {
108991:   uint32_t count;
 50931:   nsAutoString buffer;
 50931: 
 63747:   COMPUTE_START_RESET(Content, (), content, parentContent)
     1: 
   857:   // content: [string, url, counter, attr, enum]+, normal, none, inherit
 63746:   const nsCSSValue* contentValue = aRuleData->ValueForContent();
 63746:   switch (contentValue->GetUnit()) {
 50931:   case eCSSUnit_Null:
 50931:     break;
 50931: 
 50931:   case eCSSUnit_Normal:
 50931:   case eCSSUnit_None:
 50931:   case eCSSUnit_Initial:
   857:     // "normal", "none", and "initial" all mean no content
     1:     content->AllocateContents(0);
 50931:     break;
 50931: 
 50931:   case eCSSUnit_Inherit:
 80486:     canStoreInRuleTree = false;
     1:     count = parentContent->ContentCount();
     1:     if (NS_SUCCEEDED(content->AllocateContents(count))) {
     1:       while (0 < count--) {
     1:         content->ContentAt(count) = parentContent->ContentAt(count);
     1:       }
     1:     }
 50931:     break;
 50931: 
 50931:   case eCSSUnit_Enumerated: {
 63746:     NS_ABORT_IF_FALSE(contentValue->GetIntValue() ==
 50931:                       NS_STYLE_CONTENT_ALT_CONTENT,
 50931:                       "unrecognized solitary content keyword");
 50931:     content->AllocateContents(1);
 50931:     nsStyleContentData& data = content->ContentAt(0);
 50931:     data.mType = eStyleContentType_AltContent;
106838:     data.mContent.mString = nullptr;
 50931:     break;
 50931:   }
 50931: 
 50931:   case eCSSUnit_List:
 50931:   case eCSSUnit_ListDep: {
 63746:     const nsCSSValueList* contentValueList = contentValue->GetListValue();
     1:       count = 0;
 63746:       while (contentValueList) {
     1:         count++;
 63746:         contentValueList = contentValueList->mNext;
     1:       }
     1:       if (NS_SUCCEEDED(content->AllocateContents(count))) {
     1:         const nsAutoString  nullStr;
     1:         count = 0;
 63746:         contentValueList = contentValue->GetListValue();
 63746:         while (contentValueList) {
 63746:           const nsCSSValue& value = contentValueList->mValue;
     1:           nsCSSUnit unit = value.GetUnit();
     1:           nsStyleContentType type;
     1:           nsStyleContentData &data = content->ContentAt(count++);
     1:           switch (unit) {
     1:           case eCSSUnit_String:   type = eStyleContentType_String;    break;
     1:           case eCSSUnit_Image:    type = eStyleContentType_Image;     break;
     1:           case eCSSUnit_Attr:     type = eStyleContentType_Attr;      break;
     1:           case eCSSUnit_Counter:  type = eStyleContentType_Counter;   break;
     1:           case eCSSUnit_Counters: type = eStyleContentType_Counters;  break;
     1:           case eCSSUnit_Enumerated:
     1:             switch (value.GetIntValue()) {
     1:             case NS_STYLE_CONTENT_OPEN_QUOTE:
     1:               type = eStyleContentType_OpenQuote;     break;
     1:             case NS_STYLE_CONTENT_CLOSE_QUOTE:
     1:               type = eStyleContentType_CloseQuote;    break;
     1:             case NS_STYLE_CONTENT_NO_OPEN_QUOTE:
     1:               type = eStyleContentType_NoOpenQuote;   break;
     1:             case NS_STYLE_CONTENT_NO_CLOSE_QUOTE:
     1:               type = eStyleContentType_NoCloseQuote;  break;
     1:             default:
     1:               NS_ERROR("bad content value");
     1:             }
     1:             break;
     1:           default:
     1:             NS_ERROR("bad content type");
     1:           }
     1:           data.mType = type;
     1:           if (type == eStyleContentType_Image) {
108323:             NS_SET_IMAGE_REQUEST_WITH_DOC(data.SetImage,
108323:                                           aContext,
108323:                                           value.GetImageValue);
     1:           }
     1:           else if (type <= eStyleContentType_Attr) {
     1:             value.GetStringValue(buffer);
     1:             data.mContent.mString = NS_strdup(buffer.get());
     1:           }
     1:           else if (type <= eStyleContentType_Counters) {
     1:             data.mContent.mCounters = value.GetArrayValue();
     1:             data.mContent.mCounters->AddRef();
     1:           }
     1:           else {
106838:             data.mContent.mString = nullptr;
     1:           }
 63746:           contentValueList = contentValueList->mNext;
     1:         }
     1:       }
 50931:       break;
 50931:   }
 50931: 
 50931:   default:
 50931:     NS_ABORT_IF_FALSE(false,
 96873:                       nsPrintfCString("unrecognized content unit %d",
 63746:                                       contentValue->GetUnit()).get());
     1:   }
     1: 
     1:   // counter-increment: [string [int]]+, none, inherit
 63746:   const nsCSSValue* counterIncrementValue =
 63746:     aRuleData->ValueForCounterIncrement();
 63746:   switch (counterIncrementValue->GetUnit()) {
 50930:   case eCSSUnit_Null:
 50930:     break;
 50930: 
 50930:   case eCSSUnit_None:
 50930:   case eCSSUnit_Initial:
     1:     content->AllocateCounterIncrements(0);
 50930:     break;
 50930: 
 50930:   case eCSSUnit_Inherit:
 80486:     canStoreInRuleTree = false;
     1:     count = parentContent->CounterIncrementCount();
     1:     if (NS_SUCCEEDED(content->AllocateCounterIncrements(count))) {
     1:       while (0 < count--) {
     1:         const nsStyleCounterData *data =
     1:           parentContent->GetCounterIncrementAt(count);
     1:         content->SetCounterIncrementAt(count, data->mCounter, data->mValue);
     1:       }
     1:     }
 50930:     break;
 50930: 
 50930:   case eCSSUnit_PairList:
 50930:   case eCSSUnit_PairListDep: {
 50930:     const nsCSSValuePairList* ourIncrement =
 63746:       counterIncrementValue->GetPairListValue();
 50930:     NS_ABORT_IF_FALSE(ourIncrement->mXValue.GetUnit() == eCSSUnit_Ident,
 50930:                       "unexpected value unit");
 50931:     count = ListLength(ourIncrement);
 50930:     if (NS_FAILED(content->AllocateCounterIncrements(count))) {
 50930:       break;
 50930:     }
 50930: 
     1:     count = 0;
 50930:     for (const nsCSSValuePairList* p = ourIncrement; p; p = p->mNext, count++) {
108991:       int32_t increment;
 50930:       if (p->mYValue.GetUnit() == eCSSUnit_Integer) {
 50930:         increment = p->mYValue.GetIntValue();
 50930:       } else {
     1:         increment = 1;
     1:       }
 50930:       p->mXValue.GetStringValue(buffer);
 50930:       content->SetCounterIncrementAt(count, buffer, increment);
 50930:     }
 50931:     break;
 50931:   }
 50930: 
 50930:   default:
 50930:     NS_ABORT_IF_FALSE(false, "unexpected value unit");
     1:   }
     1: 
     1:   // counter-reset: [string [int]]+, none, inherit
 63746:   const nsCSSValue* counterResetValue = aRuleData->ValueForCounterReset();
 63746:   switch (counterResetValue->GetUnit()) {
 50930:   case eCSSUnit_Null:
 50930:     break;
 50930: 
 50930:   case eCSSUnit_None:
 50930:   case eCSSUnit_Initial:
     1:     content->AllocateCounterResets(0);
 50930:     break;
 50930: 
 50930:   case eCSSUnit_Inherit:
 80486:     canStoreInRuleTree = false;
     1:     count = parentContent->CounterResetCount();
     1:     if (NS_SUCCEEDED(content->AllocateCounterResets(count))) {
     1:       while (0 < count--) {
     1:         const nsStyleCounterData *data =
     1:           parentContent->GetCounterResetAt(count);
     1:         content->SetCounterResetAt(count, data->mCounter, data->mValue);
     1:       }
     1:     }
 50930:     break;
 50930: 
 50930:   case eCSSUnit_PairList:
 50930:   case eCSSUnit_PairListDep: {
 50930:     const nsCSSValuePairList* ourReset =
 63746:       counterResetValue->GetPairListValue();
 50930:     NS_ABORT_IF_FALSE(ourReset->mXValue.GetUnit() == eCSSUnit_Ident,
 50930:                       "unexpected value unit");
 50931:     count = ListLength(ourReset);
 50930:     if (NS_FAILED(content->AllocateCounterResets(count))) {
 50930:       break;
 50930:     }
 50930: 
     1:     count = 0;
 50930:     for (const nsCSSValuePairList* p = ourReset; p; p = p->mNext, count++) {
108991:       int32_t reset;
 50930:       if (p->mYValue.GetUnit() == eCSSUnit_Integer) {
 50930:         reset = p->mYValue.GetIntValue();
 50930:       } else {
     1:         reset = 0;
     1:       }
 50930:       p->mXValue.GetStringValue(buffer);
 50930:       content->SetCounterResetAt(count, buffer, reset);
 50930:     }
 50931:     break;
 50931:   }
 50930: 
 50930:   default:
 50930:     NS_ABORT_IF_FALSE(false, "unexpected value unit");
     1:   }
     1: 
     1:   // marker-offset: length, auto, inherit
 63746:   SetCoord(*aRuleData->ValueForMarkerOffset(), content->mMarkerOffset, parentContent->mMarkerOffset,
 42145:            SETCOORD_LH | SETCOORD_AUTO | SETCOORD_INITIAL_AUTO |
 42145:              SETCOORD_CALC_LENGTH_ONLY,
 42145:            aContext, mPresContext, canStoreInRuleTree);
     1: 
 50818:   // If we ended up with an image, track it.
108991:   for (uint32_t i = 0; i < content->ContentCount(); ++i) {
 50818:     if ((content->ContentAt(i).mType == eStyleContentType_Image) &&
 50818:         content->ContentAt(i).mContent.mImage) {
 50818:       content->ContentAt(i).TrackImage(aContext->PresContext());
 50818:     }
 50818:   }
 50818: 
     1:   COMPUTE_END_RESET(Content, content)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeQuotesData(void* aStartStruct,
 63746:                               const nsRuleData* aRuleData,
     1:                               nsStyleContext* aContext,
     1:                               nsRuleNode* aHighestNode,
 24634:                               const RuleDetail aRuleDetail,
 79445:                               const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_INHERITED(Quotes, (), quotes, parentQuotes)
     1: 
 17037:   // quotes: inherit, initial, none, [string string]+
 63746:   const nsCSSValue* quotesValue = aRuleData->ValueForQuotes();
 63746:   switch (quotesValue->GetUnit()) {
 50930:   case eCSSUnit_Null:
 50930:     break;
 50930:   case eCSSUnit_Inherit:
 80486:     canStoreInRuleTree = false;
 17037:     quotes->CopyFrom(*parentQuotes);
 50930:     break;
 50930:   case eCSSUnit_Initial:
 17037:     quotes->SetInitial();
 50930:     break;
 50930:   case eCSSUnit_None:
     1:     quotes->AllocateQuotes(0);
 50930:     break;
 50930:   case eCSSUnit_PairList:
 50930:   case eCSSUnit_PairListDep: {
 50931:     const nsCSSValuePairList* ourQuotes
 63746:       = quotesValue->GetPairListValue();
 17037:     nsAutoString buffer;
 17037:     nsAutoString closeBuffer;
108991:     uint32_t count = ListLength(ourQuotes);
 50930:     if (NS_FAILED(quotes->AllocateQuotes(count))) {
 50930:       break;
 50930:     }
 50930:     count = 0;
     1:     while (ourQuotes) {
 50930:       NS_ABORT_IF_FALSE(ourQuotes->mXValue.GetUnit() == eCSSUnit_String &&
 50930:                         ourQuotes->mYValue.GetUnit() == eCSSUnit_String,
 50930:                         "improper list contents for quotes");
 16372:       ourQuotes->mXValue.GetStringValue(buffer);
 16372:       ourQuotes->mYValue.GetStringValue(closeBuffer);
     1:       quotes->SetQuotesAt(count++, buffer, closeBuffer);
     1:       ourQuotes = ourQuotes->mNext;
     1:     }
 50931:     break;
 50931:   }
 50930:   default:
 50930:     NS_ABORT_IF_FALSE(false, "unexpected value unit");
     1:   }
     1: 
     1:   COMPUTE_END_INHERITED(Quotes, quotes)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeXULData(void* aStartStruct,
 63746:                            const nsRuleData* aRuleData,
     1:                            nsStyleContext* aContext,
     1:                            nsRuleNode* aHighestNode,
 24634:                            const RuleDetail aRuleDetail,
 79445:                            const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(XUL, (), xul, parentXUL)
     1: 
 18889:   // box-align: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForBoxAlign(),
 63746:               xul->mBoxAlign, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentXUL->mBoxAlign,
 18889:               NS_STYLE_BOX_ALIGN_STRETCH, 0, 0, 0, 0);
 18889: 
 18889:   // box-direction: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForBoxDirection(),
 63746:               xul->mBoxDirection, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentXUL->mBoxDirection,
 18889:               NS_STYLE_BOX_DIRECTION_NORMAL, 0, 0, 0, 0);
     1: 
     1:   // box-flex: factor, inherit
 63746:   SetFactor(*aRuleData->ValueForBoxFlex(),
 63746:             xul->mBoxFlex, canStoreInRuleTree,
 18889:             parentXUL->mBoxFlex, 0.0f);
 18889: 
 18889:   // box-orient: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForBoxOrient(),
 63746:               xul->mBoxOrient, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentXUL->mBoxOrient,
 18889:               NS_STYLE_BOX_ORIENT_HORIZONTAL, 0, 0, 0, 0);
 18889: 
 18889:   // box-pack: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForBoxPack(),
 63746:               xul->mBoxPack, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentXUL->mBoxPack,
 18889:               NS_STYLE_BOX_PACK_START, 0, 0, 0, 0);
 18889: 
 18889:   // box-ordinal-group: integer, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForBoxOrdinalGroup(),
 63746:               xul->mBoxOrdinal, canStoreInRuleTree,
 18889:               SETDSC_INTEGER, parentXUL->mBoxOrdinal, 1,
 18889:               0, 0, 0, 0);
     1: 
 63746:   const nsCSSValue* stackSizingValue = aRuleData->ValueForStackSizing();
 63746:   if (eCSSUnit_Inherit == stackSizingValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
 15260:     xul->mStretchStack = parentXUL->mStretchStack;
 63746:   } else if (eCSSUnit_Initial == stackSizingValue->GetUnit()) {
 80486:     xul->mStretchStack = true;
 63746:   } else if (eCSSUnit_Enumerated == stackSizingValue->GetUnit()) {
 63746:     xul->mStretchStack = stackSizingValue->GetIntValue() ==
 15260:       NS_STYLE_STACK_SIZING_STRETCH_TO_FIT;
 15260:   }
 15260: 
     1:   COMPUTE_END_RESET(XUL, xul)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeColumnData(void* aStartStruct,
 63746:                               const nsRuleData* aRuleData,
     1:                               nsStyleContext* aContext,
     1:                               nsRuleNode* aHighestNode,
 24634:                               const RuleDetail aRuleDetail,
 79445:                               const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(Column, (mPresContext), column, parent)
     1: 
     1:   // column-width: length, auto, inherit
 63746:   SetCoord(*aRuleData->ValueForColumnWidth(),
  3832:            column->mColumnWidth, parent->mColumnWidth,
 42145:            SETCOORD_LAH | SETCOORD_INITIAL_AUTO |
 42145:            SETCOORD_CALC_LENGTH_ONLY | SETCOORD_CALC_CLAMP_NONNEGATIVE,
 24636:            aContext, mPresContext, canStoreInRuleTree);
     1: 
 52285:   // column-gap: length, inherit, normal
 63746:   SetCoord(*aRuleData->ValueForColumnGap(),
     1:            column->mColumnGap, parent->mColumnGap,
 52285:            SETCOORD_LH | SETCOORD_NORMAL | SETCOORD_INITIAL_NORMAL |
 52285:            SETCOORD_CALC_LENGTH_ONLY,
 24636:            aContext, mPresContext, canStoreInRuleTree);
 52285:   // clamp negative calc() to 0
 52285:   if (column->mColumnGap.GetUnit() == eStyleUnit_Coord) {
 52285:     column->mColumnGap.SetCoordValue(
 52285:       NS_MAX(column->mColumnGap.GetCoordValue(), 0));
 52285:   }
     1: 
     1:   // column-count: auto, integer, inherit
 63746:   const nsCSSValue* columnCountValue = aRuleData->ValueForColumnCount();
 63746:   if (eCSSUnit_Auto == columnCountValue->GetUnit() ||
 63746:       eCSSUnit_Initial == columnCountValue->GetUnit()) {
     1:     column->mColumnCount = NS_STYLE_COLUMN_COUNT_AUTO;
 63746:   } else if (eCSSUnit_Integer == columnCountValue->GetUnit()) {
 63746:     column->mColumnCount = columnCountValue->GetIntValue();
     1:     // Max 1000 columns - wallpaper for bug 345583.
 32531:     column->mColumnCount = NS_MIN(column->mColumnCount, 1000U);
 63746:   } else if (eCSSUnit_Inherit == columnCountValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
     1:     column->mColumnCount = parent->mColumnCount;
     1:   }
     1: 
 16055:   // column-rule-width: length, enum, inherit
 63746:   const nsCSSValue& widthValue = *aRuleData->ValueForColumnRuleWidth();
 16055:   if (eCSSUnit_Initial == widthValue.GetUnit()) {
 16055:     column->SetColumnRuleWidth(
 16055:         (mPresContext->GetBorderWidthTable())[NS_STYLE_BORDER_WIDTH_MEDIUM]);
 16055:   }
 16055:   else if (eCSSUnit_Enumerated == widthValue.GetUnit()) {
 16055:     NS_ASSERTION(widthValue.GetIntValue() == NS_STYLE_BORDER_WIDTH_THIN ||
 16055:                  widthValue.GetIntValue() == NS_STYLE_BORDER_WIDTH_MEDIUM ||
 16055:                  widthValue.GetIntValue() == NS_STYLE_BORDER_WIDTH_THICK,
 16055:                  "Unexpected enum value");
 16055:     column->SetColumnRuleWidth(
 16055:         (mPresContext->GetBorderWidthTable())[widthValue.GetIntValue()]);
 16055:   }
 16055:   else if (eCSSUnit_Inherit == widthValue.GetUnit()) {
 16055:     column->SetColumnRuleWidth(parent->GetComputedColumnRuleWidth());
 80486:     canStoreInRuleTree = false;
 16055:   }
 42145:   else if (widthValue.IsLengthUnit() || widthValue.IsCalcUnit()) {
 42145:     nscoord len =
 42145:       CalcLength(widthValue, aContext, mPresContext, canStoreInRuleTree);
 42145:     if (len < 0) {
 42145:       // FIXME: This is untested (by test_value_storage.html) for
 42145:       // column-rule-width since it gets covered up by the border
 42145:       // rounding code.
 42145:       NS_ASSERTION(widthValue.IsCalcUnit(),
 42145:                    "parser should have rejected negative length");
 42145:       len = 0;
 42145:     }
 42145:     column->SetColumnRuleWidth(len);
 16055:   }
 16055: 
 34082:   // column-rule-style: enum, inherit
 63746:   const nsCSSValue& styleValue = *aRuleData->ValueForColumnRuleStyle();
 34082:   NS_ABORT_IF_FALSE(eCSSUnit_None != styleValue.GetUnit(),
 34082:                     "'none' should be handled as enumerated value");
 16055:   if (eCSSUnit_Enumerated == styleValue.GetUnit()) {
 16055:     column->mColumnRuleStyle = styleValue.GetIntValue();
 16055:   }
 34082:   else if (eCSSUnit_Initial == styleValue.GetUnit()) {
 16055:     column->mColumnRuleStyle = NS_STYLE_BORDER_STYLE_NONE;
 16055:   }
 16055:   else if (eCSSUnit_Inherit == styleValue.GetUnit()) {
 80486:     canStoreInRuleTree = false;
 16055:     column->mColumnRuleStyle = parent->mColumnRuleStyle;
 16055:   }
 16055: 
 16055:   // column-rule-color: color, inherit
 63746:   const nsCSSValue& colorValue = *aRuleData->ValueForColumnRuleColor();
 16055:   if (eCSSUnit_Inherit == colorValue.GetUnit()) {
 80486:     canStoreInRuleTree = false;
 80486:     column->mColumnRuleColorIsForeground = false;
 16055:     if (parent->mColumnRuleColorIsForeground) {
 16055:       column->mColumnRuleColor = parentContext->GetStyleColor()->mColor;
 16055:     } else {
 16055:       column->mColumnRuleColor = parent->mColumnRuleColor;
 16055:     }
 16055:   }
 63684:   else if (eCSSUnit_Initial == colorValue.GetUnit() ||
 63684:            eCSSUnit_Enumerated == colorValue.GetUnit()) {
 80486:     column->mColumnRuleColorIsForeground = true;
 16055:   }
 24636:   else if (SetColor(colorValue, 0, mPresContext, aContext,
 24636:                     column->mColumnRuleColor, canStoreInRuleTree)) {
 80486:     column->mColumnRuleColorIsForeground = false;
 16055:   }
 16055: 
106994:   // column-fill: enum
106994:   SetDiscrete(*aRuleData->ValueForColumnFill(),
106994:                 column->mColumnFill, canStoreInRuleTree,
106994:                 SETDSC_ENUMERATED, parent->mColumnFill,
106994:                 NS_STYLE_COLUMN_FILL_BALANCE,
106994:                 0, 0, 0, 0);
106994: 
     1:   COMPUTE_END_RESET(Column, column)
     1: }
     1: 
     1: static void
 50928: SetSVGPaint(const nsCSSValue& aValue, const nsStyleSVGPaint& parentPaint,
     1:             nsPresContext* aPresContext, nsStyleContext *aContext,
   467:             nsStyleSVGPaint& aResult, nsStyleSVGPaintType aInitialPaintType,
 79445:             bool& aCanStoreInRuleTree)
     1: {
  7041:   nscolor color;
  7041: 
 50928:   if (aValue.GetUnit() == eCSSUnit_Inherit) {
     1:     aResult = parentPaint;
 80486:     aCanStoreInRuleTree = false;
 50928:   } else if (aValue.GetUnit() == eCSSUnit_None) {
  7041:     aResult.SetType(eStyleSVGPaintType_None);
 50928:   } else if (aValue.GetUnit() == eCSSUnit_Initial) {
  7041:     aResult.SetType(aInitialPaintType);
   467:     aResult.mPaint.mColor = NS_RGB(0, 0, 0);
   467:     aResult.mFallbackColor = NS_RGB(0, 0, 0);
 50928:   } else if (SetColor(aValue, NS_RGB(0, 0, 0), aPresContext, aContext,
 50928:                       color, aCanStoreInRuleTree)) {
 50928:     aResult.SetType(eStyleSVGPaintType_Color);
 50928:     aResult.mPaint.mColor = color;
 50928:   } else if (aValue.GetUnit() == eCSSUnit_Pair) {
 50928:     const nsCSSValuePair& pair = aValue.GetPairValue();
111294: 
111294:     if (pair.mXValue.GetUnit() == eCSSUnit_URL) {
  7041:       aResult.SetType(eStyleSVGPaintType_Server);
 50928:       aResult.mPaint.mPaintServer = pair.mXValue.GetURLValue();
     1:       NS_IF_ADDREF(aResult.mPaint.mPaintServer);
111294:     } else if (pair.mXValue.GetUnit() == eCSSUnit_Enumerated) {
111294: 
111294:       switch (pair.mXValue.GetIntValue()) {
111294:       case NS_COLOR_OBJECTFILL:
111294:         aResult.SetType(eStyleSVGPaintType_ObjectFill);
111294:         break;
111294:       case NS_COLOR_OBJECTSTROKE:
111294:         aResult.SetType(eStyleSVGPaintType_ObjectStroke);
111294:         break;
111294:       default:
111294:         NS_NOTREACHED("unknown keyword as paint server value");
111294:       }
111294: 
111294:     } else {
111294:       NS_NOTREACHED("malformed paint server value");
111294:     }
 50928: 
 50928:     if (pair.mYValue.GetUnit() == eCSSUnit_None) {
     1:       aResult.mFallbackColor = NS_RGBA(0, 0, 0, 0);
     1:     } else {
 50928:       NS_ABORT_IF_FALSE(pair.mYValue.GetUnit() != eCSSUnit_Inherit,
 50928:                         "cannot inherit fallback colour");
 50928:       SetColor(pair.mYValue, NS_RGB(0, 0, 0), aPresContext, aContext,
 24636:                aResult.mFallbackColor, aCanStoreInRuleTree);
 24636:     }
 50928:   } else {
 50928:     NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Null,
 50928:                       "malformed paint server value");
     1:   }
     1: }
     1: 
111301: static void
111301: SetSVGOpacity(const nsCSSValue& aValue,
111301:               float& aOpacityField, nsStyleSVGOpacitySource& aOpacityTypeField,
111301:               bool& aCanStoreInRuleTree,
111301:               float aParentOpacity, nsStyleSVGOpacitySource aParentOpacityType)
111301: {
111301:   if (eCSSUnit_Enumerated == aValue.GetUnit()) {
111301:     switch (aValue.GetIntValue()) {
111301:     case NS_STYLE_OBJECT_FILL_OPACITY:
111301:       aOpacityTypeField = eStyleSVGOpacitySource_ObjectFillOpacity;
111301:       break;
111301:     case NS_STYLE_OBJECT_STROKE_OPACITY:
111301:       aOpacityTypeField = eStyleSVGOpacitySource_ObjectStrokeOpacity;
111301:       break;
111301:     default:
111301:       NS_NOTREACHED("SetSVGOpacity: Unknown keyword");
111301:     }
111301:     // Fall back on fully opaque
111301:     aOpacityField = 1.0f;
111301:   } else if (eCSSUnit_Inherit == aValue.GetUnit()) {
111301:     aCanStoreInRuleTree = false;
111301:     aOpacityField = aParentOpacity;
111301:     aOpacityTypeField = aParentOpacityType;
111301:   } else if (eCSSUnit_Null != aValue.GetUnit()) {
111301:     SetFactor(aValue, aOpacityField, aCanStoreInRuleTree,
111301:               aParentOpacity, 1.0f, SETFCT_OPACITY);
111301:     aOpacityTypeField = eStyleSVGOpacitySource_Normal;
111301:   }
111301: }
111301: 
111303: template <typename FieldT, typename T>
111303: static bool
111303: SetTextObjectValue(const nsCSSValue& aValue, FieldT& aField, T aFallbackValue)
111303: {
111303:   if (aValue.GetUnit() != eCSSUnit_Enumerated ||
111303:       aValue.GetIntValue() != NS_STYLE_STROKE_PROP_OBJECTVALUE) {
111303:     return false;
111303:   }
111303:   aField = aFallbackValue;
111303:   return true;
111303: }
111303: 
 10152: const void*
 10152: nsRuleNode::ComputeSVGData(void* aStartStruct,
 63746:                            const nsRuleData* aRuleData,
     1:                            nsStyleContext* aContext,
     1:                            nsRuleNode* aHighestNode,
 24634:                            const RuleDetail aRuleDetail,
 79445:                            const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_INHERITED(SVG, (), svg, parentSVG)
     1: 
 18889:   // clip-rule: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForClipRule(),
 63746:               svg->mClipRule, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentSVG->mClipRule,
 18889:               NS_STYLE_FILL_RULE_NONZERO, 0, 0, 0, 0);
 18889: 
 34080:   // color-interpolation: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForColorInterpolation(),
 34080:               svg->mColorInterpolation, canStoreInRuleTree,
 34080:               SETDSC_ENUMERATED, parentSVG->mColorInterpolation,
 34080:               NS_STYLE_COLOR_INTERPOLATION_SRGB, 0, 0, 0, 0);
 34080: 
 34080:   // color-interpolation-filters: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForColorInterpolationFilters(),
 24636:               svg->mColorInterpolationFilters, canStoreInRuleTree,
 34080:               SETDSC_ENUMERATED, parentSVG->mColorInterpolationFilters,
 34080:               NS_STYLE_COLOR_INTERPOLATION_LINEARRGB, 0, 0, 0, 0);
     1: 
     1:   // fill:
 63746:   SetSVGPaint(*aRuleData->ValueForFill(),
 63746:               parentSVG->mFill, mPresContext, aContext,
 24636:               svg->mFill, eStyleSVGPaintType_Color, canStoreInRuleTree);
     1: 
111301:   // fill-opacity: factor, inherit, initial, objectFillOpacity, objectStrokeOpacity
111301:   nsStyleSVGOpacitySource objectFillOpacity = svg->mFillOpacitySource;
111301:   SetSVGOpacity(*aRuleData->ValueForFillOpacity(),
111301:                 svg->mFillOpacity, objectFillOpacity, canStoreInRuleTree,
111301:                 parentSVG->mFillOpacity, parentSVG->mFillOpacitySource);
111301:   svg->mFillOpacitySource = objectFillOpacity;
 18889: 
 18889:   // fill-rule: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForFillRule(),
 63746:               svg->mFillRule, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentSVG->mFillRule,
 18889:               NS_STYLE_FILL_RULE_NONZERO, 0, 0, 0, 0);
     1: 
 34080:   // image-rendering: enum, inherit
 63746:   SetDiscrete(*aRuleData->ValueForImageRendering(),
 63746:               svg->mImageRendering, canStoreInRuleTree,
 34080:               SETDSC_ENUMERATED, parentSVG->mImageRendering,
 34080:               NS_STYLE_IMAGE_RENDERING_AUTO, 0, 0, 0, 0);
 26449: 
     1:   // marker-end: url, none, inherit
 63746:   const nsCSSValue* markerEndValue = aRuleData->ValueForMarkerEnd();
 63746:   if (eCSSUnit_URL == markerEndValue->GetUnit()) {
 63746:     svg->mMarkerEnd = markerEndValue->GetURLValue();
 63746:   } else if (eCSSUnit_None == markerEndValue->GetUnit() ||
 63746:              eCSSUnit_Initial == markerEndValue->GetUnit()) {
106838:     svg->mMarkerEnd = nullptr;
 63746:   } else if (eCSSUnit_Inherit == markerEndValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
     1:     svg->mMarkerEnd = parentSVG->mMarkerEnd;
     1:   }
     1: 
     1:   // marker-mid: url, none, inherit
 63746:   const nsCSSValue* markerMidValue = aRuleData->ValueForMarkerMid();
 63746:   if (eCSSUnit_URL == markerMidValue->GetUnit()) {
 63746:     svg->mMarkerMid = markerMidValue->GetURLValue();
 63746:   } else if (eCSSUnit_None == markerMidValue->GetUnit() ||
 63746:              eCSSUnit_Initial == markerMidValue->GetUnit()) {
106838:     svg->mMarkerMid = nullptr;
 63746:   } else if (eCSSUnit_Inherit == markerMidValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
     1:     svg->mMarkerMid = parentSVG->mMarkerMid;
     1:   }
     1: 
     1:   // marker-start: url, none, inherit
 63746:   const nsCSSValue* markerStartValue = aRuleData->ValueForMarkerStart();
 63746:   if (eCSSUnit_URL == markerStartValue->GetUnit()) {
 63746:     svg->mMarkerStart = markerStartValue->GetURLValue();
 63746:   } else if (eCSSUnit_None == markerStartValue->GetUnit() ||
 63746:              eCSSUnit_Initial == markerStartValue->GetUnit()) {
106838:     svg->mMarkerStart = nullptr;
 63746:   } else if (eCSSUnit_Inherit == markerStartValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
     1:     svg->mMarkerStart = parentSVG->mMarkerStart;
     1:   }
     1: 
 34080:   // shape-rendering: enum, inherit
 63746:   SetDiscrete(*aRuleData->ValueForShapeRendering(),
 63746:               svg->mShapeRendering, canStoreInRuleTree,
 34080:               SETDSC_ENUMERATED, parentSVG->mShapeRendering,
 34080:               NS_STYLE_SHAPE_RENDERING_AUTO, 0, 0, 0, 0);
     1: 
     1:   // stroke:
 63746:   SetSVGPaint(*aRuleData->ValueForStroke(),
 63746:               parentSVG->mStroke, mPresContext, aContext,
 24636:               svg->mStroke, eStyleSVGPaintType_None, canStoreInRuleTree);
     1: 
111303:   // stroke-dasharray: <dasharray>, none, inherit, -moz-objectValue
 63746:   const nsCSSValue* strokeDasharrayValue = aRuleData->ValueForStrokeDasharray();
 63746:   switch (strokeDasharrayValue->GetUnit()) {
 50931:   case eCSSUnit_Null:
 50931:     break;
 50931: 
 50931:   case eCSSUnit_Inherit:
 80486:     canStoreInRuleTree = false;
111303:     svg->mStrokeDasharrayFromObject = parentSVG->mStrokeDasharrayFromObject;
     1:     // only do the copy if weren't already set up by the copy constructor
  3832:     // FIXME Bug 389408: This is broken when aStartStruct is non-null!
     1:     if (!svg->mStrokeDasharray) {
     1:       svg->mStrokeDasharrayLength = parentSVG->mStrokeDasharrayLength;
     1:       if (svg->mStrokeDasharrayLength) {
     1:         svg->mStrokeDasharray = new nsStyleCoord[svg->mStrokeDasharrayLength];
     1:         if (svg->mStrokeDasharray)
     1:           memcpy(svg->mStrokeDasharray,
     1:                  parentSVG->mStrokeDasharray,
  3735:                  svg->mStrokeDasharrayLength * sizeof(nsStyleCoord));
     1:         else
     1:           svg->mStrokeDasharrayLength = 0;
     1:       }
     1:     }
 50931:     break;
 50931: 
111303:   case eCSSUnit_Enumerated:
111303:     NS_ABORT_IF_FALSE(strokeDasharrayValue->GetIntValue() ==
111303:                             NS_STYLE_STROKE_PROP_OBJECTVALUE,
111303:                       "Unknown keyword for stroke-dasharray");
111303:     svg->mStrokeDasharrayFromObject = true;
     1:     delete [] svg->mStrokeDasharray;
106838:     svg->mStrokeDasharray = nullptr;
     1:     svg->mStrokeDasharrayLength = 0;
 50931:     break;
 50931: 
111303:   case eCSSUnit_Initial:
111303:   case eCSSUnit_None:
111303:     svg->mStrokeDasharrayFromObject = false;
111303:     delete [] svg->mStrokeDasharray;
111303:     svg->mStrokeDasharray = nullptr;
111303:     svg->mStrokeDasharrayLength = 0;
111303:     break;
111303: 
 50931:   case eCSSUnit_List:
 50931:   case eCSSUnit_ListDep: {
111303:     svg->mStrokeDasharrayFromObject = false;
 50931:     delete [] svg->mStrokeDasharray;
106838:     svg->mStrokeDasharray = nullptr;
 50931:     svg->mStrokeDasharrayLength = 0;
 50931: 
     1:     // count number of values
 63746:     const nsCSSValueList *value = strokeDasharrayValue->GetListValue();
 50931:     svg->mStrokeDasharrayLength = ListLength(value);
     1: 
     1:     NS_ASSERTION(svg->mStrokeDasharrayLength != 0, "no dasharray items");
     1: 
     1:     svg->mStrokeDasharray = new nsStyleCoord[svg->mStrokeDasharrayLength];
     1: 
     1:     if (svg->mStrokeDasharray) {
108991:       uint32_t i = 0;
106838:       while (nullptr != value) {
     1:         SetCoord(value->mValue,
 33820:                  svg->mStrokeDasharray[i++], nsStyleCoord(),
     1:                  SETCOORD_LP | SETCOORD_FACTOR,
 24636:                  aContext, mPresContext, canStoreInRuleTree);
     1:         value = value->mNext;
     1:       }
 50931:     } else {
     1:       svg->mStrokeDasharrayLength = 0;
     1:     }
 50931:     break;
 50931:   }
 50931: 
 50931:   default:
 50931:     NS_ABORT_IF_FALSE(false, "unrecognized dasharray unit");
     1:   }
     1: 
     1:   // stroke-dashoffset: <dashoffset>, inherit
111303:   const nsCSSValue *strokeDashoffsetValue =
111303:     aRuleData->ValueForStrokeDashoffset();
111303:   svg->mStrokeDashoffsetFromObject =
111303:     strokeDashoffsetValue->GetUnit() == eCSSUnit_Enumerated &&
111303:     strokeDashoffsetValue->GetIntValue() == NS_STYLE_STROKE_PROP_OBJECTVALUE;
111303:   if (svg->mStrokeDashoffsetFromObject) {
111303:     svg->mStrokeDashoffset.SetIntValue(0, eStyleUnit_Integer);
111303:   } else {
 63746:     SetCoord(*aRuleData->ValueForStrokeDashoffset(),
     1:              svg->mStrokeDashoffset, parentSVG->mStrokeDashoffset,
  3832:              SETCOORD_LPH | SETCOORD_FACTOR | SETCOORD_INITIAL_ZERO,
 24636:              aContext, mPresContext, canStoreInRuleTree);
111303:   }
     1: 
 18889:   // stroke-linecap: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForStrokeLinecap(),
 63746:               svg->mStrokeLinecap, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentSVG->mStrokeLinecap,
 18889:               NS_STYLE_STROKE_LINECAP_BUTT, 0, 0, 0, 0);
 18889: 
 18889:   // stroke-linejoin: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForStrokeLinejoin(),
 63746:               svg->mStrokeLinejoin, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentSVG->mStrokeLinejoin,
 18889:               NS_STYLE_STROKE_LINEJOIN_MITER, 0, 0, 0, 0);
     1: 
     1:   // stroke-miterlimit: <miterlimit>, inherit
 63746:   SetFactor(*aRuleData->ValueForStrokeMiterlimit(),
 63746:             svg->mStrokeMiterlimit,
 24636:             canStoreInRuleTree,
 18889:             parentSVG->mStrokeMiterlimit, 4.0f);
     1: 
     1:   // stroke-opacity:
111301:   nsStyleSVGOpacitySource objectStrokeOpacity = svg->mStrokeOpacitySource;
111301:   SetSVGOpacity(*aRuleData->ValueForStrokeOpacity(),
111301:                 svg->mStrokeOpacity, objectStrokeOpacity, canStoreInRuleTree,
111301:                 parentSVG->mStrokeOpacity, parentSVG->mStrokeOpacitySource);
111301:   svg->mStrokeOpacitySource = objectStrokeOpacity;
     1: 
     1:   // stroke-width:
 63746:   const nsCSSValue* strokeWidthValue = aRuleData->ValueForStrokeWidth();
111303:   switch (strokeWidthValue->GetUnit()) {
111303:   case eCSSUnit_Enumerated:
111303:     NS_ABORT_IF_FALSE(strokeWidthValue->GetIntValue() ==
111303:                         NS_STYLE_STROKE_PROP_OBJECTVALUE,
111303:                       "Unrecognized keyword for stroke-width");
111303:     svg->mStrokeWidthFromObject = true;
  3735:     svg->mStrokeWidth.SetCoordValue(nsPresContext::CSSPixelsToAppUnits(1));
111303:     break;
111303: 
111303:   case eCSSUnit_Initial:
111303:     svg->mStrokeWidthFromObject = false;
111303:     svg->mStrokeWidth.SetCoordValue(nsPresContext::CSSPixelsToAppUnits(1));
111303:     break;
111303: 
111303:   default:
111303:     svg->mStrokeWidthFromObject = false;
 63746:     SetCoord(*strokeWidthValue,
     1:              svg->mStrokeWidth, parentSVG->mStrokeWidth,
     1:              SETCOORD_LPH | SETCOORD_FACTOR,
 24636:              aContext, mPresContext, canStoreInRuleTree);
  3735:   }
     1: 
 18889:   // text-anchor: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForTextAnchor(),
 63746:               svg->mTextAnchor, canStoreInRuleTree,
 18889:               SETDSC_ENUMERATED, parentSVG->mTextAnchor,
 18889:               NS_STYLE_TEXT_ANCHOR_START, 0, 0, 0, 0);
 18889: 
 34080:   // text-rendering: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForTextRendering(),
 63746:               svg->mTextRendering, canStoreInRuleTree,
 34080:               SETDSC_ENUMERATED, parentSVG->mTextRendering,
 34080:               NS_STYLE_TEXT_RENDERING_AUTO, 0, 0, 0, 0);
     1: 
     1:   COMPUTE_END_INHERITED(SVG, svg)
     1: }
     1: 
 10152: const void*
 10152: nsRuleNode::ComputeSVGResetData(void* aStartStruct,
 63746:                                 const nsRuleData* aRuleData,
     1:                                 nsStyleContext* aContext,
     1:                                 nsRuleNode* aHighestNode,
 24634:                                 const RuleDetail aRuleDetail,
 79445:                                 const bool aCanStoreInRuleTree)
     1: {
 63747:   COMPUTE_START_RESET(SVGReset, (), svgReset, parentSVGReset)
     1: 
     1:   // stop-color:
 63746:   const nsCSSValue* stopColorValue = aRuleData->ValueForStopColor();
 63746:   if (eCSSUnit_Initial == stopColorValue->GetUnit()) {
  3735:     svgReset->mStopColor = NS_RGB(0, 0, 0);
  3735:   } else {
 63746:     SetColor(*stopColorValue, parentSVGReset->mStopColor,
 24636:              mPresContext, aContext, svgReset->mStopColor, canStoreInRuleTree);
  3735:   }
     1: 
     1:   // flood-color:
 63746:   const nsCSSValue* floodColorValue = aRuleData->ValueForFloodColor();
 63746:   if (eCSSUnit_Initial == floodColorValue->GetUnit()) {
  3735:     svgReset->mFloodColor = NS_RGB(0, 0, 0);
  3735:   } else {
 63746:     SetColor(*floodColorValue, parentSVGReset->mFloodColor,
 24636:              mPresContext, aContext, svgReset->mFloodColor, canStoreInRuleTree);
  3735:   }
     1: 
  4029:   // lighting-color:
 63746:   const nsCSSValue* lightingColorValue = aRuleData->ValueForLightingColor();
 63746:   if (eCSSUnit_Initial == lightingColorValue->GetUnit()) {
  4029:     svgReset->mLightingColor = NS_RGB(255, 255, 255);
  4029:   } else {
 63746:     SetColor(*lightingColorValue, parentSVGReset->mLightingColor,
 24636:              mPresContext, aContext, svgReset->mLightingColor,
 24636:              canStoreInRuleTree);
  4029:   }
  4029: 
     1:   // clip-path: url, none, inherit
 63746:   const nsCSSValue* clipPathValue = aRuleData->ValueForClipPath();
 63746:   if (eCSSUnit_URL == clipPathValue->GetUnit()) {
 63746:     svgReset->mClipPath = clipPathValue->GetURLValue();
 63746:   } else if (eCSSUnit_None == clipPathValue->GetUnit() ||
 63746:              eCSSUnit_Initial == clipPathValue->GetUnit()) {
106838:     svgReset->mClipPath = nullptr;
 63746:   } else if (eCSSUnit_Inherit == clipPathValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
     1:     svgReset->mClipPath = parentSVGReset->mClipPath;
     1:   }
     1: 
     1:   // stop-opacity:
 63746:   SetFactor(*aRuleData->ValueForStopOpacity(),
 63746:             svgReset->mStopOpacity, canStoreInRuleTree,
 18889:             parentSVGReset->mStopOpacity, 1.0f, SETFCT_OPACITY);
     1: 
     1:   // flood-opacity:
 63746:   SetFactor(*aRuleData->ValueForFloodOpacity(),
 63746:             svgReset->mFloodOpacity, canStoreInRuleTree,
 18889:             parentSVGReset->mFloodOpacity, 1.0f, SETFCT_OPACITY);
 18889: 
 34080:   // dominant-baseline: enum, inherit, initial
 63746:   SetDiscrete(*aRuleData->ValueForDominantBaseline(),
 63746:               svgReset->mDominantBaseline,
 34080:               canStoreInRuleTree, SETDSC_ENUMERATED,
 18889:               parentSVGReset->mDominantBaseline,
 34080:               NS_STYLE_DOMINANT_BASELINE_AUTO, 0, 0, 0, 0);
     1: 
 98856:   // vector-effect: enum, inherit, initial
 98856:   SetDiscrete(*aRuleData->ValueForVectorEffect(),
 98856:               svgReset->mVectorEffect,
 98856:               canStoreInRuleTree, SETDSC_ENUMERATED,
 98856:               parentSVGReset->mVectorEffect,
 98856:               NS_STYLE_VECTOR_EFFECT_NONE, 0, 0, 0, 0);
 98856: 
     1:   // filter: url, none, inherit
 63746:   const nsCSSValue* filterValue = aRuleData->ValueForFilter();
 63746:   if (eCSSUnit_URL == filterValue->GetUnit()) {
 63746:     svgReset->mFilter = filterValue->GetURLValue();
 63746:   } else if (eCSSUnit_None == filterValue->GetUnit() ||
 63746:              eCSSUnit_Initial == filterValue->GetUnit()) {
106838:     svgReset->mFilter = nullptr;
 63746:   } else if (eCSSUnit_Inherit == filterValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
     1:     svgReset->mFilter = parentSVGReset->mFilter;
     1:   }
     1: 
     1:   // mask: url, none, inherit
 63746:   const nsCSSValue* maskValue = aRuleData->ValueForMask();
 63746:   if (eCSSUnit_URL == maskValue->GetUnit()) {
 63746:     svgReset->mMask = maskValue->GetURLValue();
 63746:   } else if (eCSSUnit_None == maskValue->GetUnit() ||
 63746:              eCSSUnit_Initial == maskValue->GetUnit()) {
106838:     svgReset->mMask = nullptr;
 63746:   } else if (eCSSUnit_Inherit == maskValue->GetUnit()) {
 80486:     canStoreInRuleTree = false;
     1:     svgReset->mMask = parentSVGReset->mMask;
     1:   }
     1: 
     1:   COMPUTE_END_RESET(SVGReset, svgReset)
     1: }
     1: 
 10152: const void*
     1: nsRuleNode::GetStyleData(nsStyleStructID aSID,
     1:                          nsStyleContext* aContext,
 79445:                          bool aComputeData)
     1: {
121242:   NS_ASSERTION(IsUsedDirectly(),
121242:                "if we ever call this on rule nodes that aren't used "
121242:                "directly, we should adjust handling of mDependentBits "
121242:                "in some way.");
121242: 
 10152:   const void *data;
     1:   data = mStyleData.GetStyleData(aSID);
120353:   if (MOZ_LIKELY(data != nullptr))
     1:     return data; // We have a fully specified struct. Just return it.
     1: 
120353:   if (MOZ_UNLIKELY(!aComputeData))
106838:     return nullptr;
     1: 
     1:   // Nothing is cached.  We'll have to delve further and examine our rules.
 63750:   data = WalkRuleTree(aSID, aContext);
     1: 
121507:   NS_ABORT_IF_FALSE(data, "should have aborted on out-of-memory");
     1:   return data;
     1: }
     1: 
     1: // See comments above in GetStyleData for an explanation of what the
     1: // code below does.
     1: #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                        \
     1: const nsStyle##name_*                                                         \
 79445: nsRuleNode::GetStyle##name_(nsStyleContext* aContext, bool aComputeData)    \
     1: {                                                                             \
121242:   NS_ASSERTION(IsUsedDirectly(),                                              \
121242:                "if we ever call this on rule nodes that aren't used "         \
121242:                "directly, we should adjust handling of mDependentBits "       \
121242:                "in some way.");                                               \
121242:                                                                               \
     1:   const nsStyle##name_ *data;                                                 \
     1:   data = mStyleData.GetStyle##name_();                                        \
120353:   if (MOZ_LIKELY(data != nullptr))                                            \
     1:     return data;                                                              \
     1:                                                                               \
120353:   if (MOZ_UNLIKELY(!aComputeData))                                            \
106838:     return nullptr;                                                           \
     1:                                                                               \
 63750:   data = static_cast<const nsStyle##name_ *>                                  \
 63750:            (WalkRuleTree(eStyleStruct_##name_, aContext));                    \
     1:                                                                               \
121507:   NS_ABORT_IF_FALSE(data, "should have aborted on out-of-memory");            \
     1:   return data;                                                                \
     1: }
     1: #include "nsStyleStructList.h"
     1: #undef STYLE_STRUCT
     1: 
     1: void
     1: nsRuleNode::Mark()
     1: {
     1:   for (nsRuleNode *node = this;
     1:        node && !(node->mDependentBits & NS_RULE_NODE_GC_MARK);
     1:        node = node->mParent)
     1:     node->mDependentBits |= NS_RULE_NODE_GC_MARK;
     1: }
     1: 
 20261: static PLDHashOperator
     1: SweepRuleNodeChildren(PLDHashTable *table, PLDHashEntryHdr *hdr,
108991:                       uint32_t number, void *arg)
     1: {
  3233:   ChildrenHashEntry *entry = static_cast<ChildrenHashEntry*>(hdr);
     1:   if (entry->mRuleNode->Sweep())
     1:     return PL_DHASH_REMOVE; // implies NEXT, unless |ed with STOP
     1:   return PL_DHASH_NEXT;
     1: }
     1: 
 79445: bool
     1: nsRuleNode::Sweep()
     1: {
     1:   // If we're not marked, then we have to delete ourself.
     1:   // However, we never allow the root node to GC itself, because nsStyleSet
     1:   // wants to hold onto the root node and not worry about re-creating a
     1:   // rule walker if the root node is deleted.
 24429:   if (!(mDependentBits & NS_RULE_NODE_GC_MARK) &&
 24429:       // Skip this only if we're the *current* root and not an old one.
 24429:       !(IsRoot() && mPresContext->StyleSet()->GetRuleTree() == this)) {
     1:     Destroy();
 80486:     return true;
     1:   }
     1: 
     1:   // Clear our mark, for the next time around.
     1:   mDependentBits &= ~NS_RULE_NODE_GC_MARK;
     1: 
     1:   // Call sweep on the children, since some may not be marked, and
     1:   // remove any deleted children from the child lists.
     1:   if (HaveChildren()) {
108991:     uint32_t childrenDestroyed;
     1:     if (ChildrenAreHashed()) {
     1:       PLDHashTable *children = ChildrenHash();
108991:       uint32_t oldChildCount = children->entryCount;
106838:       PL_DHashTableEnumerate(children, SweepRuleNodeChildren, nullptr);
 33020:       childrenDestroyed = children->entryCount - oldChildCount;
     1:     } else {
 33020:       childrenDestroyed = 0;
 15903:       for (nsRuleNode **children = ChildrenListPtr(); *children; ) {
 15903:         nsRuleNode *next = (*children)->mNextSibling;
 15903:         if ((*children)->Sweep()) {
 15903:           // This rule node was destroyed, so implicitly advance by
 15903:           // making *children point to the next entry.
 15903:           *children = next;
 33020:           ++childrenDestroyed;
     1:         } else {
     1:           // Advance.
 15903:           children = &(*children)->mNextSibling;
     1:         }
     1:       }
     1:     }
 33020:     mRefCnt -= childrenDestroyed;
 33020:     NS_POSTCONDITION(IsRoot() || mRefCnt > 0,
 33020:                      "We didn't get swept, so we'd better have style contexts "
 33020:                      "pointing to us or to one of our descendants, which means "
 33020:                      "we'd better have a nonzero mRefCnt here!");
     1:   }
 80486:   return false;
     1: }
  6734: 
 79445: /* static */ bool
 14697: nsRuleNode::HasAuthorSpecifiedRules(nsStyleContext* aStyleContext,
108991:                                     uint32_t ruleTypeMask,
 79445:                                     bool aAuthorColorsAllowed)
  6734: {
108991:   uint32_t inheritBits = 0;
 14697:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND)
 14697:     inheritBits |= NS_STYLE_INHERIT_BIT(Background);
 14697: 
 26801:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BORDER)
 14697:     inheritBits |= NS_STYLE_INHERIT_BIT(Border);
 14697: 
 14697:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_PADDING)
 14697:     inheritBits |= NS_STYLE_INHERIT_BIT(Padding);
 14697: 
107438:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_TEXT_SHADOW)
107438:     inheritBits |= NS_STYLE_INHERIT_BIT(Text);
107438: 
 63750:   // properties in the SIDS, whether or not we care about them
107438:   size_t nprops = 0,
107438:          backgroundOffset, borderOffset, paddingOffset, textShadowOffset;
 63750: 
 63750:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND) {
 63754:     backgroundOffset = nprops;
 63750:     nprops += nsCSSProps::PropertyCountInStruct(eStyleStruct_Background);
 63750:   }
 63750: 
 63750:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BORDER) {
 63754:     borderOffset = nprops;
 63750:     nprops += nsCSSProps::PropertyCountInStruct(eStyleStruct_Border);
 63750:   }
 63750: 
 63750:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_PADDING) {
 63754:     paddingOffset = nprops;
 63750:     nprops += nsCSSProps::PropertyCountInStruct(eStyleStruct_Padding);
 63750:   }
 63750: 
107438:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_TEXT_SHADOW) {
107438:     textShadowOffset = nprops;
107438:     nprops += nsCSSProps::PropertyCountInStruct(eStyleStruct_Text);
107438:   }
107438: 
 63750:   void* dataStorage = alloca(nprops * sizeof(nsCSSValue));
 63750:   AutoCSSValueArray dataArray(dataStorage, nprops);
 63754: 
 63754:   /* We're relying on the use of |aStyleContext| not mutating it! */
 63754:   nsRuleData ruleData(inheritBits, dataArray.get(),
 63754:                       aStyleContext->PresContext(), aStyleContext);
 63754: 
 63754:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND) {
 63754:     ruleData.mValueOffsets[eStyleStruct_Background] = backgroundOffset;
 63754:   }
 63754: 
 63754:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BORDER) {
 63754:     ruleData.mValueOffsets[eStyleStruct_Border] = borderOffset;
 63754:   }
 63754: 
 63754:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_PADDING) {
 63754:     ruleData.mValueOffsets[eStyleStruct_Padding] = paddingOffset;
 63754:   }
 63750: 
107438:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_TEXT_SHADOW) {
107438:     ruleData.mValueOffsets[eStyleStruct_Text] = textShadowOffset;
107438:   }
107438: 
 63750:   static const nsCSSProperty backgroundValues[] = {
 63750:     eCSSProperty_background_color,
 63750:     eCSSProperty_background_image,
 14697:   };
 14697: 
 63750:   static const nsCSSProperty borderValues[] = {
 63750:     eCSSProperty_border_top_color,
 63750:     eCSSProperty_border_top_style,
 63750:     eCSSProperty_border_top_width,
 63750:     eCSSProperty_border_right_color_value,
 63750:     eCSSProperty_border_right_style_value,
 63750:     eCSSProperty_border_right_width_value,
 63750:     eCSSProperty_border_bottom_color,
 63750:     eCSSProperty_border_bottom_style,
 63750:     eCSSProperty_border_bottom_width,
 63750:     eCSSProperty_border_left_color_value,
 63750:     eCSSProperty_border_left_style_value,
 63750:     eCSSProperty_border_left_width_value,
 63750:     eCSSProperty_border_start_color_value,
 63750:     eCSSProperty_border_start_style_value,
 63750:     eCSSProperty_border_start_width_value,
 63750:     eCSSProperty_border_end_color_value,
 63750:     eCSSProperty_border_end_style_value,
 63750:     eCSSProperty_border_end_width_value,
 63750:     eCSSProperty_border_top_left_radius,
 63750:     eCSSProperty_border_top_right_radius,
 63750:     eCSSProperty_border_bottom_right_radius,
 63750:     eCSSProperty_border_bottom_left_radius,
  6734:   };
  6734: 
 63750:   static const nsCSSProperty paddingValues[] = {
 63750:     eCSSProperty_padding_top,
 63750:     eCSSProperty_padding_right_value,
 63750:     eCSSProperty_padding_bottom,
 63750:     eCSSProperty_padding_left_value,
 63750:     eCSSProperty_padding_start_value,
 63750:     eCSSProperty_padding_end_value,
 14697:   };
 14697: 
107438:   static const nsCSSProperty textShadowValues[] = {
107438:     eCSSProperty_text_shadow
107438:   };
107438: 
 63750:   // Number of properties we care about
 63750:   size_t nValues = 0;
 63750: 
 80291:   nsCSSValue* values[NS_ARRAY_LENGTH(backgroundValues) +
 80291:                      NS_ARRAY_LENGTH(borderValues) +
107438:                      NS_ARRAY_LENGTH(paddingValues) +
107438:                      NS_ARRAY_LENGTH(textShadowValues)];
 14697: 
 86032:   nsCSSProperty properties[NS_ARRAY_LENGTH(backgroundValues) +
 86032:                            NS_ARRAY_LENGTH(borderValues) +
107438:                            NS_ARRAY_LENGTH(paddingValues) +
107438:                            NS_ARRAY_LENGTH(textShadowValues)];
 86032: 
 14697:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BACKGROUND) {
108991:     for (uint32_t i = 0, i_end = ArrayLength(backgroundValues);
 63750:          i < i_end; ++i) {
 86032:       properties[nValues] = backgroundValues[i];
 63750:       values[nValues++] = ruleData.ValueFor(backgroundValues[i]);
 63750:     }
 14697:   }
 14697: 
 14697:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_BORDER) {
108991:     for (uint32_t i = 0, i_end = ArrayLength(borderValues);
 63750:          i < i_end; ++i) {
 86032:       properties[nValues] = borderValues[i];
 63750:       values[nValues++] = ruleData.ValueFor(borderValues[i]);
 63750:     }
 14697:   }
 14697: 
 14697:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_PADDING) {
108991:     for (uint32_t i = 0, i_end = ArrayLength(paddingValues);
 63750:          i < i_end; ++i) {
 86032:       properties[nValues] = paddingValues[i];
 63750:       values[nValues++] = ruleData.ValueFor(paddingValues[i]);
 63750:     }
 14697:   }
 14697: 
107438:   if (ruleTypeMask & NS_AUTHOR_SPECIFIED_TEXT_SHADOW) {
108991:     for (uint32_t i = 0, i_end = ArrayLength(textShadowValues);
107438:          i < i_end; ++i) {
107438:       properties[nValues] = textShadowValues[i];
107438:       values[nValues++] = ruleData.ValueFor(textShadowValues[i]);
107438:     }
107438:   }
107438: 
 20106:   nsStyleContext* styleContext = aStyleContext;
 20106: 
 20106:   // We need to be careful not to count styles covered up by user-important or
 20106:   // UA-important declarations.  But we do want to catch explicit inherit
 20106:   // styling in those and check our parent style context to see whether we have
 20106:   // user styling for those properties.  Note that we don't care here about
 20106:   // inheritance due to lack of a specified value, since all the properties we
 20106:   // care about are reset properties.
 79445:   bool haveExplicitUAInherit;
 20106:   do {
 80486:     haveExplicitUAInherit = false;
 20106:     for (nsRuleNode* ruleNode = styleContext->GetRuleNode(); ruleNode;
  6734:          ruleNode = ruleNode->GetParent()) {
  6734:       nsIStyleRule *rule = ruleNode->GetRule();
  6734:       if (rule) {
  6734:         ruleData.mLevel = ruleNode->GetLevel();
  6734:         ruleData.mIsImportantRule = ruleNode->IsImportantRule();
 25276: 
  6734:         rule->MapRuleInfoInto(&ruleData);
 25276: 
  6734:         if (ruleData.mLevel == nsStyleSet::eAgentSheet ||
  6734:             ruleData.mLevel == nsStyleSet::eUserSheet) {
  6734:           // This is a rule whose effect we want to ignore, so if any of
  6734:           // the properties we care about were set, set them to the dummy
  6734:           // value that they'll never otherwise get.
108991:           for (uint32_t i = 0; i < nValues; ++i) {
 20106:             nsCSSUnit unit = values[i]->GetUnit();
 20106:             if (unit != eCSSUnit_Null &&
 20106:                 unit != eCSSUnit_Dummy &&
 20106:                 unit != eCSSUnit_DummyInherit) {
 20106:               if (unit == eCSSUnit_Inherit) {
 80486:                 haveExplicitUAInherit = true;
 20106:                 values[i]->SetDummyInheritValue();
 20106:               } else {
  6734:                 values[i]->SetDummyValue();
 20106:               }
 20106:             }
 20106:           }
  6734:         } else {
  6734:           // If any of the values we care about was set by the above rule,
  6734:           // we have author style.
108991:           for (uint32_t i = 0; i < nValues; ++i) {
  6734:             if (values[i]->GetUnit() != eCSSUnit_Null &&
 20106:                 values[i]->GetUnit() != eCSSUnit_Dummy && // see above
 29282:                 values[i]->GetUnit() != eCSSUnit_DummyInherit) {
 29282:               // If author colors are not allowed, only claim to have
 86032:               // author-specified rules if we're looking at a non-color
 86032:               // property or if we're looking at the background color and it's
 86032:               // set to transparent.  Anything else should get set to a dummy
 86032:               // value instead.
 29282:               if (aAuthorColorsAllowed ||
 86032:                   !nsCSSProps::PropHasFlags(properties[i],
 86032:                      CSS_PROPERTY_IGNORED_WHEN_COLORS_DISABLED) ||
 86032:                   (properties[i] == eCSSProperty_background_color &&
 29282:                    !values[i]->IsNonTransparentColor())) {
 80486:                 return true;
  6734:               }
 29282: 
 29282:               values[i]->SetDummyValue();
 29282:             }
 29282:           }
 29282:         }
  6734:       }
  6734:     }
  6734: 
 20106:     if (haveExplicitUAInherit) {
 20106:       // reset all the eCSSUnit_Null values to eCSSUnit_Dummy (since they're
 20106:       // not styled by the author, or by anyone else), and then reset all the
 20106:       // eCSSUnit_DummyInherit values to eCSSUnit_Null (so we will be able to
 20106:       // detect them being styled by the author) and move up to our parent
 20106:       // style context.
108991:       for (uint32_t i = 0; i < nValues; ++i)
 20106:         if (values[i]->GetUnit() == eCSSUnit_Null)
 20106:           values[i]->SetDummyValue();
108991:       for (uint32_t i = 0; i < nValues; ++i)
 20106:         if (values[i]->GetUnit() == eCSSUnit_DummyInherit)
 20106:           values[i]->Reset();
 20106:       styleContext = styleContext->GetParent();
 20106:     }
 20106:   } while (haveExplicitUAInherit && styleContext);
 20106: 
 80486:   return false;
 80486: }
101129: 
101129: /* static */
101129: bool
101129: nsRuleNode::ComputeColor(const nsCSSValue& aValue, nsPresContext* aPresContext,
101129:                          nsStyleContext* aStyleContext, nscolor& aResult)
101129: {
101129:   MOZ_ASSERT(aValue.GetUnit() != eCSSUnit_Inherit,
101129:              "aValue shouldn't have eCSSUnit_Inherit");
101129:   MOZ_ASSERT(aValue.GetUnit() != eCSSUnit_Initial,
101129:              "aValue shouldn't have eCSSUnit_Initial");
101129: 
101129:   bool canStoreInRuleTree;
101129:   bool ok = SetColor(aValue, NS_RGB(0, 0, 0), aPresContext, aStyleContext,
101129:                      aResult, canStoreInRuleTree);
101129:   MOZ_ASSERT(ok || !(aPresContext && aStyleContext));
101129:   return ok;
101129: }
