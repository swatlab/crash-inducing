    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsCRT.h"
    1: 
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: 
    1: #include "nsHTMLEditor.h"
    1: #include "nsHTMLEditRules.h"
    1: #include "nsTextEditUtils.h"
    1: #include "nsHTMLEditUtils.h"
    1: 
    1: #include "nsEditorEventListeners.h"
    1: #include "nsHTMLEditorMouseListener.h"
    1: #include "TypeInState.h"
    1: 
    1: #include "nsHTMLURIRefObject.h"
    1: 
    1: #include "nsIDOMText.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDocument.h"
 1418: #include "nsIDOMEventTarget.h" 
    1: #include "nsIDOM3EventTarget.h" 
    1: #include "nsIDOMKeyEvent.h"
    1: #include "nsIDOMKeyListener.h" 
    1: #include "nsIDOMMouseListener.h"
    1: #include "nsIDOMMouseEvent.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsISelectionController.h"
    1: #include "nsIDOMHTMLHtmlElement.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIDOMEventGroup.h"
    1: #include "nsILinkHandler.h"
    1: 
    1: #include "nsICSSLoader.h"
    1: #include "nsICSSStyleSheet.h"
    1: #include "nsIDOMStyleSheet.h"
    1: #include "nsIDocumentObserver.h"
    1: #include "nsIDocumentStateListener.h"
    1: 
    1: #include "nsIEnumerator.h"
    1: #include "nsIContent.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIDOMNSRange.h"
    1: #include "nsIRangeUtils.h"
    1: #include "nsISupportsArray.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIURL.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIDocumentEncoder.h"
    1: #include "nsIDOMDocumentFragment.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "SetDocTitleTxn.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsTextFragment.h"
    1: 
    1: // netwerk
    1: #include "nsIURI.h"
    1: #include "nsNetUtil.h"
    1: 
    1: // Drag & Drop, Clipboard
    1: #include "nsIClipboard.h"
    1: #include "nsITransferable.h"
    1: #include "nsIDragService.h"
    1: #include "nsIDOMNSUIEvent.h"
    1: #include "nsIContentFilter.h"
    1: 
    1: // Transactionas
    1: #include "nsStyleSheetTxns.h"
    1: 
    1: // Misc
    1: #include "TextEditorTest.h"
    1: #include "nsEditorUtils.h"
    1: #include "nsWSRunObject.h"
    1: #include "nsHTMLObjectResizer.h"
13021: #include "nsGkAtoms.h"
    1: 
    1: #include "nsIFrame.h"
    1: #include "nsIView.h"
    1: #include "nsIParserService.h"
 2896: #include "nsIEventStateManager.h"
    1: 
    1: // Some utilities to handle annoying overloading of "A" tag for link and named anchor
    1: static char hrefText[] = "href";
    1: static char anchorTxt[] = "anchor";
    1: static char namedanchorText[] = "namedanchor";
    1: 
    1: nsIRangeUtils* nsHTMLEditor::sRangeHelper;
    1: 
    1: // some prototypes for rules creation shortcuts
    1: nsresult NS_NewTextEditRules(nsIEditRules** aInstancePtrResult);
    1: nsresult NS_NewHTMLEditRules(nsIEditRules** aInstancePtrResult);
    1: 
    1: #define IsLinkTag(s) (s.EqualsIgnoreCase(hrefText))
    1: #define IsNamedAnchorTag(s) (s.EqualsIgnoreCase(anchorTxt) || s.EqualsIgnoreCase(namedanchorText))
    1: 
    1: nsHTMLEditor::nsHTMLEditor()
    1: : nsPlaintextEditor()
    1: , mIgnoreSpuriousDragEvent(PR_FALSE)
    1: , mTypeInState(nsnull)
    1: , mCRInParagraphCreatesParagraph(PR_FALSE)
    1: , mHTMLCSSUtils(nsnull)
    1: , mSelectedCellIndex(0)
    1: , mIsObjectResizingEnabled(PR_TRUE)
    1: , mIsResizing(PR_FALSE)
    1: , mIsAbsolutelyPositioningEnabled(PR_TRUE)
    1: , mResizedObjectIsAbsolutelyPositioned(PR_FALSE)
    1: , mGrabberClicked(PR_FALSE)
    1: , mIsMoving(PR_FALSE)
    1: , mSnapToGridEnabled(PR_FALSE)
    1: , mIsInlineTableEditingEnabled(PR_TRUE)
 5299: , mInfoXIncrement(20)
 5299: , mInfoYIncrement(20)
11852: , mGridSize(0)
    1: {
    1: } 
    1: 
    1: nsHTMLEditor::~nsHTMLEditor()
    1: {
    1:   // remove the rules as an action listener.  Else we get a bad
    1:   // ownership loop later on.  it's ok if the rules aren't a listener;
    1:   // we ignore the error.
    1:   nsCOMPtr<nsIEditActionListener> mListener = do_QueryInterface(mRules);
    1:   RemoveEditActionListener(mListener);
    1:   
    1:   // Clean up after our anonymous content -- we don't want these nodes to
    1:   // stay around (which they would, since the frames have an owning reference).
    1: 
    1:   if (mAbsolutelyPositionedObject)
    1:     HideGrabber();
    1:   if (mInlineEditedCell)
    1:     HideInlineTableEditingUI();
    1:   if (mResizedObject)
    1:     HideResizers();
    1: 
    1:   //the autopointers will clear themselves up. 
    1:   //but we need to also remove the listeners or we have a leak
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult result = GetSelection(getter_AddRefs(selection));
    1:   // if we don't get the selection, just skip this
    1:   if (NS_SUCCEEDED(result) && selection) 
    1:   {
    1:     nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1:     nsCOMPtr<nsISelectionListener>listener;
    1:     listener = do_QueryInterface(mTypeInState);
    1:     if (listener)
    1:     {
    1:       selPriv->RemoveSelectionListener(listener); 
    1:     }
    1:     listener = do_QueryInterface(mSelectionListenerP);
    1:     if (listener)
    1:     {
    1:       selPriv->RemoveSelectionListener(listener); 
    1:     }
    1:   }
    1: 
    1:   NS_IF_RELEASE(mTypeInState);
    1:   mSelectionListenerP = nsnull;
    1: 
    1:   delete mHTMLCSSUtils;
    1: 
    1:   // free any default style propItems
    1:   RemoveAllDefaultProperties();
    1: 
23904:   while (mStyleSheetURLs.Length())
23904:   {
23904:     RemoveOverrideStyleSheet(mStyleSheetURLs[0]);
    1:   }
    1: 
    1:   if (mLinkHandler && mPresShellWeak)
    1:   {
    1:     nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
    1: 
    1:     if (ps && ps->GetPresContext())
    1:     {
    1:       ps->GetPresContext()->SetLinkHandler(mLinkHandler);
    1:     }
    1:   }
    1: 
    1:   RemoveEventListeners();
    1: }
    1: 
    1: /* static */
    1: void
    1: nsHTMLEditor::Shutdown()
    1: {
    1:   NS_IF_RELEASE(sRangeHelper);
    1: }
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsHTMLEditor, nsEditor)
    1: NS_IMPL_RELEASE_INHERITED(nsHTMLEditor, nsEditor)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsHTMLEditor)
    1:   NS_INTERFACE_MAP_ENTRY(nsIHTMLEditor)
    1:   NS_INTERFACE_MAP_ENTRY(nsIHTMLObjectResizer)
    1:   NS_INTERFACE_MAP_ENTRY(nsIHTMLAbsPosEditor)
    1:   NS_INTERFACE_MAP_ENTRY(nsIHTMLInlineTableEditor)
    1:   NS_INTERFACE_MAP_ENTRY(nsITableEditor)
    1:   NS_INTERFACE_MAP_ENTRY(nsIEditorStyleSheets)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSLoaderObserver)
    1: NS_INTERFACE_MAP_END_INHERITING(nsPlaintextEditor)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::Init(nsIDOMDocument *aDoc, nsIPresShell *aPresShell,
    1:                    nsIContent *aRoot, nsISelectionController *aSelCon,
    1:                    PRUint32 aFlags)
    1: {
    1:   NS_PRECONDITION(aDoc && aPresShell, "bad arg");
    1:   if (!aDoc || !aPresShell)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsresult result = NS_OK, rulesRes = NS_OK;
    1: 
    1:   // make a range util object for comparing dom points
    1:   if (!sRangeHelper) {
    1:     result = CallGetService("@mozilla.org/content/range-utils;1",
    1:                             &sRangeHelper);
    1:     if (!sRangeHelper) return result;
    1:   }
    1:    
    1:   if (1)
    1:   {
    1:     // block to scope nsAutoEditInitRulesTrigger
 3233:     nsAutoEditInitRulesTrigger rulesTrigger(static_cast<nsPlaintextEditor*>(this), rulesRes);
    1: 
    1:     // Init the plaintext editor
    1:     result = nsPlaintextEditor::Init(aDoc, aPresShell, aRoot, aSelCon, aFlags);
    1:     if (NS_FAILED(result)) { return result; }
    1: 
 7921:     UpdateForFlags(aFlags);
    1: 
    1:     // disable Composer-only features
    1:     if (aFlags & eEditorMailMask)
    1:     {
    1:       SetAbsolutePositioningEnabled(PR_FALSE);
    1:       SetSnapToGridEnabled(PR_FALSE);
    1:     }
    1: 
    1:     // Init the HTML-CSS utils
    1:     if (mHTMLCSSUtils)
    1:       delete mHTMLCSSUtils;
    1:     result = NS_NewHTMLCSSUtils(&mHTMLCSSUtils);
    1:     if (NS_FAILED(result)) { return result; }
    1:     mHTMLCSSUtils->Init(this);
    1: 
    1:     // disable links
    1:     nsPresContext *context = aPresShell->GetPresContext();
    1:     if (!context) return NS_ERROR_NULL_POINTER;
 2896:     if (!(mFlags & (eEditorPlaintextMask | eEditorAllowInteraction))) {
    1:       mLinkHandler = context->GetLinkHandler();
    1: 
    1:       context->SetLinkHandler(nsnull);
    1:     }
    1: 
    1:     // init the type-in state
    1:     mTypeInState = new TypeInState();
    1:     if (!mTypeInState) {return NS_ERROR_NULL_POINTER;}
    1:     NS_ADDREF(mTypeInState);
    1: 
    1:     // init the selection listener for image resizing
    1:     mSelectionListenerP = new ResizerSelectionListener(this);
    1:     if (!mSelectionListenerP) {return NS_ERROR_NULL_POINTER;}
    1: 
 2896:     if (!(mFlags & eEditorAllowInteraction)) {
    1:       // ignore any errors from this in case the file is missing
 7269:       AddOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/EditorOverride.css"));
 2896:     }
    1: 
    1:     nsCOMPtr<nsISelection>selection;
    1:     result = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(result)) { return result; }
    1:     if (selection) 
    1:     {
    1:       nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1:       nsCOMPtr<nsISelectionListener>listener;
    1:       listener = do_QueryInterface(mTypeInState);
    1:       if (listener) {
    1:         selPriv->AddSelectionListener(listener); 
    1:       }
    1:       listener = do_QueryInterface(mSelectionListenerP);
    1:       if (listener) {
    1:         selPriv->AddSelectionListener(listener); 
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (NS_FAILED(rulesRes)) return rulesRes;
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::CreateEventListeners()
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (!mMouseListenerP)
    1:   {
    1:     // get a mouse listener
    1:     rv = NS_NewHTMLEditorMouseListener(getter_AddRefs(mMouseListenerP), this);
    1: 
    1:     if (NS_FAILED(rv))
    1:     {
    1:       return rv;
    1:     }
    1:   }
    1: 
    1:   return nsPlaintextEditor::CreateEventListeners();
    1: }
    1: 
    1: void
    1: nsHTMLEditor::RemoveEventListeners()
    1: {
    1:   if (!mDocWeak)
    1:   {
    1:     return;
    1:   }
    1: 
 1418:   nsCOMPtr<nsPIDOMEventTarget> piTarget = GetPIDOMEventTarget();
 1418:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(piTarget);
 1418: 
 1418:   if (piTarget && target)
    1:   {
    1:     // Both mMouseMotionListenerP and mResizeEventListenerP can be
    1:     // registerd with other targets than the DOM event receiver that
    1:     // we can reach from here. But nonetheless, unregister the event
    1:     // listeners with the DOM event reveiver (if it's registerd with
    1:     // other targets, it'll get unregisterd once the target goes
    1:     // away).
    1: 
    1:     if (mMouseMotionListenerP)
    1:     {
    1:       // mMouseMotionListenerP might be registerd either by IID or
    1:       // name, unregister by both.
 1418:       piTarget->RemoveEventListenerByIID(mMouseMotionListenerP,
    1:                                          NS_GET_IID(nsIDOMMouseMotionListener));
    1: 
 1418:       target->RemoveEventListener(NS_LITERAL_STRING("mousemove"),
    1:                                   mMouseMotionListenerP, PR_TRUE);
    1:     }
    1: 
    1:     if (mResizeEventListenerP)
    1:     {
 1418:       target->RemoveEventListener(NS_LITERAL_STRING("resize"),
    1:                                   mResizeEventListenerP, PR_FALSE);
    1:     }
    1:   }
    1: 
    1:   mMouseMotionListenerP = nsnull;
    1:   mResizeEventListenerP = nsnull;
    1: 
    1:   nsPlaintextEditor::RemoveEventListeners();
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::GetFlags(PRUint32 *aFlags)
    1: {
    1:   if (!mRules || !aFlags) { return NS_ERROR_NULL_POINTER; }
    1:   return mRules->GetFlags(aFlags);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::SetFlags(PRUint32 aFlags)
    1: {
    1:   if (!mRules) { return NS_ERROR_NULL_POINTER; }
 7921: 
 7921:   UpdateForFlags(aFlags);
    1: 
    1:   return mRules->SetFlags(aFlags);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::InitRules()
    1: {
    1:   // instantiate the rules for the html editor
    1:   nsresult res = NS_NewHTMLEditRules(getter_AddRefs(mRules));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!mRules) return NS_ERROR_UNEXPECTED;
 3233:   res = mRules->Init(static_cast<nsPlaintextEditor*>(this), mFlags);
    1:   
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::BeginningOfDocument()
    1: {
    1:   if (!mDocWeak || !mPresShellWeak) { return NS_ERROR_NOT_INITIALIZED; }
    1: 
    1:   // get the selection
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res))
    1:     return res;
    1:   if (!selection)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1:     
    1:   // get the root element 
    1:   nsIDOMElement *rootElement = GetRoot(); 
    1:   if (!rootElement)   return NS_ERROR_NULL_POINTER; 
    1:   
    1:   // find first editable thingy
    1:   PRBool done = PR_FALSE;
    1:   nsCOMPtr<nsIDOMNode> curNode(rootElement), selNode;
    1:   PRInt32 curOffset = 0, selOffset;
    1:   while (!done)
    1:   {
    1:     nsWSRunObject wsObj(this, curNode, curOffset);
    1:     nsCOMPtr<nsIDOMNode> visNode;
    1:     PRInt32 visOffset=0;
    1:     PRInt16 visType=0;
    1:     wsObj.NextVisibleNode(curNode, curOffset, address_of(visNode), &visOffset, &visType);
    1:     if ((visType==nsWSRunObject::eNormalWS) || 
    1:         (visType==nsWSRunObject::eText))
    1:     {
    1:       selNode = visNode;
    1:       selOffset = visOffset;
    1:       done = PR_TRUE;
    1:     }
    1:     else if ((visType==nsWSRunObject::eBreak)    ||
    1:              (visType==nsWSRunObject::eSpecial))
    1:     {
    1:       res = GetNodeLocation(visNode, address_of(selNode), &selOffset);
    1:       if (NS_FAILED(res)) return res; 
    1:       done = PR_TRUE;
    1:     }
    1:     else if (visType==nsWSRunObject::eOtherBlock)
    1:     {
    1:       // By definition of nsWSRunObject, a block element terminates 
    1:       // a whitespace run. That is, although we are calling a method 
    1:       // that is named "NextVisibleNode", the node returned
    1:       // might not be visible/editable!
    1:       // If the given block does not contain any visible/editable items,
    1:       // we want to skip it and continue our search.
    1: 
    1:       if (!IsContainer(visNode))
    1:       {
    1:         // However, we were given a block that is not a container.
    1:         // Since the block can not contain anything that's visible,
    1:         // such a block only makes sense if it is visible by itself,
    1:         // like a <hr>
    1:         // We want to place the caret in front of that block.
    1: 
    1:         res = GetNodeLocation(visNode, address_of(selNode), &selOffset);
    1:         if (NS_FAILED(res)) return res; 
    1:         done = PR_TRUE;
    1:       }
    1:       else
    1:       {
    1:         PRBool isEmptyBlock;
    1:         if (NS_SUCCEEDED(IsEmptyNode(visNode, &isEmptyBlock)) &&
    1:             isEmptyBlock)
    1:         {
    1:           // skip the empty block
    1:           res = GetNodeLocation(visNode, address_of(curNode), &curOffset);
    1:           if (NS_FAILED(res)) return res; 
    1:           ++curOffset;
    1:         }
    1:         else
    1:         {
    1:           curNode = visNode;
    1:           curOffset = 0;
    1:         }
    1:         // keep looping
    1:       }
    1:     }
    1:     else
    1:     {
    1:       // else we found nothing useful
    1:       selNode = curNode;
    1:       selOffset = curOffset;
    1:       done = PR_TRUE;
    1:     }
    1:   }
    1:   return selection->Collapse(selNode, selOffset);
    1: }
    1: 
    1: /**
    1:  * Returns true if the id represents an element of block type.
    1:  * Can be used to determine if a new paragraph should be started.
    1:  */
    1: nsresult
    1: nsHTMLEditor::NodeIsBlockStatic(nsIDOMNode *aNode, PRBool *aIsBlock)
    1: {
    1:   if (!aNode || !aIsBlock) { return NS_ERROR_NULL_POINTER; }
    1: 
    1:   *aIsBlock = PR_FALSE;
    1: 
    1: #define USE_PARSER_FOR_BLOCKNESS 1
    1: #ifdef USE_PARSER_FOR_BLOCKNESS
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIDOMElement>element = do_QueryInterface(aNode);
    1:   if (!element)
    1:   {
    1:     // We don't have an element -- probably a text node
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsIAtom *tagAtom = GetTag(aNode);
    1:   if (!tagAtom) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Nodes we know we want to treat as block
    1:   // even though the parser says they're not:
    1:   if (tagAtom==nsEditProperty::body       ||
    1:       tagAtom==nsEditProperty::head       ||
    1:       tagAtom==nsEditProperty::tbody      ||
    1:       tagAtom==nsEditProperty::thead      ||
    1:       tagAtom==nsEditProperty::tfoot      ||
    1:       tagAtom==nsEditProperty::tr         ||
    1:       tagAtom==nsEditProperty::th         ||
    1:       tagAtom==nsEditProperty::td         ||
    1:       tagAtom==nsEditProperty::li         ||
    1:       tagAtom==nsEditProperty::dt         ||
    1:       tagAtom==nsEditProperty::dd         ||
    1:       tagAtom==nsEditProperty::pre)
    1:   {
    1:     *aIsBlock = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   rv = nsContentUtils::GetParserService()->
    1:     IsBlock(nsContentUtils::GetParserService()->HTMLAtomTagToId(tagAtom),
    1:             *aIsBlock);
    1: 
    1: #ifdef DEBUG
    1:   // Check this against what we would have said with the old code:
    1:   if (tagAtom==nsEditProperty::p          ||
    1:       tagAtom==nsEditProperty::div        ||
    1:       tagAtom==nsEditProperty::blockquote ||
    1:       tagAtom==nsEditProperty::h1         ||
    1:       tagAtom==nsEditProperty::h2         ||
    1:       tagAtom==nsEditProperty::h3         ||
    1:       tagAtom==nsEditProperty::h4         ||
    1:       tagAtom==nsEditProperty::h5         ||
    1:       tagAtom==nsEditProperty::h6         ||
    1:       tagAtom==nsEditProperty::ul         ||
    1:       tagAtom==nsEditProperty::ol         ||
    1:       tagAtom==nsEditProperty::dl         ||
    1:       tagAtom==nsEditProperty::noscript   ||
    1:       tagAtom==nsEditProperty::form       ||
    1:       tagAtom==nsEditProperty::hr         ||
    1:       tagAtom==nsEditProperty::table      ||
    1:       tagAtom==nsEditProperty::fieldset   ||
    1:       tagAtom==nsEditProperty::address    ||
    1:       tagAtom==nsEditProperty::caption    ||
    1:       tagAtom==nsEditProperty::col        ||
    1:       tagAtom==nsEditProperty::colgroup   ||
    1:       tagAtom==nsEditProperty::li         ||
    1:       tagAtom==nsEditProperty::dt         ||
    1:       tagAtom==nsEditProperty::dd         ||
    1:       tagAtom==nsEditProperty::legend     )
    1:   {
    1:     if (!(*aIsBlock))
    1:     {
    1:       nsAutoString assertmsg (NS_LITERAL_STRING("Parser and editor disagree on blockness: "));
    1: 
    1:       nsAutoString tagName;
    1:       rv = element->GetTagName(tagName);
    1:       if (NS_FAILED(rv)) return rv;
    1: 
    1:       assertmsg.Append(tagName);
    1:       char* assertstr = ToNewCString(assertmsg);
    1:       NS_ASSERTION(*aIsBlock, assertstr);
  241:       NS_Free(assertstr);
    1:     }
    1:   }
    1: #endif /* DEBUG */
    1: 
    1:   return rv;
    1: #else /* USE_PARSER_FOR_BLOCKNESS */
    1:   nsresult result = NS_ERROR_FAILURE;
    1:   *aIsBlock = PR_FALSE;
    1:   nsCOMPtr<nsIDOMElement>element;
    1:   element = do_QueryInterface(aNode);
    1:   if (element)
    1:   {
    1:     nsAutoString tagName;
    1:     result = element->GetTagName(tagName);
    1:     if (NS_SUCCEEDED(result))
    1:     {
    1:       ToLowerCase(tagName);
    1:       nsCOMPtr<nsIAtom> tagAtom = do_GetAtom(tagName);
    1:       if (!tagAtom) { return NS_ERROR_NULL_POINTER; }
    1: 
    1:       if (tagAtom==nsEditProperty::p          ||
    1:           tagAtom==nsEditProperty::div        ||
    1:           tagAtom==nsEditProperty::blockquote ||
    1:           tagAtom==nsEditProperty::h1         ||
    1:           tagAtom==nsEditProperty::h2         ||
    1:           tagAtom==nsEditProperty::h3         ||
    1:           tagAtom==nsEditProperty::h4         ||
    1:           tagAtom==nsEditProperty::h5         ||
    1:           tagAtom==nsEditProperty::h6         ||
    1:           tagAtom==nsEditProperty::ul         ||
    1:           tagAtom==nsEditProperty::ol         ||
    1:           tagAtom==nsEditProperty::dl         ||
    1:           tagAtom==nsEditProperty::pre        ||
    1:           tagAtom==nsEditProperty::noscript   ||
    1:           tagAtom==nsEditProperty::form       ||
    1:           tagAtom==nsEditProperty::hr         ||
    1:           tagAtom==nsEditProperty::fieldset   ||
    1:           tagAtom==nsEditProperty::address    ||
    1:           tagAtom==nsEditProperty::body       ||
    1:           tagAtom==nsEditProperty::caption    ||
    1:           tagAtom==nsEditProperty::table      ||
    1:           tagAtom==nsEditProperty::tbody      ||
    1:           tagAtom==nsEditProperty::thead      ||
    1:           tagAtom==nsEditProperty::tfoot      ||
    1:           tagAtom==nsEditProperty::tr         ||
    1:           tagAtom==nsEditProperty::td         ||
    1:           tagAtom==nsEditProperty::th         ||
    1:           tagAtom==nsEditProperty::col        ||
    1:           tagAtom==nsEditProperty::colgroup   ||
    1:           tagAtom==nsEditProperty::li         ||
    1:           tagAtom==nsEditProperty::dt         ||
    1:           tagAtom==nsEditProperty::dd         ||
    1:           tagAtom==nsEditProperty::legend     )
    1:       {
    1:         *aIsBlock = PR_TRUE;
    1:       }
    1:       result = NS_OK;
    1:     }
    1:   } else {
    1:     // We don't have an element -- probably a text node
    1:     nsCOMPtr<nsIDOMCharacterData>nodeAsText = do_QueryInterface(aNode);
    1:     if (nodeAsText)
    1:     {
    1:       *aIsBlock = PR_FALSE;
    1:       result = NS_OK;
    1:     }
    1:   }
    1:   return result;
    1: 
    1: #endif /* USE_PARSER_FOR_BLOCKNESS */
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::NodeIsBlock(nsIDOMNode *aNode, PRBool *aIsBlock)
    1: {
    1:   return NodeIsBlockStatic(aNode, aIsBlock);
    1: }
    1: 
    1: PRBool
    1: nsHTMLEditor::IsBlockNode(nsIDOMNode *aNode)
    1: {
    1:   PRBool isBlock;
    1:   NodeIsBlockStatic(aNode, &isBlock);
    1:   return isBlock;
    1: }
    1: 
    1: // Non-static version for the nsIEditor interface and JavaScript
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::SetDocumentTitle(const nsAString &aTitle)
    1: {
27825:   nsRefPtr<SetDocTitleTxn> txn = new SetDocTitleTxn();
27825:   if (!txn)
27825:     return NS_ERROR_OUT_OF_MEMORY;
27825: 
27825:   nsresult result = txn->Init(this, &aTitle);
27825:   if (NS_FAILED(result))
27825:     return result;
27825: 
    1:   //Don't let Rules System change the selection
    1:   nsAutoTxnsConserveSelection dontChangeSelection(this);
27825:   return nsEditor::DoTransaction(txn);  
    1: }
    1: 
    1: /* ------------ Block methods moved from nsEditor -------------- */
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetBlockNodeParent: returns enclosing block level ancestor, if any
    1: //
    1: nsCOMPtr<nsIDOMNode>
    1: nsHTMLEditor::GetBlockNodeParent(nsIDOMNode *aNode)
    1: {
    1:   nsCOMPtr<nsIDOMNode> tmp;
    1:   nsCOMPtr<nsIDOMNode> p;
    1: 
    1:   if (!aNode)
    1:   {
    1:     NS_NOTREACHED("null node passed to GetBlockNodeParent()");
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   if (NS_FAILED(aNode->GetParentNode(getter_AddRefs(p))))  // no parent, ran off top of tree
    1:     return tmp;
    1: 
    1:   while (p)
    1:   {
    1:     PRBool isBlock;
    1:     if (NS_FAILED(NodeIsBlockStatic(p, &isBlock)) || isBlock)
    1:       break;
    1:     if ( NS_FAILED(p->GetParentNode(getter_AddRefs(tmp))) || !tmp) // no parent, ran off top of tree
    1:       return p;
    1: 
    1:     p = tmp;
    1:   }
    1:   return p;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetBlockSection: return leftmost/rightmost nodes in aChild's block
    1: //               
    1: nsresult
    1: nsHTMLEditor::GetBlockSection(nsIDOMNode *aChild,
    1:                               nsIDOMNode **aLeftNode, 
    1:                               nsIDOMNode **aRightNode) 
    1: {
    1:   nsresult result = NS_OK;
    1:   if (!aChild || !aLeftNode || !aRightNode) {return NS_ERROR_NULL_POINTER;}
    1:   *aLeftNode = aChild;
    1:   *aRightNode = aChild;
    1: 
    1:   nsCOMPtr<nsIDOMNode>sibling;
    1:   result = aChild->GetPreviousSibling(getter_AddRefs(sibling));
    1:   while ((NS_SUCCEEDED(result)) && sibling)
    1:   {
    1:     PRBool isBlock;
    1:     NodeIsBlockStatic(sibling, &isBlock);
    1:     if (isBlock)
    1:     {
    1:       nsCOMPtr<nsIDOMCharacterData>nodeAsText = do_QueryInterface(sibling);
    1:       if (!nodeAsText) {
    1:         break;
    1:       }
    1:       // XXX: needs some logic to work for other leaf nodes besides text!
    1:     }
    1:     *aLeftNode = sibling;
    1:     result = (*aLeftNode)->GetPreviousSibling(getter_AddRefs(sibling)); 
    1:   }
    1:   NS_ADDREF((*aLeftNode));
    1:   // now do the right side
    1:   result = aChild->GetNextSibling(getter_AddRefs(sibling));
    1:   while ((NS_SUCCEEDED(result)) && sibling)
    1:   {
    1:     PRBool isBlock;
    1:     NodeIsBlockStatic(sibling, &isBlock);
    1:     if (isBlock) 
    1:     {
    1:       nsCOMPtr<nsIDOMCharacterData>nodeAsText = do_QueryInterface(sibling);
    1:       if (!nodeAsText) {
    1:         break;
    1:       }
    1:     }
    1:     *aRightNode = sibling;
    1:     result = (*aRightNode)->GetNextSibling(getter_AddRefs(sibling)); 
    1:   }
    1:   NS_ADDREF((*aRightNode));
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetBlockSectionsForRange: return list of block sections that intersect 
    1: //                           this range
    1: nsresult
    1: nsHTMLEditor::GetBlockSectionsForRange(nsIDOMRange *aRange,
    1:                                        nsCOMArray<nsIDOMRange>& aSections) 
    1: {
    1:   if (!aRange) {return NS_ERROR_NULL_POINTER;}
    1: 
    1:   nsresult result;
    1:   nsCOMPtr<nsIContentIterator>iter =
    1:     do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &result);
    1:   if ((NS_SUCCEEDED(result)) && iter)
    1:   {
    1:     nsCOMPtr<nsIDOMRange> lastRange;
    1:     iter->Init(aRange);
    1:     while (iter->IsDone())
    1:     {
20503:       nsCOMPtr<nsIContent> currentContent =
20503:         do_QueryInterface(iter->GetCurrentNode());
    1: 
    1:       nsCOMPtr<nsIDOMNode>currentNode = do_QueryInterface(currentContent);
    1:       if (currentNode)
    1:       {
    1:         // <BR> divides block content ranges.  We can achieve this by nulling out lastRange
    1:         if (currentContent->Tag() == nsEditProperty::br)
    1:         {
    1:           lastRange = nsnull;
    1:         }
    1:         else
    1:         {
    1:           PRBool isNotInlineOrText;
    1:           result = NodeIsBlockStatic(currentNode, &isNotInlineOrText);
    1:           if (isNotInlineOrText)
    1:           {
    1:             PRUint16 nodeType;
    1:             currentNode->GetNodeType(&nodeType);
    1:             if (nsIDOMNode::TEXT_NODE == nodeType) {
    1:               isNotInlineOrText = PR_TRUE;
    1:             }
    1:           }
    1:           if (PR_FALSE==isNotInlineOrText)
    1:           {
    1:             nsCOMPtr<nsIDOMNode>leftNode;
    1:             nsCOMPtr<nsIDOMNode>rightNode;
    1:             result = GetBlockSection(currentNode,
    1:                                      getter_AddRefs(leftNode),
    1:                                      getter_AddRefs(rightNode));
    1:             if ((NS_SUCCEEDED(result)) && leftNode && rightNode)
    1:             {
    1:               // add range to the list if it doesn't overlap with the previous range
    1:               PRBool addRange=PR_TRUE;
    1:               if (lastRange)
    1:               {
    1:                 nsCOMPtr<nsIDOMNode> lastStartNode;
    1:                 nsCOMPtr<nsIDOMElement> blockParentOfLastStartNode;
    1:                 lastRange->GetStartContainer(getter_AddRefs(lastStartNode));
    1:                 blockParentOfLastStartNode = do_QueryInterface(GetBlockNodeParent(lastStartNode));
    1:                 if (blockParentOfLastStartNode)
    1:                 {
    1:                   nsCOMPtr<nsIDOMElement> blockParentOfLeftNode;
    1:                   blockParentOfLeftNode = do_QueryInterface(GetBlockNodeParent(leftNode));
    1:                   if (blockParentOfLeftNode)
    1:                   {
    1:                     if (blockParentOfLastStartNode==blockParentOfLeftNode) {
    1:                       addRange = PR_FALSE;
    1:                     }
    1:                   }
    1:                 }
    1:               }
    1:               if (PR_TRUE==addRange) 
    1:               {
    1:                 nsCOMPtr<nsIDOMRange> range =
    1:                      do_CreateInstance("@mozilla.org/content/range;1", &result);
    1:                 if ((NS_SUCCEEDED(result)) && range)
    1:                 { // initialize the range
    1:                   range->SetStart(leftNode, 0);
    1:                   range->SetEnd(rightNode, 0);
    1:                   aSections.AppendObject(range);
    1:                   lastRange = do_QueryInterface(range);
    1:                 }
    1:               }        
    1:             }
    1:           }
    1:         }
    1:       }
    1:       /* do not check result here, and especially do not return the result code.
    1:        * we rely on iter->IsDone to tell us when the iteration is complete
    1:        */
    1:       iter->Next();
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // NextNodeInBlock: gets the next/prev node in the block, if any.  Next node
    1: //                  must be an element or text node, others are ignored
    1: nsCOMPtr<nsIDOMNode>
    1: nsHTMLEditor::NextNodeInBlock(nsIDOMNode *aNode, IterDirection aDir)
    1: {
    1:   nsCOMPtr<nsIDOMNode> nullNode;
    1:   nsCOMPtr<nsIContent> content;
    1:   nsCOMPtr<nsIContent> blockContent;
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIDOMNode> blockParent;
    1:   
    1:   if (!aNode)  return nullNode;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIContentIterator> iter =
    1:        do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &rv);
    1:   if (NS_FAILED(rv))
    1:     return nullNode;
    1: 
    1:   // much gnashing of teeth as we twit back and forth between content and domnode types
    1:   content = do_QueryInterface(aNode);
    1:   PRBool isBlock;
    1:   if (NS_SUCCEEDED(NodeIsBlockStatic(aNode, &isBlock)) && isBlock)
    1:   {
    1:     blockParent = aNode;
    1:   }
    1:   else
    1:   {
    1:     blockParent = GetBlockNodeParent(aNode);
    1:   }
    1:   if (!blockParent) return nullNode;
    1:   blockContent = do_QueryInterface(blockParent);
    1:   if (!blockContent) return nullNode;
    1:   
    1:   if (NS_FAILED(iter->Init(blockContent)))  return nullNode;
    1:   if (NS_FAILED(iter->PositionAt(content)))  return nullNode;
    1:   
    1:   while (!iter->IsDone())
    1:   {
    1:     // ignore nodes that aren't elements or text, or that are the
    1:     // block parent
    1:     node = do_QueryInterface(iter->GetCurrentNode());
    1:     if (node && IsTextOrElementNode(node) && node != blockParent &&
    1:         node != aNode)
    1:       return node;
    1: 
    1:     if (aDir == kIterForward)
    1:       iter->Next();
    1:     else
    1:       iter->Prev();
    1:   }
    1:   
    1:   return nullNode;
    1: }
    1: 
    1: static const PRUnichar nbsp = 160;
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsNextCharWhitespace: checks the adjacent content in the same block
    1: //                       to see if following selection is whitespace or nbsp
    1: nsresult 
    1: nsHTMLEditor::IsNextCharWhitespace(nsIDOMNode *aParentNode, 
    1:                                    PRInt32 aOffset,
    1:                                    PRBool *outIsSpace,
    1:                                    PRBool *outIsNBSP,
    1:                                    nsCOMPtr<nsIDOMNode> *outNode,
    1:                                    PRInt32 *outOffset)
    1: {
    1:   if (!outIsSpace || !outIsNBSP) return NS_ERROR_NULL_POINTER;
    1:   *outIsSpace = PR_FALSE;
    1:   *outIsNBSP = PR_FALSE;
    1:   if (outNode) *outNode = nsnull;
    1:   if (outOffset) *outOffset = -1;
    1:   
    1:   nsAutoString tempString;
    1:   PRUint32 strLength;
    1:   nsCOMPtr<nsIDOMText> textNode = do_QueryInterface(aParentNode);
    1:   if (textNode)
    1:   {
    1:     textNode->GetLength(&strLength);
    1:     if ((PRUint32)aOffset < strLength)
    1:     {
    1:       // easy case: next char is in same node
    1:       textNode->SubstringData(aOffset,aOffset+1,tempString);
    1:       *outIsSpace = nsCRT::IsAsciiSpace(tempString.First());
    1:       *outIsNBSP = (tempString.First() == nbsp);
    1:       if (outNode) *outNode = do_QueryInterface(aParentNode);
    1:       if (outOffset) *outOffset = aOffset+1;  // yes, this is _past_ the character; 
    1:       return NS_OK;
    1:     }
    1:   }
    1:   
    1:   // harder case: next char in next node.
    1:   nsCOMPtr<nsIDOMNode> node = NextNodeInBlock(aParentNode, kIterForward);
    1:   nsCOMPtr<nsIDOMNode> tmp;
    1:   while (node) 
    1:   {
    1:     PRBool isBlock (PR_FALSE);
    1:     NodeIsBlock(node, &isBlock);
    1:     if (isBlock)  // skip over bold, italic, link, ect nodes
    1:     {
    1:       if (IsTextNode(node) && IsEditable(node))
    1:       {
    1:         textNode = do_QueryInterface(node);
    1:         textNode->GetLength(&strLength);
    1:         if (strLength)
    1:         {
    1:           textNode->SubstringData(0,1,tempString);
    1:           *outIsSpace = nsCRT::IsAsciiSpace(tempString.First());
    1:           *outIsNBSP = (tempString.First() == nbsp);
    1:           if (outNode) *outNode = do_QueryInterface(node);
    1:           if (outOffset) *outOffset = 1;  // yes, this is _past_ the character; 
    1:           return NS_OK;
    1:         }
    1:         // else it's an empty text node, or not editable; skip it.
    1:       }
    1:       else  // node is an image or some other thingy that doesn't count as whitespace
    1:       {
    1:         break;
    1:       }
    1:     }
    1:     tmp = node;
    1:     node = NextNodeInBlock(tmp, kIterForward);
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsPrevCharWhitespace: checks the adjacent content in the same block
    1: //                       to see if following selection is whitespace
    1: nsresult 
    1: nsHTMLEditor::IsPrevCharWhitespace(nsIDOMNode *aParentNode, 
    1:                                    PRInt32 aOffset,
    1:                                    PRBool *outIsSpace,
    1:                                    PRBool *outIsNBSP,
    1:                                    nsCOMPtr<nsIDOMNode> *outNode,
    1:                                    PRInt32 *outOffset)
    1: {
    1:   if (!outIsSpace || !outIsNBSP) return NS_ERROR_NULL_POINTER;
    1:   *outIsSpace = PR_FALSE;
    1:   *outIsNBSP = PR_FALSE;
    1:   if (outNode) *outNode = nsnull;
    1:   if (outOffset) *outOffset = -1;
    1:   
    1:   nsAutoString tempString;
    1:   PRUint32 strLength;
    1:   nsCOMPtr<nsIDOMText> textNode = do_QueryInterface(aParentNode);
    1:   if (textNode)
    1:   {
    1:     if (aOffset > 0)
    1:     {
    1:       // easy case: prev char is in same node
    1:       textNode->SubstringData(aOffset-1,aOffset,tempString);
    1:       *outIsSpace = nsCRT::IsAsciiSpace(tempString.First());
    1:       *outIsNBSP = (tempString.First() == nbsp);
    1:       if (outNode) *outNode = do_QueryInterface(aParentNode);
    1:       if (outOffset) *outOffset = aOffset-1;  
    1:       return NS_OK;
    1:     }
    1:   }
    1:   
    1:   // harder case: prev char in next node
    1:   nsCOMPtr<nsIDOMNode> node = NextNodeInBlock(aParentNode, kIterBackward);
    1:   nsCOMPtr<nsIDOMNode> tmp;
    1:   while (node) 
    1:   {
    1:     PRBool isBlock (PR_FALSE);
    1:     NodeIsBlock(node, &isBlock);
    1:     if (isBlock)  // skip over bold, italic, link, ect nodes
    1:     {
    1:       if (IsTextNode(node) && IsEditable(node))
    1:       {
    1:         textNode = do_QueryInterface(node);
    1:         textNode->GetLength(&strLength);
    1:         if (strLength)
    1:         {
    1:           // you could use nsIContent::TextIsOnlyWhitespace here
    1:           textNode->SubstringData(strLength-1,strLength,tempString);
    1:           *outIsSpace = nsCRT::IsAsciiSpace(tempString.First());
    1:           *outIsNBSP = (tempString.First() == nbsp);
    1:           if (outNode) *outNode = do_QueryInterface(aParentNode);
    1:           if (outOffset) *outOffset = strLength-1;  
    1:           return NS_OK;
    1:         }
    1:         // else it's an empty text node, or not editable; skip it.
    1:       }
    1:       else  // node is an image or some other thingy that doesn't count as whitespace
    1:       {
    1:         break;
    1:       }
    1:     }
    1:     // otherwise we found a node we want to skip, keep going
    1:     tmp = node;
    1:     node = NextNodeInBlock(tmp, kIterBackward);
    1:   }
    1:   
    1:   return NS_OK;
    1:   
    1: }
    1: 
    1: 
    1: 
    1: /* ------------ End Block methods -------------- */
    1: 
    1: 
    1: PRBool nsHTMLEditor::IsVisBreak(nsIDOMNode *aNode)
    1: {
    1:   if (!aNode) 
    1:     return PR_FALSE;
    1:   if (!nsTextEditUtils::IsBreak(aNode)) 
    1:     return PR_FALSE;
    1:   // check if there is a later node in block after br
    1:   nsCOMPtr<nsIDOMNode> priorNode, nextNode;
    1:   GetPriorHTMLNode(aNode, address_of(priorNode), PR_TRUE); 
    1:   GetNextHTMLNode(aNode, address_of(nextNode), PR_TRUE); 
    1:   // if we are next to another break, we are visible
    1:   if (priorNode && nsTextEditUtils::IsBreak(priorNode))
    1:     return PR_TRUE;
    1:   if (nextNode && nsTextEditUtils::IsBreak(nextNode))
    1:     return PR_TRUE;
    1:   
    1:   // if we are right before block boundary, then br not visible
    1:   if (!nextNode) 
    1:     return PR_FALSE;  // this break is trailer in block, it's not visible
    1:   if (IsBlockNode(nextNode))
    1:     return PR_FALSE; // break is right before a block, it's not visible
    1:     
    1:   // sigh.  We have to use expensive whitespace calculation code to 
    1:   // determine what is going on
    1:   nsCOMPtr<nsIDOMNode> selNode, tmp;
    1:   PRInt32 selOffset;
    1:   GetNodeLocation(aNode, address_of(selNode), &selOffset);
    1:   selOffset++; // lets look after the break
    1:   nsWSRunObject wsObj(this, selNode, selOffset);
    1:   nsCOMPtr<nsIDOMNode> visNode;
    1:   PRInt32 visOffset=0;
    1:   PRInt16 visType=0;
    1:   wsObj.NextVisibleNode(selNode, selOffset, address_of(visNode), &visOffset, &visType);
    1:   if (visType & nsWSRunObject::eBlock)
    1:     return PR_FALSE;
    1:   
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetIsDocumentEditable(PRBool *aIsDocumentEditable)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIsDocumentEditable);
    1: 
    1:   nsCOMPtr<nsIDOMDocument> doc;
    1:   GetDocument(getter_AddRefs(doc));
    1:   *aIsDocumentEditable = doc ? IsModifiable() : PR_FALSE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool nsHTMLEditor::IsModifiable()
    1: {
    1:   PRUint32 flags;
    1:   if (NS_SUCCEEDED(GetFlags(&flags)))
    1:     return ((flags & nsIPlaintextEditor::eEditorReadonlyMask) == 0);
    1:   else
    1:     return PR_FALSE;
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  nsIHTMLEditor methods 
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::UpdateBaseURL()
    1: {
    1:   nsCOMPtr<nsIDOMDocument> domDoc;
    1:   GetDocument(getter_AddRefs(domDoc));
    1:   if (!domDoc) return NS_ERROR_FAILURE;
    1: 
    1:   // Look for an HTML <base> tag
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1:   nsresult rv = domDoc->GetElementsByTagName(NS_LITERAL_STRING("base"), getter_AddRefs(nodeList));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMNode> baseNode;
    1:   if (nodeList)
    1:   {
    1:     PRUint32 count;
    1:     nodeList->GetLength(&count);
    1:     if (count >= 1)
    1:     {
    1:       rv = nodeList->Item(0, getter_AddRefs(baseNode));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1:   // If no base tag, then set baseURL to the document's URL
    1:   // This is very important, else relative URLs for links and images are wrong
    1:   if (!baseNode)
    1:   {
    1:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
    1:     if (!doc) return NS_ERROR_FAILURE;
    1: 
    1:     return doc->SetBaseURI(doc->GetDocumentURI());
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::HandleKeyPress(nsIDOMKeyEvent* aKeyEvent)
    1: {
    1:   PRUint32 keyCode, character;
    1:   PRBool   isShift, ctrlKey, altKey, metaKey;
    1:   nsresult res;
    1: 
    1:   if (!aKeyEvent) return NS_ERROR_NULL_POINTER;
    1: 
    1:   if (NS_SUCCEEDED(aKeyEvent->GetKeyCode(&keyCode)) && 
    1:       NS_SUCCEEDED(aKeyEvent->GetShiftKey(&isShift)) &&
    1:       NS_SUCCEEDED(aKeyEvent->GetCtrlKey(&ctrlKey)) &&
    1:       NS_SUCCEEDED(aKeyEvent->GetAltKey(&altKey)) &&
    1:       NS_SUCCEEDED(aKeyEvent->GetMetaKey(&metaKey)))
    1:   {
    1:     // this royally blows: because tabs come in from keyDowns instead
    1:     // of keyPress, and because GetCharCode refuses to work for keyDown
    1:     // i have to play games.
    1:     if (keyCode == nsIDOMKeyEvent::DOM_VK_TAB) character = '\t';
    1:     else aKeyEvent->GetCharCode(&character);
    1:     
    1:     if (keyCode == nsIDOMKeyEvent::DOM_VK_TAB)
    1:     {
    1:       if (!(mFlags & eEditorPlaintextMask)) {
    1:         nsCOMPtr<nsISelection>selection;
    1:         res = GetSelection(getter_AddRefs(selection));
    1:         if (NS_FAILED(res)) return res;
    1:         PRInt32 offset;
    1:         nsCOMPtr<nsIDOMNode> node, blockParent;
    1:         res = GetStartNodeAndOffset(selection, address_of(node), &offset);
    1:         if (NS_FAILED(res)) return res;
    1:         if (!node) return NS_ERROR_FAILURE;
    1: 
    1:         PRBool isBlock = PR_FALSE;
    1:         NodeIsBlock(node, &isBlock);
    1:         if (isBlock) blockParent = node;
    1:         else blockParent = GetBlockNodeParent(node);
    1:         
    1:         if (blockParent)
    1:         {
    1:           PRBool bHandled = PR_FALSE;
    1:           
    1:           if (nsHTMLEditUtils::IsTableElement(blockParent))
    1:           {
    1:             res = TabInTable(isShift, &bHandled);
    1:             if (bHandled)
    1:               ScrollSelectionIntoView(PR_FALSE);
    1:           }
    1:           else if (nsHTMLEditUtils::IsListItem(blockParent))
    1:           {
    1:             nsAutoString indentstr;
    1:             if (isShift) indentstr.AssignLiteral("outdent");
    1:             else         indentstr.AssignLiteral("indent");
    1:             res = Indent(indentstr);
    1:             bHandled = PR_TRUE;
    1:           }
    1:           if (NS_FAILED(res)) return res;
    1:           if (bHandled)
    1:             return aKeyEvent->PreventDefault(); // consumed
    1:         }
    1:       }
    1:       if (isShift)
    1:         return NS_OK; // don't type text for shift tabs
    1:     }
    1:     else if (keyCode == nsIDOMKeyEvent::DOM_VK_RETURN
    1:              || keyCode == nsIDOMKeyEvent::DOM_VK_ENTER)
    1:     {
    1:       aKeyEvent->PreventDefault();
    1:       nsString empty;
    1:       if (isShift && !(mFlags&eEditorPlaintextMask))
    1:       {
    1:         return TypedText(empty, eTypedBR);  // only inserts a br node
    1:       }
    1:       else 
    1:       {
    1:         return TypedText(empty, eTypedBreak);  // uses rules to figure out what to insert
    1:       }
    1:     }
    1:     else if (keyCode == nsIDOMKeyEvent::DOM_VK_ESCAPE)
    1:     {
    1:       aKeyEvent->PreventDefault();
    1:       // pass escape keypresses through as empty strings: needed forime support
    1:       nsString empty;
    1:       return TypedText(empty, eTypedText);
    1:     }
    1:     
    1:     // if we got here we either fell out of the tab case or have a normal character.
    1:     // Either way, treat as normal character.
    1:     if (character && !altKey && !ctrlKey && !metaKey)
    1:     {
    1:       aKeyEvent->PreventDefault();
    1:       nsAutoString key(character);
    1:       return TypedText(key, eTypedText);
    1:     }
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* This routine is needed to provide a bottleneck for typing for logging
    1:    purposes.  Can't use HandleKeyPress() (above) for that since it takes
    1:    a nsIDOMKeyEvent* parameter.  So instead we pass enough info through
    1:    to TypedText() to determine what action to take, but without passing
    1:    an event.
    1:    */
    1: NS_IMETHODIMP nsHTMLEditor::TypedText(const nsAString& aString,
    1:                                       PRInt32 aAction)
    1: {
13021:   nsAutoPlaceHolderBatch batch(this, nsGkAtoms::TypingTxnName);
    1: 
    1:   switch (aAction)
    1:   {
    1:     case eTypedText:
    1:     case eTypedBreak:
    1:       {
    1:         return nsPlaintextEditor::TypedText(aString, aAction);
    1:       }
    1:     case eTypedBR:
    1:       {
    1:         nsCOMPtr<nsIDOMNode> brNode;
    1:         return InsertBR(address_of(brNode));  // only inserts a br node
    1:       }
    1:   } 
    1:   return NS_ERROR_FAILURE; 
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::TabInTable(PRBool inIsShift, PRBool *outHandled)
    1: {
    1:   if (!outHandled) return NS_ERROR_NULL_POINTER;
    1:   *outHandled = PR_FALSE;
    1: 
    1:   // Find enclosing table cell from the selection (cell may be the selected element)
    1:   nsCOMPtr<nsIDOMElement> cellElement;
    1:     // can't use |NS_LITERAL_STRING| here until |GetElementOrParentByTagName| is fixed to accept readables
    1:   nsresult res = GetElementOrParentByTagName(NS_LITERAL_STRING("td"), nsnull, getter_AddRefs(cellElement));
    1:   if (NS_FAILED(res)) return res;
    1:   // Do nothing -- we didn't find a table cell
    1:   if (!cellElement) return NS_OK;
    1: 
    1:   // find enclosing table
    1:   nsCOMPtr<nsIDOMNode> tbl = GetEnclosingTable(cellElement);
    1:   if (!tbl) return res;
    1: 
    1:   // advance to next cell
    1:   // first create an iterator over the table
    1:   nsCOMPtr<nsIContentIterator> iter =
    1:       do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &res);
    1:   if (NS_FAILED(res)) return res;
    1:   if (!iter) return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsIContent> cTbl = do_QueryInterface(tbl);
    1:   nsCOMPtr<nsIContent> cBlock = do_QueryInterface(cellElement);
    1:   res = iter->Init(cTbl);
    1:   if (NS_FAILED(res)) return res;
    1:   // position iter at block
    1:   res = iter->PositionAt(cBlock);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   do
    1:   {
    1:     if (inIsShift)
    1:       iter->Prev();
    1:     else
    1:       iter->Next();
    1: 
    1:     node = do_QueryInterface(iter->GetCurrentNode());
    1: 
    1:     if (node && nsHTMLEditUtils::IsTableCell(node) &&
    1:         GetEnclosingTable(node) == tbl)
    1:     {
    1:       res = CollapseSelectionToDeepestNonTableFirstChild(nsnull, node);
    1:       if (NS_FAILED(res)) return res;
    1:       *outHandled = PR_TRUE;
    1:       return NS_OK;
    1:     }
    1:   } while (!iter->IsDone());
    1:   
    1:   if (!(*outHandled) && !inIsShift)
    1:   {
    1:     // if we havent handled it yet then we must have run off the end of
    1:     // the table.  Insert a new row.
    1:     res = InsertTableRow(1, PR_TRUE);
    1:     if (NS_FAILED(res)) return res;
    1:     *outHandled = PR_TRUE;
    1:     // put selection in right place
    1:     // Use table code to get selection and index to new row...
    1:     nsCOMPtr<nsISelection>selection;
    1:     nsCOMPtr<nsIDOMElement> tblElement;
    1:     nsCOMPtr<nsIDOMElement> cell;
    1:     PRInt32 row;
    1:     res = GetCellContext(getter_AddRefs(selection), 
    1:                          getter_AddRefs(tblElement),
    1:                          getter_AddRefs(cell), 
    1:                          nsnull, nsnull,
    1:                          &row, nsnull);
    1:     if (NS_FAILED(res)) return res;
    1:     // ...so that we can ask for first cell in that row...
    1:     res = GetCellAt(tblElement, row, 0, getter_AddRefs(cell));
    1:     if (NS_FAILED(res)) return res;
    1:     // ...and then set selection there.
    1:     // (Note that normally you should use CollapseSelectionToDeepestNonTableFirstChild(),
    1:     //  but we know cell is an empty new cell, so this works fine)
    1:     node = do_QueryInterface(cell);
    1:     if (node) selection->Collapse(node,0);
    1:     return NS_OK;
    1:   }
    1:   
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::CreateBRImpl(nsCOMPtr<nsIDOMNode> *aInOutParent, 
    1:                                          PRInt32 *aInOutOffset, 
    1:                                          nsCOMPtr<nsIDOMNode> *outBRNode, 
    1:                                          EDirection aSelect)
    1: {
    1:   if (!aInOutParent || !*aInOutParent || !aInOutOffset || !outBRNode) return NS_ERROR_NULL_POINTER;
    1:   *outBRNode = nsnull;
    1:   nsresult res;
    1:   
    1:   // we need to insert a br.  unfortunately, we may have to split a text node to do it.
    1:   nsCOMPtr<nsIDOMNode> node = *aInOutParent;
    1:   PRInt32 theOffset = *aInOutOffset;
    1:   nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(node);
    1:   NS_NAMED_LITERAL_STRING(brType, "br");
    1:   nsCOMPtr<nsIDOMNode> brNode;
    1:   if (nodeAsText)  
    1:   {
    1:     nsCOMPtr<nsIDOMNode> tmp;
    1:     PRInt32 offset;
    1:     PRUint32 len;
    1:     nodeAsText->GetLength(&len);
    1:     GetNodeLocation(node, address_of(tmp), &offset);
    1:     if (!tmp) return NS_ERROR_FAILURE;
    1:     if (!theOffset)
    1:     {
    1:       // we are already set to go
    1:     }
    1:     else if (theOffset == (PRInt32)len)
    1:     {
    1:       // update offset to point AFTER the text node
    1:       offset++;
    1:     }
    1:     else
    1:     {
    1:       // split the text node
    1:       res = SplitNode(node, theOffset, getter_AddRefs(tmp));
    1:       if (NS_FAILED(res)) return res;
    1:       res = GetNodeLocation(node, address_of(tmp), &offset);
    1:       if (NS_FAILED(res)) return res;
    1:     }
    1:     // create br
    1:     res = CreateNode(brType, tmp, offset, getter_AddRefs(brNode));
    1:     if (NS_FAILED(res)) return res;
    1:     *aInOutParent = tmp;
    1:     *aInOutOffset = offset+1;
    1:   }
    1:   else
    1:   {
    1:     res = CreateNode(brType, node, theOffset, getter_AddRefs(brNode));
    1:     if (NS_FAILED(res)) return res;
    1:     (*aInOutOffset)++;
    1:   }
    1: 
    1:   *outBRNode = brNode;
    1:   if (*outBRNode && (aSelect != eNone))
    1:   {
    1:     nsCOMPtr<nsISelection> selection;
    1:     nsCOMPtr<nsIDOMNode> parent;
    1:     PRInt32 offset;
    1:     res = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(res)) return res;
    1:     nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1:     res = GetNodeLocation(*outBRNode, address_of(parent), &offset);
    1:     if (NS_FAILED(res)) return res;
    1:     if (aSelect == eNext)
    1:     {
    1:       // position selection after br
    1:       selPriv->SetInterlinePosition(PR_TRUE);
    1:       res = selection->Collapse(parent, offset+1);
    1:     }
    1:     else if (aSelect == ePrevious)
    1:     {
    1:       // position selection before br
    1:       selPriv->SetInterlinePosition(PR_TRUE);
    1:       res = selection->Collapse(parent, offset);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::CreateBR(nsIDOMNode *aNode, PRInt32 aOffset, nsCOMPtr<nsIDOMNode> *outBRNode, EDirection aSelect)
    1: {
    1:   nsCOMPtr<nsIDOMNode> parent = aNode;
    1:   PRInt32 offset = aOffset;
    1:   return CreateBRImpl(address_of(parent), &offset, outBRNode, aSelect);
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::InsertBR(nsCOMPtr<nsIDOMNode> *outBRNode)
    1: {
    1:   PRBool bCollapsed;
    1:   nsCOMPtr<nsISelection> selection;
    1: 
    1:   if (!outBRNode) return NS_ERROR_NULL_POINTER;
    1:   *outBRNode = nsnull;
    1: 
    1:   // calling it text insertion to trigger moz br treatment by rules
    1:   nsAutoRules beginRulesSniffing(this, kOpInsertText, nsIEditor::eNext);
    1: 
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1:   res = selection->GetIsCollapsed(&bCollapsed);
    1:   if (NS_FAILED(res)) return res;
    1:   if (!bCollapsed)
    1:   {
    1:     res = DeleteSelection(nsIEditor::eNone);
    1:     if (NS_FAILED(res)) return res;
    1:   }
    1:   nsCOMPtr<nsIDOMNode> selNode;
    1:   PRInt32 selOffset;
    1:   res = GetStartNodeAndOffset(selection, address_of(selNode), &selOffset);
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   res = CreateBR(selNode, selOffset, outBRNode);
    1:   if (NS_FAILED(res)) return res;
    1:     
    1:   // position selection after br
    1:   res = GetNodeLocation(*outBRNode, address_of(selNode), &selOffset);
    1:   if (NS_FAILED(res)) return res;
    1:   selPriv->SetInterlinePosition(PR_TRUE);
    1:   res = selection->Collapse(selNode, selOffset+1);
    1:   
    1:   return res;
    1: }
    1: 
    1: nsresult 
    1: nsHTMLEditor::CollapseSelectionToDeepestNonTableFirstChild(nsISelection *aSelection, nsIDOMNode *aNode)
    1: {
    1:   if (!aNode) return NS_ERROR_NULL_POINTER;
    1:   nsresult res;
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   if (aSelection)
    1:   {
    1:     selection = aSelection;
    1:   } else {
    1:     res = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!selection) return NS_ERROR_FAILURE;
    1:   }
    1:   nsCOMPtr<nsIDOMNode> node = aNode;
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   
    1:   do {
    1:     node->GetFirstChild(getter_AddRefs(child));
    1:     
    1:     if (child)
    1:     {
    1:       // Stop if we find a table
    1:       // don't want to go into nested tables
    1:       if (nsHTMLEditUtils::IsTable(child)) break;
    1:       // hey, it'g gotta be a container too!
    1:       if (!IsContainer(child)) break;
    1:       node = child;
    1:     }
    1:   }
    1:   while (child);
    1: 
    1:   selection->Collapse(node,0);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // This is mostly like InsertHTMLWithCharsetAndContext, 
    1: //  but we can't use that because it is selection-based and 
    1: //  the rules code won't let us edit under the <head> node
    1: NS_IMETHODIMP
    1: nsHTMLEditor::ReplaceHeadContentsWithHTML(const nsAString& aSourceToInsert)
    1: {
    1:   nsAutoRules beginRulesSniffing(this, kOpIgnore, nsIEditor::eNone); // don't do any post processing, rules get confused
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1: 
    1:   ForceCompositionEnd();
    1: 
    1:   // Do not use nsAutoRules -- rules code won't let us insert in <head>
    1:   // Use the head node as a parent and delete/insert directly
    1:   nsCOMPtr<nsIDOMDocument> doc = do_QueryReferent(mDocWeak);
    1:   if (!doc) return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   nsCOMPtr<nsIDOMNodeList>nodeList; 
    1:   res = doc->GetElementsByTagName(NS_LITERAL_STRING("head"), getter_AddRefs(nodeList));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!nodeList) return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRUint32 count; 
    1:   nodeList->GetLength(&count);
    1:   if (count < 1) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMNode> headNode;
    1:   res = nodeList->Item(0, getter_AddRefs(headNode)); 
    1:   if (NS_FAILED(res)) return res;
    1:   if (!headNode) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // First, make sure there are no return chars in the source.
    1:   // Bad things happen if you insert returns (instead of dom newlines, \n)
    1:   // into an editor document.
    1:   nsAutoString inputString (aSourceToInsert);  // hope this does copy-on-write
    1:  
    1:   // Windows linebreaks: Map CRLF to LF:
    1:   inputString.ReplaceSubstring(NS_LITERAL_STRING("\r\n").get(),
    1:                                NS_LITERAL_STRING("\n").get());
    1:  
    1:   // Mac linebreaks: Map any remaining CR to LF:
    1:   inputString.ReplaceSubstring(NS_LITERAL_STRING("\r").get(),
    1:                                NS_LITERAL_STRING("\n").get());
    1: 
    1:   nsAutoEditBatch beginBatching(this);
    1: 
    1:   res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Get the first range in the selection, for context:
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   res = selection->GetRangeAt(0, getter_AddRefs(range));
    1:   if (NS_FAILED(res))
    1:     return res;
    1: 
    1:   nsCOMPtr<nsIDOMNSRange> nsrange (do_QueryInterface(range));
    1:   if (!nsrange)
    1:     return NS_ERROR_NO_INTERFACE;
    1:   nsCOMPtr<nsIDOMDocumentFragment> docfrag;
    1:   res = nsrange->CreateContextualFragment(inputString,
    1:                                           getter_AddRefs(docfrag));
    1: 
    1:   //XXXX BUG 50965: This is not returning the text between <title> ... </title>
    1:   // Special code is needed in JS to handle title anyway, so it really doesn't matter!
    1: 
    1:   if (NS_FAILED(res))
    1:   {
    1: #ifdef DEBUG
    1:     printf("Couldn't create contextual fragment: error was %d\n", res);
    1: #endif
    1:     return res;
    1:   }
    1:   if (!docfrag) return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsIDOMNode> child;
    1: 
    1:   // First delete all children in head
    1:   do {
    1:     res = headNode->GetFirstChild(getter_AddRefs(child));
    1:     if (NS_FAILED(res)) return res;
    1:     if (child)
    1:     {
    1:       res = DeleteNode(child);
    1:       if (NS_FAILED(res)) return res;
    1:     }
    1:   } while (child);
    1: 
    1:   // Now insert the new nodes
    1:   PRInt32 offsetOfNewNode = 0;
    1:   nsCOMPtr<nsIDOMNode> fragmentAsNode (do_QueryInterface(docfrag));
    1: 
    1:   // Loop over the contents of the fragment and move into the document
    1:   do {
    1:     res = fragmentAsNode->GetFirstChild(getter_AddRefs(child));
    1:     if (NS_FAILED(res)) return res;
    1:     if (child)
    1:     {
    1:       res = InsertNode(child, headNode, offsetOfNewNode++);
    1:       if (NS_FAILED(res)) return res;
    1:     }
    1:   } while (child);
    1: 
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::RebuildDocumentFromSource(const nsAString& aSourceString)
    1: {
    1:   ForceCompositionEnd();
    1: 
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   nsIDOMElement *bodyElement = GetRoot();
    1:   if (NS_FAILED(res)) return res;
    1:   if (!bodyElement) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Find where the <body> tag starts.
    1:   nsReadingIterator<PRUnichar> beginbody;
    1:   nsReadingIterator<PRUnichar> endbody;
    1:   aSourceString.BeginReading(beginbody);
    1:   aSourceString.EndReading(endbody);
    1:   PRBool foundbody = CaseInsensitiveFindInReadable(NS_LITERAL_STRING("<body"),
    1:                                                    beginbody, endbody);
    1: 
    1:   nsReadingIterator<PRUnichar> beginhead;
    1:   nsReadingIterator<PRUnichar> endhead;
    1:   aSourceString.BeginReading(beginhead);
    1:   aSourceString.EndReading(endhead);
    1:   PRBool foundhead = CaseInsensitiveFindInReadable(NS_LITERAL_STRING("<head"),
    1:                                                    beginhead, endhead);
    1: 
    1:   nsReadingIterator<PRUnichar> beginclosehead;
    1:   nsReadingIterator<PRUnichar> endclosehead;
    1:   aSourceString.BeginReading(beginclosehead);
    1:   aSourceString.EndReading(endclosehead);
    1: 
    1:   // Find the index after "<head>"
    1:   PRBool foundclosehead = CaseInsensitiveFindInReadable(
    1:            NS_LITERAL_STRING("</head>"), beginclosehead, endclosehead);
    1:   
    1:   // Time to change the document
    1:   nsAutoEditBatch beginBatching(this);
    1: 
    1:   nsReadingIterator<PRUnichar> endtotal;
    1:   aSourceString.EndReading(endtotal);
    1: 
    1:   if (foundhead) {
    1:     if (foundclosehead)
    1:       res = ReplaceHeadContentsWithHTML(Substring(beginhead, beginclosehead));
    1:     else if (foundbody)
    1:       res = ReplaceHeadContentsWithHTML(Substring(beginhead, beginbody));
    1:     else
    1:       // XXX Without recourse to some parser/content sink/docshell hackery
    1:       // we don't really know where the head ends and the body begins
    1:       // so we assume that there is no body
    1:       res = ReplaceHeadContentsWithHTML(Substring(beginhead, endtotal));
    1:   } else {
    1:     nsReadingIterator<PRUnichar> begintotal;
    1:     aSourceString.BeginReading(begintotal);
    1:     NS_NAMED_LITERAL_STRING(head, "<head>");
    1:     if (foundclosehead)
    1:       res = ReplaceHeadContentsWithHTML(head + Substring(begintotal, beginclosehead));
    1:     else if (foundbody)
    1:       res = ReplaceHeadContentsWithHTML(head + Substring(begintotal, beginbody));
    1:     else
    1:       // XXX Without recourse to some parser/content sink/docshell hackery
    1:       // we don't really know where the head ends and the body begins
    1:       // so we assume that there is no head
    1:       res = ReplaceHeadContentsWithHTML(head);
    1:   }
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   res = SelectAll();
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   if (!foundbody) {
    1:     NS_NAMED_LITERAL_STRING(body, "<body>");
    1:     // XXX Without recourse to some parser/content sink/docshell hackery
    1:     // we don't really know where the head ends and the body begins
    1:     if (foundclosehead) // assume body starts after the head ends
    1:       res = LoadHTML(body + Substring(endclosehead, endtotal));
    1:     else if (foundhead) // assume there is no body
    1:       res = LoadHTML(body);
    1:     else // assume there is no head, the entire source is body
    1:       res = LoadHTML(body + aSourceString);
    1:     if (NS_FAILED(res))
    1:       return res;
    1: 
    1:     nsCOMPtr<nsIDOMElement> divElement;
    1:     res = CreateElementWithDefaults(NS_LITERAL_STRING("div"), getter_AddRefs(divElement));
    1:     if (NS_FAILED(res))
    1:       return res;
    1: 
    1:     res = CloneAttributes(bodyElement, divElement);
    1:     if (NS_FAILED(res))
    1:       return res;
    1: 
    1:     return BeginningOfDocument();
    1:   }
    1: 
    1:   res = LoadHTML(Substring(beginbody, endtotal));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   // Now we must copy attributes user might have edited on the <body> tag
    1:   //  because InsertHTML (actually, CreateContextualFragment()) 
    1:   //  will never return a body node in the DOM fragment
    1:   
    1:   // We already know where "<body" begins
    1:   nsReadingIterator<PRUnichar> beginclosebody = beginbody;
    1:   nsReadingIterator<PRUnichar> endclosebody;
    1:   aSourceString.EndReading(endclosebody);
    1:   if (!FindInReadable(NS_LITERAL_STRING(">"),beginclosebody,endclosebody))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Truncate at the end of the body tag
    1:   // Kludge of the year: fool the parser by replacing "body" with "div" so we get a node
    1:   nsAutoString bodyTag;
    1:   bodyTag.AssignLiteral("<div ");
    1:   bodyTag.Append(Substring(endbody, endclosebody));
    1: 
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   res = selection->GetRangeAt(0, getter_AddRefs(range));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMNSRange> nsrange (do_QueryInterface(range));
    1:   if (!nsrange) return NS_ERROR_NO_INTERFACE;
    1: 
    1:   nsCOMPtr<nsIDOMDocumentFragment> docfrag;
    1:   res = nsrange->CreateContextualFragment(bodyTag, getter_AddRefs(docfrag));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMNode> fragmentAsNode (do_QueryInterface(docfrag));
    1:   if (!fragmentAsNode) return NS_ERROR_NULL_POINTER;
    1:   
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   res = fragmentAsNode->GetFirstChild(getter_AddRefs(child));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!child) return NS_ERROR_NULL_POINTER;
    1:   
    1:   // Copy all attributes from the div child to current body element
    1:   res = CloneAttributes(bodyElement, child);
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   // place selection at first editable content
    1:   return BeginningOfDocument();
    1: }
    1: 
    1: void
    1: nsHTMLEditor::NormalizeEOLInsertPosition(nsIDOMNode *firstNodeToInsert,
    1:                                      nsCOMPtr<nsIDOMNode> *insertParentNode,
    1:                                      PRInt32 *insertOffset)
    1: {
    1:   /*
    1:     This function will either correct the position passed in,
    1:     or leave the position unchanged.
    1: 
    1:     When the (first) item to insert is a block level element, 
    1:     and our insertion position is after the last visible item in a line, 
    1:     i.e. the insertion position is just before a visible line break <br>, 
    1:     we want to skip to the position just after the line break (see bug 68767)
    1: 
    1:     However, our logic to detect whether we should skip or not
    1:     needs to be more clever.
    1:     We must not skip when the caret appears to be positioned at the beginning
    1:     of a block, in that case skipping the <br> would not insert the <br>
    1:     at the caret position, but after the current empty line.
    1:      
    1:     So we have several cases to test:
    1:      
    1:     1) We only ever want to skip, if the next visible thing after the current position is a break
    1:      
    1:     2) We do not want to skip if there is no previous visible thing at all
    1:        That is detected if the call to PriorVisibleNode gives us an offset of zero.
    1:        Because PriorVisibleNode always positions after the prior node, we would
    1:        see an offset > 0, if there were a prior node.
    1:      
    1:     3) We do not want to skip, if both the next and the previous visible things are breaks.
    1:     
    1:     4) We do not want to skip if the previous visible thing is in a different block
    1:        than the insertion position.
    1:   */
    1: 
    1:   if (!IsBlockNode(firstNodeToInsert))
    1:     return;
    1: 
    1:   nsWSRunObject wsObj(this, *insertParentNode, *insertOffset);
    1:   nsCOMPtr<nsIDOMNode> nextVisNode;
    1:   nsCOMPtr<nsIDOMNode> prevVisNode;
    1:   PRInt32 nextVisOffset=0;
    1:   PRInt16 nextVisType=0;
    1:   PRInt32 prevVisOffset=0;
    1:   PRInt16 prevVisType=0;
    1: 
    1:   wsObj.NextVisibleNode(*insertParentNode, *insertOffset, address_of(nextVisNode), &nextVisOffset, &nextVisType);
    1:   if (!nextVisNode)
    1:     return;
    1: 
    1:   if (! (nextVisType & nsWSRunObject::eBreak))
    1:     return;
    1: 
    1:   wsObj.PriorVisibleNode(*insertParentNode, *insertOffset, address_of(prevVisNode), &prevVisOffset, &prevVisType);
    1:   if (!prevVisNode)
    1:     return;
    1: 
    1:   if (prevVisType & nsWSRunObject::eBreak)
    1:     return;
    1: 
    1:   if (prevVisType & nsWSRunObject::eThisBlock)
    1:     return;
    1: 
    1:   nsCOMPtr<nsIDOMNode> brNode;
    1:   PRInt32 brOffset=0;
    1: 
    1:   GetNodeLocation(nextVisNode, address_of(brNode), &brOffset);
    1: 
    1:   *insertParentNode = brNode;
    1:   *insertOffset = brOffset + 1;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::InsertElementAtSelection(nsIDOMElement* aElement, PRBool aDeleteSelection)
    1: {
    1:   nsresult res = NS_ERROR_NOT_INITIALIZED;
    1:   
    1:   if (!aElement)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aElement);
    1:   
    1:   ForceCompositionEnd();
    1:   nsAutoEditBatch beginBatching(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpInsertElement, nsIEditor::eNext);
    1: 
    1:   nsCOMPtr<nsISelection>selection;
    1:   res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res) || !selection)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // hand off to the rules system, see if it has anything to say about this
    1:   PRBool cancel, handled;
    1:   nsTextRulesInfo ruleInfo(nsTextEditRules::kInsertElement);
    1:   ruleInfo.insertElement = aElement;
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
    1:   if (cancel || (NS_FAILED(res))) return res;
    1: 
    1:   if (!handled)
    1:   {
    1:     if (aDeleteSelection)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> tempNode;
    1:       PRInt32 tempOffset;
    1:       nsresult result = DeleteSelectionAndPrepareToCreateNode(tempNode,tempOffset);
    1:       if (NS_FAILED(result))
    1:         return result;
    1:     }
    1: 
    1:     // If deleting, selection will be collapsed.
    1:     // so if not, we collapse it
    1:     if (!aDeleteSelection)
    1:     {
    1:       // Named Anchor is a special case,
    1:       // We collapse to insert element BEFORE the selection
    1:       // For all other tags, we insert AFTER the selection
    1:       if (nsHTMLEditUtils::IsNamedAnchor(node))
    1:       {
    1:         selection->CollapseToStart();
    1:       } else {
    1:         selection->CollapseToEnd();
    1:       }
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMNode> parentSelectedNode;
    1:     PRInt32 offsetForInsert;
    1:     res = selection->GetAnchorNode(getter_AddRefs(parentSelectedNode));
    1:     // XXX: ERROR_HANDLING bad XPCOM usage
    1:     if (NS_SUCCEEDED(res) && NS_SUCCEEDED(selection->GetAnchorOffset(&offsetForInsert)) && parentSelectedNode)
    1:     {
    1: #ifdef DEBUG_cmanske
    1:       {
    1:       nsAutoString name;
    1:       parentSelectedNode->GetNodeName(name);
    1:       printf("InsertElement: Anchor node of selection: ");
    1:       wprintf(name.get());
    1:       printf(" Offset: %d\n", offsetForInsert);
    1:       }
    1: #endif
    1: 
    1:       // Adjust position based on the node we are going to insert.
    1:       NormalizeEOLInsertPosition(node, address_of(parentSelectedNode), &offsetForInsert);
    1: 
    1:       res = InsertNodeAtPoint(node, address_of(parentSelectedNode), &offsetForInsert, PR_FALSE);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:       // Set caret after element, but check for special case 
    1:       //  of inserting table-related elements: set in first cell instead
    1:       if (!SetCaretInTableCell(aElement))
    1:       {
    1:         res = SetCaretAfterElement(aElement);
    1:         if (NS_FAILED(res)) return res;
    1:       }
    1:       // check for inserting a whole table at the end of a block. If so insert a br after it.
    1:       if (nsHTMLEditUtils::IsTable(node))
    1:       {
    1:         PRBool isLast;
    1:         res = IsLastEditableChild(node, &isLast);
    1:         if (NS_FAILED(res)) return res;
    1:         if (isLast)
    1:         {
    1:           nsCOMPtr<nsIDOMNode> brNode;
    1:           res = CreateBR(parentSelectedNode, offsetForInsert+1, address_of(brNode));
    1:           if (NS_FAILED(res)) return res;
    1:           selection->Collapse(parentSelectedNode, offsetForInsert+1);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
    1:   return res;
    1: }
    1: 
    1: 
    1: /* 
    1:   InsertNodeAtPoint: attempts to insert aNode into the document, at a point specified by 
    1:       {*ioParent,*ioOffset}.  Checks with strict dtd to see if containment is allowed.  If not
    1:       allowed, will attempt to find a parent in the parent heirarchy of *ioParent that will
    1:       accept aNode as a child.  If such a parent is found, will split the document tree from
    1:       {*ioParent,*ioOffset} up to parent, and then insert aNode.  ioParent & ioOffset are then
    1:       adjusted to point to the actual location that aNode was inserted at.  aNoEmptyNodes
    1:       specifies if the splitting process is allowed to reslt in empty nodes.
    1:               nsIDOMNode            *aNode           node to insert
    1:               nsCOMPtr<nsIDOMNode>  *ioParent        insertion parent
    1:               PRInt32               *ioOffset        insertion offset
    1:               PRBool                aNoEmptyNodes    splitting can result in empty nodes?
    1: */
    1: nsresult
    1: nsHTMLEditor::InsertNodeAtPoint(nsIDOMNode *aNode, 
    1:                                 nsCOMPtr<nsIDOMNode> *ioParent, 
    1:                                 PRInt32 *ioOffset, 
    1:                                 PRBool aNoEmptyNodes)
    1: {
    1:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1:   NS_ENSURE_TRUE(ioParent, NS_ERROR_NULL_POINTER);
    1:   NS_ENSURE_TRUE(*ioParent, NS_ERROR_NULL_POINTER);
    1:   NS_ENSURE_TRUE(ioOffset, NS_ERROR_NULL_POINTER);
    1:   
    1:   nsresult res = NS_OK;
    1:   nsAutoString tagName;
    1:   aNode->GetNodeName(tagName);
    1:   ToLowerCase(tagName);
    1:   nsCOMPtr<nsIDOMNode> parent = *ioParent;
    1:   nsCOMPtr<nsIDOMNode> topChild = *ioParent;
    1:   nsCOMPtr<nsIDOMNode> tmp;
    1:   PRInt32 offsetOfInsert = *ioOffset;
    1:    
    1:   // Search up the parent chain to find a suitable container      
    1:   while (!CanContainTag(parent, tagName))
    1:   {
    1:     // If the current parent is a root (body or table element)
    1:     // then go no further - we can't insert
    1:     if (nsTextEditUtils::IsBody(parent) || nsHTMLEditUtils::IsTableElement(parent))
    1:       return NS_ERROR_FAILURE;
    1:     // Get the next parent
    1:     parent->GetParentNode(getter_AddRefs(tmp));
    1:     NS_ENSURE_TRUE(tmp, NS_ERROR_FAILURE);
    1:     topChild = parent;
    1:     parent = tmp;
    1:   }
    1:   if (parent != topChild)
    1:   {
    1:     // we need to split some levels above the original selection parent
    1:     res = SplitNodeDeep(topChild, *ioParent, *ioOffset, &offsetOfInsert, aNoEmptyNodes);
    1:     if (NS_FAILED(res))
    1:       return res;
    1:     *ioParent = parent;
    1:     *ioOffset = offsetOfInsert;
    1:   }
    1:   // Now we can insert the new node
    1:   res = InsertNode(aNode, parent, offsetOfInsert);
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::SelectElement(nsIDOMElement* aElement)
    1: {
    1:   nsresult res = NS_ERROR_NULL_POINTER;
    1: 
    1:   // Must be sure that element is contained in the document body
    1:   if (IsElementInBody(aElement))
    1:   {
    1:     nsCOMPtr<nsISelection> selection;
    1:     res = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!selection) return NS_ERROR_NULL_POINTER;
    1:     nsCOMPtr<nsIDOMNode>parent;
    1:     res = aElement->GetParentNode(getter_AddRefs(parent));
    1:     if (NS_SUCCEEDED(res) && parent)
    1:     {
    1:       PRInt32 offsetInParent;
    1:       res = GetChildOffset(aElement, parent, offsetInParent);
    1: 
    1:       if (NS_SUCCEEDED(res))
    1:       {
    1:         // Collapse selection to just before desired element,
    1:         res = selection->Collapse(parent, offsetInParent);
    1:         if (NS_SUCCEEDED(res)) {
    1:           //  then extend it to just after
    1:           res = selection->Extend(parent, offsetInParent+1);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::SetCaretAfterElement(nsIDOMElement* aElement)
    1: {
    1:   nsresult res = NS_ERROR_NULL_POINTER;
    1: 
    1:   // Be sure the element is contained in the document body
    1:   if (aElement && IsElementInBody(aElement))
    1:   {
    1:     nsCOMPtr<nsISelection> selection;
    1:     res = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!selection) return NS_ERROR_NULL_POINTER;
    1:     nsCOMPtr<nsIDOMNode>parent;
    1:     res = aElement->GetParentNode(getter_AddRefs(parent));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!parent) return NS_ERROR_NULL_POINTER;
    1:     PRInt32 offsetInParent;
    1:     res = GetChildOffset(aElement, parent, offsetInParent);
    1:     if (NS_SUCCEEDED(res))
    1:     {
    1:       // Collapse selection to just after desired element,
    1:       res = selection->Collapse(parent, offsetInParent+1);
    1: #if 0 //def DEBUG_cmanske
    1:       {
    1:       nsAutoString name;
    1:       parent->GetNodeName(name);
    1:       printf("SetCaretAfterElement: Parent node: ");
    1:       wprintf(name.get());
    1:       printf(" Offset: %d\n\nHTML:\n", offsetInParent+1);
    1:       nsAutoString Format("text/html");
    1:       nsAutoString ContentsAs;
    1:       OutputToString(Format, 2, ContentsAs);
    1:       wprintf(ContentsAs.get());
    1:       }
    1: #endif
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::SetParagraphFormat(const nsAString& aParagraphFormat)
    1: {
    1:   nsAutoString tag; tag.Assign(aParagraphFormat);
    1:   ToLowerCase(tag);
    1:   if (tag.EqualsLiteral("dd") || tag.EqualsLiteral("dt"))
    1:     return MakeDefinitionItem(tag);
    1:   else
    1:     return InsertBasicBlock(tag);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::GetParagraphState(PRBool *aMixed, nsAString &outFormat)
    1: {
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1:   if (!aMixed) return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsIHTMLEditRules> htmlRules = do_QueryInterface(mRules);
    1:   if (!htmlRules) return NS_ERROR_FAILURE;
    1:   
    1:   return htmlRules->GetParagraphState(aMixed, outFormat);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetBackgroundColorState(PRBool *aMixed, nsAString &aOutColor)
    1: {
    1:   nsresult res;
    1:   PRBool useCSS;
    1:   GetIsCSSEnabled(&useCSS);
    1:   if (useCSS) {
    1:     // if we are in CSS mode, we have to check if the containing block defines
    1:     // a background color
    1:     res = GetCSSBackgroundColorState(aMixed, aOutColor, PR_TRUE);
    1:   }
    1:   else {
    1:     // in HTML mode, we look only at page's background
    1:     res = GetHTMLBackgroundColorState(aMixed, aOutColor);
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetHighlightColorState(PRBool *aMixed, nsAString &aOutColor)
    1: {
    1:   nsresult res = NS_OK;
    1:   PRBool useCSS;
    1:   GetIsCSSEnabled(&useCSS);
    1:   *aMixed = PR_FALSE;
    1:   aOutColor.AssignLiteral("transparent");
    1:   if (useCSS) {
    1:     // in CSS mode, text background can be added by the Text Highlight button
    1:     // we need to query the background of the selection without looking for
    1:     // the block container of the ranges in the selection
    1:     res = GetCSSBackgroundColorState(aMixed, aOutColor, PR_FALSE);
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::GetCSSBackgroundColorState(PRBool *aMixed, nsAString &aOutColor, PRBool aBlockLevel)
    1: {
    1:   if (!aMixed) return NS_ERROR_NULL_POINTER;
    1:   *aMixed = PR_FALSE;
    1:   // the default background color is transparent
    1:   aOutColor.AssignLiteral("transparent");
    1:   
    1:   // get selection
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   // get selection location
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   PRInt32 offset;
    1:   res = GetStartNodeAndOffset(selection, address_of(parent), &offset);
    1:   if (NS_FAILED(res)) return res;
25181:   if (!parent) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // is the selection collapsed?
    1:   PRBool bCollapsed;
    1:   res = selection->GetIsCollapsed(&bCollapsed);
    1:   if (NS_FAILED(res)) return res;
    1:   nsCOMPtr<nsIDOMNode> nodeToExamine;
    1:   if (bCollapsed || IsTextNode(parent))
    1:   {
    1:     // we want to look at the parent and ancestors
    1:     nodeToExamine = parent;
    1:   }
    1:   else
    1:   {
    1:     // otherwise we want to look at the first editable node after
    1:     // {parent,offset} and it's ancestors for divs with alignment on them
    1:     nodeToExamine = GetChildAt(parent, offset);
    1:     //GetNextNode(parent, offset, PR_TRUE, address_of(nodeToExamine));
    1:   }
    1:   
    1:   if (!nodeToExamine) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // is the node to examine a block ?
    1:   PRBool isBlock;
    1:   res = NodeIsBlockStatic(nodeToExamine, &isBlock);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMNode> tmp;
    1: 
    1:   if (aBlockLevel) {
    1:     // we are querying the block background (and not the text background), let's
    1:     // climb to the block container
    1:     nsCOMPtr<nsIDOMNode> blockParent = nodeToExamine;
    1:     if (!isBlock) {
    1:       blockParent = GetBlockNodeParent(nodeToExamine);
25181:       if (!blockParent)
25181:         return NS_OK;
    1:     }
    1: 
    1:     // Make sure to not walk off onto the Document node
    1:     nsCOMPtr<nsIDOMElement> element;
    1:     do {
    1:       // retrieve the computed style of background-color for blockParent
    1:       mHTMLCSSUtils->GetComputedProperty(blockParent,
    1:                                          nsEditProperty::cssBackgroundColor,
    1:                                          aOutColor);
    1:       tmp.swap(blockParent);
    1:       res = tmp->GetParentNode(getter_AddRefs(blockParent));
    1:       element = do_QueryInterface(blockParent);
    1:       // look at parent if the queried color is transparent and if the node to
    1:       // examine is not the root of the document
    1:     } while (aOutColor.EqualsLiteral("transparent") && element);
    1:     if (aOutColor.EqualsLiteral("transparent")) {
    1:       // we have hit the root of the document and the color is still transparent !
    1:       // Grumble... Let's look at the default background color because that's the
    1:       // color we are looking for
    1:       mHTMLCSSUtils->GetDefaultBackgroundColor(aOutColor);
    1:     }
    1:   }
    1:   else {
    1:     // no, we are querying the text background for the Text Highlight button
    1:     if (IsTextNode(nodeToExamine)) {
    1:       // if the node of interest is a text node, let's climb a level
    1:       res = nodeToExamine->GetParentNode(getter_AddRefs(parent));
    1:       if (NS_FAILED(res)) return res;
    1:       nodeToExamine = parent;
    1:     }
    1:     do {
    1:       // is the node to examine a block ?
    1:       res = NodeIsBlockStatic(nodeToExamine, &isBlock);
    1:       if (NS_FAILED(res)) return res;
    1:       if (isBlock) {
    1:         // yes it is a block; in that case, the text background color is transparent
    1:         aOutColor.AssignLiteral("transparent");
    1:         break;
    1:       }
    1:       else {
    1:         // no, it's not; let's retrieve the computed style of background-color for the
    1:         // node to examine
    1:         mHTMLCSSUtils->GetComputedProperty(nodeToExamine, nsEditProperty::cssBackgroundColor,
    1:                             aOutColor);
    1:         if (!aOutColor.EqualsLiteral("transparent")) {
    1:           break;
    1:         }
    1:       }
    1:       tmp.swap(nodeToExamine);
    1:       res = tmp->GetParentNode(getter_AddRefs(nodeToExamine));
    1:       if (NS_FAILED(res)) return res;
    1:     } while ( aOutColor.EqualsLiteral("transparent") && nodeToExamine );
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::GetHTMLBackgroundColorState(PRBool *aMixed, nsAString &aOutColor)
    1: {
    1:   //TODO: We don't handle "mixed" correctly!
    1:   if (!aMixed) return NS_ERROR_NULL_POINTER;
    1:   *aMixed = PR_FALSE;
    1:   aOutColor.Truncate();
    1:   
    1:   nsCOMPtr<nsIDOMElement> element;
    1:   PRInt32 selectedCount;
    1:   nsAutoString tagName;
    1:   nsresult res = GetSelectedOrParentTableElement(tagName,
    1:                                                  &selectedCount,
    1:                                                  getter_AddRefs(element));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   NS_NAMED_LITERAL_STRING(styleName, "bgcolor"); 
    1: 
    1:   while (element)
    1:   {
    1:     // We are in a cell or selected table
    1:     res = element->GetAttribute(styleName, aOutColor);
    1:     if (NS_FAILED(res)) return res;
    1: 
    1:     // Done if we have a color explicitly set
    1:     if (!aOutColor.IsEmpty())
    1:       return NS_OK;
    1: 
    1:     // Once we hit the body, we're done
    1:     if(nsTextEditUtils::IsBody(element)) return NS_OK;
    1: 
    1:     // No color is set, but we need to report visible color inherited 
    1:     // from nested cells/tables, so search up parent chain
    1:     nsCOMPtr<nsIDOMNode> parentNode;
    1:     res = element->GetParentNode(getter_AddRefs(parentNode));
    1:     if (NS_FAILED(res)) return res;
    1:     element = do_QueryInterface(parentNode);
    1:   }
    1: 
    1:   // If no table or cell found, get page body
    1:   element = GetRoot();
    1:   if (!element) return NS_ERROR_NULL_POINTER;
    1: 
    1:   return element->GetAttribute(styleName, aOutColor);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::GetListState(PRBool *aMixed, PRBool *aOL, PRBool *aUL, PRBool *aDL)
    1: {
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1:   if (!aMixed || !aOL || !aUL || !aDL) return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsIHTMLEditRules> htmlRules = do_QueryInterface(mRules);
    1:   if (!htmlRules) return NS_ERROR_FAILURE;
    1:   
    1:   return htmlRules->GetListState(aMixed, aOL, aUL, aDL);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::GetListItemState(PRBool *aMixed, PRBool *aLI, PRBool *aDT, PRBool *aDD)
    1: {
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1:   if (!aMixed || !aLI || !aDT || !aDD) return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsIHTMLEditRules> htmlRules = do_QueryInterface(mRules);
    1:   if (!htmlRules) return NS_ERROR_FAILURE;
    1:   
    1:   return htmlRules->GetListItemState(aMixed, aLI, aDT, aDD);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetAlignment(PRBool *aMixed, nsIHTMLEditor::EAlignment *aAlign)
    1: {
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1:   if (!aMixed || !aAlign) return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsIHTMLEditRules> htmlRules = do_QueryInterface(mRules);
    1:   if (!htmlRules) return NS_ERROR_FAILURE;
    1:   
    1:   return htmlRules->GetAlignment(aMixed, aAlign);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::GetIndentState(PRBool *aCanIndent, PRBool *aCanOutdent)
    1: {
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1:   if (!aCanIndent || !aCanOutdent) return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsIHTMLEditRules> htmlRules = do_QueryInterface(mRules);
    1:   if (!htmlRules) return NS_ERROR_FAILURE;
    1:   
    1:   return htmlRules->GetIndentState(aCanIndent, aCanOutdent);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::MakeOrChangeList(const nsAString& aListType, PRBool entireList, const nsAString& aBulletType)
    1: {
    1:   nsresult res;
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   PRBool cancel, handled;
    1: 
    1:   nsAutoEditBatch beginBatching(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpMakeList, nsIEditor::eNext);
    1:   
    1:   // pre-process
    1:   res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsTextRulesInfo ruleInfo(nsTextEditRules::kMakeList);
    1:   ruleInfo.blockType = &aListType;
    1:   ruleInfo.entireList = entireList;
    1:   ruleInfo.bulletType = &aBulletType;
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
    1:   if (cancel || (NS_FAILED(res))) return res;
    1: 
    1:   if (!handled)
    1:   {
    1:     // Find out if the selection is collapsed:
    1:     PRBool isCollapsed;
    1:     res = selection->GetIsCollapsed(&isCollapsed);
    1:     if (NS_FAILED(res)) return res;
    1: 
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     PRInt32 offset;
    1:   
    1:     res = GetStartNodeAndOffset(selection, address_of(node), &offset);
    1:     if (!node) res = NS_ERROR_FAILURE;
    1:     if (NS_FAILED(res)) return res;
    1:   
    1:     if (isCollapsed)
    1:     {
    1:       // have to find a place to put the list
    1:       nsCOMPtr<nsIDOMNode> parent = node;
    1:       nsCOMPtr<nsIDOMNode> topChild = node;
    1:       nsCOMPtr<nsIDOMNode> tmp;
    1:     
    1:       while ( !CanContainTag(parent, aListType))
    1:       {
    1:         parent->GetParentNode(getter_AddRefs(tmp));
    1:         if (!tmp) return NS_ERROR_FAILURE;
    1:         topChild = parent;
    1:         parent = tmp;
    1:       }
    1:     
    1:       if (parent != node)
    1:       {
    1:         // we need to split up to the child of parent
    1:         res = SplitNodeDeep(topChild, node, offset, &offset);
    1:         if (NS_FAILED(res)) return res;
    1:       }
    1: 
    1:       // make a list
    1:       nsCOMPtr<nsIDOMNode> newList;
    1:       res = CreateNode(aListType, parent, offset, getter_AddRefs(newList));
    1:       if (NS_FAILED(res)) return res;
    1:       // make a list item
    1:       nsCOMPtr<nsIDOMNode> newItem;
    1:       res = CreateNode(NS_LITERAL_STRING("li"), newList, 0, getter_AddRefs(newItem));
    1:       if (NS_FAILED(res)) return res;
    1:       res = selection->Collapse(newItem,0);
    1:       if (NS_FAILED(res)) return res;
    1:     }
    1:   }
    1:   
    1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
    1:   return res;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::RemoveList(const nsAString& aListType)
    1: {
    1:   nsresult res;
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   PRBool cancel, handled;
    1: 
    1:   nsAutoEditBatch beginBatching(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpRemoveList, nsIEditor::eNext);
    1:   
    1:   // pre-process
    1:   res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsTextRulesInfo ruleInfo(nsTextEditRules::kRemoveList);
    1:   if (aListType.LowerCaseEqualsLiteral("ol"))
    1:     ruleInfo.bOrdered = PR_TRUE;
    1:   else  ruleInfo.bOrdered = PR_FALSE;
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
    1:   if (cancel || (NS_FAILED(res))) return res;
    1: 
    1:   // no default behavior for this yet.  what would it mean?
    1: 
    1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::MakeDefinitionItem(const nsAString& aItemType)
    1: {
    1:   nsresult res;
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   PRBool cancel, handled;
    1: 
    1:   nsAutoEditBatch beginBatching(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpMakeDefListItem, nsIEditor::eNext);
    1:   
    1:   // pre-process
    1:   res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1:   nsTextRulesInfo ruleInfo(nsTextEditRules::kMakeDefListItem);
    1:   ruleInfo.blockType = &aItemType;
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
    1:   if (cancel || (NS_FAILED(res))) return res;
    1: 
    1:   if (!handled)
    1:   {
    1:     // todo: no default for now.  we count on rules to handle it.
    1:   }
    1: 
    1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::InsertBasicBlock(const nsAString& aBlockType)
    1: {
    1:   nsresult res;
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   PRBool cancel, handled;
    1: 
    1:   nsAutoEditBatch beginBatching(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpMakeBasicBlock, nsIEditor::eNext);
    1:   
    1:   // pre-process
    1:   res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1:   nsTextRulesInfo ruleInfo(nsTextEditRules::kMakeBasicBlock);
    1:   ruleInfo.blockType = &aBlockType;
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
    1:   if (cancel || (NS_FAILED(res))) return res;
    1: 
    1:   if (!handled)
    1:   {
    1:     // Find out if the selection is collapsed:
    1:     PRBool isCollapsed;
    1:     res = selection->GetIsCollapsed(&isCollapsed);
    1:     if (NS_FAILED(res)) return res;
    1: 
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     PRInt32 offset;
    1:   
    1:     res = GetStartNodeAndOffset(selection, address_of(node), &offset);
    1:     if (!node) res = NS_ERROR_FAILURE;
    1:     if (NS_FAILED(res)) return res;
    1:   
    1:     if (isCollapsed)
    1:     {
    1:       // have to find a place to put the block
    1:       nsCOMPtr<nsIDOMNode> parent = node;
    1:       nsCOMPtr<nsIDOMNode> topChild = node;
    1:       nsCOMPtr<nsIDOMNode> tmp;
    1:     
    1:       while ( !CanContainTag(parent, aBlockType))
    1:       {
    1:         parent->GetParentNode(getter_AddRefs(tmp));
    1:         if (!tmp) return NS_ERROR_FAILURE;
    1:         topChild = parent;
    1:         parent = tmp;
    1:       }
    1:     
    1:       if (parent != node)
    1:       {
    1:         // we need to split up to the child of parent
    1:         res = SplitNodeDeep(topChild, node, offset, &offset);
    1:         if (NS_FAILED(res)) return res;
    1:       }
    1: 
    1:       // make a block
    1:       nsCOMPtr<nsIDOMNode> newBlock;
    1:       res = CreateNode(aBlockType, parent, offset, getter_AddRefs(newBlock));
    1:       if (NS_FAILED(res)) return res;
    1:     
    1:       // reposition selection to inside the block
    1:       res = selection->Collapse(newBlock,0);
    1:       if (NS_FAILED(res)) return res;  
    1:     }
    1:   }
    1: 
    1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::Indent(const nsAString& aIndent)
    1: {
    1:   nsresult res;
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1: 
    1:   PRBool cancel, handled;
    1:   PRInt32 theAction = nsTextEditRules::kIndent;
    1:   PRInt32 opID = kOpIndent;
    1:   if (aIndent.LowerCaseEqualsLiteral("outdent"))
    1:   {
    1:     theAction = nsTextEditRules::kOutdent;
    1:     opID = kOpOutdent;
    1:   }
    1:   nsAutoEditBatch beginBatching(this);
    1:   nsAutoRules beginRulesSniffing(this, opID, nsIEditor::eNext);
    1:   
    1:   // pre-process
    1:   nsCOMPtr<nsISelection> selection;
    1:   res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsTextRulesInfo ruleInfo(theAction);
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
    1:   if (cancel || (NS_FAILED(res))) return res;
    1:   
    1:   if (!handled)
    1:   {
    1:     // Do default - insert a blockquote node if selection collapsed
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     PRInt32 offset;
    1:     PRBool isCollapsed;
    1:     res = selection->GetIsCollapsed(&isCollapsed);
    1:     if (NS_FAILED(res)) return res;
    1: 
    1:     res = GetStartNodeAndOffset(selection, address_of(node), &offset);
    1:     if (!node) res = NS_ERROR_FAILURE;
    1:     if (NS_FAILED(res)) return res;
    1:   
    1:     if (aIndent.EqualsLiteral("indent"))
    1:     {
    1:       if (isCollapsed)
    1:       {
    1:         // have to find a place to put the blockquote
    1:         nsCOMPtr<nsIDOMNode> parent = node;
    1:         nsCOMPtr<nsIDOMNode> topChild = node;
    1:         nsCOMPtr<nsIDOMNode> tmp;
    1:         NS_NAMED_LITERAL_STRING(bq, "blockquote");
    1:         while ( !CanContainTag(parent, bq))
    1:         {
    1:           parent->GetParentNode(getter_AddRefs(tmp));
    1:           if (!tmp) return NS_ERROR_FAILURE;
    1:           topChild = parent;
    1:           parent = tmp;
    1:         }
    1:     
    1:         if (parent != node)
    1:         {
    1:           // we need to split up to the child of parent
    1:           res = SplitNodeDeep(topChild, node, offset, &offset);
    1:           if (NS_FAILED(res)) return res;
    1:         }
    1: 
    1:         // make a blockquote
    1:         nsCOMPtr<nsIDOMNode> newBQ;
    1:         res = CreateNode(bq, parent, offset, getter_AddRefs(newBQ));
    1:         if (NS_FAILED(res)) return res;
    1:         // put a space in it so layout will draw the list item
    1:         res = selection->Collapse(newBQ,0);
    1:         if (NS_FAILED(res)) return res;
    1:         res = InsertText(NS_LITERAL_STRING(" "));
    1:         if (NS_FAILED(res)) return res;
    1:         // reposition selection to before the space character
    1:         res = GetStartNodeAndOffset(selection, address_of(node), &offset);
    1:         if (NS_FAILED(res)) return res;
    1:         res = selection->Collapse(node,0);
    1:         if (NS_FAILED(res)) return res;
    1:       }
    1:     }
    1:   }
    1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
    1:   return res;
    1: }
    1: 
    1: //TODO: IMPLEMENT ALIGNMENT!
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::Align(const nsAString& aAlignType)
    1: {
    1:   nsAutoEditBatch beginBatching(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpAlign, nsIEditor::eNext);
    1: 
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   PRBool cancel, handled;
    1:   
    1:   // Find out if the selection is collapsed:
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1:   nsTextRulesInfo ruleInfo(nsTextEditRules::kAlign);
    1:   ruleInfo.alignType = &aAlignType;
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
    1:   if (cancel || NS_FAILED(res))
    1:     return res;
    1:   
    1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetElementOrParentByTagName(const nsAString& aTagName, nsIDOMNode *aNode, nsIDOMElement** aReturn)
    1: {
    1:   if (aTagName.IsEmpty() || !aReturn )
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> currentNode;
    1: 
    1:   if (aNode)
    1:     currentNode = aNode;
    1:   else
    1:   {
    1:     // If no node supplied, get it from anchor node of current selection
    1:     nsCOMPtr<nsISelection>selection;
    1:     res = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!selection) return NS_ERROR_NULL_POINTER;
    1: 
    1:     nsCOMPtr<nsIDOMNode> anchorNode;
    1:     res = selection->GetAnchorNode(getter_AddRefs(anchorNode));
    1:     if(NS_FAILED(res)) return res;
    1:     if (!anchorNode)  return NS_ERROR_FAILURE;
    1: 
    1:     // Try to get the actual selected node
    1:     PRBool hasChildren = PR_FALSE;
    1:     anchorNode->HasChildNodes(&hasChildren);
    1:     if (hasChildren)
    1:     {
    1:       PRInt32 offset;
    1:       res = selection->GetAnchorOffset(&offset);
    1:       if(NS_FAILED(res)) return res;
    1:       currentNode = nsEditor::GetChildAt(anchorNode, offset);
    1:     }
    1:     // anchor node is probably a text node - just use that
    1:     if (!currentNode)
    1:       currentNode = anchorNode;
    1:   }
    1:    
    1:   nsAutoString TagName(aTagName);
    1:   ToLowerCase(TagName);
    1:   PRBool getLink = IsLinkTag(TagName);
    1:   PRBool getNamedAnchor = IsNamedAnchorTag(TagName);
    1:   if ( getLink || getNamedAnchor)
    1:   {
    1:     TagName.AssignLiteral("a");  
    1:   }
    1:   PRBool findTableCell = TagName.EqualsLiteral("td");
    1:   PRBool findList = TagName.EqualsLiteral("list");
    1: 
    1:   // default is null - no element found
    1:   *aReturn = nsnull;
    1:   
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   PRBool bNodeFound = PR_FALSE;
    1: 
    1:   while (PR_TRUE)
    1:   {
    1:     nsAutoString currentTagName; 
    1:     // Test if we have a link (an anchor with href set)
    1:     if ( (getLink && nsHTMLEditUtils::IsLink(currentNode)) ||
    1:          (getNamedAnchor && nsHTMLEditUtils::IsNamedAnchor(currentNode)) )
    1:     {
    1:       bNodeFound = PR_TRUE;
    1:       break;
    1:     } else {
    1:       if (findList)
    1:       {
    1:         // Match "ol", "ul", or "dl" for lists
    1:         if (nsHTMLEditUtils::IsList(currentNode))
    1:           goto NODE_FOUND;
    1: 
    1:       } else if (findTableCell)
    1:       {
    1:         // Table cells are another special case:
    1:         // Match either "td" or "th" for them
    1:         if (nsHTMLEditUtils::IsTableCell(currentNode))
    1:           goto NODE_FOUND;
    1: 
    1:       } else {
    1:         currentNode->GetNodeName(currentTagName);
    1:         if (currentTagName.Equals(TagName, nsCaseInsensitiveStringComparator()))
    1:         {
    1: NODE_FOUND:
    1:           bNodeFound = PR_TRUE;
    1:           break;
    1:         } 
    1:       }
    1:     }
    1:     // Search up the parent chain
    1:     // We should never fail because of root test below, but lets be safe
    1:     // XXX: ERROR_HANDLING error return code lost
    1:     if (NS_FAILED(currentNode->GetParentNode(getter_AddRefs(parent))) || !parent)
    1:       break;
    1: 
    1:     // Stop searching if parent is a body tag
    1:     nsAutoString parentTagName;
    1:     parent->GetNodeName(parentTagName);
    1:     // Note: Originally used IsRoot to stop at table cells,
    1:     //  but that's too messy when you are trying to find the parent table
    1:     //PRBool isRoot;
    1:     //if (NS_FAILED(IsRootTag(parentTagName, isRoot)) || isRoot)
    1:     if(parentTagName.LowerCaseEqualsLiteral("body"))
    1:       break;
    1: 
    1:     currentNode = parent;
    1:   }
    1:   if (bNodeFound)
    1:   {
    1:     nsCOMPtr<nsIDOMElement> currentElement = do_QueryInterface(currentNode);
    1:     if (currentElement)
    1:     {
    1:       *aReturn = currentElement;
    1:       // Getters must addref
    1:       NS_ADDREF(*aReturn);
    1:     }
    1:   }
    1:   else res = NS_EDITOR_ELEMENT_NOT_FOUND;
    1: 
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetSelectedElement(const nsAString& aTagName, nsIDOMElement** aReturn)
    1: {
    1:   if (!aReturn )
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   // default is null - no element found
    1:   *aReturn = nsnull;
    1:   
    1:   // First look for a single element in selection
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1: 
    1:   PRBool bNodeFound = PR_FALSE;
    1:   res=NS_ERROR_NOT_INITIALIZED;
    1:   PRBool isCollapsed;
    1:   selection->GetIsCollapsed(&isCollapsed);
    1: 
    1:   nsAutoString domTagName;
    1:   nsAutoString TagName(aTagName);
    1:   ToLowerCase(TagName);
    1:   // Empty string indicates we should match any element tag
    1:   PRBool anyTag = (TagName.IsEmpty());
    1:   PRBool isLinkTag = IsLinkTag(TagName);
    1:   PRBool isNamedAnchorTag = IsNamedAnchorTag(TagName);
    1:   
    1:   nsCOMPtr<nsIDOMElement> selectedElement;
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   res = selection->GetRangeAt(0, getter_AddRefs(range));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMNode> startParent;
    1:   PRInt32 startOffset, endOffset;
    1:   res = range->GetStartContainer(getter_AddRefs(startParent));
    1:   if (NS_FAILED(res)) return res;
    1:   res = range->GetStartOffset(&startOffset);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMNode> endParent;
    1:   res = range->GetEndContainer(getter_AddRefs(endParent));
    1:   if (NS_FAILED(res)) return res;
    1:   res = range->GetEndOffset(&endOffset);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   // Optimization for a single selected element
    1:   if (startParent && startParent == endParent && (endOffset-startOffset) == 1)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> selectedNode = GetChildAt(startParent, startOffset);
    1:     if (NS_FAILED(res)) return NS_OK;
    1:     if (selectedNode)
    1:     {
    1:       selectedNode->GetNodeName(domTagName);
    1:       ToLowerCase(domTagName);
    1: 
    1:       // Test for appropriate node type requested
    1:       if (anyTag || (TagName == domTagName) ||
    1:           (isLinkTag && nsHTMLEditUtils::IsLink(selectedNode)) ||
    1:           (isNamedAnchorTag && nsHTMLEditUtils::IsNamedAnchor(selectedNode)))
    1:       {
    1:         bNodeFound = PR_TRUE;
    1:         selectedElement = do_QueryInterface(selectedNode);
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (!bNodeFound)
    1:   {
    1:     if (isLinkTag)
    1:     {
    1:       // Link tag is a special case - we return the anchor node
    1:       //  found for any selection that is totally within a link,
    1:       //  included a collapsed selection (just a caret in a link)
    1:       nsCOMPtr<nsIDOMNode> anchorNode;
    1:       res = selection->GetAnchorNode(getter_AddRefs(anchorNode));
    1:       if (NS_FAILED(res)) return res;
    1:       PRInt32 anchorOffset = -1;
    1:       if (anchorNode)
    1:         selection->GetAnchorOffset(&anchorOffset);
    1:     
    1:       nsCOMPtr<nsIDOMNode> focusNode;
    1:       res = selection->GetFocusNode(getter_AddRefs(focusNode));
    1:       if (NS_FAILED(res)) return res;
    1:       PRInt32 focusOffset = -1;
    1:       if (focusNode)
    1:         selection->GetFocusOffset(&focusOffset);
    1: 
    1:       // Link node must be the same for both ends of selection
    1:       if (NS_SUCCEEDED(res) && anchorNode)
    1:       {
    1:   #ifdef DEBUG_cmanske
    1:         {
    1:         nsAutoString name;
    1:         anchorNode->GetNodeName(name);
    1:         printf("GetSelectedElement: Anchor node of selection: ");
    1:         wprintf(name.get());
    1:         printf(" Offset: %d\n", anchorOffset);
    1:         focusNode->GetNodeName(name);
    1:         printf("Focus node of selection: ");
    1:         wprintf(name.get());
    1:         printf(" Offset: %d\n", focusOffset);
    1:         }
    1:   #endif
    1:         nsCOMPtr<nsIDOMElement> parentLinkOfAnchor;
    1:         res = GetElementOrParentByTagName(NS_LITERAL_STRING("href"), anchorNode, getter_AddRefs(parentLinkOfAnchor));
    1:         // XXX: ERROR_HANDLING  can parentLinkOfAnchor be null?
    1:         if (NS_SUCCEEDED(res) && parentLinkOfAnchor)
    1:         {
    1:           if (isCollapsed)
    1:           {
    1:             // We have just a caret in the link
    1:             bNodeFound = PR_TRUE;
    1:           } else if(focusNode) 
    1:           {  // Link node must be the same for both ends of selection
    1:             nsCOMPtr<nsIDOMElement> parentLinkOfFocus;
    1:             res = GetElementOrParentByTagName(NS_LITERAL_STRING("href"), focusNode, getter_AddRefs(parentLinkOfFocus));
    1:             if (NS_SUCCEEDED(res) && parentLinkOfFocus == parentLinkOfAnchor)
    1:               bNodeFound = PR_TRUE;
    1:           }
    1:       
    1:           // We found a link node parent
    1:           if (bNodeFound) {
    1:             // GetElementOrParentByTagName addref'd this, so we don't need to do it here
    1:             *aReturn = parentLinkOfAnchor;
    1:             NS_IF_ADDREF(*aReturn);
    1:             return NS_OK;
    1:           }
    1:         }
    1:         else if (anchorOffset >= 0)  // Check if link node is the only thing selected
    1:         {
    1:           nsCOMPtr<nsIDOMNode> anchorChild;
    1:           anchorChild = GetChildAt(anchorNode,anchorOffset);
    1:           if (anchorChild && nsHTMLEditUtils::IsLink(anchorChild) && 
    1:               (anchorNode == focusNode) && focusOffset == (anchorOffset+1))
    1:           {
    1:             selectedElement = do_QueryInterface(anchorChild);
    1:             bNodeFound = PR_TRUE;
    1:           }
    1:         }
    1:       }
    1:     } 
    1: 
    1:     if (!isCollapsed)   // Don't bother to examine selection if it is collapsed
    1:     {
    1:       nsCOMPtr<nsIEnumerator> enumerator;
    1:       res = selPriv->GetEnumerator(getter_AddRefs(enumerator));
    1:       if (NS_SUCCEEDED(res))
    1:       {
    1:         if(!enumerator)
    1:           return NS_ERROR_NULL_POINTER;
    1: 
    1:         enumerator->First(); 
    1:         nsCOMPtr<nsISupports> currentItem;
    1:         res = enumerator->CurrentItem(getter_AddRefs(currentItem));
    1:         if ((NS_SUCCEEDED(res)) && currentItem)
    1:         {
    1:           nsCOMPtr<nsIDOMRange> currange( do_QueryInterface(currentItem) );
    1:           nsCOMPtr<nsIContentIterator> iter =
    1:             do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &res);
    1:           if (NS_FAILED(res)) return res;
    1: 
    1:           iter->Init(currange);
    1:           // loop through the content iterator for each content node
    1:           while (!iter->IsDone())
    1:           {
    1:             // Query interface to cast nsIContent to nsIDOMNode
    1:             //  then get tagType to compare to  aTagName
    1:             // Clone node of each desired type and append it to the aDomFrag
    1:             selectedElement = do_QueryInterface(iter->GetCurrentNode());
    1:             if (selectedElement)
    1:             {
    1:               // If we already found a node, then we have another element,
    1:               //  thus there's not just one element selected
    1:               if (bNodeFound)
    1:               {
    1:                 bNodeFound = PR_FALSE;
    1:                 break;
    1:               }
    1: 
    1:               selectedElement->GetNodeName(domTagName);
    1:               ToLowerCase(domTagName);
    1: 
    1:               if (anyTag)
    1:               {
    1:                 // Get name of first selected element
    1:                 selectedElement->GetTagName(TagName);
    1:                 ToLowerCase(TagName);
    1:                 anyTag = PR_FALSE;
    1:               }
    1: 
    1:               // The "A" tag is a pain,
    1:               //  used for both link(href is set) and "Named Anchor"
    1:               nsCOMPtr<nsIDOMNode> selectedNode = do_QueryInterface(selectedElement);
    1:               if ( (isLinkTag && nsHTMLEditUtils::IsLink(selectedNode)) ||
    1:                    (isNamedAnchorTag && nsHTMLEditUtils::IsNamedAnchor(selectedNode)) )
    1:               {
    1:                 bNodeFound = PR_TRUE;
    1:               } else if (TagName == domTagName) { // All other tag names are handled here
    1:                 bNodeFound = PR_TRUE;
    1:               }
    1:               if (!bNodeFound)
    1:               {
    1:                 // Check if node we have is really part of the selection???
    1:                 break;
    1:               }
    1:             }
    1:             iter->Next();
    1:           }
    1:         } else {
    1:           // Should never get here?
    1:           isCollapsed = PR_TRUE;
    1:           printf("isCollapsed was FALSE, but no elements found in selection\n");
    1:         }
    1:       } else {
    1:         printf("Could not create enumerator for GetSelectionProperties\n");
    1:       }
    1:     }
    1:   }
    1:   if (bNodeFound)
    1:   {
    1:     
    1:     *aReturn = selectedElement;
    1:     if (selectedElement)
    1:     {  
    1:       // Getters must addref
    1:       NS_ADDREF(*aReturn);
    1:     }
    1:   } 
    1:   else res = NS_EDITOR_ELEMENT_NOT_FOUND;
    1: 
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::CreateElementWithDefaults(const nsAString& aTagName, nsIDOMElement** aReturn)
    1: {
    1:   nsresult res=NS_ERROR_NOT_INITIALIZED;
    1:   if (aReturn)
    1:     *aReturn = nsnull;
    1: 
    1:   if (aTagName.IsEmpty() || !aReturn)
    1: //  if (!aTagName || !aReturn)
    1:     return NS_ERROR_NULL_POINTER;
    1:     
    1:   nsAutoString TagName(aTagName);
    1:   ToLowerCase(TagName);
    1:   nsAutoString realTagName;
    1: 
    1:   if (IsLinkTag(TagName) || IsNamedAnchorTag(TagName))
    1:   {
    1:     realTagName.AssignLiteral("a");
    1:   } else {
    1:     realTagName = TagName;
    1:   }
    1:   //We don't use editor's CreateElement because we don't want to 
    1:   //  go through the transaction system
    1: 
    1:   nsCOMPtr<nsIDOMElement>newElement;
    1:   nsCOMPtr<nsIContent> newContent;
    1:   nsCOMPtr<nsIDOMDocument> doc = do_QueryReferent(mDocWeak);
    1:   if (!doc) return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   //new call to use instead to get proper HTML element, bug# 39919
    1:   res = CreateHTMLContent(realTagName, getter_AddRefs(newContent));
    1:   newElement = do_QueryInterface(newContent);
    1:   if (NS_FAILED(res) || !newElement)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Mark the new element dirty, so it will be formatted
    1:   newElement->SetAttribute(NS_LITERAL_STRING("_moz_dirty"), EmptyString());
    1: 
    1:   // Set default values for new elements
    1:   if (TagName.EqualsLiteral("hr"))
    1:   {
    1:     // Note that we read the user's attributes for these from prefs (in InsertHLine JS)
    1:     res = SetAttributeOrEquivalent(newElement, NS_LITERAL_STRING("width"),
    1:                                    NS_LITERAL_STRING("100%"), PR_TRUE);
    1:     if (NS_FAILED(res)) return res;
    1:     res = SetAttributeOrEquivalent(newElement, NS_LITERAL_STRING("size"),
    1:                                    NS_LITERAL_STRING("2"), PR_TRUE);
    1:   } else if (TagName.EqualsLiteral("table"))
    1:   {
    1:     res = newElement->SetAttribute(NS_LITERAL_STRING("cellpadding"),NS_LITERAL_STRING("2"));
    1:     if (NS_FAILED(res)) return res;
    1:     res = newElement->SetAttribute(NS_LITERAL_STRING("cellspacing"),NS_LITERAL_STRING("2"));
    1:     if (NS_FAILED(res)) return res;
    1:     res = newElement->SetAttribute(NS_LITERAL_STRING("border"),NS_LITERAL_STRING("1"));
    1:   } else if (TagName.EqualsLiteral("td"))
    1:   {
    1:     res = SetAttributeOrEquivalent(newElement, NS_LITERAL_STRING("valign"),
    1:                                    NS_LITERAL_STRING("top"), PR_TRUE);
    1:   }
    1:   // ADD OTHER TAGS HERE
    1: 
    1:   if (NS_SUCCEEDED(res))
    1:   {
    1:     *aReturn = newElement;
    1:     // Getters must addref
    1:     NS_ADDREF(*aReturn);
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::InsertLinkAroundSelection(nsIDOMElement* aAnchorElement)
    1: {
    1:   nsresult res=NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsISelection> selection;
    1: 
    1:   if (!aAnchorElement) return NS_ERROR_NULL_POINTER; 
    1: 
    1: 
    1:   // We must have a real selection
    1:   res = GetSelection(getter_AddRefs(selection));
    1:   if (!selection)
    1:   {
    1:     res = NS_ERROR_NULL_POINTER;
    1:   }
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRBool isCollapsed;
    1:   res = selection->GetIsCollapsed(&isCollapsed);
    1:   if (NS_FAILED(res))
    1:     isCollapsed = PR_TRUE;
    1:   
    1:   if (isCollapsed)
    1:   {
    1:     printf("InsertLinkAroundSelection called but there is no selection!!!\n");     
    1:     res = NS_OK;
    1:   } else {
    1:     // Be sure we were given an anchor element
    1:     nsCOMPtr<nsIDOMHTMLAnchorElement> anchor = do_QueryInterface(aAnchorElement);
    1:     if (anchor)
    1:     {
    1:       nsAutoString href;
    1:       res = anchor->GetHref(href);
    1:       if (NS_FAILED(res)) return res;
    1:       if (!href.IsEmpty())      
    1:       {
    1:         nsAutoEditBatch beginBatching(this);
    1: 
    1:         // Set all attributes found on the supplied anchor element
    1:         nsCOMPtr<nsIDOMNamedNodeMap> attrMap;
    1:         aAnchorElement->GetAttributes(getter_AddRefs(attrMap));
    1:         if (!attrMap)
    1:           return NS_ERROR_FAILURE;
    1: 
    1:         PRUint32 count, i;
    1:         attrMap->GetLength(&count);
    1:         nsAutoString name, value;
    1: 
    1:         for (i = 0; i < count; i++)
    1:         {
    1:           nsCOMPtr<nsIDOMNode> attrNode;
    1:           res = attrMap->Item(i, getter_AddRefs(attrNode));
    1:           if (NS_FAILED(res)) return res;
    1: 
    1:           if (attrNode)
    1:           {
    1:             nsCOMPtr<nsIDOMAttr> attribute = do_QueryInterface(attrNode);
    1:             if (attribute)
    1:             {
    1:               // We must clear the string buffers
    1:               //   because GetName, GetValue appends to previous string!
    1:               name.Truncate();
    1:               value.Truncate();
    1: 
    1:               res = attribute->GetName(name);
    1:               if (NS_FAILED(res)) return res;
    1: 
    1:               res = attribute->GetValue(value);
    1:               if (NS_FAILED(res)) return res;
    1: 
    1:               res = SetInlineProperty(nsEditProperty::a, name, value);
    1:               if (NS_FAILED(res)) return res;
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::SetHTMLBackgroundColor(const nsAString& aColor)
    1: {
    1:   NS_PRECONDITION(mDocWeak, "Missing Editor DOM Document");
    1:   
    1:   // Find a selected or enclosing table element to set background on
    1:   nsCOMPtr<nsIDOMElement> element;
    1:   PRInt32 selectedCount;
    1:   nsAutoString tagName;
    1:   nsresult res = GetSelectedOrParentTableElement(tagName, &selectedCount,
    1:                                                  getter_AddRefs(element));
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   PRBool setColor = !aColor.IsEmpty();
    1: 
    1:   NS_NAMED_LITERAL_STRING(bgcolor, "bgcolor");
    1:   if (element)
    1:   {
    1:     if (selectedCount > 0)
    1:     {
    1:       // Traverse all selected cells
    1:       nsCOMPtr<nsIDOMElement> cell;
    1:       res = GetFirstSelectedCell(nsnull, getter_AddRefs(cell));
    1:       if (NS_SUCCEEDED(res) && cell)
    1:       {
    1:         while(cell)
    1:         {
    1:           if (setColor)
    1:             res = SetAttribute(cell, bgcolor, aColor);
    1:           else
    1:             res = RemoveAttribute(cell, bgcolor);
    1:           if (NS_FAILED(res)) break;
    1: 
    1:           GetNextSelectedCell(nsnull, getter_AddRefs(cell));
    1:         };
    1:         return res;
    1:       }
    1:     }
    1:     // If we failed to find a cell, fall through to use originally-found element
    1:   } else {
    1:     // No table element -- set the background color on the body tag
    1:     element = GetRoot();
    1:     if (!element)       return NS_ERROR_NULL_POINTER;
    1:   }
    1:   // Use the editor method that goes through the transaction system
    1:   if (setColor)
    1:     res = SetAttribute(element, bgcolor, aColor);
    1:   else
    1:     res = RemoveAttribute(element, bgcolor);
    1: 
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::SetBodyAttribute(const nsAString& aAttribute, const nsAString& aValue)
    1: {
    1:   // TODO: Check selection for Cell, Row, Column or table and do color on appropriate level
    1: 
    1:   NS_ASSERTION(mDocWeak, "Missing Editor DOM Document");
    1:   
    1:   // Set the background color attribute on the body tag
    1:   nsIDOMElement *bodyElement = GetRoot();
    1: 
    1:   if (!bodyElement)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Use the editor method that goes through the transaction system
    1:   return SetAttribute(bodyElement, aAttribute, aValue);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetLinkedObjects(nsISupportsArray** aNodeList)
    1: {
    1:   if (!aNodeList)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsresult res;
    1: 
    1:   res = NS_NewISupportsArray(aNodeList);
    1:   if (NS_FAILED(res)) return res;
    1:   if (!*aNodeList) return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsIContentIterator> iter =
    1:        do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &res);
    1:   if (!iter) return NS_ERROR_NULL_POINTER;
    1:   if ((NS_SUCCEEDED(res)))
    1:   {
    1:     nsCOMPtr<nsIDOMDocument> domdoc;
    1:     nsEditor::GetDocument(getter_AddRefs(domdoc));
    1:     if (!domdoc)
    1:       return NS_ERROR_UNEXPECTED;
    1: 
    1:     nsCOMPtr<nsIDocument> doc (do_QueryInterface(domdoc));
    1:     if (!doc)
    1:       return NS_ERROR_UNEXPECTED;
    1: 
    1:     iter->Init(doc->GetRootContent());
    1: 
    1:     // loop through the content iterator for each content node
    1:     while (!iter->IsDone())
    1:     {
    1:       nsCOMPtr<nsIDOMNode> node (do_QueryInterface(iter->GetCurrentNode()));
    1:       if (node)
    1:       {
    1:         // Let nsURIRefObject make the hard decisions:
    1:         nsCOMPtr<nsIURIRefObject> refObject;
    1:         res = NS_NewHTMLURIRefObject(getter_AddRefs(refObject), node);
    1:         if (NS_SUCCEEDED(res))
    1:         {
    1:           nsCOMPtr<nsISupports> isupp (do_QueryInterface(refObject));
    1: 
    1:           (*aNodeList)->AppendElement(isupp);
    1:         }
    1:       }
    1:       iter->Next();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  nsIEditorStyleSheets methods 
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::AddStyleSheet(const nsAString &aURL)
    1: {
    1:   // Enable existing sheet if already loaded.
    1:   if (EnableExistingStyleSheet(aURL))
    1:     return NS_OK;
    1: 
    1:   // Lose the previously-loaded sheet so there's nothing to replace
    1:   // This pattern is different from Override methods because
    1:   //  we must wait to remove mLastStyleSheetURL and add new sheet
    1:   //  at the same time (in StyleSheetLoaded callback) so they are undoable together
    1:   mLastStyleSheetURL.Truncate();
    1:   return ReplaceStyleSheet(aURL);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::ReplaceStyleSheet(const nsAString& aURL)
    1: {
    1:   // Enable existing sheet if already loaded.
    1:   if (EnableExistingStyleSheet(aURL))
    1:   {
    1:     // Disable last sheet if not the same as new one
29614:     if (!mLastStyleSheetURL.IsEmpty() && !mLastStyleSheetURL.Equals(aURL))
    1:         return EnableStyleSheet(mLastStyleSheetURL, PR_FALSE);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsICSSLoader> cssLoader;
    1:   nsresult rv = GetCSSLoader(aURL, getter_AddRefs(cssLoader));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
    1:   if (!ps) return NS_ERROR_NOT_INITIALIZED;
    1:   nsIDocument *document = ps->GetDocument();
    1:   if (!document)     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsIURI> uaURI;
    1:   rv = NS_NewURI(getter_AddRefs(uaURI), aURL);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
27188:   rv = cssLoader->LoadSheet(uaURI, nsnull, EmptyCString(), this);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::RemoveStyleSheet(const nsAString &aURL)
    1: {
    1:   nsCOMPtr<nsICSSStyleSheet> sheet;
    1:   nsresult rv = GetStyleSheetForURL(aURL, getter_AddRefs(sheet));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (!sheet)
    1:     return NS_ERROR_UNEXPECTED;
    1: 
 3030:   nsRefPtr<RemoveStyleSheetTxn> txn;
 3030:   rv = CreateTxnForRemoveStyleSheet(sheet, getter_AddRefs(txn));
    1:   if (!txn) rv = NS_ERROR_NULL_POINTER;
    1:   if (NS_SUCCEEDED(rv))
    1:   {
    1:     rv = DoTransaction(txn);
    1:     if (NS_SUCCEEDED(rv))
    1:       mLastStyleSheetURL.Truncate();        // forget it
    1: 
    1:     // Remove it from our internal list
    1:     rv = RemoveStyleSheetFromList(aURL);
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::AddOverrideStyleSheet(const nsAString& aURL)
    1: {
    1:   // Enable existing sheet if already loaded.
    1:   if (EnableExistingStyleSheet(aURL))
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsICSSLoader> cssLoader;
    1:   nsresult rv = GetCSSLoader(aURL, getter_AddRefs(cssLoader));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIURI> uaURI;
    1:   rv = NS_NewURI(getter_AddRefs(uaURI), aURL);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // We MUST ONLY load synchronous local files (no @import)
    1:   // XXXbz Except this will actually try to load remote files
    1:   // synchronously, of course..
    1:   nsCOMPtr<nsICSSStyleSheet> sheet;
    1:   // Editor override style sheets may want to style Gecko anonymous boxes
26242:   rv = cssLoader->LoadSheetSync(uaURI, PR_TRUE, PR_TRUE, getter_AddRefs(sheet));
    1: 
    1:   // Synchronous loads should ALWAYS return completed
    1:   if (!sheet)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
    1:   if (!ps)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   // Add the override style sheet
    1:   // (This checks if already exists)
    1:   ps->AddOverrideStyleSheet(sheet);
    1: 
    1:   ps->ReconstructStyleData();
    1: 
    1:   // Save as the last-loaded sheet
    1:   mLastOverrideStyleSheetURL = aURL;
    1: 
    1:   //Add URL and style sheet to our lists
    1:   return AddNewStyleSheetToList(aURL, sheet);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::ReplaceOverrideStyleSheet(const nsAString& aURL)
    1: {
    1:   // Enable existing sheet if already loaded.
    1:   if (EnableExistingStyleSheet(aURL))
    1:   {
    1:     // Disable last sheet if not the same as new one
    1:     if (!mLastOverrideStyleSheetURL.IsEmpty() && !mLastOverrideStyleSheetURL.Equals(aURL))
    1:       return EnableStyleSheet(mLastOverrideStyleSheetURL, PR_FALSE);
    1: 
    1:     return NS_OK;
    1:   }
    1:   // Remove the previous sheet
    1:   if (!mLastOverrideStyleSheetURL.IsEmpty())
    1:     RemoveOverrideStyleSheet(mLastOverrideStyleSheetURL);
    1: 
    1:   return AddOverrideStyleSheet(aURL);
    1: }
    1: 
    1: // Do NOT use transaction system for override style sheets
    1: NS_IMETHODIMP
    1: nsHTMLEditor::RemoveOverrideStyleSheet(const nsAString &aURL)
    1: {
    1:   nsCOMPtr<nsICSSStyleSheet> sheet;
    1:   GetStyleSheetForURL(aURL, getter_AddRefs(sheet));
    1: 
    1:   // Make sure we remove the stylesheet from our internal list in all
    1:   // cases.
    1:   nsresult rv = RemoveStyleSheetFromList(aURL);
    1: 
    1:   if (!sheet)
    1:     return NS_OK; /// Don't fail if sheet not found
    1: 
    1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
    1:   if (!ps) return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   ps->RemoveOverrideStyleSheet(sheet);
    1:   ps->ReconstructStyleData();
    1: 
    1:   // Remove it from our internal list
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::EnableStyleSheet(const nsAString &aURL, PRBool aEnable)
    1: {
    1:   nsCOMPtr<nsICSSStyleSheet> sheet;
    1:   nsresult rv = GetStyleSheetForURL(aURL, getter_AddRefs(sheet));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (!sheet)
    1:     return NS_OK; // Don't fail if sheet not found
    1: 
    1:   nsCOMPtr<nsIDOMStyleSheet> domSheet(do_QueryInterface(sheet));
    1:   NS_ASSERTION(domSheet, "Sheet not implementing nsIDOMStyleSheet!");
    1: 
25180:   // Ensure the style sheet is owned by our document.
32927:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
25180:   rv = sheet->SetOwningDocument(doc);
25180:   NS_ENSURE_SUCCESS(rv, rv);
25180:   
    1:   return domSheet->SetDisabled(!aEnable);
    1: }
    1: 
    1: PRBool
    1: nsHTMLEditor::EnableExistingStyleSheet(const nsAString &aURL)
    1: {
    1:   nsCOMPtr<nsICSSStyleSheet> sheet;
    1:   nsresult rv = GetStyleSheetForURL(aURL, getter_AddRefs(sheet));
26307:   if (NS_FAILED(rv))
26307:     return PR_FALSE;
    1: 
    1:   // Enable sheet if already loaded.
    1:   if (sheet)
    1:   {
25180:     // Ensure the style sheet is owned by our document.
32927:     nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
25180:     rv = sheet->SetOwningDocument(doc);
26307:     if (NS_FAILED(rv))
26307:       return PR_FALSE;
25180: 
    1:     nsCOMPtr<nsIDOMStyleSheet> domSheet(do_QueryInterface(sheet));
    1:     NS_ASSERTION(domSheet, "Sheet not implementing nsIDOMStyleSheet!");
    1:     
    1:     domSheet->SetDisabled(PR_FALSE);
    1:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::AddNewStyleSheetToList(const nsAString &aURL,
    1:                                      nsICSSStyleSheet *aStyleSheet)
    1: {
    1:   PRInt32 countSS = mStyleSheets.Count();
23904:   PRUint32 countU = mStyleSheetURLs.Length();
    1: 
    1:   if (countU < 0 || countSS != countU)
    1:     return NS_ERROR_UNEXPECTED;
    1: 
23904:   if (!mStyleSheetURLs.AppendElement(aURL))
    1:     return NS_ERROR_UNEXPECTED;
    1: 
    1:   return mStyleSheets.AppendObject(aStyleSheet) ? NS_OK : NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::RemoveStyleSheetFromList(const nsAString &aURL)
    1: {
    1:   // is it already in the list?
24835:   PRUint32 foundIndex;
    1:   foundIndex = mStyleSheetURLs.IndexOf(aURL);
24835:   if (foundIndex == mStyleSheetURLs.NoIndex)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Attempt both removals; if one fails there's not much we can do.
    1:   nsresult rv = NS_OK;
    1:   if (!mStyleSheets.RemoveObjectAt(foundIndex))
    1:     rv = NS_ERROR_FAILURE;
23904:   mStyleSheetURLs.RemoveElementAt(foundIndex);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetStyleSheetForURL(const nsAString &aURL,
    1:                                   nsICSSStyleSheet **aStyleSheet)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aStyleSheet);
    1:   *aStyleSheet = 0;
    1: 
    1:   // is it already in the list?
24835:   PRUint32 foundIndex;
    1:   foundIndex = mStyleSheetURLs.IndexOf(aURL);
24835:   if (foundIndex == mStyleSheetURLs.NoIndex)
    1:     return NS_OK; //No sheet -- don't fail!
    1: 
    1:   *aStyleSheet = mStyleSheets[foundIndex];
    1:   if (!*aStyleSheet)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   NS_ADDREF(*aStyleSheet);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetURLForStyleSheet(nsICSSStyleSheet *aStyleSheet,
    1:                                   nsAString &aURL)
    1: {
    1:   // is it already in the list?
    1:   PRInt32 foundIndex = mStyleSheets.IndexOf(aStyleSheet);
    1: 
    1:   // Don't fail if we don't find it in our list
24835:   // Note: mStyleSheets is nsCOMArray, so its IndexOf() method
24835:   // returns -1 on failure.
    1:   if (foundIndex == -1)
    1:     return NS_OK;
    1: 
    1:   // Found it in the list!
23904:   aURL = mStyleSheetURLs[foundIndex];
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::GetCSSLoader(const nsAString& aURL, nsICSSLoader** aCSSLoader)
    1: {
    1:   if (!aCSSLoader)
    1:     return NS_ERROR_NULL_POINTER;
    1:   *aCSSLoader = 0;
    1: 
    1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
    1:   if (!ps) return NS_ERROR_NOT_INITIALIZED;
    1:   nsIDocument *document = ps->GetDocument();
    1:   if (!document)     return NS_ERROR_NULL_POINTER;
    1: 
    1:   NS_ADDREF(*aCSSLoader = document->CSSLoader());
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  nsIEditorMailSupport methods 
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetEmbeddedObjects(nsISupportsArray** aNodeList)
    1: {
    1:   if (!aNodeList)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsresult res;
    1: 
    1:   res = NS_NewISupportsArray(aNodeList);
    1:   if (NS_FAILED(res)) return res;
    1:   if (!*aNodeList) return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsIContentIterator> iter =
    1:       do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &res);
    1:   if (!iter) return NS_ERROR_NULL_POINTER;
    1:   if ((NS_SUCCEEDED(res)))
    1:   {
    1:     nsCOMPtr<nsIDOMDocument> domdoc;
    1:     nsEditor::GetDocument(getter_AddRefs(domdoc));
    1:     if (!domdoc)
    1:       return NS_ERROR_UNEXPECTED;
    1: 
    1:     nsCOMPtr<nsIDocument> doc (do_QueryInterface(domdoc));
    1:     if (!doc)
    1:       return NS_ERROR_UNEXPECTED;
    1: 
    1:     iter->Init(doc->GetRootContent());
    1: 
    1:     // loop through the content iterator for each content node
    1:     while (!iter->IsDone())
    1:     {
20503:       nsCOMPtr<nsIDOMNode> node (do_QueryInterface(iter->GetCurrentNode()));
    1:       if (node)
    1:       {
    1:         nsAutoString tagName;
    1:         node->GetNodeName(tagName);
    1:         ToLowerCase(tagName);
    1: 
    1:         // See if it's an image or an embed and also include all links.
    1:         // Let mail decide which link to send or not
    1:         if (tagName.EqualsLiteral("img") || tagName.EqualsLiteral("embed") ||
    1:             tagName.EqualsLiteral("a"))
    1:           (*aNodeList)->AppendElement(node);
    1:         else if (tagName.EqualsLiteral("body"))
    1:         {
    1:           nsCOMPtr<nsIDOMElement> element = do_QueryInterface(node);
    1:           if (element)
    1:           {
    1:             PRBool hasBackground = PR_FALSE;
    1:             if (NS_SUCCEEDED(element->HasAttribute(NS_LITERAL_STRING("background"), &hasBackground)) && hasBackground)
    1:               (*aNodeList)->AppendElement(node);
    1:           }
    1:         }
    1:       }
    1:       iter->Next();
    1:     }
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  nsIEditor overrides 
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::DeleteNode(nsIDOMNode * aNode)
    1: {
 2896:   // do nothing if the node is read-only
 2896:   if (!IsModifiableNode(aNode)) {
 2896:     return NS_ERROR_FAILURE;
 2896:   }
 2896: 
    1:   nsCOMPtr<nsIDOMNode> selectAllNode = FindUserSelectAllNode(aNode);
    1:   
    1:   if (selectAllNode)
    1:   {
    1:     return nsEditor::DeleteNode(selectAllNode);
    1:   }
    1:   return nsEditor::DeleteNode(aNode);
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::DeleteText(nsIDOMCharacterData *aTextNode,
    1:                                        PRUint32             aOffset,
    1:                                        PRUint32             aLength)
    1: {
 2896:   // do nothing if the node is read-only
 2896:   if (!IsModifiableNode(aTextNode)) {
 2896:     return NS_ERROR_FAILURE;
 2896:   }
 2896: 
    1:   nsCOMPtr<nsIDOMNode> selectAllNode = FindUserSelectAllNode(aTextNode);
    1:   
    1:   if (selectAllNode)
    1:   {
    1:     return nsEditor::DeleteNode(selectAllNode);
    1:   }
    1:   return nsEditor::DeleteText(aTextNode, aOffset, aLength);
    1: }
    1: 
 2896: NS_IMETHODIMP nsHTMLEditor::InsertTextImpl(const nsAString& aStringToInsert, 
 2896:                                            nsCOMPtr<nsIDOMNode> *aInOutNode, 
 2896:                                            PRInt32 *aInOutOffset,
 2896:                                            nsIDOMDocument *aDoc)
 2896: {
 2896:   // do nothing if the node is read-only
 2896:   if (!IsModifiableNode(*aInOutNode)) {
 2896:     return NS_ERROR_FAILURE;
 2896:   }
 2896: 
 2896:   return nsEditor::InsertTextImpl(aStringToInsert, aInOutNode, aInOutOffset, aDoc);
 2896: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  support utils
    1: #pragma mark -
    1: #endif
    1: 
    1: /* This routine examines aNode and it's ancestors looking for any node which has the
    1:    -moz-user-select: all style lit.  Return the highest such ancestor.  */
    1: nsCOMPtr<nsIDOMNode> nsHTMLEditor::FindUserSelectAllNode(nsIDOMNode *aNode)
    1: {
    1:   nsCOMPtr<nsIDOMNode> resultNode;  // starts out empty
    1:   nsCOMPtr<nsIDOMNode> node = aNode;
    1:   nsIDOMElement *root = GetRoot();
    1:   if (!nsEditorUtils::IsDescendantOf(aNode, root))
    1:     return nsnull;
    1: 
    1:   // retrieve the computed style of -moz-user-select for aNode
    1:   nsAutoString mozUserSelectValue;
    1:   while (node)
    1:   {
    1:     mHTMLCSSUtils->GetComputedProperty(node, nsEditProperty::cssMozUserSelect, mozUserSelectValue);
    1:     if (mozUserSelectValue.EqualsLiteral("all"))
    1:     {
    1:       resultNode = node;
    1:     }
    1:     if (node != root)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> tmp;
    1:       node->GetParentNode(getter_AddRefs(tmp));
    1:       node = tmp;
    1:     }
    1:     else
    1:     {
    1:       node = nsnull;
    1:     }
    1:   } 
    1: 
    1:   return resultNode;
    1: }
    1: 
 2896: NS_IMETHODIMP_(PRBool)
 2896: nsHTMLEditor::IsModifiableNode(nsIDOMNode *aNode)
 2896: {
 2896:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 2896: 
 2896:   return !content || !(content->IntrinsicState() & NS_EVENT_STATE_MOZ_READONLY);
 2896: }
 2896: 
    1: static nsresult SetSelectionAroundHeadChildren(nsCOMPtr<nsISelection> aSelection, nsWeakPtr aDocWeak)
    1: {
    1:   nsresult res = NS_OK;
    1:   // Set selection around <head> node
    1:   nsCOMPtr<nsIDOMDocument> doc = do_QueryReferent(aDocWeak);
    1:   if (!doc) return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   nsCOMPtr<nsIDOMNodeList>nodeList; 
    1:   res = doc->GetElementsByTagName(NS_LITERAL_STRING("head"), getter_AddRefs(nodeList));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!nodeList) return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRUint32 count; 
    1:   nodeList->GetLength(&count);
    1:   if (count < 1) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMNode> headNode;
    1:   res = nodeList->Item(0, getter_AddRefs(headNode)); 
    1:   if (NS_FAILED(res)) return res;
    1:   if (!headNode) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Collapse selection to before first child of the head,
    1:   res = aSelection->Collapse(headNode, 0);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   //  then extend it to just after
    1:   nsCOMPtr<nsIDOMNodeList> childNodes;
    1:   res = headNode->GetChildNodes(getter_AddRefs(childNodes));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!childNodes) return NS_ERROR_NULL_POINTER;
    1:   PRUint32 childCount;
    1:   childNodes->GetLength(&childCount);
    1: 
    1:   return aSelection->Extend(headNode, childCount+1);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetHeadContentsAsHTML(nsAString& aOutputString)
    1: {
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Save current selection
    1:   nsAutoSelectionReset selectionResetter(selection, this);
    1: 
    1:   res = SetSelectionAroundHeadChildren(selection, mDocWeak);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   res = OutputToString(NS_LITERAL_STRING("text/html"),
    1:                        nsIDocumentEncoder::OutputSelectionOnly,
    1:                        aOutputString);
    1:   if (NS_SUCCEEDED(res))
    1:   {
    1:     // Selection always includes <body></body>,
    1:     //  so terminate there
    1:     nsReadingIterator<PRUnichar> findIter,endFindIter;
    1:     aOutputString.BeginReading(findIter);
    1:     aOutputString.EndReading(endFindIter);
    1:     //counting on our parser to always lower case!!!
    1:     if (CaseInsensitiveFindInReadable(NS_LITERAL_STRING("<body"),
    1:                                       findIter, endFindIter))
    1:     {
    1:       nsReadingIterator<PRUnichar> beginIter;
    1:       aOutputString.BeginReading(beginIter);
    1:       PRInt32 offset = Distance(beginIter, findIter);//get the distance
    1: 
    1:       nsWritingIterator<PRUnichar> writeIter;
    1:       aOutputString.BeginWriting(writeIter);
    1:       // Ensure the string ends in a newline
    1:       PRUnichar newline ('\n');
    1:       findIter.advance(-1);
    1:       if (offset ==0 || (offset >0 &&  (*findIter) != newline)) //check for 0
    1:       {
    1:         writeIter.advance(offset);
    1:         *writeIter = newline;
    1:         aOutputString.Truncate(offset+1);
    1:       }
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::DebugUnitTests(PRInt32 *outNumTests, PRInt32 *outNumTestsFailed)
    1: {
    1: #ifdef DEBUG
    1:   if (!outNumTests || !outNumTestsFailed)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   TextEditorTest *tester = new TextEditorTest();
    1:   if (!tester)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:    
    1:   tester->Run(this, outNumTests, outNumTestsFailed);
    1:   delete tester;
    1:   return NS_OK;
    1: #else
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: #endif
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  StyleSheet utils 
    1: #pragma mark -
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::StyleSheetLoaded(nsICSSStyleSheet* aSheet, PRBool aWasAlternate,
    1:                                nsresult aStatus)
    1: {
    1:   nsresult rv = NS_OK;
    1:   nsAutoEditBatch batchIt(this);
    1: 
    1:   if (!mLastStyleSheetURL.IsEmpty())
    1:     RemoveStyleSheet(mLastStyleSheetURL);
    1: 
 3030:   nsRefPtr<AddStyleSheetTxn> txn;
 3030:   rv = CreateTxnForAddStyleSheet(aSheet, getter_AddRefs(txn));
    1:   if (!txn) rv = NS_ERROR_NULL_POINTER;
    1:   if (NS_SUCCEEDED(rv))
    1:   {
    1:     rv = DoTransaction(txn);
    1:     if (NS_SUCCEEDED(rv))
    1:     {
    1:       // Get the URI, then url spec from the sheet
    1:       nsCOMPtr<nsIStyleSheet> sheet = do_QueryInterface(aSheet);
    1:       nsCOMPtr<nsIURI> uri;
    1:       rv = sheet->GetSheetURI(getter_AddRefs(uri));
    1: 
    1:       if (NS_SUCCEEDED(rv))
    1:       {
    1:         nsCAutoString spec;
    1:         rv = uri->GetSpec(spec);
    1: 
    1:         if (NS_SUCCEEDED(rv))
    1:         {
    1:           // Save it so we can remove before applying the next one
    1:           mLastStyleSheetURL.AssignWithConversion(spec.get());
    1: 
    1:           // Also save in our arrays of urls and sheets
    1:           AddNewStyleSheetToList(mLastStyleSheetURL, aSheet);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  nsEditor overrides 
    1: #pragma mark -
    1: #endif
    1: 
    1: 
    1: /** All editor operations which alter the doc should be prefaced
    1:  *  with a call to StartOperation, naming the action and direction */
    1: NS_IMETHODIMP
    1: nsHTMLEditor::StartOperation(PRInt32 opID, nsIEditor::EDirection aDirection)
    1: {
    1:   nsEditor::StartOperation(opID, aDirection);  // will set mAction, mDirection
    1:   if (! ((mAction==kOpInsertText) || (mAction==kOpInsertIMEText)) )
    1:     ClearInlineStylesCache();
    1:   if (mRules) return mRules->BeforeEdit(mAction, mDirection);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: /** All editor operations which alter the doc should be followed
    1:  *  with a call to EndOperation */
    1: NS_IMETHODIMP
    1: nsHTMLEditor::EndOperation()
    1: {
    1:   // post processing
    1:   if (! ((mAction==kOpInsertText) || (mAction==kOpInsertIMEText) || (mAction==kOpIgnore)) )
    1:     ClearInlineStylesCache();
    1:   nsresult res = NS_OK;
    1:   if (mRules) res = mRules->AfterEdit(mAction, mDirection);
    1:   nsEditor::EndOperation();  // will clear mAction, mDirection
    1:   return res;
    1: }  
    1: 
    1: PRBool 
    1: nsHTMLEditor::TagCanContainTag(const nsAString& aParentTag, const nsAString& aChildTag)  
    1: {
    1:   nsIParserService* parserService = nsContentUtils::GetParserService();
    1: 
    1:   PRInt32 childTagEnum;
    1:   // XXX Should this handle #cdata-section too?
    1:   if (aChildTag.EqualsLiteral("#text")) {
    1:     childTagEnum = eHTMLTag_text;
    1:   }
    1:   else {
    1:     childTagEnum = parserService->HTMLStringTagToId(aChildTag);
    1:   }
    1: 
    1:   PRInt32 parentTagEnum = parserService->HTMLStringTagToId(aParentTag);
    1:   NS_ASSERTION(parentTagEnum < NS_HTML_TAG_MAX,
    1:                "Fix the caller, this type of node can never contain children.");
    1: 
    1:   return nsHTMLEditUtils::CanContain(parentTagEnum, childTagEnum);
    1: }
    1: 
    1: PRBool 
    1: nsHTMLEditor::IsContainer(nsIDOMNode *aNode)
    1: {
    1:   if (!aNode) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsAutoString stringTag;
    1: 
    1:   nsresult rv = aNode->GetNodeName(stringTag);
    1:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:   PRInt32 tagEnum;
    1:   // XXX Should this handle #cdata-section too?
    1:   if (stringTag.EqualsLiteral("#text")) {
    1:     tagEnum = eHTMLTag_text;
    1:   }
    1:   else {
    1:     tagEnum = nsContentUtils::GetParserService()->HTMLStringTagToId(stringTag);
    1:   }
    1: 
    1:   return nsHTMLEditUtils::IsContainer(tagEnum);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::SelectEntireDocument(nsISelection *aSelection)
    1: {
    1:   if (!aSelection || !mRules) { return NS_ERROR_NULL_POINTER; }
    1:   
    1:   // get editor root node
    1:   nsIDOMElement *rootElement = GetRoot();
    1:   
    1:   // is doc empty?
    1:   PRBool bDocIsEmpty;
    1:   nsresult res = mRules->DocumentIsEmpty(&bDocIsEmpty);
    1:   if (NS_FAILED(res)) return res;
    1:     
    1:   if (bDocIsEmpty)
    1:   {
    1:     // if its empty dont select entire doc - that would select the bogus node
    1:     return aSelection->Collapse(rootElement, 0);
    1:   }
    1: 
    1:   return nsEditor::SelectEntireDocument(aSelection);
    1: }
    1: 
 2896: NS_IMETHODIMP
 2896: nsHTMLEditor::SelectAll()
 2896: {
 2896:   ForceCompositionEnd();
 2896: 
 2896:   nsresult rv;
 2896:   nsCOMPtr<nsISelectionController> selCon = do_QueryReferent(mSelConWeak, &rv);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   nsCOMPtr<nsISelection> selection;
 2896:   rv = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
 2896:                             getter_AddRefs(selection));
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   nsCOMPtr<nsIDOMNode> anchorNode;
 2896:   rv = selection->GetAnchorNode(getter_AddRefs(anchorNode));
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   nsCOMPtr<nsIContent> anchorContent = do_QueryInterface(anchorNode, &rv);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
11914:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
11914:   nsIContent *rootContent = anchorContent->GetSelectionRootContent(ps);
37336:   NS_ENSURE_TRUE(rootContent, NS_ERROR_UNEXPECTED);
 2896: 
 2896:   nsCOMPtr<nsIDOMNode> rootElement = do_QueryInterface(rootContent, &rv);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   return selection->SelectAllChildren(rootElement);
 2896: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  Random methods 
    1: #pragma mark -
    1: #endif
    1: 
    1: // this will NOT find aAttribute unless aAttribute has a non-null value
    1: // so singleton attributes like <Table border> will not be matched!
    1: void nsHTMLEditor::IsTextPropertySetByContent(nsIDOMNode        *aNode,
    1:                                               nsIAtom           *aProperty, 
    1:                                               const nsAString   *aAttribute, 
    1:                                               const nsAString   *aValue, 
    1:                                               PRBool            &aIsSet,
    1:                                               nsIDOMNode       **aStyleNode,
    1:                                               nsAString *outValue)
    1: {
    1:   nsresult result;
    1:   aIsSet = PR_FALSE;  // must be initialized to false for code below to work
    1:   nsAutoString propName;
    1:   aProperty->ToString(propName);
    1:   nsCOMPtr<nsIDOMNode>node = aNode;
    1: 
    1:   while (node)
    1:   {
    1:     nsCOMPtr<nsIDOMElement>element;
    1:     element = do_QueryInterface(node);
    1:     if (element)
    1:     {
    1:       nsAutoString tag, value;
    1:       element->GetTagName(tag);
    1:       if (propName.Equals(tag, nsCaseInsensitiveStringComparator()))
    1:       {
    1:         PRBool found = PR_FALSE;
    1:         if (aAttribute && 0!=aAttribute->Length())
    1:         {
    1:           element->GetAttribute(*aAttribute, value);
    1:           if (outValue) *outValue = value;
    1:           if (!value.IsEmpty())
    1:           {
    1:             if (!aValue) {
    1:               found = PR_TRUE;
    1:             }
    1:             else
    1:             {
    1:               nsString tString(*aValue);
    1:               if (tString.Equals(value, nsCaseInsensitiveStringComparator())) {
    1:                 found = PR_TRUE;
    1:               }
    1:               else {  // we found the prop with the attribute, but the value doesn't match
    1:                 break;
    1:               }
    1:             }
    1:           }
    1:         }
    1:         else { 
    1:           found = PR_TRUE;
    1:         }
    1:         if (found)
    1:         {
    1:           aIsSet = PR_TRUE;
    1:           break;
    1:         }
    1:       }
    1:     }
    1:     nsCOMPtr<nsIDOMNode>temp;
    1:     result = node->GetParentNode(getter_AddRefs(temp));
    1:     if (NS_SUCCEEDED(result) && temp) {
    1:       node = temp;
    1:     }
    1:     else {
    1:       node = nsnull;
    1:     }
    1:   }
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #endif
    1: 
    1: //================================================================
    1: // HTML Editor methods
    1: //
    1: // Note: Table Editing methods are implemented in nsTableEditor.cpp
    1: //
    1: 
    1: 
    1: PRBool nsHTMLEditor::IsElementInBody(nsIDOMElement* aElement)
    1: {
    1:   return nsTextEditUtils::InBody(aElement, this);
    1: }
    1: 
    1: PRBool
    1: nsHTMLEditor::SetCaretInTableCell(nsIDOMElement* aElement)
    1: {
    1:   PRBool caretIsSet = PR_FALSE;
    1: 
    1:   if (aElement && IsElementInBody(aElement))
    1:   {
    1:     nsresult res = NS_OK;
    1:     nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
    1:     if (content)
    1:     {
    1:       nsIAtom *atom = content->Tag();
    1:       if (atom == nsEditProperty::table ||
    1:           atom == nsEditProperty::tbody ||
    1:           atom == nsEditProperty::thead ||
    1:           atom == nsEditProperty::tfoot ||
    1:           atom == nsEditProperty::caption ||
    1:           atom == nsEditProperty::tr ||
    1:           atom == nsEditProperty::td )
    1:       {
    1:         nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aElement);
    1:         nsCOMPtr<nsIDOMNode> parent;
    1:         // This MUST succeed if IsElementInBody was TRUE
    1:         node->GetParentNode(getter_AddRefs(parent));
    1:         nsCOMPtr<nsIDOMNode>firstChild;
    1:         // Find deepest child
    1:         PRBool hasChild;
    1:         while (NS_SUCCEEDED(node->HasChildNodes(&hasChild)) && hasChild)
    1:         {
    1:           if (NS_SUCCEEDED(node->GetFirstChild(getter_AddRefs(firstChild))))
    1:           {
    1:             parent = node;
    1:             node = firstChild;
    1:           }
    1:         }
    1:         // Set selection at beginning of deepest node
    1:         nsCOMPtr<nsISelection> selection;
    1:         res = GetSelection(getter_AddRefs(selection));
    1:         if (NS_SUCCEEDED(res) && selection && firstChild)
    1:         {
    1:           res = selection->Collapse(firstChild, 0);
    1:           if (NS_SUCCEEDED(res))
    1:             caretIsSet = PR_TRUE;
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return caretIsSet;
    1: }            
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::IsRootTag(nsString &aTag, PRBool &aIsTag)
    1: {
    1:   static char bodyTag[] = "body";
    1:   static char tdTag[] = "td";
    1:   static char thTag[] = "th";
    1:   static char captionTag[] = "caption";
    1:   if (aTag.EqualsIgnoreCase(bodyTag) ||
    1:       aTag.EqualsIgnoreCase(tdTag) ||
    1:       aTag.EqualsIgnoreCase(thTag) ||
    1:       aTag.EqualsIgnoreCase(captionTag) )
    1:   {
    1:     aIsTag = PR_TRUE;
    1:   }
    1:   else {
    1:     aIsTag = PR_FALSE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetEnclosingTable: find ancestor who is a table, if any
    1: //                  
    1: nsCOMPtr<nsIDOMNode> 
    1: nsHTMLEditor::GetEnclosingTable(nsIDOMNode *aNode)
    1: {
    1:   NS_PRECONDITION(aNode, "null node passed to nsHTMLEditor::GetEnclosingTable");
    1:   nsCOMPtr<nsIDOMNode> tbl, tmp, node = aNode;
    1: 
    1:   while (!tbl)
    1:   {
    1:     tmp = GetBlockNodeParent(node);
    1:     if (!tmp) break;
    1:     if (nsHTMLEditUtils::IsTable(tmp)) tbl = tmp;
    1:     node = tmp;
    1:   }
    1:   return tbl;
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #endif
    1: 
    1: void nsHTMLEditor::ClearInlineStylesCache()
    1: {
    1:   mCachedNode = nsnull;
    1: }
    1: 
    1: #ifdef PRE_NODE_IN_BODY
    1: nsCOMPtr<nsIDOMElement> nsHTMLEditor::FindPreElement()
    1: {
    1:   nsCOMPtr<nsIDOMDocument> domdoc;
    1:   nsEditor::GetDocument(getter_AddRefs(domdoc));
    1:   if (!domdoc)
    1:     return 0;
    1: 
    1:   nsCOMPtr<nsIDocument> doc (do_QueryInterface(domdoc));
    1:   if (!doc)
    1:     return 0;
    1: 
    1:   nsCOMPtr<nsIContent> rootContent;
    1:   doc->GetRootContent(getter_AddRefs(rootContent));
    1:   if (!rootContent)
    1:     return 0;
    1: 
    1:   nsCOMPtr<nsIDOMNode> rootNode (do_QueryInterface(rootContent));
    1:   if (!rootNode)
    1:     return 0;
    1: 
    1:   nsString prestr ("PRE");  // GetFirstNodeOfType requires capitals
    1:   nsCOMPtr<nsIDOMNode> preNode;
    1:   if (NS_FAILED(nsEditor::GetFirstNodeOfType(rootNode, prestr,
    1:                                                  getter_AddRefs(preNode))))
    1:     return 0;
    1: 
    1:   return do_QueryInterface(preNode);
    1: }
    1: #endif /* PRE_NODE_IN_BODY */
    1: 
    1: /* this method scans the selection for adjacent text nodes
    1:  * and collapses them into a single text node.
    1:  * "adjacent" means literally adjacent siblings of the same parent.
    1:  * Uses nsEditor::JoinNodes so action is undoable. 
    1:  * Should be called within the context of a batch transaction.
    1:  */
    1: NS_IMETHODIMP
    1: nsHTMLEditor::CollapseAdjacentTextNodes(nsIDOMRange *aInRange)
    1: {
    1:   if (!aInRange) return NS_ERROR_NULL_POINTER;
    1:   nsAutoTxnsConserveSelection dontSpazMySelection(this);
27986:   nsTArray<nsIDOMNode*> textNodes;
27986:   // we can't actually do anything during iteration, so store the text nodes in an array
    1:   // don't bother ref counting them because we know we can hold them for the 
    1:   // lifetime of this method
    1: 
    1: 
    1:   // build a list of editable text nodes
    1:   nsresult result;
    1:   nsCOMPtr<nsIContentIterator> iter =
    1:     do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &result);
    1:   if (NS_FAILED(result)) return result;
    1: 
    1:   iter->Init(aInRange);
    1: 
    1:   while (!iter->IsDone())
    1:   {
20503:     nsCOMPtr<nsIDOMCharacterData> text = do_QueryInterface(iter->GetCurrentNode());
20503:     if (text && IsEditable(text))
20503:     {
20503:       textNodes.AppendElement(text);
    1:     }
    1: 
    1:     iter->Next();
    1:   }
    1: 
    1:   // now that I have a list of text nodes, collapse adjacent text nodes
    1:   // NOTE: assumption that JoinNodes keeps the righthand node
27986:   while (textNodes.Length() > 1)
    1:   {
    1:     // we assume a textNodes entry can't be nsnull
27986:     nsIDOMNode *leftTextNode = textNodes[0];
27986:     nsIDOMNode *rightTextNode = textNodes[1];
    1:     NS_ASSERTION(leftTextNode && rightTextNode,"left or rightTextNode null in CollapseAdjacentTextNodes");
    1: 
    1:     // get the prev sibling of the right node, and see if it's leftTextNode
    1:     nsCOMPtr<nsIDOMNode> prevSibOfRightNode;
14819:     result =
14819:       rightTextNode->GetPreviousSibling(getter_AddRefs(prevSibOfRightNode));
    1:     if (NS_FAILED(result)) return result;
    1:     if (prevSibOfRightNode && (prevSibOfRightNode == leftTextNode))
    1:     {
    1:       nsCOMPtr<nsIDOMNode> parent;
    1:       result = rightTextNode->GetParentNode(getter_AddRefs(parent));
    1:       if (NS_FAILED(result)) return result;
    1:       if (!parent) return NS_ERROR_NULL_POINTER;
    1:       result = JoinNodes(leftTextNode, rightTextNode, parent);
    1:       if (NS_FAILED(result)) return result;
    1:     }
    1: 
    1:     textNodes.RemoveElementAt(0); // remove the leftmost text node from the list
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::SetSelectionAtDocumentStart(nsISelection *aSelection)
    1: {
    1:   nsIDOMElement *rootElement = GetRoot();  
    1:   if (!rootElement)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   return aSelection->Collapse(rootElement,0);
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #endif
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // RemoveBlockContainer: remove inNode, reparenting it's children into their
    1: //                  the parent of inNode.  In addition, INSERT ANY BR's NEEDED
    1: //                  TO PRESERVE IDENTITY OF REMOVED BLOCK.
    1: //
    1: nsresult
    1: nsHTMLEditor::RemoveBlockContainer(nsIDOMNode *inNode)
    1: {
    1:   if (!inNode)
    1:     return NS_ERROR_NULL_POINTER;
    1:   nsresult res;
    1:   nsCOMPtr<nsIDOMNode> sibling, child, unused;
    1:   
    1:   // Two possibilities: the container cold be empty of editable content.
    1:   // If that is the case, we need to compare what is before and after inNode
    1:   // to determine if we need a br.
    1:   // Or it could not be empty, in which case we have to compare previous
    1:   // sibling and first child to determine if we need a leading br,
    1:   // and compare following sibling and last child to determine if we need a
    1:   // trailing br.
    1:   
    1:   res = GetFirstEditableChild(inNode, address_of(child));
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   if (child)  // the case of inNode not being empty
    1:   {
    1:     // we need a br at start unless:
    1:     // 1) previous sibling of inNode is a block, OR
    1:     // 2) previous sibling of inNode is a br, OR
    1:     // 3) first child of inNode is a block OR
    1:     // 4) either is null
    1:     
    1:     res = GetPriorHTMLSibling(inNode, address_of(sibling));
    1:     if (NS_FAILED(res)) return res;
    1:     if (sibling && !IsBlockNode(sibling) && !nsTextEditUtils::IsBreak(sibling))
    1:     {
    1:       res = GetFirstEditableChild(inNode, address_of(child));
    1:       if (NS_FAILED(res)) return res;
    1:       if (child && !IsBlockNode(child))
    1:       {
    1:         // insert br node
    1:         res = CreateBR(inNode, 0, address_of(unused));
    1:         if (NS_FAILED(res)) return res;
    1:       }
    1:     }
    1:     
    1:     // we need a br at end unless:
    1:     // 1) following sibling of inNode is a block, OR
    1:     // 2) last child of inNode is a block, OR
    1:     // 3) last child of inNode is a block OR
    1:     // 4) either is null
    1: 
    1:     res = GetNextHTMLSibling(inNode, address_of(sibling));
    1:     if (NS_FAILED(res)) return res;
    1:     if (sibling && !IsBlockNode(sibling))
    1:     {
    1:       res = GetLastEditableChild(inNode, address_of(child));
    1:       if (NS_FAILED(res)) return res;
    1:       if (child && !IsBlockNode(child) && !nsTextEditUtils::IsBreak(child))
    1:       {
    1:         // insert br node
    1:         PRUint32 len;
    1:         res = GetLengthOfDOMNode(inNode, len);
    1:         if (NS_FAILED(res)) return res;
    1:         res = CreateBR(inNode, (PRInt32)len, address_of(unused));
    1:         if (NS_FAILED(res)) return res;
    1:       }
    1:     }
    1:   }
    1:   else  // the case of inNode being empty
    1:   {
    1:     // we need a br at start unless:
    1:     // 1) previous sibling of inNode is a block, OR
    1:     // 2) previous sibling of inNode is a br, OR
    1:     // 3) following sibling of inNode is a block, OR
    1:     // 4) following sibling of inNode is a br OR
    1:     // 5) either is null
    1:     res = GetPriorHTMLSibling(inNode, address_of(sibling));
    1:     if (NS_FAILED(res)) return res;
    1:     if (sibling && !IsBlockNode(sibling) && !nsTextEditUtils::IsBreak(sibling))
    1:     {
    1:       res = GetNextHTMLSibling(inNode, address_of(sibling));
    1:       if (NS_FAILED(res)) return res;
    1:       if (sibling && !IsBlockNode(sibling) && !nsTextEditUtils::IsBreak(sibling))
    1:       {
    1:         // insert br node
    1:         res = CreateBR(inNode, 0, address_of(unused));
    1:         if (NS_FAILED(res)) return res;
    1:       }
    1:     }
    1:   }
    1:     
    1:   // now remove container
    1:   return RemoveContainer(inNode);
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetPriorHTMLSibling: returns the previous editable sibling, if there is
    1: //                   one within the parent
    1: //                       
    1: nsresult
    1: nsHTMLEditor::GetPriorHTMLSibling(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode)
    1: {
    1:   if (!outNode || !inNode) return NS_ERROR_NULL_POINTER;
    1:   nsresult res = NS_OK;
    1:   *outNode = nsnull;
    1:   nsCOMPtr<nsIDOMNode> temp, node = do_QueryInterface(inNode);
    1:   
    1:   while (1)
    1:   {
    1:     res = node->GetPreviousSibling(getter_AddRefs(temp));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!temp) return NS_OK;  // return null sibling
    1:     // if it's editable, we're done
    1:     if (IsEditable(temp)) break;
    1:     // otherwise try again
    1:     node = temp;
    1:   }
    1:   *outNode = temp;
    1:   return res;
    1: }
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetPriorHTMLSibling: returns the previous editable sibling, if there is
    1: //                   one within the parent.  just like above routine but
    1: //                   takes a parent/offset instead of a node.
    1: //                       
    1: nsresult
    1: nsHTMLEditor::GetPriorHTMLSibling(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode)
    1: {
    1:   if (!outNode || !inParent) return NS_ERROR_NULL_POINTER;
    1:   nsresult res = NS_OK;
    1:   *outNode = nsnull;
    1:   if (!inOffset) return NS_OK;  // return null sibling if at offset zero
    1:   nsCOMPtr<nsIDOMNode> node = nsEditor::GetChildAt(inParent,inOffset-1);
    1:   if (IsEditable(node)) 
    1:   {
    1:     *outNode = node;
    1:     return res;
    1:   }
    1:   // else
    1:   return GetPriorHTMLSibling(node, outNode);
    1: }
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetNextHTMLSibling: returns the next editable sibling, if there is
    1: //                   one within the parent
    1: //                       
    1: nsresult
    1: nsHTMLEditor::GetNextHTMLSibling(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode)
    1: {
    1:   if (!outNode) return NS_ERROR_NULL_POINTER;
    1:   nsresult res = NS_OK;
    1:   *outNode = nsnull;
    1:   nsCOMPtr<nsIDOMNode> temp, node = do_QueryInterface(inNode);
    1:   
    1:   while (1)
    1:   {
    1:     res = node->GetNextSibling(getter_AddRefs(temp));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!temp) return NS_OK;  // return null sibling
    1:     // if it's editable, we're done
    1:     if (IsEditable(temp)) break;
    1:     // otherwise try again
    1:     node = temp;
    1:   }
    1:   *outNode = temp;
    1:   return res;
    1: }
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetNextHTMLSibling: returns the next editable sibling, if there is
    1: //                   one within the parent.  just like above routine but
    1: //                   takes a parent/offset instead of a node.
    1: //                       
    1: nsresult
    1: nsHTMLEditor::GetNextHTMLSibling(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode)
    1: {
    1:   if (!outNode || !inParent) return NS_ERROR_NULL_POINTER;
    1:   nsresult res = NS_OK;
    1:   *outNode = nsnull;
    1:   nsCOMPtr<nsIDOMNode> node = nsEditor::GetChildAt(inParent,inOffset);
    1:   if (!node) return NS_OK; // return null sibling if no sibling
    1:   if (IsEditable(node)) 
    1:   {
    1:     *outNode = node;
    1:     return res;
    1:   }
    1:   // else
    1:   return GetPriorHTMLSibling(node, outNode);
    1: }
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetPriorHTMLNode: returns the previous editable leaf node, if there is
    1: //                   one within the <body>
    1: //
    1: nsresult
    1: nsHTMLEditor::GetPriorHTMLNode(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode, PRBool bNoBlockCrossing)
    1: {
    1:   if (!outNode) return NS_ERROR_NULL_POINTER;
    1:   nsresult res = GetPriorNode(inNode, PR_TRUE, address_of(*outNode), bNoBlockCrossing);
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   // if it's not in the body, then zero it out
    1:   if (*outNode && !nsTextEditUtils::InBody(*outNode, this))
    1:   {
    1:     *outNode = nsnull;
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetPriorHTMLNode: same as above but takes {parent,offset} instead of node
    1: //                       
    1: nsresult
    1: nsHTMLEditor::GetPriorHTMLNode(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode, PRBool bNoBlockCrossing)
    1: {
    1:   if (!outNode) return NS_ERROR_NULL_POINTER;
    1:   nsresult res = GetPriorNode(inParent, inOffset, PR_TRUE, address_of(*outNode), bNoBlockCrossing);
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   // if it's not in the body, then zero it out
    1:   if (*outNode && !nsTextEditUtils::InBody(*outNode, this))
    1:   {
    1:     *outNode = nsnull;
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetNextHTMLNode: returns the next editable leaf node, if there is
    1: //                   one within the <body>
    1: //                       
    1: nsresult
    1: nsHTMLEditor::GetNextHTMLNode(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode, PRBool bNoBlockCrossing)
    1: {
    1:   if (!outNode) return NS_ERROR_NULL_POINTER;
    1:   nsresult res = GetNextNode(inNode, PR_TRUE, address_of(*outNode), bNoBlockCrossing);
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   // if it's not in the body, then zero it out
    1:   if (*outNode && !nsTextEditUtils::InBody(*outNode, this))
    1:   {
    1:     *outNode = nsnull;
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetNHTMLextNode: same as above but takes {parent,offset} instead of node
    1: //                       
    1: nsresult
    1: nsHTMLEditor::GetNextHTMLNode(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode, PRBool bNoBlockCrossing)
    1: {
    1:   if (!outNode) return NS_ERROR_NULL_POINTER;
    1:   nsresult res = GetNextNode(inParent, inOffset, PR_TRUE, address_of(*outNode), bNoBlockCrossing);
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   // if it's not in the body, then zero it out
    1:   if (*outNode && !nsTextEditUtils::InBody(*outNode, this))
    1:   {
    1:     *outNode = nsnull;
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditor::IsFirstEditableChild( nsIDOMNode *aNode, PRBool *aOutIsFirst)
    1: {
    1:   // check parms
    1:   if (!aOutIsFirst || !aNode) return NS_ERROR_NULL_POINTER;
    1:   
    1:   // init out parms
    1:   *aOutIsFirst = PR_FALSE;
    1:   
    1:   // find first editable child and compare it to aNode
    1:   nsCOMPtr<nsIDOMNode> parent, firstChild;
    1:   nsresult res = aNode->GetParentNode(getter_AddRefs(parent));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!parent) return NS_ERROR_FAILURE;
    1:   res = GetFirstEditableChild(parent, address_of(firstChild));
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   *aOutIsFirst = (firstChild.get() == aNode);
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditor::IsLastEditableChild( nsIDOMNode *aNode, PRBool *aOutIsLast)
    1: {
    1:   // check parms
    1:   if (!aOutIsLast || !aNode) return NS_ERROR_NULL_POINTER;
    1:   
    1:   // init out parms
    1:   *aOutIsLast = PR_FALSE;
    1:   
    1:   // find last editable child and compare it to aNode
    1:   nsCOMPtr<nsIDOMNode> parent, lastChild;
    1:   nsresult res = aNode->GetParentNode(getter_AddRefs(parent));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!parent) return NS_ERROR_FAILURE;
    1:   res = GetLastEditableChild(parent, address_of(lastChild));
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   *aOutIsLast = (lastChild.get() == aNode);
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditor::GetFirstEditableChild( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutFirstChild)
    1: {
    1:   // check parms
    1:   if (!aOutFirstChild || !aNode) return NS_ERROR_NULL_POINTER;
    1:   
    1:   // init out parms
    1:   *aOutFirstChild = nsnull;
    1:   
    1:   // find first editable child
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   nsresult res = aNode->GetFirstChild(getter_AddRefs(child));
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   while (child && !IsEditable(child))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> tmp;
    1:     res = child->GetNextSibling(getter_AddRefs(tmp));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!tmp) return NS_ERROR_FAILURE;
    1:     child = tmp;
    1:   }
    1:   
    1:   *aOutFirstChild = child;
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditor::GetLastEditableChild( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutLastChild)
    1: {
    1:   // check parms
    1:   if (!aOutLastChild || !aNode) return NS_ERROR_NULL_POINTER;
    1:   
    1:   // init out parms
    1:   *aOutLastChild = aNode;
    1:   
    1:   // find last editable child
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   nsresult res = aNode->GetLastChild(getter_AddRefs(child));
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   while (child && !IsEditable(child))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> tmp;
    1:     res = child->GetPreviousSibling(getter_AddRefs(tmp));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!tmp) return NS_ERROR_FAILURE;
    1:     child = tmp;
    1:   }
    1:   
    1:   *aOutLastChild = child;
    1:   return res;
    1: }
    1: 
    1: nsresult 
    1: nsHTMLEditor::GetFirstEditableLeaf( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutFirstLeaf)
    1: {
    1:   // check parms
    1:   if (!aOutFirstLeaf || !aNode) return NS_ERROR_NULL_POINTER;
    1:   
    1:   // init out parms
    1:   *aOutFirstLeaf = aNode;
    1:   
    1:   // find leftmost leaf
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   nsresult res = NS_OK;
    1:   child = GetLeftmostChild(aNode);  
    1:   while (child && (!IsEditable(child) || !nsEditorUtils::IsLeafNode(child)))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> tmp;
    1:     res = GetNextHTMLNode(child, address_of(tmp));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!tmp) return NS_ERROR_FAILURE;
    1:     
    1:     // only accept nodes that are descendants of aNode
    1:     if (nsEditorUtils::IsDescendantOf(tmp, aNode))
    1:       child = tmp;
    1:     else
    1:     {
    1:       child = nsnull;  // this will abort the loop
    1:     }
    1:   }
    1:   
    1:   *aOutFirstLeaf = child;
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsHTMLEditor::GetLastEditableLeaf( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutLastLeaf)
    1: {
    1:   // check parms
    1:   if (!aOutLastLeaf || !aNode) return NS_ERROR_NULL_POINTER;
    1:   
    1:   // init out parms
    1:   *aOutLastLeaf = nsnull;
    1:   
    1:   // find rightmost leaf
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   nsresult res = NS_OK;
    1:   child = GetRightmostChild(aNode, PR_FALSE);  
    1:   while (child && (!IsEditable(child) || !nsEditorUtils::IsLeafNode(child)))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> tmp;
    1:     res = GetPriorHTMLNode(child, address_of(tmp));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!tmp) return NS_ERROR_FAILURE;
    1:     
    1:     // only accept nodes that are descendants of aNode
    1:     if (nsEditorUtils::IsDescendantOf(tmp, aNode))
    1:       child = tmp;
    1:     else
    1:     {
    1:       child = nsnull;
    1:     }
    1:   }
    1:   
    1:   *aOutLastLeaf = child;
    1:   return res;
    1: }
    1: 
    1: PRBool
    1: nsHTMLEditor::IsTextInDirtyFrameVisible(nsIDOMNode *aNode)
    1: {
    1:   PRBool isEmptyTextNode;
    1:   nsresult res = IsVisTextNode(aNode, &isEmptyTextNode, PR_FALSE);
    1:   if (NS_FAILED(res))
    1:   {
    1:     // We are following the historical decision:
    1:     //   if we don't know, we say it's visible...
    1: 
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   return !isEmptyTextNode;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsVisTextNode: figure out if textnode aTextNode has any visible content.
    1: //                  
    1: nsresult
    1: nsHTMLEditor::IsVisTextNode( nsIDOMNode *aNode, 
    1:                              PRBool *outIsEmptyNode, 
    1:                              PRBool aSafeToAskFrames)
    1: {
    1:   if (!aNode || !outIsEmptyNode) 
    1:     return NS_ERROR_NULL_POINTER;
    1:   *outIsEmptyNode = PR_TRUE;
    1:   nsresult res = NS_OK;
    1: 
    1:   nsCOMPtr<nsIContent> textContent = do_QueryInterface(aNode);
    1:   // callers job to only call us with text nodes
    1:   if (!textContent || !textContent->IsNodeOfType(nsINode::eTEXT)) 
    1:     return NS_ERROR_NULL_POINTER;
    1:   PRUint32 length = textContent->TextLength();
    1:   if (aSafeToAskFrames)
    1:   {
    1:     nsCOMPtr<nsISelectionController> selCon;
    1:     res = GetSelectionController(getter_AddRefs(selCon));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!selCon) return NS_ERROR_FAILURE;
    1:     PRBool isVisible = PR_FALSE;
    1:     // ask the selection controller for information about whether any
    1:     // of the data in the node is really rendered.  This is really
    1:     // something that frames know about, but we aren't supposed to talk to frames.
    1:     // So we put a call in the selection controller interface, since it's already
    1:     // in bed with frames anyway.  (this is a fix for bug 22227, and a
    1:     // partial fix for bug 46209)
    1:     res = selCon->CheckVisibility(aNode, 0, length, &isVisible);
    1:     if (NS_FAILED(res)) return res;
    1:     if (isVisible) 
    1:     {
    1:       *outIsEmptyNode = PR_FALSE;
    1:     }
    1:   }
    1:   else if (length)
    1:   {
    1:     if (textContent->TextIsOnlyWhitespace())
    1:     {
    1:       nsWSRunObject wsRunObj(this, aNode, 0);
    1:       nsCOMPtr<nsIDOMNode> visNode;
    1:       PRInt32 outVisOffset=0;
    1:       PRInt16 visType=0;
    1:       res = wsRunObj.NextVisibleNode(aNode, 0, address_of(visNode), &outVisOffset, &visType);
    1:       if (NS_FAILED(res)) return res;
    1:       if ( (visType == nsWSRunObject::eNormalWS) ||
    1:            (visType == nsWSRunObject::eText) )
    1:       {
    1:         *outIsEmptyNode = (aNode != visNode);
    1:       }
    1:     }
    1:     else
    1:     {
    1:       *outIsEmptyNode = PR_FALSE;
    1:     }
    1:   }
    1:   return NS_OK;  
    1: }
    1:   
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsEmptyNode: figure out if aNode is an empty node.
    1: //               A block can have children and still be considered empty,
    1: //               if the children are empty or non-editable.
    1: //                  
    1: nsresult
    1: nsHTMLEditor::IsEmptyNode( nsIDOMNode *aNode, 
    1:                            PRBool *outIsEmptyNode, 
    1:                            PRBool aSingleBRDoesntCount,
    1:                            PRBool aListOrCellNotEmpty,
    1:                            PRBool aSafeToAskFrames)
    1: {
    1:   if (!aNode || !outIsEmptyNode) return NS_ERROR_NULL_POINTER;
    1:   *outIsEmptyNode = PR_TRUE;
    1:   PRBool seenBR = PR_FALSE;
    1:   return IsEmptyNodeImpl(aNode, outIsEmptyNode, aSingleBRDoesntCount,
    1:                          aListOrCellNotEmpty, aSafeToAskFrames, &seenBR);
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsEmptyNodeImpl: workhorse for IsEmptyNode.
    1: //                  
    1: nsresult
    1: nsHTMLEditor::IsEmptyNodeImpl( nsIDOMNode *aNode, 
    1:                                PRBool *outIsEmptyNode, 
    1:                                PRBool aSingleBRDoesntCount,
    1:                                PRBool aListOrCellNotEmpty,
    1:                                PRBool aSafeToAskFrames,
    1:                                PRBool *aSeenBR)
    1: {
    1:   if (!aNode || !outIsEmptyNode || !aSeenBR) return NS_ERROR_NULL_POINTER;
    1:   nsresult res = NS_OK;
    1: 
    1:   if (nsEditor::IsTextNode(aNode))
    1:   {
    1:     res = IsVisTextNode(aNode, outIsEmptyNode, aSafeToAskFrames);
    1:     return res;
    1:   }
    1: 
    1:   // if it's not a text node (handled above) and it's not a container,
    1:   // then we don't call it empty (it's an <hr>, or <br>, etc).
    1:   // Also, if it's an anchor then don't treat it as empty - even though
    1:   // anchors are containers, named anchors are "empty" but we don't
    1:   // want to treat them as such.  Also, don't call ListItems or table
    1:   // cells empty if caller desires.  Form Widgets not empty.
    1:   if (!IsContainer(aNode) || nsHTMLEditUtils::IsNamedAnchor(aNode) ||
    1:         nsHTMLEditUtils::IsFormWidget(aNode)                       ||
    1:        (aListOrCellNotEmpty && nsHTMLEditUtils::IsListItem(aNode)) ||
    1:        (aListOrCellNotEmpty && nsHTMLEditUtils::IsTableCell(aNode)) ) 
    1:   {
    1:     *outIsEmptyNode = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1:     
    1:   // need this for later
    1:   PRBool isListItemOrCell = 
    1:        nsHTMLEditUtils::IsListItem(aNode) || nsHTMLEditUtils::IsTableCell(aNode);
    1:        
    1:   // loop over children of node. if no children, or all children are either 
    1:   // empty text nodes or non-editable, then node qualifies as empty
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   aNode->GetFirstChild(getter_AddRefs(child));
    1:    
    1:   while (child)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> node = child;
    1:     // is the node editable and non-empty?  if so, return false
    1:     if (nsEditor::IsEditable(node))
    1:     {
    1:       if (nsEditor::IsTextNode(node))
    1:       {
    1:         res = IsVisTextNode(node, outIsEmptyNode, aSafeToAskFrames);
    1:         if (NS_FAILED(res)) return res;
    1:         if (!*outIsEmptyNode) return NS_OK;  // break out if we find we aren't emtpy
    1:       }
    1:       else  // an editable, non-text node.  we need to check it's content.
    1:       {
    1:         // is it the node we are iterating over?
    1:         if (node == aNode) break;
    1:         else if (aSingleBRDoesntCount && !*aSeenBR && nsTextEditUtils::IsBreak(node))
    1:         {
    1:           // the first br in a block doesn't count if the caller so indicated
    1:           *aSeenBR = PR_TRUE;
    1:         }
    1:         else
    1:         {
    1:           // is it an empty node of some sort?
    1:           // note: list items or table cells are not considered empty
    1:           // if they contain other lists or tables
    1:           if (isListItemOrCell)
    1:           {
    1:             if (nsHTMLEditUtils::IsList(node) || nsHTMLEditUtils::IsTable(node))
    1:             { // break out if we find we aren't empty
    1:               *outIsEmptyNode = PR_FALSE;
    1:               return NS_OK;
    1:             }
    1:           }
    1:           // is it a form widget?
    1:           else if (nsHTMLEditUtils::IsFormWidget(aNode))
    1:           { // break out if we find we aren't empty
    1:             *outIsEmptyNode = PR_FALSE;
    1:             return NS_OK;
    1:           }
    1:           
    1:           PRBool isEmptyNode = PR_TRUE;
    1:           res = IsEmptyNodeImpl(node, &isEmptyNode, aSingleBRDoesntCount, 
    1:                                 aListOrCellNotEmpty, aSafeToAskFrames, aSeenBR);
    1:           if (NS_FAILED(res)) return res;
    1:           if (!isEmptyNode) 
    1:           { 
    1:             // otherwise it ain't empty
    1:             *outIsEmptyNode = PR_FALSE;
    1:             return NS_OK;
    1:           }
    1:         }
    1:       }
    1:     }
    1:     node->GetNextSibling(getter_AddRefs(child));
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: // add to aElement the CSS inline styles corresponding to the HTML attribute
    1: // aAttribute with its value aValue
    1: nsresult
    1: nsHTMLEditor::SetAttributeOrEquivalent(nsIDOMElement * aElement,
    1:                                        const nsAString & aAttribute,
    1:                                        const nsAString & aValue,
    1:                                        PRBool aSuppressTransaction)
    1: {
    1:   PRBool useCSS;
    1:   nsresult res = NS_OK;
    1:   GetIsCSSEnabled(&useCSS);
    1:   if (useCSS && mHTMLCSSUtils) {
    1:     PRInt32 count;
    1:     res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(aElement, nsnull, &aAttribute, &aValue, &count,
    1:                                                      aSuppressTransaction);
    1:     if (NS_FAILED(res)) return res;
    1:     if (count) {
    1:       // we found an equivalence ; let's remove the HTML attribute itself if it is set
    1:       nsAutoString existingValue;
    1:       PRBool wasSet = PR_FALSE;
    1:       res = GetAttributeValue(aElement, aAttribute, existingValue, &wasSet);
    1:       if (NS_FAILED(res)) return res;
    1:       if (wasSet) {
    1:         if (aSuppressTransaction)
    1:           res = aElement->RemoveAttribute(aAttribute);
    1:         else
    1:           res = RemoveAttribute(aElement, aAttribute);
    1:       }
    1:     }
    1:     else {
    1:       // count is an integer that represents the number of CSS declarations applied to the
    1:       // element. If it is zero, we found no equivalence in this implementation for the
    1:       // attribute
    1:       if (aAttribute.EqualsLiteral("style")) {
    1:         // if it is the style attribute, just add the new value to the existing style
    1:         // attribute's value
    1:         nsAutoString existingValue;
    1:         PRBool wasSet = PR_FALSE;
    1:         res = GetAttributeValue(aElement, NS_LITERAL_STRING("style"), existingValue, &wasSet);
    1:         if (NS_FAILED(res)) return res;
    1:         existingValue.AppendLiteral(" ");
    1:         existingValue.Append(aValue);
    1:         if (aSuppressTransaction)
    1:           res = aElement->SetAttribute(aAttribute, existingValue);
    1:         else
    1:           res = SetAttribute(aElement, aAttribute, existingValue);
    1:       }
    1:       else {
    1:         // we have no CSS equivalence for this attribute and it is not the style
    1:         // attribute; let's set it the good'n'old HTML way
    1:         if (aSuppressTransaction)
    1:           res = aElement->SetAttribute(aAttribute, aValue);
    1:         else
    1:           res = SetAttribute(aElement, aAttribute, aValue);
    1:       }
    1:     }
    1:   }
    1:   else {
    1:     // we are not in an HTML+CSS editor; let's set the attribute the HTML way
    1:     if (aSuppressTransaction)
    1:       res = aElement->SetAttribute(aAttribute, aValue);
    1:     else
    1:       res = SetAttribute(aElement, aAttribute, aValue);
    1:   }  
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::RemoveAttributeOrEquivalent(nsIDOMElement * aElement,
    1:                                           const nsAString & aAttribute,
    1:                                           PRBool aSuppressTransaction)
    1: {
    1:   PRBool useCSS;
    1:   nsresult res = NS_OK;
    1:   GetIsCSSEnabled(&useCSS);
    1:   if (useCSS && mHTMLCSSUtils) {
    1:     res = mHTMLCSSUtils->RemoveCSSEquivalentToHTMLStyle(aElement, nsnull, &aAttribute, nsnull,
    1:                                                         aSuppressTransaction);
    1:     if (NS_FAILED(res)) return res;
    1:   }
    1: 
    1:   nsAutoString existingValue;
    1:   PRBool wasSet = PR_FALSE;
    1:   res = GetAttributeValue(aElement, aAttribute, existingValue, &wasSet);
    1:   if (NS_FAILED(res)) return res;
    1:   if (wasSet) {
    1:     if (aSuppressTransaction)
    1:       res = aElement->RemoveAttribute(aAttribute);
    1:     else
    1:       res = RemoveAttribute(aElement, aAttribute);
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::SetIsCSSEnabled(PRBool aIsCSSPrefChecked)
    1: {
    1:   nsresult  err = NS_ERROR_NOT_INITIALIZED;
    1:   if (mHTMLCSSUtils)
    1:   {
    1:     err = mHTMLCSSUtils->SetCSSEnabled(aIsCSSPrefChecked);
    1:   }
 7921:   // Disable the eEditorNoCSSMask flag if we're enabling StyleWithCSS.
 7921:   if (NS_SUCCEEDED(err)) {
 7921:     PRUint32 flags = 0;
 7921:     err = GetFlags(&flags);
 7921:     NS_ENSURE_SUCCESS(err, err);
 7921: 
 7921:     if (aIsCSSPrefChecked) {
 7921:       // Turn off NoCSS as we're enabling CSS
 7921:       if (flags & eEditorNoCSSMask) {
 7921:         flags -= eEditorNoCSSMask;
 7921:       }
 7921:     } else if (!(flags & eEditorNoCSSMask)) {
 7921:       // Turn on NoCSS, as we're disabling CSS.
 7921:       flags += eEditorNoCSSMask;
 7921:     }
 7921: 
 7921:     err = SetFlags(flags);
 7921:     NS_ENSURE_SUCCESS(err, err);
 7921:   }
    1:   return err;
    1: }
    1: 
    1: // Set the block background color
    1: NS_IMETHODIMP
    1: nsHTMLEditor::SetCSSBackgroundColor(const nsAString& aColor)
    1: {
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1:   ForceCompositionEnd();
    1: 
    1:   nsresult res;
    1:   nsCOMPtr<nsISelection>selection;
    1:   res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1: 
    1:   PRBool isCollapsed;
    1:   selection->GetIsCollapsed(&isCollapsed);
    1: 
    1:   nsAutoEditBatch batchIt(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpInsertElement, nsIEditor::eNext);
    1:   nsAutoSelectionReset selectionResetter(selection, this);
    1:   nsAutoTxnsConserveSelection dontSpazMySelection(this);
    1:   
    1:   PRBool cancel, handled;
    1:   nsTextRulesInfo ruleInfo(nsTextEditRules::kSetTextProperty);
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
    1:   if (NS_FAILED(res)) return res;
    1:   if (!cancel && !handled)
    1:   {
    1:     // get selection range enumerator
    1:     nsCOMPtr<nsIEnumerator> enumerator;
    1:     res = selPriv->GetEnumerator(getter_AddRefs(enumerator));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!enumerator)    return NS_ERROR_FAILURE;
    1: 
    1:     // loop thru the ranges in the selection
    1:     enumerator->First(); 
    1:     nsCOMPtr<nsISupports> currentItem;
    1:     nsAutoString bgcolor; bgcolor.AssignLiteral("bgcolor");
    1:     nsCOMPtr<nsIDOMNode> cachedBlockParent = nsnull;
    1:     while ((NS_ENUMERATOR_FALSE == enumerator->IsDone()))
    1:     {
    1:       res = enumerator->CurrentItem(getter_AddRefs(currentItem));
    1:       if (NS_FAILED(res)) return res;
    1:       if (!currentItem)   return NS_ERROR_FAILURE;
    1:       
    1:       nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1:       
    1:       // check for easy case: both range endpoints in same text node
    1:       nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:       PRInt32 startOffset, endOffset;
    1:       res = range->GetStartContainer(getter_AddRefs(startNode));
    1:       if (NS_FAILED(res)) return res;
    1:       res = range->GetEndContainer(getter_AddRefs(endNode));
    1:       if (NS_FAILED(res)) return res;
    1:       res = range->GetStartOffset(&startOffset);
    1:       if (NS_FAILED(res)) return res;
    1:       res = range->GetEndOffset(&endOffset);
    1:       if (NS_FAILED(res)) return res;
    1:       if ((startNode == endNode) && IsTextNode(startNode))
    1:       {
    1:         // let's find the block container of the text node
    1:         nsCOMPtr<nsIDOMNode> blockParent;
    1:         blockParent = GetBlockNodeParent(startNode);
    1:         // and apply the background color to that block container
    1:         if (cachedBlockParent != blockParent)
    1:         {
    1:           cachedBlockParent = blockParent;
    1:           nsCOMPtr<nsIDOMElement> element = do_QueryInterface(blockParent);
    1:           PRInt32 count;
    1:           res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, PR_FALSE);
    1:           if (NS_FAILED(res)) return res;
    1:         }
    1:       }
    1:       else if ((startNode == endNode) && nsTextEditUtils::IsBody(startNode) && isCollapsed)
    1:       {
    1:         // we have no block in the document, let's apply the background to the body 
    1:         nsCOMPtr<nsIDOMElement> element = do_QueryInterface(startNode);
    1:         PRInt32 count;
    1:         res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, PR_FALSE);
    1:         if (NS_FAILED(res)) return res;
    1:       }
    1:       else if ((startNode == endNode) && (((endOffset-startOffset) == 1) || (!startOffset && !endOffset)))
    1:       {
    1:         // a unique node is selected, let's also apply the background color
    1:         // to the containing block, possibly the node itself
    1:         nsCOMPtr<nsIDOMNode> selectedNode = GetChildAt(startNode, startOffset);
    1:         PRBool isBlock =PR_FALSE;
    1:         res = NodeIsBlockStatic(selectedNode, &isBlock);
    1:         if (NS_FAILED(res)) return res;
    1:         nsCOMPtr<nsIDOMNode> blockParent = selectedNode;
    1:         if (!isBlock) {
    1:           blockParent = GetBlockNodeParent(selectedNode);
    1:         }
    1:         if (cachedBlockParent != blockParent)
    1:         {
    1:           cachedBlockParent = blockParent;
    1:           nsCOMPtr<nsIDOMElement> element = do_QueryInterface(blockParent);
    1:           PRInt32 count;
    1:           res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, PR_FALSE);
    1:           if (NS_FAILED(res)) return res;
    1:         }
    1:       }
    1:       else
    1:       {
    1:         // not the easy case.  range not contained in single text node. 
    1:         // there are up to three phases here.  There are all the nodes
    1:         // reported by the subtree iterator to be processed.  And there
    1:         // are potentially a starting textnode and an ending textnode
    1:         // which are only partially contained by the range.
    1:         
    1:         // lets handle the nodes reported by the iterator.  These nodes
    1:         // are entirely contained in the selection range.  We build up
    1:         // a list of them (since doing operations on the document during
    1:         // iteration would perturb the iterator).
    1: 
    1:         nsCOMPtr<nsIContentIterator> iter =
    1:           do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &res);
    1:         if (NS_FAILED(res)) return res;
    1:         if (!iter)          return NS_ERROR_FAILURE;
    1: 
    1:         nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:         nsCOMPtr<nsIDOMNode> node;
    1:                 
    1:         // iterate range and build up array
    1:         res = iter->Init(range);
    1:         // init returns an error if no nodes in range.
    1:         // this can easily happen with the subtree 
    1:         // iterator if the selection doesn't contain
    1:         // any *whole* nodes.
    1:         if (NS_SUCCEEDED(res))
    1:         {
    1:           while (!iter->IsDone())
    1:           {
    1:             node = do_QueryInterface(iter->GetCurrentNode());
    1:             if (!node)
    1:               return NS_ERROR_FAILURE;
    1: 
    1:             if (IsEditable(node))
    1:             {
    1:               arrayOfNodes.AppendObject(node);
    1:             }
    1: 
    1:             iter->Next();
    1:           }
    1:         }
    1:         // first check the start parent of the range to see if it needs to 
    1:         // be separately handled (it does if it's a text node, due to how the
    1:         // subtree iterator works - it will not have reported it).
    1:         if (IsTextNode(startNode) && IsEditable(startNode))
    1:         {
    1:           nsCOMPtr<nsIDOMNode> blockParent;
    1:           blockParent = GetBlockNodeParent(startNode);
    1:           if (cachedBlockParent != blockParent)
    1:           {
    1:             cachedBlockParent = blockParent;
    1:             nsCOMPtr<nsIDOMElement> element = do_QueryInterface(blockParent);
    1:             PRInt32 count;
    1:             res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, PR_FALSE);
    1:             if (NS_FAILED(res)) return res;
    1:           }
    1:         }
    1:         
    1:         // then loop through the list, set the property on each node
    1:         PRInt32 listCount = arrayOfNodes.Count();
    1:         PRInt32 j;
    1:         for (j = 0; j < listCount; j++)
    1:         {
    1:           node = arrayOfNodes[j];
    1:           // do we have a block here ?
    1:           PRBool isBlock =PR_FALSE;
    1:           res = NodeIsBlockStatic(node, &isBlock);
    1:           if (NS_FAILED(res)) return res;
    1:           nsCOMPtr<nsIDOMNode> blockParent = node;
    1:           if (!isBlock) {
    1:             // no we don't, let's find the block ancestor
    1:             blockParent = GetBlockNodeParent(node);
    1:           }
    1:           if (cachedBlockParent != blockParent)
    1:           {
    1:             cachedBlockParent = blockParent;
    1:             nsCOMPtr<nsIDOMElement> element = do_QueryInterface(blockParent);
    1:             PRInt32 count;
    1:             // and set the property on it
    1:             res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, PR_FALSE);
    1:             if (NS_FAILED(res)) return res;
    1:           }
    1:         }
    1:         arrayOfNodes.Clear();
    1:         
    1:         // last check the end parent of the range to see if it needs to 
    1:         // be separately handled (it does if it's a text node, due to how the
    1:         // subtree iterator works - it will not have reported it).
    1:         if (IsTextNode(endNode) && IsEditable(endNode))
    1:         {
    1:           nsCOMPtr<nsIDOMNode> blockParent;
    1:           blockParent = GetBlockNodeParent(endNode);
    1:           if (cachedBlockParent != blockParent)
    1:           {
    1:             cachedBlockParent = blockParent;
    1:             nsCOMPtr<nsIDOMElement> element = do_QueryInterface(blockParent);
    1:             PRInt32 count;
    1:             res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, PR_FALSE);
    1:             if (NS_FAILED(res)) return res;
    1:           }
    1:         }
    1:       }
    1:       enumerator->Next();
    1:     }
    1:   }
    1:   if (!cancel)
    1:   {
    1:     // post-process
    1:     res = mRules->DidDoAction(selection, &ruleInfo, res);
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::SetBackgroundColor(const nsAString& aColor)
    1: {
    1:   nsresult res;
    1:   PRBool useCSS;
    1:   GetIsCSSEnabled(&useCSS);
    1:   if (useCSS) {
    1:     // if we are in CSS mode, we have to apply the background color to the
    1:     // containing block (or the body if we have no block-level element in
    1:     // the document)
    1:     res = SetCSSBackgroundColor(aColor);
    1:   }
    1:   else {
    1:     // but in HTML mode, we can only set the document's background color
    1:     res = SetHTMLBackgroundColor(aColor);
    1:   }
    1:   return res;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // NodesSameType: do these nodes have the same tag?
    1: //                    
    1: PRBool 
    1: nsHTMLEditor::NodesSameType(nsIDOMNode *aNode1, nsIDOMNode *aNode2)
    1: {
    1:   if (!aNode1 || !aNode2) 
    1:   {
    1:     NS_NOTREACHED("null node passed to nsEditor::NodesSameType()");
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   PRBool useCSS;
    1:   GetIsCSSEnabled(&useCSS);
    1: 
    1:   nsIAtom *tag1 = GetTag(aNode1);
    1: 
    1:   if (tag1 == GetTag(aNode2)) {
    1:     if (useCSS && tag1 == nsEditProperty::span) {
    1:       if (mHTMLCSSUtils->ElementsSameStyle(aNode1, aNode2)) {
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:     else {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::CopyLastEditableChildStyles(nsIDOMNode * aPreviousBlock, nsIDOMNode * aNewBlock,
    1:                                           nsIDOMNode **aOutBrNode)
    1: {
    1:   *aOutBrNode = nsnull;
    1:   nsCOMPtr<nsIDOMNode> child, tmp;
    1:   nsresult res;
    1:   // first, clear out aNewBlock.  Contract is that we want only the styles from previousBlock.
    1:   res = aNewBlock->GetFirstChild(getter_AddRefs(child));
    1:   while (NS_SUCCEEDED(res) && child)
    1:   {
    1:     res = DeleteNode(child);
    1:     if (NS_FAILED(res)) return res;
    1:     res = aNewBlock->GetFirstChild(getter_AddRefs(child));
    1:   }
    1:   // now find and clone the styles
    1:   child = aPreviousBlock;
    1:   tmp = aPreviousBlock;
    1:   while (tmp) {
    1:     child = tmp;
    1:     res = GetLastEditableChild(child, address_of(tmp));
    1:     if (NS_FAILED(res)) return res;
    1:   }
    1:   while (child && nsTextEditUtils::IsBreak(child)) {
    1:     nsCOMPtr<nsIDOMNode> priorNode;
    1:     res = GetPriorHTMLNode(child, address_of(priorNode));
    1:     if (NS_FAILED(res)) return res;
    1:     child = priorNode;
    1:   }
    1:   nsCOMPtr<nsIDOMNode> newStyles = nsnull, deepestStyle = nsnull;
    1:   while (child && (child != aPreviousBlock)) {
    1:     if (nsHTMLEditUtils::IsInlineStyle(child) ||
    1:         nsEditor::NodeIsType(child, nsEditProperty::span)) {
    1:       nsAutoString domTagName;
    1:       child->GetNodeName(domTagName);
    1:       ToLowerCase(domTagName);
    1:       if (newStyles) {
    1:         nsCOMPtr<nsIDOMNode> newContainer;
    1:         res = InsertContainerAbove(newStyles, address_of(newContainer), domTagName);
    1:         if (NS_FAILED(res)) return res;
    1:         newStyles = newContainer;
    1:       }
    1:       else {
    1:         res = CreateNode(domTagName, aNewBlock, 0, getter_AddRefs(newStyles));
    1:         if (NS_FAILED(res)) return res;
    1:         deepestStyle = newStyles;
    1:       }
    1:       res = CloneAttributes(newStyles, child);
    1:       if (NS_FAILED(res)) return res;
    1:     }
    1:     nsCOMPtr<nsIDOMNode> tmp;
    1:     res = child->GetParentNode(getter_AddRefs(tmp));
    1:     if (NS_FAILED(res)) return res;
    1:     child = tmp;
    1:   }
    1:   if (deepestStyle) {
    1:     nsCOMPtr<nsIDOMNode> outBRNode;
    1:     res = CreateBR(deepestStyle, 0, address_of(outBRNode));
    1:     if (NS_FAILED(res)) return res;
    1:     // Getters must addref
    1:     *aOutBrNode = outBRNode;
    1:     NS_ADDREF(*aOutBrNode);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::GetElementOrigin(nsIDOMElement * aElement, PRInt32 & aX, PRInt32 & aY)
    1: {
10522:   aX = 0;
10522:   aY = 0;
10522: 
    1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
    1:   if (!ps) return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
36657:   nsIFrame *frame = content->GetPrimaryFrame();
10522: 
10522:   nsIFrame *container = ps->GetAbsoluteContainingBlock(frame);
10522:   if (!frame) return NS_OK;
10522:   nsPoint off = frame->GetOffsetTo(container);
10522:   aX = nsPresContext::AppUnitsToIntCSSPixels(off.x);
10522:   aY = nsPresContext::AppUnitsToIntCSSPixels(off.y);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::EndUpdateViewBatch()
    1: {
    1:   nsresult res = nsEditor::EndUpdateViewBatch();
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   // We may need to show resizing handles or update existing ones after
    1:   // all transactions are done. This way of doing is preferred to DOM
    1:   // mutation events listeners because all the changes the user can apply
    1:   // to a document may result in multiple events, some of them quite hard
    1:   // to listen too (in particular when an ancestor of the selection is
    1:   // changed but the selection itself is not changed).
    1:   if (mUpdateCount == 0) {
    1:     nsCOMPtr<nsISelection> selection;
    1:     res = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!selection) return NS_ERROR_NOT_INITIALIZED;
    1:     res = CheckSelectionStateForAnonymousButtons(selection);
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::IgnoreSpuriousDragEvent(PRBool aIgnoreSpuriousDragEvent)
    1: {
    1:   mIgnoreSpuriousDragEvent = aIgnoreSpuriousDragEvent;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetSelectionContainer(nsIDOMElement ** aReturn)
    1: {
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
    1:   // if we don't get the selection, just skip this
    1:   if (NS_FAILED(res) || !selection) return res;
    1: 
    1:   PRBool bCollapsed;
    1:   res = selection->GetIsCollapsed(&bCollapsed);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   nsCOMPtr<nsIDOMNode> focusNode;
    1: 
    1:   if (bCollapsed) {
    1:     res = selection->GetFocusNode(getter_AddRefs(focusNode));
    1:     if (NS_FAILED(res)) return res;
    1:   }
    1:   else {
    1: 
    1:     PRInt32 rangeCount;
    1:     res = selection->GetRangeCount(&rangeCount);
    1:     if (NS_FAILED(res)) return res;
    1: 
    1:     if (rangeCount == 1) {
    1: 
    1:       nsCOMPtr<nsIDOMRange> range;
    1:       res = selection->GetRangeAt(0, getter_AddRefs(range));
    1:       if (NS_FAILED(res)) return res;
    1:       if (!range) return NS_ERROR_NULL_POINTER;
    1: 
    1:       nsCOMPtr<nsIDOMNode> startContainer, endContainer;
    1:       res = range->GetStartContainer(getter_AddRefs(startContainer));
    1:       if (NS_FAILED(res)) return res;
    1:       res = range->GetEndContainer(getter_AddRefs(endContainer));
    1:       if (NS_FAILED(res)) return res;
    1:       PRInt32 startOffset, endOffset;
    1:       res = range->GetStartOffset(&startOffset);
    1:       if (NS_FAILED(res)) return res;
    1:       res = range->GetEndOffset(&endOffset);
    1:       if (NS_FAILED(res)) return res;
    1: 
    1:       nsCOMPtr<nsIDOMElement> focusElement;
    1:       if (startContainer == endContainer && startOffset + 1 == endOffset) {
    1:         res = GetSelectedElement(EmptyString(), getter_AddRefs(focusElement));
    1:         if (NS_FAILED(res)) return res;
    1:         if (focusElement)
    1:           focusNode = do_QueryInterface(focusElement);
    1:       }
    1:       if (!focusNode) {
    1:         res = range->GetCommonAncestorContainer(getter_AddRefs(focusNode));
    1:         if (NS_FAILED(res)) return res;
    1:       }
    1:     }
    1:     else {
    1:       PRInt32 i;
    1:       nsCOMPtr<nsIDOMRange> range;
    1:       for (i = 0; i < rangeCount; i++)
    1:       {
    1:         res = selection->GetRangeAt(i, getter_AddRefs(range));
    1:         if (NS_FAILED(res)) return res;
    1:         nsCOMPtr<nsIDOMNode> startContainer;
26710:         res = range->GetStartContainer(getter_AddRefs(startContainer));
26710:         if (NS_FAILED(res)) continue;
    1:         if (!focusNode)
    1:           focusNode = startContainer;
    1:         else if (focusNode != startContainer) {
    1:           res = startContainer->GetParentNode(getter_AddRefs(focusNode));
    1:           if (NS_FAILED(res)) return res;
    1:           break;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (focusNode) {
    1:     PRUint16 nodeType;
    1:     focusNode->GetNodeType(&nodeType);
    1:     if (nsIDOMNode::TEXT_NODE == nodeType) {
    1:       nsCOMPtr<nsIDOMNode> parent;
    1:       res = focusNode->GetParentNode(getter_AddRefs(parent));
    1:       if (NS_FAILED(res)) return res;
    1:       focusNode = parent;
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMElement> focusElement = do_QueryInterface(focusNode);
    1:   *aReturn = focusElement;
    1:   NS_IF_ADDREF(*aReturn);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::IsAnonymousElement(nsIDOMElement * aElement, PRBool * aReturn)
    1: {
    1:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
16126:   *aReturn = content->IsRootOfNativeAnonymousSubtree();
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::SetReturnInParagraphCreatesNewParagraph(PRBool aCreatesNewParagraph)
    1: {
    1:   mCRInParagraphCreatesParagraph = aCreatesNewParagraph;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::GetReturnInParagraphCreatesNewParagraph(PRBool *aCreatesNewParagraph)
    1: {
    1:   *aCreatesNewParagraph = mCRInParagraphCreatesParagraph;
    1:   return NS_OK;
    1: }
