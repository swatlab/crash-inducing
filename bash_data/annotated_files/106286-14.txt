     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
104487: #include <stdio.h>
104487: 
104487: #include "mozilla/Assertions.h"
106286: #include "mozilla/Selection.h"
104487: #include "mozilla/dom/Element.h"
104487: #include "nsAString.h"
104487: #include "nsAlgorithm.h"
104487: #include "nsCOMPtr.h"
104487: #include "nsDebug.h"
104487: #include "nsEditProperty.h"
     1: #include "nsEditor.h"
104487: #include "nsEditorUtils.h"
104487: #include "nsError.h"
104487: #include "nsGkAtoms.h"
104487: #include "nsHTMLEditUtils.h"
104487: #include "nsHTMLEditor.h"
104487: #include "nsIAtom.h"
104487: #include "nsIContent.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsIDOMRange.h"
104487: #include "nsIEditor.h"
 18814: #include "nsIFrame.h"
104487: #include "nsIHTMLEditor.h"
104487: #include "nsINode.h"
 18814: #include "nsIPresShell.h"
104487: #include "nsISupportsUtils.h"
     1: #include "nsITableCellLayout.h" // For efficient access to table cell
104487: #include "nsITableEditor.h"
     1: #include "nsITableLayout.h"     //  data owned by the table and cell frames
104487: #include "nsLayoutErrors.h"
104487: #include "nsLiteralString.h"
104487: #include "nsQueryFrame.h"
104487: #include "nsString.h"
 27986: #include "nsTArray.h"
104487: #include "nscore.h"
104487: #include "prtypes.h"
 88029: 
 88029: using namespace mozilla;
     1: 
     1: /***************************************************************************
     1:  * stack based helper class for restoring selection after table edit
     1:  */
 15596: class NS_STACK_CLASS nsSetSelectionAfterTableEdit
     1: {
     1:   private:
     1:     nsCOMPtr<nsITableEditor> mEd;
     1:     nsCOMPtr<nsIDOMElement> mTable;
     1:     PRInt32 mCol, mRow, mDirection, mSelected;
     1:   public:
     1:     nsSetSelectionAfterTableEdit(nsITableEditor *aEd, nsIDOMElement* aTable, 
     1:                                  PRInt32 aRow, PRInt32 aCol, PRInt32 aDirection, 
 79445:                                  bool aSelected) : 
     1:         mEd(do_QueryInterface(aEd))
     1:     { 
     1:       mTable = aTable; 
     1:       mRow = aRow; 
     1:       mCol = aCol; 
     1:       mDirection = aDirection;
     1:       mSelected = aSelected;
     1:     } 
     1:     
     1:     ~nsSetSelectionAfterTableEdit() 
     1:     { 
     1:       if (mEd)
     1:         mEd->SetSelectionAfterTableEdit(mTable, mRow, mCol, mDirection, mSelected);
     1:     }
     1:     // This is needed to abort the caret reset in the destructor
     1:     //  when one method yields control to another
     1:     void CancelSetCaret() {mEd = nsnull; mTable = nsnull;}
     1: };
     1: 
     1: // Stack-class to turn on/off selection batching for table selection
 23637: class NS_STACK_CLASS nsSelectionBatcherForTable
     1: {
     1: private:
     1:   nsCOMPtr<nsISelectionPrivate> mSelection;
     1: public:
 23637:   nsSelectionBatcherForTable(nsISelection *aSelection)
     1:   {
     1:     nsCOMPtr<nsISelection> sel(aSelection);
     1:     mSelection = do_QueryInterface(sel);
     1:     if (mSelection)  mSelection->StartBatchChanges();
     1:   }
 23637:   virtual ~nsSelectionBatcherForTable() 
     1:   { 
     1:     if (mSelection) mSelection->EndBatchChanges();
     1:   }
     1: };
     1: 
     1: // Table Editing helper utilities (not exposed in IDL)
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::InsertCell(nsIDOMElement *aCell, PRInt32 aRowSpan, PRInt32 aColSpan, 
 79445:                          bool aAfter, bool aIsHeader, nsIDOMElement **aNewCell)
     1: {
 43806:   NS_ENSURE_TRUE(aCell, NS_ERROR_NULL_POINTER);
     1:   if (aNewCell) *aNewCell = nsnull;
     1: 
     1:   // And the parent and offsets needed to do an insert
     1:   nsCOMPtr<nsIDOMNode> cellParent;
     1:   nsresult res = aCell->GetParentNode(getter_AddRefs(cellParent));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(cellParent, NS_ERROR_NULL_POINTER);
     1: 
103677:   PRInt32 cellOffset = GetChildOffset(aCell, cellParent);
     1: 
     1:   nsCOMPtr<nsIDOMElement> newCell;
     1:   if (aIsHeader)
     1:     res = CreateElementWithDefaults(NS_LITERAL_STRING("th"), getter_AddRefs(newCell));
     1:   else
     1:     res = CreateElementWithDefaults(NS_LITERAL_STRING("td"), getter_AddRefs(newCell));
     1:     
     1:   if(NS_FAILED(res)) return res;
     1:   if(!newCell) return NS_ERROR_FAILURE;
     1: 
     1:   //Optional: return new cell created
     1:   if (aNewCell)
     1:   {
     1:     *aNewCell = newCell.get();
     1:     NS_ADDREF(*aNewCell);
     1:   }
     1: 
     1:   if( aRowSpan > 1)
     1:   {
     1:     // Note: Do NOT use editor transaction for this
     1:     nsAutoString newRowSpan;
     1:     newRowSpan.AppendInt(aRowSpan, 10);
     1:     newCell->SetAttribute(NS_LITERAL_STRING("rowspan"), newRowSpan);
     1:   }
     1:   if( aColSpan > 1)
     1:   {
     1:     // Note: Do NOT use editor transaction for this
     1:     nsAutoString newColSpan;
     1:     newColSpan.AppendInt(aColSpan, 10);
     1:     newCell->SetAttribute(NS_LITERAL_STRING("colspan"), newColSpan);
     1:   }
     1:   if(aAfter) cellOffset++;
     1: 
     1:   //Don't let Rules System change the selection
     1:   nsAutoTxnsConserveSelection dontChangeSelection(this);
     1:   return InsertNode(newCell, cellParent, cellOffset);
     1: }
     1: 
     1: NS_IMETHODIMP nsHTMLEditor::SetColSpan(nsIDOMElement *aCell, PRInt32 aColSpan)
     1: {
 43806:   NS_ENSURE_TRUE(aCell, NS_ERROR_NULL_POINTER);
     1:   nsAutoString newSpan;
     1:   newSpan.AppendInt(aColSpan, 10);
     1:   return SetAttribute(aCell, NS_LITERAL_STRING("colspan"), newSpan);
     1: }
     1: 
     1: NS_IMETHODIMP nsHTMLEditor::SetRowSpan(nsIDOMElement *aCell, PRInt32 aRowSpan)
     1: {
 43806:   NS_ENSURE_TRUE(aCell, NS_ERROR_NULL_POINTER);
     1:   nsAutoString newSpan;
     1:   newSpan.AppendInt(aRowSpan, 10);
     1:   return SetAttribute(aCell, NS_LITERAL_STRING("rowspan"), newSpan);
     1: }
     1: 
     1: /****************************************************************/
     1: 
     1: // Table Editing interface methods
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::InsertTableCell(PRInt32 aNumber, bool aAfter)
     1: {
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   nsCOMPtr<nsIDOMElement> curCell;
     1:   nsCOMPtr<nsIDOMNode> cellParent;
     1:   PRInt32 cellOffset, startRowIndex, startColIndex;
     1:   nsresult res = GetCellContext(nsnull,
     1:                                 getter_AddRefs(table), 
     1:                                 getter_AddRefs(curCell), 
     1:                                 getter_AddRefs(cellParent), &cellOffset,
     1:                                 &startRowIndex, &startColIndex);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // Don't fail if no cell found
 43806:   NS_ENSURE_TRUE(curCell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:   // Get more data for current cell in row we are inserting at (we need COLSPAN)
     1:   PRInt32 curStartRowIndex, curStartColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1:   res = GetCellDataAt(table, startRowIndex, startColIndex,
     1:                       getter_AddRefs(curCell),
     1:                       &curStartRowIndex, &curStartColIndex, &rowSpan, &colSpan,
     1:                       &actualRowSpan, &actualColSpan, &isSelected);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(curCell, NS_ERROR_FAILURE);
     1:   PRInt32 newCellIndex = aAfter ? (startColIndex+colSpan) : startColIndex;
     1:   //We control selection resetting after the insert...
 80486:   nsSetSelectionAfterTableEdit setCaret(this, table, startRowIndex, newCellIndex, ePreviousColumn, false);
     1:   //...so suppress Rules System selection munging
     1:   nsAutoTxnsConserveSelection dontChangeSelection(this);
     1: 
     1:   PRInt32 i;
     1:   for (i = 0; i < aNumber; i++)
     1:   {
     1:     nsCOMPtr<nsIDOMElement> newCell;
     1:     res = CreateElementWithDefaults(NS_LITERAL_STRING("td"), getter_AddRefs(newCell));
     1:     if (NS_SUCCEEDED(res) && newCell)
     1:     {
     1:       if (aAfter) cellOffset++;
     1:       res = InsertNode(newCell, cellParent, cellOffset);
     1:       if(NS_FAILED(res)) break;
     1:     }
     1:   }
     1:   return res;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::GetFirstRow(nsIDOMElement* aTableElement, nsIDOMNode** aRowNode)
     1: {
 43806:   NS_ENSURE_TRUE(aRowNode, NS_ERROR_NULL_POINTER);
     1: 
     1:   *aRowNode = nsnull;  
     1: 
 43806:   NS_ENSURE_TRUE(aTableElement, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMElement> tableElement;
     1:   nsresult res = GetElementOrParentByTagName(NS_LITERAL_STRING("table"), aTableElement, getter_AddRefs(tableElement));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(tableElement, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMNode> tableChild;
     1:   res = tableElement->GetFirstChild(getter_AddRefs(tableChild));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   while (tableChild)
     1:   {
     1:     nsCOMPtr<nsIContent> content = do_QueryInterface(tableChild);
     1:     if (content)
     1:     {
     1:       nsIAtom *atom = content->Tag();
     1: 
     1:       if (atom == nsEditProperty::tr)
     1:       {
     1:         // Found a row directly under <table>
     1:         *aRowNode = tableChild;
     1:         NS_ADDREF(*aRowNode);
     1:         return NS_OK;
     1:       }
     1:       // Look for row in one of the row container elements      
     1:       if (atom == nsEditProperty::tbody ||
     1:           atom == nsEditProperty::thead ||
     1:           atom == nsEditProperty::tfoot)
     1:       {
     1:         nsCOMPtr<nsIDOMNode> rowNode;
     1:         res = tableChild->GetFirstChild(getter_AddRefs(rowNode));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         
     1:         // We can encounter textnodes here -- must find a row
     1:         while (rowNode && !nsHTMLEditUtils::IsTableRow(rowNode))
     1:         {
     1:           nsCOMPtr<nsIDOMNode> nextNode;
     1:           res = rowNode->GetNextSibling(getter_AddRefs(nextNode));
 43805:           NS_ENSURE_SUCCESS(res, res);
     1: 
     1:           rowNode = nextNode;
     1:         }
     1:         if(rowNode)
     1:         {
     1:           *aRowNode = rowNode.get();
     1:           NS_ADDREF(*aRowNode);
     1:           return NS_OK;
     1:         }
     1:       }
     1:     }
     1:     // Here if table child was a CAPTION or COLGROUP
     1:     //  or child of a row parent wasn't a row (bad HTML?),
     1:     //  or first child was a textnode
     1:     // Look in next table child
     1:     nsCOMPtr<nsIDOMNode> nextChild;
     1:     res = tableChild->GetNextSibling(getter_AddRefs(nextChild));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     tableChild = nextChild;
     1:   };
     1:   // If here, row was not found
     1:   return NS_EDITOR_ELEMENT_NOT_FOUND;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::GetNextRow(nsIDOMNode* aCurrentRowNode, nsIDOMNode **aRowNode)
     1: {
 43806:   NS_ENSURE_TRUE(aRowNode, NS_ERROR_NULL_POINTER);
     1: 
     1:   *aRowNode = nsnull;  
     1: 
 43806:   NS_ENSURE_TRUE(aCurrentRowNode, NS_ERROR_NULL_POINTER);
     1: 
     1:   if (!nsHTMLEditUtils::IsTableRow(aCurrentRowNode))
     1:     return NS_ERROR_FAILURE;
     1:   
     1:   nsCOMPtr<nsIDOMNode> nextRow;
     1:   nsresult res = aCurrentRowNode->GetNextSibling(getter_AddRefs(nextRow));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMNode> nextNode;
     1: 
     1:   // Skip over any textnodes here
     1:   while (nextRow && !nsHTMLEditUtils::IsTableRow(nextRow))
     1:   {
     1:     res = nextRow->GetNextSibling(getter_AddRefs(nextNode));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   
     1:     nextRow = nextNode;
     1:   }
     1:   if(nextRow)
     1:   {
     1:     *aRowNode = nextRow.get();
     1:     NS_ADDREF(*aRowNode);
     1:     return NS_OK;
     1:   }
     1: 
     1:   // No row found, search for rows in other table sections
     1:   nsCOMPtr<nsIDOMNode> rowParent;
     1:   res = aCurrentRowNode->GetParentNode(getter_AddRefs(rowParent));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(rowParent, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMNode> parentSibling;
     1:   res = rowParent->GetNextSibling(getter_AddRefs(parentSibling));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   while (parentSibling)
     1:   {
     1:     res = parentSibling->GetFirstChild(getter_AddRefs(nextRow));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   
     1:     // We can encounter textnodes here -- must find a row
     1:     while (nextRow && !nsHTMLEditUtils::IsTableRow(nextRow))
     1:     {
     1:       res = nextRow->GetNextSibling(getter_AddRefs(nextNode));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       nextRow = nextNode;
     1:     }
     1:     if(nextRow)
     1:     {
     1:       *aRowNode = nextRow.get();
     1:       NS_ADDREF(*aRowNode);
     1:       return NS_OK;
     1:     }
     1: #ifdef DEBUG_cmanske
     1:     printf("GetNextRow: firstChild of row's parent's sibling is not a TR!\n");
     1: #endif
     1:     // We arrive here only if a table section has no children 
     1:     //  or first child of section is not a row (bad HTML or more "_moz_text" nodes!)
     1:     // So look for another section sibling
     1:     res = parentSibling->GetNextSibling(getter_AddRefs(nextNode));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     parentSibling = nextNode;
     1:   }
     1:   // If here, row was not found
     1:   return NS_EDITOR_ELEMENT_NOT_FOUND;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::GetLastCellInRow(nsIDOMNode* aRowNode, nsIDOMNode** aCellNode)
     1: {
 43806:   NS_ENSURE_TRUE(aCellNode, NS_ERROR_NULL_POINTER);
     1: 
     1:   *aCellNode = nsnull;
     1: 
 43806:   NS_ENSURE_TRUE(aRowNode, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMNode> rowChild;
     1:   nsresult res = aRowNode->GetLastChild(getter_AddRefs(rowChild));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   while (rowChild && !nsHTMLEditUtils::IsTableCell(rowChild))
     1:   {
     1:     // Skip over textnodes
     1:     nsCOMPtr<nsIDOMNode> previousChild;
     1:     res = rowChild->GetPreviousSibling(getter_AddRefs(previousChild));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     rowChild = previousChild;
     1:   };
     1:   if (rowChild)
     1:   {
     1:     *aCellNode = rowChild.get();
     1:     NS_ADDREF(*aCellNode);
     1:     return NS_OK;
     1:   }
     1:   // If here, cell was not found
     1:   return NS_EDITOR_ELEMENT_NOT_FOUND;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::InsertTableColumn(PRInt32 aNumber, bool aAfter)
     1: {
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   nsCOMPtr<nsIDOMElement> curCell;
     1:   PRInt32 startRowIndex, startColIndex;
     1:   nsresult res = GetCellContext(getter_AddRefs(selection),
     1:                                 getter_AddRefs(table), 
     1:                                 getter_AddRefs(curCell), 
     1:                                 nsnull, nsnull,
     1:                                 &startRowIndex, &startColIndex);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // Don't fail if no cell found
 43806:   NS_ENSURE_TRUE(curCell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:   // Get more data for current cell (we need ROWSPAN)
     1:   PRInt32 curStartRowIndex, curStartColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1:   res = GetCellDataAt(table, startRowIndex, startColIndex,
     1:                       getter_AddRefs(curCell),
     1:                       &curStartRowIndex, &curStartColIndex,
     1:                       &rowSpan, &colSpan, 
     1:                       &actualRowSpan, &actualColSpan, &isSelected);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(curCell, NS_ERROR_FAILURE);
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   // Prevent auto insertion of BR in new cell until we're done
     1:   nsAutoRules beginRulesSniffing(this, kOpInsertNode, nsIEditor::eNext);
     1: 
     1:   // Use column after current cell if requested
     1:   if (aAfter)
     1:   {
     1:     startColIndex += actualColSpan;
     1:     //Detect when user is adding after a COLSPAN=0 case
     1:     // Assume they want to stop the "0" behavior and
     1:     // really add a new column. Thus we set the 
     1:     // colspan to its true value
     1:     if (colSpan == 0)
     1:       SetColSpan(curCell, actualColSpan);
     1:   }
     1:    
     1:   PRInt32 rowCount, colCount, rowIndex;
     1:   res = GetTableSize(table, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   //We reset caret in destructor...
 80486:   nsSetSelectionAfterTableEdit setCaret(this, table, startRowIndex, startColIndex, ePreviousRow, false);
     1:   //.. so suppress Rules System selection munging
     1:   nsAutoTxnsConserveSelection dontChangeSelection(this);
     1: 
     1:   // If we are inserting after all existing columns
     1:   // Make sure table is "well formed"
     1:   //  before appending new column
     1:   if (startColIndex >= colCount)
     1:     NormalizeTable(table);
     1: 
     1:   nsCOMPtr<nsIDOMNode> rowNode;
     1:   for ( rowIndex = 0; rowIndex < rowCount; rowIndex++)
     1:   {
     1: #ifdef DEBUG_cmanske
     1:     if (rowIndex == rowCount-1)
     1:       printf(" ***InsertTableColumn: Inserting cell at last row: %d\n", rowIndex);
     1: #endif
     1: 
     1:     if (startColIndex < colCount)
     1:     {
     1:       // We are inserting before an existing column
     1:       res = GetCellDataAt(table, rowIndex, startColIndex,
     1:                           getter_AddRefs(curCell),
     1:                           &curStartRowIndex, &curStartColIndex,
     1:                           &rowSpan, &colSpan, 
     1:                           &actualRowSpan, &actualColSpan, &isSelected);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       // Don't fail entire process if we fail to find a cell
     1:       //  (may fail just in particular rows with < adequate cells per row)
     1:       if (curCell)
     1:       {
     1:         if (curStartColIndex < startColIndex)
     1:         {
     1:           // We have a cell spanning this location
     1:           // Simply increase its colspan to keep table rectangular
     1:           // Note: we do nothing if colsSpan=0,
     1:           //  since it should automatically span the new column
     1:           if (colSpan > 0)
     1:             SetColSpan(curCell, colSpan+aNumber);
     1:         } else {
     1:           // Simply set selection to the current cell 
     1:           //  so we can let InsertTableCell() do the work
     1:           // Insert a new cell before current one
     1:           selection->Collapse(curCell, 0);
 80486:           res = InsertTableCell(aNumber, false);
     1:         }
     1:       }
     1:     } else {
     1:       // Get current row and append new cells after last cell in row
     1:       if(rowIndex == 0)
     1:         res = GetFirstRow(table.get(), getter_AddRefs(rowNode));
     1:       else
     1:       {
     1:         nsCOMPtr<nsIDOMNode> nextRow;
     1:         res = GetNextRow(rowNode.get(), getter_AddRefs(nextRow));
     1:         rowNode = nextRow;
     1:       }
 43805:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       if (rowNode)
     1:       {
     1:         nsCOMPtr<nsIDOMNode> lastCell;
     1:         res = GetLastCellInRow(rowNode, getter_AddRefs(lastCell));
 43805:         NS_ENSURE_SUCCESS(res, res);
 43806:         NS_ENSURE_TRUE(lastCell, NS_ERROR_FAILURE);
     1: 
     1:         curCell = do_QueryInterface(lastCell);
     1:         if (curCell)
     1:         {
     1:           // Simply add same number of cells to each row
     1:           // Although tempted to check cell indexes for curCell,
     1:           //  the effects of COLSPAN>1 in some cells makes this futile!
     1:           // We must use NormalizeTable first to assure
     1:           //  that there are cells in each cellmap location
     1:           selection->Collapse(curCell, 0);
 80486:           res = InsertTableCell(aNumber, true);
     1:         }
     1:       }
     1:     }
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::InsertTableRow(PRInt32 aNumber, bool aAfter)
     1: {
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   nsCOMPtr<nsIDOMElement> curCell;
     1:   
     1:   PRInt32 startRowIndex, startColIndex;
     1:   nsresult res = GetCellContext(nsnull,
     1:                                 getter_AddRefs(table), 
     1:                                 getter_AddRefs(curCell), 
     1:                                 nsnull, nsnull, 
     1:                                 &startRowIndex, &startColIndex);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // Don't fail if no cell found
 43806:   NS_ENSURE_TRUE(curCell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:   // Get more data for current cell in row we are inserting at (we need COLSPAN)
     1:   PRInt32 curStartRowIndex, curStartColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1:   res = GetCellDataAt(table, startRowIndex, startColIndex,
     1:                       getter_AddRefs(curCell),
     1:                       &curStartRowIndex, &curStartColIndex,
     1:                       &rowSpan, &colSpan, 
     1:                       &actualRowSpan, &actualColSpan, &isSelected);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(curCell, NS_ERROR_FAILURE);
     1:   
     1:   PRInt32 rowCount, colCount;
     1:   res = GetTableSize(table, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   // Prevent auto insertion of BR in new cell until we're done
     1:   nsAutoRules beginRulesSniffing(this, kOpInsertNode, nsIEditor::eNext);
     1: 
     1:   if (aAfter)
     1:   {
     1:     // Use row after current cell
     1:     startRowIndex += actualRowSpan;
     1: 
     1:     //Detect when user is adding after a ROWSPAN=0 case
     1:     // Assume they want to stop the "0" behavior and
     1:     // really add a new row. Thus we set the 
     1:     // rowspan to its true value
     1:     if (rowSpan == 0)
     1:       SetRowSpan(curCell, actualRowSpan);
     1:   }
     1: 
     1:   //We control selection resetting after the insert...
 80486:   nsSetSelectionAfterTableEdit setCaret(this, table, startRowIndex, startColIndex, ePreviousColumn, false);
     1:   //...so suppress Rules System selection munging
     1:   nsAutoTxnsConserveSelection dontChangeSelection(this);
     1: 
     1:   nsCOMPtr<nsIDOMElement> cellForRowParent;
     1:   PRInt32 cellsInRow = 0;
     1:   if (startRowIndex < rowCount)
     1:   {
     1:     // We are inserting above an existing row
     1:     // Get each cell in the insert row to adjust for COLSPAN effects while we
     1:     //   count how many cells are needed
     1:     PRInt32 colIndex = 0;
     1:     // This returns NS_TABLELAYOUT_CELL_NOT_FOUND when we run past end of row,
     1:     //   which passes the NS_SUCCEEDED macro
     1:     while ( NS_OK == GetCellDataAt(table, startRowIndex, colIndex,
     1:                                    getter_AddRefs(curCell), 
     1:                                    &curStartRowIndex, &curStartColIndex,
     1:                                    &rowSpan, &colSpan, 
     1:                                    &actualRowSpan, &actualColSpan,
     1:                                    &isSelected) )
     1:     {
     1:       if (curCell)
     1:       {
     1:         if (curStartRowIndex < startRowIndex)
     1:         {
     1:           // We have a cell spanning this location
     1:           // Simply increase its rowspan
     1:           //Note that if rowSpan == 0, we do nothing,
     1:           //  since that cell should automatically extend into the new row
     1:           if (rowSpan > 0)
     1:             SetRowSpan(curCell, rowSpan+aNumber);
     1:         } else {
     1:           // We have a cell in the insert row
     1: 
     1:           // Count the number of cells we need to add to the new row
     1:           cellsInRow += actualColSpan;
     1: 
     1:           // Save cell we will use below
     1:           if (!cellForRowParent)
     1:             cellForRowParent = curCell;
     1:         }
     1:         // Next cell in row
     1:         colIndex += actualColSpan;
     1:       }
     1:       else
     1:         colIndex++;
     1:     }
     1:   } else {
     1:     // We are adding a new row after all others
     1:     // If it weren't for colspan=0 effect, 
     1:     // we could simply use colCount for number of new cells...
     1:     cellsInRow = colCount;
     1:     
     1:     // ...but we must compensate for all cells with rowSpan = 0 in the last row
     1:     PRInt32 lastRow = rowCount-1;
     1:     PRInt32 tempColIndex = 0;
     1:     while ( NS_OK == GetCellDataAt(table, lastRow, tempColIndex,
     1:                                    getter_AddRefs(curCell), 
     1:                                    &curStartRowIndex, &curStartColIndex,
     1:                                    &rowSpan, &colSpan, 
     1:                                    &actualRowSpan, &actualColSpan,
     1:                                    &isSelected) )
     1:     {
     1:       if (rowSpan == 0)
     1:         cellsInRow -= actualColSpan;
     1:       
     1:       tempColIndex += actualColSpan;
     1: 
     1:       // Save cell from the last row that we will use below
     1:       if (!cellForRowParent && curStartRowIndex == lastRow)
     1:         cellForRowParent = curCell;
     1:     }
     1:   }
     1: 
     1:   if (cellsInRow > 0)
     1:   {
     1:     // The row parent and offset where we will insert new row
     1:     nsCOMPtr<nsIDOMNode> parentOfRow;
     1:     PRInt32 newRowOffset;
     1: 
     1:     NS_NAMED_LITERAL_STRING(trStr, "tr");
     1:     if (cellForRowParent)
     1:     {
     1:       nsCOMPtr<nsIDOMElement> parentRow;
     1:       res = GetElementOrParentByTagName(trStr, cellForRowParent, getter_AddRefs(parentRow));
 43805:       NS_ENSURE_SUCCESS(res, res);
 43806:       NS_ENSURE_TRUE(parentRow, NS_ERROR_NULL_POINTER);
     1: 
     1:       parentRow->GetParentNode(getter_AddRefs(parentOfRow));
 43806:       NS_ENSURE_TRUE(parentOfRow, NS_ERROR_NULL_POINTER);
     1: 
103677:       newRowOffset = GetChildOffset(parentRow, parentOfRow);
     1:       
     1:       // Adjust for when adding past the end 
     1:       if (aAfter && startRowIndex >= rowCount)
     1:         newRowOffset++;
     1:     }
     1:     else
     1:       return NS_ERROR_FAILURE;
     1: 
     1:     for (PRInt32 row = 0; row < aNumber; row++)
     1:     {
     1:       // Create a new row
     1:       nsCOMPtr<nsIDOMElement> newRow;
     1:       res = CreateElementWithDefaults(trStr, getter_AddRefs(newRow));
     1:       if (NS_SUCCEEDED(res))
     1:       {
 43806:         NS_ENSURE_TRUE(newRow, NS_ERROR_FAILURE);
     1:       
     1:         for (PRInt32 i = 0; i < cellsInRow; i++)
     1:         {
     1:           nsCOMPtr<nsIDOMElement> newCell;
     1:           res = CreateElementWithDefaults(NS_LITERAL_STRING("td"), getter_AddRefs(newCell));
 43805:           NS_ENSURE_SUCCESS(res, res);
 43806:           NS_ENSURE_TRUE(newCell, NS_ERROR_FAILURE);
     1: 
     1:           // Don't use transaction system yet! (not until entire row is inserted)
     1:           nsCOMPtr<nsIDOMNode>resultNode;
     1:           res = newRow->AppendChild(newCell, getter_AddRefs(resultNode));
 43805:           NS_ENSURE_SUCCESS(res, res);
     1:         }
     1:         // Use transaction system to insert the entire row+cells
     1:         // (Note that rows are inserted at same childoffset each time)
     1:         res = InsertNode(newRow, parentOfRow, newRowOffset);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:     }
     1:   }
     1:   return res;
     1: }
     1: 
     1: // Editor helper only
     1: // XXX Code changed for bug 217717 and now we don't need aSelection param
     1: //     TODO: Remove aSelection param
     1: NS_IMETHODIMP
     1: nsHTMLEditor::DeleteTable2(nsIDOMElement *aTable, nsISelection *aSelection)
     1: {
 43806:   NS_ENSURE_TRUE(aTable, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Select the table
     1:   nsresult res = ClearSelection();
     1:   if (NS_SUCCEEDED(res))
     1:     res = AppendNodeToSelectionAsRange(aTable);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
 98852:   return DeleteSelection(nsIEditor::eNext, nsIEditor::eStrip);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::DeleteTable()
     1: {
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   nsresult res = GetCellContext(getter_AddRefs(selection),
     1:                                 getter_AddRefs(table), 
     1:                                 nsnull, nsnull, nsnull, nsnull, nsnull);
     1:     
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   return DeleteTable2(table, selection);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::DeleteTableCell(PRInt32 aNumber)
     1: {
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   PRInt32 startRowIndex, startColIndex;
     1: 
     1: 
     1:   nsresult res = GetCellContext(getter_AddRefs(selection),
     1:                          getter_AddRefs(table), 
     1:                          getter_AddRefs(cell), 
     1:                          nsnull, nsnull,
     1:                          &startRowIndex, &startColIndex);
     1: 
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // Don't fail if we didn't find a table or cell
 43806:   NS_ENSURE_TRUE(table && cell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   // Prevent rules testing until we're done
     1:   nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
     1: 
     1:   nsCOMPtr<nsIDOMElement> firstCell;
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   res = GetFirstSelectedCell(getter_AddRefs(range), getter_AddRefs(firstCell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   PRInt32 rangeCount;
     1:   res = selection->GetRangeCount(&rangeCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   if (firstCell && rangeCount > 1)
     1:   {
     1:     // When > 1 selected cell,
     1:     //  ignore aNumber and use selected cells
     1:     cell = firstCell;
     1: 
     1:     PRInt32 rowCount, colCount;
     1:     res = GetTableSize(table, &rowCount, &colCount);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     // Get indexes -- may be different than original cell
     1:     res = GetCellIndexes(cell, &startRowIndex, &startColIndex);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
 90153:     // The setCaret object will call SetSelectionAfterTableEdit in its destructor
 80486:     nsSetSelectionAfterTableEdit setCaret(this, table, startRowIndex, startColIndex, ePreviousColumn, false);
     1:     nsAutoTxnsConserveSelection dontChangeSelection(this);
     1: 
 79445:     bool    checkToDeleteRow = true;
 79445:     bool    checkToDeleteColumn = true;
     1:     while (cell)
     1:     {
 79445:       bool deleteRow = false;
 79445:       bool deleteCol = false;
     1: 
     1:       if (checkToDeleteRow)
     1:       {
     1:         // Optimize to delete an entire row
     1:         // Clear so we don't repeat AllCellsInRowSelected within the same row
 80486:         checkToDeleteRow = false;
     1: 
     1:         deleteRow = AllCellsInRowSelected(table, startRowIndex, colCount);
     1:         if (deleteRow)
     1:         {
     1:           // First, find the next cell in a different row
     1:           //   to continue after we delete this row
     1:           PRInt32 nextRow = startRowIndex;
     1:           while (nextRow == startRowIndex)
     1:           {
     1:             res = GetNextSelectedCell(nsnull, getter_AddRefs(cell));
 43805:             NS_ENSURE_SUCCESS(res, res);
     1:             if (!cell) break;
     1:             res = GetCellIndexes(cell, &nextRow, &startColIndex);
 43805:             NS_ENSURE_SUCCESS(res, res);
     1:           }
     1:           // Delete entire row
     1:           res = DeleteRow(table, startRowIndex);          
 43805:           NS_ENSURE_SUCCESS(res, res);
     1: 
     1:           if (cell)
     1:           {
     1:             // For the next cell: Subtract 1 for row we deleted
     1:             startRowIndex = nextRow - 1;
     1:             // Set true since we know we will look at a new row next
 80486:             checkToDeleteRow = true;
     1:           }
     1:         }
     1:       }
     1:       if (!deleteRow)
     1:       {
     1:         if (checkToDeleteColumn)
     1:         {
     1:           // Optimize to delete an entire column
     1:           // Clear this so we don't repeat AllCellsInColSelected within the same Col
 80486:           checkToDeleteColumn = false;
     1: 
     1:           deleteCol = AllCellsInColumnSelected(table, startColIndex, colCount);
     1:           if (deleteCol)
     1:           {
     1:             // First, find the next cell in a different column
     1:             //   to continue after we delete this column
     1:             PRInt32 nextCol = startColIndex;
     1:             while (nextCol == startColIndex)
     1:             {
     1:               res = GetNextSelectedCell(nsnull, getter_AddRefs(cell));
 43805:               NS_ENSURE_SUCCESS(res, res);
     1:               if (!cell) break;
     1:               res = GetCellIndexes(cell, &startRowIndex, &nextCol);
 43805:               NS_ENSURE_SUCCESS(res, res);
     1:             }
     1:             // Delete entire Col
     1:             res = DeleteColumn(table, startColIndex);          
 43805:             NS_ENSURE_SUCCESS(res, res);
     1:             if (cell) 
     1:             {
     1:               // For the next cell, subtract 1 for col. deleted
     1:               startColIndex = nextCol - 1;
     1:               // Set true since we know we will look at a new column next
 80486:               checkToDeleteColumn = true;
     1:             }
     1:           }
     1:         }
     1:         if (!deleteCol)
     1:         {
     1:           // First get the next cell to delete
     1:           nsCOMPtr<nsIDOMElement> nextCell;
     1:           res = GetNextSelectedCell(getter_AddRefs(range), getter_AddRefs(nextCell));
 43805:           NS_ENSURE_SUCCESS(res, res);
     1: 
     1:           // Then delete the cell
     1:           res = DeleteNode(cell);
 43805:           NS_ENSURE_SUCCESS(res, res);
     1:           
     1:           // The next cell to delete
     1:           cell = nextCell;
     1:           if (cell)
     1:           {
     1:             res = GetCellIndexes(cell, &startRowIndex, &startColIndex);
 43805:             NS_ENSURE_SUCCESS(res, res);
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1:   else for (PRInt32 i = 0; i < aNumber; i++)
     1:   {
     1:     res = GetCellContext(getter_AddRefs(selection),
     1:                          getter_AddRefs(table), 
     1:                          getter_AddRefs(cell), 
     1:                          nsnull, nsnull,
     1:                          &startRowIndex, &startColIndex);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     // Don't fail if no cell found
 43806:     NS_ENSURE_TRUE(cell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:     if (1 == GetNumberOfCellsInRow(table, startRowIndex))
     1:     {
     1:       nsCOMPtr<nsIDOMElement> parentRow;
     1:       res = GetElementOrParentByTagName(NS_LITERAL_STRING("tr"), cell, getter_AddRefs(parentRow));
 43805:       NS_ENSURE_SUCCESS(res, res);
 43806:       NS_ENSURE_TRUE(parentRow, NS_ERROR_NULL_POINTER);
     1: 
     1:       // We should delete the row instead,
     1:       //  but first check if its the only row left
     1:       //  so we can delete the entire table
     1:       PRInt32 rowCount, colCount;
     1:       res = GetTableSize(table, &rowCount, &colCount);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       
     1:       if (rowCount == 1)
     1:         return DeleteTable2(table, selection);
     1:     
     1:       // We need to call DeleteTableRow to handle cells with rowspan 
     1:       res = DeleteTableRow(1);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     } 
     1:     else
     1:     {
     1:       // More than 1 cell in the row
     1: 
 90153:       // The setCaret object will call SetSelectionAfterTableEdit in its destructor
 80486:       nsSetSelectionAfterTableEdit setCaret(this, table, startRowIndex, startColIndex, ePreviousColumn, false);
     1:       nsAutoTxnsConserveSelection dontChangeSelection(this);
     1: 
     1:       res = DeleteNode(cell);
     1:       // If we fail, don't try to delete any more cells???
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::DeleteTableCellContents()
     1: {
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   PRInt32 startRowIndex, startColIndex;
     1:   nsresult res;
     1:   res = GetCellContext(getter_AddRefs(selection),
     1:                        getter_AddRefs(table), 
     1:                        getter_AddRefs(cell), 
     1:                        nsnull, nsnull,
     1:                        &startRowIndex, &startColIndex);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // Don't fail if no cell found
 43806:   NS_ENSURE_TRUE(cell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   // Prevent rules testing until we're done
     1:   nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
     1:   //Don't let Rules System change the selection
     1:   nsAutoTxnsConserveSelection dontChangeSelection(this);
     1: 
     1: 
     1:   nsCOMPtr<nsIDOMElement> firstCell;
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   res = GetFirstSelectedCell(getter_AddRefs(range), getter_AddRefs(firstCell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1: 
     1:   if (firstCell)
     1:   {
     1:     cell = firstCell;
     1:     res = GetCellIndexes(cell, &startRowIndex, &startColIndex);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1: 
 80486:   nsSetSelectionAfterTableEdit setCaret(this, table, startRowIndex, startColIndex, ePreviousColumn, false);
     1: 
     1:   while (cell)
     1:   {
     1:     DeleteCellContents(cell);
     1:     if (firstCell)
     1:     {
     1:       // We doing a selected cells, so do all of them
     1:       res = GetNextSelectedCell(nsnull, getter_AddRefs(cell));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1:     else
     1:       cell = nsnull;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::DeleteCellContents(nsIDOMElement *aCell)
     1: {
 43806:   NS_ENSURE_TRUE(aCell, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Prevent rules testing until we're done
     1:   nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
     1: 
     1:   nsCOMPtr<nsIDOMNode> child;
 79445:   bool hasChild;
     1:   aCell->HasChildNodes(&hasChild);
     1: 
     1:   while (hasChild)
     1:   {
     1:     aCell->GetLastChild(getter_AddRefs(child));
     1:     nsresult res = DeleteNode(child);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     aCell->HasChildNodes(&hasChild);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::DeleteTableColumn(PRInt32 aNumber)
     1: {
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   PRInt32 startRowIndex, startColIndex, rowCount, colCount;
     1:   nsresult res = GetCellContext(getter_AddRefs(selection),
     1:                                 getter_AddRefs(table), 
     1:                                 getter_AddRefs(cell), 
     1:                                 nsnull, nsnull,
     1:                                 &startRowIndex, &startColIndex);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // Don't fail if no cell found
 43806:   NS_ENSURE_TRUE(table && cell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:   res = GetTableSize(table, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // Shortcut the case of deleting all columns in table
     1:   if(startColIndex == 0 && aNumber >= colCount)
     1:     return DeleteTable2(table, selection);
     1: 
     1:   // Check for counts too high
 38053:   aNumber = NS_MIN(aNumber,(colCount-startColIndex));
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   // Prevent rules testing until we're done
     1:   nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
     1: 
     1:   // Test if deletion is controlled by selected cells
     1:   nsCOMPtr<nsIDOMElement> firstCell;
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   res = GetFirstSelectedCell(getter_AddRefs(range), getter_AddRefs(firstCell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   PRInt32 rangeCount;
     1:   res = selection->GetRangeCount(&rangeCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   if (firstCell && rangeCount > 1)
     1:   {
     1:     // Fetch indexes again - may be different for selected cells
     1:     res = GetCellIndexes(firstCell, &startRowIndex, &startColIndex);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1:   //We control selection resetting after the insert...
 80486:   nsSetSelectionAfterTableEdit setCaret(this, table, startRowIndex, startColIndex, ePreviousRow, false);
     1: 
     1:   if (firstCell && rangeCount > 1)
     1:   {
     1:     // Use selected cells to determine what rows to delete
     1:     cell = firstCell;
     1: 
     1:     while (cell)
     1:     {
     1:       if (cell != firstCell)
     1:       {
     1:         res = GetCellIndexes(cell, &startRowIndex, &startColIndex);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:       // Find the next cell in a different column
     1:       // to continue after we delete this column
     1:       PRInt32 nextCol = startColIndex;
     1:       while (nextCol == startColIndex)
     1:       {
     1:         res = GetNextSelectedCell(getter_AddRefs(range), getter_AddRefs(cell));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         if (!cell) break;
     1:         res = GetCellIndexes(cell, &startRowIndex, &nextCol);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:       res = DeleteColumn(table, startColIndex);          
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1:   }
     1:   else for (PRInt32 i = 0; i < aNumber; i++)
     1:   {
     1:     res = DeleteColumn(table, startColIndex);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::DeleteColumn(nsIDOMElement *aTable, PRInt32 aColIndex)
     1: {
 43806:   NS_ENSURE_TRUE(aTable, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   nsCOMPtr<nsIDOMElement> cellInDeleteCol;
     1:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1:   PRInt32 rowIndex = 0;
     1:   nsresult res = NS_OK;
     1:    
     1:   do {
     1:     res = GetCellDataAt(aTable, rowIndex, aColIndex, getter_AddRefs(cell),
     1:                         &startRowIndex, &startColIndex, &rowSpan, &colSpan, 
     1:                         &actualRowSpan, &actualColSpan, &isSelected);
     1: 
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     if (cell)
     1:     {
     1:       // Find cells that don't start in column we are deleting
     1:       if (startColIndex < aColIndex || colSpan > 1 || colSpan == 0)
     1:       {
     1:         // We have a cell spanning this location
     1:         // Decrease its colspan to keep table rectangular,
     1:         // but if colSpan=0, it will adjust automatically
     1:         if (colSpan > 0)
     1:         {
     1:           NS_ASSERTION((colSpan > 1),"Bad COLSPAN in DeleteTableColumn");
     1:           SetColSpan(cell, colSpan-1);
     1:         }
     1:         if (startColIndex == aColIndex)
     1:         {
     1:           // Cell is in column to be deleted, but must have colspan > 1,
     1:           // so delete contents of cell instead of cell itself
     1:           // (We must have reset colspan above)
     1:           DeleteCellContents(cell);
     1:         }
     1:         // To next cell in column
     1:         rowIndex += actualRowSpan;
     1:       } 
     1:       else 
     1:       {
     1:         // Delete the cell
     1:         if (1 == GetNumberOfCellsInRow(aTable, rowIndex))
     1:         {
     1:           // Only 1 cell in row - delete the row
     1:           nsCOMPtr<nsIDOMElement> parentRow;
     1:           res = GetElementOrParentByTagName(NS_LITERAL_STRING("tr"), cell, getter_AddRefs(parentRow));
 43805:           NS_ENSURE_SUCCESS(res, res);
     1:           if(!parentRow) return NS_ERROR_NULL_POINTER;
     1: 
     1:           //  But first check if its the only row left
     1:           //  so we can delete the entire table
     1:           //  (This should never happen but it's the safe thing to do)
     1:           PRInt32 rowCount, colCount;
     1:           res = GetTableSize(aTable, &rowCount, &colCount);
 43805:           NS_ENSURE_SUCCESS(res, res);
     1: 
     1:           if (rowCount == 1)
     1:           {
     1:             nsCOMPtr<nsISelection> selection;
     1:             res = GetSelection(getter_AddRefs(selection));
 43805:             NS_ENSURE_SUCCESS(res, res);
 43806:             NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1:             return DeleteTable2(aTable, selection);
     1:           }
     1:     
     1:           // Delete the row by placing caret in cell we were to delete
     1:           // We need to call DeleteTableRow to handle cells with rowspan 
     1:           res = DeleteRow(aTable, startRowIndex);
 43805:           NS_ENSURE_SUCCESS(res, res);
     1: 
     1:           // Note that we don't incremenet rowIndex
     1:           // since a row was deleted and "next" 
     1:           // row now has current rowIndex
     1:         } 
     1:         else 
     1:         {
     1:           // A more "normal" deletion
     1:           res = DeleteNode(cell);
 43805:           NS_ENSURE_SUCCESS(res, res);
     1: 
     1:           //Skip over any rows spanned by this cell
     1:           rowIndex += actualRowSpan;
     1:         }
     1:       }
     1:     }
     1:   } while (cell);    
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::DeleteTableRow(PRInt32 aNumber)
     1: {
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   PRInt32 startRowIndex, startColIndex;
     1:   PRInt32 rowCount, colCount;
     1:   nsresult res =  GetCellContext(getter_AddRefs(selection),
     1:                                  getter_AddRefs(table), 
     1:                                  getter_AddRefs(cell), 
     1:                                  nsnull, nsnull,
     1:                                  &startRowIndex, &startColIndex);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // Don't fail if no cell found
 43806:   NS_ENSURE_TRUE(cell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:   res = GetTableSize(table, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // Shortcut the case of deleting all rows in table
     1:   if(startRowIndex == 0 && aNumber >= rowCount)
     1:     return DeleteTable2(table, selection);
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   // Prevent rules testing until we're done
     1:   nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
     1: 
     1:   nsCOMPtr<nsIDOMElement> firstCell;
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   res = GetFirstSelectedCell(getter_AddRefs(range), getter_AddRefs(firstCell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   PRInt32 rangeCount;
     1:   res = selection->GetRangeCount(&rangeCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   if (firstCell && rangeCount > 1)
     1:   {
     1:     // Fetch indexes again - may be different for selected cells
     1:     res = GetCellIndexes(firstCell, &startRowIndex, &startColIndex);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1: 
     1:   //We control selection resetting after the insert...
 80486:   nsSetSelectionAfterTableEdit setCaret(this, table, startRowIndex, startColIndex, ePreviousRow, false);
     1:   // Don't change selection during deletions
     1:   nsAutoTxnsConserveSelection dontChangeSelection(this);
     1: 
     1:   if (firstCell && rangeCount > 1)
     1:   {
     1:     // Use selected cells to determine what rows to delete
     1:     cell = firstCell;
     1: 
     1:     while (cell)
     1:     {
     1:       if (cell != firstCell)
     1:       {
     1:         res = GetCellIndexes(cell, &startRowIndex, &startColIndex);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:       // Find the next cell in a different row
     1:       // to continue after we delete this row
     1:       PRInt32 nextRow = startRowIndex;
     1:       while (nextRow == startRowIndex)
     1:       {
     1:         res = GetNextSelectedCell(getter_AddRefs(range), getter_AddRefs(cell));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         if (!cell) break;
     1:         res = GetCellIndexes(cell, &nextRow, &startColIndex);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:       // Delete entire row
     1:       res = DeleteRow(table, startRowIndex);          
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1:   }
     1:   else
     1:   {
     1:     // Check for counts too high
 38053:     aNumber = NS_MIN(aNumber,(rowCount-startRowIndex));
     1: 
     1:     for (PRInt32 i = 0; i < aNumber; i++)
     1:     {
     1:       res = DeleteRow(table, startRowIndex);
     1:       // If failed in current row, try the next
     1:       if (NS_FAILED(res))
     1:         startRowIndex++;
     1:     
     1:       // Check if there's a cell in the "next" row
     1:       res = GetCellAt(table, startRowIndex, startColIndex, getter_AddRefs(cell));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       if(!cell)
     1:         break;
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: // Helper that doesn't batch or change the selection
     1: NS_IMETHODIMP
     1: nsHTMLEditor::DeleteRow(nsIDOMElement *aTable, PRInt32 aRowIndex)
     1: {
 43806:   NS_ENSURE_TRUE(aTable, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   nsCOMPtr<nsIDOMElement> cellInDeleteRow;
     1:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1:   PRInt32 colIndex = 0;
     1:   nsresult res = NS_OK;
     1:    
     1:   // Prevent rules testing until we're done
     1:   nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
     1: 
     1:   // The list of cells we will change rowspan in
     1:   //  and the new rowspan values for each
 27986:   nsTArray<nsIDOMElement*> spanCellList;
 27986:   nsTArray<PRInt32> newSpanList;
     1: 
     1:   // Scan through cells in row to do rowspan adjustments
     1:   // Note that after we delete row, startRowIndex will point to the
     1:   //   cells in the next row to be deleted
     1:   do {
     1:     res = GetCellDataAt(aTable, aRowIndex, colIndex, getter_AddRefs(cell),
     1:                         &startRowIndex, &startColIndex, &rowSpan, &colSpan, 
     1:                         &actualRowSpan, &actualColSpan, &isSelected);
     1:   
     1:     // We don't fail if we don't find a cell, so this must be real bad
     1:     if(NS_FAILED(res)) return res;
     1: 
     1:     // Compensate for cells that don't start or extend below the row we are deleting
     1:     if (cell)
     1:     {
     1:       if (startRowIndex < aRowIndex)
     1:       {
     1:         // Cell starts in row above us
     1:         // Decrease its rowspan to keep table rectangular
     1:         //  but we don't need to do this if rowspan=0,
     1:         //  since it will automatically adjust
     1:         if (rowSpan > 0)
     1:         {
     1:           // Build list of cells to change rowspan
     1:           // We can't do it now since it upsets cell map,
     1:           //  so we will do it after deleting the row
 27986:           spanCellList.AppendElement(cell);
 38053:           newSpanList.AppendElement(NS_MAX((aRowIndex - startRowIndex), actualRowSpan-1));
     1:         }
     1:       }
     1:       else 
     1:       {
     1:         if (rowSpan > 1)
     1:         {
     1:           //Cell spans below row to delete,
     1:           //  so we must insert new cells to keep rows below even
     1:           // Note that we test "rowSpan" so we don't do this if rowSpan = 0 (automatic readjustment)
     1:           res = SplitCellIntoRows(aTable, startRowIndex, startColIndex,
     1:                                   aRowIndex - startRowIndex + 1, // The row above the row to insert new cell into
     1:                                   actualRowSpan - 1, nsnull);    // Span remaining below
 43805:           NS_ENSURE_SUCCESS(res, res);
     1:         }
     1:         if (!cellInDeleteRow)
     1:           cellInDeleteRow = cell; // Reference cell to find row to delete
     1:       }
     1:       // Skip over other columns spanned by this cell
     1:       colIndex += actualColSpan;
     1:     }
     1:   } while (cell);
     1: 
     1:   // Things are messed up if we didn't find a cell in the row!
 43807:   NS_ENSURE_TRUE(cellInDeleteRow, NS_ERROR_FAILURE);
     1: 
     1:   // Delete the entire row
     1:   nsCOMPtr<nsIDOMElement> parentRow;
     1:   res = GetElementOrParentByTagName(NS_LITERAL_STRING("tr"), cellInDeleteRow, getter_AddRefs(parentRow));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   if (parentRow)
     1:   {
     1:     res = DeleteNode(parentRow);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1: 
     1:   // Now we can set new rowspans for cells stored above  
 27986:   for (PRUint32 i = 0, n = spanCellList.Length(); i < n; i++)
     1:   {
 27986:     nsIDOMElement *cellPtr = spanCellList[i];
     1:     if (cellPtr)
     1:     {
 27986:       res = SetRowSpan(cellPtr, newSpanList[i]);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SelectTable()
     1: {
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   nsresult res = NS_ERROR_FAILURE;
     1:   res = GetElementOrParentByTagName(NS_LITERAL_STRING("table"), nsnull, getter_AddRefs(table));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // Don't fail if we didn't find a table
 43806:   NS_ENSURE_TRUE(table, NS_OK);
     1: 
     1:   res = ClearSelection();
     1:   if (NS_SUCCEEDED(res))
     1:     res = AppendNodeToSelectionAsRange(table);
     1: 
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SelectTableCell()
     1: {
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   nsresult res = GetElementOrParentByTagName(NS_LITERAL_STRING("td"), nsnull, getter_AddRefs(cell));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(cell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:   res = ClearSelection();
     1:   if (NS_SUCCEEDED(res))
     1:     res = AppendNodeToSelectionAsRange(cell);
     1: 
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SelectBlockOfCells(nsIDOMElement *aStartCell, nsIDOMElement *aEndCell)
     1: {
 43806:   NS_ENSURE_TRUE(aStartCell && aEndCell, NS_ERROR_NULL_POINTER);
     1:   
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1: 
     1:   NS_NAMED_LITERAL_STRING(tableStr, "table");
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   res = GetElementOrParentByTagName(tableStr, aStartCell, getter_AddRefs(table));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(table, NS_ERROR_FAILURE);
     1: 
     1:   nsCOMPtr<nsIDOMElement> endTable;
     1:   res = GetElementOrParentByTagName(tableStr, aEndCell, getter_AddRefs(endTable));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(endTable, NS_ERROR_FAILURE);
     1:   
     1:   // We can only select a block if within the same table,
     1:   //  so do nothing if not within one table
     1:   if (table != endTable) return NS_OK;
     1: 
     1:   PRInt32 startRowIndex, startColIndex, endRowIndex, endColIndex;
     1: 
     1:   // Get starting and ending cells' location in the cellmap
     1:   res = GetCellIndexes(aStartCell, &startRowIndex, &startColIndex);
     1:   if(NS_FAILED(res)) return res;
     1: 
     1:   res = GetCellIndexes(aEndCell, &endRowIndex, &endColIndex);
     1:   if(NS_FAILED(res)) return res;
     1: 
     1:   // Suppress nsISelectionListener notification
     1:   //  until all selection changes are finished
 23637:   nsSelectionBatcherForTable selectionBatcher(selection);
     1: 
     1:   // Examine all cell nodes in current selection and 
     1:   //  remove those outside the new block cell region
 38053:   PRInt32 minColumn = NS_MIN(startColIndex, endColIndex);
 38053:   PRInt32 minRow    = NS_MIN(startRowIndex, endRowIndex);
 38053:   PRInt32 maxColumn   = NS_MAX(startColIndex, endColIndex);
 38053:   PRInt32 maxRow      = NS_MAX(startRowIndex, endRowIndex);
     1: 
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   PRInt32 currentRowIndex, currentColIndex;
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   res = GetFirstSelectedCell(getter_AddRefs(range), getter_AddRefs(cell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   if (res == NS_EDITOR_ELEMENT_NOT_FOUND) return NS_OK;
     1: 
     1:   while (cell)
     1:   {
     1:     res = GetCellIndexes(cell, &currentRowIndex, &currentColIndex);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     if (currentRowIndex < maxRow || currentRowIndex > maxRow || 
     1:         currentColIndex < maxColumn || currentColIndex > maxColumn)
     1:     {
     1:       selection->RemoveRange(range);
     1:       // Since we've removed the range, decrement pointer to next range
     1:       mSelectedCellIndex--;
     1:     }    
     1:     res = GetNextSelectedCell(getter_AddRefs(range), getter_AddRefs(cell));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1: 
     1:   PRInt32 rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1:   for (PRInt32 row = minRow; row <= maxRow; row++)
     1:   {
 38053:     for(PRInt32 col = minColumn; col <= maxColumn; col += NS_MAX(actualColSpan, 1))
     1:     {
     1:       res = GetCellDataAt(table, row, col, getter_AddRefs(cell),
     1:                           &currentRowIndex, &currentColIndex,
     1:                           &rowSpan, &colSpan, 
     1:                           &actualRowSpan, &actualColSpan, &isSelected);
     1:       if (NS_FAILED(res)) break;
     1:       // Skip cells that already selected or are spanned from previous locations
     1:       if (!isSelected && cell && row == currentRowIndex && col == currentColIndex)
     1:       {
     1:         res = AppendNodeToSelectionAsRange(cell);
     1:         if (NS_FAILED(res)) break;
     1:       }
     1:     }
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SelectAllTableCells()
     1: {
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   nsresult res = GetElementOrParentByTagName(NS_LITERAL_STRING("td"), nsnull, getter_AddRefs(cell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   // Don't fail if we didn't find a cell
 43806:   NS_ENSURE_TRUE(cell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:   nsCOMPtr<nsIDOMElement> startCell = cell;
     1:   
     1:   // Get parent table
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   res = GetElementOrParentByTagName(NS_LITERAL_STRING("table"), cell, getter_AddRefs(table));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   if(!table) return NS_ERROR_NULL_POINTER;
     1: 
     1:   PRInt32 rowCount, colCount;
     1:   res = GetTableSize(table, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsISelection> selection;
     1:   res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1: 
     1:   // Suppress nsISelectionListener notification
     1:   //  until all selection changes are finished
 23637:   nsSelectionBatcherForTable selectionBatcher(selection);
     1: 
     1:   // It is now safe to clear the selection
     1:   // BE SURE TO RESET IT BEFORE LEAVING!
     1:   res = ClearSelection();
     1: 
     1:   // Select all cells in the same column as current cell
 79445:   bool cellSelected = false;
     1:   PRInt32 rowSpan, colSpan, actualRowSpan, actualColSpan, currentRowIndex, currentColIndex;
 79445:   bool    isSelected;
     1:   for(PRInt32 row = 0; row < rowCount; row++)
     1:   {
 38053:     for(PRInt32 col = 0; col < colCount; col += NS_MAX(actualColSpan, 1))
     1:     {
     1:       res = GetCellDataAt(table, row, col, getter_AddRefs(cell),
     1:                           &currentRowIndex, &currentColIndex,
     1:                           &rowSpan, &colSpan, 
     1:                           &actualRowSpan, &actualColSpan, &isSelected);
     1:       if (NS_FAILED(res)) break;
     1:       // Skip cells that are spanned from previous rows or columns
     1:       if (cell && row == currentRowIndex && col == currentColIndex)
     1:       {
     1:         res =  AppendNodeToSelectionAsRange(cell);
     1:         if (NS_FAILED(res)) break;
 80486:         cellSelected = true;
     1:       }
     1:     }
     1:   }
     1:   // Safety code to select starting cell if nothing else was selected
     1:   if (!cellSelected)
     1:   {
     1:     return AppendNodeToSelectionAsRange(startCell);
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SelectTableRow()
     1: {
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   nsresult res = GetElementOrParentByTagName(NS_LITERAL_STRING("td"), nsnull, getter_AddRefs(cell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   // Don't fail if we didn't find a cell
 43806:   NS_ENSURE_TRUE(cell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1:   nsCOMPtr<nsIDOMElement> startCell = cell;
     1: 
     1:   // Get table and location of cell:
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   PRInt32 startRowIndex, startColIndex;
     1: 
     1:   res = GetCellContext(getter_AddRefs(selection),
     1:                        getter_AddRefs(table), 
     1:                        getter_AddRefs(cell),
     1:                        nsnull, nsnull,
     1:                        &startRowIndex, &startColIndex);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(table, NS_ERROR_FAILURE);
     1:   
     1:   PRInt32 rowCount, colCount;
     1:   res = GetTableSize(table, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   //Note: At this point, we could get first and last cells in row,
     1:   //  then call SelectBlockOfCells, but that would take just
     1:   //  a little less code, so the following is more efficient
     1: 
     1:   // Suppress nsISelectionListener notification
     1:   //  until all selection changes are finished
 23637:   nsSelectionBatcherForTable selectionBatcher(selection);
     1: 
     1:   // It is now safe to clear the selection
     1:   // BE SURE TO RESET IT BEFORE LEAVING!
     1:   res = ClearSelection();
     1: 
     1:   // Select all cells in the same row as current cell
 79445:   bool cellSelected = false;
     1:   PRInt32 rowSpan, colSpan, actualRowSpan, actualColSpan, currentRowIndex, currentColIndex;
 79445:   bool    isSelected;
 38053:   for(PRInt32 col = 0; col < colCount; col += NS_MAX(actualColSpan, 1))
     1:   {
     1:     res = GetCellDataAt(table, startRowIndex, col, getter_AddRefs(cell),
     1:                         &currentRowIndex, &currentColIndex, &rowSpan, &colSpan, 
     1:                         &actualRowSpan, &actualColSpan, &isSelected);
     1:     if (NS_FAILED(res)) break;
     1:     // Skip cells that are spanned from previous rows or columns
     1:     if (cell && currentRowIndex == startRowIndex && currentColIndex == col)
     1:     {
     1:       res = AppendNodeToSelectionAsRange(cell);
     1:       if (NS_FAILED(res)) break;
 80486:       cellSelected = true;
     1:     }
     1:   }
     1:   // Safety code to select starting cell if nothing else was selected
     1:   if (!cellSelected)
     1:   {
     1:     return AppendNodeToSelectionAsRange(startCell);
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SelectTableColumn()
     1: {
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   nsresult res = GetElementOrParentByTagName(NS_LITERAL_STRING("td"), nsnull, getter_AddRefs(cell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   // Don't fail if we didn't find a cell
 43806:   NS_ENSURE_TRUE(cell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:   nsCOMPtr<nsIDOMElement> startCell = cell;
     1:   
     1:   // Get location of cell:
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   PRInt32 startRowIndex, startColIndex;
     1: 
     1:   res = GetCellContext(getter_AddRefs(selection),
     1:                        getter_AddRefs(table), 
     1:                        getter_AddRefs(cell),
     1:                        nsnull, nsnull,
     1:                        &startRowIndex, &startColIndex);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(table, NS_ERROR_FAILURE);
     1: 
     1:   PRInt32 rowCount, colCount;
     1:   res = GetTableSize(table, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // Suppress nsISelectionListener notification
     1:   //  until all selection changes are finished
 23637:   nsSelectionBatcherForTable selectionBatcher(selection);
     1: 
     1:   // It is now safe to clear the selection
     1:   // BE SURE TO RESET IT BEFORE LEAVING!
     1:   res = ClearSelection();
     1: 
     1:   // Select all cells in the same column as current cell
 79445:   bool cellSelected = false;
     1:   PRInt32 rowSpan, colSpan, actualRowSpan, actualColSpan, currentRowIndex, currentColIndex;
 79445:   bool    isSelected;
 38053:   for(PRInt32 row = 0; row < rowCount; row += NS_MAX(actualRowSpan, 1))
     1:   {
     1:     res = GetCellDataAt(table, row, startColIndex, getter_AddRefs(cell),
     1:                         &currentRowIndex, &currentColIndex, &rowSpan, &colSpan, 
     1:                         &actualRowSpan, &actualColSpan, &isSelected);
     1:     if (NS_FAILED(res)) break;
     1:     // Skip cells that are spanned from previous rows or columns
     1:     if (cell && currentRowIndex == row && currentColIndex == startColIndex)
     1:     {
     1:       res = AppendNodeToSelectionAsRange(cell);
     1:       if (NS_FAILED(res)) break;
 80486:       cellSelected = true;
     1:     }
     1:   }
     1:   // Safety code to select starting cell if nothing else was selected
     1:   if (!cellSelected)
     1:   {
     1:     return AppendNodeToSelectionAsRange(startCell);
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SplitTableCell()
     1: {
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   PRInt32 startRowIndex, startColIndex, actualRowSpan, actualColSpan;
     1:   // Get cell, table, etc. at selection anchor node
     1:   nsresult res = GetCellContext(nsnull,
     1:                                 getter_AddRefs(table), 
     1:                                 getter_AddRefs(cell),
     1:                                 nsnull, nsnull,
     1:                                 &startRowIndex, &startColIndex);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   if(!table || !cell) return NS_EDITOR_ELEMENT_NOT_FOUND;
     1: 
     1:   // We need rowspan and colspan data
     1:   res = GetCellSpansAt(table, startRowIndex, startColIndex, actualRowSpan, actualColSpan);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // Must have some span to split
     1:   if (actualRowSpan <= 1 && actualColSpan <= 1)
     1:     return NS_OK;
     1:   
     1:   nsAutoEditBatch beginBatching(this);
     1:   // Prevent auto insertion of BR in new cell until we're done
     1:   nsAutoRules beginRulesSniffing(this, kOpInsertNode, nsIEditor::eNext);
     1: 
     1:   // We reset selection  
 80486:   nsSetSelectionAfterTableEdit setCaret(this, table, startRowIndex, startColIndex, ePreviousColumn, false);
     1:   //...so suppress Rules System selection munging
     1:   nsAutoTxnsConserveSelection dontChangeSelection(this);
     1: 
     1:   nsCOMPtr<nsIDOMElement> newCell;
     1:   PRInt32 rowIndex = startRowIndex;
     1:   PRInt32 rowSpanBelow, colSpanAfter;
     1: 
     1:   // Split up cell row-wise first into rowspan=1 above, and the rest below,
     1:   //  whittling away at the cell below until no more extra span
     1:   for (rowSpanBelow = actualRowSpan-1; rowSpanBelow >= 0; rowSpanBelow--)
     1:   {
     1:     // We really split row-wise only if we had rowspan > 1
     1:     if (rowSpanBelow > 0)
     1:     {
     1:       res = SplitCellIntoRows(table, rowIndex, startColIndex, 1, rowSpanBelow, getter_AddRefs(newCell));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       CopyCellBackgroundColor(newCell, cell);
     1:     }
     1:     PRInt32 colIndex = startColIndex;
     1:     // Now split the cell with rowspan = 1 into cells if it has colSpan > 1
     1:     for (colSpanAfter = actualColSpan-1; colSpanAfter > 0; colSpanAfter--)
     1:     {
     1:       res = SplitCellIntoColumns(table, rowIndex, colIndex, 1, colSpanAfter, getter_AddRefs(newCell));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       CopyCellBackgroundColor(newCell, cell);
     1:       colIndex++;
     1:     }
     1:     // Point to the new cell and repeat
     1:     rowIndex++;
     1:   }
     1:   return res;
     1: }
     1: 
     1: nsresult
     1: nsHTMLEditor::CopyCellBackgroundColor(nsIDOMElement *destCell, nsIDOMElement *sourceCell)
     1: {
 43806:   NS_ENSURE_TRUE(destCell && sourceCell, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Copy backgournd color to new cell
     1:   NS_NAMED_LITERAL_STRING(bgcolor, "bgcolor");
     1:   nsAutoString color;
 79445:   bool isSet;
     1:   nsresult res = GetAttributeValue(sourceCell, bgcolor, color, &isSet);
     1: 
     1:   if (NS_SUCCEEDED(res) && isSet)
     1:     res = SetAttribute(destCell, bgcolor, color);
     1: 
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SplitCellIntoColumns(nsIDOMElement *aTable, PRInt32 aRowIndex, PRInt32 aColIndex,
     1:                                    PRInt32 aColSpanLeft, PRInt32 aColSpanRight,
     1:                                    nsIDOMElement **aNewCell)
     1: {
 43806:   NS_ENSURE_TRUE(aTable, NS_ERROR_NULL_POINTER);
     1:   if (aNewCell) *aNewCell = nsnull;
     1: 
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1:   nsresult res = GetCellDataAt(aTable, aRowIndex, aColIndex, getter_AddRefs(cell),
     1:                                &startRowIndex, &startColIndex,
     1:                                &rowSpan, &colSpan, 
     1:                                &actualRowSpan, &actualColSpan, &isSelected);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(cell, NS_ERROR_NULL_POINTER);
     1:   
     1:   // We can't split!
     1:   if (actualColSpan <= 1 || (aColSpanLeft + aColSpanRight) > actualColSpan)
     1:     return NS_OK;
     1: 
     1:   // Reduce colspan of cell to split
     1:   res = SetColSpan(cell, aColSpanLeft);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   // Insert new cell after using the remaining span
     1:   //  and always get the new cell so we can copy the background color;
     1:   nsCOMPtr<nsIDOMElement> newCell;
 80486:   res = InsertCell(cell, actualRowSpan, aColSpanRight, true, false, getter_AddRefs(newCell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   if (newCell)
     1:   {
     1:     if (aNewCell)
     1:     {
     1:       *aNewCell = newCell.get();
     1:       NS_ADDREF(*aNewCell);
     1:     }
     1:     res = CopyCellBackgroundColor(newCell, cell);
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::SplitCellIntoRows(nsIDOMElement *aTable, PRInt32 aRowIndex, PRInt32 aColIndex,
     1:                                 PRInt32 aRowSpanAbove, PRInt32 aRowSpanBelow, 
     1:                                 nsIDOMElement **aNewCell)
     1: {
 43806:   NS_ENSURE_TRUE(aTable, NS_ERROR_NULL_POINTER);
     1:   if (aNewCell) *aNewCell = nsnull;
     1: 
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1:   nsresult res = GetCellDataAt(aTable, aRowIndex, aColIndex, getter_AddRefs(cell),
     1:                                &startRowIndex, &startColIndex,
     1:                                &rowSpan, &colSpan, 
     1:                                &actualRowSpan, &actualColSpan, &isSelected);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(cell, NS_ERROR_NULL_POINTER);
     1:   
     1:   // We can't split!
     1:   if (actualRowSpan <= 1 || (aRowSpanAbove + aRowSpanBelow) > actualRowSpan)
     1:     return NS_OK;
     1: 
     1:   PRInt32 rowCount, colCount;
     1:   res = GetTableSize(aTable, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMElement> cell2;
     1:   nsCOMPtr<nsIDOMElement> lastCellFound;
     1:   PRInt32 startRowIndex2, startColIndex2, rowSpan2, colSpan2, actualRowSpan2, actualColSpan2;
 79445:   bool    isSelected2;
     1:   PRInt32 colIndex = 0;
 79445:   bool insertAfter = (startColIndex > 0);
     1:   // This is the row we will insert new cell into
     1:   PRInt32 rowBelowIndex = startRowIndex+aRowSpanAbove;
     1:   
     1:   // Find a cell to insert before or after
     1:   do 
     1:   {
     1:     // Search for a cell to insert before
     1:     res = GetCellDataAt(aTable, rowBelowIndex, 
     1:                         colIndex, getter_AddRefs(cell2),
     1:                         &startRowIndex2, &startColIndex2, &rowSpan2, &colSpan2, 
     1:                         &actualRowSpan2, &actualColSpan2, &isSelected2);
     1:     // If we fail here, it could be because row has bad rowspan values,
     1:     //   such as all cells having rowspan > 1 (Call FixRowSpan first!)
     1:     if (NS_FAILED(res) || !cell) return NS_ERROR_FAILURE;
     1: 
     1:     // Skip over cells spanned from above (like the one we are splitting!)
     1:     if (cell2 && startRowIndex2 == rowBelowIndex)
     1:     {
     1:       if (insertAfter)
     1:       {
     1:         // New cell isn't first in row,
     1:         // so stop after we find the cell just before new cell's column
     1:         if ((startColIndex2 + actualColSpan2) == startColIndex)
     1:           break;
     1: 
     1:         // If cell found is AFTER desired new cell colum,
     1:         //  we have multiple cells with rowspan > 1 that
     1:         //  prevented us from finding a cell to insert after...
     1:         if (startColIndex2 > startColIndex)
     1:         {
     1:           // ... so instead insert before the cell we found
 80486:           insertAfter = false;
     1:           break;
     1:         }
     1:       }
     1:       else
     1:       {
     1:         break; // Inserting before, so stop at first cell in row we want to insert into
     1:       }
     1:       lastCellFound = cell2;
     1:     }
     1:     // Skip to next available cellmap location
 38053:     colIndex += NS_MAX(actualColSpan2, 1);
     1: 
     1:     // Done when past end of total number of columns
     1:     if (colIndex > colCount)
     1:         break;
     1: 
 80486:   } while(true);
     1: 
     1:   if (!cell2 && lastCellFound)
     1:   {
     1:     // Edge case where we didn't find a cell to insert after
     1:     //  or before because column(s) before desired column 
     1:     //  and all columns after it are spanned from above. 
     1:     //  We can insert after the last cell we found 
     1:     cell2 = lastCellFound;
 80486:     insertAfter = true; // Should always be true, but let's be sure
     1:   }
     1: 
     1:   // Reduce rowspan of cell to split
     1:   res = SetRowSpan(cell, aRowSpanAbove);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1: 
     1:   // Insert new cell after using the remaining span
     1:   //  and always get the new cell so we can copy the background color;
     1:   nsCOMPtr<nsIDOMElement> newCell;
 80486:   res = InsertCell(cell2, aRowSpanBelow, actualColSpan, insertAfter, false, getter_AddRefs(newCell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   if (newCell)
     1:   {
     1:     if (aNewCell)
     1:     {
     1:       *aNewCell = newCell.get();
     1:       NS_ADDREF(*aNewCell);
     1:     }
     1:     res = CopyCellBackgroundColor(newCell, cell2);
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::SwitchTableCellHeaderType(nsIDOMElement *aSourceCell, nsIDOMElement **aNewCell)
     1: {
 43806:   NS_ENSURE_TRUE(aSourceCell, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   // Prevent auto insertion of BR in new cell created by ReplaceContainer
     1:   nsAutoRules beginRulesSniffing(this, kOpInsertNode, nsIEditor::eNext);
     1: 
     1:   nsCOMPtr<nsIDOMNode> newNode;
     1: 
     1:   // Save current selection to restore when done
     1:   // This is needed so ReplaceContainer can monitor selection
     1:   //  when replacing nodes
106286:   nsRefPtr<Selection> selection = GetSelection();
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1:   nsAutoSelectionReset selectionResetter(selection, this);
     1: 
     1:   // Set to the opposite of current type
     1:   nsCOMPtr<nsIAtom> atom = nsEditor::GetTag(aSourceCell);
     1:   nsString newCellType( (atom == nsEditProperty::td) ? NS_LITERAL_STRING("th") : NS_LITERAL_STRING("td"));
     1: 
 80486:   // This creates new node, moves children, copies attributes (true)
     1:   //   and manages the selection!
106286:   nsresult res = ReplaceContainer(aSourceCell, address_of(newNode),
106286:                                   newCellType, nsnull, nsnull, true);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(newNode, NS_ERROR_FAILURE);
     1: 
     1:   // Return the new cell
     1:   if (aNewCell)
     1:   {
     1:     nsCOMPtr<nsIDOMElement> newElement = do_QueryInterface(newNode);
     1:     *aNewCell = newElement.get();
     1:     NS_ADDREF(*aNewCell);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: nsHTMLEditor::JoinTableCells(bool aMergeNonContiguousContents)
     1: {
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   nsCOMPtr<nsIDOMElement> targetCell;
     1:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1:   nsCOMPtr<nsIDOMElement> cell2;
     1:   PRInt32 startRowIndex2, startColIndex2, rowSpan2, colSpan2, actualRowSpan2, actualColSpan2;
 79445:   bool    isSelected2;
     1: 
     1:   // Get cell, table, etc. at selection anchor node
     1:   nsresult res = GetCellContext(nsnull,
     1:                                 getter_AddRefs(table), 
     1:                                 getter_AddRefs(targetCell),
     1:                                 nsnull, nsnull,
     1:                                 &startRowIndex, &startColIndex);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   if(!table || !targetCell) return NS_EDITOR_ELEMENT_NOT_FOUND;
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   //Don't let Rules System change the selection
     1:   nsAutoTxnsConserveSelection dontChangeSelection(this);
     1: 
     1:   // Note: We dont' use nsSetSelectionAfterTableEdit here so the selection
     1:   //  is retained after joining. This leaves the target cell selected
     1:   //  as well as the "non-contiguous" cells, so user can see what happened.
     1: 
     1:   nsCOMPtr<nsIDOMElement> firstCell;
     1:   PRInt32 firstRowIndex, firstColIndex;
     1:   res = GetFirstSelectedCellInTable(&firstRowIndex, &firstColIndex, getter_AddRefs(firstCell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
 79445:   bool joinSelectedCells = false;
     1:   if (firstCell)
     1:   {
     1:     nsCOMPtr<nsIDOMElement> secondCell;
     1:     res = GetNextSelectedCell(nsnull, getter_AddRefs(secondCell));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     // If only one cell is selected, join with cell to the right
     1:     joinSelectedCells = (secondCell != nsnull);
     1:   }
     1: 
     1:   if (joinSelectedCells)
     1:   {
     1:     // We have selected cells: Join just contiguous cells
     1:     //  and just merge contents if not contiguous
     1: 
     1:     PRInt32 rowCount, colCount;
     1:     res = GetTableSize(table, &rowCount, &colCount);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     // Get spans for cell we will merge into
     1:     PRInt32 firstRowSpan, firstColSpan;
     1:     res = GetCellSpansAt( table, firstRowIndex, firstColIndex, firstRowSpan, firstColSpan);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     // This defines the last indexes along the "edges"
     1:     //  of the contiguous block of cells, telling us
     1:     //  that we can join adjacent cells to the block
     1:     // Start with same as the first values,
     1:     //  then expand as we find adjacent selected cells
     1:     PRInt32 lastRowIndex = firstRowIndex;
     1:     PRInt32 lastColIndex = firstColIndex;
     1:     PRInt32 rowIndex, colIndex;
     1: 
     1:     // First pass: Determine boundaries of contiguous rectangular block 
     1:     //  that we will join into one cell,
     1:     //  favoring adjacent cells in the same row
     1:     for (rowIndex = firstRowIndex; rowIndex <= lastRowIndex; rowIndex++)
     1:     {
     1:       PRInt32 currentRowCount = rowCount;
     1:       // Be sure each row doesn't have rowspan errors
     1:       res = FixBadRowSpan(table, rowIndex, rowCount);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       // Adjust rowcount by number of rows we removed
     1:       lastRowIndex -= (currentRowCount-rowCount);
     1: 
 79445:       bool cellFoundInRow = false;
 79445:       bool lastRowIsSet = false;
     1:       PRInt32 lastColInRow = 0;
     1:       PRInt32 firstColInRow = firstColIndex;
 38053:       for (colIndex = firstColIndex; colIndex < colCount; colIndex += NS_MAX(actualColSpan2, 1))
     1:       {
     1:         res = GetCellDataAt(table, rowIndex, colIndex, getter_AddRefs(cell2),
     1:                             &startRowIndex2, &startColIndex2,
     1:                             &rowSpan2, &colSpan2, 
     1:                             &actualRowSpan2, &actualColSpan2, &isSelected2);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1: 
     1:         if (isSelected2)
     1:         {
     1:           if (!cellFoundInRow)
     1:             // We've just found the first selected cell in this row
     1:             firstColInRow = colIndex;
     1: 
     1:           if (rowIndex > firstRowIndex && firstColInRow != firstColIndex)
     1:           {
     1:             // We're in at least the second row,
     1:             // but left boundary is "ragged" (not the same as 1st row's start)
     1:             //Let's just end block on previous row
     1:             // and keep previous lastColIndex
     1:             //TODO: We could try to find the Maximum firstColInRow
     1:             //      so our block can still extend down more rows?
 38053:             lastRowIndex = NS_MAX(0,rowIndex - 1);
 80486:             lastRowIsSet = true;
     1:             break;
     1:           }
     1:           // Save max selected column in this row, including extra colspan
     1:           lastColInRow = colIndex + (actualColSpan2-1);
 80486:           cellFoundInRow = true;
     1:         }
     1:         else if (cellFoundInRow)
     1:         {
     1:           // No cell or not selected, but at least one cell in row was found
     1:           
     1:           if (rowIndex > (firstRowIndex+1) && colIndex <= lastColIndex)
     1:           {
     1:             // Cell is in a column less than current right border in 
     1:             //  the third or higher selected row, so stop block at the previous row
 38053:             lastRowIndex = NS_MAX(0,rowIndex - 1);
 80486:             lastRowIsSet = true;
     1:           }
     1:           // We're done with this row
     1:           break;
     1:         }
     1:       } // End of column loop
     1: 
     1:       // Done with this row 
     1:       if (cellFoundInRow) 
     1:       {
     1:         if (rowIndex == firstRowIndex)
     1:         {
     1:           // First row always initializes the right boundary
     1:           lastColIndex = lastColInRow;
     1:         }
     1: 
     1:         // If we didn't determine last row above...
     1:         if (!lastRowIsSet)
     1:         {
     1:           if (colIndex < lastColIndex)
     1:           {
     1:             // (don't think we ever get here?)
     1:             // Cell is in a column less than current right boundary,
     1:             //  so stop block at the previous row
 38053:             lastRowIndex = NS_MAX(0,rowIndex - 1);
     1:           }
     1:           else
     1:           {
     1:             // Go on to examine next row
     1:             lastRowIndex = rowIndex+1;
     1:           }
     1:         }
     1:         // Use the minimum col we found so far for right boundary
 38053:         lastColIndex = NS_MIN(lastColIndex, lastColInRow);
     1:       }
     1:       else
     1:       {
     1:         // No selected cells in this row -- stop at row above
     1:         //  and leave last column at its previous value
 38053:         lastRowIndex = NS_MAX(0,rowIndex - 1);
     1:       }
     1:     }
     1:   
     1:     // The list of cells we will delete after joining
 27986:     nsTArray<nsIDOMElement*> deleteList;
     1: 
     1:     // 2nd pass: Do the joining and merging
     1:     for (rowIndex = 0; rowIndex < rowCount; rowIndex++)
     1:     {
 38053:       for (colIndex = 0; colIndex < colCount; colIndex += NS_MAX(actualColSpan2, 1))
     1:       {
     1:         res = GetCellDataAt(table, rowIndex, colIndex, getter_AddRefs(cell2),
     1:                             &startRowIndex2, &startColIndex2,
     1:                             &rowSpan2, &colSpan2, 
     1:                             &actualRowSpan2, &actualColSpan2, &isSelected2);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1: 
     1:         // If this is 0, we are past last cell in row, so exit the loop
     1:         if (actualColSpan2 == 0)
     1:           break;
     1: 
     1:         // Merge only selected cells (skip cell we're merging into, of course)
     1:         if (isSelected2 && cell2 != firstCell)
     1:         {
     1:           if (rowIndex >= firstRowIndex && rowIndex <= lastRowIndex && 
     1:               colIndex >= firstColIndex && colIndex <= lastColIndex)
     1:           {
     1:             // We are within the join region
     1:             // Problem: It is very tricky to delete cells as we merge,
     1:             //  since that will upset the cellmap
     1:             //  Instead, build a list of cells to delete and do it later
     1:             NS_ASSERTION(startRowIndex2 == rowIndex, "JoinTableCells: StartRowIndex is in row above");
     1: 
     1:             if (actualColSpan2 > 1)
     1:             {
     1:               //Check if cell "hangs" off the boundary because of colspan > 1
     1:               //  Use split methods to chop off excess
     1:               PRInt32 extraColSpan = (startColIndex2 + actualColSpan2) - (lastColIndex+1);
     1:               if ( extraColSpan > 0)
     1:               {
     1:                 res = SplitCellIntoColumns(table, startRowIndex2, startColIndex2, 
     1:                                            actualColSpan2-extraColSpan, extraColSpan, nsnull);
 43805:                 NS_ENSURE_SUCCESS(res, res);
     1:               }
     1:             }
     1: 
 80486:             res = MergeCells(firstCell, cell2, false);
 43805:             NS_ENSURE_SUCCESS(res, res);
     1:             
     1:             // Add cell to list to delete
 27986:             deleteList.AppendElement(cell2.get());
     1:           }
     1:           else if (aMergeNonContiguousContents)
     1:           {
     1:             // Cell is outside join region -- just merge the contents
 80486:             res = MergeCells(firstCell, cell2, false);
 43805:             NS_ENSURE_SUCCESS(res, res);
     1:           }
     1:         }
     1:       }
     1:     }
     1: 
     1:     // All cell contents are merged. Delete the empty cells we accumulated
     1:     // Prevent rules testing until we're done
     1:     nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
     1: 
 27986:     for (PRUint32 i = 0, n = deleteList.Length(); i < n; i++)
     1:     {
 27986:       nsIDOMElement *elementPtr = deleteList[i];
     1:       if (elementPtr)
     1:       {
     1:         nsCOMPtr<nsIDOMNode> node = do_QueryInterface(elementPtr);
     1:         res = DeleteNode(node);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:     }
     1:     // Cleanup selection: remove ranges where cells were deleted
     1:     nsCOMPtr<nsISelection> selection;
     1:     res = GetSelection(getter_AddRefs(selection));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1: 
     1:     PRInt32 rangeCount;
     1:     res = selection->GetRangeCount(&rangeCount);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     nsCOMPtr<nsIDOMRange> range;
     1:     PRInt32 i;
     1:     for (i = 0; i < rangeCount; i++)
     1:     {
     1:       res = selection->GetRangeAt(i, getter_AddRefs(range));
 43805:       NS_ENSURE_SUCCESS(res, res);
 43806:       NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
     1: 
     1:       nsCOMPtr<nsIDOMElement> deletedCell;
     1:       res = GetCellFromRange(range, getter_AddRefs(deletedCell));
     1:       if (!deletedCell)
     1:       {
     1:         selection->RemoveRange(range);
     1:         rangeCount--;
     1:         i--;
     1:       }
     1:     }
     1: 
     1:     // Set spans for the cell everthing merged into
     1:     res = SetRowSpan(firstCell, lastRowIndex-firstRowIndex+1);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     res = SetColSpan(firstCell, lastColIndex-firstColIndex+1);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     
     1:     
     1:     // Fixup disturbances in table layout
     1:     NormalizeTable(table);
     1:   }
     1:   else
     1:   {
     1:     // Joining with cell to the right -- get rowspan and colspan data of target cell
     1:     res = GetCellDataAt(table, startRowIndex, startColIndex, getter_AddRefs(targetCell),
     1:                         &startRowIndex, &startColIndex, &rowSpan, &colSpan, 
     1:                         &actualRowSpan, &actualColSpan, &isSelected);
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(targetCell, NS_ERROR_NULL_POINTER);
     1: 
     1:     // Get data for cell to the right
     1:     res = GetCellDataAt(table, startRowIndex, startColIndex+actualColSpan, getter_AddRefs(cell2),
     1:                         &startRowIndex2, &startColIndex2, &rowSpan2, &colSpan2, 
     1:                         &actualRowSpan2, &actualColSpan2, &isSelected2);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     if(!cell2) return NS_OK; // Don't fail if there's no cell
     1: 
     1:     // sanity check
     1:     NS_ASSERTION((startRowIndex >= startRowIndex2),"JoinCells: startRowIndex < startRowIndex2");
     1: 
     1:     // Figure out span of merged cell starting from target's starting row
     1:     // to handle case of merged cell starting in a row above
     1:     PRInt32 spanAboveMergedCell = startRowIndex - startRowIndex2;
     1:     PRInt32 effectiveRowSpan2 = actualRowSpan2 - spanAboveMergedCell;
     1: 
     1:     if (effectiveRowSpan2 > actualRowSpan)
     1:     {
     1:       // Cell to the right spans into row below target
     1:       // Split off portion below target cell's bottom-most row
     1:       res = SplitCellIntoRows(table, startRowIndex2, startColIndex2,
     1:                               spanAboveMergedCell+actualRowSpan, 
     1:                               effectiveRowSpan2-actualRowSpan, nsnull);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1: 
     1:     // Move contents from cell to the right
     1:     // Delete the cell now only if it starts in the same row
     1:     //   and has enough row "height"
     1:     res = MergeCells(targetCell, cell2, 
     1:                      (startRowIndex2 == startRowIndex) && 
     1:                      (effectiveRowSpan2 >= actualRowSpan));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     if (effectiveRowSpan2 < actualRowSpan)
     1:     {
     1:       // Merged cell is "shorter" 
     1:       // (there are cells(s) below it that are row-spanned by target cell)
     1:       // We could try splitting those cells, but that's REAL messy,
     1:       //  so the safest thing to do is NOT really join the cells
     1:       return NS_OK;
     1:     }
     1: 
     1:     if( spanAboveMergedCell > 0 )
     1:     {
     1:       // Cell we merged started in a row above the target cell
 90153:       // Reduce rowspan to give room where target cell will extend its colspan
     1:       res = SetRowSpan(cell2, spanAboveMergedCell);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1: 
     1:     // Reset target cell's colspan to encompass cell to the right
     1:     res = SetColSpan(targetCell, actualColSpan+actualColSpan2);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::MergeCells(nsCOMPtr<nsIDOMElement> aTargetCell, 
     1:                          nsCOMPtr<nsIDOMElement> aCellToMerge,
 79445:                          bool aDeleteCellToMerge)
     1: {
101127:   nsCOMPtr<dom::Element> targetCell = do_QueryInterface(aTargetCell);
101127:   nsCOMPtr<dom::Element> cellToMerge = do_QueryInterface(aCellToMerge);
101127:   NS_ENSURE_TRUE(targetCell && cellToMerge, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Prevent rules testing until we're done
     1:   nsAutoRules beginRulesSniffing(this, kOpDeleteNode, nsIEditor::eNext);
     1: 
     1:   // Don't need to merge if cell is empty
101127:   if (!IsEmptyCell(cellToMerge)) {
     1:     // Get index of last child in target cell
     1:     // If we fail or don't have children, 
     1:     //  we insert at index 0
     1:     PRInt32 insertIndex = 0;
     1: 
     1:     // Start inserting just after last child
101127:     PRUint32 len = targetCell->GetChildCount();
101127:     if (len == 1 && IsEmptyCell(targetCell)) {
     1:       // Delete the empty node
101127:       nsIContent* cellChild = targetCell->GetFirstChild();
101127:       nsresult res = DeleteNode(cellChild->AsDOMNode());
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       insertIndex = 0;
101127:     } else {
     1:       insertIndex = (PRInt32)len;
     1:     }
     1: 
     1:     // Move the contents
101127:     while (cellToMerge->HasChildren()) {
101127:       nsCOMPtr<nsIDOMNode> cellChild = cellToMerge->GetLastChild()->AsDOMNode();
101127:       nsresult res = DeleteNode(cellChild);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       res = InsertNode(cellChild, aTargetCell, insertIndex);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1:   }
     1: 
     1:   // Delete cells whose contents were moved
     1:   if (aDeleteCellToMerge)
101127:     return DeleteNode(aCellToMerge);
101127: 
101127:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::FixBadRowSpan(nsIDOMElement *aTable, PRInt32 aRowIndex, PRInt32& aNewRowCount)
     1: {
 43806:   NS_ENSURE_TRUE(aTable, NS_ERROR_NULL_POINTER);
     1: 
     1:   PRInt32 rowCount, colCount;
     1:   nsresult res = GetTableSize(aTable, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMElement>cell;
     1:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1: 
     1:   PRInt32 minRowSpan = -1;
     1:   PRInt32 colIndex;
     1:   
 38053:   for( colIndex = 0; colIndex < colCount; colIndex += NS_MAX(actualColSpan, 1))
     1:   {
     1:     res = GetCellDataAt(aTable, aRowIndex, colIndex, getter_AddRefs(cell),
     1:                         &startRowIndex, &startColIndex, &rowSpan, &colSpan, 
     1:                         &actualRowSpan, &actualColSpan, &isSelected);
     1:     // NOTE: This is a *real* failure. 
     1:     // GetCellDataAt passes if cell is missing from cellmap
     1:     if(NS_FAILED(res)) return res;
     1:     if (!cell) break;
     1:     if(rowSpan > 0 && 
     1:        startRowIndex == aRowIndex &&
     1:        (rowSpan < minRowSpan || minRowSpan == -1))
     1:     {
     1:       minRowSpan = rowSpan;
     1:     }
     1:     NS_ASSERTION((actualColSpan > 0),"ActualColSpan = 0 in FixBadRowSpan");
     1:   }
     1:   if(minRowSpan > 1)
     1:   {
     1:     // The amount to reduce everyone's rowspan
     1:     // so at least one cell has rowspan = 1
     1:     PRInt32 rowsReduced = minRowSpan - 1;
 38053:     for(colIndex = 0; colIndex < colCount; colIndex += NS_MAX(actualColSpan, 1))
     1:     {
     1:       res = GetCellDataAt(aTable, aRowIndex, colIndex, getter_AddRefs(cell),
     1:                           &startRowIndex, &startColIndex, &rowSpan, &colSpan, 
     1:                           &actualRowSpan, &actualColSpan, &isSelected);
     1:       if(NS_FAILED(res)) return res;
     1:       // Fixup rowspans only for cells starting in current row
     1:       if(cell && rowSpan > 0 &&
     1:          startRowIndex == aRowIndex && 
     1:          startColIndex ==  colIndex )
     1:       {
     1:         res = SetRowSpan(cell, rowSpan-rowsReduced);
     1:         if(NS_FAILED(res)) return res;
     1:       }
     1:       NS_ASSERTION((actualColSpan > 0),"ActualColSpan = 0 in FixBadRowSpan");
     1:     }
     1:   }
     1:   return GetTableSize(aTable, &aNewRowCount, &colCount);
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::FixBadColSpan(nsIDOMElement *aTable, PRInt32 aColIndex, PRInt32& aNewColCount)
     1: {
 43806:   NS_ENSURE_TRUE(aTable, NS_ERROR_NULL_POINTER);
     1: 
     1:   PRInt32 rowCount, colCount;
     1:   nsresult res = GetTableSize(aTable, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1: 
     1:   PRInt32 minColSpan = -1;
     1:   PRInt32 rowIndex;
     1:   
 38053:   for( rowIndex = 0; rowIndex < rowCount; rowIndex += NS_MAX(actualRowSpan, 1))
     1:   {
     1:     res = GetCellDataAt(aTable, rowIndex, aColIndex, getter_AddRefs(cell),
     1:                         &startRowIndex, &startColIndex, &rowSpan, &colSpan, 
     1:                         &actualRowSpan, &actualColSpan, &isSelected);
     1:     // NOTE: This is a *real* failure. 
     1:     // GetCellDataAt passes if cell is missing from cellmap
     1:     if(NS_FAILED(res)) return res;
     1:     if (!cell) break;
     1:     if(colSpan > 0 && 
     1:        startColIndex == aColIndex &&
     1:        (colSpan < minColSpan || minColSpan == -1))
     1:     {
     1:       minColSpan = colSpan;
     1:     }
     1:     NS_ASSERTION((actualRowSpan > 0),"ActualRowSpan = 0 in FixBadColSpan");
     1:   }
     1:   if(minColSpan > 1)
     1:   {
     1:     // The amount to reduce everyone's colspan
     1:     // so at least one cell has colspan = 1
     1:     PRInt32 colsReduced = minColSpan - 1;
 38053:     for(rowIndex = 0; rowIndex < rowCount; rowIndex += NS_MAX(actualRowSpan, 1))
     1:     {
     1:       res = GetCellDataAt(aTable, rowIndex, aColIndex, getter_AddRefs(cell),
     1:                           &startRowIndex, &startColIndex, &rowSpan, &colSpan, 
     1:                           &actualRowSpan, &actualColSpan, &isSelected);
     1:       if(NS_FAILED(res)) return res;
     1:       // Fixup colspans only for cells starting in current column
     1:       if(cell && colSpan > 0 &&
     1:          startColIndex == aColIndex && 
     1:          startRowIndex ==  rowIndex )
     1:       {
     1:         res = SetColSpan(cell, colSpan-colsReduced);
     1:         if(NS_FAILED(res)) return res;
     1:       }
     1:       NS_ASSERTION((actualRowSpan > 0),"ActualRowSpan = 0 in FixBadColSpan");
     1:     }
     1:   }
     1:   return GetTableSize(aTable, &rowCount, &aNewColCount);
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::NormalizeTable(nsIDOMElement *aTable)
     1: {
106286:   nsRefPtr<Selection> selection = GetSelection();
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1: 
     1:   nsCOMPtr<nsIDOMElement> table;
106286:   nsresult res = GetElementOrParentByTagName(NS_LITERAL_STRING("table"),
106286:                                              aTable, getter_AddRefs(table));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // Don't fail if we didn't find a table
 43806:   NS_ENSURE_TRUE(table, NS_OK);
     1: 
     1:   PRInt32 rowCount, colCount, rowIndex, colIndex;
     1:   res = GetTableSize(table, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // Save current selection
     1:   nsAutoSelectionReset selectionResetter(selection, this);
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   // Prevent auto insertion of BR in new cell until we're done
     1:   nsAutoRules beginRulesSniffing(this, kOpInsertNode, nsIEditor::eNext);
     1: 
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1: 
     1:   // Scan all cells in each row to detect bad rowspan values
     1:   for(rowIndex = 0; rowIndex < rowCount; rowIndex++)
     1:   {
     1:     res = FixBadRowSpan(table, rowIndex, rowCount);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1:   // and same for colspans
     1:   for(colIndex = 0; colIndex < colCount; colIndex++)
     1:   {
     1:     res = FixBadColSpan(table, colIndex, colCount);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1: 
     1:   // Fill in missing cellmap locations with empty cells
     1:   for(rowIndex = 0; rowIndex < rowCount; rowIndex++)
     1:   {
     1:     nsCOMPtr<nsIDOMElement> previousCellInRow;
     1: 
     1:     for(colIndex = 0; colIndex < colCount; colIndex++)
     1:     {
     1:       res = GetCellDataAt(table, rowIndex, colIndex, getter_AddRefs(cell),
     1:                           &startRowIndex, &startColIndex, &rowSpan, &colSpan, 
     1:                           &actualRowSpan, &actualColSpan, &isSelected);
     1:       // NOTE: This is a *real* failure. 
     1:       // GetCellDataAt passes if cell is missing from cellmap
     1:       if(NS_FAILED(res)) return res;
     1:       if (!cell)
     1:       {
     1:         //We are missing a cell at a cellmap location
     1: #ifdef DEBUG
     1:         printf("NormalizeTable found missing cell at row=%d, col=%d\n", rowIndex, colIndex);
     1: #endif
     1:         // Add a cell after the previous Cell in the current row
     1:         if(previousCellInRow)
     1:         {
 80486:           // Insert a new cell after (true), and return the new cell to us
 80486:           res = InsertCell(previousCellInRow, 1, 1, true, false, getter_AddRefs(cell));
 43805:           NS_ENSURE_SUCCESS(res, res);
     1: 
     1:           // Set this so we use returned new "cell" to set previousCellInRow below
     1:           if(cell)
     1:             startRowIndex = rowIndex;   
     1:         } else {
     1:           // We don't have any cells in this row -- We are really messed up!
     1: #ifdef DEBUG
     1:           printf("NormalizeTable found no cells in row=%d, col=%d\n", rowIndex, colIndex);
     1: #endif
     1:           return NS_ERROR_FAILURE;
     1:         }
     1:       }
     1:       // Save the last cell found in the same row we are scanning
     1:       if(startRowIndex == rowIndex)
     1:       {
     1:         previousCellInRow = cell;
     1:       }
     1:     }
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::GetCellIndexes(nsIDOMElement *aCell,
     1:                              PRInt32 *aRowIndex, PRInt32 *aColIndex)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aRowIndex);
     1:   *aColIndex=0; // initialize out params
     1:   NS_ENSURE_ARG_POINTER(aColIndex);
     1:   *aRowIndex=0;
     1:   nsresult res=NS_ERROR_NOT_INITIALIZED;
     1:   if (!aCell)
     1:   {
     1:     // Get the selected cell or the cell enclosing the selection anchor
     1:     nsCOMPtr<nsIDOMElement> cell;
     1:     res = GetElementOrParentByTagName(NS_LITERAL_STRING("td"), nsnull, getter_AddRefs(cell));
     1:     if (NS_SUCCEEDED(res) && cell)
     1:       aCell = cell;
     1:     else
     1:       return NS_ERROR_FAILURE;
     1:   }
     1: 
 63587:   NS_ENSURE_TRUE(mDocWeak, NS_ERROR_NOT_INITIALIZED);
 70236:   nsCOMPtr<nsIPresShell> ps = GetPresShell();
 43806:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
 18814: 
 18814:   nsCOMPtr<nsIContent> nodeAsContent( do_QueryInterface(aCell) );
 43806:   NS_ENSURE_TRUE(nodeAsContent, NS_ERROR_FAILURE);
 18814:   // frames are not ref counted, so don't use an nsCOMPtr
 36657:   nsIFrame *layoutObject = nodeAsContent->GetPrimaryFrame();
 43806:   NS_ENSURE_TRUE(layoutObject, NS_ERROR_FAILURE);
     1: 
 23554:   nsITableCellLayout *cellLayoutObject = do_QueryFrame(layoutObject);
 43806:   NS_ENSURE_TRUE(cellLayoutObject, NS_ERROR_FAILURE);
     1:   return cellLayoutObject->GetCellIndexes(*aRowIndex, *aColIndex);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetTableLayoutObject(nsIDOMElement* aTable, nsITableLayout **tableLayoutObject)
     1: {
     1:   *tableLayoutObject = nsnull;
 43806:   NS_ENSURE_TRUE(aTable, NS_ERROR_NOT_INITIALIZED);
 63587:   NS_ENSURE_TRUE(mDocWeak, NS_ERROR_NOT_INITIALIZED);
 70236:   nsCOMPtr<nsIPresShell> ps = GetPresShell();
 43806:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
 18814: 
 18814:   nsCOMPtr<nsIContent> nodeAsContent( do_QueryInterface(aTable) );
 43806:   NS_ENSURE_TRUE(nodeAsContent, NS_ERROR_FAILURE);
     1:   // frames are not ref counted, so don't use an nsCOMPtr
 36657:   nsIFrame *layoutObject = nodeAsContent->GetPrimaryFrame();
 43806:   NS_ENSURE_TRUE(layoutObject, NS_ERROR_FAILURE);
 18814: 
 23554:   *tableLayoutObject = do_QueryFrame(layoutObject);
 23554:   return *tableLayoutObject ? NS_OK : NS_NOINTERFACE;
     1: }
     1: 
     1: //Return actual number of cells (a cell with colspan > 1 counts as just 1)
 74431: PRInt32 nsHTMLEditor::GetNumberOfCellsInRow(nsIDOMElement* aTable, PRInt32 rowIndex)
     1: {
     1:   PRInt32 cellCount = 0;
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   PRInt32 colIndex = 0;
     1:   nsresult res;
     1:   do {
     1:     PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:     bool    isSelected;
     1:     res = GetCellDataAt(aTable, rowIndex, colIndex, getter_AddRefs(cell),
     1:                         &startRowIndex, &startColIndex, &rowSpan, &colSpan, 
     1:                         &actualRowSpan, &actualColSpan, &isSelected);
 74431:     NS_ENSURE_SUCCESS(res, 0);
     1:     if (cell)
     1:     {
     1:       // Only count cells that start in row we are working with
     1:       if (startRowIndex == rowIndex)
     1:         cellCount++;
     1:       
     1:       //Next possible location for a cell
     1:       colIndex += actualColSpan;
     1:     }
     1:     else
     1:       colIndex++;
     1: 
     1:   } while (cell);
     1: 
     1:   return cellCount;
     1: }
     1: 
     1: /* Not scriptable: For convenience in C++ 
     1:    Use GetTableRowCount and GetTableColumnCount from JavaScript
     1: */
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetTableSize(nsIDOMElement *aTable,
     1:                            PRInt32* aRowCount, PRInt32* aColCount)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aRowCount);
     1:   NS_ENSURE_ARG_POINTER(aColCount);
     1:   nsresult res;
     1:   *aRowCount = 0;
     1:   *aColCount = 0;
     1:   nsCOMPtr<nsIDOMElement> table;
     1:   // Get the selected talbe or the table enclosing the selection anchor
     1:   res = GetElementOrParentByTagName(NS_LITERAL_STRING("table"), aTable, getter_AddRefs(table));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(table, NS_ERROR_FAILURE);
     1:   
     1:   // frames are not ref counted, so don't use an nsCOMPtr
     1:   nsITableLayout *tableLayoutObject;
     1:   res = GetTableLayoutObject(table.get(), &tableLayoutObject);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43807:   NS_ENSURE_TRUE(tableLayoutObject, NS_ERROR_FAILURE);
     1: 
     1:   return tableLayoutObject->GetTableSize(*aRowCount, *aColCount); 
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::GetCellDataAt(nsIDOMElement* aTable, PRInt32 aRowIndex,
     1:                             PRInt32 aColIndex, nsIDOMElement **aCell, 
     1:                             PRInt32* aStartRowIndex, PRInt32* aStartColIndex, 
     1:                             PRInt32* aRowSpan, PRInt32* aColSpan, 
     1:                             PRInt32* aActualRowSpan, PRInt32* aActualColSpan, 
 79445:                             bool* aIsSelected)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aStartRowIndex);
     1:   NS_ENSURE_ARG_POINTER(aStartColIndex);
     1:   NS_ENSURE_ARG_POINTER(aRowSpan);
     1:   NS_ENSURE_ARG_POINTER(aColSpan);
     1:   NS_ENSURE_ARG_POINTER(aActualRowSpan);
     1:   NS_ENSURE_ARG_POINTER(aActualColSpan);
     1:   NS_ENSURE_ARG_POINTER(aIsSelected);
 43806:   NS_ENSURE_TRUE(aCell, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsresult res=NS_ERROR_FAILURE;
     1:   *aStartRowIndex = 0;
     1:   *aStartColIndex = 0;
     1:   *aRowSpan = 0;
     1:   *aColSpan = 0;
     1:   *aActualRowSpan = 0;
     1:   *aActualColSpan = 0;
 80486:   *aIsSelected = false;
     1: 
     1:   *aCell = nsnull;
     1: 
     1:   if (!aTable)
     1:   {
     1:     // Get the selected table or the table enclosing the selection anchor
     1:     nsCOMPtr<nsIDOMElement> table;
     1:     res = GetElementOrParentByTagName(NS_LITERAL_STRING("table"), nsnull, getter_AddRefs(table));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     if (table)
     1:       aTable = table;
     1:     else
     1:       return NS_ERROR_FAILURE;
     1:   }
     1:   
     1:   // frames are not ref counted, so don't use an nsCOMPtr
     1:   nsITableLayout *tableLayoutObject;
     1:   res = GetTableLayoutObject(aTable, &tableLayoutObject);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(tableLayoutObject, NS_ERROR_FAILURE);
     1: 
     1:   // Note that this returns NS_TABLELAYOUT_CELL_NOT_FOUND when
     1:   //  the index(es) are out of bounds
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   res = tableLayoutObject->GetCellDataAt(aRowIndex, aColIndex,
     1:                                          *getter_AddRefs(cell), 
     1:                                          *aStartRowIndex, *aStartColIndex,
     1:                                          *aRowSpan, *aColSpan, 
     1:                                          *aActualRowSpan, *aActualColSpan, 
     1:                                          *aIsSelected);
     1:   if (cell)
     1:   {
     1:     *aCell = cell.get();
     1:     NS_ADDREF(*aCell);
     1:   }
     1:   // Convert to editor's generic "not found" return value
     1:   if (res == NS_TABLELAYOUT_CELL_NOT_FOUND) res = NS_EDITOR_ELEMENT_NOT_FOUND;
     1:   return res;
     1: }
     1: 
     1: // When all you want is the cell
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::GetCellAt(nsIDOMElement* aTable, PRInt32 aRowIndex, PRInt32 aColIndex, nsIDOMElement **aCell)
     1: {
     1:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1:   return GetCellDataAt(aTable, aRowIndex, aColIndex, aCell, 
     1:                        &startRowIndex, &startColIndex, &rowSpan, &colSpan, 
     1:                        &actualRowSpan, &actualColSpan, &isSelected);
     1: }
     1: 
     1: // When all you want are the rowspan and colspan (not exposed in nsITableEditor)
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetCellSpansAt(nsIDOMElement* aTable, PRInt32 aRowIndex, PRInt32 aColIndex, 
     1:                              PRInt32& aActualRowSpan, PRInt32& aActualColSpan)
     1: {
     1:   nsCOMPtr<nsIDOMElement> cell;    
     1:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan;
 79445:   bool    isSelected;
     1:   return GetCellDataAt(aTable, aRowIndex, aColIndex, getter_AddRefs(cell), 
     1:                        &startRowIndex, &startColIndex, &rowSpan, &colSpan, 
     1:                        &aActualRowSpan, &aActualColSpan, &isSelected);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetCellContext(nsISelection **aSelection,
     1:                              nsIDOMElement   **aTable,
     1:                              nsIDOMElement   **aCell,
     1:                              nsIDOMNode      **aCellParent, PRInt32 *aCellOffset,
     1:                              PRInt32 *aRowIndex, PRInt32 *aColIndex)
     1: {
     1:   // Initialize return pointers
     1:   if (aSelection) *aSelection = nsnull;
     1:   if (aTable) *aTable = nsnull;
     1:   if (aCell) *aCell = nsnull;
     1:   if (aCellParent) *aCellParent = nsnull;
     1:   if (aCellOffset) *aCellOffset = 0;
     1:   if (aRowIndex) *aRowIndex = 0;
     1:   if (aColIndex) *aColIndex = 0;
     1: 
     1:   nsCOMPtr <nsISelection> selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1: 
     1:   if (aSelection)
     1:   {
     1:     *aSelection = selection.get();
     1:     NS_ADDREF(*aSelection);
     1:   }
     1:   nsCOMPtr <nsIDOMElement> table;
     1:   nsCOMPtr <nsIDOMElement> cell;
     1: 
     1:   // Caller may supply the cell...
     1:   if (aCell && *aCell)
     1:     cell = *aCell;
     1: 
     1:   // ...but if not supplied,
     1:   //    get cell if it's the child of selection anchor node,
     1:   //    or get the enclosing by a cell
     1:   if (!cell)
     1:   {
     1:     // Find a selected or enclosing table element
     1:     nsCOMPtr<nsIDOMElement> cellOrTableElement;
     1:     PRInt32 selectedCount;
     1:     nsAutoString tagName;
     1:     res = GetSelectedOrParentTableElement(tagName, &selectedCount,
     1:                                           getter_AddRefs(cellOrTableElement));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     if (tagName.EqualsLiteral("table"))
     1:     {
     1:       // We have a selected table, not a cell
     1:       if (aTable)
     1:       {
     1:         *aTable = cellOrTableElement.get();
     1:         NS_ADDREF(*aTable);
     1:       }
     1:       return NS_OK;
     1:     }
     1:     if (!tagName.EqualsLiteral("td"))
     1:       return NS_EDITOR_ELEMENT_NOT_FOUND;
     1: 
     1:     // We found a cell
     1:     cell = cellOrTableElement;
     1:   }
     1:   if (aCell)
     1:   {
     1:     *aCell = cell.get();
     1:     NS_ADDREF(*aCell);
     1:   }
     1: 
     1:   // Get containing table
     1:   res = GetElementOrParentByTagName(NS_LITERAL_STRING("table"), cell, getter_AddRefs(table));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // Cell must be in a table, so fail if not found
 43806:   NS_ENSURE_TRUE(table, NS_ERROR_FAILURE);
     1:   if (aTable)
     1:   {
     1:     *aTable = table.get();
     1:     NS_ADDREF(*aTable);
     1:   }
     1: 
     1:   // Get the rest of the related data only if requested
     1:   if (aRowIndex || aColIndex)
     1:   {
     1:     PRInt32 rowIndex, colIndex;
     1:     // Get current cell location so we can put caret back there when done
     1:     res = GetCellIndexes(cell, &rowIndex, &colIndex);
     1:     if(NS_FAILED(res)) return res;
     1:     if (aRowIndex) *aRowIndex = rowIndex;
     1:     if (aColIndex) *aColIndex = colIndex;
     1:   }
     1:   if (aCellParent)
     1:   {
     1:     nsCOMPtr <nsIDOMNode> cellParent;
     1:     // Get the immediate parent of the cell
     1:     res = cell->GetParentNode(getter_AddRefs(cellParent));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     // Cell has to have a parent, so fail if not found
 43806:     NS_ENSURE_TRUE(cellParent, NS_ERROR_FAILURE);
     1: 
     1:     *aCellParent = cellParent.get();
     1:     NS_ADDREF(*aCellParent);
     1: 
103677:     if (aCellOffset) {
103677:       *aCellOffset = GetChildOffset(cell, cellParent);
103677:     }
     1:   }
     1: 
     1:   return res;
     1: }
     1: 
     1: nsresult 
     1: nsHTMLEditor::GetCellFromRange(nsIDOMRange *aRange, nsIDOMElement **aCell)
     1: {
     1:   // Note: this might return a node that is outside of the range.
     1:   // Use carefully.
 43806:   NS_ENSURE_TRUE(aRange && aCell, NS_ERROR_NULL_POINTER);
     1: 
     1:   *aCell = nsnull;
     1: 
     1:   nsCOMPtr<nsIDOMNode> startParent;
     1:   nsresult res = aRange->GetStartContainer(getter_AddRefs(startParent));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(startParent, NS_ERROR_FAILURE);
     1: 
     1:   PRInt32 startOffset;
     1:   res = aRange->GetStartOffset(&startOffset);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMNode> childNode = GetChildAt(startParent, startOffset);
     1:   // This means selection is probably at a text node (or end of doc?)
 73978:   if (!childNode) {
 73978:     return NS_ERROR_FAILURE;
 73978:   }
     1: 
     1:   nsCOMPtr<nsIDOMNode> endParent;
     1:   res = aRange->GetEndContainer(getter_AddRefs(endParent));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(startParent, NS_ERROR_FAILURE);
     1: 
     1:   PRInt32 endOffset;
     1:   res = aRange->GetEndOffset(&endOffset);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   // If a cell is deleted, the range is collapse
     1:   //   (startOffset == endOffset)
     1:   //   so tell caller the cell wasn't found
     1:   if (startParent == endParent && 
     1:       endOffset == startOffset+1 &&
     1:       nsHTMLEditUtils::IsTableCell(childNode))
     1:   {
     1:     // Should we also test if frame is selected? (Use GetCellDataAt())
     1:     // (Let's not for now -- more efficient)
     1:     nsCOMPtr<nsIDOMElement> cellElement = do_QueryInterface(childNode);
     1:     *aCell = cellElement.get();
     1:     NS_ADDREF(*aCell);
     1:     return NS_OK;
     1:   }
     1:   return NS_EDITOR_ELEMENT_NOT_FOUND;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::GetFirstSelectedCell(nsIDOMRange **aRange, nsIDOMElement **aCell)
     1: {
 43806:   NS_ENSURE_TRUE(aCell, NS_ERROR_NULL_POINTER);
     1:   *aCell = nsnull;
     1:   if (aRange) *aRange = nsnull;
     1: 
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1: 
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   res = selection->GetRangeAt(0, getter_AddRefs(range));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
     1: 
     1:   mSelectedCellIndex = 0;
     1: 
     1:   res = GetCellFromRange(range, aCell);
     1:   // Failure here probably means selection is in a text node,
     1:   //  so there's no selected cell
 73978:   if (NS_FAILED(res)) {
 73978:     return NS_EDITOR_ELEMENT_NOT_FOUND;
 73978:   }
     1:   // No cell means range was collapsed (cell was deleted)
 73978:   if (!*aCell) {
 73978:     return NS_EDITOR_ELEMENT_NOT_FOUND;
 73978:   }
     1: 
     1:   if (aRange)
     1:   {
     1:     *aRange = range.get();
     1:     NS_ADDREF(*aRange);
     1:   }
     1: 
     1:   // Setup for next cell
     1:   mSelectedCellIndex = 1;
     1: 
     1:   return res;  
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetNextSelectedCell(nsIDOMRange **aRange, nsIDOMElement **aCell)
     1: {
 43806:   NS_ENSURE_TRUE(aCell, NS_ERROR_NULL_POINTER);
     1:   *aCell = nsnull;
     1:   if (aRange) *aRange = nsnull;
     1: 
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1: 
     1:   PRInt32 rangeCount;
     1:   res = selection->GetRangeCount(&rangeCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // Don't even try if index exceeds range count
     1:   if (mSelectedCellIndex >= rangeCount) 
     1:     return NS_EDITOR_ELEMENT_NOT_FOUND;
     1: 
     1:   // Scan through ranges to find next valid selected cell
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   for (; mSelectedCellIndex < rangeCount; mSelectedCellIndex++)
     1:   {
     1:     res = selection->GetRangeAt(mSelectedCellIndex, getter_AddRefs(range));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
     1: 
     1:     res = GetCellFromRange(range, aCell);
     1:     // Failure here means the range doesn't contain a cell
 43805:     NS_ENSURE_SUCCESS(res, NS_EDITOR_ELEMENT_NOT_FOUND);
     1:     
     1:     // We found a selected cell
     1:     if (*aCell) break;
     1: #ifdef DEBUG_cmanske
     1:     else
     1:       printf("GetNextSelectedCell: Collapsed range found\n");
     1: #endif
     1: 
     1:     // If we didn't find a cell, continue to next range in selection
     1:   }
     1:   // No cell means all remaining ranges were collapsed (cells were deleted)
 43806:   NS_ENSURE_TRUE(*aCell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:   if (aRange)
     1:   {
     1:     *aRange = range.get();
     1:     NS_ADDREF(*aRange);
     1:   }
     1: 
     1:   // Setup for next cell
     1:   mSelectedCellIndex++;
     1: 
     1:   return res;  
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::GetFirstSelectedCellInTable(PRInt32 *aRowIndex, PRInt32 *aColIndex, nsIDOMElement **aCell)
     1: {
 43806:   NS_ENSURE_TRUE(aCell, NS_ERROR_NULL_POINTER);
     1:   *aCell = nsnull;
     1:   if (aRowIndex)
     1:     *aRowIndex = 0;
     1:   if (aColIndex)
     1:     *aColIndex = 0;
     1: 
     1:   nsCOMPtr<nsIDOMElement> cell;
     1:   nsresult res = GetFirstSelectedCell(nsnull, getter_AddRefs(cell));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(cell, NS_EDITOR_ELEMENT_NOT_FOUND);
     1: 
     1:   *aCell = cell.get();
     1:   NS_ADDREF(*aCell);
     1: 
     1:   // Also return the row and/or column if requested
     1:   if (aRowIndex || aColIndex)
     1:   {
     1:     PRInt32 startRowIndex, startColIndex;
     1:     res = GetCellIndexes(cell, &startRowIndex, &startColIndex);
     1:     if(NS_FAILED(res)) return res;
     1: 
     1:     if (aRowIndex)
     1:       *aRowIndex = startRowIndex;
     1: 
     1:     if (aColIndex)
     1:       *aColIndex = startColIndex;
     1:   }
     1: 
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::SetSelectionAfterTableEdit(nsIDOMElement* aTable, PRInt32 aRow, PRInt32 aCol, 
 79445:                                      PRInt32 aDirection, bool aSelected)
     1: {
 43806:   NS_ENSURE_TRUE(aTable, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsISelection>selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   if (!selection)
     1:   {
     1: #ifdef DEBUG_cmanske
     1:     printf("Selection not found after table manipulation!\n");
     1: #endif
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMElement> cell;
 79445:   bool done = false;
     1:   do {
     1:     res = GetCellAt(aTable, aRow, aCol, getter_AddRefs(cell));
     1:     if (NS_SUCCEEDED(res))
     1:     {
     1:       if (cell)
     1:       {
     1:         if (aSelected)
     1:         {
     1:           // Reselect the cell
     1:           return SelectElement(cell);
     1:         }
     1:         else
     1:         {
     1:           // Set the caret to deepest first child
     1:           //   but don't go into nested tables
     1:           // TODO: Should we really be placing the caret at the END
     1:           //  of the cell content?
     1:           return CollapseSelectionToDeepestNonTableFirstChild(selection, cell);
     1:         }
     1:       } else {
     1:         // Setup index to find another cell in the 
     1:         //   direction requested, but move in
     1:         //   other direction if already at beginning of row or column
     1:         switch (aDirection)
     1:         {
     1:           case ePreviousColumn:
     1:             if (aCol == 0)
     1:             {
     1:               if (aRow > 0)
     1:                 aRow--;
     1:               else
 80486:                 done = true;
     1:             }
     1:             else
     1:               aCol--;
     1:             break;
     1:           case ePreviousRow:
     1:             if (aRow == 0)
     1:             {
     1:               if (aCol > 0)
     1:                 aCol--;
     1:               else
 80486:                 done = true;
     1:             }
     1:             else
     1:               aRow--;
     1:             break;
     1:           default:
 80486:             done = true;
     1:         }
     1:       }
     1:     }
     1:     else
     1:       break;
     1:   } while (!done);
     1: 
     1:   // We didn't find a cell
     1:   // Set selection to just before the table
     1:   nsCOMPtr<nsIDOMNode> tableParent;
     1:   res = aTable->GetParentNode(getter_AddRefs(tableParent));
     1:   if(NS_SUCCEEDED(res) && tableParent)
     1:   {
103677:     PRInt32 tableOffset = GetChildOffset(aTable, tableParent);
     1:     return selection->Collapse(tableParent, tableOffset);
     1:   }
     1:   // Last resort: Set selection to start of doc
     1:   // (it's very bad to not have a valid selection!)
     1:   return SetSelectionAtDocumentStart(selection);
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::GetSelectedOrParentTableElement(nsAString& aTagName,
     1:                                               PRInt32 *aSelectedCount,
     1:                                               nsIDOMElement** aTableElement)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aTableElement);
     1:   NS_ENSURE_ARG_POINTER(aSelectedCount);
     1:   *aTableElement = nsnull;
     1:   aTagName.Truncate();
     1:   *aSelectedCount = 0;
     1: 
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1: 
     1:   // Try to get the first selected cell
     1:   nsCOMPtr<nsIDOMElement> tableOrCellElement;
     1:   res = GetFirstSelectedCell(nsnull, getter_AddRefs(tableOrCellElement));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   NS_NAMED_LITERAL_STRING(tdName, "td");
     1: 
     1:   if (tableOrCellElement)
     1:   {
     1:       // Each cell is in its own selection range,
     1:       //  so count signals multiple-cell selection
     1:       res = selection->GetRangeCount(aSelectedCount);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       aTagName = tdName;
     1:   }
     1:   else
     1:   {
     1:     nsCOMPtr<nsIDOMNode> anchorNode;
     1:     res = selection->GetAnchorNode(getter_AddRefs(anchorNode));
     1:     if(NS_FAILED(res)) return res;
 43806:     NS_ENSURE_TRUE(anchorNode, NS_ERROR_FAILURE);
     1: 
     1:     nsCOMPtr<nsIDOMNode> selectedNode;
     1: 
     1:     // Get child of anchor node, if exists
 79445:     bool hasChildren;
     1:     anchorNode->HasChildNodes(&hasChildren);
     1: 
     1:     if (hasChildren)
     1:     {
     1:       PRInt32 anchorOffset;
     1:       res = selection->GetAnchorOffset(&anchorOffset);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       selectedNode = GetChildAt(anchorNode, anchorOffset);
     1:       if (!selectedNode)
     1:       {
     1:         selectedNode = anchorNode;
     1:         // If anchor doesn't have a child, we can't be selecting a table element,
     1:         //  so don't do the following:
     1:       }
     1:       else
     1:       {
     1:         nsCOMPtr<nsIAtom> atom = nsEditor::GetTag(selectedNode);
     1: 
     1:         if (atom == nsEditProperty::td)
     1:         {
     1:           tableOrCellElement = do_QueryInterface(selectedNode);
     1:           aTagName = tdName;
     1:           // Each cell is in its own selection range,
     1:           //  so count signals multiple-cell selection
     1:           res = selection->GetRangeCount(aSelectedCount);
 43805:           NS_ENSURE_SUCCESS(res, res);
     1:         }
     1:         else if (atom == nsEditProperty::table)
     1:         {
     1:           tableOrCellElement = do_QueryInterface(selectedNode);
     1:           aTagName.AssignLiteral("table");
     1:           *aSelectedCount = 1;
     1:         }
     1:         else if (atom == nsEditProperty::tr)
     1:         {
     1:           tableOrCellElement = do_QueryInterface(selectedNode);
     1:           aTagName.AssignLiteral("tr");
     1:           *aSelectedCount = 1;
     1:         }
     1:       }
     1:     }
     1:     if (!tableOrCellElement)
     1:     {
     1:       // Didn't find a table element -- find a cell parent
     1:       res = GetElementOrParentByTagName(tdName, anchorNode, getter_AddRefs(tableOrCellElement));
     1:       if(NS_FAILED(res)) return res;
     1:       if (tableOrCellElement)
     1:         aTagName = tdName;
     1:     }
     1:   }
     1:   if (tableOrCellElement)
     1:   {
     1:     *aTableElement = tableOrCellElement.get();
     1:     NS_ADDREF(*aTableElement);
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::GetSelectedCellsType(nsIDOMElement *aElement, PRUint32 *aSelectionType)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aSelectionType);
     1:   *aSelectionType = 0;
     1: 
     1:   // Be sure we have a table element 
     1:   //  (if aElement is null, this uses selection's anchor node)
     1:   nsCOMPtr<nsIDOMElement> table;
     1: 
     1:   nsresult res = GetElementOrParentByTagName(NS_LITERAL_STRING("table"), aElement, getter_AddRefs(table));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   PRInt32 rowCount, colCount;
     1:   res = GetTableSize(table, &rowCount, &colCount);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // Traverse all selected cells 
     1:   nsCOMPtr<nsIDOMElement> selectedCell;
     1:   res = GetFirstSelectedCell(nsnull, getter_AddRefs(selectedCell));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   if (res == NS_EDITOR_ELEMENT_NOT_FOUND) return NS_OK;
     1:   
     1:   // We have at least one selected cell, so set return value
     1:   *aSelectionType = nsISelectionPrivate::TABLESELECTION_CELL;
     1: 
     1:   // Store indexes of each row/col to avoid duplication of searches
 27986:   nsTArray<PRInt32> indexArray;
     1: 
 79445:   bool allCellsInRowAreSelected = false;
 79445:   bool allCellsInColAreSelected = false;
     1:   while (NS_SUCCEEDED(res) && selectedCell)
     1:   {
     1:     // Get the cell's location in the cellmap
     1:     PRInt32 startRowIndex, startColIndex;
     1:     res = GetCellIndexes(selectedCell, &startRowIndex, &startColIndex);
     1:     if(NS_FAILED(res)) return res;
     1:     
 27986:     if (!indexArray.Contains(startColIndex))
     1:     {
 27986:       indexArray.AppendElement(startColIndex);
     1:       allCellsInRowAreSelected = AllCellsInRowSelected(table, startRowIndex, colCount);
     1:       // We're done as soon as we fail for any row
     1:       if (!allCellsInRowAreSelected) break;
     1:     }
     1:     res = GetNextSelectedCell(nsnull, getter_AddRefs(selectedCell));
     1:   }
     1: 
     1:   if (allCellsInRowAreSelected)
     1:   {
     1:     *aSelectionType = nsISelectionPrivate::TABLESELECTION_ROW;
     1:     return NS_OK;
     1:   }
     1:   // Test for columns
     1: 
     1:   // Empty the indexArray
     1:   indexArray.Clear();
     1: 
     1:   // Start at first cell again
     1:   res = GetFirstSelectedCell(nsnull, getter_AddRefs(selectedCell));
     1:   while (NS_SUCCEEDED(res) && selectedCell)
     1:   {
     1:     // Get the cell's location in the cellmap
     1:     PRInt32 startRowIndex, startColIndex;
     1:     res = GetCellIndexes(selectedCell, &startRowIndex, &startColIndex);
     1:     if(NS_FAILED(res)) return res;
     1:   
 27986:     if (!indexArray.Contains(startRowIndex))
     1:     {
 27986:       indexArray.AppendElement(startColIndex);
     1:       allCellsInColAreSelected = AllCellsInColumnSelected(table, startColIndex, rowCount);
     1:       // We're done as soon as we fail for any column
     1:       if (!allCellsInRowAreSelected) break;
     1:     }
     1:     res = GetNextSelectedCell(nsnull, getter_AddRefs(selectedCell));
     1:   }
     1:   if (allCellsInColAreSelected)
     1:     *aSelectionType = nsISelectionPrivate::TABLESELECTION_COLUMN;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: bool 
     1: nsHTMLEditor::AllCellsInRowSelected(nsIDOMElement *aTable, PRInt32 aRowIndex, PRInt32 aNumberOfColumns)
     1: {
 80486:   NS_ENSURE_TRUE(aTable, false);
     1: 
     1:   PRInt32 curStartRowIndex, curStartColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1: 
 38053:   for( PRInt32 col = 0; col < aNumberOfColumns; col += NS_MAX(actualColSpan, 1))
     1:   {
     1:     nsCOMPtr<nsIDOMElement> cell;    
     1:     nsresult res = GetCellDataAt(aTable, aRowIndex, col, getter_AddRefs(cell),
     1:                                  &curStartRowIndex, &curStartColIndex,
     1:                                  &rowSpan, &colSpan,
     1:                                  &actualRowSpan, &actualColSpan, &isSelected);
     1:  
 80486:     NS_ENSURE_SUCCESS(res, false);
     1:     // If no cell, we may have a "ragged" right edge,
     1:     //   so return TRUE only if we already found a cell in the row
 80486:     NS_ENSURE_TRUE(cell, (col > 0) ? true : false);
     1: 
     1:     // Return as soon as a non-selected cell is found
 80486:     NS_ENSURE_TRUE(isSelected, false);
     1: 
     1:     NS_ASSERTION((actualColSpan > 0),"ActualColSpan = 0 in AllCellsInRowSelected");
     1:   }
 80486:   return true;
     1: }
     1: 
 79445: bool 
     1: nsHTMLEditor::AllCellsInColumnSelected(nsIDOMElement *aTable, PRInt32 aColIndex, PRInt32 aNumberOfRows)
     1: {
 80486:   NS_ENSURE_TRUE(aTable, false);
     1: 
     1:   PRInt32 curStartRowIndex, curStartColIndex, rowSpan, colSpan, actualRowSpan, actualColSpan;
 79445:   bool    isSelected;
     1: 
 38053:   for( PRInt32 row = 0; row < aNumberOfRows; row += NS_MAX(actualRowSpan, 1))
     1:   {
     1:     nsCOMPtr<nsIDOMElement> cell;    
     1:     nsresult res = GetCellDataAt(aTable, row, aColIndex, getter_AddRefs(cell),
     1:                                  &curStartRowIndex, &curStartColIndex,
     1:                                  &rowSpan, &colSpan,
     1:                                  &actualRowSpan, &actualColSpan, &isSelected);
     1:     
 80486:     NS_ENSURE_SUCCESS(res, false);
     1:     // If no cell, we must have a "ragged" right edge on the last column
     1:     //   so return TRUE only if we already found a cell in the row
 80486:     NS_ENSURE_TRUE(cell, (row > 0) ? true : false);
     1: 
     1:     // Return as soon as a non-selected cell is found
 80486:     NS_ENSURE_TRUE(isSelected, false);
     1:   }
 80486:   return true;
     1: }
     1: 
 79445: bool 
101127: nsHTMLEditor::IsEmptyCell(dom::Element* aCell)
     1: {
101127:   MOZ_ASSERT(aCell);
     1: 
     1:   // Check if target only contains empty text node or <br>
101127:   nsCOMPtr<nsINode> cellChild = aCell->GetFirstChild();
 88029:   if (!cellChild) {
 88029:     return false;
 88029:   }
 88029: 
 88029:   nsCOMPtr<nsINode> nextChild = cellChild->GetNextSibling();
 88029:   if (nextChild) {
 88029:     return false;
 88029:   }
 88029: 
     1:   // We insert a single break into a cell by default
     1:   //   to have some place to locate a cursor -- it is dispensable
 88029:   if (cellChild->IsElement() && cellChild->AsElement()->IsHTML(nsGkAtoms::br)) {
 88029:     return true;
 88029:   }
 88029: 
 88029:   bool isEmpty;
     1:   // Or check if no real content
 88029:   nsresult rv = IsEmptyNode(cellChild, &isEmpty, false, false);
 88029:   NS_ENSURE_SUCCESS(rv, false);
     1:   return isEmpty;
     1: }
