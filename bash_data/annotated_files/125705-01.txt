     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsView.h"
     1: #include "nsIWidget.h"
 51050: #include "nsWidgetsCID.h"
     1: #include "nsViewManager.h"
108457: #include "nsIFrame.h"
     1: #include "nsGUIEvent.h"
     1: #include "nsIComponentManager.h"
     1: #include "nsGfxCIID.h"
     1: #include "nsIInterfaceRequestor.h"
102308: #include "mozilla/Attributes.h"
120353: #include "mozilla/Likely.h"
124569: #include "mozilla/Util.h"
108457: #include "nsXULPopupManager.h"
108457: #include "nsIWidgetListener.h"
     1: 
124569: using namespace mozilla;
124569: 
     1: nsView::nsView(nsViewManager* aViewManager, nsViewVisibility aVisibility)
     1: {
     1:   MOZ_COUNT_CTOR(nsView);
     1: 
     1:   mVis = aVisibility;
     1:   // Views should be transparent by default. Not being transparent is
     1:   // a promise that the view will paint all its pixels opaquely. Views
     1:   // should make this promise explicitly by calling
     1:   // SetViewContentTransparency.
     1:   mVFlags = 0;
     1:   mViewManager = aViewManager;
106838:   mDirtyRegion = nullptr;
 80486:   mWidgetIsTopLevel = false;
118896:   mInAlternatePaint = false;
     1: }
     1: 
 32435: void nsView::DropMouseGrabbing()
 32435: {
 82568:   nsIPresShell* presShell = mViewManager->GetPresShell();
 82568:   if (presShell)
 82568:     presShell->ClearMouseCaptureOnView(this);
     1: }
     1: 
     1: nsView::~nsView()
     1: {
     1:   MOZ_COUNT_DTOR(nsView);
     1: 
     1:   while (GetFirstChild())
     1:   {
     1:     nsView* child = GetFirstChild();
     1:     if (child->GetViewManager() == mViewManager) {
     1:       child->Destroy();
     1:     } else {
     1:       // just unhook it. Someone else will want to destroy this.
     1:       RemoveChild(child);
     1:     }
     1:   }
     1: 
     1:   if (mViewManager)
     1:   {
     1:     DropMouseGrabbing();
     1:   
 64435:     nsView *rootView = mViewManager->GetRootViewImpl();
     1:     
     1:     if (rootView)
     1:     {
     1:       // Root views can have parents!
     1:       if (mParent)
     1:       {
     1:         mViewManager->RemoveChild(this);
     1:       }
     1: 
     1:       if (rootView == this)
     1:       {
     1:         // Inform the view manager that the root view has gone away...
106838:         mViewManager->SetRootView(nullptr);
     1:       }
     1:     }
     1:     else if (mParent)
     1:     {
     1:       mParent->RemoveChild(this);
     1:     }
     1:     
106838:     mViewManager = nullptr;
     1:   }
     1:   else if (mParent)
     1:   {
     1:     mParent->RemoveChild(this);
     1:   }
     1: 
     1:   // Destroy and release the widget
 63824:   DestroyWidget();
 63824: 
 63824:   delete mDirtyRegion;
 63824: }
 63824: 
 63824: void nsView::DestroyWidget()
 63824: {
     1:   if (mWindow)
     1:   {
 46193:     // If we are not attached to a base window, we're going to tear down our
 46193:     // widget here. However, if we're attached to somebody elses widget, we
 46193:     // want to leave the widget alone: don't reset the client data or call
 46193:     // Destroy. Just clear our event view ptr and free our reference to it. 
 46193:     if (mWidgetIsTopLevel) {
108461:       mWindow->SetAttachedWidgetListener(nullptr);
 46193:     }
 46193:     else {
108457:       mWindow->SetWidgetListener(nullptr);
     1:       mWindow->Destroy();
 46193:     }
 46193: 
     1:     NS_RELEASE(mWindow);
     1:   }
     1: }
     1: 
     1: nsresult nsView::QueryInterface(const nsIID& aIID, void** aInstancePtr)
     1: {
106838:   if (nullptr == aInstancePtr) {
     1:     return NS_ERROR_NULL_POINTER;
     1:   }
     1: 
     1:   NS_ASSERTION(!aIID.Equals(NS_GET_IID(nsISupports)),
     1:                "Someone expects views to be ISupports-derived!");
     1:   
106838:   *aInstancePtr = nullptr;
     1:   
     1:   if (aIID.Equals(NS_GET_IID(nsIView))) {
     1:     *aInstancePtr = (void*)(nsIView*)this;
     1:     return NS_OK;
     1:   }
     1: 
     1:   return NS_NOINTERFACE;
     1: }
     1: 
     1: nsIView* nsIView::GetViewFor(nsIWidget* aWidget)
     1: {
106838:   NS_PRECONDITION(nullptr != aWidget, "null widget ptr");
     1: 
108461:   nsIWidgetListener* listener = aWidget->GetWidgetListener();
108461:   if (listener) {
108461:     nsIView* view = listener->GetView();
108461:     if (view)
108461:       return view;
 87650:   }
 46193: 
108461:   listener = aWidget->GetAttachedWidgetListener();
108461:   return listener ? listener->GetView() : nullptr;
     1: }
     1: 
     1: void nsIView::Destroy()
     1: {
     1:   delete this;
     1: }
     1: 
     1: void nsView::SetPosition(nscoord aX, nscoord aY)
     1: {
     1:   mDimBounds.x += aX - mPosX;
     1:   mDimBounds.y += aY - mPosY;
     1:   mPosX = aX;
     1:   mPosY = aY;
     1: 
     1:   NS_ASSERTION(GetParent() || (aX == 0 && aY == 0),
     1:                "Don't try to move the root widget to something non-zero");
     1: 
 87349:   ResetWidgetBounds(true, false);
     1: }
     1: 
 87349: void nsView::ResetWidgetBounds(bool aRecurse, bool aForceSync)
 87349: {
     1:   if (mWindow) {
 87349:     if (!aForceSync) {
 87349:       // Don't change widget geometry synchronously, since that can
 87349:       // cause synchronous painting.
     1:       mViewManager->PostPendingUpdate();
 87349:     } else {
 87349:       DoResetWidgetBounds(false, true);
 87349:     }
     1:     return;
     1:   }
     1: 
 87349:   if (aRecurse) {
     1:     // reposition any widgets under this view
     1:     for (nsView* v = GetFirstChild(); v; v = v->GetNextSibling()) {
 87349:       v->ResetWidgetBounds(true, aForceSync);
     1:     }
     1:   }
     1: }
     1: 
 79445: bool nsIView::IsEffectivelyVisible()
 30996: {
 39430:   for (nsIView* v = this; v; v = v->mParent) {
 30996:     if (v->GetVisibility() == nsViewVisibility_kHide)
 80486:       return false;
 30996:   }
 80486:   return true;
 30996: }
 30996: 
 39430: nsIntRect nsIView::CalcWidgetBounds(nsWindowType aType)
  1884: {
108991:   int32_t p2a = mViewManager->AppUnitsPerDevPixel();
  1884: 
  1884:   nsRect viewBounds(mDimBounds);
  1884: 
 51042:   nsView* parent = GetParent()->Impl();
 47897:   if (parent) {
  1884:     nsPoint offset;
 47897:     nsIWidget* parentWidget = parent->GetNearestWidget(&offset, p2a);
 41178:     // make viewBounds be relative to the parent widget, in appunits
  1884:     viewBounds += offset;
  1884: 
  2048:     if (parentWidget && aType == eWindowType_popup &&
 30996:         IsEffectivelyVisible()) {
 46193:       // put offset into screen coordinates. (based on client area origin)
 25183:       nsIntPoint screenPoint = parentWidget->WidgetToScreenOffset();
 25183:       viewBounds += nsPoint(NSIntPixelsToAppUnits(screenPoint.x, p2a),
 25183:                             NSIntPixelsToAppUnits(screenPoint.y, p2a));
  1884:     }
  1884:   }
  1884: 
 41178:   // Compute widget bounds in device pixels
 28113:   nsIntRect newBounds = viewBounds.ToNearestPixels(p2a);
  1884: 
 47897:   // Compute where the top-left of our widget ended up relative to the parent
 47897:   // widget, in appunits.
  1884:   nsPoint roundedOffset(NSIntPixelsToAppUnits(newBounds.x, p2a),
  1884:                         NSIntPixelsToAppUnits(newBounds.y, p2a));
 41178: 
 41178:   // mViewToWidgetOffset is added to coordinates relative to the view origin
 41178:   // to get coordinates relative to the widget.
 41178:   // The view origin, relative to the parent widget, is at
 41178:   // (mPosX,mPosY) - mDimBounds.TopLeft() + viewBounds.TopLeft().
 41178:   // Our widget, relative to the parent widget, is roundedOffset.
 41178:   mViewToWidgetOffset = nsPoint(mPosX, mPosY)
 41178:     - mDimBounds.TopLeft() + viewBounds.TopLeft() - roundedOffset;
  1884: 
  1884:   return newBounds;
  1884: }
  1884: 
 79445: void nsView::DoResetWidgetBounds(bool aMoveOnly,
 79445:                                  bool aInvalidateChangedSize) {
     1:   // The geometry of a root view's widget is controlled externally,
     1:   // NOT by sizing or positioning the view
 64435:   if (mViewManager->GetRootViewImpl() == this) {
     1:     return;
     1:   }
     1:   
 23738:   nsIntRect curBounds;
 83107:   mWindow->GetClientBounds(curBounds);
 46193: 
     1:   nsWindowType type;
     1:   mWindow->GetWindowType(type);
     1: 
114450:   if (type == eWindowType_popup &&
114450:       ((curBounds.IsEmpty() && mDimBounds.IsEmpty()) ||
114450:        mVis == nsViewVisibility_kHide)) {
114450:     // Don't manipulate empty or hidden popup widgets. For example there's no
114450:     // point moving hidden comboboxes around, or doing X server roundtrips
     1:     // to compute their true screen position. This could mean that WidgetToScreen
     1:     // operations on these widgets don't return up-to-date values, but popup
     1:     // positions aren't reliable anyway because of correction to be on or off-screen.
     1:     return;
     1:   }
     1: 
 61364:   NS_PRECONDITION(mWindow, "Why was this called??");
 61364: 
 23738:   nsIntRect newBounds = CalcWidgetBounds(type);
     1: 
 79445:   bool changedPos = curBounds.TopLeft() != newBounds.TopLeft();
 79445:   bool changedSize = curBounds.Size() != newBounds.Size();
     1: 
 46193:   // Child views are never attached to top level widgets, this is safe.
125073: 
125073:   // Coordinates are converted to display pixels for window Move/Resize APIs,
125073:   // because of the potential for device-pixel coordinate spaces for mixed
125073:   // hidpi/lodpi screens to overlap each other and result in bad placement
125073:   // (bug 814434).
125073:   nsRefPtr<nsDeviceContext> dx;
125073:   mViewManager->GetDeviceContext(*getter_AddRefs(dx));
125073:   double invScale = dx->UnscaledAppUnitsPerDevPixel() / 60.0;
125073: 
     1:   if (changedPos) {
     1:     if (changedSize && !aMoveOnly) {
125635:       mWindow->ResizeClient(newBounds.x * invScale,
125635:                             newBounds.y * invScale,
125635:                             newBounds.width * invScale,
125635:                             newBounds.height * invScale,
     1:                             aInvalidateChangedSize);
     1:     } else {
125635:       mWindow->MoveClient(newBounds.x * invScale,
125635:                           newBounds.y * invScale);
     1:     }
     1:   } else {
     1:     if (changedSize && !aMoveOnly) {
125635:       mWindow->ResizeClient(newBounds.width * invScale,
125635:                             newBounds.height * invScale,
 83107:                             aInvalidateChangedSize);
     1:     } // else do nothing!
     1:   }
     1: }
     1: 
 79445: void nsView::SetDimensions(const nsRect& aRect, bool aPaint, bool aResizeWidget)
     1: {
     1:   nsRect dims = aRect;
     1:   dims.MoveBy(mPosX, mPosY);
     1: 
     1:   // Don't use nsRect's operator== here, since it returns true when
     1:   // both rects are empty even if they have different widths and we
     1:   // have cases where that sort of thing matters to us.
     1:   if (mDimBounds.TopLeft() == dims.TopLeft() &&
     1:       mDimBounds.Size() == dims.Size()) {
     1:     return;
     1:   }
     1: 
     1:   mDimBounds = dims;
     1: 
     1:   if (aResizeWidget) {
 87349:     ResetWidgetBounds(false, false);
     1:   }
     1: }
     1: 
 79445: void nsView::NotifyEffectiveVisibilityChanged(bool aEffectivelyVisible)
     1: {
 30996:   if (!aEffectivelyVisible)
     1:   {
     1:     DropMouseGrabbing();
     1:   }
     1: 
106838:   if (nullptr != mWindow)
     1:   {
 61364:     if (aEffectivelyVisible)
 61364:     {
 80486:       DoResetWidgetBounds(false, true);
 80486:       mWindow->Show(true);
 61364:     }
 61364:     else
 80486:       mWindow->Show(false);
     1:   }
     1: 
 30996:   for (nsView* child = mFirstChild; child; child = child->mNextSibling) {
 30996:     if (child->mVis == nsViewVisibility_kHide) {
 30996:       // It was effectively hidden and still is
 30996:       continue;
 30996:     }
 30996:     // Our child is visible if we are
 30996:     child->NotifyEffectiveVisibilityChanged(aEffectivelyVisible);
 30996:   }
 30996: }
 30996: 
 30996: NS_IMETHODIMP nsView::SetVisibility(nsViewVisibility aVisibility)
 30996: {
 30996:   mVis = aVisibility;
 30996:   NotifyEffectiveVisibilityChanged(IsEffectivelyVisible());
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP nsView::SetFloating(bool aFloatingView)
     1: {
     1: 	if (aFloatingView)
     1: 		mVFlags |= NS_VIEW_FLAG_FLOATING;
     1: 	else
     1: 		mVFlags &= ~NS_VIEW_FLAG_FLOATING;
     1: 
     1: #if 0
     1: 	// recursively make all sub-views "floating" grr.
     1: 	for (nsView* child = mFirstChild; chlid; child = child->GetNextSibling()) {
     1: 		child->SetFloating(aFloatingView);
     1: 	}
     1: #endif
     1: 
     1: 	return NS_OK;
     1: }
     1: 
     1: void nsView::InvalidateHierarchy(nsViewManager *aViewManagerParent)
     1: {
 64435:   if (mViewManager->GetRootViewImpl() == this)
     1:     mViewManager->InvalidateHierarchy();
     1: 
     1:   for (nsView *child = mFirstChild; child; child = child->GetNextSibling())
     1:     child->InvalidateHierarchy(aViewManagerParent);
     1: }
     1: 
     1: void nsView::InsertChild(nsView *aChild, nsView *aSibling)
     1: {
106838:   NS_PRECONDITION(nullptr != aChild, "null ptr");
     1: 
106838:   if (nullptr != aChild)
     1:   {
106838:     if (nullptr != aSibling)
     1:     {
102909: #ifdef DEBUG
     1:       NS_ASSERTION(aSibling->GetParent() == this, "tried to insert view with invalid sibling");
     1: #endif
     1:       //insert after sibling
     1:       aChild->SetNextSibling(aSibling->GetNextSibling());
     1:       aSibling->SetNextSibling(aChild);
     1:     }
     1:     else
     1:     {
     1:       aChild->SetNextSibling(mFirstChild);
     1:       mFirstChild = aChild;
     1:     }
     1:     aChild->SetParent(this);
     1: 
     1:     // If we just inserted a root view, then update the RootViewManager
     1:     // on all view managers in the new subtree.
     1: 
     1:     nsViewManager *vm = aChild->GetViewManager();
 64435:     if (vm->GetRootViewImpl() == aChild)
     1:     {
106838:       aChild->InvalidateHierarchy(nullptr); // don't care about releasing grabs
     1:     }
     1:   }
     1: }
     1: 
     1: void nsView::RemoveChild(nsView *child)
     1: {
106838:   NS_PRECONDITION(nullptr != child, "null ptr");
     1: 
106838:   if (nullptr != child)
     1:   {
106838:     nsView* prevKid = nullptr;
     1:     nsView* kid = mFirstChild;
124569:     DebugOnly<bool> found = false;
106838:     while (nullptr != kid) {
     1:       if (kid == child) {
106838:         if (nullptr != prevKid) {
     1:           prevKid->SetNextSibling(kid->GetNextSibling());
     1:         } else {
     1:           mFirstChild = kid->GetNextSibling();
     1:         }
106838:         child->SetParent(nullptr);
 80486:         found = true;
     1:         break;
     1:       }
     1:       prevKid = kid;
     1: 	    kid = kid->GetNextSibling();
     1:     }
     1:     NS_ASSERTION(found, "tried to remove non child");
     1: 
     1:     // If we just removed a root view, then update the RootViewManager
     1:     // on all view managers in the removed subtree.
     1: 
     1:     nsViewManager *vm = child->GetViewManager();
 64435:     if (vm->GetRootViewImpl() == child)
     1:     {
     1:       child->InvalidateHierarchy(GetViewManager());
     1:     }
     1:   }
     1: }
     1: 
     1: // Native widgets ultimately just can't deal with the awesome power of
     1: // CSS2 z-index. However, we set the z-index on the widget anyway
     1: // because in many simple common cases the widgets do end up in the
     1: // right order. We set each widget's z-index to the z-index of the
     1: // nearest ancestor that has non-auto z-index.
108991: static void UpdateNativeWidgetZIndexes(nsView* aView, int32_t aZIndex)
     1: {
     1:   if (aView->HasWidget()) {
     1:     nsIWidget* widget = aView->GetWidget();
108991:     int32_t curZ;
     1:     widget->GetZIndex(&curZ);
     1:     if (curZ != aZIndex) {
     1:       widget->SetZIndex(aZIndex);
     1:     }
     1:   } else {
     1:     for (nsView* v = aView->GetFirstChild(); v; v = v->GetNextSibling()) {
     1:       if (v->GetZIndexIsAuto()) {
     1:         UpdateNativeWidgetZIndexes(v, aZIndex);
     1:       }
     1:     }
     1:   }
     1: }
     1: 
108991: static int32_t FindNonAutoZIndex(nsView* aView)
     1: {
     1:   while (aView) {
     1:     if (!aView->GetZIndexIsAuto()) {
     1:       return aView->GetZIndex();
     1:     }
     1:     aView = aView->GetParent();
     1:   }
     1:   return 0;
     1: }
     1: 
 51050: nsresult nsIView::CreateWidget(nsWidgetInitData *aWidgetInitData,
 79445:                                bool aEnableDragDrop,
 79445:                                bool aResetVisibility)
 51050: {
 51050:   return Impl()->CreateWidget(aWidgetInitData,
 54355:                               aEnableDragDrop, aResetVisibility);
 51050: }
 51050: 
 51050: nsresult nsIView::CreateWidgetForParent(nsIWidget* aParentWidget,
     1:                                         nsWidgetInitData *aWidgetInitData,
 79445:                                         bool aEnableDragDrop,
 79445:                                         bool aResetVisibility)
     1: {
 51050:   return Impl()->CreateWidgetForParent(aParentWidget, aWidgetInitData,
 54355:                                        aEnableDragDrop, aResetVisibility);
 51048: }
 51048: 
 51050: nsresult nsIView::CreateWidgetForPopup(nsWidgetInitData *aWidgetInitData,
 51048:                                        nsIWidget* aParentWidget,
 79445:                                        bool aEnableDragDrop,
 79445:                                        bool aResetVisibility)
 51048: {
 51050:   return Impl()->CreateWidgetForPopup(aWidgetInitData, aParentWidget,
 54355:                                       aEnableDragDrop, aResetVisibility);
 51042: }
 51042: 
 63824: void nsIView::DestroyWidget()
 63824: {
 63824:   Impl()->DestroyWidget();
 63824: }
 63824: 
 51346: struct DefaultWidgetInitData : public nsWidgetInitData {
 51346:   DefaultWidgetInitData() : nsWidgetInitData()
 51346:   {
 51346:     mWindowType = eWindowType_child;
 80486:     clipChildren = true;
 80486:     clipSiblings = true;
 51346:   }
 51346: };
 51346: 
 51050: nsresult nsView::CreateWidget(nsWidgetInitData *aWidgetInitData,
 79445:                               bool aEnableDragDrop,
 79445:                               bool aResetVisibility)
 51042: {
 51050:   AssertNoWindow();
 51048:   NS_ABORT_IF_FALSE(!aWidgetInitData ||
 51048:                     aWidgetInitData->mWindowType != eWindowType_popup,
 51048:                     "Use CreateWidgetForPopup");
     1: 
 51346:   DefaultWidgetInitData defaultInitData;
 79445:   bool initDataPassedIn = !!aWidgetInitData;
 51346:   aWidgetInitData = aWidgetInitData ? aWidgetInitData : &defaultInitData;
 51353:   defaultInitData.mListenForResizes =
 51353:     (!initDataPassedIn && GetParent() &&
 51353:      GetParent()->GetViewManager() != mViewManager);
 51044: 
 51044:   nsIntRect trect = CalcWidgetBounds(aWidgetInitData->mWindowType);
     1: 
 68668:   nsRefPtr<nsDeviceContext> dx;
  1884:   mViewManager->GetDeviceContext(*getter_AddRefs(dx));
     1: 
 51048:   nsIWidget* parentWidget =
106838:     GetParent() ? GetParent()->GetNearestWidget(nullptr) : nullptr;
 51050:   if (!parentWidget) {
 51050:     NS_ERROR("nsView::CreateWidget without suitable parent widget??");
 51050:     return NS_ERROR_FAILURE;
 51050:   }
 51048: 
 51050:   // XXX: using aForceUseIWidgetParent=true to preserve previous
 51050:   // semantics.  It's not clear that it's actually needed.
108460:   mWindow = parentWidget->CreateChild(trect, dx, aWidgetInitData,
 80486:                                       true).get();
 51050:   if (!mWindow) {
 51050:     return NS_ERROR_FAILURE;
 51050:   }
 51048:  
 51048:   InitializeWindow(aEnableDragDrop, aResetVisibility);
 51048: 
 51048:   return NS_OK;
 51048: }
 51048: 
 51050: nsresult nsView::CreateWidgetForParent(nsIWidget* aParentWidget,
 51048:                                        nsWidgetInitData *aWidgetInitData,
 79445:                                        bool aEnableDragDrop,
 79445:                                        bool aResetVisibility)
 51048: {
 51050:   AssertNoWindow();
 51048:   NS_ABORT_IF_FALSE(!aWidgetInitData ||
 51048:                     aWidgetInitData->mWindowType != eWindowType_popup,
 51048:                     "Use CreateWidgetForPopup");
 51048:   NS_ABORT_IF_FALSE(aParentWidget, "Parent widget required");
 51048: 
 51346:   DefaultWidgetInitData defaultInitData;
 51346:   aWidgetInitData = aWidgetInitData ? aWidgetInitData : &defaultInitData;
 51346: 
 51346:   nsIntRect trect = CalcWidgetBounds(aWidgetInitData->mWindowType);
 51048: 
 68668:   nsRefPtr<nsDeviceContext> dx;
 51048:   mViewManager->GetDeviceContext(*getter_AddRefs(dx));
 51048: 
 51050:   mWindow =
108460:     aParentWidget->CreateChild(trect, dx, aWidgetInitData).get();
 51050:   if (!mWindow) {
 51050:     return NS_ERROR_FAILURE;
 51050:   }
 51048: 
 51048:   InitializeWindow(aEnableDragDrop, aResetVisibility);
 51048: 
 51048:   return NS_OK;
 51048: }
 51048: 
 51050: nsresult nsView::CreateWidgetForPopup(nsWidgetInitData *aWidgetInitData,
 51048:                                       nsIWidget* aParentWidget,
 79445:                                       bool aEnableDragDrop,
 79445:                                       bool aResetVisibility)
 51048: {
 51050:   AssertNoWindow();
 51048:   NS_ABORT_IF_FALSE(aWidgetInitData, "Widget init data required");
 51048:   NS_ABORT_IF_FALSE(aWidgetInitData->mWindowType == eWindowType_popup,
 51048:                     "Use one of the other CreateWidget methods");
 51048: 
 51048:   nsIntRect trect = CalcWidgetBounds(aWidgetInitData->mWindowType);
 51048: 
 68668:   nsRefPtr<nsDeviceContext> dx;
 51048:   mViewManager->GetDeviceContext(*getter_AddRefs(dx));
 51048: 
 51048:   // XXX/cjones: having these two separate creation cases seems ... um
 51048:   // ... unnecessary, but it's the way the old code did it.  Please
 51048:   // unify them by first finding a suitable parent nsIWidget, then
 51050:   // getting rid of aForceUseIWidgetParent.
  8408:   if (aParentWidget) {
 51050:     // XXX: using aForceUseIWidgetParent=true to preserve previous
 51050:     // semantics.  It's not clear that it's actually needed.
108460:     mWindow = aParentWidget->CreateChild(trect, dx, aWidgetInitData,
 80486:                                          true).get();
  8408:   }
  8408:   else {
106838:     nsIWidget* nearestParent = GetParent() ? GetParent()->GetNearestWidget(nullptr)
106838:                                            : nullptr;
 51046:     if (!nearestParent) {
 51046:       // Without a parent, we can't make a popup.  This can happen
 51046:       // when printing
 51046:       return NS_ERROR_FAILURE;
 51046:     }
 51046: 
 51050:     mWindow =
108460:       nearestParent->CreateChild(trect, dx, aWidgetInitData).get();
 51050:   }
 51050:   if (!mWindow) {
 51050:     return NS_ERROR_FAILURE;
 51046:   }
 51045: 
 51047:   InitializeWindow(aEnableDragDrop, aResetVisibility);
 51047: 
 51047:   return NS_OK;
 51047: }
 51047: 
 51047: void
 79445: nsView::InitializeWindow(bool aEnableDragDrop, bool aResetVisibility)
 51047: {
 51047:   NS_ABORT_IF_FALSE(mWindow, "Must have a window to initialize");
 51047: 
108461:   mWindow->SetWidgetListener(this);
 51050: 
     1:   if (aEnableDragDrop) {
 80486:     mWindow->EnableDragDrop(true);
     1:   }
     1:       
     1:   // propagate the z-index to the widget.
 51042:   UpdateNativeWidgetZIndexes(this, FindNonAutoZIndex(this));
     1: 
     1:   //make sure visibility state is accurate
     1: 
     1:   if (aResetVisibility) {
 51042:     SetVisibility(GetVisibility());
     1:   }
     1: }
     1: 
 46193: // Attach to a top level widget and start receiving mirrored events.
 46193: nsresult nsIView::AttachToTopLevelWidget(nsIWidget* aWidget)
 46193: {
106838:   NS_PRECONDITION(nullptr != aWidget, "null widget ptr");
 46193:   /// XXXjimm This is a temporary workaround to an issue w/document
 46193:   // viewer (bug 513162).
108461:   nsIWidgetListener* listener = aWidget->GetAttachedWidgetListener();
108461:   if (listener) {
108461:     nsIView *oldView = listener->GetView();
 46193:     if (oldView) {
 46193:       oldView->DetachFromTopLevelWidget();
 46193:     }
108461:   }
 46193: 
 68668:   nsRefPtr<nsDeviceContext> dx;
 46193:   mViewManager->GetDeviceContext(*getter_AddRefs(dx));
 46193: 
 46193:   // Note, the previous device context will be released. Detaching
 46193:   // will not restore the old one.
108460:   nsresult rv = aWidget->AttachViewToTopLevel(!nsIWidget::UsePuppetWidgets(), dx);
 46193:   if (NS_FAILED(rv))
 46193:     return rv;
 46193: 
 46193:   mWindow = aWidget;
 46193:   NS_ADDREF(mWindow);
 46193: 
108461:   mWindow->SetAttachedWidgetListener(Impl());
 80486:   mWindow->EnableDragDrop(true);
 80486:   mWidgetIsTopLevel = true;
 46193: 
 46193:   // Refresh the view bounds
 46193:   nsWindowType type;
 46193:   mWindow->GetWindowType(type);
 46193:   CalcWidgetBounds(type);
 46193: 
 46193:   return NS_OK;
 46193: }
 46193: 
 46193: // Detach this view from an attached widget. 
 46193: nsresult nsIView::DetachFromTopLevelWidget()
 46193: {
 46193:   NS_PRECONDITION(mWidgetIsTopLevel, "Not attached currently!");
 46193:   NS_PRECONDITION(mWindow, "null mWindow for DetachFromTopLevelWidget!");
 46193: 
108461:   mWindow->SetAttachedWidgetListener(nullptr);
 46193:   NS_RELEASE(mWindow);
 46193: 
 80486:   mWidgetIsTopLevel = false;
 46193:   
 46193:   return NS_OK;
 46193: }
 46193: 
108991: void nsView::SetZIndex(bool aAuto, int32_t aZIndex, bool aTopMost)
     1: {
 79445:   bool oldIsAuto = GetZIndexIsAuto();
     1:   mVFlags = (mVFlags & ~NS_VIEW_FLAG_AUTO_ZINDEX) | (aAuto ? NS_VIEW_FLAG_AUTO_ZINDEX : 0);
     1:   mZIndex = aZIndex;
     1:   SetTopMost(aTopMost);
     1:   
     1:   if (HasWidget() || !oldIsAuto || !aAuto) {
     1:     UpdateNativeWidgetZIndexes(this, FindNonAutoZIndex(this));
     1:   }
     1: }
     1: 
 51050: void nsView::AssertNoWindow()
     1: {
 51050:   // XXX: it would be nice to make this a strong assert
120353:   if (MOZ_UNLIKELY(mWindow)) {
 51048:     NS_ERROR("We already have a window for this view? BAD");
108457:     mWindow->SetWidgetListener(nullptr);
 51048:     mWindow->Destroy();
 51048:     NS_RELEASE(mWindow);
 51048:   }
     1: }
     1: 
 51050: //
 51050: // internal window creation functions
 51050: //
108460: void nsIView::AttachWidgetEventHandler(nsIWidget* aWidget)
 30522: {
 30522: #ifdef DEBUG
108457:   NS_ASSERTION(!aWidget->GetWidgetListener(), "Already have a widget listener");
 30522: #endif
 30522: 
108461:   aWidget->SetWidgetListener(Impl());
 30522: }
 30522: 
 30522: void nsIView::DetachWidgetEventHandler(nsIWidget* aWidget)
 30522: {
108461:   NS_ASSERTION(!aWidget->GetWidgetListener() ||
108461:                aWidget->GetWidgetListener()->GetView() == this, "Wrong view");
108457:   aWidget->SetWidgetListener(nullptr);
 30522: }
 30522: 
     1: #ifdef DEBUG
108991: void nsIView::List(FILE* out, int32_t aIndent) const
     1: {
108991:   int32_t i;
     1:   for (i = aIndent; --i >= 0; ) fputs("  ", out);
     1:   fprintf(out, "%p ", (void*)this);
106838:   if (nullptr != mWindow) {
 47897:     nscoord p2a = mViewManager->AppUnitsPerDevPixel();
 23738:     nsIntRect rect;
 23738:     mWindow->GetClientBounds(rect);
 28113:     nsRect windowBounds = rect.ToAppUnits(p2a);
 23738:     mWindow->GetBounds(rect);
 28113:     nsRect nonclientBounds = rect.ToAppUnits(p2a);
     1:     nsrefcnt widgetRefCnt = mWindow->AddRef() - 1;
     1:     mWindow->Release();
108991:     int32_t Z;
     1:     mWindow->GetZIndex(&Z);
     1:     fprintf(out, "(widget=%p[%d] z=%d pos={%d,%d,%d,%d}) ",
     1:             (void*)mWindow, widgetRefCnt, Z,
     1:             nonclientBounds.x, nonclientBounds.y,
     1:             windowBounds.width, windowBounds.height);
     1:   }
     1:   nsRect brect = GetBounds();
     1:   fprintf(out, "{%d,%d,%d,%d}",
     1:           brect.x, brect.y, brect.width, brect.height);
 82566:   fprintf(out, " z=%d vis=%d frame=%p <\n",
 94492:           mZIndex, mVis, static_cast<void*>(mFrame));
     1:   for (nsView* kid = mFirstChild; kid; kid = kid->GetNextSibling()) {
     1:     NS_ASSERTION(kid->GetParent() == this, "incorrect parent");
     1:     kid->List(out, aIndent + 1);
     1:   }
     1:   for (i = aIndent; --i >= 0; ) fputs("  ", out);
     1:   fputs(">\n", out);
     1: }
     1: #endif // DEBUG
     1: 
     1: nsPoint nsIView::GetOffsetTo(const nsIView* aOther) const
     1: {
 51042:   return Impl()->GetOffsetTo(static_cast<const nsView*>(aOther),
 51042:                              Impl()->GetViewManager()->AppUnitsPerDevPixel());
 47897: }
 47897: 
 47897: nsPoint nsView::GetOffsetTo(const nsView* aOther) const
 47897: {
 47897:   return GetOffsetTo(aOther, GetViewManager()->AppUnitsPerDevPixel());
 47897: }
 47897: 
108991: nsPoint nsView::GetOffsetTo(const nsView* aOther, const int32_t aAPD) const
 47897: {
 56350:   NS_ABORT_IF_FALSE(GetParent() || !aOther || aOther->GetParent() ||
 56350:                     this == aOther, "caller of (outer) GetOffsetTo must not "
 56350:                     "pass unrelated views");
 47897:   // We accumulate the final result in offset
     1:   nsPoint offset(0, 0);
 47897:   // The offset currently accumulated at the current APD
 47897:   nsPoint docOffset(0, 0);
 47897:   const nsView* v = this;
 47897:   nsViewManager* currVM = v->GetViewManager();
108991:   int32_t currAPD = currVM->AppUnitsPerDevPixel();
106838:   const nsView* root = nullptr;
 47897:   for ( ; v != aOther && v; root = v, v = v->GetParent()) {
 47897:     nsViewManager* newVM = v->GetViewManager();
 47897:     if (newVM != currVM) {
108991:       int32_t newAPD = newVM->AppUnitsPerDevPixel();
 47897:       if (newAPD != currAPD) {
 47897:         offset += docOffset.ConvertAppUnits(currAPD, aAPD);
 47897:         docOffset.x = docOffset.y = 0;
 47897:         currAPD = newAPD;
     1:       }
 47897:       currVM = newVM;
 47897:     }
 47897:     docOffset += v->GetPosition();
 47897:   }
 47897:   offset += docOffset.ConvertAppUnits(currAPD, aAPD);
     1: 
     1:   if (v != aOther) {
     1:     // Looks like aOther wasn't an ancestor of |this|.  So now we have
 47897:     // the root-VM-relative position of |this| in |offset|.  Get the
 47897:     // root-VM-relative position of aOther and subtract it.
 47897:     nsPoint negOffset = aOther->GetOffsetTo(root, aAPD);
 47897:     offset -= negOffset;
     1:   }
     1: 
     1:   return offset;
     1: }
     1: 
 47897: nsPoint nsIView::GetOffsetToWidget(nsIWidget* aWidget) const
 47897: {
 47897:   nsPoint pt;
 47897:   // Get the view for widget
 51042:   nsIView* widgetIView = GetViewFor(aWidget);
 51042:   if (!widgetIView) {
 47897:     return pt;
 47897:   }
 51042:   nsView* widgetView = widgetIView->Impl();
 51042: 
 47897:   // Get the offset to the widget view in the widget view's APD
 47897:   // We get the offset in the widget view's APD first and then convert to our
 47897:   // APD afterwards so that we can include the widget view's ViewToWidgetOffset
 47897:   // in the sum in its native APD, and then convert the whole thing to our APD
 47897:   // so that we don't have to convert the APD of the relatively small
 47897:   // ViewToWidgetOffset by itself with a potentially large relative rounding
 47897:   // error.
 47897:   pt = -widgetView->GetOffsetTo(static_cast<const nsView*>(this));
 47897:   // Add in the offset to the widget.
 47897:   pt += widgetView->ViewToWidgetOffset();
 47897: 
 47897:   // Convert to our appunits.
108991:   int32_t widgetAPD = widgetView->GetViewManager()->AppUnitsPerDevPixel();
108991:   int32_t ourAPD = static_cast<const nsView*>(this)->
 47897:                     GetViewManager()->AppUnitsPerDevPixel();
 47897:   pt = pt.ConvertAppUnits(widgetAPD, ourAPD);
 47897:   return pt;
 47897: }
 47897: 
     1: nsIWidget* nsIView::GetNearestWidget(nsPoint* aOffset) const
     1: {
 51042:   return Impl()->GetNearestWidget(aOffset,
 51042:                                   Impl()->GetViewManager()->AppUnitsPerDevPixel());
 47897: }
 47897: 
 47897: nsIWidget* nsView::GetNearestWidget(nsPoint* aOffset) const
 47897: {
 47897:   return GetNearestWidget(aOffset, GetViewManager()->AppUnitsPerDevPixel());
 47897: }
 47897: 
108991: nsIWidget* nsView::GetNearestWidget(nsPoint* aOffset, const int32_t aAPD) const
 47897: {
 46193:   // aOffset is based on the view's position, which ignores any chrome on
 46193:   // attached parent widgets.
 46193: 
 47897:   // We accumulate the final result in pt
     1:   nsPoint pt(0, 0);
 47897:   // The offset currently accumulated at the current APD
 47897:   nsPoint docPt(0,0);
 47897:   const nsView* v = this;
 47897:   nsViewManager* currVM = v->GetViewManager();
108991:   int32_t currAPD = currVM->AppUnitsPerDevPixel();
 47897:   for ( ; v && !v->HasWidget(); v = v->GetParent()) {
 47897:     nsViewManager* newVM = v->GetViewManager();
 47897:     if (newVM != currVM) {
108991:       int32_t newAPD = newVM->AppUnitsPerDevPixel();
 47897:       if (newAPD != currAPD) {
 47897:         pt += docPt.ConvertAppUnits(currAPD, aAPD);
 47897:         docPt.x = docPt.y = 0;
 47897:         currAPD = newAPD;
 47897:       }
 47897:       currVM = newVM;
 47897:     }
 47897:     docPt += v->GetPosition();
     1:   }
     1:   if (!v) {
     1:     if (aOffset) {
 47897:       pt += docPt.ConvertAppUnits(currAPD, aAPD);
     1:       *aOffset = pt;
     1:     }
106838:     return nullptr;
     1:   }
     1: 
 47897:   // pt is now the offset from v's origin to this view's origin.
 47897:   // We add the ViewToWidgetOffset to get the offset to the widget.
     1:   if (aOffset) {
 47897:     docPt += v->ViewToWidgetOffset();
 47897:     pt += docPt.ConvertAppUnits(currAPD, aAPD);
 47897:     *aOffset = pt;
     1:   }
     1:   return v->GetWidget();
     1: }
     1: 
 79445: bool nsIView::IsRoot() const
     1: {
106838:   NS_ASSERTION(mViewManager != nullptr," View manager is null in nsView::IsRoot()");
 64435:   return mViewManager->GetRootViewImpl() == this;
     1: }
     1: 
 79445: bool nsIView::ExternalIsRoot() const
     1: {
     1:   return nsIView::IsRoot();
     1: }
  8292: 
 51042: nsView*
 51042: nsIView::Impl()
 51042: {
 51042:   return static_cast<nsView*>(this);
 51042: }
 51042: 
 51042: const nsView*
 51042: nsIView::Impl() const
 51042: {
 51042:   return static_cast<const nsView*>(this);
 51042: }
 51042: 
 47897: nsRect
 47897: nsView::GetBoundsInParentUnits() const
 47897: {
 47897:   nsView* parent = GetParent();
 47897:   nsViewManager* VM = GetViewManager();
 64435:   if (this != VM->GetRootViewImpl() || !parent) {
 47897:     return mDimBounds;
 47897:   }
108991:   int32_t ourAPD = VM->AppUnitsPerDevPixel();
108991:   int32_t parentAPD = parent->GetViewManager()->AppUnitsPerDevPixel();
 47897:   return mDimBounds.ConvertAppUnitsRoundOut(ourAPD, parentAPD);
 47897: }
 47897: 
 47897: nsPoint
 69702: nsIView::ConvertFromParentCoords(nsPoint aPt) const
 47897: {
 69702:   const nsView* view = static_cast<const nsView*>(this);
 69702:   const nsView* parent = view->GetParent();
 47897:   if (parent) {
 47897:     aPt = aPt.ConvertAppUnits(parent->GetViewManager()->AppUnitsPerDevPixel(),
 69702:                               view->GetViewManager()->AppUnitsPerDevPixel());
 47897:   }
 47897:   aPt -= GetPosition();
 47897:   return aPt;
 47897: }
108461: 
108461: static bool
108461: IsPopupWidget(nsIWidget* aWidget)
108461: {
108461:   nsWindowType type;
108461:   aWidget->GetWindowType(type);
108461:   return (type == eWindowType_popup);
108461: }
108461: 
108461: nsIPresShell*
108461: nsView::GetPresShell()
108461: {
108461:   return GetViewManager()->GetPresShell();
108461: }
108461: 
108461: bool
108991: nsView::WindowMoved(nsIWidget* aWidget, int32_t x, int32_t y)
108461: {
108461:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
108461:   if (pm && IsPopupWidget(aWidget)) {
108461:     pm->PopupMoved(mFrame, nsIntPoint(x, y));
108461:     return true;
108461:   }
108461: 
108461:   return false;
108461: }
108461: 
108461: bool
108991: nsView::WindowResized(nsIWidget* aWidget, int32_t aWidth, int32_t aHeight)
108461: {
108461:   // The root view may not be set if this is the resize associated with
108461:   // window creation
108875:   SetForcedRepaint(true);
108461:   if (this == mViewManager->GetRootView()) {
108461:     nsRefPtr<nsDeviceContext> devContext;
108461:     mViewManager->GetDeviceContext(*getter_AddRefs(devContext));
108991:     int32_t p2a = devContext->AppUnitsPerDevPixel();
108461:     mViewManager->SetWindowDimensions(NSIntPixelsToAppUnits(aWidth, p2a),
108461:                                       NSIntPixelsToAppUnits(aHeight, p2a));
108461:     return true;
108461:   }
108461:   else if (IsPopupWidget(aWidget)) {
108461:     nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
108461:     if (pm) {
108461:       pm->PopupResized(mFrame, nsIntSize(aWidth, aHeight));
108461:       return true;
108461:     }
108461:   }
108461: 
108461:   return false;
108461: }
108461: 
108461: bool
108461: nsView::RequestWindowClose(nsIWidget* aWidget)
108461: {
108461:   if (mFrame && IsPopupWidget(aWidget) &&
108461:       mFrame->GetType() == nsGkAtoms::menuPopupFrame) {
108461:     nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
108461:     if (pm) {
108461:       pm->HidePopup(mFrame->GetContent(), false, true, false);
108461:       return true;
108461:     }
108461:   }
108461: 
108461:   return false;
108461: }
108461: 
108461: void
108461: nsView::WillPaintWindow(nsIWidget* aWidget, bool aWillSendDidPaint)
108461: {
119672:   nsCOMPtr<nsViewManager> vm = mViewManager;
119672:   vm->WillPaintWindow(aWidget, aWillSendDidPaint);
108461: }
108461: 
108461: bool
118895: nsView::PaintWindow(nsIWidget* aWidget, nsIntRegion aRegion, uint32_t aFlags)
108461: {
125705:   NS_ASSERTION(this == nsView::GetViewFor(aWidget), "wrong view for widget?");
125705: 
118896:   mInAlternatePaint = aFlags & PAINT_IS_ALTERNATE;
108461:   nsCOMPtr<nsViewManager> vm = mViewManager;
118896:   bool result = vm->PaintWindow(aWidget, aRegion, aFlags);
125705:   // PaintWindow can destroy this via WillPaintWindow notification, so we have
125705:   // to re-get the view from the widget.
125705:   nsView* view = nsView::GetViewFor(aWidget);
125705:   if (view) {
125705:     view->mInAlternatePaint = false;
125705:   }
118896:   return result;
108461: }
108461: 
108461: void
108461: nsView::DidPaintWindow()
108461: {
119672:   nsCOMPtr<nsViewManager> vm = mViewManager;
119672:   vm->DidPaintWindow();
108461: }
108461: 
108461: nsEventStatus
108461: nsView::HandleEvent(nsGUIEvent* aEvent, bool aUseAttachedEvents)
108461: {
108461:   NS_PRECONDITION(nullptr != aEvent->widget, "null widget ptr");
108461: 
108461:   nsEventStatus result = nsEventStatus_eIgnore;
108461:   nsIView* view;
108461:   if (aUseAttachedEvents) {
108461:     nsIWidgetListener* listener = aEvent->widget->GetAttachedWidgetListener();
108461:     view = listener ? listener->GetView() : nullptr;
108461:   }
108461:   else {
108461:     view = GetViewFor(aEvent->widget);
108461:   }
108461: 
108461:   if (view) {
108461:     nsCOMPtr<nsIViewManager> vm = view->GetViewManager();
108461:     vm->DispatchEvent(aEvent, view, &result);
108461:   }
108461: 
108461:   return result;
108461: }
