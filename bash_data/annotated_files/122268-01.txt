 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43113: 
 43113: #ifndef nsAHttpConnection_h__
 43113: #define nsAHttpConnection_h__
 43113: 
 43113: #include "nsISupports.h"
 93843: #include "nsAHttpTransaction.h"
 43113: 
 43113: class nsHttpRequestHead;
 43113: class nsHttpResponseHead;
 43113: class nsHttpConnectionInfo;
 67712: class nsHttpConnection;
 70090: class nsISocketTransport;
 70090: class nsIAsyncInputStream;
 70090: class nsIAsyncOutputStream;
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // Abstract base class for a HTTP connection
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: class nsAHttpConnection : public nsISupports
 43113: {
 43113: public:
 43113:     //-------------------------------------------------------------------------
 43113:     // NOTE: these methods may only be called on the socket thread.
 43113:     //-------------------------------------------------------------------------
 43113: 
 43113:     //
 43113:     // called by a transaction when the response headers have all been read.
 43113:     // the connection can force the transaction to reset it's response headers,
 43113:     // and prepare for a new set of response headers, by setting |*reset=TRUE|.
 43113:     //
 43113:     // @return failure code to close the transaction.
 43113:     //
 43113:     virtual nsresult OnHeadersAvailable(nsAHttpTransaction *,
 43113:                                         nsHttpRequestHead *,
 43113:                                         nsHttpResponseHead *,
 79445:                                         bool *reset) = 0;
 43113: 
 43113:     //
 43113:     // called by a transaction to resume either sending or receiving data
 43113:     // after a transaction returned NS_BASE_STREAM_WOULD_BLOCK from its
 43113:     // ReadSegments/WriteSegments methods.
 43113:     //
 88247:     virtual nsresult ResumeSend() = 0;
 88247:     virtual nsresult ResumeRecv() = 0;
 43113: 
 88247:     // After a connection has had ResumeSend() called by a transaction,
 88247:     // and it is ready to write to the network it may need to know the
 88247:     // transaction that has data to write. This is only an issue for
 88247:     // multiplexed protocols like SPDY - plain HTTP or pipelined HTTP
 88247:     // implicitly have this information in a 1:1 relationship with the
 88247:     // transaction(s) they manage.
 88247:     virtual void TransactionHasDataToWrite(nsAHttpTransaction *)
 88247:     {
 88247:         // by default do nothing - only multiplexed protocols need to overload
 88247:         return;
 88247:     }
 43113:     //
 43113:     // called by the connection manager to close a transaction being processed
 43113:     // by this connection.
 43113:     //
 43113:     // @param transaction
 43113:     //        the transaction being closed.
 43113:     // @param reason
 43113:     //        the reason for closing the transaction.  NS_BASE_STREAM_CLOSED
 43113:     //        is equivalent to NS_OK.
 43113:     //
 43113:     virtual void CloseTransaction(nsAHttpTransaction *transaction,
 43113:                                   nsresult reason) = 0;
 43113: 
 43113:     // get a reference to the connection's connection info object.
 43113:     virtual void GetConnectionInfo(nsHttpConnectionInfo **) = 0;
 43113: 
 70090:     // get the transport level information for this connection. This may fail
 70090:     // if it is in use.
 70090:     virtual nsresult TakeTransport(nsISocketTransport **,
 70090:                                    nsIAsyncInputStream **,
 70090:                                    nsIAsyncOutputStream **) = 0;
 70090: 
 43113:     // called by a transaction to get the security info from the socket.
 43113:     virtual void GetSecurityInfo(nsISupports **) = 0;
 43113: 
 43113:     // called by a transaction to determine whether or not the connection is
 43113:     // persistent... important in determining the end of a response.
 79445:     virtual bool IsPersistent() = 0;
 43113: 
 93843:     // called to determine or set if a connection has been reused.
 79445:     virtual bool IsReused() = 0;
 93843:     virtual void DontReuse() = 0;
 43113: 
 43113:     // called by a transaction when the transaction reads more from the socket
 43113:     // than it should have (eg. containing part of the next pipelined response).
108991:     virtual nsresult PushBack(const char *data, uint32_t length) = 0;
 61543: 
 93838:     // Used to determine if the connection wants read events even though
 93838:     // it has not written out a transaction. Used when a connection has issued
 93838:     // a preamble such as a proxy ssl CONNECT sequence.
 93838:     virtual bool IsProxyConnectInProgress() = 0;
 93838: 
 61543:     // Used by a transaction to manage the state of previous response bodies on
 61543:     // the same connection and work around buggy servers.
 79445:     virtual bool LastTransactionExpectedNoContent() = 0;
 79445:     virtual void   SetLastTransactionExpectedNoContent(bool) = 0;
 67712: 
 67712:     // Transfer the base http connection object along with a
 67712:     // reference to it to the caller.
 67712:     virtual nsHttpConnection *TakeHttpConnection() = 0;
 83069: 
 83069:     // Get the nsISocketTransport used by the connection without changing
 83069:     //  references or ownership.
 83069:     virtual nsISocketTransport *Transport() = 0;
 93843: 
 93843:     // Cancel and reschedule transactions deeper than the current response.
 93843:     // Returns the number of canceled transactions.
108991:     virtual uint32_t CancelPipeline(nsresult originalReason) = 0;
 93843: 
 93843:     // Read and write class of transaction that is carried on this connection
 93843:     virtual nsAHttpTransaction::Classifier Classification() = 0;
 93843:     virtual void Classify(nsAHttpTransaction::Classifier newclass) = 0;
 98400: 
 98400:     // The number of transaction bytes written out on this HTTP Connection, does
 98400:     // not count CONNECT tunnel setup
108991:     virtual int64_t BytesWritten() = 0;
121882: 
121882:     // Update the callbacks used to provide security info. May be called on
121882:     // any thread.
121883:     virtual void SetSecurityCallbacks(nsIInterfaceRequestor* aCallbacks) = 0;
 43113: };
 43113: 
 98400: #define NS_DECL_NSAHTTPCONNECTION(fwdObject)                    \
 79445:     nsresult OnHeadersAvailable(nsAHttpTransaction *, nsHttpRequestHead *, nsHttpResponseHead *, bool *reset); \
 43113:     void CloseTransaction(nsAHttpTransaction *, nsresult); \
 70090:     nsresult TakeTransport(nsISocketTransport **,    \
 70090:                            nsIAsyncInputStream **,   \
 70090:                            nsIAsyncOutputStream **); \
 79445:     bool IsPersistent(); \
 79445:     bool IsReused(); \
 93843:     void DontReuse();  \
108991:     nsresult PushBack(const char *, uint32_t); \
 83069:     nsHttpConnection *TakeHttpConnection(); \
108991:     uint32_t CancelPipeline(nsresult originalReason);   \
 93843:     nsAHttpTransaction::Classifier Classification();      \
 99502:     /*                                                    \
 99502:        Thes methods below have automatic definitions that just forward the \
 99502:        function to a lower level connection object        \
 99502:     */                                                    \
 99502:     void GetConnectionInfo(nsHttpConnectionInfo **result) \
 99502:     {                                                     \
 99502:       if (!(fwdObject)) {                                 \
106838:           *result = nullptr;                               \
 99502:           return;                                         \
 99502:       }                                                   \
 99502:         return (fwdObject)->GetConnectionInfo(result);    \
 99502:     }                                                     \
 99502:     void GetSecurityInfo(nsISupports **result)            \
 99502:     {                                                     \
 99502:       if (!(fwdObject)) {                                 \
106838:           *result = nullptr;                               \
 99502:           return;                                         \
 99502:       }                                                   \
 99502:       return (fwdObject)->GetSecurityInfo(result);        \
 99502:     }                                                     \
 99502:     nsresult ResumeSend()                  \
 99502:     {                                      \
 99502:         if (!(fwdObject))                  \
 99502:             return NS_ERROR_FAILURE;       \
 99502:         return (fwdObject)->ResumeSend();  \
 99502:     }                                      \
 99502:     nsresult ResumeRecv()                  \
 99502:     {                                      \
 99502:         if (!(fwdObject))                  \
 99502:             return NS_ERROR_FAILURE;       \
 99502:         return (fwdObject)->ResumeRecv();  \
 99502:     }                                      \
 99502:     nsISocketTransport *Transport()        \
 99502:     {                                      \
 99502:         if (!(fwdObject))                  \
106838:             return nullptr;                 \
 99502:         return (fwdObject)->Transport();   \
 99502:     }                                      \
 99502:     bool IsProxyConnectInProgress()                         \
 99502:     {                                                       \
 99502:         return (fwdObject)->IsProxyConnectInProgress();     \
 99502:     }                                                       \
 99502:     bool LastTransactionExpectedNoContent()                 \
 99502:     {                                                       \
 99502:         return (fwdObject)->LastTransactionExpectedNoContent(); \
 99502:     }                                                       \
 99502:     void SetLastTransactionExpectedNoContent(bool val)      \
 99502:     {                                                       \
 99502:         return (fwdObject)->SetLastTransactionExpectedNoContent(val); \
 99502:     }                                                       \
 99502:     void Classify(nsAHttpTransaction::Classifier newclass)  \
 99502:     {                                                       \
 99502:     if (fwdObject)                                          \
 99502:         return (fwdObject)->Classify(newclass);             \
 99502:     }                                                       \
108991:     int64_t BytesWritten()                                  \
121882:     {     return fwdObject ? (fwdObject)->BytesWritten() : 0; } \
121883:     void SetSecurityCallbacks(nsIInterfaceRequestor* aCallbacks) \
121882:     {                                                       \
122268:         if (fwdObject)                                      \
121883:             (fwdObject)->SetSecurityCallbacks(aCallbacks);  \
121882:     }
 43113: 
 43113: #endif // nsAHttpConnection_h__
