 33620: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 33620: 
 34695: #include "nsDOMFileReader.h"
 33620: 
 33620: #include "nsContentCID.h"
 33620: #include "nsContentUtils.h"
 80058: #include "nsDOMClassInfoID.h"
 33620: #include "nsDOMFile.h"
108290: #include "nsError.h"
 33620: #include "nsIConverterInputStream.h"
136240: #include "nsIDocument.h"
 33620: #include "nsIFile.h"
 33620: #include "nsIFileStreams.h"
 33620: #include "nsIInputStream.h"
 33620: #include "nsIMIMEService.h"
 33620: #include "nsIUnicodeDecoder.h"
 33620: #include "nsNetCID.h"
 33620: #include "nsNetUtil.h"
 33620: 
 33620: #include "nsLayoutCID.h"
 33620: #include "nsXPIDLString.h"
 33620: #include "nsReadableUtils.h"
 33620: #include "nsIURI.h"
 33620: #include "nsStreamUtils.h"
 33620: #include "nsXPCOM.h"
 33620: #include "nsIDOMEventListener.h"
 33620: #include "nsJSEnvironment.h"
 33620: #include "nsIScriptGlobalObject.h"
 33620: #include "nsCExternalHandlerService.h"
 33620: #include "nsIStreamConverterService.h"
 33620: #include "nsCycleCollectionParticipant.h"
 33620: #include "nsIScriptObjectPrincipal.h"
121327: #include "nsHostObjectProtocolHandler.h"
125496: #include "mozilla/Base64.h"
 70976: #include "mozilla/Preferences.h"
121274: #include "mozilla/dom/EncodingUtils.h"
140461: #include "mozilla/dom/FileReaderBinding.h"
 79460: #include "xpcpublic.h"
 86103: #include "nsIScriptSecurityManager.h"
 86103: #include "nsDOMJSUtils.h"
 89667: #include "nsDOMEventTargetHelper.h"
 86103: 
 95834: #include "jsfriendapi.h"
 70976: 
 70976: using namespace mozilla;
140461: using namespace mozilla::dom;
 33620: 
 33620: #define LOAD_STR "load"
 33620: #define LOADSTART_STR "loadstart"
 33620: #define LOADEND_STR "loadend"
 33620: 
154217: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMFileReader)
154217: 
 34695: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMFileReader,
 79451:                                                   FileIOObject)
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mFile)
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPrincipal)
 33620: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 33620: 
 34695: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMFileReader,
 79451:                                                 FileIOObject)
106838:   tmp->mResultArrayBuffer = nullptr;
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mFile)
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mPrincipal)
 33620: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 33620: 
 72881: 
 72881: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED(nsDOMFileReader,
 89667:                                                nsDOMEventTargetHelper)
101616:   NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mResultArrayBuffer)
 72881: NS_IMPL_CYCLE_COLLECTION_TRACE_END
 72881: 
 34695: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMFileReader)
140461:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
 34695:   NS_INTERFACE_MAP_ENTRY(nsIDOMFileReader)
 33620:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
 33620:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 79451: NS_INTERFACE_MAP_END_INHERITING(FileIOObject)
 33620: 
 79451: NS_IMPL_ADDREF_INHERITED(nsDOMFileReader, FileIOObject)
 79451: NS_IMPL_RELEASE_INHERITED(nsDOMFileReader, FileIOObject)
 33620: 
110823: NS_IMPL_EVENT_HANDLER(nsDOMFileReader, load)
110823: NS_IMPL_EVENT_HANDLER(nsDOMFileReader, loadend)
110823: NS_IMPL_EVENT_HANDLER(nsDOMFileReader, loadstart)
110823: NS_IMPL_FORWARD_EVENT_HANDLER(nsDOMFileReader, abort, FileIOObject)
110823: NS_IMPL_FORWARD_EVENT_HANDLER(nsDOMFileReader, progress, FileIOObject)
110823: NS_IMPL_FORWARD_EVENT_HANDLER(nsDOMFileReader, error, FileIOObject)
110823: 
 72881: void
 72881: nsDOMFileReader::RootResultArrayBuffer()
 72881: {
159229:   mozilla::HoldJSObjects(this);
 72881: }
 72881: 
 34695: //nsDOMFileReader constructors/initializers
 33620: 
 34695: nsDOMFileReader::nsDOMFileReader()
106838:   : mFileData(nullptr),
 35227:     mDataLen(0), mDataFormat(FILE_AS_BINARY),
106838:     mResultArrayBuffer(nullptr)
 33620: {
 72881:   SetDOMStringToNull(mResult);
140461:   SetIsDOMBinding();
 33620: }
 33620: 
 34695: nsDOMFileReader::~nsDOMFileReader()
 33620: {
 35198:   FreeFileData();
144328:   mResultArrayBuffer = nullptr;
159229:   mozilla::DropJSObjects(this);
 33620: }
 33620: 
141277: 
141277: /**
141277:  * This Init method is called from the factory constructor.
141277:  */
 33620: nsresult
 34695: nsDOMFileReader::Init()
 33620: {
141277:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
141277:   nsCOMPtr<nsIPrincipal> principal;
141277:   if (secMan) {
141277:     secMan->GetSystemPrincipal(getter_AddRefs(principal));
141277:   }
141277:   NS_ENSURE_STATE(principal);
141277:   mPrincipal.swap(principal);
 33620: 
141277:   // Instead of grabbing some random global from the context stack,
151836:   // let's use the default one (junk scope) for now.
141277:   // We should move away from this Init...
151836:   nsCOMPtr<nsIGlobalObject> global = xpc::GetJunkScopeGlobal();
151836:   NS_ENSURE_TRUE(global, NS_ERROR_FAILURE);
151836:   BindToOwner(global);
 33620:   return NS_OK;
 33620: }
 33620: 
140461: /* static */ already_AddRefed<nsDOMFileReader>
140461: nsDOMFileReader::Constructor(const GlobalObject& aGlobal, ErrorResult& aRv)
 33620: {
140461:   nsRefPtr<nsDOMFileReader> fileReader = new nsDOMFileReader();
140461: 
157843:   nsCOMPtr<nsPIDOMWindow> owner = do_QueryInterface(aGlobal.GetAsSupports());
 92083:   if (!owner) {
 33620:     NS_WARNING("Unexpected nsIJSNativeInitializer owner");
140461:     aRv.Throw(NS_ERROR_FAILURE);
140461:     return nullptr;
 33620:   }
 33620: 
140461:   fileReader->BindToOwner(owner);
 92083: 
 33620:   // This object is bound to a |window|,
 92083:   // so reset the principal.
140461:   nsCOMPtr<nsIScriptObjectPrincipal> scriptPrincipal = do_QueryInterface(owner);
140461:   if (!scriptPrincipal) {
140461:     aRv.Throw(NS_ERROR_FAILURE);
140461:     return nullptr;
140461:   }
140461:   fileReader->mPrincipal = scriptPrincipal->GetPrincipal();
140461:   return fileReader.forget();
 33620: }
 33620: 
 33620: // nsIInterfaceRequestor
 33620: 
 33620: NS_IMETHODIMP
 34695: nsDOMFileReader::GetInterface(const nsIID & aIID, void **aResult)
 33620: {
 33620:   return QueryInterface(aIID, aResult);
 33620: }
 33620: 
 34695: // nsIDOMFileReader
 33620: 
 33620: NS_IMETHODIMP
108991: nsDOMFileReader::GetReadyState(uint16_t *aReadyState)
 33620: {
140461:   *aReadyState = ReadyState();
140461:   return NS_OK;
140461: }
140461: 
140461: JS::Value
140461: nsDOMFileReader::GetResult(JSContext* aCx, ErrorResult& aRv)
140461: {
167114:   JS::Rooted<JS::Value> result(aCx);
180765:   aRv = GetResult(aCx, &result);
140461:   return result;
 33620: }
 33620: 
 33620: NS_IMETHODIMP
180765: nsDOMFileReader::GetResult(JSContext* aCx, JS::MutableHandle<JS::Value> aResult)
 33620: {
167114:   JS::Rooted<JS::Value> result(aCx);
 72881:   if (mDataFormat == FILE_AS_ARRAYBUFFER) {
 72881:     if (mReadyState == nsIDOMFileReader::DONE && mResultArrayBuffer) {
167114:       result.setObject(*mResultArrayBuffer);
 72881:     } else {
167114:       result.setNull();
 72881:     }
167114:     if (!JS_WrapValue(aCx, &result)) {
 93968:       return NS_ERROR_FAILURE;
 93968:     }
180765:     aResult.set(result);
 72881:     return NS_OK;
 72881:   }
 72881: 
 72881:   nsString tmpResult = mResult;
180765:   if (!xpc::StringToJsval(aCx, tmpResult, aResult)) {
 72881:     return NS_ERROR_FAILURE;
 72881:   }
 33620:   return NS_OK;
 33620: }
 33620: 
 33620: NS_IMETHODIMP
144685: nsDOMFileReader::GetError(nsISupports** aError)
 33620: {
140461:   NS_IF_ADDREF(*aError = GetError());
140461:   return NS_OK;
 33620: }
 33620: 
 33620: NS_IMETHODIMP
 72881: nsDOMFileReader::ReadAsArrayBuffer(nsIDOMBlob* aFile, JSContext* aCx)
 72881: {
140461:   NS_ENSURE_TRUE(aFile, NS_ERROR_NULL_POINTER);
140461:   ErrorResult rv;
140461:   ReadAsArrayBuffer(aCx, aFile, rv);
140461:   return rv.ErrorCode();
 72881: }
 72881: 
 72881: NS_IMETHODIMP
 55459: nsDOMFileReader::ReadAsBinaryString(nsIDOMBlob* aFile)
 33620: {
140461:   NS_ENSURE_TRUE(aFile, NS_ERROR_NULL_POINTER);
140461:   ErrorResult rv;
140461:   ReadAsBinaryString(aFile, rv);
140461:   return rv.ErrorCode();
 33620: }
 33620: 
 33620: NS_IMETHODIMP
 55459: nsDOMFileReader::ReadAsText(nsIDOMBlob* aFile,
 33620:                             const nsAString &aCharset)
 33620: {
140461:   NS_ENSURE_TRUE(aFile, NS_ERROR_NULL_POINTER);
140461:   ErrorResult rv;
140461:   ReadAsText(aFile, aCharset, rv);
140461:   return rv.ErrorCode();
 33620: }
 33620: 
 33620: NS_IMETHODIMP
 55459: nsDOMFileReader::ReadAsDataURL(nsIDOMBlob* aFile)
 33620: {
140461:   NS_ENSURE_TRUE(aFile, NS_ERROR_NULL_POINTER);
140461:   ErrorResult rv;
140461:   ReadAsDataURL(aFile, rv);
140461:   return rv.ErrorCode();
 33620: }
 33620: 
 33620: NS_IMETHODIMP
 34695: nsDOMFileReader::Abort()
 33620: {
140461:   ErrorResult rv;
140461:   FileIOObject::Abort(rv);
140461:   return rv.ErrorCode();
 33620: }
 33620: 
140461: /* virtual */ void
 79451: nsDOMFileReader::DoAbort(nsAString& aEvent)
 79451: {
 79451:   // Revert status and result attributes
 34695:   SetDOMStringToNull(mResult);
106838:   mResultArrayBuffer = nullptr;
 33620:     
 33620:   // Non-null channel indicates a read is currently active
 33620:   if (mChannel) {
 33620:     // Cancel request requires an error status
 33620:     mChannel->Cancel(NS_ERROR_FAILURE);
106838:     mChannel = nullptr;
 33620:   }
106838:   mFile = nullptr;
 33620: 
 33620:   //Clean up memory buffer
 35198:   FreeFileData();
 33620: 
 79451:   // Tell the base class which event to dispatch
 79451:   aEvent = NS_LITERAL_STRING(LOADEND_STR);
 33620: }
 33620: 
 35194: static
 35194: NS_METHOD
 35194: ReadFuncBinaryString(nsIInputStream* in,
 35194:                      void* closure,
 35194:                      const char* fromRawSegment,
108991:                      uint32_t toOffset,
108991:                      uint32_t count,
108991:                      uint32_t *writeCount)
 35194: {
179103:   char16_t* dest = static_cast<char16_t*>(closure) + toOffset;
179103:   char16_t* end = dest + count;
 35194:   const unsigned char* source = (const unsigned char*)fromRawSegment;
 35194:   while (dest != end) {
 35194:     *dest = *source;
 35194:     ++dest;
 35194:     ++source;
 35194:   }
 35194:   *writeCount = count;
 35194: 
 35194:   return NS_OK;
 35194: }
 35194: 
 79451: nsresult
 79451: nsDOMFileReader::DoOnDataAvailable(nsIRequest *aRequest,
 33620:                                    nsISupports *aContext,
 33620:                                    nsIInputStream *aInputStream,
111234:                                    uint64_t aOffset,
108991:                                    uint32_t aCount)
 33620: {
 35194:   if (mDataFormat == FILE_AS_BINARY) {
 35194:     //Continuously update our binary string as data comes in
 35194:     NS_ASSERTION(mResult.Length() == aOffset,
 35194:                  "unexpected mResult length");
108991:     uint32_t oldLen = mResult.Length();
115367:     if (uint64_t(oldLen) + aCount > UINT32_MAX)
111234:       return NS_ERROR_OUT_OF_MEMORY;
111234: 
179103:     char16_t *buf = nullptr;
 98906:     mResult.GetMutableData(&buf, oldLen + aCount, fallible_t());
 35194:     NS_ENSURE_TRUE(buf, NS_ERROR_OUT_OF_MEMORY);
 35194: 
108991:     uint32_t bytesRead = 0;
 35194:     aInputStream->ReadSegments(ReadFuncBinaryString, buf + oldLen, aCount,
 35194:                                &bytesRead);
 35194:     NS_ASSERTION(bytesRead == aCount, "failed to read data");
 35194:   }
 72881:   else if (mDataFormat == FILE_AS_ARRAYBUFFER) {
108991:     uint32_t bytesRead = 0;
121899:     aInputStream->Read((char*)JS_GetArrayBufferData(mResultArrayBuffer) + aOffset,
 95834:                        aCount, &bytesRead);
 72881:     NS_ASSERTION(bytesRead == aCount, "failed to read data");
 72881:   }
 35194:   else {
 33620:     //Update memory buffer to reflect the contents of the file
115367:     if (aOffset + aCount > UINT32_MAX) {
111234:       // PR_Realloc doesn't support over 4GB memory size even if 64-bit OS
111234:       return NS_ERROR_OUT_OF_MEMORY;
111234:     }
125496:     mFileData = (char *)moz_realloc(mFileData, aOffset + aCount);
 33620:     NS_ENSURE_TRUE(mFileData, NS_ERROR_OUT_OF_MEMORY);
 33620: 
108991:     uint32_t bytesRead = 0;
 35194:     aInputStream->Read(mFileData + aOffset, aCount, &bytesRead);
 35194:     NS_ASSERTION(bytesRead == aCount, "failed to read data");
 35194: 
 33620:     mDataLen += aCount;
 35187:   }
 35187: 
 33620:   return NS_OK;
 33620: }
 33620: 
 79451: nsresult
 79451: nsDOMFileReader::DoOnStopRequest(nsIRequest *aRequest,
 33620:                                  nsISupports *aContext,
 79451:                                  nsresult aStatus,
 79451:                                  nsAString& aSuccessEvent,
 79451:                                  nsAString& aTerminationEvent)
 33620: {
110532:   // Make sure we drop all the objects that could hold files open now.
110532:   nsCOMPtr<nsIChannel> channel;
110532:   mChannel.swap(channel);
110532: 
110532:   nsCOMPtr<nsIDOMBlob> file;
110532:   mFile.swap(file);
110532: 
 79451:   aSuccessEvent = NS_LITERAL_STRING(LOAD_STR);
 79451:   aTerminationEvent = NS_LITERAL_STRING(LOADEND_STR);
 33620: 
 79451:   // Clear out the data if necessary
 33620:   if (NS_FAILED(aStatus)) {
 35198:     FreeFileData();
 33620:     return NS_OK;
 33620:   }
 33620: 
 35227:   nsresult rv = NS_OK;
 33620:   switch (mDataFormat) {
 72881:     case FILE_AS_ARRAYBUFFER:
 72881:       break; //Already accumulated mResultArrayBuffer
 33620:     case FILE_AS_BINARY:
 34695:       break; //Already accumulated mResult
 33620:     case FILE_AS_TEXT:
177810:       if (!mFileData) {
177810:         if (mDataLen) {
177810:           rv = NS_ERROR_OUT_OF_MEMORY;
177810:           break;
177810:         }
177810:         rv = GetAsText(file, mCharset, "", mDataLen, mResult);
177810:         break;
177810:       }
177810:       rv = GetAsText(file, mCharset, mFileData, mDataLen, mResult);
 33620:       break;
 33620:     case FILE_AS_DATAURL:
110532:       rv = GetAsDataURL(file, mFileData, mDataLen, mResult);
 33620:       break;
 33620:   }
 33620:   
 80486:   mResult.SetIsVoid(false);
 55115: 
 35198:   FreeFileData();
 35198: 
 79451:   return rv;
 33620: }
 33620: 
 33620: // Helper methods
 33620: 
140461: void
 72881: nsDOMFileReader::ReadFileContent(JSContext* aCx,
 72881:                                  nsIDOMBlob* aFile,
 33620:                                  const nsAString &aCharset,
140461:                                  eDataFormat aDataFormat,
140461:                                  ErrorResult& aRv)
 33620: {
140461:   MOZ_ASSERT(aFile);
 33620: 
 33620:   //Implicit abort to clear any other activity going on
 33620:   Abort();
106838:   mError = nullptr;
 35195:   SetDOMStringToNull(mResult);
 79451:   mTransferred = 0;
 79451:   mTotal = 0;
 35198:   mReadyState = nsIDOMFileReader::EMPTY;
 35198:   FreeFileData();
 35198: 
 52042:   mFile = aFile;
 35198:   mDataFormat = aDataFormat;
 55115:   CopyUTF16toUTF8(aCharset, mCharset);
 33620: 
 52042:   //Establish a channel with our file
 52042:   {
 52042:     // Hold the internal URL alive only as long as necessary
 52042:     // After the channel is created it will own whatever is backing
 52042:     // the DOMFile.
 54295:     nsDOMFileInternalUrlHolder urlHolder(mFile, mPrincipal);
 33620: 
 33620:     nsCOMPtr<nsIURI> uri;
140461:     aRv = NS_NewURI(getter_AddRefs(uri), urlHolder.mUrl);
140461:     NS_ENSURE_SUCCESS_VOID(aRv.ErrorCode());
 33620: 
114244:     nsCOMPtr<nsILoadGroup> loadGroup;
114244:     if (HasOrHasHadOwner()) {
140461:       if (!GetOwner()) {
140461:         aRv.Throw(NS_ERROR_FAILURE);
140461:         return;
140461:       }
114244:       nsIDocument* doc = GetOwner()->GetExtantDoc();
114244:       if (doc) {
114244:         loadGroup = doc->GetDocumentLoadGroup();
114244:       }
114244:     }
114244: 
140461:     aRv = NS_NewChannel(getter_AddRefs(mChannel), uri, nullptr, loadGroup,
114244:                         nullptr, nsIRequest::LOAD_BACKGROUND);
140461:     NS_ENSURE_SUCCESS_VOID(aRv.ErrorCode());
 52042:   }
 33620: 
 33620:   //Obtain the total size of the file before reading
 79451:   mTotal = mozilla::dom::kUnknownSize;
 79451:   mFile->GetSize(&mTotal);
 33620: 
140461:   aRv = mChannel->AsyncOpen(this, nullptr);
140461:   NS_ENSURE_SUCCESS_VOID(aRv.ErrorCode());
 33620: 
 34695:   //FileReader should be in loading state here
 34695:   mReadyState = nsIDOMFileReader::LOADING;
 33620:   DispatchProgressEvent(NS_LITERAL_STRING(LOADSTART_STR));
 33620: 
 72881:   if (mDataFormat == FILE_AS_ARRAYBUFFER) {
 72881:     RootResultArrayBuffer();
 95834:     mResultArrayBuffer = JS_NewArrayBuffer(aCx, mTotal);
 72881:     if (!mResultArrayBuffer) {
 72881:       NS_WARNING("Failed to create JS array buffer");
140461:       aRv.Throw(NS_ERROR_FAILURE);
 72881:     }
 72881:   }
 33620: }
 33620: 
 33620: nsresult
177810: nsDOMFileReader::GetAsText(nsIDOMBlob *aFile,
177810:                            const nsACString &aCharset,
 33620:                            const char *aFileData,
108991:                            uint32_t aDataLen,
 33620:                            nsAString& aResult)
 33620: {
177810:   // The BOM sniffing is baked into the "decode" part of the Encoding
177810:   // Standard, which the File API references.
177810:   nsAutoCString encoding;
177810:   if (!nsContentUtils::CheckForBOM(
177810:         reinterpret_cast<const unsigned char *>(aFileData),
177810:         aDataLen,
177810:         encoding)) {
177810:     // BOM sniffing failed. Try the API argument.
177810:     if (!EncodingUtils::FindEncodingForLabel(aCharset,
177810:                                              encoding)) {
177810:       // API argument failed. Try the type property of the blob.
177810:       nsAutoString type16;
177810:       aFile->GetType(type16);
177810:       NS_ConvertUTF16toUTF8 type(type16);
177810:       nsAutoCString specifiedCharset;
177810:       bool haveCharset;
177810:       int32_t charsetStart, charsetEnd;
177810:       NS_ExtractCharsetFromContentType(type,
177810:                                        specifiedCharset,
177810:                                        &haveCharset,
177810:                                        &charsetStart,
177810:                                        &charsetEnd);
177810:       if (!EncodingUtils::FindEncodingForLabel(specifiedCharset, encoding)) {
177810:         // Type property failed. Use UTF-8.
177810:         encoding.AssignLiteral("UTF-8");
177810:       }
177810:     }
 33620:   }
 33620: 
177810:   nsDependentCSubstring data(aFileData, aDataLen);
177810:   return nsContentUtils::ConvertStringFromEncoding(encoding, data, aResult);
 33620: }
 33620: 
 33620: nsresult
 55459: nsDOMFileReader::GetAsDataURL(nsIDOMBlob *aFile,
 33620:                               const char *aFileData,
108991:                               uint32_t aDataLen,
 33620:                               nsAString& aResult)
 33620: {
 33620:   aResult.AssignLiteral("data:");
 33620: 
 33620:   nsresult rv;
 52042:   nsString contentType;
 52042:   rv = aFile->GetType(contentType);
 52042:   if (NS_SUCCEEDED(rv) && !contentType.IsEmpty()) {
 52042:     aResult.Append(contentType);
 33620:   } else {
 33620:     aResult.AppendLiteral("application/octet-stream");
 33620:   }
 33620:   aResult.AppendLiteral(";base64,");
 33620: 
125496:   nsCString encodedData;
125496:   rv = Base64Encode(Substring(aFileData, aDataLen), encodedData);
125496:   NS_ENSURE_SUCCESS(rv, rv);
 33620: 
186279:   if (!AppendASCIItoUTF16(encodedData, aResult, fallible_t())) {
186279:     return NS_ERROR_OUT_OF_MEMORY;
186279:   }
 33620: 
 33620:   return NS_OK;
 33620: }
 33620: 
140461: /* virtual */ JSObject*
141672: nsDOMFileReader::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aScope)
140461: {
140461:   return FileReaderBinding::Wrap(aCx, aScope, this);
140461: }
