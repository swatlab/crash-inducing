 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 86269: /* JS execution context. */
 86269: 
     1: #ifndef jscntxt_h___
     1: #define jscntxt_h___
 86269: 
 86269: #include "mozilla/Attributes.h"
 86269: 
 38604: #include <string.h>
 38604: 
 86988: #include "jsapi.h"
 80213: #include "jsfriendapi.h"
 48594: #include "jsprvtd.h"
 79734: #include "jsatom.h"
     1: #include "jsclist.h"
     1: #include "jsgc.h"
 40359: #include "jspropertycache.h"
 40327: #include "jspropertytree.h"
     1: #include "jsutil.h"
 43191: #include "prmjtime.h"
     1: 
 79410: #include "ds/LifoAlloc.h"
 80212: #include "gc/Statistics.h"
 80202: #include "js/HashTable.h"
 80202: #include "js/Vector.h"
 87949: #include "vm/Stack.h"
 69223: 
 39928: #ifdef _MSC_VER
 39928: #pragma warning(push)
 39928: #pragma warning(disable:4100) /* Silence unreferenced formal parameter warnings */
 39928: #pragma warning(push)
 39928: #pragma warning(disable:4355) /* Silence warning about "this" used in base member initializer list */
 39928: #endif
 39928: 
 72075: JS_BEGIN_EXTERN_C
 72075: struct DtoaState;
 72075: JS_END_EXTERN_C
 72075: 
 90320: struct JSSharpInfo {
 90320:     bool hasGen;
 90320:     bool isSharp;
 90320: 
 90320:     JSSharpInfo() : hasGen(false), isSharp(false) {}
 90320: };
 90320: 
 90320: typedef js::HashMap<JSObject *, JSSharpInfo> JSSharpTable;
 90320: 
 79734: struct JSSharpObjectMap {
 91392:     unsigned     depth;
 84755:     uint32_t     sharpgen;
 90320:     JSSharpTable table;
 89633: 
 90320:     JSSharpObjectMap(JSContext *cx) : depth(0), sharpgen(0), table(js::TempAllocPolicy(cx)) {
 90320:         table.init();
 90320:     }
 79734: };
 79734: 
 37741: namespace js {
 34572: 
 53382: namespace mjit {
 97464: class JaegerRuntime;
 53382: }
 53382: 
 97464: class MathCache;
 72067: class WeakMapBase;
 82645: class InterpreterFrames;
 98921: class DebugScopes;
 72067: 
 38568: /*
 67915:  * GetSrcNote cache to avoid O(n^2) growth in finding a source note for a
 67915:  * given pc in a script. We use the script->code pointer to tag the cache,
 67915:  * instead of the script address itself, so that source notes are always found
 67915:  * by offset from the bytecode with which they were generated.
 67915:  */
 67915: struct GSNCache {
 67915:     typedef HashMap<jsbytecode *,
 67915:                     jssrcnote *,
 67915:                     PointerHasher<jsbytecode *, 0>,
 67915:                     SystemAllocPolicy> Map;
 67915: 
 67915:     jsbytecode      *code;
 67915:     Map             map;
 24375: 
 67915:     GSNCache() : code(NULL) { }
 67915: 
 67915:     void purge();
 67915: };
 67915: 
 67915: inline GSNCache *
 67915: GetGSNCache(JSContext *cx);
 67915: 
 67915: struct PendingProxyOperation {
 67915:     PendingProxyOperation   *next;
 99421:     RootedObject            object;
 97353:     PendingProxyOperation(JSContext *cx, JSObject *object) : next(NULL), object(cx, object) {}
 43279: };
 43279: 
 94574: typedef Vector<ScriptAndCounts, 0, SystemAllocPolicy> ScriptAndCountsVector;
 82323: 
 88135: struct ConservativeGCData
 88135: {
 88135:     /*
 88135:      * The GC scans conservatively between ThreadData::nativeStackBase and
 88135:      * nativeStackTop unless the latter is NULL.
 88135:      */
 88135:     uintptr_t           *nativeStackTop;
 67915: 
 97353: #if defined(JSGC_ROOT_ANALYSIS) && (JS_STACK_GROWTH_DIRECTION < 0)
 97353:     /*
 97353:      * Record old contents of the native stack from the last time there was a
 97353:      * scan, to reduce the overhead involved in repeatedly rescanning the
 97353:      * native stack during root analysis. oldStackData stores words in reverse
 97353:      * order starting at oldStackEnd.
 97353:      */
 97353:     uintptr_t           *oldStackMin, *oldStackEnd;
 97353:     uintptr_t           *oldStackData;
 97353:     size_t              oldStackCapacity; // in sizeof(uintptr_t)
 97353: #endif
 97353: 
 88135:     union {
 88135:         jmp_buf         jmpbuf;
 88135:         uintptr_t       words[JS_HOWMANY(sizeof(jmp_buf), sizeof(uintptr_t))];
 88135:     } registerSnapshot;
 88128: 
 97353:     ConservativeGCData() {
 97353:         PodZero(this);
 97353:     }
 88135: 
 88135:     ~ConservativeGCData() {
 88135: #ifdef JS_THREADSAFE
 88135:         /*
 88135:          * The conservative GC scanner should be disabled when the thread leaves
 88135:          * the last request.
 88135:          */
 88135:         JS_ASSERT(!hasStackToScan());
 88135: #endif
 88135:     }
 88135: 
 88135:     JS_NEVER_INLINE void recordStackTop();
 88135: 
 88135: #ifdef JS_THREADSAFE
 88135:     void updateForRequestEnd(unsigned suspendCount) {
 88135:         if (suspendCount)
 88135:             recordStackTop();
 88135:         else
 88135:             nativeStackTop = NULL;
 88135:     }
 88128: #endif
 88128: 
 88135:     bool hasStackToScan() const {
 88135:         return !!nativeStackTop;
 88128:     }
 26569: };
 26569: 
 97467: class ToSourceCache
 97467: {
 97467:     typedef HashMap<JSFunction *,
 97467:                     JSString *,
 97467:                     DefaultHasher<JSFunction *>,
 97467:                     SystemAllocPolicy> Map;
 97467:     Map *map_;
 97467:   public:
 97467:     ToSourceCache() : map_(NULL) {}
 97467:     JSString *lookup(JSFunction *fun);
 97467:     void put(JSFunction *fun, JSString *);
 97467:     void purge();
 97467: };
 97467: 
 97468: class EvalCache
 97468: {
 97468:     static const unsigned SHIFT = 6;
 97468:     static const unsigned LENGTH = 1 << SHIFT;
 97468:     JSScript *table_[LENGTH];
 97468: 
 97468:   public:
 97468:     EvalCache() { PodArrayZero(table_); }
 97468:     JSScript **bucket(JSLinearString *str);
 97468:     void purge();
 97468: };
 97468: 
 97466: class NativeIterCache
 97466: {
 97466:     static const size_t SIZE = size_t(1) << 8;
 97466: 
 97466:     /* Cached native iterators. */
 97466:     JSObject            *data[SIZE];
 97466: 
 97466:     static size_t getIndex(uint32_t key) {
 97466:         return size_t(key) % SIZE;
 97466:     }
 97466: 
 97466:   public:
 97466:     /* Native iterator most recently started. */
 97466:     JSObject            *last;
 97466: 
 97466:     NativeIterCache()
 97466:       : last(NULL) {
 97466:         PodArrayZero(data);
 97466:     }
 97466: 
 97466:     void purge() {
 97466:         last = NULL;
 97466:         PodArrayZero(data);
 97466:     }
 97466: 
 97466:     JSObject *get(uint32_t key) const {
 97466:         return data[getIndex(key)];
 97466:     }
 97466: 
 97466:     void set(uint32_t key, JSObject *iterobj) {
 97466:         data[getIndex(key)] = iterobj;
 97466:     }
 97466: };
 97466: 
 94942: /*
 97465:  * Cache for speeding up repetitive creation of objects in the VM.
 97465:  * When an object is created which matches the criteria in the 'key' section
 97465:  * below, an entry is filled with the resulting object.
 97465:  */
 97465: class NewObjectCache
 97465: {
 97465:     /* Statically asserted to be equal to sizeof(JSObject_Slots16) */
 97465:     static const unsigned MAX_OBJ_SIZE = 4 * sizeof(void*) + 16 * sizeof(Value);
 97465:     static inline void staticAsserts();
 97465: 
 97465:     struct Entry
 97465:     {
 97465:         /* Class of the constructed object. */
 97465:         Class *clasp;
 97465: 
 97465:         /*
 97465:          * Key with one of three possible values:
 97465:          *
 97465:          * - Global for the object. The object must have a standard class for
 97465:          *   which the global's prototype can be determined, and the object's
 97465:          *   parent will be the global.
 97465:          *
 97465:          * - Prototype for the object (cannot be global). The object's parent
 97465:          *   will be the prototype's parent.
 97465:          *
 97465:          * - Type for the object. The object's parent will be the type's
 97465:          *   prototype's parent.
 97465:          */
 97465:         gc::Cell *key;
 97465: 
 97465:         /* Allocation kind for the constructed object. */
 97465:         gc::AllocKind kind;
 97465: 
 97465:         /* Number of bytes to copy from the template object. */
 97465:         uint32_t nbytes;
 97465: 
 97465:         /*
 97465:          * Template object to copy from, with the initial values of fields,
 97465:          * fixed slots (undefined) and private data (NULL).
 97465:          */
 97465:         char templateObject[MAX_OBJ_SIZE];
 97465:     };
 97465: 
 97465:     Entry entries[41];  // TODO: reconsider size
 97465: 
 97465:   public:
 97465: 
 97465:     typedef int EntryIndex;
 97465: 
 97465:     NewObjectCache() { PodZero(this); }
 97465:     void purge() { PodZero(this); }
 97465: 
 97465:     /*
 97465:      * Get the entry index for the given lookup, return whether there was a hit
 97465:      * on an existing entry.
 97465:      */
 97465:     inline bool lookupProto(Class *clasp, JSObject *proto, gc::AllocKind kind, EntryIndex *pentry);
 97465:     inline bool lookupGlobal(Class *clasp, js::GlobalObject *global, gc::AllocKind kind, EntryIndex *pentry);
 97465:     inline bool lookupType(Class *clasp, js::types::TypeObject *type, gc::AllocKind kind, EntryIndex *pentry);
 97465: 
 97465:     /* Return a new object from a cache hit produced by a lookup method. */
 97465:     inline JSObject *newObjectFromHit(JSContext *cx, EntryIndex entry);
 97465: 
 97465:     /* Fill an entry after a cache miss. */
 97465:     inline void fillProto(EntryIndex entry, Class *clasp, JSObject *proto, gc::AllocKind kind, JSObject *obj);
 97465:     inline void fillGlobal(EntryIndex entry, Class *clasp, js::GlobalObject *global, gc::AllocKind kind, JSObject *obj);
 97465:     inline void fillType(EntryIndex entry, Class *clasp, js::types::TypeObject *type, gc::AllocKind kind, JSObject *obj);
 97465: 
 97465:     /* Invalidate any entries which might produce an object with shape/proto. */
 97465:     void invalidateEntriesForShape(JSContext *cx, Shape *shape, JSObject *proto);
 97465: 
 97465:   private:
 97465:     inline bool lookup(Class *clasp, gc::Cell *key, gc::AllocKind kind, EntryIndex *pentry);
 97465:     inline void fill(EntryIndex entry, Class *clasp, gc::Cell *key, gc::AllocKind kind, JSObject *obj);
 97465:     static inline void copyCachedToObject(JSObject *dst, JSObject *src);
 97465: };
 97465: 
 97465: /*
 94942:  * A FreeOp can do one thing: free memory. For convenience, it has delete_
 94942:  * convenience methods that also call destructors.
 94942:  *
 94942:  * FreeOp is passed to finalizers and other sweep-phase hooks so that we do not
 94942:  * need to pass a JSContext to those hooks.
 94942:  */
 94739: class FreeOp : public JSFreeOp {
 94739:     bool        shouldFreeLater_;
 94739:     bool        onBackgroundThread_;
 94740: 
 94739:   public:
 94739:     static FreeOp *get(JSFreeOp *fop) {
 94739:         return static_cast<FreeOp *>(fop);
 94739:     }
 94739: 
 94740:     FreeOp(JSRuntime *rt, bool shouldFreeLater, bool onBackgroundThread)
 94739:       : JSFreeOp(rt),
 94739:         shouldFreeLater_(shouldFreeLater),
 94740:         onBackgroundThread_(onBackgroundThread)
 94739:     {
 94739:     }
 94739: 
 94739:     bool shouldFreeLater() const {
 94739:         return shouldFreeLater_;
 94739:     }
 94739: 
 94739:     bool onBackgroundThread() const {
 94739:         return onBackgroundThread_;
 94739:     }
 94739: 
 94739:     inline void free_(void* p);
 94739: 
 94739:     JS_DECLARE_DELETE_METHODS(free_, inline)
 94739: 
 94739:     static void staticAsserts() {
 94739:         /*
 94739:          * Check that JSFreeOp is the first base class for FreeOp and we can
 94739:          * reinterpret a pointer to JSFreeOp as a pointer to FreeOp without
 94942:          * any offset adjustments. JSClass::finalize <-> Class::finalize depends
 94739:          * on this.
 94739:          */
 94739:         JS_STATIC_ASSERT(offsetof(FreeOp, shouldFreeLater_) == sizeof(JSFreeOp));
 94739:     }
 94739: };
 94739: 
 67915: } /* namespace js */
 67915: 
 98701: namespace JS {
 98701: struct RuntimeSizes;
 98701: }
 98701: 
 89261: struct JSRuntime : js::RuntimeFriendFields
 81562: {
 43286:     /* Default compartment. */
 60584:     JSCompartment       *atomsCompartment;
 43286: 
 80748:     /* List of compartments (protected by the GC lock). */
 80748:     js::CompartmentVector compartments;
 80748: 
 81562:     /* See comment for JS_AbortIfWrongThread in jsapi.h. */
 81562: #ifdef JS_THREADSAFE
 81562:   public:
 88135:     void *ownerThread() const { return ownerThread_; }
 81562:     void clearOwnerThread();
 81562:     void setOwnerThread();
 81562:     JS_FRIEND_API(bool) onOwnerThread() const;
 81562:   private:
 81562:     void                *ownerThread_;
 81562:   public:
 81562: #else
 81562:   public:
 81562:     bool onOwnerThread() const { return true; }
 81562: #endif
 81562: 
 88135:     /* Keeper of the contiguous stack used by all contexts in this thread. */
 88135:     js::StackSpace stackSpace;
 88135: 
 88135:     /* Temporary arena pool used while compiling and decompiling. */
 88135:     static const size_t TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE = 1 << 12;
 88135:     js::LifoAlloc tempLifoAlloc;
 88135: 
 88135:   private:
 88135:     /*
 88135:      * Both of these allocators are used for regular expression code which is shared at the
 88135:      * thread-data level.
 88135:      */
 88135:     JSC::ExecutableAllocator *execAlloc_;
 88135:     WTF::BumpPointerAllocator *bumpAlloc_;
 97464: #ifdef JS_METHODJIT
 97464:     js::mjit::JaegerRuntime *jaegerRuntime_;
 97464: #endif
 88135: 
 88135:     JSC::ExecutableAllocator *createExecutableAllocator(JSContext *cx);
 88135:     WTF::BumpPointerAllocator *createBumpPointerAllocator(JSContext *cx);
 97464:     js::mjit::JaegerRuntime *createJaegerRuntime(JSContext *cx);
 88135: 
 88135:   public:
 97464:     JSC::ExecutableAllocator *getExecAlloc(JSContext *cx) {
 88135:         return execAlloc_ ? execAlloc_ : createExecutableAllocator(cx);
 88135:     }
 97464:     JSC::ExecutableAllocator &execAlloc() {
 97464:         JS_ASSERT(execAlloc_);
 97464:         return *execAlloc_;
 97464:     }
 88135:     WTF::BumpPointerAllocator *getBumpPointerAllocator(JSContext *cx) {
 88135:         return bumpAlloc_ ? bumpAlloc_ : createBumpPointerAllocator(cx);
 88135:     }
 97464: #ifdef JS_METHODJIT
 97464:     js::mjit::JaegerRuntime *getJaegerRuntime(JSContext *cx) {
 97464:         return jaegerRuntime_ ? jaegerRuntime_ : createJaegerRuntime(cx);
 97464:     }
 97464:     bool hasJaegerRuntime() const {
 97464:         return jaegerRuntime_;
 97464:     }
 97464:     js::mjit::JaegerRuntime &jaegerRuntime() {
 97464:         JS_ASSERT(hasJaegerRuntime());
 97464:         return *jaegerRuntime_;
 97464:     }
 97464: #endif
 88135: 
 89261:     /* Base address of the native stack for the current thread. */
 89261:     uintptr_t           nativeStackBase;
 89261: 
 89261:     /* The native stack size limit that runtime should not exceed. */
 89261:     size_t              nativeStackQuota;
 89261: 
 88135:     /*
 88135:      * Frames currently running in js::Interpret. See InterpreterFrames for
 88135:      * details.
 88135:      */
 88135:     js::InterpreterFrames *interpreterFrames;
 88135: 
     1:     /* Context create/destroy callback. */
     1:     JSContextCallback   cxCallback;
     1: 
 94740:     /* Compartment destroy callback. */
 94740:     JSDestroyCompartmentCallback destroyCompartmentCallback;
 48503: 
 87286:     js::ActivityCallback  activityCallback;
 50462:     void                 *activityCallbackArg;
 50462: 
 88135: #ifdef JS_THREADSAFE
 88135:     /* Number of JS_SuspendRequest calls withot JS_ResumeRequest. */
 88135:     unsigned            suspendCount;
 88135: 
 88135:     /* The request depth for this thread. */
 88135:     unsigned            requestDepth;
 88135: 
 88135: # ifdef DEBUG
 88135:     unsigned            checkRequestDepth;
 88135: # endif
 88135: #endif
 88135: 
     1:     /* Garbage collector state, used by jsgc.c. */
 75385: 
 75385:     /*
 75385:      * Set of all GC chunks with at least one allocated thing. The
 75385:      * conservative GC uses it to quickly check if a possible GC thing points
 75385:      * into an allocated chunk.
 75385:      */
 75385:     js::GCChunkSet      gcChunkSet;
 75385: 
 75385:     /*
 75385:      * Doubly-linked lists of chunks from user and system compartments. The GC
 75385:      * allocates its arenas from the corresponding list and when all arenas
 75385:      * in the list head are taken, then the chunk is removed from the list.
 75385:      * During the GC when all arenas in a chunk become free, that chunk is
 75385:      * removed from the list and scheduled for release.
 75385:      */
 75385:     js::gc::Chunk       *gcSystemAvailableChunkListHead;
 75385:     js::gc::Chunk       *gcUserAvailableChunkListHead;
 79878:     js::gc::ChunkPool   gcChunkPool;
 49085: 
 48470:     js::RootedValueMap  gcRootsHash;
 42755:     js::GCLocks         gcLocksHash;
 91392:     unsigned            gcKeepAtoms;
 86796:     size_t              gcBytes;
 32553:     size_t              gcMaxBytes;
 32553:     size_t              gcMaxMallocBytes;
 85064: 
 85064:     /*
 85064:      * Number of the committed arenas in all GC chunks including empty chunks.
 85064:      * The counter is volatile as it is read without the GC lock, see comments
 85064:      * in MaybeGC.
 85064:      */
 85064:     volatile uint32_t   gcNumArenasFreeCommitted;
 91372:     js::GCMarker        gcMarker;
 82130:     void                *gcVerifyData;
 72110:     bool                gcChunkAllocationSinceLastGC;
 84755:     int64_t             gcNextFullGCTime;
 84755:     int64_t             gcJitReleaseTime;
 60531:     JSGCMode            gcMode;
 94620: 
 99131:     /* During shutdown, the GC needs to clean up every possible object. */
 99131:     bool                gcShouldCleanUpEverything;
 99131: 
 94620:     /*
 94620:      * These flags must be kept separate so that a thread requesting a
 94620:      * compartment GC doesn't cancel another thread's concurrent request for a
 94620:      * full GC.
 94620:      */
 86976:     volatile uintptr_t  gcIsNeeded;
 94620: 
 72067:     js::WeakMapBase     *gcWeakMapList;
 80212:     js::gcstats::Statistics gcStats;
 80212: 
 90410:     /* Incremented on every GC slice. */
 90410:     uint64_t            gcNumber;
 90410: 
 90410:     /* The gcNumber at the time of the most recent GC's first slice. */
 90410:     uint64_t            gcStartNumber;
 90410: 
 95297:     /* Whether all compartments are being collected in first GC slice. */
 95297:     bool                gcIsFull;
 95297: 
 80212:     /* The reason that an interrupt-triggered GC should be called. */
 88182:     js::gcreason::Reason gcTriggerReason;
 60258: 
     1:     /*
 94620:      * If this is true, all marked objects must belong to a compartment being
 94620:      * GCed. This is used to look for compartment bugs.
 73561:      */
 94620:     bool                gcStrictCompartmentChecking;
 73561: 
 73561:     /*
 90410:      * The current incremental GC phase. During non-incremental GC, this is
 90410:      * always NO_INCREMENTAL.
 90410:      */
 90410:     js::gc::State       gcIncrementalState;
 90410: 
 90410:     /* Indicates that the last incremental slice exhausted the mark stack. */
 90410:     bool                gcLastMarkSlice;
 90410: 
 90410:     /*
 90410:      * Indicates that a GC slice has taken place in the middle of an animation
 90410:      * frame, rather than at the beginning. In this case, the next slice will be
 90410:      * delayed so that we don't get back-to-back slices.
 90410:      */
 90410:     volatile uintptr_t  gcInterFrameGC;
 90410: 
 90410:     /* Default budget for incremental GC slice. See SliceBudget in jsgc.h. */
 90410:     int64_t             gcSliceBudget;
 90410: 
 90410:     /*
 90410:      * We disable incremental GC if we encounter a js::Class with a trace hook
 90410:      * that does not implement write barriers.
 90410:      */
 90410:     bool                gcIncrementalEnabled;
 90410: 
 90410:     /*
 97353:      * Whether exact stack scanning is enabled for this runtime. This is
 97353:      * currently only used for dynamic root analysis. Exact scanning starts out
 97353:      * enabled, and is disabled if e4x has been used.
 97353:      */
 97353:     bool                gcExactScanningEnabled;
 97353: 
 97353:     /*
 90410:      * We save all conservative scanned roots in this vector so that
 90410:      * conservative scanning can be "replayed" deterministically. In DEBUG mode,
 90410:      * this allows us to run a non-incremental GC after every incremental GC to
 90410:      * ensure that no objects were missed.
 90410:      */
 90410: #ifdef DEBUG
 90410:     struct SavedGCRoot {
 90410:         void *thing;
 90410:         JSGCTraceKind kind;
 90410: 
 90410:         SavedGCRoot(void *thing, JSGCTraceKind kind) : thing(thing), kind(kind) {}
 90410:     };
 90410:     js::Vector<SavedGCRoot, 0, js::SystemAllocPolicy> gcSavedRoots;
 90410: #endif
 90410: 
 53548:     bool                gcPoke;
 53548:     bool                gcRunning;
 30845: 
 71353:     /*
 71353:      * These options control the zealousness of the GC. The fundamental values
 71353:      * are gcNextScheduled and gcDebugCompartmentGC. At every allocation,
 71353:      * gcNextScheduled is decremented. When it reaches zero, we do either a
 71353:      * full or a compartmental GC, based on gcDebugCompartmentGC.
 71353:      *
 90410:      * At this point, if gcZeal_ == 2 then gcNextScheduled is reset to the
 71353:      * value of gcZealFrequency. Otherwise, no additional GCs take place.
 71353:      *
 71353:      * You can control these values in several ways:
 71353:      *   - Pass the -Z flag to the shell (see the usage info for details)
 71353:      *   - Call gczeal() or schedulegc() from inside shell-executed JS code
 71353:      *     (see the help for details)
 71353:      *
 90410:      * If gzZeal_ == 1 then we perform GCs in select places (during MaybeGC and
 90410:      * whenever a GC poke happens). This option is mainly useful to embedders.
 82130:      *
 82130:      * We use gcZeal_ == 4 to enable write barrier verification. See the comment
 82130:      * in jsgc.cpp for more information about this.
 71353:      */
  1492: #ifdef JS_GC_ZEAL
 71353:     int                 gcZeal_;
 71353:     int                 gcZealFrequency;
 71353:     int                 gcNextScheduled;
 91660:     bool                gcDeterministicOnly;
 71353: 
 94873:     js::Vector<JSObject *, 0, js::SystemAllocPolicy> gcSelectedForMarking;
 94873: 
 71353:     int gcZeal() { return gcZeal_; }
 71353: 
 71353:     bool needZealousGC() {
 71353:         if (gcNextScheduled > 0 && --gcNextScheduled == 0) {
 90410:             if (gcZeal() == js::gc::ZealAllocValue)
 71353:                 gcNextScheduled = gcZealFrequency;
 71353:             return true;
 71353:         }
 71353:         return false;
 71353:     }
 71353: #else
 71353:     int gcZeal() { return 0; }
 71353:     bool needZealousGC() { return false; }
  1492: #endif
     1: 
     1:     JSGCCallback        gcCallback;
 90410:     js::GCSliceCallback gcSliceCallback;
 91339:     JSFinalizeCallback  gcFinalizeCallback;
 34288: 
 99043:   private:
 99043:     /*
 99043:      * Malloc counter to measure memory pressure for GC scheduling. It runs
 99043:      * from gcMaxMallocBytes down to zero.
 99043:      */
 99043:     volatile ptrdiff_t  gcMallocBytes;
 99043: 
 53592:   public:
     1:     /*
 80159:      * The trace operations to trace embedding-specific GC roots. One is for
 80159:      * tracing through black roots and the other is for tracing through gray
 80159:      * roots. The black/gray distinction is only relevant to the cycle
 80159:      * collector.
   958:      */
 80159:     JSTraceDataOp       gcBlackRootsTraceOp;
 80159:     void                *gcBlackRootsData;
 80159:     JSTraceDataOp       gcGrayRootsTraceOp;
 80159:     void                *gcGrayRootsData;
   958: 
 91250:     /* Stack of thread-stack-allocated GC roots. */
 91250:     js::AutoGCRooter   *autoGCRooters;
 91250: 
 84803:     /* Strong references on scripts held for PCCount profiling API. */
 94574:     js::ScriptAndCountsVector *scriptAndCountsVector;
 84803: 
     1:     /* Well-known numbers held for use by this runtime's contexts. */
 48470:     js::Value           NaNValue;
 48470:     js::Value           negativeInfinityValue;
 48470:     js::Value           positiveInfinityValue;
     1: 
 76344:     JSAtom              *emptyString;
     1: 
 88135:     /* List of active contexts sharing this runtime. */
     1:     JSCList             contextList;
     1: 
 87611:     bool hasContexts() const {
 87611:         return !JS_CLIST_IS_EMPTY(&contextList);
 87611:     }
 87611: 
  2433:     /* Per runtime debug hooks -- see jsprvtd.h and jsdbgapi.h. */
 91178:     JSDebugHooks        debugHooks;
     1: 
 76243:     /* If true, new compartments are initially in debug mode. */
 75489:     bool                debugMode;
 56783: 
 84803:     /* If true, new scripts must be created with PC counter information. */
 84803:     bool                profilingScripts;
 84803: 
 98147:     /* Always preserve JIT code during GCs, for testing. */
 98147:     bool                alwaysPreserveCode;
 98147: 
 77343:     /* Had an out-of-memory error which did not populate an exception. */
 77343:     JSBool              hadOutOfMemory;
 77343: 
 75451:     /*
 75513:      * Linked list of all js::Debugger objects. This may be accessed by the GC
 75451:      * thread, if any, or a thread that is in a request and holds gcLock.
 75451:      */
 75451:     JSCList             debuggerList;
     1: 
 98921:     /* Bookkeeping information for debug scope objects. */
 98921:     js::DebugScopes     *debugScopes;
 98921: 
 20312:     /* Client opaque pointers */
     1:     void                *data;
     1: 
     1: #ifdef JS_THREADSAFE
     1:     /* These combine to interlock the GC and new requests. */
     1:     PRLock              *gcLock;
     1: 
 53592:     js::GCHelperThread  gcHelperThread;
     1: #endif /* JS_THREADSAFE */
 76248: 
 94739:   private:
 94739:     js::FreeOp          defaultFreeOp_;
 94739: 
 94739:   public:
 94739:     js::FreeOp *defaultFreeOp() {
 94739:         return &defaultFreeOp_;
 94739:     }
 94739: 
 84755:     uint32_t            debuggerMutations;
     1: 
 91900:     const JSSecurityCallbacks *securityCallbacks;
 91900:     JSDestroyPrincipalsOp destroyPrincipals;
     1: 
 80748:     /* Structured data callbacks are runtime-wide. */
 80748:     const JSStructuredCloneCallbacks *structuredCloneCallbacks;
 80748: 
 80213:     /* Call this to accumulate telemetry data. */
 80213:     JSAccumulateTelemetryDataCallback telemetryCallback;
 80213: 
     1:     /*
 52503:      * The propertyRemovals counter is incremented for every JSObject::clear,
 52503:      * and for each JSObject::remove method call that frees a slot in the given
 52503:      * object. See js_NativeGet and js_NativeSet in jsobj.cpp.
     1:      */
 84755:     int32_t             propertyRemovals;
     1: 
     1:     /* Number localization, used by jsnum.c */
     1:     const char          *thousandsSeparator;
     1:     const char          *decimalSeparator;
     1:     const char          *numGrouping;
     1: 
     1:     /*
 88135:      * Flag indicating that we are waiving any soft limits on the GC heap
 88135:      * because we want allocations to be infallible (except when we hit OOM).
 88135:      */
 88135:     bool                waiveGCQuota;
     1: 
 97464:   private:
 97464:     js::MathCache *mathCache_;
 97464:     js::MathCache *createMathCache(JSContext *cx);
 97464:   public:
 97464:     js::MathCache *getMathCache(JSContext *cx) {
 97464:         return mathCache_ ? mathCache_ : createMathCache(cx);
 97464:     }
 97464: 
 88135:     js::GSNCache        gsnCache;
 88135:     js::PropertyCache   propertyCache;
 97465:     js::NewObjectCache  newObjectCache;
 97466:     js::NativeIterCache nativeIterCache;
 97467:     js::ToSourceCache   toSourceCache;
 97468:     js::EvalCache       evalCache;
 88135: 
 88135:     /* State used by jsdtoa.cpp. */
 88135:     DtoaState           *dtoaState;
 88135: 
 88135:     /* List of currently pending operations on proxies. */
 88135:     js::PendingProxyOperation *pendingProxyOperation;
 88135: 
 88135:     js::ConservativeGCData conservativeGC;
     1: 
 73495:   private:
 73495:     JSPrincipals        *trustedPrincipals_;
 73495:   public:
 73495:     void setTrustedPrincipals(JSPrincipals *p) { trustedPrincipals_ = p; }
 73495:     JSPrincipals *trustedPrincipals() const { return trustedPrincipals_; }
 73495: 
 80748:     /* Literal table maintained by jsatom.c functions. */
 80748:     JSAtomState         atomState;
 80748: 
 78537:     /* Tables of strings that are pre-allocated in the atomsCompartment. */
 78537:     js::StaticStrings   staticStrings;
 78537: 
 47516:     JSWrapObjectCallback                   wrapObjectCallback;
 98430:     JSSameCompartmentWrapObjectCallback    sameCompartmentWrapObjectCallback;
 55628:     JSPreWrapCallback                      preWrapObjectCallback;
 84729:     js::PreserveWrapperCallback            preserveWrapperCallback;
 47516: 
 97463:     js::ScriptFilenameTable scriptFilenameTable;
 97463: 
 88135: #ifdef DEBUG
 88135:     size_t              noGCOrAllocationCheck;
 88135: #endif
 88135: 
 70287:     /*
 70287:      * To ensure that cx->malloc does not cause a GC, we set this flag during
 70287:      * OOM reporting (in js_ReportOutOfMemory). If a GC is requested while
 70287:      * reporting the OOM, we ignore it.
 70287:      */
 84755:     int32_t             inOOMReport;
 70287: 
 90106:     bool                jitHardening;
 90106: 
 34299:     JSRuntime();
 34299:     ~JSRuntime();
 34299: 
 84755:     bool init(uint32_t maxbytes);
 34299: 
 80212:     JSRuntime *thisFromCtor() { return this; }
 80212: 
 53592:     /*
 53592:      * Call the system malloc while checking for GC memory pressure and
 70287:      * reporting OOM error when cx is not null. We will not GC from here.
 53592:      */
 64560:     void* malloc_(size_t bytes, JSContext *cx = NULL) {
 88570:         updateMallocCounter(cx, bytes);
 53592:         void *p = ::js_malloc(bytes);
 53592:         return JS_LIKELY(!!p) ? p : onOutOfMemory(NULL, bytes, cx);
 53592:     }
 53592: 
 53592:     /*
 53592:      * Call the system calloc while checking for GC memory pressure and
 70287:      * reporting OOM error when cx is not null. We will not GC from here.
 53592:      */
 64560:     void* calloc_(size_t bytes, JSContext *cx = NULL) {
 88570:         updateMallocCounter(cx, bytes);
 53592:         void *p = ::js_calloc(bytes);
 53592:         return JS_LIKELY(!!p) ? p : onOutOfMemory(reinterpret_cast<void *>(1), bytes, cx);
 53592:     }
 53592: 
 64560:     void* realloc_(void* p, size_t oldBytes, size_t newBytes, JSContext *cx = NULL) {
 59001:         JS_ASSERT(oldBytes < newBytes);
 88570:         updateMallocCounter(cx, newBytes - oldBytes);
 59001:         void *p2 = ::js_realloc(p, newBytes);
 59001:         return JS_LIKELY(!!p2) ? p2 : onOutOfMemory(p, newBytes, cx);
 59001:     }
 59001: 
 64560:     void* realloc_(void* p, size_t bytes, JSContext *cx = NULL) {
 53592:         /*
 53592:          * For compatibility we do not account for realloc that increases
 53592:          * previously allocated memory.
 53592:          */
 53592:         if (!p)
 88570:             updateMallocCounter(cx, bytes);
 53592:         void *p2 = ::js_realloc(p, bytes);
 53592:         return JS_LIKELY(!!p2) ? p2 : onOutOfMemory(p, bytes, cx);
 53592:     }
 34288: 
 64560:     inline void free_(void* p) {
 64559:         /* FIXME: Making this free in the background is buggy. Can it work? */
 64560:         js::Foreground::free_(p);
 64559:     }
 64559: 
 64560:     JS_DECLARE_NEW_METHODS(malloc_, JS_ALWAYS_INLINE)
 64560:     JS_DECLARE_DELETE_METHODS(free_, JS_ALWAYS_INLINE)
 34288: 
 98574:     void setGCMaxMallocBytes(size_t value);
 53592: 
 99043:     void resetGCMallocBytes() { gcMallocBytes = ptrdiff_t(gcMaxMallocBytes); }
 99043: 
 53592:     /*
 53592:      * Call this after allocating memory held by GC things, to update memory
 53592:      * pressure counters or report the OOM error if necessary. If oomError and
 53592:      * cx is not null the function also reports OOM error.
 53592:      *
 53592:      * The function must be called outside the GC lock and in case of OOM error
 53592:      * the caller must ensure that no deadlock possible during OOM reporting.
 53592:      */
 88570:     void updateMallocCounter(JSContext *cx, size_t nbytes);
 99043: 
 99043:     bool isTooMuchMalloc() const {
 99043:         return gcMallocBytes <= 0;
 99043:     }
 99043: 
 99043:     /*
 99043:      * The function must be called outside the GC lock.
 99043:      */
 99043:     JS_FRIEND_API(void) onTooMuchMalloc();
 99043: 
 53592:     /*
 53592:      * This should be called after system malloc/realloc returns NULL to try
 53592:      * to recove some memory or to report an error. Failures in malloc and
 53592:      * calloc are signaled by p == null and p == reinterpret_cast<void *>(1).
 53592:      * Other values of p mean a realloc failure.
 53592:      *
 53592:      * The function must be called outside the GC lock.
 53592:      */
 53592:     JS_FRIEND_API(void *) onOutOfMemory(void *p, size_t nbytes, JSContext *cx);
 88135: 
 91846:     void triggerOperationCallback();
 88135: 
 90106:     void setJitHardening(bool enabled);
 90106:     bool getJitHardening() const {
 90106:         return jitHardening;
 90106:     }
 90106: 
 98789:     void sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf, JS::RuntimeSizes *runtime);
 98701:     size_t sizeOfExplicitNonHeap();
     1: };
     1: 
 88135: /* Common macros to access thread-local caches in JSRuntime. */
 88135: #define JS_PROPERTY_CACHE(cx)   (cx->runtime->propertyCache)
 24375: 
 88135: #define JS_KEEP_ATOMS(rt)   (rt)->gcKeepAtoms++;
 88135: #define JS_UNKEEP_ATOMS(rt) (rt)->gcKeepAtoms--;
     1: 
     1: #ifdef JS_ARGUMENT_FORMATTER_DEFINED
     1: /*
     1:  * Linked list mapping format strings for JS_{Convert,Push}Arguments{,VA} to
     1:  * formatter functions.  Elements are sorted in non-increasing format string
     1:  * length order.
     1:  */
     1: struct JSArgumentFormatMap {
     1:     const char          *format;
     1:     size_t              length;
     1:     JSArgumentFormatter formatter;
     1:     JSArgumentFormatMap *next;
     1: };
     1: #endif
     1: 
 40221: namespace js {
 52503: 
 64302: struct AutoResolving;
 50491: 
 53848: static inline bool
 99821: OptionsHasAllowXML(uint32_t options)
 99821: {
 99821:     return !!(options & JSOPTION_ALLOW_XML);
 99821: }
 99821: 
 99821: static inline bool
 99820: OptionsHasMoarXML(uint32_t options)
 53848: {
 99820:     return !!(options & JSOPTION_MOAR_XML);
 53848: }
 53848: 
 53848: static inline bool
 84755: OptionsSameVersionFlags(uint32_t self, uint32_t other)
 53848: {
 99820:     static const uint32_t mask = JSOPTION_MOAR_XML;
 53848:     return !((self & mask) ^ (other & mask));
 53848: }
 53848: 
 57816: /*
 57816:  * Flags accompany script version data so that a) dynamically created scripts
 57816:  * can inherit their caller's compile-time properties and b) scripts can be
 57816:  * appropriately compared in the eval cache across global option changes. An
 57816:  * example of the latter is enabling the top-level-anonymous-function-is-error
 57816:  * option: subsequent evals of the same, previously-valid script text may have
 57816:  * become invalid.
 57816:  */
 53848: namespace VersionFlags {
 91237: static const unsigned MASK      = 0x0FFF; /* see JSVersion in jspubtd.h */
 99821: static const unsigned ALLOW_XML = 0x1000; /* flag induced by JSOPTION_ALLOW_XML */
 99821: static const unsigned MOAR_XML  = 0x2000; /* flag induced by JSOPTION_MOAR_XML */
 91237: static const unsigned FULL_MASK = 0x3FFF;
 94738: } /* namespace VersionFlags */
 53848: 
 54417: static inline JSVersion
 54417: VersionNumber(JSVersion version)
 54417: {
 84755:     return JSVersion(uint32_t(version) & VersionFlags::MASK);
 54417: }
 54417: 
 53848: static inline bool
 99821: VersionHasAllowXML(JSVersion version)
 99821: {
 99821:     return !!(version & VersionFlags::ALLOW_XML);
 99821: }
 99821: 
 99821: static inline bool
 99820: VersionHasMoarXML(JSVersion version)
 53848: {
 99820:     return !!(version & VersionFlags::MOAR_XML);
 53848: }
 53848: 
 54417: /* @warning This is a distinct condition from having the XML flag set. */
 54417: static inline bool
 54417: VersionShouldParseXML(JSVersion version)
 54417: {
 99820:     return VersionHasMoarXML(version) || VersionNumber(version) >= JSVERSION_1_6;
 54417: }
 54417: 
 53848: static inline JSVersion
 53848: VersionExtractFlags(JSVersion version)
 53848: {
 84755:     return JSVersion(uint32_t(version) & ~VersionFlags::MASK);
 53848: }
 53848: 
 61450: static inline void
 61450: VersionCopyFlags(JSVersion *version, JSVersion from)
 61450: {
 61450:     *version = JSVersion(VersionNumber(*version) | VersionExtractFlags(from));
 61450: }
 61450: 
 53848: static inline bool
 53848: VersionHasFlags(JSVersion version)
 53848: {
 53848:     return !!VersionExtractFlags(version);
 53848: }
 53848: 
 91237: static inline unsigned
 61450: VersionFlagsToOptions(JSVersion version)
 61450: {
 99821:     unsigned copts = (VersionHasAllowXML(version) ? JSOPTION_ALLOW_XML : 0) |
 99821:                      (VersionHasMoarXML(version) ? JSOPTION_MOAR_XML : 0);
 61450:     JS_ASSERT((copts & JSCOMPILEOPTION_MASK) == copts);
 61450:     return copts;
 61450: }
 61450: 
 61450: static inline JSVersion
 91237: OptionFlagsToVersion(unsigned options, JSVersion version)
 61450: {
 99821:     uint32_t v = version;
 99821:     v &= ~(VersionFlags::ALLOW_XML | VersionFlags::MOAR_XML);
 99821:     if (OptionsHasAllowXML(options))
 99821:         v |= VersionFlags::ALLOW_XML;
 99821:     if (OptionsHasMoarXML(options))
 99821:         v |= VersionFlags::MOAR_XML;
 99821:     return JSVersion(v);
 61450: }
 61450: 
 53848: static inline bool
 53848: VersionIsKnown(JSVersion version)
 53848: {
 53848:     return VersionNumber(version) != JSVERSION_UNKNOWN;
 53848: }
 53848: 
 67950: typedef HashSet<JSObject *,
 67950:                 DefaultHasher<JSObject *>,
 67950:                 SystemAllocPolicy> BusyArraysSet;
 61229: 
 94739: inline void
 94739: FreeOp::free_(void* p) {
 94738: #ifdef JS_THREADSAFE
 94738:     if (shouldFreeLater()) {
 94738:         runtime()->gcHelperThread.freeLater(p);
 94738:         return;
 94738:     }
 94738: #endif
 94738:     runtime()->free_(p);
 94738: }
 94738: 
 52503: } /* namespace js */
 50491: 
 89261: struct JSContext : js::ContextFriendFields
 38568: {
 42714:     explicit JSContext(JSRuntime *rt);
 69223:     JSContext *thisDuringConstruction() { return this; }
 67915:     ~JSContext();
 38568: 
 80748:     /* JSRuntime contextList linkage. */
 80748:     JSCList             link;
 80748: 
 80748:   private:
 80748:     /* See JSContext::findVersion. */
 80748:     JSVersion           defaultVersion;      /* script compilation version */
 80748:     JSVersion           versionOverride;     /* supercedes defaultVersion when valid */
 80748:     bool                hasVersionOverride;
 80748: 
 80748:     /* Exception state -- the exception member is a GC root by definition. */
 80748:     JSBool              throwing;            /* is there a pending exception? */
 80748:     js::Value           exception;           /* most-recently-thrown exception */
 80748: 
 80748:     /* Per-context run options. */
 91237:     unsigned            runOptions;          /* see jsapi.h for JSOPTION_* */
 80748: 
 80748:   public:
 84755:     int32_t             reportGranularity;  /* see jsprobes.h */
 80748: 
 80748:     /* Locale specific callbacks for string conversion. */
 80748:     JSLocaleCallbacks   *localeCallbacks;
 80748: 
 80748:     js::AutoResolving   *resolvingList;
 80748: 
 92710:     /* True if generating an error, to prevent runaway recursion. */
 91303:     bool                generatingError;
 80748: 
 80748:     /* GC heap compartment. */
 80748:     JSCompartment       *compartment;
 80748: 
 80748:     inline void setCompartment(JSCompartment *compartment);
 80744: 
 69223:     /* Current execution stack. */
 69223:     js::ContextStack    stack;
 69223: 
 69223:     /* ContextStack convenience functions */
 87949:     inline bool hasfp() const               { return stack.hasfp(); }
 87949:     inline js::StackFrame* fp() const       { return stack.fp(); }
 87949:     inline js::StackFrame* maybefp() const  { return stack.maybefp(); }
 87949:     inline js::FrameRegs& regs() const      { return stack.regs(); }
 87949:     inline js::FrameRegs* maybeRegs() const { return stack.maybeRegs(); }
 69223: 
 69223:     /* Set cx->compartment based on the current scope chain. */
 55607:     void resetCompartment();
 69223: 
 69223:     /* Wrap cx->exception for the current compartment. */
 60245:     void wrapPendingException();
 42717: 
 72579:   private:
 72579:     /* Lazily initialized pool of maps used during parse/emit. */
 72579:     js::ParseMapPool    *parseMapPool_;
 72579: 
 72579:   public:
 80748:     /* Top-level object and pointer to top stack frame's scope chain. */
 80748:     JSObject            *globalObject;
 80748: 
     1:     /* State for object and array toSource conversion. */
     1:     JSSharpObjectMap    sharpObjectMap;
 67950:     js::BusyArraysSet   busyArrays;
     1: 
     1:     /* Argument formatter support for JS_{Convert,Push}Arguments{,VA}. */
     1:     JSArgumentFormatMap *argumentFormatMap;
     1: 
 56604:     /* Last message string and log file for debugging. */
     1:     char                *lastMessage;
     1: 
  9780:     /* Per-context optional error reporter. */
     1:     JSErrorReporter     errorReporter;
     1: 
 25087:     /* Branch callback. */
  9780:     JSOperationCallback operationCallback;
  9780: 
 80748:     /* Client opaque pointers. */
 80748:     void                *data;
 80748:     void                *data2;
 80748: 
 62953:     inline js::RegExpStatics *regExpStatics();
 53858: 
 61450:   public:
 72579:     js::ParseMapPool &parseMapPool() {
 72579:         JS_ASSERT(parseMapPool_);
 72579:         return *parseMapPool_;
 72579:     }
 72579: 
 72579:     inline bool ensureParseMapPool();
 72579: 
 53848:     /*
 53848:      * The default script compilation version can be set iff there is no code running.
 53848:      * This typically occurs via the JSAPI right after a context is constructed.
 53848:      */
 79734:     inline bool canSetDefaultVersion() const;
 53848: 
 53848:     /* Force a version for future script compilation. */
 79734:     inline void overrideVersion(JSVersion newVersion);
 53848: 
 53848:     /* Set the default script compilation version. */
 57819:     void setDefaultVersion(JSVersion version) {
 57819:         defaultVersion = version;
 57819:     }
 53848: 
 61450:     void clearVersionOverride() { hasVersionOverride = false; }
 61450:     JSVersion getDefaultVersion() const { return defaultVersion; }
 61450:     bool isVersionOverridden() const { return hasVersionOverride; }
 61450: 
 61450:     JSVersion getVersionOverride() const {
 61450:         JS_ASSERT(isVersionOverridden());
 61450:         return versionOverride;
 61450:     }
 61450: 
 53848:     /*
 53848:      * Set the default version if possible; otherwise, force the version.
 53848:      * Return whether an override occurred.
 53848:      */
 79734:     inline bool maybeOverrideVersion(JSVersion newVersion);
 53848: 
 61450:     /*
 69223:      * If there is no code on the stack, turn the override version into the
 69223:      * default version.
 61450:      */
 61450:     void maybeMigrateVersionOverride() {
 71697:         JS_ASSERT(stack.empty());
 71697:         if (JS_UNLIKELY(isVersionOverridden())) {
 61450:             defaultVersion = versionOverride;
 61450:             clearVersionOverride();
 61450:         }
 71697:     }
 61450: 
 53848:     /*
 53848:      * Return:
 53848:      * - The override version, if there is an override version.
 53848:      * - The newest scripted frame's version, if there is such a frame.
 78017:      * - The default version.
 53848:      *
 60169:      * Note: if this ever shows up in a profile, just add caching!
 53848:      */
 79734:     inline JSVersion findVersion() const;
 53848: 
 91237:     void setRunOptions(unsigned ropts) {
 61450:         JS_ASSERT((ropts & JSRUNOPTION_MASK) == ropts);
 61450:         runOptions = ropts;
 57819:     }
 57819: 
 61450:     /* Note: may override the version. */
 91237:     inline void setCompileOptions(unsigned newcopts);
 61425: 
 91237:     unsigned getRunOptions() const { return runOptions; }
 91237:     inline unsigned getCompileOptions() const;
 91237:     inline unsigned allOptions() const;
 61450: 
 91237:     bool hasRunOption(unsigned ropt) const {
 61450:         JS_ASSERT((ropt & JSRUNOPTION_MASK) == ropt);
 61450:         return !!(runOptions & ropt);
 57819:     }
 57819: 
 61450:     bool hasStrictOption() const { return hasRunOption(JSOPTION_STRICT); }
 61450:     bool hasWErrorOption() const { return hasRunOption(JSOPTION_WERROR); }
 61450:     bool hasAtLineOption() const { return hasRunOption(JSOPTION_ATLINE); }
 61450: 
 88135:     js::LifoAlloc &tempLifoAlloc() { return runtime->tempLifoAlloc; }
 79410:     inline js::LifoAlloc &typeLifoAlloc();
 79410: 
 98835:     inline js::PropertyTree &propertyTree();
 98835: 
     1: #ifdef JS_THREADSAFE
 80748:     unsigned            outstandingRequests;/* number of JS_BeginRequest calls
 80748:                                                without the corresponding
 80748:                                                JS_EndRequest. */
     1: #endif
     1: 
 19712:     /* Stored here to avoid passing it around as a parameter. */
 91237:     unsigned               resolveFlags;
 24598: 
 40306:     /* Random number generator state, used by jsmath.cpp. */
 84755:     int64_t             rngSeed;
 40306: 
 74052:     /* Location to stash the iteration value between JSOP_MOREITER and JSOP_ITERNEXT. */
 48470:     js::Value           iterValue;
 42641: 
 54175: #ifdef JS_METHODJIT
 54175:     bool                 methodJitEnabled;
 69223: 
 97464:     js::mjit::JaegerRuntime &jaegerRuntime() { return runtime->jaegerRuntime(); }
 54175: #endif
 54175: 
 77343:     bool                 inferenceEnabled;
 77343: 
 77343:     bool typeInferenceEnabled() { return inferenceEnabled; }
 77343: 
 35331:     /* Caller must be holding runtime->gcLock. */
 54175:     void updateJITEnabled();
 35331: 
 50455: #ifdef MOZ_TRACE_JSCALLS
 50455:     /* Function entry/exit debugging callback. */
 50455:     JSFunctionCallback    functionCallback;
 50455: 
 50455:     void doFunctionCallback(const JSFunction *fun,
 50455:                             const JSScript *scr,
 57757:                             int entering) const
 50455:     {
 50455:         if (functionCallback)
 50455:             functionCallback(fun, scr, this, entering);
 50455:     }
 50455: #endif
 50455: 
 43191:     DSTOffsetCache dstOffsetCache;
 43191: 
 43281:     /* List of currently active non-escaping enumerators (for-in). */
 43281:     JSObject *enumerators;
 41796: 
 42714:   private:
100006:     /*
100006:      * To go from a live generator frame (on the stack) to its generator object
100006:      * (see comment js_FloatingFrameIfGenerator), we maintain a stack of active
100006:      * generators, pushing and popping when entering and leaving generator
100006:      * frames, respectively.
100006:      */
100006:     js::Vector<JSGenerator *, 2, js::SystemAllocPolicy> genStack;
100006: 
 42714:   public:
100006:     /* Return the generator object for the given generator frame. */
100006:     JSGenerator *generatorFor(js::StackFrame *fp) const;
100006: 
100006:     /* Early OOM-check. */
100006:     inline bool ensureGeneratorStackSpace();
100006: 
100006:     bool enterGenerator(JSGenerator *gen) {
100006:         return genStack.append(gen);
100006:     }
100006: 
100006:     void leaveGenerator(JSGenerator *gen) {
100006:         JS_ASSERT(genStack.back() == gen);
100006:         genStack.popBack();
100006:     }
 42714: 
 64560:     inline void* malloc_(size_t bytes) {
 64560:         return runtime->malloc_(bytes, this);
 34288:     }
 32553: 
 33128:     inline void* mallocNoReport(size_t bytes) {
 33128:         JS_ASSERT(bytes != 0);
 64560:         return runtime->malloc_(bytes, NULL);
 33128:     }
 33128: 
 64560:     inline void* calloc_(size_t bytes) {
 64560:         return runtime->calloc_(bytes, this);
 30851:     }
 30851: 
 64560:     inline void* realloc_(void* p, size_t bytes) {
 64560:         return runtime->realloc_(p, bytes, this);
 30851:     }
 30851: 
 64560:     inline void* realloc_(void* p, size_t oldBytes, size_t newBytes) {
 64560:         return runtime->realloc_(p, oldBytes, newBytes, this);
 59001:     }
 59001: 
 64560:     inline void free_(void* p) {
 64560:         runtime->free_(p);
 30851:     }
 32651: 
 64560:     JS_DECLARE_NEW_METHODS(malloc_, inline)
 64560:     JS_DECLARE_DELETE_METHODS(free_, inline)
 34288: 
 38604:     void purge();
 38604: 
100006:     /* For DEBUG. */
100006:     inline void assertValidStackDepth(unsigned depth);
100006: 
 60211:     bool isExceptionPending() {
 60211:         return throwing;
 60211:     }
 60211: 
 60211:     js::Value getPendingException() {
 60211:         JS_ASSERT(throwing);
 60211:         return exception;
 60211:     }
 60211: 
 60211:     void setPendingException(js::Value v);
 60211: 
 60211:     void clearPendingException() {
 60211:         this->throwing = false;
 60211:         this->exception.setUndefined();
 60211:     }
 60211: 
 98921: #ifdef DEBUG
 98921:     /*
 98921:      * Controls whether a quadratic-complexity assertion is performed during
 98921:      * stack iteration; defaults to true.
 98921:      */
 98921:     bool stackIterAssertionEnabled;
100006: 
100006:     /*
100006:      * When greather than zero, it is ok to accessed non-aliased fields of
100006:      * ScopeObjects because the accesses are coming from the DebugScopeProxy.
100006:      */
100006:     unsigned okToAccessUnaliasedBindings;
 98921: #endif
 98921: 
 72579:     /*
 72579:      * Count of currently active compilations.
 72579:      * When there are compilations active for the context, the GC must not
 72579:      * purge the ParseMapPool.
 72579:      */
 91237:     unsigned activeCompilations;
 72579: 
 74914:     /*
 74914:      * See JS_SetTrustedPrincipals in jsapi.h.
 74914:      * Note: !cx->compartment is treated as trusted.
 74914:      */
 74914:     bool runningWithTrustedPrincipals() const;
 74914: 
 83122:     JS_FRIEND_API(size_t) sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf) const;
 83122: 
 77166:     static inline JSContext *fromLinkField(JSCList *link) {
 77166:         JS_ASSERT(link);
 77166:         return reinterpret_cast<JSContext *>(uintptr_t(link) - offsetof(JSContext, link));
 77166:     }
 77166: 
 90302:     void mark(JSTracer *trc);
 90302: 
 48619:   private:
 48619:     /*
 48619:      * The allocation code calls the function to indicate either OOM failure
 48619:      * when p is null or that a memory pressure counter has reached some
 48619:      * threshold when p is not null. The function takes the pointer and not
 48619:      * a boolean flag to minimize the amount of code in its inlined callers.
 48619:      */
 48619:     JS_FRIEND_API(void) checkMallocGCPressure(void *p);
 57585: }; /* struct JSContext */
     1: 
 69223: namespace js {
 69223: 
100006: class AutoAllowUnaliasedVarAccess
100006: {
100006:     JSContext *cx;
100006:   public:
100006:     AutoAllowUnaliasedVarAccess(JSContext *cx) : cx(cx) {
100006: #ifdef DEBUG
100006:         cx->okToAccessUnaliasedBindings++;
100006: #endif
100006:     }
100006:     ~AutoAllowUnaliasedVarAccess() {
100006: #ifdef DEBUG
100006:         JS_ASSERT(cx->okToAccessUnaliasedBindings);
100006:         cx->okToAccessUnaliasedBindings--;
100006: #endif
100006:     }
100006: };
100006: 
 64302: struct AutoResolving {
 64302:   public:
 64302:     enum Kind {
 64302:         LOOKUP,
 64302:         WATCH
 64302:     };
 64302: 
 64302:     AutoResolving(JSContext *cx, JSObject *obj, jsid id, Kind kind = LOOKUP
 64302:                   JS_GUARD_OBJECT_NOTIFIER_PARAM)
 64302:       : context(cx), object(obj), id(id), kind(kind), link(cx->resolvingList)
 64302:     {
 64302:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 64302:         JS_ASSERT(obj);
 64302:         cx->resolvingList = this;
 64302:     }
 64302: 
 64302:     ~AutoResolving() {
 64302:         JS_ASSERT(context->resolvingList == this);
 64302:         context->resolvingList = link;
 64302:     }
 64302: 
 64302:     bool alreadyStarted() const {
 64302:         return link && alreadyStartedSlow();
 64302:     }
 64302: 
 64302:   private:
 64302:     bool alreadyStartedSlow() const;
 64302: 
 64302:     JSContext           *const context;
 64302:     JSObject            *const object;
 64302:     jsid                const id;
 64302:     Kind                const kind;
 64302:     AutoResolving       *const link;
 64302:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 64302: };
 64302: 
 98644: #if JS_HAS_XML_SUPPORT
 40221: class AutoXMLRooter : private AutoGCRooter {
 40221:   public:
 60555:     AutoXMLRooter(JSContext *cx, JSXML *xml
 60555:                   JS_GUARD_OBJECT_NOTIFIER_PARAM)
 80748:       : AutoGCRooter(cx, XML), xml(xml)
 40221:     {
 60555:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 40221:         JS_ASSERT(xml);
 40221:     }
 40221: 
 80748:     friend void AutoGCRooter::trace(JSTracer *trc);
 80748: 
 80744:   private:
 40221:     JSXML * const xml;
 60555:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 40221: };
 40221: #endif /* JS_HAS_XML_SUPPORT */
 40221: 
 88135: #ifdef JS_THREADSAFE
 88135: # define JS_LOCK_GC(rt)    PR_Lock((rt)->gcLock)
 88135: # define JS_UNLOCK_GC(rt)  PR_Unlock((rt)->gcLock)
 88135: #else
 88135: # define JS_LOCK_GC(rt)
 88135: # define JS_UNLOCK_GC(rt)
 88135: #endif
 88135: 
 91846: class AutoLockGC
 91846: {
 91846:   public:
 91846:     explicit AutoLockGC(JSRuntime *rt = NULL
 91846:                         MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
 91846:       : runtime(rt)
 91846:     {
 91846:         MOZ_GUARD_OBJECT_NOTIFIER_INIT;
 92157:         // Avoid MSVC warning C4390 for non-threadsafe builds.
 92157: #ifdef JS_THREADSAFE
 91846:         if (rt)
 91846:             JS_LOCK_GC(rt);
 92157: #endif
 91846:     }
 91846: 
 91846:     ~AutoLockGC()
 91846:     {
 92157: #ifdef JS_THREADSAFE
 91846:         if (runtime)
 91846:             JS_UNLOCK_GC(runtime);
 92157: #endif
 91846:     }
 91846: 
 91846:     bool locked() const {
 91846:         return !!runtime;
 91846:     }
 91846: 
 91846:     void lock(JSRuntime *rt) {
 91846:         JS_ASSERT(rt);
 91846:         JS_ASSERT(!runtime);
 91846:         runtime = rt;
 91846:         JS_LOCK_GC(rt);
 91846:     }
 91846: 
 91846:   private:
 91846:     JSRuntime *runtime;
 91846:     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
 91846: };
 91846: 
 40840: class AutoUnlockGC {
 40840:   private:
 40840:     JSRuntime *rt;
 60555:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 60555: 
 40840:   public:
 60555:     explicit AutoUnlockGC(JSRuntime *rt
 60555:                           JS_GUARD_OBJECT_NOTIFIER_PARAM)
 60555:       : rt(rt)
 60555:     {
 60555:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 60555:         JS_UNLOCK_GC(rt);
 60555:     }
 40840:     ~AutoUnlockGC() { JS_LOCK_GC(rt); }
 40840: };
 40840: 
 40840: class AutoKeepAtoms {
 40840:     JSRuntime *rt;
 60555:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 60555: 
 40840:   public:
 60555:     explicit AutoKeepAtoms(JSRuntime *rt
 60555:                            JS_GUARD_OBJECT_NOTIFIER_PARAM)
 60555:       : rt(rt)
 60555:     {
 60555:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 60555:         JS_KEEP_ATOMS(rt);
 60555:     }
 40840:     ~AutoKeepAtoms() { JS_UNKEEP_ATOMS(rt); }
 40840: };
 40840: 
 50491: class AutoReleasePtr {
 50491:     JSContext   *cx;
 50491:     void        *ptr;
 60555:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 60555: 
 86269:     AutoReleasePtr(const AutoReleasePtr &other) MOZ_DELETE;
 86269:     AutoReleasePtr operator=(const AutoReleasePtr &other) MOZ_DELETE;
 60555: 
 50491:   public:
 60555:     explicit AutoReleasePtr(JSContext *cx, void *ptr
 60555:                             JS_GUARD_OBJECT_NOTIFIER_PARAM)
 60555:       : cx(cx), ptr(ptr)
 60555:     {
 60555:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 60555:     }
 64560:     ~AutoReleasePtr() { cx->free_(ptr); }
 50491: };
 50491: 
 56211: /*
 56211:  * FIXME: bug 602774: cleaner API for AutoReleaseNullablePtr
 56211:  */
 56211: class AutoReleaseNullablePtr {
 56211:     JSContext   *cx;
 56211:     void        *ptr;
 60555:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 60555: 
 86269:     AutoReleaseNullablePtr(const AutoReleaseNullablePtr &other) MOZ_DELETE;
 86269:     AutoReleaseNullablePtr operator=(const AutoReleaseNullablePtr &other) MOZ_DELETE;
 60555: 
 56211:   public:
 60555:     explicit AutoReleaseNullablePtr(JSContext *cx, void *ptr
 60555:                                     JS_GUARD_OBJECT_NOTIFIER_PARAM)
 60555:       : cx(cx), ptr(ptr)
 60555:     {
 60555:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 60555:     }
 56211:     void reset(void *ptr2) {
 56211:         if (ptr)
 64560:             cx->free_(ptr);
 56211:         ptr = ptr2;
 56211:     }
 64560:     ~AutoReleaseNullablePtr() { if (ptr) cx->free_(ptr); }
 56211: };
 56211: 
 40379: } /* namespace js */
 40379: 
 19712: class JSAutoResolveFlags
 19712: {
 19712:   public:
 91237:     JSAutoResolveFlags(JSContext *cx, unsigned flags
 33538:                        JS_GUARD_OBJECT_NOTIFIER_PARAM)
 40221:       : mContext(cx), mSaved(cx->resolveFlags)
 40221:     {
 33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 19712:         cx->resolveFlags = flags;
 19712:     }
 19712: 
 19712:     ~JSAutoResolveFlags() { mContext->resolveFlags = mSaved; }
 19712: 
 19712:   private:
 19712:     JSContext *mContext;
 91237:     unsigned mSaved;
 33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 19712: };
 24293: 
 42712: namespace js {
 42712: 
 77166: /*
 91250:  * Enumerate all contexts in a runtime.
 77166:  */
 91250: class ContextIter {
 77166:     JSCList *begin;
 77166:     JSCList *end;
 77166: 
 77166: public:
 91250:     explicit ContextIter(JSRuntime *rt) {
 91250:         end = &rt->contextList;
 77166:         begin = end->next;
 77166:     }
 77166: 
 91250:     bool done() const {
 91250:         return begin == end;
 91250:     }
 77166: 
 91250:     void next() {
 91250:         JS_ASSERT(!done());
 91250:         begin = begin->next;
 91250:     }
 91250: 
 91250:     JSContext *get() const {
 91250:         JS_ASSERT(!done());
 77166:         return JSContext::fromLinkField(begin);
 77166:     }
 91250: 
 91250:     operator JSContext *() const {
 91250:         return get();
 91250:     }
 91250: 
 91250:     JSContext *operator ->() const {
 91250:         return get();
 91250:     }
 77166: };
 77166: 
 22627: /*
     1:  * Create and destroy functions for JSContext, which is manually allocated
     1:  * and exclusively owned.
     1:  */
     1: extern JSContext *
 94960: NewContext(JSRuntime *rt, size_t stackChunkSize);
     1: 
 94960: enum DestroyContextMode {
 94960:     DCM_NO_GC,
 94960:     DCM_FORCE_GC,
 94960:     DCM_NEW_FAILED
 94960: };
 88135: 
     1: extern void
 94960: DestroyContext(JSContext *cx, DestroyContextMode mode);
 94960: 
 94960: } /* namespace js */
     1: 
     1: #ifdef va_start
     1: extern JSBool
 91237: js_ReportErrorVA(JSContext *cx, unsigned flags, const char *format, va_list ap);
     1: 
     1: extern JSBool
 91237: js_ReportErrorNumberVA(JSContext *cx, unsigned flags, JSErrorCallback callback,
 91237:                        void *userRef, const unsigned errorNumber,
     1:                        JSBool charArgs, va_list ap);
     1: 
     1: extern JSBool
     1: js_ExpandErrorArguments(JSContext *cx, JSErrorCallback callback,
 91237:                         void *userRef, const unsigned errorNumber,
     1:                         char **message, JSErrorReport *reportp,
 35302:                         bool charArgs, va_list ap);
     1: #endif
     1: 
 91659: namespace js {
 91659: 
 91659: /* |callee| requires a usage string provided by JS_DefineFunctionsWithHelp. */
 91659: extern void
 91659: ReportUsageError(JSContext *cx, JSObject *callee, const char *msg);
 91659: 
 91659: } /* namespace js */
 91659: 
 48619: extern void
 48619: js_ReportOutOfMemory(JSContext *cx);
 48619: 
 47574: extern JS_FRIEND_API(void)
 12983: js_ReportAllocationOverflow(JSContext *cx);
 12983: 
  8296: /*
     1:  * Report an exception using a previously composed JSErrorReport.
     1:  * XXXbe remove from "friend" API
     1:  */
     1: extern JS_FRIEND_API(void)
     1: js_ReportErrorAgain(JSContext *cx, const char *message, JSErrorReport *report);
     1: 
     1: extern void
     1: js_ReportIsNotDefined(JSContext *cx, const char *name);
     1: 
     1: /*
  7897:  * Report an attempt to access the property of a null or undefined value (v).
  7897:  */
  7897: extern JSBool
 91237: js_ReportIsNullOrUndefined(JSContext *cx, int spindex, const js::Value &v,
  7897:                            JSString *fallback);
  7897: 
 16519: extern void
 91237: js_ReportMissingArg(JSContext *cx, const js::Value &v, unsigned arg);
 16519: 
  7897: /*
     1:  * Report error using js_DecompileValueGenerator(cx, spindex, v, fallback) as
     1:  * the first argument for the error message. If the error message has less
     1:  * then 3 arguments, use null for arg1 or arg2.
     1:  */
     1: extern JSBool
 91237: js_ReportValueErrorFlags(JSContext *cx, unsigned flags, const unsigned errorNumber,
 91237:                          int spindex, const js::Value &v, JSString *fallback,
     1:                          const char *arg1, const char *arg2);
     1: 
     1: #define js_ReportValueError(cx,errorNumber,spindex,v,fallback)                \
     1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
     1:                                     spindex, v, fallback, NULL, NULL))
     1: 
     1: #define js_ReportValueError2(cx,errorNumber,spindex,v,fallback,arg1)          \
     1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
     1:                                     spindex, v, fallback, arg1, NULL))
     1: 
     1: #define js_ReportValueError3(cx,errorNumber,spindex,v,fallback,arg1,arg2)     \
     1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
     1:                                     spindex, v, fallback, arg1, arg2))
     1: 
     1: extern JSErrorFormatString js_ErrorFormatString[JSErr_Limit];
     1: 
 48541: #ifdef JS_THREADSAFE
 88135: # define JS_ASSERT_REQUEST_DEPTH(cx)  JS_ASSERT((cx)->runtime->requestDepth >= 1)
 48541: #else
 48541: # define JS_ASSERT_REQUEST_DEPTH(cx)  ((void) 0)
 48541: #endif
 48541: 
  9780: /*
 25087:  * Invoke the operation callback and return false if the current execution
 25087:  * is to be terminated.
     1:  */
     1: extern JSBool
 25087: js_InvokeOperationCallback(JSContext *cx);
 23726: 
 52753: extern JSBool
 52753: js_HandleExecutionInterrupt(JSContext *cx);
 52753: 
 26550: extern jsbytecode*
 26550: js_GetCurrentBytecodePC(JSContext* cx);
 26550: 
 73746: extern JSScript *
 73746: js_GetCurrentScript(JSContext* cx);
 73746: 
 95227: /*
 95227:  * If the operation callback flag was set, call the operation callback.
 95227:  * This macro can run the full GC. Return true if it is OK to continue and
 95227:  * false otherwise.
 95227:  */
 95227: static MOZ_ALWAYS_INLINE bool
 95227: JS_CHECK_OPERATION_LIMIT(JSContext *cx)
 95227: {
 95227:     JS_ASSERT_REQUEST_DEPTH(cx);
 95227:     return !cx->runtime->interrupt || js_InvokeOperationCallback(cx);
 95227: }
 95227: 
 37741: namespace js {
 37741: 
 77343: #ifdef JS_METHODJIT
 77343: namespace mjit {
 77398:     void ExpandInlineFrames(JSCompartment *compartment);
 77343: }
 77343: #endif
 77343: 
 37741: } /* namespace js */
 37741: 
 77398: /* How much expansion of inlined frames to do when inspecting the stack. */
 77398: enum FrameExpandKind {
 77398:     FRAME_EXPAND_NONE = 0,
 77398:     FRAME_EXPAND_ALL = 1
 77398: };
 77398: 
 34299: namespace js {
 34299: 
 79734: /************************************************************************/
 79734: 
 79734: static JS_ALWAYS_INLINE void
 80748: MakeRangeGCSafe(Value *vec, size_t len)
 80748: {
 80748:     PodZero(vec, len);
 80748: }
 80748: 
 80748: static JS_ALWAYS_INLINE void
 80748: MakeRangeGCSafe(Value *beg, Value *end)
 80748: {
 80748:     PodZero(beg, end - beg);
 80748: }
 80748: 
 80748: static JS_ALWAYS_INLINE void
 80748: MakeRangeGCSafe(jsid *beg, jsid *end)
 80748: {
 80748:     for (jsid *id = beg; id != end; ++id)
 80748:         *id = INT_TO_JSID(0);
 80748: }
 80748: 
 80748: static JS_ALWAYS_INLINE void
 80748: MakeRangeGCSafe(jsid *vec, size_t len)
 80748: {
 80748:     MakeRangeGCSafe(vec, vec + len);
 80748: }
 80748: 
 80748: static JS_ALWAYS_INLINE void
 79734: MakeRangeGCSafe(const Shape **beg, const Shape **end)
 79734: {
 79734:     PodZero(beg, end - beg);
 79734: }
 79734: 
 79734: static JS_ALWAYS_INLINE void
 79734: MakeRangeGCSafe(const Shape **vec, size_t len)
 79734: {
 79734:     PodZero(vec, len);
 79734: }
 79734: 
 79734: static JS_ALWAYS_INLINE void
 79734: SetValueRangeToUndefined(Value *beg, Value *end)
 79734: {
 79734:     for (Value *v = beg; v != end; ++v)
 79734:         v->setUndefined();
 79734: }
 79734: 
 79734: static JS_ALWAYS_INLINE void
 79734: SetValueRangeToUndefined(Value *vec, size_t len)
 79734: {
 79734:     SetValueRangeToUndefined(vec, vec + len);
 79734: }
 79734: 
 79734: static JS_ALWAYS_INLINE void
 79734: SetValueRangeToNull(Value *beg, Value *end)
 79734: {
 79734:     for (Value *v = beg; v != end; ++v)
 79734:         v->setNull();
 79734: }
 79734: 
 79734: static JS_ALWAYS_INLINE void
 79734: SetValueRangeToNull(Value *vec, size_t len)
 79734: {
 79734:     SetValueRangeToNull(vec, vec + len);
 79734: }
 79734: 
 80748: class AutoObjectVector : public AutoVectorRooter<JSObject *>
 80748: {
 80748:   public:
 80748:     explicit AutoObjectVector(JSContext *cx
 80748:                               JS_GUARD_OBJECT_NOTIFIER_PARAM)
 80748:         : AutoVectorRooter<JSObject *>(cx, OBJVECTOR)
 80748:     {
 80748:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 80748:     }
 80748: 
 80748:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 80748: };
 80748: 
 80744: class AutoShapeVector : public AutoVectorRooter<const Shape *>
 40418: {
 40418:   public:
 80744:     explicit AutoShapeVector(JSContext *cx
 40418:                              JS_GUARD_OBJECT_NOTIFIER_PARAM)
 80748:         : AutoVectorRooter<const Shape *>(cx, SHAPEVECTOR)
 77170:     {
 77170:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 77170:     }
 77170: 
 77170:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 48470: };
 48470: 
 77343: class AutoValueArray : public AutoGCRooter
 77343: {
 90302:     js::Value *start_;
 77343:     unsigned length_;
 97353:     SkipRoot skip;
 77343: 
 77343:   public:
 90302:     AutoValueArray(JSContext *cx, js::Value *start, unsigned length
 77343:                    JS_GUARD_OBJECT_NOTIFIER_PARAM)
 97353:       : AutoGCRooter(cx, VALARRAY), start_(start), length_(length), skip(cx, start, length)
 77343:     {
 77343:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 77343:     }
 77343: 
 90302:     Value *start() { return start_; }
 77343:     unsigned length() const { return length_; }
 77343: 
 77343:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 77343: };
 77343: 
 72092: /*
 72092:  * Allocation policy that uses JSRuntime::malloc_ and friends, so that
 72092:  * memory pressure is properly accounted for. This is suitable for
 72092:  * long-lived objects owned by the JSRuntime.
 72092:  *
 72092:  * Since it doesn't hold a JSContext (those may not live long enough), it
 72092:  * can't report out-of-memory conditions itself; the caller must check for
 72092:  * OOM and take the appropriate action.
 72092:  *
 72092:  * FIXME bug 647103 - replace these *AllocPolicy names.
 72092:  */
 72092: class RuntimeAllocPolicy
 72092: {
 72092:     JSRuntime *const runtime;
 72092: 
 72092:   public:
 72092:     RuntimeAllocPolicy(JSRuntime *rt) : runtime(rt) {}
 72092:     RuntimeAllocPolicy(JSContext *cx) : runtime(cx->runtime) {}
 72092:     void *malloc_(size_t bytes) { return runtime->malloc_(bytes); }
 72092:     void *realloc_(void *p, size_t bytes) { return runtime->realloc_(p, bytes); }
 72092:     void free_(void *p) { runtime->free_(p); }
 72092:     void reportAllocOverflow() const {}
 72092: };
 72092: 
 94705: /*
 94705:  * FIXME bug 647103 - replace these *AllocPolicy names.
 94705:  */
 94705: class ContextAllocPolicy
 94705: {
 94705:     JSContext *const cx;
 94705: 
 94705:   public:
 94705:     ContextAllocPolicy(JSContext *cx) : cx(cx) {}
 94705:     JSContext *context() const { return cx; }
 94705:     void *malloc_(size_t bytes) { return cx->malloc_(bytes); }
 94705:     void *realloc_(void *p, size_t oldBytes, size_t bytes) { return cx->realloc_(p, oldBytes, bytes); }
 94705:     void free_(void *p) { cx->free_(p); }
 94705:     void reportAllocOverflow() const { js_ReportAllocationOverflow(cx); }
 94705: };
 94705: 
 48470: } /* namespace js */
 48470: 
 39928: #ifdef _MSC_VER
 39928: #pragma warning(pop)
 39928: #pragma warning(pop)
 39928: #endif
 39928: 
     1: #endif /* jscntxt_h___ */
