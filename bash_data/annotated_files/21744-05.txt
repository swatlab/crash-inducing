    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsscope_h___
    1: #define jsscope_h___
    1: /*
    1:  * JS symbol tables.
    1:  */
    1: #include "jstypes.h"
11377: #include "jslock.h"
    1: #include "jsobj.h"
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
    1: 
 3164: JS_BEGIN_EXTERN_C
 3164: 
    1: /*
    1:  * Given P independent, non-unique properties each of size S words mapped by
    1:  * all scopes in a runtime, construct a property tree of N nodes each of size
    1:  * S+L words (L for tree linkage).  A nominal L value is 2 for leftmost-child
    1:  * and right-sibling links.  We hope that the N < P by enough that the space
    1:  * overhead of L, and the overhead of scope entries pointing at property tree
    1:  * nodes, is worth it.
    1:  *
    1:  * The tree construction goes as follows.  If any empty scope in the runtime
    1:  * has a property X added to it, find or create a node under the tree root
    1:  * labeled X, and set scope->lastProp to point at that node.  If any non-empty
    1:  * scope whose most recently added property is labeled Y has another property
    1:  * labeled Z added, find or create a node for Z under the node that was added
    1:  * for Y, and set scope->lastProp to point at that node.
    1:  *
    1:  * A property is labeled by its members' values: id, getter, setter, slot,
    1:  * attributes, tiny or short id, and a field telling for..in order.  Note that
    1:  * labels are not unique in the tree, but they are unique among a node's kids
    1:  * (barring rare and benign multi-threaded race condition outcomes, see below)
    1:  * and along any ancestor line from the tree root to a given leaf node (except
    1:  * for the hard case of duplicate formal parameters to a function).
    1:  *
    1:  * Thus the root of the tree represents all empty scopes, and the first ply
    1:  * of the tree represents all scopes containing one property, etc.  Each node
    1:  * in the tree can stand for any number of scopes having the same ordered set
    1:  * of properties, where that node was the last added to the scope.  (We need
    1:  * not store the root of the tree as a node, and do not -- all we need are
    1:  * links to its kids.)
    1:  *
    1:  * Sidebar on for..in loop order: ECMA requires no particular order, but this
    1:  * implementation has promised and delivered property definition order, and
    1:  * compatibility is king.  We could use an order number per property, which
    1:  * would require a sort in js_Enumerate, and an entry order generation number
    1:  * per scope.  An order number beats a list, which should be doubly-linked for
    1:  * O(1) delete.  An even better scheme is to use a parent link in the property
    1:  * tree, so that the ancestor line can be iterated from scope->lastProp when
    1:  * filling in a JSIdArray from back to front.  This parent link also helps the
    1:  * GC to sweep properties iteratively.
    1:  *
    1:  * What if a property Y is deleted from a scope?  If Y is the last property in
    1:  * the scope, we simply adjust the scope's lastProp member after we remove the
    1:  * scope's hash-table entry pointing at that property node.  The parent link
    1:  * mentioned in the for..in sidebar above makes this adjustment O(1).  But if
    1:  * Y comes between X and Z in the scope, then we might have to "fork" the tree
    1:  * at X, leaving X->Y->Z in case other scopes have those properties added in
    1:  * that order; and to finish the fork, we'd add a node labeled Z with the path
    1:  * X->Z, if it doesn't exist.  This could lead to lots of extra nodes, and to
    1:  * O(n^2) growth when deleting lots of properties.
    1:  *
    1:  * Rather, for O(1) growth all around, we should share the path X->Y->Z among
    1:  * scopes having those three properties added in that order, and among scopes
    1:  * having only X->Z where Y was deleted.  All such scopes have a lastProp that
    1:  * points to the Z child of Y.  But a scope in which Y was deleted does not
    1:  * have a table entry for Y, and when iterating that scope by traversing the
    1:  * ancestor line from Z, we will have to test for a table entry for each node,
    1:  * skipping nodes that lack entries.
    1:  *
    1:  * What if we add Y again?  X->Y->Z->Y is wrong and we'll enumerate Y twice.
    1:  * Therefore we must fork in such a case, if not earlier.  Because delete is
    1:  * "bursty", we should not fork eagerly.  Delaying a fork till we are at risk
    1:  * of adding Y after it was deleted already requires a flag in the JSScope, to
    1:  * wit, SCOPE_MIDDLE_DELETE.
    1:  *
    1:  * What about thread safety?  If the property tree operations done by requests
    1:  * are find-node and insert-node, then the only hazard is duplicate insertion.
    1:  * This is harmless except for minor bloat.  When all requests have ended or
    1:  * been suspended, the GC is free to sweep the tree after marking all nodes
 3046:  * reachable from scopes, performing remove-node operations as needed.
    1:  *
    1:  * Is the property tree worth it compared to property storage in each table's
    1:  * entries?  To decide, we must find the relation <> between the words used
    1:  * with a property tree and the words required without a tree.
    1:  *
    1:  * Model all scopes as one super-scope of capacity T entries (T a power of 2).
    1:  * Let alpha be the load factor of this double hash-table.  With the property
    1:  * tree, each entry in the table is a word-sized pointer to a node that can be
    1:  * shared by many scopes.  But all such pointers are overhead compared to the
    1:  * situation without the property tree, where the table stores property nodes
    1:  * directly, as entries each of size S words.  With the property tree, we need
    1:  * L=2 extra words per node for siblings and kids pointers.  Without the tree,
    1:  * (1-alpha)*S*T words are wasted on free or removed sentinel-entries required
    1:  * by double hashing.
    1:  *
    1:  * Therefore,
    1:  *
    1:  *      (property tree)                 <> (no property tree)
    1:  *      N*(S+L) + T                     <> S*T
    1:  *      N*(S+L) + T                     <> P*S + (1-alpha)*S*T
    1:  *      N*(S+L) + alpha*T + (1-alpha)*T <> P*S + (1-alpha)*S*T
    1:  *
    1:  * Note that P is alpha*T by definition, so
    1:  *
    1:  *      N*(S+L) + P + (1-alpha)*T <> P*S + (1-alpha)*S*T
    1:  *      N*(S+L)                   <> P*S - P + (1-alpha)*S*T - (1-alpha)*T
    1:  *      N*(S+L)                   <> (P + (1-alpha)*T) * (S-1)
    1:  *      N*(S+L)                   <> (P + (1-alpha)*P/alpha) * (S-1)
    1:  *      N*(S+L)                   <> P * (1/alpha) * (S-1)
    1:  *
    1:  * Let N = P*beta for a compression ratio beta, beta <= 1:
    1:  *
    1:  *      P*beta*(S+L) <> P * (1/alpha) * (S-1)
    1:  *      beta*(S+L)   <> (S-1)/alpha
    1:  *      beta         <> (S-1)/((S+L)*alpha)
    1:  *
    1:  * For S = 6 (32-bit architectures) and L = 2, the property tree wins iff
    1:  *
    1:  *      beta < 5/(8*alpha)
    1:  *
    1:  * We ensure that alpha <= .75, so the property tree wins if beta < .83_.  An
    1:  * average beta from recent Mozilla browser startups was around .6.
    1:  *
    1:  * Can we reduce L?  Observe that the property tree degenerates into a list of
    1:  * lists if at most one property Y follows X in all scopes.  In or near such a
    1:  * case, we waste a word on the right-sibling link outside of the root ply of
    1:  * the tree.  Note also that the root ply tends to be large, so O(n^2) growth
    1:  * searching it is likely, indicating the need for hashing (but with increased
    1:  * thread safety costs).
    1:  *
    1:  * If only K out of N nodes in the property tree have more than one child, we
    1:  * could eliminate the sibling link and overlay a children list or hash-table
    1:  * pointer on the leftmost-child link (which would then be either null or an
    1:  * only-child link; the overlay could be tagged in the low bit of the pointer,
    1:  * or flagged elsewhere in the property tree node, although such a flag must
    1:  * not be considered when comparing node labels during tree search).
    1:  *
    1:  * For such a system, L = 1 + (K * averageChildrenTableSize) / N instead of 2.
    1:  * If K << N, L approaches 1 and the property tree wins if beta < .95.
    1:  *
    1:  * We observe that fan-out below the root ply of the property tree appears to
    1:  * have extremely low degree (see the MeterPropertyTree code that histograms
    1:  * child-counts in jsscope.c), so instead of a hash-table we use a linked list
    1:  * of child node pointer arrays ("kid chunks").  The details are isolated in
    1:  * jsscope.c; others must treat JSScopeProperty.kids as opaque.  We leave it
    1:  * strongly typed for debug-ability of the common (null or one-kid) cases.
    1:  *
    1:  * One final twist (can you stand it?): the mean number of entries per scope
    1:  * in Mozilla is < 5, with a large standard deviation (~8).  Instead of always
    1:  * allocating scope->table, we leave it null while initializing all the other
    1:  * scope members as if it were non-null and minimal-length.  Until a property
    1:  * is added that crosses the threshold of 6 or more entries for hashing, or
    1:  * until a "middle delete" occurs, we use linear search from scope->lastProp
    1:  * to find a given id, and save on the space overhead of a hash table.
    1:  */
    1: 
    1: struct JSScope {
    1:     JSObjectMap     map;                /* base class state */
11739: #ifdef JS_THREADSAFE
11739:     JSTitle         title;              /* lock state */
11739: #endif
    1:     JSObject        *object;            /* object that owns this scope */
11377:     uint32          shape;              /* property cache shape identifier */
    1:     uint8           flags;              /* flags, see below */
    1:     int8            hashShift;          /* multiplicative hash shift */
    1:     uint16          spare;              /* reserved */
    1:     uint32          entryCount;         /* number of entries in table */
    1:     uint32          removedCount;       /* removed entry sentinels in table */
    1:     JSScopeProperty **table;            /* table of ptrs to shared tree nodes */
    1:     JSScopeProperty *lastProp;          /* pointer to last property added */
11739: };
11739: 
    1: #ifdef JS_THREADSAFE
11739: JS_STATIC_ASSERT(offsetof(JSScope, title) == sizeof(JSObjectMap));
    1: #endif
11739: 
11739: #define JS_IS_SCOPE_LOCKED(cx, scope)   JS_IS_TITLE_LOCKED(cx, &(scope)->title)
    1: 
    1: #define OBJ_SCOPE(obj)                  ((JSScope *)(obj)->map)
19020: #define OBJ_SHAPE(obj)                  (OBJ_SCOPE(obj)->shape)
12307: 
12307: #define SCOPE_MAKE_UNIQUE_SHAPE(cx,scope)                                     \
21744:     ((scope)->shape = js_GenerateShape((cx), JS_FALSE, NULL))
12307: 
12307: #define SCOPE_EXTEND_SHAPE(cx,scope,sprop)                                    \
12307:     JS_BEGIN_MACRO                                                            \
12307:         if (!(scope)->lastProp ||                                             \
12307:             (scope)->shape == (scope)->lastProp->shape) {                     \
12307:             (scope)->shape = (sprop)->shape;                                  \
12307:         } else {                                                              \
21744:             (scope)->shape = js_GenerateShape((cx), JS_FALSE, sprop);         \
12307:         }                                                                     \
12307:     JS_END_MACRO
    1: 
    1: /* By definition, hashShift = JS_DHASH_BITS - log2(capacity). */
    1: #define SCOPE_CAPACITY(scope)           JS_BIT(JS_DHASH_BITS-(scope)->hashShift)
    1: 
    1: /* Scope flags and some macros to hide them from other files than jsscope.c. */
    1: #define SCOPE_MIDDLE_DELETE             0x0001
    1: #define SCOPE_SEALED                    0x0002
11377: #define SCOPE_BRANDED                   0x0004
    1: 
    1: #define SCOPE_HAD_MIDDLE_DELETE(scope)  ((scope)->flags & SCOPE_MIDDLE_DELETE)
    1: #define SCOPE_SET_MIDDLE_DELETE(scope)  ((scope)->flags |= SCOPE_MIDDLE_DELETE)
    1: #define SCOPE_CLR_MIDDLE_DELETE(scope)  ((scope)->flags &= ~SCOPE_MIDDLE_DELETE)
    1: 
    1: #define SCOPE_IS_SEALED(scope)          ((scope)->flags & SCOPE_SEALED)
    1: #define SCOPE_SET_SEALED(scope)         ((scope)->flags |= SCOPE_SEALED)
    1: #if 0
    1: /*
    1:  * Don't define this, it can't be done safely because JS_LOCK_OBJ will avoid
    1:  * taking the lock if the object owns its scope and the scope is sealed.
    1:  */
11377: #undef  SCOPE_CLR_SEALED(scope)         ((scope)->flags &= ~SCOPE_SEALED)
    1: #endif
    1: 
    1: /*
11377:  * A branded scope's object contains plain old methods (function-valued
11377:  * properties without magic getters and setters), and its scope->shape
11377:  * evolves whenever a function value changes.
11377:  */
11377: #define SCOPE_IS_BRANDED(scope)         ((scope)->flags & SCOPE_BRANDED)
11377: #define SCOPE_SET_BRANDED(scope)        ((scope)->flags |= SCOPE_BRANDED)
11377: #define SCOPE_CLR_BRANDED(scope)        ((scope)->flags &= ~SCOPE_BRANDED)
11377: 
11377: /*
    1:  * A little information hiding for scope->lastProp, in case it ever becomes
    1:  * a tagged pointer again.
    1:  */
    1: #define SCOPE_LAST_PROP(scope)          ((scope)->lastProp)
    1: #define SCOPE_REMOVE_LAST_PROP(scope)   ((scope)->lastProp =                  \
    1:                                          (scope)->lastProp->parent)
    1: 
    1: struct JSScopeProperty {
    1:     jsid            id;                 /* int-tagged jsval/untagged JSAtom* */
    1:     JSPropertyOp    getter;             /* getter and setter hooks or objects */
    1:     JSPropertyOp    setter;
    1:     uint32          slot;               /* abstract index in object slots */
    1:     uint8           attrs;              /* attributes, see jsapi.h JSPROP_* */
    1:     uint8           flags;              /* flags, see below for defines */
    1:     int16           shortid;            /* tinyid, or local arg/var index */
    1:     JSScopeProperty *parent;            /* parent node, reverse for..in order */
    1:     JSScopeProperty *kids;              /* null, single child, or a tagged ptr
    1:                                            to many-kids data structure */
11377:     uint32          shape;              /* property cache shape identifier */
    1: };
    1: 
    1: /* JSScopeProperty pointer tag bit indicating a collision. */
    1: #define SPROP_COLLISION                 ((jsuword)1)
    1: #define SPROP_REMOVED                   ((JSScopeProperty *) SPROP_COLLISION)
    1: 
    1: /* Macros to get and set sprop pointer values and collision flags. */
    1: #define SPROP_IS_FREE(sprop)            ((sprop) == NULL)
    1: #define SPROP_IS_REMOVED(sprop)         ((sprop) == SPROP_REMOVED)
    1: #define SPROP_IS_LIVE(sprop)            ((sprop) > SPROP_REMOVED)
    1: #define SPROP_FLAG_COLLISION(spp,sprop) (*(spp) = (JSScopeProperty *)         \
    1:                                          ((jsuword)(sprop) | SPROP_COLLISION))
    1: #define SPROP_HAD_COLLISION(sprop)      ((jsuword)(sprop) & SPROP_COLLISION)
    1: #define SPROP_FETCH(spp)                SPROP_CLEAR_COLLISION(*(spp))
    1: 
    1: #define SPROP_CLEAR_COLLISION(sprop)                                          \
    1:     ((JSScopeProperty *) ((jsuword)(sprop) & ~SPROP_COLLISION))
    1: 
    1: #define SPROP_STORE_PRESERVING_COLLISION(spp, sprop)                          \
    1:     (*(spp) = (JSScopeProperty *) ((jsuword)(sprop)                           \
    1:                                    | SPROP_HAD_COLLISION(*(spp))))
    1: 
    1: /* Bits stored in sprop->flags. */
    1: #define SPROP_MARK                      0x01
 8367: #define SPROP_IS_ALIAS                  0x02
 8367: #define SPROP_HAS_SHORTID               0x04
11377: #define SPROP_FLAG_SHAPE_REGEN          0x08
    1: 
    1: /*
    1:  * If SPROP_HAS_SHORTID is set in sprop->flags, we use sprop->shortid rather
    1:  * than id when calling sprop's getter or setter.
    1:  */
    1: #define SPROP_USERID(sprop)                                                   \
    1:     (((sprop)->flags & SPROP_HAS_SHORTID) ? INT_TO_JSVAL((sprop)->shortid)    \
    1:                                           : ID_TO_VALUE((sprop)->id))
    1: 
    1: #define SPROP_INVALID_SLOT              0xffffffff
    1: 
    1: #define SLOT_IN_SCOPE(slot,scope)         ((slot) < (scope)->map.freeslot)
    1: #define SPROP_HAS_VALID_SLOT(sprop,scope) SLOT_IN_SCOPE((sprop)->slot, scope)
    1: 
    1: #define SPROP_HAS_STUB_GETTER(sprop)    (!(sprop)->getter)
    1: #define SPROP_HAS_STUB_SETTER(sprop)    (!(sprop)->setter)
    1: 
    1: /*
    1:  * NB: SPROP_GET must not be called if SPROP_HAS_STUB_GETTER(sprop).
    1:  */
    1: #define SPROP_GET(cx,sprop,obj,obj2,vp)                                       \
    1:     (((sprop)->attrs & JSPROP_GETTER)                                         \
    1:      ? js_InternalGetOrSet(cx, obj, (sprop)->id,                              \
    1:                            OBJECT_TO_JSVAL((sprop)->getter), JSACC_READ,      \
    1:                            0, 0, vp)                                          \
    1:      : (sprop)->getter(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
    1: 
    1: /*
    1:  * NB: SPROP_SET must not be called if (SPROP_HAS_STUB_SETTER(sprop) &&
    1:  * !(sprop->attrs & JSPROP_GETTER)).
    1:  */
    1: #define SPROP_SET(cx,sprop,obj,obj2,vp)                                       \
    1:     (((sprop)->attrs & JSPROP_SETTER)                                         \
    1:      ? js_InternalGetOrSet(cx, obj, (sprop)->id,                              \
    1:                            OBJECT_TO_JSVAL((sprop)->setter), JSACC_WRITE,     \
    1:                            1, vp, vp)                                         \
    1:      : ((sprop)->attrs & JSPROP_GETTER)                                       \
    1:      ? (JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,                    \
    1:                              JSMSG_GETTER_ONLY, NULL), JS_FALSE)              \
    1:      : (sprop)->setter(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
    1: 
    1: /* Macro for common expression to test for shared permanent attributes. */
    1: #define SPROP_IS_SHARED_PERMANENT(sprop)                                      \
    1:     ((~(sprop)->attrs & (JSPROP_SHARED | JSPROP_PERMANENT)) == 0)
    1: 
    1: extern JSScope *
    1: js_GetMutableScope(JSContext *cx, JSObject *obj);
    1: 
    1: extern JSScope *
    1: js_NewScope(JSContext *cx, jsrefcount nrefs, JSObjectOps *ops, JSClass *clasp,
    1:             JSObject *obj);
    1: 
    1: extern void
    1: js_DestroyScope(JSContext *cx, JSScope *scope);
    1: 
    1: extern JS_FRIEND_API(JSScopeProperty **)
    1: js_SearchScope(JSScope *scope, jsid id, JSBool adding);
    1: 
    1: #define SCOPE_GET_PROPERTY(scope, id)                                         \
    1:     SPROP_FETCH(js_SearchScope(scope, id, JS_FALSE))
    1: 
    1: #define SCOPE_HAS_PROPERTY(scope, sprop)                                      \
    1:     (SCOPE_GET_PROPERTY(scope, (sprop)->id) == (sprop))
    1: 
    1: extern JSScopeProperty *
    1: js_AddScopeProperty(JSContext *cx, JSScope *scope, jsid id,
    1:                     JSPropertyOp getter, JSPropertyOp setter, uint32 slot,
    1:                     uintN attrs, uintN flags, intN shortid);
    1: 
    1: extern JSScopeProperty *
    1: js_ChangeScopePropertyAttrs(JSContext *cx, JSScope *scope,
    1:                             JSScopeProperty *sprop, uintN attrs, uintN mask,
    1:                             JSPropertyOp getter, JSPropertyOp setter);
    1: 
    1: extern JSBool
    1: js_RemoveScopeProperty(JSContext *cx, JSScope *scope, jsid id);
    1: 
    1: extern void
    1: js_ClearScope(JSContext *cx, JSScope *scope);
    1: 
    1: /*
    1:  * These macros used to inline short code sequences, but they grew over time.
    1:  * We retain them for internal backward compatibility, and in case one or both
    1:  * ever shrink to inline-able size.
    1:  */
  583: #define TRACE_ID(trc, id)                js_TraceId(trc, id)
  583: #define TRACE_SCOPE_PROPERTY(trc, sprop) js_TraceScopeProperty(trc, sprop)
    1: 
    1: extern void
  583: js_TraceId(JSTracer *trc, jsid id);
    1: 
    1: extern void
  583: js_TraceScopeProperty(JSTracer *trc, JSScopeProperty *sprop);
    1: 
    1: extern void
    1: js_SweepScopeProperties(JSContext *cx);
    1: 
    1: extern JSBool
    1: js_InitPropertyTree(JSRuntime *rt);
    1: 
    1: extern void
    1: js_FinishPropertyTree(JSRuntime *rt);
    1: 
 3164: JS_END_EXTERN_C
 3164: 
    1: #endif /* jsscope_h___ */
