43066: /* -*- Mode: c++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 4; -*- */
43066: /* ***** BEGIN LICENSE BLOCK *****
43066:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43066:  *
43066:  * The contents of this file are subject to the Mozilla Public License Version
43066:  * 1.1 (the "License"); you may not use this file except in compliance with
43066:  * the License. You may obtain a copy of the License at
43066:  * http://www.mozilla.org/MPL/
43066:  *
43066:  * Software distributed under the License is distributed on an "AS IS" basis,
43066:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43066:  * for the specific language governing rights and limitations under the
43066:  * License.
43066:  *
43066:  * The Original Code is mozilla.org code.
43066:  *
43066:  * The Initial Developer of the Original Code is
43066:  *   Mozilla Foundation
43066:  * Portions created by the Initial Developer are Copyright (C) 2009-2010
43066:  * the Initial Developer. All Rights Reserved.
43066:  *
43066:  * Contributor(s):
43066:  *   Vladimir Vukicevic <vladimir@pobox.com>
43066:  *
43066:  * Alternatively, the contents of this file may be used under the terms of
43066:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43066:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43066:  * in which case the provisions of the GPL or the LGPL are applicable instead
43066:  * of those above. If you wish to allow use of your version of this file only
43066:  * under the terms of either the GPL or the LGPL, and not to allow others to
43066:  * use your version of this file under the terms of the MPL, indicate your
43066:  * decision by deleting the provisions above and replace them with the notice
43066:  * and other provisions required by the GPL or the LGPL. If you do not delete
43066:  * the provisions above, a recipient may use your version of this file under
43066:  * the terms of any one of the MPL, the GPL or the LGPL.
43066:  *
43066:  * ***** END LICENSE BLOCK ***** */
43066: 
89487: // Make sure the order of included headers
89487: #include "base/basictypes.h"
89487: #include "nspr/prtypes.h"
89487: 
87563: #include "mozilla/Hal.h"
43066: #include "nsAppShell.h"
43066: #include "nsWindow.h"
43066: #include "nsThreadUtils.h"
43811: #include "nsICommandLineRunner.h"
43066: #include "nsIObserverService.h"
43066: #include "nsIAppStartup.h"
43107: #include "nsIGeolocationProvider.h"
95624: #include "nsCacheService.h"
43066: 
43741: #include "mozilla/Services.h"
62359: #include "mozilla/unused.h"
71384: #include "mozilla/Preferences.h"
89487: #include "mozilla/Hal.h"
43066: #include "prenv.h"
43066: 
43066: #include "AndroidBridge.h"
43066: #include <android/log.h>
43066: #include <pthread.h>
63152: #include <wchar.h>
43066: 
93582: #include "mozilla/dom/ScreenOrientation.h"
93582: 
87005: #ifdef MOZ_ANDROID_HISTORY
87005: #include "nsAndroidHistory.h"
87005: #endif
87005: 
43066: #ifdef MOZ_LOGGING
43066: #define FORCE_PR_LOG
43066: #include "prlog.h"
43066: #endif
43066: 
77669: #ifdef DEBUG_ANDROID_EVENTS
43066: #define EVLOG(args...)  ALOG(args)
43066: #else
43066: #define EVLOG(args...) do { } while (0)
43066: #endif
43066: 
43066: using namespace mozilla;
43066: 
43066: #ifdef PR_LOGGING
43066: PRLogModuleInfo *gWidgetLog = nsnull;
43066: #endif
43066: 
43107: nsIGeolocationUpdate *gLocationCallback = nsnull;
76830: nsAutoPtr<mozilla::AndroidGeckoEvent> gLastSizeChange;
43066: 
43066: nsAppShell *nsAppShell::gAppShell = nsnull;
43066: 
60299: NS_IMPL_ISUPPORTS_INHERITED1(nsAppShell, nsBaseAppShell, nsIObserver)
60299: 
43066: nsAppShell::nsAppShell()
64576:     : mQueueLock("nsAppShell.mQueueLock"),
64576:       mCondLock("nsAppShell.mCondLock"),
64576:       mQueueCond(mCondLock, "nsAppShell.mQueueCond"),
94962:       mQueuedDrawEvent(nsnull),
95053:       mQueuedViewportEvent(nsnull),
95053:       mAllowCoalescingNextDraw(false)
43066: {
43066:     gAppShell = this;
43066: }
43066: 
43066: nsAppShell::~nsAppShell()
43066: {
43066:     gAppShell = nsnull;
43066: }
43066: 
43066: void
43066: nsAppShell::NotifyNativeEvent()
43066: {
64576:     MutexAutoLock lock(mCondLock);
64576:     mQueueCond.Notify();
43066: }
43066: 
71384: #define PREFNAME_MATCH_OS  "intl.locale.matchOS"
71384: #define PREFNAME_UA_LOCALE "general.useragent.locale"
71384: static const char* kObservedPrefs[] = {
71384:   PREFNAME_MATCH_OS,
71384:   PREFNAME_UA_LOCALE,
71384:   nsnull
71384: };
71384: 
43066: nsresult
43066: nsAppShell::Init()
43066: {
43066: #ifdef PR_LOGGING
43066:     if (!gWidgetLog)
43066:         gWidgetLog = PR_NewLogModule("Widget");
43066: #endif
43066: 
51723:     mObserversHash.Init();
51723: 
56483:     nsresult rv = nsBaseAppShell::Init();
63152:     AndroidBridge* bridge = AndroidBridge::Bridge();
60299: 
60299:     nsCOMPtr<nsIObserverService> obsServ =
60299:         mozilla::services::GetObserverService();
60299:     if (obsServ) {
80486:         obsServ->AddObserver(this, "xpcom-shutdown", false);
60299:     }
63152: 
63152:     if (!bridge)
63152:         return rv;
63152: 
71384:     Preferences::AddStrongObservers(this, kObservedPrefs);
63430: 
79445:     bool match;
71384:     rv = Preferences::GetBool(PREFNAME_MATCH_OS, &match);
63430:     NS_ENSURE_SUCCESS(rv, rv);
63430: 
63430:     if (match) {
63430:         bridge->SetSelectedLocale(EmptyString());
63430:         return NS_OK;
63430:     }
71384: 
71384:     nsAutoString locale;
71384:     rv = Preferences::GetLocalizedString(PREFNAME_UA_LOCALE, &locale);
71384:     if (NS_FAILED(rv)) {
71384:         rv = Preferences::GetString(PREFNAME_UA_LOCALE, &locale);
63430:     }
63430: 
63152:     bridge->SetSelectedLocale(locale);
56483:     return rv;
43066: }
43066: 
60299: NS_IMETHODIMP
60299: nsAppShell::Observe(nsISupports* aSubject,
60299:                     const char* aTopic,
60299:                     const PRUnichar* aData)
60299: {
60299:     if (!strcmp(aTopic, "xpcom-shutdown")) {
60299:         // We need to ensure no observers stick around after XPCOM shuts down
60299:         // or we'll see crashes, as the app shell outlives XPConnect.
60299:         mObserversHash.Clear();
63406:         return nsBaseAppShell::Observe(aSubject, aTopic, aData);
63430:     } else if (!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID) && aData && (
63430:                    nsDependentString(aData).Equals(
71384:                        NS_LITERAL_STRING(PREFNAME_UA_LOCALE)) ||
63430:                    nsDependentString(aData).Equals(
71384:                        NS_LITERAL_STRING(PREFNAME_MATCH_OS)))) {
63152:         AndroidBridge* bridge = AndroidBridge::Bridge();
71384:         if (!bridge) {
63152:             return NS_OK;
71384:         }
63430: 
79445:         bool match;
71384:         nsresult rv = Preferences::GetBool(PREFNAME_MATCH_OS, &match);
63430:         NS_ENSURE_SUCCESS(rv, rv);
63152: 
63430:         if (match) {
63430:             bridge->SetSelectedLocale(EmptyString());
63430:             return NS_OK;
63430:         }
71384: 
71384:         nsAutoString locale;
71384:         if (NS_FAILED(Preferences::GetLocalizedString(PREFNAME_UA_LOCALE,
71384:                                                       &locale))) {
71384:             locale = Preferences::GetString(PREFNAME_UA_LOCALE);
63430:         }
63430: 
63152:         bridge->SetSelectedLocale(locale);
63152:         return NS_OK;
60299:     }
63406:     return NS_OK;
60299: }
43066: 
43066: void
43066: nsAppShell::ScheduleNativeEventCallback()
43066: {
43066:     EVLOG("nsAppShell::ScheduleNativeEventCallback pth: %p thread: %p main: %d", (void*) pthread_self(), (void*) NS_GetCurrentThread(), NS_IsMainThread());
43066: 
43066:     // this is valid to be called from any thread, so do so.
43066:     PostEvent(new AndroidGeckoEvent(AndroidGeckoEvent::NATIVE_POKE));
43066: }
43066: 
79445: bool
79445: nsAppShell::ProcessNextNativeEvent(bool mayWait)
43066: {
43066:     EVLOG("nsAppShell::ProcessNextNativeEvent %d", mayWait);
43066: 
43066:     nsAutoPtr<AndroidGeckoEvent> curEvent;
64576:     {
64576:         MutexAutoLock lock(mCondLock);
43066: 
83987:         curEvent = PopNextEvent();
43066:         if (!curEvent && mayWait) {
43066:             // hmm, should we really hardcode this 10s?
77669: #if defined(DEBUG_ANDROID_EVENTS)
43066:             PRTime t0, t1;
43066:             EVLOG("nsAppShell: waiting on mQueueCond");
43066:             t0 = PR_Now();
43066: 
64576:             mQueueCond.Wait(PR_MillisecondsToInterval(10000));
43066:             t1 = PR_Now();
43066:             EVLOG("nsAppShell: wait done, waited %d ms", (int)(t1-t0)/1000);
43066: #else
64576:             mQueueCond.Wait();
43066: #endif
43066: 
83987:             curEvent = PopNextEvent();
43066:         }
64576:     }
43066: 
43066:     if (!curEvent)
43066:         return false;
43066: 
94962:     EVLOG("nsAppShell: event %p %d", (void*)curEvent.get(), curEvent->Type());
43066: 
43066:     switch (curEvent->Type()) {
43066:     case AndroidGeckoEvent::NATIVE_POKE:
43066:         NativeEventCallback();
43066:         break;
43066: 
93670:     case AndroidGeckoEvent::SENSOR_EVENT:
93670:       {
93670:         InfallibleTArray<float> values;
93670:         mozilla::hal::SensorType type = (mozilla::hal::SensorType) curEvent->Flags();
93637: 
93670:         switch (type) {
92736:           case hal::SENSOR_ORIENTATION:
94770:           case hal::SENSOR_LINEAR_ACCELERATION:
94770:           case hal::SENSOR_ACCELERATION:
94770:           case hal::SENSOR_GYROSCOPE:
93670:             values.AppendElement(curEvent->X());
93670:             values.AppendElement(curEvent->Y()); 
93670:             values.AppendElement(curEvent->Z());
93626:             break;
93626: 
93673:         case hal::SENSOR_PROXIMITY:
93673:             values.AppendElement(curEvent->X());
93673:             break;
93673: 
92736:         default:
93670:             __android_log_print(ANDROID_LOG_ERROR,
93670:                                 "Gecko", "### SENSOR_EVENT fired, but type wasn't known %d",
93670:                                 type);
93670:         }
93670: 
93670:         const hal::SensorAccuracyType &accuracy = (hal::SensorAccuracyType) curEvent->MetaState();
93670:         hal::SensorData sdata(type, PR_Now(), values, accuracy);
93670:         hal::NotifySensorChange(sdata);
92736:       }
43066:       break;
43066: 
63550:     case AndroidGeckoEvent::LOCATION_EVENT: {
43107:         if (!gLocationCallback)
43107:             break;
43107: 
63550:         nsGeoPosition* p = curEvent->GeoPosition();
92732:         if (p)
43107:             gLocationCallback->Update(curEvent->GeoPosition());
43107:         else
43107:             NS_WARNING("Received location event without geoposition!");
43107:         break;
63550:     }
43107: 
61773:     case AndroidGeckoEvent::ACTIVITY_STOPPING: {
90194:         if (curEvent->Flags() > 0)
90194:             break;
90194: 
61773:         nsCOMPtr<nsIObserverService> obsServ =
61773:             mozilla::services::GetObserverService();
61773:         NS_NAMED_LITERAL_STRING(minimize, "heap-minimize");
61773:         obsServ->NotifyObservers(nsnull, "memory-pressure", minimize.get());
76942:         obsServ->NotifyObservers(nsnull, "application-background", nsnull);
61773: 
61773:         break;
61773:     }
61773: 
59122:     case AndroidGeckoEvent::ACTIVITY_SHUTDOWN: {
43741:         nsCOMPtr<nsIObserverService> obsServ =
43741:             mozilla::services::GetObserverService();
43741:         NS_NAMED_LITERAL_STRING(context, "shutdown-persist");
43741:         obsServ->NotifyObservers(nsnull, "quit-application-granted", nsnull);
43741:         obsServ->NotifyObservers(nsnull, "quit-application-forced", nsnull);
43741:         obsServ->NotifyObservers(nsnull, "profile-change-net-teardown", context.get());
43741:         obsServ->NotifyObservers(nsnull, "profile-change-teardown", context.get());
43741:         obsServ->NotifyObservers(nsnull, "profile-before-change", context.get());
43066:         nsCOMPtr<nsIAppStartup> appSvc = do_GetService("@mozilla.org/toolkit/app-startup;1");
43066:         if (appSvc)
43066:             appSvc->Quit(nsIAppStartup::eForceQuit);
43066:         break;
43066:     }
43066: 
43741:     case AndroidGeckoEvent::ACTIVITY_PAUSING: {
90194:         if (curEvent->Flags() == 0) {
90194:             // We aren't transferring to one of our own activities, so set
90194:             // background status
90194:             nsCOMPtr<nsIObserverService> obsServ =
90194:                 mozilla::services::GetObserverService();
90194:             obsServ->NotifyObservers(nsnull, "application-background", nsnull);
95624: 
95624:             // If we are OOM killed with the disk cache enabled, the entire
95624:             // cache will be cleared (bug 105843), so shut down the cache here
95624:             // and re-init on resume
95667:             if (nsCacheService::GlobalInstance())
95624:                 nsCacheService::GlobalInstance()->Shutdown();
90194:         }
90194: 
44157:         // We really want to send a notification like profile-before-change,
44157:         // but profile-before-change ends up shutting some things down instead
44157:         // of flushing data
71384:         nsIPrefService* prefs = Preferences::GetService();
71384:         if (prefs) {
88471:             // reset the crash loop state
88471:             nsCOMPtr<nsIPrefBranch> prefBranch;
88471:             prefs->GetBranch("browser.sessionstore.", getter_AddRefs(prefBranch));
88471:             if (prefBranch)
88471:                 prefBranch->SetIntPref("recent_crashes", 0);
88471: 
44157:             prefs->SavePrefFile(nsnull);
71384:         }
44134: 
43741:         break;
43741:     }
43741: 
76942:     case AndroidGeckoEvent::ACTIVITY_START: {
90194:         if (curEvent->Flags() > 0)
90194:             break;
90194: 
76942:         nsCOMPtr<nsIObserverService> obsServ =
76942:             mozilla::services::GetObserverService();
76942:         obsServ->NotifyObservers(nsnull, "application-foreground", nsnull);
76942: 
76942:         break;
76942:     }
76942: 
90393:     case AndroidGeckoEvent::SCREENSHOT: {
90393:         if (!mBrowserApp)
90393:             break;
90393: 
90393:         AndroidBridge* bridge = AndroidBridge::Bridge();
90393:         if (!bridge)
90393:             break;
90393: 
90393:         nsCOMPtr<nsIDOMWindow> domWindow;
92110:         nsCOMPtr<nsIBrowserTab> tab;
92110:         float scale;
92110:         mBrowserApp->GetBrowserTab(curEvent->MetaState(), getter_AddRefs(tab));
92110:         if (!tab)
92110:             break;
92110: 
92110:         tab->GetWindow(getter_AddRefs(domWindow));
92110:         if (!domWindow)
92110:             break;
92110: 
92110:         if (NS_FAILED(tab->GetScale(&scale)))
92110:             break;
92110: 
90393:         nsTArray<nsIntPoint> points = curEvent->Points();
92955:         NS_ASSERTION(points.Length() == 2, "Screenshot event does not have enough coordinates");
92110:         bridge->TakeScreenshot(domWindow, 0, 0, points[0].x, points[0].y, points[1].x, points[1].y, curEvent->MetaState(), scale);
90393:         break;
90393:     }
90393: 
86071:     case AndroidGeckoEvent::VIEWPORT:
82216:     case AndroidGeckoEvent::BROADCAST: {
82216: 
82216:         if (curEvent->Characters().Length() == 0)
82216:             break;
82216: 
82216:         nsCOMPtr<nsIObserverService> obsServ =
82216:             mozilla::services::GetObserverService();
82216: 
82216:         const NS_ConvertUTF16toUTF8 topic(curEvent->Characters());
82216:         const nsPromiseFlatString& data = PromiseFlatString(curEvent->CharactersExtra());
82216: 
82216:         obsServ->NotifyObservers(nsnull, topic.get(), data.get());
82216:         break;
82216:     }
82216: 
43811:     case AndroidGeckoEvent::LOAD_URI: {
43811:         nsCOMPtr<nsICommandLineRunner> cmdline
43811:             (do_CreateInstance("@mozilla.org/toolkit/command-line;1"));
43811:         if (!cmdline)
43811:             break;
43811: 
82216:         if (curEvent->Characters().Length() == 0)
82216:             break;
82216: 
43811:         char *uri = ToNewUTF8String(curEvent->Characters());
43811:         if (!uri)
43811:             break;
43811: 
95399:         char *flag = ToNewUTF8String(curEvent->CharactersExtra());
95399: 
95399:         const char *argv[4] = {
43811:             "dummyappname",
95399:             "-url",
95399:             uri,
95399:             flag ? flag : ""
43811:         };
95399:         nsresult rv = cmdline->Init(4, const_cast<char **>(argv), nsnull, nsICommandLine::STATE_REMOTE_AUTO);
43811:         if (NS_SUCCEEDED(rv))
43811:             cmdline->Run();
43811:         nsMemory::Free(uri);
95399:         if (flag)
95399:             nsMemory::Free(flag);
43811:         break;
43811:     }
43811: 
76830:     case AndroidGeckoEvent::SIZE_CHANGED: {
76830:         // store the last resize event to dispatch it to new windows with a FORCED_RESIZE event
76830:         if (curEvent != gLastSizeChange) {
76830:             gLastSizeChange = new AndroidGeckoEvent(curEvent);
76830:         }
76830:         nsWindow::OnGlobalAndroidEvent(curEvent);
76830:         break;
76830:     }
76830: 
87005:     case AndroidGeckoEvent::VISITED: {
87005: #ifdef MOZ_ANDROID_HISTORY
87005:         nsAndroidHistory::NotifyURIVisited(nsString(curEvent->Characters()));
87005: #endif
87005:         break;
87005:     }
87005: 
87563:     case AndroidGeckoEvent::NETWORK_CHANGED: {
87563:         hal::NotifyNetworkChange(hal::NetworkInformation(curEvent->Bandwidth(),
87563:                                                          curEvent->CanBeMetered()));
87563:         break;
87563:     }
87563: 
90194:     case AndroidGeckoEvent::ACTIVITY_RESUMING: {
90194:         if (curEvent->Flags() == 0) {
95624:             // If we are OOM killed with the disk cache enabled, the entire
95624:             // cache will be cleared (bug 105843), so shut down cache on pause
95624:             // and re-init here
95667:             if (nsCacheService::GlobalInstance())
95624:                 nsCacheService::GlobalInstance()->Init();
95624: 
90194:             // We didn't return from one of our own activities, so restore
90194:             // to foreground status
90194:             nsCOMPtr<nsIObserverService> obsServ =
90194:                 mozilla::services::GetObserverService();
90194:             obsServ->NotifyObservers(nsnull, "application-foreground", nsnull);
90194:         }
90194:         break;
90194:     }
90194: 
93582:     case AndroidGeckoEvent::SCREENORIENTATION_CHANGED: {
93582:         hal::NotifyScreenOrientationChange(static_cast<dom::ScreenOrientation>(curEvent->ScreenOrientation()));
93582:         break;
93582:     }
93582: 
43066:     default:
43066:         nsWindow::OnGlobalAndroidEvent(curEvent);
43066:     }
43066: 
43066:     EVLOG("nsAppShell: -- done event %p %d", (void*)curEvent.get(), curEvent->Type());
43066: 
43066:     return true;
43066: }
43066: 
76830: void
76830: nsAppShell::ResendLastResizeEvent(nsWindow* aDest) {
76830:     if (gLastSizeChange) {
76830:         nsWindow::OnGlobalAndroidEvent(gLastSizeChange);
76830:     }
76830: }
76830: 
43066: AndroidGeckoEvent*
83987: nsAppShell::PopNextEvent()
43066: {
43066:     AndroidGeckoEvent *ae = nsnull;
64576:     MutexAutoLock lock(mQueueLock);
43066:     if (mEventQueue.Length()) {
43066:         ae = mEventQueue[0];
43066:         mEventQueue.RemoveElementAt(0);
94962:         if (mQueuedDrawEvent == ae) {
94962:             mQueuedDrawEvent = nsnull;
94962:         } else if (mQueuedViewportEvent == ae) {
94962:             mQueuedViewportEvent = nsnull;
43066:         }
43066:     }
43066: 
43066:     return ae;
43066: }
43066: 
43066: AndroidGeckoEvent*
43066: nsAppShell::PeekNextEvent()
43066: {
43066:     AndroidGeckoEvent *ae = nsnull;
64576:     MutexAutoLock lock(mQueueLock);
43066:     if (mEventQueue.Length()) {
43066:         ae = mEventQueue[0];
43066:     }
43066: 
43066:     return ae;
43066: }
43066: 
43066: void
43066: nsAppShell::PostEvent(AndroidGeckoEvent *ae)
43066: {
64576:     {
95054:         // set this to true when inserting events that we can coalesce
95054:         // viewport events across. this is effectively maintaining a whitelist
95054:         // of events that are unaffected by viewport changes.
95054:         bool allowCoalescingNextViewport = false;
95054: 
64576:         MutexAutoLock lock(mQueueLock);
94962:         EVLOG("nsAppShell::PostEvent %p %d", ae, ae->Type());
94962:         switch (ae->Type()) {
94962:         case AndroidGeckoEvent::SURFACE_DESTROYED:
77087:             // Give priority to this event, and discard any pending
77087:             // SURFACE_CREATED events.
77087:             mEventQueue.InsertElementAt(0, ae);
77087:             AndroidGeckoEvent *event;
77087:             for (int i = mEventQueue.Length() - 1; i >= 1; i--) {
77087:                 event = mEventQueue[i];
77087:                 if (event->Type() == AndroidGeckoEvent::SURFACE_CREATED) {
94962:                     EVLOG("nsAppShell: Dropping old SURFACE_CREATED event at %p %d", event, i);
77087:                     mEventQueue.RemoveElementAt(i);
77087:                     delete event;
77087:                 }
77087:             }
94962:             break;
94962: 
94962:         case AndroidGeckoEvent::COMPOSITOR_PAUSE:
94962:         case AndroidGeckoEvent::COMPOSITOR_RESUME:
94310:             // Give priority to these events, but maintain their order wrt each other.
94962:             {
94310:                 int i = 0;
94310:                 while (i < mEventQueue.Length() &&
94310:                        (mEventQueue[i]->Type() == AndroidGeckoEvent::COMPOSITOR_PAUSE ||
94310:                         mEventQueue[i]->Type() == AndroidGeckoEvent::COMPOSITOR_RESUME)) {
94310:                     i++;
94310:                 }
94962:                 EVLOG("nsAppShell: Inserting compositor event %d at position %d to maintain priority order", ae->Type(), i);
94310:                 mEventQueue.InsertElementAt(i, ae);
94962:             }
94962:             break;
94962: 
94962:         case AndroidGeckoEvent::DRAW:
94962:             if (mQueuedDrawEvent) {
94962:                 // coalesce this new draw event with the one already in the queue
94962:                 const nsIntRect& oldRect = mQueuedDrawEvent->Rect();
94962:                 const nsIntRect& newRect = ae->Rect();
94962:                 int combinedArea = (oldRect.width * oldRect.height) +
94962:                                    (newRect.width * newRect.height);
94962: 
94962:                 nsIntRect combinedRect = oldRect.Union(newRect);
94962:                 // XXX We may want to consider using regions instead of rectangles.
94962:                 //     Print an error if we're upload a lot more than we would
94962:                 //     if we handled this as two separate events.
94962:                 int boundsArea = combinedRect.width * combinedRect.height;
94962:                 if (boundsArea > combinedArea * 8)
94962:                     ALOG("nsAppShell: Area of bounds greatly exceeds combined area: %d > %d",
94962:                          boundsArea, combinedArea);
94962: 
94962:                 // coalesce into the new draw event rather than the queued one because
94962:                 // it is not always safe to move draws earlier in the queue; there may
94962:                 // be events between the two draws that affect scroll position or something.
94962:                 ae->Init(AndroidGeckoEvent::DRAW, combinedRect);
94962: 
94962:                 EVLOG("nsAppShell: Coalescing previous DRAW event at %p into new DRAW event %p", mQueuedDrawEvent, ae);
94962:                 mEventQueue.RemoveElement(mQueuedDrawEvent);
94962:                 delete mQueuedDrawEvent;
77087:             }
77087: 
95508:             if (!mAllowCoalescingNextDraw) {
95053:                 // if we're not allowing coalescing of this draw event, then
95053:                 // don't set mQueuedDrawEvent to point to this; that way the
95053:                 // next draw event that comes in won't kill this one.
95053:                 mAllowCoalescingNextDraw = true;
95053:                 mQueuedDrawEvent = nsnull;
95053:             } else {
94962:                 mQueuedDrawEvent = ae;
95053:             }
95054: 
95054:             allowCoalescingNextViewport = true;
95054: 
94962:             mEventQueue.AppendElement(ae);
94962:             break;
94962: 
94962:         case AndroidGeckoEvent::VIEWPORT:
94962:             if (mQueuedViewportEvent) {
94962:                 // drop the previous viewport event now that we have a new one
94962:                 EVLOG("nsAppShell: Dropping old viewport event at %p in favour of new VIEWPORT event %p", mQueuedViewportEvent, ae);
94962:                 mEventQueue.RemoveElement(mQueuedViewportEvent);
94962:                 delete mQueuedViewportEvent;
94962:             }
94962:             mQueuedViewportEvent = ae;
95053:             // temporarily turn off draw-coalescing, so that we process a draw
95053:             // event as soon as possible after a viewport change
95053:             mAllowCoalescingNextDraw = false;
95054:             allowCoalescingNextViewport = true;
95053: 
94962:             mEventQueue.AppendElement(ae);
94962:             break;
94962: 
94962:         case AndroidGeckoEvent::MOTION_EVENT:
94962:             if (ae->Action() == AndroidMotionEvent::ACTION_MOVE) {
94962:                 int len = mEventQueue.Length();
94962:                 if (len > 0) {
94962:                     AndroidGeckoEvent* event = mEventQueue[len - 1];
94962:                     if (event->Type() == AndroidGeckoEvent::MOTION_EVENT && event->Action() == AndroidMotionEvent::ACTION_MOVE) {
94962:                         // consecutive motion-move events; drop the last one before adding the new one
94962:                         EVLOG("nsAppShell: Dropping old move event at %p in favour of new move event %p", event, ae);
94962:                         mEventQueue.RemoveElementAt(len - 1);
94962:                         delete event;
94962:                     }
94962:                 }
94962:             }
94962:             mEventQueue.AppendElement(ae);
94962:             break;
94962: 
95054:         case AndroidGeckoEvent::NATIVE_POKE:
95054:             allowCoalescingNextViewport = true;
95054:             // fall through
95054: 
94962:         default:
94962:             mEventQueue.AppendElement(ae);
94962:             break;
43066:         }
95054: 
95054:         // if the event wasn't on our whitelist then reset mQueuedViewportEvent
95054:         // so that we don't coalesce future viewport events into the last viewport
95054:         // event we added
95054:         if (!allowCoalescingNextViewport)
95054:             mQueuedViewportEvent = nsnull;
64576:     }
43066:     NotifyNativeEvent();
43066: }
43066: 
43066: void
61773: nsAppShell::OnResume()
61773: {
61773: }
61773: 
51723: nsresult
51723: nsAppShell::AddObserver(const nsAString &aObserverKey, nsIObserver *aObserver)
51723: {
51723:     NS_ASSERTION(aObserver != nsnull, "nsAppShell::AddObserver: aObserver is null!");
51723:     return mObserversHash.Put(aObserverKey, aObserver) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
51723: }
51723: 
51723: /**
51723:  * The XPCOM event that will call the observer on the main thread.
51723:  */
51723: class ObserverCaller : public nsRunnable {
51723: public:
51723:     ObserverCaller(nsIObserver *aObserver, const char *aTopic, const PRUnichar *aData) :
51723:         mObserver(aObserver), mTopic(aTopic), mData(aData) {
51723:         NS_ASSERTION(aObserver != nsnull, "ObserverCaller: aObserver is null!");
51723:     }
51723: 
51723:     NS_IMETHOD Run() {
51723:         ALOG("ObserverCaller::Run: observer = %p, topic = '%s')",
51723:              (nsIObserver*)mObserver, mTopic.get());
51723:         mObserver->Observe(nsnull, mTopic.get(), mData.get());
51723:         return NS_OK;
51723:     }
51723: 
51723: private:
51723:     nsCOMPtr<nsIObserver> mObserver;
51723:     nsCString mTopic;
51723:     nsString mData;
51723: };
51723: 
51723: void
51723: nsAppShell::CallObserver(const nsAString &aObserverKey, const nsAString &aTopic, const nsAString &aData)
51723: {
51723:     nsCOMPtr<nsIObserver> observer;
51723:     mObserversHash.Get(aObserverKey, getter_AddRefs(observer));
51723: 
51723:     if (!observer) {
51723:         ALOG("nsAppShell::CallObserver: Observer was not found!");
51723:         return;
51723:     }
51723: 
51723:     const NS_ConvertUTF16toUTF8 sTopic(aTopic);
51723:     const nsPromiseFlatString& sData = PromiseFlatString(aData);
51723: 
51723:     if (NS_IsMainThread()) {
51723:         // This branch will unlikely be hit, have it just in case
51723:         observer->Observe(nsnull, sTopic.get(), sData.get());
51723:     } else {
51723:         // Java is not running on main thread, so we have to use NS_DispatchToMainThread
51723:         nsCOMPtr<nsIRunnable> observerCaller = new ObserverCaller(observer, sTopic.get(), sData.get());
51723:         nsresult rv = NS_DispatchToMainThread(observerCaller);
51723:         ALOG("NS_DispatchToMainThread result: %d", rv);
62359:         unused << rv;
51723:     }
51723: }
51723: 
51723: void
51723: nsAppShell::RemoveObserver(const nsAString &aObserverKey)
51723: {
51723:     mObserversHash.Remove(aObserverKey);
51723: }
51723: 
60059: // NotifyObservers support.  NotifyObservers only works on main thread.
60059: 
60059: class NotifyObserversCaller : public nsRunnable {
60059: public:
60059:     NotifyObserversCaller(nsISupports *aSupports,
60059:                           const char *aTopic, const PRUnichar *aData) :
60059:         mSupports(aSupports), mTopic(aTopic), mData(aData) {
60059:     }
60059: 
60059:     NS_IMETHOD Run() {
60059:         nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
60059:         if (os)
60059:             os->NotifyObservers(mSupports, mTopic.get(), mData.get());
60059: 
60059:         return NS_OK;
60059:     }
60059: 
60059: private:
60059:     nsCOMPtr<nsISupports> mSupports;
60059:     nsCString mTopic;
60059:     nsString mData;
60059: };
60059: 
60059: void
60059: nsAppShell::NotifyObservers(nsISupports *aSupports,
60059:                             const char *aTopic,
60059:                             const PRUnichar *aData)
60059: {
60059:     // This isn't main thread, so post this to main thread
60059:     nsCOMPtr<nsIRunnable> caller =
60059:         new NotifyObserversCaller(aSupports, aTopic, aData);
60059:     NS_DispatchToMainThread(caller);
60059: }
60059: 
43066: // Used by IPC code
43066: namespace mozilla {
43066: 
43066: bool ProcessNextEvent()
43066: {
80486:     return nsAppShell::gAppShell->ProcessNextNativeEvent(true) ? true : false;
43066: }
43066: 
43066: void NotifyEvent()
43066: {
43066:     nsAppShell::gAppShell->NotifyNativeEvent();
43066: }
43066: 
43066: }
