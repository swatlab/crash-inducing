    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsatom_h___
    1: #define jsatom_h___
    1: /*
    1:  * JS atom table.
    1:  */
    1: #include <stddef.h>
18863: #include "jsversion.h"
    1: #include "jsapi.h"
    1: #include "jsprvtd.h"
48633: #include "jshash.h"
48633: #include "jshashtable.h"
67930: #include "jsnum.h"
    1: #include "jspubtd.h"
48633: #include "jsstr.h"
    1: #include "jslock.h"
48470: #include "jsvalue.h"
    1: 
 4529: #define ATOM_PINNED     0x1       /* atom is pinned against GC */
 4529: #define ATOM_INTERNED   0x2       /* pinned variant for JS_Intern* API */
 4529: #define ATOM_NOCOPY     0x4       /* don't copy atom string bytes */
48470: 
48470: /* Engine-internal extensions of jsid */
48470: 
48470: static JS_ALWAYS_INLINE jsid
48470: JSID_FROM_BITS(size_t bits)
48470: {
48470:     jsid id;
48470:     JSID_BITS(id) = bits;
48470:     return id;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsid
48470: ATOM_TO_JSID(JSAtom *atom)
48470: {
48470:     JS_ASSERT(((size_t)atom & 0x7) == 0);
48470:     return JSID_FROM_BITS((size_t)atom);
48470: }
48470: 
48470: /* All strings stored in jsids are atomized. */
48470: static JS_ALWAYS_INLINE JSBool
48470: JSID_IS_ATOM(jsid id)
48470: {
48470:     return JSID_IS_STRING(id);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSID_IS_ATOM(jsid id, JSAtom *atom)
48470: {
48470:     return JSID_BITS(id) == JSID_BITS(ATOM_TO_JSID(atom));
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSAtom *
48470: JSID_TO_ATOM(jsid id)
48470: {
48470:     return (JSAtom *)JSID_TO_STRING(id);
48470: }
48470: 
48470: namespace js {
48470: 
48470: static JS_ALWAYS_INLINE Value
48470: IdToValue(jsid id)
48470: {
48470:     if (JSID_IS_STRING(id))
48470:         return StringValue(JSID_TO_STRING(id));
48470:     if (JS_LIKELY(JSID_IS_INT(id)))
48470:         return Int32Value(JSID_TO_INT(id));
48470:     if (JS_LIKELY(JSID_IS_OBJECT(id)))
48470:         return ObjectValue(*JSID_TO_OBJECT(id));
48470:     JS_ASSERT(JSID_IS_DEFAULT_XML_NAMESPACE(id) || JSID_IS_VOID(id));
48470:     return UndefinedValue();
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval
48470: IdToJsval(jsid id)
48470: {
48470:     return Jsvalify(IdToValue(id));
48470: }
48470: 
67930: static JS_ALWAYS_INLINE JSString *
67930: IdToString(JSContext *cx, jsid id)
67930: {
67930:     if (JSID_IS_STRING(id))
67930:         return JSID_TO_STRING(id);
67930:     if (JS_LIKELY(JSID_IS_INT(id)))
67930:         return js_IntToString(cx, JSID_TO_INT(id));
67930:     return js_ValueToString(cx, IdToValue(id));
67930: }
67930: 
48470: }
    1: 
 3328: #if JS_BYTES_PER_WORD == 4
 3328: # define ATOM_HASH(atom)          ((JSHashNumber)(atom) >> 2)
 3328: #elif JS_BYTES_PER_WORD == 8
 6956: # define ATOM_HASH(atom)          (((JSHashNumber)(jsuword)(atom) >> 3) ^     \
 3328:                                    (JSHashNumber)((jsuword)(atom) >> 32))
 3328: #else
 3328: # error "Unsupported configuration"
 3328: #endif
 3328: 
    1: /*
    1:  * Return a printable, lossless char[] representation of a string-type atom.
57812:  * The lifetime of the result matches the lifetime of bytes.
    1:  */
10444: extern const char *
57812: js_AtomToPrintableString(JSContext *cx, JSAtom *atom, JSAutoByteString *bytes);
    1: 
    1: struct JSAtomListElement {
    1:     JSHashEntry         entry;
    1: };
    1: 
    1: #define ALE_ATOM(ale)   ((JSAtom *) (ale)->entry.key)
40292: #define ALE_INDEX(ale)  (jsatomid(uintptr_t((ale)->entry.value)))
48470: #define ALE_VALUE(ale)  ((jsboxedword) (ale)->entry.value)
    1: #define ALE_NEXT(ale)   ((JSAtomListElement *) (ale)->entry.next)
    1: 
28740: /*
28740:  * In an upvars list, ALE_DEFN(ale)->resolve() is the outermost definition the
28740:  * name may reference. If a with block or a function that calls eval encloses
28740:  * the use, the name may end up referring to something else at runtime.
28740:  */
28740: #define ALE_DEFN(ale)   ((JSDefinition *) (ale)->entry.value)
28740: 
    1: #define ALE_SET_ATOM(ale,atom)  ((ale)->entry.key = (const void *)(atom))
40292: #define ALE_SET_INDEX(ale,index)((ale)->entry.value = (void *)(index))
27012: #define ALE_SET_DEFN(ale, dn)   ((ale)->entry.value = (void *)(dn))
18308: #define ALE_SET_VALUE(ale, v)   ((ale)->entry.value = (void *)(v))
27012: #define ALE_SET_NEXT(ale,nxt)   ((ale)->entry.next = (JSHashEntry *)(nxt))
    1: 
27012: /*
27012:  * NB: JSAtomSet must be plain-old-data as it is embedded in the pn_u union in
27012:  * JSParseNode. JSAtomList encapsulates all operational uses of a JSAtomSet.
27012:  *
27012:  * The JSAtomList name is traditional, even though the implementation is a map
27012:  * (not to be confused with JSAtomMap). In particular the "ALE" and "ale" short
27012:  * names for JSAtomListElement variables roll off the fingers, compared to ASE
27012:  * or AME alternatives.
27012:  */
27012: struct JSAtomSet {
 2284:     JSHashEntry         *list;          /* literals indexed for mapping */
    1:     JSHashTable         *table;         /* hash table if list gets too long */
    1:     jsuint              count;          /* count of indexed literals */
    1: };
    1: 
27012: struct JSAtomList : public JSAtomSet
27012: {
27012: #ifdef DEBUG
27012:     const JSAtomSet* set;               /* asserted null in mutating methods */
27012: #endif
    1: 
27012:     JSAtomList() {
27012:         list = NULL; table = NULL; count = 0;
27012: #ifdef DEBUG
27012:         set = NULL;
27012: #endif
27012:     }
27012: 
27012:     JSAtomList(const JSAtomSet& as) {
27012:         list = as.list; table = as.table; count = as.count;
27012: #ifdef DEBUG
27012:         set = &as;
27012: #endif
27012:     }
27012: 
27012:     void clear() { JS_ASSERT(!set); list = NULL; table = NULL; count = 0; }
27012: 
27012:     JSAtomListElement *lookup(JSAtom *atom) {
27012:         JSHashEntry **hep;
27012:         return rawLookup(atom, hep);
27012:     }
27012: 
27012:     JSAtomListElement *rawLookup(JSAtom *atom, JSHashEntry **&hep);
27012: 
27012:     enum AddHow { UNIQUE, SHADOW, HOIST };
27012: 
40860:     JSAtomListElement *add(js::Parser *parser, JSAtom *atom, AddHow how = UNIQUE);
27012: 
40860:     void remove(js::Parser *parser, JSAtom *atom) {
27012:         JSHashEntry **hep;
27012:         JSAtomListElement *ale = rawLookup(atom, hep);
27012:         if (ale)
40860:             rawRemove(parser, ale, hep);
27012:     }
27012: 
40860:     void rawRemove(js::Parser *parser, JSAtomListElement *ale, JSHashEntry **hep);
27012: };
27012: 
27012: /*
35309:  * A subclass of JSAtomList with a destructor.  This atom list owns its
35309:  * hash table and its entries, but no keys or values.
35309:  */
35309: struct JSAutoAtomList: public JSAtomList
35309: {
40860:     JSAutoAtomList(js::Parser *p): parser(p) {}
35309:     ~JSAutoAtomList();
35309:   private:
40860:     js::Parser *parser;         /* For freeing list entries. */
35309: };
35309: 
35309: /*
27012:  * Iterate over an atom list. We define a call operator to minimize the syntax
27012:  * tax for users. We do not use a more standard pattern using ++ and * because
27012:  * (a) it's the wrong pattern for a non-scalar; (b) it's overkill -- one method
27012:  * is enough. (This comment is overkill!)
27012:  */
27012: class JSAtomListIterator {
27012:     JSAtomList*         list;
27012:     JSAtomListElement*  next;
27012:     uint32              index;
27012: 
27012:   public:
27012:     JSAtomListIterator(JSAtomList* al) : list(al) { reset(); }
27012: 
27012:     void reset() {
27012:         next = (JSAtomListElement *) list->list;
27012:         index = 0;
27012:     }
27012: 
27012:     JSAtomListElement* operator ()();
27012: };
27012: 
    1: struct JSAtomMap {
    1:     JSAtom              **vector;       /* array of ptrs to indexed atoms */
    1:     jsatomid            length;         /* count of (to-be-)indexed atoms */
    1: };
    1: 
48633: namespace js {
48633: 
48633: #define ATOM_ENTRY_FLAG_MASK            ((size_t)(ATOM_PINNED | ATOM_INTERNED))
48633: 
48633: JS_STATIC_ASSERT(ATOM_ENTRY_FLAG_MASK < JS_GCTHING_ALIGN);
48633: 
48633: typedef uintptr_t AtomEntryType;
48633: 
59890: static JS_ALWAYS_INLINE JSAtom *
48633: AtomEntryToKey(AtomEntryType entry)
48633: {
48633:     JS_ASSERT(entry != 0);
59890:     return (JSAtom *)(entry & ~ATOM_ENTRY_FLAG_MASK);
48633: }
48633: 
48633: struct AtomHasher
48633: {
64345:     struct Lookup
64345:     {
64345:         const jschar *chars;
64345:         size_t length;
64345:         Lookup(const jschar *chars, size_t length) : chars(chars), length(length) {}
64345:     };
48633: 
64345:     static HashNumber hash(const Lookup &l) {
64345:         return HashChars(l.chars, l.length);
48633:     }
48633: 
64345:     static bool match(AtomEntryType entry, const Lookup &lookup) {
64345:         JS_ASSERT(entry);
64345:         JSAtom *key = AtomEntryToKey(entry);
64345:         if (key->length() != lookup.length)
64345:             return false;
64345:         return PodEqual(key->chars(), lookup.chars, lookup.length);
48633:     }
48633: };
48633: 
48633: typedef HashSet<AtomEntryType, AtomHasher, SystemAllocPolicy> AtomSet;
48633: 
48633: }  /* namespace js */
48633: 
48633: struct JSAtomState
48633: {
48633:     js::AtomSet         atoms;
48633: 
 4342: #ifdef JS_THREADSAFE
 4342:     JSThinLock          lock;
 4342: #endif
 4342: 
 4342:     /*
 4342:      * From this point until the end of struct definition the struct must
 4342:      * contain only JSAtom fields. We use this to access the storage occupied
 4342:      * by the common atoms in js_FinishCommonAtoms.
 4342:      *
 4342:      * js_common_atom_names defined in jsatom.c contains C strings for atoms
 4342:      * in the order of atom fields here. Therefore you must update that array
 4342:      * if you change member order here.
 4342:      */
    1: 
    1:     /* The rt->emptyString atom, see jsstr.c's js_InitRuntimeStringState. */
    1:     JSAtom              *emptyAtom;
    1: 
21447:     /*
21447:      * Literal value and type names.
21447:      * NB: booleanAtoms must come right before typeAtoms!
21447:      */
21447:     JSAtom              *booleanAtoms[2];
    1:     JSAtom              *typeAtoms[JSTYPE_LIMIT];
    1:     JSAtom              *nullAtom;
    1: 
    1:     /* Standard class constructor or prototype names. */
    1:     JSAtom              *classAtoms[JSProto_LIMIT];
    1: 
    1:     /* Various built-in or commonly-used atoms, pinned on first context. */
    1:     JSAtom              *anonymousAtom;
21452:     JSAtom              *applyAtom;
    1:     JSAtom              *argumentsAtom;
    1:     JSAtom              *arityAtom;
21473:     JSAtom              *callAtom;
    1:     JSAtom              *calleeAtom;
    1:     JSAtom              *callerAtom;
    1:     JSAtom              *classPrototypeAtom;
    1:     JSAtom              *constructorAtom;
    1:     JSAtom              *eachAtom;
    1:     JSAtom              *evalAtom;
    1:     JSAtom              *fileNameAtom;
    1:     JSAtom              *getAtom;
47436:     JSAtom              *globalAtom;
47436:     JSAtom              *ignoreCaseAtom;
    1:     JSAtom              *indexAtom;
    1:     JSAtom              *inputAtom;
51100:     JSAtom              *toISOStringAtom;
    1:     JSAtom              *iteratorAtom;
48486:     JSAtom              *joinAtom;
47436:     JSAtom              *lastIndexAtom;
    1:     JSAtom              *lengthAtom;
    1:     JSAtom              *lineNumberAtom;
    1:     JSAtom              *messageAtom;
47436:     JSAtom              *multilineAtom;
    1:     JSAtom              *nameAtom;
    1:     JSAtom              *nextAtom;
    1:     JSAtom              *noSuchMethodAtom;
55714:     JSAtom              *objectNullAtom;
55714:     JSAtom              *objectUndefinedAtom;
    1:     JSAtom              *protoAtom;
    1:     JSAtom              *setAtom;
47436:     JSAtom              *sourceAtom;
    1:     JSAtom              *stackAtom;
47436:     JSAtom              *stickyAtom;
47533:     JSAtom              *toGMTStringAtom;
    1:     JSAtom              *toLocaleStringAtom;
    1:     JSAtom              *toSourceAtom;
    1:     JSAtom              *toStringAtom;
47533:     JSAtom              *toUTCStringAtom;
    1:     JSAtom              *valueOfAtom;
20092:     JSAtom              *toJSONAtom;
 2312:     JSAtom              *void0Atom;
32721:     JSAtom              *enumerableAtom;
32721:     JSAtom              *configurableAtom;
32721:     JSAtom              *writableAtom;
32721:     JSAtom              *valueAtom;
53601:     JSAtom              *testAtom;
35113:     JSAtom              *useStrictAtom;
56211:     JSAtom              *locAtom;
56211:     JSAtom              *lineAtom;
57823:     JSAtom              *InfinityAtom;
57823:     JSAtom              *NaNAtom;
60150:     JSAtom              *builderAtom;
 4342: 
 4342: #if JS_HAS_XML_SUPPORT
 4342:     JSAtom              *etagoAtom;
 4342:     JSAtom              *namespaceAtom;
 4342:     JSAtom              *ptagcAtom;
 4342:     JSAtom              *qualifierAtom;
 4342:     JSAtom              *spaceAtom;
 4342:     JSAtom              *stagoAtom;
 4342:     JSAtom              *starAtom;
 4342:     JSAtom              *starQualifierAtom;
 4342:     JSAtom              *tagcAtom;
    1:     JSAtom              *xmlAtom;
54162: 
54162:     /* Represents an invalid URI, for internal use only. */
54162:     JSAtom              *functionNamespaceURIAtom;
 4342: #endif
 4342: 
42733:     JSAtom              *ProxyAtom;
42733: 
42733:     JSAtom              *getOwnPropertyDescriptorAtom;
42733:     JSAtom              *getPropertyDescriptorAtom;
42733:     JSAtom              *definePropertyAtom;
42733:     JSAtom              *deleteAtom;
42733:     JSAtom              *getOwnPropertyNamesAtom;
42733:     JSAtom              *enumerateAtom;
42733:     JSAtom              *fixAtom;
42733: 
42733:     JSAtom              *hasAtom;
42733:     JSAtom              *hasOwnAtom;
60532:     JSAtom              *keysAtom;
43190:     JSAtom              *iterateAtom;
42733: 
    1:     /* Less frequently used atoms, pinned lazily by JS_ResolveStandardClass. */
    1:     struct {
    1:         JSAtom          *XMLListAtom;
    1:         JSAtom          *decodeURIAtom;
    1:         JSAtom          *decodeURIComponentAtom;
    1:         JSAtom          *defineGetterAtom;
    1:         JSAtom          *defineSetterAtom;
    1:         JSAtom          *encodeURIAtom;
    1:         JSAtom          *encodeURIComponentAtom;
    1:         JSAtom          *escapeAtom;
    1:         JSAtom          *hasOwnPropertyAtom;
    1:         JSAtom          *isFiniteAtom;
    1:         JSAtom          *isNaNAtom;
    1:         JSAtom          *isPrototypeOfAtom;
    1:         JSAtom          *isXMLNameAtom;
    1:         JSAtom          *lookupGetterAtom;
    1:         JSAtom          *lookupSetterAtom;
    1:         JSAtom          *parseFloatAtom;
    1:         JSAtom          *parseIntAtom;
    1:         JSAtom          *propertyIsEnumerableAtom;
    1:         JSAtom          *unescapeAtom;
    1:         JSAtom          *unevalAtom;
    1:         JSAtom          *unwatchAtom;
    1:         JSAtom          *watchAtom;
    1:     } lazy;
 4342: };
    1: 
42733: #define ATOM(name) cx->runtime->atomState.name##Atom
42733: 
 4342: #define ATOM_OFFSET_START       offsetof(JSAtomState, emptyAtom)
 4342: #define LAZY_ATOM_OFFSET_START  offsetof(JSAtomState, lazy)
 4342: #define ATOM_OFFSET_LIMIT       (sizeof(JSAtomState))
 4342: 
 4529: #define COMMON_ATOMS_START(state)                                             \
21685:     ((JSAtom **)((uint8 *)(state) + ATOM_OFFSET_START))
21685: #define COMMON_ATOM_INDEX(name)                                               \
21685:     ((offsetof(JSAtomState, name##Atom) - ATOM_OFFSET_START)                  \
21685:      / sizeof(JSAtom*))
21685: #define COMMON_TYPE_ATOM_INDEX(type)                                          \
21685:     ((offsetof(JSAtomState, typeAtoms[type]) - ATOM_OFFSET_START)             \
21685:      / sizeof(JSAtom*))
 4529: 
 2803: #define ATOM_OFFSET(name)       offsetof(JSAtomState, name##Atom)
 2803: #define OFFSET_TO_ATOM(rt,off)  (*(JSAtom **)((char*)&(rt)->atomState + (off)))
 2803: #define CLASS_ATOM_OFFSET(name) offsetof(JSAtomState,classAtoms[JSProto_##name])
 2803: 
    1: #define CLASS_ATOM(cx,name) \
    1:     ((cx)->runtime->atomState.classAtoms[JSProto_##name])
    1: 
 4342: extern const char *const js_common_atom_names[];
21685: extern const size_t      js_common_atom_count;
    1: 
 4342: /*
25901:  * Macros to access C strings for JSType and boolean literals.
 4342:  */
21447: #define JS_BOOLEAN_STR(type) (js_common_atom_names[1 + (type)])
21447: #define JS_TYPE_STR(type)    (js_common_atom_names[1 + 2 + (type)])
 4342: 
 4342: /* Well-known predefined C strings. */
    1: #define JS_PROTO(name,code,init) extern const char js_##name##_str[];
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: 
    1: extern const char   js_anonymous_str[];
21452: extern const char   js_apply_str[];
    1: extern const char   js_arguments_str[];
    1: extern const char   js_arity_str[];
21473: extern const char   js_call_str[];
    1: extern const char   js_callee_str[];
    1: extern const char   js_caller_str[];
    1: extern const char   js_class_prototype_str[];
    1: extern const char   js_close_str[];
    1: extern const char   js_constructor_str[];
    1: extern const char   js_count_str[];
    1: extern const char   js_etago_str[];
    1: extern const char   js_each_str[];
    1: extern const char   js_eval_str[];
    1: extern const char   js_fileName_str[];
    1: extern const char   js_get_str[];
    1: extern const char   js_getter_str[];
47436: extern const char   js_global_str[];
47436: extern const char   js_ignoreCase_str[];
    1: extern const char   js_index_str[];
    1: extern const char   js_input_str[];
    1: extern const char   js_iterator_str[];
48486: extern const char   js_join_str[];
47436: extern const char   js_lastIndex_str[];
    1: extern const char   js_length_str[];
    1: extern const char   js_lineNumber_str[];
    1: extern const char   js_message_str[];
47436: extern const char   js_multiline_str[];
    1: extern const char   js_name_str[];
    1: extern const char   js_namespace_str[];
    1: extern const char   js_next_str[];
    1: extern const char   js_noSuchMethod_str[];
    1: extern const char   js_object_str[];
    1: extern const char   js_proto_str[];
    1: extern const char   js_ptagc_str[];
    1: extern const char   js_qualifier_str[];
    1: extern const char   js_send_str[];
    1: extern const char   js_setter_str[];
    1: extern const char   js_set_str[];
47436: extern const char   js_source_str[];
    1: extern const char   js_space_str[];
    1: extern const char   js_stack_str[];
47436: extern const char   js_sticky_str[];
    1: extern const char   js_stago_str[];
    1: extern const char   js_star_str[];
    1: extern const char   js_starQualifier_str[];
    1: extern const char   js_tagc_str[];
47533: extern const char   js_toGMTString_str[];
47533: extern const char   js_toLocaleString_str[];
    1: extern const char   js_toSource_str[];
    1: extern const char   js_toString_str[];
47533: extern const char   js_toUTCString_str[];
 4342: extern const char   js_undefined_str[];
    1: extern const char   js_valueOf_str[];
20092: extern const char   js_toJSON_str[];
    1: extern const char   js_xml_str[];
32721: extern const char   js_enumerable_str[];
32721: extern const char   js_configurable_str[];
32721: extern const char   js_writable_str[];
32721: extern const char   js_value_str[];
53601: extern const char   js_test_str[];
    1: 
    1: /*
 4342:  * Initialize atom state. Return true on success, false on failure to allocate
 4342:  * memory. The caller must zero rt->atomState before calling this function and
 4342:  * only call it after js_InitGC successfully returns.
    1:  */
    1: extern JSBool
 4342: js_InitAtomState(JSRuntime *rt);
    1: 
    1: /*
 4342:  * Free and clear atom state including any interned string atoms. This
 4342:  * function must be called before js_FinishGC.
    1:  */
    1: extern void
 4342: js_FinishAtomState(JSRuntime *rt);
    1: 
    1: /*
  583:  * Atom tracing and garbage collection hooks.
    1:  */
    1: 
    1: extern void
41294: js_TraceAtomState(JSTracer *trc);
    1: 
    1: extern void
 4342: js_SweepAtomState(JSContext *cx);
    1: 
    1: extern JSBool
 4342: js_InitCommonAtoms(JSContext *cx);
    1: 
    1: extern void
 4342: js_FinishCommonAtoms(JSContext *cx);
    1: 
    1: /*
 3328:  * Find or create the atom for a string. Return null on failure to allocate
 3328:  * memory.
    1:  */
    1: extern JSAtom *
    1: js_AtomizeString(JSContext *cx, JSString *str, uintN flags);
    1: 
10444: extern JSAtom *
68124: js_Atomize(JSContext *cx, const char *bytes, size_t length, uintN flags);
    1: 
10444: extern JSAtom *
    1: js_AtomizeChars(JSContext *cx, const jschar *chars, size_t length, uintN flags);
    1: 
    1: /*
    1:  * Return an existing atom for the given char array or null if the char
    1:  * sequence is currently not atomized.
    1:  */
    1: extern JSAtom *
    1: js_GetExistingStringAtom(JSContext *cx, const jschar *chars, size_t length);
    1: 
 4342: #ifdef DEBUG
 4342: 
 4342: extern JS_FRIEND_API(void)
 4342: js_DumpAtoms(JSContext *cx, FILE *fp);
 4342: 
 4342: #endif
 4342: 
48470: inline bool
48470: js_ValueToAtom(JSContext *cx, const js::Value &v, JSAtom **atomp);
48470: 
48470: inline bool
48470: js_ValueToStringId(JSContext *cx, const js::Value &v, jsid *idp);
48470: 
48470: inline bool
48470: js_InternNonIntElementId(JSContext *cx, JSObject *obj, const js::Value &idval,
48470:                          jsid *idp);
48470: inline bool
48470: js_InternNonIntElementId(JSContext *cx, JSObject *obj, const js::Value &idval,
48470:                          jsid *idp, js::Value *vp);
    1: /*
    1:  * For all unmapped atoms recorded in al, add a mapping from the atom's index
 3235:  * to its address. map->length must already be set to the number of atoms in
 3235:  * the list and map->vector must point to pre-allocated memory.
    1:  */
10444: extern void
 3235: js_InitAtomMap(JSContext *cx, JSAtomMap *map, JSAtomList *al);
    1: 
    1: #endif /* jsatom_h___ */
