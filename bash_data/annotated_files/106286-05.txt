     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
106286: #include "mozilla/Selection.h"
104487: #include "nsCOMArray.h"
104487: #include "nsComponentManagerUtils.h"
     1: #include "nsEditorUtils.h"
104487: #include "nsError.h"
104487: #include "nsIClipboardDragDropHookList.h"
     1: // hooks
     1: #include "nsIClipboardDragDropHooks.h"
104487: #include "nsIContent.h"
104487: #include "nsIContentIterator.h"
104487: #include "nsIDOMDocument.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIDocument.h"
     1: #include "nsIInterfaceRequestorUtils.h"
104487: #include "nsINode.h"
104487: #include "nsISimpleEnumerator.h"
104487: 
104487: class nsIDOMRange;
104487: class nsISupports;
     1: 
106286: using namespace mozilla;
     1: 
     1: /******************************************************************************
     1:  * nsAutoSelectionReset
     1:  *****************************************************************************/
     1: 
106286: nsAutoSelectionReset::nsAutoSelectionReset(Selection* aSel, nsEditor* aEd)
106286:   : mSel(nsnull), mEd(nsnull)
     1: { 
     1:   if (!aSel || !aEd) return;    // not much we can do, bail.
     1:   if (aEd->ArePreservingSelection()) return;   // we already have initted mSavedSel, so this must be nested call.
106286:   mSel = aSel;
     1:   mEd = aEd;
     1:   if (mSel)
     1:   {
     1:     mEd->PreserveSelectionAcrossActions(mSel);
     1:   }
     1: }
     1: 
     1: nsAutoSelectionReset::~nsAutoSelectionReset()
     1: {
 10011:   NS_ASSERTION(!mSel || mEd, "mEd should be non-null when mSel is");
     1:   if (mSel && mEd->ArePreservingSelection())   // mSel will be null if this was nested call
     1:   {
     1:     mEd->RestorePreservedSelection(mSel);
     1:   }
     1: }
     1: 
     1: void
     1: nsAutoSelectionReset::Abort()
     1: {
 10011:   NS_ASSERTION(!mSel || mEd, "mEd should be non-null when mSel is");
 10011:   if (mSel)
     1:     mEd->StopPreservingSelection();
     1: }
     1: 
     1: 
     1: /******************************************************************************
     1:  * some helper classes for iterating the dom tree
     1:  *****************************************************************************/
     1: 
     1: nsDOMIterator::nsDOMIterator() :
     1: mIter(nsnull)
     1: {
     1: }
     1:     
     1: nsDOMIterator::~nsDOMIterator()
     1: {
     1: }
     1:     
     1: nsresult
     1: nsDOMIterator::Init(nsIDOMRange* aRange)
     1: {
     1:   nsresult res;
     1:   mIter = do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &res);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(mIter, NS_ERROR_FAILURE);
     1:   return mIter->Init(aRange);
     1: }
     1: 
     1: nsresult
     1: nsDOMIterator::Init(nsIDOMNode* aNode)
     1: {
     1:   nsresult res;
     1:   mIter = do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &res);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(mIter, NS_ERROR_FAILURE);
     1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
     1:   return mIter->Init(content);
     1: }
     1: 
     1: nsresult
     1: nsDOMIterator::AppendList(nsBoolDomIterFunctor& functor,
     1:                           nsCOMArray<nsIDOMNode>& arrayOfNodes) const
     1: {
     1:   nsCOMPtr<nsIDOMNode> node;
     1:   
     1:   // iterate through dom and build list
     1:   while (!mIter->IsDone())
     1:   {
     1:     node = do_QueryInterface(mIter->GetCurrentNode());
 43807:     NS_ENSURE_TRUE(node, NS_ERROR_NULL_POINTER);
     1: 
     1:     if (functor(node))
     1:     {
     1:       arrayOfNodes.AppendObject(node);
     1:     }
     1:     mIter->Next();
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: nsDOMSubtreeIterator::nsDOMSubtreeIterator()
     1: {
     1: }
     1:     
     1: nsDOMSubtreeIterator::~nsDOMSubtreeIterator()
     1: {
     1: }
     1:     
     1: nsresult
     1: nsDOMSubtreeIterator::Init(nsIDOMRange* aRange)
     1: {
     1:   nsresult res;
     1:   mIter = do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &res);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(mIter, NS_ERROR_FAILURE);
     1:   return mIter->Init(aRange);
     1: }
     1: 
     1: /******************************************************************************
     1:  * some general purpose editor utils
     1:  *****************************************************************************/
     1: 
 79445: bool 
     1: nsEditorUtils::IsDescendantOf(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 *aOffset) 
     1: {
 80486:   NS_ENSURE_TRUE(aNode || aParent, false);
 80486:   if (aNode == aParent) return false;
     1:   
     1:   nsCOMPtr<nsIDOMNode> parent, node = do_QueryInterface(aNode);
     1:   nsresult res;
     1:   
     1:   do
     1:   {
     1:     res = node->GetParentNode(getter_AddRefs(parent));
 80486:     NS_ENSURE_SUCCESS(res, false);
     1:     if (parent == aParent) 
     1:     {
     1:       if (aOffset)
     1:       {
     1:         nsCOMPtr<nsIContent> pCon(do_QueryInterface(parent));
     1:         nsCOMPtr<nsIContent> cCon(do_QueryInterface(node));
     1:         if (pCon)
     1:         {
     1:           *aOffset = pCon->IndexOf(cCon);
     1:         }
     1:       }
 80486:       return true;
     1:     }
     1:     node = parent;
     1:   } while (parent);
     1:   
 80486:   return false;
     1: }
     1: 
 79445: bool
     1: nsEditorUtils::IsLeafNode(nsIDOMNode *aNode)
     1: {
 79445:   bool hasChildren = false;
     1:   if (aNode)
     1:     aNode->HasChildNodes(&hasChildren);
     1:   return !hasChildren;
     1: }
     1: 
     1: /******************************************************************************
     1:  * utility methods for drag/drop/copy/paste hooks
     1:  *****************************************************************************/
     1: 
     1: nsresult
     1: nsEditorHookUtils::GetHookEnumeratorFromDocument(nsIDOMDocument *aDoc,
     1:                                                  nsISimpleEnumerator **aResult)
     1: {
     1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(aDoc);
 43806:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
     1: 
     1:   nsCOMPtr<nsISupports> container = doc->GetContainer();
     1:   nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(container);
     1:   nsCOMPtr<nsIClipboardDragDropHookList> hookObj = do_GetInterface(docShell);
 43806:   NS_ENSURE_TRUE(hookObj, NS_ERROR_FAILURE);
     1: 
     1:   return hookObj->GetHookEnumerator(aResult);
     1: }
     1: 
 79445: bool
     1: nsEditorHookUtils::DoInsertionHook(nsIDOMDocument *aDoc, nsIDOMEvent *aDropEvent,  
     1:                                    nsITransferable *aTrans)
     1: {
     1:   nsCOMPtr<nsISimpleEnumerator> enumerator;
     1:   GetHookEnumeratorFromDocument(aDoc, getter_AddRefs(enumerator));
 80486:   NS_ENSURE_TRUE(enumerator, true);
     1: 
 79445:   bool hasMoreHooks = false;
     1:   while (NS_SUCCEEDED(enumerator->HasMoreElements(&hasMoreHooks)) && hasMoreHooks)
     1:   {
     1:     nsCOMPtr<nsISupports> isupp;
     1:     if (NS_FAILED(enumerator->GetNext(getter_AddRefs(isupp))))
     1:       break;
     1: 
     1:     nsCOMPtr<nsIClipboardDragDropHooks> override = do_QueryInterface(isupp);
     1:     if (override)
     1:     {
 79445:       bool doInsert = true;
 56879: #ifdef DEBUG
 56879:       nsresult hookResult =
 56879: #endif
 56879:       override->OnPasteOrDrop(aDropEvent, aTrans, &doInsert);
     1:       NS_ASSERTION(NS_SUCCEEDED(hookResult), "hook failure in OnPasteOrDrop");
 80486:       NS_ENSURE_TRUE(doInsert, false);
     1:     }
     1:   }
     1: 
 80486:   return true;
     1: }
