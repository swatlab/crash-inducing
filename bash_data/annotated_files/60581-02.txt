    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* Wrapper object for reflecting native xpcom objects into JavaScript. */
    1: 
    1: #include "xpcprivate.h"
    1: #include "nsCRT.h"
 4042: #include "XPCWrapper.h"
21618: #include "nsWrapperCache.h"
30001: #include "xpclog.h"
41138: #include "jstl.h"
48124: #include "nsINode.h"
48124: #include "xpcquickstubs.h"
55599: #include "jsproxy.h"
55604: #include "AccessCheck.h"
55659: #include "WrapperFactory.h"
    1: 
    1: /***************************************************************************/
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(XPCWrappedNative)
    1: 
    1: NS_IMETHODIMP
12418: NS_CYCLE_COLLECTION_CLASSNAME(XPCWrappedNative)::RootAndUnlinkJSObjects(void *p)
12418: {
12418:     XPCWrappedNative *tmp = static_cast<XPCWrappedNative*>(p);
12418:     tmp->ExpireWrapper();
12418:     return NS_OK;
12418: }
12418: 
12418: 
12418: NS_IMETHODIMP
 1829: NS_CYCLE_COLLECTION_CLASSNAME(XPCWrappedNative)::Traverse(void *p,
    1:                                                           nsCycleCollectionTraversalCallback &cb)
    1: {
 3233:     XPCWrappedNative *tmp = static_cast<XPCWrappedNative*>(p);
    1:     if(!tmp->IsValid())
    1:         return NS_OK;
    1: 
30096:     if (NS_UNLIKELY(cb.WantDebugInfo())) {
    1:         char name[72];
    1:         XPCNativeScriptableInfo* si = tmp->GetScriptableInfo();
    1:         if(si)
    1:             JS_snprintf(name, sizeof(name), "XPCWrappedNative (%s)",
    1:                         si->GetJSClass()->name);
    1:         else
    1:             JS_snprintf(name, sizeof(name), "XPCWrappedNative");
    1: 
30096:         cb.DescribeNode(RefCounted, tmp->mRefCnt.get(),
30096:                         sizeof(XPCWrappedNative), name);
30096:     } else {
30096:         cb.DescribeNode(RefCounted, tmp->mRefCnt.get(),
30096:                         sizeof(XPCWrappedNative), "XPCWrappedNative");
30096:     }
    1: 
    1:     if(tmp->mRefCnt.get() > 1) {
    1: 
    1:         // If our refcount is > 1, our reference to the flat JS object is
    1:         // considered "strong", and we're going to traverse it. 
    1:         //
    1:         // If our refcount is <= 1, our reference to the flat JS object is
    1:         // considered "weak", and we're *not* going to traverse it.
    1:         //
    1:         // This reasoning is in line with the slightly confusing lifecycle rules
    1:         // for XPCWrappedNatives, described in a larger comment below and also
    1:         // on our wiki at http://wiki.mozilla.org/XPConnect_object_wrapping 
    1: 
    1:         JSObject *obj = nsnull;
    1:         nsresult rv = tmp->GetJSObject(&obj);
    1:         if(NS_SUCCEEDED(rv))
    1:             cb.NoteScriptChild(nsIProgrammingLanguage::JAVASCRIPT, obj);
    1:     }
    1: 
    1:     // XPCWrappedNative keeps its native object alive.
    1:     cb.NoteXPCOMChild(tmp->GetIdentityObject());
    1: 
 7286:     tmp->NoteTearoffs(cb);
 7286: 
    1:     return NS_OK;
    1: }
    1: 
 7286: void
 7286: XPCWrappedNative::NoteTearoffs(nsCycleCollectionTraversalCallback& cb)
    1: {
 7286:     // Tearoffs hold their native object alive. If their JS object hasn't been
 7286:     // finalized yet we'll note the edge between the JS object and the native
 7286:     // (see nsXPConnect::Traverse), but if their JS object has been finalized
 7286:     // then the tearoff is only reachable through the XPCWrappedNative, so we
 7286:     // record an edge here.
 7286:     XPCWrappedNativeTearOffChunk* chunk;
 7286:     for(chunk = &mFirstChunk; chunk; chunk = chunk->mNextChunk)
 7286:     {
 7286:         XPCWrappedNativeTearOff* to = chunk->mTearOffs;
 7286:         for(int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK-1; i >= 0; i--, to++)
 7286:         {
 7286:             JSObject* jso = to->GetJSObject();
 7286:             if(!jso)
 7286:             {
 7286:                 cb.NoteXPCOMChild(to->GetNative());
    1:             }
 7286:         }
 7286:     }
 7286: }
 7286: 
    1: #ifdef XPC_CHECK_CLASSINFO_CLAIMS
    1: static void DEBUG_CheckClassInfoClaims(XPCWrappedNative* wrapper);
    1: #else
    1: #define DEBUG_CheckClassInfoClaims(wrapper) ((void)0)
    1: #endif
    1: 
    1: #ifdef XPC_TRACK_WRAPPER_STATS
    1: static int DEBUG_TotalWrappedNativeCount;
    1: static int DEBUG_TotalLiveWrappedNativeCount;
    1: static int DEBUG_TotalMaxWrappedNativeCount;
    1: static int DEBUG_WrappedNativeWithProtoCount;
    1: static int DEBUG_LiveWrappedNativeWithProtoCount;
    1: static int DEBUG_MaxWrappedNativeWithProtoCount;
    1: static int DEBUG_WrappedNativeNoProtoCount;
    1: static int DEBUG_LiveWrappedNativeNoProtoCount;
    1: static int DEBUG_MaxWrappedNativeNoProtoCount;
    1: static int DEBUG_WrappedNativeTotalCalls;
    1: static int DEBUG_WrappedNativeMethodCalls;
    1: static int DEBUG_WrappedNativeGetterCalls;
    1: static int DEBUG_WrappedNativeSetterCalls;
    1: #define DEBUG_CHUNKS_TO_COUNT 4
    1: static int DEBUG_WrappedNativeTearOffChunkCounts[DEBUG_CHUNKS_TO_COUNT+1];
    1: static PRBool  DEBUG_DumpedWrapperStats;
    1: #endif
    1: 
    1: #ifdef DEBUG
    1: static void DEBUG_TrackNewWrapper(XPCWrappedNative* wrapper)
    1: {
    1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
    1:     if(wrapper->GetRuntime())
    1:         wrapper->GetRuntime()->DEBUG_AddWrappedNative(wrapper);
    1:     else
    1:         NS_ERROR("failed to add wrapper");
    1: #endif
    1: #ifdef XPC_TRACK_WRAPPER_STATS
    1:     DEBUG_TotalWrappedNativeCount++;
    1:     DEBUG_TotalLiveWrappedNativeCount++;
    1:     if(DEBUG_TotalMaxWrappedNativeCount < DEBUG_TotalLiveWrappedNativeCount)
    1:         DEBUG_TotalMaxWrappedNativeCount = DEBUG_TotalLiveWrappedNativeCount;
    1: 
    1:     if(wrapper->HasProto())
    1:     {
    1:         DEBUG_WrappedNativeWithProtoCount++;
    1:         DEBUG_LiveWrappedNativeWithProtoCount++;
    1:         if(DEBUG_MaxWrappedNativeWithProtoCount < DEBUG_LiveWrappedNativeWithProtoCount)
    1:             DEBUG_MaxWrappedNativeWithProtoCount = DEBUG_LiveWrappedNativeWithProtoCount;
    1:     }
    1:     else
    1:     {
    1:         DEBUG_WrappedNativeNoProtoCount++;
    1:         DEBUG_LiveWrappedNativeNoProtoCount++;
    1:         if(DEBUG_MaxWrappedNativeNoProtoCount < DEBUG_LiveWrappedNativeNoProtoCount)
    1:             DEBUG_MaxWrappedNativeNoProtoCount = DEBUG_LiveWrappedNativeNoProtoCount;
    1:     }
    1: #endif
    1: }
    1: 
    1: static void DEBUG_TrackDeleteWrapper(XPCWrappedNative* wrapper)
    1: {
    1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
20312:     nsXPConnect::GetRuntimeInstance()->DEBUG_RemoveWrappedNative(wrapper);
    1: #endif
    1: #ifdef XPC_TRACK_WRAPPER_STATS
    1:     DEBUG_TotalLiveWrappedNativeCount--;
    1:     if(wrapper->HasProto())
    1:         DEBUG_LiveWrappedNativeWithProtoCount--;
    1:     else
    1:         DEBUG_LiveWrappedNativeNoProtoCount--;
    1: 
    1:     int extraChunkCount = wrapper->DEBUG_CountOfTearoffChunks() - 1;
    1:     if(extraChunkCount > DEBUG_CHUNKS_TO_COUNT)
    1:         extraChunkCount = DEBUG_CHUNKS_TO_COUNT;
    1:     DEBUG_WrappedNativeTearOffChunkCounts[extraChunkCount]++;
    1: #endif
    1: }
    1: static void DEBUG_TrackWrapperCall(XPCWrappedNative* wrapper,
    1:                                    XPCWrappedNative::CallMode mode)
    1: {
    1: #ifdef XPC_TRACK_WRAPPER_STATS
    1:     DEBUG_WrappedNativeTotalCalls++;
    1:     switch(mode)
    1:     {
    1:         case XPCWrappedNative::CALL_METHOD:
    1:             DEBUG_WrappedNativeMethodCalls++;
    1:             break;
    1:         case XPCWrappedNative::CALL_GETTER:
    1:             DEBUG_WrappedNativeGetterCalls++;
    1:             break;
    1:         case XPCWrappedNative::CALL_SETTER:
    1:             DEBUG_WrappedNativeSetterCalls++;
    1:             break;
    1:         default:
    1:             NS_ERROR("bad value");
    1:     }
    1: #endif
    1: }
    1: 
    1: static void DEBUG_TrackShutdownWrapper(XPCWrappedNative* wrapper)
    1: {
    1: #ifdef XPC_TRACK_WRAPPER_STATS
    1:     if(!DEBUG_DumpedWrapperStats)
    1:     {
    1:         DEBUG_DumpedWrapperStats = PR_TRUE;
    1:         printf("%d WrappedNatives were constructed. "
    1:                "(%d w/ protos, %d w/o)\n",
    1:                DEBUG_TotalWrappedNativeCount,
    1:                DEBUG_WrappedNativeWithProtoCount,
    1:                DEBUG_WrappedNativeNoProtoCount);
    1: 
    1:         printf("%d WrappedNatives max alive at one time. "
    1:                "(%d w/ protos, %d w/o)\n",
    1:                DEBUG_TotalMaxWrappedNativeCount,
    1:                DEBUG_MaxWrappedNativeWithProtoCount,
    1:                DEBUG_MaxWrappedNativeNoProtoCount);
    1: 
    1:         printf("%d WrappedNatives alive now. "
    1:                "(%d w/ protos, %d w/o)\n",
    1:                DEBUG_TotalLiveWrappedNativeCount,
    1:                DEBUG_LiveWrappedNativeWithProtoCount,
    1:                DEBUG_LiveWrappedNativeNoProtoCount);
    1: 
    1:         printf("%d calls to WrappedNatives. "
    1:                "(%d methods, %d getters, %d setters)\n",
    1:                DEBUG_WrappedNativeTotalCalls,
    1:                DEBUG_WrappedNativeMethodCalls,
    1:                DEBUG_WrappedNativeGetterCalls,
    1:                DEBUG_WrappedNativeSetterCalls);
    1: 
    1:         printf("(wrappers / tearoffs): (");
    1:         int i;
    1:         for(i = 0; i < DEBUG_CHUNKS_TO_COUNT; i++)
    1:         {
    1:             printf("%d / %d, ",
    1:                    DEBUG_WrappedNativeTearOffChunkCounts[i],
    1:                    (i+1) * XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK);
    1:         }
    1:         printf("%d / more)\n", DEBUG_WrappedNativeTearOffChunkCounts[i]);
    1:     }
    1: #endif
    1: }
    1: #else
    1: #define DEBUG_TrackNewWrapper(wrapper) ((void)0)
    1: #define DEBUG_TrackDeleteWrapper(wrapper) ((void)0)
    1: #define DEBUG_TrackWrapperCall(wrapper, mode) ((void)0)
    1: #define DEBUG_TrackShutdownWrapper(wrapper) ((void)0)
    1: #endif
    1: 
    1: /***************************************************************************/
30001: static nsresult
30001: FinishCreate(XPCCallContext& ccx,
30001:              XPCWrappedNativeScope* Scope,
30001:              XPCNativeInterface* Interface,
30001:              nsWrapperCache *cache,
30001:              XPCWrappedNative* wrapper,
30001:              XPCWrappedNative** resultWrapper);
    1: 
    1: // static
    1: nsresult
    1: XPCWrappedNative::GetNewOrUsed(XPCCallContext& ccx,
51515:                                xpcObjectHelper& helper,
    1:                                XPCWrappedNativeScope* Scope,
    1:                                XPCNativeInterface* Interface,
    1:                                JSBool isGlobal,
    1:                                XPCWrappedNative** resultWrapper)
    1: {
51515:     nsWrapperCache *cache = helper.GetWrapperCache();
51515: 
26411:     NS_ASSERTION(!cache || !cache->GetWrapper(),
26411:                  "We assume the caller already checked if it could get the "
26411:                  "wrapper from the cache.");
26411: 
    1:     nsresult rv;
    1: 
    1:     NS_ASSERTION(!Scope->GetRuntime()->GetThreadRunningGC(), 
    1:                  "XPCWrappedNative::GetNewOrUsed called during GC");
51515: 
51515:     nsISupports *identity;
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     // XXX This is done for the benefit of some warped COM implementations
    1:     // where QI(IID_IUnknown, a.b) == QI(IID_IUnknown, a). If someone passes
    1:     // in a pointer that hasn't been QI'd to IDispatch properly this could
    1:     // create multiple wrappers for the same object, creating a fair bit of
    1:     // confusion.
22842:     PRBool isIDispatch = Interface &&
22842:                          Interface->GetIID()->Equals(NSID_IDISPATCH);
    1:     if(isIDispatch)
51515:         identity = helper.Object();
    1:     else
    1: #endif
51515:         identity = helper.GetCanonical();
    1: 
    1:     if(!identity)
    1:     {
    1:         NS_ERROR("This XPCOM object fails in QueryInterface to nsISupports!");
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     XPCLock* mapLock = Scope->GetRuntime()->GetMapLock();
    1:     
    1:     // We use an AutoMarkingPtr here because it is possible for JS gc to happen
    1:     // after we have Init'd the wrapper but *before* we add it to the hashtable.
    1:     // This would cause the mSet to get collected and we'd later crash. I've
    1:     // *seen* this happen.
    1:     AutoMarkingWrappedNativePtr wrapper(ccx);
    1: 
    1:     Native2WrappedNativeMap* map = Scope->GetWrappedNativeMap();
26411:     if(!cache)
26411:     {
    1:         {   // scoped lock
    1:             XPCAutoLock lock(mapLock);
    1:             wrapper = map->Find(identity);
    1:             if(wrapper)
    1:                 wrapper->AddRef();
    1:         }
    1: 
    1:         if(wrapper)
    1:         {
26411:             if(Interface &&
26411:                !wrapper->FindTearOff(ccx, Interface, JS_FALSE, &rv))
    1:             {
    1:                 NS_RELEASE(wrapper);
    1:                 NS_ASSERTION(NS_FAILED(rv), "returning NS_OK on failure");
    1:                 return rv;
    1:             }
    1:             DEBUG_CheckWrapperThreadSafety(wrapper);
    1:             *resultWrapper = wrapper;
    1:             return NS_OK;
    1:         }
26411:     }
26411: #ifdef DEBUG
26411:     else if(!cache->GetWrapper())
26411:     {   // scoped lock
26411:         XPCAutoLock lock(mapLock);
26411:         NS_ASSERTION(!map->Find(identity),
26411:                      "There's a wrapper in the hashtable but it wasn't cached?");
26411:     }
26411: #endif
    1: 
    1:     // There is a chance that the object wants to have the self-same JSObject
    1:     // reflection regardless of the scope into which we are reflecting it.
    1:     // Many DOM objects require this. The scriptable helper specifies this
    1:     // in preCreate by indicating a 'parent' of a particular scope.
    1:     //
    1:     // To handle this we need to get the scriptable helper early and ask it.
    1:     // It is possible that we will then end up forwarding this entire call
    1:     // to this same function but with a different scope.
    1: 
    1:     // If we are making a wrapper for the nsIClassInfo interface then
    1:     // We *don't* want to have it use the prototype meant for instances
    1:     // of that class.
22842:     JSBool isClassInfo = Interface &&
22842:                          Interface->GetIID()->Equals(NS_GET_IID(nsIClassInfo));
    1: 
51515:     nsIClassInfo *info = helper.GetClassInfo();
    1: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     // If this is an IDispatch wrapper and it didn't give us a class info
    1:     // we'll provide a default one
51515:     nsCOMPtr<nsIClassInfo> dispatchInfo;
    1:     if(isIDispatch && !info)
    1:     {
51515:         dispatchInfo = dont_AddRef(static_cast<nsIClassInfo*>
 3233:                                       (XPCIDispatchClassInfo::GetSingleton()));
51515:         info = dispatchInfo;
    1:     }
    1: #endif
    1: 
    1:     XPCNativeScriptableCreateInfo sciProto;
40489:     XPCNativeScriptableCreateInfo sci;
    1: 
    1:     // Gather scriptable create info if we are wrapping something
    1:     // other than an nsIClassInfo object. We need to not do this for
    1:     // nsIClassInfo objects because often nsIClassInfo implementations
42263:     // are also nsIXPCScriptable helper implementations, but the helper
    1:     // code is obviously intended for the implementation of the class
    1:     // described by the nsIClassInfo, not for the class info object
    1:     // itself.
40489:     const XPCNativeScriptableCreateInfo& sciWrapper =
40489:         isClassInfo ? sci :
40489:         GatherScriptableCreateInfo(identity, info, sciProto, sci);
    1: 
    1:     JSObject* parent = Scope->GetGlobalJSObject();
    1: 
    1:     jsval newParentVal = JSVAL_NULL;
    1:     XPCMarkableJSVal newParentVal_markable(&newParentVal);
    1:     AutoMarkingJSVal newParentVal_automarker(ccx, &newParentVal_markable);
47574:     JSBool needsSOW = JS_FALSE;
47574:     JSBool needsCOW = JS_FALSE;
    1: 
54733:     JSAutoEnterCompartment ac;
53565: 
    1:     if(sciWrapper.GetFlags().WantPreCreate())
    1:     {
    1:         JSObject* plannedParent = parent;
    1:         nsresult rv = sciWrapper.GetCallback()->PreCreate(identity, ccx,
    1:                                                           parent, &parent);
    1:         if(NS_FAILED(rv))
    1:             return rv;
    1: 
47410:         if(rv == NS_SUCCESS_CHROME_ACCESS_ONLY)
47574:             needsSOW = JS_TRUE;
27664:         rv = NS_OK;
27664: 
55659:         NS_ASSERTION(!xpc::WrapperFactory::IsXrayWrapper(parent),
55659:                      "Xray wrapper being used to parent XPCWrappedNative?");
    1: 
55601:         if(!ac.enter(ccx, parent))
55601:             return NS_ERROR_FAILURE;
55601: 
    1:         if(parent != plannedParent)
    1:         {
    1:             XPCWrappedNativeScope* betterScope =
    1:                 XPCWrappedNativeScope::FindInJSObjectScope(ccx, parent);
    1:             if(betterScope != Scope)
51515:                 return GetNewOrUsed(ccx, helper, betterScope, Interface,
51515:                                     isGlobal, resultWrapper);
    1: 
    1:             newParentVal = OBJECT_TO_JSVAL(parent);
    1:         }
    1: 
    1:         // Take the performance hit of checking the hashtable again in case
    1:         // the preCreate call caused the wrapper to get created through some
    1:         // interesting path (the DOM code tends to make this happen sometimes).
    1: 
26411:         if(cache)
26411:         {
30001:             JSObject *cached = cache->GetWrapper();
30001:             if(cached)
30001:             {
33785:                 if(IS_SLIM_WRAPPER_OBJECT(cached))
30001:                 {
30001:                     nsRefPtr<XPCWrappedNative> morphed;
30001:                     if(!XPCWrappedNative::Morph(ccx, cached, Interface, cache,
30001:                                                 getter_AddRefs(morphed)))
30001:                         return NS_ERROR_FAILURE;
30001: 
30001:                     wrapper = morphed.forget().get();
30001:                 } else {
30001:                     wrapper =
30001:                         static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(cached));
26411:                     if(wrapper)
26411:                         wrapper->AddRef();
26411:                 }
30001:             }
30001:         }
26411:         else
    1:         {   // scoped lock
    1:             XPCAutoLock lock(mapLock);
    1:             wrapper = map->Find(identity);
    1:             if(wrapper)
    1:                 wrapper->AddRef();
    1:         }
    1: 
    1:         if(wrapper)
    1:         {
22842:             if(Interface && !wrapper->FindTearOff(ccx, Interface, JS_FALSE, &rv))
    1:             {
    1:                 NS_RELEASE(wrapper);
    1:                 NS_ASSERTION(NS_FAILED(rv), "returning NS_OK on failure");
    1:                 return rv;
    1:             }
    1:             DEBUG_CheckWrapperThreadSafety(wrapper);
    1:             *resultWrapper = wrapper;
    1:             return NS_OK;
    1:         }
    1:     }
30625:     else
30625:     {
54733:         if(!ac.enter(ccx, parent))
53565:             return NS_ERROR_FAILURE;
53565: 
51515:         nsISupports *Object = helper.Object();
30625:         if(nsXPCWrappedJSClass::IsWrappedJS(Object))
30625:         {
30625:             nsCOMPtr<nsIXPConnectWrappedJS> wrappedjs(do_QueryInterface(Object));
30625:             JSObject *obj;
30625:             wrappedjs->GetJSObject(&obj);
58714:             if(xpc::AccessCheck::isChrome(obj->compartment()) &&
58714:                !xpc::AccessCheck::isChrome(Scope->GetGlobalJSObject()->compartment()))
30625:             {
47574:                 needsCOW = JS_TRUE;
30625:             }
30625:         }
30625:     }
    1: 
    1:     AutoMarkingWrappedNativeProtoPtr proto(ccx);
    1: 
    1:     // If there is ClassInfo (and we are not building a wrapper for the
    1:     // nsIClassInfo interface) then we use a wrapper that needs a prototype.
    1: 
    1:     // Note that the security check happens inside FindTearOff - after the
    1:     // wrapper is actually created, but before JS code can see it.
    1: 
    1:     if(info && !isClassInfo)
    1:     {
    1:         proto = XPCWrappedNativeProto::GetNewOrUsed(ccx, Scope, info, &sciProto,
    1:                                                     JS_FALSE, isGlobal);
    1:         if(!proto)
    1:             return NS_ERROR_FAILURE;
    1: 
21218:         proto->CacheOffsets(identity);
21218: 
58747:         wrapper = new XPCWrappedNative(identity, proto);
    1:         if(!wrapper)
    1:             return NS_ERROR_FAILURE;
    1:     }
    1:     else
    1:     {
28864:         AutoMarkingNativeInterfacePtr iface(ccx, Interface);
28864:         if(!iface)
28864:             iface = XPCNativeInterface::GetISupports(ccx);
28864: 
    1:         AutoMarkingNativeSetPtr set(ccx);
28864:         set = XPCNativeSet::GetNewOrUsed(ccx, nsnull, iface, 0);
    1: 
    1:         if(!set)
    1:             return NS_ERROR_FAILURE;
    1: 
58747:         wrapper = new XPCWrappedNative(identity, Scope, set);
    1:         if(!wrapper)
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         DEBUG_ReportShadowedMembers(set, wrapper, nsnull);
    1:     }
    1: 
26411:     // The strong reference was taken over by the wrapper, so make the nsCOMPtr
26411:     // forget about it.
51515:     helper.forgetCanonical();
26411: 
    1:     NS_ADDREF(wrapper);
    1: 
55659:     NS_ASSERTION(!xpc::WrapperFactory::IsXrayWrapper(parent),
55659:                  "Xray wrapper being used to parent XPCWrappedNative?");
    1: 
    1:     if(!wrapper->Init(ccx, parent, isGlobal, &sciWrapper))
    1:     {
    1:         NS_RELEASE(wrapper);
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
22842:     if(Interface && !wrapper->FindTearOff(ccx, Interface, JS_FALSE, &rv))
    1:     {
30001:         // Second reference will be released by the FlatJSObject's finalizer.
    1:         wrapper->Release();
    1:         NS_ASSERTION(NS_FAILED(rv), "returning NS_OK on failure");
    1:         return rv;
    1:     }
    1: 
47574:     if(needsSOW)
47574:         wrapper->SetNeedsSOW();
47574:     if(needsCOW)
47574:         wrapper->SetNeedsCOW();
28705: 
30001:     return FinishCreate(ccx, Scope, Interface, cache, wrapper, resultWrapper);
30001: }
30001: 
30001: static nsresult
30001: FinishCreate(XPCCallContext& ccx,
30001:              XPCWrappedNativeScope* Scope,
30001:              XPCNativeInterface* Interface,
30001:              nsWrapperCache *cache,
30001:              XPCWrappedNative* wrapper,
30001:              XPCWrappedNative** resultWrapper)
30001: {
    1: #if DEBUG_xpc_leaks
    1:     {
    1:         char* s = wrapper->ToString(ccx);
57794:         NS_ASSERTION(wrapper->IsValid(), "eh?");
    1:         printf("Created wrapped native %s, flat JSObject is %p\n",
57794:                s, (void*)wrapper->GetFlatJSObjectNoMark());
    1:         if(s)
    1:             JS_smprintf_free(s);
    1:     }
    1: #endif
    1: 
30001:     XPCLock* mapLock = Scope->GetRuntime()->GetMapLock();
30001:     Native2WrappedNativeMap* map = Scope->GetWrappedNativeMap();
30001: 
    1:     // Redundant wrapper must be killed outside of the map lock.
    1:     XPCWrappedNative* wrapperToKill = nsnull;
    1: 
    1:     {   // scoped lock
    1:         XPCAutoLock lock(mapLock);
    1: 
    1:         // Deal with the case where the wrapper got created as a side effect
    1:         // of one of our calls out of this code (or on another thread).
    1:         XPCWrappedNative* wrapper2 = map->Add(wrapper);
    1:         if(!wrapper2)
    1:         {
    1:             NS_ERROR("failed to add our wrapper!");
    1:             wrapperToKill = wrapper;
    1:             wrapper = nsnull;
    1:         }
    1:         else if(wrapper2 != wrapper)
    1:         {
    1:             NS_ADDREF(wrapper2);
    1:             wrapperToKill = wrapper;
    1:             wrapper = wrapper2;
    1:         }
    1:     }
    1: 
    1:     if(wrapperToKill)
    1:     {
    1:         // Second reference will be released by the FlatJSObject's finializer.
    1:         wrapperToKill->Release();
    1:     }
    1:     else if(wrapper)
    1:     {
57794:         JSObject *flat = wrapper->GetFlatJSObjectAndMark();
30001:         NS_ASSERTION(!cache || !cache->GetWrapper() ||
30001:                      flat == cache->GetWrapper(),
30001:                      "This object has a cached wrapper that's different from "
30001:                      "the JSObject held by its native wrapper?");
30001: 
30001:         if(cache && !cache->GetWrapper())
30001:             cache->SetWrapper(flat);
26503: 
    1:         // Our newly created wrapper is the one that we just added to the table.
    1:         // All is well. Call PostCreate as necessary.
    1:         XPCNativeScriptableInfo* si = wrapper->GetScriptableInfo();
    1:         if(si && si->GetFlags().WantPostCreate())
    1:         {
57794:             nsresult rv = si->GetCallback()->PostCreate(wrapper, ccx, flat);
    1:             if(NS_FAILED(rv))
    1:             {
14986:                 // PostCreate failed and that's Very Bad. We'll remove it from
14986:                 // the map and mark it as invalid, but the PostCreate function
14986:                 // may have handed the partially-constructed-and-now-invalid
14986:                 // wrapper to someone before failing. Or, perhaps worse, the
14986:                 // PostCreate call could have triggered code that reentered
14986:                 // XPConnect and tried to wrap the same object. In that case
14986:                 // *we* hand out the invalid wrapper since it is already in our
14986:                 // map :(
14986:                 NS_ERROR("PostCreate failed! This is known to cause "
14986:                          "inconsistent state for some class types and may even "
14986:                          "cause a crash in combination with a JS GC. Fix the "
14986:                          "failing PostCreate ASAP!");
14986: 
    1:                 {   // scoped lock
    1:                     XPCAutoLock lock(mapLock);
    1:                     map->Remove(wrapper);
    1:                 }
    1: 
14986:                 // This would be a good place to tell the wrapper not to remove
14986:                 // itself from the map when it dies... See bug 429442.
14986: 
26503:                 if(cache)
26503:                     cache->ClearWrapper();
    1:                 wrapper->Release();
    1:                 return rv;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if(!wrapper)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     DEBUG_CheckClassInfoClaims(wrapper);
    1:     *resultWrapper = wrapper;
    1:     return NS_OK;
    1: }
    1: 
    1: // static
    1: nsresult
30001: XPCWrappedNative::Morph(XPCCallContext& ccx,
30001:                         JSObject* existingJSObject,
30001:                         XPCNativeInterface* Interface,
30001:                         nsWrapperCache *cache,
30001:                         XPCWrappedNative** resultWrapper)
30001: {
30001:     NS_ASSERTION(IS_SLIM_WRAPPER(existingJSObject),
30001:                  "Trying to morph a JSObject that's not a slim wrapper?");
30001: 
30001:     nsISupports *identity =
30001:         static_cast<nsISupports*>(xpc_GetJSPrivate(existingJSObject));
30001:     XPCWrappedNativeProto *proto = GetSlimWrapperProto(existingJSObject);
30001: 
30001:     // We use an AutoMarkingPtr here because it is possible for JS gc to happen
30001:     // after we have Init'd the wrapper but *before* we add it to the hashtable.
30001:     // This would cause the mSet to get collected and we'd later crash. I've
30001:     // *seen* this happen.
30001:     AutoMarkingWrappedNativePtr wrapper(ccx);
30001: 
30001: #if DEBUG
30001:     // FIXME Can't assert this until
30001:     //       https://bugzilla.mozilla.org/show_bug.cgi?id=343141 is fixed.
30001: #if 0
30001:     if(proto->GetScriptableInfo()->GetFlags().WantPreCreate())
30001:     {
30001:         JSObject* parent = JS_GetParent(ccx, existingJSObject);
30001:         JSObject* plannedParent = parent;
30001:         nsresult rv =
30001:             proto->GetScriptableInfo()->GetCallback()->PreCreate(identity, ccx,
30001:                                                                  parent,
30001:                                                                  &parent);
30001:         if(NS_FAILED(rv))
30001:             return rv;
30001: 
30001:         NS_ASSERTION(parent == plannedParent,
30001:                      "PreCreate returned a different parent");
30001:     }
30001: #endif
30001: #endif
30001: 
30001:     wrapper = new XPCWrappedNative(dont_AddRef(identity), proto);
30001:     if(!wrapper)
30001:         return NS_ERROR_FAILURE;
30001: 
30001:     NS_ADDREF(wrapper);
30001: 
55659:     NS_ASSERTION(!xpc::WrapperFactory::IsXrayWrapper(existingJSObject->getParent()),
55659:                  "Xray wrapper being used to parent XPCWrappedNative?");
30001: 
55601:     JSAutoEnterCompartment ac;
55601:     if(!ac.enter(ccx, existingJSObject) || !wrapper->Init(ccx, existingJSObject))
30001:     {
30001:         NS_RELEASE(wrapper);
30001:         return NS_ERROR_FAILURE;
30001:     }
30001: 
30001:     nsresult rv;
30001:     if(Interface && !wrapper->FindTearOff(ccx, Interface, JS_FALSE, &rv))
30001:     {
30001:         // Second reference will be released by the FlatJSObject's finalizer.
30001:         wrapper->Release();
30001:         NS_ASSERTION(NS_FAILED(rv), "returning NS_OK on failure");
30001:         return rv;
30001:     }
30001: 
30001:     return FinishCreate(ccx, wrapper->GetScope(), Interface, cache, wrapper,
30001:                         resultWrapper);
30001: }
30001: 
30001: // static
30001: nsresult
    1: XPCWrappedNative::GetUsedOnly(XPCCallContext& ccx,
    1:                               nsISupports* Object,
    1:                               XPCWrappedNativeScope* Scope,
    1:                               XPCNativeInterface* Interface,
    1:                               XPCWrappedNative** resultWrapper)
    1: {
    1:     NS_ASSERTION(Object, "XPCWrappedNative::GetUsedOnly was called with a null Object");
21618: 
21618:     XPCWrappedNative* wrapper;
21618:     nsWrapperCache* cache = nsnull;
21618:     CallQueryInterface(Object, &cache);
21618:     if(cache)
21618:     {
30001:         JSObject *flat = cache->GetWrapper();
33785:         if(flat && IS_SLIM_WRAPPER_OBJECT(flat) && !MorphSlimWrapper(ccx, flat))
30001:            return NS_ERROR_FAILURE;
30001: 
30001:         wrapper = flat ?
30001:                   static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(flat)) :
30001:                   nsnull;
30001: 
21618:         if(!wrapper)
21618:         {
21618:             *resultWrapper = nsnull;
21618:             return NS_OK;
21618:         }
21618:         NS_ADDREF(wrapper);
21618:     }
21618:     else
21618:     {
    1:         nsCOMPtr<nsISupports> identity;
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:         // XXX See GetNewOrUsed for more info on this
    1:         if(Interface->GetIID()->Equals(NSID_IDISPATCH))
    1:             identity = Object;
    1:         else
    1: #endif
    1:             identity = do_QueryInterface(Object);
    1: 
    1:         if(!identity)
    1:         {
    1:             NS_ERROR("This XPCOM object fails in QueryInterface to nsISupports!");
    1:             return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         Native2WrappedNativeMap* map = Scope->GetWrappedNativeMap();
    1: 
    1:         {   // scoped lock
    1:             XPCAutoLock lock(Scope->GetRuntime()->GetMapLock());
    1:             wrapper = map->Find(identity);
    1:             if(!wrapper)
    1:             {
    1:                 *resultWrapper = nsnull;
    1:                 return NS_OK;
    1:             }
    1:             NS_ADDREF(wrapper);
    1:         }
21618:     }
    1: 
    1:     nsresult rv;
22842:     if(Interface && !wrapper->FindTearOff(ccx, Interface, JS_FALSE, &rv))
    1:     {
    1:         NS_RELEASE(wrapper);
    1:         NS_ASSERTION(NS_FAILED(rv), "returning NS_OK on failure");
    1:         return rv;
    1:     }
    1: 
    1:     *resultWrapper = wrapper;
    1:     return NS_OK;
    1: }
    1: 
    1: // This ctor is used if this object will have a proto.
26411: XPCWrappedNative::XPCWrappedNative(already_AddRefed<nsISupports> aIdentity,
    1:                                    XPCWrappedNativeProto* aProto)
    1:     : mMaybeProto(aProto),
24206:       mSet(aProto->GetSet()),
48470:       mFlatJSObject(INVALID_OBJECT), // non-null to pass IsValid() test
    1:       mScriptableInfo(nsnull),
30625:       mWrapperWord(0)
60581: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
60581:     , mThread(PR_GetCurrentThread())
60581: #endif
    1: {
26411:     mIdentity = aIdentity.get();
    1: 
    1:     NS_ASSERTION(mMaybeProto, "bad ctor param");
24206:     NS_ASSERTION(mSet, "bad ctor param");
    1: 
    1:     DEBUG_TrackNewWrapper(this);
    1: }
    1: 
    1: // This ctor is used if this object will NOT have a proto.
26411: XPCWrappedNative::XPCWrappedNative(already_AddRefed<nsISupports> aIdentity,
    1:                                    XPCWrappedNativeScope* aScope,
    1:                                    XPCNativeSet* aSet)
    1: 
    1:     : mMaybeScope(TagScope(aScope)),
24206:       mSet(aSet),
48470:       mFlatJSObject(INVALID_OBJECT), // non-null to pass IsValid() test
    1:       mScriptableInfo(nsnull),
30625:       mWrapperWord(0)
60581: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
60581:     , mThread(PR_GetCurrentThread())
60581: #endif
    1: {
26411:     mIdentity = aIdentity.get();
    1: 
    1:     NS_ASSERTION(aScope, "bad ctor param");
    1:     NS_ASSERTION(aSet, "bad ctor param");
    1: 
    1:     DEBUG_TrackNewWrapper(this);
    1: }
    1: 
    1: XPCWrappedNative::~XPCWrappedNative()
    1: {
    1:     DEBUG_TrackDeleteWrapper(this);
    1: 
    1:     XPCWrappedNativeProto* proto = GetProto();
    1: 
    1:     if(mScriptableInfo &&
    1:        (!HasProto() ||
    1:         (proto && proto->GetScriptableInfo() != mScriptableInfo)))
    1:     {
    1:         delete mScriptableInfo;
    1:     }
    1: 
12418:     XPCWrappedNativeScope *scope = GetScope();
12418:     if(scope)
12418:     {
12418:         Native2WrappedNativeMap* map = scope->GetWrappedNativeMap();
12418: 
12418:         // scoped lock
    1:         XPCAutoLock lock(GetRuntime()->GetMapLock());
14986: 
14986:         // Post-1.9 we should not remove this wrapper from the map if it is
14986:         // uninitialized.
    1:         map->Remove(this);
    1:     }
    1: 
    1:     if(mIdentity)
    1:     {
    1:         XPCJSRuntime* rt = GetRuntime();
10184:         if(rt && rt->GetDoingFinalization())
    1:         {
    1:             if(!rt->DeferredRelease(mIdentity))
    1:             {
    1:                 NS_WARNING("Failed to append object for deferred release.");
    1:                 // XXX do we really want to do this???
    1:                 NS_RELEASE(mIdentity);
    1:             }
    1:         }
    1:         else
    1:         {
    1:             NS_RELEASE(mIdentity);
    1:         }
    1:     }
    1: }
    1: 
    1: // This is factored out so that it can be called publicly 
    1: // static
40489: void 
    1: XPCWrappedNative::GatherProtoScriptableCreateInfo(
    1:                         nsIClassInfo* classInfo,
40489:                         XPCNativeScriptableCreateInfo& sciProto)
    1: {
    1:     NS_ASSERTION(classInfo, "bad param");
40489:     NS_ASSERTION(!sciProto.GetCallback(), "bad param");
40489: 
40489:     nsXPCClassInfo *classInfoHelper = nsnull;
40489:     CallQueryInterface(classInfo, &classInfoHelper);
40489:     if(classInfoHelper)
40489:     {
40489:         nsCOMPtr<nsIXPCScriptable> helper =
40489:           dont_AddRef(static_cast<nsIXPCScriptable*>(classInfoHelper));
40489:         JSUint32 flags;
40489:         nsresult rv = classInfoHelper->GetScriptableFlags(&flags);
40489:         if(NS_FAILED(rv))
40489:             flags = 0;
40489: 
40489:         sciProto.SetCallback(helper.forget());
40489:         sciProto.SetFlags(flags);
40491:         sciProto.SetInterfacesBitmap(classInfoHelper->GetInterfacesBitmap());
40489: 
40489:         return;
40489:     }
    1: 
    1:     nsCOMPtr<nsISupports> possibleHelper;
    1:     nsresult rv = classInfo->GetHelperForLanguage(
    1:                                     nsIProgrammingLanguage::JAVASCRIPT,
    1:                                     getter_AddRefs(possibleHelper));
    1:     if(NS_SUCCEEDED(rv) && possibleHelper)
    1:     {
    1:         nsCOMPtr<nsIXPCScriptable> helper(do_QueryInterface(possibleHelper));
    1:         if(helper)
    1:         {
    1:             JSUint32 flags;
    1:             rv = helper->GetScriptableFlags(&flags);
    1:             if(NS_FAILED(rv))
    1:                 flags = 0;
    1: 
40489:             sciProto.SetCallback(helper.forget());
40489:             sciProto.SetFlags(flags);
40489:         }
40489:     }
    1: }
    1: 
    1: // static
40489: const XPCNativeScriptableCreateInfo&
    1: XPCWrappedNative::GatherScriptableCreateInfo(
    1:                         nsISupports* obj,
    1:                         nsIClassInfo* classInfo,
40489:                         XPCNativeScriptableCreateInfo& sciProto,
40489:                         XPCNativeScriptableCreateInfo& sciWrapper)
40489: {
40489:     NS_ASSERTION(!sciWrapper.GetCallback(), "bad param");
    1: 
    1:     // Get the class scriptable helper (if present)
    1:     if(classInfo)
    1:     {
    1:         GatherProtoScriptableCreateInfo(classInfo, sciProto);
    1: 
40489:         if(sciProto.GetFlags().DontAskInstanceForScriptable())
40489:             return sciProto;
    1:     }
    1: 
    1:     // Do the same for the wrapper specific scriptable
    1:     nsCOMPtr<nsIXPCScriptable> helper(do_QueryInterface(obj));
    1:     if(helper)
    1:     {
    1:         JSUint32 flags;
    1:         nsresult rv = helper->GetScriptableFlags(&flags);
    1:         if(NS_FAILED(rv))
    1:             flags = 0;
    1: 
40489:         sciWrapper.SetCallback(helper.forget());
40489:         sciWrapper.SetFlags(flags);
    1: 
    1:         // A whole series of assertions to catch bad uses of scriptable flags on
    1:         // the siWrapper...
    1: 
40489:         NS_ASSERTION(!(sciWrapper.GetFlags().WantPreCreate() &&
40489:                         !sciProto.GetFlags().WantPreCreate()),
    1:                      "Can't set WANT_PRECREATE on an instance scriptable "
    1:                      "without also setting it on the class scriptable");
    1: 
40489:         NS_ASSERTION(!(sciWrapper.GetFlags().DontEnumStaticProps() &&
40489:                         !sciProto.GetFlags().DontEnumStaticProps() &&
40489:                         sciProto.GetCallback() &&
40489:                         !sciProto.GetFlags().DontSharePrototype()),
    1:                      "Can't set DONT_ENUM_STATIC_PROPS on an instance scriptable "
    1:                      "without also setting it on the class scriptable (if present and shared)");
    1: 
40489:         NS_ASSERTION(!(sciWrapper.GetFlags().DontEnumQueryInterface() &&
40489:                         !sciProto.GetFlags().DontEnumQueryInterface() &&
40489:                         sciProto.GetCallback() &&
40489:                         !sciProto.GetFlags().DontSharePrototype()),
    1:                      "Can't set DONT_ENUM_QUERY_INTERFACE on an instance scriptable "
    1:                      "without also setting it on the class scriptable (if present and shared)");
    1: 
40489:         NS_ASSERTION(!(sciWrapper.GetFlags().DontAskInstanceForScriptable() &&
40489:                         !sciProto.GetFlags().DontAskInstanceForScriptable()),
    1:                      "Can't set DONT_ASK_INSTANCE_FOR_SCRIPTABLE on an instance scriptable "
    1:                      "without also setting it on the class scriptable");
    1: 
40489:         NS_ASSERTION(!(sciWrapper.GetFlags().ClassInfoInterfacesOnly() &&
40489:                         !sciProto.GetFlags().ClassInfoInterfacesOnly() &&
40489:                         sciProto.GetCallback() &&
40489:                         !sciProto.GetFlags().DontSharePrototype()),
    1:                      "Can't set CLASSINFO_INTERFACES_ONLY on an instance scriptable "
    1:                      "without also setting it on the class scriptable (if present and shared)");
    1: 
40489:         NS_ASSERTION(!(sciWrapper.GetFlags().AllowPropModsDuringResolve() &&
40489:                         !sciProto.GetFlags().AllowPropModsDuringResolve() &&
40489:                         sciProto.GetCallback() &&
40489:                         !sciProto.GetFlags().DontSharePrototype()),
    1:                      "Can't set ALLOW_PROP_MODS_DURING_RESOLVE on an instance scriptable "
    1:                      "without also setting it on the class scriptable (if present and shared)");
    1: 
40489:         NS_ASSERTION(!(sciWrapper.GetFlags().AllowPropModsToPrototype() &&
40489:                         !sciProto.GetFlags().AllowPropModsToPrototype() &&
40489:                         sciProto.GetCallback() &&
40489:                         !sciProto.GetFlags().DontSharePrototype()),
    1:                      "Can't set ALLOW_PROP_MODS_TO_PROTOTYPE on an instance scriptable "
    1:                      "without also setting it on the class scriptable (if present and shared)");
    1: 
40489:         NS_ASSERTION(!(sciWrapper.GetFlags().DontSharePrototype() &&
40489:                         !sciProto.GetFlags().DontSharePrototype() &&
40489:                         sciProto.GetCallback()),
    1:                      "Can't set DONT_SHARE_PROTOTYPE on an instance scriptable "
    1:                      "without also setting it on the class scriptable (if present and shared)");
40489: 
40489:         return sciWrapper;
40489:     }
40489: 
40489:     return sciProto;
    1: }
    1: 
30001: #ifdef DEBUG_slimwrappers
30001: static PRUint32 sMorphedSlimWrappers;
30001: #endif
30001: 
    1: JSBool
30001: XPCWrappedNative::Init(XPCCallContext& ccx,
30001:                        JSObject* parent, JSBool isGlobal,
    1:                        const XPCNativeScriptableCreateInfo* sci)
    1: {
    1:     // setup our scriptable info...
    1: 
    1:     if(sci->GetCallback())
    1:     {
    1:         if(HasProto())
    1:         {
    1:             XPCNativeScriptableInfo* siProto = GetProto()->GetScriptableInfo();
    1:             if(siProto && siProto->GetCallback() == sci->GetCallback())
    1:                 mScriptableInfo = siProto;
    1:         }
    1:         if(!mScriptableInfo)
    1:         {
    1:             mScriptableInfo =
    1:                 XPCNativeScriptableInfo::Construct(ccx, isGlobal, sci);
    1: 
    1:             if(!mScriptableInfo)
    1:                 return JS_FALSE;
    1: 
    1:             // If we have a one-off proto, then it should share our scriptable.
    1:             // This allows the proto's JSClass callbacks to do the right things
    1:             // (like respecting the DONT_ENUM_STATIC_PROPS flag) w/o requiring
    1:             // scriptable objects to have an nsIClassInfo.
    1:             if(HasProto() && !HasSharedProto())
    1:                 GetProto()->SetScriptableInfo(mScriptableInfo);
    1:         }
    1:     }
    1:     XPCNativeScriptableInfo* si = mScriptableInfo;
    1: 
    1:     // create our flatJSObject
    1: 
48622:     js::Class* jsclazz = si
48622:                          ? js::Valueify(si->GetJSClass())
48622:                          : &XPC_WN_NoHelper_JSClass;
    1: 
19794:     if(isGlobal)
19794:     {
19794:         // Resolving a global object's class can cause us to create a global's
19794:         // JS class without the proper global flags. Notice that here and fix
19794:         // the problem.
19794:         if(!(jsclazz->flags & JSCLASS_IS_GLOBAL))
19794:             jsclazz->flags |= JSCLASS_GLOBAL_FLAGS;
19794:     }
19794:     else
19794:         NS_ASSERTION(!(jsclazz->flags & JSCLASS_IS_GLOBAL),
19794:                      "Non-global object has the wrong flags");
19794: 
    1:     NS_ASSERTION(jsclazz &&
    1:                  jsclazz->name &&
    1:                  jsclazz->flags &&
    1:                  jsclazz->addProperty &&
    1:                  jsclazz->delProperty &&
    1:                  jsclazz->getProperty &&
    1:                  jsclazz->setProperty &&
    1:                  jsclazz->enumerate &&
    1:                  jsclazz->resolve &&
    1:                  jsclazz->convert &&
    1:                  jsclazz->finalize, "bad class");
    1: 
    1:     JSObject* protoJSObject = HasProto() ?
    1:                                 GetProto()->GetJSProtoObject() :
10478:                                 GetScope()->GetPrototypeNoHelper(ccx);
10478: 
10478:     if (!protoJSObject) {
10478:         return JS_FALSE;
10478:     }
    1: 
48622:     mFlatJSObject = xpc_NewSystemInheritingJSObject(ccx, js::Jsvalify(jsclazz),
48622:                                                     protoJSObject, parent);
    1:     if(!mFlatJSObject)
    1:         return JS_FALSE;
    1: 
30001:     return FinishInit(ccx);
30001: }
30001: 
30001: JSBool
30001: XPCWrappedNative::Init(XPCCallContext &ccx, JSObject *existingJSObject)
30001: {
33785:     // Morph the existing object.
33785:     if(!JS_SetReservedSlot(ccx, existingJSObject, 0, JSVAL_VOID))
33785:         return JS_FALSE;
33785: 
33683:     mScriptableInfo = GetProto()->GetScriptableInfo();
30001:     mFlatJSObject = existingJSObject;
30001: 
30001:     SLIM_LOG(("----- %i morphed slim wrapper (mFlatJSObject: %p, %p)\n",
30001:               ++sMorphedSlimWrappers, mFlatJSObject,
30001:               static_cast<nsISupports*>(xpc_GetJSPrivate(mFlatJSObject))));
30001: 
30001:     return FinishInit(ccx);
30001: }
30001: 
30001: JSBool
30001: XPCWrappedNative::FinishInit(XPCCallContext &ccx)
30001: {
    1:     // In the current JS engine JS_SetPrivate can't fail. But if it *did*
    1:     // fail then we would not receive our finalizer call and would not be
    1:     // able to properly cleanup. So, if it fails we null out mFlatJSObject
    1:     // to indicate the invalid state of this object and return false. 
    1:     if(!JS_SetPrivate(ccx, mFlatJSObject, this))
    1:     {
    1:         mFlatJSObject = nsnull;
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     // This reference will be released when mFlatJSObject is finalized.
    1:     // Since this reference will push the refcount to 2 it will also root
    1:     // mFlatJSObject;
    1:     NS_ASSERTION(1 == mRefCnt, "unexpected refcount value");
    1:     NS_ADDREF(this);
    1: 
30001:     if(mScriptableInfo && mScriptableInfo->GetFlags().WantCreate() &&
30001:        NS_FAILED(mScriptableInfo->GetCallback()->Create(this, ccx,
30001:                                                         mFlatJSObject)))
    1:     {
    1:         return JS_FALSE;
    1:     }
    1: 
    1: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
60581:     NS_ASSERTION(mThread, "Should have been set at construction time!");
    1: 
    1:     if(HasProto() && GetProto()->ClassIsMainThreadOnly() && !NS_IsMainThread())
58076:     {
    1:         DEBUG_ReportWrapperThreadSafetyError(ccx,
    1:             "MainThread only wrapper created on the wrong thread", this);
58076:         return JS_FALSE;
58076:     }
    1: #endif
    1: 
34273:     // A hack for bug 517665, increase the probability for GC.
34383:     JS_updateMallocCounter(ccx.GetJSContext(), 2 * sizeof(XPCWrappedNative));
34273: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(XPCWrappedNative)
    1:   NS_INTERFACE_MAP_ENTRY(nsIXPConnectWrappedNative)
    1:   NS_INTERFACE_MAP_ENTRY(nsIXPConnectJSObjectHolder)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPConnectWrappedNative)
    1: NS_INTERFACE_MAP_END_THREADSAFE
    1: 
    1: NS_IMPL_THREADSAFE_ADDREF(XPCWrappedNative)
    1: NS_IMPL_THREADSAFE_RELEASE(XPCWrappedNative)
    1: 
    1: /*
    1:  *  Wrapped Native lifetime management is messy!
    1:  *
    1:  *  - At creation we push the refcount to 2 (only one of which is owned by
    1:  *    the native caller that caused the wrapper creation).
    1:  *  - During the JS GC Mark phase we mark any wrapper with a refcount > 1.
    1:  *  - The *only* thing that can make the wrapper get destroyed is the
    1:  *    finalization of mFlatJSObject. And *that* should only happen if the only
    1:  *    reference is the single extra (internal) reference we hold.
    1:  *
    1:  *  - The wrapper has a pointer to the nsISupports 'view' of the wrapped native
    1:  *    object i.e... mIdentity. This is held until the wrapper's refcount goes
    1:  *    to zero and the wrapper is released.
    1:  *
    1:  *  - The wrapper also has 'tearoffs'. It has one tearoff for each interface
    1:  *    that is actually used on the native object. 'Used' means we have either
    1:  *    needed to QueryInterface to verify the availability of that interface
    1:  *    of that we've had to QueryInterface in order to actually make a call
    1:  *    into the wrapped object via the pointer for the given interface.
    1:  *
    1:  *  - Each tearoff's 'mNative' member (if non-null) indicates one reference
    1:  *    held by our wrapper on the wrapped native for the given interface
    1:  *    associated with the tearoff. If we release that reference then we set
    1:  *    the tearoff's 'mNative' to null.
    1:  *
    1:  *  - We use the occasion of the JavaScript GCCallback for the JSGC_MARK_END
    1:  *    event to scan the tearoffs of all wrappers for non-null mNative members
    1:  *    that represent unused references. We can tell that a given tearoff's
    1:  *    mNative is unused by noting that no live XPCCallContexts hold a pointer
    1:  *    to the tearoff.
    1:  *
    1:  *  - As a time/space tradeoff we may decide to not do this scanning on
    1:  *    *every* JavaScript GC. We *do* want to do this *sometimes* because
    1:  *    we want to allow for wrapped native's to do their own tearoff patterns.
    1:  *    So, we want to avoid holding references to interfaces that we don't need.
    1:  *    At the same time, we don't want to be bracketing every call into a
    1:  *    wrapped native object with a QueryInterface/Release pair. And we *never*
    1:  *    make a call into the object except via the correct interface for which
    1:  *    we've QI'd.
    1:  *
    1:  *  - Each tearoff *can* have a mJSObject whose lazily resolved properties
    1:  *    represent the methods/attributes/constants of that specific interface.
    1:  *    This is optionally reflected into JavaScript as "foo.nsIFoo" when "foo"
    1:  *    is the name of mFlatJSObject and "nsIFoo" is the name of the given
    1:  *    interface associated with the tearoff. When we create the tearoff's
    1:  *    mJSObject we set it's parent to be mFlatJSObject. This way we know that
    1:  *    when mFlatJSObject get's collected there are no outstanding reachable
    1:  *    tearoff mJSObjects. Note that we must clear the private of any lingering
    1:  *    mJSObjects at this point because we have no guarentee of the *order* of
    1:  *    finalization within a given gc cycle.
    1:  */
    1: 
    1: void
 7230: XPCWrappedNative::FlatJSObjectFinalized(JSContext *cx)
    1: {
    1:     if(!IsValid())
    1:         return;
    1: 
    1:     // Iterate the tearoffs and null out each of their JSObject's privates.
    1:     // This will keep them from trying to access their pointers to the
    1:     // dying tearoff object. We can safely assume that those remaining
    1:     // JSObjects are about to be finalized too.
    1: 
    1:     XPCWrappedNativeTearOffChunk* chunk;
    1:     for(chunk = &mFirstChunk; chunk; chunk = chunk->mNextChunk)
    1:     {
    1:         XPCWrappedNativeTearOff* to = chunk->mTearOffs;
    1:         for(int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK-1; i >= 0; i--, to++)
    1:         {
    1:             JSObject* jso = to->GetJSObject();
    1:             if(jso)
    1:             {
    1:                 NS_ASSERTION(JS_IsAboutToBeFinalized(cx, jso), "bad!");
    1:                 JS_SetPrivate(cx, jso, nsnull);
    1:                 to->JSObjectFinalized();
    1:             }
    1: 
    1:             // We also need to release any native pointers held...
    1:             nsISupports* obj = to->GetNative();
    1:             if(obj)
    1:             {
    1: #ifdef XP_WIN
    1:                 // Try to detect free'd pointer
    1:                 NS_ASSERTION(*(int*)obj != 0xdddddddd, "bad pointer!");
    1:                 NS_ASSERTION(*(int*)obj != 0,          "bad pointer!");
    1: #endif
    1:                 XPCJSRuntime* rt = GetRuntime();
10184:                 if(rt)
    1:                 {
    1:                     if(!rt->DeferredRelease(obj))
    1:                     {
    1:                         NS_WARNING("Failed to append object for deferred release.");
    1:                         // XXX do we really want to do this???
    1:                         obj->Release();
    1:                     }
    1:                 }
    1:                 else
    1:                 {
    1:                     obj->Release();
    1:                 }
    1:                 to->SetNative(nsnull);
    1:             }
    1: 
    1:             to->SetInterface(nsnull);
    1:         }
    1:     }
    1: 
12418:     if(IsWrapperExpired())
12418:     {
12418:         GetScope()->GetWrappedNativeMap()->Remove(this);
12418: 
12418:         XPCWrappedNativeProto* proto = GetProto();
12418: 
12418:         if(mScriptableInfo &&
12418:            (!HasProto() ||
12418:             (proto && proto->GetScriptableInfo() != mScriptableInfo)))
12418:         {
12418:             delete mScriptableInfo;
12418:             mScriptableInfo = nsnull;
12418:         }
12418: 
12418:         mMaybeScope = nsnull;
12418:     }
12418: 
26503:     nsWrapperCache *cache = nsnull;
26503:     CallQueryInterface(mIdentity, &cache);
26503:     if(cache)
26503:         cache->ClearWrapper();
26503: 
    1:     // This makes IsValid return false from now on...
    1:     mFlatJSObject = nsnull;
    1: 
    1:     NS_ASSERTION(mIdentity, "bad pointer!");
    1: #ifdef XP_WIN
    1:     // Try to detect free'd pointer
    1:     NS_ASSERTION(*(int*)mIdentity != 0xdddddddd, "bad pointer!");
    1:     NS_ASSERTION(*(int*)mIdentity != 0,          "bad pointer!");
    1: #endif
    1: 
    1:     // Note that it's not safe to touch mNativeWrapper here since it's
    1:     // likely that it has already been finalized.
    1: 
    1:     Release();
    1: }
    1: 
    1: void
 2991: XPCWrappedNative::SystemIsBeingShutDown(JSContext* cx)
    1: {
 2991: #ifdef DEBUG_xpc_hacker
 2991:     {
 2991:         printf("Removing root for still-live XPCWrappedNative %p wrapping:\n",
 3233:                static_cast<void*>(this));
24206:         for(PRUint16 i = 0, i_end = mSet->GetInterfaceCount(); i < i_end; ++i)
 2991:         {
 2991:             nsXPIDLCString name;
24206:             mSet->GetInterfaceAt(i)->GetInterfaceInfo()
 2991:                 ->GetName(getter_Copies(name));
 2991:             printf("  %s\n", name.get());
 2991:         }
 2991:     }
 2991: #endif
    1:     DEBUG_TrackShutdownWrapper(this);
    1: 
    1:     if(!IsValid())
    1:         return;
    1: 
    1:     // The long standing strategy is to leak some objects still held at shutdown.
    1:     // The general problem is that propagating release out of xpconnect at
    1:     // shutdown time causes a world of problems.
    1: 
    1:     // We leak mIdentity (see above).
    1: 
    1:     // short circuit future finalization
 2991:     JS_SetPrivate(cx, mFlatJSObject, nsnull);
    1:     mFlatJSObject = nsnull; // This makes 'IsValid()' return false.
    1: 
    1:     XPCWrappedNativeProto* proto = GetProto();
    1: 
    1:     if(HasProto())
 2991:         proto->SystemIsBeingShutDown(cx);
    1: 
    1:     if(mScriptableInfo &&
    1:        (!HasProto() ||
    1:         (proto && proto->GetScriptableInfo() != mScriptableInfo)))
    1:     {
    1:         delete mScriptableInfo;
    1:     }
    1: 
    1:     // cleanup the tearoffs...
    1: 
    1:     XPCWrappedNativeTearOffChunk* chunk;
    1:     for(chunk = &mFirstChunk; chunk; chunk = chunk->mNextChunk)
    1:     {
    1:         XPCWrappedNativeTearOff* to = chunk->mTearOffs;
    1:         for(int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK-1; i >= 0; i--, to++)
    1:         {
    1:             if(to->GetJSObject())
    1:             {
 2991:                 JS_SetPrivate(cx, to->GetJSObject(), nsnull);
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:                 if(to->IsIDispatch())
    1:                     delete to->GetIDispatchInfo();
    1: #endif
    1:                 to->SetJSObject(nsnull);
    1:             }
    1:             // We leak the tearoff mNative
    1:             // (for the same reason we leak mIdentity - see above).
    1:             to->SetNative(nsnull);
    1:             to->SetInterface(nsnull);
    1:         }
    1:     }
    1: 
    1:     if(mFirstChunk.mNextChunk)
    1:     {
    1:         delete mFirstChunk.mNextChunk;
    1:         mFirstChunk.mNextChunk = nsnull;
    1:     }
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: // static
    1: nsresult
    1: XPCWrappedNative::ReparentWrapperIfFound(XPCCallContext& ccx,
    1:                                          XPCWrappedNativeScope* aOldScope,
    1:                                          XPCWrappedNativeScope* aNewScope,
    1:                                          JSObject* aNewParent,
    1:                                          nsISupports* aCOMObj,
    1:                                          XPCWrappedNative** aWrapper)
    1: {
    1:     XPCNativeInterface* iface =
    1:         XPCNativeInterface::GetISupports(ccx);
    1: 
    1:     if(!iface)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsresult rv;
30001: 
30001:     nsRefPtr<XPCWrappedNative> wrapper;
30001:     JSObject *flat;
30001:     nsWrapperCache* cache = nsnull;
30001:     CallQueryInterface(aCOMObj, &cache);
30001:     if(cache)
30001:     {
30001:         flat = cache->GetWrapper();
33785:         if(flat && !IS_SLIM_WRAPPER_OBJECT(flat))
40041:         {
30001:             wrapper = static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(flat));
40041:             NS_ASSERTION(wrapper->GetScope() == aOldScope,
40041:                          "Incorrect scope passed");
40041:         }
30001:     }
30001:     else
30001:     {
30001:         rv = XPCWrappedNative::GetUsedOnly(ccx, aCOMObj, aOldScope, iface,
30001:                                            getter_AddRefs(wrapper));
    1:         if(NS_FAILED(rv))
    1:             return rv;
    1: 
57794:         flat = wrapper->GetFlatJSObjectAndMark();
30001:     }
30001: 
30001:     if(!flat)
30001:     {
    1:         *aWrapper = nsnull;
    1:         return NS_OK;
    1:     }
    1: 
58714:     bool crosscompartment = aOldScope->GetGlobalJSObject()->compartment() !=
58714:                             aNewScope->GetGlobalJSObject()->compartment();
58714: #ifdef DEBUG
58714:     if(crosscompartment)
58714:     {
58714:         NS_ASSERTION(aNewParent, "won't be able to find the new parent");
58714:         NS_ASSERTION(wrapper, "can't transplant slim wrappers");
58714:     }
58714: #endif
58714: 
26165:     // ReparentWrapperIfFound is really only meant to be called from DOM code
26165:     // which must happen only on the main thread. Bail if we're on some other
26165:     // thread or have a non-main-thread-only wrapper.
26165:     if (!XPCPerThreadData::IsMainThread(ccx) ||
30001:         (wrapper &&
30001:          wrapper->GetProto() &&
58076:          !wrapper->GetProto()->ClassIsMainThreadOnly()))
58076:     {
26165:         return NS_ERROR_FAILURE;
26165:     }
26165: 
58714:     JSAutoEnterCompartment ac;
58714:     if(!ac.enter(ccx, aNewScope->GetGlobalJSObject()))
58714:         return NS_ERROR_FAILURE;
58714: 
    1:     if(aOldScope != aNewScope)
    1:     {
    1:         // Oh, so now we need to move the wrapper to a different scope.
    1:         AutoMarkingWrappedNativeProtoPtr oldProto(ccx);
    1:         AutoMarkingWrappedNativeProtoPtr newProto(ccx);
    1: 
30001:         if(!wrapper)
30001:             oldProto = GetSlimWrapperProto(flat);
30001:         else if(wrapper->HasProto())
    1:             oldProto = wrapper->GetProto();
30001: 
30001:         if(oldProto)
30001:         {
    1:             XPCNativeScriptableInfo *info = oldProto->GetScriptableInfo();
    1:             XPCNativeScriptableCreateInfo ci(*info);
    1:             newProto =
    1:                 XPCWrappedNativeProto::GetNewOrUsed(ccx, aNewScope,
    1:                                                     oldProto->GetClassInfo(),
    1:                                                     &ci,
    1:                                                     !oldProto->IsShared(),
21218:                                                     (info->GetJSClass()->flags & JSCLASS_IS_GLOBAL),
21218:                                                     oldProto->GetOffsetsMasked());
    1:             if(!newProto)
    1:             {
    1:                 return NS_ERROR_FAILURE;
    1:             }
    1:         }
    1: 
30001:         if(wrapper)
30001:         {
    1:             Native2WrappedNativeMap* oldMap = aOldScope->GetWrappedNativeMap();
    1:             Native2WrappedNativeMap* newMap = aNewScope->GetWrappedNativeMap();
    1: 
    1:             {   // scoped lock
    1:                 XPCAutoLock lock(aOldScope->GetRuntime()->GetMapLock());
    1: 
    1:                 oldMap->Remove(wrapper);
    1: 
    1:                 if(wrapper->HasProto())
12418:                     wrapper->SetProto(newProto);
    1: 
    1:                 // If the wrapper has no scriptable or it has a non-shared
    1:                 // scriptable, then we don't need to mess with it.
    1:                 // Otherwise...
    1: 
    1:                 if(wrapper->mScriptableInfo &&
    1:                    wrapper->mScriptableInfo == oldProto->GetScriptableInfo())
    1:                 {
30001:                     // The new proto had better have the same JSClass stuff as
30001:                     // the old one! We maintain a runtime wide unique map of
30001:                     // this stuff. So, if these don't match then the caller is
30001:                     // doing something bad here.
    1: 
    1:                     NS_ASSERTION(
    1:                        oldProto->GetScriptableInfo()->GetScriptableShared() ==
    1:                        newProto->GetScriptableInfo()->GetScriptableShared(),
    1:                        "Changing proto is also changing JSObject Classname or "
    1:                        "helper's nsIXPScriptable flags. This is not allowed!");
    1: 
    1:                     wrapper->mScriptableInfo = newProto->GetScriptableInfo();
    1:                 }
    1: 
    1:                 NS_ASSERTION(!newMap->Find(wrapper->GetIdentityObject()),
    1:                              "wrapper already in new scope!");
    1: 
    1:                 (void) newMap->Add(wrapper);
    1:             }
26165: 
26165:             // We only try to fixup the __proto__ JSObject if the wrapper
26165:             // is directly using that of its XPCWrappedNativeProto.
26165: 
58714:             if(crosscompartment)
58714:             {
58714:                 JSObject *newobj = flat->clone(ccx, newProto->GetJSProtoObject(),
58714:                                                aNewParent);
58714:                 if(!newobj)
58714:                     return NS_ERROR_FAILURE;
58714: 
58714:                 JS_SetPrivate(ccx, flat, nsnull);
58714: 
58714:                 JSObject *propertyHolder =
58714:                     JS_NewObjectWithGivenProto(ccx, NULL, NULL, aNewParent);
58714:                 if(!propertyHolder || !propertyHolder->copyPropertiesFrom(ccx, flat))
58714:                     return NS_ERROR_OUT_OF_MEMORY;
58714: 
58714:                 flat = JS_TransplantObject(ccx, flat, newobj);
58714:                 if(!flat)
58714:                     return NS_ERROR_FAILURE;
58714:                 wrapper->mFlatJSObject = flat;
58714:                 if(cache)
58714:                     cache->SetWrapper(flat);
58714:                 if (!flat->copyPropertiesFrom(ccx, propertyHolder))
58714:                     return NS_ERROR_FAILURE;
58714:             }
58714:             else
58714:             {
26165:                 if(wrapper->HasProto() &&
39928:                    flat->getProto() == oldProto->GetJSProtoObject())
30001:                 {
30001:                     if(!JS_SetPrototype(ccx, flat, newProto->GetJSProtoObject()))
26165:                     {
26165:                         // this is bad, very bad
26165:                         NS_ERROR("JS_SetPrototype failed");
26165:                         return NS_ERROR_FAILURE;
26165:                     }
26165:                 }
26165:                 else
26165:                 {
26165:                     NS_WARNING("Moving XPConnect wrappedNative to new scope, "
26165:                                "but can't fixup __proto__");
26165:                 }
    1:             }
58714:         }
30001:         else
30001:         {
30001:             if(!JS_SetReservedSlot(ccx, flat, 0,
30001:                                    PRIVATE_TO_JSVAL(newProto.get())) ||
30001:                !JS_SetPrototype(ccx, flat, newProto->GetJSProtoObject()))
30001:             {
30001:                 // this is bad, very bad
30001:                 JS_SetReservedSlot(ccx, flat, 0, JSVAL_NULL);
30001:                 NS_ERROR("JS_SetPrototype failed");
30001:                 return NS_ERROR_FAILURE;
30001:             }
30001:         }
30001:     }
    1: 
    1:     // Now we can just fix up the parent and return the wrapper
    1: 
51080:     if(aNewParent)
51080:     {
51080:         if(!JS_SetParent(ccx, flat, aNewParent))
    1:             return NS_ERROR_FAILURE;
    1: 
51080:         JSObject *nw;
51080:         if(wrapper &&
51080:            (nw = wrapper->GetWrapper()) &&
51080:            !JS_SetParent(ccx, nw, JS_GetGlobalForObject(ccx, aNewParent)))
51080:         {
51080:             return NS_ERROR_FAILURE;
51080:         }
51080:     }
51080: 
30001:     *aWrapper = nsnull;
30001:     wrapper.swap(*aWrapper);
30001: 
    1:     return NS_OK;
    1: }
    1: 
    1: #define IS_TEAROFF_CLASS(clazz)                                               \
    1:           ((clazz) == &XPC_WN_Tearoff_JSClass)
    1: 
    1: // static
    1: XPCWrappedNative*
    1: XPCWrappedNative::GetWrappedNativeOfJSObject(JSContext* cx,
    1:                                              JSObject* obj,
    1:                                              JSObject* funobj,
    1:                                              JSObject** pobj2,
    1:                                              XPCWrappedNativeTearOff** pTearOff)
    1: {
    1:     NS_PRECONDITION(obj, "bad param");
    1: 
    1:     JSObject* cur;
    1: 
    1:     XPCWrappedNativeProto* proto = nsnull;
    1:     nsIClassInfo* protoClassInfo = nsnull;
    1: 
    1:     // If we were passed a function object then we need to find the correct
    1:     // wrapper out of those that might be in the callee obj's proto chain.
    1: 
    1:     if(funobj)
    1:     {
39930:         JSObject* funObjParent = funobj->getParent();
    1:         NS_ASSERTION(funObjParent, "funobj has no parent");
    1: 
48622:         js::Class* funObjParentClass = funObjParent->getClass();
    1: 
    1:         if(IS_PROTO_CLASS(funObjParentClass))
    1:         {
39930:             NS_ASSERTION(funObjParent->getParent(), "funobj's parent (proto) is global");
10858:             proto = (XPCWrappedNativeProto*) xpc_GetJSPrivate(funObjParent);
    1:             if(proto)
    1:                 protoClassInfo = proto->GetClassInfo();
    1:         }
    1:         else if(IS_WRAPPER_CLASS(funObjParentClass))
    1:         {
    1:             cur = funObjParent;
    1:             goto return_wrapper;
    1:         }
    1:         else if(IS_TEAROFF_CLASS(funObjParentClass))
    1:         {
39930:             NS_ASSERTION(funObjParent->getParent(), "funobj's parent (tearoff) is global");
    1:             cur = funObjParent;
    1:             goto return_tearoff;
    1:         }
    1:         else
    1:         {
    1:             NS_ERROR("function object has parent of unknown class!");
    1:             return nsnull;
    1:         }
    1:     }
    1: 
39928:     for(cur = obj; cur; cur = cur->getProto())
    1:     {
    1:         // this is on two lines to make the compiler happy given the goto.
48622:         js::Class* clazz;
48622:         clazz = cur->getClass();
    1: 
33785:         if(IS_WRAPPER_CLASS(clazz))
33785:         {
33785: return_wrapper:
33785:             JSBool isWN = IS_WN_WRAPPER_OBJECT(cur);
33785:             XPCWrappedNative* wrapper =
33785:                 isWN ? (XPCWrappedNative*) xpc_GetJSPrivate(cur) : nsnull;
30001:             if(proto)
30001:             {
30001:                 XPCWrappedNativeProto* wrapper_proto =
33785:                     isWN ? wrapper->GetProto() : GetSlimWrapperProto(cur);
30001:                 if(proto != wrapper_proto &&
51078:                    (!protoClassInfo || !wrapper_proto ||
30001:                     protoClassInfo != wrapper_proto->GetClassInfo()))
30001:                     continue;
30001:             }
30001:             if(pobj2)
33786:                 *pobj2 = isWN ? nsnull : cur;
    1:             return wrapper;
    1:         }
    1: 
    1:         if(IS_TEAROFF_CLASS(clazz))
    1:         {
    1: return_tearoff:
    1:             XPCWrappedNative* wrapper =
39930:                 (XPCWrappedNative*) xpc_GetJSPrivate(cur->getParent());
    1:             if(proto && proto != wrapper->GetProto() &&
    1:                (proto->GetScope() != wrapper->GetScope() ||
    1:                 !protoClassInfo || !wrapper->GetProto() ||
    1:                 protoClassInfo != wrapper->GetProto()->GetClassInfo()))
    1:                 continue;
    1:             if(pobj2)
33786:                 *pobj2 = nsnull;
    1:             XPCWrappedNativeTearOff* to =
10858:                 (XPCWrappedNativeTearOff*) xpc_GetJSPrivate(cur);
    1:             if(!to)
    1:                 return nsnull;
    1:             if(pTearOff)
    1:                 *pTearOff = to;
    1:             return wrapper;
    1:         }
    1: 
27664:         // Unwrap any wrapper wrappers.
 4042:         JSObject *unsafeObj;
27664:         if((unsafeObj = XPCWrapper::Unwrap(cx, cur)))
    1:             return GetWrappedNativeOfJSObject(cx, unsafeObj, funobj, pobj2,
    1:                                               pTearOff);
    1:     }
    1: 
30002:     if(pobj2)
30002:         *pobj2 = nsnull;
    1:     return nsnull;
    1: }
    1: 
    1: JSBool
    1: XPCWrappedNative::ExtendSet(XPCCallContext& ccx, XPCNativeInterface* aInterface)
    1: {
    1:     // This is only called while locked (during XPCWrappedNative::FindTearOff).
24206: 
24206:     if(!mSet->HasInterface(aInterface))
    1:     {
    1:         AutoMarkingNativeSetPtr newSet(ccx);
24206:         newSet = XPCNativeSet::GetNewOrUsed(ccx, mSet, aInterface,
24206:                                             mSet->GetInterfaceCount());
    1:         if(!newSet)
    1:             return JS_FALSE;
    1: 
24206:         mSet = newSet;
    1: 
    1:         DEBUG_ReportShadowedMembers(newSet, this, GetProto());
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: XPCWrappedNativeTearOff*
    1: XPCWrappedNative::LocateTearOff(XPCCallContext& ccx,
    1:                               XPCNativeInterface* aInterface)
    1: {
    1:     XPCAutoLock al(GetLock()); // hold the lock throughout
    1: 
    1:     for(
    1:         XPCWrappedNativeTearOffChunk* chunk = &mFirstChunk;
    1:         chunk != nsnull;
    1:         chunk = chunk->mNextChunk)
    1:     {
    1:         XPCWrappedNativeTearOff* tearOff = chunk->mTearOffs;
    1:         XPCWrappedNativeTearOff* const end = tearOff + 
    1:             XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK;
    1:         for(
    1:             tearOff = chunk->mTearOffs;
    1:             tearOff < end; 
    1:             tearOff++)
    1:         {
    1:             if(tearOff->GetInterface() == aInterface)
    1:             {
    1:                 return tearOff;
    1:             }
    1:         }
    1:     }
    1:     return nsnull;
    1: }
    1: 
    1: XPCWrappedNativeTearOff*
    1: XPCWrappedNative::FindTearOff(XPCCallContext& ccx,
    1:                               XPCNativeInterface* aInterface,
    1:                               JSBool needJSObject /* = JS_FALSE */,
    1:                               nsresult* pError /* = nsnull */)
    1: {
    1:     XPCAutoLock al(GetLock()); // hold the lock throughout
    1: 
    1:     nsresult rv = NS_OK;
    1:     XPCWrappedNativeTearOff* to;
    1:     XPCWrappedNativeTearOff* firstAvailable = nsnull;
    1: 
    1:     XPCWrappedNativeTearOffChunk* lastChunk;
    1:     XPCWrappedNativeTearOffChunk* chunk;
    1:     for(lastChunk = chunk = &mFirstChunk;
    1:         chunk;
    1:         lastChunk = chunk, chunk = chunk->mNextChunk)
    1:     {
    1:         to = chunk->mTearOffs;
    1:         XPCWrappedNativeTearOff* const end = chunk->mTearOffs + 
    1:             XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK;
    1:         for(
    1:             to = chunk->mTearOffs;
    1:             to < end; 
    1:             to++)
    1:         {
    1:             if(to->GetInterface() == aInterface)
    1:             {
    1:                 if(needJSObject && !to->GetJSObject())
    1:                 {
    1:                     AutoMarkingWrappedNativeTearOffPtr tearoff(ccx, to);
60212:                     JSBool ok = InitTearOffJSObject(ccx, to);
    1:                     // During shutdown, we don't sweep tearoffs.  So make sure
    1:                     // to unmark manually in case the auto-marker marked us.
    1:                     // We shouldn't ever be getting here _during_ our
    1:                     // Mark/Sweep cycle, so this should be safe.
    1:                     to->Unmark();
60212:                     if(!ok) {
    1:                         to = nsnull;
60212:                         rv = NS_ERROR_OUT_OF_MEMORY;
60212:                     }
    1:                 }
    1:                 goto return_result;
    1:             }
    1:             if(!firstAvailable && to->IsAvailable())
    1:                 firstAvailable = to;
    1:         }
    1:     }
    1: 
    1:     to = firstAvailable;
    1: 
    1:     if(!to)
    1:     {
    1:         XPCWrappedNativeTearOffChunk* newChunk =
    1:             new XPCWrappedNativeTearOffChunk();
    1:         if(!newChunk)
    1:         {
    1:             rv = NS_ERROR_OUT_OF_MEMORY;
    1:             goto return_result;
    1:         }
    1:         lastChunk->mNextChunk = newChunk;
    1:         to = newChunk->mTearOffs;
    1:     }
    1: 
    1:     {
    1:         // Scope keeps |tearoff| from leaking across the return_result: label
    1:         AutoMarkingWrappedNativeTearOffPtr tearoff(ccx, to);
    1:         rv = InitTearOff(ccx, to, aInterface, needJSObject);
    1:         // During shutdown, we don't sweep tearoffs.  So make sure to unmark
    1:         // manually in case the auto-marker marked us.  We shouldn't ever be
    1:         // getting here _during_ our Mark/Sweep cycle, so this should be safe.
    1:         to->Unmark();
    1:         if(NS_FAILED(rv))
    1:             to = nsnull;
    1:     }
    1: 
    1: return_result:
    1: 
    1:     if(pError)
    1:         *pError = rv;
    1:     return to;
    1: }
    1: 
    1: nsresult
    1: XPCWrappedNative::InitTearOff(XPCCallContext& ccx,
    1:                               XPCWrappedNativeTearOff* aTearOff,
    1:                               XPCNativeInterface* aInterface,
    1:                               JSBool needJSObject)
    1: {
    1:     // This is only called while locked (during XPCWrappedNative::FindTearOff).
    1: 
    1:     // Determine if the object really does this interface...
    1: 
    1:     const nsIID* iid = aInterface->GetIID();
    1:     nsISupports* identity = GetIdentityObject();
    1:     nsISupports* obj;
    1: 
    1:     // If the scriptable helper forbids us from reflecting additional
    1:     // interfaces, then don't even try the QI, just fail.
    1:     if(mScriptableInfo &&
    1:        mScriptableInfo->GetFlags().ClassInfoInterfacesOnly() &&
24206:        !mSet->HasInterface(aInterface) &&
24206:        !mSet->HasInterfaceWithAncestor(aInterface))
    1:     {
    1:         return NS_ERROR_NO_INTERFACE;
    1:     }
    1: 
    1:     // We are about to call out to unlock and other code.
    1:     // So protect our intended tearoff.
    1: 
    1:     aTearOff->SetReserved();
    1: 
    1:     {   // scoped *un*lock
    1:         XPCAutoUnlock unlock(GetLock());
    1: 
    1:         if(NS_FAILED(identity->QueryInterface(*iid, (void**)&obj)) || !obj)
    1:         {
    1:             aTearOff->SetInterface(nsnull);
    1:             return NS_ERROR_NO_INTERFACE;
    1:         }
    1: 
    1:         // Guard against trying to build a tearoff for a shared nsIClassInfo.
    1:         if(iid->Equals(NS_GET_IID(nsIClassInfo)))
    1:         {
    1:             nsCOMPtr<nsISupports> alternate_identity(do_QueryInterface(obj));
    1:             if(alternate_identity.get() != identity)
    1:             {
    1:                 NS_RELEASE(obj);
    1:                 aTearOff->SetInterface(nsnull);
    1:                 return NS_ERROR_NO_INTERFACE;
    1:             }
    1:         }
    1: 
    1:         // Guard against trying to build a tearoff for an interface that is
    1:         // aggregated and is implemented as a nsIXPConnectWrappedJS using this
    1:         // self-same JSObject. The XBL system does this. If we mutate the set
    1:         // of this wrapper then we will shadow the method that XBL has added to
    1:         // the JSObject that it has inserted in the JS proto chain between our
    1:         // JSObject and our XPCWrappedNativeProto's JSObject. If we let this
    1:         // set mutation happen then the interface's methods will be added to 
    1:         // our JSObject, but calls on those methods will get routed up to
    1:         // native code and into the wrappedJS - which will do a method lookup
    1:         // on *our* JSObject and find the same method and make another call
    1:         // into an infinite loop.
    1:         // see: http://bugzilla.mozilla.org/show_bug.cgi?id=96725
    1: 
    1:         // The code in this block also does a check for the double wrapped
    1:         // nsIPropertyBag case.
    1: 
    1:         nsCOMPtr<nsIXPConnectWrappedJS> wrappedJS(do_QueryInterface(obj));
    1:         if(wrappedJS)
    1:         {
    1:             JSObject* jso = nsnull;
    1:             if(NS_SUCCEEDED(wrappedJS->GetJSObject(&jso)) &&
57794:                jso == mFlatJSObject)
    1:             {
    1:                 // The implementing JSObject is the same as ours! Just say OK
    1:                 // without actually extending the set.
    1:                 //
    1:                 // XXX It is a little cheesy to have FindTearOff return an
    1:                 // 'empty' tearoff. But this is the centralized place to do the
    1:                 // QI activities on the underlying object. *And* most caller to
    1:                 // FindTearOff only look for a non-null result and ignore the
    1:                 // actual tearoff returned. The only callers that do use the
    1:                 // returned tearoff make sure to check for either a non-null 
    1:                 // JSObject or a matching Interface before proceeding.
    1:                 // I think we can get away with this bit of ugliness.
    1:                 
    1: #ifdef DEBUG_xpc_hacker
    1:                 {
    1:                     // I want to make sure this only happens in xbl-like cases.
    1:                     // So, some debug code to verify that there is at least
    1:                     // *some* object between our JSObject and its inital proto.
    1:                     // XXX This is a pretty funky test. Someone might hack it
    1:                     // a bit if false positives start showing up. Note that 
    1:                     // this is only going to run for the few people in the
    1:                     // DEBUG_xpc_hacker list.
    1:                     if(HasProto())
    1:                     {
    1:                         JSObject* proto  = nsnull;
    1:                         JSObject* our_proto = GetProto()->GetJSProtoObject();
    1: 
39928:                         proto = jso->getProto();
    1: 
    1:                         NS_ASSERTION(proto && proto != our_proto,
    1:                             "!!! xpconnect/xbl check - wrapper has no special proto");
    1: 
    1:                         PRBool found_our_proto = PR_FALSE;
    1:                         while(proto && !found_our_proto) {
39928:                             proto = proto->getProto();
    1: 
    1:                             found_our_proto = proto == our_proto;
    1:                         }
    1: 
    1:                         NS_ASSERTION(found_our_proto,
    1:                             "!!! xpconnect/xbl check - wrapper has extra proto");
    1:                     }
    1:                     else
    1:                     {
    1:                         NS_WARNING("!!! xpconnect/xbl check - wrapper has no proto");
    1:                     }
    1:                 }
    1: #endif
    1:                 NS_RELEASE(obj);
    1:                 aTearOff->SetInterface(nsnull);
    1:                 return NS_OK;
    1:             }
    1:             
    1:             // Decide whether or not to expose nsIPropertyBag to calling
    1:             // JS code in the double wrapped case.
    1:             //
    1:             // Our rule here is that when JSObjects are double wrapped and
    1:             // exposed to other JSObjects then the nsIPropertyBag interface
    1:             // is only exposed on an 'opt-in' basis; i.e. if the underlying
    1:             // JSObject wants other JSObjects to be able to see this interface
    1:             // then it must implement QueryInterface and not throw an exception
    1:             // when asked for nsIPropertyBag. It need not actually *implement*
    1:             // nsIPropertyBag - xpconnect will do that work.
    1: 
    1:             nsXPCWrappedJSClass* clazz;
    1:             if(iid->Equals(NS_GET_IID(nsIPropertyBag)) && jso &&
    1:                NS_SUCCEEDED(nsXPCWrappedJSClass::GetNewOrUsed(ccx,*iid,&clazz))&&
    1:                clazz)
    1:             {
    1:                 JSObject* answer =
    1:                     clazz->CallQueryInterfaceOnJSObject(ccx, jso, *iid);
    1:                 NS_RELEASE(clazz);
    1:                 if(!answer)
    1:                 {
    1:                     NS_RELEASE(obj);
    1:                     aTearOff->SetInterface(nsnull);
    1:                     return NS_ERROR_NO_INTERFACE;
    1:                 }
    1:             }
    1:         }
    1: 
    1:         nsIXPCSecurityManager* sm;
    1:            sm = ccx.GetXPCContext()->GetAppropriateSecurityManager(
    1:                                 nsIXPCSecurityManager::HOOK_CREATE_WRAPPER);
    1:         if(sm && NS_FAILED(sm->
    1:                     CanCreateWrapper(ccx, *iid, identity,
    1:                                      GetClassInfo(), GetSecurityInfoAddr())))
    1:         {
    1:             // the security manager vetoed. It should have set an exception.
    1:             NS_RELEASE(obj);
    1:             aTearOff->SetInterface(nsnull);
    1:             return NS_ERROR_XPC_SECURITY_MANAGER_VETO;
    1:         }
    1:     }
    1:     // We are relocked from here on...
    1: 
    1:     // If this is not already in our set we need to extend our set.
    1:     // Note: we do not cache the result of the previous call to HasInterface()
    1:     // because we unlocked and called out in the interim and the result of the
    1:     // previous call might not be correct anymore.
    1: 
24206:     if(!mSet->HasInterface(aInterface) && !ExtendSet(ccx, aInterface))
    1:     {
    1:         NS_RELEASE(obj);
    1:         aTearOff->SetInterface(nsnull);
    1:         return NS_ERROR_NO_INTERFACE;
    1:     }
    1: 
    1:     aTearOff->SetInterface(aInterface);
    1:     aTearOff->SetNative(obj);
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     // Are we building a tearoff for IDispatch?
    1:     if(iid->Equals(NSID_IDISPATCH))
    1:     {
    1:         aTearOff->SetIDispatch(ccx);
    1:     }  
    1: #endif
    1:     if(needJSObject && !InitTearOffJSObject(ccx, aTearOff))
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: JSBool
    1: XPCWrappedNative::InitTearOffJSObject(XPCCallContext& ccx,
    1:                                       XPCWrappedNativeTearOff* to)
    1: {
    1:     // This is only called while locked (during XPCWrappedNative::FindTearOff).
    1: 
 7987:     JSObject* obj =
48622:         xpc_NewSystemInheritingJSObject(ccx, js::Jsvalify(&XPC_WN_Tearoff_JSClass),
    1:                                         GetScope()->GetPrototypeJSObject(),
    1:                                         mFlatJSObject);
    1: 
    1:     if(!obj || !JS_SetPrivate(ccx, obj, to))
    1:         return JS_FALSE;
    1: 
    1:     to->SetJSObject(obj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: static JSBool Throw(uintN errNum, XPCCallContext& ccx)
    1: {
    1:     XPCThrower::Throw(errNum, ccx);
    1:     return JS_FALSE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
41138: class CallMethodHelper
41138: {
41138:     XPCCallContext& mCallContext;
41138:     nsIInterfaceInfo* const mIFaceInfo;
41138:     const nsXPTMethodInfo* mMethodInfo;
41138:     nsISupports* const mCallee;
41138:     const uint16 mVTableIndex;
41138:     const jsid mIdxValueId;
41138: 
41138:     nsAutoTArray<nsXPTCVariant, 8> mDispatchParams;
46381:     uint8 mJSContextIndex; // TODO make const
41138:     uint8 mOptArgcIndex; // TODO make const
41138: 
41138:     // Reserve space for one nsAutoString. We don't want the string itself
41138:     // to be declared as that would make the ctor and dtors run for each
41138:     // CallMethodHelper instantiation, and they're only needed in a
41138:     // fraction of all the calls that come through here.
41138:     js::LazilyConstructed<nsAutoString> mAutoString;
41138: 
41138:     jsval* const mArgv;
41138:     const PRUint32 mArgc;
41138: 
41138:     enum SizeMode {
41138:         eGetSize,
41138:         eGetLength
41138:     };
41138: 
41138:     JS_ALWAYS_INLINE JSBool
41138:     GetArrayInfoFromParam(uint8 paramIndex, SizeMode mode,
41138:                           JSUint32* result) const;
41138: 
41138:     JSBool
41138:     GetArraySizeFromParam(uint8 paramIndex, JSUint32* result) const
41138:     {
41138:         return GetArrayInfoFromParam(paramIndex, eGetSize, result);
41138:     }
41138: 
41138:     JSBool
41138:     GetArrayLengthFromParam(uint8 paramIndex, JSUint32* result) const
41138:     {
41138:         return GetArrayInfoFromParam(paramIndex, eGetLength, result);
41138:     }
41138: 
41138:     JS_ALWAYS_INLINE JSBool
41138:     GetInterfaceTypeFromParam(uint8 paramIndex,
    1:                               const nsXPTType& datum_type,
41138:                               nsID* result) const;
41138: 
41138:     JS_ALWAYS_INLINE JSBool
41138:     GetOutParamSource(uint8 paramIndex, jsval* srcp) const;
41138: 
41138:     JS_ALWAYS_INLINE JSBool
41138:     GatherAndConvertResults();
41138: 
41138:     JS_ALWAYS_INLINE JSBool
41138:     QueryInterfaceFastPath() const;
41138: 
41138:     nsXPTCVariant*
41138:     GetDispatchParam(uint8 paramIndex)
41138:     {
46381:         if (paramIndex >= mJSContextIndex)
46381:             paramIndex += 1;
41138:         if (paramIndex >= mOptArgcIndex)
41138:             paramIndex += 1;
41138:         return &mDispatchParams[paramIndex];
41138:     }
41138:     const nsXPTCVariant*
41138:     GetDispatchParam(uint8 paramIndex) const
41138:     {
41138:         return const_cast<CallMethodHelper*>(this)->GetDispatchParam(paramIndex);
41138:     }
41138: 
41138:     JS_ALWAYS_INLINE JSBool InitializeDispatchParams();
41138: 
41138:     JS_ALWAYS_INLINE JSBool ConvertIndependentParams(JSBool* foundDependentParam);
41138:     JS_ALWAYS_INLINE JSBool ConvertDependentParams();
41138: 
41138:     JS_ALWAYS_INLINE nsresult Invoke();
41138: 
41138: public:
41138: 
41138:     CallMethodHelper(XPCCallContext& ccx)
41138:         : mCallContext(ccx)
41138:         , mIFaceInfo(ccx.GetInterface()->GetInterfaceInfo())
41138:         , mMethodInfo(nsnull)
41138:         , mCallee(ccx.GetTearOff()->GetNative())
41138:         , mVTableIndex(ccx.GetMethodIndex())
41138:         , mIdxValueId(ccx.GetRuntime()->GetStringID(XPCJSRuntime::IDX_VALUE))
46381:         , mJSContextIndex(PR_UINT8_MAX)
41138:         , mOptArgcIndex(PR_UINT8_MAX)
41138:         , mArgv(ccx.GetArgv())
41138:         , mArgc(ccx.GetArgc())
41138: 
41138:     {
41138:         // Success checked later.
41138:         mIFaceInfo->GetMethodInfo(mVTableIndex, &mMethodInfo);
41138:     }
41138: 
41138:     ~CallMethodHelper();
41138: 
41138:     JS_ALWAYS_INLINE JSBool Call();
41138: 
41138: };
    1: 
    1: // static
18741: NS_SUPPRESS_STACK_CHECK JSBool
    1: XPCWrappedNative::CallMethod(XPCCallContext& ccx,
    1:                              CallMode mode /*= CALL_METHOD */)
    1: {
41138:     XPCContext* xpcc = ccx.GetXPCContext();
41138:     NS_ASSERTION(xpcc->CallerTypeIsJavaScript(),
    1:                  "Native caller for XPCWrappedNative::CallMethod?");
    1: 
    1:     nsresult rv = ccx.CanCallNow();
    1:     if(NS_FAILED(rv))
    1:     {
    1:         // If the security manager is complaining then this is not really an
    1:         // internal error in xpconnect. So, no reason to botch the assertion.
    1:         NS_ASSERTION(rv == NS_ERROR_XPC_SECURITY_MANAGER_VETO,
    1:                      "hmm? CanCallNow failed in XPCWrappedNative::CallMethod. "
    1:                      "We are finding out about this late!");
    1:         return Throw(rv, ccx);
    1:     }
    1: 
    1:     DEBUG_TrackWrapperCall(ccx.GetWrapper(), mode);
    1: 
    1:     // set up the method index and do the security check if needed
    1: 
    1:     PRUint32 secFlag;
    1:     PRUint32 secAction;
    1: 
    1:     switch(mode)
    1:     {
    1:         case CALL_METHOD:
    1:             secFlag   = nsIXPCSecurityManager::HOOK_CALL_METHOD;
    1:             secAction = nsIXPCSecurityManager::ACCESS_CALL_METHOD;
    1:             break;
    1:         case CALL_GETTER:
    1:             secFlag   = nsIXPCSecurityManager::HOOK_GET_PROPERTY;
    1:             secAction = nsIXPCSecurityManager::ACCESS_GET_PROPERTY;
    1:             break;
    1:         case CALL_SETTER:
    1:             secFlag   = nsIXPCSecurityManager::HOOK_SET_PROPERTY;
    1:             secAction = nsIXPCSecurityManager::ACCESS_SET_PROPERTY;
    1:             break;
    1:         default:
31561:             NS_ERROR("bad value");
 5838:             return JS_FALSE;
    1:     }
    1: 
41138:     nsIXPCSecurityManager* sm =
41138:         xpcc->GetAppropriateSecurityManager(secFlag);
    1:     if(sm && NS_FAILED(sm->CanAccess(secAction, &ccx, ccx,
    1:                                      ccx.GetFlattenedJSObject(),
    1:                                      ccx.GetWrapper()->GetIdentityObject(),
41138:                                      ccx.GetWrapper()->GetClassInfo(),
41138:                                      ccx.GetMember()->GetName(),
    1:                                      ccx.GetWrapper()->GetSecurityInfoAddr())))
    1:     {
    1:         // the security manager vetoed. It should have set an exception.
 5838:         return JS_FALSE;
 5838:     }
 5838: 
41138:     return CallMethodHelper(ccx).Call();
41138: }
41138: 
41138: JSBool
41138: CallMethodHelper::Call()
41138: {
41138:     mCallContext.SetRetVal(JSVAL_VOID);
41138: 
41138:     mCallContext.GetThreadData()->SetException(nsnull);
41138:     mCallContext.GetXPCContext()->SetLastResult(NS_ERROR_UNEXPECTED);
41138: 
41138:     if(mVTableIndex == 0)
41138:     {
41138:         return QueryInterfaceFastPath();
41138:     }
41138: 
41138:     if(!mMethodInfo)
41138:     {
41138:         Throw(NS_ERROR_XPC_CANT_GET_METHOD_INFO, mCallContext);
 5838:         return JS_FALSE;
 5838:     }
41138: 
41138:     if (!InitializeDispatchParams())
 5838:         return JS_FALSE;
    1: 
    1:     // Iterate through the params doing conversions of independent params only.
    1:     // When we later convert the dependent params (if any) we will know that
    1:     // the params upon which they depend will have already been converted -
    1:     // regardless of ordering.
41138:     JSBool foundDependentParam = JS_FALSE;
41138:     if(!ConvertIndependentParams(&foundDependentParam))
41138:         return JS_FALSE;
41138: 
41138:     if(foundDependentParam && !ConvertDependentParams())
41138:         return JS_FALSE;
41138: 
41138:     nsresult invokeResult = Invoke();
41138: 
41138:     mCallContext.GetXPCContext()->SetLastResult(invokeResult);
41138: 
41138:     if(NS_FAILED(invokeResult))
41138:     {
41138:         ThrowBadResult(invokeResult, mCallContext);
41138:         return JS_FALSE;
41138:     }
41138: 
41138:     if(JS_IsExceptionPending(mCallContext))
41138:     {
41138:         return JS_FALSE;
41138:     }
41138: 
41138:     return GatherAndConvertResults();
41138: }
41138: 
41138: CallMethodHelper::~CallMethodHelper()
41138: {
41138:     uint8 paramCount = mMethodInfo->GetParamCount();
41138:     if (mDispatchParams.Length())
41138:     {
41138:         for(uint8 i = 0; i < paramCount; i++)
41138:         {
41138:             nsXPTCVariant* dp = GetDispatchParam(i);
41138:             void* p = dp->val.p;
41138:             if(!p)
    1:                 continue;
41138: 
41138:             if(dp->IsValArray())
41138:             {
41138:                 // going to have to cleanup the array and perhaps its contents
41138:                 if(dp->IsValAllocated() || dp->IsValInterface())
41138:                 {
41138:                     // we need to figure out how many elements are present.
41138:                     JSUint32 array_count;
41138: 
41138:                     if(!GetArraySizeFromParam(i, &array_count))
41138:                     {
41138:                         NS_ERROR("failed to get array length, we'll leak here");
41138:                         continue;
41138:                     }
41138:                     if(dp->IsValAllocated())
41138:                     {
41138:                         void** a = (void**)p;
41138:                         for(JSUint32 k = 0; k < array_count; k++)
41138:                         {
41138:                             void* o = a[k];
41138:                             if(o) nsMemory::Free(o);
41138:                         }
41138:                     }
41138:                     else // if(dp->IsValInterface())
41138:                     {
41138:                         nsISupports** a = (nsISupports**)p;
41138:                         for(JSUint32 k = 0; k < array_count; k++)
41138:                         {
41138:                             nsISupports* o = a[k];
41138:                             NS_IF_RELEASE(o);
41138:                         }
41138:                     }
41138:                 }
41138:                 // always free the array itself
41138:                 nsMemory::Free(p);
41138:             }
48470:             else
48470:             {
48470:                 if(dp->IsValJSRoot())
48470:                     JS_RemoveValueRoot(mCallContext, (jsval*)dp->ptr);
48470: 
48470:                 if(dp->IsValAllocated())
41138:                     nsMemory::Free(p);
41138:                 else if(dp->IsValInterface())
41138:                     ((nsISupports*)p)->Release();
41138:                 else if(dp->IsValDOMString())
41138:                     mCallContext.DeleteString((nsAString*)p);
41138:                 else if(dp->IsValUTF8String())
41138:                     delete (nsCString*) p;
41138:                 else if(dp->IsValCString())
41138:                     delete (nsCString*) p;
48470:             }
46230:         }
46230:     }
46230: 
41138: }
41138: 
41138: JSBool
41138: CallMethodHelper::GetArrayInfoFromParam(uint8 paramIndex, SizeMode mode,
41138:                                         JSUint32* result) const
41138: {
41138:     nsresult rv;
41138:     const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(paramIndex);
41138: 
41138:     // TODO fixup the various exceptions that are thrown
41138: 
41138:     if(mode == eGetSize)
41138:         rv = mIFaceInfo->GetSizeIsArgNumberForParam(mVTableIndex, &paramInfo, 0, &paramIndex);
41138:     else
41138:         rv = mIFaceInfo->GetLengthIsArgNumberForParam(mVTableIndex, &paramInfo, 0, &paramIndex);
41138:     if(NS_FAILED(rv))
41138:         return Throw(NS_ERROR_XPC_CANT_GET_ARRAY_INFO, mCallContext);
41138: 
41138:     const nsXPTType& type = mMethodInfo->GetParam(paramIndex).GetType();
41138:     // The xpidl compiler ensures this. We reaffirm it for safety.
41138:     if(type.IsPointer() || type.TagPart() != nsXPTType::T_U32)
41138:         return Throw(NS_ERROR_XPC_CANT_GET_ARRAY_INFO, mCallContext);
41138: 
41138:     *result = GetDispatchParam(paramIndex)->val.u32;
41138: 
41138:     return JS_TRUE;
41138: }
41138: 
41138: JSBool
41138: CallMethodHelper::GetInterfaceTypeFromParam(uint8 paramIndex,
41138:                                             const nsXPTType& datum_type,
41138:                                             nsID* result) const
41138: {
41138:     nsresult rv;
41138:     const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(paramIndex);
41138:     uint8 tag = datum_type.TagPart();
41138: 
41138:     // TODO fixup the various exceptions that are thrown
41138: 
41138:     if(tag == nsXPTType::T_INTERFACE)
41138:     {
41138:         rv = mIFaceInfo->GetIIDForParamNoAlloc(mVTableIndex, &paramInfo, result);
41138:         if(NS_FAILED(rv))
41138:             return ThrowBadParam(NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO,
41138:                                  paramIndex, mCallContext);
41138:     }
41138:     else if(tag == nsXPTType::T_INTERFACE_IS)
41138:     {
41138:         rv = mIFaceInfo->GetInterfaceIsArgNumberForParam(mVTableIndex, &paramInfo,
41138:                                                          &paramIndex);
41138:         if(NS_FAILED(rv))
41138:             return Throw(NS_ERROR_XPC_CANT_GET_ARRAY_INFO, mCallContext);
41138: 
41138:         const nsXPTType& type = mMethodInfo->GetParam(paramIndex).GetType();
41138:         // The xpidl compiler ensures this. We reaffirm it for safety.
41138:         if(!type.IsPointer() || type.TagPart() != nsXPTType::T_IID)
41138:             return ThrowBadParam(NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO,
41138:                                  paramIndex, mCallContext);
41138: 
41138:         nsID* p = (nsID*) GetDispatchParam(paramIndex)->val.p;
41138:         if(!p)
41138:             return ThrowBadParam(NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO,
41138:                                  paramIndex, mCallContext);
41138:         *result = *p;
41138:     }
41138:     return JS_TRUE;
41138: }
41138: 
41138: JSBool
41138: CallMethodHelper::GetOutParamSource(uint8 paramIndex, jsval* srcp) const
41138: {
41138:     const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(paramIndex);
    1: 
 1869:     if((paramInfo.IsOut() || paramInfo.IsDipper()) &&
41138:        !paramInfo.IsRetval())
41138:     {
41138:         NS_ASSERTION(paramIndex < mArgc || paramInfo.IsOptional(),
 8557:                      "Expected either enough arguments or an optional argument");
41138:         jsval arg = paramIndex < mArgc ? mArgv[paramIndex] : JSVAL_NULL;
41138:         if(paramIndex < mArgc &&
41138:            (JSVAL_IS_PRIMITIVE(arg) ||
41138:             !JS_GetPropertyById(mCallContext,
41138:                                 JSVAL_TO_OBJECT(arg),
41138:                                 mIdxValueId,
41138:                                 srcp)))
41138:         {
41138:             // Explicitly passed in unusable value for out param.  Note
41138:             // that if i >= mArgc we already know that |arg| is JSVAL_NULL,
41138:             // and that's ok.
41138:             ThrowBadParam(NS_ERROR_XPC_NEED_OUT_OBJECT, paramIndex,
41138:                           mCallContext);
41138:             return JS_FALSE;
41138:         }
41138:     }
41138: 
41138:     return JS_TRUE;
41138: }
41138: 
41138: JSBool
41138: CallMethodHelper::GatherAndConvertResults()
41138: {
    1:     // now we iterate through the native params to gather and convert results
41138:     uint8 paramCount = mMethodInfo->GetParamCount();
41138:     for(uint8 i = 0; i < paramCount; i++)
41138:     {
41138:         const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(i);
    1:         if(!paramInfo.IsOut() && !paramInfo.IsDipper())
    1:             continue;
    1: 
    1:         const nsXPTType& type = paramInfo.GetType();
41138:         nsXPTCVariant* dp = GetDispatchParam(i);
    1:         jsval v = JSVAL_NULL;
41138:         AUTO_MARK_JSVAL(mCallContext, &v);
    1:         JSUint32 array_count;
    1:         nsXPTType datum_type;
    1:         PRBool isArray = type.IsArray();
    1:         PRBool isSizedString = isArray ?
    1:                 JS_FALSE :
    1:                 type.TagPart() == nsXPTType::T_PSTRING_SIZE_IS ||
    1:                 type.TagPart() == nsXPTType::T_PWSTRING_SIZE_IS;
    1: 
    1:         if(isArray)
    1:         {
41138:             if(NS_FAILED(mIFaceInfo->GetTypeForParam(mVTableIndex, &paramInfo, 1,
    1:                                                      &datum_type)))
    1:             {
41138:                 Throw(NS_ERROR_XPC_CANT_GET_ARRAY_INFO, mCallContext);
41138:                 return JS_FALSE;
    1:             }
    1:         }
    1:         else
    1:             datum_type = type;
    1: 
    1:         if(isArray || isSizedString)
    1:         {
41138:             if(!GetArraySizeFromParam(i, &array_count))
41138:                 return JS_FALSE;
41138:         }
41138: 
41138:         nsID param_iid;
    1:         if(datum_type.IsInterfacePointer() &&
41138:            !GetInterfaceTypeFromParam(i, datum_type, &param_iid))
41138:             return JS_FALSE;
41138: 
41138:         uintN err;
    1: 
    1:         if(isArray)
    1:         {
41138:             XPCLazyCallContext lccx(mCallContext);
31395:             if(!XPCConvert::NativeArray2JS(lccx, &v, (const void**)&dp->val,
    1:                                            datum_type, &param_iid,
41138:                                            array_count, mCallContext.GetCurrentJSObject(),
    1:                                            &err))
    1:             {
    1:                 // XXX need exception scheme for arrays to indicate bad element
41138:                 ThrowBadParam(err, i, mCallContext);
41138:                 return JS_FALSE;
    1:             }
    1:         }
    1:         else if(isSizedString)
    1:         {
41138:             if(!XPCConvert::NativeStringWithSize2JS(mCallContext, &v,
    1:                                                     (const void*)&dp->val,
    1:                                                     datum_type,
    1:                                                     array_count, &err))
    1:             {
41138:                 ThrowBadParam(err, i, mCallContext);
41138:                 return JS_FALSE;
    1:             }
    1:         }
    1:         else
    1:         {
41138:             if(!XPCConvert::NativeData2JS(mCallContext, &v, &dp->val, datum_type,
    1:                                           &param_iid,
41138:                                           mCallContext.GetCurrentJSObject(), &err))
41138:             {
41138:                 ThrowBadParam(err, i, mCallContext);
41138:                 return JS_FALSE;
    1:             }
    1:         }
    1: 
    1:         if(paramInfo.IsRetval())
    1:         {
46230:             if(!mCallContext.GetReturnValueWasSet() && type.TagPart() != nsXPTType::T_JSVAL)
41138:                 mCallContext.SetRetVal(v);
41138:         }
41138:         else if(i < mArgc)
    1:         {
    1:             // we actually assured this before doing the invoke
41138:             NS_ASSERTION(JSVAL_IS_OBJECT(mArgv[i]), "out var is not object");
41138:             if(!JS_SetPropertyById(mCallContext,
41138:                                    JSVAL_TO_OBJECT(mArgv[i]),
41138:                                    mIdxValueId, &v))
41138:             {
41138:                 ThrowBadParam(NS_ERROR_XPC_CANT_SET_OUT_VAL, i, mCallContext);
41138:                 return JS_FALSE;
    1:             }
    1:         }
 8557:         else
 8557:         {
 8557:             NS_ASSERTION(paramInfo.IsOptional(),
 8557:                          "Expected either enough arguments or an optional argument");
 8557:         }
    1:     }
    1: 
41138:     return JS_TRUE;
41138: }
41138: 
41138: JSBool
41138: CallMethodHelper::QueryInterfaceFastPath() const
41138: {
41138:     NS_ASSERTION(mVTableIndex == 0,
41138:                  "Using the QI fast-path for a method other than QueryInterface");
41138: 
41138:     if(mArgc < 1)
41138:     {
41138:         Throw(NS_ERROR_XPC_NOT_ENOUGH_ARGS, mCallContext);
41138:         return JS_FALSE;
41138:     }
41138:     const nsID* iid;
41138:     JSObject* obj;
41138:     if(!JSVAL_IS_OBJECT(mArgv[0]) ||
41138:        (!(obj = JSVAL_TO_OBJECT(mArgv[0]))) ||
41138:        (!(iid = xpc_JSObjectToID(mCallContext, obj))))
41138:     {
41138:         ThrowBadParam(NS_ERROR_XPC_BAD_CONVERT_JS, 0, mCallContext);
41138:         return JS_FALSE;
41138:     }
41138: 
41138:     nsresult invokeResult;
41138:     nsISupports* qiresult = nsnull;
41138:     if(XPCPerThreadData::IsMainThread(mCallContext))
41138:     {
41138:         invokeResult = mCallee->QueryInterface(*iid, (void**) &qiresult);
41138:     }
41138:     else
41138:     {
41138:         JSAutoSuspendRequest suspended(mCallContext);
41138:         invokeResult = mCallee->QueryInterface(*iid, (void**) &qiresult);
41138:     }
41138: 
41138:     mCallContext.GetXPCContext()->SetLastResult(invokeResult);
41138: 
41138:     if(NS_FAILED(invokeResult))
41138:     {
41138:         ThrowBadResult(invokeResult, mCallContext);
41138:         return JS_FALSE;
41138:     }
41138: 
41138:     jsval v = JSVAL_NULL;
41138:     uintN err;
41138:     JSBool success =
41138:         XPCConvert::NativeData2JS(mCallContext, &v, &qiresult,
41138:                                   nsXPTType::T_INTERFACE_IS | XPT_TDP_POINTER,
41138:                                   iid, mCallContext.GetCurrentJSObject(), &err);
41138:     NS_IF_RELEASE(qiresult);
41138: 
41138:     if(!success)
41138:     {
41138:         ThrowBadParam(err, 0, mCallContext);
41138:         return JS_FALSE;
41138:     }
41138: 
41138:     mCallContext.SetRetVal(v);
41138:     return JS_TRUE;
41138: }
41138: 
41138: JSBool
41138: CallMethodHelper::InitializeDispatchParams()
41138: {
41138:     const uint8 wantsOptArgc = mMethodInfo->WantsOptArgc() ? 1 : 0;
46381:     const uint8 wantsJSContext = mMethodInfo->WantsContext() ? 1 : 0;
41138:     const uint8 paramCount = mMethodInfo->GetParamCount();
41138:     uint8 requiredArgs = paramCount;
46381:     uint8 hasRetval = 0;
41138: 
41138:     // XXX ASSUMES that retval is last arg. The xpidl compiler ensures this.
41138:     if(paramCount && mMethodInfo->GetParam(paramCount-1).IsRetval())
46381:     {
46381:         hasRetval = 1;
41138:         requiredArgs--;
46381:     }
41138: 
41138:     if(mArgc < requiredArgs || wantsOptArgc)
41138:     {
41138:         if(wantsOptArgc)
41138:             mOptArgcIndex = requiredArgs;
41138: 
41138:         // skip over any optional arguments
41138:         while(requiredArgs && mMethodInfo->GetParam(requiredArgs-1).IsOptional())
41138:             requiredArgs--;
41138: 
41138:         if(mArgc < requiredArgs) {
41138:             Throw(NS_ERROR_XPC_NOT_ENOUGH_ARGS, mCallContext);
41138:             return JS_FALSE;
41138:         }
41138:     }
41138: 
46381:     if(wantsJSContext)
46381:     {
46381:         if(wantsOptArgc)
46381:             // Need to bump mOptArgcIndex up one here.
46381:             mJSContextIndex = mOptArgcIndex++;
46381:         else
46381:             mJSContextIndex = paramCount - hasRetval;
46381:     }
46381: 
41138:     // iterate through the params to clear flags (for safe cleanup later)
46381:     for(uint8 i = 0; i < paramCount + wantsJSContext + wantsOptArgc; i++)
41138:     {
41138:         nsXPTCVariant* dp = mDispatchParams.AppendElement();
41138:         dp->ClearFlags();
41138:         dp->val.p = nsnull;
41138:     }
41138: 
46381:     // Fill in the JSContext argument
46381:     if(wantsJSContext)
46381:     {
46381:         nsXPTCVariant* dp = &mDispatchParams[mJSContextIndex];
46381:         dp->type = nsXPTType::T_VOID;
46381:         dp->val.p = mCallContext;
46381:     }
46381: 
41138:     // Fill in the optional_argc argument
41138:     if(wantsOptArgc)
41138:     {
41138:         nsXPTCVariant* dp = &mDispatchParams[mOptArgcIndex];
41138:         dp->type = nsXPTType::T_U8;
41138:         dp->val.u8 = mArgc - requiredArgs;
41138:     }
41138: 
41138:     return JS_TRUE;
41138: }
41138: 
41138: JSBool
41138: CallMethodHelper::ConvertIndependentParams(JSBool* foundDependentParam)
41138: {
41138:     const uint8 paramCount = mMethodInfo->GetParamCount();
41138:     for(uint8 i = 0; i < paramCount; i++)
41138:     {
41138:         JSBool useAllocator = JS_FALSE;
41138:         const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(i);
41138:         const nsXPTType& type = paramInfo.GetType();
41138:         uint8 type_tag = type.TagPart();
41138: 
41138:         if(type.IsDependent())
41138:         {
41138:             *foundDependentParam = JS_TRUE;
    1:             continue;
41138:         }
41138: 
41138:         nsXPTCVariant* dp = GetDispatchParam(i);
41138:         dp->type = type;
41138: 
41138:         if(type_tag == nsXPTType::T_INTERFACE)
41138:         {
41138:             dp->SetValIsInterface();
41138:         }
41138: 
41138:         jsval src;
41138: 
41138:         if (!GetOutParamSource(i, &src))
41138:             return JS_FALSE;
41138: 
41138:         if(paramInfo.IsOut())
41138:         {
41138:             dp->SetPtrIsData();
41138:             dp->ptr = &dp->val;
41138: 
46230:             if (type_tag == nsXPTType::T_JSVAL)
46230:             {
46230:                 if (paramInfo.IsRetval())
46230:                 {
46230:                     dp->ptr = mCallContext.GetRetVal();
46230:                 }
46230:                 else
46230:                 {
48470:                     JS_STATIC_ASSERT(sizeof(jsval) <= sizeof(uint64));
48470:                     jsval *rootp = (jsval *)&dp->val.u64;
46230:                     dp->ptr = rootp;
46230:                     *rootp = JSVAL_VOID;
47471:                     if (!JS_AddValueRoot(mCallContext, rootp))
46230:                         return JS_FALSE;
48470:                     dp->SetValIsJSRoot();
46230:                 }
46230:             }
46230: 
41138:             if(type.IsPointer() &&
41138:                type_tag != nsXPTType::T_INTERFACE &&
41138:                !paramInfo.IsShared())
41138:             {
41138:                 useAllocator = JS_TRUE;
41138:                 dp->SetValIsAllocated();
41138:             }
41138: 
41138:             if(!paramInfo.IsIn())
41138:                 continue;
41138:         }
41138:         else
41138:         {
41138:             if(type.IsPointer())
41138:             {
41138:                 switch(type_tag)
41138:                 {
41138:                 case nsXPTType::T_IID:
41138:                     dp->SetValIsAllocated();
41138:                     useAllocator = JS_TRUE;
41138:                     break;
57814:                 case nsXPTType::T_CHAR_STR:
57814:                     dp->SetValIsAllocated();
57814:                     useAllocator = JS_TRUE;
57814:                     break;
41138:                 case nsXPTType::T_ASTRING:
41138:                     // Fall through to the T_DOMSTRING case
41138: 
41138:                 case nsXPTType::T_DOMSTRING:
41138:                     if(paramInfo.IsDipper())
41138:                     {
41138:                         // Is an 'out' DOMString. Make a new nsAString
41138:                         // now and then continue in order to skip the call to
41138:                         // JSData2Native
41138: 
41138:                         if(mAutoString.empty())
41138:                         {
41138:                             mAutoString.construct();
41138:                             // Don't call SetValIsDOMString because we don't
41138:                             // want to delete this pointer.
41138:                             dp->val.p = mAutoString.addr();
41138:                             continue;
41138:                         }
41138: 
41138:                         dp->SetValIsDOMString();
41138:                         if(!(dp->val.p = new nsAutoString()))
41138:                         {
41138:                             JS_ReportOutOfMemory(mCallContext);
41138:                             return JS_FALSE;
41138:                         }
41138:                         continue;
41138:                     }
41138:                     // else...
41138: 
41138:                     // Is an 'in' DOMString. Set 'useAllocator' to indicate
41138:                     // that JSData2Native should allocate a new
41138:                     // nsAString.
41138:                     dp->SetValIsDOMString();
41138:                     useAllocator = JS_TRUE;
41138:                     break;
41138: 
41138:                 case nsXPTType::T_UTF8STRING:
41138:                     // Fall through to the C string case for now...
41138:                 case nsXPTType::T_CSTRING:
41138:                     dp->SetValIsCString();
41138:                     if(paramInfo.IsDipper())
41138:                     {
41138:                         // Is an 'out' CString.
41138:                         if(!(dp->val.p = new nsCString()))
41138:                         {
41138:                             JS_ReportOutOfMemory(mCallContext);
41138:                             return JS_FALSE;
41138:                         }
41138:                         continue;
41138:                     }
41138:                     // else ...
41138:                     // Is an 'in' CString.
41138:                     useAllocator = JS_TRUE;
41138:                     break;
41138:                 }
41138:             }
48480:             else {
48470:                 if(type_tag == nsXPTType::T_JSVAL) {
48470:                     dp->SetValIsAllocated();
48470:                     useAllocator = JS_TRUE;
48470:                 }
47616:             }
41138: 
41138:             // Do this *after* the above because in the case where we have a
41138:             // "T_DOMSTRING && IsDipper()" then arg might be null since this
41138:             // is really an 'out' param masquerading as an 'in' param.
41138:             NS_ASSERTION(i < mArgc || paramInfo.IsOptional(),
41138:                          "Expected either enough arguments or an optional argument");
47327:             if(i < mArgc)
47327:                 src = mArgv[i];
47327:             else if(type_tag == nsXPTType::T_JSVAL)
47327:                 src = JSVAL_VOID;
47327:             else
47327:                 src = JSVAL_NULL;
41138:         }
41138: 
41138:         nsID param_iid;
41138:         if(type_tag == nsXPTType::T_INTERFACE &&
41138:            NS_FAILED(mIFaceInfo->GetIIDForParamNoAlloc(mVTableIndex, &paramInfo,
41138:                                                        &param_iid)))
41138:         {
41138:             ThrowBadParam(NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO, i, mCallContext);
41138:             return JS_FALSE;
41138:         }
41138: 
41138:         uintN err;
41138:         if(!XPCConvert::JSData2Native(mCallContext, &dp->val, src, type,
41138:                                       useAllocator, &param_iid, &err))
41138:         {
41138:             ThrowBadParam(err, i, mCallContext);
41138:             return JS_FALSE;
41138:         }
41138:     }
41138: 
41138:     return JS_TRUE;
41138: }
41138: 
41138: JSBool
41138: CallMethodHelper::ConvertDependentParams()
41138: {
41138:     const uint8 paramCount = mMethodInfo->GetParamCount();
41138:     for(uint8 i = 0; i < paramCount; i++)
41138:     {
41138:         const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(i);
41138:         const nsXPTType& type = paramInfo.GetType();
41138: 
41138:         if(!type.IsDependent())
41138:             continue;
41138: 
41138:         nsXPTType datum_type;
    1:         JSUint32 array_count;
41138:         JSUint32 array_capacity;
41138:         JSBool useAllocator = JS_FALSE;
41138:         PRBool isArray = type.IsArray();
41138: 
41138:         PRBool isSizedString = isArray ?
41138:             JS_FALSE :
41138:             type.TagPart() == nsXPTType::T_PSTRING_SIZE_IS ||
41138:             type.TagPart() == nsXPTType::T_PWSTRING_SIZE_IS;
41138: 
41138:         nsXPTCVariant* dp = GetDispatchParam(i);
41138:         dp->type = type;
41138: 
41138:         if(isArray)
41138:         {
41138:             dp->SetValIsArray();
41138: 
41138:             if(NS_FAILED(mIFaceInfo->GetTypeForParam(mVTableIndex, &paramInfo, 1,
41138:                                                      &datum_type)))
41138:             {
41138:                 Throw(NS_ERROR_XPC_CANT_GET_ARRAY_INFO, mCallContext);
41138:                 return JS_FALSE;
41138:             }
41138:         }
41138:         else
41138:             datum_type = type;
41138: 
41138:         if(datum_type.IsInterfacePointer())
41138:         {
41138:             dp->SetValIsInterface();
41138:         }
41138: 
41138:         jsval src;
41138: 
41138:         if (!GetOutParamSource(i, &src))
41138:             return JS_FALSE;
41138: 
41138:         if(paramInfo.IsOut())
41138:         {
41138:             dp->SetPtrIsData();
41138:             dp->ptr = &dp->val;
41138: 
41138:             if(datum_type.IsPointer() &&
41138:                !datum_type.IsInterfacePointer() &&
41138:                (isArray || !paramInfo.IsShared()))
41138:             {
41138:                 useAllocator = JS_TRUE;
41138:                 dp->SetValIsAllocated();
41138:             }
41138: 
41138:             if(!paramInfo.IsIn())
    1:                 continue;
    1:         }
41138:         else
41138:         {
41138:             NS_ASSERTION(i < mArgc || paramInfo.IsOptional(),
41138:                          "Expected either enough arguments or an optional argument");
41138:             src = i < mArgc ? mArgv[i] : JSVAL_NULL;
41138: 
57814:             if((datum_type.IsPointer() &&
57814:                 (datum_type.TagPart() == nsXPTType::T_IID ||
57814:                  datum_type.TagPart() == nsXPTType::T_PSTRING_SIZE_IS)) ||
57814:                (isArray && datum_type.TagPart() == nsXPTType::T_CHAR_STR))
41138:             {
41138:                 useAllocator = JS_TRUE;
41138:                 dp->SetValIsAllocated();
41138:             }
41138:         }
41138: 
41138:         nsID param_iid;
41138:         if(datum_type.IsInterfacePointer() &&
41138:            !GetInterfaceTypeFromParam(i, datum_type, &param_iid))
41138:             return JS_FALSE;
41138: 
41138:         uintN err;
41138: 
41138:         if(isArray || isSizedString)
41138:         {
41138:             if(!GetArraySizeFromParam(i, &array_capacity) ||
41138:                !GetArrayLengthFromParam(i, &array_count))
41138:                 return JS_FALSE;
41138: 
41138:             if(isArray)
41138:             {
41138:                 if(array_count &&
41138:                    !XPCConvert::JSArray2Native(mCallContext, (void**)&dp->val, src,
41138:                                                array_count, array_capacity,
41138:                                                datum_type,
41138:                                                useAllocator,
41138:                                                &param_iid, &err))
41138:                 {
41138:                     // XXX need exception scheme for arrays to indicate bad element
41138:                     ThrowBadParam(err, i, mCallContext);
41138:                     return JS_FALSE;
41138:                 }
41138:             }
41138:             else // if(isSizedString)
41138:             {
41138:                 if(!XPCConvert::JSStringWithSize2Native(mCallContext,
41138:                                                         (void*)&dp->val,
41138:                                                         src,
41138:                                                         array_count, array_capacity,
41138:                                                         datum_type, useAllocator,
41138:                                                         &err))
41138:                 {
41138:                     ThrowBadParam(err, i, mCallContext);
41138:                     return JS_FALSE;
41138:                 }
41138:             }
41138:         }
41138:         else
41138:         {
41138:             if(!XPCConvert::JSData2Native(mCallContext, &dp->val, src, type,
41138:                                           useAllocator, &param_iid,
41138:                                           &err))
41138:             {
41138:                 ThrowBadParam(err, i, mCallContext);
41138:                 return JS_FALSE;
41138:             }
41138:         }
41138:     }
41138: 
41138:     return JS_TRUE;
41138: }
41138: 
41138: nsresult
41138: CallMethodHelper::Invoke()
41138: {
41138:     PRUint32 argc = mDispatchParams.Length();
41138:     nsXPTCVariant* argv = mDispatchParams.Elements();
41138: 
41138:     if(XPCPerThreadData::IsMainThread(mCallContext))
41138:         return NS_InvokeByIndex(mCallee, mVTableIndex, argc, argv);
41138: 
41138:     JSAutoSuspendRequest suspended(mCallContext);
41138:     return NS_InvokeByIndex(mCallee, mVTableIndex, argc, argv);
    1: }
    1: 
    1: /***************************************************************************/
    1: // interface methods
    1: 
    1: /* readonly attribute JSObjectPtr JSObject; */
    1: NS_IMETHODIMP XPCWrappedNative::GetJSObject(JSObject * *aJSObject)
    1: {
57794:     *aJSObject = GetFlatJSObjectAndMark();
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute nsISupports Native; */
    1: NS_IMETHODIMP XPCWrappedNative::GetNative(nsISupports * *aNative)
    1: {
    1:     // No need to QI here, we already have the correct nsISupports
    1:     // vtable.
    1:     *aNative = mIdentity;
    1:     NS_ADDREF(*aNative);
    1:     return NS_OK;
    1: }
    1: 
57794: /* reaonly attribute JSObjectPtr JSObjectPrototype; */
    1: NS_IMETHODIMP XPCWrappedNative::GetJSObjectPrototype(JSObject * *aJSObjectPrototype)
    1: {
    1:     *aJSObjectPrototype = HasProto() ?
57794:                 GetProto()->GetJSProtoObject() : GetFlatJSObjectAndMark();
    1:     return NS_OK;
    1: }
    1: 
    1: #ifndef XPCONNECT_STANDALONE
    1: nsIPrincipal*
    1: XPCWrappedNative::GetObjectPrincipal() const
    1: {
    1:     nsIPrincipal* principal = GetScope()->GetPrincipal();
    1: #ifdef DEBUG
    1:     nsCOMPtr<nsIScriptObjectPrincipal> objPrin(do_QueryInterface(mIdentity));
    1:     NS_ASSERTION(!objPrin || objPrin->GetPrincipal() == principal,
    1:                  "Principal mismatch.  Expect bad things to happen");
    1: #endif
    1:     return principal;
    1: }
    1: #endif
    1: 
    1: /* readonly attribute nsIXPConnect XPConnect; */
    1: NS_IMETHODIMP XPCWrappedNative::GetXPConnect(nsIXPConnect * *aXPConnect)
    1: {
    1:     if(IsValid())
    1:     {
    1:         nsIXPConnect* temp = GetRuntime()->GetXPConnect();
    1:         NS_IF_ADDREF(temp);
    1:         *aXPConnect = temp;
    1:     }
    1:     else
    1:         *aXPConnect = nsnull;
    1:     return NS_OK;
    1: }
    1: 
42675: /* XPCNativeInterface FindInterfaceWithMember (in jsval name); */
48470: NS_IMETHODIMP XPCWrappedNative::FindInterfaceWithMember(jsid name, nsIInterfaceInfo * *_retval)
    1: {
    1:     XPCNativeInterface* iface;
    1:     XPCNativeMember*  member;
    1: 
    1:     if(GetSet()->FindMember(name, &member, &iface) && iface)
    1:     {
    1:         nsIInterfaceInfo* temp = iface->GetInterfaceInfo();
    1:         NS_IF_ADDREF(temp);
    1:         *_retval = temp;
    1:     }
    1:     else
    1:         *_retval = nsnull;
    1:     return NS_OK;
    1: }
    1: 
42675: /* XPCNativeInterface FindInterfaceWithName (in jsval name); */
48470: NS_IMETHODIMP XPCWrappedNative::FindInterfaceWithName(jsid name, nsIInterfaceInfo * *_retval)
    1: {
    1:     XPCNativeInterface* iface = GetSet()->FindNamedInterface(name);
    1:     if(iface)
    1:     {
    1:         nsIInterfaceInfo* temp = iface->GetInterfaceInfo();
    1:         NS_IF_ADDREF(temp);
    1:         *_retval = temp;
    1:     }
    1:     else
    1:         *_retval = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: inline nsresult UnexpectedFailure(nsresult rv)
    1: {
    1:     NS_ERROR("This is not supposed to fail!");
    1:     return rv;
    1: }
    1: 
    1: /* void refreshPrototype (); */
    1: NS_IMETHODIMP XPCWrappedNative::RefreshPrototype()
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if(!HasProto())
    1:         return NS_OK;
    1: 
57794:     if(!mFlatJSObject)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
55601:     JSAutoEnterCompartment ac;
57794:     if(!ac.enter(ccx, GetFlatJSObjectAndMark()))
55601:         return UnexpectedFailure(NS_ERROR_FAILURE);
55601: 
    1:     AutoMarkingWrappedNativeProtoPtr oldProto(ccx);
    1:     AutoMarkingWrappedNativeProtoPtr newProto(ccx);
    1: 
    1:     oldProto = GetProto();
    1: 
    1:     XPCNativeScriptableInfo *info = oldProto->GetScriptableInfo();
    1:     XPCNativeScriptableCreateInfo ci(*info);
    1:     newProto = XPCWrappedNativeProto::GetNewOrUsed(ccx, oldProto->GetScope(),
    1:                                                    oldProto->GetClassInfo(),
    1:                                                    &ci,
    1:                                                    !oldProto->IsShared(),
21218:                                                    (info->GetJSClass()->flags & JSCLASS_IS_GLOBAL),
21218:                                                    oldProto->GetOffsetsMasked());
    1:     if(!newProto)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     // If nothing needs to change then we're done.
    1: 
    1:     if(newProto.get() == oldProto.get())
    1:         return NS_OK;
    1: 
57794:     if(!JS_SetPrototype(ccx, GetFlatJSObjectAndMark(),
57794:                         newProto->GetJSProtoObject()))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
12418:     SetProto(newProto);
    1: 
    1:     if(mScriptableInfo == oldProto->GetScriptableInfo())
    1:         mScriptableInfo = newProto->GetScriptableInfo();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP XPCWrappedNative::GetSecurityInfoAddress(void*** securityInfoAddrPtr)
    1: {
    1:     NS_ENSURE_ARG_POINTER(securityInfoAddrPtr);
    1:     *securityInfoAddrPtr = GetSecurityInfoAddr();
    1:     return NS_OK;
    1: }
    1: 
    1: /* void debugDump (in short depth); */
    1: NS_IMETHODIMP XPCWrappedNative::DebugDump(PRInt16 depth)
    1: {
    1: #ifdef DEBUG
    1:     depth-- ;
    1:     XPC_LOG_ALWAYS(("XPCWrappedNative @ %x with mRefCnt = %d", this, mRefCnt.get()));
    1:     XPC_LOG_INDENT();
    1: 
    1:         if(HasProto())
    1:         {
12418:             XPCWrappedNativeProto* proto = GetProto();
12418:             if(depth && proto)
12418:                 proto->DebugDump(depth);
    1:             else
12418:                 XPC_LOG_ALWAYS(("mMaybeProto @ %x", proto));
    1:         }
    1:         else
12418:             XPC_LOG_ALWAYS(("Scope @ %x", GetScope()));
    1: 
24206:         if(depth && mSet)
24206:             mSet->DebugDump(depth);
    1:         else
24206:             XPC_LOG_ALWAYS(("mSet @ %x", mSet));
    1: 
    1:         XPC_LOG_ALWAYS(("mFlatJSObject of %x", mFlatJSObject));
 2953:         XPC_LOG_ALWAYS(("mIdentity of %x", mIdentity));
    1:         XPC_LOG_ALWAYS(("mScriptableInfo @ %x", mScriptableInfo));
    1: 
    1:         if(depth && mScriptableInfo)
    1:         {
    1:             XPC_LOG_INDENT();
    1:             XPC_LOG_ALWAYS(("mScriptable @ %x", mScriptableInfo->GetCallback()));
    1:             XPC_LOG_ALWAYS(("mFlags of %x", (PRUint32)mScriptableInfo->GetFlags()));
    1:             XPC_LOG_ALWAYS(("mJSClass @ %x", mScriptableInfo->GetJSClass()));
    1:             XPC_LOG_OUTDENT();
    1:         }
    1:     XPC_LOG_OUTDENT();
    1: #endif
    1:     return NS_OK;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: char*
    1: XPCWrappedNative::ToString(XPCCallContext& ccx,
    1:                            XPCWrappedNativeTearOff* to /* = nsnull */ ) const
    1: {
    1: #ifdef DEBUG
    1: #  define FMT_ADDR " @ 0x%p"
    1: #  define FMT_STR(str) str
    1: #  define PARAM_ADDR(w) , w
    1: #else
    1: #  define FMT_ADDR ""
    1: #  define FMT_STR(str)
    1: #  define PARAM_ADDR(w)
    1: #endif
    1: 
    1:     char* sz = nsnull;
    1:     char* name = nsnull;
    1: 
    1:     XPCNativeScriptableInfo* si = GetScriptableInfo();
    1:     if(si)
    1:         name = JS_smprintf("%s", si->GetJSClass()->name);
    1:     if(to)
    1:     {
    1:         const char* fmt = name ? " (%s)" : "%s";
    1:         name = JS_sprintf_append(name, fmt,
    1:                                  to->GetInterface()->GetNameString());
    1:     }
    1:     else if(!name)
    1:     {
    1:         XPCNativeSet* set = GetSet();
    1:         XPCNativeInterface** array = set->GetInterfaceArray();
    1:         PRUint16 count = set->GetInterfaceCount();
    1: 
    1:         if(count == 1)
    1:             name = JS_sprintf_append(name, "%s", array[0]->GetNameString());
    1:         else if(count == 2 &&
    1:                 array[0] == XPCNativeInterface::GetISupports(ccx))
    1:         {
    1:             name = JS_sprintf_append(name, "%s", array[1]->GetNameString());
    1:         }
    1:         else
    1:         {
    1:             for(PRUint16 i = 0; i < count; i++)
    1:             {
    1:                 const char* fmt = (i == 0) ?
    1:                                     "(%s" : (i == count-1) ?
    1:                                         ", %s)" : ", %s";
    1:                 name = JS_sprintf_append(name, fmt,
    1:                                          array[i]->GetNameString());
    1:             }
    1:         }
    1:     }
    1: 
    1:     if(!name)
    1:     {
    1:         return nsnull;
    1:     }
    1:     const char* fmt = "[xpconnect wrapped %s" FMT_ADDR FMT_STR(" (native")
    1:         FMT_ADDR FMT_STR(")") "]";
    1:     if(si)
    1:     {
    1:         fmt = "[object %s" FMT_ADDR FMT_STR(" (native") FMT_ADDR FMT_STR(")") "]";
    1:     }
    1:     sz = JS_smprintf(fmt, name PARAM_ADDR(this) PARAM_ADDR(mIdentity));
    1: 
    1:     JS_smprintf_free(name);
    1: 
    1: 
    1:     return sz;
    1: 
    1: #undef FMT_ADDR
    1: #undef PARAM_ADDR
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: #ifdef XPC_CHECK_CLASSINFO_CLAIMS
    1: static void DEBUG_CheckClassInfoClaims(XPCWrappedNative* wrapper)
    1: {
    1:     if(!wrapper || !wrapper->GetClassInfo())
    1:         return;
    1: 
    1:     nsISupports* obj = wrapper->GetIdentityObject();
    1:     XPCNativeSet* set = wrapper->GetSet();
    1:     PRUint16 count = set->GetInterfaceCount();
    1:     for(PRUint16 i = 0; i < count; i++)
    1:     {
    1:         nsIClassInfo* clsInfo = wrapper->GetClassInfo();
    1:         XPCNativeInterface* iface = set->GetInterfaceAt(i);
    1:         nsIInterfaceInfo* info = iface->GetInterfaceInfo();
    1:         const nsIID* iid;
    1:         nsISupports* ptr;
    1: 
    1:         info->GetIIDShared(&iid);
    1:         nsresult rv = obj->QueryInterface(*iid, (void**)&ptr);
    1:         if(NS_SUCCEEDED(rv))
    1:         {
    1:             NS_RELEASE(ptr);
    1:             continue;
    1:         }
    1:         if(rv == NS_ERROR_OUT_OF_MEMORY)
    1:             continue;
    1: 
    1:         // Houston, We have a problem...
    1: 
    1:         char* className = nsnull;
    1:         char* contractID = nsnull;
    1:         const char* interfaceName;
    1: 
    1:         info->GetNameShared(&interfaceName);
    1:         clsInfo->GetContractID(&contractID);
    1:         if(wrapper->GetScriptableInfo())
    1:         {
    1:             wrapper->GetScriptableInfo()->GetCallback()->
    1:                 GetClassName(&className);
    1:         }
    1: 
    1: 
    1:         printf("\n!!! Object's nsIClassInfo lies about its interfaces!!!\n"
    1:                "   classname: %s \n"
    1:                "   contractid: %s \n"
    1:                "   unimplemented interface name: %s\n\n",
    1:                className ? className : "<unknown>",
    1:                contractID ? contractID : "<unknown>",
    1:                interfaceName);
    1: 
    1: #ifdef XPC_ASSERT_CLASSINFO_CLAIMS
    1:         NS_ERROR("Fix this QueryInterface or nsIClassInfo");
    1: #endif
    1: 
    1:         if(className)
    1:             nsMemory::Free(className);
    1:         if(contractID)
    1:             nsMemory::Free(contractID);
    1:     }
    1: }
    1: #endif
    1: 
    1: #ifdef XPC_REPORT_SHADOWED_WRAPPED_NATIVE_MEMBERS
    1: static void DEBUG_PrintShadowObjectInfo(const char* header,
    1:                                         XPCNativeSet* set,
    1:                                         XPCWrappedNative* wrapper,
    1:                                         XPCWrappedNativeProto* proto)
    1: 
    1: {
    1:     if(header)
    1:         printf("%s\n", header);
    1: 
    1:     printf("   XPCNativeSet @ 0x%p for the class:\n", (void*)set);
    1: 
    1:     char* className = nsnull;
    1:     char* contractID = nsnull;
    1: 
    1:     nsIClassInfo* clsInfo = proto ? proto->GetClassInfo() : nsnull;
    1:     if(clsInfo)
    1:         clsInfo->GetContractID(&contractID);
    1: 
    1:     XPCNativeScriptableInfo* si = wrapper ?
    1:             wrapper->GetScriptableInfo() :
    1:             proto->GetScriptableInfo();
    1:     if(si)
    1:         si->GetCallback()->GetClassName(&className);
    1: 
    1:     printf("   classname: %s \n"
    1:            "   contractid: %s \n",
    1:            className ? className : "<unknown>",
    1:            contractID ? contractID : "<unknown>");
    1: 
    1:     if(className)
    1:         nsMemory::Free(className);
    1:     if(contractID)
    1:         nsMemory::Free(contractID);
    1: 
    1:     printf("   claims to implement interfaces:\n");
    1: 
    1:     PRUint16 count = set->GetInterfaceCount();
    1:     for(PRUint16 i = 0; i < count; i++)
    1:     {
    1:         XPCNativeInterface* iface = set->GetInterfaceAt(i);
    1:         nsIInterfaceInfo* info = iface->GetInterfaceInfo();
    1:         const char* interfaceName;
    1:         info->GetNameShared(&interfaceName);
    1:         printf("      %s\n", interfaceName);
    1:     }
    1: }
    1: 
    1: static void ReportSingleMember(jsval ifaceName,
    1:                                jsval memberName)
    1: {
57721:     JS_FileEscapedString(stdout, ifaceName, 0);
57721:     if(JSVAL_IS_STRING(memberName)) {
57721:         fputs("::", stdout);
57721:         JS_FileEscapedString(stdout, memberName, 0);
57721:     }
    1: }
    1: 
    1: static void ShowHeader(JSBool* printedHeader,
    1:                        const char* header,
    1:                        XPCNativeSet* set,
    1:                        XPCWrappedNative* wrapper,
    1:                        XPCWrappedNativeProto* proto)
    1: {
    1:     if(!*printedHeader)
    1:     {
    1:         DEBUG_PrintShadowObjectInfo(header, set, wrapper, proto);
    1:         *printedHeader = JS_TRUE;
    1:     }
    1: 
    1: }
    1: 
    1: static void ShowOneShadow(jsval ifaceName1,
    1:                           jsval memberName1,
    1:                           jsval ifaceName2,
    1:                           jsval memberName2)
    1: {
    1:     ReportSingleMember(ifaceName1, memberName1);
    1:     printf(" shadows ");
    1:     ReportSingleMember(ifaceName2, memberName2);
    1:     printf("\n");
    1: }
    1: 
    1: static void ShowDuplicateInterface(jsval ifaceName)
    1: {
57721:     fputs(" ! ", stdout);
57721:     JS_FileEscapedString(stdout, ifaceName, 0);
57721:     fputs(" appears twice in the nsIClassInfo interface set!\n", stdout);
    1: }
    1: 
    1: static JSBool InterfacesAreRelated(XPCNativeInterface* iface1,
    1:                                    XPCNativeInterface* iface2)
    1: {
    1:     nsIInterfaceInfo* info1 = iface1->GetInterfaceInfo();
    1:     nsIInterfaceInfo* info2 = iface2->GetInterfaceInfo();
    1: 
    1:     NS_ASSERTION(info1 != info2, "should not have different iface!");
    1: 
    1:     PRBool match;
    1: 
    1:     return
    1:         (NS_SUCCEEDED(info1->HasAncestor(iface2->GetIID(), &match)) && match) ||
    1:         (NS_SUCCEEDED(info2->HasAncestor(iface1->GetIID(), &match)) && match);
    1: }
    1: 
    1: static JSBool MembersAreTheSame(XPCNativeInterface* iface1,
    1:                                 PRUint16 memberIndex1,
    1:                                 XPCNativeInterface* iface2,
    1:                                 PRUint16 memberIndex2)
    1: {
    1:     nsIInterfaceInfo* info1 = iface1->GetInterfaceInfo();
    1:     nsIInterfaceInfo* info2 = iface2->GetInterfaceInfo();
    1: 
    1:     XPCNativeMember* member1 = iface1->GetMemberAt(memberIndex1);
    1:     XPCNativeMember* member2 = iface2->GetMemberAt(memberIndex2);
    1: 
    1:     PRUint16 index1 = member1->GetIndex();
    1:     PRUint16 index2 = member2->GetIndex();
    1: 
    1:     // If they are both constants, then we'll just be sure that they are equivalent.
    1: 
    1:     if(member1->IsConstant())
    1:     {
    1:         if(!member2->IsConstant())
    1:             return JS_FALSE;
    1: 
    1:         const nsXPTConstant* constant1;
    1:         const nsXPTConstant* constant2;
    1: 
    1:         return NS_SUCCEEDED(info1->GetConstant(index1, &constant1)) &&
    1:                NS_SUCCEEDED(info2->GetConstant(index2, &constant2)) &&
    1:                constant1->GetType() == constant2->GetType() &&
    1:                constant1->GetValue() == constant2->GetValue();
    1:     }
    1: 
    1:     // Else we make sure they are of the same 'type' and return true only if
    1:     // they are inherited from the same interface.
    1: 
    1:     if(member1->IsMethod() != member2->IsMethod() ||
    1:        member1->IsWritableAttribute() != member2->IsWritableAttribute() ||
    1:        member1->IsReadOnlyAttribute() != member2->IsReadOnlyAttribute())
    1:     {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     const nsXPTMethodInfo* mi1;
    1:     const nsXPTMethodInfo* mi2;
    1: 
    1:     return NS_SUCCEEDED(info1->GetMethodInfo(index1, &mi1)) &&
    1:            NS_SUCCEEDED(info2->GetMethodInfo(index2, &mi2)) &&
    1:            mi1 == mi2;
    1: }
    1: 
    1: void DEBUG_ReportShadowedMembers(XPCNativeSet* set,
    1:                                  XPCWrappedNative* wrapper,
    1:                                  XPCWrappedNativeProto* proto)
    1: {
    1:     // NOTE: Either wrapper or proto could be null...
    1: 
    1:     if(!(proto || wrapper) || !set || set->GetInterfaceCount() < 2)
    1:         return;
    1: 
    1:     NS_ASSERTION(proto || wrapper, "bad param!");
    1:     XPCJSRuntime* rt = proto ? proto->GetRuntime() : wrapper->GetRuntime();
    1: 
    1:     // a quicky hack to avoid reporting info for the same set too often
    1:     static int nextSeenSet = 0;
    1:     static const int MAX_SEEN_SETS = 128;
    1:     static XPCNativeSet* SeenSets[MAX_SEEN_SETS];
    1:     for(int seen = 0; seen < MAX_SEEN_SETS; seen++)
    1:         if(set == SeenSets[seen])
    1:             return;
    1:     SeenSets[nextSeenSet] = set;
    1: 
    1: #ifdef off_DEBUG_jband
    1:     static int seenCount = 0;
    1:     printf("--- adding SeenSets[%d] = 0x%p\n", nextSeenSet, set);
    1:     DEBUG_PrintShadowObjectInfo(nsnull, set, wrapper, proto);
    1: #endif
    1:     int localNext = nextSeenSet+1;
    1:     nextSeenSet = localNext < MAX_SEEN_SETS ? localNext : 0;
    1: 
    1:     XPCNativeScriptableInfo* si = wrapper ?
    1:             wrapper->GetScriptableInfo() :
    1:             proto->GetScriptableInfo();
    1: 
    1:     // We just want to skip some classes...
    1:     if(si)
    1:     {
    1:         // Add any classnames to skip to this (null terminated) array...
    1:         static const char* skipClasses[] = {
    1:             "Window",
    1:             "HTMLDocument",
    1:             "HTMLCollection",
    1:             "Event",
    1:             "ChromeWindow",
    1:             nsnull
    1:         };
    1: 
    1:         static PRBool warned = JS_FALSE;
    1:         if(!warned)
    1:         {
    1:             printf("!!! XPConnect won't warn about Shadowed Members of...\n  ");
    1:             for(const char** name = skipClasses; *name; name++)
    1:                 printf("%s %s", name == skipClasses ? "" : ",", *name);
    1:              printf("\n");
    1:             warned = JS_TRUE;
    1:         }
    1: 
    1:         PRBool quit = JS_FALSE;
    1:         char* className = nsnull;
    1:         si->GetCallback()->GetClassName(&className);
    1:         if(className)
    1:         {
    1:             for(const char** name = skipClasses; *name; name++)
    1:             {
    1:                 if(!strcmp(*name, className))
    1:                 {
    1:                     quit = JS_TRUE;
    1:                     break;
    1:                 }
    1:             }
    1:             nsMemory::Free(className);
    1:         }
    1:         if(quit)
    1:             return;
    1:     }
    1: 
    1:     const char header[] =
    1:         "!!!Object wrapped by XPConnect has members whose names shadow each other!!!";
    1: 
    1:     JSBool printedHeader = JS_FALSE;
    1: 
    1:     jsval QIName = rt->GetStringJSVal(XPCJSRuntime::IDX_QUERY_INTERFACE);
    1: 
    1:     PRUint16 ifaceCount = set->GetInterfaceCount();
    1:     PRUint16 i, j, k, m;
    1: 
    1:     // First look for duplicate interface entries
    1: 
    1:     for(i = 0; i < ifaceCount; i++)
    1:     {
    1:         XPCNativeInterface* ifaceOuter = set->GetInterfaceAt(i);
    1:         for(k = i+1; k < ifaceCount; k++)
    1:         {
    1:             XPCNativeInterface* ifaceInner = set->GetInterfaceAt(k);
    1:             if(ifaceInner == ifaceOuter)
    1:             {
    1:                 ShowHeader(&printedHeader, header, set, wrapper, proto);
    1:                 ShowDuplicateInterface(ifaceOuter->GetName());
    1:             }
    1:         }
    1:     }
    1: 
    1:     // Now scan for shadowing names
    1: 
    1:     for(i = 0; i < ifaceCount; i++)
    1:     {
    1:         XPCNativeInterface* ifaceOuter = set->GetInterfaceAt(i);
    1:         jsval ifaceOuterName = ifaceOuter->GetName();
    1: 
    1:         PRUint16 memberCountOuter = ifaceOuter->GetMemberCount();
    1:         for(j = 0; j < memberCountOuter; j++)
    1:         {
    1:             XPCNativeMember* memberOuter = ifaceOuter->GetMemberAt(j);
    1:             jsval memberOuterName = memberOuter->GetName();
    1: 
    1:             if(memberOuterName == QIName)
    1:                 continue;
    1: 
    1:             for(k = i+1; k < ifaceCount; k++)
    1:             {
    1:                 XPCNativeInterface* ifaceInner = set->GetInterfaceAt(k);
    1:                 jsval ifaceInnerName = ifaceInner->GetName();
    1: 
    1:                 // Reported elsewhere.
    1:                 if(ifaceInner == ifaceOuter)
    1:                     continue;
    1: 
    1:                 // We consider this not worth reporting because callers will
    1:                 // almost certainly be getting what they expect.
    1:                 if(InterfacesAreRelated(ifaceInner, ifaceOuter))
    1:                     continue;
    1: 
    1:                 if(ifaceInnerName == memberOuterName)
    1:                 {
    1:                     ShowHeader(&printedHeader, header, set, wrapper, proto);
    1:                     ShowOneShadow(ifaceInnerName, JSVAL_NULL,
    1:                                   ifaceOuterName, memberOuterName);
    1:                 }
    1: 
    1:                 PRUint16 memberCountInner = ifaceInner->GetMemberCount();
    1: 
    1:                 for(m = 0; m < memberCountInner; m++)
    1:                 {
    1:                     XPCNativeMember* memberInner = ifaceInner->GetMemberAt(m);
    1:                     jsval memberInnerName = memberInner->GetName();
    1: 
    1:                     if(memberInnerName == QIName)
    1:                         continue;
    1: 
    1:                     if(memberOuterName == memberInnerName &&
    1:                        !MembersAreTheSame(ifaceOuter, j, ifaceInner, m))
    1: 
    1:                     {
    1:                         ShowHeader(&printedHeader, header, set, wrapper, proto);
    1:                         ShowOneShadow(ifaceOuterName, memberOuterName,
    1:                                       ifaceInnerName, memberInnerName);
    1:                     }
    1:                 }
    1:             }
    1:         }
    1:     }
    1: }
    1: #endif
    1: 
    1: #ifdef XPC_CHECK_WRAPPER_THREADSAFETY
    1: void DEBUG_ReportWrapperThreadSafetyError(XPCCallContext& ccx,
    1:                                           const char* msg,
    1:                                           const XPCWrappedNative* wrapper)
    1: {
    1:     XPCPerThreadData* tls = ccx.GetThreadData();
    1:     if(1 != tls->IncrementWrappedNativeThreadsafetyReportDepth())
    1:         return;
    1: 
    1:     printf("---------------------------------------------------------------\n");
    1:     printf("!!!!! XPConnect wrapper thread use error...\n");
    1: 
    1:     char* wrapperDump = wrapper->ToString(ccx);
    1:     if(wrapperDump)
    1:     {
    1:         printf("  %s\n  wrapper: %s\n", msg, wrapperDump);
    1:         JS_smprintf_free(wrapperDump);
    1:     }
    1:     else
    1:         printf("  %s\n  wrapper @ 0x%p\n", msg, (void *)wrapper);
    1: 
    1:     printf("  JS call stack...\n");
 5905:     xpc_DumpJSStack(ccx, JS_TRUE, JS_TRUE, JS_TRUE);
    1:     printf("---------------------------------------------------------------\n");
    1:     
    1:     tls->ClearWrappedNativeThreadsafetyReportDepth();
    1: }
    1: 
    1: void DEBUG_CheckWrapperThreadSafety(const XPCWrappedNative* wrapper)
    1: {
    1:     XPCWrappedNativeProto* proto = wrapper->GetProto();
    1:     if(proto && proto->ClassIsThreadSafe())
    1:         return;
    1: 
    1:     if(proto && proto->ClassIsMainThreadOnly())
    1:     {
60581:         // NS_IsMainThread is safe to call even after we've started shutting
60581:         // down.
    1:         if(!NS_IsMainThread())
    1:         {
    1:             XPCCallContext ccx(NATIVE_CALLER);
    1:             DEBUG_ReportWrapperThreadSafetyError(ccx,
    1:                 "Main Thread Only wrapper accessed on another thread", wrapper);
    1:         }
    1:     }
60581:     else if(PR_GetCurrentThread() != wrapper->mThread)
    1:     {
    1:         XPCCallContext ccx(NATIVE_CALLER);
    1:         DEBUG_ReportWrapperThreadSafetyError(ccx,
    1:             "XPConnect WrappedNative is being accessed on multiple threads but "
    1:             "the underlying native xpcom object does not have a "
    1:             "nsIClassInfo with the 'THREADSAFE' flag set", wrapper);
    1:     }
    1: }
    1: #endif
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(XPCJSObjectHolder, nsIXPConnectJSObjectHolder)
    1: 
    1: NS_IMETHODIMP
    1: XPCJSObjectHolder::GetJSObject(JSObject** aJSObj)
    1: {
    1:     NS_PRECONDITION(aJSObj, "bad param");
    1:     NS_PRECONDITION(mJSObj, "bad object state");
    1:     *aJSObj = mJSObj;
    1:     return NS_OK;
    1: }
    1: 
 2072: XPCJSObjectHolder::XPCJSObjectHolder(XPCCallContext& ccx, JSObject* obj)
 2072:     : mJSObj(obj)
    1: {
 2072:     ccx.GetRuntime()->AddObjectHolderRoot(this);
    1: }
    1: 
    1: XPCJSObjectHolder::~XPCJSObjectHolder()
    1: {
57794:     RemoveFromRootSet(nsXPConnect::GetRuntimeInstance()->GetMapLock());
    1: }
    1: 
 2072: void
 2072: XPCJSObjectHolder::TraceJS(JSTracer *trc)
 2072: {
 2072:     JS_SET_TRACING_DETAILS(trc, PrintTraceName, this, 0);
 2072:     JS_CallTracer(trc, mJSObj, JSTRACE_OBJECT);
 2072: }
 2072: 
 2072: #ifdef DEBUG
 2072: // static
 2072: void
 2072: XPCJSObjectHolder::PrintTraceName(JSTracer* trc, char *buf, size_t bufsize)
 2072: {
 2072:     JS_snprintf(buf, bufsize, "XPCJSObjectHolder[0x%p].mJSObj",
 2072:                 trc->debugPrintArg);
 2072: }
 2072: #endif
 2072: 
 2072: // static
    1: XPCJSObjectHolder*
 2072: XPCJSObjectHolder::newHolder(XPCCallContext& ccx, JSObject* obj)
    1: {
 2072:     if(!obj)
    1:     {
31561:         NS_ERROR("bad param");
    1:         return nsnull;
    1:     }
 2072:     return new XPCJSObjectHolder(ccx, obj);
    1: }
30001: 
30001: JSBool
30001: MorphSlimWrapper(JSContext *cx, JSObject *obj)
30001: {
30001:     SLIM_LOG(("***** morphing from MorphSlimToWrapper (%p, %p)\n",
30001:               obj, static_cast<nsISupports*>(xpc_GetJSPrivate(obj))));
30001: 
30001:     XPCCallContext ccx(JS_CALLER, cx);
30001: 
30001:     nsISupports* object = static_cast<nsISupports*>(xpc_GetJSPrivate(obj));
30001:     nsWrapperCache *cache = nsnull;
30001:     CallQueryInterface(object, &cache);
30001:     nsRefPtr<XPCWrappedNative> wn;
30001:     nsresult rv = XPCWrappedNative::Morph(ccx, obj, nsnull, cache,
30001:                                           getter_AddRefs(wn));
30001:     return NS_SUCCEEDED(rv);
30001: }
30001: 
30001: #ifdef DEBUG_slimwrappers
30001: static PRUint32 sSlimWrappers;
30001: #endif
30001: 
55577: JSObject *
55577: ConstructProxyObject(XPCCallContext &ccx,
55577:                      xpcObjectHelper &aHelper,
55577:                      XPCWrappedNativeScope *xpcscope)
55577: {
55577:     nsISupports *identityObj = aHelper.GetCanonical();
55577:     nsXPCClassInfo *classInfoHelper = aHelper.GetXPCClassInfo();
55577: 
55577: #ifdef DEBUG
55577:     {
55577:         JSUint32 flagsInt;
55577:         nsresult debug_rv = classInfoHelper->GetScriptableFlags(&flagsInt);
55577:         XPCNativeScriptableFlags flags(flagsInt);
55577:         NS_ASSERTION(NS_SUCCEEDED(debug_rv) && flags.WantPreCreate(),
55577:                      "bad flags, cache->IsProxy() implies WantPreCreate()");
55577:     }
55577: #endif
55577: 
55577:     // We re-use the PreCreate hook to create the actual proxy object.
55577:     JSObject* parent = xpcscope->GetGlobalJSObject();
55577:     nsresult rv = classInfoHelper->PreCreate(identityObj, ccx, parent, &parent);
55577:     NS_ENSURE_SUCCESS(rv, nsnull);
55577: 
55577:     nsWrapperCache *cache = aHelper.GetWrapperCache();
55577:     JSObject *flat = cache->GetWrapper();
55577:     NS_ASSERTION(flat, "PreCreate is supposed to create the wrapper");
55577:     return flat;
55577: }
55577: 
30001: JSBool
48124: ConstructSlimWrapper(XPCCallContext &ccx,
51515:                      xpcObjectHelper &aHelper,
31395:                      XPCWrappedNativeScope* xpcScope, jsval *rval)
30001: {
51515:     nsISupports *identityObj = aHelper.GetCanonical();
51515:     nsXPCClassInfo *classInfoHelper = aHelper.GetXPCClassInfo();
40489: 
40489:     JSUint32 flagsInt;
40489:     nsresult rv = classInfoHelper->GetScriptableFlags(&flagsInt);
40489:     if(NS_FAILED(rv))
40489:         flagsInt = 0;
40489: 
40489:     XPCNativeScriptableFlags flags(flagsInt);
40489: 
40489:     NS_ASSERTION(flags.DontAskInstanceForScriptable(),
40489:                  "Not supported for cached wrappers!");
30001: 
30001:     JSObject* parent = xpcScope->GetGlobalJSObject();
40489:     if(!flags.WantPreCreate())
30001:     {
30001:         SLIM_LOG_NOT_CREATED(ccx, identityObj,
30001:                              "scriptable helper has no PreCreate hook");
30001: 
30001:         return JS_FALSE;
30001:     }
30001: 
30001:     JSObject* plannedParent = parent;
40489:     rv = classInfoHelper->PreCreate(identityObj, ccx, parent, &parent);
30001:     if(rv != NS_SUCCESS_ALLOW_SLIM_WRAPPERS)
30001:     {
30001:         SLIM_LOG_NOT_CREATED(ccx, identityObj, "PreCreate hook refused");
30001: 
30001:         return JS_FALSE;
30001:     }
30001: 
55690:     if(ccx.GetJSContext()->compartment != parent->compartment())
55690:     {
55690:         SLIM_LOG_NOT_CREATED(ccx, identityObj, "wrong compartment");
55690: 
55690:         return JS_FALSE;
55690:     }
55690: 
55601:     JSAutoEnterCompartment ac;
55601:     if(!ac.enter(ccx, parent))
55601:     {
55601:         SLIM_LOG_NOT_CREATED(ccx, identityObj, "unable to enter compartment");
55601: 
55601:         return JS_FALSE;
55601:     }
55601: 
30001:     if(parent != plannedParent)
30001:     {
30001:         XPCWrappedNativeScope *newXpcScope =
30001:             XPCWrappedNativeScope::FindInJSObjectScope(ccx, parent);
30001:         if(newXpcScope != xpcScope)
30001:         {
30001:             SLIM_LOG_NOT_CREATED(ccx, identityObj, "crossing origins");
30001: 
30001:             return JS_FALSE;
30001:         }
30001:     }
30001: 
30384:     // The PreCreate hook could have forced the creation of a wrapper, need
30384:     // to check for that here and return early.
55577:     nsWrapperCache *cache = aHelper.GetWrapperCache();
30384:     JSObject* wrapper = cache->GetWrapper();
30384:     if(wrapper)
30384:     {
30384:         *rval = OBJECT_TO_JSVAL(wrapper);
30384: 
30384:         return JS_TRUE;
30384:     }
30384: 
40493:     PRUint32 interfacesBitmap = classInfoHelper->GetInterfacesBitmap();
40491:     XPCNativeScriptableCreateInfo
51515:         sciProto(aHelper.forgetXPCClassInfo(), flags, interfacesBitmap);
40489: 
30001:     AutoMarkingWrappedNativeProtoPtr xpcproto(ccx);
30001:     JSBool isGlobal = JS_FALSE;
51515:     xpcproto = XPCWrappedNativeProto::GetNewOrUsed(ccx, xpcScope,
51515:                                                    classInfoHelper, &sciProto,
51515:                                                    JS_FALSE, isGlobal);
30001:     if(!xpcproto)
30001:         return JS_FALSE;
30001: 
30001:     xpcproto->CacheOffsets(identityObj);
30001: 
30001:     XPCNativeScriptableInfo* si = xpcproto->GetScriptableInfo();
30001:     JSClass* jsclazz = si->GetSlimJSClass();
33785:     if(!jsclazz)
30001:         return JS_FALSE;
30001: 
30384:     wrapper = xpc_NewSystemInheritingJSObject(ccx, jsclazz,
30384:                                               xpcproto->GetJSProtoObject(),
30384:                                               parent);
33785:     if(!wrapper ||
33785:        !JS_SetPrivate(ccx, wrapper, identityObj) ||
30001:        !JS_SetReservedSlot(ccx, wrapper, 0, PRIVATE_TO_JSVAL(xpcproto.get())))
30001:         return JS_FALSE;
30001: 
30001:     // Transfer ownership to the wrapper's private.
51515:     aHelper.forgetCanonical();
30001: 
30001:     cache->SetWrapper(wrapper);
30001: 
30001:     SLIM_LOG(("+++++ %i created slim wrapper (%p, %p, %p)\n", ++sSlimWrappers,
30001:               wrapper, p, xpcScope));
30001: 
30001:     *rval = OBJECT_TO_JSVAL(wrapper);
30001: 
30001:     return JS_TRUE;
30001: }
