     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* rendering objects for replaced elements implemented by a plugin */
     1: 
     1: #ifndef nsObjectFrame_h___
     1: #define nsObjectFrame_h___
     1: 
113981: #include "mozilla/Attributes.h"
 71095: #include "nsPluginInstanceOwner.h"
     1: #include "nsIObjectFrame.h"
     1: #include "nsFrame.h"
 30522: #include "nsRegion.h"
 30522: #include "nsDisplayList.h"
 52186: #include "nsIReflowCallback.h"
     1: 
 69092: class nsPluginHost;
     1: class nsPresContext;
108609: class nsRootPresContext;
 30522: class nsDisplayPlugin;
 62474: class nsIOSurface;
 62699: class PluginBackgroundSink;
     1: 
106914: namespace mozilla {
106914: namespace layers {
106914: class ImageContainer;
106914: class Layer;
106914: class LayerManager;
106914: }
106914: }
106914: 
     1: #define nsObjectFrameSuper nsFrame
     1: 
 52186: class nsObjectFrame : public nsObjectFrameSuper,
 52186:                       public nsIObjectFrame,
 52186:                       public nsIReflowCallback {
     1: public:
 54223:   typedef mozilla::LayerState LayerState;
 54223:   typedef mozilla::layers::Layer Layer;
 54223:   typedef mozilla::layers::LayerManager LayerManager;
 54223:   typedef mozilla::layers::ImageContainer ImageContainer;
114087:   typedef mozilla::FrameLayerBuilder::ContainerParameters ContainerParameters;
 54223: 
 32423:   NS_DECL_FRAMEARENA_HELPERS
 32423: 
     1:   friend nsIFrame* NS_NewObjectFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
 23554:   NS_DECL_QUERYFRAME
118929:   NS_DECL_QUERYFRAME_TARGET(nsObjectFrame)
     1: 
     1:   NS_IMETHOD Init(nsIContent* aContent,
     1:                   nsIFrame* aParent,
     1:                   nsIFrame* aPrevInFlow);
 68481:   virtual nscoord GetMinWidth(nsRenderingContext *aRenderingContext);
 68481:   virtual nscoord GetPrefWidth(nsRenderingContext *aRenderingContext);
     1:   NS_IMETHOD Reflow(nsPresContext* aPresContext,
     1:                     nsHTMLReflowMetrics& aDesiredSize,
     1:                     const nsHTMLReflowState& aReflowState,
     1:                     nsReflowStatus& aStatus);
     1:   NS_IMETHOD DidReflow(nsPresContext* aPresContext,
     1:                        const nsHTMLReflowState* aReflowState,
     1:                        nsDidReflowStatus aStatus);
     1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                               const nsRect&           aDirtyRect,
     1:                               const nsDisplayListSet& aLists);
     1: 
     1:   NS_IMETHOD  HandleEvent(nsPresContext* aPresContext,
     1:                           nsGUIEvent* aEvent,
     1:                           nsEventStatus* aEventStatus);
     1: 
 37413: #ifdef XP_MACOSX
 37413:   NS_IMETHOD HandlePress(nsPresContext* aPresContext,
 37413:                          nsGUIEvent*    aEvent,
 37413:                          nsEventStatus* aEventStatus);
 37413: #endif
 37413: 
     1:   virtual nsIAtom* GetType() const;
     1: 
108991:   virtual bool IsFrameOfType(uint32_t aFlags) const
     1:   {
     1:     return nsObjectFrameSuper::IsFrameOfType(aFlags & ~(nsIFrame::eReplaced));
     1:   }
     1: 
 79445:   virtual bool NeedsView() { return true; }
     1: 
     1: #ifdef DEBUG
     1:   NS_IMETHOD GetFrameName(nsAString& aResult) const;
     1: #endif
     1: 
 36647:   virtual void DestroyFrom(nsIFrame* aDestructRoot);
     1: 
 20836:   virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
  7015: 
 70007:   NS_METHOD GetPluginInstance(nsNPAPIPluginInstance** aPluginInstance);
 89114: 
113981:   virtual void SetIsDocumentActive(bool aIsActive) MOZ_OVERRIDE;
 77328: 
 67677:   NS_IMETHOD GetCursor(const nsPoint& aPoint, nsIFrame::Cursor& aCursor);
     1: 
118837:   // APIs used by nsRootPresContext to set up the widget position/size/clip
118837:   // region.
118837:   /**
118837:    * Set the next widget configuration for the plugin to the desired
118837:    * position of the plugin's widget, on the assumption that it is not visible
118837:    * (clipped out or covered by opaque content).
118837:    * This will only be called for plugins which have been registered
118837:    * with the root pres context for geometry updates.
118837:    * If there is no widget associated with the plugin, this will have no effect.
118837:    */
118837:   void SetEmptyWidgetConfiguration()
118837:   {
118837:     mNextConfigurationBounds = nsIntRect(0,0,0,0);
118837:     mNextConfigurationClipRegion.Clear();
 30522:   }
118837:   /**
118837:    * Append the desired widget configuration to aConfigurations.
118837:    */
118837:   void GetWidgetConfiguration(nsTArray<nsIWidget::Configuration>* aConfigurations)
118837:   {
118837:     if (mWidget) {
119290:       if (!mWidget->GetParent()) {
119290:         // Plugin widgets should not be toplevel except when they're out of the
119290:         // document, in which case the plugin should not be registered for
119290:         // geometry updates and this should not be called. But apparently we
119290:         // have bugs where mWidget sometimes is toplevel here. Bail out.
119290:         NS_ERROR("Plugin widgets registered for geometry updates should not be toplevel");
119290:         return;
119290:       }
118837:       nsIWidget::Configuration* configuration = aConfigurations->AppendElement();
118837:       configuration->mChild = mWidget;
118837:       configuration->mBounds = mNextConfigurationBounds;
118837:       configuration->mClipRegion = mNextConfigurationClipRegion;
118837:     }
118837:   }
118837:   /**
118837:    * Called after all widget position/size/clip regions have been changed
118837:    * (even if there isn't a widget for this plugin).
118837:    */
 30524:   void DidSetWidgetGeometry();
 30524: 
     1:   // accessibility support
     1: #ifdef ACCESSIBILITY
118929:   virtual mozilla::a11y::AccType AccessibleType() MOZ_OVERRIDE;
     1: #ifdef XP_WIN
     1:   NS_IMETHOD GetPluginPort(HWND *aPort);
     1: #endif
     1: #endif
     1: 
     1:   //local methods
 89114:   nsresult PrepForDrawing(nsIWidget *aWidget);
     1: 
     1:   // for a given aRoot, this walks the frame tree looking for the next outFrame
     1:   static nsIObjectFrame* GetNextObjectFrame(nsPresContext* aPresContext,
     1:                                             nsIFrame* aRoot);
     1: 
 52186:   // nsIReflowCallback
113981:   virtual bool ReflowFinished() MOZ_OVERRIDE;
113981:   virtual void ReflowCallbackCanceled() MOZ_OVERRIDE;
 52186: 
 89708:   void UpdateImageLayer(const gfxRect& aRect);
 62724: 
 62699:   /**
 62699:    * Builds either an ImageLayer or a ReadbackLayer, depending on the type
 62699:    * of aItem (TYPE_PLUGIN or TYPE_PLUGIN_READBACK respectively).
 62699:    */
 54223:   already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
 54223:                                      LayerManager* aManager,
114087:                                      nsDisplayItem* aItem,
114087:                                      const ContainerParameters& aContainerParameters);
 54223: 
 97534:   LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
 62224:                            LayerManager* aManager);
 54223: 
 89204:   already_AddRefed<ImageContainer> GetImageContainer();
 62982:   /**
 62982:    * Get the rectangle (relative to this frame) which it will paint. Normally
 62982:    * the frame's content-box but may be smaller if the plugin is rendering
 62982:    * asynchronously and has a different-sized image temporarily.
 62982:    */
 62982:   nsRect GetPaintedRect(nsDisplayPlugin* aItem);
 54223: 
 54309:   /**
 54309:    * If aContent has a nsObjectFrame, then prepare it for a DocShell swap.
 54309:    * @see nsSubDocumentFrame::BeginSwapDocShells.
 54309:    * There will be a call to EndSwapDocShells after we were moved to the
 54309:    * new view tree.
 54309:    */
 54309:   static void BeginSwapDocShells(nsIContent* aContent, void*);
 54309:   /**
 54309:    * If aContent has a nsObjectFrame, then set it up after a DocShell swap.
 54309:    * @see nsSubDocumentFrame::EndSwapDocShells.
 54309:    */
 54309:   static void EndSwapDocShells(nsIContent* aContent, void*);
 54309: 
113981:   nsIWidget* GetWidget() MOZ_OVERRIDE { return mInnerView ? mWidget : nullptr; }
 64534: 
 89114:   /**
 89114:    * Adjust the plugin's idea of its size, using aSize as its new size.
 89114:    * (aSize must be in twips)
 89114:    */
 89114:   void FixupWindow(const nsSize& aSize);
 89114: 
 89114:   /*
 89114:    * Sets up the plugin window and calls SetWindow on the plugin.
 89114:    */
 89114:   nsresult CallSetWindow(bool aCheckIsHidden = true);
 89114: 
 89114:   void SetInstanceOwner(nsPluginInstanceOwner* aOwner);
 89114: 
     1: protected:
 12417:   nsObjectFrame(nsStyleContext* aContext);
     1:   virtual ~nsObjectFrame();
     1: 
     1:   // NOTE:  This frame class does not inherit from |nsLeafFrame|, so
     1:   // this is not a virtual method implementation.
     1:   void GetDesiredSize(nsPresContext* aPresContext,
     1:                       const nsHTMLReflowState& aReflowState,
     1:                       nsHTMLReflowMetrics& aDesiredSize);
     1: 
108991:   bool IsFocusable(int32_t *aTabIndex = nullptr, bool aWithMouse = false);
     1: 
     1:   // check attributes and optionally CSS to see if we should display anything
 79445:   bool IsHidden(bool aCheckVisibilityStyle = true) const;
     1: 
 79445:   bool IsOpaque() const;
 79445:   bool IsTransparentMode() const;
118837:   bool IsPaintedByGecko() const;
 30522: 
 79445:   nsIntPoint GetWindowOriginInPixels(bool aWindowless);
     1: 
 15688:   static void PaintPrintPlugin(nsIFrame* aFrame,
 68481:                                nsRenderingContext* aRenderingContext,
 15688:                                const nsRect& aDirtyRect, nsPoint aPt);
 68481:   void PrintPlugin(nsRenderingContext& aRenderingContext,
 15688:                    const nsRect& aDirtyRect);
 56434:   void PaintPlugin(nsDisplayListBuilder* aBuilder,
 68481:                    nsRenderingContext& aRenderingContext,
 33369:                    const nsRect& aDirtyRect, const nsRect& aPluginRect);
 15688: 
 37372:   void NotifyPluginReflowObservers();
 35180: 
     1:   friend class nsPluginInstanceOwner;
 30522:   friend class nsDisplayPlugin;
 62699:   friend class PluginBackgroundSink;
 30522: 
     1: private:
108609:   // Registers the plugin for a geometry update, and requests a geometry
108609:   // update. This caches the root pres context in
108609:   // mRootPresContextRegisteredWith, so that we can be sure we unregister
108609:   // from the right root prest context in UnregisterPluginForGeometryUpdates.
108609:   void RegisterPluginForGeometryUpdates();
108609: 
108609:   // Unregisters the plugin for geometry updated with the root pres context
108609:   // stored in mRootPresContextRegisteredWith.
108609:   void UnregisterPluginForGeometryUpdates();
 37372: 
 37372:   class PluginEventNotifier : public nsRunnable {
 37372:   public:
 37372:     PluginEventNotifier(const nsString &aEventType) : 
 37372:       mEventType(aEventType) {}
 37372:     
 37372:     NS_IMETHOD Run();
 37372:   private:
 37372:     nsString mEventType;
 37372:   };
 37372: 
 89114:   nsPluginInstanceOwner*          mInstanceOwner; // WEAK
 33369:   nsIView*                        mInnerView;
 30522:   nsCOMPtr<nsIWidget>             mWidget;
 23738:   nsIntRect                       mWindowlessRect;
 62699:   /**
 62699:    * This is owned by the ReadbackLayer for this nsObjectFrame. It is
 62699:    * automatically cleared if the PluginBackgroundSink is destroyed.
 62699:    */
 62699:   PluginBackgroundSink*           mBackgroundSink;
     1: 
118837:   /**
118837:    * Bounds that we should set the plugin's widget to in the next composite,
118837:    * for plugins with widgets. For plugins without widgets, bounds in device
118837:    * pixels relative to the nearest frame that's a display list reference frame.
118837:    */
118837:   nsIntRect                       mNextConfigurationBounds;
118837:   /**
118837:    * Clip region that we should set the plugin's widget to
118837:    * in the next composite. Only meaningful for plugins with widgets.
118837:    */
118837:   nsTArray<nsIntRect>             mNextConfigurationClipRegion;
118837: 
 79445:   bool mReflowCallbackPosted;
 54223: 
 54223:   // A reference to the ImageContainer which contains the current frame
 54223:   // of plugin to display.
 54223:   nsRefPtr<ImageContainer> mImageContainer;
108609: 
108609:   // We keep this reference to ensure we can always unregister the
108609:   // plugins we register on the root PresContext.
108609:   // This is only non-null while we have a plugin registered for geometry
108609:   // updates.
108609:   nsRefPtr<nsRootPresContext> mRootPresContextRegisteredWith;
     1: };
     1: 
 30522: class nsDisplayPlugin : public nsDisplayItem {
 30522: public:
 51260:   nsDisplayPlugin(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
 51260:     : nsDisplayItem(aBuilder, aFrame)
 30522:   {
 30522:     MOZ_COUNT_CTOR(nsDisplayPlugin);
119281:     aBuilder->SetContainsPluginItem();
 30522:   }
 30522: #ifdef NS_BUILD_REFCNT_LOGGING
 30522:   virtual ~nsDisplayPlugin() {
 30522:     MOZ_COUNT_DTOR(nsDisplayPlugin);
 30522:   }
 30522: #endif
 30522: 
113981:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) MOZ_OVERRIDE;
 59779:   virtual nsRegion GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
113981:                                    bool* aSnap) MOZ_OVERRIDE;
 33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
113981:                      nsRenderingContext* aCtx) MOZ_OVERRIDE;
 79445:   virtual bool ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                    nsRegion* aVisibleRegion,
113981:                                    const nsRect& aAllowVisibleRegionExpansion) MOZ_OVERRIDE;
 30522: 
 47732:   NS_DISPLAY_DECL_NAME("Plugin", TYPE_PLUGIN)
 30522: 
 54223:   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
 72230:                                              LayerManager* aManager,
113981:                                              const ContainerParameters& aContainerParameters) MOZ_OVERRIDE
 54223:   {
 62474:     return static_cast<nsObjectFrame*>(mFrame)->BuildLayer(aBuilder,
 62474:                                                            aManager, 
114087:                                                            this,
114087:                                                            aContainerParameters);
 54223:   }
 54223: 
 54223:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
 97534:                                    LayerManager* aManager,
113981:                                    const ContainerParameters& aParameters) MOZ_OVERRIDE
 54223:   {
 62699:     return static_cast<nsObjectFrame*>(mFrame)->GetLayerState(aBuilder,
 62699:                                                               aManager);
 54223:   }
 30522: };
     1: 
     1: #endif /* nsObjectFrame_h___ */
