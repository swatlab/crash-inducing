    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla SVG project.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Crocodile Clips Ltd..
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Alex Fritze <alex.fritze@crocodile-clips.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsSVGTextFrame.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsTextFragment.h"
    1: #include "nsSVGUtils.h"
    1: #include "nsIDOMSVGLengthList.h"
    1: #include "nsIDOMSVGLength.h"
    1: #include "nsIDOMSVGRect.h"
    1: #include "nsIDOMSVGPoint.h"
    1: #include "nsSVGGlyphFrame.h"
    1: #include "nsSVGTextPathFrame.h"
    1: #include "nsSVGPathElement.h"
    1: #include "nsSVGPoint.h"
    1: #include "nsSVGRect.h"
    1: #include "nsDOMError.h"
    1: #include "gfxContext.h"
    1: #include "gfxMatrix.h"
  630: #include "gfxPlatform.h"
13259: #include "gfxTextRunWordCache.h"
25840: #include "nsTextFrame.h"
  630: 
13259: struct CharacterPosition {
13259:   gfxPoint pos;
13259:   gfxFloat angle;
13259:   PRBool draw;
13259: };
13259:   
13259: /**
13259:  * This is a do-it-all helper class. It supports iterating through the
13259:  * drawable characters of a string. For each character, it can set up
13259:  * a graphics context with a transform appropriate for drawing the
13259:  * character, or a transform appropriate for emitting geometry in the
13259:  * text metrics coordinate system (which differs from the drawing
13259:  * coordinate system by a scale factor of AppUnitPerCSSPixels). These
13259:  * transforms include offsets and rotations of characters along paths, and
13259:  * the mPosition of the nsSVGGlyphFrame.
13259:  * 
13259:  * This helper also creates the textrun as needed. It supports detecting
13259:  * the special case when the entire textrun can be drawn or measured
13259:  * as a unit, and setting the graphics context transform up for that. It
13259:  * takes care of setting up the global transform if requested. It also
13259:  * provides direct access to the character path position data for the
13259:  * DOM APIs that need that.
13259:  * 
13259:  * If an error occurs, for example, a canvas TM is not available because
13259:  * the element is in a <defs> section, then the CharacterIterator will
13259:  * behave as if the frame has no drawable characters.
13259:  *
13259:  * XXX should make this iterate clusters instead
13259:  * XXX needs RTL love
13259:  * XXX might want to make AdvanceToCharacter constant time (e.g. by
13259:  * caching advances and/or the CharacterPosition array across DOM
13259:  * API calls) to ensure that calling Get*OfChar (etc) for each character
13259:  * in the text is O(N)
13259:  */
13259: class CharacterIterator
13259: {
13259: public:
13259:   /**
13259:    * Sets up the iterator so that NextChar will return the first drawable
13259:    * char.
13259:    * @param aForceGlobalTransform passed on to EnsureTextRun (see below)
13259:    */
13259:   CharacterIterator(nsSVGGlyphFrame *aSource, PRBool aForceGlobalTransform);
13259:   /**
13259:    * This matrix will be applied to aContext in the SetupFor methods below,
13259:    * before any glyph translation/rotation.
13259:    */
13760:   void SetInitialMatrix(gfxContext *aContext) {
13760:     mInitialMatrix = aContext->CurrentMatrix();
13760:     if (mInitialMatrix.IsSingular()) {
13760:       mInError = PR_TRUE;
13760:     }
13760:   }
13259:   /**
13259:    * Try to set up aContext so we can draw the whole textrun at once.
13760:    * This applies any global transform requested by SetInitialMatrix,
13259:    * then applies the positioning of the text. Returns false if drawing
13259:    * the whole textrun at once is impossible due to individual positioning
13259:    * and/or rotation of glyphs.
13259:    */
13259:   PRBool SetupForDirectTextRunDrawing(gfxContext *aContext) {
13259:     return SetupForDirectTextRun(aContext, mDrawScale);
13259:   }
13259:   /**
13259:    * Try to set up aContext so we can measure the whole textrun at once.
13760:    * This applies any global transform requested by SetInitialMatrix,
13259:    * then applies the positioning of the text, then applies a scale
13259:    * from appunits to device pixels so drawing in appunits works.
13259:    * Returns false if drawing the whole textrun at once is impossible due
13259:    * to individual positioning and/or rotation of glyphs.
13259:    */
13259:   PRBool SetupForDirectTextRunMetrics(gfxContext *aContext) {
13259:     return SetupForDirectTextRun(aContext, mMetricsScale);
13259:   }
13259: 
13259:   /**
13259:    * Returns the index of the next char in the string that should be
13259:    * drawn, or -1 if there is no such character.
13259:    */
13259:   PRInt32 NextChar();
13259:   /**
13259:    * Repeated calls NextChar until it returns aIndex (i.e. aIndex is the
13259:    * current drawable character). Returns false if that never happens
13259:    * (because aIndex is before or equal to the current character, or
13259:    * out of bounds, or not drawable).
13259:    */
13259:   PRBool AdvanceToCharacter(PRInt32 aIndex);
13259: 
13259:   /**
13259:    * Set up aContext for glyph drawing. This applies any global transform
13760:    * requested by SetInitialMatrix, then applies any positioning and
13259:    * rotation for the current character.
13259:    */
13259:   void SetupForDrawing(gfxContext *aContext) {
13259:     return SetupFor(aContext, mDrawScale);
13259:   }
13259:   /**
13259:    * Set up aContext for glyph measuring. This applies any global transform
13760:    * requested by SetInitialMatrix, then applies any positioning and
13259:    * rotation for the current character, then applies a scale from appunits
13259:    * to device pixels so that drawing in appunits sizes works.
13259:    */
13259:   void SetupForMetrics(gfxContext *aContext) {
13259:     return SetupFor(aContext, mMetricsScale);
13259:   }
13259:   /**
13259:    * Get the raw position data for the current character.
13259:    */
13259:   CharacterPosition GetPositionData();
13259: 
13259: private:
13259:   PRBool SetupForDirectTextRun(gfxContext *aContext, float aScale);
13259:   void SetupFor(gfxContext *aContext, float aScale);
13259: 
13259:   nsSVGGlyphFrame *mSource;
13259:   nsAutoTArray<CharacterPosition,80> mPositions;
13259:   gfxMatrix mInitialMatrix;
13259:   // Textrun advance width from start to mCurrentChar, in appunits
13259:   gfxFloat mCurrentAdvance;
13259:   PRInt32 mCurrentChar;
13259:   float mDrawScale;
13259:   float mMetricsScale;
13259:   PRPackedBool mInError;
13259: };
    1: 
    1: //----------------------------------------------------------------------
    1: // Implementation
    1: 
    1: nsIFrame*
23953: NS_NewSVGGlyphFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsSVGGlyphFrame(aContext);
    1: }
    1: 
    1: //----------------------------------------------------------------------
23554: // nsQueryFrame methods
    1: 
23554: NS_QUERYFRAME_HEAD(nsSVGGlyphFrame)
23554:   NS_QUERYFRAME_ENTRY(nsISVGGlyphFragmentLeaf)
23554:   NS_QUERYFRAME_ENTRY(nsISVGGlyphFragmentNode)
23554:   NS_QUERYFRAME_ENTRY(nsISVGChildFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsSVGGlyphFrameBase)
    1: 
    1: //----------------------------------------------------------------------
    1: // nsIFrame methods
    1: 
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::CharacterDataChanged(nsPresContext*  aPresContext,
    1:                                       nsIContent*     aChild,
    1:                                       PRBool          aAppend)
    1: {
13259:   ClearTextRun();
14042:   NotifyGlyphMetricsChange();
    1: 
    1:   return NS_OK;
    1: }
    1: 
13259: // Usable font size range in devpixels / user-units
13259: #define CLAMP_MIN_SIZE 8
13259: #define CLAMP_MAX_SIZE 200
13259: #define PRECISE_SIZE   200
13259: 
20441: /* virtual */ void
20836: nsSVGGlyphFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
    1: {
20836:   nsSVGGlyphFrameBase::DidSetStyleContext(aOldStyleContext);
16307: 
16307:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
13259:     ClearTextRun();
14042:     NotifyGlyphMetricsChange();
16307:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::SetSelected(nsPresContext* aPresContext,
    1:                              nsIDOMRange*    aRange,
    1:                              PRBool          aSelected,
18931:                              nsSpread        aSpread,
18931:                              SelectionType   aType)
    1: {
    1: #if defined(DEBUG) && defined(SVG_DEBUG_SELECTION)
    1:   printf("nsSVGGlyphFrame(%p)::SetSelected()\n", this);
    1: #endif
18931: //  return nsSVGGlyphFrameBase::SetSelected(aPresContext, aRange, aSelected, aSpread, aType);
    1: 
18931:   if (aType == nsISelectionController::SELECTION_NORMAL) {
    1:     // check whether style allows selection
    1:     PRBool  selectable;
    1:     IsSelectable(&selectable, nsnull);
    1:     if (!selectable)
    1:       return NS_OK;
18931:   }
    1: 
    1:   if ( aSelected ){
    1:     mState |=  NS_FRAME_SELECTED_CONTENT;
    1:   }
    1:   else
    1:     mState &= ~NS_FRAME_SELECTED_CONTENT;
    1: 
14042:   nsSVGUtils::UpdateGraphic(this);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::GetSelected(PRBool *aSelected) const
    1: {
    1:   nsresult rv = nsSVGGlyphFrameBase::GetSelected(aSelected);
    1: #if defined(DEBUG) && defined(SVG_DEBUG_SELECTION)
    1:   printf("nsSVGGlyphFrame(%p)::GetSelected()=%d\n", this, *aSelected);
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::IsSelectable(PRBool* aIsSelectable,
    1:                               PRUint8* aSelectStyle) const
    1: {
    1:   nsresult rv = nsSVGGlyphFrameBase::IsSelectable(aIsSelectable, aSelectStyle);
    1: #if defined(DEBUG) && defined(SVG_DEBUG_SELECTION)
    1:   printf("nsSVGGlyphFrame(%p)::IsSelectable()=(%d,%d)\n", this, *aIsSelectable, aSelectStyle);
    1: #endif
    1:   return rv;
    1: }
    1: 
23953: #ifdef DEBUG
23953: NS_IMETHODIMP
23953: nsSVGGlyphFrame::Init(nsIContent* aContent,
23953:                       nsIFrame* aParent,
23953:                       nsIFrame* aPrevInFlow)
23953: {
23953:   NS_ASSERTION(aParent, "null parent");
23953: 
23953:   nsIFrame* ancestorFrame = nsSVGUtils::GetFirstNonAAncestorFrame(aParent);
23953:   NS_ASSERTION(ancestorFrame, "Must have ancestor");
23953: 
23953:   nsISVGTextContentMetrics *metrics = do_QueryFrame(ancestorFrame);
23953:   NS_ASSERTION(metrics,
23953:                "trying to construct an SVGGlyphFrame for an invalid container");
23953: 
23953:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
23953:                "trying to construct an SVGGlyphFrame for wrong content element");
23953: 
26295:   if (!PresContext()->IsDynamic()) {
26295:     AddStateBits(NS_STATE_SVG_PRINTING);
26295:   }
25840: 
23953:   return nsSVGGlyphFrameBase::Init(aContent, aParent, aPrevInFlow);
23953: }
23953: #endif /* DEBUG */
23953: 
    1: nsIAtom *
    1: nsSVGGlyphFrame::GetType() const
    1: {
    1:   return nsGkAtoms::svgGlyphFrame;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsISVGChildFrame methods
    1: 
    1: NS_IMETHODIMP
20652: nsSVGGlyphFrame::PaintSVG(nsSVGRenderState *aContext,
20652:                           const nsIntRect *aDirtyRect)
    1: {
    1:   if (!GetStyleVisibility()->IsVisible())
    1:     return NS_OK;
    1: 
13217:   gfxContext *gfx = aContext->GetGfxContext();
13217:   PRUint16 renderMode = aContext->GetRenderMode();
    1: 
    1:   if (renderMode != nsSVGRenderState::NORMAL) {
13760: 
13760:     gfxMatrix matrix = gfx->CurrentMatrix();
13760:     SetupGlobalTransform(gfx);
13760: 
13259:     CharacterIterator iter(this, PR_TRUE);
13760:     iter.SetInitialMatrix(gfx);
13259: 
    1:     if (GetClipRule() == NS_STYLE_FILL_RULE_EVENODD)
  630:       gfx->SetFillRule(gfxContext::FILL_RULE_EVEN_ODD);
    1:     else
  630:       gfx->SetFillRule(gfxContext::FILL_RULE_WINDING);
    1: 
    1:     if (renderMode == nsSVGRenderState::CLIP_MASK) {
  630:       gfx->SetAntialiasMode(gfxContext::MODE_ALIASED);
  630:       gfx->SetColor(gfxRGBA(1.0f, 1.0f, 1.0f, 1.0f));
13259:       FillCharacters(&iter, gfx);
    1:     } else {
13259:       AddCharactersToPath(&iter, gfx);
    1:     }
    1: 
  630:     gfx->SetMatrix(matrix);
    1:     return NS_OK;
    1:   }
    1: 
13760:   // We are adding patterns or gradients to the context. Save
13760:   // it so we don't leak them into the next object we draw
13259:   gfx->Save();
13760:   SetupGlobalTransform(gfx);
13760: 
19948:   if (SetupCairoFill(gfx)) {
13760:     gfxMatrix matrix = gfx->CurrentMatrix();
13259:     CharacterIterator iter(this, PR_TRUE);
13760:     iter.SetInitialMatrix(gfx);
13259: 
13259:     FillCharacters(&iter, gfx);
13760:     gfx->SetMatrix(matrix);
    1:   }
    1: 
19948:   if (SetupCairoStroke(gfx)) {
13760:     // SetupCairoStroke will clear mTextRun whenever
13760:     // there is a pattern or gradient on the text
13259:     CharacterIterator iter(this, PR_TRUE);
13760:     iter.SetInitialMatrix(gfx);
13259: 
  630:     gfx->NewPath();
13259:     AddCharactersToPath(&iter, gfx);
  630:     gfx->Stroke();
13259:     // We need to clear the context's path so state doesn't leak
13259:     // out. See bug 337753.
  630:     gfx->NewPath();
    1:   }
  630:   gfx->Restore();
    1: 
    1:   return NS_OK;
    1: }
    1: 
18367: NS_IMETHODIMP_(nsIFrame*)
18367: nsSVGGlyphFrame::GetFrameForPoint(const nsPoint &aPoint)
    1: {
    1: #ifdef DEBUG
    1:   //printf("nsSVGGlyphFrame(%p)::GetFrameForPoint\n", this);
    1: #endif
    1: 
18367:   if (!mRect.Contains(aPoint))
18367:     return nsnull;
    1: 
    1:   PRBool events = PR_FALSE;
    1:   switch (GetStyleSVG()->mPointerEvents) {
    1:     case NS_STYLE_POINTER_EVENTS_NONE:
    1:       break;
    1:     case NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED:
    1:       if (GetStyleVisibility()->IsVisible() &&
    1:           (GetStyleSVG()->mFill.mType != eStyleSVGPaintType_None ||
    1:            GetStyleSVG()->mStroke.mType != eStyleSVGPaintType_None))
    1:         events = PR_TRUE;
    1:       break;
    1:     case NS_STYLE_POINTER_EVENTS_VISIBLEFILL:
    1:     case NS_STYLE_POINTER_EVENTS_VISIBLESTROKE:
    1:     case NS_STYLE_POINTER_EVENTS_VISIBLE:
    1:       if (GetStyleVisibility()->IsVisible())
    1:         events = PR_TRUE;
    1:       break;
    1:     case NS_STYLE_POINTER_EVENTS_PAINTED:
    1:       if (GetStyleSVG()->mFill.mType != eStyleSVGPaintType_None ||
    1:           GetStyleSVG()->mStroke.mType != eStyleSVGPaintType_None)
    1:         events = PR_TRUE;
    1:       break;
    1:     case NS_STYLE_POINTER_EVENTS_FILL:
    1:     case NS_STYLE_POINTER_EVENTS_STROKE:
    1:     case NS_STYLE_POINTER_EVENTS_ALL:
    1:       events = PR_TRUE;
    1:       break;
    1:     default:
    1:       NS_ERROR("not reached");
    1:       break;
    1:   }
    1: 
18367:   if (events && ContainsPoint(aPoint))
18367:     return this;
    1: 
18367:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP_(nsRect)
    1: nsSVGGlyphFrame::GetCoveredRegion()
    1: {
    1:   return mRect;
    1: }
    1: 
13259: static gfxContext *
13259: MakeTmpCtx() {
13259:   return new gfxContext(nsSVGUtils::GetThebesComputationalSurface());
13259: }
13259: 
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::UpdateCoveredRegion()
    1: {
21217:   mRect.Empty();
21217: 
13259:   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
22124:   SetMatrixPropagation(PR_FALSE);
  605:   
22198:   gfxRect extent = gfxRect(0, 0, 0, 0);
  605: 
19948:   if (SetupCairoStrokeGeometry(tmpCtx)) {
26223:     CharacterIterator iter(this, PR_TRUE);
22124:     gfxFloat strokeWidth = tmpCtx->CurrentLineWidth();
13259:     AddCharactersToPath(&iter, tmpCtx);
22124:     tmpCtx->SetLineWidth(strokeWidth);
22124:     tmpCtx->IdentityMatrix();
21217:     extent = tmpCtx->GetUserStrokeExtent();
22198:   }
22198:   if (GetStyleSVG()->mFill.mType != eStyleSVGPaintType_None) {
26223:     CharacterIterator iter(this, PR_TRUE);
13259:     AddBoundingBoxesToPath(&iter, tmpCtx);
22124:     tmpCtx->IdentityMatrix();
22198:     extent = extent.Union(tmpCtx->GetUserPathExtent());
    1:   }
22124:   SetMatrixPropagation(PR_TRUE);
    1: 
21217:   if (!extent.IsEmpty()) {
21217:     gfxMatrix matrix;
21217:     GetGlobalTransform(&matrix);
21217: 
21217:     extent = matrix.TransformBounds(extent);
18367:     mRect = nsSVGUtils::ToAppPixelRect(PresContext(), extent);
21217:   }
21217: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::InitialUpdate()
    1: {
 7035:   NS_ASSERTION(GetStateBits() & NS_FRAME_FIRST_REFLOW,
 7035:                "Yikes! We've been called already! Hopefully we weren't called "
 7035:                "before our nsSVGOuterSVGFrame's initial Reflow()!!!");
 7035: 
    1:   NS_ASSERTION(!(mState & NS_FRAME_IN_REFLOW),
    1:                "We don't actually participate in reflow");
    1: 
    1:   // Do unset the various reflow bits, though.
    1:   mState &= ~(NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY |
    1:               NS_FRAME_HAS_DIRTY_CHILDREN);
    1:   
 4230:   return NS_OK;
    1: }  
    1: 
10661: void
10661: nsSVGGlyphFrame::NotifySVGChanged(PRUint32 aFlags)
    1: {
13259:   if (aFlags & TRANSFORM_CHANGED) {
13259:     ClearTextRun();
13259:   }
14042:   if (!(aFlags & SUPPRESS_INVALIDATION)) {
14042:     nsSVGUtils::UpdateGraphic(this);
14042:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::NotifyRedrawSuspended()
    1: {
    1:   // XXX should we cache the fact that redraw is suspended?
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::NotifyRedrawUnsuspended()
    1: {
    1:   if (GetStateBits() & NS_STATE_SVG_DIRTY)
14042:     nsSVGUtils::UpdateGraphic(this);
    1: 
    1:   return NS_OK;
    1: }
    1: 
13259: void
13259: nsSVGGlyphFrame::AddCharactersToPath(CharacterIterator *aIter,
13259:                                      gfxContext *aContext)
13259: {
13259:   if (aIter->SetupForDirectTextRunDrawing(aContext)) {
13259:     mTextRun->DrawToPath(aContext, gfxPoint(0, 0), 0,
13259:                          mTextRun->GetLength(), nsnull, nsnull);
13259:     return;
13259:   }
13259: 
13259:   PRInt32 i;
13259:   while ((i = aIter->NextChar()) >= 0) {
13259:     aIter->SetupForDrawing(aContext);
13259:     mTextRun->DrawToPath(aContext, gfxPoint(0, 0), i, 1, nsnull, nsnull);
13259:   }
13259: }
13259: 
13259: void
13259: nsSVGGlyphFrame::AddBoundingBoxesToPath(CharacterIterator *aIter,
13259:                                         gfxContext *aContext)
13259: {
13259:   if (aIter->SetupForDirectTextRunMetrics(aContext)) {
13259:     gfxTextRun::Metrics metrics =
13259:       mTextRun->MeasureText(0, mTextRun->GetLength(),
25417:                             gfxFont::LOOSE_INK_EXTENTS, nsnull, nsnull);
13259:     aContext->Rectangle(metrics.mBoundingBox);
13259:     return;
13259:   }
13259: 
13259:   PRInt32 i;
13259:   while ((i = aIter->NextChar()) >= 0) {
13259:     aIter->SetupForMetrics(aContext);
13259:     gfxTextRun::Metrics metrics =
25417:       mTextRun->MeasureText(i, 1, gfxFont::LOOSE_INK_EXTENTS, nsnull, nsnull);
13259:     aContext->Rectangle(metrics.mBoundingBox);
13259:   }
13259: }
13259: 
13259: void
13259: nsSVGGlyphFrame::FillCharacters(CharacterIterator *aIter,
13259:                                 gfxContext *aContext)
13259: {
13259:   if (aIter->SetupForDirectTextRunDrawing(aContext)) {
13259:     mTextRun->Draw(aContext, gfxPoint(0, 0), 0,
13259:                    mTextRun->GetLength(), nsnull, nsnull, nsnull);
13259:     return;
13259:   }
13259: 
13259:   PRInt32 i;
13259:   while ((i = aIter->NextChar()) >= 0) {
13259:     aIter->SetupForDrawing(aContext);
13259:     mTextRun->Draw(aContext, gfxPoint(0, 0), i, 1, nsnull, nsnull, nsnull);
13259:   }
13259: }
13259: 
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::GetBBox(nsIDOMSVGRect **_retval)
    1: {
    1:   *_retval = nsnull;
    1: 
13259:   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
13760:   SetupGlobalTransform(tmpCtx);
13259:   CharacterIterator iter(this, PR_TRUE);
13760:   iter.SetInitialMatrix(tmpCtx);
13259:   AddCharactersToPath(&iter, tmpCtx);
    1: 
13259:   tmpCtx->IdentityMatrix();
13259:   return NS_NewSVGRect(_retval, tmpCtx->GetUserPathExtent());
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsSVGGeometryFrame methods:
    1: 
    1: /* readonly attribute nsIDOMSVGMatrix canvasTM; */
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::GetCanvasTM(nsIDOMSVGMatrix * *aCTM)
    1: {
    1:   NS_ASSERTION(mParent, "null parent");
    1:   
 3233:   nsSVGContainerFrame *containerFrame = static_cast<nsSVGContainerFrame*>
 3233:                                                    (mParent);
    1:   nsCOMPtr<nsIDOMSVGMatrix> parentTM = containerFrame->GetCanvasTM();
13259:   *aCTM = nsnull;
13259:   parentTM.swap(*aCTM);
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsSVGGlyphFrame methods:
    1: 
    1: PRBool
    1: nsSVGGlyphFrame::GetCharacterData(nsAString & aCharacterData)
    1: {
    1:   nsAutoString characterData;
25840:   GetFragment()->AppendTo(characterData);
    1: 
    1:   if (mWhitespaceHandling & COMPRESS_WHITESPACE) {
    1:     PRBool trimLeadingWhitespace, trimTrailingWhitespace;
    1:     trimLeadingWhitespace = ((mWhitespaceHandling & TRIM_LEADING_WHITESPACE) != 0);
    1:     trimTrailingWhitespace = ((mWhitespaceHandling & TRIM_TRAILING_WHITESPACE) != 0);
    1:     characterData.CompressWhitespace(trimLeadingWhitespace, 
    1:                                      trimTrailingWhitespace);
    1:   } else {
    1:     nsAString::iterator start, end;
    1:     characterData.BeginWriting(start);
    1:     characterData.EndWriting(end);
    1:     while (start != end) {
    1:       if (NS_IsAsciiWhitespace(*start))
    1:         *start = ' ';
    1:       ++start;
    1:     }
    1:   }
    1:   aCharacterData = characterData;
    1: 
    1:   return !characterData.IsEmpty();
    1: }
    1: 
13259: PRBool
13259: nsSVGGlyphFrame::GetCharacterPositions(nsTArray<CharacterPosition>* aCharacterPositions,
13259:                                        float aMetricsScale)
    1: {
13259:   NS_ASSERTION(mTextRun->GetLength() > 0, "no text");
    1: 
    1:   nsSVGTextPathFrame *textPath = FindTextPathParent();
    1: 
    1:   /* we're an ordinary fragment - return */
    1:   /* XXX: we might want to use this for individual x/y/dx/dy adjustment */
    1:   if (!textPath)
13259:     return PR_TRUE;
    1: 
  565:   nsRefPtr<gfxFlattenedPath> data = textPath->GetFlattenedPath();
    1: 
    1:   /* textPath frame, but invalid target */
    1:   if (!data)
13259:     return PR_FALSE;
    1: 
  724:   gfxFloat length = data->GetLength();
13259:   PRUint32 strLength = mTextRun->GetLength();
    1: 
13259:   if (!aCharacterPositions->SetLength(strLength))
13259:     return PR_FALSE;
  630: 
13259:   CharacterPosition *cp = aCharacterPositions->Elements();
    1: 
    1:   for (PRUint32 k = 0; k < strLength; k++)
    1:     cp[k].draw = PR_FALSE;
    1: 
  724:   gfxFloat x = mPosition.x;
    1:   for (PRUint32 i = 0; i < strLength; i++) {
13259:     gfxFloat halfAdvance =
13259:       mTextRun->GetAdvanceWidth(i, 1, nsnull)*aMetricsScale / 2.0;
    1: 
    1:     /* have we run off the end of the path? */
  565:     if (x + halfAdvance > length)
    1:       break;
    1: 
    1:     /* check that we've advanced to the start of the path */
  724:     if (x + halfAdvance >= 0.0) {
    1:       cp[i].draw = PR_TRUE;
    1: 
    1:       // add y (normal)
    1:       // add rotation
    1:       // move point back along tangent
  630:       gfxPoint pt = data->FindPoint(gfxPoint(x + halfAdvance, mPosition.y),
    1:                                     &(cp[i].angle));
  630:       cp[i].pos =
  630:         pt - gfxPoint(cos(cp[i].angle), sin(cp[i].angle)) * halfAdvance;
    1:     }
  565:     x += 2 * halfAdvance;
    1:   }
    1:   
13259:   return PR_TRUE;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Utilities for converting from indices in the uncompressed content
    1: // element strings to compressed frame string and back:
    1: static int
    1: CompressIndex(int index, const nsTextFragment*fragment)
    1: {
    1:   int ci=0;
    1:   if (fragment->Is2b()) {
    1:     const PRUnichar *data=fragment->Get2b();
    1:     while(*data && index) {
    1:       if (XP_IS_SPACE_W(*data)){
    1:         do {
    1:           ++data;
    1:           --index;
    1:         }while(XP_IS_SPACE_W(*data) && index);
    1:       }
    1:       else {
    1:         ++data;
    1:         --index;
    1:       }
    1:       ++ci;
    1:     }
    1:   }
    1:   else {
    1:     const char *data=fragment->Get1b();
    1:     while(*data && index) {
    1:       if (XP_IS_SPACE_W(*data)){
    1:         do {
    1:           ++data;
    1:           --index;
    1:         }while(XP_IS_SPACE_W(*data) && index);
    1:       }
    1:       else {
    1:         ++data;
    1:         --index;
    1:       }
    1:       ++ci;
    1:     }
    1:   }
    1:     
    1:   return ci;
    1: }
    1: 
    1: static int
    1: UncompressIndex(int index, PRBool bRightAffinity, const nsTextFragment*fragment)
    1: {
    1:   // XXX
    1:   return index;
    1: }
    1: 
    1: nsresult
    1: nsSVGGlyphFrame::GetHighlight(PRUint32 *charnum, PRUint32 *nchars,
    1:                               nscolor *foreground, nscolor *background)
    1: {
    1:   *foreground = NS_RGB(255,255,255);
    1:   *background = NS_RGB(0,0,0); 
    1:   *charnum=0;
    1:   *nchars=0;
    1: 
    1:   PRBool hasHighlight =
    1:     (mState & NS_FRAME_SELECTED_CONTENT) == NS_FRAME_SELECTED_CONTENT;
    1: 
    1:   if (!hasHighlight) {
    1:     NS_ERROR("nsSVGGlyphFrame::GetHighlight() called by renderer when there is no highlight");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
  238:   nsPresContext *presContext = PresContext();
    1: 
    1:   // The selection ranges are relative to the uncompressed text in
    1:   // the content element. We'll need the text fragment:
25840:   const nsTextFragment* fragment = GetFragment();
    1:   NS_ASSERTION(fragment, "no text");
    1:   
    1:   // get the selection details 
    1:   SelectionDetails *details = nsnull;
    1:   {
    1:     nsCOMPtr<nsFrameSelection> frameSelection;
    1:     {
    1:       nsCOMPtr<nsISelectionController> controller;
    1:       GetSelectionController(presContext, getter_AddRefs(controller));
    1:       
    1:       if (!controller) {
    1:         NS_ERROR("no selection controller");
    1:         return NS_ERROR_FAILURE;
    1:       }
    1:       frameSelection = do_QueryInterface(controller);
    1:     }
    1:     if (!frameSelection) {
    1:       frameSelection = presContext->PresShell()->FrameSelection();
    1:     }
    1:     if (!frameSelection) {
    1:       NS_ERROR("no frameselection interface");
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     details = frameSelection->LookUpSelection(
    1:       mContent, 0, fragment->GetLength(), PR_FALSE
    1:       );
    1:   }
    1: 
    1: #if defined(DEBUG) && defined(SVG_DEBUG_SELECTION)
    1:   {
    1:     SelectionDetails *dp = details;
    1:     printf("nsSVGGlyphFrame(%p)::GetHighlight() [\n", this);
    1:     while (dp) {
    1:       printf("selection detail: %d(%d)->%d(%d) type %d\n",
    1:              dp->mStart, CompressIndex(dp->mStart, fragment),
    1:              dp->mEnd, CompressIndex(dp->mEnd, fragment),
    1:              dp->mType);
    1:       dp = dp->mNext;
    1:     }
    1:     printf("]\n");
    1:       
    1:   }
    1: #endif
    1:   
    1:   if (details) {
    1:     NS_ASSERTION(details->mNext==nsnull, "can't do multiple selection ranges");
    1: 
    1:     *charnum=CompressIndex(details->mStart, fragment);
    1:     *nchars=CompressIndex(details->mEnd, fragment)-*charnum;  
    1:     
    1:     nsILookAndFeel *look = presContext->LookAndFeel();
    1: 
    1:     look->GetColor(nsILookAndFeel::eColor_TextSelectBackground, *background);
    1:     look->GetColor(nsILookAndFeel::eColor_TextSelectForeground, *foreground);
    1: 
    1:     SelectionDetails *dp = details;
    1:     while ((dp=details->mNext) != nsnull) {
    1:       delete details;
    1:       details = dp;
    1:     }
    1:     delete details;
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: // nsISVGGlyphFragmentLeaf interface:
    1: 
    1: NS_IMETHODIMP_(void)
    1: nsSVGGlyphFrame::SetGlyphPosition(float x, float y)
    1: {
  630:   mPosition.MoveTo(x, y);
14042:   nsSVGUtils::UpdateGraphic(this);
    1: }
    1: 
    1: NS_IMETHODIMP
13259: nsSVGGlyphFrame::GetStartPositionOfChar(PRUint32 charnum,
13259:                                         nsIDOMSVGPoint **_retval)
    1: {
    1:   *_retval = nsnull;
    1: 
13259:   CharacterIterator iter(this, PR_FALSE);
13259:   if (!iter.AdvanceToCharacter(charnum))
13259:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
13219: 
13259:   return NS_NewSVGPoint(_retval, iter.GetPositionData().pos);
    1: }
    1: 
    1: NS_IMETHODIMP
13259: nsSVGGlyphFrame::GetEndPositionOfChar(PRUint32 charnum,
13259:                                       nsIDOMSVGPoint **_retval)
    1: {
    1:   *_retval = nsnull;
    1: 
13259:   CharacterIterator iter(this, PR_FALSE);
13259:   if (!iter.AdvanceToCharacter(charnum))
13259:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
13219: 
13259:   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
13259:   iter.SetupForMetrics(tmpCtx);
13259:   tmpCtx->MoveTo(gfxPoint(mTextRun->GetAdvanceWidth(charnum, 1, nsnull), 0));
13259:   tmpCtx->IdentityMatrix();
13259:   return NS_NewSVGPoint(_retval, tmpCtx->CurrentPoint());
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::GetExtentOfChar(PRUint32 charnum, nsIDOMSVGRect **_retval)
    1: {
    1:   *_retval = nsnull;
    1: 
25387:   PRUint32 start = charnum, limit = charnum + 1;
25387:   while (start > 0 && !mTextRun->IsClusterStart(start)) {
25387:     --start;
25387:   }
25387:   while (limit < mTextRun->GetLength() && !mTextRun->IsClusterStart(limit)) {
25387:     ++limit;
25387:   }
25387: 
13259:   CharacterIterator iter(this, PR_FALSE);
25387:   if (!iter.AdvanceToCharacter(start))
13259:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1: 
  630:   gfxTextRun::Metrics metrics =
25417:     mTextRun->MeasureText(start, limit - start, gfxFont::LOOSE_INK_EXTENTS,
25417:                           nsnull, nsnull);
    1: 
13259:   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
13259:   iter.SetupForMetrics(tmpCtx);
25387:   tmpCtx->Rectangle(gfxRect(0, -metrics.mAscent,
25387:                             metrics.mAdvanceWidth,
25387:                             metrics.mAscent + metrics.mDescent));
13259:   tmpCtx->IdentityMatrix();
13259:   return NS_NewSVGRect(_retval, tmpCtx->GetUserPathExtent());
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSVGGlyphFrame::GetRotationOfChar(PRUint32 charnum, float *_retval)
    1: {
13259:   CharacterIterator iter(this, PR_FALSE);
13259:   if (!iter.AdvanceToCharacter(charnum))
13259:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
13259: 
13259:   CharacterPosition pos = iter.GetPositionData();
13259:   if (!pos.draw)
13259:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
13259: 
13219:   const gfxFloat radPerDeg = M_PI/180.0;
13259:   *_retval = float(pos.angle / radPerDeg);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP_(float)
13259: nsSVGGlyphFrame::GetBaselineOffset(PRUint16 baselineIdentifier,
13259:                                    PRBool aForceGlobalTransform)
    1: {
13259:   float drawScale, metricsScale;
    1: 
13259:   if (!EnsureTextRun(&drawScale, &metricsScale, aForceGlobalTransform))
  630:     return 0.0f;
  630: 
  630:   gfxTextRun::Metrics metrics =
13259:     mTextRun->MeasureText(0, mTextRun->GetLength(),
25417:                           gfxFont::LOOSE_INK_EXTENTS, nsnull, nsnull);
    1: 
13259:   gfxFloat baselineAppUnits;
    1:   switch (baselineIdentifier) {
    1:   case BASELINE_HANGING:
    1:     // not really right, but the best we can do with the information provided
    1:     // FALLTHROUGH
    1:   case BASELINE_TEXT_BEFORE_EDGE:
13259:     baselineAppUnits = -metrics.mAscent;
    1:     break;
    1:   case BASELINE_TEXT_AFTER_EDGE:
13259:     baselineAppUnits = metrics.mDescent;
    1:     break;
    1:   case BASELINE_CENTRAL:
    1:   case BASELINE_MIDDLE:
13259:     baselineAppUnits = -(metrics.mAscent - metrics.mDescent) / 2.0f;
    1:     break;
    1:   case BASELINE_ALPHABETIC:
    1:   default:
13259:     baselineAppUnits = 0.0;
    1:     break;
    1:   }
13259:   return float(baselineAppUnits)*metricsScale;
    1: }
    1: 
    1: NS_IMETHODIMP_(float)
13259: nsSVGGlyphFrame::GetAdvance(PRBool aForceGlobalTransform)
    1: {
13259:   float drawScale, metricsScale;
13259:   if (!EnsureTextRun(&drawScale, &metricsScale, aForceGlobalTransform))
  630:     return 0.0f;
    1: 
13259:   gfxFloat advanceAppUnits =
13259:     mTextRun->GetAdvanceWidth(0, mTextRun->GetLength(), nsnull);
13259:   return float(advanceAppUnits)*metricsScale;
    1: }
    1: 
    1: NS_IMETHODIMP_(nsSVGTextPathFrame*) 
    1: nsSVGGlyphFrame::FindTextPathParent()
    1: {
    1:   /* check if we're the child of a textPath */
    1:   for (nsIFrame *frame = GetParent();
    1:        frame != nsnull;
    1:        frame = frame->GetParent()) {
    1:     nsIAtom* type = frame->GetType();
    1:     if (type == nsGkAtoms::svgTextPathFrame) {
 3233:       return static_cast<nsSVGTextPathFrame*>(frame);
    1:     } else if (type == nsGkAtoms::svgTextFrame)
    1:       return nsnull;
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsSVGGlyphFrame::IsStartOfChunk()
    1: {
    1:   // this fragment is a chunk if it has a corresponding absolute
    1:   // position adjustment in an ancestors' x or y array. (At the moment
    1:   // we don't map the full arrays, but only the first elements.)
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP_(void)
    1: nsSVGGlyphFrame::GetAdjustedPosition(/* inout */ float &x, /* inout */ float &y)
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP_(already_AddRefed<nsIDOMSVGLengthList>)
    1: nsSVGGlyphFrame::GetX()
    1: {
    1:   nsSVGTextContainerFrame *containerFrame;
 3233:   containerFrame = static_cast<nsSVGTextContainerFrame *>(mParent);
    1:   if (containerFrame)
    1:     return containerFrame->GetX();
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP_(already_AddRefed<nsIDOMSVGLengthList>)
    1: nsSVGGlyphFrame::GetY()
    1: {
    1:   nsSVGTextContainerFrame *containerFrame;
 3233:   containerFrame = static_cast<nsSVGTextContainerFrame *>(mParent);
    1:   if (containerFrame)
    1:     return containerFrame->GetY();
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP_(already_AddRefed<nsIDOMSVGLengthList>)
    1: nsSVGGlyphFrame::GetDx()
    1: {
    1:   nsSVGTextContainerFrame *containerFrame;
 3233:   containerFrame = static_cast<nsSVGTextContainerFrame *>(mParent);
    1:   if (containerFrame)
    1:     return containerFrame->GetDx();
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP_(already_AddRefed<nsIDOMSVGLengthList>)
    1: nsSVGGlyphFrame::GetDy()
    1: {
    1:   nsSVGTextContainerFrame *containerFrame;
 3233:   containerFrame = static_cast<nsSVGTextContainerFrame *>(mParent);
    1:   if (containerFrame)
    1:     return containerFrame->GetDy();
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRUint16)
    1: nsSVGGlyphFrame::GetTextAnchor()
    1: {
    1:   return GetStyleSVG()->mTextAnchor;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsSVGGlyphFrame::IsAbsolutelyPositioned()
    1: {
    1:   nsIFrame *lastFrame = this;
    1: 
    1:   for (nsIFrame *frame = GetParent();
    1:        frame != nsnull;
    1:        lastFrame = frame, frame = frame->GetParent()) {
    1: 
    1:     /* need to be the first child if we are absolutely positioned */
    1:     if (!frame ||
    1:         frame->GetFirstChild(nsnull) != lastFrame)
    1:       break;
    1: 
    1:     // textPath is always absolutely positioned for our purposes
    1:     if (frame->GetType() == nsGkAtoms::svgTextPathFrame)
    1:       return PR_TRUE;
    1:         
    1:     if (frame &&
    1:         (frame->GetContent()->HasAttr(kNameSpaceID_None, nsGkAtoms::x) ||
    1:          frame->GetContent()->HasAttr(kNameSpaceID_None, nsGkAtoms::y)))
    1:         return PR_TRUE;
    1: 
    1:     if (frame->GetType() == nsGkAtoms::svgTextFrame)
    1:       break;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: // nsISVGGlyphFragmentNode interface:
    1: 
    1: NS_IMETHODIMP_(PRUint32)
    1: nsSVGGlyphFrame::GetNumberOfChars()
    1: {
    1:   if (mWhitespaceHandling == PRESERVE_WHITESPACE)
25840:     return GetFragment()->GetLength();
    1: 
    1:   nsAutoString text;
    1:   GetCharacterData(text);
    1:   return text.Length();
    1: }
    1: 
    1: NS_IMETHODIMP_(float)
    1: nsSVGGlyphFrame::GetComputedTextLength()
    1: {
13259:   return GetAdvance(PR_FALSE);
    1: }
    1: 
    1: NS_IMETHODIMP_(float)
    1: nsSVGGlyphFrame::GetSubStringLength(PRUint32 charnum, PRUint32 fragmentChars)
    1: {
13259:   float drawScale, metricsScale;
13259:   if (!EnsureTextRun(&drawScale, &metricsScale, PR_FALSE))
  630:     return 0.0f;
    1: 
13259:   gfxFloat advanceAppUnits =
13259:     mTextRun->GetAdvanceWidth(charnum, fragmentChars, nsnull);
13259:   return float(advanceAppUnits)*metricsScale;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRInt32)
    1: nsSVGGlyphFrame::GetCharNumAtPosition(nsIDOMSVGPoint *point)
    1: {
    1:   float xPos, yPos;
    1:   point->GetX(&xPos);
    1:   point->GetY(&yPos);
    1: 
13259:   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
13259:   CharacterIterator iter(this, PR_FALSE);
    1: 
13259:   PRInt32 i;
13259:   PRInt32 last = -1;
13259:   gfxPoint pt(xPos, yPos);
13259:   while ((i = iter.NextChar()) >= 0) {
25387:     // iter is the beginning of a cluster (or of the entire run);
25387:     // look ahead for the next cluster start, then measure the entire cluster
25387:     PRInt32 limit = i + 1;
25387:     while (limit < mTextRun->GetLength() && !mTextRun->IsClusterStart(limit)) {
25387:       ++limit;
25387:     }
13259:     gfxTextRun::Metrics metrics =
25417:       mTextRun->MeasureText(i, limit - i, gfxFont::LOOSE_INK_EXTENTS,
25417:                             nsnull, nsnull);
25387: 
25387:     // the SVG spec tells us to divide the width of the cluster equally among
25387:     // its chars, so we'll step through the chars, allocating a share of the
25387:     // total advance to each
25387:     PRInt32 current, end, step;
25387:     if (mTextRun->IsRightToLeft()) {
25387:       current = limit - 1;
25387:       end = i - 1;
25387:       step = -1;
25387:     } else {
25387:       current = i;
25387:       end = limit;
25387:       step = 1;
25387:     }
25387:     gfxFloat leftEdge = 0.0;
25387:     gfxFloat width = metrics.mAdvanceWidth / (limit - i);
25387:     while (current != end) {
13259:       iter.SetupForMetrics(tmpCtx);
13259:       tmpCtx->NewPath();
25387:       tmpCtx->Rectangle(gfxRect(leftEdge, -metrics.mAscent,
25387:                                 width, metrics.mAscent + metrics.mDescent));
13259:       tmpCtx->IdentityMatrix();
13259:       if (tmpCtx->PointInFill(pt)) {
25387:         // Can't return yet; if there's glyph overlap, the last character
25387:         // to be rendered wins, so we still have to check the rest...
25387:         last = current;
25387:         break; // ...but we don't need to check more slices of this cluster
25387:       }
25387:       current += step;
25387:       leftEdge += width;
25387:     }
25387: 
25387:     // move iter past any trailing chars of the cluster
25387:     while (++i < limit) {
25387:       iter.NextChar();
13259:     }
    1:   }
    1: 
13259:   return last;
    1: }
    1: 
    1: NS_IMETHODIMP_(nsISVGGlyphFragmentLeaf *)
    1: nsSVGGlyphFrame::GetFirstGlyphFragment()
    1: {
    1:   return this;
    1: }
    1: 
    1: NS_IMETHODIMP_(nsISVGGlyphFragmentLeaf *)
    1: nsSVGGlyphFrame::GetNextGlyphFragment()
    1: {
    1:   nsIFrame* sibling = mNextSibling;
    1:   while (sibling) {
23554:     nsISVGGlyphFragmentNode *node = do_QueryFrame(sibling);
    1:     if (node)
    1:       return node->GetFirstGlyphFragment();
    1:     sibling = sibling->GetNextSibling();
    1:   }
    1: 
    1:   // no more siblings. go back up the tree.
    1:   
    1:   NS_ASSERTION(mParent, "null parent");
23554:   nsISVGGlyphFragmentNode *node = do_QueryFrame(mParent);
    1:   return node ? node->GetNextGlyphFragment() : nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP_(void)
    1: nsSVGGlyphFrame::SetWhitespaceHandling(PRUint8 aWhitespaceHandling)
    1: {
    1:   mWhitespaceHandling = aWhitespaceHandling;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: 
14042: void
14042: nsSVGGlyphFrame::NotifyGlyphMetricsChange()
    1: {
14042:   nsSVGTextContainerFrame *containerFrame =
14042:     static_cast<nsSVGTextContainerFrame *>(mParent);
14042:   if (containerFrame)
14042:     containerFrame->NotifyGlyphMetricsChange();
    1: }
    1: 
    1: PRBool
18367: nsSVGGlyphFrame::ContainsPoint(const nsPoint &aPoint)
    1: {
13259:   nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
13760:   SetupGlobalTransform(tmpCtx);
13259:   CharacterIterator iter(this, PR_TRUE);
13760:   iter.SetInitialMatrix(tmpCtx);
13259:   
13259:   PRInt32 i;
13259:   while ((i = iter.NextChar()) >= 0) {
13259:     gfxTextRun::Metrics metrics =
25417:       mTextRun->MeasureText(i, 1, gfxFont::LOOSE_INK_EXTENTS, nsnull, nsnull);
13259:     iter.SetupForMetrics(tmpCtx);
13259:     tmpCtx->Rectangle(metrics.mBoundingBox);
    1:   }
    1: 
13259:   tmpCtx->IdentityMatrix();
18367:   return tmpCtx->PointInFill(gfxPoint(PresContext()->AppUnitsToGfxUnits(aPoint.x),
18367:                                       PresContext()->AppUnitsToGfxUnits(aPoint.y)));
    1: }
    1: 
13259: PRBool
13259: nsSVGGlyphFrame::GetGlobalTransform(gfxMatrix *aMatrix)
    1: {
22124:   if (!GetMatrixPropagation()) {
22124:     aMatrix->Reset();
22124:     return PR_TRUE;
22124:   }
22124: 
    1:   nsCOMPtr<nsIDOMSVGMatrix> ctm;
    1:   GetCanvasTM(getter_AddRefs(ctm));
13259:   if (!ctm)
13259:     return PR_FALSE;
    1: 
13760:   *aMatrix = nsSVGUtils::ConvertSVGMatrixToThebes(ctm);
13760:   return !aMatrix->IsSingular();
    1: }
    1: 
13760: void
13760: nsSVGGlyphFrame::SetupGlobalTransform(gfxContext *aContext)
13760: {
13760:   gfxMatrix matrix;
13760:   GetGlobalTransform(&matrix);
13760:   aContext->Multiply(matrix);
    1: }
    1: 
13259: void
13259: nsSVGGlyphFrame::ClearTextRun()
  630: {
13259:   if (!mTextRun)
13259:     return;
13259:   gfxTextRunWordCache::RemoveTextRun(mTextRun);
13259:   delete mTextRun;
13259:   mTextRun = nsnull;
13259: }
13259: 
13259: PRBool
13259: nsSVGGlyphFrame::EnsureTextRun(float *aDrawScale, float *aMetricsScale,
13259:                                PRBool aForceGlobalTransform)
13259: {
13259:   // Compute the size at which the text should render (excluding the CTM)
13259:   const nsStyleFont* fontData = GetStyleFont();
13259:   // Since SVG has its own scaling, we really don't want
13259:   // fonts in SVG to respond to the browser's "TextZoom"
13259:   // (Ctrl++,Ctrl+-)
13259:   nsPresContext *presContext = PresContext();
13259:   float textZoom = presContext->TextZoom();
13259:   double size =
13259:     presContext->AppUnitsToFloatCSSPixels(fontData->mSize) / textZoom;
13259: 
13259:   double textRunSize;
13259:   if (mTextRun) {
13259:     textRunSize = mTextRun->GetFontGroup()->GetStyle()->size;
13259:   } else {
13259:     nsAutoString text;
13259:     if (!GetCharacterData(text))
13259:       return PR_FALSE;
13259: 
13259:     gfxMatrix m;
13259:     if (aForceGlobalTransform ||
13259:         !(GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)) {
13259:       if (!GetGlobalTransform(&m))
13259:         return PR_FALSE;
13259:     }
13259: 
13259:     // The context scale is the ratio of the length of the transformed
13259:     // diagonal vector (1,1) to the length of the untransformed diagonal
13259:     // (which is sqrt(2)).
13259:     gfxPoint p = m.Transform(gfxPoint(1, 1)) - m.Transform(gfxPoint(0, 0));
15943:     double contextScale = nsSVGUtils::ComputeNormalizedHypotenuse(p.x, p.y);
13259: 
13259:     nsCAutoString langGroup;
13259:     nsIAtom *langGroupAtom = presContext->GetLangGroup();
13259:     if (langGroupAtom) {
13259:       const char* lg;
13259:       langGroupAtom->GetUTF8String(&lg);
13259:       langGroup.Assign(lg);
13259:     }
13259: 
13259:     if (GetStyleSVG()->mTextRendering ==
13259:         NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION) {
13259:       textRunSize = PRECISE_SIZE;
13259:     } else {
13259:       textRunSize = size*contextScale;
13259:       textRunSize = PR_MAX(textRunSize, CLAMP_MIN_SIZE);
13259:       textRunSize = PR_MIN(textRunSize, CLAMP_MAX_SIZE);
13259:     }
13259: 
13259:     const nsFont& font = fontData->mFont;
22866:     PRBool printerFont = (presContext->Type() == nsPresContext::eContext_PrintPreview ||
22866:                           presContext->Type() == nsPresContext::eContext_Print);
24408:     gfxFontStyle fontStyle(font.style, font.weight, font.stretch, textRunSize,
24408:                            langGroup, font.sizeAdjust, font.systemFont,
22866:                            font.familyNameQuirks,
22866:                            printerFont);
13259: 
13259:     nsRefPtr<gfxFontGroup> fontGroup =
19962:       gfxPlatform::GetPlatform()->CreateFontGroup(font.name, &fontStyle, presContext->GetUserFontSet());
  630: 
 6513:     PRUint32 flags = gfxTextRunFactory::TEXT_NEED_BOUNDING_BOX |
 6513:       nsLayoutUtils::GetTextRunFlagsForStyle(GetStyleContext(), GetStyleText(), GetStyleFont());
13259: 
13259:     // XXX We should use a better surface here! But then we'd have to
13259:     // change things so we can ensure we always have the "right" sort of
13259:     // surface available, by creating the textrun only at the right times
13259:     nsRefPtr<gfxContext> tmpCtx = MakeTmpCtx();
13259:     tmpCtx->SetMatrix(m);
13259: 
13259:     // Use only the word cache here. We don't want to cache the textrun
13259:     // globally because we'll never hit in that cache, since we create
13259:     // a new fontgroup every time. Even if we cached fontgroups, we
13259:     // might render at very many different sizes (e.g. during zoom
13259:     // animation) and caching a textrun for each such size would be bad.
13259:     gfxTextRunFactory::Parameters params = {
13259:         tmpCtx, nsnull, nsnull, nsnull, 0, GetTextRunUnitsFactor()
13259:     };
13259:     mTextRun = gfxTextRunWordCache::MakeTextRun(text.get(), text.Length(),
13259:       fontGroup, &params, flags);
13259:     if (!mTextRun)
13259:       return PR_FALSE;
13259:   }
13259: 
13259:   *aDrawScale = float(size/textRunSize);
13259:   *aMetricsScale = (*aDrawScale)/GetTextRunUnitsFactor();
13259:   return PR_TRUE;
  630: }
  630: 
19125: NS_IMETHODIMP
19125: nsSVGGlyphFrame::SetMatrixPropagation(PRBool aPropagate)
19125: {
19125:   if (aPropagate) {
19125:     AddStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
19125:   } else {
19125:     RemoveStateBits(NS_STATE_SVG_PROPAGATE_TRANSFORM);
19125:   }
19125:   return NS_OK;
19125: }
19125: 
19125: PRBool
19125: nsSVGGlyphFrame::GetMatrixPropagation()
19125: {
19125:   return (GetStateBits() & NS_STATE_SVG_PROPAGATE_TRANSFORM) != 0;
19125: }
19125: 
    1: //----------------------------------------------------------------------
    1: // helper class
    1: 
13259: CharacterIterator::CharacterIterator(nsSVGGlyphFrame *aSource,
13259:         PRBool aForceGlobalTransform)
13259:   : mSource(aSource), mCurrentAdvance(0), mCurrentChar(-1),
13259:     mInError(PR_FALSE)
    1: {
13259:   if (!aSource->EnsureTextRun(&mDrawScale, &mMetricsScale,
13259:                               aForceGlobalTransform) ||
13259:       !aSource->GetCharacterPositions(&mPositions, mMetricsScale)) {
13259:     mInError = PR_TRUE;
    1:   }
    1: }
    1: 
13259: PRBool
13259: CharacterIterator::SetupForDirectTextRun(gfxContext *aContext, float aScale)
13259: {
13259:   if (!mPositions.IsEmpty() || mInError)
13259:     return PR_FALSE;
13259:   aContext->SetMatrix(mInitialMatrix);
13259:   aContext->Translate(mSource->mPosition);
13259:   aContext->Scale(aScale, aScale);
15470:   // We are scaling the glyphs up/down to the size we want so we need to
15470:   // inverse scale the outline widths of those glyphs so they are invariant
15470:   aContext->SetLineWidth(aContext->CurrentLineWidth() / aScale);
13259:   return PR_TRUE;
13259: }
13259: 
13259: PRInt32
13259: CharacterIterator::NextChar()
13259: {
13259:   if (mInError)
13259:     return -1;
13259: 
13259:   while (PR_TRUE) {
13259:     if (mCurrentChar >= 0 &&
13259:         (mPositions.IsEmpty() || mPositions[mCurrentChar].draw)) {
13259:       mCurrentAdvance +=
13259:         mSource->mTextRun->GetAdvanceWidth(mCurrentChar, 1, nsnull);
13259:     }
13259:     ++mCurrentChar;
13259: 
13259:     if (mCurrentChar >= PRInt32(mSource->mTextRun->GetLength()))
13259:       return -1;
13259: 
13259:     if (mPositions.IsEmpty() || mPositions[mCurrentChar].draw)
13259:       return mCurrentChar;
13259:   }
13259: }
13259: 
13259: PRBool
13259: CharacterIterator::AdvanceToCharacter(PRInt32 aIndex)
13259: {
13259:   while (NextChar() != -1) {
13259:     if (mCurrentChar == aIndex)
13259:       return PR_TRUE;
13259:   }
13259:   return PR_FALSE;
13259: }
13259: 
13259: void
13259: CharacterIterator::SetupFor(gfxContext *aContext, float aScale)
13259: {
13259:   NS_ASSERTION(!mInError, "We should not have reached here");
13259: 
13259:   aContext->SetMatrix(mInitialMatrix);
13259:   if (mPositions.IsEmpty()) {
14005:     aContext->Translate(mSource->mPosition);
14005:     aContext->Scale(aScale, aScale);
14005:     aContext->Translate(gfxPoint(mCurrentAdvance, 0));
13259:   } else {
13259:     aContext->Translate(mPositions[mCurrentChar].pos);
13259:     aContext->Rotate(mPositions[mCurrentChar].angle);
14005:     aContext->Scale(aScale, aScale);
13259:   }
15470:   // We are scaling the glyphs up/down to the size we want so we need to
15470:   // inverse scale the outline widths of those glyphs so they are invariant
15470:   aContext->SetLineWidth(aContext->CurrentLineWidth() / aScale);
13259: }
13259: 
13259: CharacterPosition
13259: CharacterIterator::GetPositionData()
13259: {
13259:   if (!mPositions.IsEmpty())
13259:     return mPositions[mCurrentChar];
13259: 
19832:   gfxFloat advance = mCurrentAdvance * mMetricsScale;
13259:   CharacterPosition cp =
13259:     { mSource->mPosition + gfxPoint(advance, 0), 0, PR_TRUE };
13259:   return cp;
13259: }
