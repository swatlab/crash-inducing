35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
36124:  *   Jim Mathies <jmathies@mozilla.com>
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
35893: #include "PluginInstanceChild.h"
35925: #include "PluginModuleChild.h"
35895: #include "BrowserStreamChild.h"
35938: #include "PluginStreamChild.h"
35904: #include "StreamNotifyChild.h"
39979: #include "PluginThreadChild.h"
35746: 
36056: #include "mozilla/ipc/SyncChannel.h"
36056: 
35925: using namespace mozilla::plugins;
35925: 
35957: #ifdef MOZ_WIDGET_GTK2
35747: 
35740: #include <gtk/gtk.h>
35740: #include <gdk/gdkx.h>
35740: #include <gdk/gdk.h>
35740: #include "gtk2xtbin.h"
35747: 
38045: #elif defined(MOZ_WIDGET_QT)
38045: #include <QX11Info>
35747: #elif defined(OS_WIN)
38103: 
39729: #include "nsWindowsDllInterceptor.h"
39729: 
39729: typedef BOOL (WINAPI *User32TrackPopupMenu)(HMENU hMenu,
39729:                                             UINT uFlags,
39729:                                             int x,
39729:                                             int y,
39729:                                             int nReserved,
39729:                                             HWND hWnd,
39729:                                             CONST RECT *prcRect);
39729: static WindowsDllInterceptor sUser32Intercept;
39729: static HWND sWinlessPopupSurrogateHWND = NULL;
39729: static User32TrackPopupMenu sUser32TrackPopupMenuStub = NULL;
39729: 
36130: using mozilla::gfx::SharedDIB;
35747: 
35747: #include <windows.h>
38660: #include <windowsx.h>
35747: 
41342: // Flash WM_USER message delay time for PostDelayedTask. Borrowed
41342: // from Chromium's web plugin delegate src. See 'flash msg throttling
41342: // helpers' section for details.
41342: const int kFlashWMUSERMessageThrottleDelayMs = 5;
41342: 
36270: #define NS_OOPP_DOUBLEPASS_MSGID TEXT("MozDoublePassMsg")
41341: 
41341: #ifndef WM_MOUSEHWHEEL
41341: #define WM_MOUSEHWHEEL                    0x020E
41341: #endif
39883: #elif defined(XP_MACOSX)
39883: #include <ApplicationServices/ApplicationServices.h>
39883: #endif // defined(XP_MACOSX)
35740: 
38660: PluginInstanceChild::PluginInstanceChild(const NPPluginFuncs* aPluginIface,
39283:                                          const nsCString& aMimeType)
39283:     : mPluginIface(aPluginIface)
39283:     , mQuirks(0)
38660:     , mCachedWindowActor(nsnull)
38660:     , mCachedElementActor(nsnull)
35980: #if defined(OS_WIN)
35980:     , mPluginWindowHWND(0)
35980:     , mPluginWndProc(0)
35980:     , mPluginParentHWND(0)
38103:     , mCachedWinlessPluginHWND(0)
39729:     , mWinlessPopupSurrogateHWND(0)
41342:     , mWinlessThrottleOldWndProc(0)
41997:     , mWinlessHiddenMsgHWND(0)
37311: #endif // OS_WIN
39979:     , mAsyncCallMutex("PluginInstanceChild::mAsyncCallMutex")
40120: #if defined(OS_MACOSX)  
41029:     , mShColorSpace(nsnull)
41029:     , mShContext(nsnull)
41029:     , mDrawingModel(NPDrawingModelCoreGraphics)
40120: #endif
35980: {
35980:     memset(&mWindow, 0, sizeof(mWindow));
35980:     mData.ndata = (void*) this;
39978:     mData.pdata = nsnull;
35980: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35980:     mWindow.ws_info = &mWsInfo;
35980:     memset(&mWsInfo, 0, sizeof(mWsInfo));
35980: #ifdef MOZ_WIDGET_GTK2
35980:     mWsInfo.display = GDK_DISPLAY();
38045: #elif defined(MOZ_WIDGET_QT)
38045:     mWsInfo.display = QX11Info::display();
37311: #endif // MOZ_WIDGET_GTK2
37311: #endif // MOZ_X11 && XP_UNIX && !XP_MACOSX
36270: #if defined(OS_WIN)
36270:     memset(&mAlphaExtract, 0, sizeof(mAlphaExtract));
36270:     mAlphaExtract.doublePassEvent = ::RegisterWindowMessage(NS_OOPP_DOUBLEPASS_MSGID);
37311: #endif // OS_WIN
38660:     InitQuirksModes(aMimeType);
39729: #if defined(OS_WIN)
39729:     InitPopupMenuHook();
39729: #endif // OS_WIN
35980: }
35980: 
35893: PluginInstanceChild::~PluginInstanceChild()
35747: {
35747: #if defined(OS_WIN)
35747:   DestroyPluginWindow();
35747: #endif
40120: #if defined(OS_MACOSX)
40120:     if (mShColorSpace) {
40120:         ::CGColorSpaceRelease(mShColorSpace);
40120:     }
40120:     if (mShContext) {
40120:         ::CGContextRelease(mShContext);
40120:     }
40120: #endif
35747: }
35747: 
38660: void
38660: PluginInstanceChild::InitQuirksModes(const nsCString& aMimeType)
38660: {
38660: #ifdef OS_WIN
38660:     // application/x-silverlight
38660:     // application/x-silverlight-2
38660:     NS_NAMED_LITERAL_CSTRING(silverlight, "application/x-silverlight");
39729:     // application/x-shockwave-flash
39729:     NS_NAMED_LITERAL_CSTRING(flash, "application/x-shockwave-flash");
38660:     if (FindInReadable(silverlight, aMimeType)) {
38660:         mQuirks |= QUIRK_SILVERLIGHT_WINLESS_INPUT_TRANSLATION;
39729:         mQuirks |= QUIRK_WINLESS_TRACKPOPUP_HOOK;
39729:     }
39729:     else if (FindInReadable(flash, aMimeType)) {
39729:         mQuirks |= QUIRK_WINLESS_TRACKPOPUP_HOOK;
41342:         mQuirks |= QUIRK_FLASH_THROTTLE_WMUSER_EVENTS; 
38660:     }
38660: #endif
38660: }
38660: 
35740: NPError
38354: PluginInstanceChild::InternalGetNPObjectForValue(NPNVariable aValue,
38354:                                                  NPObject** aObject)
38354: {
38354:     PluginScriptableObjectChild* actor;
38354:     NPError result = NPERR_NO_ERROR;
38354: 
38354:     switch (aValue) {
38354:         case NPNVWindowNPObject:
38354:             if (!(actor = mCachedWindowActor)) {
38354:                 PPluginScriptableObjectChild* actorProtocol;
38354:                 CallNPN_GetValue_NPNVWindowNPObject(&actorProtocol, &result);
38354:                 if (result == NPERR_NO_ERROR) {
38354:                     actor = mCachedWindowActor =
38354:                         static_cast<PluginScriptableObjectChild*>(actorProtocol);
38354:                     NS_ASSERTION(actor, "Null actor!");
38354:                     PluginModuleChild::sBrowserFuncs.retainobject(
38354:                         actor->GetObject(false));
38354:                 }
38354:             }
38354:             break;
38354: 
38354:         case NPNVPluginElementNPObject:
38354:             if (!(actor = mCachedElementActor)) {
38354:                 PPluginScriptableObjectChild* actorProtocol;
38354:                 CallNPN_GetValue_NPNVPluginElementNPObject(&actorProtocol,
38354:                                                            &result);
38354:                 if (result == NPERR_NO_ERROR) {
38354:                     actor = mCachedElementActor =
38354:                         static_cast<PluginScriptableObjectChild*>(actorProtocol);
38354:                     NS_ASSERTION(actor, "Null actor!");
38354:                     PluginModuleChild::sBrowserFuncs.retainobject(
38354:                         actor->GetObject(false));
38354:                 }
38354:             }
38354:             break;
38354: 
38354:         default:
38354:             NS_NOTREACHED("Don't know what to do with this value type!");
38354:     }
38354: 
38354: #ifdef DEBUG
38354:     {
38354:         NPError currentResult;
38354:         PPluginScriptableObjectChild* currentActor;
38354: 
38354:         switch (aValue) {
38354:             case NPNVWindowNPObject:
38354:                 CallNPN_GetValue_NPNVWindowNPObject(&currentActor,
38354:                                                     &currentResult);
38354:                 break;
38354:             case NPNVPluginElementNPObject:
38354:                 CallNPN_GetValue_NPNVPluginElementNPObject(&currentActor,
38354:                                                            &currentResult);
38354:                 break;
38354:             default:
38354:                 NS_NOTREACHED("Don't know what to do with this value type!");
38354:         }
38354: 
38354:         // Make sure that the current actor returned by the parent matches our
38354:         // cached actor!
38354:         NS_ASSERTION(static_cast<PluginScriptableObjectChild*>(currentActor) ==
38354:                      actor, "Cached actor is out of date!");
38354:         NS_ASSERTION(currentResult == result, "Results don't match?!");
38354:     }
38354: #endif
38354: 
38354:     if (result != NPERR_NO_ERROR) {
38354:         return result;
38354:     }
38354: 
38354:     NPObject* object = actor->GetObject(false);
38354:     NS_ASSERTION(object, "Null object?!");
38354: 
38354:     *aObject = PluginModuleChild::sBrowserFuncs.retainobject(object);
38354:     return NPERR_NO_ERROR;
38354: 
38354: }
38354: 
38354: NPError
35893: PluginInstanceChild::NPN_GetValue(NPNVariable aVar,
35893:                                   void* aValue)
35740: {
37099:     PLUGIN_LOG_DEBUG(("%s (aVar=%i)", FULLFUNCTION, (int) aVar));
35971:     AssertPluginThread();
35740: 
35746:     switch(aVar) {
35740: 
35746:     case NPNVSupportsWindowless:
36011: #if defined(OS_LINUX) || defined(OS_WIN)
35951:         *((NPBool*)aValue) = true;
35951: #else
35747:         *((NPBool*)aValue) = false;
35951: #endif
35746:         return NPERR_NO_ERROR;
35746: 
35746: #if defined(OS_LINUX)
35740:     case NPNVSupportsXEmbedBool:
35747:         *((NPBool*)aValue) = true;
35740:         return NPERR_NO_ERROR;
35740: 
35740:     case NPNVToolkit:
35740:         *((NPNToolkitType*)aValue) = NPNVGtk2;
35740:         return NPERR_NO_ERROR;
35740: 
35746: #elif defined(OS_WIN)
35746:     case NPNVToolkit:
35746:         return NPERR_GENERIC_ERROR;
35746: #endif
35923:     case NPNVjavascriptEnabledBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVjavascriptEnabledBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
35923:     case NPNVisOfflineBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVisOfflineBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
35923:     case NPNVprivateModeBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVprivateModeBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
38354:     case NPNVWindowNPObject: // Intentional fall-through
38354:     case NPNVPluginElementNPObject: {
38354:         NPObject* object;
38354:         NPError result = InternalGetNPObjectForValue(aVar, &object);
38354:         if (result == NPERR_NO_ERROR) {
38354:             *((NPObject**)aValue) = object;
35965:         }
35965:         return result;
35965:     }
35965: 
37168:     case NPNVnetscapeWindow: {
37168: #ifdef XP_WIN
37168:         if (mWindow.type == NPWindowTypeDrawable) {
38103:             if (mCachedWinlessPluginHWND) {
38103:               *static_cast<HWND*>(aValue) = mCachedWinlessPluginHWND;
38103:               return NPERR_NO_ERROR;
38103:             }
37168:             NPError result;
38103:             if (!CallNPN_GetValue_NPNVnetscapeWindow(&mCachedWinlessPluginHWND, &result)) {
37168:                 return NPERR_GENERIC_ERROR;
37168:             }
38103:             *static_cast<HWND*>(aValue) = mCachedWinlessPluginHWND;
37168:             return result;
37168:         }
37168:         else {
37168:             *static_cast<HWND*>(aValue) = mPluginWindowHWND;
37168:             return NPERR_NO_ERROR;
37168:         }
37308: #elif defined(MOZ_X11)
37308:         NPError result;
37308:         CallNPN_GetValue_NPNVnetscapeWindow(static_cast<XID*>(aValue), &result);
37308:         return result;
37168: #else
37168:         return NPERR_GENERIC_ERROR;
37168: #endif
37168:     }
37168: 
39883: #ifdef XP_MACOSX
39883:    case NPNVsupportsCoreGraphicsBool: {
39883:         *((NPBool*)aValue) = true;
39883:         return NPERR_NO_ERROR;
39883:     }
39883: 
39883:     case NPNVsupportsCoreAnimationBool: {
41029:         *((NPBool*)aValue) = true;
39883:         return NPERR_NO_ERROR;
39883:     }
39883: 
39883:     case NPNVsupportsCocoaBool: {
39883:         *((NPBool*)aValue) = true;
39883:         return NPERR_NO_ERROR;
39883:     }
39883:   
39883: #ifndef NP_NO_QUICKDRAW
39883:     case NPNVsupportsQuickDrawBool: {
39883:         *((NPBool*)aValue) = false;
39883:         return NPERR_NO_ERROR;
39883:     }
39883: #endif /* NP_NO_QUICKDRAW */
39883: #endif /* XP_MACOSX */
39883: 
35740:     default:
37099:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37099:                ("In PluginInstanceChild::NPN_GetValue: Unhandled NPNVariable %i (%s)",
37099:                 (int) aVar, NPNVariableToString(aVar)));
35740:         return NPERR_GENERIC_ERROR;
35740:     }
35740: 
35740: }
35740: 
35951: 
35951: NPError
35951: PluginInstanceChild::NPN_SetValue(NPPVariable aVar, void* aValue)
35951: {
37099:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s (aVar=%i, aValue=%p)",
37099:                                       FULLFUNCTION, (int) aVar, aValue));
37099: 
35971:     AssertPluginThread();
35951: 
35951:     switch (aVar) {
35951:     case NPPVpluginWindowBool: {
35951:         NPError rv;
35951:         bool windowed = (NPBool) (intptr_t) aValue;
35951: 
35951:         if (!CallNPN_SetValue_NPPVpluginWindow(windowed, &rv))
35951:             return NPERR_GENERIC_ERROR;
35951: 
35951:         return rv;
35951:     }
35951: 
35951:     case NPPVpluginTransparentBool: {
35951:         NPError rv;
35951:         bool transparent = (NPBool) (intptr_t) aValue;
35951: 
35951:         if (!CallNPN_SetValue_NPPVpluginTransparent(transparent, &rv))
35951:             return NPERR_GENERIC_ERROR;
35951: 
35951:         return rv;
35951:     }
35951: 
39883: #ifdef XP_MACOSX
39883:     case NPPVpluginDrawingModel: {
39883:         NPError rv;
39883:         int drawingModel = (int16) (intptr_t) aValue;
39883: 
39883:         if (!CallNPN_SetValue_NPPVpluginDrawingModel(drawingModel, &rv))
39883:             return NPERR_GENERIC_ERROR;
41029:         mDrawingModel = drawingModel;
39883: 
39883:         return rv;
39883:     }
39883: 
39883:     case NPPVpluginEventModel: {
39883:         NPError rv;
39883:         int eventModel = (int16) (intptr_t) aValue;
39883: 
39883:         if (!CallNPN_SetValue_NPPVpluginEventModel(eventModel, &rv))
39883:             return NPERR_GENERIC_ERROR;
39883: 
39883:         return rv;
39883:     }
39883: #endif
39883: 
35951:     default:
37099:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37099:                ("In PluginInstanceChild::NPN_SetValue: Unhandled NPPVariable %i (%s)",
37099:                 (int) aVar, NPPVariableToString(aVar)));
35951:         return NPERR_GENERIC_ERROR;
35951:     }
35951: }
35951: 
35951: bool
35951: PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginNeedsXEmbed(
35951:     bool* needs, NPError* rv)
35951: {
35971:     AssertPluginThread();
35971: 
38126: #ifdef MOZ_X11
38126:     // The documentation on the types for many variables in NP(N|P)_GetValue
38126:     // is vague.  Often boolean values are NPBool (1 byte), but
38126:     // https://developer.mozilla.org/en/XEmbed_Extension_for_Mozilla_Plugins
38126:     // treats NPPVpluginNeedsXEmbed as PRBool (int), and
36324:     // on x86/32-bit, flash stores to this using |movl 0x1,&needsXEmbed|.
38126:     // thus we can't use NPBool for needsXEmbed, or the three bytes above
38126:     // it on the stack would get clobbered. so protect with the larger PRBool.
38126:     PRBool needsXEmbed = 0;
38126:     if (!mPluginIface->getvalue) {
38126:         *rv = NPERR_GENERIC_ERROR;
38126:     }
38126:     else {
35951:         *rv = mPluginIface->getvalue(GetNPP(), NPPVpluginNeedsXEmbed,
38126:                                      &needsXEmbed);
38126:     }
35951:     *needs = needsXEmbed;
35951:     return true;
35951: 
35951: #else
35951: 
38126:     NS_RUNTIMEABORT("shouldn't be called on non-X11 platforms");
35952:     return false;               // not reached
35951: 
35951: #endif
35951: }
35951: 
35926: bool
35925: PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginScriptableNPObject(
36078:                                           PPluginScriptableObjectChild** aValue,
36078:                                           NPError* aResult)
35746: {
35971:     AssertPluginThread();
35925: 
39411:     NPObject* object = nsnull;
38126:     NPError result = NPERR_GENERIC_ERROR;
38126:     if (mPluginIface->getvalue) {
38126:         result = mPluginIface->getvalue(GetNPP(), NPPVpluginScriptableNPObject,
35925:                                         &object);
38126:     }
36078:     if (result == NPERR_NO_ERROR && object) {
36078:         PluginScriptableObjectChild* actor = GetActorForNPObject(object);
36078: 
36078:         // If we get an actor then it has retained. Otherwise we don't need it
36078:         // any longer.
36078:         PluginModuleChild::sBrowserFuncs.releaseobject(object);
36078:         if (actor) {
36078:             *aValue = actor;
36078:             *aResult = NPERR_NO_ERROR;
35926:             return true;
35925:         }
35925: 
36078:         NS_ERROR("Failed to get actor!");
36078:         result = NPERR_GENERIC_ERROR;
35925:     }
39411:     else {
39411:         result = NPERR_GENERIC_ERROR;
39411:     }
35925: 
36078:     *aValue = nsnull;
36078:     *aResult = result;
35926:     return true;
35746: }
35746: 
35926: bool
37350: PluginInstanceChild::AnswerNPP_SetValue_NPNVprivateModeBool(const bool& value,
37350:                                                             NPError* result)
37350: {
37885:     if (!mPluginIface->setvalue) {
37885:         *result = NPERR_GENERIC_ERROR;
37885:         return true;
37885:     }
37885: 
39529:     NPBool v = value;
37350:     *result = mPluginIface->setvalue(GetNPP(), NPNVprivateModeBool, &v);
37350:     return true;
37350: }
37350: 
37350: bool
36011: PluginInstanceChild::AnswerNPP_HandleEvent(const NPRemoteEvent& event,
35933:                                            int16_t* handled)
35933: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35951: 
36014: #if defined(OS_LINUX) && defined(DEBUG)
36014:     if (GraphicsExpose == event.event.type)
38112:         PLUGIN_LOG_DEBUG(("  received drawable 0x%lx\n",
38112:                           event.event.xgraphicsexpose.drawable));
35951: #endif
35951: 
39883: #ifdef XP_MACOSX
39534:     // Mac OS X does not define an NPEvent structure. It defines more specific types.
39534:     NPCocoaEvent evcopy = event.event;
39534: #else
36124:     // Make a copy since we may modify values.
36011:     NPEvent evcopy = event.event;
39534: #endif
36124: 
36124: #ifdef OS_WIN
36270:     // Painting for win32. SharedSurfacePaint handles everything.
36270:     if (mWindow.type == NPWindowTypeDrawable) {
36270:        if (evcopy.event == WM_PAINT) {
36270:           *handled = SharedSurfacePaint(evcopy);
36270:           return true;
36270:        }
36270:        else if (evcopy.event == mAlphaExtract.doublePassEvent) {
36270:             // We'll render to mSharedSurfaceDib first, then render to a cached bitmap
36270:             // we store locally. The two passes are for alpha extraction, so the second
36270:             // pass must be to a flat white surface in order for things to work.
36270:             mAlphaExtract.doublePass = RENDER_BACK_ONE;
36270:             *handled = true;
36270:             return true;
36270:        }
36270:     }
38103:     *handled = WinlessHandleEvent(evcopy);
38103:     return true;
36124: #endif
36124: 
39279:     if (!mPluginIface->event)
39279:         *handled = false;
39279:     else
35933:         *handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
35980: 
39994: #ifdef XP_MACOSX
39994:     // Release any reference counted objects created in the child process.
39994:     if (evcopy.type == NPCocoaEventKeyDown ||
39994:         evcopy.type == NPCocoaEventKeyUp) {
39994:       ::CFRelease((CFStringRef)evcopy.data.key.characters);
39994:       ::CFRelease((CFStringRef)evcopy.data.key.charactersIgnoringModifiers);
39994:     }
39994:     else if (evcopy.type == NPCocoaEventTextInput) {
39994:       ::CFRelease((CFStringRef)evcopy.data.text.text);
39994:     }
39994: #endif
39994: 
35980: #ifdef MOZ_X11
36013:     if (GraphicsExpose == event.event.type) {
35980:         // Make sure the X server completes the drawing before the parent
35980:         // draws on top and destroys the Drawable.
35980:         //
35980:         // XSync() waits for the X server to complete.  Really this child
35980:         // process does not need to wait; the parent is the process that needs
35980:         // to wait.  A possibly-slightly-better alternative would be to send
35980:         // an X event to the parent that the parent would wait for.
35980:         XSync(mWsInfo.display, False);
35980:     }
35980: #endif
35980: 
35933:     return true;
35933: }
35933: 
39883: #ifdef XP_MACOSX
41029: 
39883: bool
39883: PluginInstanceChild::AnswerNPP_HandleEvent_Shmem(const NPRemoteEvent& event,
39883:                                                  Shmem& mem,
39883:                                                  int16_t* handled,
39883:                                                  Shmem* rtnmem)
39883: {
39883:     PLUGIN_LOG_DEBUG_FUNCTION;
39883:     AssertPluginThread();
39883: 
39883:     NPCocoaEvent evcopy = event.event;
39883: 
39883:     if (evcopy.type == NPCocoaEventDrawRect) {
40120:         if (!mShColorSpace) {
40120:             mShColorSpace = CreateSystemColorSpace();
40120:             if (!mShColorSpace) {
39883:                 PLUGIN_LOG_DEBUG(("Could not allocate ColorSpace."));
39883:                 *handled = false;
39883:                 *rtnmem = mem;
39883:                 return true;
39883:             } 
40120:         }
40120:         if (!mShContext) {
39883:             void* cgContextByte = mem.get<char>();
40120:             mShContext = ::CGBitmapContextCreate(cgContextByte, 
40120:                               mWindow.width, mWindow.height, 8, 
40120:                               mWindow.width * 4, mShColorSpace, 
40120:                               kCGImageAlphaPremultipliedFirst |
40120:                               kCGBitmapByteOrder32Host);
40120:     
40120:             if (!mShContext) {
39883:                 PLUGIN_LOG_DEBUG(("Could not allocate CGBitmapContext."));
39883:                 *handled = false;
39883:                 *rtnmem = mem;
39883:                 return true;
39883:             }
40120:         }
40494:         CGRect clearRect = ::CGRectMake(0, 0, mWindow.width, mWindow.height);
40494:         ::CGContextClearRect(mShContext, clearRect);
40120:         evcopy.data.draw.context = mShContext; 
39883:     } else {
39883:         PLUGIN_LOG_DEBUG(("Invalid event type for AnswerNNP_HandleEvent_Shmem."));
39883:         *handled = false;
39883:         *rtnmem = mem;
39883:         return true;
39883:     } 
39883: 
39883:     if (!mPluginIface->event) {
39883:         *handled = false;
39883:     } else {
39883:         *handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
39883:     }
39883: 
39883:     *rtnmem = mem;
39883:     return true;
39883: }
39883: 
39883: #else
39883: bool
39883: PluginInstanceChild::AnswerNPP_HandleEvent_Shmem(const NPRemoteEvent& event,
39883:                                                  Shmem& mem,
39883:                                                  int16_t* handled,
39883:                                                  Shmem* rtnmem)
39883: {
39883:     NS_RUNTIMEABORT("not reached.");
39883:     *rtnmem = mem;
39883:     return true;
39883: }
39883: #endif
39883: 
41029: #ifdef XP_MACOSX
41029: bool
41029: PluginInstanceChild::AnswerNPP_HandleEvent_IOSurface(const NPRemoteEvent& event,
41029:                                                      const uint32_t &surfaceid,
41029:                                                      int16_t* handled)
41029: {
41029:     PLUGIN_LOG_DEBUG_FUNCTION;
41029:     AssertPluginThread();
41029: 
41029:     NPCocoaEvent evcopy = event.event;
41029:     nsIOSurface* surf = nsIOSurface::LookupSurface(surfaceid);
41029:     if (!surf) {
41029:         NS_ERROR("Invalid IOSurface.\n");
41029:         *handled = false;
41029:         return false;
41029:     }
41029: 
41029:     if (evcopy.type == NPCocoaEventDrawRect) {
41029:         mCARenderer.AttachIOSurface(surf);
41029:         if (!mCARenderer.isInit()) {
41029:             void *caLayer = nsnull;
41029:             NPError result = mPluginIface->getvalue(GetNPP(), 
41029:                                      NPPVpluginCoreAnimationLayer,
41029:                                      &caLayer);
41029:             if (result != NPERR_NO_ERROR || !caLayer) {
41029:                 PLUGIN_LOG_DEBUG(("Plugin requested CoreAnimation but did not "
41029:                                   "provide CALayer."));
41029:                 *handled = false;
41029:                 return false;
41029:             }
41029:             mCARenderer.SetupRenderer(caLayer, mWindow.width, mWindow.height);
41029:             // Flash needs to have the window set again after this step
41029:             if (mPluginIface->setwindow)
41029:                 (void) mPluginIface->setwindow(&mData, &mWindow);
41029:         }
41029:     } else {
41029:         PLUGIN_LOG_DEBUG(("Invalid event type for "
41029:                           "AnswerNNP_HandleEvent_IOSurface."));
41029:         *handled = false;
41029:         return false;
41029:     } 
41029: 
41029:     mCARenderer.Render(mWindow.width, mWindow.height, nsnull);
41029: 
41029:     return true;
41029: 
41029: }
41029: 
41029: #else
41029: bool
41029: PluginInstanceChild::AnswerNPP_HandleEvent_IOSurface(const NPRemoteEvent& event,
41029:                                                      const uint32_t &surfaceid,
41029:                                                      int16_t* handled)
41029: {
41029:     NS_RUNTIMEABORT("NPP_HandleEvent_IOSurface is a OSX-only message");
41029:     return false;
41029: }
41029: #endif
41029: 
39720: bool
39720: PluginInstanceChild::RecvWindowPosChanged(const NPRemoteEvent& event)
39720: {
39720: #ifdef OS_WIN
39720:     int16_t dontcare;
39720:     return AnswerNPP_HandleEvent(event, &dontcare);
39720: #else
39720:     NS_RUNTIMEABORT("WindowPosChanged is a windows-only message");
39720:     return false;
39720: #endif
39720: }
39720: 
39720: 
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957: static bool
35957: XVisualIDToInfo(Display* aDisplay, VisualID aVisualID,
35957:                 Visual** aVisual, unsigned int* aDepth)
35957: {
35957:     if (aVisualID == None) {
35957:         *aVisual = NULL;
35957:         *aDepth = 0;
35957:         return true;
35957:     }
35957: 
35957:     const Screen* screen = DefaultScreenOfDisplay(aDisplay);
35957: 
35957:     for (int d = 0; d < screen->ndepths; d++) {
35957:         Depth *d_info = &screen->depths[d];
35957:         for (int v = 0; v < d_info->nvisuals; v++) {
35957:             Visual* visual = &d_info->visuals[v];
35957:             if (visual->visualid == aVisualID) {
35957:                 *aVisual = visual;
35957:                 *aDepth = d_info->depth;
35957:                 return true;
35957:             }
35957:         }
35957:     }
35957: 
35957:     NS_ERROR("VisualID not on Screen.");
35957:     return false;
35957: }
35957: #endif
35957: 
35933: bool
39279: PluginInstanceChild::AnswerNPP_SetWindow(const NPRemoteWindow& aWindow)
35740: {
37099:     PLUGIN_LOG_DEBUG(("%s (aWindow=<window: 0x%lx, x: %d, y: %d, width: %d, height: %d>)",
37099:                       FULLFUNCTION,
35957:                       aWindow.window,
35954:                       aWindow.x, aWindow.y,
37099:                       aWindow.width, aWindow.height));
35971:     AssertPluginThread();
35740: 
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957:     // The minimum info is sent over IPC to allow this
35957:     // code to determine the rest.
35740: 
35957:     mWindow.window = reinterpret_cast<void*>(aWindow.window);
35957:     mWindow.x = aWindow.x;
35957:     mWindow.y = aWindow.y;
35957:     mWindow.width = aWindow.width;
35957:     mWindow.height = aWindow.height;
35957:     mWindow.clipRect = aWindow.clipRect;
35957:     mWindow.type = aWindow.type;
35740: 
35957:     mWsInfo.colormap = aWindow.colormap;
35957:     if (!XVisualIDToInfo(mWsInfo.display, aWindow.visualID,
35957:                          &mWsInfo.visual, &mWsInfo.depth))
35957:         return false;
35740: 
37621: #ifdef MOZ_WIDGET_GTK2
41542:     if (aWindow.type == NPWindowTypeWindow
41542:         && gtk_check_version(2,18,7) != NULL) { // older
41542:         GdkWindow* socket_window = gdk_window_lookup(aWindow.window);
41542:         if (socket_window) {
37347:             // A GdkWindow for the socket already exists.  Need to
37347:             // workaround https://bugzilla.gnome.org/show_bug.cgi?id=607061
37347:             // See wrap_gtk_plug_embedded in PluginModuleChild.cpp.
37347:             g_object_set_data(G_OBJECT(socket_window),
37347:                               "moz-existed-before-set-window",
37347:                               GUINT_TO_POINTER(1));
37347:         }
41542:     }
37621: #endif
37347: 
39279:     if (mPluginIface->setwindow)
39279:         (void) mPluginIface->setwindow(&mData, &mWindow);
35747: 
35746: #elif defined(OS_WIN)
36124:     switch (aWindow.type) {
36124:       case NPWindowTypeWindow:
36124:       {
36124:           if (!CreatePluginWindow())
36124:               return false;
36124: 
35747:           ReparentPluginWindow((HWND)aWindow.window);
35747:           SizePluginWindow(aWindow.width, aWindow.height);
35747: 
35747:           mWindow.window = (void*)mPluginWindowHWND;
35954:           mWindow.x = aWindow.x;
35954:           mWindow.y = aWindow.y;
35746:           mWindow.width = aWindow.width;
35746:           mWindow.height = aWindow.height;
36011:           mWindow.type = aWindow.type;
35740: 
39279:           if (mPluginIface->setwindow) {
39279:               (void) mPluginIface->setwindow(&mData, &mWindow);
35747:               WNDPROC wndProc = reinterpret_cast<WNDPROC>(
35747:                   GetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC));
35747:               if (wndProc != PluginWindowProc) {
35747:                   mPluginWndProc = reinterpret_cast<WNDPROC>(
35747:                       SetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC,
35747:                                        reinterpret_cast<LONG>(PluginWindowProc)));
35747:               }
35747:           }
36124:       }
36124:       break;
36124: 
36124:       case NPWindowTypeDrawable:
41342:           mWindow.type = aWindow.type;
39729:           if (mQuirks & QUIRK_WINLESS_TRACKPOPUP_HOOK)
39729:               CreateWinlessPopupSurrogate();
41342:           if (mQuirks & QUIRK_FLASH_THROTTLE_WMUSER_EVENTS)
41342:               SetupFlashMsgThrottle();
39279:           return SharedSurfaceSetWindow(aWindow);
36124:       break;
36124: 
36124:       default:
36124:           NS_NOTREACHED("Bad plugin window type.");
36124:           return false;
36124:       break;
36124:     }
35747: 
39883: #elif defined(XP_MACOSX)
39534: 
39534:     mWindow.x = aWindow.x;
39534:     mWindow.y = aWindow.y;
39534:     mWindow.width = aWindow.width;
39534:     mWindow.height = aWindow.height;
39534:     mWindow.clipRect = aWindow.clipRect;
39534:     mWindow.type = aWindow.type;
36069: 
40120:     if (mShContext) {
40120:         // Release the shared context so that it is reallocated
40120:         // with the new size. 
40120:         ::CGContextRelease(mShContext);
41029:         mShContext = nsnull;
40120:     }
40120: 
39883:     if (mPluginIface->setwindow)
39883:         (void) mPluginIface->setwindow(&mData, &mWindow);
39883: 
35740: #else
35740: #  error Implement me for your OS
35740: #endif
35746: 
35926:     return true;
35740: }
35740: 
35747: bool
35893: PluginInstanceChild::Initialize()
35747: {
35747:     return true;
35747: }
35747: 
35747: #if defined(OS_WIN)
35747: 
35747: static const TCHAR kWindowClassName[] = TEXT("GeckoPluginWindow");
35893: static const TCHAR kPluginInstanceChildProperty[] = TEXT("PluginInstanceChildProperty");
35747: 
35747: // static
35747: bool
35893: PluginInstanceChild::RegisterWindowClass()
35747: {
35747:     static bool alreadyRegistered = false;
35747:     if (alreadyRegistered)
35747:         return true;
35747: 
35747:     alreadyRegistered = true;
35747: 
35747:     WNDCLASSEX wcex;
35747:     wcex.cbSize         = sizeof(WNDCLASSEX);
35747:     wcex.style          = CS_DBLCLKS;
35747:     wcex.lpfnWndProc    = DummyWindowProc;
35747:     wcex.cbClsExtra     = 0;
35747:     wcex.cbWndExtra     = 0;
35747:     wcex.hInstance      = GetModuleHandle(NULL);
35747:     wcex.hIcon          = 0;
35747:     wcex.hCursor        = 0;
35748:     wcex.hbrBackground  = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
35747:     wcex.lpszMenuName   = 0;
35747:     wcex.lpszClassName  = kWindowClassName;
35747:     wcex.hIconSm        = 0;
35747: 
35747:     return RegisterClassEx(&wcex) ? true : false;
35747: }
35747: 
35747: bool
35893: PluginInstanceChild::CreatePluginWindow()
35747: {
36124:     // already initialized
36124:     if (mPluginWindowHWND)
36124:         return true;
36124:         
35747:     if (!RegisterWindowClass())
35747:         return false;
35747: 
35747:     mPluginWindowHWND =
35747:         CreateWindowEx(WS_EX_LEFT | WS_EX_LTRREADING |
35747:                        WS_EX_NOPARENTNOTIFY | // XXXbent Get rid of this!
35747:                        WS_EX_RIGHTSCROLLBAR,
35747:                        kWindowClassName, 0,
35747:                        WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0, 0,
35747:                        0, 0, NULL, 0, GetModuleHandle(NULL), 0);
35747:     if (!mPluginWindowHWND)
35747:         return false;
35893:     if (!SetProp(mPluginWindowHWND, kPluginInstanceChildProperty, this))
35747:         return false;
35747: 
35747:     // Apparently some plugins require an ASCII WndProc.
35747:     SetWindowLongPtrA(mPluginWindowHWND, GWLP_WNDPROC,
35747:                       reinterpret_cast<LONG>(DefWindowProcA));
35747: 
35747:     return true;
35747: }
35747: 
35747: void
35893: PluginInstanceChild::DestroyPluginWindow()
35747: {
35747:     if (mPluginWindowHWND) {
35747:         // Unsubclass the window.
35747:         WNDPROC wndProc = reinterpret_cast<WNDPROC>(
35747:             GetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC));
35747:         if (wndProc == PluginWindowProc) {
35747:             NS_ASSERTION(mPluginWndProc, "Should have old proc here!");
35747:             SetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC,
35747:                              reinterpret_cast<LONG>(mPluginWndProc));
35747:             mPluginWndProc = 0;
35747:         }
35747: 
35893:         RemoveProp(mPluginWindowHWND, kPluginInstanceChildProperty);
35747:         DestroyWindow(mPluginWindowHWND);
35747:         mPluginWindowHWND = 0;
35747:     }
35747: }
35747: 
35747: void
35893: PluginInstanceChild::ReparentPluginWindow(HWND hWndParent)
35747: {
35747:     if (hWndParent != mPluginParentHWND && IsWindow(hWndParent)) {
36082:         // Fix the child window's style to be a child window.
35747:         LONG style = GetWindowLongPtr(mPluginWindowHWND, GWL_STYLE);
35747:         style |= WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
36082:         style &= ~WS_POPUP;
35747:         SetWindowLongPtr(mPluginWindowHWND, GWL_STYLE, style);
36082: 
36082:         // Do the reparenting.
35747:         SetParent(mPluginWindowHWND, hWndParent);
36082: 
36082:         // Make sure we're visible.
35747:         ShowWindow(mPluginWindowHWND, SW_SHOWNA);
35747:     }
35747:     mPluginParentHWND = hWndParent;
35747: }
35747: 
35747: void
35893: PluginInstanceChild::SizePluginWindow(int width,
35747:                                       int height)
35747: {
35747:     if (mPluginWindowHWND) {
38281:         mPluginSize.x = width;
38281:         mPluginSize.y = height;
35747:         SetWindowPos(mPluginWindowHWND, NULL, 0, 0, width, height,
35747:                      SWP_NOZORDER | SWP_NOREPOSITION);
35747:     }
35747: }
35747: 
35747: // See chromium's webplugin_delegate_impl.cc for explanation of this function.
35747: // static
35747: LRESULT CALLBACK
35893: PluginInstanceChild::DummyWindowProc(HWND hWnd,
35747:                                      UINT message,
35747:                                      WPARAM wParam,
35747:                                      LPARAM lParam)
35747: {
35747:     return CallWindowProc(DefWindowProc, hWnd, message, wParam, lParam);
35747: }
35747: 
35747: // static
35747: LRESULT CALLBACK
35893: PluginInstanceChild::PluginWindowProc(HWND hWnd,
35747:                                       UINT message,
35747:                                       WPARAM wParam,
35747:                                       LPARAM lParam)
35747: {
36056:     NS_ASSERTION(!mozilla::ipc::SyncChannel::IsPumpingMessages(),
36056:                  "Failed to prevent a nonqueued message from running!");
36056: 
35893:     PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
35893:         GetProp(hWnd, kPluginInstanceChildProperty));
35747:     if (!self) {
35747:         NS_NOTREACHED("Badness!");
35747:         return 0;
35747:     }
35747: 
35747:     NS_ASSERTION(self->mPluginWindowHWND == hWnd, "Wrong window!");
35747: 
38281:     // Adobe's shockwave positions the plugin window relative to the browser
38281:     // frame when it initializes. With oopp disabled, this wouldn't have an
38281:     // effect. With oopp, GeckoPluginWindow is a child of the parent plugin
38281:     // window, so the move offsets the child within the parent. Generally
38281:     // we don't want plugins moving or sizing our window, so we prevent these
38281:     // changes here.
38281:     if (message == WM_WINDOWPOSCHANGING) {
38281:       WINDOWPOS* pos = reinterpret_cast<WINDOWPOS*>(lParam);
38281:       if (pos && (!(pos->flags & SWP_NOMOVE) || !(pos->flags & SWP_NOSIZE))) {
38281:         pos->x = pos->y = 0;
38281:         pos->cx = self->mPluginSize.x;
38281:         pos->cy = self->mPluginSize.y;
38281:         LRESULT res = CallWindowProc(self->mPluginWndProc, hWnd, message, wParam,
38281:                                      lParam);
38281:         pos->x = pos->y = 0;
38281:         pos->cx = self->mPluginSize.x;
38281:         pos->cy = self->mPluginSize.y;
38281:         return res;
38281:       }
38281:     }
38281: 
37550:     // The plugin received keyboard focus, let the parent know so the dom is up to date.
37550:     if (message == WM_MOUSEACTIVATE)
37550:         self->CallPluginGotFocus();
37550: 
37551:     // Prevent lockups due to plugins making rpc calls when the parent
41341:     // is making a synchronous SendMessage call to the child window. Add
41341:     // more messages as needed.
41341:     if ((InSendMessageEx(NULL)&(ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
41341:         switch(message) {
41341:             case WM_KILLFOCUS:
41341:             case WM_MOUSEHWHEEL:
41341:             case WM_MOUSEWHEEL:
41341:             case WM_HSCROLL:
41341:             case WM_VSCROLL:
41341:             ReplyMessage(0);
41341:             break;
41341:         }
37551:     }
37551: 
41342:     if (message == WM_USER+1 &&
41342:         (self->mQuirks & PluginInstanceChild::QUIRK_FLASH_THROTTLE_WMUSER_EVENTS)) {
41342:         self->FlashThrottleMessage(hWnd, message, wParam, lParam, true);
41342:         return 0;
41342:     }
41342: 
35747:     LRESULT res = CallWindowProc(self->mPluginWndProc, hWnd, message, wParam,
35747:                                  lParam);
35747: 
35747:     if (message == WM_CLOSE)
35747:         self->DestroyPluginWindow();
35747: 
35747:     if (message == WM_NCDESTROY)
35893:         RemoveProp(hWnd, kPluginInstanceChildProperty);
35747: 
35747:     return res;
35747: }
35747: 
39729: /* windowless track popup menu helpers */
39729: 
39729: BOOL
39729: WINAPI
39729: PluginInstanceChild::TrackPopupHookProc(HMENU hMenu,
39729:                                         UINT uFlags,
39729:                                         int x,
39729:                                         int y,
39729:                                         int nReserved,
39729:                                         HWND hWnd,
39729:                                         CONST RECT *prcRect)
39729: {
39729:   if (!sUser32TrackPopupMenuStub) {
39729:       NS_ERROR("TrackPopupMenu stub isn't set! Badness!");
39729:       return 0;
39729:   }
39729: 
39729:   // Only change the parent when we know this is a context on the plugin
39729:   // surface within the browser. Prevents resetting the parent on child ui
39729:   // displayed by plugins that have working parent-child relationships.
39729:   PRUnichar szClass[21];
39729:   bool haveClass = GetClassNameW(hWnd, szClass, NS_ARRAY_LENGTH(szClass));
39729:   if (!haveClass || 
39729:       (wcscmp(szClass, L"MozillaWindowClass") &&
39729:        wcscmp(szClass, L"SWFlash_Placeholder"))) {
39729:       // Unrecognized parent
39729:       return sUser32TrackPopupMenuStub(hMenu, uFlags, x, y, nReserved,
39729:                                        hWnd, prcRect);
39729:   }
39729: 
39729:   // Called on an unexpected event, warn.
39729:   if (!sWinlessPopupSurrogateHWND) {
39729:       NS_WARNING(
39729:           "Untraced TrackPopupHookProc call! Menu might not work right!");
39729:       return sUser32TrackPopupMenuStub(hMenu, uFlags, x, y, nReserved,
39729:                                        hWnd, prcRect);
39729:   }
39729: 
39729:   HWND surrogateHwnd = sWinlessPopupSurrogateHWND;
39729:   sWinlessPopupSurrogateHWND = NULL;
39729: 
39729:   // Popups that don't use TPM_RETURNCMD expect a final command message
39729:   // when an item is selected and the context closes. Since we replace
39729:   // the parent, we need to forward this back to the real parent so it
39729:   // can act on the menu item selected.
39729:   bool isRetCmdCall = (uFlags & TPM_RETURNCMD);
39729: 
39729:   // A little trick scrounged from chromium's code - set the focus
39729:   // to our surrogate parent so keyboard nav events go to the menu. 
39729:   HWND focusHwnd = SetFocus(surrogateHwnd);
39729:   DWORD res = sUser32TrackPopupMenuStub(hMenu, uFlags|TPM_RETURNCMD, x, y,
39729:                                         nReserved, surrogateHwnd, prcRect);
39729:   if (IsWindow(focusHwnd)) {
39729:       SetFocus(focusHwnd);
39729:   }
39729: 
39729:   if (!isRetCmdCall && res) {
39729:       SendMessage(hWnd, WM_COMMAND, MAKEWPARAM(res, 0), 0);
39729:   }
39729: 
39729:   return res;
39729: }
39729: 
39729: void
39729: PluginInstanceChild::InitPopupMenuHook()
39729: {
39729:     if (!(mQuirks & QUIRK_WINLESS_TRACKPOPUP_HOOK) ||
39729:         sUser32TrackPopupMenuStub)
39729:         return;
39729: 
39729:     // Note, once WindowsDllInterceptor is initialized for a module,
39729:     // it remains initialized for that particular module for it's
39729:     // lifetime. Additional instances are needed if other modules need
39729:     // to be hooked.
39729:     sUser32Intercept.Init("user32.dll");
39729:     sUser32Intercept.AddHook("TrackPopupMenu", TrackPopupHookProc,
39729:                              (void**) &sUser32TrackPopupMenuStub);
39729: }
39729: 
39729: void
39729: PluginInstanceChild::CreateWinlessPopupSurrogate()
39729: {
39729:     // already initialized
39729:     if (mWinlessPopupSurrogateHWND)
39729:         return;
39729: 
39729:     HWND hwnd = NULL;
39729:     NPError result;
39729:     if (!CallNPN_GetValue_NPNVnetscapeWindow(&hwnd, &result)) {
39729:         NS_ERROR("CallNPN_GetValue_NPNVnetscapeWindow failed.");
39729:         return;
39729:     }
39729: 
39729:     mWinlessPopupSurrogateHWND =
39729:         CreateWindowEx(WS_EX_NOPARENTNOTIFY, L"Static", NULL, WS_CHILD, 0, 0,
39729:                        0, 0, hwnd, 0, GetModuleHandle(NULL), 0);
39729:     if (!mWinlessPopupSurrogateHWND) {
39729:         NS_ERROR("CreateWindowEx failed for winless placeholder!");
39729:         return;
39729:     }
39729:     return;
39729: }
39729: 
39729: void
39729: PluginInstanceChild::DestroyWinlessPopupSurrogate()
39729: {
39729:     if (mWinlessPopupSurrogateHWND)
39729:         DestroyWindow(mWinlessPopupSurrogateHWND);
39729:     mWinlessPopupSurrogateHWND = NULL;
39729: }
39729: 
38660: /* windowless handle event helpers */
38660: 
38660: static bool
38660: NeedsNestedEventCoverage(UINT msg)
38660: {
38660:     // Events we assume some sort of modal ui *might* be generated.
38660:     switch (msg) {
38660:         case WM_LBUTTONUP:
38660:         case WM_RBUTTONUP:
38660:         case WM_MBUTTONUP:
38660:         case WM_LBUTTONDOWN:
38660:         case WM_RBUTTONDOWN:
38660:         case WM_MBUTTONDOWN:
38660:         case WM_CONTEXTMENU:
38660:             return true;
38660:     }
38660:     return false;
38660: }
38660: 
38660: static bool
38660: IsMouseInputEvent(UINT msg)
38660: {
38660:     switch (msg) {
38660:         case WM_MOUSEMOVE:
38660:         case WM_LBUTTONUP:
38660:         case WM_RBUTTONUP:
38660:         case WM_MBUTTONUP:
38660:         case WM_LBUTTONDOWN:
38660:         case WM_RBUTTONDOWN:
38660:         case WM_MBUTTONDOWN:
38660:         case WM_LBUTTONDBLCLK:
38660:         case WM_MBUTTONDBLCLK:
38660:         case WM_RBUTTONDBLCLK:
38660:             return true;
38660:     }
38660:     return false;
38660: }
38660: 
38103: int16_t
38103: PluginInstanceChild::WinlessHandleEvent(NPEvent& event)
38103: {
39279:     if (!mPluginIface->event)
39279:         return false;
39279: 
38660:     // Winless Silverlight quirk: winposchanged events are not used in
38660:     // determining the position of the plugin within the parent window,
38660:     // NPP_SetWindow values are used instead. Due to shared memory dib
38660:     // rendering, the origin of NPP_SetWindow is 0x0, so we trap
38660:     // winposchanged events here and do the translation internally for
38660:     // mouse input events.
38660:     if (mQuirks & QUIRK_SILVERLIGHT_WINLESS_INPUT_TRANSLATION) {
38660:         if (event.event == WM_WINDOWPOSCHANGED && event.lParam) {
38660:             WINDOWPOS* pos = reinterpret_cast<WINDOWPOS*>(event.lParam);
38660:             mPluginOffset.x = pos->x;
38660:             mPluginOffset.y = pos->y;
38660:         }
38660:         else if (IsMouseInputEvent(event.event)) {
38660:             event.lParam =
38660:                 MAKELPARAM((GET_X_LPARAM(event.lParam) - mPluginOffset.x),
38660:                            (GET_Y_LPARAM(event.lParam) - mPluginOffset.y));
38660:         }
38660:     }
38660: 
38660:     if (!NeedsNestedEventCoverage(event.event)) {
38103:         return mPluginIface->event(&mData, reinterpret_cast<void*>(&event));
38103:     }
38103: 
38660:     // Events that might generate nested event dispatch loops need
38660:     // special handling during delivery.
38103:     int16_t handled;
38103: 
39729:     // TrackPopupMenu will fail if the parent window is not associated with
39729:     // our ui thread. So we hook TrackPopupMenu so we can hand in a surrogate
39729:     // parent created in the child process.
39729:     if ((mQuirks & QUIRK_WINLESS_TRACKPOPUP_HOOK) && // XXX turn on by default?
39729:           (event.event == WM_RBUTTONDOWN || // flash
39729:            event.event == WM_RBUTTONUP)) {  // silverlight
39729:       sWinlessPopupSurrogateHWND = mWinlessPopupSurrogateHWND;
39729:     }
39729: 
38103:     handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&event));
38103: 
39729:     sWinlessPopupSurrogateHWND = NULL;
38103: 
38103:     return handled;
38103: }
38103: 
36124: /* windowless drawing helpers */
36124: 
36124: bool
39279: PluginInstanceChild::SharedSurfaceSetWindow(const NPRemoteWindow& aWindow)
36124: {
36124:     // If the surfaceHandle is empty, parent is telling us we can reuse our cached
36124:     // memory surface and hdc. Otherwise, we need to reset, usually due to a
36124:     // expanding plugin port size.
36124:     if (!aWindow.surfaceHandle) {
36124:         if (!mSharedSurfaceDib.IsValid()) {
36124:             return false;
36124:         }
36124:     }
36124:     else {
36124:         // Attach to the new shared surface parent handed us.
36124:         if (NS_FAILED(mSharedSurfaceDib.Attach((SharedDIB::Handle)aWindow.surfaceHandle,
36124:                                                aWindow.width, aWindow.height, 32)))
36124:           return false;
36270:         // Free any alpha extraction resources if needed. This will be reset
36270:         // the next time it's used.
36270:         AlphaExtractCacheRelease();
36124:     }
36124:       
36124:     // NPRemoteWindow's origin is the origin of our shared dib.
36124:     mWindow.x      = 0;
36124:     mWindow.y      = 0;
36124:     mWindow.width  = aWindow.width;
36124:     mWindow.height = aWindow.height;
36124:     mWindow.type   = aWindow.type;
36124: 
36124:     mWindow.window = reinterpret_cast<void*>(mSharedSurfaceDib.GetHDC());
39279: 
39279:     if (mPluginIface->setwindow)
39279:         mPluginIface->setwindow(&mData, &mWindow);
36124: 
36124:     return true;
36124: }
36124: 
36124: void
36124: PluginInstanceChild::SharedSurfaceRelease()
36124: {
36124:     mSharedSurfaceDib.Close();
36270:     AlphaExtractCacheRelease();
36270: }
36270: 
36270: /* double pass cache buffer - (rarely) used in cases where alpha extraction
36270:  * occurs for windowless plugins. */
36270:  
36270: bool
36270: PluginInstanceChild::AlphaExtractCacheSetup()
36270: {
36270:     AlphaExtractCacheRelease();
36270: 
36270:     mAlphaExtract.hdc = ::CreateCompatibleDC(NULL);
36270: 
36270:     if (!mAlphaExtract.hdc)
36270:         return false;
36270: 
36270:     BITMAPINFOHEADER bmih;
36270:     memset((void*)&bmih, 0, sizeof(BITMAPINFOHEADER));
36270:     bmih.biSize        = sizeof(BITMAPINFOHEADER);
36270:     bmih.biWidth       = mWindow.width;
36270:     bmih.biHeight      = mWindow.height;
36270:     bmih.biPlanes      = 1;
36270:     bmih.biBitCount    = 32;
36270:     bmih.biCompression = BI_RGB;
36270: 
36270:     void* ppvBits = nsnull;
36270:     mAlphaExtract.bmp = ::CreateDIBSection(mAlphaExtract.hdc,
36270:                                            (BITMAPINFO*)&bmih,
36270:                                            DIB_RGB_COLORS,
36270:                                            (void**)&ppvBits,
36270:                                            NULL,
36270:                                            (unsigned long)sizeof(BITMAPINFOHEADER));
36270:     if (!mAlphaExtract.bmp)
36270:       return false;
36270: 
36270:     DeleteObject(::SelectObject(mAlphaExtract.hdc, mAlphaExtract.bmp));
36270:     return true;
36124: }
36124: 
36124: void
36270: PluginInstanceChild::AlphaExtractCacheRelease()
36124: {
36270:     if (mAlphaExtract.bmp)
36270:         ::DeleteObject(mAlphaExtract.bmp);
36270: 
36270:     if (mAlphaExtract.hdc)
36270:         ::DeleteObject(mAlphaExtract.hdc);
36270: 
36270:     mAlphaExtract.bmp = NULL;
36270:     mAlphaExtract.hdc = NULL;
36270: }
36270: 
36270: void
36270: PluginInstanceChild::UpdatePaintClipRect(RECT* aRect)
36270: {
36270:     if (aRect) {
36124:         // Update the clip rect on our internal hdc
36270:         HRGN clip = ::CreateRectRgnIndirect(aRect);
36124:         ::SelectClipRgn(mSharedSurfaceDib.GetHDC(), clip);
36124:         ::DeleteObject(clip);
36124:     }
36270: }
36270: 
36270: int16_t
36270: PluginInstanceChild::SharedSurfacePaint(NPEvent& evcopy)
36270: {
39279:     if (!mPluginIface->event)
39279:         return false;
39279: 
36270:     RECT* pRect = reinterpret_cast<RECT*>(evcopy.lParam);
36270: 
36270:     switch(mAlphaExtract.doublePass) {
36270:         case RENDER_NATIVE:
36124:             // pass the internal hdc to the plugin
36270:             UpdatePaintClipRect(pRect);
36124:             evcopy.wParam = WPARAM(mSharedSurfaceDib.GetHDC());
36270:             return mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
36270:         break;
36270:         case RENDER_BACK_ONE:
36270:               // Handle a double pass render used in alpha extraction for transparent
36270:               // plugins. (See nsObjectFrame and gfxWindowsNativeDrawing for details.)
36270:               // We render twice, once to the shared dib, and once to a cache which
36270:               // we copy back on a second paint. These paints can't be spread across
36270:               // multiple rpc messages as delays cause animation frame changes.
36270:               if (!mAlphaExtract.bmp && !AlphaExtractCacheSetup()) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270: 
36270:               // See gfxWindowsNativeDrawing, color order doesn't have to match.
40219:               UpdatePaintClipRect(pRect);
36270:               ::FillRect(mSharedSurfaceDib.GetHDC(), pRect, (HBRUSH)GetStockObject(WHITE_BRUSH));
36270:               evcopy.wParam = WPARAM(mSharedSurfaceDib.GetHDC());
36270:               if (!mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy))) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270: 
36270:               // Copy to cache. We render to shared dib so we don't have to call
36270:               // setwindow between calls (flash issue).  
36270:               ::BitBlt(mAlphaExtract.hdc,
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        pRect->right - pRect->left,
36270:                        pRect->bottom - pRect->top,
36270:                        mSharedSurfaceDib.GetHDC(),
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        SRCCOPY);
36270: 
36270:               ::FillRect(mSharedSurfaceDib.GetHDC(), pRect, (HBRUSH)GetStockObject(BLACK_BRUSH));
36270:               if (!mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy))) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270:               mAlphaExtract.doublePass = RENDER_BACK_TWO;
36270:               return true;
36270:         break;
36270:         case RENDER_BACK_TWO:
36270:               // copy our cached surface back
40219:               UpdatePaintClipRect(pRect);
36270:               ::BitBlt(mSharedSurfaceDib.GetHDC(),
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        pRect->right - pRect->left,
36270:                        pRect->bottom - pRect->top,
36270:                        mAlphaExtract.hdc,
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        SRCCOPY);
36270:               mAlphaExtract.doublePass = RENDER_NATIVE;
36270:               return true;
36270:         break;
36270:     }
36270:     return false;
36124: }
36124: 
41342: /* flash msg throttling helpers */
41342: 
41342: // Flash has the unfortunate habit of flooding dispatch loops with custom
41342: // windowing events they use for timing. We throttle these by dropping the
41342: // delivery priority below any other event, including pending ipc io
41342: // notifications. We do this for both windowed and windowless controls.
41997: // Note flash's windowless msg window can last longer than our instance,
41997: // so we try to unhook when the window is destroyed and in NPP_Destroy.
41997: 
41997: void
41997: PluginInstanceChild::UnhookWinlessFlashThrottle()
41997: {
41997:   // We may have already unhooked
41997:   if (!mWinlessThrottleOldWndProc)
41997:       return;
41997: 
41997:   WNDPROC tmpProc = mWinlessThrottleOldWndProc;
41997:   mWinlessThrottleOldWndProc = nsnull;
41997: 
41997:   NS_ASSERTION(mWinlessHiddenMsgHWND,
41997:                "Missing mWinlessHiddenMsgHWND w/subclass set??");
41997: 
41997:   // reset the subclass
41997:   SetWindowLongPtr(mWinlessHiddenMsgHWND, GWLP_WNDPROC,
41997:                    reinterpret_cast<LONG>(tmpProc));
41997: 
41997:   // Remove our instance prop
41997:   RemoveProp(mWinlessHiddenMsgHWND, kPluginInstanceChildProperty);
41997:   mWinlessHiddenMsgHWND = nsnull;
41997: }
41342: 
41342: // static
41342: LRESULT CALLBACK
41342: PluginInstanceChild::WinlessHiddenFlashWndProc(HWND hWnd,
41342:                                                UINT message,
41342:                                                WPARAM wParam,
41342:                                                LPARAM lParam)
41342: {
41342:     PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
41342:         GetProp(hWnd, kPluginInstanceChildProperty));
41342:     if (!self) {
41342:         NS_NOTREACHED("Badness!");
41342:         return 0;
41342:     }
41342: 
41342:     NS_ASSERTION(self->mWinlessThrottleOldWndProc,
41342:                  "Missing subclass procedure!!");
41342: 
41342:     // Throttle
41342:     if (message == WM_USER+1) {
41342:         self->FlashThrottleMessage(hWnd, message, wParam, lParam, false);
41342:         return 0;
41342:      }
41342: 
41342:     // Unhook
41997:     if (message == WM_CLOSE || message == WM_NCDESTROY) {
41342:         WNDPROC tmpProc = self->mWinlessThrottleOldWndProc;
41997:         self->UnhookWinlessFlashThrottle();
41342:         LRESULT res = CallWindowProc(tmpProc, hWnd, message, wParam, lParam);
41342:         return res;
41342:     }
41342: 
41342:     return CallWindowProc(self->mWinlessThrottleOldWndProc,
41342:                           hWnd, message, wParam, lParam);
41342: }
41342: 
41342: // Enumerate all thread windows looking for flash's hidden message window.
41342: // Once we find it, sub class it so we can throttle user msgs.  
41342: // static
41342: BOOL CALLBACK
41342: PluginInstanceChild::EnumThreadWindowsCallback(HWND hWnd,
41342:                                                LPARAM aParam)
41342: {
41342:     PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(aParam);
41342:     if (!self) {
41342:         NS_NOTREACHED("Enum befuddled!");
41342:         return FALSE;
41342:     }
41342: 
41342:     PRUnichar className[64];
41342:     if (!GetClassNameW(hWnd, className, sizeof(className)/sizeof(PRUnichar)))
41342:       return TRUE;
41342:     
41342:     if (!wcscmp(className, L"SWFlash_PlaceholderX")) {
41342:         WNDPROC oldWndProc =
41342:             reinterpret_cast<WNDPROC>(GetWindowLongPtr(hWnd, GWLP_WNDPROC));
41342:         // Only set this if we haven't already.
41342:         if (oldWndProc != WinlessHiddenFlashWndProc) {
41342:             if (self->mWinlessThrottleOldWndProc) {
41342:                 NS_WARNING("mWinlessThrottleWndProc already set???");
41342:                 return FALSE;
41342:             }
41342:             // Subsclass and store self as a property
41997:             self->mWinlessHiddenMsgHWND = hWnd;
41342:             self->mWinlessThrottleOldWndProc =
41342:                 reinterpret_cast<WNDPROC>(SetWindowLongPtr(hWnd, GWLP_WNDPROC,
41342:                 reinterpret_cast<LONG>(WinlessHiddenFlashWndProc)));
41342:             SetProp(hWnd, kPluginInstanceChildProperty, self);
41342:             NS_ASSERTION(self->mWinlessThrottleOldWndProc,
41342:                          "SetWindowLongPtr failed?!");
41342:         }
41342:         // Return no matter what once we find the right window.
41342:         return FALSE;
41342:     }
41342: 
41342:     return TRUE;
41342: }
41342: 
41342: 
41342: void
41342: PluginInstanceChild::SetupFlashMsgThrottle()
41342: {
41342:     if (mWindow.type == NPWindowTypeDrawable) {
41342:         // Search for the flash hidden message window and subclass it. Only
41342:         // search for flash windows belonging to our ui thread!
41342:         if (mWinlessThrottleOldWndProc)
41342:             return;
41342:         EnumThreadWindows(GetCurrentThreadId(), EnumThreadWindowsCallback,
41342:                           reinterpret_cast<LPARAM>(this));
41342:     }
41342:     else {
41342:         // Already setup through quirks and the subclass.
41342:         return;
41342:     }
41342: }
41342: 
41342: WNDPROC
41342: PluginInstanceChild::FlashThrottleAsyncMsg::GetProc()
41342: { 
41342:     if (mInstance) {
41342:         return mWindowed ? mInstance->mPluginWndProc :
41342:                            mInstance->mWinlessThrottleOldWndProc;
41342:     }
41342:     return nsnull;
41342: }
41342:  
41342: void
41342: PluginInstanceChild::FlashThrottleAsyncMsg::Run()
41342: {
41342:     RemoveFromAsyncList();
41342: 
41342:     // GetProc() checks mInstance, and pulls the procedure from
41342:     // PluginInstanceChild. We don't transport sub-class procedure
41342:     // ptrs around in FlashThrottleAsyncMsg msgs.
41342:     if (!GetProc())
41342:         return;
41342:   
41342:     // deliver the event to flash 
41342:     CallWindowProc(GetProc(), GetWnd(), GetMsg(), GetWParam(), GetLParam());
41342: }
41342: 
41342: void
41342: PluginInstanceChild::FlashThrottleMessage(HWND aWnd,
41342:                                           UINT aMsg,
41342:                                           WPARAM aWParam,
41342:                                           LPARAM aLParam,
41342:                                           bool isWindowed)
41342: {
41342:     // We reuse ChildAsyncCall so we get the cancelation work
41342:     // that's done in Destroy.
41342:     FlashThrottleAsyncMsg* task = new FlashThrottleAsyncMsg(this,
41342:         aWnd, aMsg, aWParam, aLParam, isWindowed);
41342:     if (!task)
41342:         return; 
41342: 
41342:     {
41342:         MutexAutoLock lock(mAsyncCallMutex);
41342:         mPendingAsyncCalls.AppendElement(task);
41342:     }
41342:     MessageLoop::current()->PostDelayedTask(FROM_HERE,
41342:         task, kFlashWMUSERMessageThrottleDelayMs);
41342: }
41342: 
35747: #endif // OS_WIN
35747: 
37550: bool
37550: PluginInstanceChild::AnswerSetPluginFocus()
37550: {
37550:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s", FULLFUNCTION));
37550: 
37550: #if defined(OS_WIN)
37550:     // Parent is letting us know something set focus to the plugin.
37550:     if (::GetFocus() == mPluginWindowHWND)
37550:         return true;
37550:     ::SetFocus(mPluginWindowHWND);
37550:     return true;
37550: #else
37550:     NS_NOTREACHED("PluginInstanceChild::AnswerSetPluginFocus not implemented!");
37550:     return false;
37550: #endif
37550: }
37550: 
37554: bool
37554: PluginInstanceChild::AnswerUpdateWindow()
37554: {
37554:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s", FULLFUNCTION));
37554: 
37554: #if defined(OS_WIN)
40218:     if (mPluginWindowHWND) {
40218:         RECT rect;
40218:         if (GetUpdateRect(GetParent(mPluginWindowHWND), &rect, FALSE)) {
40218:             ::InvalidateRect(mPluginWindowHWND, &rect, FALSE); 
40218:         }
37554:         UpdateWindow(mPluginWindowHWND);
40218:     }
37554:     return true;
37554: #else
37554:     NS_NOTREACHED("PluginInstanceChild::AnswerUpdateWindow not implemented!");
37554:     return false;
37554: #endif
37554: }
37554: 
35898: PPluginScriptableObjectChild*
35943: PluginInstanceChild::AllocPPluginScriptableObject()
35835: {
35971:     AssertPluginThread();
37311:     return new PluginScriptableObjectChild(Proxy);
35835: }
35835: 
35926: bool
35965: PluginInstanceChild::DeallocPPluginScriptableObject(
35965:     PPluginScriptableObjectChild* aObject)
35835: {
35971:     AssertPluginThread();
37477:     delete aObject;
35945:     return true;
35925: }
35890: 
35965: bool
38994: PluginInstanceChild::RecvPPluginScriptableObjectConstructor(
35965:                                            PPluginScriptableObjectChild* aActor)
35965: {
35971:     AssertPluginThread();
35971: 
35965:     // This is only called in response to the parent process requesting the
35965:     // creation of an actor. This actor will represent an NPObject that is
35965:     // created by the browser and returned to the plugin.
35965:     PluginScriptableObjectChild* actor =
35965:         static_cast<PluginScriptableObjectChild*>(aActor);
37311:     NS_ASSERTION(!actor->GetObject(false), "Actor already has an object?!");
37311: 
37311:     actor->InitializeProxy();
37311:     NS_ASSERTION(actor->GetObject(false), "Actor should have an object!");
35965: 
35965:     return true;
35965: }
35965: 
37126: bool
37126: PluginInstanceChild::AnswerPBrowserStreamConstructor(
37126:     PBrowserStreamChild* aActor,
37126:     const nsCString& url,
37126:     const uint32_t& length,
37126:     const uint32_t& lastmodified,
37126:     PStreamNotifyChild* notifyData,
37126:     const nsCString& headers,
37126:     const nsCString& mimeType,
37126:     const bool& seekable,
37126:     NPError* rv,
37126:     uint16_t* stype)
37126: {
37126:     AssertPluginThread();
37126:     *rv = static_cast<BrowserStreamChild*>(aActor)
39283:           ->StreamConstructed(mimeType, seekable, stype);
37126:     return true;
37126: }
37126: 
35898: PBrowserStreamChild*
35943: PluginInstanceChild::AllocPBrowserStream(const nsCString& url,
35893:                                          const uint32_t& length,
35890:                                          const uint32_t& lastmodified,
35990:                                          PStreamNotifyChild* notifyData,
35890:                                          const nsCString& headers,
35890:                                          const nsCString& mimeType,
35890:                                          const bool& seekable,
35893:                                          NPError* rv,
35893:                                          uint16_t *stype)
35890: {
35971:     AssertPluginThread();
39283:     return new BrowserStreamChild(this, url, length, lastmodified,
39283:                                   static_cast<StreamNotifyChild*>(notifyData),
35949:                                   headers, mimeType, seekable, rv, stype);
35890: }
35890: 
35926: bool
36138: PluginInstanceChild::DeallocPBrowserStream(PBrowserStreamChild* stream)
35890: {
35971:     AssertPluginThread();
35890:     delete stream;
35926:     return true;
35890: }
35890: 
35938: PPluginStreamChild*
35943: PluginInstanceChild::AllocPPluginStream(const nsCString& mimeType,
35938:                                         const nsCString& target,
35938:                                         NPError* result)
35938: {
35938:     NS_RUNTIMEABORT("not callable");
35938:     return NULL;
35938: }
35938: 
35938: bool
36138: PluginInstanceChild::DeallocPPluginStream(PPluginStreamChild* stream)
35938: {
35971:     AssertPluginThread();
35938:     delete stream;
35938:     return true;
35938: }
35938: 
35904: PStreamNotifyChild*
35943: PluginInstanceChild::AllocPStreamNotify(const nsCString& url,
35904:                                         const nsCString& target,
35904:                                         const bool& post,
35904:                                         const nsCString& buffer,
35904:                                         const bool& file,
35904:                                         NPError* result)
35904: {
35971:     AssertPluginThread();
35904:     NS_RUNTIMEABORT("not reached");
35904:     return NULL;
35904: }
35904: 
39283: void
39283: StreamNotifyChild::ActorDestroy(ActorDestroyReason why)
35904: {
39283:     if (AncestorDeletion == why && mBrowserStream) {
39283:         NS_ERROR("Pending NPP_URLNotify not called when closing an instance.");
39283: 
39283:         // reclaim responsibility for deleting ourself
39284:         mBrowserStream->mStreamNotify = NULL;
39283:         mBrowserStream = NULL;
39283:     }
39283: }
39283: 
39283: 
39283: void
39283: StreamNotifyChild::SetAssociatedStream(BrowserStreamChild* bs)
39283: {
39283:     NS_ASSERTION(bs, "Shouldn't be null");
39283:     NS_ASSERTION(!mBrowserStream, "Two streams for one streamnotify?");
39283: 
39283:     mBrowserStream = bs;
36138: }
35971: 
36138: bool
39283: StreamNotifyChild::Recv__delete__(const NPReason& reason)
36138: {
39283:     AssertPluginThread();
39283: 
39283:     if (mBrowserStream)
39283:         mBrowserStream->NotifyPending();
39283:     else
39283:         NPP_URLNotify(reason);
39283: 
35926:     return true;
35904: }
35904: 
39283: void
39283: StreamNotifyChild::NPP_URLNotify(NPReason reason)
39283: {
39283:     PluginInstanceChild* instance = static_cast<PluginInstanceChild*>(Manager());
39283: 
39283:     if (mClosure)
39283:         instance->mPluginIface->urlnotify(instance->GetNPP(), mURL.get(),
39283:                                           reason, mClosure);
39283: }
39283: 
36110: bool
36138: PluginInstanceChild::DeallocPStreamNotify(PStreamNotifyChild* notifyData)
36110: {
36138:     AssertPluginThread();
39283: 
39283:     if (!static_cast<StreamNotifyChild*>(notifyData)->mBrowserStream)
36110:         delete notifyData;
36110:     return true;
36110: }
36110: 
35925: PluginScriptableObjectChild*
35945: PluginInstanceChild::GetActorForNPObject(NPObject* aObject)
35925: {
35971:     AssertPluginThread();
35925:     NS_ASSERTION(aObject, "Null pointer!");
35925: 
35965:     if (aObject->_class == PluginScriptableObjectChild::GetClass()) {
35965:         // One of ours! It's a browser-provided object.
35965:         ChildNPObject* object = static_cast<ChildNPObject*>(aObject);
35965:         NS_ASSERTION(object->parent, "Null actor!");
35965:         return object->parent;
35965:     }
35945: 
35925:     PluginScriptableObjectChild* actor =
35945:         PluginModuleChild::current()->GetActorForNPObject(aObject);
35945:     if (actor) {
35965:         // Plugin-provided object that we've previously wrapped.
35945:         return actor;
35945:     }
35945: 
37311:     actor = new PluginScriptableObjectChild(LocalObject);
38994:     if (!SendPPluginScriptableObjectConstructor(actor)) {
37311:         NS_ERROR("Failed to send constructor message!");
37311:         return nsnull;
37311:     }
35925: 
37311:     actor->InitializeLocal(aObject);
35925:     return actor;
35925: }
35938: 
35938: NPError
35938: PluginInstanceChild::NPN_NewStream(NPMIMEType aMIMEType, const char* aWindow,
35938:                                    NPStream** aStream)
35938: {
35971:     AssertPluginThread();
35971: 
36138:     PluginStreamChild* ps = new PluginStreamChild();
35938: 
35938:     NPError result;
35938:     CallPPluginStreamConstructor(ps, nsDependentCString(aMIMEType),
35944:                                  NullableString(aWindow), &result);
35938:     if (NPERR_NO_ERROR != result) {
35938:         *aStream = NULL;
36138:         PPluginStreamChild::Call__delete__(ps, NPERR_GENERIC_ERROR, true);
35938:         return result;
35938:     }
35938: 
35938:     *aStream = &ps->mStream;
35938:     return NPERR_NO_ERROR;
35938: }
36082: 
36835: void
36835: PluginInstanceChild::InvalidateRect(NPRect* aInvalidRect)
36082: {
36082:     NS_ASSERTION(aInvalidRect, "Null pointer!");
36082: 
36082: #ifdef OS_WIN
36124:     // Invalidate and draw locally for windowed plugins.
36124:     if (mWindow.type == NPWindowTypeWindow) {
36082:       NS_ASSERTION(IsWindow(mPluginWindowHWND), "Bad window?!");
36082:       RECT rect = { aInvalidRect->left, aInvalidRect->top,
36082:                     aInvalidRect->right, aInvalidRect->bottom };
36836:       ::InvalidateRect(mPluginWindowHWND, &rect, FALSE);
36835:       return;
36124:     }
36082: #endif
36083: 
36835:     SendNPN_InvalidateRect(*aInvalidRect);
36082: }
37311: 
37348: uint32_t
37348: PluginInstanceChild::ScheduleTimer(uint32_t interval, bool repeat,
37348:                                    TimerFunc func)
37348: {
37348:     ChildTimer* t = new ChildTimer(this, interval, repeat, func);
37348:     if (0 == t->ID()) {
37348:         delete t;
37348:         return 0;
37348:     }
37348: 
37348:     mTimers.AppendElement(t);
37348:     return t->ID();
37348: }
37348: 
37348: void
37348: PluginInstanceChild::UnscheduleTimer(uint32_t id)
37348: {
37348:     if (0 == id)
37348:         return;
37348: 
37884:     mTimers.RemoveElement(id, ChildTimer::IDComparator());
37348: }
37348: 
39979: void
39979: PluginInstanceChild::AsyncCall(PluginThreadCallback aFunc, void* aUserData)
39979: {
39979:     ChildAsyncCall* task = new ChildAsyncCall(this, aFunc, aUserData);
39979: 
39979:     {
39979:         MutexAutoLock lock(mAsyncCallMutex);
39979:         mPendingAsyncCalls.AppendElement(task);
39979:     }
39979:     PluginThreadChild::current()->message_loop()->PostTask(FROM_HERE, task);
39979: }
39979: 
38669: static PLDHashOperator
38669: InvalidateObject(DeletingObjectEntry* e, void* userArg)
38669: {
38669:     NPObject* o = e->GetKey();
38669:     if (!e->mDeleted && o->_class && o->_class->invalidate)
38669:         o->_class->invalidate(o);
38669: 
38669:     return PL_DHASH_NEXT;
38669: }
38669: 
38669: static PLDHashOperator
38669: DeleteObject(DeletingObjectEntry* e, void* userArg)
38669: {
38669:     NPObject* o = e->GetKey();
38669:     if (!e->mDeleted) {
38669:         e->mDeleted = true;
38669: 
38669: #ifdef NS_BUILD_REFCNT_LOGGING
38669:         {
38669:             int32_t refcnt = o->referenceCount;
38669:             while (refcnt) {
38669:                 --refcnt;
38669:                 NS_LOG_RELEASE(o, refcnt, "NPObject");
38669:             }
38669:         }
38669: #endif
38669: 
38669:         PluginModuleChild::DeallocNPObject(o);
38669:     }
38669: 
38669:     return PL_DHASH_NEXT;
38669: }
38669: 
37311: bool
37311: PluginInstanceChild::AnswerNPP_Destroy(NPError* aResult)
37311: {
38669:     PLUGIN_LOG_DEBUG_METHOD;
38669:     AssertPluginThread();
38669: 
39283:     nsTArray<PBrowserStreamChild*> streams;
39283:     ManagedPBrowserStreamChild(streams);
39283: 
39283:     // First make sure none of these streams become deleted
39283:     for (PRUint32 i = 0; i < streams.Length(); ) {
39283:         if (static_cast<BrowserStreamChild*>(streams[i])->InstanceDying())
39283:             ++i;
39283:         else
39283:             streams.RemoveElementAt(i);
39283:     }
39283:     for (PRUint32 i = 0; i < streams.Length(); ++i)
39283:         static_cast<BrowserStreamChild*>(streams[i])->FinishDelivery();
39283: 
39979:     {
39979:         MutexAutoLock lock(mAsyncCallMutex);
37348:         for (PRUint32 i = 0; i < mPendingAsyncCalls.Length(); ++i)
37348:             mPendingAsyncCalls[i]->Cancel();
37348:         mPendingAsyncCalls.TruncateLength(0);
39979:     }
37348: 
37884:     mTimers.Clear();
37348: 
38669:     PluginModuleChild::current()->NPP_Destroy(this);
38669:     mData.ndata = 0;
38669: 
38669:     mDeletingHash = new nsTHashtable<DeletingObjectEntry>;
38669:     mDeletingHash->Init();
38669:     PluginModuleChild::current()->FindNPObjectsForInstance(this);
38669: 
38669:     mDeletingHash->EnumerateEntries(InvalidateObject, NULL);
38669:     mDeletingHash->EnumerateEntries(DeleteObject, NULL);
37311: 
38354:     // Null out our cached actors as they should have been killed in the
38354:     // PluginInstanceDestroyed call above.
38354:     mCachedWindowActor = nsnull;
38354:     mCachedElementActor = nsnull;
38354: 
37311: #if defined(OS_WIN)
37311:     SharedSurfaceRelease();
39729:     DestroyWinlessPopupSurrogate();
41997:     UnhookWinlessFlashThrottle();
37311: #endif
37311: 
38669:     return true;
37311: }
