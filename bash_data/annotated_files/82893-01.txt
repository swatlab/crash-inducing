29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JavaScript iterators.
    1:  */
    1: #include <string.h>     /* for memcpy */
80468: 
80468: #include "mozilla/Util.h"
80468: 
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsutil.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsexn.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
68933: #include "jsgcmark.h"
    1: #include "jsinterp.h"
    1: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
42733: #include "jsproxy.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
80506: #include "frontend/TokenStream.h"
75062: #include "vm/GlobalObject.h"
75062: 
77343: #include "jsinferinlines.h"
40858: #include "jsobjinlines.h"
40858: 
69223: #include "vm/Stack-inl.h"
72107: #include "vm/String-inl.h"
69223: 
80468: using namespace mozilla;
37741: using namespace js;
54707: using namespace js::gc;
37741: 
42641: static void iterator_finalize(JSContext *cx, JSObject *obj);
42641: static void iterator_trace(JSTracer *trc, JSObject *obj);
42641: static JSObject *iterator_iterator(JSContext *cx, JSObject *obj, JSBool keysonly);
    1: 
77817: Class js::IteratorClass = {
48622:     "Iterator",
68896:     JSCLASS_HAS_PRIVATE |
68896:     JSCLASS_CONCURRENT_FINALIZER |
68896:     JSCLASS_HAS_CACHED_PROTO(JSProto_Iterator),
78614:     JS_PropertyStub,         /* addProperty */
78614:     JS_PropertyStub,         /* delProperty */
78614:     JS_PropertyStub,         /* getProperty */
78614:     JS_StrictPropertyStub,   /* setProperty */
78614:     JS_EnumerateStub,
78614:     JS_ResolveStub,
78614:     JS_ConvertStub,
48622:     iterator_finalize,
48622:     NULL,                    /* reserved    */
48622:     NULL,                    /* checkAccess */
48622:     NULL,                    /* call        */
48622:     NULL,                    /* construct   */
48622:     NULL,                    /* xdrObject   */
48622:     NULL,                    /* hasInstance */
64218:     iterator_trace,
48622:     {
48622:         NULL,                /* equality       */
48622:         NULL,                /* outerObject    */
48622:         NULL,                /* innerObject    */
48622:         iterator_iterator,   
56565:         NULL                 /* unused  */
48622:     }
42641: };
 3436: 
42641: void
42641: NativeIterator::mark(JSTracer *trc)
42641: {
61055:     MarkIdRange(trc, begin(), end(), "props");
48470:     if (obj)
82129:         MarkObject(trc, obj, "obj");
42641: }
 3436: 
40857: static void
40857: iterator_finalize(JSContext *cx, JSObject *obj)
40857: {
77817:     JS_ASSERT(obj->isIterator());
42641: 
42641:     NativeIterator *ni = obj->getNativeIterator();
42641:     if (ni) {
82129:         obj->setPrivate(NULL);
64560:         cx->free_(ni);
42641:     }
40857: }
40857: 
40857: static void
33128: iterator_trace(JSTracer *trc, JSObject *obj)
33128: {
42641:     NativeIterator *ni = obj->getNativeIterator();
42641: 
42641:     if (ni)
42641:         ni->mark(trc);
33128: }
33128: 
48470: struct IdHashPolicy {
48470:     typedef jsid Lookup;
48470:     static HashNumber hash(jsid id) {
48470:         return JSID_BITS(id);
48470:     }
48470:     static bool match(jsid id1, jsid id2) {
48470:         return id1 == id2;
48470:     }
48470: };
48470: 
72091: typedef HashSet<jsid, IdHashPolicy> IdSet;
48470: 
48470: static inline bool
48470: NewKeyValuePair(JSContext *cx, jsid id, const Value &val, Value *rval)
42641: {
48470:     Value vec[2] = { IdToValue(id), val };
80468:     AutoArrayRooter tvr(cx, ArrayLength(vec), vec);
    1: 
59234:     JSObject *aobj = NewDenseCopiedArray(cx, 2, vec);
42641:     if (!aobj)
42641:         return false;
48470:     rval->setObject(*aobj);
42641:     return true;
42641: }
42641: 
42641: static inline bool
42691: Enumerate(JSContext *cx, JSObject *obj, JSObject *pobj, jsid id,
72089:           bool enumerable, uintN flags, IdSet& ht, AutoIdVector *props)
    1: {
72089:     JS_ASSERT_IF(flags & JSITER_OWNONLY, obj == pobj);
72089: 
79933:     /*
79933:      * We implement __proto__ using a property on |Object.prototype|, but
79933:      * because __proto__ is highly deserving of removal, we don't want it to
79933:      * show up in property enumeration, even if only for |Object.prototype|
79933:      * (think introspection by Prototype-like frameworks that add methods to
79933:      * the built-in prototypes).  So exclude __proto__ if the object where the
79933:      * property was found has no [[Prototype]] and might be |Object.prototype|.
79933:      */
79933:     if (JS_UNLIKELY(!pobj->getProto() && JSID_IS_ATOM(id, cx->runtime->atomState.protoAtom)))
79933:         return true;
79933: 
72560:     if (!(flags & JSITER_OWNONLY) || pobj->isProxy() || pobj->getOps()->enumerate) {
72560:         /* If we've already seen this, we definitely won't add it. */
48470:         IdSet::AddPtr p = ht.lookupForAdd(id);
42641:         if (JS_UNLIKELY(!!p))
42641:             return true;
47569: 
47569:         /*
72089:          * It's not necessary to add properties to the hash table at the end of
72560:          * the prototype chain, but custom enumeration behaviors might return
72560:          * duplicated properties, so always add in such cases.
47569:          */
72560:         if ((pobj->getProto() || pobj->isProxy() || pobj->getOps()->enumerate) && !ht.add(p, id))
42641:             return false;
42641:     }
47569: 
48470:     if (enumerable || (flags & JSITER_HIDDEN))
61055:         return props->append(id);
48470: 
42641:     return true;
42641: }
42641: 
42641: static bool
48470: EnumerateNativeProperties(JSContext *cx, JSObject *obj, JSObject *pobj, uintN flags, IdSet &ht,
61055:                           AutoIdVector *props)
42641: {
54562:     size_t initialLength = props->length();
42641: 
42641:     /* Collect all unique properties from this object's scope. */
52503:     for (Shape::Range r = pobj->lastProperty()->all(); !r.empty(); r.popFront()) {
52503:         const Shape &shape = r.front();
52503: 
69637:         if (!JSID_IS_DEFAULT_XML_NAMESPACE(shape.propid) &&
72089:             !Enumerate(cx, obj, pobj, shape.propid, shape.enumerable(), flags, ht, props))
47569:         {
42641:             return false;
42641:         }
42641:     }
42641: 
64335:     ::Reverse(props->begin() + initialLength, props->end());
42641:     return true;
42641: }
42641: 
42641: static bool
42691: EnumerateDenseArrayProperties(JSContext *cx, JSObject *obj, JSObject *pobj, uintN flags,
61055:                               IdSet &ht, AutoIdVector *props)
42641: {
72089:     if (!Enumerate(cx, obj, pobj, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom), false,
47569:                    flags, ht, props)) {
47569:         return false;
47569:     }
42641: 
48537:     if (pobj->getArrayLength() > 0) {
77343:         size_t initlen = pobj->getDenseArrayInitializedLength();
74457:         const Value *vp = pobj->getDenseArrayElements();
77343:         for (size_t i = 0; i < initlen; ++i, ++vp) {
48470:             if (!vp->isMagic(JS_ARRAY_HOLE)) {
42641:                 /* Dense arrays never get so large that i would not fit into an integer id. */
72089:                 if (!Enumerate(cx, obj, pobj, INT_TO_JSID(i), true, flags, ht, props))
42641:                     return false;
42641:             }
42641:         }
42641:     }
47569: 
42641:     return true;
42641: }
42641: 
47459: static bool
61055: Snapshot(JSContext *cx, JSObject *obj, uintN flags, AutoIdVector *props)
42641: {
48470:     IdSet ht(cx);
47569:     if (!ht.init(32))
48470:         return NULL;
42641: 
42691:     JSObject *pobj = obj;
47459:     do {
48470:         Class *clasp = pobj->getClass();
42691:         if (pobj->isNative() &&
48622:             !pobj->getOps()->enumerate &&
42641:             !(clasp->flags & JSCLASS_NEW_ENUMERATE)) {
42691:             if (!clasp->enumerate(cx, pobj))
47459:                 return false;
61055:             if (!EnumerateNativeProperties(cx, obj, pobj, flags, ht, props))
47459:                 return false;
42691:         } else if (pobj->isDenseArray()) {
61055:             if (!EnumerateDenseArrayProperties(cx, obj, pobj, flags, ht, props))
47459:                 return false;
42641:         } else {
42733:             if (pobj->isProxy()) {
48470:                 AutoIdVector proxyProps(cx);
42733:                 if (flags & JSITER_OWNONLY) {
61423:                     if (flags & JSITER_HIDDEN) {
79386:                         if (!Proxy::getOwnPropertyNames(cx, pobj, proxyProps))
61423:                             return false;
61423:                     } else {
79386:                         if (!Proxy::keys(cx, pobj, proxyProps))
47459:                             return false;
61423:                     }
42733:                 } else {
79386:                     if (!Proxy::enumerate(cx, pobj, proxyProps))
47459:                         return false;
42733:                 }
47460:                 for (size_t n = 0, len = proxyProps.length(); n < len; n++) {
72089:                     if (!Enumerate(cx, obj, pobj, proxyProps[n], true, flags, ht, props))
47459:                         return false;
42733:                 }
42733:                 /* Proxy objects enumerate the prototype on their own, so we are done here. */
42733:                 break;
42733:             }
48470:             Value state;
47569:             JSIterateOp op = (flags & JSITER_HIDDEN) ? JSENUMERATE_INIT_ALL : JSENUMERATE_INIT;
47569:             if (!pobj->enumerate(cx, op, &state, NULL))
47459:                 return false;
48470:             if (state.isMagic(JS_NATIVE_ENUMERATE)) {
61055:                 if (!EnumerateNativeProperties(cx, obj, pobj, flags, ht, props))
47459:                     return false;
42641:             } else {
42641:                 while (true) {
42641:                     jsid id;
42691:                     if (!pobj->enumerate(cx, JSENUMERATE_NEXT, &state, &id))
47459:                         return false;
48470:                     if (state.isNull())
42641:                         break;
72089:                     if (!Enumerate(cx, obj, pobj, id, true, flags, ht, props))
47459:                         return false;
42641:                 }
42641:             }
42641:         }
    1: 
72089:         if ((flags & JSITER_OWNONLY) || pobj->isXML())
42641:             break;
47459:     } while ((pobj = pobj->getProto()) != NULL);
    1: 
47459:     return true;
42641: }
42641: 
42641: bool
79734: js::VectorToIdArray(JSContext *cx, AutoIdVector &props, JSIdArray **idap)
42641: {
47459:     JS_STATIC_ASSERT(sizeof(JSIdArray) > sizeof(jsid));
47459:     size_t len = props.length();
47459:     size_t idsz = len * sizeof(jsid);
47459:     size_t sz = (sizeof(JSIdArray) - sizeof(jsid)) + idsz;
64560:     JSIdArray *ida = static_cast<JSIdArray *>(cx->malloc_(sz));
47459:     if (!ida)
47459:         return false;
47459: 
47459:     ida->length = static_cast<jsint>(len);
82129:     jsid *v = props.begin();
82129:     for (jsint i = 0; i < ida->length; i++)
82129:         ida->vector[i].init(v[i]);
42641:     *idap = ida;
42641:     return true;
42641: }
42641: 
55632: JS_FRIEND_API(bool)
79734: js::GetPropertyNames(JSContext *cx, JSObject *obj, uintN flags, AutoIdVector *props)
42733: {
61055:     return Snapshot(cx, obj, flags & (JSITER_OWNONLY | JSITER_HIDDEN), props);
42733: }
42733: 
74914: size_t sCustomIteratorCount = 0;
74914: 
42641: static inline bool
48470: GetCustomIterator(JSContext *cx, JSObject *obj, uintN flags, Value *vp)
42641: {
82893:     JS_CHECK_RECURSION(cx, return false);
82893: 
42641:     /* Check whether we have a valid __iterator__ method. */
42641:     JSAtom *atom = cx->runtime->atomState.iteratorAtom;
42641:     if (!js_GetMethod(cx, obj, ATOM_TO_JSID(atom), JSGET_NO_METHOD_BARRIER, vp))
42641:         return false;
42641: 
42641:     /* If there is no custom __iterator__ method, we are done here. */
60775:     if (!vp->isObject()) {
60775:         vp->setUndefined();
42641:         return true;
60775:     }
42641: 
74914:     if (!cx->runningWithTrustedPrincipals())
74914:         ++sCustomIteratorCount;
74914: 
42641:     /* Otherwise call it and return that object. */
48470:     Value arg = BooleanValue((flags & JSITER_FOREACH) == 0);
76829:     if (!Invoke(cx, ObjectValue(*obj), *vp, 1, &arg, vp))
42641:         return false;
48470:     if (vp->isPrimitive()) {
43211:         /*
43211:          * We are always coming from js_ValueToIterator, and we are no longer on
43211:          * trace, so the object we are iterating over is on top of the stack (-1).
43211:          */
57812:         JSAutoByteString bytes;
57812:         if (!js_AtomToPrintableString(cx, atom, &bytes))
57812:             return false;
43211:         js_ReportValueError2(cx, JSMSG_BAD_TRAP_RETURN_VALUE,
57812:                              -1, ObjectValue(*obj), NULL, bytes.ptr());
42641:         return false;
42641:     }
42641:     return true;
42641: }
42641: 
42641: template <typename T>
42641: static inline bool
42641: Compare(T *a, T *b, size_t c)
42641: {
42641:     size_t n = (c + size_t(7)) / size_t(8);
42641:     switch (c % 8) {
42641:       case 0: do { if (*a++ != *b++) return false;
42641:       case 7:      if (*a++ != *b++) return false;
42641:       case 6:      if (*a++ != *b++) return false;
42641:       case 5:      if (*a++ != *b++) return false;
42641:       case 4:      if (*a++ != *b++) return false;
42641:       case 3:      if (*a++ != *b++) return false;
42641:       case 2:      if (*a++ != *b++) return false;
42641:       case 1:      if (*a++ != *b++) return false;
42641:               } while (--n > 0);
42641:     }
42641:     return true;
42641: }
42641: 
47497: static inline JSObject *
43190: NewIteratorObject(JSContext *cx, uintN flags)
43190: {
47497:     if (flags & JSITER_ENUMERATE) {
47497:         /*
47497:          * Non-escaping native enumerator objects do not need map, proto, or
47497:          * parent. However, code in jstracer.cpp and elsewhere may find such a
47497:          * native enumerator object via the stack and (as for all objects that
47497:          * are not stillborn, with the exception of "NoSuchMethod" internal
47497:          * helper objects) expect it to have a non-null map pointer, so we
47497:          * share an empty Enumerator scope in the runtime.
47497:          */
55746:         JSObject *obj = js_NewGCObject(cx, FINALIZE_OBJECT0);
47497:         if (!obj)
68902:             return NULL;
64242: 
64242:         EmptyShape *emptyEnumeratorShape = EmptyShape::getEmptyEnumeratorShape(cx);
64242:         if (!emptyEnumeratorShape)
64242:             return NULL;
77817:         obj->init(cx, &IteratorClass, &types::emptyTypeObject, NULL, NULL, false);
64242:         obj->setMap(emptyEnumeratorShape);
47497:         return obj;
47497:     }
47497: 
77817:     return NewBuiltinClassInstance(cx, &IteratorClass);
43190: }
43190: 
48470: NativeIterator *
61055: NativeIterator::allocateIterator(JSContext *cx, uint32 slength, const AutoIdVector &props)
48470: {
48470:     size_t plength = props.length();
48470:     NativeIterator *ni = (NativeIterator *)
64560:         cx->malloc_(sizeof(NativeIterator) + plength * sizeof(jsid) + slength * sizeof(uint32));
48470:     if (!ni)
48470:         return NULL;
82129:     ni->props_array = ni->props_cursor = (HeapId *) (ni + 1);
82129:     ni->props_end = ni->props_array + plength;
82129:     if (plength) {
82129:         for (size_t i = 0; i < plength; i++)
82129:             ni->props_array[i].init(props[i]);
82129:     }
48470:     return ni;
48470: }
48470: 
48470: inline void
53404: NativeIterator::init(JSObject *obj, uintN flags, uint32 slength, uint32 key)
48470: {
82129:     this->obj.init(obj);
48470:     this->flags = flags;
48470:     this->shapes_array = (uint32 *) this->props_end;
48470:     this->shapes_length = slength;
48470:     this->shapes_key = key;
48470: }
48470: 
43281: static inline void
43281: RegisterEnumerator(JSContext *cx, JSObject *iterobj, NativeIterator *ni)
43281: {
43281:     /* Register non-escaping native enumerators (for-in) with the current context. */
43281:     if (ni->flags & JSITER_ENUMERATE) {
43281:         ni->next = cx->enumerators;
43281:         cx->enumerators = iterobj;
53519: 
53519:         JS_ASSERT(!(ni->flags & JSITER_ACTIVE));
62413:         ni->flags |= JSITER_ACTIVE;
43281:     }
43281: }
43281: 
48470: static inline bool
48470: VectorToKeyIterator(JSContext *cx, JSObject *obj, uintN flags, AutoIdVector &keys,
53404:                     uint32 slength, uint32 key, Value *vp)
43190: {
48470:     JS_ASSERT(!(flags & JSITER_FOREACH));
48470: 
77361:     if (obj) {
77361:         obj->flags |= JSObject::ITERATED;
77353:         types::MarkTypeObjectFlags(cx, obj, types::OBJECT_FLAG_ITERATED);
77361:     }
77343: 
43190:     JSObject *iterobj = NewIteratorObject(cx, flags);
43190:     if (!iterobj)
43190:         return false;
43190: 
61055:     NativeIterator *ni = NativeIterator::allocateIterator(cx, slength, keys);
43190:     if (!ni)
53404:         return false;
53404:     ni->init(obj, flags, slength, key);
53404: 
53404:     if (slength) {
53404:         /*
53404:          * Fill in the shape array from scratch.  We can't use the array that was
53404:          * computed for the cache lookup earlier, as constructing iterobj could
53404:          * have triggered a shape-regenerating GC.  Don't bother with regenerating
53404:          * the shape key; if such a GC *does* occur, we can only get hits through
53404:          * the one-slot lastNativeIterator cache.
53404:          */
53404:         JSObject *pobj = obj;
53404:         size_t ind = 0;
53404:         do {
53404:             ni->shapes_array[ind++] = pobj->shape();
53404:             pobj = pobj->getProto();
53404:         } while (pobj);
53404:         JS_ASSERT(ind == slength);
53404:     }
47525: 
43190:     iterobj->setNativeIterator(ni);
48470:     vp->setObject(*iterobj);
43281: 
43281:     RegisterEnumerator(cx, iterobj, ni);
43190:     return true;
43190: }
43190: 
55632: namespace js {
55632: 
43190: bool
48470: VectorToKeyIterator(JSContext *cx, JSObject *obj, uintN flags, AutoIdVector &props, Value *vp)
48470: {
53404:     return VectorToKeyIterator(cx, obj, flags, props, 0, 0, vp);
48470: }
48470: 
53404: bool
61055: VectorToValueIterator(JSContext *cx, JSObject *obj, uintN flags, AutoIdVector &keys,
53404:                       Value *vp)
48470: {
48470:     JS_ASSERT(flags & JSITER_FOREACH);
48470: 
77361:     if (obj) {
77361:         obj->flags |= JSObject::ITERATED;
77353:         types::MarkTypeObjectFlags(cx, obj, types::OBJECT_FLAG_ITERATED);
77361:     }
77343: 
48470:     JSObject *iterobj = NewIteratorObject(cx, flags);
48470:     if (!iterobj)
48470:         return false;
48470: 
61055:     NativeIterator *ni = NativeIterator::allocateIterator(cx, 0, keys);
48470:     if (!ni)
53404:         return false;
53404:     ni->init(obj, flags, 0, 0);
48470: 
48470:     iterobj->setNativeIterator(ni);
48470:     vp->setObject(*iterobj);
48470: 
48470:     RegisterEnumerator(cx, iterobj, ni);
48470:     return true;
48470: }
48470: 
48470: bool
48470: EnumeratedIdVectorToIterator(JSContext *cx, JSObject *obj, uintN flags, AutoIdVector &props, Value *vp)
48470: {
48470:     if (!(flags & JSITER_FOREACH))
48470:         return VectorToKeyIterator(cx, obj, flags, props, vp);
48470: 
61055:     return VectorToValueIterator(cx, obj, flags, props, vp);
48470: }
48470: 
59250: static inline void
59250: UpdateNativeIterator(NativeIterator *ni, JSObject *obj)
59250: {
59250:     // Update the object for which the native iterator is associated, so
59250:     // SuppressDeletedPropertyHelper will recognize the iterator as a match.
59250:     ni->obj = obj;
59250: }
59250: 
48470: bool
48470: GetIterator(JSContext *cx, JSObject *obj, uintN flags, Value *vp)
42641: {
42641:     Vector<uint32, 8> shapes(cx);
42641:     uint32 key = 0;
42641: 
42641:     bool keysOnly = (flags == JSITER_ENUMERATE);
42641: 
42641:     if (obj) {
56574:         /* Enumerate Iterator.prototype directly. */
80307:         if (JSIteratorOp op = obj->getClass()->ext.iteratorObject) {
56574:             JSObject *iterobj = op(cx, obj, !(flags & JSITER_FOREACH));
56574:             if (!iterobj)
56574:                 return false;
56574:             vp->setObject(*iterobj);
77399:             types::MarkIteratorUnknown(cx);
56574:             return true;
56574:         }
56574: 
42641:         if (keysOnly) {
    1:             /*
53404:              * Check to see if this is the same as the most recent object which
53404:              * was iterated over.  We don't explicitly check for shapeless
53404:              * objects here, as they are not inserted into the cache and
53404:              * will result in a miss.
53404:              */
59954:             JSObject *last = cx->compartment->nativeIterCache.last;
53404:             JSObject *proto = obj->getProto();
53404:             if (last) {
53404:                 NativeIterator *lastni = last->getNativeIterator();
62573:                 if (!(lastni->flags & (JSITER_ACTIVE|JSITER_UNREUSABLE)) &&
53531:                     obj->isNative() &&
53531:                     obj->shape() == lastni->shapes_array[0] &&
53531:                     proto && proto->isNative() &&
53531:                     proto->shape() == lastni->shapes_array[1] &&
53404:                     !proto->getProto()) {
53404:                     vp->setObject(*last);
59250:                     UpdateNativeIterator(lastni, obj);
53404:                     RegisterEnumerator(cx, last, lastni);
53404:                     return true;
53404:                 }
53404:             }
53404: 
53404:             /*
42641:              * The iterator object for JSITER_ENUMERATE never escapes, so we
42641:              * don't care for the proper parent/proto to be set. This also
53404:              * allows us to re-use a previous iterator object that is not
53404:              * currently active.
    1:              */
42641:             JSObject *pobj = obj;
42641:             do {
42641:                 if (!pobj->isNative() ||
48622:                     obj->getOps()->enumerate ||
42641:                     pobj->getClass()->enumerate != JS_EnumerateStub) {
42641:                     shapes.clear();
42641:                     goto miss;
    1:                 }
42641:                 uint32 shape = pobj->shape();
42641:                 key = (key + (key << 16)) ^ shape;
42641:                 if (!shapes.append(shape))
42641:                     return false;
42641:                 pobj = pobj->getProto();
42641:             } while (pobj);
42641: 
59954:             JSObject *iterobj = cx->compartment->nativeIterCache.get(key);
42641:             if (iterobj) {
43190:                 NativeIterator *ni = iterobj->getNativeIterator();
62573:                 if (!(ni->flags & (JSITER_ACTIVE|JSITER_UNREUSABLE)) &&
53404:                     ni->shapes_key == key &&
42641:                     ni->shapes_length == shapes.length() &&
42641:                     Compare(ni->shapes_array, shapes.begin(), ni->shapes_length)) {
48470:                     vp->setObject(*iterobj);
43281: 
59250:                     UpdateNativeIterator(ni, obj);
43281:                     RegisterEnumerator(cx, iterobj, ni);
53404:                     if (shapes.length() == 2)
59954:                         cx->compartment->nativeIterCache.last = iterobj;
42641:                     return true;
42641:                 }
42641:             }
42641:         }
42641: 
42641:       miss:
77399:         if (obj->isProxy()) {
77399:             types::MarkIteratorUnknown(cx);
79386:             return Proxy::iterate(cx, obj, flags, vp);
77399:         }
42641:         if (!GetCustomIterator(cx, obj, flags, vp))
42641:             return false;
77399:         if (!vp->isUndefined()) {
77399:             types::MarkIteratorUnknown(cx);
42641:             return true;
42641:         }
77399:     }
42641: 
48470:     /* NB: for (var p in null) succeeds by iterating over no properties. */
48470: 
61055:     AutoIdVector keys(cx);
48470:     if (flags & JSITER_FOREACH) {
61055:         if (JS_LIKELY(obj != NULL) && !Snapshot(cx, obj, flags, &keys))
42641:             return false;
53404:         JS_ASSERT(shapes.empty());
61055:         if (!VectorToValueIterator(cx, obj, flags, keys, vp))
53404:             return false;
53404:     } else {
61055:         if (JS_LIKELY(obj != NULL) && !Snapshot(cx, obj, flags, &keys))
47459:             return false;
53404:         if (!VectorToKeyIterator(cx, obj, flags, keys, shapes.length(), key, vp))
53404:             return false;
53404:     }
53404: 
53404:     JSObject *iterobj = &vp->toObject();
53404: 
53404:     /* Cache the iterator object if possible. */
59954:     if (shapes.length())
59954:         cx->compartment->nativeIterCache.set(key, iterobj);
53404: 
53404:     if (shapes.length() == 2)
59954:         cx->compartment->nativeIterCache.last = iterobj;
53404:     return true;
42641: }
42641: 
55632: }
55632: 
42641: static JSObject *
42641: iterator_iterator(JSContext *cx, JSObject *obj, JSBool keysonly)
42641: {
42641:     return obj;
    1: }
    1: 
    1: static JSBool
53557: Iterator(JSContext *cx, uintN argc, Value *vp)
    1: {
53557:     Value *argv = JS_ARGV(cx, vp);
53557:     bool keyonly = argc >= 2 ? js_ValueToBoolean(argv[1]) : false;
53557:     uintN flags = JSITER_OWNONLY | (keyonly ? 0 : (JSITER_FOREACH | JSITER_KEYVALUE));
53557:     *vp = argc >= 1 ? argv[0] : UndefinedValue();
53557:     return js_ValueToIterator(cx, flags, vp);
    1: }
    1: 
 6464: JSBool
 6464: js_ThrowStopIteration(JSContext *cx)
    1: {
48470:     Value v;
    1: 
    1:     JS_ASSERT(!JS_IsExceptionPending(cx));
38604:     if (js_FindClassObject(cx, NULL, JSProto_StopIteration, &v))
60211:         cx->setPendingException(v);
    1:     return JS_FALSE;
    1: }
    1: 
    1: static JSBool
48470: iterator_next(JSContext *cx, uintN argc, Value *vp)
    1: {
79387:     CallArgs args = CallArgsFromVp(argc, vp);
79389: 
79389:     bool ok;
79779:     JSObject *obj = NonGenericMethodGuard(cx, args, iterator_next, &IteratorClass, &ok);
67943:     if (!obj)
79389:         return ok;
    1: 
79387:     if (!js_IteratorMore(cx, obj, &args.rval()))
42641:         return false;
79389: 
79387:     if (!args.rval().toBoolean()) {
 6464:         js_ThrowStopIteration(cx);
42641:         return false;
    1:     }
79389: 
79387:     return js_IteratorNext(cx, obj, &args.rval());
    1: }
    1: 
 4127: #define JSPROP_ROPERM   (JSPROP_READONLY | JSPROP_PERMANENT)
 4127: 
    1: static JSFunctionSpec iterator_methods[] = {
16519:     JS_FN(js_next_str,      iterator_next,  0,JSPROP_ROPERM),
 4127:     JS_FS_END
    1: };
    1: 
    1: /*
    1:  * Call ToObject(v).__iterator__(keyonly) if ToObject(v).__iterator__ exists.
11835:  * Otherwise construct the default iterator.
    1:  */
 9695: JS_FRIEND_API(JSBool)
48470: js_ValueToIterator(JSContext *cx, uintN flags, Value *vp)
    1: {
    1:     /* JSITER_KEYVALUE must always come with JSITER_FOREACH */
42641:     JS_ASSERT_IF(flags & JSITER_KEYVALUE, flags & JSITER_FOREACH);
42641: 
42641:     /*
42641:      * Make sure the more/next state machine doesn't get stuck. A value might be
42641:      * left in iterValue when a trace is left due to an operation time-out after
42641:      * JSOP_MOREITER but before the value is picked up by FOR*.
42641:      */
48470:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
    1: 
48470:     JSObject *obj;
48470:     if (vp->isObject()) {
40867:         /* Common case. */
48470:         obj = &vp->toObject();
    1:     } else {
    1:         /*
    1:          * Enumerating over null and undefined gives an empty enumerator.
    1:          * This is contrary to ECMA-262 9.9 ToObject, invoked from step 3 of
    1:          * the first production in 12.6.4 and step 4 of the second production,
40867:          * but it's "web JS" compatible. ES5 fixed for-in to match this de-facto
40867:          * standard.
    1:          */
    1:         if ((flags & JSITER_ENUMERATE)) {
48470:             if (!js_ValueToObjectOrNull(cx, *vp, &obj))
40395:                 return false;
56574:             /* fall through */
    1:         } else {
    1:             obj = js_ValueToNonNullObject(cx, *vp);
    1:             if (!obj)
40395:                 return false;
    1:         }
    1:     }
    1: 
42641:     return GetIterator(cx, obj, flags, vp);
 5899: }
    1: 
42641: #if JS_HAS_GENERATORS
42641: static JS_REQUIRES_STACK JSBool
42641: CloseGenerator(JSContext *cx, JSObject *genobj);
42641: #endif
    1: 
42641: JS_FRIEND_API(JSBool)
48470: js_CloseIterator(JSContext *cx, JSObject *obj)
 3025: {
48470:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
 3025: 
77817:     if (obj->isIterator()) {
43281:         /* Remove enumerators from the active list, which is a stack. */
43281:         NativeIterator *ni = obj->getNativeIterator();
53404: 
62413:         if (ni->flags & JSITER_ENUMERATE) {
43281:             JS_ASSERT(cx->enumerators == obj);
43281:             cx->enumerators = ni->next;
43281: 
53404:             JS_ASSERT(ni->flags & JSITER_ACTIVE);
53404:             ni->flags &= ~JSITER_ACTIVE;
53404: 
53519:             /*
53519:              * Reset the enumerator; it may still be in the cached iterators
53519:              * for this thread, and can be reused.
53519:              */
42641:             ni->props_cursor = ni->props_array;
42641:         }
 3025:     }
 3025: #if JS_HAS_GENERATORS
77817:     else if (obj->isGenerator()) {
42641:         return CloseGenerator(cx, obj);
 3025:     }
 3025: #endif
 3025:     return JS_TRUE;
 3025: }
 3025: 
43281: /*
55519:  * Suppress enumeration of deleted properties. This function must be called
55519:  * when a property is deleted and there might be active enumerators.
55519:  *
55519:  * We maintain a list of active non-escaping for-in enumerators. To suppress
55519:  * a property, we check whether each active enumerator contains the (obj, id)
55519:  * pair and has not yet enumerated |id|. If so, and |id| is the next property,
55519:  * we simply advance the cursor. Otherwise, we delete |id| from the list.
43281:  *
43281:  * We do not suppress enumeration of a property deleted along an object's
43281:  * prototype chain. Only direct deletions on the object are handled.
55519:  *
55519:  * This function can suppress multiple properties at once. The |predicate|
55519:  * argument is an object which can be called on an id and returns true or
55519:  * false. It also must have a method |matchesAtMostOne| which allows us to
55519:  * stop searching after the first deletion if true.
43281:  */
55519: template<typename IdPredicate>
55519: static bool
55519: SuppressDeletedPropertyHelper(JSContext *cx, JSObject *obj, IdPredicate predicate)
43281: {
43281:     JSObject *iterobj = cx->enumerators;
43281:     while (iterobj) {
47383:       again:
43281:         NativeIterator *ni = iterobj->getNativeIterator();
48470:         /* This only works for identified surpressed keys, not values. */
48470:         if (ni->isKeyIter() && ni->obj == obj && ni->props_cursor < ni->props_end) {
43281:             /* Check whether id is still to come. */
82129:             HeapId *props_cursor = ni->current();
82129:             HeapId *props_end = ni->end();
82129:             for (HeapId *idp = props_cursor; idp < props_end; ++idp) {
55519:                 if (predicate(*idp)) {
43281:                     /*
43281:                      * Check whether another property along the prototype chain
43281:                      * became visible as a result of this deletion.
43281:                      */
43281:                     if (obj->getProto()) {
43281:                         AutoObjectRooter proto(cx, obj->getProto());
43281:                         AutoObjectRooter obj2(cx);
43281:                         JSProperty *prop;
80442:                         if (!proto.object()->lookupGeneric(cx, *idp, obj2.addr(), &prop))
43281:                             return false;
43290:                         if (prop) {
43281:                             uintN attrs;
56567:                             if (obj2.object()->isNative())
52503:                                 attrs = ((Shape *) prop)->attributes();
80622:                             else if (!obj2.object()->getGenericAttributes(cx, *idp, &attrs))
43281:                                 return false;
56567: 
43281:                             if (attrs & JSPROP_ENUMERATE)
43281:                                 continue;
43281:                         }
43281:                     }
43281: 
43281:                     /*
47383:                      * If lookupProperty or getAttributes above removed a property from
47383:                      * ni, start over.
47383:                      */
47383:                     if (props_end != ni->props_end || props_cursor != ni->props_cursor)
47383:                         goto again;
47383: 
47383:                     /*
55519:                      * No property along the prototype chain stepped in to take the
43281:                      * property's place, so go ahead and delete id from the list.
43281:                      * If it is the next property to be enumerated, just skip it.
43281:                      */
47383:                     if (idp == props_cursor) {
61055:                         ni->incCursor();
43281:                     } else {
82129:                         for (HeapId *p = idp; p + 1 != props_end; p++)
82129:                             *p = *(p + 1);
61055:                         ni->props_end = ni->end() - 1;
43281:                     }
62573: 
62573:                     /* Don't reuse modified native iterators. */
62573:                     ni->flags |= JSITER_UNREUSABLE;
62573: 
55519:                     if (predicate.matchesAtMostOne())
43281:                         break;
43281:                 }
43281:             }
43281:         }
43281:         iterobj = ni->next;
43281:     }
43281:     return true;
43281: }
43281: 
55519: class SingleIdPredicate {
55519:     jsid id;
55519: public:
55519:     SingleIdPredicate(jsid id) : id(id) {}
55519: 
55519:     bool operator()(jsid id) { return id == this->id; }
55519:     bool matchesAtMostOne() { return true; }
55519: };
55519: 
55519: bool
55519: js_SuppressDeletedProperty(JSContext *cx, JSObject *obj, jsid id)
55519: {
59232:     id = js_CheckForStringIndex(id);
55519:     return SuppressDeletedPropertyHelper(cx, obj, SingleIdPredicate(id));
55519: }
55519: 
78344: bool
78344: js_SuppressDeletedElement(JSContext *cx, JSObject *obj, uint32 index)
78344: {
78344:     jsid id;
78344:     if (!IndexToId(cx, index, &id))
78344:         return false;
78344:     JS_ASSERT(id == js_CheckForStringIndex(id));
78344:     return SuppressDeletedPropertyHelper(cx, obj, SingleIdPredicate(id));
78344: }
78344: 
55519: class IndexRangePredicate {
79934:     uint32 begin, end;
79934: 
55519:   public:
79934:     IndexRangePredicate(uint32 begin, uint32 end) : begin(begin), end(end) {}
55519: 
55519:     bool operator()(jsid id) {
79934:         if (JSID_IS_INT(id)) {
79934:             jsint i = JSID_TO_INT(id);
79934:             return i > 0 && begin <= uint32(i) && uint32(i) < end;
55519:         }
79934: 
79934:         if (JS_LIKELY(JSID_IS_ATOM(id))) {
79934:             JSAtom *atom = JSID_TO_ATOM(id);
79934:             uint32 index;
79934:             return atom->isIndex(&index) && begin <= index && index < end;
79934:         }
79934: 
79934:         return false;
79934:     }
79934: 
55519:     bool matchesAtMostOne() { return false; }
55519: };
55519: 
55519: bool
79934: js_SuppressDeletedElements(JSContext *cx, JSObject *obj, uint32 begin, uint32 end)
55519: {
55519:     return SuppressDeletedPropertyHelper(cx, obj, IndexRangePredicate(begin, end));
55519: }
55519: 
42641: JSBool
48470: js_IteratorMore(JSContext *cx, JSObject *iterobj, Value *rval)
    1: {
42641:     /* Fast path for native iterators */
61055:     NativeIterator *ni = NULL;
77817:     if (iterobj->isIterator()) {
61055:         /* Key iterators are handled by fast-paths. */
61055:         ni = iterobj->getNativeIterator();
61055:         bool more = ni->props_cursor < ni->props_end;
61055:         if (ni->isKeyIter() || !more) {
61055:             rval->setBoolean(more);
42641:             return true;
    1:         }
61055:     }
    1: 
42641:     /* We might still have a pending value. */
48470:     if (!cx->iterValue.isMagic(JS_NO_ITER_VALUE)) {
48470:         rval->setBoolean(true);
42641:         return true;
    1:     }
    1: 
72108:     /* We're reentering below and can call anything. */
72108:     JS_CHECK_RECURSION(cx, return false);
72108: 
42641:     /* Fetch and cache the next value from the iterator. */
61055:     if (!ni) {
    1:         jsid id = ATOM_TO_JSID(cx->runtime->atomState.nextAtom);
48470:         if (!js_GetMethod(cx, iterobj, id, JSGET_METHOD_BARRIER, rval))
42641:             return false;
76829:         if (!Invoke(cx, ObjectValue(*iterobj), *rval, 0, NULL, rval)) {
    1:             /* Check for StopIteration. */
77817:             if (!cx->isExceptionPending() || !IsStopIteration(cx->getPendingException()))
42641:                 return false;
    1: 
60211:             cx->clearPendingException();
48470:             cx->iterValue.setMagic(JS_NO_ITER_VALUE);
48470:             rval->setBoolean(false);
42641:             return true;
    1:         }
61055:     } else {
61055:         JS_ASSERT(!ni->isKeyIter());
61055:         jsid id = *ni->current();
61055:         ni->incCursor();
78675:         if (!ni->obj->getGeneric(cx, id, rval))
61055:             return false;
61055:         if ((ni->flags & JSITER_KEYVALUE) && !NewKeyValuePair(cx, id, *rval, rval))
61055:             return false;
61055:     }
    1: 
42641:     /* Cache the value returned by iterobj.next() so js_IteratorNext() can find it. */
48470:     JS_ASSERT(!rval->isMagic(JS_NO_ITER_VALUE));
42641:     cx->iterValue = *rval;
48470:     rval->setBoolean(true);
42641:     return true;
42641: }
42641: 
42641: JSBool
48470: js_IteratorNext(JSContext *cx, JSObject *iterobj, Value *rval)
42641: {
42641:     /* Fast path for native iterators */
77817:     if (iterobj->isIterator()) {
42641:         /*
42641:          * Implement next directly as all the methods of the native iterator are
42641:          * read-only and permanent.
42641:          */
42641:         NativeIterator *ni = iterobj->getNativeIterator();
80307:         if (ni->isKeyIter()) {
60785:             JS_ASSERT(ni->props_cursor < ni->props_end);
61055:             *rval = IdToValue(*ni->current());
61055:             ni->incCursor();
42641: 
61055:             if (rval->isString())
42641:                 return true;
42641: 
42641:             JSString *str;
42641:             jsint i;
78537:             if (rval->isInt32() && StaticStrings::hasInt(i = rval->toInt32())) {
78537:                 str = cx->runtime->staticStrings.getInt(i);
42641:             } else {
42641:                 str = js_ValueToString(cx, *rval);
42641:                 if (!str)
42641:                     return false;
42641:             }
42641: 
48470:             rval->setString(str);
42641:             return true;
42641:         }
61055:     }
42641: 
48470:     JS_ASSERT(!cx->iterValue.isMagic(JS_NO_ITER_VALUE));
42641:     *rval = cx->iterValue;
48470:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
42641: 
42641:     return true;
    1: }
    1: 
    1: static JSBool
48470: stopiter_hasInstance(JSContext *cx, JSObject *obj, const Value *v, JSBool *bp)
    1: {
77817:     *bp = IsStopIteration(*v);
    1:     return JS_TRUE;
    1: }
    1: 
77817: Class js::StopIterationClass = {
    1:     js_StopIteration_str,
56574:     JSCLASS_HAS_CACHED_PROTO(JSProto_StopIteration) |
56576:     JSCLASS_FREEZE_PROTO,
78614:     JS_PropertyStub,         /* addProperty */
78614:     JS_PropertyStub,         /* delProperty */
78614:     JS_PropertyStub,         /* getProperty */
78614:     JS_StrictPropertyStub,   /* setProperty */
78614:     JS_EnumerateStub,
78614:     JS_ResolveStub,
78614:     JS_ConvertStub,
48622:     NULL,                    /* finalize    */
48622:     NULL,                    /* reserved0   */
48622:     NULL,                    /* checkAccess */
48622:     NULL,                    /* call        */
48622:     NULL,                    /* construct   */
48622:     NULL,                    /* xdrObject   */
48622:     stopiter_hasInstance
    1: };
    1: 
    1: #if JS_HAS_GENERATORS
    1: 
    1: static void
    1: generator_finalize(JSContext *cx, JSObject *obj)
    1: {
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
31452:     if (!gen)
31452:         return;
    1: 
    1:     /*
31452:      * gen is open when a script has not called its close method while
31452:      * explicitly manipulating it.
    1:      */
31452:     JS_ASSERT(gen->state == JSGEN_NEWBORN ||
31452:               gen->state == JSGEN_CLOSED ||
    1:               gen->state == JSGEN_OPEN);
64560:     cx->free_(gen);
    1: }
    1: 
  583: static void
82129: MarkGenerator(JSTracer *trc, JSGenerator *gen)
82129: {
82129:     StackFrame *fp = gen->floatingFrame();
82129: 
82129:     /*
82129:      * MarkGenerator should only be called when regs is based on the floating frame.
82129:      * See calls to RebaseRegsFromTo.
82129:      */
82129:     JS_ASSERT(size_t(gen->regs.sp - fp->slots()) <= fp->numSlots());
82129: 
82129:     /*
82129:      * Currently, generators are not mjitted. Still, (overflow) args can be
82129:      * pushed by the mjit and need to be conservatively marked. Technically, the
82129:      * formal args and generator slots are safe for exact marking, but since the
82129:      * plan is to eventually mjit generators, it makes sense to future-proof
82129:      * this code and save someone an hour later.
82129:      */
82129:     MarkStackRangeConservatively(trc, gen->floatingStack, fp->formalArgsEnd());
82129:     js_TraceStackFrame(trc, fp);
82129:     MarkStackRangeConservatively(trc, fp->slots(), gen->regs.sp);
82129: }
82129: 
82129: static void
82129: GeneratorWriteBarrierPre(JSContext *cx, JSGenerator *gen)
82129: {
82129:     JSCompartment *comp = cx->compartment;
82129:     if (comp->needsBarrier())
82129:         MarkGenerator(comp->barrierTracer(), gen);
82129: }
82129: 
82129: static void
  583: generator_trace(JSTracer *trc, JSObject *obj)
    1: {
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
 4282:     if (!gen)
 4282:         return;
 4282: 
    1:     /*
42714:      * Do not mark if the generator is running; the contents may be trash and
42714:      * will be replaced when the generator stops.
    1:      */
42714:     if (gen->state == JSGEN_RUNNING || gen->state == JSGEN_CLOSING)
42714:         return;
 4282: 
82129:     JS_ASSERT(gen->liveFrame() == gen->floatingFrame());
82129:     MarkGenerator(trc, gen);
    1: }
    1: 
77817: Class js::GeneratorClass = {
78098:     "Generator",
78098:     JSCLASS_HAS_PRIVATE,
78614:     JS_PropertyStub,         /* addProperty */
78614:     JS_PropertyStub,         /* delProperty */
78614:     JS_PropertyStub,         /* getProperty */
78614:     JS_StrictPropertyStub,   /* setProperty */
78614:     JS_EnumerateStub,
78614:     JS_ResolveStub,
78614:     JS_ConvertStub,
48622:     generator_finalize,
48622:     NULL,                    /* reserved    */
48622:     NULL,                    /* checkAccess */
48622:     NULL,                    /* call        */
48622:     NULL,                    /* construct   */
48622:     NULL,                    /* xdrObject   */
48622:     NULL,                    /* hasInstance */
64218:     generator_trace,
48622:     {
48622:         NULL,                /* equality       */
48622:         NULL,                /* outerObject    */
48622:         NULL,                /* innerObject    */
48622:         iterator_iterator,   
56565:         NULL                 /* unused */
48622:     }
    1: };
    1: 
    1: /*
    1:  * Called from the JSOP_GENERATOR case in the interpreter, with fp referring
    1:  * to the frame by which the generator function was activated.  Create a new
69223:  * JSGenerator object, which contains its own StackFrame that we populate
    1:  * from *fp.  We know that upon return, the JSOP_GENERATOR opcode will return
    1:  * from the activation in fp, so we can steal away fp->callobj and fp->argsobj
    1:  * if they are non-null.
    1:  */
37777: JS_REQUIRES_STACK JSObject *
37777: js_NewGenerator(JSContext *cx)
    1: {
71695:     FrameRegs &stackRegs = cx->regs();
71695:     StackFrame *stackfp = stackRegs.fp();
69223:     JS_ASSERT(stackfp->base() == cx->regs().sp);
53840:     JS_ASSERT(stackfp->actualArgs() <= stackfp->formalArgs());
53840: 
78098:     GlobalObject *global = stackfp->scopeChain().getGlobal();
78098:     JSObject *proto = global->getOrCreateGeneratorPrototype(cx);
78098:     if (!proto)
78098:         return NULL;
78098:     JSObject *obj = NewNonFunction<WithProto::Given>(cx, &GeneratorClass, proto, global);
78098:     if (!obj)
78098:         return NULL;
78098: 
    1:     /* Load and compute stack slot counts. */
53840:     Value *stackvp = stackfp->actualArgs() - 2;
53840:     uintN vplen = stackfp->formalArgsEnd() - stackvp;
    1: 
42714:     /* Compute JSGenerator size. */
42714:     uintN nbytes = sizeof(JSGenerator) +
48470:                    (-1 + /* one Value included in JSGenerator */
42714:                     vplen +
42714:                     VALUES_PER_STACK_FRAME +
53840:                     stackfp->numSlots()) * sizeof(Value);
42714: 
64560:     JSGenerator *gen = (JSGenerator *) cx->malloc_(nbytes);
    1:     if (!gen)
31452:         return NULL;
    1: 
42714:     /* Cut up floatingStack space. */
53840:     Value *genvp = gen->floatingStack;
69223:     StackFrame *genfp = reinterpret_cast<StackFrame *>(genvp + vplen);
42714: 
42714:     /* Initialize JSGenerator. */
82129:     gen->obj.init(obj);
42714:     gen->state = JSGEN_NEWBORN;
43281:     gen->enumerators = NULL;
53840:     gen->floating = genfp;
42708: 
71695:     /* Copy from the stack to the generator's floating frame. */
71697:     gen->regs.rebaseFromTo(stackRegs, *genfp);
71695:     genfp->stealFrameAndSlots(genvp, stackfp, stackvp, stackRegs.sp);
53840:     genfp->initFloatingGenerator();
    1: 
31452:     obj->setPrivate(gen);
    1:     return obj;
    1: }
    1: 
42714: JSGenerator *
69223: js_FloatingFrameToGenerator(StackFrame *fp)
42714: {
53840:     JS_ASSERT(fp->isGeneratorFrame() && fp->isFloatingGenerator());
53840:     char *floatingStackp = (char *)(fp->actualArgs() - 2);
42714:     char *p = floatingStackp - offsetof(JSGenerator, floatingStack);
42714:     return reinterpret_cast<JSGenerator *>(p);
42714: }
42714: 
    1: typedef enum JSGeneratorOp {
    1:     JSGENOP_NEXT,
    1:     JSGENOP_SEND,
    1:     JSGENOP_THROW,
    1:     JSGENOP_CLOSE
    1: } JSGeneratorOp;
    1: 
    1: /*
    1:  * Start newborn or restart yielding generator and perform the requested
    1:  * operation inside its frame.
    1:  */
24499: static JS_REQUIRES_STACK JSBool
    1: SendToGenerator(JSContext *cx, JSGeneratorOp op, JSObject *obj,
48470:                 JSGenerator *gen, const Value &arg)
    1: {
 3554:     if (gen->state == JSGEN_RUNNING || gen->state == JSGEN_CLOSING) {
 3554:         js_ReportValueError(cx, JSMSG_NESTING_GENERATOR,
48470:                             JSDVG_SEARCH_STACK, ObjectOrNullValue(obj),
53840:                             JS_GetFunctionId(gen->floatingFrame()->fun()));
 3554:         return JS_FALSE;
 3554:     }
 3554: 
42714:     /* Check for OOM errors here, where we can fail easily. */
42714:     if (!cx->ensureGeneratorStackSpace())
42714:         return JS_FALSE;
42714: 
82129:     /*
82129:      * Write barrier is needed since the generator stack can be updated,
82129:      * and it's not barriered in any other way. We need to do it before
82129:      * gen->state changes, which can cause us to trace the generator
82129:      * differently.
82129:      *
82129:      * We could optimize this by setting a bit on the generator to signify
82129:      * that it has been marked. If this bit has already been set, there is no
82129:      * need to mark again. The bit would have to be reset before the next GC,
82129:      * or else some kind of epoch scheme would have to be used.
82129:      */
82129:     GeneratorWriteBarrierPre(cx, gen);
82129: 
    1:     JS_ASSERT(gen->state == JSGEN_NEWBORN || gen->state == JSGEN_OPEN);
    1:     switch (op) {
    1:       case JSGENOP_NEXT:
    1:       case JSGENOP_SEND:
    1:         if (gen->state == JSGEN_OPEN) {
    1:             /*
    1:              * Store the argument to send as the result of the yield
    1:              * expression.
    1:              */
53840:             gen->regs.sp[-1] = arg;
    1:         }
    1:         gen->state = JSGEN_RUNNING;
    1:         break;
    1: 
    1:       case JSGENOP_THROW:
60211:         cx->setPendingException(arg);
    1:         gen->state = JSGEN_RUNNING;
    1:         break;
    1: 
    1:       default:
    1:         JS_ASSERT(op == JSGENOP_CLOSE);
60211:         cx->setPendingException(MagicValue(JS_GENERATOR_CLOSING));
    1:         gen->state = JSGEN_CLOSING;
    1:         break;
    1:     }
    1: 
69223:     StackFrame *genfp = gen->floatingFrame();
53840: 
42714:     JSBool ok;
42714:     {
71695:         GeneratorFrameGuard gfg;
71695:         if (!cx->stack.pushGeneratorFrame(cx, gen, &gfg)) {
42714:             gen->state = JSGEN_CLOSED;
42714:             return JS_FALSE;
42714:         }
42714: 
71695:         StackFrame *fp = gfg.fp();
71695:         gen->regs = cx->regs();
71695:         JS_ASSERT(gen->liveFrame() == fp);
42714: 
53840:         cx->enterGenerator(gen);   /* OOM check above. */
43281:         JSObject *enumerators = cx->enumerators;
43281:         cx->enumerators = gen->enumerators;
43281: 
71695:         ok = RunScript(cx, fp->script(), fp);
42708: 
43281:         gen->enumerators = cx->enumerators;
43281:         cx->enumerators = enumerators;
53840:         cx->leaveGenerator(gen);
53840:     }
42708: 
53840:     if (gen->floatingFrame()->isYielding()) {
    1:         /* Yield cannot fail, throw or be called on closing. */
    1:         JS_ASSERT(ok);
60211:         JS_ASSERT(!cx->isExceptionPending());
    1:         JS_ASSERT(gen->state == JSGEN_RUNNING);
    1:         JS_ASSERT(op != JSGENOP_CLOSE);
53840:         genfp->clearYielding();
    1:         gen->state = JSGEN_OPEN;
    1:         return JS_TRUE;
    1:     }
    1: 
51056:     genfp->clearReturnValue();
    1:     gen->state = JSGEN_CLOSED;
    1:     if (ok) {
    1:         /* Returned, explicitly or by falling off the end. */
    1:         if (op == JSGENOP_CLOSE)
    1:             return JS_TRUE;
 6464:         return js_ThrowStopIteration(cx);
    1:     }
    1: 
    1:     /*
 9780:      * An error, silent termination by operation callback or an exception.
    1:      * Propagate the condition to the caller.
    1:      */
    1:     return JS_FALSE;
    1: }
    1: 
24499: static JS_REQUIRES_STACK JSBool
 3436: CloseGenerator(JSContext *cx, JSObject *obj)
    1: {
77817:     JS_ASSERT(obj->isGenerator());
 3025: 
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
 3025:     if (!gen) {
 3025:         /* Generator prototype object. */
 3025:         return JS_TRUE;
 3025:     }
 3025: 
 3025:     if (gen->state == JSGEN_CLOSED)
 3025:         return JS_TRUE;
 3025: 
48470:     return SendToGenerator(cx, JSGENOP_CLOSE, obj, gen, UndefinedValue());
    1: }
    1: 
    1: /*
    1:  * Common subroutine of generator_(next|send|throw|close) methods.
    1:  */
    1: static JSBool
79779: generator_op(JSContext *cx, Native native, JSGeneratorOp op, Value *vp, uintN argc)
    1: {
79387:     CallArgs args = CallArgsFromVp(argc, vp);
79389: 
79389:     bool ok;
79779:     JSObject *obj = NonGenericMethodGuard(cx, args, native, &GeneratorClass, &ok);
67943:     if (!obj)
79389:         return ok;
    1: 
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
31452:     if (!gen) {
    1:         /* This happens when obj is the generator prototype. See bug 352885. */
    1:         goto closed_generator;
    1:     }
    1: 
 3554:     if (gen->state == JSGEN_NEWBORN) {
    1:         switch (op) {
    1:           case JSGENOP_NEXT:
    1:           case JSGENOP_THROW:
    1:             break;
    1: 
    1:           case JSGENOP_SEND:
79387:             if (args.length() >= 1 && !args[0].isUndefined()) {
    1:                 js_ReportValueError(cx, JSMSG_BAD_GENERATOR_SEND,
79387:                                     JSDVG_SEARCH_STACK, args[0], NULL);
79387:                 return false;
    1:             }
    1:             break;
    1: 
    1:           default:
    1:             JS_ASSERT(op == JSGENOP_CLOSE);
    1:             gen->state = JSGEN_CLOSED;
79387:             args.rval().setUndefined();
79387:             return true;
    1:         }
 3554:     } else if (gen->state == JSGEN_CLOSED) {
    1:       closed_generator:
    1:         switch (op) {
    1:           case JSGENOP_NEXT:
    1:           case JSGENOP_SEND:
 6464:             return js_ThrowStopIteration(cx);
    1:           case JSGENOP_THROW:
79387:             cx->setPendingException(args.length() >= 1 ? args[0] : UndefinedValue());
79387:             return false;
    1:           default:
    1:             JS_ASSERT(op == JSGENOP_CLOSE);
79387:             args.rval().setUndefined();
79387:             return true;
    1:         }
    1:     }
    1: 
79387:     bool undef = ((op == JSGENOP_SEND || op == JSGENOP_THROW) && args.length() != 0);
79387:     if (!SendToGenerator(cx, op, obj, gen, undef ? args[0] : UndefinedValue()))
79387:         return false;
64224: 
79387:     args.rval() = gen->floatingFrame()->returnValue();
79387:     return true;
    1: }
    1: 
    1: static JSBool
48470: generator_send(JSContext *cx, uintN argc, Value *vp)
    1: {
79779:     return generator_op(cx, generator_send, JSGENOP_SEND, vp, argc);
    1: }
    1: 
    1: static JSBool
48470: generator_next(JSContext *cx, uintN argc, Value *vp)
    1: {
79779:     return generator_op(cx, generator_next, JSGENOP_NEXT, vp, argc);
    1: }
    1: 
    1: static JSBool
48470: generator_throw(JSContext *cx, uintN argc, Value *vp)
    1: {
79779:     return generator_op(cx, generator_throw, JSGENOP_THROW, vp, argc);
    1: }
    1: 
    1: static JSBool
48470: generator_close(JSContext *cx, uintN argc, Value *vp)
    1: {
79779:     return generator_op(cx, generator_close, JSGENOP_CLOSE, vp, argc);
    1: }
    1: 
    1: static JSFunctionSpec generator_methods[] = {
16519:     JS_FN(js_next_str,      generator_next,     0,JSPROP_ROPERM),
16519:     JS_FN(js_send_str,      generator_send,     1,JSPROP_ROPERM),
16519:     JS_FN(js_throw_str,     generator_throw,    1,JSPROP_ROPERM),
16519:     JS_FN(js_close_str,     generator_close,    0,JSPROP_ROPERM),
 4127:     JS_FS_END
    1: };
    1: 
    1: #endif /* JS_HAS_GENERATORS */
    1: 
75062: static bool
75062: InitIteratorClass(JSContext *cx, GlobalObject *global)
75062: {
77817:     JSObject *iteratorProto = global->createBlankPrototype(cx, &IteratorClass);
75062:     if (!iteratorProto)
75062:         return false;
75062: 
80307:     AutoIdVector blank(cx);
80307:     NativeIterator *ni = NativeIterator::allocateIterator(cx, 0, blank);
80307:     if (!ni)
80307:         return false;
80307:     ni->init(NULL, 0 /* flags */, 0, 0);
80307: 
80307:     iteratorProto->setNativeIterator(ni);
80307: 
77817:     JSFunction *ctor = global->createConstructor(cx, Iterator, &IteratorClass,
75062:                                                  CLASS_ATOM(cx, Iterator), 2);
75062:     if (!ctor)
75062:         return false;
75062: 
75062:     if (!LinkConstructorAndPrototype(cx, ctor, iteratorProto))
75062:         return false;
75062: 
75062:     if (!DefinePropertiesAndBrand(cx, iteratorProto, NULL, iterator_methods))
75062:         return false;
75062: 
75062:     return DefineConstructorAndPrototype(cx, global, JSProto_Iterator, ctor, iteratorProto);
75062: }
75062: 
78098: bool
78098: GlobalObject::initGeneratorClass(JSContext *cx)
75062: {
75062: #if JS_HAS_GENERATORS
78098:     JSObject *proto = createBlankPrototype(cx, &GeneratorClass);
78098:     if (!proto || !DefinePropertiesAndBrand(cx, proto, NULL, generator_methods))
75063:         return false;
78098:     setReservedSlot(GENERATOR_PROTO, ObjectValue(*proto));
78098: #endif
75062:     return true;
75062: }
75062: 
75062: static JSObject *
75062: InitStopIterationClass(JSContext *cx, GlobalObject *global)
75062: {
77817:     JSObject *proto = global->createBlankPrototype(cx, &StopIterationClass);
75064:     if (!proto || !proto->freeze(cx))
75064:         return NULL;
75064: 
75064:     /* This should use a non-JSProtoKey'd slot, but this is easier for now. */
75064:     if (!DefineConstructorAndPrototype(cx, global, JSProto_StopIteration, proto, proto))
75064:         return NULL;
75064: 
77817:     MarkStandardClassInitializedNoProto(global, &StopIterationClass);
75064: 
75062:     return proto;
75062: }
75062: 
    1: JSObject *
    1: js_InitIteratorClasses(JSContext *cx, JSObject *obj)
    1: {
75062:     JS_ASSERT(obj->isNative());
    1: 
75062:     GlobalObject *global = obj->asGlobal();
75062: 
75062:     /*
75062:      * Bail if Iterator has already been initialized.  We test for Iterator
75062:      * rather than for StopIteration because if js_InitIteratorClasses recurs,
75062:      * as happens when the StopIteration object is frozen, initializing the
75062:      * Iterator class a second time will assert.
75062:      */
75062:     JSObject *iter;
75062:     if (!js_GetClassObject(cx, global, JSProto_Iterator, &iter))
    1:         return NULL;
75062:     if (iter)
75062:         return iter;
    1: 
78098:     if (!InitIteratorClass(cx, global) || !global->initGeneratorClass(cx))
    1:         return NULL;
75062:     return InitStopIterationClass(cx, global);
    1: }
