    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=80: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: 
    1: #ifndef nsPIDOMWindow_h__
    1: #define nsPIDOMWindow_h__
    1: 
    1: #include "nsISupports.h"
    1: #include "nsIDOMLocation.h"
    1: #include "nsIDOMXULCommandDispatcher.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsPIDOMEventTarget.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsEvent.h"
    1: 
11693: #define DOM_WINDOW_DESTROYED_TOPIC "dom-window-destroyed"
11693: 
    1: class nsIPrincipal;
    1: 
    1: // Popup control state enum. The values in this enum must go from most
    1: // permissive to least permissive so that it's safe to push state in
    1: // all situations. Pushing popup state onto the stack never makes the
    1: // current popup state less permissive (see
    1: // nsGlobalWindow::PushPopupControlState()).
    1: enum PopupControlState {
    1:   openAllowed = 0,  // open that window without worries
    1:   openControlled,   // it's a popup, but allow it
    1:   openAbused,       // it's a popup. disallow it, but allow domain override.
    1:   openOverridden    // disallow window open
    1: };
    1: 
    1: class nsIDocShell;
    1: class nsIFocusController;
29018: class nsIContent;
    1: class nsIDocument;
    1: class nsIScriptTimeoutHandler;
    1: class nsPresContext;
    1: struct nsTimeout;
11622: class nsScriptObjectHolder;
11622: class nsXBLPrototypeHandler;
33525: class nsIArray;
    1: 
    1: #define NS_PIDOMWINDOW_IID \
36884: { 0xeee92d9a, 0xae9f, 0x41e5, \
36884:   { 0x95, 0x5f, 0xaf, 0x1c, 0xe7, 0x66, 0x42, 0xe6 } }
    1: 
    1: class nsPIDOMWindow : public nsIDOMWindowInternal
    1: {
    1: public:
    1:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_PIDOMWINDOW_IID)
    1: 
    1:   virtual nsPIDOMWindow* GetPrivateRoot() = 0;
    1: 
29018:   virtual void ActivateOrDeactivate(PRBool aActivate) = 0;
    1: 
    1:   nsPIDOMEventTarget* GetChromeEventHandler() const
    1:   {
    1:     return mChromeEventHandler;
    1:   }
    1: 
16549:   virtual void SetChromeEventHandler(nsPIDOMEventTarget* aChromeEventHandler) = 0;
16549: 
    1:   PRBool HasMutationListeners(PRUint32 aMutationEventType) const
    1:   {
    1:     const nsPIDOMWindow *win;
    1: 
    1:     if (IsOuterWindow()) {
    1:       win = GetCurrentInnerWindow();
    1: 
    1:       if (!win) {
    1:         NS_ERROR("No current inner window available!");
    1: 
    1:         return PR_FALSE;
    1:       }
    1:     } else {
    1:       if (!mOuterWindow) {
    1:         NS_ERROR("HasMutationListeners() called on orphan inner window!");
    1: 
    1:         return PR_FALSE;
    1:       }
    1: 
    1:       win = this;
    1:     }
    1: 
    1:     return (win->mMutationBits & aMutationEventType) != 0;
    1:   }
    1: 
    1:   void SetMutationListeners(PRUint32 aType)
    1:   {
    1:     nsPIDOMWindow *win;
    1: 
    1:     if (IsOuterWindow()) {
    1:       win = GetCurrentInnerWindow();
    1: 
    1:       if (!win) {
    1:         NS_ERROR("No inner window available to set mutation bits on!");
    1: 
    1:         return;
    1:       }
    1:     } else {
    1:       if (!mOuterWindow) {
    1:         NS_ERROR("HasMutationListeners() called on orphan inner window!");
    1: 
    1:         return;
    1:       }
    1: 
    1:       win = this;
    1:     }
    1: 
    1:     win->mMutationBits |= aType;
    1:   }
    1: 
    1:   virtual nsIFocusController* GetRootFocusController() = 0;
    1: 
    1:   // GetExtantDocument provides a backdoor to the DOM GetDocument accessor
    1:   nsIDOMDocument* GetExtantDocument() const
    1:   {
    1:     return mDocument;
    1:   }
    1: 
    1:   // Internal getter/setter for the frame element, this version of the
    1:   // getter crosses chrome boundaries whereas the public scriptable
    1:   // one doesn't for security reasons.
    1:   nsIDOMElement* GetFrameElementInternal() const
    1:   {
    1:     if (mOuterWindow) {
    1:       return mOuterWindow->GetFrameElementInternal();
    1:     }
    1: 
    1:     NS_ASSERTION(!IsInnerWindow(),
    1:                  "GetFrameElementInternal() called on orphan inner window");
    1: 
    1:     return mFrameElement;
    1:   }
    1: 
    1:   void SetFrameElementInternal(nsIDOMElement *aFrameElement)
    1:   {
    1:     if (IsOuterWindow()) {
    1:       mFrameElement = aFrameElement;
    1: 
    1:       return;
    1:     }
    1: 
    1:     if (!mOuterWindow) {
    1:       NS_ERROR("frameElement set on inner window with no outer!");
    1: 
    1:       return;
    1:     }
    1: 
    1:     mOuterWindow->SetFrameElementInternal(aFrameElement);
    1:   }
    1: 
    1:   PRBool IsLoadingOrRunningTimeout() const
    1:   {
    1:     const nsPIDOMWindow *win = GetCurrentInnerWindow();
    1: 
    1:     if (!win) {
    1:       win = this;
    1:     }
    1: 
    1:     return !win->mIsDocumentLoaded || win->mRunningTimeout;
    1:   }
    1: 
    1:   // Check whether a document is currently loading
    1:   PRBool IsLoading() const
    1:   {
    1:     const nsPIDOMWindow *win;
    1: 
    1:     if (IsOuterWindow()) {
    1:       win = GetCurrentInnerWindow();
    1: 
    1:       if (!win) {
    1:         NS_ERROR("No current inner window available!");
    1: 
    1:         return PR_FALSE;
    1:       }
    1:     } else {
    1:       if (!mOuterWindow) {
    1:         NS_ERROR("IsLoading() called on orphan inner window!");
    1: 
    1:         return PR_FALSE;
    1:       }
    1: 
    1:       win = this;
    1:     }
    1: 
    1:     return !win->mIsDocumentLoaded;
    1:   }
    1: 
    1:   PRBool IsHandlingResizeEvent() const
    1:   {
    1:     const nsPIDOMWindow *win;
    1: 
    1:     if (IsOuterWindow()) {
    1:       win = GetCurrentInnerWindow();
    1: 
    1:       if (!win) {
    1:         NS_ERROR("No current inner window available!");
    1: 
    1:         return PR_FALSE;
    1:       }
    1:     } else {
    1:       if (!mOuterWindow) {
    1:         NS_ERROR("IsHandlingResizeEvent() called on orphan inner window!");
    1: 
    1:         return PR_FALSE;
    1:       }
    1: 
    1:       win = this;
    1:     }
    1: 
    1:     return win->mIsHandlingResizeEvent;
    1:   }
    1: 
    1:   // Tell this window who opened it.  This only has an effect if there is
    1:   // either no document currently in the window or if the document is the
    1:   // original document this window came with (an about:blank document either
    1:   // preloaded into it when it was created, or created by
    1:   // CreateAboutBlankContentViewer()).
    1:   virtual void SetOpenerScriptPrincipal(nsIPrincipal* aPrincipal) = 0;
    1:   // Ask this window who opened it.
    1:   virtual nsIPrincipal* GetOpenerScriptPrincipal() = 0;
    1: 
    1:   virtual PopupControlState PushPopupControlState(PopupControlState aState,
    1:                                                   PRBool aForce) const = 0;
    1:   virtual void PopPopupControlState(PopupControlState state) const = 0;
    1:   virtual PopupControlState GetPopupControlState() const = 0;
    1: 
    1:   // Returns an object containing the window's state.  This also suspends
    1:   // all running timeouts in the window.
    1:   virtual nsresult SaveWindowState(nsISupports **aState) = 0;
    1: 
    1:   // Restore the window state from aState.
    1:   virtual nsresult RestoreWindowState(nsISupports *aState) = 0;
    1: 
25074:   // Suspend timeouts in this window and in child windows.
25723:   virtual void SuspendTimeouts(PRUint32 aIncrease = 1,
25723:                                PRBool aFreezeChildren = PR_TRUE) = 0;
25074: 
    1:   // Resume suspended timeouts in this window and in child windows.
25723:   virtual nsresult ResumeTimeouts(PRBool aThawChildren = PR_TRUE) = 0;
25723: 
25723:   virtual PRUint32 TimeoutSuspendCount() = 0;
    1: 
    1:   // Fire any DOM notification events related to things that happened while
    1:   // the window was frozen.
    1:   virtual nsresult FireDelayedDOMEvents() = 0;
    1: 
10340:   virtual PRBool IsFrozen() const = 0;
10340: 
    1:   // Add a timeout to this window.
    1:   virtual nsresult SetTimeoutOrInterval(nsIScriptTimeoutHandler *aHandler,
    1:                                         PRInt32 interval,
    1:                                         PRBool aIsInterval, PRInt32 *aReturn) = 0;
    1: 
    1:   // Clear a timeout from this window.
    1:   virtual nsresult ClearTimeoutOrInterval(PRInt32 aTimerID) = 0;
    1: 
    1:   nsPIDOMWindow *GetOuterWindow()
    1:   {
    1:     return mIsInnerWindow ? mOuterWindow : this;
    1:   }
    1: 
    1:   nsPIDOMWindow *GetCurrentInnerWindow() const
    1:   {
    1:     return mInnerWindow;
    1:   }
    1: 
    1:   nsPIDOMWindow *EnsureInnerWindow()
    1:   {
    1:     NS_ASSERTION(IsOuterWindow(), "EnsureInnerWindow called on inner window");
    1:     // GetDocument forces inner window creation if there isn't one already
    1:     nsCOMPtr<nsIDOMDocument> doc;
    1:     GetDocument(getter_AddRefs(doc));
    1:     return GetCurrentInnerWindow();
    1:   }
    1: 
    1:   PRBool IsInnerWindow() const
    1:   {
    1:     return mIsInnerWindow;
    1:   }
    1: 
    1:   PRBool IsOuterWindow() const
    1:   {
    1:     return !IsInnerWindow();
    1:   }
    1: 
    1:   virtual PRBool WouldReuseInnerWindow(nsIDocument *aNewDocument) = 0;
    1: 
    1:   /**
    1:    * Get the docshell in this window.
    1:    */
    1:   nsIDocShell *GetDocShell()
    1:   {
    1:     if (mOuterWindow) {
    1:       return mOuterWindow->mDocShell;
    1:     }
    1: 
    1:     return mDocShell;
    1:   }
    1: 
    1:   /**
    1:    * Set or unset the docshell in the window.
    1:    */
    1:   virtual void SetDocShell(nsIDocShell *aDocShell) = 0;
    1: 
    1:   /**
    1:    * Set a new document in the window. Calling this method will in
    1:    * most cases create a new inner window. If this method is called on
    1:    * an inner window the call will be forewarded to the outer window,
    1:    * if the inner window is not the current inner window an
    1:    * NS_ERROR_NOT_AVAILABLE error code will be returned. This may be
    1:    * called with a pointer to the current document, in that case the
    1:    * document remains unchanged, but a new inner window will be
    1:    * created.
    1:    */
    1:   virtual nsresult SetNewDocument(nsIDocument *aDocument,
    1:                                   nsISupports *aState,
    1:                                   PRBool aClearScope) = 0;
    1: 
    1:   /**
    1:    * Set the opener window.  aOriginalOpener is true if and only if this is the
    1:    * original opener for the window.  That is, it can only be true at most once
    1:    * during the life cycle of a window, and then only the first time
    1:    * SetOpenerWindow is called.  It might never be true, of course, if the
    1:    * window does not have an opener when it's created.
    1:    */
    1:   virtual void SetOpenerWindow(nsIDOMWindowInternal *aOpener,
    1:                                PRBool aOriginalOpener) = 0;
    1: 
    1:   virtual void EnsureSizeUpToDate() = 0;
    1: 
    1:   /**
    1:    * Callback for notifying a window about a modal dialog being
    1:    * opened/closed with the window as a parent.
    1:    */
    1:   virtual void EnterModalState() = 0;
    1:   virtual void LeaveModalState() = 0;
    1: 
 4040:   void SetModalContentWindow(PRBool aIsModalContentWindow)
 4040:   {
 4040:     mIsModalContentWindow = aIsModalContentWindow;
 4040:   }
 4040: 
 4040:   PRBool IsModalContentWindow() const
 4040:   {
 4040:     return mIsModalContentWindow;
 4040:   }
    1: 
 7273:   /**
20515:    * Call this to indicate that some node (this window, its document,
20515:    * or content in that document) has a paint event listener.
20515:    */
20515:   void SetHasPaintEventListeners()
20515:   {
20515:     mMayHavePaintEventListener = PR_TRUE;
20515:   }
20515: 
20515:   /**
20515:    * Call this to check whether some node (this window, its document,
20515:    * or content in that document) has a paint event listener.
20515:    */
20515:   PRBool HasPaintEventListeners()
20515:   {
20515:     return mMayHavePaintEventListener;
20515:   }
20515:   
20515:   /**
29923:    * Initialize window.java and window.Packages.
 7273:    */
 7273:   virtual void InitJavaProperties() = 0;
 7273: 
11622:   virtual void* GetCachedXBLPrototypeHandler(nsXBLPrototypeHandler* aKey) = 0;
11622:   virtual void CacheXBLPrototypeHandler(nsXBLPrototypeHandler* aKey,
11622:                                         nsScriptObjectHolder& aHandler) = 0;
11622: 
29018:   /*
29018:    * Get and set the currently focused element within the document. If
29018:    * aNeedsFocus is true, then set mNeedsFocus to true to indicate that a
29018:    * document focus event is needed.
29018:    *
29018:    * DO NOT CALL EITHER OF THESE METHODS DIRECTLY. USE THE FOCUS MANAGER
29018:    * INSTEAD.
29018:    */
29018:   virtual nsIContent* GetFocusedNode() = 0;
29018:   virtual void SetFocusedNode(nsIContent* aNode,
29018:                               PRUint32 aFocusMethod = 0,
29018:                               PRBool aNeedsFocus = PR_FALSE) = 0;
29018: 
29018:   /**
29018:    * Retrieves the method that was used to focus the current node.
29018:    */
29018:   virtual PRUint32 GetFocusMethod() = 0;
29018: 
29018:   /*
29018:    * Tells the window that it now has focus or has lost focus, based on the
29018:    * state of aFocus. If this method returns true, then the document loaded
29018:    * in the window has never received a focus event and expects to receive
29018:    * one. If false is returned, the document has received a focus event before
29018:    * and should only receive one if the window is being focused.
29018:    *
29018:    * aFocusMethod may be set to one of the focus method constants in
29018:    * nsIFocusManager to indicate how focus was set.
29018:    */
29018:   virtual PRBool TakeFocus(PRBool aFocus, PRUint32 aFocusMethod) = 0;
29018: 
29018:   /**
29018:    * Indicates that the window may now accept a document focus event. This
29018:    * should be called once a document has been loaded into the window.
29018:    */
29018:   virtual void SetReadyForFocus() = 0;
29018: 
29018:   /**
29018:    * Indicates that the page in the window has been hidden. This is used to
29018:    * reset the focus state.
29018:    */
29018:   virtual void PageHidden() = 0;
29018: 
29975:   /**
29975:    * Instructs this window to asynchronously dispatch a hashchange event.  This
29975:    * method must be called on an inner window.
29975:    */
29975:   virtual nsresult DispatchAsyncHashchange() = 0;
29975: 
31738: 
31738:   /**
31738:    * Tell this window that there is an observer for orientation changes
31738:    */
31738:   virtual void SetHasOrientationEventListener() = 0;
31738: 
33525:   /**
33525:    * Set a arguments for this window. This will be set on the window
33525:    * right away (if there's an existing document) and it will also be
33525:    * installed on the window when the next document is loaded. Each
33525:    * language impl is responsible for converting to an array of args
33525:    * as appropriate for that language.
33525:    */
33525:   virtual nsresult SetArguments(nsIArray *aArguments, nsIPrincipal *aOrigin) = 0;
33525: 
    1: protected:
    1:   // The nsPIDOMWindow constructor. The aOuterWindow argument should
    1:   // be null if and only if the created window itself is an outer
    1:   // window. In all other cases aOuterWindow should be the outer
    1:   // window for the inner window that is being created.
    1:   nsPIDOMWindow(nsPIDOMWindow *aOuterWindow)
    1:     : mFrameElement(nsnull), mDocShell(nsnull), mModalStateDepth(0),
    1:       mRunningTimeout(nsnull), mMutationBits(0), mIsDocumentLoaded(PR_FALSE),
    1:       mIsHandlingResizeEvent(PR_FALSE), mIsInnerWindow(aOuterWindow != nsnull),
20515:       mMayHavePaintEventListener(PR_FALSE),
 4040:       mIsModalContentWindow(PR_FALSE), mInnerWindow(nsnull),
 4040:       mOuterWindow(aOuterWindow)
    1:   {
    1:   }
    1: 
16549:   void SetChromeEventHandlerInternal(nsPIDOMEventTarget* aChromeEventHandler) {
16549:     mChromeEventHandler = aChromeEventHandler;
16549:   }
16549: 
    1:   // These two variables are special in that they're set to the same
    1:   // value on both the outer window and the current inner window. Make
    1:   // sure you keep them in sync!
    1:   nsCOMPtr<nsPIDOMEventTarget> mChromeEventHandler; // strong
    1:   nsCOMPtr<nsIDOMDocument> mDocument; // strong
    1: 
    1:   // These members are only used on outer windows.
27191:   nsCOMPtr<nsIDOMElement> mFrameElement;
    1:   nsIDocShell           *mDocShell;  // Weak Reference
    1: 
    1:   PRUint32               mModalStateDepth;
    1: 
    1:   // These variables are only used on inner windows.
    1:   nsTimeout             *mRunningTimeout;
    1: 
    1:   PRUint32               mMutationBits;
    1: 
    1:   PRPackedBool           mIsDocumentLoaded;
    1:   PRPackedBool           mIsHandlingResizeEvent;
    1:   PRPackedBool           mIsInnerWindow;
20515:   PRPackedBool           mMayHavePaintEventListener;
    1: 
 4040:   // This variable is used on both inner and outer windows (and they
 4040:   // should match).
 4040:   PRPackedBool           mIsModalContentWindow;
 4040: 
    1:   // And these are the references between inner and outer windows.
    1:   nsPIDOMWindow         *mInnerWindow;
    1:   nsPIDOMWindow         *mOuterWindow;
    1: };
    1: 
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsPIDOMWindow, NS_PIDOMWINDOW_IID)
    1: 
    1: #ifdef _IMPL_NS_LAYOUT
    1: PopupControlState
    1: PushPopupControlState(PopupControlState aState, PRBool aForce);
    1: 
    1: void
    1: PopPopupControlState(PopupControlState aState);
    1: 
    1: #define NS_AUTO_POPUP_STATE_PUSHER nsAutoPopupStatePusherInternal
    1: #else
    1: #define NS_AUTO_POPUP_STATE_PUSHER nsAutoPopupStatePusherExternal
    1: #endif
    1: 
    1: // Helper class that helps with pushing and popping popup control
    1: // state. Note that this class looks different from within code that's
    1: // part of the layout library than it does in code outside the layout
    1: // library.  We give the two object layouts different names so the symbols
    1: // don't conflict, but code should always use the name
    1: // |nsAutoPopupStatePusher|.
    1: class NS_AUTO_POPUP_STATE_PUSHER
    1: {
    1: public:
    1: #ifdef _IMPL_NS_LAYOUT
    1:   NS_AUTO_POPUP_STATE_PUSHER(PopupControlState aState, PRBool aForce = PR_FALSE)
    1:     : mOldState(::PushPopupControlState(aState, aForce))
    1:   {
    1:   }
    1: 
    1:   ~NS_AUTO_POPUP_STATE_PUSHER()
    1:   {
    1:     PopPopupControlState(mOldState);
    1:   }
    1: #else
    1:   NS_AUTO_POPUP_STATE_PUSHER(nsPIDOMWindow *aWindow, PopupControlState aState)
    1:     : mWindow(aWindow), mOldState(openAbused)
    1:   {
    1:     if (aWindow) {
    1:       mOldState = aWindow->PushPopupControlState(aState, PR_FALSE);
    1:     }
    1:   }
    1: 
    1:   ~NS_AUTO_POPUP_STATE_PUSHER()
    1:   {
    1:     if (mWindow) {
    1:       mWindow->PopPopupControlState(mOldState);
    1:     }
    1:   }
    1: #endif
    1: 
    1: protected:
    1: #ifndef _IMPL_NS_LAYOUT
    1:   nsCOMPtr<nsPIDOMWindow> mWindow;
    1: #endif
    1:   PopupControlState mOldState;
    1: 
    1: private:
    1:   // Hide so that this class can only be stack-allocated
    1:   static void* operator new(size_t /*size*/) CPP_THROW_NEW { return nsnull; }
    1:   static void operator delete(void* /*memory*/) {}
    1: };
    1: 
    1: #define nsAutoPopupStatePusher NS_AUTO_POPUP_STATE_PUSHER
    1: 
    1: #endif // nsPIDOMWindow_h__
