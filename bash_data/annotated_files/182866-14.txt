131289: /* This Source Code Form is subject to the terms of the Mozilla Public
131289:  * License, v. 2.0. If a copy of the MPL was not distributed with this
131289:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
131289: 'use strict';
131289: 
131289: module.metadata = {
131289:   'stability': 'unstable'
131289: };
131289: 
135382: 
135382: // NOTE: This file should only deal with xul/native tabs
135382: 
135382: 
135382: const { Ci } = require('chrome');
131289: const { defer } = require("../lang/functional");
131289: const { windows, isBrowser } = require('../window/utils');
135382: const { isPrivateBrowsingSupported } = require('../self');
137856: const { isGlobalPBSupported } = require('../private-browsing/utils');
135382: 
135382: // Bug 834961: ignore private windows when they are not supported
137856: function getWindows() windows(null, { includePrivate: isPrivateBrowsingSupported || isGlobalPBSupported });
131289: 
131289: function activateTab(tab, window) {
131289:   let gBrowser = getTabBrowserForTab(tab);
131289: 
131289:   // normal case
131289:   if (gBrowser) {
131289:     gBrowser.selectedTab = tab;
131289:   }
131289:   // fennec ?
131289:   else if (window && window.BrowserApp) {
131289:     window.BrowserApp.selectTab(tab);
131289:   }
131289:   return null;
131289: }
131289: exports.activateTab = activateTab;
131289: 
131289: function getTabBrowser(window) {
131289:   return window.gBrowser;
131289: }
131289: exports.getTabBrowser = getTabBrowser;
131289: 
131289: function getTabContainer(window) {
131289:   return getTabBrowser(window).tabContainer;
131289: }
131289: exports.getTabContainer = getTabContainer;
131289: 
131289: /**
131289:  * Returns the tabs for the `window` if given, or the tabs
131289:  * across all the browser's windows otherwise.
131289:  *
131289:  * @param {nsIWindow} [window]
131289:  *    A reference to a window
131289:  *
131289:  * @returns {Array} an array of Tab objects
131289:  */
131289: function getTabs(window) {
131289:   if (arguments.length === 0) {
135382:     return getWindows().filter(isBrowser).reduce(function(tabs, window) {
131289:       return tabs.concat(getTabs(window))
131289:     }, []);
131289:   }
131289: 
131289:   // fennec
131289:   if (window.BrowserApp)
131289:     return window.BrowserApp.tabs;
131289: 
131289:   // firefox - default
131289:   return Array.slice(getTabContainer(window).children);
131289: }
131289: exports.getTabs = getTabs;
131289: 
131289: function getActiveTab(window) {
135382:   return getSelectedTab(window);
131289: }
131289: exports.getActiveTab = getActiveTab;
131289: 
131289: function getOwnerWindow(tab) {
131289:   // normal case
131289:   if (tab.ownerDocument)
131289:     return tab.ownerDocument.defaultView;
131289: 
131289:   // try fennec case
131289:   return getWindowHoldingTab(tab);
131289: }
131289: exports.getOwnerWindow = getOwnerWindow;
131289: 
131289: // fennec
131289: function getWindowHoldingTab(rawTab) {
135382:   for each (let window in getWindows()) {
133768:     // this function may be called when not using fennec,
133768:     // but BrowserApp is only defined on Fennec
131289:     if (!window.BrowserApp)
131289:       continue;
131289: 
131289:     for each (let tab in window.BrowserApp.tabs) {
131289:       if (tab === rawTab)
131289:         return window;
131289:     }
131289:   }
131289: 
131289:   return null;
131289: }
131289: 
131289: function openTab(window, url, options) {
131289:   options = options || {};
131289: 
131289:   // fennec?
131289:   if (window.BrowserApp) {
131289:     return window.BrowserApp.addTab(url, {
131289:       selected: options.inBackground ? false : true,
133768:       pinned: options.isPinned || false,
133898:       isPrivate: options.isPrivate || false
131289:     });
131289:   }
135382: 
135382:   // firefox
135382:   let newTab = window.gBrowser.addTab(url);
135382:   if (!options.inBackground) {
135382:     activateTab(newTab);
135382:   }
135382:   return newTab;
131289: };
131289: exports.openTab = openTab;
131289: 
131289: function isTabOpen(tab) {
131289:   // try normal case then fennec case
131289:   return !!((tab.linkedBrowser) || getWindowHoldingTab(tab));
131289: }
131289: exports.isTabOpen = isTabOpen;
131289: 
131289: function closeTab(tab) {
131289:   let gBrowser = getTabBrowserForTab(tab);
131289:   // normal case?
146742:   if (gBrowser) {
146742:     // Bug 699450: the tab may already have been detached
146742:     if (!tab.parentNode)
146742:       return;
131289:     return gBrowser.removeTab(tab);
146742:   }
131289: 
131289:   let window = getWindowHoldingTab(tab);
131289:   // fennec?
146742:   if (window && window.BrowserApp) {
146742:     // Bug 699450: the tab may already have been detached
146742:     if (!tab.browser)
146742:       return;
131289:     return window.BrowserApp.closeTab(tab);
146742:   }
131289:   return null;
131289: }
131289: exports.closeTab = closeTab;
131289: 
131289: function getURI(tab) {
131289:   if (tab.browser) // fennec
131289:     return tab.browser.currentURI.spec;
131289:   return tab.linkedBrowser.currentURI.spec;
131289: }
131289: exports.getURI = getURI;
131289: 
131289: function getTabBrowserForTab(tab) {
131289:   let outerWin = getOwnerWindow(tab);
131289:   if (outerWin)
131289:     return getOwnerWindow(tab).gBrowser;
131289:   return null;
131289: }
131289: exports.getTabBrowserForTab = getTabBrowserForTab;
131289: 
131289: function getBrowserForTab(tab) {
131289:   if (tab.browser) // fennec
131289:     return tab.browser;
131289: 
131289:   return tab.linkedBrowser;
131289: }
131289: exports.getBrowserForTab = getBrowserForTab;
131289: 
131289: function getTabId(tab) {
131289:   if (tab.browser) // fennec
131289:     return tab.id
131289: 
131289:   return String.split(tab.linkedPanel, 'panel').pop();
131289: }
131289: exports.getTabId = getTabId;
131289: 
131289: function getTabTitle(tab) {
131289:   return getBrowserForTab(tab).contentDocument.title || tab.label || "";
131289: }
131289: exports.getTabTitle = getTabTitle;
131289: 
131289: function setTabTitle(tab, title) {
131289:   title = String(title);
131289:   if (tab.browser)
131289:     tab.browser.contentDocument.title = title;
131289:   tab.label = String(title);
131289: }
131289: exports.setTabTitle = setTabTitle;
131289: 
131289: function getTabContentWindow(tab) {
131289:   return getBrowserForTab(tab).contentWindow;
131289: }
131289: exports.getTabContentWindow = getTabContentWindow;
131289: 
131289: /**
131289:  * Returns all tabs' content windows across all the browsers' windows
131289:  */
131289: function getAllTabContentWindows() {
131289:   return getTabs().map(getTabContentWindow);
131289: }
131289: exports.getAllTabContentWindows = getAllTabContentWindows;
131289: 
135382: // gets the tab containing the provided window
131289: function getTabForContentWindow(window) {
131289:   // Retrieve the topmost frame container. It can be either <xul:browser>,
131289:   // <xul:iframe/> or <html:iframe/>. But in our case, it should be xul:browser.
146742:   let browser;
146742:   try {
146742:     browser = window.QueryInterface(Ci.nsIInterfaceRequestor)
131289:                     .getInterface(Ci.nsIWebNavigation)
131289:                     .QueryInterface(Ci.nsIDocShell)
131289:                     .chromeEventHandler;
146742:   } catch(e) {
146742:     // Bug 699450: The tab may already have been detached so that `window` is
146742:     // in a almost destroyed state and can't be queryinterfaced anymore.
146742:   }
135382: 
131289:   // Is null for toplevel documents
135382:   if (!browser) {
146742:     return null;
135382:   }
135382: 
131289:   // Retrieve the owner window, should be browser.xul one
131289:   let chromeWindow = browser.ownerDocument.defaultView;
131289: 
131289:   // Ensure that it is top-level browser window.
131289:   // We need extra checks because of Mac hidden window that has a broken
131289:   // `gBrowser` global attribute.
131289:   if ('gBrowser' in chromeWindow && chromeWindow.gBrowser &&
131289:       'browsers' in chromeWindow.gBrowser) {
131289:     // Looks like we are on Firefox Desktop
131289:     // Then search for the position in tabbrowser in order to get the tab object
131289:     let browsers = chromeWindow.gBrowser.browsers;
131289:     let i = browsers.indexOf(browser);
131289:     if (i !== -1)
131289:       return chromeWindow.gBrowser.tabs[i];
131289:     return null;
131289:   }
135382:   // Fennec
131289:   else if ('BrowserApp' in chromeWindow) {
135382:     return getTabForWindow(window);
131289:   }
131289: 
131289:   return null;
131289: }
131289: exports.getTabForContentWindow = getTabForContentWindow;
131289: 
135382: // used on fennec
135382: function getTabForWindow(window) {
135382:   for each (let { BrowserApp } in getWindows()) {
135382:     if (!BrowserApp)
135382:       continue;
135382: 
135382:     for each (let tab in BrowserApp.tabs) {
135382:       if (tab.browser.contentWindow == window.top)
135382:         return tab;
135382:     }
135382:   }
135382:   return null; 
135382: }
135382: 
131289: function getTabURL(tab) {
131289:   if (tab.browser) // fennec
131289:     return String(tab.browser.currentURI.spec);
131289:   return String(getBrowserForTab(tab).currentURI.spec);
131289: }
131289: exports.getTabURL = getTabURL;
131289: 
131289: function setTabURL(tab, url) {
131289:   url = String(url);
131289:   if (tab.browser)
131289:     return tab.browser.loadURI(url);
131289:   return getBrowserForTab(tab).loadURI(url);
131289: }
131289: // "TabOpen" event is fired when it's still "about:blank" is loaded in the
131289: // changing `location` property of the `contentDocument` has no effect since
131289: // seems to be either ignored or overridden by internal listener, there for
131289: // location change is enqueued for the next turn of event loop.
131289: exports.setTabURL = defer(setTabURL);
131289: 
131289: function getTabContentType(tab) {
131289:   return getBrowserForTab(tab).contentDocument.contentType;
131289: }
131289: exports.getTabContentType = getTabContentType;
131289: 
131289: function getSelectedTab(window) {
131289:   if (window.BrowserApp) // fennec?
131289:     return window.BrowserApp.selectedTab;
131289:   if (window.gBrowser)
131289:     return window.gBrowser.selectedTab;
131289:   return null;
131289: }
131289: exports.getSelectedTab = getSelectedTab;
135382: 
135382: 
135382: function getTabForBrowser(browser) {
135382:   for each (let window in getWindows()) {
135382:     // this function may be called when not using fennec
135382:     if (!window.BrowserApp)
135382:       continue;
135382: 
135382:     for each (let tab in window.BrowserApp.tabs) {
135382:       if (tab.browser === browser)
135382:         return tab;
135382:     }
135382:   }
135382:   return null;
135382: }
135382: exports.getTabForBrowser = getTabForBrowser;
135382: 
139499: function pin(tab) {
139499:   let gBrowser = getTabBrowserForTab(tab);
139499:   // TODO: Implement Fennec support
139499:   if (gBrowser) gBrowser.pinTab(tab);
139499: }
139499: exports.pin = pin;
139499: 
139499: function unpin(tab) {
139499:   let gBrowser = getTabBrowserForTab(tab);
139499:   // TODO: Implement Fennec support
139499:   if (gBrowser) gBrowser.unpinTab(tab);
139499: }
139499: exports.unpin = unpin;
139499: 
139499: function isPinned(tab) !!tab.pinned
139499: exports.isPinned = isPinned;
139499: 
139499: function reload(tab) {
139499:   let gBrowser = getTabBrowserForTab(tab);
139499:   // Firefox
139499:   if (gBrowser) gBrowser.unpinTab(tab);
139499:   // Fennec
139499:   else if (tab.browser) tab.browser.reload();
139499: }
139499: exports.reload = reload
139499: 
139499: function getIndex(tab) {
139499:   let gBrowser = getTabBrowserForTab(tab);
139499:   // Firefox
139499:   if (gBrowser) {
139499:     let document = getBrowserForTab(tab).contentDocument;
139499:     return gBrowser.getBrowserIndexForDocument(document);
139499:   }
139499:   // Fennec
139499:   else {
139499:     let window = getWindowHoldingTab(tab)
139499:     let tabs = window.BrowserApp.tabs;
139499:     for (let i = tabs.length; i >= 0; i--)
139499:       if (tabs[i] === tab) return i;
139499:   }
139499: }
139499: exports.getIndex = getIndex;
139499: 
139499: function move(tab, index) {
139499:   let gBrowser = getTabBrowserForTab(tab);
139499:   // Firefox
139499:   if (gBrowser) gBrowser.moveTabTo(tab, index);
139499:   // TODO: Implement fennec support
139499: }
139499: exports.move = move;
