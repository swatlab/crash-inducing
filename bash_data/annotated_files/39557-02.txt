16297: /*
16297:    Copyright (C) 2003 Commonwealth Scientific and Industrial Research
16297:    Organisation (CSIRO) Australia
16297: 
16297:    Redistribution and use in source and binary forms, with or without
16297:    modification, are permitted provided that the following conditions
16297:    are met:
16297: 
16297:    - Redistributions of source code must retain the above copyright
16297:    notice, this list of conditions and the following disclaimer.
16297: 
16297:    - Redistributions in binary form must reproduce the above copyright
16297:    notice, this list of conditions and the following disclaimer in the
16297:    documentation and/or other materials provided with the distribution.
16297: 
16297:    - Neither the name of CSIRO Australia nor the names of its
16297:    contributors may be used to endorse or promote products derived from
16297:    this software without specific prior written permission.
16297: 
16297:    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
16297:    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
16297:    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
16297:    PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE ORGANISATION OR
16297:    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
16297:    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
16297:    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
16297:    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
16297:    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
16297:    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
16297:    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
16297: */
16297: 
16297: /*
16297:  * oggz_auto.c
16297:  *
16297:  * Conrad Parker <conrad@annodex.net>
16297:  */
16297: 
16297: #include "config.h"
16297: 
16297: #include <stdlib.h>
16297: #include <string.h>
16297: 
16297: #include "oggz_private.h"
16297: #include "oggz_byteorder.h"
25689: #include "dirac.h"
16297: 
32523: #include "oggz/oggz_stream.h"
16297: 
16297: /*#define DEBUG*/
16297: 
16297: /* Allow use of internal metrics; ie. the user_data for these gets free'd
16297:  * when the metric is overwritten, or on close */
16297: int oggz_set_metric_internal (OGGZ * oggz, long serialno, OggzMetric metric,
16297: 			      void * user_data, int internal);
16297: 
16297: int oggz_set_metric_linear (OGGZ * oggz, long serialno,
16297: 			    ogg_int64_t granule_rate_numerator,
16297: 			    ogg_int64_t granule_rate_denominator);
16297: 
16297: static int
16297: oggz_stream_set_numheaders (OGGZ * oggz, long serialno, int numheaders)
16297: {
16297:   oggz_stream_t * stream;
16297: 
16297:   if (oggz == NULL) return OGGZ_ERR_BAD_OGGZ;
16297: 
16297:   stream = oggz_get_stream (oggz, serialno);
16297:   if (stream == NULL) return OGGZ_ERR_BAD_SERIALNO;
16297: 
16297:   stream->numheaders = numheaders;
16297: 
16297:   return 0;
16297: }
16297: 
16297: static int
25689: auto_speex (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
25689:   unsigned char * header = data;
16297:   ogg_int64_t granule_rate = 0;
16297:   int numheaders;
16297: 
25689:   if (length < 68) return 0;
16297: 
32523:   granule_rate = (ogg_int64_t) int32_le_at(&header[36]);
16297: #ifdef DEBUG
16297:   printf ("Got speex rate %d\n", (int)granule_rate);
16297: #endif
16297: 
16297:   oggz_set_granulerate (oggz, serialno, granule_rate, OGGZ_AUTO_MULT);
16297: 
25689:   oggz_set_preroll (oggz, serialno, 3);
25689: 
32523:   numheaders = (ogg_int64_t) int32_le_at(&header[68]) + 2;
16297:   oggz_stream_set_numheaders (oggz, serialno, numheaders);
16297: 
16297:   return 1;
16297: }
16297: 
16297: static int
25689: auto_vorbis (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
25689:   unsigned char * header = data;
16297:   ogg_int64_t granule_rate = 0;
16297: 
25689:   if (length < 30) return 0;
16297: 
32523:   granule_rate = (ogg_int64_t) int32_le_at(&header[12]);
16297: #ifdef DEBUG
16297:   printf ("Got vorbis rate %d\n", (int)granule_rate);
16297: #endif
16297: 
16297:   oggz_set_granulerate (oggz, serialno, granule_rate, OGGZ_AUTO_MULT);
16297: 
25689:   oggz_set_preroll (oggz, serialno, 2);
25689: 
16297:   oggz_stream_set_numheaders (oggz, serialno, 3);
16297: 
16297:   return 1;
16297: }
16297: 
16297: #if USE_THEORA_PRE_ALPHA_3_FORMAT
16297: static int intlog(int num) {
16297:   int ret=0;
16297:   while(num>0){
16297:     num=num/2;
16297:     ret=ret+1;
16297:   }
16297:   return(ret);
16297: }
16297: #endif
16297: 
32523: #define THEORA_VERSION(maj,min,rev) ((maj<<16)+(min<<8)+rev)
32523: 
16297: static int
25689: auto_theora (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
25689:   unsigned char * header = data;
32523:   int version;
16297:   ogg_int32_t fps_numerator, fps_denominator;
16297:   char keyframe_granule_shift = 0;
16297:   int keyframe_shift;
16297: 
16297:   /* TODO: this should check against 42 for the relevant version numbers */
25689:   if (length < 41) return 0;
16297: 
32523:   version = THEORA_VERSION(header[7], header[8], header[9]);
32523: 
28230:   fps_numerator = int32_be_at(&header[22]);
28230:   fps_denominator = int32_be_at(&header[26]);
16297: 
16297:   /* Very old theora versions used a value of 0 to mean 1.
16297:    * Unfortunately theora hasn't incremented its version field,
16297:    * hence we hardcode this workaround for old or broken streams.
16297:    */
16297:   if (fps_numerator == 0) fps_numerator = 1;
16297: 
16297: #if USE_THEORA_PRE_ALPHA_3_FORMAT
16297:   /* old header format, used by Theora alpha2 and earlier */
16297:   keyframe_granule_shift = (header[36] & 0xf8) >> 3;
16297:   keyframe_shift = intlog (keyframe_granule_shift - 1);
16297: #else
16297:   keyframe_granule_shift = (char) ((header[40] & 0x03) << 3);
16297:   keyframe_granule_shift |= (header[41] & 0xe0) >> 5; /* see TODO above */
16297:   keyframe_shift = keyframe_granule_shift;
16297: #endif
16297: 
16297: #ifdef DEBUG
16297:   printf ("Got theora fps %d/%d, keyframe_shift %d\n",
16297: 	  fps_numerator, fps_denominator, keyframe_shift);
16297: #endif
16297: 
16297:   oggz_set_granulerate (oggz, serialno, (ogg_int64_t)fps_numerator,
16297: 			OGGZ_AUTO_MULT * (ogg_int64_t)fps_denominator);
16297:   oggz_set_granuleshift (oggz, serialno, keyframe_shift);
16297: 
32523:   if (version > THEORA_VERSION(3,2,0))
32523:     oggz_set_first_granule (oggz, serialno, 1);
25689: 
16297:   oggz_stream_set_numheaders (oggz, serialno, 3);
16297: 
16297:   return 1;
16297: }
16297: 
16297: static int
25689: auto_annodex (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
16297:   /* Apply a zero metric */
16297:   oggz_set_granulerate (oggz, serialno, 0, 1);
16297: 
16297:   return 1;
16297: }
16297: 
16297: static int
25689: auto_anxdata (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
25689:   unsigned char * header = data;
16297:   ogg_int64_t granule_rate_numerator = 0, granule_rate_denominator = 0;
16297: 
25689:   if (length < 28) return 0;
16297: 
32523:   granule_rate_numerator = int64_le_at(&header[8]);
32523:   granule_rate_denominator = int64_le_at(&header[16]);
16297: #ifdef DEBUG
16297:   printf ("Got AnxData rate %lld/%lld\n", granule_rate_numerator,
16297: 	  granule_rate_denominator);
16297: #endif
16297: 
16297:   oggz_set_granulerate (oggz, serialno,
16297: 			granule_rate_numerator,
16297: 			OGGZ_AUTO_MULT * granule_rate_denominator);
16297: 
16297:   return 1;
16297: }
16297: 
16297: static int
25689: auto_flac0 (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
25689:   unsigned char * header = data;
16297:   ogg_int64_t granule_rate = 0;
16297: 
16297:   granule_rate = (ogg_int64_t) (header[14] << 12) | (header[15] << 4) |
16297:             ((header[16] >> 4)&0xf);
16297: #ifdef DEBUG
16297:     printf ("Got flac rate %d\n", (int)granule_rate);
16297: #endif
16297: 
16297:   oggz_set_granulerate (oggz, serialno, granule_rate, OGGZ_AUTO_MULT);
16297: 
16297:   oggz_stream_set_numheaders (oggz, serialno, 3);
16297: 
16297:   return 1;
16297: }
16297: 
16297: static int
25689: auto_flac (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
25689:   unsigned char * header = data;
16297:   ogg_int64_t granule_rate = 0;
16297:   int numheaders;
16297: 
25689:   if (length < 51) return 0;
16297: 
16297:   granule_rate = (ogg_int64_t) (header[27] << 12) | (header[28] << 4) |
16297:             ((header[29] >> 4)&0xf);
16297: #ifdef DEBUG
16297:   printf ("Got flac rate %d\n", (int)granule_rate);
16297: #endif
16297: 
16297:   oggz_set_granulerate (oggz, serialno, granule_rate, OGGZ_AUTO_MULT);
16297: 
32523:   numheaders = int16_be_at(&header[7]);
16297:   oggz_stream_set_numheaders (oggz, serialno, numheaders);
16297: 
16297:   return 1;
16297: }
16297: 
16297: /**
16297:  * Recognizer for OggPCM2:
16297:  * http://wiki.xiph.org/index.php/OggPCM2
16297:  */
16297: static int
25689: auto_oggpcm2 (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
25689:   unsigned char * header = data;
16297:   ogg_int64_t granule_rate;
16297: 
25689:   if (length < 28) return 0;
16297: 
28230:   granule_rate = (ogg_int64_t) int32_be_at(&header[16]);
16297: #ifdef DEBUG
16297:   printf ("Got OggPCM2 rate %d\n", (int)granule_rate);
16297: #endif
16297: 
16297:   oggz_set_granulerate (oggz, serialno, granule_rate, OGGZ_AUTO_MULT);
16297: 
16297:   oggz_stream_set_numheaders (oggz, serialno, 3);
16297: 
16297:   return 1;
16297: }
16297: 
16297: static int
25689: auto_celt (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
25689:   unsigned char * header = data;
16297:   ogg_int64_t granule_rate = 0;
16297:   int numheaders;
16297: 
25689:   if (length < 56) return 0;
16297: 
32523:   granule_rate = (ogg_int64_t) int32_le_at(&header[40]);
16297: #ifdef DEBUG
16297:   printf ("Got celt sample rate %d\n", (int)granule_rate);
16297: #endif
16297: 
16297:   oggz_set_granulerate (oggz, serialno, granule_rate, OGGZ_AUTO_MULT);
16297: 
32523:   numheaders = (ogg_int64_t) int32_le_at(&header[52]) + 2;
16297:   oggz_stream_set_numheaders (oggz, serialno, numheaders);
16297: 
16297:   return 1;
16297: }
16297: 
16297: static int
25689: auto_cmml (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
25689:   unsigned char * header = data;
16297:   ogg_int64_t granule_rate_numerator = 0, granule_rate_denominator = 0;
16297:   int granuleshift;
16297: 
25689:   if (length < 28) return 0;
16297: 
32523:   granule_rate_numerator = int64_le_at(&header[12]);
32523:   granule_rate_denominator = int64_le_at(&header[20]);
25689:   if (length > 28)
16297:     granuleshift = (int)header[28];
16297:   else
16297:     granuleshift = 0;
16297: 
16297: #ifdef DEBUG
16297:   printf ("Got CMML rate %lld/%lld\n", granule_rate_numerator,
16297: 	  granule_rate_denominator);
16297: #endif
16297: 
16297:   oggz_set_granulerate (oggz, serialno,
16297: 			granule_rate_numerator,
16297: 			OGGZ_AUTO_MULT * granule_rate_denominator);
16297:   oggz_set_granuleshift (oggz, serialno, granuleshift);
16297: 
16297:   oggz_stream_set_numheaders (oggz, serialno, 3);
16297: 
16297:   return 1;
16297: }
16297: 
16297: static int
25689: auto_kate (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
25689:   unsigned char * header = data;
16297:   ogg_int32_t gps_numerator, gps_denominator;
16297:   unsigned char granule_shift = 0;
16297:   int numheaders;
16297: 
25689:   if (length < 64) return 0;
16297: 
32523:   gps_numerator = int32_le_at(&header[24]);
32523:   gps_denominator = int32_le_at(&header[28]);
16297: 
16297:   granule_shift = (header[15]);
16297:   numheaders = (header[11]);
16297: 
16297: #ifdef DEBUG
16297:   printf ("Got kate gps %d/%d, granule shift %d\n",
16297: 	  gps_numerator, gps_denominator, granule_shift);
16297: #endif
16297: 
16297:   oggz_set_granulerate (oggz, serialno, gps_numerator,
16297: 			OGGZ_AUTO_MULT * gps_denominator);
16297:   oggz_set_granuleshift (oggz, serialno, granule_shift);
16297: 
16297:   oggz_stream_set_numheaders (oggz, serialno, numheaders);
16297: 
16297:   return 1;
16297: }
16297: 
16297: static int
25689: auto_dirac (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
25689:   int granule_shift = 22; /* not a typo */
25689:   dirac_info *info;
25689: 
25689:   info = oggz_malloc(sizeof(dirac_info));
25689:   if (info == NULL) return -1;
25689: 
32523:   if (dirac_parse_info(info, data, length) == -1)
32523:     return -1;
25689: 
25689:   /* the granulerate is twice the frame rate (in order to handle interlace) */
25689:   oggz_set_granulerate (oggz, serialno,
25689: 	2 * (ogg_int64_t)info->fps_numerator,
25689: 	OGGZ_AUTO_MULT * (ogg_int64_t)info->fps_denominator);
25689:   oggz_set_granuleshift (oggz, serialno, granule_shift);
25689: 
25689:   oggz_stream_set_numheaders (oggz, serialno, 0);
25689: 
25689:   oggz_free(info);
25689:   return 1;
25689: }
25689: 
25689: static int
25689: auto_fisbone (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
25689: {
25689:   unsigned char * header = data;
16297:   long fisbone_serialno; /* The serialno referred to in this fisbone */
16297:   ogg_int64_t granule_rate_numerator = 0, granule_rate_denominator = 0;
16297:   int granuleshift, numheaders;
16297: 
25689:   if (length < 48) return 0;
16297: 
32523:   fisbone_serialno = (long) int32_le_at(&header[12]);
16297: 
16297:   /* Don't override an already assigned metric */
16297:   if (oggz_stream_has_metric (oggz, fisbone_serialno)) return 1;
16297: 
32523:   granule_rate_numerator = int64_le_at(&header[20]);
32523:   granule_rate_denominator = int64_le_at(&header[28]);
16297:   granuleshift = (int)header[48];
16297: 
16297: #ifdef DEBUG
25689:   printf ("Got fisbone granulerate %lld/%lld, granuleshift %d for serialno %010lu\n",
16297: 	  granule_rate_numerator, granule_rate_denominator, granuleshift,
16297: 	  fisbone_serialno);
16297: #endif
16297: 
16297:   oggz_set_granulerate (oggz, fisbone_serialno,
16297: 			granule_rate_numerator,
16297: 			OGGZ_AUTO_MULT * granule_rate_denominator);
16297:   oggz_set_granuleshift (oggz, fisbone_serialno, granuleshift);
16297: 
16297:   /* Increment the number of headers for this stream */
16297:   numheaders = oggz_stream_get_numheaders (oggz, serialno);
16297:   oggz_stream_set_numheaders (oggz, serialno, numheaders+1);
16297: 
16297:   return 1;
16297: }
16297: 
16297: static int
25689: auto_fishead (OGGZ * oggz, long serialno, unsigned char * data, long length, void * user_data)
16297: {
16297:   oggz_set_granulerate (oggz, serialno, 0, 1);
16297: 
16297:   /* For skeleton, numheaders will get incremented as each header is seen */
16297:   oggz_stream_set_numheaders (oggz, serialno, 1);
16297: 
16297:   return 1;
16297: }
16297: 
16297: /*
16297:  * The first two speex packets are header and comment packets (granulepos = 0)
16297:  */
16297: 
16297: typedef struct {
16297:   int headers_encountered;
16297:   int packet_size;
16297:   int encountered_first_data_packet;
16297: } auto_calc_speex_info_t;
16297: 
16297: static ogg_int64_t
16297: auto_calc_speex(ogg_int64_t now, oggz_stream_t *stream, ogg_packet *op) {
16297: 
16297:   /*
16297:    * on the first (b_o_s) packet, set calculate_data to be the number
16297:    * of speex frames per packet
16297:    */
16297: 
16297:   auto_calc_speex_info_t *info
16297:           = (auto_calc_speex_info_t *)stream->calculate_data;
16297: 
16297:   if (stream->calculate_data == NULL) {
25689:     stream->calculate_data = oggz_malloc(sizeof(auto_calc_speex_info_t));
25689:     if (stream->calculate_data == NULL) return -1;
16297:     info = stream->calculate_data;
16297:     info->encountered_first_data_packet = 0;
16297:     info->packet_size =
16297:             (*(int *)(op->packet + 64)) * (*(int *)(op->packet + 56));
16297:     info->headers_encountered = 1;
16297:     return 0;
16297:   }
16297: 
16297:   if (info->headers_encountered < 2) {
16297:     info->headers_encountered += 1;
16297:   } else {
16297:     info->encountered_first_data_packet = 1;
16297:   }
16297: 
16297:   if (now > -1) {
16297:     return now;
16297:   }
16297: 
16297:   if (info->encountered_first_data_packet) {
16297:     if (stream->last_granulepos > 0) {
16297:       return stream->last_granulepos + info->packet_size;
16297:     }
16297: 
16297:     return -1;
16297:   }
16297: 
16297:   return 0;
16297: 
16297: }
16297: 
16297: /*
16297:  * The first two CELT packets are header and comment packets (granulepos = 0)
16297:  */
16297: 
16297: typedef struct {
16297:   int headers_encountered;
16297:   int packet_size;
16297:   int encountered_first_data_packet;
16297: } auto_calc_celt_info_t;
16297: 
16297: static ogg_int64_t
16297: auto_calc_celt (ogg_int64_t now, oggz_stream_t *stream, ogg_packet *op) {
16297: 
16297:   /*
16297:    * on the first (b_o_s) packet, set calculate_data to be the number
16297:    * of celt frames per packet
16297:    */
16297: 
16297:   auto_calc_celt_info_t *info
16297:           = (auto_calc_celt_info_t *)stream->calculate_data;
16297: 
16297:   if (stream->calculate_data == NULL) {
25689:     stream->calculate_data = oggz_malloc(sizeof(auto_calc_celt_info_t));
25689:     if (stream->calculate_data == NULL) return -1;
25689: 
16297:     info = stream->calculate_data;
16297:     info->encountered_first_data_packet = 0;
16297: 
16297:     /* In general, the number of frames per packet depends on the mode.
16297:      * Currently (20080213) both available modes, mono and stereo, have 256
16297:      * frames per packet.
16297:      */
16297:     info->packet_size = 256;
16297: 
16297:     info->headers_encountered = 1;
16297:     return 0;
16297:   }
16297: 
16297:   if (info->headers_encountered < 2) {
16297:     info->headers_encountered += 1;
16297:   } else {
16297:     info->encountered_first_data_packet = 1;
16297:   }
16297: 
16297:   if (now > -1) {
16297:     return now;
16297:   }
16297: 
16297:   if (info->encountered_first_data_packet) {
16297:     if (stream->last_granulepos > 0) {
16297:       return stream->last_granulepos + info->packet_size;
16297:     }
16297: 
16297:     return -1;
16297:   }
16297: 
16297:   return 0;
16297: 
16297: }
16297: /*
16297:  * Header packets are marked by a set MSB in the first byte.  Inter packets
16297:  * are marked by a set 2MSB in the first byte.  Intra packets (keyframes)
16297:  * are any that are left over ;-)
16297:  *
26921:  * (see http://theora.org/doc/Theora.pdf for the theora specification)
16297:  */
16297: 
16297: typedef struct {
16297:   int encountered_first_data_packet;
16297: } auto_calc_theora_info_t;
16297: 
16297: 
16297: static ogg_int64_t
16297: auto_calc_theora(ogg_int64_t now, oggz_stream_t *stream, ogg_packet *op) {
16297: 
16297:   long keyframe_no;
16297:   int keyframe_shift;
16297:   unsigned char first_byte;
16297:   auto_calc_theora_info_t *info;
16297: 
32931:   first_byte = op->bytes == 0 ? 0x40 : op->packet[0];
16297: 
16297:   info = (auto_calc_theora_info_t *)stream->calculate_data;
16297: 
16297:   /* header packet */
16297:   if (first_byte & 0x80)
16297:   {
16297:     if (info == NULL) {
25689:       stream->calculate_data = oggz_malloc(sizeof(auto_calc_theora_info_t));
25689:       if (stream->calculate_data == NULL) return -1;
16297:       info = stream->calculate_data;
16297:     }
16297:     info->encountered_first_data_packet = 0;
16297:     return (ogg_int64_t)0;
16297:   }
16297: 
16297:   /* known granulepos */
16297:   if (now > (ogg_int64_t)(-1)) {
16297:     info->encountered_first_data_packet = 1;
16297:     return now;
16297:   }
16297: 
16297:   /* last granulepos unknown */
16297:   if (stream->last_granulepos == -1) {
16297:     info->encountered_first_data_packet = 1;
16297:     return (ogg_int64_t)-1;
16297:   }
16297: 
16297:   /*
16297:    * first data packet is -1 if gp not set
16297:    */
16297:   if (!info->encountered_first_data_packet) {
16297:     info->encountered_first_data_packet = 1;
16297:     return (ogg_int64_t)-1;
16297:   }
16297: 
16297:   /* inter-coded packet */
16297:   if (first_byte & 0x40)
16297:   {
16297:     return stream->last_granulepos + 1;
16297:   }
16297: 
16297:   keyframe_shift = stream->granuleshift;
16297:   /*
16297:    * retrieve last keyframe number
16297:    */
16297:   keyframe_no = (int)(stream->last_granulepos >> keyframe_shift);
16297:   /*
16297:    * add frames since last keyframe number
16297:    */
16297:   keyframe_no += (stream->last_granulepos & ((1 << keyframe_shift) - 1)) + 1;
16297:   return ((ogg_int64_t)keyframe_no) << keyframe_shift;
16297: 
16297: 
16297: }
16297: 
16297: static ogg_int64_t
16297: auto_rcalc_theora(ogg_int64_t next_packet_gp, oggz_stream_t *stream,
16297:                   ogg_packet *this_packet, ogg_packet *next_packet) {
16297: 
16297:   int keyframe = (int)(next_packet_gp >> stream->granuleshift);
16297:   int offset = (int)(next_packet_gp - (keyframe << stream->granuleshift));
16297: 
16297:   /* assume kf is 60 frames ago. NOTE: This is going to cause problems,
16297:    * but I can't think of what else to do.  The position of the last kf
16297:    * is fundamentally unknowable.
16297:    */
16297:   if (offset == 0) {
16297:     return ((keyframe - 60L) << stream->granuleshift) + 59;
16297:   }
16297:   else {
16297:     return (((ogg_int64_t)keyframe) << stream->granuleshift) + (offset - 1);
16297:   }
16297: 
16297: }
16297: 
16297: 
16297: /*
16297:  * Vorbis packets can be short or long, and each packet overlaps the previous
16297:  * and next packets.  The granulepos of a packet is always the last sample
16297:  * that is completely decoded at the end of decoding that packet - i.e. the
16297:  * last packet before the first overlapping packet.  If the sizes of packets
16297:  * are 's' and 'l', then the increment will depend on the previous and next
16297:  * packet types:
16297:  *  v                             prev<<1 | next
16297:  * lll:           l/2             3
16297:  * lls:           3l/4 - s/4      2
16297:  * lsl:           s/2
16297:  * lss:           s/2
16297:  * sll:           l/4 + s/4       1
16297:  * sls:           l/2             0
16297:  * ssl:           s/2
16297:  * sss:           s/2
16297:  *
16297:  * The previous and next packet types can be inferred from the current packet
16297:  * (additional information is not required)
16297:  *
16297:  * The two blocksizes can be determined from the first header packet, by reading
16297:  * byte 28.  1 << (packet[28] >> 4) == long_size.
16297:  * 1 << (packet[28] & 0xF) == short_size.
16297:  *
16297:  * (see http://xiph.org/vorbis/doc/Vorbis_I_spec.html for specification)
16297:  */
16297: 
16297: typedef struct {
16297:   int nln_increments[4];
16297:   int nsn_increment;
16297:   int short_size;
16297:   int long_size;
16297:   int encountered_first_data_packet;
16297:   int last_was_long;
16297:   int log2_num_modes;
39557:   int mode_sizes_length;
16297:   int mode_sizes[1];
16297: } auto_calc_vorbis_info_t;
16297: 
16297: 
16297: static ogg_int64_t
16297: auto_calc_vorbis(ogg_int64_t now, oggz_stream_t *stream, ogg_packet *op) {
16297: 
16297:   auto_calc_vorbis_info_t *info;
26921:   int ii;
16297: 
16297:   if (stream->calculate_data == NULL) {
16297:     /*
16297:      * on the first (b_o_s) packet, determine the long and short sizes,
16297:      * and then calculate l/2, l/4 - s/4, 3 * l/4 - s/4, l/2 - s/2 and s/2
16297:      */
16297:     int short_size;
16297:     int long_size;
16297: 
16297:     long_size = 1 << (op->packet[28] >> 4);
16297:     short_size = 1 << (op->packet[28] & 0xF);
16297: 
25689:     stream->calculate_data = oggz_malloc(sizeof(auto_calc_vorbis_info_t));
25689:     if (stream->calculate_data == NULL) return -1;
25689: 
16297:     info = (auto_calc_vorbis_info_t *)stream->calculate_data;
16297:     info->nln_increments[3] = long_size >> 1;
16297:     info->nln_increments[2] = 3 * (long_size >> 2) - (short_size >> 2);
16297:     info->nln_increments[1] = (long_size >> 2) + (short_size >> 2);
16297:     info->nln_increments[0] = info->nln_increments[3];
16297:     info->short_size = short_size;
16297:     info->long_size = long_size;
16297:     info->nsn_increment = short_size >> 1;
16297:     info->encountered_first_data_packet = 0;
39557:     info->mode_sizes_length = 0;
16297: 
16297:     /* this is a header packet */
16297:     return 0;
16297:   }
16297: 
16297:   /*
16297:    * marker for header packets
16297:    */
16297:   if (op->packet[0] & 0x1) {
16297:     /*
16297:      * the code pages, a whole bunch of other fairly useless stuff, AND,
16297:      * RIGHT AT THE END (of a bunch of variable-length compressed rubbish that
16297:      * basically has only one actual set of values that everyone uses BUT YOU
16297:      * CAN'T BE SURE OF THAT, OH NO YOU CAN'T) is the only piece of data that's
16297:      * actually useful to us - the packet modes (because it's inconceivable to
16297:      * think people might want _just that_ and nothing else, you know, for
16297:      * seeking and stuff).
16297:      *
16297:      * Fortunately, because of the mandate that non-used bits must be zero
16297:      * at the end of the packet, we might be able to sneakily work backwards
16297:      * and find out the information we need (namely a mapping of modes to
16297:      * packet sizes)
16297:      */
16297:     if (op->packet[0] == 5) {
16297:       unsigned char *current_pos = &op->packet[op->bytes - 1];
16297:       int offset;
16297:       int size;
16297:       int size_check;
16297:       int *mode_size_ptr;
16297:       int i;
25689:       size_t size_realloc_bytes;
16297: 
16297:       /*
16297:        * This is the format of the mode data at the end of the packet for all
16297:        * Vorbis Version 1 :
16297:        *
16297:        * [ 6:number_of_modes ]
16297:        * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]
16297:        * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]
16297:        * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]
16297:        * [ 1:framing(1) ]
16297:        *
16297:        * e.g.:
16297:        *
16297:        *              <-
16297:        * 0 0 0 0 0 1 0 0
16297:        * 0 0 1 0 0 0 0 0
16297:        * 0 0 1 0 0 0 0 0
16297:        * 0 0 1|0 0 0 0 0
16297:        * 0 0 0 0|0|0 0 0
16297:        * 0 0 0 0 0 0 0 0
16297:        * 0 0 0 0|0 0 0 0
16297:        * 0 0 0 0 0 0 0 0
16297:        * 0 0 0 0|0 0 0 0
16297:        * 0 0 0|1|0 0 0 0 |
16297:        * 0 0 0 0 0 0 0 0 V
16297:        * 0 0 0|0 0 0 0 0
16297:        * 0 0 0 0 0 0 0 0
16297:        * 0 0 1|0 0 0 0 0
16297:        * 0 0|1|0 0 0 0 0
16297:        *
16297:        *
16297:        * i.e. each entry is an important bit, 32 bits of 0, 8 bits of blah, a
16297:        * bit of 1.
16297:        * Let's find our last 1 bit first.
16297:        *
16297:        */
16297: 
16297:       size = 0;
16297: 
16297:       offset = 8;
16297:       while (!((1 << --offset) & *current_pos)) {
16297:         if (offset == 0) {
16297:           offset = 8;
16297:           current_pos -= 1;
16297:         }
16297:       }
16297: 
16297:       while (1)
16297:       {
16297: 
16297:         /*
16297:          * from current_pos-5:(offset+1) to current_pos-1:(offset+1) should
16297:          * be zero
16297:          */
16297:         offset = (offset + 7) % 8;
16297:         if (offset == 7)
16297:           current_pos -= 1;
16297: 
16297:         if
16297:         (
16297:           ((current_pos[-5] & ~((1 << (offset + 1)) - 1)) != 0)
16297:           ||
16297:           current_pos[-4] != 0
16297:           ||
16297:           current_pos[-3] != 0
16297:           ||
16297:           current_pos[-2] != 0
16297:           ||
16297:           ((current_pos[-1] & ((1 << (offset + 1)) - 1)) != 0)
16297:         )
16297:         {
16297:           break;
16297:         }
16297: 
16297:         size += 1;
16297: 
16297:         current_pos -= 5;
16297: 
16297:       }
16297: 
26921:       /* Give ourselves a chance to recover if we went back too far by using
26921:        * the size check. */
26921:       for (ii=0; ii < 2; ii++) {
16297:        if (offset > 4) {
16297:          size_check = (current_pos[0] >> (offset - 5)) & 0x3F;
16297:        } else {
16297:          /* mask part of byte from current_pos */
16297:          size_check = (current_pos[0] & ((1 << (offset + 1)) - 1));
16297:          /* shift to appropriate position */
16297:          size_check <<= (5 - offset);
16297:          /* or in part of byte from current_pos - 1 */
16297:          size_check |= (current_pos[-1] & ~((1 << (offset + 3)) - 1)) >>
16297:            (offset + 3);
16297:        }
16297: 
16297:        size_check += 1;
26921:        if (size_check == size) {
26921:          break;
26921:        }
26921:         offset = (offset + 1) % 8;
26921:         if (offset == 0)
26921:           current_pos += 1;
26921:        current_pos += 5;
26921:        size -= 1;
26921:       }
26921: 
21008: #ifdef DEBUG
16297:       if (size_check != size)
16297:       {
16297:         printf("WARNING: size parsing failed for VORBIS mode packets\n");
16297:       }
21008: #endif
16297: 
25689:       /* Check that size to be realloc'd doesn't overflow */
25689:       size_realloc_bytes = sizeof(auto_calc_vorbis_info_t) + (size - 1) * sizeof(int);
25689:       if (size_realloc_bytes < sizeof (auto_calc_vorbis_info_t)) return -1;
25689: 
25689:       /* Store mode size information in our info struct */
25689:       info = realloc(stream->calculate_data, size_realloc_bytes);
25689:       if (info == NULL) return -1;
25689: 
39557:       info->mode_sizes_length = size + 1;
25689:       stream->calculate_data = info;
16297: 
16297:       i = -1;
16297:       while ((1 << (++i)) < size);
16297:       info->log2_num_modes = i;
16297: 
16297:       mode_size_ptr = info->mode_sizes;
16297: 
16297:       for(i = 0; i < size; i++)
16297:       {
16297:         offset = (offset + 1) % 8;
16297:         if (offset == 0)
16297:           current_pos += 1;
16297:         *mode_size_ptr++ = (current_pos[0] >> offset) & 0x1;
16297:         current_pos += 5;
16297:       }
16297: 
16297:     }
16297: 
16297:     return 0;
16297:   }
16297: 
16297:   return -1;
16297: }
16297: 
16297: ogg_int64_t
16297: auto_rcalc_vorbis(ogg_int64_t next_packet_gp, oggz_stream_t *stream,
16297:                   ogg_packet *this_packet, ogg_packet *next_packet) {
16297: 
16297:   auto_calc_vorbis_info_t *info =
16297:                   (auto_calc_vorbis_info_t *)stream->calculate_data;
16297: 
16297:   int mode =
16297:       (this_packet->packet[0] >> 1) & ((1 << info->log2_num_modes) - 1);
39557:   if (info->mode_sizes_length == 0 || mode < 0 || mode >= info->mode_sizes_length)
39557:     return 0;
16297:   int this_size = info->mode_sizes[mode] ? info->long_size : info->short_size;
16297:   int next_size;
16297:   ogg_int64_t r;
16297: 
16297:   mode = (next_packet->packet[0] >> 1) & ((1 << info->log2_num_modes) - 1);
39557:   if (info->mode_sizes_length == 0 || mode < 0 || mode >= info->mode_sizes_length)
39557:     return 0;
16297:   next_size = info->mode_sizes[mode] ? info->long_size : info->short_size;
16297: 
16297:   r = next_packet_gp - ((this_size + next_size) / 4);
16297:   if (r < 0) return 0L;
16297:   return r;
16297: 
16297: }
16297: 
16297: /**
16297:  * FLAC
16297:  * Defined at: http://flac.sourceforge.net/ogg_mapping.html
16297:  *   - Native FLAC audio frames appear as subsequent packets in the stream.
16297:  *     Each packet corresponds to one FLAC audio frame.
16297:  *   - FLAC packets may span page boundaries.
16297:  *
16297:  * The frame header defines block size
16297:  * http://flac.sourceforge.net/format.html#frame_header
16297:  *
16297:  * Note that most FLAC packets will have a granulepos, but rare cases exist
16297:  * where they don't. See for example
16297:  * http://rafb.net/paste/results/Pkib5w72.html
16297:  */
16297: 
16297: typedef struct {
16297:   ogg_int64_t previous_gp;
16297:   int encountered_first_data_packet;
16297: } auto_calc_flac_info_t;
16297: 
16297: static ogg_int64_t
16297: auto_calc_flac (ogg_int64_t now, oggz_stream_t *stream, ogg_packet *op)
16297: {
16297:   auto_calc_flac_info_t *info;
16297: 
16297:   if (stream->calculate_data == NULL) {
25689:     stream->calculate_data = oggz_malloc(sizeof(auto_calc_flac_info_t));
25689:     if (stream->calculate_data == NULL) return -1;
25689: 
16297:     info = (auto_calc_flac_info_t *)stream->calculate_data;
16297:     info->previous_gp = 0;
16297:     info->encountered_first_data_packet = 0;
16297: 
16297:     /* this is a header packet */
16297:     goto out;
16297:   }
16297: 
16297:   info = (auto_calc_flac_info_t *)stream->calculate_data;
16297: 
16297:   /* FLAC audio frames begin with marker 0xFF */
16297:   if (op->packet[0] == 0xff)
16297:       info->encountered_first_data_packet = 1;
16297: 
16297:   if (now == -1 && op->packet[0] == 0xff && op->bytes > 2) {
16297:     unsigned char bs;
16297:     int block_size;
16297: 
16297:     bs = (op->packet[2] & 0xf0) >> 4;
16297: 
16297:     switch (bs) {
16297:       case 0x0: /*   0000 : get from STREAMINFO metadata block */
16297:         block_size = -1;
16297:         break;
16297:       case 0x1: /* 0001 : 192 samples */
16297:         block_size = 192;
16297:         break;
16297:       /* 0010-0101 : 576 * (2^(n-2)) samples, i.e. 576/1152/2304/4608 */
16297:       case 0x2:
16297:         block_size = 576;
16297:         break;
16297:       case 0x3:
16297:         block_size = 1152;
16297:         break;
16297:       case 0x4:
16297:         block_size = 2304;
16297:         break;
16297:       case 0x5:
16297:         block_size = 4608;
16297:         break;
16297:       case 0x6: /* 0110 : get 8 bit (blocksize-1) from end of header */
16297:         block_size = -1;
16297:         break;
16297:       case 0x7: /* 0111 : get 16 bit (blocksize-1) from end of header */
16297:         block_size = -1;
16297:         break;
16297:       /* 1000-1111 : 256 * (2^(n-8)) samples, i.e. 256/512/1024/2048/4096/8192/16384/32768 */
16297:       case 0x8:
16297:         block_size = 256;
16297:         break;
16297:       case 0x9:
16297:         block_size = 512;
16297:         break;
16297:       case 0xa:
16297:         block_size = 1024;
16297:         break;
16297:       case 0xb:
16297:         block_size = 2048;
16297:         break;
16297:       case 0xc:
16297:         block_size = 4096;
16297:         break;
16297:       case 0xd:
16297:         block_size = 8192;
16297:         break;
16297:       case 0xe:
16297:         block_size = 16384;
16297:         break;
16297:       case 0xf:
16297:         block_size = 32768;
16297:         break;
16297:       default:
16297:         block_size = -1;
16297:         break;
16297:     }
16297: 
16297:     if (block_size != -1) {
16297:       now = info->previous_gp + block_size;
16297:     }
16297:   } else if (now == -1 && info->encountered_first_data_packet == 0) {
16297:     /* this is a header packet */
16297:     now = 0;
16297:   }
16297: 
16297: out:
16297:   info->previous_gp = now;
16297:   return now;
16297: }
16297: 
16297: const oggz_auto_contenttype_t oggz_auto_codec_ident[] = {
16297:   {"\200theora", 7, "Theora", auto_theora, auto_calc_theora, auto_rcalc_theora},
16297:   {"\001vorbis", 7, "Vorbis", auto_vorbis, auto_calc_vorbis, auto_rcalc_vorbis},
16297:   {"Speex", 5, "Speex", auto_speex, auto_calc_speex, NULL},
16297:   {"PCM     ", 8, "PCM", auto_oggpcm2, NULL, NULL},
16297:   {"CMML\0\0\0\0", 8, "CMML", auto_cmml, NULL, NULL},
16297:   {"Annodex", 8, "Annodex", auto_annodex, NULL, NULL},
16297:   {"fishead", 7, "Skeleton", auto_fishead, NULL, NULL},
16297:   {"fLaC", 4, "Flac0", auto_flac0, auto_calc_flac, NULL},
25689:   {"\177FLAC", 5, "Flac", auto_flac, auto_calc_flac, NULL},
16297:   {"AnxData", 7, "AnxData", auto_anxdata, NULL, NULL},
16297:   {"CELT    ", 8, "CELT", auto_celt, auto_calc_celt, NULL},
16297:   {"\200kate\0\0\0", 8, "Kate", auto_kate, NULL, NULL},
25689:   {"BBCD\0", 5, "Dirac", auto_dirac, NULL, NULL},
16297:   {"", 0, "Unknown", NULL, NULL, NULL}
16297: };
16297: 
16297: static int
16297: oggz_auto_identify (OGGZ * oggz, long serialno, unsigned char * data, long len)
16297: {
16297:   int i;
16297: 
16297:   for (i = 0; i < OGGZ_CONTENT_UNKNOWN; i++)
16297:   {
16297:     const oggz_auto_contenttype_t *codec = oggz_auto_codec_ident + i;
16297: 
16297:     if (len >= codec->bos_str_len &&
16297:         memcmp (data, codec->bos_str, codec->bos_str_len) == 0) {
16297: 
16297:       oggz_stream_set_content (oggz, serialno, i);
16297: 
16297:       return 1;
16297:     }
16297:   }
16297: 
16297:   oggz_stream_set_content (oggz, serialno, OGGZ_CONTENT_UNKNOWN);
16297:   return 0;
16297: }
16297: 
16297: int
16297: oggz_auto_identify_page (OGGZ * oggz, ogg_page *og, long serialno)
16297: {
16297:   return oggz_auto_identify (oggz, serialno, og->body, og->body_len);
16297: }
16297: 
16297: int
16297: oggz_auto_identify_packet (OGGZ * oggz, ogg_packet * op, long serialno)
16297: {
16297:   return oggz_auto_identify (oggz, serialno, op->packet, op->bytes);
16297: }
16297: 
16297: int
25689: oggz_auto_read_bos_page (OGGZ * oggz, ogg_page * og, long serialno,
16297:                          void * user_data)
16297: {
16297:   int content = 0;
16297: 
16297:   content = oggz_stream_get_content(oggz, serialno);
16297:   if (content < 0 || content >= OGGZ_CONTENT_UNKNOWN) {
16297:     return 0;
25689:   } else if (content == OGGZ_CONTENT_SKELETON && !ogg_page_bos(og)) {
25689:     return auto_fisbone(oggz, serialno, og->body, og->body_len, user_data);
25689:   } else {
25689:     return oggz_auto_codec_ident[content].reader(oggz, serialno, og->body, og->body_len, user_data);
25689:   }
16297: }
16297: 
25689: int
25689: oggz_auto_read_bos_packet (OGGZ * oggz, ogg_packet * op, long serialno,
25689:                            void * user_data)
25689: {
25689:   int content = 0;
25689: 
25689:   content = oggz_stream_get_content(oggz, serialno);
25689:   if (content < 0 || content >= OGGZ_CONTENT_UNKNOWN) {
16297:     return 0;
25689:   } else if (content == OGGZ_CONTENT_SKELETON && !op->b_o_s) {
25689:     return auto_fisbone(oggz, serialno, op->packet, op->bytes, user_data);
25689:   } else {
25689:     return oggz_auto_codec_ident[content].reader(oggz, serialno, op->packet, op->bytes, user_data);
25689:   }
16297: }
16297: 
16297: ogg_int64_t
16297: oggz_auto_calculate_granulepos(int content, ogg_int64_t now,
16297:                 oggz_stream_t *stream, ogg_packet *op) {
16297:   if (oggz_auto_codec_ident[content].calculator != NULL) {
16297:     ogg_int64_t r = oggz_auto_codec_ident[content].calculator(now, stream, op);
16297:     return r;
16297:   }
16297: 
16297:   return now;
16297: }
16297: 
16297: ogg_int64_t
16297: oggz_auto_calculate_gp_backwards(int content, ogg_int64_t next_packet_gp,
16297:       oggz_stream_t *stream, ogg_packet *this_packet, ogg_packet *next_packet) {
16297: 
16297:   if (oggz_auto_codec_ident[content].r_calculator != NULL) {
16297:     return oggz_auto_codec_ident[content].r_calculator(next_packet_gp,
16297:             stream, this_packet, next_packet);
16297:   }
16297: 
16297:   return 0;
16297: 
16297: }
16297: 
16297: int
16297: oggz_auto_read_comments (OGGZ * oggz, oggz_stream_t * stream, long serialno,
16297:                          ogg_packet * op)
16297: {
16297:   int offset = -1;
16297:   long len = -1;
16297: 
16297:   switch (stream->content) {
16297:     case OGGZ_CONTENT_VORBIS:
16297:       if (op->bytes > 7 && memcmp (op->packet, "\003vorbis", 7) == 0)
16297:         offset = 7;
16297:       break;
16297:     case OGGZ_CONTENT_SPEEX:
16297:       offset = 0; break;
16297:     case OGGZ_CONTENT_THEORA:
16297:       if (op->bytes > 7 && memcmp (op->packet, "\201theora", 7) == 0)
16297:         offset = 7;
16297:       break;
16297:     case OGGZ_CONTENT_KATE:
16297:       if (op->bytes > 9 && memcmp (op->packet, "\201kate\0\0\0", 8) == 0) {
16297:         /* we skip the reserved 0 byte after the signature */
16297:         offset = 9;
16297:       }
16297:       break;
16297:     case OGGZ_CONTENT_FLAC:
16297:       if (op->bytes > 4 && (op->packet[0] & 0x7) == 4) {
16297:         len = (op->packet[1]<<16) + (op->packet[2]<<8) + op->packet[3];
16297:         offset = 4;
16297:       }
16297:       break;
16297:     default:
16297:       break;
16297:   }
16297: 
16297:   /* The length of the comments to decode is the rest of the packet,
16297:    * unless otherwise determined (ie. for FLAC) */
16297:   if (len == -1)
16297:     len = op->bytes - offset;
16297: 
16297:   if (offset >= 0) {
16297:     oggz_comments_decode (oggz, serialno, op->packet+offset, len);
16297:   }
16297: 
16297:   return 0;
16297: }
16297: 
