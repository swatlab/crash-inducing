    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim:set ts=2 sts=2 sw=2 et cin: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
26617:  *   Ere Maijala <emaijala@kolumbus.fi>
    1:  *   Mark Hammond <markh@activestate.com>
    1:  *   Michael Lowe <michael.lowe@bigfoot.com>
    1:  *   Peter Bajusz <hyp-x@inf.bme.hu>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   Roy Yokoyama <yokoyama@netscape.com>
    1:  *   Makoto Kato  <m_kato@ga2.so-net.ne.jp>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Dainis Jonitis <Dainis_Jonitis@swh-t.lv>
    1:  *   Christian Biesinger <cbiesinger@web.de>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
24836:  *   Ningjie Chen <chenn@email.uc.edu>
29835:  *   Jim Mathies <jmathies@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
29835: /*
29841:  * nsWindow - Native window management and event handling.
29841:  * 
29835:  * nsWindow is organized into a set of major blocks and
29835:  * block subsections. The layout is as follows:
29835:  *
29835:  *  Includes
29835:  *  Variables
29835:  *  nsIWidget impl.
29835:  *     nsIWidget methods and utilities
29835:  *  nsSwitchToUIThread impl.
29835:  *     nsSwitchToUIThread methods and utilities
29835:  *  Moz events
29835:  *     Event initialization
29835:  *     Event dispatching
29835:  *  Native events
29835:  *     Wndproc(s)
29835:  *     Event processing
29835:  *     OnEvent event handlers
29835:  *  IME management and accessibility
29835:  *  Transparency
29835:  *  Popup hook handling
29835:  *  Misc. utilities
29835:  *  Child window impl.
29835:  *
29835:  * Search for "BLOCK:" to find major blocks.
29835:  * Search for "SECTION:" to find specific sections.
29835:  *
29835:  * Blocks should be split out into separate files if they
29835:  * become unmanageable.
29835:  *
29835:  * Related source:
29835:  *
29835:  *  nsWindowDefs.h     - Definitions, macros, structs, enums
29835:  *                       and general setup.
29835:  *  nsWindowDbg.h/.cpp - Debug related code and directives.
29835:  *  nsWindowGfx.h/.cpp - Graphics and painting.
29835:  *  nsWindowCE.h/.cpp  - WINCE specific code that can be
29835:  *                       split out from nsWindow.
29835:  *
29835:  */
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Includes
29835:  **
29835:  ** Include headers.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
    1: #include "nsWindow.h"
29835: 
29835: #include <windows.h>
29835: #include <process.h>
29835: #include <commctrl.h>
29835: #include <unknwn.h>
29835: 
29835: #include "prlog.h"
29835: #include "prtime.h"
29835: #include "prprf.h"
29835: #include "prmem.h"
29835: 
    1: #include "nsIAppShell.h"
29835: #include "nsISupportsPrimitives.h"
29835: #include "nsIDOMNSUIEvent.h"
29835: #include "nsITheme.h"
29835: #include "nsIImage.h"
29835: #include "nsIPrefBranch.h"
29835: #include "nsIPrefService.h"
29835: #include "nsIObserverService.h"
29835: #include "nsIScreenManager.h"
29835: #include "imgIContainer.h"
29835: #include "gfxIImageFrame.h"
29835: #include "nsIFile.h"
29835: #include "nsIRollupListener.h"
29835: #include "nsIMenuRollup.h"
29835: #include "nsIRegion.h"
29835: #include "nsIServiceManager.h"
29835: #include "nsIClipboard.h"
29835: #include "nsIMM32Handler.h"
29835: #include "nsILocalFile.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsIFontEnumerator.h"
29835: #include "nsIDeviceContext.h"
29835: 
29835: #include "nsGUIEvent.h"
    1: #include "nsFont.h"
    1: #include "nsRect.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsNativeCharsetUtils.h"
    1: #include "nsWidgetAtoms.h"
14799: #include "nsUnicharUtils.h"
29835: #include "nsCRT.h"
29835: #include "nsAppDirectoryServiceDefs.h"
29835: #include "nsXPIDLString.h"
29835: #include "nsWidgetsCID.h"
29835: 
29835: #if defined(WINCE)
29835: #include "nsWindowCE.h"
27652: #endif
27652: 
29835: #include "nsWindowGfx.h"
29835: 
29835: #if !defined(WINCE)
23335: #include "nsUXThemeData.h"
26576: #include "nsUXThemeConstants.h"
23335: #include "nsKeyboardLayout.h"
23335: #include "nsNativeDragTarget.h"
29835: #include <mmsystem.h> // needed for WIN32_LEAN_AND_MEAN
29835: #include <zmouse.h>
23335: #include <pbt.h>
29835: #endif // !defined(WINCE)
29835: 
29835: #if defined(ACCESSIBILITY)
    1: #include "OLEIDL.H"
 7756: #include <winuser.h>
29835: #if !defined(WINABLEAPI)
 7756: #include <winable.h>
29835: #endif // !defined(WINABLEAPI)
    1: #include "nsIAccessible.h"
    1: #include "nsIAccessibleDocument.h"
    1: #include "nsIAccessNode.h"
29835: #endif // defined(ACCESSIBILITY)
29835: 
29835: #if defined(NS_ENABLE_TSF)
29835: #include "nsTextStore.h"
29835: #endif // defined(NS_ENABLE_TSF)
29835: 
29835: #if defined(MOZ_SPLASHSCREEN)
29835: #include "nsSplashScreen.h"
29835: #endif // defined(MOZ_SPLASHSCREEN)
29835: 
29835: // Windowless plugin support
    1: #include "nsplugindefs.h"
    1: 
29835: #include "nsWindowDefs.h"
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Variables
29835:  **
29835:  ** nsWindow Class static initializations and global variables. 
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsWindow statics
29835:  *
29835:  **************************************************************/
29835: 
    1: PRUint32        nsWindow::sInstanceCount          = 0;
29835: PRBool          nsWindow::sSwitchKeyboardLayout   = PR_FALSE;
    1: BOOL            nsWindow::sIsRegistered           = FALSE;
    1: BOOL            nsWindow::sIsPopupClassRegistered = FALSE;
 7271: BOOL            nsWindow::sIsOleInitialized       = FALSE;
29835: HCURSOR         nsWindow::sHCursor                = NULL;
29835: imgIContainer*  nsWindow::sCursorImgContainer     = nsnull;
29835: nsWindow*       nsWindow::sCurrentWindow          = nsnull;
29835: PRBool          nsWindow::sJustGotDeactivate      = PR_FALSE;
29835: PRBool          nsWindow::sJustGotActivate        = PR_FALSE;
29835: 
29835: // imported in nsWidgetFactory.cpp
29835: TriStateBool    nsWindow::sCanQuit                = TRI_UNKNOWN;
29835: 
29835: // Hook Data Memebers for Dropdowns. sProcessHook Tells the
29835: // hook methods whether they should be processing the hook
29835: // messages.
29835: HHOOK           nsWindow::sMsgFilterHook          = NULL;
29835: HHOOK           nsWindow::sCallProcHook           = NULL;
29835: HHOOK           nsWindow::sCallMouseHook          = NULL;
29835: PRPackedBool    nsWindow::sProcessHook            = PR_FALSE;
29835: UINT            nsWindow::sRollupMsgId            = 0;
29835: HWND            nsWindow::sRollupMsgWnd           = NULL;
29835: UINT            nsWindow::sHookTimerId            = 0;
29835: 
29835: // Rollup Listener
29835: nsIRollupListener* nsWindow::sRollupListener      = nsnull;
29835: nsIWidget*      nsWindow::sRollupWidget           = nsnull;
29835: PRBool          nsWindow::sRollupConsumeEvent     = PR_FALSE;
29835: 
29835: // Mouse Clicks - static variable definitions for figuring
29835: // out 1 - 3 Clicks.
29835: POINT           nsWindow::sLastMousePoint         = {0};
29835: POINT           nsWindow::sLastMouseMovePoint     = {0};
29835: LONG            nsWindow::sLastMouseDownTime      = 0L;
29835: LONG            nsWindow::sLastClickCount         = 0L;
29835: BYTE            nsWindow::sLastMouseButton        = 0;
29835: 
29835: // Trim heap on minimize. (initialized, but still true.)
29835: int             nsWindow::sTrimOnMinimize         = 2;
    1: 
    1: #ifdef ACCESSIBILITY
29835: BOOL            nsWindow::sIsAccessibilityOn      = FALSE;
29835: // Accessibility wm_getobject handler
29835: HINSTANCE       nsWindow::sAccLib                 = 0;
29835: LPFNLRESULTFROMOBJECT 
29835:                 nsWindow::sLresultFromObject      = 0;
29835: #endif // ACCESSIBILITY
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: globals variables
29835:  *
29835:  **************************************************************/
29835: 
29835: static const char *sScreenManagerContractID       = "@mozilla.org/gfx/screenmanager;1";
29835: 
29835: #ifdef PR_LOGGING
29835: PRLogModuleInfo* gWindowsLog                      = nsnull;
    1: #endif
29835: 
27326: #ifndef WINCE
29835: // Kbd layout. Used throughout character processing.
29835: static KeyboardLayout gKbdLayout;
27326: #endif
29835: 
29835: // The last user input event time in microseconds. If
29835: // there are any pending native toolkit input events
29835: // it returns the current time. The value is compatible
29835: // with PR_IntervalToMicroseconds(PR_IntervalNow()).
29835: #if !defined(WINCE)
29835: static PRUint32 gLastInputEventTime               = 0;
29835: #else
27326: PRUint32        gLastInputEventTime               = 0;
    1: #endif
29835: 
29835: // Global user preference for disabling native theme. Used
29835: // in NativeWindowTheme.
29835: PRBool          gDisableNativeTheme               = PR_FALSE;
29835: 
29835: // Global used in Show window enumerations.
29835: static PRBool   gWindowsVisible                   = PR_FALSE;
29835: 
29835: static NS_DEFINE_CID(kCClipboardCID, NS_CLIPBOARD_CID);
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: nsIWidget impl.
29835:  **
29835:  ** nsIWidget interface implementation, broken down into
29835:  ** sections.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsWindow construction and destruction
29835:  *
29835:  **************************************************************/
29835: 
29835: nsWindow::nsWindow() : nsBaseWidget()
29835: {
29835: #ifdef PR_LOGGING
29835:   if (!gWindowsLog)
29835:     gWindowsLog = PR_NewLogModule("nsWindowsWidgets");
    1: #endif
    1: 
29835:   mWnd                  = nsnull;
29835:   mPaintDC              = nsnull;
29835:   mPrevWndProc          = nsnull;
29835:   mDeferredPositioner   = nsnull;
29835:   mOldIMC               = nsnull;
29835:   mNativeDragTarget     = nsnull;
30223:   mInDtor               = PR_FALSE;
29835:   mIsVisible            = PR_FALSE;
29835:   mHas3DBorder          = PR_FALSE;
29835:   mIsInMouseCapture     = PR_FALSE;
29835:   mIsPluginWindow       = PR_FALSE;
29835:   mIsTopWidgetWindow    = PR_FALSE;
29835:   mInWheelProcessing    = PR_FALSE;
29835:   mUnicodeWidget        = PR_TRUE;
29835:   mWindowType           = eWindowType_child;
29835:   mBorderStyle          = eBorderStyle_default;
29835:   mPopupType            = ePopupTypeAny;
    1:   mLastPoint.x          = 0;
    1:   mLastPoint.y          = 0;
    1:   mLastSize.width       = 0;
    1:   mLastSize.height      = 0;
    1:   mOldStyle             = 0;
    1:   mOldExStyle           = 0;
    1:   mPainting             = 0;
29835:   mLastKeyboardLayout   = 0;
29835:   mBlurSuppressLevel    = 0;
15919:   mIMEEnabled           = nsIWidget::IME_STATUS_ENABLED;
    1:   mLeadByte             = '\0';
29835: #ifdef MOZ_XUL
29835:   mTransparentSurface   = nsnull;
29835:   mMemoryDC             = nsnull;
29835:   mTransparencyMode     = eTransparencyOpaque;
29835: #endif
29835:   mBackground           = ::GetSysColor(COLOR_BTNFACE);
29835:   mBrush                = ::CreateSolidBrush(NSRGB_2_COLOREF(mBackground));
29835:   mForeground           = ::GetSysColor(COLOR_WINDOWTEXT);
29835: 
29835:   // Global initialization
29835:   if (!sInstanceCount) {
29835: #if !defined(WINCE)
22411:   gKbdLayout.LoadLayout(::GetKeyboardLayout(0));
23335: #endif
29835: 
29835:   // Init IME handler
27961:   nsIMM32Handler::Initialize();
    1: 
24836: #ifdef NS_ENABLE_TSF
24836:   nsTextStore::Initialize();
29835: #endif
29835: 
29835: #if !defined(WINCE)
29835:   if (SUCCEEDED(::OleInitialize(NULL)))
 7271:     sIsOleInitialized = TRUE;
 7271:   NS_ASSERTION(sIsOleInitialized, "***** OLE is not initialized!\n");
24836: #endif
24746: 
29835: #if defined(HEAP_DUMP_EVENT)
29835:   InitHeapDump();
29835: #endif
29835:   } // !sInstanceCount
29835: 
27326:   // Set gLastInputEventTime to some valid number
27326:   gLastInputEventTime = PR_IntervalToMicroseconds(PR_IntervalNow());
27326: 
    1:   sInstanceCount++;
23335: }
23335: 
    1: nsWindow::~nsWindow()
    1: {
30223:   mInDtor = PR_TRUE;
30223: 
30223:   // If the widget was released without calling Destroy() then the native window still
30223:   // exists, and we need to destroy it. This will also result in a call to OnDestroy.
30223:   //
30223:   // XXX How could this happen???
30223:   if (NULL != mWnd)
    1:     Destroy();
    1: 
24836:   sInstanceCount--;
24836: 
29835:   // Global shutdown
29841:   if (sInstanceCount == 0) {
24836: #ifdef NS_ENABLE_TSF
24836:     nsTextStore::Terminate();
29835: #endif
29835: 
29835: #if !defined(WINCE)
29835:     NS_IF_RELEASE(sCursorImgContainer);
 7271:     if (sIsOleInitialized) {
 7968:       ::OleFlushClipboard();
 7271:       ::OleUninitialize();
 7271:       sIsOleInitialized = FALSE;
 7271:     }
29835:     // delete any of the IME structures that we allocated
27961:     nsIMM32Handler::Terminate();
29841: #endif // !defined(WINCE)
29841:   }
29841: 
29841: #if !defined(WINCE)
    1:   NS_IF_RELEASE(mNativeDragTarget);
29835: #endif // !defined(WINCE)
29835: }
29835: 
29835: NS_IMPL_ISUPPORTS_INHERITED0(nsWindow, nsBaseWidget)
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Create, nsIWidget::Destroy
29835:  *
29835:  * Creating and destroying windows for this widget.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Create the proper widget
29835: NS_METHOD nsWindow::Create(nsIWidget *aParent,
29835:                            const nsIntRect &aRect,
29835:                            EVENT_CALLBACK aHandleEventFunction,
29835:                            nsIDeviceContext *aContext,
29835:                            nsIAppShell *aAppShell,
29835:                            nsIToolkit *aToolkit,
29835:                            nsWidgetInitData *aInitData)
29835: {
29835:   if (aInitData)
29835:     mUnicodeWidget = aInitData->mUnicode;
29835:   return(StandardWindowCreate(aParent, aRect, aHandleEventFunction,
29835:                               aContext, aAppShell, aToolkit, aInitData,
29835:                               nsnull));
29835: }
29835: 
29835: 
29835: // Create with a native parent
29835: NS_METHOD nsWindow::Create(nsNativeWidget aParent,
29835:                            const nsIntRect &aRect,
29835:                            EVENT_CALLBACK aHandleEventFunction,
29835:                            nsIDeviceContext *aContext,
29835:                            nsIAppShell *aAppShell,
29835:                            nsIToolkit *aToolkit,
29835:                            nsWidgetInitData *aInitData)
29835: {
29835:   if (aInitData)
29835:     mUnicodeWidget = aInitData->mUnicode;
29835:   return(StandardWindowCreate(nsnull, aRect, aHandleEventFunction,
29835:                               aContext, aAppShell, aToolkit, aInitData,
29835:                               aParent));
29835: }
29835: 
29835: // Allow Derived classes to modify the height that is passed
29835: // when the window is created or resized. Also add extra height
29835: // if needed (on Windows CE)
    1: PRInt32 nsWindow::GetHeight(PRInt32 aProposedHeight)
    1: {
29276:   PRInt32 extra = 0;
29276: 
29276:   #if defined(WINCE) && !defined(WINCE_WINDOWS_MOBILE)
29276:   DWORD style = WindowStyle();
29276:   if ((style & WS_SYSMENU) && (style & WS_POPUP)) {
29276:     extra = GetSystemMetrics(SM_CYCAPTION);
29276:   }
29276:   #endif
29276: 
29276:   return aProposedHeight + extra;
    1: }
    1: 
29835: // Utility methods for creating windows.
    1: nsresult
    1: nsWindow::StandardWindowCreate(nsIWidget *aParent,
23738:                                const nsIntRect &aRect,
    1:                                EVENT_CALLBACK aHandleEventFunction,
    1:                                nsIDeviceContext *aContext,
    1:                                nsIAppShell *aAppShell,
    1:                                nsIToolkit *aToolkit,
    1:                                nsWidgetInitData *aInitData,
    1:                                nsNativeWidget aNativeParent)
    1: {
    1:   nsIWidget *baseParent = aInitData &&
    1:                          (aInitData->mWindowType == eWindowType_dialog ||
    1:                           aInitData->mWindowType == eWindowType_toplevel ||
    1:                           aInitData->mWindowType == eWindowType_invisible) ?
    1:                          nsnull : aParent;
    1: 
    1:   mIsTopWidgetWindow = (nsnull == baseParent);
    1:   mBounds.width = aRect.width;
    1:   mBounds.height = aRect.height;
    1: 
    1:   BaseCreate(baseParent, aRect, aHandleEventFunction, aContext,
    1:              aAppShell, aToolkit, aInitData);
    1: 
    1:   // Switch to the "main gui thread" if necessary... This method must
    1:   // be executed on the "gui thread"...
    1: 
    1:   nsToolkit* toolkit = (nsToolkit *)mToolkit;
    1:   if (toolkit && !toolkit->IsGuiThread()) {
25349:     DWORD_PTR args[7];
25349:     args[0] = (DWORD_PTR)aParent;
25349:     args[1] = (DWORD_PTR)&aRect;
25349:     args[2] = (DWORD_PTR)aHandleEventFunction;
25349:     args[3] = (DWORD_PTR)aContext;
25349:     args[4] = (DWORD_PTR)aAppShell;
25349:     args[5] = (DWORD_PTR)aToolkit;
25349:     args[6] = (DWORD_PTR)aInitData;
    1: 
    1:     if (nsnull != aParent) {
    1:       // nsIWidget parent dispatch
    1:       MethodInfo info(this, nsWindow::CREATE, 7, args);
    1:       toolkit->CallMethod(&info);
    1:       return NS_OK;
    1:     }
    1:     else {
    1:       // Native parent dispatch
    1:       MethodInfo info(this, nsWindow::CREATE_NATIVE, 5, args);
    1:       toolkit->CallMethod(&info);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   HWND parent;
    1:   if (nsnull != aParent) { // has a nsIWidget parent
    1:     parent = ((aParent) ? (HWND)aParent->GetNativeData(NS_NATIVE_WINDOW) : nsnull);
    1:   } else { // has a nsNative parent
    1:     parent = (HWND)aNativeParent;
    1:   }
    1: 
    1:   if (nsnull != aInitData) {
    1:     SetWindowType(aInitData->mWindowType);
    1:     SetBorderStyle(aInitData->mBorderStyle);
26576:     mPopupType = aInitData->mPopupHint;
    1:   }
    1: 
    1:   mContentType = aInitData ? aInitData->mContentType : eContentTypeInherit;
    1: 
    1:   DWORD style = WindowStyle();
    1:   DWORD extendedStyle = WindowExStyle();
    1: 
    1:   if (mWindowType == eWindowType_popup) {
 8408:     // if a parent was specified, don't use WS_EX_TOPMOST so that the popup
 8408:     // only appears above the parent, instead of all windows
 8408:     if (aParent)
 8408:       extendedStyle = WS_EX_TOOLWINDOW;
 8587:     else
 8587:       parent = NULL;
    1:   } else if (nsnull != aInitData) {
    1:     // See if the caller wants to explictly set clip children and clip siblings
    1:     if (aInitData->clipChildren) {
    1:       style |= WS_CLIPCHILDREN;
    1:     } else {
    1:       style &= ~WS_CLIPCHILDREN;
    1:     }
    1:     if (aInitData->clipSiblings) {
    1:       style |= WS_CLIPSIBLINGS;
    1:     }
    1:   }
    1: 
    1:   mHas3DBorder = (extendedStyle & WS_EX_CLIENTEDGE) > 0;
    1: 
    1:   mWnd = ::CreateWindowExW(extendedStyle,
    1:                            aInitData && aInitData->mDropShadow ?
23186:                            WindowPopupClass() : WindowClass(),
    1:                            L"",
    1:                            style,
    1:                            aRect.x,
    1:                            aRect.y,
    1:                            aRect.width,
    1:                            GetHeight(aRect.height),
    1:                            parent,
    1:                            NULL,
    1:                            nsToolkit::mDllInstance,
    1:                            NULL);
    1: 
    1:   if (!mWnd)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // call the event callback to notify about creation
    1: 
    1:   DispatchStandardEvent(NS_CREATE);
    1:   SubclassWindow(TRUE);
    1: 
29835:   if (sTrimOnMinimize == 2 && mWindowType == eWindowType_invisible) {
    1:     /* The internal variable set by the config.trim_on_minimize pref
    1:        has not yet been initialized, and this is the hidden window
    1:        (conveniently created before any visible windows, and after
    1:        the profile has been initialized).
    1:        
    1:        Default config.trim_on_minimize to false, to fix bug 76831
    1:        for good.  If anyone complains about this new default, saying
    1:        that a Mozilla app hogs too much memory while minimized, they
    1:        will have that entire bug tattooed on their backside. */
    1: 
29835:     sTrimOnMinimize = 0;
    1:     nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:     if (prefs) {
    1:       nsCOMPtr<nsIPrefBranch> prefBranch;
    1:       prefs->GetBranch(0, getter_AddRefs(prefBranch));
    1:       if (prefBranch) {
24391: 
24391:         PRBool temp;
    1:         if (NS_SUCCEEDED(prefBranch->GetBoolPref("config.trim_on_minimize",
24391:                                                  &temp))
24391:             && temp)
29835:           sTrimOnMinimize = 1;
    1: 
    1:         if (NS_SUCCEEDED(prefBranch->GetBoolPref("intl.keyboard.per_window_layout",
24391:                                                  &temp)))
29835:           sSwitchKeyboardLayout = temp;
24391: 
24391:         if (NS_SUCCEEDED(prefBranch->GetBoolPref("mozilla.widget.disable-native-theme",
24391:                                                  &temp)))
24391:           gDisableNativeTheme = temp;
    1:       }
    1:     }
    1:   }
25278: #if defined(WINCE_HAVE_SOFTKB)
    1:   if (mWindowType == eWindowType_dialog || mWindowType == eWindowType_toplevel )
29835:      nsWindowCE::CreateSoftKeyMenuBar(mWnd);
    1: #endif
    1: 
29835: #if !defined(WINCE)
26874:   // Enable gesture support for this window.
26874:   if (mWindowType != eWindowType_invisible &&
26874:       mWindowType != eWindowType_plugin &&
26874:       mWindowType != eWindowType_java &&
26874:       mWindowType != eWindowType_toplevel) {
26874:     // eWindowType_toplevel is the top level main frame window. Gesture support
26874:     // there prevents the user from interacting with the title bar or nc
26874:     // areas using a single finger. Java and plugin windows can make their
26874:     // own calls.
26874:     mGesture.InitWinGestureSupport(mWnd);
26874:   }
29835: #endif // !defined(WINCE)
26874: 
    1:   return NS_OK;
    1: }
    1: 
30223: // Close this nsWindow
30223: NS_METHOD nsWindow::Destroy()
30223: {
30223:   // WM_DESTROY has already fired, we're done.
30223:   if (nsnull == mWnd)
30223:     return NS_OK;
30223: 
30223:   // Switch to the "main gui thread" if necessary. Destroy() must be executed on the
30223:   // "gui thread".
30223:   nsToolkit* toolkit = (nsToolkit *)mToolkit;
30223:   if (toolkit != nsnull && !toolkit->IsGuiThread()) {
30223:     MethodInfo info(this, nsWindow::DESTROY);
30223:     toolkit->CallMethod(&info);
30223:     return NS_ERROR_FAILURE;
30223:   }
30223: 
30223:   // During the destruction of all of our children, make sure we don't get deleted.
30223:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
30223: 
30223:   // The DestroyWindow function destroys the specified window. The function sends WM_DESTROY
30223:   // and WM_NCDESTROY messages to the window to deactivate it and remove the keyboard focus
30223:   // from it. The function also destroys the window's menu, flushes the thread message queue,
30223:   // destroys timers, removes clipboard ownership, and breaks the clipboard viewer chain (if
30223:   // the window is at the top of the viewer chain).
30223:   //
30223:   // If the specified window is a parent or owner window, DestroyWindow automatically destroys
30223:   // the associated child or owned windows when it destroys the parent or owner window. The
30223:   // function first destroys child or owned windows, and then it destroys the parent or owner
30223:   // window.
30223:   VERIFY(::DestroyWindow(mWnd));
30223:   
30223:   // Our windows can be subclassed which may prevent us receiving WM_DESTROY. If OnDestroy()
30223:   // didn't get called, call it now.
30223:   if (PR_FALSE == mOnDestroyCalled)
30223:     OnDestroy();
30223: 
30223:   return NS_OK;
30223: }
30223: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Window class utilities
29835:  *
29835:  * Utilities for calculating the proper window class name for
29835:  * Create window.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Return the proper window class for everything except popups.
29835: LPCWSTR nsWindow::WindowClass()
29835: {
29835:   if (!nsWindow::sIsRegistered) {
29835:     WNDCLASSW wc;
29835: 
29835: //    wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
29835:     wc.style         = CS_DBLCLKS;
29835:     wc.lpfnWndProc   = ::DefWindowProcW;
29835:     wc.cbClsExtra    = 0;
29835:     wc.cbWndExtra    = 0;
29835:     wc.hInstance     = nsToolkit::mDllInstance;
29835:     wc.hIcon         = ::LoadIconW(::GetModuleHandleW(NULL), (LPWSTR)IDI_APPLICATION);
29835:     wc.hCursor       = NULL;
29835:     wc.hbrBackground = mBrush;
29835:     wc.lpszMenuName  = NULL;
29835:     wc.lpszClassName = kClassNameHidden;
29835: 
29835:     BOOL succeeded = ::RegisterClassW(&wc) != 0 && 
29835:       ERROR_CLASS_ALREADY_EXISTS != GetLastError();
29835:     nsWindow::sIsRegistered = succeeded;
29835: 
29835:     wc.lpszClassName = kClassNameContentFrame;
29835:     if (!::RegisterClassW(&wc) && 
29835:       ERROR_CLASS_ALREADY_EXISTS != GetLastError()) {
29835:       nsWindow::sIsRegistered = FALSE;
29835:     }
29835: 
29835:     wc.lpszClassName = kClassNameContent;
29835:     if (!::RegisterClassW(&wc) && 
29835:       ERROR_CLASS_ALREADY_EXISTS != GetLastError()) {
29835:       nsWindow::sIsRegistered = FALSE;
29835:     }
29835: 
29835:     wc.lpszClassName = kClassNameUI;
29835:     if (!::RegisterClassW(&wc) && 
29835:       ERROR_CLASS_ALREADY_EXISTS != GetLastError()) {
29835:       nsWindow::sIsRegistered = FALSE;
29835:     }
29835: 
29835:     wc.lpszClassName = kClassNameGeneral;
29835:     ATOM generalClassAtom = ::RegisterClassW(&wc);
29835:     if (!generalClassAtom && 
29835:       ERROR_CLASS_ALREADY_EXISTS != GetLastError()) {
29835:       nsWindow::sIsRegistered = FALSE;
29835:     }
29835: 
29835:     wc.lpszClassName = kClassNameDialog;
29835:     wc.hIcon = 0;
29835:     if (!::RegisterClassW(&wc) && 
29835:       ERROR_CLASS_ALREADY_EXISTS != GetLastError()) {
29835:       nsWindow::sIsRegistered = FALSE;
29835:     }
29835:   }
29835: 
29835:   if (mWindowType == eWindowType_invisible) {
29835:     return kClassNameHidden;
29835:   }
29835:   if (mWindowType == eWindowType_dialog) {
29835:     return kClassNameDialog;
29835:   }
29835:   if (mContentType == eContentTypeContent) {
29835:     return kClassNameContent;
29835:   }
29835:   if (mContentType == eContentTypeContentFrame) {
29835:     return kClassNameContentFrame;
29835:   }
29835:   if (mContentType == eContentTypeUI) {
29835:     return kClassNameUI;
29835:   }
29835:   return kClassNameGeneral;
29835: }
29835: 
29835: // Return the proper popup window class
29835: LPCWSTR nsWindow::WindowPopupClass()
29835: {
29835:   const LPCWSTR className = L"MozillaDropShadowWindowClass";
29835: 
29835:   if (!nsWindow::sIsPopupClassRegistered) {
29835:     WNDCLASSW wc;
29835: 
29835:     wc.style = CS_DBLCLKS | CS_XP_DROPSHADOW;
29835:     wc.lpfnWndProc   = ::DefWindowProcW;
29835:     wc.cbClsExtra    = 0;
29835:     wc.cbWndExtra    = 0;
29835:     wc.hInstance     = nsToolkit::mDllInstance;
29835:     wc.hIcon         = ::LoadIconW(::GetModuleHandleW(NULL), (LPWSTR)IDI_APPLICATION);
29835:     wc.hCursor       = NULL;
29835:     wc.hbrBackground = mBrush;
29835:     wc.lpszMenuName  = NULL;
29835:     wc.lpszClassName = className;
29835: 
29835:     nsWindow::sIsPopupClassRegistered = ::RegisterClassW(&wc);
29835:     if (!nsWindow::sIsPopupClassRegistered) {
29835:       // For older versions of Win32 (i.e., not XP), the registration will
29835:       // fail, so we have to re-register without the CS_XP_DROPSHADOW flag.
29835:       wc.style = CS_DBLCLKS;
29835:       nsWindow::sIsPopupClassRegistered = ::RegisterClassW(&wc);
29835:     }
29835:   }
29835: 
29835:   return className;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Window styles utilities
29835:  *
29835:  * Return the proper windows styles and extended styles.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Return nsWindow styles
29835: #if !defined(WINCE) // implemented in nsWindowCE.cpp
29835: DWORD nsWindow::WindowStyle()
29835: {
29835:   DWORD style;
29835: 
29835:   switch (mWindowType) {
29835:     case eWindowType_child:
29835:       style = WS_OVERLAPPED;
29835:       break;
29835: 
29835:     case eWindowType_dialog:
29835:       style = WS_OVERLAPPED | WS_BORDER | WS_DLGFRAME | WS_SYSMENU | DS_3DLOOK | DS_MODALFRAME;
29835:       if (mBorderStyle != eBorderStyle_default)
29835:         style |= WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
29835:       break;
29835: 
29835:     case eWindowType_popup:
29835:       style = WS_POPUP;
29835:       if (mTransparencyMode == eTransparencyGlass) {
29835:         /* Glass seems to need WS_CAPTION or WS_THICKFRAME to work.
29835:            WS_THICKFRAME has issues with autohiding popups but looks better */
29835:         style |= WS_THICKFRAME;
29835:       } else {
29835:         style |= WS_OVERLAPPED;
29835:       }
29835:       break;
29835: 
29835:     default:
29835:       NS_ASSERTION(0, "unknown border style");
29835:       // fall through
29835: 
29835:     case eWindowType_toplevel:
29835:     case eWindowType_invisible:
29835:       style = WS_OVERLAPPED | WS_BORDER | WS_DLGFRAME | WS_SYSMENU |
29835:               WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
29835:       break;
29835:   }
29835: 
29835:   VERIFY_WINDOW_STYLE(style);
29835:   return style;
29835: }
29835: #endif // !defined(WINCE)
29835: 
29835: // Return nsWindow extended styles
29835: DWORD nsWindow::WindowExStyle()
29835: {
29835:   switch (mWindowType)
29835:   {
29835:     case eWindowType_child:
29835:       return 0;
29835: 
29835:     case eWindowType_dialog:
29835:       return WS_EX_WINDOWEDGE | WS_EX_DLGMODALFRAME;
29835: 
29835:     case eWindowType_popup:
29835:       return
29835: #if defined(WINCE) && !defined(WINCE_WINDOWS_MOBILE)
29835:         WS_EX_NOACTIVATE |
    1: #endif
29835:         WS_EX_TOPMOST | WS_EX_TOOLWINDOW;
29835: 
29835:     default:
29835:       NS_ASSERTION(0, "unknown border style");
29835:       // fall through
29835: 
29835:     case eWindowType_toplevel:
29835:     case eWindowType_invisible:
29835:       return WS_EX_WINDOWEDGE;
29835:   }
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Window subclassing utilities
29835:  *
29835:  * Set or clear window subclasses on native windows. Used in
29835:  * Create and Destroy.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Subclass (or remove the subclass from) this component's nsWindow
29835: void nsWindow::SubclassWindow(BOOL bState)
29835: {
29835:   if (NULL != mWnd) {
29835:     NS_PRECONDITION(::IsWindow(mWnd), "Invalid window handle");
29835: 
29835:     if (bState) {
29835:       // change the nsWindow proc
29835:       if (mUnicodeWidget)
29835:         mPrevWndProc = (WNDPROC)::SetWindowLongPtrW(mWnd, GWLP_WNDPROC,
29835:                                                 (LONG_PTR)nsWindow::WindowProc);
29835:       else
29835:         mPrevWndProc = (WNDPROC)::SetWindowLongPtrA(mWnd, GWLP_WNDPROC,
29835:                                                 (LONG_PTR)nsWindow::WindowProc);
29835:       NS_ASSERTION(mPrevWndProc, "Null standard window procedure");
29835:       // connect the this pointer to the nsWindow handle
29835:       SetNSWindowPtr(mWnd, this);
29835:     }
29835:     else {
29835:       if (mUnicodeWidget)
29835:         ::SetWindowLongPtrW(mWnd, GWLP_WNDPROC, (LONG_PTR)mPrevWndProc);
29835:       else
29835:         ::SetWindowLongPtrA(mWnd, GWLP_WNDPROC, (LONG_PTR)mPrevWndProc);
29835:       SetNSWindowPtr(mWnd, NULL);
29835:       mPrevWndProc = NULL;
29835:     }
29835:   }
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Window properties
29835:  *
29835:  * Set and clear native window properties.
29835:  *
29835:  **************************************************************/
29835: 
29835: static PRUnichar sPropName[40] = L"";
29835: static PRUnichar* GetNSWindowPropName()
29835: {
29835:   if (!*sPropName)
29835:   {
29835:     _snwprintf(sPropName, 39, L"MozillansIWidgetPtr%p", GetCurrentProcessId());
29835:     sPropName[39] = '\0';
29835:   }
29835:   return sPropName;
29835: }
29835: 
29835: nsWindow * nsWindow::GetNSWindowPtr(HWND aWnd)
29835: {
29835:   return (nsWindow *) ::GetPropW(aWnd, GetNSWindowPropName());
29835: }
29835: 
29835: BOOL nsWindow::SetNSWindowPtr(HWND aWnd, nsWindow * ptr)
29835: {
29835:   if (ptr == NULL) {
29835:     ::RemovePropW(aWnd, GetNSWindowPropName());
29835:     return TRUE;
29835:   } else {
29835:     return ::SetPropW(aWnd, GetNSWindowPropName(), (HANDLE)ptr);
29835:   }
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetParent, nsIWidget::GetParent
29835:  *
29835:  * Set or clear the parent widgets using window properties, and
29835:  * handles calculating native parent handles.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Get and set parent widgets
    1: NS_IMETHODIMP nsWindow::SetParent(nsIWidget *aNewParent)
    1: {
    1:   if (aNewParent) {
 3419:     nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
 3419: 
 3419:     nsIWidget* parent = GetParent();
 3419:     if (parent) {
 3419:       parent->RemoveChild(this);
 3419:     }
 3419: 
    1:     HWND newParent = (HWND)aNewParent->GetNativeData(NS_NATIVE_WINDOW);
    1:     NS_ASSERTION(newParent, "Parent widget has a null native window handle");
 3419:     if (newParent && mWnd) {
    1:       ::SetParent(mWnd, newParent);
 3419:     }
 3419: 
 3419:     aNewParent->AddChild(this);
    1: 
    1:     return NS_OK;
    1:   }
 4577: 
 4577:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
 4577: 
 4577:   nsIWidget* parent = GetParent();
 4577: 
 4577:   if (parent) {
 4577:     parent->RemoveChild(this);
 4577:   }
 4577: 
 4577:   if (mWnd) {
30223:     // If we have no parent, SetParent should return the desktop.
30223:     VERIFY(::SetParent(mWnd, nsnull));
 4577:   }
 4577: 
 4577:   return NS_OK;
    1: }
    1: 
    1: nsIWidget* nsWindow::GetParent(void)
    1: {
27505:   return GetParentWindow(PR_FALSE);
27505: }
27505: 
27505: nsWindow* nsWindow::GetParentWindow(PRBool aIncludeOwner)
19016: {
19016:   if (mIsTopWidgetWindow) {
    1:     // Must use a flag instead of mWindowType to tell if the window is the
    1:     // owned by the topmost widget, because a child window can be embedded inside
    1:     // a HWND which is not associated with a nsIWidget.
    1:     return nsnull;
    1:   }
19016: 
    1:   // If this widget has already been destroyed, pretend we have no parent.
    1:   // This corresponds to code in Destroy which removes the destroyed
    1:   // widget from its parent's child list.
30223:   if (mInDtor || mOnDestroyCalled)
    1:     return nsnull;
    1: 
27505: 
27505:   // aIncludeOwner set to true implies walking the parent chain to retrieve the
27505:   // root owner. aIncludeOwner set to false implies the search will stop at the
27505:   // true parent (default).
    1:   nsWindow* widget = nsnull;
    1:   if (mWnd) {
27506: #ifdef WINCE
27506:     HWND parent = ::GetParent(mWnd);
27506: #else
27505:     HWND parent = nsnull;
27505:     if (aIncludeOwner)
27505:       parent = ::GetParent(mWnd);
27505:     else
27505:       parent = ::GetAncestor(mWnd, GA_PARENT);
27506: #endif
    1:     if (parent) {
    1:       widget = GetNSWindowPtr(parent);
    1:       if (widget) {
    1:         // If the widget is in the process of being destroyed then
    1:         // do NOT return it
30223:         if (widget->mInDtor) {
    1:           widget = nsnull;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return widget;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Show
29835:  *
29835:  * Hide or show this component.
29835:  *
29835:  **************************************************************/
    1: 
    1: NS_METHOD nsWindow::Show(PRBool bState)
    1: {
29279: #if defined(MOZ_SPLASHSCREEN)
29279:   // we're about to show the first toplevel window,
29279:   // so kill off any splash screen if we had one
29279:   nsSplashScreen *splash = nsSplashScreen::Get();
29279:   if (splash && splash->IsOpen() && mWnd && bState &&
29279:       (mWindowType == eWindowType_toplevel ||
29279:        mWindowType == eWindowType_dialog ||
29279:        mWindowType == eWindowType_popup))
29279:   {
29279:     splash->Close();
29279:   }
29279: #endif
29279: 
16326:   PRBool wasVisible = mIsVisible;
16326:   // Set the status now so that anyone asking during ShowWindow or
16326:   // SetWindowPos would get the correct answer.
16326:   mIsVisible = bState;
16326: 
    1:   if (mWnd) {
    1:     if (bState) {
16326:       if (!wasVisible && mWindowType == eWindowType_toplevel) {
    1:         switch (mSizeMode) {
24970: #ifdef WINCE
30075:           case nsSizeMode_Fullscreen:
30075:             ::SetForegroundWindow(mWnd);
30075:             ::ShowWindow(mWnd, SW_SHOWMAXIMIZED);
30075:             MakeFullScreen(TRUE);
30075:             break;
30075: 
    1:           case nsSizeMode_Maximized :
24795:             ::SetForegroundWindow(mWnd);
    1:             ::ShowWindow(mWnd, SW_SHOWMAXIMIZED);
    1:             break;
24970:           // use default for nsSizeMode_Minimized on Windows CE
24970: #else
30075:           case nsSizeMode_Fullscreen:
30075:             ::ShowWindow(mWnd, SW_SHOWMAXIMIZED);
30075:             break;
30075: 
24970:           case nsSizeMode_Maximized :
24970:             ::ShowWindow(mWnd, SW_SHOWMAXIMIZED);
24970:             break;
    1:           case nsSizeMode_Minimized :
    1:             ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
24795:             break;
24795: #endif
    1:           default:
    1:             if (CanTakeFocus()) {
25859: #ifdef WINCE
23335:               ::SetForegroundWindow(mWnd);
23335: #endif
24795:               ::ShowWindow(mWnd, SW_SHOWNORMAL);
    1:             } else {
    1:               // Place the window behind the foreground window
    1:               // (as long as it is not topmost)
    1:               HWND wndAfter = ::GetForegroundWindow();
    1:               if (!wndAfter)
    1:                 wndAfter = HWND_BOTTOM;
25349:               else if (GetWindowLongPtrW(wndAfter, GWL_EXSTYLE) & WS_EX_TOPMOST)
    1:                 wndAfter = HWND_TOP;
    1:               ::SetWindowPos(mWnd, wndAfter, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE | 
    1:                              SWP_NOMOVE | SWP_NOACTIVATE);
    1:               GetAttention(2);
    1:             }
23335:             break;
    1:         }
    1:       } else {
    1:         DWORD flags = SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW;
16326:         if (wasVisible)
    1:           flags |= SWP_NOZORDER;
    1: 
    1:         if (mWindowType == eWindowType_popup) {
    1: #ifndef WINCE
    1:           // ensure popups are the topmost of the TOPMOST
    1:           // layer. Remember not to set the SWP_NOZORDER
    1:           // flag as that might allow the taskbar to overlap
    1:           // the popup.  However on windows ce, we need to
    1:           // activate the popup or clicks will not be sent.
    1:           flags |= SWP_NOACTIVATE;
    1: #endif
 8408:           HWND owner = ::GetWindow(mWnd, GW_OWNER);
 8408:           ::SetWindowPos(mWnd, owner ? 0 : HWND_TOPMOST, 0, 0, 0, 0, flags);
    1:         } else {
26616: #ifndef WINCE
26616:           if (mWindowType == eWindowType_dialog && !CanTakeFocus())
26616:             flags |= SWP_NOACTIVATE;
26616: #endif
    1:           ::SetWindowPos(mWnd, HWND_TOP, 0, 0, 0, 0, flags);
    1:         }
    1:       }
    1:     } else {
    1:       if (mWindowType != eWindowType_dialog) {
    1:         ::ShowWindow(mWnd, SW_HIDE);
    1:       } else {
    1:         ::SetWindowPos(mWnd, 0, 0, 0, 0, 0, SWP_HIDEWINDOW | SWP_NOSIZE | SWP_NOMOVE |
    1:                        SWP_NOZORDER | SWP_NOACTIVATE);
    1:       }
    1:     }
    1:   }
    1:   
    1: #ifdef MOZ_XUL
16326:   if (!wasVisible && bState)
    1:     Invalidate(PR_FALSE);
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::IsVisible
29835:  *
29835:  * Returns the visibility state.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Return PR_TRUE if the whether the component is visible, PR_FALSE otherwise
    1: NS_METHOD nsWindow::IsVisible(PRBool & bState)
    1: {
    1:   bState = mIsVisible;
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Window clipping utilities
29835:  *
29835:  * Used in Size and Move operations for setting the proper
29835:  * window clipping regions for window transparency.
29835:  *
29835:  **************************************************************/
    1: 
26576: // XP and Vista visual styles sometimes require window clipping regions to be applied for proper
26576: // transparency. These routines are called on size and move operations.
26576: void nsWindow::ClearThemeRegion()
26576: {
26576: #ifndef WINCE
26650:   if (nsUXThemeData::sIsVistaOrLater && mTransparencyMode != eTransparencyGlass &&
26650:       mWindowType == eWindowType_popup && (mPopupType == ePopupTypeTooltip || mPopupType == ePopupTypePanel)) {
26576:     SetWindowRgn(mWnd, NULL, false);
26650:   }
26576: #endif
26576: }
26576: 
26576: void nsWindow::SetThemeRegion()
26576: {
26576: #ifndef WINCE
26576:   // Popup types that have a visual styles region applied (bug 376408). This can be expanded
26576:   // for other window types as needed. The regions are applied generically to the base window
26576:   // so default constants are used for part and state. At some point we might need part and
26576:   // state values from nsNativeThemeWin's GetThemePartAndState, but currently windows that
26576:   // change shape based on state haven't come up.
26576:   if (nsUXThemeData::sIsVistaOrLater && mTransparencyMode != eTransparencyGlass &&
26576:       mWindowType == eWindowType_popup && (mPopupType == ePopupTypeTooltip || mPopupType == ePopupTypePanel)) {
26576:     HRGN hRgn = nsnull;
26576:     RECT rect = {0,0,mBounds.width,mBounds.height};
26576:     
26576:     nsUXThemeData::getThemeBackgroundRegion(nsUXThemeData::GetTheme(eUXTooltip), GetDC(mWnd), TTP_STANDARD, TS_NORMAL, &rect, &hRgn);
26576:     if (hRgn) {
26576:       if (!SetWindowRgn(mWnd, hRgn, false)) // do not delete or alter hRgn if accepted.
26576:         DeleteObject(hRgn);
26576:     }
26576:   }
26576: #endif
26576: }
26576: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Move, nsIWidget::Resize, nsIWidget::Size
29835:  *
29835:  * Repositioning and sizing a window.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Move this component
    1: NS_METHOD nsWindow::Move(PRInt32 aX, PRInt32 aY)
    1: {
    1:   // Check to see if window needs to be moved first
    1:   // to avoid a costly call to SetWindowPos. This check
    1:   // can not be moved to the calling code in nsView, because
    1:   // some platforms do not position child windows correctly
    1: 
    1:   // Only perform this check for non-popup windows, since the positioning can
    1:   // in fact change even when the x/y do not.  We always need to perform the
    1:   // check. See bug #97805 for details.
    1:   if (mWindowType != eWindowType_popup && (mBounds.x == aX) && (mBounds.y == aY))
    1:   {
    1:     // Nothing to do, since it is already positioned correctly.
    1:     return NS_OK;
    1:   }
    1: 
    1:   mBounds.x = aX;
    1:   mBounds.y = aY;
    1: 
    1:   if (mWnd) {
    1: #ifdef DEBUG
    1:     // complain if a window is moved offscreen (legal, but potentially worrisome)
    1:     if (mIsTopWidgetWindow) { // only a problem for top-level windows
    1:       // Make sure this window is actually on the screen before we move it
    1:       // XXX: Needs multiple monitor support
    1:       HDC dc = ::GetDC(mWnd);
    1:       if (dc) {
    1:         if (::GetDeviceCaps(dc, TECHNOLOGY) == DT_RASDISPLAY) {
    1:           RECT workArea;
    1:           ::SystemParametersInfo(SPI_GETWORKAREA, 0, &workArea, 0);
    1:           // no annoying assertions. just mention the issue.
    1:           if (aX < 0 || aX >= workArea.right || aY < 0 || aY >= workArea.bottom)
    1:             printf("window moved to offscreen position\n");
    1:         }
    1:       ::ReleaseDC(mWnd, dc);
    1:       }
    1:     }
    1: #endif
    1: 
    1:     nsIWidget *par = GetParent();
    1:     HDWP      deferrer = NULL;
    1: 
    1:     if (nsnull != par) {
    1:       deferrer = ((nsWindow *)par)->mDeferredPositioner;
    1:     }
    1: 
    1:     if (NULL != deferrer) {
    1:       VERIFY(((nsWindow *)par)->mDeferredPositioner = ::DeferWindowPos(deferrer,
    1:                             mWnd, NULL, aX, aY, 0, 0,
    1:                             SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE));
    1:     }
    1:     else {
26576:       ClearThemeRegion();
    1:       VERIFY(::SetWindowPos(mWnd, NULL, aX, aY, 0, 0,
    1:                             SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE));
26576:       SetThemeRegion();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Resize this component
    1: NS_METHOD nsWindow::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
    1:   NS_ASSERTION((aWidth >=0 ) , "Negative width passed to nsWindow::Resize");
    1:   NS_ASSERTION((aHeight >=0 ), "Negative height passed to nsWindow::Resize");
    1: 
    1: #ifdef MOZ_XUL
16601:   if (eTransparencyTransparent == mTransparencyMode)
    1:     ResizeTranslucentWindow(aWidth, aHeight);
    1: #endif
    1: 
    1:   // Set cached value for lightweight and printing
    1:   mBounds.width  = aWidth;
    1:   mBounds.height = aHeight;
    1: 
    1:   if (mWnd) {
    1:     nsIWidget *par = GetParent();
    1:     HDWP      deferrer = NULL;
    1: 
    1:     if (nsnull != par) {
    1:       deferrer = ((nsWindow *)par)->mDeferredPositioner;
    1:     }
    1: 
    1:     UINT  flags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE;
    1: #ifndef WINCE
    1:     if (!aRepaint) {
    1:       flags |= SWP_NOREDRAW;
    1:     }
    1: #endif
    1: 
    1:     if (NULL != deferrer) {
    1:       VERIFY(((nsWindow *)par)->mDeferredPositioner = ::DeferWindowPos(deferrer,
    1:                             mWnd, NULL, 0, 0, aWidth, GetHeight(aHeight), flags));
    1:     }
    1:     else {
26576:       ClearThemeRegion();
    1:       VERIFY(::SetWindowPos(mWnd, NULL, 0, 0, aWidth, GetHeight(aHeight), flags));
26576:       SetThemeRegion();
    1:     }
    1:   }
    1: 
    1:   if (aRepaint)
    1:     Invalidate(PR_FALSE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Resize this component
    1: NS_METHOD nsWindow::Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
    1:   NS_ASSERTION((aWidth >=0 ),  "Negative width passed to nsWindow::Resize");
    1:   NS_ASSERTION((aHeight >=0 ), "Negative height passed to nsWindow::Resize");
    1: 
    1: #ifdef MOZ_XUL
16601:   if (eTransparencyTransparent == mTransparencyMode)
    1:     ResizeTranslucentWindow(aWidth, aHeight);
    1: #endif
    1: 
    1:   // Set cached value for lightweight and printing
    1:   mBounds.x      = aX;
    1:   mBounds.y      = aY;
    1:   mBounds.width  = aWidth;
    1:   mBounds.height = aHeight;
    1: 
    1:   if (mWnd) {
    1:     nsIWidget *par = GetParent();
    1:     HDWP      deferrer = NULL;
    1: 
    1:     if (nsnull != par) {
    1:       deferrer = ((nsWindow *)par)->mDeferredPositioner;
    1:     }
    1: 
    1:     UINT  flags = SWP_NOZORDER | SWP_NOACTIVATE;
    1: #ifndef WINCE
    1:     if (!aRepaint) {
    1:       flags |= SWP_NOREDRAW;
    1:     }
    1: #endif
26576: 
    1:     if (NULL != deferrer) {
    1:       VERIFY(((nsWindow *)par)->mDeferredPositioner = ::DeferWindowPos(deferrer,
    1:                             mWnd, NULL, aX, aY, aWidth, GetHeight(aHeight), flags));
    1:     }
    1:     else {
26576:       ClearThemeRegion();
    1:       VERIFY(::SetWindowPos(mWnd, NULL, aX, aY, aWidth, GetHeight(aHeight), flags));
26576:       SetThemeRegion();
    1:     }
    1:   }
    1: 
    1:   if (aRepaint)
    1:     Invalidate(PR_FALSE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Window Z-order and state.
29835:  *
29835:  * nsIWidget::PlaceBehind, nsIWidget::SetSizeMode,
29835:  * nsIWidget::ConstrainPosition
29835:  *
29835:  * Z-order, positioning, restore, minimize, and maximize.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Position the window behind the given window
29835: NS_METHOD nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
29835:                                 nsIWidget *aWidget, PRBool aActivate)
29835: {
29835:   HWND behind = HWND_TOP;
29835:   if (aPlacement == eZPlacementBottom)
29835:     behind = HWND_BOTTOM;
29835:   else if (aPlacement == eZPlacementBelow && aWidget)
29835:     behind = (HWND)aWidget->GetNativeData(NS_NATIVE_WINDOW);
29835:   UINT flags = SWP_NOMOVE | SWP_NOREPOSITION | SWP_NOSIZE;
29835:   if (!aActivate)
29835:     flags |= SWP_NOACTIVATE;
29835: 
29835:   if (!CanTakeFocus() && behind == HWND_TOP)
29835:   {
29835:     // Can't place the window to top so place it behind the foreground window
29835:     // (as long as it is not topmost)
29835:     HWND wndAfter = ::GetForegroundWindow();
29835:     if (!wndAfter)
29835:       behind = HWND_BOTTOM;
29835:     else if (!(GetWindowLongPtrW(wndAfter, GWL_EXSTYLE) & WS_EX_TOPMOST))
29835:       behind = wndAfter;
29835:     flags |= SWP_NOACTIVATE;
29835:   }
29835: 
29835:   ::SetWindowPos(mWnd, behind, 0, 0, 0, 0, flags);
29835:   return NS_OK;
29835: }
29835: 
29835: // Maximize, minimize or restore the window.
29835: #if !defined(WINCE) // implemented in nsWindowCE.cpp
29835: NS_IMETHODIMP nsWindow::SetSizeMode(PRInt32 aMode) {
29835: 
29835:   nsresult rv;
29835: 
29835:   // Let's not try and do anything if we're already in that state.
29835:   // (This is needed to prevent problems when calling window.minimize(), which
29835:   // calls us directly, and then the OS triggers another call to us.)
29835:   if (aMode == mSizeMode)
29835:     return NS_OK;
29835: 
29835:   // save the requested state
29835:   rv = nsBaseWidget::SetSizeMode(aMode);
29835:   if (NS_SUCCEEDED(rv) && mIsVisible) {
29835:     int mode;
29835: 
29835:     switch (aMode) {
30075:       case nsSizeMode_Fullscreen :
30075:         mode = SW_MAXIMIZE;
30075:         break;
30075: 
29835:       case nsSizeMode_Maximized :
29835:         mode = SW_MAXIMIZE;
29835:         break;
29835:       case nsSizeMode_Minimized :
29835:         mode = sTrimOnMinimize ? SW_MINIMIZE : SW_SHOWMINIMIZED;
29835:         if (!sTrimOnMinimize) {
29835:           // Find the next window that is visible and not minimized.
29835:           HWND hwndBelow = ::GetNextWindow(mWnd, GW_HWNDNEXT);
29835:           while (hwndBelow && (!::IsWindowVisible(hwndBelow) ||
29835:                                ::IsIconic(hwndBelow))) {
29835:             hwndBelow = ::GetNextWindow(hwndBelow, GW_HWNDNEXT);
29835:           }
29835: 
29835:           // Push ourselves to the bottom of the stack, then activate the
29835:           // next window.
29835:           ::SetWindowPos(mWnd, HWND_BOTTOM, 0, 0, 0, 0,
29835:                          SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
29835:           if (hwndBelow)
29835:             ::SetForegroundWindow(hwndBelow);
29835: 
29835:           // Play the minimize sound while we're here, since that is also
29835:           // forgotten when we use SW_SHOWMINIMIZED.
29835:           ::PlaySoundW(L"Minimize", nsnull, SND_ALIAS | SND_NODEFAULT | SND_ASYNC);
29835:         }
29835:         break;
29835:       default :
29835:         mode = SW_RESTORE;
29835:     }
29835:     ::ShowWindow(mWnd, mode);
29835:   }
29835:   return rv;
29835: }
29835: #endif // !defined(WINCE)
29835: 
29835: // Constrain a potential move to fit onscreen
29835: NS_METHOD nsWindow::ConstrainPosition(PRBool aAllowSlop,
29835:                                       PRInt32 *aX, PRInt32 *aY)
29835: {
29835:   if (!mIsTopWidgetWindow) // only a problem for top-level windows
29835:     return NS_OK;
29835: 
29835:   PRBool doConstrain = PR_FALSE; // whether we have enough info to do anything
29835: 
29835:   /* get our playing field. use the current screen, or failing that
29835:     for any reason, use device caps for the default screen. */
29835:   RECT screenRect;
29835: 
29835:   nsCOMPtr<nsIScreenManager> screenmgr = do_GetService(sScreenManagerContractID);
29835:   if (screenmgr) {
29835:     nsCOMPtr<nsIScreen> screen;
29835:     PRInt32 left, top, width, height;
29835: 
29835:     // zero size rects confuse the screen manager
29835:     width = mBounds.width > 0 ? mBounds.width : 1;
29835:     height = mBounds.height > 0 ? mBounds.height : 1;
29835:     screenmgr->ScreenForRect(*aX, *aY, width, height,
29835:                              getter_AddRefs(screen));
29835:     if (screen) {
29835:       screen->GetAvailRect(&left, &top, &width, &height);
29835:       screenRect.left = left;
29835:       screenRect.right = left+width;
29835:       screenRect.top = top;
29835:       screenRect.bottom = top+height;
29835:       doConstrain = PR_TRUE;
29835:     }
29835:   } else {
29835:     if (mWnd) {
29835:       HDC dc = ::GetDC(mWnd);
29835:       if (dc) {
29835:         if (::GetDeviceCaps(dc, TECHNOLOGY) == DT_RASDISPLAY) {
29835:           ::SystemParametersInfo(SPI_GETWORKAREA, 0, &screenRect, 0);
29835:           doConstrain = PR_TRUE;
29835:         }
29835:         ::ReleaseDC(mWnd, dc);
29835:       }
29835:     }
29835:   }
29835: 
29835:   if (aAllowSlop) {
29835:     if (*aX < screenRect.left - mBounds.width + kWindowPositionSlop)
29835:       *aX = screenRect.left - mBounds.width + kWindowPositionSlop;
29835:     else if (*aX >= screenRect.right - kWindowPositionSlop)
29835:       *aX = screenRect.right - kWindowPositionSlop;
29835: 
29835:     if (*aY < screenRect.top - mBounds.height + kWindowPositionSlop)
29835:       *aY = screenRect.top - mBounds.height + kWindowPositionSlop;
29835:     else if (*aY >= screenRect.bottom - kWindowPositionSlop)
29835:       *aY = screenRect.bottom - kWindowPositionSlop;
29835: 
29835:   } else {
29835: 
29835:     if (*aX < screenRect.left)
29835:       *aX = screenRect.left;
29835:     else if (*aX >= screenRect.right - mBounds.width)
29835:       *aX = screenRect.right - mBounds.width;
29835: 
29835:     if (*aY < screenRect.top)
29835:       *aY = screenRect.top;
29835:     else if (*aY >= screenRect.bottom - mBounds.height)
29835:       *aY = screenRect.bottom - mBounds.height;
29835:   }
29835: 
29835:   return NS_OK;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Enable, nsIWidget::IsEnabled
29835:  *
29835:  * Enabling and disabling the widget.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Enable/disable this component
    1: NS_METHOD nsWindow::Enable(PRBool bState)
    1: {
    1:   if (mWnd) {
    1:     ::EnableWindow(mWnd, bState);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
29835: // Return the current enable state
    1: NS_METHOD nsWindow::IsEnabled(PRBool *aState)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aState);
23335: 
23335: #ifndef WINCE
    1:   *aState = !mWnd || (::IsWindowEnabled(mWnd) && ::IsWindowEnabled(::GetAncestor(mWnd, GA_ROOT)));
23335: #else
23335:   *aState = !mWnd || (::IsWindowEnabled(mWnd) && ::IsWindowEnabled(mWnd));
23335: #endif
23335: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetFocus
29835:  *
29835:  * Give the focus to this widget.
29835:  *
29835:  **************************************************************/
29835: 
    1: NS_METHOD nsWindow::SetFocus(PRBool aRaise)
    1: {
    1:   // Switch to the "main gui thread" if necessary... This method must
    1:   // be executed on the "gui thread"...
    1:   nsToolkit* toolkit = (nsToolkit *)mToolkit;
    1:   NS_ASSERTION(toolkit != nsnull, "This should never be null!"); // Bug 57044
    1:   if (toolkit != nsnull && !toolkit->IsGuiThread()) {
    1:     MethodInfo info(this, nsWindow::SET_FOCUS);
    1:     toolkit->CallMethod(&info);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (mWnd) {
    1:     // Uniconify, if necessary
    1:     HWND toplevelWnd = GetTopLevelHWND(mWnd);
    1:     if (::IsIconic(toplevelWnd))
    1:       ::ShowWindow(toplevelWnd, SW_RESTORE);
    1:     ::SetFocus(mWnd);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Bounds
29835:  *
29835:  * nsIWidget::GetBounds, nsIWidget::GetScreenBounds,
29835:  * nsIWidget::GetClientBounds
29835:  *
29835:  * Bound calculations.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Get this component dimension
23738: NS_METHOD nsWindow::GetBounds(nsIntRect &aRect)
    1: {
    1:   if (mWnd) {
    1:     RECT r;
    1:     VERIFY(::GetWindowRect(mWnd, &r));
    1: 
    1:     // assign size
    1:     aRect.width  = r.right - r.left;
    1:     aRect.height = r.bottom - r.top;
    1: 
    1:     // convert coordinates if parent exists
    1:     HWND parent = ::GetParent(mWnd);
    1:     if (parent) {
    1:       RECT pr;
    1:       VERIFY(::GetWindowRect(parent, &pr));
    1:       r.left -= pr.left;
    1:       r.top  -= pr.top;
    1:     }
    1:     aRect.x = r.left;
    1:     aRect.y = r.top;
    1:   } else {
    1:     aRect = mBounds;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Get this component dimension
23738: NS_METHOD nsWindow::GetClientBounds(nsIntRect &aRect)
    1: {
    1:   if (mWnd) {
    1:     RECT r;
    1:     VERIFY(::GetClientRect(mWnd, &r));
    1: 
    1:     // assign size
    1:     aRect.x = 0;
    1:     aRect.y = 0;
    1:     aRect.width  = r.right - r.left;
    1:     aRect.height = r.bottom - r.top;
    1: 
    1:   } else {
    1:     aRect.SetRect(0,0,0,0);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
29835: // Get the bounds, but don't take into account the client size
23738: void nsWindow::GetNonClientBounds(nsIntRect &aRect)
    1: {
    1:   if (mWnd) {
    1:     RECT r;
    1:     VERIFY(::GetWindowRect(mWnd, &r));
    1: 
    1:     // assign size
    1:     aRect.width = r.right - r.left;
    1:     aRect.height = r.bottom - r.top;
    1: 
    1:     // convert coordinates if parent exists
    1:     HWND parent = ::GetParent(mWnd);
    1:     if (parent) {
    1:       RECT pr;
    1:       VERIFY(::GetWindowRect(parent, &pr));
    1:       r.left -= pr.left;
    1:       r.top -= pr.top;
    1:     }
    1:     aRect.x = r.left;
    1:     aRect.y = r.top;
    1:   } else {
    1:     aRect.SetRect(0,0,0,0);
    1:   }
    1: }
    1: 
29835: // Like GetBounds, but don't offset by the parent
23738: NS_METHOD nsWindow::GetScreenBounds(nsIntRect &aRect)
    1: {
    1:   if (mWnd) {
    1:     RECT r;
    1:     VERIFY(::GetWindowRect(mWnd, &r));
    1: 
    1:     aRect.width  = r.right - r.left;
    1:     aRect.height = r.bottom - r.top;
    1:     aRect.x = r.left;
    1:     aRect.y = r.top;
    1:   } else
    1:     aRect = mBounds;
    1: 
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetBackgroundColor
29835:  *
29835:  * Sets the window background paint color.
29835:  *
29835:  **************************************************************/
29835: 
    1: NS_METHOD nsWindow::SetBackgroundColor(const nscolor &aColor)
    1: {
    1:   nsBaseWidget::SetBackgroundColor(aColor);
    1: 
    1:   if (mBrush)
    1:     ::DeleteObject(mBrush);
    1: 
    1:   mBrush = ::CreateSolidBrush(NSRGB_2_COLOREF(mBackground));
    1: #ifndef WINCE
    1:   if (mWnd != NULL) {
25349:     ::SetClassLongPtrW(mWnd, GCLP_HBRBACKGROUND, (LONG_PTR)mBrush);
    1:   }
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetCursor
29835:  *
29835:  * SetCursor and related utilities for manging cursor state.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Set this component cursor
    1: NS_METHOD nsWindow::SetCursor(nsCursor aCursor)
    1: {
    1:   // Only change cursor if it's changing
    1: 
    1:   //XXX mCursor isn't always right.  Scrollbars and others change it, too.
    1:   //XXX If we want this optimization we need a better way to do it.
    1:   //if (aCursor != mCursor) {
    1:   HCURSOR newCursor = NULL;
    1: 
    1:   switch (aCursor) {
    1:     case eCursor_select:
    1:       newCursor = ::LoadCursor(NULL, IDC_IBEAM);
    1:       break;
    1: 
    1:     case eCursor_wait:
    1:       newCursor = ::LoadCursor(NULL, IDC_WAIT);
    1:       break;
    1: 
    1:     case eCursor_hyperlink:
    1:     {
    1:       newCursor = ::LoadCursor(NULL, IDC_HAND);
    1:       break;
    1:     }
    1: 
    1:     case eCursor_standard:
    1:       newCursor = ::LoadCursor(NULL, IDC_ARROW);
    1:       break;
    1: 
    1:     case eCursor_n_resize:
    1:     case eCursor_s_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENS);
    1:       break;
    1: 
    1:     case eCursor_w_resize:
    1:     case eCursor_e_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEWE);
    1:       break;
    1: 
    1:     case eCursor_nw_resize:
    1:     case eCursor_se_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENWSE);
    1:       break;
    1: 
    1:     case eCursor_ne_resize:
    1:     case eCursor_sw_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENESW);
    1:       break;
    1: 
    1:     case eCursor_crosshair:
    1:       newCursor = ::LoadCursor(NULL, IDC_CROSS);
    1:       break;
    1: 
    1:     case eCursor_move:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEALL);
    1:       break;
    1: 
    1:     case eCursor_help:
    1:       newCursor = ::LoadCursor(NULL, IDC_HELP);
    1:       break;
    1: 
    1:     case eCursor_copy: // CSS3
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_COPY));
    1:       break;
    1: 
    1:     case eCursor_alias:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ALIAS));
    1:       break;
    1: 
    1:     case eCursor_cell:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_CELL));
    1:       break;
    1: 
    1:     case eCursor_grab:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_GRAB));
    1:       break;
    1: 
    1:     case eCursor_grabbing:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_GRABBING));
    1:       break;
    1: 
    1:     case eCursor_spinning:
    1:       newCursor = ::LoadCursor(NULL, IDC_APPSTARTING);
    1:       break;
    1: 
    1:     case eCursor_context_menu:
    1:       // XXX this CSS3 cursor needs to be implemented
    1:       break;
    1: 
    1:     case eCursor_zoom_in:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ZOOMIN));
    1:       break;
    1: 
    1:     case eCursor_zoom_out:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ZOOMOUT));
    1:       break;
    1: 
    1:     case eCursor_not_allowed:
    1:     case eCursor_no_drop:
    1:       newCursor = ::LoadCursor(NULL, IDC_NO);
    1:       break;
    1: 
    1:     case eCursor_col_resize:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_COLRESIZE));
    1:       break;
    1: 
    1:     case eCursor_row_resize:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ROWRESIZE));
    1:       break;
    1: 
    1:     case eCursor_vertical_text:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_VERTICALTEXT));
    1:       break;
    1: 
    1:     case eCursor_all_scroll:
    1:       // XXX not 100% appropriate perhaps
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEALL);
    1:       break;
    1: 
    1:     case eCursor_nesw_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENESW);
    1:       break;
    1: 
    1:     case eCursor_nwse_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENWSE);
    1:       break;
    1: 
    1:     case eCursor_ns_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENS);
    1:       break;
    1: 
    1:     case eCursor_ew_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEWE);
    1:       break;
    1: 
10405:     case eCursor_none:
10405:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_NONE));
10405:       break;
10405: 
    1:     default:
    1:       NS_ERROR("Invalid cursor type");
    1:       break;
    1:   }
    1: 
    1:   if (NULL != newCursor) {
    1:     mCursor = aCursor;
    1:     HCURSOR oldCursor = ::SetCursor(newCursor);
    1:     
29835:     if (sHCursor == oldCursor) {
29835:       NS_IF_RELEASE(sCursorImgContainer);
29835:       if (sHCursor != NULL)
29835:         ::DestroyIcon(sHCursor);
29835:       sHCursor = NULL;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
29835: // Adjust cursor image data
29835: PRUint8* nsWindow::Data32BitTo1Bit(PRUint8* aImageData,
 4857:                                    PRUint32 aWidth, PRUint32 aHeight)
 4857: {
 4857:   // We need (aWidth + 7) / 8 bytes plus zero-padding up to a multiple of
 4857:   // 4 bytes for each row (HBITMAP requirement). Bug 353553.
 4857:   PRUint32 outBpr = ((aWidth + 31) / 8) & ~3;
 4857: 
 6354:   // Allocate and clear mask buffer
 6354:   PRUint8* outData = (PRUint8*)PR_Calloc(outBpr, aHeight);
 4857:   if (!outData)
 4857:     return NULL;
 4857: 
 6354:   PRInt32 *imageRow = (PRInt32*)aImageData;
 4857:   for (PRUint32 curRow = 0; curRow < aHeight; curRow++) {
 6354:     PRUint8 *outRow = outData + curRow * outBpr;
 6354:     PRUint8 mask = 0x80;
 4857:     for (PRUint32 curCol = 0; curCol < aWidth; curCol++) {
 6354:       // Use sign bit to test for transparency, as alpha byte is highest byte
 6354:       if (*imageRow++ < 0)
 6354:         *outRow |= mask;
 6354: 
 6354:       mask >>= 1;
 6354:       if (!mask) {
 6354:         outRow ++;
 6354:         mask = 0x80;
 6354:       }
 6354:     }
 4857:   }
 4857: 
 4857:   return outData;
 4857: }
 4857: 
29835: PRBool nsWindow::IsCursorTranslucencySupported()
29835: {
29835: #ifdef WINCE
29835:   return PR_FALSE;
29835: #else
29835:   static PRBool didCheck = PR_FALSE;
29835:   static PRBool isSupported = PR_FALSE;
29835:   if (!didCheck) {
29835:     didCheck = PR_TRUE;
29835:     // Cursor translucency is supported on Windows XP and newer
29835:     isSupported = nsWindow::GetWindowsVersion() >= 0x501;
29835:   }
29835: 
29835:   return isSupported;
29835: #endif
29835: }
29835: 
 6354: /**
 6354:  * Convert the given image data to a HBITMAP. If the requested depth is
 6354:  * 32 bit and the OS supports translucency, a bitmap with an alpha channel
 6354:  * will be returned.
 6354:  *
 6354:  * @param aImageData The image data to convert. Must use the format accepted
 6354:  *                   by CreateDIBitmap.
 6354:  * @param aWidth     With of the bitmap, in pixels.
 6354:  * @param aHeight    Height of the image, in pixels.
 6354:  * @param aDepth     Image depth, in bits. Should be one of 1, 24 and 32.
 6354:  *
 6354:  * @return The HBITMAP representing the image. Caller should call
 6354:  *         DeleteObject when done with the bitmap.
 6354:  *         On failure, NULL will be returned.
 6354:  */
29835: HBITMAP nsWindow::DataToBitmap(PRUint8* aImageData,
    1:                                PRUint32 aWidth,
    1:                                PRUint32 aHeight,
    1:                                PRUint32 aDepth)
    1: {
23335: #ifndef WINCE
 6354:   HDC dc = ::GetDC(NULL);
    1: 
    1:   if (aDepth == 32 && IsCursorTranslucencySupported()) {
    1:     // Alpha channel. We need the new header.
    1:     BITMAPV4HEADER head = { 0 };
    1:     head.bV4Size = sizeof(head);
    1:     head.bV4Width = aWidth;
    1:     head.bV4Height = aHeight;
    1:     head.bV4Planes = 1;
    1:     head.bV4BitCount = aDepth;
    1:     head.bV4V4Compression = BI_BITFIELDS;
    1:     head.bV4SizeImage = 0; // Uncompressed
    1:     head.bV4XPelsPerMeter = 0;
    1:     head.bV4YPelsPerMeter = 0;
    1:     head.bV4ClrUsed = 0;
    1:     head.bV4ClrImportant = 0;
    1: 
    1:     head.bV4RedMask   = 0x00FF0000;
    1:     head.bV4GreenMask = 0x0000FF00;
    1:     head.bV4BlueMask  = 0x000000FF;
    1:     head.bV4AlphaMask = 0xFF000000;
    1: 
    1:     HBITMAP bmp = ::CreateDIBitmap(dc,
 3233:                                    reinterpret_cast<CONST BITMAPINFOHEADER*>(&head),
    1:                                    CBM_INIT,
    1:                                    aImageData,
 3233:                                    reinterpret_cast<CONST BITMAPINFO*>(&head),
    1:                                    DIB_RGB_COLORS);
 6354:     ::ReleaseDC(NULL, dc);
    1:     return bmp;
    1:   }
    1: 
 6354:   char reserved_space[sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 2];
 6354:   BITMAPINFOHEADER& head = *(BITMAPINFOHEADER*)reserved_space;
    1: 
    1:   head.biSize = sizeof(BITMAPINFOHEADER);
    1:   head.biWidth = aWidth;
    1:   head.biHeight = aHeight;
    1:   head.biPlanes = 1;
    1:   head.biBitCount = (WORD)aDepth;
    1:   head.biCompression = BI_RGB;
    1:   head.biSizeImage = 0; // Uncompressed
    1:   head.biXPelsPerMeter = 0;
    1:   head.biYPelsPerMeter = 0;
    1:   head.biClrUsed = 0;
    1:   head.biClrImportant = 0;
    1:   
    1:   BITMAPINFO& bi = *(BITMAPINFO*)reserved_space;
    1: 
    1:   if (aDepth == 1) {
    1:     RGBQUAD black = { 0, 0, 0, 0 };
    1:     RGBQUAD white = { 255, 255, 255, 0 };
    1: 
    1:     bi.bmiColors[0] = white;
    1:     bi.bmiColors[1] = black;
    1:   }
    1: 
    1:   HBITMAP bmp = ::CreateDIBitmap(dc, &head, CBM_INIT, aImageData, &bi, DIB_RGB_COLORS);
 6354:   ::ReleaseDC(NULL, dc);
    1:   return bmp;
23335: #else
23335:   return nsnull;
23335: #endif
    1: }
    1: 
29835: // Setting the actual cursor
    1: NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,
    1:                                   PRUint32 aHotspotX, PRUint32 aHotspotY)
    1: {
29835:   if (sCursorImgContainer == aCursor && sHCursor) {
29835:     ::SetCursor(sHCursor);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Get the image data
    1:   nsCOMPtr<gfxIImageFrame> frame;
    1:   aCursor->GetFrameAt(0, getter_AddRefs(frame));
    1:   if (!frame)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:   PRInt32 width, height;
    1:   frame->GetWidth(&width);
    1:   frame->GetHeight(&height);
    1: 
 6354:   // Reject cursors greater than 128 pixels in either direction, to prevent
    1:   // spoofing.
    1:   // XXX ideally we should rescale. Also, we could modify the API to
    1:   // allow trusted content to set larger cursors.
    1:   if (width > 128 || height > 128)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:   frame->LockImageData();
    1: 
    1:   PRUint32 dataLen;
    1:   PRUint8 *data;
    1:   nsresult rv = frame->GetImageData(&data, &dataLen);
    1:   if (NS_FAILED(rv)) {
    1:     frame->UnlockImageData();
    1:     return rv;
    1:   }
    1: 
 6354:   HBITMAP bmp = DataToBitmap(data, width, -height, 32);
 6354:   PRUint8* a1data = Data32BitTo1Bit(data, width, height);
    1:   frame->UnlockImageData();
 4857:   if (!a1data) {
 4857:     return NS_ERROR_FAILURE;
 4857:   }
 4857: 
 6354:   HBITMAP mbmp = DataToBitmap(a1data, width, -height, 1);
 6354:   PR_Free(a1data);
    1: 
    1:   ICONINFO info = {0};
    1:   info.fIcon = FALSE;
    1:   info.xHotspot = aHotspotX;
    1:   info.yHotspot = aHotspotY;
 4857:   info.hbmMask = mbmp;
    1:   info.hbmColor = bmp;
    1:   
    1:   HCURSOR cursor = ::CreateIconIndirect(&info);
 4857:   ::DeleteObject(mbmp);
    1:   ::DeleteObject(bmp);
    1:   if (cursor == NULL) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   mCursor = nsCursor(-1);
    1:   ::SetCursor(cursor);
    1: 
29835:   NS_IF_RELEASE(sCursorImgContainer);
29835:   sCursorImgContainer = aCursor;
29835:   NS_ADDREF(sCursorImgContainer);
29835: 
29835:   if (sHCursor != NULL)
29835:     ::DestroyIcon(sHCursor);
29835:   sHCursor = cursor;
    1: 
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Get/SetTransparencyMode
29835:  *
29835:  * Manage the transparency mode of the top-level window
29835:  * containing this widget.
29835:  *
29835:  **************************************************************/
29835: 
29835: #ifdef MOZ_XUL
29835: nsTransparencyMode nsWindow::GetTransparencyMode()
29835: {
29835:   return GetTopLevelWindow(PR_TRUE)->GetWindowTranslucencyInner();
29835: }
29835: 
29835: void nsWindow::SetTransparencyMode(nsTransparencyMode aMode)
29835: {
29835:   GetTopLevelWindow(PR_TRUE)->SetWindowTranslucencyInner(aMode);
29835: }
29835: #endif
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::HideWindowChrome
29835:  *
29835:  * Show or hide window chrome.
29835:  *
29835:  **************************************************************/
29835: 
    1: NS_IMETHODIMP nsWindow::HideWindowChrome(PRBool aShouldHide)
    1: {
    1:   HWND hwnd = GetTopLevelHWND(mWnd, PR_TRUE);
    1:   if (!GetNSWindowPtr(hwnd))
    1:   {
    1:     NS_WARNING("Trying to hide window decorations in an embedded context");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
25349:   DWORD_PTR style, exStyle;
    1:   if (aShouldHide) {
25349:     DWORD_PTR tempStyle = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
25349:     DWORD_PTR tempExStyle = ::GetWindowLongPtrW(hwnd, GWL_EXSTYLE);
    1: 
    1:     style = tempStyle & ~(WS_CAPTION | WS_THICKFRAME);
    1:     exStyle = tempExStyle & ~(WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE |
    1:                               WS_EX_CLIENTEDGE | WS_EX_STATICEDGE);
    1: 
    1:     mOldStyle = tempStyle;
    1:     mOldExStyle = tempExStyle;
    1:   }
    1:   else {
    1:     if (!mOldStyle || !mOldExStyle) {
25349:       mOldStyle = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
25349:       mOldExStyle = ::GetWindowLongPtrW(hwnd, GWL_EXSTYLE);
    1:     }
    1: 
    1:     style = mOldStyle;
    1:     exStyle = mOldExStyle;
    1:   }
    1: 
19016:   VERIFY_WINDOW_STYLE(style);
25349:   ::SetWindowLongPtrW(hwnd, GWL_STYLE, style);
25349:   ::SetWindowLongPtrW(hwnd, GWL_EXSTYLE, exStyle);
    1: 
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Validate, nsIWidget::Invalidate
29835:  *
29835:  * Validate or invalidate an area of the client for painting.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Validate a visible area of a widget.
    1: NS_METHOD nsWindow::Validate()
    1: {
    1:   if (mWnd)
    1:     VERIFY(::ValidateRect(mWnd, NULL));
    1:   return NS_OK;
    1: }
    1: 
    1: // Invalidate this component visible area
    1: NS_METHOD nsWindow::Invalidate(PRBool aIsSynchronous)
    1: {
    1:   if (mWnd)
    1:   {
29835: #ifdef WIDGET_DEBUG_OUTPUT
    1:     debug_DumpInvalidate(stdout,
    1:                          this,
    1:                          nsnull,
    1:                          aIsSynchronous,
    1:                          nsCAutoString("noname"),
    1:                          (PRInt32) mWnd);
29835: #endif // WIDGET_DEBUG_OUTPUT
    1: 
    1:     VERIFY(::InvalidateRect(mWnd, NULL, FALSE));
    1: 
    1:     if (aIsSynchronous) {
    1:       VERIFY(::UpdateWindow(mWnd));
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Invalidate this component visible area
23738: NS_METHOD nsWindow::Invalidate(const nsIntRect & aRect, PRBool aIsSynchronous)
    1: {
    1:   if (mWnd)
    1:   {
29835: #ifdef WIDGET_DEBUG_OUTPUT
    1:     debug_DumpInvalidate(stdout,
    1:                          this,
    1:                          &aRect,
    1:                          aIsSynchronous,
    1:                          nsCAutoString("noname"),
    1:                          (PRInt32) mWnd);
29835: #endif // WIDGET_DEBUG_OUTPUT
    1: 
    1:     RECT rect;
    1: 
    1:     rect.left   = aRect.x;
    1:     rect.top    = aRect.y;
    1:     rect.right  = aRect.x + aRect.width;
    1:     rect.bottom = aRect.y + aRect.height;
    1: 
    1:     VERIFY(::InvalidateRect(mWnd, &rect, FALSE));
    1: 
    1:     if (aIsSynchronous) {
    1:       VERIFY(::UpdateWindow(mWnd));
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
30075: NS_IMETHODIMP
30075: nsWindow::MakeFullScreen(PRBool aFullScreen)
30075: {
30123: #if WINCE_WINDOWS_MOBILE
30075:   RECT rc;
30075:   if (aFullScreen) {
30075:     SetForegroundWindow(mWnd);
30075:     SHFullScreen(mWnd, SHFS_HIDETASKBAR | SHFS_HIDESTARTICON);
30075:     SetRect(&rc, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
30075:   }
30075:   else {
30075:     SHFullScreen(mWnd, SHFS_SHOWTASKBAR | SHFS_SHOWSTARTICON);
30075:     SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, FALSE);
30075:   }
30075:   MoveWindow(mWnd, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, TRUE);
30123: 
30123:   if (aFullScreen)
30123:     mSizeMode = nsSizeMode_Fullscreen;
30123: #endif
30123: 
30075:   return nsBaseWidget::MakeFullScreen(aFullScreen);
30075: }
30075: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Update
29835:  *
29835:  * Force a synchronous repaint of the window.
29835:  *
29835:  **************************************************************/
29835: 
    1: NS_IMETHODIMP nsWindow::Update()
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   // updates can come through for windows no longer holding an mWnd during
    1:   // deletes triggered by JavaScript in buttons with mouse feedback
    1:   if (mWnd)
    1:     VERIFY(::UpdateWindow(mWnd));
    1: 
    1:   return rv;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Scroll
29835:  *
29835:  * Scroll this widget.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Invalidates a window if it's not one of ours, for example
29835: // a window created by a plugin.
29835: BOOL CALLBACK nsWindow::InvalidateForeignChildWindows(HWND aWnd, LPARAM aMsg)
29835: {
29835:   LONG_PTR proc = ::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
29835:   if (proc != (LONG_PTR)&nsWindow::WindowProc) {
29835:     // This window is not one of our windows so invalidate it.
29835:     VERIFY(::InvalidateRect(aWnd, NULL, FALSE));    
29835:   }
29835:   return TRUE;
29835: }
29835: 
29835: // Scroll
29835: NS_METHOD nsWindow::Scroll(PRInt32 aDx, PRInt32 aDy, nsIntRect *aClipRect)
29835: {
29835:   RECT  trect;
29835: 
29835:   if (nsnull != aClipRect)
29835:   {
29835:     trect.left = aClipRect->x;
29835:     trect.top = aClipRect->y;
29835:     trect.right = aClipRect->XMost();
29835:     trect.bottom = aClipRect->YMost();
29835:   }
29835: 
29835:   ::ScrollWindowEx(mWnd, aDx, aDy, NULL, (nsnull != aClipRect) ? &trect : NULL,
29835:                    NULL, NULL, SW_INVALIDATE | SW_SCROLLCHILDREN);
29835:   // Invalidate all child windows that aren't ours; we're moving them, and we
29835:   // expect them to be painted at the new location even if they're outside the
29835:   // region we're bit-blit scrolling. See bug 387701.
29835: #if !defined(WINCE)
29835:   ::EnumChildWindows(GetWindowHandle(), nsWindow::InvalidateForeignChildWindows, NULL);
29835: #else
29835:   nsWindowCE::EnumChildWindows(GetWindowHandle(), nsWindow::InvalidateForeignChildWindows, NULL);
29835: #endif
29835:   ::UpdateWindow(mWnd);
29835:   return NS_OK;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Native data storage
29835:  *
29835:  * nsIWidget::GetNativeData
29835:  * nsIWidget::FreeNativeData
29835:  *
29835:  * Set or clear native data based on a constant.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Return some native data according to aDataType
    1: void* nsWindow::GetNativeData(PRUint32 aDataType)
    1: {
    1:   switch (aDataType) {
21999:     case NS_NATIVE_PLUGIN_PORT:
21999:       mIsPluginWindow = 1;
    1:     case NS_NATIVE_WIDGET:
    1:     case NS_NATIVE_WINDOW:
    1:       return (void*)mWnd;
    1:     case NS_NATIVE_GRAPHIC:
    1:       // XXX:  This is sleezy!!  Remember to Release the DC after using it!
    1: #ifdef MOZ_XUL
16601:       return (void*)(eTransparencyTransparent == mTransparencyMode) ?
    1:         mMemoryDC : ::GetDC(mWnd);
    1: #else
    1:       return (void*)::GetDC(mWnd);
    1: #endif
24836: 
24836: #ifdef NS_ENABLE_TSF
25395:     case NS_NATIVE_TSF_THREAD_MGR:
25395:       return nsTextStore::GetThreadMgr();
25395:     case NS_NATIVE_TSF_CATEGORY_MGR:
25395:       return nsTextStore::GetCategoryMgr();
25395:     case NS_NATIVE_TSF_DISPLAY_ATTR_MGR:
25395:       return nsTextStore::GetDisplayAttrMgr();
24836: #endif //NS_ENABLE_TSF
24836: 
    1:     default:
    1:       break;
    1:   }
    1: 
    1:   return NULL;
    1: }
    1: 
29835: // Free some native data according to aDataType
    1: void nsWindow::FreeNativeData(void * data, PRUint32 aDataType)
    1: {
    1:   switch (aDataType)
    1:   {
    1:     case NS_NATIVE_GRAPHIC:
    1: #ifdef MOZ_XUL
16601:       if (eTransparencyTransparent != mTransparencyMode)
    1:         ::ReleaseDC(mWnd, (HDC)data);
    1: #else
    1:       ::ReleaseDC(mWnd, (HDC)data);
    1: #endif
    1:       break;
    1:     case NS_NATIVE_WIDGET:
    1:     case NS_NATIVE_WINDOW:
    1:     case NS_NATIVE_PLUGIN_PORT:
    1:       break;
    1:     default:
    1:       break;
    1:   }
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetTitle
29835:  *
29835:  * Set the main windows title text.
29835:  *
29835:  **************************************************************/
29835: 
29835: NS_METHOD nsWindow::SetTitle(const nsAString& aTitle)
29835: {
29835:   const nsString& strTitle = PromiseFlatString(aTitle);
29835:   ::SendMessageW(mWnd, WM_SETTEXT, (WPARAM)0, (LPARAM)(LPCWSTR)strTitle.get());
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetIcon
29835:  *
29835:  * Set the main windows icon.
29835:  *
29835:  **************************************************************/
29835: 
29835: NS_METHOD nsWindow::SetIcon(const nsAString& aIconSpec) 
29835: {
29835: #ifndef WINCE
29835:   // Assume the given string is a local identifier for an icon file.
29835: 
29835:   nsCOMPtr<nsILocalFile> iconFile;
29835:   ResolveIconName(aIconSpec, NS_LITERAL_STRING(".ico"),
29835:                   getter_AddRefs(iconFile));
29835:   if (!iconFile)
29835:     return NS_OK; // not an error if icon is not found
29835: 
29835:   nsAutoString iconPath;
29835:   iconFile->GetPath(iconPath);
29835: 
29835:   // XXX this should use MZLU (see bug 239279)
29835: 
29835:   ::SetLastError(0);
29835: 
29835:   HICON bigIcon = (HICON)::LoadImageW(NULL,
29835:                                       (LPCWSTR)iconPath.get(),
29835:                                       IMAGE_ICON,
29835:                                       ::GetSystemMetrics(SM_CXICON),
29835:                                       ::GetSystemMetrics(SM_CYICON),
29835:                                       LR_LOADFROMFILE );
29835:   HICON smallIcon = (HICON)::LoadImageW(NULL,
29835:                                         (LPCWSTR)iconPath.get(),
29835:                                         IMAGE_ICON,
29835:                                         ::GetSystemMetrics(SM_CXSMICON),
29835:                                         ::GetSystemMetrics(SM_CYSMICON),
29835:                                         LR_LOADFROMFILE );
29835: 
29835:   if (bigIcon) {
29835:     HICON icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM)bigIcon);
29835:     if (icon)
29835:       ::DestroyIcon(icon);
29835:   }
29835: #ifdef DEBUG_SetIcon
29835:   else {
29835:     NS_LossyConvertUTF16toASCII cPath(iconPath);
29835:     printf( "\nIcon load error; icon=%s, rc=0x%08X\n\n", cPath.get(), ::GetLastError() );
29835:   }
29835: #endif
29835:   if (smallIcon) {
29835:     HICON icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)smallIcon);
29835:     if (icon)
29835:       ::DestroyIcon(icon);
29835:   }
29835: #ifdef DEBUG_SetIcon
29835:   else {
29835:     NS_LossyConvertUTF16toASCII cPath(iconPath);
29835:     printf( "\nSmall icon load error; icon=%s, rc=0x%08X\n\n", cPath.get(), ::GetLastError() );
29835:   }
29835: #endif
29835: #endif // WINCE
29835:   return NS_OK;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::WidgetToScreenOffset
29835:  *
29835:  * Return this widget's origin in screen coordinates.
29835:  *
29835:  **************************************************************/
29835: 
29835: nsIntPoint nsWindow::WidgetToScreenOffset()
29835: {
29835:   POINT point;
29835:   point.x = 0;
29835:   point.y = 0;
29835:   ::ClientToScreen(mWnd, &point);
29835:   return nsIntPoint(point.x, point.y);
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Deferred window positioning.
29835:  *
29835:  * nsIWidget::BeginResizingChildren,
29835:  * nsIWidget::EndResizingChildren
29835:  *
29835:  * Filters child paint events during a resize operation.
29835:  *
29835:  **************************************************************/
29835: 
29835: NS_METHOD nsWindow::BeginResizingChildren(void)
29835: {
29835:   if (NULL == mDeferredPositioner)
29835:     mDeferredPositioner = ::BeginDeferWindowPos(1);
29835:   return NS_OK;
29835: }
29835: 
29835: NS_METHOD nsWindow::EndResizingChildren(void)
29835: {
29835:   if (NULL != mDeferredPositioner) {
29835:     ::EndDeferWindowPos(mDeferredPositioner);
29835:     mDeferredPositioner = NULL;
29835:   }
29835:   return NS_OK;
29835: }
29835: 
29835: LPARAM nsWindow::lParamToScreen(LPARAM lParam)
29835: {
29835:   POINT pt;
29835:   pt.x = GET_X_LPARAM(lParam);
29835:   pt.y = GET_Y_LPARAM(lParam);
29835:   ::ClientToScreen(mWnd, &pt);
29835:   return MAKELPARAM(pt.x, pt.y);
29835: }
29835: 
29835: LPARAM nsWindow::lParamToClient(LPARAM lParam)
29835: {
29835:   POINT pt;
29835:   pt.x = GET_X_LPARAM(lParam);
29835:   pt.y = GET_Y_LPARAM(lParam);
29835:   ::ScreenToClient(mWnd, &pt);
29835:   return MAKELPARAM(pt.x, pt.y);
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::EnableDragDrop
29835:  *
29835:  * Enables/Disables drag and drop of files on this widget.
29835:  *
29835:  **************************************************************/
29835: 
29835: #if !defined(WINCE) // implemented in nsWindowCE.cpp
29835: NS_METHOD nsWindow::EnableDragDrop(PRBool aEnable)
29835: {
29835:   nsresult rv = NS_ERROR_FAILURE;
29835:   if (aEnable) {
29835:     if (nsnull == mNativeDragTarget) {
29835:        mNativeDragTarget = new nsNativeDragTarget(this);
29835:        if (NULL != mNativeDragTarget) {
29835:          mNativeDragTarget->AddRef();
29835:          if (S_OK == ::CoLockObjectExternal((LPUNKNOWN)mNativeDragTarget,TRUE,FALSE)) {
29835:            if (S_OK == ::RegisterDragDrop(mWnd, (LPDROPTARGET)mNativeDragTarget)) {
29835:              rv = NS_OK;
29835:            }
29835:          }
29835:        }
29835:     }
29835:   } else {
29835:     if (nsnull != mWnd && NULL != mNativeDragTarget) {
29835:       ::RevokeDragDrop(mWnd);
29835:       if (S_OK == ::CoLockObjectExternal((LPUNKNOWN)mNativeDragTarget, FALSE, TRUE)) {
29835:         rv = NS_OK;
29835:       }
29835:       mNativeDragTarget->mDragCancelled = PR_TRUE;
29835:       NS_RELEASE(mNativeDragTarget);
29835:     }
29835:   }
29835:   return rv;
29835: }
29835: #endif
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::CaptureMouse
29835:  *
29835:  * Enables/Disables system mouse capture.
29835:  *
29835:  **************************************************************/
29835: 
29835: NS_METHOD nsWindow::CaptureMouse(PRBool aCapture)
29835: {
29835:   if (!nsToolkit::gMouseTrailer) {
29835:     NS_ERROR("nsWindow::CaptureMouse called after nsToolkit destroyed");
29835:     return NS_OK;
29835:   }
29835: 
29835:   if (aCapture) {
29835:     nsToolkit::gMouseTrailer->SetCaptureWindow(mWnd);
29835:     ::SetCapture(mWnd);
29835:   } else {
29835:     nsToolkit::gMouseTrailer->SetCaptureWindow(NULL);
29835:     ::ReleaseCapture();
29835:   }
29835:   mIsInMouseCapture = aCapture;
29835:   return NS_OK;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::CaptureRollupEvents
29835:  *
29835:  * Dealing with event rollup on destroy for popups. Enables &
29835:  * Disables system capture of any and all events that would
29835:  * cause a dropdown to be rolled up.
29835:  *
29835:  **************************************************************/
29835: 
29835: NS_IMETHODIMP nsWindow::CaptureRollupEvents(nsIRollupListener * aListener,
29835:                                             PRBool aDoCapture,
29835:                                             PRBool aConsumeRollupEvent)
29835: {
29835:   if (aDoCapture) {
29835:     /* we haven't bothered carrying a weak reference to sRollupWidget because
29835:        we believe lifespan is properly scoped. this next assertion helps
29835:        assure that remains true. */
29835:     NS_ASSERTION(!sRollupWidget, "rollup widget reassigned before release");
29835:     sRollupConsumeEvent = aConsumeRollupEvent;
29835:     NS_IF_RELEASE(sRollupListener);
29835:     NS_IF_RELEASE(sRollupWidget);
29835:     sRollupListener = aListener;
29835:     NS_ADDREF(aListener);
29835:     sRollupWidget = this;
29835:     NS_ADDREF(this);
29835: 
29835: #ifndef WINCE
29835:     if (!sMsgFilterHook && !sCallProcHook && !sCallMouseHook) {
29835:       RegisterSpecialDropdownHooks();
29835:     }
29835:     sProcessHook = PR_TRUE;
29835: #endif
29835:     
29835:   } else {
29835:     NS_IF_RELEASE(sRollupListener);
29835:     NS_IF_RELEASE(sRollupWidget);
29835:     
29835: #ifndef WINCE
29835:     sProcessHook = PR_FALSE;
29835:     UnregisterSpecialDropdownHooks();
29835: #endif
29835:   }
29835: 
29835:   return NS_OK;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::GetAttention
29835:  *
29835:  * Bring this window to the user's attention.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Draw user's attention to this window until it comes to foreground.
29835: NS_IMETHODIMP
29835: nsWindow::GetAttention(PRInt32 aCycleCount)
29835: {
29835: #ifndef WINCE
29835:   // Got window?
29835:   if (!mWnd)
29835:     return NS_ERROR_NOT_INITIALIZED;
29835: 
29835:   // Don't flash if the flash count is 0 or if the
29835:   // top level window is already active.
29835:   HWND fgWnd = ::GetForegroundWindow();
29835:   if (aCycleCount == 0 || fgWnd == GetTopLevelHWND(mWnd))
29835:     return NS_OK;
29835: 
29835:   HWND flashWnd = mWnd;
29835:   while (HWND ownerWnd = ::GetWindow(flashWnd, GW_OWNER)) {
29835:     flashWnd = ownerWnd;
29835:   }
29835: 
29835:   // Don't flash if the owner window is active either.
29835:   if (fgWnd == flashWnd)
29835:     return NS_OK;
29835: 
29835:   DWORD defaultCycleCount = 0;
29835:   ::SystemParametersInfo(SPI_GETFOREGROUNDFLASHCOUNT, 0, &defaultCycleCount, 0);
29835: 
29835:   FLASHWINFO flashInfo = { sizeof(FLASHWINFO), flashWnd,
29835:     FLASHW_ALL, aCycleCount > 0 ? aCycleCount : defaultCycleCount, 0 };
29835:   ::FlashWindowEx(&flashInfo);
29835: #endif
29835:   return NS_OK;
29835: }
29835: 
29835: void nsWindow::StopFlashing()
29835: {
29835: #ifndef WINCE
29835:   HWND flashWnd = mWnd;
29835:   while (HWND ownerWnd = ::GetWindow(flashWnd, GW_OWNER)) {
29835:     flashWnd = ownerWnd;
29835:   }
29835: 
29835:   FLASHWINFO flashInfo = { sizeof(FLASHWINFO), flashWnd,
29835:     FLASHW_STOP, 0, 0 };
29835:   ::FlashWindowEx(&flashInfo);
29835: #endif
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::HasPendingInputEvent
29835:  *
29835:  * Ask whether there user input events pending.  All input events are
29835:  * included, including those not targeted at this nsIwidget instance.
29835:  *
29835:  **************************************************************/
29835: 
29835: PRBool
29835: nsWindow::HasPendingInputEvent()
29835: {
29835:   // If there is pending input or the user is currently
29835:   // moving the window then return true.
29835:   // Note: When the user is moving the window WIN32 spins
29835:   // a separate event loop and input events are not
29835:   // reported to the application.
29835:   WORD qstatus = HIWORD(GetQueueStatus(QS_INPUT));
29835:   nsToolkit* toolkit = (nsToolkit *)mToolkit;
29835:   return qstatus || (toolkit && toolkit->UserIsMovingWindow());
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::GetThebesSurface
29835:  *
29835:  * Get the Thebes surface associated with this widget.
29835:  *
29835:  **************************************************************/
29835: 
29835: gfxASurface *nsWindow::GetThebesSurface()
29835: {
29835:   if (mPaintDC)
29835:     return (new gfxWindowsSurface(mPaintDC));
29835: 
29835:   return (new gfxWindowsSurface(mWnd));
29835: }
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: nsSwitchToUIThread impl.
29835:  **
29835:  ** Switch thread to match the thread the widget was created
29835:  ** in so messages will be dispatched.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsSwitchToUIThread::CallMethod
29835:  *
29835:  * Every function that needs a thread switch goes through this function
29835:  * by calling SendMessage (..WM_CALLMETHOD..) in nsToolkit::CallMethod.
29835:  *
29835:  **************************************************************/
29835: 
    1: BOOL nsWindow::CallMethod(MethodInfo *info)
    1: {
    1:   BOOL bRet = TRUE;
    1: 
    1:   switch (info->methodId) {
    1:     case nsWindow::CREATE:
    1:       NS_ASSERTION(info->nArgs == 7, "Wrong number of arguments to CallMethod");
    1:       Create((nsIWidget*)(info->args[0]),
23738:              (nsIntRect&)*(nsIntRect*)(info->args[1]),
    1:              (EVENT_CALLBACK)(info->args[2]),
    1:              (nsIDeviceContext*)(info->args[3]),
    1:              (nsIAppShell *)(info->args[4]),
    1:              (nsIToolkit*)(info->args[5]),
    1:              (nsWidgetInitData*)(info->args[6]));
    1:       break;
    1: 
    1:     case nsWindow::CREATE_NATIVE:
    1:       NS_ASSERTION(info->nArgs == 7, "Wrong number of arguments to CallMethod");
    1:       Create((nsNativeWidget)(info->args[0]),
23738:              (nsIntRect&)*(nsIntRect*)(info->args[1]),
    1:              (EVENT_CALLBACK)(info->args[2]),
    1:              (nsIDeviceContext*)(info->args[3]),
    1:              (nsIAppShell *)(info->args[4]),
    1:              (nsIToolkit*)(info->args[5]),
    1:              (nsWidgetInitData*)(info->args[6]));
    1:       return TRUE;
    1: 
    1:     case nsWindow::DESTROY:
    1:       NS_ASSERTION(info->nArgs == 0, "Wrong number of arguments to CallMethod");
    1:       Destroy();
    1:       break;
    1: 
    1:     case nsWindow::SET_FOCUS:
    1:       NS_ASSERTION(info->nArgs == 0, "Wrong number of arguments to CallMethod");
    1:       SetFocus(PR_FALSE);
    1:       break;
    1: 
    1:     default:
    1:       bRet = FALSE;
    1:       break;
    1:   }
    1: 
    1:   return bRet;
    1: }
    1: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Moz Events
29835:  **
29835:  ** Moz GUI event management. 
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Mozilla event initialization
29835:  *
29835:  * Helpers for initializing moz events.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Event intialization
29835: MSG nsWindow::InitMSG(UINT aMessage, WPARAM wParam, LPARAM lParam)
29835: {
29835:   MSG msg;
29835:   msg.message = aMessage;
29835:   msg.wParam  = wParam;
29835:   msg.lParam  = lParam;
29835:   return msg;
29835: }
29835: 
29835: void nsWindow::InitEvent(nsGUIEvent& event, nsIntPoint* aPoint)
29835: {
29835:   if (nsnull == aPoint) {     // use the point from the event
29835:     // get the message position in client coordinates
29835:     if (mWnd != NULL) {
29835: 
29835:       DWORD pos = ::GetMessagePos();
29835:       POINT cpos;
29835:       
29835:       cpos.x = GET_X_LPARAM(pos);
29835:       cpos.y = GET_Y_LPARAM(pos);
29835: 
29835:       ::ScreenToClient(mWnd, &cpos);
29835:       event.refPoint.x = cpos.x;
29835:       event.refPoint.y = cpos.y;
    1:     } else {
29835:       event.refPoint.x = 0;
29835:       event.refPoint.y = 0;
29835:     }
29835:   }
29835:   else {  
29835:     // use the point override if provided
29835:     event.refPoint.x = aPoint->x;
29835:     event.refPoint.y = aPoint->y;
29835:   }
29835: 
29835:   event.time = ::GetMessageTime();
29835: 
29835:   mLastPoint = event.refPoint;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Moz event dispatch helpers
29835:  *
29835:  * Helpers for dispatching different types of moz events.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Main event dispatch. Invokes callback and ProcessEvent method on
29835: // Event Listener object. Part of nsIWidget.
29835: NS_IMETHODIMP nsWindow::DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus)
29835: {
29835: #ifdef WIDGET_DEBUG_OUTPUT
29835:   debug_DumpEvent(stdout,
29835:                   event->widget,
29835:                   event,
29835:                   nsCAutoString("something"),
29835:                   (PRInt32) mWnd);
29835: #endif // WIDGET_DEBUG_OUTPUT
29835: 
29835:   aStatus = nsEventStatus_eIgnore;
29835: 
29835:   // skip processing of suppressed blur events
29835:   if (event->message == NS_DEACTIVATE && BlurEventsSuppressed())
29835:     return NS_OK;
29835: 
29835:   if (nsnull != mEventCallback) {
29835:     aStatus = (*mEventCallback)(event);
29835:   }
29835: 
29835:   // Dispatch to event listener if event was not consumed
29835:   if ((aStatus != nsEventStatus_eIgnore) && (nsnull != mEventListener)) {
29835:     aStatus = mEventListener->ProcessEvent(*event);
29835:   }
29835: 
29835:   // the window can be destroyed during processing of seemingly innocuous events like, say,
29835:   // mousedowns due to the magic of scripting. mousedowns will return nsEventStatus_eIgnore,
29835:   // which causes problems with the deleted window. therefore:
29835:   if (mOnDestroyCalled)
29835:     aStatus = nsEventStatus_eConsumeNoDefault;
29835:   return NS_OK;
29835: }
29835: 
29835: PRBool nsWindow::DispatchStandardEvent(PRUint32 aMsg)
29835: {
29835:   nsGUIEvent event(PR_TRUE, aMsg, this);
29835:   InitEvent(event);
29835: 
29835:   PRBool result = DispatchWindowEvent(&event);
29835:   return result;
29835: }
29835: 
29835: PRBool nsWindow::DispatchWindowEvent(nsGUIEvent* event)
29835: {
29835:   nsEventStatus status;
29835:   DispatchEvent(event, status);
29835:   return ConvertStatus(status);
29835: }
29835: 
29835: PRBool nsWindow::DispatchWindowEvent(nsGUIEvent* event, nsEventStatus &aStatus) {
29835:   DispatchEvent(event, aStatus);
29835:   return ConvertStatus(aStatus);
29835: }
29835: 
14328: PRBool nsWindow::DispatchKeyEvent(PRUint32 aEventType, WORD aCharCode,
14476:                    const nsTArray<nsAlternativeCharCode>* aAlternativeCharCodes,
22788:                    UINT aVirtualCharCode, const MSG *aMsg,
27961:                    const nsModifierKeyState &aModKeyState,
22788:                    PRUint32 aFlags)
    1: {
    1:   nsKeyEvent event(PR_TRUE, aEventType, this);
23738:   nsIntPoint point(0, 0);
    1: 
    1:   InitEvent(event, &point); // this add ref's event.widget
    1: 
    1:   event.flags |= aFlags;
    1:   event.charCode = aCharCode;
14476:   if (aAlternativeCharCodes)
14476:     event.alternativeCharCodes.AppendElements(*aAlternativeCharCodes);
    1:   event.keyCode  = aVirtualCharCode;
    1: 
    1: #ifdef KE_DEBUG
    1:   static cnt=0;
    1:   printf("%d DispatchKE Type: %s charCode %d  keyCode %d ", cnt++,
    1:         (NS_KEY_PRESS == aEventType) ? "PRESS" : (aEventType == NS_KEY_UP ? "Up" : "Down"),
    1:          event.charCode, event.keyCode);
    1:   printf("Shift: %s Control %s Alt: %s \n", 
    1:          (mIsShiftDown ? "D" : "U"), (mIsControlDown ? "D" : "U"), (mIsAltDown ? "D" : "U"));
    1:   printf("[%c][%c][%c] <==   [%c][%c][%c][ space bar ][%c][%c][%c]\n",
    1:          IS_VK_DOWN(NS_VK_SHIFT) ? 'S' : ' ',
    1:          IS_VK_DOWN(NS_VK_CONTROL) ? 'C' : ' ',
    1:          IS_VK_DOWN(NS_VK_ALT) ? 'A' : ' ',
    1:          IS_VK_DOWN(VK_LSHIFT) ? 'S' : ' ',
    1:          IS_VK_DOWN(VK_LCONTROL) ? 'C' : ' ',
    1:          IS_VK_DOWN(VK_LMENU) ? 'A' : ' ',
    1:          IS_VK_DOWN(VK_RMENU) ? 'A' : ' ',
    1:          IS_VK_DOWN(VK_RCONTROL) ? 'C' : ' ',
    1:          IS_VK_DOWN(VK_RSHIFT) ? 'S' : ' ');
    1: #endif
    1: 
27961:   event.isShift   = aModKeyState.mIsShiftDown;
27961:   event.isControl = aModKeyState.mIsControlDown;
    1:   event.isMeta    = PR_FALSE;
27961:   event.isAlt     = aModKeyState.mIsAltDown;
    1: 
    1:   nsPluginEvent pluginEvent;
22788:   if (aMsg && PluginHasFocus()) {
22788:     pluginEvent.event = aMsg->message;
22788:     pluginEvent.wParam = aMsg->wParam;
22788:     pluginEvent.lParam = aMsg->lParam;
    1:     event.nativeMsg = (void *)&pluginEvent;
22788:   }
    1: 
    1:   PRBool result = DispatchWindowEvent(&event);
    1: 
    1:   return result;
    1: }
    1: 
29835: PRBool nsWindow::DispatchCommandEvent(PRUint32 aEventCommand)
29835: {
29835:   nsCOMPtr<nsIAtom> command;
29835:   switch (aEventCommand) {
29835:     case APPCOMMAND_BROWSER_BACKWARD:
29835:       command = nsWidgetAtoms::Back;
29835:       break;
29835:     case APPCOMMAND_BROWSER_FORWARD:
29835:       command = nsWidgetAtoms::Forward;
29835:       break;
29835:     case APPCOMMAND_BROWSER_REFRESH:
29835:       command = nsWidgetAtoms::Reload;
29835:       break;
29835:     case APPCOMMAND_BROWSER_STOP:
29835:       command = nsWidgetAtoms::Stop;
29835:       break;
29835:     case APPCOMMAND_BROWSER_SEARCH:
29835:       command = nsWidgetAtoms::Search;
29835:       break;
29835:     case APPCOMMAND_BROWSER_FAVORITES:
29835:       command = nsWidgetAtoms::Bookmarks;
29835:       break;
29835:     case APPCOMMAND_BROWSER_HOME:
29835:       command = nsWidgetAtoms::Home;
29835:       break;
29835:     default:
29835:       return PR_FALSE;
29835:   }
29835:   nsCommandEvent event(PR_TRUE, nsWidgetAtoms::onAppCommand, command, this);
29835: 
29835:   InitEvent(event);
29835:   DispatchWindowEvent(&event);
29835: 
29835:   return PR_TRUE;
29835: }
29835: 
29835: // Recursively dispatch synchronous paints for nsIWidget
29835: // descendants with invalidated rectangles.
29835: BOOL CALLBACK nsWindow::DispatchStarvedPaints(HWND aWnd, LPARAM aMsg)
29835: {
29835:   LONG_PTR proc = ::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
29835:   if (proc == (LONG_PTR)&nsWindow::WindowProc) {
29835:     // its one of our windows so check to see if it has a
29835:     // invalidated rect. If it does. Dispatch a synchronous
29835:     // paint.
29835:     if (GetUpdateRect(aWnd, NULL, FALSE)) {
29835:       VERIFY(::UpdateWindow(aWnd));
29835:     }
29835:   }
29835:   return TRUE;
29835: }
29835: 
29835: // Check for pending paints and dispatch any pending paint
29835: // messages for any nsIWidget which is a descendant of the
29835: // top-level window that *this* window is embedded within.
29835: //
29835: // Note: We do not dispatch pending paint messages for non
29835: // nsIWidget managed windows.
29835: void nsWindow::DispatchPendingEvents()
29835: {
29835:   gLastInputEventTime = PR_IntervalToMicroseconds(PR_IntervalNow());
29835: 
29835:   // We need to ensure that reflow events do not get starved.
29835:   // At the same time, we don't want to recurse through here
29835:   // as that would prevent us from dispatching starved paints.
29835:   static int recursionBlocker = 0;
29835:   if (recursionBlocker++ == 0) {
29835:     NS_ProcessPendingEvents(nsnull, PR_MillisecondsToInterval(100));
29835:     --recursionBlocker;
29835:   }
29835: 
29835:   // Quickly check to see if there are any
29835:   // paint events pending.
29835:   if (::GetQueueStatus(QS_PAINT)) {
29835:     // Find the top level window.
29835:     HWND topWnd = GetTopLevelHWND(mWnd);
29835: 
29835:     // Dispatch pending paints for all topWnd's descendant windows.
29835:     // Note: EnumChildWindows enumerates all descendant windows not just
29835:     // it's children.
29835: #if !defined(WINCE)
29835:     ::EnumChildWindows(topWnd, nsWindow::DispatchStarvedPaints, NULL);
29835: #else
29835:     nsWindowCE::EnumChildWindows(topWnd, nsWindow::DispatchStarvedPaints, NULL);
29835: #endif
29835:   }
29835: }
29835: 
29835: // Deal with plugin events
29835: PRBool nsWindow::DispatchPluginEvent(const MSG &aMsg)
29835: {
29835:   if (!PluginHasFocus())
29835:     return PR_FALSE;
29835: 
29835:   nsGUIEvent event(PR_TRUE, NS_PLUGIN_EVENT, this);
29835:   nsIntPoint point(0, 0);
29835:   InitEvent(event, &point);
29835:   nsPluginEvent pluginEvent;
29835:   pluginEvent.event = aMsg.message;
29835:   pluginEvent.wParam = aMsg.wParam;
29835:   pluginEvent.lParam = aMsg.lParam;
29835:   event.nativeMsg = (void *)&pluginEvent;
29835:   return DispatchWindowEvent(&event);
29835: }
29835: 
22788: void nsWindow::RemoveMessageAndDispatchPluginEvent(UINT aFirstMsg,
22788:                                                    UINT aLastMsg)
22788: {
22788:   MSG msg;
22788:   ::GetMessageW(&msg, mWnd, aFirstMsg, aLastMsg);
22788:   DispatchPluginEvent(msg);
22788: }
22788: 
29835: // Deal with all sort of mouse event
29835: PRBool nsWindow::DispatchMouseEvent(PRUint32 aEventType, WPARAM wParam,
29835:                                     LPARAM lParam, PRBool aIsContextMenuKey,
29835:                                     PRInt16 aButton)
29835: {
29835:   PRBool result = PR_FALSE;
29835: 
29835:   if (!mEventCallback) {
29835:     return result;
29835:   }
29835: 
29835:   nsIntPoint eventPoint;
29835:   eventPoint.x = GET_X_LPARAM(lParam);
29835:   eventPoint.y = GET_Y_LPARAM(lParam);
29835: 
29835:   nsMouseEvent event(PR_TRUE, aEventType, this, nsMouseEvent::eReal,
29835:                      aIsContextMenuKey
29835:                      ? nsMouseEvent::eContextMenuKey
29835:                      : nsMouseEvent::eNormal);
29835:   if (aEventType == NS_CONTEXTMENU && aIsContextMenuKey) {
29835:     nsIntPoint zero(0, 0);
29835:     InitEvent(event, &zero);
29835:   } else {
29835:     InitEvent(event, &eventPoint);
29835:   }
29835: 
29835:   event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
29835:   event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
29835:   event.isMeta    = PR_FALSE;
29835:   event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
29835:   event.button    = aButton;
29835: 
29835:   nsIntPoint mpScreen = eventPoint + WidgetToScreenOffset();
29835: 
29835:   // Suppress mouse moves caused by widget creation
29835:   if (aEventType == NS_MOUSE_MOVE) 
29835:   {
29835:     if ((sLastMouseMovePoint.x == mpScreen.x) && (sLastMouseMovePoint.y == mpScreen.y))
29835:       return result;
29835:     sLastMouseMovePoint.x = mpScreen.x;
29835:     sLastMouseMovePoint.y = mpScreen.y;
29835:   }
29835: 
29835:   PRBool insideMovementThreshold = (abs(sLastMousePoint.x - eventPoint.x) < (short)::GetSystemMetrics(SM_CXDOUBLECLK)) &&
29835:                                    (abs(sLastMousePoint.y - eventPoint.y) < (short)::GetSystemMetrics(SM_CYDOUBLECLK));
29835: 
29835:   BYTE eventButton;
29835:   switch (aButton) {
29835:     case nsMouseEvent::eLeftButton:
29835:       eventButton = VK_LBUTTON;
29835:       break;
29835:     case nsMouseEvent::eMiddleButton:
29835:       eventButton = VK_MBUTTON;
29835:       break;
29835:     case nsMouseEvent::eRightButton:
29835:       eventButton = VK_RBUTTON;
29835:       break;
29835:     default:
29835:       eventButton = 0;
29835:       break;
29835:   }
29835: 
29835:   // Doubleclicks are used to set the click count, then changed to mousedowns
29835:   // We're going to time double-clicks from mouse *up* to next mouse *down*
29835:   LONG curMsgTime = ::GetMessageTime();
29835: 
29835:   if (aEventType == NS_MOUSE_DOUBLECLICK) {
29835:     event.message = NS_MOUSE_BUTTON_DOWN;
29835:     event.button = aButton;
29835:     sLastClickCount = 2;
29835:   }
29835:   else if (aEventType == NS_MOUSE_BUTTON_UP) {
29835:     // remember when this happened for the next mouse down
29835:     sLastMousePoint.x = eventPoint.x;
29835:     sLastMousePoint.y = eventPoint.y;
29835:     sLastMouseButton = eventButton;
29835:   }
29835:   else if (aEventType == NS_MOUSE_BUTTON_DOWN) {
29835:     // now look to see if we want to convert this to a double- or triple-click
29835: 
29835: #ifdef NS_DEBUG_XX
29835:     printf("Msg: %d Last: %d Dif: %d Max %d\n", curMsgTime, sLastMouseDownTime, curMsgTime-sLastMouseDownTime, ::GetDoubleClickTime());
29835:     printf("Mouse %d %d\n", abs(sLastMousePoint.x - mp.x), abs(sLastMousePoint.y - mp.y));
29835: #endif
29835:     if (((curMsgTime - sLastMouseDownTime) < (LONG)::GetDoubleClickTime()) && insideMovementThreshold &&
29835:         eventButton == sLastMouseButton) {
29835:       sLastClickCount ++;
29835:     } else {
29835:       // reset the click count, to count *this* click
29835:       sLastClickCount = 1;
29835:     }
29835:     // Set last Click time on MouseDown only
29835:     sLastMouseDownTime = curMsgTime;
29835:   }
29835:   else if (aEventType == NS_MOUSE_MOVE && !insideMovementThreshold) {
29835:     sLastClickCount = 0;
29835:   }
29835:   else if (aEventType == NS_MOUSE_EXIT) {
29835:     event.exit = IsTopLevelMouseExit(mWnd) ? nsMouseEvent::eTopLevel : nsMouseEvent::eChild;
29835:   }
29835:   event.clickCount = sLastClickCount;
29835: 
29835: #ifdef NS_DEBUG_XX
29835:   printf("Msg Time: %d Click Count: %d\n", curMsgTime, event.clickCount);
29835: #endif
29835: 
29835:   nsPluginEvent pluginEvent;
29835: 
29835:   switch (aEventType)
29835:   {
29835:     case NS_MOUSE_BUTTON_DOWN:
29835:       switch (aButton) {
29835:         case nsMouseEvent::eLeftButton:
29835:           pluginEvent.event = WM_LBUTTONDOWN;
29835:           break;
29835:         case nsMouseEvent::eMiddleButton:
29835:           pluginEvent.event = WM_MBUTTONDOWN;
29835:           break;
29835:         case nsMouseEvent::eRightButton:
29835:           pluginEvent.event = WM_RBUTTONDOWN;
29835:           break;
29835:         default:
29835:           break;
29835:       }
29835:       break;
29835:     case NS_MOUSE_BUTTON_UP:
29835:       switch (aButton) {
29835:         case nsMouseEvent::eLeftButton:
29835:           pluginEvent.event = WM_LBUTTONUP;
29835:           break;
29835:         case nsMouseEvent::eMiddleButton:
29835:           pluginEvent.event = WM_MBUTTONUP;
29835:           break;
29835:         case nsMouseEvent::eRightButton:
29835:           pluginEvent.event = WM_RBUTTONUP;
29835:           break;
29835:         default:
29835:           break;
29835:       }
29835:       break;
29835:     case NS_MOUSE_DOUBLECLICK:
29835:       switch (aButton) {
29835:         case nsMouseEvent::eLeftButton:
29835:           pluginEvent.event = WM_LBUTTONDBLCLK;
29835:           break;
29835:         case nsMouseEvent::eMiddleButton:
29835:           pluginEvent.event = WM_MBUTTONDBLCLK;
29835:           break;
29835:         case nsMouseEvent::eRightButton:
29835:           pluginEvent.event = WM_RBUTTONDBLCLK;
29835:           break;
29835:         default:
29835:           break;
29835:       }
29835:       break;
29835:     case NS_MOUSE_MOVE:
29835:       pluginEvent.event = WM_MOUSEMOVE;
29835:       break;
29835:     default:
29835:       pluginEvent.event = WM_NULL;
29835:       break;
29835:   }
29835: 
29835:   pluginEvent.wParam = wParam;     // plugins NEED raw OS event flags!
29835:   pluginEvent.lParam = lParam;
29835: 
29835:   event.nativeMsg = (void *)&pluginEvent;
29835: 
29835:   // call the event callback
29835:   if (nsnull != mEventCallback) {
29835:     if (nsToolkit::gMouseTrailer)
29835:       nsToolkit::gMouseTrailer->Disable();
29835:     if (aEventType == NS_MOUSE_MOVE) {
29835:       if (nsToolkit::gMouseTrailer && !mIsInMouseCapture) {
29835:         nsToolkit::gMouseTrailer->SetMouseTrailerWindow(mWnd);
29835:       }
29835:       nsIntRect rect;
29835:       GetBounds(rect);
29835:       rect.x = 0;
29835:       rect.y = 0;
29835: 
29835:       if (rect.Contains(event.refPoint)) {
29835:         if (sCurrentWindow == NULL || sCurrentWindow != this) {
30223:           if ((nsnull != sCurrentWindow) && (!sCurrentWindow->mInDtor)) {
29835:             LPARAM pos = sCurrentWindow->lParamToClient(lParamToScreen(lParam));
29835:             sCurrentWindow->DispatchMouseEvent(NS_MOUSE_EXIT, wParam, pos);
29835:           }
29835:           sCurrentWindow = this;
30223:           if (!mInDtor) {
29835:             LPARAM pos = sCurrentWindow->lParamToClient(lParamToScreen(lParam));
29835:             sCurrentWindow->DispatchMouseEvent(NS_MOUSE_ENTER, wParam, pos);
29835:           }
29835:         }
29835:       }
29835:     } else if (aEventType == NS_MOUSE_EXIT) {
29835:       if (sCurrentWindow == this) {
29835:         sCurrentWindow = nsnull;
29835:       }
29835:     }
29835: 
29835:     result = DispatchWindowEvent(&event);
29835: 
29835:     if (nsToolkit::gMouseTrailer)
29835:       nsToolkit::gMouseTrailer->Enable();
29835: 
29835:     // Release the widget with NS_IF_RELEASE() just in case
29835:     // the context menu key code in nsEventListenerManager::HandleEvent()
29835:     // released it already.
29835:     return result;
29835:   }
29835: 
29835:   return result;
29835: }
29835: 
29835: // Deal with accessibile event
29835: #ifdef ACCESSIBILITY
29835: PRBool nsWindow::DispatchAccessibleEvent(PRUint32 aEventType, nsIAccessible** aAcc, nsIntPoint* aPoint)
29835: {
29835:   PRBool result = PR_FALSE;
29835: 
29835:   if (nsnull == mEventCallback) {
29835:     return result;
29835:   }
29835: 
29835:   *aAcc = nsnull;
29835: 
29835:   nsAccessibleEvent event(PR_TRUE, aEventType, this);
29835:   InitEvent(event, aPoint);
29835: 
29835:   event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
29835:   event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
29835:   event.isMeta    = PR_FALSE;
29835:   event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
29835:   event.accessible = nsnull;
29835: 
29835:   result = DispatchWindowEvent(&event);
29835: 
29835:   // if the event returned an accesssible get it.
29835:   if (event.accessible)
29835:     *aAcc = event.accessible;
29835: 
29835:   return result;
29835: }
29835: #endif
29835: 
29835: PRBool nsWindow::DispatchFocusToTopLevelWindow(PRUint32 aEventType)
29835: {
29835:   if (aEventType == NS_ACTIVATE)
29835:     sJustGotActivate = PR_FALSE;
29835:   sJustGotDeactivate = PR_FALSE;
29835: 
29835:   // clear the flags, and retrieve the toplevel window. This way, it doesn't
29835:   // mattter what child widget received the focus event and it will always be
29835:   // fired at the toplevel window.
29835:   HWND toplevelWnd = GetTopLevelHWND(mWnd);
29835:   if (toplevelWnd) {
29835:     nsWindow *win = GetNSWindowPtr(toplevelWnd);
29835:     if (win)
29835:       return win->DispatchFocus(aEventType);
29835:   }
29835: 
29835:   return PR_FALSE;
29835: }
29835: 
29835: // Deal with focus messages
29835: PRBool nsWindow::DispatchFocus(PRUint32 aEventType)
29835: {
29835:   // call the event callback
29835:   if (mEventCallback) {
29835:     nsGUIEvent event(PR_TRUE, aEventType, this);
29835:     InitEvent(event);
29835: 
29835:     //focus and blur event should go to their base widget loc, not current mouse pos
29835:     event.refPoint.x = 0;
29835:     event.refPoint.y = 0;
29835: 
29835:     nsPluginEvent pluginEvent;
29835: 
29835:     switch (aEventType)
29835:     {
29835:       case NS_ACTIVATE:
29835:         pluginEvent.event = WM_SETFOCUS;
29835:         break;
29835:       case NS_DEACTIVATE:
29835:         pluginEvent.event = WM_KILLFOCUS;
29835:         break;
29835:       case NS_PLUGIN_ACTIVATE:
29835:         pluginEvent.event = WM_KILLFOCUS;
29835:         break;
29835:       default:
29835:         break;
29835:     }
29835: 
29835:     event.nativeMsg = (void *)&pluginEvent;
29835: 
29835:     return DispatchWindowEvent(&event);
29835:   }
29835:   return PR_FALSE;
29835: }
29835: 
29835: PRBool nsWindow::IsTopLevelMouseExit(HWND aWnd)
29835: {
29835:   DWORD pos = ::GetMessagePos();
29835:   POINT mp;
29835:   mp.x = GET_X_LPARAM(pos);
29835:   mp.y = GET_Y_LPARAM(pos);
29835:   HWND mouseWnd = ::WindowFromPoint(mp);
29835: 
29835:   // GetTopLevelHWND will return a HWND for the window frame (which includes
29835:   // the non-client area).  If the mouse has moved into the non-client area,
29835:   // we should treat it as a top-level exit.
29835:   HWND mouseTopLevel = nsWindow::GetTopLevelHWND(mouseWnd);
29835:   if (mouseWnd == mouseTopLevel)
29835:     return PR_TRUE;
29835: 
29835:   return nsWindow::GetTopLevelHWND(aWnd) != mouseTopLevel;
29835: }
29835: 
29835: PRBool nsWindow::BlurEventsSuppressed()
29835: {
29835:   // are they suppressed in this window?
29835:   if (mBlurSuppressLevel > 0)
29835:     return PR_TRUE;
29835: 
29835:   // are they suppressed by any container widget?
29835:   HWND parentWnd = ::GetParent(mWnd);
29835:   if (parentWnd) {
29835:     nsWindow *parent = GetNSWindowPtr(parentWnd);
29835:     if (parent)
29835:       return parent->BlurEventsSuppressed();
29835:   }
29835:   return PR_FALSE;
29835: }
29835: 
29835: // In some circumstances (opening dependent windows) it makes more sense
29835: // (and fixes a crash bug) to not blur the parent window. Called from
29835: // nsFilePicker.
29835: void nsWindow::SuppressBlurEvents(PRBool aSuppress)
29835: {
29835:   if (aSuppress)
29835:     ++mBlurSuppressLevel; // for this widget
29835:   else {
29835:     NS_ASSERTION(mBlurSuppressLevel > 0, "unbalanced blur event suppression");
29835:     if (mBlurSuppressLevel > 0)
29835:       --mBlurSuppressLevel;
29835:   }
29835: }
29835: 
29835: PRBool nsWindow::ConvertStatus(nsEventStatus aStatus)
29835: {
29835:   return aStatus == nsEventStatus_eConsumeNoDefault;
29835: }
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Native events
29835:  **
29835:  ** Main Windows message handlers and OnXXX handlers for
29835:  ** Windows event handling.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Wind proc.
29835:  *
29835:  * The main Windows event procedures and associated
29835:  * message processing methods.
29835:  *
29835:  **************************************************************/
29835: 
29835: // The WndProc procedure for all nsWindows in this toolkit
29835: LRESULT CALLBACK nsWindow::WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
29835: {
29835:   // create this here so that we store the last rolled up popup until after
29835:   // the event has been processed.
29835:   nsAutoRollup autoRollup;
29835: 
29835:   LRESULT popupHandlingResult;
29835:   if ( DealWithPopups(hWnd, msg, wParam, lParam, &popupHandlingResult) )
29835:     return popupHandlingResult;
29835: 
29835:   // Get the window which caused the event and ask it to process the message
29835:   nsWindow *someWindow = GetNSWindowPtr(hWnd);
29835: 
29835:   // XXX This fixes 50208 and we are leaving 51174 open to further investigate
29835:   // why we are hitting this assert
29835:   if (nsnull == someWindow) {
29835:     NS_ASSERTION(someWindow, "someWindow is null, cannot call any CallWindowProc");
29835:     return ::DefWindowProcW(hWnd, msg, wParam, lParam);
29835:   }
29835: 
29835:   // hold on to the window for the life of this method, in case it gets
29835:   // deleted during processing. yes, it's a double hack, since someWindow
29835:   // is not really an interface.
29835:   nsCOMPtr<nsISupports> kungFuDeathGrip;
30223:   if (!someWindow->mInDtor) // not if we're in the destructor!
29835:     kungFuDeathGrip = do_QueryInterface((nsBaseWidget*)someWindow);
29835: 
29835:   // Re-direct a tab change message destined for its parent window to the
29835:   // the actual window which generated the event.
29835:   if (msg == WM_NOTIFY) {
29835:     LPNMHDR pnmh = (LPNMHDR) lParam;
29835:     if (pnmh->code == TCN_SELCHANGE) {
29835:       someWindow = GetNSWindowPtr(pnmh->hwndFrom);
29835:     }
29835:   }
29835: 
29835:   // Call ProcessMessage
29835:   if (nsnull != someWindow) {
29835:     LRESULT retValue;
29835:     if (PR_TRUE == someWindow->ProcessMessage(msg, wParam, lParam, &retValue)) {
29835:       return retValue;
29835:     }
29835:   }
29835: 
29835:   return ::CallWindowProcW(someWindow->GetPrevWindowProc(),
29835:                            hWnd, msg, wParam, lParam);
29835: }
29835: 
29835: // The main windows message processing method for plugins.
29835: // The result means whether this method processed the native
29835: // event for plugin. If false, the native event should be
29835: // processed by the caller self.
29835: PRBool
29835: nsWindow::ProcessMessageForPlugin(const MSG &aMsg,
29835:                                   LRESULT *aResult,
29835:                                   PRBool &aCallDefWndProc)
29835: {
29835:   NS_PRECONDITION(aResult, "aResult must be non-null.");
29835:   *aResult = 0;
29835: 
29835:   aCallDefWndProc = PR_FALSE;
29835:   PRBool fallBackToNonPluginProcess = PR_FALSE;
29835:   PRBool eventDispatched = PR_FALSE;
29835:   PRBool dispatchPendingEvents = PR_TRUE;
29835:   switch (aMsg.message) {
29835:     case WM_INPUTLANGCHANGEREQUEST:
29835:     case WM_INPUTLANGCHANGE:
29835:       DispatchPluginEvent(aMsg);
29835:       return PR_FALSE; // go to non-plug-ins processing
29835: 
29835:     case WM_CHAR:
29835:     case WM_SYSCHAR:
29835:       *aResult = ProcessCharMessage(aMsg, &eventDispatched);
29835:       break;
29835: 
29835:     case WM_KEYUP:
29835:     case WM_SYSKEYUP:
29835:       *aResult = ProcessKeyUpMessage(aMsg, &eventDispatched);
29835:       break;
29835: 
29835:     case WM_KEYDOWN:
29835:     case WM_SYSKEYDOWN:
29835:       *aResult = ProcessKeyDownMessage(aMsg, &eventDispatched);
29835:       break;
29835: 
29835:     case WM_DEADCHAR:
29835:     case WM_SYSDEADCHAR:
29835:     case WM_CONTEXTMENU:
29835: 
29835:     case WM_CUT:
29835:     case WM_COPY:
29835:     case WM_PASTE:
29835:     case WM_CLEAR:
29835:     case WM_UNDO:
29835: 
29835:     case WM_IME_STARTCOMPOSITION:
29835:     case WM_IME_COMPOSITION:
29835:     case WM_IME_ENDCOMPOSITION:
29835:     case WM_IME_CHAR:
29835:     case WM_IME_COMPOSITIONFULL:
29835:     case WM_IME_CONTROL:
29835:     case WM_IME_KEYDOWN:
29835:     case WM_IME_KEYUP:
29835:     case WM_IME_NOTIFY:
29835:     case WM_IME_REQUEST:
29835:     case WM_IME_SELECT:
29835:       break;
29835: 
29835:     case WM_IME_SETCONTEXT:
29835:       // Don't synchronously dispatch when we receive WM_IME_SETCONTEXT
29835:       // because we get it during plugin destruction. (bug 491848)
29835:       dispatchPendingEvents = PR_FALSE;
29835:       break;
29835: 
29835:     default:
29835:       return PR_FALSE;
29835:   }
29835: 
29835:   if (!eventDispatched)
29835:     aCallDefWndProc = !DispatchPluginEvent(aMsg);
29835:   if (dispatchPendingEvents)
29835:     DispatchPendingEvents();
29835:   return PR_TRUE;
29835: }
29835: 
29835: // The main windows message processing method.
29835: PRBool nsWindow::ProcessMessage(UINT msg, WPARAM &wParam, LPARAM &lParam,
29835:                                 LRESULT *aRetValue)
29835: {
29835:   // (Large blocks of code should be broken out into OnEvent handlers.)
29835:   
29835:   PRBool eatMessage;
29835:   if (nsIMM32Handler::ProcessMessage(this, msg, wParam, lParam, aRetValue,
29835:                                      eatMessage)) {
29835:     return mWnd ? eatMessage : PR_TRUE;
29835:   }
29835: 
29835:   if (PluginHasFocus()) {
29835:     PRBool callDefaultWndProc;
29835:     MSG nativeMsg = InitMSG(msg, wParam, lParam);
29835:     if (ProcessMessageForPlugin(nativeMsg, aRetValue, callDefaultWndProc)) {
29835:       return mWnd ? !callDefaultWndProc : PR_TRUE;
29835:     }
29835:   }
29835: 
29835:   static UINT vkKeyCached = 0; // caches VK code fon WM_KEYDOWN
29835:   PRBool result = PR_FALSE;    // call the default nsWindow proc
29835:   *aRetValue = 0;
29835: 
30094: #if !defined (WINCE_WINDOWS_MOBILE)
29835:   static PRBool getWheelInfo = PR_TRUE;
29835: #endif
29835: 
29835: #if defined(EVENT_DEBUG_OUTPUT)
29835:   // First param shows all events, second param indicates whether
29835:   // to show mouse move events. See nsWindowDbg for details.
29835:   PrintEvent(msg, SHOW_REPEAT_EVENTS, SHOW_MOUSEMOVE_EVENTS);
29835: #endif
29835: 
29835:   switch (msg) {
29835:     case WM_COMMAND:
29835:     {
29835:       WORD wNotifyCode = HIWORD(wParam); // notification code
29835:       if ((CBN_SELENDOK == wNotifyCode) || (CBN_SELENDCANCEL == wNotifyCode)) { // Combo box change
29835:         nsGUIEvent event(PR_TRUE, NS_CONTROL_CHANGE, this);
29835:         nsIntPoint point(0,0);
29835:         InitEvent(event, &point); // this add ref's event.widget
29835:         result = DispatchWindowEvent(&event);
29835:       } else if (wNotifyCode == 0) { // Menu selection
29835:         nsMenuEvent event(PR_TRUE, NS_MENU_SELECTED, this);
29835:         event.mCommand = LOWORD(wParam);
29835:         InitEvent(event);
29835:         result = DispatchWindowEvent(&event);
29835:       }
29835:     }
29835:     break;
29835: 
29835: #ifndef WINCE
29835:     // WM_QUERYENDSESSION must be handled by all windows.
29835:     // Otherwise Windows thinks the window can just be killed at will.
29835:     case WM_QUERYENDSESSION:
29835:       if (sCanQuit == TRI_UNKNOWN)
29835:       {
29835:         // Ask if it's ok to quit, and store the answer until we
29835:         // get WM_ENDSESSION signaling the round is complete.
29835:         nsCOMPtr<nsIObserverService> obsServ =
29835:           do_GetService("@mozilla.org/observer-service;1");
29835:         nsCOMPtr<nsISupportsPRBool> cancelQuit =
29835:           do_CreateInstance(NS_SUPPORTS_PRBOOL_CONTRACTID);
29835:         cancelQuit->SetData(PR_FALSE);
29835:         obsServ->NotifyObservers(cancelQuit, "quit-application-requested", nsnull);
29835: 
29835:         PRBool abortQuit;
29835:         cancelQuit->GetData(&abortQuit);
29835:         sCanQuit = abortQuit ? TRI_FALSE : TRI_TRUE;
29835:       }
29835:       *aRetValue = sCanQuit ? TRUE : FALSE;
29835:       result = PR_TRUE;
29835:       break;
29835: 
29835:     case WM_ENDSESSION:
29835:       if (wParam == TRUE && sCanQuit == TRI_TRUE)
29835:       {
29835:         // Let's fake a shutdown sequence without actually closing windows etc.
29835:         // to avoid Windows killing us in the middle. A proper shutdown would
29835:         // require having a chance to pump some messages. Unfortunately
29835:         // Windows won't let us do that. Bug 212316.
29835:         nsCOMPtr<nsIObserverService> obsServ =
29835:           do_GetService("@mozilla.org/observer-service;1");
29835:         NS_NAMED_LITERAL_STRING(context, "shutdown-persist");
29835:         obsServ->NotifyObservers(nsnull, "quit-application-granted", nsnull);
29835:         obsServ->NotifyObservers(nsnull, "quit-application-forced", nsnull);
29835:         obsServ->NotifyObservers(nsnull, "quit-application", nsnull);
29835:         obsServ->NotifyObservers(nsnull, "profile-change-net-teardown", context.get());
29835:         obsServ->NotifyObservers(nsnull, "profile-change-teardown", context.get());
29835:         obsServ->NotifyObservers(nsnull, "profile-before-change", context.get());
29835:         // Then a controlled but very quick exit.
29835:         _exit(0);
29835:       }
29835:       sCanQuit = TRI_UNKNOWN;
29835:       result = PR_TRUE;
29835:       break;
29835: 
29835:     case WM_DISPLAYCHANGE:
29835:       DispatchStandardEvent(NS_DISPLAYCHANGED);
29835:       break;
29835: #endif
29835: 
29835:     case WM_SYSCOLORCHANGE:
29835:       // Note: This is sent for child windows as well as top-level windows.
29835:       // The Win32 toolkit normally only sends these events to top-level windows.
29835:       // But we cycle through all of the childwindows and send it to them as well
29835:       // so all presentations get notified properly.
29835:       // See nsWindow::GlobalMsgWindowProc.
29835:       DispatchStandardEvent(NS_SYSCOLORCHANGED);
29835:       break;
29835: 
29835:     case WM_NOTIFY:
29835:       // TAB change
29835:     {
29835:       LPNMHDR pnmh = (LPNMHDR) lParam;
29835: 
29835:         switch (pnmh->code) {
29835:           case TCN_SELCHANGE:
29835:           {
29835:             DispatchStandardEvent(NS_TABCHANGE);
29835:             result = PR_TRUE;
29835:           }
29835:           break;
29835:         }
29835:     }
29835:     break;
29835: 
29835:     case WM_XP_THEMECHANGED:
29835:     {
29835:       DispatchStandardEvent(NS_THEMECHANGED);
29835: 
29835:       // Invalidate the window so that the repaint will
29835:       // pick up the new theme.
29835:       Invalidate(PR_FALSE);
29835:     }
29835:     break;
29835: 
29835:     case WM_FONTCHANGE:
29835:     {
29835:       nsresult rv;
29835:       PRBool didChange = PR_FALSE;
29835: 
29835:       // update the global font list
29835:       nsCOMPtr<nsIFontEnumerator> fontEnum = do_GetService("@mozilla.org/gfx/fontenumerator;1", &rv);
29835:       if (NS_SUCCEEDED(rv)) {
29835:         fontEnum->UpdateFontList(&didChange);
29835:         //didChange is TRUE only if new font langGroup is added to the list.
29835:         if (didChange)  {
29835:           // update device context font cache
29835:           // Dirty but easiest way:
29835:           // Changing nsIPrefBranch entry which triggers callbacks
29835:           // and flows into calling mDeviceContext->FlushFontCache()
29835:           // to update the font cache in all the instance of Browsers
29835:           nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
29835:           if (prefs) {
29835:             nsCOMPtr<nsIPrefBranch> fiPrefs;
29835:             prefs->GetBranch("font.internaluseonly.", getter_AddRefs(fiPrefs));
29835:             if (fiPrefs) {
29835:               PRBool fontInternalChange = PR_FALSE;
29835:               fiPrefs->GetBoolPref("changed", &fontInternalChange);
29835:               fiPrefs->SetBoolPref("changed", !fontInternalChange);
29835:             }
29835:           }
29835:         }
29835:       } //if (NS_SUCCEEDED(rv))
29835:     }
29835:     break;
29835: 
29835: #ifndef WINCE
29835:     case WM_POWERBROADCAST:
29835:       // only hidden window handle this
29835:       // to prevent duplicate notification
29835:       if (mWindowType == eWindowType_invisible) {
29835:         switch (wParam)
29835:         {
29835:           case PBT_APMSUSPEND:
29835:             PostSleepWakeNotification("sleep_notification");
29835:             break;
29835:           case PBT_APMRESUMEAUTOMATIC:
29835:           case PBT_APMRESUMECRITICAL:
29835:           case PBT_APMRESUMESUSPEND:
29835:             PostSleepWakeNotification("wake_notification");
29835:             break;
29835:         }
29835:       }
29835:       break;
29835: #endif
29835: 
29835:     case WM_MOVE: // Window moved
29835:     {
29835:       PRInt32 x = GET_X_LPARAM(lParam); // horizontal position in screen coordinates
29835:       PRInt32 y = GET_Y_LPARAM(lParam); // vertical position in screen coordinates
29835:       result = OnMove(x, y);
29835:     }
29835:     break;
29835: 
29835:     case WM_CLOSE: // close request
29835:       DispatchStandardEvent(NS_XUL_CLOSE);
29835:       result = PR_TRUE; // abort window closure
29835:       break;
29835: 
29835:     case WM_DESTROY:
29835:       // clean up.
29835:       OnDestroy();
29835:       result = PR_TRUE;
29835:       break;
29835: 
29835:     case WM_PAINT:
29835:       *aRetValue = (int) OnPaint();
29835:       result = PR_TRUE;
29835:       break;
29835: 
29835: #ifndef WINCE
29835:     case WM_PRINTCLIENT:
29835:       result = OnPaint((HDC) wParam);
29835:       break;
29835: #endif
29835: 
29835:     case WM_HOTKEY:
29835:       result = OnHotKey(wParam, lParam);
29835:       break;
29835: 
29835:     case WM_SYSCHAR:
29835:     case WM_CHAR:
29835:     {
29835:       MSG nativeMsg = InitMSG(msg, wParam, lParam);
29835:       result = ProcessCharMessage(nativeMsg, nsnull);
29835:       DispatchPendingEvents();
29835:     }
29835:     break;
29835: 
29835:     case WM_SYSKEYUP:
29835:     case WM_KEYUP:
29835:     {
29835:       MSG nativeMsg = InitMSG(msg, wParam, lParam);
29835:       result = ProcessKeyUpMessage(nativeMsg, nsnull);
29835:       DispatchPendingEvents();
29835:     }
29835:     break;
29835: 
29835:     case WM_SYSKEYDOWN:
29835:     case WM_KEYDOWN:
29835:     {
29835:       MSG nativeMsg = InitMSG(msg, wParam, lParam);
29835:       result = ProcessKeyDownMessage(nativeMsg, nsnull);
29835:       DispatchPendingEvents();
29835:     }
29835:     break;
29835: 
29835:     // say we've dealt with erase background if widget does
29835:     // not need auto-erasing
29835:     case WM_ERASEBKGND:
29835:       if (! AutoErase()) {
29835:         *aRetValue = 1;
29835:         result = PR_TRUE;
29835:       }
29835:       break;
29835: 
29835:     case WM_GETDLGCODE:
29835:       *aRetValue = DLGC_WANTALLKEYS;
29835:       result = PR_TRUE;
29835:       break;
29835: 
29835:     case WM_MOUSEMOVE:
29835:     {
29835:       // Suppress dispatch of pending events
29835:       // when mouse moves are generated by widget
29835:       // creation instead of user input.
29835:       LPARAM lParamScreen = lParamToScreen(lParam);
29835:       POINT mp;
29835:       mp.x      = GET_X_LPARAM(lParamScreen);
29835:       mp.y      = GET_Y_LPARAM(lParamScreen);
29835:       PRBool userMovedMouse = PR_FALSE;
29835:       if ((sLastMouseMovePoint.x != mp.x) || (sLastMouseMovePoint.y != mp.y)) {
29835:         userMovedMouse = PR_TRUE;
29835:       }
29835: 
29835:       result = DispatchMouseEvent(NS_MOUSE_MOVE, wParam, lParam);
29835:       if (userMovedMouse) {
29835:         DispatchPendingEvents();
29835:       }
29835:     }
29835:     break;
29835: 
29835:     case WM_LBUTTONDOWN:
29835:     {
29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam,
29835:                                   PR_FALSE, nsMouseEvent::eLeftButton);
29835:       DispatchPendingEvents();
29835:     }
29835:     break;
29835: 
29835:     case WM_LBUTTONUP:
29835:     {
29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam,
29835:                                   PR_FALSE, nsMouseEvent::eLeftButton);
29835:       DispatchPendingEvents();
29835:     }
29835:     break;
29835: 
29835: #ifndef WINCE
29835:     case WM_MOUSELEAVE:
29835:     {
29835:       // We need to check mouse button states and put them in for
29835:       // wParam.
29835:       WPARAM mouseState = (GetKeyState(VK_LBUTTON) ? MK_LBUTTON : 0)
29835:         | (GetKeyState(VK_MBUTTON) ? MK_MBUTTON : 0)
29835:         | (GetKeyState(VK_RBUTTON) ? MK_RBUTTON : 0);
29835:       // Synthesize an event position because we don't get one from
29835:       // WM_MOUSELEAVE.
29835:       LPARAM pos = lParamToClient(::GetMessagePos());
29835:       DispatchMouseEvent(NS_MOUSE_EXIT, mouseState, pos);
29835:     }
29835:     break;
29835: #endif
29835: 
29835:     case WM_CONTEXTMENU:
29835:     {
29835:       // if the context menu is brought up from the keyboard, |lParam|
29835:       // will be maxlong.
29835:       LPARAM pos;
29835:       PRBool contextMenukey = PR_FALSE;
29835:       if (lParam == 0xFFFFFFFF)
29835:       {
29835:         contextMenukey = PR_TRUE;
29835:         pos = lParamToClient(GetMessagePos());
29835:       }
29835:       else
29835:       {
29835:         pos = lParamToClient(lParam);
29835:       }
29835:       result = DispatchMouseEvent(NS_CONTEXTMENU, wParam, pos, contextMenukey,
29835:                                   contextMenukey ?
29835:                                     nsMouseEvent::eLeftButton :
29835:                                     nsMouseEvent::eRightButton);
29835:     }
29835:     break;
29835: 
29835:     case WM_LBUTTONDBLCLK:
29835:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam, lParam, PR_FALSE,
29835:                                   nsMouseEvent::eLeftButton);
29835:       break;
29835: 
29835:     case WM_MBUTTONDOWN:
29835:     {
29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam, PR_FALSE,
29835:                                   nsMouseEvent::eMiddleButton);
29835:       DispatchPendingEvents();
29835:     }
29835:     break;
29835: 
29835:     case WM_MBUTTONUP:
29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam, PR_FALSE,
29835:                                   nsMouseEvent::eMiddleButton);
29835:       DispatchPendingEvents();
29835:       break;
29835: 
29835:     case WM_MBUTTONDBLCLK:
29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam, PR_FALSE,
29835:                                   nsMouseEvent::eMiddleButton);
29835:       break;
29835: 
29835:     case WM_RBUTTONDOWN:
29835:     {
29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam, PR_FALSE,
29835:                                   nsMouseEvent::eRightButton);
29835:       DispatchPendingEvents();
29835:     }
29835:     break;
29835: 
29835:     case WM_RBUTTONUP:
29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam, PR_FALSE,
29835:                                   nsMouseEvent::eRightButton);
29835:       DispatchPendingEvents();
29835:       break;
29835: 
29835:     case WM_RBUTTONDBLCLK:
29835:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam, lParam, PR_FALSE,
29835:                                   nsMouseEvent::eRightButton);
29835:       break;
29835: 
29835:     case WM_APPCOMMAND:
29835:     {
29835:       PRUint32 appCommand = GET_APPCOMMAND_LPARAM(lParam);
29835: 
29835:       switch (appCommand)
29835:       {
29835:         case APPCOMMAND_BROWSER_BACKWARD:
29835:         case APPCOMMAND_BROWSER_FORWARD:
29835:         case APPCOMMAND_BROWSER_REFRESH:
29835:         case APPCOMMAND_BROWSER_STOP:
29835:         case APPCOMMAND_BROWSER_SEARCH:
29835:         case APPCOMMAND_BROWSER_FAVORITES:
29835:         case APPCOMMAND_BROWSER_HOME:
29835:           DispatchCommandEvent(appCommand);
29835:           // tell the driver that we handled the event
29835:           *aRetValue = 1;
29835:           result = PR_TRUE;
29835:           break;
29835:       }
29835:       // default = PR_FALSE - tell the driver that the event was not handled
29835:     }
29835:     break;
29835: 
29835:     case WM_HSCROLL:
29835:     case WM_VSCROLL:
29835:       // check for the incoming nsWindow handle to be null in which case
29835:       // we assume the message is coming from a horizontal scrollbar inside
29835:       // a listbox and we don't bother processing it (well, we don't have to)
29835:       if (lParam) {
29835:         nsWindow* scrollbar = GetNSWindowPtr((HWND)lParam);
29835: 
29835:         if (scrollbar) {
29835:           result = scrollbar->OnScroll(LOWORD(wParam), (short)HIWORD(wParam));
29835:         }
29835:       }
29835:       break;
29835: 
29835:     case WM_CTLCOLORLISTBOX:
29835:     case WM_CTLCOLOREDIT:
29835:     case WM_CTLCOLORBTN:
29835:     //case WM_CTLCOLORSCROLLBAR: //XXX causes the scrollbar to be drawn incorrectly
29835:     case WM_CTLCOLORSTATIC:
29835:       if (lParam) {
29835:         nsWindow* control = GetNSWindowPtr((HWND)lParam);
29835:           if (control) {
29835:             control->SetUpForPaint((HDC)wParam);
29835:             *aRetValue = (LPARAM)control->OnControlColor();
29835:           }
29835:       }
29835: 
29835:       result = PR_TRUE;
29835:       break;
29835: 
29835:     // The WM_ACTIVATE event is fired when a window is raised or lowered,
29835:     // and the loword of wParam specifies which. But we don't want to tell
29835:     // the focus system about this until the WM_SETFOCUS or WM_KILLFOCUS
29835:     // events are fired. Instead, set either the sJustGotActivate or
29835:     // gJustGotDeativate flags and fire the NS_ACTIVATE or NS_DEACTIVATE
29835:     // events once the focus events arrive.
29835:     case WM_ACTIVATE:
29835:       if (mEventCallback) {
29835:         PRInt32 fActive = LOWORD(wParam);
29835: 
29835: #if defined(WINCE_HAVE_SOFTKB)
29835:         if (mIsTopWidgetWindow && sSoftKeyboardState)
29835:           nsWindowCE::ToggleSoftKB(fActive);
29835: #endif
29835: 
29835:         if (WA_INACTIVE == fActive) {
29835:           // when minimizing a window, the deactivation and focus events will
29835:           // be fired in the reverse order. Instead, just dispatch
29835:           // NS_DEACTIVATE right away.
29835:           if (HIWORD(wParam))
29835:             result = DispatchFocusToTopLevelWindow(NS_DEACTIVATE);
29835:           else
29835:             sJustGotDeactivate = PR_TRUE;
29835: #ifndef WINCE
29835:           if (mIsTopWidgetWindow)
29835:             mLastKeyboardLayout = gKbdLayout.GetLayout();
29835: #endif
29835: 
29835:         } else {
29835:           StopFlashing();
29835: 
29835:           sJustGotActivate = PR_TRUE;
29835:           nsMouseEvent event(PR_TRUE, NS_MOUSE_ACTIVATE, this,
29835:                              nsMouseEvent::eReal);
29835:           InitEvent(event);
29835: 
29835:           event.acceptActivation = PR_TRUE;
29835:   
29835:           PRBool result = DispatchWindowEvent(&event);
29835: #ifndef WINCE
29835:           if (event.acceptActivation)
29835:             *aRetValue = MA_ACTIVATE;
29835:           else
29835:             *aRetValue = MA_NOACTIVATE;
29835: 
29835:           if (sSwitchKeyboardLayout && mLastKeyboardLayout)
29835:             ActivateKeyboardLayout(mLastKeyboardLayout, 0);
29835: #else
29835:           *aRetValue = 0;
29835: #endif
30075:           if (mSizeMode == nsSizeMode_Fullscreen)
30075:             MakeFullScreen(TRUE);
29835:         }
29835:       }
29835:       break;
29835: 
29835: #ifndef WINCE
29835:     case WM_MOUSEACTIVATE:
29835:       if (mWindowType == eWindowType_popup) {
29835:         // a popup with a parent owner should not be activated when clicked
29835:         // but should still allow the mouse event to be fired, so the return
29835:         // value is set to MA_NOACTIVATE. But if the owner isn't the frontmost
29835:         // window, just use default processing so that the window is activated.
29835:         HWND owner = ::GetWindow(mWnd, GW_OWNER);
29835:         if (owner && owner == ::GetForegroundWindow()) {
29835:           *aRetValue = MA_NOACTIVATE;
29835:           result = PR_TRUE;
29835:         }
29835:       }
29835:       break;
29835: 
29835:     case WM_WINDOWPOSCHANGING:
29835:     {
29835:       LPWINDOWPOS info = (LPWINDOWPOS) lParam;
29835:       OnWindowPosChanging(info);
29835:     }
29835:     break;
29835: #endif
29835: 
29835:     case WM_SETFOCUS:
29835:       if (sJustGotActivate) {
29835:         result = DispatchFocusToTopLevelWindow(NS_ACTIVATE);
29835:       }
29835: 
29835: #ifdef ACCESSIBILITY
29835:       if (nsWindow::sIsAccessibilityOn) {
29835:         // Create it for the first time so that it can start firing events
29835:         nsCOMPtr<nsIAccessible> rootAccessible = GetRootAccessible();
29835:       }
29835: #endif
29835: 
29835: #if defined(WINCE_HAVE_SOFTKB)
29835:       {
29835:         // On Windows CE, we have a window that overlaps
29835:         // the ISP button.  In this case, we should always
29835:         // try to hide it when we are activated
29835:       
29835:         nsIMEContext IMEContext(mWnd);
29835:         // Open the IME 
29835:         ImmSetOpenStatus(IMEContext.get(), TRUE);
29835:       }
29835: #endif
29835:       break;
29835: 
29835:     case WM_KILLFOCUS:
29835: #if defined(WINCE_HAVE_SOFTKB)
29835:       {
29835:         nsIMEContext IMEContext(mWnd);
29835:         ImmSetOpenStatus(IMEContext.get(), FALSE);
29835:       }
29835: #endif
29835:       if (sJustGotDeactivate) {
29835:         result = DispatchFocusToTopLevelWindow(NS_DEACTIVATE);
29835:       }
29835:       break;
29835: 
29835:     case WM_WINDOWPOSCHANGED:
29835:     {
29835:       WINDOWPOS *wp = (LPWINDOWPOS)lParam;
29835: 
29835:       // We only care about a resize, so filter out things like z-order
29835:       // changes. Note: there's a WM_MOVE handler above which is why we're
29835:       // not handling them here...
29835:       if (0 == (wp->flags & SWP_NOSIZE)) {
29835:         // XXX Why are we using the client size area? If the size notification
29835:         // is for the client area then the origin should be (0,0) and not
29835:         // the window origin in screen coordinates...
29835:         RECT r;
29835:         ::GetWindowRect(mWnd, &r);
29835:         PRInt32 newWidth, newHeight;
29835:         newWidth = PRInt32(r.right - r.left);
29835:         newHeight = PRInt32(r.bottom - r.top);
29835:         nsIntRect rect(wp->x, wp->y, newWidth, newHeight);
29835: 
29835: #ifdef MOZ_XUL
29835:         if (eTransparencyTransparent == mTransparencyMode)
29835:           ResizeTranslucentWindow(newWidth, newHeight);
29835: #endif
29835: 
29835:         if (newWidth > mLastSize.width)
29835:         {
29835:           RECT drect;
29835: 
29835:           //getting wider
29835:           drect.left = wp->x + mLastSize.width;
29835:           drect.top = wp->y;
29835:           drect.right = drect.left + (newWidth - mLastSize.width);
29835:           drect.bottom = drect.top + newHeight;
29835: 
29835:           ::RedrawWindow(mWnd, &drect, NULL,
29835:                          RDW_INVALIDATE | RDW_NOERASE | RDW_NOINTERNALPAINT | RDW_ERASENOW | RDW_ALLCHILDREN);
29835:         }
29835:         if (newHeight > mLastSize.height)
29835:         {
29835:           RECT drect;
29835: 
29835:           //getting taller
29835:           drect.left = wp->x;
29835:           drect.top = wp->y + mLastSize.height;
29835:           drect.right = drect.left + newWidth;
29835:           drect.bottom = drect.top + (newHeight - mLastSize.height);
29835: 
29835:           ::RedrawWindow(mWnd, &drect, NULL,
29835:                          RDW_INVALIDATE | RDW_NOERASE | RDW_NOINTERNALPAINT | RDW_ERASENOW | RDW_ALLCHILDREN);
29835:         }
29835: 
29835:         mBounds.width  = newWidth;
29835:         mBounds.height = newHeight;
29835:         mLastSize.width = newWidth;
29835:         mLastSize.height = newHeight;
29835:         ///nsRect rect(wp->x, wp->y, wp->cx, wp->cy);
29835: 
29835:         // If we're being minimized, don't send the resize event to Gecko because
29835:         // it will cause the scrollbar in the content area to go away and we'll
29835:         // forget the scroll position of the page.  Note that we need to check the
29835:         // toplevel window, because child windows seem to go to 0x0 on minimize.
29835:         HWND toplevelWnd = GetTopLevelHWND(mWnd);
29835:         if (!newWidth && !newHeight && IsIconic(toplevelWnd)) {
29835:           result = PR_FALSE;
29835:           break;
29835:         }
29835: 
29835:         // recalculate the width and height
29835:         // this time based on the client area
29835:         if (::GetClientRect(mWnd, &r)) {
29835:           rect.width  = PRInt32(r.right - r.left);
29835:           rect.height = PRInt32(r.bottom - r.top);
29835:         }
29835:         result = OnResize(rect);
29835:       }
29835: 
29835:       /* handle size mode changes
29835:          (the framechanged message seems a handy place to hook in,
29835:          because it happens early enough (WM_SIZE is too late) and
29835:          because in testing it seems an accurate harbinger of
29835:          an impending min/max/restore change (WM_NCCALCSIZE would
29835:          also work, but it's also sent when merely resizing.)) */
29835:       if (wp->flags & SWP_FRAMECHANGED && ::IsWindowVisible(mWnd)) {
29835:         nsSizeModeEvent event(PR_TRUE, NS_SIZEMODE, this);
29835: #ifndef WINCE
29835:         WINDOWPLACEMENT pl;
29835:         pl.length = sizeof(pl);
29835:         ::GetWindowPlacement(mWnd, &pl);
29835: 
29835:         if (pl.showCmd == SW_SHOWMAXIMIZED)
29835:           event.mSizeMode = nsSizeMode_Maximized;
29835:         else if (pl.showCmd == SW_SHOWMINIMIZED)
29835:           event.mSizeMode = nsSizeMode_Minimized;
29835:         else
29835:           event.mSizeMode = nsSizeMode_Normal;
29835: #else
30075:         event.mSizeMode = mSizeMode;
29835: #endif
29835:         InitEvent(event);
29835: 
29835:         result = DispatchWindowEvent(&event);
29835:       }
29835:     }
29835:     break;
29835: 
29835:     case WM_SETTINGCHANGE:
30094: #if !defined (WINCE_WINDOWS_MOBILE)
29835:       getWheelInfo = PR_TRUE;
29835: #endif
29835:       OnSettingsChange(wParam, lParam);
29835:       break;
29835: 
29835: #ifndef WINCE
29835:     case WM_INPUTLANGCHANGEREQUEST:
29835:       *aRetValue = TRUE;
29835:       result = PR_FALSE;
29835:       break;
29835: 
29835:     case WM_INPUTLANGCHANGE:
29835:       result = OnInputLangChange((HKL)lParam);
29835:       break;
29835: #endif // WINCE
29835: 
29835:     case WM_DESTROYCLIPBOARD:
29835:     {
29835:       nsIClipboard* clipboard;
29835:       nsresult rv = CallGetService(kCClipboardCID, &clipboard);
29835:       clipboard->EmptyClipboard(nsIClipboard::kGlobalClipboard);
29835:       NS_RELEASE(clipboard);
29835:     }
29835:     break;
29835: 
29835: #ifdef ACCESSIBILITY
29835:     case WM_GETOBJECT:
29835:     {
29835:       *aRetValue = 0;
29835:       if (lParam == OBJID_CLIENT) { // oleacc.dll will be loaded dynamically
29835:         nsCOMPtr<nsIAccessible> rootAccessible = GetRootAccessible(); // Held by a11y cache
29835:         if (rootAccessible) {
29835:           IAccessible *msaaAccessible = NULL;
29835:           rootAccessible->GetNativeInterface((void**)&msaaAccessible); // does an addref
29835:           if (msaaAccessible) {
29835:             *aRetValue = LresultFromObject(IID_IAccessible, wParam, msaaAccessible); // does an addref
29835:             msaaAccessible->Release(); // release extra addref
29835:             result = PR_TRUE;  // We handled the WM_GETOBJECT message
29835:           }
29835:         }
29835:       }
29835:     }
29835: #endif
29835: 
29835: #ifndef WINCE
29835:     case WM_SYSCOMMAND:
29835:       // prevent Windows from trimming the working set. bug 76831
29835:       if (!sTrimOnMinimize && wParam == SC_MINIMIZE) {
29835:         ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
29835:         result = PR_TRUE;
29835:       }
29835:       break;
29835: #endif
29835: 
29835: 
29835: #ifdef WINCE
29835:   case WM_HIBERNATE:        
29835:     nsMemory::HeapMinimize(PR_TRUE);
29835:     break;
29835: #endif
29835: 
30094: #if !defined (WINCE_WINDOWS_MOBILE)
29835:   case WM_MOUSEWHEEL:
29835:   case WM_MOUSEHWHEEL:
29851:     {
29851:       // If OnMouseWheel returns true, the event was forwarded directly to another
29851:       // mozilla window message handler (ProcessMessage). In this case the return
29851:       // value of the forwarded event is in 'result' which we should return immediately.
29851:       // If OnMouseWheel returns false, OnMouseWheel processed the event internally.
29851:       // 'result' and 'aRetValue' will be set based on what we did with the event, so
29851:       // we should fall through.
29835:       if (OnMouseWheel(msg, wParam, lParam, getWheelInfo, result, aRetValue))
29835:         return result;
29851:     }
29835:     break;
29835: #endif
29835: 
29835: #ifndef WINCE
29835:   case WM_DWMCOMPOSITIONCHANGED:
29835:     BroadcastMsg(mWnd, WM_DWMCOMPOSITIONCHANGED);
29835:     DispatchStandardEvent(NS_THEMECHANGED);
29835:     if (nsUXThemeData::CheckForCompositor() && mTransparencyMode == eTransparencyGlass) {
29835:       MARGINS margins = { -1, -1, -1, -1 };
29835:       nsUXThemeData::dwmExtendFrameIntoClientAreaPtr(mWnd, &margins);
29835:     }
29835:     Invalidate(PR_FALSE);
29835:     break;
29835: #endif
29835: 
29835: #if !defined(WINCE)
29835:   /* Gesture support events */
29835:   case WM_TABLET_QUERYSYSTEMGESTURESTATUS:
29835:     // According to MS samples, this must be handled to enable
29835:     // rotational support in multi-touch drivers.
29835:     result = PR_TRUE;
29835:     *aRetValue = TABLET_ROTATE_GESTURE_ENABLE;
29835:     break;
29835:     
29835:   case WM_GESTURE:
29835:     result = OnGesture(wParam, lParam);
29835:     break;
29835: #endif // !defined(WINCE)
29835: 
29835:     default:
29835:     {
29835: #ifdef NS_ENABLE_TSF
29835:       if (msg == WM_USER_TSF_TEXTCHANGE) {
29835:         nsTextStore::OnTextChangeMsg();
29835:       }
29835: #endif //NS_ENABLE_TSF
29835: #if defined(HEAP_DUMP_EVENT)
29835:       if (msg == GetHeapMsg()) {
29835:         HeapDump(msg, wParam, lParam);
29835:         result = PR_TRUE;
29835:       }
29835: #endif
29835:     }
29835:     break;
29835:   }
29835: 
29835:   //*aRetValue = result;
29835:   if (mWnd) {
29835:     return result;
29835:   }
29835:   else {
29835:     //Events which caused mWnd destruction and aren't consumed
29835:     //will crash during the Windows default processing.
29835:     return PR_TRUE;
29835:   }
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Broadcast messaging
29835:  *
29835:  * Broadcast messages to all windows.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Enumerate all child windows sending aMsg to each of them
29835: BOOL CALLBACK nsWindow::BroadcastMsgToChildren(HWND aWnd, LPARAM aMsg)
29835: {
29835:   WNDPROC winProc = (WNDPROC)::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
29835:   if (winProc == &nsWindow::WindowProc) {
29835:     // it's one of our windows so go ahead and send a message to it
29835:     ::CallWindowProcW(winProc, aWnd, aMsg, 0, 0);
29835:   }
29835:   return TRUE;
29835: }
29835: 
29835: // Enumerate all top level windows specifying that the children of each
29835: // top level window should be enumerated. Do *not* send the message to
29835: // each top level window since it is assumed that the toolkit will send
29835: // aMsg to them directly.
29835: BOOL CALLBACK nsWindow::BroadcastMsg(HWND aTopWindow, LPARAM aMsg)
29835: {
29835:   // Iterate each of aTopWindows child windows sending the aMsg
29835:   // to each of them.
29835: #if !defined(WINCE)
29835:   ::EnumChildWindows(aTopWindow, nsWindow::BroadcastMsgToChildren, aMsg);
29835: #else
29835:   nsWindowCE::EnumChildWindows(aTopWindow, nsWindow::BroadcastMsgToChildren, aMsg);
29835: #endif
29835:   return TRUE;
29835: }
29835: 
29835: // This method is called from nsToolkit::WindowProc to forward global
29835: // messages which need to be dispatched to all child windows.
29835: void nsWindow::GlobalMsgWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
29835: {
29835:   switch (msg) {
29835:     case WM_SYSCOLORCHANGE:
29835:       // Code to dispatch WM_SYSCOLORCHANGE message to all child windows.
29835:       // WM_SYSCOLORCHANGE is only sent to top-level windows, but the
29835:       // cross platform API requires that NS_SYSCOLORCHANGE message be sent to
29835:       // all child windows as well. When running in an embedded application
29835:       // we may not receive a WM_SYSCOLORCHANGE message because the top
29835:       // level window is owned by the embeddor.
29835:       // System color changes are posted to top-level windows only.
29835:       // The NS_SYSCOLORCHANGE must be dispatched to all child
29835:       // windows as well.
29835: #if !defined(WINCE)
29835:      ::EnumThreadWindows(GetCurrentThreadId(), nsWindow::BroadcastMsg, msg);
29835: #endif
29835:     break;
29835:   }
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Event processing helpers
29835:  *
29835:  * Special processing for certain event types and 
29835:  * synthesized events.
29835:  *
29835:  **************************************************************/
29835: 
29835: #ifndef WINCE
29835: void nsWindow::PostSleepWakeNotification(const char* aNotification)
29835: {
29835:   nsCOMPtr<nsIObserverService> observerService = do_GetService("@mozilla.org/observer-service;1");
29835:   if (observerService)
29835:   {
29835:     observerService->NotifyObservers(nsnull, aNotification, nsnull);
29835:   }
29835: }
29835: #endif
29835: 
29835: LRESULT nsWindow::ProcessCharMessage(const MSG &aMsg, PRBool *aEventDispatched)
29835: {
29835:   NS_PRECONDITION(aMsg.message == WM_CHAR || aMsg.message == WM_SYSCHAR,
29835:                   "message is not keydown event");
29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
29835:          ("%s charCode=%d scanCode=%d\n",
29835:          aMsg.message == WM_SYSCHAR ? "WM_SYSCHAR" : "WM_CHAR",
29835:          aMsg.wParam, HIWORD(aMsg.lParam) & 0xFF));
29835: 
29835:   // These must be checked here too as a lone WM_CHAR could be received
29835:   // if a child window didn't handle it (for example Alt+Space in a content window)
29835:   nsModifierKeyState modKeyState;
29835:   return OnChar(aMsg, modKeyState, aEventDispatched);
29835: }
29835: 
29835: LRESULT nsWindow::ProcessKeyUpMessage(const MSG &aMsg, PRBool *aEventDispatched)
29835: {
29835:   NS_PRECONDITION(aMsg.message == WM_KEYUP || aMsg.message == WM_SYSKEYUP,
29835:                   "message is not keydown event");
29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
29835:          ("%s VK=%d\n", aMsg.message == WM_SYSKEYDOWN ?
29835:                           "WM_SYSKEYUP" : "WM_KEYUP", aMsg.wParam));
29835: 
29835:   nsModifierKeyState modKeyState;
29835: 
29835:   // Note: the original code passed (HIWORD(lParam)) to OnKeyUp as
29835:   // scan code. However, this breaks Alt+Num pad input.
29835:   // MSDN states the following:
29835:   //  Typically, ToAscii performs the translation based on the
29835:   //  virtual-key code. In some cases, however, bit 15 of the
29835:   //  uScanCode parameter may be used to distinguish between a key
29835:   //  press and a key release. The scan code is used for
29835:   //  translating ALT+number key combinations.
29835: 
29835:   // ignore [shift+]alt+space so the OS can handle it
29835:   if (modKeyState.mIsAltDown && !modKeyState.mIsControlDown &&
29835:       IS_VK_DOWN(NS_VK_SPACE)) {
29835:     return FALSE;
29835:   }
29835: 
29835:   if (!nsIMM32Handler::IsComposing(this) &&
29835:       (aMsg.message != WM_KEYUP || aMsg.message != VK_MENU)) {
29835:     // Ignore VK_MENU if it's not a system key release, so that the menu bar does not trigger
29835:     // This helps avoid triggering the menu bar for ALT key accelerators used in
29835:     // assistive technologies such as Window-Eyes and ZoomText, and when using Alt+Tab
29835:     // to switch back to Mozilla in Windows 95 and Windows 98
29835:     return OnKeyUp(aMsg, modKeyState, aEventDispatched);
29835:   }
29835: 
29835:   return 0;
29835: }
29835: 
29835: LRESULT nsWindow::ProcessKeyDownMessage(const MSG &aMsg,
29835:                                         PRBool *aEventDispatched)
29835: {
29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
29835:          ("%s VK=%d\n", aMsg.message == WM_SYSKEYDOWN ?
29835:                           "WM_SYSKEYDOWN" : "WM_KEYDOWN", aMsg.wParam));
29835:   NS_PRECONDITION(aMsg.message == WM_KEYDOWN || aMsg.message == WM_SYSKEYDOWN,
29835:                   "message is not keydown event");
29835: 
29835:   nsModifierKeyState modKeyState;
29835: 
29835:   // Note: the original code passed (HIWORD(lParam)) to OnKeyDown as
29835:   // scan code. However, this breaks Alt+Num pad input.
29835:   // MSDN states the following:
29835:   //  Typically, ToAscii performs the translation based on the
29835:   //  virtual-key code. In some cases, however, bit 15 of the
29835:   //  uScanCode parameter may be used to distinguish between a key
29835:   //  press and a key release. The scan code is used for
29835:   //  translating ALT+number key combinations.
29835: 
29835:   // ignore [shift+]alt+space so the OS can handle it
29835:   if (modKeyState.mIsAltDown && !modKeyState.mIsControlDown &&
29835:       IS_VK_DOWN(NS_VK_SPACE))
29835:     return FALSE;
29835: 
29835:   LRESULT result = 0;
29835:   if (modKeyState.mIsAltDown && nsIMM32Handler::IsStatusChanged()) {
29835:     nsIMM32Handler::NotifyEndStatusChange();
29835:   } else if (!nsIMM32Handler::IsComposing(this)) {
29835:     result = OnKeyDown(aMsg, modKeyState, aEventDispatched, nsnull);
29835:   }
29835: 
29835: #ifndef WINCE
29835:   if (aMsg.wParam == VK_MENU ||
29835:       (aMsg.wParam == VK_F10 && !modKeyState.mIsShiftDown)) {
29835:     // We need to let Windows handle this keypress,
29835:     // by returning PR_FALSE, if there's a native menu
29835:     // bar somewhere in our containing window hierarchy.
29835:     // Otherwise we handle the keypress and don't pass
29835:     // it on to Windows, by returning PR_TRUE.
29835:     PRBool hasNativeMenu = PR_FALSE;
29835:     HWND hWnd = mWnd;
29835:     while (hWnd) {
29835:       if (::GetMenu(hWnd)) {
29835:         hasNativeMenu = PR_TRUE;
29835:         break;
29835:       }
29835:       hWnd = ::GetParent(hWnd);
29835:     }
29835:     result = !hasNativeMenu;
29835:   }
29835: #endif
29835: 
29835:   return result;
29835: }
29835: 
29835: nsresult
29835: nsWindow::SynthesizeNativeKeyEvent(PRInt32 aNativeKeyboardLayout,
29835:                                    PRInt32 aNativeKeyCode,
29835:                                    PRUint32 aModifierFlags,
29835:                                    const nsAString& aCharacters,
29835:                                    const nsAString& aUnmodifiedCharacters)
29835: {
29835: #ifndef WINCE  //Win CE doesn't support many of the calls used in this method, perhaps theres another way
29835:   nsPrintfCString layoutName("%08x", aNativeKeyboardLayout);
29835:   HKL loadedLayout = LoadKeyboardLayoutA(layoutName.get(), KLF_NOTELLSHELL);
29835:   if (loadedLayout == NULL)
29835:     return NS_ERROR_NOT_AVAILABLE;
29835: 
29835:   // Setup clean key state and load desired layout
29835:   BYTE originalKbdState[256];
29835:   ::GetKeyboardState(originalKbdState);
29835:   BYTE kbdState[256];
29835:   memset(kbdState, 0, sizeof(kbdState));
29835:   // This changes the state of the keyboard for the current thread only,
29835:   // and we'll restore it soon, so this should be OK.
29835:   ::SetKeyboardState(kbdState);
29835:   HKL oldLayout = gKbdLayout.GetLayout();
29835:   gKbdLayout.LoadLayout(loadedLayout);
29835: 
29835:   nsAutoTArray<KeyPair,10> keySequence;
29835:   SetupKeyModifiersSequence(&keySequence, aModifierFlags);
29835:   NS_ASSERTION(aNativeKeyCode >= 0 && aNativeKeyCode < 256,
29835:                "Native VK key code out of range");
29835:   keySequence.AppendElement(KeyPair(aNativeKeyCode, 0));
29835: 
29835:   // Simulate the pressing of each modifier key and then the real key
29835:   for (PRUint32 i = 0; i < keySequence.Length(); ++i) {
29835:     PRUint8 key = keySequence[i].mGeneral;
29835:     PRUint8 keySpecific = keySequence[i].mSpecific;
29835:     kbdState[key] = 0x81; // key is down and toggled on if appropriate
29835:     if (keySpecific) {
29835:       kbdState[keySpecific] = 0x81;
29835:     }
29835:     ::SetKeyboardState(kbdState);
29835:     nsModifierKeyState modKeyState;
29835:     MSG msg = InitMSG(WM_KEYDOWN, key, 0);
29835:     if (i == keySequence.Length() - 1 && aCharacters.Length() > 0) {
29835:       UINT scanCode = ::MapVirtualKeyEx(aNativeKeyCode, MAPVK_VK_TO_VSC,
29835:                                         gKbdLayout.GetLayout());
29835:       nsFakeCharMessage fakeMsg = { aCharacters.CharAt(0), scanCode };
29835:       OnKeyDown(msg, modKeyState, nsnull, &fakeMsg);
29835:     } else {
29835:       OnKeyDown(msg, modKeyState, nsnull, nsnull);
29835:     }
29835:   }
29835:   for (PRUint32 i = keySequence.Length(); i > 0; --i) {
29835:     PRUint8 key = keySequence[i - 1].mGeneral;
29835:     PRUint8 keySpecific = keySequence[i - 1].mSpecific;
29835:     kbdState[key] = 0; // key is up and toggled off if appropriate
29835:     if (keySpecific) {
29835:       kbdState[keySpecific] = 0;
29835:     }
29835:     ::SetKeyboardState(kbdState);
29835:     nsModifierKeyState modKeyState;
29835:     MSG msg = InitMSG(WM_KEYUP, key, 0);
29835:     OnKeyUp(msg, modKeyState, nsnull);
29835:   }
29835: 
29835:   // Restore old key state and layout
29835:   ::SetKeyboardState(originalKbdState);
29835:   gKbdLayout.LoadLayout(oldLayout);
29835: 
29835:   UnloadKeyboardLayout(loadedLayout);
29835:   return NS_OK;
29835: #else  //XXX: is there another way to do this?
29835:   return NS_ERROR_NOT_IMPLEMENTED;
29835: #endif
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: OnXXX message handlers
29835:  *
29835:  * For message handlers that need to be broken out or
29835:  * implemented in specific platform code.
29835:  *
29835:  **************************************************************/
29835: 
29835: BOOL nsWindow::OnInputLangChange(HKL aHKL)
29835: {
29835: #ifdef KE_DEBUG
29835:   printf("OnInputLanguageChange\n");
29835: #endif
29835: 
29835: #ifndef WINCE
29835:   gKbdLayout.LoadLayout(aHKL);
29835: #endif
29835: 
29835:   return PR_FALSE;   // always pass to child window
29835: }
29835: 
29835: #if !defined(WINCE)
29835: void nsWindow::OnWindowPosChanging(LPWINDOWPOS& info)
29835: {
29835:   // enforce local z-order rules
29835:   if (!(info->flags & SWP_NOZORDER)) {
29835:     HWND hwndAfter = info->hwndInsertAfter;
29835:     
29835:     nsZLevelEvent event(PR_TRUE, NS_SETZLEVEL, this);
29835:     nsWindow *aboveWindow = 0;
29835: 
29835:     InitEvent(event);
29835: 
29835:     if (hwndAfter == HWND_BOTTOM)
29835:       event.mPlacement = nsWindowZBottom;
29835:     else if (hwndAfter == HWND_TOP || hwndAfter == HWND_TOPMOST || hwndAfter == HWND_NOTOPMOST)
29835:       event.mPlacement = nsWindowZTop;
29835:     else {
29835:       event.mPlacement = nsWindowZRelative;
29835:       aboveWindow = GetNSWindowPtr(hwndAfter);
29835:     }
29835:     event.mReqBelow = aboveWindow;
29835:     event.mActualBelow = nsnull;
29835: 
29835:     event.mImmediate = PR_FALSE;
29835:     event.mAdjusted = PR_FALSE;
29835:     DispatchWindowEvent(&event);
29835: 
29835:     if (event.mAdjusted) {
29835:       if (event.mPlacement == nsWindowZBottom)
29835:         info->hwndInsertAfter = HWND_BOTTOM;
29835:       else if (event.mPlacement == nsWindowZTop)
29835:         info->hwndInsertAfter = HWND_TOP;
29835:       else {
29835:         info->hwndInsertAfter = (HWND)event.mActualBelow->GetNativeData(NS_NATIVE_WINDOW);
29835:       }
29835:     }
29835:     NS_IF_RELEASE(event.mActualBelow);
29835:   }
29835:   // prevent rude external programs from making hidden window visible
29835:   if (mWindowType == eWindowType_invisible)
29835:     info->flags &= ~SWP_SHOWWINDOW;
29835: }
29835: #endif
29835: 
29835: // Gesture event processing. Handles WM_GESTURE events.
29835: #if !defined(WINCE)
29835: PRBool nsWindow::OnGesture(WPARAM wParam, LPARAM lParam)
29835: {
29835:   // Treatment for pan events which translate into scroll events:
29835:   if (mGesture.IsPanEvent(lParam)) {
29835:     nsMouseScrollEvent event(PR_TRUE, NS_MOUSE_PIXEL_SCROLL, this);
29835: 
29835:     if ( !mGesture.ProcessPanMessage(mWnd, wParam, lParam) )
29835:       return PR_FALSE; // ignore
29835: 
29835:     nsEventStatus status;
29835: 
29835:     event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
29835:     event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
29835:     event.isMeta    = PR_FALSE;
29835:     event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
29835:     event.button    = 0;
29835:     event.time      = ::GetMessageTime();
29835: 
29835:     PRBool endFeedback = PR_TRUE;
29835:     
29835:     if (mGesture.PanDeltaToPixelScrollX(event)) {
29835:       DispatchEvent(&event, status);
29835:     }
29835:     mGesture.UpdatePanFeedbackX(mWnd, event, endFeedback);
29835:     
29835:     if (mGesture.PanDeltaToPixelScrollY(event)) {
29835:       DispatchEvent(&event, status);
29835:     }
29835:     mGesture.UpdatePanFeedbackY(mWnd, event, endFeedback);
29835:     mGesture.PanFeedbackFinalize(mWnd, endFeedback);
29835:     mGesture.CloseGestureInfoHandle((HGESTUREINFO)lParam);
29835: 
29835:     return PR_TRUE;
29835:   }
29835: 
29835:   // Other gestures translate into simple gesture events:
29835:   nsSimpleGestureEvent event(PR_TRUE, 0, this, 0, 0.0);
29835:   if ( !mGesture.ProcessGestureMessage(mWnd, wParam, lParam, event) ) {
29835:     return PR_FALSE; // fall through to DefWndProc
29835:   }
29835:   
29835:   // Polish up and send off the new event
29835:   event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
29835:   event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
29835:   event.isMeta    = PR_FALSE;
29835:   event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
29835:   event.button    = 0;
29835:   event.time      = ::GetMessageTime();
29835: 
29835:   nsEventStatus status;
29835:   DispatchEvent(&event, status);
29835:   if (status == nsEventStatus_eIgnore) {
29835:     return PR_FALSE; // Ignored, fall through
29835:   }
29835: 
29835:   // Only close this if we process and return true.
29835:   mGesture.CloseGestureInfoHandle((HGESTUREINFO)lParam);
29835: 
29835:   return PR_TRUE; // Handled
29835: }
29835: #endif // !defined(WINCE)
29835: 
29835: /*
29835:  * OnMouseWheel - mouse wheele event processing. This was originally embedded
29835:  * within the message case block. If returning true result should be returned
29835:  * immediately (no more processing).
29835:  */
30094: #if !defined (WINCE_WINDOWS_MOBILE)
29835: PRBool nsWindow::OnMouseWheel(UINT msg, WPARAM wParam, LPARAM lParam, PRBool& getWheelInfo, PRBool& result, LRESULT *aRetValue)
29835: {
29835:   // Handle both flavors of mouse wheel events.
29835:   static int iDeltaPerLine, iDeltaPerChar;
29835:   static ULONG ulScrollLines, ulScrollChars = 1;
29835:   static int currentVDelta, currentHDelta;
29835:   static HWND currentWindow = 0;
29835: 
29835:   PRBool isVertical = msg == WM_MOUSEWHEEL;
29835: 
29835:   // Get mouse wheel metrics (but only once).
29835:   if (getWheelInfo) {
29835:     getWheelInfo = PR_FALSE;
29835: 
29835:     SystemParametersInfo (SPI_GETWHEELSCROLLLINES, 0, &ulScrollLines, 0);
29835: 
29835:     // ulScrollLines usually equals 3 or 0 (for no scrolling)
29835:     // WHEEL_DELTA equals 120, so iDeltaPerLine will be 40.
29835: 
29835:     // However, if ulScrollLines > WHEEL_DELTA, we assume that
29835:     // the mouse driver wants a page scroll.  The docs state that
29835:     // ulScrollLines should explicitly equal WHEEL_PAGESCROLL, but
29835:     // since some mouse drivers use an arbitrary large number instead,
29835:     // we have to handle that as well.
29835: 
29835:     iDeltaPerLine = 0;
29835:     if (ulScrollLines) {
29835:       if (ulScrollLines <= WHEEL_DELTA) {
29835:         iDeltaPerLine = WHEEL_DELTA / ulScrollLines;
29835:       } else {
29835:         ulScrollLines = WHEEL_PAGESCROLL;
29835:       }
29835:     }
29835: 
29835:     if (!SystemParametersInfo(SPI_GETWHEELSCROLLCHARS, 0,
29835:                               &ulScrollChars, 0)) {
29835:       // Note that we may always fail to get the value before Win Vista.
29835:       ulScrollChars = 1;
29835:     }
29835: 
29835:     iDeltaPerChar = 0;
29835:     if (ulScrollChars) {
29835:       if (ulScrollChars <= WHEEL_DELTA) {
29835:         iDeltaPerChar = WHEEL_DELTA / ulScrollChars;
29835:       } else {
29835:         ulScrollChars = WHEEL_PAGESCROLL;
29835:       }
29835:     }
29835:   }
29835: 
29835:   if ((isVertical  && ulScrollLines != WHEEL_PAGESCROLL && !iDeltaPerLine) ||
29835:       (!isVertical && ulScrollChars != WHEEL_PAGESCROLL && !iDeltaPerChar))
29835:     return PR_FALSE; // break
29835: 
29835:   // The mousewheel event will be dispatched to the toplevel
29835:   // window.  We need to give it to the child window
29835: 
29835:   POINT point;
29835:   point.x = GET_X_LPARAM(lParam);
29835:   point.y = GET_Y_LPARAM(lParam);
29835:   HWND destWnd = ::WindowFromPoint(point);
29835: 
29835:   // Since we receive mousewheel events for as long as
29835:   // we are focused, it's entirely possible that there
29835:   // is another app's window or no window under the
29835:   // pointer.
29835: 
29835:   if (!destWnd) {
29835:     // No window is under the pointer
29835:     return PR_FALSE; // break
29835:   }
29835: 
29835:   // We don't care about windows belonging to other processes.
29835:   DWORD processId = 0;
29835:   GetWindowThreadProcessId(destWnd, &processId);
29835:   if (processId != GetCurrentProcessId())
29835:   {
29835:     // Somebody elses window
29835:     return PR_FALSE; // break
29835:   }
29835: 
29835:   nsWindow* destWindow = GetNSWindowPtr(destWnd);
29835:   if (!destWindow || destWindow->mIsPluginWindow) {
29835:     // Some other app, or a plugin window.
29835:     // Windows directs WM_MOUSEWHEEL to the focused window.
29835:     // However, Mozilla does not like plugins having focus, so a
29835:     // Mozilla window (ie, the plugin's parent (us!) has focus.)
29835:     // Therefore, plugins etc _should_ get first grab at the
29835:     // message, but this focus vaguary means the plugin misses
29835:     // out. If the window is a child of ours, forward it on.
29835:     // Determine if a child by walking the parent list until
29835:     // we find a parent matching our wndproc.
29835:     HWND parentWnd = ::GetParent(destWnd);
29835:     while (parentWnd) {
29835:       nsWindow* parentWindow = GetNSWindowPtr(parentWnd);
29835:       if (parentWindow) {
29835:         // We have a child window - quite possibly a plugin window.
29835:         // However, not all plugins are created equal - some will handle this message themselves,
29835:         // some will forward directly back to us, while others will call DefWndProc, which
29835:         // itself still forwards back to us.
29835:         // So if we have sent it once, we need to handle it ourself.
29835:         if (mInWheelProcessing) {
29835:           destWnd = parentWnd;
29835:           destWindow = parentWindow;
29835:         } else {
29835:           // First time we have seen this message.
29835:           // Call the child - either it will consume it, or
29835:           // it will wind it's way back to us, triggering the destWnd case above.
29835:           // either way, when the call returns, we are all done with the message,
29835:           mInWheelProcessing = PR_TRUE;
29835:           if (0 == ::SendMessageW(destWnd, msg, wParam, lParam)) {
29835:             result = PR_TRUE; // consumed - don't call DefWndProc
29835:           }
29835:           destWnd = nsnull;
29835:           mInWheelProcessing = PR_FALSE;
29835:         }
29835:         return PR_FALSE; // break; // stop parent search
29835:       }
29835:       parentWnd = ::GetParent(parentWnd);
29835:     } // while parentWnd
29835:   }
29835:   if (destWnd == nsnull)
29835:     return PR_FALSE;
29835:   if (destWnd != mWnd) {
29835:     if (destWindow) {
29835:       result = destWindow->ProcessMessage(msg, wParam, lParam, aRetValue);
29835:       return PR_TRUE; // return result immediately
29835:     }
29835:   #ifdef DEBUG
29835:     else
29835:       printf("WARNING: couldn't get child window for MW event\n");
29835:   #endif
29835:   }
29835: 
29835:   // We should cancel the surplus delta if the current window is not
29835:   // same as previous.
29835:   if (currentWindow != mWnd) {
29835:     currentVDelta = 0;
29835:     currentHDelta = 0;
29835:     currentWindow = mWnd;
29835:   }
29835: 
29835:   nsMouseScrollEvent scrollEvent(PR_TRUE, NS_MOUSE_SCROLL, this);
29835:   scrollEvent.delta = 0;
29835:   if (isVertical) {
29835:     scrollEvent.scrollFlags = nsMouseScrollEvent::kIsVertical;
29835:     if (ulScrollLines == WHEEL_PAGESCROLL) {
29835:       scrollEvent.scrollFlags |= nsMouseScrollEvent::kIsFullPage;
29835:       scrollEvent.delta = (((short) HIWORD (wParam)) > 0) ? -1 : 1;
29835:     } else {
29835:       currentVDelta -= (short) HIWORD (wParam);
29835:       if (PR_ABS(currentVDelta) >= iDeltaPerLine) {
29835:         scrollEvent.delta = currentVDelta / iDeltaPerLine;
29835:         currentVDelta %= iDeltaPerLine;
29835:       }
29835:     }
29835:   } else {
29835:     scrollEvent.scrollFlags = nsMouseScrollEvent::kIsHorizontal;
29835:     if (ulScrollChars == WHEEL_PAGESCROLL) {
29835:       scrollEvent.scrollFlags |= nsMouseScrollEvent::kIsFullPage;
29835:       scrollEvent.delta = (((short) HIWORD (wParam)) > 0) ? 1 : -1;
29835:     } else {
29835:       currentHDelta += (short) HIWORD (wParam);
29835:       if (PR_ABS(currentHDelta) >= iDeltaPerChar) {
29835:         scrollEvent.delta = currentHDelta / iDeltaPerChar;
29835:         currentHDelta %= iDeltaPerChar;
29835:       }
29835:     }
29835:   }
29835: 
29842:   if (!scrollEvent.delta)
29843:     return PR_FALSE; // break
29842: 
29835:   scrollEvent.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
29835:   scrollEvent.isControl = IS_VK_DOWN(NS_VK_CONTROL);
29835:   scrollEvent.isMeta    = PR_FALSE;
29835:   scrollEvent.isAlt     = IS_VK_DOWN(NS_VK_ALT);
29835:   InitEvent(scrollEvent);
29835:   if (nsnull != mEventCallback) {
29835:     result = DispatchWindowEvent(&scrollEvent);
29835:   }
29835:   // Note that we should return zero if we process WM_MOUSEWHEEL.
29835:   // But if we process WM_MOUSEHWHEEL, we should return non-zero.
29835: 
29835:   if (result)
29851:     *aRetValue = isVertical ? 0 : TRUE;
29835:   
29835:   return PR_FALSE; // break;
29835: } 
30094: #endif // !defined(WINCE_WINDOWS_MOBILE)
29835: 
14799: static PRBool
22232: StringCaseInsensitiveEquals(const PRUnichar* aChars1, const PRUint32 aNumChars1,
22232:                             const PRUnichar* aChars2, const PRUint32 aNumChars2)
14799: {
14799:   if (aNumChars1 != aNumChars2)
14799:     return PR_FALSE;
14799: 
14799:   nsCaseInsensitiveStringComparator comp;
22232:   return comp(aChars1, aChars2, aNumChars1) == 0;
14799: }
    1: 
29835: UINT nsWindow::MapFromNativeToDOM(UINT aNativeKeyCode)
29835: {
29835: #ifndef WINCE
29835:   switch (aNativeKeyCode) {
29835:     case VK_OEM_1:     return NS_VK_SEMICOLON;     // 0xBA, For the US standard keyboard, the ';:' key
29835:     case VK_OEM_PLUS:  return NS_VK_ADD;           // 0xBB, For any country/region, the '+' key
29835:     case VK_OEM_MINUS: return NS_VK_SUBTRACT;      // 0xBD, For any country/region, the '-' key
29835:   }
29835: #endif
29835: 
29835:   return aNativeKeyCode;
29835: }
29835: 
14962: /**
14962:  * nsWindow::OnKeyDown peeks into the message queue and pulls out
14962:  * WM_CHAR messages for processing. During testing we don't want to
14962:  * mess with the real message queue. Instead we pass a
14962:  * pseudo-WM_CHAR-message using this structure, and OnKeyDown will use
14962:  * that as if it was in the message queue, and refrain from actually
14962:  * looking at or touching the message queue.
14962:  */
22788: LRESULT nsWindow::OnKeyDown(const MSG &aMsg,
27961:                             nsModifierKeyState &aModKeyState,
22788:                             PRBool *aEventDispatched,
14962:                             nsFakeCharMessage* aFakeCharMessage)
    1: {
22788:   UINT virtualKeyCode = aMsg.wParam;
22788: 
23335: #ifndef WINCE
22788:   gKbdLayout.OnKeyDown (virtualKeyCode);
23335: #endif
    1: 
    1:   // Use only DOMKeyCode for XP processing.
    1:   // Use aVirtualKeyCode for gKbdLayout and native processing.
27961:   UINT DOMKeyCode = nsIMM32Handler::IsComposing(this) ?
22788:                       virtualKeyCode : MapFromNativeToDOM(virtualKeyCode);
    1: 
    1: #ifdef DEBUG
14962:   //printf("In OnKeyDown virt: %d\n", DOMKeyCode);
    1: #endif
    1: 
22788:   PRBool noDefault =
27961:     DispatchKeyEvent(NS_KEY_DOWN, 0, nsnull, DOMKeyCode, &aMsg, aModKeyState);
22788:   if (aEventDispatched)
22788:     *aEventDispatched = PR_TRUE;
    1: 
    1:   // If we won't be getting a WM_CHAR, WM_SYSCHAR or WM_DEADCHAR, synthesize a keypress
    1:   // for almost all keys
    1:   switch (DOMKeyCode) {
    1:     case NS_VK_SHIFT:
    1:     case NS_VK_CONTROL:
    1:     case NS_VK_ALT:
    1:     case NS_VK_CAPS_LOCK:
    1:     case NS_VK_NUM_LOCK:
    1:     case NS_VK_SCROLL_LOCK: return noDefault;
    1:   }
    1: 
    1:   PRUint32 extraFlags = (noDefault ? NS_EVENT_FLAG_NO_DEFAULT : 0);
    1:   MSG msg;
14962:   BOOL gotMsg = aFakeCharMessage ||
14962:     ::PeekMessageW(&msg, mWnd, WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE | PM_NOYIELD);
    1:   // Enter and backspace are always handled here to avoid for example the
    1:   // confusion between ctrl-enter and ctrl-J.
    1:   if (DOMKeyCode == NS_VK_RETURN || DOMKeyCode == NS_VK_BACK ||
27961:       ((aModKeyState.mIsControlDown || aModKeyState.mIsAltDown)
23335: #ifdef WINCE
23335:        ))
23335: #else
23335:        && !gKbdLayout.IsDeadKey() && KeyboardLayout::IsPrintableCharKey(virtualKeyCode)))
23335: #endif
    1:   {
    1:     // Remove a possible WM_CHAR or WM_SYSCHAR messages from the message queue.
    1:     // They can be more than one because of:
    1:     //  * Dead-keys not pairing with base character
    1:     //  * Some keyboard layouts may map up to 4 characters to the single key
14962:     PRBool anyCharMessagesRemoved = PR_FALSE;
14962: 
14962:     if (aFakeCharMessage) {
14962:       anyCharMessagesRemoved = PR_TRUE;
14962:     } else {
    1:       while (gotMsg && (msg.message == WM_CHAR || msg.message == WM_SYSCHAR))
    1:       {
29835:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
14962:                ("%s charCode=%d scanCode=%d\n", msg.message == WM_SYSCHAR ? "WM_SYSCHAR" : "WM_CHAR",
14962:                 msg.wParam, HIWORD(msg.lParam) & 0xFF));
22788:         RemoveMessageAndDispatchPluginEvent(WM_KEYFIRST, WM_KEYLAST);
    1:         anyCharMessagesRemoved = PR_TRUE;
    1: 
    1:         gotMsg = ::PeekMessageW (&msg, mWnd, WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE | PM_NOYIELD);
    1:       }
14962:     }
    1: 
27961:     if (!anyCharMessagesRemoved && DOMKeyCode == NS_VK_BACK &&
27961:         nsIMM32Handler::IsDoingKakuteiUndo(mWnd)) {
27961:       NS_ASSERTION(!aFakeCharMessage,
27961:                    "We shouldn't be touching the real msg queue");
22788:       RemoveMessageAndDispatchPluginEvent(WM_CHAR, WM_CHAR);
    1:     }
    1:   }
    1:   else if (gotMsg &&
14962:            (aFakeCharMessage ||
14962:             msg.message == WM_CHAR || msg.message == WM_SYSCHAR || msg.message == WM_DEADCHAR)) {
14962:     if (aFakeCharMessage)
22788:       return OnCharRaw(aFakeCharMessage->mCharCode,
27961:                        aFakeCharMessage->mScanCode, aModKeyState, extraFlags);
14962: 
    1:     // If prevent default set for keydown, do same for keypress
    1:     ::GetMessageW(&msg, mWnd, msg.message, msg.message);
    1: 
22788:     if (msg.message == WM_DEADCHAR) {
22788:       if (!PluginHasFocus())
    1:         return PR_FALSE;
    1: 
22788:       // We need to send the removed message to focused plug-in.
22788:       DispatchPluginEvent(msg);
22788:       return noDefault;
22788:     }
22788: 
29835:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
14962:            ("%s charCode=%d scanCode=%d\n",
14962:             msg.message == WM_SYSCHAR ? "WM_SYSCHAR" : "WM_CHAR",
14962:             msg.wParam, HIWORD(msg.lParam) & 0xFF));
14962: 
27961:     BOOL result = OnChar(msg, aModKeyState, nsnull, extraFlags);
 7027:     // If a syschar keypress wasn't processed, Windows may want to
 7027:     // handle it to activate a native menu.
 7027:     if (!result && msg.message == WM_SYSCHAR)
 7027:       ::DefWindowProcW(mWnd, msg.message, msg.wParam, msg.lParam);
 7027:     return result;
23335:   }
23335: #ifndef WINCE
27961:   else if (!aModKeyState.mIsControlDown && !aModKeyState.mIsAltDown &&
22788:              (KeyboardLayout::IsPrintableCharKey(virtualKeyCode) ||
22788:               KeyboardLayout::IsNumpadKey(virtualKeyCode)))
    1:   {
    1:     // If this is simple KeyDown event but next message is not WM_CHAR,
    1:     // this event may not input text, so we should ignore this event.
    1:     // See bug 314130.
22788:     return PluginHasFocus() && noDefault;
    1:   }
    1: 
    1:   if (gKbdLayout.IsDeadKey ())
22788:     return PluginHasFocus() && noDefault;
    1: 
    1:   PRUint8 shiftStates[5];
22232:   PRUnichar uniChars[5];
22232:   PRUnichar shiftedChars[5] = {0, 0, 0, 0, 0};
22232:   PRUnichar unshiftedChars[5] = {0, 0, 0, 0, 0};
22232:   PRUnichar shiftedLatinChar = 0;
22232:   PRUnichar unshiftedLatinChar = 0;
    1:   PRUint32 numOfUniChars = 0;
14328:   PRUint32 numOfShiftedChars = 0;
14328:   PRUint32 numOfUnshiftedChars = 0;
    1:   PRUint32 numOfShiftStates = 0;
    1: 
22788:   switch (virtualKeyCode) {
    1:     // keys to be sent as characters
    1:     case VK_ADD:       uniChars [0] = '+';  numOfUniChars = 1;  break;
    1:     case VK_SUBTRACT:  uniChars [0] = '-';  numOfUniChars = 1;  break;
    1:     case VK_DIVIDE:    uniChars [0] = '/';  numOfUniChars = 1;  break;
    1:     case VK_MULTIPLY:  uniChars [0] = '*';  numOfUniChars = 1;  break;
    1:     case VK_NUMPAD0:
    1:     case VK_NUMPAD1:
    1:     case VK_NUMPAD2:
    1:     case VK_NUMPAD3:
    1:     case VK_NUMPAD4:
    1:     case VK_NUMPAD5:
    1:     case VK_NUMPAD6:
    1:     case VK_NUMPAD7:
    1:     case VK_NUMPAD8:
    1:     case VK_NUMPAD9:
22788:       uniChars [0] = virtualKeyCode - VK_NUMPAD0 + '0';
    1:       numOfUniChars = 1;
    1:       break;
    1:     default:
22788:       if (KeyboardLayout::IsPrintableCharKey(virtualKeyCode)) {
14328:         numOfUniChars = numOfShiftStates =
14328:           gKbdLayout.GetUniChars(uniChars, shiftStates,
14328:                                  NS_ARRAY_LENGTH(uniChars));
14328:       }
14328: 
27961:       if (aModKeyState.mIsControlDown ^ aModKeyState.mIsAltDown) {
14799:         PRUint8 capsLockState = (::GetKeyState(VK_CAPITAL) & 1) ? eCapsLock : 0;
14328:         numOfUnshiftedChars =
22788:           gKbdLayout.GetUniCharsWithShiftState(virtualKeyCode, capsLockState,
14328:                        unshiftedChars, NS_ARRAY_LENGTH(unshiftedChars));
14328:         numOfShiftedChars =
22788:           gKbdLayout.GetUniCharsWithShiftState(virtualKeyCode,
14799:                        capsLockState | eShift,
14328:                        shiftedChars, NS_ARRAY_LENGTH(shiftedChars));
14799: 
14476:         // The current keyboard cannot input alphabets or numerics,
14476:         // we should append them for Shortcut/Access keys.
14476:         // E.g., for Cyrillic keyboard layout.
14799:         if (NS_VK_A <= DOMKeyCode && DOMKeyCode <= NS_VK_Z) {
14476:           shiftedLatinChar = unshiftedLatinChar = DOMKeyCode;
14799:           if (capsLockState)
14799:             shiftedLatinChar += 0x20;
14799:           else
14476:             unshiftedLatinChar += 0x20;
14799:           if (unshiftedLatinChar == unshiftedChars[0] &&
14799:               shiftedLatinChar == shiftedChars[0]) {
14799:               shiftedLatinChar = unshiftedLatinChar = 0;
14799:           }
14799:         } else {
14799:           PRUint16 ch = 0;
14799:           if (NS_VK_0 <= DOMKeyCode && DOMKeyCode <= NS_VK_9) {
14799:             ch = DOMKeyCode;
14799:           } else {
22788:             switch (virtualKeyCode) {
14799:               case VK_OEM_PLUS:   ch = '+'; break;
14799:               case VK_OEM_MINUS:  ch = '-'; break;
14799:             }
14799:           }
14799:           if (ch && unshiftedChars[0] != ch && shiftedChars[0] != ch) {
14799:             // Windows has assigned a virtual key code to the key even though
14799:             // the character can't be produced with this key.  That probably
14799:             // means the character can't be produced with any key in the
14799:             // current layout and so the assignment is based on a QWERTY
14799:             // layout.  Append this code so that users can access the shortcut.
14799:             unshiftedLatinChar = ch;
14799:           }
14799:         }
14799: 
14799:         // If the charCode is not ASCII character, we should replace the
14799:         // charCode with ASCII character only when Ctrl is pressed.
14799:         // But don't replace the charCode when the charCode is not same as
14799:         // unmodified characters. In such case, Ctrl is sometimes used for a
14799:         // part of character inputting key combination like Shift.
27961:         if (aModKeyState.mIsControlDown) {
14799:           PRUint8 currentState = eCtrl;
27961:           if (aModKeyState.mIsShiftDown)
14799:             currentState |= eShift;
14799: 
27961:           PRUint32 ch =
27961:             aModKeyState.mIsShiftDown ? shiftedLatinChar : unshiftedLatinChar;
14799:           if (ch &&
14799:               (numOfUniChars == 0 ||
14799:                StringCaseInsensitiveEquals(uniChars, numOfUniChars,
27961:                  aModKeyState.mIsShiftDown ? shiftedChars : unshiftedChars,
27961:                  aModKeyState.mIsShiftDown ? numOfShiftedChars :
27961:                                              numOfUnshiftedChars))) {
14799:             numOfUniChars = numOfShiftStates = 1;
14799:             uniChars[0] = ch;
14799:             shiftStates[0] = currentState;
14799:           }
14476:         }
14328:       }
14328:   }
14328: 
14328:   if (numOfUniChars > 0 || numOfShiftedChars > 0 || numOfUnshiftedChars > 0) {
14328:     PRUint32 num = PR_MAX(numOfUniChars,
14328:                           PR_MAX(numOfShiftedChars, numOfUnshiftedChars));
14328:     PRUint32 skipUniChars = num - numOfUniChars;
14328:     PRUint32 skipShiftedChars = num - numOfShiftedChars;
14328:     PRUint32 skipUnshiftedChars = num - numOfUnshiftedChars;
14328:     UINT keyCode = numOfUniChars == 0 ? DOMKeyCode : 0;
14328:     for (PRUint32 cnt = 0; cnt < num; cnt++) {
14328:       PRUint16 uniChar, shiftedChar, unshiftedChar;
14328:       uniChar = shiftedChar = unshiftedChar = 0;
14328:       if (skipUniChars <= cnt) {
14328:         if (cnt - skipUniChars  < numOfShiftStates) {
14328:           // If key in combination with Alt and/or Ctrl produces a different
14328:           // character than without them then do not report these flags
14328:           // because it is separate keyboard layout shift state. If dead-key
14328:           // and base character does not produce a valid composite character
14328:           // then both produced dead-key character and following base
14328:           // character may have different modifier flags, too.
27961:           aModKeyState.mIsShiftDown =
27961:             (shiftStates[cnt - skipUniChars] & eShift) != 0;
27961:           aModKeyState.mIsControlDown =
27961:             (shiftStates[cnt - skipUniChars] & eCtrl) != 0;
27961:           aModKeyState.mIsAltDown =
27961:             (shiftStates[cnt - skipUniChars] & eAlt) != 0;
14328:         }
14328:         uniChar = uniChars[cnt - skipUniChars];
14328:       }
14328:       if (skipShiftedChars <= cnt)
14328:         shiftedChar = shiftedChars[cnt - skipShiftedChars];
14328:       if (skipUnshiftedChars <= cnt)
14328:         unshiftedChar = unshiftedChars[cnt - skipUnshiftedChars];
14476:       nsAutoTArray<nsAlternativeCharCode, 5> altArray;
14476: 
14476:       if (shiftedChar || unshiftedChar) {
14476:         nsAlternativeCharCode chars(unshiftedChar, shiftedChar);
14476:         altArray.AppendElement(chars);
14476:       }
14476:       if (cnt == num - 1 && (unshiftedLatinChar || shiftedLatinChar)) {
14476:         nsAlternativeCharCode chars(unshiftedLatinChar, shiftedLatinChar);
14476:         altArray.AppendElement(chars);
14476:       }
14476: 
14476:       DispatchKeyEvent(NS_KEY_PRESS, uniChar, &altArray,
27961:                        keyCode, nsnull, aModKeyState, extraFlags);
    1:     }
    1:   } else
23335: #endif
27961:     DispatchKeyEvent(NS_KEY_PRESS, 0, nsnull, DOMKeyCode, nsnull, aModKeyState,
27961:                      extraFlags);
    1: 
    1:   return noDefault;
    1: }
    1: 
29835: // OnKeyUp
27961: LRESULT nsWindow::OnKeyUp(const MSG &aMsg,
27961:                           nsModifierKeyState &aModKeyState,
27961:                           PRBool *aEventDispatched)
22788: {
22788:   UINT virtualKeyCode = aMsg.wParam;
22788: 
29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
22788:          ("nsWindow::OnKeyUp VK=%d\n", virtualKeyCode));
14962: 
27961:   if (!nsIMM32Handler::IsComposing(this)) {
27961:     virtualKeyCode = MapFromNativeToDOM(virtualKeyCode);
27961:   }
27961: 
22788:   if (aEventDispatched)
22788:     *aEventDispatched = PR_TRUE;
27961:   return DispatchKeyEvent(NS_KEY_UP, 0, nsnull, virtualKeyCode, &aMsg,
27961:                           aModKeyState);
22788: }
22788: 
29835: // OnChar
27961: LRESULT nsWindow::OnChar(const MSG &aMsg, nsModifierKeyState &aModKeyState,
27961:                          PRBool *aEventDispatched, PRUint32 aFlags)
27961: {
27961:   return OnCharRaw(aMsg.wParam, HIWORD(aMsg.lParam) & 0xFF, aModKeyState,
22788:                    aFlags, &aMsg, aEventDispatched);
22788: }
22788: 
29835: // OnCharRaw
27961: LRESULT nsWindow::OnCharRaw(UINT charCode, UINT aScanCode,
27961:                             nsModifierKeyState &aModKeyState, PRUint32 aFlags,
22788:                             const MSG *aMsg, PRBool *aEventDispatched)
14962: {
    1:   // ignore [shift+]alt+space so the OS can handle it
27961:   if (aModKeyState.mIsAltDown && !aModKeyState.mIsControlDown &&
27961:       IS_VK_DOWN(NS_VK_SPACE)) {
    1:     return FALSE;
    1:   }
    1:   
16335:   // Ignore Ctrl+Enter (bug 318235)
27961:   if (aModKeyState.mIsControlDown && charCode == 0xA) {
16335:     return FALSE;
16335:   }
16335: 
    1:   // WM_CHAR with Control and Alt (== AltGr) down really means a normal character
27961:   PRBool saveIsAltDown = aModKeyState.mIsAltDown;
27961:   PRBool saveIsControlDown = aModKeyState.mIsControlDown;
27961:   if (aModKeyState.mIsAltDown && aModKeyState.mIsControlDown)
27961:     aModKeyState.mIsAltDown = aModKeyState.mIsControlDown = PR_FALSE;
    1: 
    1:   wchar_t uniChar;
    1: 
27961:   if (nsIMM32Handler::IsComposing(this)) {
27961:     ResetInputState();
27961:   }
27961: 
27961:   if (aModKeyState.mIsControlDown && charCode <= 0x1A) { // Ctrl+A Ctrl+Z, see Programming Windows 3.1 page 110 for details
    1:     // need to account for shift here.  bug 16486
27961:     if (aModKeyState.mIsShiftDown)
    1:       uniChar = charCode - 1 + 'A';
    1:     else
    1:       uniChar = charCode - 1 + 'a';
    1:     charCode = 0;
    1:   }
27961:   else if (aModKeyState.mIsControlDown && charCode <= 0x1F) {
    1:     // Fix for 50255 - <ctrl><[> and <ctrl><]> are not being processed.
    1:     // also fixes ctrl+\ (x1c), ctrl+^ (x1e) and ctrl+_ (x1f)
    1:     // for some reason the keypress handler need to have the uniChar code set
    1:     // with the addition of a upper case A not the lower case.
    1:     uniChar = charCode - 1 + 'A';
    1:     charCode = 0;
    1:   } else { // 0x20 - SPACE, 0x3D - EQUALS
27961:     if (charCode < 0x20 || (charCode == 0x3D && aModKeyState.mIsControlDown)) {
    1:       uniChar = 0;
    1:     } else {
    1:       uniChar = charCode;
    1:       charCode = 0;
    1:     }
    1:   }
    1: 
    1:   // Keep the characters unshifted for shortcuts and accesskeys and make sure
    1:   // that numbers are always passed as such (among others: bugs 50255 and 351310)
27961:   if (uniChar && (aModKeyState.mIsControlDown || aModKeyState.mIsAltDown)) {
22411:     UINT virtualKeyCode = ::MapVirtualKeyEx(aScanCode, MAPVK_VSC_TO_VK,
22411:                                             gKbdLayout.GetLayout());
    1:     UINT unshiftedCharCode =
    1:       virtualKeyCode >= '0' && virtualKeyCode <= '9' ? virtualKeyCode :
27961:         aModKeyState.mIsShiftDown ? ::MapVirtualKeyEx(virtualKeyCode,
27961:                                         MAPVK_VK_TO_CHAR,
22411:                                         gKbdLayout.GetLayout()) : 0;
    1:     // ignore diacritics (top bit set) and key mapping errors (char code 0)
    1:     if ((INT)unshiftedCharCode > 0)
    1:       uniChar = unshiftedCharCode;
    1:   }
    1: 
    1:   // Fix for bug 285161 (and 295095) which was caused by the initial fix for bug 178110.
    1:   // When pressing (alt|ctrl)+char, the char must be lowercase unless shift is
    1:   // pressed too.
27961:   if (!aModKeyState.mIsShiftDown && (saveIsAltDown || saveIsControlDown)) {
    1:     uniChar = towlower(uniChar);
    1:   }
    1: 
14476:   PRBool result = DispatchKeyEvent(NS_KEY_PRESS, uniChar, nsnull,
27961:                                    charCode, aMsg, aModKeyState, aFlags);
22788:   if (aEventDispatched)
22788:     *aEventDispatched = PR_TRUE;
27961:   aModKeyState.mIsAltDown = saveIsAltDown;
27961:   aModKeyState.mIsControlDown = saveIsControlDown;
    1:   return result;
    1: }
    1: 
29835: void
29835: nsWindow::SetupKeyModifiersSequence(nsTArray<KeyPair>* aArray, PRUint32 aModifiers)
14962: {
14962:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(sModifierKeyMap); ++i) {
14962:     const PRUint32* map = sModifierKeyMap[i];
14962:     if (aModifiers & map[0]) {
14962:       aArray->AppendElement(KeyPair(map[1], map[2]));
14962:     }
14962:   }
14962: }
14962: 
30223: // WM_DESTROY event handler
    1: void nsWindow::OnDestroy()
    1: {
    1:   mOnDestroyCalled = PR_TRUE;
    1: 
30223:   // Make sure we don't get destroyed in the process of tearing down.
30223:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
30223:   
30223:   // Dispatch the NS_DESTROY event. Must be called before mEventCallback is cleared.
30223:   if (!mInDtor)
30223:     DispatchStandardEvent(NS_DESTROY);
30223: 
30223:   // Prevent the widget from sending additional events.
30223:   mEventCallback = nsnull;
30223: 
30223:   // Free our subclass and clear |this| stored in the window props. We will no longer
30223:   // receive events from Windows after this point.
    1:   SubclassWindow(FALSE);
 4186: 
30223:   // Once mEventCallback is cleared and the subclass is reset, sCurrentWindow can be
30223:   // cleared. (It's used in tracking windows for mouse events.)
30223:   if (sCurrentWindow == this)
30223:     sCurrentWindow = nsnull;
30223: 
30223:   // Disconnects us from our parent, will call our GetParent().
30223:   nsBaseWidget::Destroy();
30223: 
30223:   // Release references to children, device context, toolkit, and app shell.
30223:   nsBaseWidget::OnDestroy();
30223:   
30223:   // Clear our native parent handle.
30223:   // XXX Windows will take care of this in the proper order, and SetParent(nsnull)'s
30223:   // remove child on the parent already took place in nsBaseWidget's Destroy call above.
30223:   //SetParent(nsnull);
30223: 
30223:   // We have to destroy the native drag target before we null out our window pointer.
 4186:   EnableDragDrop(PR_FALSE);
 4186: 
30223:   // If we're going away and for some reason we're still the rollup widget, rollup and
30223:   // turn off capture.
30223:   if ( this == sRollupWidget ) {
30223:     if ( sRollupListener )
30223:       sRollupListener->Rollup(nsnull, nsnull);
30223:     CaptureRollupEvents(nsnull, PR_FALSE, PR_TRUE);
30223:   }
30223: 
30223:   // If IME is disabled, restore it.
30223:   if (mOldIMC) {
30223:     mOldIMC = ::ImmAssociateContext(mWnd, mOldIMC);
30223:     NS_ASSERTION(!mOldIMC, "Another IMC was associated");
30223:   }
30223: 
30223:   // Turn off mouse trails if enabled.
30223:   MouseTrailer* mtrailer = nsToolkit::gMouseTrailer;
30223:   if (mtrailer) {
30223:     if (mtrailer->GetMouseTrailerWindow() == mWnd)
30223:       mtrailer->DestroyTimer();
30223: 
30223:     if (mtrailer->GetCaptureWindow() == mWnd)
30223:       mtrailer->SetCaptureWindow(nsnull);
30223:   }
30223: 
30223:   // If we were in the middle of deferred window positioning then free the memory for the
30223:   // multiple-window position structure.
30223:   if (mDeferredPositioner) {
30223:     VERIFY(::EndDeferWindowPos(mDeferredPositioner));
30223:     mDeferredPositioner = NULL;
30223:   }
30223: 
30223:   // Free GDI window class objects
    1:   if (mBrush) {
    1:     VERIFY(::DeleteObject(mBrush));
    1:     mBrush = NULL;
    1:   }
    1: 
30223:   // Free app icon resources.
30223:   HICON icon;
30223:   icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM) 0);
30223:   if (icon)
30223:     ::DestroyIcon(icon);
30223: 
30223:   icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM) 0);
30223:   if (icon)
30223:     ::DestroyIcon(icon);
30223: 
30223:   // Destroy any custom cursor resources.
30223:   if (mCursor == -1)
30223:     SetCursor(eCursor_standard);
30223: 
30223: #ifdef MOZ_XUL
30223:   // Reset transparency
30223:   if (eTransparencyTransparent == mTransparencyMode)
30223:     SetupTranslucentWindowMemoryBitmap(eTransparencyOpaque);
30223: #endif
30223: 
30223:   // Clear the main HWND.
30223:   mWnd = NULL;
    1: }
    1: 
29835: // OnMove
    1: PRBool nsWindow::OnMove(PRInt32 aX, PRInt32 aY)
    1: {
    1:   mBounds.x = aX;
    1:   mBounds.y = aY;
    1: 
    1:   nsGUIEvent event(PR_TRUE, NS_MOVE, this);
    1:   InitEvent(event);
    1:   event.refPoint.x = aX;
    1:   event.refPoint.y = aY;
    1: 
11297:   return DispatchWindowEvent(&event);
    1: }
    1: 
    1: // Send a resize message to the listener
23738: PRBool nsWindow::OnResize(nsIntRect &aWindowRect)
    1: {
    1:   // call the event callback
    1:   if (mEventCallback) {
    1:     nsSizeEvent event(PR_TRUE, NS_SIZE, this);
    1:     InitEvent(event);
    1:     event.windowSize = &aWindowRect;
    1:     RECT r;
    1:     if (::GetWindowRect(mWnd, &r)) {
    1:       event.mWinWidth  = PRInt32(r.right - r.left);
    1:       event.mWinHeight = PRInt32(r.bottom - r.top);
    1:     } else {
    1:       event.mWinWidth  = 0;
    1:       event.mWinHeight = 0;
    1:     }
11297:     return DispatchWindowEvent(&event);
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
29835: #if !defined(WINCE) // implemented in nsWindowCE.cpp
29835: PRBool nsWindow::OnHotKey(WPARAM wParam, LPARAM lParam)
29835: {
14640:   return PR_TRUE;
29835: }
29835: #endif // !defined(WINCE)
29835: 
29835: void nsWindow::OnSettingsChange(WPARAM wParam, LPARAM lParam)
29835: {
29835: #if defined(WINCE_WINDOWS_MOBILE)
29835:   if (wParam == SPI_SETSIPINFO) {
29835:     nsWindowCE::NotifySoftKbObservers();
29835:   }
    1: #endif
29835: 
29835:   nsWindowGfx::OnSettingsChangeGfx(wParam);
29835: }
29835: 
29835: // Deal with scrollbar messages (actually implemented only in nsScrollbar)
29835: PRBool nsWindow::OnScroll(UINT scrollCode, int cPos)
29835: {
29018:   return PR_FALSE;
29018: }
29018: 
29835: // Return the brush used to paint the background of this control
29835: HBRUSH nsWindow::OnControlColor()
29835: {
29835:   return mBrush;
29835: }
29835: 
29835: // Can be overriden. Controls auot-erase of background.
29835: PRBool nsWindow::AutoErase()
29835: {
    1:   return PR_FALSE;
    1: }
    1: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: IME management and accessibility
29835:  **
29835:  ** Handles managing IME input and accessibility.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
    1: NS_IMETHODIMP nsWindow::ResetInputState()
    1: {
    1: #ifdef DEBUG_KBSTATE
    1:   printf("ResetInputState\n");
    1: #endif
24836: 
24836: #ifdef NS_ENABLE_TSF
24836:   nsTextStore::CommitComposition(PR_FALSE);
24836: #endif //NS_ENABLE_TSF
24836: 
27961:   nsIMEContext IMEContext(mWnd);
27961:   if (IMEContext.IsValid()) {
27961:     ::ImmNotifyIME(IMEContext.get(), NI_COMPOSITIONSTR, CPS_COMPLETE, NULL);
27961:     ::ImmNotifyIME(IMEContext.get(), NI_COMPOSITIONSTR, CPS_CANCEL, NULL);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::SetIMEOpenState(PRBool aState)
    1: {
    1: #ifdef DEBUG_KBSTATE
    1:   printf("SetIMEOpenState %s\n", (aState ? "Open" : "Close"));
    1: #endif 
24836: 
24836: #ifdef NS_ENABLE_TSF
24836:   nsTextStore::SetIMEOpenState(aState);
24836: #endif //NS_ENABLE_TSF
24836: 
27961:   nsIMEContext IMEContext(mWnd);
27961:   if (IMEContext.IsValid()) {
27961:     ::ImmSetOpenStatus(IMEContext.get(), aState ? TRUE : FALSE);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::GetIMEOpenState(PRBool* aState)
    1: {
27961:   nsIMEContext IMEContext(mWnd);
27961:   if (IMEContext.IsValid()) {
27961:     BOOL isOpen = ::ImmGetOpenStatus(IMEContext.get());
    1:     *aState = isOpen ? PR_TRUE : PR_FALSE;
    1:   } else 
    1:     *aState = PR_FALSE;
24836: 
24836: #ifdef NS_ENABLE_TSF
24836:   *aState |= nsTextStore::GetIMEOpenState();
24836: #endif //NS_ENABLE_TSF
24836: 
    1:   return NS_OK;
    1: }
    1: 
  539: NS_IMETHODIMP nsWindow::SetIMEEnabled(PRUint32 aState)
    1: {
24836: #ifdef NS_ENABLE_TSF
24836:   nsTextStore::SetIMEEnabled(aState);
24836: #endif //NS_ENABLE_TSF
25278: #ifdef DEBUG_KBSTATE
25278:   printf("SetIMEEnabled: %s\n", (aState == nsIWidget::IME_STATUS_ENABLED ||
25278:                                  aState == nsIWidget::IME_STATUS_PLUGIN)? 
25278:                                 "Enabled": "Disabled");
25278: #endif 
27961:   if (nsIMM32Handler::IsComposing(this))
    1:     ResetInputState();
  539:   mIMEEnabled = aState;
22788:   PRBool enable = (aState == nsIWidget::IME_STATUS_ENABLED ||
22788:                    aState == nsIWidget::IME_STATUS_PLUGIN);
25278: 
25278: #if defined(WINCE_HAVE_SOFTKB)
29835:   sSoftKeyboardState = (aState != nsIWidget::IME_STATUS_DISABLED);
29835:   nsWindowCE::ToggleSoftKB(sSoftKeyboardState);
25278: #endif
25278: 
  539:   if (!enable != !mOldIMC)
    1:     return NS_OK;
  539:   mOldIMC = ::ImmAssociateContext(mWnd, enable ? mOldIMC : NULL);
  539:   NS_ASSERTION(!enable || !mOldIMC, "Another IMC was associated");
    1: 
    1:   return NS_OK;
    1: }
    1: 
  539: NS_IMETHODIMP nsWindow::GetIMEEnabled(PRUint32* aState)
  539: {
25278: #ifdef DEBUG_KBSTATE
25278:   printf("GetIMEEnabled: %s\n", mIMEEnabled? "Enabled": "Disabled");
25278: #endif 
  539:   *aState = mIMEEnabled;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::CancelIMEComposition()
    1: {
    1: #ifdef DEBUG_KBSTATE
    1:   printf("CancelIMEComposition\n");
    1: #endif 
24836: 
24836: #ifdef NS_ENABLE_TSF
24836:   nsTextStore::CommitComposition(PR_TRUE);
24836: #endif //NS_ENABLE_TSF
24836: 
27961:   nsIMEContext IMEContext(mWnd);
27961:   if (IMEContext.IsValid()) {
27961:     ::ImmNotifyIME(IMEContext.get(), NI_COMPOSITIONSTR, CPS_CANCEL, NULL);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
 2475: NS_IMETHODIMP
 2475: nsWindow::GetToggledKeyState(PRUint32 aKeyCode, PRBool* aLEDState)
 2475: {
 2475: #ifdef DEBUG_KBSTATE
 2475:   printf("GetToggledKeyState\n");
 2475: #endif 
 2475:   NS_ENSURE_ARG_POINTER(aLEDState);
 2475:   *aLEDState = (::GetKeyState(aKeyCode) & 1) != 0;
 2475:   return NS_OK;
 2475: }
    1: 
24836: #ifdef NS_ENABLE_TSF
24836: NS_IMETHODIMP
24836: nsWindow::OnIMEFocusChange(PRBool aFocus)
24836: {
27984:   nsresult rv = nsTextStore::OnFocusChange(aFocus, this, mIMEEnabled);
27984:   if (rv == NS_ERROR_NOT_AVAILABLE)
27984:     rv = NS_OK; // TSF is not enabled, maybe.
27984:   return rv;
24836: }
24836: 
24836: NS_IMETHODIMP
24836: nsWindow::OnIMETextChange(PRUint32 aStart,
24836:                           PRUint32 aOldEnd,
24836:                           PRUint32 aNewEnd)
24836: {
24836:   return nsTextStore::OnTextChange(aStart, aOldEnd, aNewEnd);
24836: }
24836: 
24836: NS_IMETHODIMP
24836: nsWindow::OnIMESelectionChange(void)
24836: {
24836:   return nsTextStore::OnSelectionChange();
24836: }
24836: #endif //NS_ENABLE_TSF
24836: 
    1: #ifdef ACCESSIBILITY
    1: already_AddRefed<nsIAccessible> nsWindow::GetRootAccessible()
    1: {
29835:   nsWindow::sIsAccessibilityOn = TRUE;
    1: 
30223:   if (mInDtor || mOnDestroyCalled || mWindowType == eWindowType_invisible) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsIAccessible *rootAccessible = nsnull;
    1: 
    1:   // If accessibility is turned on, we create this even before it is requested
    1:   // when the window gets focused. We need it to be created early so it can 
    1:   // generate accessibility events right away
    1:   nsWindow* accessibleWindow = nsnull;
    1:   if (mContentType != eContentTypeInherit) {
    1:     // We're on a MozillaContentWindowClass or MozillaUIWindowClass window.
    1:     // Search for the correct visible child window to get an accessible 
    1:     // document from. Make sure to use an active child window
    1:     HWND accessibleWnd = ::GetTopWindow(mWnd);
    1:     while (accessibleWnd) {
    1:       // Loop through windows and find the first one with accessibility info
    1:       accessibleWindow = GetNSWindowPtr(accessibleWnd);
    1:       if (accessibleWindow) {
    1:         accessibleWindow->DispatchAccessibleEvent(NS_GETACCESSIBLE, &rootAccessible);
    1:         if (rootAccessible) {
    1:           break;  // Success, one of the child windows was active
    1:         }
    1:       }
    1:       accessibleWnd = ::GetNextWindow(accessibleWnd, GW_HWNDNEXT);
    1:     }
    1:   }
    1:   else {
    1:     DispatchAccessibleEvent(NS_GETACCESSIBLE, &rootAccessible);
    1:   }
    1:   return rootAccessible;
    1: }
    1: 
29835: STDMETHODIMP_(LRESULT)
29835: nsWindow::LresultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN pAcc)
    1: {
    1:   // open the dll dynamically
29835:   if (!sAccLib)
29835:     sAccLib =::LoadLibraryW(L"OLEACC.DLL");
29835: 
29835:   if (sAccLib) {
29835:     if (!sLresultFromObject)
29835:       sLresultFromObject = (LPFNLRESULTFROMOBJECT)GetProcAddress(sAccLib,"LresultFromObject");
29835: 
29835:     if (sLresultFromObject)
29835:       return sLresultFromObject(riid,wParam,pAcc);
    1:   }
    1: 
    1:   return 0;
    1: }
    1: #endif
    1: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Transparency
29835:  **
29835:  ** Window transparency helpers.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
    1: #ifdef MOZ_XUL
    1: 
    1: void nsWindow::ResizeTranslucentWindow(PRInt32 aNewWidth, PRInt32 aNewHeight, PRBool force)
    1: {
    1:   if (!force && aNewWidth == mBounds.width && aNewHeight == mBounds.height)
    1:     return;
    1: 
 9499:   mTransparentSurface = new gfxWindowsSurface(gfxIntSize(aNewWidth, aNewHeight), gfxASurface::ImageFormatARGB32);
 9499:   mMemoryDC = mTransparentSurface->GetDC();
    1: }
    1: 
16601: void nsWindow::SetWindowTranslucencyInner(nsTransparencyMode aMode)
16601: {
19822: #ifndef WINCE
19822: 
16601:   if (aMode == mTransparencyMode)
16601:     return;
    1: 
    1:   HWND hWnd = GetTopLevelHWND(mWnd, PR_TRUE);
    1:   nsWindow* topWindow = GetNSWindowPtr(hWnd);
    1: 
    1:   if (!topWindow)
    1:   {
    1:     NS_WARNING("Trying to use transparent chrome in an embedded context");
16601:     return;
    1:   }
    1: 
25349:   LONG_PTR style = 0, exStyle = 0;
16601:   switch(aMode) {
16601:     case eTransparencyTransparent:
16601:       exStyle |= WS_EX_LAYERED;
16601:     case eTransparencyOpaque:
16601:     case eTransparencyGlass:
16601:       topWindow->mTransparencyMode = aMode;
16601:       break;
    1:   }
19222: 
19222:   style |= topWindow->WindowStyle();
19222:   exStyle |= topWindow->WindowExStyle();
19222: 
25427:   if (aMode == eTransparencyTransparent) {
25427:     style &= ~(WS_CAPTION | WS_THICKFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX);
25427:     exStyle &= ~(WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE | WS_EX_STATICEDGE);
25427:   }
25427: 
19016:   VERIFY_WINDOW_STYLE(style);
25349:   ::SetWindowLongPtrW(hWnd, GWL_STYLE, style);
25349:   ::SetWindowLongPtrW(hWnd, GWL_EXSTYLE, exStyle);
    1: 
16601:   mTransparencyMode = aMode;
16601: 
16601:   SetupTranslucentWindowMemoryBitmap(aMode);
16601:   MARGINS margins = { 0, 0, 0, 0 };
16601:   if(eTransparencyGlass == aMode)
16601:     margins.cxLeftWidth = -1;
16601:   if(nsUXThemeData::sHaveCompositor)
16601:     nsUXThemeData::dwmExtendFrameIntoClientAreaPtr(hWnd, &margins);
19822: #endif
16601: }
16601: 
16601: void nsWindow::SetupTranslucentWindowMemoryBitmap(nsTransparencyMode aMode)
16601: {
16601:   if (eTransparencyTransparent == aMode) {
    1:     ResizeTranslucentWindow(mBounds.width, mBounds.height, PR_TRUE);
    1:   } else {
 9499:     mTransparentSurface = nsnull;
    1:     mMemoryDC = NULL;
    1:   }
    1: }
    1: 
    1: nsresult nsWindow::UpdateTranslucentWindow()
    1: {
19822: #ifndef WINCE
    1:   if (mBounds.IsEmpty())
    1:     return NS_OK;
    1: 
    1:   ::GdiFlush();
    1: 
    1:   BLENDFUNCTION bf = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
    1:   SIZE winSize = { mBounds.width, mBounds.height };
    1:   POINT srcPos = { 0, 0 };
    1:   HWND hWnd = GetTopLevelHWND(mWnd, PR_TRUE);
    1:   RECT winRect;
    1:   ::GetWindowRect(hWnd, &winRect);
    1: 
    1:   // perform the alpha blend
 5223:   if (!::UpdateLayeredWindow(hWnd, NULL, (POINT*)&winRect, &winSize, mMemoryDC, &srcPos, 0, &bf, ULW_ALPHA))
 5223:     return NS_ERROR_FAILURE;
19822: #endif
 5223: 
 5223:   return NS_OK;
 5223: }
 5223: 
19822: #endif //MOZ_XUL
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Popup rollup hooks
29835:  **
29835:  ** Deals with CaptureRollup on popup windows.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: #ifndef WINCE
29835: // Schedules a timer for a window, so we can rollup after processing the hook event
29835: void nsWindow::ScheduleHookTimer(HWND aWnd, UINT aMsgId)
29835: {
29835:   // In some cases multiple hooks may be scheduled
29835:   // so ignore any other requests once one timer is scheduled
29835:   if (sHookTimerId == 0) {
29835:     // Remember the window handle and the message ID to be used later
29835:     sRollupMsgId = aMsgId;
29835:     sRollupMsgWnd = aWnd;
29835:     // Schedule native timer for doing the rollup after
29835:     // this event is done being processed
29835:     sHookTimerId = ::SetTimer(NULL, 0, 0, (TIMERPROC)HookTimerForPopups);
29835:     NS_ASSERTION(sHookTimerId, "Timer couldn't be created.");
29835:   }
29835: }
29835: 
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835: int gLastMsgCode = 0;
29835: extern MSGFEventMsgInfo gMSGFEvents[];
29835: #endif
29835: 
29835: // Process Menu messages, rollup when popup is clicked.
29835: LRESULT CALLBACK nsWindow::MozSpecialMsgFilter(int code, WPARAM wParam, LPARAM lParam)
29835: {
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835:   if (sProcessHook) {
29835:     MSG* pMsg = (MSG*)lParam;
29835: 
29835:     int inx = 0;
29835:     while (gMSGFEvents[inx].mId != code && gMSGFEvents[inx].mStr != NULL) {
29835:       inx++;
29835:     }
29835:     if (code != gLastMsgCode) {
29835:       if (gMSGFEvents[inx].mId == code) {
29835: #ifdef DEBUG
29835:         printf("MozSpecialMessageProc - code: 0x%X  - %s  hw: %p\n", code, gMSGFEvents[inx].mStr, pMsg->hwnd);
29835: #endif
29835:       } else {
29835: #ifdef DEBUG
29835:         printf("MozSpecialMessageProc - code: 0x%X  - %d  hw: %p\n", code, gMSGFEvents[inx].mId, pMsg->hwnd);
29835: #endif
29835:       }
29835:       gLastMsgCode = code;
29835:     }
29835:     PrintEvent(pMsg->message, FALSE, FALSE);
29835:   }
29835: #endif // #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835: 
29835:   if (sProcessHook && code == MSGF_MENU) {
29835:     MSG* pMsg = (MSG*)lParam;
29835:     ScheduleHookTimer( pMsg->hwnd, pMsg->message);
29835:   }
29835: 
29835:   return ::CallNextHookEx(sMsgFilterHook, code, wParam, lParam);
29835: }
29835: 
29835: // Process all mouse messages. Roll up when a click is in a native window
29835: // that doesn't have an nsIWidget.
29835: LRESULT CALLBACK nsWindow::MozSpecialMouseProc(int code, WPARAM wParam, LPARAM lParam)
29835: {
29835:   if (sProcessHook) {
29835:     switch (wParam) {
29835:       case WM_LBUTTONDOWN:
29835:       case WM_RBUTTONDOWN:
29835:       case WM_MBUTTONDOWN:
29835:       case WM_MOUSEWHEEL:
29835:       case WM_MOUSEHWHEEL:
29835:       {
29835:         MOUSEHOOKSTRUCT* ms = (MOUSEHOOKSTRUCT*)lParam;
29835:         nsIWidget* mozWin = (nsIWidget*)GetNSWindowPtr(ms->hwnd);
29835:         if (mozWin) {
29835:           // If this window is windowed plugin window, the mouse events are not
29835:           // sent to us.
29835:           if (static_cast<nsWindow*>(mozWin)->mIsPluginWindow)
29835:             ScheduleHookTimer(ms->hwnd, (UINT)wParam);
29835:         } else {
29835:           ScheduleHookTimer(ms->hwnd, (UINT)wParam);
29835:         }
29835:         break;
29835:       }
29835:     }
29835:   }
29835:   return ::CallNextHookEx(sCallMouseHook, code, wParam, lParam);
29835: }
29835: 
29835: // Process all messages. Roll up when the window is moving, or
29835: // is resizing or when maximized or mininized.
29835: LRESULT CALLBACK nsWindow::MozSpecialWndProc(int code, WPARAM wParam, LPARAM lParam)
29835: {
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835:   if (sProcessHook) {
29835:     CWPSTRUCT* cwpt = (CWPSTRUCT*)lParam;
29835:     PrintEvent(cwpt->message, FALSE, FALSE);
29835:   }
29835: #endif
29835: 
29835:   if (sProcessHook) {
29835:     CWPSTRUCT* cwpt = (CWPSTRUCT*)lParam;
29835:     if (cwpt->message == WM_MOVING ||
29835:         cwpt->message == WM_SIZING ||
29835:         cwpt->message == WM_GETMINMAXINFO) {
29835:       ScheduleHookTimer(cwpt->hwnd, (UINT)cwpt->message);
29835:     }
29835:   }
29835: 
29835:   return ::CallNextHookEx(sCallProcHook, code, wParam, lParam);
29835: }
29835: 
29835: // Register the special "hooks" for dropdown processing.
29835: void nsWindow::RegisterSpecialDropdownHooks()
29835: {
29835:   NS_ASSERTION(!sMsgFilterHook, "sMsgFilterHook must be NULL!");
29835:   NS_ASSERTION(!sCallProcHook,  "sCallProcHook must be NULL!");
29835: 
29835:   DISPLAY_NMM_PRT("***************** Installing Msg Hooks ***************\n");
29835: 
29835:   //HMODULE hMod = GetModuleHandle("gkwidget.dll");
29835: 
29835:   // Install msg hook for moving the window and resizing
29835:   if (!sMsgFilterHook) {
29835:     DISPLAY_NMM_PRT("***** Hooking sMsgFilterHook!\n");
29835:     sMsgFilterHook = SetWindowsHookEx(WH_MSGFILTER, MozSpecialMsgFilter, NULL, GetCurrentThreadId());
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835:     if (!sMsgFilterHook) {
29835:       printf("***** SetWindowsHookEx is NOT installed for WH_MSGFILTER!\n");
29835:     }
29835: #endif
29835:   }
29835: 
29835:   // Install msg hook for menus
29835:   if (!sCallProcHook) {
29835:     DISPLAY_NMM_PRT("***** Hooking sCallProcHook!\n");
29835:     sCallProcHook  = SetWindowsHookEx(WH_CALLWNDPROC, MozSpecialWndProc, NULL, GetCurrentThreadId());
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835:     if (!sCallProcHook) {
29835:       printf("***** SetWindowsHookEx is NOT installed for WH_CALLWNDPROC!\n");
29835:     }
29835: #endif
29835:   }
29835: 
29835:   // Install msg hook for the mouse
29835:   if (!sCallMouseHook) {
29835:     DISPLAY_NMM_PRT("***** Hooking sCallMouseHook!\n");
29835:     sCallMouseHook  = SetWindowsHookEx(WH_MOUSE, MozSpecialMouseProc, NULL, GetCurrentThreadId());
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835:     if (!sCallMouseHook) {
29835:       printf("***** SetWindowsHookEx is NOT installed for WH_MOUSE!\n");
29835:     }
29835: #endif
29835:   }
29835: }
29835: 
29835: // Unhook special message hooks for dropdowns.
29835: void nsWindow::UnregisterSpecialDropdownHooks()
29835: {
29835:   DISPLAY_NMM_PRT("***************** De-installing Msg Hooks ***************\n");
29835: 
29835:   if (sCallProcHook) {
29835:     DISPLAY_NMM_PRT("***** Unhooking sCallProcHook!\n");
29835:     if (!::UnhookWindowsHookEx(sCallProcHook)) {
29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sCallProcHook!\n");
29835:     }
29835:     sCallProcHook = NULL;
29835:   }
29835: 
29835:   if (sMsgFilterHook) {
29835:     DISPLAY_NMM_PRT("***** Unhooking sMsgFilterHook!\n");
29835:     if (!::UnhookWindowsHookEx(sMsgFilterHook)) {
29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sMsgFilterHook!\n");
29835:     }
29835:     sMsgFilterHook = NULL;
29835:   }
29835: 
29835:   if (sCallMouseHook) {
29835:     DISPLAY_NMM_PRT("***** Unhooking sCallMouseHook!\n");
29835:     if (!::UnhookWindowsHookEx(sCallMouseHook)) {
29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sCallMouseHook!\n");
29835:     }
29835:     sCallMouseHook = NULL;
29835:   }
29835: }
29835: 
29835: // This timer is designed to only fire one time at most each time a "hook" function
29835: // is used to rollup the dropdown. In some cases, the timer may be scheduled from the
29835: // hook, but that hook event or a subsequent event may roll up the dropdown before
29835: // this timer function is executed.
29835: //
29835: // For example, if an MFC control takes focus, the combobox will lose focus and rollup
29835: // before this function fires.
29835: VOID CALLBACK nsWindow::HookTimerForPopups(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
29835: {
29835:   if (sHookTimerId != 0) {
29835:     // if the window is NULL then we need to use the ID to kill the timer
29835:     BOOL status = ::KillTimer(NULL, sHookTimerId);
29835:     NS_ASSERTION(status, "Hook Timer was not killed.");
29835:     sHookTimerId = 0;
29835:   }
29835: 
29835:   if (sRollupMsgId != 0) {
29835:     // Note: DealWithPopups does the check to make sure that
29835:     // sRollupListener and sRollupWidget are not NULL
29835:     LRESULT popupHandlingResult;
29835:     nsAutoRollup autoRollup;
29835:     DealWithPopups(sRollupMsgWnd, sRollupMsgId, 0, 0, &popupHandlingResult);
29835:     sRollupMsgId = 0;
29835:     sRollupMsgWnd = NULL;
29835:   }
29835: }
29835: #endif // WinCE
29835: 
29835: static PRBool IsDifferentThreadWindow(HWND aWnd)
29835: {
29835:   return ::GetCurrentThreadId() != ::GetWindowThreadProcessId(aWnd, NULL);
29835: }
29835: 
29835: PRBool
29835: nsWindow::EventIsInsideWindow(UINT Msg, nsWindow* aWindow)
29835: {
29835:   RECT r;
29835: 
29835: #ifndef WINCE
29835:   if (Msg == WM_ACTIVATEAPP)
29835:     // don't care about activation/deactivation
29835:     return PR_FALSE;
29835: #else
29835:   if (Msg == WM_ACTIVATE)
29835:     // but on Windows CE we do care about
29835:     // activation/deactivation because there doesn't exist
29835:     // cancelable Mouse Activation events
29835:     return PR_TRUE;
29835: #endif
29835: 
29835:   ::GetWindowRect(aWindow->mWnd, &r);
29835:   DWORD pos = ::GetMessagePos();
29835:   POINT mp;
29835:   mp.x = GET_X_LPARAM(pos);
29835:   mp.y = GET_Y_LPARAM(pos);
29835: 
29835:   // was the event inside this window?
29835:   return (PRBool) PtInRect(&r, mp);
29835: }
29835: 
29835: // Handle events that may cause a popup (combobox, XPMenu, etc) to need to rollup.
29835: BOOL
29835: nsWindow::DealWithPopups(HWND inWnd, UINT inMsg, WPARAM inWParam, LPARAM inLParam, LRESULT* outResult)
29835: {
29835:   if (sRollupListener && sRollupWidget && ::IsWindowVisible(inWnd)) {
29835: 
29835:     if (inMsg == WM_LBUTTONDOWN || inMsg == WM_RBUTTONDOWN || inMsg == WM_MBUTTONDOWN ||
29835:         inMsg == WM_MOUSEWHEEL || inMsg == WM_MOUSEHWHEEL || inMsg == WM_ACTIVATE ||
29835:         (inMsg == WM_KILLFOCUS && IsDifferentThreadWindow((HWND)inWParam))
29835: #ifndef WINCE
29835:         ||
29835:         inMsg == WM_NCRBUTTONDOWN ||
29835:         inMsg == WM_MOVING ||
29835:         inMsg == WM_SIZING ||
29835:         inMsg == WM_NCLBUTTONDOWN ||
29835:         inMsg == WM_NCMBUTTONDOWN ||
29835:         inMsg == WM_MOUSEACTIVATE ||
29835:         inMsg == WM_ACTIVATEAPP ||
29835:         inMsg == WM_MENUSELECT
29835: #endif
29835:         )
29835:     {
29835:       // Rollup if the event is outside the popup.
29835:       PRBool rollup = !nsWindow::EventIsInsideWindow(inMsg, (nsWindow*)sRollupWidget);
29835: 
29835:       if (rollup && (inMsg == WM_MOUSEWHEEL || inMsg == WM_MOUSEHWHEEL))
29835:       {
29835:         sRollupListener->ShouldRollupOnMouseWheelEvent(&rollup);
29835:         *outResult = PR_TRUE;
29835:       }
29835: 
29835:       // If we're dealing with menus, we probably have submenus and we don't
29835:       // want to rollup if the click is in a parent menu of the current submenu.
29835:       PRUint32 popupsToRollup = PR_UINT32_MAX;
29835:       if (rollup) {
29835:         nsCOMPtr<nsIMenuRollup> menuRollup ( do_QueryInterface(sRollupListener) );
29835:         if ( menuRollup ) {
29835:           nsAutoTArray<nsIWidget*, 5> widgetChain;
29835:           PRUint32 sameTypeCount = menuRollup->GetSubmenuWidgetChain(&widgetChain);
29835:           for ( PRUint32 i = 0; i < widgetChain.Length(); ++i ) {
29835:             nsIWidget* widget = widgetChain[i];
29835:             if ( nsWindow::EventIsInsideWindow(inMsg, (nsWindow*)widget) ) {
29835:               // don't roll up if the mouse event occured within a menu of the
29835:               // same type. If the mouse event occured in a menu higher than
29835:               // that, roll up, but pass the number of popups to Rollup so
29835:               // that only those of the same type close up.
29835:               if (i < sameTypeCount) {
29835:                 rollup = PR_FALSE;
29835:               }
29835:               else {
29835:                 popupsToRollup = sameTypeCount;
29835:               }
29835:               break;
29835:             }
29835:           } // foreach parent menu widget
29835:         } // if rollup listener knows about menus
29835:       }
29835: 
29835: #ifndef WINCE
29835:       if (inMsg == WM_MOUSEACTIVATE && popupsToRollup == PR_UINT32_MAX) {
29835:         // Prevent the click inside the popup from causing a change in window
29835:         // activation. Since the popup is shown non-activated, we need to eat
29835:         // any requests to activate the window while it is displayed. Windows
29835:         // will automatically activate the popup on the mousedown otherwise.
29835:         if (!rollup) {
29835:           *outResult = MA_NOACTIVATE;
29835:           return TRUE;
29835:         }
29835:         else
29835:         {
29835:           UINT uMsg = HIWORD(inLParam);
29835:           if (uMsg == WM_MOUSEMOVE)
29835:           {
29835:             // WM_MOUSEACTIVATE cause by moving the mouse - X-mouse (eg. TweakUI)
29835:             // must be enabled in Windows.
29835:             sRollupListener->ShouldRollupOnMouseActivate(&rollup);
29835:             if (!rollup)
29835:             {
29835:               *outResult = MA_NOACTIVATE;
29835:               return true;
29835:             }
29835:           }
29835:         }
29835:       }
29835:       // if we've still determined that we should still rollup everything, do it.
29835:       else
29835: #endif
29835:       if ( rollup ) {
29835:         // sRollupConsumeEvent may be modified by
29835:         // nsIRollupListener::Rollup.
29835:         PRBool consumeRollupEvent = sRollupConsumeEvent;
29835:         // only need to deal with the last rollup for left mouse down events.
29835:         sRollupListener->Rollup(popupsToRollup, inMsg == WM_LBUTTONDOWN ? &mLastRollup : nsnull);
29835: 
29835:         // Tell hook to stop processing messages
29835:         sProcessHook = PR_FALSE;
29835:         sRollupMsgId = 0;
29835:         sRollupMsgWnd = NULL;
29835: 
29835:         // return TRUE tells Windows that the event is consumed,
29835:         // false allows the event to be dispatched
29835:         //
29835:         // So if we are NOT supposed to be consuming events, let it go through
29835:         if (consumeRollupEvent && inMsg != WM_RBUTTONDOWN) {
29835:           *outResult = TRUE;
29835:           return TRUE;
29835:         }
29835: #ifndef WINCE
29835:         // if we are only rolling up some popups, don't activate and don't let
29835:         // the event go through. This prevents clicks menus higher in the
29835:         // chain from opening when a context menu is open
29835:         if (popupsToRollup != PR_UINT32_MAX && inMsg == WM_MOUSEACTIVATE) {
29835:           *outResult = MA_NOACTIVATEANDEAT;
29835:           return TRUE;
29835:         }
29835: #endif
29835:       }
29835:     } // if event that might trigger a popup to rollup
29835:   } // if rollup listeners registered
29835: 
29835:   return FALSE;
29835: }
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Misc. utility methods and functions.
29835:  **
29835:  ** General use.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: // nsModifierKeyState used in various character processing. 
29835: nsModifierKeyState::nsModifierKeyState()
29835: {
29835:   mIsShiftDown   = IS_VK_DOWN(NS_VK_SHIFT);
29835:   mIsControlDown = IS_VK_DOWN(NS_VK_CONTROL);
29835:   mIsAltDown     = IS_VK_DOWN(NS_VK_ALT);
29835: }
29835: 
29835: 
29835: PRInt32 nsWindow::GetWindowsVersion()
29835: {
29835: #ifdef WINCE
29835:   return 0x500;
29835: #else
29835:   static PRInt32 version = 0;
29835:   static PRBool didCheck = PR_FALSE;
29835: 
29835:   if (!didCheck)
29835:   {
29835:     didCheck = PR_TRUE;
29835:     OSVERSIONINFOEX osInfo;
29835:     osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
29835:     // This cast is safe and supposed to be here, don't worry
29835:     ::GetVersionEx((OSVERSIONINFO*)&osInfo);
29835:     version = (osInfo.dwMajorVersion & 0xff) << 8 | (osInfo.dwMinorVersion & 0xff);
29835:   }
29835:   return version;
29835: #endif
29835: }
29835: 
29835: // Note that the result of GetTopLevelWindow method can be different from the
29835: // result of GetTopLevelHWND method.  The result can be non-floating window.
29835: // Because our top level window may be contained in another window which is
29835: // not managed by us.
29835: nsWindow* nsWindow::GetTopLevelWindow(PRBool aStopOnDialogOrPopup)
29835: {
29835:   nsWindow* curWindow = this;
29835: 
29835:   while (PR_TRUE) {
29835:     if (aStopOnDialogOrPopup) {
29835:       switch (curWindow->mWindowType) {
29835:         case eWindowType_dialog:
29835:         case eWindowType_popup:
29835:           return curWindow;
29835:       }
29835:     }
29835: 
29835:     // Retrieve the top level parent or owner window
29835:     nsWindow* parentWindow = curWindow->GetParentWindow(PR_TRUE);
29835: 
29835:     if (!parentWindow)
29835:       return curWindow;
29835: 
29835:     curWindow = parentWindow;
29835:   }
29835: }
29835: 
29835: // Note that the result of GetTopLevelHWND can be different from the result
29835: // of GetTopLevelWindow method.  Because this is checking whether the window
29835: // is top level only in Win32 window system.  Therefore, the result window
29835: // may not be managed by us.
29835: HWND nsWindow::GetTopLevelHWND(HWND aWnd, PRBool aStopOnDialogOrPopup)
29835: {
29835:   HWND curWnd = aWnd;
29835:   HWND topWnd = NULL;
30088:   HWND upWnd = NULL;
29835: 
29835:   while (curWnd) {
29835:     topWnd = curWnd;
29835: 
29835:     if (aStopOnDialogOrPopup) {
29835:       DWORD_PTR style = ::GetWindowLongPtrW(curWnd, GWL_STYLE);
29835: 
29835:       VERIFY_WINDOW_STYLE(style);
29835: 
29835:       if (!(style & WS_CHILD)) // first top-level window
29835:         break;
29835:     }
29835: 
30088:     upWnd = ::GetParent(curWnd); // Parent or owner (if has no parent)
30088: 
30088: #ifdef WINCE
30088:     // For dialog windows, we want just the parent, not the owner.
30088:     // For other/popup windows, we want to find the first owner/parent
30088:     // that's a dialog and/or has an owner.
30088:     if (upWnd && ::GetWindow(curWnd, GW_OWNER) == upWnd) {
30088:       DWORD_PTR style = ::GetWindowLongPtrW(curWnd, GWL_STYLE);
30088:       if ((style & WS_DLGFRAME) != 0)
30088:         break;
30088:     }
30088: #endif
30088: 
30088:     curWnd = upWnd;
29835:   }
29835: 
29835:   return topWnd;
29835: }
29835: 
29835: static BOOL CALLBACK gEnumWindowsProc(HWND hwnd, LPARAM lParam)
29835: {
29835:   DWORD pid;
29835:   ::GetWindowThreadProcessId(hwnd, &pid);
29835:   if (pid == GetCurrentProcessId() && ::IsWindowVisible(hwnd))
29835:   {
29835:     gWindowsVisible = PR_TRUE;
29835:     return FALSE;
29835:   }
29835:   return TRUE;
29835: }
29835: 
29835: PRBool nsWindow::CanTakeFocus()
29835: {
29835:   gWindowsVisible = PR_FALSE;
29835:   EnumWindows(gEnumWindowsProc, 0);
29835:   if (!gWindowsVisible) {
29835:     return PR_TRUE;
29835:   } else {
29835:     HWND fgWnd = ::GetForegroundWindow();
29835:     if (!fgWnd) {
29835:       return PR_TRUE;
29835:     }
29835:     DWORD pid;
29835:     GetWindowThreadProcessId(fgWnd, &pid);
29835:     if (pid == GetCurrentProcessId()) {
29835:       return PR_TRUE;
29835:     }
29835:   }
29835:   return PR_FALSE;
29835: }
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: ChildWindow impl.
29835:  **
29835:  ** Child window overrides.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: // Deal with all sort of mouse event
29835: PRBool ChildWindow::DispatchMouseEvent(PRUint32 aEventType, WPARAM wParam, LPARAM lParam,
29835:                                        PRBool aIsContextMenuKey, PRInt16 aButton)
29835: {
29835:   PRBool result = PR_FALSE;
29835: 
29835:   if (nsnull == mEventCallback) {
29835:     return result;
29835:   }
29835: 
29835:   switch (aEventType) {
29835:     case NS_MOUSE_BUTTON_DOWN:
29835:       CaptureMouse(PR_TRUE);
29835:       break;
29835: 
29835:     // NS_MOUSE_MOVE and NS_MOUSE_EXIT are here because we need to make sure capture flag
29835:     // isn't left on after a drag where we wouldn't see a button up message (see bug 324131).
29835:     case NS_MOUSE_BUTTON_UP:
29835:     case NS_MOUSE_MOVE:
29835:     case NS_MOUSE_EXIT:
29835:       if (!(wParam & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON)) && mIsInMouseCapture)
29835:         CaptureMouse(PR_FALSE);
29835:       break;
29835: 
29835:     default:
29835:       break;
29835: 
29835:   } // switch
29835: 
29835:   return nsWindow::DispatchMouseEvent(aEventType, wParam, lParam,
29835:                                       aIsContextMenuKey, aButton);
29835: }
29835: 
29835: // return the style for a child nsWindow
29835: DWORD ChildWindow::WindowStyle()
29835: {
29835:   DWORD style = WS_CLIPCHILDREN | nsWindow::WindowStyle();
29835:   if (!(style & WS_POPUP))
29835:     style |= WS_CHILD; // WS_POPUP and WS_CHILD are mutually exclusive.
29835:   VERIFY_WINDOW_STYLE(style);
29835:   return style;
30075: }
