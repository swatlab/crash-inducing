    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * vim:set ts=2 sts=2 sw=2 et cin:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org Code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Scott MacGregor <mscott@netscape.com>
 1859:  *   Dan Mosedale <dmose@mozilla.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsIURI.h"
    1: #include "nsIURL.h"
    1: #include "nsExternalProtocolHandler.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsServiceManagerUtils.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrompt.h"
    1: #include "nsNetUtil.h"
 1859: #include "nsExternalHelperAppService.h"
    1: 
    1: // used to dispatch urls to default protocol handlers
    1: #include "nsCExternalHandlerService.h"
    1: #include "nsIExternalProtocolService.h"
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: // a stub channel implemenation which will map calls to AsyncRead and OpenInputStream
    1: // to calls in the OS for loading the url.
    1: ////////////////////////////////////////////////////////////////////////
    1: 
    1: class nsExtProtocolChannel : public nsIChannel
    1: {
    1: public:
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSICHANNEL
    1:     NS_DECL_NSIREQUEST
    1: 
    1:     nsExtProtocolChannel();
    1:     virtual ~nsExtProtocolChannel();
    1: 
    1:     nsresult SetURI(nsIURI*);
    1: 
    1: private:
    1:     nsresult OpenURL();
 3161:     void Finish(nsresult aResult);
    1:     
    1:     nsCOMPtr<nsIURI> mUrl;
    1:     nsCOMPtr<nsIURI> mOriginalURI;
    1:     nsresult mStatus;
 1859:     nsLoadFlags mLoadFlags;
79445:     bool mWasOpened;
    1:     
    1:     nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
    1:     nsCOMPtr<nsILoadGroup> mLoadGroup;
    1: };
    1: 
    1: NS_IMPL_THREADSAFE_ADDREF(nsExtProtocolChannel)
    1: NS_IMPL_THREADSAFE_RELEASE(nsExtProtocolChannel)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsExtProtocolChannel)
    1:    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIChannel)
    1:    NS_INTERFACE_MAP_ENTRY(nsIChannel)
    1:    NS_INTERFACE_MAP_ENTRY(nsIRequest)
    1: NS_INTERFACE_MAP_END_THREADSAFE
    1: 
 3161: nsExtProtocolChannel::nsExtProtocolChannel() : mStatus(NS_OK), 
80486:                                                mWasOpened(false)
    1: {
    1: }
    1: 
    1: nsExtProtocolChannel::~nsExtProtocolChannel()
    1: {}
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::GetLoadGroup(nsILoadGroup * *aLoadGroup)
    1: {
    1:   NS_IF_ADDREF(*aLoadGroup = mLoadGroup);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::SetLoadGroup(nsILoadGroup * aLoadGroup)
    1: {
    1:   mLoadGroup = aLoadGroup;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::GetNotificationCallbacks(nsIInterfaceRequestor* *aCallbacks)
    1: {
    1:   NS_IF_ADDREF(*aCallbacks = mCallbacks);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::SetNotificationCallbacks(nsIInterfaceRequestor* aCallbacks)
    1: {
    1:   mCallbacks = aCallbacks;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsExtProtocolChannel::GetSecurityInfo(nsISupports * *aSecurityInfo)
    1: {
    1:   *aSecurityInfo = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::GetOriginalURI(nsIURI* *aURI)
    1: {
20508:   NS_ADDREF(*aURI = mOriginalURI);
    1:   return NS_OK; 
    1: }
    1:  
    1: NS_IMETHODIMP nsExtProtocolChannel::SetOriginalURI(nsIURI* aURI)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aURI);
    1:   mOriginalURI = aURI;
    1:   return NS_OK;
    1: }
    1:  
    1: NS_IMETHODIMP nsExtProtocolChannel::GetURI(nsIURI* *aURI)
    1: {
    1:   *aURI = mUrl;
    1:   NS_IF_ADDREF(*aURI);
    1:   return NS_OK; 
    1: }
    1:  
    1: nsresult nsExtProtocolChannel::SetURI(nsIURI* aURI)
    1: {
    1:   mUrl = aURI;
    1:   return NS_OK; 
    1: }
    1: 
    1: nsresult nsExtProtocolChannel::OpenURL()
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   nsCOMPtr<nsIExternalProtocolService> extProtService (do_GetService(NS_EXTERNALPROTOCOLSERVICE_CONTRACTID));
    1: 
    1:   if (extProtService)
    1:   {
    1: #ifdef DEBUG
    1:     nsCAutoString urlScheme;
    1:     mUrl->GetScheme(urlScheme);
79445:     bool haveHandler = false;
    1:     extProtService->ExternalProtocolHandlerExists(urlScheme.get(), &haveHandler);
    1:     NS_ASSERTION(haveHandler, "Why do we have a channel for this url if we don't support the protocol?");
    1: #endif
    1: 
 5588:     nsCOMPtr<nsIInterfaceRequestor> aggCallbacks;
 5588:     rv = NS_NewNotificationCallbacksAggregation(mCallbacks, mLoadGroup,
 5588:                                                 getter_AddRefs(aggCallbacks));
 5588:     if (NS_FAILED(rv)) {
 5588:       goto finish;
    1:     }
    1:                                                 
 5588:     rv = extProtService->LoadURI(mUrl, aggCallbacks);
 5588:     if (NS_SUCCEEDED(rv)) {
 5588:         // despite success, we need to abort this channel, at the very least 
 5588:         // to make it clear to the caller that no on{Start,Stop}Request
 5588:         // should be expected.
 5588:         rv = NS_ERROR_NO_CONTENT;
 5588:     }
 5588:   }
 5588: 
 5588: finish:
    1:   mCallbacks = 0;
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::Open(nsIInputStream **_retval)
    1: {
 5588:   return OpenURL();
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::AsyncOpen(nsIStreamListener *listener, nsISupports *ctxt)
    1: {
 3161:   NS_ENSURE_ARG_POINTER(listener);
 3161:   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
 3161: 
80486:   mWasOpened = true;
 3161: 
 5588:   return OpenURL();
 3161: }
 3161: 
    1: NS_IMETHODIMP nsExtProtocolChannel::GetLoadFlags(nsLoadFlags *aLoadFlags)
    1: {
 1859:   *aLoadFlags = mLoadFlags;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::SetLoadFlags(nsLoadFlags aLoadFlags)
    1: {
 1859:   mLoadFlags = aLoadFlags;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::GetContentType(nsACString &aContentType)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::SetContentType(const nsACString &aContentType)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::GetContentCharset(nsACString &aContentCharset)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::SetContentCharset(const nsACString &aContentCharset)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
78165: NS_IMETHODIMP nsExtProtocolChannel::GetContentDisposition(PRUint32 *aContentDisposition)
78165: {
78165:   return NS_ERROR_NOT_AVAILABLE;
78165: }
78165: 
78165: NS_IMETHODIMP nsExtProtocolChannel::GetContentDispositionFilename(nsAString &aContentDispositionFilename)
78165: {
78165:   return NS_ERROR_NOT_AVAILABLE;
78165: }
78165: 
78165: NS_IMETHODIMP nsExtProtocolChannel::GetContentDispositionHeader(nsACString &aContentDispositionHeader)
78165: {
78165:   return NS_ERROR_NOT_AVAILABLE;
78165: }
78165: 
51740: NS_IMETHODIMP nsExtProtocolChannel::GetContentLength(PRInt32 * aContentLength)
    1: {
    1:   *aContentLength = -1;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
51740: nsExtProtocolChannel::SetContentLength(PRInt32 aContentLength)
    1: {
    1:   NS_NOTREACHED("SetContentLength");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::GetOwner(nsISupports * *aPrincipal)
    1: {
    1:   NS_NOTREACHED("GetOwner");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::SetOwner(nsISupports * aPrincipal)
    1: {
    1:   NS_NOTREACHED("SetOwner");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: // From nsIRequest
    1: ////////////////////////////////////////////////////////////////////////////////
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::GetName(nsACString &result)
    1: {
 1859:   return mUrl->GetSpec(result);
    1: }
    1: 
79445: NS_IMETHODIMP nsExtProtocolChannel::IsPending(bool *result)
    1: {
80486:   *result = false;
    1:   return NS_OK; 
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::GetStatus(nsresult *status)
    1: {
    1:   *status = mStatus;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::Cancel(nsresult status)
    1: {
    1:   mStatus = status;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::Suspend()
    1: {
    1:   NS_NOTREACHED("Suspend");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP nsExtProtocolChannel::Resume()
    1: {
    1:   NS_NOTREACHED("Resume");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////
    1: // the default protocol handler implementation
    1: //////////////////////////////////////////////////////////////////////
    1: 
    1: nsExternalProtocolHandler::nsExternalProtocolHandler()
    1: {
    1:   m_schemeName = "default";
    1: }
    1: 
    1: 
    1: nsExternalProtocolHandler::~nsExternalProtocolHandler()
    1: {}
    1: 
    1: NS_IMPL_THREADSAFE_ADDREF(nsExternalProtocolHandler)
    1: NS_IMPL_THREADSAFE_RELEASE(nsExternalProtocolHandler)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsExternalProtocolHandler)
    1:    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIProtocolHandler)
    1:    NS_INTERFACE_MAP_ENTRY(nsIProtocolHandler)
    1:    NS_INTERFACE_MAP_ENTRY(nsIExternalProtocolHandler)
    1:    NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1: NS_INTERFACE_MAP_END_THREADSAFE
    1: 
    1: NS_IMETHODIMP nsExternalProtocolHandler::GetScheme(nsACString &aScheme)
    1: {
    1:   aScheme = m_schemeName;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalProtocolHandler::GetDefaultPort(PRInt32 *aDefaultPort)
    1: {
    1:   *aDefaultPort = 0;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
79445: nsExternalProtocolHandler::AllowPort(PRInt32 port, const char *scheme, bool *_retval)
    1: {
    1:     // don't override anything.  
80486:     *_retval = false;
    1:     return NS_OK;
    1: }
    1: // returns TRUE if the OS can handle this protocol scheme and false otherwise.
79445: bool nsExternalProtocolHandler::HaveExternalProtocolHandler(nsIURI * aURI)
    1: {
79445:   bool haveHandler = false;
    1:   if (aURI)
    1:   {
    1:     nsCAutoString scheme;
    1:     aURI->GetScheme(scheme);
87393:     nsCOMPtr<nsIExternalProtocolService> extProtSvc(do_GetService(NS_EXTERNALPROTOCOLSERVICE_CONTRACTID));
87393:     if (extProtSvc)
87393:       extProtSvc->ExternalProtocolHandlerExists(scheme.get(), &haveHandler);
    1:   }
    1: 
    1:   return haveHandler;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalProtocolHandler::GetProtocolFlags(PRUint32 *aUritype)
    1: {
    1:     // Make it norelative since it is a simple uri
  538:     *aUritype = URI_NORELATIVE | URI_NOAUTH | URI_LOADABLE_BY_ANYONE |
 3961:         URI_NON_PERSISTABLE | URI_DOES_NOT_RETURN_DATA;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalProtocolHandler::NewURI(const nsACString &aSpec,
    1:                                                 const char *aCharset, // ignore charset info
    1:                                                 nsIURI *aBaseURI,
    1:                                                 nsIURI **_retval)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIURI> uri = do_CreateInstance(NS_SIMPLEURI_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   rv = uri->SetSpec(aSpec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   NS_ADDREF(*_retval = uri);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalProtocolHandler::NewChannel(nsIURI *aURI, nsIChannel **_retval)
    1: {
 4068:   // Only try to return a channel if we have a protocol handler for the url.
 4068:   // nsOSHelperAppService::LoadUriInternal relies on this to check trustedness
 4068:   // for some platforms at least.  (win uses ::ShellExecute and unix uses
 4068:   // gnome_url_show.)
79445:   bool haveExternalHandler = HaveExternalProtocolHandler(aURI);
 2455:   if (haveExternalHandler)
    1:   {
47223:     nsCOMPtr<nsIChannel> channel = new nsExtProtocolChannel();
    1:     if (!channel) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     ((nsExtProtocolChannel*) channel.get())->SetURI(aURI);
    1:     channel->SetOriginalURI(aURI);
    1: 
    1:     if (_retval)
    1:     {
    1:       *_retval = channel;
    1:       NS_IF_ADDREF(*_retval);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_ERROR_UNKNOWN_PROTOCOL;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////
    1: // External protocol handler interface implementation
    1: //////////////////////////////////////////////////////////////////////
79445: NS_IMETHODIMP nsExternalProtocolHandler::ExternalAppExistsForScheme(const nsACString& aScheme, bool *_retval)
    1: {
87393:   nsCOMPtr<nsIExternalProtocolService> extProtSvc(do_GetService(NS_EXTERNALPROTOCOLSERVICE_CONTRACTID));
87393:   if (extProtSvc)
87393:     return extProtSvc->ExternalProtocolHandlerExists(
 1859:       PromiseFlatCString(aScheme).get(), _retval);
    1: 
    1:   // In case we don't have external protocol service.
80486:   *_retval = false;
    1:   return NS_OK;
    1: }
