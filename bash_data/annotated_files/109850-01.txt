 37412: /* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
 37412: /* Cairo - a vector graphics library with display and print output
 37412:  *
 37412:  * Copyright © 2010 Mozilla Foundation
 37412:  *
 37412:  * This library is free software; you can redistribute it and/or
 37412:  * modify it either under the terms of the GNU Lesser General Public
 37412:  * License version 2.1 as published by the Free Software Foundation
 37412:  * (the "LGPL") or, at your option, under the terms of the Mozilla
 37412:  * Public License Version 1.1 (the "MPL"). If you do not alter this
 37412:  * notice, a recipient may use your version of this file under either
 37412:  * the MPL or the LGPL.
 37412:  *
 37412:  * You should have received a copy of the LGPL along with this library
 37412:  * in the file COPYING-LGPL-2.1; if not, write to the Free Software
 37412:  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 37412:  * You should have received a copy of the MPL along with this library
 37412:  * in the file COPYING-MPL-1.1
 37412:  *
 37412:  * The contents of this file are subject to the Mozilla Public License
 37412:  * Version 1.1 (the "License"); you may not use this file except in
 37412:  * compliance with the License. You may obtain a copy of the License at
 37412:  * http://www.mozilla.org/MPL/
 37412:  *
 37412:  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
 37412:  * OF ANY KIND, either express or implied. See the LGPL or the MPL for
 37412:  * the specific language governing rights and limitations.
 37412:  *
 37412:  * The Original Code is the cairo graphics library.
 37412:  *
 37412:  * The Initial Developer of the Original Code is the Mozilla Foundation
 37412:  *
 37412:  * Contributor(s):
 37412:  *	Bas Schouten <bschouten@mozilla.com>
 37412:  */
 37412: #define INITGUID
 37412: 
 67839: #include "cairoint.h"
 37412: #include "cairo-d2d-private.h"
 37412: #include "cairo-dwrite-private.h"
 37412: 
 37412: #include "cairo-win32.h"
 37412: #include "cairo-analysis-surface-private.h"
 70960: #include "cairo-error-private.h"
 37412: 
 40634: // Required for using placement new.
 40634: #include <new>
 37412: 
 37412: #define CAIRO_INT_STATUS_SUCCESS (cairo_int_status_t)CAIRO_STATUS_SUCCESS
 37412: 
 49320: struct Vertex
 49320: {
 49320:     float position[2];
 49320: };
 49320: 
 49320: // This factory is not device dependent, we can store it. But will clear it
 49320: // if there are no devices left needing it.
 49320: static ID2D1Factory *sD2DFactory = NULL;
 49320: static HMODULE sD2DModule;
 49320: 
 49320: static void
 49320: _cairo_d2d_release_factory()
 49320: {
 49320:     int refcnt = sD2DFactory->Release();
 49320:     if (!refcnt) {
 49320: 	// Once the last reference goes, free the library.
 49320: 	sD2DFactory = NULL;
 49320: 	FreeLibrary(sD2DModule);
 49320:     }
 49320: }
 49320: 
 49320: /**
 49320:  * Set a blending mode for an operator. This will also return a boolean that
 49320:  * reports if for this blend mode the entire surface needs to be blended. This
 49320:  * is true whenever the DEST blend is not ONE when src alpha is 0.
 49320:  */
 49320: static cairo_int_status_t
 49320: _cairo_d2d_set_operator(cairo_d2d_device_t *device,
 49320: 			cairo_operator_t op)
 49320: {
 49320:     assert(op < MAX_OPERATORS);
 49320:     if (op >= MAX_OPERATORS) {
 49320: 	// Eep! Someone forgot to update MAX_OPERATORS probably.
 49320: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 49320:     }
 49320: 
 49320:     if (device->mBlendStates[op]) {
 49320: 	device->mD3D10Device->OMSetBlendState(device->mBlendStates[op], NULL, 0xffffffff);
 49320: 	return CAIRO_INT_STATUS_SUCCESS;
 49320:     }
 49320: 
 49320:     D3D10_BLEND_DESC desc;
 49320:     memset(&desc, 0, sizeof(desc));
 49320:     desc.BlendEnable[0] = TRUE;
 49320:     desc.AlphaToCoverageEnable = FALSE;
 49320:     desc.RenderTargetWriteMask[0] = D3D10_COLOR_WRITE_ENABLE_ALL;
 49320: 
 49320:     switch (op) {
 49320: 	case CAIRO_OPERATOR_OVER:
 49320: 	    desc.BlendOp = desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
 49320: 	    desc.DestBlend = desc.DestBlendAlpha = D3D10_BLEND_INV_SRC_ALPHA;
 49320: 	    desc.SrcBlend = desc.SrcBlendAlpha = D3D10_BLEND_ONE;
 49320: 	    break;
 49320: 	case CAIRO_OPERATOR_ADD:
 49320: 	    desc.BlendOp = desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
 49320: 	    desc.DestBlend = desc.DestBlendAlpha = D3D10_BLEND_ONE;
 49320: 	    desc.SrcBlend = desc.SrcBlendAlpha = D3D10_BLEND_ONE;
 49320: 	    break;
 49320: 	case CAIRO_OPERATOR_IN:
 49320: 	    desc.BlendOp = desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
 49320: 	    desc.DestBlend = desc.DestBlendAlpha = D3D10_BLEND_ZERO;
 49320: 	    desc.SrcBlend = desc.SrcBlendAlpha = D3D10_BLEND_DEST_ALPHA;
 49320: 	    break;
 49320: 	case CAIRO_OPERATOR_OUT:
 49320: 	    desc.BlendOp = desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
 49320: 	    desc.DestBlend = desc.DestBlendAlpha = D3D10_BLEND_ZERO;
 49320: 	    desc.SrcBlend = desc.SrcBlendAlpha = D3D10_BLEND_INV_DEST_ALPHA;
 49320: 	    break;
 49320: 	case CAIRO_OPERATOR_ATOP:
 49320: 	    desc.BlendOp = desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
 49320: 	    desc.DestBlend = desc.DestBlendAlpha = D3D10_BLEND_INV_SRC_ALPHA;
 49320: 	    desc.SrcBlend = desc.SrcBlendAlpha = D3D10_BLEND_DEST_ALPHA;
 49320: 	    break;
 49320: 	case CAIRO_OPERATOR_DEST:
 49320: 	    desc.BlendOp = desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
 49320: 	    desc.DestBlend = desc.DestBlendAlpha = D3D10_BLEND_ONE;
 49320: 	    desc.SrcBlend = desc.SrcBlendAlpha = D3D10_BLEND_ZERO;
 49320: 	    break;
 49320: 	case CAIRO_OPERATOR_DEST_OVER:
 49320: 	    desc.BlendOp = desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
 49320: 	    desc.DestBlend = desc.DestBlendAlpha = D3D10_BLEND_ONE;
 49320: 	    desc.SrcBlend = desc.SrcBlendAlpha = D3D10_BLEND_INV_DEST_ALPHA;
 49320: 	    break;
 49320: 	case CAIRO_OPERATOR_DEST_IN:
 49320: 	    desc.BlendOp = desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
 49320: 	    desc.DestBlend = desc.DestBlendAlpha = D3D10_BLEND_SRC_ALPHA;
 49320: 	    desc.SrcBlend = desc.SrcBlendAlpha = D3D10_BLEND_ZERO;
 49320: 	    break;
 49320: 	case CAIRO_OPERATOR_DEST_OUT:
 49320: 	    desc.BlendOp = desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
 49320: 	    desc.DestBlend = desc.DestBlendAlpha = D3D10_BLEND_INV_SRC_ALPHA;
 49320: 	    desc.SrcBlend = desc.SrcBlendAlpha = D3D10_BLEND_ZERO;
 49320: 	    break;
 49320: 	case CAIRO_OPERATOR_DEST_ATOP:
 49320: 	    desc.BlendOp = desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
 49320: 	    desc.DestBlend = desc.DestBlendAlpha = D3D10_BLEND_SRC_ALPHA;
 49320: 	    desc.SrcBlend = desc.SrcBlendAlpha = D3D10_BLEND_INV_DEST_ALPHA;
 49320: 	    break;
 49320: 	case CAIRO_OPERATOR_XOR:
 49320: 	    desc.BlendOp = desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
 49320: 	    desc.DestBlend = desc.DestBlendAlpha = D3D10_BLEND_INV_SRC_ALPHA;
 49320: 	    desc.SrcBlend = desc.SrcBlendAlpha = D3D10_BLEND_INV_DEST_ALPHA;
 49320: 	    break;
 49320: 	default:
 49320: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 49320:     };
 49320:     device->mD3D10Device->CreateBlendState(&desc, &device->mBlendStates[op]);
 49320: 
 49320:     device->mD3D10Device->OMSetBlendState(device->mBlendStates[op], NULL, 0xffffffff);
 49320:     return CAIRO_INT_STATUS_SUCCESS;
 49320: }
 49320: 
 49320: cairo_device_t *
 50584: cairo_d2d_create_device_from_d3d10device(ID3D10Device1 *d3d10device)
 49320: {
 50584:     HRESULT hr;
 49320:     D3D10_RASTERIZER_DESC rastDesc;
 49320:     D3D10_INPUT_ELEMENT_DESC layout[] =
 49320:     {
 49320: 	{ "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0 },
 49320:     };
 49320:     D3D10_PASS_DESC passDesc;
 49320:     ID3D10EffectTechnique *technique;
 49320:     Vertex vertices[] = { {0.0, 0.0}, {1.0, 0.0}, {0.0, 1.0}, {1.0, 1.0} };
 49320:     CD3D10_BUFFER_DESC bufferDesc(sizeof(vertices), D3D10_BIND_VERTEX_BUFFER);
 49320:     D3D10_SUBRESOURCE_DATA data;
 60656:     CD3D10_TEXTURE2D_DESC textDesc(DXGI_FORMAT_B8G8R8A8_UNORM,
 60656: 				   TEXT_TEXTURE_WIDTH,
 60656: 				   TEXT_TEXTURE_HEIGHT,
 60656: 				   1, 1);
 49320: 
 49320:     cairo_d2d_device_t *device = new cairo_d2d_device_t;
 50584: 
 50584:     device->mD3D10Device = d3d10device;
 50584: 
 49320:     device->mD3D10_1 = LoadLibraryA("d3d10_1.dll");
 49320:     D3D10CreateEffectFromMemoryFunc createEffect = (D3D10CreateEffectFromMemoryFunc)
 49320: 	GetProcAddress(device->mD3D10_1, "D3D10CreateEffectFromMemory");
 49320:     D2D1CreateFactoryFunc createD2DFactory;
 49320: 
 50584:     if (!createEffect) {
 49320: 	goto FAILED;
 49320:     }
 49320: 
 50584:     if (!sD2DFactory) {
 50584: 	sD2DModule = LoadLibraryW(L"d2d1.dll");
 50584: 	createD2DFactory = (D2D1CreateFactoryFunc)
 50584: 	    GetProcAddress(sD2DModule, "D2D1CreateFactory");
 50584: 	if (!createD2DFactory) {
 50584: 	    goto FAILED;
 50584: 	}
 50584: 	D2D1_FACTORY_OPTIONS options;
 50584: #ifdef DEBUG
 50584: 	options.debugLevel = D2D1_DEBUG_LEVEL_INFORMATION;
 50584: #else
 50584: 	options.debugLevel = D2D1_DEBUG_LEVEL_NONE;
 50584: #endif
 50584: 	hr = createD2DFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED,
 50584: 			      __uuidof(ID2D1Factory),
 50584: 			      &options,
 50584: 			      (void**)&sD2DFactory);
 50584: 	if (FAILED(hr)) {
 50584: 	    goto FAILED;
 50584: 	}
 50584:     } else {
 50584: 	sD2DFactory->AddRef();
 50584:     }
 50584: 
 50584:     device->mD3D10Device->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP);
 50584:     createEffect((void*)g_main, sizeof(g_main), 0, device->mD3D10Device, NULL, &device->mSampleEffect);
 50584: 
 50584:     technique = device->mSampleEffect->GetTechniqueByName("SampleTexture");
 50584:     technique->GetPassByIndex(0)->GetDesc(&passDesc);
 50584: 
 50584: 
 50584:     hr = device->mD3D10Device->CreateInputLayout(layout,
 50584: 						 sizeof(layout) / sizeof(D3D10_INPUT_ELEMENT_DESC),
 50584: 						 passDesc.pIAInputSignature,
 50584: 						 passDesc.IAInputSignatureSize,
 50584: 						 &device->mInputLayout);
 50584:     if (FAILED(hr)) {
 50584: 	goto FAILED;
 50584:     }
 50584: 
 50584:     data.pSysMem = (void*)vertices;
 50584:     hr = device->mD3D10Device->CreateBuffer(&bufferDesc, &data, &device->mQuadBuffer);
 50584:     if (FAILED(hr)) {
 50584: 	goto FAILED;
 50584:     }
 50584: 
 50584:     memset(&rastDesc, 0, sizeof(rastDesc));
 50584:     rastDesc.CullMode = D3D10_CULL_NONE;
 50584:     rastDesc.FillMode = D3D10_FILL_SOLID;
 50872:     rastDesc.DepthClipEnable = TRUE;
 50584:     hr = device->mD3D10Device->CreateRasterizerState(&rastDesc, &device->mRasterizerState);
 50584:     if (FAILED(hr)) {
 50584: 	goto FAILED;
 50584:     }
 50584:     device->base.refcount = 1;
 60656: 
 60656:     // We start out with TEXT_TEXTURE roughly in VRAM usage.
 60656:     device->mVRAMUsage = TEXT_TEXTURE_WIDTH * TEXT_TEXTURE_HEIGHT * 4;
 60656: 
 60710:     // We create this with USAGE_DEFAULT, our intention is to have VRAM reserved
 60710:     // for text usage. We actually store glyph data in STAGING textures for the
 60710:     // rendering pipeline to read and copy it to this VRAM texture.
 60710:     textDesc.Usage = D3D10_USAGE_DEFAULT;
 60656:     hr = device->mD3D10Device->CreateTexture2D(&textDesc, NULL, &device->mTextTexture);
 60656:     if (FAILED(hr)) {
 60656: 	goto FAILED;
 60656:     }
 60656: 
 60656:     hr = device->mD3D10Device->CreateShaderResourceView(device->mTextTexture,
 60656: 							NULL,
 60656: 							&device->mTextTextureView);
 50584: 
 50584:     return &device->base;
 50584: FAILED:
 50584:     delete &device->base;
 50584:     return NULL;
 50584: }
 50584: 
 50584: cairo_device_t *
 50584: cairo_d2d_create_device()
 50584: {
 50584:     HMODULE d3d10module = LoadLibraryA("d3d10_1.dll");
 50584:     D3D10CreateDevice1Func createD3DDevice = (D3D10CreateDevice1Func)
 50584: 	GetProcAddress(d3d10module, "D3D10CreateDevice1");
 50584: 
 50584:     if (!createD3DDevice) {
 50584: 	return NULL;
 50584:     }
 50584: 
 50584:     RefPtr<ID3D10Device1> d3ddevice;
 50584: 
 49320:     /**
 49320:      * On usage of D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS:
 49320:      * documentation on D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS
 49320:      * can be misleading. In fact, that flag gives no such indication. I pointed this
 49320:      * out to Bas in my email. However, Microsoft is in fact using this flag to
 49320:      * indicate "light weight" DX applications. By light weight they are essentially
 49320:      * referring to applications that are not games. The idea is that when you create
 49320:      * a DX game, the driver assumes that you will pretty much have a single instance
 49320:      * and therefore it doesn't try to hold back when it comes to GPU resource
 49320:      * allocation as long as it can crank out performance. In other words, the
 49320:      * priority in regular DX applications is to make that one application run as fast
 49320:      * as you can. For "light weight" applications, including D2D applications, the
 49320:      * priorities are a bit different. Now you are no longer going to have a single
 49320:      * (or very few) instances. You can have a lot of them (say, for example, a
 49320:      * separate DX context/device per browser tab). In such cases, the GPU resource
 49320:      * allocation scheme changes.
 49320:      */
 49320:     HRESULT hr = createD3DDevice(
 49320: 	NULL, 
 49320: 	D3D10_DRIVER_TYPE_HARDWARE,
 49320: 	NULL,
 49320: 	D3D10_CREATE_DEVICE_BGRA_SUPPORT |
 49320: 	D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS,
 49320: 	D3D10_FEATURE_LEVEL_10_1,
 49320: 	D3D10_1_SDK_VERSION,
 50584: 	&d3ddevice);
 49320:     if (FAILED(hr)) {
 49628: 	hr = createD3DDevice(
 49320: 	    NULL, 
 49320: 	    D3D10_DRIVER_TYPE_HARDWARE,
 49320: 	    NULL,
 49320: 	    D3D10_CREATE_DEVICE_BGRA_SUPPORT |
 49320: 	    D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS,
 49320: 	    D3D10_FEATURE_LEVEL_10_0,
 49320: 	    D3D10_1_SDK_VERSION,
 50584: 	    &d3ddevice);
 49320: 	if (FAILED(hr)) {
 49320: 	    /* This is not guaranteed to be too fast! */
 49628: 	    hr = createD3DDevice(
 49320: 		NULL, 
 49320: 		D3D10_DRIVER_TYPE_HARDWARE,
 49320: 		NULL,
 49320: 		D3D10_CREATE_DEVICE_BGRA_SUPPORT |
 49320: 		D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS,
 49320: 		D3D10_FEATURE_LEVEL_9_3,
 49320: 		D3D10_1_SDK_VERSION,
 50584: 		&d3ddevice);
 49320: 
 49320: 	}
 49320:     }
 49320:     if (FAILED(hr)) {
 49320: 	return NULL;
 49320:     }
 49320: 
 50584:     cairo_device_t *device = cairo_d2d_create_device_from_d3d10device(d3ddevice);
 50584: 
 50584:     // Free our reference to the modules. The created device should have its own.
 50584:     FreeLibrary(d3d10module);
 50584:     return device;
 50584: }
 50584: 
 49320: int
 49320: cairo_release_device(cairo_device_t *device)
 49320: {
 49320:     int newrefcnt = --device->refcount;
 49320:     if (!newrefcnt) {
 49320: 	// Call the correct destructor
 49320: 	cairo_d2d_device_t *d2d_device = reinterpret_cast<cairo_d2d_device_t*>(device);
 50596: 	HMODULE d3d10_1 = d2d_device->mD3D10_1;
 49320: 	delete d2d_device;
 49320: 	_cairo_d2d_release_factory();
 50596: 	FreeLibrary(d3d10_1);
 49320:     }
 49320:     return newrefcnt;
 49320: }
 49320: 
 49320: int
 49320: cairo_addref_device(cairo_device_t *device)
 49320: {
 49320:     return ++device->refcount;
 49320: }
 49320: 
 49321: void
 49321: cairo_d2d_finish_device(cairo_device_t *device)
 49321: {
 49321:     cairo_d2d_device_t *d2d_device = reinterpret_cast<cairo_d2d_device_t*>(device);
 49321:     // Here it becomes interesting, this flush method is generally called when
 49321:     // interop is going on between our device and another device. The
 49321:     // synchronisation between these devices is not always that great. The
 49321:     // device flush method may flush the device's command queue, but it gives
 49321:     // no guarantee that the device will actually be done with those commands,
 49321:     // and so the surface may still not be complete when the external device
 49321:     // chooses to use it. The EVENT query will actually tell us when the GPU
 49321:     // is completely done with our commands.
 49321:     D3D10_QUERY_DESC queryDesc;
 49321:     queryDesc.MiscFlags = 0;
 49321:     queryDesc.Query = D3D10_QUERY_EVENT;
 49321:     RefPtr<ID3D10Query> query;
 49321: 
 49321:     d2d_device->mD3D10Device->CreateQuery(&queryDesc, &query);
 49321: 
 49321:     // QUERY_EVENT does not use Begin(). It's disabled.
 49321:     query->End();
 49321: 
 49321:     BOOL done = FALSE;
 49321:     while (!done) {
 49321: 	// This will return S_OK and done = FALSE when the GPU is not done, and
 49321: 	// S_OK and done = TRUE when the GPU is done. Any other return value
 49321: 	// means we need to break out or risk an infinite loop.
 49321: 	if (FAILED(query->GetData(&done, sizeof(BOOL), 0))) {
 49321: 	    break;
 49321: 	}
 54659: 	if (FAILED(d2d_device->mD3D10Device->GetDeviceRemovedReason())) {
 54659: 	    break;
 54659: 	}
 49321:     }
 49321: }
 49321: 
 53983: ID3D10Device1*
 53983: cairo_d2d_device_get_device(cairo_device_t *device)
 53983: {
 53983:     cairo_d2d_device_t *d2d_device = reinterpret_cast<cairo_d2d_device_t*>(device);
 53983:     return d2d_device->mD3D10Device;  
 53983: }
 53983: 
 49320: static void
 49320: _cairo_d2d_setup_for_blend(cairo_d2d_device_t *device)
 49320: {
 49320:     device->mD3D10Device->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
 49320:     device->mD3D10Device->IASetInputLayout(device->mInputLayout);
 49320: 
 49320:     UINT stride = sizeof(Vertex);
 49320:     UINT offset = 0;
 49320:     ID3D10Buffer *buff = device->mQuadBuffer;
 49320:     device->mD3D10Device->IASetVertexBuffers(0, 1, &buff, &stride, &offset);
 49320: 
 49320:     device->mD3D10Device->RSSetState(device->mRasterizerState);
 49320: }
 49320: 
 46437: // Contains our cache usage - perhaps this should be made threadsafe.
 46437: static int cache_usage = 0;
 46437: 
 37412: /**
 37412:  * Create a similar surface which will blend effectively to
 37412:  * another surface. For D2D, this will create another texture.
 37412:  * Within the types we use blending is always easy.
 37412:  *
 37412:  * \param surface Surface this needs to be similar to
 37412:  * \param content Content type of the new surface
 37412:  * \param width Width of the new surface
 37412:  * \param height Height of the new surface
 37412:  * \return New surface
 37412:  */
 37412: static cairo_surface_t*
 37412: _cairo_d2d_create_similar(void			*surface,
 37412: 			  cairo_content_t	 content,
 37412: 			  int			 width,
 37412: 			  int			 height);
 37412: 
 37412: /**
 37412:  * Release all the data held by a surface, the surface structure
 37412:  * itsself will be freed by cairo.
 37412:  *
 37412:  * \param surface Surface to clean up
 37412:  */
 37412: static cairo_status_t
 37412: _cairo_d2d_finish(void	    *surface);
 37412: 
 37412: /**
 37412:  * Get a read-only image surface that contains the pixel data
 37412:  * of a D2D surface.
 37412:  *
 37412:  * \param abstract_surface D2D surface to acquire the image from
 37412:  * \param image_out Pointer to where we should store the image surface pointer
 37412:  * \param image_extra Pointer where to store extra data we want to know about
 37412:  * at the point of release.
 37412:  * \return CAIRO_STATUS_SUCCESS for success
 37412:  */
 37412: static cairo_status_t
 37412: _cairo_d2d_acquire_source_image(void                    *abstract_surface,
 37412: 				cairo_image_surface_t  **image_out,
 37412: 				void                   **image_extra);
 37412: 
 37412: /**
 37412:  * Release a read-only image surface that was obtained using acquire_source_image
 37412:  *
 37412:  * \param abstract_surface D2D surface to acquire the image from
 37412:  * \param image_out Pointer to where we should store the image surface pointer
 37412:  * \param image_extra Pointer where to store extra data we want to know about
 37412:  * at the point of release.
 37412:  * \return CAIRO_STATUS_SUCCESS for success
 37412:  */
 37412: static void
 37412: _cairo_d2d_release_source_image(void                   *abstract_surface,
 37412: 				cairo_image_surface_t  *image,
 37412: 				void                   *image_extra);
 37412: 
 37412: /**
 37412:  * Get a read-write image surface that contains the pixel data
 37412:  * of a D2D surface.
 37412:  *
 37412:  * \param abstract_surface D2D surface to acquire the image from
 37412:  * \param image_out Pointer to where we should store the image surface pointer
 37412:  * \param image_extra Pointer where to store extra data we want to know about
 37412:  * at the point of release.
 37412:  * \return CAIRO_STATUS_SUCCESS for success
 37412:  */
 37412: static cairo_status_t
 37412: _cairo_d2d_acquire_dest_image(void                    *abstract_surface,
 37412: 			      cairo_rectangle_int_t   *interest_rect,
 37412: 			      cairo_image_surface_t  **image_out,
 37412: 			      cairo_rectangle_int_t   *image_rect,
 37412: 			      void                   **image_extra);
 37412: 
 37412: /**
 37412:  * Release a read-write image surface that was obtained using acquire_source_image
 37412:  *
 37412:  * \param abstract_surface D2D surface to acquire the image from
 37412:  * \param image_out Pointer to where we should store the image surface pointer
 37412:  * \param image_extra Pointer where to store extra data we want to know about
 37412:  * at the point of release.
 37412:  * \return CAIRO_STATUS_SUCCESS for success
 37412:  */
 37412: static void
 37412: _cairo_d2d_release_dest_image(void                    *abstract_surface,
 37412: 			      cairo_rectangle_int_t   *interest_rect,
 37412: 			      cairo_image_surface_t   *image,
 37412: 			      cairo_rectangle_int_t   *image_rect,
 37412: 			      void                    *image_extra);
 37412: 
 37412: /**
 37412:  * Flush this surface, only after this operation is the related hardware texture
 37412:  * guaranteed to contain all the results of the executed drawing operations.
 37412:  *
 37412:  * \param surface D2D surface to flush
 37412:  * \return CAIRO_STATUS_SUCCESS or CAIRO_SURFACE_TYPE_MISMATCH
 37412:  */
 37412: static cairo_status_t
 37412: _cairo_d2d_flush(void                  *surface);
 37412: 
 37412: /**
 37412:  * Fill a path on this D2D surface.
 37412:  *
 37412:  * \param surface The surface to apply this operation to, must be
 37412:  * a D2D surface
 37412:  * \param op The operator to use
 37412:  * \param source The source pattern to fill this path with
 37412:  * \param path The path to fill
 37412:  * \param fill_rule The fill rule to uses on the path
 37412:  * \param tolerance The tolerance applied to the filling
 37412:  * \param antialias The anti-alias mode to use
 41340:  * \param clip The clip of this operation
 37412:  * \return Return code, this can be CAIRO_ERROR_SURFACE_TYPE_MISMATCH,
 37412:  * CAIRO_INT_STATUS_UNSUPPORTED or CAIRO_STATUS_SUCCESS
 37412:  */
 37412: static cairo_int_status_t
 37412: _cairo_d2d_fill(void			*surface,
 37412: 		cairo_operator_t	 op,
 37412: 		const cairo_pattern_t	*source,
 37412: 		cairo_path_fixed_t	*path,
 37412: 		cairo_fill_rule_t	 fill_rule,
 37412: 		double			 tolerance,
 37412: 		cairo_antialias_t	 antialias,
 41340: 		cairo_clip_t		*clip);
 37412: 
 37412: /**
 37412:  * Paint this surface, applying the operation to the entire surface
 37412:  *
 37412:  * \param surface The surface to apply this operation to, must be
 37412:  * a D2D surface
 37412:  * \param op Operator to use when painting
 37412:  * \param source The pattern to fill this surface with, source of the op
 41340:  * \param clip The clip of this operation
 37412:  * \return Return code, this can be CAIRO_ERROR_SURFACE_TYPE_MISMATCH,
 37412:  * CAIRO_INT_STATUS_UNSUPPORTED or CAIRO_STATUS_SUCCESS
 37412:  */
 37412: static cairo_int_status_t
 37412: _cairo_d2d_paint(void			*surface,
 37412: 		 cairo_operator_t	 op,
 37412: 		 const cairo_pattern_t	*source,
 41340: 		 cairo_clip_t		*clip);
 37412: 
 37412: /**
 37412:  * Paint something on the surface applying a certain mask to that
 37412:  * source.
 37412:  *
 37412:  * \param surface The surface to apply this oepration to, must be
 37412:  * a D2D surface
 37412:  * \param op Operator to use
 37412:  * \param source Source for this operation
 37412:  * \param mask Pattern to mask source with
 41340:  * \param clip The clip of this operation
 37412:  * \return Return code, this can be CAIRO_ERROR_SURFACE_TYPE_MISMATCH,
 37412:  * CAIRO_INT_STATUS_UNSUPPORTED or CAIRO_STATUS_SUCCESS
 37412:  */
 37412: static cairo_int_status_t
 37412: _cairo_d2d_mask(void			*surface,
 37412: 		cairo_operator_t	 op,
 37412: 		const cairo_pattern_t	*source,
 37412: 		const cairo_pattern_t	*mask,
 41340: 		cairo_clip_t		*clip);
 37412: 
 37412: /**
 37412:  * Show a glyph run on the target D2D surface.
 37412:  *
 37412:  * \param surface The surface to apply this oepration to, must be
 37412:  * a D2D surface
 37412:  * \param op Operator to use
 37412:  * \param source Source for this operation
 37412:  * \param glyphs Glyphs to draw
 37412:  * \param num_gluphs Amount of glyphs stored at glyphs
 37412:  * \param scaled_font Scaled font to draw
 37412:  * \param remaining_glyphs Pointer to store amount of glyphs still
 37412:  * requiring drawing.
 41340:  * \param clip The clip of this operation
 37412:  * \return CAIRO_ERROR_SURFACE_TYPE_MISMATCH, CAIRO_ERROR_FONT_TYPE_MISMATCH,
 37412:  * CAIRO_INT_STATUS_UNSUPPORTED or CAIRO_STATUS_SUCCESS
 37412:  */
 37412: static cairo_int_status_t
 37412: _cairo_d2d_show_glyphs (void			*surface,
 37412: 			cairo_operator_t	 op,
 37412: 			const cairo_pattern_t	*source,
 37412: 			cairo_glyph_t		*glyphs,
 37412: 			int			 num_glyphs,
 37412: 			cairo_scaled_font_t	*scaled_font,
 41340: 			cairo_clip_t		*clip,
 41340: 			int			*remaining_glyphs);
 37412: 
 37412: /**
 37412:  * Get the extents of this surface.
 37412:  *
 37412:  * \param surface D2D surface to get the extents for
 37412:  * \param extents Pointer to where to store the extents
 37412:  * \param CAIRO_ERROR_SURFACE_TYPE_MISTMATCH or CAIRO_STATUS_SUCCESS
 37412:  */
 41340: static cairo_bool_t
 37412: _cairo_d2d_getextents(void		       *surface,
 37412: 		      cairo_rectangle_int_t    *extents);
 37412: 
 37412: 
 37412: /**
 37412:  * Stroke a path on this D2D surface.
 37412:  *
 37412:  * \param surface The surface to apply this operation to, must be
 37412:  * a D2D surface
 37412:  * \param op The operator to use
 37412:  * \param source The source pattern to fill this path with
 37412:  * \param path The path to stroke
 37412:  * \param style The style of the stroke
 37412:  * \param ctm A logical to device matrix, since the path might be in
 37412:  * device space the miter angle and such are not, hence we need to
 37412:  * be aware of the transformation to apply correct stroking.
 37412:  * \param ctm_inverse Inverse of ctm, used to transform the path back
 37412:  * to logical space.
 37412:  * \param tolerance Tolerance to stroke with
 37412:  * \param antialias Antialias mode to use
 41340:  * \param clip The clip of this operation
 37412:  * \return Return code, this can be CAIRO_ERROR_SURFACE_TYPE_MISMATCH,
 37412:  * CAIRO_INT_STATUS_UNSUPPORTED or CAIRO_STATUS_SUCCESS
 37412:  */
 37412: static cairo_int_status_t
 37412: _cairo_d2d_stroke(void			*surface,
 37412: 		  cairo_operator_t	 op,
 37412: 		  const cairo_pattern_t	*source,
 37412: 		  cairo_path_fixed_t	*path,
 70960: 		  const cairo_stroke_style_t	*style,
 70960: 		  const cairo_matrix_t	*ctm,
 70960: 		  const cairo_matrix_t	*ctm_inverse,
 37412: 		  double		 tolerance,
 37412: 		  cairo_antialias_t	 antialias,
 41340: 		  cairo_clip_t		*clip);
 37412: 
 37412: static const cairo_surface_backend_t cairo_d2d_surface_backend = {
 37412:     CAIRO_SURFACE_TYPE_D2D,
 37412:     _cairo_d2d_create_similar, /* create_similar */
 37412:     _cairo_d2d_finish, /* finish */
 37412:     _cairo_d2d_acquire_source_image, /* acquire_source_image */
 37412:     _cairo_d2d_release_source_image, /* release_source_image */
 37412:     _cairo_d2d_acquire_dest_image, /* acquire_dest_image */
 37412:     _cairo_d2d_release_dest_image, /* release_dest_image */
 37412:     NULL, /* clone_similar */
 37412:     NULL, /* composite */
 37412:     NULL, /* fill_rectangles */
 37412:     NULL, /* composite_trapezoids */
 37412:     NULL, /* create_span_renderer */
 37412:     NULL, /* check_span_renderer */
 37412:     NULL, /* copy_page */
 37412:     NULL, /* show_page */
 41340:     _cairo_d2d_getextents, /* get_extents */
 37412:     NULL, /* old_show_glyphs */
 37412:     NULL, /* get_font_options */
 37412:     _cairo_d2d_flush, /* flush */
 37412:     NULL, /* mark_dirty_rectangle */
 37412:     NULL, /* scaled_font_fini */
 37412:     NULL, /* scaled_glyph_fini */
 37412:     _cairo_d2d_paint, /* paint */
 37412:     _cairo_d2d_mask, /* mask */
 37412:     _cairo_d2d_stroke, /* stroke */
 37412:     _cairo_d2d_fill, /* fill */
 37412:     _cairo_d2d_show_glyphs, /* show_glyphs */
 37412:     NULL, /* snapshot */
 37412:     NULL
 37412: };
 37412: 
 37412: /*
 37412:  * Helper functions.
 37412:  */
 37412: 
 60655: /* Stack-based helper to manage region destruction. */
 60655: struct cairo_region_auto_ptr
 60655: {
 60655:     cairo_region_auto_ptr() : region(NULL)
 60655:     { }
 60655:     cairo_region_auto_ptr(cairo_region_t *in_region) : region(in_region)
 60655:     { }
 60655: 
 60655:     void set(cairo_region_t *in_region) { region = in_region; }
 60655: 
 60655:     ~cairo_region_auto_ptr() { if (region) cairo_region_destroy (region); }
 60655: 
 60655:     cairo_region_t *region;
 60655: };
 60655: 
 42921: /* This clears a new D2D surface in case the VRAM was reused from an existing surface
 42921:  * and is therefor not empty, this must be called outside of drawing state! */
 42921: static void
 42921: _d2d_clear_surface(cairo_d2d_surface_t *surf)
 42921: {
 42921:     surf->rt->BeginDraw();
 42921:     surf->rt->Clear(D2D1::ColorF(0, 0));
 42921:     surf->rt->EndDraw();
 42921: }
 42921: 
 60657: static cairo_rectangle_int_t
 60657: _cairo_rect_from_windows_rect(const RECT *rect)
 60657: {
 60657:     cairo_rectangle_int_t new_rect;
 60657: 
 60657:     new_rect.x = rect->left;
 60657:     new_rect.y = rect->top;
 60657:     new_rect.width = rect->right - rect->left;
 60657:     new_rect.height = rect->bottom - rect->top;
 60657: 
 60657:     return new_rect;
 60657: }
 60657: 
 37412: static D2D1_POINT_2F
 37412: _d2d_point_from_cairo_point(const cairo_point_t *point)
 37412: {
 37412:     return D2D1::Point2F(_cairo_fixed_to_float(point->x),
 37412: 			 _cairo_fixed_to_float(point->y));
 37412: }
 37412: 
 37412: static D2D1_COLOR_F
 37412: _cairo_d2d_color_from_cairo_color(const cairo_color_t &color)
 37412: {
 37412:     return D2D1::ColorF((FLOAT)color.red, 
 37412: 			(FLOAT)color.green, 
 37412: 			(FLOAT)color.blue,
 37412: 			(FLOAT)color.alpha);
 37412: }
 37412: 
 49320: static void
 49320: _cairo_d2d_round_out_to_int_rect(cairo_rectangle_int_t *rect, double x1, double y1, double x2, double y2)
 49320: {
 49320:     rect->x = (int)floor(x1);
 49320:     rect->y = (int)floor(y1);
 49320:     rect->width = (int)ceil(x2) - rect->x;
 49320:     rect->height = (int)ceil(y2) - rect->y;    
 49320: }
 49320: 
 50775: static int
 50775: _cairo_d2d_compute_surface_mem_size(cairo_d2d_surface_t *surface)
 50775: {
 50775:     int size = surface->rt->GetPixelSize().width * surface->rt->GetPixelSize().height;
 50775:     size *= surface->rt->GetPixelFormat().format == DXGI_FORMAT_A8_UNORM ? 1 : 4;
 50775:     return size;
 50775: }
 50775: 
 70960: static D2D1_COLOR_F
 70960: _cairo_d2d_color_from_cairo_color_stop(const cairo_color_stop_t &color)
 70960: {
 70960:     return D2D1::ColorF((FLOAT)color.red, 
 70960: 			(FLOAT)color.green, 
 70960: 			(FLOAT)color.blue,
 70960: 			(FLOAT)color.alpha);
 70960: }
 70960: 
 70960: 
 37412: /**
 37412:  * Gets the surface buffer texture for window surfaces whose backbuffer
 37412:  * is not directly usable as a bitmap.
 37412:  *
 37412:  * \param surface D2D surface.
 37412:  * \return Buffer texture
 37412:  */
 37412: static ID3D10Texture2D*
 37412: _cairo_d2d_get_buffer_texture(cairo_d2d_surface_t *surface) 
 37412: {
 37412:     if (!surface->bufferTexture) {
 51365: 	RefPtr<IDXGISurface> surf;
 37412: 	DXGI_SURFACE_DESC surfDesc;
 39196: 	surface->surface->QueryInterface(&surf);
 39196: 	surf->GetDesc(&surfDesc);
 37412: 	CD3D10_TEXTURE2D_DESC softDesc(surfDesc.Format, surfDesc.Width, surfDesc.Height);
 37412: 	softDesc.MipLevels = 1;
 37412: 	softDesc.Usage = D3D10_USAGE_DEFAULT;
 37412: 	softDesc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
 49320: 	surface->device->mD3D10Device->CreateTexture2D(&softDesc, NULL, &surface->bufferTexture);
 50775: 	surface->device->mVRAMUsage += _cairo_d2d_compute_surface_mem_size(surface);
 37412:     }
 37412:     return surface->bufferTexture;
 37412: }
 37412: 
 37412: /**
 37412:  * Ensure that the surface has an up-to-date surface bitmap. Used for
 37412:  * window surfaces which cannot have a surface bitmap directly related
 37412:  * to their backbuffer for some reason.
 37412:  * You cannot create a bitmap around a backbuffer surface for reason (it will 
 37412:  * fail with an E_INVALIDARG). Meaning they need a special texture to store 
 37412:  * their graphical data which is wrapped by a D2D bitmap if a window surface 
 37412:  * is ever used in a surface pattern. All other D2D surfaces use a texture as 
 37412:  * their backing store so can have a bitmap directly.
 37412:  *
 37412:  * \param surface D2D surface.
 37412:  */
 37412: static void _cairo_d2d_update_surface_bitmap(cairo_d2d_surface_t *d2dsurf)
 37412: {
 43669:     if (!d2dsurf->backBuf && d2dsurf->rt->GetPixelFormat().format != DXGI_FORMAT_A8_UNORM) {
 37412: 	return;
 37412:     }
 43669:     
 37412:     if (!d2dsurf->surfaceBitmap) {
 43669: 	d2dsurf->rt->CreateBitmap(d2dsurf->rt->GetPixelSize(),
 43669: 				  D2D1::BitmapProperties(d2dsurf->rt->GetPixelFormat()),
 37412: 				  &d2dsurf->surfaceBitmap);
 37412:     }
 43669: 
 43669:     d2dsurf->surfaceBitmap->CopyFromRenderTarget(NULL, d2dsurf->rt, NULL);
 37412: }
 37412: 
 37412: /**
 37412:  * Present the backbuffer for a surface create for an HWND. This needs
 37412:  * to be called when the owner of the original window surface wants to
 37412:  * actually present the executed drawing operations to the screen.
 37412:  *
 37412:  * \param surface D2D surface.
 37412:  */
 37412: void cairo_d2d_present_backbuffer(cairo_surface_t *surface)
 37412: {
 37412:     if (surface->type != CAIRO_SURFACE_TYPE_D2D) {
 37412: 	return;
 37412:     }
 37412:     cairo_d2d_surface_t *d2dsurf = reinterpret_cast<cairo_d2d_surface_t*>(surface);
 37412:     _cairo_d2d_flush(d2dsurf);
 37412:     if (d2dsurf->dxgiChain) {
 37412: 	d2dsurf->dxgiChain->Present(0, 0);
 49320: 	d2dsurf->device->mD3D10Device->Flush();
 37412:     }
 37412: }
 37412: 
 84947: struct d2d_clip_t
 37412: {
 46450:     enum clip_type {LAYER, AXIS_ALIGNED_CLIP};
 84947:     d2d_clip_t * const prev;
 46450:     const enum clip_type type;
 84947:     d2d_clip_t(d2d_clip_t *prev, clip_type type) : prev(prev), type(type) { }
 46450: };
 46450: 
 46450: static RefPtr<ID2D1PathGeometry>
 46450: _cairo_d2d_create_path_geometry_for_path(cairo_path_fixed_t *path,
 46450: 					 cairo_fill_rule_t fill_rule,
 46450: 					 D2D1_FIGURE_BEGIN type);
 46450: 
 46450: 
 46450: static cairo_bool_t
 46450: box_is_integer (cairo_box_t *box)
 46450: {
 46450:     return _cairo_fixed_is_integer(box->p1.x) &&
 46450: 	_cairo_fixed_is_integer(box->p1.y) &&
 46450: 	_cairo_fixed_is_integer(box->p2.x) &&
 46450: 	_cairo_fixed_is_integer(box->p2.y);
 37412: }
 46450: 
 46450: static cairo_status_t
 46450: push_clip (cairo_d2d_surface_t *d2dsurf, cairo_clip_path_t *clip_path)
 46450: {
 46450:     cairo_box_t box;
 46450:     if (_cairo_path_fixed_is_box(&clip_path->path, &box)) {
 46450: 
 46450: 	assert(box.p1.y < box.p2.y);
 46450: 
 46450: 	D2D1_ANTIALIAS_MODE mode;
 46450: 	if (box_is_integer (&box)) {
 46450: 	    mode = D2D1_ANTIALIAS_MODE_ALIASED;
 46450: 	} else {
 46450: 	    mode = D2D1_ANTIALIAS_MODE_PER_PRIMITIVE;
 46450: 	}
 46450: 	d2dsurf->rt->PushAxisAlignedClip (
 46450: 		D2D1::RectF(
 46450: 		    _cairo_fixed_to_float(box.p1.x),
 46450: 		    _cairo_fixed_to_float(box.p1.y),
 46450: 		    _cairo_fixed_to_float(box.p2.x),
 46450: 		    _cairo_fixed_to_float(box.p2.y)),
 46450: 		mode);
 46450: 
 84947: 	d2dsurf->d2d_clip = new d2d_clip_t (d2dsurf->d2d_clip, d2d_clip_t::AXIS_ALIGNED_CLIP);
 46450:     } else {
 46450: 	HRESULT hr;
 46450: 	RefPtr<ID2D1PathGeometry> geom = _cairo_d2d_create_path_geometry_for_path (&clip_path->path,
 46450: 							clip_path->fill_rule,
 46450: 							D2D1_FIGURE_BEGIN_FILLED);
 46450: 	RefPtr<ID2D1Layer> layer;
 46450: 
 46450: 	hr = d2dsurf->rt->CreateLayer (&layer);
 46450: 
 43397: 	D2D1_LAYER_OPTIONS options = D2D1_LAYER_OPTIONS_NONE;
 43397: 	if (d2dsurf->base.content == CAIRO_CONTENT_COLOR) {
 43397: 	    options = D2D1_LAYER_OPTIONS_INITIALIZE_FOR_CLEARTYPE;
 43397: 	}
 46450: 
 46450: 	d2dsurf->rt->PushLayer(D2D1::LayerParameters(
 46450: 		    D2D1::InfiniteRect(),
 46450: 		    geom,
 46450: 		    D2D1_ANTIALIAS_MODE_PER_PRIMITIVE,
 37412: 		    D2D1::IdentityMatrix(),
 37412: 		    1.0,
 37412: 		    0,
 43397: 		    options),
 46450: 		layer);
 46450: 
 84947: 	d2dsurf->d2d_clip = new d2d_clip_t(d2dsurf->d2d_clip, d2d_clip_t::LAYER);
 37412:    }
 46450:     if (!d2dsurf->d2d_clip)
 46450: 	return _cairo_error(CAIRO_STATUS_NO_MEMORY);
 46450:     return CAIRO_STATUS_SUCCESS;
 37412: }
 37412: 
 37412: static void
 46450: pop_clip (cairo_d2d_surface_t *d2dsurf)
 37412: {
 84947:     d2d_clip_t *current_clip = d2dsurf->d2d_clip;
 46450: 
 46450:     /* pop the clip from the render target */
 84947:     if (current_clip->type == d2d_clip_t::LAYER) {
 37412: 	d2dsurf->rt->PopLayer();
 84947:     } else if (current_clip->type == d2d_clip_t::AXIS_ALIGNED_CLIP) {
 37412: 	d2dsurf->rt->PopAxisAlignedClip();
 37412:     }
 46450: 
 46450:     /* pop it from our own stack */
 46450:     d2dsurf->d2d_clip = current_clip->prev;
 46450:     delete current_clip;
 37412: }
 46450: 
 46450: /* intersect clip_paths until we reach head */
 46450: static cairo_status_t
 46450: clipper_intersect_clip_path_recursive (cairo_d2d_surface_t *d2dsurf,
 46450: 	cairo_clip_path_t *head,
 46450: 	cairo_clip_path_t *clip_path)
 46450: {
 46450:     cairo_status_t status;
 46450: 
 46450:     if (clip_path->prev != head) {
 46450: 	status =
 46450: 	    clipper_intersect_clip_path_recursive (d2dsurf,
 46450: 		    head,
 46450: 		    clip_path->prev);
 46450: 	if (unlikely (status))
 46450: 	    return status;
 37412:     }
 46450:     return push_clip(d2dsurf, clip_path);
 46450: 
 46450: }
 46450: 
 46450: /* pop all of the clipping layers and reset the clip */
 46450: static void
 46450: reset_clip (cairo_d2d_surface_t *d2dsurf)
 46450: {
 46450:     cairo_clip_path_t *current_clip_path = d2dsurf->clip.path;
 46450:     while (current_clip_path != NULL) {
 46450: 	pop_clip (d2dsurf);
 46450: 	current_clip_path = current_clip_path->prev;
 46450:     }
 46450: 
 46450:     _cairo_clip_reset (&d2dsurf->clip);
 46450: }
 46450: 
 46450: /* finds the lowest common ancestor of a and b */
 46450: static cairo_clip_path_t *
 46450: find_common_ancestor(cairo_clip_path_t *a, cairo_clip_path_t *b)
 46450: {
 46450:     int a_depth = 0, b_depth = 0;
 46450: 
 46450:     cairo_clip_path_t *x;
 46450: 
 46450:     /* find the depths of the clip_paths */
 46450:     x = a;
 46450:     while (x) {
 46450: 	a_depth++;
 46450: 	x = x->prev;
 46450:     }
 46450: 
 46450:     x = b;
 46450:     while (x) {
 46450: 	b_depth++;
 46450: 	x = x->prev;
 46450:     }
 46450: 
 46450:     /* rewind the deeper chain to the depth of the shallowest chain */
 46450:     while (b_depth < a_depth && a) {
 46450: 	a = a->prev;
 46450: 	a_depth--;
 46450:     }
 46450: 
 46450:     while (a_depth < b_depth && b) {
 46450: 	b = b->prev;
 46450: 	b_depth--;
 46450:     }
 46450: 
 46450:     /* walk back until we find a common ancesstor */
 46450: 
 46450:     /* b will be null if and only if a is null because the depths
 46450:      * must match at this point */
 46450:     while (a) {
 46450: 	if (a == b)
 46450: 	    return a;
 46450: 
 46450: 	a = a->prev;
 46450: 	b = b->prev;
 46450:     }
 46450: 
 46450:     /* a will be NULL */
 46450:     return a;
 46450: }
 46450: 
 60653: static cairo_status_t
 46450: _cairo_d2d_set_clip (cairo_d2d_surface_t *d2dsurf, cairo_clip_t *clip)
 46450: {
 46450:     if (clip == NULL) {
 46450: 	reset_clip (d2dsurf);
 46450: 	return CAIRO_STATUS_SUCCESS;
 46450:     }
 46450: 
 46450:     if (clip != NULL && clip->path == d2dsurf->clip.path)
 46450: 	return CAIRO_STATUS_SUCCESS;
 46450: 
 46450:     cairo_clip_path_t *current_clip_path = d2dsurf->clip.path;
 46450:     cairo_clip_path_t *new_clip_path = clip->path;
 46450:     cairo_clip_path_t *ancestor = find_common_ancestor (current_clip_path, new_clip_path);
 46450: 
 46450:     /* adjust the clip to the common ancestor */
 46450:     while (current_clip_path != ancestor) {
 46450: 	pop_clip (d2dsurf);
 46450: 	current_clip_path = current_clip_path->prev;
 46450:     }
 46450: 
 46450:     /* we now have a common parent (current_clip_path) for the clip */
 46450: 
 46450:     /* replace the old clip */
 46450:     _cairo_clip_reset (&d2dsurf->clip);
 46450:     _cairo_clip_init_copy (&d2dsurf->clip, clip);
 46450: 
 46450:     /* push the new clip paths up to current_clip_path */
 46450:     if (current_clip_path != clip->path)
 46450: 	return clipper_intersect_clip_path_recursive (d2dsurf, current_clip_path, clip->path);
 46450:     else
 46450: 	return CAIRO_STATUS_SUCCESS;
 37412: }
 37412: 
 71557: static void _cairo_d2d_add_dependent_surface(cairo_d2d_surface_t *surf, cairo_d2d_surface_t *user)
 71557: {
 71557:     _cairo_d2d_surface_entry *entry = new _cairo_d2d_surface_entry;
 71557:     entry->surface = user;
 71557:     cairo_surface_reference(&user->base);
 71557:     cairo_list_add(&entry->link, &surf->dependent_surfaces);
 71557: };
 71557: 
 71557: static void _cairo_d2d_flush_dependent_surfaces(cairo_d2d_surface_t *surf)
 71557: {
 71557:     _cairo_d2d_surface_entry *entry, *next;
 71557:     cairo_list_foreach_entry_safe(entry, next, _cairo_d2d_surface_entry, &surf->dependent_surfaces, link) {
 71557: 	_cairo_d2d_flush(entry->surface);
 71557: 	cairo_surface_destroy(&entry->surface->base);
 71557: 	delete entry;
 71557:     }
 71557:     cairo_list_init(&surf->dependent_surfaces);
 71557: }
 71557: 
 37412: /**
 37412:  * Enter the state where the surface is ready for drawing. This will guarantee
 37412:  * the surface is in the correct state, and the correct clipping area is pushed.
 37412:  *
 37412:  * \param surface D2D surface
 37412:  */
 37412: static void _begin_draw_state(cairo_d2d_surface_t* surface)
 37412: {
 37412:     if (!surface->isDrawing) {
 71557: 	_cairo_d2d_flush_dependent_surfaces(surface);
 37412: 	surface->rt->BeginDraw();
 37412: 	surface->isDrawing = true;
 37412:     }
 37412: }
 37412: 
 37412: /**
 37412:  * Get a D2D matrix from a cairo matrix. Note that D2D uses row vectors where cairo
 37412:  * uses column vectors. Hence the transposition.
 37412:  *
 37412:  * \param Cairo matrix
 37412:  * \return D2D matrix
 37412:  */
 37412: static D2D1::Matrix3x2F
 37412: _cairo_d2d_matrix_from_matrix(const cairo_matrix_t *matrix)
 37412: {
 37412:     return D2D1::Matrix3x2F((FLOAT)matrix->xx,
 37412: 			    (FLOAT)matrix->yx,
 37412: 			    (FLOAT)matrix->xy,
 37412: 			    (FLOAT)matrix->yy,
 37412: 			    (FLOAT)matrix->x0,
 37412: 			    (FLOAT)matrix->y0);
 37412: }
 37412: 
 37412: /**
 48299:  * Returns the inverse matrix for a D2D1 matrix. We cannot use the Invert function
 48299:  * on the Matrix3x2F function class since it's statically linked and we'd have to
 48299:  * lookup the symbol in the library. Doing this ourselves is easier.
 48299:  *
 48299:  * \param mat matrix
 48299:  * \return inverse of matrix mat
 48299:  */
 48299: static D2D1::Matrix3x2F
 48299: _cairo_d2d_invert_matrix(const D2D1::Matrix3x2F &mat)
 48299: {
 48299:     float inv_det =  (1 / mat.Determinant());
 48299: 
 48299:     return D2D1::Matrix3x2F(mat._22 * inv_det,
 48299: 			    -mat._12 * inv_det,
 48299: 			    -mat._21 * inv_det,
 48299: 			    mat._11 * inv_det,
 48299: 			    (mat._21 * mat._32 - mat._22 * mat._31) * inv_det,
 48299: 			    -(mat._11 * mat._32 - mat._12 * mat._31) * inv_det);
 48299: }
 48299: 
 48299: /**
 37412:  * Create a D2D stroke style interface for a cairo stroke style object. Must be
 37412:  * released when the calling function is finished with it.
 37412:  *
 37412:  * \param style Cairo stroke style object
 37412:  * \return D2D StrokeStyle interface
 37412:  */
 40634: static RefPtr<ID2D1StrokeStyle>
 37412: _cairo_d2d_create_strokestyle_for_stroke_style(const cairo_stroke_style_t *style)
 37412: {
 37412:     D2D1_CAP_STYLE line_cap = D2D1_CAP_STYLE_FLAT;
 37412:     switch (style->line_cap) {
 37412: 	case CAIRO_LINE_CAP_BUTT:
 37412: 	    line_cap = D2D1_CAP_STYLE_FLAT;
 37412: 	    break;
 37412: 	case CAIRO_LINE_CAP_SQUARE:
 37412: 	    line_cap = D2D1_CAP_STYLE_SQUARE;
 37412: 	    break;
 37412: 	case CAIRO_LINE_CAP_ROUND:
 37412: 	    line_cap = D2D1_CAP_STYLE_ROUND;
 37412: 	    break;
 37412:     }
 37412: 
 37412:     D2D1_LINE_JOIN line_join = D2D1_LINE_JOIN_MITER;
 37412:     switch (style->line_join) {
 37412: 	case CAIRO_LINE_JOIN_MITER:
 50648: 	    line_join = D2D1_LINE_JOIN_MITER_OR_BEVEL;
 37412: 	    break;
 37412: 	case CAIRO_LINE_JOIN_ROUND:
 37412: 	    line_join = D2D1_LINE_JOIN_ROUND;
 37412: 	    break;
 37412: 	case CAIRO_LINE_JOIN_BEVEL:
 37412: 	    line_join = D2D1_LINE_JOIN_BEVEL;
 37412: 	    break;
 37412:     }
 37412: 
 37412:     FLOAT *dashes = NULL;
 37412:     if (style->num_dashes) {
 37412: 	dashes = new FLOAT[style->num_dashes];
 37412: 	for (unsigned int i = 0; i < style->num_dashes; i++) {
 48848: 	    /* D2D seems to specify dash lengths in units of
 48848: 	     * line width instead of the more traditional approach
 48848: 	     * that cairo and many other APIs use where the unit
 48848: 	     * is in pixels or someother constant unit. */
 48848: 	    dashes[i] = (FLOAT) (style->dash[i] / style->line_width);
 37412: 	}
 37412:     }
 37412: 
 37412:     D2D1_DASH_STYLE dashStyle = D2D1_DASH_STYLE_SOLID;
 37412:     if (dashes) {
 37412: 	dashStyle = D2D1_DASH_STYLE_CUSTOM;
 37412:     }
 37412: 
 40634:     RefPtr<ID2D1StrokeStyle> strokeStyle;
 49320:     sD2DFactory->CreateStrokeStyle(D2D1::StrokeStyleProperties(line_cap, 
 37412: 							       line_cap,
 37412: 							       line_cap, 
 37412: 							       line_join, 
 37412: 							       (FLOAT)style->miter_limit,
 37412: 							       dashStyle,
 73690: 							       (FLOAT)style->dash_offset),
 37412: 							       dashes,
 37412: 							       style->num_dashes,
 37412: 							       &strokeStyle);
 37412:     delete [] dashes;
 37412:     return strokeStyle;
 37412: }
 37412: 
 46437: static int _d2d_compute_bitmap_mem_size(ID2D1Bitmap *bitmap)
 46437: {
 46437:     D2D1_SIZE_U size = bitmap->GetPixelSize();
 46437:     int bytes_per_pixel = bitmap->GetPixelFormat().format == DXGI_FORMAT_A8_UNORM ? 1 : 4;
 46437:     return size.width * size.height * bytes_per_pixel;
 46437: }
 46437: 
 41226: cairo_user_data_key_t bitmap_key_nonextend;
 41226: cairo_user_data_key_t bitmap_key_extend;
 41226: cairo_user_data_key_t bitmap_key_snapshot;
 37412: 
 37412: struct cached_bitmap {
 49320:     cached_bitmap()
 49320:     {
 49320: 	sD2DFactory->AddRef();
 49320:     }
 49320: 
 49320:     ~cached_bitmap()
 49320:     {
 49320: 	// Clear bitmap out first because it depends on the factory.
 49320: 	bitmap = NULL;
 49320: 	_cairo_d2d_release_factory();
 49320:     }
 49320: 
 56617:     /* Device this cached bitmap was created with, we should really have a per
 56617:      * device cache, see bug 607408 */
 56617:     cairo_d2d_device_t *device;
 37412:     /** The cached bitmap */
 40634:     RefPtr<ID2D1Bitmap> bitmap;
 37412:     /** The cached bitmap is dirty and needs its data refreshed */
 37412:     bool dirty;
 37412:     /** Order of snapshot detach/release bitmap called not guaranteed, single threaded refcount for now */
 37412:     int refs;
 37412: };
 37412: 
 37412: /** 
 37412:  * This is called when user data on a surface is replaced or the surface is
 37412:  * destroyed.
 37412:  */
 37412: static void _d2d_release_bitmap(void *bitmap)
 37412: {
 40634:     cached_bitmap *existingBitmap = (cached_bitmap*)bitmap;
 40634:     if (!--existingBitmap->refs) {
 46437: 	cache_usage -= _d2d_compute_bitmap_mem_size(existingBitmap->bitmap);
 40634: 	delete existingBitmap;
 37412:     }
 37412: }
 37412: 
 37412: /**
 37412:  * Via a little trick this is just used to determine when a surface has been
 37412:  * modified.
 37412:  */
 37412: static void _d2d_snapshot_detached(cairo_surface_t *surface)
 37412: {
 41226:     cached_bitmap *existingBitmap = (cached_bitmap*)cairo_surface_get_user_data(surface, &bitmap_key_snapshot);
 37412:     if (existingBitmap) {
 37412: 	existingBitmap->dirty = true;
 37412:     }
 37412:     if (!--existingBitmap->refs) {
 46437: 	cache_usage -= _d2d_compute_bitmap_mem_size(existingBitmap->bitmap);
 37412: 	delete existingBitmap;
 37412:     }
 37412:     cairo_surface_destroy(surface);
 37412: }
 37412: 
 43850: /**
 43850:  * This function will calculate the part of srcSurf which will possibly be used within
 43850:  * the boundaries of d2dsurf given the current transformation mat. This is used to
 43850:  * determine what the minimal part of a surface is that needs to be uploaded.
 43850:  *
 43850:  * \param d2dsurf D2D surface
 43850:  * \param srcSurf Source surface for operation
 43850:  * \param mat Transformation matrix applied to source
 43850:  */
 43849: static void
 43849: _cairo_d2d_calculate_visible_rect(cairo_d2d_surface_t *d2dsurf, cairo_image_surface_t *srcSurf,
 43849: 				  cairo_matrix_t *mat,
 43849: 				  int *x, int *y, unsigned int *width, unsigned int *height)
 43849: {
 43849:     /** Leave room for extend_none space, 2 pixels */
 43849:     UINT32 maxSize = d2dsurf->rt->GetMaximumBitmapSize() - 2;
 43849: 
 43849:     /* Transform this surface to image surface space */
 43849:     cairo_matrix_t invMat = *mat;
 43849:     if (_cairo_matrix_is_invertible(mat)) {
 43849: 	/* If this is not invertible it will be rank zero, and invMat = mat is fine */
 43849: 	cairo_matrix_invert(&invMat);
 43849:     }
 43849: 
 43849:     RefPtr<IDXGISurface> surf;
 43849:     d2dsurf->surface->QueryInterface(&surf);
 43849:     DXGI_SURFACE_DESC desc;
 43849:     surf->GetDesc(&desc);
 43849: 
 43849:     double leftMost = 0;
 43849:     double rightMost = desc.Width;
 43849:     double topMost = 0;
 43849:     double bottomMost = desc.Height;
 43849: 
 43849:     _cairo_matrix_transform_bounding_box(&invMat, &leftMost, &topMost, &rightMost, &bottomMost, NULL);
 43849: 
 43849:     leftMost -= 1;
 43849:     topMost -= 1;
 43849:     rightMost += 1;
 43849:     bottomMost += 1;
 43849: 
 43849:     /* Calculate the offsets into the source image and the width of the part required */
 43849:     if ((UINT32)srcSurf->width > maxSize) {
 43849: 	*x = (int)MAX(0, floor(leftMost));
 43850: 	/* Ensure that we get atleast 1 column of pixels as source, this will make EXTEND_PAD work */
 43850: 	if (*x < srcSurf->width) {
 43850: 	    *width = (unsigned int)MIN(MAX(1, ceil(rightMost - *x)), srcSurf->width - *x);
 43850: 	} else {
 43850: 	    *x = srcSurf->width - 1;
 43850: 	    *width = 1;
 43850: 	}
 43849:     } else {
 43849: 	*x = 0;
 43849: 	*width = srcSurf->width;
 43849:     }
 43849: 
 43849:     if ((UINT32)srcSurf->height > maxSize) {
 43849: 	*y = (int)MAX(0, floor(topMost));
 43850: 	/* Ensure that we get atleast 1 row of pixels as source, this will make EXTEND_PAD work */
 43850: 	if (*y < srcSurf->height) {
 43850: 	    *height = (unsigned int)MIN(MAX(1, ceil(bottomMost - *y)), srcSurf->height - *y);
 43850: 	} else {
 43850: 	    *y = srcSurf->height - 1;
 43850: 	    *height = 1;
 43850: 	}
 43849:     } else {
 43849: 	*y = 0;
 43849: 	*height = srcSurf->height;
 43849:     }
 43849: }
 43849: 
 48300: static double
 48300: _cairo_d2d_point_dist(const cairo_point_double_t &p1, const cairo_point_double_t &p2)
 48300: {
 48300:     return hypot(p2.x - p1.x, p2.y - p1.y);
 48300: }
 48300: 
 48353: static void
 48353: _cairo_d2d_normalize_point(cairo_point_double_t *p)
 48353: {
 48353:     double length = hypot(p->x, p->y);
 48353:     p->x /= length;
 48353:     p->y /= length;
 48353: }
 48353: 
 48353: static cairo_point_double_t
 48353: _cairo_d2d_subtract_point(const cairo_point_double_t &p1, const cairo_point_double_t &p2)
 48353: {
 48353:     cairo_point_double_t p = {p1.x - p2.x, p1.y - p2.y};
 48353:     return p;
 48353: }
 48353: 
 48353: static double
 48353: _cairo_d2d_dot_product(const cairo_point_double_t &p1, const cairo_point_double_t &p2)
 48353: {
 48353:     return p1.x * p2.x + p1.y * p2.y;
 48353: }
 48353: 
 48300: static RefPtr<ID2D1Brush>
 48300: _cairo_d2d_create_radial_gradient_brush(cairo_d2d_surface_t *d2dsurf,
 48300: 					cairo_radial_pattern_t *source_pattern)
 48300: {
 48300:     cairo_matrix_t inv_mat = source_pattern->base.base.matrix;
 48300:     if (_cairo_matrix_is_invertible(&inv_mat)) {
 48300: 	/* If this is not invertible it will be rank zero, and invMat = mat is fine */
 48300: 	cairo_matrix_invert(&inv_mat);
 48300:     }
 48300: 
 48300:     D2D1_BRUSH_PROPERTIES brushProps =
 48300: 	D2D1::BrushProperties(1.0, _cairo_d2d_matrix_from_matrix(&inv_mat));
 48300: 
 48300:     if ((source_pattern->c1.x != source_pattern->c2.x ||
 48300: 	source_pattern->c1.y != source_pattern->c2.y) &&
 48300: 	source_pattern->r1 != 0) {
 48300: 	    /**
 48300: 	     * In this particular case there's no way to deal with this!
 48300: 	     * \todo Create an image surface with the gradient and use that.
 48300: 	     */
 48300: 	    return NULL;
 48300:     }
 48300: 
 48300:     D2D_POINT_2F center =
 48300: 	_d2d_point_from_cairo_point(&source_pattern->c2);
 48300:     D2D_POINT_2F origin =
 48300: 	_d2d_point_from_cairo_point(&source_pattern->c1);
 48300:     origin.x -= center.x;
 48300:     origin.y -= center.y;
 48300: 
 48300:     float outer_radius = _cairo_fixed_to_float(source_pattern->r2);
 48300:     float inner_radius = _cairo_fixed_to_float(source_pattern->r1);
 48300:     int num_stops = source_pattern->base.n_stops;
 48300:     int repeat_count = 1;
 48300:     D2D1_GRADIENT_STOP *stops;
 48300: 
 48300:     if (source_pattern->base.base.extend == CAIRO_EXTEND_REPEAT || source_pattern->base.base.extend == CAIRO_EXTEND_REFLECT) {
 48300: 	bool reflected = false;
 48300: 	bool reflect = source_pattern->base.base.extend == CAIRO_EXTEND_REFLECT;
 48300: 
 48300: 	RefPtr<IDXGISurface> surf;
 48300: 	d2dsurf->surface->QueryInterface(&surf);
 48300: 	DXGI_SURFACE_DESC desc;
 48300: 	surf->GetDesc(&desc);
 48300: 
 48300: 	// Calculate the largest distance the origin could be from the edge after inverse
 48300: 	// transforming by the pattern transformation.
 48300: 	cairo_point_double_t top_left, top_right, bottom_left, bottom_right, gradient_center;
 48300: 	top_left.x = bottom_left.x = top_left.y = top_right.y = 0;
 48300: 	top_right.x = bottom_right.x = desc.Width;
 48300: 	bottom_right.y = bottom_left.y = desc.Height;
 48300: 
 48300: 	gradient_center.x = _cairo_fixed_to_float(source_pattern->c1.x);
 48300: 	gradient_center.y = _cairo_fixed_to_float(source_pattern->c1.y);
 48300: 
 48300: 	// Transform surface corners into pattern coordinates.
 48300: 	cairo_matrix_transform_point(&source_pattern->base.base.matrix, &top_left.x, &top_left.y);
 48300: 	cairo_matrix_transform_point(&source_pattern->base.base.matrix, &top_right.x, &top_right.y);
 48300: 	cairo_matrix_transform_point(&source_pattern->base.base.matrix, &bottom_left.x, &bottom_left.y);
106422: 	cairo_matrix_transform_point(&source_pattern->base.base.matrix, &bottom_right.x, &bottom_right.y);
 48300: 
 48300: 	// Find the corner furthest away from the gradient center in pattern space.
 48300: 	double largest = MAX(_cairo_d2d_point_dist(top_left, gradient_center), _cairo_d2d_point_dist(top_right, gradient_center));
 48300: 	largest = MAX(largest, _cairo_d2d_point_dist(bottom_left, gradient_center));
 48300: 	largest = MAX(largest, _cairo_d2d_point_dist(bottom_right, gradient_center));
 48300: 
 48300: 	unsigned int minSize = (unsigned int)ceil(largest);
 48300: 
 48300: 	// Calculate how often we need to repeat on the inside (for filling the inner radius)
 48300: 	// and on the outside (for covering the entire surface) and create the appropriate number
 48300: 	// of stops.
 48300: 	float gradient_length = outer_radius - inner_radius;
 48300: 	int inner_repeat = (int)ceil(inner_radius / gradient_length);
 48300: 	int outer_repeat = (int)MAX(1, ceil((minSize - inner_radius) / gradient_length));
 48300: 	num_stops *= (inner_repeat + outer_repeat);
 48300: 	stops = new D2D1_GRADIENT_STOP[num_stops];
 48300: 
 48300: 	// Change outer_radius to the true outer radius after taking into account the needed
 48300: 	// repeats.
 48300: 	outer_radius = (inner_repeat + outer_repeat) * gradient_length;
 48300: 
 48300: 	float stop_scale = 1.0f / (inner_repeat + outer_repeat);
 48300: 
 48300: 	float inner_position = (inner_repeat * gradient_length) / outer_radius;
 48300: 	if (reflect) {
 48300: 	    // We start out reflected (meaning reflected starts as false since it will
 48300: 	    // immediately be inverted) if the inner_repeats are uneven.
 48300: 	    reflected = !(inner_repeat & 0x1);
 48300: 
 48300: 	    for (int i = 0; i < num_stops; i++) {
 48300: 		if (!(i % source_pattern->base.n_stops)) {
 48300: 		    // Reflect here
 48300: 		    reflected = !reflected;
 48300: 		}
 48300: 		// Calculate the repeat count.
 48300: 		int repeat = i / source_pattern->base.n_stops;
 48300: 		// Take the stop that we're using in the pattern.
 48300: 		int stop = i % source_pattern->base.n_stops;
 48300: 		if (reflected) {
 48300: 		    // Take the stop from the opposite side when reflected.
 48300: 		    stop = source_pattern->base.n_stops - stop - 1;
 48300: 		    // When reflected take 1 - offset as the offset.
 48300: 		    stops[i].position = (FLOAT)((repeat + 1.0f - source_pattern->base.stops[stop].offset) * stop_scale);
 48300: 		} else {
 48300: 		    stops[i].position = (FLOAT)((repeat + source_pattern->base.stops[stop].offset) * stop_scale);
 48300: 		}
 48300: 		stops[i].color =
 70960: 		    _cairo_d2d_color_from_cairo_color_stop(source_pattern->base.stops[stop].color);
 48300: 	    }
 48300: 	} else {
 48300: 	    // Simple case, we don't need to reflect.
 48300: 	    for (int i = 0; i < num_stops; i++) {
 48300: 		// Calculate which repeat this is.
 48300: 		int repeat = i / source_pattern->base.n_stops;
 48300: 		// Calculate which stop this would be in the original pattern
 48300: 		cairo_gradient_stop_t *stop = &source_pattern->base.stops[i % source_pattern->base.n_stops];
 48300: 		stops[i].position = (FLOAT)((repeat + stop->offset) * stop_scale);
 70960: 		stops[i].color = _cairo_d2d_color_from_cairo_color_stop(stop->color);
 48300: 	    }
 48300: 	}
 48300:     } else if (source_pattern->base.base.extend == CAIRO_EXTEND_PAD) {
 48300: 	float offset_factor = (outer_radius - inner_radius) / outer_radius;
 48300: 	float global_offset = inner_radius / outer_radius;
 48300: 
 48300: 	stops = new D2D1_GRADIENT_STOP[num_stops];
 48300: 
 48300: 	// If the inner radius is not 0 we need to scale and offset the stops.
 48300: 	for (unsigned int i = 0; i < source_pattern->base.n_stops; i++) {
 48300: 	    cairo_gradient_stop_t *stop = &source_pattern->base.stops[i];
 48300: 	    stops[i].position = (FLOAT)(global_offset + stop->offset * offset_factor);
 70960: 	    stops[i].color = _cairo_d2d_color_from_cairo_color_stop(stop->color);
 48300: 	}
 48300:     } else if (source_pattern->base.base.extend == CAIRO_EXTEND_NONE) {
 48300: 	float offset_factor = (outer_radius - inner_radius) / outer_radius;
 48300: 	float global_offset = inner_radius / outer_radius;
 48300: 
 48300: 	num_stops++; // Add a stop on the outer radius.
 48300: 	if (inner_radius != 0) {
 48300: 	    num_stops++; // Add a stop on the inner radius.
 48300: 	}
 48300: 
 48300: 	stops = new D2D1_GRADIENT_STOP[num_stops];
 48300: 
 48300: 	// If the inner radius is not 0 we need to scale and offset the stops and put a stop before the inner_radius
 48300: 	// of a transparent color.
 48300: 	int i = 0;
 48300: 	if (inner_radius != 0) {
 48300: 	    stops[i].position = global_offset;
 48300: 	    stops[i].color = D2D1::ColorF(0, 0);
 48300: 	    i++;
 48300: 	}
 48300: 	for (unsigned int j = 0; j < source_pattern->base.n_stops; j++, i++) {
 48300: 	    cairo_gradient_stop_t *stop = &source_pattern->base.stops[j];
 48300: 	    stops[i].position = (FLOAT)(global_offset + stop->offset * offset_factor);
 70960: 	    stops[i].color = _cairo_d2d_color_from_cairo_color_stop(stop->color);
 48300: 	}
 48300: 	stops[i].position = 1.0f;
 48300: 	stops[i].color = D2D1::ColorF(0, 0);
 48300:     } else {
 48300: 	return NULL;
 48300:     }
 48300: 
 48300:     RefPtr<ID2D1GradientStopCollection> stopCollection;
 48300:     d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &stopCollection);
 48300:     RefPtr<ID2D1RadialGradientBrush> brush;
 48300: 
 48300:     d2dsurf->rt->CreateRadialGradientBrush(D2D1::RadialGradientBrushProperties(center,
 48300: 									       origin,
 48300: 									       outer_radius,
 48300: 									       outer_radius),
 48300: 					   brushProps,
 48300: 					   stopCollection,
 48300: 					   &brush);
 48300:     delete [] stops;
 48300:     return brush;
 48300: }
 48300: 
 48353: static RefPtr<ID2D1Brush>
 48353: _cairo_d2d_create_linear_gradient_brush(cairo_d2d_surface_t *d2dsurf,
106422: 					cairo_path_fixed_t *fill_path,
 48353: 					cairo_linear_pattern_t *source_pattern)
 48353: {
 48353:     if (source_pattern->p1.x == source_pattern->p2.x &&
 48353: 	source_pattern->p1.y == source_pattern->p2.y) {
 48353: 	// Cairo behavior in this situation is to draw a solid color the size of the last stop.
 48353: 	RefPtr<ID2D1SolidColorBrush> brush;
 48353: 	d2dsurf->rt->CreateSolidColorBrush(
 70960: 	    _cairo_d2d_color_from_cairo_color_stop(source_pattern->base.stops[source_pattern->base.n_stops - 1].color),
 48353: 	    &brush);
 48353: 	return brush;
 48353:     }
 48353: 
 48353:     cairo_matrix_t inv_mat = source_pattern->base.base.matrix;
 48353:     /**
 48353:      * Cairo views this matrix as the transformation of the destination
 48353:      * when the pattern is imposed. We see this differently, D2D transformation
 48353:      * moves the pattern over the destination.
 48353:      */
 48353:     if (_cairo_matrix_is_invertible(&inv_mat)) {
 48353: 	/* If this is not invertible it will be rank zero, and invMat = mat is fine */
 48353: 	cairo_matrix_invert(&inv_mat);
 48353:     }
 48353:     D2D1_BRUSH_PROPERTIES brushProps =
 48353: 	D2D1::BrushProperties(1.0, _cairo_d2d_matrix_from_matrix(&inv_mat));
 48353:     cairo_point_double_t p1, p2;
 48353:     p1.x = _cairo_fixed_to_float(source_pattern->p1.x);
 48353:     p1.y = _cairo_fixed_to_float(source_pattern->p1.y);
 48353:     p2.x = _cairo_fixed_to_float(source_pattern->p2.x);
 48353:     p2.y = _cairo_fixed_to_float(source_pattern->p2.y);
 48353: 
 48353:     D2D1_GRADIENT_STOP *stops;
 48353:     int num_stops = source_pattern->base.n_stops;
 48353:     if (source_pattern->base.base.extend == CAIRO_EXTEND_REPEAT || source_pattern->base.base.extend == CAIRO_EXTEND_REFLECT) {
106422: 	// Get this when the points are not transformed yet.
106422: 	double gradient_length = _cairo_d2d_point_dist(p1, p2);
106422:         cairo_point_double_t top_left, top_right, bottom_left, bottom_right;
106422: 
106422:         if (fill_path) {
106422:             // Calculate the repeat count needed;
106422:             cairo_box_t fill_extents;
106422:             _cairo_path_fixed_extents (fill_path, &fill_extents);
106422: 
106422: 	    top_left.x = bottom_left.x = _cairo_fixed_to_double (fill_extents.p1.x);
106422: 	    top_left.y = top_right.y = _cairo_fixed_to_double (fill_extents.p1.y);
106422: 	    top_right.x = bottom_right.x = _cairo_fixed_to_double (fill_extents.p2.x);
106422: 	    bottom_right.y = bottom_left.y = _cairo_fixed_to_double (fill_extents.p2.y);
106422:         } else {
 48353:             RefPtr<IDXGISurface> surf;
 48353:             d2dsurf->surface->QueryInterface(&surf);
 48353:             DXGI_SURFACE_DESC desc;
 48353:             surf->GetDesc(&desc);
 48353: 
106422:             top_left.x = bottom_left.x = 0;
106422:             top_left.y = top_right.y = 0;
 48353:             top_right.x = bottom_right.x = desc.Width;
 48353:             bottom_right.y = bottom_left.y = desc.Height;
106422:         }
106422: 
 48353: 	// Transform the corners of our surface to pattern space.
 48353: 	cairo_matrix_transform_point(&source_pattern->base.base.matrix, &top_left.x, &top_left.y);
 48353: 	cairo_matrix_transform_point(&source_pattern->base.base.matrix, &top_right.x, &top_right.y);
 48353: 	cairo_matrix_transform_point(&source_pattern->base.base.matrix, &bottom_left.x, &bottom_left.y);
106422: 	cairo_matrix_transform_point(&source_pattern->base.base.matrix, &bottom_right.x, &bottom_right.y);
 48353: 
 48353: 	cairo_point_double_t u;
 48353: 	// Unit vector of the gradient direction.
 48353: 	u = _cairo_d2d_subtract_point(p2, p1);
 48353: 	_cairo_d2d_normalize_point(&u);
 48353: 
 48353: 	// (corner - p1) . u = |corner - p1| cos(a) where a is the angle between the two vectors.
 48353: 	// Coincidentally |corner - p1| cos(a) is actually also the distance our gradient needs to cover since
 48353: 	// at this point on the gradient line it will be perpendicular to the line running from the gradient
 48353: 	// line through the corner.
 48353: 
 48353: 	double max_dist, min_dist;
 48353: 	max_dist = MAX(_cairo_d2d_dot_product(u, _cairo_d2d_subtract_point(top_left, p1)),
 48353: 		       _cairo_d2d_dot_product(u, _cairo_d2d_subtract_point(top_right, p1)));
 48353: 	max_dist = MAX(max_dist, _cairo_d2d_dot_product(u, _cairo_d2d_subtract_point(bottom_left, p1)));
 48353: 	max_dist = MAX(max_dist, _cairo_d2d_dot_product(u, _cairo_d2d_subtract_point(bottom_right, p1)));
 48353: 	min_dist = MIN(_cairo_d2d_dot_product(u, _cairo_d2d_subtract_point(top_left, p1)),
 48353: 		       _cairo_d2d_dot_product(u, _cairo_d2d_subtract_point(top_right, p1)));
 48353: 	min_dist = MIN(min_dist, _cairo_d2d_dot_product(u, _cairo_d2d_subtract_point(bottom_left, p1)));
 48353: 	min_dist = MIN(min_dist, _cairo_d2d_dot_product(u, _cairo_d2d_subtract_point(bottom_right, p1)));
 48353: 
 48353: 	min_dist = MAX(-min_dist, 0);
 48353: 
 48353: 	// Repeats after gradient start.
109850:  	// It's possible for max_dist and min_dist to both be zero, in which case
109850:  	// we'll set num_stops to 0 and crash D2D. Let's just ensure after_repeat
109850:  	// is at least 1.
109850:  	int after_repeat = MAX((int)ceil(max_dist / gradient_length), 1);
 48353: 	int before_repeat = (int)ceil(min_dist / gradient_length);
 48353: 	num_stops *= (after_repeat + before_repeat);
 48353: 
 48353: 	p2.x = p1.x + u.x * after_repeat * gradient_length;
 48353: 	p2.y = p1.y + u.y * after_repeat * gradient_length;
 48353: 	p1.x = p1.x - u.x * before_repeat * gradient_length;
 48353: 	p1.y = p1.y - u.y * before_repeat * gradient_length;
 48353: 
 48353: 	float stop_scale = 1.0f / (float)(after_repeat + before_repeat);
 48353: 	float begin_position = (float)before_repeat / (float)(after_repeat + before_repeat);
 48353: 
 48353: 	stops = new D2D1_GRADIENT_STOP[num_stops];
 48353: 	if (source_pattern->base.base.extend == CAIRO_EXTEND_REFLECT) {
 48353: 	    // We start out reflected (meaning reflected starts as false since it will
 48353: 	    // immediately be inverted) if the inner_repeats are uneven.
 48353: 	    bool reflected = !(before_repeat & 0x1);
 48353: 
 48353: 	    for (int i = 0; i < num_stops; i++) {
 48353: 		if (!(i % source_pattern->base.n_stops)) {
 48353: 		    // Reflect here
 48353: 		    reflected = !reflected;
 48353: 		}
 48353: 		// Calculate the repeat count.
 48353: 		int repeat = i / source_pattern->base.n_stops;
 48353: 		// Take the stop that we're using in the pattern.
 48353: 		int stop = i % source_pattern->base.n_stops;
 48353: 		if (reflected) {
 48353: 		    // Take the stop from the opposite side when reflected.
 48353: 		    stop = source_pattern->base.n_stops - stop - 1;
 48353: 		    // When reflected take 1 - offset as the offset.
 48353: 		    stops[i].position = (FLOAT)((repeat + 1.0f - source_pattern->base.stops[stop].offset) * stop_scale);
 48353: 		} else {
 48353: 		    stops[i].position = (FLOAT)((repeat + source_pattern->base.stops[stop].offset) * stop_scale);
 48353: 		}
 48353: 		stops[i].color =
 70960: 		    _cairo_d2d_color_from_cairo_color_stop(source_pattern->base.stops[stop].color);
 48353: 	    }
 48353: 	} else {
 48353: 	    // Simple case, we don't need to reflect.
 48353: 	    for (int i = 0; i < num_stops; i++) {
 48353: 		// Calculate which repeat this is.
 48353: 		int repeat = i / source_pattern->base.n_stops;
 48353: 		// Calculate which stop this would be in the original pattern
 48353: 		cairo_gradient_stop_t *stop = &source_pattern->base.stops[i % source_pattern->base.n_stops];
 48353: 		stops[i].position = (FLOAT)((repeat + stop->offset) * stop_scale);
 70960: 		stops[i].color = _cairo_d2d_color_from_cairo_color_stop(stop->color);
 48353: 	    }
 48353: 	}
 48353:     } else if (source_pattern->base.base.extend == CAIRO_EXTEND_PAD) {
 48353: 	stops = new D2D1_GRADIENT_STOP[source_pattern->base.n_stops];
 48353: 	for (unsigned int i = 0; i < source_pattern->base.n_stops; i++) {
 48353: 	    cairo_gradient_stop_t *stop = &source_pattern->base.stops[i];
 48353: 	    stops[i].position = (FLOAT)stop->offset;
 70960: 	    stops[i].color = _cairo_d2d_color_from_cairo_color_stop(stop->color);
 48353: 	}
 48353:     } else if (source_pattern->base.base.extend == CAIRO_EXTEND_NONE) {
 48353: 	num_stops += 2;
 48353: 	stops = new D2D1_GRADIENT_STOP[num_stops];
 48353: 	stops[0].position = 0;
 48353: 	stops[0].color = D2D1::ColorF(0, 0);
 48353: 	for (unsigned int i = 1; i < source_pattern->base.n_stops + 1; i++) {
 48353: 	    cairo_gradient_stop_t *stop = &source_pattern->base.stops[i - 1];
 48353: 	    stops[i].position = (FLOAT)stop->offset;
 70960: 	    stops[i].color = _cairo_d2d_color_from_cairo_color_stop(stop->color);
 48353: 	}
 48353: 	stops[source_pattern->base.n_stops + 1].position = 1.0f;
 48353: 	stops[source_pattern->base.n_stops + 1].color = D2D1::ColorF(0, 0);
 48353:     }
 48353:     RefPtr<ID2D1GradientStopCollection> stopCollection;
 48353:     d2dsurf->rt->CreateGradientStopCollection(stops, num_stops, &stopCollection);
 48353:     RefPtr<ID2D1LinearGradientBrush> brush;
 48353:     d2dsurf->rt->CreateLinearGradientBrush(D2D1::LinearGradientBrushProperties(D2D1::Point2F((FLOAT)p1.x, (FLOAT)p1.y),
 48353: 									       D2D1::Point2F((FLOAT)p2.x, (FLOAT)p2.y)),
 48353: 					   brushProps,
 48353: 					   stopCollection,
 48353: 					   &brush);
 48353:     delete [] stops;
 48353:     return brush;
 48353: }
 48353: 
 37412: /**
 37412:  * This creates an ID2D1Brush that will fill with the correct pattern.
 37412:  * This function passes a -strong- reference to the caller, the brush
 42102:  * needs to be released, even if it is not unique.
 37412:  *
 37412:  * \param d2dsurf Surface to create a brush for
 37412:  * \param pattern The pattern to create a brush for
 37412:  * \param unique We cache the bitmap/color brush for speed. If this
 37412:  * needs a brush that is unique (i.e. when more than one is needed),
 37412:  * this will make the function return a seperate brush.
 37412:  * \return A brush object
 37412:  */
 60653: static RefPtr<ID2D1Brush>
 37412: _cairo_d2d_create_brush_for_pattern(cairo_d2d_surface_t *d2dsurf,
106422: 				    cairo_path_fixed_t *fill_path,
 37412: 				    const cairo_pattern_t *pattern,
 60653: 				    bool unique = false)
 37412: {
 98971:     HRESULT hr;
 98971: 
 37412:     if (pattern->type == CAIRO_PATTERN_TYPE_SOLID) {
 37412: 	cairo_solid_pattern_t *sourcePattern =
 37412: 	    (cairo_solid_pattern_t*)pattern;
 37412: 	D2D1_COLOR_F color = _cairo_d2d_color_from_cairo_color(sourcePattern->color);
 37412: 	if (unique) {
 40634: 	    RefPtr<ID2D1SolidColorBrush> brush;
 37412: 	    d2dsurf->rt->CreateSolidColorBrush(color,
 37412: 					       &brush);
 37412: 	    return brush;
 37412: 	} else {
 37412: 	    if (d2dsurf->solidColorBrush->GetColor().a != color.a ||
 37412: 		d2dsurf->solidColorBrush->GetColor().r != color.r ||
 37412: 		d2dsurf->solidColorBrush->GetColor().g != color.g ||
 37412: 		d2dsurf->solidColorBrush->GetColor().b != color.b) {
 37412: 		d2dsurf->solidColorBrush->SetColor(color);
 37412: 	    }
 37412: 	    return d2dsurf->solidColorBrush;
 37412: 	}
 37412: 
 37412:     } else if (pattern->type == CAIRO_PATTERN_TYPE_LINEAR) {
 48353: 	cairo_linear_pattern_t *source_pattern =
 37412: 	    (cairo_linear_pattern_t*)pattern;
106422: 	return _cairo_d2d_create_linear_gradient_brush(d2dsurf, fill_path, source_pattern);
 37412:     } else if (pattern->type == CAIRO_PATTERN_TYPE_RADIAL) {
 48300: 	cairo_radial_pattern_t *source_pattern =
 37412: 	    (cairo_radial_pattern_t*)pattern;
 48300: 	return _cairo_d2d_create_radial_gradient_brush(d2dsurf, source_pattern);
 37412:     } else if (pattern->type == CAIRO_PATTERN_TYPE_SURFACE) {
 37412: 	cairo_matrix_t mat = pattern->matrix;
 37412: 	cairo_matrix_invert(&mat);
 37412: 
 37412: 	cairo_surface_pattern_t *surfacePattern =
 37412: 	    (cairo_surface_pattern_t*)pattern;
 37412: 	D2D1_EXTEND_MODE extendMode;
 41226: 
 41226: 	cairo_user_data_key_t *key = &bitmap_key_extend;
 41226: 
 37412: 	if (pattern->extend == CAIRO_EXTEND_NONE) {
 37412: 	    extendMode = D2D1_EXTEND_MODE_CLAMP;
 41226: 	    key = &bitmap_key_nonextend;
 37412: 	    /** 
 50651: 	     * We create a slightly larger bitmap with a transparent border
 50651: 	     * around it for this case. Need to translate for that.
 37412: 	     */
 37412: 	    cairo_matrix_translate(&mat, -1.0, -1.0);
 37412: 	} else if (pattern->extend == CAIRO_EXTEND_REPEAT) {
 37412: 	    extendMode = D2D1_EXTEND_MODE_WRAP;
 37412: 	} else if (pattern->extend == CAIRO_EXTEND_REFLECT) {
 37412: 	    extendMode = D2D1_EXTEND_MODE_MIRROR;
 37412: 	} else {
 37412: 	    extendMode = D2D1_EXTEND_MODE_CLAMP;
 37412: 	}
 42102: 
 40663: 	RefPtr<ID2D1Bitmap> sourceBitmap;
 42101: 	bool partial = false;
 43849: 	int xoffset = 0;
 43849: 	int yoffset = 0;
 37412: 	unsigned int width;
 37412: 	unsigned int height;
 42101: 	unsigned char *data = NULL;
 42101:  	unsigned int stride = 0;
 42102: 
 37412: 	if (surfacePattern->surface->type == CAIRO_SURFACE_TYPE_D2D) {
 37412: 	    /**
 37412: 	     * \todo We need to somehow get a rectangular transparent
 37412: 	     * border here too!!
 37412: 	     */
 37412: 	    cairo_d2d_surface_t *srcSurf = 
 37412: 		reinterpret_cast<cairo_d2d_surface_t*>(surfacePattern->surface);
 37412: 	    
 47929: 	    if (srcSurf == d2dsurf) {
 47929: 		/* D2D cannot deal with self-copy. We should add an optimized
 47929: 		 * codepath for self-copy in the easy cases that does ping-pong like
 47929: 		 * scroll does. See bug 579215. For now fallback.
 47929: 		 */
 47929: 		return NULL;
 47929: 	    }
 56617: 	    if (srcSurf->device != d2dsurf->device) {
 56617: 		/* This code does not work if the source surface does not use
 56617: 		 * the same device. Some work could be done to do something
 56617: 		 * fairly efficient here, for now, fallback.
 56617: 		 */
 56617: 		return NULL;
 56617: 	    }
 47929: 
 37412: 	    _cairo_d2d_update_surface_bitmap(srcSurf);
 50651: 	    _cairo_d2d_flush(srcSurf);
 50651: 
 71557: 	    // Mark a dependency on the source surface.
 71557: 	    _cairo_d2d_add_dependent_surface(srcSurf, d2dsurf);
 71557: 
 50651: 	    if (pattern->extend == CAIRO_EXTEND_NONE) {
 50651: 		ID2D1Bitmap *srcSurfBitmap = srcSurf->surfaceBitmap;
 50651: 		d2dsurf->rt->CreateBitmap(
 50651: 		    D2D1::SizeU(srcSurfBitmap->GetPixelSize().width + 2,
 50651: 				srcSurfBitmap->GetPixelSize().height + 2),
 50651: 		    D2D1::BitmapProperties(srcSurfBitmap->GetPixelFormat()),
 50651: 		    &sourceBitmap);
 50651: 		D2D1_POINT_2U point = D2D1::Point2U(1, 1);
 50651: 		sourceBitmap->CopyFromBitmap(&point, srcSurfBitmap, NULL);
 50651: 	    } else {
 37412: 		sourceBitmap = srcSurf->surfaceBitmap;
 50651: 	    }
 50651: 
 37412: 	} else if (surfacePattern->surface->type == CAIRO_SURFACE_TYPE_IMAGE) {
 37412: 	    cairo_image_surface_t *srcSurf = 
 37412: 		reinterpret_cast<cairo_image_surface_t*>(surfacePattern->surface);
 37412: 	    D2D1_ALPHA_MODE alpha;
 37412: 	    if (srcSurf->format == CAIRO_FORMAT_ARGB32 ||
 37412: 		srcSurf->format == CAIRO_FORMAT_A8) {
 37412: 		alpha = D2D1_ALPHA_MODE_PREMULTIPLIED;
 37412: 	    } else {
 37412: 		alpha = D2D1_ALPHA_MODE_IGNORE;
 37412: 	    }
 37412: 
 42101: 	    data = srcSurf->data;
 42101: 	    stride = srcSurf->stride;
 42101: 
 42101: 	    /* This is used as a temporary surface for resampling surfaces larget than maxSize. */
 42101: 	    pixman_image_t *pix_image = NULL;
 42101: 
 37412: 	    DXGI_FORMAT format;
 37412: 	    unsigned int Bpp;
 37412: 	    if (srcSurf->format == CAIRO_FORMAT_ARGB32) {
 37412: 		format = DXGI_FORMAT_B8G8R8A8_UNORM;
 37412: 		Bpp = 4;
 37412: 	    } else if (srcSurf->format == CAIRO_FORMAT_RGB24) {
 37412: 		format = DXGI_FORMAT_B8G8R8A8_UNORM;
 37412: 		Bpp = 4;
 37412: 	    } else if (srcSurf->format == CAIRO_FORMAT_A8) {
 37412: 		format = DXGI_FORMAT_A8_UNORM;
 37412: 		Bpp = 1;
 37412: 	    } else {
 37412: 		return NULL;
 37412: 	    }
 37412: 
 37412: 	    /** Leave room for extend_none space, 2 pixels */
 37412: 	    UINT32 maxSize = d2dsurf->rt->GetMaximumBitmapSize() - 2;
 37412: 
 37412: 	    if ((UINT32)srcSurf->width > maxSize || (UINT32)srcSurf->height > maxSize) {
 43850: 		if (pattern->extend == CAIRO_EXTEND_REPEAT ||
 43850: 		    pattern->extend == CAIRO_EXTEND_REFLECT) {
 43850: 		    // XXX - we don't have code to deal with these yet.
 43850: 		    return NULL;
 43850: 		}
 43850: 
 42101: 		/* We cannot fit this image directly into a texture, start doing tricks to draw correctly anyway. */
 42101: 		partial = true;
 43849: 
 42101: 		/* First we check which part of the image is inside the viewable area. */
 43849:   		_cairo_d2d_calculate_visible_rect(d2dsurf, srcSurf, &mat, &xoffset, &yoffset, &width, &height);
 42101: 
 42101: 		cairo_matrix_translate(&mat, xoffset, yoffset);
 42101: 
 42101: 		if (width > maxSize || height > maxSize) {
 42101: 		    /*
 42101: 		     * We cannot upload the required part of the surface directly, we're going to create
 42101: 		     * a version which is downsampled to a smaller size by pixman and then uploaded.
 42101: 		     *
 42101: 		     * We need to size it to at least the diagonal size of this surface, in order to prevent ever
 42101: 		     * upsampling this again when drawing it to the surface. We want the resized surface
 42101: 		     * to be as small as possible to limit pixman required fill rate.
 42101: 		     *
 42101: 		     * Note this isn't necessarily perfect. Imagine having a 5x5 pixel destination and
 42101: 		     * a 10x5 image containing a line of blackpixels, white pixels, black pixels, if you rotate
 42101: 		     * this by 45 degrees and scale it to a size of 5x5 pixels and composite it to the destination,
 42101: 		     * the composition will require all 10 original columns to do the best possible sampling.
 42101: 		     */
 43849: 		    RefPtr<IDXGISurface> surf;
 43849: 		    d2dsurf->surface->QueryInterface(&surf);
 43849: 		    DXGI_SURFACE_DESC desc;
 43849: 		    surf->GetDesc(&desc);
 43849: 
 42101: 		    unsigned int minSize = (unsigned int)ceil(sqrt(pow((float)desc.Width, 2) + pow((float)desc.Height, 2)));
 42101: 		    
 42101: 		    unsigned int newWidth = MIN(minSize, MIN(width, maxSize));
 42101: 		    unsigned int newHeight = MIN(minSize, MIN(height, maxSize));
 42101: 		    double xRatio = (double)width / newWidth;
 42101: 		    double yRatio = (double)height / newHeight;
 42101: 
 42101: 		    if (newWidth > maxSize || newHeight > maxSize) {
 42101: 			/*
 42101: 			 * Okay, the diagonal of our surface is big enough to require a sampling larger
 42101: 			 * than the maximum texture size. This is where we give up.
 42101: 			 */
 42101: 			return NULL;
 42101:   		    }
 42101: 
 42101: 		    /* Create a temporary surface to hold the downsampled image */
 42101: 		    pix_image = pixman_image_create_bits(srcSurf->pixman_format,
 42101: 							 newWidth,
 42101: 							 newHeight,
 42101: 							 NULL,
 42101: 							 -1);
 42101: 
 42101: 		    /* Set the transformation to downsample and call pixman_image_composite to downsample */
 42101: 		    pixman_transform_t transform;
 42101: 		    pixman_transform_init_scale(&transform, pixman_double_to_fixed(xRatio), pixman_double_to_fixed(yRatio));
 42101: 		    pixman_transform_translate(&transform, NULL, pixman_int_to_fixed(xoffset), pixman_int_to_fixed(yoffset));
 42101: 
 42101: 		    pixman_image_set_transform(srcSurf->pixman_image, &transform);
 42101: 		    pixman_image_composite(PIXMAN_OP_SRC, srcSurf->pixman_image, NULL, pix_image, 0, 0, 0, 0, 0, 0, newWidth, newHeight);
 42101: 
 42101: 		    /* Adjust the pattern transform to the used temporary surface */
 42101: 		    cairo_matrix_scale(&mat, xRatio, yRatio);
 42101: 
 42101: 		    data = (unsigned char*)pixman_image_get_data(pix_image);
 42101: 		    stride = pixman_image_get_stride(pix_image);
 42101: 
 42101: 		    /* Into this image we actually have no offset */
 42101: 		    xoffset = 0;
 42101: 		    yoffset = 0;
 42101: 		    width = newWidth;
 42101: 		    height = newHeight;
 37412:   		}
 37412: 	    } else {
 37412: 		width = srcSurf->width;
 37412: 		height = srcSurf->height;
 37412: 	    }
 37412: 
 37412: 	    cached_bitmap *cachebitmap = NULL;
 41226: 
 42101: 	    if (!partial) {
 37412: 		cachebitmap = 
 37412: 		    (cached_bitmap*)cairo_surface_get_user_data(
 37412: 		    surfacePattern->surface,
 41226: 		    key);
 56617: 		if (cachebitmap && cachebitmap->device != d2dsurf->device) {
 56617: 		    cachebitmap = NULL;
 56617: 		}
 37412: 	    }
 37412: 
 41226: 	    if (cachebitmap) {
 37412: 		sourceBitmap = cachebitmap->bitmap;
 37412: 		if (cachebitmap->dirty) {
 37412: 		    D2D1_RECT_U rect;
 42101: 		    /* No need to take partial uploading into account - partially uploaded surfaces are never cached. */
 41226: 		    if (pattern->extend == CAIRO_EXTEND_NONE) {
 37412: 			rect = D2D1::RectU(1, 1, srcSurf->width + 1, srcSurf->height + 1);
 37412: 		    } else {
 37412: 			rect = D2D1::RectU(0, 0, srcSurf->width, srcSurf->height);
 37412: 		    }
 37412: 		    sourceBitmap->CopyFromMemory(&rect,
 37412: 						 srcSurf->data,
 37412: 						 srcSurf->stride);
 37412: 		    cairo_surface_t *nullSurf =
 88623: 			cairo_null_surface_create(CAIRO_CONTENT_COLOR_ALPHA);
 37412: 		    cachebitmap->refs++;
 40632: 		    cachebitmap->dirty = false;
 37412: 		    cairo_surface_set_user_data(nullSurf,
 41226: 						&bitmap_key_snapshot,
 37412: 						cachebitmap,
 37412: 						NULL);
 88623: 		    cairo_surface_attach_snapshot(surfacePattern->surface,
 37412: 						   nullSurf,
 37412: 						   _d2d_snapshot_detached);
 37412: 		}
 37412: 	    } else {
 37412: 		if (pattern->extend != CAIRO_EXTEND_NONE) {
 98971: 		    hr = d2dsurf->rt->CreateBitmap(D2D1::SizeU(width, height),
 42101: 						   data + yoffset * stride + xoffset * Bpp,
 42101: 						   stride,
 37412: 						   D2D1::BitmapProperties(D2D1::PixelFormat(format,
 37412: 											    alpha)),
 37412: 						   &sourceBitmap);
 98971: 
 98971: 		    if (FAILED(hr)) {
 98971: 			return NULL;
 98971: 		    }
 37412: 		} else {
 37412: 		    /**
 37412: 		     * Trick here, we create a temporary rectangular
 37412: 		     * surface with 1 pixel margin on each side. This
 37412: 		     * provides a rectangular transparent border, that
 37412: 		     * will ensure CLAMP acts as EXTEND_NONE. Perhaps
 37412: 		     * this could be further optimized by not memsetting
 37412: 		     * the whole array.
 37412: 		     */
 37412: 		    unsigned int tmpWidth = width + 2;
 37412: 		    unsigned int tmpHeight = height + 2;
 37412: 		    unsigned char *tmp = new unsigned char[tmpWidth * tmpHeight * Bpp];
 37412: 		    memset(tmp, 0, tmpWidth * tmpHeight * Bpp);
 37412: 		    for (unsigned int y = 0; y < height; y++) {
 37412: 			memcpy(
 37412: 			    tmp + tmpWidth * Bpp * y + tmpWidth * Bpp + Bpp, 
 42101: 			    data + yoffset * stride + y * stride + xoffset * Bpp, 
 37412: 			    width * Bpp);
 37412: 		    }
 37412: 
 98971: 		    hr = d2dsurf->rt->CreateBitmap(D2D1::SizeU(tmpWidth, tmpHeight),
 37412: 						   tmp,
 37412: 						   tmpWidth * Bpp,
 37412: 						   D2D1::BitmapProperties(D2D1::PixelFormat(format,
 37412: 					 						    D2D1_ALPHA_MODE_PREMULTIPLIED)),
 37412: 						   &sourceBitmap);
 98971: 
 37412: 		    delete [] tmp;
 98971: 		    if (FAILED(hr)) {
 98971: 			return NULL;
 98971: 		    }
 37412: 		}
 37412: 
 42101: 		if (!partial) {
 42101: 		    cached_bitmap *cachebitmap = new cached_bitmap;
 42101: 		    /* We can cache it if it isn't a partial bitmap */
 37412: 		    cachebitmap->dirty = false;
 37412: 		    cachebitmap->bitmap = sourceBitmap;
 56617: 		    cachebitmap->device = d2dsurf->device;
 42101: 		    /*
 42101: 		     * This will start out with two references, one on the snapshot
 42101: 		     * and one more in the user data structure.
 42101: 		     */
 37412: 		    cachebitmap->refs = 2;
 37412: 		    cairo_surface_set_user_data(surfacePattern->surface,
 41226: 						key,
 37412: 						cachebitmap,
 37412: 						_d2d_release_bitmap);
 37412: 		    cairo_surface_t *nullSurf =
 88623: 			cairo_null_surface_create(CAIRO_CONTENT_COLOR_ALPHA);
 37412: 		    cairo_surface_set_user_data(nullSurf,
 41226: 						&bitmap_key_snapshot,
 37412: 						cachebitmap,
 37412: 						NULL);
 88623: 		    cairo_surface_attach_snapshot(surfacePattern->surface,
 37412: 						   nullSurf,
 37412: 						   _d2d_snapshot_detached);
 46437: 		    cache_usage += _d2d_compute_bitmap_mem_size(sourceBitmap);
 37412: 		}
 42101: 		if (pix_image) {
 42101: 		    pixman_image_unref(pix_image);
 42101:   		}
 42101: 	    }
 37412: 	} else {
 37412: 	    return NULL;
 37412: 	}
 37412: 	D2D1_BITMAP_BRUSH_PROPERTIES bitProps;
 37412: 	
 37412: 	if (surfacePattern->base.filter == CAIRO_FILTER_NEAREST) {
 37412: 	    bitProps = D2D1::BitmapBrushProperties(extendMode, 
 37412: 						   extendMode,
 37412: 						   D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR);
 37412: 	} else {
 37412: 	    bitProps = D2D1::BitmapBrushProperties(extendMode,
 37412: 						   extendMode,
 37412: 						   D2D1_BITMAP_INTERPOLATION_MODE_LINEAR);
 37412: 	}
 37412: 	if (unique) {
 40634: 	    RefPtr<ID2D1BitmapBrush> bitBrush;
 37412: 	    D2D1_BRUSH_PROPERTIES brushProps =
 37412: 		D2D1::BrushProperties(1.0, _cairo_d2d_matrix_from_matrix(&mat));
 37412: 	    d2dsurf->rt->CreateBitmapBrush(sourceBitmap, 
 37412: 					   &bitProps,
 37412: 					   &brushProps,
 37412: 					   &bitBrush);
 37412: 	    return bitBrush;
 37412: 	} else {
 37412: 	    D2D1_MATRIX_3X2_F matrix = _cairo_d2d_matrix_from_matrix(&mat);
 37412: 
 37412: 	    if (d2dsurf->bitmapBrush) {
 37412: 		d2dsurf->bitmapBrush->SetTransform(matrix);
 37412: 
 37412: 		if (surfacePattern->base.filter == CAIRO_FILTER_NEAREST) {
 37412: 		    d2dsurf->bitmapBrush->SetInterpolationMode(D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR);
 37412: 		} else {
 37412: 		    d2dsurf->bitmapBrush->SetInterpolationMode(D2D1_BITMAP_INTERPOLATION_MODE_LINEAR);
 37412: 		}
 37412: 
 37412: 		d2dsurf->bitmapBrush->SetBitmap(sourceBitmap);
 37412: 		d2dsurf->bitmapBrush->SetExtendModeX(extendMode);
 37412: 		d2dsurf->bitmapBrush->SetExtendModeY(extendMode);
 37412: 	    } else {
 37412: 		D2D1_BRUSH_PROPERTIES brushProps =
 37412: 		    D2D1::BrushProperties(1.0, _cairo_d2d_matrix_from_matrix(&mat));
 37412: 		d2dsurf->rt->CreateBitmapBrush(sourceBitmap,
 37412: 					       &bitProps,
 37412: 					       &brushProps,
 37412: 					       &d2dsurf->bitmapBrush);
 37412: 	    }
 37412: 	    return d2dsurf->bitmapBrush;
 37412: 	}
 37412:     } else {
 37412: 	return NULL;
 37412:     }
 37412: }
 37412: 
 37412: 
 37412: /** Path Conversion */
 37412: 
 37412: /**
 37412:  * Structure to use for the closure, containing all needed data.
 37412:  */
 37412: struct path_conversion {
 37412:     /** Geometry sink that we need to write to */
 37412:     ID2D1GeometrySink *sink;
 37412:     /** 
 37412:      * If this figure is active, cairo doesn't always send us a close. But
 37412:      * we do need to end this figure if it didn't.
 37412:      */
 37412:     bool figureActive;
 37412:     /**
 37412:      * Current point, D2D has no explicit move so we need to track moved for
 37412:      * the next begin.
 37412:      */
 37412:     cairo_point_t current_point;
 37412:     /** The type of figure begin for this geometry instance */
 37412:     D2D1_FIGURE_BEGIN type;
 37412: };
 37412: 
 37412: static cairo_status_t
 37412: _cairo_d2d_path_move_to(void		 *closure,
 37412: 			const cairo_point_t *point)
 37412: {
 37412:     path_conversion *pathConvert =
 37412: 	static_cast<path_conversion*>(closure);
 37412:     if (pathConvert->figureActive) {
 37412: 	pathConvert->sink->EndFigure(D2D1_FIGURE_END_OPEN);
 37412: 	pathConvert->figureActive = false;
 37412:     }
 37412: 
 37412:     pathConvert->current_point = *point;
 37412:     return CAIRO_STATUS_SUCCESS;
 37412: }
 37412: 
 37412: static cairo_status_t
 37412: _cairo_d2d_path_line_to(void		    *closure,
 37412: 			const cairo_point_t *point)
 37412: {
 37412:     path_conversion *pathConvert =
 37412: 	static_cast<path_conversion*>(closure);
 37412:     if (!pathConvert->figureActive) {
 37412: 	pathConvert->sink->BeginFigure(_d2d_point_from_cairo_point(&pathConvert->current_point),
 37412: 				       pathConvert->type);
 37412: 	pathConvert->figureActive = true;
 37412:     }
 37412: 
 37412:     D2D1_POINT_2F d2dpoint = _d2d_point_from_cairo_point(point);
 37412: 
 37412:     pathConvert->sink->AddLine(d2dpoint);
 37412:     return CAIRO_STATUS_SUCCESS;
 37412: }
 37412: 
 37412: static cairo_status_t
 37412: _cairo_d2d_path_curve_to(void	  *closure,
 37412: 			 const cairo_point_t *p0,
 37412: 			 const cairo_point_t *p1,
 37412: 			 const cairo_point_t *p2)
 37412: {
 37412:     path_conversion *pathConvert =
 37412: 	static_cast<path_conversion*>(closure);
 37412:     if (!pathConvert->figureActive) {
 37412: 	pathConvert->sink->BeginFigure(_d2d_point_from_cairo_point(&pathConvert->current_point),
 37412: 				       D2D1_FIGURE_BEGIN_FILLED);
 37412: 	pathConvert->figureActive = true;
 37412:     }
 37412: 
 37412:     pathConvert->sink->AddBezier(D2D1::BezierSegment(_d2d_point_from_cairo_point(p0),
 37412: 						     _d2d_point_from_cairo_point(p1),
 37412: 						     _d2d_point_from_cairo_point(p2)));
 37412: 	
 37412:     return CAIRO_STATUS_SUCCESS;
 37412: }
 37412: 
 37412: static cairo_status_t
 37412: _cairo_d2d_path_close(void *closure)
 37412: {
 37412:     path_conversion *pathConvert =
 37412: 	static_cast<path_conversion*>(closure);
 37412: 
 40713:     if (!pathConvert->figureActive) {
 40713: 	pathConvert->sink->BeginFigure(_d2d_point_from_cairo_point(&pathConvert->current_point),
 40713: 				       pathConvert->type);
 40713: 	/**
 40713: 	 * In this case we mean a single point. For D2D this means we need to add an infinitely
 40713: 	 * small line here to get that effect.
 40713: 	 */
 40713: 	pathConvert->sink->AddLine(_d2d_point_from_cairo_point(&pathConvert->current_point));
 40713:     }
 40713: 
 37412:     pathConvert->sink->EndFigure(D2D1_FIGURE_END_CLOSED);
 37412:     pathConvert->figureActive = false;
 37412:     return CAIRO_STATUS_SUCCESS;
 37412: }
 37412: 
 37412: /**
 37412:  * Create an ID2D1PathGeometry for a cairo_path_fixed_t
 37412:  *
 37412:  * \param path Path to create a geometry for
 37412:  * \param fill_rule Fill rule to use
 37412:  * \param type Figure begin type to use
 37412:  * \return A D2D geometry
 37412:  */
 40634: static RefPtr<ID2D1PathGeometry>
 37412: _cairo_d2d_create_path_geometry_for_path(cairo_path_fixed_t *path, 
 37412: 					 cairo_fill_rule_t fill_rule,
 37412: 					 D2D1_FIGURE_BEGIN type)
 37412: {
 40634:     RefPtr<ID2D1PathGeometry> d2dpath;
 49320:     sD2DFactory->CreatePathGeometry(&d2dpath);
 40634:     RefPtr<ID2D1GeometrySink> sink;
 37412:     d2dpath->Open(&sink);
 37412:     D2D1_FILL_MODE fillMode = D2D1_FILL_MODE_WINDING;
 37412:     if (fill_rule == CAIRO_FILL_RULE_WINDING) {
 37412: 	fillMode = D2D1_FILL_MODE_WINDING;
 37412:     } else if (fill_rule == CAIRO_FILL_RULE_EVEN_ODD) {
 37412: 	fillMode = D2D1_FILL_MODE_ALTERNATE;
 37412:     }
 37412:     sink->SetFillMode(fillMode);
 37412: 
 37412:     path_conversion pathConvert;
 37412:     pathConvert.type = type;
 37412:     pathConvert.sink = sink;
 37412:     pathConvert.figureActive = false;
 37412:     _cairo_path_fixed_interpret(path,
 37412: 				CAIRO_DIRECTION_FORWARD,
 37412: 				_cairo_d2d_path_move_to,
 37412: 				_cairo_d2d_path_line_to,
 37412: 				_cairo_d2d_path_curve_to,
 37412: 				_cairo_d2d_path_close,
 37412: 				&pathConvert);
 37412:     if (pathConvert.figureActive) {
 37412: 	sink->EndFigure(D2D1_FIGURE_END_OPEN);
 37412:     }
 37412:     sink->Close();
 37412:     return d2dpath;
 37412: }
 37412: 
 46450: static cairo_bool_t
 46450: clip_contains_only_boxes (cairo_clip_t *clip)
 38944: {
 46450:     cairo_bool_t is_boxes = TRUE;
 46450: 
 46450:     if (clip) {
 46450: 	cairo_box_t clip_box;
 46450: 	cairo_clip_path_t *path = clip->path;
 46450: 
 46450: 	while (path) {
 46450: 	    is_boxes &= _cairo_path_fixed_is_box(&path->path, &clip_box);
 46450: 	    path = path->prev;
 46450: 	}
 46450:     }
 46450:     return is_boxes;
 38944: }
 38944: 
 46450: static cairo_int_status_t
 46450: _cairo_d2d_clear_box (cairo_d2d_surface_t *d2dsurf,
 46450: 		 cairo_clip_t *clip,
 46450: 		 cairo_box_t *box)
 46450: {
 46450:     if (clip_contains_only_boxes (clip)) {
 46450: 	/* clear the box using axis aligned clips */
 46450: 	d2dsurf->rt->PushAxisAlignedClip(D2D1::RectF(_cairo_fixed_to_float(box->p1.x),
 46450: 		    _cairo_fixed_to_float(box->p1.y),
 46450: 		    _cairo_fixed_to_float(box->p2.x),
 46450: 		    _cairo_fixed_to_float(box->p2.y)),
 46450: 		D2D1_ANTIALIAS_MODE_ALIASED);
 39196: 	d2dsurf->rt->Clear(D2D1::ColorF(0, 0));
 46450: 	d2dsurf->rt->PopAxisAlignedClip();
 46450: 
 46450: 	return CAIRO_INT_STATUS_SUCCESS;
 39196:     }
 39196: 
 46450:     return CAIRO_INT_STATUS_UNSUPPORTED;
 46450: }
 39196: 
 46450: static cairo_int_status_t
 46450: _cairo_d2d_clear (cairo_d2d_surface_t *d2dsurf,
 46450: 		 cairo_clip_t *clip)
 46450: {
 46450:     cairo_region_t *region;
 46450:     cairo_int_status_t status;
 42004: 
 46450:     if (!clip) {
 46450: 	/* no clip so clear everything */
 46450: 	_begin_draw_state(d2dsurf);
 46450: 	reset_clip(d2dsurf);
 39196: 	d2dsurf->rt->Clear(D2D1::ColorF(0, 0));
 39196: 
 46450: 	return CAIRO_INT_STATUS_SUCCESS;
 39196:     }
 39196: 
 46450:     status = _cairo_clip_get_region (clip, &region);
 46450:     if (status)
 46450: 	return status;
 39196: 
 46450:     /* We now have a region, we'll clear it one rectangle at a time */
 46450:     _begin_draw_state(d2dsurf);
 39196: 
 46450:     reset_clip(d2dsurf);
 46450: 
 46450:     if (region) {
 46450: 	int num_rects;
 46450: 	int i;
 46450: 
 46450: 	num_rects = cairo_region_num_rectangles (region);
 46450: 
 46450: 	for (i = 0; i < num_rects; i++) {
 46450: 	    cairo_rectangle_int_t rect;
 46450: 
 46450: 	    cairo_region_get_rectangle (region, i, &rect);
 46450: 
 46450: 	    d2dsurf->rt->PushAxisAlignedClip(
 46450: 		    D2D1::RectF((FLOAT)rect.x,
 46450: 				(FLOAT)rect.y,
 46450: 				(FLOAT)rect.x + rect.width,
 46450: 				(FLOAT)rect.y + rect.height),
 46450: 		    D2D1_ANTIALIAS_MODE_ALIASED);
 46450: 
 46450: 	    d2dsurf->rt->Clear(D2D1::ColorF(0, 0));
 46450: 
 46450: 	    d2dsurf->rt->PopAxisAlignedClip();
 46450: 	}
 46450: 
 46450:     }
 46450: 
 46450:     return CAIRO_INT_STATUS_SUCCESS;
 38944: }
 38944: 
 60653: static cairo_operator_t _cairo_d2d_simplify_operator(cairo_operator_t op,
 38945: 						     const cairo_pattern_t *source)
 38945: {
 38945:     if (op == CAIRO_OPERATOR_SOURCE) {
 38945: 	/** Operator over is easier for D2D! If the source if opaque, change */
 38945: 	if (source->type == CAIRO_PATTERN_TYPE_SURFACE) {
 38945: 	    const cairo_surface_pattern_t *surfpattern =
 38945: 		reinterpret_cast<const cairo_surface_pattern_t*>(source);
 38945: 	    if (surfpattern->surface->content == CAIRO_CONTENT_COLOR) {
 38945: 		return CAIRO_OPERATOR_OVER;
 38945: 	    }
 38945: 	} else if (source->type == CAIRO_PATTERN_TYPE_SOLID) {
 38945: 	    const cairo_solid_pattern_t *solidpattern =
 38945: 		reinterpret_cast<const cairo_solid_pattern_t*>(source);
 38945: 	    if (solidpattern->color.alpha == 1.0) {
 38945: 		return CAIRO_OPERATOR_OVER;
 38945: 	    }
 38945: 	}
 38945:     }
 38945:     return op;
 38945: }
 38945: 
 70960: void
 70960: _cairo_d2d_surface_init(cairo_d2d_surface_t *newSurf, cairo_d2d_device_t *d2d_device, cairo_format_t format)
 70960: {
 70960:     newSurf->format = format;
 70960: 
 70960:     newSurf->device = d2d_device;
 70960:     cairo_addref_device(&d2d_device->base);
 70960:     d2d_device->mVRAMUsage += _cairo_d2d_compute_surface_mem_size(newSurf);
 70960: }
 70960:     
 71557: _cairo_d2d_surface::~_cairo_d2d_surface()
 71557: {
 71557:     _cairo_d2d_surface_entry *entry, *next;
 71557:     cairo_list_foreach_entry_safe(entry, next, _cairo_d2d_surface_entry, &dependent_surfaces, link) {
 71557: 	// We do not need to flush, the contents of our texture has not changed,
 71557: 	// our users have their own reference and can just use it later.
 71557: 	cairo_surface_destroy(&entry->surface->base);
 71557: 	delete entry;
 71557:     }
 71557: 
 71557: }
 71557: 
 37412: // Implementation
 37412: static cairo_surface_t*
 37412: _cairo_d2d_create_similar(void			*surface,
 37412: 			  cairo_content_t	 content,
 37412: 			  int			 width,
 37412: 			  int			 height)
 37412: {
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
 37412:     cairo_d2d_surface_t *newSurf = static_cast<cairo_d2d_surface_t*>(malloc(sizeof(cairo_d2d_surface_t)));
 37412:     
 40634:     new (newSurf) cairo_d2d_surface_t();
 70960:     _cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, NULL, content);
 37412: 
 37412: 
 37412:     D2D1_SIZE_U sizePixels;
 37412:     D2D1_SIZE_F size;
 37412:     HRESULT hr;
 37412: 
 37412:     sizePixels.width = width;
 37412:     sizePixels.height = height;
 37412:     FLOAT dpiX;
 37412:     FLOAT dpiY;
 37412: 
 37412:     d2dsurf->rt->GetDpi(&dpiX, &dpiY);
 37412: 
 37412:     D2D1_ALPHA_MODE alpha;
 37412: 
 37412:     if (content == CAIRO_CONTENT_COLOR) {
 37412: 	alpha = D2D1_ALPHA_MODE_IGNORE;
 37412:     } else {
 37412: 	alpha = D2D1_ALPHA_MODE_PREMULTIPLIED;
 37412:     }
 37412: 
 37412:     size.width = sizePixels.width * dpiX;
 37412:     size.height = sizePixels.height * dpiY;
 37412:     D2D1_BITMAP_PROPERTIES bitProps = D2D1::BitmapProperties(D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN,
 37412: 									       alpha));
 37412: 
 37412:     if (sizePixels.width < 1) {
 37412: 	sizePixels.width = 1;
 37412:     }
 37412:     if (sizePixels.height < 1) {
 37412: 	sizePixels.height = 1;
 37412:     }
 40634:     RefPtr<IDXGISurface> oldDxgiSurface;
 37412:     d2dsurf->surface->QueryInterface(&oldDxgiSurface);
 37412:     DXGI_SURFACE_DESC origDesc;
 37412: 
 37412:     oldDxgiSurface->GetDesc(&origDesc);
 37412: 
 37412:     CD3D10_TEXTURE2D_DESC desc(origDesc.Format,
 37412: 			       sizePixels.width,
 37412: 			       sizePixels.height);
 37412: 
 37412:     if (content == CAIRO_CONTENT_ALPHA) {
 37412: 	desc.Format = DXGI_FORMAT_A8_UNORM;
 37412:     }
 37412: 
 37412:     desc.MipLevels = 1;
 37412:     desc.Usage = D3D10_USAGE_DEFAULT;
 37412:     desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
 48033:     
 48033:     /* CreateTexture2D does not support D3D10_RESOURCE_MISC_GDI_COMPATIBLE with DXGI_FORMAT_A8_UNORM */
 48033:     if (desc.Format != DXGI_FORMAT_A8_UNORM)
 43935: 	desc.MiscFlags = D3D10_RESOURCE_MISC_GDI_COMPATIBLE;
 48033: 
 40634:     RefPtr<ID3D10Texture2D> texture;
 40634:     RefPtr<IDXGISurface> dxgiSurface;
 37412: 
 84947:     D2D1_RENDER_TARGET_USAGE usage = (desc.MiscFlags & D3D10_RESOURCE_MISC_GDI_COMPATIBLE) ?
 84947: 					  D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE
 84947: 					: D2D1_RENDER_TARGET_USAGE_NONE;
 84947: 
 49320:     hr = d2dsurf->device->mD3D10Device->CreateTexture2D(&desc, NULL, &texture);
 37412:     if (FAILED(hr)) {
 40634: 	goto FAIL_CREATESIMILAR;
 37412:     }
 37412: 
 37412:     newSurf->surface = texture;
 37412: 
 37412:     // Create the DXGI surface.
 37412:     hr = newSurf->surface->QueryInterface(IID_IDXGISurface, (void**)&dxgiSurface);
 37412:     if (FAILED(hr)) {
 40634: 	goto FAIL_CREATESIMILAR;
 37412:     }
 48033: 
 49320:     hr = sD2DFactory->CreateDxgiSurfaceRenderTarget(dxgiSurface,
 48033: 						    D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,
 48033: 										 D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN,
 48033: 												   alpha),
 48033: 										 dpiX,
 48033: 										 dpiY,
 48033: 										 usage),
 37412: 						    &newSurf->rt);
 37412: 
 37412:     if (FAILED(hr)) {
 40634: 	goto FAIL_CREATESIMILAR;
 37412:     }
 37412: 
 43669:     if (desc.Format != DXGI_FORMAT_A8_UNORM) {
 43669: 	/* For some reason creation of shared bitmaps for A8 UNORM surfaces
 43669: 	 * doesn't work even though the documentation suggests it does. The
 43669: 	 * function will return an error if we try */
 37412: 	hr = newSurf->rt->CreateSharedBitmap(IID_IDXGISurface,
 37412: 					     dxgiSurface,
 37412: 					     &bitProps,
 37412: 					     &newSurf->surfaceBitmap);
 37412: 	if (FAILED(hr)) {
 40634: 	    goto FAIL_CREATESIMILAR;
 37412: 	}
 43669:     }
 37412: 
 37412:     newSurf->rt->CreateSolidColorBrush(D2D1::ColorF(0, 1.0), &newSurf->solidColorBrush);
 37412: 
 42921:     _d2d_clear_surface(newSurf);
 42921: 
 70960:     _cairo_d2d_surface_init(newSurf, d2dsurf->device, _cairo_format_from_content(content));
 49320: 
 37412:     return reinterpret_cast<cairo_surface_t*>(newSurf);
 37412: 
 40634: FAIL_CREATESIMILAR:
 40634:     /** Ensure we call our surfaces desctructor */
 40634:     newSurf->~cairo_d2d_surface_t();
 37412:     free(newSurf);
 37412:     return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
 37412: }
 37412: 
 37412: static cairo_status_t
 37412: _cairo_d2d_finish(void	    *surface)
 37412: {
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
 41340: 
 50775:     d2dsurf->device->mVRAMUsage -= _cairo_d2d_compute_surface_mem_size(d2dsurf);
 50775:     if (d2dsurf->bufferTexture) {
 50775: 	d2dsurf->device->mVRAMUsage -= _cairo_d2d_compute_surface_mem_size(d2dsurf);
 50775:     }
 50775: 
 46450:     reset_clip(d2dsurf);
 41340: 
 61650:     // We need to release the device after calling the constructor, since the
 61650:     // device destruction may release the D3D/D2D libraries.
 61650:     cairo_device_t *device = &d2dsurf->device->base;
 40634:     d2dsurf->~cairo_d2d_surface_t();
 61650:     cairo_release_device(device);
 37412:     return CAIRO_STATUS_SUCCESS;
 37412: }
 37412: 
 76727: /* The input types for src and dst don't match because in our particular use case, copying from a texture,
 76727:  * those types don't match. */
 76727: static void
 76727: _copy_data_to_different_stride(unsigned char *dst, int dst_stride, void *src, UINT src_stride, int height)
 76727: {
 76727: 
 76727:     unsigned char *src_p = (unsigned char *)src;
 76727:     int min_stride = MIN(dst_stride, src_stride);
 76727:     while (height) {
 76727:         memcpy(dst, src_p, min_stride);
 76727:         height--;
 76727:         dst += dst_stride;
 76727:         src_p += src_stride;
 76727:     }
 76727: }
 76727: 
 37412: static cairo_status_t
 37412: _cairo_d2d_acquire_source_image(void                    *abstract_surface,
 76727: 				cairo_image_surface_t  **image_out_ret,
 37412: 				void                   **image_extra)
 37412: {
 76727:     cairo_surface_t *image_out;
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(abstract_surface);
 37412:     _cairo_d2d_flush(d2dsurf);
 37412: 
 37412:     HRESULT hr;
 37412:     D2D1_SIZE_U size = d2dsurf->rt->GetPixelSize();
 37412: 
 40634:     RefPtr<ID3D10Texture2D> softTexture;
 37412: 
 40634:     RefPtr<IDXGISurface> dxgiSurface;
 37412:     d2dsurf->surface->QueryInterface(&dxgiSurface);
 37412:     DXGI_SURFACE_DESC desc;
 37412: 
 37412:     dxgiSurface->GetDesc(&desc);
 37412: 
 37412:     CD3D10_TEXTURE2D_DESC softDesc(desc.Format, desc.Width, desc.Height);
 37412: 
 37412:     /**
 37412:      * We can't actually map our backing store texture, so we create one in CPU memory, and then
 37412:      * tell D3D to copy the data from our surface there, readback is expensive, we -never-
 37412:      * -ever- want this to happen.
 37412:      */
 37412:     softDesc.MipLevels = 1;
 37412:     softDesc.CPUAccessFlags = D3D10_CPU_ACCESS_WRITE | D3D10_CPU_ACCESS_READ;
 37412:     softDesc.Usage = D3D10_USAGE_STAGING;
 37412:     softDesc.BindFlags = 0;
 49320:     hr = d2dsurf->device->mD3D10Device->CreateTexture2D(&softDesc, NULL, &softTexture);
 37412:     if (FAILED(hr)) {
 51614: 	return _cairo_error(CAIRO_STATUS_NO_MEMORY);
 37412:     }
 37412: 
 49320:     d2dsurf->device->mD3D10Device->CopyResource(softTexture, d2dsurf->surface);
 37412: 
 37412:     D3D10_MAPPED_TEXTURE2D data;
 37412:     hr = softTexture->Map(0, D3D10_MAP_READ_WRITE, 0, &data);
 37412:     if (FAILED(hr)) {
 51614: 	return _cairo_error(CAIRO_STATUS_NO_DEVICE);
 37412:     }
 76727: 
 76727:     if (_cairo_valid_stride_alignment(data.RowPitch)) {
 76727: 	image_out = cairo_image_surface_create_for_data((unsigned char*)data.pData,
 70960: 						  d2dsurf->format,
 37412: 						  size.width,
 37412: 						  size.height,
 37412: 						  data.RowPitch);
 76727:     } else {
 76727: 	/* Slow path used when the stride doesn't match our requirements.
 76727: 	 * This is possible on at least the Intel driver 8.15.10.2302.
 76727: 	 *
 76727: 	 * Create a new image surface and copy our data into it */
 76727: 	image_out = cairo_image_surface_create(d2dsurf->format,
 76727: 					 size.width,
 76727: 					 size.height);
 76727: 	_copy_data_to_different_stride(cairo_image_surface_get_data(image_out),
 76727: 				       cairo_image_surface_get_stride(image_out),
 76727: 				       data.pData,
 76727: 				       data.RowPitch,
 76727: 				       size.height);
 76727: 
 76727:     }
 76727:     /* these are the only surface statuses we expect */
 76727:     assert(cairo_surface_status(image_out) == CAIRO_STATUS_SUCCESS ||
 76727: 	   cairo_surface_status(image_out) == CAIRO_STATUS_NO_MEMORY);
 76727: 
 89759:     *image_extra = softTexture.forget().drop();
 76727:     *image_out_ret = (cairo_image_surface_t*)image_out;
 76727: 
 76727:     return cairo_surface_status(image_out);
 37412: }
 37412: 
 37412: static void
 37412: _cairo_d2d_release_source_image(void                   *abstract_surface,
 37412: 				cairo_image_surface_t  *image,
 37412: 				void                   *image_extra)
 37412: {
 37412:     if (((cairo_surface_t*)abstract_surface)->type != CAIRO_SURFACE_TYPE_D2D) {
 37412: 	return;
 37412:     }
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(abstract_surface);
 37412: 
 39776:     cairo_surface_destroy(&image->base);
 37412:     ID3D10Texture2D *softTexture = (ID3D10Texture2D*)image_extra;
 37412:     
 37412:     softTexture->Unmap(0);
 37412:     softTexture->Release();
 37412:     softTexture = NULL;
 37412: }
 37412: 
 37412: static cairo_status_t
 37412: _cairo_d2d_acquire_dest_image(void                    *abstract_surface,
 37412: 			      cairo_rectangle_int_t   *interest_rect,
 37412: 			      cairo_image_surface_t  **image_out,
 37412: 			      cairo_rectangle_int_t   *image_rect,
 37412: 			      void                   **image_extra)
 37412: {
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(abstract_surface);
 37412:     _cairo_d2d_flush(d2dsurf);
 37412: 
 37412:     HRESULT hr;
 37412:     D2D1_SIZE_U size = d2dsurf->rt->GetPixelSize();
 37412: 
 40634:     RefPtr<ID3D10Texture2D> softTexture;
 37412: 
 37412: 
 40634:     RefPtr<IDXGISurface> dxgiSurface;
 37412:     d2dsurf->surface->QueryInterface(&dxgiSurface);
 37412:     DXGI_SURFACE_DESC desc;
 37412: 
 37412:     dxgiSurface->GetDesc(&desc);
 37412: 
 37412:     CD3D10_TEXTURE2D_DESC softDesc(desc.Format, desc.Width, desc.Height);
 37412: 
 39124:     image_rect->width = desc.Width;
 39124:     image_rect->height = desc.Height;
 39124:     image_rect->x = image_rect->y = 0;
 39124: 
 37412:     softDesc.MipLevels = 1;
 37412:     softDesc.CPUAccessFlags = D3D10_CPU_ACCESS_WRITE | D3D10_CPU_ACCESS_READ;
 37412:     softDesc.Usage = D3D10_USAGE_STAGING;
 37412:     softDesc.BindFlags = 0;
 49320:     hr = d2dsurf->device->mD3D10Device->CreateTexture2D(&softDesc, NULL, &softTexture);
 37412:     if (FAILED(hr)) {
 51614: 	return _cairo_error(CAIRO_STATUS_NO_MEMORY);
 37412:     }
 49320:     d2dsurf->device->mD3D10Device->CopyResource(softTexture, d2dsurf->surface);
 37412: 
 37412:     D3D10_MAPPED_TEXTURE2D data;
 37412:     hr = softTexture->Map(0, D3D10_MAP_READ_WRITE, 0, &data);
 37412:     if (FAILED(hr)) {
 51614: 	return _cairo_error(CAIRO_STATUS_NO_DEVICE);
 37412:     }
 37412:     *image_out = 
 70960: 	(cairo_image_surface_t*)cairo_image_surface_create_for_data((unsigned char*)data.pData,
 70960: 										  _cairo_format_from_content(d2dsurf->base.content),
 37412: 										  size.width,
 37412: 										  size.height,
 37412: 										  data.RowPitch);
 89759:     *image_extra = softTexture.forget().drop();
 37412: 
 37412:     return CAIRO_STATUS_SUCCESS;
 37412: }
 37412: 
 37412: static void
 37412: _cairo_d2d_release_dest_image(void                    *abstract_surface,
 37412: 			      cairo_rectangle_int_t   *interest_rect,
 37412: 			      cairo_image_surface_t   *image,
 37412: 			      cairo_rectangle_int_t   *image_rect,
 37412: 			      void                    *image_extra)
 37412: {
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(abstract_surface);
 37412: 
 37412:     ID3D10Texture2D *softTexture = (ID3D10Texture2D*)image_extra;
 37412:     D2D1_POINT_2U point;
 37412:     point.x = 0;
 37412:     point.y = 0;
 37412:     D2D1_RECT_U rect;
 37412:     D2D1_SIZE_U size = d2dsurf->rt->GetPixelSize();
 37412:     rect.left = rect.top = 0;
 37412:     rect.right = size.width;
 37412:     rect.bottom = size.height;
 39776: 
 39776:     cairo_surface_destroy(&image->base);
 39776: 
 37412:     softTexture->Unmap(0);
 49320:     d2dsurf->device->mD3D10Device->CopyResource(d2dsurf->surface, softTexture);
 37412:     softTexture->Release();
 37412: }
 37412: 
 37412: 
 37412: static cairo_status_t
 37412: _cairo_d2d_flush(void                  *surface)
 37412: {
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
 37412: 
 37412:     if (d2dsurf->isDrawing) {
 46450: 	reset_clip(d2dsurf);
 37412: 	HRESULT hr = d2dsurf->rt->EndDraw();
 37412: 	d2dsurf->isDrawing = false;
 37412:     }
 41340: 
 37412:     return CAIRO_STATUS_SUCCESS;
 37412: }
 37412: 
 49318: static cairo_int_status_t
 49318: _cairo_d2d_copy_surface(cairo_d2d_surface_t *dst,
 49318: 			cairo_d2d_surface_t *src,
 49318: 			cairo_point_int_t *translation,
 49318: 			cairo_region_t *region)
 49318: {
 49318:     RefPtr<IDXGISurface> dstSurface;
 49318:     dst->surface->QueryInterface(&dstSurface);
 49318:     RefPtr<IDXGISurface> srcSurface;
 49318:     src->surface->QueryInterface(&srcSurface);
 49318:     DXGI_SURFACE_DESC srcDesc, dstDesc;
 49318: 
 49318:     srcSurface->GetDesc(&srcDesc);
 49318:     dstSurface->GetDesc(&dstDesc);
 49318: 
 49318:     cairo_rectangle_int_t clip_rect;
 49318:     clip_rect.x = 0;
 49318:     clip_rect.y = 0;
 49318:     clip_rect.width = dstDesc.Width;
 49318:     clip_rect.height = dstDesc.Height;
 49318:     
 49318:     cairo_int_status_t rv = CAIRO_INT_STATUS_SUCCESS;
 49318: 
 49318:     _cairo_d2d_flush(dst);
 49318:     ID3D10Resource *srcResource = src->surface;
 49318:     if (src->surface.get() == dst->surface.get()) {
 49318: 	// Self-copy
 49318: 	srcResource = _cairo_d2d_get_buffer_texture(dst);
 49320: 	src->device->mD3D10Device->CopyResource(srcResource, src->surface);
 49318:     } else {
 49318: 	// Need to flush the source too if it's a different surface.
 49318: 	_cairo_d2d_flush(src);
 49318:     }
 49318: 
 49318:     // One copy for each rectangle in the final clipping region.
 49318:     for (int i = 0; i < cairo_region_num_rectangles(region); i++) {
 49318: 	D3D10_BOX rect;
 49318: 	cairo_rectangle_int_t area_to_copy;
 49318: 
 49318: 	cairo_region_get_rectangle(region, i, &area_to_copy);
 49318: 
 49318: 	cairo_rectangle_int_t transformed_rect = { area_to_copy.x + translation->x,
 49318: 						   area_to_copy.y + translation->y,
 49318: 						   area_to_copy.width, area_to_copy.height };
 49318: 	cairo_rectangle_int_t surface_rect = { 0, 0, srcDesc.Width, srcDesc.Height };
 49318: 
 49318: 
 49318: 	if (!_cairo_rectangle_contains(&surface_rect, &transformed_rect)) {
 49318: 	    /* We cannot do any sort of extend, in the future a little bit of extra code could
 49318: 	     * allow us to support EXTEND_NONE.
 49318: 	     */
 49318: 	    rv = CAIRO_INT_STATUS_UNSUPPORTED;
 49318: 	    break;
 49318: 	}
 49318: 
 49318: 	rect.front = 0;
 49318: 	rect.back = 1;
 49318: 	rect.left = transformed_rect.x;
 49318: 	rect.top = transformed_rect.y;
 49318: 	rect.right = transformed_rect.x + transformed_rect.width;
 49318: 	rect.bottom = transformed_rect.y + transformed_rect.height;
 49318: 
 49320: 	src->device->mD3D10Device->CopySubresourceRegion(dst->surface,
 49318: 							 0,
 49318: 							 area_to_copy.x,
 49318: 							 area_to_copy.y,
 49318: 							 0,
 49318: 							 srcResource,
 49318: 							 0,
 49318: 							 &rect);
 49318:     }
 49318: 
 49318:     return rv;
 49318: }
 49318: 
 54631: static cairo_int_status_t
 54631: _cairo_d2d_blend_surface(cairo_d2d_surface_t *dst,
 54631: 			 cairo_d2d_surface_t *src,
 54631: 		 	 const cairo_matrix_t *transform,
 54631: 			 cairo_box_t *box,
 54631: 			 cairo_clip_t *clip,
 54634: 			 cairo_filter_t filter,
 54631: 			 float opacity)
 54631: {
 54631:     if (dst == src) {
 54631: 	// We cannot do self-blend.
 54631: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 54631:     }
 54631:     cairo_int_status_t rv = CAIRO_INT_STATUS_SUCCESS;
 54631: 
 54631:     _begin_draw_state(dst);
 54631:     _cairo_d2d_set_clip(dst, clip);
 54631:     _cairo_d2d_flush(src);
 54631:     D2D1_SIZE_U sourceSize = src->surfaceBitmap->GetPixelSize();
 54631: 
 54631: 
 54631:     double x1, x2, y1, y2;
 54631:     if (box) {
 54631: 	_cairo_box_to_doubles(box, &x1, &y1, &x2, &y2);
 54631:     } else {
 54631: 	x1 = y1 = 0;
 54631: 	x2 = dst->rt->GetSize().width;
 54631: 	y2 = dst->rt->GetSize().height;
 54631:     }
 54631: 
 54631:     if (clip) {
 54631: 	const cairo_rectangle_int_t *clipExtent = _cairo_clip_get_extents(clip);
 54631: 	x1 = MAX(x1, clipExtent->x);
 54631: 	x2 = MIN(x2, clipExtent->x + clipExtent->width);
 54631: 	y1 = MAX(y1, clipExtent->y);
 54631: 	y2 = MIN(y2, clipExtent->y + clipExtent->height);
 54631:     }
 54631: 
 54631:     // We should be in drawing state for this.
 54631:     _begin_draw_state(dst);
 54631:     _cairo_d2d_set_clip (dst, clip);
 54631:     D2D1_RECT_F rectSrc;
 54631:     rectSrc.left = (float)(x1 * transform->xx + transform->x0);
 54631:     rectSrc.top = (float)(y1 * transform->yy + transform->y0);
 54631:     rectSrc.right = (float)(x2 * transform->xx + transform->x0);
 54631:     rectSrc.bottom = (float)(y2 * transform->yy + transform->y0);
 54631: 
 54695:     if (rectSrc.left < 0 || rectSrc.top < 0 || rectSrc.right < 0 || rectSrc.bottom < 0 ||
 54695: 	rectSrc.right > sourceSize.width || rectSrc.bottom > sourceSize.height ||
 54695: 	rectSrc.left > sourceSize.width || rectSrc.top > sourceSize.height) {
 54631: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 54631:     }
 54631: 
 54631:     D2D1_RECT_F rectDst;
 54631:     rectDst.left = (float)x1;
 54631:     rectDst.top = (float)y1;
 54631:     rectDst.right = (float)x2;
 54631:     rectDst.bottom = (float)y2;
 54631: 
 54695:     // Bug 599658 - if the src rect is inverted in either axis D2D is fine with
 54695:     // this but it does not actually invert the bitmap. This is an easy way
 54695:     // of doing that.
 54695:     D2D1_MATRIX_3X2_F matrix = D2D1::IdentityMatrix();
 54695:     bool needsTransform = false;
 54695:     if (rectSrc.left > rectSrc.right) {
 54695: 	rectDst.left = -rectDst.left;
 54695: 	rectDst.right = -rectDst.right;
 54695: 	matrix._11 = -1.0;
 54695: 	needsTransform = true;
 54695:     }
 54695:     if (rectSrc.top > rectSrc.bottom) {
 54695: 	rectDst.top = -rectDst.top;
 54695: 	rectDst.bottom = -rectDst.bottom;
 54695: 	matrix._22 = -1.0;
 54695: 	needsTransform = true;
 54695:     }
 54695: 
 71557:     _cairo_d2d_add_dependent_surface(src, dst);
 71557: 
 54634:     D2D1_BITMAP_INTERPOLATION_MODE interpMode =
 54634:       D2D1_BITMAP_INTERPOLATION_MODE_LINEAR;
 54634: 
 54695:     if (needsTransform) {
 54695: 	dst->rt->SetTransform(matrix);
 54695:     }
 54695: 
 54634:     if (filter == CAIRO_FILTER_NEAREST) {
 54634:       interpMode = D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR;
 54634:     }
 54634: 
 54631:     dst->rt->DrawBitmap(src->surfaceBitmap,
 54631: 			rectDst,
 54631: 			opacity,
 54634: 			interpMode,
 54631: 			rectSrc);
 54695:     if (needsTransform) {
 54695: 	dst->rt->SetTransform(D2D1::IdentityMatrix());
 54695:     }
 54631: 
 54631:     return rv;
 54631: }
 49318: /**
 49318:  * This function will text if we can use GPU mem cpy to execute an operation with
 49318:  * a surface pattern. If box is NULL it will operate on the entire dst surface.
 49318:  */
 49318: static cairo_int_status_t
 54631: _cairo_d2d_try_fastblit(cairo_d2d_surface_t *dst,
 49318: 			cairo_surface_t *src,
 49318: 			cairo_box_t *box,
 49318: 			const cairo_matrix_t *matrix,
 49318: 			cairo_clip_t *clip,
 54631: 			cairo_operator_t op,
 54634: 			cairo_filter_t filter,
 54631: 			float opacity = 1.0f)
 49318: {
 54631:     if (op == CAIRO_OPERATOR_OVER && src->content == CAIRO_CONTENT_COLOR) {
 54631: 	op = CAIRO_OPERATOR_SOURCE;
 54631:     }
 54631:     if (op != CAIRO_OPERATOR_SOURCE && op != CAIRO_OPERATOR_OVER) {
 54631: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 54631:     }
 54631: 
 54631:     /* For now we do only D2D sources */
 54631:     if (src->type != CAIRO_SURFACE_TYPE_D2D) {
 54631: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 54631:     }
 54631: 
 54631:     cairo_d2d_surface_t *d2dsrc = reinterpret_cast<cairo_d2d_surface_t*>(src);
 54631:     if (op == CAIRO_OPERATOR_OVER && matrix->xy == 0 && matrix->yx == 0) {
 54634: 	return _cairo_d2d_blend_surface(dst, d2dsrc, matrix, box, clip, filter, opacity);
 54631:     }
 54631:     
 54631:     if (op == CAIRO_OPERATOR_OVER || opacity != 1.0f) {
 54631: 	// Past this point we will never get into a situation where we can
 54631: 	// support OVER.
 49318: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 49318:     }
 49318:     
 49318:     cairo_point_int_t translation;
 49318:     if ((box && !box_is_integer(box)) ||
 49318: 	!_cairo_matrix_is_integer_translation(matrix, &translation.x, &translation.y)) {
 49318: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 49318:     }
 49318: 
 49318:     cairo_rectangle_int_t rect;
 49318:     if (box) {
 49318: 	_cairo_box_round_to_rectangle(box, &rect);
 49318:     } else {
 49318: 	rect.x = rect.y = 0;
 49318: 	rect.width = dst->rt->GetPixelSize().width;
 49318: 	rect.height = dst->rt->GetPixelSize().height;
 49318:     }
 49318:     
 49320:     if (d2dsrc->device != dst->device) {
 49320: 	// This doesn't work between different devices.
 49320: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 49320:     }
 49320: 
 49318:     /* Region we need to clip this operation to */
 49318:     cairo_region_t *clipping_region = NULL;
 49318:     cairo_region_t *region;
 60655:     cairo_region_auto_ptr region_ptr;
 60655: 
 49318:     if (clip) {
 49318: 	_cairo_clip_get_region(clip, &clipping_region);
 49318: 
 49318: 	if (!clipping_region) {
 49318: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 49318: 	}
 49318: 	region = cairo_region_copy(clipping_region);
 60655: 	region_ptr.set(region);
 49318: 
 49318: 	cairo_region_intersect_rectangle(region, &rect);
 49318: 
 49318: 	if (cairo_region_is_empty(region)) {
 49318: 	    // Nothing to do.
 49318: 	    return CAIRO_INT_STATUS_SUCCESS;
 49318: 	}
 49318:     } else {
 49318: 	region = cairo_region_create_rectangle(&rect);
 60655: 	region_ptr.set(region);
 60655: 
 49318: 	// Areas outside of the surface do not matter.
 49318: 	cairo_rectangle_int_t surface_rect = { 0, 0,
 49318: 					       dst->rt->GetPixelSize().width,
 49318: 					       dst->rt->GetPixelSize().height };
 49318: 	cairo_region_intersect_rectangle(region, &surface_rect);
 49318:     }
 49318: 
 49318:     cairo_int_status_t rv = _cairo_d2d_copy_surface(dst, d2dsrc, &translation, region);
 49318:     
 49318:     return rv;
 49318: }
 46450: 
 60653: static RefPtr<ID2D1RenderTarget>
 60653: _cairo_d2d_get_temp_rt(cairo_d2d_surface_t *surf, cairo_clip_t *clip)
 49320: {
 49320:     RefPtr<ID3D10Texture2D> texture = _cairo_d2d_get_buffer_texture(surf);
 49320:     RefPtr<ID2D1RenderTarget> new_rt;
 49320:     RefPtr<IDXGISurface> dxgiSurface;
 49320:     texture->QueryInterface(&dxgiSurface);
 49320:     HRESULT hr;
 49320: 
 49320:     _cairo_d2d_flush(surf);
 49320: 
 49320:     if (!surf) {
 49320: 	return NULL;
 49320:     }
 49320: 
 49320:     D2D1_RENDER_TARGET_PROPERTIES props = 
 49320: 	D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,
 49320: 				     D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED));
 49320:     hr = sD2DFactory->CreateDxgiSurfaceRenderTarget(dxgiSurface,
 49320: 						    props,
 49320: 						    &new_rt);
 49320: 
 49320:     if (FAILED(hr)) {
 49320: 	return NULL;
 49320:     }
 49320: 
 49320:     new_rt->BeginDraw();
 49320:     new_rt->Clear(D2D1::ColorF(0, 0));
 49320: 
 49320:     // Since this is a fresh surface there's no point in doing clever things to
 49320:     // keep the clip path around until a certain depth. So we just do a straight-
 49320:     // forward push of all clip paths in the tree, similar to what the normal
 49320:     // clip code does, but a little less clever.
 49320:     if (clip) {
 49320: 	cairo_clip_path_t *path = clip->path;
 49320: 	while (path) {
 49320: 	    cairo_box_t clip_box;
 49320: 	    if (_cairo_path_fixed_is_box(&path->path, &clip_box)) {
 49320: 		// If this does not have a region it could be none-pixel aligned.
 49320: 		D2D1_ANTIALIAS_MODE aaMode = D2D1_ANTIALIAS_MODE_PER_PRIMITIVE;
 49320: 		if (box_is_integer(&clip_box)) {
 49320: 		    aaMode = D2D1_ANTIALIAS_MODE_ALIASED;
 49320: 		}
 49320: 		new_rt->PushAxisAlignedClip(D2D1::RectF(_cairo_fixed_to_float(clip_box.p1.x),
 49320: 							_cairo_fixed_to_float(clip_box.p1.y),
 49320: 							_cairo_fixed_to_float(clip_box.p2.x),
 49320: 							_cairo_fixed_to_float(clip_box.p2.y)),
 49320: 					    aaMode);
 49320: 	    } else {
 49320: 		HRESULT hr;
 49320: 		RefPtr<ID2D1PathGeometry> geom = _cairo_d2d_create_path_geometry_for_path (&path->path,
 49320: 											   path->fill_rule,
 49320: 											   D2D1_FIGURE_BEGIN_FILLED);
 49320: 		RefPtr<ID2D1Layer> layer;
 49320: 
 49320: 		hr = new_rt->CreateLayer (&layer);
 49320: 
 49320: 		D2D1_LAYER_OPTIONS options = D2D1_LAYER_OPTIONS_NONE;
 49320: 
 49320: 		new_rt->PushLayer(D2D1::LayerParameters(
 49320: 					D2D1::InfiniteRect(),
 49320: 					geom,
 49320: 					D2D1_ANTIALIAS_MODE_PER_PRIMITIVE,
 49320: 					D2D1::IdentityMatrix(),
 49320: 					1.0,
 49320: 					0,
 49320: 					options),
 49320: 				  layer);
 49320: 	    }
 49320: 	    path = path->prev;
 49320: 	}
 49320:     }
 49320:     return new_rt;
 49320: }
 49320: 
 60653: static cairo_int_status_t
 60653: _cairo_d2d_blend_temp_surface(cairo_d2d_surface_t *surf, cairo_operator_t op, ID2D1RenderTarget *rt, cairo_clip_t *clip, const cairo_rectangle_int_t *bounds = NULL)
 49320: {
 71557:     _cairo_d2d_flush_dependent_surfaces(surf);
 71557: 
 49320:     int numPaths = 0;
 49320:     if (clip) {
 49320: 	cairo_clip_path_t *path = clip->path;
 49320: 	while (path) {
 49320: 	    numPaths++;
 49320: 	    path = path->prev;
 49320: 	}
 49320: 	
 49320: 	cairo_clip_path_t **paths = new cairo_clip_path_t*[numPaths];
 49320: 
 49320: 	numPaths = 0;
 49320: 	path = clip->path;
 49320: 	while (path) {
 49320: 	    paths[numPaths++] = path;
 49320: 	    path = path->prev;
 49320: 	}	
 49320: 
 49320: 	for (int i = numPaths - 1; i >= 0; i--) {
 49320: 	    if (paths[i]->flags & CAIRO_CLIP_PATH_IS_BOX) {
 49320: 		rt->PopAxisAlignedClip();
 49320: 	    } else {
 49320: 		rt->PopLayer();
 49320: 	    }
 49320: 	}
 49320: 	delete [] paths;
 49320:     }
 49320:     rt->EndDraw();
 49320:     HRESULT hr;
 49320: 
 49320:     RefPtr<ID3D10Texture2D> srcTexture = _cairo_d2d_get_buffer_texture(surf);
 49320:     RefPtr<ID3D10Texture2D> dstTexture;
 49320: 
 49320:     surf->surface->QueryInterface(&dstTexture);
 49320:     ID3D10Device *device = surf->device->mD3D10Device;
 49320: 
 49320:     if (!surf->buffer_rt_view) {
 49320: 	hr = device->CreateRenderTargetView(dstTexture, NULL, &surf->buffer_rt_view);
 49320: 	if (FAILED(hr)) {
 49320: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 49320: 	}
 49320:     }
 49320: 
 49320:     if (!surf->buffer_sr_view) {
 49320: 	hr = device->CreateShaderResourceView(srcTexture, NULL, &surf->buffer_sr_view);
 49320: 	if (FAILED(hr)) {
 49320: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 49320: 	}
 49320:     }
 49320: 
 49320:     cairo_int_status_t status;
 49320: 
 49320:     status = _cairo_d2d_set_operator(surf->device, op);
 49320: 
 49320:     if (unlikely(status)) {
 49320: 	return status;
 49320:     }
 49320: 
 49320:     D3D10_TEXTURE2D_DESC tDesc;
 49320:     dstTexture->GetDesc(&tDesc);
 49320:     D3D10_VIEWPORT vp;
 49320:     vp.Height = tDesc.Height;
 49320:     vp.MinDepth = 0;
 49320:     vp.MaxDepth = 1.0;
 49320:     vp.TopLeftX = 0;
 49320:     vp.TopLeftY = 0;
 49320:     vp.Width = tDesc.Width;
 49320:     device->RSSetViewports(1, &vp);
 49320: 
 49320:     ID3D10Effect *effect = surf->device->mSampleEffect;
 49320: 
 49320:     ID3D10RenderTargetView *rtViewPtr = surf->buffer_rt_view;
 49320:     device->OMSetRenderTargets(1, &rtViewPtr, 0);
 49320:     ID3D10EffectVectorVariable *quadDesc = effect->GetVariableByName("QuadDesc")->AsVector();
 49320:     ID3D10EffectVectorVariable *texCoords = effect->GetVariableByName("TexCoords")->AsVector();
 49320: 
 49320:     float quadDescVal[] = { -1.0f, 1.0f, 2.0f, -2.0f };
 49320:     float texCoordsVal[] = { 0.0, 0.0, 1.0f, 1.0f };
 49320:     if (bounds && _cairo_operator_bounded_by_mask(op)) {
 49320: 	quadDescVal[0] = -1.0f + ((float)bounds->x / (float)tDesc.Width) * 2.0f;
 49320: 	quadDescVal[1] = 1.0f - ((float)bounds->y / (float)tDesc.Height) * 2.0f;
 49320: 	quadDescVal[2] = ((float)bounds->width / (float)tDesc.Width) * 2.0f;
 49320: 	quadDescVal[3] = -((float)bounds->height / (float)tDesc.Height) * 2.0f;
 49320: 	texCoordsVal[0] = (float)bounds->x / (float)tDesc.Width;
 49320: 	texCoordsVal[1] = (float)bounds->y / (float)tDesc.Height;
 49320: 	texCoordsVal[2] = (float)bounds->width / (float)tDesc.Width;
 49320: 	texCoordsVal[3] = (float)bounds->height / (float)tDesc.Height;
 49320:     }
 49320:     quadDesc->SetFloatVector(quadDescVal);
 49320:     texCoords->SetFloatVector(texCoordsVal);
 49320: 
 49320:     _cairo_d2d_setup_for_blend(surf->device);
 49320:     ID3D10EffectTechnique *technique = effect->GetTechniqueByName("SampleTexture");
 49320:     technique->GetPassByIndex(0)->Apply(0);
 49320: 
 49320:     ID3D10ShaderResourceView *srViewPtr = surf->buffer_sr_view;
 49320:     device->PSSetShaderResources(0, 1, &srViewPtr);
 49320: 
 49320:     device->Draw(4, 0);
 49320: 
 49320: #ifdef DEBUG
 49320:     // Quiet down some info messages from D3D10 debug layer
 49320:     srViewPtr = NULL;
 49320:     device->PSSetShaderResources(0, 1, &srViewPtr);
 49320:     rtViewPtr = NULL;
 49320:     device->OMSetRenderTargets(1, &rtViewPtr, 0); 
 49320: #endif
 49320:     return CAIRO_INT_STATUS_SUCCESS;
 49320: }
 49320: 
 37412: static cairo_int_status_t
 37412: _cairo_d2d_paint(void			*surface,
 37412: 		 cairo_operator_t	 op,
 37412: 		 const cairo_pattern_t	*source,
 41340: 		 cairo_clip_t		*clip)
 37412: {
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
 41340:     cairo_int_status_t status;
 41340: 
 38945:     op = _cairo_d2d_simplify_operator(op, source);
 38945: 
 49320:     if (op == CAIRO_OPERATOR_SOURCE) {
 49320: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 49320:     }
 49320: 
 37412:     if (op == CAIRO_OPERATOR_CLEAR) {
 46450: 	return _cairo_d2d_clear(d2dsurf, clip);
 37412:     }
 37412: 
 49318:     if (source->type == CAIRO_PATTERN_TYPE_SURFACE) {
 49318: 	const cairo_surface_pattern_t *surf_pattern = 
 49318: 	    reinterpret_cast<const cairo_surface_pattern_t*>(source);
 49318: 
 54631: 	status = _cairo_d2d_try_fastblit(d2dsurf, surf_pattern->surface,
 54634: 					 NULL, &source->matrix, clip,
 54634: 					 op, source->filter);
 49318: 
 49318: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED) {
 49318: 	    return status;
 49318: 	}
 49318:     }
 49320:     RefPtr<ID2D1RenderTarget> target_rt = d2dsurf->rt;
 49320: #ifndef ALWAYS_MANUAL_COMPOSITE
 49320:     if (op != CAIRO_OPERATOR_OVER) {
 49320: #endif
 49320: 	target_rt = _cairo_d2d_get_temp_rt(d2dsurf, clip);
 49320: 	if (!target_rt) {
 49320: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 49320: 	}
 49320: #ifndef ALWAYS_MANUAL_COMPOSITE
 49320:     } else {
 46450: 	_begin_draw_state(d2dsurf);
 46450: 	status = (cairo_int_status_t)_cairo_d2d_set_clip (d2dsurf, clip);
 46450: 
 46450: 	if (unlikely(status))
 46450: 	    return status;
 49320:     }
 49320: #endif
 49320: 
 49320:     target_rt->SetAntialiasMode(D2D1_ANTIALIAS_MODE_ALIASED);
 37412: 
106422:     RefPtr<ID2D1Brush> brush = _cairo_d2d_create_brush_for_pattern(d2dsurf, NULL,
 42102: 								   source);
 37412:     
 37412:     if (!brush) {
 37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 37412:     }
 49320: 
 49320:     D2D1_SIZE_F size = target_rt->GetSize();
 49320:     target_rt->FillRectangle(D2D1::RectF((FLOAT)0,
 37412: 					 (FLOAT)0,
 37412: 					 (FLOAT)size.width,
 37412: 					 (FLOAT)size.height),
 37412: 			     brush);
 49320: 
 49320:     if (target_rt.get() != d2dsurf->rt.get()) {
 49320: 	return _cairo_d2d_blend_temp_surface(d2dsurf, op, target_rt, clip);
 37412:     }
 37412: 
 37412:     return CAIRO_INT_STATUS_SUCCESS;
 37412: }
 37412: 
 37412: static cairo_int_status_t
 37412: _cairo_d2d_mask(void			*surface,
 37412: 		cairo_operator_t	 op,
 37412: 		const cairo_pattern_t	*source,
 37412: 		const cairo_pattern_t	*mask,
 41340: 		cairo_clip_t		*clip)
 37412: {
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
 41340:     cairo_rectangle_int_t extents;
 37412: 
 67868:     cairo_clip_t *actual_clip = clip;
 69994:     cairo_clip_t temporary_clip;
 67868: 
 41340:     cairo_int_status_t status;
 41340: 
 54632:     status = (cairo_int_status_t)_cairo_surface_mask_extents (&d2dsurf->base,
 54632: 		    op, source,
 54632: 		    mask,
 54632: 		    clip, &extents);
 54632:     if (unlikely (status))
 54632: 	    return status;
 54632: 
 54632:     bool isSolidAlphaMask = false;
 54632:     float solidAlphaValue = 1.0f;
 54632: 
 54632:     if (mask->type == CAIRO_PATTERN_TYPE_SOLID) {
 54632: 	cairo_solid_pattern_t *solidPattern =
 54632: 	    (cairo_solid_pattern_t*)mask;
 70960: 	if (_cairo_color_get_content (&solidPattern->color) == CAIRO_CONTENT_ALPHA) {
 54632: 	    isSolidAlphaMask = true;
 54632: 	    solidAlphaValue = solidPattern->color.alpha;
 54632: 	}
 54632:     }
 54632: 
 67868:     cairo_box_t box;
 67868:     _cairo_box_from_rectangle(&box, &extents);
 67868: 
 87925:     if (clip && isSolidAlphaMask) {
 67868: 	// We do some work here to try and avoid pushing and popping clips for rectangular areas,
 67868: 	// if we do this fill rects will occur without rectangular clips being pushed and popped.
 67868: 	// This is faster for non-axis aligned clips in general and allows more efficient batching
 67868: 	// of the pop-clip calls.
 67868: 	int num_boxes = 1;
 67868: 	cairo_box_t box_stack;
 67868: 	cairo_box_t *boxes;
 67868: 	boxes = &box_stack;
 67868: 
 67868: 	// This function assumes atleast a single box resides at 'boxes' and the
 67868: 	// amount of boxes that reside there are passed in under num_boxes.
 67868: 	status = _cairo_clip_get_boxes(clip, &boxes, &num_boxes);
 67868: 
 67868: 	if (!status && num_boxes == 1) {
 67868: 	    box.p1.x = MAX(box.p1.x, boxes->p1.x);
 67868: 	    box.p2.x = MIN(box.p2.x, boxes->p2.x);
 67868: 	    box.p1.y = MAX(box.p1.y, boxes->p1.y);
 67868: 	    box.p2.y = MIN(box.p2.y, boxes->p2.y);
 67868: 
 67868: 	    if (clip->path != d2dsurf->clip.path) {
 69994: 		// If we have a clip set, but it's not the right one. We want to
 69994: 		// pop as much as we need to, to be sure the area affected by
 69994: 		// the operation is not clipped. To do this we set the clip path
 69994: 		// to the common ancestor of the currently set clip path and the
 69994: 		// clip path for this operation. This will cause
 69994: 		// _cairo_d2d_set_clip to pop to that common ancestor, but not
 69994: 		// needlessly push the additional clips we're trying to avoid.
 69994: 		temporary_clip.path = find_common_ancestor(clip->path, d2dsurf->clip.path);
 69994: 
 69994: 		// We're not going to be using this down the line so it doesn't
 69994: 		// really matter what the value is. If all -was- clipped this
 69994: 		// call shouldn't even have reached the surface backend.
 69994: 		temporary_clip.all_clipped = FALSE;
 69994: 
 69994: 		actual_clip = &temporary_clip;
 67868: 	    }
 67868: 	}
 67868: 
 67868: 	if (boxes != &box_stack) {
 67868: 	    // If the function changed the boxes pointer, we need to free it.
 67868: 	    free(boxes);
 67868: 	}
 67868:     }
 67868: 
 54632:     if (isSolidAlphaMask) {
 54632: 	if (source->type == CAIRO_PATTERN_TYPE_SURFACE) {
 54632: 	    const cairo_surface_pattern_t *surf_pattern = 
 54632: 		reinterpret_cast<const cairo_surface_pattern_t*>(source);
 54632: 	    cairo_int_status_t rv = _cairo_d2d_try_fastblit(d2dsurf,
 54632: 							    surf_pattern->surface,
 54632: 							    &box,
 54632: 							    &source->matrix,
 54632: 							    clip,
 54632: 							    op,
 54634: 							    source->filter,
 54632: 							    solidAlphaValue);
 54632: 	    if (rv != CAIRO_INT_STATUS_UNSUPPORTED) {
 54632: 		return rv;
 54632: 	    }
 54632: 	}
 54632:     }
 54632: 
106422:     RefPtr<ID2D1Brush> brush = _cairo_d2d_create_brush_for_pattern(d2dsurf, NULL, source);
 54632:     if (!brush) {
 54632: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 54632:     }
 54632: 
 50650:     RefPtr<ID2D1RenderTarget> target_rt = d2dsurf->rt;
 50650: #ifndef ALWAYS_MANUAL_COMPOSITE
 50650:     if (op != CAIRO_OPERATOR_OVER) {
 50650: #endif
 50650: 	target_rt = _cairo_d2d_get_temp_rt(d2dsurf, clip);
 50650: 	if (!target_rt) {
 50650: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 50650: 	}
 50650: #ifndef ALWAYS_MANUAL_COMPOSITE
 50650:     } else {
 46450: 	_begin_draw_state(d2dsurf);
 67868: 
 67868: 	status = (cairo_int_status_t)_cairo_d2d_set_clip (d2dsurf, actual_clip);
 41340: 	if (unlikely(status))
 41340: 	    return status;
 50650:     }
 50650: #endif
 41340: 
 67868:     D2D1_RECT_F rect = D2D1::RectF(_cairo_fixed_to_float(box.p1.x),
 67868: 				   _cairo_fixed_to_float(box.p1.y),
 67868: 				   _cairo_fixed_to_float(box.p2.x),
 67868: 				   _cairo_fixed_to_float(box.p2.y));
 67868: 
 54632:     if (isSolidAlphaMask) {
 54632: 	brush->SetOpacity(solidAlphaValue);
 50650: 	target_rt->FillRectangle(rect,
 37412: 				 brush);
 37412: 	brush->SetOpacity(1.0);
 50650: 
 50650: 	if (target_rt.get() != d2dsurf->rt.get()) {
 50650: 	    return _cairo_d2d_blend_temp_surface(d2dsurf, op, target_rt, clip);
 50650: 	}
 37412: 	return CAIRO_INT_STATUS_SUCCESS;
 37412:     }
 42102: 
106422:     RefPtr<ID2D1Brush> opacityBrush = _cairo_d2d_create_brush_for_pattern(d2dsurf, NULL, mask, true);
 37412:     if (!opacityBrush) {
 37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 37412:     }
 42102: 
 37412:     if (!d2dsurf->maskLayer) {
 37412: 	d2dsurf->rt->CreateLayer(&d2dsurf->maskLayer);
 37412:     }
 50650:     target_rt->PushLayer(D2D1::LayerParameters(D2D1::InfiniteRect(),
 37412: 					       0,
 37412: 					       D2D1_ANTIALIAS_MODE_ALIASED,
 37412: 					       D2D1::IdentityMatrix(),
 37412: 					       1.0,
 37412: 					       opacityBrush),
 37412: 			 d2dsurf->maskLayer);
 37412: 
 50650:     target_rt->FillRectangle(rect,
 37412: 			     brush);
 50650:     target_rt->PopLayer();
 50650: 
 50650:     if (target_rt.get() != d2dsurf->rt.get()) {
 50650: 	return _cairo_d2d_blend_temp_surface(d2dsurf, op, target_rt, clip);
 50650:     }
 37412:     return CAIRO_INT_STATUS_SUCCESS;
 37412: }
 37412: 
 37412: static cairo_int_status_t
 37412: _cairo_d2d_stroke(void			*surface,
 37412: 		  cairo_operator_t	 op,
 37412: 		  const cairo_pattern_t	*source,
 37412: 		  cairo_path_fixed_t	*path,
 70960: 		  const cairo_stroke_style_t	*style,
 70960: 		  const cairo_matrix_t	*ctm,
 70960: 		  const cairo_matrix_t	*ctm_inverse,
 37412: 		  double		 tolerance,
 37412: 		  cairo_antialias_t	 antialias,
 41340: 		  cairo_clip_t		*clip)
 37412: {
 41340:     cairo_int_status_t status;
 41340: 
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
 38944: 
 38945:     op = _cairo_d2d_simplify_operator(op, source);
 38945: 
 49320:     if (op == CAIRO_OPERATOR_SOURCE) {
 37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 37412:     }
 37412: 
 49320:     RefPtr<ID2D1RenderTarget> target_rt = d2dsurf->rt;
 49320: #ifndef ALWAYS_MANUAL_COMPOSITE
 49320:     if (op != CAIRO_OPERATOR_OVER) {
 49320: #endif
 49320: 	target_rt = _cairo_d2d_get_temp_rt(d2dsurf, clip);
 49320: 	if (!target_rt) {
 49320: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 49320: 	}
 49320: #ifndef ALWAYS_MANUAL_COMPOSITE
 49320:     } else {
 46450: 	_begin_draw_state(d2dsurf);
 46450: 	status = (cairo_int_status_t)_cairo_d2d_set_clip (d2dsurf, clip);
 46450: 
 41340: 	if (unlikely(status))
 41340: 	    return status;
 49320:     }
 49320: #endif
 41340: 
 37412:     if (antialias == CAIRO_ANTIALIAS_NONE) {
 49320: 	target_rt->SetAntialiasMode(D2D1_ANTIALIAS_MODE_ALIASED);
 37412:     } else {
 49320: 	target_rt->SetAntialiasMode(D2D1_ANTIALIAS_MODE_PER_PRIMITIVE);
 37412:     }
 40634:     RefPtr<ID2D1StrokeStyle> strokeStyle = _cairo_d2d_create_strokestyle_for_stroke_style(style);
 37412: 
 37412:     if (!strokeStyle) {
 37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 37412:     }
 48299:     RefPtr<ID2D1Geometry> d2dpath = _cairo_d2d_create_path_geometry_for_path(path, 
 48299: 		    							     CAIRO_FILL_RULE_WINDING, 
 48299: 									     D2D1_FIGURE_BEGIN_FILLED);
 58397:     
 58397:     bool transformed = true;
 58397: 
 58397:     if (_cairo_matrix_is_identity(ctm)) {
 58397:       transformed = false;
 58397:     }
 37412: 
106422:     RefPtr<ID2D1Brush> brush = _cairo_d2d_create_brush_for_pattern(d2dsurf, NULL,
 42102: 								   source);
 42102:     if (!brush) {
 42102: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 42102:     }
 42102: 
 58397:     D2D1::Matrix3x2F mat;
 58397:     if (transformed) {
 58397:       // If we are transformed we will draw the geometry multiplied by the
 58397:       // inverse transformation and apply the transform to our render target.
 58397:       // This way the transformation will also be applied to the strokestyle.
 58397:       mat = _cairo_d2d_matrix_from_matrix(ctm);
 58397:       D2D1::Matrix3x2F inverse_mat = _cairo_d2d_invert_matrix(mat);
 58397:     
 58397:       RefPtr<ID2D1TransformedGeometry> trans_geom;
 58397:       sD2DFactory->CreateTransformedGeometry(d2dpath, &inverse_mat, &trans_geom);
 58397: 
 58397:       // If we are setting a transform on the render target, we've multiplied
 58397:       // the geometry by the inverse transform, we should also multiply the
 58397:       // brush matrix by this inverse transform then to map the brush to the
 58397:       // correct place.
 58397:       D2D1_MATRIX_3X2_F brushMatrix;
 58397:       brush->GetTransform(&brushMatrix);
 58397:       brushMatrix = brushMatrix * inverse_mat;
 58397:       brush->SetTransform(brushMatrix);
 58397:       target_rt->SetTransform(mat);
 58397:       d2dpath = trans_geom;
 58397:     } else {
 58397:       mat = D2D1::Matrix3x2F::Identity();
 58397:     }
 58397: 
 58397:     target_rt->DrawGeometry(d2dpath, brush, (FLOAT)style->line_width, strokeStyle);
 58397: 
 58397:     if (transformed) {
 49320:       target_rt->SetTransform(D2D1::Matrix3x2F::Identity());
 58397:     }
 49320: 
 49320:     if (target_rt.get() != d2dsurf->rt.get()) {
 49320: 	D2D1_RECT_F bounds;
 58397: 	d2dpath->GetWidenedBounds((FLOAT)style->line_width, strokeStyle, mat, &bounds);
 49320: 	cairo_rectangle_int_t bound_rect;
 49320: 	_cairo_d2d_round_out_to_int_rect(&bound_rect, bounds.left, bounds.top, bounds.right, bounds.bottom);
 49320: 	return _cairo_d2d_blend_temp_surface(d2dsurf, op, target_rt, clip, &bound_rect);
 49320:     }
 49320: 
 37412:     return CAIRO_INT_STATUS_SUCCESS;
 37412: }
 37412: 
 37412: static cairo_int_status_t
 37412: _cairo_d2d_fill(void			*surface,
 37412: 		cairo_operator_t	 op,
 37412: 		const cairo_pattern_t	*source,
 37412: 		cairo_path_fixed_t	*path,
 37412: 		cairo_fill_rule_t	 fill_rule,
 37412: 		double			 tolerance,
 37412: 		cairo_antialias_t	 antialias,
 41340: 		cairo_clip_t		*clip)
 37412: {
 41340:     cairo_int_status_t status;
 41340: 
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
 49318:     cairo_box_t box;
 49318:     bool is_box = _cairo_path_fixed_is_box(path, &box);
 49318: 
 49318:     if (is_box && source->type == CAIRO_PATTERN_TYPE_SURFACE) {
 49318: 	const cairo_surface_pattern_t *surf_pattern = 
 49318: 	    reinterpret_cast<const cairo_surface_pattern_t*>(source);
 54631: 	cairo_int_status_t rv = _cairo_d2d_try_fastblit(d2dsurf, surf_pattern->surface,
 54634: 							&box, &source->matrix, clip, op,
 54634: 							source->filter);
 49318: 
 49318: 	if (rv != CAIRO_INT_STATUS_UNSUPPORTED) {
 49318: 	    return rv;
 49318: 	}
 49318:     }
 37412: 
 38945:     op = _cairo_d2d_simplify_operator(op, source);
 38945: 
 49320:     if (op == CAIRO_OPERATOR_SOURCE) {
 37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 37412:     }
 37412: 
 49320:     if (op == CAIRO_OPERATOR_CLEAR) {
 49320: 	if (_cairo_path_fixed_is_box(path, &box)) {
 46450: 	    _begin_draw_state(d2dsurf);
 46450: 	    status = (cairo_int_status_t)_cairo_d2d_set_clip (d2dsurf, clip);
 46450: 
 41340: 	    if (unlikely(status))
 41340: 		return status;
 41340: 
 46450: 	    return _cairo_d2d_clear_box (d2dsurf, clip, &box);
 46450: 	} else {
 46450: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 39196: 	}
 38944:     }
 38944: 
 49320:     RefPtr<ID2D1RenderTarget> target_rt = d2dsurf->rt;
 49320:     
 49320: #ifndef ALWAYS_MANUAL_COMPOSITE
 49320:     if (op != CAIRO_OPERATOR_OVER) {
 49320: #endif
 49320: 	target_rt = _cairo_d2d_get_temp_rt(d2dsurf, clip);
 49320: 	if (!target_rt) {
 49320: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 49320: 	}
 49320: #ifndef ALWAYS_MANUAL_COMPOSITE
 49320:     } else {
 49320: 	_begin_draw_state(d2dsurf);
 49320: 	status = (cairo_int_status_t)_cairo_d2d_set_clip (d2dsurf, clip);
 49320: 
 49320: 	if (unlikely(status))
 49320: 	    return status;
 49320:     }
 49320: #endif
 49320: 
 49320:     if (antialias == CAIRO_ANTIALIAS_NONE) {
 49320: 	target_rt->SetAntialiasMode(D2D1_ANTIALIAS_MODE_ALIASED);
 49320:     } else {
 49320: 	target_rt->SetAntialiasMode(D2D1_ANTIALIAS_MODE_PER_PRIMITIVE);
 49320:     }
 49320: 
 49318:     if (is_box) {
 37412: 	float x1 = _cairo_fixed_to_float(box.p1.x);
 37412: 	float y1 = _cairo_fixed_to_float(box.p1.y);    
 37412: 	float x2 = _cairo_fixed_to_float(box.p2.x);    
 37412: 	float y2 = _cairo_fixed_to_float(box.p2.y);
 40634: 	RefPtr<ID2D1Brush> brush = _cairo_d2d_create_brush_for_pattern(d2dsurf,
106422: 	    path, source);
 37412: 	if (!brush) {
 37412: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 37412: 	}
 37412: 
 49320: 	target_rt->FillRectangle(D2D1::RectF(x1,
 37412: 					     y1,
 37412: 					     x2,
 37412: 					     y2),
 37412: 				 brush);
 37412:     } else {
 40634: 	RefPtr<ID2D1Geometry> d2dpath = _cairo_d2d_create_path_geometry_for_path(path, fill_rule, D2D1_FIGURE_BEGIN_FILLED);
 42102: 
 40634: 	RefPtr<ID2D1Brush> brush = _cairo_d2d_create_brush_for_pattern(d2dsurf,
106422:             path, source);
 37412: 	if (!brush) {
 37412: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 37412: 	}
 49320: 	target_rt->FillGeometry(d2dpath, brush);
 37412:     }
 49320: 
 49320:     if (target_rt.get() != d2dsurf->rt.get()) {
 49320: 	double x1, y1, x2, y2;
 70960:         cairo_box_t box;
 70960:         _cairo_path_fixed_extents (path, &box);
 70960:         x1 = _cairo_fixed_to_double (box.p1.x);
 70960:         y1 = _cairo_fixed_to_double (box.p1.y);
 70960:         x2 = _cairo_fixed_to_double (box.p2.x);
 70960:         y2 = _cairo_fixed_to_double (box.p2.y);
 49320: 	cairo_rectangle_int_t bounds;
 49320: 	_cairo_d2d_round_out_to_int_rect(&bounds, x1, y1, x2, y2);
 49320: 	return _cairo_d2d_blend_temp_surface(d2dsurf, op, target_rt, clip, &bounds);
 49320:     }
 49320: 
 37412:     return CAIRO_INT_STATUS_SUCCESS;
 37412: }
 37412: 
 60657: cairo_int_status_t
 60657: _cairo_dwrite_manual_show_glyphs_on_d2d_surface(void			    *surface,
 60657: 						cairo_operator_t	     op,
 60657: 						const cairo_solid_pattern_t *source,
 60657: 						cairo_glyph_t		    *glyphs,
 60657: 						int			     num_glyphs,
 60657: 						cairo_dwrite_scaled_font_t  *scaled_font,
 60657: 						cairo_clip_t		    *clip)
 60657: {
 62611:     cairo_dwrite_scaled_font_t *dwritesf = reinterpret_cast<cairo_dwrite_scaled_font_t*>(scaled_font);
 62611:     if (!dwritesf->manual_show_glyphs_allowed) {
 62611: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 62611:     }
 62611: 
 60657:     cairo_dwrite_font_face_t *dwriteff = reinterpret_cast<cairo_dwrite_font_face_t*>(scaled_font->base.font_face);
 60657:     cairo_d2d_surface_t *dst = reinterpret_cast<cairo_d2d_surface_t*>(surface);
 60657: 
 60657:     BOOL transform = FALSE;
 60657:     HRESULT hr;
 60657: 
 60657:     cairo_region_t *clip_region = NULL;
 60657: 
 60657:     // We can only draw axis and pixel aligned rectangular quads, this means we
 60657:     // can only support clips which form regions, since the intersection with
 60657:     // our text area will then always be a set of rectangular axis and pixel
 60657:     // aligned quads.
 60657:     if (clip) {
 60657: 	_cairo_clip_get_region(clip, &clip_region);
 60657: 	if (!clip_region) {
 60657: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 60657: 	}
 60657:     }
 60657: 
 71557:     if (!dst->isDrawing) {
 71557: 	_cairo_d2d_flush_dependent_surfaces(dst);
 71557:     }
 71557: 
 60657:     _cairo_d2d_set_clip(dst, NULL);
 60657:     dst->rt->Flush();
 60657: 
 88479:     AutoDWriteGlyphRun run;
 60657:     _cairo_dwrite_glyph_run_from_glyphs(glyphs, num_glyphs, scaled_font, &run, &transform);
 60657: 
 60657:     RefPtr<IDWriteGlyphRunAnalysis> analysis;
 60657:     DWRITE_MATRIX dwmat = _cairo_dwrite_matrix_from_matrix(&scaled_font->mat);
 60657: 
 60657:     RefPtr<IDWriteRenderingParams> params;
 60657:     dst->rt->GetTextRenderingParams(&params);
 60657: 
 60708:     DWRITE_RENDERING_MODE renderMode = DWRITE_RENDERING_MODE_DEFAULT;
 60708:     if (params) {
 60708: 	hr = dwriteff->dwriteface->GetRecommendedRenderingMode(
 60708: 						      (FLOAT)scaled_font->base.font_matrix.yy,
 60657: 						      1.0f,
 60657: 						      DWRITE_MEASURING_MODE_NATURAL,
 60657: 						      params,
 60657: 						      &renderMode);
 60708: 	if (FAILED(hr)) {
 60708: 	    // this probably never happens, but let's play it safe
 60708: 	    renderMode = DWRITE_RENDERING_MODE_DEFAULT;
 60708: 	}
 60708:     }
 60657: 
 60657:     // Deal with rendering modes CreateGlyphRunAnalysis doesn't accept.
 68738:     switch (renderMode) {
 68738:     case DWRITE_RENDERING_MODE_ALIASED:
 68738: 	// ClearType texture creation will fail in this mode, so bail out
 68738: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 68738:     case DWRITE_RENDERING_MODE_DEFAULT:
 60657: 	// As per DWRITE_RENDERING_MODE documentation, pick Natural for font
 60657: 	// sizes under 16 ppem
 60657: 	if (scaled_font->base.font_matrix.yy < 16.0f) {
 60657: 	    renderMode = DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL;
 60657: 	} else {
 60657: 	    renderMode = DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC;
 60657: 	}
 68738: 	break;
 68738:     case DWRITE_RENDERING_MODE_OUTLINE:
 60657: 	renderMode = DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC;
 68738: 	break;
 68738:     default:
 68738: 	break;
 68738:     }
 68738: 
 68738:     DWRITE_MEASURING_MODE measureMode =
 68738: 	renderMode <= DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC ? DWRITE_MEASURING_MODE_GDI_CLASSIC :
 68738: 	renderMode == DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL ? DWRITE_MEASURING_MODE_GDI_NATURAL :
 68738: 	DWRITE_MEASURING_MODE_NATURAL;
 60657: 
 60708:     hr = DWriteFactory::Instance()->CreateGlyphRunAnalysis(&run,
 60657: 						      1.0f,
 60657: 						      transform ? &dwmat : 0,
 60657: 						      renderMode,
 68738: 						      measureMode,
 60657: 						      0,
 60657: 						      0,
 60657: 						      &analysis);
 60708:     if (FAILED(hr)) {
 60708: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 60708:     }
 60657: 
 60657:     RECT bounds;
 60708:     hr = analysis->GetAlphaTextureBounds(DWRITE_TEXTURE_CLEARTYPE_3x1,
 60657: 					 &bounds);
 60708:     if (FAILED(hr) ||
 60708: 	// with bitmap sizes of asian fonts, GetAlphaTextureBounds returns
 60708: 	// an empty rect, so we need to detect that and fall back
 60708: 	(bounds.top == 0 && bounds.bottom == 0 && num_glyphs > 0))
 60708:     {
 60708: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 60708:     }
 60657: 
 60657:     cairo_rectangle_int_t cairo_bounds =
 60657: 	_cairo_rect_from_windows_rect(&bounds);
 60657: 
 60657:     cairo_region_t *region;
 60657:     if (clip) {
 60657: 	region = cairo_region_copy(clip_region);
 60657: 
 60657: 	cairo_region_intersect_rectangle(region, &cairo_bounds);
 60657:     } else {
 60657: 	region = cairo_region_create_rectangle(&cairo_bounds);
 60657:     }
 60657: 
 60657:     cairo_region_auto_ptr region_ptr(region);
 60657: 
 60657:     if (cairo_region_is_empty(region)) {
 60657: 	// Nothing to do.
 60657: 	return CAIRO_INT_STATUS_SUCCESS;
 60657:     }
 60657:  
 60657:     int bufferSize = cairo_bounds.width * cairo_bounds.height * 3;
 60657: 
 60657:     if (!bufferSize) {
 60657: 	// width == 0 || height == 0
 60657: 	return CAIRO_INT_STATUS_SUCCESS;
 60657:     }
 60657: 
 60657:     // We add one byte so we can safely read an entire 32-bit int when copying
 60657:     // the last 3 bytes of the alpha texture.
 60657:     BYTE *texture = new BYTE[bufferSize + 1];
 60708:     hr = analysis->CreateAlphaTexture(DWRITE_TEXTURE_CLEARTYPE_3x1,
 60708: 					&bounds, texture, bufferSize);
 60708:     if (FAILED(hr)) {
 60708: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 60708:     }
 60657: 
 60657:     RefPtr<ID3D10ShaderResourceView> srView;
 60657:     ID3D10Device1 *device = dst->device->mD3D10Device;
 60657: 
 60657:     int textureWidth, textureHeight;
 60657: 
 60657:     if (cairo_bounds.width < TEXT_TEXTURE_WIDTH &&
 60657: 	cairo_bounds.height < TEXT_TEXTURE_HEIGHT)
 60657:     {
 60657: 	// Use our cached TextTexture when it is big enough.
 60710: 	RefPtr<ID3D10Texture2D> tmpTexture;
 60710: 	CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM,
 60710: 				   cairo_bounds.width, cairo_bounds.height,
 60710: 				   1, 1, 0);
 60710: 
 60710: 	desc.Usage = D3D10_USAGE_STAGING;
 60710: 	desc.CPUAccessFlags = D3D10_CPU_ACCESS_WRITE;
 60710: 				   
 60710: 	hr = device->CreateTexture2D(&desc, NULL, &tmpTexture);
 60710: 
 60657: 	D3D10_MAPPED_TEXTURE2D texMap;
 60710: 	hr = tmpTexture->Map(0, D3D10_MAP_WRITE, 0, &texMap);
 60657: 
 60657: 	if (FAILED(hr)) {
 60657: 	    delete [] texture;
 60657: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 60657: 	}
 60657: 
 60657: 	BYTE *alignedTextureData = (BYTE*)texMap.pData;
 60657: 	for (int y = 0; y < cairo_bounds.height; y++) {
 60657: 	    for (int x = 0; x < cairo_bounds.width; x++) {
 60657: 		// Copy 3 Bpp source to 4 Bpp texture.
 60657: 		//
 60657: 		// Since we don't care what ends up in the alpha pixel of the
 60657: 		// destination, therefor we can simply copy a normal 32 bit
 60657: 		// integer each time, filling the alpha pixel of the destination
 60657: 		// with the first subpixel of the next pixel from the source.
 60657: 		*((int*)(alignedTextureData + (y * texMap.RowPitch) + x * 4)) =
 60657: 		    *((int*)(texture + (y * cairo_bounds.width + x) * 3));
 60657: 	    }
 60657: 	}
 60657: 
 60710: 	tmpTexture->Unmap(0);
 60657: 
 60657: 	delete [] texture;
 60657: 
 60710: 	D3D10_BOX box;
 60710: 	box.front = box.top = box.left = 0;
 60710: 	box.back = 1;
 60710: 	box.right = cairo_bounds.width;
 60710: 	box.bottom = cairo_bounds.height;
 60710: 
 60710: 	device->CopySubresourceRegion(dst->device->mTextTexture, 0, 0, 0, 0, tmpTexture, 0, &box);
 60710: 
 60657: 	srView = dst->device->mTextTextureView;
 60657: 
 60657: 	textureWidth = TEXT_TEXTURE_WIDTH;
 60657: 	textureHeight = TEXT_TEXTURE_HEIGHT;
 60657:     } else {
 60657: 	int alignedBufferSize = cairo_bounds.width * cairo_bounds.height * 4;
 60657: 
 60657: 	// Create a one-off immutable texture from system memory.
 60657: 	BYTE *alignedTextureData = new BYTE[alignedBufferSize];
 60657: 	for (int y = 0; y < cairo_bounds.height; y++) {
 60657: 	    for (int x = 0; x < cairo_bounds.width; x++) {
 60657: 		// Copy 3 Bpp source to 4 Bpp destination memory used for
 60657: 		// texture creation. D3D10 has no 3 Bpp texture format we can
 60657: 		// use.
 60657: 		//
 60657: 		// Since we don't care what ends up in the alpha pixel of the
 60657: 		// destination, therefor we can simply copy a normal 32 bit
 60657: 		// integer each time, filling the alpha pixel of the destination
 60657: 		// with the first subpixel of the next pixel from the source.
 60657: 		*((int*)(alignedTextureData + (y * cairo_bounds.width + x) * 4)) =
 60657: 		    *((int*)(texture + (y * cairo_bounds.width + x) * 3));
 60657: 	    }
 60657: 	}
 60657: 
 60657: 	D3D10_SUBRESOURCE_DATA data;
 60657:   
 60657: 	CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM,
 60657: 				   cairo_bounds.width, cairo_bounds.height,
 60657: 				   1, 1);
 60657: 	desc.Usage = D3D10_USAGE_IMMUTABLE;
 60657: 
 60657: 	data.SysMemPitch = cairo_bounds.width * 4;
 60657: 	data.pSysMem = alignedTextureData;
 60657: 
 60657: 	RefPtr<ID3D10Texture2D> tex;
 60657: 	hr = device->CreateTexture2D(&desc, &data, &tex);
 60657: 	
 60657: 	delete [] alignedTextureData;
 60657: 	delete [] texture;
 60657: 
 60657: 	if (FAILED(hr)) {
 60657: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 60657: 	}
 60657: 
 60657: 	hr = device->CreateShaderResourceView(tex, NULL, &srView);
 60657: 
 60657: 	if (FAILED(hr)) {
 60657: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 60657: 	}
 60657: 
 60657: 	textureWidth = cairo_bounds.width;
 60657: 	textureHeight = cairo_bounds.height;
 60657:     }
 60657: 
 60657:     // Prepare destination surface for rendering.
 60657:     RefPtr<ID3D10Texture2D> dstTexture;
 60657: 
 60657:     dst->surface->QueryInterface(&dstTexture);
 60657: 
 60657:     if (!dst->buffer_rt_view) {
 60657: 	hr = device->CreateRenderTargetView(dstTexture, NULL, &dst->buffer_rt_view);
 60657: 	if (FAILED(hr)) {
 60657: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 60657: 	}
 60657:     }
 60657: 
 60657:     D3D10_TEXTURE2D_DESC tDesc;
 60657:     dstTexture->GetDesc(&tDesc);
 60657:     D3D10_VIEWPORT vp;
 60657:     vp.Height = tDesc.Height;
 60657:     vp.MinDepth = 0;
 60657:     vp.MaxDepth = 1.0;
 60657:     vp.TopLeftX = 0;
 60657:     vp.TopLeftY = 0;
 60657:     vp.Width = tDesc.Width;
 60657:     device->RSSetViewports(1, &vp);
 60657: 
 60657:     ID3D10Effect *effect = dst->device->mSampleEffect;
 60657: 
 60657:     ID3D10RenderTargetView *rtViewPtr = dst->buffer_rt_view;
 60657: 
 60657:     device->OMSetRenderTargets(1, &rtViewPtr, 0);
 60657: 
 60657:     ID3D10EffectTechnique *technique = effect->GetTechniqueByName("SampleTextTexture");
 60657: 
 60657:     ID3D10EffectVectorVariable *quadDesc = effect->GetVariableByName("QuadDesc")->AsVector();
 60657:     ID3D10EffectVectorVariable *texCoords = effect->GetVariableByName("TexCoords")->AsVector();
 60657:     ID3D10EffectVectorVariable *textColor = effect->GetVariableByName("TextColor")->AsVector();
 60657: 
 60657:     float colorVal[] = { float(source->color.red   * source->color.alpha),
 60657: 			 float(source->color.green * source->color.alpha),
 60657: 			 float(source->color.blue  * source->color.alpha),
 60657: 			 float(source->color.alpha) };
 60657:     textColor->SetFloatVector(colorVal);
 60657: 
 60657:     float quadDescVal[4];
 60657:     float texCoordsVal[4];
 60657: 
 60657:     // Draw a quad for each rectangle in the intersection of the clip and the
 60657:     // text area.
 60657:     for (int i = 0; i < cairo_region_num_rectangles(region); i++) {
 60657: 	cairo_rectangle_int_t quad;
 60657: 	cairo_region_get_rectangle(region, i, &quad);
 60657: 
 60657: 	quadDescVal[0] = -1.0f + ((float)quad.x / (float)tDesc.Width) * 2.0f;
 60657: 	quadDescVal[1] = 1.0f - ((float)quad.y / (float)tDesc.Height) * 2.0f;
 60657: 	quadDescVal[2] = ((float)quad.width / (float)tDesc.Width) * 2.0f;
 60657: 	quadDescVal[3] = -((float)quad.height / (float)tDesc.Height) * 2.0f;
 60657: 	
 60657: 	texCoordsVal[0] = (float)(quad.x - cairo_bounds.x) / textureWidth;
 60657: 	texCoordsVal[1] = (float)(quad.y - cairo_bounds.y) / textureHeight;
 60657: 	texCoordsVal[2] = (float)quad.width / textureWidth;
 60657: 	texCoordsVal[3] = (float)quad.height / textureHeight;
 60657: 
 60657: 	quadDesc->SetFloatVector(quadDescVal);
 60657: 	texCoords->SetFloatVector(texCoordsVal);
 60657: 
 60657: 	_cairo_d2d_setup_for_blend(dst->device);
 60657: 	technique->GetPassByIndex(0)->Apply(0);
 60657: 
 60657: 	ID3D10ShaderResourceView *srViewPtr = srView;
 60657: 	device->PSSetShaderResources(0, 1, &srViewPtr);
 60657: 
 60657: 	device->Draw(4, 0);
 60657:     }
 60657: 
 60657:     return CAIRO_INT_STATUS_SUCCESS;
 60657: }
 60657: 
 60653: static cairo_int_status_t
 60653: _cairo_dwrite_show_glyphs_on_d2d_surface(void			*surface,
 60653: 					 cairo_operator_t	 op,
 60653: 					 const cairo_pattern_t	*source,
 60653: 					 cairo_glyph_t		*glyphs,
 60653: 					 int			 num_glyphs,
 60653: 					 cairo_scaled_font_t	*scaled_font,
 60653: 					 cairo_clip_t		*clip)
 60653: {
 60653:     cairo_int_status_t status;
 60653: 
 60653:     // TODO: Check font & surface for types.
 60653:     cairo_dwrite_scaled_font_t *dwritesf = reinterpret_cast<cairo_dwrite_scaled_font_t*>(scaled_font);
 60653:     cairo_dwrite_font_face_t *dwriteff = reinterpret_cast<cairo_dwrite_font_face_t*>(scaled_font->font_face);
 60653:     cairo_d2d_surface_t *dst = reinterpret_cast<cairo_d2d_surface_t*>(surface);
 60653: 
 60653:     /* We can only handle dwrite fonts */
 60653:     //XXX: this is checked by at least one caller
 60653:     if (cairo_scaled_font_get_type (scaled_font) != CAIRO_FONT_TYPE_DWRITE)
 60653: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 60653: 
 60653:     op = _cairo_d2d_simplify_operator(op, source);
 60653: 
 60653:     /* We cannot handle operator SOURCE or CLEAR */
 60653:     if (op == CAIRO_OPERATOR_SOURCE || op == CAIRO_OPERATOR_CLEAR) {
 60653: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 60653:     }
 60653: 
 60657:     if (op == CAIRO_OPERATOR_OVER && source->type == CAIRO_PATTERN_TYPE_SOLID &&
 60657: 	dst->base.content != CAIRO_CONTENT_COLOR &&
 60657: 	dst->base.permit_subpixel_antialiasing &&
 60657: 	dwritesf->antialias_mode == CAIRO_ANTIALIAS_SUBPIXEL)
 60657:     {
 60657: 	// The D2D/DWrite drawing API's will not allow drawing subpixel AA to
 60657: 	// an RGBA surface. We do however want to do this if we know all text
 60657: 	// on a surface will be over opaque pixels, when this is the case
 60657: 	// we set the permit_subpixel_antialiasing flag on a surface. We then
 60657: 	// proceed to manually composite the glyphs to the surface.
 60657: 
 60657: 	const cairo_solid_pattern_t *solid_src =
 60657: 	    reinterpret_cast<const cairo_solid_pattern_t*>(source);
 60657: 	status = _cairo_dwrite_manual_show_glyphs_on_d2d_surface(surface,
 60657: 								 op,
 60657: 								 solid_src,
 60657: 								 glyphs,
 60657: 								 num_glyphs,
 60657: 								 dwritesf,
 60657: 								 clip);
 60657: 
 60657: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED) {
 60657: 	    return status;
 60657: 	}
 60657:     }
 60657: 
 60653:     RefPtr<ID2D1RenderTarget> target_rt = dst->rt;
 60653:     cairo_rectangle_int_t fontArea;
 60653: #ifndef ALWAYS_MANUAL_COMPOSITE
 60653:     if (op != CAIRO_OPERATOR_OVER) {
 60653: #endif
 60653: 	target_rt = _cairo_d2d_get_temp_rt(dst, clip);
 60653: 
 60653: 	if (!target_rt) {
 60653: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 60653: 	}
 60653: #ifndef ALWAYS_MANUAL_COMPOSITE
 60653:     } else {
 60653: 	_begin_draw_state(dst);
 60653: 	status = (cairo_int_status_t)_cairo_d2d_set_clip (dst, clip);
 60653: 
 60653: 	if (unlikely(status))
 60653: 	    return status;
 60653:     }
 60653: #endif
 60653: 
 60653:     D2D1_TEXT_ANTIALIAS_MODE cleartype_quality = D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE;
 60653: 
 60653:     // If we're rendering to a temporary surface we cannot do sub-pixel AA.
 60653:     if (dst->base.content != CAIRO_CONTENT_COLOR || dst->rt.get() != target_rt.get()) {
 60653: 	cleartype_quality = D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE;
 60653:     }
 60653: 
 68738:     RefPtr<IDWriteRenderingParams> params;
 68738:     target_rt->GetTextRenderingParams(&params);
 68738: 
 68738:     DWRITE_RENDERING_MODE renderMode = DWRITE_RENDERING_MODE_DEFAULT;
 68738:     if (params) {
 68738: 	HRESULT hr = dwriteff->dwriteface->GetRecommendedRenderingMode(
 68738: 						      (FLOAT)dwritesf->base.font_matrix.yy,
 68738: 						      1.0f,
 68738: 						      DWRITE_MEASURING_MODE_NATURAL,
 68738: 						      params,
 68738: 						      &renderMode);
 68738: 	if (FAILED(hr)) {
 68738: 	    // this probably never happens, but let's play it safe
 68738: 	    renderMode = DWRITE_RENDERING_MODE_DEFAULT;
 68738: 	}
 68738:     }
 68738: 
 68738:     // Deal with rendering modes CreateGlyphRunAnalysis doesn't accept
 68738:     switch (renderMode) {
 68738:     case DWRITE_RENDERING_MODE_DEFAULT:
 68738: 	// As per DWRITE_RENDERING_MODE documentation, pick Natural for font
 68738: 	// sizes under 16 ppem
 68738:   	if (dwritesf->base.font_matrix.yy < 16.0f) {
 68738: 	    renderMode = DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL;
 68738: 	} else {
 68738: 	    renderMode = DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC;
 68738: 	}
 68738: 	break;
 68738:     case DWRITE_RENDERING_MODE_OUTLINE:
 68738: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 68738:     default:
 68738: 	break;
 68738:     }
 68738: 
 60653:     switch (dwritesf->antialias_mode) {
 60653:     case CAIRO_ANTIALIAS_NONE:
 68738: 	cleartype_quality = D2D1_TEXT_ANTIALIAS_MODE_ALIASED;
 60653: 	break;
 60653:     case CAIRO_ANTIALIAS_GRAY:
 68738: 	cleartype_quality = D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE;
 60653: 	break;
 60653:     case CAIRO_ANTIALIAS_SUBPIXEL:
 68738: 	break;
 68738:     }
 68738: 
 68738:     if (renderMode == DWRITE_RENDERING_MODE_ALIASED) {
 68738: 	cleartype_quality = D2D1_TEXT_ANTIALIAS_MODE_ALIASED;
 68738:     }
 68738: 
 60653:     target_rt->SetTextAntialiasMode(cleartype_quality);
 68738: 
 68738:     DWRITE_MEASURING_MODE measureMode =
 68738: 	renderMode <= DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC ? DWRITE_MEASURING_MODE_GDI_CLASSIC :
 68738: 	renderMode == DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL ? DWRITE_MEASURING_MODE_GDI_NATURAL :
 68738: 	DWRITE_MEASURING_MODE_NATURAL;
 60653: 
 60654:     cairo_bool_t transform = FALSE;
 60653: 
 88479:     AutoDWriteGlyphRun run;
 60654:     _cairo_dwrite_glyph_run_from_glyphs(glyphs, num_glyphs, dwritesf, &run, &transform);
 60653: 
 60653:     D2D1::Matrix3x2F mat = _cairo_d2d_matrix_from_matrix(&dwritesf->mat);
 60653: 	
 60653:     if (transform) {
 60653: 	target_rt->SetTransform(mat);
 60653:     }
 60653: 
 60653:     if (dst->rt.get() != target_rt.get()) {
 60653: 	RefPtr<IDWriteGlyphRunAnalysis> analysis;
 60653: 	DWRITE_MATRIX dwmat = _cairo_dwrite_matrix_from_matrix(&dwritesf->mat);
 60653: 	DWriteFactory::Instance()->CreateGlyphRunAnalysis(&run,
 60653: 							  1.0f,
 60653: 							  transform ? &dwmat : 0,
 68738: 							  renderMode,
 68738: 							  measureMode,
 60653: 							  0,
 60653: 							  0,
 60653: 							  &analysis);
 60653: 
 60653: 	RECT bounds;
 60653: 	analysis->GetAlphaTextureBounds(scaled_font->options.antialias == CAIRO_ANTIALIAS_NONE ?
 60653: 					DWRITE_TEXTURE_ALIASED_1x1 : DWRITE_TEXTURE_CLEARTYPE_3x1,
 60653: 					&bounds);
 60653: 	fontArea.x = bounds.left;
 60653: 	fontArea.y = bounds.top;
 60653: 	fontArea.width = bounds.right - bounds.left;
 60653: 	fontArea.height = bounds.bottom - bounds.top;
 60653:     }
 60653: 
106422:     RefPtr<ID2D1Brush> brush = _cairo_d2d_create_brush_for_pattern(dst, NULL,
 60653: 								   source);
 60653: 
 60653:     if (!brush) {
 60653: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 60653:     }
 60653:     
 60653:     if (transform) {
 60653: 	D2D1::Matrix3x2F mat_inverse = _cairo_d2d_matrix_from_matrix(&dwritesf->mat_inverse);
 60653: 	D2D1::Matrix3x2F mat_brush;
 60653: 
 60653: 	// The brush matrix needs to be multiplied with the inverted matrix
 60653: 	// as well, to move the brush into the space of the glyphs. Before
 60653: 	// the render target transformation.
 60653: 	brush->GetTransform(&mat_brush);
 60653: 	mat_brush = mat_brush * mat_inverse;
 60653: 	brush->SetTransform(&mat_brush);
 60653:     }
 60653:     
 68738:     target_rt->DrawGlyphRun(D2D1::Point2F(0, 0), &run, brush, measureMode);
 60653:     
 60653:     if (transform) {
 60653: 	target_rt->SetTransform(D2D1::Matrix3x2F::Identity());
 60653:     }
 60653: 
 60653:     if (target_rt.get() != dst->rt.get()) {
 60653: 	return _cairo_d2d_blend_temp_surface(dst, op, target_rt, clip, &fontArea);
 60653:     }
 60653: 
 60653:     return CAIRO_INT_STATUS_SUCCESS;
 60653: }
 41340: 
 37412: static cairo_int_status_t
 37412: _cairo_d2d_show_glyphs (void			*surface,
 37412: 			cairo_operator_t	 op,
 37412: 			const cairo_pattern_t	*source,
 37412: 			cairo_glyph_t		*glyphs,
 37412: 			int			 num_glyphs,
 37412: 			cairo_scaled_font_t	*scaled_font,
 41340: 			cairo_clip_t            *clip,
 41340: 			int			*remaining_glyphs)
 37412: {
 71544:     if (((cairo_surface_t*)surface)->type != CAIRO_SURFACE_TYPE_D2D ||
 71544:         scaled_font->backend->type != CAIRO_FONT_TYPE_DWRITE)
 71544:     {
 37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 37412:     }
 71544: 
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
 71189:     cairo_d2d_surface_t::TextRenderingState textRenderingState =
 71544:         reinterpret_cast<cairo_dwrite_scaled_font_t*>(scaled_font)->rendering_mode;
 71189:     if (d2dsurf->textRenderingState != textRenderingState) {
 71189: 	RefPtr<IDWriteRenderingParams> params =
 71544: 	    DWriteFactory::RenderingParams(textRenderingState);
 37412: 	d2dsurf->rt->SetTextRenderingParams(params);
 71189: 	d2dsurf->textRenderingState = textRenderingState;
 37412:     }
 71544:     cairo_int_status_t status = (cairo_int_status_t)
 41340:         _cairo_dwrite_show_glyphs_on_d2d_surface(surface, op, source, glyphs, num_glyphs, scaled_font, clip);
 37412: 
 37412:     return status;
 37412: }
 37412: 
 41340: 
 41340: static cairo_bool_t
 37412: _cairo_d2d_getextents(void		       *surface,
 37412: 		      cairo_rectangle_int_t    *extents)
 37412: {
 37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
 37412:     extents->x = 0;
 37412:     extents->y = 0;
 37412:     D2D1_SIZE_U size = d2dsurf->rt->GetPixelSize(); 
 37412:     extents->width = size.width;
 37412:     extents->height = size.height;
 41340:     return TRUE;
 37412: }
 37412: 
 37412: 
 37412: /** Helper functions. */
 37412: 
 70960: 
 70960: 
 37412: cairo_surface_t*
 49320: cairo_d2d_surface_create_for_hwnd(cairo_device_t *cairo_device,
 49320: 				  HWND wnd,
 43397: 				  cairo_content_t content)
 37412: {
 49320:     cairo_d2d_device_t *d2d_device = reinterpret_cast<cairo_d2d_device_t*>(cairo_device);
 37412:     cairo_d2d_surface_t *newSurf = static_cast<cairo_d2d_surface_t*>(malloc(sizeof(cairo_d2d_surface_t)));
 40634:     new (newSurf) cairo_d2d_surface_t();
 37412: 
 70960:     _cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, NULL, content);
 37412: 
 37412:     RECT rc;
 37412:     HRESULT hr;
 37412: 
 37412:     newSurf->isDrawing = false;
 37412:     ::GetClientRect(wnd, &rc);
 37412: 
 37412:     FLOAT dpiX;
 37412:     FLOAT dpiY;
 37412:     D2D1_SIZE_U sizePixels;
 37412:     D2D1_SIZE_F size;
 37412: 
 37412:     dpiX = 96;
 37412:     dpiY = 96;
 37412: 
 37412: 
 37412:     sizePixels.width = rc.right - rc.left;
 37412:     sizePixels.height = rc.bottom - rc.top;
 37412: 
 37412:     if (!sizePixels.width) {
 37412: 	sizePixels.width = 1;
 37412:     }
 37412:     if (!sizePixels.height) {
 37412: 	sizePixels.height = 1;
 37412:     }
 49320:     ID3D10Device1 *device = d2d_device->mD3D10Device;
 40634:     RefPtr<IDXGIDevice> dxgiDevice;
 40634:     RefPtr<IDXGIAdapter> dxgiAdapter;
 40634:     RefPtr<IDXGIFactory> dxgiFactory;
 40634:     D2D1_RENDER_TARGET_PROPERTIES props;    
 40634:     D2D1_BITMAP_PROPERTIES bitProps;
 37412: 
 37412:     device->QueryInterface(&dxgiDevice);
 37412:     dxgiDevice->GetAdapter(&dxgiAdapter);
 37412:     dxgiAdapter->GetParent(IID_PPV_ARGS(&dxgiFactory));
 37412: 
 37412:     DXGI_SWAP_CHAIN_DESC swapDesc;
 37412:     ::ZeroMemory(&swapDesc, sizeof(swapDesc));
 37412: 
 37412:     swapDesc.BufferDesc.Width = sizePixels.width;
 37412:     swapDesc.BufferDesc.Height = sizePixels.height;
 37412:     swapDesc.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
 37412:     swapDesc.BufferDesc.RefreshRate.Numerator = 60;
 37412:     swapDesc.BufferDesc.RefreshRate.Denominator = 1;
 37412:     swapDesc.SampleDesc.Count = 1;
 37412:     swapDesc.SampleDesc.Quality = 0;
 37412:     swapDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
 37412:     swapDesc.BufferCount = 1;
 43935:     swapDesc.Flags = DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE;
 37412:     swapDesc.OutputWindow = wnd;
 37412:     swapDesc.Windowed = TRUE;
 37412: 
 37412:     /**
 37412:      * Create a swap chain, this swap chain will contain the backbuffer for
 37412:      * the window we draw to. The front buffer is the full screen front
 37412:      * buffer.
 37412:      */
 37412:     hr = dxgiFactory->CreateSwapChain(dxgiDevice, &swapDesc, &newSurf->dxgiChain);
 37412: 
 40712:     /**
 40712:      * We do not want DXGI to intercept alt-enter events and make the window go
 40712:      * fullscreen! This shouldn't be in the cairo backend but controlled through
 40712:      * the device. See comments on mozilla bug 553603.
 40712:      */
 40712:     dxgiFactory->MakeWindowAssociation(wnd, DXGI_MWA_NO_WINDOW_CHANGES);
 40712: 
 37412:     if (FAILED(hr)) {
 40634: 	goto FAIL_HWND;
 37412:     }
 37412:     /** Get the backbuffer surface from the swap chain */
 37412:     hr = newSurf->dxgiChain->GetBuffer(0,
 51366: 				       IID_PPV_ARGS(&newSurf->surface));
 37412: 
 37412:     if (FAILED(hr)) {
 40634: 	goto FAIL_HWND;
 37412:     }
 37412: 
 51366:     newSurf->surface->QueryInterface(&newSurf->backBuf);
 37412: 
 37412:     size.width = sizePixels.width * dpiX;
 37412:     size.height = sizePixels.height * dpiY;
 37412: 
 40634:     props = D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,
 37412: 					 D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED),
 37412: 					 dpiX,
 37412: 					 dpiY,
 43935: 					 D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE);
 49320:     hr = sD2DFactory->CreateDxgiSurfaceRenderTarget(newSurf->backBuf,
 37412: 								   props,
 37412: 								   &newSurf->rt);
 37412:     if (FAILED(hr)) {
 40634: 	goto FAIL_HWND;
 37412:     }
 37412: 
 40634:     bitProps = D2D1::BitmapProperties(D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, 
 37412: 				      D2D1_ALPHA_MODE_PREMULTIPLIED));
 37412:     
 37412:     newSurf->rt->CreateSolidColorBrush(D2D1::ColorF(0, 1.0), &newSurf->solidColorBrush);
 37412: 
 42921:     _d2d_clear_surface(newSurf);
 42921: 
 70960:     _cairo_d2d_surface_init(newSurf, d2d_device, _cairo_format_from_content(content));
 49320: 
 37412:     return reinterpret_cast<cairo_surface_t*>(newSurf);
 40634: 
 40634: FAIL_HWND:
 40634:     newSurf->~cairo_d2d_surface_t();
 40634:     free(newSurf);
 40634:     return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
 37412: }
 37412: 
 70960: 
 70960: 
 37412: cairo_surface_t *
 49320: cairo_d2d_surface_create(cairo_device_t *device,
 49320: 			 cairo_format_t format,
 37412: 			 int width,
 37412: 			 int height)
 37412: {
 51306:     if (width == 0 || height == 0) {
 51306: 	return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_INVALID_SIZE));
 51306:     }
 51306: 
 49320:     cairo_d2d_device_t *d2d_device = reinterpret_cast<cairo_d2d_device_t*>(device);
 37412:     cairo_d2d_surface_t *newSurf = static_cast<cairo_d2d_surface_t*>(malloc(sizeof(cairo_d2d_surface_t)));
 40634:     new (newSurf) cairo_d2d_surface_t();
 37412: 
 37412:     DXGI_FORMAT dxgiformat = DXGI_FORMAT_B8G8R8A8_UNORM;
 37412:     D2D1_ALPHA_MODE alpha = D2D1_ALPHA_MODE_PREMULTIPLIED;
 37412:     if (format == CAIRO_FORMAT_ARGB32) {
 70960: 	_cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, NULL, CAIRO_CONTENT_COLOR_ALPHA);
 37412:     } else if (format == CAIRO_FORMAT_RGB24) {
 70960: 	_cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, NULL, CAIRO_CONTENT_COLOR);
 37412: 	alpha = D2D1_ALPHA_MODE_IGNORE;
 37412:     } else {
 70960: 	_cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, NULL, CAIRO_CONTENT_ALPHA);
 37412: 	dxgiformat = DXGI_FORMAT_A8_UNORM;
 37412:     }
 41340: 
 41340: 
 37412:     newSurf->format = format;
 37412: 
 37412:     D2D1_SIZE_U sizePixels;
 37412:     HRESULT hr;
 37412: 
 37412:     sizePixels.width = width;
 37412:     sizePixels.height = height;
 37412: 
 37412:     CD3D10_TEXTURE2D_DESC desc(
 37412: 	dxgiformat,
 37412: 	sizePixels.width,
 37412: 	sizePixels.height
 37412: 	);
 37412:     desc.MipLevels = 1;
 37412:     desc.Usage = D3D10_USAGE_DEFAULT;
 37412:     desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
 48033: 
 48033:     /* CreateTexture2D does not support D3D10_RESOURCE_MISC_GDI_COMPATIBLE with DXGI_FORMAT_A8_UNORM */
 48033:     if (desc.Format != DXGI_FORMAT_A8_UNORM)
 43935: 	desc.MiscFlags = D3D10_RESOURCE_MISC_GDI_COMPATIBLE;
 37412: 
 40634:     RefPtr<ID3D10Texture2D> texture;
 40634:     RefPtr<IDXGISurface> dxgiSurface;
 40634:     D2D1_BITMAP_PROPERTIES bitProps;
 40634:     D2D1_RENDER_TARGET_PROPERTIES props;
 37412: 
 49320:     hr = d2d_device->mD3D10Device->CreateTexture2D(&desc, NULL, &texture);
 37412: 
 37412:     if (FAILED(hr)) {
 40634: 	goto FAIL_CREATE;
 37412:     }
 37412: 
 37412:     newSurf->surface = texture;
 37412: 
 37412:     /** Create the DXGI surface. */
 37412:     hr = newSurf->surface->QueryInterface(IID_IDXGISurface, (void**)&dxgiSurface);
 37412:     if (FAILED(hr)) {
 40634: 	goto FAIL_CREATE;
 37412:     }
 37412: 
 40634:     props = D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,
 37412: 					 D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, alpha));
 48033: 
 48033:     if (desc.MiscFlags & D3D10_RESOURCE_MISC_GDI_COMPATIBLE)
 43935: 	props.usage = D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE;
 48033: 
 49320:     hr = sD2DFactory->CreateDxgiSurfaceRenderTarget(dxgiSurface,
 37412: 								   props,
 37412: 								   &newSurf->rt);
 37412: 
 37412:     if (FAILED(hr)) {
 40634: 	goto FAIL_CREATE;
 37412:     }
 37412: 
 40634:     bitProps = D2D1::BitmapProperties(D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, 
 37412: 				      alpha));
 43669: 
 43669:     if (dxgiformat != DXGI_FORMAT_A8_UNORM) {
 43669: 	/* For some reason creation of shared bitmaps for A8 UNORM surfaces
 43669: 	 * doesn't work even though the documentation suggests it does. The
 43669: 	 * function will return an error if we try */
 37412: 	hr = newSurf->rt->CreateSharedBitmap(IID_IDXGISurface,
 37412: 					     dxgiSurface,
 37412: 					     &bitProps,
 37412: 					     &newSurf->surfaceBitmap);
 37412: 
 37412: 	if (FAILED(hr)) {
 43669: 	    goto FAIL_CREATE;
 43669: 	}
 37412:     }
 37412: 
 37412:     newSurf->rt->CreateSolidColorBrush(D2D1::ColorF(0, 1.0), &newSurf->solidColorBrush);
 37412: 
 42921:     _d2d_clear_surface(newSurf);
 42921: 
 70960:     _cairo_d2d_surface_init(newSurf, d2d_device, format);
 49320: 
 37412:     return reinterpret_cast<cairo_surface_t*>(newSurf);
 40634: 
 40634: FAIL_CREATE:
 40634:     newSurf->~cairo_d2d_surface_t();
 40634:     free(newSurf);
 40634:     return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
 37412: }
 37412: 
 49321: cairo_surface_t *
 49321: cairo_d2d_surface_create_for_handle(cairo_device_t *device, HANDLE handle, cairo_content_t content)
 49321: {
 49321:     if (!device) {
 49321: 	return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_DEVICE));
 49321:     }
 49321: 
 49321:     cairo_d2d_device_t *d2d_device = reinterpret_cast<cairo_d2d_device_t*>(device);
 49321:     cairo_d2d_surface_t *newSurf = static_cast<cairo_d2d_surface_t*>(malloc(sizeof(cairo_d2d_surface_t)));
 49321:     new (newSurf) cairo_d2d_surface_t();
 49321: 
 49321:     cairo_status_t status = CAIRO_STATUS_NO_MEMORY;
 49321:     HRESULT hr;
 49321:     RefPtr<ID3D10Texture2D> texture;
 49321:     RefPtr<IDXGISurface> dxgiSurface;
 49321:     D2D1_BITMAP_PROPERTIES bitProps;
 49321:     D2D1_RENDER_TARGET_PROPERTIES props;
 49321:     DXGI_FORMAT format;
 49321:     DXGI_SURFACE_DESC desc;
 84947:     D2D1_ALPHA_MODE alpha = D2D1_ALPHA_MODE_PREMULTIPLIED;
 49321: 
 49321:     hr = d2d_device->mD3D10Device->OpenSharedResource(handle,
 49321: 						      __uuidof(ID3D10Resource),
 49321: 						      (void**)&newSurf->surface);
 49321: 
 49321:     if (FAILED(hr)) {
 49321: 	goto FAIL_CREATEHANDLE;
 49321:     }
 49321: 
 49321:     hr = newSurf->surface->QueryInterface(&dxgiSurface);
 49321: 
 49321:     if (FAILED(hr)) {
 49321: 	goto FAIL_CREATEHANDLE;
 49321:     }
 49321: 
 49321:     dxgiSurface->GetDesc(&desc);
 49321:     format = desc.Format;
 49321:     
 49321:     if (format == DXGI_FORMAT_B8G8R8A8_UNORM) {
 49321: 	if (content == CAIRO_CONTENT_ALPHA) {
 49321: 	    status = CAIRO_STATUS_INVALID_CONTENT;
 49321: 	    goto FAIL_CREATEHANDLE;
 49321: 	}
 70960: 	_cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, NULL, content);
 49321: 	if (content == CAIRO_CONTENT_COLOR) {
 49321: 	    alpha = D2D1_ALPHA_MODE_IGNORE;
 49321: 	}
 49321:     } else if (format == DXGI_FORMAT_A8_UNORM) {
 49321: 	if (content != CAIRO_CONTENT_ALPHA) {
 49321: 	    status = CAIRO_STATUS_INVALID_CONTENT;
 49321: 	    goto FAIL_CREATEHANDLE;
 49321: 	}
 70960: 	_cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, NULL, CAIRO_CONTENT_ALPHA);
 49321:     } else {
 49321: 	status = CAIRO_STATUS_INVALID_FORMAT;
 49321: 	// We don't know how to support this format!
 49321: 	goto FAIL_CREATEHANDLE;
 49321:     }
 49321: 
 49321:     props = D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,
 49321: 					 D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, alpha));
 49321: 
 49321:     hr = sD2DFactory->CreateDxgiSurfaceRenderTarget(dxgiSurface,
 49321: 						    props,
 49321: 						    &newSurf->rt);
 49321: 
 49321:     if (FAILED(hr)) {
 49321: 	goto FAIL_CREATEHANDLE;
 49321:     }
 49321: 
 49321:     bitProps = D2D1::BitmapProperties(D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, 
 49321: 				      alpha));
 49321: 
 49321:     if (format != DXGI_FORMAT_A8_UNORM) {
 49321: 	/* For some reason creation of shared bitmaps for A8 UNORM surfaces
 49321: 	 * doesn't work even though the documentation suggests it does. The
 49321: 	 * function will return an error if we try */
 49321: 	hr = newSurf->rt->CreateSharedBitmap(IID_IDXGISurface,
 49321: 					     dxgiSurface,
 49321: 					     &bitProps,
 49321: 					     &newSurf->surfaceBitmap);
 49321: 
 49321: 	if (FAILED(hr)) {
 49321: 	    goto FAIL_CREATEHANDLE;
 49321: 	}
 49321:     }
 49321: 
 49321:     newSurf->rt->CreateSolidColorBrush(D2D1::ColorF(0, 1.0), &newSurf->solidColorBrush);
 49321: 
 70960:     _cairo_d2d_surface_init(newSurf, d2d_device, _cairo_format_from_content(content));
 49321: 
 49321:     return &newSurf->base;
 49321:    
 49321: FAIL_CREATEHANDLE:
 49321:     newSurf->~cairo_d2d_surface_t();
 49321:     free(newSurf);
 49321:     return _cairo_surface_create_in_error(_cairo_error(status));
 49321: }
 49321: 
 54810: cairo_surface_t *
 54810: cairo_d2d_surface_create_for_texture(cairo_device_t *device,
 54810: 				     ID3D10Texture2D *texture,
 54810: 				     cairo_content_t content)
 54810: {
 54810:     cairo_d2d_device_t *d2d_device = reinterpret_cast<cairo_d2d_device_t*>(device);
 54810:     cairo_d2d_surface_t *newSurf = static_cast<cairo_d2d_surface_t*>(malloc(sizeof(cairo_d2d_surface_t)));
 54810:     new (newSurf) cairo_d2d_surface_t();
 54810: 
 54810:     D2D1_ALPHA_MODE alpha = D2D1_ALPHA_MODE_PREMULTIPLIED;
 54810:     if (content == CAIRO_CONTENT_COLOR) {
 70960: 	_cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, NULL, CAIRO_CONTENT_COLOR);
 54810: 	alpha = D2D1_ALPHA_MODE_IGNORE;
 54810:     } else {
 70960: 	_cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, NULL, content);
 54810:     }
 54810: 
 54810:     D2D1_SIZE_U sizePixels;
 54810:     HRESULT hr;
 54810: 
 54810:     D3D10_TEXTURE2D_DESC desc;
 54810:     RefPtr<IDXGISurface> dxgiSurface;
 54810:     D2D1_BITMAP_PROPERTIES bitProps;
 54810:     D2D1_RENDER_TARGET_PROPERTIES props;
 54810: 
 54810:     texture->GetDesc(&desc);
 54810: 
 54810:     sizePixels.width = desc.Width;
 54810:     sizePixels.height = desc.Height;
 54810: 
 54810:     newSurf->surface = texture;
 54810: 
 54810:     /** Create the DXGI surface. */
 54810:     hr = newSurf->surface->QueryInterface(IID_IDXGISurface, (void**)&dxgiSurface);
 54810:     if (FAILED(hr)) {
 54810: 	goto FAIL_CREATE;
 54810:     }
 54810: 
 54810:     props = D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,
 54810: 					 D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, alpha));
 54810: 
 54810:     if (desc.MiscFlags & D3D10_RESOURCE_MISC_GDI_COMPATIBLE)
 54810: 	props.usage = D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE;
 54810: 
 54810:     hr = sD2DFactory->CreateDxgiSurfaceRenderTarget(dxgiSurface,
 54810: 						    props,
 54810: 						    &newSurf->rt);
 54810: 
 54810:     if (FAILED(hr)) {
 54810: 	goto FAIL_CREATE;
 54810:     }
 54810: 
 54810:     bitProps = D2D1::BitmapProperties(D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, 
 54810: 				      alpha));
 54810: 
 54810:     if (content != CAIRO_CONTENT_ALPHA) {
 54810: 	/* For some reason creation of shared bitmaps for A8 UNORM surfaces
 54810: 	 * doesn't work even though the documentation suggests it does. The
 54810: 	 * function will return an error if we try */
 54810: 	hr = newSurf->rt->CreateSharedBitmap(IID_IDXGISurface,
 54810: 					     dxgiSurface,
 54810: 					     &bitProps,
 54810: 					     &newSurf->surfaceBitmap);
 54810: 
 54810: 	if (FAILED(hr)) {
 54810: 	    goto FAIL_CREATE;
 54810: 	}
 54810:     }
 54810: 
 54810:     newSurf->rt->CreateSolidColorBrush(D2D1::ColorF(0, 1.0), &newSurf->solidColorBrush);
 54810: 
 70960:     _cairo_d2d_surface_init(newSurf, d2d_device, _cairo_format_from_content(content));
 54810: 
 54810:     return reinterpret_cast<cairo_surface_t*>(newSurf);
 54810: 
 54810: FAIL_CREATE:
 54810:     newSurf->~cairo_d2d_surface_t();
 54810:     free(newSurf);
 54810:     return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
 54810: }
 54810: 
 72424: ID3D10Texture2D*
 72424: cairo_d2d_surface_get_texture(cairo_surface_t *surface)
 72424: {
 72424:     if (surface->type != CAIRO_SURFACE_TYPE_D2D) {
 72424:         return NULL;
 72424:     }
 72424: 
 72424:     cairo_d2d_surface_t *d2dsurf = reinterpret_cast<cairo_d2d_surface_t*>(surface);
 72424: 
 72424:     RefPtr<ID3D10Texture2D> texture;
 72424:     d2dsurf->surface->QueryInterface(&texture);
 72424: 
 72424:     return texture;
 72424: }
 72424: 
 37412: void cairo_d2d_scroll(cairo_surface_t *surface, int x, int y, cairo_rectangle_t *clip)
 37412: {
 37412:     if (surface->type != CAIRO_SURFACE_TYPE_D2D) {
 37412: 	return;
 37412:     }
 37412:     cairo_d2d_surface_t *d2dsurf = reinterpret_cast<cairo_d2d_surface_t*>(surface);
 37412: 
 37412:     /** For now, we invalidate our storing texture with this operation. */
 37412:     D2D1_POINT_2U point;
 37412:     D3D10_BOX rect;
 37412:     rect.front = 0;
 37412:     rect.back = 1;
 37412: 
 40634:     RefPtr<IDXGISurface> dxgiSurface;
 38949:     d2dsurf->surface->QueryInterface(&dxgiSurface);
 38949:     DXGI_SURFACE_DESC desc;
 38949: 
 38949:     dxgiSurface->GetDesc(&desc);
 38949: 
 38949:     /**
 38949:      * It's important we constrain the size of the clip region to the area of
 38949:      * the surface. If we don't we might get a box that goes outside the
 38949:      * surface, and CopySubresourceRegion will become very angry with us.
 38949:      * It will cause a device failure and subsequent drawing will break.
 38949:      */
 38949:     clip->x = MAX(clip->x, 0);
 38949:     clip->y = MAX(clip->y, 0);
 38949:     clip->width = MIN(clip->width, desc.Width - clip->x);
 38949:     clip->height = MIN(clip->height, desc.Height - clip->y);
 38949: 
 37412:     if (x < 0) {
 37412: 	point.x = (UINT32)clip->x;
 37412: 	rect.left = (UINT)(clip->x - x);
 37412: 	rect.right = (UINT)(clip->x + clip->width);
 37412:     } else {
 37412: 	point.x = (UINT32)(clip->x + x);
 37412: 	rect.left = (UINT)clip->x;
 37412: 	rect.right = (UINT32)(clip->x + clip->width - x);
 37412:     }
 37412:     if (y < 0) {
 37412: 	point.y = (UINT32)clip->y;
 37412: 	rect.top = (UINT)(clip->y - y);
 37412: 	rect.bottom = (UINT)(clip->y + clip->height);
 37412:     } else {
 37412: 	point.y = (UINT32)(clip->y + y);
 37412: 	rect.top = (UINT)clip->y;
 37412: 	rect.bottom = (UINT)(clip->y + clip->height - y);
 37412:     }
 37412:     ID3D10Texture2D *texture = _cairo_d2d_get_buffer_texture(d2dsurf);
 37412: 
 49320:     d2dsurf->device->mD3D10Device->CopyResource(texture, d2dsurf->surface);
 49320:     d2dsurf->device->mD3D10Device->CopySubresourceRegion(d2dsurf->surface,
 37412: 						  0,
 37412: 						  point.x,
 37412: 						  point.y,
 37412: 						  0,
 37412: 						  texture,
 37412: 						  0,
 37412: 						  &rect);
 37412: 
 37412: }
 38825: 
 43935: HDC
 43935: cairo_d2d_get_dc(cairo_surface_t *surface, cairo_bool_t retain_contents)
 43935: {
 43935:     if (surface->type != CAIRO_SURFACE_TYPE_D2D) {
 43935: 	return NULL;
 43935:     }
 43935:     cairo_d2d_surface_t *d2dsurf = reinterpret_cast<cairo_d2d_surface_t*>(surface);
 43935: 
 43935:     /* We'll pop the clip here manually so that we'll stay in drawing state if we
 43935:      * already are, we need to ensure d2dsurf->isDrawing manually then though 
 43935:      */
 43935: 
 43935:     /* Clips aren't allowed as per MSDN docs */
 46450:     reset_clip(d2dsurf);
 43935: 
 43935:     if (!d2dsurf->isDrawing) {
 43935:       /* GetDC must be called between BeginDraw/EndDraw */
 43935:       d2dsurf->rt->BeginDraw();
 43935:       d2dsurf->isDrawing = true;
 43935:     }
 43935: 
 43935:     RefPtr<ID2D1GdiInteropRenderTarget> interopRT;
 43935: 
 48033:     /* This QueryInterface call will always succeed even if the
 48033:      * the render target doesn't support the ID2D1GdiInteropRenderTarget
 48033:      * interface */
 43935:     d2dsurf->rt->QueryInterface(&interopRT);
 43935: 
 48033:     HDC dc;
 43935:     HRESULT rv;
 43935: 
 43935:     rv = interopRT->GetDC(retain_contents ? D2D1_DC_INITIALIZE_MODE_COPY :
 48033: 	D2D1_DC_INITIALIZE_MODE_CLEAR, &dc);
 43935: 
 43935:     if (FAILED(rv)) {
 43935: 	return NULL;
 43935:     }
 43935: 
 48033:     return dc;
 43935: }
 43935: 
 43935: void
 43935: cairo_d2d_release_dc(cairo_surface_t *surface, const cairo_rectangle_int_t *updated_rect)
 43935: {
 43935:     if (surface->type != CAIRO_SURFACE_TYPE_D2D) {
 43935: 	return;
 43935:     }
 43935:     cairo_d2d_surface_t *d2dsurf = reinterpret_cast<cairo_d2d_surface_t*>(surface);
 43935: 
 43935:     RefPtr<ID2D1GdiInteropRenderTarget> interopRT;
 43935: 
 43935:     d2dsurf->rt->QueryInterface(&interopRT);
 43935: 
 43935:     if (!updated_rect) {
 43935: 	interopRT->ReleaseDC(NULL);
 43935: 	return;
 43935:     }
 43935:     
 43935:     RECT r;
 43935:     r.left = updated_rect->x;
 43935:     r.top = updated_rect->y;
 43935:     r.right = r.left + updated_rect->width;
 43935:     r.bottom = r.top + updated_rect->height;
 43935: 
 43935:     interopRT->ReleaseDC(&r);
 46437: }
 46437: 
 46437: int
 46437: cairo_d2d_get_image_surface_cache_usage()
 46437: {
 46437:   return _cairo_atomic_int_get(&cache_usage);
 46437: }
 50775: 
 50775: int
 50775: cairo_d2d_get_surface_vram_usage(cairo_device_t *device)
 50775: {
 50775:     cairo_d2d_device_t *d2d_device = reinterpret_cast<cairo_d2d_device_t*>(device);
 50775:     return d2d_device->mVRAMUsage;
 50775: }
 82415: 
 82415: int
 82415: cairo_d2d_surface_get_width(cairo_surface_t *surface)
 82415: {
 82415:     if (surface->backend != &cairo_d2d_surface_backend) {
 82415: 	    _cairo_error_throw (CAIRO_STATUS_SURFACE_TYPE_MISMATCH);
 82415: 	    return 0;
 82415:     }
 82415: 
 82415:     cairo_d2d_surface_t *d2dsurf = reinterpret_cast<cairo_d2d_surface_t*>(surface);
 82415:     D2D1_SIZE_U size = d2dsurf->rt->GetPixelSize();
 82415:     return size.width;
 82415: }
 82415: 
 82415: int
 82415: cairo_d2d_surface_get_height(cairo_surface_t *surface)
 82415: {
 82415:     if (surface->backend != &cairo_d2d_surface_backend) {
 82415: 	    _cairo_error_throw (CAIRO_STATUS_SURFACE_TYPE_MISMATCH);
 82415: 	    return 0;
 82415:     }
 82415: 
 82415:     cairo_d2d_surface_t *d2dsurf = reinterpret_cast<cairo_d2d_surface_t*>(surface);
 82415:     D2D1_SIZE_U size = d2dsurf->rt->GetPixelSize();
 82415:     return size.height;
 82415: }
