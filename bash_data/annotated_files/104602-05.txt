 35963: //
 35963: // Autogenerated from Python template.  Hands off.
 35963: //
 35963: 
 36159: #include <stdlib.h>
 35963: #include <string.h>
 35963: 
 89318: #include "IPDLUnitTests.h"
 89318: 
 35963: #include "base/command_line.h"
 35963: #include "base/string_util.h"
 83466: #include "base/thread.h"
 35963: 
 43908: #include "nsRegion.h"
 43908: 
 35963: #include "IPDLUnitTestSubprocess.h"
 35963: 
 35963: //-----------------------------------------------------------------------------
 35963: //===== TEMPLATED =====
 35963: ${INCLUDES}
 35963: //-----------------------------------------------------------------------------
 35963: 
 83466: using namespace base;
 89318: using namespace std;
 35963: 
 89318: namespace mozilla {
 89318: namespace _ipdltest {
 36606: 
 89318: void* gParentActor;
 89318: IPDLUnitTestSubprocess* gSubprocess;
 89318: 
 89318: void* gChildActor;
 36606: 
 83466: // Note: in threaded mode, this will be non-null (for both parent and
 83466: // child, since they share one set of globals).  
 89318: Thread* gChildThread;
 83466: MessageLoop *gParentMessageLoop;
 83466: bool gParentDone;
 83466: bool gChildDone;
 83466: 
 35963: //-----------------------------------------------------------------------------
 35963: // data/functions accessed by both parent and child processes
 35963: 
 36165: char* gIPDLUnitTestName = NULL;
 35963: 
 35963: const char* const
 35963: IPDLUnitTestName()
 35963: {
 35963:     if (!gIPDLUnitTestName) {
 36050: #if defined(OS_WIN)
 89318:         vector<wstring> args =
 35963:             CommandLine::ForCurrentProcess()->GetLooseValues();
 93782:         gIPDLUnitTestName = ::strdup(WideToUTF8(args[0]).c_str());
 36050: #elif defined(OS_POSIX)
 89318:         vector<string> argv = CommandLine::ForCurrentProcess()->argv();
 89318:         gIPDLUnitTestName = ::moz_xstrdup(argv[1].c_str());
 35985: #else
 36050: #  error Sorry
 35985: #endif
 35963:     }
 35963:     return gIPDLUnitTestName;
 35963: }
 35963: 
 35963: } // namespace _ipdltest
 35963: } // namespace mozilla
 35963: 
 35963: 
 35963: namespace {
 35963: 
 35963: enum IPDLUnitTestType {
 35963:     NoneTest = 0,
 35963: 
 35963: //-----------------------------------------------------------------------------
 35963: //===== TEMPLATED =====
 35963: ${ENUM_VALUES}
 35963:     
 35963:     LastTest = ${LAST_ENUM}
 35963: //-----------------------------------------------------------------------------
 35963: };
 35963: 
 35963: 
 35963: IPDLUnitTestType
 35963: IPDLUnitTestFromString(const char* const aString)
 35963: {
 35963:     if (!aString)
 35963:         return static_cast<IPDLUnitTestType>(0);
 35963: //-----------------------------------------------------------------------------
 35963: //===== TEMPLATED =====
 35963: ${STRING_TO_ENUMS}
 35963: //-----------------------------------------------------------------------------
 35963:     else
 35963:         return static_cast<IPDLUnitTestType>(0);
 35963: }
 35963: 
 35963: 
 35963: const char* const
 35963: IPDLUnitTestToString(IPDLUnitTestType aTest)
 35963: {
 35963:     switch (aTest) {
 35963: //-----------------------------------------------------------------------------
 35963: //===== TEMPLATED =====
 35963: ${ENUM_TO_STRINGS}
 35963: //-----------------------------------------------------------------------------
 35963: 
 35963:     default:
 35963:         return NULL;
 35963:     }
 35963: }
 35963: 
 35963: 
 35963: IPDLUnitTestType
 35963: IPDLUnitTest()
 35963: {
104602:     return IPDLUnitTestFromString(::mozilla::_ipdltest::IPDLUnitTestName());
 35963: }
 35963: 
 35963: 
 35963: } // namespace <anon>
 35963: 
 35963: 
 35963: //-----------------------------------------------------------------------------
 35963: // parent process only
 35963: 
 35963: namespace mozilla {
 35963: namespace _ipdltest {
 35963: 
 35963: void
 83466: DeferredParentShutdown();
 83466: 
 83466: void
 83466: IPDLUnitTestThreadMain(char *testString);
 83466: 
 83466: void
 35963: IPDLUnitTestMain(void* aData)
 35963: {
 35963:     char* testString = reinterpret_cast<char*>(aData);
 83466: 
 83466:     // Check if we are to run the test using threads instead:
 83466:     const char *prefix = "thread:";
 83466:     const int prefixLen = strlen(prefix);
 83466:     if (!strncmp(testString, prefix, prefixLen)) {
 83466:         IPDLUnitTestThreadMain(testString + prefixLen);
 83466:         return;
 83466:     }
 83466: 
 35963:     IPDLUnitTestType test = IPDLUnitTestFromString(testString);
 35963:     if (!test) {
 35963:         // use this instead of |fail()| because we don't know what the test is
 39636:         fprintf(stderr, MOZ_IPDL_TESTFAIL_LABEL "| %s | unknown unit test %s\n",
 35963:                 "<--->", testString);
 35963:         NS_RUNTIMEABORT("can't continue");
 35963:     }
 35963:     gIPDLUnitTestName = testString;
 35963: 
 83466:     // Check whether this test is enabled for processes:
 83466:     switch (test) {
 83466: //-----------------------------------------------------------------------------
 83466: //===== TEMPLATED =====
 83466: ${PARENT_ENABLED_CASES_PROC}
 83466: //-----------------------------------------------------------------------------
 83466: 
 83466:     default:
 83466:         fail("not reached");
 83466:         return;                 // unreached
 83466:     }
 83466: 
 39636:     printf(MOZ_IPDL_TESTINFO_LABEL "| running test | %s\n", gIPDLUnitTestName);
 39636: 
 36050:     std::vector<std::string> testCaseArgs;
 36050:     testCaseArgs.push_back(testString);
 35963: 
 36159:     gSubprocess = new IPDLUnitTestSubprocess();
 36159:     if (!gSubprocess->SyncLaunch(testCaseArgs))
 35963:         fail("problem launching subprocess");
 35963: 
 36159:     IPC::Channel* transport = gSubprocess->GetChannel();
 35963:     if (!transport)
 35963:         fail("no transport");
 35963: 
 36159:     base::ProcessHandle child = gSubprocess->GetChildProcessHandle();
 36159: 
 35963:     switch (test) {
 35963: //-----------------------------------------------------------------------------
 35963: //===== TEMPLATED =====
 83466: ${PARENT_MAIN_CASES_PROC}
 83466: //-----------------------------------------------------------------------------
 83466: 
 83466:     default:
 83466:         fail("not reached");
 83466:         return;                 // unreached
 83466:     }
 83466: }
 83466: 
 83466: void
 83466: IPDLUnitTestThreadMain(char *testString)
 83466: {
 83466:     IPDLUnitTestType test = IPDLUnitTestFromString(testString);
 83466:     if (!test) {
 83466:         // use this instead of |fail()| because we don't know what the test is
 83466:         fprintf(stderr, MOZ_IPDL_TESTFAIL_LABEL "| %s | unknown unit test %s\n",
 83466:                 "<--->", testString);
 83466:         NS_RUNTIMEABORT("can't continue");
 83466:     }
 83466:     gIPDLUnitTestName = testString;
 83466: 
 83466:     // Check whether this test is enabled for threads:
 83466:     switch (test) {
 83466: //-----------------------------------------------------------------------------
 83466: //===== TEMPLATED =====
 83466: ${PARENT_ENABLED_CASES_THREAD}
 83466: //-----------------------------------------------------------------------------
 83466: 
 83466:     default:
 83466:         fail("not reached");
 83466:         return;                 // unreached
 83466:     }
 83466: 
 83466:     printf(MOZ_IPDL_TESTINFO_LABEL "| running test | %s\n", gIPDLUnitTestName);
 83466: 
 83466:     std::vector<std::string> testCaseArgs;
 83466:     testCaseArgs.push_back(testString);
 83466: 
 83466:     gChildThread = new Thread("ParentThread");
 83466:     if (!gChildThread->Start())
 83466:         fail("starting parent thread");
 83466: 
 83466:     gParentMessageLoop = MessageLoop::current();
 83466:     MessageLoop *childMessageLoop = gChildThread->message_loop();
 83466: 
 83466:     switch (test) {
 83466: //-----------------------------------------------------------------------------
 83466: //===== TEMPLATED =====
 83466: ${PARENT_MAIN_CASES_THREAD}
 35963: //-----------------------------------------------------------------------------
 35963: 
 35963:     default:
 35963:         fail("not reached");
 35963:         return;                 // unreached
 35963:     }
 35963: }
 35963: 
 36165: void
 36606: DeleteParentActor()
 36606: {
 36606:     if (!gParentActor)
 36606:         return;
 36606: 
 36606:     switch (IPDLUnitTest()) {
 36606: //-----------------------------------------------------------------------------
 36606: //===== TEMPLATED =====
 36606: ${PARENT_DELETE_CASES}
 36606: //-----------------------------------------------------------------------------
104602:     default:  ::mozilla::_ipdltest::fail("???");
 36606:     }
 36606: }
 36606: 
 36606: void
 36606: QuitXPCOM()
 36606: {
 36606:   DeleteParentActor();
 36606: 
 36606:   static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
 36606:   nsCOMPtr<nsIAppShell> appShell (do_GetService(kAppShellCID));
 36606:   appShell->Exit();
 36606: }
 36606: 
 36606: void
 36606: DeleteSubprocess(MessageLoop* uiLoop)
 36606: {
 36606:   // pong to QuitXPCOM
 36606:   delete gSubprocess;
 36606:   uiLoop->PostTask(FROM_HERE, NewRunnableFunction(QuitXPCOM));
 36606: }
 36606: 
 36606: void
 36606: DeferredParentShutdown()
 36606: {
 36606:     // ping to DeleteSubprocess
 36606:     XRE_GetIOMessageLoop()->PostTask(
 36606:         FROM_HERE,
 36606:         NewRunnableFunction(DeleteSubprocess, MessageLoop::current()));
 36606: }
 36606: 
 36606: void 
 83466: TryThreadedShutdown()
 83466: {
 83466:     // Stop if either: 
 83466:     // - the child has not finished, 
 83466:     // - the parent has not finished,
 83466:     // - or this code has already executed.
 83466:     // Remember: this TryThreadedShutdown() task is enqueued
 83466:     // by both parent and child (though always on parent's msg loop).
 83466:     if (!gChildDone || !gParentDone || !gChildThread)
 83466:         return;
 83466: 
 83466:     delete gChildThread;
 83466:     gChildThread = 0;
 83466:     DeferredParentShutdown();
 83466: }
 83466: 
 83466: void 
 83466: ChildCompleted()
 83466: {
 83466:     // Executes on the parent message loop once child has completed.
 83466:     gChildDone = true;
 83466:     TryThreadedShutdown();
 83466: }
 83466: 
 83466: void
 36165: QuitParent()
 36165: {
 83466:     if (gChildThread) {
 83466:         gParentDone = true;
 83466:         MessageLoop::current()->PostTask(
 83466:             FROM_HERE, NewRunnableFunction(TryThreadedShutdown));
 83466:     } else {
 36166:         // defer "real" shutdown to avoid *Channel::Close() racing with the
 36166:         // deletion of the subprocess
 36166:         MessageLoop::current()->PostTask(
 36166:             FROM_HERE, NewRunnableFunction(DeferredParentShutdown));
 36165:     }
 83466: }
 83466: 
 83466: void
 83466: QuitChild()
 83466: {
 83466:     if (gChildThread) { // Threaded-mode test
 83466:         gParentMessageLoop->PostTask(
 83466:             FROM_HERE, NewRunnableFunction(ChildCompleted));
 83466:     } else { // Process-mode test
 83466:         XRE_ShutdownChildProcess();
 83466:     }
 83466: }
 36165: 
 35963: } // namespace _ipdltest
 35963: } // namespace mozilla
 35963: 
 35963: 
 35963: //-----------------------------------------------------------------------------
 35963: // child process only
 35963: 
 36606: namespace mozilla {
 36606: namespace _ipdltest {
 36159: 
 36159: void
 36159: DeleteChildActor()
 36159: {
 36159:     if (!gChildActor)
 36159:         return;
 36159: 
 36159:     switch (IPDLUnitTest()) {
 36159: //-----------------------------------------------------------------------------
 36159: //===== TEMPLATED =====
 36159: ${CHILD_DELETE_CASES}
 36159: //-----------------------------------------------------------------------------
104602:     default:  ::mozilla::_ipdltest::fail("???");
 36159:     }
 36159: }
 36159: 
 35963: void
 36016: IPDLUnitTestChildInit(IPC::Channel* transport,
 36016:                       base::ProcessHandle parent,
 36016:                       MessageLoop* worker)
 35963: {
 36159:     if (atexit(DeleteChildActor))
 36159:         fail("can't install atexit() handler");
 36159: 
 35963:     switch (IPDLUnitTest()) {
 35963: //-----------------------------------------------------------------------------
 35963: //===== TEMPLATED =====
 35963: ${CHILD_INIT_CASES}
 35963: //-----------------------------------------------------------------------------
 35963: 
 35963:     default:
 35963:         fail("not reached");
 35963:         return;                 // unreached
 35963:     }
 35963: }
 35963: 
 35963: } // namespace _ipdltest
 35963: } // namespace mozilla
