  1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
  1: /* vim: set ts=2 sw=2 et tw=80: */
  1: /* ***** BEGIN LICENSE BLOCK *****
  1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  1:  *
  1:  * The contents of this file are subject to the Mozilla Public License Version
  1:  * 1.1 (the "License"); you may not use this file except in compliance with
  1:  * the License. You may obtain a copy of the License at
  1:  * http://www.mozilla.org/MPL/
  1:  *
  1:  * Software distributed under the License is distributed on an "AS IS" basis,
  1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  1:  * for the specific language governing rights and limitations under the
  1:  * License.
  1:  *
  1:  * The Original Code is Mozilla Communicator client code.
  1:  *
  1:  * The Initial Developer of the Original Code is
  1:  * Netscape Communications Corporation.
  1:  * Portions created by the Initial Developer are Copyright (C) 1998
  1:  * the Initial Developer. All Rights Reserved.
  1:  *
  1:  * Contributor(s):
  1:  *   Dan Rosen <dr@netscape.com>
  1:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
  1:  *   Mats Palmgren <mats.palmgren@bredband.net>
  1:  *
  1:  * Alternatively, the contents of this file may be used under the terms of
  1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
  1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  1:  * in which case the provisions of the GPL or the LGPL are applicable instead
  1:  * of those above. If you wish to allow use of your version of this file only
  1:  * under the terms of either the GPL or the LGPL, and not to allow others to
  1:  * use your version of this file under the terms of the MPL, indicate your
  1:  * decision by deleting the provisions above and replace them with the notice
  1:  * and other provisions required by the GPL or the LGPL. If you do not delete
  1:  * the provisions above, a recipient may use your version of this file under
  1:  * the terms of any one of the MPL, the GPL or the LGPL.
  1:  *
  1:  * ***** END LICENSE BLOCK ***** */
  1: 
  1: /* container for a document and its presentation */
  1: 
  1: #include "nscore.h"
  1: #include "nsCOMPtr.h"
  1: #include "nsCRT.h"
  1: #include "nsString.h"
  1: #include "nsReadableUtils.h"
  1: #include "nsISupports.h"
  1: #include "nsIContent.h"
  1: #include "nsIContentViewerContainer.h"
  1: #include "nsIDocumentViewer.h"
  1: #include "nsIDocumentViewerPrint.h"
  1: 
  1: #include "nsIDocument.h"
  1: #include "nsPresContext.h"
  1: #include "nsIPresShell.h"
  1: #include "nsIEventStateManager.h"
  1: #include "nsStyleSet.h"
  1: #include "nsIStyleSheet.h"
  1: #include "nsICSSStyleSheet.h"
  1: #include "nsIFrame.h"
  1: 
  1: #include "nsILinkHandler.h"
  1: #include "nsIDOMDocument.h"
  1: #include "nsISelectionListener.h"
  1: #include "nsISelectionPrivate.h"
  1: #include "nsIDOMHTMLDocument.h"
  1: #include "nsIDOMNSHTMLDocument.h"
  1: #include "nsIDOMHTMLCollection.h"
  1: #include "nsIDOMHTMLElement.h"
  1: #include "nsIDOMRange.h"
  1: #include "nsContentCID.h"
  1: #include "nsLayoutCID.h"
  1: #include "nsContentUtils.h"
  1: #include "nsLayoutStylesheetCache.h"
  1: 
  1: #include "nsViewsCID.h"
  1: #include "nsWidgetsCID.h"
  1: #include "nsIDeviceContext.h"
  1: #include "nsIDeviceContextSpec.h"
  1: #include "nsIViewManager.h"
  1: #include "nsIView.h"
  1: #include "nsView.h" // For nsView::GetViewFor
  1: 
  1: #include "nsIPageSequenceFrame.h"
  1: #include "nsIURL.h"
  1: #include "nsNetUtil.h"
  1: #include "nsIContentViewerEdit.h"
  1: #include "nsIContentViewerFile.h"
  1: #include "nsICSSLoader.h"
  1: #include "nsIMarkupDocumentViewer.h"
  1: #include "nsIInterfaceRequestor.h"
  1: #include "nsIInterfaceRequestorUtils.h"
  1: #include "nsIDocShellTreeItem.h"
  1: #include "nsIDocShellTreeNode.h"
  1: #include "nsIDocShellTreeOwner.h"
  1: #include "nsIDocShell.h"
  1: #include "nsIBaseWindow.h"
  1: #include "nsIFrameDebug.h"
  1: #include "nsILayoutHistoryState.h"
  1: #include "nsIParser.h"
  1: #include "nsGUIEvent.h"
  1: #include "nsHTMLReflowState.h"
  1: #include "nsIDOMHTMLAnchorElement.h"
  1: #include "nsIDOMHTMLAreaElement.h"
  1: #include "nsIDOMHTMLLinkElement.h"
  1: #include "nsIImageLoadingContent.h"
  1: #include "nsCopySupport.h"
  1: #include "nsIDOMHTMLFrameSetElement.h"
  1: #ifdef MOZ_XUL
  1: #include "nsIXULDocument.h"
  1: #endif
  1: #include "nsPrintfCString.h"
  1: 
  1: #include "nsIClipboardHelper.h"
  1: 
  1: #include "nsPIDOMWindow.h"
  1: #include "nsJSEnvironment.h"
  1: #include "nsIFocusController.h"
  1: #include "nsIMenuParent.h"
  1: 
  1: #include "nsIScrollableView.h"
  1: #include "nsIHTMLDocument.h"
  1: #include "nsITimelineService.h"
  1: #include "nsGfxCIID.h"
  1: #include "nsStyleSheetService.h"
  1: 
  1: #include "nsIPrompt.h"
  1: #include "imgIContainer.h" // image animation mode constants
  1: 
  1: //--------------------------
  1: // Printing Include
  1: //---------------------------
  1: #ifdef NS_PRINTING
  1: 
  1: #include "nsIWebBrowserPrint.h"
  1: 
  1: #include "nsPrintEngine.h"
  1: 
  1: // Print Options
  1: #include "nsIPrintSettings.h"
  1: #include "nsIPrintSettingsService.h"
  1: #include "nsIPrintOptions.h"
  1: #include "nsIServiceManager.h"
  1: #include "nsISimpleEnumerator.h"
  1: #include "nsXPCOM.h"
  1: #include "nsISupportsPrimitives.h"
  1: 
  1: // PrintOptions is now implemented by PrintSettingsService
  1: static const char sPrintOptionsContractID[]         = "@mozilla.org/gfx/printsettings-service;1";
  1: 
  1: // Printing Events
  1: #include "nsPrintPreviewListener.h"
  1: 
  1: #include "nsIDOMHTMLFrameElement.h"
  1: #include "nsIDOMHTMLIFrameElement.h"
  1: #include "nsIDOMHTMLObjectElement.h"
  1: #include "nsIPluginDocument.h"
  1: 
  1: // Print Progress
  1: #include "nsIPrintProgress.h"
  1: #include "nsIPrintProgressParams.h"
  1: 
  1: // Print error dialog
  1: #include "nsIWindowWatcher.h"
  1: 
  1: // Printing 
  1: #include "nsPrintEngine.h"
  1: #include "nsPagePrintTimer.h"
  1: 
  1: #endif // NS_PRINTING
  1: 
  1: // FrameSet
  1: #include "nsIDocument.h"
  1: 
  1: //focus
  1: #include "nsIDOMEventReceiver.h"
  1: #include "nsIDOMFocusListener.h"
  1: #include "nsISelectionController.h"
  1: 
  1: #include "nsBidiUtils.h"
  1: #include "nsISHEntry.h"
  1: #include "nsISHistory.h"
  1: #include "nsISHistoryInternal.h"
  1: #include "nsIWebNavigation.h"
  1: #include "nsWeakPtr.h"
  1: #include "nsEventDispatcher.h"
  1: 
  1: //paint forcing
  1: #include "prenv.h"
  1: #include <stdio.h>
  1: 
  1: //switch to page layout
  1: #include "nsGfxCIID.h"
  1: 
  1: #ifdef NS_DEBUG
  1: 
  1: #undef NOISY_VIEWER
  1: #else
  1: #undef NOISY_VIEWER
  1: #endif
  1: 
  1: //-----------------------------------------------------
  1: // PR LOGGING
  1: #ifdef MOZ_LOGGING
  1: #define FORCE_PR_LOG /* Allow logging in the release build */
  1: #endif
  1: 
  1: #include "prlog.h"
  1: 
  1: #ifdef PR_LOGGING
  1: 
  1: static PRLogModuleInfo * kPrintingLogMod = PR_NewLogModule("printing");
  1: #define PR_PL(_p1)  PR_LOG(kPrintingLogMod, PR_LOG_DEBUG, _p1);
  1: 
  1: #define PRT_YESNO(_p) ((_p)?"YES":"NO")
  1: #else
  1: #define PRT_YESNO(_p)
  1: #define PR_PL(_p1)
  1: #endif
  1: //-----------------------------------------------------
  1: 
  1: class DocumentViewerImpl;
  1: 
  1: // a small delegate class used to avoid circular references
  1: 
  1: #ifdef XP_MAC
  1: #pragma mark ** nsDocViewerSelectionListener **
  1: #endif
  1: 
  1: class nsDocViewerSelectionListener : public nsISelectionListener
  1: {
  1: public:
  1: 
  1:   // nsISupports interface...
  1:   NS_DECL_ISUPPORTS
  1: 
  1:   // nsISelectionListerner interface
  1:   NS_DECL_NSISELECTIONLISTENER
  1: 
  1:                        nsDocViewerSelectionListener()
  1:                        : mDocViewer(NULL)
  1:                        , mGotSelectionState(PR_FALSE)
  1:                        , mSelectionWasCollapsed(PR_FALSE)
  1:                        {
  1:                        }
  1: 
  1:   virtual              ~nsDocViewerSelectionListener() {}
  1: 
  1:   nsresult             Init(DocumentViewerImpl *aDocViewer);
  1: 
  1: protected:
  1: 
  1:   DocumentViewerImpl*  mDocViewer;
  1:   PRPackedBool         mGotSelectionState;
  1:   PRPackedBool         mSelectionWasCollapsed;
  1: 
  1: };
  1: 
  1: 
  1: /** editor Implementation of the FocusListener interface
  1:  */
  1: class nsDocViewerFocusListener : public nsIDOMFocusListener
  1: {
  1: public:
  1:   /** default constructor
  1:    */
  1:   nsDocViewerFocusListener();
  1:   /** default destructor
  1:    */
  1:   virtual ~nsDocViewerFocusListener();
  1: 
  1: 
  1: /*interfaces for addref and release and queryinterface*/
  1:   NS_DECL_ISUPPORTS
  1: 
  1: /*BEGIN implementations of focus event handler interface*/
  1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent);
  1:   NS_IMETHOD Focus(nsIDOMEvent* aEvent);
  1:   NS_IMETHOD Blur(nsIDOMEvent* aEvent);
  1: /*END implementations of focus event handler interface*/
  1:   nsresult             Init(DocumentViewerImpl *aDocViewer);
  1: 
  1: private:
  1:     DocumentViewerImpl*  mDocViewer;
  1: };
  1: 
  1: 
  1: 
  1: #ifdef XP_MAC
  1: #pragma mark ** DocumentViewerImpl **
  1: #endif
  1: 
  1: //-------------------------------------------------------------
  1: class DocumentViewerImpl : public nsIDocumentViewer,
  1:                            public nsIContentViewerEdit,
  1:                            public nsIContentViewerFile,
  1:                            public nsIMarkupDocumentViewer,
  1:                            public nsIDocumentViewerPrint
  1: 
  1: #ifdef NS_PRINTING
  1:                            , public nsIWebBrowserPrint
  1: #endif
  1: 
  1: {
  1:   friend class nsDocViewerSelectionListener;
  1:   friend class nsPagePrintTimer;
  1:   friend class nsPrintEngine;
  1: 
  1: public:
  1:   DocumentViewerImpl();
  1: 
  1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
  1: 
  1:   // nsISupports interface...
  1:   NS_DECL_ISUPPORTS
  1: 
  1:   // nsIContentViewer interface...
  1:   NS_DECL_NSICONTENTVIEWER
  1: 
  1:   // nsIDocumentViewer interface...
  1:   NS_IMETHOD SetUAStyleSheet(nsIStyleSheet* aUAStyleSheet);
  1:   NS_IMETHOD GetDocument(nsIDocument** aResult);
  1:   NS_IMETHOD GetPresShell(nsIPresShell** aResult);
  1:   NS_IMETHOD GetPresContext(nsPresContext** aResult);
  1: 
  1:   // nsIContentViewerEdit
  1:   NS_DECL_NSICONTENTVIEWEREDIT
  1: 
  1:   // nsIContentViewerFile
  1:   NS_DECL_NSICONTENTVIEWERFILE
  1: 
  1:   // nsIMarkupDocumentViewer
  1:   NS_DECL_NSIMARKUPDOCUMENTVIEWER
  1: 
  1: #ifdef NS_PRINTING
  1:   // nsIWebBrowserPrint
  1:   NS_DECL_NSIWEBBROWSERPRINT
  1: #endif
  1: 
  1:   typedef void (*CallChildFunc)(nsIMarkupDocumentViewer* aViewer,
  1:                                 void* aClosure);
  1:   void CallChildren(CallChildFunc aFunc, void* aClosure);
  1: 
  1:   // nsIDocumentViewerPrint Printing Methods
  1:   NS_DECL_NSIDOCUMENTVIEWERPRINT
  1: 
  1: protected:
  1:   virtual ~DocumentViewerImpl();
  1: 
  1: private:
  1:   nsresult MakeWindow(nsIWidget* aParentWidget,
  1:                       const nsRect& aBounds);
  1:   nsresult InitInternal(nsIWidget* aParentWidget,
  1:                         nsISupports *aState,
  1:                         nsIDeviceContext* aDeviceContext,
  1:                         const nsRect& aBounds,
  1:                         PRBool aDoCreation,
  1:                         PRBool aInPrintPreview,
  1:                         PRBool aNeedMakeCX = PR_TRUE);
  1:   nsresult InitPresentationStuff(PRBool aDoInitialReflow);
  1: 
  1:   nsresult GetPopupNode(nsIDOMNode** aNode);
  1:   nsresult GetPopupLinkNode(nsIDOMNode** aNode);
  1:   nsresult GetPopupImageNode(nsIImageLoadingContent** aNode);
  1: 
  1:   void DumpContentToPPM(const char* aFileName);
  1: 
  1:   void PrepareToStartLoad(void);
  1: 
  1:   nsresult SyncParentSubDocMap();
  1: 
  1:   nsresult GetDocumentSelection(nsISelection **aSelection);
  1: 
  1: #ifdef NS_PRINTING
  1:   // Called when the DocViewer is notified that the state
  1:   // of Printing or PP has changed
  1:   void SetIsPrintingInDocShellTree(nsIDocShellTreeNode* aParentNode, 
  1:                                    PRBool               aIsPrintingOrPP, 
  1:                                    PRBool               aStartAtTop);
  1: #endif // NS_PRINTING
  1: 
  1: protected:
  1:   // IMPORTANT: The ownership implicit in the following member
  1:   // variables has been explicitly checked and set using nsCOMPtr
  1:   // for owning pointers and raw COM interface pointers for weak
  1:   // (ie, non owning) references. If you add any members to this
  1:   // class, please make the ownership explicit (pinkerton, scc).
  1: 
  1:   nsWeakPtr mContainer; // it owns me!
  1:   nsCOMPtr<nsIDeviceContext> mDeviceContext;   // ??? can't hurt, but...
  1: 
  1:   // the following six items are explicitly in this order
  1:   // so they will be destroyed in the reverse order (pinkerton, scc)
  1:   nsCOMPtr<nsIDocument>    mDocument;
  1:   nsCOMPtr<nsIWidget>      mWindow;      // ??? should we really own it?
  1:   nsCOMPtr<nsIViewManager> mViewManager;
  1:   nsCOMPtr<nsPresContext> mPresContext;
  1:   nsCOMPtr<nsIPresShell>   mPresShell;
  1: 
  1:   nsCOMPtr<nsIStyleSheet>  mUAStyleSheet;
  1: 
  1:   nsCOMPtr<nsISelectionListener> mSelectionListener;
  1:   nsCOMPtr<nsIDOMFocusListener> mFocusListener;
  1: 
  1:   nsCOMPtr<nsIContentViewer> mPreviousViewer;
  1:   nsCOMPtr<nsISHEntry> mSHEntry;
  1: 
  1:   nsIWidget* mParentWidget;          // purposely won't be ref counted
  1: 
  1:   float mTextZoom;      // Text zoom, defaults to 1.0
  1: 
  1:   PRInt16 mNumURLStarts;
  1:   PRInt16 mDestroyRefCount;    // a second "refcount" for the document viewer's "destroy"
  1: 
  1:   unsigned      mEnableRendering : 1;
  1:   unsigned      mStopped : 1;
  1:   unsigned      mLoaded : 1;
  1:   unsigned      mDeferredWindowClose : 1;
  1:   // document management data
  1:   //   these items are specific to markup documents (html and xml)
  1:   //   may consider splitting these out into a subclass
  1:   unsigned      mIsSticky : 1;
  1:   unsigned      mInPermitUnload : 1;
  1: 
  1: #ifdef NS_PRINTING
  1:   unsigned      mClosingWhilePrinting : 1;
  1: 
  1: #if NS_PRINT_PREVIEW
  1:   // These data members support delayed printing when the document is loading
  1:   unsigned                         mPrintIsPending : 1;
  1:   unsigned                         mPrintDocIsFullyLoaded : 1;
  1:   nsCOMPtr<nsIPrintSettings>       mCachedPrintSettings;
  1:   nsCOMPtr<nsIWebProgressListener> mCachedPrintWebProgressListner;
  1: 
  1:   nsCOMPtr<nsPrintEngine>          mPrintEngine;
  1: #endif // NS_PRINT_PREVIEW
  1: 
  1: #ifdef NS_DEBUG
  1:   FILE* mDebugFile;
  1: #endif // NS_DEBUG
  1: #endif // NS_PRINTING
  1: 
  1:   /* character set member data */
  1:   PRInt32 mHintCharsetSource;
  1:   nsCString mHintCharset;
  1:   nsCString mDefaultCharacterSet;
  1:   nsCString mForceCharacterSet;
  1:   nsCString mPrevDocCharacterSet;
  1:   
  1:   PRPackedBool mIsPageMode;
  1: 
  1: };
  1: 
  1: //------------------------------------------------------------------
  1: // DocumentViewerImpl
  1: //------------------------------------------------------------------
  1: // Class IDs
  1: static NS_DEFINE_CID(kViewManagerCID,       NS_VIEW_MANAGER_CID);
  1: static NS_DEFINE_CID(kWidgetCID,            NS_CHILD_CID);
  1: 
  1: //------------------------------------------------------------------
  1: nsresult
  1: NS_NewDocumentViewer(nsIDocumentViewer** aResult)
  1: {
  1:   *aResult = new DocumentViewerImpl();
  1:   if (!*aResult) {
  1:     return NS_ERROR_OUT_OF_MEMORY;
  1:   }
  1: 
  1:   NS_ADDREF(*aResult);
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: void DocumentViewerImpl::PrepareToStartLoad()
  1: {
  1:   mEnableRendering  = PR_TRUE;
  1:   mStopped          = PR_FALSE;
  1:   mLoaded           = PR_FALSE;
  1:   mDeferredWindowClose = PR_FALSE;
  1: 
  1: #ifdef NS_PRINTING
  1:   mPrintIsPending        = PR_FALSE;
  1:   mPrintDocIsFullyLoaded = PR_FALSE;
  1:   mClosingWhilePrinting  = PR_FALSE;
  1: 
  1:   // Make sure we have destroyed it and cleared the data member
  1:   if (mPrintEngine) {
  1:     mPrintEngine->Destroy();
  1:     mPrintEngine = nsnull;
  1:   }
  1: 
  1: #ifdef NS_PRINT_PREVIEW
  1:   SetIsPrintPreview(PR_FALSE);
  1: #endif
  1: 
  1: #ifdef NS_DEBUG
  1:   mDebugFile = nsnull;
  1: #endif
  1: 
  1: #endif // NS_PRINTING
  1: }
  1: 
  1: // Note: operator new zeros our memory, so no need to init things to null.
  1: DocumentViewerImpl::DocumentViewerImpl()
  1:   : mTextZoom(1.0),
  1:     mIsSticky(PR_TRUE),
  1:     mHintCharsetSource(kCharsetUninitialized)
  1: {
  1:   PrepareToStartLoad();
  1: }
  1: 
  1: NS_IMPL_ADDREF(DocumentViewerImpl)
  1: NS_IMPL_RELEASE(DocumentViewerImpl)
  1: 
  1: NS_INTERFACE_MAP_BEGIN(DocumentViewerImpl)
  1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewer)
  1:     NS_INTERFACE_MAP_ENTRY(nsIDocumentViewer)
  1:     NS_INTERFACE_MAP_ENTRY(nsIMarkupDocumentViewer)
  1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewerFile)
  1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewerEdit)
  1:     NS_INTERFACE_MAP_ENTRY(nsIDocumentViewerPrint)
  1:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContentViewer)
  1: #ifdef NS_PRINTING
  1:     NS_INTERFACE_MAP_ENTRY(nsIWebBrowserPrint)
  1: #endif
  1: NS_INTERFACE_MAP_END
  1: 
  1: DocumentViewerImpl::~DocumentViewerImpl()
  1: {
  1:   if (mDocument) {
  1:     Close(nsnull);
  1:     mDocument->Destroy();
  1:   }
  1: 
  1:   NS_ASSERTION(!mPresShell && !mPresContext,
  1:                "User did not call nsIContentViewer::Destroy");
  1:   if (mPresShell || mPresContext) {
  1:     // Make sure we don't hand out a reference to the content viewer to
  1:     // the SHEntry!
  1:     mSHEntry = nsnull;
  1: 
  1:     Destroy();
  1:   }
  1: 
  1:   // XXX(?) Revoke pending invalidate events
  1: }
  1: 
  1: /*
  1:  * This method is called by the Document Loader once a document has
  1:  * been created for a particular data stream...  The content viewer
  1:  * must cache this document for later use when Init(...) is called.
  1:  *
  1:  * This method is also called when an out of band document.write() happens.
  1:  * In that case, the document passed in is the same as the previous document.
  1:  */
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::LoadStart(nsISupports *aDoc)
  1: {
  1: #ifdef NOISY_VIEWER
  1:   printf("DocumentViewerImpl::LoadStart\n");
  1: #endif
  1: 
  1:   nsresult rv = NS_OK;
  1:   if (!mDocument) {
  1:     mDocument = do_QueryInterface(aDoc, &rv);
  1:   }
  1:   else if (mDocument == aDoc) {
  1:     // Reset the document viewer's state back to what it was
  1:     // when the document load started.
  1:     PrepareToStartLoad();
  1:   }
  1: 
  1:   return rv;
  1: }
  1: 
  1: nsresult
  1: DocumentViewerImpl::SyncParentSubDocMap()
  1: {
  1:   nsCOMPtr<nsIDocShellTreeItem> item(do_QueryReferent(mContainer));
  1:   nsCOMPtr<nsPIDOMWindow> pwin(do_GetInterface(item));
  1:   nsCOMPtr<nsIContent> content;
  1: 
  1:   if (mDocument && pwin) {
  1:     content = do_QueryInterface(pwin->GetFrameElementInternal());
  1:   }
  1: 
  1:   if (content) {
  1:     nsCOMPtr<nsIDocShellTreeItem> parent;
  1:     item->GetParent(getter_AddRefs(parent));
  1: 
  1:     nsCOMPtr<nsIDOMWindow> parent_win(do_GetInterface(parent));
  1: 
  1:     if (parent_win) {
  1:       nsCOMPtr<nsIDOMDocument> dom_doc;
  1:       parent_win->GetDocument(getter_AddRefs(dom_doc));
  1: 
  1:       nsCOMPtr<nsIDocument> parent_doc(do_QueryInterface(dom_doc));
  1: 
  1:       if (parent_doc) {
  1:         return parent_doc->SetSubDocumentFor(content, mDocument);
  1:       }
  1:     }
  1:   }
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetContainer(nsISupports* aContainer)
  1: {
  1:   mContainer = do_GetWeakReference(aContainer);
  1:   if (mPresContext) {
  1:     mPresContext->SetContainer(aContainer);
  1:   }
  1: 
  1:   // We're loading a new document into the window where this document
  1:   // viewer lives, sync the parent document's frame element -> sub
  1:   // document map
  1: 
  1:   return SyncParentSubDocMap();
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetContainer(nsISupports** aResult)
  1: {
  1:    NS_ENSURE_ARG_POINTER(aResult);
  1: 
  1:    *aResult = nsnull;
  1:    nsCOMPtr<nsISupports> container = do_QueryReferent(mContainer);
  1:    container.swap(*aResult);
  1:    return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::Init(nsIWidget* aParentWidget,
  1:                          nsIDeviceContext* aDeviceContext,
  1:                          const nsRect& aBounds)
  1: {
  1:   return InitInternal(aParentWidget, nsnull, aDeviceContext, aBounds, PR_TRUE, PR_FALSE);
  1: }
  1: 
  1: nsresult
  1: DocumentViewerImpl::InitPresentationStuff(PRBool aDoInitialReflow)
  1: {
  1:   // Create the style set...
  1:   nsStyleSet *styleSet;
  1:   nsresult rv = CreateStyleSet(mDocument, &styleSet);
  1:   NS_ENSURE_SUCCESS(rv, rv);
  1: 
  1:   // Now make the shell for the document
  1:   rv = mDocument->CreateShell(mPresContext, mViewManager, styleSet,
  1:                               getter_AddRefs(mPresShell));
  1:   if (NS_FAILED(rv)) {
  1:     delete styleSet;
  1:     return rv;
  1:   }
  1: 
  1:   // We're done creating the style set
  1:   styleSet->EndUpdate();
  1: 
  1:   if (aDoInitialReflow) {
  1:     // Since InitialReflow() will create frames for *all* items
  1:     // that are currently in the document tree, we need to flush
  1:     // any pending notifications to prevent the content sink from
  1:     // duplicating layout frames for content it has added to the tree
  1:     // but hasn't notified the document about. (Bug 154018)
  1:     //
  1:     // Note that we are flushing before we add mPresShell as an observer
  1:     // to avoid bogus notifications.
  1: 
  1:     mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
  1:   }
  1: 
  1:   mPresShell->BeginObservingDocument();
  1: 
  1:   // Initialize our view manager
  1:   nsRect bounds;
  1:   mWindow->GetBounds(bounds);
  1: 
  1:   nscoord width = mPresContext->DevPixelsToAppUnits(bounds.width);
  1:   nscoord height = mPresContext->DevPixelsToAppUnits(bounds.height);
  1: 
  1:   mViewManager->DisableRefresh();
  1:   mViewManager->SetWindowDimensions(width, height);
  1:   mPresContext->SetTextZoom(mTextZoom);
  1: 
  1:   // Setup default view manager background color
  1: 
  1:   // This may be overridden by the docshell with the background color
  1:   // for the last document loaded into the docshell
  1:   mViewManager->SetDefaultBackgroundColor(mPresContext->DefaultBackgroundColor());
  1: 
  1:   if (aDoInitialReflow) {
  1:     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
  1:     if (htmlDoc) {
  1:       nsCOMPtr<nsIDOMHTMLFrameSetElement> frameset =
  1:         do_QueryInterface(mDocument->GetRootContent());
  1:       htmlDoc->SetIsFrameset(frameset != nsnull);
  1:     }
  1: 
  1:     // Initial reflow
  1:     mPresShell->InitialReflow(width, height);
  1: 
  1:     // Now trigger a refresh
  1:     if (mEnableRendering) {
  1:       mViewManager->EnableRefresh(NS_VMREFRESH_IMMEDIATE);
  1:     }
  1:   } else {
  1:     // Store the visible area so it's available for other callers of
  1:     // InitialReflow, like nsContentSink::StartLayout.
  1:     mPresContext->SetVisibleArea(nsRect(0, 0, width, height));
  1:   }
  1: 
  1:   // now register ourselves as a selection listener, so that we get
  1:   // called when the selection changes in the window
  1:   nsDocViewerSelectionListener *selectionListener =
  1:     new nsDocViewerSelectionListener();
  1:   NS_ENSURE_TRUE(selectionListener, NS_ERROR_OUT_OF_MEMORY);
  1: 
  1:   selectionListener->Init(this);
  1: 
  1:   // mSelectionListener is a owning reference
  1:   mSelectionListener = selectionListener;
  1: 
  1:   nsCOMPtr<nsISelection> selection;
  1:   rv = GetDocumentSelection(getter_AddRefs(selection));
  1:   NS_ENSURE_SUCCESS(rv, rv);
  1: 
  1:   nsCOMPtr<nsISelectionPrivate> selPrivate(do_QueryInterface(selection));
  1:   rv = selPrivate->AddSelectionListener(mSelectionListener);
  1:   if (NS_FAILED(rv))
  1:     return rv;
  1: 
  1:   // Save old listener so we can unregister it
  1:   nsCOMPtr<nsIDOMFocusListener> mOldFocusListener = mFocusListener;
  1: 
  1:   // focus listener
  1:   //
  1:   // now register ourselves as a focus listener, so that we get called
  1:   // when the focus changes in the window
  1:   nsDocViewerFocusListener *focusListener;
  1:   NS_NEWXPCOM(focusListener, nsDocViewerFocusListener);
  1:   NS_ENSURE_TRUE(focusListener, NS_ERROR_OUT_OF_MEMORY);
  1: 
  1:   focusListener->Init(this);
  1: 
  1:   // mFocusListener is a strong reference
  1:   mFocusListener = focusListener;
  1: 
  1:   // get the DOM event receiver
  1:   nsCOMPtr<nsIDOMEventReceiver> erP(do_QueryInterface(mDocument));
  1:   NS_ASSERTION(erP, "No event receiver in document!");
  1: 
  1:   if (erP) {
  1:     rv = erP->AddEventListenerByIID(mFocusListener,
  1:                                     NS_GET_IID(nsIDOMFocusListener));
  1:     NS_ASSERTION(NS_SUCCEEDED(rv), "failed to register focus listener");
  1:     if (mOldFocusListener) {
  1:       rv = erP->RemoveEventListenerByIID(mOldFocusListener,
  1:                                       NS_GET_IID(nsIDOMFocusListener));
  1:       NS_ASSERTION(NS_SUCCEEDED(rv), "failed to remove focus listener");
  1:     }
  1:   }
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: //-----------------------------------------------
  1: // This method can be used to initial the "presentation"
  1: // The aDoCreation indicates whether it should create
  1: // all the new objects or just initialize the existing ones
  1: nsresult
  1: DocumentViewerImpl::InitInternal(nsIWidget* aParentWidget,
  1:                                  nsISupports *aState,
  1:                                  nsIDeviceContext* aDeviceContext,
  1:                                  const nsRect& aBounds,
  1:                                  PRBool aDoCreation,
  1:                                  PRBool aInPrintPreview,
  1:                                  PRBool aNeedMakeCX /*= PR_TRUE*/)
  1: {
  1:   mParentWidget = aParentWidget; // not ref counted
  1: 
  1:   nsresult rv = NS_OK;
  1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NULL_POINTER);
  1: 
  1:   mDeviceContext = aDeviceContext;
  1: 
  1:   PRBool makeCX = PR_FALSE;
  1:   if (aDoCreation) {
  1:     if (aParentWidget && !mPresContext) {
  1:       // Create presentation context
  1:       if (mIsPageMode) {
  1:         //Presentation context already created in SetPageMode which is calling this method
  1:       }
  1:       else
  1:         mPresContext =
  1:             new nsPresContext(mDocument, nsPresContext::eContext_Galley);
  1:       NS_ENSURE_TRUE(mPresContext, NS_ERROR_OUT_OF_MEMORY);
  1: 
  1:       nsresult rv = mPresContext->Init(aDeviceContext); 
  1:       if (NS_FAILED(rv)) {
  1:         mPresContext = nsnull;
  1:         return rv;
  1:       }
  1: 
  1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
  1:       makeCX = !GetIsPrintPreview() && aNeedMakeCX; // needs to be true except when we are already in PP or we are enabling/disabling paginated mode.
  1: #else
  1:       makeCX = PR_TRUE;
  1: #endif
  1:     }
  1: 
  1:     if (mPresContext) {
  1:       // Create the ViewManager and Root View...
  1: 
  1:       // We must do this before we tell the script global object about
  1:       // this new document since doing that will cause us to re-enter
  1:       // into nsSubDocumentFrame code through reflows caused by
  1:       // FlushPendingNotifications() calls down the road...
  1: 
  1:       rv = MakeWindow(aParentWidget, aBounds);
  1:       NS_ENSURE_SUCCESS(rv, rv);
  1:       Hide();
  1: 
  1: #ifdef NS_PRINT_PREVIEW
  1:       if (mIsPageMode) {
  1:         // I'm leaving this in a broken state for the moment; we should
  1:         // be measuring/scaling with the print device context, not the
  1:         // screen device context, but this is good enough to allow
  1:         // printing reftests to work.
  1: #if 0
  1:         nsCOMPtr<nsIDeviceContextSpec> devspec =
  1:           do_CreateInstance("@mozilla.org/gfx/devicecontextspec;1", &rv);
  1:         NS_ENSURE_SUCCESS(rv, rv);
  1:         // mWindow has been initialized by preceding call to MakeWindow
  1:         rv = devspec->Init(mWindow, mPresContext->GetPrintSettings(), PR_FALSE);
  1:         NS_ENSURE_SUCCESS(rv, rv);
  1:         nsCOMPtr<nsIDeviceContext> devctx =
  1:           do_CreateInstance("@mozilla.org/gfx/devicecontext;1", &rv);
  1:         NS_ENSURE_SUCCESS(rv, rv);
  1:         rv = devctx->InitForPrinting(devspec);
  1:         NS_ENSURE_SUCCESS(rv, rv);
  1:         // XXX I'm breaking this code; I'm not sure I really want to mess with
  1:         // the document viewer at the moment to get the right device context
  1:         // (this won't break anyone, since page layout mode was never really
  1:         // usable)
  1: #endif
  1:         PRInt32 pageWidth = 0, pageHeight = 0;
  1:         mPresContext->GetPrintSettings()->GetPageSizeInTwips(&pageWidth,
  1:                                                              &pageHeight);
  1:         mPresContext->SetPageSize(
  1:           nsSize(mPresContext->TwipsToAppUnits(pageWidth),
  1:                  mPresContext->TwipsToAppUnits(pageHeight)));
  1:         mPresContext->SetIsRootPaginatedDocument(PR_TRUE);
  1:         mPresContext->SetPageScale(1.0f);
  1:       }
  1: #endif
  1:     }
  1:   }
  1: 
  1:   nsCOMPtr<nsIInterfaceRequestor> requestor(do_QueryReferent(mContainer));
  1:   if (requestor) {
  1:     if (mPresContext) {
  1:       nsCOMPtr<nsILinkHandler> linkHandler;
  1:       requestor->GetInterface(NS_GET_IID(nsILinkHandler),
  1:                               getter_AddRefs(linkHandler));
  1: 
  1:       mPresContext->SetContainer(requestor);
  1:       mPresContext->SetLinkHandler(linkHandler);
  1:     }
  1: 
  1:     if (!aInPrintPreview) {
  1:       // Set script-context-owner in the document
  1: 
  1:       nsCOMPtr<nsPIDOMWindow> window;
  1:       requestor->GetInterface(NS_GET_IID(nsPIDOMWindow),
  1:                               getter_AddRefs(window));
  1: 
  1:       if (window) {
  1:         window->SetNewDocument(mDocument, aState, PR_TRUE);
  1: 
  1:         nsJSContext::LoadStart();
  1:       }
  1:     }
  1:   }
  1: 
  1:   if (aDoCreation && mPresContext) {
  1:     // The ViewManager and Root View was created above (in
  1:     // MakeWindow())...
  1: 
  1:     rv = InitPresentationStuff(!makeCX);
  1:   }
  1: 
  1:   return rv;
  1: }
  1: 
  1: void
  1: DocumentViewerImpl::DumpContentToPPM(const char* aFileName)
  1: {
  1:   mDocument->FlushPendingNotifications(Flush_Display);
  1: 
  1:   nsIScrollableView* scrollableView;
  1:   mViewManager->GetRootScrollableView(&scrollableView);
  1:   nsIView* view;
  1:   if (scrollableView) {
  1:     scrollableView->GetScrolledView(view);
  1:   } else {
  1:     mViewManager->GetRootView(view);
  1:   }
  1:   nsRect r = view->GetBounds() - view->GetPosition();
  1:   // Limit the bitmap size to 5000x5000
  1:   nscoord twipLimit = mPresContext->DevPixelsToAppUnits(5000);
  1:   if (r.height > twipLimit)
  1:     r.height = twipLimit;
  1:   if (r.width > twipLimit)
  1:     r.width = twipLimit;
  1: 
  1:   const char* status;
  1: 
  1:   if (r.IsEmpty()) {
  1:     status = "EMPTY";
  1:   } else {
  1:     nsCOMPtr<nsIRenderingContext> context;
  1:     nsresult rv = mPresShell->RenderOffscreen(r, PR_FALSE, PR_TRUE, 
  1:                                               NS_RGB(255, 255, 255),
  1:                                               getter_AddRefs(context));
  1: 
  1:     if (NS_FAILED(rv)) {
  1:       status = "FAILEDRENDER";
  1:     } else {
  1:       nsIDrawingSurface* surface;
  1:       context->GetDrawingSurface(&surface);
  1:       if (!surface) {
  1:         status = "NOSURFACE";
  1:       } else {
  1:         PRUint32 width = mPresContext->AppUnitsToDevPixels(view->GetBounds().width);
  1:         PRUint32 height = mPresContext->AppUnitsToDevPixels(view->GetBounds().height);
  1: 
  1:         PRUint8* data;
  1:         PRInt32 rowLen, rowSpan;
  1:         rv = surface->Lock(0, 0, width, height, (void**)&data, &rowSpan, &rowLen,
  1:                            NS_LOCK_SURFACE_READ_ONLY);
  1:         if (NS_FAILED(rv)) {
  1:           status = "FAILEDLOCK";
  1:         } else {
  1:           PRUint32 bytesPerPix = rowLen/width;
  1:           nsPixelFormat format;
  1:           surface->GetPixelFormat(&format);
  1: 
  1:           PRUint8* buf = new PRUint8[3*width];
  1:           if (buf) {
  1:             FILE* f = fopen(aFileName, "wb");
  1:             if (!f) {
  1:               status = "FOPENFAILED";
  1:             } else {
  1:               fprintf(f, "P6\n%d\n%d\n255\n", width, height);
  1:               for (PRUint32 i = 0; i < height; ++i) {
  1:                 PRUint8* src = data + i*rowSpan;
  1:                 PRUint8* dest = buf;
  1:                 for (PRUint32 j = 0; j < width; ++j) {
  1:                   /* v is the pixel value */
  1: #ifdef IS_BIG_ENDIAN
  1:                   PRUint32 v = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
  1:                   v >>= (32 - 8*bytesPerPix);
  1: #else
  1:                   PRUint32 v = src[0] | (src[1] << 8) | (src[2] << 16) | (src[3] << 24);
  1: #endif
  1:                   dest[0] = ((v & format.mRedMask) >> format.mRedShift) << (8 - format.mRedCount);
  1:                   dest[1] = ((v & format.mGreenMask) >> format.mGreenShift) << (8 - format.mGreenCount);
  1:                   dest[2] = ((v & format.mBlueMask) >> format.mBlueShift) << (8 - format.mBlueCount);
  1:                   src += bytesPerPix;
  1:                   dest += 3;
  1:                 }
  1:                 fwrite(buf, 3, width, f);
  1:               }
  1:               fclose(f);
  1:               status = "OK";
  1:             }
  1:             
  1:             delete[] buf;
  1:           }
  1:           else {
  1:             status = "OOM";
  1:           }
  1:           surface->Unlock();
  1:         }
  1:         context->DestroyDrawingSurface(surface);
  1:       }
  1:     }
  1:   }
  1: 
  1:   nsIURI *uri = mDocument->GetDocumentURI();
  1:   nsCAutoString spec;
  1:   if (uri) {
  1:     uri->GetAsciiSpec(spec);
  1:   }
  1:   printf("GECKO: PAINT FORCED AFTER ONLOAD: %s %s (%s)\n", spec.get(), aFileName, status);
  1:   fflush(stdout);
  1: }
  1: 
  1: //
  1: // LoadComplete(aStatus)
  1: //
  1: //   aStatus - The status returned from loading the document.
  1: //
  1: // This method is called by the container when the document has been
  1: // completely loaded.
  1: //
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::LoadComplete(nsresult aStatus)
  1: {
  1:   nsresult rv = NS_OK;
  1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
  1: 
  1:   // First, get the window from the document...
  1:   nsPIDOMWindow *window = mDocument->GetWindow();
  1: 
  1:   // Fail if no window is available...
  1:   NS_ENSURE_TRUE(window, NS_ERROR_NULL_POINTER);
  1: 
  1:   mLoaded = PR_TRUE;
  1: 
  1:   /* We need to protect ourself against auto-destruction in case the
  1:      window is closed while processing the OnLoad event.  See bug
  1:      http://bugzilla.mozilla.org/show_bug.cgi?id=78445 for more
  1:      explanation.
  1:   */
  1:   nsCOMPtr<nsIDocumentViewer> kungFuDeathGrip(this);
  1: 
  1:   // Now, fire either an OnLoad or OnError event to the document...
  1:   PRBool restoring = PR_FALSE;
  1:   if(NS_SUCCEEDED(aStatus)) {
  1:     nsEventStatus status = nsEventStatus_eIgnore;
  1:     nsEvent event(PR_TRUE, NS_LOAD);
  1:     event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
  1:      // XXX Dispatching to |window|, but using |document| as the target.
  1:     event.target = mDocument;
  1: 
  1:     // If the document presentation is being restored, we don't want to fire
  1:     // onload to the document content since that would likely confuse scripts
  1:     // on the page.
  1: 
  1:     nsIDocShell *docShell = window->GetDocShell();
  1:     NS_ENSURE_TRUE(docShell, NS_ERROR_UNEXPECTED);
  1: 
  1:     docShell->GetRestoringDocument(&restoring);
  1:     if (!restoring) {
  1:       nsEventDispatcher::Dispatch(window, mPresContext, &event, nsnull,
  1:                                   &status);
  1: #ifdef MOZ_TIMELINE
  1:       // if navigator.xul's load is complete, the main nav window is visible
  1:       // mark that point.
  1: 
  1:       //printf("DEBUG: getting uri from document (%p)\n", mDocument.get());
  1: 
  1:       nsIURI *uri = mDocument ? mDocument->GetDocumentURI() : nsnull;
  1: 
  1:       if (uri) {
  1:         //printf("DEBUG: getting spec for uri (%p)\n", uri.get());
  1:         nsCAutoString spec;
  1:         uri->GetSpec(spec);
  1:         if (spec.EqualsLiteral("chrome://navigator/content/navigator.xul") ||
  1:             spec.EqualsLiteral("chrome://browser/content/browser.xul")) {
  1:           NS_TIMELINE_MARK("Navigator Window visible now");
  1:         }
  1:       }
  1: #endif /* MOZ_TIMELINE */
  1:     }
  1:   } else {
  1:     // XXX: Should fire error event to the document...
  1:   }
  1: 
  1:   // Notify the document that it has been shown (regardless of whether
  1:   // it was just loaded). Note: mDocument may be null now if the above
  1:   // firing of onload caused the document to unload.
  1:   if (mDocument)
  1:     mDocument->OnPageShow(restoring);
  1: 
  1:   // Now that the document has loaded, we can tell the presshell
  1:   // to unsuppress painting.
  1:   if (mPresShell && !mStopped) {
867:     nsCOMPtr<nsIPresShell> shellDeathGrip(mPresShell); // bug 378682
  1:     mPresShell->UnsuppressPainting();
  1:   }
  1: 
  1:   static PRBool forcePaint
  1:     = PR_GetEnv("MOZ_FORCE_PAINT_AFTER_ONLOAD") != nsnull;
  1:   static PRUint32 index = 0;
  1:   if (forcePaint) {
  1:     nsCAutoString name(PR_GetEnv("MOZ_FORCE_PAINT_AFTER_ONLOAD"));
  1:     name.AppendLiteral("-");
  1:     ++index;
  1:     name.AppendInt(index);
  1:     DumpContentToPPM(name.get());
  1:   }
  1: 
  1:   nsJSContext::LoadEnd();
  1: 
  1: #ifdef NS_PRINTING
  1:   // Check to see if someone tried to print during the load
  1:   if (mPrintIsPending) {
  1:     mPrintIsPending        = PR_FALSE;
  1:     mPrintDocIsFullyLoaded = PR_TRUE;
  1:     Print(mCachedPrintSettings, mCachedPrintWebProgressListner);
  1:     mCachedPrintSettings           = nsnull;
  1:     mCachedPrintWebProgressListner = nsnull;
  1:   }
  1: #endif
  1: 
  1:   return rv;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::PermitUnload(PRBool *aPermitUnload)
  1: {
  1:   *aPermitUnload = PR_TRUE;
  1: 
  1:   if (!mDocument || mInPermitUnload) {
  1:     return NS_OK;
  1:   }
  1: 
  1:   // First, get the script global object from the document...
  1:   nsPIDOMWindow *window = mDocument->GetWindow();
  1: 
  1:   if (!window) {
  1:     // This is odd, but not fatal
  1:     NS_WARNING("window not set for document!");
  1:     return NS_OK;
  1:   }
  1: 
  1:   // Now, fire an BeforeUnload event to the document and see if it's ok
  1:   // to unload...
  1:   nsEventStatus status = nsEventStatus_eIgnore;
  1:   nsBeforePageUnloadEvent event(PR_TRUE, NS_BEFORE_PAGE_UNLOAD);
  1:   event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
  1:   // XXX Dispatching to |window|, but using |document| as the target.
  1:   event.target = mDocument;
  1:   nsresult rv = NS_OK;
  1: 
  1:   // In evil cases we might be destroyed while handling the
  1:   // onbeforeunload event, don't let that happen. (see also bug#331040)
  1:   nsRefPtr<DocumentViewerImpl> kungFuDeathGrip(this);
  1: 
  1:   {
  1:     // Never permit popups from the beforeunload handler, no matter
  1:     // how we get here.
  1:     nsAutoPopupStatePusher popupStatePusher(openAbused, PR_TRUE);
  1: 
  1:     mInPermitUnload = PR_TRUE;
  1:     nsEventDispatcher::Dispatch(window, mPresContext, &event, nsnull, &status);
  1:     mInPermitUnload = PR_FALSE;
  1:   }
  1: 
  1:   nsCOMPtr<nsIDocShellTreeNode> docShellNode(do_QueryReferent(mContainer));
  1: 
  1:   if (NS_SUCCEEDED(rv) && (event.flags & NS_EVENT_FLAG_NO_DEFAULT ||
  1:                            !event.text.IsEmpty())) {
  1:     // Ask the user if it's ok to unload the current page
  1: 
  1:     nsCOMPtr<nsIPrompt> prompt = do_GetInterface(docShellNode);
  1: 
  1:     if (prompt) {
  1:       nsXPIDLString preMsg, postMsg;
  1:       rv = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
  1:                                               "OnBeforeUnloadPreMessage",
  1:                                               preMsg);
  1:       rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
  1:                                                "OnBeforeUnloadPostMessage",
  1:                                                postMsg);
  1: 
  1:       // GetStringFromName can succeed, yet give NULL strings back.
  1:       if (NS_FAILED(rv) || preMsg.IsEmpty() || postMsg.IsEmpty()) {
  1:         NS_ERROR("Failed to get strings from dom.properties!");
  1:         return NS_OK;
  1:       }
  1: 
  1:       // Limit the length of the text the page can inject into this
  1:       // dialogue to 1024 characters.
  1:       PRInt32 len = PR_MIN(event.text.Length(), 1024);
  1: 
  1:       nsAutoString msg;
  1:       if (len == 0) {
  1:         msg = preMsg + NS_LITERAL_STRING("\n\n") + postMsg;
  1:       } else {
  1:         msg = preMsg + NS_LITERAL_STRING("\n\n") +
  1:               StringHead(event.text, len) +
  1:               NS_LITERAL_STRING("\n\n") + postMsg;
  1:       } 
  1: 
  1:       // This doesn't pass a title, which makes the title be
  1:       // "Confirm", is that ok, or do we want a localizable title for
  1:       // this dialogue?
  1:       if (NS_FAILED(prompt->Confirm(nsnull, msg.get(), aPermitUnload))) {
  1:         *aPermitUnload = PR_TRUE;
  1:       }
  1:     }
  1:   }
  1: 
  1:   if (docShellNode) {
  1:     PRInt32 childCount;
  1:     docShellNode->GetChildCount(&childCount);
  1: 
  1:     for (PRInt32 i = 0; i < childCount && *aPermitUnload; ++i) {
  1:       nsCOMPtr<nsIDocShellTreeItem> item;
  1:       docShellNode->GetChildAt(i, getter_AddRefs(item));
  1: 
  1:       nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(item));
  1: 
  1:       if (docShell) {
  1:         nsCOMPtr<nsIContentViewer> cv;
  1:       docShell->GetContentViewer(getter_AddRefs(cv));
  1: 
  1:       if (cv) {
  1:         cv->PermitUnload(aPermitUnload);
  1:         }
  1:       }
  1:     }
  1:   }
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::PageHide(PRBool aIsUnload)
  1: {
  1:   mEnableRendering = PR_FALSE;
  1: 
  1:   if (!mDocument) {
  1:     return NS_ERROR_NULL_POINTER;
  1:   }
  1: 
  1:   mDocument->OnPageHide(!aIsUnload);
  1:   if (aIsUnload) {
  1:     // if Destroy() was called during OnPageHide(), mDocument is nsnull.
  1:     NS_ENSURE_STATE(mDocument);
  1: 
  1:     // First, get the window from the document...
  1:     nsPIDOMWindow *window = mDocument->GetWindow();
  1: 
  1:     if (!window) {
  1:       // Fail if no window is available...
  1:       NS_ERROR("window not set for document!");
  1:       return NS_ERROR_NULL_POINTER;
  1:     }
  1: 
  1:     // Now, fire an Unload event to the document...
  1:     nsEventStatus status = nsEventStatus_eIgnore;
  1:     nsEvent event(PR_TRUE, NS_PAGE_UNLOAD);
  1:     event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
  1:     // XXX Dispatching to |window|, but using |document| as the target.
  1:     event.target = mDocument;
  1: 
  1:     // Never permit popups from the unload handler, no matter how we get
  1:     // here.
  1:     nsAutoPopupStatePusher popupStatePusher(openAbused, PR_TRUE);
  1: 
  1:     nsEventDispatcher::Dispatch(window, mPresContext, &event, nsnull, &status);
  1:   }
  1: 
  1:   // look for open menupopups and close them after the unload event, in case
  1:   // the unload event listeners open any new popups
867:   if (mPresShell) {
867:     nsCOMPtr<nsIPresShell> kungFuDeathGrip = mPresShell;
677:     mPresShell->HidePopups();
867:   }
825: 
825:   return NS_OK;
  1: }
  1: 
  1: static void
  1: AttachContainerRecurse(nsIDocShell* aShell)
  1: {
  1:   nsCOMPtr<nsIContentViewer> viewer;
  1:   aShell->GetContentViewer(getter_AddRefs(viewer));
  1:   nsCOMPtr<nsIDocumentViewer> docViewer = do_QueryInterface(viewer);
  1:   if (docViewer) {
  1:     nsCOMPtr<nsIDocument> doc;
  1:     docViewer->GetDocument(getter_AddRefs(doc));
  1:     if (doc) {
  1:       doc->SetContainer(aShell);
  1:     }
  1:     nsCOMPtr<nsPresContext> pc;
  1:     docViewer->GetPresContext(getter_AddRefs(pc));
  1:     if (pc) {
  1:       pc->SetContainer(aShell);
  1:       pc->SetLinkHandler(nsCOMPtr<nsILinkHandler>(do_QueryInterface(aShell)));
  1:     }
  1:     nsCOMPtr<nsIPresShell> presShell;
  1:     docViewer->GetPresShell(getter_AddRefs(presShell));
  1:     if (presShell) {
  1:       presShell->SetForwardingContainer(nsnull);
  1:     }
  1:   }
  1: 
  1:   // Now recurse through the children
  1:   nsCOMPtr<nsIDocShellTreeNode> node = do_QueryInterface(aShell);
  1:   NS_ASSERTION(node, "docshells must implement nsIDocShellTreeNode");
  1: 
  1:   PRInt32 childCount;
  1:   node->GetChildCount(&childCount);
  1:   for (PRInt32 i = 0; i < childCount; ++i) {
  1:     nsCOMPtr<nsIDocShellTreeItem> childItem;
  1:     node->GetChildAt(i, getter_AddRefs(childItem));
  1:     AttachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(childItem)));
  1:   }
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::Open(nsISupports *aState, nsISHEntry *aSHEntry)
  1: {
  1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
  1: 
  1:   // Our container might have gone away while we were closed.
  1:   // If this is the case, we must fail to open so we don't crash.
  1:   nsCOMPtr<nsISupports> container = do_QueryReferent(mContainer);
  1:   if (!container)
  1:     return NS_ERROR_NOT_AVAILABLE;
  1: 
  1:   nsRect bounds;
  1:   mWindow->GetBounds(bounds);
  1: 
  1:   nsresult rv = InitInternal(mParentWidget, aState, mDeviceContext, bounds,
  1:                              PR_FALSE, PR_FALSE);
  1:   NS_ENSURE_SUCCESS(rv, rv);
  1: 
  1:   if (mDocument)
  1:     mDocument->SetContainer(nsCOMPtr<nsISupports>(do_QueryReferent(mContainer)));
  1: 
  1:   if (mPresShell)
  1:     mPresShell->SetForwardingContainer(nsnull);
  1: 
  1:   // Rehook the child presentations.  The child shells are still in
  1:   // session history, so get them from there.
  1: 
  1:   nsCOMPtr<nsIDocShellTreeItem> item;
  1:   PRInt32 itemIndex = 0;
  1:   while (NS_SUCCEEDED(aSHEntry->ChildShellAt(itemIndex++,
  1:                                              getter_AddRefs(item))) && item) {
  1:     AttachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(item)));
  1:   }
  1:   
  1:   SyncParentSubDocMap();
  1: 
  1:   if (mFocusListener) {
  1:     // get the DOM event receiver
  1:     nsCOMPtr<nsIDOMEventReceiver> erP(do_QueryInterface(mDocument));
  1:     NS_ASSERTION(erP, "No event receiver in document!");
  1: 
  1:     if (erP) {
  1:       erP->AddEventListenerByIID(mFocusListener,
  1:                                  NS_GET_IID(nsIDOMFocusListener));
  1:     }
  1:   }
  1: 
  1:   // XXX re-enable image animations once that works correctly
  1: 
  1:   PrepareToStartLoad();
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::Close(nsISHEntry *aSHEntry)
  1: {
  1:   // All callers are supposed to call close to break circular
  1:   // references.  If we do this stuff in the destructor, the
  1:   // destructor might never be called (especially if we're being
  1:   // used from JS.
  1: 
  1:   mSHEntry = aSHEntry;
  1: 
  1:   // Close is also needed to disable scripts during paint suppression,
  1:   // since we transfer the existing global object to the new document
  1:   // that is loaded.  In the future, the global object may become a proxy
  1:   // for an object that can be switched in and out so that we don't need
  1:   // to disable scripts during paint suppression.
  1: 
  1:   if (!mDocument)
  1:     return NS_OK;
  1: 
  1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
  1:   // Turn scripting back on
  1:   // after PrintPreview had turned it off
  1:   if (GetIsPrintPreview() && mPrintEngine) {
  1:     mPrintEngine->TurnScriptingOn(PR_TRUE);
  1:   }
  1: #endif
  1: 
  1: #ifdef NS_PRINTING
  1:   // A Close was called while we were printing
  1:   // so don't clear the ScriptGlobalObject
  1:   // or clear the mDocument below
  1:   // Also, do an extra addref to keep the viewer from going away.
  1:   if (mPrintEngine && !mClosingWhilePrinting) {
  1:     mClosingWhilePrinting = PR_TRUE;
  1:     NS_ADDREF_THIS();
  1:   } else
  1: #endif
  1:     {
  1:       // out of band cleanup of webshell
  1:       mDocument->SetScriptGlobalObject(nsnull);
  1: 
  1:       if (!mSHEntry)
  1:         mDocument->Destroy();
  1:     }
  1: 
  1:   if (mFocusListener) {
  1:     // get the DOM event receiver
  1:     nsCOMPtr<nsIDOMEventReceiver> erP(do_QueryInterface(mDocument));
  1:     NS_ASSERTION(erP, "No event receiver in document!");
  1: 
  1:     if (erP) {
  1:       erP->RemoveEventListenerByIID(mFocusListener,
  1:                                     NS_GET_IID(nsIDOMFocusListener));
  1:     }
  1:   }
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: static void
  1: DetachContainerRecurse(nsIDocShell *aShell)
  1: {
  1:   // Unhook this docshell's presentation
  1:   nsCOMPtr<nsIContentViewer> viewer;
  1:   aShell->GetContentViewer(getter_AddRefs(viewer));
  1:   nsCOMPtr<nsIDocumentViewer> docViewer = do_QueryInterface(viewer);
  1:   if (docViewer) {
  1:     nsCOMPtr<nsIDocument> doc;
  1:     docViewer->GetDocument(getter_AddRefs(doc));
  1:     if (doc) {
  1:       doc->SetContainer(nsnull);
  1:     }
  1:     nsCOMPtr<nsPresContext> pc;
  1:     docViewer->GetPresContext(getter_AddRefs(pc));
  1:     if (pc) {
  1:       pc->SetContainer(nsnull);
  1:       pc->SetLinkHandler(nsnull);
  1:     }
  1:     nsCOMPtr<nsIPresShell> presShell;
  1:     docViewer->GetPresShell(getter_AddRefs(presShell));
  1:     if (presShell) {
  1:       presShell->SetForwardingContainer(nsWeakPtr(do_GetWeakReference(aShell)));
  1:     }
  1:   }
  1: 
  1:   // Now recurse through the children
  1:   nsCOMPtr<nsIDocShellTreeNode> node = do_QueryInterface(aShell);
  1:   NS_ASSERTION(node, "docshells must implement nsIDocShellTreeNode");
  1: 
  1:   PRInt32 childCount;
  1:   node->GetChildCount(&childCount);
  1:   for (PRInt32 i = 0; i < childCount; ++i) {
  1:     nsCOMPtr<nsIDocShellTreeItem> childItem;
  1:     node->GetChildAt(i, getter_AddRefs(childItem));
  1:     DetachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(childItem)));
  1:   }
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::Destroy()
  1: {
  1:   NS_ASSERTION(mDocument, "No document in Destroy()!");
  1: 
  1: #ifdef NS_PRINTING
  1:   // Here is where we check to see if the docment was still being prepared 
  1:   // for printing when it was asked to be destroy from someone externally
  1:   // This usually happens if the document is unloaded while the user is in the Print Dialog
  1:   //
  1:   // So we flip the bool to remember that the document is going away
  1:   // and we can clean up and abort later after returning from the Print Dialog
  1:   if (mPrintEngine) {
  1:     if (mPrintEngine->CheckBeforeDestroy()) {
  1:       return NS_OK;
  1:     }
  1:   }
  1: #endif
  1: 
  1:   // Don't let the document get unloaded while we are printing.
  1:   // this could happen if we hit the back button during printing.
  1:   // We also keep the viewer from being cached in session history, since
  1:   // we require all documents there to be sanitized.
  1:   if (mDestroyRefCount != 0) {
  1:     --mDestroyRefCount;
  1:     return NS_OK;
  1:   }
  1: 
  1:   // If we were told to put ourselves into session history instead of destroy
  1:   // the presentation, do that now.
  1:   if (mSHEntry) {
  1:     if (mPresShell)
  1:       mPresShell->Freeze();
  1: 
  1:     // Make sure the presentation isn't torn down by Hide().
  1:     mSHEntry->SetSticky(mIsSticky);
  1:     mIsSticky = PR_TRUE;
  1: 
  1:     PRBool savePresentation = PR_TRUE;
  1: 
  1:     // Remove our root view from the view hierarchy.
  1:     if (mPresShell) {
  1:       nsIViewManager *vm = mPresShell->GetViewManager();
  1:       if (vm) {
  1:         nsIView *rootView = nsnull;
  1:         vm->GetRootView(rootView);
  1: 
  1:         if (rootView) {
  1:           nsIView *rootViewParent = rootView->GetParent();
  1:           if (rootViewParent) {
  1:             nsIViewManager *parentVM = rootViewParent->GetViewManager();
  1:             if (parentVM) {
  1:               parentVM->RemoveChild(rootView);
  1:             }
  1:           }
  1:         }
  1:       }
  1:     }
  1: 
  1:     Hide();
  1: 
  1:     // This is after Hide() so that the user doesn't see the inputs clear.
  1:     if (mDocument) {
  1:       nsresult rv = mDocument->Sanitize();
  1:       if (NS_FAILED(rv)) {
  1:         // If we failed to sanitize, don't save presentation.
  1:         savePresentation = PR_FALSE;
  1:       }
  1:     }
  1: 
  1: 
  1:     // Reverse ownership. Do this *after* calling sanitize so that sanitize
  1:     // doesn't cause mutations that make the SHEntry drop the presentation
  1:     if (savePresentation) {
  1:       mSHEntry->SetContentViewer(this);
  1:     }
  1:     else {
  1:       mSHEntry->SyncPresentationState();
  1:     }
  1:     nsCOMPtr<nsISHEntry> shEntry = mSHEntry; // we'll need this below
  1:     mSHEntry = nsnull;
  1: 
  1:     // Break the link from the document/presentation to the docshell, so that
  1:     // link traversals cannot affect the currently-loaded document.
  1:     // When the presentation is restored, Open() and InitInternal() will reset
  1:     // these pointers to their original values.
  1: 
  1:     if (mDocument)
  1:       mDocument->SetContainer(nsnull);
  1:     if (mPresContext) {
  1:       mPresContext->SetLinkHandler(nsnull);
  1:       mPresContext->SetContainer(nsnull);
  1:     }
  1:     if (mPresShell)
  1:       mPresShell->SetForwardingContainer(mContainer);
  1: 
  1:     // Do the same for our children.  Note that we need to get the child
  1:     // docshells from the SHEntry now; the docshell will have cleared them.
  1:     nsCOMPtr<nsIDocShellTreeItem> item;
  1:     PRInt32 itemIndex = 0;
  1:     while (NS_SUCCEEDED(shEntry->ChildShellAt(itemIndex++,
  1:                                               getter_AddRefs(item))) && item) {
  1:       DetachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(item)));
  1:     }
  1: 
  1:     return NS_OK;
  1:   }
  1: 
  1:   if (mDocument) {
  1:     mDocument->Destroy();
  1:     mDocument = nsnull;
  1:   }
  1: 
  1:   // All callers are supposed to call destroy to break circular
  1:   // references.  If we do this stuff in the destructor, the
  1:   // destructor might never be called (especially if we're being
  1:   // used from JS.
  1: 
  1: #ifdef NS_PRINTING
  1:   if (mPrintEngine) {
  1:     mPrintEngine->Destroy();
  1:     mPrintEngine = nsnull;
  1:   }
  1: #endif
  1: 
  1:   // Avoid leaking the old viewer.
  1:   if (mPreviousViewer) {
  1:     mPreviousViewer->Destroy();
  1:     mPreviousViewer = nsnull;
  1:   }
  1: 
  1:   if (mDeviceContext) {
  1:     mDeviceContext->FlushFontCache();
  1:     mDeviceContext = nsnull;
  1:   }
  1: 
  1:   if (mPresShell) {
  1:     // Break circular reference (or something)
  1:     mPresShell->EndObservingDocument();
  1: 
  1:     nsCOMPtr<nsISelection> selection;
  1:     GetDocumentSelection(getter_AddRefs(selection));
  1: 
  1:     nsCOMPtr<nsISelectionPrivate> selPrivate(do_QueryInterface(selection));
  1: 
  1:     if (selPrivate && mSelectionListener)
  1:       selPrivate->RemoveSelectionListener(mSelectionListener);
  1: 
  1:     mPresShell->Destroy();
  1:     mPresShell = nsnull;
  1:   }
  1: 
  1:   if (mPresContext) {
  1:     mPresContext->SetContainer(nsnull);
  1:     mPresContext->SetLinkHandler(nsnull);
  1:     mPresContext = nsnull;
  1:   }
  1: 
  1:   mContainer = nsnull;
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::Stop(void)
  1: {
  1:   NS_ASSERTION(mDocument, "Stop called too early or too late");
  1:   if (mDocument) {
  1:     mDocument->StopDocumentLoad();
  1:   }
  1: 
  1:   if (mEnableRendering && (mLoaded || mStopped) && mPresContext && !mSHEntry)
  1:     mPresContext->SetImageAnimationMode(imgIContainer::kDontAnimMode);
  1: 
  1:   mStopped = PR_TRUE;
  1: 
  1:   if (!mLoaded && mPresShell) {
  1:     // Well, we might as well paint what we have so far.
867:     nsCOMPtr<nsIPresShell> shellDeathGrip(mPresShell); // bug 378682
  1:     mPresShell->UnsuppressPainting();
  1:   }
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetDOMDocument(nsIDOMDocument **aResult)
  1: {
  1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
  1:   return CallQueryInterface(mDocument, aResult);
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetDOMDocument(nsIDOMDocument *aDocument)
  1: {
  1:   // Assumptions:
  1:   //
  1:   // 1) this document viewer has been initialized with a call to Init().
  1:   // 2) the stylesheets associated with the document have been added
  1:   // to the document.
  1: 
  1:   // XXX Right now, this method assumes that the layout of the current
  1:   // document hasn't started yet.  More cleanup will probably be
  1:   // necessary to make this method work for the case when layout *has*
  1:   // occurred for the current document.
  1:   // That work can happen when and if it is needed.
  1: 
  1:   nsresult rv;
  1:   if (!aDocument)
  1:     return NS_ERROR_NULL_POINTER;
  1: 
  1:   nsCOMPtr<nsIDocument> newDoc = do_QueryInterface(aDocument, &rv);
  1:   if (NS_FAILED(rv)) return rv;
  1: 
  1:   // Set new container
  1:   nsCOMPtr<nsISupports> container = do_QueryReferent(mContainer);
  1:   newDoc->SetContainer(container);
  1: 
  1:   if (mDocument != newDoc) {
  1:     // Replace the old document with the new one. Do this only when
  1:     // the new document really is a new document.
  1:     mDocument = newDoc;
  1: 
  1:     // Set the script global object on the new document
  1:     nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(container);
  1:     if (window) {
  1:       window->SetNewDocument(newDoc, nsnull, PR_TRUE);
  1:     }
  1: 
  1:     // Clear the list of old child docshells. CChild docshells for the new
  1:     // document will be constructed as frames are created.
  1:     nsCOMPtr<nsIDocShellTreeNode> node = do_QueryInterface(container);
  1:     if (node) {
  1:       PRInt32 count;
  1:       node->GetChildCount(&count);
  1:       for (PRInt32 i = 0; i < count; ++i) {
  1:         nsCOMPtr<nsIDocShellTreeItem> child;
  1:         node->GetChildAt(0, getter_AddRefs(child));
  1:         node->RemoveChild(child);
  1:       }
  1:     }
  1:   }
  1: 
  1:   rv = SyncParentSubDocMap();
  1:   NS_ENSURE_SUCCESS(rv, rv);
  1: 
  1:   // Replace the current pres shell with a new shell for the new document
  1: 
  1:   nsCOMPtr<nsILinkHandler> linkHandler;
  1:   if (mPresShell) {
  1:     if (mPresContext) {
  1:       // Save the linkhandler (nsPresShell::Destroy removes it from
  1:       // mPresContext).
  1:       linkHandler = mPresContext->GetLinkHandler();
  1:     }
  1: 
  1:     mPresShell->EndObservingDocument();
  1:     mPresShell->Destroy();
  1: 
  1:     mPresShell = nsnull;
  1:   }
  1: 
  1:   // And if we're already given a prescontext...
  1:   if (mPresContext) {
  1:     // If we had a linkHandler and it got removed, put it back.
  1:     if (linkHandler) {
  1:       mPresContext->SetLinkHandler(linkHandler);
  1:     }
  1: 
  1:     // Create a new style set for the document
  1: 
  1:     nsStyleSet *styleSet;
  1:     rv = CreateStyleSet(mDocument, &styleSet);
  1:     NS_ENSURE_SUCCESS(rv, rv);
  1: 
  1:     rv = newDoc->CreateShell(mPresContext, mViewManager, styleSet,
  1:                              getter_AddRefs(mPresShell));
  1:     if (NS_FAILED(rv)) {
  1:       delete styleSet;
  1:       return rv;
  1:     }
  1: 
  1:     // We're done creating the style set
  1:     styleSet->EndUpdate();
  1: 
  1:     // The pres shell owns the style set now.
  1:     mPresShell->BeginObservingDocument();
  1: 
  1:     // Register the focus listener on the new document
  1: 
  1:     nsCOMPtr<nsIDOMEventReceiver> erP = do_QueryInterface(mDocument, &rv);
  1:     NS_ASSERTION(erP, "No event receiver in document!");
  1: 
  1:     if (erP) {
  1:       rv = erP->AddEventListenerByIID(mFocusListener,
  1:                                       NS_GET_IID(nsIDOMFocusListener));
  1:       NS_ASSERTION(NS_SUCCEEDED(rv), "failed to register focus listener");
  1:     }
  1:   }
  1: 
  1:   return rv;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetUAStyleSheet(nsIStyleSheet* aUAStyleSheet)
  1: {
  1:   NS_ASSERTION(aUAStyleSheet, "unexpected null pointer");
  1:   nsCOMPtr<nsICSSStyleSheet> sheet(do_QueryInterface(aUAStyleSheet));
  1:   if (sheet) {
  1:     nsCOMPtr<nsICSSStyleSheet> newSheet;
  1:     sheet->Clone(nsnull, nsnull, nsnull, nsnull, getter_AddRefs(newSheet));
  1:     mUAStyleSheet = newSheet;
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetDocument(nsIDocument** aResult)
  1: {
  1:   NS_IF_ADDREF(*aResult = mDocument);
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetPresShell(nsIPresShell** aResult)
  1: {
  1:   NS_IF_ADDREF(*aResult = mPresShell);
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetPresContext(nsPresContext** aResult)
  1: {
  1:   NS_IF_ADDREF(*aResult = mPresContext);
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetBounds(nsRect& aResult)
  1: {
  1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
  1:   NS_PRECONDITION(mWindow, "null window");
  1:   if (mWindow) {
  1:     mWindow->GetBounds(aResult);
  1:   }
  1:   else {
  1:     aResult.SetRect(0, 0, 0, 0);
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetPreviousViewer(nsIContentViewer** aViewer)
  1: {
  1:   *aViewer = mPreviousViewer;
  1:   NS_IF_ADDREF(*aViewer);
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetPreviousViewer(nsIContentViewer* aViewer)
  1: {
  1:   // NOTE:  |Show| sets |mPreviousViewer| to null without calling this
  1:   // function.
  1: 
  1:   if (aViewer) {
  1:     NS_ASSERTION(!mPreviousViewer,
  1:                  "can't set previous viewer when there already is one");
  1: 
  1:     // In a multiple chaining situation (which occurs when running a thrashing
  1:     // test like i-bench or jrgm's tests with no delay), we can build up a
  1:     // whole chain of viewers.  In order to avoid this, we always set our previous
  1:     // viewer to the MOST previous viewer in the chain, and then dump the intermediate
  1:     // link from the chain.  This ensures that at most only 2 documents are alive
  1:     // and undestroyed at any given time (the one that is showing and the one that
  1:     // is loading with painting suppressed).
  1:     nsCOMPtr<nsIContentViewer> prevViewer;
  1:     aViewer->GetPreviousViewer(getter_AddRefs(prevViewer));
  1:     if (prevViewer) {
  1:       aViewer->SetPreviousViewer(nsnull);
  1:       aViewer->Destroy();
  1:       return SetPreviousViewer(prevViewer);
  1:     }
  1:   }
  1: 
  1:   mPreviousViewer = aViewer;
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetBounds(const nsRect& aBounds)
  1: {
  1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
  1: 
  1:   if (mWindow) {
  1:     // Don't have the widget repaint. Layout will generate repaint requests
  1:     // during reflow
  1:     mWindow->Resize(aBounds.x, aBounds.y, aBounds.width, aBounds.height,
  1:                     PR_FALSE);
  1:   }
  1: 
  1:   // If there's a previous viewer, it's the one that's actually showing,
  1:   // so be sure to resize it as well so it paints over the right area.
  1:   // This may slow down the performance of the new page load, but resize
  1:   // during load is also probably a relatively unusual condition
  1:   // relating to things being hidden while something is loaded.  It so
  1:   // happens that Firefox does this a good bit with its infobar, and it
  1:   // looks ugly if we don't do this.
  1:   if (mPreviousViewer)
  1:     mPreviousViewer->SetBounds(aBounds);
  1: 
  1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
  1:   if (GetIsPrintPreview() && !mPrintEngine->GetIsCreatingPrintPreview()) {
  1:     mPrintEngine->GetPrintPreviewWindow()->Resize(aBounds.x, aBounds.y,
  1:                                                   aBounds.width, aBounds.height,
  1:                                                   PR_FALSE);
  1:   }
  1: #endif
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::Move(PRInt32 aX, PRInt32 aY)
  1: {
  1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
  1:   NS_PRECONDITION(mWindow, "null window");
  1:   if (mWindow) {
  1:     mWindow->Move(aX, aY);
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::Show(void)
  1: {
  1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
  1: 
  1:   // We don't need the previous viewer anymore since we're not
  1:   // displaying it.
  1:   if (mPreviousViewer) {
  1:     // This little dance *may* only be to keep
  1:     // PresShell::EndObservingDocument happy, but I'm not sure.
  1:     nsCOMPtr<nsIContentViewer> prevViewer(mPreviousViewer);
  1:     mPreviousViewer = nsnull;
  1:     prevViewer->Destroy();
  1: 
  1:     // Make sure we don't have too many cached ContentViewers
  1:     nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryReferent(mContainer);
  1:     if (treeItem) {
  1:       // We need to find the root DocShell since only that object has an
  1:       // SHistory and we need the SHistory to evict content viewers
  1:       nsCOMPtr<nsIDocShellTreeItem> root;
  1:       treeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
  1:       nsCOMPtr<nsIWebNavigation> webNav = do_QueryInterface(root);
  1:       nsCOMPtr<nsISHistory> history;
  1:       webNav->GetSessionHistory(getter_AddRefs(history));
  1:       nsCOMPtr<nsISHistoryInternal> historyInt = do_QueryInterface(history);
  1:       if (historyInt) {
  1:         PRInt32 prevIndex,loadedIndex;
  1:         nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(treeItem);
  1:         docShell->GetPreviousTransIndex(&prevIndex);
  1:         docShell->GetLoadedTransIndex(&loadedIndex);
  1: #ifdef DEBUG_PAGE_CACHE
  1:         printf("About to evict content viewers: prev=%d, loaded=%d\n",
  1:                prevIndex, loadedIndex);
  1: #endif
  1:         historyInt->EvictContentViewers(prevIndex, loadedIndex);
  1:       }
  1:     }
  1:   }
  1: 
  1:   if (mWindow) {
  1:     mWindow->Show(PR_TRUE);
  1:   }
  1: 
  1:   if (mDocument && !mPresShell && !mWindow) {
  1:     nsresult rv;
  1: 
  1:     nsCOMPtr<nsIBaseWindow> base_win(do_QueryReferent(mContainer));
  1:     NS_ENSURE_TRUE(base_win, NS_ERROR_UNEXPECTED);
  1: 
  1:     base_win->GetParentWidget(&mParentWidget);
  1:     NS_ENSURE_TRUE(mParentWidget, NS_ERROR_UNEXPECTED);
  1: 
  1:     mDeviceContext = mParentWidget->GetDeviceContext();
  1: 
  1:     // Create presentation context
  1:     NS_ASSERTION(!mPresContext, "Shouldn't have a prescontext if we have no shell!");
  1:     mPresContext = new nsPresContext(mDocument, nsPresContext::eContext_Galley);
  1:     NS_ENSURE_TRUE(mPresContext, NS_ERROR_OUT_OF_MEMORY);
  1: 
  1:     rv = mPresContext->Init(mDeviceContext);
  1:     if (NS_FAILED(rv)) {
  1:       mPresContext = nsnull;
  1:       return rv;
  1:     }
  1: 
  1:     nsRect tbounds;
  1:     mParentWidget->GetBounds(tbounds);
  1: 
  1:     rv = MakeWindow(mParentWidget, tbounds);
  1:     if (NS_FAILED(rv))
  1:       return rv;
  1: 
  1:     if (mPresContext && base_win) {
  1:       nsCOMPtr<nsILinkHandler> linkHandler(do_GetInterface(base_win));
  1: 
  1:       if (linkHandler) {
  1:         mPresContext->SetLinkHandler(linkHandler);
  1:       }
  1: 
  1:       mPresContext->SetContainer(base_win);
  1:     }
  1: 
  1:     if (mPresContext) {
  1:       Hide();
  1: 
  1:       rv = InitPresentationStuff(PR_TRUE);
  1:     }
  1: 
  1:     // If we get here the document load has already started and the
  1:     // window is shown because some JS on the page caused it to be
  1:     // shown...
  1: 
867:     nsCOMPtr<nsIPresShell> shellDeathGrip(mPresShell); // bug 378682
  1:     mPresShell->UnsuppressPainting();
  1:   }
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::Hide(void)
  1: {
  1:   NS_PRECONDITION(mWindow, "null window");
  1:   if (mWindow) {
  1:     mWindow->Show(PR_FALSE);
  1:   }
  1: 
  1:   if (!mPresShell)
  1:     return NS_OK;
  1: 
  1:   NS_ASSERTION(mPresContext, "Can't have a presshell and no prescontext!");
  1: 
  1:   // Avoid leaking the old viewer.
  1:   if (mPreviousViewer) {
  1:     mPreviousViewer->Destroy();
  1:     mPreviousViewer = nsnull;
  1:   }
  1: 
  1:   if (mIsSticky) {
  1:     // This window is sticky, that means that it might be shown again
  1:     // and we don't want the presshell n' all that to be thrown away
  1:     // just because the window is hidden.
  1: 
  1:     return NS_OK;
  1:   }
  1: 
  1:   if (mDeviceContext) {
  1:     mDeviceContext->FlushFontCache();
  1:   }
  1: 
  1:   // Break circular reference (or something)
  1:   mPresShell->EndObservingDocument();
  1:   nsCOMPtr<nsISelection> selection;
  1: 
  1:   GetDocumentSelection(getter_AddRefs(selection));
  1: 
  1:   nsCOMPtr<nsISelectionPrivate> selPrivate(do_QueryInterface(selection));
  1: 
  1:   if (selPrivate && mSelectionListener) {
  1:     selPrivate->RemoveSelectionListener(mSelectionListener);
  1:   }
  1: 
  1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
  1:   if (docShell) {
  1:     PRBool saveLayoutState = PR_FALSE;
  1:     docShell->GetShouldSaveLayoutState(&saveLayoutState);
  1:     if (saveLayoutState) {
  1:       nsCOMPtr<nsILayoutHistoryState> layoutState;
  1:       mPresShell->CaptureHistoryState(getter_AddRefs(layoutState), PR_TRUE);
  1:     }
  1:   }
  1: 
  1:   mPresShell->Destroy();
  1:   // Clear weak refs
  1:   mPresContext->SetContainer(nsnull);
  1:   mPresContext->SetLinkHandler(nsnull);                             
  1: 
  1:   mPresShell     = nsnull;
  1:   mPresContext   = nsnull;
  1:   mViewManager   = nsnull;
  1:   mWindow        = nsnull;
  1:   mDeviceContext = nsnull;
  1:   mParentWidget  = nsnull;
  1: 
  1:   nsCOMPtr<nsIBaseWindow> base_win(do_QueryReferent(mContainer));
  1: 
  1:   if (base_win) {
  1:     base_win->SetParentWidget(nsnull);
  1:   }
  1: 
  1:   return NS_OK;
  1: }
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetEnableRendering(PRBool aOn)
  1: {
  1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
  1:   mEnableRendering = aOn;
  1:   if (mViewManager) {
  1:     if (aOn) {
  1:       mViewManager->EnableRefresh(NS_VMREFRESH_IMMEDIATE);
  1:       nsIView* view;
  1:       mViewManager->GetRootView(view);   // views are not refCounted
  1:       if (view) {
  1:         mViewManager->UpdateView(view, NS_VMREFRESH_IMMEDIATE);
  1:       }
  1:     }
  1:     else {
  1:       mViewManager->DisableRefresh();
  1:     }
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetSticky(PRBool *aSticky)
  1: {
  1:   *aSticky = mIsSticky;
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetSticky(PRBool aSticky)
  1: {
  1:   mIsSticky = aSticky;
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetEnableRendering(PRBool* aResult)
  1: {
  1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
  1:   NS_PRECONDITION(nsnull != aResult, "null OUT ptr");
  1:   if (aResult) {
  1:     *aResult = mEnableRendering;
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::RequestWindowClose(PRBool* aCanClose)
  1: {
  1: #ifdef NS_PRINTING
  1:   if (mPrintIsPending || (mPrintEngine && mPrintEngine->GetIsPrinting())) {
  1:     *aCanClose = PR_FALSE;
  1:     mDeferredWindowClose = PR_TRUE;
  1:   } else
  1: #endif
  1:     *aCanClose = PR_TRUE;
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: PR_STATIC_CALLBACK(PRBool)
  1: AppendAgentSheet(nsIStyleSheet *aSheet, void *aData)
  1: {
  1:   nsStyleSet *styleSet = NS_STATIC_CAST(nsStyleSet*, aData);
  1:   styleSet->AppendStyleSheet(nsStyleSet::eAgentSheet, aSheet);
  1:   return PR_TRUE;
  1: }
  1: 
  1: PR_STATIC_CALLBACK(PRBool)
  1: PrependUserSheet(nsIStyleSheet *aSheet, void *aData)
  1: {
  1:   nsStyleSet *styleSet = NS_STATIC_CAST(nsStyleSet*, aData);
  1:   styleSet->PrependStyleSheet(nsStyleSet::eUserSheet, aSheet);
  1:   return PR_TRUE;
  1: }
  1: 
  1: nsresult
  1: DocumentViewerImpl::CreateStyleSet(nsIDocument* aDocument,
  1:                                    nsStyleSet** aStyleSet)
  1: {
  1:   // Make sure this does the same thing as PresShell::AddSheet wrt ordering.
  1: 
  1:   // this should eventually get expanded to allow for creating
  1:   // different sets for different media
  1:   if (!mUAStyleSheet) {
  1:     NS_WARNING("unable to load UA style sheet");
  1:   }
  1: 
  1:   nsStyleSet *styleSet = new nsStyleSet();
  1:   if (!styleSet) {
  1:     return NS_ERROR_OUT_OF_MEMORY;
  1:   }
  1: 
  1:   styleSet->BeginUpdate();
  1:   
  1:   // The document will fill in the document sheets when we create the presshell
  1:   
  1:   // Handle the user sheets.
  1:   nsCOMPtr<nsIDocShellTreeItem> docShell(do_QueryReferent(mContainer));
  1:   PRInt32 shellType;
  1:   docShell->GetItemType(&shellType);
  1:   nsICSSStyleSheet* sheet = nsnull;
  1:   if (shellType == nsIDocShellTreeItem::typeChrome) {
  1:     sheet = nsLayoutStylesheetCache::UserChromeSheet();
  1:   }
  1:   else {
  1:     sheet = nsLayoutStylesheetCache::UserContentSheet();
  1:   }
  1: 
  1:   if (sheet)
  1:     styleSet->AppendStyleSheet(nsStyleSet::eUserSheet, sheet);
  1: 
  1:   // Append chrome sheets (scrollbars + forms).
  1:   PRBool shouldOverride = PR_FALSE;
  1:   nsCOMPtr<nsIDocShell> ds(do_QueryInterface(docShell));
  1:   nsCOMPtr<nsIDOMEventTarget> chromeHandler;
  1:   nsCOMPtr<nsIURI> uri;
  1:   nsCOMPtr<nsICSSStyleSheet> csssheet;
  1: 
  1:   ds->GetChromeEventHandler(getter_AddRefs(chromeHandler));
  1:   if (chromeHandler) {
  1:     nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(chromeHandler));
  1:     nsCOMPtr<nsIContent> content(do_QueryInterface(elt));
  1:     if (elt && content) {
  1:       nsCOMPtr<nsIURI> baseURI = content->GetBaseURI();
  1: 
  1:       nsAutoString sheets;
  1:       elt->GetAttribute(NS_LITERAL_STRING("usechromesheets"), sheets);
  1:       if (!sheets.IsEmpty() && baseURI) {
  1:         nsCOMPtr<nsICSSLoader> cssLoader;
  1:         NS_NewCSSLoader(getter_AddRefs(cssLoader));
  1: 
  1:         char *str = ToNewCString(sheets);
  1:         char *newStr = str;
  1:         char *token;
  1:         while ( (token = nsCRT::strtok(newStr, ", ", &newStr)) ) {
  1:           NS_NewURI(getter_AddRefs(uri), nsDependentCString(token), nsnull,
  1:                     baseURI);
  1:           if (!uri) continue;
  1: 
  1:           cssLoader->LoadSheetSync(uri, getter_AddRefs(csssheet));
  1:           if (!sheet) continue;
  1: 
  1:           styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, csssheet);
  1:           shouldOverride = PR_TRUE;
  1:         }
  1:         nsMemory::Free(str);
  1:       }
  1:     }
  1:   }
  1: 
  1:   if (!shouldOverride) {
  1:     sheet = nsLayoutStylesheetCache::ScrollbarsSheet();
  1:     if (sheet) {
  1:       styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, sheet);
  1:     }
  1:   }
  1: 
  1:   sheet = nsLayoutStylesheetCache::FormsSheet();
  1:   if (sheet) {
  1:     styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, sheet);
  1:   }
  1: 
  1:   if (mUAStyleSheet) {
  1:     styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, mUAStyleSheet);
  1:   }
  1: 
  1:   nsCOMPtr<nsIStyleSheetService> dummy =
  1:     do_GetService(NS_STYLESHEETSERVICE_CONTRACTID);
  1: 
  1:   nsStyleSheetService *sheetService = nsStyleSheetService::gInstance;
  1:   if (sheetService) {
  1:     sheetService->AgentStyleSheets()->EnumerateForwards(AppendAgentSheet,
  1:                                                         styleSet);
  1:     sheetService->UserStyleSheets()->EnumerateBackwards(PrependUserSheet,
  1:                                                         styleSet);
  1:   }
  1: 
  1:   // Caller will handle calling EndUpdate, per contract.
  1:   *aStyleSet = styleSet;
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::ClearHistoryEntry()
  1: {
  1:   mSHEntry = nsnull;
  1:   return NS_OK;
  1: }
  1: 
  1: //-------------------------------------------------------
  1: 
  1: nsresult
  1: DocumentViewerImpl::MakeWindow(nsIWidget* aParentWidget,
  1:                                const nsRect& aBounds)
  1: {
  1:   nsresult rv;
  1: 
  1:   mViewManager = do_CreateInstance(kViewManagerCID, &rv);
  1:   if (NS_FAILED(rv))
  1:     return rv;
  1: 
  1:   nsIDeviceContext *dx = mPresContext->DeviceContext();
  1: 
  1:   nsRect tbounds = aBounds;
  1:   tbounds *= mPresContext->AppUnitsPerDevPixel();
  1: 
  1:    // Initialize the view manager with an offset. This allows the viewmanager
  1:    // to manage a coordinate space offset from (0,0)
  1:   rv = mViewManager->Init(dx);
  1:   if (NS_FAILED(rv))
  1:     return rv;
  1: 
  1:   // Reset the bounds offset so the root view is set to 0,0. The
  1:   // offset is specified in nsIViewManager::Init above.
  1:   // Besides, layout will reset the root view to (0,0) during reflow,
  1:   // so changing it to 0,0 eliminates placing the root view in the
  1:   // wrong place initially.
  1:   tbounds.x = 0;
  1:   tbounds.y = 0;
  1: 
  1:   // Create a child window of the parent that is our "root view/window"
  1:   // if aParentWidget has a view, we'll hook our view manager up to its view tree
  1:   nsIView* containerView = nsView::GetViewFor(aParentWidget);
  1: 
  1:   if (containerView) {
  1:     // see if the containerView has already been hooked into a foreign view manager hierarchy
  1:     // if it has, then we have to hook into the hierarchy too otherwise bad things will happen.
  1:     nsIViewManager* containerVM = containerView->GetViewManager();
  1:     nsIView* pView = containerView;
  1:     do {
  1:       pView = pView->GetParent();
  1:     } while (pView && pView->GetViewManager() == containerVM);
  1: 
  1:     if (!pView) {
  1:       // OK, so the container is not already hooked up into a foreign view manager hierarchy.
  1:       // That means we can choose not to hook ourselves up.
  1:       //
  1:       // If the parent container is a chrome shell then we won't hook into its view
  1:       // tree. This will improve performance a little bit (especially given scrolling/painting perf bugs)
  1:       // but is really just for peace of mind. This check can be removed if we want to support fancy
  1:       // chrome effects like transparent controls floating over content, transparent Web browsers, and
  1:       // things like that, and the perf bugs are fixed.
  1:       nsCOMPtr<nsIDocShellTreeItem> container(do_QueryReferent(mContainer));
  1:       nsCOMPtr<nsIDocShellTreeItem> parentContainer;
  1:       PRInt32 itemType;
  1:       if (nsnull == container
  1:           || NS_FAILED(container->GetParent(getter_AddRefs(parentContainer)))
  1:           || nsnull == parentContainer
  1:           || NS_FAILED(parentContainer->GetItemType(&itemType))
  1:           || itemType != nsIDocShellTreeItem::typeContent) {
  1:         containerView = nsnull;
  1:       }
  1:     }
  1:   }
  1: 
  1:   // Create a view
  1:   nsIView* view = mViewManager->CreateView(tbounds, containerView);
  1:   if (!view)
  1:     return NS_ERROR_OUT_OF_MEMORY;
  1: 
  1:   // pass in a native widget to be the parent widget ONLY if the view hierarchy will stand alone.
  1:   // otherwise the view will find its own parent widget and "do the right thing" to
  1:   // establish a parent/child widget relationship
  1:   rv = view->CreateWidget(kWidgetCID, nsnull,
  1:                           containerView != nsnull ? nsnull : aParentWidget->GetNativeData(NS_NATIVE_WIDGET),
  1:                           PR_TRUE, PR_FALSE);
  1:   if (NS_FAILED(rv))
  1:     return rv;
  1: 
  1:   // Setup hierarchical relationship in view manager
  1:   mViewManager->SetRootView(view);
  1: 
  1:   mWindow = view->GetWidget();
  1: 
  1:   // This SetFocus is necessary so the Arrow Key and Page Key events
  1:   // go to the scrolled view as soon as the Window is created instead of going to
  1:   // the browser window (this enables keyboard scrolling of the document)
  1:   // mWindow->SetFocus();
  1: 
  1:   return rv;
  1: }
  1: 
  1: // Return the selection for the document. Note that text fields have their
  1: // own selection, which cannot be accessed with this method. Use
  1: // mPresShell->GetSelectionForCopy() instead.
  1: nsresult DocumentViewerImpl::GetDocumentSelection(nsISelection **aSelection)
  1: {
  1:   NS_ENSURE_ARG_POINTER(aSelection);
  1:   if (!mPresShell) {
  1:     return NS_ERROR_NOT_INITIALIZED;
  1:   }
  1: 
  1:   nsCOMPtr<nsISelectionController> selcon;
  1:   selcon = do_QueryInterface(mPresShell);
  1:   if (selcon)
  1:     return selcon->GetSelection(nsISelectionController::SELECTION_NORMAL,
  1:                                 aSelection);
  1:   return NS_ERROR_FAILURE;
  1: }
  1: 
  1: /* ========================================================================================
  1:  * nsIContentViewerEdit
  1:  * ======================================================================================== */
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::Search()
  1: {
  1:   // Nothing to do here.
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetSearchable(PRBool *aSearchable)
  1: {
  1:   // Nothing to do here.
  1:   *aSearchable = PR_FALSE;
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::ClearSelection()
  1: {
  1:   nsresult rv;
  1:   nsCOMPtr<nsISelection> selection;
  1: 
  1:   // use mPresShell->GetSelectionForCopy() ?
  1:   rv = GetDocumentSelection(getter_AddRefs(selection));
  1:   if (NS_FAILED(rv)) return rv;
  1: 
  1:   return selection->CollapseToStart();
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::SelectAll()
  1: {
  1:   // XXX this is a temporary implementation copied from nsWebShell
  1:   // for now. I think nsDocument and friends should have some helper
  1:   // functions to make this easier.
  1:   nsCOMPtr<nsISelection> selection;
  1:   nsresult rv;
  1: 
  1:   // use mPresShell->GetSelectionForCopy() ?
  1:   rv = GetDocumentSelection(getter_AddRefs(selection));
  1:   if (NS_FAILED(rv)) return rv;
  1: 
  1:   nsCOMPtr<nsIDOMHTMLDocument> htmldoc = do_QueryInterface(mDocument);
  1:   nsCOMPtr<nsIDOMNode> bodyNode;
  1: 
  1:   if (htmldoc)
  1:   {
  1:     nsCOMPtr<nsIDOMHTMLElement>bodyElement;
  1:     rv = htmldoc->GetBody(getter_AddRefs(bodyElement));
  1:     if (NS_FAILED(rv) || !bodyElement) return rv;
  1: 
  1:     bodyNode = do_QueryInterface(bodyElement);
  1:   }
  1:   else if (mDocument)
  1:   {
  1:     bodyNode = do_QueryInterface(mDocument->GetRootContent());
  1:   }
  1:   if (!bodyNode) return NS_ERROR_FAILURE;
  1: 
  1:   rv = selection->RemoveAllRanges();
  1:   if (NS_FAILED(rv)) return rv;
  1: 
  1:   rv = selection->SelectAllChildren(bodyNode);
  1:   return rv;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::CopySelection()
  1: {
  1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
  1:   return mPresShell->DoCopy();
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::CopyLinkLocation()
  1: {
  1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
  1:   nsCOMPtr<nsIDOMNode> node;
  1:   GetPopupLinkNode(getter_AddRefs(node));
  1:   // make noise if we're not in a link
  1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
  1: 
  1:   nsAutoString locationText;
  1:   nsresult rv = mPresShell->GetLinkLocation(node, locationText);
  1:   NS_ENSURE_SUCCESS(rv, rv);
  1: 
  1:   nsCOMPtr<nsIClipboardHelper> clipboard(do_GetService("@mozilla.org/widget/clipboardhelper;1", &rv));
  1:   NS_ENSURE_SUCCESS(rv, rv);
  1: 
  1:   // copy the href onto the clipboard
  1:   return clipboard->CopyString(locationText);
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::CopyImage(PRInt32 aCopyFlags)
  1: {
  1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
  1:   nsCOMPtr<nsIImageLoadingContent> node;
  1:   GetPopupImageNode(getter_AddRefs(node));
  1:   // make noise if we're not in an image
  1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
  1: 
  1:   return nsCopySupport::ImageCopy(node, aCopyFlags);
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetCopyable(PRBool *aCopyable)
  1: {
  1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
  1: 
  1:   nsCOMPtr<nsISelection> selection;
  1:   nsresult rv = mPresShell->GetSelectionForCopy(getter_AddRefs(selection));
  1:   if (NS_FAILED(rv)) return rv;
  1: 
  1:   PRBool isCollapsed;
  1:   selection->GetIsCollapsed(&isCollapsed);
  1: 
  1:   *aCopyable = !isCollapsed;
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::CutSelection()
  1: {
  1:   // Nothing to do here.
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetCutable(PRBool *aCutable)
  1: {
  1:   *aCutable = PR_FALSE;  // mm, will this ever be called for an editable document?
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::Paste()
  1: {
  1:   // Nothing to do here.
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetPasteable(PRBool *aPasteable)
  1: {
  1:   *aPasteable = PR_FALSE;
  1:   return NS_OK;
  1: }
  1: 
  1: /* AString getContents (in string mimeType, in boolean selectionOnly); */
  1: NS_IMETHODIMP DocumentViewerImpl::GetContents(const char *mimeType, PRBool selectionOnly, nsAString& aOutValue)
  1: {
  1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
  1:   return mPresShell->DoGetContents(nsDependentCString(mimeType), 0, selectionOnly, aOutValue);
  1: }
  1: 
  1: /* readonly attribute boolean canGetContents; */
  1: NS_IMETHODIMP DocumentViewerImpl::GetCanGetContents(PRBool *aCanGetContents)
  1: {
  1:   return GetCopyable(aCanGetContents);
  1: }
  1: 
  1: #ifdef XP_MAC
  1: #pragma mark -
  1: #endif
  1: 
  1: /* ========================================================================================
  1:  * nsIContentViewerFile
  1:  * ======================================================================================== */
  1: /** ---------------------------------------------------
  1:  *  See documentation above in the nsIContentViewerfile class definition
  1:  *	@update 01/24/00 dwc
  1:  */
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::Print(PRBool            aSilent,
  1:                           FILE *            aDebugFile,
  1:                           nsIPrintSettings* aPrintSettings)
  1: {
  1: #ifdef NS_PRINTING
  1:   nsCOMPtr<nsIPrintSettings> printSettings;
  1: 
  1: #ifdef NS_DEBUG
  1:   nsresult rv = NS_ERROR_FAILURE;
  1: 
  1:   mDebugFile = aDebugFile;
  1:   // if they don't pass in a PrintSettings, then make one
  1:   // it will have all the default values
  1:   printSettings = aPrintSettings;
  1:   nsCOMPtr<nsIPrintOptions> printOptions = do_GetService(sPrintOptionsContractID, &rv);
  1:   if (NS_SUCCEEDED(rv)) {
  1:     // if they don't pass in a PrintSettings, then make one
  1:     if (printSettings == nsnull) {
  1:       printOptions->CreatePrintSettings(getter_AddRefs(printSettings));
  1:     }
  1:     NS_ASSERTION(printSettings, "You can't PrintPreview without a PrintSettings!");
  1:   }
  1:   if (printSettings) printSettings->SetPrintSilent(aSilent);
  1:   if (printSettings) printSettings->SetShowPrintProgress(PR_FALSE);
  1: #endif
  1: 
  1: 
  1:   return Print(printSettings, nsnull);
  1: #else
  1:   return NS_ERROR_FAILURE;
  1: #endif
  1: }
  1: 
  1: /* [noscript] void printWithParent (in nsIDOMWindowInternal aParentWin, in nsIPrintSettings aThePrintSettings, in nsIWebProgressListener aWPListener); */
  1: NS_IMETHODIMP 
  1: DocumentViewerImpl::PrintWithParent(nsIDOMWindowInternal *aParentWin, nsIPrintSettings *aThePrintSettings, nsIWebProgressListener *aWPListener)
  1: {
  1: #ifdef NS_PRINTING
  1:   return Print(aThePrintSettings, aWPListener);
  1: #else
  1:   return NS_ERROR_FAILURE;
  1: #endif
  1: }
  1: 
  1: // nsIContentViewerFile interface
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetPrintable(PRBool *aPrintable)
  1: {
  1:   NS_ENSURE_ARG_POINTER(aPrintable);
  1: 
  1:   *aPrintable = !GetIsPrinting();
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: //*****************************************************************************
  1: // nsIMarkupDocumentViewer
  1: //*****************************************************************************
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::ScrollToNode(nsIDOMNode* aNode)
  1: {
  1:    NS_ENSURE_ARG(aNode);
  1:    NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
  1:    nsCOMPtr<nsIPresShell> presShell;
  1:    NS_ENSURE_SUCCESS(GetPresShell(getter_AddRefs(presShell)), NS_ERROR_FAILURE);
  1: 
  1:    // Get the nsIContent interface, because that's what we need to
  1:    // get the primary frame
  1: 
  1:    nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
  1:    NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
  1: 
  1:    // Tell the PresShell to scroll to the primary frame of the content.
  1:    NS_ENSURE_SUCCESS(presShell->ScrollContentIntoView(content,
  1:                                                       NS_PRESSHELL_SCROLL_TOP,
  1:                                                       NS_PRESSHELL_SCROLL_ANYWHERE),
  1:                      NS_ERROR_FAILURE);
  1:    return NS_OK;
  1: }
  1: 
  1: void
  1: DocumentViewerImpl::CallChildren(CallChildFunc aFunc, void* aClosure)
  1: {
  1:   nsCOMPtr<nsIDocShellTreeNode> docShellNode(do_QueryReferent(mContainer));
  1:   if (docShellNode)
  1:   {
  1:     PRInt32 i;
  1:     PRInt32 n;
  1:     docShellNode->GetChildCount(&n);
  1:     for (i=0; i < n; i++)
  1:     {
  1:       nsCOMPtr<nsIDocShellTreeItem> child;
  1:       docShellNode->GetChildAt(i, getter_AddRefs(child));
  1:       nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
  1:       NS_ASSERTION(childAsShell, "null child in docshell");
  1:       if (childAsShell)
  1:       {
  1:         nsCOMPtr<nsIContentViewer> childCV;
  1:         childAsShell->GetContentViewer(getter_AddRefs(childCV));
  1:         if (childCV)
  1:         {
  1:           nsCOMPtr<nsIMarkupDocumentViewer> markupCV = do_QueryInterface(childCV);
  1:           if (markupCV) {
  1:             (*aFunc)(markupCV, aClosure);
  1:           }
  1:         }
  1:       }
  1:     }
  1:   }
  1: }
  1: 
  1: struct TextZoomInfo
  1: {
  1:   float mTextZoom;
  1: };
  1: 
  1: static void
  1: SetChildTextZoom(nsIMarkupDocumentViewer* aChild, void* aClosure)
  1: {
  1:   struct TextZoomInfo* textZoomInfo = (struct TextZoomInfo*) aClosure;
  1:   aChild->SetTextZoom(textZoomInfo->mTextZoom);
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetTextZoom(float aTextZoom)
  1: {
  1:   mTextZoom = aTextZoom;
  1: 
  1:   if (mViewManager) {
  1:     mViewManager->BeginUpdateViewBatch();
  1:   }
  1:       
  1:   // Set the text zoom on all children of mContainer (even if our zoom didn't
  1:   // change, our children's zoom may be different, though it would be unusual).
  1:   // Do this first, in case kids are auto-sizing and post reflow commands on
  1:   // our presshell (which should be subsumed into our own style change reflow).
  1:   struct TextZoomInfo textZoomInfo = { aTextZoom };
  1:   CallChildren(SetChildTextZoom, &textZoomInfo);
  1: 
  1:   // Now change our own zoom
  1:   if (mPresContext && aTextZoom != mPresContext->TextZoom()) {
  1:       mPresContext->SetTextZoom(aTextZoom);
  1:   }
  1: 
  1:   if (mViewManager) {
  1:     mViewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
  1:   }
  1:   
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetTextZoom(float* aTextZoom)
  1: {
  1:   NS_ENSURE_ARG_POINTER(aTextZoom);
  1:   NS_ASSERTION(!mPresContext || mPresContext->TextZoom() == mTextZoom, 
  1:                "mPresContext->TextZoom() != mTextZoom");
  1: 
  1:   *aTextZoom = mTextZoom;
  1:   return NS_OK;
  1: }
  1: 
  1: static void
  1: SetChildAuthorStyleDisabled(nsIMarkupDocumentViewer* aChild, void* aClosure)
  1: {
  1:   PRBool styleDisabled  = *NS_STATIC_CAST(PRBool*, aClosure);
  1:   aChild->SetAuthorStyleDisabled(styleDisabled);
  1: }
  1: 
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetAuthorStyleDisabled(PRBool aStyleDisabled)
  1: {
  1:   if (mPresShell) {
  1:     mPresShell->SetAuthorStyleDisabled(aStyleDisabled);
  1:   }
  1:   CallChildren(SetChildAuthorStyleDisabled, &aStyleDisabled);
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetAuthorStyleDisabled(PRBool* aStyleDisabled)
  1: {
  1:   if (mPresShell) {
  1:     *aStyleDisabled = mPresShell->GetAuthorStyleDisabled();
  1:   } else {
  1:     *aStyleDisabled = PR_FALSE;
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetDefaultCharacterSet(nsACString& aDefaultCharacterSet)
  1: {
  1:   NS_ENSURE_STATE(nsCOMPtr<nsISupports>(do_QueryReferent(mContainer)));
  1: 
  1:   if (mDefaultCharacterSet.IsEmpty())
  1:   {
  1:     const nsAdoptingString& defCharset =
  1:       nsContentUtils::GetLocalizedStringPref("intl.charset.default");
  1: 
  1:     if (!defCharset.IsEmpty())
  1:       LossyCopyUTF16toASCII(defCharset, mDefaultCharacterSet);
  1:     else
  1:       mDefaultCharacterSet.AssignLiteral("ISO-8859-1");
  1:   }
  1:   aDefaultCharacterSet = mDefaultCharacterSet;
  1:   return NS_OK;
  1: }
  1: 
  1: static void
  1: SetChildDefaultCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
  1: {
  1:   const nsACString* charset = NS_STATIC_CAST(nsACString*, aClosure);
  1:   aChild->SetDefaultCharacterSet(*charset);
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetDefaultCharacterSet(const nsACString& aDefaultCharacterSet)
  1: {
  1:   mDefaultCharacterSet = aDefaultCharacterSet;  // this does a copy of aDefaultCharacterSet
  1:   // now set the default char set on all children of mContainer
  1:   CallChildren(SetChildDefaultCharacterSet, (void*) &aDefaultCharacterSet);
  1:   return NS_OK;
  1: }
  1: 
  1: // XXX: SEMANTIC CHANGE!
  1: //      returns a copy of the string.  Caller is responsible for freeing result
  1: //      using Recycle(aForceCharacterSet)
  1: NS_IMETHODIMP DocumentViewerImpl::GetForceCharacterSet(nsACString& aForceCharacterSet)
  1: {
  1:   aForceCharacterSet = mForceCharacterSet;
  1:   return NS_OK;
  1: }
  1: 
  1: static void
  1: SetChildForceCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
  1: {
  1:   const nsACString* charset = NS_STATIC_CAST(nsACString*, aClosure);
  1:   aChild->SetForceCharacterSet(*charset);
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetForceCharacterSet(const nsACString& aForceCharacterSet)
  1: {
  1:   mForceCharacterSet = aForceCharacterSet;
  1:   // now set the force char set on all children of mContainer
  1:   CallChildren(SetChildForceCharacterSet, (void*) &aForceCharacterSet);
  1:   return NS_OK;
  1: }
  1: 
  1: // XXX: SEMANTIC CHANGE!
  1: //      returns a copy of the string.  Caller is responsible for freeing result
  1: //      using Recycle(aHintCharacterSet)
  1: NS_IMETHODIMP DocumentViewerImpl::GetHintCharacterSet(nsACString& aHintCharacterSet)
  1: {
  1: 
  1:   if(kCharsetUninitialized == mHintCharsetSource) {
  1:     aHintCharacterSet.Truncate();
  1:   } else {
  1:     aHintCharacterSet = mHintCharset;
  1:     // this can't possibly be right.  we can't set a value just because somebody got a related value!
  1:     //mHintCharsetSource = kCharsetUninitialized;
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetHintCharacterSetSource(PRInt32 *aHintCharacterSetSource)
  1: {
  1:   NS_ENSURE_ARG_POINTER(aHintCharacterSetSource);
  1: 
  1:   *aHintCharacterSetSource = mHintCharsetSource;
  1:   return NS_OK;
  1: }
  1: 
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetPrevDocCharacterSet(nsACString& aPrevDocCharacterSet)
  1: {
  1:   aPrevDocCharacterSet = mPrevDocCharacterSet;
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: static void
  1: SetChildPrevDocCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
  1: {
  1:   const nsACString* charset = NS_STATIC_CAST(nsACString*, aClosure);
  1:   aChild->SetPrevDocCharacterSet(*charset);
  1: }
  1: 
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetPrevDocCharacterSet(const nsACString& aPrevDocCharacterSet)
  1: {
  1:   mPrevDocCharacterSet = aPrevDocCharacterSet;  
  1:   CallChildren(SetChildPrevDocCharacterSet, (void*) &aPrevDocCharacterSet);
  1:   return NS_OK;
  1: }
  1: 
  1: 
  1: static void
  1: SetChildHintCharacterSetSource(nsIMarkupDocumentViewer* aChild, void* aClosure)
  1: {
  1:   aChild->SetHintCharacterSetSource(NS_PTR_TO_INT32(aClosure));
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetHintCharacterSetSource(PRInt32 aHintCharacterSetSource)
  1: {
  1:   mHintCharsetSource = aHintCharacterSetSource;
  1:   // now set the hint char set source on all children of mContainer
  1:   CallChildren(SetChildHintCharacterSetSource,
  1:                       (void*) aHintCharacterSetSource);
  1:   return NS_OK;
  1: }
  1: 
  1: static void
  1: SetChildHintCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
  1: {
  1:   const nsACString* charset = NS_STATIC_CAST(nsACString*, aClosure);
  1:   aChild->SetHintCharacterSet(*charset);
  1: }
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::SetHintCharacterSet(const nsACString& aHintCharacterSet)
  1: {
  1:   mHintCharset = aHintCharacterSet;
  1:   // now set the hint char set on all children of mContainer
  1:   CallChildren(SetChildHintCharacterSet, (void*) &aHintCharacterSet);
  1:   return NS_OK;
  1: }
  1: 
  1: static void
  1: SetChildBidiOptions(nsIMarkupDocumentViewer* aChild, void* aClosure)
  1: {
  1:   aChild->SetBidiOptions(NS_PTR_TO_INT32(aClosure));
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::SetBidiTextDirection(PRUint8 aTextDirection)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   GetBidiOptions(&bidiOptions);
  1:   SET_BIDI_OPTION_DIRECTION(bidiOptions, aTextDirection);
  1:   SetBidiOptions(bidiOptions);
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetBidiTextDirection(PRUint8* aTextDirection)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   if (aTextDirection) {
  1:     GetBidiOptions(&bidiOptions);
  1:     *aTextDirection = GET_BIDI_OPTION_DIRECTION(bidiOptions);
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::SetBidiTextType(PRUint8 aTextType)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   GetBidiOptions(&bidiOptions);
  1:   SET_BIDI_OPTION_TEXTTYPE(bidiOptions, aTextType);
  1:   SetBidiOptions(bidiOptions);
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetBidiTextType(PRUint8* aTextType)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   if (aTextType) {
  1:     GetBidiOptions(&bidiOptions);
  1:     *aTextType = GET_BIDI_OPTION_TEXTTYPE(bidiOptions);
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::SetBidiControlsTextMode(PRUint8 aControlsTextMode)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   GetBidiOptions(&bidiOptions);
  1:   SET_BIDI_OPTION_CONTROLSTEXTMODE(bidiOptions, aControlsTextMode);
  1:   SetBidiOptions(bidiOptions);
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetBidiControlsTextMode(PRUint8* aControlsTextMode)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   if (aControlsTextMode) {
  1:     GetBidiOptions(&bidiOptions);
  1:     *aControlsTextMode = GET_BIDI_OPTION_CONTROLSTEXTMODE(bidiOptions);
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::SetBidiNumeral(PRUint8 aNumeral)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   GetBidiOptions(&bidiOptions);
  1:   SET_BIDI_OPTION_NUMERAL(bidiOptions, aNumeral);
  1:   SetBidiOptions(bidiOptions);
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetBidiNumeral(PRUint8* aNumeral)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   if (aNumeral) {
  1:     GetBidiOptions(&bidiOptions);
  1:     *aNumeral = GET_BIDI_OPTION_NUMERAL(bidiOptions);
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::SetBidiSupport(PRUint8 aSupport)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   GetBidiOptions(&bidiOptions);
  1:   SET_BIDI_OPTION_SUPPORT(bidiOptions, aSupport);
  1:   SetBidiOptions(bidiOptions);
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetBidiSupport(PRUint8* aSupport)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   if (aSupport) {
  1:     GetBidiOptions(&bidiOptions);
  1:     *aSupport = GET_BIDI_OPTION_SUPPORT(bidiOptions);
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::SetBidiCharacterSet(PRUint8 aCharacterSet)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   GetBidiOptions(&bidiOptions);
  1:   SET_BIDI_OPTION_CHARACTERSET(bidiOptions, aCharacterSet);
  1:   SetBidiOptions(bidiOptions);
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetBidiCharacterSet(PRUint8* aCharacterSet)
  1: {
  1:   PRUint32 bidiOptions;
  1: 
  1:   if (aCharacterSet) {
  1:     GetBidiOptions(&bidiOptions);
  1:     *aCharacterSet = GET_BIDI_OPTION_CHARACTERSET(bidiOptions);
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::SetBidiOptions(PRUint32 aBidiOptions)
  1: {
  1:   if (mPresContext) {
  1:     mPresContext->SetBidi(aBidiOptions, PR_TRUE); // could cause reflow
  1:   }
  1:   // now set bidi on all children of mContainer
  1:   CallChildren(SetChildBidiOptions, (void*) aBidiOptions);
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetBidiOptions(PRUint32* aBidiOptions)
  1: {
  1:   if (aBidiOptions) {
  1:     if (mPresContext) {
  1:       *aBidiOptions = mPresContext->GetBidi();
  1:     }
  1:     else
  1:       *aBidiOptions = IBMBIDI_DEFAULT_BIDI_OPTIONS;
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::SizeToContent()
  1: {
  1:    NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
  1: 
  1:    nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryReferent(mContainer));
  1:    NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
  1: 
  1:    nsCOMPtr<nsIDocShellTreeItem> docShellParent;
  1:    docShellAsItem->GetSameTypeParent(getter_AddRefs(docShellParent));
  1: 
  1:    // It's only valid to access this from a top frame.  Doesn't work from
  1:    // sub-frames.
  1:    NS_ENSURE_TRUE(!docShellParent, NS_ERROR_FAILURE);
  1: 
  1:    nsCOMPtr<nsIPresShell> presShell;
  1:    GetPresShell(getter_AddRefs(presShell));
  1:    NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
  1: 
  1:    // Flush out all content and style updates. We can't use a resize reflow
  1:    // because it won't change some sizes that a style change reflow will.
  1:    mDocument->FlushPendingNotifications(Flush_Layout);
  1: 
  1:   nsIFrame *root = presShell->GetRootFrame();
  1:   NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
  1: 
  1:   nscoord prefWidth;
  1:   {
  1:     nsCOMPtr<nsIRenderingContext> rcx;
  1:     presShell->CreateRenderingContext(root, getter_AddRefs(rcx));
  1:     NS_ENSURE_TRUE(rcx, NS_ERROR_FAILURE);
  1:     prefWidth = root->GetPrefWidth(rcx);
  1:   }
  1: 
  1:   nsresult rv = presShell->ResizeReflow(prefWidth, NS_UNCONSTRAINEDSIZE);
  1:   NS_ENSURE_SUCCESS(rv, rv);
  1: 
  1:    nsCOMPtr<nsPresContext> presContext;
  1:    GetPresContext(getter_AddRefs(presContext));
  1:    NS_ENSURE_TRUE(presContext, NS_ERROR_FAILURE);
  1: 
  1:    PRInt32 width, height;
  1: 
  1:    // so how big is it?
  1:    nsRect shellArea = presContext->GetVisibleArea();
  1:    if (shellArea.width == NS_UNCONSTRAINEDSIZE ||
  1:        shellArea.height == NS_UNCONSTRAINEDSIZE) {
  1:      // Protect against bogus returns here
  1:      return NS_ERROR_FAILURE;
  1:    }
  1:    width = presContext->AppUnitsToDevPixels(shellArea.width);
  1:    height = presContext->AppUnitsToDevPixels(shellArea.height);
  1: 
  1:    nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
  1:    docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
  1:    NS_ENSURE_TRUE(treeOwner, NS_ERROR_FAILURE);
  1: 
  1:    /* presContext's size was calculated in twips and has already been
  1:       rounded to the equivalent pixels (so the width/height calculation
  1:       we just performed was probably exact, though it was based on
  1:       values already rounded during ResizeReflow). In a surprising
  1:       number of instances, this rounding makes a window which for want
  1:       of one extra pixel's width ends up wrapping the longest line of
  1:       text during actual window layout. This makes the window too short,
  1:       generally clipping the OK/Cancel buttons. Here we add one pixel
  1:       to the calculated width, to circumvent this problem. */
  1:    NS_ENSURE_SUCCESS(treeOwner->SizeShellTo(docShellAsItem, width+1, height),
  1:       NS_ERROR_FAILURE);
  1: 
  1:    return NS_OK;
  1: }
  1: 
  1: 
  1: NS_IMPL_ISUPPORTS1(nsDocViewerSelectionListener, nsISelectionListener)
  1: 
  1: nsresult nsDocViewerSelectionListener::Init(DocumentViewerImpl *aDocViewer)
  1: {
  1:   mDocViewer = aDocViewer;
  1:   return NS_OK;
  1: }
  1: 
  1: /*
  1:  * GetPopupNode, GetPopupLinkNode and GetPopupImageNode are helpers
  1:  * for the cmd_copyLink / cmd_copyImageLocation / cmd_copyImageContents family
  1:  * of commands. The focus controller stores the popup node, these retrieve
  1:  * them and munge appropriately. Note that we have to store the popup node
  1:  * rather than retrieving it from EventStateManager::GetFocusedContent because
  1:  * not all content (images included) can receive focus.
  1:  */
  1: 
  1: nsresult
  1: DocumentViewerImpl::GetPopupNode(nsIDOMNode** aNode)
  1: {
  1:   NS_ENSURE_ARG_POINTER(aNode);
  1: 
  1:   nsresult rv;
  1: 
  1:   // get the document
  1:   nsCOMPtr<nsIDocument> document;
  1:   rv = GetDocument(getter_AddRefs(document));
  1:   NS_ENSURE_SUCCESS(rv, rv);
  1:   NS_ENSURE_TRUE(document, NS_ERROR_FAILURE);
  1: 
  1: 
  1:   // get the private dom window
  1:   nsPIDOMWindow *privateWin = document->GetWindow();
  1:   NS_ENSURE_TRUE(privateWin, NS_ERROR_NOT_AVAILABLE);
  1: 
  1:   // get the focus controller
  1:   nsIFocusController *focusController = privateWin->GetRootFocusController();
  1:   NS_ENSURE_TRUE(focusController, NS_ERROR_FAILURE);
  1: 
  1:   // get the popup node
  1:   focusController->GetPopupNode(aNode); // addref happens here
  1: 
  1:   return rv;
  1: }
  1: 
  1: // GetPopupLinkNode: return popup link node or fail
  1: nsresult
  1: DocumentViewerImpl::GetPopupLinkNode(nsIDOMNode** aNode)
  1: {
  1:   NS_ENSURE_ARG_POINTER(aNode);
  1: 
  1:   // you get null unless i say so
  1:   *aNode = nsnull;
  1: 
  1:   // find popup node
  1:   nsCOMPtr<nsIDOMNode> node;
  1:   nsresult rv = GetPopupNode(getter_AddRefs(node));
  1:   NS_ENSURE_SUCCESS(rv, rv);
  1: 
  1:   // find out if we have a link in our ancestry
  1:   while (node) {
  1: 
  1:     // are we an anchor?
  1:     nsCOMPtr<nsIDOMHTMLAnchorElement> anchor(do_QueryInterface(node));
  1:     nsCOMPtr<nsIDOMHTMLAreaElement> area;
  1:     nsCOMPtr<nsIDOMHTMLLinkElement> link;
  1:     nsAutoString xlinkType;
  1:     if (!anchor) {
  1:       // area?
  1:       area = do_QueryInterface(node);
  1:       if (!area) {
  1:         // link?
  1:         link = do_QueryInterface(node);
  1:         if (!link) {
  1:           // XLink?
  1:           nsCOMPtr<nsIDOMElement> element(do_QueryInterface(node));
  1:           if (element) {
  1:             element->GetAttributeNS(NS_LITERAL_STRING("http://www.w3.org/1999/xlink"),NS_LITERAL_STRING("type"),xlinkType);
  1:           }
  1:         }
  1:       }
  1:     }
  1:     if (anchor || area || link || xlinkType.EqualsLiteral("simple")) {
  1:       *aNode = node;
  1:       NS_IF_ADDREF(*aNode); // addref
  1:       return NS_OK;
  1:     }
  1:     else {
  1:       // if not, get our parent and keep trying...
  1:       nsCOMPtr<nsIDOMNode> parentNode;
  1:       node->GetParentNode(getter_AddRefs(parentNode));
  1:       node = parentNode;
  1:     }
  1:   }
  1: 
  1:   // if we have no node, fail
  1:   return NS_ERROR_FAILURE;
  1: }
  1: 
  1: // GetPopupLinkNode: return popup image node or fail
  1: nsresult
  1: DocumentViewerImpl::GetPopupImageNode(nsIImageLoadingContent** aNode)
  1: {
  1:   NS_ENSURE_ARG_POINTER(aNode);
  1: 
  1:   // you get null unless i say so
  1:   *aNode = nsnull;
  1: 
  1:   // find popup node
  1:   nsCOMPtr<nsIDOMNode> node;
  1:   nsresult rv = GetPopupNode(getter_AddRefs(node));
  1:   NS_ENSURE_SUCCESS(rv, rv);
  1: 
  1:   if (node)
  1:     CallQueryInterface(node, aNode);
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: /*
  1:  * XXX dr
  1:  * ------
  1:  * These two functions -- GetInLink and GetInImage -- are kind of annoying
  1:  * in that they only get called from the controller (in
  1:  * nsDOMWindowController::IsCommandEnabled). The actual construction of the
  1:  * context menus in communicator (nsContextMenu.js) has its own, redundant
  1:  * tests. No big deal, but good to keep in mind if we ever clean context
  1:  * menus.
  1:  */
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetInLink(PRBool* aInLink)
  1: {
  1: #ifdef DEBUG_dr
  1:   printf("dr :: DocumentViewerImpl::GetInLink\n");
  1: #endif
  1: 
  1:   NS_ENSURE_ARG_POINTER(aInLink);
  1: 
  1:   // we're not in a link unless i say so
  1:   *aInLink = PR_FALSE;
  1: 
  1:   // get the popup link
  1:   nsCOMPtr<nsIDOMNode> node;
  1:   nsresult rv = GetPopupLinkNode(getter_AddRefs(node));
  1:   if (NS_FAILED(rv)) return rv;
  1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
  1: 
  1:   // if we made it here, we're in a link
  1:   *aInLink = PR_TRUE;
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::GetInImage(PRBool* aInImage)
  1: {
  1: #ifdef DEBUG_dr
  1:   printf("dr :: DocumentViewerImpl::GetInImage\n");
  1: #endif
  1: 
  1:   NS_ENSURE_ARG_POINTER(aInImage);
  1: 
  1:   // we're not in an image unless i say so
  1:   *aInImage = PR_FALSE;
  1: 
  1:   // get the popup image
  1:   nsCOMPtr<nsIImageLoadingContent> node;
  1:   nsresult rv = GetPopupImageNode(getter_AddRefs(node));
  1:   if (NS_FAILED(rv)) return rv;
  1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
  1: 
  1:   // if we made it here, we're in an image
  1:   *aInImage = PR_TRUE;
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP nsDocViewerSelectionListener::NotifySelectionChanged(nsIDOMDocument *, nsISelection *, PRInt16)
  1: {
  1:   NS_ASSERTION(mDocViewer, "Should have doc viewer!");
  1: 
  1:   // get the selection state
  1:   nsCOMPtr<nsISelection> selection;
  1:   nsresult rv = mDocViewer->GetDocumentSelection(getter_AddRefs(selection));
  1:   if (NS_FAILED(rv)) return rv;
  1: 
  1:   PRBool selectionCollapsed;
  1:   selection->GetIsCollapsed(&selectionCollapsed);
  1:   // we only call UpdateCommands when the selection changes from collapsed
  1:   // to non-collapsed or vice versa. We might need another update string
  1:   // for simple selection changes, but that would be expenseive.
  1:   if (!mGotSelectionState || mSelectionWasCollapsed != selectionCollapsed)
  1:   {
  1:     nsCOMPtr<nsIDocument> theDoc;
  1:     mDocViewer->GetDocument(getter_AddRefs(theDoc));
  1:     if (!theDoc) return NS_ERROR_FAILURE;
  1: 
  1:     nsPIDOMWindow *domWindow = theDoc->GetWindow();
  1:     if (!domWindow) return NS_ERROR_FAILURE;
  1: 
  1:     domWindow->UpdateCommands(NS_LITERAL_STRING("select"));
  1:     mGotSelectionState = PR_TRUE;
  1:     mSelectionWasCollapsed = selectionCollapsed;
  1:   }
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: //nsDocViewerFocusListener
  1: NS_IMPL_ISUPPORTS2(nsDocViewerFocusListener,
  1:                    nsIDOMFocusListener,
  1:                    nsIDOMEventListener)
  1: 
  1: nsDocViewerFocusListener::nsDocViewerFocusListener()
  1: :mDocViewer(nsnull)
  1: {
  1: }
  1: 
  1: nsDocViewerFocusListener::~nsDocViewerFocusListener(){}
  1: 
  1: nsresult
  1: nsDocViewerFocusListener::HandleEvent(nsIDOMEvent* aEvent)
  1: {
  1:   return NS_OK;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: nsDocViewerFocusListener::Focus(nsIDOMEvent* aEvent)
  1: {
  1:   nsCOMPtr<nsIPresShell> shell;
  1:   if(!mDocViewer)
  1:     return NS_ERROR_FAILURE;
  1: 
  1:   nsresult result = mDocViewer->GetPresShell(getter_AddRefs(shell));
  1:   if(NS_FAILED(result) || !shell)
  1:     return result?result:NS_ERROR_FAILURE;
  1:   nsCOMPtr<nsISelectionController> selCon;
  1:   selCon = do_QueryInterface(shell);
  1:   PRInt16 selectionStatus;
  1:   selCon->GetDisplaySelection(&selectionStatus);
  1: 
  1:   // If selection was disabled, re-enable it.
  1:   if(selectionStatus == nsISelectionController::SELECTION_DISABLED ||
  1:      selectionStatus == nsISelectionController::SELECTION_HIDDEN)
  1:   {
  1:     selCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
  1:     selCon->RepaintSelection(nsISelectionController::SELECTION_NORMAL);
  1:   }
  1:   return result;
  1: }
  1: 
  1: NS_IMETHODIMP
  1: nsDocViewerFocusListener::Blur(nsIDOMEvent* aEvent)
  1: {
  1:   nsCOMPtr<nsIPresShell> shell;
  1:   if(!mDocViewer)
  1:     return NS_ERROR_FAILURE;
  1: 
  1:   nsresult result = mDocViewer->GetPresShell(getter_AddRefs(shell));
  1:   if(NS_FAILED(result) || !shell)
  1:     return result?result:NS_ERROR_FAILURE;
  1:   nsCOMPtr<nsISelectionController> selCon;
  1:   selCon = do_QueryInterface(shell);
  1:   PRInt16 selectionStatus;
  1:   selCon->GetDisplaySelection(&selectionStatus);
  1: 
  1:   // If selection was on, disable it.
  1:   if(selectionStatus == nsISelectionController::SELECTION_ON ||
  1:      selectionStatus == nsISelectionController::SELECTION_ATTENTION)
  1:   {
  1:     selCon->SetDisplaySelection(nsISelectionController::SELECTION_DISABLED);
  1:     selCon->RepaintSelection(nsISelectionController::SELECTION_NORMAL);
  1:   }
  1:   return result;
  1: }
  1: 
  1: 
  1: nsresult
  1: nsDocViewerFocusListener::Init(DocumentViewerImpl *aDocViewer)
  1: {
  1:   mDocViewer = aDocViewer;
  1:   return NS_OK;
  1: }
  1: 
  1: /** ---------------------------------------------------
  1:  *  From nsIWebBrowserPrint
  1:  */
  1: 
  1: #ifdef NS_PRINTING
  1: 
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::Print(nsIPrintSettings*       aPrintSettings,
  1:                           nsIWebProgressListener* aWebProgressListener)
  1: {
  1: 
  1: #ifdef MOZ_XUL
  1:   // Temporary code for Bug 136185 / Bug 240490
  1:   nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
  1:   if (xulDoc) {
  1:     nsPrintEngine::ShowPrintErrorDialog(NS_ERROR_GFX_PRINTER_NO_XUL);
  1:     return NS_ERROR_FAILURE;
  1:   }
  1: #endif
  1: 
  1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
  1:   NS_ASSERTION(docShell, "This has to be a docshell");
  1: 
  1:   // Check to see if this document is still busy
  1:   // If it is busy and we aren't already "queued" up to print then
  1:   // Indicate there is a print pending and cache the args for later
  1:   PRUint32 busyFlags = nsIDocShell::BUSY_FLAGS_NONE;
  1:   if ((NS_FAILED(docShell->GetBusyFlags(&busyFlags)) ||
  1:        (busyFlags != nsIDocShell::BUSY_FLAGS_NONE && busyFlags & nsIDocShell::BUSY_FLAGS_PAGE_LOADING)) && 
  1:       !mPrintDocIsFullyLoaded) {
  1:     if (!mPrintIsPending) {
  1:       mCachedPrintSettings           = aPrintSettings;
  1:       mCachedPrintWebProgressListner = aWebProgressListener;
  1:       mPrintIsPending                = PR_TRUE;
  1:     }
  1:     PR_PL(("Printing Stopped - document is still busy!"));
  1:     return NS_ERROR_GFX_PRINTER_DOC_IS_BUSY;
  1:   }
  1: 
  1:   nsCOMPtr<nsIPresShell> presShell;
  1:   docShell->GetPresShell(getter_AddRefs(presShell));
  1:   if (!presShell || !mDocument || !mDeviceContext || !mParentWidget) {
  1:     PR_PL(("Can't Print without pres shell, document etc"));
  1:     return NS_ERROR_FAILURE;
  1:   }
  1: 
  1:   nsresult rv;
  1: 
  1:   // if we are printing another URL, then exit
  1:   // the reason we check here is because this method can be called while
  1:   // another is still in here (the printing dialog is a good example).
  1:   // the only time we can print more than one job at a time is the regression tests
  1:   if (GetIsPrinting()) {
  1:     // Let the user know we are not ready to print.
  1:     rv = NS_ERROR_NOT_AVAILABLE;
  1:     nsPrintEngine::ShowPrintErrorDialog(rv);
  1:     return rv;
  1:   }
  1: 
  1:   // If we are hosting a full-page plugin, tell it to print
  1:   // first. It shows its own native print UI.
  1:   nsCOMPtr<nsIPluginDocument> pDoc(do_QueryInterface(mDocument));
  1:   if (pDoc)
  1:     return pDoc->Print();
  1: 
  1:   if (!mPrintEngine) {
  1:     mPrintEngine = new nsPrintEngine();
  1:     NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_OUT_OF_MEMORY);
  1: 
  1:     rv = mPrintEngine->Initialize(this, docShell, mDocument, 
  1:                                   mDeviceContext, mParentWidget,
  1: #ifdef NS_DEBUG
  1:                                   mDebugFile
  1: #else
  1:                                   nsnull
  1: #endif
  1:                                   );
  1:     if (NS_FAILED(rv)) {
  1:       mPrintEngine->Destroy();
  1:       mPrintEngine = nsnull;
  1:       return rv;
  1:     }
  1:   }
  1: 
  1:   rv = mPrintEngine->Print(aPrintSettings, aWebProgressListener);
  1:   if (NS_FAILED(rv)) {
  1:     OnDonePrinting();
  1:   }
  1:   return rv;
  1: }
  1: 
  1: /** ---------------------------------------------------
  1:  *  See documentation above in the nsIContentViewerfile class definition
  1:  *	@update 11/01/01 rods
  1:  *
  1:  *  For a full and detailed understanding of the issues with
  1:  *  PrintPreview: See the design spec that is attached to Bug 107562
  1:  */
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::PrintPreview(nsIPrintSettings* aPrintSettings, 
  1:                                  nsIDOMWindow *aChildDOMWin, 
  1:                                  nsIWebProgressListener* aWebProgressListener)
  1: {
  1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
  1:   nsresult rv = NS_OK;
  1: 
  1:   if (GetIsPrinting()) {
  1:     nsPrintEngine::CloseProgressDialog(aWebProgressListener);
  1:     return NS_ERROR_FAILURE;
  1:   }
  1: 
  1: #ifdef MOZ_XUL
  1:   // Temporary code for Bug 136185 / Bug 240490
  1:   nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
  1:   if (xulDoc) {
  1:     nsPrintEngine::CloseProgressDialog(aWebProgressListener);
  1:     nsPrintEngine::ShowPrintErrorDialog(NS_ERROR_GFX_PRINTER_NO_XUL, PR_FALSE);
  1:     return NS_ERROR_FAILURE;
  1:   }
  1: #endif
  1: 
  1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
  1:   NS_ASSERTION(docShell, "This has to be a docshell");
  1:   nsCOMPtr<nsIPresShell> presShell;
  1:   docShell->GetPresShell(getter_AddRefs(presShell));
  1:   if (!presShell || !mDocument || !mDeviceContext || !mParentWidget) {
  1:     PR_PL(("Can't Print Preview without pres shell, document etc"));
  1:     return NS_ERROR_FAILURE;
  1:   }
  1: 
  1:   if (!mPrintEngine) {
  1:     mPrintEngine = new nsPrintEngine();
  1:     NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_OUT_OF_MEMORY);
  1: 
  1:     rv = mPrintEngine->Initialize(this, docShell, mDocument,
  1:                                   mDeviceContext, mParentWidget,
  1: #ifdef NS_DEBUG
  1:                                   mDebugFile
  1: #else
  1:                                   nsnull
  1: #endif
  1:                                   );
  1:     if (NS_FAILED(rv)) {
  1:       mPrintEngine->Destroy();
  1:       mPrintEngine = nsnull;
  1:       return rv;
  1:     }
  1:   }
  1: 
  1:   rv = mPrintEngine->PrintPreview(aPrintSettings, aChildDOMWin, aWebProgressListener);
  1:   if (NS_FAILED(rv)) {
  1:     OnDonePrinting();
  1:   }
  1:   return rv;
  1: #else
  1:   return NS_ERROR_FAILURE;
  1: #endif
  1: }
  1: 
  1: //----------------------------------------------------------------------
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::PrintPreviewNavigate(PRInt16 aType, PRInt32 aPageNum)
  1: {
  1:   if (!GetIsPrintPreview() ||
  1:       mPrintEngine->GetIsCreatingPrintPreview())
  1:     return NS_ERROR_FAILURE;
  1: 
  1:   nsIScrollableView* scrollableView = nsnull;
  1:   mPrintEngine->GetPrintPreviewViewManager()->GetRootScrollableView(&scrollableView);
  1:   if (scrollableView == nsnull)
  1:     return NS_OK;
  1: 
  1:   // Check to see if we can short circut scrolling to the top
  1:   if (aType == nsIWebBrowserPrint::PRINTPREVIEW_HOME ||
  1:       (aType == nsIWebBrowserPrint::PRINTPREVIEW_GOTO_PAGENUM && aPageNum == 1)) {
  1:     scrollableView->ScrollTo(0, 0, PR_TRUE);
  1:     return NS_OK;
  1:   }
  1: 
  1:   // Finds the SimplePageSequencer frame
  1:   // in PP mPrtPreview->mPrintObject->mSeqFrame is null
  1:   nsIFrame* seqFrame  = nsnull;
  1:   PRInt32   pageCount = 0;
  1:   if (NS_FAILED(mPrintEngine->GetSeqFrameAndCountPages(seqFrame, pageCount))) {
  1:     return NS_ERROR_FAILURE;
  1:   }
  1: 
  1:   // Figure where we are currently scrolled to
  1:   nscoord x;
  1:   nscoord y;
  1:   scrollableView->GetScrollPosition(x, y);
  1: 
  1:   PRInt32    pageNum = 1;
  1:   nsIFrame * fndPageFrame  = nsnull;
  1:   nsIFrame * currentPage   = nsnull;
  1: 
  1:   // If it is "End" then just do a "goto" to the last page
  1:   if (aType == nsIWebBrowserPrint::PRINTPREVIEW_END) {
  1:     aType    = nsIWebBrowserPrint::PRINTPREVIEW_GOTO_PAGENUM;
  1:     aPageNum = pageCount;
  1:   }
  1: 
  1:   // Now, locate the current page we are on and
  1:   // and the page of the page number
  1:   nscoord gap = 0;
  1:   nsIFrame* pageFrame = seqFrame->GetFirstChild(nsnull);
  1:   while (pageFrame != nsnull) {
  1:     nsRect pageRect = pageFrame->GetRect();
  1:     if (pageNum == 1) {
  1:       gap = pageRect.y;
  1:     }
  1:     if (pageRect.Contains(pageRect.x, y)) {
  1:       currentPage = pageFrame;
  1:     }
  1:     if (pageNum == aPageNum) {
  1:       fndPageFrame = pageFrame;
  1:       break;
  1:     }
  1:     pageNum++;
  1:     pageFrame = pageFrame->GetNextSibling();
  1:   }
  1: 
  1:   if (aType == nsIWebBrowserPrint::PRINTPREVIEW_PREV_PAGE) {
  1:     if (currentPage) {
  1:       fndPageFrame = currentPage->GetPrevInFlow();
  1:       if (!fndPageFrame) {
  1:         return NS_OK;
  1:       }
  1:     } else {
  1:       return NS_OK;
  1:     }
  1:   } else if (aType == nsIWebBrowserPrint::PRINTPREVIEW_NEXT_PAGE) {
  1:     if (currentPage) {
  1:       fndPageFrame = currentPage->GetNextInFlow();
  1:       if (!fndPageFrame) {
  1:         return NS_OK;
  1:       }
  1:     } else {
  1:       return NS_OK;
  1:     }
  1:   } else { // If we get here we are doing "GoTo"
  1:     if (aPageNum < 0 || aPageNum > pageCount) {
  1:       return NS_OK;
  1:     }
  1:   }
  1: 
  1:   if (fndPageFrame && scrollableView) {
  1:     nscoord deadSpaceGap = 0;
  1:     nsIPageSequenceFrame * sqf;
  1:     if (NS_SUCCEEDED(CallQueryInterface(seqFrame, &sqf))) {
  1:       sqf->GetDeadSpaceValue(&deadSpaceGap);
  1:     }
  1: 
  1:     // scroll so that top of page (plus the gray area) is at the top of the scroll area
  1:     scrollableView->ScrollTo(0, fndPageFrame->GetPosition().y-deadSpaceGap, PR_TRUE);
  1:   }
  1:   return NS_OK;
  1: 
  1: }
  1: 
  1: /* readonly attribute nsIPrintSettings globalPrintSettings; */
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetGlobalPrintSettings(nsIPrintSettings * *aGlobalPrintSettings)
  1: {
  1:   return nsPrintEngine::GetGlobalPrintSettings(aGlobalPrintSettings);
  1: }
  1: 
  1: /* readonly attribute boolean doingPrint; */
  1: // XXX This always returns PR_FALSE for subdocuments
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetDoingPrint(PRBool *aDoingPrint)
  1: {
  1:   NS_ENSURE_ARG_POINTER(aDoingPrint);
  1:   
  1:   *aDoingPrint = PR_FALSE;
  1:   if (mPrintEngine) {
  1:     // XXX shouldn't this be GetDoingPrint() ?
  1:     return mPrintEngine->GetDoingPrintPreview(aDoingPrint);
  1:   } 
  1:   return NS_OK;
  1: }
  1: 
  1: /* readonly attribute boolean doingPrintPreview; */
  1: // XXX This always returns PR_FALSE for subdocuments
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetDoingPrintPreview(PRBool *aDoingPrintPreview)
  1: {
  1:   NS_ENSURE_ARG_POINTER(aDoingPrintPreview);
  1: 
  1:   *aDoingPrintPreview = PR_FALSE;
  1:   if (mPrintEngine) {
  1:     return mPrintEngine->GetDoingPrintPreview(aDoingPrintPreview);
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: /* readonly attribute nsIPrintSettings currentPrintSettings; */
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetCurrentPrintSettings(nsIPrintSettings * *aCurrentPrintSettings)
  1: {
  1:   NS_ENSURE_ARG_POINTER(aCurrentPrintSettings);
  1: 
  1:   *aCurrentPrintSettings = nsnull;
  1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
  1: 
  1:   return mPrintEngine->GetCurrentPrintSettings(aCurrentPrintSettings);
  1: }
  1: 
  1: 
  1: /* readonly attribute nsIDOMWindow currentChildDOMWindow; */
  1: NS_IMETHODIMP 
  1: DocumentViewerImpl::GetCurrentChildDOMWindow(nsIDOMWindow * *aCurrentChildDOMWindow)
  1: {
  1:   NS_ENSURE_ARG_POINTER(aCurrentChildDOMWindow);
  1:   *aCurrentChildDOMWindow = nsnull;
  1:   return NS_ERROR_NOT_IMPLEMENTED;
  1: }
  1: 
  1: /* void cancel (); */
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::Cancel()
  1: {
  1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
  1:   return mPrintEngine->Cancelled();
  1: }
  1: 
  1: /* void exitPrintPreview (); */
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::ExitPrintPreview()
  1: {
  1:   if (GetIsPrinting()) return NS_ERROR_FAILURE;
  1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
  1: 
  1:   if (GetIsPrintPreview()) {
  1:     ReturnToGalleyPresentation();
  1:   }
  1:   return NS_OK;
  1: }
  1: 
  1: //----------------------------------------------------------------------------------
  1: // Enumerate all the documents for their titles
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::EnumerateDocumentNames(PRUint32* aCount,
  1:                                            PRUnichar*** aResult)
  1: {
  1: #ifdef NS_PRINTING
  1:   NS_ENSURE_ARG(aCount);
  1:   NS_ENSURE_ARG_POINTER(aResult);
  1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
  1: 
  1:   return mPrintEngine->EnumerateDocumentNames(aCount, aResult);
  1: #else
  1:   return NS_ERROR_FAILURE;
  1: #endif
  1: }
  1: 
  1: /* readonly attribute boolean isFramesetFrameSelected; */
  1: NS_IMETHODIMP 
  1: DocumentViewerImpl::GetIsFramesetFrameSelected(PRBool *aIsFramesetFrameSelected)
  1: {
  1: #ifdef NS_PRINTING
  1:   *aIsFramesetFrameSelected = PR_FALSE;
  1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
  1: 
  1:   return mPrintEngine->GetIsFramesetFrameSelected(aIsFramesetFrameSelected);
  1: #else
  1:   return NS_ERROR_FAILURE;
  1: #endif
  1: }
  1: 
  1: /* readonly attribute long printPreviewNumPages; */
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetPrintPreviewNumPages(PRInt32 *aPrintPreviewNumPages)
  1: {
  1: #ifdef NS_PRINTING
  1:   NS_ENSURE_ARG_POINTER(aPrintPreviewNumPages);
  1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
  1: 
  1:   return mPrintEngine->GetPrintPreviewNumPages(aPrintPreviewNumPages);
  1: #else
  1:   return NS_ERROR_FAILURE;
  1: #endif
  1: }
  1: 
  1: /* readonly attribute boolean isFramesetDocument; */
  1: NS_IMETHODIMP
  1: DocumentViewerImpl::GetIsFramesetDocument(PRBool *aIsFramesetDocument)
  1: {
  1: #ifdef NS_PRINTING
  1:   *aIsFramesetDocument = PR_FALSE;
  1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
  1: 
  1:   return mPrintEngine->GetIsFramesetDocument(aIsFramesetDocument);
  1: #else
  1:   return NS_ERROR_FAILURE;
  1: #endif
  1: }
  1: 
  1: /* readonly attribute boolean isIFrameSelected; */
  1: NS_IMETHODIMP 
  1: DocumentViewerImpl::GetIsIFrameSelected(PRBool *aIsIFrameSelected)
  1: {
  1: #ifdef NS_PRINTING
  1:   *aIsIFrameSelected = PR_FALSE;
  1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
  1: 
  1:   return mPrintEngine->GetIsIFrameSelected(aIsIFrameSelected);
  1: #else
  1:   return NS_ERROR_FAILURE;
  1: #endif
  1: }
  1: 
  1: /* readonly attribute boolean isRangeSelection; */
  1: NS_IMETHODIMP 
  1: DocumentViewerImpl::GetIsRangeSelection(PRBool *aIsRangeSelection)
  1: {
  1: #ifdef NS_PRINTING
  1:   *aIsRangeSelection = PR_FALSE;
  1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
  1: 
  1:   return mPrintEngine->GetIsRangeSelection(aIsRangeSelection);
  1: #else
  1:   return NS_ERROR_FAILURE;
  1: #endif
  1: }
  1: 
  1: //----------------------------------------------------------------------------------
  1: // Printing/Print Preview Helpers
  1: //----------------------------------------------------------------------------------
  1: 
  1: //----------------------------------------------------------------------------------
  1: // Walks the document tree and tells each DocShell whether Printing/PP is happening
  1: void 
  1: DocumentViewerImpl::SetIsPrintingInDocShellTree(nsIDocShellTreeNode* aParentNode, 
  1:                                                 PRBool               aIsPrintingOrPP, 
  1:                                                 PRBool               aStartAtTop)
  1: {
  1:   NS_ASSERTION(aParentNode, "Parent can't be NULL!");
  1: 
  1:   nsCOMPtr<nsIDocShellTreeItem> parentItem(do_QueryInterface(aParentNode));
  1: 
  1:   // find top of "same parent" tree
  1:   if (aStartAtTop) {
  1:     while (parentItem) {
  1:       nsCOMPtr<nsIDocShellTreeItem> parent;
  1:       parentItem->GetSameTypeParent(getter_AddRefs(parent));
  1:       if (!parent) {
  1:         break;
  1:       }
  1:       parentItem = do_QueryInterface(parent);
  1:     }
  1:   }
  1:   NS_ASSERTION(parentItem, "parentItem can't be null");
  1: 
  1:   // Check to see if the DocShell's ContentViewer is printing/PP
  1:   nsCOMPtr<nsIContentViewerContainer> viewerContainer(do_QueryInterface(parentItem));
  1:   if (viewerContainer) {
  1:     viewerContainer->SetIsPrinting(aIsPrintingOrPP);
  1:   }
  1: 
  1:   // Traverse children to see if any of them are printing.
  1:   PRInt32 n;
  1:   aParentNode->GetChildCount(&n);
  1:   for (PRInt32 i=0; i < n; i++) {
  1:     nsCOMPtr<nsIDocShellTreeItem> child;
  1:     aParentNode->GetChildAt(i, getter_AddRefs(child));
  1:     nsCOMPtr<nsIDocShellTreeNode> childAsNode(do_QueryInterface(child));
  1:     NS_ASSERTION(childAsNode, "child isn't nsIDocShellTreeNode");
  1:     if (childAsNode) {
  1:       SetIsPrintingInDocShellTree(childAsNode, aIsPrintingOrPP, PR_FALSE);
  1:     }
  1:   }
  1: 
  1: }
  1: #endif // NS_PRINTING
  1: 
  1: //------------------------------------------------------------
  1: // XXX this always returns PR_FALSE for subdocuments
  1: PRBool
  1: DocumentViewerImpl::GetIsPrinting()
  1: {
  1: #ifdef NS_PRINTING
  1:   if (mPrintEngine) {
  1:     return mPrintEngine->GetIsPrinting();
  1:   }
  1: #endif
  1:   return PR_FALSE; 
  1: }
  1: 
  1: //------------------------------------------------------------
  1: // Notification from the PrintEngine of the current Printing status
  1: void
  1: DocumentViewerImpl::SetIsPrinting(PRBool aIsPrinting)
  1: {
  1: #ifdef NS_PRINTING
  1:   // Set all the docShells in the docshell tree to be printing.
  1:   // that way if anyone of them tries to "navigate" it can't
  1:   if (mContainer) {
  1:     nsCOMPtr<nsIDocShellTreeNode> docShellTreeNode(do_QueryReferent(mContainer));
  1:     NS_ASSERTION(docShellTreeNode, "mContainer has to be a nsIDocShellTreeNode");
  1:     SetIsPrintingInDocShellTree(docShellTreeNode, aIsPrinting, PR_TRUE);
  1:   }
  1: #endif
  1: }
  1: 
  1: //------------------------------------------------------------
  1: // The PrintEngine holds the current value
  1: // this called from inside the DocViewer.
  1: // XXX it always returns PR_FALSE for subdocuments
  1: PRBool
  1: DocumentViewerImpl::GetIsPrintPreview()
  1: {
  1: #ifdef NS_PRINTING
  1:   if (mPrintEngine) {
  1:     return mPrintEngine->GetIsPrintPreview();
  1:   }
  1: #endif
  1:   return PR_FALSE; 
  1: }
  1: 
  1: //------------------------------------------------------------
  1: // Notification from the PrintEngine of the current PP status
  1: void
  1: DocumentViewerImpl::SetIsPrintPreview(PRBool aIsPrintPreview)
  1: {
  1: #ifdef NS_PRINTING
  1:   // Set all the docShells in the docshell tree to be printing.
  1:   // that way if anyone of them tries to "navigate" it can't
  1:   if (mContainer) {
  1:     nsCOMPtr<nsIDocShellTreeNode> docShellTreeNode(do_QueryReferent(mContainer));
  1:     NS_ASSERTION(docShellTreeNode, "mContainer has to be a nsIDocShellTreeNode");
  1:     SetIsPrintingInDocShellTree(docShellTreeNode, aIsPrintPreview, PR_TRUE);
  1:   }
  1: #endif
  1: }
  1: 
  1: //----------------------------------------------------------------------------------
  1: // nsIDocumentViewerPrint IFace
  1: //----------------------------------------------------------------------------------
  1: 
  1: //------------------------------------------------------------
  1: void
  1: DocumentViewerImpl::IncrementDestroyRefCount()
  1: {
  1:   ++mDestroyRefCount;
  1: }
  1: 
  1: //------------------------------------------------------------
  1: 
  1: static void ResetFocusState(nsIDocShell* aDocShell);
  1: 
  1: void
  1: DocumentViewerImpl::ReturnToGalleyPresentation()
  1: {
  1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
  1:   if (!GetIsPrintPreview()) {
  1:     NS_ERROR("Wow, we should never get here!");
  1:     return;
  1:   }
  1: 
  1:   SetIsPrintPreview(PR_FALSE);
  1: 
  1:   mPrintEngine->TurnScriptingOn(PR_TRUE);
  1:   mPrintEngine->Destroy();
  1:   mPrintEngine = nsnull;
  1: 
  1:   mViewManager->EnableRefresh(NS_VMREFRESH_DEFERRED);
  1: 
  1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
  1:   ResetFocusState(docShell);
  1: 
  1:   Show();
  1: 
  1: #endif // NS_PRINTING && NS_PRINT_PREVIEW
  1: }
  1: 
  1: //------------------------------------------------------------
  1: // Reset ESM focus for all descendent doc shells.
  1: static void
  1: ResetFocusState(nsIDocShell* aDocShell)
  1: {
  1:   nsCOMPtr<nsISimpleEnumerator> docShellEnumerator;
  1:   aDocShell->GetDocShellEnumerator(nsIDocShellTreeItem::typeContent,
  1:                                    nsIDocShell::ENUMERATE_FORWARDS,
  1:                                    getter_AddRefs(docShellEnumerator));
  1:   
  1:   nsCOMPtr<nsIDocShell> currentDocShell;
  1:   nsCOMPtr<nsISupports> currentContainer;
  1:   PRBool hasMoreDocShells;
  1:   while (NS_SUCCEEDED(docShellEnumerator->HasMoreElements(&hasMoreDocShells))
  1:          && hasMoreDocShells) {
  1:     docShellEnumerator->GetNext(getter_AddRefs(currentContainer));
  1:     currentDocShell = do_QueryInterface(currentContainer);
  1:     if (!currentDocShell) {
  1:       break;
  1:     }
  1:     nsCOMPtr<nsPresContext> presContext;
  1:     currentDocShell->GetPresContext(getter_AddRefs(presContext));
  1:     nsIEventStateManager* esm =
  1:       presContext ? presContext->EventStateManager() : nsnull;
  1:     if (esm) {
  1:        esm->SetContentState(nsnull, NS_EVENT_STATE_FOCUS);
  1:        esm->SetFocusedContent(nsnull);
  1:     }
  1:   }
  1: }
  1: 
  1: //------------------------------------------------------------
  1: // This called ONLY when printing has completed and the DV
  1: // is being notified that it should get rid of the PrintEngine.
  1: //
  1: // BUT, if we are in Print Preview then we want to ignore the 
  1: // notification (we do not get rid of the PrintEngine)
  1: // 
  1: // One small caveat: 
  1: //   This IS called from two places in this module for cleaning
  1: //   up when an error occurred during the start up printing 
  1: //   and print preview
  1: //
  1: void
  1: DocumentViewerImpl::OnDonePrinting() 
  1: {
  1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
  1:   if (mPrintEngine) {
  1:     if (GetIsPrintPreview()) {
  1:       mPrintEngine->DestroyPrintingData();
  1:     } else {
  1:       mPrintEngine->Destroy();
  1:       mPrintEngine = nsnull;
  1:     }
  1: 
  1:     // We are done printing, now cleanup 
  1:     if (mDeferredWindowClose) {
  1:       mDeferredWindowClose = PR_FALSE;
  1:       nsCOMPtr<nsISupports> container = do_QueryReferent(mContainer);
  1:       nsCOMPtr<nsIDOMWindowInternal> win = do_GetInterface(container);
  1:       if (win)
  1:         win->Close();
  1:     } else if (mClosingWhilePrinting) {
  1:       if (mDocument) {
  1:         mDocument->SetScriptGlobalObject(nsnull);
  1:         mDocument->Destroy();
  1:         mDocument = nsnull;
  1:       }
  1:       mClosingWhilePrinting = PR_FALSE;
  1:       NS_RELEASE_THIS();
  1:     }
  1:   }
  1: #endif // NS_PRINTING && NS_PRINT_PREVIEW
  1: }
  1: 
  1: NS_IMETHODIMP DocumentViewerImpl::SetPageMode(PRBool aPageMode, nsIPrintSettings* aPrintSettings)
  1: {
  1:   // XXX Page mode is only partially working; it's currently used for
  1:   // reftests that require a paginated context
  1:   mIsPageMode = aPageMode;
  1:   // Get the current size of what is being viewed
  1:   nsRect bounds;
  1:   mWindow->GetBounds(bounds);
  1: 
  1:   if (mPresShell) {
  1:     // Break circular reference (or something)
  1:     mPresShell->EndObservingDocument();
  1:     nsCOMPtr<nsISelection> selection;
  1:     nsresult rv = GetDocumentSelection(getter_AddRefs(selection));
  1:     nsCOMPtr<nsISelectionPrivate> selPrivate(do_QueryInterface(selection));
  1:     if (NS_SUCCEEDED(rv) && selPrivate && mSelectionListener)
  1:       selPrivate->RemoveSelectionListener(mSelectionListener);
  1:     mPresShell->Destroy();
  1:   }
  1: 
  1:   if (mPresContext) {
  1:     mPresContext->SetContainer(nsnull);
  1:     mPresContext->SetLinkHandler(nsnull);
  1:   }
  1: 
  1:   mPresShell    = nsnull;
  1:   mPresContext  = nsnull;
  1:   mViewManager  = nsnull;
  1:   mWindow       = nsnull;
  1: 
  1:   NS_ENSURE_STATE(mDocument);
  1:   if (aPageMode)
  1:   {    
  1:     mPresContext =
  1:       new nsPresContext(mDocument, nsPresContext::eContext_PageLayout);
  1:     NS_ENSURE_TRUE(mPresContext, NS_ERROR_OUT_OF_MEMORY);
  1:     mPresContext->SetPaginatedScrolling(PR_TRUE);
  1:     mPresContext->SetPrintSettings(aPrintSettings);
  1:     nsresult rv = mPresContext->Init(mDeviceContext);
  1:     NS_ENSURE_SUCCESS(rv, rv);
  1:   }
  1:   InitInternal(mParentWidget, nsnull, mDeviceContext, bounds, PR_TRUE, PR_FALSE, PR_FALSE);
  1:   mViewManager->EnableRefresh(NS_VMREFRESH_NO_SYNC);
  1: 
  1:   Show();
  1:   return NS_OK;
  1: }
