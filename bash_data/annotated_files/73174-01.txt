    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998-1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /**
    1:  * This file contains implementations of the nsIBinaryInputStream and
    1:  * nsIBinaryOutputStream interfaces.  Together, these interfaces allows reading
    1:  * and writing of primitive data types (integers, floating-point values,
    1:  * booleans, etc.) to a stream in a binary, untagged, fixed-endianness format.
    1:  * This might be used, for example, to implement network protocols or to
    1:  * produce architecture-neutral binary disk files, i.e. ones that can be read
    1:  * and written by both big-endian and little-endian platforms.  Output is
    1:  * written in big-endian order (high-order byte first), as this is traditional
    1:  * network order.
    1:  *
    1:  * @See nsIBinaryInputStream
    1:  * @See nsIBinaryOutputStream
    1:  */
    1: #include <string.h>
    1: #include "nsBinaryStream.h"
    1: #include "nsCRT.h"
    1: #include "nsIStreamBufferAccess.h"
    1: #include "nsMemory.h"
    1: #include "prlong.h"
    1: #include "nsString.h"
 4334: #include "nsISerializable.h"
 4334: #include "nsIClassInfo.h"
 4334: #include "nsComponentManagerUtils.h"
71514: #include "nsIURI.h" // for NS_IURI_IID
    1: 
    1: NS_IMPL_ISUPPORTS3(nsBinaryOutputStream, nsIObjectOutputStream, nsIBinaryOutputStream, nsIOutputStream)
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::Flush() 
    1: { 
    1:     NS_ENSURE_STATE(mOutputStream);
    1:     return mOutputStream->Flush(); 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::Close() 
    1: { 
    1:     NS_ENSURE_STATE(mOutputStream);
    1:     return mOutputStream->Close(); 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::Write(const char *aBuf, PRUint32 aCount, PRUint32 *aActualBytes)
    1: {
    1:     NS_ENSURE_STATE(mOutputStream);
    1:     return mOutputStream->Write(aBuf, aCount, aActualBytes);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteFrom(nsIInputStream *inStr, PRUint32 count, PRUint32 *_retval)
    1: {
    1:     NS_NOTREACHED("WriteFrom");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteSegments(nsReadSegmentFun reader, void * closure, PRUint32 count, PRUint32 *_retval)
    1: {
    1:     NS_NOTREACHED("WriteSegments");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::IsNonBlocking(PRBool *aNonBlocking)
    1: {
    1:     NS_ENSURE_STATE(mOutputStream);
    1:     return mOutputStream->IsNonBlocking(aNonBlocking);
    1: }
    1: 
    1: nsresult
    1: nsBinaryOutputStream::WriteFully(const char *aBuf, PRUint32 aCount)
    1: {
    1:     NS_ENSURE_STATE(mOutputStream);
    1: 
    1:     nsresult rv;
    1:     PRUint32 bytesWritten;
    1: 
    1:     rv = mOutputStream->Write(aBuf, aCount, &bytesWritten);
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (bytesWritten != aCount)
    1:         return NS_ERROR_FAILURE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::SetOutputStream(nsIOutputStream *aOutputStream)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aOutputStream);
    1:     mOutputStream = aOutputStream;
    1:     mBufferAccess = do_QueryInterface(aOutputStream);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteBoolean(PRBool aBoolean)
    1: {
    1:     return Write8(aBoolean);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::Write8(PRUint8 aByte)
    1: {
    1:     return WriteFully((const char*)&aByte, sizeof aByte);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::Write16(PRUint16 a16)
    1: {
    1:     a16 = NS_SWAP16(a16);
    1:     return WriteFully((const char*)&a16, sizeof a16);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::Write32(PRUint32 a32)
    1: {
    1:     a32 = NS_SWAP32(a32);
    1:     return WriteFully((const char*)&a32, sizeof a32);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::Write64(PRUint64 a64)
    1: {
    1:     nsresult rv;
    1:     PRUint32 bytesWritten;
    1: 
    1:     a64 = NS_SWAP64(a64);
 3233:     rv = Write(reinterpret_cast<char*>(&a64), sizeof a64, &bytesWritten);
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (bytesWritten != sizeof a64)
    1:         return NS_ERROR_FAILURE;
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteFloat(float aFloat)
    1: {
    1:     NS_ASSERTION(sizeof(float) == sizeof (PRUint32),
    1:                  "False assumption about sizeof(float)");
 3233:     return Write32(*reinterpret_cast<PRUint32*>(&aFloat));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteDouble(double aDouble)
    1: {
    1:     NS_ASSERTION(sizeof(double) == sizeof(PRUint64),
    1:                  "False assumption about sizeof(double)");
 3233:     return Write64(*reinterpret_cast<PRUint64*>(&aDouble));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteStringZ(const char *aString)
    1: {
    1:     PRUint32 length;
    1:     nsresult rv;
    1: 
    1:     length = strlen(aString);
    1:     rv = Write32(length);
    1:     if (NS_FAILED(rv)) return rv;
    1:     return WriteFully(aString, length);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteWStringZ(const PRUnichar* aString)
    1: {
    1:     PRUint32 length, byteCount;
    1:     nsresult rv;
    1: 
    1:     length = nsCRT::strlen(aString);
    1:     rv = Write32(length);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     if (length == 0)
    1:         return NS_OK;
    1:     byteCount = length * sizeof(PRUnichar);
    1: 
    1: #ifdef IS_BIG_ENDIAN
 3233:     rv = WriteBytes(reinterpret_cast<const char*>(aString), byteCount);
    1: #else
    1:     // XXX use WriteSegments here to avoid copy!
    1:     PRUnichar *copy, temp[64];
    1:     if (length <= 64) {
    1:         copy = temp;
    1:     } else {
 3233:         copy = reinterpret_cast<PRUnichar*>(nsMemory::Alloc(byteCount));
    1:         if (!copy)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     NS_ASSERTION((PRUptrdiff(aString) & 0x1) == 0, "aString not properly aligned");
    1:     for (PRUint32 i = 0; i < length; i++)
    1:         copy[i] = NS_SWAP16(aString[i]);
 3233:     rv = WriteBytes(reinterpret_cast<const char*>(copy), byteCount);
    1:     if (copy != temp)
    1:         nsMemory::Free(copy);
    1: #endif
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteUtf8Z(const PRUnichar* aString)
    1: {
    1:     return WriteStringZ(NS_ConvertUTF16toUTF8(aString).get());
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteBytes(const char *aString, PRUint32 aLength)
    1: {
    1:     nsresult rv;
    1:     PRUint32 bytesWritten;
    1: 
    1:     rv = Write(aString, aLength, &bytesWritten);
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (bytesWritten != aLength)
    1:         return NS_ERROR_FAILURE;
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteByteArray(PRUint8 *aBytes, PRUint32 aLength)
    1: {
 3233:     return WriteBytes(reinterpret_cast<char *>(aBytes), aLength);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteObject(nsISupports* aObject, PRBool aIsStrongRef)
    1: {
 4334:     return WriteCompoundObject(aObject, NS_GET_IID(nsISupports),
 4334:                                aIsStrongRef);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteSingleRefObject(nsISupports* aObject)
    1: {
 4334:     return WriteCompoundObject(aObject, NS_GET_IID(nsISupports),
 4334:                                PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteCompoundObject(nsISupports* aObject,
    1:                                           const nsIID& aIID,
    1:                                           PRBool aIsStrongRef)
    1: {
 4334:     // Can't deal with weak refs
 4334:     NS_ENSURE_TRUE(aIsStrongRef, NS_ERROR_UNEXPECTED);
 4334:     
 4334:     nsCOMPtr<nsIClassInfo> classInfo = do_QueryInterface(aObject);
 4334:     NS_ENSURE_TRUE(classInfo, NS_ERROR_NOT_AVAILABLE);
 4334: 
 4334:     nsCOMPtr<nsISerializable> serializable = do_QueryInterface(aObject);
 4334:     NS_ENSURE_TRUE(serializable, NS_ERROR_NOT_AVAILABLE);
 4334: 
 4334:     nsCID cid;
 4334:     classInfo->GetClassIDNoAlloc(&cid);
 4334: 
 4334:     nsresult rv = WriteID(cid);
 4334:     NS_ENSURE_SUCCESS(rv, rv);
 4334:     
 4334:     rv = WriteID(aIID);
 4334:     NS_ENSURE_SUCCESS(rv, rv);
 4334: 
 4334:     return serializable->Write(this);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryOutputStream::WriteID(const nsIID& aIID)
    1: {
 4334:     nsresult rv = Write32(aIID.m0);
 4334:     NS_ENSURE_SUCCESS(rv, rv);
 4334: 
 4334:     rv = Write16(aIID.m1);
 4334:     NS_ENSURE_SUCCESS(rv, rv);
 4334: 
 4334:     rv = Write16(aIID.m2);
 4334:     NS_ENSURE_SUCCESS(rv, rv);
 4334: 
 4334:     for (int i = 0; i < 8; ++i) {
 4334:         rv = Write8(aIID.m3[i]);
 4334:         NS_ENSURE_SUCCESS(rv, rv);
 4334:     }
 4334: 
 4334:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP_(char*)
    1: nsBinaryOutputStream::GetBuffer(PRUint32 aLength, PRUint32 aAlignMask)
    1: {
    1:     if (mBufferAccess)
    1:         return mBufferAccess->GetBuffer(aLength, aAlignMask);
    1:     return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP_(void)
    1: nsBinaryOutputStream::PutBuffer(char* aBuffer, PRUint32 aLength)
    1: {
    1:     if (mBufferAccess)
    1:         mBufferAccess->PutBuffer(aBuffer, aLength);
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS3(nsBinaryInputStream, nsIObjectInputStream, nsIBinaryInputStream, nsIInputStream)
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::Available(PRUint32* aResult)
    1: {
    1:     NS_ENSURE_STATE(mInputStream);
    1:     return mInputStream->Available(aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::Read(char* aBuffer, PRUint32 aCount, PRUint32 *aNumRead)
    1: {
    1:     NS_ENSURE_STATE(mInputStream);
 3598: 
 3598:     // mInputStream might give us short reads, so deal with that.
 3598:     PRUint32 totalRead = 0;
 3598: 
 3598:     PRUint32 bytesRead;
 3598:     do {
 3598:         nsresult rv = mInputStream->Read(aBuffer, aCount, &bytesRead);
 3598:         if (rv == NS_BASE_STREAM_WOULD_BLOCK && totalRead != 0) {
 3598:             // We already read some data.  Return it.
 3598:             break;
 3598:         }
 3598:         
 3598:         if (NS_FAILED(rv)) {
 3598:             return rv;
 3598:         }
 3598: 
 3598:         totalRead += bytesRead;
 3598:         aBuffer += bytesRead;
 3598:         aCount -= bytesRead;
 3598:     } while (aCount != 0 && bytesRead != 0);
 3598: 
 3598:     *aNumRead = totalRead;
 3598:     
 3598:     return NS_OK;
    1: }
    1: 
    1: 
    1: // when forwarding ReadSegments to mInputStream, we need to make sure
    1: // 'this' is being passed to the writer each time. To do this, we need
    1: // a thunking function which keeps the real input stream around.
    1: 
    1: // the closure wrapper
    1: struct ReadSegmentsClosure {
    1:     nsIInputStream* mRealInputStream;
    1:     void* mRealClosure;
    1:     nsWriteSegmentFun mRealWriter;
 3598:     nsresult mRealResult;
 3598:     PRUint32 mBytesRead;  // to properly implement aToOffset
    1: };
    1: 
    1: // the thunking function
    1: static NS_METHOD
    1: ReadSegmentForwardingThunk(nsIInputStream* aStream,
    1:                            void *aClosure,
    1:                            const char* aFromSegment,
    1:                            PRUint32 aToOffset,
    1:                            PRUint32 aCount,
    1:                            PRUint32 *aWriteCount)
    1: {
    1:     ReadSegmentsClosure* thunkClosure =
 3233:         reinterpret_cast<ReadSegmentsClosure*>(aClosure);
    1: 
 3598:     NS_ASSERTION(NS_SUCCEEDED(thunkClosure->mRealResult),
 3598:                  "How did this get to be a failure status?");
 3598: 
 3598:     thunkClosure->mRealResult =
 3598:         thunkClosure->mRealWriter(thunkClosure->mRealInputStream,
    1:                                   thunkClosure->mRealClosure,
 3598:                                   aFromSegment,
 3598:                                   thunkClosure->mBytesRead + aToOffset,
    1:                                   aCount, aWriteCount);
 3598: 
 3598:     return thunkClosure->mRealResult;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::ReadSegments(nsWriteSegmentFun writer, void * closure, PRUint32 count, PRUint32 *_retval)
    1: {
    1:     NS_ENSURE_STATE(mInputStream);
    1: 
 3598:     ReadSegmentsClosure thunkClosure = { this, closure, writer, NS_OK, 0 };
    1:     
 3598:     // mInputStream might give us short reads, so deal with that.
 3598:     PRUint32 bytesRead;
 3598:     do {
 3598:         nsresult rv = mInputStream->ReadSegments(ReadSegmentForwardingThunk,
 3598:                                                  &thunkClosure,
 3598:                                                  count, &bytesRead);
 3598: 
 3598:         if (rv == NS_BASE_STREAM_WOULD_BLOCK && thunkClosure.mBytesRead != 0) {
 3598:             // We already read some data.  Return it.
 3598:             break;
 3598:         }
 3598:         
 3598:         if (NS_FAILED(rv)) {
 3598:             return rv;
 3598:         }
 3598: 
 3598:         thunkClosure.mBytesRead += bytesRead;
 3598:         count -= bytesRead;
 3598:     } while (count != 0 && bytesRead != 0 &&
 3598:              NS_SUCCEEDED(thunkClosure.mRealResult));
 3598: 
 3598:     *_retval = thunkClosure.mBytesRead;
 3598: 
 3598:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::IsNonBlocking(PRBool *aNonBlocking)
    1: {
    1:     NS_ENSURE_STATE(mInputStream);
    1:     return mInputStream->IsNonBlocking(aNonBlocking);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::Close() 
    1: { 
    1:     NS_ENSURE_STATE(mInputStream);
    1:     return mInputStream->Close(); 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::SetInputStream(nsIInputStream *aInputStream)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aInputStream);
    1:     mInputStream = aInputStream;
    1:     mBufferAccess = do_QueryInterface(aInputStream);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::ReadBoolean(PRBool* aBoolean)
    1: {
    1:     PRUint8 byteResult;
    1:     nsresult rv = Read8(&byteResult);
33303:     if (NS_FAILED(rv)) return rv;
 7059:     *aBoolean = !!byteResult;
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::Read8(PRUint8* aByte)
    1: {
    1:     nsresult rv;
    1:     PRUint32 bytesRead;
    1: 
 3233:     rv = Read(reinterpret_cast<char*>(aByte), sizeof(*aByte), &bytesRead);
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (bytesRead != 1)
    1:         return NS_ERROR_FAILURE;
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::Read16(PRUint16* a16)
    1: {
    1:     nsresult rv;
    1:     PRUint32 bytesRead;
    1: 
 3233:     rv = Read(reinterpret_cast<char*>(a16), sizeof *a16, &bytesRead);
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (bytesRead != sizeof *a16)
    1:         return NS_ERROR_FAILURE;
    1:     *a16 = NS_SWAP16(*a16);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::Read32(PRUint32* a32)
    1: {
    1:     nsresult rv;
    1:     PRUint32 bytesRead;
    1: 
 3233:     rv = Read(reinterpret_cast<char*>(a32), sizeof *a32, &bytesRead);
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (bytesRead != sizeof *a32)
    1:         return NS_ERROR_FAILURE;
    1:     *a32 = NS_SWAP32(*a32);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::Read64(PRUint64* a64)
    1: {
    1:     nsresult rv;
    1:     PRUint32 bytesRead;
    1: 
 3233:     rv = Read(reinterpret_cast<char*>(a64), sizeof *a64, &bytesRead);
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (bytesRead != sizeof *a64)
    1:         return NS_ERROR_FAILURE;
    1:     *a64 = NS_SWAP64(*a64);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::ReadFloat(float* aFloat)
    1: {
    1:     NS_ASSERTION(sizeof(float) == sizeof (PRUint32),
    1:                  "False assumption about sizeof(float)");
 3233:     return Read32(reinterpret_cast<PRUint32*>(aFloat));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::ReadDouble(double* aDouble)
    1: {
    1:     NS_ASSERTION(sizeof(double) == sizeof(PRUint64),
    1:                  "False assumption about sizeof(double)");
 3233:     return Read64(reinterpret_cast<PRUint64*>(aDouble));
    1: }
    1: 
    1: static NS_METHOD
    1: WriteSegmentToCString(nsIInputStream* aStream,
    1:                       void *aClosure,
    1:                       const char* aFromSegment,
    1:                       PRUint32 aToOffset,
    1:                       PRUint32 aCount,
    1:                       PRUint32 *aWriteCount)
    1: {
 3233:     nsACString* outString = static_cast<nsACString*>(aClosure);
    1: 
    1:     outString->Append(aFromSegment, aCount);
    1: 
    1:     *aWriteCount = aCount;
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::ReadCString(nsACString& aString)
    1: {
    1:     nsresult rv;
    1:     PRUint32 length, bytesRead;
    1: 
    1:     rv = Read32(&length);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     aString.Truncate();
    1:     rv = ReadSegments(WriteSegmentToCString, &aString, length, &bytesRead);
    1:     if (NS_FAILED(rv)) return rv;
    1:     
    1:     if (bytesRead != length)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: // sometimes, WriteSegmentToString will be handed an odd-number of
    1: // bytes, which means we only have half of the last PRUnichar
    1: struct WriteStringClosure {
    1:     PRUnichar *mWriteCursor;
    1:     PRPackedBool mHasCarryoverByte;
    1:     char mCarryoverByte;
    1: };
    1: 
    1: // there are a few cases we have to account for here:
    1: // * even length buffer, no carryover - easy, just append
    1: // * odd length buffer, no carryover - the last byte needs to be saved
    1: //                                     for carryover
    1: // * odd length buffer, with carryover - first byte needs to be used
    1: //                              with the carryover byte, and
    1: //                              the rest of the even length
    1: //                              buffer is appended as normal
    1: // * even length buffer, with carryover - the first byte needs to be
    1: //                              used with the previous carryover byte.
    1: //                              this gives you an odd length buffer,
    1: //                              so you have to save the last byte for
    1: //                              the next carryover
    1: 
    1: 
    1: // same version of the above, but with correct casting and endian swapping
    1: static NS_METHOD
    1: WriteSegmentToString(nsIInputStream* aStream,
    1:                      void *aClosure,
    1:                      const char* aFromSegment,
    1:                      PRUint32 aToOffset,
    1:                      PRUint32 aCount,
    1:                      PRUint32 *aWriteCount)
    1: {
    1:     NS_PRECONDITION(aCount > 0, "Why are we being told to write 0 bytes?");
    1:     NS_PRECONDITION(sizeof(PRUnichar) == 2, "We can't handle other sizes!");
    1: 
 3233:     WriteStringClosure* closure = static_cast<WriteStringClosure*>(aClosure);
    1:     PRUnichar *cursor = closure->mWriteCursor;
    1: 
    1:     // we're always going to consume the whole buffer no matter what
    1:     // happens, so take care of that right now.. that allows us to
    1:     // tweak aCount later. Do NOT move this!
    1:     *aWriteCount = aCount;
    1: 
    1:     // if the last Write had an odd-number of bytes read, then 
    1:     if (closure->mHasCarryoverByte) {
    1:         // re-create the two-byte sequence we want to work with
    1:         char bytes[2] = { closure->mCarryoverByte, *aFromSegment };
    1:         *cursor = *(PRUnichar*)bytes;
    1:         // Now the little endianness dance
    1: #ifdef IS_LITTLE_ENDIAN
    1:         *cursor = (PRUnichar) NS_SWAP16(*cursor);
    1: #endif
    1:         ++cursor;
    1:         
    1:         // now skip past the first byte of the buffer.. code from here
    1:         // can assume normal operations, but should not assume aCount
    1:         // is relative to the ORIGINAL buffer
    1:         ++aFromSegment;
    1:         --aCount;
    1: 
    1:         closure->mHasCarryoverByte = PR_FALSE;
    1:     }
    1:     
    1:     // this array is possibly unaligned... be careful how we access it!
    1:     const PRUnichar *unicodeSegment =
 3233:         reinterpret_cast<const PRUnichar*>(aFromSegment);
    1: 
    1:     // calculate number of full characters in segment (aCount could be odd!)
    1:     PRUint32 segmentLength = aCount / sizeof(PRUnichar);
    1: 
    1:     // copy all data into our aligned buffer.  byte swap if necessary.
    1:     memcpy(cursor, unicodeSegment, segmentLength * sizeof(PRUnichar));
    1:     PRUnichar *end = cursor + segmentLength;
    1: #ifdef IS_LITTLE_ENDIAN
    1:     for (; cursor < end; ++cursor)
    1:         *cursor = (PRUnichar) NS_SWAP16(*cursor);
    1: #endif
    1:     closure->mWriteCursor = end;
    1: 
    1:     // remember this is the modifed aCount and aFromSegment,
    1:     // so that will take into account the fact that we might have
    1:     // skipped the first byte in the buffer
    1:     if (aCount % sizeof(PRUnichar) != 0) {
    1:         // we must have had a carryover byte, that we'll need the next
    1:         // time around
    1:         closure->mCarryoverByte = aFromSegment[aCount - 1];
    1:         closure->mHasCarryoverByte = PR_TRUE;
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::ReadString(nsAString& aString)
    1: {
    1:     nsresult rv;
    1:     PRUint32 length, bytesRead;
    1: 
    1:     rv = Read32(&length);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
 8463:     if (length == 0) {
 8463:       aString.Truncate();
 8463:       return NS_OK;
 8463:     }
 8463: 
    1:     // pre-allocate output buffer, and get direct access to buffer...
    1:     if (!EnsureStringLength(aString, length))
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     nsAString::iterator start;
    1:     aString.BeginWriting(start);
    1:     
    1:     WriteStringClosure closure;
    1:     closure.mWriteCursor = start.get();
    1:     closure.mHasCarryoverByte = PR_FALSE;
    1:     
    1:     rv = ReadSegments(WriteSegmentToString, &closure,
    1:                       length*sizeof(PRUnichar), &bytesRead);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     NS_ASSERTION(!closure.mHasCarryoverByte, "some strange stream corruption!");
    1:     
    1:     if (bytesRead != length*sizeof(PRUnichar))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::ReadBytes(PRUint32 aLength, char* *_rval)
    1: {
    1:     nsresult rv;
    1:     PRUint32 bytesRead;
    1:     char* s;
    1: 
 3233:     s = reinterpret_cast<char*>(nsMemory::Alloc(aLength));
    1:     if (!s)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     rv = Read(s, aLength, &bytesRead);
    1:     if (NS_FAILED(rv)) {
    1:         nsMemory::Free(s);
    1:         return rv;
    1:     }
    1:     if (bytesRead != aLength) {
    1:         nsMemory::Free(s);
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     *_rval = s;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::ReadByteArray(PRUint32 aLength, PRUint8* *_rval)
    1: {
 3233:     return ReadBytes(aLength, reinterpret_cast<char **>(_rval));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::ReadObject(PRBool aIsStrongRef, nsISupports* *aObject)
    1: {
 4334:     nsCID cid;
 4334:     nsIID iid;
 4334:     nsresult rv = ReadID(&cid);
 4334:     NS_ENSURE_SUCCESS(rv, rv);
 4334: 
 4334:     rv = ReadID(&iid);
 4334:     NS_ENSURE_SUCCESS(rv, rv);
 4334: 
71514:     // HACK: Intercept old (pre-gecko6) nsIURI IID, and replace with
71514:     // the updated IID, so that we're QI'ing to an actual interface.
71514:     // (As soon as we drop support for upgrading from pre-gecko6, we can
71514:     // remove this chunk.)
71514:     static const nsIID oldURIiid =
71514:         { 0x7a22cc0, 0xce5, 0x11d3,
71514:           { 0x93, 0x31, 0x0, 0x10, 0x4b, 0xa0, 0xfd, 0x40 }};
71514: 
73174:     // hackaround for bug 670542
73174:     static const nsIID oldURIiid2 =
73174:         { 0xd6d04c36, 0x0fa4, 0x4db3,
73174:           { 0xbe, 0x05, 0x4a, 0x18, 0x39, 0x71, 0x03, 0xe2 }};
73174: 
73174:     if (iid.Equals(oldURIiid) ||
73174:         iid.Equals(oldURIiid2)) {
71514:         const nsIID newURIiid = NS_IURI_IID;
71514:         iid = newURIiid;
71514:     }
71514:     // END HACK
71514: 
 4334:     nsCOMPtr<nsISupports> object = do_CreateInstance(cid, &rv);
 4334:     NS_ENSURE_SUCCESS(rv, rv);
 4334: 
 4334:     nsCOMPtr<nsISerializable> serializable = do_QueryInterface(object);
 4334:     NS_ENSURE_TRUE(serializable, NS_ERROR_UNEXPECTED);
 4334: 
 4334:     rv = serializable->Read(this);
 4334:     NS_ENSURE_SUCCESS(rv, rv);    
 4334: 
 4334:     return object->QueryInterface(iid, reinterpret_cast<void**>(aObject));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBinaryInputStream::ReadID(nsID *aResult)
    1: {
 4334:     nsresult rv = Read32(&aResult->m0);
 4334:     NS_ENSURE_SUCCESS(rv, rv);
 4334: 
 4334:     rv = Read16(&aResult->m1);
 4334:     NS_ENSURE_SUCCESS(rv, rv);
 4334: 
 4334:     rv = Read16(&aResult->m2);
 4334:     NS_ENSURE_SUCCESS(rv, rv);
 4334: 
 4334:     for (int i = 0; i < 8; ++i) {
 4334:         rv = Read8(&aResult->m3[i]);
 4334:         NS_ENSURE_SUCCESS(rv, rv);
 4334:     }
 4334: 
 4334:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP_(char*)
    1: nsBinaryInputStream::GetBuffer(PRUint32 aLength, PRUint32 aAlignMask)
    1: {
    1:     if (mBufferAccess)
    1:         return mBufferAccess->GetBuffer(aLength, aAlignMask);
    1:     return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP_(void)
    1: nsBinaryInputStream::PutBuffer(char* aBuffer, PRUint32 aLength)
    1: {
    1:     if (mBufferAccess)
    1:         mBufferAccess->PutBuffer(aBuffer, aLength);
    1: }
