     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: // vim:cindent:ts=2:et:sw=2:
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* base class of all rendering objects */
     1: 
 86054: #include "mozilla/Attributes.h"
 80467: #include "mozilla/Util.h"
 80467: 
     1: #include "nsCOMPtr.h"
     1: #include "nsFrame.h"
     1: #include "nsFrameList.h"
 32107: #include "nsPlaceholderFrame.h"
     1: #include "nsLineLayout.h"
     1: #include "nsIContent.h"
     1: #include "nsContentUtils.h"
     1: #include "nsIAtom.h"
     1: #include "nsString.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsStyleContext.h"
     1: #include "nsIView.h"
     1: #include "nsIViewManager.h"
     1: #include "nsIScrollableFrame.h"
     1: #include "nsPresContext.h"
     1: #include "nsCRT.h"
     1: #include "nsGUIEvent.h"
     1: #include "nsIDOMEvent.h"
 84833: #include "nsAsyncDOMEvent.h"
     1: #include "nsStyleConsts.h"
     1: #include "nsIPresShell.h"
     1: #include "prlog.h"
     1: #include "prprf.h"
     1: #include <stdarg.h>
     1: #include "nsFrameManager.h"
     1: #include "nsCSSRendering.h"
     1: #include "nsLayoutUtils.h"
     1: #ifdef ACCESSIBILITY
     1: #include "nsIAccessible.h"
     1: #endif
     1: 
 70982: #include "nsIDOMNode.h"
     1: #include "nsIEditorDocShell.h"
 68780: #include "nsEventStateManager.h"
     1: #include "nsISelection.h"
     1: #include "nsISelectionPrivate.h"
     1: #include "nsFrameSelection.h"
     1: #include "nsHTMLParts.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsCSSAnonBoxes.h"
     1: #include "nsCSSPseudoElements.h"
     1: #include "nsCSSFrameConstructor.h"
     1: 
107518: #include "nsFrameIterator.h"
     1: #include "nsStyleChangeList.h"
     1: #include "nsIDOMRange.h"
 85101: #include "nsRange.h"
 23533: #include "nsITableLayout.h"    //selection necessity
     1: #include "nsITableCellLayout.h"//  "
     1: #include "nsITextControlFrame.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsIPercentHeightObserver.h"
 23015: #include "nsStyleStructInlines.h"
     1: 
     1: #ifdef IBMBIDI
     1: #include "nsBidiPresUtils.h"
     1: #endif
     1: 
     1: // For triple-click pref
     1: #include "nsIServiceManager.h"
     1: #include "imgIContainer.h"
     1: #include "imgIRequest.h"
     1: #include "nsLayoutCID.h"
     1: #include "nsUnicharUtils.h"
108290: #include "nsError.h"
 86231: #include "nsContainerFrame.h"
     1: #include "nsBoxLayoutState.h"
     1: #include "nsBlockFrame.h"
     1: #include "nsDisplayList.h"
 35581: #include "nsIObjectLoadingContent.h"
 47753: #include "nsExpirationTracker.h"
 19125: #include "nsSVGIntegrationUtils.h"
 19948: #include "nsSVGEffects.h"
 72242: #include "nsChangeHint.h"
 80910: #include "nsDeckFrame.h"
 95533: #include "nsTableFrame.h"
 19125: 
     1: #include "gfxContext.h"
 93575: #include "nsRenderingContext.h"
 51776: #include "CSSCalc.h"
 79482: #include "nsAbsoluteContainingBlock.h"
 95534: #include "nsFontInflationData.h"
107003: #include "nsAnimationManager.h"
107005: #include "nsTransitionManager.h"
  5235: 
 70840: #include "mozilla/Preferences.h"
 78130: #include "mozilla/LookAndFeel.h"
108323: #include "mozilla/css/ImageLoader.h"
 70840: 
 39965: using namespace mozilla;
 64542: using namespace mozilla::layers;
 88122: using namespace mozilla::layout;
108323: using namespace mozilla::css;
 39965: 
     1: // Struct containing cached metrics for box-wrapped frames.
     1: struct nsBoxLayoutMetrics
     1: {
     1:   nsSize mPrefSize;
     1:   nsSize mMinSize;
     1:   nsSize mMaxSize;
     1: 
     1:   nsSize mBlockMinSize;
     1:   nsSize mBlockPrefSize;
     1:   nscoord mBlockAscent;
     1: 
     1:   nscoord mFlex;
     1:   nscoord mAscent;
     1: 
     1:   nsSize mLastSize;
     1: };
     1: 
     1: struct nsContentAndOffset
     1: {
     1:   nsIContent* mContent;
108991:   int32_t mOffset;
     1: };
     1: 
     1: // Some Misc #defines
     1: #define SELECTION_DEBUG        0
     1: #define FORCE_SELECTION_UPDATE 1
     1: #define CALC_DEBUG             0
     1: 
     1: 
     1: #include "nsILineIterator.h"
     1: 
     1: //non Hack prototypes
     1: #if 0
     1: static void RefreshContentFrames(nsPresContext* aPresContext, nsIContent * aStartContent, nsIContent * aEndContent);
     1: #endif
     1: 
     1: #include "prenv.h"
     1: 
 31709: // Formerly the nsIFrameDebug interface
     1: 
102909: #ifdef DEBUG
 79445: static bool gShowFrameBorders = false;
 79445: 
 79445: void nsFrame::ShowFrameBorders(bool aEnable)
     1: {
     1:   gShowFrameBorders = aEnable;
     1: }
     1: 
 79445: bool nsFrame::GetShowFrameBorders()
     1: {
     1:   return gShowFrameBorders;
     1: }
     1: 
 79445: static bool gShowEventTargetFrameBorder = false;
 79445: 
 79445: void nsFrame::ShowEventTargetFrameBorder(bool aEnable)
     1: {
     1:   gShowEventTargetFrameBorder = aEnable;
     1: }
     1: 
 79445: bool nsFrame::GetShowEventTargetFrameBorder()
     1: {
     1:   return gShowEventTargetFrameBorder;
     1: }
     1: 
     1: /**
     1:  * Note: the log module is created during library initialization which
     1:  * means that you cannot perform logging before then.
     1:  */
     1: static PRLogModuleInfo* gLogModule;
     1: 
     1: static PRLogModuleInfo* gStyleVerifyTreeLogModuleInfo;
     1: 
108991: static uint32_t gStyleVerifyTreeEnable = 0x55;
     1: 
 79445: bool
 31709: nsFrame::GetVerifyStyleTreeEnable()
     1: {
 74671:   if (gStyleVerifyTreeEnable == 0x55) {
106838:     if (nullptr == gStyleVerifyTreeLogModuleInfo) {
     1:       gStyleVerifyTreeLogModuleInfo = PR_NewLogModule("styleverifytree");
     1:       gStyleVerifyTreeEnable = 0 != gStyleVerifyTreeLogModuleInfo->level;
     1:     }
     1:   }
     1:   return gStyleVerifyTreeEnable;
     1: }
     1: 
     1: void
 79445: nsFrame::SetVerifyStyleTreeEnable(bool aEnabled)
     1: {
     1:   gStyleVerifyTreeEnable = aEnabled;
     1: }
     1: 
     1: PRLogModuleInfo*
 31709: nsFrame::GetLogModuleInfo()
     1: {
106838:   if (nullptr == gLogModule) {
     1:     gLogModule = PR_NewLogModule("frame");
     1:   }
     1:   return gLogModule;
     1: }
     1: 
     1: void
 31709: nsFrame::DumpFrameTree(nsIFrame* aFrame)
     1: {
   238:     RootFrameList(aFrame->PresContext(), stdout, 0);
     1: }
     1: 
     1: void
108991: nsFrame::RootFrameList(nsPresContext* aPresContext, FILE* out, int32_t aIndent)
 31709: {
 31709:   if (!aPresContext || !out)
     1:     return;
     1: 
     1:   nsIPresShell *shell = aPresContext->GetPresShell();
 31709:   if (shell) {
     1:     nsIFrame* frame = shell->FrameManager()->GetRootFrame();
 31709:     if(frame) {
 31709:       frame->List(out, aIndent);
     1:     }
     1:   }
     1: }
     1: #endif
     1: 
 79482: static void
 79482: DestroyAbsoluteContainingBlock(void* aPropertyValue)
 79482: {
 79482:   delete static_cast<nsAbsoluteContainingBlock*>(aPropertyValue);
 79482: }
 79482: 
 79482: NS_DECLARE_FRAME_PROPERTY(AbsoluteContainingBlockProperty, DestroyAbsoluteContainingBlock)
 79482: 
 79482: bool
 79482: nsIFrame::HasAbsolutelyPositionedChildren() const {
 79482:   return IsAbsoluteContainer() && GetAbsoluteContainingBlock()->HasAbsoluteFrames();
 79482: }
 79482: 
 79482: nsAbsoluteContainingBlock*
 79482: nsIFrame::GetAbsoluteContainingBlock() const {
 79482:   NS_ASSERTION(IsAbsoluteContainer(), "The frame is not marked as an abspos container correctly");
 79482:   nsAbsoluteContainingBlock* absCB = static_cast<nsAbsoluteContainingBlock*>
 79482:     (Properties().Get(AbsoluteContainingBlockProperty()));
 79482:   NS_ASSERTION(absCB, "The frame is marked as an abspos container but doesn't have the property");
 79482:   return absCB;
 79482: }
 79482: 
 79482: void
 79482: nsIFrame::MarkAsAbsoluteContainingBlock() {
 79482:   AddStateBits(NS_FRAME_HAS_ABSPOS_CHILDREN);
 79482:   Properties().Set(AbsoluteContainingBlockProperty(), new nsAbsoluteContainingBlock(GetAbsoluteListID()));
 79482: }
 79482: 
106096: void
106096: nsIFrame::ClearDisplayItemCache()
106096: {
106096:   if (GetStateBits() & NS_FRAME_HAS_CACHED_BACKGROUND) {
106096:     Properties().Delete(CachedBackgroundImage());
106096:     RemoveStateBits(NS_FRAME_HAS_CACHED_BACKGROUND);
106096:   }
106096: }
106096: 
 80875: bool
 80875: nsIFrame::CheckAndClearPaintedState()
 80875: {
 80875:   bool result = (GetStateBits() & NS_FRAME_PAINTED_THEBES);
 80875:   RemoveStateBits(NS_FRAME_PAINTED_THEBES);
 80875:   
 80875:   nsIFrame::ChildListIterator lists(this);
 80875:   for (; !lists.IsDone(); lists.Next()) {
 80875:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 80875:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 80875:       nsIFrame* child = childFrames.get();
 80875:       if (child->CheckAndClearPaintedState()) {
 80875:         result = true;
 80875:       }
 80875:     }
 80875:   }
 80875:   return result;
 80875: }
 80875: 
 80910: bool
108991: nsIFrame::IsVisibleConsideringAncestors(uint32_t aFlags) const
 80910: {
 80910:   if (!GetStyleVisibility()->IsVisible()) {
 80910:     return false;
 80910:   }
 80910: 
 80910:   const nsIFrame* frame = this;
 80910:   while (frame) {
 80910:     nsIView* view = frame->GetView();
 80910:     if (view && view->GetVisibility() == nsViewVisibility_kHide)
 80910:       return false;
 80910:     
 80910:     nsIFrame* parent = frame->GetParent();
 80910:     nsDeckFrame* deck = do_QueryFrame(parent);
 80910:     if (deck) {
 80910:       if (deck->GetSelectedBox() != frame)
 80910:         return false;
 80910:     }
 80910: 
 80910:     if (parent) {
 80910:       frame = parent;
 80910:     } else {
 80910:       parent = nsLayoutUtils::GetCrossDocParentFrame(frame);
 80910:       if (!parent)
 80910:         break;
 80910: 
 80910:       if ((aFlags & nsIFrame::VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY) == 0 &&
 80910:           parent->PresContext()->IsChrome() && !frame->PresContext()->IsChrome()) {
 80910:         break;
 80910:       }
 80910: 
 80910:       if (!parent->GetStyleVisibility()->IsVisible())
 80910:         return false;
 80910: 
 80910:       frame = parent;
 80910:     }
 80910:   }
 80910: 
 80910:   return true;
 80910: }
 80910: 
 79445: static bool ApplyOverflowClipping(nsDisplayListBuilder* aBuilder,
 77286:                                     const nsIFrame* aFrame,
 77286:                                     const nsStyleDisplay* aDisp, 
 77286:                                     nsRect* aRect);
 77286: 
 91411: static bool ApplyClipPropClipping(nsDisplayListBuilder* aBuilder,
 77286:                                   const nsStyleDisplay* aDisp, 
 77286:                                   const nsIFrame* aFrame,
 77286:                                   nsRect* aRect);
 77286: 
     1: void
 15183: NS_MergeReflowStatusInto(nsReflowStatus* aPrimary, nsReflowStatus aSecondary)
 15183: {
 15183:   *aPrimary |= aSecondary &
 15183:     (NS_FRAME_NOT_COMPLETE | NS_FRAME_OVERFLOW_INCOMPLETE |
 15183:      NS_FRAME_TRUNCATED | NS_FRAME_REFLOW_NEXTINFLOW);
 15183:   if (*aPrimary & NS_FRAME_NOT_COMPLETE) {
 15183:     *aPrimary &= ~NS_FRAME_OVERFLOW_INCOMPLETE;
 15183:   }
 15183: }
 15183: 
 15183: void
 34904: nsWeakFrame::InitInternal(nsIFrame* aFrame)
     1: {
106838:   Clear(mFrame ? mFrame->PresContext()->GetPresShell() : nullptr);
     1:   mFrame = aFrame;
     1:   if (mFrame) {
   238:     nsIPresShell* shell = mFrame->PresContext()->GetPresShell();
     1:     NS_WARN_IF_FALSE(shell, "Null PresShell in nsWeakFrame!");
     1:     if (shell) {
     1:       shell->AddWeakFrame(this);
     1:     } else {
106838:       mFrame = nullptr;
     1:     }
     1:   }
     1: }
     1: 
     1: nsIFrame*
     1: NS_NewEmptyFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsFrame(aContext);
     1: }
     1: 
     1: nsFrame::nsFrame(nsStyleContext* aContext)
     1: {
     1:   MOZ_COUNT_CTOR(nsFrame);
     1: 
     1:   mState = NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY;
     1:   mStyleContext = aContext;
     1:   mStyleContext->AddRef();
     1: }
     1: 
     1: nsFrame::~nsFrame()
     1: {
     1:   MOZ_COUNT_DTOR(nsFrame);
     1: 
     1:   NS_IF_RELEASE(mContent);
     1:   if (mStyleContext)
     1:     mStyleContext->Release();
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsFrame)
 32423: 
 32423: // Dummy operator delete.  Will never be called, but must be defined
 32423: // to satisfy some C++ ABIs.
 32423: void
 32423: nsFrame::operator delete(void *, size_t)
 32423: {
 32423:   NS_RUNTIMEABORT("nsFrame::operator delete should never be called");
 32423: }
 32423: 
 23554: NS_QUERYFRAME_HEAD(nsFrame)
 23554:   NS_QUERYFRAME_ENTRY(nsIFrame)
 32423: NS_QUERYFRAME_TAIL_INHERITANCE_ROOT
     1: 
     1: /////////////////////////////////////////////////////////////////////////////
     1: // nsIFrame
     1: 
 88118: static bool
 88118: IsFontSizeInflationContainer(nsIFrame* aFrame,
 88118:                              const nsStyleDisplay* aStyleDisplay)
 88118: {
 88118:   /*
 88118:    * Font size inflation is built around the idea that we're inflating
 88118:    * the fonts for a pan-and-zoom UI so that when the user scales up a
 88118:    * block or other container to fill the width of the device, the fonts
 88118:    * will be readable.  To do this, we need to pick what counts as a
 88118:    * container.
 88118:    *
 88118:    * From a code perspective, the only hard requirement is that frames
 88118:    * that are line participants
 88118:    * (nsIFrame::IsFrameOfType(nsIFrame::eLineParticipant)) are never
 88118:    * containers, since line layout assumes that the inflation is
 88118:    * consistent within a line.
 88118:    *
 88118:    * This is not an imposition, since we obviously want a bunch of text
 88118:    * (possibly with inline elements) flowing within a block to count the
 88118:    * block (or higher) as its container.
 88118:    *
 88118:    * We also want form controls, including the text in the anonymous
 88118:    * content inside of them, to match each other and the text next to
 88118:    * them, so they and their anonymous content should also not be a
 88118:    * container.
 88118:    *
 88118:    * However, because we can't reliably compute sizes across XUL during
 88118:    * reflow, any XUL frame with a XUL parent is always a container.
 88118:    *
 88118:    * There are contexts where it would be nice if some blocks didn't
 88118:    * count as a container, so that, for example, an indented quotation
 88118:    * didn't end up with a smaller font size.  However, it's hard to
 88118:    * distinguish these situations where we really do want the indented
 88118:    * thing to count as a container, so we don't try, and blocks are
 88118:    * always containers.
 88118:    */
 97702: 
 97702:   // The root frame should always be an inflation container.
 97702:   if (!aFrame->GetParent()) {
 97702:     return true;
 97702:   }
 97702: 
 88127:   nsIContent *content = aFrame->GetContent();
107226:   bool isInline = (aFrame->GetDisplay() == NS_STYLE_DISPLAY_INLINE ||
107224:                    (aFrame->IsFloating() &&
 88121:                     aFrame->GetType() == nsGkAtoms::letterFrame) ||
 88127:                    // Given multiple frames for the same node, only the
 88127:                    // outer one should be considered a container.
 88127:                    // (Important, e.g., for nsSelectsAreaFrame.)
 97702:                    (aFrame->GetParent()->GetContent() == content) ||
 88127:                    (content && (content->IsHTML(nsGkAtoms::option) ||
 88127:                                 content->IsHTML(nsGkAtoms::optgroup) ||
111451:                                 content->IsHTML(nsGkAtoms::select) ||
 88127:                                 content->IsInNativeAnonymousSubtree()))) &&
 97702:                   !(aFrame->IsBoxFrame() && aFrame->GetParent()->IsBoxFrame());
 88118:   NS_ASSERTION(!aFrame->IsFrameOfType(nsIFrame::eLineParticipant) ||
 88118:                isInline ||
 88118:                // br frames and mathml frames report being line
 88118:                // participants even when their position or display is
 88118:                // set
 88118:                aFrame->GetType() == nsGkAtoms::brFrame ||
 88118:                aFrame->IsFrameOfType(nsIFrame::eMathML),
 88118:                "line participants must not be containers");
 88118:   NS_ASSERTION(aFrame->GetType() != nsGkAtoms::bulletFrame || isInline,
 88118:                "bullets should not be containers");
 88118:   return !isInline;
 88118: }
 88118: 
     1: NS_IMETHODIMP
     1: nsFrame::Init(nsIContent*      aContent,
     1:               nsIFrame*        aParent,
     1:               nsIFrame*        aPrevInFlow)
     1: {
  6219:   NS_PRECONDITION(!mContent, "Double-initing a frame?");
     1:   NS_ASSERTION(IsFrameOfType(eDEBUGAllFrames) &&
     1:                !IsFrameOfType(eDEBUGNoFrames),
     1:                "IsFrameOfType implementation that doesn't call base class");
     1: 
     1:   mContent = aContent;
     1:   mParent = aParent;
     1: 
     1:   if (aContent) {
     1:     NS_ADDREF(aContent);
     1:   }
     1: 
     1:   if (aPrevInFlow) {
     1:     // Make sure the general flags bits are the same
     1:     nsFrameState state = aPrevInFlow->GetStateBits();
     1: 
     1:     // Make bits that are currently off (see constructor) the same:
 85101:     mState |= state & (NS_FRAME_INDEPENDENT_SELECTION |
 19948:                        NS_FRAME_IS_SPECIAL |
 99736:                        NS_FRAME_MAY_BE_TRANSFORMED |
 99736:                        NS_FRAME_MAY_HAVE_GENERATED_CONTENT);
     1:   }
     1:   if (mParent) {
     1:     nsFrameState state = mParent->GetStateBits();
     1: 
     1:     // Make bits that are currently off (see constructor) the same:
     1:     mState |= state & (NS_FRAME_INDEPENDENT_SELECTION |
107214:                        NS_FRAME_GENERATED_CONTENT |
107214:                        NS_FRAME_IS_SVG_TEXT);
     1:   }
 88118:   const nsStyleDisplay *disp = GetStyleDisplay();
 88118:   if (disp->HasTransform()) {
 19214:     // The frame gets reconstructed if we toggle the -moz-transform
 19214:     // property, so we can set this bit here and then ignore it.
 50423:     mState |= NS_FRAME_MAY_BE_TRANSFORMED;
 19214:   }
 19214: 
102448:   if (nsLayoutUtils::FontSizeInflationEnabled(PresContext()) || !GetParent()
 88118: #ifdef DEBUG
 88118:       // We have assertions that check inflation invariants even when
 88118:       // font size inflation is not enabled.
 88118:       || true
 88118: #endif
 88118:       ) {
 88118:     if (IsFontSizeInflationContainer(this, disp)) {
 95533:       AddStateBits(NS_FRAME_FONT_INFLATION_CONTAINER);
 95533:       if (!GetParent() ||
 95533:           // I'd use NS_FRAME_OUT_OF_FLOW, but it's not set yet.
107225:           disp->IsFloating(this) || disp->IsAbsolutelyPositioned(this)) {
 95533:         AddStateBits(NS_FRAME_FONT_INFLATION_FLOW_ROOT);
 95533:       }
 95533:     }
 95533:     NS_ASSERTION(GetParent() ||
 95533:                  (GetStateBits() & NS_FRAME_FONT_INFLATION_CONTAINER),
 95533:                  "root frame should always be a container");
 88118:   }
 88118: 
106838:   DidSetStyleContext(nullptr);
     1: 
     1:   if (IsBoxWrapped())
 80486:     InitBoxMetrics(false);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 77154: NS_IMETHODIMP nsFrame::SetInitialChildList(ChildListID     aListID,
 30790:                                            nsFrameList&    aChildList)
     1: {
     1:   // XXX This shouldn't be getting called at all, but currently is for backwards
     1:   // compatility reasons...
     1: #if 0
     1:   NS_ERROR("not a container");
     1:   return NS_ERROR_UNEXPECTED;
     1: #else
 30790:   NS_ASSERTION(aChildList.IsEmpty(), "not a container");
     1:   return NS_OK;
     1: #endif
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsFrame::AppendFrames(ChildListID     aListID,
 30941:                       nsFrameList&    aFrameList)
     1: {
 80486:   NS_PRECONDITION(false, "not a container");
     1:   return NS_ERROR_UNEXPECTED;
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsFrame::InsertFrames(ChildListID     aListID,
     1:                       nsIFrame*       aPrevFrame,
 30941:                       nsFrameList&    aFrameList)
     1: {
 80486:   NS_PRECONDITION(false, "not a container");
     1:   return NS_ERROR_UNEXPECTED;
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsFrame::RemoveFrame(ChildListID     aListID,
     1:                      nsIFrame*       aOldFrame)
     1: {
 80486:   NS_PRECONDITION(false, "not a container");
     1:   return NS_ERROR_UNEXPECTED;
     1: }
     1: 
     1: void
 36647: nsFrame::DestroyFrom(nsIFrame* aDestructRoot)
     1: {
 28371:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
 28371:     "destroy called on frame while scripts not blocked");
 36646:   NS_ASSERTION(!GetNextSibling() && !GetPrevSibling(),
 36646:                "Frames should be removed before destruction.");
 36647:   NS_ASSERTION(aDestructRoot, "Must specify destruct root");
 28371: 
 19948:   nsSVGEffects::InvalidateDirectRenderingObservers(this);
 19948: 
     1:   // Get the view pointer now before the frame properties disappear
     1:   // when we call NotifyDestroyingFrame()
     1:   nsIView* view = GetView();
   238:   nsPresContext* presContext = PresContext();
     1: 
     1:   nsIPresShell *shell = presContext->GetPresShell();
 28300:   if (mState & NS_FRAME_OUT_OF_FLOW) {
 28300:     nsPlaceholderFrame* placeholder =
 28300:       shell->FrameManager()->GetPlaceholderFrameFor(this);
 36647:     NS_ASSERTION(!placeholder || (aDestructRoot != this),
 36647:                  "Don't call Destroy() on OOFs, call Destroy() on the placeholder.");
 36647:     NS_ASSERTION(!placeholder ||
 36647:                  nsLayoutUtils::IsProperAncestorFrame(aDestructRoot, placeholder),
 36647:                  "Placeholder relationship should have been torn down already; "
 36647:                  "this might mean we have a stray placeholder in the tree.");
 28300:     if (placeholder) {
 28300:       shell->FrameManager()->UnregisterPlaceholderFrame(placeholder);
106838:       placeholder->SetOutOfFlowFrame(nullptr);
 28300:     }
 28300:   }
     1: 
 77680:   // If we have any IB split special siblings, clear their references to us.
 77200:   // (Note: This has to happen before we call shell->NotifyDestroyingFrame,
 77200:   // because that clears our Properties() table.)
 77200:   if (mState & NS_FRAME_IS_SPECIAL) {
 77680:     // Delete previous sibling's reference to me.
 77680:     nsIFrame* prevSib = static_cast<nsIFrame*>
 77680:       (Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
 77680:     if (prevSib) {
 77680:       NS_WARN_IF_FALSE(this ==
 77680:          prevSib->Properties().Get(nsIFrame::IBSplitSpecialSibling()),
 77680:          "IB sibling chain is inconsistent");
 77680:       prevSib->Properties().Delete(nsIFrame::IBSplitSpecialSibling());
 77680:     }
 77680: 
 77680:     // Delete next sibling's reference to me.
 77200:     nsIFrame* nextSib = static_cast<nsIFrame*>
 77200:       (Properties().Get(nsIFrame::IBSplitSpecialSibling()));
 77200:     if (nextSib) {
 77200:       NS_WARN_IF_FALSE(this ==
 77200:          nextSib->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()),
 77680:          "IB sibling chain is inconsistent");
 77200:       nextSib->Properties().Delete(nsIFrame::IBSplitSpecialPrevSibling());
 77200:     }
 77200:   }
 77200: 
     1:   shell->NotifyDestroyingFrame(this);
     1: 
 85101:   if (mState & NS_FRAME_EXTERNAL_REFERENCE) {
     1:     shell->ClearFrameRefs(this);
     1:   }
     1: 
     1:   if (view) {
     1:     // Break association between view and frame
106838:     view->SetFrame(nullptr);
     1: 
     1:     // Destroy the view
     1:     view->Destroy();
     1:   }
     1: 
 36653:   // Make sure that our deleted frame can't be returned from GetPrimaryFrame()
 36653:   if (mContent && mContent->GetPrimaryFrame() == this) {
106838:     mContent->SetPrimaryFrame(nullptr);
 36653:   }
 36653: 
 32511:   // Must retrieve the object ID before calling destructors, so the
 32423:   // vtable is still valid.
 32423:   //
 32423:   // Note to future tweakers: having the method that returns the
 32423:   // object size call the destructor will not avoid an indirect call;
 32423:   // the compiler cannot devirtualize the call to the destructor even
 32423:   // if it's from a method defined in the same class.
 32423: 
 32511:   nsQueryFrame::FrameIID id = GetFrameId();
 32423:   this->~nsFrame();
 32423: 
 32423:   // Now that we're totally cleaned out, we need to add ourselves to
 32423:   // the presshell's recycler.
 32511:   shell->FreeFrame(id, this);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsFrame::GetOffsets(int32_t &aStart, int32_t &aEnd) const
     1: {
     1:   aStart = 0;
     1:   aEnd = 0;
     1:   return NS_OK;
     1: }
     1: 
 79445: static bool
 25231: EqualImages(imgIRequest *aOldImage, imgIRequest *aNewImage)
 25231: {
 25231:   if (aOldImage == aNewImage)
 80486:     return true;
 25231: 
 25231:   if (!aOldImage || !aNewImage)
 80486:     return false;
 25231: 
 25231:   nsCOMPtr<nsIURI> oldURI, newURI;
 25231:   aOldImage->GetURI(getter_AddRefs(oldURI));
 25231:   aNewImage->GetURI(getter_AddRefs(newURI));
 79445:   bool equal;
 25231:   return NS_SUCCEEDED(oldURI->Equals(newURI, &equal)) && equal;
 25231: }
 25231: 
     1: // Subclass hook for style post processing
 20441: /* virtual */ void
 20836: nsFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 20324: {
108323:   ImageLoader* imageLoader = PresContext()->Document()->StyleImageLoader();
108323: 
 25231:   // If the old context had a background image image and new context
 25231:   // does not have the same image, clear the image load notifier
 25231:   // (which keeps the image loading, if it still is) for the frame.
 25231:   // We want to do this conservatively because some frames paint their
 25231:   // backgrounds from some other frame's style data, and we don't want
 25231:   // to clear those notifiers unless we have to.  (They'll be reset
 25231:   // when we paint, although we could miss a notification in that
 25231:   // interval.)
108323:   const nsStyleBackground *oldBG = aOldStyleContext ?
108323:                                    aOldStyleContext->GetStyleBackground() :
108323:                                    nullptr;
 25276:   const nsStyleBackground *newBG = GetStyleBackground();
108323:   if (oldBG) {
 25276:     NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, oldBG) {
108323:       // If there is an image in oldBG that's not in newBG, drop it.
 30993:       if (i >= newBG->mImageCount ||
 30993:           oldBG->mLayers[i].mImage != newBG->mLayers[i].mImage) {
108323:         const nsStyleImage& oldImage = oldBG->mLayers[i].mImage;
108323:         if (oldImage.GetType() != eStyleImageType_Image) {
108323:           continue;
108323:         }
108323: 
108323:         imageLoader->DisassociateRequestFromFrame(oldImage.GetImageData(),
108323:                                                   this);
108323:       }          
108323:     }
108323:   }
108323: 
108323:   NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, newBG) {
108323:     // If there is an image in newBG that's not in oldBG, add it.
108323:     if (!oldBG || i >= oldBG->mImageCount ||
108323:         newBG->mLayers[i].mImage != oldBG->mLayers[i].mImage) {
108323:       const nsStyleImage& newImage = newBG->mLayers[i].mImage;
108323:       if (newImage.GetType() != eStyleImageType_Image) {
108323:         continue;
108323:       }
108323: 
108323:       imageLoader->AssociateRequestToFrame(newImage.GetImageData(), this);
108323:     }          
108323:   }
108323: 
108323:   if (aOldStyleContext) {
 38828:     // If we detect a change on margin, padding or border, we store the old
 38828:     // values on the frame itself between now and reflow, so if someone
 38828:     // calls GetUsed(Margin|Border|Padding)() before the next reflow, we
 38828:     // can give an accurate answer.
 38828:     // We don't want to set the property if one already exists.
 39965:     FrameProperties props = Properties();
 38828:     nsMargin oldValue(0, 0, 0, 0);
 38828:     nsMargin newValue(0, 0, 0, 0);
 38863:     const nsStyleMargin* oldMargin = aOldStyleContext->PeekStyleMargin();
 38828:     if (oldMargin && oldMargin->GetMargin(oldValue)) {
 38828:       if ((!GetStyleMargin()->GetMargin(newValue) || oldValue != newValue) &&
 39965:           !props.Get(UsedMarginProperty())) {
 39965:         props.Set(UsedMarginProperty(), new nsMargin(oldValue));
 38828:       }
 38828:     }
 38828: 
 38863:     const nsStylePadding* oldPadding = aOldStyleContext->PeekStylePadding();
 38828:     if (oldPadding && oldPadding->GetPadding(oldValue)) {
 38828:       if ((!GetStylePadding()->GetPadding(newValue) || oldValue != newValue) &&
 39965:           !props.Get(UsedPaddingProperty())) {
 39965:         props.Set(UsedPaddingProperty(), new nsMargin(oldValue));
 38828:       }
 38828:     }
 38828: 
 38863:     const nsStyleBorder* oldBorder = aOldStyleContext->PeekStyleBorder();
 38828:     if (oldBorder) {
 99855:       oldValue = oldBorder->GetComputedBorder();
 99855:       newValue = GetStyleBorder()->GetComputedBorder();
 38828:       if (oldValue != newValue &&
 39965:           !props.Get(UsedBorderProperty())) {
 39965:         props.Set(UsedBorderProperty(), new nsMargin(oldValue));
 38828:       }
 38828:     }
 25231:   }
 25231: 
 25231:   imgIRequest *oldBorderImage = aOldStyleContext
 25231:     ? aOldStyleContext->GetStyleBorder()->GetBorderImage()
106838:     : nullptr;
108323:   imgIRequest *newBorderImage = GetStyleBorder()->GetBorderImage();
 99855:   // FIXME (Bug 759996): The following is no longer true.
 25231:   // For border-images, we can't be as conservative (we need to set the
 25231:   // new loaders if there has been any change) since the CalcDifference
 99855:   // call depended on the result of GetComputedBorder() and that result
 25231:   // depends on whether the image has loaded, start the image load now
 25231:   // so that we'll get notified when it completes loading and can do a
 25231:   // restyle.  Otherwise, the image might finish loading from the
 25231:   // network before we start listening to its notifications, and then
 25231:   // we'll never know that it's finished loading.  Likewise, we want to
 25231:   // do this for freshly-created frames to prevent a similar race if the
 25231:   // image loads between reflow (which can depend on whether the image
 25231:   // is loaded) and paint.  We also don't really care about any callers
 25231:   // who try to paint borders with a different style context, because
 25231:   // they won't have the correct size for the border either.
108323:   if (!EqualImages(oldBorderImage, newBorderImage)) {
 25231:     // stop and restart the image loading/notification
108323:     if (oldBorderImage) {
108323:       imageLoader->DisassociateRequestFromFrame(oldBorderImage, this);
108323:     }
108323:     if (newBorderImage) {
108323:       imageLoader->AssociateRequestToFrame(newBorderImage, this);
108323:     }
 23015:   }
 27659: 
 27659:   // If the page contains markup that overrides text direction, and
 27659:   // does not contain any characters that would activate the Unicode
 27659:   // bidi algorithm, we need to call |SetBidiEnabled| on the pres
 27659:   // context before reflow starts.  See bug 115921.
 27659:   if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
 27659:     PresContext()->SetBidiEnabled();
 27659:   }
     1: }
     1: 
 77152: // MSVC fails with link error "one or more multiply defined symbols found",
 77152: // gcc fails with "hidden symbol `nsIFrame::kPrincipalList' isn't defined"
 77152: // etc if they are not defined.
 77152: #ifndef _MSC_VER
 77152: // static nsIFrame constants; initialized in the header file.
 77152: const nsIFrame::ChildListID nsIFrame::kPrincipalList;
 77152: const nsIFrame::ChildListID nsIFrame::kAbsoluteList;
 77152: const nsIFrame::ChildListID nsIFrame::kBulletList;
 77152: const nsIFrame::ChildListID nsIFrame::kCaptionList;
 77152: const nsIFrame::ChildListID nsIFrame::kColGroupList;
 77152: const nsIFrame::ChildListID nsIFrame::kExcessOverflowContainersList;
 77152: const nsIFrame::ChildListID nsIFrame::kFixedList;
 77152: const nsIFrame::ChildListID nsIFrame::kFloatList;
 77152: const nsIFrame::ChildListID nsIFrame::kOverflowContainersList;
 77152: const nsIFrame::ChildListID nsIFrame::kOverflowList;
 77152: const nsIFrame::ChildListID nsIFrame::kOverflowOutOfFlowList;
 77152: const nsIFrame::ChildListID nsIFrame::kPopupList;
 77152: const nsIFrame::ChildListID nsIFrame::kPushedFloatsList;
 77152: const nsIFrame::ChildListID nsIFrame::kSelectPopupList;
 77152: const nsIFrame::ChildListID nsIFrame::kNoReflowPrincipalList;
 77152: #endif
 77152: 
     1: /* virtual */ nsMargin
     1: nsIFrame::GetUsedMargin() const
     1: {
     1:   nsMargin margin(0, 0, 0, 0);
110557:   if (((mState & NS_FRAME_FIRST_REFLOW) &&
110557:        !(mState & NS_FRAME_IN_REFLOW)) ||
107222:       (mState & NS_FRAME_IS_SVG_TEXT))
 38828:     return margin;
 38828: 
  3233:   nsMargin *m = static_cast<nsMargin*>
 39965:                            (Properties().Get(UsedMarginProperty()));
     1:   if (m) {
     1:     margin = *m;
 38828:   } else {
 38828: #ifdef DEBUG
 79445:     bool hasMargin = 
 38828: #endif
 38828:     GetStyleMargin()->GetMargin(margin);
 38828:     NS_ASSERTION(hasMargin, "We should have a margin here! (out of memory?)");
     1:   }
     1:   return margin;
     1: }
     1: 
     1: /* virtual */ nsMargin
     1: nsIFrame::GetUsedBorder() const
     1: {
 38828:   nsMargin border(0, 0, 0, 0);
110557:   if (((mState & NS_FRAME_FIRST_REFLOW) &&
110557:        !(mState & NS_FRAME_IN_REFLOW)) ||
107222:       (mState & NS_FRAME_IS_SVG_TEXT))
 38828:     return border;
     1: 
     1:   // Theme methods don't use const-ness.
  3233:   nsIFrame *mutable_this = const_cast<nsIFrame*>(this);
     1: 
     1:   const nsStyleDisplay *disp = GetStyleDisplay();
     1:   if (mutable_this->IsThemed(disp)) {
 23738:     nsIntMargin result;
   238:     nsPresContext *presContext = PresContext();
     1:     presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
     1:                                              mutable_this, disp->mAppearance,
     1:                                              &result);
 38828:     border.left = presContext->DevPixelsToAppUnits(result.left);
 38828:     border.top = presContext->DevPixelsToAppUnits(result.top);
 38828:     border.right = presContext->DevPixelsToAppUnits(result.right);
 38828:     border.bottom = presContext->DevPixelsToAppUnits(result.bottom);
 38828:     return border;
 38828:   }
 38828: 
 38828:   nsMargin *b = static_cast<nsMargin*>
 39965:                            (Properties().Get(UsedBorderProperty()));
 38828:   if (b) {
 38828:     border = *b;
 38828:   } else {
 99855:     border = GetStyleBorder()->GetComputedBorder();
 38828:   }
 38828:   return border;
     1: }
     1: 
     1: /* virtual */ nsMargin
     1: nsIFrame::GetUsedPadding() const
     1: {
     1:   nsMargin padding(0, 0, 0, 0);
110557:   if (((mState & NS_FRAME_FIRST_REFLOW) &&
110557:        !(mState & NS_FRAME_IN_REFLOW)) ||
107222:       (mState & NS_FRAME_IS_SVG_TEXT))
 38828:     return padding;
     1: 
     1:   // Theme methods don't use const-ness.
  3233:   nsIFrame *mutable_this = const_cast<nsIFrame*>(this);
     1: 
     1:   const nsStyleDisplay *disp = GetStyleDisplay();
     1:   if (mutable_this->IsThemed(disp)) {
   238:     nsPresContext *presContext = PresContext();
 23738:     nsIntMargin widget;
     1:     if (presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
     1:                                                   mutable_this,
     1:                                                   disp->mAppearance,
 23738:                                                   &widget)) {
 23738:       padding.top = presContext->DevPixelsToAppUnits(widget.top);
 23738:       padding.right = presContext->DevPixelsToAppUnits(widget.right);
 23738:       padding.bottom = presContext->DevPixelsToAppUnits(widget.bottom);
 23738:       padding.left = presContext->DevPixelsToAppUnits(widget.left);
     1:       return padding;
     1:     }
     1:   }
 38828: 
  3233:   nsMargin *p = static_cast<nsMargin*>
 39965:                            (Properties().Get(UsedPaddingProperty()));
     1:   if (p) {
     1:     padding = *p;
 38828:   } else {
 38828: #ifdef DEBUG
 79445:     bool hasPadding = 
 38828: #endif
 38828:     GetStylePadding()->GetPadding(padding);
 38828:     NS_ASSERTION(hasPadding, "We should have padding here! (out of memory?)");
     1:   }
     1:   return padding;
     1: }
     1: 
     1: void
     1: nsIFrame::ApplySkipSides(nsMargin& aMargin) const
     1: {
107846:   int skipSides = GetSkipSides();
     1:   if (skipSides & (1 << NS_SIDE_TOP))
     1:     aMargin.top = 0;
     1:   if (skipSides & (1 << NS_SIDE_RIGHT))
     1:     aMargin.right = 0;
     1:   if (skipSides & (1 << NS_SIDE_BOTTOM))
     1:     aMargin.bottom = 0;
     1:   if (skipSides & (1 << NS_SIDE_LEFT))
     1:     aMargin.left = 0;
     1: }
     1: 
     1: nsRect
 68635: nsIFrame::GetPaddingRectRelativeToSelf() const
 68635: {
 68635:   nsMargin bp(GetUsedBorder());
 68635:   ApplySkipSides(bp);
 68635:   nsRect r(0, 0, mRect.width, mRect.height);
 68635:   r.Deflate(bp);
 68635:   return r;
 68635: }
 68635: 
 68635: nsRect
     1: nsIFrame::GetPaddingRect() const
     1: {
 68635:   return GetPaddingRectRelativeToSelf() + GetPosition();
     1: }
     1: 
 79445: bool
 19214: nsIFrame::IsTransformed() const
 19214: {
107003:   return ((mState & NS_FRAME_MAY_BE_TRANSFORMED) &&
 98711:           (GetStyleDisplay()->HasTransform() ||
107003:            IsSVGTransformed() ||
107003:            (mContent &&
107005:             nsLayoutUtils::HasAnimationsForCompositor(mContent,
107005:                                                       eCSSProperty_transform))));
107003: }
107003: 
107003: bool
107003: nsIFrame::HasOpacity() const
107003: {
107003:   return GetStyleDisplay()->mOpacity < 1.0f || (mContent &&
107005:            nsLayoutUtils::HasAnimationsForCompositor(mContent,
107005:                                                      eCSSProperty_opacity));
 98711: }
 98711: 
 98711: bool
 98711: nsIFrame::IsSVGTransformed(gfxMatrix *aOwnTransforms,
 98711:                            gfxMatrix *aFromParentTransforms) const
 98711: {
 98711:   return false;
 19214: }
 19214: 
 79445: bool
 77286: nsIFrame::Preserves3DChildren() const
 77286: {
111630:   if (GetStyleDisplay()->mTransformStyle != NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D ||
111630:       !GetStyleDisplay()->HasTransform())
 80486:       return false;
 77850: 
 77850:   // If we're all scroll frame, then all descendants will be clipped, so we can't preserve 3d.
 77850:   if (GetType() == nsGkAtoms::scrollFrame)
 80486:       return false;
 77286: 
 77286:   nsRect temp;
106838:   return (!ApplyOverflowClipping(nullptr, this, GetStyleDisplay(), &temp) &&
106838:       !ApplyClipPropClipping(nullptr, GetStyleDisplay(), this, &temp) &&
 77286:       !nsSVGIntegrationUtils::UsingEffectsForFrame(this));
 77286: }
 77286: 
 79445: bool
 77850: nsIFrame::Preserves3D() const
 77850: {
111630:   if (!GetParent() || !GetParent()->Preserves3DChildren() ||
111630:       !GetStyleDisplay()->HasTransform()) {
 80486:     return false;
 80486:   }
 80486:   return true;
 77850: }
 77850: 
 90156: bool
 90156: nsIFrame::HasPerspective() const
 90156: {
 90156:   if (!IsTransformed()) {
 90156:     return false;
 90156:   }
106838:   const nsStyleDisplay* parentDisp = nullptr;
 90156:   nsStyleContext* parentStyleContext = GetStyleContext()->GetParent();
 90156:   if (parentStyleContext) {
 90156:     parentDisp = parentStyleContext->GetStyleDisplay();
 90156:   }
 90156: 
 90156:   if (parentDisp &&
 90156:       parentDisp->mChildPerspective.GetUnit() == eStyleUnit_Coord &&
 90156:       parentDisp->mChildPerspective.GetCoordValue() > 0.0) {
 90156:     return true;
 90156:   }
 90156:   return false;
 90156: }
 90156: 
 92049: bool
 92049: nsIFrame::ChildrenHavePerspective() const
 92049: {
 92049:   const nsStyleDisplay *disp = GetStyleContext()->GetStyleDisplay();
 92049:   if (disp &&
 92049:       disp->mChildPerspective.GetUnit() == eStyleUnit_Coord &&
 92049:       disp->mChildPerspective.GetCoordValue() > 0.0) {
 92049:     return true;
 92049:   }
 92049:   return false;
 92049: }
 92049: 
     1: nsRect
 68635: nsIFrame::GetContentRectRelativeToSelf() const
     1: {
     1:   nsMargin bp(GetUsedBorderAndPadding());
     1:   ApplySkipSides(bp);
 68635:   nsRect r(0, 0, mRect.width, mRect.height);
     1:   r.Deflate(bp);
     1:   return r;
     1: }
     1: 
 68635: nsRect
 68635: nsIFrame::GetContentRect() const
 68635: {
 68635:   return GetContentRectRelativeToSelf() + GetPosition();
 68635: }
 68635: 
 79445: bool
 52126: nsIFrame::ComputeBorderRadii(const nsStyleCorners& aBorderRadius,
 52127:                              const nsSize& aFrameSize,
 52130:                              const nsSize& aBorderArea,
107846:                              int aSkipSides,
 52126:                              nscoord aRadii[8])
 52126: {
 52126:   // Percentages are relative to whichever side they're on.
 52126:   NS_FOR_CSS_HALF_CORNERS(i) {
 52126:     const nsStyleCoord c = aBorderRadius.Get(i);
 52127:     nscoord axis =
 52127:       NS_HALF_CORNER_IS_X(i) ? aFrameSize.width : aFrameSize.height;
 52126: 
 52281:     if (c.IsCoordPercentCalcUnit()) {
 52281:       aRadii[i] = nsRuleNode::ComputeCoordPercentCalc(c, axis);
 52281:       if (aRadii[i] < 0) {
 52281:         // clamp calc()
 52281:         aRadii[i] = 0;
 52281:       }
 52281:     } else {
 52126:       NS_NOTREACHED("ComputeBorderRadii: bad unit");
 52126:       aRadii[i] = 0;
 52126:     }
 52128:   }
 52128: 
 52128:   if (aSkipSides & (1 << NS_SIDE_TOP)) {
 52128:     aRadii[NS_CORNER_TOP_LEFT_X] = 0;
 52128:     aRadii[NS_CORNER_TOP_LEFT_Y] = 0;
 52128:     aRadii[NS_CORNER_TOP_RIGHT_X] = 0;
 52128:     aRadii[NS_CORNER_TOP_RIGHT_Y] = 0;
 52128:   }
 52128: 
 52128:   if (aSkipSides & (1 << NS_SIDE_RIGHT)) {
 52128:     aRadii[NS_CORNER_TOP_RIGHT_X] = 0;
 52128:     aRadii[NS_CORNER_TOP_RIGHT_Y] = 0;
 52128:     aRadii[NS_CORNER_BOTTOM_RIGHT_X] = 0;
 52128:     aRadii[NS_CORNER_BOTTOM_RIGHT_Y] = 0;
 52128:   }
 52128: 
 52128:   if (aSkipSides & (1 << NS_SIDE_BOTTOM)) {
 52128:     aRadii[NS_CORNER_BOTTOM_RIGHT_X] = 0;
 52128:     aRadii[NS_CORNER_BOTTOM_RIGHT_Y] = 0;
 52128:     aRadii[NS_CORNER_BOTTOM_LEFT_X] = 0;
 52128:     aRadii[NS_CORNER_BOTTOM_LEFT_Y] = 0;
 52128:   }
 52128: 
 52128:   if (aSkipSides & (1 << NS_SIDE_LEFT)) {
 52128:     aRadii[NS_CORNER_BOTTOM_LEFT_X] = 0;
 52128:     aRadii[NS_CORNER_BOTTOM_LEFT_Y] = 0;
 52128:     aRadii[NS_CORNER_TOP_LEFT_X] = 0;
 52128:     aRadii[NS_CORNER_TOP_LEFT_Y] = 0;
 52128:   }
 52128: 
 52130:   // css3-background specifies this algorithm for reducing
 52130:   // corner radii when they are too big.
 79445:   bool haveRadius = false;
 52130:   double ratio = 1.0f;
 52130:   NS_FOR_CSS_SIDES(side) {
108991:     uint32_t hc1 = NS_SIDE_TO_HALF_CORNER(side, false, true);
108991:     uint32_t hc2 = NS_SIDE_TO_HALF_CORNER(side, true, true);
 52130:     nscoord length =
 52130:       NS_SIDE_IS_VERTICAL(side) ? aBorderArea.height : aBorderArea.width;
 52130:     nscoord sum = aRadii[hc1] + aRadii[hc2];
 52130:     if (sum)
 80486:       haveRadius = true;
 52130: 
 52130:     // avoid floating point division in the normal case
 52130:     if (length < sum)
 52130:       ratio = NS_MIN(ratio, double(length)/sum);
 52130:   }
 52130:   if (ratio < 1.0) {
 52130:     NS_FOR_CSS_HALF_CORNERS(corner) {
 52130:       aRadii[corner] *= ratio;
 52130:     }
 52130:   }
 52130: 
 52130:   return haveRadius;
 52126: }
 52126: 
 52131: /* static */ void
 52131: nsIFrame::InsetBorderRadii(nscoord aRadii[8], const nsMargin &aOffsets)
 52131: {
 52131:   NS_FOR_CSS_SIDES(side) {
 68637:     nscoord offset = aOffsets.Side(side);
108991:     uint32_t hc1 = NS_SIDE_TO_HALF_CORNER(side, false, false);
108991:     uint32_t hc2 = NS_SIDE_TO_HALF_CORNER(side, true, false);
 52131:     aRadii[hc1] = NS_MAX(0, aRadii[hc1] - offset);
 52131:     aRadii[hc2] = NS_MAX(0, aRadii[hc2] - offset);
 52131:   }
 52131: }
 52131: 
 52131: /* static */ void
 52131: nsIFrame::OutsetBorderRadii(nscoord aRadii[8], const nsMargin &aOffsets)
 52131: {
 52131:   NS_FOR_CSS_SIDES(side) {
 68637:     nscoord offset = aOffsets.Side(side);
108991:     uint32_t hc1 = NS_SIDE_TO_HALF_CORNER(side, false, false);
108991:     uint32_t hc2 = NS_SIDE_TO_HALF_CORNER(side, true, false);
 52131:     if (aRadii[hc1] > 0)
 52131:       aRadii[hc1] += offset;
 52131:     if (aRadii[hc2] > 0)
 52131:       aRadii[hc2] += offset;
 52131:   }
 52131: }
 52131: 
 79445: /* virtual */ bool
 52131: nsIFrame::GetBorderRadii(nscoord aRadii[8]) const
 52131: {
 55048:   if (IsThemed()) {
 55048:     // When we're themed, the native theme code draws the border and
 55048:     // background, and therefore it doesn't make sense to tell other
 55048:     // code that's interested in border-radius that we have any radii.
 55048:     //
 55048:     // In an ideal world, we might have a way for the them to tell us an
 55048:     // border radius, but since we don't, we're better off assuming
 55048:     // zero.
 55048:     NS_FOR_CSS_HALF_CORNERS(corner) {
 55048:       aRadii[corner] = 0;
 55048:     }
 80486:     return false;
 55048:   }
 52131:   nsSize size = GetSize();
 52131:   return ComputeBorderRadii(GetStyleBorder()->mBorderRadius, size, size,
 52131:                             GetSkipSides(), aRadii);
 52131: }
 52131: 
 79445: bool
 52131: nsIFrame::GetPaddingBoxBorderRadii(nscoord aRadii[8]) const
 52131: {
 52131:   if (!GetBorderRadii(aRadii))
 80486:     return false;
 52131:   InsetBorderRadii(aRadii, GetUsedBorder());
 52131:   NS_FOR_CSS_HALF_CORNERS(corner) {
 52131:     if (aRadii[corner])
 80486:       return true;
 80486:   }
 80486:   return false;
 52131: }
 52131: 
 79445: bool
 52131: nsIFrame::GetContentBoxBorderRadii(nscoord aRadii[8]) const
 52131: {
 52131:   if (!GetBorderRadii(aRadii))
 80486:     return false;
 52131:   InsetBorderRadii(aRadii, GetUsedBorderAndPadding());
 52131:   NS_FOR_CSS_HALF_CORNERS(corner) {
 52131:     if (aRadii[corner])
 80486:       return true;
 80486:   }
 80486:   return false;
 52131: }
 52131: 
     1: nsStyleContext*
108991: nsFrame::GetAdditionalStyleContext(int32_t aIndex) const
     1: {
     1:   NS_PRECONDITION(aIndex >= 0, "invalid index number");
106838:   return nullptr;
     1: }
     1: 
     1: void
108991: nsFrame::SetAdditionalStyleContext(int32_t aIndex, 
     1:                                    nsStyleContext* aStyleContext)
     1: {
     1:   NS_PRECONDITION(aIndex >= 0, "invalid index number");
     1: }
     1: 
     1: nscoord
     1: nsFrame::GetBaseline() const
     1: {
  1158:   NS_ASSERTION(!NS_SUBTREE_DIRTY(this),
     1:                "frame must not be dirty");
     1:   // Default to the bottom margin edge, per CSS2.1's definition of the
     1:   // 'baseline' value of 'vertical-align'.
     1:   return mRect.height + GetUsedMargin().bottom;
     1: }
     1: 
 91756: const nsFrameList&
 79483: nsFrame::GetChildList(ChildListID aListID) const
 79483: {
 79483:   if (IsAbsoluteContainer() &&
 79483:       aListID == GetAbsoluteListID()) {
 79483:     return GetAbsoluteContainingBlock()->GetChildList();
 79483:   } else {
 79483:     return nsFrameList::EmptyList();
 79483:   }
 79483: }
 79483: 
 79483: void
 79483: nsFrame::GetChildLists(nsTArray<ChildList>* aLists) const
 79483: {
 79483:   if (IsAbsoluteContainer()) {
 79483:     nsFrameList absoluteList = GetAbsoluteContainingBlock()->GetChildList();
 79483:     absoluteList.AppendIfNonempty(aLists, GetAbsoluteListID());
 79483:   }
 79483: }
 79483: 
 74711: static nsIFrame*
 74711: GetActiveSelectionFrame(nsPresContext* aPresContext, nsIFrame* aFrame)
 74711: {
 74711:   nsIContent* capturingContent = nsIPresShell::GetCapturingContent();
 74711:   if (capturingContent) {
 74711:     nsIFrame* activeFrame = aPresContext->GetPrimaryFrameFor(capturingContent);
 74711:     return activeFrame ? activeFrame : aFrame;
 74711:   }
 74711: 
 74711:   return aFrame;
 74711: }
 74711: 
108991: int16_t
 79445: nsFrame::DisplaySelection(nsPresContext* aPresContext, bool isOkToTurnOn)
     1: {
108991:   int16_t selType = nsISelectionController::SELECTION_OFF;
     1: 
     1:   nsCOMPtr<nsISelectionController> selCon;
     1:   nsresult result = GetSelectionController(aPresContext, getter_AddRefs(selCon));
     1:   if (NS_SUCCEEDED(result) && selCon) {
     1:     result = selCon->GetDisplaySelection(&selType);
     1:     if (NS_SUCCEEDED(result) && (selType != nsISelectionController::SELECTION_OFF)) {
     1:       // Check whether style allows selection.
 79445:       bool selectable;
106838:       IsSelectable(&selectable, nullptr);
     1:       if (!selectable) {
     1:         selType = nsISelectionController::SELECTION_OFF;
 80486:         isOkToTurnOn = false;
     1:       }
     1:     }
     1:     if (isOkToTurnOn && (selType == nsISelectionController::SELECTION_OFF)) {
     1:       selCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
     1:       selType = nsISelectionController::SELECTION_ON;
     1:     }
     1:   }
     1:   return selType;
     1: }
     1: 
     1: class nsDisplaySelectionOverlay : public nsDisplayItem {
     1: public:
 51260:   nsDisplaySelectionOverlay(nsDisplayListBuilder* aBuilder,
108991:                             nsFrame* aFrame, int16_t aSelectionValue)
 51260:     : nsDisplayItem(aBuilder, aFrame), mSelectionValue(aSelectionValue) {
     1:     MOZ_COUNT_CTOR(nsDisplaySelectionOverlay);
     1:   }
     1: #ifdef NS_BUILD_REFCNT_LOGGING
     1:   virtual ~nsDisplaySelectionOverlay() {
     1:     MOZ_COUNT_DTOR(nsDisplaySelectionOverlay);
     1:   }
     1: #endif
     1: 
 33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
 68481:                      nsRenderingContext* aCtx);
 47732:   NS_DISPLAY_DECL_NAME("SelectionOverlay", TYPE_SELECTION_OVERLAY)
     1: private:
108991:   int16_t mSelectionValue;
     1: };
     1: 
     1: void nsDisplaySelectionOverlay::Paint(nsDisplayListBuilder* aBuilder,
 68481:                                       nsRenderingContext* aCtx)
     1: {
 78130:   LookAndFeel::ColorID colorID;
     1:   if (mSelectionValue == nsISelectionController::SELECTION_ON) {
 78130:     colorID = LookAndFeel::eColorID_TextSelectBackground;
     1:   } else if (mSelectionValue == nsISelectionController::SELECTION_ATTENTION) {
 78130:     colorID = LookAndFeel::eColorID_TextSelectBackgroundAttention;
     1:   } else {
 78130:     colorID = LookAndFeel::eColorID_TextSelectBackgroundDisabled;
 78130:   }
 78130: 
 78130:   nscolor color = LookAndFeel::GetColor(colorID, NS_RGB(255, 255, 255));
     1: 
     1:   gfxRGBA c(color);
     1:   c.a = .5;
     1: 
 15229:   gfxContext *ctx = aCtx->ThebesContext();
     1:   ctx->SetColor(c);
     1: 
 33368:   nsIntRect pxRect =
 33368:     mVisibleRect.ToOutsidePixels(mFrame->PresContext()->AppUnitsPerDevPixel());
    54:   ctx->NewPath();
 80486:   ctx->Rectangle(gfxRect(pxRect.x, pxRect.y, pxRect.width, pxRect.height), true);
     1:   ctx->Fill();
     1: }
     1: 
     1: /********************************************************
     1: * Refreshes each content's frame
     1: *********************************************************/
     1: 
     1: nsresult
     1: nsFrame::DisplaySelectionOverlay(nsDisplayListBuilder*   aBuilder,
 52291:                                  nsDisplayList*          aList,
108991:                                  uint16_t                aContentType)
     1: {
 85101:   if (!IsSelected() || !IsVisibleForPainting(aBuilder))
     1:     return NS_OK;
     1:     
   238:   nsPresContext* presContext = PresContext();
     1:   nsIPresShell *shell = presContext->PresShell();
     1:   if (!shell)
     1:     return NS_OK;
     1: 
108991:   int16_t displaySelection = shell->GetSelectionFlags();
     1:   if (!(displaySelection & aContentType))
     1:     return NS_OK;
     1: 
  8295:   const nsFrameSelection* frameSelection = GetConstFrameSelection();
108991:   int16_t selectionValue = frameSelection->GetDisplaySelection();
     1: 
     1:   if (selectionValue <= nsISelectionController::SELECTION_HIDDEN)
     1:     return NS_OK; // selection is hidden or off
     1: 
     1:   nsIContent *newContent = mContent->GetParent();
     1: 
     1:   //check to see if we are anonymous content
108991:   int32_t offset = 0;
     1:   if (newContent) {
     1:     // XXXbz there has GOT to be a better way of determining this!
     1:     offset = newContent->IndexOf(mContent);
     1:   }
     1: 
     1:   SelectionDetails *details;
     1:   //look up to see what selection(s) are on this frame
 80486:   details = frameSelection->LookUpSelection(newContent, offset, 1, false);
     1:   if (!details)
     1:     return NS_OK;
     1:   
105448:   bool normal = false;
     1:   while (details) {
105448:     if (details->mType == nsISelectionController::SELECTION_NORMAL) {
105448:       normal = true;
105448:     }
     1:     SelectionDetails *next = details->mNext;
     1:     delete details;
     1:     details = next;
     1:   }
     1: 
105448:   if (!normal && aContentType == nsISelectionDisplay::DISPLAY_IMAGES) {
105448:     // Don't overlay an image if it's not in the primary selection.
105448:     return NS_OK;
105448:   }
105448: 
 52291:   return aList->AppendNewToTop(new (aBuilder)
 51260:       nsDisplaySelectionOverlay(aBuilder, this, selectionValue));
     1: }
     1: 
     1: nsresult
     1: nsFrame::DisplayOutlineUnconditional(nsDisplayListBuilder*   aBuilder,
     1:                                      const nsDisplayListSet& aLists)
     1: {
     1:   if (GetStyleOutline()->GetOutlineStyle() == NS_STYLE_BORDER_STYLE_NONE)
     1:     return NS_OK;
     1:     
 51260:   return aLists.Outlines()->AppendNewToTop(
 51260:       new (aBuilder) nsDisplayOutline(aBuilder, this));
     1: }
     1: 
     1: nsresult
     1: nsFrame::DisplayOutline(nsDisplayListBuilder*   aBuilder,
     1:                         const nsDisplayListSet& aLists)
     1: {
     1:   if (!IsVisibleForPainting(aBuilder))
     1:     return NS_OK;
     1: 
     1:   return DisplayOutlineUnconditional(aBuilder, aLists);
     1: }
     1: 
     1: nsresult
     1: nsIFrame::DisplayCaret(nsDisplayListBuilder* aBuilder,
 39949:                        const nsRect& aDirtyRect, nsDisplayList* aList)
     1: {
     1:   if (!IsVisibleForPainting(aBuilder))
     1:     return NS_OK;
     1: 
 39949:   return aList->AppendNewToTop(
 51260:       new (aBuilder) nsDisplayCaret(aBuilder, this, aBuilder->GetCaret()));
     1: }
     1: 
 40078: nscolor
108991: nsIFrame::GetCaretColorAt(int32_t aOffset)
 40078: {
 40078:   // Use text color.
 40078:   return GetStyleColor()->mColor;
 40078: }
 40078: 
     1: nsresult
 30510: nsFrame::DisplayBackgroundUnconditional(nsDisplayListBuilder*   aBuilder,
 30510:                                         const nsDisplayListSet& aLists,
 95349:                                         bool                    aForceBackground,
 95349:                                         nsDisplayBackground**   aBackground)
 30510: {
 30510:   // Here we don't try to detect background propagation. Frames that might
 30510:   // receive a propagated background should just set aForceBackground to
 80486:   // true.
 30510:   if (aBuilder->IsForEventDelivery() || aForceBackground ||
 30510:       !GetStyleBackground()->IsTransparent() || GetStyleDisplay()->mAppearance) {
 95349:     nsDisplayBackground* bg = new (aBuilder) nsDisplayBackground(aBuilder, this);
 95349:     *aBackground = bg;
 95349:     return aLists.BorderBackground()->AppendNewToTop(bg);
 95349:   }
106838:   *aBackground = nullptr;
 30510:   return NS_OK;
 30510: }
 30510: 
 30510: nsresult
     1: nsFrame::DisplayBorderBackgroundOutline(nsDisplayListBuilder*   aBuilder,
     1:                                         const nsDisplayListSet& aLists,
 79445:                                         bool                    aForceBackground)
     1: {
     1:   // The visibility check belongs here since child elements have the
     1:   // opportunity to override the visibility property and display even if
     1:   // their parent is hidden.
     1:   if (!IsVisibleForPainting(aBuilder))
     1:     return NS_OK;
     1: 
 95486:   nsCSSShadowArray* shadows = GetStyleBorder()->mBoxShadow;
 95486:   if (shadows && shadows->HasShadowWithInset(false)) {
 15700:     nsresult rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
 51260:         nsDisplayBoxShadowOuter(aBuilder, this));
 15700:     NS_ENSURE_SUCCESS(rv, rv);
 15700:   }
 15700: 
 95349:   nsDisplayBackground* bg;
 30510:   nsresult rv =
 95349:     DisplayBackgroundUnconditional(aBuilder, aLists, aForceBackground, &bg);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 95486:   if (shadows && shadows->HasShadowWithInset(true)) {
 30510:     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
 51260:         nsDisplayBoxShadowInner(aBuilder, this));
 24818:     NS_ENSURE_SUCCESS(rv, rv);
 24818:   }
 24818: 
 95349:   // If there's a themed background, we should not create a border item.
 95646:   // It won't be rendered.
 95646:   if ((!bg || !bg->IsThemed()) && GetStyleBorder()->HasBorder()) {
 30510:     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
 51260:         nsDisplayBorder(aBuilder, this));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   return DisplayOutlineUnconditional(aBuilder, aLists);
     1: }
     1: 
105956: inline static bool IsSVGContentWithCSSClip(const nsIFrame *aFrame)
105956: {
105956:   // The CSS spec says that the 'clip' property only applies to absolutely
105956:   // positioned elements, whereas the SVG spec says that it applies to SVG
105956:   // elements regardless of the value of the 'position' property. Here we obey
105956:   // the CSS spec for outer-<svg> (since that's what we generally do), but
105956:   // obey the SVG spec for other SVG elements to which 'clip' applies.
105956:   nsIAtom *tag = aFrame->GetContent()->Tag();
105956:   return (aFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT) &&
105956:     (tag == nsGkAtoms::svg || tag == nsGkAtoms::foreignObject);
105956: }
105956: 
 79445: bool
 91411: nsIFrame::GetClipPropClipRect(const nsStyleDisplay* aDisp, nsRect* aRect,
 77286:                               const nsSize& aSize) const
     1: {
     1:   NS_PRECONDITION(aRect, "Must have aRect out parameter");
     1: 
105956:   if (!(aDisp->mClipFlags & NS_STYLE_CLIP_RECT) ||
107225:       !(aDisp->IsAbsolutelyPositioned(this) || IsSVGContentWithCSSClip(this))) {
 80486:     return false;
105956:   }
     1: 
   204:   *aRect = aDisp->mClip;
   204:   if (NS_STYLE_CLIP_RIGHT_AUTO & aDisp->mClipFlags) {
   462:     aRect->width = aSize.width - aRect->x;
   204:   }
   204:   if (NS_STYLE_CLIP_BOTTOM_AUTO & aDisp->mClipFlags) {
   462:     aRect->height = aSize.height - aRect->y;
     1:   }
 80486:   return true;
     1: }
     1: 
 91411: static bool ApplyClipPropClipping(nsDisplayListBuilder* aBuilder,
 77286:                                   const nsStyleDisplay* aDisp, const nsIFrame* aFrame,
     1:                                   nsRect* aRect) {
 91411:   if (!aFrame->GetClipPropClipRect(aDisp, aRect, aFrame->GetSize()))
 80486:     return false;
     1: 
 77286:   if (aBuilder) {
     1:     *aRect += aBuilder->ToReferenceFrame(aFrame);
 77286:   }
 80486:   return true;
     1: }
     1: 
 79445: static bool ApplyOverflowClipping(nsDisplayListBuilder* aBuilder,
 77286:                                   const nsIFrame* aFrame,
     1:                                   const nsStyleDisplay* aDisp, nsRect* aRect) {
     1:   // REVIEW: from nsContainerFrame.cpp SyncFrameViewGeometryDependentProperties,
     1:   // except that that function used the border-edge for
     1:   // -moz-hidden-unscrollable which I don't think is correct... Also I've
     1:   // changed -moz-hidden-unscrollable to apply to any kind of frame.
     1: 
     1:   // Only -moz-hidden-unscrollable is handled here (and 'hidden' for table
 55006:   // frames, and any non-visible value for blocks in a paginated context).
 55006:   // Other overflow clipping is applied by nsHTML/XULScrollFrame.
     1:   // We allow -moz-hidden-unscrollable to apply to any kind of frame. This
     1:   // is required by comboboxes which make their display text (an inline frame)
     1:   // have clipping.
 87630:   if (!nsFrame::ApplyOverflowClipping(aFrame, aDisp)) {
 87630:     return false;
 87630:   }
 77286:   *aRect = aFrame->GetPaddingRect() - aFrame->GetPosition();
 77286:   if (aBuilder) {
 77286:     *aRect += aBuilder->ToReferenceFrame(aFrame);
 77286:   }
 80486:   return true;
     1: }
     1: 
     1: class nsOverflowClipWrapper : public nsDisplayWrapper
     1: {
     1: public:
     1:   /**
     1:    * Create a wrapper to apply overflow clipping for aContainer.
 80486:    * @param aClipBorderBackground set to true to clip the BorderBackground()
     1:    * list, otherwise it will not be clipped
 80486:    * @param aClipAll set to true to clip all descendants, even those for
     1:    * which we aren't the containing block
     1:    */
     1:   nsOverflowClipWrapper(nsIFrame* aContainer, const nsRect& aRect,
 52293:                         const nscoord aRadii[8],
 79445:                         bool aClipBorderBackground, bool aClipAll)
     1:     : mContainer(aContainer), mRect(aRect),
 52293:       mClipBorderBackground(aClipBorderBackground), mClipAll(aClipAll),
 80486:       mHaveRadius(false)
 52293:   {
 52293:     memcpy(mRadii, aRadii, sizeof(mRadii));
 52293:     NS_FOR_CSS_HALF_CORNERS(corner) {
 52293:       if (aRadii[corner] > 0) {
 80486:         mHaveRadius = true;
 52293:         break;
 52293:       }
 52293:     }
 52293:   }
 79445:   virtual bool WrapBorderBackground() { return mClipBorderBackground; }
     1:   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
     1:                                   nsIFrame* aFrame, nsDisplayList* aList) {
     1:     // We are not a stacking context root. There is no valid underlying
     1:     // frame for the whole list. These items are all in-flow descendants so
     1:     // we can safely just clip them.
 52293:     if (mHaveRadius) {
106838:       return new (aBuilder) nsDisplayClipRoundedRect(aBuilder, nullptr, aList,
 52293:                                                      mRect, mRadii);
 52293:     }
106838:     return new (aBuilder) nsDisplayClip(aBuilder, nullptr, aList, mRect);
     1:   }
     1:   virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
     1:                                   nsDisplayItem* aItem) {
     1:     nsIFrame* f = aItem->GetUnderlyingFrame();
 52293:     if (mClipAll ||
106838:         nsLayoutUtils::IsProperAncestorFrame(mContainer, f, nullptr)) {
 52293:       if (mHaveRadius) {
 52293:         return new (aBuilder) nsDisplayClipRoundedRect(aBuilder, f, aItem,
 52293:                                                        mRect, mRadii);
 52293:       }
 52289:       return new (aBuilder) nsDisplayClip(aBuilder, f, aItem, mRect);
 52293:     }
     1:     return aItem;
     1:   }
     1: protected:
     1:   nsIFrame*    mContainer;
     1:   nsRect       mRect;
 52293:   nscoord      mRadii[8];
 79445:   bool mClipBorderBackground;
 79445:   bool mClipAll;
 79445:   bool mHaveRadius;
     1: };
     1: 
 91411: class nsDisplayClipPropWrapper : public nsDisplayWrapper
     1: {
     1: public:
 91411:   nsDisplayClipPropWrapper(const nsRect& aRect)
 52290:     : mRect(aRect) {}
     1:   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
     1:                                   nsIFrame* aFrame, nsDisplayList* aList) {
     1:     // We are not a stacking context root. There is no valid underlying
     1:     // frame for the whole list.
106838:     return new (aBuilder) nsDisplayClip(aBuilder, nullptr, aList, mRect);
     1:   }
     1:   virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
     1:                                   nsDisplayItem* aItem) {
 51260:     return new (aBuilder) nsDisplayClip(aBuilder, aItem->GetUnderlyingFrame(),
 52289:                                         aItem, mRect);
     1:   }
     1: protected:
     1:   nsRect    mRect;
     1: };
     1: 
     1: nsresult
     1: nsIFrame::OverflowClip(nsDisplayListBuilder*   aBuilder,
     1:                        const nsDisplayListSet& aFromSet,
     1:                        const nsDisplayListSet& aToSet,
     1:                        const nsRect&           aClipRect,
 52293:                        const nscoord           aClipRadii[8],
 79445:                        bool                    aClipBorderBackground,
 79445:                        bool                    aClipAll)
     1: {
 52293:   nsOverflowClipWrapper wrapper(this, aClipRect, aClipRadii,
 52293:                                 aClipBorderBackground, aClipAll);
     1:   return wrapper.WrapLists(aBuilder, this, aFromSet, aToSet);
     1: }
     1: 
     1: static nsresult
     1: BuildDisplayListWithOverflowClip(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
     1:     const nsRect& aDirtyRect, const nsDisplayListSet& aSet,
 52293:     const nsRect& aClipRect, const nscoord aClipRadii[8])
     1: {
     1:   nsDisplayListCollection set;
     1:   nsresult rv = aFrame->BuildDisplayList(aBuilder, aDirtyRect, set);
     1:   NS_ENSURE_SUCCESS(rv, rv);
 39949:   rv = aBuilder->DisplayCaret(aFrame, aDirtyRect, aSet.Content());
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 52293:   return aFrame->OverflowClip(aBuilder, set, aSet, aClipRect, aClipRadii);
     1: }
     1: 
102909: #ifdef DEBUG
 68481: static void PaintDebugBorder(nsIFrame* aFrame, nsRenderingContext* aCtx,
     1:      const nsRect& aDirtyRect, nsPoint aPt) {
     1:   nsRect r(aPt, aFrame->GetSize());
     1:   if (aFrame->HasView()) {
     1:     aCtx->SetColor(NS_RGB(0,0,255));
     1:   } else {
     1:     aCtx->SetColor(NS_RGB(255,0,0));
     1:   }
     1:   aCtx->DrawRect(r);
     1: }
     1: 
 68481: static void PaintEventTargetBorder(nsIFrame* aFrame, nsRenderingContext* aCtx,
     1:      const nsRect& aDirtyRect, nsPoint aPt) {
     1:   nsRect r(aPt, aFrame->GetSize());
     1:   aCtx->SetColor(NS_RGB(128,0,128));
     1:   aCtx->DrawRect(r);
     1: }
     1: 
     1: static void
     1: DisplayDebugBorders(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
     1:                     const nsDisplayListSet& aLists) {
     1:   // Draw a border around the child
     1:   // REVIEW: From nsContainerFrame::PaintChild
 31709:   if (nsFrame::GetShowFrameBorders() && !aFrame->GetRect().IsEmpty()) {
     1:     aLists.Outlines()->AppendNewToTop(new (aBuilder)
 51260:         nsDisplayGeneric(aBuilder, aFrame, PaintDebugBorder, "DebugBorder",
 47732:                          nsDisplayItem::TYPE_DEBUG_BORDER));
     1:   }
     1:   // Draw a border around the current event target
 31709:   if (nsFrame::GetShowEventTargetFrameBorder() &&
   238:       aFrame->PresContext()->PresShell()->GetDrawEventTargetFrame() == aFrame) {
     1:     aLists.Outlines()->AppendNewToTop(new (aBuilder)
 51260:         nsDisplayGeneric(aBuilder, aFrame, PaintEventTargetBorder, "EventTargetBorder",
 47732:                          nsDisplayItem::TYPE_EVENT_TARGET_BORDER));
     1:   }
     1: }
     1: #endif
     1: 
 77286: static nsresult
108991: WrapPreserve3DListInternal(nsIFrame* aFrame, nsDisplayListBuilder *aBuilder, nsDisplayList *aList, uint32_t& aIndex)
 79635: {
 79635:   if (aIndex > nsDisplayTransform::INDEX_MAX) {
 79635:     return NS_OK;
 79635:   }
 79635: 
 77286:   nsresult rv = NS_OK;
 77286:   nsDisplayList newList;
 79635:   nsDisplayList temp;
 77286:   while (nsDisplayItem *item = aList->RemoveBottom()) {
 77850:     nsIFrame *childFrame = item->GetUnderlyingFrame();
 79635: 
 79635:     // We accumulate sequential items that aren't transforms into the 'temp' list
 79635:     // and then flush this list into newList by wrapping the whole lot with a single
 79635:     // nsDisplayTransform.
 79635: 
 82356:     if (childFrame && (childFrame->GetParent()->Preserves3DChildren() || childFrame == aFrame)) {
 77286:       switch (item->GetType()) {
 77286:         case nsDisplayItem::TYPE_TRANSFORM: {
 79635:           if (!temp.IsEmpty()) {
 79635:             newList.AppendToTop(new (aBuilder) nsDisplayTransform(aBuilder, aFrame, &temp, aIndex++));
 79635:           }
 79635:           newList.AppendToTop(item);
 77286:           break;
 77286:         }
 77286:         case nsDisplayItem::TYPE_WRAP_LIST: {
 79635:           if (!temp.IsEmpty()) {
 79635:             newList.AppendToTop(new (aBuilder) nsDisplayTransform(aBuilder, aFrame, &temp, aIndex++));
 79635:           }
 77286:           nsDisplayWrapList *list = static_cast<nsDisplayWrapList*>(item);
 79635:           rv = WrapPreserve3DListInternal(aFrame, aBuilder, list->GetList(), aIndex);
 79923:           newList.AppendToTop(list->GetList());
 79923:           list->~nsDisplayWrapList();
 77286:           break;
 77286:         }
 77286:         case nsDisplayItem::TYPE_OPACITY: {
 79635:           if (!temp.IsEmpty()) {
 79635:             newList.AppendToTop(new (aBuilder) nsDisplayTransform(aBuilder, aFrame, &temp, aIndex++));
 79635:           }
 77286:           nsDisplayOpacity *opacity = static_cast<nsDisplayOpacity*>(item);
 79635:           rv = WrapPreserve3DListInternal(aFrame, aBuilder, opacity->GetList(), aIndex);
 95693:           opacity->UpdateBounds(aBuilder);
 79635:           newList.AppendToTop(item);
 77286:           break;
 77286:         }
 77286:         default: {
 79635:           temp.AppendToTop(item);
 77286:           break;
 77286:         }
 77286:       } 
 77286:     } else {
 79635:       temp.AppendToTop(item);
 79635:     }
 79635:  
 79635:     if (NS_FAILED(rv) || !item || aIndex > nsDisplayTransform::INDEX_MAX)
 77286:       return rv;
 79635:   }
 79635:     
 79635:   if (!temp.IsEmpty()) {
 79635:     newList.AppendToTop(new (aBuilder) nsDisplayTransform(aBuilder, aFrame, &temp, aIndex++));
 77286:   }
 77286: 
 77286:   aList->AppendToTop(&newList);
 77286:   return NS_OK;
 77286: }
 77286: 
 79635: static nsresult
 79635: WrapPreserve3DList(nsIFrame* aFrame, nsDisplayListBuilder* aBuilder, nsDisplayList *aList)
 79635: {
108991:   uint32_t index = 0;
 79635:   return WrapPreserve3DListInternal(aFrame, aBuilder, aList, index);
 79635: }
 79635: 
     1: nsresult
     1: nsIFrame::BuildDisplayListForStackingContext(nsDisplayListBuilder* aBuilder,
     1:                                              const nsRect&         aDirtyRect,
     1:                                              nsDisplayList*        aList) {
  3724:   if (GetStateBits() & NS_FRAME_TOO_DEEP_IN_FRAME_TREE)
     1:     return NS_OK;
106439: 
     1:   // Replaced elements have their visibility handled here, because
     1:   // they're visually atomic
     1:   if (IsFrameOfType(eReplaced) && !IsVisibleForPainting(aBuilder))
     1:     return NS_OK;
     1: 
 91411:   nsRect clipPropClip;
     1:   const nsStyleDisplay* disp = GetStyleDisplay();
106439:   // We can stop right away if this is a zero-opacity stacking context and
107005:   // we're painting, and we're not animating opacity.
107005:   if (disp->mOpacity == 0.0 && aBuilder->IsForPainting() &&
107005:       !nsLayoutUtils::HasAnimationsForCompositor(mContent,
107005:                                                  eCSSProperty_opacity)) {
 34209:     return NS_OK;
107005:   }
 34209: 
 91411:   bool applyClipPropClipping =
 91411:       ApplyClipPropClipping(aBuilder, disp, this, &clipPropClip);
     1:   nsRect dirtyRect = aDirtyRect;
 19214: 
 79445:   bool inTransform = aBuilder->IsInTransform();
105956:   if (IsTransformed()) {
 98299:     if (aBuilder->IsForPainting() &&
 98299:         nsDisplayTransform::ShouldPrerenderTransformedContent(aBuilder, this)) {
 84920:       dirtyRect = GetVisualOverflowRectRelativeToSelf();
 84920:     } else {
106521:       // Trying to  back-transform arbitrary rects gives us really weird results. I believe 
106521:       // this is from points that lie beyond the vanishing point. As a workaround we transform t
106521:       // he overflow rect into screen space and compare in that coordinate system.
 98299: 
 98299:       // Transform the overflow rect into screen space
 98299:       nsRect overflow = GetVisualOverflowRectRelativeToSelf();
 98299:       nsPoint offset = aBuilder->ToReferenceFrame(this);
 98299:       overflow += offset;
 98299:       overflow = nsDisplayTransform::TransformRect(overflow, this, offset);
 98299: 
 98299:       dirtyRect += offset;
 98299: 
 98299:       if (dirtyRect.Intersects(overflow)) {
106521:         // If they intersect, we take our whole overflow rect. We could instead take the intersection
106521:         // and then reverse transform it but I doubt this extra work is worthwhile.
 98299:         dirtyRect = GetVisualOverflowRectRelativeToSelf();
 98299:       } else {
 98299:         dirtyRect.SetEmpty();
 98299:       }
 98299:       if (!Preserves3DChildren() && !dirtyRect.Intersects(GetVisualOverflowRectRelativeToSelf())) {
 98299:         return NS_OK;
 74283:       }
 84920:     }
 80486:     inTransform = true;
 30541:   }
 19214: 
 91411:   if (applyClipPropClipping) {
     1:     dirtyRect.IntersectRect(dirtyRect,
 91411:                             clipPropClip - aBuilder->ToReferenceFrame(this));
     1:   }
     1: 
 79445:   bool usingSVGEffects = nsSVGIntegrationUtils::UsingEffectsForFrame(this);
 19125:   if (usingSVGEffects) {
 19125:     dirtyRect =
 19125:       nsSVGIntegrationUtils::GetRequiredSourceForInvalidArea(this, dirtyRect);
 19125:   }
 19125: 
 79692:   MarkAbsoluteFramesForDisplayList(aBuilder, dirtyRect);
105956: 
 98299:   // Preserve3DChildren() also guarantees that applyAbsPosClipping and usingSVGEffects are false
 98299:   // We only modify the preserve-3d rect if we are the top of a preserve-3d heirarchy
 98299:   if (Preserves3DChildren()) {
 98299:     aBuilder->MarkPreserve3DFramesForDisplayList(this, aDirtyRect);
 98299:   }
 79483: 
     1:   nsDisplayListCollection set;
     1:   nsresult rv;
     1:   {    
 95645:     nsDisplayListBuilder::AutoBuildingDisplayList rootSetter(aBuilder, true);
 30541:     nsDisplayListBuilder::AutoInTransformSetter
 30541:       inTransformSetter(aBuilder, inTransform);
     1:     rv = BuildDisplayList(aBuilder, dirtyRect, set);
     1:   }
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:     
     1:   if (aBuilder->IsBackgroundOnly()) {
     1:     set.BlockBorderBackgrounds()->DeleteAll();
     1:     set.Floats()->DeleteAll();
     1:     set.Content()->DeleteAll();
     1:     set.PositionedDescendants()->DeleteAll();
     1:     set.Outlines()->DeleteAll();
     1:   }
     1:   
     1:   // This z-order sort also sorts secondarily by content order. We need to do
     1:   // this so that boxes produced by the same element are placed together
     1:   // in the sort. Consider a position:relative inline element that breaks
     1:   // across lines and has absolutely positioned children; all the abs-pos
     1:   // children should be z-ordered after all the boxes for the position:relative
     1:   // element itself.
     1:   set.PositionedDescendants()->SortByZOrder(aBuilder, GetContent());
     1:   
     1:   nsRect overflowClip;
     1:   if (ApplyOverflowClipping(aBuilder, this, disp, &overflowClip)) {
 52293:     nscoord radii[8];
 52293:     this->GetPaddingBoxBorderRadii(radii);
 52293:     nsOverflowClipWrapper wrapper(this, overflowClip, radii,
 80486:                                   false, false);
     1:     rv = wrapper.WrapListsInPlace(aBuilder, this, set);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1:   // We didn't use overflowClip to restrict the dirty rect, since some of the
     1:   // descendants may not be clipped by it. Even if we end up with unnecessary
 33368:   // display items, they'll be pruned during ComputeVisibility.  
     1: 
     1:   nsDisplayList resultList;
     1:   // Now follow the rules of http://www.w3.org/TR/CSS21/zindex.html
     1:   // 1,2: backgrounds and borders
     1:   resultList.AppendToTop(set.BorderBackground());
     1:   // 3: negative z-index children.
     1:   for (;;) {
     1:     nsDisplayItem* item = set.PositionedDescendants()->GetBottom();
     1:     if (item) {
     1:       nsIFrame* f = item->GetUnderlyingFrame();
     1:       NS_ASSERTION(f, "After sorting, every item in the list should have an underlying frame");
     1:       if (nsLayoutUtils::GetZIndex(f) < 0) {
     1:         set.PositionedDescendants()->RemoveBottom();
     1:         resultList.AppendToTop(item);
     1:         continue;
     1:       }
     1:     }
     1:     break;
     1:   }
     1:   // 4: block backgrounds
     1:   resultList.AppendToTop(set.BlockBorderBackgrounds());
     1:   // 5: floats
     1:   resultList.AppendToTop(set.Floats());
  3660:   // 7: general content
     1:   resultList.AppendToTop(set.Content());
  3660:   // 7.5: outlines, in content tree order. We need to sort by content order
     1:   // because an element with outline that breaks and has children with outline
     1:   // might have placed child outline items between its own outline items.
     1:   // The element's outline items need to all come before any child outline
     1:   // items.
     1:   set.Outlines()->SortByContentOrder(aBuilder, GetContent());
102909: #ifdef DEBUG
     1:   DisplayDebugBorders(aBuilder, this, set);
     1: #endif
    67:   resultList.AppendToTop(set.Outlines());
  3660:   // 8, 9: non-negative z-index children
  3660:   resultList.AppendToTop(set.PositionedDescendants());
     1: 
 78033:   /* If we have absolute position clipping and we have, or will have, items to
 78033:    * be clipped, wrap the list in a clip wrapper.
 78033:    */
 91411:   if (applyClipPropClipping &&
 78033:       (!resultList.IsEmpty() || usingSVGEffects)) {
 91411:     nsDisplayClipPropWrapper wrapper(clipPropClip);
     1:     nsDisplayItem* item = wrapper.WrapList(aBuilder, this, &resultList);
     1:     if (!item)
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     // resultList was emptied
     1:     resultList.AppendToTop(item);
     1:   }
 78032:   /* If there are any SVG effects, wrap the list up in an SVG effects item
 78032:    * (which also handles CSS group opacity). Note that we create an SVG effects
 78032:    * item even if resultList is empty, since a filter can produce graphical
 78032:    * output even if the element being filtered wouldn't otherwise do so.
 78032:    */
 19125:   if (usingSVGEffects) {
 19214:     /* List now emptied, so add the new list to the top. */
 51260:     rv = resultList.AppendNewToTop(
 51260:         new (aBuilder) nsDisplaySVGEffects(aBuilder, this, &resultList));
 51260:     if (NS_FAILED(rv))
 51260:       return rv;
 78032:   }
 78032:   /* Else, if the list is non-empty and there is CSS group opacity without SVG
 78032:    * effects, wrap it up in an opacity item.
 54268:    */
107003:   else if (HasOpacity() &&
105956:            !nsSVGUtils::CanOptimizeOpacity(this) &&
105956:            !resultList.IsEmpty()) {
 51260:     rv = resultList.AppendNewToTop(
 51260:         new (aBuilder) nsDisplayOpacity(aBuilder, this, &resultList));
 51260:     if (NS_FAILED(rv))
 51260:       return rv;
 19214:   }
 19214: 
 77286:   /* If we're going to apply a transformation and don't have preserve-3d set, wrap 
 77286:    * everything in an nsDisplayTransform. If there's nothing in the list, don't add 
 77286:    * anything.
 77286:    *
 77286:    * For the preserve-3d case we want to individually wrap every child in the list with
 77286:    * a separate nsDisplayTransform instead. When the child is already an nsDisplayTransform,
 77286:    * we can skip this step, as the computed transform will already include our own.
 77286:    *
 77286:    * We also traverse into sublists created by nsDisplayWrapList or nsDisplayOpacity, so that
 77286:    * we find all the correct children.
 19214:    */
105956:   if (IsTransformed() && !resultList.IsEmpty()) {
 77286:     if (Preserves3DChildren()) {
 77286:       rv = WrapPreserve3DList(this, aBuilder, &resultList);
 77286:       if (NS_FAILED(rv))
 77286:         return rv;
 77286:     } else {
 51260:       rv = resultList.AppendNewToTop(
 51260:         new (aBuilder) nsDisplayTransform(aBuilder, this, &resultList));
 51260:       if (NS_FAILED(rv))
 51260:         return rv;
 19214:     }
 77286:   }
 19214: 
     1:   aList->AppendToTop(&resultList);
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsIFrame::BuildDisplayListForChild(nsDisplayListBuilder*   aBuilder,
     1:                                    nsIFrame*               aChild,
     1:                                    const nsRect&           aDirtyRect,
     1:                                    const nsDisplayListSet& aLists,
108991:                                    uint32_t                aFlags) {
     1:   // If painting is restricted to just the background of the top level frame,
     1:   // then we have nothing to do here.
     1:   if (aBuilder->IsBackgroundOnly())
     1:     return NS_OK;
     1: 
 81616:   nsIFrame* child = aChild;
 81616:   if (child->GetStateBits() & NS_FRAME_TOO_DEEP_IN_FRAME_TREE)
     1:     return NS_OK;
     1:   
105956:   bool isSVG = (child->GetStateBits() & NS_FRAME_SVG_LAYOUT);
105956: 
 80486:   // true if this is a real or pseudo stacking context
 79445:   bool pseudoStackingContext =
     1:     (aFlags & DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT) != 0;
105956:   if (!isSVG &&
105956:       (aFlags & DISPLAY_CHILD_INLINE) &&
 81616:       !child->IsFrameOfType(eLineParticipant)) {
     1:     // child is a non-inline frame in an inline context, i.e.,
     1:     // it acts like inline-block or inline-table. Therefore it is a
     1:     // pseudo-stacking-context.
 80486:     pseudoStackingContext = true;
     1:   }
     1: 
     1:   // dirty rect in child-relative coordinates
 81616:   nsRect dirty = aDirtyRect - child->GetOffsetTo(this);
 81616: 
 81616:   nsIAtom* childType = child->GetType();
     1:   if (childType == nsGkAtoms::placeholderFrame) {
 81616:     nsPlaceholderFrame* placeholder = static_cast<nsPlaceholderFrame*>(child);
 81616:     child = placeholder->GetOutOfFlowFrame();
 81616:     NS_ASSERTION(child, "No out of flow frame?");
 81617:     // If 'child' is a pushed float then it's owned by a block that's not an
 81617:     // ancestor of the placeholder, and it will be painted by that block and
 81617:     // should not be painted through the placeholder.
 81617:     if (!child || nsLayoutUtils::IsPopup(child) ||
 81617:         (child->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT))
     1:       return NS_OK;
     1:     // Make sure that any attempt to use childType below is disappointed. We
     1:     // could call GetType again but since we don't currently need it, let's
     1:     // avoid the virtual call.
106838:     childType = nullptr;
  3724:     // Recheck NS_FRAME_TOO_DEEP_IN_FRAME_TREE
 81616:     if (child->GetStateBits() & NS_FRAME_TOO_DEEP_IN_FRAME_TREE)
     1:       return NS_OK;
  3233:     nsRect* savedDirty = static_cast<nsRect*>
 81616:       (child->Properties().Get(nsDisplayListBuilder::OutOfFlowDirtyRectProperty()));
     1:     if (savedDirty) {
     1:       dirty = *savedDirty;
     1:     } else {
     1:       // The out-of-flow frame did not intersect the dirty area. We may still
     1:       // need to traverse into it, since it may contain placeholders we need
     1:       // to enter to reach other out-of-flow frames that are visible.
 68639:       dirty.SetEmpty();
     1:     }
 80486:     pseudoStackingContext = true;
 79483:   }
 98299:   if (child->Preserves3D()) {
 98299:     nsRect* savedDirty = static_cast<nsRect*>
 98299:       (child->Properties().Get(nsDisplayListBuilder::Preserve3DDirtyRectProperty()));
 98299:     if (savedDirty) {
 98299:       dirty = *savedDirty;
 98299:     } else {
 98299:       dirty.SetEmpty();
 98299:     }
 98299:   }
 79483: 
 81616:   child->MarkAbsoluteFramesForDisplayList(aBuilder, dirty);
 79483: 
 79483:   if (childType != nsGkAtoms::placeholderFrame &&
 79483:       aBuilder->GetSelectedFramesOnly() &&
 81616:       child->IsLeaf() &&
 85101:       !aChild->IsSelected()) {
 47337:     return NS_OK;
 47337:   }
 47337: 
 58774:   if (aBuilder->GetIncludeAllOutOfFlows() &&
 81616:       (child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
 81616:     dirty = child->GetVisualOverflowRect();
 81616:   } else if (!(child->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO)) {
 81616:     // No need to descend into child to catch placeholders for visible
     1:     // positioned stuff. So see if we can short-circuit frame traversal here.
     1: 
 81616:     // We can stop if child's frame subtree's intersection with the
 26699:     // dirty area is empty.
     1:     // If the child is a scrollframe that we want to ignore, then we need
     1:     // to descend into it because its scrolled child may intersect the dirty
     1:     // area even if the scrollframe itself doesn't.
 81616:     if (child != aBuilder->GetIgnoreScrollFrame()) {
 26699:       nsRect childDirty;
 94996:       if (!childDirty.IntersectRect(dirty, child->GetVisualOverflowRect()))
     1:         return NS_OK;
 26699:       // Usually we could set dirty to childDirty now but there's no
 26699:       // benefit, and it can be confusing. It can especially confuse
 26699:       // situations where we're going to ignore a scrollframe's clipping;
 26699:       // we wouldn't want to clip the dirty area to the scrollframe's
 26699:       // bounds in that case.
 26699:     }
     1:   }
     1: 
     1:   // XXX need to have inline-block and inline-table set pseudoStackingContext
     1:   
     1:   const nsStyleDisplay* ourDisp = GetStyleDisplay();
     1:   // REVIEW: Taken from nsBoxFrame::Paint
     1:   // Don't paint our children if the theme object is a leaf.
     1:   if (IsThemed(ourDisp) &&
   238:       !PresContext()->GetTheme()->WidgetIsContainer(ourDisp->mAppearance))
     1:     return NS_OK;
     1: 
 19214:   // Child is composited if it's transformed, partially transparent, or has
 19214:   // SVG effects.
 81616:   const nsStyleDisplay* disp = child->GetStyleDisplay();
107003:   bool isVisuallyAtomic = child->HasOpacity()
 81616:     || child->IsTransformed()
 81616:     || nsSVGIntegrationUtils::UsingEffectsForFrame(child);
 71013: 
107225:   bool isPositioned = !isSVG && disp->IsPositioned(child);
107224:   if (isVisuallyAtomic || isPositioned || (!isSVG && disp->IsFloating(child)) ||
105956:       ((disp->mClipFlags & NS_STYLE_CLIP_RECT) &&
106560:        IsSVGContentWithCSSClip(child)) ||
 32107:       (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
     1:     // If you change this, also change IsPseudoStackingContextFromStyle()
 80486:     pseudoStackingContext = true;
     1:   }
     1: 
106380:   // This controls later whether we build an nsDisplayWrapList or an
106380:   // nsDisplayFixedPosition. We check if we're already building a fixed-pos
106380:   // item and disallow nesting, to prevent the situation of bug #769541
106380:   // occurring.
106380:   bool buildFixedPositionItem = disp->mPosition == NS_STYLE_POSITION_FIXED
106380:     && !child->GetParent()->GetParent() && !isSVG && !aBuilder->IsInFixedPosition();
106380: 
 95645:   nsDisplayListBuilder::AutoBuildingDisplayList
106380:     buildingForChild(aBuilder, child, pseudoStackingContext, buildFixedPositionItem);
 95645: 
     1:   nsRect overflowClip;
 52293:   nscoord overflowClipRadii[8];
 79445:   bool applyOverflowClip =
 81616:     ApplyOverflowClipping(aBuilder, child, disp, &overflowClip);
 52293:   if (applyOverflowClip) {
 81616:     child->GetPaddingBoxBorderRadii(overflowClipRadii);
 52293:   }
     1:   // Don't use overflowClip to restrict the dirty rect, since some of the
     1:   // descendants may not be clipped by it. Even if we end up with unnecessary
 33368:   // display items, they'll be pruned during ComputeVisibility. Note that
     1:   // this overflow-clipping here only applies to overflow:-moz-hidden-unscrollable;
     1:   // overflow:hidden etc creates an nsHTML/XULScrollFrame which does its own
     1:   // clipping.
     1: 
     1:   nsresult rv;
     1:   if (!pseudoStackingContext) {
     1:     // THIS IS THE COMMON CASE.
     1:     // Not a pseudo or real stacking context. Do the simple thing and
     1:     // return early.
     1:     if (applyOverflowClip) {
 81616:       rv = BuildDisplayListWithOverflowClip(aBuilder, child, dirty, aLists,
 52293:                                             overflowClip, overflowClipRadii);
     1:     } else {
 81616:       rv = child->BuildDisplayList(aBuilder, dirty, aLists);
     1:       if (NS_SUCCEEDED(rv)) {
 81616:         rv = aBuilder->DisplayCaret(child, dirty, aLists.Content());
     1:       }
     1:     }
102909: #ifdef DEBUG
 81616:     DisplayDebugBorders(aBuilder, child, aLists);
     1: #endif
     1:     return rv;
     1:   }
     1:   
     1:   nsDisplayList list;
     1:   nsDisplayList extraPositionedDescendants;
 81616:   const nsStylePosition* pos = child->GetStylePosition();
     1:   if ((isPositioned && pos->mZIndex.GetUnit() == eStyleUnit_Integer) ||
 78035:       isVisuallyAtomic || (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
     1:     // True stacking context
 81616:     rv = child->BuildDisplayListForStackingContext(aBuilder, dirty, &list);
     1:     if (NS_SUCCEEDED(rv)) {
 81616:       rv = aBuilder->DisplayCaret(child, dirty, &list);
     1:     }
     1:   } else {
     1:     nsRect clipRect;
 91411:     bool applyClipPropClipping =
 91411:         ApplyClipPropClipping(aBuilder, disp, child, &clipRect);
  7046:     // A pseudo-stacking context (e.g., a positioned element with z-index auto).
 78032:     // We allow positioned descendants of the child to escape to our parent
 78032:     // stacking context's positioned descendant list, because they might be
     1:     // z-index:non-auto
     1:     nsDisplayListCollection pseudoStack;
     1:     nsRect clippedDirtyRect = dirty;
 91411:     if (applyClipPropClipping) {
     1:       // clipRect is in builder-reference-frame coordinates,
 81616:       // dirty/clippedDirtyRect are in child coordinates
     1:       clippedDirtyRect.IntersectRect(clippedDirtyRect,
 81616:                                      clipRect - aBuilder->ToReferenceFrame(child));
     1:     }
     1:     
     1:     if (applyOverflowClip) {
 81616:       rv = BuildDisplayListWithOverflowClip(aBuilder, child, clippedDirtyRect,
 52293:                                             pseudoStack, overflowClip,
 52293:                                             overflowClipRadii);
     1:     } else {
 81616:       rv = child->BuildDisplayList(aBuilder, clippedDirtyRect, pseudoStack);
     1:       if (NS_SUCCEEDED(rv)) {
 81616:         rv = aBuilder->DisplayCaret(child, dirty, pseudoStack.Content());
     1:       }
     1:     }
     1:     
     1:     if (NS_SUCCEEDED(rv)) {
 91411:       if (applyClipPropClipping) {
 91411:         nsDisplayClipPropWrapper wrapper(clipRect);
 81616:         rv = wrapper.WrapListsInPlace(aBuilder, child, pseudoStack);
     1:       }
     1:     }
     1:     list.AppendToTop(pseudoStack.BorderBackground());
     1:     list.AppendToTop(pseudoStack.BlockBorderBackgrounds());
     1:     list.AppendToTop(pseudoStack.Floats());
     1:     list.AppendToTop(pseudoStack.Content());
  3660:     list.AppendToTop(pseudoStack.Outlines());
     1:     extraPositionedDescendants.AppendToTop(pseudoStack.PositionedDescendants());
102909: #ifdef DEBUG
 81616:     DisplayDebugBorders(aBuilder, child, aLists);
     1: #endif
     1:   }
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:     
 78035:   if (isPositioned || isVisuallyAtomic ||
     1:       (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
     1:     // Genuine stacking contexts, and positioned pseudo-stacking-contexts,
     1:     // go in this level.
 95487:     if (!list.IsEmpty()) {
103084:       // Make sure the root of a fixed position frame sub-tree gets the
103084:       // correct displaylist item type.
105776:       nsDisplayItem* item;
106380:       if (buildFixedPositionItem) {
106380:         item = new (aBuilder) nsDisplayFixedPosition(aBuilder, child, child, &list);
103084:       } else {
105776:         item = new (aBuilder) nsDisplayWrapList(aBuilder, child, &list);
105776:       }
105956:       if (isSVG) {
105956:         rv = aLists.Content()->AppendNewToTop(item);
105956:       } else {
105776:         rv = aLists.PositionedDescendants()->AppendNewToTop(item);
105956:       }
     1:       NS_ENSURE_SUCCESS(rv, rv);
106380: 
106380:       // Make sure that extra positioned descendants don't escape having
106380:       // their fixed-position metadata applied to them.
106380:       if (buildFixedPositionItem) {
106380:         while (!extraPositionedDescendants.IsEmpty()) {
106380:           item = extraPositionedDescendants.RemoveBottom();
106380:           nsDisplayList fixedPosDescendantList;
106380:           fixedPosDescendantList.AppendToTop(item);
106380:           aLists.PositionedDescendants()->AppendNewToTop(
106380:               new (aBuilder) nsDisplayFixedPosition(aBuilder, item->GetUnderlyingFrame(),
106380:                                                     child, &fixedPosDescendantList));
106380:         }
106380:       }
 95487:     }
107224:   } else if (!isSVG && disp->IsFloating(child)) {
 95487:     if (!list.IsEmpty()) {
     1:       rv = aLists.Floats()->AppendNewToTop(new (aBuilder)
 81616:           nsDisplayWrapList(aBuilder, child, &list));
     1:       NS_ENSURE_SUCCESS(rv, rv);
 95487:     }
     1:   } else {
     1:     aLists.Content()->AppendToTop(&list);
     1:   }
     1:   // We delay placing the positioned descendants of positioned frames to here,
     1:   // because in the absence of z-index this is the correct order for them.
     1:   // This doesn't affect correctness because the positioned descendants list
     1:   // is sorted by z-order and content in BuildDisplayListForStackingContext,
     1:   // but it means that sort routine needs to do less work.
     1:   aLists.PositionedDescendants()->AppendToTop(&extraPositionedDescendants);
     1:   return NS_OK;
     1: }
     1: 
 52294: void
 79483: nsIFrame::MarkAbsoluteFramesForDisplayList(nsDisplayListBuilder* aBuilder,
 79483:                                            const nsRect& aDirtyRect)
 79483: {
 79483:   if (IsAbsoluteContainer()) {
 79483:     aBuilder->MarkFramesForDisplayList(this, GetAbsoluteContainingBlock()->GetChildList(), aDirtyRect);
 79483:   }
 79483: }
 79483: 
 79483: void
 52294: nsIFrame::WrapReplacedContentForBorderRadius(nsDisplayListBuilder* aBuilder,
 52294:                                              nsDisplayList* aFromList,
 52294:                                              const nsDisplayListSet& aToLists)
 52294: {
 52294:   nscoord radii[8];
 52294:   if (GetContentBoxBorderRadii(radii)) {
 52294:     // If we have a border-radius, we have to clip our content to that
 52294:     // radius.
 52294:     nsDisplayListCollection set;
 52294:     set.Content()->AppendToTop(aFromList);
 52294:     nsRect clipRect = GetContentRect() - GetPosition() +
 52294:                       aBuilder->ToReferenceFrame(this);
 80486:     OverflowClip(aBuilder, set, aToLists, clipRect, radii, false, true);
 52294: 
 52294:     return;
 52294:   }
 52294: 
 52294:   aToLists.Content()->AppendToTop(aFromList);
 52294: }
 52294: 
     1: NS_IMETHODIMP  
 79435: nsFrame::GetContentForEvent(nsEvent* aEvent,
     1:                             nsIContent** aContent)
     1: {
 32180:   nsIFrame* f = nsLayoutUtils::GetNonGeneratedAncestor(this);
 32180:   *aContent = f->GetContent();
     1:   NS_IF_ADDREF(*aContent);
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsFrame::FireDOMEvent(const nsAString& aDOMEventName, nsIContent *aContent)
     1: {
 25812:   nsIContent* target = aContent ? aContent : mContent;
 25812: 
 25812:   if (target) {
 84833:     nsRefPtr<nsAsyncDOMEvent> event =
 84833:       new nsAsyncDOMEvent(target, aDOMEventName, true, false);
 72509:     if (NS_FAILED(event->PostDOMEvent()))
 84833:       NS_WARNING("Failed to dispatch nsAsyncDOMEvent");
     1:   }
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFrame::HandleEvent(nsPresContext* aPresContext, 
     1:                      nsGUIEvent*     aEvent,
     1:                      nsEventStatus*  aEventStatus)
     1: {
     1: 
104398:   if (aEvent->message == NS_MOUSE_MOVE || aEvent->message == NS_TOUCH_MOVE) {
     1:     return HandleDrag(aPresContext, aEvent, aEventStatus);
     1:   }
     1: 
104398:   if ((aEvent->eventStructType == NS_MOUSE_EVENT &&
104398:       static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton) ||
104398:       aEvent->eventStructType == NS_TOUCH_EVENT) {
104398:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN || aEvent->message == NS_TOUCH_START) {
     1:       HandlePress(aPresContext, aEvent, aEventStatus);
104398:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP || aEvent->message == NS_TOUCH_END) {
     1:       HandleRelease(aPresContext, aEvent, aEventStatus);
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
  8295: nsFrame::GetDataForTableSelection(const nsFrameSelection *aFrameSelection,
     1:                                   nsIPresShell *aPresShell, nsMouseEvent *aMouseEvent, 
108991:                                   nsIContent **aParentContent, int32_t *aContentOffset, int32_t *aTarget)
     1: {
     1:   if (!aFrameSelection || !aPresShell || !aMouseEvent || !aParentContent || !aContentOffset || !aTarget)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
106838:   *aParentContent = nullptr;
     1:   *aContentOffset = 0;
     1:   *aTarget = 0;
     1: 
108991:   int16_t displaySelection = aPresShell->GetSelectionFlags();
     1: 
 79445:   bool selectingTableCells = aFrameSelection->GetTableCellSelection();
     1: 
     1:   // DISPLAY_ALL means we're in an editor.
     1:   // If already in cell selection mode, 
     1:   //  continue selecting with mouse drag or end on mouse up,
     1:   //  or when using shift key to extend block of cells
     1:   //  (Mouse down does normal selection unless Ctrl/Cmd is pressed)
 79445:   bool doTableSelection =
     1:      displaySelection == nsISelectionDisplay::DISPLAY_ALL && selectingTableCells &&
     1:      (aMouseEvent->message == NS_MOUSE_MOVE ||
     1:       (aMouseEvent->message == NS_MOUSE_BUTTON_UP &&
     1:        aMouseEvent->button == nsMouseEvent::eLeftButton) ||
 96893:       aMouseEvent->IsShift());
     1: 
     1:   if (!doTableSelection)
     1:   {  
     1:     // In Browser, special 'table selection' key must be pressed for table selection
     1:     // or when just Shift is pressed and we're already in table/cell selection mode
  6499: #ifdef XP_MACOSX
 96893:     doTableSelection = aMouseEvent->IsMeta() || (aMouseEvent->IsShift() && selectingTableCells);
     1: #else
 96893:     doTableSelection = aMouseEvent->IsControl() || (aMouseEvent->IsShift() && selectingTableCells);
     1: #endif
     1:   }
     1:   if (!doTableSelection) 
     1:     return NS_OK;
     1: 
     1:   // Get the cell frame or table frame (or parent) of the current content node
     1:   nsIFrame *frame = this;
 79445:   bool foundCell = false;
 79445:   bool foundTable = false;
     1: 
     1:   // Get the limiting node to stop parent frame search
     1:   nsIContent* limiter = aFrameSelection->GetLimiter();
     1: 
 56876:   // If our content node is an ancestor of the limiting node,
 56876:   // we should stop the search right now.
 56876:   if (limiter && nsContentUtils::ContentIsDescendantOf(limiter, GetContent()))
 56876:     return NS_OK;
 56876: 
     1:   //We don't initiate row/col selection from here now,
     1:   //  but we may in future
 79445:   //bool selectColumn = false;
 79445:   //bool selectRow = false;
     1:   
 39668:   while (frame)
     1:   {
     1:     // Check for a table cell by querying to a known CellFrame interface
 23554:     nsITableCellLayout *cellElement = do_QueryFrame(frame);
 23554:     if (cellElement)
     1:     {
 80486:       foundCell = true;
     1:       //TODO: If we want to use proximity to top or left border
     1:       //      for row and column selection, this is the place to do it
     1:       break;
     1:     }
     1:     else
     1:     {
     1:       // If not a cell, check for table
     1:       // This will happen when starting frame is the table or child of a table,
     1:       //  such as a row (we were inbetween cells or in table border)
 23554:       nsITableLayout *tableElement = do_QueryFrame(frame);
 23554:       if (tableElement)
     1:       {
 80486:         foundTable = true;
     1:         //TODO: How can we select row when along left table edge
     1:         //  or select column when along top edge?
     1:         break;
     1:       } else {
     1:         frame = frame->GetParent();
     1:         // Stop if we have hit the selection's limiting content node
     1:         if (frame && frame->GetContent() == limiter)
     1:           break;
     1:       }
     1:     }
     1:   }
     1:   // We aren't in a cell or table
     1:   if (!foundCell && !foundTable) return NS_OK;
     1: 
     1:   nsIContent* tableOrCellContent = frame->GetContent();
     1:   if (!tableOrCellContent) return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIContent> parentContent = tableOrCellContent->GetParent();
     1:   if (!parentContent) return NS_ERROR_FAILURE;
     1: 
108991:   int32_t offset = parentContent->IndexOf(tableOrCellContent);
     1:   // Not likely?
     1:   if (offset < 0) return NS_ERROR_FAILURE;
     1: 
     1:   // Everything is OK -- set the return values
     1:   *aParentContent = parentContent;
     1:   NS_ADDREF(*aParentContent);
     1: 
     1:   *aContentOffset = offset;
     1: 
     1: #if 0
     1:   if (selectRow)
     1:     *aTarget = nsISelectionPrivate::TABLESELECTION_ROW;
     1:   else if (selectColumn)
     1:     *aTarget = nsISelectionPrivate::TABLESELECTION_COLUMN;
     1:   else 
     1: #endif
     1:   if (foundCell)
     1:     *aTarget = nsISelectionPrivate::TABLESELECTION_CELL;
     1:   else if (foundTable)
     1:     *aTarget = nsISelectionPrivate::TABLESELECTION_TABLE;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsFrame::IsSelectable(bool* aSelectable, uint8_t* aSelectStyle) const
     1: {
     1:   if (!aSelectable) //it's ok if aSelectStyle is null
     1:     return NS_ERROR_NULL_POINTER;
     1: 
     1:   // Like 'visibility', we must check all the parents: if a parent
     1:   // is not selectable, none of its children is selectable.
     1:   //
     1:   // The -moz-all value acts similarly: if a frame has 'user-select:-moz-all',
     1:   // all its children are selectable, even those with 'user-select:none'.
     1:   //
     1:   // As a result, if 'none' and '-moz-all' are not present in the frame hierarchy,
     1:   // aSelectStyle returns the first style that is not AUTO. If these values
     1:   // are present in the frame hierarchy, aSelectStyle returns the style of the
     1:   // topmost parent that has either 'none' or '-moz-all'.
     1:   //
     1:   // For instance, if the frame hierarchy is:
     1:   //    AUTO     -> _MOZ_ALL -> NONE -> TEXT,     the returned value is _MOZ_ALL
     1:   //    TEXT     -> NONE     -> AUTO -> _MOZ_ALL, the returned value is NONE
     1:   //    _MOZ_ALL -> TEXT     -> AUTO -> AUTO,     the returned value is _MOZ_ALL
     1:   //    AUTO     -> CELL     -> TEXT -> AUTO,     the returned value is TEXT
     1:   //
108991:   uint8_t selectStyle  = NS_STYLE_USER_SELECT_AUTO;
     1:   nsIFrame* frame      = (nsIFrame*)this;
     1: 
     1:   while (frame) {
     1:     const nsStyleUIReset* userinterface = frame->GetStyleUIReset();
     1:     switch (userinterface->mUserSelect) {
     1:       case NS_STYLE_USER_SELECT_ALL:
     1:       case NS_STYLE_USER_SELECT_NONE:
     1:       case NS_STYLE_USER_SELECT_MOZ_ALL:
     1:         // override the previous values
     1:         selectStyle = userinterface->mUserSelect;
     1:         break;
     1:       default:
     1:         // otherwise return the first value which is not 'auto'
     1:         if (selectStyle == NS_STYLE_USER_SELECT_AUTO) {
     1:           selectStyle = userinterface->mUserSelect;
     1:         }
     1:         break;
     1:     }
     1:     frame = frame->GetParent();
     1:   }
     1: 
     1:   // convert internal values to standard values
     1:   if (selectStyle == NS_STYLE_USER_SELECT_AUTO)
     1:     selectStyle = NS_STYLE_USER_SELECT_TEXT;
     1:   else
     1:   if (selectStyle == NS_STYLE_USER_SELECT_MOZ_ALL)
     1:     selectStyle = NS_STYLE_USER_SELECT_ALL;
     1:   else
     1:   if (selectStyle == NS_STYLE_USER_SELECT_MOZ_NONE)
     1:     selectStyle = NS_STYLE_USER_SELECT_NONE;
     1: 
     1:   // return stuff
     1:   if (aSelectStyle)
     1:     *aSelectStyle = selectStyle;
     1:   if (mState & NS_FRAME_GENERATED_CONTENT)
 80486:     *aSelectable = false;
 79843:   else
 79843:     *aSelectable = (selectStyle != NS_STYLE_USER_SELECT_NONE);
     1:   return NS_OK;
     1: }
     1: 
     1: /**
     1:   * Handles the Mouse Press Event for the frame
     1:  */
     1: NS_IMETHODIMP
     1: nsFrame::HandlePress(nsPresContext* aPresContext, 
     1:                      nsGUIEvent*     aEvent,
     1:                      nsEventStatus*  aEventStatus)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aEventStatus);
     1:   if (nsEventStatus_eConsumeNoDefault == *aEventStatus) {
     1:     return NS_OK;
     1:   }
     1: 
104401:   NS_ENSURE_ARG_POINTER(aEvent);
104401:   if (aEvent->eventStructType == NS_TOUCH_EVENT) {
104401:     return NS_OK;
104401:   }
104401: 
     1:   //We often get out of sync state issues with mousedown events that
     1:   //get interrupted by alerts/dialogs.
     1:   //Check with the ESM to see if we should process this one
 68780:   if (!aPresContext->EventStateManager()->EventStatusOK(aEvent)) 
     1:     return NS_OK;
     1: 
     1:   nsresult rv;
     1:   nsIPresShell *shell = aPresContext->GetPresShell();
     1:   if (!shell)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   // if we are in Navigator and the click is in a draggable node, we don't want
     1:   // to start selection because we don't want to interfere with a potential
     1:   // drag of said node and steal all its glory.
108991:   int16_t isEditor = shell->GetSelectionFlags();
 39668:   //weaaak. only the editor can display frame selection not just text and images
     1:   isEditor = isEditor == nsISelectionDisplay::DISPLAY_ALL;
     1: 
     1:   nsInputEvent* keyEvent = (nsInputEvent*)aEvent;
 96893:   if (!keyEvent->IsAlt()) {
     1:     
     1:     for (nsIContent* content = mContent; content;
     1:          content = content->GetParent()) {
 14472:       if (nsContentUtils::ContentIsDraggable(content) &&
 14472:           !content->IsEditable()) {
     1:         // coordinate stuff is the fix for bug #55921
     1:         if ((mRect - GetPosition()).Contains(
     1:                nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this)))
     1:           return NS_OK;
     1:       }
     1:     }
 14472:   }
     1: 
 74711:   // check whether style allows selection
 74711:   // if not, don't tell selection the mouse event even occurred.  
 79445:   bool    selectable;
108991:   uint8_t selectStyle;
 74711:   rv = IsSelectable(&selectable, &selectStyle);
 74711:   if (NS_FAILED(rv)) return rv;
 74711:   
 74711:   // check for select: none
 74711:   if (!selectable)
 74711:     return NS_OK;
 74711: 
 74711:   // When implementing NS_STYLE_USER_SELECT_ELEMENT, NS_STYLE_USER_SELECT_ELEMENTS and
 74711:   // NS_STYLE_USER_SELECT_TOGGLE, need to change this logic
 79445:   bool useFrameSelection = (selectStyle == NS_STYLE_USER_SELECT_TEXT);
 74711: 
 74711:   // If the mouse is dragged outside the nearest enclosing scrollable area
 73455:   // while making a selection, the area will be scrolled. To do this, capture
 74711:   // the mouse on the nearest scrollable frame. If there isn't a scrollable
 74711:   // frame, or something else is already capturing the mouse, there's no
 74711:   // reason to capture.
 74711:   if (!nsIPresShell::GetCapturingContent()) {
 74711:     nsIFrame* checkFrame = this;
106838:     nsIScrollableFrame *scrollFrame = nullptr;
 74711:     while (checkFrame) {
 74711:       scrollFrame = do_QueryFrame(checkFrame);
 74711:       if (scrollFrame) {
 74711:         nsIPresShell::SetCapturingContent(checkFrame->GetContent(), CAPTURE_IGNOREALLOWED);
 74711:         break;
 74711:       }
 74711:       checkFrame = checkFrame->GetParent();
 74711:     }
 74711:   }
 74711: 
 74711:   // XXX This is screwy; it really should use the selection frame, not the
 74711:   // event frame
106838:   const nsFrameSelection* frameselection = nullptr;
 74711:   if (useFrameSelection)
 74711:     frameselection = GetConstFrameSelection();
 74711:   else
 74711:     frameselection = shell->ConstFrameSelection();
 74711: 
 74711:   if (!frameselection || frameselection->GetDisplaySelection() == nsISelectionController::SELECTION_OFF)
     1:     return NS_OK;//nothing to do we cannot affect selection from here
     1: 
     1:   nsMouseEvent *me = (nsMouseEvent *)aEvent;
     1: 
  6499: #ifdef XP_MACOSX
 96893:   if (me->IsControl())
 84939:     return NS_OK;//short circuit. hard coded for mac due to time restraints.
 96893:   bool control = me->IsMeta();
 20590: #else
 96893:   bool control = me->IsControl();
     1: #endif
 20590: 
 74711:   nsRefPtr<nsFrameSelection> fc = const_cast<nsFrameSelection*>(frameselection);
     1:   if (me->clickCount > 1)
     1:   {
  8295:     // These methods aren't const but can't actually delete anything,
  8295:     // so no need for nsWeakFrame.
 80486:     fc->SetMouseDownState(true);
 80486:     fc->SetMouseDoubleDown(true);
 20590:     return HandleMultiplePress(aPresContext, aEvent, aEventStatus, control);
     1:   }
     1: 
 26712:   nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
 99687:   ContentOffsets offsets = GetContentOffsetsFromPoint(pt, SKIP_HIDDEN);
 26712: 
     1:   if (!offsets.content)
     1:     return NS_ERROR_FAILURE;
     1: 
 84939:   // On touchables devices, touch the screen is usually a pan action,
108909:   // so let's reposition the caret if needed but do not select text
108909:   // if the touch did not happen over an editable element.  Otherwise,
108909:   // let the user move the caret by tapping and dragging.
108627:   if (!offsets.content->IsEditable() &&
108627:       Preferences::GetBool("browser.ignoreNativeFrameTextSelection", false)) {
 84939:     return fc->HandleClick(offsets.content, offsets.StartOffset(),
 84939:                            offsets.EndOffset(), false, false,
 84939:                            offsets.associateWithNext);
 84939:   }
 84939: 
     1:   // Let Ctrl/Cmd+mouse down do table selection instead of drag initiation
     1:   nsCOMPtr<nsIContent>parentContent;
108991:   int32_t  contentOffset;
108991:   int32_t target;
 74711:   rv = GetDataForTableSelection(frameselection, shell, me, getter_AddRefs(parentContent), &contentOffset, &target);
     1:   if (NS_SUCCEEDED(rv) && parentContent)
     1:   {
 80486:     fc->SetMouseDownState(true);
 74711:     return fc->HandleTableSelection(parentContent, contentOffset, target, me);
 74711:   }
 74711: 
 74711:   fc->SetDelayedCaretData(0);
     1: 
     1:   // Check if any part of this frame is selected, and if the
     1:   // user clicked inside the selected region. If so, we delay
     1:   // starting a new selection since the user may be trying to
     1:   // drag the selected region to some other app.
     1: 
     1:   SelectionDetails *details = 0;
 85101:   if (GetContent()->IsSelectionDescendant())
     1:   {
 79445:     bool inSelection = false;
 74711:     details = frameselection->LookUpSelection(offsets.content, 0,
 80486:         offsets.EndOffset(), false);
     1: 
     1:     //
     1:     // If there are any details, check to see if the user clicked
     1:     // within any selected region of the frame.
     1:     //
     1: 
     1:     SelectionDetails *curDetail = details;
     1: 
     1:     while (curDetail)
     1:     {
     1:       //
     1:       // If the user clicked inside a selection, then just
     1:       // return without doing anything. We will handle placing
     1:       // the caret later on when the mouse is released. We ignore
 69254:       // the spellcheck, find and url formatting selections.
     1:       //
     1:       if (curDetail->mType != nsISelectionController::SELECTION_SPELLCHECK &&
 18761:           curDetail->mType != nsISelectionController::SELECTION_FIND &&
 69254:           curDetail->mType != nsISelectionController::SELECTION_URLSECONDARY &&
     1:           curDetail->mStart <= offsets.StartOffset() &&
     1:           offsets.EndOffset() <= curDetail->mEnd)
     1:       {
 80486:         inSelection = true;
 20685:       }
 20685: 
 20685:       SelectionDetails *nextDetail = curDetail->mNext;
 20685:       delete curDetail;
 20685:       curDetail = nextDetail;
 20685:     }
 20685: 
 20685:     if (inSelection) {
 80486:       fc->SetMouseDownState(false);
 74711:       fc->SetDelayedCaretData(me);
     1:       return NS_OK;
     1:     }
     1:   }
     1: 
 80486:   fc->SetMouseDownState(true);
     1: 
  8295:   // Do not touch any nsFrame members after this point without adding
  8295:   // weakFrame checks.
 74711:   rv = fc->HandleClick(offsets.content, offsets.StartOffset(),
 96893:                        offsets.EndOffset(), me->IsShift(), control,
     1:                        offsets.associateWithNext);
     1: 
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   if (offsets.offset != offsets.secondaryOffset)
 74711:     fc->MaintainSelection();
     1: 
 96893:   if (isEditor && !me->IsShift() &&
     1:       (offsets.EndOffset() - offsets.StartOffset()) == 1)
     1:   {
     1:     // A single node is selected and we aren't extending an existing
     1:     // selection, which means the user clicked directly on an object (either
     1:     // -moz-user-select: all or a non-text node without children).
     1:     // Therefore, disable selection extension during mouse moves.
     1:     // XXX This is a bit hacky; shouldn't editor be able to deal with this?
 80486:     fc->SetMouseDownState(false);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
111609: /*
111609:  * SelectByTypeAtPoint
111609:  *
111609:  * Search for selectable content at point and attempt to select
111609:  * based on the start and end selection behaviours.
111609:  *
111609:  * @param aPresContext Presentation context
111609:  * @param aPoint Point at which selection will occur. Coordinates
111609:  * should be relaitve to this frame.
111609:  * @param aBeginAmountType, aEndAmountType Selection behavior, see
111609:  * nsIFrame for definitions.
111609:  * @param aSelectFlags Selection flags defined in nsFame.h.
111609:  * @return success or failure at finding suitable content to select.
111609:  */
111609: nsresult
111609: nsFrame::SelectByTypeAtPoint(nsPresContext* aPresContext,
111609:                              const nsPoint& aPoint,
111609:                              nsSelectionAmount aBeginAmountType,
111609:                              nsSelectionAmount aEndAmountType,
111609:                              uint32_t aSelectFlags)
111609: {
111609:   NS_ENSURE_ARG_POINTER(aPresContext);
111609: 
111609:   // No point in selecting if selection is turned off
111609:   if (DisplaySelection(aPresContext) == nsISelectionController::SELECTION_OFF)
111609:     return NS_OK;
111609: 
111609:   ContentOffsets offsets = GetContentOffsetsFromPoint(aPoint, SKIP_HIDDEN);
111609:   if (!offsets.content)
111609:     return NS_ERROR_FAILURE;
111609: 
111609:   nsIFrame* theFrame;
111609:   int32_t offset;
111609:   const nsFrameSelection* frameSelection =
111609:     PresContext()->GetPresShell()->ConstFrameSelection();
111609:   theFrame = frameSelection->
111609:     GetFrameForNodeOffset(offsets.content, offsets.offset,
111609:                           nsFrameSelection::HINT(offsets.associateWithNext),
111609:                           &offset);
111609:   if (!theFrame)
111609:     return NS_ERROR_FAILURE;
111609: 
111609:   nsFrame* frame = static_cast<nsFrame*>(theFrame);
111609:   return frame->PeekBackwardAndForward(aBeginAmountType, aEndAmountType,
111609:                                        offsets.offset, aPresContext,
111609:                                        aBeginAmountType != eSelectWord,
111609:                                        aSelectFlags);
111609: }
111609: 
     1: /**
     1:   * Multiple Mouse Press -- line or paragraph selection -- for the frame.
     1:   * Wouldn't it be nice if this didn't have to be hardwired into Frame code?
     1:  */
     1: NS_IMETHODIMP
     1: nsFrame::HandleMultiplePress(nsPresContext* aPresContext,
     1:                              nsGUIEvent*    aEvent,
 20590:                              nsEventStatus* aEventStatus,
 79445:                              bool           aControlHeld)
     1: {
111609:   NS_ENSURE_ARG_POINTER(aEvent);
     1:   NS_ENSURE_ARG_POINTER(aEventStatus);
111609: 
111609:   if (nsEventStatus_eConsumeNoDefault == *aEventStatus ||
111609:       DisplaySelection(aPresContext) == nsISelectionController::SELECTION_OFF) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Find out whether we're doing line or paragraph selection.
     1:   // If browser.triple_click_selects_paragraph is true, triple-click selects paragraph.
     1:   // Otherwise, triple-click selects line, and quadruple-click selects paragraph
     1:   // (on platforms that support quadruple-click).
     1:   nsSelectionAmount beginAmount, endAmount;
     1:   nsMouseEvent *me = (nsMouseEvent *)aEvent;
     1:   if (!me) return NS_OK;
     1: 
     1:   if (me->clickCount == 4) {
     1:     beginAmount = endAmount = eSelectParagraph;
     1:   } else if (me->clickCount == 3) {
 70840:     if (Preferences::GetBool("browser.triple_click_selects_paragraph")) {
     1:       beginAmount = endAmount = eSelectParagraph;
     1:     } else {
     1:       beginAmount = eSelectBeginLine;
     1:       endAmount = eSelectEndLine;
     1:     }
     1:   } else if (me->clickCount == 2) {
     1:     // We only want inline frames; PeekBackwardAndForward dislikes blocks
     1:     beginAmount = endAmount = eSelectWord;
     1:   } else {
     1:     return NS_OK;
     1:   }
     1: 
111609:   nsPoint relPoint = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
111609:   return SelectByTypeAtPoint(aPresContext, relPoint, beginAmount, endAmount,
111609:                              (aControlHeld ? SELECT_ACCUMULATE : 0));
111609: }
111609: 
111609: nsresult
     1: nsFrame::PeekBackwardAndForward(nsSelectionAmount aAmountBack,
     1:                                 nsSelectionAmount aAmountForward,
108991:                                 int32_t aStartPos,
     1:                                 nsPresContext* aPresContext,
 79445:                                 bool aJumpLines,
111609:                                 uint32_t aSelectFlags)
 20590: {
     1:   nsIFrame* baseFrame = this;
108991:   int32_t baseOffset = aStartPos;
 20590:   nsresult rv;
 20590: 
     1:   if (aAmountBack == eSelectWord) {
     1:     // To avoid selecting the previous word when at start of word,
     1:     // first move one character forward.
 94058:     nsPeekOffsetStruct pos(eSelectCharacter,
     1:                            eDirNext,
     1:                            aStartPos,
     1:                            0,
     1:                            aJumpLines,
 80486:                            true,  //limit on scrolled views
 80486:                            false,
 80486:                            false);
     1:     rv = PeekOffset(&pos);
     1:     if (NS_SUCCEEDED(rv)) {
     1:       baseFrame = pos.mResultFrame;
     1:       baseOffset = pos.mContentOffset;
     1:     }
     1:   }
 20590: 
 20590:   // Use peek offset one way then the other:
 94058:   nsPeekOffsetStruct startpos(aAmountBack,
     1:                               eDirPrevious,
     1:                               baseOffset,
     1:                               0,
     1:                               aJumpLines,
 80486:                               true,  //limit on scrolled views
 80486:                               false,
 80486:                               false);
     1:   rv = baseFrame->PeekOffset(&startpos);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 94058:   nsPeekOffsetStruct endpos(aAmountForward,
     1:                             eDirNext,
     1:                             aStartPos,
     1:                             0,
     1:                             aJumpLines,
 80486:                             true,  //limit on scrolled views
 80486:                             false,
 80486:                             false);
     1:   rv = PeekOffset(&endpos);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 20590:   // Keep frameSelection alive.
 20590:   nsRefPtr<nsFrameSelection> frameSelection = GetFrameSelection();
 20590: 
 20590:   rv = frameSelection->HandleClick(startpos.mResultContent,
 20590:                                    startpos.mContentOffset, startpos.mContentOffset,
111609:                                    false, (aSelectFlags & SELECT_ACCUMULATE),
 20590:                                    nsFrameSelection::HINTRIGHT);
     1:   if (NS_FAILED(rv))
     1:     return rv;
 20590: 
 20590:   rv = frameSelection->HandleClick(endpos.mResultContent,
 20590:                                    endpos.mContentOffset, endpos.mContentOffset,
 80486:                                    true, false,
 20590:                                    nsFrameSelection::HINTLEFT);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   // maintain selection
  5907:   return frameSelection->MaintainSelection(aAmountBack);
     1: }
     1: 
 74711: NS_IMETHODIMP nsFrame::HandleDrag(nsPresContext* aPresContext, 
     1:                                   nsGUIEvent*     aEvent,
     1:                                   nsEventStatus*  aEventStatus)
     1: {
 79445:   bool    selectable;
108991:   uint8_t selectStyle;
 74711:   IsSelectable(&selectable, &selectStyle);
 74711:   // XXX Do we really need to exclude non-selectable content here?
 74711:   // GetContentOffsetsFromPoint can handle it just fine, although some
 74711:   // other stuff might not like it.
 74711:   if (!selectable)
 74711:     return NS_OK;
 74711:   if (DisplaySelection(aPresContext) == nsISelectionController::SELECTION_OFF) {
 74711:     return NS_OK;
 74711:   }
 74711:   nsIPresShell *presShell = aPresContext->PresShell();
 74711: 
 74711:   nsRefPtr<nsFrameSelection> frameselection = GetFrameSelection();
 79445:   bool mouseDown = frameselection->GetMouseDownState();
 74711:   if (!mouseDown)
 74711:     return NS_OK;
 74711: 
 74711:   frameselection->StopAutoScrollTimer();
     1: 
     1:   // Check if we are dragging in a table cell
     1:   nsCOMPtr<nsIContent> parentContent;
108991:   int32_t contentOffset;
108991:   int32_t target;
 74711:   nsMouseEvent *me = (nsMouseEvent *)aEvent;
 74711:   nsresult result;
 74711:   result = GetDataForTableSelection(frameselection, presShell, me,
 74711:                                     getter_AddRefs(parentContent),
     1:                                     &contentOffset, &target);      
     1: 
 35219:   nsWeakFrame weakThis = this;
 74711:   if (NS_SUCCEEDED(result) && parentContent) {
 74711:     frameselection->HandleTableSelection(parentContent, contentOffset, target, me);
     1:   } else {
     1:     nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
 74711:     frameselection->HandleDrag(this, pt);
     1:   }
     1: 
 35219:   // The frameselection object notifies selection listeners synchronously above
 35219:   // which might have killed us.
 35219:   if (!weakThis.IsAlive()) {
 35219:     return NS_OK;
 35219:   }
 35219: 
 74711:   // get the nearest scrollframe
 74711:   nsIFrame* checkFrame = this;
106838:   nsIScrollableFrame *scrollFrame = nullptr;
 74711:   while (checkFrame) {
 74711:     scrollFrame = do_QueryFrame(checkFrame);
 74711:     if (scrollFrame) {
 74711:       break;
 74711:     }
 74711:     checkFrame = checkFrame->GetParent();
 74711:   }
 74711: 
 74711:   if (scrollFrame) {
 74711:     nsIFrame* capturingFrame = scrollFrame->GetScrolledFrame();
 74711:     if (capturingFrame) {
 74711:       nsPoint pt =
 74711:         nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, capturingFrame);
 74711:       frameselection->StartAutoScrollTimer(capturingFrame, pt, 30);
 74711:     }
 74711:   }
 74711: 
 73455:   return NS_OK;
 73455: }
 73455: 
 74711: /**
 74711:  * This static method handles part of the nsFrame::HandleRelease in a way
 74711:  * which doesn't rely on the nsFrame object to stay alive.
 74711:  */
 74711: static nsresult
 74711: HandleFrameSelection(nsFrameSelection*         aFrameSelection,
 74711:                      nsIFrame::ContentOffsets& aOffsets,
 79445:                      bool                      aHandleTableSel,
108991:                      int32_t                   aContentOffsetForTableSel,
108991:                      int32_t                   aTargetForTableSel,
 74711:                      nsIContent*               aParentContentForTableSel,
     1:                      nsGUIEvent*               aEvent,
     1:                      nsEventStatus*            aEventStatus)
     1: {
 74711:   if (!aFrameSelection) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsresult rv = NS_OK;
 74711: 
 74711:   if (nsEventStatus_eConsumeNoDefault != *aEventStatus) {
 74711:     if (!aHandleTableSel) {
 99337:       if (!aOffsets.content || !aFrameSelection->HasDelayedCaretData()) {
 74711:         return NS_ERROR_FAILURE;
 74711:       }
     1: 
     1:       // We are doing this to simulate what we would have done on HandlePress.
     1:       // We didn't do it there to give the user an opportunity to drag
     1:       // the text, but since they didn't drag, we want to place the
     1:       // caret.
     1:       // However, we'll use the mouse position from the release, since:
     1:       //  * it's easier
     1:       //  * that's the normal click position to use (although really, in
     1:       //    the normal case, small movements that don't count as a drag
     1:       //    can do selection)
 80486:       aFrameSelection->SetMouseDownState(true);
     1: 
 74711:       rv = aFrameSelection->HandleClick(aOffsets.content,
 74711:                                         aOffsets.StartOffset(),
 74711:                                         aOffsets.EndOffset(),
 99337:                                         aFrameSelection->IsShiftDownInDelayedCaretData(),
 99337:                                         false,
 74711:                                         aOffsets.associateWithNext);
 74711:       if (NS_FAILED(rv)) {
 74711:         return rv;
 74711:       }
 74711:     } else if (aParentContentForTableSel) {
 80486:       aFrameSelection->SetMouseDownState(false);
 74711:       rv = aFrameSelection->HandleTableSelection(aParentContentForTableSel,
 74711:                                                  aContentOffsetForTableSel,
 74711:                                                  aTargetForTableSel,
 74711:                                                  (nsMouseEvent *)aEvent);
 74711:       if (NS_FAILED(rv)) {
 74711:         return rv;
 74711:       }
 74711:     }
     1:     aFrameSelection->SetDelayedCaretData(0);
 74711:   }
 74711: 
 80486:   aFrameSelection->SetMouseDownState(false);
 74711:   aFrameSelection->StopAutoScrollTimer();
 74711: 
     1:   return NS_OK;
     1: }
     1: 
 74711: NS_IMETHODIMP nsFrame::HandleRelease(nsPresContext* aPresContext,
 74711:                                      nsGUIEvent*    aEvent,
 74711:                                      nsEventStatus* aEventStatus)
 74711: {
107010:   if (aEvent->eventStructType != NS_MOUSE_EVENT) {
107010:     return NS_OK;
107010:   }
107010: 
 74711:   nsIFrame* activeFrame = GetActiveSelectionFrame(aPresContext, this);
 74711: 
 74711:   nsCOMPtr<nsIContent> captureContent = nsIPresShell::GetCapturingContent();
 74711: 
 74711:   // We can unconditionally stop capturing because
 74711:   // we should never be capturing when the mouse button is up
106838:   nsIPresShell::SetCapturingContent(nullptr, 0);
 74711: 
 79445:   bool selectionOff =
 74711:     (DisplaySelection(aPresContext) == nsISelectionController::SELECTION_OFF);
 74711: 
 74711:   nsRefPtr<nsFrameSelection> frameselection;
 74711:   ContentOffsets offsets;
     1:   nsCOMPtr<nsIContent> parentContent;
108991:   int32_t contentOffsetForTableSel = 0;
108991:   int32_t targetForTableSel = 0;
 79445:   bool handleTableSelection = true;
 74711: 
 74711:   if (!selectionOff) {
 74711:     frameselection = GetFrameSelection();
 74711:     if (nsEventStatus_eConsumeNoDefault != *aEventStatus && frameselection) {
 74711:       // Check if the frameselection recorded the mouse going down.
 74711:       // If not, the user must have clicked in a part of the selection.
 74711:       // Place the caret before continuing!
 74711: 
 79445:       bool mouseDown = frameselection->GetMouseDownState();
 99337: 
 99337:       if (!mouseDown && frameselection->HasDelayedCaretData() &&
 99337:           frameselection->GetClickCountInDelayedCaretData() < 2) {
 74711:         nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
 99687:         offsets = GetContentOffsetsFromPoint(pt, SKIP_HIDDEN);
 80486:         handleTableSelection = false;
 74711:       } else {
 74711:         GetDataForTableSelection(frameselection, PresContext()->PresShell(),
 74711:                                  (nsMouseEvent *)aEvent,
 74711:                                  getter_AddRefs(parentContent),
 74711:                                  &contentOffsetForTableSel,
 74711:                                  &targetForTableSel);
 74711:       }
 74711:     }
 74711:   }
 74711: 
 74711:   // We might be capturing in some other document and the event just happened to
 74711:   // trickle down here. Make sure that document's frame selection is notified.
 74711:   // Note, this may cause the current nsFrame object to be deleted, bug 336592.
 74711:   nsRefPtr<nsFrameSelection> frameSelection;
 74711:   if (activeFrame != this &&
 74711:       static_cast<nsFrame*>(activeFrame)->DisplaySelection(activeFrame->PresContext())
 74711:         != nsISelectionController::SELECTION_OFF) {
 74711:       frameSelection = activeFrame->GetFrameSelection();
 74711:   }
 74711: 
 74711:   // Also check the selection of the capturing content which might be in a
 74711:   // different document.
 74711:   if (!frameSelection && captureContent) {
 74711:     nsIDocument* doc = captureContent->GetCurrentDoc();
 74711:     if (doc) {
 74711:       nsIPresShell* capturingShell = doc->GetShell();
 74711:       if (capturingShell && capturingShell != PresContext()->GetPresShell()) {
 74711:         frameSelection = capturingShell->FrameSelection();
 74711:       }
 74711:     }
 74711:   }
 74711: 
 74711:   if (frameSelection) {
 80486:     frameSelection->SetMouseDownState(false);
 74711:     frameSelection->StopAutoScrollTimer();
 74711:   }
 74711: 
 74711:   // Do not call any methods of the current object after this point!!!
     1:   // The object is perhaps dead!
 74711: 
 74711:   return selectionOff
 74711:     ? NS_OK
 74711:     : HandleFrameSelection(frameselection, offsets, handleTableSelection,
 74711:                            contentOffsetForTableSel, targetForTableSel,
 74711:                            parentContent, aEvent, aEventStatus);
     1: }
     1: 
 15599: struct NS_STACK_CLASS FrameContentRange {
108991:   FrameContentRange(nsIContent* aContent, int32_t aStart, int32_t aEnd) :
     1:     content(aContent), start(aStart), end(aEnd) { }
     1:   nsCOMPtr<nsIContent> content;
108991:   int32_t start;
108991:   int32_t end;
     1: };
     1: 
     1: // Retrieve the content offsets of a frame
     1: static FrameContentRange GetRangeForFrame(nsIFrame* aFrame) {
     1:   nsCOMPtr<nsIContent> content, parent;
     1:   content = aFrame->GetContent();
     1:   if (!content) {
     1:     NS_WARNING("Frame has no content");
106838:     return FrameContentRange(nullptr, -1, -1);
     1:   }
     1:   nsIAtom* type = aFrame->GetType();
     1:   if (type == nsGkAtoms::textFrame) {
108991:     int32_t offset, offsetEnd;
     1:     aFrame->GetOffsets(offset, offsetEnd);
     1:     return FrameContentRange(content, offset, offsetEnd);
     1:   }
     1:   if (type == nsGkAtoms::brFrame) {
     1:     parent = content->GetParent();
108991:     int32_t beginOffset = parent->IndexOf(content);
     1:     return FrameContentRange(parent, beginOffset, beginOffset);
     1:   }
     1:   // Loop to deal with anonymous content, which has no index; this loop
     1:   // probably won't run more than twice under normal conditions
     1:   do {
     1:     parent  = content->GetParent();
     1:     if (parent) {
108991:       int32_t beginOffset = parent->IndexOf(content);
     1:       if (beginOffset >= 0)
     1:         return FrameContentRange(parent, beginOffset, beginOffset + 1);
     1:       content = parent;
     1:     }
     1:   } while (parent);
     1: 
     1:   // The root content node must act differently
     1:   return FrameContentRange(content, 0, content->GetChildCount());
     1: }
     1: 
     1: // The FrameTarget represents the closest frame to a point that can be selected
     1: // The frame is the frame represented, frameEdge says whether one end of the
     1: // frame is the result (in which case different handling is needed), and
     1: // afterFrame says which end is repersented if frameEdge is true
     1: struct FrameTarget {
 79445:   FrameTarget(nsIFrame* aFrame, bool aFrameEdge, bool aAfterFrame,
 79445:               bool aEmptyBlock = false) :
 43565:     frame(aFrame), frameEdge(aFrameEdge), afterFrame(aAfterFrame),
 43565:     emptyBlock(aEmptyBlock) { }
     1:   static FrameTarget Null() {
106838:     return FrameTarget(nullptr, false, false);
     1:   }
 79445:   bool IsNull() {
     1:     return !frame;
     1:   }
     1:   nsIFrame* frame;
 79445:   bool frameEdge;
 79445:   bool afterFrame;
 79445:   bool emptyBlock;
     1: };
     1: 
     1: // See function implementation for information
 99686: static FrameTarget GetSelectionClosestFrame(nsIFrame* aFrame, nsPoint aPoint,
108991:                                             uint32_t aFlags);
108991: 
108991: static bool SelfIsSelectable(nsIFrame* aFrame, uint32_t aFlags)
 99686: {
 99686:   if ((aFlags & nsIFrame::SKIP_HIDDEN) &&
 99686:       !aFrame->GetStyleVisibility()->IsVisible()) {
 99686:     return false;
 99686:   }
 99686:   return !aFrame->IsGeneratedContentFrame() &&
 99686:     aFrame->GetStyleUIReset()->mUserSelect != NS_STYLE_USER_SELECT_NONE;
     1: }
     1: 
 79445: static bool SelectionDescendToKids(nsIFrame* aFrame) {
108991:   uint8_t style = aFrame->GetStyleUIReset()->mUserSelect;
     1:   nsIFrame* parent = aFrame->GetParent();
     1:   // If we are only near (not directly over) then don't traverse
     1:   // frames with independent selection (e.g. text and list controls)
     1:   // unless we're already inside such a frame (see bug 268497).  Note that this
     1:   // prevents any of the users of this method from entering form controls.
     1:   // XXX We might want some way to allow using the up-arrow to go into a form
     1:   // control, but the focus didn't work right anyway; it'd probably be enough
     1:   // if the left and right arrows could enter textboxes (which I don't believe
     1:   // they can at the moment)
     1:   return !aFrame->IsGeneratedContentFrame() &&
     1:          style != NS_STYLE_USER_SELECT_ALL  &&
     1:          style != NS_STYLE_USER_SELECT_NONE &&
     1:          ((parent->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION) ||
     1:           !(aFrame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION));
     1: }
     1: 
     1: static FrameTarget GetSelectionClosestFrameForChild(nsIFrame* aChild,
 99686:                                                     nsPoint aPoint,
108991:                                                     uint32_t aFlags)
     1: {
     1:   nsIFrame* parent = aChild->GetParent();
     1:   if (SelectionDescendToKids(aChild)) {
     1:     nsPoint pt = aPoint - aChild->GetOffsetTo(parent);
 99686:     return GetSelectionClosestFrame(aChild, pt, aFlags);
     1:   }
 80486:   return FrameTarget(aChild, false, false);
     1: }
     1: 
     1: // When the cursor needs to be at the beginning of a block, it shouldn't be
     1: // before the first child.  A click on a block whose first child is a block
     1: // should put the cursor in the child.  The cursor shouldn't be between the
     1: // blocks, because that's not where it's expected.
     1: // Note that this method is guaranteed to succeed.
     1: static FrameTarget DrillDownToSelectionFrame(nsIFrame* aFrame,
108991:                                              bool aEndFrame, uint32_t aFlags) {
     1:   if (SelectionDescendToKids(aFrame)) {
106838:     nsIFrame* result = nullptr;
 77154:     nsIFrame *frame = aFrame->GetFirstPrincipalChild();
     1:     if (!aEndFrame) {
 99686:       while (frame && (!SelfIsSelectable(frame, aFlags) ||
     1:                         frame->IsEmpty()))
     1:         frame = frame->GetNextSibling();
     1:       if (frame)
     1:         result = frame;
     1:     } else {
     1:       // Because the frame tree is singly linked, to find the last frame,
     1:       // we have to iterate through all the frames
     1:       // XXX I have a feeling this could be slow for long blocks, although
     1:       //     I can't find any slowdowns
     1:       while (frame) {
 99686:         if (!frame->IsEmpty() && SelfIsSelectable(frame, aFlags))
     1:           result = frame;
     1:         frame = frame->GetNextSibling();
     1:       }
     1:     }
     1:     if (result)
 99686:       return DrillDownToSelectionFrame(result, aEndFrame, aFlags);
     1:   }
     1:   // If the current frame has no targetable children, target the current frame
 80486:   return FrameTarget(aFrame, true, aEndFrame);
     1: }
     1: 
     1: // This method finds the closest valid FrameTarget on a given line; if there is
     1: // no valid FrameTarget on the line, it returns a null FrameTarget
     1: static FrameTarget GetSelectionClosestFrameForLine(
     1:                       nsBlockFrame* aParent,
     1:                       nsBlockFrame::line_iterator aLine,
 99686:                       nsPoint aPoint,
108991:                       uint32_t aFlags)
     1: {
     1:   nsIFrame *frame = aLine->mFirstChild;
     1:   // Account for end of lines (any iterator from the block is valid)
     1:   if (aLine == aParent->end_lines())
 99686:     return DrillDownToSelectionFrame(aParent, true, aFlags);
106838:   nsIFrame *closestFromLeft = nullptr, *closestFromRight = nullptr;
     1:   nsRect rect = aLine->mBounds;
     1:   nscoord closestLeft = rect.x, closestRight = rect.XMost();
108991:   for (int32_t n = aLine->GetChildCount(); n;
     1:        --n, frame = frame->GetNextSibling()) {
 99686:     if (!SelfIsSelectable(frame, aFlags) || frame->IsEmpty())
     1:       continue;
     1:     nsRect frameRect = frame->GetRect();
     1:     if (aPoint.x >= frameRect.x) {
     1:       if (aPoint.x < frameRect.XMost()) {
 99686:         return GetSelectionClosestFrameForChild(frame, aPoint, aFlags);
     1:       }
     1:       if (frameRect.XMost() >= closestLeft) {
     1:         closestFromLeft = frame;
     1:         closestLeft = frameRect.XMost();
     1:       }
     1:     } else {
     1:       if (frameRect.x <= closestRight) {
     1:         closestFromRight = frame;
     1:         closestRight = frameRect.x;
     1:       }
     1:     }
     1:   }
     1:   if (!closestFromLeft && !closestFromRight) {
     1:     // We should only get here if there are no selectable frames on a line
     1:     // XXX Do we need more elaborate handling here?
     1:     return FrameTarget::Null();
     1:   }
     1:   if (closestFromLeft &&
     1:       (!closestFromRight ||
     1:        (abs(aPoint.x - closestLeft) <= abs(aPoint.x - closestRight)))) {
 99686:     return GetSelectionClosestFrameForChild(closestFromLeft, aPoint, aFlags);
 99686:   }
 99686:   return GetSelectionClosestFrameForChild(closestFromRight, aPoint, aFlags);
     1: }
     1: 
     1: // This method is for the special handling we do for block frames; they're
     1: // special because they represent paragraphs and because they are organized
     1: // into lines, which have bounds that are not stored elsewhere in the
     1: // frame tree.  Returns a null FrameTarget for frames which are not
 43565: // blocks or blocks with no lines except editable one.
     1: static FrameTarget GetSelectionClosestFrameForBlock(nsIFrame* aFrame,
 99686:                                                     nsPoint aPoint,
108991:                                                     uint32_t aFlags)
     1: {
 15909:   nsBlockFrame* bf = nsLayoutUtils::GetAsBlock(aFrame); // used only for QI
 15909:   if (!bf)
     1:     return FrameTarget::Null();
     1: 
     1:   // This code searches for the correct line
     1:   nsBlockFrame::line_iterator firstLine = bf->begin_lines();
     1:   nsBlockFrame::line_iterator end = bf->end_lines();
 43565:   if (firstLine == end) {
 43565:     nsIContent *blockContent = aFrame->GetContent();
110500:     if (blockContent) {
110500:       // Return with empty flag true.
 80486:       return FrameTarget(aFrame, false, false, true);
 43565:     }
     1:     return FrameTarget::Null();
 43565:   }
     1:   nsBlockFrame::line_iterator curLine = firstLine;
     1:   nsBlockFrame::line_iterator closestLine = end;
     1:   while (curLine != end) {
     1:     // Check to see if our point lies with the line's Y bounds
     1:     nscoord y = aPoint.y - curLine->mBounds.y;
     1:     nscoord height = curLine->mBounds.height;
     1:     if (y >= 0 && y < height) {
     1:       closestLine = curLine;
     1:       break; // We found the line; stop looking
     1:     }
     1:     if (y < 0)
     1:       break;
     1:     ++curLine;
     1:   }
     1: 
     1:   if (closestLine == end) {
     1:     nsBlockFrame::line_iterator prevLine = curLine.prev();
     1:     nsBlockFrame::line_iterator nextLine = curLine;
     1:     // Avoid empty lines
     1:     while (nextLine != end && nextLine->IsEmpty())
     1:       ++nextLine;
     1:     while (prevLine != end && prevLine->IsEmpty())
     1:       --prevLine;
     1: 
     1:     // This hidden pref dictates whether a point above or below all lines comes
     1:     // up with a line or the beginning or end of the frame; 0 on Windows,
     1:     // 1 on other platforms by default at the writing of this code
108991:     int32_t dragOutOfFrame =
 70842:       Preferences::GetInt("browser.drag_out_of_frame_style");
     1: 
     1:     if (prevLine == end) {
     1:       if (dragOutOfFrame == 1 || nextLine == end)
 99686:         return DrillDownToSelectionFrame(aFrame, false, aFlags);
     1:       closestLine = nextLine;
     1:     } else if (nextLine == end) {
     1:       if (dragOutOfFrame == 1)
 99686:         return DrillDownToSelectionFrame(aFrame, true, aFlags);
     1:       closestLine = prevLine;
     1:     } else { // Figure out which line is closer
     1:       if (aPoint.y - prevLine->mBounds.YMost() < nextLine->mBounds.y - aPoint.y)
     1:         closestLine = prevLine;
     1:       else
     1:         closestLine = nextLine;
     1:     }
     1:   }
     1: 
     1:   do {
     1:     FrameTarget target = GetSelectionClosestFrameForLine(bf, closestLine,
 99686:                                                          aPoint, aFlags);
     1:     if (!target.IsNull())
     1:       return target;
     1:     ++closestLine;
     1:   } while (closestLine != end);
     1:   // Fall back to just targeting the last targetable place
 99686:   return DrillDownToSelectionFrame(aFrame, true, aFlags);
     1: }
     1: 
     1: // GetSelectionClosestFrame is the helper function that calculates the closest
     1: // frame to the given point.
     1: // It doesn't completely account for offset styles, so needs to be used in
     1: // restricted environments.
     1: // Cannot handle overlapping frames correctly, so it should receive the output
     1: // of GetFrameForPoint
     1: // Guaranteed to return a valid FrameTarget
 99686: static FrameTarget GetSelectionClosestFrame(nsIFrame* aFrame, nsPoint aPoint,
108991:                                             uint32_t aFlags)
     1: {
     1:   {
     1:     // Handle blocks; if the frame isn't a block, the method fails
 99686:     FrameTarget target = GetSelectionClosestFrameForBlock(aFrame, aPoint, aFlags);
     1:     if (!target.IsNull())
     1:       return target;
     1:   }
     1: 
 77154:   nsIFrame *kid = aFrame->GetFirstPrincipalChild();
     1: 
     1:   if (kid) {
     1:     // Go through all the child frames to find the closest one
     1: 
     1:     // Large number to force the comparison to succeed
     1:     const nscoord HUGE_DISTANCE = nscoord_MAX;
     1:     nscoord closestXDistance = HUGE_DISTANCE;
     1:     nscoord closestYDistance = HUGE_DISTANCE;
106838:     nsIFrame *closestFrame = nullptr;
     1: 
     1:     for (; kid; kid = kid->GetNextSibling()) {
 99686:       if (!SelfIsSelectable(kid, aFlags) || kid->IsEmpty())
     1:         continue;
     1: 
107810:       if (nsLayoutUtils::PointIsCloserToRect(aPoint, kid->GetRect(),
107810:                                              closestXDistance,
107810:                                              closestYDistance))
     1:         closestFrame = kid;
     1:     }
     1:     if (closestFrame)
 99686:       return GetSelectionClosestFrameForChild(closestFrame, aPoint, aFlags);
     1:   }
 80486:   return FrameTarget(aFrame, false, false);
     1: }
     1: 
     1: nsIFrame::ContentOffsets OffsetsForSingleFrame(nsIFrame* aFrame, nsPoint aPoint)
     1: {
     1:   nsIFrame::ContentOffsets offsets;
     1:   FrameContentRange range = GetRangeForFrame(aFrame);
     1:   offsets.content = range.content;
     1:   // If there are continuations (meaning it's not one rectangle), this is the
     1:   // best this function can do
     1:   if (aFrame->GetNextContinuation() || aFrame->GetPrevContinuation()) {
     1:     offsets.offset = range.start;
     1:     offsets.secondaryOffset = range.end;
 80486:     offsets.associateWithNext = true;
     1:     return offsets;
     1:   }
     1: 
     1:   // Figure out whether the offsets should be over, after, or before the frame
     1:   nsRect rect(nsPoint(0, 0), aFrame->GetSize());
     1: 
107226:   bool isBlock = aFrame->GetDisplay() != NS_STYLE_DISPLAY_INLINE;
 79445:   bool isRtl = (aFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL);
     1:   if ((isBlock && rect.y < aPoint.y) ||
     1:       (!isBlock && ((isRtl  && rect.x + rect.width / 2 > aPoint.x) || 
     1:                     (!isRtl && rect.x + rect.width / 2 < aPoint.x)))) {
     1:     offsets.offset = range.end;
     1:     if (rect.Contains(aPoint))
     1:       offsets.secondaryOffset = range.start;
     1:     else
     1:       offsets.secondaryOffset = range.end;
     1:   } else {
     1:     offsets.offset = range.start;
     1:     if (rect.Contains(aPoint))
     1:       offsets.secondaryOffset = range.end;
     1:     else
     1:       offsets.secondaryOffset = range.start;
     1:   }
     1:   offsets.associateWithNext = (offsets.offset == range.start);
     1:   return offsets;
     1: }
     1: 
     1: static nsIFrame* AdjustFrameForSelectionStyles(nsIFrame* aFrame) {
     1:   nsIFrame* adjustedFrame = aFrame;
     1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent())
     1:   {
     1:     // These are the conditions that make all children not able to handle
     1:     // a cursor.
     1:     if (frame->GetStyleUIReset()->mUserSelect == NS_STYLE_USER_SELECT_NONE || 
     1:         frame->GetStyleUIReset()->mUserSelect == NS_STYLE_USER_SELECT_ALL || 
     1:         frame->IsGeneratedContentFrame()) {
     1:       adjustedFrame = frame;
     1:     }
     1:   }
     1:   return adjustedFrame;
     1: }
     1:   
     1: 
     1: nsIFrame::ContentOffsets nsIFrame::GetContentOffsetsFromPoint(nsPoint aPoint,
108991:                                                               uint32_t aFlags)
     1: {
     1:   nsIFrame *adjustedFrame;
 99685:   if (aFlags & IGNORE_SELECTION_STYLE) {
     1:     adjustedFrame = this;
     1:   }
     1:   else {
     1:     // This section of code deals with special selection styles.  Note that
     1:     // -moz-none and -moz-all exist, even though they don't need to be explicitly
     1:     // handled.
     1:     // The offset is forced not to end up in generated content; content offsets
     1:     // cannot represent content outside of the document's content tree.
     1: 
     1:     adjustedFrame = AdjustFrameForSelectionStyles(this);
     1: 
     1:     // -moz-user-select: all needs special handling, because clicking on it
     1:     // should lead to the whole frame being selected
     1:     if (adjustedFrame && adjustedFrame->GetStyleUIReset()->mUserSelect ==
     1:         NS_STYLE_USER_SELECT_ALL) {
     1:       return OffsetsForSingleFrame(adjustedFrame, aPoint +
     1:                                    this->GetOffsetTo(adjustedFrame));
     1:     }
     1: 
     1:     // For other cases, try to find a closest frame starting from the parent of
     1:     // the unselectable frame
     1:     if (adjustedFrame != this)
     1:       adjustedFrame = adjustedFrame->GetParent();
     1:   }
     1: 
     1:   nsPoint adjustedPoint = aPoint + this->GetOffsetTo(adjustedFrame);
     1: 
 99686:   FrameTarget closest =
 99686:     GetSelectionClosestFrame(adjustedFrame, adjustedPoint, aFlags);
     1: 
 43565:   if (closest.emptyBlock) {
 43565:     ContentOffsets offsets;
 43565:     NS_ASSERTION(closest.frame,
 43565:                  "closest.frame must not be null when it's empty");
 43565:     offsets.content = closest.frame->GetContent();
 43565:     offsets.offset = 0;
 43565:     offsets.secondaryOffset = 0;
 80486:     offsets.associateWithNext = true;
 43565:     return offsets;
 43565:   }
 43565: 
     1:   // If the correct offset is at one end of a frame, use offset-based
     1:   // calculation method
     1:   if (closest.frameEdge) {
     1:     ContentOffsets offsets;
     1:     FrameContentRange range = GetRangeForFrame(closest.frame);
     1:     offsets.content = range.content;
     1:     if (closest.afterFrame)
     1:       offsets.offset = range.end;
     1:     else
     1:       offsets.offset = range.start;
     1:     offsets.secondaryOffset = offsets.offset;
     1:     offsets.associateWithNext = (offsets.offset == range.start);
     1:     return offsets;
     1:   }
     1:   nsPoint pt = aPoint - closest.frame->GetOffsetTo(this);
  3233:   return static_cast<nsFrame*>(closest.frame)->CalcContentOffsetsFromFramePoint(pt);
     1: 
     1:   // XXX should I add some kind of offset standardization?
     1:   // consider <b>xxxxx</b><i>zzzzz</i>; should any click between the last
     1:   // x and first z put the cursor in the same logical position in addition
     1:   // to the same visual position?
     1: }
     1: 
     1: nsIFrame::ContentOffsets nsFrame::CalcContentOffsetsFromFramePoint(nsPoint aPoint)
     1: {
     1:   return OffsetsForSingleFrame(this, aPoint);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFrame::GetCursor(const nsPoint& aPoint,
     1:                    nsIFrame::Cursor& aCursor)
     1: {
     1:   FillCursorInformationFromStyle(GetStyleUserInterface(), aCursor);
     1:   if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
     1:     aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
     1:   }
     1: 
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // Resize and incremental reflow
     1: 
     1: /* virtual */ void
     1: nsFrame::MarkIntrinsicWidthsDirty()
     1: {
     1:   // This version is meant only for what used to be box-to-block adaptors.
     1:   // It should not be called by other derived classes.
     1:   if (IsBoxWrapped()) {
     1:     nsBoxLayoutMetrics *metrics = BoxMetrics();
     1: 
     1:     SizeNeedsRecalc(metrics->mPrefSize);
     1:     SizeNeedsRecalc(metrics->mMinSize);
     1:     SizeNeedsRecalc(metrics->mMaxSize);
     1:     SizeNeedsRecalc(metrics->mBlockPrefSize);
     1:     SizeNeedsRecalc(metrics->mBlockMinSize);
     1:     CoordNeedsRecalc(metrics->mFlex);
     1:     CoordNeedsRecalc(metrics->mAscent);
     1:   }
 95534: 
 95534:   if (GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
 95534:     nsFontInflationData::MarkFontInflationDataTextDirty(this);
 95534:   }
     1: }
     1: 
     1: /* virtual */ nscoord
 68481: nsFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
     1: {
     1:   nscoord result = 0;
     1:   DISPLAY_MIN_WIDTH(this, result);
     1:   return result;
     1: }
     1: 
     1: /* virtual */ nscoord
 68481: nsFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
     1: {
     1:   nscoord result = 0;
     1:   DISPLAY_PREF_WIDTH(this, result);
     1:   return result;
     1: }
     1: 
     1: /* virtual */ void
 68481: nsFrame::AddInlineMinWidth(nsRenderingContext *aRenderingContext,
     1:                            nsIFrame::InlineMinWidthData *aData)
     1: {
     1:   NS_ASSERTION(GetParent(), "Must have a parent if we get here!");
 79445:   bool canBreak = !CanContinueTextRun() &&
     1:     GetParent()->GetStyleText()->WhiteSpaceCanWrap();
     1:   
     1:   if (canBreak)
  2668:     aData->OptionallyBreak(aRenderingContext);
     1:   aData->trailingWhitespace = 0;
 80486:   aData->skipWhitespace = false;
106838:   aData->trailingTextFrame = nullptr;
     1:   aData->currentLine += nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
     1:                             this, nsLayoutUtils::MIN_WIDTH);
 80486:   aData->atStartOfLine = false;
     1:   if (canBreak)
  2668:     aData->OptionallyBreak(aRenderingContext);
     1: }
     1: 
     1: /* virtual */ void
 68481: nsFrame::AddInlinePrefWidth(nsRenderingContext *aRenderingContext,
     1:                             nsIFrame::InlinePrefWidthData *aData)
     1: {
     1:   aData->trailingWhitespace = 0;
 80486:   aData->skipWhitespace = false;
  6254:   nscoord myPref = nsLayoutUtils::IntrinsicForContainer(aRenderingContext, 
     1:                        this, nsLayoutUtils::PREF_WIDTH);
  6254:   aData->currentLine = NSCoordSaturatingAdd(aData->currentLine, myPref);
     1: }
     1: 
     1: void
 68481: nsIFrame::InlineMinWidthData::ForceBreak(nsRenderingContext *aRenderingContext)
     1: {
     1:   currentLine -= trailingWhitespace;
 32531:   prevLines = NS_MAX(prevLines, currentLine);
     1:   currentLine = trailingWhitespace = 0;
     1: 
108991:   for (uint32_t i = 0, i_end = floats.Length(); i != i_end; ++i) {
108092:     nscoord float_min = floats[i].Width();
     1:     if (float_min > prevLines)
     1:       prevLines = float_min;
     1:   }
     1:   floats.Clear();
106838:   trailingTextFrame = nullptr;
 80486:   skipWhitespace = true;
     1: }
     1: 
     1: void
 68481: nsIFrame::InlineMinWidthData::OptionallyBreak(nsRenderingContext *aRenderingContext,
 64410:                                               nscoord aHyphenWidth)
  2668: {
106838:   trailingTextFrame = nullptr;
  2668: 
  2668:   // If we can fit more content into a smaller width by staying on this
  2668:   // line (because we're still at a negative offset due to negative
  2668:   // text-indent or negative margin), don't break.  Otherwise, do the
  2668:   // same as ForceBreak.  it doesn't really matter when we accumulate
  2668:   // floats.
 64410:   if (currentLine + aHyphenWidth < 0 || atStartOfLine)
  2668:     return;
 64410:   currentLine += aHyphenWidth;
  2668:   ForceBreak(aRenderingContext);
  2668: }
  2668: 
  2668: void
 68481: nsIFrame::InlinePrefWidthData::ForceBreak(nsRenderingContext *aRenderingContext)
     1: {
 24551:   if (floats.Length() != 0) {
     1:             // preferred widths accumulated for floats that have already
     1:             // been cleared past
     1:     nscoord floats_done = 0,
     1:             // preferred widths accumulated for floats that have not yet
     1:             // been cleared past
     1:             floats_cur_left = 0,
     1:             floats_cur_right = 0;
     1: 
108991:     for (uint32_t i = 0, i_end = floats.Length(); i != i_end; ++i) {
108092:       const FloatInfo& floatInfo = floats[i];
108092:       const nsStyleDisplay *floatDisp = floatInfo.Frame()->GetStyleDisplay();
     1:       if (floatDisp->mBreakType == NS_STYLE_CLEAR_LEFT ||
     1:           floatDisp->mBreakType == NS_STYLE_CLEAR_RIGHT ||
     1:           floatDisp->mBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT) {
 12743:         nscoord floats_cur = NSCoordSaturatingAdd(floats_cur_left,
 12743:                                                   floats_cur_right);
     1:         if (floats_cur > floats_done)
     1:           floats_done = floats_cur;
     1:         if (floatDisp->mBreakType != NS_STYLE_CLEAR_RIGHT)
     1:           floats_cur_left = 0;
     1:         if (floatDisp->mBreakType != NS_STYLE_CLEAR_LEFT)
     1:           floats_cur_right = 0;
     1:       }
     1: 
     1:       nscoord &floats_cur = floatDisp->mFloats == NS_STYLE_FLOAT_LEFT
     1:                               ? floats_cur_left : floats_cur_right;
108092:       nscoord floatWidth = floatInfo.Width();
 13553:       // Negative-width floats don't change the available space so they
 13553:       // shouldn't change our intrinsic line width either.
 13553:       floats_cur =
 32531:         NSCoordSaturatingAdd(floats_cur, NS_MAX(0, floatWidth));
 12743:     }
 12743: 
 12743:     nscoord floats_cur =
 12743:       NSCoordSaturatingAdd(floats_cur_left, floats_cur_right);
     1:     if (floats_cur > floats_done)
     1:       floats_done = floats_cur;
     1: 
  7750:     currentLine = NSCoordSaturatingAdd(currentLine, floats_done);
     1: 
     1:     floats.Clear();
     1:   }
     1: 
 12743:   currentLine =
 12743:     NSCoordSaturatingSubtract(currentLine, trailingWhitespace, nscoord_MAX);
 32531:   prevLines = NS_MAX(prevLines, currentLine);
     1:   currentLine = trailingWhitespace = 0;
 80486:   skipWhitespace = true;
     1: }
     1: 
     1: static void
     1: AddCoord(const nsStyleCoord& aStyle,
 68481:          nsRenderingContext* aRenderingContext,
     1:          nsIFrame* aFrame,
 52283:          nscoord* aCoord, float* aPercent,
 79445:          bool aClampNegativeToZero)
     1: {
 52481:   switch (aStyle.GetUnit()) {
 52481:     case eStyleUnit_Coord: {
 52481:       NS_ASSERTION(!aClampNegativeToZero || aStyle.GetCoordValue() >= 0,
 52481:                    "unexpected negative value");
 52481:       *aCoord += aStyle.GetCoordValue();
 51776:       return;
 51776:     }
 52481:     case eStyleUnit_Percent: {
 52481:       NS_ASSERTION(!aClampNegativeToZero || aStyle.GetPercentValue() >= 0.0f,
 52481:                    "unexpected negative value");
 52481:       *aPercent += aStyle.GetPercentValue();
 52481:       return;
 52481:     }
 52481:     case eStyleUnit_Calc: {
 52481:       const nsStyleCoord::Calc *calc = aStyle.GetCalcValue();
 52283:       if (aClampNegativeToZero) {
 52283:         // This is far from ideal when one is negative and one is positive.
 52481:         *aCoord += NS_MAX(calc->mLength, 0);
 52481:         *aPercent += NS_MAX(calc->mPercent, 0.0f);
 52481:       } else {
 52481:         *aCoord += calc->mLength;
 52481:         *aPercent += calc->mPercent;
 52481:       }
 52481:       return;
 52481:     }
 52481:     default: {
 52481:       return;
 52481:     }
 52481:   }
     1: }
     1: 
     1: /* virtual */ nsIFrame::IntrinsicWidthOffsetData
 68481: nsFrame::IntrinsicWidthOffsets(nsRenderingContext* aRenderingContext)
     1: {
     1:   IntrinsicWidthOffsetData result;
     1: 
     1:   const nsStyleMargin *styleMargin = GetStyleMargin();
 12630:   AddCoord(styleMargin->mMargin.GetLeft(), aRenderingContext, this,
 80486:            &result.hMargin, &result.hPctMargin, false);
 12630:   AddCoord(styleMargin->mMargin.GetRight(), aRenderingContext, this,
 80486:            &result.hMargin, &result.hPctMargin, false);
     1: 
     1:   const nsStylePadding *stylePadding = GetStylePadding();
 12630:   AddCoord(stylePadding->mPadding.GetLeft(), aRenderingContext, this,
 80486:            &result.hPadding, &result.hPctPadding, true);
 12630:   AddCoord(stylePadding->mPadding.GetRight(), aRenderingContext, this,
 80486:            &result.hPadding, &result.hPctPadding, true);
     1: 
     1:   const nsStyleBorder *styleBorder = GetStyleBorder();
 99856:   result.hBorder += styleBorder->GetComputedBorderWidth(NS_SIDE_LEFT);
 99856:   result.hBorder += styleBorder->GetComputedBorderWidth(NS_SIDE_RIGHT);
     1: 
     1:   const nsStyleDisplay *disp = GetStyleDisplay();
     1:   if (IsThemed(disp)) {
   238:     nsPresContext *presContext = PresContext();
     1: 
 23738:     nsIntMargin border;
     1:     presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
     1:                                              this, disp->mAppearance,
     1:                                              &border);
     1:     result.hBorder = presContext->DevPixelsToAppUnits(border.LeftRight());
     1: 
 23738:     nsIntMargin padding;
     1:     if (presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
     1:                                                   this, disp->mAppearance,
     1:                                                   &padding)) {
     1:       result.hPadding = presContext->DevPixelsToAppUnits(padding.LeftRight());
     1:       result.hPctPadding = 0;
     1:     }
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
  8142: /* virtual */ nsIFrame::IntrinsicSize
  8142: nsFrame::GetIntrinsicSize()
  8142: {
  8142:   return IntrinsicSize(); // default is width/height set to eStyleUnit_None
  8142: }
  8142: 
  2301: /* virtual */ nsSize
  2301: nsFrame::GetIntrinsicRatio()
  2301: {
  2301:   return nsSize(0, 0);
  2301: }
  2301: 
     1: /* virtual */ nsSize
 68481: nsFrame::ComputeSize(nsRenderingContext *aRenderingContext,
     1:                      nsSize aCBSize, nscoord aAvailableWidth,
     1:                      nsSize aMargin, nsSize aBorder, nsSize aPadding,
108991:                      uint32_t aFlags)
     1: {
     1:   nsSize result = ComputeAutoSize(aRenderingContext, aCBSize, aAvailableWidth,
 93353:                                   aMargin, aBorder, aPadding,
 93353:                                   aFlags & eShrinkWrap);
     1:   nsSize boxSizingAdjust(0,0);
     1:   const nsStylePosition *stylePos = GetStylePosition();
     1: 
     1:   switch (stylePos->mBoxSizing) {
     1:     case NS_STYLE_BOX_SIZING_BORDER:
     1:       boxSizingAdjust += aBorder;
     1:       // fall through
     1:     case NS_STYLE_BOX_SIZING_PADDING:
     1:       boxSizingAdjust += aPadding;
     1:   }
  1068:   nscoord boxSizingToMarginEdgeWidth =
  1068:     aMargin.width + aBorder.width + aPadding.width - boxSizingAdjust.width;
111204:   const nsStyleCoord* widthStyleCoord = &(stylePos->mWidth);
111204:   const nsStyleCoord* heightStyleCoord = &(stylePos->mHeight);
111204: 
111204:   bool isFlexItem = IsFlexItem();
111204:   bool isHorizontalFlexItem = false;
111204:  
111204: #ifdef MOZ_FLEXBOX
111204:   if (isFlexItem) {
111204:     // Flex items use their "flex-basis" property in place of their main-size
111204:     // property (e.g. "width") for sizing purposes, *unless* they have
111204:     // "flex-basis:auto", in which case they use their main-size property after
111204:     // all.
111204:     uint32_t flexDirection = mParent->GetStylePosition()->mFlexDirection;
111204:     isHorizontalFlexItem =
111204:       flexDirection == NS_STYLE_FLEX_DIRECTION_ROW ||
111204:       flexDirection == NS_STYLE_FLEX_DIRECTION_ROW_REVERSE;
111204: 
111204:     if (stylePos->mFlexBasis.GetUnit() != eStyleUnit_Auto) {
111204:       if (isHorizontalFlexItem) {
111204:         widthStyleCoord = &(stylePos->mFlexBasis);
111204:       } else {
111204:         heightStyleCoord = &(stylePos->mFlexBasis);
111204:       }
111204:     }
111204:   }
111204: #endif // MOZ_FLEXBOX
111204: 
     1:   // Compute width
     1: 
111204:   if (widthStyleCoord->GetUnit() != eStyleUnit_Auto) {
     1:     result.width =
  1068:       nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
  1068:         aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
111204:         *widthStyleCoord);
     1:   }
     1: 
111205:   // Flex items ignore their min & max sizing properties in their
111205:   // flex container's main-axis.  (Those properties get applied later in
111205:   // the flexbox algorithm.)
111205:   if (stylePos->mMaxWidth.GetUnit() != eStyleUnit_None &&
111205:       !(isFlexItem && isHorizontalFlexItem)) {
     1:     nscoord maxWidth =
  1068:       nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
  1068:         aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
  1068:         stylePos->mMaxWidth);
108742:     result.width = NS_MIN(maxWidth, result.width);
     1:   }
     1: 
111124:   nscoord minWidth;
111205:   if (stylePos->mMinWidth.GetUnit() != eStyleUnit_Auto &&
111205:       !(isFlexItem && isHorizontalFlexItem)) {
111124:     minWidth =
  1068:       nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
  1068:         aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
  1068:         stylePos->mMinWidth);
111124:   } else {
111124:     // Treat "min-width: auto" as 0.
111124:     // NOTE: Technically, "auto" is supposed to behave like "min-content" on
111124:     // flex items. However, we don't need to worry about that here, because
111124:     // flex items' min-sizes are intentionally ignored until the flex
111124:     // container explicitly considers them during space distribution.
111124:     minWidth = 0;
111124:   }
108742:   result.width = NS_MAX(minWidth, result.width);
     1: 
     1:   // Compute height
111204:   if (!nsLayoutUtils::IsAutoHeight(*heightStyleCoord, aCBSize.height)) {
     1:     result.height =
108742:       nsLayoutUtils::ComputeHeightValue(aCBSize.height, 
108742:                                         boxSizingAdjust.height,
111204:                                         *heightStyleCoord);
     1:   }
     1: 
     1:   if (result.height != NS_UNCONSTRAINEDSIZE) {
111205:     if (!nsLayoutUtils::IsAutoHeight(stylePos->mMaxHeight, aCBSize.height) &&
111205:         !(isFlexItem && !isHorizontalFlexItem)) {
     1:       nscoord maxHeight =
108742:         nsLayoutUtils::ComputeHeightValue(aCBSize.height, 
108742:                                           boxSizingAdjust.height,
108742:                                           stylePos->mMaxHeight);
108742:       result.height = NS_MIN(maxHeight, result.height);
     1:     }
     1: 
111205:     if (!nsLayoutUtils::IsAutoHeight(stylePos->mMinHeight, aCBSize.height) &&
111205:         !(isFlexItem && !isHorizontalFlexItem)) {
     1:       nscoord minHeight =
108742:         nsLayoutUtils::ComputeHeightValue(aCBSize.height, 
108742:                                           boxSizingAdjust.height, 
108742:                                           stylePos->mMinHeight);
108742:       result.height = NS_MAX(minHeight, result.height);
     1:     }
     1:   }
     1: 
     1:   const nsStyleDisplay *disp = GetStyleDisplay();
     1:   if (IsThemed(disp)) {
 23738:     nsIntSize widget(0, 0);
 79445:     bool canOverride = true;
   238:     nsPresContext *presContext = PresContext();
     1:     presContext->GetTheme()->
     1:       GetMinimumWidgetSize(aRenderingContext, this, disp->mAppearance,
 23738:                            &widget, &canOverride);
 23738: 
 23738:     nsSize size;
 23738:     size.width = presContext->DevPixelsToAppUnits(widget.width);
 23738:     size.height = presContext->DevPixelsToAppUnits(widget.height);
     1: 
     1:     // GMWS() returns border-box; we need content-box
     1:     size.width -= aBorder.width + aPadding.width;
     1:     size.height -= aBorder.height + aPadding.height;
     1: 
     1:     if (size.height > result.height || !canOverride)
     1:       result.height = size.height;
     1:     if (size.width > result.width || !canOverride)
     1:       result.width = size.width;
     1:   }
     1: 
108742:   result.width = NS_MAX(0, result.width);
108742:   result.height = NS_MAX(0, result.height);
     1: 
     1:   return result;
     1: }
     1: 
  6862: nsRect
  6862: nsIFrame::ComputeTightBounds(gfxContext* aContext) const
  6862: {
 55035:   return GetVisualOverflowRect();
  6862: }
  6862: 
  6862: nsRect
  6862: nsFrame::ComputeSimpleTightBounds(gfxContext* aContext) const
  6862: {
  6862:   if (GetStyleOutline()->GetOutlineStyle() != NS_STYLE_BORDER_STYLE_NONE ||
 95646:       GetStyleBorder()->HasBorder() || !GetStyleBackground()->IsTransparent() ||
  6862:       GetStyleDisplay()->mAppearance) {
  6862:     // Not necessarily tight, due to clipping, negative
  6862:     // outline-offset, and lots of other issues, but that's OK
 55035:     return GetVisualOverflowRect();
  6862:   }
  6862: 
  6862:   nsRect r(0, 0, 0, 0);
 77153:   ChildListIterator lists(this);
 77153:   for (; !lists.IsDone(); lists.Next()) {
 77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 77153:       nsIFrame* child = childFrames.get();
  6862:       r.UnionRect(r, child->ComputeTightBounds(aContext) + child->GetPosition());
 77153:     }
 77153:   }
  6862:   return r;
  6862: }
  6862: 
     1: /* virtual */ nsSize
 68481: nsFrame::ComputeAutoSize(nsRenderingContext *aRenderingContext,
     1:                          nsSize aCBSize, nscoord aAvailableWidth,
     1:                          nsSize aMargin, nsSize aBorder, nsSize aPadding,
 79445:                          bool aShrinkWrap)
     1: {
     1:   // Use basic shrink-wrapping as a default implementation.
     1:   nsSize result(0xdeadbeef, NS_UNCONSTRAINEDSIZE);
     1: 
     1:   // don't bother setting it if the result won't be used
     1:   if (GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
     1:     nscoord availBased = aAvailableWidth - aMargin.width - aBorder.width -
     1:                          aPadding.width;
     1:     result.width = ShrinkWidthToFit(aRenderingContext, availBased);
     1:   }
     1:   return result;
     1: }
     1: 
     1: nscoord
 68481: nsFrame::ShrinkWidthToFit(nsRenderingContext *aRenderingContext,
     1:                           nscoord aWidthInCB)
     1: {
 88122:   // If we're a container for font size inflation, then shrink
 88122:   // wrapping inside of us should not apply font size inflation.
 98992:   AutoMaybeDisableFontInflation an(this);
 88122: 
     1:   nscoord result;
     1:   nscoord minWidth = GetMinWidth(aRenderingContext);
     1:   if (minWidth > aWidthInCB) {
     1:     result = minWidth;
     1:   } else {
     1:     nscoord prefWidth = GetPrefWidth(aRenderingContext);
     1:     if (prefWidth > aWidthInCB) {
     1:       result = aWidthInCB;
     1:     } else {
     1:       result = prefWidth;
     1:     }
     1:   }
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFrame::WillReflow(nsPresContext* aPresContext)
     1: {
     1: #ifdef DEBUG_dbaron_off
     1:   // bug 81268
     1:   NS_ASSERTION(!(mState & NS_FRAME_IN_REFLOW),
     1:                "nsFrame::WillReflow: frame is already in reflow");
     1: #endif
     1: 
     1:   NS_FRAME_TRACE_MSG(NS_FRAME_TRACE_CALLS,
     1:                      ("WillReflow: oldState=%x", mState));
     1:   mState |= NS_FRAME_IN_REFLOW;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFrame::DidReflow(nsPresContext*           aPresContext,
     1:                    const nsHTMLReflowState*  aReflowState,
     1:                    nsDidReflowStatus         aStatus)
     1: {
     1:   NS_FRAME_TRACE_MSG(NS_FRAME_TRACE_CALLS,
     1:                      ("nsFrame::DidReflow: aStatus=%d", aStatus));
 79483: 
     1:   if (NS_FRAME_REFLOW_FINISHED == aStatus) {
     1:     mState &= ~(NS_FRAME_IN_REFLOW | NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY |
     1:                 NS_FRAME_HAS_DIRTY_CHILDREN);
     1:   }
     1: 
  7370:   // Notify the percent height observer if there is a percent height.
  7370:   // The observer may be able to initiate another reflow with a computed
  7370:   // height. This happens in the case where a table cell has no computed
  7370:   // height but can fabricate one when the cell height is known.
     1:   if (aReflowState && aReflowState->mPercentHeightObserver &&
 51406:       !GetPrevInFlow()) {
 51406:     const nsStyleCoord &height = aReflowState->mStylePosition->mHeight;
 51406:     if (height.HasPercent()) {
     1:       aReflowState->mPercentHeightObserver->NotifyPercentHeight(*aReflowState);
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79483: void
 79483: nsFrame::FinishReflowWithAbsoluteFrames(nsPresContext*           aPresContext,
 79483:                                         nsHTMLReflowMetrics&     aDesiredSize,
 79483:                                         const nsHTMLReflowState& aReflowState,
 79483:                                         nsReflowStatus&          aStatus)
 79483: {
 79483:   ReflowAbsoluteFrames(aPresContext, aDesiredSize, aReflowState, aStatus);
 79483: 
 79483:   FinishAndStoreOverflow(&aDesiredSize);
 79483: }
 79483: 
 79483: void
 79483: nsFrame::DestroyAbsoluteFrames(nsIFrame* aDestructRoot)
 79483: {
 79483:   if (IsAbsoluteContainer()) {
 79483:     GetAbsoluteContainingBlock()->DestroyFrames(this, aDestructRoot);
 79483:   }
 79483: }
 79483: 
 79483: void
 79483: nsFrame::ReflowAbsoluteFrames(nsPresContext*           aPresContext,
 79483:                               nsHTMLReflowMetrics&     aDesiredSize,
 79483:                               const nsHTMLReflowState& aReflowState,
 79483:                               nsReflowStatus&          aStatus)
 79483: {
 79483:   if (HasAbsolutelyPositionedChildren()) {
 79483:     nsAbsoluteContainingBlock* absoluteContainer = GetAbsoluteContainingBlock();
 79483: 
 79483:     // Let the absolutely positioned container reflow any absolutely positioned
 79483:     // child frames that need to be reflowed
 79483: 
 79483:     // The containing block for the abs pos kids is formed by our padding edge.
 79483:     nsMargin computedBorder =
 79483:       aReflowState.mComputedBorderPadding - aReflowState.mComputedPadding;
 79483:     nscoord containingBlockWidth =
 79483:       aDesiredSize.width - computedBorder.LeftRight();
 79483:     nscoord containingBlockHeight =
 79483:       aDesiredSize.height - computedBorder.TopBottom();
 79483: 
 79483:     nsContainerFrame* container = do_QueryFrame(this);
 79483:     NS_ASSERTION(container, "Abs-pos children only supported on container frames for now");
 79483: 
 79483:     absoluteContainer->Reflow(container, aPresContext, aReflowState, aStatus,
 79483:                               containingBlockWidth, containingBlockHeight,
 79483:                               true, true, true, // XXX could be optimized
 79483:                               &aDesiredSize.mOverflowAreas);
 79483:   }
 79483: }
 79483: 
 79445: /* virtual */ bool
     1: nsFrame::CanContinueTextRun() const
     1: {
     1:   // By default, a frame will *not* allow a text run to be continued
     1:   // through it.
 80486:   return false;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFrame::Reflow(nsPresContext*          aPresContext,
     1:                 nsHTMLReflowMetrics&     aDesiredSize,
     1:                 const nsHTMLReflowState& aReflowState,
     1:                 nsReflowStatus&          aStatus)
     1: {
     1:   DO_GLOBAL_REFLOW_COUNT("nsFrame");
     1:   aDesiredSize.width = 0;
     1:   aDesiredSize.height = 0;
     1:   aStatus = NS_FRAME_COMPLETE;
     1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 31131: nsFrame::CharacterDataChanged(CharacterDataChangeInfo* aInfo)
     1: {
     1:   NS_NOTREACHED("should only be called for text frames");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsFrame::AttributeChanged(int32_t         aNameSpaceID,
     1:                           nsIAtom*        aAttribute,
108991:                           int32_t         aModType)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: // Flow member functions
     1: 
     1: nsSplittableType
     1: nsFrame::GetSplittableType() const
     1: {
     1:   return NS_FRAME_NOT_SPLITTABLE;
     1: }
     1: 
     1: nsIFrame* nsFrame::GetPrevContinuation() const
     1: {
106838:   return nullptr;
     1: }
     1: 
     1: NS_IMETHODIMP nsFrame::SetPrevContinuation(nsIFrame* aPrevContinuation)
     1: {
     1:   // Ignore harmless requests to set it to NULL
     1:   if (aPrevContinuation) {
     1:     NS_ERROR("not splittable");
     1:     return NS_ERROR_NOT_IMPLEMENTED;
     1:   }
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: nsIFrame* nsFrame::GetNextContinuation() const
     1: {
106838:   return nullptr;
     1: }
     1: 
     1: NS_IMETHODIMP nsFrame::SetNextContinuation(nsIFrame*)
     1: {
     1:   NS_ERROR("not splittable");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: nsIFrame* nsFrame::GetPrevInFlowVirtual() const
     1: {
106838:   return nullptr;
     1: }
     1: 
     1: NS_IMETHODIMP nsFrame::SetPrevInFlow(nsIFrame* aPrevInFlow)
     1: {
     1:   // Ignore harmless requests to set it to NULL
     1:   if (aPrevInFlow) {
     1:     NS_ERROR("not splittable");
     1:     return NS_ERROR_NOT_IMPLEMENTED;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsIFrame* nsFrame::GetNextInFlowVirtual() const
     1: {
106838:   return nullptr;
     1: }
     1: 
     1: NS_IMETHODIMP nsFrame::SetNextInFlow(nsIFrame*)
     1: {
     1:   NS_ERROR("not splittable");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
 10780: nsIFrame* nsIFrame::GetTailContinuation()
 10780: {
 10780:   nsIFrame* frame = this;
 10780:   while (frame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
 10780:     frame = frame->GetPrevContinuation();
 10780:     NS_ASSERTION(frame, "first continuation can't be overflow container");
 10780:   }
 10780:   for (nsIFrame* next = frame->GetNextContinuation();
 10780:        next && !(next->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER);
 10780:        next = frame->GetNextContinuation())  {
 10780:     frame = next;
 10780:   }
 10780:   NS_POSTCONDITION(frame, "illegal state in continuation chain.");
 10780:   return frame;
 10780: }
 10780: 
106838: NS_DECLARE_FRAME_PROPERTY(ViewProperty, nullptr)
 39965: 
     1: // Associated view object
     1: nsIView*
     1: nsIFrame::GetView() const
     1: {
     1:   // Check the frame state bit and see if the frame has a view
     1:   if (!(GetStateBits() & NS_FRAME_HAS_VIEW))
106838:     return nullptr;
     1: 
     1:   // Check for a property on the frame
 39965:   void* value = Properties().Get(ViewProperty());
     1:   NS_ASSERTION(value, "frame state bit was set but frame has no view");
  3233:   return static_cast<nsIView*>(value);
     1: }
     1: 
     1: /* virtual */ nsIView*
     1: nsIFrame::GetViewExternal() const
     1: {
     1:   return GetView();
     1: }
     1: 
     1: nsresult
     1: nsIFrame::SetView(nsIView* aView)
     1: {
     1:   if (aView) {
 82566:     aView->SetFrame(this);
     1: 
     1:     // Set a property on the frame
 39965:     Properties().Set(ViewProperty(), aView);
     1: 
     1:     // Set the frame state bit that says the frame has a view
     1:     AddStateBits(NS_FRAME_HAS_VIEW);
     1: 
     1:     // Let all of the ancestors know they have a descendant with a view.
     1:     for (nsIFrame* f = GetParent();
     1:          f && !(f->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW);
     1:          f = f->GetParent())
     1:       f->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsIFrame* nsIFrame::GetAncestorWithViewExternal() const
     1: {
     1:   return GetAncestorWithView();
     1: }
     1: 
     1: // Find the first geometric parent that has a view
     1: nsIFrame* nsIFrame::GetAncestorWithView() const
     1: {
106838:   for (nsIFrame* f = mParent; nullptr != f; f = f->GetParent()) {
     1:     if (f->HasView()) {
     1:       return f;
     1:     }
     1:   }
106838:   return nullptr;
     1: }
     1: 
     1: // virtual
     1: nsPoint nsIFrame::GetOffsetToExternal(const nsIFrame* aOther) const
     1: {
     1:   return GetOffsetTo(aOther);
     1: }
     1: 
     1: nsPoint nsIFrame::GetOffsetTo(const nsIFrame* aOther) const
     1: {
     1:   NS_PRECONDITION(aOther,
     1:                   "Must have frame for destination coordinate system!");
 47895: 
 47902:   NS_ASSERTION(PresContext() == aOther->PresContext(),
 47902:                "GetOffsetTo called on frames in different documents");
 47895: 
     1:   nsPoint offset(0, 0);
     1:   const nsIFrame* f;
 47895:   for (f = this; f != aOther && f; f = f->GetParent()) {
     1:     offset += f->GetPosition();
     1:   }
     1: 
     1:   if (f != aOther) {
 18884:     // Looks like aOther wasn't an ancestor of |this|.  So now we have
 47895:     // the root-frame-relative position of |this| in |offset|.  Convert back
 18884:     // to the coordinates of aOther
 18884:     while (aOther) {
 18884:       offset -= aOther->GetPosition();
 47895:       aOther = aOther->GetParent();
 47895:     }
 47895:   }
 47895: 
 47895:   return offset;
 47895: }
 47895: 
 47895: nsPoint nsIFrame::GetOffsetToCrossDoc(const nsIFrame* aOther) const
 47895: {
 47895:   return GetOffsetToCrossDoc(aOther, PresContext()->AppUnitsPerDevPixel());
 47895: }
 47895: 
 47895: nsPoint
108991: nsIFrame::GetOffsetToCrossDoc(const nsIFrame* aOther, const int32_t aAPD) const
 47895: {
 47895:   NS_PRECONDITION(aOther,
 47895:                   "Must have frame for destination coordinate system!");
 47895:   NS_ASSERTION(PresContext()->GetRootPresContext() ==
 47895:                  aOther->PresContext()->GetRootPresContext(),
 47895:                "trying to get the offset between frames in different document "
 47895:                "hierarchies?");
 71107:   if (PresContext()->GetRootPresContext() !=
 71107:         aOther->PresContext()->GetRootPresContext()) {
 71107:     // crash right away, we are almost certainly going to crash anyway.
 79845:     NS_RUNTIMEABORT("trying to get the offset between frames in different "
 79845:                     "document hierarchies?");
 71107:   }
 47895: 
106838:   const nsIFrame* root = nullptr;
 47895:   // offset will hold the final offset
 47895:   // docOffset holds the currently accumulated offset at the current APD, it
 47895:   // will be converted and added to offset when the current APD changes.
 47895:   nsPoint offset(0, 0), docOffset(0, 0);
 47895:   const nsIFrame* f = this;
108991:   int32_t currAPD = PresContext()->AppUnitsPerDevPixel();
 47895:   while (f && f != aOther) {
 47895:     docOffset += f->GetPosition();
 47895:     nsIFrame* parent = f->GetParent();
 47895:     if (parent) {
 47895:       f = parent;
 47895:     } else {
 47895:       nsPoint newOffset(0, 0);
 47895:       root = f;
 47895:       f = nsLayoutUtils::GetCrossDocParentFrame(f, &newOffset);
108991:       int32_t newAPD = f ? f->PresContext()->AppUnitsPerDevPixel() : 0;
 47895:       if (!f || newAPD != currAPD) {
 47895:         // Convert docOffset to the right APD and add it to offset.
 47895:         offset += docOffset.ConvertAppUnits(currAPD, aAPD);
 47895:         docOffset.x = docOffset.y = 0;
 47895:       }
 47895:       currAPD = newAPD;
 47895:       docOffset += newOffset;
 47895:     }
 47895:   }
 47895:   if (f == aOther) {
 47895:     offset += docOffset.ConvertAppUnits(currAPD, aAPD);
 47895:   } else {
 47895:     // Looks like aOther wasn't an ancestor of |this|.  So now we have
 47895:     // the root-document-relative position of |this| in |offset|. Subtract the
 47895:     // root-document-relative position of |aOther| from |offset|.
 47895:     // This call won't try to recurse again because root is an ancestor of
 47895:     // aOther.
 47895:     nsPoint negOffset = aOther->GetOffsetToCrossDoc(root, aAPD);
 47895:     offset -= negOffset;
     1:   }
     1: 
     1:   return offset;
     1: }
     1: 
     1: // virtual
     1: nsIntRect nsIFrame::GetScreenRectExternal() const
     1: {
     1:   return GetScreenRect();
     1: }
     1: 
     1: nsIntRect nsIFrame::GetScreenRect() const
     1: {
 34969:   return GetScreenRectInAppUnits().ToNearestPixels(PresContext()->AppUnitsPerCSSPixel());
 15364: }
 15364: 
 15364: // virtual
 15364: nsRect nsIFrame::GetScreenRectInAppUnitsExternal() const
 15364: {
 15364:   return GetScreenRectInAppUnits();
 15364: }
 15364: 
 15364: nsRect nsIFrame::GetScreenRectInAppUnits() const
 15364: {
 30531:   nsPresContext* presContext = PresContext();
 30531:   nsIFrame* rootFrame =
 30531:     presContext->PresShell()->FrameManager()->GetRootFrame();
 30531:   nsPoint rootScreenPos(0, 0);
 30531:   nsPoint rootFrameOffsetInParent(0, 0);
 30531:   nsIFrame* rootFrameParent =
 30531:     nsLayoutUtils::GetCrossDocParentFrame(rootFrame, &rootFrameOffsetInParent);
 30531:   if (rootFrameParent) {
 30531:     nsRect parentScreenRectAppUnits = rootFrameParent->GetScreenRectInAppUnits();
 30531:     nsPresContext* parentPresContext = rootFrameParent->PresContext();
 30531:     double parentScale = double(presContext->AppUnitsPerDevPixel())/
 30531:         parentPresContext->AppUnitsPerDevPixel();
 30531:     nsPoint rootPt = parentScreenRectAppUnits.TopLeft() + rootFrameOffsetInParent;
 30531:     rootScreenPos.x = NS_round(parentScale*rootPt.x);
 30531:     rootScreenPos.y = NS_round(parentScale*rootPt.y);
 30531:   } else {
 30531:     nsCOMPtr<nsIWidget> rootWidget;
 30531:     presContext->PresShell()->GetViewManager()->GetRootWidget(getter_AddRefs(rootWidget));
 30531:     if (rootWidget) {
 30531:       nsIntPoint rootDevPx = rootWidget->WidgetToScreenOffset();
 30531:       rootScreenPos.x = presContext->DevPixelsToAppUnits(rootDevPx.x);
 30531:       rootScreenPos.y = presContext->DevPixelsToAppUnits(rootDevPx.y);
 30531:     }
 30531:   }
 30531: 
 30531:   return nsRect(rootScreenPos + GetOffsetTo(rootFrame), GetSize());
     1: }
     1: 
     1: // Returns the offset from this frame to the closest geometric parent that
     1: // has a view. Also returns the containing view or null in case of error
     1: NS_IMETHODIMP nsFrame::GetOffsetFromView(nsPoint&  aOffset,
     1:                                          nsIView** aView) const
     1: {
106838:   NS_PRECONDITION(nullptr != aView, "null OUT parameter pointer");
     1:   nsIFrame* frame = (nsIFrame*)this;
     1: 
106838:   *aView = nullptr;
     1:   aOffset.MoveTo(0, 0);
     1:   do {
     1:     aOffset += frame->GetPosition();
     1:     frame = frame->GetParent();
     1:   } while (frame && !frame->HasView());
     1:   if (frame)
     1:     *aView = frame->GetView();
     1:   return NS_OK;
     1: }
     1: 
     1: nsIWidget*
 47148: nsIFrame::GetNearestWidget() const
     1: {
106838:   return GetClosestView()->GetNearestWidget(nullptr);
     1: }
     1: 
 39425: nsIWidget*
 47148: nsIFrame::GetNearestWidget(nsPoint& aOffset) const
 39425: {
 39425:   nsPoint offsetToView;
 39425:   nsPoint offsetToWidget;
 39425:   nsIWidget* widget =
 39425:     GetClosestView(&offsetToView)->GetNearestWidget(&offsetToWidget);
 39425:   aOffset = offsetToView + offsetToWidget;
 39425:   return widget;
 39425: }
 39425: 
     1: nsIAtom*
     1: nsFrame::GetType() const
     1: {
106838:   return nullptr;
     1: }
     1: 
 79445: bool
     1: nsIFrame::IsLeaf() const
     1: {
 80486:   return true;
     1: }
     1: 
103530: Layer*
108991: nsIFrame::InvalidateLayer(const nsRect& aDamageRect, uint32_t aDisplayItemKey)
103530: {
103530:   NS_ASSERTION(aDisplayItemKey > 0, "Need a key");
103530: 
103530:   Layer* layer = FrameLayerBuilder::GetDedicatedLayer(this, aDisplayItemKey);
103530:   if (!layer) {
103530:     Invalidate(aDamageRect);
106838:     return nullptr;
103530:   }
103530: 
108991:   uint32_t flags = INVALIDATE_NO_THEBES_LAYERS;
103530:   if (aDisplayItemKey == nsDisplayItem::TYPE_VIDEO ||
103530:       aDisplayItemKey == nsDisplayItem::TYPE_PLUGIN ||
103530:       aDisplayItemKey == nsDisplayItem::TYPE_CANVAS) {
103530:     flags |= INVALIDATE_NO_UPDATE_LAYER_TREE;
103530:   }
103530: 
103530:   InvalidateWithFlags(aDamageRect, flags);
103530:   return layer;
103530: }
103530: 
103530: void
103530: nsIFrame::InvalidateTransformLayer()
103530: {
103530:   NS_ASSERTION(mParent, "How can a viewport frame have a transform?");
103530: 
103530:   bool hasLayer =
106838:       FrameLayerBuilder::GetDedicatedLayer(this, nsDisplayItem::TYPE_TRANSFORM) != nullptr;
103530:   // Invalidate post-transform area in the parent. We have to invalidate
103530:   // in the parent because our transform style may have changed from what was
103530:   // used to paint this frame.
103530:   // It's OK to bypass the SVG effects processing and other processing
103530:   // performed if we called this->InvalidateWithFlags, because those effects
103530:   // are performed before applying transforms.
103530:   mParent->InvalidateInternal(GetVisualOverflowRect() + GetPosition(),
103530:                               0, 0, this,
103530:                               hasLayer ? INVALIDATE_NO_THEBES_LAYERS : 0);
103530: }
103530: 
 47753: class LayerActivity {
 47753: public:
 72242:   LayerActivity(nsIFrame* aFrame) : mFrame(aFrame), mChangeHint(nsChangeHint(0)) {}
 47753:   ~LayerActivity();
 47753:   nsExpirationState* GetExpirationState() { return &mState; }
 47753: 
 47753:   nsIFrame* mFrame;
 47753:   nsExpirationState mState;
 72242:   // mChangeHint can be some combination of nsChangeHint_UpdateOpacityLayer and
 72242:   // nsChangeHint_UpdateTransformLayer (or neither)
 72242:   // The presence of those bits indicates whether opacity or transform
 72242:   // changes have been detected.
 72242:   nsChangeHint mChangeHint;
 47753: };
 47753: 
 86633: class LayerActivityTracker MOZ_FINAL : public nsExpirationTracker<LayerActivity,4> {
 47753: public:
 47753:   // 75-100ms is a good timeout period. We use 4 generations of 25ms each.
 47753:   enum { GENERATION_MS = 100 };
 47753:   LayerActivityTracker()
 47753:     : nsExpirationTracker<LayerActivity,4>(GENERATION_MS) {}
 47753:   ~LayerActivityTracker() {
 47753:     AgeAllGenerations();
 47753:   }
 47753: 
 47753:   virtual void NotifyExpired(LayerActivity* aObject);
 47753: };
 47753: 
106838: static LayerActivityTracker* gLayerActivityTracker = nullptr;
 47753: 
 47753: LayerActivity::~LayerActivity()
 47753: {
 47753:   if (mFrame) {
 47753:     NS_ASSERTION(gLayerActivityTracker, "Should still have a tracker");
 47753:     gLayerActivityTracker->RemoveObject(this);
 47753:   }
 47753: }
 47753: 
 47753: static void DestroyLayerActivity(void* aPropertyValue)
 47753: {
 47753:   delete static_cast<LayerActivity*>(aPropertyValue);
 47753: }
 47753: 
 47753: NS_DECLARE_FRAME_PROPERTY(LayerActivityProperty, DestroyLayerActivity)
 47753: 
 47753: void
 47753: LayerActivityTracker::NotifyExpired(LayerActivity* aObject)
 47753: {
 47753:   RemoveObject(aObject);
 47753: 
 47753:   nsIFrame* f = aObject->mFrame;
106838:   aObject->mFrame = nullptr;
 47753:   f->Properties().Delete(LayerActivityProperty());
 51756:   f->InvalidateFrameSubtree();
 47753: }
 47753: 
 47753: void
 72242: nsIFrame::MarkLayersActive(nsChangeHint aChangeHint)
 47753: {
 47753:   FrameProperties properties = Properties();
 47753:   LayerActivity* layerActivity =
 47753:     static_cast<LayerActivity*>(properties.Get(LayerActivityProperty()));
 47753:   if (layerActivity) {
 47753:     gLayerActivityTracker->MarkUsed(layerActivity);
 47753:   } else {
 47753:     if (!gLayerActivityTracker) {
 47753:       gLayerActivityTracker = new LayerActivityTracker();
 47753:     }
 47753:     layerActivity = new LayerActivity(this);
 47753:     gLayerActivityTracker->AddObject(layerActivity);
 47753:     properties.Set(LayerActivityProperty(), layerActivity);
 47753:   }
 72242:   NS_UpdateHint(layerActivity->mChangeHint, aChangeHint);
 47753: }
 47753: 
 79445: bool
 47753: nsIFrame::AreLayersMarkedActive()
 47753: {
106838:   return Properties().Get(LayerActivityProperty()) != nullptr;
 47753: }
 47753: 
 79445: bool
 72242: nsIFrame::AreLayersMarkedActive(nsChangeHint aChangeHint)
 72242: {
 72242:   LayerActivity* layerActivity =
 72242:     static_cast<LayerActivity*>(Properties().Get(LayerActivityProperty()));
 72242:   return layerActivity && (layerActivity->mChangeHint & aChangeHint);
 72242: }
 72242: 
 47753: /* static */ void
 47753: nsFrame::ShutdownLayerActivityTimer()
 47753: {
 47753:   delete gLayerActivityTracker;
106838:   gLayerActivityTracker = nullptr;
 47753: }
 47753: 
103530: void
108991: nsIFrame::InvalidateWithFlags(const nsRect& aDamageRect, uint32_t aFlags)
103530: {
103530:   if (aDamageRect.IsEmpty()) {
103530:     return;
103530:   }
103530: 
103530:   // Don't allow invalidates to do anything when
103530:   // painting is suppressed.
103530:   nsIPresShell *shell = PresContext()->GetPresShell();
103530:   if (shell) {
103530:     if (shell->IsPaintingSuppressed())
103530:       return;
103530:   }
103530: 
106838:   InvalidateInternal(aDamageRect, 0, 0, nullptr, aFlags);
103530: }
103530: 
103530: /**
103530:  * Helper function that funnels an InvalidateInternal request up to the
103530:  * parent.  This function is used so that if MOZ_SVG is not defined, we still
103530:  * have unified control paths in the InvalidateInternal chain.
103530:  *
103530:  * @param aDamageRect The rect to invalidate.
103530:  * @param aX The x offset from the origin of this frame to the rectangle.
103530:  * @param aY The y offset from the origin of this frame to the rectangle.
103530:  * @param aImmediate Whether to redraw immediately.
103530:  * @return None, though this funnels the request up to the parent frame.
103530:  */
103530: void
103530: nsIFrame::InvalidateInternalAfterResize(const nsRect& aDamageRect, nscoord aX,
108991:                                         nscoord aY, uint32_t aFlags)
103530: {
103530:   if (aDamageRect.IsEmpty()) {
103530:     return;
103530:   }
103530: 
103530:   /* If we're a transformed frame, then we need to apply our transform to the
103530:    * damage rectangle so that the redraw correctly redraws the transformed
103530:    * region.  We're moved over aX and aY from our origin, but since this aX
103530:    * and aY is contained within our border, we need to scoot back by -aX and
103530:    * -aY to get back to the origin of the transform.
103530:    *
103530:    * There's one more problem, though, and that's that we don't know what
103530:    * coordinate space this rectangle is in.  Sometimes it's in the local
103530:    * coordinate space for the frame, and sometimes its in the transformed
103530:    * coordinate space.  If we get it wrong, we'll display incorrectly.  Until I
103530:    * find a better fix for this problem, we'll invalidate the union of the two
103530:    * rectangles (original rectangle and transformed rectangle).  At least one of
103530:    * these will be correct.
103530:    *
103530:    * When we are preserving-3d, we can have arbitrary hierarchies of preserved 3d
103530:    * children. The computed transform on these children is relative to the root
103530:    * transform object in the hierarchy, not necessarily their direct ancestor.
103530:    * In this case we transform by the child's transform, and mark the rectangle
103530:    * as being transformed until it is passed up to the root of the hierarchy.
103530:    *
103530:    * See bug #452496 for more details.
103530:    */
103530: 
103530:   // Check the transformed flags and remove it
103530:   bool rectIsTransformed = (aFlags & INVALIDATE_ALREADY_TRANSFORMED);
103530:   if (!Preserves3D()) {
103530:     // We only want to remove the flag if we aren't preserving 3d. Otherwise
103530:     // the rect will already have been transformed into the root preserve-3d
103530:     // frame coordinate space, and we should continue passing it up without
103530:     // further transforms.
103530:     aFlags &= ~INVALIDATE_ALREADY_TRANSFORMED;
103530:   }
103530: 
103530:   if ((mState & NS_FRAME_HAS_CONTAINER_LAYER) &&
103530:       !(aFlags & INVALIDATE_NO_THEBES_LAYERS)) {
103530:     // XXX need to set INVALIDATE_NO_THEBES_LAYERS for certain kinds of
103530:     // invalidation, e.g. video update, 'opacity' change
103530:     FrameLayerBuilder::InvalidateThebesLayerContents(this,
103530:         aDamageRect + nsPoint(aX, aY));
103530:     // Don't need to invalidate any more Thebes layers
103530:     aFlags |= INVALIDATE_NO_THEBES_LAYERS;
103530:     if (aFlags & INVALIDATE_ONLY_THEBES_LAYERS) {
103530:       return;
103530:     }
103530:   }
103530:   if (IsTransformed() && !rectIsTransformed) {
103530:     nsRect newDamageRect = nsDisplayTransform::TransformRectOut
103530:                              (aDamageRect, this, nsPoint(-aX, -aY));
103530:     if (!(GetStateBits() & NS_FRAME_SVG_LAYOUT)) {
103530:       newDamageRect.UnionRect(newDamageRect, aDamageRect);
103530:     }
103530: 
103530:     // If we are preserving 3d, then our computed transform includes that of any
103530:     // ancestor frames that also preserve 3d. Mark the rectangle as already being
103530:     // transformed into the parent's coordinate space.
103530:     if (Preserves3D()) {
103530:       aFlags |= INVALIDATE_ALREADY_TRANSFORMED;
103530:     }
103530: 
103530:     GetParent()->
103530:       InvalidateInternal(newDamageRect, aX + mRect.x, aY + mRect.y, this,
103530:                          aFlags);
103530:   }
103530:   else 
103530:     GetParent()->
103530:       InvalidateInternal(aDamageRect, aX + mRect.x, aY + mRect.y, this, aFlags);
103530: }
103530: 
103530: void
103530: nsIFrame::InvalidateInternal(const nsRect& aDamageRect, nscoord aX, nscoord aY,
108991:                              nsIFrame* aForChild, uint32_t aFlags)
103530: {
106096:   ClearDisplayItemCache();
103530:   nsSVGEffects::InvalidateDirectRenderingObservers(this);
103530:   if (nsSVGIntegrationUtils::UsingEffectsForFrame(this)) {
103530:     nsRect r = nsSVGIntegrationUtils::AdjustInvalidAreaForSVGEffects(this,
103530:             aDamageRect + nsPoint(aX, aY));
103530:     /* Rectangle is now in our own local space, so aX and aY are effectively
103530:      * zero.  Thus we'll pretend that the entire time this was in our own
103530:      * local coordinate space and do any remaining processing.
103530:      */
103530:     InvalidateInternalAfterResize(r, 0, 0, aFlags);
103530:     return;
103530:   }
103530:   
103530:   InvalidateInternalAfterResize(aDamageRect, aX, aY, aFlags);
103530: }
103530: 
 74283: gfx3DMatrix
 86353: nsIFrame::GetTransformMatrix(nsIFrame* aStopAtAncestor,
 86353:                              nsIFrame** aOutAncestor)
 19214: {
 19214:   NS_PRECONDITION(aOutAncestor, "Need a place to put the ancestor!");
 19214: 
 19214:   /* If we're transformed, we want to hand back the combination
 19214:    * transform/translate matrix that will apply our current transform, then
 19214:    * shift us to our parent.
 19214:    */
 19214:   if (IsTransformed()) {
 19214:     /* Compute the delta to the parent, which we need because we are converting
 19214:      * coordinates to our parent.
 19214:      */
 86353:     NS_ASSERTION(nsLayoutUtils::GetCrossDocParentFrame(this),
 86353:                  "Cannot transform the viewport frame!");
108991:     int32_t scaleFactor = PresContext()->AppUnitsPerDevPixel();
 19214: 
 74283:     gfx3DMatrix result =
107003:       nsDisplayTransform::GetResultingTransformMatrix(this, nsPoint(0, 0), scaleFactor, nullptr,
107003:                                                       nullptr, nullptr, nullptr, nullptr, aOutAncestor);
 98711:     // XXXjwatt: seems like this will double count offsets in the face of preserve-3d:
 77286:     nsPoint delta = GetOffsetToCrossDoc(*aOutAncestor);
 19214:     /* Combine the raw transform with a translation to our parent. */
 74753:     result *= gfx3DMatrix::Translation
 74283:       (NSAppUnitsToFloatPixels(delta.x, scaleFactor),
 74283:        NSAppUnitsToFloatPixels(delta.y, scaleFactor),
 74283:        0.0f);
 19214:     return result;
 19214:   }
 19214: 
 77286:   *aOutAncestor = nsLayoutUtils::GetCrossDocParentFrame(this);
 77286: 
 19214:   /* Otherwise, we're not transformed.  In that case, we'll walk up the frame
 19214:    * tree until we either hit the root frame or something that may be
 19214:    * transformed.  We'll then change coordinates into that frame, since we're
 19214:    * guaranteed that nothing in-between can be transformed.  First, however,
 19214:    * we have to check to see if we have a parent.  If not, we'll set the
 19214:    * outparam to null (indicating that there's nothing left) and will hand back
 19214:    * the identity matrix.
 19214:    */
 19214:   if (!*aOutAncestor)
 74283:     return gfx3DMatrix();
 19214:   
 19214:   /* Keep iterating while the frame can't possibly be transformed. */
 86353:   while (!(*aOutAncestor)->IsTransformed() && *aOutAncestor != aStopAtAncestor) {
 19214:     /* If no parent, stop iterating.  Otherwise, update the ancestor. */
 19214:     nsIFrame* parent = nsLayoutUtils::GetCrossDocParentFrame(*aOutAncestor);
 19214:     if (!parent)
 19214:       break;
 19214: 
 19214:     *aOutAncestor = parent;
 19214:   }
 19214: 
 19214:   NS_ASSERTION(*aOutAncestor, "Somehow ended up with a null ancestor...?");
 19214: 
 19214:   /* Translate from this frame to our ancestor, if it exists.  That's the
 19214:    * entire transform, so we're done.
 19214:    */
 47902:   nsPoint delta = GetOffsetToCrossDoc(*aOutAncestor);
108991:   int32_t scaleFactor = PresContext()->AppUnitsPerDevPixel();
 74283:   return gfx3DMatrix().Translation
 74283:     (NSAppUnitsToFloatPixels(delta.x, scaleFactor),
 74283:      NSAppUnitsToFloatPixels(delta.y, scaleFactor),
 74283:      0.0f);
     1: }
     1: 
     1: void
103530: nsIFrame::InvalidateRectDifference(const nsRect& aR1, const nsRect& aR2)
103530: {
103530:   nsRect sizeHStrip, sizeVStrip;
103530:   nsLayoutUtils::GetRectDifferenceStrips(aR1, aR2, &sizeHStrip, &sizeVStrip);
103530:   Invalidate(sizeVStrip);
103530:   Invalidate(sizeHStrip);
101681: }
101681: 
101681: void
103530: nsIFrame::InvalidateFrameSubtree()
103530: {
103530:   Invalidate(GetVisualOverflowRectRelativeToSelf());
103530:   FrameLayerBuilder::InvalidateThebesLayersInSubtree(this);
101681: }
101681: 
101681: void
103530: nsIFrame::InvalidateOverflowRect()
103530: {
103530:   Invalidate(GetVisualOverflowRectRelativeToSelf());
103530: }
103530: 
103530: NS_DECLARE_FRAME_PROPERTY(DeferInvalidatesProperty, nsIFrame::DestroyRegion)
103295: 
103295: void
108991: nsIFrame::InvalidateRoot(const nsRect& aDamageRect, uint32_t aFlags)
103530: {
103530:   NS_ASSERTION(nsLayoutUtils::GetDisplayRootFrame(this) == this,
103530:                "Can only call this on display roots");
103530: 
103530:   if ((mState & NS_FRAME_HAS_CONTAINER_LAYER) &&
103530:       !(aFlags & INVALIDATE_NO_THEBES_LAYERS)) {
103530:     FrameLayerBuilder::InvalidateThebesLayerContents(this, aDamageRect);
103530:     if (aFlags & INVALIDATE_ONLY_THEBES_LAYERS) {
103295:       return;
103295:     }
103530:   }
103530: 
103530:   nsRect rect = aDamageRect;
103530:   nsRegion* excludeRegion = static_cast<nsRegion*>
103530:     (Properties().Get(DeferInvalidatesProperty()));
103530:   if (excludeRegion && (aFlags & INVALIDATE_EXCLUDE_CURRENT_PAINT)) {
103530:     nsRegion r;
103530:     r.Sub(rect, *excludeRegion);
103530:     if (r.IsEmpty())
103530:       return;
103530:     rect = r.GetBounds();
103530:   }
103530: 
103530:   if (!(aFlags & INVALIDATE_NO_UPDATE_LAYER_TREE)) {
103530:     AddStateBits(NS_FRAME_UPDATE_LAYER_TREE);
103530:   }
103530: 
103530:   nsIView* view = GetView();
103530:   NS_ASSERTION(view, "This can only be called on frames with views");
103530:   view->GetViewManager()->InvalidateViewNoSuppression(view, rect);
103530: }
101681: 
101681: void
 47735: nsIFrame::BeginDeferringInvalidatesForDisplayRoot(const nsRegion& aExcludeRegion)
 47735: {
 47735:   NS_ASSERTION(nsLayoutUtils::GetDisplayRootFrame(this) == this,
 47735:                "Can only call this on display roots");
 47735:   Properties().Set(DeferInvalidatesProperty(), new nsRegion(aExcludeRegion));
 47735: }
 47735: 
 47735: void
 47735: nsIFrame::EndDeferringInvalidatesForDisplayRoot()
 47735: {
 47735:   NS_ASSERTION(nsLayoutUtils::GetDisplayRootFrame(this) == this,
 47735:                "Can only call this on display roots");
 47735:   Properties().Delete(DeferInvalidatesProperty());
     1: }
     1: 
 20711: /**
 20711:  * @param aAnyOutlineOrEffects set to true if this frame has any
 20711:  * outline, SVG effects or box shadows that mean we need to invalidate
 20711:  * the whole overflow area if the frame's size changes.
 20711:  */
 19125: static nsRect
 79445: ComputeOutlineAndEffectsRect(nsIFrame* aFrame, bool* aAnyOutlineOrEffects,
 19125:                              const nsRect& aOverflowRect,
 35702:                              const nsSize& aNewSize,
 79445:                              bool aStoreRectProperties) {
 19125:   nsRect r = aOverflowRect;
 80486:   *aAnyOutlineOrEffects = false;
 19125: 
 98711:   if (aFrame->GetStateBits() & NS_FRAME_SVG_LAYOUT) {
 98711:     // For SVG frames, we only need to account for filters.
 98711:     // TODO: We could also take account of clipPath and mask to reduce the
 98711:     // visual overflow, but that's not essential.
 98711:     if (aFrame->GetStyleSVGReset()->mFilter) {
 98711:       *aAnyOutlineOrEffects = true;
 98711:       if (aStoreRectProperties) {
 98711:         aFrame->Properties().
 98711:           Set(nsIFrame::PreEffectsBBoxProperty(), new nsRect(r));
 98711:       }
 98711:       r = nsSVGUtils::GetPostFilterVisualOverflowRect(aFrame, aOverflowRect);
 98711:     }
 98711:     return r;
 98711:   }
 98711: 
 19125:   // box-shadow
 51262:   nsCSSShadowArray* boxShadows = aFrame->GetStyleBorder()->mBoxShadow;
 26940:   if (boxShadows) {
 19125:     nsRect shadows;
108991:     int32_t A2D = aFrame->PresContext()->AppUnitsPerDevPixel();
108991:     for (uint32_t i = 0; i < boxShadows->Length(); ++i) {
 35702:       nsRect tmpRect(nsPoint(0, 0), aNewSize);
 19125:       nsCSSShadowItem* shadow = boxShadows->ShadowAt(i);
 24818: 
 24818:       // inset shadows are never painted outside the frame
 24818:       if (shadow->mInset)
 24818:         continue;
 19207: 
 19207:       tmpRect.MoveBy(nsPoint(shadow->mXOffset, shadow->mYOffset));
 52476:       tmpRect.Inflate(shadow->mSpread, shadow->mSpread);
 52476:       tmpRect.Inflate(
 52476:         nsContextBoxBlur::GetBlurRadiusMargin(shadow->mRadius, A2D));
 19125: 
 19125:       shadows.UnionRect(shadows, tmpRect);
 19125:     }
 19125:     r.UnionRect(r, shadows);
 80486:     *aAnyOutlineOrEffects = true;
 19125:   }
 19125: 
     1:   const nsStyleOutline* outline = aFrame->GetStyleOutline();
108991:   uint8_t outlineStyle = outline->GetOutlineStyle();
     1:   if (outlineStyle != NS_STYLE_BORDER_STYLE_NONE) {
     1:     nscoord width;
     1: #ifdef DEBUG
 79445:     bool result = 
     1: #endif
     1:       outline->GetOutlineWidth(width);
     1:     NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
     1:     if (width > 0) {
 19125:       if (aStoreRectProperties) {
 39965:         aFrame->Properties().
 39965:           Set(nsIFrame::OutlineInnerRectProperty(), new nsRect(r));
 19125:       }
 19125: 
 19205:       nscoord offset = outline->mOutlineOffset;
 32531:       nscoord inflateBy = NS_MAX(width + offset, 0);
 55040:       // FIXME (bug 599652): We probably want outline to be drawn around
 55040:       // something smaller than the visual overflow rect (perhaps the
 55040:       // scrollable overflow rect is correct).  When we change that, we
 55040:       // need to keep this code (and the storing of properties just
 55040:       // above) in sync with GetOutlineInnerRect in nsCSSRendering.cpp.
     1:       r.Inflate(inflateBy, inflateBy);
 80486:       *aAnyOutlineOrEffects = true;
 19125:     }
 19125:   }
 19125: 
 86084:   // border-image-outset.
 86084:   // We need to include border-image-outset because it can cause the
 86084:   // border image to be drawn beyond the border box.
 86084: 
 86084:   // (1) It's important we not check whether there's a border-image
 86084:   //     since the style hint for a change in border image doesn't cause
 86084:   //     reflow, and that's probably more important than optimizing the
 86084:   //     overflow areas for the silly case of border-image-outset without
 86084:   //     border-image
 86084:   // (2) It's important that we not check whether the border-image
 86084:   //     is actually loaded, since that would require us to reflow when
 86084:   //     the image loads.
 86084:   const nsStyleBorder* styleBorder = aFrame->GetStyleBorder();
 86084:   nsMargin outsetMargin = styleBorder->GetImageOutset();
 86084: 
 86084:   if (outsetMargin != nsMargin(0, 0, 0, 0)) {
 86084:     nsRect outsetRect(nsPoint(0, 0), aNewSize);
 86084:     outsetRect.Inflate(outsetMargin);
 86084:     r.UnionRect(r, outsetRect);
 86084: 
 86084:     *aAnyOutlineOrEffects = true;
 86084:   }
 86084: 
 19125:   // Note that we don't remove the outlineInnerRect if a frame loses outline
 19125:   // style. That would require an extra property lookup for every frame,
 19125:   // or a new frame state bit to track whether a property had been stored,
 19125:   // or something like that. It's not worth doing that here. At most it's
 19125:   // only one heap-allocated rect per frame and it will be cleaned up when
 19125:   // the frame dies.
 19125: 
 19125:   if (nsSVGIntegrationUtils::UsingEffectsForFrame(aFrame)) {
 80486:     *aAnyOutlineOrEffects = true;
 19125:     if (aStoreRectProperties) {
 39965:       aFrame->Properties().
 39965:         Set(nsIFrame::PreEffectsBBoxProperty(), new nsRect(r));
 19125:     }
102527:     r = nsSVGIntegrationUtils::ComputePostEffectsVisualOverflowRect(aFrame, r);
 19125:   }
 19125: 
     1:   return r;
     1: }
     1: 
 14460: nsPoint
 14460: nsIFrame::GetRelativeOffset(const nsStyleDisplay* aDisplay) const
 14460: {
107225:   if (!aDisplay ||
107225:       aDisplay->IsRelativelyPositioned(this)) {
 14460:     nsPoint *offsets = static_cast<nsPoint*>
 39965:       (Properties().Get(ComputedOffsetProperty()));
 14460:     if (offsets) {
 14460:       return *offsets;
 14460:     }
 14460:   }
 14460:   return nsPoint(0,0);
 14460: }
 14460: 
     1: nsRect
 55021: nsIFrame::GetOverflowRect(nsOverflowType aType) const
 55021: {
 55021:   NS_ABORT_IF_FALSE(aType == eVisualOverflow || aType == eScrollableOverflow,
 55021:                     "unexpected type");
 55021: 
     1:   // Note that in some cases the overflow area might not have been
     1:   // updated (yet) to reflect any outline set on the frame or the area
     1:   // of child frames. That's OK because any reflow that updates these
     1:   // areas will invalidate the appropriate area, so any (mis)uses of
     1:   // this method will be fixed up.
 11909: 
 26950:   if (mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) {
 26950:     // there is an overflow rect, and it's not stored as deltas but as
 26950:     // a separately-allocated rect
 55021:     return static_cast<nsOverflowAreas*>(const_cast<nsIFrame*>(this)->
 55021:              GetOverflowAreasProperty())->Overflow(aType);
 55021:   }
 55021: 
 55021:   if (aType == eVisualOverflow &&
 55021:       mOverflow.mType != NS_FRAME_OVERFLOW_NONE) {
 55021:     return GetVisualOverflowFromDeltas();
 55021:   }
 55021: 
 55021:   return nsRect(nsPoint(0, 0), GetSize());
 55021: }
 55021: 
 55021: nsOverflowAreas
 55021: nsIFrame::GetOverflowAreas() const
 55021: {
 55021:   if (mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) {
 55021:     // there is an overflow rect, and it's not stored as deltas but as
 55021:     // a separately-allocated rect
 55021:     return *const_cast<nsIFrame*>(this)->GetOverflowAreasProperty();
 55021:   }
 55021: 
 55021:   return nsOverflowAreas(GetVisualOverflowFromDeltas(),
 55021:                          nsRect(nsPoint(0, 0), GetSize()));
     1: }
     1: 
 19284: nsRect
 55021: nsIFrame::GetScrollableOverflowRectRelativeToParent() const
 55021: {
 55021:   return GetScrollableOverflowRect() + mRect.TopLeft();
 19284: }
 19284: 
 19284: nsRect
 55021: nsIFrame::GetVisualOverflowRectRelativeToSelf() const
 19284: {
 50423:   if (IsTransformed()) {
 87626:     nsOverflowAreas* preTransformOverflows = static_cast<nsOverflowAreas*>
 87626:       (Properties().Get(PreTransformOverflowAreasProperty()));
 87626:     if (preTransformOverflows)
 87626:       return preTransformOverflows->VisualOverflow();
 39967:   }
 55021:   return GetVisualOverflowRect();
 19284: }
 19284: 
102946: nsRect
102946: nsIFrame::GetPreEffectsVisualOverflowRect() const
102946: {
102946:   nsRect* r = static_cast<nsRect*>
102946:     (Properties().Get(nsIFrame::PreEffectsBBoxProperty()));
102946:   return r ? *r : GetVisualOverflowRectRelativeToSelf();
102946: }
102946: 
 87626: /* virtual */ bool
 87626: nsFrame::UpdateOverflow()
 87626: {
108285:   MOZ_ASSERT(!(mState & NS_FRAME_SVG_LAYOUT) ||
108285:              !(mState & NS_STATE_SVG_NONDISPLAY_CHILD),
108285:              "Non-display SVG do not maintain visual overflow rects");
108285: 
 87626:   nsRect rect(nsPoint(0, 0), GetSize());
 87626:   nsOverflowAreas overflowAreas(rect, rect);
 87626: 
 87626:   bool isBox = IsBoxFrame() || IsBoxWrapped();
 87626:   if (!isBox || (!IsCollapsed() && !DoesClipChildren())) {
 87626:     nsLayoutUtils::UnionChildOverflow(this, overflowAreas);
 87626:   }
 87626: 
 87626:   if (FinishAndStoreOverflow(overflowAreas, GetSize())) {
 87626:     nsIView* view = GetView();
 87626:     if (view) {
108991:       uint32_t flags = 0;
 87626:       GetLayoutFlags(flags);
 87626: 
 87626:       if ((flags & NS_FRAME_NO_SIZE_VIEW) == 0) {
 87626:         // Make sure the frame's view is properly sized.
 87626:         nsIViewManager* vm = view->GetViewManager();
 87626:         vm->ResizeView(view, overflowAreas.VisualOverflow(), true);
 87626:       }
 87626:     }
 87626: 
 87626:     return true;
 87626:   }
 87626: 
 87626:   return false;
 87626: }
 87626: 
103530: void
103530: nsFrame::CheckInvalidateSizeChange(nsHTMLReflowMetrics& aNewDesiredSize)
103530: {
103530:   nsIFrame::CheckInvalidateSizeChange(mRect, GetVisualOverflowRect(),
103530:       nsSize(aNewDesiredSize.width, aNewDesiredSize.height));
103530: }
103530: 
103530: static void
103530: InvalidateRectForFrameSizeChange(nsIFrame* aFrame, const nsRect& aRect)
103530: {
103530:   nsStyleContext *bgSC;
103530:   if (!nsCSSRendering::FindBackground(aFrame->PresContext(), aFrame, &bgSC)) {
103530:     nsIFrame* rootFrame =
103530:       aFrame->PresContext()->PresShell()->FrameManager()->GetRootFrame();
103530:     rootFrame->Invalidate(nsRect(nsPoint(0, 0), rootFrame->GetSize()));
103530:   }
103530: 
103530:   aFrame->Invalidate(aRect);
103530: }
103530: 
103530: void
103530: nsIFrame::CheckInvalidateSizeChange(const nsRect& aOldRect,
103530:                                     const nsRect& aOldVisualOverflowRect,
103530:                                     const nsSize& aNewDesiredSize)
103530: {
103530:   if (aNewDesiredSize == aOldRect.Size())
103530:     return;
103530: 
103530:   // Below, we invalidate the old frame area (or, in the case of
103530:   // outline, combined area) if the outline, border or background
103530:   // settings indicate that something other than the difference
103530:   // between the old and new areas needs to be painted. We are
103530:   // assuming that the difference between the old and new areas will
103530:   // be invalidated by some other means. That also means invalidating
103530:   // the old frame area is the same as invalidating the new frame area
103530:   // (since in either case the UNION of old and new areas will be
103530:   // invalidated)
103530: 
103530:   // We use InvalidateRectForFrameSizeChange throughout this method, even
103530:   // though root-invalidation is technically only needed in the case where
103530:   // layer.RenderingMightDependOnFrameSize().  This allows us to simplify the
103530:   // code somewhat and return immediately after invalidation in the earlier
103530:   // cases.
103530: 
103530:   // Invalidate the entire old frame+outline if the frame has an outline
103530:   bool anyOutlineOrEffects;
103530:   nsRect r = ComputeOutlineAndEffectsRect(this, &anyOutlineOrEffects,
103530:                                           aOldVisualOverflowRect,
103530:                                           aNewDesiredSize,
103530:                                           false);
103530:   if (anyOutlineOrEffects) {
103530:     r.UnionRect(aOldVisualOverflowRect, r);
103530:     InvalidateRectForFrameSizeChange(this, r);
103530:     return;
103530:   }
103530: 
103530:   // Invalidate the old frame border box if the frame has borders. Those
103530:   // borders may be moving.
103530:   const nsStyleBorder* border = GetStyleBorder();
103530:   NS_FOR_CSS_SIDES(side) {
103530:     if (border->GetComputedBorderWidth(side) != 0) {
103530:       if ((side == NS_SIDE_LEFT || side == NS_SIDE_TOP) &&
103530:           !nsLayoutUtils::HasNonZeroCornerOnSide(border->mBorderRadius, side) &&
103530:           !border->GetBorderImage() &&
103530:           border->GetBorderStyle(side) == NS_STYLE_BORDER_STYLE_SOLID) {
103530:         // We also need to be sure that the bottom-left or top-right
103530:         // corner is simple. For example, if the bottom or right border
103530:         // has a different color, we would need to invalidate the corner
103530:         // area. But that's OK because if there is a right or bottom border,
103530:         // we'll invalidate the entire border-box here anyway.
103530:         continue;
103530:       }
103530:       InvalidateRectForFrameSizeChange(this, nsRect(0, 0, aOldRect.width, aOldRect.height));
103530:       return;
103530:     }
103530:   }
103530: 
103530:   const nsStyleBackground *bg = GetStyleBackground();
103530:   if (!bg->IsTransparent()) {
103530:     // Invalidate the old frame background if the frame has a background
103530:     // whose position depends on the size of the frame
103530:     NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, bg) {
103530:       const nsStyleBackground::Layer &layer = bg->mLayers[i];
103530:       if (layer.RenderingMightDependOnFrameSize()) {
103530:         InvalidateRectForFrameSizeChange(this, nsRect(0, 0, aOldRect.width, aOldRect.height));
103530:         return;
103530:       }
103530:     }
103530: 
103530:     // Invalidate the old frame background if the frame has a background
103530:     // that is being clipped by border-radius, since the old or new area
103530:     // clipped off by the radius is not necessarily in the area that has
103530:     // already been invalidated (even if only the top-left corner has a
103530:     // border radius).
103530:     if (nsLayoutUtils::HasNonZeroCorner(border->mBorderRadius)) {
103530:       InvalidateRectForFrameSizeChange(this, nsRect(0, 0, aOldRect.width, aOldRect.height));
103530:       return;
103530:     }
103530:   }
103530: }
103530: 
     1: // Define the MAX_FRAME_DEPTH to be the ContentSink's MAX_REFLOW_DEPTH plus
     1: // 4 for the frames above the document's frames: 
     1: //  the Viewport, GFXScroll, ScrollPort, and Canvas
     1: #define MAX_FRAME_DEPTH (MAX_REFLOW_DEPTH+4)
     1: 
 79445: bool
     1: nsFrame::IsFrameTreeTooDeep(const nsHTMLReflowState& aReflowState,
 60343:                             nsHTMLReflowMetrics& aMetrics,
 60343:                             nsReflowStatus& aStatus)
     1: {
     1:   if (aReflowState.mReflowDepth >  MAX_FRAME_DEPTH) {
 60342:     NS_WARNING("frame tree too deep; setting zero size and returning");
  3724:     mState |= NS_FRAME_TOO_DEEP_IN_FRAME_TREE;
 55021:     ClearOverflowRects();
     1:     aMetrics.width = 0;
     1:     aMetrics.height = 0;
     1:     aMetrics.ascent = 0;
     1:     aMetrics.mCarriedOutBottomMargin.Zero();
 55039:     aMetrics.mOverflowAreas.Clear();
 60343: 
 60343:     if (GetNextInFlow()) {
 60343:       // Reflow depth might vary between reflows, so we might have
 60343:       // successfully reflowed and split this frame before.  If so, we
 60343:       // shouldn't delete its continuations.
 60343:       aStatus = NS_FRAME_NOT_COMPLETE;
 60343:     } else {
 60343:       aStatus = NS_FRAME_COMPLETE;
 60343:     }
 60343: 
 80486:     return true;
     1:   }
  3724:   mState &= ~NS_FRAME_TOO_DEEP_IN_FRAME_TREE;
 80486:   return false;
     1: }
     1: 
 79487: bool
 79487: nsIFrame::IsBlockWrapper() const
 79487: {
 79487:   nsIAtom *pseudoType = GetStyleContext()->GetPseudo();
 79487:   return (pseudoType == nsCSSAnonBoxes::mozAnonymousBlock ||
 79487:           pseudoType == nsCSSAnonBoxes::mozAnonymousPositionedBlock ||
 79487:           pseudoType == nsCSSAnonBoxes::cellContent);
 79487: }
 79487: 
 79487: static nsIFrame*
 79487: GetNearestBlockContainer(nsIFrame* frame)
 79487: {
 79487:   // The block wrappers we use to wrap blocks inside inlines aren't
 79487:   // described in the CSS spec.  We need to make them not be containing
 79487:   // blocks.
 79487:   // Since the parent of such a block is either a normal block or
 79487:   // another such pseudo, this shouldn't cause anything bad to happen.
 79487:   // Also the anonymous blocks inside table cells are not containing blocks.
 79487:   while (frame->IsFrameOfType(nsIFrame::eLineParticipant) ||
 90880:          frame->IsBlockWrapper() ||
 90880:          // Table rows are not containing blocks either
 90880:          frame->GetType() == nsGkAtoms::tableRowFrame) {
 79487:     frame = frame->GetParent();
 79487:     NS_ASSERTION(frame, "How come we got to the root frame without seeing a containing block?");
 79487:   }
 79487:   return frame;
 79487: }
 79487: 
 79487: nsIFrame*
 79487: nsIFrame::GetContainingBlock() const
 79487: {
 79487:   // MathML frames might have absolute positioning style, but they would
 79487:   // still be in-flow.  So we have to check to make sure that the frame
 79487:   // is really out-of-flow too.
107225:   if (IsAbsolutelyPositioned() &&
 79487:       (GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
 79487:     return GetParent(); // the parent is always the containing block
 79487:   }
 79487:   return GetNearestBlockContainer(GetParent());
     1: }
     1: 
102909: #ifdef DEBUG
     1: 
108991: int32_t nsFrame::ContentIndexInContainer(const nsIFrame* aFrame)
108991: {
108991:   int32_t result = -1;
     1: 
     1:   nsIContent* content = aFrame->GetContent();
     1:   if (content) {
     1:     nsIContent* parentContent = content->GetParent();
     1:     if (parentContent) {
     1:       result = parentContent->IndexOf(content);
     1:     }
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
     1: /**
     1:  * List a frame tree to stdout. Meant to be called from gdb.
     1:  */
     1: void
     1: DebugListFrameTree(nsIFrame* aFrame)
     1: {
     1:   ((nsFrame*)aFrame)->List(stdout, 0);
     1: }
     1: 
     1: 
     1: // Debugging
     1: NS_IMETHODIMP
108991: nsFrame::List(FILE* out, int32_t aIndent) const
     1: {
     1:   IndentBy(out, aIndent);
     1:   ListTag(out);
     1: #ifdef DEBUG_waterson
  3233:   fprintf(out, " [parent=%p]", static_cast<void*>(mParent));
     1: #endif
     1:   if (HasView()) {
  3233:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
     1:   }
     1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
     1:   if (0 != mState) {
 85981:     fprintf(out, " [state=%016llx]", (unsigned long long)mState);
     1:   }
     1:   nsIFrame* prevInFlow = GetPrevInFlow();
     1:   nsIFrame* nextInFlow = GetNextInFlow();
106838:   if (nullptr != prevInFlow) {
  3233:     fprintf(out, " prev-in-flow=%p", static_cast<void*>(prevInFlow));
     1:   }
106838:   if (nullptr != nextInFlow) {
  3233:     fprintf(out, " next-in-flow=%p", static_cast<void*>(nextInFlow));
  3233:   }
  3233:   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
  3233:   nsFrame* f = const_cast<nsFrame*>(this);
 55040:   if (f->HasOverflowAreas()) {
 55040:     nsRect overflowArea = f->GetVisualOverflowRect();
 55040:     fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
 55040:             overflowArea.width, overflowArea.height);
 55040:     overflowArea = f->GetScrollableOverflowRect();
 55040:     fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
 11909:             overflowArea.width, overflowArea.height);
     1:   }
 46249:   fprintf(out, " [sc=%p]", static_cast<void*>(mStyleContext));
     1:   fputs("\n", out);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFrame::GetFrameName(nsAString& aResult) const
     1: {
     1:   return MakeFrameName(NS_LITERAL_STRING("Frame"), aResult);
     1: }
     1: 
     1: NS_IMETHODIMP_(nsFrameState)
     1: nsFrame::GetDebugStateBits() const
     1: {
     1:   // We'll ignore these flags for the purposes of comparing frame state:
     1:   //
     1:   //   NS_FRAME_EXTERNAL_REFERENCE
     1:   //     because this is set by the event state manager or the
     1:   //     caret code when a frame is focused. Depending on whether
     1:   //     or not the regression tests are run as the focused window
     1:   //     will make this value vary randomly.
     1: #define IRRELEVANT_FRAME_STATE_FLAGS NS_FRAME_EXTERNAL_REFERENCE
     1: 
     1: #define FRAME_STATE_MASK (~(IRRELEVANT_FRAME_STATE_FLAGS))
     1: 
     1:   return GetStateBits() & FRAME_STATE_MASK;
     1: }
     1: 
     1: nsresult
     1: nsFrame::MakeFrameName(const nsAString& aType, nsAString& aResult) const
     1: {
     1:   aResult = aType;
     1:   if (mContent && !mContent->IsNodeOfType(nsINode::eTEXT)) {
     1:     nsAutoString buf;
     1:     mContent->Tag()->ToString(buf);
108280:     if (GetType() == nsGkAtoms::subDocumentFrame) {
108280:       nsAutoString src;
108280:       mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::src, src);
108280:       buf.Append(NS_LITERAL_STRING(" src=") + src);
108280:     }
     1:     aResult.Append(NS_LITERAL_STRING("(") + buf + NS_LITERAL_STRING(")"));
     1:   }
     1:   char buf[40];
     1:   PR_snprintf(buf, sizeof(buf), "(%d)", ContentIndexInContainer(this));
     1:   AppendASCIItoUTF16(buf, aResult);
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsFrame::XMLQuote(nsString& aString)
     1: {
108991:   int32_t i, len = aString.Length();
     1:   for (i = 0; i < len; i++) {
     1:     PRUnichar ch = aString.CharAt(i);
     1:     if (ch == '<') {
     1:       nsAutoString tmp(NS_LITERAL_STRING("&lt;"));
     1:       aString.Cut(i, 1);
     1:       aString.Insert(tmp, i);
     1:       len += 3;
     1:       i += 3;
     1:     }
     1:     else if (ch == '>') {
     1:       nsAutoString tmp(NS_LITERAL_STRING("&gt;"));
     1:       aString.Cut(i, 1);
     1:       aString.Insert(tmp, i);
     1:       len += 3;
     1:       i += 3;
     1:     }
     1:     else if (ch == '\"') {
     1:       nsAutoString tmp(NS_LITERAL_STRING("&quot;"));
     1:       aString.Cut(i, 1);
     1:       aString.Insert(tmp, i);
     1:       len += 5;
     1:       i += 5;
     1:     }
     1:   }
     1: }
     1: #endif
     1: 
 79445: bool
     1: nsIFrame::IsVisibleForPainting(nsDisplayListBuilder* aBuilder) {
     1:   if (!GetStyleVisibility()->IsVisible())
 80486:     return false;
     1:   nsISelection* sel = aBuilder->GetBoundingSelection();
     1:   return !sel || IsVisibleInSelection(sel);
     1: }
     1: 
 79445: bool
     1: nsIFrame::IsVisibleForPainting() {
     1:   if (!GetStyleVisibility()->IsVisible())
 80486:     return false;
     1: 
   238:   nsPresContext* pc = PresContext();
     1:   if (!pc->IsRenderingOnlySelection())
 80486:     return true;
     1: 
     1:   nsCOMPtr<nsISelectionController> selcon(do_QueryInterface(pc->PresShell()));
     1:   if (selcon) {
     1:     nsCOMPtr<nsISelection> sel;
     1:     selcon->GetSelection(nsISelectionController::SELECTION_NORMAL,
     1:                          getter_AddRefs(sel));
     1:     if (sel)
     1:       return IsVisibleInSelection(sel);
     1:   }
 80486:   return true;
     1: }
     1: 
 79445: bool
     1: nsIFrame::IsVisibleInSelection(nsDisplayListBuilder* aBuilder) {
     1:   nsISelection* sel = aBuilder->GetBoundingSelection();
     1:   return !sel || IsVisibleInSelection(sel);
     1: }
     1: 
 79445: bool
     1: nsIFrame::IsVisibleOrCollapsedForPainting(nsDisplayListBuilder* aBuilder) {
     1:   if (!GetStyleVisibility()->IsVisibleOrCollapsed())
 80486:     return false;
     1:   nsISelection* sel = aBuilder->GetBoundingSelection();
     1:   return !sel || IsVisibleInSelection(sel);
     1: }
     1: 
 79445: bool
     1: nsIFrame::IsVisibleInSelection(nsISelection* aSelection)
     1: {
 85101:   if (!GetContent() || !GetContent()->IsSelectionDescendant()) {
 85101:     return false;
 85101:   }
     1:   
     1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent));
 79445:   bool vis;
 80486:   nsresult rv = aSelection->ContainsNode(node, true, &vis);
     1:   return NS_FAILED(rv) || vis;
     1: }
     1: 
 79445: /* virtual */ bool
     1: nsFrame::IsEmpty()
     1: {
 80486:   return false;
     1: }
     1: 
 79445: bool
     1: nsIFrame::CachedIsEmpty()
     1: {
     1:   NS_PRECONDITION(!(GetStateBits() & NS_FRAME_IS_DIRTY),
     1:                   "Must only be called on reflowed lines");
     1:   return IsEmpty();
     1: }
     1: 
 79445: /* virtual */ bool
     1: nsFrame::IsSelfEmpty()
     1: {
 80486:   return false;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFrame::GetSelectionController(nsPresContext *aPresContext, nsISelectionController **aSelCon)
     1: {
     1:   if (!aPresContext || !aSelCon)
     1:     return NS_ERROR_INVALID_ARG;
     1: 
     1:   nsIFrame *frame = this;
     1:   while (frame && (frame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION)) {
 23554:     nsITextControlFrame *tcf = do_QueryFrame(frame);
 23554:     if (tcf) {
 43129:       return tcf->GetOwnedSelectionController(aSelCon);
     1:     }
     1:     frame = frame->GetParent();
     1:   }
     1: 
     1:   return CallQueryInterface(aPresContext->GetPresShell(), aSelCon);
     1: }
     1: 
  8295: already_AddRefed<nsFrameSelection>
  8295: nsIFrame::GetFrameSelection()
  8295: {
  8295:   nsFrameSelection* fs =
  8295:     const_cast<nsFrameSelection*>(GetConstFrameSelection());
  8295:   NS_IF_ADDREF(fs);
  8295:   return fs;
  8295: }
  8295: 
  8295: const nsFrameSelection*
 85101: nsIFrame::GetConstFrameSelection() const
 85101: {
 85101:   nsIFrame* frame = const_cast<nsIFrame*>(this);
     1:   while (frame && (frame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION)) {
 23554:     nsITextControlFrame* tcf = do_QueryFrame(frame);
 23554:     if (tcf) {
     1:       return tcf->GetOwnedFrameSelection();
     1:     }
     1:     frame = frame->GetParent();
     1:   }
     1: 
  8295:   return PresContext()->PresShell()->ConstFrameSelection();
     1: }
     1: 
102909: #ifdef DEBUG
     1: NS_IMETHODIMP
108991: nsFrame::DumpRegressionData(nsPresContext* aPresContext, FILE* out, int32_t aIndent)
     1: {
     1:   IndentBy(out, aIndent);
     1:   fprintf(out, "<frame va=\"%ld\" type=\"", PRUptrdiff(this));
     1:   nsAutoString name;
     1:   GetFrameName(name);
     1:   XMLQuote(name);
     1:   fputs(NS_LossyConvertUTF16toASCII(name).get(), out);
 43479:   fprintf(out, "\" state=\"%016llx\" parent=\"%ld\">\n",
 85981:           (unsigned long long)GetDebugStateBits(), PRUptrdiff(mParent));
     1: 
     1:   aIndent++;
 24806:   DumpBaseRegressionData(aPresContext, out, aIndent);
     1:   aIndent--;
     1: 
     1:   IndentBy(out, aIndent);
     1:   fprintf(out, "</frame>\n");
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
108991: nsFrame::DumpBaseRegressionData(nsPresContext* aPresContext, FILE* out, int32_t aIndent)
     1: {
 32845:   if (GetNextSibling()) {
     1:     IndentBy(out, aIndent);
 32845:     fprintf(out, "<next-sibling va=\"%ld\"/>\n", PRUptrdiff(GetNextSibling()));
     1:   }
     1: 
     1:   if (HasView()) {
     1:     IndentBy(out, aIndent);
     1:     fprintf(out, "<view va=\"%ld\">\n", PRUptrdiff(GetView()));
     1:     aIndent++;
     1:     // XXX add in code to dump out view state too...
     1:     aIndent--;
     1:     IndentBy(out, aIndent);
     1:     fprintf(out, "</view>\n");
     1:   }
     1: 
     1:   IndentBy(out, aIndent);
     1:   fprintf(out, "<bbox x=\"%d\" y=\"%d\" w=\"%d\" h=\"%d\"/>\n",
     1:           mRect.x, mRect.y, mRect.width, mRect.height);
     1: 
     1:   // Now dump all of the children on all of the child lists
 77153:   ChildListIterator lists(this);
 77153:   for (; !lists.IsDone(); lists.Next()) {
     1:     IndentBy(out, aIndent);
 77153:     if (lists.CurrentID() != kPrincipalList) {
 77153:       fprintf(out, "<child-list name=\"%s\">\n", mozilla::layout::ChildListName(lists.CurrentID()));
     1:     }
     1:     else {
     1:       fprintf(out, "<child-list>\n");
     1:     }
     1:     aIndent++;
 77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 77153:       nsIFrame* kid = childFrames.get();
 31709:       kid->DumpRegressionData(aPresContext, out, aIndent);
     1:     }
     1:     aIndent--;
     1:     IndentBy(out, aIndent);
     1:     fprintf(out, "</child-list>\n");
     1:   }
     1: }
     1: #endif
     1: 
 85101: bool
 85101: nsIFrame::IsFrameSelected() const
 85101: {
 85101:   NS_ASSERTION(!GetContent() || GetContent()->IsSelectionDescendant(),
 85101:                "use the public IsSelected() instead");
 85101:   return nsRange::IsNodeSelected(GetContent(), 0,
 85101:                                  GetContent()->GetChildCount());
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsFrame::GetPointFromOffset(int32_t inOffset, nsPoint* outPoint)
     1: {
106838:   NS_PRECONDITION(outPoint != nullptr, "Null parameter");
 38960:   nsRect contentRect = GetContentRect() - GetPosition();
 38960:   nsPoint pt = contentRect.TopLeft();
     1:   if (mContent)
     1:   {
     1:     nsIContent* newContent = mContent->GetParent();
     1:     if (newContent){
108991:       int32_t newOffset = newContent->IndexOf(mContent);
     1: 
 79445:       bool isRTL = (NS_GET_EMBEDDING_LEVEL(this) & 1) == 1;
 19264:       if ((!isRTL && inOffset > newOffset) ||
 38960:           (isRTL && inOffset <= newOffset)) {
 38960:         pt = contentRect.TopRight();
 38960:       }
 38960:     }
 38960:   }
 38960:   *outPoint = pt;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsFrame::GetChildFrameContainingOffset(int32_t inContentOffset, bool inHint, int32_t* outFrameContentOffset, nsIFrame **outChildFrame)
     1: {
     1:   NS_PRECONDITION(outChildFrame && outFrameContentOffset, "Null parameter");
108991:   *outFrameContentOffset = (int32_t)inHint;
     1:   //the best frame to reflect any given offset would be a visible frame if possible
     1:   //i.e. we are looking for a valid frame to place the blinking caret 
     1:   nsRect rect = GetRect();
     1:   if (!rect.width || !rect.height)
     1:   {
     1:     //if we have a 0 width or height then lets look for another frame that possibly has
     1:     //the same content.  If we have no frames in flow then just let us return 'this' frame
     1:     nsIFrame* nextFlow = GetNextInFlow();
     1:     if (nextFlow)
     1:       return nextFlow->GetChildFrameContainingOffset(inContentOffset, inHint, outFrameContentOffset, outChildFrame);
     1:   }
     1:   *outChildFrame = this;
     1:   return NS_OK;
     1: }
     1: 
     1: //
     1: // What I've pieced together about this routine:
     1: // Starting with a block frame (from which a line frame can be gotten)
     1: // and a line number, drill down and get the first/last selectable
     1: // frame on that line, depending on aPos->mDirection.
     1: // aOutSideLimit != 0 means ignore aLineStart, instead work from
     1: // the end (if > 0) or beginning (if < 0).
     1: //
     1: nsresult
     1: nsFrame::GetNextPrevLineFromeBlockFrame(nsPresContext* aPresContext,
     1:                                         nsPeekOffsetStruct *aPos,
     1:                                         nsIFrame *aBlockFrame, 
108991:                                         int32_t aLineStart, 
108991:                                         int8_t aOutSideLimit
     1:                                         )
     1: {
     1:   //magic numbers aLineStart will be -1 for end of block 0 will be start of block
     1:   if (!aBlockFrame || !aPos)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
106838:   aPos->mResultFrame = nullptr;
106838:   aPos->mResultContent = nullptr;
     1:   aPos->mAttachForward = (aPos->mDirection == eDirNext);
     1: 
 21112:   nsAutoLineIterator it = aBlockFrame->GetLineIterator();
 21112:   if (!it)
 21112:     return NS_ERROR_FAILURE;
108991:   int32_t searchingLine = aLineStart;
108991:   int32_t countLines = it->GetNumLines();
     1:   if (aOutSideLimit > 0) //start at end
     1:     searchingLine = countLines;
     1:   else if (aOutSideLimit <0)//start at beginning
     1:     searchingLine = -1;//"next" will be 0  
     1:   else 
     1:     if ((aPos->mDirection == eDirPrevious && searchingLine == 0) || 
     1:        (aPos->mDirection == eDirNext && searchingLine >= (countLines -1) )){
     1:       //we need to jump to new block frame.
     1:            return NS_ERROR_FAILURE;
     1:     }
108991:   int32_t lineFrameCount;
106838:   nsIFrame *resultFrame = nullptr;
106838:   nsIFrame *farStoppingFrame = nullptr; //we keep searching until we find a "this" frame then we go to next line
106838:   nsIFrame *nearStoppingFrame = nullptr; //if we are backing up from edge, stop here
     1:   nsIFrame *firstFrame;
     1:   nsIFrame *lastFrame;
     1:   nsRect  rect;
 79445:   bool isBeforeFirstFrame, isAfterLastFrame;
 79445:   bool found = false;
 21112: 
 21112:   nsresult result = NS_OK;
     1:   while (!found)
     1:   {
     1:     if (aPos->mDirection == eDirPrevious)
     1:       searchingLine --;
     1:     else
     1:       searchingLine ++;
     1:     if ((aPos->mDirection == eDirPrevious && searchingLine < 0) || 
     1:        (aPos->mDirection == eDirNext && searchingLine >= countLines ))
     1:     {
     1:       //we need to jump to new block frame.
     1:       return NS_ERROR_FAILURE;
     1:     }
108991:     uint32_t lineFlags;
     1:     result = it->GetLine(searchingLine, &firstFrame, &lineFrameCount,
     1:                          rect, &lineFlags);
     1:     if (!lineFrameCount) 
     1:       continue;
     1:     if (NS_SUCCEEDED(result)){
     1:       lastFrame = firstFrame;
     1:       for (;lineFrameCount > 1;lineFrameCount --){
     1:         //result = lastFrame->GetNextSibling(&lastFrame, searchingLine);
     1:         result = it->GetNextSiblingOnLine(lastFrame, searchingLine);
     1:         if (NS_FAILED(result) || !lastFrame){
     1:           NS_ERROR("GetLine promised more frames than could be found");
     1:           return NS_ERROR_FAILURE;
     1:         }
     1:       }
     1:       GetLastLeaf(aPresContext, &lastFrame);
     1: 
     1:       if (aPos->mDirection == eDirNext){
     1:         nearStoppingFrame = firstFrame;
     1:         farStoppingFrame = lastFrame;
     1:       }
     1:       else{
     1:         nearStoppingFrame = lastFrame;
     1:         farStoppingFrame = firstFrame;
     1:       }
     1:       nsPoint offset;
     1:       nsIView * view; //used for call of get offset from view
     1:       aBlockFrame->GetOffsetFromView(offset,&view);
     1:       nscoord newDesiredX  = aPos->mDesiredX - offset.x;//get desired x into blockframe coordinates!
     1:       result = it->FindFrameAt(searchingLine, newDesiredX, &resultFrame, &isBeforeFirstFrame, &isAfterLastFrame);
     1:       if(NS_FAILED(result))
     1:         continue;
     1:     }
     1: 
     1:     if (NS_SUCCEEDED(result) && resultFrame)
     1:     {
     1:       //check to see if this is ANOTHER blockframe inside the other one if so then call into its lines
 21112:       nsAutoLineIterator newIt = resultFrame->GetLineIterator();
 21112:       if (newIt)
     1:       {
     1:         aPos->mResultFrame = resultFrame;
     1:         return NS_OK;
     1:       }
     1:       //resultFrame is not a block frame
 21112:       result = NS_ERROR_FAILURE;
     1: 
108991:       uint32_t flags = nsFrameIterator::FLAG_NONE;
107518:       if (aPos->mScrollViewStop) {
107607:         flags |= nsFrameIterator::FLAG_LOCK_SCROLL;
107518:       }
107518:       nsFrameIterator frameTraversal(aPresContext, resultFrame,
107518:                                      ePostOrder, flags);
     1:       nsIFrame *storeOldResultFrame = resultFrame;
     1:       while ( !found ){
     1:         nsPoint point;
     1:         point.x = aPos->mDesiredX;
     1: 
     1:         nsRect tempRect = resultFrame->GetRect();
     1:         nsPoint offset;
     1:         nsIView * view; //used for call of get offset from view
     1:         result = resultFrame->GetOffsetFromView(offset, &view);
     1:         if (NS_FAILED(result))
     1:           return result;
     1:         point.y = tempRect.height + offset.y;
     1: 
     1:         //special check. if we allow non-text selection then we can allow a hit location to fall before a table. 
     1:         //otherwise there is no way to get and click signal to fall before a table (it being a line iterator itself)
     1:         nsIPresShell *shell = aPresContext->GetPresShell();
     1:         if (!shell)
     1:           return NS_ERROR_FAILURE;
108991:         int16_t isEditor = shell->GetSelectionFlags();
     1:         isEditor = isEditor == nsISelectionDisplay::DISPLAY_ALL;
     1:         if ( isEditor )
     1:         {
     1:           if (resultFrame->GetType() == nsGkAtoms::tableOuterFrame)
     1:           {
     1:             if (((point.x - offset.x + tempRect.x)<0) ||  ((point.x - offset.x+ tempRect.x)>tempRect.width))//off left/right side
     1:             {
     1:               nsIContent* content = resultFrame->GetContent();
     1:               if (content)
     1:               {
     1:                 nsIContent* parent = content->GetParent();
     1:                 if (parent)
     1:                 {
     1:                   aPos->mResultContent = parent;
     1:                   aPos->mContentOffset = parent->IndexOf(content);
 80486:                   aPos->mAttachForward = false;
     1:                   if ((point.x - offset.x+ tempRect.x)>tempRect.width)
     1:                   {
     1:                     aPos->mContentOffset++;//go to end of this frame
 80486:                     aPos->mAttachForward = true;
     1:                   }
     1:                   //result frame is the result frames parent.
     1:                   aPos->mResultFrame = resultFrame->GetParent();
     1:                   return NS_POSITION_BEFORE_TABLE;
     1:                 }
     1:               }
     1:             }
     1:           }
     1:         }
     1: 
     1:         if (!resultFrame->HasView())
     1:         {
     1:           nsIView* view;
     1:           nsPoint offset;
     1:           resultFrame->GetOffsetFromView(offset, &view);
     1:           ContentOffsets offsets =
     1:               resultFrame->GetContentOffsetsFromPoint(point - offset);
     1:           aPos->mResultContent = offsets.content;
     1:           aPos->mContentOffset = offsets.offset;
     1:           aPos->mAttachForward = offsets.associateWithNext;
     1:           if (offsets.content)
     1:           {
 79445:             bool selectable;
106838:             resultFrame->IsSelectable(&selectable, nullptr);
     1:             if (selectable)
     1:             {
 80486:               found = true;
     1:               break;
     1:             }
     1:           }
     1:         }
     1: 
     1:         if (aPos->mDirection == eDirPrevious && (resultFrame == farStoppingFrame))
     1:           break;
     1:         if (aPos->mDirection == eDirNext && (resultFrame == nearStoppingFrame))
     1:           break;
     1:         //always try previous on THAT line if that fails go the other way
107518:         frameTraversal.Prev();
107518:         resultFrame = frameTraversal.CurrentItem();
 21105:         if (!resultFrame)
 21105:           return NS_ERROR_FAILURE;
     1:       }
     1: 
     1:       if (!found){
     1:         resultFrame = storeOldResultFrame;
107518: 
108991:         uint32_t flags = nsFrameIterator::FLAG_NONE;
107518:         if (aPos->mScrollViewStop) {
107607:           flags |= nsFrameIterator::FLAG_LOCK_SCROLL;
107518:         }
107518:         frameTraversal = nsFrameIterator(aPresContext, resultFrame,
107518:                                          eLeaf, flags);
     1:       }
     1:       while ( !found ){
     1:         nsPoint point(aPos->mDesiredX, 0);
     1:         nsIView* view;
     1:         nsPoint offset;
     1:         resultFrame->GetOffsetFromView(offset, &view);
     1:         ContentOffsets offsets =
     1:             resultFrame->GetContentOffsetsFromPoint(point - offset);
     1:         aPos->mResultContent = offsets.content;
     1:         aPos->mContentOffset = offsets.offset;
     1:         aPos->mAttachForward = offsets.associateWithNext;
     1:         if (offsets.content)
     1:         {
 79445:           bool selectable;
106838:           resultFrame->IsSelectable(&selectable, nullptr);
     1:           if (selectable)
     1:           {
 80486:             found = true;
     1:             if (resultFrame == farStoppingFrame)
 80486:               aPos->mAttachForward = false;
     1:             else
 80486:               aPos->mAttachForward = true;
     1:             break;
     1:           }
     1:         }
     1:         if (aPos->mDirection == eDirPrevious && (resultFrame == nearStoppingFrame))
     1:           break;
     1:         if (aPos->mDirection == eDirNext && (resultFrame == farStoppingFrame))
     1:           break;
     1:         //previous didnt work now we try "next"
107518:         frameTraversal.Next();
107518:         nsIFrame *tempFrame = frameTraversal.CurrentItem();
 21105:         if (!tempFrame)
     1:           break;
 21105:         resultFrame = tempFrame;
     1:       }
     1:       aPos->mResultFrame = resultFrame;
     1:     }
     1:     else {
     1:         //we need to jump to new block frame.
     1:       aPos->mAmount = eSelectLine;
     1:       aPos->mStartOffset = 0;
     1:       aPos->mAttachForward = !(aPos->mDirection == eDirNext);
     1:       if (aPos->mDirection == eDirPrevious)
     1:         aPos->mStartOffset = -1;//start from end
     1:      return aBlockFrame->PeekOffset(aPos);
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 94058: nsIFrame::CaretPosition
 94058: nsIFrame::GetExtremeCaretPosition(bool aStart)
 94058: {
 94058:   CaretPosition result;
     1: 
 99686:   FrameTarget targetFrame = DrillDownToSelectionFrame(this, !aStart, 0);
     1:   FrameContentRange range = GetRangeForFrame(targetFrame.frame);
     1:   result.mResultContent = range.content;
     1:   result.mContentOffset = aStart ? range.start : range.end;
     1:   return result;
     1: }
     1: 
     1: // Find the first (or last) descendant of the given frame
     1: // which is either a block frame or a BRFrame.
     1: static nsContentAndOffset
     1: FindBlockFrameOrBR(nsIFrame* aFrame, nsDirection aDirection)
     1: {
     1:   nsContentAndOffset result;
106838:   result.mContent =  nullptr;
 12151:   result.mOffset = 0;
     1: 
     1:   if (aFrame->IsGeneratedContentFrame())
     1:     return result;
     1: 
     1:   // Treat form controls as inline leaves
     1:   // XXX we really need a way to determine whether a frame is inline-level
 23554:   nsIFormControlFrame* fcf = do_QueryFrame(aFrame);
 23554:   if (fcf)
     1:     return result;
     1:   
     1:   // Check the frame itself
     1:   // Fall through "special" block frames because their mContent is the content
     1:   // of the inline frames they were created from. The first/last child of
     1:   // such frames is the real block frame we're looking for.
 19264:   if ((nsLayoutUtils::GetAsBlock(aFrame) && !(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) ||
     1:       aFrame->GetType() == nsGkAtoms::brFrame) {
     1:     nsIContent* content = aFrame->GetContent();
     1:     result.mContent = content->GetParent();
 12151:     // In some cases (bug 310589, bug 370174) we end up here with a null content.
 12151:     // This probably shouldn't ever happen, but since it sometimes does, we want
 12151:     // to avoid crashing here.
 12151:     NS_ASSERTION(result.mContent, "Unexpected orphan content");
 12118:     if (result.mContent)
     1:       result.mOffset = result.mContent->IndexOf(content) + 
     1:         (aDirection == eDirPrevious ? 1 : 0);
     1:     return result;
     1:   }
     1: 
     1:   // If this is a preformatted text frame, see if it ends with a newline
     1:   if (aFrame->HasTerminalNewline() &&
 16575:       aFrame->GetStyleContext()->GetStyleText()->NewlineIsSignificant()) {
108991:     int32_t startOffset, endOffset;
     1:     aFrame->GetOffsets(startOffset, endOffset);
     1:     result.mContent = aFrame->GetContent();
     1:     result.mOffset = endOffset - (aDirection == eDirPrevious ? 0 : 1);
     1:     return result;
     1:   }
     1: 
     1:   // Iterate over children and call ourselves recursively
     1:   if (aDirection == eDirPrevious) {
 77154:     nsIFrame* child = aFrame->GetLastChild(nsIFrame::kPrincipalList);
     1:     while(child && !result.mContent) {
     1:       result = FindBlockFrameOrBR(child, aDirection);
 33388:       child = child->GetPrevSibling();
     1:     }
     1:   } else { // eDirNext
 77154:     nsIFrame* child = aFrame->GetFirstPrincipalChild();
     1:     while(child && !result.mContent) {
     1:       result = FindBlockFrameOrBR(child, aDirection);
     1:       child = child->GetNextSibling();
     1:     }
     1:   }
     1:   return result;
     1: }
     1: 
     1: nsresult
     1: nsIFrame::PeekOffsetParagraph(nsPeekOffsetStruct *aPos)
     1: {
     1:   nsIFrame* frame = this;
     1:   nsContentAndOffset blockFrameOrBR;
106838:   blockFrameOrBR.mContent = nullptr;
 79445:   bool reachedBlockAncestor = false;
     1: 
     1:   // Go through containing frames until reaching a block frame.
     1:   // In each step, search the previous (or next) siblings for the closest
     1:   // "stop frame" (a block frame or a BRFrame).
     1:   // If found, set it to be the selection boundray and abort.
     1:   
     1:   if (aPos->mDirection == eDirPrevious) {
     1:     while (!reachedBlockAncestor) {
     1:       nsIFrame* parent = frame->GetParent();
   532:       // Treat a frame associated with the root content as if it were a block frame.
   532:       if (!frame->mContent || !frame->mContent->GetParent()) {
 80486:         reachedBlockAncestor = true;
     1:         break;
     1:       }
 33388:       nsIFrame* sibling = frame->GetPrevSibling();
     1:       while (sibling && !blockFrameOrBR.mContent) {
     1:         blockFrameOrBR = FindBlockFrameOrBR(sibling, eDirPrevious);
 33388:         sibling = sibling->GetPrevSibling();
     1:       }
     1:       if (blockFrameOrBR.mContent) {
     1:         aPos->mResultContent = blockFrameOrBR.mContent;
     1:         aPos->mContentOffset = blockFrameOrBR.mOffset;
     1:         break;
     1:       }
     1:       frame = parent;
106838:       reachedBlockAncestor = (nsLayoutUtils::GetAsBlock(frame) != nullptr);
     1:     }
     1:     if (reachedBlockAncestor) { // no "stop frame" found
     1:       aPos->mResultContent = frame->GetContent();
     1:       aPos->mContentOffset = 0;
     1:     }
     1:   } else { // eDirNext
     1:     while (!reachedBlockAncestor) {
     1:       nsIFrame* parent = frame->GetParent();
   532:       // Treat a frame associated with the root content as if it were a block frame.
   532:       if (!frame->mContent || !frame->mContent->GetParent()) {
 80486:         reachedBlockAncestor = true;
     1:         break;
     1:       }
     1:       nsIFrame* sibling = frame;
     1:       while (sibling && !blockFrameOrBR.mContent) {
     1:         blockFrameOrBR = FindBlockFrameOrBR(sibling, eDirNext);
     1:         sibling = sibling->GetNextSibling();
     1:       }
     1:       if (blockFrameOrBR.mContent) {
     1:         aPos->mResultContent = blockFrameOrBR.mContent;
     1:         aPos->mContentOffset = blockFrameOrBR.mOffset;
     1:         break;
     1:       }
     1:       frame = parent;
106838:       reachedBlockAncestor = (nsLayoutUtils::GetAsBlock(frame) != nullptr);
     1:     }
     1:     if (reachedBlockAncestor) { // no "stop frame" found
     1:       aPos->mResultContent = frame->GetContent();
     1:       if (aPos->mResultContent)
     1:         aPos->mContentOffset = aPos->mResultContent->GetChildCount();
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: // Determine movement direction relative to frame
 79445: static bool IsMovingInFrameDirection(nsIFrame* frame, nsDirection aDirection, bool aVisual)
 79445: {
 79445:   bool isReverseDirection = aVisual ?
 80486:     (NS_GET_EMBEDDING_LEVEL(frame) & 1) != (NS_GET_BASE_LEVEL(frame) & 1) : false;
     1:   return aDirection == (isReverseDirection ? eDirPrevious : eDirNext);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsIFrame::PeekOffset(nsPeekOffsetStruct* aPos)
     1: {
     1:   if (!aPos)
     1:     return NS_ERROR_NULL_POINTER;
     1:   nsresult result = NS_ERROR_FAILURE;
     1: 
     1:   if (mState & NS_FRAME_IS_DIRTY)
     1:     return NS_ERROR_UNEXPECTED;
     1: 
     1:   // Translate content offset to be relative to frame
     1:   FrameContentRange range = GetRangeForFrame(this);
108991:   int32_t offset = aPos->mStartOffset - range.start;
     1:   nsIFrame* current = this;
     1:   
     1:   switch (aPos->mAmount) {
     1:     case eSelectCharacter:
 59604:     case eSelectCluster:
     1:     {
 79445:       bool eatingNonRenderableWS = false;
 79445:       bool done = false;
 79445:       bool jumpedLine = false;
     1:       
     1:       while (!done) {
 79445:         bool movingInFrameDirection =
     1:           IsMovingInFrameDirection(current, aPos->mDirection, aPos->mVisual);
     1: 
     1:         if (eatingNonRenderableWS)
     1:           done = current->PeekOffsetNoAmount(movingInFrameDirection, &offset); 
     1:         else
 59604:           done = current->PeekOffsetCharacter(movingInFrameDirection, &offset,
 59604:                                               aPos->mAmount == eSelectCluster);
     1: 
     1:         if (!done) {
     1:           result =
     1:             current->GetFrameFromDirection(aPos->mDirection, aPos->mVisual,
     1:                                            aPos->mJumpLines, aPos->mScrollViewStop,
     1:                                            &current, &offset, &jumpedLine);
     1:           if (NS_FAILED(result))
     1:             return result;
     1: 
     1:           // If we jumped lines, it's as if we found a character, but we still need
     1:           // to eat non-renderable content on the new line.
     1:           if (jumpedLine)
 80486:             eatingNonRenderableWS = true;
     1:         }
     1:       }
     1: 
     1:       // Set outputs
     1:       range = GetRangeForFrame(current);
     1:       aPos->mResultFrame = current;
     1:       aPos->mResultContent = range.content;
     1:       // Output offset is relative to content, not frame
     1:       aPos->mContentOffset = offset < 0 ? range.end : range.start + offset;
 53724:       // If we're dealing with a text frame and moving backward positions us at
 53724:       // the end of that line, decrease the offset by one to make sure that
 53724:       // we're placed before the linefeed character on the previous line.
 53724:       if (offset < 0 && jumpedLine &&
 53724:           aPos->mDirection == eDirPrevious &&
 53724:           current->GetStyleText()->NewlineIsSignificant() &&
 53724:           current->HasTerminalNewline()) {
 53724:         --aPos->mContentOffset;
 53724:       }
     1:       
     1:       break;
     1:     }
 63601:     case eSelectWordNoSpace:
 63601:       // eSelectWordNoSpace means that we should not be eating any whitespace when
 63601:       // moving to the adjacent word.  This means that we should set aPos->
 63601:       // mWordMovementType to eEndWord if we're moving forwards, and to eStartWord
 63601:       // if we're moving backwards.
 63601:       if (aPos->mDirection == eDirPrevious) {
 63601:         aPos->mWordMovementType = eStartWord;
 63601:       } else {
 63601:         aPos->mWordMovementType = eEndWord;
 63601:       }
 63601:       // Intentionally fall through the eSelectWord case.
     1:     case eSelectWord:
     1:     {
     1:       // wordSelectEatSpace means "are we looking for a boundary between whitespace
     1:       // and non-whitespace (in the direction we're moving in)".
     1:       // It is true when moving forward and looking for a beginning of a word, or
     1:       // when moving backwards and looking for an end of a word.
 79445:       bool wordSelectEatSpace;
     1:       if (aPos->mWordMovementType != eDefaultBehavior) {
     1:         // aPos->mWordMovementType possible values:
     1:         //       eEndWord: eat the space if we're moving backwards
     1:         //       eStartWord: eat the space if we're moving forwards
     1:         wordSelectEatSpace = ((aPos->mWordMovementType == eEndWord) == (aPos->mDirection == eDirPrevious));
     1:       }
     1:       else {
     1:         // Use the hidden preference which is based on operating system behavior.
     1:         // This pref only affects whether moving forward by word should go to the end of this word or start of the next word.
     1:         // When going backwards, the start of the word is always used, on every operating system.
  3049:         wordSelectEatSpace = aPos->mDirection == eDirNext &&
 70840:           Preferences::GetBool("layout.word_select.eat_space_to_next_word");
     1:       }
     1:       
  5453:       // mSawBeforeType means "we already saw characters of the type
     1:       // before the boundary we're looking for". Examples:
     1:       // 1. If we're moving forward, looking for a word beginning (i.e. a boundary
 80486:       //    between whitespace and non-whitespace), then eatingWS==true means
     1:       //    "we already saw some whitespace".
     1:       // 2. If we're moving backward, looking for a word beginning (i.e. a boundary
 80486:       //    between non-whitespace and whitespace), then eatingWS==true means
     1:       //    "we already saw some non-whitespace".
  5453:       PeekWordState state;
108991:       int32_t offsetAdjustment = 0;
 79445:       bool done = false;
     1:       while (!done) {
 79445:         bool movingInFrameDirection =
     1:           IsMovingInFrameDirection(current, aPos->mDirection, aPos->mVisual);
     1:         
  5453:         done = current->PeekOffsetWord(movingInFrameDirection, wordSelectEatSpace,
  5453:                                        aPos->mIsKeyboardSelect, &offset, &state);
     1:         
     1:         if (!done) {
     1:           nsIFrame* nextFrame;
108991:           int32_t nextFrameOffset;
 79445:           bool jumpedLine;
     1:           result =
     1:             current->GetFrameFromDirection(aPos->mDirection, aPos->mVisual,
     1:                                            aPos->mJumpLines, aPos->mScrollViewStop,
     1:                                            &nextFrame, &nextFrameOffset, &jumpedLine);
     1:           // We can't jump lines if we're looking for whitespace following
     1:           // non-whitespace, and we already encountered non-whitespace.
     1:           if (NS_FAILED(result) ||
 19264:               (jumpedLine && !wordSelectEatSpace && state.mSawBeforeType)) {
 80486:             done = true;
 64445:             // If we've crossed the line boundary, check to make sure that we
 64445:             // have not consumed a trailing newline as whitesapce if it's significant.
 64445:             if (jumpedLine && wordSelectEatSpace &&
 64445:                 current->HasTerminalNewline() &&
 64445:                 current->GetStyleText()->NewlineIsSignificant()) {
 64445:               offsetAdjustment = -1;
 64445:             }
     1:           } else {
  7679:             if (jumpedLine) {
  7679:               state.mContext.Truncate();
  7679:             }
     1:             current = nextFrame;
     1:             offset = nextFrameOffset;
     1:             // Jumping a line is equivalent to encountering whitespace
     1:             if (wordSelectEatSpace && jumpedLine)
  5453:               state.SetSawBeforeType();
     1:           }
     1:         }
     1:       }
     1:       
     1:       // Set outputs
     1:       range = GetRangeForFrame(current);
     1:       aPos->mResultFrame = current;
     1:       aPos->mResultContent = range.content;
     1:       // Output offset is relative to content, not frame
 64445:       aPos->mContentOffset = (offset < 0 ? range.end : range.start + offset) + offsetAdjustment;
     1:       break;
     1:     }
     1:     case eSelectLine :
     1:     {
 21112:       nsAutoLineIterator iter;
     1:       nsIFrame *blockFrame = this;
     1: 
     1:       while (NS_FAILED(result)){
108991:         int32_t thisLine = nsFrame::GetLineNumber(blockFrame, aPos->mScrollViewStop, &blockFrame);
     1:         if (thisLine < 0) 
     1:           return  NS_ERROR_FAILURE;
 21112:         iter = blockFrame->GetLineIterator();
 21112:         NS_ASSERTION(iter, "GetLineNumber() succeeded but no block frame?");
 21112:         result = NS_OK;
     1: 
     1:         int edgeCase = 0;//no edge case. this should look at thisLine
     1:         
 79445:         bool doneLooping = false;//tells us when no more block frames hit.
     1:         //this part will find a frame or a block frame. if it's a block frame
     1:         //it will "drill down" to find a viable frame or it will return an error.
     1:         nsIFrame *lastFrame = this;
     1:         do {
   238:           result = nsFrame::GetNextPrevLineFromeBlockFrame(PresContext(),
     1:                                                            aPos, 
     1:                                                            blockFrame, 
     1:                                                            thisLine, 
     1:                                                            edgeCase //start from thisLine
     1:             );
     1:           if (NS_SUCCEEDED(result) && (!aPos->mResultFrame || aPos->mResultFrame == lastFrame))//we came back to same spot! keep going
     1:           {
106838:             aPos->mResultFrame = nullptr;
     1:             if (aPos->mDirection == eDirPrevious)
     1:               thisLine--;
     1:             else
     1:               thisLine++;
     1:           }
     1:           else //if failure or success with different frame.
 80486:             doneLooping = true; //do not continue with while loop
     1: 
     1:           lastFrame = aPos->mResultFrame; //set last frame 
     1: 
     1:           if (NS_SUCCEEDED(result) && aPos->mResultFrame 
     1:             && blockFrame != aPos->mResultFrame)// make sure block element is not the same as the one we had before
     1:           {
     1: /* SPECIAL CHECK FOR TABLE NAVIGATION
     1:   tables need to navigate also and the frame that supports it is nsTableRowGroupFrame which is INSIDE
     1:   nsTableOuterFrame.  if we have stumbled onto an nsTableOuter we need to drill into nsTableRowGroup
     1:   if we hit a header or footer that's ok just go into them,
     1: */
 79445:             bool searchTableBool = false;
     1:             if (aPos->mResultFrame->GetType() == nsGkAtoms::tableOuterFrame ||
     1:                 aPos->mResultFrame->GetType() == nsGkAtoms::tableCellFrame)
     1:             {
 77154:               nsIFrame *frame = aPos->mResultFrame->GetFirstPrincipalChild();
     1:               //got the table frame now
     1:               while(frame) //ok time to drill down to find iterator
     1:               {
 21112:                 iter = frame->GetLineIterator();
 21112:                 if (iter)
     1:                 {
     1:                   aPos->mResultFrame = frame;
 80486:                   searchTableBool = true;
 21112:                   result = NS_OK;
     1:                   break; //while(frame)
     1:                 }
 21112:                 result = NS_ERROR_FAILURE;
 77154:                 frame = frame->GetFirstPrincipalChild();
     1:               }
     1:             }
 21112: 
 21112:             if (!searchTableBool) {
 21112:               iter = aPos->mResultFrame->GetLineIterator();
 21112:               result = iter ? NS_OK : NS_ERROR_FAILURE;
 21112:             }
     1:             if (NS_SUCCEEDED(result) && iter)//we've struck another block element!
     1:             {
 80486:               doneLooping = false;
     1:               if (aPos->mDirection == eDirPrevious)
     1:                 edgeCase = 1;//far edge, search from end backwards
     1:               else
     1:                 edgeCase = -1;//near edge search from beginning onwards
     1:               thisLine=0;//this line means nothing now.
     1:               //everything else means something so keep looking "inside" the block
     1:               blockFrame = aPos->mResultFrame;
     1: 
     1:             }
     1:             else
     1:             {
     1:               result = NS_OK;//THIS is to mean that everything is ok to the containing while loop
     1:               break;
     1:             }
     1:           }
     1:         } while (!doneLooping);
     1:       }
     1:       return result;
     1:     }
     1: 
     1:     case eSelectParagraph:
     1:       return PeekOffsetParagraph(aPos);
     1: 
     1:     case eSelectBeginLine:
     1:     case eSelectEndLine:
     1:     {
     1:       // Adjusted so that the caret can't get confused when content changes
     1:       nsIFrame* blockFrame = AdjustFrameForSelectionStyles(this);
108991:       int32_t thisLine = nsFrame::GetLineNumber(blockFrame, aPos->mScrollViewStop, &blockFrame);
     1:       if (thisLine < 0)
     1:         return NS_ERROR_FAILURE;
 21112:       nsAutoLineIterator it = blockFrame->GetLineIterator();
 21112:       NS_ASSERTION(it, "GetLineNumber() succeeded but no block frame?");
     1: 
108991:       int32_t lineFrameCount;
     1:       nsIFrame *firstFrame;
     1:       nsRect usedRect;
108991:       uint32_t lineFlags;
106838:       nsIFrame* baseFrame = nullptr;
 79445:       bool endOfLine = (eSelectEndLine == aPos->mAmount);
     1:       
     1: #ifdef IBMBIDI
   238:       if (aPos->mVisual && PresContext()->BidiEnabled()) {
 79445:         bool lineIsRTL = it->GetDirection();
 79445:         bool isReordered;
     1:         nsIFrame *lastFrame;
     1:         result = it->CheckLineOrder(thisLine, &isReordered, &firstFrame, &lastFrame);
     1:         baseFrame = endOfLine ? lastFrame : firstFrame;
  5419:         if (baseFrame) {
     1:           nsBidiLevel embeddingLevel = nsBidiPresUtils::GetFrameEmbeddingLevel(baseFrame);
     1:           // If the direction of the frame on the edge is opposite to that of the line,
     1:           // we'll need to drill down to its opposite end, so reverse endOfLine.
     1:           if ((embeddingLevel & 1) == !lineIsRTL)
     1:             endOfLine = !endOfLine;
  5419:         }
     1:       } else
     1: #endif
     1:       {
     1:         it->GetLine(thisLine, &firstFrame, &lineFrameCount, usedRect, &lineFlags);
     1: 
     1:         nsIFrame* frame = firstFrame;
108991:         for (int32_t count = lineFrameCount; count;
     1:              --count, frame = frame->GetNextSibling()) {
     1:           if (!frame->IsGeneratedContentFrame()) {
     1:             baseFrame = frame;
     1:             if (!endOfLine)
     1:               break;
     1:           }
     1:         }
     1:       }
     1:       if (!baseFrame)
     1:         return NS_ERROR_FAILURE;
     1:       FrameTarget targetFrame = DrillDownToSelectionFrame(baseFrame,
 99686:                                                           endOfLine, 0);
     1:       FrameContentRange range = GetRangeForFrame(targetFrame.frame);
     1:       aPos->mResultContent = range.content;
     1:       aPos->mContentOffset = endOfLine ? range.end : range.start;
 54193:       if (endOfLine && targetFrame.frame->HasTerminalNewline()) {
 54193:         // Do not position the caret after the terminating newline if we're
 54193:         // trying to move to the end of line (see bug 596506)
 54193:         --aPos->mContentOffset;
 54193:       }
     1:       aPos->mResultFrame = targetFrame.frame;
     1:       aPos->mAttachForward = (aPos->mContentOffset == range.start);
     1:       if (!range.content)
     1:         return NS_ERROR_FAILURE;
     1:       return NS_OK;
     1:     }
     1: 
     1:     default: 
     1:     {
 80486:       NS_ASSERTION(false, "Invalid amount");
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
108991: nsFrame::PeekOffsetNoAmount(bool aForward, int32_t* aOffset)
     1: {
     1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
     1:   // Sure, we can stop right here.
 80486:   return true;
     1: }
     1: 
 79445: bool
108991: nsFrame::PeekOffsetCharacter(bool aForward, int32_t* aOffset,
 79445:                              bool aRespectClusters)
     1: {
     1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
108991:   int32_t startOffset = *aOffset;
     1:   // A negative offset means "end of frame", which in our case means offset 1.
     1:   if (startOffset < 0)
     1:     startOffset = 1;
     1:   if (aForward == (startOffset == 0)) {
     1:     // We're before the frame and moving forward, or after it and moving backwards:
     1:     // skip to the other side and we're done.
     1:     *aOffset = 1 - startOffset;
 80486:     return true;
 80486:   }
 80486:   return false;
     1: }
     1: 
 79445: bool
 79445: nsFrame::PeekOffsetWord(bool aForward, bool aWordSelectEatSpace, bool aIsKeyboardSelect,
108991:                         int32_t* aOffset, PeekWordState* aState)
     1: {
     1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
108991:   int32_t startOffset = *aOffset;
  7679:   // This isn't text, so truncate the context
  7679:   aState->mContext.Truncate();
     1:   if (startOffset < 0)
     1:     startOffset = 1;
     1:   if (aForward == (startOffset == 0)) {
     1:     // We're before the frame and moving forward, or after it and moving backwards.
     1:     // If we're looking for non-whitespace, we found it (without skipping this frame).
  5453:     if (!aState->mAtStart) {
  5453:       if (aState->mLastCharWasPunctuation) {
  5453:         // We're not punctuation, so this is a punctuation boundary.
 80486:         if (BreakWordBetweenPunctuation(aState, aForward, false, false, aIsKeyboardSelect))
 80486:           return true;
  5453:       } else {
  5453:         // This is not a punctuation boundary.
  5453:         if (aWordSelectEatSpace && aState->mSawBeforeType)
 80486:           return true;
  5453:       }
  5453:     }
     1:     // Otherwise skip to the other side and note that we encountered non-whitespace.
     1:     *aOffset = 1 - startOffset;
 80486:     aState->Update(false, // not punctuation
 80486:                    false     // not whitespace
 12505:                    );
     1:     if (!aWordSelectEatSpace)
  5453:       aState->SetSawBeforeType();
     1:   }
 80486:   return false;
     1: }
     1: 
 79445: bool
 12505: nsFrame::BreakWordBetweenPunctuation(const PeekWordState* aState,
 79445:                                      bool aForward,
 79445:                                      bool aPunctAfter, bool aWhitespaceAfter,
 79445:                                      bool aIsKeyboardSelect)
 12505: {
 12505:   NS_ASSERTION(aPunctAfter != aState->mLastCharWasPunctuation,
 12505:                "Call this only at punctuation boundaries");
 12505:   if (aState->mLastCharWasWhitespace) {
 12505:     // We always stop between whitespace and punctuation
 80486:     return true;
 12505:   }
 70840:   if (!Preferences::GetBool("layout.word_select.stop_at_punctuation")) {
 12505:     // When this pref is false, we never stop at a punctuation boundary unless
 12505:     // it's after whitespace
 80486:     return false;
  5453:   }
  5453:   if (!aIsKeyboardSelect) {
  5453:     // mouse caret movement (e.g. word selection) always stops at every punctuation boundary
 80486:     return true;
  5453:   }
 79445:   bool afterPunct = aForward ? aState->mLastCharWasPunctuation : aPunctAfter;
 12505:   if (!afterPunct) {
 12505:     // keyboard caret movement only stops after punctuation (in content order)
 80486:     return false;
 12505:   }
 12505:   // Stop only if we've seen some non-punctuation since the last whitespace;
 12505:   // don't stop after punctuation that follows whitespace.
 12505:   return aState->mSeenNonPunctuationSinceWhitespace;
  5453: }
  5453: 
     1: NS_IMETHODIMP
108991: nsFrame::CheckVisibility(nsPresContext* , int32_t , int32_t , bool , bool *, bool *)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: 
108991: int32_t
 79445: nsFrame::GetLineNumber(nsIFrame *aFrame, bool aLockScroll, nsIFrame** aContainingBlock)
     1: {
     1:   NS_ASSERTION(aFrame, "null aFrame");
   238:   nsFrameManager* frameManager = aFrame->PresContext()->FrameManager();
     1:   nsIFrame *blockFrame = aFrame;
     1:   nsIFrame *thisBlock;
 21112:   nsAutoLineIterator it;
     1:   nsresult result = NS_ERROR_FAILURE;
     1:   while (NS_FAILED(result) && blockFrame)
     1:   {
     1:     thisBlock = blockFrame;
     1:     if (thisBlock->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
     1:       //if we are searching for a frame that is not in flow we will not find it. 
     1:       //we must instead look for its placeholder
  6521:       if (thisBlock->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
  6521:         // abspos continuations don't have placeholders, get the fif
  6521:         thisBlock = thisBlock->GetFirstInFlow();
  6521:       }
     1:       thisBlock = frameManager->GetPlaceholderFrameFor(thisBlock);
     1:       if (!thisBlock)
     1:         return -1;
     1:     }  
     1:     blockFrame = thisBlock->GetParent();
     1:     result = NS_OK;
     1:     if (blockFrame) {
 20200:       if (aLockScroll && blockFrame->GetType() == nsGkAtoms::scrollFrame)
 20200:         return -1;
 21112:       it = blockFrame->GetLineIterator();
 21112:       if (!it)
 21112:         result = NS_ERROR_FAILURE;
     1:     }
     1:   }
     1:   if (!blockFrame || !it)
     1:     return -1;
     1: 
     1:   if (aContainingBlock)
     1:     *aContainingBlock = blockFrame;
 21112:   return it->FindLineContaining(thisBlock);
     1: }
     1: 
     1: nsresult
 79445: nsIFrame::GetFrameFromDirection(nsDirection aDirection, bool aVisual,
 79445:                                 bool aJumpLines, bool aScrollViewStop, 
108991:                                 nsIFrame** aOutFrame, int32_t* aOutOffset, bool* aOutJumpedLine)
     1: {
 21112:   nsresult result;
 21112: 
     1:   if (!aOutFrame || !aOutOffset || !aOutJumpedLine)
     1:     return NS_ERROR_NULL_POINTER;
     1:   
   238:   nsPresContext* presContext = PresContext();
106838:   *aOutFrame = nullptr;
     1:   *aOutOffset = 0;
 80486:   *aOutJumpedLine = false;
     1: 
     1:   // Find the prev/next selectable frame
 79445:   bool selectable = false;
     1:   nsIFrame *traversedFrame = this;
     1:   while (!selectable) {
     1:     nsIFrame *blockFrame;
     1:     
108991:     int32_t thisLine = nsFrame::GetLineNumber(traversedFrame, aScrollViewStop, &blockFrame);
     1:     if (thisLine < 0)
     1:       return NS_ERROR_FAILURE;
 21112: 
 21112:     nsAutoLineIterator it = blockFrame->GetLineIterator();
 21112:     NS_ASSERTION(it, "GetLineNumber() succeeded but no block frame?");
     1: 
 79445:     bool atLineEdge;
     1:     nsIFrame *firstFrame;
     1:     nsIFrame *lastFrame;
     1: #ifdef IBMBIDI
     1:     if (aVisual && presContext->BidiEnabled()) {
 79445:       bool lineIsRTL = it->GetDirection();
 79445:       bool isReordered;
     1:       result = it->CheckLineOrder(thisLine, &isReordered, &firstFrame, &lastFrame);
     1:       nsIFrame** framePtr = aDirection == eDirPrevious ? &firstFrame : &lastFrame;
     1:       if (*framePtr) {
     1:         nsBidiLevel embeddingLevel = nsBidiPresUtils::GetFrameEmbeddingLevel(*framePtr);
 19264:         if ((((embeddingLevel & 1) && lineIsRTL) || (!(embeddingLevel & 1) && !lineIsRTL)) ==
     1:             (aDirection == eDirPrevious)) {
     1:           nsFrame::GetFirstLeaf(presContext, framePtr);
     1:         } else {
     1:           nsFrame::GetLastLeaf(presContext, framePtr);
     1:         }
     1:         atLineEdge = *framePtr == traversedFrame;
     1:       } else {
 80486:         atLineEdge = true;
     1:       }
     1:     } else
     1: #endif
     1:     {
     1:       nsRect  nonUsedRect;
108991:       int32_t lineFrameCount;
108991:       uint32_t lineFlags;
     1:       result = it->GetLine(thisLine, &firstFrame, &lineFrameCount,nonUsedRect,
     1:                            &lineFlags);
     1:       if (NS_FAILED(result))
     1:         return result;
     1: 
     1:       if (aDirection == eDirPrevious) {
     1:         nsFrame::GetFirstLeaf(presContext, &firstFrame);
     1:         atLineEdge = firstFrame == traversedFrame;
     1:       } else { // eDirNext
     1:         lastFrame = firstFrame;
     1:         for (;lineFrameCount > 1;lineFrameCount --){
     1:           result = it->GetNextSiblingOnLine(lastFrame, thisLine);
     1:           if (NS_FAILED(result) || !lastFrame){
 43756:             NS_ERROR("should not be reached nsFrame");
     1:             return NS_ERROR_FAILURE;
     1:           }
     1:         }
     1:         nsFrame::GetLastLeaf(presContext, &lastFrame);
     1:         atLineEdge = lastFrame == traversedFrame;
     1:       }
     1:     }
     1: 
     1:     if (atLineEdge) {
 80486:       *aOutJumpedLine = true;
     1:       if (!aJumpLines)
     1:         return NS_ERROR_FAILURE; //we are done. cannot jump lines
     1:     }
     1: 
108991:     uint32_t flags = nsFrameIterator::FLAG_FOLLOW_OUT_OF_FLOW;
107518:     if (aScrollViewStop) {
107607:       flags |= nsFrameIterator::FLAG_LOCK_SCROLL;
107518:     }
107518:     if (aVisual && presContext->BidiEnabled()) {
107607:       flags |= nsFrameIterator::FLAG_VISUAL;
107518:     }
107518:     nsFrameIterator frameTraversal(presContext, traversedFrame,
107518:                                    eLeaf, flags);
     1: 
     1:     if (aDirection == eDirNext)
107518:       frameTraversal.Next();
     1:     else
107518:       frameTraversal.Prev();
107518: 
107518:     traversedFrame = frameTraversal.CurrentItem();
 21105:     if (!traversedFrame)
 21105:       return NS_ERROR_FAILURE;
106838:     traversedFrame->IsSelectable(&selectable, nullptr);
     1:   } // while (!selectable)
     1: 
     1:   *aOutOffset = (aDirection == eDirNext) ? 0 : -1;
     1: 
     1: #ifdef IBMBIDI
     1:   if (aVisual) {
108991:     uint8_t newLevel = NS_GET_EMBEDDING_LEVEL(traversedFrame);
108991:     uint8_t newBaseLevel = NS_GET_BASE_LEVEL(traversedFrame);
     1:     if ((newLevel & 1) != (newBaseLevel & 1)) // The new frame is reverse-direction, go to the other end
     1:       *aOutOffset = -1 - *aOutOffset;
     1:   }
     1: #endif
     1:   *aOutFrame = traversedFrame;
     1:   return NS_OK;
     1: }
     1: 
     1: nsIView* nsIFrame::GetClosestView(nsPoint* aOffset) const
     1: {
     1:   nsPoint offset(0,0);
     1:   for (const nsIFrame *f = this; f; f = f->GetParent()) {
     1:     if (f->HasView()) {
     1:       if (aOffset)
     1:         *aOffset = offset;
     1:       return f->GetView();
     1:     }
     1:     offset += f->GetPosition();
     1:   }
     1: 
     1:   NS_NOTREACHED("No view on any parent?  How did that happen?");
106838:   return nullptr;
     1: }
     1: 
     1: 
     1: /* virtual */ void
     1: nsFrame::ChildIsDirty(nsIFrame* aChild)
     1: {
     1:   NS_NOTREACHED("should never be called on a frame that doesn't inherit from "
     1:                 "nsContainerFrame");
     1: }
     1: 
     1: 
     1: #ifdef ACCESSIBILITY
 99648: already_AddRefed<Accessible>
 46338: nsFrame::CreateAccessible()
 46338: {
106838:   return nullptr;
     1: }
     1: #endif
     1: 
 55021: NS_DECLARE_FRAME_PROPERTY(OverflowAreasProperty,
 55021:                           nsIFrame::DestroyOverflowAreas)
 39965: 
 83439: bool
 55021: nsIFrame::ClearOverflowRects()
 55021: {
 83439:   if (mOverflow.mType == NS_FRAME_OVERFLOW_NONE) {
 83439:     return false;
 83439:   }
 55021:   if (mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) {
 55021:     Properties().Delete(OverflowAreasProperty());
 55021:   }
 39965:   mOverflow.mType = NS_FRAME_OVERFLOW_NONE;
 83439:   return true;
 39965: }
 39965: 
 11909: /** Create or retrieve the previously stored overflow area, if the frame does 
106838:  * not overflow and no creation is required return nullptr.
 11909:  * @return pointer to the overflow area rectangle 
 11909:  */
 55021: nsOverflowAreas*
 55021: nsIFrame::GetOverflowAreasProperty()
 55021: {
 39965:   FrameProperties props = Properties();
 55021:   nsOverflowAreas *overflow =
 55021:     static_cast<nsOverflowAreas*>(props.Get(OverflowAreasProperty()));
 55021: 
 55021:   if (overflow) {
 55021:     return overflow; // the property already exists
 55021:   }
 55021: 
     1:   // The property isn't set yet, so allocate a new rect, set the property,
     1:   // and return the newly allocated rect
 55021:   overflow = new nsOverflowAreas;
 55021:   props.Set(OverflowAreasProperty(), overflow);
     1:   return overflow;
     1: }
     1: 
 26950: /** Set the overflowArea rect, storing it as deltas or a separate rect
 26950:  * depending on its size in relation to the primary frame rect.
 26950:  */
 83439: bool
 55021: nsIFrame::SetOverflowAreas(const nsOverflowAreas& aOverflowAreas)
 55021: {
 55021:   if (mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) {
 55021:     nsOverflowAreas *overflow =
 55021:       static_cast<nsOverflowAreas*>(Properties().Get(OverflowAreasProperty()));
 83439:     bool changed = *overflow != aOverflowAreas;
 55021:     *overflow = aOverflowAreas;
 55021: 
 55021:     // Don't bother with converting to the deltas form if we already
 55021:     // have a property.
 83439:     return changed;
 55021:   }
 55021: 
 55021:   const nsRect& vis = aOverflowAreas.VisualOverflow();
108991:   uint32_t l = -vis.x, // left edge: positive delta is leftwards
 55021:            t = -vis.y, // top: positive is upwards
 55021:            r = vis.XMost() - mRect.width, // right: positive is rightwards
 55021:            b = vis.YMost() - mRect.height; // bottom: positive is downwards
 68638:   if (aOverflowAreas.ScrollableOverflow().IsEqualEdges(nsRect(nsPoint(0, 0), GetSize())) &&
 55021:       l <= NS_FRAME_OVERFLOW_DELTA_MAX &&
 26950:       t <= NS_FRAME_OVERFLOW_DELTA_MAX &&
 26950:       r <= NS_FRAME_OVERFLOW_DELTA_MAX &&
 26950:       b <= NS_FRAME_OVERFLOW_DELTA_MAX &&
 55021:       // we have to check these against zero because we *never* want to
 55021:       // set a frame as having no overflow in this function.  This is
 55021:       // because FinishAndStoreOverflow calls this function prior to
 55021:       // SetRect based on whether the overflow areas match aNewSize.
 55021:       // In the case where the overflow areas exactly match mRect but
 55021:       // do not match aNewSize, we need to store overflow in a property
 55021:       // so that our eventual SetRect/SetSize will know that it has to
 55021:       // reset our overflow areas.
 26950:       (l | t | r | b) != 0) {
 83439:     VisualDeltas oldDeltas = mOverflow.mVisualDeltas;
 26950:     // It's a "small" overflow area so we store the deltas for each edge
 26950:     // directly in the frame, rather than allocating a separate rect.
 55021:     // If they're all zero, that's fine; we're setting things to
 55021:     // no-overflow.
 55021:     mOverflow.mVisualDeltas.mLeft   = l;
 55021:     mOverflow.mVisualDeltas.mTop    = t;
 55021:     mOverflow.mVisualDeltas.mRight  = r;
 55021:     mOverflow.mVisualDeltas.mBottom = b;
 83439:     // There was no scrollable overflow before, and there isn't now.
 83439:     return oldDeltas != mOverflow.mVisualDeltas;
 26950:   } else {
 83439:     bool changed = !aOverflowAreas.ScrollableOverflow().IsEqualEdges(nsRect(nsPoint(0, 0), GetSize())) ||
 83439:       !aOverflowAreas.VisualOverflow().IsEqualEdges(GetVisualOverflowFromDeltas());
 83439: 
 26950:     // it's a large overflow area that we need to store as a property
 26950:     mOverflow.mType = NS_FRAME_OVERFLOW_LARGE;
 55021:     nsOverflowAreas* overflow = GetOverflowAreasProperty();
 55021:     NS_ASSERTION(overflow, "should have created areas");
 55021:     *overflow = aOverflowAreas;
 83439:     return changed;
 26950:   }
 26950: }
 26950: 
 79445: inline bool
 13951: IsInlineFrame(nsIFrame *aFrame)
 13951: {
 13951:   nsIAtom *type = aFrame->GetType();
 79483:   return type == nsGkAtoms::inlineFrame;
 13951: }
 13951: 
 83439: bool
 55024: nsIFrame::FinishAndStoreOverflow(nsOverflowAreas& aOverflowAreas,
 55024:                                  nsSize aNewSize)
 55024: {
 55024:   nsRect bounds(nsPoint(0, 0), aNewSize);
 80449:   // Store the passed in overflow area if we are a preserve-3d frame,
 80449:   // and it's not just the frame bounds.
 90156:   if ((Preserves3D() || HasPerspective()) && (!aOverflowAreas.VisualOverflow().IsEqualEdges(bounds) ||
 80449:                         !aOverflowAreas.ScrollableOverflow().IsEqualEdges(bounds))) {
 80449:     nsOverflowAreas* initial =
 80449:       static_cast<nsOverflowAreas*>(Properties().Get(nsIFrame::InitialOverflowProperty()));
 80449:     if (!initial) {
 80449:       Properties().Set(nsIFrame::InitialOverflowProperty(),
 80449:                        new nsOverflowAreas(aOverflowAreas));
 80449:     } else if (initial != &aOverflowAreas) {
 80449:       *initial = aOverflowAreas;
 80449:     }
 80449:   }
 55024: 
     1:   // This is now called FinishAndStoreOverflow() instead of 
     1:   // StoreOverflow() because frame-generic ways of adding overflow
     1:   // can happen here, e.g. CSS2 outline and native theme.
 87432:   // If the overflow area width or height is nscoord_MAX, then a
 87432:   // saturating union may have encounted an overflow, so the overflow may not
 87432:   // contain the frame border-box. Don't warn in that case.
 98711:   // Don't warn for SVG either, since SVG doesn't need the overflow area
 98711:   // to contain the frame bounds.
 55024:   NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
 87432:     DebugOnly<nsRect*> r = &aOverflowAreas.Overflow(otype);
     1:     NS_ASSERTION(aNewSize.width == 0 || aNewSize.height == 0 ||
 87432:                  r->width == nscoord_MAX || r->height == nscoord_MAX ||
 98711:                  (mState & NS_FRAME_SVG_LAYOUT) ||
 87432:                  r->Contains(nsRect(nsPoint(0,0), aNewSize)),
     1:                  "Computed overflow area must contain frame bounds");
 55024:   }
     1: 
 46323:   // If we clip our children, clear accumulated overflow area. The
 46323:   // children are actually clipped to the padding-box, but since the
 46323:   // overflow area should include the entire border-box, just set it to
 46323:   // the border-box here.
     1:   const nsStyleDisplay* disp = GetStyleDisplay();
 46323:   NS_ASSERTION((disp->mOverflowY == NS_STYLE_OVERFLOW_CLIP) ==
 46323:                (disp->mOverflowX == NS_STYLE_OVERFLOW_CLIP),
 46323:                "If one overflow is clip, the other should be too");
 87630:   if (nsFrame::ApplyOverflowClipping(this, disp)) {
 46323:     // The contents are actually clipped to the padding area 
 55024:     aOverflowAreas.SetAllTo(bounds);
 46323:   }
 46323: 
 46323:   // Overflow area must always include the frame's top-left and bottom-right,
 98711:   // even if the frame rect is empty (so we can scroll to those positions).
 46323:   // Pending a real fix for bug 426879, don't do this for inline frames
 46323:   // with zero width.
 98711:   // Do not do this for SVG either, since it will usually massively increase
 98711:   // the area unnecessarily.
 98711:   if ((aNewSize.width != 0 || !IsInlineFrame(this)) &&
 98711:       !(GetStateBits() & NS_FRAME_SVG_LAYOUT)) {
 55024:     NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
 55024:       nsRect& o = aOverflowAreas.Overflow(otype);
 68638:       o.UnionRectEdges(o, bounds);
 55024:     }
 87435:   }
 46323: 
 46323:   // Note that NS_STYLE_OVERFLOW_CLIP doesn't clip the frame background,
 46323:   // so we add theme background overflow here so it's not clipped.
  5894:   if (!IsBoxWrapped() && IsThemed(disp)) {
 55024:     nsRect r(bounds);
   238:     nsPresContext *presContext = PresContext();
     1:     if (presContext->GetTheme()->
     1:           GetWidgetOverflow(presContext->DeviceContext(), this,
     1:                             disp->mAppearance, &r)) {
 73475:       nsRect& vo = aOverflowAreas.VisualOverflow();
 73475:       vo.UnionRectEdges(vo, r);
 55024:     }
 55024:   }
 55024: 
 55024:   // Nothing in here should affect scrollable overflow.
 79445:   bool hasOutlineOrEffects;
 55024:   aOverflowAreas.VisualOverflow() =
 51893:     ComputeOutlineAndEffectsRect(this, &hasOutlineOrEffects,
 55024:                                  aOverflowAreas.VisualOverflow(), aNewSize,
 80486:                                  true);
 51893: 
 51893:   // Absolute position clipping
 91411:   bool didHaveClipPropClip = (GetStateBits() & NS_FRAME_HAS_CLIP) != 0;
 91411:   nsRect clipPropClipRect;
 91411:   bool hasClipPropClip = GetClipPropClipRect(disp, &clipPropClipRect, aNewSize);
 91411:   if (hasClipPropClip) {
 55024:     NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
 55024:       nsRect& o = aOverflowAreas.Overflow(otype);
 91411:       o.IntersectRect(o, clipPropClipRect);
 55024:     }
 51893:     AddStateBits(NS_FRAME_HAS_CLIP);
 51893:   } else {
 51893:     RemoveStateBits(NS_FRAME_HAS_CLIP);
 51893:   }
 19284: 
 90089:   bool preTransformVisualOverflowChanged =
 90089:     !GetVisualOverflowRectRelativeToSelf().IsEqualInterior(aOverflowAreas.VisualOverflow());
 90089: 
 19284:   /* If we're transformed, transform the overflow rect by the current transformation. */
 79445:   bool hasTransform = IsTransformed();
 39966:   if (hasTransform) {
 87626:     Properties().Set(nsIFrame::PreTransformOverflowAreasProperty(),
 87626:                      new nsOverflowAreas(aOverflowAreas));
 19284:     /* Since our size might not actually have been computed yet, we need to make sure that we use the
 19284:      * correct dimensions by overriding the stored bounding rectangle with the value the caller has
 19284:      * ensured us we'll use.
 19284:      */
 19284:     nsRect newBounds(nsPoint(0, 0), aNewSize);
 55024:     // Transform affects both overflow areas.
 55024:     NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
 55024:       nsRect& o = aOverflowAreas.Overflow(otype);
 55024:       o = nsDisplayTransform::TransformRect(o, this, nsPoint(0, 0), &newBounds);
 55024:     }
 82355:     if (Preserves3DChildren()) {
 77286:       ComputePreserve3DChildrenOverflow(aOverflowAreas, newBounds);
 92049:     } else if (ChildrenHavePerspective()) {
 92049:       RecomputePerspectiveChildrenOverflow(this->GetStyleContext(), &newBounds);
 77286:     }
 87626:   } else {
 87626:     Properties().Delete(nsIFrame::PreTransformOverflowAreasProperty());
 92049:     if (ChildrenHavePerspective()) {
 92049:       nsRect newBounds(nsPoint(0, 0), aNewSize);
 92049:       RecomputePerspectiveChildrenOverflow(this->GetStyleContext(), &newBounds);
 92049:     }
 92049:   }
 92049:     
 55024: 
 83439:   bool anyOverflowChanged;
 55024:   if (aOverflowAreas != nsOverflowAreas(bounds, bounds)) {
 83439:     anyOverflowChanged = SetOverflowAreas(aOverflowAreas);
 20711:   } else {
 83439:     anyOverflowChanged = ClearOverflowRects();
 55024:   }
 55024: 
 90089:   if (preTransformVisualOverflowChanged) {
 51893:     if (hasOutlineOrEffects) {
 51893:       // When there's an outline or box-shadow or SVG effects,
 39966:       // changes to those styles might require repainting of the old and new
 39966:       // overflow areas. Repainting of the old overflow area is handled in
 20711:       // nsCSSFrameConstructor::DoApplyRenderingChangeToTree in response
 20711:       // to nsChangeHint_RepaintFrame. Since the new overflow area is not
 20711:       // known at that time, we have to handle it here.
 20711:       // If the overflow area hasn't changed, then we don't have to do
 20711:       // anything here since repainting the old overflow area was enough.
 20711:       // If there is no outline or other effects now, then we don't have
 20711:       // to do anything here since removing those styles can't require
 20711:       // repainting of areas that weren't in the old overflow area.
103530:       Invalidate(aOverflowAreas.VisualOverflow());
 91411:     } else if (hasClipPropClip || didHaveClipPropClip) {
 51893:       // If we are (or were) clipped by the 'clip' property, and our
 51893:       // overflow area changes, it might be because the clipping changed.
 51893:       // The nsChangeHint_RepaintFrame for the style change will only
 51893:       // repaint the old overflow area, so if the overflow area has
 51893:       // changed (in particular, if it grows), we have to repaint the
 51893:       // new area here.
103530:       Invalidate(aOverflowAreas.VisualOverflow());
103530:     }
103530:   }
106052:   // XXXSDL For SVG the invalidation happens in ReflowSVG for now, so we
103530:   // don't currently invalidate SVG here:
103530:   if (anyOverflowChanged && hasTransform &&
103530:       !(GetStateBits() & NS_FRAME_SVG_LAYOUT)) {
103530:     // When there's a transform, changes to that style might require
103530:     // repainting of the old and new overflow areas in the widget.
103530:     // Repainting of the frame itself will not be required if there's
103530:     // a retained layer, so we can call InvalidateLayer here
103530:     // which will avoid repainting ThebesLayers if possible.
103530:     // nsCSSFrameConstructor::DoApplyRenderingChangeToTree repaints
103530:     // the old overflow area in the widget in response to
103530:     // nsChangeHint_UpdateTransformLayer. But since the new overflow
103530:     // area is not known at that time, we have to handle it here.
103530:     // If the overflow area hasn't changed, then it doesn't matter that
103530:     // we didn't reach here since repainting the old overflow area was enough.
103530:     // If there is no transform now, then the container layer for
103530:     // the transform will go away and the frame contents will change
103530:     // ThebesLayers, forcing it to be invalidated, so it doesn't matter
103530:     // that we didn't reach here.
103530:     InvalidateLayer(aOverflowAreas.VisualOverflow(),
103530:                     nsDisplayItem::TYPE_TRANSFORM);
 51893:   }
 83439: 
 83439:   return anyOverflowChanged;
     1: }
     1: 
 90156: void
 92049: nsIFrame::RecomputePerspectiveChildrenOverflow(const nsStyleContext* aStartStyle, const nsRect* aBounds)
 90156: {
 90156:   // Children may check our size when getting our transform, make sure it's valid.
 90156:   nsSize oldSize = GetSize();
 90156:   if (aBounds) {
 90156:     SetSize(aBounds->Size());
 90156:   }
 90156:   nsIFrame::ChildListIterator lists(this);
 90156:   for (; !lists.IsDone(); lists.Next()) {
 90156:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 90156:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 90156:       nsIFrame* child = childFrames.get();
 90156:       if (child->HasPerspective()) {
 90156:         nsOverflowAreas* overflow = 
 90156:           static_cast<nsOverflowAreas*>(child->Properties().Get(nsIFrame::InitialOverflowProperty()));
 90156:         nsRect bounds(nsPoint(0, 0), child->GetSize());
 90156:         if (overflow) {
 90156:           child->FinishAndStoreOverflow(*overflow, bounds.Size());
 90156:         } else {
 90156:           nsOverflowAreas boundsOverflow;
 90156:           boundsOverflow.SetAllTo(bounds);
 90156:           child->FinishAndStoreOverflow(boundsOverflow, bounds.Size());
 90156:         }
 92049:       } else if (child->GetStyleContext()->GetParent() == aStartStyle ||
 92049:                  child->GetStyleContext() == aStartStyle) {
 92049:         // Recurse into frames with the same style context, or a direct
 92049:         // child style context.
106838:         child->RecomputePerspectiveChildrenOverflow(aStartStyle, nullptr);
 90156:       }
 90156:     }
 90156:   }
 90156:   // Restore our old size just in case something depends on this elesewhere.
 90156:   SetSize(oldSize);
 90156: }
 90156: 
 80449: /* The overflow rects for leaf nodes in a preserve-3d hierarchy depends on
 80449:  * the mRect value for their parents (since we use their transform, and transform
 80449:  * depends on this for transform-origin etc). These weren't necessarily correct
 80449:  * when we reflowed initially, so walk over all preserve-3d children and repeat the
 80449:  * overflow calculation.
 80449:  */
 80449: static void
 80449: RecomputePreserve3DChildrenOverflow(nsIFrame* aFrame, const nsRect* aBounds)
 80449: {
 80449:   // Children may check our size when getting our transform, make sure it's valid.
 80449:   nsSize oldSize = aFrame->GetSize();
 80449:   if (aBounds) {
 80449:     aFrame->SetSize(aBounds->Size());
 80449:   }
 80449:   nsIFrame::ChildListIterator lists(aFrame);
 80449:   for (; !lists.IsDone(); lists.Next()) {
 80449:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 80449:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 80449:       nsIFrame* child = childFrames.get();
 80449:       if (child->Preserves3DChildren()) {
 80449:         RecomputePreserve3DChildrenOverflow(child, NULL);
 80449:       } else if (child->Preserves3D()) {
 80449:         nsOverflowAreas* overflow = 
 80449:           static_cast<nsOverflowAreas*>(child->Properties().Get(nsIFrame::InitialOverflowProperty()));
 80449:         nsRect bounds(nsPoint(0, 0), child->GetSize());
 80449:         if (overflow) {
 80449:           child->FinishAndStoreOverflow(*overflow, bounds.Size());
 80449:         } else {
 80449:           nsOverflowAreas boundsOverflow;
 80449:           boundsOverflow.SetAllTo(bounds);
 80449:           child->FinishAndStoreOverflow(boundsOverflow, bounds.Size());
 80449:         }
 80449:       }
 80449:     }
 80449:   }
 80449:   // Restore our old size just in case something depends on this elesewhere.
 80449:   aFrame->SetSize(oldSize);
 80449:  
 80449:   // Only repeat computing our overflow in recursive calls since the initial caller is still
 80449:   // in the middle of doing this and we don't want an infinite loop.
 80449:   if (!aBounds) {
 80449:     nsOverflowAreas* overflow = 
 80449:       static_cast<nsOverflowAreas*>(aFrame->Properties().Get(nsIFrame::InitialOverflowProperty()));
 80449:     nsRect bounds(nsPoint(0, 0), aFrame->GetSize());
 80449:     if (overflow) {
 80449:       overflow->UnionAllWith(bounds); 
 80449:       aFrame->FinishAndStoreOverflow(*overflow, bounds.Size());
 80449:     } else {
 80449:       nsOverflowAreas boundsOverflow;
 80449:       boundsOverflow.SetAllTo(bounds);
 80449:       aFrame->FinishAndStoreOverflow(boundsOverflow, bounds.Size());
 80449:     }
 80449:   }
 80449: }
 80449: 
     1: void
 77286: nsIFrame::ComputePreserve3DChildrenOverflow(nsOverflowAreas& aOverflowAreas, const nsRect& aBounds)
 77286: {
 77286:   // When we are preserving 3d we need to iterate over all children separately.
 77286:   // If the child also preserves 3d then their overflow will already been in our
 77286:   // coordinate space, otherwise we need to transform.
 80449: 
 80449:   // If we're the top frame in a preserve 3d chain then we need to recalculate the overflow
 80449:   // areas of all our children since they will have used our size/offset which was invalid at
 80449:   // the time.
 80449:   if (!Preserves3D()) {
 80449:     RecomputePreserve3DChildrenOverflow(this, &aBounds);
 80449:   }
 80449: 
 77286:   nsRect childVisual;
 77286:   nsRect childScrollable;
 77286:   nsIFrame::ChildListIterator lists(this);
 77286:   for (; !lists.IsDone(); lists.Next()) {
 77286:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 77286:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 77286:       nsIFrame* child = childFrames.get();
 80449:       nsPoint offset = child->GetPosition();
 80449:       nsRect visual = child->GetVisualOverflowRect();
 80449:       nsRect scrollable = child->GetScrollableOverflowRect();
 80449:       visual.MoveBy(offset);
 80449:       scrollable.MoveBy(offset);
 77286:       if (child->Preserves3D()) {
 80449:         childVisual = childVisual.Union(visual);
 80449:         childScrollable = childScrollable.Union(scrollable);
 77286:       } else {
 77286:         childVisual = 
 80449:           childVisual.Union(nsDisplayTransform::TransformRect(visual, 
 77286:                             this, nsPoint(0,0), &aBounds));
 77286:         childScrollable = 
 80449:           childScrollable.Union(nsDisplayTransform::TransformRect(scrollable,
 77286:                                 this, nsPoint(0,0), &aBounds));
 77286:       }
 77286:     }
 77286:   }
 77286: 
 82355:   aOverflowAreas.Overflow(eVisualOverflow) = aOverflowAreas.Overflow(eVisualOverflow).Union(childVisual);
 82355:   aOverflowAreas.Overflow(eScrollableOverflow) = aOverflowAreas.Overflow(eScrollableOverflow).Union(childScrollable);
 77286: }
 77286: 
 77286: void
 55021: nsFrame::ConsiderChildOverflow(nsOverflowAreas& aOverflowAreas,
     1:                                nsIFrame* aChildFrame)
     1: {
 55021:   aOverflowAreas.UnionWith(aChildFrame->GetOverflowAreas() +
 55021:                            aChildFrame->GetPosition());
     1: }
     1: 
     1: /**
 34459:  * This function takes a "special" frame and _if_ that frame is an anonymous
 34459:  * block created by an ib split it returns the block's preceding inline.  This
 34459:  * is needed because the split inline's style context is the parent of the
 34459:  * anonymous block's style context.
     1:  *
 34459:  * If aFrame is not an anonymous block, null is returned.
     1:  */
 34459: static nsIFrame*
 90155: GetIBSpecialSiblingForAnonymousBlock(const nsIFrame* aFrame)
     1: {
     1:   NS_PRECONDITION(aFrame, "Must have a non-null frame!");
     1:   NS_ASSERTION(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL,
     1:                "GetIBSpecialSibling should not be called on a non-special frame");
     1: 
 34387:   nsIAtom* type = aFrame->GetStyleContext()->GetPseudo();
 19125:   if (type != nsCSSAnonBoxes::mozAnonymousBlock &&
 19125:       type != nsCSSAnonBoxes::mozAnonymousPositionedBlock) {
 34459:     // it's not an anonymous block
106838:     return nullptr;
 34459:   }
 34459: 
 34459:   // Find the first continuation of the frame.  (Ugh.  This ends up
     1:   // being O(N^2) when it is called O(N) times.)
 34459:   aFrame = aFrame->GetFirstContinuation();
     1: 
     1:   /*
     1:    * Now look up the nsGkAtoms::IBSplitSpecialPrevSibling
 34459:    * property.
     1:    */
 39965:   nsIFrame *specialSibling = static_cast<nsIFrame*>
 39965:     (aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
 34459:   NS_ASSERTION(specialSibling, "Broken frame tree?");
 34459:   return specialSibling;
     1: }
     1: 
     1: /**
     1:  * Get the parent, corrected for the mangled frame tree resulting from
     1:  * having a block within an inline.  The result only differs from the
     1:  * result of |GetParent| when |GetParent| returns an anonymous block
     1:  * that was created for an element that was 'display: inline' because
     1:  * that element contained a block.
     1:  *
     1:  * Also skip anonymous scrolled-content parents; inherit directly from the
     1:  * outer scroll frame.
     1:  */
 78202: static nsIFrame*
 78202: GetCorrectedParent(const nsIFrame* aFrame)
     1: {
     1:   nsIFrame *parent = aFrame->GetParent();
   549:   if (!parent) {
106838:     return nullptr;
 78202:   }
 78202: 
   553:   // Outer tables are always anon boxes; if we're in here for an outer
   553:   // table, that actually means its the _inner_ table that wants to
   553:   // know its parent.  So get the pseudo of the inner in that case.
 78202:   nsIAtom* pseudo = aFrame->GetStyleContext()->GetPseudo();
   553:   if (pseudo == nsCSSAnonBoxes::tableOuter) {
 78202:     pseudo = aFrame->GetFirstPrincipalChild()->GetStyleContext()->GetPseudo();
 78202:   }
 78202:   return nsFrame::CorrectStyleParentFrame(parent, pseudo);
   549: }
   549: 
   549: /* static */
   549: nsIFrame*
   549: nsFrame::CorrectStyleParentFrame(nsIFrame* aProspectiveParent,
   549:                                  nsIAtom* aChildPseudo)
   549: {
   549:   NS_PRECONDITION(aProspectiveParent, "Must have a prospective parent");
   549: 
   549:   // Anon boxes are parented to their actual parent already, except
   549:   // for non-elements.  Those should not be treated as an anon box.
   549:   if (aChildPseudo && aChildPseudo != nsCSSAnonBoxes::mozNonElement &&
   549:       nsCSSAnonBoxes::IsAnonBox(aChildPseudo)) {
   549:     NS_ASSERTION(aChildPseudo != nsCSSAnonBoxes::mozAnonymousBlock &&
   549:                  aChildPseudo != nsCSSAnonBoxes::mozAnonymousPositionedBlock,
   549:                  "Should have dealt with kids that have NS_FRAME_IS_SPECIAL "
   549:                  "elsewhere");
   549:     return aProspectiveParent;
   549:   }
   549: 
  7046:   // Otherwise, walk up out of all anon boxes.  For placeholder frames, walk out
 40137:   // of all pseudo-elements as well.  Otherwise ReparentStyleContext could cause
  3599:   // style data to be out of sync with the frame tree.
   549:   nsIFrame* parent = aProspectiveParent;
   549:   do {
   549:     if (parent->GetStateBits() & NS_FRAME_IS_SPECIAL) {
 34459:       nsIFrame* sibling = GetIBSpecialSiblingForAnonymousBlock(parent);
   549: 
   549:       if (sibling) {
 34459:         // |parent| was a block in an {ib} split; use the inline as
   549:         // |the style parent.
   549:         parent = sibling;
   549:       }
   549:     }
   549:       
 34387:     nsIAtom* parentPseudo = parent->GetStyleContext()->GetPseudo();
  3599:     if (!parentPseudo ||
  3599:         (!nsCSSAnonBoxes::IsAnonBox(parentPseudo) &&
  3599:          // nsPlaceholderFrame pases in nsGkAtoms::placeholderFrame for
  3599:          // aChildPseudo (even though that's not a valid pseudo-type) just to
  3599:          // trigger this behavior of walking up to the nearest non-pseudo
  3599:          // ancestor.
  3599:          aChildPseudo != nsGkAtoms::placeholderFrame)) {
   549:       return parent;
   549:     }
   549: 
     1:     parent = parent->GetParent();
   549:   } while (parent);
   549: 
 34387:   if (aProspectiveParent->GetStyleContext()->GetPseudo() ==
 18953:       nsCSSAnonBoxes::viewportScroll) {
 18953:     // aProspectiveParent is the scrollframe for a viewport
 18953:     // and the kids are the anonymous scrollbars
 18953:     return aProspectiveParent;
 18953:   }
 18953: 
 18953:   // We can get here if the root element is absolutely positioned.
 18953:   // We can't test for this very accurately, but it can only happen
 18953:   // when the prospective parent is a canvas frame.
 18953:   NS_ASSERTION(aProspectiveParent->GetType() == nsGkAtoms::canvasFrame,
 18888:                "Should have found a parent before this");
106838:   return nullptr;
 18885: }
 18885: 
 78202: nsIFrame*
 90155: nsFrame::DoGetParentStyleContextFrame() const
 78202: {
     1:   if (mContent && !mContent->GetParent() &&
 34387:       !GetStyleContext()->GetPseudo()) {
     1:     // we're a frame for the root.  We have no style context parent.
106838:     return nullptr;
     1:   }
     1:   
     1:   if (!(mState & NS_FRAME_OUT_OF_FLOW)) {
     1:     /*
 34459:      * If this frame is an anonymous block created when an inline with a block
 34459:      * inside it got split, then the parent style context is on its preceding
 34459:      * inline. We can get to it using GetIBSpecialSiblingForAnonymousBlock.
     1:      */
     1:     if (mState & NS_FRAME_IS_SPECIAL) {
 78202:       nsIFrame* specialSibling = GetIBSpecialSiblingForAnonymousBlock(this);
 78202:       if (specialSibling) {
 78202:         return specialSibling;
     1:       }
   549:     }
     1: 
     1:     // If this frame is one of the blocks that split an inline, we must
     1:     // return the "special" inline parent, i.e., the parent that this
     1:     // frame would have if we didn't mangle the frame structure.
 78202:     return GetCorrectedParent(this);
     1:   }
     1: 
     1:   // For out-of-flow frames, we must resolve underneath the
     1:   // placeholder's parent.
 90155:   const nsIFrame* oofFrame = this;
 32108:   if ((oofFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
 32108:       GetPrevInFlow()) {
 32108:     // Out of flows that are continuations do not
  6521:     // have placeholders. Use their first-in-flow's placeholder.
  6521:     oofFrame = oofFrame->GetFirstInFlow();
  6521:   }
 78202:   nsIFrame* placeholder = oofFrame->PresContext()->FrameManager()->
 78202:                             GetPlaceholderFrameFor(oofFrame);
     1:   if (!placeholder) {
     1:     NS_NOTREACHED("no placeholder frame for out-of-flow frame");
 78202:     return GetCorrectedParent(this);
 78202:   }
 78202:   return placeholder->GetParentStyleContextFrame();
 78202: }
     1: 
     1: void
     1: nsFrame::GetLastLeaf(nsPresContext* aPresContext, nsIFrame **aFrame)
     1: {
     1:   if (!aFrame || !*aFrame)
     1:     return;
     1:   nsIFrame *child = *aFrame;
     1:   //if we are a block frame then go for the last line of 'this'
     1:   while (1){
 77154:     child = child->GetFirstPrincipalChild();
     1:     if (!child)
     1:       return;//nothing to do
     1:     nsIFrame* siblingFrame;
     1:     nsIContent* content;
     1:     //ignore anonymous elements, e.g. mozTableAdd* mozTableRemove*
     1:     //see bug 278197 comment #12 #13 for details
     1:     while ((siblingFrame = child->GetNextSibling()) &&
     1:            (content = siblingFrame->GetContent()) &&
 16126:            !content->IsRootOfNativeAnonymousSubtree())
     1:       child = siblingFrame;
     1:     *aFrame = child;
     1:   }
     1: }
     1: 
     1: void
     1: nsFrame::GetFirstLeaf(nsPresContext* aPresContext, nsIFrame **aFrame)
     1: {
     1:   if (!aFrame || !*aFrame)
     1:     return;
     1:   nsIFrame *child = *aFrame;
     1:   while (1){
 77154:     child = child->GetFirstPrincipalChild();
     1:     if (!child)
     1:       return;//nothing to do
     1:     *aFrame = child;
     1:   }
     1: }
     1: 
 10152: /* virtual */ const void*
     1: nsFrame::GetStyleDataExternal(nsStyleStructID aSID) const
     1: {
     1:   NS_ASSERTION(mStyleContext, "unexpected null pointer");
     1:   return mStyleContext->GetStyleData(aSID);
     1: }
     1: 
 79445: /* virtual */ bool
108991: nsIFrame::IsFocusable(int32_t *aTabIndex, bool aWithMouse)
108991: {
108991:   int32_t tabIndex = -1;
     1:   if (aTabIndex) {
     1:     *aTabIndex = -1; // Default for early return is not focusable
     1:   }
 79445:   bool isFocusable = false;
     1: 
 80910:   if (mContent && mContent->IsElement() && IsVisibleConsideringAncestors()) {
     1:     const nsStyleUserInterface* ui = GetStyleUserInterface();
     1:     if (ui->mUserFocus != NS_STYLE_USER_FOCUS_IGNORE &&
     1:         ui->mUserFocus != NS_STYLE_USER_FOCUS_NONE) {
     1:       // Pass in default tabindex of -1 for nonfocusable and 0 for focusable
     1:       tabIndex = 0;
     1:     }
 41071:     isFocusable = mContent->IsFocusable(&tabIndex, aWithMouse);
     1:     if (!isFocusable && !aWithMouse &&
     1:         GetType() == nsGkAtoms::scrollFrame &&
 33329:         mContent->IsHTML() &&
 16126:         !mContent->IsRootOfNativeAnonymousSubtree() &&
 16126:         mContent->GetParent() &&
     1:         !mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)) {
     1:       // Elements with scrollable view are focusable with script & tabbable
     1:       // Otherwise you couldn't scroll them with keyboard, which is
     1:       // an accessibility issue (e.g. Section 508 rules)
     1:       // However, we don't make them to be focusable with the mouse,
     1:       // because the extra focus outlines are considered unnecessarily ugly.
     1:       // When clicked on, the selection position within the element 
     1:       // will be enough to make them keyboard scrollable.
 23554:       nsIScrollableFrame *scrollFrame = do_QueryFrame(this);
 68635:       if (scrollFrame &&
 77134:           scrollFrame->GetScrollbarStyles() != nsIScrollableFrame::ScrollbarStyles(NS_STYLE_OVERFLOW_HIDDEN, NS_STYLE_OVERFLOW_HIDDEN) &&
 77134:           !scrollFrame->GetScrollRange().IsEqualEdges(nsRect(0, 0, 0, 0))) {
     1:           // Scroll bars will be used for overflow
 80486:           isFocusable = true;
     1:           tabIndex = 0;
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (aTabIndex) {
     1:     *aTabIndex = tabIndex;
     1:   }
     1:   return isFocusable;
     1: }
     1: 
     1: /**
 80486:  * @return true if this text frame ends with a newline character.  It
 80486:  * should return false if this is not a text frame.
     1:  */
 79445: bool
     1: nsIFrame::HasTerminalNewline() const
     1: {
 80486:   return false;
     1: }
     1: 
108991: static uint8_t
108991: ConvertSVGDominantBaselineToVerticalAlign(uint8_t aDominantBaseline)
107220: {
107220:   switch (aDominantBaseline) {
107220:   case NS_STYLE_DOMINANT_BASELINE_HANGING:
107220:   case NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE:
107220:     return NS_STYLE_VERTICAL_ALIGN_TEXT_TOP;
107220:   case NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE:
107220:   case NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC:
107220:     return NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM;
107220:   case NS_STYLE_DOMINANT_BASELINE_CENTRAL:
107220:   case NS_STYLE_DOMINANT_BASELINE_MIDDLE:
107220:     return NS_STYLE_VERTICAL_ALIGN_MIDDLE;
107220:   case NS_STYLE_DOMINANT_BASELINE_AUTO:
107220:   case NS_STYLE_DOMINANT_BASELINE_ALPHABETIC:
107220:     return NS_STYLE_VERTICAL_ALIGN_BASELINE;
107220:   default:
107220:     NS_NOTREACHED("unexpected aDominantBaseline value");
107220:     return NS_STYLE_VERTICAL_ALIGN_BASELINE;
107220:   }
107220: }
107220: 
108991: uint8_t
107220: nsIFrame::VerticalAlignEnum() const
107220: {
107220:   if (mState & NS_FRAME_IS_SVG_TEXT) {
108991:     uint8_t dominantBaseline;
107220:     for (const nsIFrame* frame = this; frame; frame = frame->GetParent()) {
107220:       dominantBaseline = frame->GetStyleSVGReset()->mDominantBaseline;
107220:       if (dominantBaseline != NS_STYLE_DOMINANT_BASELINE_AUTO ||
107220:           frame->GetType() == nsGkAtoms::svgTextFrame) {
107220:         break;
107220:       }
107220:     }
107220:     return ConvertSVGDominantBaselineToVerticalAlign(dominantBaseline);
107220:   }
107220: 
107220:   const nsStyleCoord& verticalAlign =
107220:     GetStyleContext()->GetStyleTextReset()->mVerticalAlign;
107220:   if (verticalAlign.GetUnit() == eStyleUnit_Enumerated) {
107220:     return verticalAlign.GetIntValue();
107220:   }
107220: 
107220:   return eInvalidVerticalAlign;
107220: }
107220: 
     1: /* static */
     1: void nsFrame::FillCursorInformationFromStyle(const nsStyleUserInterface* ui,
     1:                                              nsIFrame::Cursor& aCursor)
     1: {
     1:   aCursor.mCursor = ui->mCursor;
 80486:   aCursor.mHaveHotspot = false;
     1:   aCursor.mHotspotX = aCursor.mHotspotY = 0.0f;
     1: 
     1:   for (nsCursorImage *item = ui->mCursorArray,
     1:                  *item_end = ui->mCursorArray + ui->mCursorArrayLength;
     1:        item < item_end; ++item) {
108991:     uint32_t status;
 50819:     nsresult rv = item->GetImage()->GetImageStatus(&status);
 32424:     if (NS_SUCCEEDED(rv) && (status & imgIRequest::STATUS_LOAD_COMPLETE)) {
     1:       // This is the one we want
 50819:       item->GetImage()->GetImage(getter_AddRefs(aCursor.mContainer));
     1:       aCursor.mHaveHotspot = item->mHaveHotspot;
     1:       aCursor.mHotspotX = item->mHotspotX;
     1:       aCursor.mHotspotY = item->mHotspotY;
     1:       break;
     1:     }
     1:   }
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFrame::RefreshSizeCache(nsBoxLayoutState& aState)
     1: {
   256:   // XXXbz this comment needs some rewriting to make sense in the
   256:   // post-reflow-branch world.
     1:   
     1:   // Ok we need to compute our minimum, preferred, and maximum sizes.
     1:   // 1) Maximum size. This is easy. Its infinite unless it is overloaded by CSS.
     1:   // 2) Preferred size. This is a little harder. This is the size the block would be 
     1:   //      if it were laid out on an infinite canvas. So we can get this by reflowing
     1:   //      the block with and INTRINSIC width and height. We can also do a nice optimization
     1:   //      for incremental reflow. If the reflow is incremental then we can pass a flag to 
     1:   //      have the block compute the preferred width for us! Preferred height can just be
     1:   //      the minimum height;
     1:   // 3) Minimum size. This is a toughy. We can pass the block a flag asking for the max element
     1:   //    size. That would give us the width. Unfortunately you can only ask for a maxElementSize
     1:   //    during an incremental reflow. So on other reflows we will just have to use 0.
     1:   //    The min height on the other hand is fairly easy we need to get the largest
     1:   //    line height. This can be done with the line iterator.
     1: 
     1:   // if we do have a rendering context
     1:   nsresult rv = NS_OK;
 68481:   nsRenderingContext* rendContext = aState.GetRenderingContext();
     1:   if (rendContext) {
     1:     nsPresContext* presContext = aState.PresContext();
     1: 
     1:     // If we don't have any HTML constraints and it's a resize, then nothing in the block
     1:     // could have changed, so no refresh is necessary.
     1:     nsBoxLayoutMetrics* metrics = BoxMetrics();
     1:     if (!DoesNeedRecalc(metrics->mBlockPrefSize))
     1:       return NS_OK;
     1: 
103530:     // get the old rect.
103530:     nsRect oldRect = GetRect();
103530: 
     1:     // the rect we plan to size to.
103530:     nsRect rect(oldRect);
     1: 
     1:     nsMargin bp(0,0,0,0);
     1:     GetBorderAndPadding(bp);
     1: 
 88122:     {
 88122:       // If we're a container for font size inflation, then shrink
 88122:       // wrapping inside of us should not apply font size inflation.
 98992:       AutoMaybeDisableFontInflation an(this);
 88122: 
 88122:       metrics->mBlockPrefSize.width =
 88122:         GetPrefWidth(rendContext) + bp.LeftRight();
 88122:       metrics->mBlockMinSize.width =
 88122:         GetMinWidth(rendContext) + bp.LeftRight();
 88122:     }
     1: 
     1:     // do the nasty.
     1:     nsHTMLReflowMetrics desiredSize;
     1:     rv = BoxReflow(aState, presContext, desiredSize, rendContext,
     1:                    rect.x, rect.y,
     1:                    metrics->mBlockPrefSize.width, NS_UNCONSTRAINEDSIZE);
     1: 
103530:     nsRect newRect = GetRect();
103530: 
103530:     // make sure we draw any size change
103530:     if (oldRect.width != newRect.width || oldRect.height != newRect.height) {
103530:       newRect.x = 0;
103530:       newRect.y = 0;
103530:       Redraw(aState, &newRect);
103530:     }
103530: 
 13001:     metrics->mBlockMinSize.height = 0;
 13001:     // ok we need the max ascent of the items on the line. So to do this
 13001:     // ask the block for its line iterator. Get the max ascent.
 21112:     nsAutoLineIterator lines = GetLineIterator();
 13001:     if (lines) 
 13001:     {
 13001:       metrics->mBlockMinSize.height = 0;
 13001:       int count = 0;
106838:       nsIFrame* firstFrame = nullptr;
108991:       int32_t framesOnLine;
 13001:       nsRect lineBounds;
108991:       uint32_t lineFlags;
 13001: 
 13001:       do {
 13001:          lines->GetLine(count, &firstFrame, &framesOnLine, lineBounds, &lineFlags);
 13001: 
 13001:          if (lineBounds.height > metrics->mBlockMinSize.height)
 13001:            metrics->mBlockMinSize.height = lineBounds.height;
 13001: 
 13001:          count++;
 13001:       } while(firstFrame);
 13001:     } else {
 13001:       metrics->mBlockMinSize.height = desiredSize.height;
 13001:     }
 13001: 
 13001:     metrics->mBlockPrefSize.height = metrics->mBlockMinSize.height;
     1: 
     1:     if (desiredSize.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE) {
     1:       if (!nsLayoutUtils::GetFirstLineBaseline(this, &metrics->mBlockAscent))
     1:         metrics->mBlockAscent = GetBaseline();
     1:     } else {
     1:       metrics->mBlockAscent = desiredSize.ascent;
     1:     }
     1: 
     1: #ifdef DEBUG_adaptor
     1:     printf("min=(%d,%d), pref=(%d,%d), ascent=%d\n", metrics->mBlockMinSize.width,
     1:                                                      metrics->mBlockMinSize.height,
     1:                                                      metrics->mBlockPrefSize.width,
     1:                                                      metrics->mBlockPrefSize.height,
     1:                                                      metrics->mBlockAscent);
     1: #endif
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
 21112: /* virtual */ nsILineIterator*
 21112: nsFrame::GetLineIterator()
 21112: {
106838:   return nullptr;
 21112: }
 21112: 
     1: nsSize
     1: nsFrame::GetPrefSize(nsBoxLayoutState& aState)
     1: {
     1:   nsSize size(0,0);
     1:   DISPLAY_PREF_SIZE(this, size);
     1:   // If the size is cached, and there are no HTML constraints that we might
     1:   // be depending on, then we just return the cached size.
     1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
     1:   if (!DoesNeedRecalc(metrics->mPrefSize)) {
 39604:     return metrics->mPrefSize;
     1:   }
     1: 
 87626:   if (IsCollapsed())
     1:     return size;
     1: 
     1:   // get our size in CSS.
 79445:   bool widthSet, heightSet;
107520:   bool completelyRedefined = nsIFrame::AddCSSPrefSize(this, size, widthSet, heightSet);
     1: 
     1:   // Refresh our caches with new sizes.
     1:   if (!completelyRedefined) {
     1:     RefreshSizeCache(aState);
 39604:     nsSize blockSize = metrics->mBlockPrefSize;
     1: 
     1:     // notice we don't need to add our borders or padding
     1:     // in. That's because the block did it for us.
 39604:     if (!widthSet)
 39604:       size.width = blockSize.width;
 39604:     if (!heightSet)
 39604:       size.height = blockSize.height;
     1:   }
     1: 
     1:   metrics->mPrefSize = size;
     1:   return size;
     1: }
     1: 
     1: nsSize
     1: nsFrame::GetMinSize(nsBoxLayoutState& aState)
     1: {
     1:   nsSize size(0,0);
     1:   DISPLAY_MIN_SIZE(this, size);
     1:   // Don't use the cache if we have HTMLReflowState constraints --- they might have changed
     1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
     1:   if (!DoesNeedRecalc(metrics->mMinSize)) {
     1:     size = metrics->mMinSize;
     1:     return size;
     1:   }
     1: 
 87626:   if (IsCollapsed())
     1:     return size;
     1: 
     1:   // get our size in CSS.
 79445:   bool widthSet, heightSet;
 79445:   bool completelyRedefined =
107520:     nsIFrame::AddCSSMinSize(aState, this, size, widthSet, heightSet);
     1: 
     1:   // Refresh our caches with new sizes.
     1:   if (!completelyRedefined) {
     1:     RefreshSizeCache(aState);
 39604:     nsSize blockSize = metrics->mBlockMinSize;
 39604: 
 39604:     if (!widthSet)
 39604:       size.width = blockSize.width;
 39604:     if (!heightSet)
 39604:       size.height = blockSize.height;
     1:   }
     1: 
     1:   metrics->mMinSize = size;
     1:   return size;
     1: }
     1: 
     1: nsSize
     1: nsFrame::GetMaxSize(nsBoxLayoutState& aState)
     1: {
     1:   nsSize size(NS_INTRINSICSIZE, NS_INTRINSICSIZE);
     1:   DISPLAY_MAX_SIZE(this, size);
     1:   // Don't use the cache if we have HTMLReflowState constraints --- they might have changed
     1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
     1:   if (!DoesNeedRecalc(metrics->mMaxSize)) {
     1:     size = metrics->mMaxSize;
     1:     return size;
     1:   }
     1: 
 87626:   if (IsCollapsed())
     1:     return size;
     1: 
     1:   size = nsBox::GetMaxSize(aState);
     1:   metrics->mMaxSize = size;
     1: 
     1:   return size;
     1: }
     1: 
     1: nscoord
     1: nsFrame::GetFlex(nsBoxLayoutState& aState)
     1: {
     1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
     1:   if (!DoesNeedRecalc(metrics->mFlex))
     1:      return metrics->mFlex;
     1: 
     1:   metrics->mFlex = nsBox::GetFlex(aState);
     1: 
     1:   return metrics->mFlex;
     1: }
     1: 
     1: nscoord
     1: nsFrame::GetBoxAscent(nsBoxLayoutState& aState)
     1: {
     1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
     1:   if (!DoesNeedRecalc(metrics->mAscent))
     1:     return metrics->mAscent;
     1: 
 87626:   if (IsCollapsed()) {
     1:     metrics->mAscent = 0;
     1:   } else {
     1:     // Refresh our caches with new sizes.
     1:     RefreshSizeCache(aState);
     1:     metrics->mAscent = metrics->mBlockAscent;
     1:   }
     1: 
     1:   return metrics->mAscent;
     1: }
     1: 
     1: nsresult
     1: nsFrame::DoLayout(nsBoxLayoutState& aState)
     1: {
     1:   nsRect ourRect(mRect);
     1: 
 68481:   nsRenderingContext* rendContext = aState.GetRenderingContext();
     1:   nsPresContext* presContext = aState.PresContext();
     1:   nsHTMLReflowMetrics desiredSize;
     1:   nsresult rv = NS_OK;
     1:  
     1:   if (rendContext) {
     1: 
     1:     rv = BoxReflow(aState, presContext, desiredSize, rendContext,
     1:                    ourRect.x, ourRect.y, ourRect.width, ourRect.height);
     1: 
 87626:     if (IsCollapsed()) {
     1:       SetSize(nsSize(0, 0));
     1:     } else {
     1: 
     1:       // if our child needs to be bigger. This might happend with
     1:       // wrapping text. There is no way to predict its height until we
     1:       // reflow it. Now that we know the height reshuffle upward.
     1:       if (desiredSize.width > ourRect.width ||
     1:           desiredSize.height > ourRect.height) {
     1: 
     1: #ifdef DEBUG_GROW
     1:         DumpBox(stdout);
     1:         printf(" GREW from (%d,%d) -> (%d,%d)\n",
     1:                ourRect.width, ourRect.height,
     1:                desiredSize.width, desiredSize.height);
     1: #endif
     1: 
     1:         if (desiredSize.width > ourRect.width)
     1:           ourRect.width = desiredSize.width;
     1: 
     1:         if (desiredSize.height > ourRect.height)
     1:           ourRect.height = desiredSize.height;
     1:       }
     1: 
     1:       // ensure our size is what we think is should be. Someone could have
     1:       // reset the frame to be smaller or something dumb like that. 
     1:       SetSize(nsSize(ourRect.width, ourRect.height));
     1:     }
     1:   }
     1: 
 35703:   // Should we do this if IsCollapsed() is true?
 35703:   nsSize size(GetSize());
 55039:   desiredSize.width = size.width;
 55039:   desiredSize.height = size.height;
 55039:   desiredSize.UnionOverflowAreasWithDesiredBounds();
 92006: 
 92006:   if (HasAbsolutelyPositionedChildren()) {
 92006:     // Set up a |reflowState| to pass into ReflowAbsoluteFrames
 92006:     nsHTMLReflowState reflowState(aState.PresContext(), this,
 92006:                                   aState.GetRenderingContext(),
101858:                                   nsSize(size.width, NS_UNCONSTRAINEDSIZE),
101858:                                   nsHTMLReflowState::DUMMY_PARENT_REFLOW_STATE);
 92006: 
 92006:     // Set up a |reflowStatus| to pass into ReflowAbsoluteFrames
 92006:     // (just a dummy value; hopefully that's OK)
 92006:     nsReflowStatus reflowStatus = NS_FRAME_COMPLETE;
 92006:     ReflowAbsoluteFrames(aState.PresContext(), desiredSize,
 92006:                          reflowState, reflowStatus);
 92006:   }
 92006: 
 55024:   FinishAndStoreOverflow(desiredSize.mOverflowAreas, size);
 35703: 
     1:   SyncLayout(aState);
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsFrame::BoxReflow(nsBoxLayoutState&        aState,
     1:                    nsPresContext*           aPresContext,
     1:                    nsHTMLReflowMetrics&     aDesiredSize,
 68481:                    nsRenderingContext*     aRenderingContext,
     1:                    nscoord                  aX,
     1:                    nscoord                  aY,
     1:                    nscoord                  aWidth,
     1:                    nscoord                  aHeight,
 79445:                    bool                     aMoveFrame)
     1: {
     1:   DO_GLOBAL_REFLOW_COUNT("nsBoxToBlockAdaptor");
     1: 
     1: #ifdef DEBUG_REFLOW
     1:   nsAdaptorAddIndents();
     1:   printf("Reflowing: ");
     1:   nsFrame::ListTag(stdout, mFrame);
     1:   printf("\n");
     1:   gIndent2++;
     1: #endif
     1: 
     1:   //printf("width=%d, height=%d\n", aWidth, aHeight);
     1:   /*
107520:   nsIFrame* parent;
     1:   GetParentBox(&parent);
     1: 
     1:  // if (parent->GetStateBits() & NS_STATE_CURRENTLY_IN_DEBUG)
     1:   //   printf("In debug\n");
     1:   */
     1: 
     1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
     1:   nsReflowStatus status = NS_FRAME_COMPLETE;
     1: 
 79445:   bool needsReflow = NS_SUBTREE_DIRTY(this);
     1: 
     1:   // if we don't need a reflow then 
     1:   // lets see if we are already that size. Yes? then don't even reflow. We are done.
     1:   if (!needsReflow) {
     1:       
     1:       if (aWidth != NS_INTRINSICSIZE && aHeight != NS_INTRINSICSIZE) {
     1:       
     1:           // if the new calculated size has a 0 width or a 0 height
     1:           if ((metrics->mLastSize.width == 0 || metrics->mLastSize.height == 0) && (aWidth == 0 || aHeight == 0)) {
 80486:                needsReflow = false;
     1:                aDesiredSize.width = aWidth; 
     1:                aDesiredSize.height = aHeight; 
     1:                SetSize(nsSize(aDesiredSize.width, aDesiredSize.height));
     1:           } else {
     1:             aDesiredSize.width = metrics->mLastSize.width;
     1:             aDesiredSize.height = metrics->mLastSize.height;
     1: 
     1:             // remove the margin. The rect of our child does not include it but our calculated size does.
     1:             // don't reflow if we are already the right size
     1:             if (metrics->mLastSize.width == aWidth && metrics->mLastSize.height == aHeight)
 80486:                   needsReflow = false;
     1:             else
 80486:                   needsReflow = true;
     1:    
     1:           }
     1:       } else {
     1:           // if the width or height are intrinsic alway reflow because
     1:           // we don't know what it should be.
 80486:          needsReflow = true;
     1:       }
     1:   }
     1:                              
     1:   // ok now reflow the child into the spacers calculated space
     1:   if (needsReflow) {
     1: 
     1:     aDesiredSize.width = 0;
     1:     aDesiredSize.height = 0;
     1: 
     1:     // create a reflow state to tell our child to flow at the given size.
     1: 
     1:     // Construct a bogus parent reflow state so that there's a usable
     1:     // containing block reflow state.
     1:     nsMargin margin(0,0,0,0);
     1:     GetMargin(margin);
     1: 
     1:     nsSize parentSize(aWidth, aHeight);
     1:     if (parentSize.height != NS_INTRINSICSIZE)
     1:       parentSize.height += margin.TopBottom();
     1:     if (parentSize.width != NS_INTRINSICSIZE)
     1:       parentSize.width += margin.LeftRight();
     1: 
     1:     nsIFrame *parentFrame = GetParent();
     1:     nsFrameState savedState = parentFrame->GetStateBits();
     1:     nsHTMLReflowState parentReflowState(aPresContext, parentFrame,
     1:                                         aRenderingContext,
101858:                                         parentSize,
101858:                                         nsHTMLReflowState::DUMMY_PARENT_REFLOW_STATE);
 43376:     parentFrame->RemoveStateBits(~nsFrameState(0));
     1:     parentFrame->AddStateBits(savedState);
     1: 
     1:     // This may not do very much useful, but it's probably worth trying.
     1:     if (parentSize.width != NS_INTRINSICSIZE)
 41671:       parentReflowState.SetComputedWidth(NS_MAX(parentSize.width, 0));
     1:     if (parentSize.height != NS_INTRINSICSIZE)
 41671:       parentReflowState.SetComputedHeight(NS_MAX(parentSize.height, 0));
     1:     parentReflowState.mComputedMargin.SizeTo(0, 0, 0, 0);
     1:     // XXX use box methods
     1:     parentFrame->GetPadding(parentReflowState.mComputedPadding);
     1:     parentFrame->GetBorder(parentReflowState.mComputedBorderPadding);
     1:     parentReflowState.mComputedBorderPadding +=
     1:       parentReflowState.mComputedPadding;
     1: 
     1:     // XXX Is it OK that this reflow state has no parent reflow state?
     1:     // (It used to have a bogus parent, skipping all the boxes).
   256:     nsSize availSize(aWidth, NS_INTRINSICSIZE);
     1:     nsHTMLReflowState reflowState(aPresContext, this, aRenderingContext,
101858:                                   availSize,
101858:                                   nsHTMLReflowState::DUMMY_PARENT_REFLOW_STATE);
     1: 
     1:     // Construct the parent chain manually since constructing it normally
     1:     // messes up dimensions.
 82667:     const nsHTMLReflowState *outerReflowState = aState.OuterReflowState();
 82667:     NS_ASSERTION(!outerReflowState || outerReflowState->frame != this,
 82667:                  "in and out of XUL on a single frame?");
 82667:     if (outerReflowState && outerReflowState->frame == parentFrame) {
 82667:       // We're a frame (such as a text control frame) that jumps into
 82667:       // box reflow and then straight out of it on the child frame.
 82667:       // This means we actually have a real parent reflow state.
 88124:       // nsLayoutUtils::InflationMinFontSizeFor used to need this to be
 88124:       // linked up correctly for text control frames, so do so here).
 82667:       reflowState.parentReflowState = outerReflowState;
 82667:       reflowState.mCBReflowState = outerReflowState;
 82667:     } else {
     1:       reflowState.parentReflowState = &parentReflowState;
     1:       reflowState.mCBReflowState = &parentReflowState;
 82667:     }
 14159:     reflowState.mReflowDepth = aState.GetReflowDepth();
     1: 
     1:     // mComputedWidth and mComputedHeight are content-box, not
     1:     // border-box
     1:     if (aWidth != NS_INTRINSICSIZE) {
     1:       nscoord computedWidth =
     1:         aWidth - reflowState.mComputedBorderPadding.LeftRight();
 32531:       computedWidth = NS_MAX(computedWidth, 0);
     1:       reflowState.SetComputedWidth(computedWidth);
     1:     }
 29122: 
 29122:     // Most child frames of box frames (e.g. subdocument or scroll frames)
 29122:     // need to be constrained to the provided size and overflow as necessary.
 29122:     // The one exception are block frames, because we need to know their
 29122:     // natural height excluding any overflow area which may be caused by
 29122:     // various CSS effects such as shadow or outline.
 29122:     if (!IsFrameOfType(eBlockFrame)) {
     1:       if (aHeight != NS_INTRINSICSIZE) {
  4166:         nscoord computedHeight =
     1:           aHeight - reflowState.mComputedBorderPadding.TopBottom();
 32531:         computedHeight = NS_MAX(computedHeight, 0);
  4166:         reflowState.SetComputedHeight(computedHeight);
   256:       } else {
  4166:         reflowState.SetComputedHeight(
   256:           ComputeSize(aRenderingContext, availSize, availSize.width,
   256:                       nsSize(reflowState.mComputedMargin.LeftRight(),
   256:                              reflowState.mComputedMargin.TopBottom()),
   256:                       nsSize(reflowState.mComputedBorderPadding.LeftRight() -
   256:                                reflowState.mComputedPadding.LeftRight(),
   256:                              reflowState.mComputedBorderPadding.TopBottom() -
   256:                                reflowState.mComputedPadding.TopBottom()),
   256:                       nsSize(reflowState.mComputedPadding.LeftRight(),
   256:                                reflowState.mComputedPadding.TopBottom()),
 80486:                       false).height
  4166:           );
     1:       }
 29122:     }
     1: 
     1:     // Box layout calls SetRect before Layout, whereas non-box layout
     1:     // calls SetRect after Reflow.
     1:     // XXX Perhaps we should be doing this by twiddling the rect back to
     1:     // mLastSize before calling Reflow and then switching it back, but
     1:     // However, mLastSize can also be the size passed to BoxReflow by
     1:     // RefreshSizeCache, so that doesn't really make sense.
 82671:     if (metrics->mLastSize.width != aWidth) {
 80486:       reflowState.mFlags.mHResize = true;
 82671: 
 82671:       // When font size inflation is enabled, a horizontal resize
 82671:       // requires a full reflow.  See nsHTMLReflowState::InitResizeFlags
 82671:       // for more details.
 82671:       if (nsLayoutUtils::FontSizeInflationEnabled(aPresContext)) {
 82671:         AddStateBits(NS_FRAME_IS_DIRTY);
 82671:       }
 82671:     }
     1:     if (metrics->mLastSize.height != aHeight)
 80486:       reflowState.mFlags.mVResize = true;
     1: 
     1:     #ifdef DEBUG_REFLOW
     1:       nsAdaptorAddIndents();
  4166:       printf("Size=(%d,%d)\n",reflowState.ComputedWidth(),
  4166:              reflowState.ComputedHeight());
     1:       nsAdaptorAddIndents();
     1:       nsAdaptorPrintReason(reflowState);
     1:       printf("\n");
     1:     #endif
     1: 
     1:        // place the child and reflow
     1:     WillReflow(aPresContext);
     1: 
     1:     Reflow(aPresContext, aDesiredSize, reflowState, status);
     1: 
     1:     NS_ASSERTION(NS_FRAME_IS_COMPLETE(status), "bad status");
     1: 
108991:     uint32_t layoutFlags = aState.LayoutFlags();
     1:     nsContainerFrame::FinishReflowChild(this, aPresContext, &reflowState,
     1:                                         aDesiredSize, aX, aY, layoutFlags | NS_FRAME_NO_MOVE_FRAME);
     1: 
     1:     // Save the ascent.  (bug 103925)
 87626:     if (IsCollapsed()) {
     1:       metrics->mAscent = 0;
     1:     } else {
     1:       if (aDesiredSize.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE) {
     1:         if (!nsLayoutUtils::GetFirstLineBaseline(this, &metrics->mAscent))
     1:           metrics->mAscent = GetBaseline();
     1:       } else
     1:         metrics->mAscent = aDesiredSize.ascent;
     1:     }
     1: 
     1:   } else {
     1:     aDesiredSize.ascent = metrics->mBlockAscent;
     1:   }
     1: 
     1: #ifdef DEBUG_REFLOW
     1:   if (aHeight != NS_INTRINSICSIZE && aDesiredSize.height != aHeight)
     1:   {
     1:           nsAdaptorAddIndents();
     1:           printf("*****got taller!*****\n");
     1:          
     1:   }
     1:   if (aWidth != NS_INTRINSICSIZE && aDesiredSize.width != aWidth)
     1:   {
     1:           nsAdaptorAddIndents();
     1:           printf("*****got wider!******\n");
     1:          
     1:   }
     1: #endif
     1: 
     1:   if (aWidth == NS_INTRINSICSIZE)
     1:      aWidth = aDesiredSize.width;
     1: 
     1:   if (aHeight == NS_INTRINSICSIZE)
     1:      aHeight = aDesiredSize.height;
     1: 
     1:   metrics->mLastSize.width = aDesiredSize.width;
     1:   metrics->mLastSize.height = aDesiredSize.height;
     1: 
     1: #ifdef DEBUG_REFLOW
     1:   gIndent2--;
     1: #endif
     1: 
     1:   return NS_OK;
     1: }
     1: 
 39965: static void
 39965: DestroyBoxMetrics(void* aPropertyValue)
 39965: {
 39965:   delete static_cast<nsBoxLayoutMetrics*>(aPropertyValue);
 39965: }
 39965: 
 39965: NS_DECLARE_FRAME_PROPERTY(BoxMetricsProperty, DestroyBoxMetrics)
 39965: 
     1: nsBoxLayoutMetrics*
     1: nsFrame::BoxMetrics() const
     1: {
     1:   nsBoxLayoutMetrics* metrics =
 39965:     static_cast<nsBoxLayoutMetrics*>(Properties().Get(BoxMetricsProperty()));
     1:   NS_ASSERTION(metrics, "A box layout method was called but InitBoxMetrics was never called");
     1:   return metrics;
     1: }
     1: 
 51752: void
 51752: nsFrame::SetParent(nsIFrame* aParent)
     1: {
 79445:   bool wasBoxWrapped = IsBoxWrapped();
 51752:   mParent = aParent;
 39965:   if (!wasBoxWrapped && IsBoxWrapped()) {
 80486:     InitBoxMetrics(true);
 39965:   } else if (wasBoxWrapped && !IsBoxWrapped()) {
 39965:     Properties().Delete(BoxMetricsProperty());
 39965:   }
     1: 
 51752:   if (GetStateBits() & (NS_FRAME_HAS_VIEW | NS_FRAME_HAS_CHILD_WITH_VIEW)) {
 51752:     for (nsIFrame* f = aParent;
 51752:          f && !(f->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW);
 51752:          f = f->GetParent()) {
 51752:       f->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
 51752:     }
 51752:   }
 51752: 
103530:   if (GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT) {
 51752:     for (nsIFrame* f = aParent;
103530:          f && !(f->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT);
 51752:          f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
103530:       f->AddStateBits(NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT);
103530:     }
101665:   }
     1: }
     1: 
     1: void
 79445: nsFrame::InitBoxMetrics(bool aClear)
     1: {
 39965:   FrameProperties props = Properties();
 39965:   if (aClear) {
 39965:     props.Delete(BoxMetricsProperty());
 39965:   }
     1: 
     1:   nsBoxLayoutMetrics *metrics = new nsBoxLayoutMetrics();
 39965:   props.Set(BoxMetricsProperty(), metrics);
     1: 
     1:   nsFrame::MarkIntrinsicWidthsDirty();
     1:   metrics->mBlockAscent = 0;
     1:   metrics->mLastSize.SizeTo(0, 0);
     1: }
     1: 
     1: // Box layout debugging
     1: #ifdef DEBUG_REFLOW
108991: int32_t gIndent2 = 0;
     1: 
     1: void
     1: nsAdaptorAddIndents()
     1: {
108991:     for(int32_t i=0; i < gIndent2; i++)
     1:     {
     1:         printf(" ");
     1:     }
     1: }
     1: 
     1: void
     1: nsAdaptorPrintReason(nsHTMLReflowState& aReflowState)
     1: {
     1:     char* reflowReasonString;
     1: 
     1:     switch(aReflowState.reason) 
     1:     {
     1:         case eReflowReason_Initial:
     1:           reflowReasonString = "initial";
     1:           break;
     1: 
     1:         case eReflowReason_Resize:
     1:           reflowReasonString = "resize";
     1:           break;
     1:         case eReflowReason_Dirty:
     1:           reflowReasonString = "dirty";
     1:           break;
     1:         case eReflowReason_StyleChange:
     1:           reflowReasonString = "stylechange";
     1:           break;
     1:         case eReflowReason_Incremental: 
     1:         {
     1:             switch (aReflowState.reflowCommand->Type()) {
     1:               case eReflowType_StyleChanged:
     1:                  reflowReasonString = "incremental (StyleChanged)";
     1:               break;
     1:               case eReflowType_ReflowDirty:
     1:                  reflowReasonString = "incremental (ReflowDirty)";
     1:               break;
     1:               default:
     1:                  reflowReasonString = "incremental (Unknown)";
     1:             }
     1:         }                             
     1:         break;
     1:         default:
     1:           reflowReasonString = "unknown";
     1:           break;
     1:     }
     1: 
     1:     printf("%s",reflowReasonString);
     1: }
     1: 
     1: #endif
     1: #ifdef DEBUG_LAYOUT
     1: void
     1: nsFrame::GetBoxName(nsAutoString& aName)
     1: {
 31709:   GetFrameName(aName);
     1: }
     1: #endif
     1: 
102909: #ifdef DEBUG
     1: static void
107846: GetTagName(nsFrame* aFrame, nsIContent* aContent, int aResultSize,
     1:            char* aResult)
     1: {
     1:   if (aContent) {
 39100:     PR_snprintf(aResult, aResultSize, "%s@%p",
 39100:                 nsAtomCString(aContent->Tag()).get(), aFrame);
 39100:   }
 39100:   else {
 39100:     PR_snprintf(aResult, aResultSize, "@%p", aFrame);
 39100:   }
     1: }
     1: 
     1: void
 79445: nsFrame::Trace(const char* aMethod, bool aEnter)
     1: {
     1:   if (NS_FRAME_LOG_TEST(gLogModule, NS_FRAME_TRACE_CALLS)) {
     1:     char tagbuf[40];
     1:     GetTagName(this, mContent, sizeof(tagbuf), tagbuf);
     1:     PR_LogPrint("%s: %s %s", tagbuf, aEnter ? "enter" : "exit", aMethod);
     1:   }
     1: }
     1: 
     1: void
 79445: nsFrame::Trace(const char* aMethod, bool aEnter, nsReflowStatus aStatus)
     1: {
     1:   if (NS_FRAME_LOG_TEST(gLogModule, NS_FRAME_TRACE_CALLS)) {
     1:     char tagbuf[40];
     1:     GetTagName(this, mContent, sizeof(tagbuf), tagbuf);
     1:     PR_LogPrint("%s: %s %s, status=%scomplete%s",
     1:                 tagbuf, aEnter ? "enter" : "exit", aMethod,
     1:                 NS_FRAME_IS_NOT_COMPLETE(aStatus) ? "not" : "",
     1:                 (NS_FRAME_REFLOW_NEXTINFLOW & aStatus) ? "+reflow" : "");
     1:   }
     1: }
     1: 
     1: void
     1: nsFrame::TraceMsg(const char* aFormatString, ...)
     1: {
     1:   if (NS_FRAME_LOG_TEST(gLogModule, NS_FRAME_TRACE_CALLS)) {
     1:     // Format arguments into a buffer
     1:     char argbuf[200];
     1:     va_list ap;
     1:     va_start(ap, aFormatString);
     1:     PR_vsnprintf(argbuf, sizeof(argbuf), aFormatString, ap);
     1:     va_end(ap);
     1: 
     1:     char tagbuf[40];
     1:     GetTagName(this, mContent, sizeof(tagbuf), tagbuf);
     1:     PR_LogPrint("%s: %s", tagbuf, argbuf);
     1:   }
     1: }
     1: 
     1: void
 30790: nsFrame::VerifyDirtyBitSet(const nsFrameList& aFrameList)
 30790: {
 30790:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
 30790:     NS_ASSERTION(e.get()->GetStateBits() & NS_FRAME_IS_DIRTY,
 30790:                  "dirty bit not set");
     1:   }
     1: }
     1: 
     1: // Start Display Reflow
     1: #ifdef DEBUG
     1: 
     1: DR_cookie::DR_cookie(nsPresContext*          aPresContext,
     1:                      nsIFrame*                aFrame, 
     1:                      const nsHTMLReflowState& aReflowState,
     1:                      nsHTMLReflowMetrics&     aMetrics,
     1:                      nsReflowStatus&          aStatus)
     1:   :mPresContext(aPresContext), mFrame(aFrame), mReflowState(aReflowState), mMetrics(aMetrics), mStatus(aStatus)
     1: {
     1:   MOZ_COUNT_CTOR(DR_cookie);
     1:   mValue = nsFrame::DisplayReflowEnter(aPresContext, mFrame, mReflowState);
     1: }
     1: 
     1: DR_cookie::~DR_cookie()
     1: {
     1:   MOZ_COUNT_DTOR(DR_cookie);
     1:   nsFrame::DisplayReflowExit(mPresContext, mFrame, mMetrics, mStatus, mValue);
     1: }
     1: 
     1: DR_layout_cookie::DR_layout_cookie(nsIFrame* aFrame)
     1:   : mFrame(aFrame)
     1: {
     1:   MOZ_COUNT_CTOR(DR_layout_cookie);
     1:   mValue = nsFrame::DisplayLayoutEnter(mFrame);
     1: }
     1: 
     1: DR_layout_cookie::~DR_layout_cookie()
     1: {
     1:   MOZ_COUNT_DTOR(DR_layout_cookie);
     1:   nsFrame::DisplayLayoutExit(mFrame, mValue);
     1: }
     1: 
     1: DR_intrinsic_width_cookie::DR_intrinsic_width_cookie(
     1:                      nsIFrame*                aFrame, 
     1:                      const char*              aType,
     1:                      nscoord&                 aResult)
     1:   : mFrame(aFrame)
     1:   , mType(aType)
     1:   , mResult(aResult)
     1: {
     1:   MOZ_COUNT_CTOR(DR_intrinsic_width_cookie);
     1:   mValue = nsFrame::DisplayIntrinsicWidthEnter(mFrame, mType);
     1: }
     1: 
     1: DR_intrinsic_width_cookie::~DR_intrinsic_width_cookie()
     1: {
     1:   MOZ_COUNT_DTOR(DR_intrinsic_width_cookie);
     1:   nsFrame::DisplayIntrinsicWidthExit(mFrame, mType, mResult, mValue);
     1: }
     1: 
     1: DR_intrinsic_size_cookie::DR_intrinsic_size_cookie(
     1:                      nsIFrame*                aFrame, 
     1:                      const char*              aType,
     1:                      nsSize&                  aResult)
     1:   : mFrame(aFrame)
     1:   , mType(aType)
     1:   , mResult(aResult)
     1: {
     1:   MOZ_COUNT_CTOR(DR_intrinsic_size_cookie);
     1:   mValue = nsFrame::DisplayIntrinsicSizeEnter(mFrame, mType);
     1: }
     1: 
     1: DR_intrinsic_size_cookie::~DR_intrinsic_size_cookie()
     1: {
     1:   MOZ_COUNT_DTOR(DR_intrinsic_size_cookie);
     1:   nsFrame::DisplayIntrinsicSizeExit(mFrame, mType, mResult, mValue);
     1: }
     1: 
 41687: DR_init_constraints_cookie::DR_init_constraints_cookie(
 41687:                      nsIFrame*                aFrame,
 41687:                      nsHTMLReflowState*       aState,
 41687:                      nscoord                  aCBWidth,
 41687:                      nscoord                  aCBHeight,
 41687:                      const nsMargin*          aMargin,
 41687:                      const nsMargin*          aPadding)
 41687:   : mFrame(aFrame)
 41687:   , mState(aState)
 41687: {
 41687:   MOZ_COUNT_CTOR(DR_init_constraints_cookie);
 41687:   mValue = nsHTMLReflowState::DisplayInitConstraintsEnter(mFrame, mState,
 41687:                                                           aCBWidth, aCBHeight,
 41687:                                                           aMargin, aPadding);
 41687: }
 41687: 
 41687: DR_init_constraints_cookie::~DR_init_constraints_cookie()
 41687: {
 41687:   MOZ_COUNT_DTOR(DR_init_constraints_cookie);
 41687:   nsHTMLReflowState::DisplayInitConstraintsExit(mFrame, mState, mValue);
 41687: }
 41687: 
 41687: DR_init_offsets_cookie::DR_init_offsets_cookie(
 41687:                      nsIFrame*                aFrame,
 41687:                      nsCSSOffsetState*        aState,
 41687:                      nscoord                  aCBWidth,
 41687:                      const nsMargin*          aMargin,
 41687:                      const nsMargin*          aPadding)
 41687:   : mFrame(aFrame)
 41687:   , mState(aState)
 41687: {
 41687:   MOZ_COUNT_CTOR(DR_init_offsets_cookie);
 41687:   mValue = nsCSSOffsetState::DisplayInitOffsetsEnter(mFrame, mState, aCBWidth,
 41687:                                                      aMargin, aPadding);
 41687: }
 41687: 
 41687: DR_init_offsets_cookie::~DR_init_offsets_cookie()
 41687: {
 41687:   MOZ_COUNT_DTOR(DR_init_offsets_cookie);
 41687:   nsCSSOffsetState::DisplayInitOffsetsExit(mFrame, mState, mValue);
 41687: }
 41687: 
 41687: DR_init_type_cookie::DR_init_type_cookie(
 41687:                      nsIFrame*                aFrame,
 41687:                      nsHTMLReflowState*       aState)
 41687:   : mFrame(aFrame)
 41687:   , mState(aState)
 41687: {
 41687:   MOZ_COUNT_CTOR(DR_init_type_cookie);
 41687:   mValue = nsHTMLReflowState::DisplayInitFrameTypeEnter(mFrame, mState);
 41687: }
 41687: 
 41687: DR_init_type_cookie::~DR_init_type_cookie()
 41687: {
 41687:   MOZ_COUNT_DTOR(DR_init_type_cookie);
 41687:   nsHTMLReflowState::DisplayInitFrameTypeExit(mFrame, mState, mValue);
 41687: }
 41687: 
     1: struct DR_FrameTypeInfo;
     1: struct DR_FrameTreeNode;
     1: struct DR_Rule;
     1: 
     1: struct DR_State
     1: {
     1:   DR_State();
     1:   ~DR_State();
     1:   void Init();
     1:   void AddFrameTypeInfo(nsIAtom* aFrameType,
     1:                         const char* aFrameNameAbbrev,
     1:                         const char* aFrameName);
     1:   DR_FrameTypeInfo* GetFrameTypeInfo(nsIAtom* aFrameType);
     1:   DR_FrameTypeInfo* GetFrameTypeInfo(char* aFrameName);
     1:   void InitFrameTypeTable();
     1:   DR_FrameTreeNode* CreateTreeNode(nsIFrame*                aFrame,
     1:                                    const nsHTMLReflowState* aReflowState);
     1:   void FindMatchingRule(DR_FrameTreeNode& aNode);
 79445:   bool RuleMatches(DR_Rule&          aRule,
     1:                      DR_FrameTreeNode& aNode);
 79445:   bool GetToken(FILE* aFile,
 40496:                   char* aBuf,
 40496:                   size_t aBufSize);
     1:   DR_Rule* ParseRule(FILE* aFile);
     1:   void ParseRulesFile();
 24551:   void AddRule(nsTArray<DR_Rule*>& aRules,
     1:                DR_Rule&            aRule);
 79445:   bool IsWhiteSpace(int c);
 79445:   bool GetNumber(char*    aBuf, 
108991:                  int32_t&  aNumber);
     1:   void PrettyUC(nscoord aSize,
     1:                 char*   aBuf);
 41687:   void PrintMargin(const char* tag, const nsMargin* aMargin);
     1:   void DisplayFrameTypeInfo(nsIFrame* aFrame,
108991:                             int32_t   aIndent);
     1:   void DeleteTreeNode(DR_FrameTreeNode& aNode);
     1: 
 79445:   bool        mInited;
 79445:   bool        mActive;
108991:   int32_t     mCount;
108991:   int32_t     mAssert;
108991:   int32_t     mIndent;
 79445:   bool        mIndentUndisplayedFrames;
 79445:   bool        mDisplayPixelErrors;
 24551:   nsTArray<DR_Rule*>          mWildRules;
 26081:   nsTArray<DR_FrameTypeInfo>  mFrameTypeTable;
     1:   // reflow specific state
 24551:   nsTArray<DR_FrameTreeNode*> mFrameTreeLeaves;
     1: };
     1: 
     1: static DR_State *DR_state; // the one and only DR_State
     1: 
     1: struct DR_RulePart 
     1: {
     1:   DR_RulePart(nsIAtom* aFrameType) : mFrameType(aFrameType), mNext(0) {}
     1:   void Destroy();
     1: 
     1:   nsIAtom*     mFrameType;
     1:   DR_RulePart* mNext;
     1: };
     1: 
     1: void DR_RulePart::Destroy()
     1: {
     1:   if (mNext) {
     1:     mNext->Destroy();
     1:   }
     1:   delete this;
     1: }
     1: 
     1: struct DR_Rule 
     1: {
106838:   DR_Rule() : mLength(0), mTarget(nullptr), mDisplay(false) {
     1:     MOZ_COUNT_CTOR(DR_Rule);
     1:   }
     1:   ~DR_Rule() {
     1:     if (mTarget) mTarget->Destroy();
     1:     MOZ_COUNT_DTOR(DR_Rule);
     1:   }
     1:   void AddPart(nsIAtom* aFrameType);
     1: 
108991:   uint32_t      mLength;
     1:   DR_RulePart*  mTarget;
 79445:   bool          mDisplay;
     1: };
     1: 
     1: void DR_Rule::AddPart(nsIAtom* aFrameType)
     1: {
     1:   DR_RulePart* newPart = new DR_RulePart(aFrameType);
     1:   newPart->mNext = mTarget;
     1:   mTarget = newPart;
     1:   mLength++;
     1: }
     1: 
     1: struct DR_FrameTypeInfo
     1: {
     1:   DR_FrameTypeInfo(nsIAtom* aFrmeType, const char* aFrameNameAbbrev, const char* aFrameName);
     1:   ~DR_FrameTypeInfo() { 
108991:       int32_t numElements;
 24551:       numElements = mRules.Length();
108991:       for (int32_t i = numElements - 1; i >= 0; i--) {
 24551:         delete mRules.ElementAt(i);
     1:       }
     1:    }
     1: 
     1:   nsIAtom*    mType;
     1:   char        mNameAbbrev[16];
     1:   char        mName[32];
 24551:   nsTArray<DR_Rule*> mRules;
 26081: private:
 86054:   DR_FrameTypeInfo& operator=(const DR_FrameTypeInfo&) MOZ_DELETE;
     1: };
     1: 
     1: DR_FrameTypeInfo::DR_FrameTypeInfo(nsIAtom* aFrameType, 
     1:                                    const char* aFrameNameAbbrev, 
     1:                                    const char* aFrameName)
     1: {
     1:   mType = aFrameType;
 64079:   PL_strncpyz(mNameAbbrev, aFrameNameAbbrev, sizeof(mNameAbbrev));
 64079:   PL_strncpyz(mName, aFrameName, sizeof(mName));
     1: }
     1: 
     1: struct DR_FrameTreeNode
     1: {
     1:   DR_FrameTreeNode(nsIFrame* aFrame, DR_FrameTreeNode* aParent) : mFrame(aFrame), mParent(aParent), mDisplay(0), mIndent(0)
     1:   {
     1:     MOZ_COUNT_CTOR(DR_FrameTreeNode);
     1:   }
     1: 
     1:   ~DR_FrameTreeNode()
     1:   {
     1:     MOZ_COUNT_DTOR(DR_FrameTreeNode);
     1:   }
     1: 
     1:   nsIFrame*         mFrame;
     1:   DR_FrameTreeNode* mParent;
 79445:   bool              mDisplay;
108991:   uint32_t          mIndent;
     1: };
     1: 
     1: // DR_State implementation
     1: 
     1: DR_State::DR_State() 
 80486: : mInited(false), mActive(false), mCount(0), mAssert(-1), mIndent(0), 
 80486:   mIndentUndisplayedFrames(false), mDisplayPixelErrors(false)
     1: {
     1:   MOZ_COUNT_CTOR(DR_State);
     1: }
     1: 
     1: void DR_State::Init() 
     1: {
     1:   char* env = PR_GetEnv("GECKO_DISPLAY_REFLOW_ASSERT");
108991:   int32_t num;
     1:   if (env) {
     1:     if (GetNumber(env, num)) 
     1:       mAssert = num;
     1:     else 
     1:       printf("GECKO_DISPLAY_REFLOW_ASSERT - invalid value = %s", env);
     1:   }
     1: 
     1:   env = PR_GetEnv("GECKO_DISPLAY_REFLOW_INDENT_START");
     1:   if (env) {
     1:     if (GetNumber(env, num)) 
     1:       mIndent = num;
     1:     else 
     1:       printf("GECKO_DISPLAY_REFLOW_INDENT_START - invalid value = %s", env);
     1:   }
     1: 
     1:   env = PR_GetEnv("GECKO_DISPLAY_REFLOW_INDENT_UNDISPLAYED_FRAMES");
     1:   if (env) {
     1:     if (GetNumber(env, num)) 
     1:       mIndentUndisplayedFrames = num;
     1:     else 
     1:       printf("GECKO_DISPLAY_REFLOW_INDENT_UNDISPLAYED_FRAMES - invalid value = %s", env);
     1:   }
     1: 
     1:   env = PR_GetEnv("GECKO_DISPLAY_REFLOW_FLAG_PIXEL_ERRORS");
     1:   if (env) {
     1:     if (GetNumber(env, num)) 
     1:       mDisplayPixelErrors = num;
     1:     else 
     1:       printf("GECKO_DISPLAY_REFLOW_FLAG_PIXEL_ERRORS - invalid value = %s", env);
     1:   }
     1: 
     1:   InitFrameTypeTable();
     1:   ParseRulesFile();
 80486:   mInited = true;
     1: }
     1: 
     1: DR_State::~DR_State()
     1: {
     1:   MOZ_COUNT_DTOR(DR_State);
108991:   int32_t numElements, i;
 24551:   numElements = mWildRules.Length();
     1:   for (i = numElements - 1; i >= 0; i--) {
 24551:     delete mWildRules.ElementAt(i);
 24551:   }
 24551:   numElements = mFrameTreeLeaves.Length();
     1:   for (i = numElements - 1; i >= 0; i--) {
 24551:     delete mFrameTreeLeaves.ElementAt(i);
 24551:   }
     1: }
     1: 
 79445: bool DR_State::GetNumber(char*     aBuf, 
108991:                            int32_t&  aNumber)
     1: {
     1:   if (sscanf(aBuf, "%d", &aNumber) > 0) 
 80486:     return true;
     1:   else 
 80486:     return false;
     1: }
     1: 
 79445: bool DR_State::IsWhiteSpace(int c) {
     1:   return (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r');
     1: }
     1: 
 79445: bool DR_State::GetToken(FILE* aFile,
 40496:                           char* aBuf,
 40496:                           size_t aBufSize)
     1: {
 79445:   bool haveToken = false;
     1:   aBuf[0] = 0;
     1:   // get the 1st non whitespace char
     1:   int c = -1;
     1:   for (c = getc(aFile); (c > 0) && IsWhiteSpace(c); c = getc(aFile)) {
     1:   }
     1: 
     1:   if (c > 0) {
 80486:     haveToken = true;
     1:     aBuf[0] = c;
     1:     // get everything up to the next whitespace char
 40496:     size_t cX;
 40496:     for (cX = 1; cX + 1 < aBufSize ; cX++) {
 40496:       c = getc(aFile);
     1:       if (c < 0) { // EOF
     1:         ungetc(' ', aFile); 
     1:         break;
     1:       }
     1:       else {
     1:         if (IsWhiteSpace(c)) {
     1:           break;
     1:         }
     1:         else {
     1:           aBuf[cX] = c;
     1:         }
     1:       }
     1:     }
     1:     aBuf[cX] = 0;
     1:   }
     1:   return haveToken;
     1: }
     1: 
     1: DR_Rule* DR_State::ParseRule(FILE* aFile)
     1: {
     1:   char buf[128];
108991:   int32_t doDisplay;
106838:   DR_Rule* rule = nullptr;
 40496:   while (GetToken(aFile, buf, sizeof(buf))) {
     1:     if (GetNumber(buf, doDisplay)) {
     1:       if (rule) { 
  6770:         rule->mDisplay = !!doDisplay;
     1:         break;
     1:       }
     1:       else {
     1:         printf("unexpected token - %s \n", buf);
     1:       }
     1:     }
     1:     else {
     1:       if (!rule) {
     1:         rule = new DR_Rule;
     1:       }
     1:       if (strcmp(buf, "*") == 0) {
106838:         rule->AddPart(nullptr);
     1:       }
     1:       else {
     1:         DR_FrameTypeInfo* info = GetFrameTypeInfo(buf);
     1:         if (info) {
     1:           rule->AddPart(info->mType);
     1:         }
     1:         else {
     1:           printf("invalid frame type - %s \n", buf);
     1:         }
     1:       }
     1:     }
     1:   }
     1:   return rule;
     1: }
     1: 
 24551: void DR_State::AddRule(nsTArray<DR_Rule*>& aRules,
     1:                        DR_Rule&            aRule)
     1: {
108991:   int32_t numRules = aRules.Length();
108991:   for (int32_t ruleX = 0; ruleX < numRules; ruleX++) {
 24551:     DR_Rule* rule = aRules.ElementAt(ruleX);
     1:     NS_ASSERTION(rule, "program error");
     1:     if (aRule.mLength > rule->mLength) {
 24551:       aRules.InsertElementAt(ruleX, &aRule);
     1:       return;
     1:     }
     1:   }
     1:   aRules.AppendElement(&aRule);
     1: }
     1: 
     1: void DR_State::ParseRulesFile()
     1: {
     1:   char* path = PR_GetEnv("GECKO_DISPLAY_REFLOW_RULES_FILE");
     1:   if (path) {
     1:     FILE* inFile = fopen(path, "r");
     1:     if (inFile) {
     1:       for (DR_Rule* rule = ParseRule(inFile); rule; rule = ParseRule(inFile)) {
     1:         if (rule->mTarget) {
     1:           nsIAtom* fType = rule->mTarget->mFrameType;
     1:           if (fType) {
     1:             DR_FrameTypeInfo* info = GetFrameTypeInfo(fType);
     1:             if (info) {
     1:               AddRule(info->mRules, *rule);
     1:             }
     1:           }
     1:           else {
     1:             AddRule(mWildRules, *rule);
     1:           }
 80486:           mActive = true;
     1:         }
     1:       }
     1:     }
     1:   }
     1: }
     1: 
     1: 
     1: void DR_State::AddFrameTypeInfo(nsIAtom* aFrameType,
     1:                                 const char* aFrameNameAbbrev,
     1:                                 const char* aFrameName)
     1: {
 26081:   mFrameTypeTable.AppendElement(DR_FrameTypeInfo(aFrameType, aFrameNameAbbrev, aFrameName));
     1: }
     1: 
     1: DR_FrameTypeInfo* DR_State::GetFrameTypeInfo(nsIAtom* aFrameType)
     1: {
108991:   int32_t numEntries = mFrameTypeTable.Length();
     1:   NS_ASSERTION(numEntries != 0, "empty FrameTypeTable");
108991:   for (int32_t i = 0; i < numEntries; i++) {
 26081:     DR_FrameTypeInfo& info = mFrameTypeTable.ElementAt(i);
 26081:     if (info.mType == aFrameType) {
 26081:       return &info;
 26081:     }
 26081:   }
 26081:   return &mFrameTypeTable.ElementAt(numEntries - 1); // return unknown frame type
     1: }
     1: 
     1: DR_FrameTypeInfo* DR_State::GetFrameTypeInfo(char* aFrameName)
     1: {
108991:   int32_t numEntries = mFrameTypeTable.Length();
     1:   NS_ASSERTION(numEntries != 0, "empty FrameTypeTable");
108991:   for (int32_t i = 0; i < numEntries; i++) {
 26081:     DR_FrameTypeInfo& info = mFrameTypeTable.ElementAt(i);
 26081:     if ((strcmp(aFrameName, info.mName) == 0) || (strcmp(aFrameName, info.mNameAbbrev) == 0)) {
 26081:       return &info;
 26081:     }
 26081:   }
 26081:   return &mFrameTypeTable.ElementAt(numEntries - 1); // return unknown frame type
     1: }
     1: 
     1: void DR_State::InitFrameTypeTable()
     1: {  
     1:   AddFrameTypeInfo(nsGkAtoms::blockFrame,            "block",     "block");
     1:   AddFrameTypeInfo(nsGkAtoms::brFrame,               "br",        "br");
     1:   AddFrameTypeInfo(nsGkAtoms::bulletFrame,           "bullet",    "bullet");
     1:   AddFrameTypeInfo(nsGkAtoms::gfxButtonControlFrame, "button",    "gfxButtonControl");
     1:   AddFrameTypeInfo(nsGkAtoms::HTMLButtonControlFrame, "HTMLbutton",    "HTMLButtonControl");
     1:   AddFrameTypeInfo(nsGkAtoms::HTMLCanvasFrame,       "HTMLCanvas","HTMLCanvas");
     1:   AddFrameTypeInfo(nsGkAtoms::subDocumentFrame,      "subdoc",    "subDocument");
     1:   AddFrameTypeInfo(nsGkAtoms::imageFrame,            "img",       "image");
     1:   AddFrameTypeInfo(nsGkAtoms::inlineFrame,           "inline",    "inline");
     1:   AddFrameTypeInfo(nsGkAtoms::letterFrame,           "letter",    "letter");
     1:   AddFrameTypeInfo(nsGkAtoms::lineFrame,             "line",      "line");
     1:   AddFrameTypeInfo(nsGkAtoms::listControlFrame,      "select",    "select");
     1:   AddFrameTypeInfo(nsGkAtoms::objectFrame,           "obj",       "object");
     1:   AddFrameTypeInfo(nsGkAtoms::pageFrame,             "page",      "page");
     1:   AddFrameTypeInfo(nsGkAtoms::placeholderFrame,      "place",     "placeholder");
     1:   AddFrameTypeInfo(nsGkAtoms::canvasFrame,           "canvas",    "canvas");
     1:   AddFrameTypeInfo(nsGkAtoms::rootFrame,             "root",      "root");
     1:   AddFrameTypeInfo(nsGkAtoms::scrollFrame,           "scroll",    "scroll");
     1:   AddFrameTypeInfo(nsGkAtoms::tableCaptionFrame,     "caption",   "tableCaption");
     1:   AddFrameTypeInfo(nsGkAtoms::tableCellFrame,        "cell",      "tableCell");
     1:   AddFrameTypeInfo(nsGkAtoms::bcTableCellFrame,      "bcCell",    "bcTableCell");
     1:   AddFrameTypeInfo(nsGkAtoms::tableColFrame,         "col",       "tableCol");
     1:   AddFrameTypeInfo(nsGkAtoms::tableColGroupFrame,    "colG",      "tableColGroup");
     1:   AddFrameTypeInfo(nsGkAtoms::tableFrame,            "tbl",       "table");
     1:   AddFrameTypeInfo(nsGkAtoms::tableOuterFrame,       "tblO",      "tableOuter");
     1:   AddFrameTypeInfo(nsGkAtoms::tableRowGroupFrame,    "rowG",      "tableRowGroup");
     1:   AddFrameTypeInfo(nsGkAtoms::tableRowFrame,         "row",       "tableRow");
     1:   AddFrameTypeInfo(nsGkAtoms::textInputFrame,        "textCtl",   "textInput");
     1:   AddFrameTypeInfo(nsGkAtoms::textFrame,             "text",      "text");
     1:   AddFrameTypeInfo(nsGkAtoms::viewportFrame,         "VP",        "viewport");
 23176: #ifdef MOZ_XUL
 23176:   AddFrameTypeInfo(nsGkAtoms::XULLabelFrame,         "XULLabel",  "XULLabel");
 41687:   AddFrameTypeInfo(nsGkAtoms::boxFrame,              "Box",       "Box");
 41687:   AddFrameTypeInfo(nsGkAtoms::sliderFrame,           "Slider",    "Slider");
 41687:   AddFrameTypeInfo(nsGkAtoms::popupSetFrame,         "PopupSet",  "PopupSet");
 23176: #endif
106838:   AddFrameTypeInfo(nullptr,                               "unknown",   "unknown");
     1: }
     1: 
     1: 
     1: void DR_State::DisplayFrameTypeInfo(nsIFrame* aFrame,
108991:                                     int32_t   aIndent)
     1: { 
     1:   DR_FrameTypeInfo* frameTypeInfo = GetFrameTypeInfo(aFrame->GetType());
     1:   if (frameTypeInfo) {
108991:     for (int32_t i = 0; i < aIndent; i++) {
     1:       printf(" ");
     1:     }
     1:     if(!strcmp(frameTypeInfo->mNameAbbrev, "unknown")) {
 31709:       if (aFrame) {
     1:        nsAutoString  name;
 31709:        aFrame->GetFrameName(name);
     1:        printf("%s %p ", NS_LossyConvertUTF16toASCII(name).get(), (void*)aFrame);
     1:       }
     1:       else {
     1:         printf("%s %p ", frameTypeInfo->mNameAbbrev, (void*)aFrame);
     1:       }
     1:     }
     1:     else {
     1:       printf("%s %p ", frameTypeInfo->mNameAbbrev, (void*)aFrame);
     1:     }
     1:   }
     1: }
     1: 
 79445: bool DR_State::RuleMatches(DR_Rule&          aRule,
     1:                              DR_FrameTreeNode& aNode)
     1: {
     1:   NS_ASSERTION(aRule.mTarget, "program error");
     1: 
     1:   DR_RulePart* rulePart;
     1:   DR_FrameTreeNode* parentNode;
     1:   for (rulePart = aRule.mTarget->mNext, parentNode = aNode.mParent;
     1:        rulePart && parentNode;
     1:        rulePart = rulePart->mNext, parentNode = parentNode->mParent) {
     1:     if (rulePart->mFrameType) {
     1:       if (parentNode->mFrame) {
     1:         if (rulePart->mFrameType != parentNode->mFrame->GetType()) {
 80486:           return false;
 80486:         }
 80486:       }
 80486:       else NS_ASSERTION(false, "program error");
     1:     }
     1:     // else wild card match
     1:   }
 80486:   return true;
     1: }
     1: 
     1: void DR_State::FindMatchingRule(DR_FrameTreeNode& aNode)
     1: {
     1:   if (!aNode.mFrame) {
 80486:     NS_ASSERTION(false, "invalid DR_FrameTreeNode \n");
     1:     return;
     1:   }
     1: 
 79445:   bool matchingRule = false;
     1: 
     1:   DR_FrameTypeInfo* info = GetFrameTypeInfo(aNode.mFrame->GetType());
     1:   NS_ASSERTION(info, "program error");
108991:   int32_t numRules = info->mRules.Length();
108991:   for (int32_t ruleX = 0; ruleX < numRules; ruleX++) {
 24551:     DR_Rule* rule = info->mRules.ElementAt(ruleX);
     1:     if (rule && RuleMatches(*rule, aNode)) {
     1:       aNode.mDisplay = rule->mDisplay;
 80486:       matchingRule = true;
     1:       break;
     1:     }
     1:   }
     1:   if (!matchingRule) {
108991:     int32_t numWildRules = mWildRules.Length();
108991:     for (int32_t ruleX = 0; ruleX < numWildRules; ruleX++) {
 24551:       DR_Rule* rule = mWildRules.ElementAt(ruleX);
     1:       if (rule && RuleMatches(*rule, aNode)) {
     1:         aNode.mDisplay = rule->mDisplay;
     1:         break;
     1:       }
     1:     }
     1:   }
     1: }
     1:     
     1: DR_FrameTreeNode* DR_State::CreateTreeNode(nsIFrame*                aFrame,
     1:                                            const nsHTMLReflowState* aReflowState)
     1: {
     1:   // find the frame of the parent reflow state (usually just the parent of aFrame)
     1:   nsIFrame* parentFrame;
     1:   if (aReflowState) {
     1:     const nsHTMLReflowState* parentRS = aReflowState->parentReflowState;
106838:     parentFrame = (parentRS) ? parentRS->frame : nullptr;
     1:   } else {
     1:     parentFrame = aFrame->GetParent();
     1:   }
     1: 
     1:   // find the parent tree node leaf
106838:   DR_FrameTreeNode* parentNode = nullptr;
106838:   
106838:   DR_FrameTreeNode* lastLeaf = nullptr;
 24551:   if(mFrameTreeLeaves.Length())
 26081:     lastLeaf = mFrameTreeLeaves.ElementAt(mFrameTreeLeaves.Length() - 1);
     1:   if (lastLeaf) {
     1:     for (parentNode = lastLeaf; parentNode && (parentNode->mFrame != parentFrame); parentNode = parentNode->mParent) {
     1:     }
     1:   }
     1:   DR_FrameTreeNode* newNode = new DR_FrameTreeNode(aFrame, parentNode);
     1:   FindMatchingRule(*newNode);
     1: 
     1:   newNode->mIndent = mIndent;
     1:   if (newNode->mDisplay || mIndentUndisplayedFrames) {
     1:     ++mIndent;
     1:   }
     1: 
     1:   if (lastLeaf && (lastLeaf == parentNode)) {
 24551:     mFrameTreeLeaves.RemoveElementAt(mFrameTreeLeaves.Length() - 1);
     1:   }
     1:   mFrameTreeLeaves.AppendElement(newNode);
     1:   mCount++;
     1: 
     1:   return newNode;
     1: }
     1: 
     1: void DR_State::PrettyUC(nscoord aSize,
     1:                         char*   aBuf)
     1: {
     1:   if (NS_UNCONSTRAINEDSIZE == aSize) {
     1:     strcpy(aBuf, "UC");
     1:   }
     1:   else {
     1:     if ((nscoord)0xdeadbeefU == aSize)
     1:     {
     1:       strcpy(aBuf, "deadbeef");
     1:     }
     1:     else {
     1:       sprintf(aBuf, "%d", aSize);
     1:     }
     1:   }
     1: }
     1: 
 41687: void DR_State::PrintMargin(const char *tag, const nsMargin* aMargin)
 41687: {
 41687:   if (aMargin) {
 41687:     char t[16], r[16], b[16], l[16];
 41687:     PrettyUC(aMargin->top, t);
 41687:     PrettyUC(aMargin->right, r);
 41687:     PrettyUC(aMargin->bottom, b);
 41687:     PrettyUC(aMargin->left, l);
 41687:     printf(" %s=%s,%s,%s,%s", tag, t, r, b, l);
 41687:   } else {
 41687:     // use %p here for consistency with other null-pointer printouts
 41687:     printf(" %s=%p", tag, (void*)aMargin);
 41687:   }
 41687: }
 41687: 
     1: void DR_State::DeleteTreeNode(DR_FrameTreeNode& aNode)
     1: {
     1:   mFrameTreeLeaves.RemoveElement(&aNode);
108991:   int32_t numLeaves = mFrameTreeLeaves.Length();
 24551:   if ((0 == numLeaves) || (aNode.mParent != mFrameTreeLeaves.ElementAt(numLeaves - 1))) {
     1:     mFrameTreeLeaves.AppendElement(aNode.mParent);
     1:   }
     1: 
     1:   if (aNode.mDisplay || mIndentUndisplayedFrames) {
     1:     --mIndent;
     1:   }
     1:   // delete the tree node 
     1:   delete &aNode;
     1: }
     1: 
     1: static void
     1: CheckPixelError(nscoord aSize,
108991:                 int32_t aPixelToTwips)
     1: {
     1:   if (NS_UNCONSTRAINEDSIZE != aSize) {
     1:     if ((aSize % aPixelToTwips) > 0) {
     1:       printf("VALUE %d is not a whole pixel \n", aSize);
     1:     }
     1:   }
     1: }
     1: 
     1: static void DisplayReflowEnterPrint(nsPresContext*          aPresContext,
     1:                                     nsIFrame*                aFrame,
     1:                                     const nsHTMLReflowState& aReflowState,
     1:                                     DR_FrameTreeNode&        aTreeNode,
 79445:                                     bool                     aChanged)
     1: {
     1:   if (aTreeNode.mDisplay) {
     1:     DR_state->DisplayFrameTypeInfo(aFrame, aTreeNode.mIndent);
     1: 
     1:     char width[16];
     1:     char height[16];
     1: 
     1:     DR_state->PrettyUC(aReflowState.availableWidth, width);
     1:     DR_state->PrettyUC(aReflowState.availableHeight, height);
     1:     printf("Reflow a=%s,%s ", width, height);
     1: 
     1:     DR_state->PrettyUC(aReflowState.ComputedWidth(), width);
  4166:     DR_state->PrettyUC(aReflowState.ComputedHeight(), height);
     1:     printf("c=%s,%s ", width, height);
     1: 
     1:     if (aFrame->GetStateBits() & NS_FRAME_IS_DIRTY)
     1:       printf("dirty ");
     1: 
     1:     if (aFrame->GetStateBits() & NS_FRAME_HAS_DIRTY_CHILDREN)
     1:       printf("dirty-children ");
     1: 
     1:     if (aReflowState.mFlags.mSpecialHeightReflow)
     1:       printf("special-height ");
     1: 
     1:     if (aReflowState.mFlags.mHResize)
     1:       printf("h-resize ");
     1: 
     1:     if (aReflowState.mFlags.mVResize)
     1:       printf("v-resize ");
     1: 
     1:     nsIFrame* inFlow = aFrame->GetPrevInFlow();
     1:     if (inFlow) {
     1:       printf("pif=%p ", (void*)inFlow);
     1:     }
     1:     inFlow = aFrame->GetNextInFlow();
     1:     if (inFlow) {
     1:       printf("nif=%p ", (void*)inFlow);
     1:     }
     1:     if (aChanged) 
     1:       printf("CHANGED \n");
     1:     else 
     1:       printf("cnt=%d \n", DR_state->mCount);
     1:     if (DR_state->mDisplayPixelErrors) {
108991:       int32_t p2t = aPresContext->AppUnitsPerDevPixel();
     1:       CheckPixelError(aReflowState.availableWidth, p2t);
     1:       CheckPixelError(aReflowState.availableHeight, p2t);
     1:       CheckPixelError(aReflowState.ComputedWidth(), p2t);
  4166:       CheckPixelError(aReflowState.ComputedHeight(), p2t);
     1:     }
     1:   }
     1: }
     1: 
     1: void* nsFrame::DisplayReflowEnter(nsPresContext*          aPresContext,
     1:                                   nsIFrame*                aFrame,
     1:                                   const nsHTMLReflowState& aReflowState)
     1: {
     1:   if (!DR_state->mInited) DR_state->Init();
106838:   if (!DR_state->mActive) return nullptr;
     1: 
     1:   NS_ASSERTION(aFrame, "invalid call");
     1: 
     1:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, &aReflowState);
     1:   if (treeNode) {
 80486:     DisplayReflowEnterPrint(aPresContext, aFrame, aReflowState, *treeNode, false);
     1:   }
     1:   return treeNode;
     1: }
     1: 
     1: void* nsFrame::DisplayLayoutEnter(nsIFrame* aFrame)
     1: {
     1:   if (!DR_state->mInited) DR_state->Init();
106838:   if (!DR_state->mActive) return nullptr;
     1: 
     1:   NS_ASSERTION(aFrame, "invalid call");
     1: 
106838:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nullptr);
     1:   if (treeNode && treeNode->mDisplay) {
     1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
     1:     printf("Layout\n");
     1:   }
     1:   return treeNode;
     1: }
     1: 
     1: void* nsFrame::DisplayIntrinsicWidthEnter(nsIFrame* aFrame,
     1:                                           const char* aType)
     1: {
     1:   if (!DR_state->mInited) DR_state->Init();
106838:   if (!DR_state->mActive) return nullptr;
     1: 
     1:   NS_ASSERTION(aFrame, "invalid call");
     1: 
106838:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nullptr);
     1:   if (treeNode && treeNode->mDisplay) {
     1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
     1:     printf("Get%sWidth\n", aType);
     1:   }
     1:   return treeNode;
     1: }
     1: 
     1: void* nsFrame::DisplayIntrinsicSizeEnter(nsIFrame* aFrame,
     1:                                          const char* aType)
     1: {
     1:   if (!DR_state->mInited) DR_state->Init();
106838:   if (!DR_state->mActive) return nullptr;
     1: 
     1:   NS_ASSERTION(aFrame, "invalid call");
     1: 
106838:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nullptr);
     1:   if (treeNode && treeNode->mDisplay) {
     1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
     1:     printf("Get%sSize\n", aType);
     1:   }
     1:   return treeNode;
     1: }
     1: 
     1: void nsFrame::DisplayReflowExit(nsPresContext*      aPresContext,
     1:                                 nsIFrame*            aFrame,
     1:                                 nsHTMLReflowMetrics& aMetrics,
     1:                                 nsReflowStatus       aStatus,
     1:                                 void*                aFrameTreeNode)
     1: {
     1:   if (!DR_state->mActive) return;
     1: 
     1:   NS_ASSERTION(aFrame, "DisplayReflowExit - invalid call");
     1:   if (!aFrameTreeNode) return;
     1: 
     1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
     1:   if (treeNode->mDisplay) {
     1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
     1: 
     1:     char width[16];
     1:     char height[16];
     1:     char x[16];
     1:     char y[16];
     1:     DR_state->PrettyUC(aMetrics.width, width);
     1:     DR_state->PrettyUC(aMetrics.height, height);
     1:     printf("Reflow d=%s,%s", width, height);
     1: 
  4006:     if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
     1:       printf(" status=0x%x", aStatus);
     1:     }
 55040:     if (aFrame->HasOverflowAreas()) {
 55040:       DR_state->PrettyUC(aMetrics.VisualOverflow().x, x);
 55040:       DR_state->PrettyUC(aMetrics.VisualOverflow().y, y);
 55040:       DR_state->PrettyUC(aMetrics.VisualOverflow().width, width);
 55040:       DR_state->PrettyUC(aMetrics.VisualOverflow().height, height);
 55040:       printf(" vis-o=(%s,%s) %s x %s", x, y, width, height);
 55040: 
 55040:       nsRect storedOverflow = aFrame->GetVisualOverflowRect();
 11909:       DR_state->PrettyUC(storedOverflow.x, x);
 11909:       DR_state->PrettyUC(storedOverflow.y, y);
 11909:       DR_state->PrettyUC(storedOverflow.width, width);
 11909:       DR_state->PrettyUC(storedOverflow.height, height);
 55040:       printf(" vis-sto=(%s,%s) %s x %s", x, y, width, height);
 55040: 
 55040:       DR_state->PrettyUC(aMetrics.ScrollableOverflow().x, x);
 55040:       DR_state->PrettyUC(aMetrics.ScrollableOverflow().y, y);
 55040:       DR_state->PrettyUC(aMetrics.ScrollableOverflow().width, width);
 55040:       DR_state->PrettyUC(aMetrics.ScrollableOverflow().height, height);
 55040:       printf(" scr-o=(%s,%s) %s x %s", x, y, width, height);
 55040: 
 55040:       storedOverflow = aFrame->GetScrollableOverflowRect();
 55040:       DR_state->PrettyUC(storedOverflow.x, x);
 55040:       DR_state->PrettyUC(storedOverflow.y, y);
 55040:       DR_state->PrettyUC(storedOverflow.width, width);
 55040:       DR_state->PrettyUC(storedOverflow.height, height);
 55040:       printf(" scr-sto=(%s,%s) %s x %s", x, y, width, height);
     1:     }
     1:     printf("\n");
     1:     if (DR_state->mDisplayPixelErrors) {
108991:       int32_t p2t = aPresContext->AppUnitsPerDevPixel();
     1:       CheckPixelError(aMetrics.width, p2t);
     1:       CheckPixelError(aMetrics.height, p2t);
     1:     }
     1:   }
     1:   DR_state->DeleteTreeNode(*treeNode);
     1: }
     1: 
     1: void nsFrame::DisplayLayoutExit(nsIFrame*            aFrame,
     1:                                 void*                aFrameTreeNode)
     1: {
     1:   if (!DR_state->mActive) return;
     1: 
     1:   NS_ASSERTION(aFrame, "non-null frame required");
     1:   if (!aFrameTreeNode) return;
     1: 
     1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
     1:   if (treeNode->mDisplay) {
     1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
     1:     nsRect rect = aFrame->GetRect();
     1:     printf("Layout=%d,%d,%d,%d\n", rect.x, rect.y, rect.width, rect.height);
     1:   }
     1:   DR_state->DeleteTreeNode(*treeNode);
     1: }
     1: 
     1: void nsFrame::DisplayIntrinsicWidthExit(nsIFrame*            aFrame,
     1:                                         const char*          aType,
     1:                                         nscoord              aResult,
     1:                                         void*                aFrameTreeNode)
     1: {
     1:   if (!DR_state->mActive) return;
     1: 
     1:   NS_ASSERTION(aFrame, "non-null frame required");
     1:   if (!aFrameTreeNode) return;
     1: 
     1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
     1:   if (treeNode->mDisplay) {
     1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
 36972:     char width[16];
 36972:     DR_state->PrettyUC(aResult, width);
 36972:     printf("Get%sWidth=%s\n", aType, width);
     1:   }
     1:   DR_state->DeleteTreeNode(*treeNode);
     1: }
     1: 
     1: void nsFrame::DisplayIntrinsicSizeExit(nsIFrame*            aFrame,
     1:                                        const char*          aType,
     1:                                        nsSize               aResult,
     1:                                        void*                aFrameTreeNode)
     1: {
     1:   if (!DR_state->mActive) return;
     1: 
     1:   NS_ASSERTION(aFrame, "non-null frame required");
     1:   if (!aFrameTreeNode) return;
     1: 
     1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
     1:   if (treeNode->mDisplay) {
     1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
     1: 
     1:     char width[16];
     1:     char height[16];
     1:     DR_state->PrettyUC(aResult.width, width);
     1:     DR_state->PrettyUC(aResult.height, height);
     1:     printf("Get%sSize=%s,%s\n", aType, width, height);
     1:   }
     1:   DR_state->DeleteTreeNode(*treeNode);
     1: }
     1: 
     1: /* static */ void
     1: nsFrame::DisplayReflowStartup()
     1: {
     1:   DR_state = new DR_State();
     1: }
     1: 
     1: /* static */ void
     1: nsFrame::DisplayReflowShutdown()
     1: {
     1:   delete DR_state;
106838:   DR_state = nullptr;
     1: }
     1: 
     1: void DR_cookie::Change() const
     1: {
     1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)mValue;
     1:   if (treeNode && treeNode->mDisplay) {
 80486:     DisplayReflowEnterPrint(mPresContext, mFrame, mReflowState, *treeNode, true);
     1:   }
     1: }
     1: 
 41687: /* static */ void*
 41687: nsHTMLReflowState::DisplayInitConstraintsEnter(nsIFrame* aFrame,
 41687:                                                nsHTMLReflowState* aState,
 41687:                                                nscoord aContainingBlockWidth,
 41687:                                                nscoord aContainingBlockHeight,
 41687:                                                const nsMargin* aBorder,
 41687:                                                const nsMargin* aPadding)
 41687: {
 41687:   NS_PRECONDITION(aFrame, "non-null frame required");
 41687:   NS_PRECONDITION(aState, "non-null state required");
 41687: 
 41687:   if (!DR_state->mInited) DR_state->Init();
106838:   if (!DR_state->mActive) return nullptr;
 41687: 
 41687:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, aState);
 41687:   if (treeNode && treeNode->mDisplay) {
 41687:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
 41687: 
 41687:     printf("InitConstraints parent=%p",
 41687:            (void*)aState->parentReflowState);
 41687: 
 41687:     char width[16];
 41687:     char height[16];
 41687: 
 41687:     DR_state->PrettyUC(aContainingBlockWidth, width);
 41687:     DR_state->PrettyUC(aContainingBlockHeight, height);
 41687:     printf(" cb=%s,%s", width, height);
 41687: 
 41687:     DR_state->PrettyUC(aState->availableWidth, width);
 41687:     DR_state->PrettyUC(aState->availableHeight, height);
 41687:     printf(" as=%s,%s", width, height);
 41687: 
 41687:     DR_state->PrintMargin("b", aBorder);
 41687:     DR_state->PrintMargin("p", aPadding);
 41687:     putchar('\n');
 41687:   }
 41687:   return treeNode;
 41687: }
 41687: 
 41687: /* static */ void
 41687: nsHTMLReflowState::DisplayInitConstraintsExit(nsIFrame* aFrame,
 41687:                                               nsHTMLReflowState* aState,
 41687:                                               void* aValue)
 41687: {
 41687:   NS_PRECONDITION(aFrame, "non-null frame required");
 41687:   NS_PRECONDITION(aState, "non-null state required");
 41687: 
 41687:   if (!DR_state->mActive) return;
 41687:   if (!aValue) return;
 41687: 
 41687:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aValue;
 41687:   if (treeNode->mDisplay) {
 41687:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
 41687:     char cmiw[16], cw[16], cmxw[16], cmih[16], ch[16], cmxh[16];
 41687:     DR_state->PrettyUC(aState->mComputedMinWidth, cmiw);
 41687:     DR_state->PrettyUC(aState->mComputedWidth, cw);
 41687:     DR_state->PrettyUC(aState->mComputedMaxWidth, cmxw);
 41687:     DR_state->PrettyUC(aState->mComputedMinHeight, cmih);
 41687:     DR_state->PrettyUC(aState->mComputedHeight, ch);
 41687:     DR_state->PrettyUC(aState->mComputedMaxHeight, cmxh);
 41687:     printf("InitConstraints= cw=(%s <= %s <= %s) ch=(%s <= %s <= %s)",
 41687:            cmiw, cw, cmxw, cmih, ch, cmxh);
 41687:     DR_state->PrintMargin("co", &aState->mComputedOffsets);
 41687:     putchar('\n');
 41687:   }
 41687:   DR_state->DeleteTreeNode(*treeNode);
 41687: }
 41687: 
 41687: 
 41687: /* static */ void*
 41687: nsCSSOffsetState::DisplayInitOffsetsEnter(nsIFrame* aFrame,
 41687:                                           nsCSSOffsetState* aState,
 41687:                                           nscoord aContainingBlockWidth,
 41687:                                           const nsMargin* aBorder,
 41687:                                           const nsMargin* aPadding)
 41687: {
 41687:   NS_PRECONDITION(aFrame, "non-null frame required");
 41687:   NS_PRECONDITION(aState, "non-null state required");
 41687: 
 41687:   if (!DR_state->mInited) DR_state->Init();
106838:   if (!DR_state->mActive) return nullptr;
 41687: 
 41687:   // aState is not necessarily a nsHTMLReflowState
106838:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nullptr);
 41687:   if (treeNode && treeNode->mDisplay) {
 41687:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
 41687: 
 41687:     char width[16];
 41687:     DR_state->PrettyUC(aContainingBlockWidth, width);
 41687:     printf("InitOffsets cbw=%s", width);
 41687:     DR_state->PrintMargin("b", aBorder);
 41687:     DR_state->PrintMargin("p", aPadding);
 41687:     putchar('\n');
 41687:   }
 41687:   return treeNode;
 41687: }
 41687: 
 41687: /* static */ void
 41687: nsCSSOffsetState::DisplayInitOffsetsExit(nsIFrame* aFrame,
 41687:                                          nsCSSOffsetState* aState,
 41687:                                          void* aValue)
 41687: {
 41687:   NS_PRECONDITION(aFrame, "non-null frame required");
 41687:   NS_PRECONDITION(aState, "non-null state required");
 41687: 
 41687:   if (!DR_state->mActive) return;
 41687:   if (!aValue) return;
 41687: 
 41687:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aValue;
 41687:   if (treeNode->mDisplay) {
 41687:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
 41687:     printf("InitOffsets=");
 41687:     DR_state->PrintMargin("m", &aState->mComputedMargin);
 41687:     DR_state->PrintMargin("p", &aState->mComputedPadding);
 41687:     DR_state->PrintMargin("p+b", &aState->mComputedBorderPadding);
 41687:     putchar('\n');
 41687:   }
 41687:   DR_state->DeleteTreeNode(*treeNode);
 41687: }
 41687: 
 41687: /* static */ void*
 41687: nsHTMLReflowState::DisplayInitFrameTypeEnter(nsIFrame* aFrame,
 41687:                                              nsHTMLReflowState* aState)
 41687: {
 41687:   NS_PRECONDITION(aFrame, "non-null frame required");
 41687:   NS_PRECONDITION(aState, "non-null state required");
 41687: 
 41687:   if (!DR_state->mInited) DR_state->Init();
106838:   if (!DR_state->mActive) return nullptr;
 41687: 
 41687:   // we don't print anything here
 41687:   return DR_state->CreateTreeNode(aFrame, aState);
 41687: }
 41687: 
 41687: /* static */ void
 41687: nsHTMLReflowState::DisplayInitFrameTypeExit(nsIFrame* aFrame,
 41687:                                             nsHTMLReflowState* aState,
 41687:                                             void* aValue)
 41687: {
 41687:   NS_PRECONDITION(aFrame, "non-null frame required");
 41687:   NS_PRECONDITION(aState, "non-null state required");
 41687: 
 41687:   if (!DR_state->mActive) return;
 41687:   if (!aValue) return;
 41687: 
 41687:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aValue;
 41687:   if (treeNode->mDisplay) {
 41687:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
 41687:     printf("InitFrameType");
 41687: 
 41687:     const nsStyleDisplay *disp = aState->mStyleDisplay;
 41687: 
 41687:     if (aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
 41687:       printf(" out-of-flow");
 41687:     if (aFrame->GetPrevInFlow())
 41687:       printf(" prev-in-flow");
107225:     if (aFrame->IsAbsolutelyPositioned())
 41687:       printf(" abspos");
107224:     if (aFrame->IsFloating())
 41687:       printf(" float");
 41687: 
 41687:     // This array must exactly match the NS_STYLE_DISPLAY constants.
 41687:     const char *const displayTypes[] = {
 41687:       "none", "block", "inline", "inline-block", "list-item", "marker",
 41687:       "run-in", "compact", "table", "inline-table", "table-row-group",
 41687:       "table-column", "table-column-group", "table-header-group",
 41687:       "table-footer-group", "table-row", "table-cell", "table-caption",
 41687:       "box", "inline-box",
 41687: #ifdef MOZ_XUL
 41687:       "grid", "inline-grid", "grid-group", "grid-line", "stack",
 41687:       "inline-stack", "deck", "popup", "groupbox",
 41687: #endif
 41687:     };
 80467:     if (disp->mDisplay >= ArrayLength(displayTypes))
 41687:       printf(" display=%u", disp->mDisplay);
 41687:     else
 41687:       printf(" display=%s", displayTypes[disp->mDisplay]);
 41687: 
 41687:     // This array must exactly match the NS_CSS_FRAME_TYPE constants.
 41687:     const char *const cssFrameTypes[] = {
 41687:       "unknown", "inline", "block", "floating", "absolute", "internal-table"
 41687:     };
 41687:     nsCSSFrameType bareType = NS_FRAME_GET_TYPE(aState->mFrameType);
 41687:     bool repNoBlock = NS_FRAME_IS_REPLACED_NOBLOCK(aState->mFrameType);
 41687:     bool repBlock = NS_FRAME_IS_REPLACED_CONTAINS_BLOCK(aState->mFrameType);
 41687: 
 80467:     if (bareType >= ArrayLength(cssFrameTypes)) {
 41687:       printf(" result=type %u", bareType);
 41687:     } else {
 41687:       printf(" result=%s", cssFrameTypes[bareType]);
 41687:     }
 41687:     printf("%s%s\n", repNoBlock ? " +rep" : "", repBlock ? " +repBlk" : "");
 41687:   }
 41687:   DR_state->DeleteTreeNode(*treeNode);
 41687: }
 41687: 
     1: #endif
     1: // End Display Reflow
     1: 
     1: #endif
