108036: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
108036: /* vim: set ts=2 sw=2 et tw=78: */
108036: /* This Source Code Form is subject to the terms of the Mozilla Public
108036:  * License, v. 2.0. If a copy of the MPL was not distributed with this
108036:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
108036: 
123733: /*
123733:   Implementation description from https://etherpad.mozilla.org/dir-auto
123733: 
123733:   Static case
123733:   ===========
123733:   When we see a new content node with @dir=auto from the parser, we set the
123733:   NodeHasDirAuto flag on the node.  We won't have enough information to
123733:   decide the directionality of the node at this point.
123733: 
123733:   When we bind a new content node to the document, if its parent has either of
123733:   the NodeAncestorHasDirAuto or NodeHasDirAuto flags, we set the
123733:   NodeAncestorHasDirAuto flag on the node.
123733: 
123733:   When a new input with @type=text/search/tel/url/email and @dir=auto is added
123733:   from the parser, we resolve the directionality based on its @value.
123733: 
123733:   When a new text node with non-neutral content is appended to a textarea
123733:   element with NodeHasDirAuto, if the directionality of the textarea element
123733:   is still unresolved, it is resolved based on the value of the text node.
123733:   Elements with unresolved directionality behave as LTR.
123733: 
123733:   When a new text node with non-neutral content is appended to an element that
123733:   is not a textarea but has either of the NodeAncestorHasDirAuto or
123733:   NodeHasDirAuto flags, we walk up the parent chain while the
123733:   NodeAncestorHasDirAuto flag is present, and when we reach an element with
123733:   NodeHasDirAuto and no resolved directionality, we resolve the directionality
123733:   based on the contents of the text node and cease walking the parent chain.
123733:   Note that we should ignore elements with NodeHasDirAuto with resolved
123733:   directionality, so that the second text node in this example tree doesn't
123733:   affect the directionality of the div:
123733: 
123733:   <div dir=auto>
123733:     <span>foo</span>
123733:     <span>بار</span>
123733:   </div>
123733: 
123733:   The parent chain walk will be aborted if we hit a script or style element, or
123733:   if we hit an element with @dir=ltr or @dir=rtl.
123733: 
123733:   I will call this algorithm "upward propagation".
123733: 
123733:   Each text node should maintain a list of elements which have their
123733:   directionality determined by the first strong character of that text node.
123733:   This is useful to make dynamic changes more efficient.  One way to implement
123733:   this is to have a per-document hash table mapping a text node to a set of
123733:   elements.  I'll call this data structure TextNodeDirectionalityMap. The
123733:   algorithm for appending a new text node above needs to update this data
123733:   structure.
123733: 
123733:   *IMPLEMENTATION NOTE*
123733:   In practice, the implementation uses two per-node properties:
123733: 
123733:   dirAutoSetBy, which is set on a node with auto-directionality, and points to
123733:   the textnode that contains the strong character which determines the
123733:   directionality of the node.
123733: 
123733:   textNodeDirectionalityMap, which is set on a text node and points to a hash
123733:   table listing the nodes whose directionality is determined by the text node.
123733: 
123733:   Handling dynamic changes
123733:   ========================
123733: 
123733:   We need to handle the following cases:
123733: 
123733:   1. When the value of an input element with @type=text/search/tel/url/email is
123733:   changed, if it has NodeHasDirAuto, we update the resolved directionality.
123733: 
123733:   2. When the dir attribute is changed from something else (including the case
123733:   where it doesn't exist) to auto on a textarea or an input element with
123733:   @type=text/search/tel/url/email, we set the NodeHasDirAuto flag and resolve
123733:   the directionality based on the value of the element.
123733: 
123733:   3. When the dir attribute is changed from something else (including the case
123733:   where it doesn't exist) to auto on any element except case 1 above and the bdi
123733:   element, we run the following algorithm:
123733:   * We set the NodeHasDirAuto flag.
123733:   * If the element doesn't have the NodeAncestorHasDirAuto flag, we set the
123733:   NodeAncestorHasDirAuto flag on all of its child nodes.  (Note that if the
123733:   element does have NodeAncestorHasDirAuto, all of its children should
123733:   already have this flag too.  We can assert this in debug builds.)
123733:   * To resolve the directionality of the element, we run the algorithm explained
123733:   in http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#the-dir-attribute
123733:   (I'll call this the "downward propagation algorithm".) by walking the child
123733:   subtree in tree order.  Note that an element with @dir=auto should not affect
123733:   other elements in its document with @dir=auto.  So there is no need to walk up
123733:   the parent chain in this case.  TextNodeDirectionalityMap needs to be updated
123733:   as appropriate.
123733: 
123733:   3a. When the dir attribute is set to any valid value on an element that didn't
123733:   have a valid dir attribute before, this means that any descendant of that
123733:   element will not affect the directionality of any of its ancestors. So we need
123733:   to check whether any text node descendants of the element are listed in
123733:   TextNodeDirectionalityMap, and whether the elements whose direction they set
123733:   are ancestors of the element. If so, we need to rerun the downward propagation
123733:   algorithm for those ancestors.
123733: 
123733:   4.  When the dir attribute is changed from auto to something else (including
123733:   the case where it gets removed) on a textarea or an input element with
123733:   @type=text/search/tel/url/email, we unset the NodeHasDirAuto flag and
123733:   resolve the directionality based on the directionality of the value of the @dir
123733:   attribute on element itself or its parent element.
123733: 
123733:   5. When the dir attribute is changed from auto to something else (including the
123733:   case where it gets removed) on any element except case 4 above and the bdi
123733:   element, we run the following algorithm:
123733:   * We unset the NodeHasDirAuto flag.
123733:   * If the element does not have the NodeAncestorHasDirAuto flag, we unset
123733:   the NodeAncestorHasDirAuto flag on all of its child nodes, except those
123733:   who are a descendant of another element with NodeHasDirAuto.  (Note that if
123733:   the element has the NodeAncestorHasDirAuto flag, all of its child nodes
123733:   should still retain the same flag.)
123733:   * We resolve the directionality of the element based on the value of the @dir
123733:   attribute on the element itself or its parent element.
123733:   TextNodeDirectionalityMap needs to be updated as appropriate.
123733: 
123733:   5a. When the dir attribute is removed or set to an invalid value on any
123733:   element (except a bdi element) with the NodeAncestorHasDirAuto flag which
123733:   previously had a valid dir attribute, it might have a text node descendant that
123733:   did not previously affect the directionality of any of its ancestors but should
123733:   now begin to affect them.
123733:   We run the following algorithm:
123733:   * Walk up the parent chain from the element.
123733:   * For any element that appears in the TextNodeDirectionalityMap, remove the
123733:     element from the map and rerun the downward propagation algorithm
123733:     (see section 3).
123733:   * If we reach an element without either of the NodeHasDirAuto or
123733:     NodeAncestorHasDirAuto flags, abort the parent chain walk.
123733: 
123733:   6. When an element with @dir=auto is added to the document, we should handle it
123733:   similar to the case 2/3 above.
123733: 
123733:   7. When an element with NodeHasDirAuto or NodeAncestorHasDirAuto is
123733:   removed from the document, we should handle it similar to the case 4/5 above,
123733:   except that we don't need to handle anything in the child subtree.  We should
123733:   also remove all of the occurrences of that node and its descendants from
123733:   TextNodeDirectionalityMap. (This is the conceptual description of what needs to
123733:   happen but in the implementation UnbindFromTree is going to be called on all of
123733:   the descendants so we don't need to descend into the child subtree).
123733: 
123733:   8. When the contents of a text node is changed either from script or by the
123733:   user, we need to run the following algorithm:
123733:   * If the change has happened after the first character with strong
123733:   directionality in the text node, do nothing.
123733:   * If the text node is a child of a bdi, script or style element, do nothing.
123733:   * If the text node belongs to a textarea with NodeHasDirAuto, we need to
123733:   update the directionality of the textarea.
123733:   * Grab a list of elements affected by this text node from
123733:   TextNodeDirectionalityMap and re-resolve the directionality of each one of them
123733:   based on the new contents of the text node.
123733:   * If the text node does not exist in TextNodeDirectionalityMap, and it has the
123733:   NodeAncestorHasDirAuto flag set, this could potentially be a text node
123733:   which is going to start affecting the directionality of its parent @dir=auto
123733:   elements. In this case, we need to fall back to the (potentially expensive)
123733:   "upward propagation algorithm".  The TextNodeDirectionalityMap data structure
123733:   needs to be update during this algorithm.
123733:   * If the new contents of the text node do not have any strong characters, and
123733:   the old contents used to, and the text node used to exist in
123733:   TextNodeDirectionalityMap and it has the NodeAncestorHasDirAuto flag set,
123733:   the elements associated with this text node inside TextNodeDirectionalityMap
123733:   will now get their directionality from another text node.  In this case, for
123733:   each element in the list retrieved from TextNodeDirectionalityMap, run the
123733:   downward propagation algorithm (section 3), and remove the text node from
123733:   TextNodeDirectionalityMap.
123733: 
123733:   9. When a new text node is injected into a document, we need to run the
123733:   following algorithm:
123733:   * If the contents of the text node do not have any characters with strong
123733:   direction, do nothing.
123733:   * If the text node is a child of a bdi, script or style element, do nothing.
123733:   * If the text node is appended to a textarea element with NodeHasDirAuto, we
123733:   need to update the directionality of the textarea.
123733:   * If the text node has NodeAncestorHasDirAuto, we need to run the "upward
123733:   propagation algorithm".  The TextNodeDirectionalityMap data structure needs to
123733:   be update during this algorithm.
123733: 
123733:   10. When a text node is removed from a document, we need to run the following
123733:   algorithm:
123733:   * If the contents of the text node do not have any characters with strong
123733:   direction, do nothing.
123733:   * If the text node is a child of a bdi, script or style element, do nothing.
123733:   * If the text node is removed from a textarea element with NodeHasDirAuto,
123733:   set the directionality to "ltr". (This is what the spec currently says, but I'm
123733:   filing a spec bug to get it fixed -- the directionality should depend on the
123733:   parent element here.)
123733:   * If the text node has NodeAncestorHasDirAuto, we need to look at the list
123733:   of elements being affected by this text node from TextNodeDirectionalityMap,
123733:   run the "downward propagation algorithm" (section 3) for each one of them,
123733:   while updating TextNodeDirectionalityMap along the way.
123733: 
123733:   11. If the value of the @dir attribute on a bdi element is changed to an
123733:   invalid value (or if it's removed), determine the new directionality similar
123733:   to the case 3 above.
123733: 
123733:   == Implemention Notes ==
123733:   When a new node gets bound to the tree, the BindToTree function gets called.
123733:   The reverse case is UnbindFromTree.
123733:   When the contents of a text node change, nsGenericDOMDataNode::SetTextInternal
123733:   gets called.
123733:   */
123733: 
108036: #include "mozilla/dom/DirectionalityUtils.h"
108036: #include "nsINode.h"
108036: #include "nsIContent.h"
108036: #include "nsIDocument.h"
108036: #include "mozilla/dom/Element.h"
108036: #include "nsIDOMHTMLDocument.h"
123733: #include "nsUnicodeProperties.h"
123733: #include "nsTextFragment.h"
123733: #include "nsAttrValue.h"
123733: #include "nsContentUtils.h"
123733: #include "nsTextNode.h"
123733: #include "nsCheapSets.h"
108036: 
108036: namespace mozilla {
108036: 
123733: typedef mozilla::dom::Element Element;
123650: 
123733: /**
123733:  * Returns true if aNode is one of the elements whose text content should not
123733:  * affect its own direction, nor the direction of ancestors with dir=auto.
123733:  *
123733:  * Note that this does not include <bdi>, whose content does affect its own
123733:  * direction when it has dir=auto (which it has by default), so one needs to
123733:  * test for it separately.
123733:  * It *does* include textarea, because even if a textarea has dir=auto, it has
123733:  * unicode-bidi: plaintext and is handled automatically in bidi resolution.
123733:  */
123733: static bool
123733: DoesNotParticipateInAutoDirection(const Element* aElement)
123733: {
123733:   nsINodeInfo* nodeInfo = aElement->NodeInfo();
123733:   return (aElement->IsHTML() &&
123733:           (nodeInfo->Equals(nsGkAtoms::script) ||
123733:            nodeInfo->Equals(nsGkAtoms::style) ||
123733:            nodeInfo->Equals(nsGkAtoms::textarea)));
123733: }
123733: 
123733: /**
123733:  * Returns the directionality of a Unicode character
123733:  */
123733: static Directionality
123733: GetDirectionFromChar(uint32_t ch)
123733: {
123733:   switch(mozilla::unicode::GetBidiCat(ch)) {
123733:     case eCharType_RightToLeft:
123733:     case eCharType_RightToLeftArabic:
123733:       return eDir_RTL;
123733: 
123733:     case eCharType_LeftToRight:
123733:       return eDir_LTR;
123733: 
123733:     default:
123733:       return eDir_NotSet;
123733:   }
123733: }
123733: 
123733: inline static bool NodeAffectsDirAutoAncestor(nsINode* aTextNode)
123733: {
123733:   Element* parent = aTextNode->GetElementParent();
123733:   return (parent &&
123733:           !DoesNotParticipateInAutoDirection(parent) &&
123733:           parent->NodeOrAncestorHasDirAuto());
123733: }
123733: 
123733: /**
123733:  * Various methods for returning the directionality of a string using the
123733:  * first-strong algorithm defined in http://unicode.org/reports/tr9/#P2
123733:  *
123733:  * @param[out] aFirstStrong the offset to the first character in the string with
125518:  *             strong directionality, or UINT32_MAX if there is none (return
123733:                value is eDir_NotSet).
123733:  * @return the directionality of the string
123733:  */
123733: static Directionality
123733: GetDirectionFromText(const PRUnichar* aText, const uint32_t aLength,
123733:                      uint32_t* aFirstStrong = nullptr)
123733: {
123733:   const PRUnichar* start = aText;
123733:   const PRUnichar* end = aText + aLength;
123733: 
123733:   while (start < end) {
123733:     uint32_t current = start - aText;
123733:     uint32_t ch = *start++;
123733: 
123733:     if (NS_IS_HIGH_SURROGATE(ch) &&
123733:         start < end &&
123733:         NS_IS_LOW_SURROGATE(*start)) {
123733:       ch = SURROGATE_TO_UCS4(ch, *start++);
123733:     }
123733: 
123733:     Directionality dir = GetDirectionFromChar(ch);
123733:     if (dir != eDir_NotSet) {
123733:       if (aFirstStrong) {
123733:         *aFirstStrong = current;
123733:       }
123733:       return dir;
123733:     }
123733:   }
123733: 
123733:   if (aFirstStrong) {
125518:     *aFirstStrong = UINT32_MAX;
123733:   }
123733:   return eDir_NotSet;
123733: }
123733: 
123733: static Directionality
123733: GetDirectionFromText(const char* aText, const uint32_t aLength,
123733:                         uint32_t* aFirstStrong = nullptr)
123733: {
123733:   const char* start = aText;
123733:   const char* end = aText + aLength;
123733: 
123733:   while (start < end) {
123733:     uint32_t current = start - aText;
123733:     unsigned char ch = (unsigned char)*start++;
123733: 
123733:     Directionality dir = GetDirectionFromChar(ch);
123733:     if (dir != eDir_NotSet) {
123733:       if (aFirstStrong) {
123733:         *aFirstStrong = current;
123733:       }
123733:       return dir;
123733:     }
123733:   }
123733: 
123733:   if (aFirstStrong) {
125518:     *aFirstStrong = UINT32_MAX;
123733:   }
123733:   return eDir_NotSet;
123733: }
123733: 
123733: static Directionality
123733: GetDirectionFromText(const nsTextFragment* aFrag,
123733:                      uint32_t* aFirstStrong = nullptr)
123733: {
123733:   if (aFrag->Is2b()) {
123733:     return GetDirectionFromText(aFrag->Get2b(), aFrag->GetLength(),
123733:                                    aFirstStrong);
123733:   }
123733: 
123733:   return GetDirectionFromText(aFrag->Get1b(), aFrag->GetLength(),
123733:                                  aFirstStrong);
123733: }
123733: 
123733: /**
123733:  * Set the directionality of a node with dir=auto as defined in
123733:  * http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#the-directionality
123733:  *
123733:  * @param[in] aStartAfterNode as an optimization, a caller may pass in a node
123733:  *            from which to begin walking the descendants of aElement, if it is
123733:  *            known that all text nodes before this node do not contain any
123733:  *            strong directional characters
123733:  * @return the text node containing the character that determined the direction
123733:  */
123733: static nsINode*
123733: WalkDescendantsSetDirectionFromText(Element* aElement, bool aNotify = true,
123733:                                        nsINode* aStartAfterNode = nullptr)
123733: {
123733:   MOZ_ASSERT(aElement, "aElement is null");
126799:   if (DoesNotParticipateInAutoDirection(aElement)) {
126799:     return nullptr;
126799:   }
123733: 
123733:   nsIContent* child;
123733:   if (aStartAfterNode &&
123733:       nsContentUtils::ContentIsDescendantOf(aStartAfterNode, aElement)) {
126798:     nsIContent* firstNode = aStartAfterNode->GetNextNode(aElement);
126798: 
123733: #ifdef DEBUG
126798:     // In debug builds, assert that aStartAfterNode is correctly set by checking
126798:     // that text node descendants of elements up to aStartAfterNode don't have
126798:     // any strong directional characters
123733:     child = aElement->GetFirstChild();
126798:     while (child && child != firstNode) {
126798:       // Skip over nodes whose text node descendants don't affect directionality
126798:       // of their ancestors
126798:       if (child->IsElement() &&
126798:           (DoesNotParticipateInAutoDirection(child->AsElement()) ||
126798:            child->NodeInfo()->Equals(nsGkAtoms::bdi) ||
126798:            child->HasFixedDir())) {
126798:         child = child->GetNextNonChildNode(aElement);
126798:         continue;
126798:       }
126798: 
123733:       if (child->NodeType() == nsIDOMNode::TEXT_NODE) {
123733:         MOZ_ASSERT(GetDirectionFromText(child->GetText()) == eDir_NotSet,
123733:                    "Strong directional characters before aStartAfterNode");
123733:       }
123733:       child = child->GetNextNode(aElement);
123733:     }
126798: #else
126798:     child = firstNode;
123733: #endif
123733:   } else {
123733:     child = aElement->GetFirstChild();
123733:   }
123733: 
123733:   while (child) {
123733:     if (child->IsElement() &&
123733:         (DoesNotParticipateInAutoDirection(child->AsElement()) ||
123733:          child->NodeInfo()->Equals(nsGkAtoms::bdi) ||
123733:          child->HasFixedDir())) {
123733:       child = child->GetNextNonChildNode(aElement);
123733:       continue;
123733:     }
123733: 
123733:     if (child->NodeType() == nsIDOMNode::TEXT_NODE) {
123733:       Directionality textNodeDir = GetDirectionFromText(child->GetText());
123733:       if (textNodeDir != eDir_NotSet) {
123733:         // We found a descendant text node with strong directional characters.
123733:         // Set the directionality of aElement to the corresponding value.
123733:         aElement->SetDirectionality(textNodeDir, aNotify);
123733:         return child;
123733:       }
123733:     }
123733:     child = child->GetNextNode(aElement);
123733:   }
123733: 
123733:   // We walked all the descendants without finding a text node with strong
123733:   // directional characters. Set the directionality to LTR
123733:   aElement->SetDirectionality(eDir_LTR, aNotify);
123733:   return nullptr;
123733: }
123733: 
123733: class nsTextNodeDirectionalityMap
123733: {
123733:   static void
123733:   nsTextNodeDirectionalityMapDtor(void *aObject, nsIAtom* aPropertyName,
123733:                                   void *aPropertyValue, void* aData)
123733:   {
127652:     nsINode* textNode = static_cast<nsINode * >(aObject);
127652:     textNode->ClearHasTextNodeDirectionalityMap();
127652: 
123733:     nsTextNodeDirectionalityMap* map =
123733:       reinterpret_cast<nsTextNodeDirectionalityMap * >(aPropertyValue);
123733:     delete map;
123733:   }
123733: 
123733: public:
123733:   nsTextNodeDirectionalityMap(nsINode* aTextNode)
123733:   {
123733:     MOZ_ASSERT(aTextNode, "Null text node");
123733:     MOZ_COUNT_CTOR(nsTextNodeDirectionalityMap);
123733:     aTextNode->SetProperty(nsGkAtoms::textNodeDirectionalityMap, this,
123733:                            nsTextNodeDirectionalityMapDtor);
123733:     aTextNode->SetHasTextNodeDirectionalityMap();
123733:   }
123733: 
123733:   ~nsTextNodeDirectionalityMap()
123733:   {
123733:     MOZ_COUNT_DTOR(nsTextNodeDirectionalityMap);
123733:   }
123733: 
123733:   void AddEntry(nsINode* aTextNode, Element* aElement)
123733:   {
123733:     if (!mElements.Contains(aElement)) {
123733:       mElements.Put(aElement);
123733:       aElement->SetProperty(nsGkAtoms::dirAutoSetBy, aTextNode);
123733:       aElement->SetHasDirAutoSet();
123733:     }
123733:   }
123733: 
123733:   void RemoveEntry(nsINode* aTextNode, Element* aElement)
123733:   {
123733:     if (mElements.Contains(aElement)) {
123733:       mElements.Remove(aElement);
123733: 
123733:       aElement->ClearHasDirAutoSet();
123733:       aElement->UnsetProperty(nsGkAtoms::dirAutoSetBy);
123733:     }
123733:   }
123733: 
123733: private:
123733:   nsCheapSet<nsPtrHashKey<Element> > mElements;
123733: 
123733:   static nsTextNodeDirectionalityMap* GetDirectionalityMap(nsINode* aTextNode)
123733:   {
123733:     MOZ_ASSERT(aTextNode->NodeType() == nsIDOMNode::TEXT_NODE,
123733:                "Must be a text node");
123733:     nsTextNodeDirectionalityMap* map = nullptr;
123733: 
123733:     if (aTextNode->HasTextNodeDirectionalityMap()) {
123733:       map = static_cast<nsTextNodeDirectionalityMap * >
123733:         (aTextNode->GetProperty(nsGkAtoms::textNodeDirectionalityMap));
123733:     }
123733: 
123733:     return map;
123733:   }
123733: 
123733:   static PLDHashOperator SetNodeDirection(nsPtrHashKey<Element>* aEntry, void* aDir)
123733:   {
123733:     MOZ_ASSERT(aEntry->GetKey()->IsElement(), "Must be an Element");
123733:     aEntry->GetKey()->SetDirectionality(*reinterpret_cast<Directionality*>(aDir),
123733:                                         true);
123733:     return PL_DHASH_NEXT;
123733:   }
123733: 
123733:   static PLDHashOperator ResetNodeDirection(nsPtrHashKey<Element>* aEntry, void* aData)
123733:   {
123733:     MOZ_ASSERT(aEntry->GetKey()->IsElement(), "Must be an Element");
123733:     // run the downward propagation algorithm
123733:     // and remove the text node from the map
123733:     nsINode* startAfterNode = static_cast<Element*>(aData);
123733:     Element* rootNode = aEntry->GetKey();
123733:     nsINode* textNode = WalkDescendantsSetDirectionFromText(rootNode, true,
123733:                                                             startAfterNode);
123733:     if (textNode) {
123733:       nsTextNodeDirectionalityMap::AddEntryToMap(textNode, rootNode);
126053:     } else {
126053:       rootNode->ClearHasDirAutoSet();
126053:       rootNode->UnsetProperty(nsGkAtoms::dirAutoSetBy);
123733:     }
123733:     return PL_DHASH_REMOVE;
123733:   }
123733: 
123733: public:
123733:   void UpdateAutoDirection(Directionality aDir)
123733:   {
123733:     mElements.EnumerateEntries(SetNodeDirection, &aDir);
123733:   }
123733: 
123733:   void ResetAutoDirection(nsINode* aTextNode, nsINode* aStartAfterNode)
123733:   {
123733:     mElements.EnumerateEntries(ResetNodeDirection, aStartAfterNode);
123733:   }
123733: 
123733:   static void RemoveElementFromMap(nsINode* aTextNode, Element* aElement)
123733:   {
123733:     if (aTextNode->HasTextNodeDirectionalityMap()) {
123733:       GetDirectionalityMap(aTextNode)->RemoveEntry(aTextNode, aElement);
123733:     }
123733:   }
123733: 
123733:   static void AddEntryToMap(nsINode* aTextNode, Element* aElement)
123733:   {
123733:     nsTextNodeDirectionalityMap* map = GetDirectionalityMap(aTextNode);
123733:     if (!map) {
123733:       map = new nsTextNodeDirectionalityMap(aTextNode);
123733:     }
123733: 
123733:     map->AddEntry(aTextNode, aElement);
123733:   }
123733: 
123733:   static void UpdateTextNodeDirection(nsINode* aTextNode, Directionality aDir)
123733:   {
123733:     MOZ_ASSERT(aTextNode->HasTextNodeDirectionalityMap(),
123733:                "Map missing in UpdateTextNodeDirection");
123733:     GetDirectionalityMap(aTextNode)->UpdateAutoDirection(aDir);
123733:   }
123733: 
123733:   static void ResetTextNodeDirection(nsINode* aTextNode,
123733:                                      nsINode* aStartAfterNode = nullptr)
123733:   {
123733:     MOZ_ASSERT(aTextNode->HasTextNodeDirectionalityMap(),
123733:                "Map missing in ResetTextNodeDirection");
123733:     GetDirectionalityMap(aTextNode)->ResetAutoDirection(aTextNode,
123733:                                                         aStartAfterNode);
123733:   }
123733: };
108036: 
108036: Directionality
108036: RecomputeDirectionality(Element* aElement, bool aNotify)
108036: {
123733:   MOZ_ASSERT(!aElement->HasDirAuto(),
123733:              "RecomputeDirectionality called with dir=auto");
123733:   if (aElement->HasDirAutoSet()) {
123733:     nsINode* setByNode =
123733:       static_cast<nsINode*>(aElement->GetProperty(nsGkAtoms::dirAutoSetBy));
123733:     if (setByNode) {
123733:       nsTextNodeDirectionalityMap::RemoveElementFromMap(setByNode, aElement);
123733:     }
123733:   }
123733: 
108036:   Directionality dir = eDir_LTR;
108036: 
108036:   if (aElement->HasValidDir()) {
108036:     dir = aElement->GetDirectionality();
108036:   } else {
108036:     Element* parent = aElement->GetElementParent();
108036:     if (parent) {
108036:       // If the element doesn't have an explicit dir attribute with a valid
108036:       // value, the directionality is the same as the parent element (but
108036:       // don't propagate the parent directionality if it isn't set yet).
108036:       Directionality parentDir = parent->GetDirectionality();
108036:       if (parentDir != eDir_NotSet) {
108036:         dir = parentDir;
108036:       }
108036:     } else {
108036:       // If there is no parent element, the directionality is the same as the
108036:       // document direction.
108036:       Directionality documentDir =
108036:         aElement->OwnerDoc()->GetDocumentDirectionality();
108036:       if (documentDir != eDir_NotSet) {
108036:         dir = documentDir;
108036:       }
108036:     }
108036: 
108036:     aElement->SetDirectionality(dir, aNotify);
108036:   }
108036:   return dir;
108036: }
108036: 
108036: void
108036: SetDirectionalityOnDescendants(Element* aElement, Directionality aDir,
108036:                                bool aNotify)
108036: {
108036:   for (nsIContent* child = aElement->GetFirstChild(); child; ) {
108036:     if (!child->IsElement()) {
108036:       child = child->GetNextNode(aElement);
108036:       continue;
108036:     }
108036: 
108036:     Element* element = child->AsElement();
123733:     if (element->HasValidDir() || element->HasDirAuto()) {
108036:       child = child->GetNextNonChildNode(aElement);
108036:       continue;
108036:     }
108036:     element->SetDirectionality(aDir, aNotify);
108036:     child = child->GetNextNode(aElement);
108036:   }
108036: }
108036: 
123733: void
123733: WalkAncestorsResetAutoDirection(Element* aElement, bool aNotify)
123733: {
123733:   nsINode* setByNode;
123733:   Element* parent = aElement->GetElementParent();
123733: 
123733:   while (parent && parent->NodeOrAncestorHasDirAuto()) {
123733:     if (parent->HasDirAutoSet()) {
123733:       // If the parent has the DirAutoSet flag, its direction is determined by
123733:       // some text node descendant.
123733:       // Remove it from the map and reset its direction by the downward
123733:       // propagation algorithm
123733:       setByNode =
123733:         static_cast<nsINode*>(parent->GetProperty(nsGkAtoms::dirAutoSetBy));
123733:       if (setByNode) {
123733:         nsTextNodeDirectionalityMap::RemoveElementFromMap(setByNode, parent);
123733:       }
123733:     }
123733:     if (parent->HasDirAuto()) {
123733:       setByNode = WalkDescendantsSetDirectionFromText(parent, aNotify);
123733:       if (setByNode) {
123733:         nsTextNodeDirectionalityMap::AddEntryToMap(setByNode, parent);
123733:       }
123733:       break;
123733:     }
123733:     parent = parent->GetElementParent();
123733:   }
123733: }
123733: 
123733: void
123733: WalkDescendantsResetAutoDirection(Element* aElement)
123733: {
123733:   nsIContent* child = aElement->GetFirstChild();
123733:   while (child) {
123733:     if (child->HasDirAuto()) {
123733:       child = child->GetNextNonChildNode(aElement);
123733:       continue;
123733:     }
123733: 
123733:     if (child->HasTextNodeDirectionalityMap()) {
123733:       nsTextNodeDirectionalityMap::ResetTextNodeDirection(child, child);
123733:     }
123733:     child = child->GetNextNode(aElement);
123733:   }
123733: }
123733: 
123733: void
123733: WalkDescendantsSetDirAuto(Element* aElement, bool aNotify)
123733: {
123733:   bool setAncestorDirAutoFlag =
123733: #ifdef DEBUG
123733:     true;
123733: #else
123733:     !aElement->AncestorHasDirAuto();
123733: #endif
123733: 
123733:   if (setAncestorDirAutoFlag) {
123733:     nsIContent* child = aElement->GetFirstChild();
123733:     while (child) {
123733:       MOZ_ASSERT(!aElement->AncestorHasDirAuto() ||
123733:                  child->AncestorHasDirAuto(),
123733:                  "AncestorHasDirAuto set on node but not its children");
123733:       child->SetHasDirAuto();
123733:       child = child->GetNextNode(aElement);
123733:     }
123733:   }
123733: 
123733:   nsINode* textNode = WalkDescendantsSetDirectionFromText(aElement, aNotify);
123733:   if (textNode) {
123733:     nsTextNodeDirectionalityMap::AddEntryToMap(textNode, aElement);
123733:   }
123733: }
123733: 
123733: void
123733: WalkDescendantsClearAncestorDirAuto(Element* aElement)
123733: {
123733:   nsIContent* child = aElement->GetFirstChild();
123733:   while (child) {
123733:     if (child->HasDirAuto()) {
123733:       child = child->GetNextNonChildNode(aElement);
123733:       continue;
123733:     }
123733: 
123733:     child->ClearAncestorHasDirAuto();
123733:     child = child->GetNextNode(aElement);
123733:   }
123733: }
123733: 
123733: void SetAncestorDirectionIfAuto(nsINode* aTextNode, Directionality aDir,
123733:                                 bool aNotify = true)
123733: {
123733:   MOZ_ASSERT(aTextNode->NodeType() == nsIDOMNode::TEXT_NODE,
123733:              "Must be a text node");
123733: 
123733:   Element* parent = aTextNode->GetElementParent();
123733:   while (parent && parent->NodeOrAncestorHasDirAuto()) {
123733:     if (DoesNotParticipateInAutoDirection(parent) || parent->HasFixedDir()) {
123733:       break;
123733:     }
123733: 
123733:     if (parent->HasDirAuto()) {
123733:       bool resetDirection = false;
123733: 
123733:       if (!parent->HasDirAutoSet()) {
123733:         // Fast path if parent's direction is not yet set by any descendant
123733:         resetDirection = true;
123733:       } else {
123733:         // If parent's direction is already set, we need to know if
123733:         // aTextNode is before or after the text node that had set it.
123733:         // We will walk parent's descendants in tree order starting from
123733:         // aTextNode to optimize for the most common case where text nodes are
123733:         // being appended to tree.
123733:         nsINode* directionWasSetByTextNode =
123733:           static_cast<nsINode*>(parent->GetProperty(nsGkAtoms::dirAutoSetBy));
123733:         if (!directionWasSetByTextNode) {
123733:           resetDirection = true;
123733:         } else if (directionWasSetByTextNode != aTextNode) {
123733:           nsIContent* child = aTextNode->GetNextNode(parent);
123733:           while (child) {
123733:             if (child->IsElement() &&
123733:                 (DoesNotParticipateInAutoDirection(child->AsElement()) ||
123733:                  child->NodeInfo()->Equals(nsGkAtoms::bdi) ||
123733:                  child->HasFixedDir())) {
123733:               child = child->GetNextNonChildNode(parent);
123733:               continue;
123733:             }
123733: 
123733:             if (child == directionWasSetByTextNode) {
123733:               // we found the node that set the element's direction after our
123733:               // text node, so we need to reset the direction
123733:               resetDirection = true;
125328:               nsTextNodeDirectionalityMap::RemoveElementFromMap(
125328:                 directionWasSetByTextNode, parent
125328:               );
123733:               break;
123733:             }
123733: 
123733:             child = child->GetNextNode(parent);
123733:           }
123733:         }
123733:       }
123733: 
123733:       if (resetDirection) {
123733:         parent->SetDirectionality(aDir, aNotify);
123733:         nsTextNodeDirectionalityMap::AddEntryToMap(aTextNode, parent);
123733:         SetDirectionalityOnDescendants(parent, aDir, aNotify);
123733:       }
123733: 
123733:       // Since we found an element with dir=auto, we can stop walking the
123733:       // parent chain: none of its ancestors will have their direction set by
123733:       // any of its descendants.
123733:       return;
123733:     }
123733:     parent = parent->GetElementParent();
123733:   }
123733: }
123733: 
123733: void
123733: SetDirectionFromChangedTextNode(nsIContent* aTextNode, uint32_t aOffset,
123733:                                 const PRUnichar* aBuffer, uint32_t aLength,
123733:                                 bool aNotify)
123733: {
123733:   if (!NodeAffectsDirAutoAncestor(aTextNode)) {
123733:     return;
123733:   }
123733: 
123733:   uint32_t firstStrong;
123733:   Directionality oldDir = GetDirectionFromText(aTextNode->GetText(),
123733:                                                &firstStrong);
123733:   if (aOffset > firstStrong) {
123733:     return;
123733:   }
123733: 
123733:   Directionality newDir = GetDirectionFromText(aBuffer, aLength);
123733:   if (newDir == eDir_NotSet) {
123733:     if (oldDir != eDir_NotSet && aTextNode->HasTextNodeDirectionalityMap()) {
123733:       // This node used to have a strong directional character but no
123733:       // longer does. ResetTextNodeDirection() will re-resolve the
123733:       // directionality of any elements whose directionality was
123733:       // determined by this node.
123733:       nsTextNodeDirectionalityMap::ResetTextNodeDirection(aTextNode);
123733:     }
123733:   } else {
123733:     // This node has a strong directional character. If it has a
123733:     // TextNodeDirectionalityMap property, it already determines the
123733:     // directionality of some element(s), so call UpdateTextNodeDirection to
123733:     // reresolve their directionality. Otherwise call
123733:     // SetAncestorDirectionIfAuto to find ancestor elements which should
123733:     // have their directionality determined by this node.
123733:     if (aTextNode->HasTextNodeDirectionalityMap()) {
123733:       nsTextNodeDirectionalityMap::UpdateTextNodeDirection(aTextNode, newDir);
123733:     } else {
123733:       SetAncestorDirectionIfAuto(aTextNode, newDir, aNotify);
123733:     }
123733:   }
123733: }
123733: 
123733: void
123733: SetDirectionFromNewTextNode(nsTextNode* aTextNode)
123733: {
123733:   if (!NodeAffectsDirAutoAncestor(aTextNode)) {
123733:     return;
123733:   }
123733: 
123733:   Directionality dir = GetDirectionFromText(aTextNode->GetText());
123733:   if (dir != eDir_NotSet) {
123733:     SetAncestorDirectionIfAuto(aTextNode, dir);
123733:   }
123733: }
123733: 
123733: void
123733: ResetDirectionSetByTextNode(nsTextNode* aTextNode)
123733: {
123733:   if (!NodeAffectsDirAutoAncestor(aTextNode)) {
123733:     return;
123733:   }
123733: 
123733:   Directionality dir = GetDirectionFromText(aTextNode->GetText());
123733:   if (dir != eDir_NotSet && aTextNode->HasTextNodeDirectionalityMap()) {
123733:     nsTextNodeDirectionalityMap::ResetTextNodeDirection(aTextNode);
123733:   }
123733: }
123733: 
123733: void
123733: SetDirectionalityFromValue(Element* aElement, const nsAString& value,
123733:                            bool aNotify)
123733: {
123733:   Directionality dir = GetDirectionFromText(PromiseFlatString(value).get(),
123733:                                             value.Length());
123733:   if (dir == eDir_NotSet) {
123733:     dir = eDir_LTR;
123733:   }
123733: 
123733:   aElement->SetDirectionality(dir, aNotify);
123733: }
123733: 
123733: void
123733: OnSetDirAttr(Element* aElement, const nsAttrValue* aNewValue,
123733:              bool hadValidDir, bool aNotify)
123733: {
123733:   if (aElement->IsHTML() && aElement->NodeInfo()->Equals(nsGkAtoms::input)) {
123733:     return;
123733:   }
123733: 
123733:   if (aElement->AncestorHasDirAuto()) {
123733:     if (!hadValidDir) {
123733:       // The element is a descendant of an element with dir = auto, is
123733:       // having its dir attribute set, and previously didn't have a valid dir
123733:       // attribute.
123733:       // Check whether any of its text node descendants determine the
123733:       // direction of any of its ancestors, and redetermine their direction
123733:       WalkDescendantsResetAutoDirection(aElement);
123733:     } else if (!aElement->HasValidDir()) {
123733:       // The element is a descendant of an element with dir = auto and is
123733:       // having its dir attribute removed or set to an invalid value.
123733:       // Reset the direction of any of its ancestors whose direction is
123733:       // determined by a text node descendant
123733:       WalkAncestorsResetAutoDirection(aElement, aNotify);
123733:     }
123733:   }
123733: 
123733:   if (aElement->HasDirAuto()) {
123733:     WalkDescendantsSetDirAuto(aElement, aNotify);
123733:   } else {
123733:     SetDirectionalityOnDescendants(aElement,
123733:                                    RecomputeDirectionality(aElement, aNotify),
123733:                                    aNotify);
123733:   }
123733: }
108036: 
108036: } // end namespace mozilla
108036: 
