 69827: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 69827:  * vim: set ts=8 sw=4 et tw=78:
 69827:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 69827: 
 69827: #ifndef ArgumentsObject_inl_h___
 69827: #define ArgumentsObject_inl_h___
 69827: 
 69827: #include "ArgumentsObject.h"
 69827: 
100006: namespace js {
 99994: 
100006: inline void
100006: ArgumentsObject::initInitialLength(uint32_t length)
100006: {
100006:     JS_ASSERT(getFixedSlot(INITIAL_LENGTH_SLOT).isUndefined());
100006:     initFixedSlot(INITIAL_LENGTH_SLOT, Int32Value(length << PACKED_BITS_COUNT));
100006:     JS_ASSERT((getFixedSlot(INITIAL_LENGTH_SLOT).toInt32() >> PACKED_BITS_COUNT) == int32_t(length));
100006:     JS_ASSERT(!hasOverriddenLength());
100006: }
 69827: 
 84755: inline uint32_t
 69827: ArgumentsObject::initialLength() const
 69827: {
 84755:     uint32_t argc = uint32_t(getFixedSlot(INITIAL_LENGTH_SLOT).toInt32()) >> PACKED_BITS_COUNT;
 73495:     JS_ASSERT(argc <= StackSpace::ARGS_LENGTH_MAX);
 69827:     return argc;
 69827: }
 69827: 
 69827: inline void
 69827: ArgumentsObject::markLengthOverridden()
 69827: {
 84755:     uint32_t v = getFixedSlot(INITIAL_LENGTH_SLOT).toInt32() | LENGTH_OVERRIDDEN_BIT;
 83309:     setFixedSlot(INITIAL_LENGTH_SLOT, Int32Value(v));
 69827: }
 69827: 
 69827: inline bool
 69827: ArgumentsObject::hasOverriddenLength() const
 69827: {
100006:     const js::Value &v = getFixedSlot(INITIAL_LENGTH_SLOT);
 69827:     return v.toInt32() & LENGTH_OVERRIDDEN_BIT;
 69827: }
 69827: 
100006: inline void
100006: ArgumentsObject::initData(ArgumentsData *data)
100006: {
100006:     JS_ASSERT(getFixedSlot(DATA_SLOT).isUndefined());
100006:     initFixedSlot(DATA_SLOT, PrivateValue(data));
100006: }
100006: 
 69827: inline ArgumentsData *
 69827: ArgumentsObject::data() const
 69827: {
100006:     return reinterpret_cast<js::ArgumentsData *>(getFixedSlot(DATA_SLOT).toPrivate());
 69827: }
 69827: 
 93646: inline bool
 93646: ArgumentsObject::isElementDeleted(uint32_t i) const
 93646: {
 93646:     return IsBitArrayElementSet(data()->deletedBits, initialLength(), i);
 93646: }
 93646: 
 93646: inline bool
 93646: ArgumentsObject::isAnyElementDeleted() const
 93646: {
 93646:     return IsAnyBitArrayElementSet(data()->deletedBits, initialLength());
 93646: }
 93646: 
 93646: inline void
 93646: ArgumentsObject::markElementDeleted(uint32_t i)
 93646: {
 93646:     SetBitArrayElement(data()->deletedBits, initialLength(), i);
 93646: }
 93646: 
100006: inline const js::Value &
100006: ArgumentsObject::element(uint32_t i) const
100006: {
100006:     JS_ASSERT(!isElementDeleted(i));
100006:     return data()->slots[i];
100006: }
100006: 
100006: inline void
100006: ArgumentsObject::setElement(uint32_t i, const js::Value &v)
100006: {
100006:     JS_ASSERT(!isElementDeleted(i));
100006:     data()->slots[i] = v;
100006: }
100006: 
 89722: inline bool
100006: ArgumentsObject::getElement(uint32_t i, Value *vp)
 89722: {
 93646:     if (i >= initialLength() || isElementDeleted(i))
 89722:         return false;
100006: 
100006:     /*
100006:      * If this arguments object has an associated stack frame, that contains
100006:      * the canonical argument value.  Note that strict arguments objects do not
100006:      * alias named arguments and never have a stack frame.
100006:      */
100006:     StackFrame *fp = maybeStackFrame();
100006:     JS_ASSERT_IF(isStrictArguments(), !fp);
100006:     if (fp)
100006:         *vp = fp->canonicalActualArg(i);
100006:     else
 93646:         *vp = element(i);
 89722:     return true;
 89722: }
 89722: 
100006: namespace detail {
100006: 
100006: struct STATIC_SKIP_INFERENCE CopyNonHoleArgsTo
100006: {
100006:     CopyNonHoleArgsTo(ArgumentsObject *argsobj, Value *dst) : argsobj(*argsobj), dst(dst) {}
100006:     ArgumentsObject &argsobj;
100006:     Value *dst;
100006:     bool operator()(uint32_t argi, Value *src) {
100006:         *dst++ = *src;
100006:         return true;
100006:     }
100006: };
100006: 
100006: } /* namespace detail */
100006: 
 89722: inline bool
100006: ArgumentsObject::getElements(uint32_t start, uint32_t count, Value *vp)
 89722: {
 89722:     JS_ASSERT(start + count >= start);
 89722: 
 89722:     uint32_t length = initialLength();
 93646:     if (start > length || start + count > length || isAnyElementDeleted())
 89722:         return false;
 89722: 
100006:     StackFrame *fp = maybeStackFrame();
100006: 
100006:     /* If there's no stack frame for this, argument values are in elements(). */
100006:     if (!fp) {
100006:         const Value *srcbeg = Valueify(data()->slots) + start;
100006:         const Value *srcend = srcbeg + count;
100006:         const Value *src = srcbeg;
100006:         for (Value *dst = vp; src < srcend; ++dst, ++src)
100006:             *dst = *src;
 89722:         return true;
 89722:     }
 89722: 
100006:     /* Otherwise, element values are on the stack. */
100006:     JS_ASSERT(fp->numActualArgs() <= StackSpace::ARGS_LENGTH_MAX);
100006:     return fp->forEachCanonicalActualArg(detail::CopyNonHoleArgsTo(this, vp), start, count);
100006: }
100006: 
100006: inline js::StackFrame *
100006: ArgumentsObject::maybeStackFrame() const
100006: {
100006:     return reinterpret_cast<js::StackFrame *>(getFixedSlot(STACK_FRAME_SLOT).toPrivate());
100006: }
100006: 
100006: inline void
100006: ArgumentsObject::setStackFrame(StackFrame *frame)
100006: {
100006:     setFixedSlot(STACK_FRAME_SLOT, PrivateValue(frame));
100006: }
100006: 
 89497: inline size_t
 89497: ArgumentsObject::sizeOfMisc(JSMallocSizeOfFun mallocSizeOf) const
 89497: {
 89497:     return mallocSizeOf(data());
 89497: }
 89497: 
100006: inline const js::Value &
 69827: NormalArgumentsObject::callee() const
 69827: {
 69827:     return data()->callee;
 69827: }
 69827: 
 69827: inline void
 69827: NormalArgumentsObject::clearCallee()
 69827: {
 93646:     data()->callee.set(compartment(), MagicValue(JS_OVERWRITTEN_CALLEE));
 69827: }
 69827: 
100006: } // namespace js
 69827: 
 69827: #endif /* ArgumentsObject_inl_h___ */
