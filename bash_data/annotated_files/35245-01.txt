11914: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
11914: /* vim: set ts=2 sw=2 et tw=80: */
11914: /* ***** BEGIN LICENSE BLOCK *****
11914:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
11914:  *
11914:  * The contents of this file are subject to the Mozilla Public License Version
11914:  * 1.1 (the "License"); you may not use this file except in compliance with
11914:  * the License. You may obtain a copy of the License at
11914:  * http://www.mozilla.org/MPL/
11914:  *
11914:  * Software distributed under the License is distributed on an "AS IS" basis,
11914:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
11914:  * for the specific language governing rights and limitations under the
11914:  * License.
11914:  *
11914:  * The Original Code is mozilla.org code.
11914:  *
11914:  * The Initial Developer of the Original Code is
11914:  * Mozilla Japan.
11914:  * Portions created by the Initial Developer are Copyright (C) 2008
11914:  * the Initial Developer. All Rights Reserved.
11914:  *
11914:  * Contributor(s):
11914:  *   Masayuki Nakano <masayuki@d-toybox.com>
24836:  *   Ningjie Chen <chenn@email.uc.edu>
11914:  *
11914:  * Alternatively, the contents of this file may be used under the terms of
11914:  * either of the GNU General Public License Version 2 or later (the "GPL"),
11914:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
11914:  * in which case the provisions of the GPL or the LGPL are applicable instead
11914:  * of those above. If you wish to allow use of your version of this file only
11914:  * under the terms of either the GPL or the LGPL, and not to allow others to
11914:  * use your version of this file under the terms of the MPL, indicate your
11914:  * decision by deleting the provisions above and replace them with the notice
11914:  * and other provisions required by the GPL or the LGPL. If you do not delete
11914:  * the provisions above, a recipient may use your version of this file under
11914:  * the terms of any one of the MPL, the GPL or the LGPL.
11914:  *
11914:  * ***** END LICENSE BLOCK ***** */
11914: 
24836: #include "nsContentEventHandler.h"
11914: #include "nsCOMPtr.h"
11914: #include "nsPresContext.h"
11914: #include "nsIPresShell.h"
11914: #include "nsISelection.h"
11914: #include "nsIDOMText.h"
11914: #include "nsIDOMRange.h"
11914: #include "nsRange.h"
11914: #include "nsGUIEvent.h"
15969: #include "nsCaret.h"
26757: #include "nsCopySupport.h"
11914: #include "nsFrameSelection.h"
11914: #include "nsIFrame.h"
11914: #include "nsIView.h"
11914: #include "nsIContentIterator.h"
11914: #include "nsTextFragment.h"
11914: #include "nsTextFrame.h"
24836: #include "nsISelectionController.h"
24836: #include "nsISelectionPrivate.h"
24836: #include "nsContentUtils.h"
28352: #include "nsLayoutUtils.h"
24836: #include "nsISelection2.h"
24836: #include "nsIMEStateManager.h"
11914: 
11914: nsresult NS_NewContentIterator(nsIContentIterator** aInstancePtrResult);
11914: 
11914: /******************************************************************/
24836: /* nsContentEventHandler                                          */
11914: /******************************************************************/
11914: 
24836: nsContentEventHandler::nsContentEventHandler(
11914:                               nsPresContext* aPresContext) :
11914:   mPresContext(aPresContext),
11914:   mPresShell(aPresContext->GetPresShell()), mSelection(nsnull),
11914:   mFirstSelectedRange(nsnull), mRootContent(nsnull)
11914: {
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::Init(nsQueryContentEvent* aEvent)
11914: {
11914:   NS_ASSERTION(aEvent, "aEvent must not be null");
11914: 
11914:   if (mSelection)
11914:     return NS_OK;
11914: 
11914:   aEvent->mSucceeded = PR_FALSE;
11914: 
11914:   if (!mPresShell)
11914:     return NS_ERROR_NOT_AVAILABLE;
11914: 
26883:   // If text frame which has overflowing selection underline is dirty,
26883:   // we need to flush the pending reflow here.
26883:   nsresult rv = mPresShell->FlushPendingNotifications(Flush_Layout);
26883:   NS_ENSURE_SUCCESS(rv, rv);
26883: 
26883:   rv = mPresShell->GetSelectionForCopy(getter_AddRefs(mSelection));
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914:   NS_ASSERTION(mSelection,
11914:                "GetSelectionForCopy succeeded, but the result is null");
11914: 
26757:   PRBool isCollapsed;
26757:   rv = mSelection->GetIsCollapsed(&isCollapsed);
26757:   if (NS_FAILED(rv))
26757:     return NS_ERROR_NOT_AVAILABLE;
26757:   aEvent->mReply.mHasSelection = !isCollapsed;
26757: 
11914:   nsCOMPtr<nsIDOMRange> firstRange;
11914:   rv = mSelection->GetRangeAt(0, getter_AddRefs(firstRange));
11914:   // This shell doesn't support selection.
11914:   if (NS_FAILED(rv))
11914:     return NS_ERROR_NOT_AVAILABLE;
11914:   mFirstSelectedRange = do_QueryInterface(firstRange);
11914:   NS_ENSURE_TRUE(mFirstSelectedRange, NS_ERROR_FAILURE);
11914: 
11914:   nsINode* startNode = mFirstSelectedRange->GetStartParent();
11914:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
11914:   mRootContent = startNode->GetSelectionRootContent(mPresShell);
11914:   NS_ENSURE_TRUE(mRootContent, NS_ERROR_FAILURE);
11914: 
11914:   aEvent->mReply.mContentsRoot = mRootContent.get();
11914: 
16548:   nsRefPtr<nsCaret> caret;
16548:   rv = mPresShell->GetCaret(getter_AddRefs(caret));
16548:   NS_ENSURE_SUCCESS(rv, rv);
16548:   NS_ASSERTION(caret, "GetCaret succeeded, but the result is null");
16548:   nsRect r;
16548:   nsIView* view = nsnull;
16548:   rv = caret->GetCaretCoordinates(nsCaret::eRenderingViewCoordinates,
16548:                                   mSelection, &r, &isCollapsed, &view);
16548:   NS_ENSURE_SUCCESS(rv, rv);
16548:   NS_ENSURE_TRUE(view, NS_ERROR_FAILURE);
16548:   aEvent->mReply.mFocusedWidget = view->GetWidget();
16548: 
11914:   return NS_OK;
11914: }
11914: 
24836: // Editor places a bogus BR node under its root content if the editor doesn't
24836: // have any text. This happens even for single line editors.
24836: // When we get text content and when we change the selection,
24836: // we don't want to include the bogus BRs at the end.
24836: static PRBool IsContentBR(nsIContent* aContent)
24836: {
33329:   return aContent->IsHTML() &&
24836:          aContent->Tag() == nsGkAtoms::br &&
24836:          !aContent->AttrValueIs(kNameSpaceID_None,
24836:                                 nsGkAtoms::type,
24836:                                 nsGkAtoms::moz,
24836:                                 eIgnoreCase) &&
24836:          !aContent->AttrValueIs(kNameSpaceID_None,
24836:                                 nsGkAtoms::mozeditorbogusnode,
24836:                                 nsGkAtoms::_true,
24836:                                 eIgnoreCase);
24836: }
24836: 
11914: static void ConvertToNativeNewlines(nsAFlatString& aString)
11914: {
11914: #if defined(XP_MACOSX)
11914:   aString.ReplaceSubstring(NS_LITERAL_STRING("\n"), NS_LITERAL_STRING("\r"));
11914: #elif defined(XP_WIN)
11914:   aString.ReplaceSubstring(NS_LITERAL_STRING("\n"), NS_LITERAL_STRING("\r\n"));
11914: #endif
11914: }
11914: 
11914: static void ConvertToXPNewlines(nsAFlatString& aString)
11914: {
11914: #if defined(XP_MACOSX)
11914:   aString.ReplaceSubstring(NS_LITERAL_STRING("\r"), NS_LITERAL_STRING("\n"));
11914: #elif defined(XP_WIN)
11914:   aString.ReplaceSubstring(NS_LITERAL_STRING("\r\n"), NS_LITERAL_STRING("\n"));
11914: #endif
11914: }
11914: 
11914: static void AppendString(nsAString& aString, nsIContent* aContent)
11914: {
11914:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
11914:                "aContent is not a text node!");
11914:   const nsTextFragment* text = aContent->GetText();
11914:   if (!text)
11914:     return;
11914:   text->AppendTo(aString);
11914: }
11914: 
11914: static void AppendSubString(nsAString& aString, nsIContent* aContent,
11914:                             PRUint32 aXPOffset, PRUint32 aXPLength)
11914: {
11914:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
11914:                "aContent is not a text node!");
11914:   const nsTextFragment* text = aContent->GetText();
11914:   if (!text)
11914:     return;
11914:   text->AppendTo(aString, PRInt32(aXPOffset), PRInt32(aXPLength));
11914: }
11914: 
11914: static PRUint32 GetNativeTextLength(nsIContent* aContent)
11914: {
11914:   nsAutoString str;
11914:   if (aContent->IsNodeOfType(nsINode::eTEXT))
11914:     AppendString(str, aContent);
24836:   else if (IsContentBR(aContent))
11914:     str.Assign(PRUnichar('\n'));
11914:   ConvertToNativeNewlines(str);
11914:   return str.Length();
11914: }
11914: 
11914: static PRUint32 ConvertToXPOffset(nsIContent* aContent, PRUint32 aNativeOffset)
11914: {
11914: 
11914:   nsAutoString str;
11914:   AppendString(str, aContent);
11914:   ConvertToNativeNewlines(str);
11914:   NS_ASSERTION(aNativeOffset <= str.Length(),
11914:                "aOffsetForNativeLF is too large!");
11914:   str.Truncate(aNativeOffset);
11914:   ConvertToXPNewlines(str);
11914:   return str.Length();
11914: }
11914: 
24836: static nsresult GenerateFlatTextContent(nsIRange* aRange,
11914:                                         nsAFlatString& aString)
11914: {
11914:   nsCOMPtr<nsIContentIterator> iter;
11914:   nsresult rv = NS_NewContentIterator(getter_AddRefs(iter));
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914:   NS_ASSERTION(iter, "NS_NewContentIterator succeeded, but the result is null");
11914:   nsCOMPtr<nsIDOMRange> domRange(do_QueryInterface(aRange));
11914:   NS_ASSERTION(domRange, "aRange doesn't have nsIDOMRange!");
11914:   iter->Init(domRange);
11914: 
11914:   NS_ASSERTION(aString.IsEmpty(), "aString must be empty string");
11914: 
11914:   nsINode* startNode = aRange->GetStartParent();
35245:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
11914:   nsINode* endNode = aRange->GetEndParent();
35245:   NS_ENSURE_TRUE(endNode, NS_ERROR_FAILURE);
11914: 
11914:   if (startNode == endNode && startNode->IsNodeOfType(nsINode::eTEXT)) {
11914:     nsIContent* content = static_cast<nsIContent*>(startNode);
11914:     AppendSubString(aString, content, aRange->StartOffset(),
11914:                     aRange->EndOffset() - aRange->StartOffset());
11914:     ConvertToNativeNewlines(aString);
11914:     return NS_OK;
11914:   }
11914: 
11914:   nsAutoString tmpStr;
11914:   for (; !iter->IsDone(); iter->Next()) {
20503:     nsINode* node = iter->GetCurrentNode();
20503:     if (!node || !node->IsNodeOfType(nsINode::eCONTENT))
11914:       continue;
20503:     nsIContent* content = static_cast<nsIContent*>(node);
11914: 
11914:     if (content->IsNodeOfType(nsINode::eTEXT)) {
11914:       if (content == startNode)
11914:         AppendSubString(aString, content, aRange->StartOffset(),
11914:                         content->TextLength() - aRange->StartOffset());
11914:       else if (content == endNode)
11914:         AppendSubString(aString, content, 0, aRange->EndOffset());
11914:       else
11914:         AppendString(aString, content);
24836:     } else if (IsContentBR(content))
11914:         aString.Append(PRUnichar('\n'));
11914:   }
11914:   ConvertToNativeNewlines(aString);
11914:   return NS_OK;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::ExpandToClusterBoundary(nsIContent* aContent,
11914:                                                     PRBool aForward,
11914:                                                     PRUint32* aXPOffset)
11914: {
11914:   // XXX This method assumes that the frame boundaries must be cluster
11914:   // boundaries. It's false, but no problem now, maybe.
11914:   if (!aContent->IsNodeOfType(nsINode::eTEXT) ||
11914:       *aXPOffset == 0 || *aXPOffset == aContent->TextLength())
11914:     return NS_OK;
24836: 
24836:   NS_ASSERTION(*aXPOffset >= 0 && *aXPOffset <= aContent->TextLength(),
24836:                "offset is out of range.");
24836: 
11914:   nsCOMPtr<nsFrameSelection> fs = mPresShell->FrameSelection();
11914:   PRInt32 offsetInFrame;
11914:   nsFrameSelection::HINT hint =
11914:     aForward ? nsFrameSelection::HINTLEFT : nsFrameSelection::HINTRIGHT;
11914:   nsIFrame* frame = fs->GetFrameForNodeOffset(aContent, PRInt32(*aXPOffset),
11914:                                               hint, &offsetInFrame);
11914:   if (!frame) {
11914:     // This content doesn't have any frames, we only can check surrogate pair...
11914:     const nsTextFragment* text = aContent->GetText();
11914:     NS_ENSURE_TRUE(text, NS_ERROR_FAILURE);
11914:     if (NS_IS_LOW_SURROGATE(text->CharAt(*aXPOffset)) &&
11914:         NS_IS_HIGH_SURROGATE(text->CharAt(*aXPOffset - 1)))
11914:       *aXPOffset += aForward ? 1 : -1;
11914:     return NS_OK;
11914:   }
11914:   PRInt32 startOffset, endOffset;
11914:   nsresult rv = frame->GetOffsets(startOffset, endOffset);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914:   if (*aXPOffset == PRUint32(startOffset) || *aXPOffset == PRUint32(endOffset))
11914:     return NS_OK;
11914:   if (frame->GetType() != nsGkAtoms::textFrame)
11914:     return NS_ERROR_FAILURE;
11914:   nsTextFrame* textFrame = static_cast<nsTextFrame*>(frame);
24836:   PRInt32 newOffsetInFrame = *aXPOffset - startOffset;
11914:   newOffsetInFrame += aForward ? -1 : 1;
11914:   textFrame->PeekOffsetCharacter(aForward, &newOffsetInFrame);
11914:   *aXPOffset = startOffset + newOffsetInFrame;
11914:   return NS_OK;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::SetRangeFromFlatTextOffset(
11914:                               nsIRange* aRange,
11914:                               PRUint32 aNativeOffset,
11914:                               PRUint32 aNativeLength,
11914:                               PRBool aExpandToClusterBoundaries)
11914: {
11914:   nsCOMPtr<nsIContentIterator> iter;
11914:   nsresult rv = NS_NewContentIterator(getter_AddRefs(iter));
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914:   NS_ASSERTION(iter, "NS_NewContentIterator succeeded, but the result is null");
11914:   rv = iter->Init(mRootContent);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914:   nsCOMPtr<nsIDOMRange> domRange(do_QueryInterface(aRange));
11914:   NS_ASSERTION(domRange, "aRange doesn't have nsIDOMRange!");
11914: 
11914:   PRUint32 nativeOffset = 0;
11914:   PRUint32 nativeEndOffset = aNativeOffset + aNativeLength;
20503:   nsCOMPtr<nsIContent> content;
11914:   for (; !iter->IsDone(); iter->Next()) {
20503:     nsINode* node = iter->GetCurrentNode();
20503:     if (!node || !node->IsNodeOfType(nsINode::eCONTENT))
11914:       continue;
20503:     nsIContent* content = static_cast<nsIContent*>(node);
11914: 
11914:     PRUint32 nativeTextLength;
11914:     nativeTextLength = GetNativeTextLength(content);
11914:     if (nativeTextLength == 0)
11914:       continue;
11914: 
11914:     if (nativeOffset <= aNativeOffset &&
11914:         aNativeOffset < nativeOffset + nativeTextLength) {
11914:       nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(content));
11914:       NS_ASSERTION(domNode, "aContent doesn't have nsIDOMNode!");
11914: 
11914:       PRUint32 xpOffset =
11914:         content->IsNodeOfType(nsINode::eTEXT) ?
11914:           ConvertToXPOffset(content, aNativeOffset - nativeOffset) : 0;
11914: 
11914:       if (aExpandToClusterBoundaries) {
11914:         rv = ExpandToClusterBoundary(content, PR_FALSE, &xpOffset);
11914:         NS_ENSURE_SUCCESS(rv, rv);
11914:       }
11914: 
11914:       rv = domRange->SetStart(domNode, PRInt32(xpOffset));
11914:       NS_ENSURE_SUCCESS(rv, rv);
11914:       if (aNativeLength == 0) {
11914:         // Ensure that the end offset and the start offset are same.
11914:         rv = domRange->SetEnd(domNode, PRInt32(xpOffset));
11914:         NS_ENSURE_SUCCESS(rv, rv);
11914:         return NS_OK;
11914:       }
11914:     }
11914:     if (nativeEndOffset <= nativeOffset + nativeTextLength) {
11914:       nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(content));
11914:       NS_ASSERTION(domNode, "aContent doesn't have nsIDOMNode!");
11914: 
11914:       PRUint32 xpOffset;
11914:       if (content->IsNodeOfType(nsINode::eTEXT)) {
11914:         xpOffset = ConvertToXPOffset(content, nativeEndOffset - nativeOffset);
11914:         if (aExpandToClusterBoundaries) {
11914:           rv = ExpandToClusterBoundary(content, PR_TRUE, &xpOffset);
11914:           NS_ENSURE_SUCCESS(rv, rv);
11914:         }
11914:       } else {
11914:         // Use first position of next node, because the end node is ignored
11914:         // by ContentIterator when the offset is zero.
11914:         xpOffset = 0;
11914:         iter->Next();
11914:         if (iter->IsDone())
11914:           break;
11914:         domNode = do_QueryInterface(iter->GetCurrentNode());
11914:       }
11914: 
11914:       rv = domRange->SetEnd(domNode, PRInt32(xpOffset));
11914:       NS_ENSURE_SUCCESS(rv, rv);
11914:       return NS_OK;
11914:     }
11914: 
11914:     nativeOffset += nativeTextLength;
11914:   }
11914: 
11914:   if (nativeOffset < aNativeOffset)
11914:     return NS_ERROR_FAILURE;
11914: 
11914:   nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(mRootContent));
11914:   NS_ASSERTION(domNode, "lastContent doesn't have nsIDOMNode!");
11914:   if (!content) {
11914:     rv = domRange->SetStart(domNode, 0);
11914:     NS_ENSURE_SUCCESS(rv, rv);
11914:   }
11914:   rv = domRange->SetEnd(domNode, PRInt32(mRootContent->GetChildCount()));
11914:   NS_ASSERTION(NS_SUCCEEDED(rv), "nsIDOMRange::SetEnd failed");
11914:   return rv;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::OnQuerySelectedText(nsQueryContentEvent* aEvent)
11914: {
11914:   nsresult rv = Init(aEvent);
11914:   if (NS_FAILED(rv))
11914:     return rv;
11914: 
11914:   NS_ASSERTION(aEvent->mReply.mString.IsEmpty(),
11914:                "The reply string must be empty");
11914: 
24836:   rv = GetFlatTextOffsetOfRange(mRootContent,
24836:                                 mFirstSelectedRange, &aEvent->mReply.mOffset);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
24836:   nsCOMPtr<nsIDOMNode> anchorDomNode, focusDomNode;
24836:   rv = mSelection->GetAnchorNode(getter_AddRefs(anchorDomNode));
24836:   NS_ENSURE_TRUE(anchorDomNode, NS_ERROR_FAILURE);
24836:   rv = mSelection->GetFocusNode(getter_AddRefs(focusDomNode));
24836:   NS_ENSURE_TRUE(focusDomNode, NS_ERROR_FAILURE);
24836: 
24836:   PRInt32 anchorOffset, focusOffset;
24836:   rv = mSelection->GetAnchorOffset(&anchorOffset);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836:   rv = mSelection->GetFocusOffset(&focusOffset);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
24836:   nsCOMPtr<nsINode> anchorNode(do_QueryInterface(anchorDomNode));
24836:   nsCOMPtr<nsINode> focusNode(do_QueryInterface(focusDomNode));
24836:   NS_ENSURE_TRUE(anchorNode && focusNode, NS_ERROR_UNEXPECTED);
11914: 
24836:   PRInt16 compare = nsContentUtils::ComparePoints(anchorNode, anchorOffset,
24836:                                                   focusNode, focusOffset);
24836:   aEvent->mReply.mReversed = compare > 0;
24836: 
24836:   if (compare) {
24836:     nsCOMPtr<nsIRange> range = mFirstSelectedRange;
11914:     rv = GenerateFlatTextContent(range, aEvent->mReply.mString);
11914:     NS_ENSURE_SUCCESS(rv, rv);
11914:   }
11914: 
11914:   aEvent->mSucceeded = PR_TRUE;
11914:   return NS_OK;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::OnQueryTextContent(nsQueryContentEvent* aEvent)
11914: {
11914:   nsresult rv = Init(aEvent);
11914:   if (NS_FAILED(rv))
11914:     return rv;
11914: 
11914:   NS_ASSERTION(aEvent->mReply.mString.IsEmpty(),
11914:                "The reply string must be empty");
11914: 
11914:   nsCOMPtr<nsIRange> range = new nsRange();
11914:   NS_ENSURE_TRUE(range, NS_ERROR_OUT_OF_MEMORY);
11914:   rv = SetRangeFromFlatTextOffset(range, aEvent->mInput.mOffset,
11914:                                   aEvent->mInput.mLength, PR_FALSE);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
11914:   rv = GenerateFlatTextContent(range, aEvent->mReply.mString);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
11914:   aEvent->mSucceeded = PR_TRUE;
11914: 
11914:   return NS_OK;
11914: }
11914: 
24836: // Adjust to use a child node if possible
24836: // to make the returned rect more accurate
24836: static nsINode* AdjustTextRectNode(nsINode* aNode,
24836:                                    PRInt32& aOffset)
24836: {
24836:   PRInt32 childCount = PRInt32(aNode->GetChildCount());
24836:   nsINode* node = aNode;
24836:   if (childCount) {
24836:     if (aOffset < childCount) {
24836:       node = aNode->GetChildAt(aOffset);
24836:       aOffset = 0;
24836:     } else if (aOffset == childCount) {
24836:       node = aNode->GetChildAt(childCount - 1);
24836:       aOffset = node->IsNodeOfType(nsINode::eTEXT) ?
24836:           static_cast<nsIContent*>(node)->TextLength() : 1;
24836:     }
24836:   }
24836:   return node;
24836: }
24836: 
24836: // Similar to nsFrameSelection::GetFrameForNodeOffset,
24836: // but this is more flexible for OnQueryTextRect to use
24836: static nsresult GetFrameForTextRect(nsIPresShell* aPresShell,
24836:                                     nsINode* aNode,
24836:                                     PRInt32 aOffset,
24836:                                     PRBool aHint,
24836:                                     nsIFrame** aReturnFrame)
24836: {
24836:   NS_ENSURE_TRUE(aNode && aNode->IsNodeOfType(nsINode::eCONTENT),
24836:                  NS_ERROR_UNEXPECTED);
24836:   nsIContent* content = static_cast<nsIContent*>(aNode);
24836:   nsIFrame* frame = aPresShell->GetPrimaryFrameFor(content);
24836:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
24836:   PRInt32 childOffset = 0;
24836:   return frame->GetChildFrameContainingOffset(aOffset, aHint, &childOffset,
24836:                                               aReturnFrame);
24836: }
24836: 
24831: nsresult
24836: nsContentEventHandler::OnQueryTextRect(nsQueryContentEvent* aEvent)
24823: {
24836:   nsresult rv = Init(aEvent);
24836:   if (NS_FAILED(rv))
24836:     return rv;
24836: 
26992:   nsCOMPtr<nsIRange> range = new nsRange();
24836:   if (!range) {
24836:     return NS_ERROR_OUT_OF_MEMORY;
24836:   }
24836:   rv = SetRangeFromFlatTextOffset(range, aEvent->mInput.mOffset,
24836:                                   aEvent->mInput.mLength, PR_TRUE);
24831:   NS_ENSURE_SUCCESS(rv, rv);
24831: 
24836:   // used to iterate over all contents and their frames
24836:   nsCOMPtr<nsIContentIterator> iter;
24836:   rv = NS_NewContentIterator(getter_AddRefs(iter));
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836:   iter->Init(range);
24831:   NS_ENSURE_SUCCESS(rv, rv);
24831: 
24836:   // get the starting frame
24836:   PRInt32 offset = range->StartOffset();
24836:   nsINode* node = iter->GetCurrentNode();
24836:   if (!node) {
24836:     node = AdjustTextRectNode(range->GetStartParent(), offset);
24836:   }
24836:   nsIFrame* firstFrame = nsnull;
24836:   rv = GetFrameForTextRect(mPresShell, node, offset,
24836:                            PR_TRUE, &firstFrame);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24831: 
24836:   // get the starting frame rect
24836:   nsRect rect(nsPoint(0, 0), firstFrame->GetRect().Size());
24836:   rv = ConvertToRootViewRelativeOffset(firstFrame, rect);
24831:   NS_ENSURE_SUCCESS(rv, rv);
24836:   nsRect frameRect = rect;
24836:   nsPoint ptOffset;
24836:   firstFrame->GetPointFromOffset(offset, &ptOffset);
24836:   // minus 1 to avoid creating an empty rect
24836:   rect.x += ptOffset.x - 1;
24836:   rect.width -= ptOffset.x - 1;
24836: 
24836:   // get the ending frame
24836:   offset = range->EndOffset();
24836:   node = AdjustTextRectNode(range->GetEndParent(), offset);
24836:   nsIFrame* lastFrame = nsnull;
24836:   rv = GetFrameForTextRect(mPresShell, node, offset,
24836:                            range->Collapsed(), &lastFrame);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   // iterate over all covered frames
24836:   for (nsIFrame* frame = firstFrame; frame != lastFrame;) {
24836:     frame = frame->GetNextContinuation();
24836:     if (!frame) {
24836:       do {
24836:         iter->Next();
24836:         node = iter->GetCurrentNode();
24836:         if (!node || !node->IsNodeOfType(nsINode::eCONTENT))
24836:           continue;
24836:         frame = mPresShell->GetPrimaryFrameFor(static_cast<nsIContent*>(node));
24836:       } while (!frame && !iter->IsDone());
24836:       if (!frame) {
24836:         // this can happen when the end offset of the range is 0.
24836:         frame = lastFrame;
24836:       }
24836:     }
24836:     frameRect.SetRect(nsPoint(0, 0), frame->GetRect().Size());
24836:     rv = ConvertToRootViewRelativeOffset(frame, frameRect);
24836:     NS_ENSURE_SUCCESS(rv, rv);
24836:     if (frame != lastFrame) {
24836:       // not last frame, so just add rect to previous result
24836:       rect.UnionRect(rect, frameRect);
24836:     }
24823:   }
24823: 
24836:   // get the ending frame rect
24836:   lastFrame->GetPointFromOffset(offset, &ptOffset);
24836:   // minus 1 to avoid creating an empty rect
24836:   frameRect.width -= lastFrame->GetRect().width - ptOffset.x - 1;
24831: 
24836:   if (firstFrame == lastFrame) {
24836:     rect.IntersectRect(rect, frameRect);
24836:   } else {
24836:     rect.UnionRect(rect, frameRect);
24836:   }
24836:   aEvent->mReply.mRect =
28113:       rect.ToOutsidePixels(mPresContext->AppUnitsPerDevPixel());
24831:   aEvent->mSucceeded = PR_TRUE;
24831:   return NS_OK;
24823: }
24823: 
24746: nsresult
24836: nsContentEventHandler::OnQueryEditorRect(nsQueryContentEvent* aEvent)
24726: {
24823:   nsresult rv = Init(aEvent);
24823:   if (NS_FAILED(rv))
24823:     return rv;
24823: 
24836:   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(mRootContent);
24836:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
24836: 
24836:   // get rect for first frame
24836:   nsRect resultRect(nsPoint(0, 0), frame->GetRect().Size());
24836:   rv = ConvertToRootViewRelativeOffset(frame, resultRect);
24746:   NS_ENSURE_SUCCESS(rv, rv);
24746: 
24836:   // account for any additional frames
24836:   while ((frame = frame->GetNextContinuation()) != nsnull) {
24836:     nsRect frameRect(nsPoint(0, 0), frame->GetRect().Size());
24836:     rv = ConvertToRootViewRelativeOffset(frame, frameRect);
24836:     NS_ENSURE_SUCCESS(rv, rv);
24836:     resultRect.UnionRect(resultRect, frameRect);
24836:   }
24836: 
24836:   aEvent->mReply.mRect =
28113:       resultRect.ToOutsidePixels(mPresContext->AppUnitsPerDevPixel());
24836:   aEvent->mSucceeded = PR_TRUE;
24746:   return NS_OK;
24726: }
24726: 
11914: nsresult
24836: nsContentEventHandler::OnQueryCaretRect(nsQueryContentEvent* aEvent)
11914: {
11914:   nsresult rv = Init(aEvent);
11914:   if (NS_FAILED(rv))
11914:     return rv;
11914: 
15969:   nsRefPtr<nsCaret> caret;
11914:   rv = mPresShell->GetCaret(getter_AddRefs(caret));
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914:   NS_ASSERTION(caret, "GetCaret succeeded, but the result is null");
11914: 
11914:   // When the selection is collapsed and the queried offset is current caret
11914:   // position, we should return the "real" caret rect.
11914:   PRBool selectionIsCollapsed;
11914:   rv = mSelection->GetIsCollapsed(&selectionIsCollapsed);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
11914:   if (selectionIsCollapsed) {
11914:     PRUint32 offset;
24836:     rv = GetFlatTextOffsetOfRange(mRootContent, mFirstSelectedRange, &offset);
11914:     NS_ENSURE_SUCCESS(rv, rv);
11914:     if (offset == aEvent->mInput.mOffset) {
11914:       PRBool isCollapsed;
23738:       nsRect rect;
15969:       rv = caret->GetCaretCoordinates(nsCaret::eTopLevelWindowCoordinates,
23738:                                       mSelection, &rect,
11914:                                       &isCollapsed, nsnull);
24836:       aEvent->mReply.mRect =
28113:           rect.ToOutsidePixels(mPresContext->AppUnitsPerDevPixel());
11914:       NS_ENSURE_SUCCESS(rv, rv);
11914:       aEvent->mSucceeded = PR_TRUE;
11914:       return NS_OK;
11914:     }
11914:   }
11914: 
11914:   // Otherwise, we should set the guessed caret rect.
11914:   nsCOMPtr<nsIRange> range = new nsRange();
11914:   NS_ENSURE_TRUE(range, NS_ERROR_OUT_OF_MEMORY);
11914:   rv = SetRangeFromFlatTextOffset(range, aEvent->mInput.mOffset, 0, PR_TRUE);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
24836:   PRInt32 offsetInFrame;
24836:   nsIFrame* frame;
24836:   rv = GetStartFrameAndOffset(range, &frame, &offsetInFrame);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   nsPoint posInFrame;
24836:   rv = frame->GetPointFromOffset(range->StartOffset(), &posInFrame);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   nsRect rect;
24836:   rect.x = posInFrame.x;
24836:   rect.y = posInFrame.y;
24836:   rect.width = caret->GetCaretRect().width;
24836:   rect.height = frame->GetSize().height;
24836: 
24836:   rv = ConvertToRootViewRelativeOffset(frame, rect);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   aEvent->mReply.mRect =
28113:       rect.ToOutsidePixels(mPresContext->AppUnitsPerDevPixel());
24836:   aEvent->mSucceeded = PR_TRUE;
24836:   return NS_OK;
11914: }
11914: 
11914: nsresult
26757: nsContentEventHandler::OnQueryContentState(nsQueryContentEvent * aEvent)
26757: {
26757:   nsresult rv = Init(aEvent);
26757:   if (NS_FAILED(rv))
26757:     return rv;
26757:   
26757:   aEvent->mSucceeded = PR_TRUE;
26757: 
26757:   return NS_OK;
26757: }
26757: 
26757: nsresult
26757: nsContentEventHandler::OnQuerySelectionAsTransferable(nsQueryContentEvent* aEvent)
26757: {
26757:   nsresult rv = Init(aEvent);
26757:   if (NS_FAILED(rv))
26757:     return rv;
26757: 
26757:   if (!aEvent->mReply.mHasSelection) {
26757:     aEvent->mSucceeded = PR_TRUE;
26757:     aEvent->mReply.mTransferable = nsnull;
26757:     return NS_OK;
26757:   }
26757: 
26757:   nsCOMPtr<nsIDocument> doc = mPresShell->GetDocument();
26757:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
26757: 
26757:   rv = nsCopySupport::GetTransferableForSelection(mSelection, doc, getter_AddRefs(aEvent->mReply.mTransferable));
26757:   NS_ENSURE_SUCCESS(rv, rv);
26757: 
26757:   aEvent->mSucceeded = PR_TRUE;
26757:   return NS_OK;
26757: }
26757: 
26757: nsresult
28352: nsContentEventHandler::OnQueryCharacterAtPoint(nsQueryContentEvent* aEvent)
28352: {
28352:   nsresult rv = Init(aEvent);
28352:   if (NS_FAILED(rv))
28352:     return rv;
28352: 
28352:   nsIFrame* rootFrame = mPresShell->GetRootFrame();
28352:   nsPoint ptInRoot =
28352:     nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, rootFrame);
28352:   nsIFrame* targetFrame = nsLayoutUtils::GetFrameForPoint(rootFrame, ptInRoot);
28352:   if (!targetFrame || targetFrame->GetType() != nsGkAtoms::textFrame) {
28352:     // there is no character at the point.
28352:     aEvent->mReply.mOffset = nsQueryContentEvent::NOT_FOUND;
28352:     aEvent->mSucceeded = PR_TRUE;
28352:     return NS_OK;
28352:   }
28352:   nsPoint ptInTarget = ptInRoot - targetFrame->GetOffsetTo(rootFrame);
28352:   nsTextFrame* textframe = static_cast<nsTextFrame*>(targetFrame);
28352:   nsIFrame::ContentOffsets offsets =
28352:     textframe->GetCharacterOffsetAtFramePoint(ptInTarget);
28352:   NS_ENSURE_TRUE(offsets.content, NS_ERROR_FAILURE);
28352:   PRUint32 nativeOffset;
28352:   rv = GetFlatTextOffsetOfRange(mRootContent, offsets.content, offsets.offset,
28352:                                 &nativeOffset);
28352:   NS_ENSURE_SUCCESS(rv, rv);
28352: 
28352:   nsQueryContentEvent textRect(PR_TRUE, NS_QUERY_TEXT_RECT, aEvent->widget);
28352:   textRect.InitForQueryTextRect(nativeOffset, 1);
28352:   rv = OnQueryTextRect(&textRect);
28352:   NS_ENSURE_SUCCESS(rv, rv);
28352:   NS_ENSURE_TRUE(textRect.mSucceeded, NS_ERROR_FAILURE);
28352: 
28352:   // currently, we don't need to get the actual text.
28352:   aEvent->mReply.mOffset = nativeOffset;
28352:   aEvent->mReply.mRect = textRect.mReply.mRect;
28352:   aEvent->mSucceeded = PR_TRUE;
28352:   return NS_OK;
28352: }
28352: 
28352: nsresult
24836: nsContentEventHandler::GetFlatTextOffsetOfRange(nsIContent* aRootContent,
24836:                                                 nsINode* aNode,
24836:                                                 PRInt32 aNodeOffset,
11914:                                                 PRUint32* aNativeOffset)
11914: {
11914:   NS_ASSERTION(aNativeOffset, "param is invalid");
11914: 
11914:   nsCOMPtr<nsIRange> prev = new nsRange();
11914:   NS_ENSURE_TRUE(prev, NS_ERROR_OUT_OF_MEMORY);
11914:   nsCOMPtr<nsIDOMRange> domPrev(do_QueryInterface(prev));
11914:   NS_ASSERTION(domPrev, "nsRange doesn't have nsIDOMRange??");
24836:   nsCOMPtr<nsIDOMNode> rootDOMNode(do_QueryInterface(aRootContent));
11914:   domPrev->SetStart(rootDOMNode, 0);
11914: 
24836:   nsCOMPtr<nsIDOMNode> startDOMNode(do_QueryInterface(aNode));
11914:   NS_ASSERTION(startDOMNode, "startNode doesn't have nsIDOMNode");
24836:   domPrev->SetEnd(startDOMNode, aNodeOffset);
11914: 
11914:   nsAutoString prevStr;
11914:   nsresult rv = GenerateFlatTextContent(prev, prevStr);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914:   *aNativeOffset = prevStr.Length();
11914:   return NS_OK;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::GetFlatTextOffsetOfRange(nsIContent* aRootContent,
24836:                                                 nsIRange* aRange,
24836:                                                 PRUint32* aNativeOffset)
24836: {
24836:   nsINode* startNode = aRange->GetStartParent();
24836:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
24836:   PRInt32 startOffset = aRange->StartOffset();
24836:   return GetFlatTextOffsetOfRange(aRootContent, startNode, startOffset,
24836:                                   aNativeOffset);
24836: }
24836: 
24836: nsresult
24836: nsContentEventHandler::GetStartFrameAndOffset(nsIRange* aRange,
11914:                                               nsIFrame** aFrame,
11914:                                               PRInt32* aOffsetInFrame)
11914: {
11914:   NS_ASSERTION(aRange && aFrame && aOffsetInFrame, "params are invalid");
11914: 
11914:   nsIContent* content = nsnull;
11914:   nsINode* node = aRange->GetStartParent();
11914:   if (node && node->IsNodeOfType(nsINode::eCONTENT))
11914:     content = static_cast<nsIContent*>(node);
11914:   NS_ASSERTION(content, "the start node doesn't have nsIContent!");
11914: 
11914:   nsCOMPtr<nsFrameSelection> fs = mPresShell->FrameSelection();
11914:   *aFrame = fs->GetFrameForNodeOffset(content, aRange->StartOffset(),
11914:                                       fs->GetHint(), aOffsetInFrame);
11914:   NS_ENSURE_TRUE((*aFrame), NS_ERROR_FAILURE);
11914:   NS_ASSERTION((*aFrame)->GetType() == nsGkAtoms::textFrame,
11914:                "The frame is not textframe");
11914:   return NS_OK;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::ConvertToRootViewRelativeOffset(nsIFrame* aFrame,
11914:                                                        nsRect& aRect)
11914: {
11914:   NS_ASSERTION(aFrame, "aFrame must not be null");
11914: 
11914:   nsIView* view = nsnull;
11914:   nsPoint posInView;
11914:   aFrame->GetOffsetFromView(posInView, &view);
11914:   if (!view)
11914:     return NS_ERROR_FAILURE;
11914:   aRect += posInView + view->GetOffsetTo(nsnull);
11914:   return NS_OK;
11914: }
24836: 
24836: static void AdjustRangeForSelection(nsIContent* aRoot,
24836:                                     nsINode** aNode,
24836:                                     PRInt32* aOffset)
24836: {
24836:   nsINode* node = *aNode;
24836:   PRInt32 offset = *aOffset;
24836:   if (aRoot != node && node->GetParent() &&
24836:       !node->IsNodeOfType(nsINode::eTEXT)) {
24836:     node = node->GetParent();
24836:     offset = node->IndexOf(*aNode) + (offset ? 1 : 0);
24836:   }
33329:   
33329:   nsIContent* brContent = node->GetChildAt(offset - 1);
33329:   while (brContent && brContent->IsHTML()) {
24836:     if (brContent->Tag() != nsGkAtoms::br || IsContentBR(brContent))
24836:       break;
33329:     brContent = node->GetChildAt(--offset - 1);
24836:   }
24836:   *aNode = node;
24836:   *aOffset = PR_MAX(offset, 0);
24836: }
24836: 
24836: nsresult
24836: nsContentEventHandler::OnSelectionEvent(nsSelectionEvent* aEvent)
24836: {
24836:   aEvent->mSucceeded = PR_FALSE;
24836: 
24836:   // Get selection to manipulate
24836:   nsCOMPtr<nsISelection> sel;
24836:   nsresult rv = nsIMEStateManager::
24836:       GetFocusSelectionAndRoot(getter_AddRefs(sel),
24836:                                getter_AddRefs(mRootContent));
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   // Get range from offset and length
24836:   nsRefPtr<nsRange> range = new nsRange();
24836:   NS_ENSURE_TRUE(range, NS_ERROR_OUT_OF_MEMORY);
24836:   rv = SetRangeFromFlatTextOffset(range, aEvent->mOffset,
24836:                                   aEvent->mLength, PR_TRUE);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   nsINode* startNode = range->GetStartParent();
24836:   nsINode* endNode = range->GetEndParent();
24836:   PRInt32 startOffset = range->StartOffset();
24836:   PRInt32 endOffset = range->EndOffset();
24836:   AdjustRangeForSelection(mRootContent, &startNode, &startOffset);
24836:   AdjustRangeForSelection(mRootContent, &endNode, &endOffset);
24836: 
24836:   nsCOMPtr<nsIDOMNode> startDomNode(do_QueryInterface(startNode));
24836:   nsCOMPtr<nsIDOMNode> endDomNode(do_QueryInterface(endNode));
24836:   NS_ENSURE_TRUE(startDomNode && endDomNode, NS_ERROR_UNEXPECTED);
24836: 
24836:   nsCOMPtr<nsISelectionPrivate> selPrivate = do_QueryInterface(sel);
24836:   NS_ENSURE_TRUE(selPrivate, NS_ERROR_UNEXPECTED);
24836:   selPrivate->StartBatchChanges();
24836: 
24836:   // Clear selection first before setting
24836:   rv = sel->RemoveAllRanges();
24836:   // Need to call EndBatchChanges at the end even if call failed
24836:   if (NS_SUCCEEDED(rv)) {
24836:     if (aEvent->mReversed) {
24836:       rv = sel->Collapse(endDomNode, endOffset);
24836:     } else {
24836:       rv = sel->Collapse(startDomNode, startOffset);
24836:     }
24836:     if (NS_SUCCEEDED(rv) &&
24836:         (startDomNode != endDomNode || startOffset != endOffset)) {
24836:       if (aEvent->mReversed) {
24836:         rv = sel->Extend(startDomNode, startOffset);
24836:       } else {
24836:         rv = sel->Extend(endDomNode, endOffset);
24836:       }
24836:     }
24836:   }
24836:   selPrivate->EndBatchChanges();
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   nsCOMPtr<nsISelection2>(do_QueryInterface(sel))->ScrollIntoView(
24836:       nsISelectionController::SELECTION_FOCUS_REGION, PR_FALSE, -1, -1);
24836:   aEvent->mSucceeded = PR_TRUE;
24836:   return NS_OK;
24836: }
