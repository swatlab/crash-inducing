    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Sean Echevarria <sean@beatnik.com>
12841:  *   HÃ¥kan Waara <hwaara@chello.se>
    1:  *   Josh Aas <josh@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
29956: /* nsPluginHost.cpp - top-level plugin management code */
    1: 
    1: #include "nscore.h"
29956: #include "nsPluginHost.h"
    1: 
    1: #include <stdio.h>
    1: #include "prio.h"
    1: #include "prmem.h"
46998: #include "nsIComponentManager.h"
19246: #include "nsNPAPIPlugin.h"
19246: #include "nsNPAPIPluginStreamListener.h"
    1: #include "nsIPlugin.h"
29834: #include "nsNPAPIPluginInstance.h"
    1: #include "nsIPluginStreamListener.h"
    1: #include "nsIHTTPHeaderListener.h"
    1: #include "nsIHttpHeaderVisitor.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIHttpProtocolHandler.h"
    1: #include "nsIHttpChannel.h"
    1: #include "nsIHttpChannelInternal.h"
    1: #include "nsIUploadChannel.h"
    1: #include "nsIByteRangeRequest.h"
    1: #include "nsIStreamListener.h"
    1: #include "nsIInputStream.h"
    1: #include "nsIOutputStream.h"
    1: #include "nsIURL.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIProtocolProxyService.h"
    1: #include "nsIStreamConverterService.h"
    1: #include "nsIFile.h"
    1: #include "nsIInputStream.h"
    1: #include "nsIIOService.h"
    1: #include "nsIURL.h"
    1: #include "nsIChannel.h"
    1: #include "nsISeekableStream.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIProgressEventSink.h"
    1: #include "nsIDocument.h"
    1: #include "nsICachingChannel.h"
    1: #include "nsHashtable.h"
    1: #include "nsIProxyInfo.h"
    1: #include "nsPluginLogging.h"
    1: #include "nsIPrefBranch2.h"
    1: #include "nsIScriptChannel.h"
    1: #include "nsPrintfCString.h"
21189: #include "nsIBlocklistService.h"
21192: #include "nsVersionComparator.h"
24475: #include "nsIPrivateBrowsingService.h"
37151: #include "nsIObjectLoadingContent.h"
38026: #include "nsIWritablePropertyBag2.h"
47361: #include "nsPluginStreamListenerPeer.h"
    1: 
    1: #include "nsEnumeratorUtils.h"
    1: #include "nsXPCOM.h"
    1: #include "nsXPCOMCID.h"
    1: #include "nsISupportsPrimitives.h"
24790: 
59080: #include "nsIXULRuntime.h"
59080: 
    1: // for the dialog
    1: #include "nsIStringBundle.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsPIDOMWindow.h"
    1: 
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptGlobalObjectOwner.h"
    1: #include "nsIPrincipal.h"
    1: 
    1: #include "nsNetCID.h"
    1: #include "nsIDOMPlugin.h"
    1: #include "nsIDOMMimeType.h"
    1: #include "nsMimeTypes.h"
    1: #include "prprf.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsIInputStreamTee.h"
    1: #include "nsIInterfaceInfoManager.h"
    1: #include "xptinfo.h"
    1: 
    1: #include "nsIMIMEService.h"
    1: #include "nsCExternalHandlerService.h"
    1: #include "nsILocalFile.h"
    1: #include "nsIFileChannel.h"
    1: 
    1: #include "nsPluginSafety.h"
    1: 
    1: #include "nsICharsetConverterManager.h"
    1: #include "nsIPlatformCharset.h"
    1: 
    1: #include "nsIDirectoryService.h"
    1: #include "nsDirectoryServiceDefs.h"
32940: #include "nsXULAppAPI.h"
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsIFile.h"
    1: #include "nsPluginDirServiceProvider.h"
    1: #include "nsInt64.h"
    1: #include "nsPluginError.h"
    1: 
    1: #include "nsUnicharUtils.h"
    1: #include "nsPluginManifestLineReader.h"
    1: 
39118: #include "nsIWeakReferenceUtils.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMHTMLObjectElement.h"
    1: #include "nsIDOMHTMLEmbedElement.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsISupportsArray.h"
    1: #include "nsIDocShell.h"
    1: #include "nsPluginNativeWindow.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIContentPolicy.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsContentErrors.h"
37525: #include "mozilla/TimeStamp.h"
    1: 
24790: #if defined(XP_WIN)
56921: #include "nsIWindowMediator.h"
56921: #include "nsIBaseWindow.h"
24790: #include "windows.h"
24790: #include "winbase.h"
24790: #endif
24790: 
37525: using mozilla::TimeStamp;
37525: 
31646: // Null out a strong ref to a linked list iteratively to avoid
31646: // exhausting the stack (bug 486349).
31646: #define NS_ITERATIVE_UNREF_LIST(type_, list_, mNext_)                \
31646:   {                                                                  \
31646:     while (list_) {                                                  \
31646:       type_ temp = list_->mNext_;                                    \
31646:       list_->mNext_ = nsnull;                                        \
31646:       list_ = temp;                                                  \
31646:     }                                                                \
31646:   }
31646: 
    1: // this is the name of the directory which will be created
    1: // to cache temporary files.
    1: #define kPluginTmpDirName NS_LITERAL_CSTRING("plugtmp")
    1: 
    1: // Version of cached plugin info
    1: // 0.01 first implementation
    1: // 0.02 added caching of CanUnload to fix bug 105935
    1: // 0.03 changed name, description and mime desc from string to bytes, bug 108246
    1: // 0.04 added new mime entry point on Mac, bug 113464
    1: // 0.05 added new entry point check for the default plugin, bug 132430
    1: // 0.06 strip off suffixes in mime description strings, bug 53895
    1: // 0.07 changed nsIRegistry to flat file support for caching plugins info
    1: // 0.08 mime entry point on MachO, bug 137535
12841: // 0.09 the file encoding is changed to UTF-8, bug 420285
15947: // 0.10 added plugin versions on appropriate platforms, bug 427743
29020: // 0.11 file name and full path fields now store expected values on all platforms, bug 488181
57547: // 0.12 force refresh due to quicktime pdf claim fix, bug 611197
59080: // 0.13 add architecture and list of invalid plugins, bug 616271
21192: // The current plugin registry version (and the maximum version we know how to read)
59080: static const char *kPluginRegistryVersion = "0.13";
21192: // The minimum registry version we know how to read
21192: static const char *kMinimumRegistryVersion = "0.9";
21231: 
29952: static NS_DEFINE_IID(kIPluginTagInfoIID, NS_IPLUGINTAGINFO_IID);
    1: static const char kDirectoryServiceContractID[] = "@mozilla.org/file/directory_service;1";
    1: 
    1: // Registry keys for caching plugin info
    1: static const char kPluginsRootKey[] = "software/plugins";
    1: static const char kPluginsNameKey[] = "name";
    1: static const char kPluginsDescKey[] = "description";
    1: static const char kPluginsFilenameKey[] = "filename";
    1: static const char kPluginsFullpathKey[] = "fullpath";
    1: static const char kPluginsModTimeKey[] = "lastModTimeStamp";
    1: static const char kPluginsCanUnload[] = "canUnload";
    1: static const char kPluginsVersionKey[] = "version";
    1: static const char kPluginsMimeTypeKey[] = "mimetype";
    1: static const char kPluginsMimeDescKey[] = "description";
    1: static const char kPluginsMimeExtKey[] = "extension";
    1: 
    1: #define kPluginRegistryFilename NS_LITERAL_CSTRING("pluginreg.dat")
    1: 
    1: #ifdef PLUGIN_LOGGING
    1: PRLogModuleInfo* nsPluginLogging::gNPNLog = nsnull;
    1: PRLogModuleInfo* nsPluginLogging::gNPPLog = nsnull;
    1: PRLogModuleInfo* nsPluginLogging::gPluginLog = nsnull;
    1: #endif
    1: 
    1: #define BRAND_PROPERTIES_URL "chrome://branding/locale/brand.properties"
    1: #define PLUGIN_PROPERTIES_URL "chrome://global/locale/downloadProgress.properties"
    1: 
    1: // #defines for plugin cache and prefs
    1: #define NS_PREF_MAX_NUM_CACHED_PLUGINS "browser.plugins.max_num_cached_plugins"
    1: #define DEFAULT_NUMBER_OF_STOPPED_PLUGINS 10
    1: 
    1: #ifdef CALL_SAFETY_ON
    1: PRBool gSkipPluginSafeCalls = PR_FALSE;
    1: #endif
    1: 
29956: nsIFile *nsPluginHost::sPluginTempDir;
29956: nsPluginHost *nsPluginHost::sInst;
    1: 
59080: NS_IMPL_ISUPPORTS0(nsInvalidPluginTag)
59080: 
59080: nsInvalidPluginTag::nsInvalidPluginTag(const char* aFullPath, PRInt64 aLastModifiedTime)
59080: : mFullPath(aFullPath),
59080:   mLastModifiedTime(aLastModifiedTime),
59538:   mSeen(false)
59080: {
59080:   
59080: }
59080: 
59080: nsInvalidPluginTag::~nsInvalidPluginTag()
59080: {
59080:   
59080: }
59080: 
    1: // flat file reg funcs
    1: static
    1: PRBool ReadSectionHeader(nsPluginManifestLineReader& reader, const char *token)
    1: {
    1:   do {
    1:     if (*reader.LinePtr() == '[') {
    1:       char* p = reader.LinePtr() + (reader.LineLength() - 1);
    1:       if (*p != ']')
    1:         break;
    1:       *p = 0;
    1: 
    1:       char* values[1];
    1:       if (1 != reader.ParseLine(values, 1))
    1:         break;
    1:       // ignore the leading '['
    1:       if (PL_strcmp(values[0]+1, token)) {
    1:         break; // it's wrong token
    1:       }
    1:       return PR_TRUE;
    1:     }
    1:   } while (reader.NextLine());
    1:   return PR_FALSE;
    1: }
    1: 
    1: // Little helper struct to asynchronously reframe any presentations (embedded)
    1: // or reload any documents (full-page), that contained plugins
    1: // which were shutdown as a result of a plugins.refresh(1)
    1: class nsPluginDocReframeEvent: public nsRunnable {
    1: public:
    1:   nsPluginDocReframeEvent(nsISupportsArray* aDocs) { mDocs = aDocs; }
    1: 
    1:   NS_DECL_NSIRUNNABLE
    1: 
    1:   nsCOMPtr<nsISupportsArray> mDocs;
    1: };
    1: 
    1: NS_IMETHODIMP nsPluginDocReframeEvent::Run() {
    1:   NS_ENSURE_TRUE(mDocs, NS_ERROR_FAILURE);
    1: 
    1:   PRUint32 c;
    1:   mDocs->Count(&c);
    1: 
    1:   // for each document (which previously had a running instance), tell
    1:   // the frame constructor to rebuild
    1:   for (PRUint32 i = 0; i < c; i++) {
    1:     nsCOMPtr<nsIDocument> doc (do_QueryElementAt(mDocs, i));
    1:     if (doc) {
46225:       nsIPresShell *shell = doc->GetShell();
    1: 
    1:       // if this document has a presentation shell, then it has frames and can be reframed
    1:       if (shell) {
21231:         /* A reframe will cause a fresh object frame, instance owner, and instance
    1:          * to be created. Reframing of the entire document is necessary as we may have
    1:          * recently found new plugins and we want a shot at trying to use them instead
    1:          * of leaving alternate renderings.
    1:          * We do not want to completely reload all the documents that had running plugins
    1:          * because we could possibly trigger a script to run in the unload event handler
    1:          * which may want to access our defunct plugin and cause us to crash.
    1:          */
    1: 
    1:         shell->ReconstructFrames(); // causes reframe of document
    1:       } else {  // no pres shell --> full-page plugin
    1: 
    1:         NS_NOTREACHED("all plugins should have a pres shell!");
    1: 
    1:       }
    1:     }
    1:   }
    1: 
    1:   return mDocs->Clear();
    1: }
    1: 
50781: static PRBool UnloadPluginsASAP()
50781: {
50781:   nsresult rv;
50781:   nsCOMPtr<nsIPrefBranch> pref(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
50781:   if (NS_SUCCEEDED(rv)) {
50781:     PRBool unloadPluginsASAP = PR_FALSE;
50781:     rv = pref->GetBoolPref("plugins.unloadASAP", &unloadPluginsASAP);
50781:     if (NS_SUCCEEDED(rv)) {
50781:       return unloadPluginsASAP;
50781:     }
50781:   }
50781: 
50781:   return PR_FALSE;
50781: }
50781: 
24790: // helper struct for asynchronous handling of plugin unloading
    1: class nsPluginUnloadEvent : public nsRunnable {
    1: public:
    1:   nsPluginUnloadEvent(PRLibrary* aLibrary)
    1:     : mLibrary(aLibrary)
    1:   {}
    1:  
    1:   NS_DECL_NSIRUNNABLE
    1:  
    1:   PRLibrary* mLibrary;
    1: };
    1: 
    1: NS_IMETHODIMP nsPluginUnloadEvent::Run()
    1: {
    1:   if (mLibrary) {
24790:     // put our unload call in a safety wrapper
55810:     NS_TRY_SAFE_CALL_VOID(PR_UnloadLibrary(mLibrary), nsnull);
    1:   } else {
    1:     NS_WARNING("missing library from nsPluginUnloadEvent");
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // unload plugin asynchronously if possible, otherwise just unload now
36266: nsresult nsPluginHost::PostPluginUnloadEvent(PRLibrary* aLibrary)
    1: {
    1:   nsCOMPtr<nsIRunnable> ev = new nsPluginUnloadEvent(aLibrary);
    1:   if (ev && NS_SUCCEEDED(NS_DispatchToCurrentThread(ev)))
    1:     return NS_OK;
    1: 
    1:   // failure case
55810:   NS_TRY_SAFE_CALL_VOID(PR_UnloadLibrary(aLibrary), nsnull);
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
29956: nsPluginHost::nsPluginHost()
31646:   // No need to initialize members to nsnull, PR_FALSE etc because this class
31646:   // has a zeroing operator new.
31800: {
    1:   // check to see if pref is set at startup to let plugins take over in
    1:   // full page mode for certain image mime types that we handle internally
    1:   mPrefService = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:   if (mPrefService) {
    1:     PRBool tmp;
    1:     nsresult rv = mPrefService->GetBoolPref("plugin.override_internal_types",
    1:                                             &tmp);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       mOverrideInternalTypes = tmp;
    1:     }
    1: 
37523:     rv = mPrefService->GetBoolPref("plugin.disable", &tmp);
37523:     if (NS_SUCCEEDED(rv)) {
37523:       mPluginsDisabled = tmp;
37523:     }
    1:   }
    1: 
41540:   nsCOMPtr<nsIObserverService> obsService =
41540:     mozilla::services::GetObserverService();
24475:   if (obsService) {
    1:     obsService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, PR_FALSE);
24475:     obsService->AddObserver(this, NS_PRIVATE_BROWSING_SWITCH_TOPIC, PR_FALSE);
    1:   }
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   nsPluginLogging::gNPNLog = PR_NewLogModule(NPN_LOG_NAME);
    1:   nsPluginLogging::gNPPLog = PR_NewLogModule(NPP_LOG_NAME);
    1:   nsPluginLogging::gPluginLog = PR_NewLogModule(PLUGIN_LOG_NAME);
    1: 
    1:   PR_LOG(nsPluginLogging::gNPNLog, PLUGIN_LOG_ALWAYS,("NPN Logging Active!\n"));
29956:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_ALWAYS,("General Plugin Logging Active! (nsPluginHost::ctor)\n"));
    1:   PR_LOG(nsPluginLogging::gNPPLog, PLUGIN_LOG_ALWAYS,("NPP Logging Active!\n"));
    1: 
29956:   PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("nsPluginHost::ctor\n"));
    1:   PR_LogFlush();
    1: #endif
36227: 
36227: #ifdef MAC_CARBON_PLUGINS
36227:   mVisiblePluginTimer = do_CreateInstance("@mozilla.org/timer;1");
36227:   mHiddenPluginTimer = do_CreateInstance("@mozilla.org/timer;1");
36227: #endif
    1: }
    1: 
29956: nsPluginHost::~nsPluginHost()
29956: {
29956:   PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("nsPluginHost::dtor\n"));
    1: 
    1:   Destroy();
    1:   sInst = nsnull;
    1: }
    1: 
36297: NS_IMPL_ISUPPORTS4(nsPluginHost,
    1:                    nsIPluginHost,
    1:                    nsIObserver,
36297:                    nsITimerCallback,
    1:                    nsISupportsWeakReference)
21231: 
29956: nsPluginHost*
29956: nsPluginHost::GetInst()
    1: {
    1:   if (!sInst) {
29956:     sInst = new nsPluginHost();
21231:     if (!sInst)
    1:       return nsnull;
    1:     NS_ADDREF(sInst);
    1:   }
    1: 
    1:   NS_ADDREF(sInst);
    1:   return sInst;
    1: }
    1: 
29956: PRBool nsPluginHost::IsRunningPlugin(nsPluginTag * plugin)
    1: {
    1:   if (!plugin)
    1:     return PR_FALSE;
    1: 
    1:   for (int i = 0; i < plugin->mVariants; i++) {
47965:     nsNPAPIPluginInstance *instance = FindInstance(plugin->mMimeTypeArray[i]);
47965:     if (instance && instance->IsRunning())
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
29956: nsresult nsPluginHost::ReloadPlugins(PRBool reloadPages)
    1: {
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
29956:   ("nsPluginHost::ReloadPlugins Begin reloadPages=%d, active_instance_count=%d\n",
47965:   reloadPages, mInstances.Length()));
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   // this will create the initial plugin list out of cache
    1:   // if it was not created yet
    1:   if (!mPluginsLoaded)
    1:     return LoadPlugins();
    1: 
    1:   // we are re-scanning plugins. New plugins may have been added, also some
    1:   // plugins may have been removed, so we should probably shut everything down
    1:   // but don't touch running (active and  not stopped) plugins
    1: 
    1:   // check if plugins changed, no need to do anything else
    1:   // if no changes to plugins have been made
    1:   // PR_FALSE instructs not to touch the plugin list, just to
    1:   // look for possible changes
    1:   PRBool pluginschanged = PR_TRUE;
    1:   FindPlugins(PR_FALSE, &pluginschanged);
    1: 
    1:   // if no changed detected, return an appropriate error code
    1:   if (!pluginschanged)
    1:     return NS_ERROR_PLUGINS_PLUGINSNOTCHANGED;
    1: 
    1:   nsCOMPtr<nsISupportsArray> instsToReload;
    1:   if (reloadPages) {
    1:     NS_NewISupportsArray(getter_AddRefs(instsToReload));
    1: 
    1:     // Then stop any running plugin instances but hold on to the documents in the array
    1:     // We are going to need to restart the instances in these documents later
47965:     DestroyRunningInstances(instsToReload, nsnull);
37525:   }
    1: 
    1:   // shutdown plugins and kill the list if there are no running plugins
 3102:   nsRefPtr<nsPluginTag> prev;
 3102:   nsRefPtr<nsPluginTag> next;
 3102: 
 3102:   for (nsRefPtr<nsPluginTag> p = mPlugins; p != nsnull;) {
    1:     next = p->mNext;
    1: 
29079:     // only remove our plugin from the list if it's not running.
29079:     if (!IsRunningPlugin(p)) {
    1:       if (p == mPlugins)
    1:         mPlugins = next;
    1:       else
    1:         prev->mNext = next;
    1: 
 3102:       p->mNext = nsnull;
35426: 
35426:       // attempt to unload plugins whenever they are removed from the list
35426:       p->TryUnloadPlugin();
35426: 
    1:       p = next;
    1:       continue;
    1:     }
    1: 
    1:     prev = p;
    1:     p = next;
    1:   }
    1: 
    1:   // set flags
    1:   mPluginsLoaded = PR_FALSE;
    1: 
    1:   // load them again
    1:   rv = LoadPlugins();
    1: 
    1:   // If we have shut down any plugin instances, we've now got to restart them.
    1:   // Post an event to do the rest as we are going to be destroying the frame tree and we also want
    1:   // any posted unload events to finish
    1:   PRUint32 c;
    1:   if (reloadPages &&
    1:       instsToReload &&
    1:       NS_SUCCEEDED(instsToReload->Count(&c)) &&
    1:       c > 0) {
    1:     nsCOMPtr<nsIRunnable> ev = new nsPluginDocReframeEvent(instsToReload);
    1:     if (ev)
    1:       NS_DispatchToCurrentThread(ev);
    1:   }
    1: 
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
29956:   ("nsPluginHost::ReloadPlugins End active_instance_count=%d\n",
47965:   mInstances.Length()));
    1: 
    1:   return rv;
    1: }
    1: 
    1: #define NS_RETURN_UASTRING_SIZE 128
    1: 
29956: nsresult nsPluginHost::UserAgent(const char **retstring)
    1: {
    1:   static char resultString[NS_RETURN_UASTRING_SIZE];
    1:   nsresult res;
    1: 
    1:   nsCOMPtr<nsIHttpProtocolHandler> http = do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &res);
    1:   if (NS_FAILED(res))
    1:     return res;
    1: 
    1:   nsCAutoString uaString;
    1:   res = http->GetUserAgent(uaString);
    1: 
21231:   if (NS_SUCCEEDED(res)) {
21231:     if (NS_RETURN_UASTRING_SIZE > uaString.Length()) {
    1:       PL_strcpy(resultString, uaString.get());
21231:     } else {
16368:       // Copy as much of UA string as we can (terminate at right-most space).
16368:       PL_strncpy(resultString, uaString.get(), NS_RETURN_UASTRING_SIZE);
21231:       for (int i = NS_RETURN_UASTRING_SIZE - 1; i >= 0; i--) {
21231:         if (i == 0) {
16368:           resultString[NS_RETURN_UASTRING_SIZE - 1] = '\0';
21231:         }
21231:         else if (resultString[i] == ' ') {
16368:           resultString[i] = '\0';
16368:           break;
16368:         }
16368:       }
16368:     }
    1:     *retstring = resultString;
    1:   }
21231:   else {
    1:     *retstring = nsnull;
21231:   }
    1: 
29956:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHost::UserAgent return=%s\n", *retstring));
    1: 
    1:   return res;
    1: }
    1: 
29956: nsresult nsPluginHost::GetPrompt(nsIPluginInstanceOwner *aOwner, nsIPrompt **aPrompt)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIPrompt> prompt;
    1:   nsCOMPtr<nsIWindowWatcher> wwatch = do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
    1: 
    1:   if (wwatch) {
    1:     nsCOMPtr<nsIDOMWindow> domWindow;
    1:     if (aOwner) {
    1:       nsCOMPtr<nsIDocument> document;
    1:       aOwner->GetDocument(getter_AddRefs(document));
    1:       if (document) {
    1:         domWindow = document->GetWindow();
    1:       }
    1:     }
    1: 
    1:     if (!domWindow) {
    1:       wwatch->GetWindowByName(NS_LITERAL_STRING("_content").get(), nsnull, getter_AddRefs(domWindow));
    1:     }
    1:     rv = wwatch->GetNewPrompter(domWindow, getter_AddRefs(prompt));
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aPrompt = prompt);
    1:   return rv;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::GetURL(nsISupports* pluginInst,
    1:                                    const char* url,
    1:                                    const char* target,
    1:                                    nsIPluginStreamListener* streamListener,
    1:                                    const char* altHost,
    1:                                    const char* referrer,
    1:                                    PRBool forceJSEnabled)
    1: {
47835:   return GetURLWithHeaders(static_cast<nsNPAPIPluginInstance*>(pluginInst),
47835:                            url, target, streamListener, altHost, referrer,
47835:                            forceJSEnabled, nsnull, nsnull);
47835: }
47835: 
47835: nsresult nsPluginHost::GetURLWithHeaders(nsNPAPIPluginInstance* pluginInst,
    1:                                          const char* url,
    1:                                          const char* target,
    1:                                          nsIPluginStreamListener* streamListener,
    1:                                          const char* altHost,
    1:                                          const char* referrer,
    1:                                          PRBool forceJSEnabled,
    1:                                          PRUint32 getHeadersLength,
    1:                                          const char* getHeaders)
    1: {
21231:   nsAutoString string;
21231:   string.AssignWithConversion(url);
    1: 
    1:   // we can only send a stream back to the plugin (as specified by a
    1:   // null target) if we also have a nsIPluginStreamListener to talk to
21231:   if (!target && !streamListener)
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1: 
47835:   nsresult rv = DoURLLoadSecurityCheck(pluginInst, url);
34262:   if (NS_FAILED(rv))
34262:     return rv;
34262: 
21231:   if (target) {
    1:     nsCOMPtr<nsIPluginInstanceOwner> owner;
47835:     rv = pluginInst->GetOwner(getter_AddRefs(owner));
21231:     if (owner) {
    1:       if ((0 == PL_strcmp(target, "newwindow")) ||
    1:           (0 == PL_strcmp(target, "_new")))
    1:         target = "_blank";
    1:       else if (0 == PL_strcmp(target, "_current"))
    1:         target = "_self";
    1: 
36766:       rv = owner->GetURL(url, target, nsnull, nsnull, 0);
    1:     }
    1:   }
    1: 
34262:   if (streamListener)
47835:     rv = NewPluginURLStream(string, pluginInst, streamListener, nsnull,
36766:                             getHeaders, getHeadersLength);
    1: 
    1:   return rv;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::PostURL(nsISupports* pluginInst,
    1:                                     const char* url,
    1:                                     PRUint32 postDataLen,
    1:                                     const char* postData,
    1:                                     PRBool isFile,
    1:                                     const char* target,
    1:                                     nsIPluginStreamListener* streamListener,
    1:                                     const char* altHost,
    1:                                     const char* referrer,
    1:                                     PRBool forceJSEnabled,
    1:                                     PRUint32 postHeadersLength,
    1:                                     const char* postHeaders)
    1: {
34262:   nsAutoString string;
    1:   nsresult rv;
    1: 
34262:   string.AssignWithConversion(url);
34262: 
    1:   // we can only send a stream back to the plugin (as specified
    1:   // by a null target) if we also have a nsIPluginStreamListener
    1:   // to talk to also
21231:   if (!target && !streamListener)
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1: 
47835:   nsNPAPIPluginInstance* instance = static_cast<nsNPAPIPluginInstance*>(pluginInst);
34262: 
    1:   rv = DoURLLoadSecurityCheck(instance, url);
34262:   if (NS_FAILED(rv))
34262:     return rv;
34262: 
36766:   nsCOMPtr<nsIInputStream> postStream;
    1:   if (isFile) {
36766:     nsCOMPtr<nsIFile> file;
36766:     rv = CreateTempFileToPost(postData, getter_AddRefs(file));
36766:     if (NS_FAILED(rv))
36766:       return rv;
36766: 
36766:     nsCOMPtr<nsIInputStream> fileStream;
36766:     rv = NS_NewLocalFileInputStream(getter_AddRefs(fileStream),
36766:                                     file,
36766:                                     PR_RDONLY,
36766:                                     0600,
36766:                                     nsIFileInputStream::DELETE_ON_CLOSE |
36766:                                     nsIFileInputStream::CLOSE_ON_EOF);
36766:     if (NS_FAILED(rv))
36766:       return rv;
36766: 
36766:     rv = NS_NewBufferedInputStream(getter_AddRefs(postStream), fileStream, 8192);
36766:     if (NS_FAILED(rv))
21231:       return rv;
    1:   } else {
36766:     char *dataToPost;
    1:     PRUint32 newDataToPostLen;
    1:     ParsePostBufferToFixHeaders(postData, postDataLen, &dataToPost, &newDataToPostLen);
    1:     if (!dataToPost)
    1:       return NS_ERROR_UNEXPECTED;
    1: 
36766:     nsCOMPtr<nsIStringInputStream> sis = do_CreateInstance("@mozilla.org/io/string-input-stream;1", &rv);
36766:     if (!sis) {
36766:       NS_Free(dataToPost);
36766:       return rv;
36766:     }
36766: 
36766:     // data allocated by ParsePostBufferToFixHeaders() is managed and
36766:     // freed by the string stream.
    1:     postDataLen = newDataToPostLen;
36766:     sis->AdoptData(dataToPost, postDataLen);
36766:     postStream = sis;
    1:   }
    1: 
21231:   if (target) {
    1:     nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:     rv = instance->GetOwner(getter_AddRefs(owner));
21231:     if (owner) {
    1:       if ((0 == PL_strcmp(target, "newwindow")) ||
21231:           (0 == PL_strcmp(target, "_new"))) {
    1:         target = "_blank";
29834:       } else if (0 == PL_strcmp(target, "_current")) {
    1:         target = "_self";
    1:       }
36766:       rv = owner->GetURL(url, target, postStream,
36766:                          (void*)postHeaders, postHeadersLength);
    1:     }
    1:   }
    1: 
    1:   // if we don't have a target, just create a stream.  This does
    1:   // NS_OpenURI()!
21231:   if (streamListener)
    1:     rv = NewPluginURLStream(string, instance, streamListener,
36766:                             postStream, postHeaders, postHeadersLength);
    1: 
    1:   return rv;
    1: }
    1: 
21231: /* This method queries the prefs for proxy information.
    1:  * It has been tested and is known to work in the following three cases
    1:  * when no proxy host or port is specified
    1:  * when only the proxy host is specified
    1:  * when only the proxy port is specified
    1:  * This method conforms to the return code specified in
    1:  * http://developer.netscape.com/docs/manuals/proxy/adminnt/autoconf.htm#1020923
    1:  * with the exception that multiple values are not implemented.
    1:  */
    1: 
29956: NS_IMETHODIMP nsPluginHost::FindProxyForURL(const char* url, char* *result)
    1: {
    1:   if (!url || !result) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1:   nsresult res;
    1: 
    1:   nsCOMPtr<nsIURI> uriIn;
    1:   nsCOMPtr<nsIProtocolProxyService> proxyService;
    1:   nsCOMPtr<nsIIOService> ioService;
    1: 
    1:   proxyService = do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &res);
21231:   if (NS_FAILED(res) || !proxyService)
    1:     return res;
    1: 
    1:   ioService = do_GetService(NS_IOSERVICE_CONTRACTID, &res);
21231:   if (NS_FAILED(res) || !ioService)
    1:     return res;
    1: 
    1:   // make an nsURI from the argument url
    1:   res = ioService->NewURI(nsDependentCString(url), nsnull, nsnull, getter_AddRefs(uriIn));
21231:   if (NS_FAILED(res))
    1:     return res;
    1: 
    1:   nsCOMPtr<nsIProxyInfo> pi;
    1: 
    1:   res = proxyService->Resolve(uriIn, 0, getter_AddRefs(pi));
21231:   if (NS_FAILED(res))
    1:     return res;
    1: 
    1:   nsCAutoString host, type;
    1:   PRInt32 port = -1;
    1: 
    1:   // These won't fail, and even if they do... we'll be ok.
    1:   if (pi) {
    1:     pi->GetType(type);
    1:     pi->GetHost(host);
    1:     pi->GetPort(&port);
    1:   }
    1: 
    1:   if (!pi || host.IsEmpty() || port <= 0 || host.EqualsLiteral("direct")) {
    1:     *result = PL_strdup("DIRECT");
    1:   } else if (type.EqualsLiteral("http")) {
    1:     *result = PR_smprintf("PROXY %s:%d", host.get(), port);
    1:   } else if (type.EqualsLiteral("socks4")) {
    1:     *result = PR_smprintf("SOCKS %s:%d", host.get(), port);
    1:   } else if (type.EqualsLiteral("socks")) {
    1:     // XXX - this is socks5, but there is no API for us to tell the
    1:     // plugin that fact. SOCKS for now, in case the proxy server
    1:     // speaks SOCKS4 as well. See bug 78176
    1:     // For a long time this was returning an http proxy type, so
    1:     // very little is probably broken by this
    1:     *result = PR_smprintf("SOCKS %s:%d", host.get(), port);
    1:   } else {
    1:     NS_ASSERTION(PR_FALSE, "Unknown proxy type!");
    1:     *result = PL_strdup("DIRECT");
    1:   }
    1: 
21231:   if (nsnull == *result)
    1:     res = NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   return res;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::Init()
    1: {
    1:   return NS_OK;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::Destroy()
29956: {
29956:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHost::Destroy Called\n"));
    1: 
    1:   if (mIsDestroyed)
    1:     return NS_OK;
    1: 
    1:   mIsDestroyed = PR_TRUE;
    1: 
    1:   // we should call nsIPluginInstance::Stop and nsIPluginInstance::SetWindow
    1:   // for those plugins who want it
47965:   DestroyRunningInstances(nsnull, nsnull);
    1: 
35426:   nsPluginTag *pluginTag;
35426:   for (pluginTag = mPlugins; pluginTag; pluginTag = pluginTag->mNext) {
35426:     pluginTag->TryUnloadPlugin();
    1:   }
    1: 
31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mPlugins, mNext);
31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
59080:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
    1: 
    1:   // Lets remove any of the temporary files that we created.
    1:   if (sPluginTempDir) {
    1:     sPluginTempDir->Remove(PR_TRUE);
    1:     NS_RELEASE(sPluginTempDir);
    1:   }
    1: 
 3715: #ifdef XP_WIN
21231:   if (mPrivateDirServiceProvider) {
    1:     nsCOMPtr<nsIDirectoryService> dirService =
    1:       do_GetService(kDirectoryServiceContractID);
    1:     if (dirService)
    1:       dirService->UnregisterProvider(mPrivateDirServiceProvider);
    1:     mPrivateDirServiceProvider = nsnull;
    1:   }
 3715: #endif /* XP_WIN */
    1: 
    1:   mPrefService = nsnull; // release prefs service to avoid leaks!
    1: 
    1:   return NS_OK;
    1: }
    1: 
37525: void nsPluginHost::OnPluginInstanceDestroyed(nsPluginTag* aPluginTag)
37525: {
37525:   PRBool hasInstance = PR_FALSE;
47965:   for (PRUint32 i = 0; i < mInstances.Length(); i++) {
47965:     if (TagForPlugin(mInstances[i]->GetPlugin()) == aPluginTag) {
37525:       hasInstance = PR_TRUE;
37525:       break;
37525:     }
37525:   }
37525: 
50781:   if (!hasInstance && UnloadPluginsASAP()) {
37525:     aPluginTag->TryUnloadPlugin();
37525:   }
37525: }
37525: 
    1: nsresult
29956: nsPluginHost::GetPluginTempDir(nsIFile **aDir)
    1: {
    1:   if (!sPluginTempDir) {
    1:     nsCOMPtr<nsIFile> tmpDir;
    1:     nsresult rv = NS_GetSpecialDirectory(NS_OS_TEMP_DIR,
    1:                                          getter_AddRefs(tmpDir));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = tmpDir->AppendNative(kPluginTmpDirName);
    1: 
    1:     // make it unique, and mode == 0700, not world-readable
    1:     rv = tmpDir->CreateUnique(nsIFile::DIRECTORY_TYPE, 0700);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     tmpDir.swap(sPluginTempDir);
    1:   }
    1: 
    1:   return sPluginTempDir->Clone(aDir);
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::InstantiatePluginForChannel(nsIChannel* aChannel,
    1:                                                         nsIPluginInstanceOwner* aOwner,
    1:                                                         nsIStreamListener** aListener)
    1: {
    1:   NS_PRECONDITION(aChannel && aOwner,
    1:                   "Invalid arguments to InstantiatePluginForChannel");
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsresult rv = aChannel->GetURI(getter_AddRefs(uri));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   if (PR_LOG_TEST(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL)) {
    1:     nsCAutoString urlSpec;
    1:     uri->GetAsciiSpec(urlSpec);
    1: 
    1:     PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
29956:            ("nsPluginHost::InstantiatePluginForChannel Begin owner=%p, url=%s\n",
    1:            aOwner, urlSpec.get()));
    1: 
    1:     PR_LogFlush();
    1:   }
    1: #endif
    1: 
56390:   // Note that we're not setting up a plugin instance here; the stream
56390:   // listener's OnStartRequest will handle doing that, looking for
56390:   // stopped plugins, etc, etc.
    1: 
    1:   return NewEmbeddedPluginStreamListener(uri, aOwner, nsnull, aListener);
    1: }
    1: 
36227: // Called by nsPluginInstanceOwner
29956: NS_IMETHODIMP nsPluginHost::InstantiateEmbeddedPlugin(const char *aMimeType,
    1:                                                       nsIURI* aURL,
    1:                                                       nsIPluginInstanceOwner *aOwner)
    1: {
56390:   return DoInstantiateEmbeddedPlugin(aMimeType, aURL, aOwner, PR_TRUE);
56390: }
56390: 
56390: nsresult
56390: nsPluginHost::DoInstantiateEmbeddedPlugin(const char *aMimeType, nsIURI* aURL,
56390:                                           nsIPluginInstanceOwner* aOwner,
56390:                                           PRBool aAllowOpeningStreams)
56390: {
    1:   NS_ENSURE_ARG_POINTER(aOwner);
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec;
21231:   if (aURL)
21231:     aURL->GetAsciiSpec(urlSpec);
    1: 
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
29956:         ("nsPluginHost::InstantiateEmbeddedPlugin Begin mime=%s, owner=%p, url=%s\n",
    1:         aMimeType, aOwner, urlSpec.get()));
    1: 
    1:   PR_LogFlush();
    1: #endif
    1: 
    1:   nsresult rv;
29952:   nsCOMPtr<nsIPluginTagInfo> pti;
    1:   nsPluginTagType tagType;
    1: 
29952:   rv = aOwner->QueryInterface(kIPluginTagInfoIID, getter_AddRefs(pti));
    1: 
21231:   if (rv != NS_OK)
    1:     return rv;
    1: 
29952:   rv = pti->GetTagType(&tagType);
    1: 
    1:   if ((rv != NS_OK) || !((tagType == nsPluginTagType_Embed)
    1:                         || (tagType == nsPluginTagType_Applet)
21231:                         || (tagType == nsPluginTagType_Object))) {
    1:     return rv;
    1:   }
    1: 
    1:   // Security checks
    1:   // Can't do security checks without a URI - hopefully the plugin will take
    1:   // care of that
56390:   // No need to do the security check if aAllowOpeningStreams is
56390:   // false; we don't plan to do any network access in that case.
56390:   // Furthermore, doing it could reenter plugin instantiation, which
56390:   // would be Bad.
56390:   if (aURL && aAllowOpeningStreams) {
    1:     nsCOMPtr<nsIScriptSecurityManager> secMan =
    1:                     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
    1:     if (NS_FAILED(rv))
    1:       return rv; // Better fail if we can't do security checks
    1: 
    1:     nsCOMPtr<nsIDocument> doc;
    1:     aOwner->GetDocument(getter_AddRefs(doc));
    1:     if (!doc)
    1:       return NS_ERROR_NULL_POINTER;
    1: 
    1:     rv = secMan->CheckLoadURIWithPrincipal(doc->NodePrincipal(), aURL, 0);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCOMPtr<nsIDOMElement> elem;
29952:     pti->GetDOMElement(getter_AddRefs(elem));
    1: 
    1:     PRInt16 shouldLoad = nsIContentPolicy::ACCEPT; // default permit
    1:     nsresult rv =
    1:       NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OBJECT,
    1:                                 aURL,
 4367:                                 doc->NodePrincipal(),
    1:                                 elem,
    1:                                 nsDependentCString(aMimeType ? aMimeType : ""),
    1:                                 nsnull, //extra
    1:                                 &shouldLoad);
    1:     if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad))
    1:       return NS_ERROR_CONTENT_BLOCKED_SHOW_ALT;
    1:   }
    1: 
48850:   PRBool isJava = PR_FALSE;
48850:   nsPluginTag* pluginTag = FindPluginForType(aMimeType, PR_TRUE);
    1:   if (pluginTag) {
48850:     isJava = pluginTag->mIsJavaPlugin;
48850:   }
    1: 
    1:   // Determine if the scheme of this URL is one we can handle internaly because we should
    1:   // only open the initial stream if it's one that we can handle internally. Otherwise
    1:   // |NS_OpenURI| in |InstantiateEmbeddedPlugin| may open up a OS protocal registered helper app
56390:   // Also set bCanHandleInternally to true if aAllowOpeningStreams is
56390:   // false; we don't want to do any network traffic in that case.
    1:   PRBool bCanHandleInternally = PR_FALSE;
    1:   nsCAutoString scheme;
56390:   if (aURL && aAllowOpeningStreams && NS_SUCCEEDED(aURL->GetScheme(scheme))) {
    1:       nsCAutoString contractID(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX);
    1:       contractID += scheme;
    1:       ToLowerCase(contractID);
    1:       nsCOMPtr<nsIProtocolHandler> handler = do_GetService(contractID.get());
    1:       if (handler)
    1:         bCanHandleInternally = PR_TRUE;
    1:   }
    1: 
    1:   if (FindStoppedPluginForURL(aURL, aOwner) == NS_OK) {
    1:     PLUGIN_LOG(PLUGIN_LOG_NOISY,
29956:     ("nsPluginHost::InstantiateEmbeddedPlugin FoundStopped mime=%s\n", aMimeType));
    1: 
47835:     nsCOMPtr<nsIPluginInstance> instanceCOMPtr;
47835:     aOwner->GetInstance(getter_AddRefs(instanceCOMPtr));
47835:     nsNPAPIPluginInstance *instance = static_cast<nsNPAPIPluginInstance*>(instanceCOMPtr.get());
    1:     if (!isJava && bCanHandleInternally)
    1:       rv = NewEmbeddedPluginStream(aURL, aOwner, instance);
    1: 
47835:     return NS_OK;
47835:   }
47835: 
47835:   // if we don't have a MIME type at this point, we still have one more chance by
47835:   // opening the stream and seeing if the server hands one back
47835:   if (!aMimeType)
47835:     return bCanHandleInternally ? NewEmbeddedPluginStream(aURL, aOwner, nsnull) : NS_ERROR_FAILURE;
47835: 
47835:   rv = SetUpPluginInstance(aMimeType, aURL, aOwner);
47835: 
47835:   if (NS_FAILED(rv))
47835:     return NS_ERROR_FAILURE;
47835: 
47835:   nsCOMPtr<nsIPluginInstance> instanceCOMPtr;
47835:   rv = aOwner->GetInstance(getter_AddRefs(instanceCOMPtr));
47835:   // if we have a failure error, it means we found a plugin for the mimetype,
47835:   // but we had a problem with the entry point
47835:   if (rv == NS_ERROR_FAILURE)
47835:     return rv;
47835: 
47835:   // if we are here then we have loaded a plugin for this mimetype
47835:   nsNPAPIPluginInstance *instance = static_cast<nsNPAPIPluginInstance*>(instanceCOMPtr.get());
47835: 
47835:   if (instance) {
47835:     instance->Start();
47835:     aOwner->CreateWidget();
47835: 
47835:     // If we've got a native window, the let the plugin know about it.
58796:     nsCOMPtr<nsIPluginInstanceOwner_MOZILLA_2_0_BRANCH> owner = do_QueryInterface(aOwner);
58796:     if (owner)
58796:       owner->SetWindow();
47835: 
47835:     // create an initial stream with data
47835:     // don't make the stream if it's a java applet or we don't have SRC or DATA attribute
47835:     PRBool havedata = PR_FALSE;
47835: 
47835:     nsCOMPtr<nsIPluginTagInfo> pti(do_QueryInterface(aOwner, &rv));
47835: 
47835:     if (pti) {
47835:       const char *value;
47835:       havedata = NS_SUCCEEDED(pti->GetAttribute("SRC", &value));
47835:       // no need to check for "data" as it would have been converted to "src"
47835:     }
47835: 
47835:     if (havedata && !isJava && bCanHandleInternally)
47835:       rv = NewEmbeddedPluginStream(aURL, aOwner, instance);
    1:   }
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec2;
29956:   if (aURL != nsnull) aURL->GetAsciiSpec(urlSpec2);
    1: 
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
29956:         ("nsPluginHost::InstantiateEmbeddedPlugin Finished mime=%s, rv=%d, owner=%p, url=%s\n",
    1:         aMimeType, rv, aOwner, urlSpec2.get()));
    1: 
    1:   PR_LogFlush();
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
21231: // Called by full-page case
29956: NS_IMETHODIMP nsPluginHost::InstantiateFullPagePlugin(const char *aMimeType,
    1:                                                       nsIURI* aURI,
47865:                                                       nsIPluginInstanceOwner *aOwner,
47865:                                                       nsIStreamListener **aStreamListener)
    1: {
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec;
    1:   aURI->GetSpec(urlSpec);
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
29956:   ("nsPluginHost::InstantiateFullPagePlugin Begin mime=%s, owner=%p, url=%s\n",
    1:   aMimeType, aOwner, urlSpec.get()));
    1: #endif
    1: 
    1:   if (FindStoppedPluginForURL(aURI, aOwner) == NS_OK) {
    1:     PLUGIN_LOG(PLUGIN_LOG_NOISY,
29956:     ("nsPluginHost::InstantiateFullPagePlugin FoundStopped mime=%s\n",aMimeType));
    1: 
47835: 
    1:     nsPluginTag* pluginTag = FindPluginForType(aMimeType, PR_TRUE);
47835:     if (!pluginTag || !pluginTag->mIsJavaPlugin) {
47835:       nsCOMPtr<nsIPluginInstance> instanceCOMPtr;
47835:       aOwner->GetInstance(getter_AddRefs(instanceCOMPtr));
47865:       NewFullPagePluginStream(aURI, static_cast<nsNPAPIPluginInstance*>(instanceCOMPtr.get()), aStreamListener);
47835:     }
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv = SetUpPluginInstance(aMimeType, aURI, aOwner);
    1: 
21231:   if (NS_OK == rv) {
47835:     nsCOMPtr<nsIPluginInstance> instanceCOMPtr;
47835:     aOwner->GetInstance(getter_AddRefs(instanceCOMPtr));
47835:     nsNPAPIPluginInstance *instance = static_cast<nsNPAPIPluginInstance*>(instanceCOMPtr.get());
47835: 
32799:     NPWindow* win = nsnull;
    1:     aOwner->GetWindow(win);
    1: 
21231:     if (win && instance) {
    1:       instance->Start();
    1:       aOwner->CreateWidget();
    1: 
    1:       // If we've got a native window, the let the plugin know about it.
58796:       nsCOMPtr<nsIPluginInstanceOwner_MOZILLA_2_0_BRANCH> owner = do_QueryInterface(aOwner);
58796:       if (owner)
58796:         owner->SetWindow();
    1: 
47865:       rv = NewFullPagePluginStream(aURI, instance, aStreamListener);
    1: 
    1:       // If we've got a native window, the let the plugin know about it.
58796:       if (owner)
58796:         owner->SetWindow();
    1:     }
    1:   }
    1: 
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
29956:   ("nsPluginHost::InstantiateFullPagePlugin End mime=%s, rv=%d, owner=%p, url=%s\n",
    1:   aMimeType, rv, aOwner, urlSpec.get()));
    1: 
    1:   return rv;
    1: }
    1: 
37199: nsPluginTag*
40216: nsPluginHost::FindTagForLibrary(PRLibrary* aLibrary)
40216: {
40216:   nsPluginTag* pluginTag;
40216:   for (pluginTag = mPlugins; pluginTag; pluginTag = pluginTag->mNext) {
40216:     if (pluginTag->mLibrary == aLibrary) {
40216:       return pluginTag;
40216:     }
40216:   }
40216:   return nsnull;
40216: }
40216: 
40216: nsPluginTag*
47965: nsPluginHost::TagForPlugin(nsNPAPIPlugin* aPlugin)
37199: {
37199:   nsPluginTag* pluginTag;
37199:   for (pluginTag = mPlugins; pluginTag; pluginTag = pluginTag->mNext) {
37199:     if (pluginTag->mEntryPoint == aPlugin) {
37199:       return pluginTag;
37199:     }
37199:   }
47965:   // a plugin should never exist without a corresponding tag
59645:   NS_ASSERTION(PR_FALSE, "TagForPlugin has failed");
37199:   return nsnull;
37199: }
37199: 
29956: nsresult nsPluginHost::FindStoppedPluginForURL(nsIURI* aURL,
    1:                                                nsIPluginInstanceOwner *aOwner)
    1: {
    1:   nsCAutoString url;
    1:   if (!aURL)
    1:     return NS_ERROR_FAILURE;
    1: 
21231:   aURL->GetAsciiSpec(url);
    1: 
47965:   nsNPAPIPluginInstance *instance = FindStoppedInstance(url.get());
47965:   if (instance && !instance->IsRunning()) {
    1:     aOwner->SetInstance(instance);
29834:     instance->SetOwner(aOwner);
    1: 
    1:     instance->Start();
    1:     aOwner->CreateWidget();
    1: 
    1:     // If we've got a native window, the let the plugin know about it.
58796:     nsCOMPtr<nsIPluginInstanceOwner_MOZILLA_2_0_BRANCH> owner = do_QueryInterface(aOwner);
58796:     if (owner)
58796:       owner->SetWindow();
    1: 
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::SetUpPluginInstance(const char *aMimeType,
    1:                                                 nsIURI *aURL,
    1:                                                 nsIPluginInstanceOwner *aOwner)
    1: {
59670:   NS_ENSURE_ARG_POINTER(aOwner);
59670: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   rv = TrySetUpPluginInstance(aMimeType, aURL, aOwner);
    1: 
    1:   // if we fail, refresh plugin list just in case the plugin has been
    1:   // just added and try to instantiate plugin instance again, see bug 143178
    1:   if (NS_FAILED(rv)) {
    1:     // we should also make sure not to do this more than once per page
    1:     // so if there are a few embed tags with unknown plugins,
    1:     // we don't get unnecessary overhead
    1:     // let's cache document to decide whether this is the same page or not
    1:     nsCOMPtr<nsIDocument> document;
    1:     aOwner->GetDocument(getter_AddRefs(document));
    1: 
    1:     nsCOMPtr<nsIDocument> currentdocument = do_QueryReferent(mCurrentDocument);
    1:     if (document == currentdocument)
    1:       return rv;
    1: 
    1:     mCurrentDocument = do_GetWeakReference(document);
    1: 
    1:     // ReloadPlugins will do the job smartly: nothing will be done
    1:     // if no changes detected, in such a case just return
    1:     if (NS_ERROR_PLUGINS_PLUGINSNOTCHANGED == ReloadPlugins(PR_FALSE))
    1:       return rv;
    1: 
    1:     // other failure return codes may be not fatal, so we can still try
31646:     aOwner->SetInstance(nsnull); // avoid assert about setting it twice
    1:     rv = TrySetUpPluginInstance(aMimeType, aURL, aOwner);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
29574: nsresult
29956: nsPluginHost::TrySetUpPluginInstance(const char *aMimeType,
    1:                                      nsIURI *aURL,
    1:                                      nsIPluginInstanceOwner *aOwner)
    1: {
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec;
29956:   if (aURL != nsnull) aURL->GetSpec(urlSpec);
    1: 
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
29956:         ("nsPluginHost::TrySetupPluginInstance Begin mime=%s, owner=%p, url=%s\n",
    1:         aMimeType, aOwner, urlSpec.get()));
    1: 
    1:   PR_LogFlush();
    1: #endif
    1: 
50781:   nsresult rv = NS_ERROR_FAILURE;
50781:   
    1:   const char* mimetype = nsnull;
    1: 
    1:   // if don't have a mimetype or no plugin can handle this mimetype
    1:   // check by file extension
    1:   nsPluginTag* pluginTag = FindPluginForType(aMimeType, PR_TRUE);
13521:   if (!pluginTag) {
    1:     nsCOMPtr<nsIURL> url = do_QueryInterface(aURL);
    1:     if (!url) return NS_ERROR_FAILURE;
    1: 
    1:     nsCAutoString fileExtension;
    1:     url->GetFileExtension(fileExtension);
    1: 
    1:     // if we don't have an extension or no plugin for this extension,
    1:     // return failure as there is nothing more we can do
    1:     if (fileExtension.IsEmpty() ||
    1:         !(pluginTag = FindPluginEnabledForExtension(fileExtension.get(),
    1:                                                     mimetype))) {
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
29020:   else {
    1:     mimetype = aMimeType;
29020:   }
    1: 
    1:   NS_ASSERTION(pluginTag, "Must have plugin tag here!");
28071: 
50781:   nsCOMPtr<nsIPlugin> plugin;
30057:   GetPlugin(mimetype, getter_AddRefs(plugin));
    1: 
50781:   nsCOMPtr<nsIPluginInstance> instance;
    1:   if (plugin) {
25861: #if defined(XP_WIN) && !defined(WINCE)
    1:     static BOOL firstJavaPlugin = FALSE;
    1:     BOOL restoreOrigDir = FALSE;
38313:     WCHAR origDir[_MAX_PATH];
29020:     if (pluginTag->mIsJavaPlugin && !firstJavaPlugin) {
38313:       DWORD dw = GetCurrentDirectoryW(_MAX_PATH, origDir);
34718:       NS_ASSERTION(dw <= _MAX_PATH, "Failed to obtain the current directory, which may lead to incorrect class loading");
    1:       nsCOMPtr<nsIFile> binDirectory;
50781:       rv = NS_GetSpecialDirectory(NS_XPCOM_CURRENT_PROCESS_DIR,
    1:                                   getter_AddRefs(binDirectory));
    1: 
50781:       if (NS_SUCCEEDED(rv)) {
38313:         nsAutoString path;
38313:         binDirectory->GetPath(path);
38313:         restoreOrigDir = SetCurrentDirectoryW(path.get());
    1:       }
    1:     }
    1: #endif
50781: 
50781:     rv = plugin->CreatePluginInstance(getter_AddRefs(instance));
    1: 
25861: #if defined(XP_WIN) && !defined(WINCE)
    1:     if (!firstJavaPlugin && restoreOrigDir) {
38313:       BOOL bCheck = SetCurrentDirectoryW(origDir);
34718:       NS_ASSERTION(bCheck, "Error restoring directory");
    1:       firstJavaPlugin = TRUE;
    1:     }
    1: #endif
    1:   }
    1: 
50781:   if (NS_FAILED(rv))
50781:     return rv;
    1: 
    1:   // it is adreffed here
    1:   aOwner->SetInstance(instance);
    1: 
36223:   // this should not addref the instance or owner
36223:   // except in some cases not Java, see bug 140931
36223:   // our COM pointer will free the peer
50781:   rv = instance->Initialize(aOwner, mimetype);
50781:   if (NS_FAILED(rv)) {
36223:     aOwner->SetInstance(nsnull);
50781:     return rv;
36223:   }
    1: 
47965:   mInstances.AppendElement(static_cast<nsNPAPIPluginInstance*>(instance.get()));
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec2;
    1:   if (aURL)
    1:     aURL->GetSpec(urlSpec2);
    1: 
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_BASIC,
29956:         ("nsPluginHost::TrySetupPluginInstance Finished mime=%s, rv=%d, owner=%p, url=%s\n",
50781:         aMimeType, rv, aOwner, urlSpec2.get()));
    1: 
    1:   PR_LogFlush();
    1: #endif
    1: 
50781:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::IsPluginEnabledForType(const char* aMimeType)
    1: {
37883:   nsPluginTag *plugin = FindPluginForType(aMimeType, PR_TRUE);
37883:   if (plugin)
37883:     return NS_OK;
37883: 
    1:   // Pass PR_FALSE as the second arg so we can return NS_ERROR_PLUGIN_DISABLED
    1:   // for disabled plug-ins.
37883:   plugin = FindPluginForType(aMimeType, PR_FALSE);
21231:   if (!plugin)
    1:     return NS_ERROR_FAILURE;
    1: 
13222:   if (!plugin->IsEnabled()) {
 3464:     if (plugin->HasFlag(NS_PLUGIN_FLAG_BLOCKLISTED))
 3464:       return NS_ERROR_PLUGIN_BLOCKLISTED;
 3464:     else
    1:       return NS_ERROR_PLUGIN_DISABLED;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // check comma delimitered extensions
    1: static int CompareExtensions(const char *aExtensionList, const char *aExtension)
    1: {
21231:   if (!aExtensionList || !aExtension)
    1:     return -1;
    1: 
    1:   const char *pExt = aExtensionList;
    1:   const char *pComma = strchr(pExt, ',');
21231:   if (!pComma)
    1:     return PL_strcasecmp(pExt, aExtension);
    1: 
    1:   int extlen = strlen(aExtension);
21231:   while (pComma) {
    1:     int length = pComma - pExt;
    1:     if (length == extlen && 0 == PL_strncasecmp(aExtension, pExt, length))
    1:       return 0;
    1:     pComma++;
    1:     pExt = pComma;
    1:     pComma = strchr(pExt, ',');
    1:   }
    1: 
    1:   // the last one
    1:   return PL_strcasecmp(pExt, aExtension);
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::IsPluginEnabledForExtension(const char* aExtension,
    1:                                           const char* &aMimeType)
    1: {
    1:   nsPluginTag *plugin = FindPluginEnabledForExtension(aExtension, aMimeType);
    1:   return plugin ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: class DOMMimeTypeImpl : public nsIDOMMimeType {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1: 
12841:   DOMMimeTypeImpl(nsPluginTag* aTag, PRUint32 aMimeTypeIndex)
12841:   {
12841:     if (!aTag)
12841:       return;
12841:     CopyUTF8toUTF16(aTag->mMimeDescriptionArray[aMimeTypeIndex], mDescription);
12841:     if (aTag->mExtensionsArray)
12841:       CopyUTF8toUTF16(aTag->mExtensionsArray[aMimeTypeIndex], mSuffixes);
12841:     if (aTag->mMimeTypeArray)
12841:       CopyUTF8toUTF16(aTag->mMimeTypeArray[aMimeTypeIndex], mType);
    1:   }
    1: 
    1:   virtual ~DOMMimeTypeImpl() {
    1:   }
    1: 
    1:   NS_METHOD GetDescription(nsAString& aDescription)
    1:   {
    1:     aDescription.Assign(mDescription);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD GetEnabledPlugin(nsIDOMPlugin** aEnabledPlugin)
    1:   {
    1:     // this has to be implemented by the DOM version.
    1:     *aEnabledPlugin = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD GetSuffixes(nsAString& aSuffixes)
    1:   {
    1:     aSuffixes.Assign(mSuffixes);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD GetType(nsAString& aType)
    1:   {
    1:     aType.Assign(mType);
    1:     return NS_OK;
    1:   }
    1: 
    1: private:
    1:   nsString mDescription;
    1:   nsString mSuffixes;
    1:   nsString mType;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(DOMMimeTypeImpl, nsIDOMMimeType)
21231: 
    1: class DOMPluginImpl : public nsIDOMPlugin {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   DOMPluginImpl(nsPluginTag* aPluginTag) : mPluginTag(aPluginTag)
    1:   {
    1:   }
    1: 
    1:   virtual ~DOMPluginImpl() {
    1:   }
    1: 
    1:   NS_METHOD GetDescription(nsAString& aDescription)
    1:   {
12841:     CopyUTF8toUTF16(mPluginTag.mDescription, aDescription);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD GetFilename(nsAString& aFilename)
    1:   {
    1:     PRBool bShowPath;
    1:     nsCOMPtr<nsIPrefBranch> prefService = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:     if (prefService &&
    1:         NS_SUCCEEDED(prefService->GetBoolPref("plugin.expose_full_path", &bShowPath)) &&
21231:         bShowPath) {
12841:       CopyUTF8toUTF16(mPluginTag.mFullPath, aFilename);
29020:     } else {
28451:       CopyUTF8toUTF16(mPluginTag.mFileName, aFilename);
29020:     }
29020: 
28451:     return NS_OK;
28451:   }
28451: 
27645:   NS_METHOD GetVersion(nsAString& aVersion)
27645:   {
27645:     CopyUTF8toUTF16(mPluginTag.mVersion, aVersion);
27645:     return NS_OK;
27645:   }
27645: 
    1:   NS_METHOD GetName(nsAString& aName)
    1:   {
12841:     CopyUTF8toUTF16(mPluginTag.mName, aName);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD GetLength(PRUint32* aLength)
    1:   {
    1:     *aLength = mPluginTag.mVariants;
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD Item(PRUint32 aIndex, nsIDOMMimeType** aReturn)
    1:   {
    1:     nsIDOMMimeType* mimeType = new DOMMimeTypeImpl(&mPluginTag, aIndex);
    1:     NS_IF_ADDREF(mimeType);
    1:     *aReturn = mimeType;
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD NamedItem(const nsAString& aName, nsIDOMMimeType** aReturn)
    1:   {
12841:     for (int i = mPluginTag.mVariants - 1; i >= 0; --i) {
12841:       if (aName.Equals(NS_ConvertUTF8toUTF16(mPluginTag.mMimeTypeArray[i])))
12841:         return Item(i, aReturn);
    1:     }
    1:     return NS_OK;
    1:   }
    1: 
    1: private:
    1:   nsPluginTag mPluginTag;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(DOMPluginImpl, nsIDOMPlugin)
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::GetPluginCount(PRUint32* aPluginCount)
    1: {
    1:   LoadPlugins();
    1: 
    1:   PRUint32 count = 0;
    1: 
    1:   nsPluginTag* plugin = mPlugins;
    1:   while (plugin != nsnull) {
13222:     if (plugin->IsEnabled()) {
    1:       ++count;
    1:     }
    1:     plugin = plugin->mNext;
    1:   }
    1: 
    1:   *aPluginCount = count;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::GetPlugins(PRUint32 aPluginCount, nsIDOMPlugin** aPluginArray)
    1: {
    1:   LoadPlugins();
    1: 
    1:   nsPluginTag* plugin = mPlugins;
 3102:   for (PRUint32 i = 0; i < aPluginCount && plugin; plugin = plugin->mNext) {
13222:     if (plugin->IsEnabled()) {
    1:       nsIDOMPlugin* domPlugin = new DOMPluginImpl(plugin);
    1:       NS_IF_ADDREF(domPlugin);
 3102:       aPluginArray[i++] = domPlugin;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 3102: NS_IMETHODIMP
29956: nsPluginHost::GetPluginTags(PRUint32* aPluginCount, nsIPluginTag*** aResults)
 3102: {
 3102:   LoadPlugins();
 3102: 
 3102:   PRUint32 count = 0;
 3102:   nsRefPtr<nsPluginTag> plugin = mPlugins;
 3102:   while (plugin != nsnull) {
 3102:     count++;
 3102:     plugin = plugin->mNext;
 3102:   }
 3102: 
 3233:   *aResults = static_cast<nsIPluginTag**>
 3233:                          (nsMemory::Alloc(count * sizeof(**aResults)));
 3102:   if (!*aResults)
 3102:     return NS_ERROR_OUT_OF_MEMORY;
 3102: 
 3102:   *aPluginCount = count;
 3102: 
 3102:   plugin = mPlugins;
 3102:   PRUint32 i;
 3102:   for (i = 0; i < count; i++) {
 3102:     (*aResults)[i] = plugin;
 3102:     NS_ADDREF((*aResults)[i]);
 3102:     plugin = plugin->mNext;
 3102:   }
 3102: 
 3102:   return NS_OK;
 3102: }
    1: 
    1: nsPluginTag*
29956: nsPluginHost::FindPluginForType(const char* aMimeType,
    1:                                 PRBool aCheckEnabled)
    1: {
    1:   nsPluginTag *plugins = nsnull;
    1:   PRInt32     variants, cnt;
    1: 
    1:   LoadPlugins();
    1: 
    1:   // if we have a mimetype passed in, search the mPlugins
    1:   // linked list for a match
48721:   if (aMimeType) {
    1:     plugins = mPlugins;
    1: 
48721:     while (plugins) {
    1:       variants = plugins->mVariants;
    1:       for (cnt = 0; cnt < variants; cnt++) {
13222:         if ((!aCheckEnabled || plugins->IsEnabled()) &&
    1:             plugins->mMimeTypeArray[cnt] &&
    1:             (0 == PL_strcasecmp(plugins->mMimeTypeArray[cnt], aMimeType))) {
    1:           return plugins;
    1:         }
    1:       }
    1:       plugins = plugins->mNext;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsPluginTag*
29956: nsPluginHost::FindPluginEnabledForExtension(const char* aExtension,
    1:                                             const char*& aMimeType)
    1: {
    1:   nsPluginTag *plugins = nsnull;
    1:   PRInt32     variants, cnt;
    1: 
    1:   LoadPlugins();
    1: 
    1:   // if we have a mimetype passed in, search the mPlugins linked
    1:   // list for a match
21231:   if (aExtension) {
    1:     plugins = mPlugins;
21231:     while (plugins) {
    1:       variants = plugins->mVariants;
21231:       if (plugins->mExtensionsArray) {
21231:         for (cnt = 0; cnt < variants; cnt++) {
    1:           // mExtensionsArray[cnt] is a list of extensions separated
    1:           // by commas
13222:           if (plugins->IsEnabled() &&
21231:               0 == CompareExtensions(plugins->mExtensionsArray[cnt], aExtension)) {
    1:             aMimeType = plugins->mMimeTypeArray[cnt];
    1:             return plugins;
    1:           }
    1:         }
    1:       }
    1: 
    1:       plugins = plugins->mNext;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
12841: static nsresult ConvertToNative(nsIUnicodeEncoder *aEncoder,
12841:                                 const nsACString& aUTF8String,
12841:                                 nsACString& aNativeString)
12841: {
12841:   NS_ConvertUTF8toUTF16 utf16(aUTF8String);
12841:   PRInt32 len = utf16.Length();
12841:   PRInt32 outLen;
12841:   nsresult rv = aEncoder->GetMaxLength(utf16.get(), len, &outLen);
12841:   NS_ENSURE_SUCCESS(rv, rv);
12841:   if (!EnsureStringLength(aNativeString, outLen))
12841:     return NS_ERROR_OUT_OF_MEMORY;
12841:   rv = aEncoder->Convert(utf16.get(), &len,
12841:                          aNativeString.BeginWriting(), &outLen);
12841:   NS_ENSURE_SUCCESS(rv, rv);
12841:   aNativeString.SetLength(outLen);
12841:   return NS_OK;
12841: }
12841: 
50781: static nsresult CreateNPAPIPlugin(nsPluginTag *aPluginTag,
30057:                                   nsIPlugin **aOutNPAPIPlugin)
12841: {
50781:   // If this is an in-process plugin we'll need to load it here if we haven't already.
50781: #ifdef MOZ_IPC
54127:   if (!nsNPAPIPlugin::RunPluginOOP(aPluginTag)) {
50781: #else
50781:   if (!aPluginTag->mLibrary) {
50781: #endif
50781:     if (aPluginTag->mFullPath.IsEmpty())
50781:       return NS_ERROR_FAILURE;
50781:     nsCOMPtr<nsILocalFile> file = do_CreateInstance("@mozilla.org/file/local;1");
50781:     file->InitWithPath(NS_ConvertUTF8toUTF16(aPluginTag->mFullPath));
50781:     nsPluginFile pluginFile(file);
50781:     PRLibrary* pluginLibrary = NULL;
50781: 
50781:     if (NS_FAILED(pluginFile.LoadPlugin(&pluginLibrary)) || !pluginLibrary)
50781:       return NS_ERROR_FAILURE;
50781: 
50781:     aPluginTag->mLibrary = pluginLibrary;
50781:   }
50781: 
12841:   nsresult rv;
12841:   nsCOMPtr <nsIPlatformCharset> pcs =
12841:     do_GetService(NS_PLATFORMCHARSET_CONTRACTID, &rv);
12841:   NS_ENSURE_SUCCESS(rv, rv);
12841: 
12841:   nsCAutoString charset;
12841:   rv = pcs->GetCharset(kPlatformCharsetSel_FileName, charset);
12841:   NS_ENSURE_SUCCESS(rv, rv);
12841: 
29020:   nsCAutoString fullPath;
12841:   if (!charset.LowerCaseEqualsLiteral("utf-8")) {
12841:     nsCOMPtr<nsIUnicodeEncoder> encoder;
12841:     nsCOMPtr<nsICharsetConverterManager> ccm =
12841:       do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
12841:     NS_ENSURE_SUCCESS(rv, rv);
12841:     rv = ccm->GetUnicodeEncoderRaw(charset.get(), getter_AddRefs(encoder));
12841:     NS_ENSURE_SUCCESS(rv, rv);
12841:     rv = ConvertToNative(encoder, aPluginTag->mFullPath, fullPath);
12841:     NS_ENSURE_SUCCESS(rv, rv);
12841:   } else {
12841:     fullPath = aPluginTag->mFullPath;
12841:   }
12841: 
40564: #if defined(XP_MACOSX) && !defined(__LP64__)
40564:   short appRefNum = ::CurResFile();
40564:   nsCOMPtr<nsILocalFile> pluginPath;
40564:   NS_NewNativeLocalFile(nsDependentCString(fullPath.get()), PR_TRUE,
40564:                         getter_AddRefs(pluginPath));
40564:   nsPluginFile pluginFile(pluginPath);
40564:   short pluginRefNum = pluginFile.OpenPluginResource();
40564: #endif
40564: 
54127:   rv = nsNPAPIPlugin::CreatePlugin(aPluginTag, aOutNPAPIPlugin);
40564: 
40564: #if defined(XP_MACOSX) && !defined(__LP64__)
40564:   if (NS_SUCCEEDED(rv))
40564:     static_cast<nsNPAPIPlugin*>(*aOutNPAPIPlugin)->SetPluginRefNum(pluginRefNum);
40564:   else if (pluginRefNum > 0)
40564:     ::CloseResFile(pluginRefNum);
40564:   ::UseResFile(appRefNum);
40564: #endif
40564: 
40564:   return rv;
30057: }
30057: 
30057: NS_IMETHODIMP nsPluginHost::GetPlugin(const char *aMimeType, nsIPlugin** aPlugin)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   *aPlugin = NULL;
    1: 
    1:   if (!aMimeType)
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1: 
    1:   // If plugins haven't been scanned yet, do so now
    1:   LoadPlugins();
    1: 
    1:   nsPluginTag* pluginTag = FindPluginForType(aMimeType, PR_TRUE);
21231:   if (pluginTag) {
    1:     rv = NS_OK;
    1:     PLUGIN_LOG(PLUGIN_LOG_BASIC,
30057:     ("nsPluginHost::GetPlugin Begin mime=%s, plugin=%s\n",
12841:     aMimeType, pluginTag->mFileName.get()));
    1: 
    1: #ifdef NS_DEBUG
12841:     if (aMimeType && !pluginTag->mFileName.IsEmpty())
12841:       printf("For %s found plugin %s\n", aMimeType, pluginTag->mFileName.get());
    1: #endif
    1: 
50781:     // Create a plugin object if necessary
35426:     nsCOMPtr<nsIPlugin> plugin = pluginTag->mEntryPoint;
21231:     if (!plugin) {
35426:       rv = CreateNPAPIPlugin(pluginTag, getter_AddRefs(plugin));
36102:       if (NS_FAILED(rv))
36102:         return rv;
12841:       pluginTag->mEntryPoint = plugin;
    1:     }
    1: 
35426:     NS_ADDREF(*aPlugin = plugin);
    1:     return NS_OK;
    1:   }
    1: 
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
30057:   ("nsPluginHost::GetPlugin End mime=%s, rv=%d, plugin=%p name=%s\n",
12841:   aMimeType, rv, *aPlugin,
12841:   (pluginTag ? pluginTag->mFileName.get() : "(not found)")));
    1: 
    1:   return rv;
    1: }
    1: 
    1: // XXX called from ScanPluginsDirectory only when told to filter
    1: // currently 'unwanted' plugins are Java, and all other plugins except
    1: // Acrobat, Flash, Quicktime and Shockwave
    1: static PRBool isUnwantedPlugin(nsPluginTag * tag)
    1: {
12841:   if (tag->mFileName.IsEmpty())
    1:     return PR_TRUE;
    1: 
    1:   for (PRInt32 i = 0; i < tag->mVariants; ++i) {
51925:     if (!PL_strcasecmp(tag->mMimeTypeArray[i], "application/pdf"))
    1:       return PR_FALSE;
    1: 
51925:     if (!PL_strcasecmp(tag->mMimeTypeArray[i], "application/x-shockwave-flash"))
    1:       return PR_FALSE;
    1: 
51925:     if (!PL_strcasecmp(tag->mMimeTypeArray[i], "application/x-director"))
    1:       return PR_FALSE;
    1:   }
    1: 
    1:   // On Windows, we also want to include the Quicktime plugin from the 4.x directory
    1:   // But because it spans several DLL's, the best check for now is by filename
12841:   if (tag->mFileName.Find("npqtplugin", PR_TRUE, 0, -1) != kNotFound)
    1:     return PR_FALSE;
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
29956: PRBool nsPluginHost::IsJavaMIMEType(const char* aType)
    1: {
    1:   return aType &&
    1:     ((0 == PL_strncasecmp(aType, "application/x-java-vm",
    1:                           sizeof("application/x-java-vm") - 1)) ||
    1:      (0 == PL_strncasecmp(aType, "application/x-java-applet",
    1:                           sizeof("application/x-java-applet") - 1)) ||
    1:      (0 == PL_strncasecmp(aType, "application/x-java-bean",
    1:                           sizeof("application/x-java-bean") - 1)));
    1: }
    1: 
29956: nsPluginTag * nsPluginHost::HaveSamePlugin(nsPluginTag * aPluginTag)
    1: {
    1:   for (nsPluginTag* tag = mPlugins; tag; tag = tag->mNext) {
    1:     if (tag->Equals(aPluginTag))
    1:       return tag;
    1:   }
    1:   return nsnull;
    1: }
    1: 
29956: PRBool nsPluginHost::IsDuplicatePlugin(nsPluginTag * aPluginTag)
    1: {
    1:   nsPluginTag * tag = HaveSamePlugin(aPluginTag);
    1:   if (tag) {
    1:     // if we got the same plugin, check the full path to see if this is a dup;
    1: 
    1:     // mFileName contains full path on Windows and Unix and leaf name on Mac
    1:     // if those are not equal, we have the same plugin with  different path,
    1:     // i.e. duplicate, return true
12841:     if (!tag->mFileName.Equals(aPluginTag->mFileName))
    1:       return PR_TRUE;
    1: 
    1:     // if they are equal, compare mFullPath fields just in case
    1:     // mFileName contained leaf name only, and if not equal, return true
12841:     if (!tag->mFullPath.Equals(aPluginTag->mFullPath))
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   // we do not have it at all, return false
    1:   return PR_FALSE;
    1: }
    1: 
    1: // Structure for collecting plugin files found during directory scanning
    1: struct pluginFileinDirectory
    1: {
29020:   nsString mFilePath;
    1:   PRInt64  mModTime;
    1: 
    1:   pluginFileinDirectory()
    1:   {
    1:     mModTime = LL_ZERO;
    1:   }
    1: };
    1: 
    1: // QuickSort callback for comparing the modification time of two files
    1: // if the times are the same, compare the filenames
26912: 
26912: NS_SPECIALIZE_TEMPLATE
26912: class nsDefaultComparator<pluginFileinDirectory, pluginFileinDirectory>
26912: {
26912:   public:
26912:   PRBool Equals(const pluginFileinDirectory& aA,
26912:                 const pluginFileinDirectory& aB) const {
26912:     if (aA.mModTime == aB.mModTime &&
29020:         Compare(aA.mFilePath, aB.mFilePath,
26912:                 nsCaseInsensitiveStringComparator()) == 0)
26912:       return PR_TRUE;
    1:     else
26912:       return PR_FALSE;
26912:   }
26912:   PRBool LessThan(const pluginFileinDirectory& aA,
26912:                   const pluginFileinDirectory& aB) const {
26912:     if (aA.mModTime < aB.mModTime)
26912:       return PR_TRUE;
26912:     else if(aA.mModTime == aB.mModTime)
29020:       return Compare(aA.mFilePath, aB.mFilePath,
26912:                      nsCaseInsensitiveStringComparator()) < 0;
26912:     else
26912:       return PR_FALSE;
26912:   }
26912: };
    1: 
19246: typedef NS_NPAPIPLUGIN_CALLBACK(char *, NP_GETMIMEDESCRIPTION)(void);
    1: 
29956: nsresult nsPluginHost::ScanPluginsDirectory(nsIFile * pluginsDir,
    1:                                             nsIComponentManager * compManager,
    1:                                             PRBool aCreatePluginList,
    1:                                             PRBool * aPluginsChanged,
    1:                                             PRBool checkForUnwantedPlugins)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPluginsChanged);
    1:   nsresult rv;
    1: 
    1:   *aPluginsChanged = PR_FALSE;
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString dirPath;
    1:   pluginsDir->GetNativePath(dirPath);
    1:   PLUGIN_LOG(PLUGIN_LOG_BASIC,
29956:   ("nsPluginHost::ScanPluginsDirectory dir=%s\n", dirPath.get()));
    1: #endif
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> iter;
    1:   rv = pluginsDir->GetDirectoryEntries(getter_AddRefs(iter));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
26912:   // Collect all the files in this directory in an array we can sort later
26912:   nsAutoTArray<pluginFileinDirectory, 8> pluginFilesArray;
    1: 
    1:   PRBool hasMore;
    1:   while (NS_SUCCEEDED(iter->HasMoreElements(&hasMore)) && hasMore) {
    1:     nsCOMPtr<nsISupports> supports;
    1:     rv = iter->GetNext(getter_AddRefs(supports));
    1:     if (NS_FAILED(rv))
    1:       continue;
    1:     nsCOMPtr<nsILocalFile> dirEntry(do_QueryInterface(supports, &rv));
    1:     if (NS_FAILED(rv))
    1:       continue;
    1: 
    1:     // Sun's JRE 1.3.1 plugin must have symbolic links resolved or else it'll crash.
    1:     // See bug 197855.
    1:     dirEntry->Normalize();
    1: 
    1:     nsAutoString filePath;
    1:     rv = dirEntry->GetPath(filePath);
    1:     if (NS_FAILED(rv))
    1:       continue;
    1: 
    1:     if (nsPluginsDir::IsPluginFile(dirEntry)) {
26912:       pluginFileinDirectory * item = pluginFilesArray.AppendElement();
    1:       if (!item)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       // Get file mod time
    1:       PRInt64 fileModTime = LL_ZERO;
    1:       dirEntry->GetLastModifiedTime(&fileModTime);
    1: 
    1:       item->mModTime = fileModTime;
29020:       item->mFilePath = filePath;
    1:     }
    1:   } // end round of up of plugin files
    1: 
    1:   // now sort the array by file modification time or by filename, if equal
    1:   // put newer plugins first to weed out dups and catch upgrades, see bug 119966
26912:   pluginFilesArray.Sort();
    1: 
33384:   PRBool warnOutdated = PR_FALSE;
33384: 
    1:   // finally, go through the array, looking at each entry and continue processing it
26912:   for (PRUint32 i = 0; i < pluginFilesArray.Length(); i++) {
26912:     pluginFileinDirectory &pfd = pluginFilesArray[i];
    1:     nsCOMPtr <nsIFile> file = do_CreateInstance("@mozilla.org/file/local;1");
    1:     nsCOMPtr <nsILocalFile> localfile = do_QueryInterface(file);
29020:     localfile->InitWithPath(pfd.mFilePath);
26912:     PRInt64 fileModTime = pfd.mModTime;
    1: 
    1:     // Look for it in our cache
59080:     NS_ConvertUTF16toUTF8 filePath(pfd.mFilePath);
 3102:     nsRefPtr<nsPluginTag> pluginTag;
59080:     RemoveCachedPluginsInfo(filePath.get(),
 3102:                             getter_AddRefs(pluginTag));
 3102: 
21189:     PRBool enabled = PR_TRUE;
21189:     PRBool seenBefore = PR_FALSE;
    1:     if (pluginTag) {
21189:       seenBefore = PR_TRUE;
    1:       // If plugin changed, delete cachedPluginTag and don't use cache
    1:       if (LL_NE(fileModTime, pluginTag->mLastModifiedTime)) {
    1:         // Plugins has changed. Don't use cached plugin info.
21189:         enabled = (pluginTag->Flags() & NS_PLUGIN_FLAG_ENABLED) != 0;
    1:         pluginTag = nsnull;
    1: 
    1:         // plugin file changed, flag this fact
    1:         *aPluginsChanged = PR_TRUE;
    1:       }
    1:       else {
    1:         // if it is unwanted plugin we are checking for, get it back to the cache info list
    1:         // if this is a duplicate plugin, too place it back in the cache info list marking unwantedness
    1:         if ((checkForUnwantedPlugins && isUnwantedPlugin(pluginTag)) ||
15819:            IsDuplicatePlugin(pluginTag)) {
    1:           if (!pluginTag->HasFlag(NS_PLUGIN_FLAG_UNWANTED)) {
    1:             // Plugin switched from wanted to unwanted
    1:             *aPluginsChanged = PR_TRUE;
    1:           }
    1:           pluginTag->Mark(NS_PLUGIN_FLAG_UNWANTED);
    1:           pluginTag->mNext = mCachedPlugins;
    1:           mCachedPlugins = pluginTag;
    1:         } else if (pluginTag->HasFlag(NS_PLUGIN_FLAG_UNWANTED)) {
    1:           pluginTag->UnMark(NS_PLUGIN_FLAG_UNWANTED);
    1:           // Plugin switched from unwanted to wanted
    1:           *aPluginsChanged = PR_TRUE;
    1:         }
    1:       }
55427: 
55427:       // If we're not creating a list and we already know something changed then
55427:       // we're done.
    1:       if (!aCreatePluginList) {
55427:         if (*aPluginsChanged) {
    1:           return NS_OK;
55427:         }
    1:         continue;
    1:       }
55427:     }
    1:     
59538:     bool isKnownInvalidPlugin = false;
59080:     for (nsRefPtr<nsInvalidPluginTag> invalidPlugins = mInvalidPlugins;
59080:          invalidPlugins; invalidPlugins = invalidPlugins->mNext) {
59080:       // If already marked as invalid, ignore it
59080:       if (invalidPlugins->mFullPath.Equals(filePath.get()) &&
59080:           invalidPlugins->mLastModifiedTime == fileModTime) {
59080:         if (aCreatePluginList) {
59080:           invalidPlugins->mSeen = true;
59080:         }
59080:         isKnownInvalidPlugin = true;
59080:         break;
59080:       }
59080:     }
59080:     if (isKnownInvalidPlugin) {
59080:       continue;
59080:     }
59080: 
    1:     // if it is not found in cache info list or has been changed, create a new one
    1:     if (!pluginTag) {
    1:       nsPluginFile pluginFile(file);
    1: 
    1:       // create a tag describing this plugin.
50781:       PRLibrary *library = nsnull;
22547:       nsPluginInfo info;
22547:       memset(&info, 0, sizeof(info));
50781:       nsresult res = pluginFile.GetPluginInfo(info, &library);
22547:       // if we don't have mime type don't proceed, this is not a plugin
22547:       if (NS_FAILED(res) || !info.fMimeTypeArray) {
59080:         nsRefPtr<nsInvalidPluginTag> invalidTag = new nsInvalidPluginTag(filePath.get(),
59080:                                                                          fileModTime);
    1:         pluginFile.FreePluginInfo(info);
59080:         
59080:         if (aCreatePluginList) {
59538:           invalidTag->mSeen = true;
59080:         }
59080:         invalidTag->mNext = mInvalidPlugins;
59080:         if (mInvalidPlugins) {
59080:           mInvalidPlugins->mPrev = invalidTag;
59080:         }
59080:         mInvalidPlugins = invalidTag;
59080:         
59080:         // Mark aPluginsChanged so pluginreg is rewritten
59080:         *aPluginsChanged = PR_TRUE;
    1:         continue;
    1:       }
    1: 
    1:       pluginTag = new nsPluginTag(&info);
    1:       pluginFile.FreePluginInfo(info);
50781:       if (!pluginTag)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
50781:       pluginTag->mLibrary = library;
    1:       pluginTag->mLastModifiedTime = fileModTime;
21189: 
21189:       nsCOMPtr<nsIBlocklistService> blocklist = do_GetService("@mozilla.org/extensions/blocklist;1");
21189:       if (blocklist) {
21189:         PRUint32 state;
21189:         rv = blocklist->GetPluginBlocklistState(pluginTag, EmptyString(),
21189:                                                 EmptyString(), &state);
21189: 
21189:         if (NS_SUCCEEDED(rv)) {
21189:           // If the blocklist says so then block the plugin. If the blocklist says
21189:           // it is risky and we have never seen this plugin before then disable it
21189:           if (state == nsIBlocklistService::STATE_BLOCKED)
21189:             pluginTag->Mark(NS_PLUGIN_FLAG_BLOCKLISTED);
21189:           else if (state == nsIBlocklistService::STATE_SOFTBLOCKED && !seenBefore)
21189:             enabled = PR_FALSE;
33384:           else if (state == nsIBlocklistService::STATE_OUTDATED && !seenBefore)
33384:             warnOutdated = PR_TRUE;
21189:         }
21189:       }
21189: 
31800:       if (!enabled)
21186:         pluginTag->UnMark(NS_PLUGIN_FLAG_ENABLED);
21186: 
    1:       // if this is unwanted plugin we are checkin for, or this is a duplicate plugin,
    1:       // add it to our cache info list so we can cache the unwantedness of this plugin
    1:       // when we sync cached plugins to registry
    1:       NS_ASSERTION(!pluginTag->HasFlag(NS_PLUGIN_FLAG_UNWANTED),
    1:                    "Brand-new tags should not be unwanted");
    1:       if ((checkForUnwantedPlugins && isUnwantedPlugin(pluginTag)) ||
15819:          IsDuplicatePlugin(pluginTag)) {
    1:         pluginTag->Mark(NS_PLUGIN_FLAG_UNWANTED);
    1:         pluginTag->mNext = mCachedPlugins;
    1:         mCachedPlugins = pluginTag;
    1:       }
50781: 
50781:       // Plugin unloading is tag-based. If we created a new tag and loaded
50781:       // the library in the process then we want to attempt to unload it here.
50781:       // Only do this if the pref is set for aggressive unloading.
50781:       if (UnloadPluginsASAP()) {
50781:         pluginTag->TryUnloadPlugin();
50781:       }
    1:     }
    1: 
    1:     // set the flag that we want to add this plugin to the list for now
    1:     // and see if it remains after we check several reasons not to do so
    1:     PRBool bAddIt = PR_TRUE;
    1: 
    1:     // check if this is a specific plugin we don't want
15819:     if (checkForUnwantedPlugins && isUnwantedPlugin(pluginTag))
    1:       bAddIt = PR_FALSE;
    1: 
    1:     // check if we already have this plugin in the list which
    1:     // is possible if we do refresh
    1:     if (bAddIt) {
    1:       if (HaveSamePlugin(pluginTag)) {
    1:         // we cannot get here if the plugin has just been added
    1:         // and thus |pluginTag| is not from cache, because otherwise
    1:         // it would not be present in the list;
    1:         bAddIt = PR_FALSE;
    1:       }
    1:     }
    1: 
21231:     // do it if we still want it
    1:     if (bAddIt) {
57939:       if (!seenBefore) {
55427:         // We have a valid new plugin so report that plugins have changed.
55427:         *aPluginsChanged = PR_TRUE;
57939:       }
55427: 
55427:       // If we're not creating a plugin list, simply looking for changes,
55427:       // then we're done.
55427:       if (!aCreatePluginList) {
55427:         return NS_OK;
55427:       }
55427: 
    1:       pluginTag->SetHost(this);
    1:       pluginTag->mNext = mPlugins;
    1:       mPlugins = pluginTag;
46415: 
46415:       if (pluginTag->IsEnabled())
46415:         pluginTag->RegisterWithCategoryManager(mOverrideInternalTypes);
    1:     }
    1:   }
33384:   
33384:   if (warnOutdated)
33384:     mPrefService->SetBoolPref("plugins.update.notifyUser", PR_TRUE);
33384: 
    1:   return NS_OK;
    1: }
    1: 
29956: nsresult nsPluginHost::ScanPluginsDirectoryList(nsISimpleEnumerator * dirEnum,
    1:                                                 nsIComponentManager * compManager,
    1:                                                 PRBool aCreatePluginList,
    1:                                                 PRBool * aPluginsChanged,
    1:                                                 PRBool checkForUnwantedPlugins)
    1: {
    1:     PRBool hasMore;
    1:     while (NS_SUCCEEDED(dirEnum->HasMoreElements(&hasMore)) && hasMore) {
    1:       nsCOMPtr<nsISupports> supports;
    1:       nsresult rv = dirEnum->GetNext(getter_AddRefs(supports));
    1:       if (NS_FAILED(rv))
    1:         continue;
    1:       nsCOMPtr<nsIFile> nextDir(do_QueryInterface(supports, &rv));
    1:       if (NS_FAILED(rv))
    1:         continue;
    1: 
    1:       // don't pass aPluginsChanged directly to prevent it from been reset
    1:       PRBool pluginschanged = PR_FALSE;
    1:       ScanPluginsDirectory(nextDir, compManager, aCreatePluginList, &pluginschanged, checkForUnwantedPlugins);
    1: 
    1:       if (pluginschanged)
    1:         *aPluginsChanged = PR_TRUE;
    1: 
    1:       // if changes are detected and we are not creating the list, do not proceed
    1:       if (!aCreatePluginList && *aPluginsChanged)
    1:         break;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::LoadPlugins()
    1: {
    1:   // do not do anything if it is already done
    1:   // use ReloadPlugins() to enforce loading
    1:   if (mPluginsLoaded)
    1:     return NS_OK;
    1: 
37523:   if (mPluginsDisabled)
37523:     return NS_OK;
37523: 
    1:   PRBool pluginschanged;
    1:   nsresult rv = FindPlugins(PR_TRUE, &pluginschanged);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
29936:   // only if plugins have changed will we notify plugin-change observers
    1:   if (pluginschanged) {
41540:     nsCOMPtr<nsIObserverService> obsService =
41540:       mozilla::services::GetObserverService();
 3464:     if (obsService)
 3464:       obsService->NotifyObservers(nsnull, "plugins-list-updated", nsnull);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #include "nsITimelineService.h"
    1: 
    1: // if aCreatePluginList is false we will just scan for plugins
    1: // and see if any changes have been made to the plugins.
    1: // This is needed in ReloadPlugins to prevent possible recursive reloads
29956: nsresult nsPluginHost::FindPlugins(PRBool aCreatePluginList, PRBool * aPluginsChanged)
    1: {
    1:   // let's start timing if we are only really creating the plugin list
    1:   if (aCreatePluginList) {
    1:     NS_TIMELINE_START_TIMER("LoadPlugins");
    1:   }
    1: 
    1: #ifdef CALL_SAFETY_ON
    1:   // check preferences on whether or not we want to try safe calls to plugins
    1:   NS_INIT_PLUGIN_SAFE_CALLS;
    1: #endif
    1: 
    1:   NS_ENSURE_ARG_POINTER(aPluginsChanged);
    1: 
    1:   *aPluginsChanged = PR_FALSE;
    1:   nsresult rv;
    1: 
32940:   // Read cached plugins info. If the profile isn't yet available then don't
32940:   // scan for plugins
32940:   if (ReadPluginInfo() == NS_ERROR_NOT_AVAILABLE)
32940:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIComponentManager> compManager;
    1:   NS_GetComponentManager(getter_AddRefs(compManager));
    1: 
 3715: #ifdef XP_WIN
    1:   // Failure here is not a show-stopper so just warn.
    1:   rv = EnsurePrivateDirServiceProvider();
    1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to register dir service provider.");
 3715: #endif /* XP_WIN */
    1: 
    1:   nsCOMPtr<nsIProperties> dirService(do_GetService(kDirectoryServiceContractID, &rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> dirList;
    1: 
    1:   // Scan plugins directories;
    1:   // don't pass aPluginsChanged directly, to prevent its
    1:   // possible reset in subsequent ScanPluginsDirectory calls
    1:   PRBool pluginschanged = PR_FALSE;
    1: 
    1:   // Scan the app-defined list of plugin dirs.
    1:   rv = dirService->Get(NS_APP_PLUGINS_DIR_LIST, NS_GET_IID(nsISimpleEnumerator), getter_AddRefs(dirList));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     ScanPluginsDirectoryList(dirList, compManager, aCreatePluginList, &pluginschanged);
    1: 
    1:     if (pluginschanged)
    1:       *aPluginsChanged = PR_TRUE;
    1: 
    1:     // if we are just looking for possible changes,
    1:     // no need to proceed if changes are detected
    1:     if (!aCreatePluginList && *aPluginsChanged) {
31646:       NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
59539:       NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   mPluginsLoaded = PR_TRUE; // at this point 'some' plugins have been loaded,
    1:                             // the rest is optional
    1: 
 3715: #ifdef XP_WIN
    1:   PRBool bScanPLIDs = PR_FALSE;
    1: 
    1:   if (mPrefService)
    1:     mPrefService->GetBoolPref("plugin.scan.plid.all", &bScanPLIDs);
    1: 
    1:     // Now lets scan any PLID directories
    1:   if (bScanPLIDs && mPrivateDirServiceProvider) {
    1:     rv = mPrivateDirServiceProvider->GetPLIDDirectories(getter_AddRefs(dirList));
    1:     if (NS_SUCCEEDED(rv)) {
    1:       ScanPluginsDirectoryList(dirList, compManager, aCreatePluginList, &pluginschanged);
    1: 
    1:       if (pluginschanged)
    1:         *aPluginsChanged = PR_TRUE;
    1: 
    1:       // if we are just looking for possible changes,
    1:       // no need to proceed if changes are detected
    1:       if (!aCreatePluginList && *aPluginsChanged) {
31646:         NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
59539:         NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1: 
    1:   // Scan the installation paths of our popular plugins if the prefs are enabled
    1: 
    1:   // This table controls the order of scanning
    1:   const char* const prefs[] = {NS_WIN_JRE_SCAN_KEY,         nsnull,
    1:                                NS_WIN_ACROBAT_SCAN_KEY,     nsnull,
    1:                                NS_WIN_QUICKTIME_SCAN_KEY,   nsnull,
    1:                                NS_WIN_WMP_SCAN_KEY,         nsnull,
    1:                                NS_WIN_4DOTX_SCAN_KEY,       "1"  /*  second column is flag for 4.x folder */ };
    1: 
    1:   PRUint32 size = sizeof(prefs) / sizeof(prefs[0]);
    1: 
    1:   for (PRUint32 i = 0; i < size; i+=2) {
    1:     nsCOMPtr<nsIFile> dirToScan;
    1:     PRBool bExists;
    1:     if (NS_SUCCEEDED(dirService->Get(prefs[i], NS_GET_IID(nsIFile), getter_AddRefs(dirToScan))) &&
    1:         dirToScan &&
    1:         NS_SUCCEEDED(dirToScan->Exists(&bExists)) &&
    1:         bExists) {
    1: 
    1:       PRBool bFilterUnwanted = PR_FALSE;
    1: 
    1:       // 4.x plugins folder stuff:
    1:       // Normally we "filter" the 4.x folder through |IsUnwantedPlugin|
    1:       // Check for a pref to see if we want to scan the entire 4.x plugins folder
    1:       if (prefs[i+1]) {
    1:         PRBool bScanEverything;
    1:         bFilterUnwanted = PR_TRUE;  // default to filter 4.x folder
    1:         if (mPrefService &&
    1:             NS_SUCCEEDED(mPrefService->GetBoolPref(prefs[i], &bScanEverything)) &&
    1:             bScanEverything)
    1:           bFilterUnwanted = PR_FALSE;
    1: 
    1:       }
    1:       ScanPluginsDirectory(dirToScan, compManager, aCreatePluginList, &pluginschanged, bFilterUnwanted);
    1: 
    1:       if (pluginschanged)
    1:         *aPluginsChanged = PR_TRUE;
    1: 
    1:       // if we are just looking for possible changes,
    1:       // no need to proceed if changes are detected
    1:       if (!aCreatePluginList && *aPluginsChanged) {
31646:         NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
59539:         NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: #endif
    1: 
    1:   // if get to this point and did not detect changes in plugins
    1:   // that means no plugins got updated or added
    1:   // let's see if plugins have been removed
    1:   if (!*aPluginsChanged) {
    1:     // count plugins remained in cache, if there are some, that means some plugins were removed;
    1:     // while counting, we should ignore unwanted plugins which are also present in cache
    1:     PRUint32 cachecount = 0;
    1:     for (nsPluginTag * cachetag = mCachedPlugins; cachetag; cachetag = cachetag->mNext) {
    1:       if (!cachetag->HasFlag(NS_PLUGIN_FLAG_UNWANTED))
    1:         cachecount++;
    1:     }
    1:     // if there is something left in cache, some plugins got removed from the directory
    1:     // and therefor their info did not get removed from the cache info list during directory scan;
    1:     // flag this fact
    1:     if (cachecount > 0)
    1:       *aPluginsChanged = PR_TRUE;
    1:   }
    1:   
59080:   // Remove unseen invalid plugins
59080:   nsRefPtr<nsInvalidPluginTag> invalidPlugins = mInvalidPlugins;
59080:   while (invalidPlugins) {
59080:     if (!invalidPlugins->mSeen) {
59080:       nsRefPtr<nsInvalidPluginTag> invalidPlugin = invalidPlugins;
59080:       
59080:       if (invalidPlugin->mPrev) {
59080:         invalidPlugin->mPrev->mNext = invalidPlugin->mNext;
59080:       }
59080:       else {
59080:         mInvalidPlugins = invalidPlugin->mNext;
59080:       }
59080:       if (invalidPlugin->mNext) {
59080:         invalidPlugin->mNext->mPrev = invalidPlugin->mPrev; 
59080:       }
59080:       
59080:       invalidPlugins = invalidPlugin->mNext;
59080:       
59080:       invalidPlugin->mPrev = NULL;
59080:       invalidPlugin->mNext = NULL;
59080:     }
59080:     else {
59538:       invalidPlugins->mSeen = false;
59080:       invalidPlugins = invalidPlugins->mNext;
59080:     }
59080:   }
59080: 
    1:   // if we are not creating the list, there is no need to proceed
    1:   if (!aCreatePluginList) {
31646:     NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
59539:     NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // if we are creating the list, it is already done;
    1:   // update the plugins info cache if changes are detected
    1:   if (*aPluginsChanged)
    1:     WritePluginInfo();
    1: 
    1:   // No more need for cached plugins. Clear it up.
31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
59539:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
    1: 
    1:   // reverse our list of plugins
 3102:   nsRefPtr<nsPluginTag> next;
 3102:   nsRefPtr<nsPluginTag> prev;
 3102:   for (nsRefPtr<nsPluginTag> cur = mPlugins; cur; cur = next) {
    1:     next = cur->mNext;
    1:     cur->mNext = prev;
    1:     prev = cur;
    1:   }
    1: 
    1:   mPlugins = prev;
    1: 
    1:   NS_TIMELINE_STOP_TIMER("LoadPlugins");
    1:   NS_TIMELINE_MARK_TIMER("LoadPlugins");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
29956: nsPluginHost::UpdatePluginInfo(nsPluginTag* aPluginTag)
 3102: {
 3102:   ReadPluginInfo();
 3102:   WritePluginInfo();
31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
59539:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
 3464: 
13222:   if (!aPluginTag || aPluginTag->IsEnabled())
 3464:     return NS_OK;
 3464: 
 3464:   nsCOMPtr<nsISupportsArray> instsToReload;
 3464:   NS_NewISupportsArray(getter_AddRefs(instsToReload));
47965:   DestroyRunningInstances(instsToReload, aPluginTag);
 3464:   
 3464:   PRUint32 c;
21231:   if (instsToReload && NS_SUCCEEDED(instsToReload->Count(&c)) && c > 0) {
 3464:     nsCOMPtr<nsIRunnable> ev = new nsPluginDocReframeEvent(instsToReload);
 3464:     if (ev)
 3464:       NS_DispatchToCurrentThread(ev);
 3464:   }
 3102: 
 3102:   return NS_OK;
 3102: }
 3102: 
 3102: nsresult
29956: nsPluginHost::WritePluginInfo()
    1: {
    1: 
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsIProperties> directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID,&rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
 4030:   directoryService->Get(NS_APP_USER_PROFILE_50_DIR, NS_GET_IID(nsIFile),
    1:                         getter_AddRefs(mPluginRegFile));
    1: 
    1:   if (!mPluginRegFile)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PRFileDesc* fd = nsnull;
    1: 
    1:   nsCOMPtr<nsIFile> pluginReg;
    1: 
    1:   rv = mPluginRegFile->Clone(getter_AddRefs(pluginReg));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   rv = pluginReg->AppendNative(kPluginRegistryFilename);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(pluginReg, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   rv = localFile->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE, 0600, &fd);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
59080:   nsCOMPtr<nsIXULRuntime> runtime = do_GetService("@mozilla.org/xre/runtime;1");
59080:   if (!runtime) {
59080:     return NS_ERROR_FAILURE;
59080:   }
59080:     
59080:   nsCAutoString arch;
59080:   rv = runtime->GetXPCOMABI(arch);
59080:   if (NS_FAILED(rv)) {
59080:     return rv;
59080:   }
59080: 
    1:   PR_fprintf(fd, "Generated File. Do not edit.\n");
    1: 
59080:   PR_fprintf(fd, "\n[HEADER]\nVersion%c%s%c%c\nArch%c%s%c%c\n",
    1:              PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:              kPluginRegistryVersion,
    1:              PLUGIN_REGISTRY_FIELD_DELIMITER,
59080:              PLUGIN_REGISTRY_END_OF_LINE_MARKER,
59080:              PLUGIN_REGISTRY_FIELD_DELIMITER,
59080:              arch.get(),
59080:              PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:              PLUGIN_REGISTRY_END_OF_LINE_MARKER);
    1: 
    1:   // Store all plugins in the mPlugins list - all plugins currently in use.
    1:   PR_fprintf(fd, "\n[PLUGINS]\n");
    1: 
    1:   nsPluginTag *taglist[] = {mPlugins, mCachedPlugins};
    1:   for (int i=0; i<(int)(sizeof(taglist)/sizeof(nsPluginTag *)); i++) {
    1:     for (nsPluginTag *tag = taglist[i]; tag; tag=tag->mNext) {
    1:       // from mCachedPlugins list write down only unwanted plugins
    1:       if ((taglist[i] == mCachedPlugins) && !tag->HasFlag(NS_PLUGIN_FLAG_UNWANTED))
    1:         continue;
    1:       // store each plugin info into the registry
    1:       // filename & fullpath are on separate line
    1:       // because they can contain field delimiter char
15947:       PR_fprintf(fd, "%s%c%c\n%s%c%c\n%s%c%c\n",
12841:         (!tag->mFileName.IsEmpty() ? tag->mFileName.get() : ""),
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         PLUGIN_REGISTRY_END_OF_LINE_MARKER,
12841:         (!tag->mFullPath.IsEmpty() ? tag->mFullPath.get() : ""),
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
15947:         PLUGIN_REGISTRY_END_OF_LINE_MARKER,
15947:         (!tag->mVersion.IsEmpty() ? tag->mVersion.get() : ""),
15947:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         PLUGIN_REGISTRY_END_OF_LINE_MARKER);
    1: 
    1:       // lastModifiedTimeStamp|canUnload|tag->mFlags
    1:       PR_fprintf(fd, "%lld%c%d%c%lu%c%c\n",
    1:         tag->mLastModifiedTime,
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         tag->mCanUnloadLibrary,
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         tag->Flags(),
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         PLUGIN_REGISTRY_END_OF_LINE_MARKER);
    1: 
    1:       //description, name & mtypecount are on separate line
    1:       PR_fprintf(fd, "%s%c%c\n%s%c%c\n%d\n",
12841:         (!tag->mDescription.IsEmpty() ? tag->mDescription.get() : ""),
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         PLUGIN_REGISTRY_END_OF_LINE_MARKER,
12841:         (!tag->mName.IsEmpty() ? tag->mName.get() : ""),
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         PLUGIN_REGISTRY_END_OF_LINE_MARKER,
 6774:         tag->mVariants + (tag->mIsNPRuntimeEnabledJavaPlugin ? 1 : 0));
    1: 
    1:       // Add in each mimetype this plugin supports
    1:       for (int i=0; i<tag->mVariants; i++) {
    1:         PR_fprintf(fd, "%d%c%s%c%s%c%s%c%c\n",
    1:           i,PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:           (tag->mMimeTypeArray && tag->mMimeTypeArray[i] ? tag->mMimeTypeArray[i] : ""),
    1:           PLUGIN_REGISTRY_FIELD_DELIMITER,
12841:           (!tag->mMimeDescriptionArray[i].IsEmpty() ? tag->mMimeDescriptionArray[i].get() : ""),
    1:           PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:           (tag->mExtensionsArray && tag->mExtensionsArray[i] ? tag->mExtensionsArray[i] : ""),
    1:           PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:           PLUGIN_REGISTRY_END_OF_LINE_MARKER);
    1:       }
 6774: 
 6774:       if (tag->mIsNPRuntimeEnabledJavaPlugin) {
 6774:         PR_fprintf(fd, "%d%c%s%c%s%c%s%c%c\n",
 6774:           tag->mVariants, PLUGIN_REGISTRY_FIELD_DELIMITER,
 6774:           "application/x-java-vm-npruntime",
 6774:           PLUGIN_REGISTRY_FIELD_DELIMITER,
 6774:           "",
 6774:           PLUGIN_REGISTRY_FIELD_DELIMITER,
 6774:           "",
 6774:           PLUGIN_REGISTRY_FIELD_DELIMITER,
 6774:           PLUGIN_REGISTRY_END_OF_LINE_MARKER);
 6774:       }
    1:     }
    1:   }
    1:   
59080:   PR_fprintf(fd, "\n[INVALID]\n");
59080:   
59080:   nsRefPtr<nsInvalidPluginTag> invalidPlugins = mInvalidPlugins;
59080:   while (invalidPlugins) {
59080:     // fullPath
59080:     PR_fprintf(fd, "%s%c%c\n",
59080:       (!invalidPlugins->mFullPath.IsEmpty() ? invalidPlugins->mFullPath.get() : ""),
59080:       PLUGIN_REGISTRY_FIELD_DELIMITER,
59080:       PLUGIN_REGISTRY_END_OF_LINE_MARKER);
59080: 
59080:     // lastModifiedTimeStamp
59080:     PR_fprintf(fd, "%lld%c%c\n",
59080:       invalidPlugins->mLastModifiedTime,
59080:       PLUGIN_REGISTRY_FIELD_DELIMITER,
59080:       PLUGIN_REGISTRY_END_OF_LINE_MARKER);
59080:     
59080:     invalidPlugins = invalidPlugins->mNext;
59080:   }
59080: 
36600:   if (fd) {
36600:     PR_Sync(fd);
    1:     PR_Close(fd);
36600:   }
    1:   return NS_OK;
    1: }
    1: 
    1: #define PLUGIN_REG_MIMETYPES_ARRAY_SIZE 12
    1: nsresult
29956: nsPluginHost::ReadPluginInfo()
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIProperties> directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID,&rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
 4030:   directoryService->Get(NS_APP_USER_PROFILE_50_DIR, NS_GET_IID(nsIFile),
    1:                         getter_AddRefs(mPluginRegFile));
    1: 
32940:   if (!mPluginRegFile) {
32940:     // There is no profile yet, this will tell us if there is going to be one
32940:     // in the future.
32940:     directoryService->Get(NS_APP_PROFILE_DIR_STARTUP, NS_GET_IID(nsIFile),
32940:                           getter_AddRefs(mPluginRegFile));
    1:     if (!mPluginRegFile)
    1:       return NS_ERROR_FAILURE;
32940:     else
32940:       return NS_ERROR_NOT_AVAILABLE;
32940:   }
    1: 
    1:   PRFileDesc* fd = nsnull;
    1: 
    1:   nsCOMPtr<nsIFile> pluginReg;
    1: 
    1:   rv = mPluginRegFile->Clone(getter_AddRefs(pluginReg));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   rv = pluginReg->AppendNative(kPluginRegistryFilename);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(pluginReg, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   PRInt64 fileSize;
    1:   rv = localFile->GetFileSize(&fileSize);
21231:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   PRInt32 flen = nsInt64(fileSize);
    1:   if (flen == 0) {
    1:     NS_WARNING("Plugins Registry Empty!");
    1:     return NS_OK; // ERROR CONDITION
    1:   }
    1: 
    1:   nsPluginManifestLineReader reader;
    1:   char* registry = reader.Init(flen);
21231:   if (!registry)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   rv = localFile->OpenNSPRFileDesc(PR_RDONLY, 0444, &fd);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // set rv to return an error on goto out
    1:   rv = NS_ERROR_FAILURE;
    1: 
    1:   PRInt32 bread = PR_Read(fd, registry, flen);
    1:   PR_Close(fd);
    1: 
    1:   if (flen > bread)
    1:     return rv;
    1: 
21231:   if (!ReadSectionHeader(reader, "HEADER"))
    1:     return rv;;
21231: 
21231:   if (!reader.NextLine())
    1:     return rv;
    1: 
    1:   char* values[6];
    1: 
    1:   // VersionLiteral, kPluginRegistryVersion
21231:   if (2 != reader.ParseLine(values, 2))
    1:     return rv;
    1: 
    1:   // VersionLiteral
21231:   if (PL_strcmp(values[0], "Version"))
    1:     return rv;
    1: 
    1:   // kPluginRegistryVersion
21192:   PRInt32 vdiff = NS_CompareVersions(values[1], kPluginRegistryVersion);
21192:   // If this is a registry from some future version then don't attempt to read it
21231:   if (vdiff > 0)
    1:     return rv;
21192:   // If this is a registry from before the minimum then don't attempt to read it
21231:   if (NS_CompareVersions(values[1], kMinimumRegistryVersion) < 0)
21192:     return rv;
21192: 
21192:   // Registry v0.10 and upwards includes the plugin version field
21192:   PRBool regHasVersion = NS_CompareVersions(values[1], "0.10") >= 0;
    1: 
59080:   // Registry v0.13 and upwards includes the architecture
59080:   if (NS_CompareVersions(values[1], "0.13") >= 0) {
59080:     char* archValues[6];
59080:     
59080:     if (!reader.NextLine()) {
59080:       return rv;
59080:     }
59080:     
59080:     // ArchLiteral, Architecture
59080:     if (2 != reader.ParseLine(archValues, 2)) {
59080:       return rv;
59080:     }
59080:       
59080:     // ArchLiteral
59080:     if (PL_strcmp(archValues[0], "Arch")) {
59080:       return rv;
59080:     }
59080:       
59080:     nsCOMPtr<nsIXULRuntime> runtime = do_GetService("@mozilla.org/xre/runtime;1");
59080:     if (!runtime) {
59080:       return rv;
59080:     }
59080:       
59080:     nsCAutoString arch;
59080:     if (NS_FAILED(runtime->GetXPCOMABI(arch))) {
59080:       return rv;
59080:     }
59080:       
59080:     // If this is a registry from a different architecture then don't attempt to read it
59080:     if (PL_strcmp(archValues[1], arch.get())) {
59080:       return rv;
59080:     }
59080:   }
59080:   
59080:   // Registry v0.13 and upwards includes the list of invalid plugins
59080:   bool hasInvalidPlugins = (NS_CompareVersions(values[1], "0.13") >= 0);
59080: 
21231:   if (!ReadSectionHeader(reader, "PLUGINS"))
    1:     return rv;
    1: 
29020: #if defined(XP_MACOSX)
29020:   PRBool hasFullPathInFileNameField = PR_FALSE;
29020: #else
29020:   PRBool hasFullPathInFileNameField = (NS_CompareVersions(values[1], "0.11") < 0);
29020: #endif
29020: 
    1:   while (reader.NextLine()) {
29020:     const char *filename;
29020:     const char *fullpath;
29020:     nsCAutoString derivedFileName;
29020:     
59080:     if (hasInvalidPlugins && *reader.LinePtr() == '[') {
59080:       break;
59080:     }
59080:     
29020:     if (hasFullPathInFileNameField) {
29020:       fullpath = reader.LinePtr();
    1:       if (!reader.NextLine())
    1:         return rv;
29020:       // try to derive a file name from the full path
29020:       if (fullpath) {
29020:         nsCOMPtr<nsILocalFile> file = do_CreateInstance("@mozilla.org/file/local;1");
29020:         file->InitWithNativePath(nsDependentCString(fullpath));
29020:         file->GetNativeLeafName(derivedFileName);
29020:         filename = derivedFileName.get();
29020:       } else {
29020:         filename = NULL;
29020:       }
29020: 
29020:       // skip the next line, useless in this version
    1:       if (!reader.NextLine())
    1:         return rv;
29020:     } else {
29020:       filename = reader.LinePtr();
29020:       if (!reader.NextLine())
29020:         return rv;
29020: 
29020:       fullpath = reader.LinePtr();
29020:       if (!reader.NextLine())
29020:         return rv;
29020:     }
    1: 
26026:     const char *version;
21192:     if (regHasVersion) {
21192:       version = reader.LinePtr();
15947:       if (!reader.NextLine())
15947:         return rv;
21231:     } else {
21192:       version = "0";
21192:     }
15947: 
    1:     // lastModifiedTimeStamp|canUnload|tag.mFlag
21231:     if (reader.ParseLine(values, 3) != 3)
    1:       return rv;
    1: 
21192:     // If this is an old plugin registry mark this plugin tag to be refreshed
29020:     PRInt64 lastmod = (vdiff == 0) ? nsCRT::atoll(values[0]) : -1;
    1:     PRBool canunload = atoi(values[1]);
    1:     PRUint32 tagflag = atoi(values[2]);
    1:     if (!reader.NextLine())
    1:       return rv;
    1: 
26026:     const char *description = reader.LinePtr();
    1:     if (!reader.NextLine())
    1:       return rv;
    1: 
26026:     const char *name = reader.LinePtr();
    1:     if (!reader.NextLine())
    1:       return rv;
    1: 
    1:     int mimetypecount = atoi(reader.LinePtr());
    1: 
    1:     char *stackalloced[PLUGIN_REG_MIMETYPES_ARRAY_SIZE * 3];
    1:     char **mimetypes;
    1:     char **mimedescriptions;
    1:     char **extensions;
    1:     char **heapalloced = 0;
    1:     if (mimetypecount > PLUGIN_REG_MIMETYPES_ARRAY_SIZE - 1) {
    1:       heapalloced = new char *[mimetypecount * 3];
    1:       mimetypes = heapalloced;
    1:     } else {
    1:       mimetypes = stackalloced;
    1:     }
    1:     mimedescriptions = mimetypes + mimetypecount;
    1:     extensions = mimedescriptions + mimetypecount;
    1: 
    1:     int mtr = 0; //mimetype read
    1:     for (; mtr < mimetypecount; mtr++) {
    1:       if (!reader.NextLine())
    1:         break;
    1: 
    1:       //line number|mimetype|description|extension
    1:       if (4 != reader.ParseLine(values, 4))
    1:         break;
    1:       int line = atoi(values[0]);
    1:       if (line != mtr)
    1:         break;
    1:       mimetypes[mtr] = values[1];
    1:       mimedescriptions[mtr] = values[2];
    1:       extensions[mtr] = values[3];
    1:     }
    1: 
    1:     if (mtr != mimetypecount) {
    1:       if (heapalloced) {
    1:         delete [] heapalloced;
    1:       }
    1:       return rv;
    1:     }
    1: 
 3102:     nsRefPtr<nsPluginTag> tag = new nsPluginTag(name,
    1:       description,
    1:       filename,
29020:       fullpath,
15947:       version,
    1:       (const char* const*)mimetypes,
    1:       (const char* const*)mimedescriptions,
    1:       (const char* const*)extensions,
12841:       mimetypecount, lastmod, canunload, PR_TRUE);
21231:     if (heapalloced)
    1:       delete [] heapalloced;
21231: 
21231:     if (!tag)
    1:       continue;
    1: 
    1:     // Mark plugin as loaded from cache
    1:     tag->Mark(tagflag | NS_PLUGIN_FLAG_FROMCACHE);
    1:     PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_BASIC,
12988:       ("LoadCachedPluginsInfo : Loading Cached plugininfo for %s\n", tag->mFileName.get()));
    1:     tag->mNext = mCachedPlugins;
    1:     mCachedPlugins = tag;
59080:   }
59080:   
59080:   if (hasInvalidPlugins) {
59080:     if (!ReadSectionHeader(reader, "INVALID")) {
59080:       return rv;
59080:     }
59080: 
59080:     while (reader.NextLine()) {
59080:       const char *fullpath = reader.LinePtr();
59080:       if (!reader.NextLine()) {
59080:         return rv;
59080:       }
59080:       
59080:       const char *lastModifiedTimeStamp = reader.LinePtr();
59080:       PRInt64 lastmod = (vdiff == 0) ? nsCRT::atoll(lastModifiedTimeStamp) : -1;
59080:       
59080:       nsRefPtr<nsInvalidPluginTag> invalidTag = new nsInvalidPluginTag(fullpath, lastmod);
59080:       
59080:       invalidTag->mNext = mInvalidPlugins;
59080:       if (mInvalidPlugins) {
59080:         mInvalidPlugins->mPrev = invalidTag;
59080:       }
59080:       mInvalidPlugins = invalidTag;
59080:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
 3102: void
29956: nsPluginHost::RemoveCachedPluginsInfo(const char *filePath, nsPluginTag **result)
 3102: {
 3102:   nsRefPtr<nsPluginTag> prev;
 3102:   nsRefPtr<nsPluginTag> tag = mCachedPlugins;
 3102:   while (tag)
    1:   {
29020:     if (tag->mFullPath.Equals(filePath)) {
    1:       // Found it. Remove it from our list
 3102:       if (prev)
 3102:         prev->mNext = tag->mNext;
 3102:       else
 3102:         mCachedPlugins = tag->mNext;
 3102:       tag->mNext = nsnull;
 3102:       *result = tag;
 3102:       NS_ADDREF(*result);
 3102:       break;
 3102:     }
 3102:     prev = tag;
 3102:     tag = tag->mNext;
 3102:   }
    1: }
    1: 
 3715: #ifdef XP_WIN
    1: nsresult
29956: nsPluginHost::EnsurePrivateDirServiceProvider()
    1: {
21231:   if (!mPrivateDirServiceProvider) {
    1:     nsresult rv;
    1:     mPrivateDirServiceProvider = new nsPluginDirServiceProvider();
    1:     if (!mPrivateDirServiceProvider)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     nsCOMPtr<nsIDirectoryService> dirService(do_GetService(kDirectoryServiceContractID, &rv));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     rv = dirService->RegisterProvider(mPrivateDirServiceProvider);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:   }
    1:   return NS_OK;
    1: }
 3715: #endif /* XP_WIN */
    1: 
29956: nsresult nsPluginHost::NewPluginURLStream(const nsString& aURL,
47835:                                           nsNPAPIPluginInstance *aInstance,
    1:                                           nsIPluginStreamListener* aListener,
36766:                                           nsIInputStream *aPostStream,
    1:                                           const char *aHeadersData,
    1:                                           PRUint32 aHeadersDataLen)
    1: {
    1:   nsCOMPtr<nsIURI> url;
    1:   nsAutoString absUrl;
    1:   nsresult rv;
    1: 
    1:   if (aURL.Length() <= 0)
    1:     return NS_OK;
    1: 
    1:   // get the full URL of the document that the plugin is embedded
    1:   //   in to create an absolute url in case aURL is relative
    1:   nsCOMPtr<nsIDocument> doc;
  353:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   aInstance->GetOwner(getter_AddRefs(owner));
21231:   if (owner) {
    1:     rv = owner->GetDocument(getter_AddRefs(doc));
21231:     if (NS_SUCCEEDED(rv) && doc) {
    1:       // Create an absolute URL
41900:       rv = NS_MakeAbsoluteURI(absUrl, aURL, doc->GetDocBaseURI());
    1:     }
    1:   }
    1: 
    1:   if (absUrl.IsEmpty())
    1:     absUrl.Assign(aURL);
    1: 
    1:   rv = NS_NewURI(getter_AddRefs(url), absUrl);
34262:   if (NS_FAILED(rv))
34262:     return rv;
34262: 
29952:   nsCOMPtr<nsIPluginTagInfo> pti = do_QueryInterface(owner);
  353:   nsCOMPtr<nsIDOMElement> element;
29952:   if (pti)
29952:     pti->GetDOMElement(getter_AddRefs(element));
  353: 
  353:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
 2501:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OBJECT_SUBREQUEST,
  353:                                  url,
 4367:                                  (doc ? doc->NodePrincipal() : nsnull),
  353:                                  element,
  353:                                  EmptyCString(), //mime guess
  353:                                  nsnull,         //extra
  353:                                  &shouldLoad);
34262:   if (NS_FAILED(rv))
34262:     return rv;
  353:   if (NS_CP_REJECTED(shouldLoad)) {
  353:     // Disallowed by content policy
  353:     return NS_ERROR_CONTENT_BLOCKED;
  353:   }
  353: 
36766:   nsRefPtr<nsPluginStreamListenerPeer> listenerPeer = new nsPluginStreamListenerPeer();
47835:   if (!listenerPeer)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   rv = listenerPeer->Initialize(url, aInstance, aListener);
36766:   if (NS_FAILED(rv))
34262:     return rv;
34262: 
    1:   nsCOMPtr<nsIChannel> channel;
    1:   rv = NS_NewChannel(getter_AddRefs(channel), url, nsnull,
    1:     nsnull, /* do not add this internal plugin's channel
    1:             on the load group otherwise this channel could be canceled
28078:             form |nsDocShell::OnLinkClickSync| bug 166613 */
57651:     listenerPeer);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
21231:   if (doc) {
    1:     // Set the owner of channel to the document principal...
    1:     channel->SetOwner(doc->NodePrincipal());
    1: 
    1:     // And if it's a script allow it to execute against the
    1:     // document's script context.
    1:     nsCOMPtr<nsIScriptChannel> scriptChannel(do_QueryInterface(channel));
    1:     if (scriptChannel) {
    1:       scriptChannel->SetExecutionPolicy(nsIScriptChannel::EXECUTE_NORMAL);
 2364:       // Plug-ins seem to depend on javascript: URIs running synchronously
 2364:       scriptChannel->SetExecuteAsync(PR_FALSE);
    1:     }
    1:   }
    1: 
    1:   // deal with headers and post data
    1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
    1:   if (httpChannel) {
36766:     if (aPostStream) {
    1:       // XXX it's a bit of a hack to rewind the postdata stream
    1:       // here but it has to be done in case the post data is
    1:       // being reused multiple times.
    1:       nsCOMPtr<nsISeekableStream>
36766:       postDataSeekable(do_QueryInterface(aPostStream));
    1:       if (postDataSeekable)
    1:         postDataSeekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
    1: 
    1:       nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
    1:       NS_ASSERTION(uploadChannel, "http must support nsIUploadChannel");
    1: 
36766:       uploadChannel->SetUploadStream(aPostStream, EmptyCString(), -1);
    1:     }
    1: 
    1:     if (aHeadersData)
    1:       rv = AddHeadersToChannel(aHeadersData, aHeadersDataLen, httpChannel);
    1:   }
    1:   rv = channel->AsyncOpen(listenerPeer, nsnull);
    1:   return rv;
    1: }
    1: 
21231: // Called by GetURL and PostURL
    1: nsresult
47835: nsPluginHost::DoURLLoadSecurityCheck(nsNPAPIPluginInstance *aInstance,
    1:                                      const char* aURL)
    1: {
    1:   if (!aURL || *aURL == '\0')
    1:     return NS_OK;
    1: 
    1:   // get the URL of the document that loaded the plugin
    1:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   aInstance->GetOwner(getter_AddRefs(owner));
    1:   if (!owner)
    1:     return NS_ERROR_FAILURE;
    1: 
29834:   nsCOMPtr<nsIDocument> doc;
29834:   owner->GetDocument(getter_AddRefs(doc));
    1:   if (!doc)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Create an absolute URL for the target in case the target is relative
    1:   nsCOMPtr<nsIURI> targetURL;
41900:   NS_NewURI(getter_AddRefs(targetURL), aURL, doc->GetDocBaseURI());
    1:   if (!targetURL)
    1:     return NS_ERROR_FAILURE;
    1: 
29834:   nsresult rv;
    1:   nsCOMPtr<nsIScriptSecurityManager> secMan(
    1:     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   return secMan->CheckLoadURIWithPrincipal(doc->NodePrincipal(), targetURL,
    1:                                            nsIScriptSecurityManager::STANDARD);
    1: 
    1: }
    1: 
29574: nsresult
29956: nsPluginHost::AddHeadersToChannel(const char *aHeadersData,
    1:                                   PRUint32 aHeadersDataLen,
    1:                                   nsIChannel *aGenericChannel)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsCOMPtr<nsIHttpChannel> aChannel = do_QueryInterface(aGenericChannel);
    1:   if (!aChannel) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   // used during the manipulation of the String from the aHeadersData
    1:   nsCAutoString headersString;
    1:   nsCAutoString oneHeader;
    1:   nsCAutoString headerName;
    1:   nsCAutoString headerValue;
    1:   PRInt32 crlf = 0;
    1:   PRInt32 colon = 0;
    1: 
    1:   // Turn the char * buffer into an nsString.
    1:   headersString = aHeadersData;
    1: 
    1:   // Iterate over the nsString: for each "\r\n" delimited chunk,
    1:   // add the value as a header to the nsIHTTPChannel
    1:   while (PR_TRUE) {
    1:     crlf = headersString.Find("\r\n", PR_TRUE);
    1:     if (-1 == crlf) {
    1:       rv = NS_OK;
    1:       return rv;
    1:     }
    1:     headersString.Mid(oneHeader, 0, crlf);
    1:     headersString.Cut(0, crlf + 2);
    1:     oneHeader.StripWhitespace();
    1:     colon = oneHeader.Find(":");
    1:     if (-1 == colon) {
    1:       rv = NS_ERROR_NULL_POINTER;
    1:       return rv;
    1:     }
    1:     oneHeader.Left(headerName, colon);
    1:     colon++;
    1:     oneHeader.Mid(headerValue, colon, oneHeader.Length() - colon);
    1: 
    1:     // FINALLY: we can set the header!
    1: 
    1:     rv = aChannel->SetRequestHeader(headerName, headerValue, PR_TRUE);
    1:     if (NS_FAILED(rv)) {
    1:       rv = NS_ERROR_NULL_POINTER;
    1:       return rv;
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::StopPluginInstance(nsIPluginInstance* aInstance)
    1: {
12417:   if (PluginDestructionGuard::DelayDestroy(aInstance)) {
12417:     return NS_OK;
12417:   }
12417: 
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
29956:   ("nsPluginHost::StopPluginInstance called instance=%p\n",aInstance));
    1: 
59645:   aInstance->Stop();
59645: 
59487:   nsNPAPIPluginInstance* instance = static_cast<nsNPAPIPluginInstance*>(aInstance);
37525: 
    1:   // if the plugin does not want to be 'cached' just remove it
    1:   PRBool doCache = PR_TRUE;
32799:   aInstance->ShouldCache(&doCache);
37525:   if (doCache) {
    1:     // try to get the max cached plugins from a pref or use default
37525:     PRUint32 cachedPluginLimit;
    1:     nsresult rv = NS_ERROR_FAILURE;
21231:     if (mPrefService)
37525:       rv = mPrefService->GetIntPref(NS_PREF_MAX_NUM_CACHED_PLUGINS, (int*)&cachedPluginLimit);
21231:     if (NS_FAILED(rv))
37525:       cachedPluginLimit = DEFAULT_NUMBER_OF_STOPPED_PLUGINS;
37525:     
47965:     if (StoppedInstanceCount() >= cachedPluginLimit) {
47965:       nsNPAPIPluginInstance *oldestInstance = FindOldestStoppedInstance();
47965:       if (oldestInstance) {
47965:         nsPluginTag* pluginTag = TagForPlugin(oldestInstance->GetPlugin());
47965:         oldestInstance->Destroy();
47965:         mInstances.RemoveElement(oldestInstance);
37525:         OnPluginInstanceDestroyed(pluginTag);
37525:       }
37525:     }
37525:   } else {
47965:     nsPluginTag* pluginTag = TagForPlugin(instance->GetPlugin());
47965:     instance->Destroy();
47965:     mInstances.RemoveElement(instance);
37525:     OnPluginInstanceDestroyed(pluginTag);
37525:   }
37525: 
    1:   return NS_OK;
    1: }
    1: 
29956: nsresult nsPluginHost::NewEmbeddedPluginStreamListener(nsIURI* aURL,
    1:                                                        nsIPluginInstanceOwner *aOwner,
47835:                                                        nsNPAPIPluginInstance* aInstance,
    1:                                                        nsIStreamListener** aListener)
    1: {
    1:   if (!aURL)
    1:     return NS_OK;
    1: 
47835:   nsRefPtr<nsPluginStreamListenerPeer> listener = new nsPluginStreamListenerPeer();
47835:   if (!listener)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsresult rv;
    1: 
    1:   // if we have an instance, everything has been set up
    1:   // if we only have an owner, then we need to pass it in
    1:   // so the listener can set up the instance later after
    1:   // we've determined the mimetype of the stream
47835:   if (aInstance)
    1:     rv = listener->InitializeEmbedded(aURL, aInstance);
    1:   else if (aOwner != nsnull)
37525:     rv = listener->InitializeEmbedded(aURL, nsnull, aOwner);
    1:   else
    1:     rv = NS_ERROR_ILLEGAL_VALUE;
    1:   if (NS_SUCCEEDED(rv))
    1:     NS_ADDREF(*aListener = listener);
    1: 
    1:   return rv;
    1: }
    1: 
21231: // Called by InstantiateEmbeddedPlugin()
29956: nsresult nsPluginHost::NewEmbeddedPluginStream(nsIURI* aURL,
    1:                                                nsIPluginInstanceOwner *aOwner,
47835:                                                nsNPAPIPluginInstance* aInstance)
    1: {
    1:   nsCOMPtr<nsIStreamListener> listener;
    1:   nsresult rv = NewEmbeddedPluginStreamListener(aURL, aOwner, aInstance,
    1:                                                 getter_AddRefs(listener));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIDocument> doc;
    1:     nsCOMPtr<nsILoadGroup> loadGroup;
    1:     if (aOwner) {
    1:       rv = aOwner->GetDocument(getter_AddRefs(doc));
    1:       if (NS_SUCCEEDED(rv) && doc) {
    1:         loadGroup = doc->GetDocumentLoadGroup();
    1:       }
    1:     }
    1:     nsCOMPtr<nsIChannel> channel;
    1:     rv = NS_NewChannel(getter_AddRefs(channel), aURL, nsnull, loadGroup, nsnull);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       // if this is http channel, set referrer, some servers are configured
    1:       // to reject requests without referrer set, see bug 157796
    1:       nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
    1:       if (httpChannel && doc)
    1:         httpChannel->SetReferrer(doc->GetDocumentURI());
    1: 
    1:       rv = channel->AsyncOpen(listener, nsnull);
    1:       if (NS_SUCCEEDED(rv))
    1:         return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
21231: // Called by InstantiateFullPagePlugin()
47865: nsresult nsPluginHost::NewFullPagePluginStream(nsIURI* aURI,
47865:                                                nsNPAPIPluginInstance *aInstance,
47865:                                                nsIStreamListener **aStreamListener)
    1: {
47865:   NS_ASSERTION(aStreamListener, "Stream listener out param cannot be null");
47865: 
47865:   nsRefPtr<nsPluginStreamListenerPeer> listener = new nsPluginStreamListenerPeer();
21231:   if (!listener)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
47865:   nsresult rv = listener->InitializeFullPage(aURI, aInstance);
47865:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
47865:   listener.forget(aStreamListener);
47865: 
47865:   return NS_OK;
47865: }
47865: 
29956: NS_IMETHODIMP nsPluginHost::Observe(nsISupports *aSubject,
    1:                                     const char *aTopic,
    1:                                     const PRUnichar *someData)
    1: {
21231:   if (!nsCRT::strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, aTopic)) {
 3363:     OnShutdown();
    1:     Destroy();
    1:     sInst->Release();
    1:   }
24475:   if (!nsCRT::strcmp(NS_PRIVATE_BROWSING_SWITCH_TOPIC, aTopic)) {
30005:     // inform all active plugins of changed private mode state
47965:     for (PRUint32 i = 0; i < mInstances.Length(); i++) {
47965:       mInstances[i]->PrivateModeStateChanged();
24475:     }
24475:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::HandleBadPlugin(PRLibrary* aLibrary, nsIPluginInstance *aInstance)
    1: {
    1:   // the |aLibrary| parameter is not needed anymore, after we added |aInstance| which
    1:   // can also be used to look up the plugin name, but we cannot get rid of it because
    1:   // the |nsIPluginHost| interface is deprecated which in fact means 'frozen'
    1: 
58895:   NS_ERROR("Plugin performed illegal operation");
58895:   NS_ENSURE_ARG_POINTER(aInstance);
    1: 
    1:   if (mDontShowBadPluginMessage)
58895:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   aInstance->GetOwner(getter_AddRefs(owner));
    1: 
    1:   nsCOMPtr<nsIPrompt> prompt;
    1:   GetPrompt(owner, getter_AddRefs(prompt));
58895:   if (!prompt)
58895:     return NS_OK;
58895: 
42314:   nsCOMPtr<nsIStringBundleService> strings =
42314:     mozilla::services::GetStringBundleService();
42314:   if (!strings)
42314:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIStringBundle> bundle;
58895:   nsresult rv = strings->CreateBundle(BRAND_PROPERTIES_URL, getter_AddRefs(bundle));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsXPIDLString brandName;
58895:   rv = bundle->GetStringFromName(NS_LITERAL_STRING("brandShortName").get(),
58895:                                  getter_Copies(brandName));
58895:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   rv = strings->CreateBundle(PLUGIN_PROPERTIES_URL, getter_AddRefs(bundle));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsXPIDLString title, message, checkboxMessage;
58895:   rv = bundle->GetStringFromName(NS_LITERAL_STRING("BadPluginTitle").get(),
58895:                                  getter_Copies(title));
58895:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   const PRUnichar *formatStrings[] = { brandName.get() };
    1:   if (NS_FAILED(rv = bundle->FormatStringFromName(NS_LITERAL_STRING("BadPluginMessage").get(),
    1:                                formatStrings, 1, getter_Copies(message))))
    1:     return rv;
    1: 
58895:   rv = bundle->GetStringFromName(NS_LITERAL_STRING("BadPluginCheckboxMessage").get(),
58895:                                  getter_Copies(checkboxMessage));
58895:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
47965:   nsNPAPIPluginInstance *instance = static_cast<nsNPAPIPluginInstance*>(aInstance);
47965: 
47965:   nsNPAPIPlugin *plugin = instance->GetPlugin();
47965:   if (!plugin)
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   nsPluginTag *pluginTag = TagForPlugin(plugin);
47965: 
    1:   // add plugin name to the message
12841:   nsCString pluginname;
59677:   if (pluginTag) {
58895:     if (!pluginTag->mName.IsEmpty()) {
47965:       pluginname = pluginTag->mName;
58895:     } else {
47965:       pluginname = pluginTag->mFileName;
58895:     }
59677:   } else {
59678:     pluginname.AppendLiteral("???");
59677:   }
    1: 
12841:   NS_ConvertUTF8toUTF16 msg(pluginname);
    1:   msg.AppendLiteral("\n\n");
    1:   msg.Append(message);
    1: 
    1:   PRInt32 buttonPressed;
    1:   PRBool checkboxState = PR_FALSE;
    1:   rv = prompt->ConfirmEx(title, msg.get(),
    1:                        nsIPrompt::BUTTON_TITLE_OK * nsIPrompt::BUTTON_POS_0,
    1:                        nsnull, nsnull, nsnull,
    1:                        checkboxMessage, &checkboxState, &buttonPressed);
    1: 
    1: 
    1:   if (NS_SUCCEEDED(rv) && checkboxState)
    1:     mDontShowBadPluginMessage = PR_TRUE;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::ParsePostBufferToFixHeaders(const char *inPostData, PRUint32 inPostDataLen,
    1:                                           char **outPostData, PRUint32 *outPostDataLen)
    1: {
    1:   if (!inPostData || !outPostData || !outPostDataLen)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *outPostData = 0;
    1:   *outPostDataLen = 0;
    1: 
    1:   const char CR = '\r';
    1:   const char LF = '\n';
    1:   const char CRLFCRLF[] = {CR,LF,CR,LF,'\0'}; // C string"\r\n\r\n"
    1:   const char ContentLenHeader[] = "Content-length";
    1: 
26912:   nsAutoTArray<const char*, 8> singleLF;
    1:   const char *pSCntlh = 0;// pointer to start of ContentLenHeader in inPostData
    1:   const char *pSod = 0;   // pointer to start of data in inPostData
    1:   const char *pEoh = 0;   // pointer to end of headers in inPostData
    1:   const char *pEod = inPostData + inPostDataLen; // pointer to end of inPostData
    1:   if (*inPostData == LF) {
    1:     // If no custom headers are required, simply add a blank
    1:     // line ('\n') to the beginning of the file or buffer.
    1:     // so *inPostData == '\n' is valid
    1:     pSod = inPostData + 1;
    1:   } else {
    1:     const char *s = inPostData; //tmp pointer to sourse inPostData
    1:     while (s < pEod) {
    1:       if (!pSCntlh &&
    1:           (*s == 'C' || *s == 'c') &&
    1:           (s + sizeof(ContentLenHeader) - 1 < pEod) &&
    1:           (!PL_strncasecmp(s, ContentLenHeader, sizeof(ContentLenHeader) - 1)))
    1:       {
    1:         // lets assume this is ContentLenHeader for now
    1:         const char *p = pSCntlh = s;
    1:         p += sizeof(ContentLenHeader) - 1;
    1:         // search for first CR or LF == end of ContentLenHeader
    1:         for (; p < pEod; p++) {
    1:           if (*p == CR || *p == LF) {
    1:             // got delimiter,
    1:             // one more check; if previous char is a digit
    1:             // most likely pSCntlh points to the start of ContentLenHeader
    1:             if (*(p-1) >= '0' && *(p-1) <= '9') {
    1:               s = p;
    1:             }
    1:             break; //for loop
    1:           }
    1:         }
    1:         if (pSCntlh == s) { // curret ptr is the same
    1:           pSCntlh = 0; // that was not ContentLenHeader
    1:           break; // there is nothing to parse, break *WHILE LOOP* here
    1:         }
    1:       }
    1: 
    1:       if (*s == CR) {
    1:         if (pSCntlh && // only if ContentLenHeader is found we are looking for end of headers
    1:             ((s + sizeof(CRLFCRLF)-1) <= pEod) &&
    1:             !memcmp(s, CRLFCRLF, sizeof(CRLFCRLF)-1))
    1:         {
    1:           s += sizeof(CRLFCRLF)-1;
    1:           pEoh = pSod = s; // data stars here
    1:           break;
    1:         }
    1:       } else if (*s == LF) {
    1:         if (*(s-1) != CR) {
26912:           singleLF.AppendElement(s);
    1:         }
    1:         if (pSCntlh && (s+1 < pEod) && (*(s+1) == LF)) {
    1:           s++;
26912:           singleLF.AppendElement(s);
    1:           s++;
    1:           pEoh = pSod = s; // data stars here
    1:           break;
    1:         }
    1:       }
    1:       s++;
    1:     }
    1:   }
    1: 
    1:   // deal with output buffer
    1:   if (!pSod) { // lets assume whole buffer is a data
    1:     pSod = inPostData;
    1:   }
    1: 
    1:   PRUint32 newBufferLen = 0;
    1:   PRUint32 dataLen = pEod - pSod;
    1:   PRUint32 headersLen = pEoh ? pSod - inPostData : 0;
    1: 
    1:   char *p; // tmp ptr into new output buf
    1:   if (headersLen) { // we got a headers
    1:     // this function does not make any assumption on correctness
    1:     // of ContentLenHeader value in this case.
    1: 
    1:     newBufferLen = dataLen + headersLen;
    1:     // in case there were single LFs in headers
    1:     // reserve an extra space for CR will be added before each single LF
26912:     int cntSingleLF = singleLF.Length();
    1:     newBufferLen += cntSingleLF;
    1: 
    1:     if (!(*outPostData = p = (char*)nsMemory::Alloc(newBufferLen)))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // deal with single LF
    1:     const char *s = inPostData;
    1:     if (cntSingleLF) {
    1:       for (int i=0; i<cntSingleLF; i++) {
26912:         const char *plf = singleLF.ElementAt(i); // ptr to single LF in headers
    1:         int n = plf - s; // bytes to copy
    1:         if (n) { // for '\n\n' there is nothing to memcpy
    1:           memcpy(p, s, n);
    1:           p += n;
    1:         }
    1:         *p++ = CR;
    1:         s = plf;
    1:         *p++ = *s++;
    1:       }
    1:     }
    1:     // are we done with headers?
    1:     headersLen = pEoh - s;
    1:     if (headersLen) { // not yet
    1:       memcpy(p, s, headersLen); // copy the rest
    1:       p += headersLen;
    1:     }
    1:   } else  if (dataLen) { // no ContentLenHeader is found but there is a data
    1:     // make new output buffer big enough
    1:     // to keep ContentLenHeader+value followed by data
    1:     PRUint32 l = sizeof(ContentLenHeader) + sizeof(CRLFCRLF) + 32;
    1:     newBufferLen = dataLen + l;
    1:     if (!(*outPostData = p = (char*)nsMemory::Alloc(newBufferLen)))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     headersLen = PR_snprintf(p, l,"%s: %ld%s", ContentLenHeader, dataLen, CRLFCRLF);
    1:     if (headersLen == l) { // if PR_snprintf has ate all extra space consider this as an error
    1:       nsMemory::Free(p);
    1:       *outPostData = 0;
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     p += headersLen;
    1:     newBufferLen = headersLen + dataLen;
    1:   }
    1:   // at this point we've done with headers.
    1:   // there is a possibility that input buffer has only headers info in it
    1:   // which already parsed and copied into output buffer.
    1:   // copy the data
    1:   if (dataLen) {
    1:     memcpy(p, pSod, dataLen);
    1:   }
    1: 
    1:   *outPostDataLen = newBufferLen;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
36766: nsPluginHost::CreateTempFileToPost(const char *aPostDataURL, nsIFile **aTmpFile)
    1: {
    1:   nsresult rv;
    1:   PRInt64 fileSize;
    1:   nsCAutoString filename;
    1: 
    1:   // stat file == get size & convert file:///c:/ to c: if needed
    1:   nsCOMPtr<nsIFile> inFile;
36766:   rv = NS_GetFileFromURLSpec(nsDependentCString(aPostDataURL),
    1:                              getter_AddRefs(inFile));
    1:   if (NS_FAILED(rv)) {
    1:     nsCOMPtr<nsILocalFile> localFile;
36766:     rv = NS_NewNativeLocalFile(nsDependentCString(aPostDataURL), PR_FALSE,
    1:                                getter_AddRefs(localFile));
    1:     if (NS_FAILED(rv)) return rv;
    1:     inFile = localFile;
    1:   }
    1:   rv = inFile->GetFileSize(&fileSize);
    1:   if (NS_FAILED(rv)) return rv;
    1:   rv = inFile->GetNativePath(filename);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   if (!LL_IS_ZERO(fileSize)) {
    1:     nsCOMPtr<nsIInputStream> inStream;
    1:     rv = NS_NewLocalFileInputStream(getter_AddRefs(inStream), inFile);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Create a temporary file to write the http Content-length:
    1:     // %ld\r\n\" header and "\r\n" == end of headers for post data to
    1: 
    1:     nsCOMPtr<nsIFile> tempFile;
    1:     rv = GetPluginTempDir(getter_AddRefs(tempFile));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCAutoString inFileName;
    1:     inFile->GetNativeLeafName(inFileName);
    1:     // XXX hack around bug 70083
    1:     inFileName.Insert(NS_LITERAL_CSTRING("post-"), 0);
    1:     rv = tempFile->AppendNative(inFileName);
    1: 
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     // make it unique, and mode == 0600, not world-readable
    1:     rv = tempFile->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCOMPtr<nsIOutputStream> outStream;
    1:     if (NS_SUCCEEDED(rv)) {
    1:       rv = NS_NewLocalFileOutputStream(getter_AddRefs(outStream),
    1:         tempFile,
    1:         (PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE),
    1:         0600); // 600 so others can't read our form data
    1:     }
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Post data file couldn't be created!");
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     char buf[1024];
    1:     PRUint32 br, bw;
    1:     PRBool firstRead = PR_TRUE;
    1:     while (1) {
    1:       // Read() mallocs if buffer is null
    1:       rv = inStream->Read(buf, 1024, &br);
    1:       if (NS_FAILED(rv) || (PRInt32)br <= 0)
    1:         break;
    1:       if (firstRead) {
    1:         //"For protocols in which the headers must be distinguished from the body,
    1:         // such as HTTP, the buffer or file should contain the headers, followed by
    1:         // a blank line, then the body. If no custom headers are required, simply
    1:         // add a blank line ('\n') to the beginning of the file or buffer.
    1: 
    1:         char *parsedBuf;
    1:         // assuming first 1K (or what we got) has all headers in,
29956:         // lets parse it through nsPluginHost::ParsePostBufferToFixHeaders()
    1:         ParsePostBufferToFixHeaders((const char *)buf, br, &parsedBuf, &bw);
    1:         rv = outStream->Write(parsedBuf, bw, &br);
    1:         nsMemory::Free(parsedBuf);
    1:         if (NS_FAILED(rv) || (bw != br))
    1:           break;
    1: 
    1:         firstRead = PR_FALSE;
    1:         continue;
    1:       }
    1:       bw = br;
    1:       rv = outStream->Write(buf, bw, &br);
    1:       if (NS_FAILED(rv) || (bw != br))
    1:         break;
    1:     }
    1: 
    1:     inStream->Close();
    1:     outStream->Close();
36766:     if (NS_SUCCEEDED(rv))
36766:       *aTmpFile = tempFile.forget().get();
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::NewPluginNativeWindow(nsPluginNativeWindow ** aPluginNativeWindow)
    1: {
    1:   return PLUG_NewPluginNativeWindow(aPluginNativeWindow);
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::DeletePluginNativeWindow(nsPluginNativeWindow * aPluginNativeWindow)
    1: {
    1:   return PLUG_DeletePluginNativeWindow(aPluginNativeWindow);
    1: }
    1: 
 6774: NS_IMETHODIMP
29956: nsPluginHost::InstantiateDummyJavaPlugin(nsIPluginInstanceOwner *aOwner)
 6774: {
 6774:   // Pass PR_FALSE as the second arg, we want the answer to be the
 6774:   // same here whether the Java plugin is enabled or not.
 6774:   nsPluginTag *plugin = FindPluginForType("application/x-java-vm", PR_FALSE);
 6774: 
 6774:   if (!plugin || !plugin->mIsNPRuntimeEnabledJavaPlugin) {
 6774:     // No NPRuntime enabled Java plugin found, no point in
 6774:     // instantiating a dummy plugin then.
 6774: 
 6774:     return NS_OK;
 6774:   }
 6774: 
 6774:   nsresult rv = SetUpPluginInstance("application/x-java-vm", nsnull, aOwner);
 6774:   NS_ENSURE_SUCCESS(rv, rv);
 6774: 
 6774:   nsCOMPtr<nsIPluginInstance> instance;
 6774:   aOwner->GetInstance(*getter_AddRefs(instance));
29953:   if (!instance)
 6774:     return NS_OK;
29953: 
29953:   instance->DefineJavaProperties();
 6774: 
 6774:   return NS_OK;
 6774: }
 6774: 
14390: NS_IMETHODIMP
29956: nsPluginHost::GetPluginName(nsIPluginInstance *aPluginInstance,
15698:                             const char** aPluginName)
15698: {
47965:   nsNPAPIPluginInstance *instance = static_cast<nsNPAPIPluginInstance*>(aPluginInstance);
47965:   if (!instance)
37525:     return NS_ERROR_FAILURE;
37525: 
47965:   nsNPAPIPlugin* plugin = instance->GetPlugin();
47965:   if (!plugin)
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   *aPluginName = TagForPlugin(plugin)->mName.get();
37525: 
14390:   return NS_OK;
14390: }
14390: 
33384: NS_IMETHODIMP
33384: nsPluginHost::GetPluginTagForInstance(nsIPluginInstance *aPluginInstance,
33384:                                       nsIPluginTag **aPluginTag)
33384: {
33384:   NS_ENSURE_ARG_POINTER(aPluginInstance);
33384:   NS_ENSURE_ARG_POINTER(aPluginTag);
33384: 
47965:   nsNPAPIPluginInstance *instance = static_cast<nsNPAPIPluginInstance*>(aPluginInstance);
47965:   nsNPAPIPlugin *plugin = instance->GetPlugin();
47965:   if (!plugin)
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   *aPluginTag = TagForPlugin(plugin);
47965: 
33384:   NS_ADDREF(*aPluginTag);
33384:   return NS_OK;
33384: }
33384: 
36227: #ifdef MAC_CARBON_PLUGINS
36227: // Flash requires a minimum of 8 events per second to avoid audio skipping.
36227: // Since WebKit uses a hidden plugin event rate of 4 events per second Flash
36227: // uses a Carbon timer for WebKit which fires at 8 events per second.
36227: #define HIDDEN_PLUGIN_DELAY 125
36227: #define VISIBLE_PLUGIN_DELAY 20
36227: #endif
36227: 
36227: void nsPluginHost::AddIdleTimeTarget(nsIPluginInstanceOwner* objectFrame, PRBool isVisible)
36227: {
36227: #ifdef MAC_CARBON_PLUGINS
36227:   nsTObserverArray<nsIPluginInstanceOwner*> *targetArray;
36227:   if (isVisible) {
36227:     targetArray = &mVisibleTimerTargets;
36227:   } else {
36227:     targetArray = &mHiddenTimerTargets;
36227:   }
36227: 
36227:   if (targetArray->Contains(objectFrame)) {
36227:     return;
36227:   }
36227: 
36227:   targetArray->AppendElement(objectFrame);
36227:   if (targetArray->Length() == 1) {
36227:     if (isVisible) {
36227:       mVisiblePluginTimer->InitWithCallback(this, VISIBLE_PLUGIN_DELAY, nsITimer::TYPE_REPEATING_SLACK);
36227:     } else {
36227:       mHiddenPluginTimer->InitWithCallback(this, HIDDEN_PLUGIN_DELAY, nsITimer::TYPE_REPEATING_SLACK);
36227:     }
36227:   }
36227: #endif
36227: }
36227: 
36227: void nsPluginHost::RemoveIdleTimeTarget(nsIPluginInstanceOwner* objectFrame)
36227: {
36227: #ifdef MAC_CARBON_PLUGINS
36227:   PRBool visibleRemoved = mVisibleTimerTargets.RemoveElement(objectFrame);
36227:   if (visibleRemoved && mVisibleTimerTargets.IsEmpty()) {
36227:     mVisiblePluginTimer->Cancel();
36227:   }
36227: 
36227:   PRBool hiddenRemoved = mHiddenTimerTargets.RemoveElement(objectFrame);
36227:   if (hiddenRemoved && mHiddenTimerTargets.IsEmpty()) {
36227:     mHiddenPluginTimer->Cancel();
36227:   }
36227: 
36227:   NS_ASSERTION(!(hiddenRemoved && visibleRemoved), "Plugin instance received visible and hidden idle event notifications");
36227: #endif
36227: }
36227: 
36227: NS_IMETHODIMP nsPluginHost::Notify(nsITimer* timer)
36227: {
36227: #ifdef MAC_CARBON_PLUGINS
36227:   if (timer == mVisiblePluginTimer) {
36227:     nsTObserverArray<nsIPluginInstanceOwner*>::ForwardIterator iter(mVisibleTimerTargets);
36227:     while (iter.HasMore()) {
36227:       iter.GetNext()->SendIdleEvent();
36227:     }
36227:     return NS_OK;
36227:   } else if (timer == mHiddenPluginTimer) {
36227:     nsTObserverArray<nsIPluginInstanceOwner*>::ForwardIterator iter(mHiddenTimerTargets);
36227:     while (iter.HasMore()) {
36227:       iter.GetNext()->SendIdleEvent();
36227:     }
36227:     return NS_OK;
36227:   }
36227: #endif
36227:   return NS_ERROR_FAILURE;
36227: }
36227: 
36304: #ifdef MOZ_IPC
56921: #ifdef XP_WIN
56921: // Re-enable any top level browser windows that were disabled by modal dialogs
56921: // displayed by the crashed plugin.
56921: static void
56921: CheckForDisabledWindows()
56921: {
56921:   nsCOMPtr<nsIWindowMediator> wm(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
56921:   if (!wm)
56921:     return;
56921: 
56921:   nsCOMPtr<nsISimpleEnumerator> windowList;
56921:   wm->GetXULWindowEnumerator(nsnull, getter_AddRefs(windowList));
56921:   if (!windowList)
56921:     return;
56921: 
56921:   PRBool haveWindows;
56921:   do {
56921:     windowList->HasMoreElements(&haveWindows);
56921:     if (!haveWindows)
56921:       return;
56921: 
56921:     nsCOMPtr<nsISupports> supportsWindow;
56921:     windowList->GetNext(getter_AddRefs(supportsWindow));
56921:     nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(supportsWindow));
56921:     if (baseWin) {
56921:       PRBool aFlag;
56921:       nsCOMPtr<nsIWidget> widget;
56921:       baseWin->GetMainWidget(getter_AddRefs(widget));
56921:       if (widget && !widget->GetParent() &&
56921:           NS_SUCCEEDED(widget->IsVisible(aFlag)) && aFlag == PR_TRUE &&
56921:           NS_SUCCEEDED(widget->IsEnabled(&aFlag)) && aFlag == PR_FALSE) {
56921:         nsIWidget * child = widget->GetFirstChild();
56921:         PRBool enable = PR_TRUE;
56921:         while (child)  {
56921:           nsWindowType aType;
56921:           if (NS_SUCCEEDED(child->GetWindowType(aType)) &&
56921:               aType == eWindowType_dialog) {
56921:             enable = PR_FALSE;
56921:             break;
56921:           }
56921:           child = child->GetNextSibling();
56921:         }
56921:         if (enable) {
56921:           widget->Enable(PR_TRUE);
56921:         }
56921:       }
56921:     }
56921:   } while (haveWindows);
56921: }
56921: #endif
56921: 
36304: void
39794: nsPluginHost::PluginCrashed(nsNPAPIPlugin* aPlugin,
39794:                             const nsAString& pluginDumpID,
39794:                             const nsAString& browserDumpID)
36304: {
47965:   nsPluginTag* crashedPluginTag = TagForPlugin(aPlugin);
36304: 
39794:   // Notify the app's observer that a plugin crashed so it can submit
39794:   // a crashreport.
38026:   PRBool submittedCrashReport = PR_FALSE;
39794:   nsCOMPtr<nsIObserverService> obsService =
41540:     mozilla::services::GetObserverService();
39794:   nsCOMPtr<nsIWritablePropertyBag2> propbag =
39794:     do_CreateInstance("@mozilla.org/hash-property-bag;1");
38026:   if (obsService && propbag) {
39794:     propbag->SetPropertyAsAString(NS_LITERAL_STRING("pluginDumpID"),
39794:                                   pluginDumpID);
39794:     propbag->SetPropertyAsAString(NS_LITERAL_STRING("browserDumpID"),
39794:                                   browserDumpID);
39794:     propbag->SetPropertyAsBool(NS_LITERAL_STRING("submittedCrashReport"),
39794:                                submittedCrashReport);
38026:     obsService->NotifyObservers(propbag, "plugin-crashed", nsnull);
38026:     // see if an observer submitted a crash report.
39794:     propbag->GetPropertyAsBool(NS_LITERAL_STRING("submittedCrashReport"),
39794:                                &submittedCrashReport);
38026:   }
38026: 
36304:   // Invalidate each nsPluginInstanceTag for the crashed plugin
36304: 
47965:   for (PRUint32 i = mInstances.Length(); i > 0; i--) {
47965:     nsNPAPIPluginInstance* instance = mInstances[i - 1];
47965:     if (instance->GetPlugin() == aPlugin) {
39794:       // notify the content node (nsIObjectLoadingContent) that the
39794:       // plugin has crashed
37151:       nsCOMPtr<nsIDOMElement> domElement;
47965:       instance->GetDOMElement(getter_AddRefs(domElement));
37151:       nsCOMPtr<nsIObjectLoadingContent> objectContent(do_QueryInterface(domElement));
37151:       if (objectContent) {
47965:         objectContent->PluginCrashed(crashedPluginTag, pluginDumpID, browserDumpID,
39794:                                      submittedCrashReport);
37151:       }
37151: 
47965:       instance->Destroy();
47965:       mInstances.RemoveElement(instance);
47965:       OnPluginInstanceDestroyed(crashedPluginTag);
36304:     }
36304:   }
36304: 
36304:   // Only after all instances have been invalidated is it safe to null
36304:   // out nsPluginTag.mEntryPoint. The next time we try to create an
36304:   // instance of this plugin we reload it (launch a new plugin process).
36304: 
47965:   crashedPluginTag->mEntryPoint = nsnull;
56921: 
56921: #ifdef XP_WIN
56921:   CheckForDisabledWindows();
56921: #endif
36304: }
36304: #endif
36304: 
47965: nsNPAPIPluginInstance*
47965: nsPluginHost::FindInstance(const char *mimetype)
37841: {
47965:   for (PRUint32 i = 0; i < mInstances.Length(); i++) {
47965:     nsNPAPIPluginInstance* instance = mInstances[i];
37525: 
37525:     const char* mt;
47965:     nsresult rv = instance->GetMIMEType(&mt);
37525:     if (NS_FAILED(rv))
37525:       continue;
37525: 
37525:     if (PL_strcasecmp(mt, mimetype) == 0)
47965:       return instance;
47965:   }
47965: 
37525:   return nsnull;
37525: }
37525: 
47965: nsNPAPIPluginInstance*
47965: nsPluginHost::FindStoppedInstance(const char *url)
37525: {
47965:   for (PRUint32 i = 0; i < mInstances.Length(); i++) {
47965:     nsNPAPIPluginInstance *instance = mInstances[i];
47965: 
47965:     nsIURI *uri = instance->GetURI();
47965:     if (!uri)
47965:       continue;
47965: 
47965:     nsCAutoString spec;
47965:     uri->GetSpec(spec);
47965:     if (!PL_strcmp(url, spec.get()) && !instance->IsRunning())
47965:       return instance;
47965:   }
47965: 
37525:   return nsnull;
37525: }
37525: 
47965: nsNPAPIPluginInstance*
47965: nsPluginHost::FindOldestStoppedInstance()
47965: {
47965:   nsNPAPIPluginInstance *oldestInstance = nsnull;
47965:   TimeStamp oldestTime = TimeStamp::Now();
47965:   for (PRUint32 i = 0; i < mInstances.Length(); i++) {
47965:     nsNPAPIPluginInstance *instance = mInstances[i];
47965:     if (instance->IsRunning())
47965:       continue;
47965: 
47965:     TimeStamp time = instance->LastStopTime();
47965:     if (time < oldestTime) {
47965:       oldestTime = time;
47965:       oldestInstance = instance;
47965:     }
47965:   }
47965: 
47965:   return oldestInstance;
47965: }
47965: 
47965: PRUint32
47965: nsPluginHost::StoppedInstanceCount()
47965: {
47965:   PRUint32 stoppedCount = 0;
47965:   for (PRUint32 i = 0; i < mInstances.Length(); i++) {
47965:     nsNPAPIPluginInstance *instance = mInstances[i];
47965:     if (!instance->IsRunning())
47965:       stoppedCount++;
47965:   }
47965:   return stoppedCount;
47965: }
47965: 
47965: nsTArray< nsRefPtr<nsNPAPIPluginInstance> >*
47965: nsPluginHost::InstanceArray()
47965: {
47965:   return &mInstances;
47965: }
47965: 
37525: void 
47965: nsPluginHost::DestroyRunningInstances(nsISupportsArray* aReloadDocs, nsPluginTag* aPluginTag)
37525: {
47965:   for (PRInt32 i = mInstances.Length(); i > 0; i--) {
47965:     nsNPAPIPluginInstance *instance = mInstances[i - 1];
47965:     if (instance->IsRunning() && (!aPluginTag || aPluginTag == TagForPlugin(instance->GetPlugin()))) {
37525:       instance->SetWindow(nsnull);
37525:       instance->Stop();
37525: 
37525:       // If we've been passed an array to return, lets collect all our documents,
37525:       // removing duplicates. These will be reframed (embedded) or reloaded (full-page) later
37525:       // to kickstart our instances.
37525:       if (aReloadDocs) {
37525:         nsCOMPtr<nsIPluginInstanceOwner> owner;
37525:         instance->GetOwner(getter_AddRefs(owner));
37525:         if (owner) {
37525:           nsCOMPtr<nsIDocument> doc;
37525:           owner->GetDocument(getter_AddRefs(doc));
37525:           if (doc && aReloadDocs->IndexOf(doc) == -1)  // don't allow for duplicates
37525:             aReloadDocs->AppendElement(doc);
37525:         }
37525:       }
37525: 
47965:       // Get rid of all the instances without the possibility of caching.
47965:       nsPluginTag* pluginTag = TagForPlugin(instance->GetPlugin());
47965:       instance->SetWindow(nsnull);
47965:       instance->Destroy();
47965:       mInstances.RemoveElement(instance);
37525:       OnPluginInstanceDestroyed(pluginTag);
37525:     }
37525:   }
37525: }
37525: 
12417: // Runnable that does an async destroy of a plugin.
12417: 
12417: class nsPluginDestroyRunnable : public nsRunnable,
12417:                                 public PRCList
12417: {
12417: public:
12417:   nsPluginDestroyRunnable(nsIPluginInstance *aInstance)
12417:     : mInstance(aInstance)
12417:   {
12417:     PR_INIT_CLIST(this);
12417:     PR_APPEND_LINK(this, &sRunnableListHead);
12417:   }
12417: 
12417:   virtual ~nsPluginDestroyRunnable()
12417:   {
12417:     PR_REMOVE_LINK(this);
12417:   }
12417: 
12417:   NS_IMETHOD Run()
12417:   {
12417:     nsCOMPtr<nsIPluginInstance> instance;
12417: 
12417:     // Null out mInstance to make sure this code in another runnable
12417:     // will do the right thing even if someone was holding on to this
12417:     // runnable longer than we expect.
12417:     instance.swap(mInstance);
12417: 
12417:     if (PluginDestructionGuard::DelayDestroy(instance)) {
12417:       // It's still not safe to destroy the plugin, it's now up to the
12417:       // outermost guard on the stack to take care of the destruction.
12417:       return NS_OK;
12417:     }
12417: 
12417:     nsPluginDestroyRunnable *r =
12417:       static_cast<nsPluginDestroyRunnable*>(PR_NEXT_LINK(&sRunnableListHead));
12417: 
12417:     while (r != &sRunnableListHead) {
12417:       if (r != this && r->mInstance == instance) {
12417:         // There's another runnable scheduled to tear down
12417:         // instance. Let it do the job.
12417:         return NS_OK;
12417:       }
12592:       r = static_cast<nsPluginDestroyRunnable*>(PR_NEXT_LINK(r));
12417:     }
12417: 
12417:     PLUGIN_LOG(PLUGIN_LOG_NORMAL,
12417:                ("Doing delayed destroy of instance %p\n", instance.get()));
12417: 
29956:     nsRefPtr<nsPluginHost> host = nsPluginHost::GetInst();
21231:     if (host)
12417:       host->StopPluginInstance(instance);
12417: 
12417:     PLUGIN_LOG(PLUGIN_LOG_NORMAL,
12417:                ("Done with delayed destroy of instance %p\n", instance.get()));
12417: 
12417:     return NS_OK;
12417:   }
12417: 
12417: protected:
12417:   nsCOMPtr<nsIPluginInstance> mInstance;
12417: 
12417:   static PRCList sRunnableListHead;
12417: };
12417: 
12417: PRCList nsPluginDestroyRunnable::sRunnableListHead =
12417:   PR_INIT_STATIC_CLIST(&nsPluginDestroyRunnable::sRunnableListHead);
12417: 
12417: PRCList PluginDestructionGuard::sListHead =
12417:   PR_INIT_STATIC_CLIST(&PluginDestructionGuard::sListHead);
12417: 
12417: PluginDestructionGuard::~PluginDestructionGuard()
12417: {
12417:   NS_ASSERTION(NS_IsMainThread(), "Should be on the main thread");
12417: 
12417:   PR_REMOVE_LINK(this);
12417: 
12417:   if (mDelayedDestroy) {
12417:     // We've attempted to destroy the plugin instance we're holding on
12417:     // to while we were guarding it. Do the actual destroy now, off of
12417:     // a runnable.
12417:     nsRefPtr<nsPluginDestroyRunnable> evt =
12417:       new nsPluginDestroyRunnable(mInstance);
12417: 
12417:     NS_DispatchToMainThread(evt);
12417:   }
12417: }
12417: 
12417: // static
12417: PRBool
12417: PluginDestructionGuard::DelayDestroy(nsIPluginInstance *aInstance)
12417: {
12417:   NS_ASSERTION(NS_IsMainThread(), "Should be on the main thread");
12417:   NS_ASSERTION(aInstance, "Uh, I need an instance!");
12417: 
12417:   // Find the first guard on the stack and make it do a delayed
12417:   // destroy upon destruction.
12417: 
12417:   PluginDestructionGuard *g =
12417:     static_cast<PluginDestructionGuard*>(PR_LIST_HEAD(&sListHead));
12417: 
12417:   while (g != &sListHead) {
12417:     if (g->mInstance == aInstance) {
12417:       g->mDelayedDestroy = PR_TRUE;
12417: 
12417:       return PR_TRUE;
12417:     }
12417:     g = static_cast<PluginDestructionGuard*>(PR_NEXT_LINK(g));    
12417:   }
12417: 
12417:   return PR_FALSE;
12417: }
