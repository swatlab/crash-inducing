 47243: // Copyright (c) 2010 Google Inc.
 47243: // All rights reserved.
 47243: //
 47243: // Redistribution and use in source and binary forms, with or without
 47243: // modification, are permitted provided that the following conditions are
 47243: // met:
 47243: //
 47243: //     * Redistributions of source code must retain the above copyright
 47243: // notice, this list of conditions and the following disclaimer.
 47243: //     * Redistributions in binary form must reproduce the above
 47243: // copyright notice, this list of conditions and the following disclaimer
 47243: // in the documentation and/or other materials provided with the
 47243: // distribution.
 47243: //     * Neither the name of Google Inc. nor the names of its
 47243: // contributors may be used to endorse or promote products derived from
 47243: // this software without specific prior written permission.
 47243: //
 47243: // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 47243: // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 47243: // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 47243: // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 47243: // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 47243: // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 47243: // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 47243: // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 47243: // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 47243: // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 47243: // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 47243: 
 47243: // Original author: Jim Blandy <jimb@mozilla.com> <jimb@red-bean.com>
 47243: 
 47243: // Implement the DwarfCUToModule class; see dwarf_cu_to_module.h.
 47243: 
114869: // For <inttypes.h> PRI* macros, before anything else might #include it.
114869: #ifndef __STDC_FORMAT_MACROS
114869: #define __STDC_FORMAT_MACROS
114869: #endif  /* __STDC_FORMAT_MACROS */
114869: 
 47243: #include "common/dwarf_cu_to_module.h"
 47243: 
 47243: #include <assert.h>
118328: #include <cxxabi.h>
114869: #include <inttypes.h>
114869: #include <stdio.h>
 47243: 
 47243: #include <algorithm>
 50677: #include <set>
 50677: #include <utility>
 47243: 
 47243: #include "common/dwarf_line_to_module.h"
 47243: 
 47243: namespace google_breakpad {
 47243: 
 47243: using std::map;
 50677: using std::pair;
 50677: using std::set;
 47243: using std::vector;
 47243: 
 47243: // Data provided by a DWARF specification DIE.
 47243: //
 47243: // In DWARF, the DIE for a definition may contain a DW_AT_specification
 47243: // attribute giving the offset of the corresponding declaration DIE, and
 47243: // the definition DIE may omit information given in the declaration. For
 47243: // example, it's common for a function's address range to appear only in
 47243: // its definition DIE, but its name to appear only in its declaration
 47243: // DIE.
 47243: //
 47243: // The dumper needs to be able to follow DW_AT_specification links to
 47243: // bring all this information together in a FUNC record. Conveniently,
 47243: // DIEs that are the target of such links have a DW_AT_declaration flag
 47243: // set, so we can identify them when we first see them, and record their
 47243: // contents for later reference.
 47243: //
 47243: // A Specification holds information gathered from a declaration DIE that
 47243: // we may need if we find a DW_AT_specification link pointing to it.
 47243: struct DwarfCUToModule::Specification {
118328:   // The qualified name that can be found by demangling DW_AT_MIPS_linkage_name.
118328:   string qualified_name;
118328: 
 47243:   // The name of the enclosing scope, or the empty string if there is none.
 47243:   string enclosing_name;
 47243: 
 47243:   // The name for the specification DIE itself, without any enclosing
 47243:   // name components.
 47243:   string unqualified_name;
 47243: };
 47243: 
 47243: // An abstract origin -- base definition of an inline function.
 47243: struct AbstractOrigin {
 47243:   AbstractOrigin() : name() {}
 47243:   AbstractOrigin(const string& name) : name(name) {}
 47243: 
 47243:   string name;
 47243: };
 47243: 
 47243: typedef map<uint64, AbstractOrigin> AbstractOriginByOffset;
 47243: 
 47243: // Data global to the DWARF-bearing file that is private to the
 47243: // DWARF-to-Module process.
 47243: struct DwarfCUToModule::FilePrivate {
 50677:   // A set of strings used in this CU. Before storing a string in one of
 50677:   // our data structures, insert it into this set, and then use the string
 50677:   // from the set.
 50677:   //
118328:   // In some STL implementations, strings are reference-counted internally,
118328:   // meaning that simply using strings from this set, even if passed by
118328:   // value, assigned, or held directly in structures and containers
118328:   // (map<string, ...>, for example), causes those strings to share a
118328:   // single instance of each distinct piece of text. GNU's libstdc++ uses
118328:   // reference counts, and I believe MSVC did as well, at some point.
118328:   // However, C++ '11 implementations are moving away from reference
118328:   // counting.
118328:   //
118328:   // In other implementations, string assignments copy the string's text,
118328:   // so this set will actually hold yet another copy of the string (although
118328:   // everything will still work). To improve memory consumption portably,
118328:   // we will probably need to use pointers to strings held in this set.
 50677:   set<string> common_strings;
 50677: 
 47243:   // A map from offsets of DIEs within the .debug_info section to
 47243:   // Specifications describing those DIEs. Specification references can
 47243:   // cross compilation unit boundaries.
 47243:   SpecificationByOffset specifications;
 47243: 
 47243:   AbstractOriginByOffset origins;
 47243: };
 47243: 
 47243: DwarfCUToModule::FileContext::FileContext(const string &filename_arg,
 47243:                                           Module *module_arg)
 47243:     : filename(filename_arg), module(module_arg) {
 47243:   file_private = new FilePrivate();
 47243: }
 47243: 
 47243: DwarfCUToModule::FileContext::~FileContext() {
 47243:   delete file_private;
 47243: }
 47243: 
 47243: // Information global to the particular compilation unit we're
 47243: // parsing. This is for data shared across the CU's entire DIE tree,
 47243: // and parameters from the code invoking the CU parser.
 47243: struct DwarfCUToModule::CUContext {
 47243:   CUContext(FileContext *file_context_arg, WarningReporter *reporter_arg)
 47243:       : file_context(file_context_arg),
 47243:         reporter(reporter_arg),
 47243:         language(Language::CPlusPlus) { }
 47243:   ~CUContext() {
 47243:     for (vector<Module::Function *>::iterator it = functions.begin();
 47243:          it != functions.end(); it++)
 47243:       delete *it;
 47243:   };
 47243: 
 47243:   // The DWARF-bearing file into which this CU was incorporated.
 47243:   FileContext *file_context;
 47243: 
 47243:   // For printing error messages.
 47243:   WarningReporter *reporter;
 47243: 
 47243:   // The source language of this compilation unit.
 47243:   const Language *language;
 47243: 
 47243:   // The functions defined in this compilation unit. We accumulate
 47243:   // them here during parsing. Then, in DwarfCUToModule::Finish, we
 47243:   // assign them lines and add them to file_context->module.
 47243:   //
 47243:   // Destroying this destroys all the functions this vector points to.
 47243:   vector<Module::Function *> functions;
 47243: };
 47243: 
 47243: // Information about the context of a particular DIE. This is for
 47243: // information that changes as we descend the tree towards the leaves:
 47243: // the containing classes/namespaces, etc.
 47243: struct DwarfCUToModule::DIEContext {
 47243:   // The fully-qualified name of the context. For example, for a
 47243:   // tree like:
 47243:   //
 47243:   // DW_TAG_namespace Foo
 47243:   //   DW_TAG_class Bar
 47243:   //     DW_TAG_subprogram Baz
 47243:   //
 47243:   // in a C++ compilation unit, the DIEContext's name for the
 47243:   // DW_TAG_subprogram DIE would be "Foo::Bar". The DIEContext's
 47243:   // name for the DW_TAG_namespace DIE would be "".
 47243:   string name;
 47243: };
 47243: 
 47243: // An abstract base class for all the dumper's DIE handlers.
 47243: class DwarfCUToModule::GenericDIEHandler: public dwarf2reader::DIEHandler {
 47243:  public:
 47243:   // Create a handler for the DIE at OFFSET whose compilation unit is
 47243:   // described by CU_CONTEXT, and whose immediate context is described
 47243:   // by PARENT_CONTEXT.
 47243:   GenericDIEHandler(CUContext *cu_context, DIEContext *parent_context,
 47243:                     uint64 offset)
 47243:       : cu_context_(cu_context),
 47243:         parent_context_(parent_context),
 47243:         offset_(offset),
 47243:         declaration_(false),
 47243:         specification_(NULL) { }
 47243: 
 47243:   // Derived classes' ProcessAttributeUnsigned can defer to this to
 47243:   // handle DW_AT_declaration, or simply not override it.
 47243:   void ProcessAttributeUnsigned(enum DwarfAttribute attr,
 47243:                                 enum DwarfForm form,
 47243:                                 uint64 data);
 47243: 
 47243:   // Derived classes' ProcessAttributeReference can defer to this to
 47243:   // handle DW_AT_specification, or simply not override it.
 47243:   void ProcessAttributeReference(enum DwarfAttribute attr,
 47243:                                  enum DwarfForm form,
 47243:                                  uint64 data);
 47243: 
 47243:   // Derived classes' ProcessAttributeReference can defer to this to
 47243:   // handle DW_AT_specification, or simply not override it.
 47243:   void ProcessAttributeString(enum DwarfAttribute attr,
 47243:                               enum DwarfForm form,
 47243:                               const string &data);
 47243: 
 47243:  protected:
 47243:   // Compute and return the fully-qualified name of the DIE. If this
 47243:   // DIE is a declaration DIE, to be cited by other DIEs'
 47243:   // DW_AT_specification attributes, record its enclosing name and
 47243:   // unqualified name in the specification table.
 47243:   //
 47243:   // Use this from EndAttributes member functions, not ProcessAttribute*
 47243:   // functions; only the former can be sure that all the DIE's attributes
 47243:   // have been seen.
 47243:   string ComputeQualifiedName();
 47243: 
 47243:   CUContext *cu_context_;
 47243:   DIEContext *parent_context_;
 47243:   uint64 offset_;
 47243: 
118328:   // Place the name in the global set of strings. Even though this looks
118328:   // like a copy, all the major std::string implementations use reference
118328:   // counting internally, so the effect is to have all the data structures
118328:   // share copies of strings whenever possible.
118328:   // FIXME: Should this return something like a string_ref to avoid the
118328:   // assumption about how strings are implemented?
118328:   string AddStringToPool(const string &str);
118328: 
 47243:   // If this DIE has a DW_AT_declaration attribute, this is its value.
 47243:   // It is false on DIEs with no DW_AT_declaration attribute.
 47243:   bool declaration_;
 47243: 
 47243:   // If this DIE has a DW_AT_specification attribute, this is the
 47243:   // Specification structure for the DIE the attribute refers to.
 47243:   // Otherwise, this is NULL.
 47243:   Specification *specification_;
 47243: 
 47243:   // The value of the DW_AT_name attribute, or the empty string if the
 47243:   // DIE has no such attribute.
 47243:   string name_attribute_;
118328: 
118328:   // The demangled value of the DW_AT_MIPS_linkage_name attribute, or the empty
118328:   // string if the DIE has no such attribute or its content could not be
118328:   // demangled.
118328:   string demangled_name_;
 47243: };
 47243: 
 47243: void DwarfCUToModule::GenericDIEHandler::ProcessAttributeUnsigned(
 47243:     enum DwarfAttribute attr,
 47243:     enum DwarfForm form,
 47243:     uint64 data) {
 47243:   switch (attr) {
 47243:     case dwarf2reader::DW_AT_declaration: declaration_ = (data != 0); break;
 47243:     default: break;
 47243:   }
 47243: }
 47243: 
 47243: void DwarfCUToModule::GenericDIEHandler::ProcessAttributeReference(
 47243:     enum DwarfAttribute attr,
 47243:     enum DwarfForm form,
 47243:     uint64 data) {
 47243:   switch (attr) {
 47243:     case dwarf2reader::DW_AT_specification: {
 47243:       // Find the Specification to which this attribute refers, and
 47243:       // set specification_ appropriately. We could do more processing
 47243:       // here, but it's better to leave the real work to our
 47243:       // EndAttribute member function, at which point we know we have
 47243:       // seen all the DIE's attributes.
 47243:       FileContext *file_context = cu_context_->file_context;
 47243:       SpecificationByOffset *specifications
 47243:           = &file_context->file_private->specifications;
 47243:       SpecificationByOffset::iterator spec = specifications->find(data);
 47243:       if (spec != specifications->end()) {
 47243:         specification_ = &spec->second;
 47243:       } else {
 47243:         // Technically, there's no reason a DW_AT_specification
 47243:         // couldn't be a forward reference, but supporting that would
 47243:         // be a lot of work (changing to a two-pass structure), and I
 47243:         // don't think any producers we care about ever emit such
 47243:         // things.
 47243:         cu_context_->reporter->UnknownSpecification(offset_, data);
 47243:       }
 47243:       break;
 47243:     }
 47243:     default: break;
 47243:   }
 47243: }
 47243: 
118328: string DwarfCUToModule::GenericDIEHandler::AddStringToPool(const string &str) {
118328:   pair<set<string>::iterator, bool> result =
118328:     cu_context_->file_context->file_private->common_strings.insert(str);
118328:   return *result.first;
118328: }
118328: 
 47243: void DwarfCUToModule::GenericDIEHandler::ProcessAttributeString(
 47243:     enum DwarfAttribute attr,
 47243:     enum DwarfForm form,
 47243:     const string &data) {
 47243:   switch (attr) {
118328:     case dwarf2reader::DW_AT_name:
118328:       name_attribute_ = AddStringToPool(data);
118328:       break;
118328:     case dwarf2reader::DW_AT_MIPS_linkage_name: {
118328:       char* demangled = abi::__cxa_demangle(data.c_str(), NULL, NULL, NULL);
118328:       if (demangled) {
118328:         demangled_name_ = AddStringToPool(demangled);
118328:         free(reinterpret_cast<void*>(demangled));
118328:       }
 50677:       break;
 50677:     }
 47243:     default: break;
 47243:   }
 47243: }
 47243: 
 47243: string DwarfCUToModule::GenericDIEHandler::ComputeQualifiedName() {
118328:   // Use the demangled name, if one is available. Demangled names are
118328:   // preferable to those inferred from the DWARF structure because they
118328:   // include argument types.
118328:   const string *qualified_name = NULL;
118328:   if (!demangled_name_.empty()) {
118328:     // Found it is this DIE.
118328:     qualified_name = &demangled_name_;
118328:   } else if (specification_ && !specification_->qualified_name.empty()) {
118328:     // Found it on the specification.
118328:     qualified_name = &specification_->qualified_name;
118328:   }
118328: 
118328:   const string *unqualified_name;
118328:   const string *enclosing_name;
118328:   if (!qualified_name) {
 47243:     // Find our unqualified name. If the DIE has its own DW_AT_name
 47243:     // attribute, then use that; otherwise, check our specification.
 47243:     if (name_attribute_.empty() && specification_)
 47243:       unqualified_name = &specification_->unqualified_name;
 47243:     else
 47243:       unqualified_name = &name_attribute_;
 47243: 
 47243:     // Find the name of our enclosing context. If we have a
 47243:     // specification, it's the specification's enclosing context that
 47243:     // counts; otherwise, use this DIE's context.
 47243:     if (specification_)
 47243:       enclosing_name = &specification_->enclosing_name;
 47243:     else
 47243:       enclosing_name = &parent_context_->name;
118328:   }
 47243: 
 47243:   // If this DIE was marked as a declaration, record its names in the
 47243:   // specification table.
 47243:   if (declaration_) {
 47243:     FileContext *file_context = cu_context_->file_context;
 47243:     Specification spec;
118328:     if (qualified_name)
118328:       spec.qualified_name = *qualified_name;
118328:     else {
 47243:       spec.enclosing_name = *enclosing_name;
 47243:       spec.unqualified_name = *unqualified_name;
118328:     }
 47243:     file_context->file_private->specifications[offset_] = spec;
 47243:   }
 47243: 
118328:   if (qualified_name)
118328:     return *qualified_name;
118328: 
 47243:   // Combine the enclosing name and unqualified name to produce our
 47243:   // own fully-qualified name.
 47243:   return cu_context_->language->MakeQualifiedName(*enclosing_name,
 47243:                                                   *unqualified_name);
 47243: }
 47243: 
 47243: // A handler class for DW_TAG_subprogram DIEs.
 47243: class DwarfCUToModule::FuncHandler: public GenericDIEHandler {
 47243:  public:
 47243:   FuncHandler(CUContext *cu_context, DIEContext *parent_context,
 47243:               uint64 offset)
 47243:       : GenericDIEHandler(cu_context, parent_context, offset),
 47243:         low_pc_(0), high_pc_(0), abstract_origin_(NULL), inline_(false) { }
 47243:   void ProcessAttributeUnsigned(enum DwarfAttribute attr,
 47243:                                 enum DwarfForm form,
 47243:                                 uint64 data);
 47243:   void ProcessAttributeSigned(enum DwarfAttribute attr,
 47243:                               enum DwarfForm form,
 47243:                               int64 data);
 47243:   void ProcessAttributeReference(enum DwarfAttribute attr,
 47243:                                  enum DwarfForm form,
 47243:                                  uint64 data);
 47243: 
 47243:   bool EndAttributes();
 47243:   void Finish();
 47243: 
 47243:  private:
 47243:   // The fully-qualified name, as derived from name_attribute_,
 47243:   // specification_, parent_context_.  Computed in EndAttributes.
 47243:   string name_;
 47243:   uint64 low_pc_, high_pc_; // DW_AT_low_pc, DW_AT_high_pc
 47243:   const AbstractOrigin* abstract_origin_;
 47243:   bool inline_;
 47243: };
 47243: 
 47243: void DwarfCUToModule::FuncHandler::ProcessAttributeUnsigned(
 47243:     enum DwarfAttribute attr,
 47243:     enum DwarfForm form,
 47243:     uint64 data) {
 47243:   switch (attr) {
 47243:     // If this attribute is present at all --- even if its value is
 47243:     // DW_INL_not_inlined --- then GCC may cite it as someone else's
 47243:     // DW_AT_abstract_origin attribute.
 47243:     case dwarf2reader::DW_AT_inline:      inline_  = true; break;
 47243: 
 47243:     case dwarf2reader::DW_AT_low_pc:      low_pc_  = data; break;
 47243:     case dwarf2reader::DW_AT_high_pc:     high_pc_ = data; break;
 47243:     default:
 47243:       GenericDIEHandler::ProcessAttributeUnsigned(attr, form, data);
 47243:       break;
 47243:   }
 47243: }
 47243: 
 47243: void DwarfCUToModule::FuncHandler::ProcessAttributeSigned(
 47243:     enum DwarfAttribute attr,
 47243:     enum DwarfForm form,
 47243:     int64 data) {
 47243:   switch (attr) {
 47243:     // If this attribute is present at all --- even if its value is
 47243:     // DW_INL_not_inlined --- then GCC may cite it as someone else's
 47243:     // DW_AT_abstract_origin attribute.
 47243:     case dwarf2reader::DW_AT_inline:      inline_  = true; break;
 47243: 
 47243:     default:
 47243:       break;
 47243:   }
 47243: }
 47243: 
 47243: void DwarfCUToModule::FuncHandler::ProcessAttributeReference(
 47243:     enum DwarfAttribute attr,
 47243:     enum DwarfForm form,
 47243:     uint64 data) {
 47243:   switch(attr) {
 47243:     case dwarf2reader::DW_AT_abstract_origin: {
 47243:       const AbstractOriginByOffset& origins =
 47243:           cu_context_->file_context->file_private->origins;
 47243:       AbstractOriginByOffset::const_iterator origin = origins.find(data);
 47243:       if (origin != origins.end()) {
 47243:         abstract_origin_ = &(origin->second);
 47243:       } else {
 47243:         cu_context_->reporter->UnknownAbstractOrigin(offset_, data);
 47243:       }
 47243:       break;
 47243:     }
 47243:     default:
 47243:       GenericDIEHandler::ProcessAttributeReference(attr, form, data);
 47243:       break;
 47243:   }
 47243: }
 47243: 
 47243: bool DwarfCUToModule::FuncHandler::EndAttributes() {
 47243:   // Compute our name, and record a specification, if appropriate.
 47243:   name_ = ComputeQualifiedName();
 47243:   if (name_.empty() && abstract_origin_) {
 47243:     name_ = abstract_origin_->name;
 47243:   }
 47243:   return true;
 47243: }
 47243: 
 47243: void DwarfCUToModule::FuncHandler::Finish() {
 47243:   // Did we collect the information we need?  Not all DWARF function
 47243:   // entries have low and high addresses (for example, inlined
 47243:   // functions that were never used), but all the ones we're
 47243:   // interested in cover a non-empty range of bytes.
 47243:   if (low_pc_ < high_pc_) {
 47243:     // Create a Module::Function based on the data we've gathered, and
 47243:     // add it to the functions_ list.
 47243:     Module::Function *func = new Module::Function;
114869:     // Malformed DWARF may omit the name, but all Module::Functions must
114869:     // have names.
114869:     if (!name_.empty()) {
 47243:       func->name = name_;
114869:     } else {
114869:       cu_context_->reporter->UnnamedFunction(offset_);
114869:       func->name = "<name omitted>";
114869:     }
 47243:     func->address = low_pc_;
 47243:     func->size = high_pc_ - low_pc_;
 47243:     func->parameter_size = 0;
114869:     if (func->address) {
114869:        // If the function address is zero this is a sign that this function
114869:        // description is just empty debug data and should just be discarded.
 47243:        cu_context_->functions.push_back(func);
114869:      }
 47243:   } else if (inline_) {
 47243:     AbstractOrigin origin(name_);
 47243:     cu_context_->file_context->file_private->origins[offset_] = origin;
 47243:   }
 47243: }
 47243: 
 47243: // A handler for DIEs that contain functions and contribute a
 47243: // component to their names: namespaces, classes, etc.
 47243: class DwarfCUToModule::NamedScopeHandler: public GenericDIEHandler {
 47243:  public:
 47243:   NamedScopeHandler(CUContext *cu_context, DIEContext *parent_context,
 47243:                     uint64 offset)
 47243:       : GenericDIEHandler(cu_context, parent_context, offset) { }
 47243:   bool EndAttributes();
 47243:   DIEHandler *FindChildHandler(uint64 offset, enum DwarfTag tag,
 47243:                                const AttributeList &attrs);
 47243: 
 47243:  private:
 47243:   DIEContext child_context_; // A context for our children.
 47243: };
 47243: 
 47243: bool DwarfCUToModule::NamedScopeHandler::EndAttributes() {
 47243:   child_context_.name = ComputeQualifiedName();
 47243:   return true;
 47243: }
 47243: 
 47243: dwarf2reader::DIEHandler *DwarfCUToModule::NamedScopeHandler::FindChildHandler(
 47243:     uint64 offset,
 47243:     enum DwarfTag tag,
118328:     const AttributeList &/*attrs*/) {
 47243:   switch (tag) {
 47243:     case dwarf2reader::DW_TAG_subprogram:
 47243:       return new FuncHandler(cu_context_, &child_context_, offset);
 47243:     case dwarf2reader::DW_TAG_namespace:
 47243:     case dwarf2reader::DW_TAG_class_type:
 47243:     case dwarf2reader::DW_TAG_structure_type:
 47243:     case dwarf2reader::DW_TAG_union_type:
 47243:       return new NamedScopeHandler(cu_context_, &child_context_, offset);
 47243:     default:
 47243:       return NULL;
 47243:   }
 47247: }
 47243: 
 47243: void DwarfCUToModule::WarningReporter::CUHeading() {
 47243:   if (printed_cu_header_)
 47243:     return;
 47243:   fprintf(stderr, "%s: in compilation unit '%s' (offset 0x%llx):\n",
 47243:           filename_.c_str(), cu_name_.c_str(), cu_offset_);
 47243:   printed_cu_header_ = true;
 47243: }
 47243: 
 47243: void DwarfCUToModule::WarningReporter::UnknownSpecification(uint64 offset,
 47243:                                                             uint64 target) {
 47243:   CUHeading();
 47243:   fprintf(stderr, "%s: the DIE at offset 0x%llx has a DW_AT_specification"
 47243:           " attribute referring to the die at offset 0x%llx, which either"
 47243:           " was not marked as a declaration, or comes later in the file\n",
 47243:           filename_.c_str(), offset, target);
 47243: }
 47243: 
 47243: void DwarfCUToModule::WarningReporter::UnknownAbstractOrigin(uint64 offset,
 47243:                                                              uint64 target) {
 47243:   CUHeading();
 47243:   fprintf(stderr, "%s: the DIE at offset 0x%llx has a DW_AT_abstract_origin"
 47243:           " attribute referring to the die at offset 0x%llx, which either"
 47243:           " was not marked as an inline, or comes later in the file\n",
 47243:           filename_.c_str(), offset, target);
 47243: }
 47243: 
 47243: void DwarfCUToModule::WarningReporter::MissingSection(const string &name) {
 47243:   CUHeading();
 47243:   fprintf(stderr, "%s: warning: couldn't find DWARF '%s' section\n",
 47243:           filename_.c_str(), name.c_str());
 47243: }
 47243: 
 47243: void DwarfCUToModule::WarningReporter::BadLineInfoOffset(uint64 offset) {
 47243:   CUHeading();
 47243:   fprintf(stderr, "%s: warning: line number data offset beyond end"
 47243:           " of '.debug_line' section\n",
 47243:           filename_.c_str());
 47243: }
 47243: 
 47243: void DwarfCUToModule::WarningReporter::UncoveredHeading() {
 47243:   if (printed_unpaired_header_)
 47243:     return;
 47243:   CUHeading();
 47243:   fprintf(stderr, "%s: warning: skipping unpaired lines/functions:\n",
 47243:           filename_.c_str());
 47243:   printed_unpaired_header_ = true;
 47243: }
 47243: 
 47243: void DwarfCUToModule::WarningReporter::UncoveredFunction(
 47243:     const Module::Function &function) {
 47243:   if (!uncovered_warnings_enabled_)
 47243:     return;
 47243:   UncoveredHeading();
 47243:   fprintf(stderr, "    function%s: %s\n",
 47243:           function.size == 0 ? " (zero-length)" : "",
 47243:           function.name.c_str());
 47243: }
 47243: 
 47243: void DwarfCUToModule::WarningReporter::UncoveredLine(const Module::Line &line) {
 47243:   if (!uncovered_warnings_enabled_)
 47243:     return;
 47243:   UncoveredHeading();
114869:   fprintf(stderr, "    line%s: %s:%d at 0x%" PRIx64 "\n",
 47243:           (line.size == 0 ? " (zero-length)" : ""),
 47243:           line.file->name.c_str(), line.number, line.address);
 47243: }
 47243: 
114869: void DwarfCUToModule::WarningReporter::UnnamedFunction(uint64 offset) {
114869:   CUHeading();
114869:   fprintf(stderr, "%s: warning: function at offset 0x%llx has no name\n",
114869:           filename_.c_str(), offset);
114869: }
114869: 
 47243: DwarfCUToModule::DwarfCUToModule(FileContext *file_context,
 47243:                                  LineToModuleFunctor *line_reader,
 47243:                                  WarningReporter *reporter)
 47243:     : line_reader_(line_reader), has_source_line_info_(false) { 
 47243:   cu_context_ = new CUContext(file_context, reporter);
 47243:   child_context_ = new DIEContext();
 47243: }
 47243: 
 47243: DwarfCUToModule::~DwarfCUToModule() {
 47243:   delete cu_context_;
 47243:   delete child_context_;
 47243: }
 47243: 
 47243: void DwarfCUToModule::ProcessAttributeSigned(enum DwarfAttribute attr,
 47243:                                              enum DwarfForm form,
 47243:                                              int64 data) {
 47243:   switch (attr) {
 47243:     case dwarf2reader::DW_AT_language: // source language of this CU
 47243:       SetLanguage(static_cast<DwarfLanguage>(data));
 47243:       break;
 47243:     default:
 47243:       break;
 47243:   }
 47243: }
 47243: 
 47243: void DwarfCUToModule::ProcessAttributeUnsigned(enum DwarfAttribute attr,
 47243:                                                enum DwarfForm form,
 47243:                                                uint64 data) {
 47243:   switch (attr) {
 47243:     case dwarf2reader::DW_AT_stmt_list: // Line number information.
 47243:       has_source_line_info_ = true;
 47243:       source_line_offset_ = data;
 47243:       break;
 47243:     case dwarf2reader::DW_AT_language: // source language of this CU
 47243:       SetLanguage(static_cast<DwarfLanguage>(data));
 47243:       break;
 47243:     default:
 47243:       break;
 47243:   }
 47243: }
 47243: 
 47243: void DwarfCUToModule::ProcessAttributeString(enum DwarfAttribute attr,
 47243:                                              enum DwarfForm form,
 47243:                                              const string &data) {
 47243:   if (attr == dwarf2reader::DW_AT_name)
 47243:     cu_context_->reporter->SetCUName(data);
 47243: }
 47243: 
 47243: bool DwarfCUToModule::EndAttributes() {
 47243:   return true;
 47243: }
 47243: 
 47243: dwarf2reader::DIEHandler *DwarfCUToModule::FindChildHandler(
 47243:     uint64 offset,
 47243:     enum DwarfTag tag,
118328:     const AttributeList &/*attrs*/) {
 47243:   switch (tag) {
 47243:     case dwarf2reader::DW_TAG_subprogram:
 47243:       return new FuncHandler(cu_context_, child_context_, offset);
 47243:     case dwarf2reader::DW_TAG_namespace:
 47243:     case dwarf2reader::DW_TAG_class_type:
 47243:     case dwarf2reader::DW_TAG_structure_type:
 47243:     case dwarf2reader::DW_TAG_union_type:
 47243:       return new NamedScopeHandler(cu_context_, child_context_, offset);
 47243:     default:
 47243:       return NULL;
 47243:   }
 47243: }
 47243: 
 47243: void DwarfCUToModule::SetLanguage(DwarfLanguage language) {
 47243:   switch (language) {
 47243:     case dwarf2reader::DW_LANG_Java:
 47243:       cu_context_->language = Language::Java;
 47243:       break;
 47243: 
 47243:     // DWARF has no generic language code for assembly language; this is
 47243:     // what the GNU toolchain uses.
 47243:     case dwarf2reader::DW_LANG_Mips_Assembler:
 47243:       cu_context_->language = Language::Assembler;
 47243:       break;
 47243: 
 47243:     // C++ covers so many cases that it probably has some way to cope
 47243:     // with whatever the other languages throw at us. So make it the
 47243:     // default.
 47243:     //
 47243:     // Objective C and Objective C++ seem to create entries for
 47243:     // methods whose DW_AT_name values are already fully-qualified:
 47243:     // "-[Classname method:]".  These appear at the top level.
 47243:     // 
 47243:     // DWARF data for C should never include namespaces or functions
 47243:     // nested in struct types, but if it ever does, then C++'s
 47243:     // notation is probably not a bad choice for that.
 47243:     default:
 47243:     case dwarf2reader::DW_LANG_ObjC:
 47243:     case dwarf2reader::DW_LANG_ObjC_plus_plus:
 47243:     case dwarf2reader::DW_LANG_C:
 47243:     case dwarf2reader::DW_LANG_C89:
 47243:     case dwarf2reader::DW_LANG_C99:
 47243:     case dwarf2reader::DW_LANG_C_plus_plus:
 47243:       cu_context_->language = Language::CPlusPlus;
 47243:       break;
 47243:   }
 47243: }
 47243: 
 47243: void DwarfCUToModule::ReadSourceLines(uint64 offset) {
 47243:   const dwarf2reader::SectionMap &section_map
 47243:       = cu_context_->file_context->section_map;
 47243:   dwarf2reader::SectionMap::const_iterator map_entry
 47243:       = section_map.find(".debug_line");
 47243:   // Mac OS X puts DWARF data in sections whose names begin with "__"
 47243:   // instead of ".".
 47243:   if (map_entry == section_map.end())
 47243:     map_entry = section_map.find("__debug_line");
 47243:   if (map_entry == section_map.end()) {
 47243:     cu_context_->reporter->MissingSection(".debug_line");
 47243:     return;
 47243:   }
 47243:   const char *section_start = map_entry->second.first;
 47243:   uint64 section_length = map_entry->second.second;
 47243:   if (offset >= section_length) {
 47243:     cu_context_->reporter->BadLineInfoOffset(offset);
 47243:     return;
 47243:   }
 47243:   (*line_reader_)(section_start + offset, section_length - offset,
 47243:                   cu_context_->file_context->module, &lines_);
 47243: }
 47243: 
 47243: namespace {
 47243: // Return true if ADDRESS falls within the range of ITEM.
 47243: template <class T>
 47243: inline bool within(const T &item, Module::Address address) {
 47243:   // Because Module::Address is unsigned, and unsigned arithmetic
 47243:   // wraps around, this will be false if ADDRESS falls before the
 47243:   // start of ITEM, or if it falls after ITEM's end.
 47243:   return address - item.address < item.size;
 47243: }
 47243: }
 47243: 
 47243: void DwarfCUToModule::AssignLinesToFunctions() {
 47243:   vector<Module::Function *> *functions = &cu_context_->functions;
 47243:   WarningReporter *reporter = cu_context_->reporter;
 47243: 
 47243:   // This would be simpler if we assumed that source line entries
 47243:   // don't cross function boundaries.  However, there's no real reason
 47243:   // to assume that (say) a series of function definitions on the same
 47243:   // line wouldn't get coalesced into one line number entry.  The
 47243:   // DWARF spec certainly makes no such promises.
 47243:   //
 47243:   // So treat the functions and lines as peers, and take the trouble
 47243:   // to compute their ranges' intersections precisely.  In any case,
 47243:   // the hair here is a constant factor for performance; the
 47243:   // complexity from here on out is linear.
 47243: 
 47243:   // Put both our functions and lines in order by address.
 47243:   sort(functions->begin(), functions->end(),
 47243:        Module::Function::CompareByAddress);
 47243:   sort(lines_.begin(), lines_.end(), Module::Line::CompareByAddress);
 47243: 
 47243:   // The last line that we used any piece of.  We use this only for
 47243:   // generating warnings.
 47243:   const Module::Line *last_line_used = NULL;
 47243: 
 47243:   // The last function and line we warned about --- so we can avoid
 47243:   // doing so more than once.
 47243:   const Module::Function *last_function_cited = NULL;
 47243:   const Module::Line *last_line_cited = NULL;
 47243: 
 47243:   // Make a single pass through both vectors from lower to higher
 47243:   // addresses, populating each Function's lines vector with lines
 47243:   // from our lines_ vector that fall within the function's address
 47243:   // range.
 47243:   vector<Module::Function *>::iterator func_it = functions->begin();
 47243:   vector<Module::Line>::const_iterator line_it = lines_.begin();
 47243: 
 47243:   Module::Address current;
 47243: 
 47243:   // Pointers to the referents of func_it and line_it, or NULL if the
 47243:   // iterator is at the end of the sequence.
 47243:   Module::Function *func;
 47243:   const Module::Line *line;
 47243: 
 47243:   // Start current at the beginning of the first line or function,
 47243:   // whichever is earlier.
 47243:   if (func_it != functions->end() && line_it != lines_.end()) {
 47243:     func = *func_it;
 47243:     line = &*line_it;
 47243:     current = std::min(func->address, line->address);
 47243:   } else if (line_it != lines_.end()) {
 47243:     func = NULL;
 47243:     line = &*line_it;
 47243:     current = line->address;
 47243:   } else if (func_it != functions->end()) {
 47243:     func = *func_it;
 47243:     line = NULL;
 47243:     current = (*func_it)->address;
 47243:   } else {
 47243:     return;
 47243:   }
 47243: 
 47243:   while (func || line) {
 47243:     // This loop has two invariants that hold at the top.
 47243:     //
 47243:     // First, at least one of the iterators is not at the end of its
 47243:     // sequence, and those that are not refer to the earliest
 47243:     // function or line that contains or starts after CURRENT.
 47243:     //
 47243:     // Note that every byte is in one of four states: it is covered
 47243:     // or not covered by a function, and, independently, it is
 47243:     // covered or not covered by a line.
 47243:     //
 47243:     // The second invariant is that CURRENT refers to a byte whose
 47243:     // state is different from its predecessor, or it refers to the
 47243:     // first byte in the address space. In other words, CURRENT is
 47243:     // always the address of a transition.
 47243:     //
 47243:     // Note that, although each iteration advances CURRENT from one
 47243:     // transition address to the next in each iteration, it might
 47243:     // not advance the iterators. Suppose we have a function that
 47243:     // starts with a line, has a gap, and then a second line, and
 47243:     // suppose that we enter an iteration with CURRENT at the end of
 47243:     // the first line. The next transition address is the start of
 47243:     // the second line, after the gap, so the iteration should
 47243:     // advance CURRENT to that point. At the head of that iteration,
 47243:     // the invariants require that the line iterator be pointing at
 47243:     // the second line. But this is also true at the head of the
 47243:     // next. And clearly, the iteration must not change the function
 47243:     // iterator. So neither iterator moves.
 47243: 
 47243:     // Assert the first invariant (see above).
 47243:     assert(!func || current < func->address || within(*func, current));
 47243:     assert(!line || current < line->address || within(*line, current));
 47243: 
 47243:     // The next transition after CURRENT.
 47243:     Module::Address next_transition;
 47243: 
 47243:     // Figure out which state we're in, add lines or warn, and compute
 47243:     // the next transition address.
 47243:     if (func && current >= func->address) {
 47243:       if (line && current >= line->address) {
 47243:         // Covered by both a line and a function.
 47243:         Module::Address func_left = func->size - (current - func->address);
 47243:         Module::Address line_left = line->size - (current - line->address);
 47243:         // This may overflow, but things work out.
 47243:         next_transition = current + std::min(func_left, line_left);
 47243:         Module::Line l = *line;
 47243:         l.address = current;
 47243:         l.size = next_transition - current;
 47243:         func->lines.push_back(l);
 47243:         last_line_used = line;
 47243:       } else {
 47243:         // Covered by a function, but no line.
 47243:         if (func != last_function_cited) {
 47243:           reporter->UncoveredFunction(*func);
 47243:           last_function_cited = func;
 47243:         }
 47243:         if (line && within(*func, line->address))
 47243:           next_transition = line->address;
 47243:         else
 47243:           // If this overflows, we'll catch it below.
 47243:           next_transition = func->address + func->size;
 47243:       }
 47243:     } else {
 47243:       if (line && current >= line->address) {
 47243:         // Covered by a line, but no function.
 47243:         //
 47243:         // If GCC emits padding after one function to align the start
 47243:         // of the next, then it will attribute the padding
 47243:         // instructions to the last source line of function (to reduce
 47243:         // the size of the line number info), but omit it from the
 47243:         // DW_AT_{low,high}_pc range given in .debug_info (since it
 47243:         // costs nothing to be precise there). If we did use at least
 47243:         // some of the line we're about to skip, and it ends at the
 47243:         // start of the next function, then assume this is what
 47243:         // happened, and don't warn.
 47243:         if (line != last_line_cited
 47243:             && !(func
 47243:                  && line == last_line_used
 47243:                  && func->address - line->address == line->size)) {
 47243:           reporter->UncoveredLine(*line);
 47243:           last_line_cited = line;
 47243:         }
 47243:         if (func && within(*line, func->address))
 47243:           next_transition = func->address;
 47243:         else
 47243:           // If this overflows, we'll catch it below.
 47243:           next_transition = line->address + line->size;
 47243:       } else {
 47243:         // Covered by neither a function nor a line. By the invariant,
 47243:         // both func and line begin after CURRENT. The next transition
 47243:         // is the start of the next function or next line, whichever
 47243:         // is earliest.
 47243:         assert (func || line);
 47243:         if (func && line)
 47243:           next_transition = std::min(func->address, line->address);
 47243:         else if (func)
 47243:           next_transition = func->address;
 47243:         else
 47243:           next_transition = line->address;
 47243:       }
 47243:     }
 47243: 
 47243:     // If a function or line abuts the end of the address space, then
 47243:     // next_transition may end up being zero, in which case we've completed
 47243:     // our pass. Handle that here, instead of trying to deal with it in
 47243:     // each place we compute next_transition.
 47243:     if (!next_transition)
 47243:       break;
 47243: 
 47243:     // Advance iterators as needed. If lines overlap or functions overlap,
 47243:     // then we could go around more than once. We don't worry too much
 47243:     // about what result we produce in that case, just as long as we don't
 47243:     // hang or crash.
 47243:     while (func_it != functions->end()
 72624:            && next_transition >= (*func_it)->address
 47243:            && !within(**func_it, next_transition))
 47243:       func_it++;
 47243:     func = (func_it != functions->end()) ? *func_it : NULL;
 47243:     while (line_it != lines_.end()
 72624:            && next_transition >= line_it->address
 47243:            && !within(*line_it, next_transition))
 47243:       line_it++;
 47243:     line = (line_it != lines_.end()) ? &*line_it : NULL;
 47243: 
 47243:     // We must make progress.
 47243:     assert(next_transition > current);
 47243:     current = next_transition;
 47243:   }
 47243: }
 47243: 
 47243: void DwarfCUToModule::Finish() {
 47243:   // Assembly language files have no function data, and that gives us
 47243:   // no place to store our line numbers (even though the GNU toolchain
 47243:   // will happily produce source line info for assembly language
 47243:   // files).  To avoid spurious warnings about lines we can't assign
 47243:   // to functions, skip CUs in languages that lack functions.
 47243:   if (!cu_context_->language->HasFunctions())
 47243:     return;
 47243: 
 47243:   // Read source line info, if we have any.
 47243:   if (has_source_line_info_)
 47243:     ReadSourceLines(source_line_offset_);
 47243: 
 47243:   vector<Module::Function *> *functions = &cu_context_->functions;
 47243: 
 47243:   // Dole out lines to the appropriate functions.
 47243:   AssignLinesToFunctions();
 47243: 
 47243:   // Add our functions, which now have source lines assigned to them,
 47243:   // to module_.
 47243:   cu_context_->file_context->module->AddFunctions(functions->begin(),
 47243:                                                   functions->end());
 47243: 
 47243:   // Ownership of the function objects has shifted from cu_context to
 47243:   // the Module.
 47243:   functions->clear();
 47243: }
 47243: 
 47243: bool DwarfCUToModule::StartCompilationUnit(uint64 offset,
 47243:                                            uint8 address_size,
 47243:                                            uint8 offset_size,
 47243:                                            uint64 cu_length,
 47243:                                            uint8 dwarf_version) {
 47243:   return dwarf_version >= 2;
 47243: }
 47243: 
 47243: bool DwarfCUToModule::StartRootDIE(uint64 offset, enum DwarfTag tag,
118328:                                    const AttributeList& /*attrs*/) {
 47243:   // We don't deal with partial compilation units (the only other tag
 47243:   // likely to be used for root DIE).
 47243:   return tag == dwarf2reader::DW_TAG_compile_unit;
 47243: }
 47243: 
 47243: } // namespace google_breakpad
