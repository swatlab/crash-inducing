     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 99905: #include "mozilla/StandardInteger.h"
 80467: #include "mozilla/Util.h"
 80467: 
     1: #include "nsGkAtoms.h"
 98711: #include "nsLayoutUtils.h"
 58554: #include "DOMSVGNumber.h"
 47840: #include "DOMSVGLength.h"
     1: #include "nsSVGAngle.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsIPresShell.h"
  3439: #include "nsContentUtils.h"
     1: #include "nsIDocument.h"
     1: #include "nsPresContext.h"
 78865: #include "DOMSVGMatrix.h"
 58893: #include "DOMSVGPoint.h"
     1: #include "nsIDOMEventTarget.h"
     1: #include "nsIFrame.h"
     1: #include "nsISVGSVGFrame.h" //XXX
     1: #include "nsSVGRect.h"
     1: #include "nsDOMError.h"
     1: #include "nsISVGChildFrame.h"
     1: #include "nsGUIEvent.h"
     1: #include "nsSVGUtils.h"
     1: #include "nsSVGSVGElement.h"
 59474: #include "nsContentErrors.h" // For NS_PROPTABLE_PROP_OVERWRITTEN
 82009: #include "nsStyleUtil.h"
     1: 
 23697: #include "nsEventDispatcher.h"
 23697: #include "nsSMILTimeContainer.h"
 23697: #include "nsSMILAnimationController.h"
 23697: #include "nsSMILTypes.h"
 23697: #include "nsIContentIterator.h"
 23697: 
 50634: using namespace mozilla;
 56805: using namespace mozilla::dom;
 50634: 
 27870: NS_SVG_VAL_IMPL_CYCLE_COLLECTION(nsSVGTranslatePoint::DOMVal, mElement)
 27870: 
 27870: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsSVGTranslatePoint::DOMVal)
 27870: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsSVGTranslatePoint::DOMVal)
 27870: 
 27870: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsSVGTranslatePoint::DOMVal)
 27870:   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGPoint)
 27870:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(SVGPoint)
 27870: NS_INTERFACE_MAP_END
 27870: 
 27870: nsresult
 27870: nsSVGTranslatePoint::ToDOMVal(nsSVGSVGElement *aElement,
 27870:                               nsIDOMSVGPoint **aResult)
 27870: {
 27870:   *aResult = new DOMVal(this, aElement);
 27870:   if (!*aResult)
 27870:     return NS_ERROR_OUT_OF_MEMORY;
 27870:   
 27870:   NS_ADDREF(*aResult);
 27870:   return NS_OK;
 27870: }
 27870: 
 27870: NS_IMETHODIMP
 27870: nsSVGTranslatePoint::DOMVal::SetX(float aValue)
 27870: {
 27870:   NS_ENSURE_FINITE(aValue, NS_ERROR_ILLEGAL_VALUE);
 27870:   return mElement->SetCurrentTranslate(aValue, mVal->GetY());
 27870: }
 27870: 
 27870: NS_IMETHODIMP
 27870: nsSVGTranslatePoint::DOMVal::SetY(float aValue)
 27870: {
 27870:   NS_ENSURE_FINITE(aValue, NS_ERROR_ILLEGAL_VALUE);
 27870:   return mElement->SetCurrentTranslate(mVal->GetX(), aValue);
 27870: }
 27870: 
 27870: /* nsIDOMSVGPoint matrixTransform (in nsIDOMSVGMatrix matrix); */
 27870: NS_IMETHODIMP
 27870: nsSVGTranslatePoint::DOMVal::MatrixTransform(nsIDOMSVGMatrix *matrix,
 27870:                                              nsIDOMSVGPoint **_retval)
 27870: {
 27870:   if (!matrix)
 27870:     return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
 27870: 
 27870:   float a, b, c, d, e, f;
 27870:   matrix->GetA(&a);
 27870:   matrix->GetB(&b);
 27870:   matrix->GetC(&c);
 27870:   matrix->GetD(&d);
 27870:   matrix->GetE(&e);
 27870:   matrix->GetF(&f);
 27870: 
 27870:   float x = mVal->GetX();
 27870:   float y = mVal->GetY();
 27870: 
 58893:   NS_ADDREF(*_retval = new DOMSVGPoint(a*x + c*y + e, b*x + d*y + f));
 58893:   return NS_OK;
 27870: }
 23697: 
     1: nsSVGElement::LengthInfo nsSVGSVGElement::sLengthInfo[4] =
     1: {
     1:   { &nsGkAtoms::x, 0, nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER, nsSVGUtils::X },
     1:   { &nsGkAtoms::y, 0, nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER, nsSVGUtils::Y },
     1:   { &nsGkAtoms::width, 100, nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE, nsSVGUtils::X },
     1:   { &nsGkAtoms::height, 100, nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE, nsSVGUtils::Y },
     1: };
     1: 
  5347: nsSVGEnumMapping nsSVGSVGElement::sZoomAndPanMap[] = {
  5347:   {&nsGkAtoms::disable, nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_DISABLE},
  5347:   {&nsGkAtoms::magnify, nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_MAGNIFY},
  5347:   {nsnull, 0}
  5347: };
  5347: 
  5347: nsSVGElement::EnumInfo nsSVGSVGElement::sEnumInfo[1] =
  5347: {
  5347:   { &nsGkAtoms::zoomAndPan,
  5347:     sZoomAndPanMap,
  5347:     nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_MAGNIFY
  5347:   }
  5347: };
  5347: 
 37218: NS_IMPL_NS_NEW_SVG_ELEMENT_CHECK_PARSER(SVG)
     1: 
     1: //----------------------------------------------------------------------
     1: // nsISupports methods
     1: 
 37113: NS_IMPL_CYCLE_COLLECTION_CLASS(nsSVGSVGElement)
 37113: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsSVGSVGElement,
 37113:                                                 nsSVGSVGElementBase)
 37113:   if (tmp->mTimedDocumentRoot) {
 37113:     tmp->mTimedDocumentRoot->Unlink();
 37113:   }
 37113: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 37113: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsSVGSVGElement,
 37113:                                                   nsSVGSVGElementBase)
 37113:   if (tmp->mTimedDocumentRoot) {
 37113:     tmp->mTimedDocumentRoot->Traverse(&cb);
 37113:   }
 37113: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 37113: 
     1: NS_IMPL_ADDREF_INHERITED(nsSVGSVGElement,nsSVGSVGElementBase)
     1: NS_IMPL_RELEASE_INHERITED(nsSVGSVGElement,nsSVGSVGElementBase)
     1: 
 48124: DOMCI_NODE_DATA(SVGSVGElement, nsSVGSVGElement)
 40490: 
 37113: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsSVGSVGElement)
 86429:   NS_NODE_INTERFACE_TABLE8(nsSVGSVGElement, nsIDOMNode, nsIDOMElement,
 86429:                            nsIDOMSVGElement, nsIDOMSVGTests,
 86429:                            nsIDOMSVGSVGElement,
 21218:                            nsIDOMSVGFitToViewBox, nsIDOMSVGLocatable,
 21218:                            nsIDOMSVGZoomAndPan)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(SVGSVGElement)
     1: NS_INTERFACE_MAP_END_INHERITING(nsSVGSVGElementBase)
     1: 
     1: //----------------------------------------------------------------------
     1: // Implementation
     1: 
 94340: nsSVGSVGElement::nsSVGSVGElement(already_AddRefed<nsINodeInfo> aNodeInfo,
 56805:                                  FromParser aFromParser)
     1:   : nsSVGSVGElementBase(aNodeInfo),
     1:     mCoordCtx(nsnull),
  3298:     mViewportWidth(0),
  3298:     mViewportHeight(0),
 27870:     mCurrentTranslate(0.0f, 0.0f),
 27870:     mCurrentScale(1.0f),
 27870:     mPreviousTranslate(0.0f, 0.0f),
 27870:     mPreviousScale(1.0f),
 81490:     mStartAnimationOnBindToTree(!aFromParser),
 81490:     mImageNeedsTransformInvalidation(false),
 98711:     mIsPaintingSVGImageElement(false),
 99905:     mHasChildrenOnlyTransform(false),
 99905:     mUseCurrentView(false)
     1: {
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // nsIDOMNode methods
     1: 
 23697: // From NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGSVGElement)
 23697: nsresult
 94340: nsSVGSVGElement::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
 23697: {
 23697:   *aResult = nsnull;
 94340:   nsCOMPtr<nsINodeInfo> ni = aNodeInfo;
 56805:   nsSVGSVGElement *it = new nsSVGSVGElement(ni.forget(), NOT_FROM_PARSER);
 23697: 
 23697:   nsCOMPtr<nsINode> kungFuDeathGrip = it;
 23697:   nsresult rv = it->Init();
103999:   rv |= const_cast<nsSVGSVGElement*>(this)->CopyInnerTo(it);
 23697:   if (NS_SUCCEEDED(rv)) {
 23697:     kungFuDeathGrip.swap(*aResult);
 23697:   }
 23697: 
 23697:   return rv;
 23697: }
     1: 
     1: 
     1: //----------------------------------------------------------------------
     1: // nsIDOMSVGSVGElement methods:
     1: 
     1: /* readonly attribute nsIDOMSVGAnimatedLength x; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetX(nsIDOMSVGAnimatedLength * *aX)
     1: {
     1:   return mLengthAttributes[X].ToDOMAnimatedLength(aX, this);
     1: }
     1: 
     1: /* readonly attribute nsIDOMSVGAnimatedLength y; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetY(nsIDOMSVGAnimatedLength * *aY)
     1: {
     1:   return mLengthAttributes[Y].ToDOMAnimatedLength(aY, this);
     1: }
     1: 
     1: /* readonly attribute nsIDOMSVGAnimatedLength width; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetWidth(nsIDOMSVGAnimatedLength * *aWidth)
     1: {
     1:   return mLengthAttributes[WIDTH].ToDOMAnimatedLength(aWidth, this);
     1: }
     1: 
     1: /* readonly attribute nsIDOMSVGAnimatedLength height; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetHeight(nsIDOMSVGAnimatedLength * *aHeight)
     1: {
     1:   return mLengthAttributes[HEIGHT].ToDOMAnimatedLength(aHeight, this);
     1: }
     1: 
     1: /* attribute DOMString contentScriptType; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetContentScriptType(nsAString & aContentScriptType)
     1: {
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetContentScriptType");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::SetContentScriptType(const nsAString & aContentScriptType)
     1: {
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::SetContentScriptType");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* attribute DOMString contentStyleType; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetContentStyleType(nsAString & aContentStyleType)
     1: {
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetContentStyleType");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::SetContentStyleType(const nsAString & aContentStyleType)
     1: {
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::SetContentStyleType");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* readonly attribute nsIDOMSVGRect viewport; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetViewport(nsIDOMSVGRect * *aViewport)
     1: {
     1:   // XXX
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* readonly attribute float pixelUnitToMillimeterX; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetPixelUnitToMillimeterX(float *aPixelUnitToMillimeterX)
     1: {
 50791:   *aPixelUnitToMillimeterX = MM_PER_INCH_FLOAT / 96;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute float pixelUnitToMillimeterY; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetPixelUnitToMillimeterY(float *aPixelUnitToMillimeterY)
     1: {
     1:   return GetPixelUnitToMillimeterX(aPixelUnitToMillimeterY);
     1: }
     1: 
     1: /* readonly attribute float screenPixelToMillimeterX; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetScreenPixelToMillimeterX(float *aScreenPixelToMillimeterX)
     1: {
 50791:   *aScreenPixelToMillimeterX = MM_PER_INCH_FLOAT / 96;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute float screenPixelToMillimeterY; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetScreenPixelToMillimeterY(float *aScreenPixelToMillimeterY)
     1: {
     1:   return GetScreenPixelToMillimeterX(aScreenPixelToMillimeterY);
     1: }
     1: 
     1: /* attribute boolean useCurrentView; */
     1: NS_IMETHODIMP
 79445: nsSVGSVGElement::GetUseCurrentView(bool *aUseCurrentView)
     1: {
 99905:   *aUseCurrentView = mUseCurrentView;
 99905:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute nsIDOMSVGViewSpec currentView; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetCurrentView(nsIDOMSVGViewSpec * *aCurrentView)
     1: {
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetCurrentView");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* attribute float currentScale; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetCurrentScale(float *aCurrentScale)
     1: {
 27870:   *aCurrentScale = mCurrentScale;
 27870:   return NS_OK;
     1: }
     1: 
     1: #define CURRENT_SCALE_MAX 16.0f
     1: #define CURRENT_SCALE_MIN 0.0625f
     1: 
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::SetCurrentScale(float aCurrentScale)
     1: {
 27870:   return SetCurrentScaleTranslate(aCurrentScale,
 27870:     mCurrentTranslate.GetX(), mCurrentTranslate.GetY());
     1: }
     1: 
     1: /* readonly attribute nsIDOMSVGPoint currentTranslate; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetCurrentTranslate(nsIDOMSVGPoint * *aCurrentTranslate)
     1: {
 27870:   return mCurrentTranslate.ToDOMVal(this, aCurrentTranslate);
     1: }
     1: 
     1: /* unsigned long suspendRedraw (in unsigned long max_wait_milliseconds); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::SuspendRedraw(PRUint32 max_wait_milliseconds, PRUint32 *_retval)
     1: {
 93573:   // suspendRedraw is a no-op in Mozilla, so it doesn't matter what
 93573:   // we set the ID out-param to:
     1:   *_retval = 1;
     1:   return NS_OK;
     1: }
     1: 
     1: /* void unsuspendRedraw (in unsigned long suspend_handle_id); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::UnsuspendRedraw(PRUint32 suspend_handle_id)
     1: {
 93573:   // no-op
     1:   return NS_OK;
     1: }
     1: 
     1: /* void unsuspendRedrawAll (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::UnsuspendRedrawAll()
     1: {
 93573:   // no-op
     1:   return NS_OK;
     1: }
     1: 
     1: /* void forceRedraw (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::ForceRedraw()
     1: {
     1:   nsIDocument* doc = GetCurrentDoc();
     1:   if (!doc) return NS_ERROR_FAILURE;
     1: 
     1:   doc->FlushPendingNotifications(Flush_Display);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: /* void pauseAnimations (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::PauseAnimations()
     1: {
 25961:   if (NS_SMILEnabled()) {
 23697:     if (mTimedDocumentRoot) {
 23697:       mTimedDocumentRoot->Pause(nsSMILTimeContainer::PAUSE_SCRIPT);
 23697:     }
 23697:     // else we're not the outermost <svg> or not bound to a tree, so silently fail
 23697:     return NS_OK;
 25961:   }
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::PauseAnimations");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* void unpauseAnimations (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::UnpauseAnimations()
     1: {
 25961:   if (NS_SMILEnabled()) {
 23697:     if (mTimedDocumentRoot) {
 23697:       mTimedDocumentRoot->Resume(nsSMILTimeContainer::PAUSE_SCRIPT);
 23697:     }
 23697:     // else we're not the outermost <svg> or not bound to a tree, so silently fail
 23697:     return NS_OK;
 25961:   }
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::UnpauseAnimations");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* boolean animationsPaused (); */
     1: NS_IMETHODIMP
 79445: nsSVGSVGElement::AnimationsPaused(bool *_retval)
     1: {
 25961:   if (NS_SMILEnabled()) {
 23697:     nsSMILTimeContainer* root = GetTimedDocumentRoot();
 23697:     *_retval = root && root->IsPausedByType(nsSMILTimeContainer::PAUSE_SCRIPT);
 23697:     return NS_OK;
 25961:   }
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::AnimationsPaused");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* float getCurrentTime (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetCurrentTime(float *_retval)
     1: {
 25961:   if (NS_SMILEnabled()) {
 23697:     nsSMILTimeContainer* root = GetTimedDocumentRoot();
 23697:     if (root) {
 23697:       double fCurrentTimeMs = double(root->GetCurrentTime());
 23697:       *_retval = (float)(fCurrentTimeMs / PR_MSEC_PER_SEC);
 23697:     } else {
 23697:       *_retval = 0.f;
 23697:     }
 23697:     return NS_OK;
 25961:   }
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetCurrentTime");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* void setCurrentTime (in float seconds); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::SetCurrentTime(float seconds)
     1: {
 14038:   NS_ENSURE_FINITE(seconds, NS_ERROR_ILLEGAL_VALUE);
 25961:   if (NS_SMILEnabled()) {
 23697:     if (mTimedDocumentRoot) {
 59632:       // Make sure the timegraph is up-to-date
 59632:       FlushAnimations();
 23697:       double fMilliseconds = double(seconds) * PR_MSEC_PER_SEC;
 23697:       // Round to nearest whole number before converting, to avoid precision
 23697:       // errors
 23697:       nsSMILTime lMilliseconds = PRInt64(NS_round(fMilliseconds));
 23697:       mTimedDocumentRoot->SetCurrentTime(lMilliseconds);
 59632:       AnimationNeedsResample();
 59632:       // Trigger synchronous sample now, to:
 59632:       //  - Make sure we get an up-to-date paint after this method
 59632:       //  - re-enable event firing (it got disabled during seeking, and it
 59632:       //  doesn't get re-enabled until the first sample after the seek -- so
 59632:       //  let's make that happen now.)
 59632:       FlushAnimations();
 23697:     } // else we're not the outermost <svg> or not bound to a tree, so silently
 23697:       // fail
 23697:     return NS_OK;
 25961:   }
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::SetCurrentTime");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* nsIDOMNodeList getIntersectionList (in nsIDOMSVGRect rect, in nsIDOMSVGElement referenceElement); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetIntersectionList(nsIDOMSVGRect *rect,
     1:                                      nsIDOMSVGElement *referenceElement,
     1:                                      nsIDOMNodeList **_retval)
     1: {
     1:   // null check when implementing - this method can be used by scripts!
     1:   // if (!rect || !referenceElement)
     1:   //   return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
     1: 
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetIntersectionList");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* nsIDOMNodeList getEnclosureList (in nsIDOMSVGRect rect, in nsIDOMSVGElement referenceElement); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetEnclosureList(nsIDOMSVGRect *rect,
     1:                                   nsIDOMSVGElement *referenceElement,
     1:                                   nsIDOMNodeList **_retval)
     1: {
     1:   // null check when implementing - this method can be used by scripts!
     1:   // if (!rect || !referenceElement)
     1:   //   return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
     1: 
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetEnclosureList");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* boolean checkIntersection (in nsIDOMSVGElement element, in nsIDOMSVGRect rect); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::CheckIntersection(nsIDOMSVGElement *element,
     1:                                    nsIDOMSVGRect *rect,
 79445:                                    bool *_retval)
     1: {
     1:   // null check when implementing - this method can be used by scripts!
     1:   // if (!element || !rect)
     1:   //   return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
     1: 
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::CheckIntersection");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* boolean checkEnclosure (in nsIDOMSVGElement element, in nsIDOMSVGRect rect); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::CheckEnclosure(nsIDOMSVGElement *element,
     1:                                 nsIDOMSVGRect *rect,
 79445:                                 bool *_retval)
     1: {
     1:   // null check when implementing - this method can be used by scripts!
     1:   // if (!element || !rect)
     1:   //   return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
     1: 
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::CheckEnclosure");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* void deSelectAll (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::DeSelectAll()
     1: {
     1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::DeSelectAll");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* nsIDOMSVGNumber createSVGNumber (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::CreateSVGNumber(nsIDOMSVGNumber **_retval)
     1: {
 58554:   NS_ADDREF(*_retval = new DOMSVGNumber());
 58554:   return NS_OK;
     1: }
     1: 
     1: /* nsIDOMSVGLength createSVGLength (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::CreateSVGLength(nsIDOMSVGLength **_retval)
     1: {
 64140:   NS_ADDREF(*_retval = new DOMSVGLength());
 47840:   return NS_OK;
     1: }
     1: 
     1: /* nsIDOMSVGAngle createSVGAngle (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::CreateSVGAngle(nsIDOMSVGAngle **_retval)
     1: {
  6788:   return NS_NewDOMSVGAngle(_retval);
     1: }
     1: 
     1: /* nsIDOMSVGPoint createSVGPoint (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::CreateSVGPoint(nsIDOMSVGPoint **_retval)
     1: {
 58893:   NS_ADDREF(*_retval = new DOMSVGPoint(0, 0));
 58893:   return NS_OK;
     1: }
     1: 
     1: /* nsIDOMSVGMatrix createSVGMatrix (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::CreateSVGMatrix(nsIDOMSVGMatrix **_retval)
     1: {
 78865:   NS_ADDREF(*_retval = new DOMSVGMatrix());
 78865:   return NS_OK;
     1: }
     1: 
     1: /* nsIDOMSVGRect createSVGRect (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::CreateSVGRect(nsIDOMSVGRect **_retval)
     1: {
     1:   return NS_NewSVGRect(_retval);
     1: }
     1: 
     1: /* nsIDOMSVGTransform createSVGTransform (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::CreateSVGTransform(nsIDOMSVGTransform **_retval)
     1: {
 78865:   NS_ADDREF(*_retval = new DOMSVGTransform());
 78865:   return NS_OK;
     1: }
     1: 
     1: /* nsIDOMSVGTransform createSVGTransformFromMatrix (in nsIDOMSVGMatrix matrix); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::CreateSVGTransformFromMatrix(nsIDOMSVGMatrix *matrix, 
     1:                                               nsIDOMSVGTransform **_retval)
     1: {
 78865:   nsCOMPtr<DOMSVGMatrix> domItem = do_QueryInterface(matrix);
 78865:   if (!domItem) {
 78865:     return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
 78865:   }
     1: 
 78865:   NS_ADDREF(*_retval = new DOMSVGTransform(domItem->Matrix()));
     1:   return NS_OK;
     1: }
     1: 
     1: /* nsIDOMElement getElementById (in DOMString elementId); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetElementById(const nsAString & elementId, nsIDOMElement **_retval)
     1: {
 82009:   NS_ENSURE_ARG_POINTER(_retval);
 82009:   *_retval = nsnull;
 82009: 
 82009:   nsresult rv = NS_OK;
 82009:   nsAutoString selector(NS_LITERAL_STRING("#"));
 82009:   nsStyleUtil::AppendEscapedCSSIdent(PromiseFlatString(elementId), selector);
 82009:   nsIContent* element = nsGenericElement::doQuerySelector(this, selector, &rv);
 82009:   if (NS_SUCCEEDED(rv) && element) {
 82009:     return CallQueryInterface(element, _retval);
 82009:   }
 82009:   return rv;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // nsIDOMSVGFitToViewBox methods
     1: 
     1: /* readonly attribute nsIDOMSVGAnimatedRect viewBox; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetViewBox(nsIDOMSVGAnimatedRect * *aViewBox)
     1: {
 24554:   return mViewBox.ToDOMAnimatedRect(aViewBox, this);
     1: }
     1: 
     1: /* readonly attribute nsIDOMSVGAnimatedPreserveAspectRatio preserveAspectRatio; */
     1: NS_IMETHODIMP
 23313: nsSVGSVGElement::GetPreserveAspectRatio(nsIDOMSVGAnimatedPreserveAspectRatio
 23313:                                         **aPreserveAspectRatio)
     1: {
 23313:   return mPreserveAspectRatio.ToDOMAnimatedPreserveAspectRatio(aPreserveAspectRatio, this);
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // nsIDOMSVGLocatable methods
     1: 
     1: /* readonly attribute nsIDOMSVGElement nearestViewportElement; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetNearestViewportElement(nsIDOMSVGElement * *aNearestViewportElement)
     1: {
 30596:   *aNearestViewportElement = nsSVGUtils::GetNearestViewportElement(this).get();
 30596:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute nsIDOMSVGElement farthestViewportElement; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetFarthestViewportElement(nsIDOMSVGElement * *aFarthestViewportElement)
     1: {
 64140:   NS_IF_ADDREF(*aFarthestViewportElement = nsSVGUtils::GetOuterSVGElement(this));
 30596:   return NS_OK;
     1: }
     1: 
     1: /* nsIDOMSVGRect getBBox (); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetBBox(nsIDOMSVGRect **_retval)
     1: {
     1:   *_retval = nsnull;
     1: 
     1:   nsIFrame* frame = GetPrimaryFrame(Flush_Layout);
     1: 
 10138:   if (!frame || (frame->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD))
 10138:     return NS_ERROR_FAILURE;
 10138: 
 23554:   nsISVGChildFrame* svgframe = do_QueryFrame(frame);
     1:   if (svgframe) {
 29067:     return NS_NewSVGRect(_retval, nsSVGUtils::GetBBox(frame));
     1:   }
 29067:   return NS_ERROR_NOT_IMPLEMENTED; // XXX: outer svg
     1: }
     1: 
 29610: /* nsIDOMSVGMatrix getCTM (); */
 29610: NS_IMETHODIMP
 29610: nsSVGSVGElement::GetCTM(nsIDOMSVGMatrix * *aCTM)
 29610: {
 80486:   gfxMatrix m = nsSVGUtils::GetCTM(this, false);
 78865:   *aCTM = m.IsSingular() ? nsnull : new DOMSVGMatrix(m);
 78865:   NS_IF_ADDREF(*aCTM);
 30596:   return NS_OK;
     1: }
     1: 
     1: /* nsIDOMSVGMatrix getScreenCTM (); */
     1: NS_IMETHODIMP
 29610: nsSVGSVGElement::GetScreenCTM(nsIDOMSVGMatrix **aCTM)
     1: {
101875:   gfxMatrix m = nsSVGUtils::GetCTM(this, true);
 78865:   *aCTM = m.IsSingular() ? nsnull : new DOMSVGMatrix(m);
 78865:   NS_IF_ADDREF(*aCTM);
 30596:   return NS_OK;
     1: }
     1: 
     1: /* nsIDOMSVGMatrix getTransformToElement (in nsIDOMSVGElement element); */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetTransformToElement(nsIDOMSVGElement *element,
     1:                                        nsIDOMSVGMatrix **_retval)
     1: {
     1:   if (!element)
     1:     return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
     1: 
     1:   nsresult rv;
     1:   *_retval = nsnull;
     1:   nsCOMPtr<nsIDOMSVGMatrix> ourScreenCTM;
     1:   nsCOMPtr<nsIDOMSVGMatrix> targetScreenCTM;
     1:   nsCOMPtr<nsIDOMSVGMatrix> tmp;
     1:   nsCOMPtr<nsIDOMSVGLocatable> target = do_QueryInterface(element, &rv);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   // the easiest way to do this (if likely to increase rounding error):
 33628:   GetScreenCTM(getter_AddRefs(ourScreenCTM));
 33628:   if (!ourScreenCTM) return NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE;
 33628:   target->GetScreenCTM(getter_AddRefs(targetScreenCTM));
 33628:   if (!targetScreenCTM) return NS_ERROR_DOM_SVG_MATRIX_NOT_INVERTABLE;
     1:   rv = targetScreenCTM->Inverse(getter_AddRefs(tmp));
     1:   if (NS_FAILED(rv)) return rv;
     1:   return tmp->Multiply(ourScreenCTM, _retval);  // addrefs, so we don't
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // nsIDOMSVGZoomAndPan methods
     1: 
     1: /* attribute unsigned short zoomAndPan; */
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::GetZoomAndPan(PRUint16 *aZoomAndPan)
     1: {
 38700:   *aZoomAndPan = mEnumAttributes[ZOOMANDPAN].GetAnimValue();
  5347:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsSVGSVGElement::SetZoomAndPan(PRUint16 aZoomAndPan)
     1: {
     1:   if (aZoomAndPan == nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_DISABLE ||
  5347:       aZoomAndPan == nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_MAGNIFY) {
 80122:     mEnumAttributes[ZOOMANDPAN].SetBaseValue(aZoomAndPan, this);
  5347:     return NS_OK;
  5347:   }
     1: 
101935:   return NS_ERROR_RANGE_ERR;
     1: }
     1: 
     1: //----------------------------------------------------------------------
  2617: // helper methods for implementing SVGZoomEvent:
     1: 
 27870: NS_IMETHODIMP
 27870: nsSVGSVGElement::SetCurrentScaleTranslate(float s, float x, float y)
     1: {
 27870:   NS_ENSURE_FINITE3(s, x, y, NS_ERROR_ILLEGAL_VALUE);
 27870: 
 27870:   if (s == mCurrentScale &&
 27870:       x == mCurrentTranslate.GetX() && y == mCurrentTranslate.GetY()) {
     1:     return NS_OK;
     1:   }
     1: 
 27870:   // Prevent bizarre behaviour and maxing out of CPU and memory by clamping
 27870:   if (s < CURRENT_SCALE_MIN)
 27870:     s = CURRENT_SCALE_MIN;
 27870:   else if (s > CURRENT_SCALE_MAX)
 27870:     s = CURRENT_SCALE_MAX;
     1:   
     1:   // IMPORTANT: If either mCurrentTranslate *or* mCurrentScale is changed then
     1:   // mPreviousTranslate_x, mPreviousTranslate_y *and* mPreviousScale must all
     1:   // be updated otherwise SVGZoomEvents will end up with invalid data. I.e. an
     1:   // SVGZoomEvent's properties previousScale and previousTranslate must contain
     1:   // the state of currentScale and currentTranslate immediately before the
     1:   // change that caused the event's dispatch, which is *not* necessarily the
     1:   // same thing as the values of currentScale and currentTranslate prior to
     1:   // their own last change.
 27870:   mPreviousScale = mCurrentScale;
 27870:   mPreviousTranslate = mCurrentTranslate;
 27870:   
 27870:   mCurrentScale = s;
 27870:   mCurrentTranslate = nsSVGTranslatePoint(x, y);
 27870: 
 27870:   // now dispatch the appropriate event if we are the root element
 27870:   nsIDocument* doc = GetCurrentDoc();
 27870:   if (doc) {
 46225:     nsCOMPtr<nsIPresShell> presShell = doc->GetShell();
 27870:     if (presShell && IsRoot()) {
 79445:       bool scaling = (mPreviousScale != mCurrentScale);
 27870:       nsEventStatus status = nsEventStatus_eIgnore;
 80486:       nsGUIEvent event(true, scaling ? NS_SVG_ZOOM : NS_SVG_SCROLL, 0);
 27870:       event.eventStructType = scaling ? NS_SVGZOOM_EVENT : NS_SVG_EVENT;
 27870:       presShell->HandleDOMEventWithTarget(this, &event, &status);
 27870:       InvalidateTransformNotifyFrame();
 27870:     }
 27870:   }
 27870:   return NS_OK;
 27870: }
 27870: 
 27870: NS_IMETHODIMP
 27870: nsSVGSVGElement::SetCurrentTranslate(float x, float y)
 27870: {
 27870:   return SetCurrentScaleTranslate(mCurrentScale, x, y);
     1: }
     1: 
 23697: nsSMILTimeContainer*
 23697: nsSVGSVGElement::GetTimedDocumentRoot()
 23697: {
 23697:   if (mTimedDocumentRoot) {
 64140:     return mTimedDocumentRoot;
 23697:   }
 23697: 
 64140:   // We must not be the outermost <svg> element, try to find it
 64140:   nsSVGSVGElement *outerSVGElement =
 64140:     nsSVGUtils::GetOuterSVGElement(this);
 64140: 
 64140:   if (outerSVGElement) {
 64140:     return outerSVGElement->GetTimedDocumentRoot();
 64140:   }
 64140:   // invalid structure
 64140:   return nsnull;
 23697: }
 23697: 
     1: //----------------------------------------------------------------------
     1: // nsIContent methods
     1: 
 79445: NS_IMETHODIMP_(bool)
     1: nsSVGSVGElement::IsAttributeMapped(const nsIAtom* name) const
     1: {
 86211:   // We want to map the 'width' and 'height' attributes into style for
 86211:   // outer-<svg>, except when the attributes aren't set (since their default
 86211:   // values of '100%' can cause unexpected and undesirable behaviour for SVG
 86211:   // inline in HTML). We rely on nsSVGElement::UpdateContentStyleRule() to
 86211:   // prevent mapping of the default values into style (it only maps attributes
 86211:   // that are set). We also rely on a check in nsSVGElement::
 86211:   // UpdateContentStyleRule() to prevent us mapping the attributes when they're
 86211:   // given a <length> value that is not currently recognized by the SVG
 86211:   // specification.
 86211: 
 86211:   if (!IsInner() && (name == nsGkAtoms::width || name == nsGkAtoms::height)) {
 86211:     return true;
 86211:   }
 86211: 
     1:   static const MappedAttributeEntry* const map[] = {
     1:     sColorMap,
     1:     sFEFloodMap,
     1:     sFillStrokeMap,
     1:     sFiltersMap,
     1:     sFontSpecificationMap,
     1:     sGradientStopMap,
     1:     sGraphicsMap,
  4029:     sLightingEffectsMap,
     1:     sMarkersMap,
     1:     sTextContentElementsMap,
     1:     sViewportsMap
     1:   };
     1: 
 84865:   return FindAttributeDependence(name, map) ||
     1:     nsSVGSVGElementBase::IsAttributeMapped(name);
     1: }
     1: 
     1: //----------------------------------------------------------------------
 23697: // nsIContent methods:
 23697: 
 23697: nsresult
 23697: nsSVGSVGElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
 23697: {
 23697:   if (aVisitor.mEvent->message == NS_SVG_LOAD) {
 23697:     if (mTimedDocumentRoot) {
 23697:       mTimedDocumentRoot->Begin();
 48087:       // Set 'resample needed' flag, so that if any script calls a DOM method
 48087:       // that requires up-to-date animations before our first sample callback,
 48087:       // we'll force a synchronous sample.
 48087:       AnimationNeedsResample();
 23697:     }
 23697:   }
 23697:   return nsSVGSVGElementBase::PreHandleEvent(aVisitor);
 23697: }
 23697: 
 23697: //----------------------------------------------------------------------
     1: // nsSVGElement overrides
     1: 
 79445: bool
     1: nsSVGSVGElement::IsEventName(nsIAtom* aName)
     1: {
   265:   /* The events in EventNameType_SVGSVG are for events that are only
   265:      applicable to outermost 'svg' elements. We don't check if we're an outer
   265:      'svg' element in case we're not inserted into the document yet, but since
   265:      the target of the events in question will always be the outermost 'svg'
   265:      element, this shouldn't cause any real problems.
     1:   */
   265:   return nsContentUtils::IsEventAttributeName(aName,
   265:          (EventNameType_SVGGraphic | EventNameType_SVGSVG));
     1: }
     1: 
 62244: // Helper for GetViewBoxTransform on root <svg> node
 62244: // * aLength: internal value for our <svg> width or height attribute.
 62244: // * aViewportLength: length of the corresponding dimension of the viewport.
 62244: // * aSelf: the outermost <svg> node itself.
 62244: // NOTE: aSelf is not an ancestor viewport element, so it can't be used to
 62244: // resolve percentage lengths. (It can only be used to resolve
 62244: // 'em'/'ex'-valued units).
 62244: inline float
 71887: ComputeSynthesizedViewBoxDimension(const nsSVGLength2& aLength,
 62244:                                    float aViewportLength,
 71887:                                    const nsSVGSVGElement* aSelf)
 62244: {
 62244:   if (aLength.IsPercentage()) {
 62244:     return aViewportLength * aLength.GetAnimValInSpecifiedUnits() / 100.0f;
 62244:   }
 62244: 
 71887:   return aLength.GetAnimValue(const_cast<nsSVGSVGElement*>(aSelf));
 62244: }
 62244: 
     1: //----------------------------------------------------------------------
     1: // public helpers:
     1: 
 30596: gfxMatrix
 71887: nsSVGSVGElement::GetViewBoxTransform() const
     1: {
     1:   float viewportWidth, viewportHeight;
 64140:   if (IsInner()) {
     1:     nsSVGSVGElement *ctx = GetCtx();
 30596:     viewportWidth = mLengthAttributes[WIDTH].GetAnimValue(ctx);
 30596:     viewportHeight = mLengthAttributes[HEIGHT].GetAnimValue(ctx);
 30596:   } else {
 30505:     viewportWidth = mViewportWidth;
 30505:     viewportHeight = mViewportHeight;
     1:   }
     1: 
 90445:   if (viewportWidth <= 0.0f || viewportHeight <= 0.0f) {
 90445:     return gfxMatrix(0.0, 0.0, 0.0, 0.0, 0.0, 0.0); // singular
 90445:   }
 90445: 
 98726:   nsSVGViewBoxRect viewBox =
 98726:     GetViewBoxWithSynthesis(viewportWidth, viewportHeight);
     1: 
 30596:   if (viewBox.width <= 0.0f || viewBox.height <= 0.0f) {
 30596:     return gfxMatrix(0.0, 0.0, 0.0, 0.0, 0.0, 0.0); // singular
     1:   }
     1: 
 37974:   return nsSVGUtils::GetViewBoxTransform(this,
 37974:                                          viewportWidth, viewportHeight,
 30596:                                          viewBox.x, viewBox.y,
 30596:                                          viewBox.width, viewBox.height,
 98726:                                          GetPreserveAspectRatioWithOverride());
     1: }
     1: 
 98711: void
105163: nsSVGSVGElement::ChildrenOnlyTransformChanged(PRUint32 aFlags)
 98711: {
 98711:   // Avoid wasteful calls:
 98711:   NS_ABORT_IF_FALSE(!(GetPrimaryFrame()->GetStateBits() &
 98711:                       NS_STATE_SVG_NONDISPLAY_CHILD),
 98711:                     "Non-display SVG frames don't maintain overflow rects");
 98711: 
 98711:   bool hasChildrenOnlyTransform = HasViewBoxOrSyntheticViewBox() ||
 98711:     (IsRoot() && (mCurrentTranslate != nsSVGTranslatePoint(0.0f, 0.0f) ||
 98711:                   mCurrentScale != 1.0f));
 98711: 
 98711:   // XXXSDL Currently we don't destroy frames if
 98711:   // hasChildrenOnlyTransform != mHasChildrenOnlyTransform
 98711:   // but we should once we start using GFX layers for SVG transforms
 98711:   // (see the comment in nsSVGGraphicElement::GetAttributeChangeHint).
 98711: 
 98711:   nsChangeHint changeHint =
 98711:     nsChangeHint(nsChangeHint_RepaintFrame |
 98711:                  nsChangeHint_UpdateOverflow |
 98711:                  nsChangeHint_ChildrenOnlyTransform);
 98711: 
105163:   // If we're not reconstructing the frame tree, then we only call
105163:   // PostRestyleEvent if we're not being called under reflow to avoid recursing
105163:   // to death. See bug 767056 comments 10 and 12. Since our nsSVGOuterSVGFrame
105163:   // is being reflowed we're going to invalidate and repaint its entire area
105163:   // anyway (which will include our children).
105163:   if ((changeHint & nsChangeHint_ReconstructFrame) ||
105163:       !(aFlags & eDuringReflow)) {
 98711:     nsLayoutUtils::PostRestyleEvent(this, nsRestyleHint(0), changeHint);
105163:   }
 98711: 
 98711:   mHasChildrenOnlyTransform = hasChildrenOnlyTransform;
 98711: }
 98711: 
 23697: nsresult
 23697: nsSVGSVGElement::BindToTree(nsIDocument* aDocument,
 23697:                             nsIContent* aParent,
 23697:                             nsIContent* aBindingParent,
 79445:                             bool aCompileEventHandlers)
 23697: {
 25827:   nsSMILAnimationController* smilController = nsnull;
 23697: 
 25827:   if (aDocument) {
 25827:     smilController = aDocument->GetAnimationController();
 25827:     if (smilController) {
 25827:       // SMIL is enabled in this document
 25827:       if (WillBeOutermostSVG(aParent, aBindingParent)) {
 25827:         // We'll be the outermost <svg> element.  We'll need a time container.
 25827:         if (!mTimedDocumentRoot) {
 23697:           mTimedDocumentRoot = new nsSMILTimeContainer();
 23697:           NS_ENSURE_TRUE(mTimedDocumentRoot, NS_ERROR_OUT_OF_MEMORY);
 25827:         }
 25827:       } else {
 25827:         // We're a child of some other <svg> element, so we don't need our own
 25827:         // time container. However, we need to make sure that we'll get a
 25827:         // kick-start if we get promoted to be outermost later on.
 23697:         mTimedDocumentRoot = nsnull;
 80486:         mStartAnimationOnBindToTree = true;
 23697:       }
 25827:     }
 25827:   }
 23697: 
 23697:   nsresult rv = nsSVGSVGElementBase::BindToTree(aDocument, aParent,
 23697:                                                 aBindingParent,
 23697:                                                 aCompileEventHandlers);
 23697:   NS_ENSURE_SUCCESS(rv,rv);
 23697: 
 25827:   if (mTimedDocumentRoot && smilController) {
 23697:     rv = mTimedDocumentRoot->SetParent(smilController);
 23697:     if (mStartAnimationOnBindToTree) {
 23697:       mTimedDocumentRoot->Begin();
 80486:       mStartAnimationOnBindToTree = false;
 23697:     }
 23697:   }
 23697: 
 23697:   return rv;
 23697: }
 23697: 
 23697: void
 79445: nsSVGSVGElement::UnbindFromTree(bool aDeep, bool aNullParent)
 23697: {
 23697:   if (mTimedDocumentRoot) {
 23697:     mTimedDocumentRoot->SetParent(nsnull);
 23697:   }
 23697: 
 23697:   nsSVGSVGElementBase::UnbindFromTree(aDeep, aNullParent);
 23697: }
 23697: 
     1: //----------------------------------------------------------------------
     1: // implementation helpers
     1: 
 79445: bool
 23697: nsSVGSVGElement::WillBeOutermostSVG(nsIContent* aParent,
 23697:                                     nsIContent* aBindingParent) const
 23697: {
 23697:   nsIContent* parent = aBindingParent ? aBindingParent : aParent;
 23697: 
 84637:   while (parent && parent->IsSVG()) {
 23697:     nsIAtom* tag = parent->Tag();
 23697:     if (tag == nsGkAtoms::foreignObject) {
 23697:       // SVG in a foreignObject must have its own <svg> (nsSVGOuterSVGFrame).
 80486:       return false;
 23697:     }
 23697:     if (tag == nsGkAtoms::svg) {
 80486:       return false;
 23697:     }
 23697:     parent = parent->GetParent();
 23697:   }
 23697: 
 80486:   return true;
 23697: }
 23697: 
     1: void
     1: nsSVGSVGElement::InvalidateTransformNotifyFrame()
     1: {
 39947:   nsIFrame* frame = GetPrimaryFrame();
 71127:   if (frame) {
 39947:     nsISVGSVGFrame* svgframe = do_QueryFrame(frame);
 71127:     // might fail this check if we've failed conditional processing
     1:     if (svgframe) {
 97651:       svgframe->NotifyViewportOrTransformChanged(
 97651:                   nsISVGChildFrame::TRANSFORM_CHANGED);
     1:     }
     1:   }
     1: }
     1: 
 79445: bool
 59474: nsSVGSVGElement::HasPreserveAspectRatio()
 59474: {
 59474:   return HasAttr(kNameSpaceID_None, nsGkAtoms::preserveAspectRatio) ||
 59474:     mPreserveAspectRatio.IsAnimated();
 59474: }
 59474: 
 98726: nsSVGViewBoxRect
 98726: nsSVGSVGElement::GetViewBoxWithSynthesis(
 98726:   float aViewportWidth, float aViewportHeight) const
 98726: {
 98726:   if (HasViewBox()) {
 98726:     return mViewBox.GetAnimValue();
 98726:   }
 98726: 
 98726:   if (ShouldSynthesizeViewBox()) {
 98726:     // Special case -- fake a viewBox, using height & width attrs.
 98726:     // (Use |this| as context, since if we get here, we're outermost <svg>.)
 98726:     return nsSVGViewBoxRect(0, 0,
 98726:               ComputeSynthesizedViewBoxDimension(mLengthAttributes[WIDTH],
 98726:                                                  mViewportWidth, this),
 98726:               ComputeSynthesizedViewBoxDimension(mLengthAttributes[HEIGHT],
 98726:                                                  mViewportHeight, this));
 98726: 
 98726:   }
 98726: 
 98726:   // No viewBox attribute, so we shouldn't auto-scale. This is equivalent
 98726:   // to having a viewBox that exactly matches our viewport size.
 98726:   return nsSVGViewBoxRect(0, 0, aViewportWidth, aViewportHeight);
 98726: }
 98726: 
 98726: SVGPreserveAspectRatio
 98726: nsSVGSVGElement::GetPreserveAspectRatioWithOverride() const
 98726: {
 99205:   nsIDocument* doc = GetCurrentDoc();
 99205:   if (doc && doc->IsBeingUsedAsImage()) {
 98726:     const SVGPreserveAspectRatio *pAROverridePtr = GetPreserveAspectRatioProperty();
 98726:     if (pAROverridePtr) {
 98726:       return *pAROverridePtr;
 98726:     }
 98726:   }
 98726: 
 98726:   if (!HasViewBox() && ShouldSynthesizeViewBox()) {
 98726:     // If we're synthesizing a viewBox, use preserveAspectRatio="none";
 98726:     return SVGPreserveAspectRatio(
 98726:          nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_NONE,
 98726:          nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_SLICE);
 98726:   }
 98726: 
 98726:   return mPreserveAspectRatio.GetAnimValue();
 98726: }
 98726: 
     1: //----------------------------------------------------------------------
     1: // nsSVGSVGElement
     1: 
 24554: float
 24554: nsSVGSVGElement::GetLength(PRUint8 aCtxType)
  3021: {
 24554:   float h, w;
 24554: 
 97650:   if (HasViewBox()) {
 38700:     const nsSVGViewBoxRect& viewbox = mViewBox.GetAnimValue();
 24554:     w = viewbox.width;
 24554:     h = viewbox.height;
 64140:   } else if (IsInner()) {
     1:     nsSVGSVGElement *ctx = GetCtx();
 25598:     w = mLengthAttributes[WIDTH].GetAnimValue(ctx);
 25598:     h = mLengthAttributes[HEIGHT].GetAnimValue(ctx);
 62244:   } else if (ShouldSynthesizeViewBox()) {
 62244:     w = ComputeSynthesizedViewBoxDimension(mLengthAttributes[WIDTH],
 62244:                                            mViewportWidth, this);
 62244:     h = ComputeSynthesizedViewBoxDimension(mLengthAttributes[HEIGHT],
 62244:                                            mViewportHeight, this);
 25598:   } else {
 25397:     w = mViewportWidth;
 25397:     h = mViewportHeight;
     1:   }
 12023: 
 36757:   w = NS_MAX(w, 0.0f);
 36757:   h = NS_MAX(h, 0.0f);
 12023: 
     1:   switch (aCtxType) {
     1:   case nsSVGUtils::X:
     1:     return w;
     1:   case nsSVGUtils::Y:
     1:     return h;
     1:   case nsSVGUtils::XY:
 15943:     return float(nsSVGUtils::ComputeNormalizedHypotenuse(w, h));
     1:   }
     1:   return 0;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // nsSVGElement methods
     1: 
 27899: /* virtual */ gfxMatrix
 90361: nsSVGSVGElement::PrependLocalTransformsTo(const gfxMatrix &aMatrix,
 90361:                                           TransformTypes aWhich) const
 27899: {
 90361:   NS_ABORT_IF_FALSE(aWhich != eChildToUserSpace || aMatrix.IsIdentity(),
 90361:                     "Skipping eUserSpaceToParent transforms makes no sense");
 90361: 
 64140:   if (IsInner()) {
 27899:     float x, y;
 71887:     const_cast<nsSVGSVGElement*>(this)->GetAnimatedLengthValues(&x, &y, nsnull);
 90361:     if (aWhich == eAllTransforms) {
 90361:       // the common case
 30596:       return GetViewBoxTransform() * gfxMatrix().Translate(gfxPoint(x, y)) * aMatrix;
 30596:     }
 90361:     if (aWhich == eUserSpaceToParent) {
 90361:       return gfxMatrix().Translate(gfxPoint(x, y)) * aMatrix;
 90361:     }
 90361:     NS_ABORT_IF_FALSE(aWhich == eChildToUserSpace, "Unknown TransformTypes");
 90361:     return GetViewBoxTransform(); // no need to multiply identity aMatrix
 90361:   }
 90361: 
 90361:   if (aWhich == eUserSpaceToParent) {
 90361:     // only inner-<svg> has eUserSpaceToParent transforms
 90361:     return aMatrix;
 90361:   }
 30505: 
 30596:   if (IsRoot()) {
 30596:     gfxMatrix zoomPanTM;
 30596:     zoomPanTM.Translate(gfxPoint(mCurrentTranslate.GetX(), mCurrentTranslate.GetY()));
 30596:     zoomPanTM.Scale(mCurrentScale, mCurrentScale);
 30596:     return GetViewBoxTransform() * zoomPanTM * aMatrix;
 30502:   }
 30596: 
 30596:   // outer-<svg>, but inline in some other content:
 30596:   return GetViewBoxTransform() * aMatrix;
 27899: }
 27899: 
 91474: /* virtual */ bool
 91474: nsSVGSVGElement::HasValidDimensions() const
 91474: {
 91474:   return !IsInner() ||
 91474:     ((!mLengthAttributes[WIDTH].IsExplicitlySet() ||
 91474:        mLengthAttributes[WIDTH].GetAnimValInSpecifiedUnits() > 0) &&
 91474:      (!mLengthAttributes[HEIGHT].IsExplicitlySet() || 
 91474:        mLengthAttributes[HEIGHT].GetAnimValInSpecifiedUnits() > 0));
 91474: }
 91474: 
     1: nsSVGElement::LengthAttributesInfo
     1: nsSVGSVGElement::GetLengthInfo()
     1: {
     1:   return LengthAttributesInfo(mLengthAttributes, sLengthInfo,
 80467:                               ArrayLength(sLengthInfo));
     1: }
  5347: 
  5347: nsSVGElement::EnumAttributesInfo
  5347: nsSVGSVGElement::GetEnumInfo()
  5347: {
  5347:   return EnumAttributesInfo(mEnumAttributes, sEnumInfo,
 80467:                             ArrayLength(sEnumInfo));
  5347: }
 23313: 
 24554: nsSVGViewBox *
 24554: nsSVGSVGElement::GetViewBox()
 24554: {
 24554:   return &mViewBox;
 24554: }
 24554: 
 59470: SVGAnimatedPreserveAspectRatio *
 23313: nsSVGSVGElement::GetPreserveAspectRatio()
 23313: {
 23313:   return &mPreserveAspectRatio;
 23313: }
 57610: 
 79445: bool
 71887: nsSVGSVGElement::ShouldSynthesizeViewBox() const
 62244: {
 97650:   NS_ABORT_IF_FALSE(!HasViewBox(),
 62244:                     "Should only be called if we lack a viewBox");
 62244: 
 62244:   nsIDocument* doc = GetCurrentDoc();
 62244:   return doc &&
 62244:     doc->IsBeingUsedAsImage() &&
 62244:     !mIsPaintingSVGImageElement &&
 62244:     !GetParent();
 62244: }
 62244: 
 62244: 
 59474: // Callback function, for freeing PRUint64 values stored in property table
 59474: static void
 59474: ReleasePreserveAspectRatioPropertyValue(void*    aObject,       /* unused */
 59474:                                         nsIAtom* aPropertyName, /* unused */
 59474:                                         void*    aPropertyValue,
 59474:                                         void*    aData          /* unused */)
 59474: {
 59474:   SVGPreserveAspectRatio* valPtr =
 59474:     static_cast<SVGPreserveAspectRatio*>(aPropertyValue);
 59474:   delete valPtr;
 59474: }
 59474: 
 98726: bool
 98726: nsSVGSVGElement::
 98726:   SetPreserveAspectRatioProperty(const SVGPreserveAspectRatio& aPAR)
 98726: {
 98726:   SVGPreserveAspectRatio* pAROverridePtr = new SVGPreserveAspectRatio(aPAR);
 98726:   nsresult rv = SetProperty(nsGkAtoms::overridePreserveAspectRatio,
 98726:                             pAROverridePtr,
101258:                             ReleasePreserveAspectRatioPropertyValue,
101258:                             true);
 98726:   NS_ABORT_IF_FALSE(rv != NS_PROPTABLE_PROP_OVERWRITTEN,
 98726:                     "Setting override value when it's already set...?"); 
 98726: 
 98726:   if (NS_UNLIKELY(NS_FAILED(rv))) {
 98726:     // property-insertion failed (e.g. OOM in property-table code)
 98726:     delete pAROverridePtr;
 98726:     return false;
 98726:   }
 98726:   return true;
 98726: }
 98726: 
 98726: const SVGPreserveAspectRatio*
 98726: nsSVGSVGElement::GetPreserveAspectRatioProperty() const
 98726: {
 98726:   void* valPtr = GetProperty(nsGkAtoms::overridePreserveAspectRatio);
 98726:   if (valPtr) {
 98726:     return static_cast<SVGPreserveAspectRatio*>(valPtr);
 98726:   }
 98726:   return nsnull;
 98726: }
 98726: 
 98726: bool
 98726: nsSVGSVGElement::ClearPreserveAspectRatioProperty()
 98726: {
 98726:   void* valPtr = UnsetProperty(nsGkAtoms::overridePreserveAspectRatio);
 98726:   delete static_cast<SVGPreserveAspectRatio*>(valPtr);
 98726:   return valPtr;
 98726: }
 98726: 
 59474: void
 59474: nsSVGSVGElement::
 59474:   SetImageOverridePreserveAspectRatio(const SVGPreserveAspectRatio& aPAR)
 59474: {
 59474: #ifdef DEBUG
 59474:   NS_ABORT_IF_FALSE(GetCurrentDoc()->IsBeingUsedAsImage(),
 59474:                     "should only override preserveAspectRatio in images");
 59474: #endif
 59474: 
 97650:   if (!HasViewBox() && ShouldSynthesizeViewBox()) {
 62244:     // My non-<svg:image> clients will have been painting me with a synthesized
 62244:     // viewBox, but my <svg:image> client that's about to paint me now does NOT
 62244:     // want that.  Need to tell ourselves to flush our transform.
 80486:     mImageNeedsTransformInvalidation = true;
 62244:   }
 80486:   mIsPaintingSVGImageElement = true;
 62244: 
 97650:   if (!HasViewBox()) {
 59474:     return; // preserveAspectRatio irrelevant (only matters if we have viewBox)
 59474:   }
 59474: 
 59474:   if (aPAR.GetDefer() && HasPreserveAspectRatio()) {
 59474:     return; // Referring element defers to my own preserveAspectRatio value.
 59474:   }
 59474: 
 98726:   if (SetPreserveAspectRatioProperty(aPAR)) {
 80486:     mImageNeedsTransformInvalidation = true;
 59474:   }
 59474: }
 59474: 
 59474: void
 59474: nsSVGSVGElement::ClearImageOverridePreserveAspectRatio()
 59474: {
 59474: #ifdef DEBUG
 59474:   NS_ABORT_IF_FALSE(GetCurrentDoc()->IsBeingUsedAsImage(),
 98726:                     "should only override image preserveAspectRatio in images");
 59474: #endif
 59474: 
 80486:   mIsPaintingSVGImageElement = false;
 97650:   if (!HasViewBox() && ShouldSynthesizeViewBox()) {
 62244:     // My non-<svg:image> clients will want to paint me with a synthesized
 62244:     // viewBox, but my <svg:image> client that just painted me did NOT
 62244:     // use that.  Need to tell ourselves to flush our transform.
 80486:     mImageNeedsTransformInvalidation = true;
 62244:   }
 62244: 
 98726:   if (ClearPreserveAspectRatioProperty()) {
 80486:     mImageNeedsTransformInvalidation = true;
 59474:   }
 59474: }
 59474: 
 59474: void
 62243: nsSVGSVGElement::FlushImageTransformInvalidation()
 59474: {
 62243:   NS_ABORT_IF_FALSE(!GetParent(), "Should only be called on root node");
 62243:   NS_ABORT_IF_FALSE(GetCurrentDoc()->IsBeingUsedAsImage(),
 62243:                     "Should only be called on image documents");
 62243: 
 62243:   if (mImageNeedsTransformInvalidation) {
 59474:     InvalidateTransformNotifyFrame();
 80486:     mImageNeedsTransformInvalidation = false;
 59474:   }
 59474: }
 98726: 
 98726: // Callback function, for freeing PRUint64 values stored in property table
 98726: static void
 98726: ReleaseViewBoxPropertyValue(void*    aObject,       /* unused */
 98726:                             nsIAtom* aPropertyName, /* unused */
 98726:                             void*    aPropertyValue,
 98726:                             void*    aData          /* unused */)
 98726: {
 98726:   nsSVGViewBoxRect* valPtr =
 98726:     static_cast<nsSVGViewBoxRect*>(aPropertyValue);
 98726:   delete valPtr;
 98726: }
 98726: 
 98726: bool
 98726: nsSVGSVGElement::SetViewBoxProperty(const nsSVGViewBoxRect& aViewBox)
 98726: {
 98726:   nsSVGViewBoxRect* pViewBoxOverridePtr = new nsSVGViewBoxRect(aViewBox);
 98726:   nsresult rv = SetProperty(nsGkAtoms::viewBox,
 98726:                             pViewBoxOverridePtr,
101258:                             ReleaseViewBoxPropertyValue,
101258:                             true);
 98726:   NS_ABORT_IF_FALSE(rv != NS_PROPTABLE_PROP_OVERWRITTEN,
 98726:                     "Setting override value when it's already set...?"); 
 98726: 
 98726:   if (NS_UNLIKELY(NS_FAILED(rv))) {
 98726:     // property-insertion failed (e.g. OOM in property-table code)
 98726:     delete pViewBoxOverridePtr;
 98726:     return false;
 98726:   }
 98726:   return true;
 98726: }
 98726: 
 98726: const nsSVGViewBoxRect*
 98726: nsSVGSVGElement::GetViewBoxProperty() const
 98726: {
 98726:   void* valPtr = GetProperty(nsGkAtoms::viewBox);
 98726:   if (valPtr) {
 98726:     return static_cast<nsSVGViewBoxRect*>(valPtr);
 98726:   }
 98726:   return nsnull;
 98726: }
 98726: 
 98726: bool
 98726: nsSVGSVGElement::ClearViewBoxProperty()
 98726: {
 98726:   void* valPtr = UnsetProperty(nsGkAtoms::viewBox);
 98726:   delete static_cast<nsSVGViewBoxRect*>(valPtr);
 98726:   return valPtr;
 98726: }
 98726: 
 98726: bool
 98726: nsSVGSVGElement::SetZoomAndPanProperty(PRUint16 aValue)
 98726: {
101258:   nsresult rv = SetProperty(nsGkAtoms::zoomAndPan,
101258:                             reinterpret_cast<void*>(aValue),
101258:                             nsnull, true);
 98726:   NS_ABORT_IF_FALSE(rv != NS_PROPTABLE_PROP_OVERWRITTEN,
 98726:                     "Setting override value when it's already set...?"); 
 98726: 
 98726:   return NS_SUCCEEDED(rv);
 98726: }
 98726: 
 99905: PRUint16
 98726: nsSVGSVGElement::GetZoomAndPanProperty() const
 98726: {
 98726:   void* valPtr = GetProperty(nsGkAtoms::zoomAndPan);
 98726:   if (valPtr) {
 99905:     return reinterpret_cast<uintptr_t>(valPtr);
 98726:   }
 99905:   return nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_UNKNOWN;
 98726: }
 98726: 
 98726: bool
 98726: nsSVGSVGElement::ClearZoomAndPanProperty()
 98726: {
 99905:   return UnsetProperty(nsGkAtoms::zoomAndPan);
 98726: }
 98726: 
