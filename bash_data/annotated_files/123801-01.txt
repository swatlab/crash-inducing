 81024: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 81024: 
 84182: #include <string>
 81024: #include <stdio.h>
 93931: #include <iostream>
 93931: #include <fstream>
 93931: #include <sstream>
 81024: #include "sps_sampler.h"
 81024: #include "platform.h"
 81024: #include "nsXULAppAPI.h"
 81024: #include "nsThreadUtils.h"
 81024: #include "prenv.h"
 86339: #include "shared-libraries.h"
 89959: #include "mozilla/StackWalk.h"
104276: 
104276: // JSON
 91957: #include "JSObjectBuilder.h"
104276: #include "nsIJSRuntimeService.h"
 81024: 
103096: // Meta
103096: #include "nsXPCOM.h"
103096: #include "nsXPCOMCID.h"
103096: #include "nsIHttpProtocolHandler.h"
103096: #include "nsServiceManagerUtils.h"
103096: #include "nsIXULRuntime.h"
103096: #include "nsIXULAppInfo.h"
104095: #include "nsDirectoryServiceUtils.h"
104095: #include "nsDirectoryServiceDefs.h"
114514: #include "nsIObserverService.h"
114514: #include "mozilla/Services.h"
103096: 
108151: // JS
108151: #include "jsdbgapi.h"
108151: 
 86346: // we eventually want to make this runtime switchable
 89959: #if defined(MOZ_PROFILING) && (defined(XP_UNIX) && !defined(XP_MACOSX))
 87197:  #ifndef ANDROID
 87196:   #define USE_BACKTRACE
 87196:  #endif
 87197: #endif
 86346: #ifdef USE_BACKTRACE
 86346:  #include <execinfo.h>
 86346: #endif
 86346: 
 89959: #if defined(MOZ_PROFILING) && (defined(XP_MACOSX) || defined(XP_WIN))
 87491:  #define USE_NS_STACKWALK
 87491: #endif
 87491: #ifdef USE_NS_STACKWALK
 87491:  #include "nsStackWalk.h"
 87491: #endif
 87491: 
 93709: #if defined(MOZ_PROFILING) && defined(ANDROID)
 93709:  #define USE_LIBUNWIND
 93709:  #include <libunwind.h>
 93709:  #include "android-signal-defs.h"
 93709: #endif
 93709: 
 84182: using std::string;
 86344: using namespace mozilla;
 84182: 
 84348: #ifdef XP_WIN
 84348:  #include <windows.h>
 84348:  #define getpid GetCurrentProcessId
 84348: #else
 84348:  #include <unistd.h>
 84348: #endif
 84348: 
 84348: #ifndef MAXPATHLEN
 84348:  #ifdef PATH_MAX
 84348:   #define MAXPATHLEN PATH_MAX
 84348:  #elif defined(MAX_PATH)
 84348:   #define MAXPATHLEN MAX_PATH
 84348:  #elif defined(_MAX_PATH)
 84348:   #define MAXPATHLEN _MAX_PATH
 84348:  #elif defined(CCHMAXPATH)
 84348:   #define MAXPATHLEN CCHMAXPATH
 84348:  #else
 84348:   #define MAXPATHLEN 1024
 84348:  #endif
 84348: #endif
 84348: 
 84348: #if _MSC_VER
 84348:  #define snprintf _snprintf
 84348: #endif
 84348: 
103095: static const int DYNAMIC_MAX_STRING = 512;
 86346: 
 99088: mozilla::ThreadLocal<ProfileStack *> tlsStack;
 99088: mozilla::ThreadLocal<TableTicker *> tlsTicker;
 84289: // We need to track whether we've been initialized otherwise
 98877: // we end up using tlsStack without initializing it.
 98877: // Because tlsStack is totally opaque to us we can't reuse
 84289: // it as the flag itself.
 84289: bool stack_key_initialized;
 81024: 
 84182: TimeStamp sLastTracerEvent;
111209: int sFrameNumber = 0;
111209: int sLastFrameNumber = 0;
 84182: 
 92114: class ThreadProfile;
 81024: 
 81024: class ProfileEntry
 81024: {
 81024: public:
 81024:   ProfileEntry()
 81024:     : mTagData(NULL)
 81024:     , mTagName(0)
 81024:   { }
 81024: 
 81024:   // aTagData must not need release (i.e. be a string from the text segment)
 81024:   ProfileEntry(char aTagName, const char *aTagData)
 81024:     : mTagData(aTagData)
 81024:     , mTagName(aTagName)
 81024:   { }
 81024: 
 98028:   ProfileEntry(char aTagName, void *aTagPtr)
 98028:     : mTagPtr(aTagPtr)
 98028:     , mTagName(aTagName)
 98028:   { }
 98028: 
 87177:   ProfileEntry(char aTagName, double aTagFloat)
 84182:     : mTagFloat(aTagFloat)
 84182:     , mTagName(aTagName)
 84182:   { }
 84182: 
 87196:   ProfileEntry(char aTagName, uintptr_t aTagOffset)
 87196:     : mTagOffset(aTagOffset)
 95500:     , mTagName(aTagName)
 95500:   { }
 95500: 
 95500:   ProfileEntry(char aTagName, Address aTagAddress)
 95500:     : mTagAddress(aTagAddress)
 87196:     , mTagName(aTagName)
 87196:   { }
 87196: 
108151:   ProfileEntry(char aTagName, int aTagLine)
108151:     : mTagLine(aTagLine)
108151:     , mTagName(aTagName)
108151:   { }
108151: 
 93931:   friend std::ostream& operator<<(std::ostream& stream, const ProfileEntry& entry);
 81024: 
 84182:   union {
 81024:     const char* mTagData;
103095:     char mTagChars[sizeof(void*)];
 98028:     void* mTagPtr;
 87177:     double mTagFloat;
 86346:     Address mTagAddress;
 87196:     uintptr_t mTagOffset;
108151:     int mTagLine;
 84182:   };
 81024:   char mTagName;
 81024: };
 81024: 
123586: typedef void (*IterateTagsCallback)(const ProfileEntry& entry, const char* tagStringData);
123586: 
 81024: #define PROFILE_MAX_ENTRY 100000
 92114: class ThreadProfile
 81024: {
 81024: public:
 92115:   ThreadProfile(int aEntrySize, ProfileStack *aStack)
 81024:     : mWritePos(0)
 87847:     , mLastFlushPos(0)
 81024:     , mReadPos(0)
 81024:     , mEntrySize(aEntrySize)
 92115:     , mStack(aStack)
 81024:   {
 81024:     mEntries = new ProfileEntry[mEntrySize];
 81024:   }
 81024: 
 92114:   ~ThreadProfile()
 81024:   {
 81024:     delete[] mEntries;
 81024:   }
 81024: 
 81024:   void addTag(ProfileEntry aTag)
 81024:   {
 81024:     // Called from signal, call only reentrant functions
 81024:     mEntries[mWritePos] = aTag;
 81024:     mWritePos = (mWritePos + 1) % mEntrySize;
 81024:     if (mWritePos == mReadPos) {
 81024:       // Keep one slot open
 81024:       mEntries[mReadPos] = ProfileEntry();
 81024:       mReadPos = (mReadPos + 1) % mEntrySize;
 81024:     }
 87847:     // we also need to move the flush pos to ensure we
 87847:     // do not pass it
 87847:     if (mWritePos == mLastFlushPos) {
 87847:       mLastFlushPos = (mLastFlushPos + 1) % mEntrySize;
 87847:     }
 87847:   }
 87847: 
 87847:   // flush the new entries
 87847:   void flush()
 87847:   {
 87847:     mLastFlushPos = mWritePos;
 87847:   }
 87847: 
 87847:   // discards all of the entries since the last flush()
 87847:   // NOTE: that if mWritePos happens to wrap around past
 87847:   // mLastFlushPos we actually only discard mWritePos - mLastFlushPos entries
 87847:   //
 87847:   // r = mReadPos
 87847:   // w = mWritePos
 87847:   // f = mLastFlushPos
 87847:   //
 87847:   //     r          f    w
 87847:   // |-----------------------------|
 87847:   // |   abcdefghijklmnopq         | -> 'abcdefghijklmnopq'
 87847:   // |-----------------------------|
 87847:   //
 87847:   //
 87847:   // mWritePos and mReadPos have passed mLastFlushPos
 87847:   //                      f
 87847:   //                    w r
 87847:   // |-----------------------------|
 87847:   // |ABCDEFGHIJKLMNOPQRSqrstuvwxyz|
 87847:   // |-----------------------------|
 87847:   //                       w
 87847:   //                       r
 87847:   // |-----------------------------|
 87847:   // |ABCDEFGHIJKLMNOPQRSqrstuvwxyz| -> ''
 87847:   // |-----------------------------|
 87847:   //
 87847:   //
 87847:   // mWritePos will end up the same as mReadPos
 87847:   //                r
 87847:   //              w f
 87847:   // |-----------------------------|
 87847:   // |ABCDEFGHIJKLMklmnopqrstuvwxyz|
 87847:   // |-----------------------------|
 87847:   //                r
 87847:   //                w
 87847:   // |-----------------------------|
 87847:   // |ABCDEFGHIJKLMklmnopqrstuvwxyz| -> ''
 87847:   // |-----------------------------|
 87847:   //
 87847:   //
 87847:   // mWritePos has moved past mReadPos
 87847:   //      w r       f
 87847:   // |-----------------------------|
 87847:   // |ABCDEFdefghijklmnopqrstuvwxyz|
 87847:   // |-----------------------------|
 87847:   //        r       w
 87847:   // |-----------------------------|
 87847:   // |ABCDEFdefghijklmnopqrstuvwxyz| -> 'defghijkl'
 87847:   // |-----------------------------|
 87847: 
 87847:   void erase()
 87847:   {
 87847:     mWritePos = mLastFlushPos;
 81024:   }
 81024: 
103095:   char* processDynamicTag(int readPos, int* tagsConsumed, char* tagBuff)
103095:   {
103095:     int readAheadPos = (readPos + 1) % mEntrySize;
103095:     int tagBuffPos = 0;
103095: 
103095:     // Read the string stored in mTagData until the null character is seen
103095:     bool seenNullByte = false;
103095:     while (readAheadPos != mLastFlushPos && !seenNullByte) {
103095:       (*tagsConsumed)++;
103095:       ProfileEntry readAheadEntry = mEntries[readAheadPos];
103095:       for (size_t pos = 0; pos < sizeof(void*); pos++) {
103095:         tagBuff[tagBuffPos] = readAheadEntry.mTagChars[pos];
103095:         if (tagBuff[tagBuffPos] == '\0' || tagBuffPos == DYNAMIC_MAX_STRING-2) {
103095:           seenNullByte = true;
103095:           break;
103095:         }
103095:         tagBuffPos++;
103095:       }
103095:       if (!seenNullByte)
103095:         readAheadPos = (readAheadPos + 1) % mEntrySize;
103095:     }
103095:     return tagBuff;
103095:   }
103095: 
 93931:   friend std::ostream& operator<<(std::ostream& stream, const ThreadProfile& profile);
 84182: 
123586:   void IterateTags(IterateTagsCallback aCallback)
123586:   {
123586:     MOZ_ASSERT(aCallback);
123586: 
123586:     int readPos = mReadPos;
123586:     while (readPos != mLastFlushPos) {
123586:       // Number of tag consumed
123586:       int incBy = 1;
123586:       const ProfileEntry& entry = mEntries[readPos];
123586: 
123586:       // Read ahead to the next tag, if it's a 'd' tag process it now
123586:       const char* tagStringData = entry.mTagData;
123586:       int readAheadPos = (readPos + 1) % mEntrySize;
123586:       char tagBuff[DYNAMIC_MAX_STRING];
123586:       // Make sure the string is always null terminated if it fills up DYNAMIC_MAX_STRING-2
123586:       tagBuff[DYNAMIC_MAX_STRING-1] = '\0';
123586: 
123586:       if (readAheadPos != mLastFlushPos && mEntries[readAheadPos].mTagName == 'd') {
123586:         tagStringData = processDynamicTag(readPos, &incBy, tagBuff);
123586:       }
123586: 
123586:       aCallback(entry, tagStringData);
123586: 
123586:       readPos = (readPos + incBy) % mEntrySize;
123586:     }
123586:   }
123586: 
 91957:   JSObject *ToJSObject(JSContext *aCx)
 91957:   {
 91957:     JSObjectBuilder b(aCx);
 91957: 
 91957:     JSObject *profile = b.CreateObject();
 91957:     JSObject *samples = b.CreateArray();
 91957:     b.DefineProperty(profile, "samples", samples);
 91957: 
 91957:     JSObject *sample = NULL;
 91957:     JSObject *frames = NULL;
118931:     JSObject *marker = NULL;
 91957: 
103035:     int readPos = mReadPos;
103035:     while (readPos != mLastFlushPos) {
103095:       // Number of tag consumed
103095:       int incBy = 1;
103035:       ProfileEntry entry = mEntries[readPos];
103095: 
103095:       // Read ahead to the next tag, if it's a 'd' tag process it now
103095:       const char* tagStringData = entry.mTagData;
103095:       int readAheadPos = (readPos + 1) % mEntrySize;
103095:       char tagBuff[DYNAMIC_MAX_STRING];
103095:       // Make sure the string is always null terminated if it fills up DYNAMIC_MAX_STRING-2
103095:       tagBuff[DYNAMIC_MAX_STRING-1] = '\0';
103095: 
103095:       if (readAheadPos != mLastFlushPos && mEntries[readAheadPos].mTagName == 'd') {
103095:         tagStringData = processDynamicTag(readPos, &incBy, tagBuff);
103095:       }
103095: 
 91957:       switch (entry.mTagName) {
 91957:         case 's':
 91957:           sample = b.CreateObject();
103095:           b.DefineProperty(sample, "name", tagStringData);
 91957:           frames = b.CreateArray();
 91957:           b.DefineProperty(sample, "frames", frames);
 91957:           b.ArrayPush(samples, sample);
118931:           // Created lazily
118931:           marker = NULL;
118931:           break;
118931:         case 'm':
118931:           {
118931:             if (sample) {
118931:               if (!marker) {
118931:                 marker = b.CreateArray();
118931:                 b.DefineProperty(sample, "marker", marker);
118931:               }
118931:               b.ArrayPush(marker, tagStringData);
118931:             }
118931:           }
 91957:           break;
103150:         case 'r':
103150:           {
103150:             if (sample) {
103150:               b.DefineProperty(sample, "responsiveness", entry.mTagFloat);
103150:             }
103150:           }
103150:           break;
111209:         case 'f':
111209:           {
111209:             if (sample) {
111209:               b.DefineProperty(sample, "frameNumber", entry.mTagLine);
111209:             }
111209:           }
111209:           break;
103720:         case 't':
103720:           {
103720:             if (sample) {
103720:               b.DefineProperty(sample, "time", entry.mTagFloat);
103720:             }
103720:           }
103720:           break;
 91957:         case 'c':
 91957:         case 'l':
 91957:           {
 91957:             if (sample) {
 91957:               JSObject *frame = b.CreateObject();
103095:               if (entry.mTagName == 'l') {
 98028:                 // Bug 753041
 98028:                 // We need a double cast here to tell GCC that we don't want to sign
 98028:                 // extend 32-bit addresses starting with 0xFXXXXXX.
 98028:                 unsigned long long pc = (unsigned long long)(uintptr_t)entry.mTagPtr;
103095:                 snprintf(tagBuff, DYNAMIC_MAX_STRING, "%#llx", pc);
 92116:                 b.DefineProperty(frame, "location", tagBuff);
103095:               } else {
103095:                 b.DefineProperty(frame, "location", tagStringData);
108151:                 readAheadPos = (readPos + incBy) % mEntrySize;
108151:                 if (readAheadPos != mLastFlushPos &&
108151:                     mEntries[readAheadPos].mTagName == 'n') {
108151:                   b.DefineProperty(frame, "line",
108151:                                    mEntries[readAheadPos].mTagLine);
108151:                   incBy++;
108151:                 }
103095:               }
 91957:               b.ArrayPush(frames, frame);
 91957:             }
 91957:           }
 91957:       }
103095:       readPos = (readPos + incBy) % mEntrySize;
 91957:     }
 91957: 
 91957:     return profile;
 91957:   }
 91957: 
 92115:   ProfileStack* GetStack()
 92115:   {
 92115:     return mStack;
 92115:   }
 81024: private:
 81024:   // Circular buffer 'Keep One Slot Open' implementation
 81024:   // for simplicity
 81024:   ProfileEntry *mEntries;
 81024:   int mWritePos; // points to the next entry we will write to
 87847:   int mLastFlushPos; // points to the next entry since the last flush()
 81024:   int mReadPos;  // points to the next entry we will read to
 81024:   int mEntrySize;
 92115:   ProfileStack *mStack;
 81024: };
 81024: 
 81024: class SaveProfileTask;
 81024: 
 87178: static bool
 87178: hasFeature(const char** aFeatures, uint32_t aFeatureCount, const char* aFeature) {
 87178:   for(size_t i = 0; i < aFeatureCount; i++) {
 87178:     if (strcmp(aFeatures[i], aFeature) == 0)
 87178:       return true;
 87178:   }
 87178:   return false;
 87178: }
 87178: 
 81024: class TableTicker: public Sampler {
 81024:  public:
 92114:   TableTicker(int aInterval, int aEntrySize, ProfileStack *aStack,
 87178:               const char** aFeatures, uint32_t aFeatureCount)
 81024:     : Sampler(aInterval, true)
 92115:     , mPrimaryThreadProfile(aEntrySize, aStack)
103720:     , mStartTime(TimeStamp::Now())
 81024:     , mSaveRequested(false)
 81024:   {
 87196:     mUseStackWalk = hasFeature(aFeatures, aFeatureCount, "stackwalk");
 93709: 
 87847:     //XXX: It's probably worth splitting the jank profiler out from the regular profiler at some point
 87413:     mJankOnly = hasFeature(aFeatures, aFeatureCount, "jank");
103915:     mProfileJS = hasFeature(aFeatures, aFeatureCount, "js");
 92114:     mPrimaryThreadProfile.addTag(ProfileEntry('m', "Start"));
 81024:   }
 81024: 
 81024:   ~TableTicker() { if (IsActive()) Stop(); }
 81024: 
 81024:   virtual void SampleStack(TickSample* sample) {}
 81024: 
 81024:   // Called within a signal. This function must be reentrant
 81024:   virtual void Tick(TickSample* sample);
 81024: 
 81024:   // Called within a signal. This function must be reentrant
 81024:   virtual void RequestSave()
 81024:   {
 81024:     mSaveRequested = true;
 81024:   }
 81024: 
 81024:   virtual void HandleSaveRequest();
 81024: 
 92114:   ThreadProfile* GetPrimaryThreadProfile()
 81024:   {
 92114:     return &mPrimaryThreadProfile;
 81024:   }
 87491: 
 92116:   JSObject *ToJSObject(JSContext *aCx);
103096:   JSObject *GetMetaJSObject(JSObjectBuilder& b);
 92116: 
103915:   const bool ProfileJS() { return mProfileJS; }
103915: 
 87491: private:
 87491:   // Not implemented on platforms which do not support backtracing
 93749:   void doBacktrace(ThreadProfile &aProfile, TickSample* aSample);
 87491: 
 81024: private:
 92114:   // This represent the application's main thread (SAMPLER_INIT)
 92114:   ThreadProfile mPrimaryThreadProfile;
103720:   TimeStamp mStartTime;
 81024:   bool mSaveRequested;
 87196:   bool mUseStackWalk;
 87413:   bool mJankOnly;
103915:   bool mProfileJS;
 81024: };
 81024: 
 95506: std::string GetSharedLibraryInfoString();
 95506: 
104276: static JSBool
104276: WriteCallback(const jschar *buf, uint32_t len, void *data)
104276: {
104276:   std::ofstream& stream = *static_cast<std::ofstream*>(data);
110974:   nsAutoCString profile = NS_ConvertUTF16toUTF8(buf, len);
104276:   stream << profile.Data();
104276:   return JS_TRUE;
104276: }
104276: 
 81024: /**
 81024:  * This is an event used to save the profile on the main thread
 81024:  * to be sure that it is not being modified while saving.
 81024:  */
 81024: class SaveProfileTask : public nsRunnable {
 81024: public:
 81024:   SaveProfileTask() {}
 81024: 
 81024:   NS_IMETHOD Run() {
 98877:     TableTicker *t = tlsTicker.get();
 81024: 
 99032:     // Pause the profiler during saving.
 99032:     // This will prevent us from recording sampling
 99032:     // regarding profile saving. This will also
 99032:     // prevent bugs caused by the circular buffer not
 99032:     // being thread safe. Bug 750989.
104095:     t->SetPaused(true);
104095: 
104276:     // Get file path
114819: #ifdef MOZ_WIDGET_ANDROID
106307:     nsCString tmpPath;
106307:     tmpPath.AppendPrintf("/sdcard/profile_%i_%i.txt", XRE_GetProcessType(), getpid());
106307: #else
104095:     nsCOMPtr<nsIFile> tmpFile;
110974:     nsAutoCString tmpPath;
104095:     if (NS_FAILED(NS_GetSpecialDirectory(NS_OS_TEMP_DIR, getter_AddRefs(tmpFile)))) {
104095:       LOG("Failed to find temporary directory.");
104095:       return NS_ERROR_FAILURE;
104095:     }
104095:     tmpPath.AppendPrintf("profile_%i_%i.txt", XRE_GetProcessType(), getpid());
104095: 
104095:     nsresult rv = tmpFile->AppendNative(tmpPath);
104095:     if (NS_FAILED(rv))
104095:       return rv;
104095: 
104095:     rv = tmpFile->GetNativePath(tmpPath);
104095:     if (NS_FAILED(rv))
104095:       return rv;
106307: #endif
104095: 
104276:     // Create a JSContext to run a JSObjectBuilder :(
104276:     // Based on XPCShellEnvironment
104276:     JSRuntime *rt;
104276:     JSContext *cx;
104276:     nsCOMPtr<nsIJSRuntimeService> rtsvc = do_GetService("@mozilla.org/js/xpc/RuntimeService;1");
104276:     if (!rtsvc || NS_FAILED(rtsvc->GetRuntime(&rt)) || !rt) {
104276:       LOG("failed to get RuntimeService");
104276:       return NS_ERROR_FAILURE;;
104276:     }
104276: 
104276:     cx = JS_NewContext(rt, 8192);
104276:     if (!cx) {
104276:       LOG("Failed to get context");
104276:       return NS_ERROR_FAILURE;
104276:     }
104276: 
104276:     {
104276:       JSAutoRequest ar(cx);
104276:       static JSClass c = {
104276:           "global", JSCLASS_GLOBAL_FLAGS,
104276:           JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
104276:           JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub
104276:       };
104276:       JSObject *obj = JS_NewGlobalObject(cx, &c, NULL);
104276: 
 93931:       std::ofstream stream;
104095:       stream.open(tmpPath.get());
104276:       // Pause the profiler during saving.
104276:       // This will prevent us from recording sampling
104276:       // regarding profile saving. This will also
104276:       // prevent bugs caused by the circular buffer not
104276:       // being thread safe. Bug 750989.
104276:       t->SetPaused(true);
 93931:       if (stream.is_open()) {
109257:         JSAutoCompartment autoComp(cx, obj);
104276:         JSObject* profileObj = mozilla_sampler_get_profile_data(cx);
104276:         jsval val = OBJECT_TO_JSVAL(profileObj);
106838:         JS_Stringify(cx, &val, nullptr, JSVAL_NULL, WriteCallback, &stream);
 93931:         stream.close();
104095:         LOGF("Saved to %s", tmpPath.get());
 81024:       } else {
 81024:         LOG("Fail to open profile log file.");
 81024:       }
104276:     }
104276:     JS_EndRequest(cx);
104276:     JS_DestroyContext(cx);
104276: 
 99032:     t->SetPaused(false);
 81024: 
 81024:     return NS_OK;
 81024:   }
 81024: };
 81024: 
 81024: void TableTicker::HandleSaveRequest()
 81024: {
 81024:   if (!mSaveRequested)
 81024:     return;
 81024:   mSaveRequested = false;
 81024: 
 81024:   // TODO: Use use the ipc/chromium Tasks here to support processes
 81024:   // without XPCOM.
 81024:   nsCOMPtr<nsIRunnable> runnable = new SaveProfileTask();
 81024:   NS_DispatchToMainThread(runnable);
 81024: }
 81024: 
103096: JSObject* TableTicker::GetMetaJSObject(JSObjectBuilder& b)
103096: {
103096:   JSObject *meta = b.CreateObject();
103096: 
103096:   b.DefineProperty(meta, "version", 2);
103096:   b.DefineProperty(meta, "interval", interval());
103096:   b.DefineProperty(meta, "stackwalk", mUseStackWalk);
103096:   b.DefineProperty(meta, "jank", mJankOnly);
103096:   b.DefineProperty(meta, "processType", XRE_GetProcessType());
103096: 
103096:   nsresult res;
103096:   nsCOMPtr<nsIHttpProtocolHandler> http = do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &res);
103096:   if (!NS_FAILED(res)) {
110974:     nsAutoCString string;
103096: 
103096:     res = http->GetPlatform(string);
103096:     if (!NS_FAILED(res))
103096:       b.DefineProperty(meta, "platform", string.Data());
103096: 
103096:     res = http->GetOscpu(string);
103096:     if (!NS_FAILED(res))
103096:       b.DefineProperty(meta, "oscpu", string.Data());
103096: 
103096:     res = http->GetMisc(string);
103096:     if (!NS_FAILED(res))
103096:       b.DefineProperty(meta, "misc", string.Data());
103096:   }
103096: 
103096:   nsCOMPtr<nsIXULRuntime> runtime = do_GetService("@mozilla.org/xre/runtime;1");
103096:   if (runtime) {
110974:     nsAutoCString string;
103096: 
103096:     res = runtime->GetXPCOMABI(string);
103096:     if (!NS_FAILED(res))
103096:       b.DefineProperty(meta, "abi", string.Data());
103096: 
103096:     res = runtime->GetWidgetToolkit(string);
103096:     if (!NS_FAILED(res))
103096:       b.DefineProperty(meta, "toolkit", string.Data());
103096:   }
103096: 
103096:   nsCOMPtr<nsIXULAppInfo> appInfo = do_GetService("@mozilla.org/xre/app-info;1");
103096:   if (appInfo) {
110974:     nsAutoCString string;
103096: 
103096:     res = appInfo->GetName(string);
103096:     if (!NS_FAILED(res))
103096:       b.DefineProperty(meta, "product", string.Data());
103096:   }
103096: 
103096:   return meta;
103096: }
103096: 
 92116: JSObject* TableTicker::ToJSObject(JSContext *aCx)
 92116: {
 92116:   JSObjectBuilder b(aCx);
 92116: 
 92116:   JSObject *profile = b.CreateObject();
 92116: 
104276:   // Put shared library info
104276:   b.DefineProperty(profile, "libs", GetSharedLibraryInfoString().c_str());
104276: 
 92116:   // Put meta data
103096:   JSObject *meta = GetMetaJSObject(b);
103096:   b.DefineProperty(profile, "meta", meta);
 92116: 
 92116:   // Lists the samples for each ThreadProfile
 92116:   JSObject *threads = b.CreateArray();
 92116:   b.DefineProperty(profile, "threads", threads);
 92116: 
 92116:   // For now we only have one thread
 99032:   SetPaused(true);
 92116:   JSObject* threadSamples = GetPrimaryThreadProfile()->ToJSObject(aCx);
 92116:   b.ArrayPush(threads, threadSamples);
 99032:   SetPaused(false);
 92116: 
 92116:   return profile;
 92116: }
 92116: 
104125: static
108151: void addProfileEntry(volatile StackEntry &entry, ThreadProfile &aProfile,
108151:                      ProfileStack *stack, void *lastpc)
104125: {
108151:   int lineno = -1;
108151: 
104125:   // First entry has tagName 's' (start)
104125:   // Check for magic pointer bit 1 to indicate copy
108148:   const char* sampleLabel = entry.label();
108148:   if (entry.isCopyLabel()) {
104125:     // Store the string using 1 or more 'd' (dynamic) tags
104125:     // that will happen to the preceding tag
104125: 
104125:     aProfile.addTag(ProfileEntry('c', ""));
104125:     // Add one to store the null termination
104125:     size_t strLen = strlen(sampleLabel) + 1;
104125:     for (size_t j = 0; j < strLen;) {
104125:       // Store as many characters in the void* as the platform allows
104125:       char text[sizeof(void*)];
104125:       for (size_t pos = 0; pos < sizeof(void*) && j+pos < strLen; pos++) {
104125:         text[pos] = sampleLabel[j+pos];
104125:       }
104125:       j += sizeof(void*)/sizeof(char);
104125:       // Cast to *((void**) to pass the text data to a void*
104125:       aProfile.addTag(ProfileEntry('d', *((void**)(&text[0]))));
104125:     }
108151:     if (entry.js()) {
108151:       if (!entry.pc()) {
108151:         // The JIT only allows the top-most entry to have a NULL pc
108151:         MOZ_ASSERT(&entry == &stack->mStack[stack->stackSize() - 1]);
108151:         // If stack-walking was disabled, then that's just unfortunate
108151:         if (lastpc) {
108151:           jsbytecode *jspc = js::ProfilingGetPC(stack->mRuntime, entry.script(),
108151:                                                 lastpc);
108151:           if (jspc) {
108151:             lineno = JS_PCToLineNumber(NULL, entry.script(), jspc);
108151:           }
108151:         }
108151:       } else {
108151:         lineno = JS_PCToLineNumber(NULL, entry.script(), entry.pc());
108151:       }
108151:     } else {
108151:       lineno = entry.line();
108151:     }
104125:   } else {
104125:     aProfile.addTag(ProfileEntry('c', sampleLabel));
108151:     lineno = entry.line();
108151:   }
108151:   if (lineno != -1) {
108151:     aProfile.addTag(ProfileEntry('n', lineno));
104125:   }
104125: }
 89959: 
 86346: #ifdef USE_BACKTRACE
 93709: void TableTicker::doBacktrace(ThreadProfile &aProfile, TickSample* aSample)
 86346: {
 86346:   void *array[100];
 86346:   int count = backtrace (array, 100);
 86346: 
 95530:   aProfile.addTag(ProfileEntry('s', "(root)"));
 87196: 
 87196:   for (int i = 0; i < count; i++) {
 87196:     if( (intptr_t)array[i] == -1 ) break;
 98028:     aProfile.addTag(ProfileEntry('l', (void*)array[i]));
 86346:   }
 86346: }
 86346: #endif
 86346: 
 89959: 
 87491: #ifdef USE_NS_STACKWALK
 87491: typedef struct {
 87491:   void** array;
104125:   void** sp_array;
 87491:   size_t size;
 87491:   size_t count;
 87491: } PCArray;
 87491: 
 87491: static
104124: void StackWalkCallback(void* aPC, void* aSP, void* aClosure)
 87491: {
 87491:   PCArray* array = static_cast<PCArray*>(aClosure);
 87491:   if (array->count >= array->size) {
 87491:     // too many frames, ignore
 87491:     return;
 87491:   }
104125:   array->sp_array[array->count] = aSP;
104125:   array->array[array->count] = aPC;
104125:   array->count++;
 87491: }
 87491: 
 93709: void TableTicker::doBacktrace(ThreadProfile &aProfile, TickSample* aSample)
 87491: {
 89959: #ifndef XP_MACOSX
 87491:   uintptr_t thread = GetThreadHandle(platform_data());
 87491:   MOZ_ASSERT(thread);
 89959: #endif
 87491:   void* pc_array[1000];
104125:   void* sp_array[1000];
 87491:   PCArray array = {
 87491:     pc_array,
104125:     sp_array,
 87491:     mozilla::ArrayLength(pc_array),
 87491:     0
 87491:   };
 93827: 
 93827:   // Start with the current function.
104124:   StackWalkCallback(aSample->pc, aSample->sp, &array);
 93827: 
 89959: #ifdef XP_MACOSX
 91921:   pthread_t pt = GetProfiledThread(platform_data());
 91921:   void *stackEnd = reinterpret_cast<void*>(-1);
 91921:   if (pt)
 92113:     stackEnd = static_cast<char*>(pthread_get_stackaddr_np(pt));
123801:   nsresult rv = NS_OK;
123801:   if (aSample->fp >= aSample->sp && aSample->fp <= stackEnd)
123801:     rv = FramePointerStackWalk(StackWalkCallback, 0, &array, reinterpret_cast<void**>(aSample->fp), stackEnd);
 89959: #else
 87491:   nsresult rv = NS_StackWalk(StackWalkCallback, 0, &array, thread);
 89959: #endif
 87491:   if (NS_SUCCEEDED(rv)) {
 95632:     aProfile.addTag(ProfileEntry('s', "(root)"));
 87491: 
104125:     ProfileStack* stack = aProfile.GetStack();
104125:     int pseudoStackPos = 0;
104125: 
104125:     /* We have two stacks, the native C stack we extracted from unwinding,
104125:      * and the pseudostack we managed during execution. We want to consolidate
104125:      * the two in order. We do so by merging using the approximate stack address
104125:      * when each entry was push. When pushing JS entry we may not now the stack
104125:      * address in which case we have a NULL stack address in which case we assume
104125:      * that it follows immediatly the previous element.
104125:      *
104125:      *  C Stack | Address    --  Pseudo Stack | Address
104125:      *  main()  | 0x100          run_js()     | 0x40
104125:      *  start() | 0x80           jsCanvas()   | NULL
104125:      *  timer() | 0x50           drawLine()   | NULL
104125:      *  azure() | 0x10
104125:      *
104125:      * Merged: main(), start(), timer(), run_js(), jsCanvas(), drawLine(), azure()
104125:      */
104125:     // i is the index in C stack starting at main and decreasing
104125:     // pseudoStackPos is the position in the Pseudo stack starting
104125:     // at the first frame (run_js in the example) and increasing.
 87491:     for (size_t i = array.count; i > 0; --i) {
108148:       while (pseudoStackPos < stack->stackSize()) {
104125:         volatile StackEntry& entry = stack->mStack[pseudoStackPos];
104125: 
108148:         if (entry.stackAddress() < array.sp_array[i-1] && entry.stackAddress())
104125:           break;
104125: 
108151:         addProfileEntry(entry, aProfile, stack, array.array[0]);
104125:         pseudoStackPos++;
104125:       }
104125: 
 98028:       aProfile.addTag(ProfileEntry('l', (void*)array.array[i-1]));
 87491:     }
 87491:   }
 87491: }
 87491: #endif
 87491: 
 93709: #if defined(USE_LIBUNWIND) && defined(ANDROID)
 93709: void TableTicker::doBacktrace(ThreadProfile &aProfile, TickSample* aSample)
 93709: {
 93709:   void* pc_array[1000];
 93709:   size_t count = 0;
 93709: 
 93709:   unw_cursor_t cursor; unw_context_t uc;
 93709:   unw_word_t ip;
 93709:   unw_getcontext(&uc);
 93709: 
 93709:   // Dirty hack: replace the registers with values from the signal handler
 93709:   // We do this in order to avoid the overhead of walking up to reach the
 93709:   // signal handler frame, and the possibility that libunwind fails to
 93709:   // handle it correctly.
 93709:   unw_tdep_context_t *unw_ctx = reinterpret_cast<unw_tdep_context_t*> (&uc);
 93709:   mcontext_t& mcontext = reinterpret_cast<ucontext_t*> (aSample->context)->uc_mcontext;
121785: #define REPLACE_REG(num) unw_ctx->regs[num] = (&mcontext.arm_r0)[num]
 93709:   REPLACE_REG(0);
 93709:   REPLACE_REG(1);
 93709:   REPLACE_REG(2);
 93709:   REPLACE_REG(3);
 93709:   REPLACE_REG(4);
 93709:   REPLACE_REG(5);
 93709:   REPLACE_REG(6);
 93709:   REPLACE_REG(7);
 93709:   REPLACE_REG(8);
 93709:   REPLACE_REG(9);
 93709:   REPLACE_REG(10);
 93709:   REPLACE_REG(11);
 93709:   REPLACE_REG(12);
 93709:   REPLACE_REG(13);
 93709:   REPLACE_REG(14);
 93709:   REPLACE_REG(15);
 93709: #undef REPLACE_REG
 93709:   unw_init_local(&cursor, &uc);
 93709:   while (count < ArrayLength(pc_array) &&
 93709:          unw_step(&cursor) > 0) {
 93709:     unw_get_reg(&cursor, UNW_REG_IP, &ip);
 93709:     pc_array[count++] = reinterpret_cast<void*> (ip);
 93709:   }
 93709: 
 95500:   aProfile.addTag(ProfileEntry('s', "(root)"));
 93709:   for (size_t i = count; i > 0; --i) {
 98028:     aProfile.addTag(ProfileEntry('l', reinterpret_cast<void*>(pc_array[i - 1])));
 93709:   }
 93709: }
 93709: #endif
 93709: 
 86346: static
 92114: void doSampleStackTrace(ProfileStack *aStack, ThreadProfile &aProfile, TickSample *sample)
 86346: {
 86346:   // Sample
 86346:   // 's' tag denotes the start of a sample block
 86346:   // followed by 0 or more 'c' tags.
103095:   aProfile.addTag(ProfileEntry('s', "(root)"));
108148:   for (uint32_t i = 0; i < aStack->stackSize(); i++) {
108151:     addProfileEntry(aStack->mStack[i], aProfile, aStack, nullptr);
 86346:   }
 95500: #ifdef ENABLE_SPS_LEAF_DATA
 95500:   if (sample) {
 98028:     aProfile.addTag(ProfileEntry('l', (void*)sample->pc));
103605: #ifdef ENABLE_ARM_LR_SAVING
103605:     aProfile.addTag(ProfileEntry('L', (void*)sample->lr));
103605: #endif
 95500:   }
 95500: #endif
 86346: }
 81024: 
 87847: /* used to keep track of the last event that we sampled during */
 87847: unsigned int sLastSampledEventGeneration = 0;
 87847: 
 87847: /* a counter that's incremented everytime we get responsiveness event
 87847:  * note: it might also be worth tracking everytime we go around
 87847:  * the event loop */
 87847: unsigned int sCurrentEventGeneration = 0;
 87847: /* we don't need to worry about overflow because we only treat the
 87847:  * case of them being the same as special. i.e. we only run into
 87847:  * a problem if 2^32 events happen between samples that we need
 87847:  * to know are associated with different events */
 87847: 
 81024: void TableTicker::Tick(TickSample* sample)
 81024: {
 81024:   // Marker(s) come before the sample
 92115:   ProfileStack* stack = mPrimaryThreadProfile.GetStack();
 92115:   for (int i = 0; stack->getMarker(i) != NULL; i++) {
 92115:     mPrimaryThreadProfile.addTag(ProfileEntry('m', stack->getMarker(i)));
 81024:   }
 92115:   stack->mQueueClearMarker = true;
 81024: 
 92112:   bool recordSample = true;
 92112:   if (mJankOnly) {
 87847:     // if we are on a different event we can discard any temporary samples
 87847:     // we've kept around
 87847:     if (sLastSampledEventGeneration != sCurrentEventGeneration) {
 87847:       // XXX: we also probably want to add an entry to the profile to help
 87847:       // distinguish which samples are part of the same event. That, or record
 87847:       // the event generation in each sample
 92114:       mPrimaryThreadProfile.erase();
 87847:     }
 87847:     sLastSampledEventGeneration = sCurrentEventGeneration;
 87847: 
 87413:     recordSample = false;
 87413:     // only record the events when we have a we haven't seen a tracer event for 100ms
 87413:     if (!sLastTracerEvent.IsNull()) {
 87413:       TimeDuration delta = sample->timestamp - sLastTracerEvent;
 87413:       if (delta.ToMilliseconds() > 100.0) {
 87413:           recordSample = true;
 87413:       }
 87413:     }
 87413:   }
 87413: 
 93709: #if defined(USE_BACKTRACE) || defined(USE_NS_STACKWALK) || defined(USE_LIBUNWIND)
 87196:   if (mUseStackWalk) {
 93709:     doBacktrace(mPrimaryThreadProfile, sample);
 87196:   } else {
 92115:     doSampleStackTrace(stack, mPrimaryThreadProfile, sample);
 87196:   }
 86346: #else
 92115:   doSampleStackTrace(stack, mPrimaryThreadProfile, sample);
 86346: #endif
 87847: 
 87847:   if (recordSample)
 92114:     mPrimaryThreadProfile.flush();
 81024: 
103719:   if (!sLastTracerEvent.IsNull() && sample) {
 86164:     TimeDuration delta = sample->timestamp - sLastTracerEvent;
 92114:     mPrimaryThreadProfile.addTag(ProfileEntry('r', delta.ToMilliseconds()));
 84182:   }
103720: 
103720:   if (sample) {
103720:     TimeDuration delta = sample->timestamp - mStartTime;
103720:     mPrimaryThreadProfile.addTag(ProfileEntry('t', delta.ToMilliseconds()));
103720:   }
111209: 
111209:   if (sLastFrameNumber != sFrameNumber) {
111209:     mPrimaryThreadProfile.addTag(ProfileEntry('f', sFrameNumber));
111209:     sLastFrameNumber = sFrameNumber;
111209:   }
 84182: }
 84182: 
 93931: std::ostream& operator<<(std::ostream& stream, const ThreadProfile& profile)
 84182: {
 93931:   int readPos = profile.mReadPos;
 93931:   while (readPos != profile.mLastFlushPos) {
 93931:     stream << profile.mEntries[readPos];
 93931:     readPos = (readPos + 1) % profile.mEntrySize;
 93931:   }
 93931:   return stream;
 93931: }
 93931: 
 93931: std::ostream& operator<<(std::ostream& stream, const ProfileEntry& entry)
 93931: {
103850:   if (entry.mTagName == 'r' || entry.mTagName == 't') {
 93931:     stream << entry.mTagName << "-" << std::fixed << entry.mTagFloat << "\n";
103605:   } else if (entry.mTagName == 'l' || entry.mTagName == 'L') {
 94318:     // Bug 739800 - Force l-tag addresses to have a "0x" prefix on all platforms
 94318:     // Additionally, stringstream seemed to be ignoring formatter flags.
 94318:     char tagBuff[1024];
 98028:     unsigned long long pc = (unsigned long long)(uintptr_t)entry.mTagPtr;
103605:     snprintf(tagBuff, 1024, "%c-%#llx\n", entry.mTagName, pc);
 94318:     stream << tagBuff;
103095:   } else if (entry.mTagName == 'd') {
103095:     // TODO implement 'd' tag for text profile
 84182:   } else {
 93931:     stream << entry.mTagName << "-" << entry.mTagData << "\n";
 84182:   }
 93931:   return stream;
 84182: }
 81024: 
 81024: void mozilla_sampler_init()
 81024: {
116382:   if (stack_key_initialized)
116382:     return;
116382: 
 98877:   if (!tlsStack.init() || !tlsTicker.init()) {
 81024:     LOG("Failed to init.");
 81024:     return;
 81024:   }
 84289:   stack_key_initialized = true;
 81024: 
 92114:   ProfileStack *stack = new ProfileStack();
 98877:   tlsStack.set(stack);
 84182: 
 93709: #if defined(USE_LIBUNWIND) && defined(ANDROID)
 93709:   // Only try debug_frame and exidx unwinding
 93709:   putenv("UNW_ARM_UNWIND_METHOD=5");
104252: #endif
 93709: 
104252:   // Allow the profiler to be started using signals
104252:   OS::RegisterStartHandler();
 93709: 
104252: #if defined(USE_LIBUNWIND) && defined(__arm__) && defined(MOZ_CRASHREPORTER)
104252:   // On ARM, libunwind defines a signal handler for segmentation faults.
104252:   // If SPS is enabled now, the crash reporter will override that signal
104252:   // handler, and libunwind will likely break.
 93709:   return;
 93709: #endif
 93709: 
 84182:   // We can't open pref so we use an environment variable
 84182:   // to know if we should trigger the profiler on startup
 84182:   // NOTE: Default
 84182:   const char *val = PR_GetEnv("MOZ_PROFILER_STARTUP");
 83113:   if (!val || !*val) {
 83113:     return;
 83113:   }
 83113: 
118930:   const char* features[] = {"js"
118930: #if defined(XP_WIN) || defined(XP_MACOSX)
118930:                          , "stackwalk"
118930: #endif
118930:                          };
 87178:   mozilla_sampler_start(PROFILE_DEFAULT_ENTRY, PROFILE_DEFAULT_INTERVAL,
118930:                         features, sizeof(features)/sizeof(const char*));
 84182: }
 84182: 
 84182: void mozilla_sampler_deinit()
 84182: {
 84182:   mozilla_sampler_stop();
 84182:   // We can't delete the Stack because we can be between a
 84182:   // sampler call_enter/call_exit point.
 84182:   // TODO Need to find a safe time to delete Stack
 84182: }
 84182: 
 87178: void mozilla_sampler_save()
 87178: {
 98877:   TableTicker *t = tlsTicker.get();
 84182:   if (!t) {
 84182:     return;
 84182:   }
 84182: 
 84182:   t->RequestSave();
 84182:   // We're on the main thread already so we don't
 84182:   // have to wait to handle the save request.
 84182:   t->HandleSaveRequest();
 84182: }
 84182: 
 87178: char* mozilla_sampler_get_profile()
 87178: {
 98877:   TableTicker *t = tlsTicker.get();
 84182:   if (!t) {
 84182:     return NULL;
 84182:   }
 84182: 
 93931:   std::stringstream profile;
 99032:   t->SetPaused(true);
 93931:   profile << *(t->GetPrimaryThreadProfile());
 99032:   t->SetPaused(false);
 84182: 
 93931:   std::string profileString = profile.str();
 93931:   char *rtn = (char*)malloc( (profileString.length() + 1) * sizeof(char) );
 93931:   strcpy(rtn, profileString.c_str());
 84182:   return rtn;
 84182: }
 84182: 
 91957: JSObject *mozilla_sampler_get_profile_data(JSContext *aCx)
 91957: {
 98877:   TableTicker *t = tlsTicker.get();
 91957:   if (!t) {
 91957:     return NULL;
 91957:   }
 91957: 
 92116:   return t->ToJSObject(aCx);
 91957: }
 91957: 
 91957: 
 87178: const char** mozilla_sampler_get_features()
 87178: {
 87196:   static const char* features[] = {
 93709: #if defined(MOZ_PROFILING) && (defined(USE_BACKTRACE) || defined(USE_NS_STACKWALK) || defined(USE_LIBUNWIND))
 87196:     "stackwalk",
 87196: #endif
 89347:     "jank",
103915:     "js",
 87196:     NULL
 87196:   };
 87178: 
 87178:   return features;
 87178: }
 87178: 
 84182: // Values are only honored on the first start
 87178: void mozilla_sampler_start(int aProfileEntries, int aInterval,
 87178:                            const char** aFeatures, uint32_t aFeatureCount)
 84182: {
103035:   if (!stack_key_initialized)
103035:     mozilla_sampler_init();
103035: 
 98877:   ProfileStack *stack = tlsStack.get();
 84182:   if (!stack) {
 84182:     ASSERT(false);
 84182:     return;
 84182:   }
 84182: 
 84182:   mozilla_sampler_stop();
 84182: 
113756:   TableTicker *t = new TableTicker(aInterval ? aInterval : PROFILE_DEFAULT_INTERVAL,
113756:                                    aProfileEntries ? aProfileEntries : PROFILE_DEFAULT_ENTRY,
113756:                                    stack, aFeatures, aFeatureCount);
 98877:   tlsTicker.set(t);
 81024:   t->Start();
103915:   if (t->ProfileJS())
104307:       stack->enableJSSampling();
114514: 
114514:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
114514:   if (os)
114514:     os->NotifyObservers(nullptr, "profiler-started", nullptr);
 81024: }
 81024: 
 84182: void mozilla_sampler_stop()
 81024: {
103035:   if (!stack_key_initialized)
103035:     mozilla_sampler_init();
103035: 
 98877:   TableTicker *t = tlsTicker.get();
 81024:   if (!t) {
 81024:     return;
 81024:   }
 81024: 
104307:   bool disableJS = t->ProfileJS();
103915: 
 81024:   t->Stop();
 99956:   delete t;
 98877:   tlsTicker.set(NULL);
103915:   ProfileStack *stack = tlsStack.get();
103915:   ASSERT(stack != NULL);
103915: 
104307:   if (disableJS)
104307:     stack->disableJSSampling();
114514: 
114514:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
114514:   if (os)
114514:     os->NotifyObservers(nullptr, "profiler-stopped", nullptr);
 81024: }
 81024: 
 84182: bool mozilla_sampler_is_active()
 84182: {
103035:   if (!stack_key_initialized)
103035:     mozilla_sampler_init();
103035: 
 98877:   TableTicker *t = tlsTicker.get();
 84182:   if (!t) {
 84182:     return false;
 84182:   }
 84182: 
 84182:   return t->IsActive();
 84182: }
 84182: 
 87177: double sResponsivenessTimes[100];
 87177: double sCurrResponsiveness = 0.f;
 84182: unsigned int sResponsivenessLoc = 0;
 84182: void mozilla_sampler_responsiveness(TimeStamp aTime)
 84182: {
 84182:   if (!sLastTracerEvent.IsNull()) {
 84182:     if (sResponsivenessLoc == 100) {
 84182:       for(size_t i = 0; i < 100-1; i++) {
 84182:         sResponsivenessTimes[i] = sResponsivenessTimes[i+1];
 84182:       }
 84182:       sResponsivenessLoc--;
 84182:     }
 84182:     TimeDuration delta = aTime - sLastTracerEvent;
 84182:     sResponsivenessTimes[sResponsivenessLoc++] = delta.ToMilliseconds();
 84182:   }
 87847:   sCurrentEventGeneration++;
 84182: 
 84182:   sLastTracerEvent = aTime;
 84182: }
 84182: 
 87177: const double* mozilla_sampler_get_responsiveness()
 84182: {
 84182:   return sResponsivenessTimes;
 84182: }
 84182: 
111209: void mozilla_sampler_frame_number(int frameNumber)
111209: {
111209:   sFrameNumber = frameNumber;
111209: }
123586: 
123586: void print_callback(const ProfileEntry& entry, const char* tagStringData) {
123586:   switch (entry.mTagName) {
123586:     case 's':
123586:     case 'c':
123586:       printf_stderr("  %s\n", tagStringData);
123586:   }
123586: }
123586: 
123586: void mozilla_sampler_print_location()
123586: {
123586:   if (!stack_key_initialized)
123586:     mozilla_sampler_init();
123586: 
123586:   ProfileStack *stack = tlsStack.get();
123586:   if (!stack) {
123586:     MOZ_ASSERT(false);
123586:     return;
123586:   }
123586: 
123586:   ThreadProfile threadProfile(1000, stack);
123586:   doSampleStackTrace(stack, threadProfile, NULL);
123586: 
123586:   threadProfile.flush();
123586: 
123586:   printf_stderr("Backtrace:\n");
123586:   threadProfile.IterateTags(print_callback);
123586: }
