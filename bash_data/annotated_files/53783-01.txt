49316: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
49316:  * ***** BEGIN LICENSE BLOCK *****
49316:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
49316:  *
49316:  * The contents of this file are subject to the Mozilla Public License Version
49316:  * 1.1 (the "License"); you may not use this file except in compliance with
49316:  * the License. You may obtain a copy of the License at
49316:  * http://www.mozilla.org/MPL/
49316:  *
49316:  * Software distributed under the License is distributed on an "AS IS" basis,
49316:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
49316:  * for the specific language governing rights and limitations under the
49316:  * License.
49316:  *
49316:  * The Original Code is Mozilla Corporation code.
49316:  *
49316:  * The Initial Developer of the Original Code is Mozilla Foundation.
49316:  * Portions created by the Initial Developer are Copyright (C) 2009
49316:  * the Initial Developer. All Rights Reserved.
49316:  *
49316:  * Contributor(s):
49316:  *   Bas Schouten <bschouten@mozilla.com>
49316:  *
49316:  * Alternatively, the contents of this file may be used under the terms of
49316:  * either the GNU General Public License Version 2 or later (the "GPL"), or
49316:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
49316:  * in which case the provisions of the GPL or the LGPL are applicable instead
49316:  * of those above. If you wish to allow use of your version of this file only
49316:  * under the terms of either the GPL or the LGPL, and not to allow others to
49316:  * use your version of this file under the terms of the MPL, indicate your
49316:  * decision by deleting the provisions above and replace them with the notice
49316:  * and other provisions required by the GPL or the LGPL. If you do not delete
49316:  * the provisions above, a recipient may use your version of this file under
49316:  * the terms of any one of the MPL, the GPL or the LGPL.
49316:  *
49316:  * ***** END LICENSE BLOCK ***** */
49316: 
49316: #include "DeviceManagerD3D9.h"
49316: #include "LayerManagerD3D9Shaders.h"
49316: #include "ThebesLayerD3D9.h"
49316: #include "nsIServiceManager.h"
49316: #include "nsIConsoleService.h"
49316: #include "nsPrintfCString.h"
51527: #include "nsIPrefService.h" 
51527: #include "Nv3DVUtils.h"
49316: 
49316: namespace mozilla {
49316: namespace layers {
49316: 
49316: const LPCWSTR kClassName       = L"D3D9WindowClass";
49316: 
49317: #define USE_D3D9EX
49317: 
49316: typedef IDirect3D9* (WINAPI*Direct3DCreate9Func)(
49316:   UINT SDKVersion
49316: );
49316: 
49317: typedef HRESULT (WINAPI*Direct3DCreate9ExFunc)(
49317:   UINT SDKVersion,
49317:   IDirect3D9Ex **ppD3D
49317: );
49317: 
49316: struct vertex {
49316:   float x, y;
49316: };
49316: 
49316: SwapChainD3D9::SwapChainD3D9(DeviceManagerD3D9 *aDeviceManager)
49316:   : mDeviceManager(aDeviceManager)
49316:   , mWnd(0)
49316: {
49316:   mDeviceManager->mSwapChains.AppendElement(this);
49316: }
49316: 
49316: SwapChainD3D9::~SwapChainD3D9()
49316: {
49316:   mDeviceManager->mSwapChains.RemoveElement(this);
49316: }
49316: 
49316: bool
49316: SwapChainD3D9::Init(HWND hWnd)
49316: {
49316:   RECT r;
49316:   ::GetClientRect(hWnd, &r);
49316: 
49316:   mWnd = hWnd;
49316: 
49316:   D3DPRESENT_PARAMETERS pp;
49316:   memset(&pp, 0, sizeof(D3DPRESENT_PARAMETERS));
49316: 
49706:   pp.BackBufferFormat = D3DFMT_A8R8G8B8;
49316:   pp.SwapEffect = D3DSWAPEFFECT_COPY;
49316:   pp.Windowed = TRUE;
49316:   pp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
49316:   pp.hDeviceWindow = mWnd;
49316:   if (r.left == r.right || r.top == r.bottom) {
49316:     pp.BackBufferHeight = 1;
49316:     pp.BackBufferWidth = 1;
49316:   }
49316: 
49316:   HRESULT hr = mDeviceManager->device()->
49316:     CreateAdditionalSwapChain(&pp,
49316:                               getter_AddRefs(mSwapChain));
49316: 
49316:   if (FAILED(hr)) {
49316:     NS_WARNING("Failed to create swap chain for window.");
49316:     return false;
49316:   }
49316: 
49316:   return true;
49316: }
49316: 
49316: bool
49316: SwapChainD3D9::PrepareForRendering()
49316: {
49316:   RECT r;
49316:   if (!::GetClientRect(mWnd, &r)) {
49316:     return false;
49316:   }
49316: 
49316:   if (!mDeviceManager->VerifyReadyForRendering()) {
49316:     return false;
49316:   }
49316: 
49316:   if (!mSwapChain) {
49316:     Init(mWnd);
49316:   }
49316: 
49316:   if (mSwapChain) {
49316:     nsRefPtr<IDirect3DSurface9> backBuffer;
49316:     mSwapChain->GetBackBuffer(0,
49316:                               D3DBACKBUFFER_TYPE_MONO,
49316:                               getter_AddRefs(backBuffer));
49316: 
49316:     D3DSURFACE_DESC desc;
49316:     backBuffer->GetDesc(&desc);
49316: 
49316:     if (desc.Width == r.right - r.left && desc.Height == r.bottom - r.top) {
49316:       mDeviceManager->device()->SetRenderTarget(0, backBuffer);
49316:       return true;
49316:     }
49316: 
49316:     mSwapChain = nsnull;
49316:     
49316:     Init(mWnd);
49316:     
49316:     if (!mSwapChain) {
49316:       return false;
49316:     }
49316:     
49316:     mSwapChain->GetBackBuffer(0,
49316:                               D3DBACKBUFFER_TYPE_MONO,
49316:                               getter_AddRefs(backBuffer));
49316: 
49316:     mDeviceManager->device()->SetRenderTarget(0, backBuffer);
49316:     
49316:     return true;
49316:   }
49316:   return false;
49316: }
49316: 
49316: void
49316: SwapChainD3D9::Present(const nsIntRect &aRect)
49316: {
49316:   RECT r;
49316:   r.left = aRect.x;
49316:   r.top = aRect.y;
49316:   r.right = aRect.XMost();
49316:   r.bottom = aRect.YMost();
49316: 
49316:   mSwapChain->Present(&r, &r, 0, 0, 0);
49316: }
49316: 
49316: void
49316: SwapChainD3D9::Reset()
49316: {
49316:   mSwapChain = nsnull;
49316: }
49316: 
49316: #define HAS_CAP(a, b) (((a) & (b)) == (b))
49316: #define LACKS_CAP(a, b) !(((a) & (b)) == (b))
49316: 
49316: DeviceManagerD3D9::DeviceManagerD3D9()
49317:   : mHasDynamicTextures(false)
49316: {
49316: }
49316: 
50600: DeviceManagerD3D9::~DeviceManagerD3D9()
50600: {
50600:   LayerManagerD3D9::OnDeviceManagerDestroy(this);
50600: }
50600: 
51996: NS_IMPL_ADDREF(DeviceManagerD3D9)
51996: NS_IMPL_RELEASE(DeviceManagerD3D9)
51996: 
49316: bool
49316: DeviceManagerD3D9::Init()
49316: {
49316:   WNDCLASSW wc;
49317:   HRESULT hr;
49317: 
49316:   if (!GetClassInfoW(GetModuleHandle(NULL), kClassName, &wc)) {
49316:       ZeroMemory(&wc, sizeof(WNDCLASSW));
49316:       wc.hInstance = GetModuleHandle(NULL);
49316:       wc.lpfnWndProc = ::DefWindowProc;
49316:       wc.lpszClassName = kClassName;
49316:       if (!RegisterClassW(&wc)) {
49316:           NS_WARNING("Failed to register window class for DeviceManager.");
49316:           return false;
49316:       }
49316:   }
49316: 
49393:   mFocusWnd = ::CreateWindowW(kClassName, L"D3D9Window", WS_OVERLAPPEDWINDOW,
49316:                               CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL,
49316:                               NULL, GetModuleHandle(NULL), NULL);
49316: 
49316:   if (!mFocusWnd) {
49316:     NS_WARNING("Failed to create DeviceManagerD3D9 Window.");
49316:     return false;
49316:   }
49316: 
51527:   /* Create an Nv3DVUtils instance */ 
51527:   if (!mNv3DVUtils) { 
51527:     mNv3DVUtils = new Nv3DVUtils(); 
51527:     if (!mNv3DVUtils) { 
51527:       NS_WARNING("Could not create a new instance of Nv3DVUtils.\n"); 
51527:     } 
51527:   } 
51527: 
51527:   /* Initialize the Nv3DVUtils object */ 
51527:   if (mNv3DVUtils) { 
51527:     mNv3DVUtils->Initialize(); 
51527:   } 
51527: 
49317:   HMODULE d3d9 = LoadLibraryW(L"d3d9.dll");
49317:   Direct3DCreate9Func d3d9Create = (Direct3DCreate9Func)
49317:     GetProcAddress(d3d9, "Direct3DCreate9");
49317:   Direct3DCreate9ExFunc d3d9CreateEx = (Direct3DCreate9ExFunc)
49317:     GetProcAddress(d3d9, "Direct3DCreate9Ex");
49316:   
49317: #ifdef USE_D3D9EX
49317:   if (d3d9CreateEx) {
49317:     hr = d3d9CreateEx(D3D_SDK_VERSION, getter_AddRefs(mD3D9Ex));
49317:     if (SUCCEEDED(hr)) {
49317:       mD3D9 = mD3D9Ex;
49317:     }
49317:   }
49317: #endif
49317: 
49317:   if (!mD3D9) {
49317:     if (!d3d9Create) {
49316:       return false;
49316:     }
49316: 
49317:     mD3D9 = dont_AddRef(d3d9Create(D3D_SDK_VERSION));
49317: 
49317:     if (!mD3D9) {
49317:       return false;
49317:     }
49317:   }
49316: 
49316:   D3DPRESENT_PARAMETERS pp;
49316:   memset(&pp, 0, sizeof(D3DPRESENT_PARAMETERS));
49316: 
49316:   pp.BackBufferWidth = 1;
49316:   pp.BackBufferHeight = 1;
49316:   pp.BackBufferFormat = D3DFMT_A8R8G8B8;
49316:   pp.SwapEffect = D3DSWAPEFFECT_DISCARD;
49316:   pp.Windowed = TRUE;
49316:   pp.PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
49316:   pp.hDeviceWindow = mFocusWnd;
49316: 
49317:   if (mD3D9Ex) {
49317:     hr = mD3D9Ex->CreateDeviceEx(D3DADAPTER_DEFAULT,
49317:                                  D3DDEVTYPE_HAL,
49317:                                  mFocusWnd,
49317:                                  D3DCREATE_FPU_PRESERVE |
49317:                                  D3DCREATE_MULTITHREADED |
49317:                                  D3DCREATE_MIXED_VERTEXPROCESSING,
49317:                                  &pp,
49317:                                  NULL,
49317:                                  getter_AddRefs(mDeviceEx));
49317:     if (SUCCEEDED(hr)) {
49317:       mDevice = mDeviceEx;
49317:     }
49317: 
49317:     D3DCAPS9 caps;
52040:     if (mDeviceEx && mDeviceEx->GetDeviceCaps(&caps)) {
49317:       if (LACKS_CAP(caps.Caps2, D3DCAPS2_DYNAMICTEXTURES)) {
49317:         // XXX - Should we actually hit this we'll need a CanvasLayer that
49317:         // supports static D3DPOOL_DEFAULT textures.
49317:         NS_WARNING("D3D9Ex device not used because of lack of support for \
49317:                    dynamic textures. This is unexpected.");
49317:         mDevice = nsnull;
49317:         mDeviceEx = nsnull;
49317:       }
49317:     }
49317:   }
49317: 
49317:   if (!mDevice) {
49317:     hr = mD3D9->CreateDevice(D3DADAPTER_DEFAULT,
49316:                              D3DDEVTYPE_HAL,
49316:                              mFocusWnd,
49316:                              D3DCREATE_FPU_PRESERVE |
49316:                              D3DCREATE_MULTITHREADED |
49316:                              D3DCREATE_MIXED_VERTEXPROCESSING,
49316:                              &pp,
49316:                              getter_AddRefs(mDevice));
49316: 
49316:     if (FAILED(hr)) {
49316:       NS_WARNING("Failed to create Device for DeviceManagerD3D9.");
49316:       return false;
49316:     }
49317:   }
49316: 
49316:   if (!VerifyCaps()) {
49316:     return false;
49316:   }
49316: 
51527:   /* 
51527:    * Do some post device creation setup 
51527:    */ 
51527:   if (mNv3DVUtils) { 
51527:     IUnknown* devUnknown = NULL; 
51527:     if (mDevice) { 
51527:       mDevice->QueryInterface(IID_IUnknown, (void **)&devUnknown); 
51527:     } 
51527:     mNv3DVUtils->SetDeviceInfo(devUnknown); 
51527:   } 
51527: 
49316:   hr = mDevice->CreateVertexShader((DWORD*)LayerQuadVS,
49316:                                    getter_AddRefs(mLayerVS));
49316: 
49316:   if (FAILED(hr)) {
49316:     return false;
49316:   }
49316: 
49316:   hr = mDevice->CreatePixelShader((DWORD*)RGBShaderPS,
49316:                                   getter_AddRefs(mRGBPS));
49316: 
49316:   if (FAILED(hr)) {
49316:     return false;
49316:   }
49316: 
51963:   hr = mDevice->CreatePixelShader((DWORD*)RGBAShaderPS,
51963:                                   getter_AddRefs(mRGBAPS));
51963: 
51963:   if (FAILED(hr)) {
51963:     return false;
51963:   }
51963: 
49316:   hr = mDevice->CreatePixelShader((DWORD*)YCbCrShaderPS,
49316:                                   getter_AddRefs(mYCbCrPS));
49316: 
49316:   if (FAILED(hr)) {
49316:     return false;
49316:   }
49316: 
49316:   hr = mDevice->CreatePixelShader((DWORD*)SolidColorShaderPS,
49316:                                   getter_AddRefs(mSolidColorPS));
49316: 
49316:   if (FAILED(hr)) {
49316:     return false;
49316:   }
49316: 
49316:   hr = mDevice->CreateVertexBuffer(sizeof(vertex) * 4,
49317:                                    D3DUSAGE_WRITEONLY,
49316:                                    0,
49317:                                    D3DPOOL_DEFAULT,
49316:                                    getter_AddRefs(mVB),
49316:                                    NULL);
49316: 
49316:   if (FAILED(hr)) {
49316:     return false;
49316:   }
49316: 
49316:   vertex *vertices;
49316:   hr = mVB->Lock(0, 0, (void**)&vertices, 0);
49316:   if (FAILED(hr)) {
49316:     return false;
49316:   }
49316: 
49316:   vertices[0].x = vertices[0].y = 0;
49316:   vertices[1].x = 1; vertices[1].y = 0;
49316:   vertices[2].x = 0; vertices[2].y = 1;
49316:   vertices[3].x = 1; vertices[3].y = 1;
49316: 
49316:   mVB->Unlock();
49316: 
49316:   hr = mDevice->SetStreamSource(0, mVB, 0, sizeof(vertex));
49316:   if (FAILED(hr)) {
49316:     return false;
49316:   }
49316: 
49316:   D3DVERTEXELEMENT9 elements[] = {
49316:     { 0, 0, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,
49316:       D3DDECLUSAGE_POSITION, 0 },
49316:     D3DDECL_END()
49316:   };
49316: 
49316:   mDevice->CreateVertexDeclaration(elements, getter_AddRefs(mVD));
49316: 
49316:   nsCOMPtr<nsIConsoleService>
49316:     console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
49316: 
49316:   D3DADAPTER_IDENTIFIER9 identifier;
49316:   mD3D9->GetAdapterIdentifier(D3DADAPTER_DEFAULT, 0, &identifier);
49316: 
49316:   if (console) {
49316:     nsString msg;
49316:     msg +=
49316:       NS_LITERAL_STRING("Direct3D 9 DeviceManager Initialized Succesfully.\nDriver: ");
49316:     msg += NS_ConvertUTF8toUTF16(
49316:       nsDependentCString((const char*)identifier.Driver));
49316:     msg += NS_LITERAL_STRING("\nDescription: ");
49316:     msg += NS_ConvertUTF8toUTF16(
49316:       nsDependentCString((const char*)identifier.Description));
49316:     msg += NS_LITERAL_STRING("\nVersion: ");
49316:     msg += NS_ConvertUTF8toUTF16(
49316:       nsPrintfCString("%d.%d.%d.%d",
49316:                       HIWORD(identifier.DriverVersion.HighPart),
49316:                       LOWORD(identifier.DriverVersion.HighPart),
49316:                       HIWORD(identifier.DriverVersion.LowPart),
49316:                       LOWORD(identifier.DriverVersion.LowPart)));
49316:     console->LogStringMessage(msg.get());
49316:   }
49316: 
49316:   return true;
49316: }
49316: 
49316: void
49316: DeviceManagerD3D9::SetupRenderState()
49316: {
49316:   mDevice->SetStreamSource(0, mVB, 0, sizeof(vertex));
49316:   mDevice->SetVertexDeclaration(mVD);
49316:   mDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
49316:   mDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
49316:   mDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
49316:   mDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
49316:   mDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
49316:   mDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, TRUE);
51314:   mDevice->SetRenderState(D3DRS_SRCBLENDALPHA, D3DBLEND_ONE);
51314:   mDevice->SetRenderState(D3DRS_DESTBLENDALPHA, D3DBLEND_INVSRCALPHA);
51314:   mDevice->SetRenderState(D3DRS_BLENDOPALPHA, D3DBLENDOP_ADD);
49316:   mDevice->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
49316:   mDevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
49316:   mDevice->SetSamplerState(1, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
49316:   mDevice->SetSamplerState(1, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
49316:   mDevice->SetSamplerState(2, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
49316:   mDevice->SetSamplerState(2, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
49316: }
49316: 
49316: already_AddRefed<SwapChainD3D9>
49316: DeviceManagerD3D9::CreateSwapChain(HWND hWnd)
49316: {
49316:   nsRefPtr<SwapChainD3D9> swapChain = new SwapChainD3D9(this);
49316:   
49316:   if (!swapChain->Init(hWnd)) {
49316:     return nsnull;
49316:   }
49316: 
49316:   return swapChain.forget();
49316: }
49316: 
49316: void
49316: DeviceManagerD3D9::SetShaderMode(ShaderMode aMode)
49316: {
49316:   switch (aMode) {
49316:     case RGBLAYER:
49316:       mDevice->SetVertexShader(mLayerVS);
49316:       mDevice->SetPixelShader(mRGBPS);
49316:       break;
51963:     case RGBALAYER:
51963:       mDevice->SetVertexShader(mLayerVS);
51963:       mDevice->SetPixelShader(mRGBAPS);
51963:       break;
49316:     case YCBCRLAYER:
49316:       mDevice->SetVertexShader(mLayerVS);
49316:       mDevice->SetPixelShader(mYCbCrPS);
49316:       break;
49316:     case SOLIDCOLORLAYER:
49316:       mDevice->SetVertexShader(mLayerVS);
49316:       mDevice->SetPixelShader(mSolidColorPS);
49316:       break;
49316:   }
49316: }
49316: 
49316: bool
49316: DeviceManagerD3D9::VerifyReadyForRendering()
49316: {
49316:   HRESULT hr = mDevice->TestCooperativeLevel();
49316: 
49316:   if (SUCCEEDED(hr)) {
49317:     if (IsD3D9Ex()) {
49317:       hr = mDeviceEx->CheckDeviceState(mFocusWnd);
49317:       if (FAILED(hr)) {
49317:         D3DPRESENT_PARAMETERS pp;
49317:         memset(&pp, 0, sizeof(D3DPRESENT_PARAMETERS));
49317: 
49317:         pp.BackBufferWidth = 1;
49317:         pp.BackBufferHeight = 1;
49317:         pp.BackBufferFormat = D3DFMT_A8R8G8B8;
49317:         pp.SwapEffect = D3DSWAPEFFECT_DISCARD;
49317:         pp.Windowed = TRUE;
49317:         pp.PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
49317:         pp.hDeviceWindow = mFocusWnd;
49317:         
49317:         hr = mDeviceEx->ResetEx(&pp, NULL);
49317:         // Handle D3DERR_DEVICEREMOVED!
49317:         if (FAILED(hr)) {
49317:           return false;
49317:         }
49317:       }
49317:     }
49316:     return true;
49316:   }
49316: 
49316:   if (hr != D3DERR_DEVICENOTRESET) {
49316:     return false;
49316:   }
49316: 
53783:   for(unsigned int i = 0; i < mLayersWithResources.Length(); i++) {
53783:     mLayersWithResources[i]->CleanResources();
49316:   }
49316:   for(unsigned int i = 0; i < mSwapChains.Length(); i++) {
49316:     mSwapChains[i]->Reset();
49316:   }
49316:   
49316:   D3DPRESENT_PARAMETERS pp;
49316:   memset(&pp, 0, sizeof(D3DPRESENT_PARAMETERS));
49316: 
49316:   pp.BackBufferWidth = 1;
49316:   pp.BackBufferHeight = 1;
49316:   pp.BackBufferFormat = D3DFMT_A8R8G8B8;
49316:   pp.SwapEffect = D3DSWAPEFFECT_DISCARD;
49316:   pp.Windowed = TRUE;
49316:   pp.PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
49316:   pp.hDeviceWindow = mFocusWnd;
49316: 
49316:   hr = mDevice->Reset(&pp);
49316: 
49316:   if (FAILED(hr)) {
49316:     return false;
49316:   }
49316: 
49316:   return true;
49316: }
49316: 
49316: bool
49316: DeviceManagerD3D9::VerifyCaps()
49316: {
49316:   D3DCAPS9 caps;
49316:   HRESULT hr = mDevice->GetDeviceCaps(&caps);
49316: 
49316:   if (FAILED(hr)) {
49316:     return false;
49316:   }
49316: 
49316:   if (LACKS_CAP(caps.DevCaps, D3DDEVCAPS_TEXTUREVIDEOMEMORY)) {
49316:     return false;
49316:   }
49316: 
49316:   if (LACKS_CAP(caps.PrimitiveMiscCaps, D3DPMISCCAPS_CULLNONE)) {
49316:     return false;
49316:   }
49316: 
49316:   if (LACKS_CAP(caps.SrcBlendCaps, D3DPBLENDCAPS_ONE) ||
49316:       LACKS_CAP(caps.SrcBlendCaps, D3DBLEND_SRCALPHA) ||
49316:       LACKS_CAP(caps.DestBlendCaps, D3DPBLENDCAPS_INVSRCALPHA)) {
49316:     return false;
49316:   }
49316: 
49316:   if (LACKS_CAP(caps.RasterCaps, D3DPRASTERCAPS_SCISSORTEST)) {
49316:     return false;
49316:   }
49316: 
49316:   if (LACKS_CAP(caps.TextureCaps, D3DPTEXTURECAPS_ALPHA) ||
49316:       HAS_CAP(caps.TextureCaps, D3DPTEXTURECAPS_SQUAREONLY) ||
49316:       (HAS_CAP(caps.TextureCaps, D3DPTEXTURECAPS_POW2) &&
49316:        LACKS_CAP(caps.TextureCaps, D3DPTEXTURECAPS_NONPOW2CONDITIONAL))) {
49316:     return false;
49316:   }
49316: 
49316:   if (LACKS_CAP(caps.TextureFilterCaps, D3DPTFILTERCAPS_MAGFLINEAR) ||
49316:       LACKS_CAP(caps.TextureFilterCaps, D3DPTFILTERCAPS_MINFLINEAR)) {
49316:     return false;
49316:   }
49316: 
49316:   if (LACKS_CAP(caps.TextureAddressCaps, D3DPTADDRESSCAPS_CLAMP)) {
49316:     return false;
49316:   }
49316: 
49316:   if (caps.MaxTextureHeight < 4096 ||
49316:       caps.MaxTextureWidth < 4096) {
49316:     return false;
49316:   }
49316: 
49316:   if ((caps.PixelShaderVersion & 0xffff) < 0x200 ||
49316:       (caps.VertexShaderVersion & 0xffff) < 0x200) {
49316:     return false;
49316:   }
49316: 
49317:   if (HAS_CAP(caps.Caps2, D3DCAPS2_DYNAMICTEXTURES)) {
49317:     mHasDynamicTextures = true;
49317:   }
49317: 
49316:   return true;
49316: }
49316: 
49316: } /* namespace layers */
49316: } /* namespace mozilla */
