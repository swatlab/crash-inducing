    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is Robert Sayre.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsString.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsScriptLoader.h"
    1: #include "nsEscape.h"
    1: #include "nsIParser.h"
    1: #include "nsIDTD.h"
    1: #include "nsNetCID.h"
    1: #include "nsNetUtil.h"
    1: #include "nsParserCIID.h"
    1: #include "nsParserCIID.h"
    1: #include "nsIContentSink.h"
    1: #include "nsIHTMLToTextSink.h"
    1: #include "nsIDocumentEncoder.h"
    1: #include "nsIDOMDocumentFragment.h"
    1: #include "nsIFragmentContentSink.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDocument.h"
    1: #include "nsIContent.h"
    1: #include "nsAttrName.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsContentCID.h"
    1: #include "nsIScriptableUnescapeHTML.h"
    1: #include "nsScriptableUnescapeHTML.h"
    1: #include "nsAutoPtr.h"
74556: #include "nsTreeSanitizer.h"
74556: #include "nsAHtml5FragmentParser.h"
74556: #include "nsHtml5Module.h"
    1: 
    1: #define XHTML_DIV_TAG "div xmlns=\"http://www.w3.org/1999/xhtml\""
    1: 
    1: NS_IMPL_ISUPPORTS1(nsScriptableUnescapeHTML, nsIScriptableUnescapeHTML)
    1: 
    1: static NS_DEFINE_CID(kCParserCID, NS_PARSER_CID);
    1: 
    1: // From /widget/HTMLConverter
    1: //
    1: // Takes HTML and converts it to plain text but in unicode.
    1: //
    1: NS_IMETHODIMP
    1: nsScriptableUnescapeHTML::Unescape(const nsAString & aFromStr, 
    1:                                    nsAString & aToStr)
    1: {
    1:   // create the parser to do the conversion.
    1:   aToStr.SetLength(0);
    1:   nsresult rv;
    1:   nsCOMPtr<nsIParser> parser = do_CreateInstance(kCParserCID, &rv);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   // convert it!
    1:   nsCOMPtr<nsIContentSink> sink;
    1: 
    1:   sink = do_CreateInstance(NS_PLAINTEXTSINK_CONTRACTID);
    1:   NS_ENSURE_TRUE(sink, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIHTMLToTextSink> textSink(do_QueryInterface(sink));
    1:   NS_ENSURE_TRUE(textSink, NS_ERROR_FAILURE);
    1: 
    1:   textSink->Initialize(&aToStr, nsIDocumentEncoder::OutputSelectionOnly
    1:                        | nsIDocumentEncoder::OutputAbsoluteLinks, 0);
    1: 
    1:   parser->SetContentSink(sink);
    1: 
    1:   parser->Parse(aFromStr, 0, NS_LITERAL_CSTRING("text/html"),
    1:                 PR_TRUE, eDTDMode_fragment);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: // The feed version of nsContentUtils::CreateContextualFragment It
    1: // creates a fragment, but doesn't go to all the effort to preserve
    1: // context like innerHTML does, because feed DOMs shouldn't have that.
    1: NS_IMETHODIMP
    1: nsScriptableUnescapeHTML::ParseFragment(const nsAString &aFragment,
    1:                                         PRBool aIsXML,
    1:                                         nsIURI* aBaseURI,
    1:                                         nsIDOMElement* aContextElement,
    1:                                         nsIDOMDocumentFragment** aReturn)
    1: {
    1:   NS_ENSURE_ARG(aContextElement);
    1:   *aReturn = nsnull;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIParser> parser = do_CreateInstance(kCParserCID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDocument> document;
    1:   nsCOMPtr<nsIDOMDocument> domDocument;
    1:   nsCOMPtr<nsIDOMNode> contextNode;
    1:   contextNode = do_QueryInterface(aContextElement);
    1:   contextNode->GetOwnerDocument(getter_AddRefs(domDocument));
    1:   document = do_QueryInterface(domDocument);
    1:   NS_ENSURE_TRUE(document, NS_ERROR_NOT_AVAILABLE);
    1: 
    1:   // stop scripts
    1:   nsRefPtr<nsScriptLoader> loader;
    1:   PRBool scripts_enabled = PR_FALSE;
    1:   if (document) {
 2007:     loader = document->ScriptLoader();
    1:     scripts_enabled = loader->GetEnabled();
    1:   }
    1:   if (scripts_enabled) {
    1:     loader->SetEnabled(PR_FALSE);
    1:   }
    1: 
    1:   // Wrap things in a div or body for parsing, but it won't show up in
    1:   // the fragment.
14205:   nsAutoTArray<nsString, 2> tagStack;
    1:   nsCAutoString base, spec;
    1:   if (aIsXML) {
    1:     // XHTML
    1:     if (aBaseURI) {
    1:       base.Append(NS_LITERAL_CSTRING(XHTML_DIV_TAG));
    1:       base.Append(NS_LITERAL_CSTRING(" xml:base=\""));
    1:       aBaseURI->GetSpec(spec);
    1:       // nsEscapeHTML is good enough, because we only need to get
    1:       // quotes, ampersands, and angle brackets
    1:       char* escapedSpec = nsEscapeHTML(spec.get());
    1:       if (escapedSpec)
    1:         base += escapedSpec;
    1:       NS_Free(escapedSpec);
    1:       base.Append(NS_LITERAL_CSTRING("\""));
 7884:       tagStack.AppendElement(NS_ConvertUTF8toUTF16(base));
    1:     }  else {
 7884:       tagStack.AppendElement(NS_LITERAL_STRING(XHTML_DIV_TAG));
    1:     }
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
74556:     nsCOMPtr<nsIContent> fragment;
74556:     if (aIsXML) {
74622:       rv = nsContentUtils::ParseFragmentXML(aFragment,
74622:                                             document,
74622:                                             tagStack,
74625:                                             PR_TRUE,
74622:                                             aReturn);
74556:       fragment = do_QueryInterface(*aReturn);
    1:     } else {
74556:       NS_NewDocumentFragment(aReturn,
74556:                              document->NodeInfoManager());
74556:       fragment = do_QueryInterface(*aReturn);
74622:       nsContentUtils::ParseFragmentHTML(aFragment,
74556:                                         fragment,
74556:                                         nsGkAtoms::body,
74556:                                         kNameSpaceID_XHTML,
74556:                                         PR_FALSE,
74556:                                         PR_TRUE);
74556:       // Now, set the base URI on all subtree roots.
74728:       if (aBaseURI) {
74556:         aBaseURI->GetSpec(spec);
74556:         nsAutoString spec16;
74556:         CopyUTF8toUTF16(spec, spec16);
74556:         nsIContent* node = fragment->GetFirstChild();
74556:         while (node) {
74556:           if (node->IsElement()) {
74556:             node->SetAttr(kNameSpaceID_XML,
74556:                           nsGkAtoms::base,
74556:                           nsGkAtoms::xml,
74556:                           spec16,
74556:                           PR_FALSE);
74556:           }
74556:           node = node->GetNextSibling();
74556:         }
74556:       }
74728:     }
74556:     if (fragment) {
74556:       nsTreeSanitizer sanitizer(PR_FALSE, PR_FALSE);
74556:       sanitizer.Sanitize(fragment);
74556:     }
    1:   }
    1: 
    1:   if (scripts_enabled)
    1:       loader->SetEnabled(PR_TRUE);
    1:   
    1:   return rv;
    1: }
